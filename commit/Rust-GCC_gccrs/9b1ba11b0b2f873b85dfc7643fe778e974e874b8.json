{"sha": "9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "node_id": "C_kwDOANBUbNoAKDliMWJhMTFiMGIyZjg3M2I4NWRmYzc2NDNmZTc3OGU5NzRlODc0Yjg", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-09-27T15:56:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-09-27T15:56:30Z"}, "message": "Merge #1546\n\n1546: Merge remote-tracking branch 'mainline/master' into ibuclaw/merge_mainline r=philberty a=ibuclaw\n\nFixes: #1544\n\nCo-authored-by: Jonathan Wakely <jwakely@redhat.com>\nCo-authored-by: GCC Administrator <gccadmin@gcc.gnu.org>\nCo-authored-by: Torbj\u00f6rn SVENSSON <torbjorn.svensson@foss.st.com>\nCo-authored-by: Mikael Morin <mikael@gcc.gnu.org>\nCo-authored-by: Harald Anlauf <anlauf@gmx.de>\nCo-authored-by: liuhongt <hongtao.liu@intel.com>\nCo-authored-by: Kewen Lin <linkw@linux.ibm.com>\nCo-authored-by: Hu, Lin1 <lin1.hu@intel.com>\nCo-authored-by: Martin Liska <mliska@suse.cz>\nCo-authored-by: Eric Botcazou <ebotcazou@adacore.com>\nCo-authored-by: Piotr Trojanek <trojanek@adacore.com>\nCo-authored-by: Boris Yakobowski <yakobowski@adacore.com>\nCo-authored-by: Justin Squirek <squirek@adacore.com>\nCo-authored-by: Tucker Taft <taft@adacore.com>\nCo-authored-by: K\u00e9vin Le Gouguec <legouguec@adacore.com>", "tree": {"sha": "b74f2216e01b6ba8812715872bef44793e352695", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b74f2216e01b6ba8812715872bef44793e352695"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjMx0uCRBK7hj4Ov3rIwAANVAIAHufvLGfzV8RLqqsnYS2Poqw\nfP4tzb9bXumnzGDdEFjmnr+EqONPuIUnYvyEZiYF/IMwuzSrfz85YejAA5Hsh3DR\nPLiPGGp2ByPwcDlKjWT9M9rAFvBLiZysgxcSnpsY49cAQfhN7Y/YHo4A7NQkQau8\nB9a0RRHb8fxrdqv6hNvVB+6QZF1TqGY2oFV6n1CBU4vdidJOubXsC4zSd0iKWlmX\nQA22zhg3r37y8ryPy5xVUrjKi8iy5jCjc52MaFwa/W7Z8LlhDysjh5ldB4SusHco\nIYlm59/qnEfNUdEx2HO0J0s43uj3IzGQfKbPb2ACJO8Hjps25v0Li7Aen3WfzJo=\n=SBhV\n-----END PGP SIGNATURE-----\n", "payload": "tree b74f2216e01b6ba8812715872bef44793e352695\nparent b71e3dc02a8fd3141080419b7fb1a24d2c4133d0\nparent 875cb50f9ff205104ee775f3b578abd56618bfc2\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1664294190 +0000\ncommitter GitHub <noreply@github.com> 1664294190 +0000\n\nMerge #1546\n\n1546: Merge remote-tracking branch 'mainline/master' into ibuclaw/merge_mainline r=philberty a=ibuclaw\n\nFixes: #1544\n\nCo-authored-by: Jonathan Wakely <jwakely@redhat.com>\nCo-authored-by: GCC Administrator <gccadmin@gcc.gnu.org>\nCo-authored-by: Torbj\u00f6rn SVENSSON <torbjorn.svensson@foss.st.com>\nCo-authored-by: Mikael Morin <mikael@gcc.gnu.org>\nCo-authored-by: Harald Anlauf <anlauf@gmx.de>\nCo-authored-by: liuhongt <hongtao.liu@intel.com>\nCo-authored-by: Kewen Lin <linkw@linux.ibm.com>\nCo-authored-by: Hu, Lin1 <lin1.hu@intel.com>\nCo-authored-by: Martin Liska <mliska@suse.cz>\nCo-authored-by: Eric Botcazou <ebotcazou@adacore.com>\nCo-authored-by: Piotr Trojanek <trojanek@adacore.com>\nCo-authored-by: Boris Yakobowski <yakobowski@adacore.com>\nCo-authored-by: Justin Squirek <squirek@adacore.com>\nCo-authored-by: Tucker Taft <taft@adacore.com>\nCo-authored-by: K\u00e9vin Le Gouguec <legouguec@adacore.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b71e3dc02a8fd3141080419b7fb1a24d2c4133d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b71e3dc02a8fd3141080419b7fb1a24d2c4133d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b71e3dc02a8fd3141080419b7fb1a24d2c4133d0"}, {"sha": "875cb50f9ff205104ee775f3b578abd56618bfc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/875cb50f9ff205104ee775f3b578abd56618bfc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/875cb50f9ff205104ee775f3b578abd56618bfc2"}], "stats": {"total": 15991, "additions": 8806, "deletions": 7185}, "files": [{"sha": "62809ef273486272f09d3d4623778b948ecdea14", "filename": ".github/bors_log_expected_warnings", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/.github%2Fbors_log_expected_warnings", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/.github%2Fbors_log_expected_warnings", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/.github%2Fbors_log_expected_warnings?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,7 +1,7 @@\n ../../../../libffi/src/x86/ffi.c:612:1: warning: label \u2018out\u2019 defined but not used [-Wunused-label]\n-../../../libcpp/expr.cc:808:18: warning: format not a string literal and no format arguments [-Wformat-security]\n-../../../libcpp/expr.cc:811:39: warning: format not a string literal and no format arguments [-Wformat-security]\n-../../../libcpp/expr.cc:821:34: warning: format not a string literal and no format arguments [-Wformat-security]\n+../../../libcpp/expr.cc:807:18: warning: format not a string literal and no format arguments [-Wformat-security]\n+../../../libcpp/expr.cc:810:39: warning: format not a string literal and no format arguments [-Wformat-security]\n+../../../libcpp/expr.cc:820:34: warning: format not a string literal and no format arguments [-Wformat-security]\n ../../../libcpp/macro.cc:186:23: warning: format not a string literal and no format arguments [-Wformat-security]\n ../../../libcpp/macro.cc:215:24: warning: format not a string literal and no format arguments [-Wformat-security]\n ../../../libcpp/macro.cc:3704:58: warning: format not a string literal and no format arguments [-Wformat-security]\n@@ -67,8 +67,8 @@\n ../../gcc/analyzer/varargs.cc:509:7: warning: too many arguments for format [-Wformat-extra-args]\n ../../gcc/analyzer/varargs.cc:520:45: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n ../../gcc/analyzer/varargs.cc:520:7: warning: too many arguments for format [-Wformat-extra-args]\n-../../gcc/c-family/c-common.cc:6612:30: warning: format not a string literal and no format arguments [-Wformat-security]\n-../../gcc/c-family/c-common.cc:6616:33: warning: format not a string literal and no format arguments [-Wformat-security]\n+../../gcc/c-family/c-common.cc:6623:30: warning: format not a string literal and no format arguments [-Wformat-security]\n+../../gcc/c-family/c-common.cc:6627:33: warning: format not a string literal and no format arguments [-Wformat-security]\n ../../gcc/c/c-convert.cc:84:31: warning: format not a string literal and no format arguments [-Wformat-security]\n ../../gcc/c/c-typeck.cc:11921:42: warning: format not a string literal and no format arguments [-Wformat-security]\n ../../gcc/c/c-typeck.cc:3713:28: warning: format not a string literal and no format arguments [-Wformat-security]\n@@ -83,8 +83,6 @@\n ../../gcc/config/i386/i386.cc:2565:8: warning: unknown conversion type character \u2018{\u2019 in format [-Wformat=]\n ../../gcc/config/i386/i386.cc:2565:8: warning: unknown conversion type character \u2018}\u2019 in format [-Wformat=]\n ../../gcc/diagnostic.cc:2206:52: warning: format not a string literal and no format arguments [-Wformat-security]\n-../../gcc/doc/sourcebuild.texi:1452: warning: node `Add Options' is next for `Effective-Target Keywords' in menu but not in sectioning\n-../../gcc/doc/sourcebuild.texi:2946: warning: node `Effective-Target Keywords' is prev for `Add Options' in menu but not in sectioning\n ../../gcc/fold-const.cc:314:42: warning: format not a string literal and no format arguments [-Wformat-security]\n ../../gcc/gcc.cc:10475:12: warning: ignoring return value of \u2018ssize_t read(int, void*, size_t)\u2019, declared with attribute warn_unused_result [-Wunused-result]\n ../../gcc/gcc.cc:7708:9: warning: ignoring return value of \u2018ssize_t write(int, const void*, size_t)\u2019, declared with attribute warn_unused_result [-Wunused-result]\n@@ -103,7 +101,7 @@\n ../../gcc/lto/lto-common.cc:2075:10: warning: ignoring return value of \u2018int fscanf(FILE*, const char*, ...)\u2019, declared with attribute warn_unused_result [-Wunused-result]\n ../../gcc/lto/lto-common.cc:2077:9: warning: ignoring return value of \u2018size_t fread(void*, size_t, size_t, FILE*)\u2019, declared with attribute warn_unused_result [-Wunused-result]\n ../../gcc/lto/lto-common.cc:2097:10: warning: ignoring return value of \u2018int fscanf(FILE*, const char*, ...)\u2019, declared with attribute warn_unused_result [-Wunused-result]\n-../../gcc/omp-low.cc:10629:19: warning: \u2018T\u2019 conversion used within a quoted sequence [-Wformat=]\n+../../gcc/omp-low.cc:10632:19: warning: \u2018T\u2019 conversion used within a quoted sequence [-Wformat=]\n ../../gcc/omp-low.cc:1547:23: warning: \u2018T\u2019 conversion used within a quoted sequence [-Wformat=]\n ../../gcc/omp-low.cc:1552:23: warning: \u2018T\u2019 conversion used within a quoted sequence [-Wformat=]\n ../../gcc/omp-oacc-kernels-decompose.cc:1500:23: warning: \u2018T\u2019 conversion used within a quoted sequence [-Wformat=]\n@@ -129,9 +127,9 @@\n ../../gcc/tree-diagnostic-path.cc:68:23: warning: unknown conversion type character \u2018@\u2019 in format [-Wformat=]\n ../../gcc/tree-diagnostic-path.cc:68:26: warning: format \u2018%s\u2019 expects argument of type \u2018char*\u2019, but argument 3 has type \u2018diagnostic_event_id_t*\u2019 [-Wformat=]\n ../../gcc/tree-ssa-sccvn.cc:280:67: warning: format not a string literal and no format arguments [-Wformat-security]\n-../../libcpp/expr.cc:808:18: warning: format not a string literal and no format arguments [-Wformat-security]\n-../../libcpp/expr.cc:811:39: warning: format not a string literal and no format arguments [-Wformat-security]\n-../../libcpp/expr.cc:821:34: warning: format not a string literal and no format arguments [-Wformat-security]\n+../../libcpp/expr.cc:807:18: warning: format not a string literal and no format arguments [-Wformat-security]\n+../../libcpp/expr.cc:810:39: warning: format not a string literal and no format arguments [-Wformat-security]\n+../../libcpp/expr.cc:820:34: warning: format not a string literal and no format arguments [-Wformat-security]\n ../../libcpp/macro.cc:186:23: warning: format not a string literal and no format arguments [-Wformat-security]\n ../../libcpp/macro.cc:215:24: warning: format not a string literal and no format arguments [-Wformat-security]\n ../../libcpp/macro.cc:3704:58: warning: format not a string literal and no format arguments [-Wformat-security]"}, {"sha": "9aee34d34ccf5282607becfb952e6ff7dadb23cb", "filename": "ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,3 +1,7 @@\n+2022-09-26  Jeff Law  <jlaw@ventanamicro.com>\n+\n+\t* MAINTAINERS: Update my email address and DCO entry.\n+\n 2022-09-23  Paul-Antoine Arras  <pa@codesourcery.com>\n \n \t* MAINTAINERS (Write After Approval): Add myself."}, {"sha": "11fa8bc6dbd9f3cd68efa433e9f9bf459cd6476a", "filename": "MAINTAINERS", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/MAINTAINERS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/MAINTAINERS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/MAINTAINERS?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -30,7 +30,7 @@ Richard Biener\t\t\t\t\t<rguenther@suse.de>\n Richard Earnshaw\t\t\t\t<richard.earnshaw@arm.com>\n Jakub Jelinek\t\t\t\t\t<jakub@redhat.com>\n Richard Kenner\t\t\t\t\t<kenner@nyu.edu>\n-Jeff Law\t\t\t\t\t<jeffreyalaw@gmail.com>\n+Jeff Law\t\t\t\t\t<jlaw@ventanamicro.com>\n Michael Meissner\t\t\t\t<gnu@the-meissners.org>\n Jason Merrill\t\t\t\t\t<jason@redhat.com>\n David S. Miller\t\t\t\t\t<davem@redhat.com>\n@@ -725,6 +725,7 @@ Matthias Kretz\t\t\t\t\t<m.kretz@gsi.de>\n Tim Lange\t\t\t\t\t<mail@tim-lange.me>\n Jeff Law\t\t\t\t\t<jeffreyalaw@gmail.com>\n Jeff Law\t\t\t\t\t<jlaw@tachyum.com>\n+Jeff Law\t\t\t\t\t<jlaw@ventanamicro.com>\n Immad Mir\t\t\t\t\t<mir@sourceware.org>\n Gaius Mulley\t\t\t\t\t<gaiusmod2@gmail.com>\n Siddhesh Poyarekar\t\t\t\t<siddhesh@gotplt.org>"}, {"sha": "630972367f093981cc8dab2ca45d78e85306069f", "filename": "fixincludes/fixincl.x", "status": "modified", "additions": 149, "deletions": 5, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/fixincludes%2Ffixincl.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/fixincludes%2Ffixincl.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fixincludes%2Ffixincl.x?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -2,11 +2,11 @@\n  *\n  * DO NOT EDIT THIS FILE   (fixincl.x)\n  *\n- * It has been AutoGen-ed  February 27, 2022 at 07:47:03 PM by AutoGen 5.18.16\n+ * It has been AutoGen-ed  September 27, 2022 at 12:21:44 PM by AutoGen 5.18.16\n  * From the definitions    inclhack.def\n  * and the template file   fixincl\n  */\n-/* DO NOT SVN-MERGE THIS FILE, EITHER Sun Feb 27 19:47:03 UTC 2022\n+/* DO NOT SVN-MERGE THIS FILE, EITHER Tue Sep 27 12:21:44 CEST 2022\n  *\n  * You must regenerate it.  Use the ./genfixes script.\n  *\n@@ -15,7 +15,7 @@\n  * certain ANSI-incompatible system header files which are fixed to work\n  * correctly with ANSI C and placed in a directory that GNU C will search.\n  *\n- * This file contains 267 fixup descriptions.\n+ * This file contains 270 fixup descriptions.\n  *\n  * See README for more information.\n  *\n@@ -4105,6 +4105,132 @@ static const char* apzGlibc_C99_Inline_4Patch[] = {\n     \"%0 __attribute__ ((__gnu_inline__))\",\n     (char*)NULL };\n \n+/* * * * * * * * * * * * * * * * * * * * * * * * * *\n+ *\n+ *  Description of Glibc_Cxx_Floatn_1 fix\n+ */\n+tSCC zGlibc_Cxx_Floatn_1Name[] =\n+     \"glibc_cxx_floatn_1\";\n+\n+/*\n+ *  File name selection pattern\n+ */\n+tSCC zGlibc_Cxx_Floatn_1List[] =\n+  \"bits/floatn.h\\0bits/floatn-common.h\\0*/bits/floatn.h\\0*/bits/floatn-common.h\\0\";\n+/*\n+ *  Machine/OS name selection pattern\n+ */\n+#define apzGlibc_Cxx_Floatn_1Machs (const char**)NULL\n+\n+/*\n+ *  content selection pattern - do fix if pattern found\n+ */\n+tSCC zGlibc_Cxx_Floatn_1Select0[] =\n+       \"^([ \\t]*#[ \\t]*if !__GNUC_PREREQ \\\\(7, 0\\\\) \\\\|\\\\| )defined __cplusplus\\n\\\n+(([ \\t]*/\\\\*[^\\n\\\n+]*\\\\*/\\n\\\n+)?([ \\t]*#[ \\t]*if[^\\n\\\n+]*\\n\\\n+)?[ \\t]*#[ \\t]*define __f(16|32|64|128)x?\\\\()\";\n+\n+#define    GLIBC_CXX_FLOATN_1_TEST_CT  1\n+static tTestDesc aGlibc_Cxx_Floatn_1Tests[] = {\n+  { TT_EGREP,    zGlibc_Cxx_Floatn_1Select0, (regex_t*)NULL }, };\n+\n+/*\n+ *  Fix Command Arguments for Glibc_Cxx_Floatn_1\n+ */\n+static const char* apzGlibc_Cxx_Floatn_1Patch[] = {\n+    \"format\",\n+    \"%1(defined __cplusplus && !__GNUC_PREREQ (13, 0))\\n\\\n+%2\",\n+    (char*)NULL };\n+\n+/* * * * * * * * * * * * * * * * * * * * * * * * * *\n+ *\n+ *  Description of Glibc_Cxx_Floatn_2 fix\n+ */\n+tSCC zGlibc_Cxx_Floatn_2Name[] =\n+     \"glibc_cxx_floatn_2\";\n+\n+/*\n+ *  File name selection pattern\n+ */\n+tSCC zGlibc_Cxx_Floatn_2List[] =\n+  \"bits/floatn.h\\0bits/floatn-common.h\\0*/bits/floatn.h\\0*/bits/floatn-common.h\\0\";\n+/*\n+ *  Machine/OS name selection pattern\n+ */\n+#define apzGlibc_Cxx_Floatn_2Machs (const char**)NULL\n+\n+/*\n+ *  content selection pattern - do fix if pattern found\n+ */\n+tSCC zGlibc_Cxx_Floatn_2Select0[] =\n+       \"^([ \\t]*#[ \\t]*if !__GNUC_PREREQ \\\\(7, 0\\\\) \\\\|\\\\| )defined __cplusplus\\n\\\n+(([ \\t]*/\\\\*[^\\n\\\n+]*\\\\*/\\n\\\n+)?[ \\t]*typedef[ \\t]+[^\\n\\\n+]*[ \\t]+_Float(16|32|64|128)x?([ \\t]+__attribute__ \\\\(\\\\(__mode__ \\\\(__HF__\\\\)\\\\)\\\\))?;)\";\n+\n+#define    GLIBC_CXX_FLOATN_2_TEST_CT  1\n+static tTestDesc aGlibc_Cxx_Floatn_2Tests[] = {\n+  { TT_EGREP,    zGlibc_Cxx_Floatn_2Select0, (regex_t*)NULL }, };\n+\n+/*\n+ *  Fix Command Arguments for Glibc_Cxx_Floatn_2\n+ */\n+static const char* apzGlibc_Cxx_Floatn_2Patch[] = {\n+    \"format\",\n+    \"%1(defined __cplusplus && !__GNUC_PREREQ (13, 0))\\n\\\n+%2\",\n+    (char*)NULL };\n+\n+/* * * * * * * * * * * * * * * * * * * * * * * * * *\n+ *\n+ *  Description of Glibc_Cxx_Floatn_3 fix\n+ */\n+tSCC zGlibc_Cxx_Floatn_3Name[] =\n+     \"glibc_cxx_floatn_3\";\n+\n+/*\n+ *  File name selection pattern\n+ */\n+tSCC zGlibc_Cxx_Floatn_3List[] =\n+  \"bits/floatn.h\\0bits/floatn-common.h\\0*/bits/floatn.h\\0*/bits/floatn-common.h\\0\";\n+/*\n+ *  Machine/OS name selection pattern\n+ */\n+#define apzGlibc_Cxx_Floatn_3Machs (const char**)NULL\n+\n+/*\n+ *  content selection pattern - do fix if pattern found\n+ */\n+tSCC zGlibc_Cxx_Floatn_3Select0[] =\n+       \"^([ \\t]*#[ \\t]*if !__GNUC_PREREQ \\\\(7, 0\\\\) \\\\|\\\\| )defined __cplusplus\\n\\\n+(([ \\t]*/\\\\*[^\\n\\\n+]*\\n\\\n+?[^\\n\\\n+]*\\\\*/\\n\\\n+)?([ \\t]*#[ \\t]*if[^\\n\\\n+]*\\n\\\n+)?([ \\t]*typedef[ \\t]+[^\\n\\\n+]*;\\n\\\n+)?[ \\t]*#[ \\t]*define __CFLOAT(16|32|64|128)X?[ \\t]+)\";\n+\n+#define    GLIBC_CXX_FLOATN_3_TEST_CT  1\n+static tTestDesc aGlibc_Cxx_Floatn_3Tests[] = {\n+  { TT_EGREP,    zGlibc_Cxx_Floatn_3Select0, (regex_t*)NULL }, };\n+\n+/*\n+ *  Fix Command Arguments for Glibc_Cxx_Floatn_3\n+ */\n+static const char* apzGlibc_Cxx_Floatn_3Patch[] = {\n+    \"format\",\n+    \"%1(defined __cplusplus && !__GNUC_PREREQ (13, 0))\\n\\\n+%2\",\n+    (char*)NULL };\n+\n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n  *\n  *  Description of Glibc_Mutex_Init fix\n@@ -10872,9 +10998,9 @@ static const char* apzX11_SprintfPatch[] = {\n  *\n  *  List of all fixes\n  */\n-#define REGEX_COUNT          305\n+#define REGEX_COUNT          308\n #define MACH_LIST_SIZE_LIMIT 187\n-#define FIX_COUNT            267\n+#define FIX_COUNT            270\n \n /*\n  *  Enumerate the fixes\n@@ -10977,6 +11103,9 @@ typedef enum {\n     GLIBC_C99_INLINE_2_FIXIDX,\n     GLIBC_C99_INLINE_3_FIXIDX,\n     GLIBC_C99_INLINE_4_FIXIDX,\n+    GLIBC_CXX_FLOATN_1_FIXIDX,\n+    GLIBC_CXX_FLOATN_2_FIXIDX,\n+    GLIBC_CXX_FLOATN_3_FIXIDX,\n     GLIBC_MUTEX_INIT_FIXIDX,\n     GLIBC_STDINT_FIXIDX,\n     GLIBC_STRNCPY_FIXIDX,\n@@ -11635,6 +11764,21 @@ tFixDesc fixDescList[ FIX_COUNT ] = {\n      GLIBC_C99_INLINE_4_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,\n      aGlibc_C99_Inline_4Tests,   apzGlibc_C99_Inline_4Patch, 0 },\n \n+  {  zGlibc_Cxx_Floatn_1Name,    zGlibc_Cxx_Floatn_1List,\n+     apzGlibc_Cxx_Floatn_1Machs,\n+     GLIBC_CXX_FLOATN_1_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,\n+     aGlibc_Cxx_Floatn_1Tests,   apzGlibc_Cxx_Floatn_1Patch, 0 },\n+\n+  {  zGlibc_Cxx_Floatn_2Name,    zGlibc_Cxx_Floatn_2List,\n+     apzGlibc_Cxx_Floatn_2Machs,\n+     GLIBC_CXX_FLOATN_2_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,\n+     aGlibc_Cxx_Floatn_2Tests,   apzGlibc_Cxx_Floatn_2Patch, 0 },\n+\n+  {  zGlibc_Cxx_Floatn_3Name,    zGlibc_Cxx_Floatn_3List,\n+     apzGlibc_Cxx_Floatn_3Machs,\n+     GLIBC_CXX_FLOATN_3_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,\n+     aGlibc_Cxx_Floatn_3Tests,   apzGlibc_Cxx_Floatn_3Patch, 0 },\n+\n   {  zGlibc_Mutex_InitName,    zGlibc_Mutex_InitList,\n      apzGlibc_Mutex_InitMachs,\n      GLIBC_MUTEX_INIT_TEST_CT, FD_MACH_ONLY,"}, {"sha": "88bf28fb58ccf1569945cc3edf7e623235297918", "filename": "fixincludes/inclhack.def", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/fixincludes%2Finclhack.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/fixincludes%2Finclhack.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fixincludes%2Finclhack.def?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -2015,6 +2015,102 @@ fix = {\n \tEOT;\n };\n \n+/*  glibc-2.27 to 2.36 assume GCC 7 or later supports some or all\n+ *  of _Float{16,32,64,128} and _Float{32,64,128}x keywords for C,\n+ *  but doesn't for C++.\n+ */\n+fix = {\n+    hackname  = glibc_cxx_floatn_1;\n+    files     = bits/floatn.h, bits/floatn-common.h, \"*/bits/floatn.h\", \"*/bits/floatn-common.h\";\n+    select    = \"^([ \\t]*#[ \\t]*if !__GNUC_PREREQ \\\\(7, 0\\\\) \\\\|\\\\| )defined __cplusplus\\n\"\n+\t\t\"(([ \\t]*/\\\\*[^\\n]*\\\\*/\\n)?\"\n+\t\t\"([ \\t]*#[ \\t]*if[^\\n]*\\n)?\"\n+\t\t\"[ \\t]*#[ \\t]*define __f(16|32|64|128)x?\\\\()\";\n+    c_fix     = format;\n+    c_fix_arg = \"%1(defined __cplusplus && !__GNUC_PREREQ (13, 0))\\n%2\";\n+    test_text = <<-EOT\n+\t#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n+\t/* The literal suffix f128 exists only since GCC 7.0.  */\n+\t#   define __f128(x) x##l\n+\t#  else\n+\t#   define __f128(x) x##f128\n+\t#  endif\n+\t#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n+\t/* The literal suffix (f128) exist for powerpc only since GCC 7.0.  */\n+\t#   if __LDBL_MANT_DIG__ == 113\n+\t#    define __f128(x) x##l\n+\t#   else\n+\t#    define __f128(x) x##q\n+\t#   endif\n+\t#  else\n+\t#   define __f128(x) x##f128\n+\t#  endif\n+\t#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n+\t#   ifdef __NO_LONG_DOUBLE_MATH\n+\t#    define __f64(x) x##l\n+\t#   else\n+\t#    define __f64(x) x\n+\t#   endif\n+\t#  else\n+\t#   define __f64(x) x##f64\n+\t#  endif\n+\tEOT;\n+};\n+\n+fix = {\n+    hackname  = glibc_cxx_floatn_2;\n+    files     = bits/floatn.h, bits/floatn-common.h, \"*/bits/floatn.h\", \"*/bits/floatn-common.h\";\n+    select    = \"^([ \\t]*#[ \\t]*if !__GNUC_PREREQ \\\\(7, 0\\\\) \\\\|\\\\| )defined __cplusplus\\n\"\n+\t\t\"(([ \\t]*/\\\\*[^\\n]*\\\\*/\\n)?\"\n+\t\t\"[ \\t]*typedef[ \\t]+[^\\n]*[ \\t]+_Float(16|32|64|128)x?([ \\t]+__attribute__ \\\\(\\\\(__mode__ \\\\(__HF__\\\\)\\\\)\\\\))?;)\";\n+    c_fix     = format;\n+    c_fix_arg = \"%1(defined __cplusplus && !__GNUC_PREREQ (13, 0))\\n%2\";\n+    test_text = <<-EOT\n+\t#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n+\ttypedef float _Float16 __attribute__ ((__mode__ (__HF__)));\n+\t#  endif\n+\t#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n+\ttypedef __float128 _Float128;\n+\t#  endif\n+\tEOT;\n+};\n+\n+fix = {\n+    hackname  = glibc_cxx_floatn_3;\n+    files     = bits/floatn.h, bits/floatn-common.h, \"*/bits/floatn.h\", \"*/bits/floatn-common.h\";\n+    select    = \"^([ \\t]*#[ \\t]*if !__GNUC_PREREQ \\\\(7, 0\\\\) \\\\|\\\\| )defined __cplusplus\\n\"\n+\t\t\"(([ \\t]*/\\\\*[^\\n]*\\n?[^\\n]*\\\\*/\\n)?\"\n+\t\t\"([ \\t]*#[ \\t]*if[^\\n]*\\n)?\"\n+\t\t\"([ \\t]*typedef[ \\t]+[^\\n]*;\\n)?\"\n+\t\t\"[ \\t]*#[ \\t]*define __CFLOAT(16|32|64|128)X?[ \\t]+)\";\n+    c_fix     = format;\n+    c_fix_arg = \"%1(defined __cplusplus && !__GNUC_PREREQ (13, 0))\\n%2\";\n+    test_text = <<-EOT\n+\t#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n+\t#   define __CFLOAT128 _Complex long double\n+\t#  else\n+\t#   define __CFLOAT128 _Complex _Float128\n+\t#  endif\n+\t#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n+\t/* Add a typedef for older GCC compilers which don't natively support\n+\t   _Complex _Float128.  */\n+\ttypedef _Complex float __cfloat128 __attribute__ ((__mode__ (__TC__)));\n+\t#   define __CFLOAT128 __cfloat128\n+\t#  else\n+\t#   define __CFLOAT128 _Complex _Float128\n+\t#  endif\n+\t#  if !__GNUC_PREREQ (7, 0) || defined __cplusplus\n+\t#   ifdef __NO_LONG_DOUBLE_MATH\n+\t#    define __CFLOAT64 _Complex long double\n+\t#   else\n+\t#    define __CFLOAT64 _Complex double\n+\t#   endif\n+\t#  else\n+\t#   define __CFLOAT64 _Complex _Float64\n+\t#  endif\n+\tEOT;\n+};\n+\n /*  glibc-2.3.5 defines pthread mutex initializers incorrectly,\n  *  so we replace them with versions that correspond to the\n  *  definition."}, {"sha": "f09528b6e274ac812b0d78d39e423c64b91835f9", "filename": "fixincludes/tests/base/bits/floatn.h", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/fixincludes%2Ftests%2Fbase%2Fbits%2Ffloatn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/fixincludes%2Ftests%2Fbase%2Fbits%2Ffloatn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fixincludes%2Ftests%2Fbase%2Fbits%2Ffloatn.h?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,74 @@\n+/*  DO NOT EDIT THIS FILE.\n+\n+    It has been auto-edited by fixincludes from:\n+\n+\t\"fixinc/tests/inc/bits/floatn.h\"\n+\n+    This had to be done to correct non-standard usages in the\n+    original, manufacturer supplied header file.  */\n+\n+\n+\n+#if defined( GLIBC_CXX_FLOATN_1_CHECK )\n+#  if !__GNUC_PREREQ (7, 0) || (defined __cplusplus && !__GNUC_PREREQ (13, 0))\n+/* The literal suffix f128 exists only since GCC 7.0.  */\n+#   define __f128(x) x##l\n+#  else\n+#   define __f128(x) x##f128\n+#  endif\n+#  if !__GNUC_PREREQ (7, 0) || (defined __cplusplus && !__GNUC_PREREQ (13, 0))\n+/* The literal suffix (f128) exist for powerpc only since GCC 7.0.  */\n+#   if __LDBL_MANT_DIG__ == 113\n+#    define __f128(x) x##l\n+#   else\n+#    define __f128(x) x##q\n+#   endif\n+#  else\n+#   define __f128(x) x##f128\n+#  endif\n+#  if !__GNUC_PREREQ (7, 0) || (defined __cplusplus && !__GNUC_PREREQ (13, 0))\n+#   ifdef __NO_LONG_DOUBLE_MATH\n+#    define __f64(x) x##l\n+#   else\n+#    define __f64(x) x\n+#   endif\n+#  else\n+#   define __f64(x) x##f64\n+#  endif\n+#endif  /* GLIBC_CXX_FLOATN_1_CHECK */\n+\n+\n+#if defined( GLIBC_CXX_FLOATN_2_CHECK )\n+#  if !__GNUC_PREREQ (7, 0) || (defined __cplusplus && !__GNUC_PREREQ (13, 0))\n+typedef float _Float16 __attribute__ ((__mode__ (__HF__)));\n+#  endif\n+#  if !__GNUC_PREREQ (7, 0) || (defined __cplusplus && !__GNUC_PREREQ (13, 0))\n+typedef __float128 _Float128;\n+#  endif\n+#endif  /* GLIBC_CXX_FLOATN_2_CHECK */\n+\n+\n+#if defined( GLIBC_CXX_FLOATN_3_CHECK )\n+#  if !__GNUC_PREREQ (7, 0) || (defined __cplusplus && !__GNUC_PREREQ (13, 0))\n+#   define __CFLOAT128 _Complex long double\n+#  else\n+#   define __CFLOAT128 _Complex _Float128\n+#  endif\n+#  if !__GNUC_PREREQ (7, 0) || (defined __cplusplus && !__GNUC_PREREQ (13, 0))\n+/* Add a typedef for older GCC compilers which don't natively support\n+   _Complex _Float128.  */\n+typedef _Complex float __cfloat128 __attribute__ ((__mode__ (__TC__)));\n+#   define __CFLOAT128 __cfloat128\n+#  else\n+#   define __CFLOAT128 _Complex _Float128\n+#  endif\n+#  if !__GNUC_PREREQ (7, 0) || (defined __cplusplus && !__GNUC_PREREQ (13, 0))\n+#   ifdef __NO_LONG_DOUBLE_MATH\n+#    define __CFLOAT64 _Complex long double\n+#   else\n+#    define __CFLOAT64 _Complex double\n+#   endif\n+#  else\n+#   define __CFLOAT64 _Complex _Float64\n+#  endif\n+#endif  /* GLIBC_CXX_FLOATN_3_CHECK */"}, {"sha": "4bd177da72a9c9a01a94cc3e70da71ae02b93e45", "filename": "gcc/ChangeLog", "status": "modified", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,3 +1,126 @@\n+2022-09-26  Martin Liska  <mliska@suse.cz>\n+\n+\t* doc/invoke.texi: Add missing dash for\n+\t  Wanalyzer-exposure-through-uninit-copy.\n+\n+2022-09-26  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\tPR tree-optimization/107009\n+\t* range-op.cc (operator_bitwise_and::op1_range): Optimize 0 = x & MASK.\n+\t(range_op_bitwise_and_tests): New test.\n+\n+2022-09-26  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\tPR tree-optimization/107009\n+\t* tree-ssa-dom.cc\n+\t(dom_opt_dom_walker::set_global_ranges_from_unreachable_edges):\n+\tIterate over exports.\n+\n+2022-09-26  Thomas Schwinge  <thomas@codesourcery.com>\n+\n+\t* config.gcc (with_arch) [nvptx]: Allow '--with-arch' to override\n+\tthe default.\n+\t* config/nvptx/gen-multilib-matches.sh: New.\n+\t* config/nvptx/t-nvptx (MULTILIB_OPTIONS, MULTILIB_MATCHES)\n+\t(MULTILIB_EXCEPTIONS): Handle this.\n+\t* doc/install.texi (Specific) <nvptx-*-none>: Document this.\n+\t* doc/invoke.texi (Nvidia PTX Options): Likewise.\n+\n+2022-09-26  Thomas Schwinge  <thomas@codesourcery.com>\n+\n+\t* config.gcc (TM_MULTILIB_CONFIG) [nvptx]: Set to '$with_arch'.\n+\t* config/nvptx/t-nvptx (MULTILIB_OPTIONS, MULTILIB_MATCHES)\n+\t(MULTILIB_EXCEPTIONS): Handle it.\n+\n+2022-09-26  Thomas Schwinge  <thomas@codesourcery.com>\n+\n+\t* config.gcc (with_arch) [nvptx]: Set to 'sm_30'.\n+\t* config/nvptx/nvptx.cc (nvptx_option_override): Assert that\n+\t'-misa' appeared.\n+\t* config/nvptx/nvptx.h (OPTION_DEFAULT_SPECS): Define.\n+\t* config/nvptx/nvptx.opt (misa=): Remove 'Init'.\n+\n+2022-09-26  Thomas Schwinge  <thomas@codesourcery.com>\n+\n+\t* config/nvptx/nvptx.h (ASM_SPEC): Define.\n+\n+2022-09-26  Jeff Law  <jeffreyalaw@gmail.com>\n+\n+\t* cfgcleanup.cc (bb_is_just_return): No longer static.\n+\t* cfgcleanup.h (bb_is_just_return): Add prototype.\n+\t* cfgrtl.cc (fixup_reorder_chain): Do not create an\n+\tunconditional jump to a return block.  Conditionally\n+\tremove unreachable blocks.\n+\n+2022-09-26  Tobias Burnus  <tobias@codesourcery.com>\n+\n+\tPR middle-end/106982\n+\t* omp-low.cc (lower_oacc_reductions): Add some unshare_expr.\n+\n+2022-09-26  Martin Liska  <mliska@suse.cz>\n+\n+\t* config/s390/s390.cc (s390_rtx_costs): Remove dest variable\n+\tand use only dst.\n+\n+2022-09-26  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* config/aarch64/aarch64-arches.def (armv9.1-a): Define.\n+\t(armv9.2-a): Likewise.\n+\t(armv9.3-a): Likewise.\n+\t* config/aarch64/aarch64.h (AARCH64_FL_V9_1): Likewise.\n+\t(AARCH64_FL_V9_2): Likewise.\n+\t(AARCH64_FL_V9_3): Likewise.\n+\t(AARCH64_FL_FOR_ARCH9_1): Likewise.\n+\t(AARCH64_FL_FOR_ARCH9_2): Likewise.\n+\t(AARCH64_FL_FOR_ARCH9_3): Likewise.\n+\t(AARCH64_ISA_V9_1): Likewise.\n+\t(AARCH64_ISA_V9_2): Likewise.\n+\t(AARCH64_ISA_V9_3): Likewise.\n+\t* doc/invoke.texi (AArch64 Options): Document armv9.1-a, armv9.2-a,\n+\tarmv9.3-a values to -march.\n+\n+2022-09-26  Martin Liska  <mliska@suse.cz>\n+\n+\t* value-range.cc (tree_compare): Remove unused function.\n+\n+2022-09-26  Kewen Lin  <linkw@linux.ibm.com>\n+\n+\tPR target/96072\n+\t* config/rs6000/rs6000-logue.cc (rs6000_emit_epilogue): Update the\n+\tcondition for adding REG_CFA_DEF_CFA reg note with\n+\tframe_pointer_needed_indeed.\n+\n+2022-09-26  Kewen Lin  <linkw@linux.ibm.com>\n+\n+\tPR target/100645\n+\t* config/rs6000/vector.md (vec_shr_<mode>): Replace condition\n+\tTARGET_ALTIVEC with VECTOR_UNIT_ALTIVEC_OR_VSX_P.\n+\n+2022-09-26  Hongtao Liu  <hongtao.liu@intel.com>\n+\t    Liwei Xu  <liwei.xu@intel.com>\n+\n+\tPR target/53346\n+\t* config/i386/i386-expand.cc (expand_vec_perm_shufps_shufps):\n+\tNew function.\n+\t(ix86_expand_vec_perm_const_1): Insert\n+\texpand_vec_perm_shufps_shufps at the end of 2-instruction\n+\texpand sequence.\n+\n+2022-09-25  Torbj\u00f6rn SVENSSON  <torbjorn.svensson@foss.st.com>\n+\n+\t* doc/sourcebuild.texi: Fix chapter level.\n+\n+2022-09-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/107001\n+\t* omp-low.cc (lower_omp_taskgroup): Don't add GOMP_RETURN statement\n+\tat the end.\n+\t* omp-expand.cc (build_omp_regions_1): Clarify GF_OMP_TARGET_KIND_DATA\n+\tis not stand-alone directive.  For GIMPLE_OMP_TASKGROUP, also don't\n+\tupdate parent.\n+\t(omp_make_gimple_edges) <case GIMPLE_OMP_TASKGROUP>: Reset\n+\tcur_region back after new_omp_region.\n+\n 2022-09-23  Vineet Gupta  <vineetg@rivosinc.com>\n \n \t* config/riscv/riscv.h (LOCAL_SYM_P): New."}, {"sha": "38c805d4b6a860292dcd2ad74048690e53c88600", "filename": "gcc/DATESTAMP", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2FDATESTAMP", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2FDATESTAMP", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FDATESTAMP?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1 +1 @@\n-20220924\n+20220927"}, {"sha": "db4ac0d176b868b8542305ec3d7a6f61034b3165", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 105, "deletions": 6, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,3 +1,102 @@\n+2022-09-26  Ghjuvan Lacambre  <lacambre@adacore.com>\n+\n+\t* doc/gnat_rm/implementation_defined_attributes.rst: Rename Valid_Image.\n+\t* gnat_rm.texi: Regenerate.\n+\t* gnat_ugn.texi: Regenerate.\n+\n+2022-09-26  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* sem_ch12.adb (Build_Instance_Compilation_Unit_Nodes): Relocate\n+\tauxiliary declarations from the original compilation unit to the\n+\tnewly created compilation unit for the spec.\n+\n+2022-09-26  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* rtsfind.ads\n+\t(RTU_Id): Remove unreferenced packages; fix whitespace.\n+\t(RE_Id): Remove unreferenced entities; add comment about entity\n+\tthat is only used by GNATprove and not by GNAT.\n+\n+2022-09-26  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* s-oscons-tmplt.c (STR, STR1): Remove.\n+\n+2022-09-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* doc/gnat_ugn/building_executable_programs_with_gnat.rst\n+\t(-gnateT): Document new parameter Long_Long_Long_Size.\n+\t* gnat_ugn.texi: Regenerate.\n+\n+2022-09-26  Steve Baird  <baird@adacore.com>\n+\n+\t* bindgen.adb: When the binder is invoked for the device, specify\n+\tthe CUDA_Global aspect for the adainit and adafinal procedures via\n+\ta pragma instead of via an aspect_specification.\n+\n+2022-09-26  K\u00e9vin Le Gouguec  <legouguec@adacore.com>\n+\n+\t* doc/gnat_ugn/building_executable_programs_with_gnat.rst\n+\t(Linker Switches): Document support for mold along with gold; add some\n+\tadvice regarding OpenSSL in the Pro version.\n+\t* gnat_ugn.texi: Regenerate.\n+\n+2022-09-26  Tucker Taft  <taft@adacore.com>\n+\n+\t* sem_util.adb (Original_Aspect_Pragma_Name): Check for Check\n+\tpragmas.\n+\n+2022-09-26  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* sem_ch5.adb (Analyze_Iterator_Specification): Delay expansion\n+\tbased on Full_Analysis flag.\n+\n+2022-09-26  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* sem_ch5.adb (Analyze_Iterator_Specification): Delay expansion of\n+\tfor iterated component association just like it is done within\n+\tquantified expression.\n+\n+2022-09-26  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* contracts.adb (Analyze_Object_Contract): Check SPARK_Mode before\n+\tapplying SPARK rule.\n+\n+2022-09-26  Justin Squirek  <squirek@adacore.com>\n+\n+\t* sem_util.adb\n+\t(Accessibility_Level): Modify indexed and selected components case\n+\tby reducing the scope where Original_Node gets used.\n+\n+2022-09-26  Boris Yakobowski  <yakobowski@adacore.com>\n+\n+\t* doc/gnat_ugn/gnat_utility_programs.rst: Remove documentation for\n+\tgnatmetric.\n+\n+2022-09-26  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* gsocket.h: Remove redefinition of _WIN32_WINNT.\n+\t* mingw32.h: Remove conditional definition of _WIN32_WINNT.\n+\n+2022-09-26  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* mingw32.h: Remove condition definition of MAXPATHLEN; the include\n+\tdirective for stdlib.h was most likely intended to provide the\n+\tMAX_PATH.\n+\n+2022-09-26  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* adaint.c: Remove conditional #include directives for old MinGW.\n+\t* cal.c: Always include winsock.h, since it is part of modern\n+\tMinGW.\n+\t* cstreams.c: Remove workaround for old MinGW.\n+\t* expect.c: Remove conditional #include directive for old MinGW.\n+\t* mingw32.h: Remove STD_MINGW and OLD_MINGW declarations.\n+\t* sysdep.c: Remove conditional #include directive for old MinGW.\n+\n+2022-09-26  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* sem_warn.ads (Has_Junk_Name): Reword comment.\n+\n 2022-09-20  Martin Liska  <mliska@suse.cz>\n \n \t* exp_ch6.adb: Replace \"the the\" with \"the\".\n@@ -66,7 +165,7 @@\n \n 2022-09-12  Eric Botcazou  <ebotcazou@adacore.com>\n \n-\t* contracts.adb (uild_Subprogram_Contract_Wrapper): Remove useless\n+\t* contracts.adb (Build_Subprogram_Contract_Wrapper): Remove useless\n \tlocal variable. In the case of a function, replace the extended\n \treturn statement by a block statement declaring a renaming of the\n \tcall to the local subprogram after removing side effects manually.\n@@ -1179,14 +1278,14 @@\n \n 2022-09-02  Eric Botcazou  <ebotcazou@adacore.com>\n \n-\t* exp_util.adb (Expand_Subtype_From_Expr): Be prepared for\n-\trewritten aggregates as expressions.\n+\t* exp_util.adb (Expand_Subtype_From_Expr): Be prepared for rewritten\n+\taggregates as expressions.\n \n 2022-09-02  Gary Dismukes  <dismukes@adacore.com>\n \n-\t* exp_ch6.adb (Expand_Simple_Function_Return) Bypass creation of an actual\n-\tsubtype and unchecked conversion to that subtype when the underlying type\n-\tof the expression has discriminants without defaults.\n+\t* exp_ch6.adb (Expand_Simple_Function_Return) Bypass creation of an\n+\tactual subtype and unchecked conversion to that subtype when the\n+\tunderlying type of the expression has discriminants without defaults.\n \n 2022-09-02  Eric Botcazou  <ebotcazou@adacore.com>\n "}, {"sha": "199dbe0e4052671aa53b38ac6d953a3829588667", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -200,11 +200,7 @@ UINT __gnat_current_ccs_encoding;\n #endif\n \n /* wait.h processing */\n-#ifdef __MINGW32__\n-# if OLD_MINGW\n-#  include <sys/wait.h>\n-# endif\n-#elif defined (__vxworks) && defined (__RTP__)\n+#if defined (__vxworks) && defined (__RTP__)\n # include <wait.h>\n #elif defined (__Lynx__)\n /* ??? We really need wait.h and it includes resource.h on Lynx.  GCC\n@@ -214,7 +210,7 @@ UINT __gnat_current_ccs_encoding;\n    preventing the inclusion of the GCC header from doing anything.  */\n # define GCC_RESOURCE_H\n # include <sys/wait.h>\n-#elif defined (__PikeOS__)\n+#elif defined (__PikeOS__) || defined (__MINGW32__)\n /* No wait() or waitpid() calls available.  */\n #else\n /* Default case.  */\n@@ -335,11 +331,6 @@ const char *__gnat_library_template = GNAT_LIBRARY_TEMPLATE;\n \n #if defined (__MINGW32__)\n #include \"mingw32.h\"\n-\n-#if OLD_MINGW\n-#include <sys/param.h>\n-#endif\n-\n #else\n #include <sys/param.h>\n #endif"}, {"sha": "f2aaa2dea92005170cab5dfadbefc83915f03ed6", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -134,9 +134,6 @@ package body Bindgen is\n    --  Text for aspect specifications (if any) given as part of the\n    --  Adainit and Adafinal spec declarations.\n \n-   function Aspect_Text return String is\n-     (if Enable_CUDA_Device_Expansion then \" with CUDA_Global\" else \"\");\n-\n    ----------------------------------\n    -- Interface_State Pragma Table --\n    ----------------------------------\n@@ -2644,10 +2641,11 @@ package body Bindgen is\n       end if;\n \n       WBI (\"\");\n-      WBI (\"   procedure \" & Ada_Init_Name.all & Aspect_Text & \";\");\n+      WBI (\"   procedure \" & Ada_Init_Name.all & \";\");\n       if Enable_CUDA_Device_Expansion then\n          WBI (\"   pragma Export (C, \" & Ada_Init_Name.all &\n                 \", Link_Name => \"\"\" & Device_Ada_Init_Link_Name & \"\"\");\");\n+         WBI (\"   pragma CUDA_Global (\" & Ada_Init_Name.all & \");\");\n       else\n          WBI (\"   pragma Export (C, \" & Ada_Init_Name.all & \", \"\"\" &\n               Ada_Init_Name.all & \"\"\");\");\n@@ -2662,11 +2660,12 @@ package body Bindgen is\n \n       if not Cumulative_Restrictions.Set (No_Finalization) then\n          WBI (\"\");\n-         WBI (\"   procedure \" & Ada_Final_Name.all & Aspect_Text & \";\");\n+         WBI (\"   procedure \" & Ada_Final_Name.all & \";\");\n \n          if Enable_CUDA_Device_Expansion then\n             WBI (\"   pragma Export (C, \" & Ada_Final_Name.all &\n                    \", Link_Name => \"\"\" & Device_Ada_Final_Link_Name & \"\"\");\");\n+            WBI (\"   pragma CUDA_Global (\" & Ada_Final_Name.all & \");\");\n          else\n             WBI (\"   pragma Export (C, \" & Ada_Final_Name.all & \", \"\"\" &\n                  Ada_Final_Name.all & \"\"\");\");"}, {"sha": "09bcc15c4b37ed868ddb465541bb4a8613f8999f", "filename": "gcc/ada/cal.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fcal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fcal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcal.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -53,10 +53,8 @@\n \n #ifdef __MINGW32__\n #include \"mingw32.h\"\n-#if STD_MINGW\n #include <winsock.h>\n #endif\n-#endif\n \n void\n __gnat_timeval_to_duration (struct timeval *t, long long *sec, long *usec)"}, {"sha": "dd573d374c690f1e7157dcee02529ea9a33309a7", "filename": "gcc/ada/contracts.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1207,7 +1207,7 @@ package body Contracts is\n          --  A Ghost object cannot be effectively volatile (SPARK RM 6.9(7) and\n          --  SPARK RM 6.9(19)).\n \n-         elsif Is_Effectively_Volatile (Obj_Id) then\n+         elsif SPARK_Mode = On and then Is_Effectively_Volatile (Obj_Id) then\n             Error_Msg_N (\"ghost object & cannot be volatile\", Obj_Id);\n \n          --  A Ghost object cannot be imported or exported (SPARK RM 6.9(7))."}, {"sha": "fc583e17004be3a419d619c6821d229a886db00e", "filename": "gcc/ada/cstreams.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fcstreams.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fcstreams.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcstreams.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -97,14 +97,6 @@ extern \"C\" {\n #undef fileno\n #endif\n \n-/* The _IONBF value in MINGW32 stdio.h is wrong.  */\n-#if defined (WINNT) || defined (_WINNT)\n-#if OLD_MINGW\n-#undef _IONBF\n-#define _IONBF 0004\n-#endif\n-#endif\n-\n int\n __gnat_feof (FILE *stream)\n {"}, {"sha": "d839b1fd2e705810bb30c19ddd825ca85b003d14", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_attributes.rst", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_attributes.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_attributes.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_attributes.rst?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1623,13 +1623,13 @@ Multi-dimensional arrays can be modified, as shown by this example:\n \n which changes element (1,2) to 20 and (3,4) to 30.\n \n-Attribute Valid_Image\n+Attribute Valid_Value\n =======================\n-.. index:: Valid_Image\n+.. index:: Valid_Value\n \n-The ``'Valid_Image`` attribute is defined for enumeration types other than\n+The ``'Valid_Value`` attribute is defined for enumeration types other than\n those in package Standard. This attribute is a function that takes\n-a String, and returns Boolean. ``T'Valid_Image (S)`` returns True\n+a String, and returns Boolean. ``T'Valid_Value (S)`` returns True\n if and only if ``T'Value (S)`` would not raise Constraint_Error.\n \n Attribute Valid_Scalars"}, {"sha": "d4bddffac60afa9d242a8cf601d492274d5aa704", "filename": "gcc/ada/doc/gnat_ugn/building_executable_programs_with_gnat.rst", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fbuilding_executable_programs_with_gnat.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fbuilding_executable_programs_with_gnat.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fbuilding_executable_programs_with_gnat.rst?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1719,6 +1719,7 @@ Alphabetical List of All Switches\n     Float_Words_BE             : Nat; -- Float words stored big-endian?\n     Int_Size                   : Pos; -- Standard.Integer'Size\n     Long_Double_Size           : Pos; -- Standard.Long_Long_Float'Size\n+    Long_Long_Long_Size        : Pos; -- Standard.Long_Long_Long_Integer'Size\n     Long_Long_Size             : Pos; -- Standard.Long_Long_Integer'Size\n     Long_Size                  : Pos; -- Standard.Long_Integer'Size\n     Maximum_Alignment          : Pos; -- Maximum permitted alignment\n@@ -1816,6 +1817,7 @@ Alphabetical List of All Switches\n     Float_Words_BE                0\n     Int_Size                     64\n     Long_Double_Size            128\n+    Long_Long_Long_Size         128\n     Long_Long_Size               64\n     Long_Size                    64\n     Maximum_Alignment            16\n@@ -6229,11 +6231,33 @@ Linker switches can be specified after :switch:`-largs` builder switch.\n .. index:: -fuse-ld=name\n \n :switch:`-fuse-ld={name}`\n-  Linker to be used. The default is ``bfd`` for :file:`ld.bfd`,\n-  the alternative being ``gold`` for :file:`ld.gold`. The later is\n-  a more recent and faster linker, but only available on GNU/Linux\n+  Linker to be used. The default is ``bfd`` for :file:`ld.bfd`; ``gold``\n+  (for :file:`ld.gold`) and ``mold`` (for :file:`ld.mold`) are more\n+  recent and faster alternatives, but only available on GNU/Linux\n   platforms.\n \n+  .. only:: PRO\n+\n+    The GNAT distribution for native Linux platforms includes ``mold``,\n+    compiled against OpenSSL version 1.1; however, the distribution does\n+    not include OpenSSL.  In order to use this linker, you may either:\n+\n+    * use your system's OpenSSL library, if the version matches: in this\n+      situation, you need not do anything beside using the\n+      :switch:`-fuse-ld=mold` switch,\n+\n+    * obtain a source distribution for OpenSSL 1.1, compile the\n+      :file:`libcrypto.so` library and install it in the directory of\n+      your choice, then include this directory in the\n+      :envvar:`LD_LIBRARY_PATH` environment variable,\n+\n+    * install another copy of ``mold`` by other means in the directory\n+      of your choice, and include this directory in the :envvar:`PATH`\n+      environment variable; you may find this alternative preferable if\n+      the copy of ``mold`` included in GNAT does not suit your needs\n+      (e.g. being able to link against your system's OpenSSL, or using\n+      another version of ``mold``).\n+\n .. _Binding_with_gnatbind:\n \n Binding with ``gnatbind``"}, {"sha": "92877a2d172b90f01a3e0b8a043c6fa3fa6ff7e0", "filename": "gcc/ada/doc/gnat_ugn/gnat_utility_programs.rst", "status": "modified", "additions": 1, "deletions": 1119, "changes": 1120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_utility_programs.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_utility_programs.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_utility_programs.rst?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -15,7 +15,6 @@ This chapter describes a number of utility programs:\n   * :ref:`The_File_Cleanup_Utility_gnatclean`\n   * :ref:`The_GNAT_Library_Browser_gnatls`\n   * :ref:`The_Coding_Standard_Verifier_gnatcheck`\n-  * :ref:`The_GNAT_Metrics_Tool_gnatmetric`\n   * :ref:`The_GNAT_Pretty_Printer_gnatpp`\n   * :ref:`The_Body_Stub_Generator_gnatstub`\n   * :ref:`The_Backtrace_Symbolizer_gnatsymbolize`\n@@ -487,1123 +486,6 @@ building specialized scripts.\n   For full details, plese refer to :title:`GNATcheck Reference Manual`.\n \n \n-\n-.. only:: PRO or GPL\n-\n-  .. _The_GNAT_Metrics_Tool_gnatmetric:\n-\n-  The GNAT Metrics Tool ``gnatmetric``\n-  ====================================\n-\n-  .. index:: ! gnatmetric\n-  .. index:: Metric tool\n-\n-  The ``gnatmetric`` tool is a utility\n-  for computing various program metrics.\n-  It takes an Ada source file as input and generates a file containing the\n-  metrics data as output. Various switches control which\n-  metrics are reported.\n-\n-  ``gnatmetric`` is a project-aware tool\n-  (see :ref:`Using_Project_Files_with_GNAT_Tools` for a description of\n-  the project-related switches). The project file package that can specify\n-  ``gnatmetric`` switches is named ``Metrics``.\n-\n-  The ``gnatmetric`` command has the form\n-\n-    ::\n-\n-       $ gnatmetric [ switches ] { filename }\n-\n-  where:\n-\n-  * ``switches`` specify the metrics to compute and define the destination for\n-    the output\n-\n-  * Each ``filename`` is the name of a source file to process. 'Wildcards' are\n-    allowed, and the file name may contain path information.  If no\n-    ``filename`` is supplied, then the ``switches`` list must contain at least\n-    one :switch:`--files` switch (see :ref:`Other_gnatmetric_Switches`).\n-    Including both a :switch:`--files` switch and one or more ``filename``\n-    arguments is permitted.\n-\n-    Note that it is no longer necessary to specify the Ada language version;\n-    ``gnatmetric`` can process Ada source code written in any version from\n-    Ada 83 onward without specifying any language version switch.\n-\n-  The following subsections describe the various switches accepted by\n-  ``gnatmetric``, organized by category.\n-\n-  .. _Output_File_Control-gnatmetric:\n-\n-  Output File Control\n-  -------------------\n-\n-  .. index:: Output file control in gnatmetric\n-\n-  ``gnatmetric`` has two output formats. It can generate a\n-  textual (human-readable) form, and also XML. By default only textual\n-  output is generated.\n-\n-  When generating the output in textual form, ``gnatmetric`` creates\n-  for each Ada source file a corresponding text file\n-  containing the computed metrics, except for the case when the set of metrics\n-  specified by gnatmetric parameters consists only of metrics that are computed\n-  for the whole set of analyzed sources, but not for each Ada source.\n-  By default, the name of the file containing metric information for a source\n-  is obtained by appending the :file:`.metrix` suffix to the\n-  name of the input source file. If not otherwise specified and no project file\n-  is specified as ``gnatmetric`` option this file is placed in the same\n-  directory as where the source file is located. If ``gnatmetric`` has a\n-  project  file as its parameter, it places all the generated files in the\n-  object directory of the project (or in the project source directory if the\n-  project does not define an object directory). If :switch:`--subdirs` option\n-  is specified, the files are placed in the subrirectory of this directory\n-  specified by this option.\n-\n-  All the output information generated in XML format is placed in a single\n-  file. By default the name of this file is :file:`metrix.xml`.\n-  If not otherwise specified and if no project file is specified\n-  as ``gnatmetric`` option this file is placed in the\n-  current directory.\n-\n-  Some of the computed metrics are summed over the units passed to\n-  ``gnatmetric``; for example, the total number of lines of code.\n-  By default this information is sent to :file:`stdout`, but a file\n-  can be specified with the :switch:`--global-file-name` switch.\n-\n-  The following switches control the ``gnatmetric`` output:\n-\n-  .. index:: --generate-xml-output (gnatmetric)\n-\n-  :switch:`--generate-xml-output`\n-    Generate XML output.\n-\n-  .. index:: --generate-xml-schema (gnatmetric)\n-\n-  :switch:`--generate-xml-schema`\n-    Generate XML output and an XML schema file that describes the structure\n-    of the XML metric report. This schema is assigned to the XML file. The schema\n-    file has the same name as the XML output file with :file:`.xml` suffix replaced\n-    with :file:`.xsd`.\n-\n-  .. index:: --no-text-output (gnatmetric)\n-\n-\n-  :switch:`--no-text-output`\n-    Do not generate the output in text form (implies :switch:`-x`).\n-\n-  .. index:: --output-dir (gnatmetric)\n-\n-\n-  :switch:`--output-dir={output_dir}`\n-    Put text files with detailed metrics into ``output_dir``.\n-\n-  .. index:: --output-suffix (gnatmetric)\n-\n-\n-  :switch:`--output-suffix={file_suffix}`\n-    Use ``file_suffix``, instead of :file:`.metrix`\n-    in the name of the output file.\n-\n-  .. index:: --global-file-name (gnatmetric)\n-\n-  :switch:`--global-file-name={file_name}`\n-    Put global metrics into ``file_name``.\n-\n-  .. index:: --xml-file-name (gnatmetric)\n-\n-\n-  :switch:`--xml-file-name={file_name}`\n-    Put the XML output into ``file_name``\n-    (also implies :switch:`--generate-xml-output`).\n-\n-  .. index:: --short-file-names (gnatmetric)\n-\n-  :switch:`--short-file-names`\n-    Use 'short' source file names in the output. (The ``gnatmetric``\n-    output includes the name(s) of the Ada source file(s) from which the\n-    metrics are computed. By default each name includes the absolute\n-    path. The :switch:`--short-file-names` switch causes ``gnatmetric``\n-    to exclude all directory information from the file names that are\n-    output.)\n-\n-   .. index:: --wide-character-encoding (gnatmetric)\n-\n-  :switch:`--wide-character-encoding={e}`\n-    Specify the wide character encoding method for the input and output\n-    files. ``e`` is one of the following:\n-\n-    * *8* - UTF-8 encoding\n-\n-    * *b* - Brackets encoding (default value)\n-\n-\n-  .. index:: Disable Metrics For Local Units in gnatmetric\n-\n-  .. _Disable_Metrics_For_Local_Units:\n-\n-  Disable Metrics For Local Units\n-  -------------------------------\n-\n-  ``gnatmetric`` relies on the GNAT compilation model --\n-  one compilation\n-  unit per one source file. It computes line metrics for the whole source\n-  file, and it also computes syntax\n-  and complexity metrics for the file's outermost unit.\n-\n-  By default, ``gnatmetric`` will also compute all metrics for certain\n-  kinds of locally declared program units:\n-\n-  * subprogram (and generic subprogram) bodies;\n-\n-  * package (and generic package) specs and bodies;\n-\n-  * task object and type specifications and bodies;\n-\n-  * protected object and type specifications and bodies.\n-\n-  .. index:: Eligible local unit (for gnatmetric)\n-\n-  These kinds of entities will be referred to as\n-  *eligible local program units*, or simply *eligible local units*,\n-  in the discussion below.\n-\n-  Note that a subprogram declaration, generic instantiation,\n-  or renaming declaration only receives metrics\n-  computation when it appear as the outermost entity\n-  in a source file.\n-\n-  Suppression of metrics computation for eligible local units can be\n-  obtained via the following switch:\n-\n-\n-  .. index:: --no-local-metrics (gnatmetric)\n-\n-\n-  :switch:`--no-local-metrics`\n-    Do not compute detailed metrics for eligible local program units.\n-\n-\n-  .. _Specifying_a_set_of_metrics_to_compute:\n-\n-  Specifying a set of metrics to compute\n-  --------------------------------------\n-\n-  By default all the metrics are reported. The switches described in this\n-  subsection allow you to control, on an individual basis, whether metrics are\n-  reported. If at least one positive metric switch is specified (that is, a\n-  switch that defines that a given metric or set of metrics is to be computed),\n-  then only explicitly specified metrics are reported.\n-\n-  .. _Line_Metrics_Control:\n-\n-  Line Metrics Control\n-  ^^^^^^^^^^^^^^^^^^^^\n-\n-  .. index:: Line metrics control in gnatmetric\n-\n-  For each source file, and for each of its eligible local program\n-  units, ``gnatmetric`` computes the following metrics:\n-\n-  * the total number of lines;\n-\n-  * the total number of code lines (i.e., non-blank lines that are not\n-    comments)\n-\n-  * the number of comment lines\n-\n-  * the number of code lines containing end-of-line comments;\n-\n-  * the comment percentage: the ratio between the number of lines that\n-    contain comments and the number of all non-blank lines, expressed as\n-    a percentage\n-\n-  * the number of empty lines and lines containing only space characters\n-    and/or format effectors (blank lines)\n-\n-  * the average number of code lines in subprogram bodies, task bodies,\n-    entry bodies and statement sequences in package bodies\n-\n-  ``gnatmetric`` sums the values of the line metrics for all the files\n-  being processed and then generates the cumulative results. The tool\n-  also computes for all the files being processed the average number of\n-  code lines in bodies.\n-\n-  You can use the following switches to select the specific line metrics\n-  to be reported.\n-\n-\n-  .. index:: --lines (gnatmetric)\n-  .. index:: --no-lines (gnatmetric)\n-\n-\n-  :switch:`--lines-all`\n-    Report all the line metrics\n-\n-\n-  :switch:`--no-lines-all`\n-    Do not report any of line metrics\n-\n-\n-  :switch:`--lines`\n-    Report the number of all lines\n-\n-\n-  :switch:`--no-lines`\n-    Do not report the number of all lines\n-\n-\n-  :switch:`--lines-code`\n-    Report the number of code lines\n-\n-\n-  :switch:`--no-lines-code`\n-    Do not report the number of code lines\n-\n-\n-  :switch:`--lines-comment`\n-    Report the number of comment lines\n-\n-\n-  :switch:`--no-lines-comment`\n-    Do not report the number of comment lines\n-\n-\n-  :switch:`--lines-eol-comment`\n-    Report the number of code lines containing\n-    end-of-line comments\n-\n-\n-  :switch:`--no-lines-eol-comment`\n-    Do not report the number of code lines containing\n-    end-of-line comments\n-\n-\n-  :switch:`--lines-ratio`\n-    Report the comment percentage in the program text\n-\n-\n-  :switch:`--no-lines-ratio`\n-    Do not report the comment percentage in the program text\n-\n-\n-  :switch:`--lines-blank`\n-    Report the number of blank lines\n-\n-\n-  :switch:`--no-lines-blank`\n-    Do not report the number of blank lines\n-\n-\n-  :switch:`--lines-average`\n-    Report the average number of code lines in subprogram bodies, task bodies,\n-    entry bodies and statement sequences in package bodies.\n-\n-\n-  :switch:`--no-lines-average`\n-    Do not report the average number of code lines in subprogram bodies,\n-    task bodies, entry bodies and statement sequences in package bodies.\n-\n-\n-  :switch:`--lines-spark`\n-    Report the number of lines written in SPARK.\n-\n-\n-  :switch:`--no-lines-spark`\n-    Do not report the number of lines written in SPARK.\n-\n-\n-  .. _Syntax_Metrics_Control:\n-\n-  Syntax Metrics Control\n-  ^^^^^^^^^^^^^^^^^^^^^^\n-\n-  .. index:: Syntax metrics control in gnatmetric\n-\n-  ``gnatmetric`` computes various syntactic metrics for the\n-  outermost unit and for each eligible local unit:\n-\n-  * *LSLOC ('Logical Source Lines Of Code')*\n-      The total number of declarations and the total number of\n-      statements. Note that the definition of declarations is the one\n-      given in the reference manual:\n-\n-        \"Each of the following is defined to be a declaration: any\n-        basic_declaration; an enumeration_literal_specification; a\n-        discriminant_specification; a component_declaration; a\n-        loop_parameter_specification; a parameter_specification; a\n-        subprogram_body; an entry_declaration; an\n-        entry_index_specification; a choice_parameter_specification; a\n-        generic_formal_parameter_declaration.\"\n-\n-      This means for example that each enumeration literal adds one to\n-      the count, as well as each subprogram parameter.\n-\n-  * *Maximal static nesting level of inner program units*\n-      According to :title:`Ada Reference Manual`, 10.1(1):\n-\n-        \"A program unit is either a package, a task unit, a protected\n-        unit, a protected entry, a generic unit, or an explicitly\n-        declared subprogram other than an enumeration literal.\"\n-\n-  * *Maximal nesting level of composite syntactic constructs*\n-      This corresponds to the notion of the maximum nesting level in the\n-      GNAT built-in style checks (see :ref:`Style_Checking`).\n-\n-  * *Number of formal parameters*\n-      Number of formal parameters of a subprogram; if a subprogram does\n-      have parameters, then numbers of \"in\", \"out\" and \"in out\"\n-      parameters are also reported. This metric is reported for\n-      subprogram specifications and for subprogram instantiations. For\n-      subprogram bodies, expression functions and null procedures this\n-      metric is reported if the construct acts as a subprogram\n-      declaration but is not a completion of previous declaration. This\n-      metric is not reported for generic and formal subprograms.\n-\n-  For the outermost unit in the file, ``gnatmetric`` additionally\n-  computes the following metrics:\n-\n-  * *Public subprograms*\n-      This metric is computed for package specs. It is the number of\n-      subprograms and generic subprograms declared in the visible part\n-      (including the visible part of nested packages, protected objects,\n-      and protected types).\n-\n-\n-  * *All subprograms*\n-      This metric is computed for bodies and subunits. The metric is\n-      equal to a total number of subprogram bodies in the compilation\n-      unit.\n-      Neither generic instantiations nor renamings-as-a-body nor body\n-      stubs are counted. Any subprogram body is counted, independently\n-      of its nesting level and enclosing constructs. Generic bodies and\n-      bodies of protected subprograms are counted in the same way as\n-      'usual' subprogram bodies.\n-\n-\n-  * *Public types*\n-      This metric is computed for package specs and generic package\n-      declarations. It is the total number of types that can be\n-      referenced from outside this compilation unit, plus the number of\n-      types from all the visible parts of all the visible generic\n-      packages. Generic formal types are not counted. Only types, not\n-      subtypes, are included.\n-\n-      Along with the total number of public types, the following\n-      types are counted and reported separately:\n-\n-      * *Abstract types*\n-\n-      * *Root tagged types^ (abstract, non-abstract, private,\n-        non-private). Type extensions are *not* counted\n-\n-      * *Private types* (including private extensions)\n-\n-      * *Task types*\n-\n-      * *Protected types*\n-\n-  * *All types*\n-      This metric is computed for any compilation unit. It is equal to\n-      the total number of the declarations of different types given in\n-      the compilation unit. The private and the corresponding full type\n-      declaration are counted as one type declaration. Incomplete type\n-      declarations and generic formal types are not counted.\n-      No distinction is made among different kinds of types (abstract,\n-      private etc.); the total number of types is reported.\n-\n-  By default, all the syntax metrics are reported. You can use the following\n-  switches to select specific syntax metrics.\n-\n-\n-  .. index:: --syntax (gnatmetric)\n-  .. index:: --no-syntax (gnatmetric)\n-\n-\n-  :switch:`--syntax-all`\n-    Report all the syntax metrics\n-\n-\n-  :switch:`--no-syntax-all`\n-    Do not report any of syntax metrics\n-\n-\n-  :switch:`--declarations`\n-    Report the total number of declarations\n-\n-\n-  :switch:`--no-declarations`\n-    Do not report the total number of declarations\n-\n-\n-  :switch:`--statements`\n-    Report the total number of statements\n-\n-\n-  :switch:`--no-statements`\n-    Do not report the total number of statements\n-\n-\n-  :switch:`--public-subprograms`\n-    Report the number of public subprograms in a compilation unit\n-\n-\n-  :switch:`--no-public-subprograms`\n-    Do not report the number of public subprograms in a compilation unit\n-\n-\n-  :switch:`--all-subprograms`\n-    Report the number of all the subprograms in a compilation unit\n-\n-\n-  :switch:`--no-all-subprograms`\n-    Do not report the number of all the subprograms in a compilation unit\n-\n-\n-  :switch:`--public-types`\n-    Report the number of public types in a compilation unit\n-\n-\n-  :switch:`--no-public-types`\n-    Do not report the number of public types in a compilation unit\n-\n-\n-  :switch:`--all-types`\n-    Report the number of all the types in a compilation unit\n-\n-\n-  :switch:`--no-all-types`\n-    Do not report the number of all the types in a compilation unit\n-\n-\n-  :switch:`--unit-nesting`\n-    Report the maximal program unit nesting level\n-\n-\n-  :switch:`--no-unit-nesting`\n-    Do not report the maximal program unit nesting level\n-\n-\n-  :switch:`--construct-nesting`\n-    Report the maximal construct nesting level\n-\n-\n-  :switch:`--no-construct-nesting`\n-    Do not report the maximal construct nesting level\n-\n-  :switch:`--param-number`\n-    Report the number of subprogram parameters\n-\n-\n-  :switch:`--no-param-number`\n-    Do not report the number of subprogram parameters\n-\n-\n-  .. _Contract_Metrics_Control:\n-\n-  Contract Metrics Control\n-  ^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-  .. index:: Contract metrics control in gnatmetric\n-\n-  :switch:`--contract-all`\n-    Report all the contract metrics\n-\n-\n-  :switch:`--no-contract-all`\n-    Do not report any of the contract metrics\n-\n-\n-  :switch:`--contract`\n-    Report the number of public subprograms with contracts\n-\n-\n-  :switch:`--no-contract`\n-    Do not report the number of public subprograms with contracts\n-\n-\n-  :switch:`--post`\n-    Report the number of public subprograms with postconditions\n-\n-\n-  :switch:`--no-post`\n-    Do not report the number of public subprograms with postconditions\n-\n-\n-  :switch:`--contract-complete`\n-    Report the number of public subprograms with complete contracts\n-\n-\n-  :switch:`--no-contract-complete`\n-    Do not report the number of public subprograms with complete contracts\n-\n-\n-  :switch:`--contract-cyclomatic`\n-    Report the McCabe complexity of public subprograms\n-\n-\n-  :switch:`--no-contract-cyclomatic`\n-    Do not report the McCabe complexity of public subprograms\n-\n-\n-  .. _Complexity_Metrics_Control:\n-\n-  Complexity Metrics Control\n-  ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-  .. index:: Complexity metrics control in gnatmetric\n-\n-  For a program unit that is an executable body (a subprogram body\n-  (including generic bodies), task body, entry body or a package body\n-  containing its own statement sequence) ``gnatmetric`` computes the\n-  following complexity metrics:\n-\n-  * McCabe cyclomatic complexity;\n-\n-  * McCabe essential complexity;\n-\n-  * maximal loop nesting level;\n-\n-  * extra exit points (for subprograms);\n-\n-  The McCabe cyclomatic complexity metric is defined\n-  in `http://www.mccabe.com/pdf/mccabe-nist235r.pdf <http://www.mccabe.com/pdf/mccabe-nist235r.pdf>`_\n-\n-  According to McCabe, both control statements and short-circuit control\n-  forms should be taken into account when computing cyclomatic\n-  complexity. For Ada 2012 we have also take into account conditional\n-  expressions and quantified expressions. For each body, we compute\n-  three metric values:\n-\n-  * the complexity introduced by control\n-    statements only, without taking into account short-circuit forms\n-    (referred as ``statement complexity`` in ``gnatmetric`` output),\n-\n-  * the complexity introduced by short-circuit control forms only\n-    (referred as ``expression complexity`` in ``gnatmetric`` output),\n-    and\n-\n-  * the total\n-    cyclomatic complexity, which is the sum of these two values\n-    (referred as ``cyclomatic complexity`` in ``gnatmetric`` output).\n-\n-  The cyclomatic complexity is also computed for Ada 2012 expression functions.\n-  An expression function cannot have statements as its components, so only one\n-  metric value is computed as a cyclomatic complexity of an expression function.\n-\n-  The origin of cyclomatic complexity metric is the need to estimate the number\n-  of independent paths in the control flow graph that in turn gives the number\n-  of tests needed to satisfy paths coverage testing completeness criterion.\n-  Considered from the testing point of view, a static Ada ``loop`` (that is,\n-  the ``loop`` statement having static subtype in loop parameter\n-  specification) does not add to cyclomatic complexity. By providing\n-  :switch:`--no-static-loop` option a user\n-  may specify that such loops should not be counted when computing the\n-  cyclomatic complexity metric\n-\n-  The Ada essential complexity metric is a McCabe cyclomatic complexity metric\n-  counted for the code that is reduced by excluding all the pure structural Ada\n-  control statements. An compound statement is considered as a non-structural\n-  if it contains a ``raise`` or ``return`` statement as it subcomponent,\n-  or if it contains a ``goto`` statement that transfers the control outside\n-  the operator. A selective ``accept`` statement with a ``terminate`` alternative\n-  is considered a non-structural statement. When computing this metric,\n-  ``exit`` statements are treated in the same way as ``goto``\n-  statements unless the :switch:`-ne` option is specified.\n-\n-  The Ada essential complexity metric defined here is intended to quantify\n-  the extent to which the software is unstructured. It is adapted from\n-  the McCabe essential complexity metric defined in\n-  http://www.mccabe.com/pdf/mccabe-nist235r.pdf\n-  but is modified to be more\n-  suitable for typical Ada usage. For example, short circuit forms\n-  are not penalized as unstructured in the Ada essential complexity metric.\n-\n-  When computing cyclomatic and essential complexity, ``gnatmetric`` skips\n-  the code in the exception handlers and in all the nested program units. The\n-  code of assertions and predicates (that is, subprogram preconditions and\n-  postconditions, subtype predicates and type invariants) is also skipped.\n-\n-  By default, all the complexity metrics are reported. For more fine-grained\n-  control you can use the following switches:\n-\n-\n-  .. index:: --complexity (gnatmetric)\n-  .. index:: --no-complexity (gnatmetric)\n-\n-\n-  :switch:`--complexity-all`\n-    Report all the complexity metrics\n-\n-\n-  :switch:`--no-complexity-all`\n-    Do not report any of the complexity metrics\n-\n-\n-  :switch:`--complexity-cyclomatic`\n-    Report the McCabe Cyclomatic Complexity\n-\n-\n-  :switch:`--no-complexity-cyclomatic`\n-    Do not report the McCabe Cyclomatic Complexity\n-\n-\n-  :switch:`--complexity-essential`\n-    Report the Essential Complexity\n-\n-\n-  :switch:`--no-complexity-essential`\n-    Do not report the Essential Complexity\n-\n-\n-  :switch:`--loop-nesting`\n-    Report maximal loop nesting level\n-\n-\n-  :switch:`--no-loop-nesting`\n-    Do not report maximal loop nesting level\n-\n-\n-  :switch:`--complexity-average`\n-    Report the average McCabe Cyclomatic Complexity for all the subprogram bodies,\n-    task bodies, entry bodies and statement sequences in package bodies.\n-    The metric is reported for whole set of processed Ada sources only.\n-\n-\n-  :switch:`--no-complexity-average`\n-    Do not report the average McCabe Cyclomatic Complexity for all the subprogram\n-    bodies, task bodies, entry bodies and statement sequences in package bodies\n-\n-  .. index:: --no-treat-exit-as-goto (gnatmetric)\n-\n-\n-  :switch:`--no-treat-exit-as-goto`\n-    Do not consider ``exit`` statements as ``goto``\\ s when\n-    computing Essential Complexity\n-\n-  .. index:: --no-static-loop (gnatmetric)\n-\n-\n-  :switch:`--no-static-loop`\n-    Do not consider static loops when computing cyclomatic complexity\n-\n-\n-  :switch:`--extra-exit-points`\n-    Report the extra exit points for subprogram bodies. As an exit point, this\n-    metric counts ``return`` statements and raise statements in case when the\n-    raised exception is not handled in the same body. In case of a function this\n-    metric subtracts 1 from the number of exit points, because a function body\n-    must contain at least one ``return`` statement.\n-\n-\n-  :switch:`--no-extra-exit-points`\n-    Do not report the extra exit points for subprogram bodies\n-\n-\n-  .. _Coupling_Metrics_Control:\n-\n-  Coupling Metrics Control\n-  ^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-  .. index:: Coupling metrics control in gnatmetric\n-\n-  .. index:: Coupling metrics (in gnatmetric)\n-\n-  Coupling metrics measure the dependencies between a given entity and other\n-  entities in the program. This information is useful since high coupling\n-  may signal potential issues with maintainability as the program evolves.\n-\n-  ``gnatmetric`` computes the following coupling metrics:\n-\n-\n-  * *object-oriented coupling*, for classes in traditional object-oriented\n-    sense;\n-\n-  * *unit coupling*, for all the program units making up a program;\n-\n-  * *control coupling*, reflecting dependencies between a unit and\n-    other units that contain subprograms.\n-\n-  .. index:: fan-out coupling\n-  .. index:: efferent coupling\n-\n-  Two kinds of coupling metrics are computed:\n-\n-  * fan-out coupling ('efferent coupling'):\n-    the number of entities the given entity depends upon. This metric\n-    reflects how the given entity depends on the changes in the\n-    'external world'.\n-\n-  .. index:: fan-in coupling\n-  .. index:: afferent coupling\n-\n-  * fan-in coupling ('afferent' coupling):\n-    the number of entities that depend on a given entity.\n-    This metric reflects how the 'external world' depends on the changes in a\n-    given entity.\n-\n-  Object-oriented coupling metrics measure the dependencies\n-  between a given class (or a group of classes) and the other classes in the\n-  program. In this subsection the term 'class' is used in its traditional\n-  object-oriented programming sense (an instantiable module that contains data\n-  and/or method members). A *category* (of classes) is a group of closely\n-  related classes that are reused and/or modified together.\n-\n-  A class ``K``\\ 's fan-out coupling is the number of classes\n-  that ``K`` depends upon.\n-  A category's fan-out coupling is the number of classes outside the\n-  category that the classes inside the category depend upon.\n-\n-  A class ``K``\\ 's fan-in coupling is the number of classes\n-  that depend upon ``K``.\n-  A category's fan-in coupling is the number of classes outside the\n-  category that depend on classes belonging to the category.\n-\n-  Ada's object-oriented paradigm separates the instantiable entity\n-  (type) from the module (package), so the definition of the coupling\n-  metrics for Ada maps the class and class category notions\n-  onto Ada constructs.\n-\n-  For the coupling metrics, several kinds of modules that define a tagged type\n-  or an interface type  -- library packages, library generic packages, and\n-  library generic package instantiations -- are considered to be classes.\n-  A category consists of a library package (or\n-  a library generic package) that defines a tagged or an interface type,\n-  together with all its descendant (generic) packages that define tagged\n-  or interface types. Thus a\n-  category is an Ada hierarchy of library-level program units. Class\n-  coupling in Ada is referred to as 'tagged coupling', and category coupling\n-  is referred to as 'hierarchy coupling'.\n-\n-  For any package serving as a class, its body and subunits (if any) are\n-  considered together with its spec when computing dependencies, and coupling\n-  metrics are reported for spec units only. Dependencies between classes\n-  mean Ada semantic dependencies. For object-oriented coupling\n-  metrics, only dependencies on units treated as classes are\n-  considered.\n-\n-  Similarly, for unit and control coupling an entity is considered to be the\n-  conceptual construct consisting of the entity's specification, body, and\n-  any subunits (transitively).\n-  ``gnatmetric`` computes\n-  the dependencies of all these units as a whole, but\n-  metrics are only reported for spec\n-  units (or for a subprogram body unit in case if there is no\n-  separate spec for the given subprogram).\n-\n-  For unit coupling, dependencies are computed between all kinds of program\n-  units. For control coupling, the dependencies of a given unit are limited to\n-  those units that define subprograms. Thus control fan-out coupling is reported\n-  for all units, but control fan-in coupling is only reported for units\n-  that define subprograms.\n-\n-  The following simple example illustrates the difference between unit coupling\n-  and control coupling metrics:\n-\n-    .. code-block:: ada\n-\n-         package Lib_1 is\n-             function F_1 (I : Integer) return Integer;\n-         end Lib_1;\n-\n-         package Lib_2 is\n-             type T_2 is new Integer;\n-         end Lib_2;\n-\n-         package body Lib_1 is\n-             function F_1 (I : Integer) return Integer is\n-             begin\n-                return I + 1;\n-             end F_1;\n-         end Lib_1;\n-\n-         with Lib_2; use Lib_2;\n-         package Pack is\n-             Var : T_2;\n-             function Fun (I : Integer) return Integer;\n-         end Pack;\n-\n-         with Lib_1; use Lib_1;\n-         package body Pack is\n-             function Fun (I : Integer) return Integer is\n-             begin\n-                return F_1 (I);\n-             end Fun;\n-         end Pack;\n-\n-  If we apply ``gnatmetric`` with the :switch:`--coupling-all` option to\n-  these units, the result will be:\n-\n-    ::\n-\n-       Coupling metrics:\n-       =================\n-           Unit Lib_1 (C:\\\\customers\\\\662\\\\L406-007\\\\lib_1.ads)\n-              control fan-out coupling  : 0\n-              control fan-in coupling   : 1\n-              unit fan-out coupling     : 0\n-              unit fan-in coupling      : 1\n-\n-           Unit Pack (C:\\\\customers\\\\662\\\\L406-007\\\\pack.ads)\n-              control fan-out coupling  : 1\n-              control fan-in coupling   : 0\n-              unit fan-out coupling     : 2\n-              unit fan-in coupling      : 0\n-\n-           Unit Lib_2 (C:\\\\customers\\\\662\\\\L406-007\\\\lib_2.ads)\n-              control fan-out coupling  : 0\n-              unit fan-out coupling     : 0\n-              unit fan-in coupling      : 1\n-\n-  The result does not contain values for object-oriented\n-  coupling because none of the argument units contains a tagged type and\n-  therefore none of these units can be treated as a class.\n-\n-  The ``Pack`` package (spec and body) depends on two\n-  units -- ``Lib_1`` and ``Lib_2`` -- and so its unit fan-out coupling\n-  is 2. Since nothing depends on it, its unit fan-in coupling is 0, as\n-  is its control fan-in coupling. Only one of the units ``Pack`` depends\n-  upon defines a subprogram, so its control fan-out coupling is 1.\n-\n-  ``Lib_2`` depends on nothing, so its fan-out metrics are 0. It does\n-  not define any subprograms, so it has no control fan-in metric.\n-  One unit (``Pack``) depends on it , so its unit fan-in coupling is 1.\n-\n-  ``Lib_1`` is similar to ``Lib_2``, but it does define a subprogram.\n-  Its control fan-in coupling is 1 (because there is one unit\n-  depending on it).\n-\n-  When computing coupling metrics, ``gnatmetric`` counts only\n-  dependencies between units that are arguments of the ``gnatmetric``\n-  invocation. Coupling metrics are program-wide (or project-wide) metrics, so\n-  you should invoke ``gnatmetric`` for\n-  the complete set of sources comprising your program. This can be done\n-  by invoking ``gnatmetric`` with the corresponding project file\n-  and with the :switch:`-U` option.\n-\n-  By default, all the coupling metrics are reported. You can use the following\n-  switches to select specific syntax metrics.\n-\n-  .. index:: --tagged-coupling (gnatmetric)\n-  .. index:: --hierarchy-coupling (gnatmetric)\n-  .. index:: --unit-coupling (gnatmetric)\n-  .. index:: --control-coupling (gnatmetric)\n-\n-  :switch:`--coupling-all`\n-    Report all the coupling metrics\n-\n-\n-  :switch:`--tagged-coupling-out`\n-    Report tagged (class) fan-out coupling\n-\n-\n-  :switch:`--tagged-coupling-in`\n-    Report tagged (class) fan-in coupling\n-\n-\n-  :switch:`--hierarchy-coupling-out`\n-    Report hierarchy (category) fan-out coupling\n-\n-\n-  :switch:`--hierarchy-coupling-in`\n-    Report hierarchy (category) fan-in coupling\n-\n-\n-  :switch:`--unit-coupling-out`\n-    Report unit fan-out coupling\n-\n-\n-  :switch:`--unit-coupling-in`\n-    Report unit fan-in coupling\n-\n-\n-  :switch:`--control-coupling-out`\n-    Report control fan-out coupling\n-\n-\n-  :switch:`--control-coupling-in`\n-    Report control fan-in coupling\n-\n-\n-  .. _Other_gnatmetric_Switches:\n-\n-  Other ``gnatmetric`` Switches\n-  -----------------------------\n-\n-  Additional ``gnatmetric`` switches are as follows:\n-\n-\n-  .. index:: --version (gnatmetric)\n-\n-  :switch:`--version`\n-    Display copyright and version, then exit disregarding all other options.\n-\n-\n-  .. index:: --help (gnatmetric)\n-\n-  :switch:`--help`\n-    Display usage, then exit disregarding all other options.\n-\n-\n-  .. index:: -P (gnatmetric)\n-\n-  :switch:`-P {file}`\n-    Indicates the name of the project file that describes the set of sources\n-    to be processed. The exact set of argument sources depends on other options\n-    specified, see below. An aggregate project is allowed as the file parameter\n-    only if it has exactly one non-aggregate project being aggregated.\n-\n-\n-  .. index:: -U (gnatmetric)\n-\n-  :switch:`-U`\n-    If a project file is specified and no argument source is explicitly\n-    specified (either directly or by means of :switch:`-files` option), process\n-    all the units of the closure of the argument project. Otherwise this option\n-    has no effect.\n-\n-\n-  :switch:`-U {main_unit}`\n-    If a project file is specified and no argument source is explicitly\n-    specified (either directly or by means of :switch:`-files` option), process\n-    the closure of units rooted at ``main_unit``. Otherwise this option\n-    has no effect.\n-\n-\n-  .. index:: -X (gnatmetric)\n-\n-  :switch:`-X{name}={value}`\n-    Indicates that external variable ``name`` in the argument project\n-    has the value ``value``. Has no effect if no project is specified.\n-\n-\n-  .. index:: --RTS (gnatmetric)\n-\n-  :switch:`--RTS={rts-path}`\n-    Specifies the default location of the runtime library. Same meaning as the\n-    equivalent ``gnatmake`` flag (see :ref:`Switches_for_gnatmake`).\n-\n-\n-  .. index:: --subdirs=dir (gnatmetric)\n-\n-  :switch:`--subdirs={dir}`\n-    Use the specified subdirectory of the project objects file (or of the\n-    project file directory if the project does not specify an object directory)\n-    for tool output files. Has no effect if no project is specified as\n-    tool argument r if :switch:`--no-objects-dir` is specified.\n-\n-\n-  .. index:: --files (gnatmetric)\n-\n-  :switch:`--files={file}`\n-    Take as arguments the files listed in text file ``file``.\n-    Text file ``file`` may contain empty lines that are ignored.\n-    Each nonempty line should contain the name of an existing file.\n-    Several such switches may be specified simultaneously.\n-\n-\n-  .. index:: --ignore (gnatmetric)\n-\n-  :switch:`--ignore={filename}`\n-    Do not process the sources listed in a specified file.\n-\n-\n-  .. index:: --verbose (gnatmetric)\n-\n-  :switch:`--verbose`\n-    Verbose mode;\n-    ``gnatmetric`` generates version information and then\n-    a trace of sources being processed.\n-\n-\n-  .. index:: --quiet (gnatmetric)\n-\n-  :switch:`--quiet`\n-    Quiet mode.\n-\n-  If a project file is specified and no argument source is explicitly\n-  specified (either directly or by means of :switch:`-files` option), and no\n-  :switch:`-U` is specified, then the set of processed sources is\n-  all the immediate units of the argument project.\n-\n-\n-  Legacy Switches\n-  ^^^^^^^^^^^^^^^\n-\n-  Some switches have a short form, mostly for legacy reasons,\n-  as shown below.\n-\n-  .. index:: -x (gnatmetric)\n-\n-  :switch:`-x`\n-    :switch:`--generate-xml-output`\n-\n-  .. index:: -xs (gnatmetric)\n-\n-  :switch:`-xs`\n-    :switch:`--generate-xml-schema`\n-\n-  .. index:: -nt (gnatmetric)\n-\n-  :switch:`-nt`\n-    :switch:`--no-text-output`\n-\n-  .. index:: -d (gnatmetric)\n-\n-  :switch:`-d {output-dir}`\n-    :switch:`--output-dir`\n-\n-  .. index:: -o (gnatmetric)\n-\n-  :switch:`-o {file-suffix}`\n-    :switch:`--output-suffix`\n-\n-  .. index:: -og (gnatmetric)\n-\n-  :switch:`-og {file-name}`\n-    :switch:`--global-file-name`\n-\n-  .. index:: -ox (gnatmetric)\n-\n-  :switch:`-ox {file-name}`\n-    :switch:`--xml-file-name`\n-\n-  .. index:: -sfn (gnatmetric)\n-\n-  :switch:`-sfn`\n-    :switch:`--short-file-names`\n-\n-  .. index:: -W (gnatsmetric)\n-\n-  :switch:`-W{e}`\n-    :switch:`--wide-character-encoding={e}`\n-\n-  .. index:: -nolocal (gnatmetric)\n-\n-  :switch:`-nolocal`\n-    :switch:`--no-local-metrics`\n-\n-  .. index:: -ne (gnatmetric)\n-\n-  :switch:`-ne`\n-    :switch:`--no-treat-exit-as-goto`\n-\n-  .. index:: -files (gnatmetric)\n-\n-  :switch:`-files {filename}`\n-    :switch:`--files`\n-\n-  .. index:: -v (gnatmetric)\n-\n-  :switch:`-v`\n-    :switch:`--verbose`\n-\n-  .. index:: -q (gnatmetric)\n-\n-  :switch:`-q`\n-    :switch:`--quiet`\n-\n .. only:: PRO or GPL\n \n    .. _The_GNAT_Pretty_Printer_gnatpp:\n@@ -3026,7 +1908,7 @@ building specialized scripts.\n       naming conventions.\n \n       Note that it is no longer necessary to specify the Ada language version;\n-      ``gnatmetric`` can process Ada source code written in any version from\n+      ``gnatstub`` can process Ada source code written in any version from\n       Ada 83 onward without specifying any language version switch.\n \n   * *switches*"}, {"sha": "48fb1076e91e11fcb2e1ebdc411f54dae8e406e6", "filename": "gcc/ada/expect.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fexpect.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fexpect.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexpect.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -42,17 +42,13 @@\n #include \"adaint.h\"\n #include <sys/types.h>\n \n-#ifdef __MINGW32__\n-# if OLD_MINGW\n-#  include <sys/wait.h>\n-# endif\n-#elif defined (__vxworks) && defined (__RTP__)\n+#if defined (__vxworks) && defined (__RTP__)\n # include <wait.h>\n #elif defined (__Lynx__)\n   /* ??? See comment in adaint.c.  */\n # define GCC_RESOURCE_H\n # include <sys/wait.h>\n-#elif defined (__PikeOS__)\n+#elif defined (__PikeOS__) || defined (__MINGW32__)\n   /* No wait.h available */\n #else\n #include <sys/wait.h>"}, {"sha": "64f2e796d8aea0a1e1cb9abb26d155b91d664131", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -19,7 +19,7 @@\n \n @copying\n @quotation\n-GNAT Reference Manual , Sep 09, 2022\n+GNAT Reference Manual , Sep 23, 2022\n \n AdaCore\n \n@@ -433,7 +433,7 @@ Implementation Defined Attributes\n * Attribute Universal_Literal_String:: \n * Attribute Unrestricted_Access:: \n * Attribute Update:: \n-* Attribute Valid_Image:: \n+* Attribute Valid_Value:: \n * Attribute Valid_Scalars:: \n * Attribute VADS_Size:: \n * Attribute Value_Size:: \n@@ -10295,7 +10295,7 @@ consideration, you should minimize the use of these attributes.\n * Attribute Universal_Literal_String:: \n * Attribute Unrestricted_Access:: \n * Attribute Update:: \n-* Attribute Valid_Image:: \n+* Attribute Valid_Value:: \n * Attribute Valid_Scalars:: \n * Attribute VADS_Size:: \n * Attribute Value_Size:: \n@@ -12040,7 +12040,7 @@ In general this is a risky approach. It may appear to \u201cwork\u201d but such uses o\n @code{Unrestricted_Access} are potentially non-portable, even from one version\n of GNAT to another, so are best avoided if possible.\n \n-@node Attribute Update,Attribute Valid_Image,Attribute Unrestricted_Access,Implementation Defined Attributes\n+@node Attribute Update,Attribute Valid_Value,Attribute Unrestricted_Access,Implementation Defined Attributes\n @anchor{gnat_rm/implementation_defined_attributes attribute-update}@anchor{1ac}\n @section Attribute Update\n \n@@ -12121,19 +12121,19 @@ A := A'Update ((1, 2) => 20, (3, 4) => 30);\n \n which changes element (1,2) to 20 and (3,4) to 30.\n \n-@node Attribute Valid_Image,Attribute Valid_Scalars,Attribute Update,Implementation Defined Attributes\n-@anchor{gnat_rm/implementation_defined_attributes attribute-valid-image}@anchor{1ad}\n-@section Attribute Valid_Image\n+@node Attribute Valid_Value,Attribute Valid_Scalars,Attribute Update,Implementation Defined Attributes\n+@anchor{gnat_rm/implementation_defined_attributes attribute-valid-value}@anchor{1ad}\n+@section Attribute Valid_Value\n \n \n-@geindex Valid_Image\n+@geindex Valid_Value\n \n-The @code{'Valid_Image} attribute is defined for enumeration types other than\n+The @code{'Valid_Value} attribute is defined for enumeration types other than\n those in package Standard. This attribute is a function that takes\n-a String, and returns Boolean. @code{T'Valid_Image (S)} returns True\n+a String, and returns Boolean. @code{T'Valid_Value (S)} returns True\n if and only if @code{T'Value (S)} would not raise Constraint_Error.\n \n-@node Attribute Valid_Scalars,Attribute VADS_Size,Attribute Valid_Image,Implementation Defined Attributes\n+@node Attribute Valid_Scalars,Attribute VADS_Size,Attribute Valid_Value,Implementation Defined Attributes\n @anchor{gnat_rm/implementation_defined_attributes attribute-valid-scalars}@anchor{1ae}\n @section Attribute Valid_Scalars\n "}, {"sha": "7d96dbe6aa1ef7511706eee2a39db85e59ccd5bb", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -19,7 +19,7 @@\n \n @copying\n @quotation\n-GNAT User's Guide for Native Platforms , Sep 09, 2022\n+GNAT User's Guide for Native Platforms , Sep 26, 2022\n \n AdaCore\n \n@@ -9220,6 +9220,7 @@ Float_Size                 : Pos; -- Standard.Float'Size\n Float_Words_BE             : Nat; -- Float words stored big-endian?\n Int_Size                   : Pos; -- Standard.Integer'Size\n Long_Double_Size           : Pos; -- Standard.Long_Long_Float'Size\n+Long_Long_Long_Size        : Pos; -- Standard.Long_Long_Long_Integer'Size\n Long_Long_Size             : Pos; -- Standard.Long_Long_Integer'Size\n Long_Size                  : Pos; -- Standard.Long_Integer'Size\n Maximum_Alignment          : Pos; -- Maximum permitted alignment\n@@ -9307,6 +9308,7 @@ Float_Size                   32\n Float_Words_BE                0\n Int_Size                     64\n Long_Double_Size            128\n+Long_Long_Long_Size         128\n Long_Long_Size               64\n Long_Size                    64\n Maximum_Alignment            16\n@@ -15317,10 +15319,11 @@ Linker switches can be specified after @code{-largs} builder switch.\n \n @item @code{-fuse-ld=`name'}\n \n-Linker to be used. The default is @code{bfd} for @code{ld.bfd},\n-the alternative being @code{gold} for @code{ld.gold}. The later is\n-a more recent and faster linker, but only available on GNU/Linux\n+Linker to be used. The default is @code{bfd} for @code{ld.bfd}; @code{gold}\n+(for @code{ld.gold}) and @code{mold} (for @code{ld.mold}) are more\n+recent and faster alternatives, but only available on GNU/Linux\n platforms.\n+\n @end table\n \n @node Binding with gnatbind,Linking with gnatlink,Linker Switches,Building Executable Programs with GNAT\n@@ -17932,7 +17935,6 @@ instr.ads\n \n \n \n-\n @c -- Example: A |withing| unit has a |with| clause, it |withs| a |withed| unit\n \n @node GNAT and Program Execution,Platform-Specific Information,GNAT Utility Programs,Top"}, {"sha": "561f2ffb5662e53ee296a424362e6159bb09c028", "filename": "gcc/ada/gsocket.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fgsocket.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fgsocket.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgsocket.h?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -80,12 +80,6 @@\n #define FD_SETSIZE 1024\n \n #ifdef __MINGW32__\n-/* winsock2.h allows WSAPoll related definitions only when\n- * _WIN32_WINNT >= 0x0600 */\n-#if !defined(_WIN32_WINNT) || _WIN32_WINNT < 0x0600\n-#define _WIN32_WINNT 0x0600\n-#endif\n-\n #include <winsock2.h>\n #include <ws2tcpip.h>\n #include <versionhelpers.h>"}, {"sha": "d038211a1dc1d9833edfc4b3fe7846ebda5d9e7d", "filename": "gcc/ada/mingw32.h", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fmingw32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fmingw32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmingw32.h?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -44,11 +44,6 @@\n #define UNICODE  /* For Win32 API */\n #endif\n \n-/* We need functionality available only starting with Windows XP */\n-#ifndef _WIN32_WINNT\n-#define _WIN32_WINNT 0x0501\n-#endif\n-\n #ifndef __CYGWIN__\n #include <tchar.h>\n #endif\n@@ -99,27 +94,4 @@ extern UINT __gnat_current_ccs_encoding;\n #define WS2S(str,wstr,len) strncpy(str,wstr,len)\n #endif\n \n-#include <stdlib.h>\n-\n-/* STD_MINGW: standard if MINGW32 version > 1.3, we have switched to this\n-   version instead of the previous enhanced version to ease building GNAT on\n-   Windows platforms. By using STD_MINGW or OLD_MINGW it is possible to build\n-   GNAT using both MingW include files (Old MingW + ACT changes and standard\n-   MingW starting with version 1.3.\n-   For w64 Mingw the define STD_MINGW is always set to value 1, because\n-   there is no old header set present.  */\n-#ifdef _WIN64\n-#define STD_MINGW 1\n-#else\n-#define STD_MINGW ((__MINGW32_MAJOR_VERSION == 1 \\\n-\t\t   && __MINGW32_MINOR_VERSION >= 3) \\\n-     || (__MINGW32_MAJOR_VERSION >= 2))\n-#endif\n-\n-#define OLD_MINGW (!(STD_MINGW))\n-\n-#ifndef MAXPATHLEN\n-#define MAXPATHLEN MAX_PATH\n-#endif\n-\n #endif /* _MINGW32_H */"}, {"sha": "24aca2cf6b6ba2aa31c1a9afe65da3e137b57d53", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 2, "deletions": 109, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -189,7 +189,6 @@ package Rtsfind is\n       --  Children of Interfaces\n \n       Interfaces_C,\n-      Interfaces_Packed_Decimal,\n \n       --  Children of Interfaces.C\n \n@@ -205,7 +204,6 @@ package Rtsfind is\n       System_Address_To_Access_Conversions,\n       System_Arith_64,\n       System_Arith_128,\n-      System_AST_Handling,\n       System_Assertions,\n       System_Atomic_Operations,\n       System_Atomic_Primitives,\n@@ -257,9 +255,6 @@ package Rtsfind is\n       System_Fat_LFlt,\n       System_Fat_LLF,\n       System_Fat_SFlt,\n-      System_Fat_VAX_D_Float,\n-      System_Fat_VAX_F_Float,\n-      System_Fat_VAX_G_Float,\n       System_Finalization_Masters,\n       System_Finalization_Root,\n       System_Fore_Decimal_32,\n@@ -288,14 +283,12 @@ package Rtsfind is\n       System_Img_LLLI,\n       System_Img_LLU,\n       System_Img_LLLU,\n-      System_Img_Name,\n       System_Img_Uns,\n       System_Img_WChar,\n       System_Interrupts,\n       System_Long_Long_Float_Expon,\n       System_Machine_Code,\n       System_Mantissa,\n-      System_Memcop,\n       System_Memory,\n       System_Multiprocessors,\n       System_Pack_03,\n@@ -420,10 +413,7 @@ package Rtsfind is\n       System_Pack_127,\n       System_Parameters,\n       System_Partition_Interface,\n-      System_Pool_32_Global,\n       System_Pool_Global,\n-      System_Pool_Empty,\n-      System_Pool_Local,\n       System_Pool_Size,\n       System_Put_Images,\n       System_Put_Task_Images,\n@@ -440,7 +430,6 @@ package Rtsfind is\n       System_Stream_Attributes,\n       System_Task_Info,\n       System_Tasking,\n-      System_Threads,\n       System_Unsigned_Types,\n       System_Val_Bool,\n       System_Val_Char,\n@@ -461,7 +450,6 @@ package Rtsfind is\n       System_Val_LLLI,\n       System_Val_LLU,\n       System_Val_LLLU,\n-      System_Val_Name,\n       System_Val_Uns,\n       System_Val_WChar,\n       System_Version_Control,\n@@ -475,7 +463,6 @@ package Rtsfind is\n       System_Wid_LLLI,\n       System_Wid_LLU,\n       System_Wid_LLLU,\n-      System_Wid_Name,\n       System_Wid_Uns,\n       System_Wid_WChar,\n       System_WWd_Char,\n@@ -484,7 +471,7 @@ package Rtsfind is\n \n       --  Children of System.Atomic_Operations\n \n-       System_Atomic_Operations_Test_And_Set,\n+      System_Atomic_Operations_Test_And_Set,\n \n       --  Children of System.Dim\n \n@@ -561,17 +548,13 @@ package Rtsfind is\n \n      RE_Set_Deadline,                    -- Ada.Dispatching.EDF\n \n-     RE_Code_Loc,                        -- Ada.Exceptions\n      RE_Exception_Id,                    -- Ada.Exceptions\n-     RE_Exception_Identity,              -- Ada.Exceptions\n      RE_Exception_Information,           -- Ada.Exceptions\n      RE_Exception_Message,               -- Ada.Exceptions\n      RE_Exception_Name_Simple,           -- Ada.Exceptions\n      RE_Exception_Occurrence,            -- Ada.Exceptions\n-     RE_Exception_Occurrence_Access,     -- Ada.Exceptions\n      RE_Null_Id,                         -- Ada.Exceptions\n      RE_Null_Occurrence,                 -- Ada.Exceptions\n-     RE_Poll,                            -- Ada.Exceptions\n      RE_Raise_Exception,                 -- Ada.Exceptions\n      RE_Raise_Exception_Always,          -- Ada.Exceptions\n      RE_Raise_From_Controlled_Operation, -- Ada.Exceptions\n@@ -596,7 +579,7 @@ package Rtsfind is\n      RE_Names,                           -- Ada.Interrupts.Names\n \n      RE_Clock,                           -- Ada.Real_Time\n-     RE_Clock_Time,                      -- Ada.Real_Time\n+     RE_Clock_Time,                      -- Ada.Real_Time [used by GNATprove]\n      RE_Time_Span,                       -- Ada.Real_Time\n      RE_Time_Span_Zero,                  -- Ada.Real_Time\n      RO_RT_Time,                         -- Ada.Real_Time\n@@ -612,8 +595,6 @@ package Rtsfind is\n      RE_Stream_Element_Array,            -- Ada.Streams\n      RE_Stream_Element_Offset,           -- Ada.Streams\n \n-     RE_Stream_Access,                   -- Ada.Streams.Stream_IO\n-\n      RO_SU_Super_String,                 -- Ada.Strings.Superbounded\n \n      RO_WI_Super_String,                 -- Ada.Strings.Wide_Superbounded\n@@ -628,8 +609,6 @@ package Rtsfind is\n \n      RE_Buffer_Type,                     -- Ada.Strings.Text_Buffers.Unbounded\n      RE_Get,                             -- Ada.Strings.Text_Buffers.Unbounded\n-     RE_Wide_Get,                        -- Ada.Strings.Text_Buffers.Unbounded\n-     RE_Wide_Wide_Get,                   -- Ada.Strings.Text_Buffers.Unbounded\n \n      RE_Wait_For_Release,                -- Ada.Synchronous_Barriers\n \n@@ -641,7 +620,6 @@ package Rtsfind is\n      RE_Address_Array,                   -- Ada.Tags\n      RE_Addr_Ptr,                        -- Ada.Tags\n      RE_Base_Address,                    -- Ada.Tags\n-     RE_Check_Interface_Conversion,      -- Ada.Tags\n      RE_Check_TSD,                       -- Ada.Tags\n      RE_Cstring_Ptr,                     -- Ada.Tags\n      RE_CW_Membership,                   -- Ada.Tags\n@@ -656,13 +634,11 @@ package Rtsfind is\n      RE_External_Tag,                    -- Ada.Tags\n      RO_TA_External_Tag,                 -- Ada.Tags\n      RE_Get_Access_Level,                -- Ada.Tags\n-     RE_Get_Alignment,                   -- Ada.Tags\n      RE_Get_Entry_Index,                 -- Ada.Tags\n      RE_Get_Offset_Index,                -- Ada.Tags\n      RE_Get_Prim_Op_Kind,                -- Ada.Tags\n      RE_Get_Tagged_Kind,                 -- Ada.Tags\n      RE_HT_Link,                         -- Ada.Tags\n-     RE_Idepth,                          -- Ada.Tags\n      RE_Interfaces_Array,                -- Ada.Tags\n      RE_Interfaces_Table,                -- Ada.Tags\n      RE_Interface_Data,                  -- Ada.Tags\n@@ -675,8 +651,6 @@ package Rtsfind is\n      RE_No_Dispatch_Table_Wrapper,       -- Ada.Tags\n      RE_No_Tag,                          -- Ada.Tags\n      RE_NDT_Prims_Ptr,                   -- Ada.Tags\n-     RE_NDT_TSD,                         -- Ada.Tags\n-     RE_Num_Prims,                       -- Ada.Tags\n      RE_Object_Specific_Data,            -- Ada.Tags\n      RE_Offset_To_Top,                   -- Ada.Tags\n      RE_Offset_To_Top_Ptr,               -- Ada.Tags\n@@ -699,11 +673,9 @@ package Rtsfind is\n      RE_Primary_DT,                      -- Ada.Tags\n      RE_Signature,                       -- Ada.Tags\n      RE_SSD,                             -- Ada.Tags\n-     RE_TSD,                             -- Ada.Tags\n      RE_Type_Specific_Data,              -- Ada.Tags\n      RE_Register_Interface_Offset,       -- Ada.Tags\n      RE_Register_Tag,                    -- Ada.Tags\n-     RE_Register_TSD,                    -- Ada.Tags\n      RE_Transportable,                   -- Ada.Tags\n      RE_Secondary_DT,                    -- Ada.Tags\n      RE_Secondary_Tag,                   -- Ada.Tags\n@@ -749,7 +721,6 @@ package Rtsfind is\n \n      RE_Stream_T,                        -- CUDA.Driver_Types\n \n-     RE_Fatbin_Wrapper,                  -- CUDA.Internal\n      RE_Launch_Kernel,                   -- CUDA.Internal\n      RE_Pop_Call_Configuration,          -- CUDA.Internal\n      RE_Push_Call_Configuration,         -- CUDA.Internal\n@@ -772,19 +743,14 @@ package Rtsfind is\n \n      RO_IC_Unsigned,                     -- Interfaces.C\n \n-     RE_Chars_Ptr,                       -- Interfaces.C.Strings\n-     RE_New_Char_Array,                  -- Interfaces.C.Strings\n-\n      RE_Address,                         -- System\n      RE_Any_Priority,                    -- System\n      RE_Bit_Order,                       -- System\n      RE_Default_Priority,                -- System\n      RE_High_Order_First,                -- System\n      RE_Interrupt_Priority,              -- System\n-     RE_Lib_Stop,                        -- System\n      RE_Low_Order_First,                 -- System\n      RE_Max_Base_Digits,                 -- System\n-     RE_Max_Priority,                    -- System\n      RE_Null_Address,                    -- System\n      RE_Priority,                        -- System\n \n@@ -802,8 +768,6 @@ package Rtsfind is\n      RE_Subtract_With_Ovflo_Check128,    -- System.Arith_128\n      RE_Scaled_Divide128,                -- System.Arith_128\n \n-     RE_Create_AST_Handler,              -- System.AST_Handling\n-\n      RE_Assert_Failure,                  -- System.Assertions\n      RE_Raise_Assert_Failure,            -- System.Assertions\n \n@@ -824,9 +788,6 @@ package Rtsfind is\n      RE_Atomic_Test_And_Set,           -- System.Atomic_Operations.Test_And_Set\n \n      RE_AST_Handler,                     -- System.Aux_DEC\n-     RE_Import_Address,                  -- System.Aux_DEC\n-     RE_Import_Value,                    -- System.Aux_DEC\n-     RE_No_AST_Handler,                  -- System.Aux_DEC\n      RE_Type_Class,                      -- System.Aux_DEC\n      RE_Type_Class_Enumeration,          -- System.Aux_DEC\n      RE_Type_Class_Integer,              -- System.Aux_DEC\n@@ -954,26 +915,15 @@ package Rtsfind is\n \n      RE_Attr_Long_Long_Float,            -- System.Fat_LLF\n \n-     RE_Attr_VAX_D_Float,                -- System.Fat_VAX_D_Float\n-     RE_Fat_VAX_D,                       -- System.Fat_VAX_D_Float\n-\n-     RE_Attr_VAX_F_Float,                -- System.Fat_VAX_F_Float\n-     RE_Fat_VAX_F,                       -- System.Fat_VAX_F_Float\n-\n-     RE_Attr_VAX_G_Float,                -- System.Fat_VAX_G_Float\n-     RE_Fat_VAX_G,                       -- System.Fat_VAX_G_Float\n-\n      RE_Add_Offset_To_Address,           -- System.Finalization_Masters\n      RE_Attach,                          -- System.Finalization_Masters\n      RE_Base_Pool,                       -- System.Finalization_Masters\n      RE_Finalization_Master,             -- System.Finalization_Masters\n      RE_Finalization_Master_Ptr,         -- System.Finalization_Masters\n      RE_Set_Base_Pool,                   -- System.Finalization_Masters\n      RE_Set_Finalize_Address,            -- System.Finalization_Masters\n-     RE_Set_Is_Heterogeneous,            -- System.Finalization_Masters\n \n      RE_Root_Controlled,                 -- System.Finalization_Root\n-     RE_Root_Controlled_Ptr,             -- System.Finalization_Root\n \n      RE_Fore_Decimal32,                  -- System.Fore_Decimal_32\n \n@@ -1649,9 +1599,7 @@ package Rtsfind is\n      RE_Set_127,                         -- System.Pack_127\n \n      RE_Adjust_Storage_Size,             -- System.Parameters\n-     RE_Default_Secondary_Stack_Size,    -- System.Parameters\n      RE_Default_Stack_Size,              -- System.Parameters\n-     RE_Garbage_Collected,               -- System.Parameters\n      RE_Size_Type,                       -- System.Parameters\n      RE_Unspecified_Size,                -- System.Parameters\n \n@@ -1677,8 +1625,6 @@ package Rtsfind is\n \n      RE_Global_Pool_Object,              -- System.Pool_Global\n \n-     RE_Global_Pool_32_Object,           -- System.Pool_32_Global\n-\n      RE_Stack_Bounded_Pool,              -- System.Pool_Size\n \n      RE_Put_Image_Integer,               -- System.Put_Images\n@@ -1744,11 +1690,8 @@ package Rtsfind is\n      RE_Set_Result,                      -- System.Partition_Interface\n      RE_Register_Obj_Receiving_Stub,     -- System.Partition_Interface\n      RE_Register_Pkg_Receiving_Stub,     -- System.Partition_Interface\n-     RE_Is_Nil,                          -- System.Partition_Interface\n-     RE_Entity_Ptr,                      -- System.Partition_Interface\n      RE_Entity_Of,                       -- System.Partition_Interface\n      RE_Inc_Usage,                       -- System.Partition_Interface\n-     RE_Set_Ref,                         -- System.Partition_Interface\n      RE_Make_Ref,                        -- System.Partition_Interface\n      RE_Get_Local_Address,               -- System.Partition_Interface\n      RE_Get_Reference,                   -- System.Partition_Interface\n@@ -1881,8 +1824,6 @@ package Rtsfind is\n      RE_Deallocate_Any_Controlled,       -- System.Storage_Pools.Subpools\n      RE_Header_Size_With_Padding,        -- System.Storage_Pools.Subpools\n      RE_Root_Storage_Pool_With_Subpools, -- System.Storage_Pools.Subpools\n-     RE_Root_Subpool,                    -- System.Storage_Pools.Subpools\n-     RE_Subpool_Handle,                  -- System.Storage_Pools.Subpools\n \n      RE_I_AD,                            -- System.Stream_Attributes\n      RE_I_AS,                            -- System.Stream_Attributes\n@@ -2006,7 +1947,6 @@ package Rtsfind is\n      RE_Simple_Mode,                     -- System.Tasking\n      RE_Terminate_Mode,                  -- System.Tasking\n      RE_Delay_Mode,                      -- System.Tasking\n-     RE_Entry_Index,                     -- System.Tasking\n      RE_Task_Entry_Index,                -- System.Tasking\n      RE_Self,                            -- System.Tasking\n \n@@ -2244,17 +2184,13 @@ package Rtsfind is\n \n      RE_Set_Deadline                     => Ada_Dispatching_EDF,\n \n-     RE_Code_Loc                         => Ada_Exceptions,\n      RE_Exception_Id                     => Ada_Exceptions,\n-     RE_Exception_Identity               => Ada_Exceptions,\n      RE_Exception_Information            => Ada_Exceptions,\n      RE_Exception_Message                => Ada_Exceptions,\n      RE_Exception_Name_Simple            => Ada_Exceptions,\n      RE_Exception_Occurrence             => Ada_Exceptions,\n-     RE_Exception_Occurrence_Access      => Ada_Exceptions,\n      RE_Null_Id                          => Ada_Exceptions,\n      RE_Null_Occurrence                  => Ada_Exceptions,\n-     RE_Poll                             => Ada_Exceptions,\n      RE_Raise_Exception                  => Ada_Exceptions,\n      RE_Raise_Exception_Always           => Ada_Exceptions,\n      RE_Raise_From_Controlled_Operation  => Ada_Exceptions,\n@@ -2295,8 +2231,6 @@ package Rtsfind is\n      RE_Stream_Element_Array             => Ada_Streams,\n      RE_Stream_Element_Offset            => Ada_Streams,\n \n-     RE_Stream_Access                    => Ada_Streams_Stream_IO,\n-\n      RO_SU_Super_String                  => Ada_Strings_Superbounded,\n \n      RO_WI_Super_String                  => Ada_Strings_Wide_Superbounded,\n@@ -2311,8 +2245,6 @@ package Rtsfind is\n \n      RE_Buffer_Type                      => Ada_Strings_Text_Buffers_Unbounded,\n      RE_Get                              => Ada_Strings_Text_Buffers_Unbounded,\n-     RE_Wide_Get                         => Ada_Strings_Text_Buffers_Unbounded,\n-     RE_Wide_Wide_Get                    => Ada_Strings_Text_Buffers_Unbounded,\n \n      RE_Wait_For_Release                 => Ada_Synchronous_Barriers,\n \n@@ -2324,7 +2256,6 @@ package Rtsfind is\n      RE_Address_Array                    => Ada_Tags,\n      RE_Addr_Ptr                         => Ada_Tags,\n      RE_Base_Address                     => Ada_Tags,\n-     RE_Check_Interface_Conversion       => Ada_Tags,\n      RE_Check_TSD                        => Ada_Tags,\n      RE_Cstring_Ptr                      => Ada_Tags,\n      RE_CW_Membership                    => Ada_Tags,\n@@ -2339,13 +2270,11 @@ package Rtsfind is\n      RE_External_Tag                     => Ada_Tags,\n      RO_TA_External_Tag                  => Ada_Tags,\n      RE_Get_Access_Level                 => Ada_Tags,\n-     RE_Get_Alignment                    => Ada_Tags,\n      RE_Get_Entry_Index                  => Ada_Tags,\n      RE_Get_Offset_Index                 => Ada_Tags,\n      RE_Get_Prim_Op_Kind                 => Ada_Tags,\n      RE_Get_Tagged_Kind                  => Ada_Tags,\n      RE_HT_Link                          => Ada_Tags,\n-     RE_Idepth                           => Ada_Tags,\n      RE_Interfaces_Array                 => Ada_Tags,\n      RE_Interfaces_Table                 => Ada_Tags,\n      RE_Interface_Data                   => Ada_Tags,\n@@ -2358,8 +2287,6 @@ package Rtsfind is\n      RE_No_Dispatch_Table_Wrapper        => Ada_Tags,\n      RE_No_Tag                           => Ada_Tags,\n      RE_NDT_Prims_Ptr                    => Ada_Tags,\n-     RE_NDT_TSD                          => Ada_Tags,\n-     RE_Num_Prims                        => Ada_Tags,\n      RE_Object_Specific_Data             => Ada_Tags,\n      RE_Offset_To_Top                    => Ada_Tags,\n      RE_Offset_To_Top_Ptr                => Ada_Tags,\n@@ -2382,11 +2309,9 @@ package Rtsfind is\n      RE_Primary_DT                       => Ada_Tags,\n      RE_Signature                        => Ada_Tags,\n      RE_SSD                              => Ada_Tags,\n-     RE_TSD                              => Ada_Tags,\n      RE_Type_Specific_Data               => Ada_Tags,\n      RE_Register_Interface_Offset        => Ada_Tags,\n      RE_Register_Tag                     => Ada_Tags,\n-     RE_Register_TSD                     => Ada_Tags,\n      RE_Transportable                    => Ada_Tags,\n      RE_Secondary_DT                     => Ada_Tags,\n      RE_Secondary_Tag                    => Ada_Tags,\n@@ -2432,7 +2357,6 @@ package Rtsfind is\n \n      RE_Stream_T                         => CUDA_Driver_Types,\n \n-     RE_Fatbin_Wrapper                   => CUDA_Internal,\n      RE_Launch_Kernel                    => CUDA_Internal,\n      RE_Pop_Call_Configuration           => CUDA_Internal,\n      RE_Push_Call_Configuration          => CUDA_Internal,\n@@ -2455,19 +2379,14 @@ package Rtsfind is\n \n      RO_IC_Unsigned                      => Interfaces_C,\n \n-     RE_Chars_Ptr                        => Interfaces_C_Strings,\n-     RE_New_Char_Array                   => Interfaces_C_Strings,\n-\n      RE_Address                          => System,\n      RE_Any_Priority                     => System,\n      RE_Bit_Order                        => System,\n      RE_Default_Priority                 => System,\n      RE_High_Order_First                 => System,\n      RE_Interrupt_Priority               => System,\n-     RE_Lib_Stop                         => System,\n      RE_Low_Order_First                  => System,\n      RE_Max_Base_Digits                  => System,\n-     RE_Max_Priority                     => System,\n      RE_Null_Address                     => System,\n      RE_Priority                         => System,\n \n@@ -2485,8 +2404,6 @@ package Rtsfind is\n      RE_Subtract_With_Ovflo_Check128     => System_Arith_128,\n      RE_Scaled_Divide128                 => System_Arith_128,\n \n-     RE_Create_AST_Handler               => System_AST_Handling,\n-\n      RE_Assert_Failure                   => System_Assertions,\n      RE_Raise_Assert_Failure             => System_Assertions,\n \n@@ -2507,9 +2424,6 @@ package Rtsfind is\n      RE_Atomic_Test_And_Set           => System_Atomic_Operations_Test_And_Set,\n \n      RE_AST_Handler                      => System_Aux_DEC,\n-     RE_Import_Address                   => System_Aux_DEC,\n-     RE_Import_Value                     => System_Aux_DEC,\n-     RE_No_AST_Handler                   => System_Aux_DEC,\n      RE_Type_Class                       => System_Aux_DEC,\n      RE_Type_Class_Enumeration           => System_Aux_DEC,\n      RE_Type_Class_Integer               => System_Aux_DEC,\n@@ -2643,26 +2557,15 @@ package Rtsfind is\n \n      RE_Attr_Long_Long_Float             => System_Fat_LLF,\n \n-     RE_Attr_VAX_D_Float                 => System_Fat_VAX_D_Float,\n-     RE_Fat_VAX_D                        => System_Fat_VAX_D_Float,\n-\n-     RE_Attr_VAX_F_Float                 => System_Fat_VAX_F_Float,\n-     RE_Fat_VAX_F                        => System_Fat_VAX_F_Float,\n-\n-     RE_Attr_VAX_G_Float                 => System_Fat_VAX_G_Float,\n-     RE_Fat_VAX_G                        => System_Fat_VAX_G_Float,\n-\n      RE_Add_Offset_To_Address            => System_Finalization_Masters,\n      RE_Attach                           => System_Finalization_Masters,\n      RE_Base_Pool                        => System_Finalization_Masters,\n      RE_Finalization_Master              => System_Finalization_Masters,\n      RE_Finalization_Master_Ptr          => System_Finalization_Masters,\n      RE_Set_Base_Pool                    => System_Finalization_Masters,\n      RE_Set_Finalize_Address             => System_Finalization_Masters,\n-     RE_Set_Is_Heterogeneous             => System_Finalization_Masters,\n \n      RE_Root_Controlled                  => System_Finalization_Root,\n-     RE_Root_Controlled_Ptr              => System_Finalization_Root,\n \n      RE_Fore_Decimal32                   => System_Fore_Decimal_32,\n \n@@ -3340,9 +3243,7 @@ package Rtsfind is\n      RE_Set_127                          => System_Pack_127,\n \n      RE_Adjust_Storage_Size              => System_Parameters,\n-     RE_Default_Secondary_Stack_Size     => System_Parameters,\n      RE_Default_Stack_Size               => System_Parameters,\n-     RE_Garbage_Collected                => System_Parameters,\n      RE_Size_Type                        => System_Parameters,\n      RE_Unspecified_Size                 => System_Parameters,\n \n@@ -3399,11 +3300,8 @@ package Rtsfind is\n      RE_Set_Result                       => System_Partition_Interface,\n      RE_Register_Obj_Receiving_Stub      => System_Partition_Interface,\n      RE_Register_Pkg_Receiving_Stub      => System_Partition_Interface,\n-     RE_Is_Nil                           => System_Partition_Interface,\n-     RE_Entity_Ptr                       => System_Partition_Interface,\n      RE_Entity_Of                        => System_Partition_Interface,\n      RE_Inc_Usage                        => System_Partition_Interface,\n-     RE_Set_Ref                          => System_Partition_Interface,\n      RE_Make_Ref                         => System_Partition_Interface,\n      RE_Get_Local_Address                => System_Partition_Interface,\n      RE_Get_Reference                    => System_Partition_Interface,\n@@ -3488,8 +3386,6 @@ package Rtsfind is\n \n      RE_Global_Pool_Object               => System_Pool_Global,\n \n-     RE_Global_Pool_32_Object            => System_Pool_32_Global,\n-\n      RE_Stack_Bounded_Pool               => System_Pool_Size,\n \n      RE_Put_Image_Integer                => System_Put_Images,\n@@ -3572,8 +3468,6 @@ package Rtsfind is\n      RE_Deallocate_Any_Controlled        => System_Storage_Pools_Subpools,\n      RE_Header_Size_With_Padding         => System_Storage_Pools_Subpools,\n      RE_Root_Storage_Pool_With_Subpools  => System_Storage_Pools_Subpools,\n-     RE_Root_Subpool                     => System_Storage_Pools_Subpools,\n-     RE_Subpool_Handle                   => System_Storage_Pools_Subpools,\n \n      RE_I_AD                             => System_Stream_Attributes,\n      RE_I_AS                             => System_Stream_Attributes,\n@@ -3697,7 +3591,6 @@ package Rtsfind is\n      RE_Simple_Mode                      => System_Tasking,\n      RE_Terminate_Mode                   => System_Tasking,\n      RE_Delay_Mode                       => System_Tasking,\n-     RE_Entry_Index                      => System_Tasking,\n      RE_Task_Entry_Index                 => System_Tasking,\n      RE_Self                             => System_Tasking,\n "}, {"sha": "53941226771fd37b8514aba6f3ec61966df64794", "filename": "gcc/ada/s-oscons-tmplt.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fs-oscons-tmplt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fs-oscons-tmplt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-oscons-tmplt.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -237,9 +237,6 @@ int counter = 0;\n #define CST(name,comment) C(#name,String,name,comment)\n /* String constant */\n \n-#define STR(x) STR1(x)\n-#define STR1(x) #x\n-\n #ifdef __MINGW32__\n unsigned int _CRT_fmode = _O_BINARY;\n #endif"}, {"sha": "ab2e182567986130c46e5d88360ade78bc7fbf9f", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -6296,13 +6296,16 @@ package body Sem_Ch12 is\n       Old_Main   : constant Entity_Id := Cunit_Entity (Main_Unit);\n \n    begin\n-      --  A new compilation unit node is built for the instance declaration\n+      --  A new compilation unit node is built for the instance declaration.\n+      --  It relocates the auxiliary declaration node from the compilation unit\n+      --  where the instance appeared, so that declarations that originally\n+      --  followed the instance will be attached to the spec compilation unit.\n \n       Decl_Cunit :=\n         Make_Compilation_Unit (Sloc (N),\n           Context_Items  => Empty_List,\n           Unit           => Act_Decl,\n-          Aux_Decls_Node => Make_Compilation_Unit_Aux (Sloc (N)));\n+          Aux_Decls_Node => Relocate_Node (Aux_Decls_Node (Parent (N))));\n \n       Set_Parent_Spec (Act_Decl, Parent_Spec (N));\n "}, {"sha": "d0f00b31161a5ff1bde1533dc3d2bde8fe34c631", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -2429,13 +2429,9 @@ package body Sem_Ch5 is\n \n       if not Is_Entity_Name (Iter_Name)\n \n-        --  When the context is a quantified expression, the renaming\n-        --  declaration is delayed until the expansion phase if we are\n-        --  doing expansion.\n+        --  Do not perform this expansion in preanalysis\n \n-        and then (Nkind (Parent (N)) /= N_Quantified_Expression\n-                   or else (Operating_Mode = Check_Semantics\n-                            and then not GNATprove_Mode))\n+        and then Full_Analysis\n \n         --  Do not perform this expansion when expansion is disabled, where the\n         --  temporary may hide the transformation of a selected component into"}, {"sha": "9ae082ca2e19c3194172ceffdc35aa2a2519e91b", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -531,7 +531,7 @@ package body Sem_Util is\n \n       --  Local variables\n \n-      E   : Entity_Id := Original_Node (Expr);\n+      E   : Node_Id := Original_Node (Expr);\n       Pre : Node_Id;\n \n    --  Start of processing for Accessibility_Level\n@@ -777,8 +777,18 @@ package body Sem_Util is\n \n          --  We don't handle function calls in prefix notation correctly ???\n \n-         when N_Indexed_Component | N_Selected_Component =>\n-            Pre := Original_Node (Prefix (E));\n+         when N_Indexed_Component | N_Selected_Component | N_Slice =>\n+            Pre := Prefix (E);\n+\n+            --  Fetch the original node when the prefix comes from the result\n+            --  of expanding a function call since we want to find the level\n+            --  of the original source call.\n+\n+            if not Comes_From_Source (Pre)\n+              and then Nkind (Original_Node (Pre)) = N_Function_Call\n+            then\n+               Pre := Original_Node (Pre);\n+            end if;\n \n             --  When E is an indexed component or selected component and\n             --  the current Expr is a function call, we know that we are\n@@ -26549,6 +26559,14 @@ package body Sem_Util is\n          Item_Nam :=\n            Chars (Original_Node (Pragma_Identifier (Original_Node (Item))));\n \n+         if Item_Nam = Name_Check then\n+            --  Pragma \"Check\" preserves the original pragma name as its first\n+            --  argument.\n+            Item_Nam :=\n+              Chars (Expression (First (Pragma_Argument_Associations\n+                (Original_Node (Item)))));\n+         end if;\n+\n       else\n          pragma Assert (Nkind (Item) = N_Aspect_Specification);\n          Item_Nam := Chars (Identifier (Item));"}, {"sha": "6681e545a3599f056c021ffe7b4a4e1d328ba516", "filename": "gcc/ada/sem_warn.ads", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fsem_warn.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fsem_warn.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.ads?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -257,12 +257,9 @@ package Sem_Warn is\n    ----------------------\n \n    function Has_Junk_Name (E : Entity_Id) return Boolean;\n-   --  Return True if the entity name contains any of the following substrings:\n-   --    discard\n-   --    dummy\n-   --    ignore\n-   --    junk\n-   --    unused\n+   --  Return True if the entity name contains substrings like \"junk\" or\n+   --  \"dummy\" (see the body for the complete list).\n+   --\n    --  Used to suppress warnings on names matching these patterns. The contents\n    --  of Name_Buffer and Name_Len are destroyed by this call.\n "}, {"sha": "7bdfcbc047c623ee13c20385cc8494254b35ecaa", "filename": "gcc/ada/sysdep.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fsysdep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fada%2Fsysdep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsysdep.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -323,11 +323,7 @@ __gnat_ttyname (int filedes ATTRIBUTE_UNUSED)\n   || defined (__QNX__)\n \n # ifdef __MINGW32__\n-#  if OLD_MINGW\n-#   include <termios.h>\n-#  else\n-#   include <conio.h>  /* for getch(), kbhit() */\n-#  endif\n+#  include <conio.h>  /* for getch(), kbhit() */\n # else\n #  include <termios.h>\n # endif"}, {"sha": "109b3879220501b06e86d292a970d120dbbeee28", "filename": "gcc/builtins.def", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -114,9 +114,8 @@ along with GCC; see the file COPYING3.  If not see\n    with an argument such as FLOAT32 to produce the enum value for the type.  If\n    we are compiling for the C language with GNU extensions, we enable the name\n    without the __builtin_ prefix as well as the name with the __builtin_\n-   prefix.  C++ does not enable these names by default because they don't have\n-   the _Float<N> and _Float<N>X keywords, and a class based library should use\n-   the __builtin_ names.  */\n+   prefix.  C++ does not enable these names by default because a class based\n+   library should use the __builtin_ names.  */\n #undef DEF_FLOATN_BUILTIN\n #define DEF_FLOATN_BUILTIN(ENUM, NAME, TYPE, ATTRS)\t\\\n   DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,\t\\"}, {"sha": "4e99c4307ea0ae8eba87dd0dfe441f821f42133f", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,3 +1,9 @@\n+2022-09-26  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/106656\n+\t* c-cppbuiltin.cc (c_cpp_builtins): Update value of __cpp_char8_t\n+\tfor C++20.\n+\n 2022-09-23  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/106784"}, {"sha": "cda6910e8c586bb3714e701e5726b84f045883c5", "filename": "gcc/c-family/c-common.cc", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fc-family%2Fc-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fc-family%2Fc-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -352,13 +352,13 @@ const struct c_common_resword c_common_reswords[] =\n   { \"_Bool\",\t\tRID_BOOL,      D_CONLY },\n   { \"_Complex\",\t\tRID_COMPLEX,\t0 },\n   { \"_Imaginary\",\tRID_IMAGINARY, D_CONLY },\n-  { \"_Float16\",         RID_FLOAT16,   D_CONLY },\n-  { \"_Float32\",         RID_FLOAT32,   D_CONLY },\n-  { \"_Float64\",         RID_FLOAT64,   D_CONLY },\n-  { \"_Float128\",        RID_FLOAT128,  D_CONLY },\n-  { \"_Float32x\",        RID_FLOAT32X,  D_CONLY },\n-  { \"_Float64x\",        RID_FLOAT64X,  D_CONLY },\n-  { \"_Float128x\",       RID_FLOAT128X, D_CONLY },\n+  { \"_Float16\",         RID_FLOAT16,    0 },\n+  { \"_Float32\",         RID_FLOAT32,    0 },\n+  { \"_Float64\",         RID_FLOAT64,    0 },\n+  { \"_Float128\",        RID_FLOAT128,   0 },\n+  { \"_Float32x\",        RID_FLOAT32X,   0 },\n+  { \"_Float64x\",        RID_FLOAT64X,   0 },\n+  { \"_Float128x\",       RID_FLOAT128X,  0 },\n   { \"_Decimal32\",       RID_DFLOAT32,  D_CONLY },\n   { \"_Decimal64\",       RID_DFLOAT64,  D_CONLY },\n   { \"_Decimal128\",      RID_DFLOAT128, D_CONLY },\n@@ -1431,8 +1431,11 @@ shorten_binary_op (tree result_type, tree op0, tree op1, bool bitwise)\n \t  == TYPE_PRECISION (TREE_TYPE (arg0)))\n       && unsigned0 == unsigned1\n       && (unsigned0 || !uns))\n-    return c_common_signed_or_unsigned_type\n-      (unsigned0, common_type (TREE_TYPE (arg0), TREE_TYPE (arg1)));\n+    {\n+      tree ctype = common_type (TREE_TYPE (arg0), TREE_TYPE (arg1));\n+      if (ctype != error_mark_node)\n+\treturn c_common_signed_or_unsigned_type (unsigned0, ctype);\n+    }\n \n   else if (TREE_CODE (arg0) == INTEGER_CST\n \t   && (unsigned1 || !uns)\n@@ -3204,9 +3207,10 @@ shorten_compare (location_t loc, tree *op0_ptr, tree *op1_ptr,\n \n   else if (unsignedp0 == unsignedp1 && real1 == real2\n \t   && TYPE_PRECISION (TREE_TYPE (primop0)) < TYPE_PRECISION (*restype_ptr)\n-\t   && TYPE_PRECISION (TREE_TYPE (primop1)) < TYPE_PRECISION (*restype_ptr))\n+\t   && TYPE_PRECISION (TREE_TYPE (primop1)) < TYPE_PRECISION (*restype_ptr)\n+\t   && (type = common_type (TREE_TYPE (primop0), TREE_TYPE (primop1)))\n+\t      != error_mark_node)\n     {\n-      type = common_type (TREE_TYPE (primop0), TREE_TYPE (primop1));\n       type = c_common_signed_or_unsigned_type (unsignedp0\n \t\t\t\t\t       || TYPE_UNSIGNED (*restype_ptr),\n \t\t\t\t\t       type);\n@@ -4380,11 +4384,18 @@ c_common_nodes_and_builtins (void)\n   record_builtin_type (RID_DOUBLE, NULL, double_type_node);\n   record_builtin_type (RID_MAX, \"long double\", long_double_type_node);\n \n-  if (!c_dialect_cxx ())\n-    for (i = 0; i < NUM_FLOATN_NX_TYPES; i++)\n+  for (i = 0; i < NUM_FLOATN_NX_TYPES; i++)\n+    {\n       if (FLOATN_NX_TYPE_NODE (i) != NULL_TREE)\n \trecord_builtin_type ((enum rid) (RID_FLOATN_NX_FIRST + i), NULL,\n \t\t\t     FLOATN_NX_TYPE_NODE (i));\n+    }\n+\n+  /* For C, let float128t_type_node (__float128 in some backends) be the\n+     same type as float128_type_node (_Float128), for C++ let those\n+     be distinct types that mangle and behave differently.  */\n+  if (c_dialect_cxx ())\n+    float128t_type_node = NULL_TREE;\n \n   /* Only supported decimal floating point extension if the target\n      actually supports underlying modes. */"}, {"sha": "50a4691cda6577ee808c1878e935301395d74da7", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1286,6 +1286,7 @@ struct c_omp_directive {\n   bool simd;\n };\n \n+extern const struct c_omp_directive c_omp_directives[];\n extern const struct c_omp_directive *c_omp_categorize_directive (const char *,\n \t\t\t\t\t\t\t\t const char *,\n \t\t\t\t\t\t\t\t const char *);"}, {"sha": "ca5f500e079b5c45721504b6b587a98bdbf4fa51", "filename": "gcc/c-family/c-cppbuiltin.cc", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fc-family%2Fc-cppbuiltin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fc-family%2Fc-cppbuiltin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1081,6 +1081,7 @@ c_cpp_builtins (cpp_reader *pfile)\n \t  cpp_define (pfile, \"__cpp_constexpr=202110L\");\n \t  cpp_define (pfile, \"__cpp_multidimensional_subscript=202110L\");\n \t  cpp_define (pfile, \"__cpp_named_character_escapes=202207L\");\n+\t  cpp_define (pfile, \"__cpp_static_call_operator=202207L\");\n \t}\n       if (flag_concepts)\n         {\n@@ -1112,7 +1113,7 @@ c_cpp_builtins (cpp_reader *pfile)\n       if (flag_threadsafe_statics)\n \tcpp_define (pfile, \"__cpp_threadsafe_static_init=200806L\");\n       if (flag_char8_t)\n-        cpp_define (pfile, \"__cpp_char8_t=201811L\");\n+\tcpp_define (pfile, \"__cpp_char8_t=202207L\");\n #ifndef THREAD_MODEL_SPEC\n       /* Targets that define THREAD_MODEL_SPEC need to define\n \t __STDCPP_THREADS__ in their config/XXX/XXX-c.c themselves.  */\n@@ -1246,6 +1247,14 @@ c_cpp_builtins (cpp_reader *pfile)\n     {\n       if (FLOATN_NX_TYPE_NODE (i) == NULL_TREE)\n \tcontinue;\n+      if (c_dialect_cxx ()\n+\t  && cxx_dialect > cxx20\n+\t  && !floatn_nx_types[i].extended)\n+\t{\n+\t  char name[sizeof (\"__STDCPP_FLOAT128_T__=1\")];\n+\t  sprintf (name, \"__STDCPP_FLOAT%d_T__=1\", floatn_nx_types[i].n);\n+\t  cpp_define (pfile, name);\n+\t}\n       char prefix[20], csuffix[20];\n       sprintf (prefix, \"FLT%d%s\", floatn_nx_types[i].n,\n \t       floatn_nx_types[i].extended ? \"X\" : \"\");"}, {"sha": "4d2252fd946bd242892e44c34d5c4c7d54428409", "filename": "gcc/c-family/c-lex.cc", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fc-family%2Fc-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fc-family%2Fc-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-lex.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -960,6 +960,10 @@ interpret_float (const cpp_token *token, unsigned int flags,\n \t  pedwarn (input_location, OPT_Wpedantic, \"non-standard suffix on floating constant\");\n \n \ttype = c_common_type_for_mode (mode, 0);\n+\t/* For Q suffix, prefer float128t_type_node (__float128) type\n+\t   over float128_type_node (_Float128) type if they are distinct.  */\n+\tif (type == float128_type_node && float128t_type_node)\n+\t  type = float128t_type_node;\n \tgcc_assert (type);\n       }\n     else if ((flags & (CPP_N_FLOATN | CPP_N_FLOATNX)) != 0)\n@@ -979,8 +983,17 @@ interpret_float (const cpp_token *token, unsigned int flags,\n \t    error (\"unsupported non-standard suffix on floating constant\");\n \t    return error_mark_node;\n \t  }\n+\telse if (c_dialect_cxx () && !extended)\n+\t  {\n+\t    if (cxx_dialect < cxx23)\n+\t      pedwarn (input_location, OPT_Wpedantic,\n+\t\t       \"%<f%d%> or %<F%d%> suffix on floating constant only \"\n+\t\t       \"available with %<-std=c++2b%> or %<-std=gnu++2b%>\",\n+\t\t       n, n);\n+\t  }\n \telse\n-\t  pedwarn (input_location, OPT_Wpedantic, \"non-standard suffix on floating constant\");\n+\t  pedwarn (input_location, OPT_Wpedantic,\n+\t\t   \"non-standard suffix on floating constant\");\n       }\n     else if ((flags & CPP_N_WIDTH) == CPP_N_LARGE)\n       type = long_double_type_node;\n@@ -990,7 +1003,10 @@ interpret_float (const cpp_token *token, unsigned int flags,\n     else\n       type = double_type_node;\n \n-  const_type = excess_precision_type (type);\n+  if (c_dialect_cxx ())\n+    const_type = NULL_TREE;\n+  else\n+    const_type = excess_precision_type (type);\n   if (!const_type)\n     const_type = type;\n "}, {"sha": "7a97c40935a268adbae369b88ab0df529a9ece5f", "filename": "gcc/c-family/c-omp.cc", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fc-family%2Fc-omp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fc-family%2Fc-omp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -3097,21 +3097,21 @@ c_omp_adjust_map_clauses (tree clauses, bool is_target)\n     }\n }\n \n-static const struct c_omp_directive omp_directives[] = {\n+const struct c_omp_directive c_omp_directives[] = {\n   /* Keep this alphabetically sorted by the first word.  Non-null second/third\n      if any should precede null ones.  */\n   { \"allocate\", nullptr, nullptr, PRAGMA_OMP_ALLOCATE,\n     C_OMP_DIR_DECLARATIVE, false },\n-  /* { \"assume\", nullptr, nullptr, PRAGMA_OMP_ASSUME,\n-    C_OMP_DIR_INFORMATIONAL, false }, */\n-  /* { \"assumes\", nullptr, nullptr, PRAGMA_OMP_ASSUMES,\n-    C_OMP_DIR_INFORMATIONAL, false }, */\n+  { \"assume\", nullptr, nullptr, PRAGMA_OMP_ASSUME,\n+    C_OMP_DIR_INFORMATIONAL, false },\n+  { \"assumes\", nullptr, nullptr, PRAGMA_OMP_ASSUMES,\n+    C_OMP_DIR_INFORMATIONAL, false },\n   { \"atomic\", nullptr, nullptr, PRAGMA_OMP_ATOMIC,\n     C_OMP_DIR_CONSTRUCT, false },\n   { \"barrier\", nullptr, nullptr, PRAGMA_OMP_BARRIER,\n     C_OMP_DIR_STANDALONE, false },\n-  /* { \"begin\", \"assumes\", nullptr, PRAGMA_OMP_BEGIN,\n-    C_OMP_DIR_INFORMATIONAL, false }, */\n+  { \"begin\", \"assumes\", nullptr, PRAGMA_OMP_BEGIN,\n+    C_OMP_DIR_INFORMATIONAL, false },\n   /* { \"begin\", \"declare\", \"target\", PRAGMA_OMP_BEGIN,\n     C_OMP_DIR_DECLARATIVE, false }, */\n   /* { \"begin\", \"declare\", \"variant\", PRAGMA_OMP_BEGIN,\n@@ -3140,9 +3140,9 @@ static const struct c_omp_directive omp_directives[] = {\n     C_OMP_DIR_CONSTRUCT, false },  */\n   { \"distribute\", nullptr, nullptr, PRAGMA_OMP_DISTRIBUTE,\n     C_OMP_DIR_CONSTRUCT, true },\n-  /* { \"end\", \"assumes\", nullptr, PRAGMA_OMP_END,\n-    C_OMP_DIR_INFORMATIONAL, false }, */\n-  { \"end\", \"declare\", \"target\", PRAGMA_OMP_END_DECLARE_TARGET,\n+  { \"end\", \"assumes\", nullptr, PRAGMA_OMP_END,\n+    C_OMP_DIR_INFORMATIONAL, false },\n+  { \"end\", \"declare\", \"target\", PRAGMA_OMP_END,\n     C_OMP_DIR_DECLARATIVE, false },\n   /* { \"end\", \"declare\", \"variant\", PRAGMA_OMP_END,\n     C_OMP_DIR_DECLARATIVE, false }, */\n@@ -3224,26 +3224,26 @@ const struct c_omp_directive *\n c_omp_categorize_directive (const char *first, const char *second,\n \t\t\t    const char *third)\n {\n-  const size_t n_omp_directives = ARRAY_SIZE (omp_directives);\n+  const size_t n_omp_directives = ARRAY_SIZE (c_omp_directives);\n   for (size_t i = 0; i < n_omp_directives; i++)\n     {\n-      if ((unsigned char) omp_directives[i].first[0]\n+      if ((unsigned char) c_omp_directives[i].first[0]\n \t  < (unsigned char) first[0])\n \tcontinue;\n-      if ((unsigned char) omp_directives[i].first[0]\n+      if ((unsigned char) c_omp_directives[i].first[0]\n \t  > (unsigned char) first[0])\n \tbreak;\n-      if (strcmp (omp_directives[i].first, first))\n+      if (strcmp (c_omp_directives[i].first, first))\n \tcontinue;\n-      if (!omp_directives[i].second)\n-\treturn &omp_directives[i];\n-      if (!second || strcmp (omp_directives[i].second, second))\n+      if (!c_omp_directives[i].second)\n+\treturn &c_omp_directives[i];\n+      if (!second || strcmp (c_omp_directives[i].second, second))\n \tcontinue;\n-      if (!omp_directives[i].third)\n-\treturn &omp_directives[i];\n-      if (!third || strcmp (omp_directives[i].third, third))\n+      if (!c_omp_directives[i].third)\n+\treturn &c_omp_directives[i];\n+      if (!third || strcmp (c_omp_directives[i].third, third))\n \tcontinue;\n-      return &omp_directives[i];\n+      return &c_omp_directives[i];\n     }\n   return NULL;\n }"}, {"sha": "b5a4b3c970f21ebcc001b617db26df8866592505", "filename": "gcc/c-family/c-pragma.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fc-family%2Fc-pragma.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fc-family%2Fc-pragma.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1546,14 +1546,16 @@ static const struct omp_pragma_def oacc_pragmas[] = {\n };\n static const struct omp_pragma_def omp_pragmas[] = {\n   { \"allocate\", PRAGMA_OMP_ALLOCATE },\n+  { \"assumes\", PRAGMA_OMP_ASSUMES },\n   { \"atomic\", PRAGMA_OMP_ATOMIC },\n   { \"barrier\", PRAGMA_OMP_BARRIER },\n+  { \"begin\", PRAGMA_OMP_BEGIN },\n   { \"cancel\", PRAGMA_OMP_CANCEL },\n   { \"cancellation\", PRAGMA_OMP_CANCELLATION_POINT },\n   { \"critical\", PRAGMA_OMP_CRITICAL },\n   { \"depobj\", PRAGMA_OMP_DEPOBJ },\n   { \"error\", PRAGMA_OMP_ERROR },\n-  { \"end\", PRAGMA_OMP_END_DECLARE_TARGET },\n+  { \"end\", PRAGMA_OMP_END },\n   { \"flush\", PRAGMA_OMP_FLUSH },\n   { \"nothing\", PRAGMA_OMP_NOTHING },\n   { \"requires\", PRAGMA_OMP_REQUIRES },\n@@ -1568,6 +1570,7 @@ static const struct omp_pragma_def omp_pragmas[] = {\n   { \"threadprivate\", PRAGMA_OMP_THREADPRIVATE }\n };\n static const struct omp_pragma_def omp_pragmas_simd[] = {\n+  { \"assume\", PRAGMA_OMP_ASSUME },\n   { \"declare\", PRAGMA_OMP_DECLARE },\n   { \"distribute\", PRAGMA_OMP_DISTRIBUTE },\n   { \"for\", PRAGMA_OMP_FOR },"}, {"sha": "10a4053d8fee73175135c4899ab86afc5a5197bd", "filename": "gcc/c-family/c-pragma.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fc-family%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fc-family%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.h?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -45,16 +45,19 @@ enum pragma_kind {\n   /* PRAGMA_OMP__START_ should be equal to the first PRAGMA_OMP_* code.  */\n   PRAGMA_OMP_ALLOCATE,\n   PRAGMA_OMP__START_ = PRAGMA_OMP_ALLOCATE,\n+  PRAGMA_OMP_ASSUME,\n+  PRAGMA_OMP_ASSUMES,\n   PRAGMA_OMP_ATOMIC,\n   PRAGMA_OMP_BARRIER,\n+  PRAGMA_OMP_BEGIN,\n   PRAGMA_OMP_CANCEL,\n   PRAGMA_OMP_CANCELLATION_POINT,\n   PRAGMA_OMP_CRITICAL,\n   PRAGMA_OMP_DECLARE,\n   PRAGMA_OMP_DEPOBJ,\n   PRAGMA_OMP_DISTRIBUTE,\n   PRAGMA_OMP_ERROR,\n-  PRAGMA_OMP_END_DECLARE_TARGET,\n+  PRAGMA_OMP_END,\n   PRAGMA_OMP_FLUSH,\n   PRAGMA_OMP_FOR,\n   PRAGMA_OMP_LOOP,"}, {"sha": "4b852b811b8b06e71bbd87653622ddcfb3890fe9", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,3 +1,10 @@\n+2022-09-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/106981\n+\t* c-typeck.cc (c_tree_equal): Only strip NON_LVALUE_EXPRs at the\n+\tstart.  For CONSTANT_CLASS_P or CASE_CONVERT: return false if t1 and\n+\tt2 have different types.\n+\n 2022-09-22  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR c/106830"}, {"sha": "740982eae311ba2ba87374e297b601eab9da87ca", "filename": "gcc/c/c-decl.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fc%2Fc-decl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fc%2Fc-decl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -156,6 +156,10 @@ static bool undef_nested_function;\n /* If non-zero, implicit \"omp declare target\" attribute is added into the\n    attribute lists.  */\n int current_omp_declare_target_attribute;\n+\n+/* If non-zero, we are inside of\n+   #pragma omp begin assumes ... #pragma omp end assumes region.  */\n+int current_omp_begin_assumes;\n \f\n /* Each c_binding structure describes one binding of an identifier to\n    a decl.  All the decls in a scope - irrespective of namespace - are"}, {"sha": "861abe8377a6ce0702b9086e0837a1ab73852690", "filename": "gcc/c/c-lang.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fc%2Fc-lang.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fc%2Fc-lang.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-lang.h?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -63,5 +63,8 @@ struct GTY(()) language_function {\n /* If non-zero, implicit \"omp declare target\" attribute is added into the\n    attribute lists.  */\n extern GTY(()) int current_omp_declare_target_attribute;\n+/* Similarly whether we are in between #pragma omp begin assumes and\n+   #pragma omp end assumes (and how many times when nested).  */\n+extern GTY(()) int current_omp_begin_assumes;\n \n #endif /* ! GCC_C_LANG_H */"}, {"sha": "f2498dc1c37fc584e26742a2d97391301d49a739", "filename": "gcc/c/c-parser.cc", "status": "modified", "additions": 291, "deletions": 17, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fc%2Fc-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fc%2Fc-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -71,6 +71,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pretty-print.h\"\n #include \"memmodel.h\"\n #include \"c-family/known-headers.h\"\n+#include \"bitmap.h\"\n \n /* We need to walk over decls with incomplete struct/union/enum types\n    after parsing the whole translation unit.\n@@ -1594,10 +1595,13 @@ enum pragma_context { pragma_external, pragma_struct, pragma_param,\n static bool c_parser_pragma (c_parser *, enum pragma_context, bool *);\n static bool c_parser_omp_cancellation_point (c_parser *, enum pragma_context);\n static bool c_parser_omp_target (c_parser *, enum pragma_context, bool *);\n-static void c_parser_omp_end_declare_target (c_parser *);\n+static void c_parser_omp_begin (c_parser *);\n+static void c_parser_omp_end (c_parser *);\n static bool c_parser_omp_declare (c_parser *, enum pragma_context);\n static void c_parser_omp_requires (c_parser *);\n static bool c_parser_omp_error (c_parser *, enum pragma_context);\n+static void c_parser_omp_assumption_clauses (c_parser *, bool);\n+static void c_parser_omp_assumes (c_parser *);\n static bool c_parser_omp_ordered (c_parser *, enum pragma_context, bool *);\n static void c_parser_oacc_routine (c_parser *, enum pragma_context);\n \n@@ -1678,6 +1682,13 @@ c_parser_translation_unit (c_parser *parser)\n \t       \"%<#pragma omp end declare target%>\");\n       current_omp_declare_target_attribute = 0;\n     }\n+  if (current_omp_begin_assumes)\n+    {\n+      if (!errorcount)\n+\terror (\"%<#pragma omp begin assumes%> without corresponding \"\n+\t       \"%<#pragma omp end assumes%>\");\n+      current_omp_begin_assumes = 0;\n+    }\n }\n \n /* Parse an external declaration (C90 6.7, C99 6.9, C11 6.9).\n@@ -12594,8 +12605,12 @@ c_parser_pragma (c_parser *parser, enum pragma_context context, bool *if_p)\n     case PRAGMA_OMP_TARGET:\n       return c_parser_omp_target (parser, context, if_p);\n \n-    case PRAGMA_OMP_END_DECLARE_TARGET:\n-      c_parser_omp_end_declare_target (parser);\n+    case PRAGMA_OMP_BEGIN:\n+      c_parser_omp_begin (parser);\n+      return false;\n+\n+    case PRAGMA_OMP_END:\n+      c_parser_omp_end (parser);\n       return false;\n \n     case PRAGMA_OMP_SCAN:\n@@ -12619,13 +12634,26 @@ c_parser_pragma (c_parser *parser, enum pragma_context context, bool *if_p)\n       if (context != pragma_external)\n \t{\n \t  error_at (c_parser_peek_token (parser)->location,\n-\t\t    \"%<#pragma omp requires%> may only be used at file scope\");\n+\t\t    \"%<#pragma %s%> may only be used at file scope\",\n+\t\t    \"omp requires\");\n \t  c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);\n \t  return false;\n \t}\n       c_parser_omp_requires (parser);\n       return false;\n \n+    case PRAGMA_OMP_ASSUMES:\n+      if (context != pragma_external)\n+\t{\n+\t  error_at (c_parser_peek_token (parser)->location,\n+\t\t    \"%<#pragma %s%> may only be used at file scope\",\n+\t\t    \"omp assumes\");\n+\t  c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);\n+\t  return false;\n+\t}\n+      c_parser_omp_assumes (parser);\n+      return false;\n+\n     case PRAGMA_OMP_NOTHING:\n       c_parser_omp_nothing (parser);\n       return false;\n@@ -22405,14 +22433,44 @@ c_parser_omp_declare_target (c_parser *parser)\n \t\t\"directive with only %<device_type%> clauses ignored\");\n }\n \n+/* OpenMP 5.1\n+   #pragma omp begin assumes clauses[optseq] new-line  */\n+\n+static void\n+c_parser_omp_begin (c_parser *parser)\n+{\n+  const char *p = \"\";\n+  c_parser_consume_pragma (parser);\n+  if (c_parser_next_token_is (parser, CPP_NAME))\n+    p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+  if (strcmp (p, \"assumes\") == 0)\n+    {\n+      c_parser_consume_token (parser);\n+      c_parser_omp_assumption_clauses (parser, false);\n+      current_omp_begin_assumes++;\n+    }\n+  else\n+    {\n+      c_parser_error (parser, \"expected %<assumes%>\");\n+      c_parser_skip_to_pragma_eol (parser);\n+    }\n+}\n+\n+/* OpenMP 4.0\n+   #pragma omp end declare target\n+\n+   OpenMP 5.1\n+   #pragma omp end assumes  */\n+\n static void\n-c_parser_omp_end_declare_target (c_parser *parser)\n+c_parser_omp_end (c_parser *parser)\n {\n   location_t loc = c_parser_peek_token (parser)->location;\n+  const char *p = \"\";\n   c_parser_consume_pragma (parser);\n-  if (c_parser_next_token_is (parser, CPP_NAME)\n-      && strcmp (IDENTIFIER_POINTER (c_parser_peek_token (parser)->value),\n-\t\t \"declare\") == 0)\n+  if (c_parser_next_token_is (parser, CPP_NAME))\n+    p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+  if (strcmp (p, \"declare\") == 0)\n     {\n       c_parser_consume_token (parser);\n       if (c_parser_next_token_is (parser, CPP_NAME)\n@@ -22425,22 +22483,30 @@ c_parser_omp_end_declare_target (c_parser *parser)\n \t  c_parser_skip_to_pragma_eol (parser);\n \t  return;\n \t}\n+      c_parser_skip_to_pragma_eol (parser);\n+      if (!current_omp_declare_target_attribute)\n+\terror_at (loc, \"%<#pragma omp end declare target%> without \"\n+\t\t       \"corresponding %<#pragma omp declare target%>\");\n+      else\n+\tcurrent_omp_declare_target_attribute--;\n     }\n-  else\n+  else if (strcmp (p, \"assumes\") == 0)\n     {\n-      c_parser_error (parser, \"expected %<declare%>\");\n+      c_parser_consume_token (parser);\n       c_parser_skip_to_pragma_eol (parser);\n-      return;\n+      if (!current_omp_begin_assumes)\n+\terror_at (loc, \"%<#pragma omp end assumes%> without \"\n+\t\t       \"corresponding %<#pragma omp begin assumes%>\");\n+      else\n+\tcurrent_omp_begin_assumes--;\n     }\n-  c_parser_skip_to_pragma_eol (parser);\n-  if (!current_omp_declare_target_attribute)\n-    error_at (loc, \"%<#pragma omp end declare target%> without corresponding \"\n-\t\t   \"%<#pragma omp declare target%>\");\n   else\n-    current_omp_declare_target_attribute--;\n+    {\n+      c_parser_error (parser, \"expected %<declare%> or %<assumes%>\");\n+      c_parser_skip_to_pragma_eol (parser);\n+    }\n }\n \n-\n /* OpenMP 4.0\n    #pragma omp declare reduction (reduction-id : typename-list : expression) \\\n       initializer-clause[opt] new-line\n@@ -23299,6 +23365,211 @@ c_parser_omp_error (c_parser *parser, enum pragma_context context)\n   return false;\n }\n \n+/* Assumption clauses:\n+   OpenMP 5.1\n+   absent (directive-name-list)\n+   contains (directive-name-list)\n+   holds (expression)\n+   no_openmp\n+   no_openmp_routines\n+   no_parallelism  */\n+\n+static void\n+c_parser_omp_assumption_clauses (c_parser *parser, bool is_assume)\n+{\n+  bool first = true;\n+  bool no_openmp = false;\n+  bool no_openmp_routines = false;\n+  bool no_parallelism = false;\n+  bitmap_head absent_head, contains_head;\n+\n+  bitmap_obstack_initialize (NULL);\n+  bitmap_initialize (&absent_head, &bitmap_default_obstack);\n+  bitmap_initialize (&contains_head, &bitmap_default_obstack);\n+\n+  if (c_parser_next_token_is (parser, CPP_PRAGMA_EOL))\n+    error_at (c_parser_peek_token (parser)->location,\n+\t      \"expected at least one assumption clause\");\n+\n+  while (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))\n+    {\n+      if (!first\n+\t  && c_parser_next_token_is (parser, CPP_COMMA)\n+\t  && c_parser_peek_2nd_token (parser)->type == CPP_NAME)\n+\tc_parser_consume_token (parser);\n+\n+      first = false;\n+\n+      if (!c_parser_next_token_is (parser, CPP_NAME))\n+\tbreak;\n+\n+      const char *p\n+\t= IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+      location_t cloc = c_parser_peek_token (parser)->location;\n+\n+      if (!strcmp (p, \"no_openmp\"))\n+\t{\n+\t  c_parser_consume_token (parser);\n+\t  if (no_openmp)\n+\t    error_at (cloc, \"too many %qs clauses\", \"no_openmp\");\n+\t  no_openmp = true;\n+\t}\n+      else if (!strcmp (p, \"no_openmp_routines\"))\n+\t{\n+\t  c_parser_consume_token (parser);\n+\t  if (no_openmp_routines)\n+\t    error_at (cloc, \"too many %qs clauses\", \"no_openmp_routines\");\n+\t  no_openmp_routines = true;\n+\t}\n+      else if (!strcmp (p, \"no_parallelism\"))\n+\t{\n+\t  c_parser_consume_token (parser);\n+\t  if (no_parallelism)\n+\t    error_at (cloc, \"too many %qs clauses\", \"no_parallelism\");\n+\t  no_parallelism = true;\n+\t}\n+      else if (!strcmp (p, \"holds\"))\n+\t{\n+\t  c_parser_consume_token (parser);\n+\t  matching_parens parens;\n+\t  if (parens.require_open (parser))\n+\t    {\n+\t      location_t eloc = c_parser_peek_token (parser)->location;\n+\t      c_expr expr = c_parser_expr_no_commas (parser, NULL);\n+\t      tree t = convert_lvalue_to_rvalue (eloc, expr, true, true).value;\n+\t      t = c_objc_common_truthvalue_conversion (eloc, t);\n+\t      t = c_fully_fold (t, false, NULL);\n+\t      if (is_assume)\n+\t\t{\n+\t\t  /* FIXME: Emit .ASSUME (t) call here.  */\n+\t\t  (void) t;\n+\t\t}\n+\t      parens.skip_until_found_close (parser);\n+\t    }\n+\t}\n+      else if (!strcmp (p, \"absent\") || !strcmp (p, \"contains\"))\n+\t{\n+\t  c_parser_consume_token (parser);\n+\t  matching_parens parens;\n+\t  if (parens.require_open (parser))\n+\t    {\n+\t      do\n+\t\t{\n+\t\t  const char *directive[3] = {};\n+\t\t  int i;\n+\t\t  location_t dloc = c_parser_peek_token (parser)->location;\n+\t\t  for (i = 0; i < 3; i++)\n+\t\t    {\n+\t\t      tree id;\n+\t\t      if (c_parser_peek_nth_token (parser, i + 1)->type\n+\t\t\t  == CPP_NAME)\n+\t\t\tid = c_parser_peek_nth_token (parser, i + 1)->value;\n+\t\t      else if (c_parser_peek_nth_token (parser, i + 1)->keyword\n+\t\t\t       != RID_MAX)\n+\t\t\t{\n+\t\t\t  enum rid rid\n+\t\t\t    = c_parser_peek_nth_token (parser, i + 1)->keyword;\n+\t\t\t  id = ridpointers[rid];\n+\t\t\t}\n+\t\t      else\n+\t\t\tbreak;\n+\t\t      directive[i] = IDENTIFIER_POINTER (id);\n+\t\t    }\n+\t\t  if (i == 0)\n+\t\t    error_at (dloc, \"expected directive name\");\n+\t\t  else\n+\t\t    {\n+\t\t      const struct c_omp_directive *dir\n+\t\t\t= c_omp_categorize_directive (directive[0],\n+\t\t\t\t\t\t      directive[1],\n+\t\t\t\t\t\t      directive[2]);\n+\t\t      if (dir == NULL\n+\t\t\t  || dir->kind == C_OMP_DIR_DECLARATIVE\n+\t\t\t  || dir->kind == C_OMP_DIR_INFORMATIONAL\n+\t\t\t  || dir->id == PRAGMA_OMP_END\n+\t\t\t  || (!dir->second && directive[1])\n+\t\t\t  || (!dir->third && directive[2]))\n+\t\t\terror_at (dloc, \"unknown OpenMP directive name in \"\n+\t\t\t\t\t\"%qs clause argument\", p);\n+\t\t      else\n+\t\t\t{\n+\t\t\t  int id = dir - c_omp_directives;\n+\t\t\t  if (bitmap_bit_p (p[0] == 'a' ? &contains_head\n+\t\t\t\t\t\t\t: &absent_head, id))\n+\t\t\t    error_at (dloc, \"%<%s%s%s%s%s%> directive \"\n+\t\t\t\t\t    \"mentioned in both %<absent%> and \"\n+\t\t\t\t\t    \"%<contains%> clauses\",\n+\t\t\t\t      directive[0],\n+\t\t\t\t      directive[1] ? \" \" : \"\",\n+\t\t\t\t      directive[1] ? directive[1] : \"\",\n+\t\t\t\t      directive[2] ? \" \" : \"\",\n+\t\t\t\t      directive[2] ? directive[2] : \"\");\n+\t\t\t  else if (!bitmap_set_bit (p[0] == 'a'\n+\t\t\t\t\t\t    ? &absent_head\n+\t\t\t\t\t\t    : &contains_head, id))\n+\t\t\t    error_at (dloc, \"%<%s%s%s%s%s%> directive \"\n+\t\t\t\t\t    \"mentioned multiple times in %qs \"\n+\t\t\t\t\t    \"clauses\",\n+\t\t\t\t      directive[0],\n+\t\t\t\t      directive[1] ? \" \" : \"\",\n+\t\t\t\t      directive[1] ? directive[1] : \"\",\n+\t\t\t\t      directive[2] ? \" \" : \"\",\n+\t\t\t\t      directive[2] ? directive[2] : \"\", p);\n+\t\t\t}\n+\t\t      for (; i; --i)\n+\t\t\tc_parser_consume_token (parser);\n+\t\t    }\n+\t\t  if (c_parser_next_token_is (parser, CPP_COMMA))\n+\t\t    c_parser_consume_token (parser);\n+\t\t  else\n+\t\t    break;\n+\t\t}\n+\t      while (1);\n+\t      parens.skip_until_found_close (parser);\n+\t    }\n+\t}\n+      else if (startswith (p, \"ext_\"))\n+\t{\n+\t  warning_at (cloc, 0, \"unknown assumption clause %qs\", p);\n+\t  c_parser_consume_token (parser);\n+\t  if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n+\t    {\n+\t      matching_parens parens;\n+\t      parens.consume_open (parser);\n+\t      c_parser_balanced_token_sequence (parser);\n+\t      parens.require_close (parser);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  c_parser_consume_token (parser);\n+\t  error_at (cloc, \"expected assumption clause\");\n+\t  break;\n+\t}\n+    }\n+  c_parser_skip_to_pragma_eol (parser);\n+}\n+\n+/* OpenMP 5.1\n+   #pragma omp assume clauses[optseq] new-line  */\n+\n+static void\n+c_parser_omp_assume (c_parser *parser, bool *if_p)\n+{\n+  c_parser_omp_assumption_clauses (parser, true);\n+  add_stmt (c_parser_omp_structured_block (parser, if_p));\n+}\n+\n+/* OpenMP 5.1\n+   #pragma omp assumes clauses[optseq] new-line  */\n+\n+static void\n+c_parser_omp_assumes (c_parser *parser)\n+{\n+  c_parser_consume_pragma (parser);\n+  c_parser_omp_assumption_clauses (parser, false);\n+}\n+\n /* Main entry point to parsing most OpenMP pragmas.  */\n \n static void\n@@ -23404,6 +23675,9 @@ c_parser_omp_construct (c_parser *parser, bool *if_p)\n       strcpy (p_name, \"#pragma omp\");\n       stmt = c_parser_omp_teams (loc, parser, p_name, mask, NULL, if_p);\n       break;\n+    case PRAGMA_OMP_ASSUME:\n+      c_parser_omp_assume (parser, if_p);\n+      return;\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "a363e0b4da3cc1bda23efd3d3ddd5f47da0e050d", "filename": "gcc/cfgcleanup.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcfgcleanup.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcfgcleanup.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -2599,7 +2599,7 @@ trivially_empty_bb_p (basic_block bb)\n    return value.  Fill in *RET and *USE with the return and use insns\n    if any found, otherwise NULL.  All CLOBBERs are ignored.  */\n \n-static bool\n+bool\n bb_is_just_return (basic_block bb, rtx_insn **ret, rtx_insn **use)\n {\n   *ret = *use = NULL;"}, {"sha": "f1021ca835fff8e023b79ae9f1a18d7ac5de8922", "filename": "gcc/cfgcleanup.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcfgcleanup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcfgcleanup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.h?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -30,5 +30,6 @@ extern int flow_find_head_matching_sequence (basic_block, basic_block,\n extern bool delete_unreachable_blocks (void);\n extern void delete_dead_jumptables (void);\n extern bool cleanup_cfg (int);\n+extern bool bb_is_just_return (basic_block, rtx_insn **, rtx_insn **);\n \n #endif /* GCC_CFGCLEANUP_H */"}, {"sha": "281a432f6a6c151673c5532941184c41e8100a64", "filename": "gcc/cfgrtl.cc", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcfgrtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcfgrtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -3901,6 +3901,7 @@ fixup_reorder_chain (void)\n   /* Now add jumps and labels as needed to match the blocks new\n      outgoing edges.  */\n \n+  bool remove_unreachable_blocks = false;\n   for (bb = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb; bb ; bb = (basic_block)\n        bb->aux)\n     {\n@@ -4043,10 +4044,31 @@ fixup_reorder_chain (void)\n \t    continue;\n \t}\n \n+      /* If E_FALL->dest is just a return block, then we can emit a\n+\t return rather than a jump to the return block.  */\n+      rtx_insn *ret, *use;\n+      basic_block dest;\n+      if (bb_is_just_return (e_fall->dest, &ret, &use)\n+\t  && ((PATTERN (ret) == simple_return_rtx && targetm.have_simple_return ())\n+\t      || (PATTERN (ret) == ret_rtx && targetm.have_return ())))\n+\t{\n+\t  ret_label = PATTERN (ret);\n+\t  dest = EXIT_BLOCK_PTR_FOR_FN (cfun);\n+\n+\t  /* E_FALL->dest might become unreachable as a result of\n+\t     replacing the jump with a return.  So arrange to remove\n+\t     unreachable blocks.  */\n+\t  remove_unreachable_blocks = true;\n+\t}\n+      else\n+\t{\n+\t  dest = e_fall->dest;\n+\t}\n+\n       /* We got here if we need to add a new jump insn. \n \t Note force_nonfallthru can delete E_FALL and thus we have to\n \t save E_FALL->src prior to the call to force_nonfallthru.  */\n-      nb = force_nonfallthru_and_redirect (e_fall, e_fall->dest, ret_label);\n+      nb = force_nonfallthru_and_redirect (e_fall, dest, ret_label);\n       if (nb)\n \t{\n \t  nb->aux = bb->aux;\n@@ -4134,6 +4156,12 @@ fixup_reorder_chain (void)\n \t\t  ei_next (&ei2);\n \t    }\n       }\n+\n+  /* Replacing a jump with a return may have exposed an unreachable\n+     block.  Conditionally remove them if such transformations were\n+     made.  */\n+  if (remove_unreachable_blocks)\n+    delete_unreachable_blocks ();\n }\n \f\n /* Perform sanity checks on the insn chain."}, {"sha": "c1b1215e98b474bfee97559b813efcfe800c796c", "filename": "gcc/config.gcc", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -3941,6 +3941,9 @@ if test x$with_arch = x ; then\n     mips*-*-vxworks)\n       with_arch=mips2\n       ;;\n+    nvptx-*)\n+      with_arch=sm_30\n+      ;;\n   esac\n \n   # Avoid overriding --with-arch-32 and --with-arch-64 values.\n@@ -5293,6 +5296,25 @@ case \"${target}\" in\n \t\t\tesac\n \t\t;;\n \n+\tnvptx-*)\n+\t\tsupported_defaults=arch\n+\t\tTM_MULTILIB_CONFIG=$with_arch\n+\t\t#TODO 'sm_[...]' list per 'nvptx-sm.def'.\n+\t\tcase $with_arch in\n+\t\t\tsm_30 )\n+\t\t\t\t# OK; default.\n+\t\t\t\t;;\n+\t\t\tsm_35 | sm_53 | sm_70 | sm_75 | sm_80 )\n+\t\t\t\t# OK, but we'd like 'sm_30', too.\n+\t\t\t\tTM_MULTILIB_CONFIG=\"$TM_MULTILIB_CONFIG sm_30\"\n+\t\t\t\t;;\n+\t\t\t* )\n+\t\t\t\techo \"Unknown arch used in --with-arch=$with_arch\" 1>&2\n+\t\t\t\texit 1\n+\t\t\t\t;;\n+\t\tesac\n+\t\t;;\n+\n \tpowerpc*-*-* | rs6000-*-*)\n \t\tsupported_defaults=\"abi cpu cpu_32 cpu_64 float tune tune_32 tune_64 advance_toolchain\"\n "}, {"sha": "6150448dc30efe6ec0a6ed24c81b7907da56aeeb", "filename": "gcc/config/aarch64/aarch64-arches.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Faarch64%2Faarch64-arches.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Faarch64%2Faarch64-arches.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-arches.def?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -41,5 +41,8 @@ AARCH64_ARCH(\"armv8.7-a\",     generic,       8_7A,      8,  AARCH64_FL_FOR_ARCH8\n AARCH64_ARCH(\"armv8.8-a\",     generic,       8_8A,      8,  AARCH64_FL_FOR_ARCH8_8)\n AARCH64_ARCH(\"armv8-r\",       generic,\t     8R  ,\t8,  AARCH64_FL_FOR_ARCH8_R)\n AARCH64_ARCH(\"armv9-a\",       generic,\t     9A  ,\t9,  AARCH64_FL_FOR_ARCH9)\n+AARCH64_ARCH(\"armv9.1-a\",     generic,       9_1A,      9,  AARCH64_FL_FOR_ARCH9_1)\n+AARCH64_ARCH(\"armv9.2-a\",     generic,       9_2A,      9,  AARCH64_FL_FOR_ARCH9_2)\n+AARCH64_ARCH(\"armv9.3-a\",     generic,       9_3A,      9,  AARCH64_FL_FOR_ARCH9_3)\n \n #undef AARCH64_ARCH"}, {"sha": "f790de1cf46d68c78e2b6bae54ec7a72b4b2a020", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -239,6 +239,15 @@\n /* Armv8.8-a architecture extensions.  */\n #define AARCH64_FL_V8_8       (1ULL << 45)\n \n+/* Armv9.1-A.  */\n+#define AARCH64_FL_V9_1       (1ULL << 46)\n+\n+/* Armv9.2-A.  */\n+#define AARCH64_FL_V9_2       (1ULL << 47)\n+\n+/* Armv9.3-A.  */\n+#define AARCH64_FL_V9_3       (1ULL << 48)\n+\n /* Has FP and SIMD.  */\n #define AARCH64_FL_FPSIMD     (AARCH64_FL_FP | AARCH64_FL_SIMD)\n \n@@ -273,6 +282,12 @@\n #define AARCH64_FL_FOR_ARCH9       \\\n   (AARCH64_FL_FOR_ARCH8_5 | AARCH64_FL_SVE | AARCH64_FL_SVE2 | AARCH64_FL_V9 \\\n    | AARCH64_FL_F16)\n+#define AARCH64_FL_FOR_ARCH9_1\t\\\n+  (AARCH64_FL_FOR_ARCH9 | AARCH64_FL_FOR_ARCH8_6 | AARCH64_FL_V9_1)\n+#define AARCH64_FL_FOR_ARCH9_2\t\\\n+  (AARCH64_FL_FOR_ARCH9_1 | AARCH64_FL_FOR_ARCH8_7 | AARCH64_FL_V9_2)\n+#define AARCH64_FL_FOR_ARCH9_3\t\\\n+  (AARCH64_FL_FOR_ARCH9_2 | AARCH64_FL_FOR_ARCH8_8 | AARCH64_FL_V9_3)\n \n /* Macros to test ISA flags.  */\n \n@@ -312,6 +327,9 @@\n #define AARCH64_ISA_V8_R\t   (aarch64_isa_flags & AARCH64_FL_V8_R)\n #define AARCH64_ISA_PAUTH\t   (aarch64_isa_flags & AARCH64_FL_PAUTH)\n #define AARCH64_ISA_V9\t\t   (aarch64_isa_flags & AARCH64_FL_V9)\n+#define AARCH64_ISA_V9_1           (aarch64_isa_flags & AARCH64_FL_V9_1)\n+#define AARCH64_ISA_V9_2           (aarch64_isa_flags & AARCH64_FL_V9_2)\n+#define AARCH64_ISA_V9_3           (aarch64_isa_flags & AARCH64_FL_V9_3)\n #define AARCH64_ISA_MOPS\t   (aarch64_isa_flags & AARCH64_FL_MOPS)\n #define AARCH64_ISA_LS64\t   (aarch64_isa_flags & AARCH64_FL_LS64)\n "}, {"sha": "75f7475ad1824727f33fbac56da45de8d2a1635b", "filename": "gcc/config/i386/avx512fp16intrin.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Fi386%2Favx512fp16intrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Fi386%2Favx512fp16intrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Favx512fp16intrin.h?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -183,21 +183,21 @@ extern __inline __m128h\n __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n _mm_setzero_ph (void)\n {\n-  return _mm_set1_ph (0.0f);\n+  return _mm_set1_ph (0.0f16);\n }\n \n extern __inline __m256h\n __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n _mm256_setzero_ph (void)\n {\n-  return _mm256_set1_ph (0.0f);\n+  return _mm256_set1_ph (0.0f16);\n }\n \n extern __inline __m512h\n __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n _mm512_setzero_ph (void)\n {\n-  return _mm512_set1_ph (0.0f);\n+  return _mm512_set1_ph (0.0f16);\n }\n \n extern __inline __m128h\n@@ -358,15 +358,16 @@ extern __inline __m128h\n __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n _mm_set_sh (_Float16 __F)\n {\n-  return _mm_set_ph (0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, __F);\n+  return _mm_set_ph (0.0f16, 0.0f16, 0.0f16, 0.0f16, 0.0f16, 0.0f16, 0.0f16,\n+\t\t     __F);\n }\n \n /* Create a vector with element 0 as *P and the rest zero.  */\n extern __inline __m128h\n __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n _mm_load_sh (void const *__P)\n {\n-  return _mm_set_ph (0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f,\n+  return _mm_set_ph (0.0f16, 0.0f16, 0.0f16, 0.0f16, 0.0f16, 0.0f16, 0.0f16,\n \t\t     *(_Float16 const *) __P);\n }\n "}, {"sha": "b91aba182213c03f85952aeed15024a0a5527ce3", "filename": "gcc/config/i386/i386-builtins.cc", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Fi386%2Fi386-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Fi386%2Fi386-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-builtins.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1409,9 +1409,18 @@ ix86_init_builtin_types (void)\n   lang_hooks.types.register_builtin_type (float80_type_node, \"__float80\");\n \n   /* The __float128 type.  The node has already been created as\n-     _Float128, so we only need to register the __float128 name for\n-     it.  */\n-  lang_hooks.types.register_builtin_type (float128_type_node, \"__float128\");\n+     _Float128, so for C we only need to register the __float128 name for\n+     it.  For C++, we create a distinct type which will mangle differently\n+     (g) vs. _Float128 (DF128_) and behave backwards compatibly.  */\n+  if (float128t_type_node == NULL_TREE)\n+    {\n+      float128t_type_node = make_node (REAL_TYPE);\n+      TYPE_PRECISION (float128t_type_node)\n+\t= TYPE_PRECISION (float128_type_node);\n+      SET_TYPE_MODE (float128t_type_node, TYPE_MODE (float128_type_node));\n+      layout_type (float128t_type_node);\n+    }\n+  lang_hooks.types.register_builtin_type (float128t_type_node, \"__float128\");\n \n   ix86_register_float16_builtin_type ();\n "}, {"sha": "6baff6d0e61b20f32033c95db118d3ba125f1302", "filename": "gcc/config/i386/i386-expand.cc", "status": "modified", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Fi386%2Fi386-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Fi386%2Fi386-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -19604,6 +19604,119 @@ expand_vec_perm_1 (struct expand_vec_perm_d *d)\n   return false;\n }\n \n+/* A subroutine of ix86_expand_vec_perm_const_1. Try to implement D\n+   in terms of a pair of shufps+ shufps/pshufd instructions.  */\n+static bool\n+expand_vec_perm_shufps_shufps (struct expand_vec_perm_d *d)\n+{\n+  unsigned char perm1[4];\n+  machine_mode vmode = d->vmode;\n+  bool ok;\n+  unsigned i, j, k, count = 0;\n+\n+  if (d->one_operand_p\n+      || (vmode != V4SImode && vmode != V4SFmode))\n+    return false;\n+\n+  if (d->testing_p)\n+    return true;\n+\n+  for (i = 0; i < 4; ++i)\n+    count += d->perm[i] > 3 ? 1 : 0;\n+\n+  gcc_assert (count & 3);\n+\n+  rtx tmp = gen_reg_rtx (vmode);\n+  /* 2 from op0 and 2 from op1.  */\n+  if (count == 2)\n+    {\n+      unsigned char perm2[4];\n+      for (i = 0, j = 0, k = 2; i < 4; ++i)\n+\tif (d->perm[i] & 4)\n+\t  {\n+\t    perm1[k++] = d->perm[i];\n+\t    perm2[i] = k - 1;\n+\t  }\n+\telse\n+\t  {\n+\t    perm1[j++] = d->perm[i];\n+\t    perm2[i] = j - 1;\n+\t  }\n+\n+      /* shufps.  */\n+      ok = expand_vselect_vconcat (tmp, d->op0, d->op1,\n+\t\t\t\t  perm1, d->nelt, false);\n+      gcc_assert (ok);\n+      if (vmode == V4SImode && TARGET_SSE2)\n+      /* pshufd.  */\n+\tok = expand_vselect (d->target, tmp,\n+\t\t\t     perm2, d->nelt, false);\n+      else\n+\t{\n+\t  /* shufps.  */\n+\t  perm2[2] += 4;\n+\t  perm2[3] += 4;\n+\t  ok = expand_vselect_vconcat (d->target, tmp, tmp,\n+\t\t\t\t       perm2, d->nelt, false);\n+\t}\n+      gcc_assert (ok);\n+    }\n+  /* 3 from one op and 1 from another.  */\n+  else\n+    {\n+      unsigned pair_idx = 8, lone_idx = 8, shift;\n+\n+      /* Find the lone index.  */\n+      for (i = 0; i < 4; ++i)\n+\tif ((d->perm[i] > 3 && count == 1)\n+\t    || (d->perm[i] < 4 && count == 3))\n+\t  lone_idx = i;\n+\n+      /* When lone_idx is not 0, it must from second op(count == 1).  */\n+      gcc_assert (count == (lone_idx ? 1 : 3));\n+\n+      /* Find the pair index that sits in the same half as the lone index.  */\n+      shift = lone_idx & 2;\n+      pair_idx = 1 - lone_idx + 2 * shift;\n+\n+      /* First permutate lone index and pair index into the same vector as\n+\t [ lone, lone, pair, pair ].  */\n+      perm1[1] = perm1[0]\n+\t= (count == 3) ? d->perm[lone_idx] : d->perm[lone_idx] - 4;\n+      perm1[3] = perm1[2]\n+\t= (count == 3) ? d->perm[pair_idx] : d->perm[pair_idx] + 4;\n+\n+      /* Alway put the vector contains lone indx at the first.  */\n+      if (count == 1)\n+\tstd::swap (d->op0, d->op1);\n+\n+      /* shufps.  */\n+      ok = expand_vselect_vconcat (tmp, d->op0, d->op1,\n+\t\t\t\t   perm1, d->nelt, false);\n+      gcc_assert (ok);\n+\n+      /* Refine lone and pair index to original order.  */\n+      perm1[shift] = lone_idx << 1;\n+      perm1[shift + 1] = pair_idx << 1;\n+\n+      /* Select the remaining 2 elements in another vector.  */\n+      for (i = 2 - shift; i < 4 - shift; ++i)\n+\tperm1[i] = lone_idx == 1 ? d->perm[i] + 4 : d->perm[i];\n+\n+      /* Adjust to original selector.  */\n+      if (lone_idx > 1)\n+\tstd::swap (tmp, d->op1);\n+\n+      /* shufps.  */\n+      ok = expand_vselect_vconcat (d->target, tmp, d->op1,\n+\t\t\t\t   perm1, d->nelt, false);\n+\n+      gcc_assert (ok);\n+    }\n+\n+  return true;\n+}\n+\n /* A subroutine of ix86_expand_vec_perm_const_1.  Try to implement D\n    in terms of a pair of pshuflw + pshufhw instructions.  */\n \n@@ -22152,6 +22265,9 @@ ix86_expand_vec_perm_const_1 (struct expand_vec_perm_d *d)\n   if (expand_vec_perm_2perm_pblendv (d, true))\n     return true;\n \n+  if (expand_vec_perm_shufps_shufps (d))\n+    return true;\n+\n   /* Try sequences of three instructions.  */\n \n   if (expand_vec_perm_even_odd_pack (d))"}, {"sha": "4386caf843eaf8b58b54836efad49d518d3404b8", "filename": "gcc/config/i386/i386.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Fi386%2Fi386.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Fi386%2Fi386.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -22735,7 +22735,10 @@ ix86_mangle_type (const_tree type)\n       return \"DF16_\";\n     case E_TFmode:\n       /* __float128 is \"g\".  */\n-      return \"g\";\n+      if (type == float128t_type_node)\n+\treturn \"g\";\n+      /* _Float128 should mangle as \"DF128_\" done in generic code.  */\n+      return NULL;\n     case E_XFmode:\n       /* \"long double\" or __float80 is \"e\".  */\n       return \"e\";"}, {"sha": "d510573a0a43267150cf79123aa3b5a295f960f8", "filename": "gcc/config/ia64/ia64.cc", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Fia64%2Fia64.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Fia64%2Fia64.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -10466,11 +10466,19 @@ ia64_init_builtins (void)\n \t= build_pointer_type (build_qualified_type\n \t\t\t      (char_type_node, TYPE_QUAL_CONST));\n \n-      (*lang_hooks.types.register_builtin_type) (float128_type_node,\n+      if (float128t_type_node == NULL_TREE)\n+\t{\n+\t  float128t_type_node = make_node (REAL_TYPE);\n+\t  TYPE_PRECISION (float128t_type_node)\n+\t    = TYPE_PRECISION (float128_type_node);\n+\t  layout_type (float128t_type_node);\n+\t  SET_TYPE_MODE (float128t_type_node, TYPE_MODE (float128_type_node));\n+\t}\n+      (*lang_hooks.types.register_builtin_type) (float128t_type_node,\n \t\t\t\t\t\t \"__float128\");\n \n       /* TFmode support builtins.  */\n-      ftype = build_function_type_list (float128_type_node, NULL_TREE);\n+      ftype = build_function_type_list (float128t_type_node, NULL_TREE);\n       decl = add_builtin_function (\"__builtin_infq\", ftype,\n \t\t\t\t   IA64_BUILTIN_INFQ, BUILT_IN_MD,\n \t\t\t\t   NULL, NULL_TREE);\n@@ -10481,7 +10489,7 @@ ia64_init_builtins (void)\n \t\t\t\t   NULL, NULL_TREE);\n       ia64_builtins[IA64_BUILTIN_HUGE_VALQ] = decl;\n \n-      ftype = build_function_type_list (float128_type_node,\n+      ftype = build_function_type_list (float128t_type_node,\n \t\t\t\t\tconst_string_type,\n \t\t\t\t\tNULL_TREE);\n       decl = add_builtin_function (\"__builtin_nanq\", ftype,\n@@ -10496,18 +10504,18 @@ ia64_init_builtins (void)\n       TREE_READONLY (decl) = 1;\n       ia64_builtins[IA64_BUILTIN_NANSQ] = decl;\n \n-      ftype = build_function_type_list (float128_type_node,\n-\t\t\t\t\tfloat128_type_node,\n+      ftype = build_function_type_list (float128t_type_node,\n+\t\t\t\t\tfloat128t_type_node,\n \t\t\t\t\tNULL_TREE);\n       decl = add_builtin_function (\"__builtin_fabsq\", ftype,\n \t\t\t\t   IA64_BUILTIN_FABSQ, BUILT_IN_MD,\n \t\t\t\t   \"__fabstf2\", NULL_TREE);\n       TREE_READONLY (decl) = 1;\n       ia64_builtins[IA64_BUILTIN_FABSQ] = decl;\n \n-      ftype = build_function_type_list (float128_type_node,\n-\t\t\t\t\tfloat128_type_node,\n-\t\t\t\t\tfloat128_type_node,\n+      ftype = build_function_type_list (float128t_type_node,\n+\t\t\t\t\tfloat128t_type_node,\n+\t\t\t\t\tfloat128t_type_node,\n \t\t\t\t\tNULL_TREE);\n       decl = add_builtin_function (\"__builtin_copysignq\", ftype,\n \t\t\t\t   IA64_BUILTIN_COPYSIGNQ, BUILT_IN_MD,"}, {"sha": "9a5878e855ba0a704ca791692bfab39408151601", "filename": "gcc/config/nvptx/gen-multilib-matches.sh", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Fnvptx%2Fgen-multilib-matches.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Fnvptx%2Fgen-multilib-matches.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fgen-multilib-matches.sh?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,60 @@\n+#!/bin/sh\n+\n+# Print nvptx 'MULTILIB_MATCHES'\n+\n+# Copyright (C) 2022 Free Software Foundation, Inc.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+set -e\n+\n+nvptx_sm_def=\"$1/nvptx-sm.def\"\n+multilib_options_isa_default=$2\n+multilib_options_isa_list=$3\n+\n+sms=$(grep ^NVPTX_SM $nvptx_sm_def | sed 's/.*(//;s/,.*//')\n+\n+# Every variant in 'sms' has to either be remapped to the default variant\n+# ('.', which is always built), or does get built as non-default variant\n+# ('misa=sm_SM'; thus not remapped), or has to be remapped to the \"next lower\"\n+# variant that does get built.\n+\n+# The \"lowest\" variant has to be built.\n+sm_next_lower=INVALID\n+\n+for sm in $sms; do\n+    if [ x\"sm_$sm\" = x\"$multilib_options_isa_default\" ]; then\n+\tsm_map=.\n+    elif expr \" $multilib_options_isa_list \" : \".* sm_$sm \" > /dev/null; then\n+\tsm_map=\n+    else\n+\tsm_map=$sm_next_lower\n+    fi\n+\n+    if [ x\"$sm_map\" = x ]; then\n+\tsm_next_lower=$sm\n+    else\n+\t# Output format as required for 'MULTILIB_MATCHES'.\n+\tif [ x\"$sm_map\" = x. ]; then\n+\t    echo \".=misa?sm_$sm\"\n+\telse\n+\t    echo \"misa?sm_$sm_map=misa?sm_$sm\"\n+\tfi\n+\n+\tsm_next_lower=$sm_map\n+    fi\n+done"}, {"sha": "2fe120b387303887f0f7e4643e1f62b427fed574", "filename": "gcc/config/nvptx/nvptx.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Fnvptx%2Fnvptx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Fnvptx%2Fnvptx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -334,6 +334,10 @@ nvptx_option_override (void)\n {\n   init_machine_status = nvptx_init_machine_status;\n \n+  /* Via nvptx 'OPTION_DEFAULT_SPECS', '-misa' always appears on the command\n+     line.  */\n+  gcc_checking_assert (OPTION_SET_P (ptx_isa_option));\n+\n   handle_ptx_version_option ();\n \n   /* Set toplevel_reorder, unless explicitly disabled.  We need"}, {"sha": "0afc83b10a3019b947fccbc563bee73bedee7904", "filename": "gcc/config/nvptx/nvptx.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Fnvptx%2Fnvptx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Fnvptx%2Fnvptx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.h?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -27,6 +27,14 @@\n \n /* Run-time Target.  */\n \n+/* Use '--with-arch' for default '-misa'.  */\n+#define OPTION_DEFAULT_SPECS \\\n+  { \"arch\", \"%{!misa=*:-misa=%(VALUE)}\" }, \\\n+\n+/* Assembler supports '-v' option; handle similar to\n+   '../../gcc.cc:asm_options', 'HAVE_GNU_AS'.  */\n+#define ASM_SPEC \"%{v}\"\n+\n #define STARTFILE_SPEC \"%{mmainkernel:crt0.o}\"\n \n #define TARGET_CPU_CPP_BUILTINS() nvptx_cpu_cpp_builtins ()"}, {"sha": "71d3b68510bd88767073d8d578e6ca3194b38417", "filename": "gcc/config/nvptx/nvptx.opt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Fnvptx%2Fnvptx.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Fnvptx%2Fnvptx.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.opt?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -53,7 +53,7 @@ Target Mask(GOMP)\n Generate code for OpenMP offloading: enables -msoft-stack and -muniform-simt.\n \n misa=\n-Target RejectNegative ToLower Joined Enum(ptx_isa) Var(ptx_isa_option) Init(PTX_ISA_SM30)\n+Target RejectNegative ToLower Joined Enum(ptx_isa) Var(ptx_isa_option)\n Specify the PTX ISA target architecture to use.\n \n march="}, {"sha": "9c5cbda0070749fe47b79d245aca664e37f94fc8", "filename": "gcc/config/nvptx/t-nvptx", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Fnvptx%2Ft-nvptx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Fnvptx%2Ft-nvptx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Ft-nvptx?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -31,4 +31,33 @@ s-nvptx-gen-opt: $(srcdir)/config/nvptx/nvptx-sm.def \\\n \t  tmp-nvptx-gen.opt $(srcdir)/config/nvptx/nvptx-gen.opt\n \t$(STAMP) s-nvptx-gen-opt\n \n-MULTILIB_OPTIONS = mgomp mptx=3.1\n+\n+# Multilib setup.\n+\n+MULTILIB_OPTIONS =\n+MULTILIB_MATCHES =\n+MULTILIB_EXCEPTIONS =\n+\n+MULTILIB_OPTIONS += mgomp\n+\n+multilib_options_isa_list := $(TM_MULTILIB_CONFIG)\n+multilib_options_isa_default := $(word 1,$(multilib_options_isa_list))\n+multilib_options_misa_list := $(addprefix misa=,$(multilib_options_isa_list))\n+# Add the requested '-misa' variants as a multilib option ('misa=VAR1/misa=VAR2/misa=VAR3' etc.):\n+empty :=\n+space := $(empty) $(empty)\n+MULTILIB_OPTIONS += $(subst $(space),/,$(multilib_options_misa_list))\n+# ..., and remap '-misa' variants as appropriate:\n+multilib_matches := $(shell $(srcdir)/config/nvptx/gen-multilib-matches.sh $(srcdir)/config/nvptx $(multilib_options_isa_default) \"$(multilib_options_isa_list)\")\n+MULTILIB_MATCHES += $(multilib_matches)\n+# ..., and don't actually build what's the default '-misa':\n+MULTILIB_EXCEPTIONS += *misa=$(multilib_options_isa_default)*\n+\n+MULTILIB_OPTIONS += mptx=3.1\n+# Filter out invalid '-misa'/'-mptx=3.1' combinations; per 'nvptx-sm.def',\n+# 'nvptx.opt:ptx_version', 'nvptx.cc:first_ptx_version_supporting_sm'\n+# (that is, '-mptx=3.1' only for sm_30, sm_35 variants):\n+MULTILIB_EXCEPTIONS += $(foreach misa,$(filter-out %=sm_30 %=sm_35,$(multilib_options_misa_list)),*$(misa)/mptx=3.1)\n+# ..., and special care has to be taken if '-mptx=3.1' is invalid for the\n+# default variant:\n+MULTILIB_EXCEPTIONS += $(if $(filter-out sm_30 sm_35,$(multilib_options_isa_default)),mgomp/mptx=3.1 mptx=3.1)"}, {"sha": "90ab39dc2588933c499e3478e4e2f264798b09d0", "filename": "gcc/config/rs6000/rs6000-builtin.cc", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -733,7 +733,22 @@ rs6000_init_builtins (void)\n       if (TARGET_IEEEQUAD && TARGET_LONG_DOUBLE_128)\n \tieee128_float_type_node = long_double_type_node;\n       else\n-\tieee128_float_type_node = float128_type_node;\n+\t{\n+\t  /* For C we only need to register the __ieee128 name for\n+\t     it.  For C++, we create a distinct type which will mangle\n+\t     differently (u9__ieee128) vs. _Float128 (DF128_) and behave\n+\t     backwards compatibly.  */\n+\t  if (float128t_type_node == NULL_TREE)\n+\t    {\n+\t      float128t_type_node = make_node (REAL_TYPE);\n+\t      TYPE_PRECISION (float128t_type_node)\n+\t\t= TYPE_PRECISION (float128_type_node);\n+\t      layout_type (float128t_type_node);\n+\t      SET_TYPE_MODE (float128t_type_node,\n+\t\t\t     TYPE_MODE (float128_type_node));\n+\t    }\n+\t  ieee128_float_type_node = float128t_type_node;\n+\t}\n       t = build_qualified_type (ieee128_float_type_node, TYPE_QUAL_CONST);\n       lang_hooks.types.register_builtin_type (ieee128_float_type_node,\n \t\t\t\t\t      \"__ieee128\");"}, {"sha": "56609462629368bb230d67fe9638db8980fef652", "filename": "gcc/config/rs6000/rs6000-c.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Frs6000%2Frs6000-c.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Frs6000%2Frs6000-c.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -808,6 +808,7 @@ static inline bool\n is_float128_p (tree t)\n {\n   return (t == float128_type_node\n+\t  || (t && t == float128t_type_node)\n \t  || (TARGET_IEEEQUAD\n \t      && TARGET_LONG_DOUBLE_128\n \t      && t == long_double_type_node));"}, {"sha": "f575e69a8ea1b87d1701996c10092433c6bdb8e5", "filename": "gcc/config/rs6000/rs6000-logue.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Frs6000%2Frs6000-logue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Frs6000%2Frs6000-logue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-logue.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -4920,7 +4920,7 @@ rs6000_emit_epilogue (enum epilogue_type epilogue_type)\n \t a REG_CFA_DEF_CFA note, but that's OK;  A duplicate is\n \t discarded by dwarf2cfi.cc/dwarf2out.cc, and in any case would\n \t be harmless if emitted.  */\n-      if (frame_pointer_needed)\n+      if (frame_pointer_needed_indeed)\n \t{\n \t  insn = get_last_insn ();\n \t  add_reg_note (insn, REG_CFA_DEF_CFA,"}, {"sha": "bbe21eacc6b95db99e20e54857bb68cbe1afa65a", "filename": "gcc/config/rs6000/rs6000.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Frs6000%2Frs6000.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Frs6000%2Frs6000.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -20272,7 +20272,11 @@ rs6000_mangle_type (const_tree type)\n \n   if (SCALAR_FLOAT_TYPE_P (type) && FLOAT128_IBM_P (TYPE_MODE (type)))\n     return \"g\";\n-  if (SCALAR_FLOAT_TYPE_P (type) && FLOAT128_IEEE_P (TYPE_MODE (type)))\n+  if (SCALAR_FLOAT_TYPE_P (type)\n+      && FLOAT128_IEEE_P (TYPE_MODE (type))\n+      /* _Float128 should mangle as DF128_ (done in generic code)\n+\t rather than u9__ieee128 (used for __ieee128 and __float128).  */\n+      && type != float128_type_node)\n     return \"u9__ieee128\";\n \n   if (type == vector_pair_type_node)"}, {"sha": "0171705803c2b79bc7a1f449117ccbb48a7a9558", "filename": "gcc/config/rs6000/vector.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Frs6000%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Frs6000%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvector.md?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1475,7 +1475,7 @@\n   [(match_operand:VEC_L 0 \"vlogical_operand\")\n    (match_operand:VEC_L 1 \"vlogical_operand\")\n    (match_operand:QI 2 \"reg_or_short_operand\")]\n-  \"TARGET_ALTIVEC\"\n+  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n {\n   rtx bitshift = operands[2];\n   rtx shift;"}, {"sha": "9861913af05093599fc2b920116fd5025c343a2a", "filename": "gcc/config/s390/s390.cc", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Fs390%2Fs390.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fconfig%2Fs390%2Fs390.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -3648,7 +3648,7 @@ s390_rtx_costs (rtx x, machine_mode mode, int outer_code,\n       *total = 0;\n       return true;\n       case SET: {\n-\trtx dest = SET_DEST (x);\n+\trtx dst = SET_DEST (x);\n \trtx src = SET_SRC (x);\n \n \tswitch (GET_CODE (src))\n@@ -3669,7 +3669,6 @@ s390_rtx_costs (rtx x, machine_mode mode, int outer_code,\n \t\t slightly more expensive than a normal load.  */\n \t      *total = COSTS_N_INSNS (1) + 2;\n \n-\t      rtx dst = SET_DEST (src);\n \t      rtx then = XEXP (src, 1);\n \t      rtx els = XEXP (src, 2);\n \n@@ -3696,33 +3695,33 @@ s390_rtx_costs (rtx x, machine_mode mode, int outer_code,\n \t    break;\n \t  }\n \n-\tswitch (GET_CODE (dest))\n+\tswitch (GET_CODE (dst))\n \t  {\n \t  case SUBREG:\n-\t    if (!REG_P (SUBREG_REG (dest)))\n+\t    if (!REG_P (SUBREG_REG (dst)))\n \t      *total += rtx_cost (SUBREG_REG (src), VOIDmode, SET, 0, speed);\n \t    /* fallthrough */\n \t  case REG:\n \t    /* If this is a VR -> VR copy, count the number of\n \t       registers.  */\n-\t    if (VECTOR_MODE_P (GET_MODE (dest)) && REG_P (src))\n+\t    if (VECTOR_MODE_P (GET_MODE (dst)) && REG_P (src))\n \t      {\n-\t\tint nregs = s390_hard_regno_nregs (VR0_REGNUM, GET_MODE (dest));\n+\t\tint nregs = s390_hard_regno_nregs (VR0_REGNUM, GET_MODE (dst));\n \t\t*total = COSTS_N_INSNS (nregs);\n \t      }\n \t    /* Same for GPRs.  */\n \t    else if (REG_P (src))\n \t      {\n \t\tint nregs\n-\t\t  = s390_hard_regno_nregs (GPR0_REGNUM, GET_MODE (dest));\n+\t\t  = s390_hard_regno_nregs (GPR0_REGNUM, GET_MODE (dst));\n \t\t*total = COSTS_N_INSNS (nregs);\n \t      }\n \t    else\n \t      /* Otherwise just cost the src.  */\n \t      *total += rtx_cost (src, mode, SET, 1, speed);\n \t    return true;\n \t    case MEM: {\n-\t      rtx address = XEXP (dest, 0);\n+\t      rtx address = XEXP (dst, 0);\n \t      rtx tmp;\n \t      HOST_WIDE_INT tmp2;\n \t      if (s390_loadrelative_operand_p (address, &tmp, &tmp2))"}, {"sha": "ca5015e162133e439b98e6bb1e541f8a844c45fa", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,3 +1,28 @@\n+2022-09-26  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/106656\n+\t* typeck2.cc (array_string_literal_compatible_p): Allow\n+\tinitializing arrays of char or unsigned char by a UTF-8 string literal.\n+\n+2022-09-26  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/106784\n+\t* method.cc (is_convertible_helper): New.\n+\t(is_convertible): Use it.\n+\t(is_nothrow_convertible): Likewise.\n+\n+2022-09-26  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/107033\n+\t* module.cc (trees_in::decl_value): In the MK_partial case for\n+\ta variable template partial specialization, pass decl_p=true to\n+\tadd_mergeable_specialization, and set spec to the VAR_DECL not\n+\tthe TEMPLATE_DECL.\n+\t* pt.cc (add_mergeable_specialization): For a variable template\n+\tpartial specialization, set the TREE_TYPE of the new\n+\tDECL_TEMPLATE_SPECIALIZATIONS node to the TREE_TYPE of the\n+\tVAR_DECL not the VAR_DECL itself.\n+\n 2022-09-23  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/106784"}, {"sha": "fc86b74a5a43e610a0bb16dde0b6dbbc6795bbe4", "filename": "gcc/cp/call.cc", "status": "modified", "additions": 148, "deletions": 5, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcp%2Fcall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcp%2Fcall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1541,6 +1541,22 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n \t   || (underlying_type && same_type_p (to, underlying_type)))\n \t  && next_conversion (conv)->rank <= cr_promotion)\n \tconv->rank = cr_promotion;\n+\n+      /* A prvalue of floating-point type can be converted to a prvalue of\n+\t another floating-point type with a greater or equal conversion\n+\t rank ([conv.rank]).  A prvalue of standard floating-point type can\n+\t be converted to a prvalue of another standard floating-point type.\n+\t For backwards compatibility with handling __float128 and other\n+\t non-standard floating point types, allow all implicit floating\n+\t point conversions if neither type is extended floating-point\n+\t type and if at least one of them is, fail if they have unordered\n+\t conversion rank or from has higher conversion rank.  */\n+      if (fcode == REAL_TYPE\n+\t  && tcode == REAL_TYPE\n+\t  && (extended_float_type_p (from)\n+\t      || extended_float_type_p (to))\n+\t  && cp_compare_floating_point_conversion_ranks (from, to) >= 2)\n+\tconv->bad_p = true;\n     }\n   else if (fcode == VECTOR_TYPE && tcode == VECTOR_TYPE\n \t   && vector_types_convertible_p (from, to, false))\n@@ -5842,6 +5858,21 @@ build_conditional_expr (const op_location_t &loc,\n       /* In this case, there is always a common type.  */\n       result_type = type_after_usual_arithmetic_conversions (arg2_type,\n \t\t\t\t\t\t\t     arg3_type);\n+      if (result_type == error_mark_node\n+\t  && TREE_CODE (arg2_type) == REAL_TYPE\n+\t  && TREE_CODE (arg3_type) == REAL_TYPE\n+\t  && (extended_float_type_p (arg2_type)\n+\t      || extended_float_type_p (arg3_type))\n+\t  && cp_compare_floating_point_conversion_ranks (arg2_type,\n+\t\t\t\t\t\t\t arg3_type) == 3)\n+\t{\n+\t  if (complain & tf_error)\n+\t    error_at (loc, \"operands to %<?:%> of types %qT and %qT \"\n+\t\t\t   \"have unordered conversion rank\",\n+\t\t      arg2_type, arg3_type);\n+\t  return error_mark_node;\n+\t}\n+\n       if (complain & tf_warning)\n \tdo_warn_double_promotion (result_type, arg2_type, arg3_type,\n \t\t\t\t  \"implicit conversion from %qH to %qI to \"\n@@ -7906,6 +7937,27 @@ convert_like_internal (conversion *convs, tree expr, tree fn, int argnum,\n \t\t\t\t\"direct-initialization\",\n \t\t\t\ttotype, TREE_TYPE (expr));\n \n+      if (TREE_CODE (TREE_TYPE (expr)) == REAL_TYPE\n+\t  && TREE_CODE (totype) == REAL_TYPE\n+\t  && (extended_float_type_p (TREE_TYPE (expr))\n+\t      || extended_float_type_p (totype)))\n+\tswitch (cp_compare_floating_point_conversion_ranks (TREE_TYPE (expr),\n+\t\t\t\t\t\t\t    totype))\n+\t  {\n+\t  case 2:\n+\t    pedwarn (loc, 0, \"converting to %qH from %qI with greater \"\n+\t\t\t     \"conversion rank\", totype, TREE_TYPE (expr));\n+\t    complained = true;\n+\t    break;\n+\t  case 3:\n+\t    pedwarn (loc, 0, \"converting to %qH from %qI with unordered \"\n+\t\t\t     \"conversion ranks\", totype, TREE_TYPE (expr));\n+\t    complained = true;\n+\t    break;\n+\t  default:\n+\t    break;\n+\t  }\n+\n       for (; t ; t = next_conversion (t))\n \t{\n \t  if (t->kind == ck_user && t->cand->reason)\n@@ -8531,7 +8583,8 @@ convert_arg_to_ellipsis (tree arg, tsubst_flags_t complain)\n   if (TREE_CODE (arg_type) == REAL_TYPE\n       && (TYPE_PRECISION (arg_type)\n \t  < TYPE_PRECISION (double_type_node))\n-      && !DECIMAL_FLOAT_MODE_P (TYPE_MODE (arg_type)))\n+      && !DECIMAL_FLOAT_MODE_P (TYPE_MODE (arg_type))\n+      && !extended_float_type_p (arg_type))\n     {\n       if ((complain & tf_warning)\n \t  && warn_double_promotion && !c_inhibit_evaluation_warnings)\n@@ -11719,6 +11772,81 @@ compare_ics (conversion *ics1, conversion *ics2)\n \treturn 1;\n     }\n \n+  {\n+    /* A conversion in either direction between floating-point type FP1 and\n+       floating-point type FP2 is better than a conversion in the same\n+       direction between FP1 and arithmetic type T3 if\n+       - the floating-point conversion rank of FP1 is equal to the rank of\n+\t FP2, and\n+       - T3 is not a floating-point type, or T3 is a floating-point type\n+\t whose rank is not equal to the rank of FP1, or the floating-point\n+\t conversion subrank of FP2 is greater than the subrank of T3.  */\n+    tree fp1 = from_type1;\n+    tree fp2 = to_type1;\n+    tree fp3 = from_type2;\n+    tree t3 = to_type2;\n+    int ret = 1;\n+    if (TYPE_MAIN_VARIANT (fp2) == TYPE_MAIN_VARIANT (t3))\n+      {\n+\tstd::swap (fp1, fp2);\n+\tstd::swap (fp3, t3);\n+      }\n+    if (TYPE_MAIN_VARIANT (fp1) == TYPE_MAIN_VARIANT (fp3)\n+\t&& TREE_CODE (fp1) == REAL_TYPE\n+\t/* Only apply this rule if at least one of the 3 types is\n+\t   extended floating-point type, otherwise keep them as\n+\t   before for compatibility reasons with types like __float128.\n+\t   float, double and long double alone have different conversion\n+\t   ranks and so when just those 3 types are involved, this\n+\t   rule doesn't trigger.  */\n+\t&& (extended_float_type_p (fp1)\n+\t    || (TREE_CODE (fp2) == REAL_TYPE && extended_float_type_p (fp2))\n+\t    || (TREE_CODE (t3) == REAL_TYPE && extended_float_type_p (t3))))\n+      {\n+\tif (TREE_CODE (fp2) != REAL_TYPE)\n+\t  {\n+\t    ret = -ret;\n+\t    std::swap (fp2, t3);\n+\t  }\n+\tif (TREE_CODE (fp2) == REAL_TYPE)\n+\t  {\n+\t    /* cp_compare_floating_point_conversion_ranks returns -1, 0 or 1\n+\t       if the conversion rank is equal (-1 or 1 if the subrank is\n+\t       different).  */\n+\t    if (IN_RANGE (cp_compare_floating_point_conversion_ranks (fp1,\n+\t\t\t\t\t\t\t\t      fp2),\n+\t\t\t  -1, 1))\n+\t      {\n+\t\t/* Conversion ranks of FP1 and FP2 are equal.  */\n+\t\tif (TREE_CODE (t3) != REAL_TYPE\n+\t\t    || !IN_RANGE (cp_compare_floating_point_conversion_ranks\n+\t\t\t\t\t\t\t\t(fp1, t3),\n+\t\t\t\t  -1, 1))\n+\t\t  /* FP1 <-> FP2 conversion is better.  */\n+\t\t  return ret;\n+\t\tint c = cp_compare_floating_point_conversion_ranks (fp2, t3);\n+\t\tgcc_assert (IN_RANGE (c, -1, 1));\n+\t\tif (c == 1)\n+\t\t  /* Conversion subrank of FP2 is greater than subrank of T3.\n+\t\t     FP1 <-> FP2 conversion is better.  */\n+\t\t  return ret;\n+\t\telse if (c == -1)\n+\t\t  /* Conversion subrank of FP2 is less than subrank of T3.\n+\t\t     FP1 <-> T3 conversion is better.  */\n+\t\t  return -ret;\n+\t      }\n+\t    else if (TREE_CODE (t3) == REAL_TYPE\n+\t\t     && IN_RANGE (cp_compare_floating_point_conversion_ranks\n+\t\t\t\t\t\t\t\t(fp1, t3),\n+\t\t\t\t  -1, 1))\n+\t      /* Conversion ranks of FP1 and FP2 are not equal, conversion\n+\t\t ranks of FP1 and T3 are equal.\n+\t\t FP1 <-> T3 conversion is better.  */\n+\t      return -ret;\n+\t  }\n+      }\n+  }\n+\n   if (TYPE_PTR_P (from_type1)\n       && TYPE_PTR_P (from_type2)\n       && TYPE_PTR_P (to_type1)\n@@ -12133,10 +12261,14 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn,\n   len = cand1->num_convs;\n   if (len != cand2->num_convs)\n     {\n-      int static_1 = DECL_STATIC_FUNCTION_P (cand1->fn);\n-      int static_2 = DECL_STATIC_FUNCTION_P (cand2->fn);\n+      int static_1 = (TREE_CODE (cand1->fn) == FUNCTION_DECL\n+\t\t      && DECL_STATIC_FUNCTION_P (cand1->fn));\n+      int static_2 = (TREE_CODE (cand2->fn) == FUNCTION_DECL\n+\t\t      && DECL_STATIC_FUNCTION_P (cand2->fn));\n \n-      if (DECL_CONSTRUCTOR_P (cand1->fn)\n+      if (TREE_CODE (cand1->fn) == FUNCTION_DECL\n+\t  && TREE_CODE (cand2->fn) == FUNCTION_DECL\n+\t  && DECL_CONSTRUCTOR_P (cand1->fn)\n \t  && is_list_ctor (cand1->fn) != is_list_ctor (cand2->fn))\n \t/* We're comparing a near-match list constructor and a near-match\n \t   non-list constructor.  Just treat them as unordered.  */\n@@ -12145,9 +12277,20 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn,\n       gcc_assert (static_1 != static_2);\n \n       if (static_1)\n-\toff2 = 1;\n+\t{\n+\t  /* C++23 [over.best.ics.general] says:\n+\t     When the parameter is the implicit object parameter of a static\n+\t     member function, the implicit conversion sequence is a standard\n+\t     conversion sequence that is neither better nor worse than any\n+\t     other standard conversion sequence.  */\n+\t  if (CONVERSION_RANK (cand2->convs[0]) >= cr_user)\n+\t    winner = 1;\n+\t  off2 = 1;\n+\t}\n       else\n \t{\n+\t  if (CONVERSION_RANK (cand1->convs[0]) >= cr_user)\n+\t    winner = -1;\n \t  off1 = 1;\n \t  --len;\n \t}"}, {"sha": "99b486b80027ed7c80fc8e61b48d9ec060abdf57", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -504,6 +504,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       OVL_NESTED_P (in OVERLOAD)\n       DECL_MODULE_EXPORT_P (in _DECL)\n       PACK_EXPANSION_FORCE_EXTRA_ARGS_P (in *_PACK_EXPANSION)\n+      LAMBDA_EXPR_STATIC_P (in LAMBDA_EXPR)\n    4: IDENTIFIER_MARKED (IDENTIFIER_NODEs)\n       TREE_HAS_CONSTRUCTOR (in INDIRECT_REF, SAVE_EXPR, CONSTRUCTOR,\n \t  CALL_EXPR, or FIELD_DECL).\n@@ -1490,6 +1491,10 @@ enum cp_lambda_default_capture_mode_type {\n #define LAMBDA_EXPR_CAPTURE_OPTIMIZED(NODE) \\\n   TREE_LANG_FLAG_2 (LAMBDA_EXPR_CHECK (NODE))\n \n+/* Predicate tracking whether the lambda was declared 'static'.  */\n+#define LAMBDA_EXPR_STATIC_P(NODE) \\\n+  TREE_LANG_FLAG_3 (LAMBDA_EXPR_CHECK (NODE))\n+\n /* True if this TREE_LIST in LAMBDA_EXPR_CAPTURE_LIST is for an explicit\n    capture.  */\n #define LAMBDA_CAPTURE_EXPLICIT_P(NODE) \\\n@@ -1834,6 +1839,10 @@ struct GTY(()) omp_declare_target_attr {\n   bool attr_syntax;\n };\n \n+struct GTY(()) omp_begin_assumes_data {\n+  bool attr_syntax;\n+};\n+\n /* Global state.  */\n \n struct GTY(()) saved_scope {\n@@ -1881,6 +1890,7 @@ struct GTY(()) saved_scope {\n \n   hash_map<tree, tree> *GTY((skip)) x_local_specializations;\n   vec<omp_declare_target_attr, va_gc> *omp_declare_target_attribute;\n+  vec<omp_begin_assumes_data, va_gc> *omp_begin_assumes;\n \n   struct saved_scope *prev;\n };\n@@ -7946,6 +7956,7 @@ extern tree require_complete_type\t\t(tree,\n extern tree complete_type\t\t\t(tree);\n extern tree complete_type_or_else\t\t(tree, tree);\n extern tree complete_type_or_maybe_complain\t(tree, tree, tsubst_flags_t);\n+extern int cp_compare_floating_point_conversion_ranks (tree, tree);\n inline bool type_unknown_p\t\t\t(const_tree);\n enum { ce_derived, ce_type, ce_normal, ce_exact };\n extern bool comp_except_specs\t\t\t(const_tree, const_tree, int);\n@@ -8688,6 +8699,18 @@ struct push_access_scope_guard\n   }\n };\n \n+/* True if TYPE is an extended floating-point type.  */\n+\n+inline bool\n+extended_float_type_p (tree type)\n+{\n+  type = TYPE_MAIN_VARIANT (type);\n+  for (int i = 0; i < NUM_FLOATN_NX_TYPES; ++i)\n+    if (type == FLOATN_TYPE_NODE (i))\n+      return true;\n+  return false;\n+}\n+\n #if CHECKING_P\n namespace selftest {\n   extern void run_cp_tests (void);"}, {"sha": "fb85564a19139abfde3cc75fe1cb8167e5165be8", "filename": "gcc/cp/decl.cc", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcp%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcp%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -12095,12 +12095,7 @@ grokdeclarator (const cp_declarator *declarator,\n     }\n \n   if (declspecs->conflicting_specifiers_p)\n-    {\n-      error_at (min_location (declspecs->locations[ds_typedef],\n-\t\t\t      declspecs->locations[ds_storage_class]),\n-\t\t\"conflicting specifiers in declaration of %qs\", name);\n-      return error_mark_node;\n-    }\n+    return error_mark_node;\n \n   /* Extract the basic type from the decl-specifier-seq.  */\n   type = declspecs->type;\n@@ -15305,8 +15300,25 @@ grok_op_properties (tree decl, bool complain)\n      an enumeration, or a reference to an enumeration.  13.4.0.6 */\n   if (! methodp || DECL_STATIC_FUNCTION_P (decl))\n     {\n+      if (operator_code == CALL_EXPR)\n+\t{\n+\t  if (! DECL_STATIC_FUNCTION_P (decl))\n+\t    {\n+\t      error_at (loc, \"%qD must be a member function\", decl);\n+\t      return false;\n+\t    }\n+\t  if (cxx_dialect < cxx23\n+\t      /* For lambdas we diagnose static lambda specifier elsewhere.  */\n+\t      && ! LAMBDA_FUNCTION_P (decl)\n+\t      /* For instantiations, we have diagnosed this already.  */\n+\t      && ! DECL_USE_TEMPLATE (decl))\n+\t    pedwarn (loc, OPT_Wc__23_extensions, \"%qD may be a static member \"\n+\t      \"function only with %<-std=c++23%> or %<-std=gnu++23%>\", decl);\n+\t  /* There are no further restrictions on the arguments to an\n+\t     overloaded \"operator ()\".  */\n+\t  return true;\n+\t}\n       if (operator_code == TYPE_EXPR\n-\t  || operator_code == CALL_EXPR\n \t  || operator_code == COMPONENT_REF\n \t  || operator_code == ARRAY_REF\n \t  || operator_code == NOP_EXPR)"}, {"sha": "0389f35d731469b74f07949006af1693c65802c5", "filename": "gcc/cp/error.cc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcp%2Ferror.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcp%2Ferror.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1692,7 +1692,13 @@ dump_lambda_function (cxx_pretty_printer *pp,\n {\n   /* A lambda's signature is essentially its \"type\".  */\n   dump_type (pp, DECL_CONTEXT (fn), flags);\n-  if (!(TYPE_QUALS (class_of_this_parm (TREE_TYPE (fn))) & TYPE_QUAL_CONST))\n+  if (TREE_CODE (TREE_TYPE (fn)) == FUNCTION_TYPE)\n+    {\n+      pp->padding = pp_before;\n+      pp_c_ws_string (pp, \"static\");\n+    }\n+  else if (!(TYPE_QUALS (class_of_this_parm (TREE_TYPE (fn)))\n+\t     & TYPE_QUAL_CONST))\n     {\n       pp->padding = pp_before;\n       pp_c_ws_string (pp, \"mutable\");"}, {"sha": "e9d5d4dc1c52a816219891363cfd48b9889af0f3", "filename": "gcc/cp/lambda.cc", "status": "modified", "additions": 71, "deletions": 18, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcp%2Flambda.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcp%2Flambda.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1099,7 +1099,9 @@ maybe_add_lambda_conv_op (tree type)\n   tree optype = TREE_TYPE (callop);\n   tree fn_result = TREE_TYPE (optype);\n \n-  tree thisarg = build_int_cst (TREE_TYPE (DECL_ARGUMENTS (callop)), 0);\n+  tree thisarg = NULL_TREE;\n+  if (TREE_CODE (optype) == METHOD_TYPE)\n+    thisarg = build_int_cst (TREE_TYPE (DECL_ARGUMENTS (callop)), 0);\n   if (generic_lambda_p)\n     {\n       ++processing_template_decl;\n@@ -1109,18 +1111,25 @@ maybe_add_lambda_conv_op (tree type)\n \t return expression for a deduced return call op to allow for simple\n \t implementation of the conversion operator.  */\n \n-      tree instance = cp_build_fold_indirect_ref (thisarg);\n-      tree objfn = lookup_template_function (DECL_NAME (callop),\n-\t\t\t\t\t     DECL_TI_ARGS (callop));\n-      objfn = build_min (COMPONENT_REF, NULL_TREE,\n-\t\t\t instance, objfn, NULL_TREE);\n-      int nargs = list_length (DECL_ARGUMENTS (callop)) - 1;\n+      tree objfn;\n+      int nargs = list_length (DECL_ARGUMENTS (callop));\n+      if (thisarg)\n+\t{\n+\t  tree instance = cp_build_fold_indirect_ref (thisarg);\n+\t  objfn = lookup_template_function (DECL_NAME (callop),\n+\t\t\t\t\t    DECL_TI_ARGS (callop));\n+\t  objfn = build_min (COMPONENT_REF, NULL_TREE,\n+\t\t\t     instance, objfn, NULL_TREE);\n+\t  --nargs;\n+\t  call = prepare_op_call (objfn, nargs);\n+\t}\n+      else\n+\tobjfn = callop;\n \n-      call = prepare_op_call (objfn, nargs);\n       if (type_uses_auto (fn_result))\n \tdecltype_call = prepare_op_call (objfn, nargs);\n     }\n-  else\n+  else if (thisarg)\n     {\n       direct_argvec = make_tree_vector ();\n       direct_argvec->quick_push (thisarg);\n@@ -1135,9 +1144,11 @@ maybe_add_lambda_conv_op (tree type)\n   tree fn_args = NULL_TREE;\n   {\n     int ix = 0;\n-    tree src = DECL_CHAIN (DECL_ARGUMENTS (callop));\n+    tree src = FUNCTION_FIRST_USER_PARM (callop);\n     tree tgt = NULL;\n \n+    if (!thisarg && !decltype_call)\n+      src = NULL_TREE;\n     while (src)\n       {\n \ttree new_node = copy_node (src);\n@@ -1160,12 +1171,15 @@ maybe_add_lambda_conv_op (tree type)\n \tif (generic_lambda_p)\n \t  {\n \t    tree a = tgt;\n-\t    if (DECL_PACK_P (tgt))\n+\t    if (thisarg)\n \t      {\n-\t\ta = make_pack_expansion (a);\n-\t\tPACK_EXPANSION_LOCAL_P (a) = true;\n+\t\tif (DECL_PACK_P (tgt))\n+\t\t  {\n+\t\t    a = make_pack_expansion (a);\n+\t\t    PACK_EXPANSION_LOCAL_P (a) = true;\n+\t\t  }\n+\t\tCALL_EXPR_ARG (call, ix) = a;\n \t      }\n-\t    CALL_EXPR_ARG (call, ix) = a;\n \n \t    if (decltype_call)\n \t      {\n@@ -1193,7 +1207,7 @@ maybe_add_lambda_conv_op (tree type)\n \t     tf_warning_or_error);\n \t}\n     }\n-  else\n+  else if (thisarg)\n     {\n       /* Don't warn on deprecated or unavailable lambda declarations, unless\n \t the lambda is actually called.  */\n@@ -1203,10 +1217,14 @@ maybe_add_lambda_conv_op (tree type)\n \t\t\t   direct_argvec->address ());\n     }\n \n-  CALL_FROM_THUNK_P (call) = 1;\n-  SET_EXPR_LOCATION (call, UNKNOWN_LOCATION);\n+  if (thisarg)\n+    {\n+      CALL_FROM_THUNK_P (call) = 1;\n+      SET_EXPR_LOCATION (call, UNKNOWN_LOCATION);\n+    }\n \n-  tree stattype = build_function_type (fn_result, FUNCTION_ARG_CHAIN (callop));\n+  tree stattype\n+    = build_function_type (fn_result, FUNCTION_FIRST_USER_PARMTYPE (callop));\n   stattype = (cp_build_type_attribute_variant\n \t      (stattype, TYPE_ATTRIBUTES (optype)));\n   if (flag_noexcept_type\n@@ -1249,6 +1267,41 @@ maybe_add_lambda_conv_op (tree type)\n \n   add_method (type, fn, false);\n \n+  if (thisarg == NULL_TREE)\n+    {\n+      /* For static lambda, just return operator().  */\n+      if (nested)\n+\tpush_function_context ();\n+      else\n+\t/* Still increment function_depth so that we don't GC in the\n+\t   middle of an expression.  */\n+\t++function_depth;\n+\n+      /* Generate the body of the conversion op.  */\n+\n+      start_preparsed_function (convfn, NULL_TREE,\n+\t\t\t\tSF_PRE_PARSED | SF_INCLASS_INLINE);\n+      tree body = begin_function_body ();\n+      tree compound_stmt = begin_compound_stmt (0);\n+\n+      /* decl_needed_p needs to see that it's used.  */\n+      TREE_USED (callop) = 1;\n+      finish_return_stmt (decay_conversion (callop, tf_warning_or_error));\n+\n+      finish_compound_stmt (compound_stmt);\n+      finish_function_body (body);\n+\n+      fn = finish_function (/*inline_p=*/true);\n+      if (!generic_lambda_p)\n+\texpand_or_defer_fn (fn);\n+\n+      if (nested)\n+\tpop_function_context ();\n+      else\n+\t--function_depth;\n+      return;\n+    }\n+\n   /* Generic thunk code fails for varargs; we'll complain in mark_used if\n      the conversion op is used.  */\n   if (varargs_function_p (callop))"}, {"sha": "00d283fff8c1b2397d825effe78bbddba641837b", "filename": "gcc/cp/mangle.cc", "status": "modified", "additions": 14, "deletions": 53, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcp%2Fmangle.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcp%2Fmangle.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -2648,63 +2648,24 @@ write_builtin_type (tree type)\n \twrite_string (\"Dd\");\n       else if (type == dfloat128_type_node || type == fallback_dfloat128_type)\n \twrite_string (\"De\");\n+      else if (type == float16_type_node)\n+\twrite_string (\"DF16_\");\n+      else if (type == float32_type_node)\n+\twrite_string (\"DF32_\");\n+      else if (type == float64_type_node)\n+\twrite_string (\"DF64_\");\n+      else if (type == float128_type_node)\n+\twrite_string (\"DF128_\");\n+      else if (type == float32x_type_node)\n+\twrite_string (\"DF32x\");\n+      else if (type == float64x_type_node)\n+\twrite_string (\"DF64x\");\n+      else if (type == float128x_type_node)\n+\twrite_string (\"DF128x\");\n       else\n \tgcc_unreachable ();\n       break;\n \n-    case FIXED_POINT_TYPE:\n-      write_string (\"DF\");\n-      if (GET_MODE_IBIT (TYPE_MODE (type)) > 0)\n-\twrite_unsigned_number (GET_MODE_IBIT (TYPE_MODE (type)));\n-      if (type == fract_type_node\n-\t  || type == sat_fract_type_node\n-\t  || type == accum_type_node\n-\t  || type == sat_accum_type_node)\n-\twrite_char ('i');\n-      else if (type == unsigned_fract_type_node\n-\t       || type == sat_unsigned_fract_type_node\n-\t       || type == unsigned_accum_type_node\n-\t       || type == sat_unsigned_accum_type_node)\n-\twrite_char ('j');\n-      else if (type == short_fract_type_node\n-\t       || type == sat_short_fract_type_node\n-\t       || type == short_accum_type_node\n-\t       || type == sat_short_accum_type_node)\n-\twrite_char ('s');\n-      else if (type == unsigned_short_fract_type_node\n-\t       || type == sat_unsigned_short_fract_type_node\n-\t       || type == unsigned_short_accum_type_node\n-\t       || type == sat_unsigned_short_accum_type_node)\n-\twrite_char ('t');\n-      else if (type == long_fract_type_node\n-\t       || type == sat_long_fract_type_node\n-\t       || type == long_accum_type_node\n-\t       || type == sat_long_accum_type_node)\n-\twrite_char ('l');\n-      else if (type == unsigned_long_fract_type_node\n-\t       || type == sat_unsigned_long_fract_type_node\n-\t       || type == unsigned_long_accum_type_node\n-\t       || type == sat_unsigned_long_accum_type_node)\n-\twrite_char ('m');\n-      else if (type == long_long_fract_type_node\n-\t       || type == sat_long_long_fract_type_node\n-\t       || type == long_long_accum_type_node\n-\t       || type == sat_long_long_accum_type_node)\n-\twrite_char ('x');\n-      else if (type == unsigned_long_long_fract_type_node\n-\t       || type == sat_unsigned_long_long_fract_type_node\n-\t       || type == unsigned_long_long_accum_type_node\n-\t       || type == sat_unsigned_long_long_accum_type_node)\n-\twrite_char ('y');\n-      else\n-\tsorry (\"mangling unknown fixed point type\");\n-      write_unsigned_number (GET_MODE_FBIT (TYPE_MODE (type)));\n-      if (TYPE_SATURATING (type))\n-\twrite_char ('s');\n-      else\n-\twrite_char ('n');\n-      break;\n-\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "9f917f13134a88e8d78fff28c1b133e2d1a3a666", "filename": "gcc/cp/method.cc", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcp%2Fmethod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcp%2Fmethod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -2236,6 +2236,19 @@ ref_xes_from_temporary (tree to, tree from, bool direct_init_p)\n   return ref_conv_binds_directly (to, val, direct_init_p).is_false ();\n }\n \n+/* Worker for is_{,nothrow_}convertible.  Attempt to perform an implicit\n+   conversion from FROM to TO and return the result.  */\n+\n+static tree\n+is_convertible_helper (tree from, tree to)\n+{\n+  if (VOID_TYPE_P (from) && VOID_TYPE_P (to))\n+    return integer_one_node;\n+  cp_unevaluated u;\n+  tree expr = build_stub_object (from);\n+  return perform_implicit_conversion (to, expr, tf_none);\n+}\n+\n /* Return true if FROM can be converted to TO using implicit conversions,\n    or both FROM and TO are possibly cv-qualified void.  NB: This doesn't\n    implement the \"Access checks are performed as if from a context unrelated\n@@ -2244,10 +2257,7 @@ ref_xes_from_temporary (tree to, tree from, bool direct_init_p)\n bool\n is_convertible (tree from, tree to)\n {\n-  if (VOID_TYPE_P (from) && VOID_TYPE_P (to))\n-    return true;\n-  tree expr = build_stub_object (from);\n-  expr = perform_implicit_conversion (to, expr, tf_none);\n+  tree expr = is_convertible_helper (from, to);\n   if (expr == error_mark_node)\n     return false;\n   return !!expr;\n@@ -2258,10 +2268,7 @@ is_convertible (tree from, tree to)\n bool\n is_nothrow_convertible (tree from, tree to)\n {\n-  if (VOID_TYPE_P (from) && VOID_TYPE_P (to))\n-    return true;\n-  tree expr = build_stub_object (from);\n-  expr = perform_implicit_conversion (to, expr, tf_none);\n+  tree expr = is_convertible_helper (from, to);\n   if (expr == NULL_TREE || expr == error_mark_node)\n     return false;\n   return expr_noexcept_p (expr, tf_none);"}, {"sha": "7496df5e843cdc903140d5d30acbbec53015ef28", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -8185,13 +8185,18 @@ trees_in::decl_value ()\n \t/* Set the TEMPLATE_DECL's type.  */\n \tTREE_TYPE (decl) = TREE_TYPE (inner);\n \n-      if (mk & MK_template_mask\n-\t  || mk == MK_partial)\n+      /* Add to specialization tables now that constraints etc are\n+\t added.  */\n+      if (mk == MK_partial)\n \t{\n-\t  /* Add to specialization tables now that constraints etc are\n-\t     added.  */\n-\t  bool is_type = mk == MK_partial || !(mk & MK_tmpl_decl_mask);\n-\n+\t  bool is_type = TREE_CODE (inner) == TYPE_DECL;\n+\t  spec.spec = is_type ? type : inner;\n+\t  add_mergeable_specialization (!is_type, false,\n+\t\t\t\t\t&spec, decl, spec_flags);\n+\t}\n+      else if (mk & MK_template_mask)\n+\t{\n+\t  bool is_type = !(mk & MK_tmpl_decl_mask);\n \t  spec.spec = is_type ? type : mk & MK_tmpl_tmpl_mask ? inner : decl;\n \t  add_mergeable_specialization (!is_type,\n \t\t\t\t\t!is_type && mk & MK_tmpl_alias_mask,"}, {"sha": "d501178634a01ed997f111d620fa09f66b8970b0", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 415, "deletions": 56, "changes": 471, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -46,6 +46,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cp-name-hint.h\"\n #include \"memmodel.h\"\n #include \"c-family/known-headers.h\"\n+#include \"bitmap.h\"\n \n \f\n /* The lexer.  */\n@@ -1129,6 +1130,7 @@ cp_keyword_starts_decl_specifier_p (enum rid keyword)\n     case RID_UNSIGNED:\n     case RID_FLOAT:\n     case RID_DOUBLE:\n+    CASE_RID_FLOATN_NX:\n     case RID_VOID:\n       /* CV qualifiers.  */\n     case RID_CONST:\n@@ -1994,7 +1996,7 @@ enum\n      constexpr.  */\n   CP_PARSER_FLAGS_ONLY_TYPE_OR_CONSTEXPR = 0x8,\n   /* When parsing a decl-specifier-seq, only allow mutable, constexpr or\n-     for C++20 consteval.  */\n+     for C++20 consteval or for C++23 static.  */\n   CP_PARSER_FLAGS_ONLY_MUTABLE_OR_CONSTEXPR = 0x10,\n   /* When parsing a decl-specifier-seq, allow missing typename.  */\n   CP_PARSER_FLAGS_TYPENAME_OPTIONAL = 0x20,\n@@ -11728,9 +11730,18 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n     {\n       LAMBDA_EXPR_MUTABLE_P (lambda_expr) = 1;\n       quals = TYPE_UNQUALIFIED;\n-      if (lambda_specs.conflicting_specifiers_p)\n+    }\n+  else if (lambda_specs.storage_class == sc_static)\n+    {\n+      if (LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda_expr) != CPLD_NONE\n+\t  || LAMBDA_EXPR_CAPTURE_LIST (lambda_expr))\n \terror_at (lambda_specs.locations[ds_storage_class],\n-\t\t  \"duplicate %<mutable%>\");\n+\t\t  \"%<static%> lambda specifier with lambda capture\");\n+      else\n+\t{\n+\t  LAMBDA_EXPR_STATIC_P (lambda_expr) = 1;\n+\t  quals = TYPE_UNQUALIFIED;\n+\t}\n     }\n \n   tx_qual = cp_parser_tx_qualifier_opt (parser);\n@@ -11817,6 +11828,12 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n     if (lambda_specs.locations[ds_consteval])\n       return_type_specs.locations[ds_consteval]\n \t= lambda_specs.locations[ds_consteval];\n+    if (LAMBDA_EXPR_STATIC_P (lambda_expr))\n+      {\n+\treturn_type_specs.storage_class = sc_static;\n+\treturn_type_specs.locations[ds_storage_class]\n+\t  = lambda_specs.locations[ds_storage_class];\n+      }\n \n     p = obstack_alloc (&declarator_obstack, 0);\n \n@@ -11840,8 +11857,9 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n       {\n \tDECL_INITIALIZED_IN_CLASS_P (fco) = 1;\n \tDECL_ARTIFICIAL (fco) = 1;\n-\t/* Give the object parameter a different name.  */\n-\tDECL_NAME (DECL_ARGUMENTS (fco)) = closure_identifier;\n+\tif (!LAMBDA_EXPR_STATIC_P (lambda_expr))\n+\t  /* Give the object parameter a different name.  */\n+\t  DECL_NAME (DECL_ARGUMENTS (fco)) = closure_identifier;\n \tDECL_SET_LAMBDA_FUNCTION (fco, true);\n       }\n     if (template_param_list)\n@@ -15730,6 +15748,13 @@ cp_parser_decomposition_declaration (cp_parser *parser,\n   return decl;\n }\n \n+/* Names of storage classes.  */\n+\n+static const char *const\n+cp_storage_class_name[] = {\n+  \"\", \"auto\", \"register\", \"static\", \"extern\", \"mutable\"\n+};\n+\n /* Parse a decl-specifier-seq.\n \n    decl-specifier-seq:\n@@ -15951,8 +15976,18 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \t     may as well commit at this point.  */\n \t  cp_parser_commit_to_tentative_parse (parser);\n \n-          if (decl_specs->storage_class != sc_none)\n-            decl_specs->conflicting_specifiers_p = true;\n+\t  if (decl_specs->storage_class != sc_none)\n+\t    {\n+\t      if (decl_specs->conflicting_specifiers_p)\n+\t\tbreak;\n+\t      gcc_rich_location richloc (token->location);\n+\t      location_t oloc = decl_specs->locations[ds_storage_class];\n+\t      richloc.add_location_if_nearby (oloc);\n+\t      error_at (&richloc,\n+\t\t\t\"%<typedef%> specifier conflicts with %qs\",\n+\t\t\tcp_storage_class_name[decl_specs->storage_class]);\n+\t      decl_specs->conflicting_specifiers_p = true;\n+\t    }\n \t  break;\n \n \t  /* storage-class-specifier:\n@@ -16018,8 +16053,15 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \t  && token->keyword != RID_MUTABLE\n \t  && token->keyword != RID_CONSTEXPR\n \t  && token->keyword != RID_CONSTEVAL)\n-\terror_at (token->location, \"%qD invalid in lambda\",\n-\t\t  ridpointers[token->keyword]);\n+\t{\n+\t  if (token->keyword != RID_STATIC)\n+\t    error_at (token->location, \"%qD invalid in lambda\",\n+\t\t      ridpointers[token->keyword]);\n+\t  else if (cxx_dialect < cxx23)\n+\t    pedwarn (token->location, OPT_Wc__23_extensions,\n+\t\t     \"%qD only valid in lambda with %<-std=c++23%> or \"\n+\t\t     \"%<-std=gnu++23%>\", ridpointers[token->keyword]);\n+\t}\n \n       if (ds != ds_last)\n \tset_and_check_decl_spec_loc (decl_specs, ds, token);\n@@ -19716,6 +19758,14 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n     case RID_DOUBLE:\n       type = double_type_node;\n       break;\n+    CASE_RID_FLOATN_NX:\n+      type = FLOATN_NX_TYPE_NODE (token->keyword - RID_FLOATN_NX_FIRST);\n+      if (type == NULL_TREE)\n+\terror (\"%<_Float%d%s%> is not supported on this target\",\n+\t       floatn_nx_types[token->keyword - RID_FLOATN_NX_FIRST].n,\n+\t       floatn_nx_types[token->keyword - RID_FLOATN_NX_FIRST].extended\n+\t       ? \"x\" : \"\");\n+      break;\n     case RID_VOID:\n       type = void_type_node;\n       break;\n@@ -32836,26 +32886,6 @@ cp_parser_set_storage_class (cp_parser *parser,\n {\n   cp_storage_class storage_class;\n \n-  if (parser->in_unbraced_linkage_specification_p)\n-    {\n-      error_at (token->location, \"invalid use of %qD in linkage specification\",\n-\t\tridpointers[keyword]);\n-      return;\n-    }\n-  else if (decl_specs->storage_class != sc_none)\n-    {\n-      decl_specs->conflicting_specifiers_p = true;\n-      return;\n-    }\n-\n-  if ((keyword == RID_EXTERN || keyword == RID_STATIC)\n-      && decl_spec_seq_has_spec_p (decl_specs, ds_thread)\n-      && decl_specs->gnu_thread_keyword_p)\n-    {\n-      pedwarn (decl_specs->locations[ds_thread], 0,\n-\t\t\"%<__thread%> before %qD\", ridpointers[keyword]);\n-    }\n-\n   switch (keyword)\n     {\n     case RID_AUTO:\n@@ -32876,15 +32906,55 @@ cp_parser_set_storage_class (cp_parser *parser,\n     default:\n       gcc_unreachable ();\n     }\n+\n+  if (parser->in_unbraced_linkage_specification_p)\n+    {\n+      error_at (token->location, \"invalid use of %qD in linkage specification\",\n+\t\tridpointers[keyword]);\n+      return;\n+    }\n+  else if (decl_specs->storage_class != sc_none)\n+    {\n+      if (decl_specs->conflicting_specifiers_p)\n+\treturn;\n+      gcc_rich_location richloc (token->location);\n+      richloc.add_location_if_nearby (decl_specs->locations[ds_storage_class]);\n+      if (decl_specs->storage_class == storage_class)\n+\terror_at (&richloc, \"duplicate %qD specifier\", ridpointers[keyword]);\n+      else\n+\terror_at (&richloc,\n+\t\t  \"%qD specifier conflicts with %qs\",\n+\t\t  ridpointers[keyword],\n+\t\t  cp_storage_class_name[decl_specs->storage_class]);\n+      decl_specs->conflicting_specifiers_p = true;\n+      return;\n+    }\n+\n+  if ((keyword == RID_EXTERN || keyword == RID_STATIC)\n+      && decl_spec_seq_has_spec_p (decl_specs, ds_thread)\n+      && decl_specs->gnu_thread_keyword_p)\n+    {\n+      pedwarn (decl_specs->locations[ds_thread], 0,\n+\t\t\"%<__thread%> before %qD\", ridpointers[keyword]);\n+    }\n+\n   decl_specs->storage_class = storage_class;\n   set_and_check_decl_spec_loc (decl_specs, ds_storage_class, token);\n \n   /* A storage class specifier cannot be applied alongside a typedef\n      specifier. If there is a typedef specifier present then set\n      conflicting_specifiers_p which will trigger an error later\n      on in grokdeclarator. */\n-  if (decl_spec_seq_has_spec_p (decl_specs, ds_typedef))\n-    decl_specs->conflicting_specifiers_p = true;\n+  if (decl_spec_seq_has_spec_p (decl_specs, ds_typedef)\n+      && !decl_specs->conflicting_specifiers_p)\n+    {\n+      gcc_rich_location richloc (token->location);\n+      richloc.add_location_if_nearby (decl_specs->locations[ds_typedef]);\n+      error_at (&richloc,\n+\t\t\"%qD specifier conflicts with %<typedef%>\",\n+\t\tridpointers[keyword]);\n+      decl_specs->conflicting_specifiers_p = true;\n+    }\n }\n \n /* Update the DECL_SPECS to reflect the TYPE_SPEC.  If TYPE_DEFINITION_P\n@@ -46018,6 +46088,218 @@ cp_parser_omp_context_selector_specification (cp_parser *parser,\n   return nreverse (ret);\n }\n \n+/* Assumption clauses:\n+   OpenMP 5.1\n+   absent (directive-name-list)\n+   contains (directive-name-list)\n+   holds (expression)\n+   no_openmp\n+   no_openmp_routines\n+   no_parallelism  */\n+\n+static void\n+cp_parser_omp_assumption_clauses (cp_parser *parser, cp_token *pragma_tok,\n+\t\t\t\t  bool is_assume)\n+{\n+  bool first = true;\n+  bool no_openmp = false;\n+  bool no_openmp_routines = false;\n+  bool no_parallelism = false;\n+  bitmap_head absent_head, contains_head;\n+\n+  bitmap_obstack_initialize (NULL);\n+  bitmap_initialize (&absent_head, &bitmap_default_obstack);\n+  bitmap_initialize (&contains_head, &bitmap_default_obstack);\n+\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_PRAGMA_EOL))\n+    error_at (cp_lexer_peek_token (parser->lexer)->location,\n+\t      \"expected at least one assumption clause\");\n+\n+  while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL))\n+    {\n+      /* For now only in C++ attributes, do it always for OpenMP 5.1.  */\n+      if ((!first || parser->lexer->in_omp_attribute_pragma)\n+\t  && cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n+\t  && cp_lexer_nth_token_is (parser->lexer, 2, CPP_NAME))\n+\tcp_lexer_consume_token (parser->lexer);\n+\n+      first = false;\n+\n+      if (!cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+\tbreak;\n+\n+      const char *p\n+\t= IDENTIFIER_POINTER (cp_lexer_peek_token (parser->lexer)->u.value);\n+      location_t cloc = cp_lexer_peek_token (parser->lexer)->location;\n+\n+      if (!strcmp (p, \"no_openmp\"))\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  if (no_openmp)\n+\t    error_at (cloc, \"too many %qs clauses\", \"no_openmp\");\n+\t  no_openmp = true;\n+\t}\n+      else if (!strcmp (p, \"no_openmp_routines\"))\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  if (no_openmp_routines)\n+\t    error_at (cloc, \"too many %qs clauses\", \"no_openmp_routines\");\n+\t  no_openmp_routines = true;\n+\t}\n+      else if (!strcmp (p, \"no_parallelism\"))\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  if (no_parallelism)\n+\t    error_at (cloc, \"too many %qs clauses\", \"no_parallelism\");\n+\t  no_parallelism = true;\n+\t}\n+      else if (!strcmp (p, \"holds\"))\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  matching_parens parens;\n+\t  if (parens.require_open (parser))\n+\t    {\n+\t      tree t = cp_parser_assignment_expression (parser);\n+\t      if (!type_dependent_expression_p (t))\n+\t\tt = contextual_conv_bool (t, tf_warning_or_error);\n+\t      if (is_assume)\n+\t\t{\n+\t\t  /* FIXME: Emit .ASSUME (t) call here.  */\n+\t\t  (void) t;\n+\t\t}\n+\t      if (!parens.require_close (parser))\n+\t\tcp_parser_skip_to_closing_parenthesis (parser,\n+\t\t\t\t\t\t       /*recovering=*/true,\n+\t\t\t\t\t\t       /*or_comma=*/false,\n+\t\t\t\t\t\t       /*consume_paren=*/true);\n+\t    }\n+\t}\n+      else if (!strcmp (p, \"absent\") || !strcmp (p, \"contains\"))\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  matching_parens parens;\n+\t  if (parens.require_open (parser))\n+\t    {\n+\t      do\n+\t\t{\n+\t\t  const char *directive[3] = {};\n+\t\t  int i;\n+\t\t  location_t dloc\n+\t\t    = cp_lexer_peek_token (parser->lexer)->location;\n+\t\t  for (i = 0; i < 3; i++)\n+\t\t    {\n+\t\t      tree id;\n+\t\t      if (cp_lexer_nth_token_is (parser->lexer, i + 1, CPP_NAME))\n+\t\t\tid = cp_lexer_peek_nth_token (parser->lexer,\n+\t\t\t\t\t\t      i + 1)->u.value;\n+\t\t      else if (cp_lexer_nth_token_is (parser->lexer, i + 1,\n+\t\t\t\t\t\t      CPP_KEYWORD))\n+\t\t\t{\n+\t\t\t  enum rid rid\n+\t\t\t    = cp_lexer_peek_nth_token (parser->lexer,\n+\t\t\t\t\t\t       i + 1)->keyword;\n+\t\t\t  id = ridpointers[rid];\n+\t\t\t}\n+\t\t      else\n+\t\t\tbreak;\n+\t\t      directive[i] = IDENTIFIER_POINTER (id);\n+\t\t    }\n+\t\t  if (i == 0)\n+\t\t    error_at (dloc, \"expected directive name\");\n+\t\t  else\n+\t\t    {\n+\t\t      const struct c_omp_directive *dir\n+\t\t\t= c_omp_categorize_directive (directive[0],\n+\t\t\t\t\t\t      directive[1],\n+\t\t\t\t\t\t      directive[2]);\n+\t\t      if (dir == NULL\n+\t\t\t  || dir->kind == C_OMP_DIR_DECLARATIVE\n+\t\t\t  || dir->kind == C_OMP_DIR_INFORMATIONAL\n+\t\t\t  || dir->id == PRAGMA_OMP_END\n+\t\t\t  || (!dir->second && directive[1])\n+\t\t\t  || (!dir->third && directive[2]))\n+\t\t\terror_at (dloc, \"unknown OpenMP directive name in \"\n+\t\t\t\t\t\"%qs clause argument\", p);\n+\t\t      else\n+\t\t\t{\n+\t\t\t  int id = dir - c_omp_directives;\n+\t\t\t  if (bitmap_bit_p (p[0] == 'a' ? &contains_head\n+\t\t\t\t\t\t\t: &absent_head, id))\n+\t\t\t    error_at (dloc, \"%<%s%s%s%s%s%> directive \"\n+\t\t\t\t\t    \"mentioned in both %<absent%> and \"\n+\t\t\t\t\t    \"%<contains%> clauses\",\n+\t\t\t\t      directive[0],\n+\t\t\t\t      directive[1] ? \" \" : \"\",\n+\t\t\t\t      directive[1] ? directive[1] : \"\",\n+\t\t\t\t      directive[2] ? \" \" : \"\",\n+\t\t\t\t      directive[2] ? directive[2] : \"\");\n+\t\t\t  else if (!bitmap_set_bit (p[0] == 'a'\n+\t\t\t\t\t\t    ? &absent_head\n+\t\t\t\t\t\t    : &contains_head, id))\n+\t\t\t    error_at (dloc, \"%<%s%s%s%s%s%> directive \"\n+\t\t\t\t\t    \"mentioned multiple times in %qs \"\n+\t\t\t\t\t    \"clauses\",\n+\t\t\t\t      directive[0],\n+\t\t\t\t      directive[1] ? \" \" : \"\",\n+\t\t\t\t      directive[1] ? directive[1] : \"\",\n+\t\t\t\t      directive[2] ? \" \" : \"\",\n+\t\t\t\t      directive[2] ? directive[2] : \"\", p);\n+\t\t\t}\n+\t\t      for (; i; --i)\n+\t\t\tcp_lexer_consume_token (parser->lexer);\n+\t\t    }\n+\t\t  if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+\t\t    cp_lexer_consume_token (parser->lexer);\n+\t\t  else\n+\t\t    break;\n+\t\t}\n+\t      while (1);\n+\t      if (!parens.require_close (parser))\n+\t\tcp_parser_skip_to_closing_parenthesis (parser,\n+\t\t\t\t\t\t       /*recovering=*/true,\n+\t\t\t\t\t\t       /*or_comma=*/false,\n+\t\t\t\t\t\t       /*consume_paren=*/true);\n+\t    }\n+\t}\n+      else if (startswith (p, \"ext_\"))\n+\t{\n+\t  warning_at (cloc, 0, \"unknown assumption clause %qs\", p);\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n+\t    for (size_t n = cp_parser_skip_balanced_tokens (parser, 1) - 1;\n+\t\t n; --n)\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t}\n+      else\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  error_at (cloc, \"expected assumption clause\");\n+\t  break;\n+\t}\n+    }\n+  cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+}\n+\n+/* OpenMP 5.1\n+   # pragma omp assume clauses[optseq] new-line  */\n+\n+static void\n+cp_parser_omp_assume (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n+{\n+  cp_parser_omp_assumption_clauses (parser, pragma_tok, true);\n+  add_stmt (cp_parser_omp_structured_block (parser, if_p));\n+}\n+\n+/* OpenMP 5.1\n+   # pragma omp assumes clauses[optseq] new-line  */\n+\n+static bool\n+cp_parser_omp_assumes (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  cp_parser_omp_assumption_clauses (parser, pragma_tok, false);\n+  return false;\n+}\n+\n /* Finalize #pragma omp declare variant after a fndecl has been parsed, and put\n    that into \"omp declare variant base\" attribute.  */\n \n@@ -46467,8 +46749,41 @@ cp_parser_omp_declare_target (cp_parser *parser, cp_token *pragma_tok)\n \t\t\"directive with only %<device_type%> clauses ignored\");\n }\n \n+/* OpenMP 5.1\n+   #pragma omp begin assumes clauses[optseq] new-line  */\n+\n static void\n-cp_parser_omp_end_declare_target (cp_parser *parser, cp_token *pragma_tok)\n+cp_parser_omp_begin (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  const char *p = \"\";\n+  bool in_omp_attribute_pragma = parser->lexer->in_omp_attribute_pragma;\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+    {\n+      tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+      p = IDENTIFIER_POINTER (id);\n+    }\n+  if (strcmp (p, \"assumes\") == 0)\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+      cp_parser_omp_assumption_clauses (parser, pragma_tok, false);\n+      struct omp_begin_assumes_data a = { in_omp_attribute_pragma };\n+      vec_safe_push (scope_chain->omp_begin_assumes, a);\n+    }\n+  else\n+    {\n+      cp_parser_error (parser, \"expected %<assumes%>\");\n+      cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+    }\n+}\n+\n+/* OpenMP 4.0:\n+   # pragma omp end declare target new-line\n+\n+   OpenMP 5.1:\n+   # pragma omp end assumes new-line  */\n+\n+static void\n+cp_parser_omp_end (cp_parser *parser, cp_token *pragma_tok)\n {\n   const char *p = \"\";\n   bool in_omp_attribute_pragma = parser->lexer->in_omp_attribute_pragma;\n@@ -46494,33 +46809,58 @@ cp_parser_omp_end_declare_target (cp_parser *parser, cp_token *pragma_tok)\n \t  cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n \t  return;\n \t}\n+      cp_parser_require_pragma_eol (parser, pragma_tok);\n+      if (!vec_safe_length (scope_chain->omp_declare_target_attribute))\n+\terror_at (pragma_tok->location,\n+\t\t  \"%<#pragma omp end declare target%> without corresponding \"\n+\t\t  \"%<#pragma omp declare target%>\");\n+      else\n+\t{\n+\t  omp_declare_target_attr\n+\t    a = scope_chain->omp_declare_target_attribute->pop ();\n+\t  if (a.attr_syntax != in_omp_attribute_pragma)\n+\t    {\n+\t      if (a.attr_syntax)\n+\t\terror_at (pragma_tok->location,\n+\t\t\t  \"%<declare target%> in attribute syntax terminated \"\n+\t\t\t  \"with %<end declare target%> in pragma syntax\");\n+\t      else\n+\t\terror_at (pragma_tok->location,\n+\t\t\t  \"%<declare target%> in pragma syntax terminated \"\n+\t\t\t  \"with %<end declare target%> in attribute syntax\");\n+\t    }\n+\t}\n     }\n-  else\n+  else if (strcmp (p, \"assumes\") == 0)\n     {\n-      cp_parser_error (parser, \"expected %<declare%>\");\n-      cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n-      return;\n+      cp_lexer_consume_token (parser->lexer);\n+      cp_parser_require_pragma_eol (parser, pragma_tok);\n+      if (!vec_safe_length (scope_chain->omp_begin_assumes))\n+\terror_at (pragma_tok->location,\n+\t\t  \"%<#pragma omp end assumes%> without corresponding \"\n+\t\t  \"%<#pragma omp begin assumes%>\");\n+      else\n+\t{\n+\t  omp_begin_assumes_data\n+\t    a = scope_chain->omp_begin_assumes->pop ();\n+\t  if (a.attr_syntax != in_omp_attribute_pragma)\n+\t    {\n+\t      if (a.attr_syntax)\n+\t\terror_at (pragma_tok->location,\n+\t\t\t  \"%<begin assumes%> in attribute syntax terminated \"\n+\t\t\t  \"with %<end assumes%> in pragma syntax\");\n+\t      else\n+\t\terror_at (pragma_tok->location,\n+\t\t\t  \"%<begin assumes%> in pragma syntax terminated \"\n+\t\t\t  \"with %<end assumes%> in attribute syntax\");\n+\t    }\n+\t}\n     }\n-  cp_parser_require_pragma_eol (parser, pragma_tok);\n-  if (!vec_safe_length (scope_chain->omp_declare_target_attribute))\n-    error_at (pragma_tok->location,\n-\t      \"%<#pragma omp end declare target%> without corresponding \"\n-\t      \"%<#pragma omp declare target%>\");\n   else\n     {\n-      omp_declare_target_attr\n-\ta = scope_chain->omp_declare_target_attribute->pop ();\n-      if (a.attr_syntax != in_omp_attribute_pragma)\n-\t{\n-\t  if (a.attr_syntax)\n-\t    error_at (pragma_tok->location,\n-\t\t      \"%<declare target%> in attribute syntax terminated \"\n-\t\t      \"with %<end declare target%> in pragma syntax\");\n-\t  else\n-\t    error_at (pragma_tok->location,\n-\t\t      \"%<declare target%> in pragma syntax terminated \"\n-\t\t      \"with %<end declare target%> in attribute syntax\");\n-\t}\n+      cp_parser_error (parser, \"expected %<declare%> or %<assumes%>\");\n+      cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+      return;\n     }\n }\n \n@@ -47803,6 +48143,9 @@ cp_parser_omp_construct (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n       stmt = cp_parser_omp_teams (parser, pragma_tok, p_name, mask, NULL,\n \t\t\t\t  if_p);\n       break;\n+    case PRAGMA_OMP_ASSUME:\n+      cp_parser_omp_assume (parser, pragma_tok, if_p);\n+      return;\n     default:\n       gcc_unreachable ();\n     }\n@@ -48406,6 +48749,7 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)\n     case PRAGMA_OACC_LOOP:\n     case PRAGMA_OACC_PARALLEL:\n     case PRAGMA_OACC_SERIAL:\n+    case PRAGMA_OMP_ASSUME:\n     case PRAGMA_OMP_ATOMIC:\n     case PRAGMA_OMP_CRITICAL:\n     case PRAGMA_OMP_DISTRIBUTE:\n@@ -48440,6 +48784,17 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)\n \t}\n       return cp_parser_omp_requires (parser, pragma_tok);\n \n+    case PRAGMA_OMP_ASSUMES:\n+      if (context != pragma_external)\n+\t{\n+\t  error_at (pragma_tok->location,\n+\t\t    \"%<#pragma omp assumes%> may only be used at file or \"\n+\t\t    \"namespace scope\");\n+\t  ret = true;\n+\t  break;\n+\t}\n+      return cp_parser_omp_assumes (parser, pragma_tok);\n+\n     case PRAGMA_OMP_NOTHING:\n       cp_parser_omp_nothing (parser, pragma_tok);\n       return false;\n@@ -48463,8 +48818,12 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)\n       pop_omp_privatization_clauses (stmt);\n       return ret;\n \n-    case PRAGMA_OMP_END_DECLARE_TARGET:\n-      cp_parser_omp_end_declare_target (parser, pragma_tok);\n+    case PRAGMA_OMP_BEGIN:\n+      cp_parser_omp_begin (parser, pragma_tok);\n+      return false;\n+\n+    case PRAGMA_OMP_END:\n+      cp_parser_omp_end (parser, pragma_tok);\n       return false;\n \n     case PRAGMA_OMP_SCAN:"}, {"sha": "1c1e5735743b23406e86e8526a2d82944b2cb3b8", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -11945,6 +11945,7 @@ apply_late_template_attributes (tree *decl_p, tree attributes, int attr_flags,\n   auto o3 = make_temp_override (current_target_pragma, NULL_TREE);\n   auto o4 = make_temp_override (scope_chain->omp_declare_target_attribute,\n \t\t\t\tNULL);\n+  auto o5 = make_temp_override (scope_chain->omp_begin_assumes, NULL);\n \n   cplus_decl_attributes (decl_p, late_attrs, attr_flags);\n \n@@ -31010,7 +31011,7 @@ add_mergeable_specialization (bool decl_p, bool alias_p, spec_entry *elt,\n       /* A partial specialization.  */\n       tree cons = tree_cons (elt->args, decl,\n \t\t\t     DECL_TEMPLATE_SPECIALIZATIONS (elt->tmpl));\n-      TREE_TYPE (cons) = elt->spec;\n+      TREE_TYPE (cons) = decl_p ? TREE_TYPE (elt->spec) : elt->spec;\n       DECL_TEMPLATE_SPECIALIZATIONS (elt->tmpl) = cons;\n     }\n }"}, {"sha": "e8cd50558d6fcb3a3bb37dd950697056947c9398", "filename": "gcc/cp/semantics.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcp%2Fsemantics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcp%2Fsemantics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -3363,6 +3363,13 @@ finish_translation_unit (void)\n \t       \"%<#pragma omp end declare target%>\");\n       vec_safe_truncate (scope_chain->omp_declare_target_attribute, 0);\n     }\n+  if (vec_safe_length (scope_chain->omp_begin_assumes))\n+    {\n+      if (!errorcount)\n+\terror (\"%<#pragma omp begin assumes%> without corresponding \"\n+\t       \"%<#pragma omp end assumes%>\");\n+      vec_safe_truncate (scope_chain->omp_begin_assumes, 0);\n+    }\n }\n \n /* Finish a template type parameter, specified as AGGR IDENTIFIER."}, {"sha": "4854b98376533338489ed57769cc3cb487a4c50b", "filename": "gcc/cp/typeck.cc", "status": "modified", "additions": 171, "deletions": 1, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcp%2Ftypeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcp%2Ftypeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -267,6 +267,133 @@ merge_type_attributes_from (tree type, tree other_type)\n   return cp_build_type_attribute_variant (type, attrs);\n }\n \n+/* Compare floating point conversion ranks and subranks of T1 and T2\n+   types.  If T1 and T2 have unordered conversion ranks, return 3.\n+   If T1 has greater conversion rank than T2, return 2.\n+   If T2 has greater conversion rank than T1, return -2.\n+   If T1 has equal conversion rank as T2, return -1, 0 or 1 depending\n+   on if T1 has smaller, equal or greater conversion subrank than\n+   T2.  */\n+\n+int\n+cp_compare_floating_point_conversion_ranks (tree t1, tree t2)\n+{\n+  tree mv1 = TYPE_MAIN_VARIANT (t1);\n+  tree mv2 = TYPE_MAIN_VARIANT (t2);\n+  int extended1 = 0;\n+  int extended2 = 0;\n+\n+  if (mv1 == mv2)\n+    return 0;\n+\n+  for (int i = 0; i < NUM_FLOATN_NX_TYPES; ++i)\n+    {\n+      if (mv1 == FLOATN_NX_TYPE_NODE (i))\n+\textended1 = i + 1;\n+      if (mv2 == FLOATN_NX_TYPE_NODE (i))\n+\textended2 = i + 1;\n+    }\n+  if (extended2 && !extended1)\n+    {\n+      int ret = cp_compare_floating_point_conversion_ranks (t2, t1);\n+      return ret == 3 ? 3 : -ret;\n+    }\n+\n+  const struct real_format *fmt1 = REAL_MODE_FORMAT (TYPE_MODE (t1));\n+  const struct real_format *fmt2 = REAL_MODE_FORMAT (TYPE_MODE (t2));\n+  gcc_assert (fmt1->b == 2 && fmt2->b == 2);\n+  /* For {ibm,mips}_extended_format formats, the type has variable\n+     precision up to ~2150 bits when the first double is around maximum\n+     representable double and second double is subnormal minimum.\n+     So, e.g. for __ibm128 vs. std::float128_t, they have unordered\n+     ranks.  */\n+  int p1 = (MODE_COMPOSITE_P (TYPE_MODE (t1))\n+\t    ? fmt1->emax - fmt1->emin + fmt1->p - 1 : fmt1->p);\n+  int p2 = (MODE_COMPOSITE_P (TYPE_MODE (t2))\n+\t    ? fmt2->emax - fmt2->emin + fmt2->p - 1 : fmt2->p);\n+  /* The rank of a floating point type T is greater than the rank of\n+     any floating-point type whose set of values is a proper subset\n+     of the set of values of T.  */\n+  if ((p1 > p2 && fmt1->emax >= fmt2->emax)\n+       || (p1 == p2 && fmt1->emax > fmt2->emax))\n+    return 2;\n+  if ((p1 < p2 && fmt1->emax <= fmt2->emax)\n+       || (p1 == p2 && fmt1->emax < fmt2->emax))\n+    return -2;\n+  if ((p1 > p2 && fmt1->emax < fmt2->emax)\n+       || (p1 < p2 && fmt1->emax > fmt2->emax))\n+    return 3;\n+  if (!extended1 && !extended2)\n+    {\n+      /* The rank of long double is greater than the rank of double, which\n+\t is greater than the rank of float.  */\n+      if (t1 == long_double_type_node)\n+\treturn 2;\n+      else if (t2 == long_double_type_node)\n+\treturn -2;\n+      if (t1 == double_type_node)\n+\treturn 2;\n+      else if (t2 == double_type_node)\n+\treturn -2;\n+      if (t1 == float_type_node)\n+\treturn 2;\n+      else if (t2 == float_type_node)\n+\treturn -2;\n+      return 0;\n+    }\n+  /* Two extended floating-point types with the same set of values have equal\n+     ranks.  */\n+  if (extended1 && extended2)\n+    {\n+      if ((extended1 <= NUM_FLOATN_TYPES) == (extended2 <= NUM_FLOATN_TYPES))\n+\t{\n+\t  /* Prefer higher extendedN value.  */\n+\t  if (extended1 > extended2)\n+\t    return 1;\n+\t  else if (extended1 < extended2)\n+\t    return -1;\n+\t  else\n+\t    return 0;\n+\t}\n+      else if (extended1 <= NUM_FLOATN_TYPES)\n+\t/* Prefer _FloatN type over _FloatMx type.  */\n+\treturn 1;\n+      else if (extended2 <= NUM_FLOATN_TYPES)\n+\treturn -1;\n+      else\n+\treturn 0;\n+    }\n+\n+  /* gcc_assert (extended1 && !extended2);  */\n+  tree *p;\n+  int cnt = 0;\n+  for (p = &float_type_node; p <= &long_double_type_node; ++p)\n+    {\n+      const struct real_format *fmt3 = REAL_MODE_FORMAT (TYPE_MODE (*p));\n+      gcc_assert (fmt3->b == 2);\n+      int p3 = (MODE_COMPOSITE_P (TYPE_MODE (*p))\n+\t\t? fmt3->emax - fmt3->emin + fmt3->p - 1 : fmt3->p);\n+      if (p1 == p3 && fmt1->emax == fmt3->emax)\n+\t++cnt;\n+    }\n+  /* An extended floating-point type with the same set of values\n+     as exactly one cv-unqualified standard floating-point type\n+     has a rank equal to the rank of that standard floating-point\n+     type.\n+\n+     An extended floating-point type with the same set of values\n+     as more than one cv-unqualified standard floating-point type\n+     has a rank equal to the rank of double.\n+\n+     Thus, if the latter is true and t2 is long double, t2\n+     has higher rank.  */\n+  if (cnt > 1 && mv2 == long_double_type_node)\n+    return -2;\n+  /* Otherwise, they have equal rank, but extended types\n+     (other than std::bfloat16_t) have higher subrank.  */\n+  return 1;\n+}\n+\n /* Return the common type for two arithmetic types T1 and T2 under the\n    usual arithmetic conversions.  The default conversions have already\n    been applied, and enumerated types converted to their compatible\n@@ -337,6 +464,23 @@ cp_common_type (tree t1, tree t2)\n   if (code2 == REAL_TYPE && code1 != REAL_TYPE)\n     return build_type_attribute_variant (t2, attributes);\n \n+  if (code1 == REAL_TYPE\n+      && (extended_float_type_p (t1) || extended_float_type_p (t2)))\n+    {\n+      tree mv1 = TYPE_MAIN_VARIANT (t1);\n+      tree mv2 = TYPE_MAIN_VARIANT (t2);\n+      if (mv1 == mv2)\n+\treturn build_type_attribute_variant (t1, attributes);\n+\n+      int cmpret = cp_compare_floating_point_conversion_ranks (mv1, mv2);\n+      if (cmpret == 3)\n+\treturn error_mark_node;\n+      else if (cmpret >= 0)\n+\treturn build_type_attribute_variant (t1, attributes);\n+      else\n+\treturn build_type_attribute_variant (t2, attributes);\n+    }\n+\n   /* Both real or both integers; use the one with greater precision.  */\n   if (TYPE_PRECISION (t1) > TYPE_PRECISION (t2))\n     return build_type_attribute_variant (t1, attributes);\n@@ -5037,7 +5181,20 @@ cp_build_binary_op (const op_location_t &location,\n        = targetm.invalid_binary_op (code, type0, type1)))\n     {\n       if (complain & tf_error)\n-\terror (invalid_op_diag);\n+\t{\n+\t  if (code0 == REAL_TYPE\n+\t      && code1 == REAL_TYPE\n+\t      && (extended_float_type_p (type0)\n+\t\t  || extended_float_type_p (type1))\n+\t      && cp_compare_floating_point_conversion_ranks (type0,\n+\t\t\t\t\t\t\t     type1) == 3)\n+\t    {\n+\t      rich_location richloc (line_table, location);\n+\t      binary_op_error (&richloc, code, type0, type1);\n+\t    }\n+\t  else\n+\t    error (invalid_op_diag);\n+\t}\n       return error_mark_node;\n     }\n \n@@ -5907,6 +6064,19 @@ cp_build_binary_op (const op_location_t &location,\n       && (shorten || common || short_compare))\n     {\n       result_type = cp_common_type (type0, type1);\n+      if (result_type == error_mark_node\n+\t  && code0 == REAL_TYPE\n+\t  && code1 == REAL_TYPE\n+\t  && (extended_float_type_p (type0) || extended_float_type_p (type1))\n+\t  && cp_compare_floating_point_conversion_ranks (type0, type1) == 3)\n+\t{\n+\t  if (complain & tf_error)\n+\t    {\n+\t      rich_location richloc (line_table, location);\n+\t      binary_op_error (&richloc, code, type0, type1);\n+\t    }\n+\t  return error_mark_node;\n+\t}\n       if (complain & tf_warning)\n \t{\n \t  do_warn_double_promotion (result_type, type0, type1,"}, {"sha": "d5236d19b09377e017763c23a00174e170574120", "filename": "gcc/cp/typeck2.cc", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcp%2Ftypeck2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fcp%2Ftypeck2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -997,12 +997,25 @@ check_narrowing (tree type, tree init, tsubst_flags_t complain,\n   else if (TREE_CODE (ftype) == REAL_TYPE\n \t   && TREE_CODE (type) == REAL_TYPE)\n     {\n-      if ((same_type_p (ftype, long_double_type_node)\n-\t   && (same_type_p (type, double_type_node)\n-\t       || same_type_p (type, float_type_node)))\n-\t  || (same_type_p (ftype, double_type_node)\n-\t      && same_type_p (type, float_type_node))\n-\t  || (TYPE_PRECISION (type) < TYPE_PRECISION (ftype)))\n+      if ((extended_float_type_p (ftype) || extended_float_type_p (type))\n+\t  ? /* \"from a floating-point type T to another floating-point type\n+\t       whose floating-point conversion rank is neither greater than\n+\t       nor equal to that of T\".\n+\t       So, it is ok if\n+\t       cp_compare_floating_point_conversion_ranks (ftype, type)\n+\t       returns -2 (type has greater conversion rank than ftype)\n+\t       or [-1..1] (type has equal conversion rank as ftype, possibly\n+\t       different subrank.  Only do this if at least one of the\n+\t       types is extended floating-point type, otherwise keep doing\n+\t       what we did before (for the sake of non-standard\n+\t       backend types).  */\n+\t    cp_compare_floating_point_conversion_ranks (ftype, type) >= 2\n+\t  : ((same_type_p (ftype, long_double_type_node)\n+\t      && (same_type_p (type, double_type_node)\n+\t\t  || same_type_p (type, float_type_node)))\n+\t     || (same_type_p (ftype, double_type_node)\n+\t\t && same_type_p (type, float_type_node))\n+\t     || (TYPE_PRECISION (type) < TYPE_PRECISION (ftype))))\n \t{\n \t  if (TREE_CODE (init) == REAL_CST)\n \t    {\n@@ -1118,6 +1131,15 @@ array_string_literal_compatible_p (tree type, tree init)\n   if (ordinary_char_type_p (to_char_type)\n       && ordinary_char_type_p (from_char_type))\n     return true;\n+\n+  /* P2513 (C++20/C++23): \"an array of char or unsigned char may\n+     be initialized by a UTF-8 string literal, or by such a string\n+     literal enclosed in braces.\"  */\n+  if (from_char_type == char8_type_node\n+      && (to_char_type == char_type_node\n+\t  || to_char_type == unsigned_char_type_node))\n+    return true;\n+\n   return false;\n }\n "}, {"sha": "dcfca648e4413cdb310ec363f2dd49783b7e8a0a", "filename": "gcc/d/decl.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdecl.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -2335,7 +2335,7 @@ layout_struct_initializer (StructDeclaration *sd)\n {\n   StructLiteralExp *sle = StructLiteralExp::create (sd->loc, sd, NULL);\n \n-  if (!sd->fill (sd->loc, sle->elements, true))\n+  if (!sd->fill (sd->loc, *sle->elements, true))\n     gcc_unreachable ();\n \n   sle->type = sd->type;"}, {"sha": "a4c46f3306ede57b9563edfe93b88cb6026ed42b", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,4 +1,4 @@\n-817610b16d0f0f469b9fbb28c000956fb910c43f\n+4219ba670ce9ff92f3e874f0f048f2c28134c008\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "edca17fbad1edf3b0218d3d1878457db79452412", "filename": "gcc/d/dmd/aggregate.d", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Faggregate.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Faggregate.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faggregate.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -355,23 +355,22 @@ extern (C++) abstract class AggregateDeclaration : ScopeDsymbol\n      *      false if any errors occur.\n      *      Otherwise, returns true and the missing arguments will be pushed in elements[].\n      */\n-    final bool fill(const ref Loc loc, Expressions* elements, bool ctorinit)\n+    final bool fill(const ref Loc loc, ref Expressions elements, bool ctorinit)\n     {\n         //printf(\"AggregateDeclaration::fill() %s\\n\", toChars());\n         assert(sizeok == Sizeok.done);\n-        assert(elements);\n         const nfields = nonHiddenFields();\n         bool errors = false;\n \n         size_t dim = elements.dim;\n         elements.setDim(nfields);\n         foreach (size_t i; dim .. nfields)\n-            (*elements)[i] = null;\n+            elements[i] = null;\n \n         // Fill in missing any elements with default initializers\n         foreach (i; 0 .. nfields)\n         {\n-            if ((*elements)[i])\n+            if (elements[i])\n                 continue;\n \n             auto vd = fields[i];\n@@ -389,7 +388,7 @@ extern (C++) abstract class AggregateDeclaration : ScopeDsymbol\n                 if (!vd.isOverlappedWith(v2))\n                     continue;\n \n-                if ((*elements)[j])\n+                if (elements[j])\n                 {\n                     vx = null;\n                     break;\n@@ -489,10 +488,10 @@ extern (C++) abstract class AggregateDeclaration : ScopeDsymbol\n                     else\n                         e = telem.defaultInitLiteral(loc);\n                 }\n-                (*elements)[fieldi] = e;\n+                elements[fieldi] = e;\n             }\n         }\n-        foreach (e; *elements)\n+        foreach (e; elements)\n         {\n             if (e && e.op == EXP.error)\n                 return false;"}, {"sha": "f0909e3dc02aaf0ffbe8fc67cdade7d3b4e6f39a", "filename": "gcc/d/dmd/aggregate.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Faggregate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Faggregate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faggregate.h?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -125,7 +125,7 @@ class AggregateDeclaration : public ScopeDsymbol\n     bool determineSize(const Loc &loc);\n     virtual void finalizeSize() = 0;\n     uinteger_t size(const Loc &loc) override final;\n-    bool fill(const Loc &loc, Expressions *elements, bool ctorinit);\n+    bool fill(const Loc &loc, Expressions &elements, bool ctorinit);\n     Type *getType() override final;\n     bool isDeprecated() const override final; // is aggregate deprecated?\n     void setDeprecated();"}, {"sha": "3b73771ef22f4875cc638e455547b1a19753443f", "filename": "gcc/d/dmd/apply.d", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fapply.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fapply.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fapply.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -16,6 +16,7 @@ import dmd.dsymbol;\n import dmd.dsymbolsem;\n import dmd.dtemplate;\n import dmd.expression;\n+import dmd.root.array;\n import dmd.visitor;\n \n bool walkPostorder(Expression e, StoppableVisitor v)\n@@ -86,12 +87,10 @@ public:\n         return stop;\n     }\n \n-    bool doCond(Expressions* e)\n+    extern(D) bool doCond(Expression[] e)\n     {\n-        if (!e)\n-            return false;\n-        for (size_t i = 0; i < e.dim && !stop; i++)\n-            doCond((*e)[i]);\n+        for (size_t i = 0; i < e.length && !stop; i++)\n+            doCond(e[i]);\n         return stop;\n     }\n \n@@ -110,13 +109,13 @@ public:\n     override void visit(NewExp e)\n     {\n         //printf(\"NewExp::apply(): %s\\n\", toChars());\n-        doCond(e.thisexp) || doCond(e.arguments) || applyTo(e);\n+        doCond(e.thisexp) || doCond(e.arguments.peekSlice()) || applyTo(e);\n     }\n \n     override void visit(NewAnonClassExp e)\n     {\n         //printf(\"NewAnonClassExp::apply(): %s\\n\", toChars());\n-        doCond(e.thisexp) || doCond(e.arguments) || applyTo(e);\n+        doCond(e.thisexp) || doCond(e.arguments.peekSlice()) || applyTo(e);\n     }\n \n     override void visit(TypeidExp e)\n@@ -143,13 +142,13 @@ public:\n     override void visit(CallExp e)\n     {\n         //printf(\"CallExp::apply(apply_fp_t fp, void *param): %s\\n\", toChars());\n-        doCond(e.e1) || doCond(e.arguments) || applyTo(e);\n+        doCond(e.e1) || doCond(e.arguments.peekSlice()) || applyTo(e);\n     }\n \n     override void visit(ArrayExp e)\n     {\n         //printf(\"ArrayExp::apply(apply_fp_t fp, void *param): %s\\n\", toChars());\n-        doCond(e.e1) || doCond(e.arguments) || applyTo(e);\n+        doCond(e.e1) || doCond(e.arguments.peekSlice()) || applyTo(e);\n     }\n \n     override void visit(SliceExp e)\n@@ -159,12 +158,12 @@ public:\n \n     override void visit(ArrayLiteralExp e)\n     {\n-        doCond(e.basis) || doCond(e.elements) || applyTo(e);\n+        doCond(e.basis) || doCond(e.elements.peekSlice()) || applyTo(e);\n     }\n \n     override void visit(AssocArrayLiteralExp e)\n     {\n-        doCond(e.keys) || doCond(e.values) || applyTo(e);\n+        doCond(e.keys.peekSlice()) || doCond(e.values.peekSlice()) || applyTo(e);\n     }\n \n     override void visit(StructLiteralExp e)\n@@ -173,13 +172,13 @@ public:\n             return;\n         int old = e.stageflags;\n         e.stageflags |= stageApply;\n-        doCond(e.elements) || applyTo(e);\n+        doCond(e.elements.peekSlice()) || applyTo(e);\n         e.stageflags = old;\n     }\n \n     override void visit(TupleExp e)\n     {\n-        doCond(e.e0) || doCond(e.exps) || applyTo(e);\n+        doCond(e.e0) || doCond(e.exps.peekSlice()) || applyTo(e);\n     }\n \n     override void visit(CondExp e)"}, {"sha": "f07a6f44d2b681439119447d25222d76427d657d", "filename": "gcc/d/dmd/arrayop.d", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Farrayop.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Farrayop.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Farrayop.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -129,8 +129,7 @@ Expression arrayOp(BinExp e, Scope* sc)\n         return arrayOpInvalidError(e);\n \n     auto tiargs = new Objects();\n-    auto args = new Expressions();\n-    buildArrayOp(sc, e, tiargs, args);\n+    auto args = buildArrayOp(sc, e, tiargs);\n \n     import dmd.dtemplate : TemplateDeclaration;\n     __gshared TemplateDeclaration arrayOp;\n@@ -184,7 +183,7 @@ Expression arrayOp(BinAssignExp e, Scope* sc)\n  * using reverse polish notation (RPN) to encode order of operations.\n  * Encode operations as string arguments, using a \"u\" prefix for unary operations.\n  */\n-private void buildArrayOp(Scope* sc, Expression e, Objects* tiargs, Expressions* args)\n+private Expressions* buildArrayOp(Scope* sc, Expression e, Objects* tiargs)\n {\n     extern (C++) final class BuildArrayOpVisitor : Visitor\n     {\n@@ -194,11 +193,11 @@ private void buildArrayOp(Scope* sc, Expression e, Objects* tiargs, Expressions*\n         Expressions* args;\n \n     public:\n-        extern (D) this(Scope* sc, Objects* tiargs, Expressions* args)\n+        extern (D) this(Scope* sc, Objects* tiargs)\n         {\n             this.sc = sc;\n             this.tiargs = tiargs;\n-            this.args = args;\n+            this.args = new Expressions();\n         }\n \n         override void visit(Expression e)\n@@ -252,8 +251,9 @@ private void buildArrayOp(Scope* sc, Expression e, Objects* tiargs, Expressions*\n         }\n     }\n \n-    scope v = new BuildArrayOpVisitor(sc, tiargs, args);\n+    scope v = new BuildArrayOpVisitor(sc, tiargs);\n     e.accept(v);\n+    return v.args;\n }\n \n /***********************************************"}, {"sha": "3472d1ce478928d0bc274c7b8aea2d6e0b76da18", "filename": "gcc/d/dmd/attrib.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fattrib.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fattrib.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fattrib.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1431,7 +1431,7 @@ extern (C++) final class UserAttributeDeclaration : AttribDeclaration\n         if (auto sc = _scope)\n         {\n             _scope = null;\n-            arrayExpressionSemantic(atts, sc);\n+            arrayExpressionSemantic(atts.peekSlice(), sc);\n         }\n         auto exps = new Expressions();\n         if (userAttribDecl && userAttribDecl !is this)\n@@ -1554,7 +1554,7 @@ int foreachUda(Dsymbol sym, Scope* sc, int delegate(Expression) dg)\n         return 0;\n \n     auto udas = sym.userAttribDecl.getAttributes();\n-    arrayExpressionSemantic(udas, sc, true);\n+    arrayExpressionSemantic(udas.peekSlice(), sc, true);\n \n     return udas.each!((uda) {\n         if (!uda.isTupleExp())"}, {"sha": "09e38331137ed2670cfb1c7cd692a37f66018253", "filename": "gcc/d/dmd/canthrow.d", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fcanthrow.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fcanthrow.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcanthrow.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -111,13 +111,9 @@ extern (C++) /* CT */ BE canThrow(Expression e, FuncDeclaration func, bool mustN\n                     auto ts = tbNext.baseElemOf().isTypeStruct();\n                     if (ts)\n                     {\n-                        import dmd.id : Id;\n-\n                         auto sd = ts.sym;\n                         const id = ce.f.ident;\n-                        if (sd.postblit &&\n-                            (id == Id._d_arrayctor || id == Id._d_arraysetctor ||\n-                            id == Id._d_arrayassign_l || id == Id._d_arrayassign_r))\n+                        if (sd.postblit && isArrayConstructionOrAssign(id))\n                         {\n                             checkFuncThrows(ce, sd.postblit);\n                             return;"}, {"sha": "8204961fd2941eb9529aca38287007c9f43f3746", "filename": "gcc/d/dmd/chkformat.d", "status": "modified", "additions": 173, "deletions": 427, "changes": 600, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fchkformat.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fchkformat.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fchkformat.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1079,386 +1079,210 @@ Format parseGenericFormatSpecifier(scope const char[] format,\n     return specifier; // success\n }\n \n-unittest\n+@(\"parseGenericFormatSpecifier\") unittest\n {\n-    /* parseGenericFormatSpecifier\n-     */\n-\n     char genSpecifier;\n     size_t idx;\n \n-    assert(parseGenericFormatSpecifier(\"hhd\", idx, genSpecifier) == Format.hhd);\n-    assert(genSpecifier == 'd');\n-\n-    idx = 0;\n-    assert(parseGenericFormatSpecifier(\"hn\", idx, genSpecifier) == Format.hn);\n-    assert(genSpecifier == 'n');\n-\n-    idx = 0;\n-    assert(parseGenericFormatSpecifier(\"ji\", idx, genSpecifier) == Format.jd);\n-    assert(genSpecifier == 'i');\n+    void testG(string fmtStr, Format expectedFormat, char expectedGenSpecifier)\n+    {\n+        idx = 0;\n+        assert(parseGenericFormatSpecifier(fmtStr, idx, genSpecifier) == expectedFormat);\n+        assert(genSpecifier == expectedGenSpecifier);\n+    }\n \n-    idx = 0;\n-    assert(parseGenericFormatSpecifier(\"lu\", idx, genSpecifier) == Format.lu);\n-    assert(genSpecifier == 'u');\n+    testG(\"hhd\", Format.hhd, 'd');\n+    testG(\"hn\", Format.hn, 'n');\n+    testG(\"ji\", Format.jd, 'i');\n+    testG(\"lu\", Format.lu, 'u');\n \n     idx = 0;\n     assert(parseGenericFormatSpecifier(\"k\", idx, genSpecifier) == Format.error);\n+}\n \n-    /* parsePrintfFormatSpecifier\n-     */\n-\n-     bool widthStar;\n-     bool precisionStar;\n-\n-     // one for each Format\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%d\", idx, widthStar, precisionStar) == Format.d);\n-     assert(idx == 2);\n-     assert(!widthStar && !precisionStar);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%ld\", idx, widthStar, precisionStar) == Format.ld);\n-     assert(idx == 3);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%lld\", idx, widthStar, precisionStar) == Format.lld);\n-     assert(idx == 4);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%jd\", idx, widthStar, precisionStar) == Format.jd);\n-     assert(idx == 3);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%zd\", idx, widthStar, precisionStar) == Format.zd);\n-     assert(idx == 3);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%td\", idx, widthStar, precisionStar) == Format.td);\n-     assert(idx == 3);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%g\", idx, widthStar, precisionStar) == Format.g);\n-     assert(idx == 2);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%Lg\", idx, widthStar, precisionStar) == Format.Lg);\n-     assert(idx == 3);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%p\", idx, widthStar, precisionStar) == Format.p);\n-     assert(idx == 2);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%n\", idx, widthStar, precisionStar) == Format.n);\n-     assert(idx == 2);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%ln\", idx, widthStar, precisionStar) == Format.ln);\n-     assert(idx == 3);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%lln\", idx, widthStar, precisionStar) == Format.lln);\n-     assert(idx == 4);\n+@(\"parsePrintfFormatSpecifier\") unittest\n+{\n+    bool useGNUExts = false;\n \n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%hn\", idx, widthStar, precisionStar) == Format.hn);\n-     assert(idx == 3);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%hhn\", idx, widthStar, precisionStar) == Format.hhn);\n-     assert(idx == 4);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%jn\", idx, widthStar, precisionStar) == Format.jn);\n-     assert(idx == 3);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%zn\", idx, widthStar, precisionStar) == Format.zn);\n-     assert(idx == 3);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%tn\", idx, widthStar, precisionStar) == Format.tn);\n-     assert(idx == 3);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%c\", idx, widthStar, precisionStar) == Format.c);\n-     assert(idx == 2);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%lc\", idx, widthStar, precisionStar) == Format.lc);\n-     assert(idx == 3);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%s\", idx, widthStar, precisionStar) == Format.s);\n-     assert(idx == 2);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%ls\", idx, widthStar, precisionStar) == Format.ls);\n-     assert(idx == 3);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%%\", idx, widthStar, precisionStar) == Format.percent);\n-     assert(idx == 2);\n-\n-     // Synonyms\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%i\", idx, widthStar, precisionStar) == Format.d);\n-     assert(idx == 2);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%u\", idx, widthStar, precisionStar) == Format.u);\n-     assert(idx == 2);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%o\", idx, widthStar, precisionStar) == Format.u);\n-     assert(idx == 2);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%x\", idx, widthStar, precisionStar) == Format.u);\n-     assert(idx == 2);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%X\", idx, widthStar, precisionStar) == Format.u);\n-     assert(idx == 2);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%f\", idx, widthStar, precisionStar) == Format.g);\n-     assert(idx == 2);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%F\", idx, widthStar, precisionStar) == Format.g);\n-     assert(idx == 2);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%G\", idx, widthStar, precisionStar) == Format.g);\n-     assert(idx == 2);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%a\", idx, widthStar, precisionStar) == Format.g);\n-     assert(idx == 2);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%La\", idx, widthStar, precisionStar) == Format.Lg);\n-     assert(idx == 3);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%A\", idx, widthStar, precisionStar) == Format.g);\n-     assert(idx == 2);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%lg\", idx, widthStar, precisionStar) == Format.lg);\n-     assert(idx == 3);\n-\n-     // width, precision\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%*d\", idx, widthStar, precisionStar) == Format.d);\n-     assert(idx == 3);\n-     assert(widthStar && !precisionStar);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%.*d\", idx, widthStar, precisionStar) == Format.d);\n-     assert(idx == 4);\n-     assert(!widthStar && precisionStar);\n-\n-     idx = 0;\n-     assert(parsePrintfFormatSpecifier(\"%*.*d\", idx, widthStar, precisionStar) == Format.d);\n-     assert(idx == 5);\n-     assert(widthStar && precisionStar);\n-\n-     // Too short formats\n-     {\n-         foreach (s; [\"%\", \"%-\", \"%+\", \"% \", \"%#\", \"%0\", \"%*\", \"%1\", \"%19\", \"%.\", \"%.*\", \"%.1\", \"%.12\",\n-                      \"%j\", \"%z\", \"%t\", \"%l\", \"%h\", \"%ll\", \"%hh\"])\n-         {\n-             idx = 0;\n-             assert(parsePrintfFormatSpecifier(s, idx, widthStar, precisionStar) == Format.error);\n-             assert(idx == s.length);\n-         }\n-     }\n-\n-     // Undefined format combinations\n-     {\n-         foreach (s; [\"%#d\", \"%llg\", \"%jg\", \"%zg\", \"%tg\", \"%hg\", \"%hhg\",\n-                      \"%#c\", \"%0c\", \"%jc\", \"%zc\", \"%tc\", \"%Lc\", \"%hc\", \"%hhc\", \"%llc\",\n-                      \"%#s\", \"%0s\", \"%js\", \"%zs\", \"%ts\", \"%Ls\", \"%hs\", \"%hhs\", \"%lls\",\n-                      \"%jp\", \"%zp\", \"%tp\", \"%Lp\", \"%hp\", \"%lp\", \"%hhp\", \"%llp\",\n-                      \"%-n\", \"%+n\", \"% n\", \"%#n\", \"%0n\", \"%*n\", \"%1n\", \"%19n\", \"%.n\", \"%.*n\", \"%.1n\", \"%.12n\", \"%Ln\", \"%K\"])\n-         {\n-             idx = 0;\n-             assert(parsePrintfFormatSpecifier(s, idx, widthStar, precisionStar) == Format.error);\n-             assert(idx == s.length);\n-         }\n-     }\n-\n-    /* parseScanfFormatSpecifier\n-     */\n+    size_t idx = 0;\n+    bool widthStar;\n+    bool precisionStar;\n \n-    bool asterisk;\n+    void testP(string fmtStr, Format expectedFormat, size_t expectedIdx)\n+    {\n+        idx = 0;\n+        assert(parsePrintfFormatSpecifier(fmtStr, idx, widthStar, precisionStar, useGNUExts) == expectedFormat);\n+        assert(idx == expectedIdx);\n+    }\n \n     // one for each Format\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%d\", idx, asterisk) == Format.d);\n-    assert(idx == 2);\n-    assert(!asterisk);\n+    testP(\"%d\", Format.d, 2);\n+    assert(!widthStar && !precisionStar);\n+\n+    testP(\"%ld\", Format.ld, 3);\n+    testP(\"%lld\", Format.lld, 4);\n+    testP(\"%jd\", Format.jd, 3);\n+    testP(\"%zd\", Format.zd, 3);\n+    testP(\"%td\", Format.td, 3);\n+    testP(\"%g\", Format.g, 2);\n+    testP(\"%Lg\", Format.Lg, 3);\n+    testP(\"%p\", Format.p, 2);\n+    testP(\"%n\", Format.n, 2);\n+    testP(\"%ln\", Format.ln, 3);\n+    testP(\"%lln\", Format.lln, 4);\n+    testP(\"%hn\", Format.hn, 3);\n+    testP(\"%hhn\", Format.hhn, 4);\n+    testP(\"%jn\", Format.jn, 3);\n+    testP(\"%zn\", Format.zn, 3);\n+    testP(\"%tn\", Format.tn, 3);\n+    testP(\"%c\", Format.c, 2);\n+    testP(\"%lc\", Format.lc, 3);\n+    testP(\"%s\", Format.s, 2);\n+    testP(\"%ls\", Format.ls, 3);\n+    testP(\"%%\", Format.percent, 2);\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%hhd\", idx, asterisk) == Format.hhd);\n-    assert(idx == 4);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%hd\", idx, asterisk) == Format.hd);\n-    assert(idx == 3);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%ld\", idx, asterisk) == Format.ld);\n-    assert(idx == 3);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%lld\", idx, asterisk) == Format.lld);\n-    assert(idx == 4);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%jd\", idx, asterisk) == Format.jd);\n-    assert(idx == 3);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%zd\", idx, asterisk) == Format.zd);\n-    assert(idx == 3);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%td\", idx, asterisk,) == Format.td);\n-    assert(idx == 3);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%u\", idx, asterisk) == Format.u);\n-    assert(idx == 2);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%hhu\", idx, asterisk,) == Format.hhu);\n-    assert(idx == 4);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%hu\", idx, asterisk) == Format.hu);\n-    assert(idx == 3);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%lu\", idx, asterisk) == Format.lu);\n-    assert(idx == 3);\n+    // Synonyms\n+    testP(\"%i\", Format.d, 2);\n+    testP(\"%u\", Format.u, 2);\n+    testP(\"%o\", Format.u, 2);\n+    testP(\"%x\", Format.u, 2);\n+    testP(\"%X\", Format.u, 2);\n+    testP(\"%f\", Format.g, 2);\n+    testP(\"%F\", Format.g, 2);\n+    testP(\"%G\", Format.g, 2);\n+    testP(\"%a\", Format.g, 2);\n+    testP(\"%La\", Format.Lg, 3);\n+    testP(\"%A\", Format.g, 2);\n+    testP(\"%lg\", Format.lg, 3);\n+\n+    // width, precision\n+    testP(\"%*d\", Format.d, 3);\n+    assert(widthStar && !precisionStar);\n+\n+    testP(\"%.*d\", Format.d, 4);\n+    assert(!widthStar && precisionStar);\n+\n+    testP(\"%*.*d\", Format.d, 5);\n+    assert(widthStar && precisionStar);\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%llu\", idx, asterisk) == Format.llu);\n-    assert(idx == 4);\n+    // Too short formats\n+    foreach (s; [\"%\", \"%-\", \"%+\", \"% \", \"%#\", \"%0\", \"%*\", \"%1\", \"%19\", \"%.\", \"%.*\", \"%.1\", \"%.12\",\n+                    \"%j\", \"%z\", \"%t\", \"%l\", \"%h\", \"%ll\", \"%hh\"])\n+    {\n+        testP(s, Format.error, s.length);\n+    }\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%ju\", idx, asterisk) == Format.ju);\n-    assert(idx == 3);\n+    // Undefined format combinations\n+    foreach (s; [\"%#d\", \"%llg\", \"%jg\", \"%zg\", \"%tg\", \"%hg\", \"%hhg\",\n+                    \"%#c\", \"%0c\", \"%jc\", \"%zc\", \"%tc\", \"%Lc\", \"%hc\", \"%hhc\", \"%llc\",\n+                    \"%#s\", \"%0s\", \"%js\", \"%zs\", \"%ts\", \"%Ls\", \"%hs\", \"%hhs\", \"%lls\",\n+                    \"%jp\", \"%zp\", \"%tp\", \"%Lp\", \"%hp\", \"%lp\", \"%hhp\", \"%llp\",\n+                    \"%-n\", \"%+n\", \"% n\", \"%#n\", \"%0n\", \"%*n\", \"%1n\", \"%19n\", \"%.n\", \"%.*n\", \"%.1n\", \"%.12n\", \"%Ln\", \"%K\"])\n+    {\n+        testP(s, Format.error, s.length);\n+    }\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%g\", idx, asterisk) == Format.g);\n-    assert(idx == 2);\n+    testP(\"%C\", Format.lc, 2);\n+    testP(\"%S\", Format.ls, 2);\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%lg\", idx, asterisk) == Format.lg);\n-    assert(idx == 3);\n+    // GNU extensions: explicitly toggle ISO/GNU flag.\n+    foreach (s; [\"%jm\", \"%zm\", \"%tm\", \"%Lm\", \"%hm\", \"%hhm\", \"%lm\", \"%llm\",\n+                    \"%#m\", \"%+m\", \"%-m\", \"% m\", \"%0m\"])\n+    {\n+        useGNUExts = false;\n+        testP(s, Format.error, s.length);\n+        useGNUExts = true;\n+        testP(s, Format.error, s.length);\n+    }\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%Lg\", idx, asterisk) == Format.Lg);\n-    assert(idx == 3);\n+    foreach (s; [\"%m\", \"%md\", \"%mz\", \"%mc\", \"%mm\", \"%msyz\", \"%ml\", \"%mlz\", \"%mlc\", \"%mlm\"])\n+    {\n+        // valid cases, all parsed as `%m`\n+        // GNU printf()\n+        useGNUExts = true;\n+        testP(s, Format.GNU_m, 2);\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%p\", idx, asterisk) == Format.p);\n-    assert(idx == 2);\n+        // ISO printf()\n+        useGNUExts = false;\n+        testP(s, Format.error, 2);\n+    }\n+}\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%s\", idx, asterisk) == Format.s);\n-    assert(idx == 2);\n+@(\"parseScanfFormatSpecifier\") unittest\n+{\n+    size_t idx;\n+    bool asterisk;\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%ls\", idx, asterisk,) == Format.ls);\n-    assert(idx == 3);\n+    void testS(string fmtStr, Format expectedFormat, size_t expectedIdx)\n+    {\n+        idx = 0;\n+        assert(parseScanfFormatSpecifier(fmtStr, idx, asterisk) == expectedFormat);\n+        assert(idx == expectedIdx);\n+    }\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%%\", idx, asterisk) == Format.percent);\n-    assert(idx == 2);\n+    // one for each Format\n+    testS(\"%d\", Format.d, 2);\n+    testS(\"%hhd\", Format.hhd, 4);\n+    testS(\"%hd\", Format.hd, 3);\n+    testS(\"%ld\", Format.ld, 3);\n+    testS(\"%lld\", Format.lld, 4);\n+    testS(\"%jd\", Format.jd, 3);\n+    testS(\"%zd\", Format.zd, 3);\n+    testS(\"%td\", Format.td, 3);\n+    testS(\"%u\", Format.u, 2);\n+    testS(\"%hhu\", Format.hhu, 4);\n+    testS(\"%hu\", Format.hu, 3);\n+    testS(\"%lu\", Format.lu, 3);\n+    testS(\"%llu\", Format.llu, 4);\n+    testS(\"%ju\", Format.ju, 3);\n+    testS(\"%g\", Format.g, 2);\n+    testS(\"%lg\", Format.lg, 3);\n+    testS(\"%Lg\", Format.Lg, 3);\n+    testS(\"%p\", Format.p, 2);\n+    testS(\"%s\", Format.s, 2);\n+    testS(\"%ls\", Format.ls, 3);\n+    testS(\"%%\", Format.percent, 2);\n \n     // Synonyms\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%i\", idx, asterisk) == Format.d);\n-    assert(idx == 2);\n+    testS(\"%i\", Format.d, 2);\n+    testS(\"%n\", Format.n, 2);\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%n\", idx, asterisk) == Format.n);\n-    assert(idx == 2);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%o\", idx, asterisk) == Format.u);\n-    assert(idx == 2);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%x\", idx, asterisk) == Format.u);\n-    assert(idx == 2);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%f\", idx, asterisk) == Format.g);\n-    assert(idx == 2);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%e\", idx, asterisk) == Format.g);\n-    assert(idx == 2);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%a\", idx, asterisk) == Format.g);\n-    assert(idx == 2);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%c\", idx, asterisk) == Format.c);\n-    assert(idx == 2);\n+    testS(\"%o\", Format.u, 2);\n+    testS(\"%x\", Format.u, 2);\n+    testS(\"%f\", Format.g, 2);\n+    testS(\"%e\", Format.g, 2);\n+    testS(\"%a\", Format.g, 2);\n+    testS(\"%c\", Format.c, 2);\n \n     // asterisk\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%*d\", idx, asterisk) == Format.d);\n-    assert(idx == 3);\n+    testS(\"%*d\", Format.d, 3);\n     assert(asterisk);\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%9ld\", idx, asterisk) == Format.ld);\n-    assert(idx == 4);\n+    testS(\"%9ld\", Format.ld, 4);\n     assert(!asterisk);\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%*25984hhd\", idx, asterisk) == Format.hhd);\n-    assert(idx == 10);\n+    testS(\"%*25984hhd\", Format.hhd, 10);\n     assert(asterisk);\n \n     // scansets\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%[a-zA-Z]\", idx, asterisk) == Format.s);\n-    assert(idx == 9);\n+    testS(\"%[a-zA-Z]\", Format.s, 9);\n     assert(!asterisk);\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%*25l[a-z]\", idx, asterisk) == Format.ls);\n-    assert(idx == 10);\n+    testS(\"%*25l[a-z]\", Format.ls, 10);\n     assert(asterisk);\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%[]]\", idx, asterisk) == Format.s);\n-    assert(idx == 4);\n+    testS(\"%[]]\", Format.s, 4);\n     assert(!asterisk);\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%[^]]\", idx, asterisk) == Format.s);\n-    assert(idx == 5);\n+    testS(\"%[^]]\", Format.s, 5);\n     assert(!asterisk);\n \n     // Too short formats\n     foreach (s; [\"%\", \"% \", \"%#\", \"%0\", \"%*\", \"%1\", \"%19\",\n                  \"%j\", \"%z\", \"%t\", \"%l\", \"%h\", \"%ll\", \"%hh\", \"%K\"])\n     {\n-        idx = 0;\n-        assert(parseScanfFormatSpecifier(s, idx, asterisk) == Format.error);\n-        assert(idx == s.length);\n+\n+        testS(s, Format.error, s.length);\n     }\n \n \n@@ -1468,18 +1292,16 @@ unittest\n                  \"%jp\", \"%zp\", \"%tp\", \"%Lp\", \"%hp\", \"%lp\", \"%hhp\", \"%llp\",\n                  \"%-\", \"%+\", \"%#\", \"%0\", \"%.\", \"%Ln\"])\n     {\n-        idx = 0;\n-        assert(parseScanfFormatSpecifier(s, idx, asterisk) == Format.error);\n-        assert(idx == s.length);\n+\n+        testS(s, Format.error, s.length);\n \n     }\n \n     // Invalid scansets\n     foreach (s; [\"%[]\", \"%[^\", \"%[^]\", \"%[s\", \"%[0-9lld\", \"%[\", \"%l[^]\"])\n     {\n-        idx = 0;\n-        assert(parseScanfFormatSpecifier(s, idx, asterisk) == Format.error);\n-        assert(idx == s.length);\n+\n+        testS(s, Format.error, s.length);\n     }\n \n     // Posix extensions\n@@ -1488,95 +1310,19 @@ unittest\n                  \"%LC\", \"%lC\", \"%llC\", \"%jC\", \"%tC\", \"%hC\", \"%hhC\", \"%zC\",\n                  \"%LS\", \"%lS\", \"%llS\", \"%jS\", \"%tS\", \"%hS\", \"%hhS\", \"%zS\"])\n     {\n-        idx = 0;\n-        assert(parseScanfFormatSpecifier(s, idx, asterisk) == Format.error);\n-        assert(idx == s.length);\n-    }\n \n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%mc\", idx, asterisk) == Format.POSIX_ms);\n-    assert(idx == 3);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%ms\", idx, asterisk) == Format.POSIX_ms);\n-    assert(idx == 3);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%m[0-9]\", idx, asterisk) == Format.POSIX_ms);\n-    assert(idx == 7);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%mlc\", idx, asterisk) == Format.POSIX_mls);\n-    assert(idx == 4);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%mls\", idx, asterisk) == Format.POSIX_mls);\n-    assert(idx == 4);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%ml[^0-9]\", idx, asterisk) == Format.POSIX_mls);\n-    assert(idx == 9);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%mC\", idx, asterisk) == Format.POSIX_mls);\n-    assert(idx == 3);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%mS\", idx, asterisk) == Format.POSIX_mls);\n-    assert(idx == 3);\n-\n-    idx = 0;\n-    assert(parsePrintfFormatSpecifier(\"%C\", idx, widthStar, precisionStar) == Format.lc);\n-    assert(idx == 2);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%C\", idx, asterisk) == Format.lc);\n-    assert(idx == 2);\n-\n-    idx = 0;\n-    assert(parsePrintfFormatSpecifier(\"%S\", idx, widthStar, precisionStar) == Format.ls);\n-    assert(idx == 2);\n-\n-    idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%S\", idx, asterisk) == Format.ls);\n-    assert(idx == 2);\n-\n-    // GNU extensions: explicitly toggle ISO/GNU flag.\n-    // ISO printf()\n-    bool useGNUExts = false;\n-    {\n-        foreach (s; [\"%jm\", \"%zm\", \"%tm\", \"%Lm\", \"%hm\", \"%hhm\", \"%lm\", \"%llm\",\n-                     \"%#m\", \"%+m\", \"%-m\", \"% m\", \"%0m\"])\n-        {\n-            idx = 0;\n-            assert(parsePrintfFormatSpecifier(s, idx, widthStar, precisionStar, useGNUExts) == Format.error);\n-            assert(idx == s.length);\n-        }\n-        foreach (s; [\"%m\", \"%md\", \"%mz\", \"%mc\", \"%mm\", \"%msyz\", \"%ml\", \"%mlz\", \"%mlc\", \"%mlm\"])\n-        {\n-            idx = 0;\n-            assert(parsePrintfFormatSpecifier(s, idx, widthStar, precisionStar, useGNUExts) == Format.error);\n-            assert(idx == 2);\n-        }\n+        testS(s, Format.error, s.length);\n     }\n \n-    // GNU printf()\n-    useGNUExts = true;\n-    {\n-        foreach (s; [\"%jm\", \"%zm\", \"%tm\", \"%Lm\", \"%hm\", \"%hhm\", \"%lm\", \"%llm\",\n-                     \"%#m\", \"%+m\", \"%-m\", \"% m\", \"%0m\"])\n-        {\n-            idx = 0;\n-            assert(parsePrintfFormatSpecifier(s, idx, widthStar, precisionStar, useGNUExts) == Format.error);\n-            assert(idx == s.length);\n-        }\n-\n-        // valid cases, all parsed as `%m`\n-        foreach (s; [\"%m\", \"%md\", \"%mz\", \"%mc\", \"%mm\", \"%msyz\", \"%ml\", \"%mlz\", \"%mlc\", \"%mlm\"])\n-        {\n-            idx = 0;\n-            assert(parsePrintfFormatSpecifier(s, idx, widthStar, precisionStar, useGNUExts) == Format.GNU_m);\n-            assert(idx == 2);\n-        }\n-    }\n+    testS(\"%mc\", Format.POSIX_ms, 3);\n+    testS(\"%ms\", Format.POSIX_ms, 3);\n+    testS(\"%m[0-9]\", Format.POSIX_ms, 7);\n+    testS(\"%mlc\", Format.POSIX_mls, 4);\n+    testS(\"%mls\", Format.POSIX_mls, 4);\n+    testS(\"%ml[^0-9]\", Format.POSIX_mls, 9);\n+    testS(\"%mC\", Format.POSIX_mls, 3);\n+    testS(\"%mS\", Format.POSIX_mls, 3);\n+\n+    testS(\"%C\", Format.lc, 2);\n+    testS(\"%S\", Format.ls, 2);\n }"}, {"sha": "ba7d590b5530209d7ae9c37c60b866fb5cee9b34", "filename": "gcc/d/dmd/clone.d", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fclone.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fclone.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fclone.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -105,8 +105,7 @@ FuncDeclaration hasIdentityOpAssign(AggregateDeclaration ad, Scope* sc)\n         scope er = new NullExp(ad.loc, ad.type);    // dummy rvalue\n         scope el = new IdentifierExp(ad.loc, Id.p); // dummy lvalue\n         el.type = ad.type;\n-        Expressions a;\n-        a.setDim(1);\n+        auto a = Expressions(1);\n         const errors = global.startGagging(); // Do not report errors, even if the template opAssign fbody makes it.\n         sc = sc.push();\n         sc.tinst = null;\n@@ -465,8 +464,7 @@ private FuncDeclaration hasIdentityOpEquals(AggregateDeclaration ad, Scope* sc)\n          */\n         scope er = new NullExp(ad.loc, null); // dummy rvalue\n         scope el = new IdentifierExp(ad.loc, Id.p); // dummy lvalue\n-        Expressions a;\n-        a.setDim(1);\n+        auto a = Expressions(1);\n \n         bool hasIt(Type tthis)\n         {"}, {"sha": "2c5a4f0e76ddb91049f56c8bf17199f1d9d51f43", "filename": "gcc/d/dmd/cparse.d", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fcparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fcparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcparse.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1886,15 +1886,6 @@ final class CParser(AST) : Parser!AST\n             }\n             if (s !is null)\n             {\n-                s = applySpecifier(s, specifier);\n-                if (level == LVL.local)\n-                {\n-                    // Wrap the declaration in `extern (C) { declaration }`\n-                    // Necessary for function pointers, but harmless to apply to all.\n-                    auto decls = new AST.Dsymbols(1);\n-                    (*decls)[0] = s;\n-                    s = new AST.LinkDeclaration(s.loc, linkage, decls);\n-                }\n                 // Saw `asm(\"name\")` in the function, type, or variable definition.\n                 // This is equivalent to `pragma(mangle, \"name\")` in D\n                 if (asmName)\n@@ -1917,6 +1908,15 @@ final class CParser(AST) : Parser!AST\n                         p.mangleOverride = str;\n                     }\n                 }\n+                s = applySpecifier(s, specifier);\n+                if (level == LVL.local)\n+                {\n+                    // Wrap the declaration in `extern (C) { declaration }`\n+                    // Necessary for function pointers, but harmless to apply to all.\n+                    auto decls = new AST.Dsymbols(1);\n+                    (*decls)[0] = s;\n+                    s = new AST.LinkDeclaration(s.loc, linkage, decls);\n+                }\n                 symbols.push(s);\n             }\n             first = false;\n@@ -2603,7 +2603,6 @@ final class CParser(AST) : Parser!AST\n     {\n         //printf(\"cparseDeclarator(%d, %p)\\n\", declarator, t);\n         AST.Types constTypes; // all the Types that will need `const` applied to them\n-        constTypes.setDim(0);\n \n         AST.Type parseDecl(AST.Type t)\n         {"}, {"sha": "8ab3873aa33fbd60cd1f1badc5f5a2b1bf689080", "filename": "gcc/d/dmd/dcast.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fdcast.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fdcast.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdcast.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -2979,10 +2979,10 @@ Lagain:\n             return Lret(t);\n \n         if (t1n.ty == Tvoid) // pointers to void are always compatible\n-            return Lret(t2);\n+            return Lret(t1);\n \n         if (t2n.ty == Tvoid)\n-            return Lret(t);\n+            return Lret(t2);\n \n         if (t1.implicitConvTo(t2))\n             return convert(e1, t2);"}, {"sha": "5bce6b0060bbc9e5b8736a0f4d325ffd452aa711", "filename": "gcc/d/dmd/declaration.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fdeclaration.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fdeclaration.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.h?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -210,7 +210,7 @@ class OverDeclaration final : public Declaration\n     Dsymbol *aliassym;\n \n     const char *kind() const override;\n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n     bool overloadInsert(Dsymbol *s) override;\n \n     Dsymbol *toAlias() override;\n@@ -625,7 +625,7 @@ class FuncDeclaration : public Declaration\n     FuncDeclaration *syntaxCopy(Dsymbol *) override;\n     bool functionSemantic();\n     bool functionSemantic3();\n-    bool equals(const RootObject *o) const override final;\n+    bool equals(const RootObject * const o) const override final;\n \n     int overrides(FuncDeclaration *fd);\n     int findVtblIndex(Dsymbols *vtbl, int dim);"}, {"sha": "705acd1c98f2aa232d165f0d390167f36e19edb9", "filename": "gcc/d/dmd/dimport.d", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fdimport.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fdimport.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdimport.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -265,11 +265,16 @@ extern (C++) final class Import : Dsymbol\n             scopesym.addAccessiblePackage(p, visibility);\n             foreach (id; packages[1 .. $]) // [b, c]\n             {\n-                p = cast(Package) p.symtab.lookup(id);\n+                auto sym = p.symtab.lookup(id);\n                 // https://issues.dlang.org/show_bug.cgi?id=17991\n                 // An import of truly empty file/package can happen\n                 // https://issues.dlang.org/show_bug.cgi?id=20151\n                 // Package in the path conflicts with a module name\n+                if (sym is null)\n+                    break;\n+                // https://issues.dlang.org/show_bug.cgi?id=23327\n+                // Package conflicts with symbol of the same name\n+                p = sym.isPackage();\n                 if (p is null)\n                     break;\n                 scopesym.addAccessiblePackage(p, visibility);"}, {"sha": "a95d9dee88dc89134c4fbd292b8c533ec2450097", "filename": "gcc/d/dmd/dinterpret.d", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fdinterpret.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fdinterpret.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdinterpret.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -2830,7 +2830,7 @@ public:\n                         (*exps)[i] = ex;\n                     }\n                 }\n-                sd.fill(e.loc, exps, false);\n+                sd.fill(e.loc, *exps, false);\n \n                 auto se = ctfeEmplaceExp!StructLiteralExp(e.loc, sd, exps, e.newtype);\n                 se.origin = se;\n@@ -4778,12 +4778,6 @@ public:\n             // If `_d_HookTraceImpl` is found, resolve the underlying hook and replace `e` and `fd` with it.\n             removeHookTraceImpl(e, fd);\n \n-            bool isArrayConstructionOrAssign(FuncDeclaration fd)\n-            {\n-                return fd.ident == Id._d_arrayctor || fd.ident == Id._d_arraysetctor ||\n-                fd.ident == Id._d_arrayassign_l || fd.ident == Id._d_arrayassign_r;\n-            }\n-\n             if (fd.ident == Id.__ArrayPostblit || fd.ident == Id.__ArrayDtor)\n             {\n                 assert(e.arguments.dim == 1);\n@@ -4837,11 +4831,11 @@ public:\n                 result = interpretRegion(ae, istate);\n                 return;\n             }\n-            else if (isArrayConstructionOrAssign(fd))\n+            else if (isArrayConstructionOrAssign(fd.ident))\n             {\n                 // In expressionsem.d, the following lowerings were performed:\n                 // * `T[x] ea = eb;` to `_d_array{,set}ctor(ea[], eb[]);`.\n-                // * `ea = eb` (ea and eb are arrays) to `_d_arrayassign_{l,r}(ea[], eb[])`.\n+                // * `ea = eb` to `_d_array{,setassign,assign_l,assign_r}(ea[], eb)`.\n                 // The following code will rewrite them back to `ea = eb` and\n                 // then interpret that expression.\n "}, {"sha": "be0cbccc7c6551b4fc890178933dfc81e797b35b", "filename": "gcc/d/dmd/dmangle.d", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fdmangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fdmangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmangle.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -833,6 +833,23 @@ public:\n                 printf(\"  parent = %s %s\", s.parent.kind(), s.parent.toChars());\n             printf(\"\\n\");\n         }\n+        if (s.parent && s.ident)\n+        {\n+            if (auto m = s.parent.isModule())\n+            {\n+                if (m.filetype == FileType.c)\n+                {\n+                    /* C types at global level get mangled into the __C global namespace\n+                     * to get the same mangling regardless of which module it\n+                     * is declared in. This works because types are the same if the mangling\n+                     * is the same.\n+                     */\n+                    mangleIdentifier(Id.ImportC, s); // parent\n+                    mangleIdentifier(s.ident, s);\n+                    return;\n+                }\n+            }\n+        }\n         mangleParent(s);\n         if (s.ident)\n             mangleIdentifier(s.ident, s);"}, {"sha": "e1d589769fe47eb33d05ae35bc44e321289399fb", "filename": "gcc/d/dmd/doc.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fdoc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fdoc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdoc.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -3294,7 +3294,7 @@ private struct MarkdownLink\n      * Params:\n      *  buf   = an OutBuffer containing the DDoc\n      *  i     = the index within `buf` that points to the first character of the URL.\n-     *          If this function succeeds `i` will point just after the the end of the URL.\n+     *          If this function succeeds `i` will point just after the end of the URL.\n      * Returns: whether a URL was found and parsed\n      */\n     private bool parseHref(ref OutBuffer buf, ref size_t i)\n@@ -3362,7 +3362,7 @@ private struct MarkdownLink\n      * Params:\n      *  buf   = an OutBuffer containing the DDoc\n      *  i     = the index within `buf` that points to the first character of the title.\n-     *          If this function succeeds `i` will point just after the the end of the title.\n+     *          If this function succeeds `i` will point just after the end of the title.\n      * Returns: whether a title was found and parsed\n      */\n     private bool parseTitle(ref OutBuffer buf, ref size_t i)"}, {"sha": "7e2d02f06bf3ac063a360e8e72c001f75877bbf9", "filename": "gcc/d/dmd/dsymbol.d", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fdsymbol.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fdsymbol.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1544,6 +1544,12 @@ public:\n \n                         if (flags & IgnoreAmbiguous) // if return NULL on ambiguity\n                             return null;\n+\n+                        /* If two imports from C import files, pick first one, as C has global name space\n+                         */\n+                        if (s.isCsymbol() && s2.isCsymbol())\n+                            continue;\n+\n                         if (!(flags & IgnoreErrors))\n                             ScopeDsymbol.multiplyDefined(loc, s, s2);\n                         break;"}, {"sha": "acf0004eb80e7525206192b2d8fd517085b820c8", "filename": "gcc/d/dmd/dsymbol.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fdsymbol.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fdsymbol.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.h?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -189,7 +189,7 @@ class Dsymbol : public ASTNode\n     virtual const char *toPrettyCharsHelper(); // helper to print fully qualified (template) arguments\n     Loc getLoc();\n     const char *locToChars();\n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n     bool isAnonymous() const;\n     void error(const Loc &loc, const char *format, ...);\n     void error(const char *format, ...);"}, {"sha": "701f06aadeed3fbae9d7281152f12fb47025730a", "filename": "gcc/d/dmd/dsymbolsem.d", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbolsem.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -58,6 +58,7 @@ import dmd.nspace;\n import dmd.objc;\n import dmd.opover;\n import dmd.parse;\n+import dmd.root.array;\n import dmd.root.filename;\n import dmd.common.outbuffer;\n import dmd.root.rmem;\n@@ -983,7 +984,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                 // possibilities.\n                 if (fd && !(dsym.storage_class & (STC.manifest | STC.static_ | STC.gshared | STC.extern_)) && !dsym._init.isVoidInitializer())\n                 {\n-                    //printf(\"fd = '%s', var = '%s'\\n\", fd.toChars(), toChars());\n+                    //printf(\"fd = '%s', var = '%s'\\n\", fd.toChars(), dsym.toChars());\n                     if (!ei)\n                     {\n                         ArrayInitializer ai = dsym._init.isArrayInitializer();\n@@ -1014,24 +1015,6 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                         dsym._init = dsym._init.initializerSemantic(sc, dsym.type, INITinterpret);\n                     }\n \n-                    Expression exp = ei.exp;\n-                    Expression e1 = new VarExp(dsym.loc, dsym);\n-                    if (isBlit)\n-                        exp = new BlitExp(dsym.loc, e1, exp);\n-                    else\n-                        exp = new ConstructExp(dsym.loc, e1, exp);\n-                    dsym.canassign++;\n-                    exp = exp.expressionSemantic(sc);\n-                    dsym.canassign--;\n-                    exp = exp.optimize(WANTvalue);\n-                    if (exp.op == EXP.error)\n-                    {\n-                        dsym._init = new ErrorInitializer();\n-                        ei = null;\n-                    }\n-                    else\n-                        ei.exp = exp;\n-\n                     if (ei && dsym.isScope())\n                     {\n                         Expression ex = ei.exp.lastComma();\n@@ -1054,6 +1037,24 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                                 f.tookAddressOf--;\n                         }\n                     }\n+\n+                    Expression exp = ei.exp;\n+                    Expression e1 = new VarExp(dsym.loc, dsym);\n+                    if (isBlit)\n+                        exp = new BlitExp(dsym.loc, e1, exp);\n+                    else\n+                        exp = new ConstructExp(dsym.loc, e1, exp);\n+                    dsym.canassign++;\n+                    exp = exp.expressionSemantic(sc);\n+                    dsym.canassign--;\n+                    exp = exp.optimize(WANTvalue);\n+                    if (exp.op == EXP.error)\n+                    {\n+                        dsym._init = new ErrorInitializer();\n+                        ei = null;\n+                    }\n+                    else\n+                        ei.exp = exp;\n                 }\n                 else\n                 {\n@@ -1956,7 +1957,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         //printf(\"UserAttributeDeclaration::semantic() %p\\n\", this);\n         if (uad.decl && !uad._scope)\n             uad.Dsymbol.setScope(sc); // for function local symbols\n-        arrayExpressionSemantic(uad.atts, sc, true);\n+        arrayExpressionSemantic(uad.atts.peekSlice(), sc, true);\n         return attribSemantic(uad);\n     }\n \n@@ -4182,6 +4183,13 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             dd.errors = true;\n             return;\n         }\n+\n+        if (ad.isClassDeclaration() && ad.classKind == ClassKind.d)\n+        {\n+            // Class destructors are implicitly `scope`\n+            dd.storage_class |= STC.scope_;\n+        }\n+\n         if (dd.ident == Id.dtor && dd.semanticRun < PASS.semantic)\n             ad.userDtors.push(dd);\n         if (!dd.type)"}, {"sha": "13efc1cba3fee29d842c25659a4fdad5ea7a2e2f", "filename": "gcc/d/dmd/dtemplate.d", "status": "modified", "additions": 39, "deletions": 32, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fdtemplate.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fdtemplate.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtemplate.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1327,7 +1327,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n \n         Loc instLoc = ti.loc;\n         Objects* tiargs = ti.tiargs;\n-        auto dedargs = new Objects();\n+        auto dedargs = new Objects(parameters.dim);\n         Objects* dedtypes = &ti.tdtypes; // for T:T*, the dedargs is the T*, dedtypes is the T\n \n         version (none)\n@@ -1346,7 +1346,6 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n \n         assert(_scope);\n \n-        dedargs.setDim(parameters.dim);\n         dedargs.zero();\n \n         dedtypes.setDim(parameters.dim);\n@@ -1511,7 +1510,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n             }\n         }\n \n-        if (toParent().isModule() || (_scope.stc & STC.static_))\n+        if (toParent().isModule())\n             tthis = null;\n         if (tthis)\n         {\n@@ -1534,7 +1533,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n             }\n \n             // Match attributes of tthis against attributes of fd\n-            if (fd.type && !fd.isCtorDeclaration())\n+            if (fd.type && !fd.isCtorDeclaration() && !(_scope.stc & STC.static_))\n             {\n                 StorageClass stc = _scope.stc | fd.storage_class2;\n                 // Propagate parent storage class, https://issues.dlang.org/show_bug.cgi?id=5504\n@@ -2716,14 +2715,27 @@ void functionResolve(ref MatchAccumulator m, Dsymbol dstart, Loc loc, Scope* sc,\n         if (mfa == MATCH.nomatch)\n             return 0;\n \n-        if (mfa > m.last) goto LfIsBetter;\n-        if (mfa < m.last) goto LlastIsBetter;\n+        int firstIsBetter()\n+        {\n+            td_best = null;\n+            ti_best = null;\n+            ta_last = MATCH.exact;\n+            m.last = mfa;\n+            m.lastf = fd;\n+            tthis_best = tthis_fd;\n+            ov_index = 0;\n+            m.count = 1;\n+            return 0;\n+        }\n+\n+        if (mfa > m.last) return firstIsBetter();\n+        if (mfa < m.last) return 0;\n \n         /* See if one of the matches overrides the other.\n          */\n         assert(m.lastf);\n-        if (m.lastf.overrides(fd)) goto LlastIsBetter;\n-        if (fd.overrides(m.lastf)) goto LfIsBetter;\n+        if (m.lastf.overrides(fd)) return 0;\n+        if (fd.overrides(m.lastf)) return firstIsBetter();\n \n         /* Try to disambiguate using template-style partial ordering rules.\n          * In essence, if f() and g() are ambiguous, if f() can call g(),\n@@ -2734,8 +2746,8 @@ void functionResolve(ref MatchAccumulator m, Dsymbol dstart, Loc loc, Scope* sc,\n             MATCH c1 = fd.leastAsSpecialized(m.lastf);\n             MATCH c2 = m.lastf.leastAsSpecialized(fd);\n             //printf(\"c1 = %d, c2 = %d\\n\", c1, c2);\n-            if (c1 > c2) goto LfIsBetter;\n-            if (c1 < c2) goto LlastIsBetter;\n+            if (c1 > c2) return firstIsBetter();\n+            if (c1 < c2) return 0;\n         }\n \n         /* The 'overrides' check above does covariant checking only\n@@ -2756,12 +2768,12 @@ void functionResolve(ref MatchAccumulator m, Dsymbol dstart, Loc loc, Scope* sc,\n             {\n                 if (firstCovariant != Covariant.yes && firstCovariant != Covariant.no)\n                 {\n-                    goto LlastIsBetter;\n+                    return 0;\n                 }\n             }\n             else if (firstCovariant == Covariant.yes || firstCovariant == Covariant.no)\n             {\n-                goto LfIsBetter;\n+                return firstIsBetter();\n             }\n         }\n \n@@ -2780,37 +2792,22 @@ void functionResolve(ref MatchAccumulator m, Dsymbol dstart, Loc loc, Scope* sc,\n             fd._linkage == m.lastf._linkage)\n         {\n             if (fd.fbody && !m.lastf.fbody)\n-                goto LfIsBetter;\n+                return firstIsBetter();\n             if (!fd.fbody)\n-                goto LlastIsBetter;\n+                return 0;\n         }\n \n         // https://issues.dlang.org/show_bug.cgi?id=14450\n         // Prefer exact qualified constructor for the creating object type\n         if (isCtorCall && tf.mod != m.lastf.type.mod)\n         {\n-            if (tthis.mod == tf.mod) goto LfIsBetter;\n-            if (tthis.mod == m.lastf.type.mod) goto LlastIsBetter;\n+            if (tthis.mod == tf.mod) return firstIsBetter();\n+            if (tthis.mod == m.lastf.type.mod) return 0;\n         }\n \n         m.nextf = fd;\n         m.count++;\n         return 0;\n-\n-    LlastIsBetter:\n-        return 0;\n-\n-    LfIsBetter:\n-        td_best = null;\n-        ti_best = null;\n-        ta_last = MATCH.exact;\n-        m.last = mfa;\n-        m.lastf = fd;\n-        tthis_best = tthis_fd;\n-        ov_index = 0;\n-        m.count = 1;\n-        return 0;\n-\n     }\n \n     int applyTemplate(TemplateDeclaration td)\n@@ -3844,10 +3841,20 @@ MATCH deduceType(RootObject o, Scope* sc, Type tparam, TemplateParameters* param\n                         tp = (*parameters)[i];\n                     else\n                     {\n+                        Loc loc;\n+                        // The \"type\" (it hasn't been resolved yet) of the function parameter\n+                        // does not have a location but the parameter it is related to does,\n+                        // so we use that for the resolution (better error message).\n+                        if (inferStart < parameters.dim)\n+                        {\n+                            TemplateParameter loctp = (*parameters)[inferStart];\n+                            loc = loctp.loc;\n+                        }\n+\n                         Expression e;\n                         Type tx;\n                         Dsymbol s;\n-                        taa.index.resolve(Loc.initial, sc, e, tx, s);\n+                        taa.index.resolve(loc, sc, e, tx, s);\n                         edim = s ? getValue(s) : getValue(e);\n                     }\n                 }"}, {"sha": "7ba0a96aa0a350d5dff511235fc36d6bff434e11", "filename": "gcc/d/dmd/escape.d", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fescape.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fescape.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fescape.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1423,10 +1423,7 @@ private bool checkReturnEscapeImpl(Scope* sc, Expression e, bool refs, bool gag)\n                  *   auto dg = () return { return &x; }\n                  * Because dg.ptr points to x, this is returning dt.ptr+offset\n                  */\n-                if (global.params.useDIP1000 == FeatureState.enabled)\n-                {\n-                    sc.func.storage_class |= STC.return_ | STC.returninferred;\n-                }\n+                sc.func.storage_class |= STC.return_ | STC.returninferred;\n             }\n         }\n "}, {"sha": "42b4dd45c09cca40188a26fdac00c23f5c7f4550", "filename": "gcc/d/dmd/expression.d", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fexpression.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fexpression.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -7197,6 +7197,26 @@ extern(D) Modifiable checkModifiable(Expression exp, Scope* sc, ModifyFlags flag\n     }\n }\n \n+/**\n+ * Verify if the given identifier is any of\n+ * _d_array{ctor,setctor,setassign,assign_l, assign_r}.\n+ *\n+ * Params:\n+ *  id = the identifier to verify\n+ *\n+ * Returns:\n+ *  `true` if the identifier corresponds to a construction of assignement\n+ *  runtime hook, `false` otherwise.\n+ */\n+bool isArrayConstructionOrAssign(const Identifier id)\n+{\n+    import dmd.id : Id;\n+\n+    return id == Id._d_arrayctor || id == Id._d_arraysetctor ||\n+        id == Id._d_arrayassign_l || id == Id._d_arrayassign_r ||\n+        id == Id._d_arraysetassign;\n+}\n+\n /******************************\n  * Provide efficient way to implement isUnaExp(), isBinExp(), isBinAssignExp()\n  */"}, {"sha": "c9e3978710687037ff4e471f27b878a35485ae58", "filename": "gcc/d/dmd/expression.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fexpression.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fexpression.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.h?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -250,7 +250,7 @@ class IntegerExp final : public Expression\n \n     static IntegerExp *create(const Loc &loc, dinteger_t value, Type *type);\n     static void emplace(UnionExp *pue, const Loc &loc, dinteger_t value, Type *type);\n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n     dinteger_t toInteger() override;\n     real_t toReal() override;\n     real_t toImaginary() override;\n@@ -280,7 +280,7 @@ class RealExp final : public Expression\n \n     static RealExp *create(const Loc &loc, real_t value, Type *type);\n     static void emplace(UnionExp *pue, const Loc &loc, real_t value, Type *type);\n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n     dinteger_t toInteger() override;\n     uinteger_t toUInteger() override;\n     real_t toReal() override;\n@@ -297,7 +297,7 @@ class ComplexExp final : public Expression\n \n     static ComplexExp *create(const Loc &loc, complex_t value, Type *type);\n     static void emplace(UnionExp *pue, const Loc &loc, complex_t value, Type *type);\n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n     dinteger_t toInteger() override;\n     uinteger_t toUInteger() override;\n     real_t toReal() override;\n@@ -358,7 +358,7 @@ class SuperExp final : public ThisExp\n class NullExp final : public Expression\n {\n public:\n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n     Optional<bool> toBool() override;\n     StringExp *toStringExp() override;\n     void accept(Visitor *v) override { v->visit(this); }\n@@ -377,7 +377,7 @@ class StringExp final : public Expression\n     static StringExp *create(const Loc &loc, const char *s);\n     static StringExp *create(const Loc &loc, const void *s, d_size_t len);\n     static void emplace(UnionExp *pue, const Loc &loc, const char *s);\n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n     char32_t getCodeUnit(d_size_t i) const;\n     void setCodeUnit(d_size_t i, char32_t c);\n     StringExp *toStringExp() override;\n@@ -408,7 +408,7 @@ class TupleExp final : public Expression\n \n     static TupleExp *create(const Loc &loc, Expressions *exps);\n     TupleExp *syntaxCopy() override;\n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n \n     void accept(Visitor *v) override { v->visit(this); }\n };\n@@ -423,7 +423,7 @@ class ArrayLiteralExp final : public Expression\n     static ArrayLiteralExp *create(const Loc &loc, Expressions *elements);\n     static void emplace(UnionExp *pue, const Loc &loc, Expressions *elements);\n     ArrayLiteralExp *syntaxCopy() override;\n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n     Expression *getElement(d_size_t i); // use opIndex instead\n     Expression *opIndex(d_size_t i);\n     Optional<bool> toBool() override;\n@@ -439,7 +439,7 @@ class AssocArrayLiteralExp final : public Expression\n     Expressions *values;\n     OwnedBy ownedByCtfe;\n \n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n     AssocArrayLiteralExp *syntaxCopy() override;\n     Optional<bool> toBool() override;\n \n@@ -477,7 +477,7 @@ class StructLiteralExp final : public Expression\n     OwnedBy ownedByCtfe;\n \n     static StructLiteralExp *create(const Loc &loc, StructDeclaration *sd, void *elements, Type *stype = NULL);\n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n     StructLiteralExp *syntaxCopy() override;\n     Expression *getField(Type *type, unsigned offset);\n     int getFieldIndex(Type *type, unsigned offset);\n@@ -583,7 +583,7 @@ class VarExp final : public SymbolExp\n public:\n     bool delegateWasExtracted;\n     static VarExp *create(const Loc &loc, Declaration *var, bool hasOverloads = true);\n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n     bool isLvalue() override;\n     Expression *toLvalue(Scope *sc, Expression *e) override;\n     Expression *modifiableLvalue(Scope *sc, Expression *e) override;\n@@ -612,7 +612,7 @@ class FuncExp final : public Expression\n     TemplateDeclaration *td;\n     TOK tok;\n \n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n     FuncExp *syntaxCopy() override;\n     const char *toChars() const override;\n     bool checkType() override;"}, {"sha": "8a4a13ce1335461a69244707a638d65eba7625be", "filename": "gcc/d/dmd/expressionsem.d", "status": "modified", "additions": 50, "deletions": 42, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -62,6 +62,7 @@ import dmd.opover;\n import dmd.optimize;\n import dmd.parse;\n import dmd.printast;\n+import dmd.root.array;\n import dmd.root.ctfloat;\n import dmd.root.file;\n import dmd.root.filename;\n@@ -336,22 +337,18 @@ Expression resolveOpDollar(Scope* sc, ArrayExp ae, IntervalExp ie, Expression* p\n /******************************\n  * Perform semantic() on an array of Expressions.\n  */\n-bool arrayExpressionSemantic(Expressions* exps, Scope* sc, bool preserveErrors = false)\n+extern(D) bool arrayExpressionSemantic(\n+    Expression[] exps, Scope* sc, bool preserveErrors = false)\n {\n     bool err = false;\n-    if (exps)\n+    foreach (ref e; exps)\n     {\n-        foreach (ref e; *exps)\n-        {\n-            if (e)\n-            {\n-                auto e2 = e.expressionSemantic(sc);\n-                if (e2.op == EXP.error)\n-                    err = true;\n-                if (preserveErrors || e2.op != EXP.error)\n-                    e = e2;\n-            }\n-        }\n+        if (e is null) continue;\n+        auto e2 = e.expressionSemantic(sc);\n+        if (e2.op == EXP.error)\n+            err = true;\n+        if (preserveErrors || e2.op != EXP.error)\n+            e = e2;\n     }\n     return err;\n }\n@@ -443,7 +440,7 @@ private Expression searchUFCS(Scope* sc, UnaExp ue, Identifier ident)\n     }\n \n     if (!s)\n-        return ue.e1.type.getProperty(sc, loc, ident, 0);\n+        return ue.e1.type.getProperty(sc, loc, ident, 0, ue.e1);\n \n     FuncDeclaration f = s.isFuncDeclaration();\n     if (f)\n@@ -550,7 +547,7 @@ private Expression resolveUFCS(Scope* sc, CallExp ce)\n                     if (!global.endGagging(errors))\n                         return e;\n \n-                    if (arrayExpressionSemantic(originalArguments, sc))\n+                    if (arrayExpressionSemantic(originalArguments.peekSlice(), sc))\n                         return ErrorExp.get();\n \n                     /* fall down to UFCS */\n@@ -3111,7 +3108,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n \n         if (e.basis)\n             e.basis = e.basis.expressionSemantic(sc);\n-        if (arrayExpressionSemantic(e.elements, sc) || (e.basis && e.basis.op == EXP.error))\n+        if (arrayExpressionSemantic(e.elements.peekSlice(), sc) || (e.basis && e.basis.op == EXP.error))\n             return setError();\n \n         expandTuples(e.elements);\n@@ -3154,8 +3151,8 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         }\n \n         // Run semantic() on each element\n-        bool err_keys = arrayExpressionSemantic(e.keys, sc);\n-        bool err_vals = arrayExpressionSemantic(e.values, sc);\n+        bool err_keys = arrayExpressionSemantic(e.keys.peekSlice(), sc);\n+        bool err_vals = arrayExpressionSemantic(e.values.peekSlice(), sc);\n         if (err_keys || err_vals)\n             return setError();\n \n@@ -3201,7 +3198,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             return setError();\n \n         // run semantic() on each element\n-        if (arrayExpressionSemantic(e.elements, sc))\n+        if (arrayExpressionSemantic(e.elements.peekSlice(), sc))\n             return setError();\n \n         expandTuples(e.elements);\n@@ -3213,7 +3210,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n \n         /* Fill out remainder of elements[] with default initializers for fields[]\n          */\n-        if (!e.sd.fill(e.loc, e.elements, false))\n+        if (!e.sd.fill(e.loc, *e.elements, false))\n         {\n             /* An error in the initializer needs to be recorded as an error\n              * in the enclosing function or template, since the initializer\n@@ -3524,7 +3521,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         exp.newtype = exp.type; // in case type gets cast to something else\n         Type tb = exp.type.toBasetype();\n         //printf(\"tb: %s, deco = %s\\n\", tb.toChars(), tb.deco);\n-        if (arrayExpressionSemantic(exp.arguments, sc))\n+        if (arrayExpressionSemantic(exp.arguments.peekSlice(), sc))\n         {\n             return setError();\n         }\n@@ -3672,7 +3669,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 }\n             }\n \n-            if (cd.disableNew)\n+            if (cd.disableNew && !exp.onstack)\n             {\n                 exp.error(\"cannot allocate `class %s` with `new` because it is annotated with `@disable new()`\",\n                           originalNewtype.toChars());\n@@ -3807,7 +3804,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 if (!sd.fit(exp.loc, sc, exp.arguments, tb))\n                     return setError();\n \n-                if (!sd.fill(exp.loc, exp.arguments, false))\n+                if (!sd.fill(exp.loc, *exp.arguments, false))\n                     return setError();\n \n                 if (checkFrameAccess(exp.loc, sc, sd, exp.arguments ? exp.arguments.dim : 0))\n@@ -4259,7 +4256,8 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         }\n         if (FuncExp fe = exp.e1.isFuncExp())\n         {\n-            if (arrayExpressionSemantic(exp.arguments, sc) || preFunctionParameters(sc, exp.arguments))\n+            if (arrayExpressionSemantic(exp.arguments.peekSlice(), sc) ||\n+                preFunctionParameters(sc, exp.arguments))\n                 return setError();\n \n             // Run e1 semantic even if arguments have any errors\n@@ -4497,7 +4495,8 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             result = exp.e1;\n             return;\n         }\n-        if (arrayExpressionSemantic(exp.arguments, sc) || preFunctionParameters(sc, exp.arguments))\n+        if (arrayExpressionSemantic(exp.arguments.peekSlice(), sc) ||\n+            preFunctionParameters(sc, exp.arguments))\n             return setError();\n \n         // Check for call operator overload\n@@ -4543,7 +4542,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                         goto Lx;\n \n                     auto sle = new StructLiteralExp(exp.loc, sd, null, exp.e1.type);\n-                    if (!sd.fill(exp.loc, sle.elements, true))\n+                    if (!sd.fill(exp.loc, *sle.elements, true))\n                         return setError();\n                     if (checkFrameAccess(exp.loc, sc, sd, sle.elements.dim))\n                         return setError();\n@@ -4614,7 +4613,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             {\n                 Expression e;\n \n-                // Make sure to use the the enum type itself rather than its\n+                // Make sure to use the enum type itself rather than its\n                 // base type\n                 // https://issues.dlang.org/show_bug.cgi?id=16346\n                 if (exp.e1.type.ty == Tenum)\n@@ -8661,7 +8660,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         if (sd.isNested())\n         {\n             auto sle = new StructLiteralExp(loc, sd, null, t);\n-            if (!sd.fill(loc, sle.elements, true))\n+            if (!sd.fill(loc, *sle.elements, true))\n                 return ErrorExp.get();\n             if (checkFrameAccess(loc, sc, sd, sle.elements.dim))\n                 return ErrorExp.get();\n@@ -9991,38 +9990,41 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n     }\n \n     /***************************************\n-     * Lower AssignExp to `_d_arrayassign_{l,r}` if needed.\n+     * Lower AssignExp to `_d_array{setassign,assign_l,assign_r}` if needed.\n      *\n      * Params:\n      *      ae = the AssignExp to be lowered\n      *      fromCommaExp = indicates whether `ae` is part of a CommaExp or not,\n      *                     so no unnecessary temporay variable is created.\n      * Returns:\n-     *      a CommaExp contiaining call a to `_d_arrayassign_{l,r}` if needed or\n-     *      `ae` otherwise\n+     *      a CommaExp contiaining call a to `_d_array{setassign,assign_l,assign_r}`\n+     *      if needed or `ae` otherwise\n      */\n     private Expression lowerArrayAssign(AssignExp ae, bool fromCommaExp = false)\n     {\n         Type t1b = ae.e1.type.toBasetype();\n         if (t1b.ty != Tsarray && t1b.ty != Tarray)\n             return ae;\n \n-        const isArrayAssign =\n-            (ae.e1.isSliceExp || ae.e1.type.ty == Tsarray) &&\n+        const isArrayAssign = (ae.e1.isSliceExp() || ae.e1.type.ty == Tsarray) &&\n             (ae.e2.type.ty == Tsarray || ae.e2.type.ty == Tarray) &&\n-            (ae.e1.type.nextOf && ae.e2.type.nextOf && ae.e1.type.nextOf.mutableOf.equals(ae.e2.type.nextOf.mutableOf));\n+            (ae.e1.type.nextOf() && ae.e2.type.nextOf() && ae.e1.type.nextOf.mutableOf.equals(ae.e2.type.nextOf.mutableOf()));\n \n-        if (!isArrayAssign)\n+        const isArraySetAssign = (ae.e1.isSliceExp() || ae.e1.type.ty == Tsarray) &&\n+            (ae.e1.type.nextOf() && ae.e2.type.implicitConvTo(ae.e1.type.nextOf()));\n+\n+        if (!isArrayAssign && !isArraySetAssign)\n             return ae;\n \n         const ts = t1b.nextOf().baseElemOf().isTypeStruct();\n         if (!ts || (!ts.sym.postblit && !ts.sym.dtor))\n             return ae;\n \n         Expression res;\n-        auto func = ae.e2.isLvalue || ae.e2.isSliceExp ? Id._d_arrayassign_l : Id._d_arrayassign_r;\n+        Identifier func = isArraySetAssign ? Id._d_arraysetassign :\n+            ae.e2.isLvalue() || ae.e2.isSliceExp() ? Id._d_arrayassign_l : Id._d_arrayassign_r;\n \n-        // Lower to `.object._d_arrayassign_l{r}(e1, e2)``\n+        // Lower to `.object._d_array{setassign,assign_l,assign_r}(e1, e2)``\n         Expression id = new IdentifierExp(ae.loc, Id.empty);\n         id = new DotIdExp(ae.loc, id, Id.object);\n         id = new DotIdExp(ae.loc, id, func);\n@@ -10032,10 +10034,11 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             .expressionSemantic(sc));\n \n         Expression eValue2, value2 = ae.e2;\n-        if (ae.e2.isLvalue)\n-            value2 = new CastExp(ae.loc, ae.e2, ae.e2.type.nextOf.arrayOf)\n+        if (isArrayAssign && value2.isLvalue())\n+            value2 = new CastExp(ae.loc, ae.e2, ae.e2.type.nextOf.arrayOf())\n                 .expressionSemantic(sc);\n-        else if (!fromCommaExp)\n+        else if (!fromCommaExp &&\n+            (isArrayAssign || (isArraySetAssign && !value2.isLvalue())))\n         {\n             // Rvalues from CommaExps were introduced in `visit(AssignExp)`\n             // and are temporary variables themselves. Rvalues from trivial\n@@ -10044,15 +10047,20 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             // `__assigntmp` will be destroyed together with the array `ae.e1`.\n             // When `ae.e2` is a variadic arg array, it is also `scope`, so\n             // `__assigntmp` may also be scope.\n-            auto vd = copyToTemp(STC.rvalue | STC.nodtor | STC.scope_, \"__assigntmp\", ae.e2);\n+            StorageClass stc = STC.nodtor;\n+            if (isArrayAssign)\n+                stc |= STC.rvalue | STC.scope_;\n+\n+            auto vd = copyToTemp(stc, \"__assigntmp\", ae.e2);\n             eValue2 = new DeclarationExp(vd.loc, vd).expressionSemantic(sc);\n             value2 = new VarExp(vd.loc, vd).expressionSemantic(sc);\n         }\n         arguments.push(value2);\n \n         Expression ce = new CallExp(ae.loc, id, arguments);\n         res = Expression.combine(eValue2, ce).expressionSemantic(sc);\n-        res = Expression.combine(res, ae.e1).expressionSemantic(sc);\n+        if (isArrayAssign)\n+            res = Expression.combine(res, ae.e1).expressionSemantic(sc);\n \n         if (global.params.verbose)\n             message(\"lowered   %s =>\\n          %s\", ae.toChars(), res.toChars());"}, {"sha": "bcae282f09fcb71bbfb3c93040f2aa569273df8b", "filename": "gcc/d/dmd/func.d", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Ffunc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Ffunc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffunc.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -3216,11 +3216,12 @@ FuncDeclaration resolveFuncCall(const ref Loc loc, Scope* sc, Dsymbol s,\n         }\n     }\n \n-    if (tiargs && arrayObjectIsError(tiargs) ||\n-        fargs && arrayObjectIsError(cast(Objects*)fargs))\n-    {\n+    if (tiargs && arrayObjectIsError(tiargs))\n         return null;\n-    }\n+    if (fargs !is null)\n+        foreach (arg; *fargs)\n+            if (isError(arg))\n+                return null;\n \n     MatchAccumulator m;\n     functionResolve(m, s, loc, sc, tiargs, tthis, fargs, null);\n@@ -3758,9 +3759,9 @@ extern (C++) final class FuncLiteralDeclaration : FuncDeclaration\n     // backend\n     bool deferToObj;\n \n-    extern (D) this(const ref Loc loc, const ref Loc endloc, Type type, TOK tok, ForeachStatement fes, Identifier id = null)\n+    extern (D) this(const ref Loc loc, const ref Loc endloc, Type type, TOK tok, ForeachStatement fes, Identifier id = null, StorageClass storage_class = STC.undefined_)\n     {\n-        super(loc, endloc, null, STC.undefined_, type);\n+        super(loc, endloc, null, storage_class, type);\n         this.ident = id ? id : Id.empty;\n         this.tok = tok;\n         this.fes = fes;\n@@ -3774,7 +3775,7 @@ extern (C++) final class FuncLiteralDeclaration : FuncDeclaration\n     {\n         //printf(\"FuncLiteralDeclaration::syntaxCopy('%s')\\n\", toChars());\n         assert(!s);\n-        auto f = new FuncLiteralDeclaration(loc, endloc, type.syntaxCopy(), tok, fes, ident);\n+        auto f = new FuncLiteralDeclaration(loc, endloc, type.syntaxCopy(), tok, fes, ident, storage_class & STC.auto_);\n         f.treq = treq; // don't need to copy\n         FuncDeclaration.syntaxCopy(f);\n         return f;\n@@ -3833,9 +3834,7 @@ extern (C++) final class FuncLiteralDeclaration : FuncDeclaration\n             {\n                 Expression exp = s.exp;\n                 if (exp && !exp.type.equals(tret))\n-                {\n-                    s.exp = exp.castTo(sc, tret);\n-                }\n+                    s.exp = exp.implicitCastTo(sc, tret);\n             }\n         }\n "}, {"sha": "7a840ffa585546cff398837b147ea8b7c0d33adc", "filename": "gcc/d/dmd/iasmgcc.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fiasmgcc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fiasmgcc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fiasmgcc.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -84,13 +84,10 @@ int parseExtAsmOperands(Parser)(Parser p, GccAsmStatement s)\n \n             case TOK.string_:\n                 constraint = p.parsePrimaryExp();\n-                // @@@DEPRECATED_2.101@@@\n-                // Old parser allowed omitting parentheses around the expression.\n-                // Deprecated in 2.091. Can be made permanent error after 2.100\n                 if (p.token.value != TOK.leftParenthesis)\n                 {\n                     arg = p.parseAssignExp();\n-                    deprecation(arg.loc, \"`%s` must be surrounded by parentheses\", arg.toChars());\n+                    error(arg.loc, \"`%s` must be surrounded by parentheses\", arg.toChars());\n                 }\n                 else\n                 {\n@@ -527,6 +524,9 @@ unittest\n         // Found ',' when expecting ':'\n         q{ asm { \"\", \"\";\n         } },\n+\n+        // https://issues.dlang.org/show_bug.cgi?id=20593\n+        q{ asm { \"instruction\" : : \"operand\" 123; } },\n     ];\n \n     foreach (test; passAsmTests)"}, {"sha": "48ca7665eaef365602a5a67dd6ff1f50c231ed84", "filename": "gcc/d/dmd/id.d", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fid.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fid.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fid.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -319,6 +319,7 @@ immutable Msgtable[] msgtable =\n     { \"_aaApply2\" },\n     { \"_d_arrayctor\" },\n     { \"_d_arraysetctor\" },\n+    { \"_d_arraysetassign\" },\n     { \"_d_arrayassign_l\" },\n     { \"_d_arrayassign_r\" },\n \n@@ -511,6 +512,7 @@ immutable Msgtable[] msgtable =\n     { \"wchar_t\" },\n \n     // for C compiler\n+    { \"ImportC\", \"__C\" },\n     { \"__tag\" },\n     { \"dllimport\" },\n     { \"dllexport\" },"}, {"sha": "523b5b820d759b53df147cf90ddd632901dc15be", "filename": "gcc/d/dmd/init.d", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Finit.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Finit.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finit.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -167,6 +167,7 @@ extern (C++) final class ArrayInitializer : Initializer\n     uint dim;               // length of array being initialized\n     Type type;              // type that array will be used to initialize\n     bool sem;               // true if semantic() is run\n+    bool isCarray;          // C array semantics\n \n     extern (D) this(const ref Loc loc)\n     {"}, {"sha": "977157f5c41434764501edd70f7c4b983ad6bf34", "filename": "gcc/d/dmd/init.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Finit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Finit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finit.h?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -78,6 +78,7 @@ class ArrayInitializer final : public Initializer\n     unsigned dim;       // length of array being initialized\n     Type *type;         // type that array will be used to initialize\n     bool sem;           // true if semantic() is run\n+    bool isCarray;      // C array semantics\n \n     bool isAssociativeArray() const;\n     Expression *toAssocArrayLiteral();"}, {"sha": "ef39f594d88b5d7e28480d515a7f5ede64a9c002", "filename": "gcc/d/dmd/initsem.d", "status": "modified", "additions": 325, "deletions": 228, "changes": 553, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Finitsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Finitsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finitsem.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -225,7 +225,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n                 assert(sc);\n                 auto tm = vd.type.addMod(t.mod);\n                 auto iz = i.value[j].initializerSemantic(sc, tm, needInterpret);\n-                auto ex = iz.initializerToExpression();\n+                auto ex = iz.initializerToExpression(null, (sc.flags & SCOPE.Cfile) != 0);\n                 if (ex.op == EXP.error)\n                 {\n                     errors = true;\n@@ -243,7 +243,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n \n             // Make a StructLiteralExp out of elements[]\n             auto sle = new StructLiteralExp(i.loc, sd, elements, t);\n-            if (!sd.fill(i.loc, elements, false))\n+            if (!sd.fill(i.loc, *elements, false))\n                 return err();\n             sle.type = t;\n             auto ie = new ExpInitializer(i.loc, sle);\n@@ -272,7 +272,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n         uint length;\n         const(uint) amax = 0x80000000;\n         bool errors = false;\n-        //printf(\"ArrayInitializer::semantic(%s)\\n\", t.toChars());\n+        //printf(\"ArrayInitializer::semantic(%s), ai: %s %p\\n\", t.toChars(), i.toChars(), i);\n         if (i.sem) // if semantic() already run\n         {\n             return i;\n@@ -374,11 +374,22 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n         }\n         if (auto tsa = t.isTypeSArray())\n         {\n-            uinteger_t edim = tsa.dim.toInteger();\n-            if (i.dim > edim && !(tsa.isIncomplete() && (sc.flags & SCOPE.Cfile)))\n+            if (sc.flags & SCOPE.Cfile && tsa.isIncomplete())\n             {\n-                error(i.loc, \"array initializer has %u elements, but array length is %llu\", i.dim, edim);\n-                return err();\n+                // Change to array of known length\n+                auto tn = tsa.next.toBasetype();\n+                tsa = new TypeSArray(tn, new IntegerExp(Loc.initial, i.dim, Type.tsize_t));\n+                tx = tsa;      // rewrite caller's type\n+                i.type = tsa;  // remember for later passes\n+            }\n+            else\n+            {\n+                uinteger_t edim = tsa.dim.toInteger();\n+                if (i.dim > edim)\n+                {\n+                    error(i.loc, \"array initializer has %u elements, but array length is %llu\", i.dim, edim);\n+                    return err();\n+                }\n             }\n         }\n         if (errors)\n@@ -394,6 +405,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n             error(i.loc, \"array dimension %llu exceeds max of %llu\", ulong(i.dim), ulong(amax / sz));\n             return err();\n         }\n+        //printf(\"returns ai: %s\\n\", i.toChars());\n         return i;\n     }\n \n@@ -661,295 +673,380 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n \n     Initializer visitC(CInitializer ci)\n     {\n-        if (ci.sem) // if semantic() already run\n-            return ci;\n         //printf(\"CInitializer::semantic() (%s) %s\\n\", t.toChars(), ci.toChars());\n-        ci.sem = true;\n+        /* Rewrite CInitializer into ExpInitializer, ArrayInitializer, or StructInitializer\n+         */\n         t = t.toBasetype();\n-        ci.type = t;    // later passes will need this\n-\n-        auto dil = ci.initializerList[];\n-        size_t i = 0;   // index into dil[]\n-        const uint amax = 0x8000_0000;\n-        bool errors;\n \n         /* If `{ expression }` return the expression initializer\n          */\n         ExpInitializer isBraceExpression()\n         {\n+            auto dil = ci.initializerList[];\n             return (dil.length == 1 && !dil[0].designatorList)\n                     ? dil[0].initializer.isExpInitializer()\n                     : null;\n         }\n \n-        /* Convert struct initializer into ExpInitializer\n+        /********************************\n          */\n-        Initializer structs(TypeStruct ts)\n+        bool overlaps(VarDeclaration field, VarDeclaration[] fields, StructInitializer si)\n         {\n-            //printf(\"structs %s\\n\", ts.toChars());\n+            foreach (fld; fields)\n+            {\n+                if (field.isOverlappedWith(fld))\n+                {\n+                    // look for initializer corresponding with fld\n+                    foreach (i, ident; si.field[])\n+                    {\n+                        if (ident == fld.ident && si.value[i])\n+                            return true;   // already an initializer for `field`\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        /* Run semantic on ExpInitializer, see if it represents entire struct ts\n+         */\n+        bool representsStruct(ExpInitializer ei, TypeStruct ts)\n+        {\n+            if (needInterpret)\n+                sc = sc.startCTFE();\n+            ei.exp = ei.exp.expressionSemantic(sc);\n+            ei.exp = resolveProperties(sc, ei.exp);\n+            if (needInterpret)\n+                sc = sc.endCTFE();\n+            return ei.exp.implicitConvTo(ts) != MATCH.nomatch; // initializer represents the entire struct\n+        }\n+\n+        /* If { } are omitted from substructs, use recursion to reconstruct where\n+         * brackets go\n+         * Params:\n+         *  ts = substruct to initialize\n+         *  index = index into ci.initializer, updated\n+         * Returns: struct initializer for this substruct\n+         */\n+        Initializer subStruct()(TypeStruct ts, ref size_t index)\n+        {\n+            //printf(\"subStruct(ts: %s, index %d)\\n\", ts.toChars(), cast(int)index);\n+\n+            auto si = new StructInitializer(ci.loc);\n             StructDeclaration sd = ts.sym;\n             sd.size(ci.loc);\n             if (sd.sizeok != Sizeok.done)\n             {\n-                errors = true;\n+                index = ci.initializerList.length;\n                 return err();\n             }\n-            const nfields = sd.nonHiddenFields();\n-            auto elements = new Expressions(nfields);\n-            auto elems = (*elements)[];\n-            foreach (ref elem; elems)\n-                elem = null;\n+            const nfields = sd.fields.length;\n \n-          FieldLoop:\n-            for (size_t fieldi = 0; fieldi < nfields; ++fieldi)\n+            foreach (fieldi; 0 .. nfields)\n             {\n-                if (i == dil.length)\n-                    break;\n-\n-                auto di = dil[i];\n-                if (di.designatorList)\n+                if (index >= ci.initializerList.length)\n+                    break;          // ran out of initializers\n+                auto di = ci.initializerList[index];\n+                if (di.designatorList && fieldi != 0)\n+                    break;          // back to top level\n+                else\n                 {\n-                    error(ci.loc, \"C designator-list not supported yet\");\n-                    errors = true;\n-                    break;\n+                    VarDeclaration field;\n+                    while (1)   // skip field if it overlaps with previously seen fields\n+                    {\n+                        field = sd.fields[fieldi];\n+                        ++fieldi;\n+                        if (!overlaps(field, sd.fields[], si))\n+                            break;\n+                        if (fieldi == nfields)\n+                            break;\n+                    }\n+                    auto tn = field.type.toBasetype();\n+                    auto tnsa = tn.isTypeSArray();\n+                    auto tns = tn.isTypeStruct();\n+                    auto ix = di.initializer;\n+                    if (tnsa && ix.isExpInitializer())\n+                    {\n+                        ExpInitializer ei = ix.isExpInitializer();\n+                        if (ei.exp.isStringExp() && tnsa.nextOf().isintegral())\n+                        {\n+                            si.addInit(field.ident, ei);\n+                            ++index;\n+                        }\n+                        else\n+                            si.addInit(field.ident, subArray(tnsa, index)); // fwd ref of subArray is why subStruct is a template\n+                    }\n+                    else if (tns && ix.isExpInitializer())\n+                    {\n+                        /* Disambiguate between an exp representing the entire\n+                         * struct, and an exp representing the first field of the struct\n+                         */\n+                        if (representsStruct(ix.isExpInitializer(), tns)) // initializer represents the entire struct\n+                        {\n+                            si.addInit(field.ident, initializerSemantic(ix, sc, tn, needInterpret));\n+                            ++index;\n+                        }\n+                        else                                // field initializers for struct\n+                            si.addInit(field.ident, subStruct(tns, index)); // the first field\n+                    }\n+                    else\n+                    {\n+                        si.addInit(field.ident, ix);\n+                        ++index;\n+                    }\n                 }\n+            }\n+            //printf(\"subStruct() returns ai: %s, index: %d\\n\", si.toChars(), cast(int)index);\n+            return si;\n+        }\n \n-                VarDeclaration vd = sd.fields[fieldi];\n+        /* If { } are omitted from subarrays, use recursion to reconstruct where\n+         * brackets go\n+         * Params:\n+         *  tsa = subarray to initialize\n+         *  index = index into ci.initializer, updated\n+         * Returns: array initializer for this subarray\n+         */\n+        Initializer subArray(TypeSArray tsa, ref size_t index)\n+        {\n+            //printf(\"array(tsa: %s, index %d)\\n\", tsa.toChars(), cast(int)index);\n+            if (tsa.isIncomplete())\n+            {\n+                // C11 6.2.5-20 \"element type shall be complete whenever the array type is specified\"\n+                assert(0); // should have been detected by parser\n+            }\n \n-                // Check for overlapping initializations (can happen with unions)\n-                foreach (k, v2; sd.fields[0 .. nfields])\n+            auto tnsa = tsa.nextOf().toBasetype().isTypeSArray();\n+\n+            auto ai = new ArrayInitializer(ci.loc);\n+            ai.isCarray = true;\n+\n+            foreach (n; 0 .. cast(size_t)tsa.dim.toInteger())\n+            {\n+                if (index >= ci.initializerList.length)\n+                    break;          // ran out of initializers\n+                auto di = ci.initializerList[index];\n+                if (di.designatorList)\n+                    break;          // back to top level\n+                else if (tnsa && di.initializer.isExpInitializer())\n                 {\n-                    if (vd.isOverlappedWith(v2) && elems[k])\n+                    ExpInitializer ei = di.initializer.isExpInitializer();\n+                    if (ei.exp.isStringExp() && tnsa.nextOf().isintegral())\n                     {\n-                        continue FieldLoop;     // skip it\n+                        ai.addInit(null, ei);\n+                        ++index;\n                     }\n+                    else\n+                        ai.addInit(null, subArray(tnsa, index));\n                 }\n-\n-                ++i;\n-\n-                // Convert initializer to Expression `ex`\n-                assert(sc);\n-                auto tm = vd.type.addMod(ts.mod);\n-                auto iz = di.initializer.initializerSemantic(sc, tm, needInterpret);\n-                auto ex = iz.initializerToExpression(null, true);\n-                if (ex.op == EXP.error)\n+                else\n                 {\n-                    errors = true;\n-                    continue;\n+                    ai.addInit(null, di.initializer);\n+                    ++index;\n                 }\n-\n-                elems[fieldi] = ex;\n             }\n-            if (errors)\n-                return err();\n-\n-            // Make a StructLiteralExp out of elements[]\n-            Type tx = ts;\n-            auto sle = new StructLiteralExp(ci.loc, sd, elements, tx);\n-            if (!sd.fill(ci.loc, elements, false))\n-                return err();\n-            sle.type = tx;\n-            auto ie = new ExpInitializer(ci.loc, sle);\n-            return ie.initializerSemantic(sc, tx, needInterpret);\n+            //printf(\"array() returns ai: %s, index: %d\\n\", ai.toChars(), cast(int)index);\n+            return ai;\n         }\n \n         if (auto ts = t.isTypeStruct())\n         {\n-            auto ei = structs(ts);\n-            if (errors)\n-                return err();\n-            if (i < dil.length)\n+            auto si = new StructInitializer(ci.loc);\n+            StructDeclaration sd = ts.sym;\n+            sd.size(ci.loc);            // run semantic() on sd to get fields\n+            if (sd.sizeok != Sizeok.done)\n             {\n-                error(ci.loc, \"%d extra initializer(s) for `struct %s`\", cast(int)(dil.length - i), ts.toChars());\n                 return err();\n             }\n-            return ei;\n-        }\n+            const nfields = sd.fields.length;\n \n-        auto tsa = t.isTypeSArray();\n-        if (!tsa)\n-        {\n-            /* Not an array. See if it is `{ exp }` which can be\n-             * converted to an ExpInitializer\n-             */\n-            if (ExpInitializer ei = isBraceExpression())\n-            {\n-                return ei.initializerSemantic(sc, t, needInterpret);\n-            }\n-\n-            error(ci.loc, \"C non-array initializer (%s) %s not supported yet\", t.toChars(), ci.toChars());\n-            return err();\n-        }\n+            size_t fieldi = 0;\n \n-        /* If it's an array of integral being initialized by `{ string }`\n-         * replace with `string`\n-         */\n-        auto tn = t.nextOf();\n-        if (tn.isintegral())\n-        {\n-            if (ExpInitializer ei = isBraceExpression())\n+            for (size_t index = 0; index < ci.initializerList.length; )\n             {\n-                if (ei.exp.isStringExp())\n-                    return ei.initializerSemantic(sc, t, needInterpret);\n+                auto di = ci.initializerList[index];\n+                auto dlist = di.designatorList;\n+                if (dlist)\n+                {\n+                    const length = (*dlist).length;\n+                    if (length == 0 || !(*dlist)[0].ident)\n+                    {\n+                        error(ci.loc, \"`.identifier` expected for C struct field initializer `%s`\", ci.toChars());\n+                        return err();\n+                    }\n+                    if (length > 1)\n+                    {\n+                        error(ci.loc, \"only 1 designator currently allowed for C struct field initializer `%s`\", ci.toChars());\n+                        return err();\n+                    }\n+                    auto id = (*dlist)[0].ident;\n+                    foreach (k, f; sd.fields[])         // linear search for now\n+                    {\n+                        if (f.ident == id)\n+                        {\n+                            fieldi = k;\n+                            si.addInit(id, di.initializer);\n+                            ++fieldi;\n+                            ++index;\n+                            break;\n+                        }\n+                    }\n+                }\n+                else\n+                {\n+                    if (fieldi == nfields)\n+                        break;\n+                    VarDeclaration field;\n+                    while (1)   // skip field if it overlaps with previously seen fields\n+                    {\n+                        field = sd.fields[fieldi];\n+                        ++fieldi;\n+                        if (!overlaps(field, sd.fields[], si))\n+                            break;\n+                        if (fieldi == nfields)\n+                            break;\n+                    }\n+                    auto tn = field.type.toBasetype();\n+                    auto tnsa = tn.isTypeSArray();\n+                    auto tns = tn.isTypeStruct();\n+                    auto ix = di.initializer;\n+                    if (tnsa && ix.isExpInitializer())\n+                    {\n+                        ExpInitializer ei = ix.isExpInitializer();\n+                        if (ei.exp.isStringExp() && tnsa.nextOf().isintegral())\n+                        {\n+                            si.addInit(field.ident, ei);\n+                            ++index;\n+                        }\n+                        else\n+                            si.addInit(field.ident, subArray(tnsa, index));\n+                    }\n+                    else if (tns && ix.isExpInitializer())\n+                    {\n+                        /* Disambiguate between an exp representing the entire\n+                         * struct, and an exp representing the first field of the struct\n+                         */\n+                        if (representsStruct(ix.isExpInitializer(), tns)) // initializer represents the entire struct\n+                        {\n+                            si.addInit(field.ident, initializerSemantic(ix, sc, tn, needInterpret));\n+                            ++index;\n+                        }\n+                        else                                // field initializers for struct\n+                            si.addInit(field.ident, subStruct(tns, index)); // the first field\n+                    }\n+                    else\n+                    {\n+                        si.addInit(field.ident, di.initializer);\n+                        ++index;\n+                    }\n+                }\n             }\n+            return initializerSemantic(si, sc, t, needInterpret);\n         }\n-\n-        /* Support recursion to handle un-braced array initializers\n-         * Params:\n-         *    t = element type\n-         *    dim = max number of elements\n-         *    simple = true if array of simple elements\n-         * Returns:\n-         *    # of elements in array\n-         */\n-        size_t array(Type t, size_t dim, ref bool simple)\n+        else if (auto ta = t.isTypeSArray())\n         {\n-            //printf(\" type %s i %d dim %d dil.length = %d\\n\", t.toChars(), cast(int)i, cast(int)dim, cast(int)dil.length);\n-            auto tn = t.nextOf().toBasetype();\n-            auto tnsa = tn.isTypeSArray();\n-            if (tnsa && tnsa.isIncomplete())\n-            {\n-                // C11 6.2.5-20 \"element type shall be complete whenever the array type is specified\"\n-                error(ci.loc, \"incomplete element type `%s` not allowed\", tnsa.toChars());\n-                errors = true;\n-                return 1;\n-            }\n-            if (i == dil.length)\n-                return 0;\n-            size_t n;\n-            const nelems = tnsa ? cast(size_t)tnsa.dim.toInteger() : 0;\n+            auto tn = t.nextOf().toBasetype();  // element type of array\n \n-            /* Run initializerSemantic on a single element.\n+            /* If it's an array of integral being initialized by `{ string }`\n+             * replace with `string`\n              */\n-            Initializer elem(Initializer ie)\n+            if (tn.isintegral())\n             {\n-                ++i;\n-                auto tnx = tn; // in case initializerSemantic tries to change it\n-                ie = ie.initializerSemantic(sc, tnx, needInterpret);\n-                if (ie.isErrorInitializer())\n-                    errors = true;\n-                assert(tnx == tn); // sub-types should not be modified\n-                return ie;\n+                if (ExpInitializer ei = isBraceExpression())\n+                {\n+                    if (ei.exp.isStringExp())\n+                        return ei.initializerSemantic(sc, t, needInterpret);\n+                }\n             }\n \n-            foreach (j; 0 .. dim)\n+            auto tnsa = tn.isTypeSArray();      // array of array\n+            auto tns = tn.isTypeStruct();       // array of struct\n+\n+            auto ai = new ArrayInitializer(ci.loc);\n+            ai.isCarray = true;\n+            for (size_t index = 0; index < ci.initializerList.length; )\n             {\n-                auto di = dil[i];\n-                if (di.designatorList)\n-                {\n-                    error(ci.loc, \"C designator-list not supported yet\");\n-                    errors = true;\n-                    break;\n-                }\n-                if (tnsa && di.initializer.isExpInitializer())\n+                auto di = ci.initializerList[index];\n+                if (auto dlist = di.designatorList)\n                 {\n-                    // no braces enclosing array initializer, so recurse\n-                    array(tnsa, nelems, simple);\n-                }\n-                else if (auto tns = tn.isTypeStruct())\n-                {\n-                    if (auto ei = di.initializer.isExpInitializer())\n+                    const length = (*dlist).length;\n+                    if (length == 0 || !(*dlist)[0].exp)\n+                    {\n+                        error(ci.loc, \"`[ constant-expression ]` expected for C array element initializer `%s`\", ci.toChars());\n+                        return err();\n+                    }\n+                    if (length > 1)\n+                    {\n+                        error(ci.loc, \"only 1 designator currently allowed for C array element initializer `%s`\", ci.toChars());\n+                        return err();\n+                    }\n+                    //printf(\"tn: %s, di.initializer: %s\\n\", tn.toChars(), di.initializer.toChars());\n+                    auto ix = di.initializer;\n+                    if (tnsa && ix.isExpInitializer())\n+                    {\n+                        // Wrap initializer in [ ]\n+                        auto ain = new ArrayInitializer(ci.loc);\n+                        ain.addInit(null, di.initializer);\n+                        ix = ain;\n+                        ai.addInit((*dlist)[0].exp, initializerSemantic(ix, sc, tn, needInterpret));\n+                        ++index;\n+                    }\n+                    else if (tns && ix.isExpInitializer())\n                     {\n-                        // no braces enclosing struct initializer\n-\n                         /* Disambiguate between an exp representing the entire\n                          * struct, and an exp representing the first field of the struct\n-                        */\n-                        if (needInterpret)\n-                            sc = sc.startCTFE();\n-                        ei.exp = ei.exp.expressionSemantic(sc);\n-                        ei.exp = resolveProperties(sc, ei.exp);\n-                        if (needInterpret)\n-                            sc = sc.endCTFE();\n-                        if (ei.exp.implicitConvTo(tn))\n-                            di.initializer = elem(di.initializer); // the whole struct\n-                        else\n+                         */\n+                        if (representsStruct(ix.isExpInitializer(), tns)) // initializer represents the entire struct\n                         {\n-                            simple = false;\n-                            dil[n].initializer = structs(tns); // the first field\n+                            ai.addInit((*dlist)[0].exp, initializerSemantic(ix, sc, tn, needInterpret));\n+                            ++index;\n                         }\n+                        else                                // field initializers for struct\n+                            ai.addInit((*dlist)[0].exp, subStruct(tns, index)); // the first field\n+                    }\n+                    else\n+                    {\n+                        ai.addInit((*dlist)[0].exp, initializerSemantic(ix, sc, tn, needInterpret));\n+                        ++index;\n+                    }\n+                }\n+                else if (tnsa && di.initializer.isExpInitializer())\n+                {\n+                    ExpInitializer ei = di.initializer.isExpInitializer();\n+                    if (ei.exp.isStringExp() && tnsa.nextOf().isintegral())\n+                    {\n+                        ai.addInit(null, ei);\n+                        ++index;\n                     }\n                     else\n-                        dil[n].initializer = elem(di.initializer);\n+                        ai.addInit(null, subArray(tnsa, index));\n+                }\n+                else if (tns && di.initializer.isExpInitializer())\n+                {\n+                    /* Disambiguate between an exp representing the entire\n+                     * struct, and an exp representing the first field of the struct\n+                     */\n+                    if (representsStruct(di.initializer.isExpInitializer(), tns)) // initializer represents the entire struct\n+                    {\n+                        ai.addInit(null, initializerSemantic(di.initializer, sc, tn, needInterpret));\n+                        ++index;\n+                    }\n+                    else                                // field initializers for struct\n+                        ai.addInit(null, subStruct(tns, index)); // the first field\n                 }\n                 else\n                 {\n-                    di.initializer = elem(di.initializer);\n+                    ai.addInit(null, initializerSemantic(di.initializer, sc, tn, needInterpret));\n+                    ++index;\n                 }\n-                ++n;\n-                if (i == dil.length)\n-                    break;\n-            }\n-            //printf(\" n: %d i: %d\\n\", cast(int)n, cast(int)i);\n-            return n;\n-        }\n-\n-        size_t dim = tsa.isIncomplete() ? dil.length : cast(size_t)tsa.dim.toInteger();\n-        bool simple = true;\n-        auto newdim = array(t, dim, simple);\n-\n-        if (errors)\n-            return err();\n-\n-        if (tsa.isIncomplete()) // array of unknown length\n-        {\n-            // Change to array of known length\n-            tsa = new TypeSArray(tn, new IntegerExp(Loc.initial, newdim, Type.tsize_t));\n-            tx = tsa;       // rewrite caller's type\n-            ci.type = tsa;  // remember for later passes\n-        }\n-        const uinteger_t edim = tsa.dim.toInteger();\n-        if (i < dil.length)\n-        {\n-            error(ci.loc, \"%d extra initializer(s) for static array length of %d\", cast(int)(dil.length - i), cast(int)edim);\n-            return err();\n-        }\n-\n-        const sz = tn.size(); // element size\n-        if (sz == SIZE_INVALID)\n-            return err();\n-        bool overflow;\n-        const max = mulu(edim, sz, overflow);\n-        if (overflow || max >= amax)\n-        {\n-            error(ci.loc, \"array dimension %llu exceeds max of %llu\", ulong(edim), ulong(amax / sz));\n-            return err();\n-        }\n-\n-        /* If an array of simple elements, replace with an ArrayInitializer\n-         */\n-        auto tnb = tn.toBasetype();\n-        if (!tnb.isTypeSArray() && (!tnb.isTypeStruct() || simple))\n-        {\n-            auto ai = new ArrayInitializer(ci.loc);\n-            ai.dim = cast(uint) dil.length;\n-            ai.index.setDim(dil.length);\n-            ai.value.setDim(dil.length);\n-            foreach (const j; 0 .. dil.length)\n-            {\n-                ai.index[j] = null;\n-                ai.value[j] = dil[j].initializer;\n             }\n-            auto ty = tx;\n-            return ai.initializerSemantic(sc, ty, needInterpret);\n+            return initializerSemantic(ai, sc, tx, needInterpret);\n         }\n-\n-        if (newdim < ci.initializerList.length && tnb.isTypeStruct())\n+        else if (ExpInitializer ei = isBraceExpression())\n+            return visitExp(ei);\n+        else\n         {\n-            // https://issues.dlang.org/show_bug.cgi?id=22375\n-            // initializerList can be bigger than the number of actual elements\n-            // to initialize for array of structs because it is not required\n-            // for values to have proper bracing.\n-            // i.e: These are all valid initializers for `struct{int a,b;}[3]`:\n-            //      {1,2,3,4}, {{1,2},3,4}, {1,2,{3,4}}, {{1,2},{3,4}}\n-            // In all examples above, the new length of the initializer list\n-            // has been shortened from four elements to two. This is important,\n-            // because `dil` is written back to directly, making the lowered\n-            // initializer `{{1,2},{3,4}}` and not `{{1,2},{3,4},3,4}`.\n-            ci.initializerList.length = newdim;\n+            assert(0);\n         }\n-\n-        return ci;\n     }\n \n     final switch (init.kind)"}, {"sha": "1de89d4d6b60e0d0ee25fc45aa4ae3f0a955f5dd", "filename": "gcc/d/dmd/lexer.d", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Flexer.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Flexer.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Flexer.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -2582,8 +2582,13 @@ class Lexer\n         {\n             /* C11 6.4.4.2 doesn't actually care if it is not representable if it is not hex\n              */\n-            const char* suffix = (result == TOK.float32Literal || result == TOK.imaginary32Literal) ? \"f\" : \"\";\n-            error(scanloc, \"number `%s%s` is not representable\", sbufptr, suffix);\n+            const char* suffix = result == TOK.float32Literal ? \"f\" : result == TOK.float80Literal ? \"L\" : \"\";\n+            const char* type = [TOK.float32Literal: \"`float`\".ptr,\n+                                TOK.float64Literal: \"`double`\".ptr,\n+                                TOK.float80Literal: \"`real` for the current target\".ptr][result];\n+            error(scanloc, \"number `%s%s` is not representable as a %s\", sbufptr, suffix, type);\n+            const char* extra = result == TOK.float64Literal ? \"`real` literals can be written using the `L` suffix. \" : \"\";\n+            errorSupplemental(scanloc, \"%shttps://dlang.org/spec/lex.html#floatliteral\", extra);\n         }\n         debug\n         {"}, {"sha": "341ce361f3cc7f8fce709233c67c8c9aee69a7ae", "filename": "gcc/d/dmd/module.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fmodule.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fmodule.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmodule.h?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -37,7 +37,7 @@ class Package : public ScopeDsymbol\n \n     const char *kind() const override;\n \n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n \n     Package *isPackage() override final { return this; }\n "}, {"sha": "1240f5a8a9d40dd489cd16a5e754abe2e18f4743", "filename": "gcc/d/dmd/mtype.d", "status": "modified", "additions": 349, "deletions": 300, "changes": 649, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fmtype.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fmtype.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -936,7 +936,7 @@ extern (C++) abstract class Type : ASTNode\n         else\n         {\n             // If `typeSemantic` succeeded, there may have been deprecations that\n-            // were gagged due the the `startGagging` above.  Run again to display\n+            // were gagged due the `startGagging` above.  Run again to display\n             // those deprecations.  https://issues.dlang.org/show_bug.cgi?id=19107\n             if (global.gaggedWarnings > 0)\n                 typeSemantic(tcopy, loc, sc);\n@@ -4656,7 +4656,7 @@ extern (C++) final class TypeFunction : TypeNext\n                 // suppress early exit if an error message is wanted,\n                 // so we can check any matching args are valid\n                 if (!pMessage)\n-                    goto Nomatch;\n+                    return MATCH.nomatch;\n             }\n             // too many args; no match\n             match = MATCH.convert; // match ... with a \"conversion\" match level\n@@ -4669,7 +4669,7 @@ extern (C++) final class TypeFunction : TypeNext\n             buf.printf(\"too few arguments, expected `%d`, got `%d`\", cast(int)nparams, cast(int)nargs);\n             if (pMessage)\n                 *pMessage = buf.extractChars();\n-            goto Nomatch;\n+            return MATCH.nomatch;\n         }\n \n         foreach (u, p; parameterList)\n@@ -4710,226 +4710,16 @@ extern (C++) final class TypeFunction : TypeNext\n             MATCH m;\n \n             assert(p);\n-            if (u >= nargs)\n-            {\n-                if (p.defaultArg)\n-                    continue;\n-                // try typesafe variadics\n-                goto L1;\n-            }\n+\n+            // One or more arguments remain\n+            if (u < nargs)\n             {\n                 Expression arg = args[u];\n                 assert(arg);\n-                //printf(\"arg: %s, type: %s\\n\", arg.toChars(), arg.type.toChars());\n-\n-                Type targ = arg.type;\n-                Type tprm = wildmatch ? p.type.substWildTo(wildmatch) : p.type;\n-\n-                if (p.isLazy() && tprm.ty == Tvoid && targ.ty != Tvoid)\n-                    m = MATCH.convert;\n-                else\n-                {\n-                    //printf(\"%s of type %s implicitConvTo %s\\n\", arg.toChars(), targ.toChars(), tprm.toChars());\n-                    if (flag)\n-                    {\n-                        // for partial ordering, value is an irrelevant mockup, just look at the type\n-                        m = targ.implicitConvTo(tprm);\n-                    }\n-                    else\n-                    {\n-                        const isRef = p.isReference();\n-\n-                        StructDeclaration argStruct, prmStruct;\n-\n-                        // first look for a copy constructor\n-                        if (arg.isLvalue() && !isRef && targ.ty == Tstruct && tprm.ty == Tstruct)\n-                        {\n-                            // if the argument and the parameter are of the same unqualified struct type\n-                            argStruct = (cast(TypeStruct)targ).sym;\n-                            prmStruct = (cast(TypeStruct)tprm).sym;\n-                        }\n-\n-                        // check if the copy constructor may be called to copy the argument\n-                        if (argStruct && argStruct == prmStruct && argStruct.hasCopyCtor)\n-                        {\n-                            /* this is done by seeing if a call to the copy constructor can be made:\n-                             *\n-                             * typeof(tprm) __copytmp;\n-                             * copytmp.__copyCtor(arg);\n-                             */\n-                            auto tmp = new VarDeclaration(arg.loc, tprm, Identifier.generateId(\"__copytmp\"), null);\n-                            tmp.storage_class = STC.rvalue | STC.temp | STC.ctfe;\n-                            tmp.dsymbolSemantic(sc);\n-                            Expression ve = new VarExp(arg.loc, tmp);\n-                            Expression e = new DotIdExp(arg.loc, ve, Id.ctor);\n-                            e = new CallExp(arg.loc, e, arg);\n-                            //printf(\"e = %s\\n\", e.toChars());\n-                            if(.trySemantic(e, sc))\n-                                m = MATCH.exact;\n-                            else\n-                            {\n-                                if (pMessage)\n-                                {\n-                                    /* https://issues.dlang.org/show_bug.cgi?id=22202\n-                                     *\n-                                     * If a function was deduced by semantic on the CallExp,\n-                                     * it means that resolveFuncCall completed succesfully.\n-                                     * Therefore, there exists a callable copy constructor,\n-                                     * however, it cannot be called because scope constraints\n-                                     * such as purity, safety or nogc.\n-                                     */\n-                                    OutBuffer buf;\n-                                    auto callExp = e.isCallExp();\n-                                    if (auto f = callExp.f)\n-                                    {\n-                                        char[] s;\n-                                        if (!f.isPure && sc.func.setImpure())\n-                                            s ~= \"pure \";\n-                                        if (!f.isSafe() && !f.isTrusted() && sc.setUnsafe())\n-                                            s ~= \"@safe \";\n-                                        if (!f.isNogc && sc.func.setGC())\n-                                            s ~= \"nogc \";\n-                                        if (s)\n-                                        {\n-                                            s[$-1] = '\\0';\n-                                            buf.printf(\"`%s` copy constructor cannot be called from a `%s` context\", f.type.toChars(), s.ptr);\n-                                        }\n-                                        else if (f.isGenerated() && f.isDisabled())\n-                                        {\n-                                            /* https://issues.dlang.org/show_bug.cgi?id=23097\n-                                             * Compiler generated copy constructor failed.\n-                                             */\n-                                            buf.printf(\"generating a copy constructor for `struct %s` failed, therefore instances of it are uncopyable\",\n-                                                       argStruct.toChars());\n-                                        }\n-                                        else\n-                                        {\n-                                            /* Although a copy constructor may exist, no suitable match was found.\n-                                             * i.e: `inout` constructor creates `const` object, not mutable.\n-                                             * Fallback to using the original generic error before bugzilla 22202.\n-                                             */\n-                                            goto Lnocpctor;\n-                                        }\n-                                    }\n-                                    else\n-                                    {\n-                                    Lnocpctor:\n-                                        buf.printf(\"`struct %s` does not define a copy constructor for `%s` to `%s` copies\",\n-                                               argStruct.toChars(), targ.toChars(), tprm.toChars());\n-                                    }\n-\n-                                    *pMessage = buf.extractChars();\n-                                }\n-                                m = MATCH.nomatch;\n-                                goto Nomatch;\n-                            }\n-                        }\n-                        else\n-                        {\n-                            import dmd.dcast : cimplicitConvTo;\n-                            m = (sc && sc.flags & SCOPE.Cfile) ? arg.cimplicitConvTo(tprm) : arg.implicitConvTo(tprm);\n-                        }\n-                    }\n-                    //printf(\"match %d\\n\", m);\n-                }\n-\n-                // Non-lvalues do not match ref or out parameters\n-                if (p.isReference())\n-                {\n-                    // https://issues.dlang.org/show_bug.cgi?id=13783\n-                    // Don't use toBasetype() to handle enum types.\n-                    Type ta = targ;\n-                    Type tp = tprm;\n-                    //printf(\"fparam[%d] ta = %s, tp = %s\\n\", u, ta.toChars(), tp.toChars());\n-\n-                    if (m && !arg.isLvalue())\n-                    {\n-                        if (p.storageClass & STC.out_)\n-                        {\n-                            if (pMessage) *pMessage = getParamError(arg, p);\n-                            goto Nomatch;\n-                        }\n-\n-                        if (arg.op == EXP.string_ && tp.ty == Tsarray)\n-                        {\n-                            if (ta.ty != Tsarray)\n-                            {\n-                                Type tn = tp.nextOf().castMod(ta.nextOf().mod);\n-                                dinteger_t dim = (cast(StringExp)arg).len;\n-                                ta = tn.sarrayOf(dim);\n-                            }\n-                        }\n-                        else if (arg.op == EXP.slice && tp.ty == Tsarray)\n-                        {\n-                            // Allow conversion from T[lwr .. upr] to ref T[upr-lwr]\n-                            if (ta.ty != Tsarray)\n-                            {\n-                                Type tn = ta.nextOf();\n-                                dinteger_t dim = (cast(TypeSArray)tp).dim.toUInteger();\n-                                ta = tn.sarrayOf(dim);\n-                            }\n-                        }\n-                        else if ((p.storageClass & STC.in_) && global.params.previewIn)\n-                        {\n-                            // Allow converting a literal to an `in` which is `ref`\n-                            if (arg.op == EXP.arrayLiteral && tp.ty == Tsarray)\n-                            {\n-                                Type tn = tp.nextOf();\n-                                dinteger_t dim = (cast(TypeSArray)tp).dim.toUInteger();\n-                                ta = tn.sarrayOf(dim);\n-                            }\n-\n-                            // Need to make this a rvalue through a temporary\n-                            m = MATCH.convert;\n-                        }\n-                        else if (global.params.rvalueRefParam != FeatureState.enabled ||\n-                                 p.storageClass & STC.out_ ||\n-                                 !arg.type.isCopyable())  // can't copy to temp for ref parameter\n-                        {\n-                            if (pMessage) *pMessage = getParamError(arg, p);\n-                            goto Nomatch;\n-                        }\n-                        else\n-                        {\n-                            /* in functionParameters() we'll convert this\n-                             * rvalue into a temporary\n-                             */\n-                            m = MATCH.convert;\n-                        }\n-                    }\n-\n-                    /* If the match is not already perfect or if the arg\n-                       is not a lvalue then try the `alias this` chain\n-                       see  https://issues.dlang.org/show_bug.cgi?id=15674\n-                       and https://issues.dlang.org/show_bug.cgi?id=21905\n-                    */\n-                    if (ta != tp || !arg.isLvalue())\n-                    {\n-                        Type firsttab = ta.toBasetype();\n-                        while (1)\n-                        {\n-                            Type tab = ta.toBasetype();\n-                            Type tat = tab.aliasthisOf();\n-                            if (!tat || !tat.implicitConvTo(tprm))\n-                                break;\n-                            if (tat == tab || tat == firsttab)\n-                                break;\n-                            ta = tat;\n-                        }\n-                    }\n-\n-                    /* A ref variable should work like a head-const reference.\n-                     * e.g. disallows:\n-                     *  ref T      <- an lvalue of const(T) argument\n-                     *  ref T[dim] <- an lvalue of const(T[dim]) argument\n-                     */\n-                    if (!ta.constConv(tp))\n-                    {\n-                        if (pMessage) *pMessage = getParamError(arg, p);\n-                        goto Nomatch;\n-                    }\n-                }\n+                m = argumentMatchParameter(this, p, arg, wildmatch, flag, sc, pMessage);\n             }\n+            else if (p.defaultArg)\n+                continue;\n \n             /* prefer matching the element type rather than the array\n              * type when more arguments are present with T[]...\n@@ -4943,100 +4733,33 @@ extern (C++) final class TypeFunction : TypeNext\n             L1:\n                 if (parameterList.varargs == VarArg.typesafe && u + 1 == nparams) // if last varargs param\n                 {\n-                    Type tb = p.type.toBasetype();\n-                    TypeSArray tsa;\n-                    dinteger_t sz;\n-\n-                    switch (tb.ty)\n-                    {\n-                    case Tsarray:\n-                        tsa = cast(TypeSArray)tb;\n-                        sz = tsa.dim.toInteger();\n-                        if (sz != nargs - u)\n-                        {\n-                            if (pMessage)\n-                                // Windows (Vista) OutBuffer.vprintf issue? 2nd argument always zero\n-                                //*pMessage = getMatchError(\"expected %d variadic argument(s), not %d\", sz, nargs - u);\n-                            if (!global.gag || global.params.showGaggedErrors)\n-                            {\n-                                OutBuffer buf;\n-                                buf.printf(\"expected %llu variadic argument(s)\", sz);\n-                                buf.printf(\", not %zu\", nargs - u);\n-                                *pMessage = buf.extractChars();\n-                            }\n-                            goto Nomatch;\n-                        }\n-                        goto case Tarray;\n-                    case Tarray:\n-                        {\n-                            TypeArray ta = cast(TypeArray)tb;\n-                            foreach (arg; args[u .. nargs])\n-                            {\n-                                assert(arg);\n-\n-                                /* If lazy array of delegates,\n-                                 * convert arg(s) to delegate(s)\n-                                 */\n-                                Type tret = p.isLazyArray();\n-                                if (tret)\n-                                {\n-                                    if (ta.next.equals(arg.type))\n-                                        m = MATCH.exact;\n-                                    else if (tret.toBasetype().ty == Tvoid)\n-                                        m = MATCH.convert;\n-                                    else\n-                                    {\n-                                        m = arg.implicitConvTo(tret);\n-                                        if (m == MATCH.nomatch)\n-                                            m = arg.implicitConvTo(ta.next);\n-                                    }\n-                                }\n-                                else\n-                                    m = arg.implicitConvTo(ta.next);\n-\n-                                if (m == MATCH.nomatch)\n-                                {\n-                                    if (pMessage) *pMessage = getParamError(arg, p);\n-                                    goto Nomatch;\n-                                }\n-                                if (m < match)\n-                                    match = m;\n-                            }\n-                            goto Ldone;\n-                        }\n-                    case Tclass:\n-                        // Should see if there's a constructor match?\n-                        // Or just leave it ambiguous?\n-                        goto Ldone;\n-\n-                    default:\n-                        break;\n-                    }\n+                    auto trailingArgs = args[u .. $];\n+                    if (auto vmatch = matchTypeSafeVarArgs(this, p, trailingArgs, pMessage))\n+                        return vmatch < match ? vmatch : match;\n+                    // Error message was already generated in `matchTypeSafeVarArgs`\n+                    return MATCH.nomatch;\n                 }\n-                if (pMessage && u < nargs)\n-                    *pMessage = getParamError(args[u], p);\n-                else if (pMessage)\n+                if (pMessage && u >= nargs)\n                     *pMessage = getMatchError(\"missing argument for parameter #%d: `%s`\",\n                         u + 1, parameterToChars(p, this, false));\n-                goto Nomatch;\n+                // If an error happened previously, `pMessage` was already filled\n+                else if (pMessage && !*pMessage)\n+                    *pMessage = getParamError(args[u], p);\n+\n+                return MATCH.nomatch;\n             }\n             if (m < match)\n                 match = m; // pick worst match\n         }\n \n-    Ldone:\n         if (pMessage && !parameterList.varargs && nargs > nparams)\n         {\n             // all parameters had a match, but there are surplus args\n             *pMessage = getMatchError(\"expected %d argument(s), not %d\", nparams, nargs);\n-            goto Nomatch;\n+            return MATCH.nomatch;\n         }\n         //printf(\"match = %d\\n\", match);\n         return match;\n-\n-    Nomatch:\n-        //printf(\"no match\\n\");\n-        return MATCH.nomatch;\n     }\n \n     /+\n@@ -6194,6 +5917,11 @@ extern (C++) final class TypeClass : Type\n         if (t && t.ty == Tclass)\n         {\n             ClassDeclaration cd = (cast(TypeClass)t).sym;\n+            if (cd.semanticRun < PASS.semanticdone && !cd.isBaseInfoComplete())\n+                cd.dsymbolSemantic(null);\n+            if (sym.semanticRun < PASS.semanticdone && !sym.isBaseInfoComplete())\n+                sym.dsymbolSemantic(null);\n+\n             if (sym.isBaseOf(cd, poffset))\n                 return true;\n         }\n@@ -6355,10 +6083,9 @@ extern (C++) final class TypeTuple : Type\n     extern (D) this(Expressions* exps)\n     {\n         super(Ttuple);\n-        auto arguments = new Parameters();\n+        auto arguments = new Parameters(exps ? exps.dim : 0);\n         if (exps)\n         {\n-            arguments.setDim(exps.dim);\n             for (size_t i = 0; i < exps.dim; i++)\n             {\n                 Expression e = (*exps)[i];\n@@ -7330,3 +7057,325 @@ const(char)* toChars(ScopeRef sr) pure nothrow @nogc @safe\n         return names[sr];\n     }\n }\n+\n+/**\n+ * Used by `callMatch` to check if the copy constructor may be called to\n+ * copy the argument\n+ *\n+ * This is done by seeing if a call to the copy constructor can be made:\n+ * ```\n+ * typeof(tprm) __copytmp;\n+ * copytmp.__copyCtor(arg);\n+ * ```\n+ */\n+private extern(D) bool isCopyConstructorCallable (StructDeclaration argStruct,\n+    Expression arg, Type tprm, Scope* sc, const(char)** pMessage)\n+{\n+    auto tmp = new VarDeclaration(arg.loc, tprm, Identifier.generateId(\"__copytmp\"), null);\n+    tmp.storage_class = STC.rvalue | STC.temp | STC.ctfe;\n+    tmp.dsymbolSemantic(sc);\n+    Expression ve = new VarExp(arg.loc, tmp);\n+    Expression e = new DotIdExp(arg.loc, ve, Id.ctor);\n+    e = new CallExp(arg.loc, e, arg);\n+    //printf(\"e = %s\\n\", e.toChars());\n+    if (.trySemantic(e, sc))\n+        return true;\n+\n+    if (pMessage)\n+    {\n+        /* https://issues.dlang.org/show_bug.cgi?id=22202\n+         *\n+         * If a function was deduced by semantic on the CallExp,\n+         * it means that resolveFuncCall completed succesfully.\n+         * Therefore, there exists a callable copy constructor,\n+         * however, it cannot be called because scope constraints\n+         * such as purity, safety or nogc.\n+         */\n+        OutBuffer buf;\n+        auto callExp = e.isCallExp();\n+        if (auto f = callExp.f)\n+        {\n+            char[] s;\n+            if (!f.isPure && sc.func.setImpure())\n+                s ~= \"pure \";\n+            if (!f.isSafe() && !f.isTrusted() && sc.setUnsafe())\n+                s ~= \"@safe \";\n+            if (!f.isNogc && sc.func.setGC())\n+                s ~= \"nogc \";\n+            if (s)\n+            {\n+                s[$-1] = '\\0';\n+                buf.printf(\"`%s` copy constructor cannot be called from a `%s` context\", f.type.toChars(), s.ptr);\n+            }\n+            else if (f.isGenerated() && f.isDisabled())\n+            {\n+                /* https://issues.dlang.org/show_bug.cgi?id=23097\n+                 * Compiler generated copy constructor failed.\n+                 */\n+                buf.printf(\"generating a copy constructor for `struct %s` failed, therefore instances of it are uncopyable\",\n+                           argStruct.toChars());\n+            }\n+            else\n+            {\n+                /* Although a copy constructor may exist, no suitable match was found.\n+                 * i.e: `inout` constructor creates `const` object, not mutable.\n+                 * Fallback to using the original generic error before bugzilla 22202.\n+                 */\n+                goto Lnocpctor;\n+            }\n+        }\n+        else\n+        {\n+        Lnocpctor:\n+            buf.printf(\"`struct %s` does not define a copy constructor for `%s` to `%s` copies\",\n+                       argStruct.toChars(), arg.type.toChars(), tprm.toChars());\n+        }\n+\n+        *pMessage = buf.extractChars();\n+    }\n+    return false;\n+}\n+\n+/**\n+ * Match a single parameter to an argument.\n+ *\n+ * This function is called by `TypeFunction.callMatch` while iterating over\n+ * the list of parameter. Here we check if `arg` is a match for `p`,\n+ * which is mostly about checking if `arg.type` converts to `p`'s type\n+ * and some check about value reference.\n+ *\n+ * Params:\n+ *   tf = The `TypeFunction`, only used for error reporting\n+ *   p = The parameter of `tf` being matched\n+ *   arg = Argument being passed (bound) to `p`\n+ *   wildmatch = Wild (`inout`) matching level, derived from the full argument list\n+ *   flag = A non-zero value means we're doing a partial ordering check\n+ *          (no value semantic check)\n+ *   sc = Scope we are in\n+ *   pMessage = A buffer to write the error in, or `null`\n+ *\n+ * Returns: Whether `trailingArgs` match `p`.\n+ */\n+private extern(D) MATCH argumentMatchParameter (TypeFunction tf, Parameter p,\n+    Expression arg, ubyte wildmatch, int flag, Scope* sc, const(char)** pMessage)\n+{\n+    //printf(\"arg: %s, type: %s\\n\", arg.toChars(), arg.type.toChars());\n+    MATCH m;\n+    Type targ = arg.type;\n+    Type tprm = wildmatch ? p.type.substWildTo(wildmatch) : p.type;\n+\n+    if (p.isLazy() && tprm.ty == Tvoid && targ.ty != Tvoid)\n+        m = MATCH.convert;\n+    else if (flag)\n+    {\n+        // for partial ordering, value is an irrelevant mockup, just look at the type\n+        m = targ.implicitConvTo(tprm);\n+    }\n+    else\n+    {\n+        const isRef = p.isReference();\n+        StructDeclaration argStruct, prmStruct;\n+\n+        // first look for a copy constructor\n+        if (arg.isLvalue() && !isRef && targ.ty == Tstruct && tprm.ty == Tstruct)\n+        {\n+            // if the argument and the parameter are of the same unqualified struct type\n+            argStruct = (cast(TypeStruct)targ).sym;\n+            prmStruct = (cast(TypeStruct)tprm).sym;\n+        }\n+\n+        // check if the copy constructor may be called to copy the argument\n+        if (argStruct && argStruct == prmStruct && argStruct.hasCopyCtor)\n+        {\n+            if (!isCopyConstructorCallable(argStruct, arg, tprm, sc, pMessage))\n+                return MATCH.nomatch;\n+            m = MATCH.exact;\n+        }\n+        else\n+        {\n+            import dmd.dcast : cimplicitConvTo;\n+            m = (sc && sc.flags & SCOPE.Cfile) ? arg.cimplicitConvTo(tprm) : arg.implicitConvTo(tprm);\n+        }\n+    }\n+\n+    // Non-lvalues do not match ref or out parameters\n+    if (p.isReference())\n+    {\n+        // https://issues.dlang.org/show_bug.cgi?id=13783\n+        // Don't use toBasetype() to handle enum types.\n+        Type ta = targ;\n+        Type tp = tprm;\n+        //printf(\"fparam[%d] ta = %s, tp = %s\\n\", u, ta.toChars(), tp.toChars());\n+\n+        if (m && !arg.isLvalue())\n+        {\n+            if (p.storageClass & STC.out_)\n+            {\n+                if (pMessage) *pMessage = tf.getParamError(arg, p);\n+                return MATCH.nomatch;\n+            }\n+\n+            if (arg.op == EXP.string_ && tp.ty == Tsarray)\n+            {\n+                if (ta.ty != Tsarray)\n+                {\n+                    Type tn = tp.nextOf().castMod(ta.nextOf().mod);\n+                    dinteger_t dim = (cast(StringExp)arg).len;\n+                    ta = tn.sarrayOf(dim);\n+                }\n+            }\n+            else if (arg.op == EXP.slice && tp.ty == Tsarray)\n+            {\n+                // Allow conversion from T[lwr .. upr] to ref T[upr-lwr]\n+                if (ta.ty != Tsarray)\n+                {\n+                    Type tn = ta.nextOf();\n+                    dinteger_t dim = (cast(TypeSArray)tp).dim.toUInteger();\n+                    ta = tn.sarrayOf(dim);\n+                }\n+            }\n+            else if ((p.storageClass & STC.in_) && global.params.previewIn)\n+            {\n+                // Allow converting a literal to an `in` which is `ref`\n+                if (arg.op == EXP.arrayLiteral && tp.ty == Tsarray)\n+                {\n+                    Type tn = tp.nextOf();\n+                    dinteger_t dim = (cast(TypeSArray)tp).dim.toUInteger();\n+                    ta = tn.sarrayOf(dim);\n+                }\n+\n+                // Need to make this a rvalue through a temporary\n+                m = MATCH.convert;\n+            }\n+            else if (global.params.rvalueRefParam != FeatureState.enabled ||\n+                     p.storageClass & STC.out_ ||\n+                     !arg.type.isCopyable())  // can't copy to temp for ref parameter\n+            {\n+                if (pMessage) *pMessage = tf.getParamError(arg, p);\n+                return MATCH.nomatch;\n+            }\n+            else\n+            {\n+                /* in functionParameters() we'll convert this\n+                 * rvalue into a temporary\n+                 */\n+                m = MATCH.convert;\n+            }\n+        }\n+\n+        /* If the match is not already perfect or if the arg\n+           is not a lvalue then try the `alias this` chain\n+           see  https://issues.dlang.org/show_bug.cgi?id=15674\n+           and https://issues.dlang.org/show_bug.cgi?id=21905\n+        */\n+        if (ta != tp || !arg.isLvalue())\n+        {\n+            Type firsttab = ta.toBasetype();\n+            while (1)\n+            {\n+                Type tab = ta.toBasetype();\n+                Type tat = tab.aliasthisOf();\n+                if (!tat || !tat.implicitConvTo(tprm))\n+                    break;\n+                if (tat == tab || tat == firsttab)\n+                    break;\n+                ta = tat;\n+            }\n+        }\n+\n+        /* A ref variable should work like a head-const reference.\n+         * e.g. disallows:\n+         *  ref T      <- an lvalue of const(T) argument\n+         *  ref T[dim] <- an lvalue of const(T[dim]) argument\n+         */\n+        if (!ta.constConv(tp))\n+        {\n+            if (pMessage) *pMessage = tf.getParamError(arg, p);\n+            return MATCH.nomatch;\n+        }\n+    }\n+    return m;\n+}\n+\n+/**\n+ * Match the remaining arguments `trailingArgs` with parameter `p`.\n+ *\n+ * Assume we already checked that `p` is the last parameter of `tf`,\n+ * and we want to know whether the arguments would match `p`.\n+ *\n+ * Params:\n+ *   tf = The `TypeFunction`, only used for error reporting\n+ *   p = The last parameter of `tf` which is variadic\n+ *   trailingArgs = The remaining arguments that should match `p`\n+ *   pMessage = A buffer to write the error in, or `null`\n+ *\n+ * Returns: Whether `trailingArgs` match `p`.\n+ */\n+private extern(D) MATCH matchTypeSafeVarArgs(TypeFunction tf, Parameter p,\n+    Expression[] trailingArgs, const(char)** pMessage)\n+{\n+    Type tb = p.type.toBasetype();\n+\n+    switch (tb.ty)\n+    {\n+    case Tsarray:\n+        TypeSArray tsa = cast(TypeSArray)tb;\n+        dinteger_t sz = tsa.dim.toInteger();\n+        if (sz != trailingArgs.length)\n+        {\n+            if (pMessage)\n+                *pMessage = tf.getMatchError(\"expected %llu variadic argument(s), not %zu\",\n+                    sz, trailingArgs.length);\n+            return MATCH.nomatch;\n+        }\n+        goto case Tarray;\n+    case Tarray:\n+    {\n+        MATCH match = MATCH.exact;\n+        TypeArray ta = cast(TypeArray)tb;\n+        foreach (arg; trailingArgs)\n+        {\n+            MATCH m;\n+            assert(arg);\n+\n+            /* If lazy array of delegates,\n+             * convert arg(s) to delegate(s)\n+             */\n+            Type tret = p.isLazyArray();\n+            if (tret)\n+            {\n+                if (ta.next.equals(arg.type))\n+                    m = MATCH.exact;\n+                else if (tret.toBasetype().ty == Tvoid)\n+                    m = MATCH.convert;\n+                else\n+                {\n+                    m = arg.implicitConvTo(tret);\n+                    if (m == MATCH.nomatch)\n+                        m = arg.implicitConvTo(ta.next);\n+                }\n+            }\n+            else\n+                m = arg.implicitConvTo(ta.next);\n+\n+            if (m == MATCH.nomatch)\n+            {\n+                if (pMessage) *pMessage = tf.getParamError(arg, p);\n+                return MATCH.nomatch;\n+            }\n+            if (m < match)\n+                match = m;\n+        }\n+        return match;\n+    }\n+    case Tclass:\n+        // We leave it up to the actual constructor call to do the matching.\n+        return MATCH.exact;\n+\n+    default:\n+        // We can have things as `foo(int[int] wat...)` but they only match\n+        // with an associative array proper.\n+        if (pMessage && trailingArgs.length) *pMessage = tf.getParamError(trailingArgs[0], p);\n+        return MATCH.nomatch;\n+    }\n+}"}, {"sha": "2b9c94cf7f2f0ed63b5d0f98388faed2605a4ce2", "filename": "gcc/d/dmd/mtype.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fmtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fmtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.h?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -221,7 +221,7 @@ class Type : public ASTNode\n     virtual const char *kind();\n     Type *copy() const;\n     virtual Type *syntaxCopy();\n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n     bool equivalent(Type *t);\n     // kludge for template.isType()\n     DYNCAST dyncast() const override final { return DYNCAST_TYPE; }\n@@ -877,7 +877,7 @@ class TypeTuple final : public Type\n     static TypeTuple *create(Type *t1, Type *t2);\n     const char *kind() override;\n     TypeTuple *syntaxCopy() override;\n-    bool equals(const RootObject *o) const override;\n+    bool equals(const RootObject * const o) const override;\n     void accept(Visitor *v) override { v->visit(this); }\n };\n "}, {"sha": "ca99b8bdc36e617910a39d82ac271da08806f85c", "filename": "gcc/d/dmd/opover.d", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fopover.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fopover.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fopover.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1247,13 +1247,10 @@ Expression op_overload(Expression e, Scope* sc, EXP* pop = null)\n                 args2[0] = e.e2;\n                 expandTuples(&args2);\n                 MatchAccumulator m;\n-                if (s)\n+                functionResolve(m, s, e.loc, sc, tiargs, e.e1.type, &args2);\n+                if (m.lastf && (m.lastf.errors || m.lastf.hasSemantic3Errors()))\n                 {\n-                    functionResolve(m, s, e.loc, sc, tiargs, e.e1.type, &args2);\n-                    if (m.lastf && (m.lastf.errors || m.lastf.hasSemantic3Errors()))\n-                    {\n-                        return ErrorExp.get();\n-                    }\n+                    return ErrorExp.get();\n                 }\n                 if (m.count > 1)\n                 {"}, {"sha": "ed85a5de96aad0a07f995a01a90ba0b9fb9ad87e", "filename": "gcc/d/dmd/parse.d", "status": "modified", "additions": 71, "deletions": 31, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -2756,7 +2756,6 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n     {\n         auto parameters = new AST.Parameters();\n         VarArg varargs = VarArg.none;\n-        int hasdefault = 0;\n         StorageClass varargsStc;\n \n         // Attributes allowed for ...\n@@ -2921,40 +2920,30 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n                         //if ((storageClass & STC.scope_) && (storageClass & (STC.ref_ | STC.out_)))\n                             //error(\"scope cannot be ref or out\");\n \n-                        if (tpl && token.value == TOK.identifier)\n+                        const tv = peekNext();\n+                        if (tpl && token.value == TOK.identifier &&\n+                            (tv == TOK.comma || tv == TOK.rightParenthesis || tv == TOK.dotDotDot))\n                         {\n-                            const tv = peekNext();\n-                            if (tv == TOK.comma || tv == TOK.rightParenthesis || tv == TOK.dotDotDot)\n-                            {\n-                                Identifier id = Identifier.generateId(\"__T\");\n-                                const loc = token.loc;\n-                                at = new AST.TypeIdentifier(loc, id);\n-                                if (!*tpl)\n-                                    *tpl = new AST.TemplateParameters();\n-                                AST.TemplateParameter tp = new AST.TemplateTypeParameter(loc, id, null, null);\n-                                (*tpl).push(tp);\n-\n-                                ai = token.ident;\n-                                nextToken();\n-                            }\n-                            else goto _else;\n+                            Identifier id = Identifier.generateId(\"__T\");\n+                            const loc = token.loc;\n+                            at = new AST.TypeIdentifier(loc, id);\n+                            if (!*tpl)\n+                                *tpl = new AST.TemplateParameters();\n+                            AST.TemplateParameter tp = new AST.TemplateTypeParameter(loc, id, null, null);\n+                            (*tpl).push(tp);\n+\n+                            ai = token.ident;\n+                            nextToken();\n                         }\n                         else\n                         {\n-                        _else:\n                             at = parseType(&ai);\n                         }\n                         ae = null;\n                         if (token.value == TOK.assign) // = defaultArg\n                         {\n                             nextToken();\n                             ae = parseDefaultInitExp();\n-                            hasdefault = 1;\n-                        }\n-                        else\n-                        {\n-                            if (hasdefault)\n-                                error(\"default argument expected for `%s`\", ai ? ai.toChars() : at.toChars());\n                         }\n                         auto param = new AST.Parameter(storageClass | STC.parameter, at, ai, ae, null);\n                         if (udas)\n@@ -4484,7 +4473,6 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n \n             const loc = token.loc;\n             Identifier ident;\n-\n             auto t = parseDeclarator(ts, alt, &ident, &tpl, storage_class, &disable, &udas);\n             assert(t);\n             if (!tfirst)\n@@ -4868,6 +4856,10 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n                     token.value == TOK.identifier && peekNext() == TOK.goesTo ||\n                     token.value == TOK.ref_ && peekNext() == TOK.leftParenthesis &&\n                         skipAttributes(peekPastParen(peek(&token)), &tk) &&\n+                        (tk.value == TOK.goesTo || tk.value == TOK.leftCurly) ||\n+                    token.value == TOK.auto_ && peekNext() == TOK.ref_ &&\n+                        peekNext2() == TOK.leftParenthesis &&\n+                        skipAttributes(peekPastParen(peek(peek(&token))), &tk) &&\n                         (tk.value == TOK.goesTo || tk.value == TOK.leftCurly)\n                    )\n                 {\n@@ -4879,6 +4871,8 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n                     // identifier => expression\n                     // ref (parameters) { statements... }\n                     // ref (parameters) => expression\n+                    // auto ref (parameters) { statements... }\n+                    // auto ref (parameters) => expression\n \n                     s = parseFunctionLiteral();\n \n@@ -5006,7 +5000,20 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n         case TOK.delegate_:\n             save = token.value;\n             nextToken();\n-            if (token.value == TOK.ref_)\n+            if (token.value == TOK.auto_)\n+            {\n+                nextToken();\n+                if (token.value == TOK.ref_)\n+                {\n+                    // function auto ref (parameters) { statements... }\n+                    // delegate auto ref (parameters) { statements... }\n+                    stc = STC.auto_ | STC.ref_;\n+                    nextToken();\n+                }\n+                else\n+                    error(\"`auto` can only be used as part of `auto ref` for function literal return values\");\n+            }\n+            else if (token.value == TOK.ref_)\n             {\n                 // function ref (parameters) { statements... }\n                 // delegate ref (parameters) { statements... }\n@@ -5034,6 +5041,20 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n             }\n             goto case TOK.leftParenthesis;\n \n+        case TOK.auto_:\n+            {\n+                nextToken();\n+                if (token.value == TOK.ref_)\n+                {\n+                    // auto ref (parameters) => expression\n+                    // auto ref (parameters) { statements... }\n+                    stc = STC.auto_ | STC.ref_;\n+                    nextToken();\n+                }\n+                else\n+                    error(\"`auto` can only be used as part of `auto ref` for function literal return values\");\n+                goto case TOK.leftParenthesis;\n+            }\n         case TOK.ref_:\n             {\n                 // ref (parameters) => expression\n@@ -5086,7 +5107,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n \n         auto tf = new AST.TypeFunction(parameterList, tret, linkage, stc);\n         tf = cast(AST.TypeFunction)tf.addSTC(stc);\n-        auto fd = new AST.FuncLiteralDeclaration(loc, Loc.initial, tf, save, null);\n+        auto fd = new AST.FuncLiteralDeclaration(loc, Loc.initial, tf, save, null, null, stc & STC.auto_);\n \n         if (token.value == TOK.goesTo)\n         {\n@@ -5209,7 +5230,9 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n             }\n             else\n             {\n-                f.frequires.push(parseStatement(ParseStatementFlags.curly | ParseStatementFlags.scope_));\n+                auto ret = parseStatement(ParseStatementFlags.curly | ParseStatementFlags.scope_);\n+                assert(ret);\n+                f.frequires.push(ret);\n                 requireDo = true;\n             }\n             goto L1;\n@@ -6550,7 +6573,7 @@ LagainStc:\n                 nextToken();\n             if (token.value == TOK.semicolon)\n                 nextToken();\n-            s = null;\n+            s = new AST.ErrorStatement;\n             break;\n         }\n         if (pEndloc)\n@@ -8394,6 +8417,22 @@ LagainStc:\n             e = parseNewExp(null);\n             break;\n \n+        case TOK.auto_:\n+            {\n+                if (peekNext() == TOK.ref_ && peekNext2() == TOK.leftParenthesis)\n+                {\n+                    Token* tk = peekPastParen(peek(peek(&token)));\n+                    if (skipAttributes(tk, &tk) && (tk.value == TOK.goesTo || tk.value == TOK.leftCurly))\n+                    {\n+                        // auto ref (arguments) => expression\n+                        // auto ref (arguments) { statements... }\n+                        goto case_delegate;\n+                    }\n+                }\n+                nextToken();\n+                error(\"found `%s` when expecting `ref` and function literal following `auto`\", token.toChars());\n+                goto Lerr;\n+            }\n         case TOK.ref_:\n             {\n                 if (peekNext() == TOK.leftParenthesis)\n@@ -8630,7 +8669,7 @@ LagainStc:\n                     if (token.value != TOK.identifier)\n                     {\n                         error(\"identifier expected following `(type)`.\");\n-                        return null;\n+                        return AST.ErrorExp.get();\n                     }\n                     e = new AST.DotIdExp(loc, new AST.TypeExp(loc, t), token.ident);\n                     nextToken();\n@@ -8749,7 +8788,8 @@ LagainStc:\n                                     if (peekNext() != TOK.identifier && peekNext() != TOK.new_)\n                                     {\n                                         error(\"identifier or new keyword expected following `(...)`.\");\n-                                        return null;\n+                                        nextToken();\n+                                        return AST.ErrorExp.get();\n                                     }\n                                     e = new AST.TypeExp(loc, t);\n                                     e.parens = true;"}, {"sha": "b735dd98728ffcd5273755d8f0d3d924b9696294", "filename": "gcc/d/dmd/root/object.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Froot%2Fobject.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Froot%2Fobject.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fobject.h?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -39,7 +39,7 @@ class RootObject\n public:\n     RootObject() { }\n \n-    virtual bool equals(const RootObject *o) const;\n+    virtual bool equals(const RootObject * const o) const;\n \n     /**\n      * Pretty-print an Object. Useful for debugging the old-fashioned way."}, {"sha": "d2f9c0ab04b0b7e45c908fe60c781cfd31c32c2d", "filename": "gcc/d/dmd/semantic3.d", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fsemantic3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Fsemantic3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsemantic3.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -167,11 +167,18 @@ private extern(C++) final class Semantic3Visitor : Visitor\n \n         sc = sc.push(tmix.argsym);\n         sc = sc.push(tmix);\n+\n+        uint olderrors = global.errors;\n+\n         for (size_t i = 0; i < tmix.members.dim; i++)\n         {\n             Dsymbol s = (*tmix.members)[i];\n             s.semantic3(sc);\n         }\n+\n+        if (global.errors != olderrors)\n+            errorSupplemental(tmix.loc, \"parent scope from here: `mixin %s`\", tmix.toChars());\n+\n         sc = sc.pop();\n         sc.pop();\n     }\n@@ -969,6 +976,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n             /* Do the semantic analysis on the [in] preconditions and\n              * [out] postconditions.\n              */\n+            immutable bool isnothrow = f.isnothrow && !(funcdecl.flags & FUNCFLAG.nothrowInprocess);\n             if (freq)\n             {\n                 /* frequire is composed of the [in] contracts\n@@ -980,10 +988,22 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                 sc2.flags = (sc2.flags & ~SCOPE.contract) | SCOPE.require;\n \n                 // BUG: need to error if accessing out parameters\n-                // BUG: need to disallow returns and throws\n+                // BUG: need to disallow returns\n                 // BUG: verify that all in and ref parameters are read\n                 freq = freq.statementSemantic(sc2);\n-                freq.blockExit(funcdecl, false);\n+\n+                // @@@DEPRECATED_2.111@@@ - pass `isnothrow` instead of `false` to print a more detailed error msg`\n+                const blockExit = freq.blockExit(funcdecl, false);\n+                if (blockExit & BE.throw_)\n+                {\n+                    if (isnothrow)\n+                        // @@@DEPRECATED_2.111@@@\n+                        // Deprecated in 2.101, can be made an error in 2.111\n+                        deprecation(funcdecl.loc, \"`%s`: `in` contract may throw but function is marked as `nothrow`\",\n+                            funcdecl.toPrettyChars());\n+                    else if (funcdecl.flags & FUNCFLAG.nothrowInprocess)\n+                        f.isnothrow = false;\n+                }\n \n                 funcdecl.flags &= ~FUNCFLAG.noEH;\n \n@@ -992,6 +1012,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                 if (global.params.useIn == CHECKENABLE.off)\n                     freq = null;\n             }\n+\n             if (fens)\n             {\n                 /* fensure is composed of the [out] contracts\n@@ -1017,7 +1038,19 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                     funcdecl.buildResultVar(scout, f.next);\n \n                 fens = fens.statementSemantic(sc2);\n-                fens.blockExit(funcdecl, false);\n+\n+                // @@@DEPRECATED_2.111@@@ - pass `isnothrow` instead of `false` to print a more detailed error msg`\n+                const blockExit = fens.blockExit(funcdecl, false);\n+                if (blockExit & BE.throw_)\n+                {\n+                    if (isnothrow)\n+                        // @@@DEPRECATED_2.111@@@\n+                        // Deprecated in 2.101, can be made an error in 2.111\n+                        deprecation(funcdecl.loc, \"`%s`: `out` contract may throw but function is marked as `nothrow`\",\n+                            funcdecl.toPrettyChars());\n+                    else if (funcdecl.flags & FUNCFLAG.nothrowInprocess)\n+                        f.isnothrow = false;\n+                }\n \n                 funcdecl.flags &= ~FUNCFLAG.noEH;\n \n@@ -1144,7 +1177,6 @@ private extern(C++) final class Semantic3Visitor : Visitor\n \n                             s = s.statementSemantic(sc2);\n \n-                            immutable bool isnothrow = f.isnothrow && !(funcdecl.flags & FUNCFLAG.nothrowInprocess);\n                             const blockexit = s.blockExit(funcdecl, isnothrow);\n                             if (blockexit & BE.throw_)\n                             {"}, {"sha": "0d7240f4ef44a11c3388eeb4ff767ae17bffcb38", "filename": "gcc/d/dmd/transitivevisitor.d", "status": "modified", "additions": 35, "deletions": 38, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Ftransitivevisitor.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Ftransitivevisitor.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftransitivevisitor.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -28,6 +28,7 @@ extern(C++) class ParseTimeTransitiveVisitor(AST) : PermissiveVisitor!AST\n  */\n package mixin template ParseVisitMethods(AST)\n {\n+    import dmd.root.array;\n \n //   Statement Nodes\n //===========================================================\n@@ -46,7 +47,7 @@ package mixin template ParseVisitMethods(AST)\n     override void visit(AST.CompileStatement s)\n     {\n         //printf(\"Visiting CompileStatement\\n\");\n-        visitArgs(s.exps);\n+        visitArgs(s.exps.peekSlice());\n     }\n \n     override void visit(AST.CompoundStatement s)\n@@ -181,11 +182,9 @@ package mixin template ParseVisitMethods(AST)\n             s.elsebody.accept(this);\n     }\n \n-    void visitArgs(AST.Expressions* expressions, AST.Expression basis = null)\n+    private extern(D) void visitArgs(AST.Expression[] expressions, AST.Expression basis = null)\n     {\n-        if (!expressions || !expressions.dim)\n-            return;\n-        foreach (el; *expressions)\n+        foreach (el; expressions)\n         {\n             if (!el)\n                 el = basis;\n@@ -197,8 +196,7 @@ package mixin template ParseVisitMethods(AST)\n     override void visit(AST.PragmaStatement s)\n     {\n         //printf(\"Visiting PragmaStatement\\n\");\n-        if (s.args && s.args.dim)\n-            visitArgs(s.args);\n+        visitArgs(s.args.peekSlice());\n         if (s._body)\n             s._body.accept(this);\n     }\n@@ -346,19 +344,14 @@ package mixin template ParseVisitMethods(AST)\n             foreach (p; *td.origParameters)\n                 p.accept(this);\n         }\n-        visitParameters(t.parameterList.parameters);\n+        visitParameters(t.parameterList.parameters.peekSlice());\n     }\n \n-    void visitParameters(AST.Parameters* parameters)\n+    private extern(D) final void visitParameters(AST.Parameter[] parameters)\n     {\n-        if (parameters)\n+        foreach (i; 0 .. parameters.length)\n         {\n-            size_t dim = AST.Parameter.dim(parameters);\n-            foreach(i; 0..dim)\n-            {\n-                AST.Parameter fparam = AST.Parameter.getNth(parameters, i);\n-                fparam.accept(this);\n-            }\n+            parameters[i].accept(this);\n         }\n     }\n \n@@ -469,7 +462,7 @@ package mixin template ParseVisitMethods(AST)\n     override void visit(AST.TypeTuple t)\n     {\n         //printf(\"Visiting TypeTuple\\n\");\n-        visitParameters(t.arguments);\n+        visitParameters(t.arguments.peekSlice());\n     }\n \n     override void visit(AST.TypeSlice t)\n@@ -487,7 +480,7 @@ package mixin template ParseVisitMethods(AST)\n \n     override void visit(AST.TypeMixin t)\n     {\n-        visitArgs(t.exps);\n+        visitArgs(t.exps.peekSlice());\n     }\n \n //      Miscellaneous\n@@ -571,33 +564,30 @@ package mixin template ParseVisitMethods(AST)\n     override void visit(AST.PragmaDeclaration d)\n     {\n         //printf(\"Visiting PragmaDeclaration\\n\");\n-        if (d.args && d.args.dim)\n-            visitArgs(d.args);\n+        visitArgs(d.args.peekSlice());\n         visitAttribDeclaration(cast(AST.AttribDeclaration)d);\n     }\n \n     override void visit(AST.ConditionalDeclaration d)\n     {\n         //printf(\"Visiting ConditionalDeclaration\\n\");\n         d.condition.accept(this);\n-        if (d.decl)\n-            foreach (de; *d.decl)\n-                de.accept(this);\n-        if (d.elsedecl)\n-            foreach (de; *d.elsedecl)\n-                de.accept(this);\n+        foreach (de; d.decl.peekSlice())\n+            de.accept(this);\n+        foreach (de; d.elsedecl.peekSlice())\n+            de.accept(this);\n     }\n \n     override void visit(AST.CompileDeclaration d)\n     {\n         //printf(\"Visiting compileDeclaration\\n\");\n-        visitArgs(d.exps);\n+        visitArgs(d.exps.peekSlice());\n     }\n \n     override void visit(AST.UserAttributeDeclaration d)\n     {\n         //printf(\"Visiting UserAttributeDeclaration\\n\");\n-        visitArgs(d.atts);\n+        visitArgs(d.atts.peekSlice());\n         visitAttribDeclaration(cast(AST.AttribDeclaration)d);\n     }\n \n@@ -791,6 +781,15 @@ package mixin template ParseVisitMethods(AST)\n             s.accept(this);\n     }\n \n+    override void visit(AST.UnionDeclaration d)\n+    {\n+        //printf(\"Visiting UnionDeclaration\\n\");\n+        if (!d.members)\n+            return;\n+        foreach (s; *d.members)\n+            s.accept(this);\n+    }\n+\n     override void visit(AST.ClassDeclaration d)\n     {\n         //printf(\"Visiting ClassDeclaration\\n\");\n@@ -840,7 +839,7 @@ package mixin template ParseVisitMethods(AST)\n         auto tf = f.type.isTypeFunction();\n         if (!f.inferRetType && tf.next)\n             visitType(tf.next);\n-        visitParameters(tf.parameterList.parameters);\n+        visitParameters(tf.parameterList.parameters.peekSlice());\n         AST.CompoundStatement cs = f.fbody.isCompoundStatement();\n         AST.Statement s = !cs ? f.fbody : null;\n         AST.ReturnStatement rs = s ? s.isReturnStatement() : null;\n@@ -946,7 +945,7 @@ package mixin template ParseVisitMethods(AST)\n     override void visit(AST.ArrayLiteralExp e)\n     {\n         //printf(\"Visiting ArrayLiteralExp\\n\");\n-        visitArgs(e.elements, e.basis);\n+        visitArgs(e.elements.peekSlice(), e.basis);\n     }\n \n     override void visit(AST.AssocArrayLiteralExp e)\n@@ -978,17 +977,15 @@ package mixin template ParseVisitMethods(AST)\n         if (e.thisexp)\n             e.thisexp.accept(this);\n         visitType(e.newtype);\n-        if (e.arguments && e.arguments.dim)\n-            visitArgs(e.arguments);\n+        visitArgs(e.arguments.peekSlice());\n     }\n \n     override void visit(AST.NewAnonClassExp e)\n     {\n         //printf(\"Visiting NewAnonClassExp\\n\");\n         if (e.thisexp)\n             e.thisexp.accept(this);\n-        if (e.arguments && e.arguments.dim)\n-            visitArgs(e.arguments);\n+        visitArgs(e.arguments.peekSlice());\n         if (e.cd)\n             e.cd.accept(this);\n     }\n@@ -998,7 +995,7 @@ package mixin template ParseVisitMethods(AST)\n         //printf(\"Visiting TupleExp\\n\");\n         if (e.e0)\n             e.e0.accept(this);\n-        visitArgs(e.exps);\n+        visitArgs(e.exps.peekSlice());\n     }\n \n     override void visit(AST.FuncExp e)\n@@ -1056,7 +1053,7 @@ package mixin template ParseVisitMethods(AST)\n     override void visit(AST.MixinExp e)\n     {\n         //printf(\"Visiting MixinExp\\n\");\n-        visitArgs(e.exps);\n+        visitArgs(e.exps.peekSlice());\n     }\n \n     override void visit(AST.ImportExp e)\n@@ -1090,7 +1087,7 @@ package mixin template ParseVisitMethods(AST)\n     {\n         //printf(\"Visiting CallExp\\n\");\n         e.e1.accept(this);\n-        visitArgs(e.arguments);\n+        visitArgs(e.arguments.peekSlice());\n     }\n \n     override void visit(AST.PtrExp e)\n@@ -1124,7 +1121,7 @@ package mixin template ParseVisitMethods(AST)\n     {\n         //printf(\"Visiting ArrayExp\\n\");\n         e.e1.accept(this);\n-        visitArgs(e.arguments);\n+        visitArgs(e.arguments.peekSlice());\n     }\n \n     override void visit(AST.PostExp e)"}, {"sha": "0ef77052ec8e8a6231a50069736682801b4c4af3", "filename": "gcc/d/dmd/typesem.d", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Ftypesem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fdmd%2Ftypesem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftypesem.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1388,6 +1388,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n             // extended index), as we need to run semantic when `oidx` changes.\n             size_t tupleOrigIdx = size_t.max;\n             size_t tupleExtIdx = size_t.max;\n+            bool hasDefault;\n             foreach (oidx, oparam, eidx, eparam; tf.parameterList)\n             {\n                 // oparam (original param) will always have the default arg\n@@ -1396,6 +1397,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                 // position to get the offset in it later on.\n                 if (oparam.defaultArg)\n                 {\n+                    hasDefault = true;\n                     // Get the obvious case out of the way\n                     if (oparam is eparam)\n                         errors |= !defaultArgSemantic(eparam, argsc);\n@@ -1422,6 +1424,11 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                             eparam.defaultArg = (*te.exps)[eidx - tupleExtIdx];\n                     }\n                 }\n+                else if (hasDefault)\n+                {\n+                    .error(loc, \"default argument expected for `%s`\", oparam.toChars());\n+                    errors = true;\n+                }\n \n                 // We need to know the default argument to resolve `auto ref`,\n                 // hence why this has to take place as the very last step.\n@@ -2089,10 +2096,12 @@ extern (C++) Type merge(Type type)\n  *  loc = the location where the property is encountered\n  *  ident = the identifier of the property\n  *  flag = if flag & 1, don't report \"not a property\" error and just return NULL.\n+ *  src = expression for type `t` or null.\n  * Returns:\n  *      expression representing the property, or null if not a property and (flag & 1)\n  */\n-Expression getProperty(Type t, Scope* scope_, const ref Loc loc, Identifier ident, int flag)\n+Expression getProperty(Type t, Scope* scope_, const ref Loc loc, Identifier ident, int flag,\n+    Expression src = null)\n {\n     Expression visitType(Type mt)\n     {\n@@ -2169,7 +2178,10 @@ Expression getProperty(Type t, Scope* scope_, const ref Loc loc, Identifier iden\n                         error(loc, \"no property `%s` for type `%s`, perhaps `import %.*s;` is needed?\", ident.toChars(), mt.toChars(), cast(int)n.length, n.ptr);\n                 else\n                 {\n-                    error(loc, \"no property `%s` for type `%s`\", ident.toChars(), mt.toPrettyChars(true));\n+                    if (src)\n+                        error(loc, \"no property `%s` for `%s` of type `%s`\", ident.toChars(), src.toChars(), mt.toPrettyChars(true));\n+                    else\n+                        error(loc, \"no property `%s` for type `%s`\", ident.toChars(), mt.toPrettyChars(true));\n                     if (auto dsym = mt.toDsymbol(scope_))\n                         if (auto sym = dsym.isAggregateDeclaration())\n                         {\n@@ -4457,7 +4469,7 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n \n \n /************************\n- * Get the the default initialization expression for a type.\n+ * Get the default initialization expression for a type.\n  * Params:\n  *  mt = the type for which the init expression is returned\n  *  loc = the location where the expression needs to be evaluated"}, {"sha": "fa5ec90a2bccb194035c509f9ddb302ec417dc07", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -908,21 +908,12 @@ class ExprVisitor : public Visitor\n \n \t    if ((postblit || destructor) && e->op != EXP::blit)\n \t      {\n-\t\t/* Need to call postblit/destructor as part of assignment.\n-\t\t   Construction has already been handled by the front-end.  */\n-\t\tgcc_assert (e->op != EXP::construct);\n-\n-\t\t/* So we can call postblits on const/immutable objects.  */\n-\t\tType *tm = etype->unSharedOf ()->mutableOf ();\n-\t\ttree ti = build_typeinfo (e, tm);\n-\n-\t\t/* Generate: _d_arraysetassign (t1.ptr, &t2, t1.length, ti);  */\n-\t\tresult = build_libcall (LIBCALL_ARRAYSETASSIGN, Type::tvoid, 4,\n-\t\t\t\t\td_array_ptr (t1),\n-\t\t\t\t\tbuild_address (t2),\n-\t\t\t\t\td_array_length (t1), ti);\n+\t\t/* This case should have been rewritten to `_d_arraysetassign`\n+\t\t   in the semantic phase.  */\n+\t\tgcc_unreachable ();\n \t      }\n-\t    else if (integer_zerop (t2))\n+\n+\t    if (integer_zerop (t2))\n \t      {\n \t\ttree size = size_mult_expr (d_array_length (t1),\n \t\t\t\t\t    size_int (etype->size ()));\n@@ -2473,6 +2464,20 @@ class ExprVisitor : public Visitor\n \tif (e->argprefix)\n \t  result = compound_expr (build_expr (e->argprefix), result);\n       }\n+    else if (tb->ty == TY::Taarray)\n+      {\n+\t/* Allocating memory for a new associative array.  */\n+\ttree arg = build_typeinfo (e, e->newtype);\n+\ttree mem = build_libcall (LIBCALL_AANEW, Type::tvoidptr, 1, arg);\n+\n+\t/* Return an associative array pointed to by MEM.  */\n+\ttree aatype = build_ctype (tb);\n+\tvec <constructor_elt, va_gc> *ce = NULL;\n+\tCONSTRUCTOR_APPEND_ELT (ce, TYPE_FIELDS (aatype), mem);\n+\n+\tresult = build_nop (build_ctype (e->type),\n+\t\t\t    build_constructor (aatype, ce));\n+      }\n     else\n       gcc_unreachable ();\n "}, {"sha": "f576bef4e59d99ba232fab446c91b12862dfd66f", "filename": "gcc/d/runtime.def", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fd%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fruntime.def?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -115,10 +115,6 @@ DEF_D_RUNTIME (ALLOCMEMORY, \"_d_allocmemory\", RT(VOIDPTR), P1(SIZE_T),\n DEF_D_RUNTIME (ARRAYCOPY, \"_d_arraycopy\", RT(ARRAY_VOID),\n \t       P3(SIZE_T, ARRAY_VOID, ARRAY_VOID), 0)\n \n-/* Used for array assignments from a single element.  */\n-DEF_D_RUNTIME (ARRAYSETASSIGN, \"_d_arraysetassign\", RT(VOIDPTR),\n-\t       P4(VOIDPTR, VOIDPTR, SIZE_T, CONST_TYPEINFO), 0)\n-\n /* Used for concatenating two or more arrays together.  Then `n' variant is\n    for when there is more than two arrays to handle.  */\n DEF_D_RUNTIME (ARRAYCATT, \"_d_arraycatT\", RT(ARRAY_BYTE),\n@@ -140,6 +136,7 @@ DEF_D_RUNTIME (ARRAYAPPENDWD, \"_d_arrayappendwd\", RT(ARRAY_VOID),\n /* Used for allocating a new associative array.  */\n DEF_D_RUNTIME (ASSOCARRAYLITERALTX, \"_d_assocarrayliteralTX\", RT(VOIDPTR),\n \t       P3(CONST_TYPEINFO, ARRAY_VOID, ARRAY_VOID), 0)\n+DEF_D_RUNTIME (AANEW, \"_aaNew\", RT(VOIDPTR), P1(CONST_TYPEINFO), 0)\n \n /* Used for value equality of two associative arrays.  */\n DEF_D_RUNTIME (AAEQUAL, \"_aaEqual\", RT(INT),"}, {"sha": "cc01c691dc18d89536312e9681a0fc83572af4ab", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -4598,6 +4598,15 @@ the GCC sources.\n Use the @option{--disable-sjlj-exceptions} and\n @option{--enable-newlib-io-long-long} options when configuring.\n \n+The @option{--with-arch} option may be specified to override the\n+default value for the @option{-march} option, and to also build\n+corresponding target libraries.\n+The default is @option{--with-arch=sm_30}.\n+\n+For example, if @option{--with-arch=sm_70} is specified,\n+@option{-march=sm_30} and @option{-march=sm_70} target libraries are\n+built, and code generation defaults to @option{-march=sm_70}.\n+\n @html\n <hr />\n @end html"}, {"sha": "383d22a4bf4ae04e673d3d8d41438db1b16dd091", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -9901,7 +9901,7 @@ security-sensitive value is written to an output file\n \n See @uref{https://cwe.mitre.org/data/definitions/532.html, CWE-532: Information Exposure Through Log Files}.\n \n-@item Wanalyzer-exposure-through-uninit-copy\n+@item -Wanalyzer-exposure-through-uninit-copy\n @opindex Wanalyzer-exposure-through-uninit-copy\n @opindex Wno-analyzer-exposure-through-uninit-copy\n This warning requires both @option{-fanalyzer} and the use of a plugin\n@@ -19681,6 +19681,9 @@ and the features that they enable by default:\n @item @samp{armv8.7-a} @tab Armv8.7-A @tab @samp{armv8.6-a}, @samp{+ls64}\n @item @samp{armv8.8-a} @tab Armv8.8-a @tab @samp{armv8.7-a}, @samp{+mops}\n @item @samp{armv9-a} @tab Armv9-A @tab @samp{armv8.5-a}, @samp{+sve}, @samp{+sve2}\n+@item @samp{armv9.1-a} @tab Armv9.1-A @tab @samp{armv9-a}, @samp{+bf16}, @samp{+i8mm}\n+@item @samp{armv9.2-a} @tab Armv9.2-A @tab @samp{armv9.1-a}, @samp{+ls64}\n+@item @samp{armv9.3-a} @tab Armv9.3-A @tab @samp{armv9.2-a}, @samp{+mops}\n @item @samp{armv8-r} @tab Armv8-R @tab @samp{armv8-r}\n @end multitable\n \n@@ -28055,7 +28058,9 @@ supported.\n Generate code for the specified PTX ISA target architecture\n (e.g.@: @samp{sm_35}).  Valid architecture strings are @samp{sm_30},\n @samp{sm_35}, @samp{sm_53}, @samp{sm_70}, @samp{sm_75} and\n-@samp{sm_80}.  The default target architecture is sm_30.\n+@samp{sm_80}.\n+The default depends on how the compiler has been configured, see\n+@option{--with-arch}.\n \n This option sets the value of the preprocessor macro\n @code{__PTX_SM__}; for instance, for @samp{sm_35}, it has the value"}, {"sha": "52357cc7aee9446ca1ec39b724efb4c97034ac89", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -2447,7 +2447,7 @@ PowerPC target pre-defines macro _ARCH_PWR9 which means the @code{-mcpu}\n setting is Power9 or later.\n @end table\n \n-@subsection RISC-V specific attributes\n+@subsubsection RISC-V specific attributes\n \n @table @code\n "}, {"sha": "6985e62338d59b96dabb83161ccb83e84eb06af7", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,3 +1,69 @@\n+2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/41453\n+\t* trans-expr.cc (gfc_conv_procedure_call): Allow strictly\n+\tmatching derived types.\n+\n+2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/41453\n+\tPR fortran/99169\n+\t* trans-expr.cc (gfc_conv_procedure_call): Remove conditions\n+\ton ALLOCATABLE and POINTER attributes guarding clobber\n+\tgeneration.\n+\n+2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/41453\n+\tPR fortran/87401\n+\t* trans-expr.cc (gfc_conv_procedure_call): Remove condition\n+\tdisabling clobber generation for ASSOCIATE variables.\n+\n+2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/41453\n+\tPR fortran/87395\n+\t* trans-expr.cc (gfc_conv_procedure_call): Remove condition\n+\ton SAVE attribute guarding clobber generation.\n+\n+2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/41453\n+\tPR fortran/87395\n+\t* trans-expr.cc (gfc_conv_procedure_call): Remove condition\n+\tdisabling clobber generation for dummy variables.  Remove\n+\tobsolete comment.\n+\n+2022-09-25  Harald Anlauf  <anlauf@gmx.de>\n+\t    Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/105012\n+\t* trans-expr.cc (gfc_conv_procedure_call): Use dummy\n+\tinformation from associated_dummy if there is no information\n+\tfrom the procedure interface.\n+\n+2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/106817\n+\t* trans-expr.cc (gfc_conv_procedure_call): Collect all clobbers\n+\tto their own separate block.  Append the block of clobbers to\n+\tthe procedure preliminary block after the argument evaluation\n+\tcodes for all the arguments.\n+\n+2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/105012\n+\t* trans-expr.cc (gfc_conv_procedure_call): Retrieve variable\n+\tfrom the just calculated variable reference.\n+\n+2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\t* trans.h (gfc_conv_expr_reference): Remove add_clobber\n+\targument.\n+\t* trans-expr.cc (gfc_conv_expr_reference): Ditto. Inline code\n+\tdepending on add_clobber and conditions controlling it ...\n+\t(gfc_conv_procedure_call): ... to here.\n+\n 2022-09-22  Jos\u00e9 Rui Faustino de Sousa  <jrfsousa@gmail.com>\n \n \tPR fortran/100103"}, {"sha": "4f3ae82d39c82d479bc5b58b6e29387c85fca70b", "filename": "gcc/fortran/trans-expr.cc", "status": "modified", "additions": 54, "deletions": 29, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ffortran%2Ftrans-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ffortran%2Ftrans-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -6018,7 +6018,6 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n   gfc_charlen cl;\n   gfc_expr *e;\n   gfc_symbol *fsym;\n-  stmtblock_t post;\n   enum {MISSING = 0, ELEMENTAL, SCALAR, SCALAR_POINTER, ARRAY};\n   gfc_component *comp = NULL;\n   int arglen;\n@@ -6062,7 +6061,9 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n   else\n     info = NULL;\n \n+  stmtblock_t post, clobbers;\n   gfc_init_block (&post);\n+  gfc_init_block (&clobbers);\n   gfc_init_interface_mapping (&mapping);\n   if (!comp)\n     {\n@@ -6395,7 +6396,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t\t&& e->symtree->n.sym->attr.pointer))\n \t\t\t&& fsym && fsym->attr.target)\n \t\t/* Make sure the function only gets called once.  */\n-\t\tgfc_conv_expr_reference (&parmse, e, false);\n+\t\tgfc_conv_expr_reference (&parmse, e);\n \t      else if (e->expr_type == EXPR_FUNCTION\n \t\t       && e->symtree->n.sym->result\n \t\t       && e->symtree->n.sym->result != e->symtree->n.sym\n@@ -6502,22 +6503,55 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      bool add_clobber;\n-\t\t      add_clobber = fsym && fsym->attr.intent == INTENT_OUT\n-\t\t\t&& !fsym->attr.allocatable && !fsym->attr.pointer\n-\t\t\t&& e->symtree && e->symtree->n.sym\n-\t\t\t&& !e->symtree->n.sym->attr.dimension\n-\t\t\t&& !e->symtree->n.sym->attr.pointer\n-\t\t\t&& !e->symtree->n.sym->attr.allocatable\n-\t\t\t/* See PR 41453.  */\n-\t\t\t&& !e->symtree->n.sym->attr.dummy\n-\t\t\t/* FIXME - PR 87395 and PR 41453  */\n-\t\t\t&& e->symtree->n.sym->attr.save == SAVE_NONE\n-\t\t\t&& !e->symtree->n.sym->attr.associate_var\n-\t\t\t&& e->ts.type != BT_CHARACTER && e->ts.type != BT_DERIVED\n-\t\t\t&& e->ts.type != BT_CLASS && !sym->attr.elemental;\n-\n-\t\t      gfc_conv_expr_reference (&parmse, e, add_clobber);\n+\t\t      gfc_conv_expr_reference (&parmse, e);\n+\n+\t\t      gfc_symbol *dsym = fsym;\n+\t\t      gfc_dummy_arg *dummy;\n+\n+\t\t      /* Use associated dummy as fallback for formal\n+\t\t\t argument if there is no explicit interface.  */\n+\t\t      if (dsym == NULL\n+\t\t\t  && (dummy = arg->associated_dummy)\n+\t\t\t  && dummy->intrinsicness == GFC_NON_INTRINSIC_DUMMY_ARG\n+\t\t\t  && dummy->u.non_intrinsic->sym)\n+\t\t\tdsym = dummy->u.non_intrinsic->sym;\n+\n+\t\t      if (dsym\n+\t\t\t  && dsym->attr.intent == INTENT_OUT\n+\t\t\t  && !dsym->attr.allocatable\n+\t\t\t  && !dsym->attr.pointer\n+\t\t\t  && e->expr_type == EXPR_VARIABLE\n+\t\t\t  && e->ref == NULL\n+\t\t\t  && e->symtree\n+\t\t\t  && e->symtree->n.sym\n+\t\t\t  && !e->symtree->n.sym->attr.dimension\n+\t\t\t  && e->ts.type != BT_CHARACTER\n+\t\t\t  && e->ts.type != BT_CLASS\n+\t\t\t  && (e->ts.type != BT_DERIVED\n+\t\t\t      || (dsym->ts.type == BT_DERIVED\n+\t\t\t\t  && e->ts.u.derived == dsym->ts.u.derived\n+\t\t\t\t  /* Types with allocatable components are\n+\t\t\t\t     excluded from clobbering because we need\n+\t\t\t\t     the unclobbered pointers to free the\n+\t\t\t\t     allocatable components in the callee.\n+\t\t\t\t     Same goes for finalizable types or types\n+\t\t\t\t     with finalizable components, we need to\n+\t\t\t\t     pass the unclobbered values to the\n+\t\t\t\t     finalization routines.\n+\t\t\t\t     For parameterized types, it's less clear\n+\t\t\t\t     but they may not have a constant size\n+\t\t\t\t     so better exclude them in any case.  */\n+\t\t\t\t  && !e->ts.u.derived->attr.alloc_comp\n+\t\t\t\t  && !e->ts.u.derived->attr.pdt_type\n+\t\t\t\t  && !gfc_is_finalizable (e->ts.u.derived, NULL)))\n+\t\t\t  && !sym->attr.elemental)\n+\t\t\t{\n+\t\t\t  tree var;\n+\t\t\t  var = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t\t     parmse.expr);\n+\t\t\t  tree clobber = build_clobber (TREE_TYPE (var));\n+\t\t\t  gfc_add_modify (&clobbers, var, clobber);\n+\t\t\t}\n \t\t    }\n \t\t  /* Catch base objects that are not variables.  */\n \t\t  if (e->ts.type == BT_CLASS\n@@ -7384,6 +7418,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \n       vec_safe_push (arglist, parmse.expr);\n     }\n+  gfc_add_block_to_block (&se->pre, &clobbers);\n   gfc_finish_interface_mapping (&mapping, &se->pre, &se->post);\n \n   if (comp)\n@@ -9484,7 +9519,7 @@ gfc_conv_expr_type (gfc_se * se, gfc_expr * expr, tree type)\n    values only.  */\n \n void\n-gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr, bool add_clobber)\n+gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr)\n {\n   gfc_ss *ss;\n   tree var;\n@@ -9524,16 +9559,6 @@ gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr, bool add_clobber)\n \t  gfc_add_block_to_block (&se->pre, &se->post);\n \t  se->expr = var;\n \t}\n-      else if (add_clobber && expr->ref == NULL)\n-\t{\n-\t  tree clobber;\n-\t  tree var;\n-\t  /* FIXME: This fails if var is passed by reference, see PR\n-\t     41453.  */\n-\t  var = expr->symtree->n.sym->backend_decl;\n-\t  clobber = build_clobber (TREE_TYPE (var));\n-\t  gfc_add_modify (&se->pre, var, clobber);\n-\t}\n       return;\n     }\n "}, {"sha": "bc9035c1717e9053cabfe17ed2e3ad1d720d1e1c", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -499,8 +499,7 @@ tree gfc_build_compare_string (tree, tree, tree, tree, int, enum tree_code);\n void gfc_conv_expr (gfc_se * se, gfc_expr * expr);\n void gfc_conv_expr_val (gfc_se * se, gfc_expr * expr);\n void gfc_conv_expr_lhs (gfc_se * se, gfc_expr * expr);\n-void gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr,\n-\t\t\t      bool add_clobber = false);\n+void gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr);\n void gfc_conv_expr_type (gfc_se * se, gfc_expr *, tree);\n \n "}, {"sha": "dc42c752017311ffeca934f94d40186b5352b783", "filename": "gcc/omp-low.cc", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fomp-low.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fomp-low.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -7631,6 +7631,7 @@ lower_oacc_reductions (location_t loc, tree clauses, tree level, bool inner,\n \t      incoming = build_simple_mem_ref (incoming);\n \t  }\n \telse\n+\t  /* Note that 'var' might be a mem ref.  */\n \t  v1 = v2 = v3 = var;\n \n \t/* Determine position in reduction buffer, which may be used\n@@ -7659,26 +7660,28 @@ lower_oacc_reductions (location_t loc, tree clauses, tree level, bool inner,\n \t  = build_call_expr_internal_loc (loc, IFN_GOACC_REDUCTION,\n \t\t\t\t\t  TREE_TYPE (var), 6, setup_code,\n \t\t\t\t\t  unshare_expr (ref_to_res),\n-\t\t\t\t\t  incoming, level, op, off);\n+\t\t\t\t\t  unshare_expr (incoming),\n+\t\t\t\t\t  level, op, off);\n \ttree init_call\n \t  = build_call_expr_internal_loc (loc, IFN_GOACC_REDUCTION,\n \t\t\t\t\t  TREE_TYPE (var), 6, init_code,\n \t\t\t\t\t  unshare_expr (ref_to_res),\n-\t\t\t\t\t  v1, level, op, off);\n+\t\t\t\t\t  unshare_expr (v1), level, op, off);\n \ttree fini_call\n \t  = build_call_expr_internal_loc (loc, IFN_GOACC_REDUCTION,\n \t\t\t\t\t  TREE_TYPE (var), 6, fini_code,\n \t\t\t\t\t  unshare_expr (ref_to_res),\n-\t\t\t\t\t  v2, level, op, off);\n+\t\t\t\t\t  unshare_expr (v2), level, op, off);\n \ttree teardown_call\n \t  = build_call_expr_internal_loc (loc, IFN_GOACC_REDUCTION,\n \t\t\t\t\t  TREE_TYPE (var), 6, teardown_code,\n-\t\t\t\t\t  ref_to_res, v3, level, op, off);\n+\t\t\t\t\t  ref_to_res, unshare_expr (v3),\n+\t\t\t\t\t  level, op, off);\n \n-\tgimplify_assign (v1, setup_call, &before_fork);\n-\tgimplify_assign (v2, init_call, &after_fork);\n-\tgimplify_assign (v3, fini_call, &before_join);\n-\tgimplify_assign (outgoing, teardown_call, &after_join);\n+\tgimplify_assign (unshare_expr (v1), setup_call, &before_fork);\n+\tgimplify_assign (unshare_expr (v2), init_call, &after_fork);\n+\tgimplify_assign (unshare_expr (v3), fini_call, &before_join);\n+\tgimplify_assign (unshare_expr (outgoing), teardown_call, &after_join);\n       }\n \n   /* Now stitch things together.  */"}, {"sha": "fc930f4d61308226ab1b8dc01e7da361e1fd6ff0", "filename": "gcc/range-op.cc", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -2951,6 +2951,15 @@ operator_bitwise_and::op1_range (irange &r, tree type,\n     }\n   if (r.undefined_p ())\n     set_nonzero_range_from_mask (r, type, lhs);\n+\n+  // For 0 = op1 & MASK, op1 is ~MASK.\n+  if (lhs.zero_p () && op2.singleton_p ())\n+    {\n+      wide_int nz = wi::bit_not (op2.get_nonzero_bits ());\n+      int_range<2> tmp (type);\n+      tmp.set_nonzero_bits (nz);\n+      r.intersect (tmp);\n+    }\n   return true;\n }\n \n@@ -4612,6 +4621,15 @@ range_op_bitwise_and_tests ()\n   op_bitwise_and.op1_range (res, integer_type_node, i1, i2);\n   ASSERT_TRUE (res == int_range<1> (integer_type_node));\n \n+  // For 0 = x & MASK, x is ~MASK.\n+  {\n+    int_range<2> zero (integer_zero_node, integer_zero_node);\n+    int_range<2> mask = int_range<2> (INT (7), INT (7));\n+    op_bitwise_and.op1_range (res, integer_type_node, zero, mask);\n+    wide_int inv = wi::shwi (~7U, TYPE_PRECISION (integer_type_node));\n+    ASSERT_TRUE (res.get_nonzero_bits () == inv);\n+  }\n+\n   // (NONZERO | X) is nonzero.\n   i1.set_nonzero (integer_type_node);\n   i2.set_varying (integer_type_node);"}, {"sha": "24f4ac5395f3cedef5bdaf6b5f90f78610663576", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,3 +1,122 @@\n+2022-09-26  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/106656\n+\t* g++.dg/cpp23/feat-cxx2b.C: Adjust.\n+\t* g++.dg/cpp2a/feat-cxx2a.C: Likewise.\n+\t* g++.dg/ext/char8_t-feature-test-macro-2.C: Likewise.\n+\t* g++.dg/ext/char8_t-init-2.C: Likewise.\n+\t* g++.dg/cpp2a/char8_t3.C: New test.\n+\t* g++.dg/cpp2a/char8_t4.C: New test.\n+\n+2022-09-26  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/106784\n+\t* g++.dg/ext/is_convertible3.C: New test.\n+\t* g++.dg/ext/is_nothrow_convertible3.C: New test.\n+\n+2022-09-26  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/107033\n+\t* g++.dg/modules/partial-2.cc, g++.dg/modules/partial-2.h: New\n+\tfiles, factored out from ...\n+\t* g++.dg/modules/partial-2_a.C, g++.dg/modules/partial-2_b.C: ...\n+\tthese.\n+\t* g++.dg/modules/partial-2_c.H: New test.\n+\t* g++.dg/modules/partial-2_d.C: New test.\n+\n+2022-09-26  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\tPR tree-optimization/107009\n+\t* gcc.dg/tree-ssa/pr107009.c: New test.\n+\n+2022-09-26  Jeff Law  <jeffreyalaw@gmail.com>\n+\n+\t* gcc.target/riscv/ret-1.c: New test.\n+\n+2022-09-26  Tobias Burnus  <tobias@codesourcery.com>\n+\n+\tPR middle-end/106982\n+\t* c-c++-common/goacc/reduction-7.c: New test.\n+\t* c-c++-common/goacc/reduction-8.c: New test.\n+\n+2022-09-26  Kewen Lin  <linkw@linux.ibm.com>\n+\n+\tPR target/96072\n+\t* gcc.target/powerpc/pr96072.c: New test.\n+\n+2022-09-26  Hu, Lin1  <lin1.hu@intel.com>\n+\n+\tPR target/94962\n+\t* gcc.target/i386/avx256-unaligned-store-3.c: Add -mno-avx512f\n+\n+2022-09-26  Kewen Lin  <linkw@linux.ibm.com>\n+\n+\tPR target/100645\n+\t* gcc.target/powerpc/pr100645.c: New test.\n+\n+2022-09-26  Hongtao Liu  <hongtao.liu@intel.com>\n+\t    Liwei Xu  <liwei.xu@intel.com>\n+\n+\t* gcc.target/i386/pr53346-1.c: New test.\n+\t* gcc.target/i386/pr53346-2.c: New test.\n+\t* gcc.target/i386/pr53346-3.c: New test.\n+\t* gcc.target/i386/pr53346-4.c: New test.\n+\n+2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/41453\n+\t* gfortran.dg/intent_optimize_10.f90: New test.\n+\n+2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/41453\n+\tPR fortran/99169\n+\t* gfortran.dg/intent_optimize_9.f90: New test.\n+\n+2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/41453\n+\tPR fortran/87401\n+\t* gfortran.dg/intent_optimize_8.f90: New test.\n+\n+2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/41453\n+\tPR fortran/87395\n+\t* gfortran.dg/intent_optimize_7.f90: New test.\n+\n+2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/41453\n+\tPR fortran/87395\n+\t* gfortran.dg/intent_optimize_6.f90: New test.\n+\n+2022-09-25  Harald Anlauf  <anlauf@gmx.de>\n+\t    Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/105012\n+\t* gfortran.dg/intent_optimize_5.f90: New test.\n+\n+2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/106817\n+\t* gfortran.dg/intent_optimize_4.f90: New test.\n+\n+2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/105012\n+\t* gfortran.dg/intent_out_15.f90: New test.\n+\n+2022-09-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/107001\n+\t* c-c++-common/gomp/pr107001.c: New test.\n+\n+2022-09-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/106981\n+\t* c-c++-common/gomp/pr106981.c: New test.\n+\n 2022-09-23  Joseph Myers  <joseph@codesourcery.com>\n \n \t* gcc.dg/c2x-complit-1.c, gcc.dg/c2x-concat-1.c,"}, {"sha": "482b0ab1984e75bd822efea2b6e825f598921f25", "filename": "gcc/testsuite/c-c++-common/goacc/reduction-7.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Freduction-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Freduction-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Freduction-7.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+\n+/* PR middle-end/106982 */\n+\n+long long n = 100;\n+int multiplicitive_n = 128;\n+\n+void test1(double *rand, double *a, double *b, double *c)\n+{\n+#pragma acc data copyin(a[0:10*multiplicitive_n], b[0:10*multiplicitive_n]) copyout(c[0:10])\n+    {\n+#pragma acc parallel loop\n+        for (int i = 0; i < 10; ++i)\n+        {\n+        double temp = 1.0;\n+#pragma acc loop vector reduction(*:temp)\n+        for (int j = 0; j < multiplicitive_n; ++j)\n+          temp *= a[(i * multiplicitive_n) + j] + b[(i * multiplicitive_n) + j];\n+        c[i] = temp;\n+        }\n+    }\n+}"}, {"sha": "2c3ed499d5b63c394373b0b816cea0b18f322cdd", "filename": "gcc/testsuite/c-c++-common/goacc/reduction-8.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Freduction-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Freduction-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Freduction-8.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+\n+/* PR middle-end/106982 */\n+\n+void test1(double *c)\n+{\n+    double reduced[5];\n+#pragma acc parallel loop gang private(reduced)\n+    for (int x = 0; x < 5; ++x)\n+#pragma acc loop worker reduction(*:reduced)\n+      for (int y = 0; y < 5; ++y) { }\n+}"}, {"sha": "05c64a803da286d9a6de2bab152dc7e341678de4", "filename": "gcc/testsuite/c-c++-common/gomp/assume-1.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassume-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassume-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassume-1.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,29 @@\n+void\n+foo (int i, int *a)\n+{\n+  #pragma omp assume no_openmp, absent (target, teams) holds (i < 32U) holds (i < 32U)\n+  ;\n+  #pragma omp assume no_openmp_routines, contains (simd)\n+  {\n+    #pragma omp simd\n+    for (int j = 0; j < i; j++)\n+      a[j] = j;\n+  }\n+  #pragma omp assume no_parallelism, contains (error)\n+  {\n+    if (i >= 32)\n+      {\n+\t#pragma omp error at (execution) message (\"Should not happen\")\n+      }\n+  }\n+  #pragma omp assume absent (for)\n+  ;\n+  #pragma omp assume absent (atomic, barrier, cancel, cancellation point) absent (critical, depobj)\n+  ;\n+  #pragma omp assume absent (distribute, flush, loop, masked, master, nothing, ordered)\n+  ;\n+  #pragma omp assume absent (parallel, scan, scope, section, sections, simd, single, task)\n+  ;\n+  #pragma omp assume absent (taskgroup, taskloop, taskwait, taskyield)\n+  ;\n+}"}, {"sha": "47396055aef1df84e75397a595d023a734958b63", "filename": "gcc/testsuite/c-c++-common/gomp/assume-2.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassume-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassume-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassume-2.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,46 @@\n+void\n+foo (int i, int *a)\n+{\n+  #pragma omp assume no_openmp no_openmp\t\t\t/* { dg-error \"too many 'no_openmp' clauses\" } */\n+  ;\n+  #pragma omp assume no_openmp_routines, no_openmp_routines\t/* { dg-error \"too many 'no_openmp_routines' clauses\" } */\n+  ;\n+  #pragma omp assume no_parallelism, no_parallelism\t\t/* { dg-error \"too many 'no_parallelism' clauses\" } */\n+  ;\n+  #pragma omp assume absent (target, target)\t\t\t/* { dg-error \"'target' directive mentioned multiple times in 'absent' clauses\" } */\n+  ;\n+  #pragma omp assume absent (target, teams) absent (teams, parallel)\t/* { dg-error \"'teams' directive mentioned multiple times in 'absent' clauses\" } */\n+  ;\n+  #pragma omp assume contains (cancellation point, cancellation point)\t/* { dg-error \"'cancellation point' directive mentioned multiple times in 'contains' clauses\" } */\n+  ;\n+  #pragma omp assume contains (target enter data, target exit data) contains (target exit data, parallel)\t/* { dg-error \"target exit data' directive mentioned multiple times in 'contains' clauses\" } */\n+  ;\n+  #pragma omp assume absent (target enter data, target exit data) contains (target exit data, parallel)\t\t/* { dg-error \"'target exit data' directive mentioned in both 'absent' and 'contains' clauses\" } */\n+  ;\n+  #pragma omp assume contains (target enter data, target exit data) absent (target enter data, parallel)\t/* { dg-error \"'target enter data' directive mentioned in both 'absent' and 'contains' clauses\" } */\n+  ;\n+  #pragma omp assume contains (declare target)\t\t\t/* { dg-error \"unknown OpenMP directive name in 'contains' clause argument\" } */\n+  ;\n+  #pragma omp assume absent (parallel for simd)\t\t\t/* { dg-error \"unknown OpenMP directive name in 'absent' clause argument\" } */\n+  ;\n+  #pragma omp assume contains (target parallel)\t\t\t/* { dg-error \"unknown OpenMP directive name in 'contains' clause argument\" } */\n+  ;\n+  #pragma omp assume absent (assume)\t\t\t\t/* { dg-error \"unknown OpenMP directive name in 'absent' clause argument\" } */\n+  ;\n+  #pragma omp assume absent (assumes)\t\t\t\t/* { dg-error \"unknown OpenMP directive name in 'absent' clause argument\" } */\n+  ;\n+  #pragma omp assume contains (begin assumes)\t\t\t/* { dg-error \"unknown OpenMP directive name in 'contains' clause argument\" } */\n+  ;\n+  #pragma omp assume contains (end assumes)\t\t\t/* { dg-error \"unknown OpenMP directive name in 'contains' clause argument\" } */\n+  ;\n+  #pragma omp assume contains (foo)\t\t\t\t/* { dg-error \"unknown OpenMP directive name in 'contains' clause argument\" } */\n+  ;\n+  #pragma omp assume absent (target enter something)\t\t/* { dg-error \"unknown OpenMP directive name in 'absent' clause argument\" } */\n+  ;\n+  #pragma omp assume foobar\t\t\t\t\t/* { dg-error \"expected assumption clause\" } */\n+  ;\n+  #pragma omp assume ext_GCC_foobarbaz, ext_GCC_baz (1, 12, 1 < 17), no_parallelism\t/* { dg-warning \"unknown assumption clause 'ext_GCC_foobarbaz'\" } */\n+  ;\t\t\t\t\t\t\t\t/* { dg-warning \"unknown assumption clause 'ext_GCC_baz'\" \"\" { target *-*-* } .-1 } */\n+  #pragma omp assume\t\t\t\t\t\t/* { dg-error \"expected at least one assumption clause\" } */\n+  ;\n+}"}, {"sha": "ce38359552da19ff57b248b823009fb5fea339ae", "filename": "gcc/testsuite/c-c++-common/gomp/assume-3.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassume-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassume-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassume-3.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fno-openmp -fopenmp-simd\" } */\n+\n+int i, j;\n+\n+int\n+foo (void)\n+{\n+  j = 1;\n+  return 1;\n+}\n+\n+int\n+main ()\n+{\n+  #pragma omp assume holds (i < 42)\n+  ;\n+  #pragma omp assume holds (++i == 1)\n+  ;\n+  if (i != 0)\n+    __builtin_abort ();\n+  #pragma omp assume holds (foo () == 1)\n+  ;\n+  if (j != 0)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "8b3fb378bfbfd6589c1edf7c63713f592bf86de7", "filename": "gcc/testsuite/c-c++-common/gomp/assumes-1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassumes-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassumes-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassumes-1.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,26 @@\n+int i;\n+\n+#pragma omp assumes no_openmp, absent (target, teams) holds (i < 32U) holds (i < 32U)\n+void\n+bar (void)\n+{\n+}\n+\n+#pragma omp assumes no_openmp_routines\n+\n+#pragma omp assumes no_parallelism\n+\n+#pragma omp assumes absent (for)\n+void\n+fred (void)\n+{\n+}\n+\n+#pragma omp assumes absent (atomic, barrier, cancel, cancellation point) absent (critical, depobj) \\\n+\t\t    absent (distribute, flush, loop, masked, master, nothing, ordered) \\\n+\t\t    absent (parallel, scan, scope, section, sections, simd, single, task) \\\n+\t\t    absent (taskgroup, taskloop, taskwait, taskyield)\n+void\n+foo (void)\n+{\n+}"}, {"sha": "924f323d68f702d5ceb2227a751906c8ed28efc3", "filename": "gcc/testsuite/c-c++-common/gomp/assumes-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassumes-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassumes-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassumes-2.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,23 @@\n+#pragma omp assumes no_openmp no_openmp\t\t\t\t/* { dg-error \"too many 'no_openmp' clauses\" } */\n+#pragma omp assumes no_openmp_routines, no_openmp_routines\t/* { dg-error \"too many 'no_openmp_routines' clauses\" } */\n+#pragma omp assumes no_parallelism, no_parallelism\t\t/* { dg-error \"too many 'no_parallelism' clauses\" } */\n+#pragma omp assumes absent (target, target)\t\t\t/* { dg-error \"'target' directive mentioned multiple times in 'absent' clauses\" } */\n+#pragma omp assumes absent (target, teams) absent (teams, parallel)\t/* { dg-error \"'teams' directive mentioned multiple times in 'absent' clauses\" } */\n+#pragma omp assumes contains (cancellation point, cancellation point)\t/* { dg-error \"'cancellation point' directive mentioned multiple times in 'contains' clauses\" } */\n+#pragma omp assumes contains (target enter data, target exit data) contains (target exit data, parallel)\t/* { dg-error \"target exit data' directive mentioned multiple times in 'contains' clauses\" } */\n+#pragma omp assumes absent (target enter data, target exit data) contains (target exit data, parallel)\t\t/* { dg-error \"'target exit data' directive mentioned in both 'absent' and 'contains' clauses\" } */\n+#pragma omp assumes contains (target enter data, target exit data) absent (target enter data, parallel)\t/* { dg-error \"'target enter data' directive mentioned in both 'absent' and 'contains' clauses\" } */\n+#pragma omp assumes contains (declare target)\t\t\t/* { dg-error \"unknown OpenMP directive name in 'contains' clause argument\" } */\n+#pragma omp assumes absent (parallel for simd)\t\t\t/* { dg-error \"unknown OpenMP directive name in 'absent' clause argument\" } */\n+#pragma omp assumes contains (target parallel)\t\t\t/* { dg-error \"unknown OpenMP directive name in 'contains' clause argument\" } */\n+#pragma omp assumes absent (assume)\t\t\t\t/* { dg-error \"unknown OpenMP directive name in 'absent' clause argument\" } */\n+#pragma omp assumes absent (assumes)\t\t\t\t/* { dg-error \"unknown OpenMP directive name in 'absent' clause argument\" } */\n+#pragma omp assumes contains (begin assumes)\t\t\t/* { dg-error \"unknown OpenMP directive name in 'contains' clause argument\" } */\n+#pragma omp assumes contains (end assumes)\t\t\t/* { dg-error \"unknown OpenMP directive name in 'contains' clause argument\" } */\n+#pragma omp assumes contains (foo)\t\t\t\t/* { dg-error \"unknown OpenMP directive name in 'contains' clause argument\" } */\n+#pragma omp assumes absent (target enter something)\t\t/* { dg-error \"unknown OpenMP directive name in 'absent' clause argument\" } */\n+#pragma omp assumes foobar\t\t\t\t\t/* { dg-error \"expected assumption clause\" } */\n+#pragma omp assumes ext_GCC_foobarbaz, ext_GCC_baz (1, 12, 1 < 17), no_parallelism\t/* { dg-warning \"unknown assumption clause 'ext_GCC_foobarbaz'\" } */\n+\t\t\t\t\t\t\t\t/* { dg-warning \"unknown assumption clause 'ext_GCC_baz'\" \"\" { target *-*-* } .-1 } */\n+#pragma omp assumes\t\t\t\t\t\t/* { dg-error \"expected at least one assumption clause\" } */\n+int i;"}, {"sha": "0bfadace4b39bab2e630386c6be98bae5a7c677a", "filename": "gcc/testsuite/c-c++-common/gomp/assumes-3.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassumes-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassumes-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassumes-3.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,15 @@\n+#pragma omp assumes contains (simd)\n+#pragma omp assumes contains (error)\n+#pragma omp assumes contains (simd)\n+\n+void\n+foo (int i, int *a)\n+{\n+  #pragma omp simd\n+  for (int j = 0; j < i; j++)\n+    a[j] = j;\n+  if (i >= 32)\n+    {\n+      #pragma omp error at (execution) message (\"Should not happen\")\n+    }\n+}"}, {"sha": "6e77adb2fe86d1c821a6fb7fad1e099276ade0cb", "filename": "gcc/testsuite/c-c++-common/gomp/assumes-4.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassumes-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassumes-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fassumes-4.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,6 @@\n+void\n+foo (void)\n+{\n+  #pragma omp assumes no_openmp\t\t/* { dg-error \"'#pragma omp assumes' may only be used at file scope\" \"\" { target c } } */\n+  ;\t\t\t\t\t/* { dg-error \"'#pragma omp assumes' may only be used at file or namespace scope\" \"\" { target c++ } .-1 } */\n+}"}, {"sha": "c3332b12755e24115ecd9c7d5e30b6ee4b2fa9c5", "filename": "gcc/testsuite/c-c++-common/gomp/begin-assumes-1.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-assumes-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-assumes-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-assumes-1.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,46 @@\n+int i;\n+\n+#pragma omp begin assumes no_openmp, absent (target, teams) holds (i < 32U) holds (i < 32U)\n+void\n+bar (void)\n+{\n+}\n+#pragma omp end assumes\n+\n+#pragma omp begin assumes no_openmp_routines, contains (simd)\n+void\n+baz (int *a)\n+{\n+  #pragma omp simd\n+  for (int j = 0; j < i; j++)\n+    a[j] = j;\n+}\n+#pragma omp end assumes\n+\n+#pragma omp begin assumes no_parallelism, contains (error)\n+void\n+qux (void)\n+{\n+  if (i >= 32)\n+    {\n+      #pragma omp error at (execution) message (\"Should not happen\")\n+    }\n+}\n+#pragma omp end assumes\n+\n+#pragma omp begin assumes absent (for)\n+void\n+fred (void)\n+{\n+}\n+#pragma omp end assumes\n+\n+#pragma omp begin assumes absent (atomic, barrier, cancel, cancellation point) absent (critical, depobj) \\\n+\t\t\t  absent (distribute, flush, loop, masked, master, nothing, ordered) \\\n+\t\t\t  absent (parallel, scan, scope, section, sections, simd, single, task) \\\n+\t\t\t  absent (taskgroup, taskloop, taskwait, taskyield)\n+void\n+foo (void)\n+{\n+}\n+#pragma omp end assumes"}, {"sha": "15dae6419338bdefdda5ddf134f2628c833ed70f", "filename": "gcc/testsuite/c-c++-common/gomp/begin-assumes-2.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-assumes-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-assumes-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-assumes-2.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,63 @@\n+#pragma omp begin assumes no_openmp no_openmp\t\t\t/* { dg-error \"too many 'no_openmp' clauses\" } */\n+void f1 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes no_openmp_routines, no_openmp_routines\t/* { dg-error \"too many 'no_openmp_routines' clauses\" } */\n+void f2 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes no_parallelism, no_parallelism\t\t/* { dg-error \"too many 'no_parallelism' clauses\" } */\n+void f3 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes absent (target, target)\t\t\t/* { dg-error \"'target' directive mentioned multiple times in 'absent' clauses\" } */\n+void f4 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes absent (target, teams) absent (teams, parallel)\t/* { dg-error \"'teams' directive mentioned multiple times in 'absent' clauses\" } */\n+void f5 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes contains (cancellation point, cancellation point)\t/* { dg-error \"'cancellation point' directive mentioned multiple times in 'contains' clauses\" } */\n+void f6 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes contains (target enter data, target exit data) contains (target exit data, parallel)\t/* { dg-error \"target exit data' directive mentioned multiple times in 'contains' clauses\" } */\n+void f7 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes absent (target enter data, target exit data) contains (target exit data, parallel)\t\t/* { dg-error \"'target exit data' directive mentioned in both 'absent' and 'contains' clauses\" } */\n+void f8 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes contains (target enter data, target exit data) absent (target enter data, parallel)\t/* { dg-error \"'target enter data' directive mentioned in both 'absent' and 'contains' clauses\" } */\n+void f9 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes contains (declare target)\t\t\t/* { dg-error \"unknown OpenMP directive name in 'contains' clause argument\" } */\n+void f10 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes absent (parallel for simd)\t\t\t/* { dg-error \"unknown OpenMP directive name in 'absent' clause argument\" } */\n+void f11 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes contains (target parallel)\t\t\t/* { dg-error \"unknown OpenMP directive name in 'contains' clause argument\" } */\n+void f12 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes absent (assume)\t\t\t\t/* { dg-error \"unknown OpenMP directive name in 'absent' clause argument\" } */\n+void f13 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes absent (assumes)\t\t\t\t/* { dg-error \"unknown OpenMP directive name in 'absent' clause argument\" } */\n+void f14 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes contains (begin assumes)\t\t\t/* { dg-error \"unknown OpenMP directive name in 'contains' clause argument\" } */\n+void f15 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes contains (end assumes)\t\t\t/* { dg-error \"unknown OpenMP directive name in 'contains' clause argument\" } */\n+void f16 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes contains (foo)\t\t\t\t/* { dg-error \"unknown OpenMP directive name in 'contains' clause argument\" } */\n+void f17 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes absent (target enter something)\t\t/* { dg-error \"unknown OpenMP directive name in 'absent' clause argument\" } */\n+void f18 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes foobar\t\t\t\t\t/* { dg-error \"expected assumption clause\" } */\n+void f19 (void) {}\n+#pragma omp end assumes\n+#pragma omp begin assumes ext_GCC_foobarbaz, ext_GCC_baz (1, 12, 1 < 17), no_parallelism\t/* { dg-warning \"unknown assumption clause 'ext_GCC_foobarbaz'\" } */\n+void f20 (void) {}\t\t\t\t\t\t\t\t/* { dg-warning \"unknown assumption clause 'ext_GCC_baz'\" \"\" { target *-*-* } .-1 } */\n+#pragma omp end assumes\n+#pragma omp begin assumes\t\t\t\t\t\t/* { dg-error \"expected at least one assumption clause\" } */\n+void f21 (void) {}\n+#pragma omp end assumes"}, {"sha": "202d5c7741b5e3eca95c972643c8a58a47f038ca", "filename": "gcc/testsuite/c-c++-common/gomp/begin-assumes-3.c", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-assumes-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-assumes-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-assumes-3.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,2 @@\n+#pragma omp begin assumes no_openmp_routines\n+void foo (void);\t/* { dg-error \"'#pragma omp begin assumes' without corresponding '#pragma omp end assumes'\" } */"}, {"sha": "eea6f908d051ac3b0ffacbe219643818e3058100", "filename": "gcc/testsuite/c-c++-common/gomp/begin-assumes-4.c", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-assumes-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-assumes-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fbegin-assumes-4.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,2 @@\n+#pragma omp end assumes\t/* { dg-error \"'#pragma omp end assumes' without corresponding '#pragma omp begin assumes'\" } */\n+void foo (void);"}, {"sha": "586eb50f8016f1cf810ba21d2508f2988b19876f", "filename": "gcc/testsuite/c-c++-common/gomp/declare-target-6.c", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-target-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-target-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdeclare-target-6.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,2 @@\n+#pragma omp end declare target\t/* { dg-error \"'#pragma omp end declare target' without corresponding '#pragma omp declare target'\" } */\n+void foo (void);"}, {"sha": "0323a0d05fc6afc6cf0f0a4dc3a2f9b2b1b1ea36", "filename": "gcc/testsuite/g++.dg/cpp1z/constexpr-lambda13.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fconstexpr-lambda13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fconstexpr-lambda13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fconstexpr-lambda13.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -2,4 +2,4 @@\n \n auto l1 = []() constexpr constexpr { }; // { dg-error \"duplicate\" }\n auto l2 = []() mutable mutable { }; // { dg-error \"duplicate\" }\n-auto l3 = []() static { };\t    // { dg-error \"static\" }\n+auto l3 = []() static { };\t    // { dg-error \"static' only valid in lambda with\" \"\" { target c++20_down } }"}, {"sha": "ffd9e636a0de657d3a504d429815f3b34f766cf3", "filename": "gcc/testsuite/g++.dg/cpp23/ext-floating.h", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating.h?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,30 @@\n+// P1467R9 - Extended floating-point types and standard names.\n+\n+namespace std\n+{\n+  #ifdef __STDCPP_FLOAT16_T__\n+  using float16_t = _Float16;\n+  #endif\n+  #ifdef __STDCPP_FLOAT32_T__\n+  using float32_t = _Float32;\n+  #endif\n+  #ifdef __STDCPP_FLOAT64_T__\n+  using float64_t = _Float64;\n+  #endif\n+  #ifdef __STDCPP_FLOAT128_T__\n+  using float128_t = _Float128;\n+  #endif\n+  #undef __STDCPP_BFLOAT16_T__\n+  #ifdef __STDCPP_BFLOAT16_T__\n+  using bfloat16_t = __bf16; // ???\n+  #endif\n+  template<typename T, T v> struct integral_constant {\n+    static constexpr T value = v;\n+  };\n+  typedef integral_constant<bool, false> false_type;\n+  typedef integral_constant<bool, true> true_type;\n+  template<class T, class U>\n+  struct is_same : std::false_type {};\n+  template <class T>\n+  struct is_same<T, T> : std::true_type {};\n+}"}, {"sha": "63232afada81278a9becd59243aac4843085563a", "filename": "gcc/testsuite/g++.dg/cpp23/ext-floating1.C", "status": "added", "additions": 447, "deletions": 0, "changes": 447, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating1.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,447 @@\n+// P1467R9 - Extended floating-point types and standard names.\n+// { dg-do compile { target c++23 } }\n+// { dg-options \"\" }\n+\n+#include \"ext-floating.h\"\n+\n+#ifdef __STRICT_ANSI__\n+#undef __SIZEOF_FLOAT128__\n+#endif\n+\n+using namespace std;\n+\n+static_assert (!is_same<float, double>::value);\n+static_assert (!is_same<float, long double>::value);\n+static_assert (!is_same<double, long double>::value);\n+static_assert (is_same<decltype (0.0f), float>::value);\n+static_assert (is_same<decltype (0.0F), float>::value);\n+static_assert (is_same<decltype (0.0), double>::value);\n+static_assert (is_same<decltype (0.0l), long double>::value);\n+static_assert (is_same<decltype (0.0L), long double>::value);\n+static_assert (is_same<decltype (0.0f + 0.0F), float>::value);\n+static_assert (is_same<decltype (0.0F + 0.0f), float>::value);\n+static_assert (is_same<decltype (0.0 + 0.0), double>::value);\n+static_assert (is_same<decltype (0.0l + 0.0L), long double>::value);\n+static_assert (is_same<decltype (0.0L + 0.0l), long double>::value);\n+#ifdef __SIZEOF_FLOAT128__\n+static_assert (is_same<decltype (0.0q), __float128>::value);\n+static_assert (is_same<decltype (0.0Q), __float128>::value);\n+static_assert (is_same<decltype (0.0q + 0.0q), __float128>::value);\n+static_assert (is_same<decltype (0.0Q + 0.0Q), __float128>::value);\n+#endif\n+#ifdef __STDCPP_FLOAT16_T__\n+static_assert (!is_same<float, float16_t>::value);\n+static_assert (!is_same<double, float16_t>::value);\n+static_assert (!is_same<long double, float16_t>::value);\n+static_assert (is_same<decltype (0.0f16), float16_t>::value);\n+static_assert (is_same<decltype (0.0F16), float16_t>::value);\n+static_assert (is_same<decltype (0.0f16 + 0.0f16), float16_t>::value);\n+static_assert (is_same<decltype (0.0F16 + 0.0F16), float16_t>::value);\n+#endif\n+#ifdef __STDCPP_FLOAT32_T__\n+static_assert (!is_same<float, float32_t>::value);\n+static_assert (!is_same<double, float32_t>::value);\n+static_assert (!is_same<long double, float32_t>::value);\n+static_assert (!is_same<decltype (0.0f), float32_t>::value);\n+static_assert (!is_same<decltype (0.0F), float32_t>::value);\n+static_assert (is_same<decltype (0.0f32), float32_t>::value);\n+static_assert (is_same<decltype (0.0F32), float32_t>::value);\n+static_assert (!is_same<decltype (0.0f32), float>::value);\n+static_assert (!is_same<decltype (0.0F32), float>::value);\n+static_assert (is_same<decltype (0.0f32 + 0.0f32), float32_t>::value);\n+static_assert (is_same<decltype (0.0F32 + 0.0F32), float32_t>::value);\n+#endif\n+#ifdef __STDCPP_FLOAT64_T__\n+static_assert (!is_same<float, float64_t>::value);\n+static_assert (!is_same<double, float64_t>::value);\n+static_assert (!is_same<long double, float64_t>::value);\n+static_assert (!is_same<decltype (0.0), float64_t>::value);\n+static_assert (is_same<decltype (0.0f64), float64_t>::value);\n+static_assert (is_same<decltype (0.0F64), float64_t>::value);\n+static_assert (!is_same<decltype (0.0f64), double>::value);\n+static_assert (!is_same<decltype (0.0F64), double>::value);\n+static_assert (is_same<decltype (0.0f64 + 0.0f64), float64_t>::value);\n+static_assert (is_same<decltype (0.0F64 + 0.0F64), float64_t>::value);\n+#endif\n+#ifdef __STDCPP_FLOAT128_T__\n+static_assert (!is_same<float, float128_t>::value);\n+static_assert (!is_same<double, float128_t>::value);\n+static_assert (!is_same<long double, float128_t>::value);\n+static_assert (!is_same<decltype (0.0l), float128_t>::value);\n+static_assert (!is_same<decltype (0.0L), float128_t>::value);\n+static_assert (is_same<decltype (0.0f128), float128_t>::value);\n+static_assert (is_same<decltype (0.0F128), float128_t>::value);\n+static_assert (!is_same<decltype (0.0f128), long double>::value);\n+static_assert (!is_same<decltype (0.0F128), long double>::value);\n+static_assert (is_same<decltype (0.0f128 + 0.0f128), float128_t>::value);\n+static_assert (is_same<decltype (0.0F128 + 0.0F128), float128_t>::value);\n+#ifdef __SIZEOF_FLOAT128__\n+static_assert (!is_same<float128_t, __float128>::value);\n+static_assert (!is_same<decltype (0.0q), float128_t>::value);\n+static_assert (!is_same<decltype (0.0Q), float128_t>::value);\n+static_assert (!is_same<decltype (0.0f128), __float128>::value);\n+static_assert (!is_same<decltype (0.0F128), __float128>::value);\n+#endif\n+#endif\n+#ifdef __STDCPP_BFLOAT16_T__\n+static_assert (!is_same<float, bfloat16_t>::value);\n+static_assert (!is_same<double, bfloat16_t>::value);\n+static_assert (!is_same<long double, bfloat16_t>::value);\n+static_assert (is_same<decltype (0.0bf16), bfloat16_t>::value);\n+static_assert (is_same<decltype (0.0BF16), bfloat16_t>::value);\n+static_assert (is_same<decltype (0.0bf16 + 0.0bf16), bfloat16_t>::value);\n+static_assert (is_same<decltype (0.0BF16 + 0.0BF16), bfloat16_t>::value);\n+#endif\n+#ifdef __FLT32X_MANT_DIG__\n+static_assert (!is_same<float, _Float32x>::value);\n+static_assert (!is_same<double, _Float32x>::value);\n+static_assert (!is_same<long double, _Float32x>::value);\n+static_assert (!is_same<decltype (0.0f), _Float32x>::value);\n+static_assert (!is_same<decltype (0.0F), _Float32x>::value);\n+static_assert (is_same<decltype (0.0f32x), _Float32x>::value);\n+static_assert (is_same<decltype (0.0F32x), _Float32x>::value);\n+static_assert (!is_same<decltype (0.0f32x), float>::value);\n+static_assert (!is_same<decltype (0.0F32x), float>::value);\n+static_assert (is_same<decltype (0.0f32x + 0.0f32x), _Float32x>::value);\n+static_assert (is_same<decltype (0.0F32x + 0.0F32x), _Float32x>::value);\n+#ifdef __STDCPP_FLOAT16_T__\n+static_assert (!is_same<float16_t, _Float32x>::value);\n+static_assert (!is_same<decltype (0.0f16), _Float32x>::value);\n+static_assert (!is_same<decltype (0.0F16), _Float32x>::value);\n+static_assert (!is_same<decltype (0.0f32x), float16_t>::value);\n+static_assert (!is_same<decltype (0.0F32x), float16_t>::value);\n+#endif\n+#ifdef __STDCPP_FLOAT32_T__\n+static_assert (!is_same<float32_t, _Float32x>::value);\n+static_assert (!is_same<decltype (0.0f32), _Float32x>::value);\n+static_assert (!is_same<decltype (0.0F32), _Float32x>::value);\n+static_assert (!is_same<decltype (0.0f32x), float32_t>::value);\n+static_assert (!is_same<decltype (0.0F32x), float32_t>::value);\n+#endif\n+#ifdef __STDCPP_FLOAT64_T__\n+static_assert (!is_same<float64_t, _Float32x>::value);\n+static_assert (!is_same<decltype (0.0f64), _Float32x>::value);\n+static_assert (!is_same<decltype (0.0F64), _Float32x>::value);\n+static_assert (!is_same<decltype (0.0f32x), float64_t>::value);\n+static_assert (!is_same<decltype (0.0F32x), float64_t>::value);\n+#endif\n+#ifdef __STDCPP_FLOAT128_T__\n+static_assert (!is_same<float128_t, _Float32x>::value);\n+static_assert (!is_same<decltype (0.0f128), _Float32x>::value);\n+static_assert (!is_same<decltype (0.0F128), _Float32x>::value);\n+static_assert (!is_same<decltype (0.0f32x), float128_t>::value);\n+static_assert (!is_same<decltype (0.0F32x), float128_t>::value);\n+#endif\n+#endif\n+#ifdef __FLT64X_MANT_DIG__\n+static_assert (!is_same<float, _Float64x>::value);\n+static_assert (!is_same<double, _Float64x>::value);\n+static_assert (!is_same<long double, _Float64x>::value);\n+static_assert (!is_same<decltype (0.0), _Float64x>::value);\n+static_assert (is_same<decltype (0.0f64x), _Float64x>::value);\n+static_assert (is_same<decltype (0.0F64x), _Float64x>::value);\n+static_assert (!is_same<decltype (0.0f64x), double>::value);\n+static_assert (!is_same<decltype (0.0F64x), double>::value);\n+static_assert (is_same<decltype (0.0f64x + 0.0f64x), _Float64x>::value);\n+static_assert (is_same<decltype (0.0F64x + 0.0F64x), _Float64x>::value);\n+#ifdef __STDCPP_FLOAT16_T__\n+static_assert (!is_same<float16_t, _Float64x>::value);\n+static_assert (!is_same<decltype (0.0f16), _Float64x>::value);\n+static_assert (!is_same<decltype (0.0F16), _Float64x>::value);\n+static_assert (!is_same<decltype (0.0f64x), float16_t>::value);\n+static_assert (!is_same<decltype (0.0F64x), float16_t>::value);\n+#endif\n+#ifdef __STDCPP_FLOAT32_T__\n+static_assert (!is_same<float32_t, _Float64x>::value);\n+static_assert (!is_same<decltype (0.0f32), _Float64x>::value);\n+static_assert (!is_same<decltype (0.0F32), _Float64x>::value);\n+static_assert (!is_same<decltype (0.0f64x), float32_t>::value);\n+static_assert (!is_same<decltype (0.0F64x), float32_t>::value);\n+#endif\n+#ifdef __STDCPP_FLOAT64_T__\n+static_assert (!is_same<float64_t, _Float64x>::value);\n+static_assert (!is_same<decltype (0.0f64), _Float64x>::value);\n+static_assert (!is_same<decltype (0.0F64), _Float64x>::value);\n+static_assert (!is_same<decltype (0.0f64x), float64_t>::value);\n+static_assert (!is_same<decltype (0.0F64x), float64_t>::value);\n+#endif\n+#ifdef __STDCPP_FLOAT128_T__\n+static_assert (!is_same<float128_t, _Float64x>::value);\n+static_assert (!is_same<decltype (0.0f128), _Float64x>::value);\n+static_assert (!is_same<decltype (0.0F128), _Float64x>::value);\n+static_assert (!is_same<decltype (0.0f64x), float128_t>::value);\n+static_assert (!is_same<decltype (0.0F64x), float128_t>::value);\n+#endif\n+#ifdef __SIZEOF_FLOAT128__\n+static_assert (!is_same<_Float64x, __float128>::value);\n+static_assert (!is_same<decltype (0.0q), _Float64x>::value);\n+static_assert (!is_same<decltype (0.0Q), _Float64x>::value);\n+static_assert (!is_same<decltype (0.0f64x), __float128>::value);\n+static_assert (!is_same<decltype (0.0F64x), __float128>::value);\n+#endif\n+#endif\n+#ifdef __FLT128X_MANT_DIG__\n+static_assert (!is_same<float, _Float128x>::value);\n+static_assert (!is_same<double, _Float128x>::value);\n+static_assert (!is_same<long double, _Float128x>::value);\n+static_assert (!is_same<decltype (0.0l), _Float128x>::value);\n+static_assert (!is_same<decltype (0.0L), _Float128x>::value);\n+static_assert (is_same<decltype (0.0f128x), _Float128x>::value);\n+static_assert (is_same<decltype (0.0F128x), _Float128x>::value);\n+static_assert (!is_same<decltype (0.0f128x), long double>::value);\n+static_assert (!is_same<decltype (0.0F128x), long double>::value);\n+static_assert (is_same<decltype (0.0f128x + 0.0f128x), _Float128x>::value);\n+static_assert (is_same<decltype (0.0F128x + 0.0F128x), _Float128x>::value);\n+#ifdef __STDCPP_FLOAT16_T__\n+static_assert (!is_same<float16_t, _Float128x>::value);\n+static_assert (!is_same<decltype (0.0f16), _Float128x>::value);\n+static_assert (!is_same<decltype (0.0F16), _Float128x>::value);\n+static_assert (!is_same<decltype (0.0f128x), float16_t>::value);\n+static_assert (!is_same<decltype (0.0F128x), float16_t>::value);\n+#endif\n+#ifdef __STDCPP_FLOAT32_T__\n+static_assert (!is_same<float32_t, _Float128x>::value);\n+static_assert (!is_same<decltype (0.0f32), _Float128x>::value);\n+static_assert (!is_same<decltype (0.0F32), _Float128x>::value);\n+static_assert (!is_same<decltype (0.0f128x), float32_t>::value);\n+static_assert (!is_same<decltype (0.0F128x), float32_t>::value);\n+#endif\n+#ifdef __STDCPP_FLOAT64_T__\n+static_assert (!is_same<float64_t, _Float128x>::value);\n+static_assert (!is_same<decltype (0.0f64), _Float128x>::value);\n+static_assert (!is_same<decltype (0.0F64), _Float128x>::value);\n+static_assert (!is_same<decltype (0.0f128x), float64_t>::value);\n+static_assert (!is_same<decltype (0.0F128x), float64_t>::value);\n+#endif\n+#ifdef __STDCPP_FLOAT128_T__\n+static_assert (!is_same<float128_t, _Float128x>::value);\n+static_assert (!is_same<decltype (0.0f128), _Float128x>::value);\n+static_assert (!is_same<decltype (0.0F128), _Float128x>::value);\n+static_assert (!is_same<decltype (0.0f128x), float128_t>::value);\n+static_assert (!is_same<decltype (0.0F128x), float128_t>::value);\n+#endif\n+#ifdef __SIZEOF_FLOAT128__\n+static_assert (!is_same<_Float128x, __float128>::value);\n+static_assert (!is_same<decltype (0.0q), _Float128x>::value);\n+static_assert (!is_same<decltype (0.0Q), _Float128x>::value);\n+static_assert (!is_same<decltype (0.0f128x), __float128>::value);\n+static_assert (!is_same<decltype (0.0F128x), __float128>::value);\n+#endif\n+#endif\n+static_assert (is_same<decltype (0.0f + 0.0), double>::value);\n+static_assert (is_same<decltype (0.0 + 0.0F), double>::value);\n+static_assert (is_same<decltype (0.0L + 0.0), long double>::value);\n+static_assert (is_same<decltype (0.0 + 0.0L), long double>::value);\n+static_assert (is_same<decltype (0.0L + 0.0f), long double>::value);\n+static_assert (is_same<decltype (0.0F + 0.0l), long double>::value);\n+#if defined(__STDCPP_FLOAT16_T__) && defined(__STDCPP_FLOAT32_T__)\n+static_assert (!is_same<float16_t, float32_t>::value);\n+static_assert (is_same<decltype (0.0f16 + 0.0f32), float32_t>::value);\n+static_assert (is_same<decltype (0.0F32 + 0.0F16), float32_t>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT16_T__) && defined(__STDCPP_FLOAT64_T__)\n+static_assert (!is_same<float16_t, float64_t>::value);\n+static_assert (is_same<decltype (0.0f16 + 0.0f64), float64_t>::value);\n+static_assert (is_same<decltype (0.0F64 + 0.0F16), float64_t>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT16_T__) && defined(__STDCPP_FLOAT128_T__)\n+static_assert (!is_same<float16_t, float128_t>::value);\n+static_assert (is_same<decltype (0.0f16 + 0.0f128), float128_t>::value);\n+static_assert (is_same<decltype (0.0F128 + 0.0F16), float128_t>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT16_T__) && defined(__FLT32X_MANT_DIG__)\n+static_assert (is_same<decltype (0.0f16 + 0.0f32x), _Float32x>::value);\n+static_assert (is_same<decltype (0.0F32x + 0.0F16), _Float32x>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT16_T__) && defined(__FLT64X_MANT_DIG__)\n+static_assert (is_same<decltype (0.0f16 + 0.0f64x), _Float64x>::value);\n+static_assert (is_same<decltype (0.0F64x + 0.0F16), _Float64x>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT16_T__) && defined(__FLT128X_MANT_DIG__)\n+static_assert (is_same<decltype (0.0f16 + 0.0f128x), _Float128x>::value);\n+static_assert (is_same<decltype (0.0F128x + 0.0F16), _Float128x>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT32_T__) && defined(__STDCPP_FLOAT64_T__)\n+static_assert (!is_same<float32_t, float64_t>::value);\n+static_assert (is_same<decltype (0.0f32 + 0.0f64), float64_t>::value);\n+static_assert (is_same<decltype (0.0F64 + 0.0F32), float64_t>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT32_T__) && defined(__STDCPP_FLOAT128_T__)\n+static_assert (!is_same<float32_t, float128_t>::value);\n+static_assert (is_same<decltype (0.0f32 + 0.0f128), float128_t>::value);\n+static_assert (is_same<decltype (0.0F128 + 0.0F32), float128_t>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT32_T__) && defined(__FLT32X_MANT_DIG__)\n+static_assert (is_same<decltype (0.0f32 + 0.0f32x), _Float32x>::value);\n+static_assert (is_same<decltype (0.0F32x + 0.0F32), _Float32x>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT32_T__) && defined(__FLT64X_MANT_DIG__)\n+static_assert (is_same<decltype (0.0f32 + 0.0f64x), _Float64x>::value);\n+static_assert (is_same<decltype (0.0F64x + 0.0F32), _Float64x>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT32_T__) && defined(__FLT128X_MANT_DIG__)\n+static_assert (is_same<decltype (0.0f32 + 0.0f128x), _Float128x>::value);\n+static_assert (is_same<decltype (0.0F128x + 0.0F32), _Float128x>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT64_T__) && defined(__STDCPP_FLOAT128_T__)\n+static_assert (!is_same<float64_t, float128_t>::value);\n+static_assert (is_same<decltype (0.0f64 + 0.0f128), float128_t>::value);\n+static_assert (is_same<decltype (0.0F128 + 0.0F64), float128_t>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT64_T__) && defined(__FLT32X_MANT_DIG__) \\\n+    && __FLT64_MAX_EXP__ == __FLT32X_MAX_EXP__ \\\n+    && __FLT64_MANT_DIG__ == __FLT32X_MANT_DIG__\n+static_assert (is_same<decltype (0.0f64 + 0.0f32x), float64_t>::value);\n+static_assert (is_same<decltype (0.0F32x + 0.0F64), float64_t>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT64_T__) && defined(__FLT64X_MANT_DIG__)\n+static_assert (is_same<decltype (0.0f64 + 0.0f64x), _Float64x>::value);\n+static_assert (is_same<decltype (0.0F64x + 0.0F64), _Float64x>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT64_T__) && defined(__FLT128X_MANT_DIG__)\n+static_assert (is_same<decltype (0.0f64 + 0.0f128x), _Float128x>::value);\n+static_assert (is_same<decltype (0.0F128x + 0.0F64), _Float128x>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT128_T__) && defined(__FLT32X_MANT_DIG__) \\\n+    && __FLT128_MAX_EXP__ >= __FLT32X_MAX_EXP__ \\\n+    && __FLT128_MANT_DIG__ >= __FLT32X_MANT_DIG__\n+static_assert (is_same<decltype (0.0f128 + 0.0f32x), float128_t>::value);\n+static_assert (is_same<decltype (0.0F32x + 0.0F128), float128_t>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT128_T__) && defined(__FLT64X_MANT_DIG__) \\\n+    && __FLT128_MAX_EXP__ >= __FLT64X_MAX_EXP__ \\\n+    && __FLT128_MANT_DIG__ >= __FLT64X_MANT_DIG__\n+static_assert (is_same<decltype (0.0f128 + 0.0f64x), float128_t>::value);\n+static_assert (is_same<decltype (0.0F64x + 0.0F128), float128_t>::value);\n+#endif\n+#if defined(__STDCPP_FLOAT128_T__) && defined(__FLT128X_MANT_DIG__)\n+static_assert (is_same<decltype (0.0f128 + 0.0f128x), _Float128>::value);\n+static_assert (is_same<decltype (0.0F128x + 0.0F128), _Float128>::value);\n+#endif\n+#if defined(__STDCPP_BFLOAT16_T__) && defined(__STDCPP_FLOAT32_T__)\n+static_assert (!is_same<bfloat16_t, float32_t>::value);\n+static_assert (is_same<decltype (0.0bf16 + 0.0f32), float32_t>::value);\n+static_assert (is_same<decltype (0.0F32 + 0.0BF16), float32_t>::value);\n+#endif\n+#if defined(__STDCPP_BFLOAT16_T__) && defined(__STDCPP_FLOAT64_T__)\n+static_assert (!is_same<bfloat16_t, float64_t>::value);\n+static_assert (is_same<decltype (0.0bf16 + 0.0f64), float64_t>::value);\n+static_assert (is_same<decltype (0.0F64 + 0.0BF16), float64_t>::value);\n+#endif\n+#if defined(__STDCPP_BFLOAT16_T__) && defined(__STDCPP_FLOAT128_T__)\n+static_assert (!is_same<bfloat16_t, float128_t>::value);\n+static_assert (is_same<decltype (0.0bf16 + 0.0f128), float128_t>::value);\n+static_assert (is_same<decltype (0.0F128 + 0.0BF16), float128_t>::value);\n+#endif\n+#ifdef __STDCPP_FLOAT16_T__\n+#if __FLT_MAX_EXP__ > __FLT16_MAX_EXP__ && __FLT_MANT_DIG__ > __FLT16_MANT_DIG__\n+static_assert (is_same<decltype (0.0f + 0.0f16), float>::value);\n+static_assert (is_same<decltype (0.0F16 + 0.0F), float>::value);\n+#endif\n+#if __DBL_MAX_EXP__ > __FLT16_MAX_EXP__ && __DBL_MANT_DIG__ > __FLT16_MANT_DIG__\n+static_assert (is_same<decltype (0.0 + 0.0f16), double>::value);\n+static_assert (is_same<decltype (0.0F16 + 0.0), double>::value);\n+#endif\n+#if __LDBL_MAX_EXP__ > __FLT16_MAX_EXP__ && __LDBL_MANT_DIG__ > __FLT16_MANT_DIG__\n+static_assert (is_same<decltype (0.0L + 0.0f16), long double>::value);\n+static_assert (is_same<decltype (0.0F16 + 0.0l), long double>::value);\n+#endif\n+#endif\n+#ifdef __STDCPP_FLOAT32_T__\n+#if __FLT_MAX_EXP__ == __FLT32_MAX_EXP__ && __FLT_MANT_DIG__ == __FLT32_MANT_DIG__\n+static_assert (is_same<decltype (0.0f + 0.0f32), float32_t>::value);\n+static_assert (is_same<decltype (0.0F32 + 0.0F), float32_t>::value);\n+#endif\n+#if __DBL_MAX_EXP__ > __FLT32_MAX_EXP__ && __DBL_MANT_DIG__ > __FLT32_MANT_DIG__\n+static_assert (is_same<decltype (0.0 + 0.0f32), double>::value);\n+static_assert (is_same<decltype (0.0F32 + 0.0), double>::value);\n+#endif\n+#if __LDBL_MAX_EXP__ > __FLT32_MAX_EXP__ && __LDBL_MANT_DIG__ > __FLT32_MANT_DIG__\n+static_assert (is_same<decltype (0.0L + 0.0f32), long double>::value);\n+static_assert (is_same<decltype (0.0F32 + 0.0l), long double>::value);\n+#endif\n+#endif\n+#ifdef __STDCPP_FLOAT64_T__\n+#if __FLT_MAX_EXP__ < __FLT64_MAX_EXP__ && __FLT_MANT_DIG__ < __FLT64_MANT_DIG__\n+static_assert (is_same<decltype (0.0f + 0.0f64), float64_t>::value);\n+static_assert (is_same<decltype (0.0F64 + 0.0F), float64_t>::value);\n+#endif\n+#if __DBL_MAX_EXP__ == __FLT64_MAX_EXP__ && __DBL_MANT_DIG__ == __FLT64_MANT_DIG__\n+static_assert (is_same<decltype (0.0 + 0.0f64), float64_t>::value);\n+static_assert (is_same<decltype (0.0F64 + 0.0), float64_t>::value);\n+#endif\n+#if __LDBL_MAX_EXP__ > __FLT64_MAX_EXP__ && __LDBL_MANT_DIG__ > __FLT64_MANT_DIG__\n+static_assert (is_same<decltype (0.0L + 0.0f64), long double>::value);\n+static_assert (is_same<decltype (0.0F64 + 0.0l), long double>::value);\n+#endif\n+#if __LDBL_MAX_EXP__ == __FLT64_MAX_EXP__ && __LDBL_MANT_DIG__ == __FLT64_MANT_DIG__ \\\n+    && __DBL_MAX_EXP__ == __FLT64_MAX_EXP__ && __DBL_MANT_DIG__ == __FLT64_MANT_DIG__\n+// An extended floating-point type with the same set of values as more than one\n+// cv-unqualified standard floating-point type has a rank equal to the rank of\n+// double.\n+// Then long double will have higher rank than float64_t.\n+static_assert (is_same<decltype (0.0L + 0.0f64), long double>::value);\n+static_assert (is_same<decltype (0.0F64 + 0.0l), long double>::value);\n+#endif\n+#endif\n+#ifdef __STDCPP_FLOAT128_T__\n+#if __FLT_MAX_EXP__ < __FLT128_MAX_EXP__ && __FLT_MANT_DIG__ < __FLT128_MANT_DIG__\n+static_assert (is_same<decltype (0.0f + 0.0f128), float128_t>::value);\n+static_assert (is_same<decltype (0.0F128 + 0.0F), float128_t>::value);\n+#endif\n+#if __DBL_MAX_EXP__ < __FLT128_MAX_EXP__ && __DBL_MANT_DIG__ < __FLT128_MANT_DIG__\n+static_assert (is_same<decltype (0.0 + 0.0f128), float128_t>::value);\n+static_assert (is_same<decltype (0.0F128 + 0.0), float128_t>::value);\n+#endif\n+#if __LDBL_MAX_EXP__ <= __FLT128_MAX_EXP__ && __LDBL_MANT_DIG__ <= __FLT128_MANT_DIG__ \\\n+    && __LDBL_MANT_DIG__ != 106 // IBM extended long double and IEEE quad are unordered.\n+static_assert (is_same<decltype (0.0L + 0.0f128), float128_t>::value);\n+static_assert (is_same<decltype (0.0F128 + 0.0l), float128_t>::value);\n+#endif\n+#ifdef __SIZEOF_FLOAT128__\n+static_assert (is_same<decltype (0.0Q + 0.0f128), float128_t>::value);\n+static_assert (is_same<decltype (0.0F128 + 0.0q), float128_t>::value);\n+#endif\n+#endif\n+#ifdef __STDCPP_BFLOAT16_T__\n+#if __FLT_MAX_EXP__ > __BFLT16_MAX_EXP__ && __FLT_MANT_DIG__ > __BFLT16_MANT_DIG__\n+static_assert (is_same<decltype (0.0f + 0.0bf16), float>::value);\n+static_assert (is_same<decltype (0.0BF16 + 0.0F), float>::value);\n+#endif\n+#if __DBL_MAX_EXP__ > __BFLT16_MAX_EXP__ && __DBL_MANT_DIG__ > __BFLT16_MANT_DIG__\n+static_assert (is_same<decltype (0.0 + 0.0bf16), double>::value);\n+static_assert (is_same<decltype (0.0BF16 + 0.0), double>::value);\n+#endif\n+#if __LDBL_MAX_EXP__ > __BFLT16_MAX_EXP__ && __LDBL_MANT_DIG__ > __BFLT16_MANT_DIG__\n+static_assert (is_same<decltype (0.0L + 0.0bf16), long double>::value);\n+static_assert (is_same<decltype (0.0BF16 + 0.0l), long double>::value);\n+#endif\n+#endif\n+\n+void foo (float) {}\n+void foo (double) {}\n+void foo (long double) {}\n+#ifdef __STDCPP_FLOAT16_T__\n+void foo (float16_t) {}\n+#endif\n+#ifdef __STDCPP_FLOAT32_T__\n+void foo (float32_t) {}\n+#endif\n+#ifdef __STDCPP_FLOAT64_T__\n+void foo (float64_t) {}\n+#endif\n+#ifdef __STDCPP_FLOAT128_T__\n+void foo (float128_t) {}\n+#endif\n+#ifdef __STDCPP_BFLOAT16_T__\n+void foo (bfloat16_t) {}\n+#endif\n+#ifdef __FLT32X_MANT_DIG__\n+void foo (_Float32x) {}\n+#endif\n+#ifdef __FLT64X_MANT_DIG__\n+void foo (_Float64x) {}\n+#endif\n+#ifdef __FLT128X_MANT_DIG__\n+void foo (_Float128x) {}\n+#endif"}, {"sha": "f5563fedd8271a455d24ded78ac756bf6b8225b2", "filename": "gcc/testsuite/g++.dg/cpp23/ext-floating10.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating10.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,13 @@\n+// P1467R9 - Extended floating-point types and standard names.\n+// { dg-do run { target { c++23 && float128_runtime } } }\n+// { dg-options \"\" }\n+// { dg-add-options float128 }\n+\n+#ifndef WIDTH\n+#ifndef __STDCPP_FLOAT128_T__\n+#error Unexpected\n+#endif\n+#define WIDTH 128\n+#endif\n+\n+#include \"ext-floating7.C\""}, {"sha": "41e9a54ada5c5bd41a28ddc68c05d5d626d9a788", "filename": "gcc/testsuite/g++.dg/cpp23/ext-floating2.C", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating2.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,157 @@\n+// P1467R9 - Extended floating-point types and standard names.\n+// { dg-do compile { target c++23 } }\n+// { dg-options \"\" }\n+\n+#include \"ext-floating.h\"\n+\n+#ifdef __STRICT_ANSI__\n+#undef __SIZEOF_FLOAT128__\n+#endif\n+\n+using namespace std;\n+\n+float fa = 1.0f;\n+float fb = (float) 1.0f;\n+float fc = 1.0;\n+float fd = (float) 1.0;\n+float fe = 1.0L;\n+float ff = (float) 1.0L;\n+#ifdef __SIZEOF_FLOAT128__\n+float fg = 1.0Q;\n+float fh = (float) 1.0Q;\n+#endif\n+double da = 1.0f;\n+double db = (double) 1.0f;\n+double dc = 1.0;\n+double dd = (double) 1.0;\n+double de = 1.0L;\n+double df = (double) 1.0L;\n+#ifdef __SIZEOF_FLOAT128__\n+double dg = 1.0Q;\n+double dh = (double) 1.0Q;\n+#endif\n+long double lda = 1.0f;\n+long double ldb = (long double) 1.0f;\n+long double ldc = 1.0;\n+long double ldd = (long double) 1.0;\n+long double lde = 1.0L;\n+long double ldf = (long double) 1.0L;\n+#ifdef __SIZEOF_FLOAT128__\n+long double ldg = 1.0Q;\n+long double ldh = (long double) 1.0Q;\n+__float128 qa = 1.0f;\n+__float128 qb = (__float128) 1.0f;\n+__float128 qc = 1.0;\n+__float128 qd = (__float128) 1.0;\n+__float128 qe = 1.0L;\n+__float128 qf = (__float128) 1.0L;\n+__float128 qg = 1.0Q;\n+__float128 qh = (__float128) 1.0Q;\n+#endif\n+#ifdef __STDCPP_FLOAT16_T__\n+float16_t f16a = 1.0F16;\n+float16_t f16b = (float16_t) 1.0F16;\n+#ifdef __STDCPP_FLOAT32_T__\n+float16_t f16c = 1.0F32;\t\t// { dg-warning \"converting to 'std::float16_t' \\\\\\{aka '_Float16'\\\\\\} from '_Float32' with greater conversion rank\" \"\" { target { float16 && float32 } } }\n+float16_t f16d = (float16_t) 1.0F32;\n+#endif\n+#ifdef __STDCPP_FLOAT64_T__\n+float16_t f16e = 1.0F64;\t\t// { dg-warning \"converting to 'std::float16_t' \\\\\\{aka '_Float16'\\\\\\} from '_Float64' with greater conversion rank\" \"\" { target { float16 && float64 } } }\n+float16_t f16f = (float16_t) 1.0F64;\n+#endif\n+#ifdef __STDCPP_FLOAT128_T__\n+float16_t f16g = 1.0F128;\t\t// { dg-warning \"converting to 'std::float16_t' \\\\\\{aka '_Float16'\\\\\\} from '_Float128' with greater conversion rank\" \"\" { target { float16 && float128 } } }\n+float16_t f16h = (float16_t) 1.0F128;\n+#endif\n+float16_t f16j = (float16_t) 1.0f;\n+float16_t f16l = (float16_t) 1.0;\n+float16_t f16n = (float16_t) 1.0L;\n+#ifdef __SIZEOF_FLOAT128__\n+float16_t f16p = (float16_t) 1.0Q;\n+#endif\n+#endif\n+#ifdef __STDCPP_FLOAT32_T__\n+#ifdef __STDCPP_FLOAT16_T__\n+float32_t f32a = 1.0F16;\n+float32_t f32b = (float32_t) 1.0F16;\n+#endif\n+float32_t f32c = 1.0F32;\n+float32_t f32d = (float32_t) 1.0F32;\n+#ifdef __STDCPP_FLOAT64_T__\n+float32_t f32e = 1.0F64;\t\t// { dg-warning \"converting to 'std::float32_t' \\\\\\{aka '_Float32'\\\\\\} from '_Float64' with greater conversion rank\" \"\" { target { float32 && float64 } } }\n+float32_t f32f = (float32_t) 1.0F64;\n+#endif\n+#ifdef __STDCPP_FLOAT128_T__\n+float32_t f32g = 1.0F128;\t\t// { dg-warning \"converting to 'std::float32_t' \\\\\\{aka '_Float32'\\\\\\} from '_Float128' with greater conversion rank\" \"\" { target { float32 && float128 } } }\n+float32_t f32h = (float32_t) 1.0F128;\n+#endif\n+#if __FLT_MAX_EXP__ <= __FLT32_MAX_EXP__ && __FLT_MANT_DIG__ <= __FLT32_MANT_DIG__\n+float32_t f32i = 1.0f;\n+#endif\n+float32_t f32j = (float32_t) 1.0f;\n+float32_t f32l = (float32_t) 1.0;\n+float32_t f32n = (float32_t) 1.0L;\n+#ifdef __SIZEOF_FLOAT128__\n+float32_t f32p = (float32_t) 1.0Q;\n+#endif\n+#endif\n+#ifdef __STDCPP_FLOAT64_T__\n+#ifdef __STDCPP_FLOAT16_T__\n+float64_t f64a = 1.0F16;\n+float64_t f64b = (float64_t) 1.0F16;\n+#endif\n+#ifdef __STDCPP_FLOAT32_T__\n+float64_t f64c = 1.0F32;\n+float64_t f64d = (float64_t) 1.0F32;\n+#endif\n+float64_t f64e = 1.0F64;\n+float64_t f64f = (float64_t) 1.0F64;\n+#ifdef __STDCPP_FLOAT128_T__\n+float64_t f64g = 1.0F128;\t\t// { dg-warning \"converting to 'std::float64_t' \\\\\\{aka '_Float64'\\\\\\} from '_Float128' with greater conversion rank\" \"\" { target { float64 && float128 } } }\n+float64_t f64h = (float64_t) 1.0F128;\n+#endif\n+#if __FLT_MAX_EXP__ <= __FLT64_MAX_EXP__ && __FLT_MANT_DIG__ <= __FLT64_MANT_DIG__\n+float64_t f64i = 1.0f;\n+#endif\n+float64_t f64j = (float64_t) 1.0f;\n+#if __DBL_MAX_EXP__ <= __FLT64_MAX_EXP__ && __DBL_MANT_DIG__ <= __FLT64_MANT_DIG__\n+float64_t f64k = 1.0;\n+#endif\n+float64_t f64l = (float64_t) 1.0;\n+float64_t f64n = (float64_t) 1.0L;\n+#ifdef __SIZEOF_FLOAT128__\n+float64_t f64p = (float64_t) 1.0Q;\n+#endif\n+#endif\n+#ifdef __STDCPP_FLOAT128_T__\n+#ifdef __STDCPP_FLOAT16_T__\n+float128_t f128a = 1.0F16;\n+float128_t f128b = (float128_t) 1.0F16;\n+#endif\n+#ifdef __STDCPP_FLOAT32_T__\n+float128_t f128c = 1.0F32;\n+float128_t f128d = (float128_t) 1.0F32;\n+#endif\n+#ifdef __STDCPP_FLOAT64_T__\n+float128_t f128e = 1.0F64;\n+float128_t f128f = (float128_t) 1.0F64;\n+#endif\n+float128_t f128g = 1.0F128;\n+float128_t f128h = (float128_t) 1.0F128;\n+#if __FLT_MAX_EXP__ <= __FLT128_MAX_EXP__ && __FLT_MANT_DIG__ <= __FLT128_MANT_DIG__\n+float128_t f128i = 1.0f;\n+#endif\n+float128_t f128j = (float128_t) 1.0f;\n+#if __DBL_MAX_EXP__ <= __FLT128_MAX_EXP__ && __DBL_MANT_DIG__ <= __FLT128_MANT_DIG__\n+float128_t f128k = 1.0;\n+#endif\n+float128_t f128l = (float128_t) 1.0;\n+#if __LDBL_MAX_EXP__ <= __FLT128_MAX_EXP__ && __LDBL_MANT_DIG__ <= __FLT128_MANT_DIG__ && __LDBL_MANT_DIG__ != 106\n+float128_t f128m = 1.0L;\n+#endif\n+float128_t f128n = (float128_t) 1.0L;\n+#ifdef __SIZEOF_FLOAT128__\n+float128_t f128o = 1.0Q;\n+float128_t f128p = (float128_t) 1.0Q;\n+#endif\n+#endif"}, {"sha": "ca9399fccd2a67341a61d57d79735060bc1fa52d", "filename": "gcc/testsuite/g++.dg/cpp23/ext-floating3.C", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating3.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,134 @@\n+// P1467R9 - Extended floating-point types and standard names.\n+// Variant of ext-floating2.C test with x86 specific assumptions\n+// about float, double, long double and existence of __float128.\n+// And some further tests.\n+// { dg-do compile { target { c++23 && { i?86-*-linux* x86_64-*-linux* } } } }\n+// { dg-options \"\" }\n+\n+#include \"ext-floating.h\"\n+\n+#if !defined(__STDCPP_FLOAT32_T__) \\\n+    || !defined(__STDCPP_FLOAT64_T__) || !defined(__STDCPP_FLOAT128_T__) \\\n+    || __FLT_MAX_EXP__ != __FLT32_MAX_EXP__ || __FLT_MANT_DIG__ != __FLT32_MANT_DIG__ \\\n+    || __DBL_MAX_EXP__ != __FLT64_MAX_EXP__ || __DBL_MANT_DIG__ != __FLT64_MANT_DIG__ \\\n+    || __LDBL_MAX_EXP__ != __FLT128_MAX_EXP__ || __LDBL_MANT_DIG__ >= __FLT128_MANT_DIG__ \\\n+    || !defined(__SIZEOF_FLOAT128__)\n+#error Unexpected set of floating point types\n+#endif\n+\n+using namespace std;\n+\n+#ifdef __STDCPP_FLOAT16_T__\n+float16_t f16i = 1.0f;\t\t\t// { dg-warning \"converting to 'std::float16_t' \\\\\\{aka '_Float16'\\\\\\} from 'float' with greater conversion rank\" \"\" { target float16 } }\n+float16_t f16k = 1.0;\t\t\t// { dg-warning \"converting to 'std::float16_t' \\\\\\{aka '_Float16'\\\\\\} from 'double' with greater conversion rank\" \"\" { target float16 } }\n+float16_t f16m = 1.0L;\t\t\t// { dg-warning \"converting to 'std::float16_t' \\\\\\{aka '_Float16'\\\\\\} from 'long double' with greater conversion rank\" \"\" { target float16 } }\n+float16_t f16o = 1.0Q;\t\t\t// { dg-warning \"converting to 'std::float16_t' \\\\\\{aka '_Float16'\\\\\\} from '__float128' with greater conversion rank\" \"\" { target float16 } }\n+#endif\n+float32_t f32i = 1.0f;\n+float32_t f32k = 1.0;\t\t\t// { dg-warning \"converting to 'std::float32_t' \\\\\\{aka '_Float32'\\\\\\} from 'double' with greater conversion rank\" }\n+float32_t f32m = 1.0L;\t\t\t// { dg-warning \"converting to 'std::float32_t' \\\\\\{aka '_Float32'\\\\\\} from 'long double' with greater conversion rank\" }\n+float32_t f32o = 1.0Q;\t\t\t// { dg-warning \"converting to 'std::float32_t' \\\\\\{aka '_Float32'\\\\\\} from '__float128' with greater conversion rank\" }\n+float64_t f64i = 1.0f;\n+float64_t f64k = 1.0;\n+float64_t f64m = 1.0L;\t\t\t// { dg-warning \"converting to 'std::float64_t' \\\\\\{aka '_Float64'\\\\\\} from 'long double' with greater conversion rank\" }\n+float64_t f64o = 1.0Q;\t\t\t// { dg-warning \"converting to 'std::float64_t' \\\\\\{aka '_Float64'\\\\\\} from '__float128' with greater conversion rank\" }\n+float128_t f128i = 1.0f;\n+float128_t f128k = 1.0;\n+float128_t f128m = 1.0L;\n+float128_t f128o = 1.0Q;\n+\n+#ifdef __STDCPP_FLOAT16_T__\n+constexpr float16_t f16x = 1.0F16;\n+#endif\n+constexpr float32_t f32x = 2.0F32;\n+constexpr float64_t f64x = 3.0F64;\n+constexpr float128_t f128x = 4.0F128;\n+constexpr float fx = 5.0f;\n+constexpr double dx = 6.0;\n+constexpr long double ldx = 7.0L;\n+\n+constexpr int foo (float32_t) { return 1; }\n+constexpr int foo (float64_t) { return 2; }\n+constexpr int bar (float) { return 3; }\n+constexpr int bar (double) { return 4; }\n+constexpr int bar (long double) { return 5; }\n+constexpr int baz (float32_t) { return 6; }\n+constexpr int baz (float64_t) { return 7; }\n+constexpr int baz (float128_t) { return 8; }\n+constexpr int qux (float64_t) { return 9; }\n+constexpr int qux (float32_t) { return 10; }\n+constexpr int fred (long double) { return 11; }\n+constexpr int fred (double) { return 12; }\n+constexpr int fred (float) { return 13; }\n+constexpr int thud (float128_t) { return 14; }\n+constexpr int thud (float64_t) { return 15; }\n+constexpr int thud (float32_t) { return 16; }\n+struct S {\n+  constexpr operator float32_t () const { return 1.0f32; }\n+  constexpr operator float64_t () const { return 2.0f64; }\n+};\n+struct T {\n+  constexpr operator float64_t () const { return 3.0f64; }\n+  constexpr operator float32_t () const { return 4.0f32; }\n+};\n+\n+void\n+test (S s, T t)\n+{\n+#ifdef __STDCPP_FLOAT16_T__\n+  foo (float16_t (1.0));\t\t\t// { dg-error \"call of overloaded 'foo\\\\\\(std::float16_t\\\\\\)' is ambiguous\" \"\" { target float16 } }\n+#endif\n+  static_assert (foo (float (2.0)) == 1);\n+  static_assert (foo (double (3.0)) == 2);\n+  constexpr double x (s);\n+  static_assert (x == 2.0);\n+#ifdef __STDCPP_FLOAT16_T__\n+  bar (f16x);\t\t\t\t\t// { dg-error \"call of overloaded 'bar\\\\\\(const std::float16_t\\\\\\&\\\\\\)' is ambiguous\" \"\" { target float16 } }\n+#endif\n+  static_assert (bar (f32x) == 3);\n+  static_assert (bar (f64x) == 4);\n+  bar (f128x);\t\t\t\t\t// { dg-error \"no matching function for call to 'bar\\\\\\(const std::float128_t\\\\\\&\\\\\\)'\" }\n+\t\t\t\t\t\t// { dg-warning \"converting to 'float' from 'const std::float128_t' \\\\\\{aka 'const _Float128'\\\\\\} with greater conversion rank\" \"\" { target *-*-* } .-1 }\n+\t\t\t\t\t\t// { dg-warning \"converting to 'double' from 'const std::float128_t' \\\\\\{aka 'const _Float128'\\\\\\} with greater conversion rank\" \"\" { target *-*-* } .-2 }\n+\t\t\t\t\t\t// { dg-warning \"converting to 'long double' from 'const std::float128_t' \\\\\\{aka 'const _Float128'\\\\\\} with greater conversion rank\" \"\" { target *-*-* } .-3 }\n+  static_assert (bar (fx) == 3);\n+  static_assert (bar (dx) == 4);\n+  static_assert (bar (ldx) == 5);\n+#ifdef __STDCPP_FLOAT16_T__\n+  baz (f16x);\t\t\t\t\t// { dg-error \"call of overloaded 'baz\\\\\\(const std::float16_t\\\\\\&\\\\\\)' is ambiguous\" \"\" { target float16 } }\n+#endif\n+  static_assert (baz (f32x) == 6);\n+  static_assert (baz (f64x) == 7);\n+  static_assert (baz (f128x) == 8);\n+  static_assert (baz (fx) == 6);\n+  static_assert (baz (dx) == 7);\n+  static_assert (baz (ldx) == 8);\n+#ifdef __STDCPP_FLOAT16_T__\n+  qux (float16_t (1.0));\t\t\t// { dg-error \"call of overloaded 'qux\\\\\\(std::float16_t\\\\\\)' is ambiguous\" \"\" { target float16 } }\n+#endif\n+  static_assert (qux (float (2.0)) == 10);\n+  static_assert (qux (double (3.0)) == 9);\n+  constexpr double y (t);\n+  static_assert (y == 3.0);\n+#ifdef __STDCPP_FLOAT16_T__\n+  fred (f16x);\t\t\t\t\t// { dg-error \"call of overloaded 'fred\\\\\\(const std::float16_t\\\\\\&\\\\\\)' is ambiguous\" \"\" { target float16 } }\n+#endif\n+  static_assert (fred (f32x) == 13);\n+  static_assert (fred (f64x) == 12);\n+  fred (f128x);\t\t\t\t\t// { dg-error \"no matching function for call to 'fred\\\\\\(const std::float128_t\\\\\\&\\\\\\)'\" }\n+\t\t\t\t\t\t// { dg-warning \"converting to 'float' from 'const std::float128_t' \\\\\\{aka 'const _Float128'\\\\\\} with greater conversion rank\" \"\" { target *-*-* } .-1 }\n+\t\t\t\t\t\t// { dg-warning \"converting to 'double' from 'const std::float128_t' \\\\\\{aka 'const _Float128'\\\\\\} with greater conversion rank\" \"\" { target *-*-* } .-2 }\n+\t\t\t\t\t\t// { dg-warning \"converting to 'long double' from 'const std::float128_t' \\\\\\{aka 'const _Float128'\\\\\\} with greater conversion rank\" \"\" { target *-*-* } .-3 }\n+  static_assert (fred (fx) == 13);\n+  static_assert (fred (dx) == 12);\n+  static_assert (fred (ldx) == 11);\n+#ifdef __STDCPP_FLOAT16_T__\n+  thud (f16x);\t\t\t\t\t// { dg-error \"call of overloaded 'thud\\\\\\(const std::float16_t\\\\\\&\\\\\\)' is ambiguous\" \"\" { target float16 } }\n+#endif\n+  static_assert (thud (f32x) == 16);\n+  static_assert (thud (f64x) == 15);\n+  static_assert (thud (f128x) == 14);\n+  static_assert (thud (fx) == 16);\n+  static_assert (thud (dx) == 15);\n+  static_assert (thud (ldx) == 14);\n+}"}, {"sha": "1bac1051f44b5e225a1bd692d56672cb9c09832b", "filename": "gcc/testsuite/g++.dg/cpp23/ext-floating4.C", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating4.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,126 @@\n+// P1467R9 - Extended floating-point types and standard names.\n+// Variant of ext-floating3.C test with different specific assumptions\n+// about float, double, long double.\n+// float, double and long double are assumed to be IEEE 754 single, double\n+// and quad.\n+// { dg-do compile { target { c++23 && { aarch64*-*-* powerpc64le*-*-linux* riscv*-*-* s390*-*-* sparc*-*-linux* } } } }\n+// { dg-options \"\" }\n+// { dg-additional-options \"-mlong-double-128\" { target s390*-*-* sparc*-*-linux* } }\n+// { dg-additional-options \"-mvsx -mfloat128 -mlong-double-128 -mabi=ieeelongdouble -Wno-psabi\" { target powerpc64le*-*-linux* } }\n+\n+#include \"ext-floating.h\"\n+\n+#if !defined(__STDCPP_FLOAT32_T__) \\\n+    || !defined(__STDCPP_FLOAT64_T__) || !defined(__STDCPP_FLOAT128_T__) \\\n+    || __FLT_MAX_EXP__ != __FLT32_MAX_EXP__ || __FLT_MANT_DIG__ != __FLT32_MANT_DIG__ \\\n+    || __DBL_MAX_EXP__ != __FLT64_MAX_EXP__ || __DBL_MANT_DIG__ != __FLT64_MANT_DIG__ \\\n+    || __LDBL_MAX_EXP__ != __FLT128_MAX_EXP__ || __LDBL_MANT_DIG__ != __FLT128_MANT_DIG__\n+#error Unexpected set of floating point types\n+#endif\n+\n+using namespace std;\n+\n+#ifdef __STDCPP_FLOAT16_T__\n+float16_t f16i = 1.0f;\t\t\t// { dg-warning \"converting to 'std::float16_t' \\\\\\{aka '_Float16'\\\\\\} from 'float' with greater conversion rank\" \"\" { target float16 } }\n+float16_t f16k = 1.0;\t\t\t// { dg-warning \"converting to 'std::float16_t' \\\\\\{aka '_Float16'\\\\\\} from 'double' with greater conversion rank\" \"\" { target float16 } }\n+float16_t f16m = 1.0L;\t\t\t// { dg-warning \"converting to 'std::float16_t' \\\\\\{aka '_Float16'\\\\\\} from 'long double' with greater conversion rank\" \"\" { target float16 } }\n+#endif\n+float32_t f32i = 1.0f;\n+float32_t f32k = 1.0;\t\t\t// { dg-warning \"converting to 'std::float32_t' \\\\\\{aka '_Float32'\\\\\\} from 'double' with greater conversion rank\" }\n+float32_t f32m = 1.0L;\t\t\t// { dg-warning \"converting to 'std::float32_t' \\\\\\{aka '_Float32'\\\\\\} from 'long double' with greater conversion rank\" }\n+float64_t f64i = 1.0f;\n+float64_t f64k = 1.0;\n+float64_t f64m = 1.0L;\t\t\t// { dg-warning \"converting to 'std::float64_t' \\\\\\{aka '_Float64'\\\\\\} from 'long double' with greater conversion rank\" }\n+float128_t f128i = 1.0f;\n+float128_t f128k = 1.0;\n+float128_t f128m = 1.0L;\n+\n+#ifdef __STDCPP_FLOAT16_T__\n+constexpr float16_t f16x = 1.0F16;\n+#endif\n+constexpr float32_t f32x = 2.0F32;\n+constexpr float64_t f64x = 3.0F64;\n+constexpr float128_t f128x = 4.0F128;\n+constexpr float fx = 5.0f;\n+constexpr double dx = 6.0;\n+constexpr long double ldx = 7.0L;\n+\n+constexpr int foo (float32_t) { return 1; }\n+constexpr int foo (float64_t) { return 2; }\n+constexpr int bar (float) { return 3; }\n+constexpr int bar (double) { return 4; }\n+constexpr int bar (long double) { return 5; }\n+constexpr int baz (float32_t) { return 6; }\n+constexpr int baz (float64_t) { return 7; }\n+constexpr int baz (float128_t) { return 8; }\n+constexpr int qux (float64_t) { return 9; }\n+constexpr int qux (float32_t) { return 10; }\n+constexpr int fred (long double) { return 11; }\n+constexpr int fred (double) { return 12; }\n+constexpr int fred (float) { return 13; }\n+constexpr int thud (float128_t) { return 14; }\n+constexpr int thud (float64_t) { return 15; }\n+constexpr int thud (float32_t) { return 16; }\n+struct S {\n+  constexpr operator float32_t () const { return 1.0f32; }\n+  constexpr operator float64_t () const { return 2.0f64; }\n+};\n+struct T {\n+  constexpr operator float64_t () const { return 3.0f64; }\n+  constexpr operator float32_t () const { return 4.0f32; }\n+};\n+\n+void\n+test (S s, T t)\n+{\n+#ifdef __STDCPP_FLOAT16_T__\n+  foo (float16_t (1.0));\t\t\t// { dg-error \"call of overloaded 'foo\\\\\\(std::float16_t\\\\\\)' is ambiguous\" \"\" { target float16 } }\n+#endif\n+  static_assert (foo (float (2.0)) == 1);\n+  static_assert (foo (double (3.0)) == 2);\n+  constexpr double x (s);\n+  static_assert (x == 2.0);\n+#ifdef __STDCPP_FLOAT16_T__\n+  bar (f16x);\t\t\t\t\t// { dg-error \"call of overloaded 'bar\\\\\\(const std::float16_t\\\\\\&\\\\\\)' is ambiguous\" \"\" { target float16 } }\n+#endif\n+  static_assert (bar (f32x) == 3);\n+  static_assert (bar (f64x) == 4);\n+  static_assert (bar (f128x) == 5);\n+  static_assert (bar (fx) == 3);\n+  static_assert (bar (dx) == 4);\n+  static_assert (bar (ldx) == 5);\n+#ifdef __STDCPP_FLOAT16_T__\n+  baz (f16x);\t\t\t\t\t// { dg-error \"call of overloaded 'baz\\\\\\(const std::float16_t\\\\\\&\\\\\\)' is ambiguous\" \"\" { target float16 } }\n+#endif\n+  static_assert (baz (f32x) == 6);\n+  static_assert (baz (f64x) == 7);\n+  static_assert (baz (f128x) == 8);\n+  static_assert (baz (fx) == 6);\n+  static_assert (baz (dx) == 7);\n+  static_assert (baz (ldx) == 8);\n+#ifdef __STDCPP_FLOAT16_T__\n+  qux (float16_t (1.0));\t\t\t// { dg-error \"call of overloaded 'qux\\\\\\(std::float16_t\\\\\\)' is ambiguous\" \"\" { target float16 } }\n+#endif\n+  static_assert (qux (float (2.0)) == 10);\n+  static_assert (qux (double (3.0)) == 9);\n+  constexpr double y (t);\n+  static_assert (y == 3.0);\n+#ifdef __STDCPP_FLOAT16_T__\n+  fred (f16x);\t\t\t\t\t// { dg-error \"call of overloaded 'fred\\\\\\(const std::float16_t\\\\\\&\\\\\\)' is ambiguous\" \"\" { target float16 } }\n+#endif\n+  static_assert (fred (f32x) == 13);\n+  static_assert (fred (f64x) == 12);\n+  static_assert (fred (f128x) == 11);\n+  static_assert (fred (fx) == 13);\n+  static_assert (fred (dx) == 12);\n+  static_assert (fred (ldx) == 11);\n+#ifdef __STDCPP_FLOAT16_T__\n+  thud (f16x);\t\t\t\t\t// { dg-error \"call of overloaded 'thud\\\\\\(const std::float16_t\\\\\\&\\\\\\)' is ambiguous\" \"\" { target float16 } }\n+#endif\n+  static_assert (thud (f32x) == 16);\n+  static_assert (thud (f64x) == 15);\n+  static_assert (thud (f128x) == 14);\n+  static_assert (thud (fx) == 16);\n+  static_assert (thud (dx) == 15);\n+  static_assert (thud (ldx) == 14);\n+}"}, {"sha": "7c8bf6a946bd158a2ab6bcbfce57f83784b8e797", "filename": "gcc/testsuite/g++.dg/cpp23/ext-floating5.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating5.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,13 @@\n+// P1467R9 - Extended floating-point types and standard names.\n+// IBM extended long double and _Float128 should have unordered conversion\n+// ranks as IBM extended long double has variable precision from 53 bits\n+// for denormals to more than 2150 bits for certain numbers.\n+// { dg-do compile { target { c++23 && { powerpc*-*-linux* } } } }\n+// { dg-require-effective-target ppc_float128_sw }\n+// { dg-options \"-mvsx -mfloat128 -mlong-double-128 -mabi=ibmlongdouble\" }\n+\n+auto a = 1.0F128 + 1.0L;\t// { dg-error \"invalid operands to binary \\\\\\+ \\\\\\(have '_Float128' and 'long double'\\\\\\)\" }\n+auto b = 1.0L + 1.0F128;\t// { dg-error \"invalid operands to binary \\\\\\+ \\\\\\(have 'long double' and '_Float128'\\\\\\)\" }\n+bool c;\n+auto d = c ? 1.0F128 : 1.0L;\t// { dg-error \"operands to '\\\\\\?:' of types '_Float128' and 'long double' have unordered conversion rank\" }\n+auto e = c ? 1.0L : 1.0F128;\t// { dg-error \"operands to '\\\\\\?:' of types 'long double' and '_Float128' have unordered conversion rank\" }"}, {"sha": "70272a1b3c140fb4a03e5a4fd7cb91a051605943", "filename": "gcc/testsuite/g++.dg/cpp23/ext-floating6.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating6.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,30 @@\n+// P1467R9 - Extended floating-point types and standard names.\n+// { dg-do compile { target c++23 } }\n+// { dg-options \"\" }\n+\n+#include \"ext-floating.h\"\n+\n+#ifdef __STRICT_ANSI__\n+#undef __SIZEOF_FLOAT128__\n+#endif\n+\n+using namespace std;\n+\n+float foo (float x, float y, float z) { return x * y + z; }\n+double foo (double x, double y, double z) { return x * y + z; }\n+long double foo (long double x, long double y, long double z) { return x * y + z; }\n+#ifdef __STDCPP_FLOAT16_T__\n+float16_t foo (float16_t x, float16_t y, float16_t z) { return x * y + z; }\n+#endif\n+#ifdef __STDCPP_FLOAT32_T__\n+float32_t foo (float32_t x, float32_t y, float32_t z) { return x * y + z; }\n+#endif\n+#ifdef __STDCPP_FLOAT64_T__\n+float64_t foo (float64_t x, float64_t y, float64_t z) { return x * y + z; }\n+#endif\n+#ifdef __STDCPP_FLOAT128_T__\n+float128_t foo (float128_t x, float128_t y, float128_t z) { return x * y + z; }\n+#endif\n+#ifdef __STDCPP_BFLOAT16_T__\n+bfloat16_t foo (bfloat16_t x, bfloat16_t y, bfloat16_t z) { return x * y + z; }\n+#endif"}, {"sha": "5c30a5979b6b38d77672970af0dbe5b82d0f71a6", "filename": "gcc/testsuite/g++.dg/cpp23/ext-floating7.C", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating7.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,119 @@\n+// P1467R9 - Extended floating-point types and standard names.\n+// { dg-do run { target { c++23 && float16_runtime } } }\n+// { dg-options \"\" }\n+// { dg-add-options float16 }\n+\n+#ifndef WIDTH\n+#ifndef __STDCPP_FLOAT16_T__\n+#error Unexpected\n+#endif\n+#define WIDTH 16\n+#endif\n+\n+#include <stdarg.h>\n+#include \"ext-floating.h\"\n+\n+#define CONCATX(X, Y) X ## Y\n+#define CONCAT(X, Y) CONCATX (X, Y)\n+#define CONCAT3(X, Y, Z) CONCAT (CONCAT (X, Y), Z)\n+#define TYPE CONCAT (_Float, WIDTH)\n+#define CST(C) CONCAT3 (C, f, WIDTH)\n+#define CSTU(C) CONCAT3 (C, F, WIDTH)\n+\n+extern \"C\" void abort ();\n+\n+volatile TYPE a = CST (1.0), b = CSTU (2.5), c = -CST (2.5);\n+volatile TYPE a2 = CST (1.0), z = CST (0.0), nz = -CST (0.0);\n+\n+// These types are not subject to default argument promotions.\n+\n+TYPE\n+vafn (TYPE arg1, ...)\n+{\n+  va_list ap;\n+  TYPE ret;\n+  va_start (ap, arg1);\n+  ret = arg1 + va_arg (ap, TYPE);\n+  va_end (ap);\n+  return ret;\n+}\n+\n+TYPE\n+fn (TYPE arg)\n+{\n+  return arg / 4;\n+}\n+\n+int\n+main (void)\n+{\n+  volatile TYPE r;\n+  r = -b;\n+  if (r != c)\n+    abort ();\n+  r = a + b;\n+  if (r != CST (3.5))\n+    abort ();\n+  r = a - b;\n+  if (r != -CST (1.5))\n+    abort ();\n+  r = 2 * c;\n+  if (r != -5)\n+    abort ();\n+  r = b * c;\n+  if (r != -CST (6.25))\n+    abort ();\n+  r = b / (a + a);\n+  if (r != CST (1.25))\n+    abort ();\n+  r = c * 3;\n+  if (r != -CST (7.5))\n+    abort ();\n+  volatile int i = r;\n+  if (i != -7)\n+    abort ();\n+  r = vafn (a, c);\n+  if (r != -CST (1.5))\n+    abort ();\n+  r = fn (a);\n+  if (r != CST (0.25))\n+    abort ();\n+  if ((a < b) != 1)\n+    abort ();\n+  if ((b < a) != 0)\n+    abort ();\n+  if ((a < a2) != 0)\n+    abort ();\n+  if ((nz < z) != 0)\n+    abort ();\n+  if ((a <= b) != 1)\n+    abort ();\n+  if ((b <= a) != 0)\n+    abort ();\n+  if ((a <= a2) != 1)\n+    abort ();\n+  if ((nz <= z) != 1)\n+    abort ();\n+  if ((a > b) != 0)\n+    abort ();\n+  if ((b > a) != 1)\n+    abort ();\n+  if ((a > a2) != 0)\n+    abort ();\n+  if ((nz > z) != 0)\n+    abort ();\n+  if ((a >= b) != 0)\n+    abort ();\n+  if ((b >= a) != 1)\n+    abort ();\n+  if ((a >= a2) != 1)\n+    abort ();\n+  if ((nz >= z) != 1)\n+    abort ();\n+  i = (nz == z);\n+  if (i != 1)\n+    abort ();\n+  i = (a == b);\n+  if (i != 0)\n+    abort ();\n+}"}, {"sha": "afb74a3abad843a4f3f1248193e14b2f46cc0d78", "filename": "gcc/testsuite/g++.dg/cpp23/ext-floating8.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating8.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,13 @@\n+// P1467R9 - Extended floating-point types and standard names.\n+// { dg-do run { target { c++23 && float32_runtime } } }\n+// { dg-options \"\" }\n+// { dg-add-options float32 }\n+\n+#ifndef WIDTH\n+#ifndef __STDCPP_FLOAT32_T__\n+#error Unexpected\n+#endif\n+#define WIDTH 32\n+#endif\n+\n+#include \"ext-floating7.C\""}, {"sha": "f0118da30ccbcbfd0150670e0ff586fd9d51cab1", "filename": "gcc/testsuite/g++.dg/cpp23/ext-floating9.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fext-floating9.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,13 @@\n+// P1467R9 - Extended floating-point types and standard names.\n+// { dg-do run { target { c++23 && float64_runtime } } }\n+// { dg-options \"\" }\n+// { dg-add-options float64 }\n+\n+#ifndef WIDTH\n+#ifndef __STDCPP_FLOAT64_T__\n+#error Unexpected\n+#endif\n+#define WIDTH 64\n+#endif\n+\n+#include \"ext-floating7.C\""}, {"sha": "2f6b21ead7006ecb6ac848f4bf0abe41d5dd20d5", "filename": "gcc/testsuite/g++.dg/cpp23/feat-cxx2b.C", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Ffeat-cxx2b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Ffeat-cxx2b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Ffeat-cxx2b.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -504,8 +504,8 @@\n \n #ifndef __cpp_char8_t\n #  error \"__cpp_char8_t\"\n-#elif __cpp_char8_t != 201811\n-#  error \"__cpp_char8_t != 201811\"\n+#elif __cpp_char8_t != 202207\n+#  error \"__cpp_char8_t != 202207\"\n #endif\n \n #ifndef __cpp_designated_initializers\n@@ -563,3 +563,9 @@\n #elif __cpp_named_character_escapes != 202207\n #  error \"__cpp_named_character_escapes != 202207\"\n #endif\n+\n+#ifndef __cpp_static_call_operator\n+#  error \"__cpp_static_call_operator\"\n+#elif __cpp_static_call_operator != 202207\n+#  error \"__cpp_static_call_operator != 202207\"\n+#endif"}, {"sha": "42219bfd8628777f313dddd943ec75d0c66bbf6d", "filename": "gcc/testsuite/g++.dg/cpp23/static-operator-call1.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fstatic-operator-call1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fstatic-operator-call1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fstatic-operator-call1.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,41 @@\n+// P1169R4 - static operator()\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"\" }\n+\n+template <typename T>\n+struct S\n+{\n+  static constexpr bool operator () (T const &x, T const &y) { return x < y; }; // { dg-warning \"may be a static member function only with\" \"\" { target c++20_down } }\n+  using P = bool (*) (T const &, T const &);\n+  operator P () const { return operator (); }\n+};\n+\n+static_assert (S<int> {} (1, 2), \"\");\n+\n+template <typename T>\n+void\n+bar (T &x)\n+{\n+  x (1, 2);\n+}\n+\n+void\n+foo ()\n+{\n+#if __cpp_constexpr >= 201603L\n+  auto a = [](int x, int y) static constexpr { return x + y; };\t\t\t// { dg-warning \"'static' only valid in lambda with\" \"\" { target { c++17 && c++20_down } } }\n+  static_assert (a (1, 2) == 3, \"\");\n+  bar (*a);\n+#endif\n+  auto b = []() static { return 1; };\t\t\t\t\t\t// { dg-warning \"'static' only valid in lambda with\" \"\" { target c++20_down } }\n+  b ();\n+  auto c = [](int x, int y) static { return x + y; };\t\t\t\t// { dg-warning \"'static' only valid in lambda with\" \"\" { target c++20_down } }\n+  c (1, 2);\n+  bar (*c);\n+#if __cpp_generic_lambdas >= 201707L\n+  auto d = []<typename T, typename U>(T x, U y) static { return x + y; };\t// { dg-warning \"'static' only valid in lambda with\" \"\" { target c++20_only } }\n+  d (1, 2L);\n+#endif\n+  S<long> s;\n+  s(1L, 2L);\n+}"}, {"sha": "21f3d4484970027ee63527a586ed0faa74f4008e", "filename": "gcc/testsuite/g++.dg/cpp23/static-operator-call2.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fstatic-operator-call2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fstatic-operator-call2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fstatic-operator-call2.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,22 @@\n+// P1169R4 - static operator()\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"\" }\n+\n+void\n+foo ()\n+{\n+  int u = 0;\n+  auto a = [](int x, int y) mutable mutable { return x + y; };\t\t// { dg-error \"duplicate 'mutable' specifier\" }\n+  auto b = [](int x, int y) static static { return x + y; };\t\t// { dg-error \"duplicate 'static' specifier\" }\n+\t\t\t\t\t\t\t\t\t// { dg-warning \"'static' only valid in lambda with\" \"\" { target c++20_down } .-1 }\n+  auto c = [](int x, int y) static mutable { return x + y; };\t\t// { dg-error \"'mutable' specifier conflicts with 'static'\" }\n+\t\t\t\t\t\t\t\t\t// { dg-warning \"'static' only valid in lambda with\" \"\" { target c++20_down } .-1 }\n+  auto d = [](int x, int y) mutable static { return x + y; };\t\t// { dg-error \"'static' specifier conflicts with 'mutable'\" }\n+\t\t\t\t\t\t\t\t\t// { dg-warning \"'static' only valid in lambda with\" \"\" { target c++20_down } .-1 }\n+  auto e = [=](int x, int y) static { return x + y; };\t\t\t// { dg-error \"lambda specifier with lambda capture\" }\n+\t\t\t\t\t\t\t\t\t// { dg-warning \"'static' only valid in lambda with\" \"\" { target c++20_down } .-1 }\n+  auto f = [&](int x, int y) static { return x + y; };\t\t\t// { dg-error \"lambda specifier with lambda capture\" }\n+\t\t\t\t\t\t\t\t\t// { dg-warning \"'static' only valid in lambda with\" \"\" { target c++20_down } .-1 }\n+  auto g = [u](int x, int y) static { return x + y; };\t\t\t// { dg-error \"lambda specifier with lambda capture\" }\n+\t\t\t\t\t\t\t\t\t// { dg-warning \"'static' only valid in lambda with\" \"\" { target c++20_down } .-1 }\n+}"}, {"sha": "9c84db621563915cabbd1104e0aac8680203e435", "filename": "gcc/testsuite/g++.dg/cpp23/static-operator-call3.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fstatic-operator-call3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fstatic-operator-call3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fstatic-operator-call3.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,10 @@\n+// P1169R4 - static operator()\n+// { dg-do compile { target c++14 } }\n+// { dg-options \"\" }\n+\n+void\n+foo ()\n+{\n+  auto a = [] (auto x) static { return x; };\t\t\t\t\t// { dg-warning \"'static' only valid in lambda with\" \"\" { target c++20_down } }\n+  int (*b) (int) = a;\n+}"}, {"sha": "071a718c4d04343b4b4bba940853758e11a6f11f", "filename": "gcc/testsuite/g++.dg/cpp2a/char8_t3.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fchar8_t3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fchar8_t3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fchar8_t3.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,37 @@\n+// PR c++/106656 - P2513 - char8_t Compatibility and Portability Fixes\n+// { dg-do compile { target c++20 } }\n+\n+const char *p1 = u8\"\"; // { dg-error \"invalid conversion\" }\n+const unsigned char *p2 = u8\"\"; // { dg-error \"invalid conversion\" }\n+const signed char *p3 = u8\"\"; // { dg-error \"invalid conversion\" }\n+const char *p4 = { u8\"\" }; // { dg-error \"invalid conversion\" }\n+const unsigned char *p5 = { u8\"\" }; // { dg-error \"invalid conversion\" }\n+const signed char *p6 = { u8\"\" }; // { dg-error \"invalid conversion\" }\n+const char *p7 = static_cast<const char *>(u8\"\"); // { dg-error \"invalid\" }\n+const char a1[] = u8\"text\";\n+const unsigned char a2[] = u8\"\";\n+const signed char a3[] = u8\"\"; // { dg-error \"cannot initialize array\" }\n+const char a4[] = { u8\"text\" };\n+const unsigned char a5[] = { u8\"\" };\n+const signed char a6[] = { u8\"\" }; // { dg-error \"cannot initialize array\" }\n+\n+const char *\n+resource_id ()\n+{\n+  static const char res_id[] = u8\"\";\n+  return res_id;\n+}\n+\n+const char8_t x[] = \"fail\"; // { dg-error \"cannot initialize array\" }\n+\n+void fn (const char a[]);\n+void\n+g ()\n+{\n+  fn (u8\"z\"); // { dg-error \"invalid conversion\" }\n+}\n+\n+char c = u8'c';\n+unsigned char uc = u8'c';\n+signed char sc = u8'c';\n+char8_t c8 = 'c';"}, {"sha": "c18081b66fb7756f2a7dd406dc293769fccf4711", "filename": "gcc/testsuite/g++.dg/cpp2a/char8_t4.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fchar8_t4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fchar8_t4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fchar8_t4.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,17 @@\n+// PR c++/106656 - P2513 - char8_t Compatibility and Portability Fixes\n+// { dg-do compile { target c++20 } }\n+// [diff.cpp20.dcl]\n+\n+struct A {\n+\tchar8_t s[10];\n+};\n+struct B {\n+\tchar s[10];\n+};\n+\n+void f(A);\n+void f(B);\n+\n+int main() {\n+\tf({u8\"\"}); // { dg-error \"ambiguous\" }\n+}"}, {"sha": "ffa6184782438ef46644a012cc8d14a02b6b47a8", "filename": "gcc/testsuite/g++.dg/cpp2a/constinit3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstinit3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstinit3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstinit3.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -5,7 +5,7 @@ constinit constinit int v1; // { dg-error \"duplicate .constinit.\" }\n constexpr constinit int v2 = 1; // { dg-error \"can use at most one of the .constinit. and .constexpr. specifiers\" }\n constinit constexpr int v3 = 1; // { dg-error \"an use at most one of the .constinit. and .constexpr. specifiers\" }\n \n-extern static constinit int v4; // { dg-error \"conflicting specifiers\" }\n+extern static constinit int v4; // { dg-error \"'static' specifier conflicts with 'extern'\" }\n extern thread_local constinit int v5;\n extern constinit int v6;\n "}, {"sha": "02f3a377fd024e899e20a67dcd6ae7c82d9190ec", "filename": "gcc/testsuite/g++.dg/cpp2a/feat-cxx2a.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffeat-cxx2a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffeat-cxx2a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffeat-cxx2a.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -504,8 +504,8 @@\n \n #ifndef __cpp_char8_t\n #  error \"__cpp_char8_t\"\n-#elif __cpp_char8_t != 201811\n-#  error \"__cpp_char8_t != 201811\"\n+#elif __cpp_char8_t != 202207\n+#  error \"__cpp_char8_t != 202207\"\n #endif\n \n #ifndef __cpp_designated_initializers"}, {"sha": "89e2ebdebf6b427409d96b1602566f8b987a013e", "filename": "gcc/testsuite/g++.dg/diagnostic/conflicting-specifiers-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fconflicting-specifiers-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fconflicting-specifiers-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fconflicting-specifiers-1.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1 +1 @@\n-static typedef int i __attribute__((unused));  // { dg-error \"1:conflicting specifiers\" }\n+static typedef int i __attribute__((unused));  // { dg-error \"8:'typedef' specifier conflicts with 'static'\" }"}, {"sha": "2d0f9045acfcc0145fbf2be01b90882240027ec3", "filename": "gcc/testsuite/g++.dg/ext/char8_t-feature-test-macro-2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fchar8_t-feature-test-macro-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fchar8_t-feature-test-macro-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fchar8_t-feature-test-macro-2.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -5,6 +5,6 @@\n \n #if !defined(__cpp_char8_t)\n #  error __cpp_char8_t is not defined!\n-#elif __cpp_char8_t != 201811\n-#  error __cpp_char8_t != 201811\n+#elif __cpp_char8_t != 202207\n+#  error __cpp_char8_t != 202207\n #endif"}, {"sha": "02a96ffe5a492448d70bb24c9757f038da2ecf65", "filename": "gcc/testsuite/g++.dg/ext/char8_t-init-2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fchar8_t-init-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fchar8_t-init-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fchar8_t-init-2.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -21,7 +21,7 @@ const char8_t (&rca4)[2] = u8\"x\";\n const char8_t (&rca5)[2] = u\"x\"; // { dg-error \"invalid initialization of reference of type .const char8_t ....... from expression of type .const char16_t ....\" \"char8_t\" }\n \n char ca1[] = \"x\";\n-char ca2[] = u8\"x\"; // { dg-error \"from a string literal with type array of .char8_t.\" \"char8_t\" }\n+char ca2[] = u8\"x\";\n char8_t ca3[] = \"x\"; // { dg-error \"from a string literal with type array of .char.\" \"char8_t\" }\n char8_t ca4[] = u8\"x\";\n char8_t ca5[] = u\"x\"; // { dg-error \"from a string literal with type array of .char16_t.\" \"char8_t\" }\n@@ -30,4 +30,4 @@ signed char sca1[] = \"x\";\n signed char sca2[] = u8\"x\"; // { dg-error \"from a string literal with type array of .char8_t.\" \"char8_t\" }\n \n unsigned char uca1[] = \"x\";\n-unsigned char uca2[] = u8\"x\"; // { dg-error \"from a string literal with type array of .char8_t.\" \"char8_t\" }\n+unsigned char uca2[] = u8\"x\";"}, {"sha": "7a986d075c22fdffcb905ed46af2cabf66446479", "filename": "gcc/testsuite/g++.dg/ext/is_convertible3.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_convertible3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_convertible3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_convertible3.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,9 @@\n+// PR c++/106784\n+// { dg-do compile { target c++11 } }\n+// Make sure we don't reject this at runtime by trying to instantiate\n+// something that would be ill-formed.\n+\n+struct A;\n+struct B { template<class T> B(const T&) noexcept { T::nonexistent; } };\n+\n+static_assert(__is_convertible(const A&, B), \"\");"}, {"sha": "05b1e1d9ad9306a1c955a0e046da7d18fc0f0362", "filename": "gcc/testsuite/g++.dg/ext/is_nothrow_convertible3.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_nothrow_convertible3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_nothrow_convertible3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_nothrow_convertible3.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,9 @@\n+// PR c++/106784\n+// { dg-do compile { target c++11 } }\n+// Make sure we don't reject this at runtime by trying to instantiate\n+// something that would be ill-formed.\n+\n+struct A;\n+struct B { template<class T> B(const T&) noexcept { T::nonexistent; } };\n+\n+static_assert(__is_nothrow_convertible(const A&, B), \"\");"}, {"sha": "dd33b07361483e8f0bd702df125c61e3a3d1c1d1", "filename": "gcc/testsuite/g++.dg/gomp/attrs-1.C", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-1.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -123,7 +123,7 @@ baz (int d, int m, int i1, int i2, int p, int *idp, int s,\n void\n bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int hda, int s,\n      int nte, int tl, int nth, int g, int nta, int fi, int pp, int *q, int *dd, int ntm,\n-     const char *msg)\n+     const char *msg, int n1, int n2)\n {\n   [[omp::directive (nothing)]];\n   [[omp::directive (error at (execution) severity (warning) message (msg))]];\n@@ -612,6 +612,19 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int hda, int s,\n     ;\n   [[omp::directive (parallel)]]\n   switch (0) { case 1: break; default: break; }\n+  [[omp::directive (assume no_openmp no_openmp_routines no_parallelism\n+\t\t\t   absent (atomic, barrier, cancel, cancellation point)\n+\t\t\t   absent (critical, depobj)\n+\t\t\t   absent (distribute, flush, loop, masked, master, nothing, ordered)\n+\t\t\t   absent (parallel, scan, scope, section, sections, simd, single, task)\n+\t\t\t   absent (taskgroup, taskloop, taskwait, taskyield)\n+\t\t\t   absent (target, teams, for, error) holds (n1 < n2))]]\n+  if (0)\n+    ;\n+  [[omp::sequence (omp::directive (assume contains (simd)),\n+\t\t   omp::directive (for simd))]]\n+  for (int i = 0; i < 64; i++)\n+    ;\n }\n \n void corge1 ();"}, {"sha": "d0598f47dff3d1604dde296e29f6861ae07432d7", "filename": "gcc/testsuite/g++.dg/gomp/attrs-15.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-15.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,41 @@\n+// { dg-do compile { target c++11 } }\n+\n+#pragma omp begin assumes absent (target)\n+#pragma omp begin assumes absent (target)\n+[[omp::directive (begin assumes absent (target))]];\n+int a;\n+[[omp::directive (end assumes)]];\n+#pragma omp end assumes\n+#pragma omp end assumes\n+[[omp::directive (begin assumes absent (target))]];\n+int b;\n+#pragma omp end assumes\t\t// { dg-error \"'begin assumes' in attribute syntax terminated with 'end assumes' in pragma syntax\" }\n+#pragma omp begin assumes absent (target)\n+int c;\n+[[omp::directive (end assumes)]];// { dg-error \"'begin assumes' in pragma syntax terminated with 'end assumes' in attribute syntax\" }\n+#pragma omp begin assumes absent (target)\n+[[omp::directive (begin assumes absent (target))]];\n+int d;\n+#pragma omp end assumes\t\t// { dg-error \"'begin assumes' in attribute syntax terminated with 'end assumes' in pragma syntax\" }\n+#pragma omp begin assumes absent (target)\n+int e;\n+[[omp::directive (end assumes)]];// { dg-error \"'begin assumes' in pragma syntax terminated with 'end assumes' in attribute syntax\" }\n+#pragma omp end assumes\n+[[omp::directive (begin assumes absent (target))]];\n+[[omp::directive (begin assumes absent (target))]];\n+int f;\n+#pragma omp end assumes\t\t// { dg-error \"'begin assumes' in attribute syntax terminated with 'end assumes' in pragma syntax\" }\n+#pragma omp begin assumes absent (target)\n+int g;\n+[[omp::directive (end assumes)]];// { dg-error \"'begin assumes' in pragma syntax terminated with 'end assumes' in attribute syntax\" }\n+[[omp::directive (end assumes)]];\n+[[omp::directive (begin assumes absent (target))]];\n+#pragma omp begin assumes absent (target)\n+int h;\n+#pragma omp end assumes\n+#pragma omp end assumes\t\t// { dg-error \"'begin assumes' in attribute syntax terminated with 'end assumes' in pragma syntax\" }\n+#pragma omp begin assumes absent (target)\n+[[omp::directive (begin assumes absent (target))]];\n+int i;\n+[[omp::directive (end assumes)]];\n+[[omp::directive (end assumes)]];// { dg-error \"'begin assumes' in pragma syntax terminated with 'end assumes' in attribute syntax\" }"}, {"sha": "5c1dcc587c56f4ac64df858b34cf4f94f199c2f8", "filename": "gcc/testsuite/g++.dg/gomp/attrs-16.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-16.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,26 @@\n+// { dg-do compile { target c++11 } }\n+\n+int i;\n+\n+[[omp::directive (assumes no_openmp, absent (target, teams) holds (i < 32U) holds (i < 32U))]];\n+void\n+bar (void)\n+{\n+}\n+\n+[[omp::directive (assumes no_openmp_routines)]];\n+[[omp::directive (assumes no_parallelism)]];\n+[[omp::directive (assumes absent (for))]];\n+void\n+fred (void)\n+{\n+}\n+\n+[[omp::directive (assumes absent (atomic, barrier, cancel, cancellation point) absent (critical, depobj)\n+\t\t    absent (distribute, flush, loop, masked, master, nothing, ordered)\n+\t\t    absent (parallel, scan, scope, section, sections, simd, single, task)\n+\t\t    absent (taskgroup, taskloop, taskwait, taskyield))]];\n+void\n+foo (void)\n+{\n+}"}, {"sha": "fe36146792431e38cb0feeb9818fd6c971047b74", "filename": "gcc/testsuite/g++.dg/gomp/attrs-17.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-17.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile { target c++11 } }\n+\n+[[omp::directive (assumes contains (simd))]];\n+[[omp::directive (assumes contains (error))]];\n+[[omp::directive (assumes, contains (simd))]];\n+\n+void\n+foo (int i, int *a)\n+{\n+  [[omp::directive (simd)]]\n+  for (int j = 0; j < i; j++)\n+    a[j] = j;\n+  if (i >= 32)\n+    {\n+      [[omp::directive (error at (execution) message (\"Should not happen\"))]];\n+    }\n+}"}, {"sha": "7258d38c5a35a2244031d87f70ec351f80d27d9d", "filename": "gcc/testsuite/g++.dg/gomp/attrs-2.C", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-2.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -123,7 +123,7 @@ baz (int d, int m, int i1, int i2, int p, int *idp, int s,\n void\n bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int hda, int s,\n      int nte, int tl, int nth, int g, int nta, int fi, int pp, int *q, int *dd, int ntm,\n-     const char *msg)\n+     const char *msg, int n1, int n2)\n {\n   [[omp::directive (nothing)]];\n   [[omp::directive (error, at (execution), severity (warning), message (msg))]];\n@@ -604,6 +604,19 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int hda, int s,\n   extern int t2;\n   [[omp::directive (declare reduction (dr: int: omp_out += omp_in),initializer (omp_priv = 0))]]\n   ;\n+  [[omp::directive (assume, no_openmp, no_openmp_routines, no_parallelism,\n+\t\t\t    absent (atomic, barrier, cancel, cancellation point),\n+\t\t\t    absent (critical, depobj),\n+\t\t\t    absent (distribute, flush, loop, masked, master, nothing, ordered),\n+\t\t\t    absent (parallel, scan, scope, section, sections, simd, single, task),\n+\t\t\t    absent (taskgroup, taskloop, taskwait, taskyield),\n+\t\t\t    absent (target, teams, for, error), holds (n1 < n2))]]\n+  if (0)\n+    ;\n+  [[omp::sequence (omp::directive (assume, contains (simd)),\n+\t\t   omp::directive (for simd))]]\n+  for (int i = 0; i < 64; i++)\n+    ;\n }\n \n void corge1 ();"}, {"sha": "fa02299bcafd902bc7927a8b4eff1b0bf47ad8fc", "filename": "gcc/testsuite/g++.dg/gomp/attrs-9.C", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-9.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,5 +1,6 @@\n // { dg-do compile { target c++11 } }\n \n+int n1 = 0, n2 = 42;\n [[omp::sequence (directive (requires, atomic_default_mem_order (seq_cst)))]];\n [[omp::directive (declare reduction (plus: int: omp_out += omp_in) initializer (omp_priv = 0))]];\n int a;\n@@ -14,3 +15,22 @@ int d;\n [[omp::directive (end declare target)]];\n [[omp::directive (end declare target)]];\n [[omp::directive (nothing)]];\n+[[omp::directive (begin assumes no_openmp no_openmp_routines no_parallelism\n+\t\t\t\tabsent (atomic, barrier, cancel, cancellation point)\n+\t\t\t\tabsent (critical, depobj)\n+\t\t\t\tabsent (distribute, flush, loop, masked, master, nothing, ordered)\n+\t\t\t\tabsent (parallel, scan, scope, section, sections, simd, single, task)\n+\t\t\t\tabsent (taskgroup, taskloop, taskwait, taskyield)\n+\t\t\t\tabsent (target, teams, for, error) holds (n1 < n2))]];\n+void foo (void) {}\n+[[omp::directive (end assumes)]];\n+[[omp::directive (begin assumes, no_openmp, no_openmp_routines, no_parallelism,\n+\t\t\t\t absent (atomic, barrier, cancel, cancellation point),\n+\t\t\t\t absent (critical, depobj),\n+\t\t\t\t absent (distribute, flush, loop, masked, master, nothing, ordered),\n+\t\t\t\t absent (parallel, scan, scope, section, sections, simd, single, task),\n+\t\t\t\t absent (taskgroup, taskloop, taskwait, taskyield),\n+\t\t\t\t absent (target, teams, for, error), holds (n1 < n2))]];\n+[[omp::directive (begin assumes no_openmp)]];\n+void bar (void) {}\n+[[omp::sequence (omp::directive (end assumes), omp::directive (end assumes))]];"}, {"sha": "1316bf5e1c5b8b4d0aba43005949d3b6bb5d196b", "filename": "gcc/testsuite/g++.dg/modules/partial-2.cc", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpartial-2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpartial-2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpartial-2.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,17 @@\n+static_assert(is_reference_v<int&>);\n+static_assert(is_reference_v<int&&>);\n+static_assert(!is_reference_v<int>);\n+\n+static_assert(A::is_reference_v<long&>);\n+static_assert(A::is_reference_v<long&&>);\n+static_assert(!A::is_reference_v<long>);\n+\n+#if __cpp_concepts\n+static_assert(concepts::is_reference_v<char&>);\n+static_assert(concepts::is_reference_v<char&&>);\n+static_assert(!concepts::is_reference_v<char>);\n+\n+static_assert(concepts::A::is_reference_v<bool&>);\n+static_assert(concepts::A::is_reference_v<bool&&>);\n+static_assert(!concepts::A::is_reference_v<bool>);\n+#endif"}, {"sha": "afcfce791b3699f05f202d06175f5587f94e7711", "filename": "gcc/testsuite/g++.dg/modules/partial-2.h", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpartial-2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpartial-2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpartial-2.h?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,38 @@\n+template<class T> constexpr bool is_reference_v = false;\n+template<class T> constexpr bool is_reference_v<T&> = true;\n+template<class T> constexpr bool is_reference_v<T&&> = true;\n+\n+struct A {\n+  template<class T> static constexpr bool is_reference_v = false;\n+};\n+\n+template<class T> constexpr bool A::is_reference_v<T&> = true;\n+template<class T> constexpr bool A::is_reference_v<T&&> = true;\n+\n+#if __cpp_concepts\n+namespace concepts {\n+  template<class T> bool is_reference_v;\n+\n+  template<class T> requires __is_same(T, T&)\n+  constexpr bool is_reference_v<T> = true;\n+\n+  template<class T> requires __is_same(T, T&&) && (!__is_same(T, T&))\n+  constexpr bool is_reference_v<T> = true;\n+\n+  template<class T> requires (!__is_same(T, T&)) && (!__is_same(T, T&&))\n+  constexpr bool is_reference_v<T> = false;\n+\n+  struct A {\n+    template<class T> static bool is_reference_v;\n+  };\n+\n+  template<class T> requires __is_same(T, T&)\n+  constexpr bool A::is_reference_v<T> = true;\n+\n+  template<class T> requires __is_same(T, T&&) && (!__is_same(T, T&))\n+  constexpr bool A::is_reference_v<T> = true;\n+\n+  template<class T> requires (!__is_same(T, T&)) && (!__is_same(T, T&&))\n+  constexpr bool A::is_reference_v<T> = false;\n+}\n+#endif"}, {"sha": "1582f56f2d466e592aef0ba9f179f438939e54bb", "filename": "gcc/testsuite/g++.dg/modules/partial-2_a.C", "status": "modified", "additions": 1, "deletions": 38, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpartial-2_a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpartial-2_a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpartial-2_a.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -3,41 +3,4 @@\n // { dg-module-cmi pr106826 }\n export module pr106826;\n \n-template<class T> constexpr bool is_reference_v = false;\n-template<class T> constexpr bool is_reference_v<T&> = true;\n-template<class T> constexpr bool is_reference_v<T&&> = true;\n-\n-struct A {\n-  template<class T> static constexpr bool is_reference_v = false;\n-};\n-\n-template<class T> constexpr bool A::is_reference_v<T&> = true;\n-template<class T> constexpr bool A::is_reference_v<T&&> = true;\n-\n-#if __cpp_concepts\n-namespace concepts {\n-  template<class T> bool is_reference_v;\n-\n-  template<class T> requires __is_same(T, T&)\n-  constexpr bool is_reference_v<T> = true;\n-\n-  template<class T> requires __is_same(T, T&&) && (!__is_same(T, T&))\n-  constexpr bool is_reference_v<T> = true;\n-\n-  template<class T> requires (!__is_same(T, T&)) && (!__is_same(T, T&&))\n-  constexpr bool is_reference_v<T> = false;\n-\n-  struct A {\n-    template<class T> static bool is_reference_v;\n-  };\n-\n-  template<class T> requires __is_same(T, T&)\n-  constexpr bool A::is_reference_v<T> = true;\n-\n-  template<class T> requires __is_same(T, T&&) && (!__is_same(T, T&))\n-  constexpr bool A::is_reference_v<T> = true;\n-\n-  template<class T> requires (!__is_same(T, T&)) && (!__is_same(T, T&&))\n-  constexpr bool A::is_reference_v<T> = false;\n-}\n-#endif\n+#include \"partial-2.h\""}, {"sha": "1b0c7a53e9f3becb13cb59a51c7891e982466350", "filename": "gcc/testsuite/g++.dg/modules/partial-2_b.C", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpartial-2_b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpartial-2_b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpartial-2_b.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -2,20 +2,4 @@\n // { dg-additional-options -fmodules-ts }\n module pr106826;\n \n-static_assert(is_reference_v<int&>);\n-static_assert(is_reference_v<int&&>);\n-static_assert(!is_reference_v<int>);\n-\n-static_assert(A::is_reference_v<long&>);\n-static_assert(A::is_reference_v<long&&>);\n-static_assert(!A::is_reference_v<long>);\n-\n-#if __cpp_concepts\n-static_assert(concepts::is_reference_v<char&>);\n-static_assert(concepts::is_reference_v<char&&>);\n-static_assert(!concepts::is_reference_v<char>);\n-\n-static_assert(concepts::A::is_reference_v<bool&>);\n-static_assert(concepts::A::is_reference_v<bool&&>);\n-static_assert(!concepts::A::is_reference_v<bool>);\n-#endif\n+#include \"partial-2.cc\""}, {"sha": "bd838529ce017681cdd25c7f5fe8d774699a6ced", "filename": "gcc/testsuite/g++.dg/modules/partial-2_c.H", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpartial-2_c.H", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpartial-2_c.H", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpartial-2_c.H?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,5 @@\n+// PR c++/107033\n+// { dg-additional-options -fmodule-header }\n+// { dg-module-cmi {} }\n+\n+#include \"partial-2.h\""}, {"sha": "ed54d3c2884d526e0d85dd2a2ec401b0051ce2ba", "filename": "gcc/testsuite/g++.dg/modules/partial-2_d.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpartial-2_d.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpartial-2_d.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpartial-2_d.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,8 @@\n+// PR c++/107033\n+// { dg-additional-options -fmodules-ts }\n+// { dg-module-cmi pr107033 }\n+export module pr107033;\n+\n+import \"partial-2_c.H\";\n+\n+#include \"partial-2.cc\""}, {"sha": "e582b03ee60dc3542b8e02d3b76e98e082565c7d", "filename": "gcc/testsuite/g++.dg/other/mult-stor1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fmult-stor1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fmult-stor1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fmult-stor1.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -4,5 +4,5 @@\n \n struct A\n {\n-  extern static int i;  // { dg-error \"conflicting specifiers\" }\n+  extern static int i;  // { dg-error \"'static' specifier conflicts with 'extern'\" }\n };"}, {"sha": "5d4e02d79ca0e457eb0249fe4121c496ba52bf11", "filename": "gcc/testsuite/g++.dg/parse/crash39.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash39.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash39.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash39.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,3 +1,3 @@\n // PR c++/31747\n \n-static extern int i; // { dg-error \"conflicting specifiers\" }\n+static extern int i; // { dg-error \"'extern' specifier conflicts with 'static'\" }"}, {"sha": "e21bdb911d9a0b4258064e5e933534502de0e49c", "filename": "gcc/testsuite/g++.dg/parse/typedef8.C", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftypedef8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftypedef8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftypedef8.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,11 +1,11 @@\n //PR c++ 29024\n \n-typedef static int a;   // { dg-error \"conflicting\" }\n-typedef register int b; // { dg-error \"conflicting\" }\n-typedef extern int c;   // { dg-error \"conflicting\" }\n-static typedef int a;   // { dg-error \"conflicting\" }\n+typedef static int a;   // { dg-error \"'static' specifier conflicts with 'typedef'\" }\n+typedef register int b; // { dg-error \"'register' specifier conflicts with 'typedef'\" }\n+typedef extern int c;   // { dg-error \"'extern' specifier conflicts with 'typedef'\" }\n+static typedef int a;   // { dg-error \"'typedef' specifier conflicts with 'static'\" }\n \n void foo()\n {\n-  typedef auto int bar; // { dg-error \"conflicting|two or more data types\" }\n+  typedef auto int bar; // { dg-error \"'auto' specifier conflicts with 'typedef'|two or more data types\" }\n }"}, {"sha": "5a3047c11c4f211d63136d3299c9f2b204b58365", "filename": "gcc/testsuite/g++.dg/template/error30.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ferror30.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ferror30.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ferror30.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -2,4 +2,4 @@\n \n template<int> struct A;\n \n-template<template<typename> class B> A<B<int>::x> operator() (); // { dg-error \"51:.A<B<int>::x> operator\\\\(\\\\)\\\\(\\\\). must be a non-static member function\" }\n+template<template<typename> class B> A<B<int>::x> operator() (); // { dg-error \"51:.A<B<int>::x> operator\\\\(\\\\)\\\\(\\\\). must be a member function\" }"}, {"sha": "93c7f28fb4cd64504884cf3954512144d7dfb5c2", "filename": "gcc/testsuite/g++.dg/torture/pr107029.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr107029.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr107029.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr107029.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,19 @@\n+// PR tree-optimization/107029\n+// { dg-do compile }\n+\n+struct S { long long a; int b; };\n+long long S::*a;\n+int S::*b;\n+struct A { void foo (bool, bool); void bar (); int c; };\n+\n+void\n+A::foo (bool a, bool b)\n+{\n+  c = a || b;\n+}\n+\n+void\n+A::bar()\n+{\n+  foo (a, b);\n+}"}, {"sha": "c18790190b52b3c291e2bc2f32953c8de563fa9b", "filename": "gcc/testsuite/g++.old-deja/g++.jason/operator.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Foperator.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Foperator.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Foperator.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -6,7 +6,7 @@ typedef __SIZE_TYPE__ size_t;\n \n struct A {\n   int operator?:(int a, int b);\t   // { dg-error \"prohibits overloading\" } \n-  static int operator()(int a);\t   // { dg-error \"14:.static int A::operator\\\\(\\\\)\\\\(int\\\\). must be a non-static member function\" }\n+  static int operator()(int a);\t   // { dg-warning \"14:.static int A::operator\\\\(\\\\)\\\\(int\\\\). may be a static member function only with\" \"\" { target c++20_down } }\n   static int operator+(A,A);\t   // { dg-error \"14:.static int A::operator\\\\+\\\\(A, A\\\\). must be either a non-static member function or a non-member function\" } \n   int operator+(int a, int b = 1); // { dg-error \"7:.int A::operator\\\\+\\\\(int, int\\\\). must have either zero or one argument\" }\n   int operator++(char);\t\t   // { dg-error \"7:postfix .int A::operator\\\\+\\\\+\\\\(char\\\\). must have .int. as its argument\" }"}, {"sha": "f96b932b69842388ef3fd8e47d74340e0707da9f", "filename": "gcc/testsuite/g++.target/i386/float16-1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Ffloat16-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Ffloat16-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Ffloat16-1.C?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,8 +1,8 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2 -mno-sse2\" } */\n \n-_Float16/* { dg-error \"does not name a type\" } */\n+_Float16\t/* { dg-error \"expected unqualified-id before '_Float16'\" } */\n foo (_Float16 x) \n {\n   return x;\n-}\n+}\t\t/* { dg-error \"'_Float16' is not supported on this target\" } */"}, {"sha": "1406ad9d33b1aa196506798151aee5c245819eff", "filename": "gcc/testsuite/gcc.dg/tree-ssa/popcount6.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpopcount6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpopcount6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpopcount6.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,12 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -fdump-tree-evrp\" }\n+\n+int g(int n)\n+{\n+  n &= 0x8000;\n+  if (n == 0)\n+    return 1;\n+  return __builtin_popcount(n);\n+}\n+\n+// { dg-final { scan-tree-dump \"return 1;\" \"evrp\" } }"}, {"sha": "5010aed1723dc32d57075f91c87602018fb00c91", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr107009.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr107009.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr107009.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr107009.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -fdump-tree-dom2-alias\" }\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+void saxpy(size_t n)\n+{\n+  if (n == 0 || n % 8 != 0)\n+    __builtin_unreachable();\n+\n+  extern void foobar (size_t n);\n+  foobar (n);\n+}\n+\n+// { dg-final { scan-tree-dump \"NONZERO.*fff8\" \"dom2\" } }"}, {"sha": "67635fb9e6687802623132014aec8bf6242f8068", "filename": "gcc/testsuite/gcc.target/i386/avx256-unaligned-store-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx256-unaligned-store-3.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O3 -dp -mavx -mavx256-split-unaligned-store -mtune=generic -fno-common\" } */\n+/* { dg-options \"-O3 -dp -mavx -mavx256-split-unaligned-store -mtune=generic -fno-common -mno-avx512f\" } */\n \n #define N 1024\n "}, {"sha": "6d230da632cc10bfdbab7216de3326b0fc0f9c9c", "filename": "gcc/testsuite/gcc.target/i386/pr53346-1.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr53346-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr53346-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr53346-1.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-msse2 -O2 -mno-sse3\" } */\n+/* { dg-final { scan-assembler-times \"shufps\" 15 } } */\n+/* { dg-final { scan-assembler-times \"pshufd\" 2 } } */\n+\n+typedef int v4si __attribute__((vector_size(16)));\n+\n+v4si\n+__attribute__((noipa))\n+foo (v4si a, v4si b)\n+{\n+  return __builtin_shufflevector (a, b, 1, 2, 5, 3);\n+}\n+\n+v4si\n+__attribute__((noipa))\n+foo1 (v4si a, v4si b)\n+{\n+  return __builtin_shufflevector (a, b, 1, 5, 2, 3);\n+}\n+\n+v4si\n+__attribute__((noipa))\n+foo2 (v4si a, v4si b)\n+{\n+  return __builtin_shufflevector (a, b, 1, 2, 3, 5);\n+}\n+\n+v4si\n+__attribute__((noipa))\n+foo3 (v4si a, v4si b)\n+{\n+  return __builtin_shufflevector (a, b, 1, 4, 5, 6);\n+}\n+\n+v4si\n+__attribute__((noipa))\n+foo4 (v4si a, v4si b)\n+{\n+  return __builtin_shufflevector (a, b, 3, 6, 7, 5);\n+}\n+\n+v4si\n+__attribute__((noipa))\n+foo5 (v4si a, v4si b)\n+{\n+  return __builtin_shufflevector (a, b, 2, 4, 7, 6);\n+}\n+\n+v4si\n+__attribute__((noipa))\n+foo6 (v4si a, v4si b)\n+{\n+  return __builtin_shufflevector (a, b, 2, 4, 3, 6);\n+}\n+\n+v4si\n+__attribute__((noipa))\n+foo7 (v4si a, v4si b)\n+{\n+  return __builtin_shufflevector (a, b, 2, 3, 4, 6);\n+}\n+\n+v4si\n+__attribute__((noipa))\n+foo8 (v4si a, v4si b)\n+{\n+  return __builtin_shufflevector (a, b, 2, 4, 6, 3);\n+}\n+"}, {"sha": "0c6c7b35e014debe535f111a6b52a762678c44ec", "filename": "gcc/testsuite/gcc.target/i386/pr53346-2.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr53346-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr53346-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr53346-2.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -msse2\" } */\n+/* { dg-require-effective-target sse2 } */\n+\n+#include \"sse2-check.h\"\n+#include \"pr53346-1.c\"\n+\n+static void\n+sse2_test ()\n+{\n+  v4si a = __extension__(v4si) { 0, 1, 2, 3 };\n+  v4si b = __extension__(v4si) { 4, 5, 6, 7 };\n+  v4si exp = __extension__(v4si) { 1, 2, 5, 3 };\n+  v4si dest;\n+  dest = foo (a, b);\n+  if (__builtin_memcmp (&dest, &exp, 16))\n+    __builtin_abort ();\n+\n+  exp = __extension__ (v4si) { 1, 5, 2, 3 };\n+  dest = foo1 (a, b);\n+  if (__builtin_memcmp (&dest, &exp, 16))\n+    __builtin_abort ();\n+\n+  exp = __extension__ (v4si) { 1, 2, 3, 5 };\n+  dest = foo2 (a, b);\n+  if (__builtin_memcmp (&dest, &exp, 16))\n+    __builtin_abort ();\n+\n+  exp = __extension__ (v4si) { 1, 4, 5, 6 };\n+  dest = foo3 (a, b);\n+  if (__builtin_memcmp (&dest, &exp, 16))\n+    __builtin_abort ();\n+\n+  exp = __extension__ (v4si) { 3, 6, 7, 5 };\n+  dest = foo4 (a, b);\n+  if (__builtin_memcmp (&dest, &exp, 16))\n+    __builtin_abort ();\n+\n+  exp = __extension__ (v4si) { 2, 4, 7, 6 };\n+  dest = foo5 (a, b);\n+  if (__builtin_memcmp (&dest, &exp, 16))\n+    __builtin_abort ();\n+\n+  exp = __extension__ (v4si) { 2, 4, 3, 6 };\n+  dest = foo6 (a, b);\n+  if (__builtin_memcmp (&dest, &exp, 16))\n+    __builtin_abort ();\n+\n+  exp = __extension__ (v4si) { 2, 3, 4, 6 };\n+  dest = foo7 (a, b);\n+  if (__builtin_memcmp (&dest, &exp, 16))\n+    __builtin_abort ();\n+\n+  exp = __extension__ (v4si) { 2, 4, 6, 3 };\n+  dest = foo8 (a, b);\n+  if (__builtin_memcmp (&dest, &exp, 16))\n+    __builtin_abort ();\n+\n+}"}, {"sha": "0b204f6f21002fd03b93e473bbbe0396064d3ce3", "filename": "gcc/testsuite/gcc.target/i386/pr53346-3.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr53346-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr53346-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr53346-3.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,69 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-msse2 -O2 -mno-sse3\" } */\n+/* { dg-final { scan-assembler-times \"shufps\" 17 } } */\n+\n+typedef float v4sf __attribute__((vector_size(16)));\n+\n+v4sf\n+__attribute__((noipa))\n+foo (v4sf a, v4sf b)\n+{\n+  return __builtin_shufflevector (a, b, 1, 2, 5, 3);\n+}\n+\n+v4sf\n+__attribute__((noipa))\n+foo1 (v4sf a, v4sf b)\n+{\n+  return __builtin_shufflevector (a, b, 1, 5, 2, 3);\n+}\n+\n+v4sf\n+__attribute__((noipa))\n+foo2 (v4sf a, v4sf b)\n+{\n+  return __builtin_shufflevector (a, b, 1, 2, 3, 5);\n+}\n+\n+v4sf\n+__attribute__((noipa))\n+foo3 (v4sf a, v4sf b)\n+{\n+  return __builtin_shufflevector (a, b, 1, 4, 5, 6);\n+}\n+\n+v4sf\n+__attribute__((noipa))\n+foo4 (v4sf a, v4sf b)\n+{\n+  return __builtin_shufflevector (a, b, 3, 6, 7, 5);\n+}\n+\n+v4sf\n+__attribute__((noipa))\n+foo5 (v4sf a, v4sf b)\n+{\n+  return __builtin_shufflevector (a, b, 2, 4, 7, 6);\n+}\n+\n+v4sf\n+__attribute__((noipa))\n+foo6 (v4sf a, v4sf b)\n+{\n+  return __builtin_shufflevector (a, b, 2, 4, 3, 6);\n+}\n+\n+v4sf\n+__attribute__((noipa))\n+foo7 (v4sf a, v4sf b)\n+{\n+  return __builtin_shufflevector (a, b, 2, 3, 4, 6);\n+}\n+\n+v4sf\n+__attribute__((noipa))\n+foo8 (v4sf a, v4sf b)\n+{\n+  return __builtin_shufflevector (a, b, 2, 4, 6, 3);\n+}\n+"}, {"sha": "9e4e45bd5844442caa43210acf36ddacbc375bef", "filename": "gcc/testsuite/gcc.target/i386/pr53346-4.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr53346-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr53346-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr53346-4.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -msse2\" } */\n+/* { dg-require-effective-target sse2 } */\n+\n+#include \"sse2-check.h\"\n+#include \"pr53346-3.c\"\n+\n+static void\n+sse2_test ()\n+{\n+  v4sf a = __extension__(v4sf) { 0, 1, 2, 3 };\n+  v4sf b = __extension__(v4sf) { 4, 5, 6, 7 };\n+  v4sf exp = __extension__(v4sf) { 1, 2, 5, 3 };\n+  v4sf dest;\n+  dest = foo (a, b);\n+  if (__builtin_memcmp (&dest, &exp, 16))\n+    __builtin_abort ();\n+\n+  exp = __extension__ (v4sf) { 1, 5, 2, 3 };\n+  dest = foo1 (a, b);\n+  if (__builtin_memcmp (&dest, &exp, 16))\n+    __builtin_abort ();\n+\n+  exp = __extension__ (v4sf) { 1, 2, 3, 5 };\n+  dest = foo2 (a, b);\n+  if (__builtin_memcmp (&dest, &exp, 16))\n+    __builtin_abort ();\n+\n+  exp = __extension__ (v4sf) { 1, 4, 5, 6 };\n+  dest = foo3 (a, b);\n+  if (__builtin_memcmp (&dest, &exp, 16))\n+    __builtin_abort ();\n+\n+  exp = __extension__ (v4sf) { 3, 6, 7, 5 };\n+  dest = foo4 (a, b);\n+  if (__builtin_memcmp (&dest, &exp, 16))\n+    __builtin_abort ();\n+\n+  exp = __extension__ (v4sf) { 2, 4, 7, 6 };\n+  dest = foo5 (a, b);\n+  if (__builtin_memcmp (&dest, &exp, 16))\n+    __builtin_abort ();\n+\n+  exp = __extension__ (v4sf) { 2, 4, 3, 6 };\n+  dest = foo6 (a, b);\n+  if (__builtin_memcmp (&dest, &exp, 16))\n+    __builtin_abort ();\n+\n+  exp = __extension__ (v4sf) { 2, 3, 4, 6 };\n+  dest = foo7 (a, b);\n+  if (__builtin_memcmp (&dest, &exp, 16))\n+    __builtin_abort ();\n+\n+  exp = __extension__ (v4sf) { 2, 4, 6, 3 };\n+  dest = foo8 (a, b);\n+  if (__builtin_memcmp (&dest, &exp, 16))\n+    __builtin_abort ();\n+\n+}"}, {"sha": "c4e92cc805211208f403f68ab5383a73c01c778f", "filename": "gcc/testsuite/gcc.target/powerpc/pr100645.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr100645.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr100645.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr100645.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-options \"-mdejagnu-cpu=power6 -maltivec\" } */\n+\n+/* This used to ICE.  */\n+\n+typedef long long v2di __attribute__ ((vector_size (16)));\n+\n+v2di\n+foo_v2di_l (v2di x)\n+{\n+  return __builtin_shuffle ((v2di){0, 0}, x, (v2di){3, 0});\n+}\n+"}, {"sha": "10341c91d2f57614699d32bae05d2e8360a0d395", "filename": "gcc/testsuite/gcc.target/powerpc/pr96072.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96072.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96072.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96072.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-options \"-O2\" } */\n+\n+/* This used to ICE with the SYSV ABI (PR96072).  */\n+\n+void\n+he (int jn)\n+{\n+  {\n+    int bh[jn];\n+    if (jn != 0)\n+      goto wa;\n+  }\n+wa:;\n+}"}, {"sha": "28133aa4226eedbef6e5de9aa39db4d62af8db5b", "filename": "gcc/testsuite/gcc.target/riscv/ret-1.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fret-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fret-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fret-1.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -dp\" } */\n+/* This was extracted from coremark.  */\n+\n+\n+typedef signed short ee_s16;\n+typedef struct list_data_s\n+{\n+    ee_s16 data16;\n+    ee_s16 idx;\n+} list_data;\n+\n+typedef struct list_head_s\n+{\n+    struct list_head_s *next;\n+    struct list_data_s *info;\n+} list_head;\n+\n+\n+list_head *\n+core_list_find(list_head *list, list_data *info)\n+{\n+    if (info->idx >= 0)\n+    {\n+        while (list && (list->info->idx != info->idx))\n+            list = list->next;\n+        return list;\n+    }\n+    else\n+    {\n+        while (list && ((list->info->data16 & 0xff) != info->data16))\n+            list = list->next;\n+        return list;\n+    }\n+}\n+\n+/* There is only one legitimate unconditional jump, so test for that,\n+   which will catch the case where bb-reorder leaves a jump to a ret\n+   in the IL.  */\n+/* { dg-final { scan-assembler-times \"jump\" 1 } } */\n+"}, {"sha": "abe956c80948bcea2b18759d9dee507a9acfda1d", "filename": "gcc/testsuite/gdc.test/compilable/commontype.d", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcommontype.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcommontype.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcommontype.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -151,19 +151,19 @@ static assert(Error!( uint*, int* ));\n static assert(is( X!( int function(), int function() ) == int function() ));\n \n // void pointer\n-static assert(is( X!( void*, int* ) == int* ));\n-static assert(is( X!( int*, void* ) == int* ));\n-static assert(is( X!( const(int)*, void* ) == const(int)* ));\n-static assert(is( X!( const(int*), void* ) == const(int*) ));\n-static assert(is( X!( int*, const(void)* ) == int* )); // `const`\n-static assert(is( X!( int*, const(void*) ) == int* )); // `const`\n-static assert(is( X!( int*, shared(void*) ) == int* )); // should fail\n-static assert(is( X!( int*, shared(void)* ) == int* )); // should fail\n+static assert(is( X!( void*, int* ) == void* ));\n+static assert(is( X!( int*, void* ) == void* ));\n+static assert(is( X!( const(int)*, void* ) == void* ));\n+static assert(is( X!( const(int*), void* ) == void* ));\n+static assert(is( X!( int*, const(void)* ) == const(void)* )); // `const`\n+static assert(is( X!( int*, const(void*) ) == const(void*) )); // `const`\n+static assert(is( X!( int*, shared(void*) ) == shared(void*) )); // should fail\n+static assert(is( X!( int*, shared(void)* ) == shared(void)* )); // should fail\n \n static assert(Error!( int**, void** )); // should work\n \n-static assert(is( X!( void*, int function() ) == int function() ));\n-static assert(is( X!( immutable(void*), int function() ) == int function() )); // `const`\n+static assert(is( X!( void*, int function() ) == void* ));\n+static assert(is( X!( immutable(void*), int function() ) == immutable(void*) )); // `const`\n \n // implicit conversion\n static assert(is( X!( int*, const(int*) ) == const(int*) ));"}, {"sha": "c8ff97644c3a89baaa54d88108cd129b4d485947", "filename": "gcc/testsuite/gdc.test/compilable/imports/cimports2a.i", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fcimports2a.i", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fcimports2a.i", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fcimports2a.i?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,4 @@\n+extern int xx;\n+\n+typedef struct Foo *FooRef;\n+FooRef make_foo(void);"}, {"sha": "03b22b2a216313514edb65b21983d928e0a2a89f", "filename": "gcc/testsuite/gdc.test/compilable/imports/cimports2b.i", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fcimports2b.i", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fcimports2b.i", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fcimports2b.i?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,4 @@\n+extern int xx;\n+\n+typedef struct Foo *FooRef;\n+void free_foo(FooRef foo);"}, {"sha": "de9b95705e1af65fc085a1deb2b71cdc87ecf96f", "filename": "gcc/testsuite/gdc.test/compilable/imports/format23327.d", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fformat23327.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fformat23327.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fformat23327.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,7 @@\n+module imports.format23327;\n+\n+import imports.format23327.write;\n+\n+immutable(string) format23327() { }\n+\n+import imports.format23327.internal.write;"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "gcc/testsuite/gdc.test/compilable/imports/format23327/write.d", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fformat23327%2Fwrite.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fformat23327%2Fwrite.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fformat23327%2Fwrite.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8"}, {"sha": "2ea125f5d3be8320f0dc82d355cf5904e5a55e72", "filename": "gcc/testsuite/gdc.test/compilable/segfaultgolf.d", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fsegfaultgolf.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fsegfaultgolf.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fsegfaultgolf.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,50 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23351\n+enum strings =\n+[\n+\"a[(b).\",\n+\"[(a)(b).\",\n+\"a(={@.()(\",\n+\"a[b,[(c).\",\n+\"a[b#([(c).\",\n+\"[a@b[(c).\",\n+\"[((a).\",\n+\"[a)b[(c).\",\n+\"a[b)[(c).\",\n+\"a(b[(c).\",\n+\"a[b()c[(d).\",\n+\"a[(b[(c).\",\n+\"a(b[(c).\",\n+\"[(@@a b[(c).\",\n+\"a[(!b)c[(d).\",\n+\"[(^a)b[(c).\",\n+\"a(b[(c).\",\n+\"~[a.b[(c).\",\n+\"[a).[(b c d(e[(f).\",\n+\"[((a).\",\n+\"[a}b[(c).\",\n+\"a[b[c..(d).\",\n+\"[1a.[(b).\",\n+\"a[({in){,\",\n+\"a[^in(b[c=])S....,\",\n+\"a[({in[({)){,\"\n+];\n+template KidNamedFinger(T)\n+{\n+\n+}\n+void dummy()\n+{\n+    static foreach(str; strings)\n+    {\n+        /*\n+            The above strings are all gibberish, they should\n+            fail to parse but not segfault the compiler.\n+        */\n+        {\n+            enum exp = __traits(compiles, mixin(str));\n+            static assert(!exp);\n+            enum t = __traits(compiles, KidNamedFinger!(mixin(str)));\n+            static assert(!t);\n+        }\n+    }\n+}"}, {"sha": "0236f2da29b50ba2181d148f47f4252d98d9a70c", "filename": "gcc/testsuite/gdc.test/compilable/statictemplatethis.d", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fstatictemplatethis.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fstatictemplatethis.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fstatictemplatethis.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,45 @@\n+mixin template Constructors(){\n+    this(){ }\n+    this()immutable{ }\n+    this()shared{ }\n+}\n+\n+class A {\n+public:\n+    static T getInstance(this T)() {\n+        return new T();\n+    }\n+private:\n+    mixin Constructors;\n+}\n+\n+class B : A {\n+private:\n+    mixin Constructors;\n+}\n+\n+void f(){\n+    auto a = (new A).getInstance;\n+    auto b = (new B).getInstance;\n+    static assert(is(typeof(a) == A));\n+    static assert(is(typeof(b) == B));\n+\n+    auto ca = (new immutable A).getInstance;\n+    auto sb = (new shared B).getInstance;\n+    static assert(is(typeof(ca) == immutable A));\n+    static assert(is(typeof(sb) == shared B));\n+}\n+\n+// https://issues.dlang.org/show_bug.cgi?id=10488\n+version(none)\n+void g(){\n+    auto a = A.getInstance();\n+    auto b = B.getInstance();\n+    static assert(is(typeof(a)==A));\n+    static assert(is(typeof(b)==B));\n+\n+    auto ai = (immutable(A)).getInstance();\n+    auto bs = (shared(B)).getInstance();\n+    static assert(is(typeof(ai)==immutable(A)));\n+    static assert(is(typeof(bs)==shared(B)));\n+}"}, {"sha": "881eb1b9dd7d99c174a8eaf8a2721d0e3a6df643", "filename": "gcc/testsuite/gdc.test/compilable/test13123.d", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest13123.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest13123.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest13123.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,38 @@\n+auto inferNothrow()\n+in\n+{\n+}\n+out\n+{\n+}\n+do\n+{\n+    return 1;\n+}\n+\n+auto dontInferNothrowIn()\n+in\n+{\n+    throw new Exception(null);\n+}\n+do\n+{\n+    return 1;\n+}\n+\n+auto dontInferNothrowOut()\n+out\n+{\n+    throw new Exception(null);\n+}\n+do\n+{\n+    return 1;\n+}\n+\n+enum isNothrow(Attr...) = (Attr.length >= 1)\n+    && (Attr[0] == \"nothrow\" || isNothrow!(Attr[1 .. $]));\n+\n+static assert(isNothrow!(__traits(getFunctionAttributes, inferNothrow)));\n+static assert(!isNothrow!(__traits(getFunctionAttributes, dontInferNothrowIn)));\n+static assert(!isNothrow!(__traits(getFunctionAttributes, dontInferNothrowOut)));"}, {"sha": "20838dc973b76fb796ff80acbfdde57eb77afc7d", "filename": "gcc/testsuite/gdc.test/compilable/test21243.d", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21243.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21243.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21243.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,21 @@\n+// Parsing - expressions\n+auto a = auto ref (int x) => x;\n+auto b = auto ref (int x) { return x; };\n+auto c = function auto ref (int x) { return x; };\n+auto d = delegate auto ref (int x) { return x; };\n+\n+// Parsing - aliases\n+alias e = auto ref (int x) => x;\n+alias f = auto ref (int x) { return x; };\n+alias g = function auto ref (int x) { return x; };\n+alias h = delegate auto ref (int x) { return x; };\n+\n+// Semantic\n+void test()\n+{\n+    alias fun(alias x) = auto ref () => x;\n+    int n = 123;\n+    auto _ = fun!123();\n+    static assert(!__traits(compiles, &fun!123())); // rvalue\n+    fun!n() = 456; // lvalue\n+}"}, {"sha": "64ebc55644c7723ca2b9a92ca6d586fb63214b9a", "filename": "gcc/testsuite/gdc.test/compilable/test21956.d", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21956.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21956.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21956.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,16 @@\n+// https://issues.dlang.org/show_bug.cgi?id=21956\n+\n+noreturn[noreturn] nrnr;\n+\n+void gun()\n+{\n+    foreach (a; nrnr){}\n+}\n+\n+int main()\n+{\n+    noreturn[] empty;\n+    int val;\n+    foreach(el; empty) val++;\n+    return val;\n+}"}, {"sha": "cc6e3bb2d073fe2fe40e22005b5040d741628ca2", "filename": "gcc/testsuite/gdc.test/compilable/test22674.d", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22674.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22674.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22674.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,10 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22674\n+// EXTRA_FILES: imports/cimports2a.i imports/cimports2b.i\n+\n+import imports.cimports2a;\n+import imports.cimports2b;\n+\n+void do_foo(){\n+    FooRef f = make_foo(); // use_foo.d(5)\n+    free_foo(f);           // use_foo.d(6)\n+}"}, {"sha": "6b16132d518fa1b4df3ca1e8e48f3371574bae29", "filename": "gcc/testsuite/gdc.test/compilable/test23173.d", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23173.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23173.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23173.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,6 @@\n+// REQUIRED_ARGS: -o-\n+// https://issues.dlang.org/show_bug.cgi?id=23173\n+\n+mixin(\"long l = \", long.min, \";\");\n+static assert(mixin(long.min) == long.min);\n+static assert(is(typeof(mixin(long.min)) == long));"}, {"sha": "1e8e91b779531c32c8820809f5e5e85c4f7dfd97", "filename": "gcc/testsuite/gdc.test/compilable/test23258.d", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23258.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23258.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23258.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,21 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23258\n+\n+struct SumType(Types...)\n+{\n+    this(Types[0])\n+    {\n+    }\n+    this(Types[1])\n+    {\n+    }\n+}\n+\n+alias A2 = SumType!(C1[], C2[]);\n+\n+class C1\n+{\n+}\n+\n+class C2\n+{\n+}"}, {"sha": "81b51f65aec6bd3bd8c885b6e95e52a0383cbaf1", "filename": "gcc/testsuite/gdc.test/compilable/test23306.d", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23306.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23306.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23306.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,7 @@\n+class A {\n+        @disable new();\n+}\n+\n+void main() {\n+        scope A a = new A();\n+}"}, {"sha": "bbb6346a9ff76cc47b38453c1698291d0365495f", "filename": "gcc/testsuite/gdc.test/compilable/test23327.d", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23327.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23327.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23327.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,3 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23327\n+// EXTRA_FILES: imports/format23327.d imports/format23327/write.d\n+import imports.format23327;"}, {"sha": "79826a0e132a5226a671ca9cd7953f92f359a694", "filename": "gcc/testsuite/gdc.test/compilable/vararg.d", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fvararg.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fvararg.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fvararg.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,20 @@\n+void main ()\n+{\n+    variance([1.0, 2, 3]);\n+}\n+\n+alias meanType(T) = T;\n+\n+template variance(bool stable = true)\n+{\n+    void variance(Range)(Range r, bool isPopulation = false)\n+    {\n+        .variance!(double, stable)(r, isPopulation);\n+    }\n+}\n+\n+template variance(F, bool stable = true)\n+{\n+    void variance(Range)(Range r, bool isPopulation = false) {}\n+    void variance(scope const F[] ar...) {}\n+}"}, {"sha": "84d0ad4696b64355a81b005185a04503f81a09ae", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag10169.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag10169.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag10169.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag10169.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -2,7 +2,7 @@\n EXTRA_FILES: imports/a10169.d\n TEST_OUTPUT:\n ---\n-fail_compilation/diag10169.d(12): Error: no property `x` for type `imports.a10169.B`\n+fail_compilation/diag10169.d(12): Error: no property `x` for `B(0)` of type `imports.a10169.B`\n ---\n */\n import imports.a10169;"}, {"sha": "80c7f5e56ea289357f2d5e5cbc9c5970d052e8c2", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag10783.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag10783.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag10783.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag10783.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/diag10783.d(14): Error: no property `type` for type `diag10783.Event`\n+fail_compilation/diag10783.d(14): Error: no property `type` for `event` of type `diag10783.Event`\n fail_compilation/diag10783.d(14): Error: undefined identifier `En`\n ---\n */"}, {"sha": "9b5761f7a575943e658408a915d1c27a74aaa62e", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag13528.d", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag13528.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag13528.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag13528.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,10 +1,12 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/diag13528.d(13): Error: value of `this` is not known at compile time\n-fail_compilation/diag13528.d(13):        while evaluating `pragma(msg, __traits(getMember, A, \"foo\"))`\n+fail_compilation/diag13528.d(6): Error: value of `this` is not known at compile time\n+fail_compilation/diag13528.d(6):        while evaluating `pragma(msg, __traits(getMember, A, \"foo\"))`\n+fail_compilation/diag13528.d(12):        parent scope from here: `mixin MyTemplate!()`\n ---\n */\n+#line 1\n \n mixin template MyTemplate()\n {"}, {"sha": "fa7c6114ad60a4f99daef91608217017f8ad5b3c", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag14145.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag14145.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag14145.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag14145.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/diag14145.d(15): Error: no property `i` for type `diag14145.main.Capture!(i)`\n+fail_compilation/diag14145.d(15): Error: no property `i` for `_` of type `diag14145.main.Capture!(i)`\n fail_compilation/diag14145.d(15):        potentially malformed `opDispatch`. Use an explicit instantiation to get a better error message\n fail_compilation/diag14145.d(34): Error: expression `*this.ptr` of type `shared(int)` is not implicitly convertible to return type `ref int`\n fail_compilation/diag14145.d(16): Error: template instance `diag14145.main.Capture!(i).Capture.opDispatch!\"i\"` error instantiating"}, {"sha": "e4cb2a7603a5687974d6abbff99ae69664101642", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag15713.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag15713.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag15713.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag15713.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/diag15713.d(19): Error: no property `widthSign` for type `diag15713.WrData.Data`\n+fail_compilation/diag15713.d(19): Error: no property `widthSign` for `this` of type `diag15713.WrData.Data`\n fail_compilation/diag15713.d(39): Error: template instance `diag15713.conwritefImpl!(\"parse-int\", \"width\", \"\\n\", Data(null))` error instantiating\n fail_compilation/diag15713.d(44):        instantiated from here: `conwritefImpl!(\"main\", \"\\n\", Data(null))`\n fail_compilation/diag15713.d(49):        instantiated from here: `fdwritef!()`"}, {"sha": "586cbb0fce85662420ac44a15c1272d04c645ad8", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag23355.d", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag23355.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag23355.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag23355.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,16 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/diag23355.d(1): Error: undefined identifier `n`\n+fail_compilation/diag23355.d(4): Error: none of the overloads of template `diag23355.ffi1` are callable using argument types `!()(int[4])`\n+fail_compilation/diag23355.d(1):        Candidate is: `ffi1(T)(T[n] s)`\n+fail_compilation/diag23355.d(2): Error: undefined identifier `n`\n+fail_compilation/diag23355.d(4): Error: none of the overloads of template `diag23355.ffi2` are callable using argument types `!()(int[4])`\n+fail_compilation/diag23355.d(2):        Candidate is: `ffi2()(T[n] s)`\n+---\n+*/\n+#line 1\n+void ffi1(T)(T[n] s) { }\n+void ffi2()(T[n] s) { }\n+\n+void main() { int[4] x; ffi1(x); ffi2(x); }"}, {"sha": "c4cbc721d860f7f199bf85fcc22660f8b7ee215f", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag3438.d", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag3438.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag3438.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag3438.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,4 +1,3 @@\n-// REQUIRED_ARGS: -de\n /*\n TEST_OUTPUT:\n ---\n@@ -8,6 +7,7 @@ fail_compilation/diag3438.d(20): Error: constructor `diag3438.F5.this` is marked\n fail_compilation/diag3438.d(20):        Use `@disable this();` if you want to disable default initialization.\n fail_compilation/diag3438.d(21): Error: constructor `diag3438.F6.this` is marked `@disable`, so it cannot have default arguments for all parameters.\n fail_compilation/diag3438.d(21):        Use `@disable this();` if you want to disable default initialization.\n+fail_compilation/diag3438.d(24): Error: default argument expected for `y`\n ---\n */\n \n@@ -19,3 +19,6 @@ struct F3 { this(...) { } } // ok\n struct F4 { this(int[] x...) { } }  // ok\n struct F5 { @disable this(int x = 1); }\n struct F6 { @disable this(int x = 1) { } }\n+\n+// Make sure the deprecation doesn't interfere w/ the check for default arguments\n+struct S { this(int x = 1, int y) { } }"}, {"sha": "46a197d2a24958006077e13aaa77882b975f4956", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag3438b.d", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b71e3dc02a8fd3141080419b7fb1a24d2c4133d0/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag3438b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b71e3dc02a8fd3141080419b7fb1a24d2c4133d0/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag3438b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag3438b.d?ref=b71e3dc02a8fd3141080419b7fb1a24d2c4133d0", "patch": "@@ -1,9 +0,0 @@\n-/*\n-TEST_OUTPUT:\n----\n-fail_compilation/diag3438b.d(9): Error: default argument expected for `y`\n----\n-*/\n-\n-// Make sure the deprecation doesn't interfere w/ the check for default arguments\n-struct S { this(int x = 1, int y) { } }"}, {"sha": "7cf3023aedbdf163f05f9760bf379074a131e137", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag8894.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8894.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8894.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8894.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,10 +1,10 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/diag8894.d(16): Error: no property `x` for type `diag8894.Foo`\n-fail_compilation/diag8894.d(17): Error: no property `y` for type `diag8894.Foo`\n-fail_compilation/diag8894.d(18): Error: no property `x` for type `diag8894.Foo`\n-fail_compilation/diag8894.d(19): Error: no property `x` for type `diag8894.Foo`\n+fail_compilation/diag8894.d(16): Error: no property `x` for `f` of type `diag8894.Foo`\n+fail_compilation/diag8894.d(17): Error: no property `y` for `f` of type `diag8894.Foo`\n+fail_compilation/diag8894.d(18): Error: no property `x` for `f` of type `diag8894.Foo`\n+fail_compilation/diag8894.d(19): Error: no property `x` for `f` of type `diag8894.Foo`\n ---\n */\n "}, {"sha": "324d21733af0686acee0455ac92aae256261731d", "filename": "gcc/testsuite/gdc.test/fail_compilation/dip22a.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdip22a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdip22a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdip22a.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -2,11 +2,11 @@\n EXTRA_FILES: imports/dip22a.d\n TEST_OUTPUT:\n ---\n-fail_compilation/dip22a.d(16): Error: no property `bar` for type `imports.dip22a.Klass`\n-fail_compilation/dip22a.d(17): Error: no property `bar` for type `imports.dip22a.Struct`\n+fail_compilation/dip22a.d(16): Error: no property `bar` for `new Klass` of type `imports.dip22a.Klass`\n+fail_compilation/dip22a.d(17): Error: no property `bar` for `Struct()` of type `imports.dip22a.Struct`\n fail_compilation/dip22a.d(18): Error: undefined identifier `bar` in module `imports.dip22a`\n-fail_compilation/dip22a.d(19): Error: no property `bar` for type `void`\n-fail_compilation/dip22a.d(20): Error: no property `bar` for type `int`\n+fail_compilation/dip22a.d(19): Error: no property `bar` for `Template!int` of type `void`\n+fail_compilation/dip22a.d(20): Error: no property `bar` for `12` of type `int`\n ---\n */\n import imports.dip22a;"}, {"sha": "92e07342d49b008e23111763c4b7dbd2ab63201e", "filename": "gcc/testsuite/gdc.test/fail_compilation/e15876_1.d", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fe15876_1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fe15876_1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fe15876_1.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,14 +1,15 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/e15876_1.d(15): Error: valid scope identifiers are `exit`, `failure`, or `success`, not `x`\n-fail_compilation/e15876_1.d(16): Error: found `End of File` when expecting `)`\n-fail_compilation/e15876_1.d(16): Error: found `End of File` instead of statement\n-fail_compilation/e15876_1.d(16): Error: found `End of File` when expecting `}` following compound statement\n-fail_compilation/e15876_1.d(16): Error: found `End of File` when expecting `]`\n-fail_compilation/e15876_1.d(16): Error: no identifier for declarator `o[()\n+fail_compilation/e15876_1.d(16): Error: valid scope identifiers are `exit`, `failure`, or `success`, not `x`\n+fail_compilation/e15876_1.d(17): Error: found `End of File` when expecting `)`\n+fail_compilation/e15876_1.d(17): Error: found `End of File` instead of statement\n+fail_compilation/e15876_1.d(17): Error: found `End of File` when expecting `}` following compound statement\n+fail_compilation/e15876_1.d(17): Error: found `End of File` when expecting `]`\n+fail_compilation/e15876_1.d(17): Error: no identifier for declarator `o[()\n {\n-scope(exit) }\n+scope(exit) __error__\n+}\n ]`\n ---\n */"}, {"sha": "fe7d546f51b7b6a9ae2fbb7ee87bcadb50b4f011", "filename": "gcc/testsuite/gdc.test/fail_compilation/e15876_3.d", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fe15876_3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fe15876_3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fe15876_3.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,25 +1,27 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/e15876_3.d(25): Error: unexpected `(` in declarator\n-fail_compilation/e15876_3.d(25): Error: basic type expected, not `=`\n-fail_compilation/e15876_3.d(26): Error: found `End of File` when expecting `(`\n-fail_compilation/e15876_3.d(26): Error: found `End of File` instead of statement\n-fail_compilation/e15876_3.d(26): Error: expression expected, not `End of File`\n-fail_compilation/e15876_3.d(26): Error: found `End of File` when expecting `;` following `for` condition\n-fail_compilation/e15876_3.d(26): Error: expression expected, not `End of File`\n-fail_compilation/e15876_3.d(26): Error: found `End of File` when expecting `)`\n-fail_compilation/e15876_3.d(26): Error: found `End of File` instead of statement\n-fail_compilation/e15876_3.d(26): Error: found `End of File` when expecting `}` following compound statement\n-fail_compilation/e15876_3.d(26): Error: found `End of File` when expecting `)`\n-fail_compilation/e15876_3.d(26): Error: no identifier for declarator `d(_error_ = ()\n+fail_compilation/e15876_3.d(27): Error: unexpected `(` in declarator\n+fail_compilation/e15876_3.d(27): Error: basic type expected, not `=`\n+fail_compilation/e15876_3.d(28): Error: found `End of File` when expecting `(`\n+fail_compilation/e15876_3.d(28): Error: found `End of File` instead of statement\n+fail_compilation/e15876_3.d(28): Error: expression expected, not `End of File`\n+fail_compilation/e15876_3.d(28): Error: found `End of File` when expecting `;` following `for` condition\n+fail_compilation/e15876_3.d(28): Error: expression expected, not `End of File`\n+fail_compilation/e15876_3.d(28): Error: found `End of File` when expecting `)`\n+fail_compilation/e15876_3.d(28): Error: found `End of File` instead of statement\n+fail_compilation/e15876_3.d(28): Error: found `End of File` when expecting `}` following compound statement\n+fail_compilation/e15876_3.d(28): Error: found `End of File` when expecting `)`\n+fail_compilation/e15876_3.d(28): Error: no identifier for declarator `d(_error_ = ()\n {\n-for (; 0; 0)\n+for (__error__\n+ 0; 0)\n {\n+__error__\n }\n }\n )`\n-fail_compilation/e15876_3.d(26): Error: semicolon expected following function declaration\n+fail_compilation/e15876_3.d(28): Error: semicolon expected following function declaration\n ---\n */\n d(={for"}, {"sha": "f4bd407b9c0eb84a61bff04dfd1c6b3779ca02a0", "filename": "gcc/testsuite/gdc.test/fail_compilation/e15876_4.d", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fe15876_4.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fe15876_4.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fe15876_4.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,20 +1,22 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/e15876_4.d(23): Error: found `)` when expecting `(`\n-fail_compilation/e15876_4.d(24): Error: found `End of File` when expecting `(`\n-fail_compilation/e15876_4.d(24): Error: found `End of File` instead of statement\n-fail_compilation/e15876_4.d(24): Error: expression expected, not `End of File`\n-fail_compilation/e15876_4.d(24): Error: found `End of File` when expecting `;` following `for` condition\n-fail_compilation/e15876_4.d(24): Error: expression expected, not `End of File`\n-fail_compilation/e15876_4.d(24): Error: found `End of File` when expecting `)`\n-fail_compilation/e15876_4.d(24): Error: found `End of File` instead of statement\n-fail_compilation/e15876_4.d(24): Error: found `End of File` when expecting `}` following compound statement\n-fail_compilation/e15876_4.d(24): Error: found `End of File` when expecting `)`\n-fail_compilation/e15876_4.d(24): Error: no identifier for declarator `typeof(()\n+fail_compilation/e15876_4.d(25): Error: found `)` when expecting `(`\n+fail_compilation/e15876_4.d(26): Error: found `End of File` when expecting `(`\n+fail_compilation/e15876_4.d(26): Error: found `End of File` instead of statement\n+fail_compilation/e15876_4.d(26): Error: expression expected, not `End of File`\n+fail_compilation/e15876_4.d(26): Error: found `End of File` when expecting `;` following `for` condition\n+fail_compilation/e15876_4.d(26): Error: expression expected, not `End of File`\n+fail_compilation/e15876_4.d(26): Error: found `End of File` when expecting `)`\n+fail_compilation/e15876_4.d(26): Error: found `End of File` instead of statement\n+fail_compilation/e15876_4.d(26): Error: found `End of File` when expecting `}` following compound statement\n+fail_compilation/e15876_4.d(26): Error: found `End of File` when expecting `)`\n+fail_compilation/e15876_4.d(26): Error: no identifier for declarator `typeof(()\n {\n-for (; 0; 0)\n+for (__error__\n+ 0; 0)\n {\n+__error__\n }\n }\n )`"}, {"sha": "cfda8f4d9ad00a3fd1b653bc2ba079c9575cb074", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail10968.d", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail10968.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail10968.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail10968.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,27 +1,28 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail10968.d(42): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(42): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(30):        `fail10968.SA.__postblit` is declared here\n fail_compilation/fail10968.d(43): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n fail_compilation/fail10968.d(43): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(30):        `fail10968.SA.__postblit` is declared here\n+fail_compilation/fail10968.d(31):        `fail10968.SA.__postblit` is declared here\n fail_compilation/fail10968.d(44): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n fail_compilation/fail10968.d(44): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(30):        `fail10968.SA.__postblit` is declared here\n-fail_compilation/fail10968.d(44): Error: `pure` function `fail10968.bar` cannot call impure function `core.internal.array.arrayassign._d_arrayassign_l!(SA[], SA)._d_arrayassign_l`\n-fail_compilation/fail10968.d(47): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(47): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(30):        `fail10968.SA.__postblit` is declared here\n+fail_compilation/fail10968.d(31):        `fail10968.SA.__postblit` is declared here\n+fail_compilation/fail10968.d(44): Error: `pure` function `fail10968.bar` cannot call impure function `core.internal.array.arrayassign._d_arraysetassign!(SA[], SA)._d_arraysetassign`\n+fail_compilation/fail10968.d(45): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n+fail_compilation/fail10968.d(45): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n+fail_compilation/fail10968.d(31):        `fail10968.SA.__postblit` is declared here\n+fail_compilation/fail10968.d(45): Error: `pure` function `fail10968.bar` cannot call impure function `core.internal.array.arrayassign._d_arrayassign_l!(SA[], SA)._d_arrayassign_l`\n fail_compilation/fail10968.d(48): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n fail_compilation/fail10968.d(48): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(30):        `fail10968.SA.__postblit` is declared here\n-fail_compilation/fail10968.d(48): Error: `pure` function `fail10968.bar` cannot call impure function `core.internal.array.construction._d_arraysetctor!(SA[], SA)._d_arraysetctor`\n+fail_compilation/fail10968.d(31):        `fail10968.SA.__postblit` is declared here\n fail_compilation/fail10968.d(49): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n fail_compilation/fail10968.d(49): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(30):        `fail10968.SA.__postblit` is declared here\n-fail_compilation/fail10968.d(49): Error: `pure` function `fail10968.bar` cannot call impure function `core.internal.array.construction._d_arrayctor!(SA[], SA)._d_arrayctor`\n+fail_compilation/fail10968.d(31):        `fail10968.SA.__postblit` is declared here\n+fail_compilation/fail10968.d(49): Error: `pure` function `fail10968.bar` cannot call impure function `core.internal.array.construction._d_arraysetctor!(SA[], SA)._d_arraysetctor`\n+fail_compilation/fail10968.d(50): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n+fail_compilation/fail10968.d(50): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n+fail_compilation/fail10968.d(31):        `fail10968.SA.__postblit` is declared here\n+fail_compilation/fail10968.d(50): Error: `pure` function `fail10968.bar` cannot call impure function `core.internal.array.construction._d_arrayctor!(SA[], SA)._d_arrayctor`\n ---\n */\n \n@@ -52,12 +53,12 @@ void bar() pure @safe\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail10968.d(75): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n fail_compilation/fail10968.d(76): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n fail_compilation/fail10968.d(77): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n-fail_compilation/fail10968.d(80): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n+fail_compilation/fail10968.d(78): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n fail_compilation/fail10968.d(81): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n fail_compilation/fail10968.d(82): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n+fail_compilation/fail10968.d(83): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n ---\n */\n "}, {"sha": "8d5af747ce15406fb80a89cb25f81569ce8ea9ba", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail121.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail121.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail121.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail121.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -3,8 +3,8 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail121.d(23): Error: no property `typeinfo` for type `fail121.myobject`\n-fail_compilation/fail121.d(23): Error: no property `typeinfo` for type `int`\n+fail_compilation/fail121.d(23): Error: no property `typeinfo` for `list[1]` of type `fail121.myobject`\n+fail_compilation/fail121.d(23): Error: no property `typeinfo` for `i` of type `int`\n ---\n */\n "}, {"sha": "7784cba67be5efce30c37268e19a69d6a4c774f1", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail13123.d", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail13123.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail13123.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail13123.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,21 @@\n+// REQUIRED_ARGS: -de\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail13123.d(10): Deprecation: `fail13123.test`: `in` contract may throw but function is marked as `nothrow`\n+fail_compilation/fail13123.d(10): Deprecation: `fail13123.test`: `out` contract may throw but function is marked as `nothrow`\n+---\n+*/\n+\n+void test() nothrow\n+in\n+{\n+    throw new Exception(null);\n+}\n+out\n+{\n+    throw new Exception(null);\n+}\n+do\n+{\n+}"}, {"sha": "39e7cb9eb7377b43e6f301380ceb679b7db2b283", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail17646.d", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17646.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17646.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17646.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -4,9 +4,8 @@ EXTRA_FILES: imports/fail17646.d\n TEST_OUTPUT:\n ---\n fail_compilation/imports/fail17646.d(10): Error: found `}` instead of statement\n-fail_compilation/imports/fail17646.d(7): Error: function `imports.fail17646.allTestData!\"\".allTestData` has no `return` statement, but is expected to return a value of type `const(TestData)[]`\n-fail_compilation/fail17646.d(16): Error: template instance `imports.fail17646.allTestData!\"\"` error instantiating\n-fail_compilation/fail17646.d(19):        instantiated from here: `runTests!\"\"`\n+fail_compilation/fail17646.d(11): Error: function `fail17646.runTests!\"\".runTests` has no `return` statement, but is expected to return a value of type `int`\n+fail_compilation/fail17646.d(18): Error: template instance `fail17646.runTests!\"\"` error instantiating\n ---\n */\n int runTests(Modules...)()"}, {"sha": "0fb56d315e97ae7f8da6f41e0ce0b76b2288834b", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail18892.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18892.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18892.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18892.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,8 +1,8 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail18892.d(20): Error: no property `foo` for type `fail18892.MT`\n-fail_compilation/fail18892.d(21): Error: no property `foo` for type `fail18892.MT`\n+fail_compilation/fail18892.d(20): Error: no property `foo` for `a` of type `fail18892.MT`\n+fail_compilation/fail18892.d(21): Error: no property `foo` for `MT` of type `fail18892.MT`\n ---\n */\n "}, {"sha": "a8156fe7d1efc7347457f29df1c443ae25144d14", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail18970.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18970.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18970.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18970.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,9 +1,9 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail18970.d(24): Error: no property `y` for type `fail18970.S`\n+fail_compilation/fail18970.d(24): Error: no property `y` for `S()` of type `fail18970.S`\n fail_compilation/fail18970.d(24):        potentially malformed `opDispatch`. Use an explicit instantiation to get a better error message\n-fail_compilation/fail18970.d(31): Error: no property `yyy` for type `fail18970.S2`\n+fail_compilation/fail18970.d(31): Error: no property `yyy` for `this` of type `fail18970.S2`\n fail_compilation/fail18970.d(31):        potentially malformed `opDispatch`. Use an explicit instantiation to get a better error message\n ---\n */"}, {"sha": "04e36f623ff79be2ab4879c8d4f8790cdaf05575", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail18979.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18979.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18979.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18979.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -2,7 +2,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail18979.d(13): Error: no property `__ctor` for type `imports.imp18979.Foo`\n+fail_compilation/fail18979.d(13): Error: no property `__ctor` for `Foo()` of type `imports.imp18979.Foo`\n ----\n */\n "}, {"sha": "40fafcdc1ae0e823f4bb72b7ae93418c4a0a5320", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail19103.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19103.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19103.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19103.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,8 +1,8 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail19103.d(12): Error: no property `puts` for type `fail19103.C`\n-fail_compilation/fail19103.d(14): Error: no property `puts` for type `fail19103.S1`\n+fail_compilation/fail19103.d(12): Error: no property `puts` for `new C` of type `fail19103.C`\n+fail_compilation/fail19103.d(14): Error: no property `puts` for `s1` of type `fail19103.S1`\n fail_compilation/fail19103.d(16): Error: no property `puts` for type `S2`, did you mean `core.stdc.stdio.puts`?\n ---\n */"}, {"sha": "0076091b8a1cacb07099fa538b23c0f833086f76", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail19687.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19687.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19687.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19687.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail19687.d(17): Error: no property `nonexisting` for type `string`\n+fail_compilation/fail19687.d(17): Error: no property `nonexisting` for `\"\"` of type `string`\n ---\n */\n "}, {"sha": "c880923ae407d3be405238e82e3dce2518a954c2", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail19913.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19913.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19913.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19913.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail19913.d(11): Error: no property `b` for type `int`\n+fail_compilation/fail19913.d(11): Error: no property `b` for `a` of type `int`\n fail_compilation/fail19913.d(11): Error: mixin `fail19913.S.b!()` is not defined\n ---\n */"}, {"sha": "25df235e9cb6ca29fabcc48cf111dc0030dce76a", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail21243.d", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail21243.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail21243.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail21243.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,19 @@\n+/+ TEST_OUTPUT:\n+---\n+fail_compilation/fail21243.d(16): Error: found `(` when expecting `ref` and function literal following `auto`\n+fail_compilation/fail21243.d(16): Error: semicolon expected following auto declaration, not `int`\n+fail_compilation/fail21243.d(16): Error: semicolon needed to end declaration of `x` instead of `)`\n+fail_compilation/fail21243.d(16): Error: declaration expected, not `)`\n+fail_compilation/fail21243.d(17): Error: `auto` can only be used as part of `auto ref` for function literal return values\n+fail_compilation/fail21243.d(18): Error: basic type expected, not `(`\n+fail_compilation/fail21243.d(18): Error: function declaration without return type. (Note that constructors are always named `this`)\n+fail_compilation/fail21243.d(18): Deprecation: storage class `auto` has no effect in type aliases\n+fail_compilation/fail21243.d(18): Error: semicolon expected to close `alias` declaration\n+fail_compilation/fail21243.d(18): Error: declaration expected, not `=>`\n+fail_compilation/fail21243.d(19): Error: `auto` can only be used as part of `auto ref` for function literal return values\n+---\n++/\n+auto a = auto (int x) => x;\n+auto b = function auto (int x) { return x; };\n+alias c = auto (int x) => x;\n+alias d = function auto (int x) { return x; };"}, {"sha": "5c5c11b719535cbcfe00c0762d7008c6811b0f9f", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail23109.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail23109.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail23109.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail23109.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -4,8 +4,8 @@ EXTRA_FILES: imports/test23109a.d imports/test23109b.d imports/test23109c.d\n EXTRA_SOURCES: extra-files/test23109/object.d\n TEST_OUTPUT:\n ---\n-Error: no property `getHash` for type `object.TypeInfo_Const`\n-Error: no property `getHash` for type `object.TypeInfo_Const`\n+Error: no property `getHash` for `typeid(const(Ensure[]))` of type `object.TypeInfo_Const`\n+Error: no property `getHash` for `typeid(const(Ensure[1]))` of type `object.TypeInfo_Const`\n fail_compilation/imports/test23109a.d(10): Error: template instance `imports.test23109a.Array!(Ensure)` error instantiating\n ---\n */"}, {"sha": "2d56e0969c28be579bdd9edea202961ddd89332a", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail7372.d", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail7372.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail7372.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail7372.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,13 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/imports/fail7372.d(7): Error: undefined identifier `X`\n+fail_compilation/fail7372.d(4):        parent scope from here: `mixin Issue7372!()`\n+---\n+*/\n+#line 1\n+import imports.fail7372;\n+interface I {}\n+class C : I {\n+    mixin Issue7372!();\n+}"}, {"sha": "c44b289cceca5d7a1f90c2d464cf30e6ef25ba17", "filename": "gcc/testsuite/gdc.test/fail_compilation/faildottypeinfo.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffaildottypeinfo.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffaildottypeinfo.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffaildottypeinfo.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/faildottypeinfo.d(11): Error: no property `typeinfo` for type `int`\n+fail_compilation/faildottypeinfo.d(11): Error: no property `typeinfo` for `0` of type `int`\n fail_compilation/faildottypeinfo.d(12): Error: no property `typeinfo` for type `object.Object`\n ---\n */"}, {"sha": "ff0d26be6737f67d2856cbcbabbe315fc97a6fdf", "filename": "gcc/testsuite/gdc.test/fail_compilation/failoffset.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffailoffset.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffailoffset.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffailoffset.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/failoffset.d(12): Error: no property `offset` for type `int`\n+fail_compilation/failoffset.d(12): Error: no property `offset` for `b` of type `int`\n fail_compilation/failoffset.d(12):        while evaluating: `static assert(b.offset == 4)`\n ---\n */"}, {"sha": "d21ee47dec749fd590185ae7b64ecc2c19d4ba04", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice10938.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice10938.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice10938.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice10938.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/ice10938.d(13): Error: no property `opts` for type `ice10938.C`\n+fail_compilation/ice10938.d(13): Error: no property `opts` for `this` of type `ice10938.C`\n fail_compilation/ice10938.d(13):        potentially malformed `opDispatch`. Use an explicit instantiation to get a better error message\n ---\n */"}, {"sha": "dbe386e97e996d1f129fe2893c574c87db7f4ff1", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice12174.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice12174.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice12174.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice12174.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/ice12174.d(12): Error: no property `sum` for type `int[]`\n+fail_compilation/ice12174.d(12): Error: no property `sum` for `[1, 2, 3]` of type `int[]`\n fail_compilation/ice12174.d(20): Error: CTFE failed because of previous errors in `this`\n fail_compilation/ice12174.d(13):        called from here: `filter([1, 2, 3])`\n ---"}, {"sha": "b26fe4cda046f740de7c1417d28ac8dd1dcb13e5", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice15855.d", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice15855.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice15855.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice15855.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -2,19 +2,21 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/ice15855.d(25): Error: found `End of File` when expecting `(`\n-fail_compilation/ice15855.d(25): Error: found `End of File` instead of statement\n-fail_compilation/ice15855.d(25): Error: expression expected, not `End of File`\n-fail_compilation/ice15855.d(25): Error: found `End of File` when expecting `;` following `for` condition\n-fail_compilation/ice15855.d(25): Error: expression expected, not `End of File`\n-fail_compilation/ice15855.d(25): Error: found `End of File` when expecting `)`\n-fail_compilation/ice15855.d(25): Error: found `End of File` instead of statement\n-fail_compilation/ice15855.d(25): Error: found `End of File` when expecting `}` following compound statement\n-fail_compilation/ice15855.d(25): Error: found `End of File` when expecting `]`\n-fail_compilation/ice15855.d(25): Error: no identifier for declarator `a[()\n+fail_compilation/ice15855.d(27): Error: found `End of File` when expecting `(`\n+fail_compilation/ice15855.d(27): Error: found `End of File` instead of statement\n+fail_compilation/ice15855.d(27): Error: expression expected, not `End of File`\n+fail_compilation/ice15855.d(27): Error: found `End of File` when expecting `;` following `for` condition\n+fail_compilation/ice15855.d(27): Error: expression expected, not `End of File`\n+fail_compilation/ice15855.d(27): Error: found `End of File` when expecting `)`\n+fail_compilation/ice15855.d(27): Error: found `End of File` instead of statement\n+fail_compilation/ice15855.d(27): Error: found `End of File` when expecting `}` following compound statement\n+fail_compilation/ice15855.d(27): Error: found `End of File` when expecting `]`\n+fail_compilation/ice15855.d(27): Error: no identifier for declarator `a[()\n {\n-for (; 0; 0)\n+for (__error__\n+ 0; 0)\n {\n+__error__\n }\n }\n ]`"}, {"sha": "796dd3dcc9decdb2f70635523633cd8ff93ba065", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice18469.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice18469.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice18469.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice18469.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/ice18469.d(10): Error: no property `opCall` for type `void`\n+fail_compilation/ice18469.d(10): Error: no property `opCall` for `this.~this()` of type `void`\n ---\n */\n class Bar"}, {"sha": "6d60fc43c1b2724d13c706201c2da13c0435bca5", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice19755.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice19755.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice19755.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice19755.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,6 +1,6 @@\n /* TEST_OUTPUT:\n ---\n-fail_compilation/ice19755.d(11): Error: no property `x` for type `ice19755.Thunk!int*`\n+fail_compilation/ice19755.d(11): Error: no property `x` for `self` of type `ice19755.Thunk!int*`\n fail_compilation/ice19755.d(16): Error: template instance `ice19755.Thunk!int` error instantiating\n ---\n */"}, {"sha": "f71c7367c700c5e5d4be936f9e79ba152d31b54b", "filename": "gcc/testsuite/gdc.test/fail_compilation/imports/fail7372.d", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Ffail7372.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Ffail7372.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Ffail7372.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,9 @@\n+module imports.fail7372;\n+import imports.imp1;\n+mixin template Issue7372()\n+{\n+    public void f()\n+    {\n+        int foo = X;\n+    }\n+}"}, {"sha": "11fddf069d6df4457b88ce4bbcdd713c505ade64", "filename": "gcc/testsuite/gdc.test/fail_compilation/misc_parser_err_cov1.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmisc_parser_err_cov1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmisc_parser_err_cov1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmisc_parser_err_cov1.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -22,7 +22,6 @@ fail_compilation/misc_parser_err_cov1.d(39): Error: expression expected, not `;`\n fail_compilation/misc_parser_err_cov1.d(40): Error: semicolon expected following auto declaration, not `auto`\n fail_compilation/misc_parser_err_cov1.d(40): Error: identifier or `new` expected following `.`, not `+`\n fail_compilation/misc_parser_err_cov1.d(41): Error: identifier or new keyword expected following `(...)`.\n-fail_compilation/misc_parser_err_cov1.d(41): Error: found `.` when expecting `;` following statement\n fail_compilation/misc_parser_err_cov1.d(41): Error: expression expected, not `;`\n fail_compilation/misc_parser_err_cov1.d(42): Error: found `}` when expecting `;` following statement\n fail_compilation/misc_parser_err_cov1.d(43): Error: found `End of File` when expecting `}` following compound statement"}, {"sha": "db8bf5968ddc70c57ff2b859e29d9f54d12d2e88", "filename": "gcc/testsuite/gdc.test/fail_compilation/mixinprop.d", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmixinprop.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmixinprop.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmixinprop.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,13 @@\n+/* TEST_OUTPUT:\n+---\n+fail_compilation/mixinprop.d(12): Error: no property `x` for `mixin Foo!() F;\n+` of type `void`\n+---\n+*/\n+mixin template Foo() { }\n+\n+void main()\n+{\n+    mixin Foo F;\n+    F.x;\n+}"}, {"sha": "594b5d35e758bd184f4b5c7ddb44f9327c0d0d10", "filename": "gcc/testsuite/gdc.test/fail_compilation/test15785.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15785.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15785.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15785.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -2,7 +2,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/test15785.d(16): Error: no property `foo` for type `imports.test15785.Base`\n+fail_compilation/test15785.d(16): Error: no property `foo` for `super` of type `imports.test15785.Base`\n fail_compilation/test15785.d(17): Error: undefined identifier `bar`\n ---\n */"}, {"sha": "db554cb9e15a1610bdbcd8a65bff1b6836bb7304", "filename": "gcc/testsuite/gdc.test/fail_compilation/test15897.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15897.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15897.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15897.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -3,7 +3,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/test15897.d(19): Error: no property `create` for type `imports.test15897.Cat`\n+fail_compilation/test15897.d(19): Error: no property `create` for `cat` of type `imports.test15897.Cat`\n ---\n */\n module test15897;"}, {"sha": "bdaae94a6ca3ae273fbd65865cc8953cee974bdf", "filename": "gcc/testsuite/gdc.test/fail_compilation/test16188.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest16188.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest16188.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest16188.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,7 +1,7 @@\n /* REQUIRED_ARGS: -preview=bitfields\n  * TEST_OUTPUT:\n ---\n-fail_compilation/test16188.d(101): Error: no property `name` for type `test16188.Where`\n+fail_compilation/test16188.d(101): Error: no property `name` for `Where()` of type `test16188.Where`\n fail_compilation/test16188.d(101):        potentially malformed `opDispatch`. Use an explicit instantiation to get a better error message\n ---\n  */"}, {"sha": "f523337037af5267c8e2b3223182ae191d8214ea", "filename": "gcc/testsuite/gdc.test/fail_compilation/test17380spec.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17380spec.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17380spec.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17380spec.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -2,7 +2,7 @@\n TEST_OUTPUT:\n ---\n (spec:1) fail_compilation/test17380spec.d(14): Error: cannot resolve identifier `ThisTypeDoesNotExistAndCrashesTheCompiler`\n-(spec:1) fail_compilation/test17380spec.d(14): Error: no property `ThisTypeDoesNotExistAndCrashesTheCompiler` for type `test17380spec.Uint128`\n+(spec:1) fail_compilation/test17380spec.d(14): Error: no property `ThisTypeDoesNotExistAndCrashesTheCompiler` for `this.opCast()` of type `test17380spec.Uint128`\n fail_compilation/test17380spec.d(14): Error: undefined identifier `ThisTypeDoesNotExistAndCrashesTheCompiler`\n ---\n  */"}, {"sha": "302eb3da31a132ae18cc521f0587bcacb89871b2", "filename": "gcc/testsuite/gdc.test/fail_compilation/test21096.d", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21096.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21096.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21096.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -3,10 +3,8 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/test21096.d(13): Error: identifier or new keyword expected following `(...)`.\n-fail_compilation/test21096.d(13): Error: found `.` when expecting `]`\n-fail_compilation/test21096.d(13): Error: no identifier for declarator `char`\n-fail_compilation/test21096.d(13): Error: declaration expected, not `]`\n+fail_compilation/test21096.d(11): Error: identifier or new keyword expected following `(...)`.\n+fail_compilation/test21096.d(11): Error: no identifier for declarator `char[(__error)]`\n ---\n */\n "}, {"sha": "caf0f4adff4a5c2f01e91f3b5b5eec2b179c40c6", "filename": "gcc/testsuite/gdc.test/fail_compilation/test22680.d", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22680.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22680.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22680.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,17 @@\n+/* REQUIRED_ARGS: -preview=dip1000\n+TEST_OUTPUT:\n+---\n+fail_compilation/test22680.d(104): Error: scope variable `this` assigned to non-scope `c`\n+---\n+*/\n+\n+// https://issues.dlang.org/show_bug.cgi?id=22680\n+\n+#line 100\n+\n+C c;\n+class C {\n+    ~this() @safe {\n+\t    c = this;\n+    }\n+}"}, {"sha": "94e79d5896a858e11eed102c1cf7c5f5a602ea6d", "filename": "gcc/testsuite/gdc.test/runnable/newaa.d", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fnewaa.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fnewaa.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fnewaa.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,23 @@\n+void main()\n+{\n+    alias AA = int[string];\n+    // aa is not ref\n+    static void test(AA aa)\n+    {\n+        aa[\"\"] = 0;\n+    }\n+    auto aa = new AA();\n+    auto ab = new int[string];\n+    auto ac = new typeof(aa);\n+    test(aa);\n+    test(ab);\n+    test(ac);\n+    assert(aa.length);\n+    assert(ab.length);\n+    assert(ac.length);\n+\n+    int[string] a = new int[string];\n+    auto b = a;\n+    a[\"seven\"] = 7;\n+    assert(b[\"seven\"] == 7);\n+}"}, {"sha": "7872aa76dfe2571767dbea51022a33e2da609c7f", "filename": "gcc/testsuite/gdc.test/runnable/test23234.d", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest23234.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest23234.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest23234.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,22 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23234\n+\n+class Bar\n+{\n+}\n+\n+class Foo\n+{\n+    Bar get() { return new Bar; }\n+    alias get this;\n+}\n+\n+void main()\n+{\n+    auto foo = new Foo;\n+    void test(Bar delegate() dg)\n+    {\n+        assert(dg() !is null);\n+    }\n+\n+    test(() => foo);\n+}"}, {"sha": "586aea80ccef258b2891116bfc0c6a5da9f8095d", "filename": "gcc/testsuite/gdc.test/runnable/testassign.d", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestassign.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestassign.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestassign.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -230,6 +230,21 @@ void test5()\n     static assert(!__traits(compiles, s.err += 1));\n }\n \n+void test6()\n+{\n+    int dtors;\n+    struct S6\n+    {\n+        @disable this(this);\n+        ~this() { dtors++; }\n+    }\n+\n+    S6[2] arr;\n+    arr = S6();\n+\n+    assert(dtors == 2);\n+}\n+\n /***************************************************/\n // https://issues.dlang.org/show_bug.cgi?id=4424\n \n@@ -1192,6 +1207,7 @@ int main()\n     test3();\n     test4();\n     test5();\n+    test6();\n     test4424();\n     test6174a();\n     test6174b();"}, {"sha": "d8bc1bb3b7ba543c4d6c6142f6f58fb06281ff17", "filename": "gcc/testsuite/gfortran.dg/intent_optimize_10.f90", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_10.f90?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,66 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fno-inline -fno-ipa-modref -fdump-tree-optimized -fdump-tree-original\" }\n+!\n+! PR fortran/41453\n+! Check that the INTENT(OUT) attribute causes in the case of non-polymorphic derived type arguments:\n+!  - one clobber to be emitted in the caller before calls to FOO in the *.original dump,\n+!  - no clobber to be emitted in the caller before calls to BAR in the *.original dump,\n+!  - the initialization constants to be optimized away in the *.optimized dump.\n+\n+module x\n+  implicit none\n+  type :: t\n+    integer :: c\n+  end type t\n+  type, extends(t) :: u\n+    integer :: d\n+  end type u\n+contains\n+  subroutine foo(a)\n+    type(t), intent(out) :: a\n+    a = t(42)\n+  end subroutine foo\n+  subroutine bar(b)\n+    class(t), intent(out) :: b\n+    b%c = 24\n+  end subroutine bar\n+end module x\n+\n+program main\n+  use x\n+  implicit none\n+  type(t) :: tc\n+  type(u) :: uc, ud\n+  class(t), allocatable :: te, tf\n+\n+  tc = t(123456789)\n+  call foo(tc)\n+  if (tc%c /= 42) stop 1\n+\n+  uc = u(987654321, 0)\n+  call foo(uc%t)\n+  if (uc%c /= 42) stop 2\n+  if (uc%d /= 0) stop 3\n+\n+  ud = u(11223344, 0)\n+  call bar(ud)\n+  if (ud%c /= 24) stop 4\n+\n+  te = t(55667788)\n+  call foo(te)\n+  if (te%c /= 42) stop 5\n+\n+  tf = t(99887766)\n+  call bar(tf)\n+  if (tf%c /= 24) stop 6\n+\n+end program main\n+\n+! We don't support class descriptors, neither derived type components, so there is a clobber for tc only;\n+! no clobber for uc, ud, te, tf.\n+! { dg-final { scan-tree-dump-times \"CLOBBER\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump \"tc = {CLOBBER};\" \"original\" } }\n+\n+! There is a clobber for tc, so we should manage to optimize away the associated initialization constant (but not other\n+! initialization constants).\n+! { dg-final { scan-tree-dump-not \"123456789\" \"optimized\" { target __OPTIMIZE__ } } }"}, {"sha": "effbaa12a2d95b72ada52e06c07f4d910f818b77", "filename": "gcc/testsuite/gfortran.dg/intent_optimize_4.f90", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_4.f90?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,43 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fdump-tree-original\" }\n+! { dg-final { scan-tree-dump-times \"CLOBBER\" 2 \"original\" } }\n+!\n+! PR fortran/106817\n+! Check that for an actual argument whose dummy is INTENT(OUT),\n+! the clobber that is emitted in the caller before a procedure call\n+! happens after any expression depending on the argument value has been\n+! evaluated.\n+! \n+\n+module m\n+  implicit none\n+contains\n+  subroutine copy1(out, in)\n+    integer, intent(in) :: in\n+    integer, intent(out) :: out\n+    out = in\n+  end subroutine copy1\n+  subroutine copy2(in, out)\n+    integer, intent(in) :: in\n+    integer, intent(out) :: out\n+    out = in\n+  end subroutine copy2\n+end module m\n+\n+program p\n+  use m\n+  implicit none\n+  integer :: a, b\n+\n+  ! Clobbering of a should happen after a+1 has been evaluated.\n+  a = 3\n+  call copy1(a, a+1)\n+  if (a /= 4) stop 1\n+\n+  ! Clobbering order does not depend on the order of arguments.\n+  ! It should also come last with reversed arguments.\n+  b = 12\n+  call copy2(b+1, b)\n+  if (b /= 13) stop 2\n+\n+end program p"}, {"sha": "2f184bf84a84b617f75dcdf16f9a2c73d7e24bd4", "filename": "gcc/testsuite/gfortran.dg/intent_optimize_5.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_5.f90?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fno-inline -fno-ipa-modref -fdump-tree-optimized -fdump-tree-original\" }\n+!\n+! PR fortran/105012\n+! Check that the INTENT(OUT) attribute causes one clobber to be emitted in\n+! the caller before the call to Y in the *.original dump, and the\n+! initialization constant to be optimized away in the *.optimized dump,\n+! despite the non-explicit interface if the subroutine with the INTENT(OUT)\n+! is declared in the same file.\n+\n+SUBROUTINE Y (Z)\n+      integer, intent(out) :: Z\n+      Z = 42\n+END SUBROUTINE Y\n+PROGRAM TEST\n+    integer :: X\n+    X = 123456789\n+    CALL Y (X)\n+    if (X.ne.42) STOP 1\n+END PROGRAM\n+\n+! { dg-final { scan-tree-dump-times \"CLOBBER\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump \"x = {CLOBBER};\" \"original\" } }\n+! { dg-final { scan-tree-dump-not \"123456789\" \"optimized\" { target __OPTIMIZE__ } } }"}, {"sha": "72fec3db583660a030613af64ea60afa61d31871", "filename": "gcc/testsuite/gfortran.dg/intent_optimize_6.f90", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_6.f90?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,34 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fno-inline -fno-ipa-modref -fdump-tree-optimized -fdump-tree-original\" }\n+!\n+! PR fortran/41453\n+! Check that the INTENT(OUT) attribute causes one clobber to be emitted in\n+! the caller before each call to FOO in the *.original dump, and the\n+! initialization constant to be optimized away in the *.optimized dump,\n+! in the case of an argument passed by reference to the caller.\n+\n+module x\n+implicit none\n+contains\n+  subroutine foo(a)\n+    integer(kind=4), intent(out) :: a\n+    a = 42\n+  end subroutine foo\n+  subroutine bar(b)\n+    integer(kind=4) :: b\n+    b = 123456789\n+    call foo(b)\n+  end subroutine bar\n+end module x\n+\n+program main\n+  use x\n+  implicit none\n+  integer(kind=4) :: c\n+  call bar(c)\n+  if (c /= 42) stop 1\n+end program main\n+\n+! { dg-final { scan-tree-dump-times \"CLOBBER\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump \"\\\\*\\\\\\(integer\\\\\\(kind=4\\\\\\) \\\\*\\\\\\) b = {CLOBBER};\" \"original\" } }\n+! { dg-final { scan-tree-dump-not \"123456789\" \"optimized\" { target __OPTIMIZE__ } } }"}, {"sha": "c2f21929863b423e3dc216d00e4cb41ba23a29e5", "filename": "gcc/testsuite/gfortran.dg/intent_optimize_7.f90", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_7.f90?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,45 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fno-inline -fno-ipa-modref -fdump-tree-optimized -fdump-tree-original\" }\n+!\n+! PR fortran/41453\n+! Check that the INTENT(OUT) attribute causes one clobber to be emitted in\n+! the caller before each call to FOO in the *.original dump, and the\n+! initialization constants to be optimized away in the *.optimized dump,\n+! in the case of SAVE variables.\n+\n+module x\n+implicit none\n+contains\n+  subroutine foo(a)\n+    integer, intent(out) :: a\n+    a = 42\n+  end subroutine foo\n+end module x\n+\n+program main\n+  use x\n+  implicit none\n+  integer :: c = 0\n+\n+  ! implicit SAVE attribute\n+  c = 123456789\n+  call foo(c)\n+  if (c /= 42) stop 1\n+\n+  ! explicit SAVE attribute\n+  call check_save_explicit\n+\n+contains\n+  subroutine check_save_explicit\n+    integer, save :: d\n+    d = 987654321\n+    call foo(d)\n+    if (d /= 42) stop 2\n+  end subroutine check_save_explicit\n+end program main\n+\n+! { dg-final { scan-tree-dump-times \"CLOBBER\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump \"c = {CLOBBER};\" \"original\" } }\n+! { dg-final { scan-tree-dump \"d = {CLOBBER};\" \"original\" } }\n+! { dg-final { scan-tree-dump-not \"123456789\" \"optimized\" { target __OPTIMIZE__ } } }\n+! { dg-final { scan-tree-dump-not \"987654321\" \"optimized\" { target __OPTIMIZE__ } } }"}, {"sha": "4336fceab027ee0bd0e279fb2744fa22ad587403", "filename": "gcc/testsuite/gfortran.dg/intent_optimize_8.f90", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_8.f90?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,45 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fno-inline -fno-ipa-modref -fdump-tree-optimized -fdump-tree-original\" }\n+!\n+! PR fortran/41453\n+! Check that the INTENT(OUT) attribute causes one clobber to be emitted in\n+! the caller before each call to FOO in the *.original dump, and the\n+! initialization constants to be optimized away in the *.optimized dump,\n+! in the case of associate variables.\n+\n+module x\n+implicit none\n+contains\n+  subroutine foo(a)\n+    integer, intent(out) :: a\n+    a = 42\n+  end subroutine foo\n+end module x\n+\n+program main\n+  use x\n+  implicit none\n+  integer :: c1, c2\n+\n+  c1 = 123456789\n+  associate (d1 => c1)\n+    call foo(d1)\n+    if (d1 /= 42) stop 1\n+  end associate\n+  if (c1 /= 42) stop 2\n+\n+  c2 = 0\n+  associate (d2 => c2)\n+    d2 = 987654321\n+    call foo(d2)\n+    if (d2 /= 42) stop 3\n+  end associate\n+  if (c2 /= 42) stop 4\n+\n+end program main\n+\n+! { dg-final { scan-tree-dump-times \"CLOBBER\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump \"d1 = {CLOBBER};\" \"original\" } }\n+! { dg-final { scan-tree-dump \"\\\\*d2 = {CLOBBER};\" \"original\" } }\n+! { dg-final { scan-tree-dump-not \"123456789\" \"optimized\" { target __OPTIMIZE__ } } }\n+! { dg-final { scan-tree-dump-not \"987654321\" \"optimized\" { target __OPTIMIZE__ } } }"}, {"sha": "0146dff4e203b94bba0b06b6ab8dc86ca26cf4bb", "filename": "gcc/testsuite/gfortran.dg/intent_optimize_9.f90", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_9.f90?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,42 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fno-inline -fno-ipa-modref -fdump-tree-optimized -fdump-tree-original\" }\n+!\n+! PR fortran/41453\n+! Check that the INTENT(OUT) attribute causes one clobber to be emitted in\n+! the caller before each call to FOO in the *.original dump, and the\n+! initialization constants to be optimized away in the *.optimized dump,\n+! in the case of scalar allocatables and pointers.\n+\n+module x\n+implicit none\n+contains\n+  subroutine foo(a)\n+    integer, intent(out) :: a\n+    a = 42\n+  end subroutine foo\n+end module x\n+\n+program main\n+  use x\n+  implicit none\n+  integer, allocatable :: ca\n+  integer, target :: ct\n+  integer, pointer :: cp\n+\n+  allocate(ca)\n+  ca = 123456789\n+  call foo(ca)\n+  if (ca /= 42) stop 1\n+  deallocate(ca)\n+\n+  ct = 987654321\n+  cp => ct\n+  call foo(cp)\n+  if (ct /= 42) stop 2\n+end program main\n+\n+! { dg-final { scan-tree-dump-times \"CLOBBER\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump \"\\\\*ca = {CLOBBER};\" \"original\" } }\n+! { dg-final { scan-tree-dump \"\\\\*cp = {CLOBBER};\" \"original\" } }\n+! { dg-final { scan-tree-dump-not \"123456789\" \"optimized\" { target __OPTIMIZE__ } } }\n+! { dg-final { scan-tree-dump-not \"987654321\" \"optimized\" { target __OPTIMIZE__ } } }"}, {"sha": "64334e6f0388ff3cf92fa0a20202fff8659f0a43", "filename": "gcc/testsuite/gfortran.dg/intent_out_15.f90", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_out_15.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_out_15.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_out_15.f90?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -0,0 +1,27 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-fdump-tree-original\" }\n+!\n+! PR fortran/105012\n+! The following case was triggering an ICE because of a clobber\n+! on the DERFC function decl instead of its result.\n+\n+module error_function\n+integer, parameter :: r8 = selected_real_kind(12) ! 8 byte real\n+contains\n+SUBROUTINE CALERF_r8(ARG, RESULT, JINT)\n+   integer, parameter :: rk = r8\n+   real(rk), intent(in)  :: arg\n+   real(rk), intent(out) :: result\n+   IF (Y .LE. THRESH) THEN\n+   END IF\n+end SUBROUTINE CALERF_r8\n+FUNCTION DERFC(X)\n+   integer, parameter :: rk = r8 ! 8 byte real\n+   real(rk), intent(in) :: X\n+   real(rk) :: DERFC\n+   CALL CALERF_r8(X, DERFC, JINT)\n+END FUNCTION DERFC\n+end module error_function\n+\n+! { dg-final { scan-tree-dump-times \"CLOBBER\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump \"__result_derfc = {CLOBBER};\" \"original\" } }"}, {"sha": "55807fe15c695468c09a96c04a6af42daa9014a7", "filename": "gcc/tree-core.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -690,6 +690,10 @@ enum tree_index {\n \t\t\t     - TI_FLOATN_NX_TYPE_FIRST\t\t\\\n \t\t\t     + 1)\n \n+  /* Type used by certain backends for __float128, which in C++ should be\n+     distinct type from _Float128 for backwards compatibility reasons.  */\n+  TI_FLOAT128T_TYPE,\n+\n   /* Put the complex types after their component types, so that in (sequential)\n      tree streaming we can assert that their component types have already been\n      handled (see tree-streamer.cc:record_common_node).  */"}, {"sha": "84bef798f52daca4b4b46e6963d65f2f61f914bd", "filename": "gcc/tree-ssa-dom.cc", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftree-ssa-dom.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftree-ssa-dom.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1227,29 +1227,30 @@ void\n dom_opt_dom_walker::set_global_ranges_from_unreachable_edges (basic_block bb)\n {\n   edge pred_e = single_pred_edge_ignoring_loop_edges (bb, false);\n-\n   if (!pred_e)\n     return;\n \n   gimple *stmt = last_stmt (pred_e->src);\n+  if (!stmt\n+      || gimple_code (stmt) != GIMPLE_COND\n+      || !assert_unreachable_fallthru_edge_p (pred_e))\n+    return;\n+\n   tree name;\n-  if (stmt\n-      && gimple_code (stmt) == GIMPLE_COND\n-      && (name = gimple_cond_lhs (stmt))\n-      && TREE_CODE (name) == SSA_NAME\n-      && assert_unreachable_fallthru_edge_p (pred_e)\n-      && all_uses_feed_or_dominated_by_stmt (name, stmt))\n-    {\n-      Value_Range r (TREE_TYPE (name));\n+  gori_compute &gori = m_ranger->gori ();\n+  FOR_EACH_GORI_EXPORT_NAME (gori, pred_e->src, name)\n+    if (all_uses_feed_or_dominated_by_stmt (name, stmt))\n+      {\n+\tValue_Range r (TREE_TYPE (name));\n \n-      if (m_ranger->range_on_edge (r, pred_e, name)\n-\t  && !r.varying_p ()\n-\t  && !r.undefined_p ())\n-\t{\n-\t  set_range_info (name, r);\n-\t  maybe_set_nonzero_bits (pred_e, name);\n-\t}\n-    }\n+\tif (m_ranger->range_on_edge (r, pred_e, name)\n+\t    && !r.varying_p ()\n+\t    && !r.undefined_p ())\n+\t  {\n+\t    set_range_info (name, r);\n+\t    maybe_set_nonzero_bits (pred_e, name);\n+\t  }\n+      }\n }\n \n /* Record any equivalences created by the incoming edge to BB into"}, {"sha": "b39c3c882c4b65494f94cefbb6e46249d044b2c9", "filename": "gcc/tree-ssa-reassoc.cc", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftree-ssa-reassoc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftree-ssa-reassoc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -3608,13 +3608,13 @@ optimize_range_tests_cmp_bitwise (enum tree_code opcode, int first, int length,\n \ttree type2 = NULL_TREE;\n \tbool strict_overflow_p = false;\n \tcandidates.truncate (0);\n-\tif (POINTER_TYPE_P (type1))\n+\tif (POINTER_TYPE_P (type1) || TREE_CODE (type1) == OFFSET_TYPE)\n \t  type1 = pointer_sized_int_node;\n \tfor (j = i; j; j = chains[j - 1])\n \t  {\n \t    tree type = TREE_TYPE (ranges[j - 1].exp);\n \t    strict_overflow_p |= ranges[j - 1].strict_overflow_p;\n-\t    if (POINTER_TYPE_P (type))\n+\t    if (POINTER_TYPE_P (type) || TREE_CODE (type) == OFFSET_TYPE)\n \t      type = pointer_sized_int_node;\n \t    if ((b % 4) == 3)\n \t      {\n@@ -3646,7 +3646,7 @@ optimize_range_tests_cmp_bitwise (enum tree_code opcode, int first, int length,\n \t    tree type = TREE_TYPE (ranges[j - 1].exp);\n \t    if (j == k)\n \t      continue;\n-\t    if (POINTER_TYPE_P (type))\n+\t    if (POINTER_TYPE_P (type) || TREE_CODE (type) == OFFSET_TYPE)\n \t      type = pointer_sized_int_node;\n \t    if ((b % 4) == 3)\n \t      {\n@@ -3677,17 +3677,28 @@ optimize_range_tests_cmp_bitwise (enum tree_code opcode, int first, int length,\n \t\top = r->exp;\n \t\tcontinue;\n \t      }\n-\t    if (id == l || POINTER_TYPE_P (TREE_TYPE (op)))\n+\t    if (id == l\n+\t\t|| POINTER_TYPE_P (TREE_TYPE (op))\n+\t\t|| TREE_CODE (TREE_TYPE (op)) == OFFSET_TYPE)\n \t      {\n \t\tcode = (b % 4) == 3 ? BIT_NOT_EXPR : NOP_EXPR;\n \t\ttree type3 = id >= l ? type1 : pointer_sized_int_node;\n+\t\tif (code == BIT_NOT_EXPR\n+\t\t    && TREE_CODE (TREE_TYPE (op)) == OFFSET_TYPE)\n+\t\t  {\n+\t\t    g = gimple_build_assign (make_ssa_name (type3),\n+\t\t\t\t\t     NOP_EXPR, op);\n+\t\t    gimple_seq_add_stmt_without_update (&seq, g);\n+\t\t    op = gimple_assign_lhs (g);\n+\t\t  }\n \t\tg = gimple_build_assign (make_ssa_name (type3), code, op);\n \t\tgimple_seq_add_stmt_without_update (&seq, g);\n \t\top = gimple_assign_lhs (g);\n \t      }\n \t    tree type = TREE_TYPE (r->exp);\n \t    tree exp = r->exp;\n \t    if (POINTER_TYPE_P (type)\n+\t\t|| TREE_CODE (type) == OFFSET_TYPE\n \t\t|| (id >= l && !useless_type_conversion_p (type1, type)))\n \t      {\n \t\ttree type3 = id >= l ? type1 : pointer_sized_int_node;\n@@ -3705,7 +3716,7 @@ optimize_range_tests_cmp_bitwise (enum tree_code opcode, int first, int length,\n \t    op = gimple_assign_lhs (g);\n \t  }\n \ttype1 = TREE_TYPE (ranges[k - 1].exp);\n-\tif (POINTER_TYPE_P (type1))\n+\tif (POINTER_TYPE_P (type1) || TREE_CODE (type1) == OFFSET_TYPE)\n \t  {\n \t    gimple *g\n \t      = gimple_build_assign (make_ssa_name (type1), NOP_EXPR, op);"}, {"sha": "756c14ff0cc3fdaba30d9e5c70f54c6dd6e27786", "filename": "gcc/tree.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -9461,6 +9461,7 @@ build_common_tree_nodes (bool signed_char)\n       layout_type (FLOATN_NX_TYPE_NODE (i));\n       SET_TYPE_MODE (FLOATN_NX_TYPE_NODE (i), mode);\n     }\n+  float128t_type_node = float128_type_node;\n \n   float_ptr_type_node = build_pointer_type (float_type_node);\n   double_ptr_type_node = build_pointer_type (double_type_node);"}, {"sha": "95285e45fb7f2021ec2a3ee1d2068344bb5f0ce6", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -4302,6 +4302,10 @@ tree_strip_any_location_wrapper (tree exp)\n #define float64x_type_node\t\tglobal_trees[TI_FLOAT64X_TYPE]\n #define float128x_type_node\t\tglobal_trees[TI_FLOAT128X_TYPE]\n \n+/* Type used by certain backends for __float128, which in C++ should be\n+   distinct type from _Float128 for backwards compatibility reasons.  */\n+#define float128t_type_node\t\tglobal_trees[TI_FLOAT128T_TYPE]\n+\n #define float_ptr_type_node\t\tglobal_trees[TI_FLOAT_PTR_TYPE]\n #define double_ptr_type_node\t\tglobal_trees[TI_DOUBLE_PTR_TYPE]\n #define long_double_ptr_type_node\tglobal_trees[TI_LONG_DOUBLE_PTR_TYPE]"}, {"sha": "6154d73ccf5dccb0b89e5fb8a4937090ea0a441c", "filename": "gcc/value-range.cc", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -258,15 +258,6 @@ frange::accept (const vrange_visitor &v) const\n   v.visit (*this);\n }\n \n-// Helper function to compare floats.  Returns TRUE if op1 .CODE. op2\n-// is nonzero.\n-\n-static inline bool\n-tree_compare (tree_code code, tree op1, tree op2)\n-{\n-  return !integer_zerop (fold_build2 (code, integer_type_node, op1, op2));\n-}\n-\n // Flush denormal endpoints to the appropriate 0.0.\n \n void\n@@ -2939,6 +2930,19 @@ irange::set_nonzero_bits (const wide_int_ref &bits)\n       set_nonzero_bits (NULL);\n       return;\n     }\n+  // If we have only one bit set in the mask, we can figure out the\n+  // range immediately.\n+  if (wi::popcount (bits) == 1)\n+    {\n+      bool has_zero = contains_p (build_zero_cst (type ()));\n+      set (type (), bits, bits);\n+      if (has_zero)\n+\t{\n+\t  int_range<2> zero;\n+\t  zero.set_zero (type ());\n+\t  union_ (zero);\n+\t}\n+    }\n   set_nonzero_bits (wide_int_to_tree (type (), bits));\n }\n "}, {"sha": "556e31aece1a8ca24cc6635f11ff54164edbddd6", "filename": "gcc/value-range.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -117,6 +117,8 @@ class GTY((user)) irange : public vrange\n public:\n   // In-place setters.\n   virtual void set (tree, tree, value_range_kind = VR_RANGE) override;\n+  void set (tree type, const wide_int_ref &, const wide_int_ref &,\n+\t    value_range_kind = VR_RANGE);\n   virtual void set_nonzero (tree type) override;\n   virtual void set_zero (tree type) override;\n   virtual void set_nonnegative (tree type) override;\n@@ -687,6 +689,13 @@ irange::varying_compatible_p () const\n   return true;\n }\n \n+inline void\n+irange::set (tree type, const wide_int_ref &min, const wide_int_ref &max,\n+\t     value_range_kind kind)\n+{\n+  set (wide_int_to_tree (type, min), wide_int_to_tree (type, max), kind);\n+}\n+\n inline bool\n vrange::varying_p () const\n {"}, {"sha": "81d4353a86f27b28714f11bd47f307496782e652", "filename": "include/demangle.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/include%2Fdemangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/include%2Fdemangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdemangle.h?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -457,6 +457,11 @@ enum demangle_component_type\n   DEMANGLE_COMPONENT_MODULE_PARTITION,\n   DEMANGLE_COMPONENT_MODULE_ENTITY,\n   DEMANGLE_COMPONENT_MODULE_INIT,\n+\n+  /* A builtin type with argument.  This holds the builtin type\n+     information.  */\n+  DEMANGLE_COMPONENT_EXTENDED_BUILTIN_TYPE\n+\n };\n \n /* Types which are only used internally.  */\n@@ -543,6 +548,15 @@ struct demangle_component\n       const struct demangle_builtin_type_info *type;\n     } s_builtin;\n \n+    /* For DEMANGLE_COMPONENT_EXTENDED_BUILTIN_TYPE.  */\n+    struct\n+    {\n+      /* Builtin type.  */\n+      const struct demangle_builtin_type_info *type;\n+      short arg;\n+      char suffix;\n+    } s_extended_builtin;\n+\n     /* For DEMANGLE_COMPONENT_SUB_STD.  */\n     struct\n     {"}, {"sha": "87bf764a4fbb35157739c3d2d4a6f3501503c296", "filename": "include/dwarf2.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/include%2Fdwarf2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/include%2Fdwarf2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdwarf2.h?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -373,6 +373,16 @@ enum dwarf_source_language\n     DW_LANG_Fortran03 = 0x0022,\n     DW_LANG_Fortran08 = 0x0023,\n     DW_LANG_RenderScript = 0x0024,\n+    DW_LANG_BLISS = 0x0025,\n+    DW_LANG_Kotlin = 0x0026,\n+    DW_LANG_Zig = 0x0027,\n+    DW_LANG_Crystal = 0x0028,\n+    DW_LANG_C_plus_plus_17 = 0x002a,\n+    DW_LANG_C_plus_plus_20 = 0x002b,\n+    DW_LANG_C17 = 0x002c,\n+    DW_LANG_Fortran18 = 0x002d,\n+    DW_LANG_Ada2005 = 0x002e,\n+    DW_LANG_Ada2012 = 0x002f,\n \n     DW_LANG_lo_user = 0x8000,\t/* Implementation-defined range start.  */\n     DW_LANG_hi_user = 0xffff,\t/* Implementation-defined range start.  */"}, {"sha": "1d680643ad883f6b9ffb9dc288626a4a95a4e40e", "filename": "libcpp/expr.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libcpp%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libcpp%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fexpr.cc?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -215,7 +215,6 @@ interpret_float_suffix (cpp_reader *pfile, const uchar *s, size_t len)\n \tcase 'f': case 'F':\n \t  f++;\n \t  if (len > 0\n-\t      && !CPP_OPTION (pfile, cplusplus)\n \t      && s[1] >= '1'\n \t      && s[1] <= '9'\n \t      && fn_bits == 0)"}, {"sha": "2429618514f55b245b4b5730151aebb5c34c840a", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,3 +1,8 @@\n+2022-09-26  Thomas Neumann  <tneumann@users.sourceforge.net>\n+\n+\t* unwind-dw2-fde.c: Introduce a constant for in_shutdown\n+\tfor the non-fast-path case. Drop destructor priority.\n+\n 2022-09-22  Thomas Neumann  <tneumann@users.sourceforge.net>\n \n \t* unwind-dw2-fde.c: (release_register_frames) Remember"}, {"sha": "3c0cc654ec0e23c26d00e9f3a644f304647185af", "filename": "libgcc/unwind-dw2-fde.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libgcc%2Funwind-dw2-fde.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libgcc%2Funwind-dw2-fde.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Funwind-dw2-fde.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -51,7 +51,7 @@ static struct btree registered_frames;\n static bool in_shutdown;\n \n static void\n-release_registered_frames (void) __attribute__ ((destructor (110)));\n+release_registered_frames (void) __attribute__ ((destructor));\n static void\n release_registered_frames (void)\n {\n@@ -67,6 +67,8 @@ static void\n init_object (struct object *ob);\n \n #else\n+/* Without fast path frame deregistration must always succeed.  */\n+static const int in_shutdown = 0;\n \n /* The unseen_objects list contains objects that have been registered\n    but not yet categorized in any way.  The seen_objects list has had"}, {"sha": "a5830a463d92caa2ed5cb38a213fbb72a689ba3b", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,3 +1,8 @@\n+2022-09-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/106981\n+\t* testsuite/libgomp.c-c++-common/pr106981.c: New test.\n+\n 2022-09-14  Julian Brown  <julian@codesourcery.com>\n \n \t* testsuite/libgomp.oacc-c-c++-common/deep-copy-15.c: New test."}, {"sha": "7ff225ec1aa584033eb624a25808cb09780c756b", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 61, "deletions": 39, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -648,6 +648,13 @@ d_dump (struct demangle_component *dc, int indent)\n     case DEMANGLE_COMPONENT_BUILTIN_TYPE:\n       printf (\"builtin type %s\\n\", dc->u.s_builtin.type->name);\n       return;\n+    case DEMANGLE_COMPONENT_EXTENDED_BUILTIN_TYPE:\n+      {\n+\tchar suffix[2] = { dc->u.s_extended_builtin.type->suffix, 0 };\n+\tprintf (\"builtin type %s%d%s\\n\", dc->u.s_extended_builtin.type->name,\n+\t\tdc->u.s_extended_builtin.type->arg, suffix);\n+      }\n+      return;\n     case DEMANGLE_COMPONENT_OPERATOR:\n       printf (\"operator %s\\n\", dc->u.s_operator.op->name);\n       return;\n@@ -771,11 +778,6 @@ d_dump (struct demangle_component *dc, int indent)\n     case DEMANGLE_COMPONENT_PTRMEM_TYPE:\n       printf (\"pointer to member type\\n\");\n       break;\n-    case DEMANGLE_COMPONENT_FIXED_TYPE:\n-      printf (\"fixed-point type, accum? %d, sat? %d\\n\",\n-              dc->u.s_fixed.accum, dc->u.s_fixed.sat);\n-      d_dump (dc->u.s_fixed.length, indent + 2);\n-      break;\n     case DEMANGLE_COMPONENT_ARGLIST:\n       printf (\"argument list\\n\");\n       break;\n@@ -1109,6 +1111,28 @@ d_make_builtin_type (struct d_info *di,\n   return p;\n }\n \n+/* Add a new extended builtin type component.  */\n+\n+static struct demangle_component *\n+d_make_extended_builtin_type (struct d_info *di,\n+\t\t\t      const struct demangle_builtin_type_info *type,\n+\t\t\t      short arg, char suffix)\n+{\n+  struct demangle_component *p;\n+\n+  if (type == NULL)\n+    return NULL;\n+  p = d_make_empty (di);\n+  if (p != NULL)\n+    {\n+      p->type = DEMANGLE_COMPONENT_EXTENDED_BUILTIN_TYPE;\n+      p->u.s_extended_builtin.type = type;\n+      p->u.s_extended_builtin.arg = arg;\n+      p->u.s_extended_builtin.suffix = suffix;\n+    }\n+  return p;\n+}\n+\n /* Add a new operator component.  */\n \n static struct demangle_component *\n@@ -2464,6 +2488,7 @@ cplus_demangle_builtin_types[D_BUILTIN_TYPE_COUNT] =\n   /* 32 */ { NL (\"char32_t\"),\tNL (\"char32_t\"),\tD_PRINT_DEFAULT },\n   /* 33 */ { NL (\"decltype(nullptr)\"),\tNL (\"decltype(nullptr)\"),\n \t     D_PRINT_DEFAULT },\n+  /* 34 */ { NL (\"_Float\"),\tNL (\"_Float\"),\t\tD_PRINT_FLOAT },\n };\n \n CP_STATIC_IF_GLIBCPP_V3\n@@ -2727,19 +2752,26 @@ cplus_demangle_type (struct d_info *di)\n \t  break;\n \n \tcase 'F':\n-\t  /* Fixed point types. DF<int bits><length><fract bits><sat>  */\n-\t  ret = d_make_empty (di);\n-\t  ret->type = DEMANGLE_COMPONENT_FIXED_TYPE;\n-\t  if ((ret->u.s_fixed.accum = IS_DIGIT (d_peek_char (di))))\n-\t    /* For demangling we don't care about the bits.  */\n-\t    d_number (di);\n-\t  ret->u.s_fixed.length = cplus_demangle_type (di);\n-\t  if (ret->u.s_fixed.length == NULL)\n-\t    return NULL;\n-\t  d_number (di);\n-\t  peek = d_next_char (di);\n-\t  ret->u.s_fixed.sat = (peek == 's');\n-\t  break;\n+\t  /* DF<number>_ - _Float<number>.\n+\t     DF<number>x - _Float<number>x.  */\n+\t  {\n+\t    int arg = d_number (di);\n+\t    char buf[12];\n+\t    char suffix = 0;\n+\t    if (d_peek_char (di) == 'x')\n+\t      suffix = 'x';\n+\t    if (!suffix && d_peek_char (di) != '_')\n+\t      return NULL;\n+\t    ret\n+\t      = d_make_extended_builtin_type (di,\n+\t\t\t\t\t      &cplus_demangle_builtin_types[34],\n+\t\t\t\t\t      arg, suffix);\n+\t    d_advance (di, 1);\n+\t    sprintf (buf, \"%d\", arg);\n+\t    di->expansion += ret->u.s_extended_builtin.type->len\n+\t\t\t     + strlen (buf) + (suffix != 0);\n+\t    break;\n+\t  }\n \n \tcase 'v':\n \t  ret = d_vector_type (di);\n@@ -4202,6 +4234,7 @@ d_count_templates_scopes (struct d_print_info *dpi,\n     case DEMANGLE_COMPONENT_FUNCTION_PARAM:\n     case DEMANGLE_COMPONENT_SUB_STD:\n     case DEMANGLE_COMPONENT_BUILTIN_TYPE:\n+    case DEMANGLE_COMPONENT_EXTENDED_BUILTIN_TYPE:\n     case DEMANGLE_COMPONENT_OPERATOR:\n     case DEMANGLE_COMPONENT_CHARACTER:\n     case DEMANGLE_COMPONENT_NUMBER:\n@@ -4210,6 +4243,7 @@ d_count_templates_scopes (struct d_print_info *dpi,\n     case DEMANGLE_COMPONENT_MODULE_NAME:\n     case DEMANGLE_COMPONENT_MODULE_PARTITION:\n     case DEMANGLE_COMPONENT_MODULE_INIT:\n+    case DEMANGLE_COMPONENT_FIXED_TYPE:\n       break;\n \n     case DEMANGLE_COMPONENT_TEMPLATE:\n@@ -4309,10 +4343,6 @@ d_count_templates_scopes (struct d_print_info *dpi,\n       d_count_templates_scopes (dpi, dc->u.s_extended_operator.name);\n       break;\n \n-    case DEMANGLE_COMPONENT_FIXED_TYPE:\n-      d_count_templates_scopes (dpi, dc->u.s_fixed.length);\n-      break;\n-\n     case DEMANGLE_COMPONENT_GLOBAL_CONSTRUCTORS:\n     case DEMANGLE_COMPONENT_GLOBAL_DESTRUCTORS:\n     case DEMANGLE_COMPONENT_MODULE_ENTITY:\n@@ -4580,11 +4610,11 @@ d_find_pack (struct d_print_info *dpi,\n     case DEMANGLE_COMPONENT_TAGGED_NAME:\n     case DEMANGLE_COMPONENT_OPERATOR:\n     case DEMANGLE_COMPONENT_BUILTIN_TYPE:\n+    case DEMANGLE_COMPONENT_EXTENDED_BUILTIN_TYPE:\n     case DEMANGLE_COMPONENT_SUB_STD:\n     case DEMANGLE_COMPONENT_CHARACTER:\n     case DEMANGLE_COMPONENT_FUNCTION_PARAM:\n     case DEMANGLE_COMPONENT_UNNAMED_TYPE:\n-    case DEMANGLE_COMPONENT_FIXED_TYPE:\n     case DEMANGLE_COMPONENT_DEFAULT_ARG:\n     case DEMANGLE_COMPONENT_NUMBER:\n       return NULL;\n@@ -5387,6 +5417,14 @@ d_print_comp_inner (struct d_print_info *dpi, int options,\n \t\t\t dc->u.s_builtin.type->java_len);\n       return;\n \n+    case DEMANGLE_COMPONENT_EXTENDED_BUILTIN_TYPE:\n+      d_append_buffer (dpi, dc->u.s_extended_builtin.type->name,\n+\t\t       dc->u.s_extended_builtin.type->len);\n+      d_append_num (dpi, dc->u.s_extended_builtin.arg);\n+      if (dc->u.s_extended_builtin.suffix)\n+\td_append_buffer (dpi, &dc->u.s_extended_builtin.suffix, 1);\n+      return;\n+\n     case DEMANGLE_COMPONENT_VENDOR_TYPE:\n       d_print_comp (dpi, options, d_left (dc));\n       return;\n@@ -5525,22 +5563,6 @@ d_print_comp_inner (struct d_print_info *dpi, int options,\n \treturn;\n       }\n \n-    case DEMANGLE_COMPONENT_FIXED_TYPE:\n-      if (dc->u.s_fixed.sat)\n-\td_append_string (dpi, \"_Sat \");\n-      /* Don't print \"int _Accum\".  */\n-      if (dc->u.s_fixed.length->u.s_builtin.type\n-\t  != &cplus_demangle_builtin_types['i'-'a'])\n-\t{\n-\t  d_print_comp (dpi, options, dc->u.s_fixed.length);\n-\t  d_append_char (dpi, ' ');\n-\t}\n-      if (dc->u.s_fixed.accum)\n-\td_append_string (dpi, \"_Accum\");\n-      else\n-\td_append_string (dpi, \"_Fract\");\n-      return;\n-\n     case DEMANGLE_COMPONENT_ARGLIST:\n     case DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:\n       if (d_left (dc) != NULL)"}, {"sha": "c5d046b3f01711b65aca2b7a9917f365ba97c5cd", "filename": "libiberty/cp-demangle.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libiberty%2Fcp-demangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libiberty%2Fcp-demangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.h?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -180,7 +180,7 @@ d_advance (struct d_info *di, int i)\n extern const struct demangle_operator_info cplus_demangle_operators[];\n #endif\n \n-#define D_BUILTIN_TYPE_COUNT (34)\n+#define D_BUILTIN_TYPE_COUNT (35)\n \n CP_STATIC_IF_GLIBCPP_V3\n const struct demangle_builtin_type_info"}, {"sha": "8fad6893ae7618cda26c3a783767ec62112b4d9f", "filename": "libiberty/testsuite/demangle-expected", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libiberty%2Ftestsuite%2Fdemangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libiberty%2Ftestsuite%2Fdemangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Fdemangle-expected?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1242,8 +1242,12 @@ _ZNSt9_Any_data9_M_accessIPZ4postISt8functionIFvvEEEvOT_EUlvE_EERS5_v\n post<std::function<void ()> >(std::function<void ()>&&)::{lambda()#1}*& std::_Any_data::_M_access<post<std::function<void ()> >(post<std::function<void ()> >(std::function<void ()>&&)::{lambda()#1}*&&)::{lambda()#1}*>()\n #\n --format=auto --no-params\n-_Z3xxxDFyuVb\n-xxx(unsigned long long _Fract, bool volatile)\n+_Z3xxxDF16_DF32_DF64_DF128_CDF16_Vb\n+xxx(_Float16, _Float32, _Float64, _Float128, _Float16 _Complex, bool volatile)\n+xxx\n+--format=auto --no-params\n+_Z3xxxDF32xDF64xDF128xCDF32xVb\n+xxx(_Float32x, _Float64x, _Float128x, _Float32x _Complex, bool volatile)\n xxx\n # https://sourceware.org/bugzilla/show_bug.cgi?id=16817\n --format=auto --no-params"}, {"sha": "a4c46f3306ede57b9563edfe93b88cb6026ed42b", "filename": "libphobos/libdruntime/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMERGE?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1,4 +1,4 @@\n-817610b16d0f0f469b9fbb28c000956fb910c43f\n+4219ba670ce9ff92f3e874f0f048f2c28134c008\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "45749d7ef103b1a4b60d6a2bfc40e20fafb88d7b", "filename": "libphobos/libdruntime/Makefile.am", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.am?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -211,11 +211,11 @@ DRUNTIME_DSOURCES = core/atomic.d core/attribute.d core/bitop.d \\\n \tgcc/sections/package.d gcc/sections/pecoff.d gcc/simd.d \\\n \tgcc/unwind/arm.d gcc/unwind/arm_common.d gcc/unwind/c6x.d \\\n \tgcc/unwind/generic.d gcc/unwind/package.d gcc/unwind/pe.d object.d \\\n-\trt/aApply.d rt/aApplyR.d rt/aaA.d rt/adi.d rt/arrayassign.d \\\n-\trt/arraycat.d rt/cast_.d rt/config.d rt/critical_.d rt/deh.d \\\n-\trt/dmain2.d rt/ehalloc.d rt/invariant.d rt/lifetime.d rt/memory.d \\\n-\trt/minfo.d rt/monitor_.d rt/profilegc.d rt/sections.d rt/tlsgc.d \\\n-\trt/util/typeinfo.d rt/util/utility.d\n+\trt/aApply.d rt/aApplyR.d rt/aaA.d rt/adi.d rt/arraycat.d rt/cast_.d \\\n+\trt/config.d rt/critical_.d rt/deh.d rt/dmain2.d rt/ehalloc.d \\\n+\trt/invariant.d rt/lifetime.d rt/memory.d rt/minfo.d rt/monitor_.d \\\n+\trt/profilegc.d rt/sections.d rt/tlsgc.d rt/util/typeinfo.d \\\n+\trt/util/utility.d\n \n DRUNTIME_DSOURCES_STDCXX = core/stdcpp/allocator.d core/stdcpp/array.d \\\n \tcore/stdcpp/exception.d core/stdcpp/memory.d core/stdcpp/new_.d \\"}, {"sha": "e86721fb3feeaecf5db75b434c7de7c9d02d2c2f", "filename": "libphobos/libdruntime/Makefile.in", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.in?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -242,11 +242,11 @@ am__objects_1 = core/atomic.lo core/attribute.lo core/bitop.lo \\\n \tgcc/unwind/arm_common.lo gcc/unwind/c6x.lo \\\n \tgcc/unwind/generic.lo gcc/unwind/package.lo gcc/unwind/pe.lo \\\n \tobject.lo rt/aApply.lo rt/aApplyR.lo rt/aaA.lo rt/adi.lo \\\n-\trt/arrayassign.lo rt/arraycat.lo rt/cast_.lo rt/config.lo \\\n-\trt/critical_.lo rt/deh.lo rt/dmain2.lo rt/ehalloc.lo \\\n-\trt/invariant.lo rt/lifetime.lo rt/memory.lo rt/minfo.lo \\\n-\trt/monitor_.lo rt/profilegc.lo rt/sections.lo rt/tlsgc.lo \\\n-\trt/util/typeinfo.lo rt/util/utility.lo\n+\trt/arraycat.lo rt/cast_.lo rt/config.lo rt/critical_.lo \\\n+\trt/deh.lo rt/dmain2.lo rt/ehalloc.lo rt/invariant.lo \\\n+\trt/lifetime.lo rt/memory.lo rt/minfo.lo rt/monitor_.lo \\\n+\trt/profilegc.lo rt/sections.lo rt/tlsgc.lo rt/util/typeinfo.lo \\\n+\trt/util/utility.lo\n am__objects_2 = core/stdc/libgdruntime_la-errno_.lo\n am__objects_3 = core/sys/elf/package.lo\n am__objects_4 = core/stdcpp/allocator.lo core/stdcpp/array.lo \\\n@@ -880,11 +880,11 @@ DRUNTIME_DSOURCES = core/atomic.d core/attribute.d core/bitop.d \\\n \tgcc/sections/package.d gcc/sections/pecoff.d gcc/simd.d \\\n \tgcc/unwind/arm.d gcc/unwind/arm_common.d gcc/unwind/c6x.d \\\n \tgcc/unwind/generic.d gcc/unwind/package.d gcc/unwind/pe.d object.d \\\n-\trt/aApply.d rt/aApplyR.d rt/aaA.d rt/adi.d rt/arrayassign.d \\\n-\trt/arraycat.d rt/cast_.d rt/config.d rt/critical_.d rt/deh.d \\\n-\trt/dmain2.d rt/ehalloc.d rt/invariant.d rt/lifetime.d rt/memory.d \\\n-\trt/minfo.d rt/monitor_.d rt/profilegc.d rt/sections.d rt/tlsgc.d \\\n-\trt/util/typeinfo.d rt/util/utility.d\n+\trt/aApply.d rt/aApplyR.d rt/aaA.d rt/adi.d rt/arraycat.d rt/cast_.d \\\n+\trt/config.d rt/critical_.d rt/deh.d rt/dmain2.d rt/ehalloc.d \\\n+\trt/invariant.d rt/lifetime.d rt/memory.d rt/minfo.d rt/monitor_.d \\\n+\trt/profilegc.d rt/sections.d rt/tlsgc.d rt/util/typeinfo.d \\\n+\trt/util/utility.d\n \n DRUNTIME_DSOURCES_STDCXX = core/stdcpp/allocator.d core/stdcpp/array.d \\\n \tcore/stdcpp/exception.d core/stdcpp/memory.d core/stdcpp/new_.d \\\n@@ -1364,7 +1364,6 @@ rt/aApply.lo: rt/$(am__dirstamp)\n rt/aApplyR.lo: rt/$(am__dirstamp)\n rt/aaA.lo: rt/$(am__dirstamp)\n rt/adi.lo: rt/$(am__dirstamp)\n-rt/arrayassign.lo: rt/$(am__dirstamp)\n rt/arraycat.lo: rt/$(am__dirstamp)\n rt/cast_.lo: rt/$(am__dirstamp)\n rt/config.lo: rt/$(am__dirstamp)"}, {"sha": "1c49035890471e6cbe3d0aa6a58e39fb5bf1c09a", "filename": "libphobos/libdruntime/__builtins.di", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2F__builtins.di", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2F__builtins.di", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2F__builtins.di?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -15,7 +15,7 @@ module __builtins;\n /* gcc relies on internal __builtin_xxxx functions and templates to\n  * accomplish <stdarg.h>. D does the same thing with templates in core.stdc.stdarg.\n  * Here, we redirect the gcc builtin declarations to the equivalent\n- * ones in core.stdc.stdarg, thereby avoiding having to hardware them\n+ * ones in core.stdc.stdarg, thereby avoiding having to hardwire them\n  * into the D compiler.\n  */\n "}, {"sha": "c2d40322961d338b8328def9c5e42a17d5dac61b", "filename": "libphobos/libdruntime/core/demangle.d", "status": "modified", "additions": 185, "deletions": 65, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2Fcore%2Fdemangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2Fcore%2Fdemangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fdemangle.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -82,7 +82,7 @@ pure @safe:\n \n     static class ParseException : Exception\n     {\n-        @safe pure nothrow this( string msg )\n+        this(string msg) @safe pure nothrow\n         {\n             super( msg );\n         }\n@@ -91,14 +91,14 @@ pure @safe:\n \n     static class OverflowException : Exception\n     {\n-        @safe pure nothrow this( string msg )\n+        this(string msg) @safe pure nothrow\n         {\n             super( msg );\n         }\n     }\n \n \n-    static void error( string msg = \"Invalid symbol\" ) @trusted /* exception only used in module */\n+    static noreturn error( string msg = \"Invalid symbol\" ) @trusted /* exception only used in module */\n     {\n         pragma(inline, false); // tame dmd inliner\n \n@@ -110,7 +110,7 @@ pure @safe:\n     }\n \n \n-    static void overflow( string msg = \"Buffer overflow\" ) @trusted /* exception only used in module */\n+    static noreturn overflow( string msg = \"Buffer overflow\" ) @trusted /* exception only used in module */\n     {\n         pragma(inline, false); // tame dmd inliner\n \n@@ -156,7 +156,6 @@ pure @safe:\n         if (val >= '0' && val <= '9')\n             return cast(ubyte)(val - '0');\n         error();\n-        return 0;\n     }\n \n \n@@ -253,23 +252,22 @@ pure @safe:\n             put(\", \");\n     }\n \n-    char[] put(char c) return scope\n+    void put(char c) return scope\n     {\n         char[1] val = c;\n-        return put(val[]);\n+        put(val[]);\n     }\n \n-    char[] put( scope const(char)[] val ) return scope\n+    void put(scope const(char)[] val) return scope\n     {\n         pragma(inline, false); // tame dmd inliner\n \n-        if ( val.length )\n-        {\n-            if ( !contains( dst[0 .. len], val ) )\n-                return append( val );\n-            return shift( val );\n-        }\n-        return null;\n+        if (!val.length) return;\n+\n+        if (!contains(dst[0 .. len], val))\n+            append(val);\n+        else\n+            shift(val);\n     }\n \n \n@@ -948,18 +946,19 @@ pure @safe:\n             return dst[beg .. len];\n         case 'D': // TypeDelegate (D TypeFunction)\n             popFront();\n-            auto modbeg = len;\n-            parseModifier();\n-            auto modend = len;\n+            auto modifiers = parseModifier();\n             if ( front == 'Q' )\n                 parseBackrefType( () => parseTypeFunction( name, IsDelegate.yes ) );\n             else\n                 parseTypeFunction( name, IsDelegate.yes );\n-            if (modend > modbeg)\n+            if (modifiers)\n             {\n-                // move modifiers behind the function arguments\n-                shift(dst[modend-1 .. modend]); // trailing space\n-                shift(dst[modbeg .. modend-1]);\n+                // write modifiers behind the function arguments\n+                while (auto str = typeCtors.toStringConsume(modifiers))\n+                {\n+                    put(' ');\n+                    put(str);\n+                }\n             }\n             return dst[beg .. len];\n         case 'n': // TypeNone (n)\n@@ -1009,7 +1008,6 @@ pure @safe:\n                 }\n             }\n             error();\n-            return null;\n         }\n     }\n \n@@ -1110,71 +1108,72 @@ pure @safe:\n         }\n     }\n \n-    void parseModifier()\n+    /// Returns: Flags of `TypeCtor`\n+    ushort parseModifier()\n     {\n+        TypeCtor res = TypeCtor.None;\n         switch ( front )\n         {\n         case 'y':\n             popFront();\n-            put( \"immutable \" );\n-            break;\n+            return TypeCtor.Immutable;\n         case 'O':\n             popFront();\n-            put( \"shared \" );\n-            if ( front == 'x' )\n+            res |= TypeCtor.Shared;\n+            if (front == 'x')\n                 goto case 'x';\n-            if ( front == 'N' )\n+            if (front == 'N')\n                 goto case 'N';\n-            break;\n+            return TypeCtor.Shared;\n         case 'N':\n-            if ( peek( 1 ) != 'g' )\n-                break;\n+            if (peek( 1 ) != 'g')\n+                return res;\n             popFront();\n             popFront();\n-            put( \"inout \" );\n+            res |= TypeCtor.InOut;\n             if ( front == 'x' )\n                 goto case 'x';\n-            break;\n+            return res;\n         case 'x':\n             popFront();\n-            put( \"const \" );\n-            break;\n-        default: break;\n+            res |= TypeCtor.Const;\n+            return res;\n+        default: return TypeCtor.None;\n         }\n     }\n \n-    void parseFuncAttr()\n+    ushort parseFuncAttr()\n     {\n         // FuncAttrs\n-        breakFuncAttrs:\n+        ushort result;\n         while ('N' == front)\n         {\n             popFront();\n             switch ( front )\n             {\n             case 'a': // FuncAttrPure\n                 popFront();\n-                put( \"pure \" );\n+                result |= FuncAttributes.Pure;\n                 continue;\n             case 'b': // FuncAttrNoThrow\n                 popFront();\n-                put( \"nothrow \" );\n+                result |= FuncAttributes.Nothrow;\n                 continue;\n             case 'c': // FuncAttrRef\n                 popFront();\n-                put( \"ref \" );\n+                result |= FuncAttributes.Ref;\n                 continue;\n             case 'd': // FuncAttrProperty\n                 popFront();\n-                put( \"@property \" );\n+                result |= FuncAttributes.Property;\n                 continue;\n             case 'e': // FuncAttrTrusted\n                 popFront();\n-                put( \"@trusted \" );\n+                result |= FuncAttributes.Trusted;\n                 continue;\n             case 'f': // FuncAttrSafe\n                 popFront();\n-                put( \"@safe \" );\n+                result |= FuncAttributes.Safe;\n                 continue;\n             case 'g':\n             case 'h':\n@@ -1188,27 +1187,42 @@ pure @safe:\n                 //       if we see these, then we know we're really in\n                 //       the parameter list.  Rewind and break.\n                 pos--;\n-                break breakFuncAttrs;\n+                return result;\n             case 'i': // FuncAttrNogc\n                 popFront();\n-                put( \"@nogc \" );\n+                result |= FuncAttributes.NoGC;\n                 continue;\n             case 'j': // FuncAttrReturn\n                 popFront();\n-                put( \"return \" );\n+                if (this.peek(0) == 'N' && this.peek(1) == 'l')\n+                {\n+                    result |= FuncAttributes.ReturnScope;\n+                    popFront();\n+                    popFront();\n+                } else {\n+                    result |= FuncAttributes.Return;\n+                }\n                 continue;\n             case 'l': // FuncAttrScope\n                 popFront();\n-                put( \"scope \" );\n+                if (this.peek(0) == 'N' && this.peek(1) == 'j')\n+                {\n+                    result |= FuncAttributes.ScopeReturn;\n+                    popFront();\n+                    popFront();\n+                } else {\n+                    result |= FuncAttributes.Scope;\n+                }\n                 continue;\n             case 'm': // FuncAttrLive\n                 popFront();\n-                put( \"@live \" );\n+                result |= FuncAttributes.Live;\n                 continue;\n             default:\n                 error();\n             }\n         }\n+        return result;\n     }\n \n     void parseFuncArguments() scope\n@@ -1346,19 +1360,20 @@ pure @safe:\n         auto beg = len;\n \n         parseCallConvention();\n-        auto attrbeg = len;\n-        parseFuncAttr();\n+        auto attributes = parseFuncAttr();\n \n         auto argbeg = len;\n         put( '(' );\n         parseFuncArguments();\n         put( ')' );\n-        if (attrbeg < argbeg)\n+        if (attributes)\n         {\n-            // move function attributes behind arguments\n-            shift( dst[argbeg - 1 .. argbeg] ); // trailing space\n-            shift( dst[attrbeg .. argbeg - 1] ); // attributes\n-            argbeg = attrbeg;\n+            // write function attributes behind arguments\n+            while (auto str = funcAttrs.toStringConsume(attributes))\n+            {\n+                put(' ');\n+                put(str);\n+            }\n         }\n         auto retbeg = len;\n         parseType();\n@@ -1900,21 +1915,26 @@ pure @safe:\n             {\n                 // do not emit \"needs this\"\n                 popFront();\n-                parseModifier();\n+                auto modifiers = parseModifier();\n+                while (auto str = typeCtors.toStringConsume(modifiers))\n+                {\n+                    put(str);\n+                    put(' ');\n+                }\n             }\n             if ( isCallConvention( front ) )\n             {\n                 // we don't want calling convention and attributes in the qualified name\n                 parseCallConvention();\n-                parseFuncAttr();\n-                if ( keepAttr )\n-                {\n+                auto attributes = parseFuncAttr();\n+                if (keepAttr) {\n+                    while (auto str = funcAttrs.toStringConsume(attributes))\n+                    {\n+                        put(str);\n+                        put(' ');\n+                    }\n                     attr = dst[prevlen .. len];\n                 }\n-                else\n-                {\n-                    len = prevlen;\n-                }\n \n                 put( '(' );\n                 parseFuncArguments();\n@@ -2637,6 +2657,12 @@ else\n         [\"_D4test4rrs1FNkMJPiZv\", \"void test.rrs1(return scope out int*)\"],\n         [\"_D4test4rrs1FNkMKPiZv\", \"void test.rrs1(return scope ref int*)\"],\n         [\"_D4test4rrs1FNkMPiZv\",  \"void test.rrs1(return scope int*)\"],\n+\n+        // `scope` and `return` combinations\n+        [\"_D3foo3Foo3barMNgFNjNlNfZNgPv\", \"inout return scope @safe inout(void*) foo.Foo.bar()\"],\n+        [\"_D3foo3FooQiMNgFNlNfZv\",        \"inout scope @safe void foo.Foo.foo()\"],\n+        [\"_D3foo3Foo4foorMNgFNjNfZv\",     \"inout return @safe void foo.Foo.foor()\"],\n+        [\"_D3foo3Foo3rabMNgFNlNjNfZv\",    \"inout scope return @safe void foo.Foo.rab()\"],\n     ];\n \n \n@@ -2720,7 +2746,12 @@ unittest\n }\n \n /*\n+ * Expand an OMF, DMD-generated compressed identifier into its full form\n  *\n+ * This function only has a visible effect for OMF binaries (Win32),\n+ * as compression is otherwise not used.\n+ *\n+ * See_Also: `compiler/src/dmd/backend/compress.d`\n  */\n string decodeDmdString( const(char)[] ln, ref size_t p ) nothrow pure @safe\n {\n@@ -2781,3 +2812,92 @@ extern (C) private\n         errno = err;\n     }\n }\n+\n+private struct ManglingFlagInfo\n+{\n+    /// The flag value to use\n+    ushort flag;\n+\n+    /// Human-readable representation\n+    string value;\n+}\n+\n+private enum TypeCtor : ushort {\n+    None      = 0,\n+    //// 'x'\n+    Const     = (1 << 1),\n+    /// 'y'\n+    Immutable = (1 << 2),\n+    /// 'O'\n+    Shared    = (1 << 3),\n+    ///\n+    InOut     = (1 << 4),\n+}\n+\n+private immutable ManglingFlagInfo[] typeCtors = [\n+    ManglingFlagInfo(TypeCtor.Immutable, \"immutable\"),\n+    ManglingFlagInfo(TypeCtor.Shared,    \"shared\"),\n+    ManglingFlagInfo(TypeCtor.InOut,     \"inout\"),\n+    ManglingFlagInfo(TypeCtor.Const,     \"const\"),\n+];\n+\n+private enum FuncAttributes : ushort {\n+    None      = 0,\n+    //// 'a'\n+    Pure     = (1 << 1),\n+    //// 'b'\n+    Nothrow  = (1 << 2),\n+    //// 'c'\n+    Ref      = (1 << 3),\n+    //// 'd'\n+    Property = (1 << 4),\n+    //// 'e'\n+    Trusted  = (1 << 5),\n+    //// 'f'\n+    Safe     = (1 << 6),\n+    //// 'i'\n+    NoGC     = (1 << 7),\n+    //// 'j'\n+    Return   = (1 << 8),\n+    //// 'l'\n+    Scope    = (1 << 9),\n+    //// 'm'\n+    Live     = (1 << 10),\n+\n+    /// Their order matter\n+    ReturnScope   = (1 << 11),\n+    ScopeReturn   = (1 << 12),\n+}\n+\n+// The order in which we process is the same as in compiler/dmd/src/dmangle.d\n+private immutable ManglingFlagInfo[] funcAttrs = [\n+    ManglingFlagInfo(FuncAttributes.Pure,     \"pure\"),\n+    ManglingFlagInfo(FuncAttributes.Nothrow,  \"nothrow\"),\n+    ManglingFlagInfo(FuncAttributes.Ref,      \"ref\"),\n+    ManglingFlagInfo(FuncAttributes.Property, \"@property\"),\n+    ManglingFlagInfo(FuncAttributes.NoGC,     \"@nogc\"),\n+\n+    ManglingFlagInfo(FuncAttributes.ReturnScope, \"return scope\"),\n+    ManglingFlagInfo(FuncAttributes.ScopeReturn, \"scope return\"),\n+\n+    ManglingFlagInfo(FuncAttributes.Return,   \"return\"),\n+    ManglingFlagInfo(FuncAttributes.Scope,    \"scope\"),\n+\n+    ManglingFlagInfo(FuncAttributes.Live,     \"@live\"),\n+    ManglingFlagInfo(FuncAttributes.Trusted,  \"@trusted\"),\n+    ManglingFlagInfo(FuncAttributes.Safe,     \"@safe\"),\n+];\n+\n+private string toStringConsume (immutable ManglingFlagInfo[] infos, ref ushort base)\n+    @safe pure nothrow @nogc\n+{\n+    foreach (const ref info; infos)\n+    {\n+        if ((base & info.flag) == info.flag)\n+        {\n+            base &= ~info.flag;\n+            return info.value;\n+        }\n+    }\n+    return null;\n+}"}, {"sha": "6e3c1fdc3effd8389190f68ed13d13cfe2c31a2f", "filename": "libphobos/libdruntime/core/internal/array/arrayassign.d", "status": "modified", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Farrayassign.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Farrayassign.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Farrayassign.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -302,3 +302,151 @@ Tarr _d_arrayassign_r(Tarr : T[], T)(return scope Tarr to, scope Tarr from) @tru\n     assert(!didThrow);\n     assert(counter == 0);\n }\n+\n+/**\n+ * Sets all elements of an array to a single value. Takes into account postblits,\n+ * copy constructors and destructors. For Plain Old Data elements,`rt/memset.d`\n+ * is used.\n+ *\n+ * ---\n+ * struct S\n+ * {\n+ *     ~this() {} // destructor, so not Plain Old Data\n+ * }\n+ *\n+ * void main()\n+ * {\n+ *   S[3] arr;\n+ *   S value;\n+ *\n+ *   arr = value;\n+ *   // Generates:\n+ *   // _d_arraysetassign(arr[], value), arr;\n+ * }\n+ * ---\n+ *\n+ * Params:\n+ *     to = destination array\n+ *     value = the element to set\n+ * Returns:\n+ *     `to`\n+ */\n+Tarr _d_arraysetassign(Tarr : T[], T)(return scope Tarr to, scope ref T value) @trusted\n+{\n+    import core.internal.traits : Unqual;\n+    import core.lifetime : copyEmplace;\n+    import core.stdc.string : memcpy;\n+\n+    enum elemSize = T.sizeof;\n+    void[elemSize] tmp = void;\n+\n+    foreach (ref dst; to)\n+    {\n+        memcpy(&tmp, cast(void*) &dst, elemSize);\n+        // Use `memcpy` if `T` has a `@disable`d postblit.\n+        static if (__traits(isCopyable, T))\n+            copyEmplace(value, dst);\n+        else\n+            memcpy(cast(void*) &value, cast(void*) &dst, elemSize);\n+        auto elem = cast(Unqual!T*) &tmp;\n+        destroy(*elem);\n+    }\n+\n+    return to;\n+}\n+\n+// postblit and destructor\n+@safe unittest\n+{\n+    string ops;\n+    struct S\n+    {\n+        int val;\n+        this(this) { ops ~= \"=\"; }\n+        ~this() { ops ~= \"~\"; }\n+    }\n+\n+    S[4] arr;\n+    S s = S(1234);\n+    _d_arraysetassign(arr[], s);\n+    assert(ops == \"=~=~=~=~\");\n+    assert(arr == [S(1234), S(1234), S(1234), S(1234)]);\n+}\n+\n+// copy constructor\n+@safe unittest\n+{\n+    string ops;\n+    struct S\n+    {\n+        int val;\n+        this(const scope ref S rhs)\n+        {\n+            val = rhs.val;\n+            ops ~= \"=\";\n+        }\n+        ~this() { ops ~= \"~\"; }\n+    }\n+\n+    S[4] arr;\n+    S s = S(1234);\n+    _d_arraysetassign(arr[], s);\n+    assert(ops == \"=~=~=~=~\");\n+    assert(arr == [S(1234), S(1234), S(1234), S(1234)]);\n+}\n+\n+// throwing and `nothrow`\n+@safe nothrow unittest\n+{\n+    // Test that throwing works\n+    bool didThrow;\n+    int counter;\n+    struct Throw\n+    {\n+        int val;\n+        this(this)\n+        {\n+            counter++;\n+            if (counter == 2)\n+                throw new Exception(\"Oh no.\");\n+        }\n+    }\n+\n+    try\n+    {\n+        Throw[4] a;\n+        Throw b = Throw(1);\n+        _d_arraysetassign(a[], b);\n+    }\n+    catch (Exception)\n+    {\n+        didThrow = true;\n+    }\n+    assert(didThrow);\n+    assert(counter == 2);\n+\n+    // Test that `nothrow` works\n+    didThrow = false;\n+    counter = 0;\n+    struct NoThrow\n+    {\n+        int val;\n+        this(this) { counter++; }\n+    }\n+\n+    try\n+    {\n+        NoThrow[4] a;\n+        NoThrow b = NoThrow(1);\n+        _d_arraysetassign(a[], b);\n+        foreach (ref e; a)\n+            assert(e == NoThrow(1));\n+    }\n+    catch (Exception)\n+    {\n+        didThrow = true;\n+    }\n+    assert(!didThrow);\n+    // The array `a` is destroyed when the `try` block ends.\n+    assert(counter == 4);\n+}"}, {"sha": "dbad0e6064f22e38dcb72db84ec2c4c63f635fa1", "filename": "libphobos/libdruntime/core/internal/dassert.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fdassert.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fdassert.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fdassert.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -518,7 +518,7 @@ private auto assumeFakeAttributes(T)(T t) @trusted\n }\n \n /// Wrapper for `miniFormat` which assumes that the implementation is `@safe`, `@nogc`, ...\n-/// s.t. it does not violate the constraints of the the function containing the `assert`.\n+/// s.t. it does not violate the constraints of the function containing the `assert`.\n private string miniFormatFakeAttributes(T)(const scope ref T t)\n {\n     alias miniT = miniFormat!T;"}, {"sha": "9808b9947f5de3034fe8f8465b9fece73bd4d60d", "filename": "libphobos/libdruntime/core/internal/utf.d", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2Fcore%2Finternal%2Futf.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2Fcore%2Finternal%2Futf.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Futf.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -567,17 +567,22 @@ ubyte codeLength(C)(dchar c)\n \n /***********************************\n Checks to see if string is well formed or not. $(D S) can be an array\n- of $(D char), $(D wchar), or $(D dchar). Throws a $(D UtfException)\n- if it is not. Use to check all untrusted input for correctness.\n+ of $(D char), $(D wchar), or $(D dchar). Returns $(D false) if it is not.\n+ Use to check all untrusted input for correctness.\n  */\n-@safe pure\n-void validate(S)(const scope S s)\n+@safe pure nothrow\n+bool isValidString(S)(const scope S s)\n {\n     auto len = s.length;\n     for (size_t i = 0; i < len; )\n     {\n-        decode(s, i);\n+        try\n+            decode(s, i);\n+        catch (Exception e)\n+            return false;\n     }\n+\n+    return true;\n }\n \n /* =================== Conversion to UTF8 ======================= */\n@@ -626,7 +631,7 @@ char[] toUTF8(return scope char[] buf, dchar c)\n string toUTF8(return scope string s)\n     in\n     {\n-        validate(s);\n+        assert(isValidString(s));\n     }\n     do\n     {\n@@ -787,7 +792,7 @@ wptr toUTF16z(const scope char[] s)\n wstring toUTF16(return scope wstring s)\n     in\n     {\n-        validate(s);\n+        assert(isValidString(s));\n     }\n     do\n     {\n@@ -867,7 +872,7 @@ dstring toUTF32(const scope wchar[] s)\n dstring toUTF32(return scope dstring s)\n     in\n     {\n-        validate(s);\n+        assert(isValidString(s));\n     }\n     do\n     {"}, {"sha": "c2b343a08475dfec4e8c9dc6e9e6ae9b018da135", "filename": "libphobos/libdruntime/core/simd.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2Fcore%2Fsimd.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2Fcore%2Fsimd.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsimd.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -704,7 +704,7 @@ version (D_SIMD)\n                 // store `v` to location pointed to by `d`\n                 storeUnaligned(cast(T*)d, v);\n \n-                // check that the the data was stored correctly\n+                // check that the data was stored correctly\n                 foreach (j; 0..T.sizeof)\n                 {\n                     assert(ptrToV[j] == d[j]);"}, {"sha": "5242ba9d4e21d10858a6dbd826688f3060f045b5", "filename": "libphobos/libdruntime/core/stdc/fenv.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Ffenv.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Ffenv.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Ffenv.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -483,7 +483,7 @@ else version (CRuntime_UClibc)\n \n         alias fexcept_t = ushort;\n     }\n-    else version (MIPS32)\n+    else version (MIPS_Any)\n     {\n         struct fenv_t\n         {"}, {"sha": "2666c952992568c0915d8f1e44eebd89b3753db3", "filename": "libphobos/libdruntime/core/stdc/math.d", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fmath.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fmath.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fmath.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -106,21 +106,14 @@ else version (CRuntime_Bionic)\n }\n else version (CRuntime_UClibc)\n {\n-    version (X86)\n-    {\n-        ///\n-        enum int FP_ILOGB0        = int.min;\n-        ///\n-        enum int FP_ILOGBNAN      = int.min;\n-    }\n-    else version (X86_64)\n+    version (X86_Any)\n     {\n         ///\n         enum int FP_ILOGB0        = int.min;\n         ///\n         enum int FP_ILOGBNAN      = int.min;\n     }\n-    else version (MIPS32)\n+    else version (MIPS_Any)\n     {\n         ///\n         enum int FP_ILOGB0        = -int.max;"}, {"sha": "7713eea97858d7a77933001b90b9d533e4794b6c", "filename": "libphobos/libdruntime/core/sys/darwin/mach/loader.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdarwin%2Fmach%2Floader.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdarwin%2Fmach%2Floader.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdarwin%2Fmach%2Floader.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -1803,7 +1803,7 @@ version (CoreDdoc)\n      * image. The isub_image field is an index into the sub-images\n      * (sub-frameworks and sub-umbrellas list) that made up the two-level image\n      * that the undefined symbol was found in when it was built by the static\n-     * link editor. If isub-image is 0 the the symbol is expected to be defined\n+     * link editor. If isub-image is 0 the symbol is expected to be defined\n      * in library and not in the sub-images. If isub-image is non-zero it is an\n      * index into the array of sub-images for the umbrella with the first index\n      * in the sub-images being 1. The array of sub-images is the ordered list of"}, {"sha": "89dc019cc8f2a82fdb2671bc1f5d95d71a441549", "filename": "libphobos/libdruntime/core/sys/linux/fcntl.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Ffcntl.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Ffcntl.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Ffcntl.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -42,7 +42,7 @@ These cmd values will set locks that conflict with process-associated\n record  locks, but are \"owned\" by the open file description, not the\n process. This means that they are inherited across fork() like BSD (flock)\n locks, and they are only released automatically when the last reference to\n-the the open file against which they were acquired is put.\n+the open file against which they were acquired is put.\n \n */\n enum"}, {"sha": "04a8e8bb8668481656abec8b331b4f5df7cb5304", "filename": "libphobos/libdruntime/core/sys/posix/dlfcn.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fdlfcn.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fdlfcn.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fdlfcn.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -377,7 +377,7 @@ else version (CRuntime_Musl)\n }\n else version (CRuntime_UClibc)\n {\n-    version (X86_64)\n+    version (X86_Any)\n     {\n         enum RTLD_LAZY              = 0x0001;\n         enum RTLD_NOW               = 0x0002;\n@@ -387,7 +387,7 @@ else version (CRuntime_UClibc)\n         enum RTLD_LOCAL             = 0;\n         enum RTLD_NODELETE          = 0x01000;\n     }\n-    else version (MIPS32)\n+    else version (MIPS_Any)\n     {\n         enum RTLD_LAZY              = 0x0001;\n         enum RTLD_NOW               = 0x0002;"}, {"sha": "7085fc4dfa54f99a73f6a139fc269af811e55b98", "filename": "libphobos/libdruntime/core/sys/posix/mqueue.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fmqueue.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fmqueue.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fmqueue.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -147,7 +147,7 @@ int mq_notify (mqd_t mqdes, const(sigevent)* notification);\n \n \n /**\n- * Receive the oldest message with the highest priority the the message queue\n+ * Receive the oldest message with the highest priority the message queue\n  *\n  * Params:\n  *   mqdes      = Message queue descriptor.\n@@ -164,7 +164,7 @@ ssize_t mq_receive (mqd_t mqdes, char* msg_ptr, size_t msg_len, uint* msg_prio);\n \n \n /**\n- * Receive the oldest message with the highest priority the the message queue,\n+ * Receive the oldest message with the highest priority the message queue,\n  * wait up to a certain timeout.\n  *\n  * Params:"}, {"sha": "5a15d82d2ee85bf356de6cd137778cf5161376c3", "filename": "libphobos/libdruntime/core/sys/posix/setjmp.d", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsetjmp.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsetjmp.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsetjmp.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -370,6 +370,22 @@ else version (CRuntime_UClibc)\n                 double[6] __fpregs;\n         }\n     }\n+    else version (MIPS64)\n+    {\n+        struct __jmp_buf\n+        {\n+            long __pc;\n+            long __sp;\n+            long[8] __regs;\n+            long __fp;\n+            long __gp;\n+            int __fpc_csr;\n+            version (MIPS_N64)\n+                double[8] __fpregs;\n+            else\n+                double[6] __fpregs;\n+        }\n+    }\n     else\n         static assert(0, \"unimplemented\");\n "}, {"sha": "df96a3d33715a3c59704cfcd9f4e63e13e30b4ba", "filename": "libphobos/libdruntime/core/sys/posix/stdlib.d", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fstdlib.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1ba11b0b2f873b85dfc7643fe778e974e874b8/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fstdlib.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fstdlib.d?ref=9b1ba11b0b2f873b85dfc7643fe778e974e874b8", "patch": "@@ -95,44 +95,44 @@ int posix_memalign(void**, size_t, size_t);\n \n version (CRuntime_Glibc)\n {\n-    int posix_memalign(void**, size_t, size_t);\n+    int posix_memalign(scope void**, size_t, size_t) pure;\n }\n else version (FreeBSD)\n {\n-    int posix_memalign(void**, size_t, size_t);\n+    int posix_memalign(scope void**, size_t, size_t) pure;\n }\n else version (NetBSD)\n {\n-    int posix_memalign(void**, size_t, size_t);\n+    int posix_memalign(scope void**, size_t, size_t) pure;\n }\n else version (OpenBSD)\n {\n-    int posix_memalign(void**, size_t, size_t);\n+    int posix_memalign(scope void**, size_t, size_t) pure;\n }\n else version (DragonFlyBSD)\n {\n-    int posix_memalign(void**, size_t, size_t);\n+    int posix_memalign(scope void**, size_t, size_t) pure;\n }\n else version (Solaris)\n {\n-    int posix_memalign(void**, size_t, size_t);\n+    int posix_memalign(scope void**, size_t, size_t) pure;\n }\n else version (Darwin)\n {\n-    int posix_memalign(void**, size_t, size_t);\n+    int posix_memalign(scope void**, size_t, size_t) pure;\n }\n else version (CRuntime_Bionic)\n {\n     // Added since Lollipop\n-    int posix_memalign(void**, size_t, size_t);\n+    int posix_memalign(scope void**, size_t, size_t) pure;\n }\n else version (CRuntime_Musl)\n {\n-    int posix_memalign(void**, size_t, size_t);\n+    int posix_memalign(scope void**, size_t, size_t) pure;\n }\n else version (CRuntime_UClibc)\n {\n-    int posix_memalign(void**, size_t, size_t);\n+    int posix_memalign(scope void**, size_t, size_t) pure;\n }\n \n //"}]}