{"sha": "3f15938e00770653b5eccd6834b19e1575498e2d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2YxNTkzOGUwMDc3MDY1M2I1ZWNjZDY4MzRiMTllMTU3NTQ5OGUyZA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-09-12T13:19:38Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-09-12T13:19:38Z"}, "message": "(protect_from_queue): Don't alter an existing MEM.\n\n(convert_modes): Use X's mode (not OLDMODE) unless it is VOIDmode.\n\nFrom-SVN: r5311", "tree": {"sha": "953437d71e19b9cc86dfb0f859b6b2c5bcaad996", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/953437d71e19b9cc86dfb0f859b6b2c5bcaad996"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f15938e00770653b5eccd6834b19e1575498e2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f15938e00770653b5eccd6834b19e1575498e2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f15938e00770653b5eccd6834b19e1575498e2d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f15938e00770653b5eccd6834b19e1575498e2d/comments", "author": null, "committer": null, "parents": [{"sha": "7056f7e8833f8831de61c2ceda5435f7f1ad9fc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7056f7e8833f8831de61c2ceda5435f7f1ad9fc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7056f7e8833f8831de61c2ceda5435f7f1ad9fc0"}], "stats": {"total": 30, "additions": 21, "deletions": 9}, "files": [{"sha": "b640ebcbf2f148c600e5d220fac4e7110d6b6bb2", "filename": "gcc/expr.c", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f15938e00770653b5eccd6834b19e1575498e2d/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f15938e00770653b5eccd6834b19e1575498e2d/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=3f15938e00770653b5eccd6834b19e1575498e2d", "patch": "@@ -378,11 +378,24 @@ protect_from_queue (x, modify)\n       /* Otherwise, recursively protect the subexpressions of all\n \t the kinds of rtx's that can contain a QUEUED.  */\n       if (code == MEM)\n-\tXEXP (x, 0) = protect_from_queue (XEXP (x, 0), 0);\n+\t{\n+\t  rtx tem = protect_from_queue (XEXP (x, 0), 0);\n+\t  if (tem != XEXP (x, 0))\n+\t    {\n+\t      x = copy_rtx (x);\n+\t      XEXP (x, 0) = tem;\n+\t    }\n+\t}\n       else if (code == PLUS || code == MULT)\n \t{\n-\t  XEXP (x, 0) = protect_from_queue (XEXP (x, 0), 0);\n-\t  XEXP (x, 1) = protect_from_queue (XEXP (x, 1), 0);\n+\t  rtx new0 = protect_from_queue (XEXP (x, 0), 0);\n+\t  rtx new1 = protect_from_queue (XEXP (x, 1), 0);\n+\t  if (new0 != XEXP (x, 0) || new1 != XEXP (x, 1))\n+\t    {\n+\t      x = copy_rtx (x);\n+\t      XEXP (x, 0) = new0;\n+\t      XEXP (x, 1) = new1;\n+\t    }\n \t}\n       return x;\n     }\n@@ -1108,12 +1121,8 @@ convert_modes (mode, oldmode, x, unsignedp)\n {\n   register rtx temp;\n \n-  if (GET_MODE (x) != mode)\n+  if (GET_MODE (x) != VOIDmode)\n     oldmode = GET_MODE (x);\n-  /* If X doesnt have a mode, and we didn't specify one, \n-     we have a potential bug, so crash now and get it fixed.  */\n-  if (oldmode == VOIDmode)\n-    abort ();\n  \n   /* If FROM is a SUBREG that indicates that we have already done at least\n      the required extension, strip it.  */\n@@ -7100,7 +7109,10 @@ expand_increment (exp, post)\n   if (post)\n     {\n       /* We have a true reference to the value in OP0.\n-\t If there is an insn to add or subtract in this mode, queue it.  */\n+\t If there is an insn to add or subtract in this mode, queue it.\n+\t Queueing the increment insn avoids the register shuffling\n+\t that often results if we must increment now and first save\n+\t the old value for subsequent use.  */\n \n #if 0  /* Turned off to avoid making extra insn for indexed memref.  */\n       op0 = stabilize (op0);"}]}