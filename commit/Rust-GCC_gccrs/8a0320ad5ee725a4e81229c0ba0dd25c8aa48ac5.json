{"sha": "8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGEwMzIwYWQ1ZWU3MjVhNGU4MTIyOWMwYmEwZGQyNWM4YWE0OGFjNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-06-26T20:11:28Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-06-26T20:11:28Z"}, "message": "[multiple changes]\n\n2012-06-26  Vincent Pucci  <pucci@adacore.com>\n\n\t* exp_ch3.adb (Build_Init_Statements): Don't check the parents\n\tin the Rep Item Chain of the task for aspects Interrupt_Priority,\n\tPriority, CPU and Dispatching_Domain.\n\t* exp_ch9.adb (Expand_N_Task_Type_Declaration): fields _Priority,\n\t_CPU and _Domain are present in the corresponding record type\n\tonly if the task entity has a pragma, attribute definition\n\tclause or aspect specification.\n\t(Make_Initialize_Protection): Don't check the parents in the Rep Item\n\tChain of the task for aspects Interrupt_Priority, Priority, CPU and\n\tDispatching_Domain.\n\t* freeze.adb (Freeze_Entity): Use of Evaluate_Aspects_At_Freeze_Point\n\tcall replaced by Analyze_Aspects_At_Freeze_Point.\n\t* sem_ch13.adb, sem_ch13.ads (Analyze_Aspects_At_Freeze_Point):\n\tRenaming of Evaluate_Aspects_At_Freeze_Point.\n\n2012-06-26  Yannick Moy  <moy@adacore.com>\n\n\t* sem_attr.adb (Analyze_Attribute): Detect if 'Old is used outside a\n\tpostcondition, and issue an error in such a case.\n\n2012-06-26  Yannick Moy  <moy@adacore.com>\n\n\t* gnat_rm.texi: Minor editing.\n\n2012-06-26  Tristan Gingold  <gingold@adacore.com>\n\n\t* raise-gcc.c: Minor cleanup: remove unused prototype.\n\t* seh_init.c: Do not create an image wide unwind info to catch\n\tSEH when SEH unwind info are emitted by the compiler.\n\nFrom-SVN: r188995", "tree": {"sha": "ed5a926eba95d7cf001fb68aa22d178a348f24b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed5a926eba95d7cf001fb68aa22d178a348f24b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5/comments", "author": null, "committer": null, "parents": [{"sha": "59b7e90faf4f995d5b1e32b9734804b1b12917ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59b7e90faf4f995d5b1e32b9734804b1b12917ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59b7e90faf4f995d5b1e32b9734804b1b12917ae"}], "stats": {"total": 840, "additions": 433, "deletions": 407}, "files": [{"sha": "328e18574466f7e4e9de0c8b04ff33746ebf00e7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5", "patch": "@@ -1,3 +1,35 @@\n+2012-06-26  Vincent Pucci  <pucci@adacore.com>\n+\n+\t* exp_ch3.adb (Build_Init_Statements): Don't check the parents\n+\tin the Rep Item Chain of the task for aspects Interrupt_Priority,\n+\tPriority, CPU and Dispatching_Domain.\n+\t* exp_ch9.adb (Expand_N_Task_Type_Declaration): fields _Priority,\n+\t_CPU and _Domain are present in the corresponding record type\n+\tonly if the task entity has a pragma, attribute definition\n+\tclause or aspect specification.\n+\t(Make_Initialize_Protection): Don't check the parents in the Rep Item\n+\tChain of the task for aspects Interrupt_Priority, Priority, CPU and\n+\tDispatching_Domain.\n+\t* freeze.adb (Freeze_Entity): Use of Evaluate_Aspects_At_Freeze_Point\n+\tcall replaced by Analyze_Aspects_At_Freeze_Point.\n+\t* sem_ch13.adb, sem_ch13.ads (Analyze_Aspects_At_Freeze_Point):\n+\tRenaming of Evaluate_Aspects_At_Freeze_Point.\n+\n+2012-06-26  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_attr.adb (Analyze_Attribute): Detect if 'Old is used outside a\n+\tpostcondition, and issue an error in such a case.\n+\n+2012-06-26  Yannick Moy  <moy@adacore.com>\n+\n+\t* gnat_rm.texi: Minor editing.\n+\n+2012-06-26  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* raise-gcc.c: Minor cleanup: remove unused prototype.\n+\t* seh_init.c: Do not create an image wide unwind info to catch\n+\tSEH when SEH unwind info are emitted by the compiler.\n+\n 2012-06-19  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* gcc-interface/trans.c: Include target.h."}, {"sha": "7f7aa6f6bb798e0aca4887f77a73c032c120e0cb", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5", "patch": "@@ -2668,7 +2668,9 @@ package body Exp_Ch3 is\n \n                      Ritem :=\n                        Get_Rep_Item\n-                         (Corresponding_Concurrent_Type (Scope (Id)), Nam);\n+                         (Corresponding_Concurrent_Type (Scope (Id)),\n+                          Nam,\n+                          Check_Parents => False);\n \n                      if Present (Ritem) then\n "}, {"sha": "620efc96ad7ce25156cc9e6f84cc8d7c338152c5", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 60, "deletions": 41, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5", "patch": "@@ -11270,30 +11270,36 @@ package body Exp_Ch9 is\n    --  in the pragma, and is used to override the task stack size otherwise\n    --  associated with the task type.\n \n-   --  The _Priority field is always present. It will be filled at the freeze\n-   --  point, when the record init proc is built, to capture the expression of\n-   --  a Priority pragma, attribute definition clause or aspect specification\n-   --  (see Build_Record_Init_Proc in Exp_Ch3).\n+   --  The _Priority field is present only if the task entity has a Priority or\n+   --  Interrupt_Priority rep item (pragma, aspect specification or attribute\n+   --  definition clause). It will be filled at the freeze point, when the\n+   --  record init proc is built, to capture the expression of the rep item\n+   --  (see Build_Record_Init_Proc in Exp_Ch3). Note that it cannot be filled\n+   --  here since aspect evaluations are delayed till the freeze point.\n \n    --  The _Task_Info field is present only if a Task_Info pragma appears in\n    --  the task definition. The expression captures the argument that was\n    --  present in the pragma, and is used to provide the Task_Image parameter\n    --  to the call to Create_Task.\n \n-   --  The _CPU field is always present. It will be filled at the freeze point,\n-   --  when the record init proc is built, to capture the expression of a CPU\n-   --  pragma, attribute definition clause or aspect specification (see\n-   --  Build_Record_Init_Proc in Exp_Ch3).\n+   --  The _CPU field is present only if the task entity has a CPU rep item\n+   --  (pragma, aspect specification or attribute definition clause). It will\n+   --  be filled at the freeze point, when the record init proc is built, to\n+   --  capture the expression of the rep item (see Build_Record_Init_Proc in\n+   --  Exp_Ch3). Note that it cannot be filled here since aspect evaluations\n+   --  are delayed till the freeze point.\n \n    --  The _Relative_Deadline field is present only if a Relative_Deadline\n    --  pragma appears in the task definition. The expression captures the\n    --  argument that was present in the pragma, and is used to provide the\n    --  Relative_Deadline parameter to the call to Create_Task.\n \n-   --  The _Domain field is always present. It will be filled at the freeze\n-   --  point, when the record init proc is built, to capture the expression of\n-   --  a Dispatching_Domain pragma, attribute definition clause or aspect\n-   --  specification (see Build_Record_Init_Proc in Exp_Ch3).\n+   --  The _Domain field is present only if the task entity has a\n+   --  Dispatching_Domain rep item (pragma, aspect specification or attribute\n+   --  definition clause). It will be filled at the freeze point, when the\n+   --  record init proc is built, to capture the expression of the rep item\n+   --  (see Build_Record_Init_Proc in Exp_Ch3). Note that it cannot be filled\n+   --  here since aspect evaluations are delayed till the freeze point.\n \n    --  When a task is declared, an instance of the task value record is\n    --  created. The elaboration of this declaration creates the correct bounds\n@@ -11566,17 +11572,20 @@ package body Exp_Ch9 is\n \n       Collect_Entry_Families (Loc, Cdecls, Size_Decl, Tasktyp);\n \n-      --  Add the _Priority component with no expression\n+      --  Add the _Priority component if a Interrupt_Priority or Priority rep\n+      --  item is present.\n \n-      Append_To (Cdecls,\n-        Make_Component_Declaration (Loc,\n-          Defining_Identifier  =>\n-            Make_Defining_Identifier (Loc, Name_uPriority),\n-          Component_Definition =>\n-            Make_Component_Definition (Loc,\n-              Aliased_Present    => False,\n-              Subtype_Indication =>\n-                New_Reference_To (Standard_Integer, Loc))));\n+      if Has_Rep_Item (TaskId, Name_Priority, Check_Parents => False) then\n+         Append_To (Cdecls,\n+           Make_Component_Declaration (Loc,\n+             Defining_Identifier  =>\n+               Make_Defining_Identifier (Loc, Name_uPriority),\n+             Component_Definition =>\n+               Make_Component_Definition (Loc,\n+                 Aliased_Present    => False,\n+                 Subtype_Indication =>\n+                   New_Reference_To (Standard_Integer, Loc))));\n+      end if;\n \n       --  Add the _Size component if a Storage_Size pragma is present\n \n@@ -11623,18 +11632,20 @@ package body Exp_Ch9 is\n                      (TaskId, Name_Task_Info, Check_Parents => False)))))));\n       end if;\n \n-      --  Add the _CPU component with no expression\n+      --  Add the _CPU component if a CPU rep item is present\n \n-      Append_To (Cdecls,\n-        Make_Component_Declaration (Loc,\n-          Defining_Identifier =>\n-            Make_Defining_Identifier (Loc, Name_uCPU),\n+      if Has_Rep_Item (TaskId, Name_CPU, Check_Parents => False) then\n+         Append_To (Cdecls,\n+           Make_Component_Declaration (Loc,\n+             Defining_Identifier =>\n+               Make_Defining_Identifier (Loc, Name_uCPU),\n \n-          Component_Definition =>\n-            Make_Component_Definition (Loc,\n-              Aliased_Present    => False,\n-              Subtype_Indication =>\n-                New_Reference_To (RTE (RE_CPU_Range), Loc))));\n+             Component_Definition =>\n+               Make_Component_Definition (Loc,\n+                 Aliased_Present    => False,\n+                 Subtype_Indication =>\n+                   New_Reference_To (RTE (RE_CPU_Range), Loc))));\n+      end if;\n \n       --  Add the _Relative_Deadline component if a Relative_Deadline pragma is\n       --  present. If we are using a restricted run time this component will\n@@ -11663,11 +11674,16 @@ package body Exp_Ch9 is\n                        Get_Relative_Deadline_Pragma (Taskdef))))))));\n       end if;\n \n-      --  Add the _Dispatching_Domain component with no expression. If we are\n-      --  using a restricted run time this component will not be added\n-      --  (dispatching domains are not allowed by the Ravenscar profile).\n+      --  Add the _Dispatching_Domain component if a Dispatching_Domain rep\n+      --  item is present. If we are using a restricted run time this component\n+      --  will not be added (dispatching domains are not allowed by the\n+      --  Ravenscar profile).\n \n-      if not Restricted_Profile then\n+      if not Restricted_Profile\n+        and then\n+          Has_Rep_Item\n+            (TaskId, Name_Dispatching_Domain, Check_Parents => False)\n+      then\n          Append_To (Cdecls,\n            Make_Component_Declaration (Loc,\n              Defining_Identifier  =>\n@@ -13344,10 +13360,11 @@ package body Exp_Ch9 is\n          --  Interrupt_Priority'Last, an implementation-defined value, see\n          --  (RM D.3(10)).\n \n-         if Has_Rep_Item (Ptyp, Name_Priority) then\n+         if Has_Rep_Item (Ptyp, Name_Priority, Check_Parents => False) then\n             declare\n                Prio_Clause : constant Node_Id :=\n-                               Get_Rep_Item (Ptyp, Name_Priority);\n+                               Get_Rep_Item\n+                                 (Ptyp, Name_Priority, Check_Parents => False);\n \n                Prio : Node_Id;\n                Temp : Entity_Id;\n@@ -13670,7 +13687,7 @@ package body Exp_Ch9 is\n       --  Priority parameter. Set to Unspecified_Priority unless there is a\n       --  Priority rep item, in which case we take the value from the rep item.\n \n-      if Has_Rep_Item (Ttyp, Name_Priority) then\n+      if Has_Rep_Item (Ttyp, Name_Priority, Check_Parents => False) then\n          Append_To (Args,\n            Make_Selected_Component (Loc,\n              Prefix        => Make_Identifier (Loc, Name_uInit),\n@@ -13741,7 +13758,7 @@ package body Exp_Ch9 is\n       --  passed as an Integer because in the case of unspecified CPU the\n       --  value is not in the range of CPU_Range.\n \n-      if Has_Rep_Item (Ttyp, Name_CPU) then\n+      if Has_Rep_Item (Ttyp, Name_CPU, Check_Parents => False) then\n          Append_To (Args,\n            Convert_To (Standard_Integer,\n              Make_Selected_Component (Loc,\n@@ -13790,7 +13807,9 @@ package body Exp_Ch9 is\n \n          --  Case where Dispatching_Domain rep item applies: use given value\n \n-         if Has_Rep_Item (Ttyp, Name_Dispatching_Domain) then\n+         if Has_Rep_Item\n+              (Ttyp, Name_Dispatching_Domain, Check_Parents => False)\n+         then\n             Append_To (Args,\n               Make_Selected_Component (Loc,\n                 Prefix        =>"}, {"sha": "5464462a22936978f024151f47c18ac367cd5822", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5", "patch": "@@ -2525,14 +2525,14 @@ package body Freeze is\n       end if;\n \n       --  Deal with delayed aspect specifications. The analysis of the\n-      --  aspect is required to be delayed to the freeze point, so we\n-      --  evaluate the pragma or attribute definition clause in the tree at\n+      --  aspect is required to be delayed to the freeze point, thus we\n+      --  analyze the pragma or attribute definition clause in the tree at\n       --  this point. We also analyze the aspect specification node at the\n       --  freeze point when the aspect doesn't correspond to\n       --  pragma/attribute definition clause.\n \n       if Has_Delayed_Aspects (E) then\n-         Evaluate_Aspects_At_Freeze_Point (E);\n+         Analyze_Aspects_At_Freeze_Point (E);\n       end if;\n \n       --  Here to freeze the entity"}, {"sha": "3b05e4779a0ab1a77c19669c052dd89961168c5c", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5", "patch": "@@ -265,7 +265,6 @@ Implementation Defined Attributes\n * Mechanism_Code::\n * Null_Parameter::\n * Object_Size::\n-* Old::\n * Passed_By_Reference::\n * Pool_Address::\n * Range_Length::\n@@ -6016,7 +6015,6 @@ consideration, you should minimize the use of these attributes.\n * Mechanism_Code::\n * Null_Parameter::\n * Object_Size::\n-* Old::\n * Passed_By_Reference::\n * Pool_Address::\n * Range_Length::\n@@ -6627,53 +6625,6 @@ alignment will be 4, because of the\n integer field, and so the default size of record objects for this type\n will be 64 (8 bytes).\n \n-@node Old\n-@unnumberedsec Old\n-@cindex Capturing Old values\n-@cindex Postconditions\n-@noindent\n-The attribute Prefix'Old can be used within a\n-subprogram body or within a precondition or\n-postcondition pragma. The effect is to\n-refer to the value of the prefix on entry. So for\n-example if you have an argument of a record type X called Arg1,\n-you can refer to Arg1.Field'Old which yields the value of\n-Arg1.Field on entry. The implementation simply involves generating\n-an object declaration which captures the value on entry.\n-The prefix must denote an object of a nonlimited type (since limited types\n-cannot be copied to capture their values) and it must not reference a local\n-variable (since local variables do not exist at subprogram entry time). Note\n-that the variable introduced by a quantified expression is a local variable.\n-The following example shows the use of 'Old to implement\n-a test of a postcondition:\n-\n-@smallexample @c ada\n-with Old_Pkg;\n-procedure Old is\n-begin\n-   Old_Pkg.Incr;\n-end Old;\n-\n-package Old_Pkg is\n-   procedure Incr;\n-end Old_Pkg;\n-\n-package body Old_Pkg is\n-   Count : Natural := 0;\n-\n-   procedure Incr is\n-   begin\n-      ... code manipulating the value of Count\n-\n-      pragma Assert (Count = Count'Old + 1);\n-   end Incr;\n-end Old_Pkg;\n-@end smallexample\n-\n-@noindent\n-Note that it is allowed to apply 'Old to a constant entity, but this will\n-result in a warning, since the old and new values will always be the same.\n-\n @node Passed_By_Reference\n @unnumberedsec Passed_By_Reference\n @cindex Parameters, when passed by reference"}, {"sha": "74983ae093e11cea13bb02555c55a7c69de95aa2", "filename": "gcc/ada/raise-gcc.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5/gcc%2Fada%2Fraise-gcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5/gcc%2Fada%2Fraise-gcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise-gcc.c?ref=8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5", "patch": "@@ -439,9 +439,9 @@ db_phases (int phases)\n      |\n      +--> __gnat_personality_v0 (context, exception)\n \t   |\n-\t   +--> get_region_descriptor_for (context)\n+\t   +--> get_region_description_for (context)\n \t   |\n-\t   +--> get_action_descriptor_for (context, exception, region)\n+\t   +--> get_action_description_for (context, exception, region)\n \t   |       |\n \t   |       +--> get_call_site_action_for (context, region)\n \t   |            (one version for each underlying scheme)\n@@ -1019,7 +1019,6 @@ setup_to_install (_Unwind_Context *uw_context,\n    automatic backtraces upon exception raise, as provided through the\n    GNAT.Traceback facilities.  */\n extern void __gnat_notify_handled_exception (void);\n-extern void __gnat_notify_unhandled_exception (void);\n \n /* Below is the eh personality routine per se. We currently assume that only\n    GNU-Ada exceptions are met.  */"}, {"sha": "fa5310ffe710af20ca0e59cecd9a7898fecf35df", "filename": "gcc/ada/seh_init.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5/gcc%2Fada%2Fseh_init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5/gcc%2Fada%2Fseh_init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fseh_init.c?ref=8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *           Copyright (C) 2005-2011, Free Software Foundation, Inc.        *\n+ *           Copyright (C) 2005-2012, Free Software Foundation, Inc.        *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -219,6 +219,9 @@ __gnat_SEH_error_handler (struct _EXCEPTION_RECORD* ExceptionRecord,\n     the loaded DLL (for example it results in unexpected behaviors in the\n     Win32 subsystem.  */\n \n+#ifndef __SEH__\n+  /* Don't use this trick when SEH are emitted by gcc, as it will conflict with\n+     them.  */\n asm\n (\n  \" .section .rdata, \\\"dr\\\"\\n\"\n@@ -238,6 +241,7 @@ asm\n  \"\\n\"\n  \" .text\\n\"\n );\n+#endif /* __SEH__ */\n \n void __gnat_install_SEH_handler (void *eh ATTRIBUTE_UNUSED)\n {"}, {"sha": "a5d7bee32120f30555a4cdba00e591b2c500492a", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 104, "deletions": 85, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5", "patch": "@@ -3905,10 +3905,95 @@ package body Sem_Attr is\n       -- Old --\n       ---------\n \n-      when Attribute_Old =>\n+      when Attribute_Old => Old : declare\n+         CS : Entity_Id;\n+         --  The enclosing scope, excluding loops for quantified expressions.\n+         --  During analysis, it is the postcondition subprogram. During\n+         --  pre-analysis, it is the scope of the subprogram declaration.\n+\n+         Prag : Node_Id;\n+         --  During pre-analysis, Prag is the enclosing pragma node if any\n+\n+      begin\n+         --  Find enclosing scopes, excluding loops\n+\n+         CS := Current_Scope;\n+         while Ekind (CS) = E_Loop loop\n+            CS := Scope (CS);\n+         end loop;\n \n-         --  The attribute reference is a primary. If expressions follow, the\n-         --  attribute reference is an indexable object, so rewrite the node\n+         --  If we are in Spec_Expression mode, this should be the prescan of\n+         --  the postcondition (or contract case, or test case) pragma.\n+\n+         if In_Spec_Expression then\n+\n+            --  Check in postcondition or Ensures clause\n+\n+            Prag := N;\n+            while not Nkind_In (Prag, N_Pragma,\n+                                N_Function_Specification,\n+                                N_Procedure_Specification,\n+                                N_Subprogram_Body)\n+            loop\n+               Prag := Parent (Prag);\n+            end loop;\n+\n+            if Nkind (Prag) /= N_Pragma then\n+               Error_Attr (\"% attribute can only appear in postcondition\", P);\n+\n+            elsif Get_Pragma_Id (Prag) = Pragma_Contract_Case\n+                    or else\n+                  Get_Pragma_Id (Prag) = Pragma_Test_Case\n+            then\n+               declare\n+                  Arg_Ens : constant Node_Id :=\n+                              Get_Ensures_From_CTC_Pragma (Prag);\n+                  Arg     : Node_Id;\n+\n+               begin\n+                  Arg := N;\n+                  while Arg /= Prag and Arg /= Arg_Ens loop\n+                     Arg := Parent (Arg);\n+                  end loop;\n+\n+                  if Arg /= Arg_Ens then\n+                     if Get_Pragma_Id (Prag) = Pragma_Contract_Case then\n+                        Error_Attr\n+                          (\"% attribute misplaced inside contract case\", P);\n+                     else\n+                        Error_Attr\n+                          (\"% attribute misplaced inside test case\", P);\n+                     end if;\n+                  end if;\n+               end;\n+\n+            elsif Get_Pragma_Id (Prag) /= Pragma_Postcondition then\n+               Error_Attr (\"% attribute can only appear in postcondition\", P);\n+            end if;\n+\n+         --  Body case, where we must be inside a generated _Postcondition\n+         --  procedure, or else the attribute use is definitely misplaced. The\n+         --  postcondition itself may have generated transient scopes, and is\n+         --  not necessarily the current one.\n+\n+         else\n+            while Present (CS) and then CS /= Standard_Standard loop\n+               if Chars (CS) = Name_uPostconditions then\n+                  exit;\n+               else\n+                  CS := Scope (CS);\n+               end if;\n+            end loop;\n+\n+            if Chars (CS) /= Name_uPostconditions then\n+               Error_Attr (\"% attribute can only appear in postcondition\", P);\n+            end if;\n+         end if;\n+\n+         --  Either the attribute reference is generated for a Requires\n+         --  clause, in which case no expressions follow, or it is a\n+         --  primary. In that case, if expressions follow, the attribute\n+         --  reference is an indexable object, so rewrite the node\n          --  accordingly.\n \n          if Present (E1) then\n@@ -3926,17 +4011,13 @@ package body Sem_Attr is\n \n          Check_E0;\n \n-         --  Prefix has not been analyzed yet, and its full analysis will take\n-         --  place during expansion (see below).\n+         --  Prefix has not been analyzed yet, and its full analysis will\n+         --  take place during expansion (see below).\n \n          Preanalyze_And_Resolve (P);\n          P_Type := Etype (P);\n          Set_Etype (N, P_Type);\n \n-         if No (Current_Subprogram) then\n-            Error_Attr (\"attribute % can only appear within subprogram\", N);\n-         end if;\n-\n          if Is_Limited_Type (P_Type) then\n             Error_Attr (\"attribute % cannot apply to limited objects\", P);\n          end if;\n@@ -3948,77 +4029,14 @@ package body Sem_Attr is\n               (\"?attribute Old applied to constant has no effect\", P);\n          end if;\n \n-         --  Check that the expression does not refer to local entities\n-\n-         Check_Local : declare\n-            Subp : Entity_Id := Current_Subprogram;\n-\n-            function Process (N : Node_Id) return Traverse_Result;\n-            --  Check that N does not contain references to local variables or\n-            --  other local entities of Subp.\n-\n-            -------------\n-            -- Process --\n-            -------------\n-\n-            function Process (N : Node_Id) return Traverse_Result is\n-            begin\n-               if Is_Entity_Name (N)\n-                 and then Present (Entity (N))\n-                 and then not Is_Formal (Entity (N))\n-                 and then Enclosing_Subprogram (Entity (N)) = Subp\n-               then\n-                  Error_Msg_Node_1 := Entity (N);\n-                  Error_Attr\n-                    (\"attribute % cannot refer to local variable&\", N);\n-               end if;\n-\n-               return OK;\n-            end Process;\n-\n-            procedure Check_No_Local is new Traverse_Proc;\n-\n-         --  Start of processing for Check_Local\n-\n-         begin\n-            Check_No_Local (P);\n-\n-            if In_Parameter_Specification (P) then\n-\n-               --  We have additional restrictions on using 'Old in parameter\n-               --  specifications.\n-\n-               if Present (Enclosing_Subprogram (Current_Subprogram)) then\n-\n-                  --  Check that there is no reference to the enclosing\n-                  --  subprogram local variables. Otherwise, we might end up\n-                  --  being called from the enclosing subprogram and thus using\n-                  --  'Old on a local variable which is not defined at entry\n-                  --  time.\n-\n-                  Subp := Enclosing_Subprogram (Current_Subprogram);\n-                  Check_No_Local (P);\n-\n-               else\n-                  --  We must prevent default expression of library-level\n-                  --  subprogram from using 'Old, as the subprogram may be\n-                  --  used in elaboration code for which there is no enclosing\n-                  --  subprogram.\n-\n-                  Error_Attr\n-                    (\"attribute % can only appear within subprogram\", N);\n-               end if;\n-            end if;\n-         end Check_Local;\n-\n          --  The attribute appears within a pre/postcondition, but refers to\n-         --  an entity in the enclosing subprogram. If it is a component of a\n-         --  formal its expansion might generate actual subtypes that may be\n-         --  referenced in an inner context, and which must be elaborated\n-         --  within the subprogram itself. As a result we create a declaration\n-         --  for it and insert it at the start of the enclosing subprogram\n-         --  This is properly an expansion activity but it has to be performed\n-         --  now to prevent out-of-order issues.\n+         --  an entity in the enclosing subprogram. If it is a component of\n+         --  a formal its expansion might generate actual subtypes that may\n+         --  be referenced in an inner context, and which must be elaborated\n+         --  within the subprogram itself. As a result we create a\n+         --  declaration for it and insert it at the start of the enclosing\n+         --  subprogram. This is properly an expansion activity but it has\n+         --  to be performed now to prevent out-of-order issues.\n \n          if Nkind (P) = N_Selected_Component\n            and then Has_Discriminants (Etype (Prefix (P)))\n@@ -4028,6 +4046,7 @@ package body Sem_Attr is\n             Set_Etype (P, P_Type);\n             Expand (N);\n          end if;\n+      end Old;\n \n       ----------------------\n       -- Overlaps_Storage --\n@@ -4261,9 +4280,9 @@ package body Sem_Attr is\n          end if;\n \n          --  If we are in the scope of a function and in Spec_Expression mode,\n-         --  this is likely the prescan of the postcondition pragma, and we\n-         --  just set the proper type. If there is an error it will be caught\n-         --  when the real Analyze call is done.\n+         --  this is likely the prescan of the postcondition (or contract case,\n+         --  or test case) pragma, and we just set the proper type. If there is\n+         --  an error it will be caught when the real Analyze call is done.\n \n          if Ekind (CS) = E_Function\n            and then In_Spec_Expression\n@@ -4278,7 +4297,7 @@ package body Sem_Attr is\n                Error_Attr;\n             end if;\n \n-            --  Check in postcondition of function\n+            --  Check in postcondition or Ensures clause of function\n \n             Prag := N;\n             while not Nkind_In (Prag, N_Pragma,\n@@ -4352,8 +4371,8 @@ package body Sem_Attr is\n             end if;\n \n          --  Body case, where we must be inside a generated _Postcondition\n-         --  procedure, and the prefix must be on the scope stack, or else\n-         --  the attribute use is definitely misplaced. The condition itself\n+         --  procedure, and the prefix must be on the scope stack, or else the\n+         --  attribute use is definitely misplaced. The postcondition itself\n          --  may have generated transient scopes, and is not necessarily the\n          --  current one.\n "}, {"sha": "e177f930f6b3588c7a3d4d53ce8824d66a502184", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 221, "deletions": 221, "changes": 442, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5", "patch": "@@ -682,6 +682,227 @@ package body Sem_Ch13 is\n       end if;\n    end Alignment_Check_For_Size_Change;\n \n+   -------------------------------------\n+   -- Analyze_Aspects_At_Freeze_Point --\n+   -------------------------------------\n+\n+   procedure Analyze_Aspects_At_Freeze_Point (E : Entity_Id) is\n+      ASN   : Node_Id;\n+      A_Id  : Aspect_Id;\n+      Ritem : Node_Id;\n+\n+      procedure Analyze_Aspect_Default_Value (ASN : Node_Id);\n+      --  This routine analyzes an Aspect_Default_[Component_]Value denoted by\n+      --  the aspect specification node ASN.\n+\n+      procedure Make_Pragma_From_Boolean_Aspect (ASN : Node_Id);\n+      --  Given an aspect specification node ASN whose expression is an\n+      --  optional Boolean, this routines creates the corresponding pragma\n+      --  at the freezing point.\n+\n+      ----------------------------------\n+      -- Analyze_Aspect_Default_Value --\n+      ----------------------------------\n+\n+      procedure Analyze_Aspect_Default_Value (ASN : Node_Id) is\n+         Ent  : constant Entity_Id := Entity (ASN);\n+         Expr : constant Node_Id   := Expression (ASN);\n+         Id   : constant Node_Id   := Identifier (ASN);\n+\n+      begin\n+         Error_Msg_Name_1 := Chars (Id);\n+\n+         if not Is_Type (Ent) then\n+            Error_Msg_N (\"aspect% can only apply to a type\", Id);\n+            return;\n+\n+         elsif not Is_First_Subtype (Ent) then\n+            Error_Msg_N (\"aspect% cannot apply to subtype\", Id);\n+            return;\n+\n+         elsif A_Id = Aspect_Default_Value\n+           and then not Is_Scalar_Type (Ent)\n+         then\n+            Error_Msg_N (\"aspect% can only be applied to scalar type\", Id);\n+            return;\n+\n+         elsif A_Id = Aspect_Default_Component_Value then\n+            if not Is_Array_Type (Ent) then\n+               Error_Msg_N (\"aspect% can only be applied to array type\", Id);\n+               return;\n+\n+            elsif not Is_Scalar_Type (Component_Type (Ent)) then\n+               Error_Msg_N (\"aspect% requires scalar components\", Id);\n+               return;\n+            end if;\n+         end if;\n+\n+         Set_Has_Default_Aspect (Base_Type (Ent));\n+\n+         if Is_Scalar_Type (Ent) then\n+            Set_Default_Aspect_Value (Ent, Expr);\n+         else\n+            Set_Default_Aspect_Component_Value (Ent, Expr);\n+         end if;\n+      end Analyze_Aspect_Default_Value;\n+\n+      -------------------------------------\n+      -- Make_Pragma_From_Boolean_Aspect --\n+      -------------------------------------\n+\n+      procedure Make_Pragma_From_Boolean_Aspect (ASN : Node_Id) is\n+         Ident  : constant Node_Id    := Identifier (ASN);\n+         A_Name : constant Name_Id    := Chars (Ident);\n+         A_Id   : constant Aspect_Id  := Get_Aspect_Id (A_Name);\n+         Ent    : constant Entity_Id  := Entity (ASN);\n+         Expr   : constant Node_Id    := Expression (ASN);\n+         Loc    : constant Source_Ptr := Sloc (ASN);\n+\n+         Prag : Node_Id;\n+\n+         procedure Check_False_Aspect_For_Derived_Type;\n+         --  This procedure checks for the case of a false aspect for a derived\n+         --  type, which improperly tries to cancel an aspect inherited from\n+         --  the parent.\n+\n+         -----------------------------------------\n+         -- Check_False_Aspect_For_Derived_Type --\n+         -----------------------------------------\n+\n+         procedure Check_False_Aspect_For_Derived_Type is\n+            Par : Node_Id;\n+\n+         begin\n+            --  We are only checking derived types\n+\n+            if not Is_Derived_Type (E) then\n+               return;\n+            end if;\n+\n+            Par := Nearest_Ancestor (E);\n+\n+            case A_Id is\n+               when Aspect_Atomic | Aspect_Shared =>\n+                  if not Is_Atomic (Par) then\n+                     return;\n+                  end if;\n+\n+               when Aspect_Atomic_Components =>\n+                  if not Has_Atomic_Components (Par) then\n+                     return;\n+                  end if;\n+\n+               when Aspect_Discard_Names =>\n+                  if not Discard_Names (Par) then\n+                     return;\n+                  end if;\n+\n+               when Aspect_Pack =>\n+                  if not Is_Packed (Par) then\n+                     return;\n+                  end if;\n+\n+               when Aspect_Unchecked_Union =>\n+                  if not Is_Unchecked_Union (Par) then\n+                     return;\n+                  end if;\n+\n+               when Aspect_Volatile =>\n+                  if not Is_Volatile (Par) then\n+                     return;\n+                  end if;\n+\n+               when Aspect_Volatile_Components =>\n+                  if not Has_Volatile_Components (Par) then\n+                     return;\n+                  end if;\n+\n+               when others =>\n+                  return;\n+            end case;\n+\n+            --  Fall through means we are canceling an inherited aspect\n+\n+            Error_Msg_Name_1 := A_Name;\n+            Error_Msg_NE (\"derived type& inherits aspect%, cannot cancel\",\n+                          Expr,\n+                          E);\n+\n+         end Check_False_Aspect_For_Derived_Type;\n+\n+      --  Start of processing for Make_Pragma_From_Boolean_Aspect\n+\n+      begin\n+         if Is_False (Static_Boolean (Expr)) then\n+            Check_False_Aspect_For_Derived_Type;\n+\n+         else\n+            Prag :=\n+              Make_Pragma (Loc,\n+                Pragma_Argument_Associations => New_List (\n+                  New_Occurrence_Of (Ent, Sloc (Ident))),\n+                Pragma_Identifier            =>\n+                  Make_Identifier (Sloc (Ident), Chars (Ident)));\n+\n+            Set_From_Aspect_Specification (Prag, True);\n+            Set_Corresponding_Aspect (Prag, ASN);\n+            Set_Aspect_Rep_Item (ASN, Prag);\n+            Set_Is_Delayed_Aspect (Prag);\n+            Set_Parent (Prag, ASN);\n+         end if;\n+\n+      end Make_Pragma_From_Boolean_Aspect;\n+\n+   --  Start of processing for Analyze_Aspects_At_Freeze_Point\n+\n+   begin\n+      --  Must be declared in current scope. This is need for a generic\n+      --  context.\n+\n+      if Scope (E) /= Current_Scope then\n+         return;\n+      end if;\n+\n+      --  Look for aspect specification entries for this entity\n+\n+      ASN := First_Rep_Item (E);\n+\n+      while Present (ASN) loop\n+         if Nkind (ASN) = N_Aspect_Specification\n+           and then Entity (ASN) = E\n+           and then Is_Delayed_Aspect (ASN)\n+         then\n+            A_Id := Get_Aspect_Id (Chars (Identifier (ASN)));\n+\n+            case A_Id is\n+               --  For aspects whose expression is an optional Boolean, make\n+               --  the corresponding pragma at the freezing point.\n+\n+               when Boolean_Aspects      |\n+                    Library_Unit_Aspects =>\n+                  Make_Pragma_From_Boolean_Aspect (ASN);\n+\n+               --  Special handling for aspects that don't correspond to\n+               --  pragmas/attributes.\n+\n+               when Aspect_Default_Value           |\n+                    Aspect_Default_Component_Value =>\n+                  Analyze_Aspect_Default_Value (ASN);\n+\n+               when others => null;\n+            end case;\n+\n+            Ritem := Aspect_Rep_Item (ASN);\n+\n+            if Present (Ritem) then\n+               Analyze (Ritem);\n+            end if;\n+         end if;\n+\n+         Next_Rep_Item (ASN);\n+      end loop;\n+   end Analyze_Aspects_At_Freeze_Point;\n+\n    -----------------------------------\n    -- Analyze_Aspect_Specifications --\n    -----------------------------------\n@@ -1199,7 +1420,6 @@ package body Sem_Ch13 is\n                   --  declaration. We do not have to worry about delay issues\n                   --  since the pragma processing takes care of this.\n \n-                  Set_Is_Delayed_Aspect (Aspect);\n                   Delay_Required := False;\n \n                --  Case 3 : Aspects that don't correspond to pragma/attribute\n@@ -7602,226 +7822,6 @@ package body Sem_Ch13 is\n       end if;\n    end Check_Size;\n \n-   --------------------------------------\n-   -- Evaluate_Aspects_At_Freeze_Point --\n-   --------------------------------------\n-\n-   procedure Evaluate_Aspects_At_Freeze_Point (E : Entity_Id) is\n-      ASN   : Node_Id;\n-      A_Id  : Aspect_Id;\n-      Ritem : Node_Id;\n-\n-      procedure Analyze_Aspect_Default_Value (ASN : Node_Id);\n-      --  This routine analyzes an Aspect_Default_[Component_]Value denoted by\n-      --  the aspect specification node ASN.\n-\n-      procedure Make_Pragma_From_Boolean_Aspect (ASN : Node_Id);\n-      --  Given an aspect specification node ASN whose expression is an\n-      --  optional Boolean, this routines creates the corresponding pragma\n-      --  at the freezing point.\n-\n-      ----------------------------------\n-      -- Analyze_Aspect_Default_Value --\n-      ----------------------------------\n-\n-      procedure Analyze_Aspect_Default_Value (ASN : Node_Id) is\n-         Ent  : constant Entity_Id := Entity (ASN);\n-         Expr : constant Node_Id   := Expression (ASN);\n-         Id   : constant Node_Id   := Identifier (ASN);\n-\n-      begin\n-         Error_Msg_Name_1 := Chars (Id);\n-\n-         if not Is_Type (Ent) then\n-            Error_Msg_N (\"aspect% can only apply to a type\", Id);\n-            return;\n-\n-         elsif not Is_First_Subtype (Ent) then\n-            Error_Msg_N (\"aspect% cannot apply to subtype\", Id);\n-            return;\n-\n-         elsif A_Id = Aspect_Default_Value\n-           and then not Is_Scalar_Type (Ent)\n-         then\n-            Error_Msg_N (\"aspect% can only be applied to scalar type\", Id);\n-            return;\n-\n-         elsif A_Id = Aspect_Default_Component_Value then\n-            if not Is_Array_Type (Ent) then\n-               Error_Msg_N (\"aspect% can only be applied to array type\", Id);\n-               return;\n-\n-            elsif not Is_Scalar_Type (Component_Type (Ent)) then\n-               Error_Msg_N (\"aspect% requires scalar components\", Id);\n-               return;\n-            end if;\n-         end if;\n-\n-         Set_Has_Default_Aspect (Base_Type (Ent));\n-\n-         if Is_Scalar_Type (Ent) then\n-            Set_Default_Aspect_Value (Ent, Expr);\n-         else\n-            Set_Default_Aspect_Component_Value (Ent, Expr);\n-         end if;\n-      end Analyze_Aspect_Default_Value;\n-\n-      -------------------------------------\n-      -- Make_Pragma_From_Boolean_Aspect --\n-      -------------------------------------\n-\n-      procedure Make_Pragma_From_Boolean_Aspect (ASN : Node_Id) is\n-         Ident  : constant Node_Id    := Identifier (ASN);\n-         A_Name : constant Name_Id    := Chars (Ident);\n-         A_Id   : constant Aspect_Id  := Get_Aspect_Id (A_Name);\n-         Ent    : constant Entity_Id  := Entity (ASN);\n-         Expr   : constant Node_Id    := Expression (ASN);\n-         Loc    : constant Source_Ptr := Sloc (ASN);\n-\n-         Prag : Node_Id;\n-\n-         procedure Check_False_Aspect_For_Derived_Type;\n-         --  This procedure checks for the case of a false aspect for a derived\n-         --  type, which improperly tries to cancel an aspect inherited from\n-         --  the parent.\n-\n-         -----------------------------------------\n-         -- Check_False_Aspect_For_Derived_Type --\n-         -----------------------------------------\n-\n-         procedure Check_False_Aspect_For_Derived_Type is\n-            Par : Node_Id;\n-\n-         begin\n-            --  We are only checking derived types\n-\n-            if not Is_Derived_Type (E) then\n-               return;\n-            end if;\n-\n-            Par := Nearest_Ancestor (E);\n-\n-            case A_Id is\n-               when Aspect_Atomic | Aspect_Shared =>\n-                  if not Is_Atomic (Par) then\n-                     return;\n-                  end if;\n-\n-               when Aspect_Atomic_Components =>\n-                  if not Has_Atomic_Components (Par) then\n-                     return;\n-                  end if;\n-\n-               when Aspect_Discard_Names =>\n-                  if not Discard_Names (Par) then\n-                     return;\n-                  end if;\n-\n-               when Aspect_Pack =>\n-                  if not Is_Packed (Par) then\n-                     return;\n-                  end if;\n-\n-               when Aspect_Unchecked_Union =>\n-                  if not Is_Unchecked_Union (Par) then\n-                     return;\n-                  end if;\n-\n-               when Aspect_Volatile =>\n-                  if not Is_Volatile (Par) then\n-                     return;\n-                  end if;\n-\n-               when Aspect_Volatile_Components =>\n-                  if not Has_Volatile_Components (Par) then\n-                     return;\n-                  end if;\n-\n-               when others =>\n-                  return;\n-            end case;\n-\n-            --  Fall through means we are canceling an inherited aspect\n-\n-            Error_Msg_Name_1 := A_Name;\n-            Error_Msg_NE (\"derived type& inherits aspect%, cannot cancel\",\n-                          Expr,\n-                          E);\n-\n-         end Check_False_Aspect_For_Derived_Type;\n-\n-      --  Start of processing for Make_Pragma_From_Boolean_Aspect\n-\n-      begin\n-         if Is_False (Static_Boolean (Expr)) then\n-            Check_False_Aspect_For_Derived_Type;\n-\n-         else\n-            Prag :=\n-              Make_Pragma (Loc,\n-                Pragma_Argument_Associations => New_List (\n-                  New_Occurrence_Of (Ent, Sloc (Ident))),\n-                Pragma_Identifier            =>\n-                  Make_Identifier (Sloc (Ident), Chars (Ident)));\n-\n-            Set_From_Aspect_Specification (Prag, True);\n-            Set_Corresponding_Aspect (Prag, ASN);\n-            Set_Aspect_Rep_Item (ASN, Prag);\n-            Set_Is_Delayed_Aspect (Prag);\n-            Set_Parent (Prag, ASN);\n-         end if;\n-\n-      end Make_Pragma_From_Boolean_Aspect;\n-\n-   --  Start of processing for Evaluate_Aspects_At_Freeze_Point\n-\n-   begin\n-      --  Must be declared in current scope\n-\n-      if Scope (E) /= Current_Scope then\n-         return;\n-      end if;\n-\n-      --  Look for aspect specification entries for this entity\n-\n-      ASN := First_Rep_Item (E);\n-\n-      while Present (ASN) loop\n-         if Nkind (ASN) = N_Aspect_Specification\n-           and then Entity (ASN) = E\n-           and then Is_Delayed_Aspect (ASN)\n-         then\n-            A_Id := Get_Aspect_Id (Chars (Identifier (ASN)));\n-\n-            case A_Id is\n-               --  For aspects whose expression is an optional Boolean, make\n-               --  the corresponding pragma at the freezing point.\n-\n-               when Boolean_Aspects      |\n-                    Library_Unit_Aspects =>\n-                  Make_Pragma_From_Boolean_Aspect (ASN);\n-\n-               --  Special handling for aspects that don't correspond to\n-               --  pragmas/attributes.\n-\n-               when Aspect_Default_Value           |\n-                    Aspect_Default_Component_Value =>\n-                  Analyze_Aspect_Default_Value (ASN);\n-\n-               when others => null;\n-            end case;\n-\n-            Ritem := Aspect_Rep_Item (ASN);\n-\n-            if Present (Ritem) then\n-               Analyze (Ritem);\n-            end if;\n-         end if;\n-\n-         Next_Rep_Item (ASN);\n-      end loop;\n-   end Evaluate_Aspects_At_Freeze_Point;\n-\n    -------------------------\n    -- Get_Alignment_Value --\n    -------------------------"}, {"sha": "ba335e195852fecf092f1b347cb868324beda1d6", "filename": "gcc/ada/sem_ch13.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5/gcc%2Fada%2Fsem_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5/gcc%2Fada%2Fsem_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.ads?ref=8a0320ad5ee725a4e81229c0ba0dd25c8aa48ac5", "patch": "@@ -299,6 +299,9 @@ package Sem_Ch13 is\n \n    --  Quite an awkward procedure, but this is an awkard requirement!\n \n+   procedure Analyze_Aspects_At_Freeze_Point (E : Entity_Id);\n+   --  Analyze all the delayed aspects for entity E at freezing point\n+\n    procedure Check_Aspect_At_Freeze_Point (ASN : Node_Id);\n    --  Performs the processing described above at the freeze point, ASN is the\n    --  N_Aspect_Specification node for the aspect.\n@@ -307,7 +310,4 @@ package Sem_Ch13 is\n    --  Performs the processing described above at the freeze all point, and\n    --  issues appropriate error messages if the visibility has indeed changed.\n    --  Again, ASN is the N_Aspect_Specification node for the aspect.\n-\n-   procedure Evaluate_Aspects_At_Freeze_Point (E : Entity_Id);\n-   --  Evaluates all the delayed aspects for entity E at freezing point\n end Sem_Ch13;"}]}