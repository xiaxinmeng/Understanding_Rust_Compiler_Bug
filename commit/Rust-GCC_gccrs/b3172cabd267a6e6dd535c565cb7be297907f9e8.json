{"sha": "b3172cabd267a6e6dd535c565cb7be297907f9e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjMxNzJjYWJkMjY3YTZlNmRkNTM1YzU2NWNiN2JlMjk3OTA3ZjllOA==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2007-09-05T17:43:01Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2007-09-05T17:43:01Z"}, "message": "cpuid.h: New file.\n\n\t* gcc/config/i386/cpuid.h: New file.\n\t* gcc/config/i386/driver-i386.c: Include cpuid.h.\n\t(describe_cache): Shrink size and line strings to 100 bytes.\n\t(detect_caches_amd): Return \"\" for unsupported max_ext_level.\n\tUse __cpuid function.\n\t(detect_caches_intel): Return \"\" for unsupported max_level.\n\tUse __cpuid function.\n\t(host_detect_local_cpu): Change feature flag variables to\n\tunsigned int.  Initialize only extended feature flag variables.\n\tUse __get_cpuid_max to determine max supported cpuid level.\n\tUse __cpuid function to determine supported features.  Fix\n\tcalculation of family id.  Remove is_amd and check signature\n\tdirectly.  Check for Geode signature.  Handle family 4 id.\n\t[PROCESSOR_GENERIC32]: New default for unknown family id. Move\n\tcpu discovery code to other part of the function.\n\t[PROCESSOR_PENTIUM, PROCESSOR_K6, PROCESSOR_ATHLON]: Do not tune\n\tfor sub-architecture.\n\t[PROCESSOR_PENTIUMPRO]: Simplify cpu discovery code.\n\t[PROCESSOR_K8]: Add k8-sse3 architecture.\n\t[PROCESSOR_GENERIC64]: Remove.\n\t* gcc/config/i386/x-i386 (driver-i386.o): Depend on cpuid.h.\n\t* gcc/config/i386/crtfastmath.c: Include cpuid.h.  Use __get_cpuid\n\tto check for SSE and FXSAVE support.\n\t* gcc/config/i386/t-crtfm (crtfastmath.o): Depend on cpuid.h.\n\tAdd -minline-all-stringops.\n\t* gcc/config.gcc (i[34567]86-*-*): Add cpuid.h to extra_headers.\n\t(x86_64-*-*): Ditto.\n\ntestsuite/ChangeLog:\n\n\t* gcc.dg/i386-cpuid.h: Remove.\n\t* gcc.target/i386/mmx-check.h: Include cpuid.h.  Use __get_cpuid.\n\t* gcc.target/i386/sse-check.h: Ditto.\n\t* gcc.target/i386/sse2-check.h: Ditto.\n\t* gcc.target/i386/sse3-check.h: Ditto.\n\t* gcc.target/i386/ssse3-check.h: Ditto.\n\t* gcc.target/i386/sse4_1-check.h: Ditto.\n\t* gcc.target/i386/sse4_2-check.h: Ditto.\n\t* gcc.target/i386/sse4a-check.h: Ditto.\n\t* gcc.dg/torture/pr16104-1.c: Ditto.\n\t* gcc.target/i386/mmx-4.c: Do not use NOINLINE.\n\t* gcc.target/i386/sse-6.c: Ditto.\n\t* gcc.target/i386/sse-7.c: Ditto.\n\t* g++.dg/other/i386-1.C: Include cpuid.h.\n\t(main): New function.  Use __get_cpuid to check target fetaures.\n\nlibgomp/ChangeLog:\n\n\t* testsuite/libgomp.c/atomic-1.c: Include cpuid.h for i386 targets.\n\t(main): Use __get_cpuid to get i386 target fetaures.\n\t* testsuite/libgomp.c/atomic-2.c: Include cpuid.h for x86_64 targets.\n\t(main): Use __get_cpuid to get x86_64 target fetaures.\n\nFrom-SVN: r128141", "tree": {"sha": "16b3a7f9f7833da2cad7c43376d098af0e2601ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16b3a7f9f7833da2cad7c43376d098af0e2601ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3172cabd267a6e6dd535c565cb7be297907f9e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3172cabd267a6e6dd535c565cb7be297907f9e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3172cabd267a6e6dd535c565cb7be297907f9e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3172cabd267a6e6dd535c565cb7be297907f9e8/comments", "author": null, "committer": null, "parents": [{"sha": "57df7359df5ff4a87858e0da6da703ec7a6624eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57df7359df5ff4a87858e0da6da703ec7a6624eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57df7359df5ff4a87858e0da6da703ec7a6624eb"}], "stats": {"total": 881, "additions": 448, "deletions": 433}, "files": [{"sha": "661db5a84e780392c2c4e1f8680646048235050a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b3172cabd267a6e6dd535c565cb7be297907f9e8", "patch": "@@ -1,4 +1,35 @@\n-2007-09-06  Jie Zhang  <jie.zhang@analog.com>\n+2007-09-05  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* gcc/config/i386/cpuid.h: New file.\n+\t* gcc/config/i386/driver-i386.c: Include cpuid.h.\n+\t(describe_cache): Shrink size and line strings to 100 bytes.\n+\t(detect_caches_amd): Return \"\" for unsupported max_ext_level.\n+\tUse __cpuid function.\n+\t(detect_caches_intel): Return \"\" for unsupported max_level.\n+\tUse __cpuid function.\n+\t(host_detect_local_cpu): Change feature flag variables to\n+\tunsigned int.  Initialize only extended feature flag variables.\n+\tUse __get_cpuid_max to determine max supported cpuid level.\n+\tUse __cpuid function to determine supported features.  Fix\n+\tcalculation of family id.  Remove is_amd and check signature\n+\tdirectly.  Check for Geode signature.  Handle family 4 id.\n+\t[PROCESSOR_GENERIC32]: New default for unknown family id.  Move\n+\tcpu discovery code to lower part of the function.\n+\t[PROCESSOR_PENTIUM, PROCESSOR_K6, PROCESSOR_ATHLON]: Do not tune\n+\tfor sub-architecture.\n+\t[PROCESSOR_PENTIUMPRO]: Simplify cpu discovery code.\n+\t[PROCESSOR_K8]: Add k8-sse3 architecture.\n+\t[PROCESSOR_NOCONA]: Remove.\n+\t[PROCESSOR_GENERIC64]: Ditto.\n+\t* gcc/config/i386/x-i386 (driver-i386.o): Depend on cpuid.h.\n+\t* gcc/config/i386/crtfastmath.c: Include cpuid.h.  Use __get_cpuid\n+\tto check for SSE and FXSAVE support.\n+\t* gcc/config/i386/t-crtfm (crtfastmath.o): Depend on cpuid.h.\n+\tAdd -minline-all-stringops.\n+\t* gcc/config.gcc (i[34567]86-*-*): Add cpuid.h to extra_headers.\n+\t(x86_64-*-*): Ditto.\n+\n+2007-09-05  Jie Zhang  <jie.zhang@analog.com>\n \n \t* config/bfin/linux-unwind.h: New file.\n \t* config/bfin/linux.h (MD_UNWIND_SUPPORT): Define."}, {"sha": "0eecd7ef90c516c754ed7208dce8c8922acef458", "filename": "gcc/config.gcc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=b3172cabd267a6e6dd535c565cb7be297907f9e8", "patch": "@@ -278,13 +278,13 @@ xscale-*-*)\n \t;;\n i[34567]86-*-*)\n \tcpu_type=i386\n-\textra_headers=\"mmintrin.h mm3dnow.h xmmintrin.h emmintrin.h\n+\textra_headers=\"cpuid.h mmintrin.h mm3dnow.h xmmintrin.h emmintrin.h\n \t\t       pmmintrin.h tmmintrin.h ammintrin.h smmintrin.h\n \t\t       nmmintrin.h\"\n \t;;\n x86_64-*-*)\n \tcpu_type=i386\n-\textra_headers=\"mmintrin.h mm3dnow.h xmmintrin.h emmintrin.h\n+\textra_headers=\"cpuid.h mmintrin.h mm3dnow.h xmmintrin.h emmintrin.h\n \t\t       pmmintrin.h tmmintrin.h ammintrin.h smmintrin.h\n \t\t       nmmintrin.h\"\n \tneed_64bit_hwint=yes"}, {"sha": "49af88d5e47ccf6ac45eebbb8e16b225dc5ce16d", "filename": "gcc/config/i386/cpuid.h", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Fconfig%2Fi386%2Fcpuid.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Fconfig%2Fi386%2Fcpuid.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcpuid.h?ref=b3172cabd267a6e6dd535c565cb7be297907f9e8", "patch": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright (C) 2007 Free Software Foundation, Inc.\n+ *\n+ * This file is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License as published by the\n+ * Free Software Foundation; either version 2, or (at your option) any\n+ * later version.\n+ * \n+ * In addition to the permissions in the GNU General Public License, the\n+ * Free Software Foundation gives you unlimited permission to link the\n+ * compiled version of this file with other programs, and to distribute\n+ * those programs without any restriction coming from the use of this\n+ * file.  (The General Public License restrictions do apply in other\n+ * respects; for example, they cover modification of the file, and\n+ * distribution when not linked into another program.)\n+ * \n+ * This file is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * General Public License for more details.\n+ * \n+ * You should have received a copy of the GNU General Public License\n+ * along with this program; see the file COPYING.  If not, write to\n+ * the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+ * Boston, MA 02110-1301, USA.\n+ * \n+ *    As a special exception, if you link this library with files\n+ *    compiled with GCC to produce an executable, this does not cause\n+ *    the resulting executable to be covered by the GNU General Public License.\n+ *    This exception does not however invalidate any other reasons why\n+ *    the executable file might be covered by the GNU General Public License.\n+ */\n+\n+/* %ecx */\n+#define bit_SSE3\t(1 << 0)\n+#define bit_SSSE3\t(1 << 9)\n+#define bit_CMPXCHG16B\t(1 << 13)\n+#define bit_SSE4_1\t(1 << 19)\n+#define bit_SSE4_2\t(1 << 20)\n+#define bit_POPCNT\t(1 << 23)\n+\n+/* %edx */\n+#define bit_CMPXCHG8B\t(1 << 8)\n+#define bit_CMOV\t(1 << 15)\n+#define bit_MMX\t\t(1 << 23)\n+#define bit_FXSAVE\t(1 << 24)\n+#define bit_SSE\t\t(1 << 25)\n+#define bit_SSE2\t(1 << 26)\n+\n+/* Extended Features */\n+/* %ecx */\n+#define bit_LAHF_LM\t(1 << 0)\n+#define bit_SSE4a\t(1 << 6)\n+\n+/* %edx */\n+#define bit_LM\t\t(1 << 29)\n+#define bit_3DNOWP\t(1 << 30)\n+#define bit_3DNOW\t(1 << 31)\n+\n+\n+#if defined(__i386__) && defined(__PIC__)\n+/* %ebx may be the PIC register.  */\n+#define __cpuid(level, a, b, c, d)\t\t\t\\\n+  __asm__ (\"xchgl\\t%%ebx, %1\\n\\t\"\t\t\t\\\n+\t   \"cpuid\\n\\t\"\t\t\t\t\t\\\n+\t   \"xchgl\\t%%ebx, %1\\n\\t\"\t\t\t\\\n+\t   : \"=a\" (a), \"=r\" (b), \"=c\" (c), \"=d\" (d)\t\\\n+\t   : \"0\" (level))\n+#else\n+#define __cpuid(level, a, b, c, d)\t\t\t\\\n+  __asm__ (\"cpuid\\n\\t\"\t\t\t\t\t\\\n+\t   : \"=a\" (a), \"=b\" (b), \"=c\" (c), \"=d\" (d)\t\\\n+\t   : \"0\" (level))\n+#endif\n+\n+/* Return highest supported input value for cpuid instruction.  ext can\n+   be either 0x0 or 0x8000000 to return highest supported value for\n+   basic or extended cpuid information.  Function returns 0 if cpuid\n+   is not supported or whatever cpuid returns in eax register.  If sig\n+   pointer is non-null, then first four bytes of the signature\n+   (as found in ebx register) are returned in location pointed by sig.  */\n+\n+static __inline unsigned int\n+__get_cpuid_max (unsigned int __ext, unsigned int *__sig)\n+{\n+  unsigned int __eax, __ebx, __ecx, __edx;\n+\n+#ifndef __x86_64__\n+  /* See if we can use cpuid.  On AMD64 we always can.  */\n+  __asm__ (\"pushfl\\n\\t\"\n+\t   \"pushfl\\n\\t\"\n+\t   \"popl\\t%0\\n\\t\"\n+\t   \"movl\\t%0, %1\\n\\t\"\n+\t   \"xorl\\t%2, %0\\n\\t\"\n+\t   \"pushl\\t%0\\n\\t\"\n+\t   \"popfl\\n\\t\"\n+\t   \"pushfl\\n\\t\"\n+\t   \"popl\\t%0\\n\\t\"\n+\t   \"popfl\\n\\t\"\n+\t   : \"=&r\" (__eax), \"=&r\" (__ebx)\n+\t   : \"i\" (0x00200000));\n+\n+  if (!((__eax ^ __ebx) & 0x00200000))\n+    return 0;\n+#endif\n+\n+  /* Host supports cpuid.  Return highest supported cpuid input value.  */\n+  __cpuid (__ext, __eax, __ebx, __ecx, __edx);\n+\n+  if (__sig)\n+    *__sig = __ebx;\n+\n+  return __eax;\n+}\n+\n+/* Return cpuid data for requested cpuid level, as found in returned\n+   eax, ebx, ecx and edx registers.  The function checks if cpuid is\n+   supported and returns 1 for valid cpuid information or 0 for\n+   unsupported cpuid level.  All pointers are requred to be non-null.  */\n+\n+static __inline int\n+__get_cpuid (unsigned int __level,\n+\t     unsigned int *__eax, unsigned int *__ebx,\n+\t     unsigned int *__ecx, unsigned int *__edx)\n+{\n+  unsigned int __ext = __level & 0x80000000;\n+\n+  if (__get_cpuid_max (__ext, 0) < __level)\n+    return 0;\n+\n+  __cpuid (__level, *__eax, *__ebx, *__ecx, *__edx);\n+  return 1;\n+}"}, {"sha": "19db142d58f26668b6a62d96d2a98a3d6e25aa33", "filename": "gcc/config/i386/crtfastmath.c", "status": "modified", "additions": 9, "deletions": 26, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Fconfig%2Fi386%2Fcrtfastmath.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Fconfig%2Fi386%2Fcrtfastmath.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcrtfastmath.c?ref=b3172cabd267a6e6dd535c565cb7be297907f9e8", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (C) 2005 Free Software Foundation, Inc.\n+ * Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n  *\n  * This file is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU General Public License as published by the\n@@ -34,8 +34,11 @@\n #define MXCSR_DAZ (1 << 6)\t/* Enable denormals are zero mode */\n #define MXCSR_FTZ (1 << 15)\t/* Enable flush to zero mode */\n \n-#define FXSAVE\t(1 << 24)\n-#define SSE\t(1 << 25)\n+#ifndef __x86_64__\n+/* All 64-bit targets have SSE and DAZ;\n+   only check them explicitly for 32-bit ones. */\n+#include \"cpuid.h\"\n+#endif\n \n static void __attribute__((constructor))\n #ifndef __x86_64__\n@@ -47,38 +50,18 @@ __attribute__ ((force_align_arg_pointer))\n set_fast_math (void)\n {\n #ifndef __x86_64__\n-  /* All 64-bit targets have SSE and DAZ; only check them explicitly\n-     for 32-bit ones. */\n   unsigned int eax, ebx, ecx, edx;\n \n-  /* See if we can use cpuid.  */\n-  asm volatile (\"pushfl; pushfl; popl %0; movl %0,%1; xorl %2,%0;\"\n-\t\t\"pushl %0; popfl; pushfl; popl %0; popfl\"\n-\t\t: \"=&r\" (eax), \"=&r\" (ebx)\n-\t\t: \"i\" (0x00200000));\n-\n-  if (((eax ^ ebx) & 0x00200000) == 0)\n+  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n     return;\n \n-  /* Check the highest input value for eax.  */\n-  asm volatile (\"xchgl %%ebx, %1; cpuid; xchgl %%ebx, %1\"\n-\t\t: \"=a\" (eax), \"=r\" (ebx), \"=c\" (ecx), \"=d\" (edx)\n-\t\t: \"0\" (0));\n-\n-  if (eax == 0)\n-    return;\n-\n-  asm volatile (\"xchgl %%ebx, %1; cpuid; xchgl %%ebx, %1\"\n-\t\t: \"=a\" (eax), \"=r\" (ebx), \"=c\" (ecx), \"=d\" (edx)\n-\t\t: \"0\" (1));\n-\n-  if (edx & SSE)\n+  if (edx & bit_SSE)\n     {\n       unsigned int mxcsr = __builtin_ia32_stmxcsr ();\n   \n       mxcsr |= MXCSR_FTZ;\n \n-      if (edx & FXSAVE)\n+      if (edx & bit_FXSAVE)\n \t{\n \t  /* Check if DAZ is available.  */\n \t  struct"}, {"sha": "df2fadee713b40767c90193b37ff96dda861021e", "filename": "gcc/config/i386/driver-i386.c", "status": "modified", "additions": 130, "deletions": 168, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Fconfig%2Fi386%2Fdriver-i386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Fconfig%2Fi386%2Fdriver-i386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fdriver-i386.c?ref=b3172cabd267a6e6dd535c565cb7be297907f9e8", "patch": "@@ -26,26 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n const char *host_detect_local_cpu (int argc, const char **argv);\n \n #ifdef GCC_VERSION\n-#define cpuid(num,a,b,c,d) \\\n-  asm volatile (\"xchgl %%ebx, %1; cpuid; xchgl %%ebx, %1\" \\\n-\t\t: \"=a\" (a), \"=r\" (b), \"=c\" (c), \"=d\" (d)  \\\n-\t\t: \"0\" (num))\n-\n-#define bit_CMPXCHG8B (1 << 8)\n-#define bit_CMOV (1 << 15)\n-#define bit_MMX (1 << 23)\n-#define bit_SSE (1 << 25)\n-#define bit_SSE2 (1 << 26)\n-\n-#define bit_SSE3 (1 << 0)\n-#define bit_SSSE3 (1 << 9)\n-#define bit_SSE4a (1 << 6)\n-#define bit_CMPXCHG16B (1 << 13)\n-\n-#define bit_LAHF_LM (1 << 0)\n-#define bit_3DNOW (1 << 31)\n-#define bit_3DNOWP (1 << 30)\n-#define bit_LM (1 << 29)\n+#include \"cpuid.h\"\n \n /* Returns parameters that describe L1_ASSOC associative cache of size\n    L1_SIZEKB with lines of size L1_LINE.  */\n@@ -54,7 +35,7 @@ static char *\n describe_cache (unsigned l1_sizekb, unsigned l1_line,\n \t\tunsigned l1_assoc ATTRIBUTE_UNUSED)\n {\n-  char size[1000], line[1000];\n+  char size[100], line[100];\n \n   /* At the moment, gcc middle-end does not use the information about the\n      associativity of the cache.  */\n@@ -74,9 +55,9 @@ detect_caches_amd (unsigned max_ext_level)\n   unsigned l1_sizekb, l1_line, l1_assoc;\n \n   if (max_ext_level < 0x80000005)\n-    return NULL;\n+    return (char *) \"\";\n \n-  cpuid (0x80000005, eax, ebx, ecx, edx);\n+  __cpuid (0x80000005, eax, ebx, ecx, edx);\n \n   l1_line = ecx & 0xff;\n   l1_sizekb = (ecx >> 24) & 0xff;\n@@ -155,14 +136,15 @@ detect_caches_intel (unsigned max_level)\n   unsigned l1_sizekb = 0, l1_line = 0, assoc = 0;\n \n   if (max_level < 2)\n-    return NULL;\n+    return (char *) \"\";\n \n-  cpuid (2, eax, ebx, ecx, edx);\n+  __cpuid (2, eax, ebx, ecx, edx);\n \n   decode_caches_intel (eax, &l1_sizekb, &l1_line, &assoc);\n   decode_caches_intel (ebx, &l1_sizekb, &l1_line, &assoc);\n   decode_caches_intel (ecx, &l1_sizekb, &l1_line, &assoc);\n   decode_caches_intel (edx, &l1_sizekb, &l1_line, &assoc);\n+\n   if (!l1_sizekb)\n     return (char *) \"\";\n \n@@ -181,88 +163,84 @@ detect_caches_intel (unsigned max_level)\n \n    ARGC and ARGV are set depending on the actual arguments given\n    in the spec.  */\n+\n const char *host_detect_local_cpu (int argc, const char **argv)\n {\n-  const char *cpu = NULL;\n+  enum processor_type processor = PROCESSOR_I386;\n+  const char *cpu = \"i386\";\n+\n   const char *cache = \"\";\n   const char *options = \"\";\n-  enum processor_type processor = PROCESSOR_I386;\n-  unsigned int eax, ebx, ecx, edx;\n-  unsigned int max_level;\n+\n+ unsigned int eax, ebx, ecx, edx;\n+\n+  unsigned int max_level, ext_level;\n   unsigned int vendor;\n-  unsigned int ext_level;\n-  unsigned char has_mmx = 0, has_3dnow = 0, has_3dnowp = 0, has_sse = 0;\n-  unsigned char has_sse2 = 0, has_sse3 = 0, has_ssse3 = 0, has_cmov = 0;\n-  unsigned char has_cmpxchg16b = 0, has_lahf_lm = 0;\n-  unsigned char has_longmode = 0, has_cmpxchg8b = 0, has_sse4a = 0;\n-  unsigned char is_amd = 0;\n-  unsigned int family = 0;\n+  unsigned int family;\n+\n+  unsigned int has_sse3, has_ssse3, has_cmpxchg16b;\n+  unsigned int has_cmpxchg8b, has_cmov, has_mmx, has_sse, has_sse2;\n+\n+  /* Extended features */\n+  unsigned int has_lahf_lm = 0, has_sse4a = 0;\n+  unsigned int has_longmode = 0, has_3dnowp = 0, has_3dnow = 0;\n+\n   bool arch;\n \n   if (argc < 1)\n     return NULL;\n \n-  arch = strcmp (argv[0], \"arch\") == 0;\n+  arch = !strcmp (argv[0], \"arch\");\n+\n   if (!arch && strcmp (argv[0], \"tune\"))\n     return NULL;\n \n-#ifndef __x86_64__\n-  /* See if we can use cpuid.  */\n-  asm volatile (\"pushfl; pushfl; popl %0; movl %0,%1; xorl %2,%0;\"\n-\t\t\"pushl %0; popfl; pushfl; popl %0; popfl\"\n-\t\t: \"=&r\" (eax), \"=&r\" (ebx)\n-\t\t: \"i\" (0x00200000));\n-\n-  if (((eax ^ ebx) & 0x00200000) == 0)\n+  max_level = __get_cpuid_max (0, &vendor);\n+  if (max_level < 1)\n     goto done;\n-#endif\n-\n-  processor = PROCESSOR_PENTIUM;\n \n-  /* Check the highest input value for eax.  */\n-  cpuid (0, eax, ebx, ecx, edx);\n-  max_level = eax;\n-  /* We only look at the first four characters.  */\n-  vendor = ebx;\n-  if (max_level == 0)\n-    goto done;\n+  __cpuid (1, eax, ebx, ecx, edx);\n \n-  cpuid (1, eax, ebx, ecx, edx);\n-  has_cmpxchg8b = !!(edx & bit_CMPXCHG8B);\n-  has_cmov = !!(edx & bit_CMOV);\n-  has_mmx = !!(edx & bit_MMX);\n-  has_sse = !!(edx & bit_SSE);\n-  has_sse2 = !!(edx & bit_SSE2);\n-  has_sse3 = !!(ecx & bit_SSE3);\n-  has_ssse3 = !!(ecx & bit_SSSE3);\n-  has_cmpxchg16b = !!(ecx & bit_CMPXCHG16B);\n   /* We don't care for extended family.  */\n-  family = (eax >> 8) & ~(1 << 4);\n+  family = (eax >> 8) & 0x0f;\n+\n+  has_sse3 = ecx & bit_SSE3;\n+  has_ssse3 = ecx & bit_SSSE3;\n+  has_cmpxchg16b = ecx & bit_CMPXCHG16B;\n \n-  cpuid (0x80000000, eax, ebx, ecx, edx);\n-  ext_level = eax;\n-  if (ext_level >= 0x80000000)\n+  has_cmpxchg8b = edx & bit_CMPXCHG8B;\n+  has_cmov = edx & bit_CMOV;\n+  has_mmx = edx & bit_MMX;\n+  has_sse = edx & bit_SSE;\n+  has_sse2 = edx & bit_SSE2;\n+\n+  /* Check cpuid level of extended features.  */\n+  __cpuid (0x80000000, ext_level, ebx, ecx, edx);\n+\n+  if (ext_level > 0x80000000)\n     {\n-      cpuid (0x80000001, eax, ebx, ecx, edx);\n-      has_lahf_lm = !!(ecx & bit_LAHF_LM);\n-      has_3dnow = !!(edx & bit_3DNOW);\n-      has_3dnowp = !!(edx & bit_3DNOWP);\n-      has_longmode = !!(edx & bit_LM);\n-      has_sse4a = !!(ecx & bit_SSE4a);\n-    }\n+      __cpuid (0x80000001, eax, ebx, ecx, edx);\n \n-  is_amd = vendor == *(unsigned int*)\"Auth\";\n+      has_lahf_lm = ecx & bit_LAHF_LM;\n+      has_sse4a = ecx & bit_SSE4a;\n+\n+      has_longmode = edx & bit_LM;\n+      has_3dnowp = edx & bit_3DNOWP;\n+      has_3dnow = edx & bit_3DNOW;\n+    }\n \n   if (!arch)\n     {\n-      if (is_amd)\n+      if (vendor == *(unsigned int*) \"Auth\")\n \tcache = detect_caches_amd (ext_level);\n-      else if (vendor == *(unsigned int*)\"Genu\")\n+      else if (vendor == *(unsigned int*) \"Genu\")\n \tcache = detect_caches_intel (max_level);\n     }\n \n-  if (is_amd)\n+  if (vendor == *(unsigned int*) \"Auth\")\n     {\n+      processor = PROCESSOR_PENTIUM;\n+\n       if (has_mmx)\n \tprocessor = PROCESSOR_K6;\n       if (has_3dnowp)\n@@ -272,12 +250,17 @@ const char *host_detect_local_cpu (int argc, const char **argv)\n       if (has_sse4a)\n \tprocessor = PROCESSOR_AMDFAM10;\n     }\n+  else if (vendor == *(unsigned int*) \"Geod\")\n+    processor = PROCESSOR_GEODE;\n   else\n     {\n       switch (family)\n \t{\n+\tcase 4:\n+\t  processor = PROCESSOR_I486;\n+\t  break;\n \tcase 5:\n-\t  /* Default is PROCESSOR_PENTIUM.  */\n+\t  processor = PROCESSOR_PENTIUM;\n \t  break;\n \tcase 6:\n \t  processor = PROCESSOR_PENTIUMPRO;\n@@ -286,135 +269,111 @@ const char *host_detect_local_cpu (int argc, const char **argv)\n \t  processor = PROCESSOR_PENTIUM4;\n \t  break;\n \tdefault:\n-\t  /* We have no idea.  Use something reasonable.  */\n-\t  if (arch)\n-\t    {\n-\t      if (has_ssse3)\n-\t\tcpu = \"core2\";\n-\t      else if (has_sse3)\n-\t\t{\n-\t\t  if (has_longmode)\n-\t\t    cpu = \"nocona\";\n-\t\t  else\n-\t\t    cpu = \"prescott\";\n-\t\t}\n-\t      else if (has_sse2)\n-\t\tcpu = \"pentium4\";\n-\t      else if (has_cmov)\n-\t\tcpu = \"pentiumpro\";\n-\t      else if (has_mmx)\n-\t\tcpu = \"pentium-mmx\";\n-\t      else if (has_cmpxchg8b)\n-\t\tcpu = \"pentium\";\n-\t      else\n-\t\tcpu = \"i386\";\n-\t    }\n-\t  else\n-\t    cpu = \"generic\";\n-\t  goto done;\n-\t  break;\n+\t  /* We have no idea.  */\n+\t  processor = PROCESSOR_GENERIC32;\n \t}\n     }\n \n   switch (processor)\n     {\n     case PROCESSOR_I386:\n-      cpu = \"i386\";\n+      /* Default.  */\n       break;\n     case PROCESSOR_I486:\n       cpu = \"i486\";\n       break;\n     case PROCESSOR_PENTIUM:\n-      if (has_mmx)\n+      if (arch && has_mmx)\n \tcpu = \"pentium-mmx\";\n       else\n \tcpu = \"pentium\";\n       break;\n     case PROCESSOR_PENTIUMPRO:\n       if (has_longmode)\n+\t/* It is Core 2 Duo.  */\n+\tcpu = \"core2\";\n+      else if (arch)\n \t{\n-\t  /* It is Core 2 Duo.  */\n-\t  cpu = \"core2\";\n+\t  if (has_sse3)\n+\t    /* It is Core Duo.  */\n+\t    cpu = \"prescott\";\n+\t  else if (has_sse2)\n+\t    /* It is Pentium M.  */\n+\t    cpu = \"pentium-m\";\n+\t  else if (has_sse)\n+\t    /* It is Pentium III.  */\n+\t    cpu = \"pentium3\";\n+\t  else if (has_mmx)\n+\t    /* It is Pentium II.  */\n+\t    cpu = \"pentium2\";\n+\t  else\n+\t    /* Default to Pentium Pro.  */\n+\t    cpu = \"pentiumpro\";\n \t}\n       else\n+\t/* For -mtune, we default to -mtune=generic.  */\n+\tcpu = \"generic\";\n+      break;\n+    case PROCESSOR_PENTIUM4:\n+      if (has_sse3)\n \t{\n-\t  if (arch)\n-\t    {\n-\t      if (has_sse3)\n-\t\t{\n-\t\t  /* It is Core Duo.  */\n-\t\t  cpu = \"prescott\";\n-\t\t}\n-\t      else if (has_sse2)\n-\t\t{\n-\t\t  /* It is Pentium M.  */\n-\t\t  cpu = \"pentium4\";\n-\t\t}\n-\t      else if (has_sse)\n-\t\t{\n-\t\t  /* It is Pentium III.  */\n-\t\t  cpu = \"pentium3\";\n-\t\t}\n-\t      else if (has_mmx)\n-\t\t{\n-\t\t  /* It is Pentium II.  */\n-\t\t  cpu = \"pentium2\";\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* Default to Pentium Pro.  */\n-\t\t  cpu = \"pentiumpro\";\n-\t\t}\n-\t    }\n+\t  if (has_longmode)\n+\t    cpu = \"nocona\";\n \t  else\n-\t    {\n-\t      /* For -mtune, we default to -mtune=generic.  */\n-\t      cpu = \"generic\";\n-\t    }\n+\t    cpu = \"prescott\";\n \t}\n+      else\n+\tcpu = \"pentium4\";\n       break;\n     case PROCESSOR_GEODE:\n       cpu = \"geode\";\n       break;\n     case PROCESSOR_K6:\n-      if (has_3dnow)\n-        cpu = \"k6-3\";\n+      if (arch && has_3dnow)\n+\tcpu = \"k6-3\";\n       else\n \tcpu = \"k6\";\n       break;\n     case PROCESSOR_ATHLON:\n-      if (has_sse)\n+      if (arch && has_sse)\n \tcpu = \"athlon-4\";\n       else\n \tcpu = \"athlon\";\n       break;\n-    case PROCESSOR_PENTIUM4:\n-      if (has_sse3)\n-\t{\n-\t  if (has_longmode)\n-\t    cpu = \"nocona\";\n-\t  else\n-\t    cpu = \"prescott\";\n-\t}\n-      else\n-\tcpu = \"pentium4\";\n-      break;\n     case PROCESSOR_K8:\n-      cpu = \"k8\";\n-      break;\n-    case PROCESSOR_NOCONA:\n-      cpu = \"nocona\";\n+      if (arch && has_sse3)\n+\tcpu = \"k8-sse3\";\n+      else\n+\tcpu = \"k8\";\n       break;\n     case PROCESSOR_AMDFAM10:\n       cpu = \"amdfam10\";\n       break;\n-    case PROCESSOR_GENERIC32:\n-    case PROCESSOR_GENERIC64:\n-      cpu = \"generic\";\n-      break;\n+\n     default:\n-      abort ();\n-      break;\n+      /* Use something reasonable.  */\n+      if (arch)\n+\t{\n+\t  if (has_ssse3)\n+\t    cpu = \"core2\";\n+\t  else if (has_sse3)\n+\t    {\n+\t      if (has_longmode)\n+\t\tcpu = \"nocona\";\n+\t      else\n+\t\tcpu = \"prescott\";\n+\t    }\n+\t  else if (has_sse2)\n+\t    cpu = \"pentium4\";\n+\t  else if (has_cmov)\n+\t    cpu = \"pentiumpro\";\n+\t  else if (has_mmx)\n+\t    cpu = \"pentium-mmx\";\n+\t  else if (has_cmpxchg8b)\n+\t    cpu = \"pentium\";\n+\t}\n+      else\n+\tcpu = \"generic\";\n     }\n \n   if (arch)\n@@ -429,8 +388,10 @@ const char *host_detect_local_cpu (int argc, const char **argv)\n   return concat (cache, \"-m\", argv[0], \"=\", cpu, \" \", options, NULL);\n }\n #else\n+\n /* If we aren't compiling with GCC we just provide a minimal\n    default value.  */\n+\n const char *host_detect_local_cpu (int argc, const char **argv)\n {\n   const char *cpu;\n@@ -439,7 +400,8 @@ const char *host_detect_local_cpu (int argc, const char **argv)\n   if (argc < 1)\n     return NULL;\n \n-  arch = strcmp (argv[0], \"arch\") == 0;\n+  arch = !strcmp (argv[0], \"arch\");\n+\n   if (!arch && strcmp (argv[0], \"tune\"))\n     return NULL;\n   "}, {"sha": "f60eab52609819e0085576c01ba12f2368bc3586", "filename": "gcc/config/i386/t-crtfm", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Fconfig%2Fi386%2Ft-crtfm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Fconfig%2Fi386%2Ft-crtfm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ft-crtfm?ref=b3172cabd267a6e6dd535c565cb7be297907f9e8", "patch": "@@ -1,6 +1,7 @@\n EXTRA_PARTS += crtfastmath.o\n \n-$(T)crtfastmath.o: $(srcdir)/config/i386/crtfastmath.c $(GCC_PASSES)\n-\t$(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -msse -c \\\n+$(T)crtfastmath.o: $(srcdir)/config/i386/crtfastmath.c \\\n+  $(srcdir)/config/i386/cpuid.h $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -msse -minline-all-stringops -c \\\n \t\t$(srcdir)/config/i386/crtfastmath.c \\\n \t\t-o $(T)crtfastmath$(objext)"}, {"sha": "9f03de4535edbbf9fdee8cbff4eaf4952daf2b90", "filename": "gcc/config/i386/x-i386", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Fconfig%2Fi386%2Fx-i386", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Fconfig%2Fi386%2Fx-i386", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx-i386?ref=b3172cabd267a6e6dd535c565cb7be297907f9e8", "patch": "@@ -1,3 +1,4 @@\n driver-i386.o : $(srcdir)/config/i386/driver-i386.c \\\n+  $(srcdir)/config/i386/cpuid.h \\\n   $(CONFIG_H) $(SYSTEM_H) $(TM_H) coretypes.h\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<"}, {"sha": "897d6a9f25e3dbb5faeeed954791e48285c6e028", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b3172cabd267a6e6dd535c565cb7be297907f9e8", "patch": "@@ -1,3 +1,23 @@\n+2007-09-05  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* gcc.dg/i386-cpuid.h: Remove.\n+\t* gcc.target/i386/mmx-check.h: Include cpuid.h.\n+\t(main): Use __get_cpuid to get target features.\n+\t* gcc.target/i386/sse-check.h: Ditto.\n+\t* gcc.target/i386/sse2-check.h: Ditto.\n+\t* gcc.target/i386/sse3-check.h: Ditto.\n+\t* gcc.target/i386/ssse3-check.h: Ditto.\n+\t* gcc.target/i386/sse4_1-check.h: Ditto.\n+\t* gcc.target/i386/sse4_2-check.h: Ditto.\n+\t* gcc.target/i386/sse4a-check.h: Ditto.\n+\t* gcc.dg/torture/pr16104-1.c: Ditto.\n+\t(do_test): Change to void.\n+\t* gcc.target/i386/mmx-4.c: Do not use NOINLINE.\n+\t* gcc.target/i386/sse-6.c: Ditto.\n+\t* gcc.target/i386/sse-7.c: Ditto.\n+\t* g++.dg/other/i386-1.C: Include cpuid.h.\n+\t(main): New function.  Use __get_cpuid to get target fetaures.\n+\n 2007-09-05  Sandra Loosemore  <sandra@codesourcery.com>\n \t    David Ung  <davidu@mips.com>\n             Nigel Stephens <nigel@mips.com>\n@@ -225,7 +245,8 @@\n \t* gcc.dg/vect/vect-intfloat-conversion-4a.c: Mark functions noinline.\n \t* gcc.dg/vect/vect-109.c: Mark functions noinline.\n \t* gcc.dg/vect/no-scevccp-outer-22.c: Mark functions noinline.\n-\t* gcc.dg/vect/no-section-anchors-vect-outer-4h.c: Mark functions noinline.\n+\t* gcc.dg/vect/no-section-anchors-vect-outer-4h.c: Mark functions\n+\tnoinline.\n \t* gcc.dg/vect/vect-iv-3.c: Mark functions noinline.\n \t* gcc.dg/vect/vect-reduc-pattern-2b.c: Mark functions noinline.\n \t* gcc.dg/vect/vect-reduc-dot-s8a.c: Mark functions noinline.\n@@ -361,15 +382,15 @@\n 2007-09-04  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.target/i386/sse4a-check.h: New file.\n-\t* gcc.target/i386/sse4a-extract.c: Include sse4a-check.h. Remove main.\n+\t* gcc.target/i386/sse4a-extract.c: Include sse4a-check.h.  Remove main.\n \t* gcc.target/i386/sse4a-insert.c: Ditto.\n \t* gcc.target/i386/sse4a-montsd.c: Ditto.\n \t* gcc.target/i386/sse4a-montss.c: Ditto.\n \t* gcc.target/i386/mmx-check.h: New file.\n-\t* gcc.target/i386/mmx-4.c: Include mmx-check.h. Remove main.\n+\t* gcc.target/i386/mmx-4.c: Include mmx-check.h.  Remove main.\n \t* gcc.target/i386/builtin-apply-mmx.c: Ditto.\n \t* gcc.target/i386/sse-check.h: New file.\n-\t* gcc.target/i386/pr13685: Include sse-check.h. Remove main.\n+\t* gcc.target/i386/pr13685: Include sse-check.h.  Remove main.\n \t* gcc.target/i386/sse-3.c: Ditto.\n \t* gcc.target/i386/sse-7.c: Ditto.\n \t* gcc.target/i386/sse-9.c: Ditto.\n@@ -378,7 +399,7 @@\n \t* gcc.target/i386/sse-recip-vec.c: Ditto.\n \t* gcc.target/i386/20020523.c: Ditto. Rename from 20020523-2.c.\n \t* gcc.target/i386/20020523-1.c: Remove.\n-\t* gcc.target/i386/sse2-lrint-vec.c: Include sse2-check.h. Remove main.\n+\t* gcc.target/i386/sse2-lrint-vec.c: Include sse2-check.h.  Remove main.\n \t* gcc.target/i386/sse2-lrintf-vec.c: Ditto.\n \t* gcc.target/i386/ssefn-4.c: Ditto.\n \t* gcc.target/i386/sse-6.c: Ditto.\n@@ -406,14 +427,11 @@\n \n 2007-09-03  H.J. Lu  <hongjiu.lu@intel.com>\n \n-\t* gcc.dg/vect/no-tree-scev-cprop-vect-iv-1.c: Restored.  Moved\n-\tto ...\n+\t* gcc.dg/vect/no-tree-scev-cprop-vect-iv-1.c: Restored.  Moved to ...\n \t* gcc.dg/vect/no-scevccp-vect-iv-1.c: New test.\n-\t* gcc.dg/vect/no-tree-scev-cprop-vect-iv-2.c: Restored.  Moved\n-\tto ...\n+\t* gcc.dg/vect/no-tree-scev-cprop-vect-iv-2.c: Restored.  Moved to ...\n \t* gcc.dg/vect/no-scevccp-vect-iv-2.c: New test.\n-\t* gcc.dg/vect/no-tree-scev-cprop-vect-iv-3.c: Restored.  Moved\n-\tto ...\n+\t* gcc.dg/vect/no-tree-scev-cprop-vect-iv-3.c: Restored.  Moved to ...\n \t* gcc.dg/vect/no-scevccp-vect-iv-3.c: New test.\n \n 2007-09-03  Jesper Nilsson  <jesper.nilsson@axis.com>"}, {"sha": "853f913db1e9d3a0f7ee5474eb8a6b52152b7e13", "filename": "gcc/testsuite/g++.dg/other/i386-1.C", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fi386-1.C?ref=b3172cabd267a6e6dd535c565cb7be297907f9e8", "patch": "@@ -1,10 +1,10 @@\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-msse2\" } */\n \n-#include \"../../gcc.target/i386/sse2-check.h\"\n-\n #include <xmmintrin.h>\n \n+#include \"cpuid.h\"\n+\n static void\n sse2_test (void)\n {\n@@ -20,3 +20,18 @@ sse2_test (void)\n   if (r != 3.0f)\n     abort ();\n }\n+\n+int\n+main ()\n+{\n+  unsigned int eax, ebx, ecx, edx;\n+ \n+  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n+    return 0;\n+\n+  /* Run SSE2 test only if host has SSE2 support.  */\n+  if (edx & bit_SSE2)\n+    sse2_test ();\n+\n+  return 0;\n+}"}, {"sha": "8c7a39f45a9c7dd64889d483106b8eea6693ec3f", "filename": "gcc/testsuite/gcc.dg/i386-cpuid.h", "status": "removed", "additions": 0, "deletions": 152, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57df7359df5ff4a87858e0da6da703ec7a6624eb/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-cpuid.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57df7359df5ff4a87858e0da6da703ec7a6624eb/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-cpuid.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-cpuid.h?ref=57df7359df5ff4a87858e0da6da703ec7a6624eb", "patch": "@@ -1,152 +0,0 @@\n-/* Helper file for i386 platform.  Runtime check for MMX/SSE/SSE2 support.\n-   Used by 20020523-2.c and i386-sse-6.c, and possibly others.  */\n-/* Plagarized from 20020523-2.c.  */\n-\n-/* %ecx */\n-#define bit_SSE3 (1 << 0)\n-#define bit_SSSE3 (1 << 9)\n-#define bit_SSE4_1 (1 << 19)\n-#define bit_SSE4_2 (1 << 20)\n-#define bit_POPCNT (1 << 23)\n-\n-/* %edx */\n-#define bit_CMOV (1 << 15)\n-#define bit_MMX (1 << 23)\n-#define bit_SSE (1 << 25)\n-#define bit_SSE2 (1 << 26)\n-\n-/* Extended Features */\n-/* %ecx */\n-#define bit_SSE4a (1 << 6)\n-\n-#ifndef NOINLINE\n-#define NOINLINE __attribute__ ((noinline))\n-#endif\n-\n-static inline unsigned int\n-i386_get_cpuid (unsigned int *ecx, unsigned int *edx)\n-{\n-  int fl1;\n-\n-#ifndef __x86_64__\n-  int fl2;\n-\n-  /* See if we can use cpuid.  On AMD64 we always can.  */\n-  __asm__ (\"pushfl; pushfl; popl %0; movl %0,%1; xorl %2,%0;\"\n-\t   \"pushl %0; popfl; pushfl; popl %0; popfl\"\n-\t   : \"=&r\" (fl1), \"=&r\" (fl2)\n-\t   : \"i\" (0x00200000));\n-  if (((fl1 ^ fl2) & 0x00200000) == 0)\n-    return (0);\n-#endif\n-\n-  /* Host supports cpuid.  See if cpuid gives capabilities, try\n-     CPUID(0).  Preserve %ebx and %ecx; cpuid insn clobbers these, we\n-     don't need their CPUID values here, and %ebx may be the PIC\n-     register.  */\n-#ifdef __x86_64__\n-  __asm__ (\"pushq %%rcx; pushq %%rbx; cpuid; popq %%rbx; popq %%rcx\"\n-\t   : \"=a\" (fl1) : \"0\" (0) : \"rdx\", \"cc\");\n-#else\n-  __asm__ (\"pushl %%ecx; pushl %%ebx; cpuid; popl %%ebx; popl %%ecx\"\n-\t   : \"=a\" (fl1) : \"0\" (0) : \"edx\", \"cc\");\n-#endif\n-  if (fl1 == 0)\n-    return (0);\n-\n-  /* Invoke CPUID(1), return %ecx and %edx; caller can examine bits to\n-     determine what's supported.  */\n-#ifdef __x86_64__\n-  __asm__ (\"pushq %%rbx; cpuid; popq %%rbx\"\n-\t   : \"=c\" (*ecx), \"=d\" (*edx), \"=a\" (fl1) : \"2\" (1) : \"cc\");\n-#else\n-  __asm__ (\"pushl %%ebx; cpuid; popl %%ebx\"\n-\t   : \"=c\" (*ecx), \"=d\" (*edx), \"=a\" (fl1) : \"2\" (1) : \"cc\");\n-#endif\n-\n-  return 1;\n-}\n-\n-static inline unsigned int\n-i386_get_extended_cpuid (unsigned int *ecx, unsigned int *edx)\n-{\n-  int fl1;\n-  if (!(i386_get_cpuid (ecx, edx)))\n-    return 0;\n-\n-  /* Invoke CPUID(0x80000000) to get the highest supported extended function\n-     number */\n-#ifdef __x86_64__\n-  __asm__ (\"cpuid\"\n-\t   : \"=a\" (fl1) : \"0\" (0x80000000) : \"edx\", \"ecx\", \"ebx\");\n-#else\n-  __asm__ (\"pushl %%ebx; cpuid; popl %%ebx\"\n-\t   : \"=a\" (fl1) : \"0\" (0x80000000) : \"edx\", \"ecx\");\n-#endif\n-  /* Check if highest supported extended function used below are supported */\n-  if (fl1 < 0x80000001)\n-    return 0;  \n-\n-  /* Invoke CPUID(0x80000001), return %ecx and %edx; caller can examine bits to\n-     determine what's supported.  */\n-#ifdef __x86_64__\n-  __asm__ (\"cpuid\"\n-\t   : \"=c\" (*ecx), \"=d\" (*edx), \"=a\" (fl1) : \"2\" (0x80000001) : \"ebx\");\n-#else\n-  __asm__ (\"pushl %%ebx; cpuid; popl %%ebx\"\n-\t   : \"=c\" (*ecx), \"=d\" (*edx), \"=a\" (fl1) : \"2\" (0x80000001));\n-#endif\n-  return 1;\n-}\n-\n-\n-unsigned int i386_cpuid_ecx (void) NOINLINE;\n-unsigned int i386_cpuid_edx (void) NOINLINE;\n-unsigned int i386_extended_cpuid_ecx (void) NOINLINE;\n-unsigned int i386_extended_cpuid_edx (void) NOINLINE;\n-\n-unsigned int NOINLINE\n-i386_cpuid_ecx (void)\n-{\n-  unsigned int ecx, edx;\n-  if (i386_get_cpuid (&ecx, &edx))\n-    return ecx;\n-  else\n-    return 0;\n-}\n-\n-unsigned int NOINLINE\n-i386_cpuid_edx (void)\n-{\n-  unsigned int ecx, edx;\n-  if (i386_get_cpuid (&ecx, &edx))\n-    return edx;\n-  else\n-    return 0;\n-}\n-\n-unsigned int NOINLINE\n-i386_extended_cpuid_ecx (void)\n-{\n-  unsigned int ecx, edx;\n-  if (i386_get_extended_cpuid (&ecx, &edx))\n-    return ecx;\n-  else\n-    return 0;\n-}\n-\n-unsigned int NOINLINE\n-i386_extended_cpuid_edx (void)\n-{\n-  unsigned int ecx, edx;\n-  if (i386_get_extended_cpuid (&ecx, &edx))\n-    return edx;\n-  else\n-    return 0;\n-}\n-\n-static inline unsigned int\n-i386_cpuid (void)\n-{\n-  return i386_cpuid_edx ();\n-}"}, {"sha": "018a1bac7601e298965b5182421bc3cd6ebc871c", "filename": "gcc/testsuite/gcc.dg/torture/pr16104-1.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr16104-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr16104-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr16104-1.c?ref=b3172cabd267a6e6dd535c565cb7be297907f9e8", "patch": "@@ -2,7 +2,7 @@\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-msse2\" } */\n \n-#include \"../i386-cpuid.h\"\n+#include \"cpuid.h\"\n \n extern void abort (void);\n \n@@ -41,12 +41,12 @@ test5 (V2USI x)\n   return (V2SI) x;\n }\n \n-int\n+void\n __attribute__ ((noinline))\n do_test (void)\n {\n   if (sizeof (short) != 2 || sizeof (int) != 4 || sizeof (long long) != 8)\n-    return 0;\n+    return;\n \n   if (test1 () != 0)\n     abort ();\n@@ -70,19 +70,19 @@ do_test (void)\n   u.x = test5 (z);\n   if (u.y[0] != 6 || u.y[1] != 6)\n     abort ();\n-  return 0;\n }\n \n int\n main (void)\n {\n-  unsigned long cpu_facilities;\n-\n-  cpu_facilities = i386_cpuid ();\n-\n-  if ((cpu_facilities & (bit_MMX | bit_SSE | bit_CMOV | bit_SSE2))\n-      != (bit_MMX | bit_SSE | bit_CMOV | bit_SSE2))\n+  unsigned int eax, ebx, ecx, edx;\n+ \n+  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n     return 0;\n \n-  return do_test ();\n+  /* Run SSE2 test only if host has SSE2 support.  */\n+  if (edx & bit_SSE2)\n+    do_test ();\n+\n+  return 0;\n }"}, {"sha": "42c71f632d93103623ec0e8b5e95f094c542330d", "filename": "gcc/testsuite/gcc.target/i386/mmx-4.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmmx-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmmx-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmmx-4.c?ref=b3172cabd267a6e6dd535c565cb7be297907f9e8", "patch": "@@ -16,7 +16,7 @@ typedef union {\n   unsigned int u[2];\n }vecInWord;\n \n-void mmx_tests (void) NOINLINE;\n+void mmx_tests (void) __attribute__((noinline));\n void dump64_16 (char *, char *, vecInWord);\n void dump64_32 (char *, char *, vecInWord);\n void dump64_64 (char *, char *, vecInWord);\n@@ -90,7 +90,7 @@ mmx_test (void)\n     abort ();\n }\n \n-void NOINLINE\n+void __attribute__((noinline))\n mmx_tests (void)\n {\n   /* psraw */"}, {"sha": "aefdc4e8799e4295b7abe3c378ea398e4ad2ab1e", "filename": "gcc/testsuite/gcc.target/i386/mmx-check.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmmx-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmmx-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmmx-check.h?ref=b3172cabd267a6e6dd535c565cb7be297907f9e8", "patch": "@@ -1,20 +1,21 @@\n #include <stdio.h>\n #include <stdlib.h>\n \n-#include \"../../gcc.dg/i386-cpuid.h\"\n+#include \"cpuid.h\"\n \n static void mmx_test (void);\n \n int\n main ()\n {\n-  unsigned long cpu_facilities;\n+  unsigned int eax, ebx, ecx, edx;\n  \n-  cpu_facilities = i386_cpuid_edx ();\n+  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n+    return 0;\n \n   /* Run MMX test only if host has MMX support.  */\n-  if ((cpu_facilities & bit_MMX))\n+  if (edx & bit_MMX)\n     mmx_test ();\n \n-  exit (0);\n+  return 0;\n }"}, {"sha": "1c222df2b2f9a7af10da84151b457899b73aa132", "filename": "gcc/testsuite/gcc.target/i386/sse-10.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-10.c?ref=b3172cabd267a6e6dd535c565cb7be297907f9e8", "patch": "@@ -6,7 +6,7 @@\n \n typedef _Complex double complex_16;\n \n-void NOINLINE\n+void __attribute__((noinline))\n test (complex_16 a[5][5])\n {\n   int i, j, k;"}, {"sha": "f07a8cbc99bbb886e4ea1bfee763d5260aae0989", "filename": "gcc/testsuite/gcc.target/i386/sse-6.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-6.c?ref=b3172cabd267a6e6dd535c565cb7be297907f9e8", "patch": "@@ -16,7 +16,7 @@ typedef union {\n   unsigned char c[16];\n }vecInLong;\n \n-void sse2_tests (void) NOINLINE;\n+void sse2_tests (void) __attribute__((noinline));\n void dump128_16 (char *, char *, vecInLong);\n void dump128_32 (char *, char *, vecInLong);\n void dump128_64 (char *, char *, vecInLong);\n@@ -110,7 +110,7 @@ sse2_test (void)\n     abort ();\n }\n \n-void NOINLINE\n+void __attribute__((noinline))\n sse2_tests (void)\n {\n   /* psraw */"}, {"sha": "12b88ca53f3c01bbac22ce18794b1f0163fc0500", "filename": "gcc/testsuite/gcc.target/i386/sse-7.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-7.c?ref=b3172cabd267a6e6dd535c565cb7be297907f9e8", "patch": "@@ -16,7 +16,7 @@ typedef union {\n   unsigned int u[2];\n }vecInWord;\n \n-void sse_tests (void) NOINLINE;\n+void sse_tests (void) __attribute__((noinline));\n void dump64_16 (char *, char *, vecInWord);\n int check (const char *, const char *[]);\n \n@@ -53,7 +53,7 @@ sse_test (void)\n     abort ();\n }\n \n-void NOINLINE\n+void __attribute__((noinline))\n sse_tests (void)\n {\n   /* pshufw */"}, {"sha": "d485b8dfa0390ab5859891a8e14990cbb6e01978", "filename": "gcc/testsuite/gcc.target/i386/sse-check.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-check.h?ref=b3172cabd267a6e6dd535c565cb7be297907f9e8", "patch": "@@ -1,20 +1,21 @@\n #include <stdio.h>\n #include <stdlib.h>\n \n-#include \"../../gcc.dg/i386-cpuid.h\"\n+#include \"cpuid.h\"\n \n static void sse_test (void);\n \n int\n main ()\n {\n-  unsigned long cpu_facilities;\n+  unsigned int eax, ebx, ecx, edx;\n  \n-  cpu_facilities = i386_cpuid_edx ();\n+  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n+    return 0;\n \n   /* Run SSE test only if host has SSE support.  */\n-  if ((cpu_facilities & bit_SSE))\n+  if (edx & bit_SSE)\n     sse_test ();\n \n-  exit (0);\n+  return 0;\n }"}, {"sha": "007ff543228791194c6cd795afa957f2151c05fc", "filename": "gcc/testsuite/gcc.target/i386/sse2-check.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-check.h?ref=b3172cabd267a6e6dd535c565cb7be297907f9e8", "patch": "@@ -1,20 +1,21 @@\n #include <stdio.h>\n #include <stdlib.h>\n \n-#include \"../../gcc.dg/i386-cpuid.h\"\n+#include \"cpuid.h\"\n \n static void sse2_test (void);\n \n int\n main ()\n {\n-  unsigned long cpu_facilities;\n+  unsigned int eax, ebx, ecx, edx;\n  \n-  cpu_facilities = i386_cpuid_edx ();\n+  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n+    return 0;\n \n   /* Run SSE2 test only if host has SSE2 support.  */\n-  if ((cpu_facilities & bit_SSE2))\n+  if (edx & bit_SSE2)\n     sse2_test ();\n \n-  exit (0);\n+  return 0;\n }"}, {"sha": "92930d10a3fa8528c078ca7f41878a82cbac0698", "filename": "gcc/testsuite/gcc.target/i386/sse3-check.h", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse3-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse3-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse3-check.h?ref=b3172cabd267a6e6dd535c565cb7be297907f9e8", "patch": "@@ -1,19 +1,21 @@\n+#include <stdio.h>\n #include <stdlib.h>\n \n-#include \"../../gcc.dg/i386-cpuid.h\"\n+#include \"cpuid.h\"\n \n static void sse3_test (void);\n \n int\n main ()\n {\n-  unsigned long cpu_facilities;\n+  unsigned int eax, ebx, ecx, edx;\n+ \n+  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n+    return 0;\n  \n-  cpu_facilities = i386_cpuid_ecx ();\n-\n   /* Run SSE3 test only if host has SSE3 support.  */\n-  if ((cpu_facilities & bit_SSE3))\n+  if (ecx & bit_SSE3)\n     sse3_test ();\n \n-  exit (0);\n+  return 0;\n }"}, {"sha": "bac37cb56efa5dc50a03c1e1e120f9e217bf99aa", "filename": "gcc/testsuite/gcc.target/i386/sse4_1-check.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_1-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_1-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_1-check.h?ref=b3172cabd267a6e6dd535c565cb7be297907f9e8", "patch": "@@ -1,6 +1,7 @@\n+#include <stdio.h>\n #include <stdlib.h>\n \n-#include \"../../gcc.dg/i386-cpuid.h\"\n+#include \"cpuid.h\"\n \n static void sse4_1_test (void);\n \n@@ -9,13 +10,14 @@ static void sse4_1_test (void);\n int\n main ()\n {\n-  unsigned long cpu_facilities;\n+  unsigned int eax, ebx, ecx, edx;\n  \n-  cpu_facilities = i386_cpuid_ecx ();\n+  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n+    return 0;\n \n   /* Run SSE4.1 test only if host has SSE4.1 support.  */\n-  if ((cpu_facilities & bit_SSE4_1))\n+  if (ecx & bit_SSE4_1)\n     sse4_1_test ();\n \n-  exit (0);\n+  return 0;\n }"}, {"sha": "2a397e886834a03f8b65e7419f58c68d22cc504d", "filename": "gcc/testsuite/gcc.target/i386/sse4_2-check.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-check.h?ref=b3172cabd267a6e6dd535c565cb7be297907f9e8", "patch": "@@ -1,20 +1,21 @@\n #include <stdio.h>\n #include <stdlib.h>\n \n-#include \"../../gcc.dg/i386-cpuid.h\"\n+#include \"cpuid.h\"\n \n static void sse4_2_test (void);\n \n int\n main ()\n {\n-  unsigned long cpu_facilities;\n+  unsigned int eax, ebx, ecx, edx;\n  \n-  cpu_facilities = i386_cpuid_ecx ();\n+  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n+    return 0;\n \n   /* Run SSE4.2 test only if host has SSE4.2 support.  */\n-  if ((cpu_facilities & bit_SSE4_2))\n+  if (ecx & bit_SSE4_2)\n     sse4_2_test ();\n \n-  exit (0);\n+  return 0;\n }"}, {"sha": "d6140e8969c94ee80f2ccb87124490a7da89221c", "filename": "gcc/testsuite/gcc.target/i386/sse4a-check.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4a-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4a-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4a-check.h?ref=b3172cabd267a6e6dd535c565cb7be297907f9e8", "patch": "@@ -1,20 +1,21 @@\n #include <stdio.h>\n #include <stdlib.h>\n \n-#include \"../../gcc.dg/i386-cpuid.h\"\n+#include \"cpuid.h\"\n \n static void sse4a_test (void);\n \n int\n main ()\n {\n-  unsigned long cpu_facilities;\n+  unsigned int eax, ebx, ecx, edx;\n  \n-  cpu_facilities = i386_extended_cpuid_ecx ();\n+  if (!__get_cpuid (0x80000001, &eax, &ebx, &ecx, &edx))\n+    return 0;\n \n   /* Run SSE4a test only if host has SSE4a support.  */\n-  if ((cpu_facilities & bit_SSE4a))\n+  if (ecx & bit_SSE4a)\n     sse4a_test ();\n \n-  exit (0);\n+  return 0;\n }"}, {"sha": "78df15db7d74600deb42303746b9d0c725dc4097", "filename": "gcc/testsuite/gcc.target/i386/ssse3-check.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fssse3-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3172cabd267a6e6dd535c565cb7be297907f9e8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fssse3-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fssse3-check.h?ref=b3172cabd267a6e6dd535c565cb7be297907f9e8", "patch": "@@ -1,19 +1,21 @@\n+#include <stdio.h>\n #include <stdlib.h>\n \n-#include \"../../gcc.dg/i386-cpuid.h\"\n+#include \"cpuid.h\"\n \n static void ssse3_test (void);\n \n int\n main ()\n {\n-  unsigned long cpu_facilities;\n+  unsigned int eax, ebx, ecx, edx;\n  \n-  cpu_facilities = i386_cpuid_ecx ();\n+  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n+    return 0;\n \n   /* Run SSSE3 test only if host has SSSE3 support.  */\n-  if ((cpu_facilities & bit_SSSE3))\n+  if (ecx & bit_SSSE3)\n     ssse3_test ();\n \n-  exit (0);\n+  return 0;\n }"}, {"sha": "90e40568dec60176d06c956bdfdaf32dc2bf91af", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3172cabd267a6e6dd535c565cb7be297907f9e8/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3172cabd267a6e6dd535c565cb7be297907f9e8/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=b3172cabd267a6e6dd535c565cb7be297907f9e8", "patch": "@@ -1,3 +1,10 @@\n+2007-09-05  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* testsuite/libgomp.c/atomic-1.c: Include cpuid.h for i386 targets.\n+\t(main): Use __get_cpuid to get i386 target fetaures.\n+\t* testsuite/libgomp.c/atomic-2.c: Include cpuid.h for x86_64 targets.\n+\t(main): Use __get_cpuid to get x86_64 target fetaures.\n+\n 2007-08-15  Jack Howarth  <howarth@bromo.med.uc.edu>\n \n \tPR target/32765"}, {"sha": "b2be8f022ea11bba74e7c8d1133eb6940db9ba63", "filename": "libgomp/testsuite/libgomp.c/atomic-1.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3172cabd267a6e6dd535c565cb7be297907f9e8/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3172cabd267a6e6dd535c565cb7be297907f9e8/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-1.c?ref=b3172cabd267a6e6dd535c565cb7be297907f9e8", "patch": "@@ -2,8 +2,7 @@\n /* { dg-options \"-O2 -march=pentium\" { target { { i?86-*-* x86_64-*-* } && ilp32 } } } */\n \n #ifdef __i386__\n-#include \"../../../gcc/testsuite/gcc.dg/i386-cpuid.h\"\n-#define bit_CX8 (1 << 8)\n+#include \"cpuid.h\"\n #endif\n \n extern void abort (void);\n@@ -41,11 +40,12 @@ int\n main (void)\n {\n #ifdef __i386__\n-  unsigned long cpu_facilities;\n+  unsigned int eax, ebx, ecx, edx;\n \n-  cpu_facilities = i386_cpuid ();\n+  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n+    return 0;\n \n-  if (!(cpu_facilities & bit_CX8))\n+  if (!(edx & bit_CMPXCHG8B))\n     return 0;\n #endif\n "}, {"sha": "c8779483b816f078d39ed90ea855927e28af72da", "filename": "libgomp/testsuite/libgomp.c/atomic-2.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3172cabd267a6e6dd535c565cb7be297907f9e8/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3172cabd267a6e6dd535c565cb7be297907f9e8/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-2.c?ref=b3172cabd267a6e6dd535c565cb7be297907f9e8", "patch": "@@ -1,6 +1,10 @@\n /* { dg-do run } */\n /* { dg-options \"-O2 -mcx16\" { target { { i?86-*-* x86_64-*-* } && lp64 } } } */\n \n+#ifdef __x86_64__\n+#include \"cpuid.h\"\n+#endif\n+\n double d = 1.5;\n long double ld = 3;\n extern void abort (void);\n@@ -20,11 +24,12 @@ int\n main (void)\n {\n #ifdef __x86_64__\n-# define bit_CX16 (1 << 13)\n-  unsigned int ax, bx, cx, dx;\n-  __asm__ (\"cpuid\" : \"=a\" (ax), \"=b\" (bx), \"=c\" (cx), \"=d\" (dx)\n-           : \"0\" (1) : \"cc\");\n-  if (!(cx & bit_CX16))\n+  unsigned int eax, ebx, ecx, edx;\n+\n+  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n+    return 0;\n+\n+  if (!(ecx & bit_CMPXCHG16B))\n     return 0;\n #endif\n   test ();"}]}