{"sha": "f614987783f01c11da3c9ea09311404a18f4a6c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjYxNDk4Nzc4M2YwMWMxMWRhM2M5ZWEwOTMxMTQwNGExOGY0YTZjNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-01-05T09:37:02Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-01-05T09:37:02Z"}, "message": "re PR c++/12945 (MIPS g++.old-deja/g++.abi/ptrflags.C fails.)\n\n\tPR target/12945\n\t* coverage.c (coverage_counter_alloc): Set SYMBOL_FLAG_LOCAL for\n\tfor counter labels.\n\t* config/mips/mips.c (INTERNAL_SYMBOL_P): Delete.\n\t(mips_classify_symbol): Always treat SYMBOL_REF_FLAG as indicating\n\tstring constants if TARGET_MIPS16.  Use SYMBOL_REF_DECL to check\n\tthe binding of decl symbols, otherwise check SYMBOL_REF_LOCAL_P.\n\t(mips_symbol_insns): Don't trust the local/global classification.\n\t(m16_usym8_4, m16_usym5_4): Same mips16 change as mips_classify_symbol.\n\t(override_options): Make -mabicalls -fno-unit-at-a-time imply\n\t-mno-explicit-relocs.\n\t(mips_encode_section_info): Don't use SYMBOL_REF_FLAG to distinguish\n\tbetween local and global symbols.\n\nFrom-SVN: r75422", "tree": {"sha": "078985001ae1284e55bddf83530b7699db67b35e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/078985001ae1284e55bddf83530b7699db67b35e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f614987783f01c11da3c9ea09311404a18f4a6c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f614987783f01c11da3c9ea09311404a18f4a6c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f614987783f01c11da3c9ea09311404a18f4a6c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f614987783f01c11da3c9ea09311404a18f4a6c6/comments", "author": null, "committer": null, "parents": [{"sha": "816bc01fa3902979e7cfa1b776e939d0d78a6fe7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/816bc01fa3902979e7cfa1b776e939d0d78a6fe7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/816bc01fa3902979e7cfa1b776e939d0d78a6fe7"}], "stats": {"total": 159, "additions": 91, "deletions": 68}, "files": [{"sha": "be9617248c527462b649c164741d8867054f7289", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f614987783f01c11da3c9ea09311404a18f4a6c6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f614987783f01c11da3c9ea09311404a18f4a6c6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f614987783f01c11da3c9ea09311404a18f4a6c6", "patch": "@@ -1,3 +1,19 @@\n+2004-01-05  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\tPR target/12945\n+\t* coverage.c (coverage_counter_alloc): Set SYMBOL_FLAG_LOCAL for\n+\tfor counter labels.\n+\t* config/mips/mips.c (INTERNAL_SYMBOL_P): Delete.\n+\t(mips_classify_symbol): Always treat SYMBOL_REF_FLAG as indicating\n+\tstring constants if TARGET_MIPS16.  Use SYMBOL_REF_DECL to check\n+\tthe binding of decl symbols, otherwise check SYMBOL_REF_LOCAL_P.\n+\t(mips_symbol_insns): Don't trust the local/global classification.\n+\t(m16_usym8_4, m16_usym5_4): Same mips16 change as mips_classify_symbol.\n+\t(override_options): Make -mabicalls -fno-unit-at-a-time imply\n+\t-mno-explicit-relocs.\n+\t(mips_encode_section_info): Don't use SYMBOL_REF_FLAG to distinguish\n+\tbetween local and global symbols.\n+\n 2004-01-05  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips-protos.h (mips_dangerous_for_la25_p): Declare."}, {"sha": "c59669bc7b6be3b3863ce183b1f9236a14d3228f", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 74, "deletions": 68, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f614987783f01c11da3c9ea09311404a18f4a6c6/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f614987783f01c11da3c9ea09311404a18f4a6c6/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=f614987783f01c11da3c9ea09311404a18f4a6c6", "patch": "@@ -77,10 +77,6 @@ enum internal_test {\n #define SINGLE_WORD_MODE_P(MODE) \\\n   ((MODE) != BLKmode && GET_MODE_SIZE (MODE) <= UNITS_PER_WORD)\n \n-/* True if the given SYMBOL_REF is for an internally-generated symbol.  */\n-#define INTERNAL_SYMBOL_P(SYM) \\\n-  (XSTR (SYM, 0)[0] == '*' && XSTR (SYM, 0)[1] == LOCAL_LABEL_PREFIX[0])\n-\n /* True if X is an unspec wrapper around a SYMBOL_REF or LABEL_REF.  */\n #define UNSPEC_ADDRESS_P(X)\t\t\t\t\t\\\n   (GET_CODE (X) == UNSPEC\t\t\t\t\t\\\n@@ -823,23 +819,44 @@ mips_classify_symbol (rtx x)\n       return SYMBOL_GENERAL;\n     }\n \n-  if (INTERNAL_SYMBOL_P (x))\n-    {\n-      /* The symbol is a local label.  For TARGET_MIPS16, SYMBOL_REF_FLAG\n-\t will be set if the symbol refers to a string in the current\n-\t function's constant pool.  */\n-      if (TARGET_MIPS16 && SYMBOL_REF_FLAG (x))\n-\treturn SYMBOL_CONSTANT_POOL;\n-\n-      if (TARGET_ABICALLS)\n-\treturn SYMBOL_GOT_LOCAL;\n-    }\n-\n   if (SYMBOL_REF_SMALL_P (x))\n     return SYMBOL_SMALL_DATA;\n \n+  /* When generating mips16 code, SYMBOL_REF_FLAG indicates a string\n+     in the current function's constant pool.  */\n+  if (TARGET_MIPS16 && SYMBOL_REF_FLAG (x))\n+    return SYMBOL_CONSTANT_POOL;\n+\n   if (TARGET_ABICALLS)\n-    return (SYMBOL_REF_FLAG (x) ? SYMBOL_GOT_LOCAL : SYMBOL_GOT_GLOBAL);\n+    {\n+      if (SYMBOL_REF_DECL (x) == 0)\n+\treturn SYMBOL_REF_LOCAL_P (x) ? SYMBOL_GOT_LOCAL : SYMBOL_GOT_GLOBAL;\n+\n+      /* There are three cases to consider:\n+\n+            - o32 PIC (either with or without explicit relocs)\n+            - n32/n64 PIC without explicit relocs\n+            - n32/n64 PIC with explicit relocs\n+\n+         In the first case, both local and global accesses will use an\n+         R_MIPS_GOT16 relocation.  We must correctly predict which of\n+         the two semantics (local or global) the assembler and linker\n+         will apply.  The choice doesn't depend on the symbol's\n+         visibility, so we deliberately ignore decl_visibility and\n+         binds_local_p here.\n+\n+         In the second case, the assembler will not use R_MIPS_GOT16\n+         relocations, but it chooses between local and global accesses\n+         in the same way as for o32 PIC.\n+\n+         In the third case we have more freedom since both forms of\n+         access will work for any kind of symbol.  However, there seems\n+         little point in doing things differently.  */\n+      if (DECL_P (SYMBOL_REF_DECL (x)) && TREE_PUBLIC (SYMBOL_REF_DECL (x)))\n+\treturn SYMBOL_GOT_GLOBAL;\n+\n+      return SYMBOL_GOT_LOCAL;\n+    }\n \n   return SYMBOL_GENERAL;\n }\n@@ -1073,27 +1090,28 @@ mips_symbol_insns (enum mips_symbol_type type)\n       return 2;\n \n     case SYMBOL_GOT_LOCAL:\n-      /* For o32 and o64, the sequence is:\n+    case SYMBOL_GOT_GLOBAL:\n+      /* Unless -funit-at-a-time is in effect, we can't be sure whether\n+\t the local/global classification is accurate.  See override_options\n+\t for details.\n \n-\t     lw\t      $at,%got(symbol)\n-\t     nop\n+\t The worst cases are:\n \n-\t and the final address is $at + %lo(symbol).  A load/add\n-\t sequence is also needed for n32 and n64.  Some versions\n-\t of GAS insert a nop in the n32/n64 sequences too so, for\n-\t simplicity, use the worst case of 3 instructions.  */\n-      return 3;\n+\t (1) For local symbols when generating o32 or o64 code.  The assembler\n+\t     will use:\n \n-    case SYMBOL_GOT_GLOBAL:\n-      /* When using a small GOT, we just fetch the address using\n-\t a gp-relative load.   For a big GOT, we need a sequence\n-\t such as:\n+\t\t lw\t      $at,%got(symbol)\n+\t\t nop\n \n-\t      lui     $at,%got_hi(symbol)\n-\t      daddu   $at,$at,$gp\n+\t     ...and the final address will be $at + %lo(symbol).\n \n-\t and the final address is $at + %got_lo(symbol).  */\n-      return (TARGET_XGOT ? 3 : 1);\n+\t (2) For global symbols when -mxgot.  The assembler will use:\n+\n+\t         lui     $at,%got_hi(symbol)\n+\t         (d)addu $at,$at,$gp\n+\n+\t     ...and the final address will be $at + %got_lo(symbol).  */\n+      return 3;\n \n     case SYMBOL_GOTOFF_PAGE:\n     case SYMBOL_GOTOFF_GLOBAL:\n@@ -2078,7 +2096,6 @@ m16_usym8_4 (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n   if (GET_CODE (op) == SYMBOL_REF\n       && SYMBOL_REF_FLAG (op)\n       && cfun->machine->insns_len > 0\n-      && INTERNAL_SYMBOL_P (op)\n       && (cfun->machine->insns_len + get_pool_size () + mips_string_length\n \t  < 4 * 0x100))\n     {\n@@ -2101,7 +2118,6 @@ m16_usym5_4 (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n   if (GET_CODE (op) == SYMBOL_REF\n       && SYMBOL_REF_FLAG (op)\n       && cfun->machine->insns_len > 0\n-      && INTERNAL_SYMBOL_P (op)\n       && (cfun->machine->insns_len + get_pool_size () + mips_string_length\n \t  < 4 * 0x20))\n     {\n@@ -4785,6 +4801,28 @@ override_options (void)\n       && (target_flags_explicit & MASK_EXPLICIT_RELOCS) == 0)\n     target_flags &= ~MASK_EXPLICIT_RELOCS;\n \n+  /* Make -mabicalls -fno-unit-at-a-time imply -mno-explicit-relocs\n+     unless the user says otherwise.\n+\n+     There are two problems here:\n+\n+       (1) The value of an R_MIPS_GOT16 relocation depends on whether\n+\t   the symbol is local or global.  We therefore need to know\n+\t   a symbol's binding before refering to it using %got().\n+\n+       (2) R_MIPS_CALL16 can only be applied to global symbols.\n+\n+     When not using -funit-at-a-time, a symbol's binding may change\n+     after it has been used.  For example, the C++ front-end will\n+     initially assume that the typeinfo for an incomplete type will be\n+     comdat, on the basis that the type could be completed later in the\n+     file.  But if the type never is completed, the typeinfo will become\n+     local instead.  */\n+  if (!flag_unit_at_a_time\n+      && TARGET_ABICALLS\n+      && (target_flags_explicit & MASK_EXPLICIT_RELOCS) == 0)\n+    target_flags &= ~MASK_EXPLICIT_RELOCS;\n+\n   /* -mrnames says to use the MIPS software convention for register\n      names instead of the hardware names (ie, $a0 instead of $4).\n      We do this by switching the names in mips_reg_names, which the\n@@ -7052,10 +7090,7 @@ mips_in_small_data_p (tree decl)\n    constants which are put in the .text section.  We also record the\n    total length of all such strings; this total is used to decide\n    whether we need to split the constant table, and need not be\n-   precisely correct.\n-\n-   When generating -mabicalls code, SYMBOL_REF_FLAG is set if we\n-   should treat the symbol as SYMBOL_GOT_LOCAL.  */\n+   precisely correct.  */\n \n static void\n mips_encode_section_info (tree decl, rtx rtl, int first)\n@@ -7107,35 +7142,6 @@ mips_encode_section_info (tree decl, rtx rtl, int first)\n         SYMBOL_REF_FLAG (symbol) = 1;\n     }\n \n-  else if (TARGET_ABICALLS)\n-    {\n-      /* Mark the symbol if we should treat it as SYMBOL_GOT_LOCAL.\n-         There are three cases to consider:\n-\n-            - o32 PIC (either with or without explicit relocs)\n-            - n32/n64 PIC without explicit relocs\n-            - n32/n64 PIC with explicit relocs\n-\n-         In the first case, both local and global accesses will use an\n-         R_MIPS_GOT16 relocation.  We must correctly predict which of\n-         the two semantics (local or global) the assembler and linker\n-         will apply.  The choice doesn't depend on the symbol's\n-         visibility, so we deliberately ignore decl_visibility and\n-         binds_local_p here.\n-\n-         In the second case, the assembler will not use R_MIPS_GOT16\n-         relocations, but it chooses between local and global accesses\n-         in the same way as for o32 PIC.\n-\n-         In the third case we have more freedom since both forms of\n-         access will work for any kind of symbol.  However, there seems\n-         little point in doing things differently.  */\n-      if (DECL_P (decl) && TREE_PUBLIC (decl))\n-        SYMBOL_REF_FLAG (symbol) = 0;\n-      else\n-        SYMBOL_REF_FLAG (symbol) = 1;\n-    }\n-\n   default_encode_section_info (decl, rtl, first);\n }\n \f"}, {"sha": "05e18149c511221ecd11f8aa3c1d634ac24e1bd4", "filename": "gcc/coverage.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f614987783f01c11da3c9ea09311404a18f4a6c6/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f614987783f01c11da3c9ea09311404a18f4a6c6/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=f614987783f01c11da3c9ea09311404a18f4a6c6", "patch": "@@ -374,6 +374,7 @@ coverage_counter_alloc (unsigned counter, unsigned num)\n \n       ASM_GENERATE_INTERNAL_LABEL (buf, \"LPBX\", counter + 1);\n       ctr_labels[counter] = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (buf));\n+      SYMBOL_REF_FLAGS (ctr_labels[counter]) = SYMBOL_FLAG_LOCAL;\n     }\n   fn_b_ctrs[counter] = fn_n_ctrs[counter];\n   fn_n_ctrs[counter] += num;"}]}