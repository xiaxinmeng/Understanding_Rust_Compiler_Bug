{"sha": "abecc8c6899a68083e567138e48a87bd027cd858", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWJlY2M4YzY4OTlhNjgwODNlNTY3MTM4ZTQ4YTg3YmQwMjdjZDg1OA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2013-05-17T19:23:35Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2013-05-17T19:23:35Z"}, "message": "gengtype-state.c: (s_expr_writer): New class, to handle prettifying of output layout of s-expressions.\n\n2013-05-17  David Malcolm  <dmalcolm@redhat.com>\n\n\t* gengtype-state.c: (s_expr_writer): New class, to handle\n\tprettifying of output layout of s-expressions.\n\t(state_writer): New class, to write out gtype.state.\n\t(state_written_type_count): Move this variable into member data of\n\tstate_writer.\n\t(s_expr_writer::s_expr_writer): New code: constructor for new class\n\t(state_writer::state_writer(): ditto\n\t(s_expr_writer::write_new_line): New function\n\t(s_expr_writer::write_any_indent): ditto\n\t(s_expr_writer::begin_s_expr): ditto\n\t(s_expr_writer::end_s_expr): ditto\n\t(write_state_fileloc): convert to method of state_writer...\n\t(state_writer:: write_state_fileloc): ...and use methods of\n\ts_expr_writer to write indentation into the gtype.state output file\n\tto visually represent the hierarchical structure of the list\n\tstructures\n\t(write_state_fields): ditto, renaming to...\n\t(state_writer::write_state_fields)\n\t(write_state_a_string): ditto, renaming to...\n\t(state_writer::write_state_a_string)\n\t(write_state_string_option): ditto, renaming to...\n\t(state_writer::write_state_string_option)\n\t(write_state_type_option): ditto, renaming to...\n\t(state_writer::write_state_type_option)\n\t(write_state_nested_option): ditto, renaming to...\n\t(state_writer::write_state_nested_option)\n\t(write_state_option): ditto, renaming to...\n\t(state_writer::write_state_option)\n\t(write_state_options): ditto, renaming to...\n\t(state_writer::write_state_options)\n\t(write_state_lang_bitmap): ditto, renaming to...\n\t(state_writer::write_state_lang_bitmap)\n\t(write_state_version): ditto, renaming to...\n\t(state_writer::write_state_version)\n\t(write_state_scalar_type): ditto, renaming to...\n\t(state_writer::write_state_scalar_type)\n\t(write_state_string_type): ditto, renaming to...\n\t(state_writer::write_state_string_type)\n\t(write_state_undefined_type): ditto, renaming to...\n\t(state_writer::write_state_undefined_type)\n\t(write_state_struct_union_type): ditto, renaming to...\n\t(state_writer::write_state_struct_union_type)\n\t(write_state_struct_type): ditto, renaming to...\n\t(state_writer::write_state_struct_type)\n\t(write_state_user_struct_type): ditto, renaming to...\n\t(state_writer::write_state_user_struct_type)\n\t(write_state_lang_struct_type): ditto, renaming to...\n\t(state_writer::write_state_lang_struct_type)\n\t(write_state_param_struct_type): ditto, renaming to...\n\t(state_writer::write_state_param_struct_type)\n\t(write_state_pointer_type): ditto, renaming to...\n\t(state_writer::write_state_pointer_type)\n\t(write_state_array_type): ditto, renaming to...\n\t(state_writer::write_state_array_type)\n\t(write_state_gc_used): ditto, renaming to...\n\t(state_writer::write_state_gc_used)\n\t(write_state_common_type_content): ditto, renaming to...\n\t(state_writer::write_state_common_type_content)\n\t(write_state_type): ditto, renaming to...\n\t(state_writer::write_state_type)\n\t(write_state_pair_list): ditto, renaming to...\n\t(state_writer::write_state_pair_list)\n\t(write_state_pair): ditto, renaming to...\n\t(state_writer::write_state_pair)\n\t(write_state_typedefs): ditto, renaming to...\n\t(state_writer::write_state_typedefs)\n\t(write_state_structures): ditto, renaming to...\n\t(state_writer::write_state_structures)\n\t(write_state_param_structs): ditto, renaming to...\n\t(state_writer::write_state_param_structs)\n\t(write_state_variables): ditto, renaming to...\n\t(state_writer::write_state_variables)\n\t(write_state_srcdir): ditto, renaming to...\n\t(state_writer::write_state_srcdir)\n\t(write_state_files_list): ditto, renaming to...\n\t(state_writer::write_state_files_list)\n\t(write_state_languages): ditto, renaming to...\n\t(state_writer::write_state_languages)\n\t(write_state): create a state_writer instance and use it when\n\twriting out the state file\n\nFrom-SVN: r199032", "tree": {"sha": "5543cff10a5d02aeeda370b3f9cae182cd79a937", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5543cff10a5d02aeeda370b3f9cae182cd79a937"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/abecc8c6899a68083e567138e48a87bd027cd858", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abecc8c6899a68083e567138e48a87bd027cd858", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abecc8c6899a68083e567138e48a87bd027cd858", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abecc8c6899a68083e567138e48a87bd027cd858/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "816a3f734579dfedd49c5f302911d6a1cca97d33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/816a3f734579dfedd49c5f302911d6a1cca97d33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/816a3f734579dfedd49c5f302911d6a1cca97d33"}], "stats": {"total": 546, "additions": 406, "deletions": 140}, "files": [{"sha": "12786cd447ffb84408f5e4f041e12312f0cd3b92", "filename": "gcc/ChangeLog", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abecc8c6899a68083e567138e48a87bd027cd858/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abecc8c6899a68083e567138e48a87bd027cd858/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=abecc8c6899a68083e567138e48a87bd027cd858", "patch": "@@ -1,3 +1,86 @@\n+2013-05-17  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gengtype-state.c: (s_expr_writer): New class, to handle\n+\tprettifying of output layout of s-expressions.\n+\t(state_writer): New class, to write out gtype.state.\n+\t(state_written_type_count): Move this variable into member data of\n+\tstate_writer.\n+\t(s_expr_writer::s_expr_writer): New code: constructor for new class\n+\t(state_writer::state_writer(): ditto\n+\t(s_expr_writer::write_new_line): New function\n+\t(s_expr_writer::write_any_indent): ditto\n+\t(s_expr_writer::begin_s_expr): ditto\n+\t(s_expr_writer::end_s_expr): ditto\n+\t(write_state_fileloc): convert to method of state_writer...\n+\t(state_writer:: write_state_fileloc): ...and use methods of\n+\ts_expr_writer to write indentation into the gtype.state output file\n+\tto visually represent the hierarchical structure of the list\n+\tstructures\n+\t(write_state_fields): ditto, renaming to...\n+\t(state_writer::write_state_fields)\n+\t(write_state_a_string): ditto, renaming to...\n+\t(state_writer::write_state_a_string)\n+\t(write_state_string_option): ditto, renaming to...\n+\t(state_writer::write_state_string_option)\n+\t(write_state_type_option): ditto, renaming to...\n+\t(state_writer::write_state_type_option)\n+\t(write_state_nested_option): ditto, renaming to...\n+\t(state_writer::write_state_nested_option)\n+\t(write_state_option): ditto, renaming to...\n+\t(state_writer::write_state_option)\n+\t(write_state_options): ditto, renaming to...\n+\t(state_writer::write_state_options)\n+\t(write_state_lang_bitmap): ditto, renaming to...\n+\t(state_writer::write_state_lang_bitmap)\n+\t(write_state_version): ditto, renaming to...\n+\t(state_writer::write_state_version)\n+\t(write_state_scalar_type): ditto, renaming to...\n+\t(state_writer::write_state_scalar_type)\n+\t(write_state_string_type): ditto, renaming to...\n+\t(state_writer::write_state_string_type)\n+\t(write_state_undefined_type): ditto, renaming to...\n+\t(state_writer::write_state_undefined_type)\n+\t(write_state_struct_union_type): ditto, renaming to...\n+\t(state_writer::write_state_struct_union_type)\n+\t(write_state_struct_type): ditto, renaming to...\n+\t(state_writer::write_state_struct_type)\n+\t(write_state_user_struct_type): ditto, renaming to...\n+\t(state_writer::write_state_user_struct_type)\n+\t(write_state_lang_struct_type): ditto, renaming to...\n+\t(state_writer::write_state_lang_struct_type)\n+\t(write_state_param_struct_type): ditto, renaming to...\n+\t(state_writer::write_state_param_struct_type)\n+\t(write_state_pointer_type): ditto, renaming to...\n+\t(state_writer::write_state_pointer_type)\n+\t(write_state_array_type): ditto, renaming to...\n+\t(state_writer::write_state_array_type)\n+\t(write_state_gc_used): ditto, renaming to...\n+\t(state_writer::write_state_gc_used)\n+\t(write_state_common_type_content): ditto, renaming to...\n+\t(state_writer::write_state_common_type_content)\n+\t(write_state_type): ditto, renaming to...\n+\t(state_writer::write_state_type)\n+\t(write_state_pair_list): ditto, renaming to...\n+\t(state_writer::write_state_pair_list)\n+\t(write_state_pair): ditto, renaming to...\n+\t(state_writer::write_state_pair)\n+\t(write_state_typedefs): ditto, renaming to...\n+\t(state_writer::write_state_typedefs)\n+\t(write_state_structures): ditto, renaming to...\n+\t(state_writer::write_state_structures)\n+\t(write_state_param_structs): ditto, renaming to...\n+\t(state_writer::write_state_param_structs)\n+\t(write_state_variables): ditto, renaming to...\n+\t(state_writer::write_state_variables)\n+\t(write_state_srcdir): ditto, renaming to...\n+\t(state_writer::write_state_srcdir)\n+\t(write_state_files_list): ditto, renaming to...\n+\t(state_writer::write_state_files_list)\n+\t(write_state_languages): ditto, renaming to...\n+\t(state_writer::write_state_languages)\n+\t(write_state): create a state_writer instance and use it when\n+\twriting out the state file\n+\n 2013-05-17  Mike Stump  <mikestump@comcast.net>\n \n \tPR rtl-optimization/57304"}, {"sha": "c6ecc247a67bf170a63849f664f02114f471a8e0", "filename": "gcc/gengtype-state.c", "status": "modified", "additions": 323, "deletions": 140, "changes": 463, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abecc8c6899a68083e567138e48a87bd027cd858/gcc%2Fgengtype-state.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abecc8c6899a68083e567138e48a87bd027cd858/gcc%2Fgengtype-state.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-state.c?ref=abecc8c6899a68083e567138e48a87bd027cd858", "patch": "@@ -137,9 +137,143 @@ static const char *state_path = NULL;\n static int state_line = 0;\n static long state_bol = 0;\t/* offset of beginning of line */\n \n+/* A class for writing out s-expressions, keeping track of newlines and\n+   nested indentation.  */\n+class s_expr_writer\n+{\n+public:\n+  s_expr_writer();\n+\n+  void write_new_line ();\n+  void write_any_indent (int leading_spaces);\n+\n+  void begin_s_expr (const char *tag);\n+  void end_s_expr ();\n+\n+private:\n+  int indent_amount_;\n+  int had_recent_newline_;\n+}; // class s_expr_writer\n+\n+/* A class for writing out \"gtype.state\".  */\n+class state_writer : public s_expr_writer\n+{\n+public:\n+  state_writer();\n+\n+private:\n+  void write_state_fileloc (struct fileloc *floc);\n+  void write_state_fields (pair_p fields);\n+  void write_state_a_string (const char *s);\n+  void write_state_string_option (options_p current);\n+  void write_state_type_option (options_p current);\n+  void write_state_nested_option (options_p current);\n+  void write_state_option (options_p current);\n+  void write_state_options (options_p opt);\n+  void write_state_lang_bitmap (lang_bitmap bitmap);\n+  void write_state_version (const char *version);\n+  void write_state_scalar_type (type_p current);\n+  void write_state_string_type (type_p current);\n+  void write_state_undefined_type (type_p current);\n+  void write_state_struct_union_type (type_p current, const char *kindstr);\n+  void write_state_struct_type (type_p current);\n+  void write_state_user_struct_type (type_p current);\n+  void write_state_union_type (type_p current);\n+  void write_state_lang_struct_type (type_p current);\n+  void write_state_param_struct_type (type_p current);\n+  void write_state_pointer_type (type_p current);\n+  void write_state_array_type (type_p current);\n+  void write_state_gc_used (enum gc_used_enum gus);\n+  void write_state_common_type_content (type_p current);\n+  void write_state_type (type_p current);\n+  void write_state_pair (pair_p current);\n+  int write_state_pair_list (pair_p list);\n+  void write_state_typedefs (void);\n+  void write_state_structures (void);\n+  void write_state_param_structs (void);\n+  void write_state_variables (void);\n+  void write_state_srcdir (void);\n+  void write_state_files_list (void);\n+  void write_state_languages (void);\n+\n+  friend void write_state (const char *state_path);\n+\n+private:\n+  /* Counter of written types.  */\n+  int state_written_type_count;\n+}; // class state_writer\n+\n+\n+/* class s_expr_writer's trivial constructor.  */\n+s_expr_writer::s_expr_writer()\n+  : indent_amount_(0),\n+    had_recent_newline_(0)\n+{\n+}\n+\n+/* Write a newline to the output file, merging adjacent newlines.  */\n+void\n+s_expr_writer::write_new_line (void)\n+{\n+  /* Don't add a newline if we've just had one.  */\n+  if (!had_recent_newline_)\n+    {\n+      fprintf (state_file, \"\\n\");\n+      had_recent_newline_ = 1;\n+    }\n+}\n+\n+/* If we've just had a newline, write the indentation amount, potentially\n+   omitting some spaces.\n \n-/* Counter of written types.  */\n-static int state_written_type_count = 0;\n+   LEADING_SPACES exists to support code that writes strings with leading\n+   spaces (e.g \" foo\") which might occur within a line, or could be the first\n+   thing on a line.  By passing leading_spaces == 1, when such a string is the\n+   first thing on a line, write_any_indent () swallows the successive\n+   leading spaces into the indentation so that the \"foo\" begins at the expected\n+   column.  */\n+void\n+s_expr_writer::write_any_indent (int leading_spaces)\n+{\n+  int i;\n+  int amount = indent_amount_ - leading_spaces;\n+  if (had_recent_newline_)\n+    for (i = 0; i < amount; i++)\n+      fprintf (state_file, \" \");\n+  had_recent_newline_ = 0;\n+}\n+\n+/* Write the beginning of a new s-expresion e.g. \"(!foo \"\n+   The writer automatically adds whitespace to show the hierachical\n+   structure of the expressions, so each one starts on a new line,\n+   and any within it will be at an increased indentation level.  */\n+void\n+s_expr_writer::begin_s_expr (const char *tag)\n+{\n+  write_new_line ();\n+  write_any_indent (0);\n+  fprintf (state_file, \"(!%s \", tag);\n+  indent_amount_++;\n+}\n+\n+/* Write out the end of an s-expression: any necssessary indentation,\n+   a closing parenthesis, and a new line.  */\n+void\n+s_expr_writer::end_s_expr (void)\n+{\n+  indent_amount_--;\n+  write_any_indent (0);\n+  fprintf (state_file, \")\");\n+  write_new_line ();\n+}\n+\n+\n+/* class state_writer's trivial constructor.  */\n+state_writer::state_writer()\n+  : s_expr_writer(),\n+    state_written_type_count(0)\n+{\n+}\n \n \n /* Fatal error messages when reading the state.  They are extremely\n@@ -519,22 +653,6 @@ static htab_t state_seen_types;\n /* Return the length of a linked list made of pairs.  */\n static int pair_list_length (pair_p list);\n \n-/* Write a pair */\n-static void write_state_pair (pair_p);\n-\n-/* return the number of pairs written.  Should match the length given\n-   by pair_list_length.  */\n-static int write_state_pair_list (pair_p list);\n-\n-/* Write a type.  When a type is written, its state_number is updated,\n-   to ensure that a \"reference\" to a seen type is written on next\n-   occurrences.  */\n-static void write_state_type (type_p);\n-\n-/* Write a null-terminatel string using our Lispy lexical conventions,\n-   similar to those of C or MELT.  */\n-static void write_state_a_string (const char *s);\n-\n /* Compute the length of a list of pairs, starting from the first\n    one.  */\n static int\n@@ -552,8 +670,8 @@ pair_list_length (pair_p list)\n    state file-s produced by gengtype on the same GCC source tree are\n    very similar and can be reasonably compared with diff, even if the\n    two GCC source trees have different absolute paths.  */\n-static void\n-write_state_fileloc (struct fileloc *floc)\n+void\n+state_writer::write_state_fileloc (struct fileloc *floc)\n {\n \n   if (floc != NULL && floc->line > 0)\n@@ -565,40 +683,43 @@ write_state_fileloc (struct fileloc *floc)\n       srcrelpath = get_file_srcdir_relative_path (floc->file);\n       if (srcrelpath != NULL)\n \t{\n-\t  fprintf (state_file, \"\\n(!srcfileloc \");\n+\t  begin_s_expr (\"srcfileloc\");\n \t  write_state_a_string (srcrelpath);\n \t}\n       else\n \t{\n-\t  fprintf (state_file, \"\\n(!fileloc \");\n+\t  begin_s_expr (\"fileloc\");\n \t  write_state_a_string (get_input_file_name (floc->file));\n \t}\n       fprintf (state_file, \" %d\", floc->line);\n-      fprintf (state_file, \")\\n\");\n+      end_s_expr ();\n     }\n   else\n     fprintf (state_file, \"nil \");\n }\n \n /* Write a list of fields.  */\n-static void\n-write_state_fields (pair_p fields)\n+void\n+state_writer::write_state_fields (pair_p fields)\n {\n   int nbfields = pair_list_length (fields);\n   int nbpairs = 0;\n-  fprintf (state_file, \"\\n(!fields %d \", nbfields);\n+  begin_s_expr (\"fields\");\n+  fprintf (state_file, \"%d \", nbfields);\n   nbpairs = write_state_pair_list (fields);\n   gcc_assert (nbpairs == nbfields);\n-  fprintf (state_file, \")\\n\");\n+  end_s_expr ();\n }\n \n /* Write a null-terminated string in our lexical convention, very\n    similar to the convention of C.  */\n-static void\n-write_state_a_string (const char *s)\n+void\n+state_writer::write_state_a_string (const char *s)\n {\n   char c;\n \n+  write_any_indent (1);\n+\n   fputs (\" \\\"\", state_file);\n   for (; *s != 0; s++)\n     {\n@@ -643,44 +764,54 @@ write_state_a_string (const char *s)\n }\n \n /* Our option-s have three kinds, each with its writer.  */\n-static void\n-write_state_string_option (options_p current)\n+void\n+state_writer::write_state_string_option (options_p current)\n {\n+  write_any_indent (0);\n   fprintf (state_file, \"string \");\n   if (current->info.string != NULL)\n     write_state_a_string (current->info.string);\n   else\n     fprintf (state_file, \" nil \");\n }\n \n-static void\n-write_state_type_option (options_p current)\n+void\n+state_writer::write_state_type_option (options_p current)\n {\n+  write_any_indent (0);\n   fprintf (state_file, \"type \");\n   write_state_type (current->info.type);\n }\n \n-static void\n-write_state_nested_option (options_p current)\n+void\n+state_writer::write_state_nested_option (options_p current)\n {\n+  write_any_indent (0);\n   fprintf (state_file, \"nested \");\n   write_state_type (current->info.nested->type);\n   if (current->info.nested->convert_from != NULL)\n     write_state_a_string (current->info.nested->convert_from);\n   else\n-    fprintf (state_file, \" nil \");\n+    {\n+      write_any_indent (1);\n+      fprintf (state_file, \" nil \");\n+    }\n \n   if (current->info.nested->convert_to != NULL)\n     write_state_a_string (current->info.nested->convert_to);\n   else\n-    fprintf (state_file, \" nil \");\n+    {\n+      write_any_indent (1);\n+      fprintf (state_file, \" nil \");\n+    }\n }\n \n-static void\n-write_state_option (options_p current)\n+void\n+state_writer::write_state_option (options_p current)\n {\n-  fprintf (state_file, \"\\n(!option \");\n+  begin_s_expr (\"option\");\n \n+  write_any_indent (0);\n   if (current->name != NULL)\n     fprintf (state_file, \"%s \", current->name);\n   else\n@@ -701,53 +832,54 @@ write_state_option (options_p current)\n       fatal (\"Option tag unknown\");\n     }\n \n-  fprintf (state_file, \")\\n\");\n+  /* Terminate the \"option\" s-expression.  */\n+  end_s_expr ();\n }\n \n \n \n /* Write a list of GTY options.  */\n-static void\n-write_state_options (options_p opt)\n+void\n+state_writer::write_state_options (options_p opt)\n {\n   options_p current;\n \n   if (opt == NULL)\n     {\n-      fprintf (state_file, \"nil \");\n+\twrite_any_indent (0);\n+\tfprintf (state_file, \"nil \");\n       return;\n     }\n \n-  fprintf (state_file, \"\\n(!options \");\n+  begin_s_expr (\"options\");\n   for (current = opt; current != NULL; current = current->next)\n       write_state_option (current);\n-  fprintf (state_file, \")\\n\");\n+  end_s_expr ();\n }\n \n \n /* Write a bitmap representing a set of GCC front-end languages.  */\n-static void\n-write_state_lang_bitmap (lang_bitmap bitmap)\n+void\n+state_writer::write_state_lang_bitmap (lang_bitmap bitmap)\n {\n+  write_any_indent (0);\n   fprintf (state_file, \"%d \", (int) bitmap);\n }\n \n /* Write version information.  */\n-static void\n-write_state_version (const char *version)\n+void\n+state_writer::write_state_version (const char *version)\n {\n-  fprintf (state_file, \"\\n(!version \");\n+  begin_s_expr (\"version\");\n   write_state_a_string (version);\n-  fprintf (state_file, \")\\n\");\n+  end_s_expr ();\n }\n \n-/* Common routine to write the common content of all types.  */\n-static void write_state_common_type_content (type_p current);\n-\n /* Write a scalar type.  We have only two of these.  */\n-static void\n-write_state_scalar_type (type_p current)\n+void\n+state_writer::write_state_scalar_type (type_p current)\n {\n+  write_any_indent (0);\n   if (current == &scalar_nonchar)\n     fprintf (state_file, \"scalar_nonchar \");\n   else if (current == &scalar_char)\n@@ -759,11 +891,12 @@ write_state_scalar_type (type_p current)\n }\n \n /* Write the string type.  There is only one such thing! */\n-static void\n-write_state_string_type (type_p current)\n+void\n+state_writer::write_state_string_type (type_p current)\n {\n   if (current == &string_type)\n     {\n+      write_any_indent (0);\n       fprintf (state_file, \"string \");\n       write_state_common_type_content (current);\n     }\n@@ -772,35 +905,44 @@ write_state_string_type (type_p current)\n }\n \n /* Write an undefined type.  */\n-static void\n-write_state_undefined_type (type_p current)\n+void\n+state_writer::write_state_undefined_type (type_p current)\n {\n   DBGPRINTF (\"undefined type @ %p #%d '%s'\", (void *) current,\n \t     current->state_number, current->u.s.tag);\n+  write_any_indent (0);\n   fprintf (state_file, \"undefined \");\n   gcc_assert (current->gc_used == GC_UNUSED);\n   write_state_common_type_content (current);\n   if (current->u.s.tag != NULL)\n     write_state_a_string (current->u.s.tag);\n   else\n-    fprintf (state_file, \"nil\");\n+    {\n+      write_any_indent (0);\n+      fprintf (state_file, \"nil\");\n+    }\n \n   write_state_fileloc (type_lineloc (current));\n }\n \n \n /* Common code to write structure like types.  */\n-static void\n-write_state_struct_union_type (type_p current, const char *kindstr)\n+void\n+state_writer::write_state_struct_union_type (type_p current,\n+\t\t\t\t\t     const char *kindstr)\n {\n   DBGPRINTF (\"%s type @ %p #%d '%s'\", kindstr, (void *) current,\n \t     current->state_number, current->u.s.tag);\n+  write_any_indent (0);\n   fprintf (state_file, \"%s \", kindstr);\n   write_state_common_type_content (current);\n   if (current->u.s.tag != NULL)\n     write_state_a_string (current->u.s.tag);\n   else\n-    fprintf (state_file, \"nil\");\n+    {\n+      write_any_indent (0);\n+      fprintf (state_file, \"nil\");\n+    }\n \n   write_state_fileloc (type_lineloc (current));\n   write_state_fields (current->u.s.fields);\n@@ -810,32 +952,36 @@ write_state_struct_union_type (type_p current, const char *kindstr)\n \n \n /* Write a GTY struct type.  */\n-static void\n-write_state_struct_type (type_p current)\n+void\n+state_writer::write_state_struct_type (type_p current)\n {\n   write_state_struct_union_type (current, \"struct\");\n   write_state_type (current->u.s.lang_struct);\n }\n \n /* Write a GTY user-defined struct type.  */\n-static void\n-write_state_user_struct_type (type_p current)\n+void\n+state_writer::write_state_user_struct_type (type_p current)\n {\n   DBGPRINTF (\"user_struct type @ %p #%d '%s'\", (void *) current,\n \t     current->state_number, current->u.s.tag);\n+  write_any_indent (0);\n   fprintf (state_file, \"user_struct \");\n   write_state_common_type_content (current);\n   if (current->u.s.tag != NULL)\n     write_state_a_string (current->u.s.tag);\n   else\n-    fprintf (state_file, \"nil\");\n+    {\n+      write_any_indent (0);\n+      fprintf (state_file, \"nil\");\n+    }\n   write_state_fileloc (type_lineloc (current));\n   write_state_fields (current->u.s.fields);\n }\n \n /* write a GTY union type.  */\n-static void\n-write_state_union_type (type_p current)\n+void\n+state_writer::write_state_union_type (type_p current)\n {\n   write_state_struct_union_type (current, \"union\");\n   write_state_type (current->u.s.lang_struct);\n@@ -846,8 +992,8 @@ write_state_union_type (type_p current)\n    subfield, which points to a linked list of homonumous types.\n    Change this function with extreme care, see also\n    read_state_lang_struct_type.  */\n-static void\n-write_state_lang_struct_type (type_p current)\n+void\n+state_writer::write_state_lang_struct_type (type_p current)\n {\n   int nbhomontype = 0;\n   type_p hty = NULL;\n@@ -869,18 +1015,20 @@ write_state_lang_struct_type (type_p current)\n \thomoname = hty->u.s.tag;\n       gcc_assert (strcmp (homoname, hty->u.s.tag) == 0);\n     }\n-  fprintf (state_file, \"(!homotypes %d\\n\", nbhomontype);\n+  begin_s_expr (\"homotypes\");\n+  fprintf (state_file, \"%d\", nbhomontype);\n   for (hty = current->u.s.lang_struct; hty != NULL; hty = hty->next)\n     write_state_type (hty);\n-  fprintf (state_file, \")\\n\");\n+  end_s_expr ();\n }\n \n /* Write a parametrized structure GTY type.  */\n-static void\n-write_state_param_struct_type (type_p current)\n+void\n+state_writer::write_state_param_struct_type (type_p current)\n {\n   int i;\n \n+  write_any_indent (0);\n   fprintf (state_file, \"param_struct \");\n   write_state_common_type_content (current);\n   write_state_type (current->u.param_struct.stru);\n@@ -889,39 +1037,49 @@ write_state_param_struct_type (type_p current)\n       if (current->u.param_struct.param[i] != NULL)\n \twrite_state_type (current->u.param_struct.param[i]);\n       else\n-\tfprintf (state_file, \"nil \");\n+\t{\n+\t  write_any_indent (0);\n+\t  fprintf (state_file, \"nil \");\n+\t}\n     }\n   write_state_fileloc (&current->u.param_struct.line);\n }\n \n /* Write a pointer type.  */\n-static void\n-write_state_pointer_type (type_p current)\n+void\n+state_writer::write_state_pointer_type (type_p current)\n {\n+  write_any_indent (0);\n   fprintf (state_file, \"pointer \");\n   write_state_common_type_content (current);\n   write_state_type (current->u.p);\n }\n \n /* Write an array type.  */\n-static void\n-write_state_array_type (type_p current)\n+void\n+state_writer::write_state_array_type (type_p current)\n {\n+  write_any_indent (0);\n   fprintf (state_file, \"array \");\n   write_state_common_type_content (current);\n   if (current->u.a.len != NULL)\n     write_state_a_string (current->u.a.len);\n   else\n-    fprintf (state_file, \" nil\");\n+    {\n+      write_any_indent (1);\n+      fprintf (state_file, \" nil\");\n+    }\n \n+  write_any_indent (1);\n   fprintf (state_file, \" \");\n   write_state_type (current->u.a.p);\n }\n \n /* Write the gc_used information.  */\n-static void\n-write_state_gc_used (enum gc_used_enum gus)\n+void\n+state_writer::write_state_gc_used (enum gc_used_enum gus)\n {\n+  write_any_indent (1);\n   switch (gus)\n     {\n     case GC_UNUSED:\n@@ -943,9 +1101,10 @@ write_state_gc_used (enum gc_used_enum gus)\n \n /* Utility routine to write the common content of all types.  Notice\n    that the next field is *not* written on purpose.  */\n-static void\n-write_state_common_type_content (type_p current)\n+void\n+state_writer::write_state_common_type_content (type_p current)\n {\n+  write_any_indent (0);\n   fprintf (state_file, \"%d \", current->state_number);\n   /* We do not write the next type, because list of types are\n      explicitly written.  However, lang_struct are special in that\n@@ -958,19 +1117,23 @@ write_state_common_type_content (type_p current)\n /* The important and recursive routine writing GTY types as understood\n    by gengtype.  Types which have a positive state_number have already\n    been seen and written.  */\n-static void\n-write_state_type (type_p current)\n+void\n+state_writer::write_state_type (type_p current)\n {\n+  write_any_indent (0);\n   if (current == NULL)\n     {\n       fprintf (state_file, \"nil \");\n       return;\n     }\n \n-  fprintf (state_file, \"\\n(!type \");\n+  begin_s_expr (\"type\");\n \n   if (current->state_number > 0)\n-    fprintf (state_file, \"already_seen %d\", current->state_number);\n+    {\n+      write_any_indent (0);\n+      fprintf (state_file, \"already_seen %d\", current->state_number);\n+    }\n   else\n     {\n       state_written_type_count++;\n@@ -1014,21 +1177,23 @@ write_state_type (type_p current)\n \t}\n     }\n \n-  fprintf (state_file, \")\\n\");\n+  /* Terminate the \"type\" s-expression.  */\n+  end_s_expr ();\n }\n \n \n /* Write a pair.  */\n-static void\n-write_state_pair (pair_p current)\n+void\n+state_writer::write_state_pair (pair_p current)\n {\n   if (current == NULL)\n     {\n+      write_any_indent (0);\n       fprintf (state_file, \"nil)\");\n       return;\n     }\n \n-  fprintf (state_file, \"\\n(!pair \");\n+  begin_s_expr (\"pair\");\n \n   if (current->name != NULL)\n     write_state_a_string (current->name);\n@@ -1039,12 +1204,13 @@ write_state_pair (pair_p current)\n   write_state_fileloc (&(current->line));\n   write_state_options (current->opt);\n \n-  fprintf (state_file, \")\");\n+  /* Terminate the \"pair\" s-expression.  */\n+  end_s_expr ();\n }\n \n /* Write a pair list and return the number of pairs written.  */\n-static int\n-write_state_pair_list (pair_p list)\n+int\n+state_writer::write_state_pair_list (pair_p list)\n {\n   int nbpair = 0;\n   pair_p current;\n@@ -1064,88 +1230,97 @@ write_state_pair_list (pair_p list)\n    of actually read items.  */\n \n /* Write our typedefs.  */\n-static void\n-write_state_typedefs (void)\n+void\n+state_writer::write_state_typedefs (void)\n {\n   int nbtypedefs = pair_list_length (typedefs);\n   int nbpairs = 0;\n-  fprintf (state_file, \"\\n(!typedefs %d\\n\", nbtypedefs);\n+  begin_s_expr (\"typedefs\");\n+  fprintf (state_file, \"%d\", nbtypedefs);\n   nbpairs = write_state_pair_list (typedefs);\n   gcc_assert (nbpairs == nbtypedefs);\n-  fprintf (state_file, \")\\n\");\n+  end_s_expr ();\n   if (verbosity_level >= 2)\n     printf (\"%s wrote %d typedefs\\n\", progname, nbtypedefs);\n }\n \n /* Write our structures.  */\n-static void\n-write_state_structures (void)\n+void\n+state_writer::write_state_structures (void)\n {\n   int nbstruct = 0;\n   type_p current;\n \n   for (current = structures; current != NULL; current = current->next)\n     nbstruct++;\n \n-  fprintf (state_file, \"\\n(!structures %d\\n\", nbstruct);\n+  begin_s_expr (\"structures\");\n+  fprintf (state_file, \"%d\", nbstruct);\n \n   for (current = structures; current != NULL; current = current->next)\n-    write_state_type (current);\n+    {\n+      write_new_line ();\n+      write_state_type (current);\n+    }\n \n-  fprintf (state_file, \")\\n\");\n+  /* Terminate the \"structures\" s-expression.  */\n+  end_s_expr ();\n   if (verbosity_level >= 2)\n     printf (\"%s wrote %d structures in state\\n\", progname, nbstruct);\n }\n \n /* Write our param_struct-s.  */\n-static void\n-write_state_param_structs (void)\n+void\n+state_writer::write_state_param_structs (void)\n {\n   int nbparamstruct = 0;\n   type_p current;\n \n   for (current = param_structs; current != NULL; current = current->next)\n     nbparamstruct++;\n \n-  fprintf (state_file, \"\\n(!param_structs %d\\n\", nbparamstruct);\n+  begin_s_expr (\"param_structs\");\n+  fprintf (state_file, \"%d\", nbparamstruct);\n \n   for (current = param_structs; current != NULL; current = current->next)\n     write_state_type (current);\n \n-  fprintf (state_file, \")\\n\");\n+  end_s_expr ();\n }\n \n /* Write our variables.  */\n-static void\n-write_state_variables (void)\n+void\n+state_writer::write_state_variables (void)\n {\n   int nbvars = pair_list_length (variables);\n   int nbpairs = 0;\n-  fprintf (state_file, \"\\n(!variables %d\\n\", nbvars);\n+  begin_s_expr (\"variables\");\n+  fprintf (state_file, \"%d\", nbvars);\n   nbpairs = write_state_pair_list (variables);\n   gcc_assert (nbpairs == nbvars);\n-  fprintf (state_file, \")\\n\");\n+  end_s_expr ();\n   if (verbosity_level >= 2)\n     printf (\"%s wrote %d variables.\\n\", progname, nbvars);\n }\n \n /* Write the source directory.  File locations within the source\n    directory have been written specifically.  */\n-static void\n-write_state_srcdir (void)\n+void\n+state_writer::write_state_srcdir (void)\n {\n-  fprintf (state_file, \"\\n(!srcdir \");\n+  begin_s_expr (\"srcdir\");\n   write_state_a_string (srcdir);\n-  fprintf (state_file, \")\\n\");\n+  end_s_expr ();\n }\n \n /* Count and write the list of our files.  */\n-static void\n-write_state_files_list (void)\n+void\n+state_writer::write_state_files_list (void)\n {\n   int i = 0;\n   /* Write the list of files with their lang_bitmap.  */\n-  fprintf (state_file, \"\\n(!fileslist %d\\n\", (int) num_gt_files);\n+  begin_s_expr (\"fileslist\");\n+  fprintf (state_file, \"%d\", (int) num_gt_files);\n   for (i = 0; i < (int) num_gt_files; i++)\n     {\n       const char *cursrcrelpath = NULL;\n@@ -1155,33 +1330,38 @@ write_state_files_list (void)\n       cursrcrelpath = get_file_srcdir_relative_path (curfil);\n       if (cursrcrelpath)\n \t{\n-\t  fprintf (state_file, \"(!srcfile %d \", get_lang_bitmap (curfil));\n+\t  begin_s_expr (\"srcfile\");\n+\t  fprintf (state_file, \"%d \", get_lang_bitmap (curfil));\n \t  write_state_a_string (cursrcrelpath);\n \t}\n       else\n \t{\n-\t  fprintf (state_file, \"(!file %d \", get_lang_bitmap (curfil));\n+\t  begin_s_expr (\"file\");\n+\t  fprintf (state_file, \"%d \", get_lang_bitmap (curfil));\n \t  write_state_a_string (get_input_file_name (curfil));\n \t}\n-      fprintf (state_file, \")\\n\");\n+      /* Terminate the inner s-expression (either \"srcfile\" or \"file\").   */\n+      end_s_expr ();\n     }\n-  fprintf (state_file, \")\\n\");\n+  /* Terminate the \"fileslist\" s-expression.  */\n+  end_s_expr ();\n }\n \n /* Write the list of GCC front-end languages.  */\n-static void\n-write_state_languages (void)\n+void\n+state_writer::write_state_languages (void)\n {\n   int i = 0;\n-  fprintf (state_file, \"\\n(!languages %d\", (int) num_lang_dirs);\n+  begin_s_expr (\"languages\");\n+  fprintf (state_file, \"%d\", (int) num_lang_dirs);\n   for (i = 0; i < (int) num_lang_dirs; i++)\n     {\n       /* Languages names are identifiers, we expect only letters or\n          underscores or digits in them.  In particular, C++ is not a\n          valid language name, but cp is valid.  */\n       fprintf (state_file, \" %s\", lang_dir_names[i]);\n     }\n-  fprintf (state_file, \")\\n\");\n+  end_s_expr ();\n }\n \n /* Write the trailer.  */\n@@ -1234,15 +1414,18 @@ write_state (const char *state_path)\n   fprintf (state_file,\n \t   \";;; This file should be parsed by the same %s which wrote it.\\n\",\n \t   progname);\n+\n+  state_writer sw;\n+\n   /* The first non-comment significant line gives the version string.  */\n-  write_state_version (version_string);\n-  write_state_srcdir ();\n-  write_state_languages ();\n-  write_state_files_list ();\n-  write_state_structures ();\n-  write_state_typedefs ();\n-  write_state_param_structs ();\n-  write_state_variables ();\n+  sw.write_state_version (version_string);\n+  sw.write_state_srcdir ();\n+  sw.write_state_languages ();\n+  sw.write_state_files_list ();\n+  sw.write_state_structures ();\n+  sw.write_state_typedefs ();\n+  sw.write_state_param_structs ();\n+  sw.write_state_variables ();\n   write_state_trailer ();\n   statelen = ftell (state_file);\n   if (ferror (state_file))\n@@ -1258,7 +1441,7 @@ write_state (const char *state_path)\n \n   if (verbosity_level >= 1)\n     printf (\"%s wrote state file %s of %ld bytes with %d GTY-ed types\\n\",\n-\t    progname, state_path, statelen, state_written_type_count);\n+\t    progname, state_path, statelen, sw.state_written_type_count);\n \n }\n \f"}]}