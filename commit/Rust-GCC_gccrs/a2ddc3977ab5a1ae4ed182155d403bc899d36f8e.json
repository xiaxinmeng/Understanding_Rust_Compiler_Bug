{"sha": "a2ddc3977ab5a1ae4ed182155d403bc899d36f8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTJkZGMzOTc3YWI1YTFhZTRlZDE4MjE1NWQ0MDNiYzg5OWQzNmY4ZQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-01-27T23:29:50Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-01-27T23:29:50Z"}, "message": "class.c (update_vtable_entry_for_fn): Add index parameter.\n\ncp:\n\t* class.c (update_vtable_entry_for_fn): Add index parameter.\n\tGenerate vcall thunk for covariant overriding from a virtual\n\tprimary base.\n\t(dfs_modify_vtables): Adjust.\ntestsuite:\n\t* g++.dg/abi/covariant1.C: New test.\n\nFrom-SVN: r61906", "tree": {"sha": "8e39b79228ad7ed3404e2df8d393ba7858475af2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e39b79228ad7ed3404e2df8d393ba7858475af2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2ddc3977ab5a1ae4ed182155d403bc899d36f8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2ddc3977ab5a1ae4ed182155d403bc899d36f8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2ddc3977ab5a1ae4ed182155d403bc899d36f8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2ddc3977ab5a1ae4ed182155d403bc899d36f8e/comments", "author": null, "committer": null, "parents": [{"sha": "23af32e6ea2031cb4bffc1edc8d0368d5e5dfada", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23af32e6ea2031cb4bffc1edc8d0368d5e5dfada", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23af32e6ea2031cb4bffc1edc8d0368d5e5dfada"}], "stats": {"total": 85, "additions": 75, "deletions": 10}, "files": [{"sha": "180fccb2fbf1dd82d15edc22fd07d0b91cf20596", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ddc3977ab5a1ae4ed182155d403bc899d36f8e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ddc3977ab5a1ae4ed182155d403bc899d36f8e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a2ddc3977ab5a1ae4ed182155d403bc899d36f8e", "patch": "@@ -1,3 +1,10 @@\n+2003-01-27  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* class.c (update_vtable_entry_for_fn): Add index parameter.\n+\tGenerate vcall thunk for covariant overriding from a virtual\n+\tprimary base.\n+\t(dfs_modify_vtables): Adjust.\n+\n 2003-01-25  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/9403"}, {"sha": "6cdcb9a5b788154c7724e83b307e4e94d65690af", "filename": "gcc/cp/class.c", "status": "modified", "additions": 43, "deletions": 10, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ddc3977ab5a1ae4ed182155d403bc899d36f8e/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ddc3977ab5a1ae4ed182155d403bc899d36f8e/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=a2ddc3977ab5a1ae4ed182155d403bc899d36f8e", "patch": "@@ -190,7 +190,7 @@ static void mark_primary_bases (tree);\n static tree mark_primary_virtual_base (tree, tree);\n static void clone_constructors_and_destructors (tree);\n static tree build_clone (tree, tree);\n-static void update_vtable_entry_for_fn (tree, tree, tree, tree *);\n+static void update_vtable_entry_for_fn (tree, tree, tree, tree *, unsigned);\n static tree copy_virtuals (tree);\n static void build_ctor_vtbl_group (tree, tree);\n static void build_vtt (tree);\n@@ -2395,7 +2395,8 @@ get_vcall_index (tree fn, tree type)\n    corresponding position in the BINFO_VIRTUALS list.  */\n \n static void\n-update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals)\n+update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n+\t\t\t    unsigned ix)\n {\n   tree b;\n   tree overrider;\n@@ -2479,7 +2480,7 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals)\n \t      \n \t\t  virtual_offset = binfo_for_vbase (BINFO_TYPE (thunk_binfo),\n \t\t\t\t\t\t    TREE_TYPE (over_return));\n-\t\t  offset = size_diffop (offset,\n+\t\t  offset = size_binop (MINUS_EXPR, offset,\n \t\t\t\t\tBINFO_OFFSET (virtual_offset));\n \t\t}\n \t      if (fixed_offset)\n@@ -2523,6 +2524,38 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals)\n \tvirtual_base = b;\n     }\n \n+  if (overrider_fn != overrider_target && !virtual_base)\n+    {\n+      /* The ABI specifies that a covariant thunk includes a mangling\n+   \t for a this pointer adjustment.  This-adjusting thunks that\n+   \t override a function from a virtual base have a vcall\n+   \t adjustment.  When the virtual base in question is a primary\n+   \t virtual base, we know the adjustments are zero, (and in the\n+   \t non-covariant case, we would not use the thunk).\n+   \t Unfortunately we didn't notice this could happen, when\n+   \t designing the ABI and so never mandated that such a covariant\n+   \t thunk should be emitted.  Because we must use the ABI mandated\n+   \t name, we must continue searching from the binfo where we\n+   \t found the most recent definition of the function, towards the\n+   \t primary binfo which first introduced the function into the\n+   \t vtable.  If that enters a virtual base, we must use a vcall\n+   \t this-adjusting thunk.  Bleah! */\n+      tree probe;\n+      \n+      for (probe = first_defn; (probe = get_primary_binfo (probe));)\n+\t{\n+\t  if (TREE_VIA_VIRTUAL (probe))\n+\t    virtual_base = probe;\n+\t  if ((unsigned) list_length (BINFO_VIRTUALS (probe)) <= ix)\n+\t    break;\n+\t}\n+      if (virtual_base)\n+\t/* Even if we find a virtual base, the correct delta is\n+\t   between the overrider and the binfo we're building a vtable\n+\t   for.  */\n+\tgoto virtual_covariant;\n+    }\n+  \n   /* Compute the constant adjustment to the `this' pointer.  The\n      `this' pointer, when this function is called, will point at BINFO\n      (or one of its primary bases, which are at the same offset).  */\n@@ -2541,6 +2574,7 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals)\n     /* The `this' pointer needs to be adjusted from pointing to\n        BINFO to pointing at the base where the final overrider\n        appears.  */\n+    virtual_covariant:\n     delta = size_diffop (BINFO_OFFSET (TREE_VALUE (overrider)),\n \t\t\t BINFO_OFFSET (binfo));\n \n@@ -2564,26 +2598,25 @@ dfs_modify_vtables (tree binfo, void* data)\n       /* Similarly, a base without a vtable needs no modification.  */\n       && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo)))\n     {\n-      tree t;\n+      tree t = (tree) data;\n       tree virtuals;\n       tree old_virtuals;\n-\n-      t = (tree) data;\n-\n+      unsigned ix;\n+      \n       make_new_vtable (t, binfo);\n       \n       /* Now, go through each of the virtual functions in the virtual\n \t function table for BINFO.  Find the final overrider, and\n \t update the BINFO_VIRTUALS list appropriately.  */\n-      for (virtuals = BINFO_VIRTUALS (binfo),\n+      for (ix = 0, virtuals = BINFO_VIRTUALS (binfo),\n \t     old_virtuals = BINFO_VIRTUALS (TYPE_BINFO (BINFO_TYPE (binfo)));\n \t   virtuals;\n-\t   virtuals = TREE_CHAIN (virtuals),\n+\t   ix++, virtuals = TREE_CHAIN (virtuals),\n \t     old_virtuals = TREE_CHAIN (old_virtuals))\n \tupdate_vtable_entry_for_fn (t, \n \t\t\t\t    binfo, \n \t\t\t\t    BV_FN (old_virtuals),\n-\t\t\t\t    &virtuals);\n+\t\t\t\t    &virtuals, ix);\n     }\n \n   SET_BINFO_MARKED (binfo);"}, {"sha": "c778bcc6ee315930be50386a98b1285b86c0b03b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ddc3977ab5a1ae4ed182155d403bc899d36f8e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ddc3977ab5a1ae4ed182155d403bc899d36f8e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a2ddc3977ab5a1ae4ed182155d403bc899d36f8e", "patch": "@@ -1,3 +1,7 @@\n+2003-01-27  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* g++.dg/abi/covariant1.C: New test.\n+\n 2003-01-25  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* gcc.dg/20030123-1.c: New test."}, {"sha": "203ec2c9fcb237105b0dff03b18bf1fb775d63bf", "filename": "gcc/testsuite/g++.dg/abi/covariant1.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ddc3977ab5a1ae4ed182155d403bc899d36f8e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fcovariant1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ddc3977ab5a1ae4ed182155d403bc899d36f8e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fcovariant1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fcovariant1.C?ref=a2ddc3977ab5a1ae4ed182155d403bc899d36f8e", "patch": "@@ -0,0 +1,21 @@\n+// { dg-do compile }\n+// { dg-options \"-w\" }\n+\n+// We don't want to use a covariant thunk to have a virtual\n+// primary base\n+\n+struct c4 {};\n+\n+struct c6 : c4 { virtual c4* f17(); };\n+\n+c4* c6::f17() { return 0; }\n+\n+struct c11 : virtual c6 { int i; };\n+\n+struct c12 : c11 { };\n+\n+struct c14 : \n+  virtual c12,\n+  virtual c11 { virtual c12* f17(); };\n+\n+// { dg-final { scan-assembler-not \"\\n_ZTch0_v0_n16_N3c143f17Ev\\[: \\t\\n\\]\" } }"}]}