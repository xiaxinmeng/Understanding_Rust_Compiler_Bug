{"sha": "401aaa5983a7d31849b3b7a88f13eb6c7f74f11a", "node_id": "C_kwDOANBUbNoAKDQwMWFhYTU5ODNhN2QzMTg0OWIzYjdhODhmMTNlYjZjN2Y3NGYxMWE", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-10-14T13:01:49Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-10-14T21:37:59Z"}, "message": "Add ability to use full resolving path solver in the backward threader.\n\nThe path solver runs in two modes: a quick mode which assumes any unknown\nSSA names are VARYING, and a fully resolving mode using the ranger.\n\nThe backward threader currently uses the quick mode, because the fully\nresolving mode was not available initially.  Since we now have the ability\nin the solver (used by the hybrid threader), I thought it'd be useful to\nhave the knob for when the time comes.\n\nNote that enabling the fully resolving mode will require some experimenting,\nas enabling it would likely render other jump threading passes irrelevant\n(VRP threading comes to mind).\n\nThere should be no functional changes as the resolver is set to false.\n\nTested on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* tree-ssa-threadbackward.c (class back_threader): Add m_resolve.\n\t(back_threader::back_threader): Same.\n\t(back_threader::resolve_phi): Try to solve without looking back if\n\tpossible.\n\t(back_threader::find_paths_to_names): Same.\n\t(try_thread_blocks): Pass resolve argument to back threader.\n\t(pass_early_thread_jumps::execute): Same.", "tree": {"sha": "d28a4ef3c71d3e01597af1cfc24b1f3920373118", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d28a4ef3c71d3e01597af1cfc24b1f3920373118"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/401aaa5983a7d31849b3b7a88f13eb6c7f74f11a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/401aaa5983a7d31849b3b7a88f13eb6c7f74f11a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/401aaa5983a7d31849b3b7a88f13eb6c7f74f11a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/401aaa5983a7d31849b3b7a88f13eb6c7f74f11a/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0bd68793921ecf3bb5654252dea3763fd127ab77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bd68793921ecf3bb5654252dea3763fd127ab77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bd68793921ecf3bb5654252dea3763fd127ab77"}], "stats": {"total": 41, "additions": 35, "deletions": 6}, "files": [{"sha": "8cc92a484fe53b4e8578d99470d3bb55c65aa653", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/401aaa5983a7d31849b3b7a88f13eb6c7f74f11a/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/401aaa5983a7d31849b3b7a88f13eb6c7f74f11a/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=401aaa5983a7d31849b3b7a88f13eb6c7f74f11a", "patch": "@@ -77,7 +77,7 @@ class back_threader_profitability\n class back_threader\n {\n public:\n-  back_threader (bool speed_p);\n+  back_threader (bool speed_p, bool resolve);\n   ~back_threader ();\n   void maybe_thread_block (basic_block bb);\n   bool thread_through_all_blocks (bool may_peel_loop_headers);\n@@ -112,17 +112,22 @@ class back_threader\n   tree m_name;\n   // Marker to differentiate unreachable edges.\n   static const edge UNREACHABLE_EDGE;\n+  // Set to TRUE if unknown SSA names along a path should be resolved\n+  // with the ranger.  Otherwise, unknown SSA names are assumed to be\n+  // VARYING.  Setting to true more precise but slower.\n+  bool m_resolve;\n };\n \n // Used to differentiate unreachable edges, so we may stop the search\n // in a the given direction.\n const edge back_threader::UNREACHABLE_EDGE = (edge) -1;\n \n-back_threader::back_threader (bool speed_p)\n+back_threader::back_threader (bool speed_p, bool resolve)\n   : m_profit (speed_p),\n-    m_solver (m_ranger, /*resolve=*/false)\n+    m_solver (m_ranger, resolve)\n {\n   m_last_stmt = NULL;\n+  m_resolve = resolve;\n }\n \n back_threader::~back_threader ()\n@@ -295,7 +300,23 @@ back_threader::resolve_phi (gphi *phi, bitmap interesting)\n \n \t  bitmap_set_bit (interesting, v);\n \t  bitmap_set_bit (m_imports, v);\n-\t  done |= find_paths_to_names (e->src, interesting);\n+\n+\t  // When resolving unknowns, see if the incoming SSA can be\n+\t  // resolved on entry without having to keep looking back.\n+\t  bool keep_looking = true;\n+\t  if (m_resolve)\n+\t    {\n+\t      m_path.safe_push (e->src);\n+\t      if (maybe_register_path ())\n+\t\t{\n+\t\t  keep_looking = false;\n+\t\t  m_visited_bbs.add (e->src);\n+\t\t}\n+\t      m_path.pop ();\n+\t    }\n+\t  if (keep_looking)\n+\t    done |= find_paths_to_names (e->src, interesting);\n+\n \t  bitmap_clear_bit (interesting, v);\n \t}\n       else if (TREE_CODE (arg) == INTEGER_CST)\n@@ -360,6 +381,14 @@ back_threader::find_paths_to_names (basic_block bb, bitmap interesting)\n       return false;\n     }\n \n+  // Try to resolve the path with nothing but ranger knowledge.\n+  if (m_resolve && m_path.length () > 1 && maybe_register_path ())\n+    {\n+      m_path.pop ();\n+      m_visited_bbs.remove (bb);\n+      return true;\n+    }\n+\n   auto_bitmap processed;\n   unsigned i;\n   bool done = false;\n@@ -936,7 +965,7 @@ static bool\n try_thread_blocks (function *fun)\n {\n   /* Try to thread each block with more than one successor.  */\n-  back_threader threader (/*speed_p=*/true);\n+  back_threader threader (/*speed=*/true, /*resolve=*/false);\n   basic_block bb;\n   FOR_EACH_BB_FN (bb, fun)\n     {\n@@ -1005,7 +1034,7 @@ pass_early_thread_jumps::execute (function *fun)\n   loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n \n   /* Try to thread each block with more than one successor.  */\n-  back_threader threader (/*speed_p=*/false);\n+  back_threader threader (/*speed_p=*/false, /*resolve=*/false);\n   basic_block bb;\n   FOR_EACH_BB_FN (bb, fun)\n     {"}]}