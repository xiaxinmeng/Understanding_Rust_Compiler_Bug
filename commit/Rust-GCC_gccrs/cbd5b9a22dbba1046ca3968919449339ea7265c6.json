{"sha": "cbd5b9a22dbba1046ca3968919449339ea7265c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JkNWI5YTIyZGJiYTEwNDZjYTM5Njg5MTk0NDkzMzllYTcyNjVjNg==", "commit": {"author": {"name": "Ken Raeburn", "email": "raeburn@cygnus.com", "date": "1998-03-16T11:56:25Z"}, "committer": {"name": "Ken Raeburn", "email": "raeburn@gcc.gnu.org", "date": "1998-03-16T11:56:25Z"}, "message": "Change MEMORY_MOVE_COST defs and uses to be able to take register class into account.\n\nChange MEMORY_MOVE_COST defs and uses to be able to take register class into\naccount.  Change mips def to actually do so, others to just ignore extra args.\nDoc changes too.\n\nFrom-SVN: r18621", "tree": {"sha": "6f74b0e16a811b7beba5cb97f6b174bc298a2458", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f74b0e16a811b7beba5cb97f6b174bc298a2458"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cbd5b9a22dbba1046ca3968919449339ea7265c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbd5b9a22dbba1046ca3968919449339ea7265c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbd5b9a22dbba1046ca3968919449339ea7265c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbd5b9a22dbba1046ca3968919449339ea7265c6/comments", "author": null, "committer": null, "parents": [{"sha": "8b1616ad12f821928f25cee27f3008803d13b0d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b1616ad12f821928f25cee27f3008803d13b0d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b1616ad12f821928f25cee27f3008803d13b0d8"}], "stats": {"total": 148, "additions": 116, "deletions": 32}, "files": [{"sha": "8f95e8751cdb2d60ee1957613cad6ca041eb43ce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cbd5b9a22dbba1046ca3968919449339ea7265c6", "patch": "@@ -1,3 +1,22 @@\n+Mon Mar 16 12:12:36 1998  Ken Raeburn  <raeburn@cygnus.com>\n+\n+\t* reload.h (MEMORY_MOVE_COST): Define here if not already defined;\n+\tif HAVE_SECONDARY_RELOADS, factor in copying cost.\n+\t(memory_move_secondary_cost): Declare.\n+\t* regclass.c (MEMORY_MOVE_COST): Don't define default here.\n+\t(memory_move_secondary_cost) [HAVE_SECONDARY_RELOADS]: New\n+\tfunction.\n+\t(regclass, record_reg_classes, copy_cost, record_address_regs):\n+\tPass register class and direction of move to MEMORY_MOVE_COST.\n+\t* reload1.c (MEMORY_MOVE_COST): Don't define default here.\n+\t(emit_reload_insns, reload_cse_simplify_set): Pass register class\n+\tand direction of move to MEMORY_MOVE_COST.\n+\t* 1750a.c, a29k.h, alpha.h, arc.h, arm.h, dsp16xx.h, i386.h,\n+\tm32r.h, m88k.h, rs6000.h (MEMORY_MOVE_COST): Add extra ignored\n+\targuments to definition, even in comments.\n+\t* mips.h (MEMORY_MOVE_COST): Add extra arguments; add\n+\tmemory_move_secondary_cost result to cpu-specific cost.\n+\n Mon Mar 16 11:16:50 1998  Jim Wilson  <wilson@cygnus.com>\n \n \t* README.gnat: New file."}, {"sha": "6c5e9e3dfcabb5b4a97927f4a1eebd0d3bb80139", "filename": "gcc/config/1750a/1750a.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2Fconfig%2F1750a%2F1750a.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2Fconfig%2F1750a%2F1750a.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a.h?ref=cbd5b9a22dbba1046ca3968919449339ea7265c6", "patch": "@@ -910,7 +910,7 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n \n #define REGISTER_MOVE_COST(FROM,TO)\t2\n \n-#define MEMORY_MOVE_COST(M)\t\t4\n+#define MEMORY_MOVE_COST(M,C,I)\t\t4\n \n /* Tell final.c how to eliminate redundant test instructions.  */\n "}, {"sha": "d65beb4ff2812bf9ee4ac6e20083d12ddf4d7430", "filename": "gcc/config/a29k/a29k.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2Fconfig%2Fa29k%2Fa29k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2Fconfig%2Fa29k%2Fa29k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.h?ref=cbd5b9a22dbba1046ca3968919449339ea7265c6", "patch": "@@ -681,7 +681,7 @@ extern struct rtx_def *a29k_get_reloaded_address ();\n    this higher.  In addition, we need to keep it more expensive than the\n    most expensive register-register copy.  */\n \n-#define MEMORY_MOVE_COST(MODE) 6\n+#define MEMORY_MOVE_COST(MODE,CLASS,IN) 6\n \n /* A C statement (sans semicolon) to update the integer variable COST\n    based on the relationship between INSN that is dependent on"}, {"sha": "be3030ea19930cd1f06aa11ac4eaf5f2dd912a3c", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=cbd5b9a22dbba1046ca3968919449339ea7265c6", "patch": "@@ -789,7 +789,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n    On the Alpha, bump this up a bit.  */\n \n extern int alpha_memory_latency;\n-#define MEMORY_MOVE_COST(MODE)  (2*alpha_memory_latency)\n+#define MEMORY_MOVE_COST(MODE,CLASS,IN)  (2*alpha_memory_latency)\n \n /* Provide the cost of a branch.  Exact meaning under development.  */\n #define BRANCH_COST 5"}, {"sha": "c4696ea5542b0f4fb21c05d20d77a4ddf131d27f", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=cbd5b9a22dbba1046ca3968919449339ea7265c6", "patch": "@@ -1102,7 +1102,7 @@ arc_select_cc_mode (OP, X, Y)\n /* Compute the cost of moving data between registers and memory.  */\n /* Memory is 3 times as expensive as registers.\n    ??? Is that the right way to look at it?  */\n-#define MEMORY_MOVE_COST(MODE) \\\n+#define MEMORY_MOVE_COST(MODE,CLASS,IN) \\\n (GET_MODE_SIZE (MODE) <= UNITS_PER_WORD ? 6 : 12)\n \n /* The cost of a branch insn.  */"}, {"sha": "0adf6dc6eabfbf45bdaffb503a234f077ee532b9", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=cbd5b9a22dbba1046ca3968919449339ea7265c6", "patch": "@@ -1624,7 +1624,7 @@ extern struct rtx_def *legitimize_pic_address ();\n    return arm_rtx_costs (X, CODE, OUTER_CODE);\n \n /* Moves to and from memory are quite expensive */\n-#define MEMORY_MOVE_COST(MODE)  10\n+#define MEMORY_MOVE_COST(MODE,CLASS,IN)  10\n \n /* All address computations that can be done are free, but rtx cost returns\n    the same for practically all of them.  So we weight the different types"}, {"sha": "61e6bf873efd11c55ccb84c7fef5da7b62bee40d", "filename": "gcc/config/dsp16xx/dsp16xx.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h?ref=cbd5b9a22dbba1046ca3968919449339ea7265c6", "patch": "@@ -1556,7 +1556,7 @@ extern struct dsp16xx_frame_info current_frame_info;\n \n /* A C expression for the cost of moving data of mode MODE between\n    a register and memory. A value of 2 is the default. */\n-#define MEMORY_MOVE_COST(MODE)                                  \\\n+#define MEMORY_MOVE_COST(MODE,CLASS,IN_P)                        \\\n   (GET_MODE_CLASS(MODE) == MODE_INT && MODE == QImode ? 12       \\\n    : 16)\n "}, {"sha": "b910e77fd65405b958518dc6e912559e14883502", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=cbd5b9a22dbba1046ca3968919449339ea7265c6", "patch": "@@ -2079,7 +2079,7 @@ while (0)\n    between two registers, you should define this macro to express the\n    relative cost.  */\n \n-/* #define MEMORY_MOVE_COST(M) 2  */\n+/* #define MEMORY_MOVE_COST(M,C,I) 2  */\n \n /* A C expression for the cost of a branch instruction.  A value of 1\n    is the default; other values are interpreted relative to that.  */"}, {"sha": "d438b49548800ddc7e12b6356093afad1f1e8ffb", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=cbd5b9a22dbba1046ca3968919449339ea7265c6", "patch": "@@ -1268,7 +1268,7 @@ m32r_select_cc_mode (OP, X, Y)\n /* Compute the cost of moving data between registers and memory.  */\n /* Memory is 3 times as expensive as registers.\n    ??? Is that the right way to look at it?  */\n-#define MEMORY_MOVE_COST(MODE) \\\n+#define MEMORY_MOVE_COST(MODE,CLASS,IN_P) \\\n (GET_MODE_SIZE (MODE) <= UNITS_PER_WORD ? 6 : 12)\n \n /* The cost of a branch insn.  */"}, {"sha": "f0dac24a0dd7398bdbdfed0a0c8cdf4c617da82a", "filename": "gcc/config/m88k/m88k.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2Fconfig%2Fm88k%2Fm88k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2Fconfig%2Fm88k%2Fm88k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.h?ref=cbd5b9a22dbba1046ca3968919449339ea7265c6", "patch": "@@ -1690,7 +1690,7 @@ enum reg_class { NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS,\n \n /* A C expressions returning the cost of moving data of MODE from a register\n    to or from memory.  This is more costly than between registers.  */\n-#define MEMORY_MOVE_COST(MODE) 4\n+#define MEMORY_MOVE_COST(MODE,CLASS,IN) 4\n \n /* Provide the cost of a branch.  Exact meaning under development.  */\n #define BRANCH_COST (TARGET_88100 ? 1 : 2)"}, {"sha": "4de5f5c66a0e51e809ec83617c8f350593ae9eef", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=cbd5b9a22dbba1046ca3968919449339ea7265c6", "patch": "@@ -3534,8 +3534,9 @@ while (0)\n    : 12)\n \n /* ??? Fix this to be right for the R8000.  */\n-#define MEMORY_MOVE_COST(MODE) \\\n-  ((mips_cpu == PROCESSOR_R4000 || mips_cpu == PROCESSOR_R6000) ? 6 : 4)\n+#define MEMORY_MOVE_COST(MODE,CLASS,TO_P) \\\n+  (((mips_cpu == PROCESSOR_R4000 || mips_cpu == PROCESSOR_R6000) ? 6 : 4) \\\n+   + memory_move_secondary_cost ((MODE), (CLASS), (TO_P)))\n \n /* A C expression for the cost of a branch instruction.  A value of\n    1 is the default; other values are interpreted relative to that.  */"}, {"sha": "cdc4bdc748d39db3da4551fa5bec12e18418986f", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=cbd5b9a22dbba1046ca3968919449339ea7265c6", "patch": "@@ -800,7 +800,7 @@ extern int rs6000_debug_arg;\t\t/* debug argument handling */\n \n    On the RS/6000, bump this up a bit.  */\n \n-#define MEMORY_MOVE_COST(MODE)\t\t\\\n+#define MEMORY_MOVE_COST(MODE,CLASS,IN)\t\\\n   ((GET_MODE_CLASS (MODE) == MODE_FLOAT\t\\\n     && (rs6000_cpu == PROCESSOR_RIOS1 || rs6000_cpu == PROCESSOR_PPC601) \\\n     ? 3 : 2) \\"}, {"sha": "4cc02080c9faff3cde9570e0d6a59274cb5431a1", "filename": "gcc/regclass.c", "status": "modified", "additions": 51, "deletions": 9, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=cbd5b9a22dbba1046ca3968919449339ea7265c6", "patch": "@@ -42,10 +42,6 @@ Boston, MA 02111-1307, USA.  */\n #define REGISTER_MOVE_COST(x, y) 2\n #endif\n \n-#ifndef MEMORY_MOVE_COST\n-#define MEMORY_MOVE_COST(x) 4\n-#endif\n-\n /* If we have auto-increment or auto-decrement and we can have secondary\n    reloads, we are not allowed to use classes requiring secondary\n    reloads for pseudos auto-incremented since reload can't handle it.  */\n@@ -431,6 +427,50 @@ init_regs ()\n   init_reg_modes ();\n }\n \n+#ifdef HAVE_SECONDARY_RELOADS\n+/* Compute extra cost of moving registers to/from memory due to reloads.\n+   Only needed if secondary reloads are required for memory moves.  */\n+int\n+memory_move_secondary_cost (mode, class, in)\n+     enum machine_mode mode;\n+     enum reg_class class;\n+     int in;\n+{\n+  enum reg_class altclass;\n+  int partial_cost = 0;\n+  rtx mem;\n+\n+  /* We need a memory reference to feed to SECONDARY... macros.  */\n+  mem = gen_rtx (MEM, mode, stack_pointer_rtx);\n+\n+  if (in)\n+    altclass = SECONDARY_INPUT_RELOAD_CLASS (class, mode, mem);\n+  else\n+    altclass = SECONDARY_OUTPUT_RELOAD_CLASS (class, mode, mem);\n+  if (altclass == NO_REGS)\n+    return 0;\n+\n+  if (in)\n+    partial_cost = REGISTER_MOVE_COST (altclass, class);\n+  else\n+    partial_cost = REGISTER_MOVE_COST (class, altclass);\n+\n+  if (class == altclass)\n+    /* This isn't simply a copy-to-temporary situation.  Can't guess\n+       what it is, so MEMORY_MOVE_COST really ought not to be calling\n+       here in that case.\n+\n+       I'm tempted to put in an abort here, but returning this will\n+       probably only give poor estimates, which is what we would've\n+       had before this code anyways.  */\n+    return partial_cost;\n+\n+  /* Check if the secondary reload register will also need a\n+     secondary reload.  */\n+  return memory_move_secondary_cost (mode, altclass, in) + partial_cost;\n+}\n+#endif\n+\n /* Return a machine mode that is legitimate for hard reg REGNO and large\n    enough to save nregs.  If we can't find one, return VOIDmode.  */\n \n@@ -773,7 +813,8 @@ regclass (f, nregs)\n \t\t      && GET_CODE (XEXP (note, 0)) == MEM)\n \t\t    {\n \t\t      costs[REGNO (SET_DEST (set))].mem_cost\n-\t\t\t-= (MEMORY_MOVE_COST (GET_MODE (SET_DEST (set)))\n+\t\t\t-= (MEMORY_MOVE_COST (GET_MODE (SET_DEST (set)),\n+\t\t\t\t\t      GENERAL_REGS, 1)\n \t\t\t    * loop_cost);\n \t\t      record_address_regs (XEXP (SET_SRC (set), 0),\n \t\t\t\t\t   BASE_REG_CLASS, loop_cost * 2);\n@@ -1290,7 +1331,8 @@ record_reg_classes (n_alts, n_ops, ops, modes, constraints, insn)\n \t\t     a bit cheaper since we won't need an extra insn to\n \t\t     load it.  */\n \n-\t\t  pp->mem_cost = MEMORY_MOVE_COST (mode) - allows_mem;\n+\t\t  pp->mem_cost = (MEMORY_MOVE_COST (mode, classes[i], 1)\n+\t\t\t\t  - allows_mem);\n \n \t\t  /* If we have assigned a class to this register in our\n \t\t     first pass, add a cost to this alternative corresponding\n@@ -1328,7 +1370,7 @@ record_reg_classes (n_alts, n_ops, ops, modes, constraints, insn)\n \t     constant that could be placed into memory.  */\n \n \t  else if (CONSTANT_P (op) && allows_mem)\n-\t    alt_cost += MEMORY_MOVE_COST (mode);\n+\t    alt_cost += MEMORY_MOVE_COST (mode, classes[i], 1);\n \t  else\n \t    alt_fail = 1;\n \t}\n@@ -1447,7 +1489,7 @@ copy_cost (x, mode, class, to_p)\n      else (constants).  */\n \n   if (GET_CODE (x) == MEM || class == NO_REGS)\n-    return MEMORY_MOVE_COST (mode);\n+    return MEMORY_MOVE_COST (mode, class, to_p);\n \n   else if (GET_CODE (x) == REG)\n     return move_cost[(int) REGNO_REG_CLASS (REGNO (x))][(int) class];\n@@ -1613,7 +1655,7 @@ record_address_regs (x, class, scale)\n \tregister struct costs *pp = &costs[REGNO (x)];\n \tregister int i;\n \n-\tpp->mem_cost += (MEMORY_MOVE_COST (Pmode) * scale) / 2;\n+\tpp->mem_cost += (MEMORY_MOVE_COST (Pmode, class, 1) * scale) / 2;\n \n \tfor (i = 0; i < N_REG_CLASSES; i++)\n \t  pp->cost[i] += (may_move_cost[i][(int) class] * scale) / 2;"}, {"sha": "d86542fa5053c8e270a8f5e11e6dd4da71d65e18", "filename": "gcc/reload.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=cbd5b9a22dbba1046ca3968919449339ea7265c6", "patch": "@@ -34,6 +34,17 @@ Boston, MA 02111-1307, USA.  */\n #define HAVE_SECONDARY_RELOADS\n #endif\n \n+/* If MEMORY_MOVE_COST isn't defined, give it a default here.  */\n+#ifndef MEMORY_MOVE_COST\n+#ifdef HAVE_SECONDARY_RELOADS\n+#define MEMORY_MOVE_COST(MODE,CLASS,IN) \\\n+  (4 + memory_move_secondary_cost ((MODE), (CLASS), (IN)))\n+#else\n+#define MEMORY_MOVE_COST(MODE,CLASS,IN) 4\n+#endif\n+#endif\n+extern int memory_move_secondary_cost PROTO ((enum machine_mode, enum reg_class, int));\n+\n /* See reload.c and reload1.c for comments on these variables.  */\n \n /* Maximum number of reloads we can need.  */"}, {"sha": "e843ceabe92528e9b2d7b6b1238ecdd38e9c44da", "filename": "gcc/reload1.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=cbd5b9a22dbba1046ca3968919449339ea7265c6", "patch": "@@ -76,10 +76,6 @@ Boston, MA 02111-1307, USA.  */\n #ifndef REGISTER_MOVE_COST\n #define REGISTER_MOVE_COST(x, y) 2\n #endif\n-\n-#ifndef MEMORY_MOVE_COST\n-#define MEMORY_MOVE_COST(x) 4\n-#endif\n \f\n /* During reload_as_needed, element N contains a REG rtx for the hard reg\n    into which reg N has been reloaded (perhaps for a previous insn).  */\n@@ -6141,7 +6137,8 @@ emit_reload_insns (insn)\n \t\t  && ((REGNO_REG_CLASS (regno) != reload_reg_class[j]\n \t\t       && (REGISTER_MOVE_COST (REGNO_REG_CLASS (regno),\n \t\t\t\t\t       reload_reg_class[j])\n-\t\t\t   >= MEMORY_MOVE_COST (mode)))\n+\t\t\t   >= MEMORY_MOVE_COST (mode, REGNO_REG_CLASS (regno),\n+\t\t\t\t\t\t1)))\n #ifdef SECONDARY_INPUT_RELOAD_CLASS\n \t\t      || (SECONDARY_INPUT_RELOAD_CLASS (reload_reg_class[j],\n \t\t\t\t\t\t\tmode, oldequiv)\n@@ -8204,13 +8201,15 @@ reload_cse_simplify_set (set, insn)\n   if (side_effects_p (src) || true_regnum (src) >= 0)\n     return 0;\n \n+  dclass = REGNO_REG_CLASS (dreg);\n+\n   /* If memory loads are cheaper than register copies, don't change\n      them.  */\n-  if (GET_CODE (src) == MEM && MEMORY_MOVE_COST (GET_MODE (src)) < 2)\n+  if (GET_CODE (src) == MEM\n+      && MEMORY_MOVE_COST (GET_MODE (src), dclass, 1) < 2)\n     return 0;\n \n   dest_mode = GET_MODE (SET_DEST (set));\n-  dclass = REGNO_REG_CLASS (dreg);\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n       if (i != dreg"}, {"sha": "d8fb72407751824aefc0be2203531d68dd736965", "filename": "gcc/tm.texi", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd5b9a22dbba1046ca3968919449339ea7265c6/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=cbd5b9a22dbba1046ca3968919449339ea7265c6", "patch": "@@ -4512,14 +4512,26 @@ allow reload to verify that the constraints are met.  You should do this\n if the @samp{mov@var{m}} pattern's constraints do not allow such copying.\n \n @findex MEMORY_MOVE_COST\n-@item MEMORY_MOVE_COST (@var{m})\n-A C expression for the cost of moving data of mode @var{m} between a\n-register and memory.  A value of 4 is the default; this cost is relative\n-to those in @code{REGISTER_MOVE_COST}.\n+@item MEMORY_MOVE_COST (@var{mode}, @var{class}, @var{in})\n+A C expression for the cost of moving data of mode @var{mode} between a\n+register of class @var{class} and memory; @var{in} is zero if the value\n+is to be written to memory, non-zero if it is to be read in.  If this\n+macro is not defined, the default cost is assumed to be 4, plus any costs\n+that would be incurred copying via a secondary reload register, if\n+needed.  This cost is relative to those in @code{REGISTER_MOVE_COST}.\n \n If moving between registers and memory is more expensive than between\n two registers, you should define this macro to express the relative cost.\n \n+If a secondary reload register would be required for @var{class}, but the\n+reload mechanism is more complex than copying via an intermediate, this\n+macro should be defined to reflect the actual cost of the move.\n+\n+The function @code{memory_move_secondary_cost}, which is defined if\n+secondary reloads are needed, will compute the costs due to copying; you\n+can use this function if you need to take other factors into account as\n+well, or if the default base value of 4 is not correct for your machine.\n+\n @findex BRANCH_COST\n @item BRANCH_COST\n A C expression for the cost of a branch instruction.  A value of 1 is"}]}