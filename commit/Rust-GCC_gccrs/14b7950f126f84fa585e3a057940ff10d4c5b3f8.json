{"sha": "14b7950f126f84fa585e3a057940ff10d4c5b3f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTRiNzk1MGYxMjZmODRmYTU4NWUzYTA1Nzk0MGZmMTBkNGM1YjNmOA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-08-22T23:09:26Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-08-22T23:09:26Z"}, "message": "PR middle-end/91490 - bogus argument missing terminating nul warning on strlen of a flexible array member\n\ngcc/c-family/ChangeLog:\n\n\tPR middle-end/91490\n\t* c-common.c (braced_list_to_string): Add argument and overload.\n\tHandle flexible length arrays and unions.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/91490\n\t* c-c++-common/Warray-bounds-7.c: New test.\n\t* gcc.dg/Warray-bounds-39.c: Expect either -Warray-bounds or\n\t-Wstringop-overflow.\n\t* gcc.dg/strlenopt-78.c: New test.\n\ngcc/ChangeLog:\n\n\tPR middle-end/91490\n\t* builtins.c (c_strlen): Rename argument and introduce new local.\n\tSet no-warning bit on original argument.\n\t* expr.c (string_constant): Pass argument type to fold_ctor_reference.\n\tFold empty and zero constructors into empty strings.\n\t* gimple-fold.c (fold_nonarray_ctor_reference): Return a STRING_CST\n\tfor missing initializers.\n\t* tree.c (build_string_literal): Handle optional argument.\n\t* tree.h (build_string_literal): Add defaulted argument.\n\t* gimple-ssa-warn-restrict.c (maybe_diag_access_bounds): Check\n\tno-warning bit on original expression.\n\nFrom-SVN: r274837", "tree": {"sha": "12d343894aea62b7964a5f595ddfd3cac40750e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12d343894aea62b7964a5f595ddfd3cac40750e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14b7950f126f84fa585e3a057940ff10d4c5b3f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14b7950f126f84fa585e3a057940ff10d4c5b3f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14b7950f126f84fa585e3a057940ff10d4c5b3f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14b7950f126f84fa585e3a057940ff10d4c5b3f8/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1b1e13dbde7f3eef0f8356af05c5de1fb46cb31b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b1e13dbde7f3eef0f8356af05c5de1fb46cb31b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b1e13dbde7f3eef0f8356af05c5de1fb46cb31b"}], "stats": {"total": 526, "additions": 450, "deletions": 76}, "files": [{"sha": "2651ce2daf07561c42514136048b36401cba41d6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b7950f126f84fa585e3a057940ff10d4c5b3f8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b7950f126f84fa585e3a057940ff10d4c5b3f8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=14b7950f126f84fa585e3a057940ff10d4c5b3f8", "patch": "@@ -1,3 +1,17 @@\n+2019-08-22  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/91490\n+\t* builtins.c (c_strlen): Rename argument and introduce new local.\n+\tSet no-warning bit on original argument.\n+\t* expr.c (string_constant): Pass argument type to fold_ctor_reference.\n+\tFold empty and zero constructors into empty strings.\n+\t* gimple-fold.c (fold_nonarray_ctor_reference): Return a STRING_CST\n+\tfor missing initializers.\n+\t* tree.c (build_string_literal): Handle optional argument.\n+\t* tree.h (build_string_literal): Add defaulted argument.\n+\t* gimple-ssa-warn-restrict.c (maybe_diag_access_bounds): Check\n+\tno-warning bit on original expression.\n+\n 2019-08-22  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \tPR target/91481"}, {"sha": "073b92a1dc9548b2de6142b05abd7eb3248508e4", "filename": "gcc/builtins.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b7950f126f84fa585e3a057940ff10d4c5b3f8/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b7950f126f84fa585e3a057940ff10d4c5b3f8/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=14b7950f126f84fa585e3a057940ff10d4c5b3f8", "patch": "@@ -620,15 +620,15 @@ unterminated_array (tree exp, tree *size /* = NULL */, bool *exact /* = NULL */)\n    into the instruction stream and zero if it is going to be expanded.\n    E.g. with i++ ? \"foo\" : \"bar\", if ONLY_VALUE is nonzero, constant 3\n    is returned, otherwise NULL, since\n-   len = c_strlen (src, 1); if (len) expand_expr (len, ...); would not\n+   len = c_strlen (ARG, 1); if (len) expand_expr (len, ...); would not\n    evaluate the side-effects.\n \n    If ONLY_VALUE is two then we do not emit warnings about out-of-bound\n    accesses.  Note that this implies the result is not going to be emitted\n    into the instruction stream.\n \n    Additional information about the string accessed may be recorded\n-   in DATA.  For example, if SRC references an unterminated string,\n+   in DATA.  For example, if ARG references an unterminated string,\n    then the declaration will be stored in the DECL field.   If the\n    length of the unterminated string can be determined, it'll be\n    stored in the LEN field.  Note this length could well be different\n@@ -640,7 +640,7 @@ unterminated_array (tree exp, tree *size /* = NULL */, bool *exact /* = NULL */)\n    The value returned is of type `ssizetype'.  */\n \n tree\n-c_strlen (tree src, int only_value, c_strlen_data *data, unsigned eltsize)\n+c_strlen (tree arg, int only_value, c_strlen_data *data, unsigned eltsize)\n {\n   /* If we were not passed a DATA pointer, then get one to a local\n      structure.  That avoids having to check DATA for NULL before\n@@ -650,7 +650,8 @@ c_strlen (tree src, int only_value, c_strlen_data *data, unsigned eltsize)\n     data = &local_strlen_data;\n \n   gcc_checking_assert (eltsize == 1 || eltsize == 2 || eltsize == 4);\n-  STRIP_NOPS (src);\n+\n+  tree src = STRIP_NOPS (arg);\n   if (TREE_CODE (src) == COND_EXPR\n       && (only_value || !TREE_SIDE_EFFECTS (TREE_OPERAND (src, 0))))\n     {\n@@ -762,11 +763,15 @@ c_strlen (tree src, int only_value, c_strlen_data *data, unsigned eltsize)\n     {\n       /* Suppress multiple warnings for propagated constant strings.  */\n       if (only_value != 2\n-\t  && !TREE_NO_WARNING (src)\n+\t  && !TREE_NO_WARNING (arg)\n \t  && warning_at (loc, OPT_Warray_bounds,\n \t\t\t \"offset %qwi outside bounds of constant string\",\n \t\t\t eltoff))\n-\tTREE_NO_WARNING (src) = 1;\n+\t{\n+\t  if (decl)\n+\t    inform (DECL_SOURCE_LOCATION (decl), \"%qE declared here\", decl);\n+\t  TREE_NO_WARNING (arg) = 1;\n+\t}\n       return NULL_TREE;\n     }\n "}, {"sha": "a1a864a8e976afd89de1f35cb6fae937806121ed", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b7950f126f84fa585e3a057940ff10d4c5b3f8/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b7950f126f84fa585e3a057940ff10d4c5b3f8/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=14b7950f126f84fa585e3a057940ff10d4c5b3f8", "patch": "@@ -1,3 +1,9 @@\n+2019-08-22  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/91490\n+\t* c-common.c (braced_list_to_string): Add argument and overload.\n+\tHandle flexible length arrays and unions.\n+\n 2019-08-21  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* c-ada-spec.c (dump_ada_function_declaration): Be prepared for broken"}, {"sha": "0aaa246d3ccd73afedff60c5e9c7380ba06877e7", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 38, "deletions": 16, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b7950f126f84fa585e3a057940ff10d4c5b3f8/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b7950f126f84fa585e3a057940ff10d4c5b3f8/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=14b7950f126f84fa585e3a057940ff10d4c5b3f8", "patch": "@@ -8747,20 +8747,30 @@ maybe_add_include_fixit (rich_location *richloc, const char *header,\n    the converted string on success or the original ctor on failure.  */\n \n static tree\n-braced_list_to_string (tree type, tree ctor)\n+braced_list_to_string (tree type, tree ctor, bool member)\n {\n-  if (!tree_fits_uhwi_p (TYPE_SIZE_UNIT (type)))\n+  /* Ignore non-members with unknown size like arrays with unspecified\n+     bound.  */\n+  tree typesize = TYPE_SIZE_UNIT (type);\n+  if (!member && !tree_fits_uhwi_p (typesize))\n     return ctor;\n \n   /* If the array has an explicit bound, use it to constrain the size\n      of the string.  If it doesn't, be sure to create a string that's\n      as long as implied by the index of the last zero specified via\n      a designator, as in:\n        const char a[] = { [7] = 0 };  */\n-  unsigned HOST_WIDE_INT maxelts = tree_to_uhwi (TYPE_SIZE_UNIT (type));\n-  maxelts /= tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (type)));\n+  unsigned HOST_WIDE_INT maxelts;\n+  if (typesize)\n+    {\n+      maxelts = tree_to_uhwi (typesize);\n+      maxelts /= tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (type)));\n+    }\n+  else\n+    maxelts = HOST_WIDE_INT_M1U;\n \n-  /* Avoid converting initializers for zero-length arrays.  */\n+  /* Avoid converting initializers for zero-length arrays (but do\n+     create them for flexible array members).  */\n   if (!maxelts)\n     return ctor;\n \n@@ -8818,7 +8828,7 @@ braced_list_to_string (tree type, tree ctor)\n     }\n \n   /* Append a nul string termination.  */\n-  if (str.length () < maxelts)\n+  if (maxelts != HOST_WIDE_INT_M1U && str.length () < maxelts)\n     str.safe_push (0);\n \n   /* Build a STRING_CST with the same type as the array.  */\n@@ -8827,14 +8837,12 @@ braced_list_to_string (tree type, tree ctor)\n   return res;\n }\n \n-/* Attempt to convert a CTOR containing braced array initializer lists\n-   for array TYPE into one containing STRING_CSTs, for convenience and\n-   efficiency.  Recurse for arrays of arrays and member initializers.\n-   Return the converted CTOR or STRING_CST on success or the original\n-   CTOR otherwise.  */\n+/* Implementation of the two-argument braced_lists_to_string withe\n+   the same arguments plus MEMBER which is set for struct members\n+   to allow initializers for flexible member arrays.  */\n \n-tree\n-braced_lists_to_strings (tree type, tree ctor)\n+static tree\n+braced_lists_to_strings (tree type, tree ctor, bool member)\n {\n   if (TREE_CODE (ctor) != CONSTRUCTOR)\n     return ctor;\n@@ -8858,22 +8866,36 @@ braced_lists_to_strings (tree type, tree ctor)\n \n   if ((TREE_CODE (ttp) == ARRAY_TYPE || TREE_CODE (ttp) == INTEGER_TYPE)\n       && TYPE_STRING_FLAG (ttp))\n-    return braced_list_to_string (type, ctor);\n+    return braced_list_to_string (type, ctor, member);\n \n   code = TREE_CODE (ttp);\n-  if (code == ARRAY_TYPE || code == RECORD_TYPE)\n+  if (code == ARRAY_TYPE || RECORD_OR_UNION_TYPE_P (ttp))\n     {\n+      bool rec = RECORD_OR_UNION_TYPE_P (ttp);\n+\n       /* Handle array of arrays or struct member initializers.  */\n       tree val;\n       unsigned HOST_WIDE_INT idx;\n       FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (ctor), idx, val)\n \t{\n-\t  val = braced_lists_to_strings (ttp, val);\n+\t  val = braced_lists_to_strings (ttp, val, rec);\n \t  CONSTRUCTOR_ELT (ctor, idx)->value = val;\n \t}\n     }\n \n   return ctor;\n }\n \n+/* Attempt to convert a CTOR containing braced array initializer lists\n+   for array TYPE into one containing STRING_CSTs, for convenience and\n+   efficiency.  Recurse for arrays of arrays and member initializers.\n+   Return the converted CTOR or STRING_CST on success or the original\n+   CTOR otherwise.  */\n+\n+tree\n+braced_lists_to_strings (tree type, tree ctor)\n+{\n+  return braced_lists_to_strings (type, ctor, false);\n+}\n+\n #include \"gt-c-family-c-common.h\""}, {"sha": "5ca0e20f14ae174b0bf112673f3e653b77c961c9", "filename": "gcc/expr.c", "status": "modified", "additions": 49, "deletions": 15, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b7950f126f84fa585e3a057940ff10d4c5b3f8/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b7950f126f84fa585e3a057940ff10d4c5b3f8/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=14b7950f126f84fa585e3a057940ff10d4c5b3f8", "patch": "@@ -11402,6 +11402,15 @@ is_aligning_offset (const_tree offset, const_tree exp)\n tree\n string_constant (tree arg, tree *ptr_offset, tree *mem_size, tree *decl)\n {\n+  tree dummy = NULL_TREE;;\n+  if (!mem_size)\n+    mem_size = &dummy;\n+\n+  /* Store the type of the original expression before conversions\n+     via NOP_EXPR or POINTER_PLUS_EXPR to other types have been\n+     removed.  */\n+  tree argtype = TREE_TYPE (arg);\n+\n   tree array;\n   STRIP_NOPS (arg);\n \n@@ -11464,7 +11473,7 @@ string_constant (tree arg, tree *ptr_offset, tree *mem_size, tree *decl)\n \t      && TREE_CODE (TREE_TYPE (TREE_TYPE (arg))) == ARRAY_TYPE\n \t      && !(decl && !*decl)\n \t      && !(decl && tree_fits_uhwi_p (DECL_SIZE_UNIT (*decl))\n-\t\t   && mem_size && tree_fits_uhwi_p (*mem_size)\n+\t\t   && tree_fits_uhwi_p (*mem_size)\n \t\t   && tree_int_cst_equal (*mem_size, DECL_SIZE_UNIT (*decl))))\n \t    return NULL_TREE;\n \n@@ -11496,7 +11505,7 @@ string_constant (tree arg, tree *ptr_offset, tree *mem_size, tree *decl)\n \t      && TREE_CODE (TREE_TYPE (TREE_TYPE (rhs1))) == ARRAY_TYPE\n \t      && !(decl && !*decl)\n \t      && !(decl && tree_fits_uhwi_p (DECL_SIZE_UNIT (*decl))\n-\t\t   && mem_size && tree_fits_uhwi_p (*mem_size)\n+\t\t   && tree_fits_uhwi_p (*mem_size)\n \t\t   && tree_int_cst_equal (*mem_size, DECL_SIZE_UNIT (*decl))))\n \t    return NULL_TREE;\n \n@@ -11530,8 +11539,7 @@ string_constant (tree arg, tree *ptr_offset, tree *mem_size, tree *decl)\n   if (TREE_CODE (array) == STRING_CST)\n     {\n       *ptr_offset = fold_convert (sizetype, offset);\n-      if (mem_size)\n-\t*mem_size = TYPE_SIZE_UNIT (TREE_TYPE (array));\n+      *mem_size = TYPE_SIZE_UNIT (TREE_TYPE (array));\n       if (decl)\n \t*decl = NULL_TREE;\n       gcc_checking_assert (tree_to_shwi (TYPE_SIZE_UNIT (TREE_TYPE (array)))\n@@ -11561,7 +11569,7 @@ string_constant (tree arg, tree *ptr_offset, tree *mem_size, tree *decl)\n \n       base_off = wioff.to_uhwi ();\n       unsigned HOST_WIDE_INT fieldoff = 0;\n-      init = fold_ctor_reference (NULL_TREE, init, base_off, 0, array,\n+      init = fold_ctor_reference (TREE_TYPE (arg), init, base_off, 0, array,\n \t\t\t\t  &fieldoff);\n       HOST_WIDE_INT cstoff;\n       if (!base_off.is_constant (&cstoff))\n@@ -11580,17 +11588,11 @@ string_constant (tree arg, tree *ptr_offset, tree *mem_size, tree *decl)\n \n   *ptr_offset = offset;\n \n-  tree eltype = TREE_TYPE (init);\n-  tree initsize = TYPE_SIZE_UNIT (eltype);\n-  if (mem_size)\n-    *mem_size = initsize;\n-\n-  if (decl)\n-    *decl = array;\n+  tree inittype = TREE_TYPE (init);\n \n   if (TREE_CODE (init) == INTEGER_CST\n       && (TREE_CODE (TREE_TYPE (array)) == INTEGER_TYPE\n-\t  || TYPE_MAIN_VARIANT (eltype) == char_type_node))\n+\t  || TYPE_MAIN_VARIANT (inittype) == char_type_node))\n     {\n       /* For a reference to (address of) a single constant character,\n \t store the native representation of the character in CHARBUF.\n@@ -11602,17 +11604,49 @@ string_constant (tree arg, tree *ptr_offset, tree *mem_size, tree *decl)\n       int len = native_encode_expr (init, charbuf, sizeof charbuf, 0);\n       if (len > 0)\n \t{\n-\t  /* Construct a string literal with elements of ELTYPE and\n+\t  /* Construct a string literal with elements of INITTYPE and\n \t     the representation above.  Then strip\n \t     the ADDR_EXPR (ARRAY_REF (...)) around the STRING_CST.  */\n-\t  init = build_string_literal (len, (char *)charbuf, eltype);\n+\t  init = build_string_literal (len, (char *)charbuf, inittype);\n \t  init = TREE_OPERAND (TREE_OPERAND (init, 0), 0);\n \t}\n     }\n \n+  tree initsize = TYPE_SIZE_UNIT (inittype);\n+\n+  if (TREE_CODE (init) == CONSTRUCTOR && initializer_zerop (init))\n+    {\n+      /* Fold an empty/zero constructor for an implicitly initialized\n+\t object or subobject into the empty string.  */\n+\n+      /* Determine the character type from that of the original\n+\t expression.  */\n+      tree chartype = argtype;\n+      if (POINTER_TYPE_P (chartype))\n+\tchartype = TREE_TYPE (chartype);\n+      while (TREE_CODE (chartype) == ARRAY_TYPE)\n+\tchartype = TREE_TYPE (chartype);\n+      /* Convert a char array to an empty STRING_CST having an array\n+\t of the expected type.  */\n+      if (!initsize)\n+\t  initsize = integer_zero_node;\n+\n+      unsigned HOST_WIDE_INT size = tree_to_uhwi (initsize);\n+      init = build_string_literal (size ? 1 : 0, \"\", chartype, size);\n+      init = TREE_OPERAND (init, 0);\n+      init = TREE_OPERAND (init, 0);\n+\n+      *ptr_offset = integer_zero_node;\n+    }\n+\n+  if (decl)\n+    *decl = array;\n+\n   if (TREE_CODE (init) != STRING_CST)\n     return NULL_TREE;\n \n+  *mem_size = initsize;\n+\n   gcc_checking_assert (tree_to_shwi (initsize) >= TREE_STRING_LENGTH (init));\n \n   return init;"}, {"sha": "fcffb9802b791bec4cd06af3f6beddc094d18a71", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b7950f126f84fa585e3a057940ff10d4c5b3f8/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b7950f126f84fa585e3a057940ff10d4c5b3f8/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=14b7950f126f84fa585e3a057940ff10d4c5b3f8", "patch": "@@ -759,11 +759,13 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n       dest_align = get_pointer_alignment (dest);\n       if (tree_fits_uhwi_p (len)\n \t  && compare_tree_int (len, MOVE_MAX) <= 0\n-\t  /* ???  Don't transform copies from strings with known length this\n-\t     confuses the tree-ssa-strlen.c.  This doesn't handle\n-\t     the case in gcc.dg/strlenopt-8.c which is XFAILed for that\n-\t     reason.  */\n-\t  && !c_strlen (src, 2)\n+\t  /* FIXME: Don't transform copies from strings with known length.\n+\t     Until GCC 9 this prevented a case in gcc.dg/strlenopt-8.c\n+\t     from being handled, and the case was XFAILed for that reason.\n+\t     Now that it is handled and the XFAIL removed, as soon as other\n+\t     strlenopt tests that rely on it for passing are adjusted, this\n+\t     hack can be removed.  */\n+\t  && !c_strlen (src, 1)\n \t  && !((tmp_str = c_getstr (src, &tmp_len)) != NULL\n \t       && memchr (tmp_str, 0, tmp_len) == NULL))\n \t{\n@@ -6969,12 +6971,15 @@ fold_nonarray_ctor_reference (tree type, tree ctor,\n \t\t\t\t      from_decl, suboff);\n \t}\n     }\n-  /* Memory not explicitly mentioned in constructor is 0.  */\n-  return type ? build_zero_cst (type) : NULL_TREE;\n+\n+  if (!type)\n+    return NULL_TREE;\n+\n+  return build_zero_cst (type);\n }\n \n /* CTOR is value initializing memory.  Fold a reference of TYPE and\n-   bit size POLY_SIZE to the memory at bit POLY_OFFSET.  When SIZE\n+   bit size POLY_SIZE to the memory at bit POLY_OFFSET.  When POLY_SIZE\n    is zero, attempt to fold a reference to the entire subobject\n    which OFFSET refers to.  This is used when folding accesses to\n    string members of aggregates.  When non-null, set *SUBOFF to"}, {"sha": "cbfc47894dc5619140cf4a1e44c07f20b50209c9", "filename": "gcc/gimple-ssa-warn-restrict.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b7950f126f84fa585e3a057940ff10d4c5b3f8/gcc%2Fgimple-ssa-warn-restrict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b7950f126f84fa585e3a057940ff10d4c5b3f8/gcc%2Fgimple-ssa-warn-restrict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-restrict.c?ref=14b7950f126f84fa585e3a057940ff10d4c5b3f8", "patch": "@@ -1678,7 +1678,8 @@ maybe_diag_access_bounds (location_t loc, gimple *call, tree func, int strict,\n   if (!warn_array_bounds)\n     return false;\n \n-  if (ref.ref && TREE_NO_WARNING (ref.ref))\n+  if (TREE_NO_WARNING (ref.ptr)\n+      || (ref.ref && TREE_NO_WARNING (ref.ref)))\n     return false;\n \n   if (EXPR_HAS_LOCATION (ref.ptr))"}, {"sha": "a7c4ec33d418788d98e0d5729e2069f76d76d1e7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b7950f126f84fa585e3a057940ff10d4c5b3f8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b7950f126f84fa585e3a057940ff10d4c5b3f8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=14b7950f126f84fa585e3a057940ff10d4c5b3f8", "patch": "@@ -1,3 +1,11 @@\n+2019-08-22  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/91490\n+\t* c-c++-common/Warray-bounds-7.c: New test.\n+\t* gcc.dg/Warray-bounds-39.c: Expect either -Warray-bounds or\n+\t-Wstringop-overflow.\n+\t* gcc.dg/strlenopt-78.c: New test.\n+\n 2019-08-22  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* gcc.target/i386/minmax-4.c: Add -mno-stackrealign to dg-options."}, {"sha": "668e809620071553c6ca6d40fa3175972ae2f07a", "filename": "gcc/testsuite/c-c++-common/Warray-bounds-7.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b7950f126f84fa585e3a057940ff10d4c5b3f8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b7950f126f84fa585e3a057940ff10d4c5b3f8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-7.c?ref=14b7950f126f84fa585e3a057940ff10d4c5b3f8", "patch": "@@ -0,0 +1,107 @@\n+/* PR middle-end/91490 - bogus argument missing terminating nul warning\n+   on strlen of a flexible array member\n+   { dg-do compile }\n+   { dg-options \"-Wall -ftrack-macro-expansion=0\" } */\n+\n+#define INT_MAX       __INT_MAX__\n+#define PTRDIFF_MAX   __PTRDIFF_MAX__\n+#define SIZE_MAX      __SIZE_MAX__\n+\n+struct A0 { char n, a[0]; };\n+struct A1 { char n, a[1]; };\n+struct Ax { char n, a[]; };\n+\n+const struct A0 a0 = { };\n+const struct A0 a0_0 = { 0 };\n+const struct A0 a0_0_ = { 0, { } };\n+\n+const struct A0 a1 = { };\n+const struct A0 a1_0 = { 0 };\n+const struct A0 a1_0_ = { 0, { } };\n+\n+const struct Ax ax= { };\n+const struct Ax ax_0 = { 0 };\n+const struct Ax ax_0_ = { 0, { } };\n+\n+void sink (unsigned);\n+\n+#define T(x)   sink (__builtin_strlen (x))\n+\n+void test_zero_length_array (void)\n+{\n+  T (a0.a);                   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a0.a - 1);               // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a0.a + 1);               // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a0.a + 9);               // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a0.a + INT_MAX);         // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a0.a + PTRDIFF_MAX);     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a0.a + SIZE_MAX);        // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+\n+  T (a0_0.a);                 // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a0_0.a - 1);             // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a0_0.a + 1);             // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a0_0.a + 9);             // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a0_0.a + INT_MAX);       // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a0_0.a + PTRDIFF_MAX);   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a0_0.a + SIZE_MAX);      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+\n+  T (a0_0_.a);                // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a0_0_.a - 1);            // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a0_0_.a + 1);            // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a0_0_.a + 9);            // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a0_0_.a + INT_MAX);      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a0_0_.a + PTRDIFF_MAX);  // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a0_0_.a + SIZE_MAX);     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+void test_one_element_array (void)\n+{\n+  T (a1.a - 1);               // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a1.a + 1);               // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a1.a + 9);               // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a1.a + INT_MAX);         // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a1.a + PTRDIFF_MAX);     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a1.a + SIZE_MAX);        // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+\n+  T (a1_0.a - 1);             // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a1_0.a + 1);             // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a1_0.a + 9);             // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a1_0.a + INT_MAX);       // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a1_0.a + PTRDIFF_MAX);   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a1_0.a + SIZE_MAX);      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+\n+  T (a1_0_.a - 1);            // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a1_0_.a + 1);            // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a1_0_.a + 9);            // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a1_0_.a + INT_MAX);      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a1_0_.a + PTRDIFF_MAX);  // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a1_0_.a + SIZE_MAX);     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+void test_flexible_array_member (void)\n+{\n+  T (ax.a);                   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (ax.a - 1);               // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (ax.a + 1);               // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (ax.a + 9);               // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (ax.a + INT_MAX);         // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (ax.a + PTRDIFF_MAX);     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (ax.a + SIZE_MAX);        // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+\n+  T (ax_0.a);                 // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (ax_0.a - 1);             // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (ax_0.a + 1);             // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (ax_0.a + 9);             // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (ax_0.a + INT_MAX);       // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (ax_0.a + PTRDIFF_MAX);   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (ax_0.a + SIZE_MAX);      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+\n+  T (ax_0_.a);                // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (ax_0_.a - 1);            // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (ax_0_.a + 1);            // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (ax_0_.a + 9);            // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (ax_0_.a + INT_MAX);      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (ax_0_.a + PTRDIFF_MAX);  // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (ax_0_.a + SIZE_MAX);     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+"}, {"sha": "ca42af86cd4ef6f8705b7d1ba32ea7e30e9c282c", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-39.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b7950f126f84fa585e3a057940ff10d4c5b3f8/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-39.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b7950f126f84fa585e3a057940ff10d4c5b3f8/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-39.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-39.c?ref=14b7950f126f84fa585e3a057940ff10d4c5b3f8", "patch": "@@ -21,65 +21,65 @@ char d[4];\n \n void* test_memcpy_s0_1 (void *d)\n {\n-  return memcpy (d, s0, 1);       /* { dg-warning \"\\\\\\[-Warray-bounds\" } */\n+  return memcpy (d, s0, 1);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n }\n \n void* test_memcpy_s0_2 (void *d)\n {\n-  return memcpy (d, s0, 2);       /* { dg-warning \"\\\\\\[-Warray-bounds\" } */\n+  return memcpy (d, s0, 2);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n }\n \n void* test_memcpy_s0_0_1 (void *d)\n {\n-  return memcpy (d, s0_0, 1);     /* { dg-warning \"\\\\\\[-Warray-bounds\" } */\n+  return memcpy (d, s0_0, 1);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n }\n \n void* test_memcpy_s0_0_2 (void *d)\n {\n-  return memcpy (d, s0_0, 2);     /* { dg-warning \"\\\\\\[-Warray-bounds\" } */\n+  return memcpy (d, s0_0, 2);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n }\n \n \n void* test_memcpy_s0_1_1 (void *d)\n {\n-  return memcpy (d, s0_1, 1);     /* { dg-warning \"\\\\\\[-Warray-bounds\" } */\n+  return memcpy (d, s0_1, 1);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n }\n \n void* test_memcpy_s0_1_2 (void *d)\n {\n-  return memcpy (d, s0_1, 2);     /* { dg-warning \"\\\\\\[-Warray-bounds\" } */\n+  return memcpy (d, s0_1, 2);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n }\n \n \n void* test_memcpy_s1_0_1 (void *d)\n {\n-  return memcpy (d, s1_0, 1);     /* { dg-warning \"\\\\\\[-Warray-bounds\" } */\n+  return memcpy (d, s1_0, 1);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n }\n \n void* test_memcpy_s1_0_2 (void *d)\n {\n-  return memcpy (d, s1_0, 2);     /* { dg-warning \"\\\\\\[-Warray-bounds\" } */\n+  return memcpy (d, s1_0, 2);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n }\n \n \n void* test_memmove_s0_1 (void *d)\n {\n-  return memmove (d, s0, 1);      /* { dg-warning \"\\\\\\[-Warray-bounds\" } */\n+  return memmove (d, s0, 1);      /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n }\n \n void* test_memmove_s0_2 (void *d)\n {\n-  return memmove (d, s0, 2);      /* { dg-warning \"\\\\\\[-Warray-bounds\" } */\n+  return memmove (d, s0, 2);      /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n }\n \n void* test_memmove_s0_0_1 (void *d)\n {\n-  return memmove (d, s0_0, 1);    /* { dg-warning \"\\\\\\[-Warray-bounds\" } */\n+  return memmove (d, s0_0, 1);    /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n }\n \n void* test_memmove_s0_0_2 (void *d)\n {\n-  return memmove (d, s0_0, 2);    /* { dg-warning \"\\\\\\[-Warray-bounds\" } */\n+  return memmove (d, s0_0, 2);    /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n }\n \n \n@@ -92,57 +92,57 @@ const struct Empty e1_0[1][0] = { };\n \n void* test_memcpy_e_1 (void *d)\n {\n-  return memcpy (d, &e, 1);       /* { dg-warning \"\\\\\\[-Warray-bounds\" } */\n+  return memcpy (d, &e, 1);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n }\n \n void* test_memcpy_e0_1 (void *d)\n {\n-  return memcpy (d, e0, 1);       /* { dg-warning \"\\\\\\[-Warray-bounds\" } */\n+  return memcpy (d, e0, 1);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n }\n \n void* test_memcpy_e0_0_1 (void *d)\n {\n-  return memcpy (d, e0_0, 1);     /* { dg-warning \"\\\\\\[-Warray-bounds\" } */\n+  return memcpy (d, e0_0, 1);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n }\n \n void* test_memcpy_e0_1_1 (void *d)\n {\n-  return memcpy (d, e0_1, 1);     /* { dg-warning \"\\\\\\[-Warray-bounds\" } */\n+  return memcpy (d, e0_1, 1);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n }\n \n void* test_memcpy_e1_0_1 (void *d)\n {\n-  return memcpy (d, e1_0, 1);     /* { dg-warning \"\\\\\\[-Warray-bounds\" } */\n+  return memcpy (d, e1_0, 1);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n }\n \n \n char* test_strcpy_s0 (char *d)\n {\n-  return strcpy (d, s0);          /* { dg-warning \"\\\\\\[-Warray-bounds\" \"pr88991\" { xfail *-*-* } } */\n+  return strcpy (d, s0);          /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n }\n \n char* test_strcpy_s0_0 (char *d)\n {\n-  return strcpy (d, s0_0[0]);     /* { dg-warning \"\\\\\\[-Warray-bounds\" \"pr88991\" { xfail *-*-* } } */\n+  return strcpy (d, s0_0[0]);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"pr88991\" { xfail *-*-* } } */\n }\n \n \n char* test_strncpy_s0_1 (char *d)\n {\n-  return strncpy (d, s0, 1);    /* { dg-warning \"\\\\\\[-Warray-bounds\" \"pr88991\" { xfail *-*-* } } */\n+  return strncpy (d, s0, 1);    /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n }\n \n char* test_strncpy_s0_2 (char *d)\n {\n-  return strncpy (d, s0, 2);    /* { dg-warning \"\\\\\\[-Warray-bounds\" \"pr88991\" { xfail *-*-* } } */\n+  return strncpy (d, s0, 2);    /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n }\n \n char* test_strncpy_s0_0_1 (char *d)\n {\n-  return strncpy (d, s0_0[0], 1); /* { dg-warning \"\\\\\\[-Warray-bounds\" \"pr88991\" { xfail *-*-* } } */\n+  return strncpy (d, s0_0[0], 1); /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"pr88991\" { xfail *-*-* } } */\n }\n \n char* test_strncpy_s0_0_2 (char *d)\n {\n-  return strncpy (d, s0_0[0], 2); /* { dg-warning \"\\\\\\[-Warray-bounds\" \"pr88991\" { xfail *-*-* } } */\n+  return strncpy (d, s0_0[0], 2); /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"pr88991\" { xfail *-*-* } } */\n }"}, {"sha": "c028723e5938d4e2b3ddc53382c6e6f6f4a10a8d", "filename": "gcc/testsuite/gcc.dg/strlenopt-78.c", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b7950f126f84fa585e3a057940ff10d4c5b3f8/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b7950f126f84fa585e3a057940ff10d4c5b3f8/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-78.c?ref=14b7950f126f84fa585e3a057940ff10d4c5b3f8", "patch": "@@ -0,0 +1,166 @@\n+/* PR middle-end/91490 - bogus argument missing terminating nul warning\n+   on strlen of a flexible array member\n+   Verify that strlen calls with a flexible array member (and its common\n+   forms) of declaraed objects are folded.\n+   { dg-do compile }\n+   { dg-options \"-Wall -fdump-tree-gimple\" } */\n+\n+#include \"strlenopt.h\"\n+\n+extern void* memchr (const void*, int, size_t);\n+\n+struct A1 { char n, a[1]; };\n+struct A2 { char n, a[2]; };\n+struct A3 { char n, a[3]; };\n+struct Ax { char n, a[]; };\n+\n+const struct A1 a1_0 = { 0 };\n+const struct A1 a1_0_ = { 0, { } };\n+const struct A1 a1_0_0 = { 0, { 0 } };\n+\n+const struct A2 a2_1_ = { 1, { } };\n+const struct A2 a2_1_1 = { 1, { 1 } };\n+const struct A2 a2_1_1_0 = { 1, { 1, 0 } };\n+\n+const struct A3 aa3_1_[2] = { { 1 } };\n+\n+const struct Ax ax = { 3, { 3, 2, 1, 0 } };\n+\n+struct BxA1 { int n; struct A1 a[]; };\n+struct BxA2 { int n; struct A2 a[]; };\n+\n+const struct BxA2 bx = { 2, { { 2, { 2, 1 } }, { 2, { 1, 0 } } } };\n+\n+#if 0\n+\n+// Not implemented yet.\n+\n+int mchr1, mchr1__, mchr1_0, mchr2_1, mchr2, mchr2_1_0, mchrax, mchrbx;\n+\n+void test_memchr_flexarray (void)\n+{\n+  mchr1 = 0 != memchr (&a1_0, '1', sizeof a1_0);\n+  mchr1__ = 0 != memchr (&a1_0_, '2', sizeof a1_0_);\n+  mchr1_0 = 0 != memchr (&a1_0_0, '3', sizeof a1_0_0);\n+\n+  mchr2 = 0 != memchr (&a2_1_, '4', sizeof a2_1_);\n+  mchr2_1 = 0 != memchr (&a2_1_1, '\\001', sizeof a2_1_1);\n+  mchr2_1_0 = 0 != memchr (&a2_1_1_0, '\\001', sizeof a2_1_1_0);\n+\n+  mchrax = (const char*)&ax + sizeof ax - 1 == memchr (&ax, '\\001', sizeof ax);\n+  mchrbx = (const char*)&bx + sizeof bx - 1 == memchr (&bx, '\\001', sizeof bx);\n+}\n+\n+#endif\n+\n+\n+int schr1, schr1__, schr1_0, schr2_1, schr2, schr2_1_0, schrax, schrbx;\n+\n+void test_strchr_flexarray (void)\n+{\n+  schr1 = 0 != strchr (a1_0.a, '1');\n+  schr1__ = 0 != strchr (a1_0_.a, '2');\n+  schr1_0 = 0 != strchr (a1_0_0.a, '3');\n+\n+  schr2 = 0 != strchr (a2_1_.a, '4');\n+  schr2_1 = 0 != strchr (a2_1_1.a, '\\001');\n+  schr2_1_0 = 0 != strchr (a2_1_1_0.a, '\\001');\n+\n+  schrax = 0 != strchr (ax.a, '\\001');\n+  schrbx = 0 != strchr (bx.a[1].a, '\\0');\n+\n+  /* { dg-final { scan-tree-dump \"schr1 = 0;\" \"gimple\" } }\n+     { dg-final { scan-tree-dump \"schr1__ = 0;\" \"gimple\" } }\n+     { dg-final { scan-tree-dump \"schr1_0 = 0;\" \"gimple\" } }\n+     { dg-final { scan-tree-dump \"schr2 = 0;\" \"gimple\" } }\n+     { dg-final { scan-tree-dump \"schr2_1 = 1;\" \"gimple\" } }\n+     { dg-final { scan-tree-dump \"schr2_1_0 = 1;\" \"gimple\" } }\n+     { dg-final { scan-tree-dump \"schrax = 1;\" \"gimple\" } }\n+     { dg-final { scan-tree-dump \"schrbx = 1;\" \"gimple\" } } */\n+}\n+\n+\n+int scmp1, scmp1__, scmp1_0, scmp2_1, scmp2, scmp2_1_0, scmpax, scmpbx;\n+\n+void test_strcmp_flexarray (void)\n+{\n+  scmp1 = 0 == strcmp (a1_0.a, \"1\");\n+  scmp1__ = 0 == strcmp (a1_0_.a, \"2\");\n+  scmp1_0 = 0 == strcmp (a1_0_0.a, \"3\");\n+\n+  scmp2 = 0 == strcmp (a2_1_.a, \"4\");\n+  scmp2_1 = 0 == strcmp (a2_1_1.a, \"\\001\");\n+  scmp2_1_0 = 0 == strcmp (a2_1_1_0.a, \"\\001\");\n+\n+  scmpax = 0 == strcmp (ax.a, \"\\003\\002\\001\");\n+  scmpbx = 0 == strcmp (bx.a[1].a, \"\\001\");\n+\n+  /* { dg-final { scan-tree-dump \"scmp1 = 0;\" \"gimple\" } }\n+     { dg-final { scan-tree-dump \"scmp1__ = 0;\" \"gimple\" } }\n+     { dg-final { scan-tree-dump \"scmp1_0 = 0;\" \"gimple\" } }\n+     { dg-final { scan-tree-dump \"scmp2 = 0;\" \"gimple\" } }\n+     { dg-final { scan-tree-dump \"scmp2_1 = 1;\" \"gimple\" } }\n+     { dg-final { scan-tree-dump \"scmp2_1_0 = 1;\" \"gimple\" } }\n+     { dg-final { scan-tree-dump \"scmpax = 1;\" \"gimple\" } }\n+     { dg-final { scan-tree-dump \"scmpbx = 1;\" \"gimple\" } } */\n+}\n+\n+\n+int len1, len1__, len1_0, len2_1, len2, len2_1_0, lenax, lenbx;\n+\n+void test_strlen_flexarray (void)\n+{\n+  len1 = strlen (a1_0.a);\n+  len1__ = strlen (a1_0_.a);\n+  len1_0 = strlen (a1_0_0.a);\n+\n+  len2 = strlen (a2_1_.a);\n+  len2_1 = strlen (a2_1_1.a);\n+  len2_1_0 = strlen (a2_1_1_0.a);\n+\n+  lenax = strlen (ax.a);\n+  lenbx = strlen (bx.a[1].a);\n+\n+  /* { dg-final { scan-tree-dump \"len1 = 0;\" \"gimple\" } }\n+     { dg-final { scan-tree-dump \"len1__ = 0;\" \"gimple\" } }\n+     { dg-final { scan-tree-dump \"len1_0 = 0;\" \"gimple\" } }\n+     { dg-final { scan-tree-dump \"len2 = 0;\" \"gimple\" } }\n+     { dg-final { scan-tree-dump \"len2_1 = 1;\" \"gimple\" } }\n+     { dg-final { scan-tree-dump \"len2_1_0 = 1;\" \"gimple\" } }\n+     { dg-final { scan-tree-dump \"lenax = 3;\" \"gimple\" } }\n+     { dg-final { scan-tree-dump \"lenbx = 1;\" \"gimple\" } } */\n+}\n+\n+\n+int schraa3, scmpaa3, lenaa3;\n+\n+void test_trailing_array_empty_init (void)\n+{\n+  schraa3 = ((aa3_1_[0].a == strchr (aa3_1_[0].a, 0))\n+\t     + (aa3_1_[1].a == strchr (aa3_1_[1].a, 0)));\n+\n+  scmpaa3 = strcmp (aa3_1_[0].a, aa3_1_[1].a);\n+  lenaa3 = strlen (aa3_1_[0].a) + strlen (aa3_1_[1].a);\n+\n+  /* { dg-final { scan-tree-dump \"schraa3 = 2;\" \"gimple\" } }\n+     { dg-final { scan-tree-dump \"scmpaa3 = 0;\" \"gimple\" } }\n+     { dg-final { scan-tree-dump \"lenaa3 = 0;\" \"gimple\" } }  */\n+}\n+\n+union U4 { char a[4]; int i; };\n+const union U4 u4[2] = { { \"123\" } };\n+\n+int ulen0, ulen1;\n+\n+void test_union_init (void)\n+{\n+  ulen0 = strlen (u4[0].a);\n+  ulen1 = strlen (u4[1].a);\n+\n+  /* { dg-final { scan-tree-dump \"ulen0 = 3;\" \"gimple\" } }\n+     { dg-final { scan-tree-dump \"ulen1 = 0;\" \"gimple\" } } */\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"strchr *\\\\(\" \"gimple\" } }\n+   { dg-final { scan-tree-dump-not \"strcmp *\\\\(\" \"gimple\" } }\n+   { dg-final { scan-tree-dump-not \"strlen *\\\\(\" \"gimple\" } } */"}, {"sha": "613efa5f2b0412e6d272aea7b30e165cce4556d3", "filename": "gcc/tree.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b7950f126f84fa585e3a057940ff10d4c5b3f8/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b7950f126f84fa585e3a057940ff10d4c5b3f8/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=14b7950f126f84fa585e3a057940ff10d4c5b3f8", "patch": "@@ -11872,18 +11872,23 @@ build_alloca_call_expr (tree size, unsigned int align, HOST_WIDE_INT max_size)\n     }\n }\n \n-/* Create a new constant string literal consisting of elements of type\n-   ELTYPE and return a tree node representing char* pointer to it as\n-   an ADDR_EXPR (ARRAY_REF (ELTYPE, ...)).  The STRING_CST value is\n-   the LEN bytes at STR (the representation of the string, which may\n+/* Create a new constant string literal of type ELTYPE[SIZE] (or LEN\n+   if SIZE == -1) and return a tree node representing char* pointer to\n+   it as an ADDR_EXPR (ARRAY_REF (ELTYPE, ...)).  The STRING_CST value\n+   is the LEN bytes at STR (the representation of the string, which may\n    be wide).  */\n \n tree\n build_string_literal (int len, const char *str,\n-\t\t      tree eltype /* = char_type_node */)\n+\t\t      tree eltype /* = char_type_node */,\n+\t\t      unsigned HOST_WIDE_INT size /* = -1 */)\n {\n   tree t = build_string (len, str);\n-  tree index = build_index_type (size_int (len - 1));\n+  /* Set the maximum valid index based on the string length or SIZE.  */\n+  unsigned HOST_WIDE_INT maxidx\n+    = (size == HOST_WIDE_INT_M1U ? len : size) - 1;\n+\n+  tree index = build_index_type (size_int (maxidx));\n   eltype = build_type_variant (eltype, 1, 0);\n   tree type = build_array_type (eltype, index);\n   TREE_TYPE (t) = type;"}, {"sha": "fc85572dffa835debf0f11c34921911b780e4dc7", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b7950f126f84fa585e3a057940ff10d4c5b3f8/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b7950f126f84fa585e3a057940ff10d4c5b3f8/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=14b7950f126f84fa585e3a057940ff10d4c5b3f8", "patch": "@@ -4418,7 +4418,8 @@ extern tree build_call_expr_internal_loc_array (location_t, enum internal_fn,\n extern tree maybe_build_call_expr_loc (location_t, combined_fn, tree,\n \t\t\t\t       int, ...);\n extern tree build_alloca_call_expr (tree, unsigned int, HOST_WIDE_INT);\n-extern tree build_string_literal (int, const char *, tree = char_type_node);\n+extern tree build_string_literal (int, const char *, tree = char_type_node,\n+\t\t\t\t  unsigned HOST_WIDE_INT = HOST_WIDE_INT_M1U);\n \n /* Construct various nodes representing data types.  */\n "}]}