{"sha": "0fb2ab504067ad0d2179622861dd71140b736afe", "node_id": "C_kwDOANBUbNoAKDBmYjJhYjUwNDA2N2FkMGQyMTc5NjIyODYxZGQ3MTE0MGI3MzZhZmU", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-11-30T09:52:27Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-11-30T09:52:27Z"}, "message": "vect: Pass mode to gather/scatter tests\n\nvect_check_gather_scatter had a binary \u201cdoes this target support\ninternal gather/scatter functions\u201d test.  This dates from the time when\nwe only handled gathers and scatters via direct target support, with\nx86_64 using built-in functions and aarch64 using IFNs.  But now that we\ncan emulate gathers, we need to check whether the gather for a particular\nmode is going to be emulated or not.\n\nWithout this, enabling SVE regresses emulated Advanced SIMD gather\nsequences in cases where SVE isn't used.\n\nLivermore kernel 15 can now be vectorised with Advanced SIMD when\nSVE is enabled.\n\ngcc/\n\t* genopinit.c (main): Turn supports_vec_gather_load and\n\tsupports_vec_scatter_store into signed char arrays and remove\n\tsupports_vec_gather_load_cached and supports_vec_scatter_store_cached.\n\t* optabs-query.c (supports_vec_convert_optab_p): Add a mode parameter.\n\tIf the mode is not VOIDmode, test only for that mode.\n\t(supports_vec_gather_load_p): Likewise.\n\t(supports_vec_scatter_store_p): Likewise.\n\t* optabs-query.h (supports_vec_gather_load_p): Likewise.\n\t(supports_vec_scatter_store_p): Likewise.\n\t* tree-vect-data-refs.c (vect_check_gather_scatter): Pass the\n\tvector mode to supports_vec_gather_load_p and\n\tsupports_vec_scatter_store_p.\n\ngcc/testsuite/\n\t* gfortran.dg/vect/vect-8.f90: Bump number of vectorized loops\n\tto 25 for SVE.\n\t* gcc.target/aarch64/sve/gather_load_10.c: New test.", "tree": {"sha": "cd5e27b00734b699b573147f38b34bafe0a71fa6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd5e27b00734b699b573147f38b34bafe0a71fa6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fb2ab504067ad0d2179622861dd71140b736afe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fb2ab504067ad0d2179622861dd71140b736afe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fb2ab504067ad0d2179622861dd71140b736afe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fb2ab504067ad0d2179622861dd71140b736afe/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1d15146b636120f49fbecdb65302ac8d3b48e8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1d15146b636120f49fbecdb65302ac8d3b48e8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1d15146b636120f49fbecdb65302ac8d3b48e8b"}], "stats": {"total": 95, "additions": 56, "deletions": 39}, "files": [{"sha": "c6be748079d76907255e28abc0b1a411344abe47", "filename": "gcc/genopinit.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb2ab504067ad0d2179622861dd71140b736afe/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb2ab504067ad0d2179622861dd71140b736afe/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=0fb2ab504067ad0d2179622861dd71140b736afe", "patch": "@@ -313,12 +313,11 @@ main (int argc, const char **argv)\n \t   \"  /* Patterns that are used by optabs that are enabled for this target.  */\\n\"\n \t   \"  bool pat_enable[NUM_OPTAB_PATTERNS];\\n\"\n \t   \"\\n\"\n-\t   \"  /* Cache if the target supports vec_gather_load for at least one vector\\n\"\n-\t   \"     mode.  */\\n\"\n-\t   \"  bool supports_vec_gather_load;\\n\"\n-\t   \"  bool supports_vec_gather_load_cached;\\n\"\n-\t   \"  bool supports_vec_scatter_store;\\n\"\n-\t   \"  bool supports_vec_scatter_store_cached;\\n\"\n+\t   \"  /* Index VOIDmode caches if the target supports vec_gather_load for any\\n\"\n+\t   \"     vector mode.  Every other index X caches specifically for mode X.\\n\"\n+\t   \"     1 means yes, -1 means no.  */\\n\"\n+\t   \"  signed char supports_vec_gather_load[NUM_MACHINE_MODES];\\n\"\n+\t   \"  signed char supports_vec_scatter_store[NUM_MACHINE_MODES];\\n\"\n \t   \"};\\n\"\n \t   \"extern void init_all_optabs (struct target_optabs *);\\n\"\n \t   \"\\n\""}, {"sha": "1c0778cba55a3f65ce7307f5b3739aa76666d1b5", "filename": "gcc/optabs-query.c", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb2ab504067ad0d2179622861dd71140b736afe/gcc%2Foptabs-query.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb2ab504067ad0d2179622861dd71140b736afe/gcc%2Foptabs-query.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.c?ref=0fb2ab504067ad0d2179622861dd71140b736afe", "patch": "@@ -712,13 +712,16 @@ lshift_cheap_p (bool speed_p)\n   return cheap[speed_p];\n }\n \n-/* Return true if vector conversion optab OP supports at least one mode,\n-   given that the second mode is always an integer vector.  */\n+/* If MODE is not VOIDmode, return true if vector conversion optab OP supports\n+   that mode, given that the second mode is always an integer vector.\n+   If MODE is VOIDmode, return true if OP supports any vector mode.  */\n \n static bool\n-supports_vec_convert_optab_p (optab op)\n+supports_vec_convert_optab_p (optab op, machine_mode mode)\n {\n-  for (int i = 0; i < NUM_MACHINE_MODES; ++i)\n+  int start = mode == VOIDmode ? 0 : mode;\n+  int end = mode == VOIDmode ? MAX_MACHINE_MODE : mode;\n+  for (int i = start; i <= end; ++i)\n     if (VECTOR_MODE_P ((machine_mode) i))\n       for (int j = MIN_MODE_VECTOR_INT; j < MAX_MODE_VECTOR_INT; ++j)\n \tif (convert_optab_handler (op, (machine_mode) i,\n@@ -728,39 +731,35 @@ supports_vec_convert_optab_p (optab op)\n   return false;\n }\n \n-/* Return true if vec_gather_load is available for at least one vector\n-   mode.  */\n+/* If MODE is not VOIDmode, return true if vec_gather_load is available for\n+   that mode.  If MODE is VOIDmode, return true if gather_load is available\n+   for at least one vector mode.  */\n \n bool\n-supports_vec_gather_load_p ()\n+supports_vec_gather_load_p (machine_mode mode)\n {\n-  if (this_fn_optabs->supports_vec_gather_load_cached)\n-    return this_fn_optabs->supports_vec_gather_load;\n+  if (!this_fn_optabs->supports_vec_gather_load[mode])\n+    this_fn_optabs->supports_vec_gather_load[mode]\n+      = (supports_vec_convert_optab_p (gather_load_optab, mode)\n+\t || supports_vec_convert_optab_p (mask_gather_load_optab, mode)\n+\t ? 1 : -1);\n \n-  this_fn_optabs->supports_vec_gather_load_cached = true;\n-\n-  this_fn_optabs->supports_vec_gather_load\n-    = (supports_vec_convert_optab_p (gather_load_optab)\n-       || supports_vec_convert_optab_p (mask_gather_load_optab));\n-\n-  return this_fn_optabs->supports_vec_gather_load;\n+  return this_fn_optabs->supports_vec_gather_load[mode] > 0;\n }\n \n-/* Return true if vec_scatter_store is available for at least one vector\n-   mode.  */\n+/* If MODE is not VOIDmode, return true if vec_scatter_store is available for\n+   that mode.  If MODE is VOIDmode, return true if scatter_store is available\n+   for at least one vector mode.  */\n \n bool\n-supports_vec_scatter_store_p ()\n+supports_vec_scatter_store_p (machine_mode mode)\n {\n-  if (this_fn_optabs->supports_vec_scatter_store_cached)\n-    return this_fn_optabs->supports_vec_scatter_store;\n-\n-  this_fn_optabs->supports_vec_scatter_store_cached = true;\n-\n-  this_fn_optabs->supports_vec_scatter_store\n-    = (supports_vec_convert_optab_p (scatter_store_optab)\n-       || supports_vec_convert_optab_p (mask_scatter_store_optab));\n+  if (!this_fn_optabs->supports_vec_scatter_store[mode])\n+    this_fn_optabs->supports_vec_scatter_store[mode]\n+      = (supports_vec_convert_optab_p (scatter_store_optab, mode)\n+\t || supports_vec_convert_optab_p (mask_scatter_store_optab, mode)\n+\t ? 1 : -1);\n \n-  return this_fn_optabs->supports_vec_scatter_store;\n+  return this_fn_optabs->supports_vec_scatter_store[mode] > 0;\n }\n "}, {"sha": "6b24eecba46ec41ce671cd708e6f2db5497a0f11", "filename": "gcc/optabs-query.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb2ab504067ad0d2179622861dd71140b736afe/gcc%2Foptabs-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb2ab504067ad0d2179622861dd71140b736afe/gcc%2Foptabs-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.h?ref=0fb2ab504067ad0d2179622861dd71140b736afe", "patch": "@@ -193,8 +193,8 @@ bool can_compare_and_swap_p (machine_mode, bool);\n bool can_atomic_exchange_p (machine_mode, bool);\n bool can_atomic_load_p (machine_mode);\n bool lshift_cheap_p (bool);\n-bool supports_vec_gather_load_p ();\n-bool supports_vec_scatter_store_p ();\n+bool supports_vec_gather_load_p (machine_mode = E_VOIDmode);\n+bool supports_vec_scatter_store_p (machine_mode = E_VOIDmode);\n \n /* Version of find_widening_optab_handler_and_mode that operates on\n    specific mode types.  */"}, {"sha": "2a07c0be866c42ec24c05f6800500f1b7c06f77d", "filename": "gcc/testsuite/gcc.target/aarch64/sve/gather_load_10.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb2ab504067ad0d2179622861dd71140b736afe/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fgather_load_10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb2ab504067ad0d2179622861dd71140b736afe/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fgather_load_10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fgather_load_10.c?ref=0fb2ab504067ad0d2179622861dd71140b736afe", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fopenmp-simd -msve-vector-bits=256 -fno-vect-cost-model\" } */\n+\n+#include <stdint.h>\n+\n+void\n+foo (uint64_t *restrict x, uint64_t *restrict y, uint64_t *restrict index)\n+{\n+#pragma omp for simd simdlen(2)\n+  for (int i = 0; i < 128; ++i)\n+    x[i] += y[index[i]];\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tldr\\td[0-9]+, \\[x[0-9]+, x[0-9]+, lsl #?3\\]} 2 } } */\n+/* { dg-final { scan-assembler-not {\\tshl\\tv[0-9]+\\.2d,} } } */\n+/* { dg-final { scan-assembler-not {\\tumov\\t} } } */\n+/* { dg-final { scan-assembler {\\tadd\\tv[0-9]+\\.2d,} } } */\n+/* { dg-final { scan-assembler {\\tstr\\tq[0-9]+,} } } */"}, {"sha": "ca72ddcffcadd691472eb6cb0880ed8c4a4a680f", "filename": "gcc/testsuite/gfortran.dg/vect/vect-8.f90", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb2ab504067ad0d2179622861dd71140b736afe/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb2ab504067ad0d2179622861dd71140b736afe/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-8.f90?ref=0fb2ab504067ad0d2179622861dd71140b736afe", "patch": "@@ -704,6 +704,7 @@ SUBROUTINE kernel(tk)\n RETURN\n END SUBROUTINE kernel\n \n-! { dg-final { scan-tree-dump-times \"vectorized 24 loops\" 1 \"vect\" { target aarch64*-*-* } } }\n+! { dg-final { scan-tree-dump-times \"vectorized 25 loops\" 1 \"vect\" { target aarch64_sve } } }\n+! { dg-final { scan-tree-dump-times \"vectorized 24 loops\" 1 \"vect\" { target { aarch64*-*-* && { ! aarch64_sve } } } } }\n ! { dg-final { scan-tree-dump-times \"vectorized 2\\[234\\] loops\" 1 \"vect\" { target { vect_intdouble_cvt && { ! aarch64*-*-* } } } } }\n ! { dg-final { scan-tree-dump-times \"vectorized 17 loops\" 1 \"vect\" { target { { ! vect_intdouble_cvt } && { ! aarch64*-*-* } } } } }"}, {"sha": "f1d7f01a9ceb23746a8d18584813194ed0eb8746", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb2ab504067ad0d2179622861dd71140b736afe/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb2ab504067ad0d2179622861dd71140b736afe/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=0fb2ab504067ad0d2179622861dd71140b736afe", "patch": "@@ -3969,8 +3969,8 @@ vect_check_gather_scatter (stmt_vec_info stmt_info, loop_vec_info loop_vinfo,\n   /* True if we should aim to use internal functions rather than\n      built-in functions.  */\n   bool use_ifn_p = (DR_IS_READ (dr)\n-\t\t    ? supports_vec_gather_load_p ()\n-\t\t    : supports_vec_scatter_store_p ());\n+\t\t    ? supports_vec_gather_load_p (TYPE_MODE (vectype))\n+\t\t    : supports_vec_scatter_store_p (TYPE_MODE (vectype)));\n \n   base = DR_REF (dr);\n   /* For masked loads/stores, DR_REF (dr) is an artificial MEM_REF,"}]}