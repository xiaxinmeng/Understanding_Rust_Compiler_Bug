{"sha": "f8a097cd17f2e2465f5bc98aff3f4eaf616a0f2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhhMDk3Y2QxN2YyZTI0NjVmNWJjOThhZmYzZjRlYWY2MTZhMGYyYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2000-04-20T12:20:38Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2000-04-20T12:20:38Z"}, "message": "calls.c (expand_call): Avoid unnecesary precalculation and outgoing parameters space guarding for...\n\n\t* calls.c (expand_call): Avoid unnecesary precalculation\n\tand outgoing parameters space guarding for sibling calls.\n\t(store_one_arg): Likewise.\n\nFrom-SVN: r33280", "tree": {"sha": "50fa6bdd3ffc8c85f3db97c6eb39359d9d91b417", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50fa6bdd3ffc8c85f3db97c6eb39359d9d91b417"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8a097cd17f2e2465f5bc98aff3f4eaf616a0f2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8a097cd17f2e2465f5bc98aff3f4eaf616a0f2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8a097cd17f2e2465f5bc98aff3f4eaf616a0f2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8a097cd17f2e2465f5bc98aff3f4eaf616a0f2c/comments", "author": null, "committer": null, "parents": [{"sha": "48d9ade562cf3cc077c60cb1f49436054b34a3c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48d9ade562cf3cc077c60cb1f49436054b34a3c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48d9ade562cf3cc077c60cb1f49436054b34a3c6"}], "stats": {"total": 172, "additions": 86, "deletions": 86}, "files": [{"sha": "f575938b9564f4e79582013004166cd861ba3013", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8a097cd17f2e2465f5bc98aff3f4eaf616a0f2c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8a097cd17f2e2465f5bc98aff3f4eaf616a0f2c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f8a097cd17f2e2465f5bc98aff3f4eaf616a0f2c", "patch": "@@ -1,3 +1,9 @@\n+Thu Apr 20 14:19:18 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n+\n+\t* calls.c (expand_call): Avoid unnecesary precalculation\n+\tand outgoing parameters space guarding for sibling calls.\n+\t(store_one_arg): Likewise.\n+\n Thu Apr 20 08:01:07 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* toplev.c (enum dump_file_index, dump_file): Add DFI_sibling."}, {"sha": "12dea75584a5182328a825b9cd10771ecdf2fa3e", "filename": "gcc/calls.c", "status": "modified", "additions": 80, "deletions": 86, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8a097cd17f2e2465f5bc98aff3f4eaf616a0f2c/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8a097cd17f2e2465f5bc98aff3f4eaf616a0f2c/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=f8a097cd17f2e2465f5bc98aff3f4eaf616a0f2c", "patch": "@@ -2467,24 +2467,27 @@ expand_call (exp, target, ignore)\n \t      || reg_mentioned_p (virtual_outgoing_args_rtx,\n \t\t\t\t  structure_value_addr))\n \t  && (args_size.var\n-\t      || (!ACCUMULATE_OUTGOING_ARGS && args_size.constant)\n-\t      ))\n+\t      || (!ACCUMULATE_OUTGOING_ARGS && args_size.constant)))\n \tstructure_value_addr = copy_to_reg (structure_value_addr);\n \n       /* Precompute any arguments as needed.  */\n-      precompute_arguments (flags, num_actuals, args);\n+      if (pass)\n+\tprecompute_arguments (flags, num_actuals, args);\n \n       /* Now we are about to start emitting insns that can be deleted\n \t if a libcall is deleted.  */\n       if (flags & (ECF_CONST | ECF_PURE | ECF_MALLOC))\n \tstart_sequence ();\n \n       old_stack_allocated =  stack_pointer_delta - pending_stack_adjust;\n-\n+      /* The argument block when performing a sibling call is the\n+         incoming argument block.  */\n+      if (pass == 0)\n+\targblock = virtual_incoming_args_rtx;\n       /* If we have no actual push instructions, or shouldn't use them,\n \t make space for all args right now.  */\n \n-      if (args_size.var != 0)\n+      else if (args_size.var != 0)\n \t{\n \t  if (old_stack_level == 0)\n \t    {\n@@ -2519,24 +2522,24 @@ expand_call (exp, target, ignore)\n \t    {\n \t      if (ACCUMULATE_OUTGOING_ARGS)\n \t\t{\n-\t\t  /* Since the stack pointer will never be pushed, it is possible\n-\t\t     for the evaluation of a parm to clobber something we have\n-\t\t     already written to the stack.  Since most function calls on\n-\t\t     RISC machines do not use the stack, this is uncommon, but\n-\t\t     must work correctly.\n+\t\t  /* Since the stack pointer will never be pushed, it is\n+\t\t     possible for the evaluation of a parm to clobber\n+\t\t     something we have already written to the stack.\n+\t\t     Since most function calls on RISC machines do not use\n+\t\t     the stack, this is uncommon, but must work correctly.\n \n \t\t     Therefore, we save any area of the stack that was already\n-\t\t     written and that we are using.  Here we set up to do this by\n-\t\t     making a new stack usage map from the old one.  The actual\n-\t\t     save will be done by store_one_arg. \n+\t\t     written and that we are using.  Here we set up to do this\n+\t\t     by making a new stack usage map from the old one.  The\n+\t\t     actual save will be done by store_one_arg. \n \n \t\t     Another approach might be to try to reorder the argument\n \t\t     evaluations to avoid this conflicting stack usage.  */\n \n #ifndef OUTGOING_REG_PARM_STACK_SPACE\n-\t\t  /* Since we will be writing into the entire argument area, the\n-\t\t     map must be allocated for its entire size, not just the part\n-\t\t     that is the responsibility of the caller.  */\n+\t\t  /* Since we will be writing into the entire argument area,\n+\t\t     the map must be allocated for its entire size, not just\n+\t\t     the part that is the responsibility of the caller.  */\n \t\t  needed += reg_parm_stack_space;\n #endif\n \n@@ -2547,7 +2550,8 @@ expand_call (exp, target, ignore)\n \t\t  highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,\n \t\t\t\t\t\t     needed);\n #endif\n-\t\t  stack_usage_map = (char *) alloca (highest_outgoing_arg_in_use);\n+\t\t  stack_usage_map\n+\t\t    = (char *) alloca (highest_outgoing_arg_in_use);\n \n \t\t  if (initial_highest_arg_in_use)\n \t\t    bcopy (initial_stack_usage_map, stack_usage_map,\n@@ -2559,9 +2563,9 @@ expand_call (exp, target, ignore)\n \t\t\t    - initial_highest_arg_in_use));\n \t\t  needed = 0;\n \n-\t\t  /* The address of the outgoing argument list must not be copied\n-\t\t     to a register here, because argblock would be left pointing\n-\t\t     to the wrong place after the call to\n+\t\t  /* The address of the outgoing argument list must not be\n+\t\t     copied to a register here, because argblock would be left\n+\t\t     pointing to the wrong place after the call to\n \t\t     allocate_dynamic_stack_space below. */\n \n \t\t  argblock = virtual_outgoing_args_rtx;\n@@ -2590,63 +2594,53 @@ expand_call (exp, target, ignore)\n \t\t  else\n \t\t    argblock = push_block (GEN_INT (needed), 0, 0);\n \n-\t\t  /* We only really need to call `copy_to_reg' in the case where\n-\t\t     push insns are going to be used to pass ARGBLOCK to a function\n-\t\t     call in ARGS.  In that case, the stack pointer changes value\n-\t\t     from the allocation point to the call point, and hence\n-\t\t     the value of VIRTUAL_OUTGOING_ARGS_RTX changes as well.\n-\t\t     But might as well always do it.  */\n+\t\t  /* We only really need to call `copy_to_reg' in the case\n+\t\t     where push insns are going to be used to pass ARGBLOCK\n+\t\t     to a function call in ARGS.  In that case, the stack\n+\t\t     pointer changes value from the allocation point to the\n+\t\t     call point, and hence the value of\n+\t\t     VIRTUAL_OUTGOING_ARGS_RTX changes as well.  But might\n+\t\t     as well always do it.  */\n \t\t  argblock = copy_to_reg (argblock);\n-\t\t}\n-\t    }\n-\t}\n \n-      /* The argument block when performing a sibling call is the\n-\t incoming argument block.  */\n-      if (pass == 0)\n-\t{\n-\t  rtx temp = plus_constant (arg_pointer_rtx,\n-\t\t\t\t    FIRST_PARM_OFFSET (current_function_decl));\n-\t  argblock = force_reg (Pmode, force_operand (temp, NULL_RTX));\n-\t}\n-\n-      if (ACCUMULATE_OUTGOING_ARGS)\n-\t{\n-\t  /* The save/restore code in store_one_arg handles all cases except one:\n-\t     a constructor call (including a C function returning a BLKmode struct)\n-\t     to initialize an argument.  */\n-\t  if (stack_arg_under_construction)\n-\t    {\n+\t\t  /* The save/restore code in store_one_arg handles all\n+\t\t     cases except one:\n+\t\t     a constructor call (including a C function returning\n+\t\t     a BLKmode struct) to initialize an argument.  */\n+\t\t  if (stack_arg_under_construction)\n+\t\t    {\n #ifndef OUTGOING_REG_PARM_STACK_SPACE\n-\t      rtx push_size = GEN_INT (reg_parm_stack_space + args_size.constant);\n+\t\t      rtx push_size = GEN_INT (reg_parm_stack_space + args_size.constant);\n #else\n-\t      rtx push_size = GEN_INT (args_size.constant);\n+\t\t      rtx push_size = GEN_INT (args_size.constant);\n #endif\n-\t      if (old_stack_level == 0)\n-\t\t{\n-\t\t  emit_stack_save (SAVE_BLOCK, &old_stack_level, NULL_RTX);\n-\t\t  old_pending_adj = pending_stack_adjust;\n-\t\t  pending_stack_adjust = 0;\n-\t\t  /* stack_arg_under_construction says whether a stack arg is\n-\t\t     being constructed at the old stack level.  Pushing the stack\n-\t\t     gets a clean outgoing argument block.  */\n-\t\t  old_stack_arg_under_construction = stack_arg_under_construction;\n-\t\t  stack_arg_under_construction = 0;\n-\t\t  /* Make a new map for the new argument list.  */\n-\t\t  stack_usage_map = (char *)alloca (highest_outgoing_arg_in_use);\n-\t\t  bzero (stack_usage_map, highest_outgoing_arg_in_use);\n-\t\t  highest_outgoing_arg_in_use = 0;\n+\t\t      if (old_stack_level == 0)\n+\t\t\t{\n+\t\t\t  emit_stack_save (SAVE_BLOCK, &old_stack_level, NULL_RTX);\n+\t\t\t  old_pending_adj = pending_stack_adjust;\n+\t\t\t  pending_stack_adjust = 0;\n+\t\t\t  /* stack_arg_under_construction says whether a stack arg is\n+\t\t\t     being constructed at the old stack level.  Pushing the stack\n+\t\t\t     gets a clean outgoing argument block.  */\n+\t\t\t  old_stack_arg_under_construction = stack_arg_under_construction;\n+\t\t\t  stack_arg_under_construction = 0;\n+\t\t\t  /* Make a new map for the new argument list.  */\n+\t\t\t  stack_usage_map = (char *)alloca (highest_outgoing_arg_in_use);\n+\t\t\t  bzero (stack_usage_map, highest_outgoing_arg_in_use);\n+\t\t\t  highest_outgoing_arg_in_use = 0;\n+\t\t\t}\n+\t\t      allocate_dynamic_stack_space (push_size, NULL_RTX, BITS_PER_UNIT);\n+\t\t    }\n+\t\t  /* If argument evaluation might modify the stack pointer, copy the\n+\t\t     address of the argument list to a register.  */\n+\t\t  for (i = 0; i < num_actuals; i++)\n+\t\t    if (args[i].pass_on_stack)\n+\t\t      {\n+\t\t\targblock = copy_addr_to_reg (argblock);\n+\t\t\tbreak;\n+\t\t      }\n \t\t}\n-\t      allocate_dynamic_stack_space (push_size, NULL_RTX, BITS_PER_UNIT);\n \t    }\n-\t  /* If argument evaluation might modify the stack pointer, copy the\n-\t     address of the argument list to a register.  */\n-\t  for (i = 0; i < num_actuals; i++)\n-\t    if (args[i].pass_on_stack)\n-\t      {\n-\t\targblock = copy_addr_to_reg (argblock);\n-\t\tbreak;\n-\t      }\n \t}\n \n       compute_argument_addresses (args, argblock, num_actuals);\n@@ -2709,7 +2703,7 @@ expand_call (exp, target, ignore)\n #ifdef REG_PARM_STACK_SPACE\n       /* Save the fixed argument area if it's part of the caller's frame and\n \t is clobbered by argument setup for this call.  */\n-      if (ACCUMULATE_OUTGOING_ARGS)\n+      if (ACCUMULATE_OUTGOING_ARGS && pass)\n \tsave_area = save_fixed_argument_area (reg_parm_stack_space, argblock,\n \t\t\t\t\t      &low_to_save, &high_to_save);\n #endif\n@@ -2722,7 +2716,7 @@ expand_call (exp, target, ignore)\n \n       for (i = 0; i < num_actuals; i++)\n \tif (args[i].reg == 0 || args[i].pass_on_stack)\n-\t  store_one_arg (&args[i], argblock, flags & ECF_MAY_BE_ALLOCA,\n+\t  store_one_arg (&args[i], argblock, flags,\n \t\t\t args_size.var != 0, reg_parm_stack_space);\n \n       /* If we have a parm that is passed in registers but not in memory\n@@ -2737,7 +2731,7 @@ expand_call (exp, target, ignore)\n       if (reg_parm_seen)\n \tfor (i = 0; i < num_actuals; i++)\n \t  if (args[i].partial != 0 && ! args[i].pass_on_stack)\n-\t    store_one_arg (&args[i], argblock, flags & ECF_MAY_BE_ALLOCA,\n+\t    store_one_arg (&args[i], argblock, flags,\n \t\t\t   args_size.var != 0, reg_parm_stack_space);\n \n #ifdef PREFERRED_STACK_BOUNDARY\n@@ -3037,14 +3031,13 @@ expand_call (exp, target, ignore)\n \t  stack_usage_map = initial_stack_usage_map;\n \t  sibcall_failure = 1;\n \t}\n-      else if (ACCUMULATE_OUTGOING_ARGS)\n+      else if (ACCUMULATE_OUTGOING_ARGS && pass)\n \t{\n #ifdef REG_PARM_STACK_SPACE\n \t  if (save_area)\n \t    {\n \t      restore_fixed_argument_area (save_area, argblock,\n \t\t\t\t\t   high_to_save, low_to_save);\n-\t      sibcall_failure = 1;\n \t    }\n #endif\n \n@@ -3065,7 +3058,6 @@ expand_call (exp, target, ignore)\n \t\t\t\t   validize_mem (args[i].save_area),\n \t\t\t\t   GEN_INT (args[i].size.constant),\n \t\t\t\t   PARM_BOUNDARY);\n-\t\tsibcall_failure = 1;\n \t      }\n \n \t  highest_outgoing_arg_in_use = initial_highest_arg_in_use;\n@@ -3595,8 +3587,8 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n \t{\n \t  if (ACCUMULATE_OUTGOING_ARGS)\n \t    {\n-\t      /* If this is being stored into a pre-allocated, fixed-size, stack\n-\t\t area, save any previous data at that location.  */\n+\t      /* If this is being stored into a pre-allocated, fixed-size,\n+\t\t stack area, save any previous data at that location.  */\n \n #ifdef ARGS_GROW_DOWNWARD\n \t      /* stack_slot is negative, but we want to index stack_usage_map\n@@ -3610,16 +3602,18 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n \n \t      for (i = lower_bound; i < upper_bound; i++)\n \t\tif (stack_usage_map[i]\n-\t\t    /* Don't store things in the fixed argument area at this point;\n-\t\t       it has already been saved.  */\n+\t\t    /* Don't store things in the fixed argument area at this\n+\t\t       point; it has already been saved.  */\n \t\t    && i > reg_parm_stack_space)\n \t\t  break;\n \n \t      if (i != upper_bound)\n \t\t{\n-\t\t  /* We need to make a save area.  See what mode we can make it. */\n+\t\t  /* We need to make a save area.  See what mode we can make\n+\t\t     it. */\n \t\t  enum machine_mode save_mode\n-\t\t    = mode_for_size (argvec[argnum].size.constant * BITS_PER_UNIT,\n+\t\t    = mode_for_size (argvec[argnum].size.constant\n+\t\t\t\t     * BITS_PER_UNIT,\n \t\t\t\t     MODE_INT, 1);\n \t\t  rtx stack_area\n \t\t    = gen_rtx_MEM\n@@ -3975,11 +3969,11 @@ target_for_arg (type, size, args_addr, offset)\n    FNDECL is the declaration of the function we are calling.  */\n \n static void\n-store_one_arg (arg, argblock, may_be_alloca, variable_size,\n+store_one_arg (arg, argblock, flags, variable_size,\n \t       reg_parm_stack_space)\n      struct arg_data *arg;\n      rtx argblock;\n-     int may_be_alloca;\n+     int flags;\n      int variable_size ATTRIBUTE_UNUSED;\n      int reg_parm_stack_space;\n {\n@@ -3996,7 +3990,7 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size,\n      this argument.  */\n   push_temp_slots ();\n \n-  if (ACCUMULATE_OUTGOING_ARGS)\n+  if (ACCUMULATE_OUTGOING_ARGS && !(flags & ECF_SIBCALL))\n     {\n       /* If this is being stored into a pre-allocated, fixed-size, stack area,\n \t save any previous data at that location.  */\n@@ -4124,7 +4118,7 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size,\n \n   /* Don't allow anything left on stack from computation\n      of argument to alloca.  */\n-  if (may_be_alloca)\n+  if (flags & ECF_MAY_BE_ALLOCA)\n     do_pending_stack_adjust ();\n \n   if (arg->value == arg->stack)"}]}