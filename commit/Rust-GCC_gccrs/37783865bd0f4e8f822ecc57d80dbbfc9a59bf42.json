{"sha": "37783865bd0f4e8f822ecc57d80dbbfc9a59bf42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzc3ODM4NjViZDBmNGU4ZjgyMmVjYzU3ZDgwZGJiZmM5YTU5YmY0Mg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-11-06T08:38:52Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-11-06T08:38:52Z"}, "message": "genmodes.c: Change the word \"bitsize\" to \"precision\" throughout.\n\n\t* genmodes.c: Change the word \"bitsize\" to \"precision\" throughout.\n\t* machmode.def: Likewise.\n\t* machmode.h (GET_MODE_SIZE): Cast value to unsigned short.\n\t(GET_MODE_BITSIZE): Define as GET_MODE_SIZE * BITS_PER_UNIT.\n\t(GET_MODE_PRECISION): New macro.\n\t(mode_bitsize): Renamed mode_precision.\n\t* stor-layout.c (mode_for_size, smallest_mode_for_size):\n\tUse GET_MODE_PRECISION; clarify comments.\nada:\n\t* misc.c (fp_prec_to_size, fp_size_to_prec): Use GET_MODE_PRECISION\n\tand update for changed meaning of GET_MODE_BITSIZE.\n\nFrom-SVN: r73295", "tree": {"sha": "422f097a3e186761a863087fa6c10b836fc42a61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/422f097a3e186761a863087fa6c10b836fc42a61"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37783865bd0f4e8f822ecc57d80dbbfc9a59bf42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37783865bd0f4e8f822ecc57d80dbbfc9a59bf42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37783865bd0f4e8f822ecc57d80dbbfc9a59bf42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37783865bd0f4e8f822ecc57d80dbbfc9a59bf42/comments", "author": null, "committer": null, "parents": [{"sha": "6c748c6c998fda800c435ad9e00bed57a1aa98a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c748c6c998fda800c435ad9e00bed57a1aa98a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c748c6c998fda800c435ad9e00bed57a1aa98a0"}], "stats": {"total": 178, "additions": 97, "deletions": 81}, "files": [{"sha": "dd0789dbf012e824c27d31af6899477a297bf601", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37783865bd0f4e8f822ecc57d80dbbfc9a59bf42/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37783865bd0f4e8f822ecc57d80dbbfc9a59bf42/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=37783865bd0f4e8f822ecc57d80dbbfc9a59bf42", "patch": "@@ -1,3 +1,14 @@\n+2003-11-06  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* genmodes.c: Change the word \"bitsize\" to \"precision\" throughout.\n+\t* machmode.def: Likewise.\n+\t* machmode.h (GET_MODE_SIZE): Cast value to unsigned short.\n+\t(GET_MODE_BITSIZE): Define as GET_MODE_SIZE * BITS_PER_UNIT.\n+\t(GET_MODE_PRECISION): New macro.\n+\t(mode_bitsize): Renamed mode_precision.\n+\t* stor-layout.c (mode_for_size, smallest_mode_for_size):\n+\tUse GET_MODE_PRECISION; clarify comments.\n+\n 2003-11-05  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* doc/install-old.texi: Remove old documentation of building"}, {"sha": "5ab653077868d640f9ca123dc544bd7f34a3450b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 29, "deletions": 24, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37783865bd0f4e8f822ecc57d80dbbfc9a59bf42/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37783865bd0f4e8f822ecc57d80dbbfc9a59bf42/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=37783865bd0f4e8f822ecc57d80dbbfc9a59bf42", "patch": "@@ -1,9 +1,14 @@\n+2003-11-06  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* misc.c (fp_prec_to_size, fp_size_to_prec): Use GET_MODE_PRECISION\n+\tand update for changed meaning of GET_MODE_BITSIZE.\n+\n 2003-11-04  Doug Rupp  <rupp@gnat.com>\n \n \t* sysdep.c: Problem discovered during IA64 VMS port.\n \t[VMS] #include <unixio.h> to get proper prototypes.\n \n-\t* adaint.c: \n+\t* adaint.c:\n \tIssues discovered/problems fixed during IA64 VMS port.\n \t[VMS] #define _POSIX_EXIT for proper semantics.\n \t[VMS] #include <unixio.h> for proper prototypes.\n@@ -17,15 +22,15 @@\n \t* ada-tree.h (TYPE_DIGITS_VALUE, SET_TYPE_DIGITS_VALUE): Save count as\n \ttree, not integer.\n \n-\t* decl.c: \n+\t* decl.c:\n \t(gnat_to_gnu_entity, case E_Floating_Point_Type): Save count as tree,\n \tnot integer.\n \n \t* targtyps.c, decl.c, misc.c,\n \tgigi.h (fp_prec_to_size, fp_size_to_prec): Temporary\n \troutines to work around change in FP sizing semantics in GCC.\n \n-\t* utils.c: \n+\t* utils.c:\n \t(build_vms_descriptor): TYPE_DIGITS_VALUE is tree, not integer.\n \n \t* gigi.h: (enumerate_modes): New function.\n@@ -44,22 +49,22 @@\n \n \t* einfo.ads, einfo.adb: Add new flag Is_Thread_Body\n \n-\t* exp_ch6.adb: \n+\t* exp_ch6.adb:\n \t(Expand_N_Subprogram_Body): Handle expansion of thread body procedure\n \n \t* par-prag.adb: Add dummy entry for Thread_Body pragma\n \n-\t* rtsfind.ads: \n+\t* rtsfind.ads:\n \tAdd entries for System.Threads entities for thread body processing\n \n-\t* sem_attr.adb: \n+\t* sem_attr.adb:\n \t(Analyze_Pragma, Access attributes): Check these are not applied to a\n \tthread body, since this is not permitted\n \n \t* sem_prag.adb: Add processing for Thread_Body pragma.\n \tMinor comment fix.\n \n-\t* sem_res.adb: \n+\t* sem_res.adb:\n \t(Resolve_Call): Check for incorrect attempt to call a thread body\n \t procedure with a direct call.\n \n@@ -76,7 +81,7 @@\n \n 2003-11-04  Javier Miranda  <miranda@gnat.com>\n \n-\t* sem_ch10.adb: \n+\t* sem_ch10.adb:\n \t(Build_Limited_Views): Return after posting an error in case of limited\n \twith_clause on subprograms, generics, instances or generic renamings\n \t(Install_Limited_Withed_Unit): Do nothing in case of limited with_clause\n@@ -165,7 +170,7 @@\n \n 2003-10-30  Vasiliy Fofanov  <fofanov@act-europe.fr>\n \n-\t* 3vtrasym.adb: \n+\t* 3vtrasym.adb:\n \tDemangle Ada symbols returned by TBK$SYMBOLIZE. Correctly align line\n \tnumbers when symbol name is too long.\n \n@@ -183,8 +188,8 @@\n \n \t* lib-writ.adb (Write_ALI): Never write ali file if -gnats is specified\n \n-\t* par.adb, par-ch12.adb, par-ch13.adb, par-ch2.adb, par-ch3.adb, \n-\tpar-ch5.adb, par-ch6.adb, par-ch9.adb, par-util.adb: \n+\t* par.adb, par-ch12.adb, par-ch13.adb, par-ch2.adb, par-ch3.adb,\n+\tpar-ch5.adb, par-ch6.adb, par-ch9.adb, par-util.adb:\n \tNew handling of Id_Check parameter to improve recognition of keywords\n \tused as identifiers.\n \tUpdate copyright notice to include 2003\n@@ -199,18 +204,18 @@\n \n 2003-10-29  Vasiliy Fofanov  <fofanov@act-europe.fr>\n \n-\t* 3vtrasym.adb, 5vtraent.adb, 5vtraent.ads, tb-alvms.c: \n+\t* 3vtrasym.adb, 5vtraent.adb, 5vtraent.ads, tb-alvms.c:\n \tSupport for TBK$SYMBOLIZE-based symbolic traceback.\n \n 2003-10-29  Jose Ruiz  <ruiz@act-europe.fr>\n \n-\t* exp_disp.adb: \n+\t* exp_disp.adb:\n \tRevert previous change, that did not work well when pragma No_Run_Time\n \twas used in conjunction with a run-time other than ZFP.\n \n 2003-10-29  Vincent Celier  <celier@gnat.com>\n \n-\t* make.adb: \n+\t* make.adb:\n \t(Gnatmake): When there are no Ada mains in attribute Main, disable the\n \t bind and link steps only is switch -z is not used.\n \n@@ -238,11 +243,11 @@\n \n 2003-10-29  Javier Miranda  <miranda@gnat.com>\n \n-\t* sem_ch12.adb: \n+\t* sem_ch12.adb:\n \t(Analyze_Package_Instantiation): Check that instances can not be used in\n \tlimited with_clauses.\n \n-\t* sem_ch8.adb: \n+\t* sem_ch8.adb:\n \t(Analyze_Package_Renaming): Check that limited withed packages cannot\n \tbe renamed. Improve text on error messages related to limited\n \twith_clauses.\n@@ -332,31 +337,31 @@\n \n 2003-10-27  Robert Dewar  <dewar@gnat.com>\n \n-\t* exp_ch3.adb: \n+\t* exp_ch3.adb:\n \t(Freeze_Array_Type): We do not need an initialization routine for types\n \tderived from String or Wide_String. They should be treated the same\n \tas String and Wide_String themselves. This caused problems with the\n \tuse of Initialize_Scalars.\n \n-\t* exp_ch5.adb: \n+\t* exp_ch5.adb:\n \t(Expand_Assign_Record): Do component-wise assignment of non-byte aligned\n \tcomposites. This allows use of component clauses that are not byte\n \taligned.\n \n-\t* sem_prag.adb: \n+\t* sem_prag.adb:\n \t(Analyze_Pragma, case Pack): Generate warning and ignore pack if there\n \tis an attempt to pack an array of atomic objects.\n \n \t* make.adb, prj-env.adb, prj-env.ads: Minor reformatting\n \n 2003-10-27  Pascal Obry  <obry@gnat.com>\n \n-\t* g-dirope.adb: \n+\t* g-dirope.adb:\n \t(Basename): Check for drive letters in a pathname only on DOS based OS.\n \n 2003-10-27  Vincent Celier  <celier@gnat.com>\n \n-\t* make.adb: \n+\t* make.adb:\n \t(Gnatmake): When unable to change dir to the object dir, display the\n \tcontent of the parent dir of the obj dir, to try to understand why this\n \thappens.\n@@ -367,16 +372,16 @@\n \n 2003-10-27  Ed Schonberg  <schonberg@gnat.com>\n \n-\t* sem_ch12.adb: \n+\t* sem_ch12.adb:\n \t(Inline_Instance_Body): Indicate that the save/restore of use_clauses\n \tshould not be done in Save/Restore_Scope_Stack, because it is performed\n \tlocally.\n \n-\t* sem_ch8.adb: \n+\t* sem_ch8.adb:\n \t(Save_Scope_Stack, Restore_Scope_Stack): Add parameter to indicate\n \twhether use clauses should be removed/restored.\n \n-\t* sem_ch8.ads: \n+\t* sem_ch8.ads:\n \t(Save_Scope_Stack, Restore_Scope_Stack): Add parameter to indicate\n \twhether use clauses should be removed/restored.\n "}, {"sha": "d0b493691198d684286e53ca6b99605092fa1e5c", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37783865bd0f4e8f822ecc57d80dbbfc9a59bf42/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37783865bd0f4e8f822ecc57d80dbbfc9a59bf42/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=37783865bd0f4e8f822ecc57d80dbbfc9a59bf42", "patch": "@@ -973,8 +973,8 @@ fp_prec_to_size (int prec)\n \n   for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT); mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n-    if (GET_MODE_BITSIZE (mode) == prec)\n-      return GET_MODE_SIZE (mode) * BITS_PER_UNIT;\n+    if (GET_MODE_PRECISION (mode) == prec)\n+      return GET_MODE_BITSIZE (mode);\n \n   abort ();\n }\n@@ -986,8 +986,8 @@ fp_size_to_prec (int size)\n \n   for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT); mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n-    if (GET_MODE_SIZE (mode) * BITS_PER_UNIT == size)\n-      return GET_MODE_BITSIZE (mode);\n+    if (GET_MODE_BITSIZE (mode) == size)\n+      return GET_MODE_PRECISION (mode);\n \n   abort ();\n }"}, {"sha": "a09e452706571ce3d255d87bbe1223b48b3a970b", "filename": "gcc/genmodes.c", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37783865bd0f4e8f822ecc57d80dbbfc9a59bf42/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37783865bd0f4e8f822ecc57d80dbbfc9a59bf42/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=37783865bd0f4e8f822ecc57d80dbbfc9a59bf42", "patch": "@@ -56,7 +56,7 @@ struct mode_data\n \n   const char *name;\t\t/* printable mode name -- SI, not SImode */\n   enum mode_class class;\t/* this mode class */\n-  unsigned int bitsize;\t\t/* size in bits, equiv to TYPE_PRECISION */\n+  unsigned int precision;\t/* size in bits, equiv to TYPE_PRECISION */\n   unsigned int bytesize;\t/* storage size in addressable units */\n   unsigned int ncomponents;\t/* number of subunits */\n   unsigned int alignment;\t/* mode alignment */\n@@ -262,13 +262,13 @@ enum requirement { SET, UNSET, OPTIONAL };\n \n static void\n validate_mode (struct mode_data *m,\n-\t       enum requirement r_bitsize,\n+\t       enum requirement r_precision,\n \t       enum requirement r_bytesize,\n \t       enum requirement r_component,\n \t       enum requirement r_ncomponents,\n \t       enum requirement r_format)\n {\n-  validate_field (m, bitsize);\n+  validate_field (m, precision);\n   validate_field (m, bytesize);\n   validate_field (m, component);\n   validate_field (m, ncomponents);\n@@ -304,7 +304,7 @@ complete_mode (struct mode_data *m)\n \n       validate_mode (m, UNSET, UNSET, UNSET, UNSET, UNSET);\n \n-      m->bitsize = 0;\n+      m->precision = 0;\n       m->bytesize = 0;\n       m->ncomponents = 0;\n       m->component = 0;\n@@ -349,17 +349,17 @@ complete_mode (struct mode_data *m)\n       /* Complex modes should have a component indicated, but no more.  */\n       validate_mode (m, UNSET, UNSET, SET, UNSET, UNSET);\n       m->ncomponents = 2;\n-      if (m->component->bitsize != (unsigned int)-1)\n-\tm->bitsize = 2 * m->component->bitsize;\n+      if (m->component->precision != (unsigned int)-1)\n+\tm->precision = 2 * m->component->precision;\n       m->bytesize = 2 * m->component->bytesize;\n       break;\n \n     case MODE_VECTOR_INT:\n     case MODE_VECTOR_FLOAT:\n       /* Vector modes should have a component and a number of components.  */\n       validate_mode (m, UNSET, UNSET, SET, SET, UNSET);\n-      if (m->component->bitsize != (unsigned int)-1)\n-\tm->bitsize = m->ncomponents * m->component->bitsize;\n+      if (m->component->precision != (unsigned int)-1)\n+\tm->precision = m->ncomponents * m->component->precision;\n       m->bytesize = m->ncomponents * m->component->bytesize;\n       break;\n \n@@ -413,7 +413,7 @@ make_complex_modes (enum mode_class class,\n   for (m = modes[class]; m; m = m->next)\n     {\n       /* Skip BImode.  FIXME: BImode probably shouldn't be MODE_INT.  */\n-      if (m->bitsize == 1)\n+      if (m->precision == 1)\n \tcontinue;\n \n       if (strlen (m->name) >= sizeof buf)\n@@ -479,7 +479,7 @@ make_vector_modes (enum mode_class class, unsigned int width,\n \t not be necessary.  */\n       if (class == MODE_FLOAT && m->bytesize == 1)\n \tcontinue;\n-      if (class == MODE_INT && m->bitsize == 1)\n+      if (class == MODE_INT && m->precision == 1)\n \tcontinue;\n \n       if ((size_t)snprintf (buf, sizeof buf, \"V%u%s\", ncomponents, m->name)\n@@ -515,12 +515,12 @@ make_special_mode (enum mode_class class, const char *name,\n \n static void\n make_int_mode (const char *name,\n-\t       unsigned int bitsize, unsigned int bytesize,\n+\t       unsigned int precision, unsigned int bytesize,\n \t       const char *file, unsigned int line)\n {\n   struct mode_data *m = new_mode (MODE_INT, name, file, line);\n   m->bytesize = bytesize;\n-  m->bitsize = bitsize;\n+  m->precision = precision;\n }\n \n #define FLOAT_MODE(N, Y, F)             FRACTIONAL_FLOAT_MODE (N, -1, Y, F)\n@@ -529,13 +529,13 @@ make_int_mode (const char *name,\n \n static void\n make_float_mode (const char *name,\n-\t\t unsigned int bitsize, unsigned int bytesize,\n+\t\t unsigned int precision, unsigned int bytesize,\n \t\t const char *format,\n \t\t const char *file, unsigned int line)\n {\n   struct mode_data *m = new_mode (MODE_FLOAT, name, file, line);\n   m->bytesize = bytesize;\n-  m->bitsize = bitsize;\n+  m->precision = precision;\n   m->format = format;\n }\n \n@@ -565,7 +565,7 @@ reset_float_format (const char *name, const char *format,\n   make_partial_integer_mode (#M, \"P\" #M, -1, __FILE__, __LINE__)\n static void ATTRIBUTE_UNUSED\n make_partial_integer_mode (const char *base, const char *name,\n-\t\t\t   unsigned int bitsize,\n+\t\t\t   unsigned int precision,\n \t\t\t   const char *file, unsigned int line)\n {\n   struct mode_data *m;\n@@ -582,7 +582,7 @@ make_partial_integer_mode (const char *base, const char *name,\n     }\n   \n   m = new_mode (MODE_PARTIAL_INT, name, file, line);\n-  m->bitsize = bitsize;\n+  m->precision = precision;\n   m->component = component;\n }\n \n@@ -645,18 +645,18 @@ create_modes (void)\n /* Processing.  */\n \n /* Sort a list of modes into the order needed for the WIDER field:\n-   major sort by bitsize, minor sort by component bitsize.\n+   major sort by precision, minor sort by component precision.\n \n    For instance:\n      QI < HI < SI < DI < TI\n      V4QI < V2HI < V8QI < V4HI < V2SI.\n \n-   If the bitsize is not set, sort by the bytesize.  A mode with\n-   bitsize set gets sorted before a mode without bitsize set, if\n+   If the precision is not set, sort by the bytesize.  A mode with\n+   precision set gets sorted before a mode without precision set, if\n    they have the same bytesize; this is the right thing because\n-   the bitsize must always be smaller than the bytesize * BITS_PER_UNIT.\n+   the precision must always be smaller than the bytesize * BITS_PER_UNIT.\n    We don't have to do anything special to get this done -- an unset\n-   bitsize shows up as (unsigned int)-1, i.e. UINT_MAX.  */\n+   precision shows up as (unsigned int)-1, i.e. UINT_MAX.  */\n static int\n cmp_modes (const void *a, const void *b)\n {\n@@ -668,9 +668,9 @@ cmp_modes (const void *a, const void *b)\n   else if (m->bytesize < n->bytesize)\n     return -1;\n \n-  if (m->bitsize > n->bitsize)\n+  if (m->precision > n->precision)\n     return 1;\n-  else if (m->bitsize < n->bitsize)\n+  else if (m->precision < n->precision)\n     return -1;\n \n   if (!m->component && !n->component)\n@@ -681,9 +681,9 @@ cmp_modes (const void *a, const void *b)\n   else if (m->component->bytesize < n->component->bytesize)\n     return -1;\n \n-  if (m->component->bitsize > n->component->bitsize)\n+  if (m->component->precision > n->component->precision)\n     return 1;\n-  else if (m->component->bitsize < n->component->bitsize)\n+  else if (m->component->precision < n->component->precision)\n     return -1;\n \n   return 0;\n@@ -802,7 +802,7 @@ enum machine_mode\\n{\");\n \t end will try to use it for bitfields in structures and the\n \t like, which we do not want.  Only the target md file should\n \t generate BImode widgets.  */\n-      if (first && first->bitsize == 1)\n+      if (first && first->precision == 1)\n \tfirst = first->next;\n \n       if (first && last)\n@@ -892,16 +892,16 @@ emit_mode_class (void)\n }\n \n static void\n-emit_mode_bitsize (void)\n+emit_mode_precision (void)\n {\n   enum mode_class c;\n   struct mode_data *m;\n \n-  print_decl (\"unsigned short\", \"mode_bitsize\", \"NUM_MACHINE_MODES\");\n+  print_decl (\"unsigned short\", \"mode_precision\", \"NUM_MACHINE_MODES\");\n \n   for_all_modes (c, m)\n-    if (m->bitsize != (unsigned int)-1)\n-      tagged_printf (\"%u\", m->bitsize, m->name);\n+    if (m->precision != (unsigned int)-1)\n+      tagged_printf (\"%u\", m->precision, m->name);\n     else\n       tagged_printf (\"%u*BITS_PER_UNIT\", m->bytesize, m->name);\n \n@@ -968,8 +968,8 @@ emit_mode_mask (void)\n    : ((unsigned HOST_WIDE_INT) 1 << (m)) - 1\\n\");\n \n   for_all_modes (c, m)\n-    if (m->bitsize != (unsigned int)-1)\n-      tagged_printf (\"MODE_MASK (%u)\", m->bitsize, m->name);\n+    if (m->precision != (unsigned int)-1)\n+      tagged_printf (\"MODE_MASK (%u)\", m->precision, m->name);\n     else\n       tagged_printf (\"MODE_MASK (%u*BITS_PER_UNIT)\", m->bytesize, m->name);\n \n@@ -1020,7 +1020,7 @@ emit_class_narrowest_mode (void)\n     /* Bleah, all this to get the comment right for MIN_MODE_INT.  */\n     tagged_printf (\"MIN_%s\", mode_class_names[c],\n \t\t   modes[c]\n-\t\t   ? (modes[c]->bitsize != 1\n+\t\t   ? (modes[c]->precision != 1\n \t\t      ? modes[c]->name\n \t\t      : (modes[c]->next\n \t\t\t ? modes[c]->next->name\n@@ -1156,7 +1156,7 @@ emit_insn_modes_c (void)\n   emit_insn_modes_c_header ();\n   emit_mode_name ();\n   emit_mode_class ();\n-  emit_mode_bitsize ();\n+  emit_mode_precision ();\n   emit_mode_size ();\n   emit_mode_nunits ();\n   emit_mode_wider ();"}, {"sha": "0b6c6771dbae2b40d0eaeece7199d6a571df1beb", "filename": "gcc/machmode.def", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37783865bd0f4e8f822ecc57d80dbbfc9a59bf42/gcc%2Fmachmode.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37783865bd0f4e8f822ecc57d80dbbfc9a59bf42/gcc%2Fmachmode.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.def?ref=37783865bd0f4e8f822ecc57d80dbbfc9a59bf42", "patch": "@@ -47,7 +47,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    A MODE argument must be the printable name of a machine mode,\n    without quotation marks or trailing \"mode\".  For instance, SI.\n \n-   A BITSIZE, BYTESIZE, or COUNT argument must be a positive integer\n+   A PRECISION, BYTESIZE, or COUNT argument must be a positive integer\n    constant.\n \n    A FORMAT argument must be one of the real_mode_format structures\n@@ -78,18 +78,18 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n         declares MODE to be of class INT and BYTESIZE bytes wide.\n \tAll of the bits of its representation are significant.\n \n-     FRACTIONAL_INT_MODE (MODE, BITSIZE, BYTESIZE);\n+     FRACTIONAL_INT_MODE (MODE, PRECISION, BYTESIZE);\n         declares MODE to be of class INT, BYTESIZE bytes wide in\n-\tstorage, but with only BITSIZE significant bits.\n+\tstorage, but with only PRECISION significant bits.\n \n      FLOAT_MODE (MODE, BYTESIZE, FORMAT);\n         declares MODE to be of class FLOAT and BYTESIZE bytes wide,\n \tusing floating point format FORMAT.\n \tAll of the bits of its representation are significant.\n \n-     FRACTIONAL_FLOAT_MODE (MODE, BITSIZE, BYTESIZE, FORMAT);\n+     FRACTIONAL_FLOAT_MODE (MODE, PRECISION, BYTESIZE, FORMAT);\n         declares MODE to be of class FLOAT, BYTESIZE bytes wide in\n-\tstorage, but with only BITSIZE significant bits, using\n+\tstorage, but with only PRECISION significant bits, using\n \tfloating point format FORMAT.\n \n      RESET_FLOAT_FORMAT (MODE, FORMAT);\n@@ -101,7 +101,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n         declares a mode of class PARTIAL_INT with the same size as\n \tMODE (which must be an INT mode).  The name of the new mode\n \tis made by prefixing a P to the name MODE.  This statement\n-\tmay grow a BITSIZE argument in the future.\n+\tmay grow a PRECISION argument in the future.\n \n      VECTOR_MODE (CLASS, MODE, COUNT);\n         Declare a vector mode whose component mode is MODE (of class"}, {"sha": "c978c0a9b52ee61f91d2705652695e7686280f49", "filename": "gcc/machmode.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37783865bd0f4e8f822ecc57d80dbbfc9a59bf42/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37783865bd0f4e8f822ecc57d80dbbfc9a59bf42/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=37783865bd0f4e8f822ecc57d80dbbfc9a59bf42", "patch": "@@ -76,15 +76,15 @@ extern const unsigned char mode_class[NUM_MACHINE_MODES];\n #define SCALAR_FLOAT_MODE_P(MODE)\t\t\\\n   (GET_MODE_CLASS (MODE) == MODE_FLOAT)\n \n-/* Get the size in bytes of an object of mode MODE.  */\n+/* Get the size in bytes and bits of an object of mode MODE.  */\n \n extern CONST_MODE_SIZE unsigned char mode_size[NUM_MACHINE_MODES];\n-#define GET_MODE_SIZE(MODE)   mode_size[MODE]\n+#define GET_MODE_SIZE(MODE)    ((unsigned short) mode_size[MODE])\n+#define GET_MODE_BITSIZE(MODE) ((unsigned short) (GET_MODE_SIZE (MODE) * BITS_PER_UNIT))\n \n-/* Get the size in bits of an object of mode MODE.  */\n-\n-extern const unsigned short mode_bitsize[NUM_MACHINE_MODES];\n-#define GET_MODE_BITSIZE(MODE)  mode_bitsize[MODE]\n+/* Get the number of value bits of an object of mode MODE.  */\n+extern const unsigned short mode_precision[NUM_MACHINE_MODES];\n+#define GET_MODE_PRECISION(MODE)  mode_precision[MODE]\n \n /* Get a bitmask containing 1 for all bits in a word\n    that fit within mode MODE.  */"}, {"sha": "019436a4fe38d24bca69e8ae4e0ed5a6d8f32c00", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37783865bd0f4e8f822ecc57d80dbbfc9a59bf42/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37783865bd0f4e8f822ecc57d80dbbfc9a59bf42/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=37783865bd0f4e8f822ecc57d80dbbfc9a59bf42", "patch": "@@ -203,10 +203,10 @@ variable_size (tree size)\n #define MAX_FIXED_MODE_SIZE GET_MODE_BITSIZE (DImode)\n #endif\n \n-/* Return the machine mode to use for a nonscalar of SIZE bits.\n-   The mode must be in class CLASS, and have exactly that many bits.\n-   If LIMIT is nonzero, modes of wider than MAX_FIXED_MODE_SIZE will not\n-   be used.  */\n+/* Return the machine mode to use for a nonscalar of SIZE bits.  The\n+   mode must be in class CLASS, and have exactly that many value bits;\n+   it may have padding as well.  If LIMIT is nonzero, modes of wider\n+   than MAX_FIXED_MODE_SIZE will not be used.  */\n \n enum machine_mode\n mode_for_size (unsigned int size, enum mode_class class, int limit)\n@@ -219,7 +219,7 @@ mode_for_size (unsigned int size, enum mode_class class, int limit)\n   /* Get the first mode which has this size, in the specified class.  */\n   for (mode = GET_CLASS_NARROWEST_MODE (class); mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n-    if (GET_MODE_BITSIZE (mode) == size)\n+    if (GET_MODE_PRECISION (mode) == size)\n       return mode;\n \n   return BLKmode;\n@@ -242,7 +242,7 @@ mode_for_size_tree (tree size, enum mode_class class, int limit)\n }\n \n /* Similar, but never return BLKmode; return the narrowest mode that\n-   contains at least the requested number of bits.  */\n+   contains at least the requested number of value bits.  */\n \n enum machine_mode\n smallest_mode_for_size (unsigned int size, enum mode_class class)\n@@ -253,7 +253,7 @@ smallest_mode_for_size (unsigned int size, enum mode_class class)\n      specified class.  */\n   for (mode = GET_CLASS_NARROWEST_MODE (class); mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n-    if (GET_MODE_BITSIZE (mode) >= size)\n+    if (GET_MODE_PRECISION (mode) >= size)\n       return mode;\n \n   abort ();"}]}