{"sha": "00b79d543df80369bf196b27fbaa55cd197d6f92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBiNzlkNTQzZGY4MDM2OWJmMTk2YjI3ZmJhYTU1Y2QxOTdkNmY5Mg==", "commit": {"author": {"name": "Ben Elliston", "email": "bje@au.ibm.com", "date": "2006-01-10T05:46:45Z"}, "committer": {"name": "Ben Elliston", "email": "bje@gcc.gnu.org", "date": "2006-01-10T05:46:45Z"}, "message": "predicates.md (easy_fp_constant): Discount decimal float modes.\n\n\t* config/rs6000/predicates.md (easy_fp_constant): Discount decimal\n\tfloat modes.\n\t* config/rs6000/rs6000.c (rs6000_scalar_mode_supported_p): New.\n\t(TARGET_SCALAR_MODE_SUPPORTED_P): Define.\n\t(USE_FP_FOR_ARG): Reject decimal float modes.\n\t(function_arg_advance): Likewise.\n\t(output_toc): Handle emitting TDmode, DDmode and SDmode constants.\n\t(rs6000_handle_altivec_attribute): Do not permit decimal floating\n\tpoint types in AltiVec vectors.\n\t(rs6000_function_value): Use GP_ARG_RETURN for decimal floats.\n\t(rs6000_libcall_value): Likewise.\n\nFrom-SVN: r109533", "tree": {"sha": "06237c05b3410762367ab5ede70562a518eb0ebb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06237c05b3410762367ab5ede70562a518eb0ebb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00b79d543df80369bf196b27fbaa55cd197d6f92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00b79d543df80369bf196b27fbaa55cd197d6f92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00b79d543df80369bf196b27fbaa55cd197d6f92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00b79d543df80369bf196b27fbaa55cd197d6f92/comments", "author": null, "committer": null, "parents": [{"sha": "eb73ef91353c929d38c5de1fa9916eba72c269c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb73ef91353c929d38c5de1fa9916eba72c269c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb73ef91353c929d38c5de1fa9916eba72c269c6"}], "stats": {"total": 86, "additions": 76, "deletions": 10}, "files": [{"sha": "9363300fd172c4bbdda29233fa359d0c92a52a9f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b79d543df80369bf196b27fbaa55cd197d6f92/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b79d543df80369bf196b27fbaa55cd197d6f92/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=00b79d543df80369bf196b27fbaa55cd197d6f92", "patch": "@@ -1,3 +1,24 @@\n+2006-01-10  Ben Elliston  <bje@au.ibm.com>\n+\n+\t* config/rs6000/predicates.md (easy_fp_constant): Discount decimal\n+\tfloat modes.\n+\t* config/rs6000/rs6000.c (rs6000_scalar_mode_supported_p): New.\n+\t(TARGET_SCALAR_MODE_SUPPORTED_P): Define.\n+\t(USE_FP_FOR_ARG): Reject decimal float modes.\n+\t(function_arg_advance): Likewise.\n+\t(output_toc): Handle emitting TDmode, DDmode and SDmode constants.\n+\t(rs6000_handle_altivec_attribute): Do not permit decimal floating\n+\tpoint types in AltiVec vectors.\n+\t(rs6000_function_value): Use GP_ARG_RETURN for decimal floats.\n+\t(rs6000_libcall_value): Likewise.\n+\n+2006-01-10  Ben Elliston  <bje@au.ibm.com>\n+\n+\t* expr.c (emit_move_change_mode): Always adjust addresses, not\n+\tjust during reload.  Copy replacements only during reload.\n+\t(emit_move_insn_1): Move MODE_DECIMAL_FLOAT modes by invoking\n+\temit_move_via_integer.\n+\n 2006-01-09  Bob Wilson  <bob.wilson@acm.org>\n \n \t* config/xtensa/ieee754-df.S: New file.\n@@ -35,6 +56,12 @@\n \t* config/i386/sse.md (*vec_extractv2di_1_sse2): New.\n \t(*vec_extractv2di_1_sse): New.\n \n+2006-01-09  Ben Elliston  <bje@au.ibm.com>\n+\n+\t* doc/tm.texi (Data Output): Add REAL_VALUE_TO_TARGET_DECIMAL32,\n+\tREAL_VALUE_TO_TARGET_DECIMAL64 and REAL_VALUE_TO_TARGET_DECIMAL64\n+\tmacros.\n+\n 2006-01-09  Ben Elliston  <bje@au.ibm.com>\n \n \t* config/rs6000/rs6000.h (GO_IF_LEGITIMATE_ADDRESS): Typo fix."}, {"sha": "de31fe2e54f2b069b28640b98d28d44470940492", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b79d543df80369bf196b27fbaa55cd197d6f92/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b79d543df80369bf196b27fbaa55cd197d6f92/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=00b79d543df80369bf196b27fbaa55cd197d6f92", "patch": "@@ -1,5 +1,5 @@\n ;; Predicate definitions for POWER and PowerPC.\n-;; Copyright (C) 2005 Free Software Foundation, Inc.\n+;; Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n ;;\n ;; This file is part of GCC.\n ;;\n@@ -195,6 +195,9 @@\n       && mode != DImode)\n     return 1;\n \n+  if (DECIMAL_FLOAT_MODE_P (mode))\n+    return 0;\n+\n   /* If we are using V.4 style PIC, consider all constants to be hard.  */\n   if (flag_pic && DEFAULT_ABI == ABI_V4)\n     return 0;"}, {"sha": "b41a3934f56431da25a510e5aafe1e85e0d9f510", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 45, "deletions": 9, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b79d543df80369bf196b27fbaa55cd197d6f92/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b79d543df80369bf196b27fbaa55cd197d6f92/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=00b79d543df80369bf196b27fbaa55cd197d6f92", "patch": "@@ -1,6 +1,7 @@\n /* Subroutines used for code generation on IBM RS/6000.\n    Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation,\n+   Inc.\n    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n \n    This file is part of GCC.\n@@ -742,6 +743,7 @@ static void rs6000_darwin_file_start (void);\n static tree rs6000_build_builtin_va_list (void);\n static tree rs6000_gimplify_va_arg (tree, tree, tree *, tree *);\n static bool rs6000_must_pass_in_stack (enum machine_mode, tree);\n+static bool rs6000_scalar_mode_supported_p (enum machine_mode);\n static bool rs6000_vector_mode_supported_p (enum machine_mode);\n static int get_vec_cmp_insn (enum rtx_code, enum machine_mode,\n \t\t\t     enum machine_mode);\n@@ -981,6 +983,9 @@ static const char alt_reg_names[][8] =\n #undef TARGET_EH_RETURN_FILTER_MODE\n #define TARGET_EH_RETURN_FILTER_MODE rs6000_eh_return_filter_mode\n \n+#undef TARGET_SCALAR_MODE_SUPPORTED_P\n+#define TARGET_SCALAR_MODE_SUPPORTED_P rs6000_scalar_mode_supported_p\n+\n #undef TARGET_VECTOR_MODE_SUPPORTED_P\n #define TARGET_VECTOR_MODE_SUPPORTED_P rs6000_vector_mode_supported_p\n \n@@ -4140,6 +4145,7 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n /* Nonzero if we can use a floating-point register to pass this arg.  */\n #define USE_FP_FOR_ARG_P(CUM,MODE,TYPE)\t\t\\\n   (SCALAR_FLOAT_MODE_P (MODE)\t\t\t\\\n+   && !DECIMAL_FLOAT_MODE_P (MODE)\t\t\\\n    && (CUM)->fregno <= FP_ARG_MAX_REG\t\t\\\n    && TARGET_HARD_FLOAT && TARGET_FPRS)\n \n@@ -4664,6 +4670,7 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       cum->words = align_words + n_words;\n \n       if (SCALAR_FLOAT_MODE_P (mode)\n+\t  && !DECIMAL_FLOAT_MODE_P (mode)\n \t  && TARGET_HARD_FLOAT && TARGET_FPRS)\n \tcum->fregno += (GET_MODE_SIZE (mode) + 7) >> 3;\n \n@@ -15746,13 +15753,17 @@ output_toc (FILE *file, rtx x, int labelno, enum machine_mode mode)\n   /* Handle FP constants specially.  Note that if we have a minimal\n      TOC, things we put here aren't actually in the TOC, so we can allow\n      FP constants.  */\n-  if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == TFmode)\n+  if (GET_CODE (x) == CONST_DOUBLE &&\n+      (GET_MODE (x) == TFmode || GET_MODE (x) == TDmode))\n     {\n       REAL_VALUE_TYPE rv;\n       long k[4];\n \n       REAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n-      REAL_VALUE_TO_TARGET_LONG_DOUBLE (rv, k);\n+      if (DECIMAL_FLOAT_MODE_P (GET_MODE (x)))\n+\tREAL_VALUE_TO_TARGET_DECIMAL128 (rv, k);\n+      else\n+\tREAL_VALUE_TO_TARGET_LONG_DOUBLE (rv, k);\n \n       if (TARGET_64BIT)\n \t{\n@@ -15781,13 +15792,18 @@ output_toc (FILE *file, rtx x, int labelno, enum machine_mode mode)\n \t  return;\n \t}\n     }\n-  else if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == DFmode)\n+  else if (GET_CODE (x) == CONST_DOUBLE &&\n+\t   (GET_MODE (x) == DFmode || GET_MODE (x) == DDmode))\n     {\n       REAL_VALUE_TYPE rv;\n       long k[2];\n \n       REAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n-      REAL_VALUE_TO_TARGET_DOUBLE (rv, k);\n+\n+      if (DECIMAL_FLOAT_MODE_P (GET_MODE (x)))\n+\tREAL_VALUE_TO_TARGET_DECIMAL64 (rv, k);\n+      else\n+\tREAL_VALUE_TO_TARGET_DOUBLE (rv, k);\n \n       if (TARGET_64BIT)\n \t{\n@@ -15812,13 +15828,17 @@ output_toc (FILE *file, rtx x, int labelno, enum machine_mode mode)\n \t  return;\n \t}\n     }\n-  else if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == SFmode)\n+  else if (GET_CODE (x) == CONST_DOUBLE &&\n+\t   (GET_MODE (x) == SFmode || GET_MODE (x) == SDmode))\n     {\n       REAL_VALUE_TYPE rv;\n       long l;\n \n       REAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n-      REAL_VALUE_TO_TARGET_SINGLE (rv, l);\n+      if (DECIMAL_FLOAT_MODE_P (GET_MODE (x)))\n+\tREAL_VALUE_TO_TARGET_DECIMAL32 (rv, l);\n+      else\n+\tREAL_VALUE_TO_TARGET_SINGLE (rv, l);\n \n       if (TARGET_64BIT)\n \t{\n@@ -17299,6 +17319,8 @@ rs6000_handle_altivec_attribute (tree *node,\n     error (\"use of boolean types in AltiVec types is invalid\");\n   else if (TREE_CODE (type) == COMPLEX_TYPE)\n     error (\"use of %<complex%> in AltiVec types is invalid\");\n+  else if (DECIMAL_FLOAT_MODE_P (mode))\n+    error (\"use of decimal floating point types in AltiVec types is invalid\");\n \n   switch (altivec_type)\n     {\n@@ -19010,7 +19032,9 @@ rs6000_function_value (tree valtype, tree func ATTRIBUTE_UNUSED)\n   else\n     mode = TYPE_MODE (valtype);\n \n-  if (SCALAR_FLOAT_TYPE_P (valtype) && TARGET_HARD_FLOAT && TARGET_FPRS)\n+  if (DECIMAL_FLOAT_MODE_P (mode))\n+    regno = GP_ARG_RETURN;\n+  else if (SCALAR_FLOAT_TYPE_P (valtype) && TARGET_HARD_FLOAT && TARGET_FPRS)\n     regno = FP_ARG_RETURN;\n   else if (TREE_CODE (valtype) == COMPLEX_TYPE\n \t   && targetm.calls.split_complex_arg)\n@@ -19049,7 +19073,9 @@ rs6000_libcall_value (enum machine_mode mode)\n \t\t\t\t      GEN_INT (4))));\n     }\n \n-  if (SCALAR_FLOAT_MODE_P (mode)\n+  if (DECIMAL_FLOAT_MODE_P (mode))\n+    regno = GP_ARG_RETURN;\n+  else if (SCALAR_FLOAT_MODE_P (mode)\n \t   && TARGET_HARD_FLOAT && TARGET_FPRS)\n     regno = FP_ARG_RETURN;\n   else if (ALTIVEC_VECTOR_MODE (mode)\n@@ -19177,6 +19203,16 @@ rs6000_eh_return_filter_mode (void)\n   return TARGET_32BIT ? SImode : word_mode;\n }\n \n+/* Target hook for scalar_mode_supported_p.  */\n+static bool\n+rs6000_scalar_mode_supported_p (enum machine_mode mode)\n+{\n+  if (DECIMAL_FLOAT_MODE_P (mode))\n+    return true;\n+  else\n+    return default_scalar_mode_supported_p (mode);\n+}\n+\n /* Target hook for vector_mode_supported_p.  */\n static bool\n rs6000_vector_mode_supported_p (enum machine_mode mode)"}]}