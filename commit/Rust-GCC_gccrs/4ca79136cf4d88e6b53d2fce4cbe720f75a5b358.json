{"sha": "4ca79136cf4d88e6b53d2fce4cbe720f75a5b358", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNhNzkxMzZjZjRkODhlNmI1M2QyZmNlNGNiZTcyMGY3NWE1YjM1OA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-08-20T09:47:18Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-08-20T09:47:18Z"}, "message": "expr.c (TARGET_MEM_FUNCTIONS): Transform to boolean.\n\n        * expr.c (TARGET_MEM_FUNCTIONS): Transform to boolean.\n        (emit_block_move): Split out subroutines.\n        (emit_block_move_via_movstr): New.\n        (emit_block_move_via_libcall): New.  Emit bcopy via normal call also.\n        (emit_block_move_libcall_fn): New.  Construct function prototype for\n        bcopy as well.\n        (clear_storage): Split out subroutines.\n        (clear_storage_via_clrstr): New.\n        (clear_storage_via_libcall): New. Emit bzero as a normal call also.\n        (clear_storage_libcall_fn): New.  Construct function prototype for\n        bzero as well.\n        (emit_push_insn): Use emit_block_move.\n        (expand_assignment): Booleanize TARGET_MEM_FUNCTIONS.\n        (store_constructor): Likewise.\n\nFrom-SVN: r56464", "tree": {"sha": "5acc2af57c6ff17fc329420a398ca43c4a7b9611", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5acc2af57c6ff17fc329420a398ca43c4a7b9611"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ca79136cf4d88e6b53d2fce4cbe720f75a5b358", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ca79136cf4d88e6b53d2fce4cbe720f75a5b358", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ca79136cf4d88e6b53d2fce4cbe720f75a5b358", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ca79136cf4d88e6b53d2fce4cbe720f75a5b358/comments", "author": null, "committer": null, "parents": [{"sha": "81eec873ab20627ccc460e803c77a554902fd7a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81eec873ab20627ccc460e803c77a554902fd7a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81eec873ab20627ccc460e803c77a554902fd7a9"}], "stats": {"total": 830, "additions": 439, "deletions": 391}, "files": [{"sha": "5a70ba777f97fd91bd078caa58fa6e455a2d0242", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca79136cf4d88e6b53d2fce4cbe720f75a5b358/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca79136cf4d88e6b53d2fce4cbe720f75a5b358/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4ca79136cf4d88e6b53d2fce4cbe720f75a5b358", "patch": "@@ -1,3 +1,20 @@\n+2002-08-20  Richard Henderson  <rth@redhat.com>\n+\n+\t* expr.c (TARGET_MEM_FUNCTIONS): Transform to boolean.\n+\t(emit_block_move): Split out subroutines.\n+\t(emit_block_move_via_movstr): New.\n+\t(emit_block_move_via_libcall): New.  Emit bcopy via normal call also.\n+\t(emit_block_move_libcall_fn): New.  Construct function prototype for\n+\tbcopy as well.\n+\t(clear_storage): Split out subroutines.\n+\t(clear_storage_via_clrstr): New.\n+\t(clear_storage_via_libcall): New. Emit bzero as a normal call also.\n+\t(clear_storage_libcall_fn): New.  Construct function prototype for\n+\tbzero as well.\n+\t(emit_push_insn): Use emit_block_move.\n+\t(expand_assignment): Booleanize TARGET_MEM_FUNCTIONS.\n+\t(store_constructor): Likewise.\n+\n 2002-08-19  Ziemowit Laski  <zlaski@apple.com>\n \n \t* objc/objc-act.c (building_objc_message_expr): Rename to"}, {"sha": "b95de65fb274d28da2acc1ce7a5c4feed908e57a", "filename": "gcc/expr.c", "status": "modified", "additions": 422, "deletions": 391, "changes": 813, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca79136cf4d88e6b53d2fce4cbe720f75a5b358/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca79136cf4d88e6b53d2fce4cbe720f75a5b358/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=4ca79136cf4d88e6b53d2fce4cbe720f75a5b358", "patch": "@@ -73,6 +73,15 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define CASE_VECTOR_PC_RELATIVE 0\n #endif\n \n+/* Convert defined/undefined to boolean.  */\n+#ifdef TARGET_MEM_FUNCTIONS\n+#undef TARGET_MEM_FUNCTIONS\n+#define TARGET_MEM_FUNCTIONS 1\n+#else\n+#define TARGET_MEM_FUNCTIONS 0\n+#endif\n+\n+\n /* If this is nonzero, we do not bother generating VOLATILE\n    around volatile memory references, and we are willing to\n    output indirect addresses.  If cse is to follow, we reject\n@@ -123,6 +132,9 @@ static unsigned HOST_WIDE_INT move_by_pieces_ninsns\n \t\t\t\t\t unsigned int));\n static void move_by_pieces_1\tPARAMS ((rtx (*) (rtx, ...), enum machine_mode,\n \t\t\t\t\t struct move_by_pieces *));\n+static bool emit_block_move_via_movstr PARAMS ((rtx, rtx, rtx, unsigned));\n+static rtx emit_block_move_via_libcall PARAMS ((rtx, rtx, rtx));\n+static tree emit_block_move_libcall_fn PARAMS ((int));\n static rtx clear_by_pieces_1\tPARAMS ((PTR, HOST_WIDE_INT,\n \t\t\t\t\t enum machine_mode));\n static void clear_by_pieces\tPARAMS ((rtx, unsigned HOST_WIDE_INT,\n@@ -132,6 +144,9 @@ static void store_by_pieces_1\tPARAMS ((struct store_by_pieces *,\n static void store_by_pieces_2\tPARAMS ((rtx (*) (rtx, ...),\n \t\t\t\t\t enum machine_mode,\n \t\t\t\t\t struct store_by_pieces *));\n+static bool clear_storage_via_clrstr PARAMS ((rtx, rtx, unsigned));\n+static rtx clear_storage_via_libcall PARAMS ((rtx, rtx));\n+static tree clear_storage_libcall_fn PARAMS ((int));\n static rtx compress_float_constant PARAMS ((rtx, rtx));\n static rtx get_subtarget\tPARAMS ((rtx));\n static int is_zeros_p\t\tPARAMS ((tree));\n@@ -1655,33 +1670,26 @@ move_by_pieces_1 (genfun, mode, data)\n     }\n }\n \f\n-/* Emit code to move a block Y to a block X.\n-   This may be done with string-move instructions,\n-   with multiple scalar move instructions, or with a library call.\n+/* Emit code to move a block Y to a block X.  This may be done with\n+   string-move instructions, with multiple scalar move instructions,\n+   or with a library call.\n \n-   Both X and Y must be MEM rtx's (perhaps inside VOLATILE)\n-   with mode BLKmode.\n+   Both X and Y must be MEM rtx's (perhaps inside VOLATILE) with mode BLKmode.\n    SIZE is an rtx that says how long they are.\n    ALIGN is the maximum alignment we can assume they have.\n \n    Return the address of the new block, if memcpy is called and returns it,\n    0 otherwise.  */\n \n-static GTY(()) tree block_move_fn;\n rtx\n emit_block_move (x, y, size)\n-     rtx x, y;\n-     rtx size;\n+     rtx x, y, size;\n {\n   rtx retval = 0;\n-#ifdef TARGET_MEM_FUNCTIONS\n-  tree call_expr, arg_list;\n-#endif\n   unsigned int align = MIN (MEM_ALIGN (x), MEM_ALIGN (y));\n \n   if (GET_MODE (x) != BLKmode)\n     abort ();\n-\n   if (GET_MODE (y) != BLKmode)\n     abort ();\n \n@@ -1698,163 +1706,218 @@ emit_block_move (x, y, size)\n \n   if (GET_CODE (size) == CONST_INT && MOVE_BY_PIECES_P (INTVAL (size), align))\n     move_by_pieces (x, y, INTVAL (size), align);\n+  else if (emit_block_move_via_movstr (x, y, size, align))\n+    ;\n   else\n-    {\n-      /* Try the most limited insn first, because there's no point\n-\t including more than one in the machine description unless\n-\t the more limited one has some advantage.  */\n-\n-      rtx opalign = GEN_INT (align / BITS_PER_UNIT);\n-      enum machine_mode mode;\n-\n-      /* Since this is a move insn, we don't care about volatility.  */\n-      volatile_ok = 1;\n-\n-      for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n-\t   mode = GET_MODE_WIDER_MODE (mode))\n-\t{\n-\t  enum insn_code code = movstr_optab[(int) mode];\n-\t  insn_operand_predicate_fn pred;\n-\n-\t  if (code != CODE_FOR_nothing\n-\t      /* We don't need MODE to be narrower than BITS_PER_HOST_WIDE_INT\n-\t\t here because if SIZE is less than the mode mask, as it is\n-\t\t returned by the macro, it will definitely be less than the\n-\t\t actual mode mask.  */\n-\t      && ((GET_CODE (size) == CONST_INT\n-\t\t   && ((unsigned HOST_WIDE_INT) INTVAL (size)\n-\t\t       <= (GET_MODE_MASK (mode) >> 1)))\n-\t\t  || GET_MODE_BITSIZE (mode) >= BITS_PER_WORD)\n-\t      && ((pred = insn_data[(int) code].operand[0].predicate) == 0\n-\t\t  || (*pred) (x, BLKmode))\n-\t      && ((pred = insn_data[(int) code].operand[1].predicate) == 0\n-\t\t  || (*pred) (y, BLKmode))\n-\t      && ((pred = insn_data[(int) code].operand[3].predicate) == 0\n-\t\t  || (*pred) (opalign, VOIDmode)))\n-\t    {\n-\t      rtx op2;\n-\t      rtx last = get_last_insn ();\n-\t      rtx pat;\n+    retval = emit_block_move_via_libcall (x, y, size);\n \n-\t      op2 = convert_to_mode (mode, size, 1);\n-\t      pred = insn_data[(int) code].operand[2].predicate;\n-\t      if (pred != 0 && ! (*pred) (op2, mode))\n-\t\top2 = copy_to_mode_reg (mode, op2);\n+  return retval;\n+}\n \n-\t      pat = GEN_FCN ((int) code) (x, y, op2, opalign);\n-\t      if (pat)\n-\t\t{\n-\t\t  emit_insn (pat);\n-\t\t  volatile_ok = 0;\n-\t\t  return 0;\n-\t\t}\n-\t      else\n-\t\tdelete_insns_since (last);\n+/* A subroutine of emit_block_move.  Expand a movstr pattern; \n+   return true if successful.  */\n+\n+static bool\n+emit_block_move_via_movstr (x, y, size, align)\n+     rtx x, y, size;\n+     unsigned int align;\n+{\n+  /* Try the most limited insn first, because there's no point\n+     including more than one in the machine description unless\n+     the more limited one has some advantage.  */\n+\n+  rtx opalign = GEN_INT (align / BITS_PER_UNIT);\n+  enum machine_mode mode;\n+\n+  /* Since this is a move insn, we don't care about volatility.  */\n+  volatile_ok = 1;\n+\n+  for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n+       mode = GET_MODE_WIDER_MODE (mode))\n+    {\n+      enum insn_code code = movstr_optab[(int) mode];\n+      insn_operand_predicate_fn pred;\n+\n+      if (code != CODE_FOR_nothing\n+\t  /* We don't need MODE to be narrower than BITS_PER_HOST_WIDE_INT\n+\t     here because if SIZE is less than the mode mask, as it is\n+\t     returned by the macro, it will definitely be less than the\n+\t     actual mode mask.  */\n+\t  && ((GET_CODE (size) == CONST_INT\n+\t       && ((unsigned HOST_WIDE_INT) INTVAL (size)\n+\t\t   <= (GET_MODE_MASK (mode) >> 1)))\n+\t      || GET_MODE_BITSIZE (mode) >= BITS_PER_WORD)\n+\t  && ((pred = insn_data[(int) code].operand[0].predicate) == 0\n+\t      || (*pred) (x, BLKmode))\n+\t  && ((pred = insn_data[(int) code].operand[1].predicate) == 0\n+\t      || (*pred) (y, BLKmode))\n+\t  && ((pred = insn_data[(int) code].operand[3].predicate) == 0\n+\t      || (*pred) (opalign, VOIDmode)))\n+\t{\n+\t  rtx op2;\n+\t  rtx last = get_last_insn ();\n+\t  rtx pat;\n+\n+\t  op2 = convert_to_mode (mode, size, 1);\n+\t  pred = insn_data[(int) code].operand[2].predicate;\n+\t  if (pred != 0 && ! (*pred) (op2, mode))\n+\t    op2 = copy_to_mode_reg (mode, op2);\n+\n+\t  /* ??? When called via emit_block_move_for_call, it'd be\n+\t     nice if there were some way to inform the backend, so\n+\t     that it doesn't fail the expansion because it thinks\n+\t     emitting the libcall would be more efficient.  */\n+\n+\t  pat = GEN_FCN ((int) code) (x, y, op2, opalign);\n+\t  if (pat)\n+\t    {\n+\t      emit_insn (pat);\n+\t      volatile_ok = 0;\n+\t      return true;\n \t    }\n+\t  else\n+\t    delete_insns_since (last);\n \t}\n+    }\n \n-      volatile_ok = 0;\n+  volatile_ok = 0;\n+  return false;\n+}\n \n-      /* X, Y, or SIZE may have been passed through protect_from_queue.\n+/* A subroutine of emit_block_move.  Expand a call to memcpy or bcopy.\n+   Return the return value from memcpy, 0 otherwise.  */\n \n-\t It is unsafe to save the value generated by protect_from_queue\n-\t and reuse it later.  Consider what happens if emit_queue is\n-\t called before the return value from protect_from_queue is used.\n+static rtx\n+emit_block_move_via_libcall (dst, src, size)\n+     rtx dst, src, size;\n+{\n+  tree call_expr, arg_list, fn, src_tree, dst_tree, size_tree;\n+  enum machine_mode size_mode;\n+  rtx retval;\n \n-\t Expansion of the CALL_EXPR below will call emit_queue before\n-\t we are finished emitting RTL for argument setup.  So if we are\n-\t not careful we could get the wrong value for an argument.\n+  /* DST, SRC, or SIZE may have been passed through protect_from_queue.\n \n-\t To avoid this problem we go ahead and emit code to copy X, Y &\n-\t SIZE into new pseudos.  We can then place those new pseudos\n-\t into an RTL_EXPR and use them later, even after a call to\n-\t emit_queue.\n+     It is unsafe to save the value generated by protect_from_queue\n+     and reuse it later.  Consider what happens if emit_queue is\n+     called before the return value from protect_from_queue is used.\n \n-\t Note this is not strictly needed for library calls since they\n-\t do not call emit_queue before loading their arguments.  However,\n-\t we may need to have library calls call emit_queue in the future\n-\t since failing to do so could cause problems for targets which\n-\t define SMALL_REGISTER_CLASSES and pass arguments in registers.  */\n-      x = copy_to_mode_reg (Pmode, XEXP (x, 0));\n-      y = copy_to_mode_reg (Pmode, XEXP (y, 0));\n+     Expansion of the CALL_EXPR below will call emit_queue before\n+     we are finished emitting RTL for argument setup.  So if we are\n+     not careful we could get the wrong value for an argument.\n \n-#ifdef TARGET_MEM_FUNCTIONS\n-      size = copy_to_mode_reg (TYPE_MODE (sizetype), size);\n-#else\n-      size = convert_to_mode (TYPE_MODE (integer_type_node), size,\n-\t\t\t      TREE_UNSIGNED (integer_type_node));\n-      size = copy_to_mode_reg (TYPE_MODE (integer_type_node), size);\n-#endif\n+     To avoid this problem we go ahead and emit code to copy X, Y &\n+     SIZE into new pseudos.  We can then place those new pseudos\n+     into an RTL_EXPR and use them later, even after a call to\n+     emit_queue.\n \n-#ifdef TARGET_MEM_FUNCTIONS\n-      /* It is incorrect to use the libcall calling conventions to call\n-\t memcpy in this context.\n-\n-\t This could be a user call to memcpy and the user may wish to\n-\t examine the return value from memcpy.\n-\n-\t For targets where libcalls and normal calls have different conventions\n-\t for returning pointers, we could end up generating incorrect code.\n-\n-\t So instead of using a libcall sequence we build up a suitable\n-\t CALL_EXPR and expand the call in the normal fashion.  */\n-      if (block_move_fn == NULL_TREE)\n-\t{\n-\t  tree fntype;\n-\n-\t  /* This was copied from except.c, I don't know if all this is\n-\t     necessary in this context or not.  */\n-\t  block_move_fn = get_identifier (\"memcpy\");\n-\t  fntype = build_pointer_type (void_type_node);\n-\t  fntype = build_function_type (fntype, NULL_TREE);\n-\t  block_move_fn = build_decl (FUNCTION_DECL, block_move_fn, fntype);\n-\t  DECL_EXTERNAL (block_move_fn) = 1;\n-\t  TREE_PUBLIC (block_move_fn) = 1;\n-\t  DECL_ARTIFICIAL (block_move_fn) = 1;\n-\t  TREE_NOTHROW (block_move_fn) = 1;\n-\t  make_decl_rtl (block_move_fn, NULL);\n-\t  assemble_external (block_move_fn);\n-\t}\n-\n-      /* We need to make an argument list for the function call.\n-\n-\t memcpy has three arguments, the first two are void * addresses and\n-\t the last is a size_t byte count for the copy.  */\n-      arg_list\n-\t= build_tree_list (NULL_TREE,\n-\t\t\t   make_tree (build_pointer_type (void_type_node), x));\n-      TREE_CHAIN (arg_list)\n-\t= build_tree_list (NULL_TREE,\n-\t\t\t   make_tree (build_pointer_type (void_type_node), y));\n-      TREE_CHAIN (TREE_CHAIN (arg_list))\n-\t = build_tree_list (NULL_TREE, make_tree (sizetype, size));\n-      TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (arg_list))) = NULL_TREE;\n-\n-      /* Now we have to build up the CALL_EXPR itself.  */\n-      call_expr = build1 (ADDR_EXPR, \n-\t\t\t  build_pointer_type (TREE_TYPE (block_move_fn)), \n-\t\t\t  block_move_fn);\n-      call_expr = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (block_move_fn)),\n-\t\t\t call_expr, arg_list, NULL_TREE);\n-      TREE_SIDE_EFFECTS (call_expr) = 1;\n-\n-      retval = expand_expr (call_expr, NULL_RTX, VOIDmode, 0);\n-#else\n-      emit_library_call (bcopy_libfunc, LCT_NORMAL,\n-\t\t\t VOIDmode, 3, y, Pmode, x, Pmode,\n-\t\t\t convert_to_mode (TYPE_MODE (integer_type_node), size,\n-\t\t\t\t\t  TREE_UNSIGNED (integer_type_node)),\n-\t\t\t TYPE_MODE (integer_type_node));\n-#endif\n+     Note this is not strictly needed for library calls since they\n+     do not call emit_queue before loading their arguments.  However,\n+     we may need to have library calls call emit_queue in the future\n+     since failing to do so could cause problems for targets which\n+     define SMALL_REGISTER_CLASSES and pass arguments in registers.  */\n \n-      /* If we are initializing a readonly value, show the above call\n-\t clobbered it.  Otherwise, a load from it may erroneously be hoisted\n-\t from a loop.  */\n-      if (RTX_UNCHANGING_P (x))\n-\temit_insn (gen_rtx_CLOBBER (VOIDmode, x));\n+  dst = copy_to_mode_reg (Pmode, XEXP (dst, 0));\n+  src = copy_to_mode_reg (Pmode, XEXP (src, 0));\n+\n+  if (TARGET_MEM_FUNCTIONS)\n+    size_mode = TYPE_MODE (sizetype);\n+  else\n+    size_mode = TYPE_MODE (unsigned_type_node);\n+  size = convert_to_mode (size_mode, size, 1);\n+  size = copy_to_mode_reg (size_mode, size);\n+\n+  /* It is incorrect to use the libcall calling conventions to call\n+     memcpy in this context.  This could be a user call to memcpy and\n+     the user may wish to examine the return value from memcpy.  For\n+     targets where libcalls and normal calls have different conventions\n+     for returning pointers, we could end up generating incorrect code.\n+\n+     For convenience, we generate the call to bcopy this way as well.  */\n+\n+  dst_tree = make_tree (ptr_type_node, dst);\n+  src_tree = make_tree (ptr_type_node, src);\n+  if (TARGET_MEM_FUNCTIONS)\n+    size_tree = make_tree (sizetype, size);\n+  else\n+    size_tree = make_tree (unsigned_type_node, size);\n+\n+  fn = emit_block_move_libcall_fn (true);\n+  arg_list = tree_cons (NULL_TREE, size_tree, NULL_TREE);\n+  if (TARGET_MEM_FUNCTIONS)\n+    {\n+      arg_list = tree_cons (NULL_TREE, src_tree, arg_list);\n+      arg_list = tree_cons (NULL_TREE, dst_tree, arg_list);\n+    }\n+  else\n+    {\n+      arg_list = tree_cons (NULL_TREE, dst_tree, arg_list);\n+      arg_list = tree_cons (NULL_TREE, src_tree, arg_list);\n     }\n \n-  return retval;\n+  /* Now we have to build up the CALL_EXPR itself.  */\n+  call_expr = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (fn)), fn);\n+  call_expr = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n+\t\t     call_expr, arg_list, NULL_TREE);\n+  TREE_SIDE_EFFECTS (call_expr) = 1;\n+\n+  retval = expand_expr (call_expr, NULL_RTX, VOIDmode, 0);\n+\n+  /* If we are initializing a readonly value, show the above call\n+     clobbered it.  Otherwise, a load from it may erroneously be\n+     hoisted from a loop.  */\n+  if (RTX_UNCHANGING_P (dst))\n+    emit_insn (gen_rtx_CLOBBER (VOIDmode, dst));\n+\n+  return (TARGET_MEM_FUNCTIONS ? retval : NULL_RTX);\n+}\n+\n+/* A subroutine of emit_block_move_via_libcall.  Create the tree node\n+   for the function we use for block copies.  The first time FOR_CALL\n+   is true, we call assemble_external.  */\n+\n+static GTY(()) tree block_move_fn;\n+\n+static tree\n+emit_block_move_libcall_fn (for_call)\n+      int for_call;\n+{\n+  static bool emitted_extern;\n+  tree fn = block_move_fn, args;\n+\n+  if (!fn)\n+    {\n+      if (TARGET_MEM_FUNCTIONS)\n+\t{\n+\t  fn = get_identifier (\"memcpy\");\n+\t  args = build_function_type_list (ptr_type_node, ptr_type_node,\n+\t\t\t\t\t   const_ptr_type_node, sizetype,\n+\t\t\t\t\t   NULL_TREE);\n+\t}\n+      else\n+\t{\n+\t  fn = get_identifier (\"bcopy\");\n+\t  args = build_function_type_list (void_type_node, const_ptr_type_node,\n+\t\t\t\t\t   ptr_type_node, unsigned_type_node,\n+\t\t\t\t\t   NULL_TREE);\n+\t}\n+\n+      fn = build_decl (FUNCTION_DECL, fn, args);\n+      DECL_EXTERNAL (fn) = 1;\n+      TREE_PUBLIC (fn) = 1;\n+      DECL_ARTIFICIAL (fn) = 1;\n+      TREE_NOTHROW (fn) = 1;\n+\n+      block_move_fn = fn;\n+    }\n+\n+  if (for_call && !emitted_extern)\n+    {\n+      emitted_extern = true;\n+      make_decl_rtl (fn, NULL);\n+      assemble_external (fn);\n+    }\n+\n+  return fn;\n }\n \f\n /* Copy all or part of a value X into registers starting at REGNO.\n@@ -2624,15 +2687,11 @@ store_by_pieces_2 (genfun, mode, data)\n /* Write zeros through the storage of OBJECT.  If OBJECT has BLKmode, SIZE is\n    its length in bytes.  */\n \n-static GTY(()) tree block_clear_fn;\n rtx\n clear_storage (object, size)\n      rtx object;\n      rtx size;\n {\n-#ifdef TARGET_MEM_FUNCTIONS\n-  tree call_expr, arg_list;\n-#endif\n   rtx retval = 0;\n   unsigned int align = (GET_CODE (object) == MEM ? MEM_ALIGN (object)\n \t\t\t: GET_MODE_ALIGNMENT (GET_MODE (object)));\n@@ -2641,7 +2700,7 @@ clear_storage (object, size)\n      just move a zero.  Otherwise, do this a piece at a time.  */\n   if (GET_MODE (object) != BLKmode\n       && GET_CODE (size) == CONST_INT\n-      && GET_MODE_SIZE (GET_MODE (object)) == (unsigned int) INTVAL (size))\n+      && INTVAL (size) == (HOST_WIDE_INT) GET_MODE_SIZE (GET_MODE (object)))\n     emit_move_insn (object, CONST0_RTX (GET_MODE (object)));\n   else\n     {\n@@ -2651,159 +2710,199 @@ clear_storage (object, size)\n       if (GET_CODE (size) == CONST_INT\n \t  && CLEAR_BY_PIECES_P (INTVAL (size), align))\n \tclear_by_pieces (object, INTVAL (size), align);\n+      else if (clear_storage_via_clrstr (object, size, align))\n+\t;\n       else\n-\t{\n-\t  /* Try the most limited insn first, because there's no point\n-\t     including more than one in the machine description unless\n-\t     the more limited one has some advantage.  */\n+\tretval = clear_storage_via_libcall (object, size);\n+    }\n \n-\t  rtx opalign = GEN_INT (align / BITS_PER_UNIT);\n-\t  enum machine_mode mode;\n+  return retval;\n+}\n \n-\t  for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n-\t       mode = GET_MODE_WIDER_MODE (mode))\n-\t    {\n-\t      enum insn_code code = clrstr_optab[(int) mode];\n-\t      insn_operand_predicate_fn pred;\n-\n-\t      if (code != CODE_FOR_nothing\n-\t\t  /* We don't need MODE to be narrower than\n-\t\t     BITS_PER_HOST_WIDE_INT here because if SIZE is less than\n-\t\t     the mode mask, as it is returned by the macro, it will\n-\t\t     definitely be less than the actual mode mask.  */\n-\t\t  && ((GET_CODE (size) == CONST_INT\n-\t\t       && ((unsigned HOST_WIDE_INT) INTVAL (size)\n-\t\t\t   <= (GET_MODE_MASK (mode) >> 1)))\n-\t\t      || GET_MODE_BITSIZE (mode) >= BITS_PER_WORD)\n-\t\t  && ((pred = insn_data[(int) code].operand[0].predicate) == 0\n-\t\t      || (*pred) (object, BLKmode))\n-\t\t  && ((pred = insn_data[(int) code].operand[2].predicate) == 0\n-\t\t      || (*pred) (opalign, VOIDmode)))\n-\t\t{\n-\t\t  rtx op1;\n-\t\t  rtx last = get_last_insn ();\n-\t\t  rtx pat;\n+/* A subroutine of clear_storage.  Expand a clrstr pattern;\n+   return true if successful.  */\n \n-\t\t  op1 = convert_to_mode (mode, size, 1);\n-\t\t  pred = insn_data[(int) code].operand[1].predicate;\n-\t\t  if (pred != 0 && ! (*pred) (op1, mode))\n-\t\t    op1 = copy_to_mode_reg (mode, op1);\n+static bool\n+clear_storage_via_clrstr (object, size, align)\n+     rtx object, size;\n+     unsigned int align;\n+{\n+  /* Try the most limited insn first, because there's no point\n+     including more than one in the machine description unless\n+     the more limited one has some advantage.  */\n \n-\t\t  pat = GEN_FCN ((int) code) (object, op1, opalign);\n-\t\t  if (pat)\n-\t\t    {\n-\t\t      emit_insn (pat);\n-\t\t      return 0;\n-\t\t    }\n-\t\t  else\n-\t\t    delete_insns_since (last);\n-\t\t}\n+  rtx opalign = GEN_INT (align / BITS_PER_UNIT);\n+  enum machine_mode mode;\n+\n+  for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n+       mode = GET_MODE_WIDER_MODE (mode))\n+    {\n+      enum insn_code code = clrstr_optab[(int) mode];\n+      insn_operand_predicate_fn pred;\n+\n+      if (code != CODE_FOR_nothing\n+\t  /* We don't need MODE to be narrower than\n+\t     BITS_PER_HOST_WIDE_INT here because if SIZE is less than\n+\t     the mode mask, as it is returned by the macro, it will\n+\t     definitely be less than the actual mode mask.  */\n+\t  && ((GET_CODE (size) == CONST_INT\n+\t       && ((unsigned HOST_WIDE_INT) INTVAL (size)\n+\t\t   <= (GET_MODE_MASK (mode) >> 1)))\n+\t      || GET_MODE_BITSIZE (mode) >= BITS_PER_WORD)\n+\t  && ((pred = insn_data[(int) code].operand[0].predicate) == 0\n+\t      || (*pred) (object, BLKmode))\n+\t  && ((pred = insn_data[(int) code].operand[2].predicate) == 0\n+\t      || (*pred) (opalign, VOIDmode)))\n+\t{\n+\t  rtx op1;\n+\t  rtx last = get_last_insn ();\n+\t  rtx pat;\n+\n+\t  op1 = convert_to_mode (mode, size, 1);\n+\t  pred = insn_data[(int) code].operand[1].predicate;\n+\t  if (pred != 0 && ! (*pred) (op1, mode))\n+\t    op1 = copy_to_mode_reg (mode, op1);\n+\n+\t  pat = GEN_FCN ((int) code) (object, op1, opalign);\n+\t  if (pat)\n+\t    {\n+\t      emit_insn (pat);\n+\t      return true;\n \t    }\n+\t  else\n+\t    delete_insns_since (last);\n+\t}\n+    }\n \n-\t  /* OBJECT or SIZE may have been passed through protect_from_queue.\n+  return false;\n+}\n \n-\t     It is unsafe to save the value generated by protect_from_queue\n-\t     and reuse it later.  Consider what happens if emit_queue is\n-\t     called before the return value from protect_from_queue is used.\n+/* A subroutine of clear_storage.  Expand a call to memset or bzero.\n+   Return the return value of memset, 0 otherwise.  */\n \n-\t     Expansion of the CALL_EXPR below will call emit_queue before\n-\t     we are finished emitting RTL for argument setup.  So if we are\n-\t     not careful we could get the wrong value for an argument.\n+static rtx\n+clear_storage_via_libcall (object, size)\n+     rtx object, size;\n+{\n+  tree call_expr, arg_list, fn, object_tree, size_tree;\n+  enum machine_mode size_mode;\n+  rtx retval;\n \n-\t     To avoid this problem we go ahead and emit code to copy OBJECT\n-\t     and SIZE into new pseudos.  We can then place those new pseudos\n-\t     into an RTL_EXPR and use them later, even after a call to\n-\t     emit_queue.\n+  /* OBJECT or SIZE may have been passed through protect_from_queue.\n \n-\t     Note this is not strictly needed for library calls since they\n-\t     do not call emit_queue before loading their arguments.  However,\n-\t     we may need to have library calls call emit_queue in the future\n-\t     since failing to do so could cause problems for targets which\n-\t     define SMALL_REGISTER_CLASSES and pass arguments in registers.  */\n-\t  object = copy_to_mode_reg (Pmode, XEXP (object, 0));\n+     It is unsafe to save the value generated by protect_from_queue\n+     and reuse it later.  Consider what happens if emit_queue is\n+     called before the return value from protect_from_queue is used.\n \n-#ifdef TARGET_MEM_FUNCTIONS\n-\t  size = copy_to_mode_reg (TYPE_MODE (sizetype), size);\n-#else\n-\t  size = convert_to_mode (TYPE_MODE (integer_type_node), size,\n-\t\t\t\t  TREE_UNSIGNED (integer_type_node));\n-\t  size = copy_to_mode_reg (TYPE_MODE (integer_type_node), size);\n-#endif\n+     Expansion of the CALL_EXPR below will call emit_queue before\n+     we are finished emitting RTL for argument setup.  So if we are\n+     not careful we could get the wrong value for an argument.\n \n-#ifdef TARGET_MEM_FUNCTIONS\n-\t  /* It is incorrect to use the libcall calling conventions to call\n-\t     memset in this context.\n+     To avoid this problem we go ahead and emit code to copy OBJECT\n+     and SIZE into new pseudos.  We can then place those new pseudos\n+     into an RTL_EXPR and use them later, even after a call to\n+     emit_queue.\n \n-\t     This could be a user call to memset and the user may wish to\n-\t     examine the return value from memset.\n+     Note this is not strictly needed for library calls since they\n+     do not call emit_queue before loading their arguments.  However,\n+     we may need to have library calls call emit_queue in the future\n+     since failing to do so could cause problems for targets which\n+     define SMALL_REGISTER_CLASSES and pass arguments in registers.  */\n \n-\t     For targets where libcalls and normal calls have different\n-\t     conventions for returning pointers, we could end up generating\n-\t     incorrect code.\n+  object = copy_to_mode_reg (Pmode, XEXP (object, 0));\n \n-\t     So instead of using a libcall sequence we build up a suitable\n-\t     CALL_EXPR and expand the call in the normal fashion.  */\n-\t  if (block_clear_fn == NULL_TREE)\n-\t    {\n-\t      tree fntype;\n-\n-\t      /* This was copied from except.c, I don't know if all this is\n-\t\t necessary in this context or not.  */\n-\t      block_clear_fn = get_identifier (\"memset\");\n-\t      fntype = build_pointer_type (void_type_node);\n-\t      fntype = build_function_type (fntype, NULL_TREE);\n-\t      block_clear_fn = build_decl (FUNCTION_DECL, block_clear_fn,\n-\t\t\t\t\t   fntype);\n-\t      DECL_EXTERNAL (block_clear_fn) = 1;\n-\t      TREE_PUBLIC (block_clear_fn) = 1;\n-\t      DECL_ARTIFICIAL (block_clear_fn) = 1;\n-\t      TREE_NOTHROW (block_clear_fn) = 1;\n-\t      make_decl_rtl (block_clear_fn, NULL);\n-\t      assemble_external (block_clear_fn);\n-\t    }\n+  if (TARGET_MEM_FUNCTIONS)\n+    size_mode = TYPE_MODE (sizetype);\n+  else\n+    size_mode = TYPE_MODE (unsigned_type_node);\n+  size = convert_to_mode (size_mode, size, 1);\n+  size = copy_to_mode_reg (size_mode, size);\n \n-\t  /* We need to make an argument list for the function call.\n-\n-\t     memset has three arguments, the first is a void * addresses, the\n-\t     second an integer with the initialization value, the last is a\n-\t     size_t byte count for the copy.  */\n-\t  arg_list\n-\t    = build_tree_list (NULL_TREE,\n-\t\t\t       make_tree (build_pointer_type (void_type_node),\n-\t\t\t\t\t  object));\n-\t  TREE_CHAIN (arg_list)\n-\t    = build_tree_list (NULL_TREE,\n-\t\t\t       make_tree (integer_type_node, const0_rtx));\n-\t  TREE_CHAIN (TREE_CHAIN (arg_list))\n-\t    = build_tree_list (NULL_TREE, make_tree (sizetype, size));\n-\t  TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (arg_list))) = NULL_TREE;\n-\n-\t  /* Now we have to build up the CALL_EXPR itself.  */\n-\t  call_expr = build1 (ADDR_EXPR,\n-\t\t\t      build_pointer_type (TREE_TYPE (block_clear_fn)),\n-\t\t\t      block_clear_fn);\n-\t  call_expr = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (block_clear_fn)),\n-\t\t\t     call_expr, arg_list, NULL_TREE);\n-\t  TREE_SIDE_EFFECTS (call_expr) = 1;\n-\n-\t  retval = expand_expr (call_expr, NULL_RTX, VOIDmode, 0);\n-#else\n-\t  emit_library_call (bzero_libfunc, LCT_NORMAL,\n-\t\t\t     VOIDmode, 2, object, Pmode, size,\n-\t\t\t     TYPE_MODE (integer_type_node));\n-#endif\n+  /* It is incorrect to use the libcall calling conventions to call\n+     memset in this context.  This could be a user call to memset and\n+     the user may wish to examine the return value from memset.  For\n+     targets where libcalls and normal calls have different conventions\n+     for returning pointers, we could end up generating incorrect code.\n+\n+     For convenience, we generate the call to bzero this way as well.  */\n+\n+  object_tree = make_tree (ptr_type_node, object);\n+  if (TARGET_MEM_FUNCTIONS)\n+    size_tree = make_tree (sizetype, size);\n+  else\n+    size_tree = make_tree (unsigned_type_node, size);\n+\n+  fn = clear_storage_libcall_fn (true);\n+  arg_list = tree_cons (NULL_TREE, size_tree, NULL_TREE);\n+  if (TARGET_MEM_FUNCTIONS)\n+    arg_list = tree_cons (NULL_TREE, integer_zero_node, arg_list);\n+  arg_list = tree_cons (NULL_TREE, object_tree, arg_list);\n+\n+  /* Now we have to build up the CALL_EXPR itself.  */\n+  call_expr = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (fn)), fn);\n+  call_expr = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n+\t\t     call_expr, arg_list, NULL_TREE);\n+  TREE_SIDE_EFFECTS (call_expr) = 1;\n+\n+  retval = expand_expr (call_expr, NULL_RTX, VOIDmode, 0);\n+\n+  /* If we are initializing a readonly value, show the above call\n+     clobbered it.  Otherwise, a load from it may erroneously be\n+     hoisted from a loop.  */\n+  if (RTX_UNCHANGING_P (object))\n+    emit_insn (gen_rtx_CLOBBER (VOIDmode, object));\n+\n+  return (TARGET_MEM_FUNCTIONS ? retval : NULL_RTX);\n+}\n+\n+/* A subroutine of clear_storage_via_libcall.  Create the tree node\n+   for the function we use for block clears.  The first time FOR_CALL\n+   is true, we call assemble_external.  */\n \n-\t  /* If we are initializing a readonly value, show the above call\n-\t     clobbered it.  Otherwise, a load from it may erroneously be\n-\t     hoisted from a loop.  */\n-\t  if (RTX_UNCHANGING_P (object))\n-\t    emit_insn (gen_rtx_CLOBBER (VOIDmode, object));\n+static GTY(()) tree block_clear_fn;\n+\n+static tree\n+clear_storage_libcall_fn (for_call)\n+     int for_call;\n+{\n+  static bool emitted_extern;\n+  tree fn = block_clear_fn, args;\n+\n+  if (!fn)\n+    {\n+      if (TARGET_MEM_FUNCTIONS)\n+\t{\n+\t  fn = get_identifier (\"memset\");\n+\t  args = build_function_type_list (ptr_type_node, ptr_type_node,\n+\t\t\t\t\t   integer_type_node, sizetype,\n+\t\t\t\t\t   NULL_TREE);\n \t}\n+      else\n+\t{\n+\t  fn = get_identifier (\"bzero\");\n+\t  args = build_function_type_list (void_type_node, ptr_type_node,\n+\t\t\t\t\t   unsigned_type_node, NULL_TREE);\n+\t}\n+\n+      fn = build_decl (FUNCTION_DECL, fn, args);\n+      DECL_EXTERNAL (fn) = 1;\n+      TREE_PUBLIC (fn) = 1;\n+      DECL_ARTIFICIAL (fn) = 1;\n+      TREE_NOTHROW (fn) = 1;\n+\n+      block_clear_fn = fn;\n     }\n \n-  return retval;\n-}\n+  if (for_call && !emitted_extern)\n+    {\n+      emitted_extern = true;\n+      make_decl_rtl (fn, NULL);\n+      assemble_external (fn);\n+    }\n \n+  return fn;\n+}\n+\f\n /* Generate code to copy Y into X.\n    Both Y and X must have the same mode, except that\n    Y can be a constant with VOIDmode.\n@@ -3501,6 +3600,18 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t\t\t\t\t\t\t\targs_addr,\n \t\t\t\t\t\t\t\targs_so_far),\n \t\t\t\t\t\t  skip));\n+\n+\t  if (!ACCUMULATE_OUTGOING_ARGS)\n+\t    {\n+\t      /* If the source is referenced relative to the stack pointer,\n+\t\t copy it to another register to stabilize it.  We do not need\n+\t\t to do this if we know that we won't be changing sp.  */\n+\n+\t      if (reg_mentioned_p (virtual_stack_dynamic_rtx, temp)\n+\t\t  || reg_mentioned_p (virtual_outgoing_args_rtx, temp))\n+\t\ttemp = copy_to_reg (temp);\n+\t    }\n+\n \t  target = gen_rtx_MEM (BLKmode, temp);\n \n \t  if (type != 0)\n@@ -3515,86 +3626,12 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t  else\n \t    set_mem_align (target, align);\n \n-\t  /* TEMP is the address of the block.  Copy the data there.  */\n-\t  if (GET_CODE (size) == CONST_INT\n-\t      && MOVE_BY_PIECES_P ((unsigned) INTVAL (size), align))\n-\t    {\n-\t      move_by_pieces (target, xinner, INTVAL (size), align);\n-\t      goto ret;\n-\t    }\n-\t  else\n-\t    {\n-\t      rtx opalign = GEN_INT (align / BITS_PER_UNIT);\n-\t      enum machine_mode mode;\n-\n-\t      for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-\t\t   mode != VOIDmode;\n-\t\t   mode = GET_MODE_WIDER_MODE (mode))\n-\t\t{\n-\t\t  enum insn_code code = movstr_optab[(int) mode];\n-\t\t  insn_operand_predicate_fn pred;\n-\n-\t\t  if (code != CODE_FOR_nothing\n-\t\t      && ((GET_CODE (size) == CONST_INT\n-\t\t\t   && ((unsigned HOST_WIDE_INT) INTVAL (size)\n-\t\t\t       <= (GET_MODE_MASK (mode) >> 1)))\n-\t\t\t  || GET_MODE_BITSIZE (mode) >= BITS_PER_WORD)\n-\t\t      && (!(pred = insn_data[(int) code].operand[0].predicate)\n-\t\t\t  || ((*pred) (target, BLKmode)))\n-\t\t      && (!(pred = insn_data[(int) code].operand[1].predicate)\n-\t\t\t  || ((*pred) (xinner, BLKmode)))\n-\t\t      && (!(pred = insn_data[(int) code].operand[3].predicate)\n-\t\t\t  || ((*pred) (opalign, VOIDmode))))\n-\t\t    {\n-\t\t      rtx op2 = convert_to_mode (mode, size, 1);\n-\t\t      rtx last = get_last_insn ();\n-\t\t      rtx pat;\n-\n-\t\t      pred = insn_data[(int) code].operand[2].predicate;\n-\t\t      if (pred != 0 && ! (*pred) (op2, mode))\n-\t\t\top2 = copy_to_mode_reg (mode, op2);\n-\n-\t\t      pat = GEN_FCN ((int) code) (target, xinner,\n-\t\t\t\t\t\t  op2, opalign);\n-\t\t      if (pat)\n-\t\t\t{\n-\t\t\t  emit_insn (pat);\n-\t\t\t  goto ret;\n-\t\t\t}\n-\t\t      else\n-\t\t\tdelete_insns_since (last);\n-\t\t    }\n-\t\t}\n-\t    }\n-\n-\t  if (!ACCUMULATE_OUTGOING_ARGS)\n-\t    {\n-\t      /* If the source is referenced relative to the stack pointer,\n-\t\t copy it to another register to stabilize it.  We do not need\n-\t\t to do this if we know that we won't be changing sp.  */\n-\n-\t      if (reg_mentioned_p (virtual_stack_dynamic_rtx, temp)\n-\t\t  || reg_mentioned_p (virtual_outgoing_args_rtx, temp))\n-\t\ttemp = copy_to_reg (temp);\n-\t    }\n-\n \t  /* Make inhibit_defer_pop nonzero around the library call\n \t     to force it to pop the bcopy-arguments right away.  */\n \t  NO_DEFER_POP;\n-#ifdef TARGET_MEM_FUNCTIONS\n-\t  emit_library_call (memcpy_libfunc, LCT_NORMAL,\n-\t\t\t     VOIDmode, 3, temp, Pmode, XEXP (xinner, 0), Pmode,\n-\t\t\t     convert_to_mode (TYPE_MODE (sizetype),\n-\t\t\t\t\t      size, TREE_UNSIGNED (sizetype)),\n-\t\t\t     TYPE_MODE (sizetype));\n-#else\n-\t  emit_library_call (bcopy_libfunc, LCT_NORMAL,\n-\t\t\t     VOIDmode, 3, XEXP (xinner, 0), Pmode, temp, Pmode,\n-\t\t\t     convert_to_mode (TYPE_MODE (integer_type_node),\n-\t\t\t\t\t      size,\n-\t\t\t\t\t      TREE_UNSIGNED (integer_type_node)),\n-\t\t\t     TYPE_MODE (integer_type_node));\n-#endif\n+\n+\t  emit_block_move (target, xinner, size);\n+\n \t  OK_DEFER_POP;\n \t}\n     }\n@@ -3700,10 +3737,8 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \n \t  emit_move_insn (dest, x);\n \t}\n-\n     }\n \n- ret:\n   /* If part should go in registers, copy that part\n      into the appropriate registers.  Do this now, at the end,\n      since mem-to-mem copies above may do function calls.  */\n@@ -3971,21 +4006,21 @@ expand_assignment (to, from, want_value, suggest_reg)\n       size = expr_size (from);\n       from_rtx = expand_expr (from, NULL_RTX, VOIDmode, 0);\n \n-#ifdef TARGET_MEM_FUNCTIONS\n-      emit_library_call (memmove_libfunc, LCT_NORMAL,\n-\t\t\t VOIDmode, 3, XEXP (to_rtx, 0), Pmode,\n-\t\t\t XEXP (from_rtx, 0), Pmode,\n-\t\t\t convert_to_mode (TYPE_MODE (sizetype),\n-\t\t\t\t\t  size, TREE_UNSIGNED (sizetype)),\n-\t\t\t TYPE_MODE (sizetype));\n-#else\n-      emit_library_call (bcopy_libfunc, LCT_NORMAL,\n-\t\t\t VOIDmode, 3, XEXP (from_rtx, 0), Pmode,\n-\t\t\t XEXP (to_rtx, 0), Pmode,\n-\t\t\t convert_to_mode (TYPE_MODE (integer_type_node),\n-\t\t\t\t\t  size, TREE_UNSIGNED (integer_type_node)),\n-\t\t\t TYPE_MODE (integer_type_node));\n-#endif\n+      if (TARGET_MEM_FUNCTIONS)\n+\temit_library_call (memmove_libfunc, LCT_NORMAL,\n+\t\t\t   VOIDmode, 3, XEXP (to_rtx, 0), Pmode,\n+\t\t\t   XEXP (from_rtx, 0), Pmode,\n+\t\t\t   convert_to_mode (TYPE_MODE (sizetype),\n+\t\t\t\t\t    size, TREE_UNSIGNED (sizetype)),\n+\t\t\t   TYPE_MODE (sizetype));\n+      else\n+        emit_library_call (bcopy_libfunc, LCT_NORMAL,\n+\t\t\t   VOIDmode, 3, XEXP (from_rtx, 0), Pmode,\n+\t\t\t   XEXP (to_rtx, 0), Pmode,\n+\t\t\t   convert_to_mode (TYPE_MODE (integer_type_node),\n+\t\t\t\t\t    size,\n+\t\t\t\t\t    TREE_UNSIGNED (integer_type_node)),\n+\t\t\t   TYPE_MODE (integer_type_node));\n \n       preserve_temp_slots (to_rtx);\n       free_temp_slots ();\n@@ -5048,9 +5083,7 @@ store_constructor (exp, target, cleared, size)\n \t  tree startbit = TREE_PURPOSE (elt);\n \t  /* End of range of element, or element value.  */\n \t  tree endbit   = TREE_VALUE (elt);\n-#ifdef TARGET_MEM_FUNCTIONS\n \t  HOST_WIDE_INT startb, endb;\n-#endif\n \t  rtx bitlength_rtx, startbit_rtx, endbit_rtx, targetx;\n \n \t  bitlength_rtx = expand_expr (bitlength,\n@@ -5091,11 +5124,10 @@ store_constructor (exp, target, cleared, size)\n \t  else\n \t    abort ();\n \n-#ifdef TARGET_MEM_FUNCTIONS\n-\t  /* Optimization:  If startbit and endbit are\n-\t     constants divisible by BITS_PER_UNIT,\n-\t     call memset instead.  */\n-\t  if (TREE_CODE (startbit) == INTEGER_CST\n+\t  /* Optimization:  If startbit and endbit are constants divisible\n+\t     by BITS_PER_UNIT, call memset instead.  */\n+\t  if (TARGET_MEM_FUNCTIONS\n+\t      && TREE_CODE (startbit) == INTEGER_CST\n \t      && TREE_CODE (endbit) == INTEGER_CST\n \t      && (startb = TREE_INT_CST_LOW (startbit)) % BITS_PER_UNIT == 0\n \t      && (endb = TREE_INT_CST_LOW (endbit) + 1) % BITS_PER_UNIT == 0)\n@@ -5110,7 +5142,6 @@ store_constructor (exp, target, cleared, size)\n \t\t\t\t TYPE_MODE (sizetype));\n \t    }\n \t  else\n-#endif\n \t    emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__setbits\"),\n \t\t\t       LCT_NORMAL, VOIDmode, 4, XEXP (targetx, 0),\n \t\t\t       Pmode, bitlength_rtx, TYPE_MODE (sizetype),"}]}