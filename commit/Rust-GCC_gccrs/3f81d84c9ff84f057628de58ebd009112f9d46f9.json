{"sha": "3f81d84c9ff84f057628de58ebd009112f9d46f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y4MWQ4NGM5ZmY4NGYwNTc2MjhkZTU4ZWJkMDA5MTEyZjlkNDZmOQ==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-04-19T16:02:17Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-04-19T16:14:30Z"}, "message": "libphobos: Merge upstream phobos bf0d0a37c\n\nstd.array.Appender and RefAppender: use .opSlice() instead of data()\n\nPreviously, Appender.data() was used to extract a slice of the Appender's array.\nNow use the [] slice operator instead.  The same goes for RefAppender.\n\nFixes: PR d/94455\n\nReviewed-on: https://github.com/dlang/phobos/pull/7450", "tree": {"sha": "52ec38d4755d0a806b5bd4def56e4a8c7fc8fcce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52ec38d4755d0a806b5bd4def56e4a8c7fc8fcce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f81d84c9ff84f057628de58ebd009112f9d46f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f81d84c9ff84f057628de58ebd009112f9d46f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f81d84c9ff84f057628de58ebd009112f9d46f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f81d84c9ff84f057628de58ebd009112f9d46f9/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc186077486fb6e5453157ad8507c66d0a34017c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc186077486fb6e5453157ad8507c66d0a34017c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc186077486fb6e5453157ad8507c66d0a34017c"}], "stats": {"total": 140, "additions": 87, "deletions": 53}, "files": [{"sha": "6025cdcc1f736d26adde2261e54b30a78357a2c1", "filename": "libphobos/src/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f81d84c9ff84f057628de58ebd009112f9d46f9/libphobos%2Fsrc%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f81d84c9ff84f057628de58ebd009112f9d46f9/libphobos%2Fsrc%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMERGE?ref=3f81d84c9ff84f057628de58ebd009112f9d46f9", "patch": "@@ -1,4 +1,4 @@\n-99003a75a883d4ae28b276763f4d1f2a360cf1dd\n+bf0d0a37c4c2d8762ceff7d8677e7584b770800f\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/phobos repository."}, {"sha": "179fa664795f2b321b68df712a6c793fd7717028", "filename": "libphobos/src/std/array.d", "status": "modified", "additions": 86, "deletions": 52, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f81d84c9ff84f057628de58ebd009112f9d46f9/libphobos%2Fsrc%2Fstd%2Farray.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f81d84c9ff84f057628de58ebd009112f9d46f9/libphobos%2Fsrc%2Fstd%2Farray.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Farray.d?ref=3f81d84c9ff84f057628de58ebd009112f9d46f9", "patch": "@@ -2859,9 +2859,18 @@ if (isDynamicArray!A)\n     }\n \n     /**\n+     * Use opSlice() from now on.\n      * Returns: The managed array.\n      */\n     @property inout(ElementEncodingType!A)[] data() inout @trusted pure nothrow\n+    {\n+        return this[];\n+    }\n+\n+    /**\n+     * Returns: The managed array.\n+     */\n+    @property inout(ElementEncodingType!A)[] opSlice() inout @trusted pure nothrow\n     {\n         /* @trusted operation:\n          * casting Unqual!T[] to inout(T)[]\n@@ -3117,13 +3126,13 @@ if (isDynamicArray!A)\n     string b = \"abcdefg\";\n     foreach (char c; b)\n         app.put(c);\n-    assert(app.data == \"abcdefg\");\n+    assert(app[] == \"abcdefg\");\n \n     int[] a = [ 1, 2 ];\n     auto app2 = appender(a);\n     app2.put(3);\n     app2.put([ 4, 5, 6 ]);\n-    assert(app2.data == [ 1, 2, 3, 4, 5, 6 ]);\n+    assert(app2[] == [ 1, 2, 3, 4, 5, 6 ]);\n }\n \n @safe unittest\n@@ -3214,7 +3223,7 @@ if (isDynamicArray!A)\n     if (__traits(compiles, (Appender!A a) => mixin(\"a.\" ~ fn ~ \"(args)\")))\n     {\n         // we do it this way because we can't cache a void return\n-        scope(exit) *this.arr = impl.data;\n+        scope(exit) *this.arr = impl[];\n         mixin(\"return impl.\" ~ fn ~ \"(args);\");\n     }\n \n@@ -3226,7 +3235,7 @@ if (isDynamicArray!A)\n     void opOpAssign(string op : \"~\", U)(U rhs)\n     if (__traits(compiles, (Appender!A a){ a.put(rhs); }))\n     {\n-        scope(exit) *this.arr = impl.data;\n+        scope(exit) *this.arr = impl[];\n         impl.put(rhs);\n     }\n \n@@ -3240,12 +3249,20 @@ if (isDynamicArray!A)\n         return impl.capacity;\n     }\n \n-    /**\n-     * Returns the managed array.\n+    /* Use opSlice() instead.\n+     * Returns: the managed array.\n      */\n     @property inout(ElementEncodingType!A)[] data() inout\n     {\n-        return impl.data;\n+        return impl[];\n+    }\n+\n+    /**\n+     * Returns: the managed array.\n+     */\n+    @property inout(ElementEncodingType!A)[] opSlice() inout\n+    {\n+        return impl[];\n     }\n }\n \n@@ -3255,11 +3272,11 @@ unittest\n {\n     int[] a = [1, 2];\n     auto app2 = appender(&a);\n-    assert(app2.data == [1, 2]);\n+    assert(app2[] == [1, 2]);\n     assert(a == [1, 2]);\n     app2 ~= 3;\n     app2 ~= [4, 5, 6];\n-    assert(app2.data == [1, 2, 3, 4, 5, 6]);\n+    assert(app2[] == [1, 2, 3, 4, 5, 6]);\n     assert(a == [1, 2, 3, 4, 5, 6]);\n \n     app2.reserve(5);\n@@ -3291,33 +3308,33 @@ Appender!(E[]) appender(A : E[], E)(auto ref A array)\n         auto app = appender!(char[])();\n         string b = \"abcdefg\";\n         foreach (char c; b) app.put(c);\n-        assert(app.data == \"abcdefg\");\n+        assert(app[] == \"abcdefg\");\n     }\n     {\n         auto app = appender!(char[])();\n         string b = \"abcdefg\";\n         foreach (char c; b) app ~= c;\n-        assert(app.data == \"abcdefg\");\n+        assert(app[] == \"abcdefg\");\n     }\n     {\n         int[] a = [ 1, 2 ];\n         auto app2 = appender(a);\n-        assert(app2.data == [ 1, 2 ]);\n+        assert(app2[] == [ 1, 2 ]);\n         app2.put(3);\n         app2.put([ 4, 5, 6 ][]);\n-        assert(app2.data == [ 1, 2, 3, 4, 5, 6 ]);\n+        assert(app2[] == [ 1, 2, 3, 4, 5, 6 ]);\n         app2.put([ 7 ]);\n-        assert(app2.data == [ 1, 2, 3, 4, 5, 6, 7 ]);\n+        assert(app2[] == [ 1, 2, 3, 4, 5, 6, 7 ]);\n     }\n \n     int[] a = [ 1, 2 ];\n     auto app2 = appender(a);\n-    assert(app2.data == [ 1, 2 ]);\n+    assert(app2[] == [ 1, 2 ]);\n     app2 ~= 3;\n     app2 ~= [ 4, 5, 6 ][];\n-    assert(app2.data == [ 1, 2, 3, 4, 5, 6 ]);\n+    assert(app2[] == [ 1, 2, 3, 4, 5, 6 ]);\n     app2 ~= [ 7 ];\n-    assert(app2.data == [ 1, 2, 3, 4, 5, 6, 7 ]);\n+    assert(app2[] == [ 1, 2, 3, 4, 5, 6, 7 ]);\n \n     app2.reserve(5);\n     assert(app2.capacity >= 5);\n@@ -3327,12 +3344,12 @@ Appender!(E[]) appender(A : E[], E)(auto ref A array)\n         app2.shrinkTo(3);\n     }\n     catch (Exception) assert(0);\n-    assert(app2.data == [ 1, 2, 3 ]);\n+    assert(app2[] == [ 1, 2, 3 ]);\n     assertThrown(app2.shrinkTo(5));\n \n     const app3 = app2;\n     assert(app3.capacity >= 3);\n-    assert(app3.data == [1, 2, 3]);\n+    assert(app3[] == [1, 2, 3]);\n \n     auto app4 = appender([]);\n     try // shrinkTo may throw\n@@ -3347,29 +3364,29 @@ Appender!(E[]) appender(A : E[], E)(auto ref A array)\n         {\n             Appender!S app5663i;\n             assertNotThrown(app5663i.put(\"\\xE3\"));\n-            assert(app5663i.data == \"\\xE3\");\n+            assert(app5663i[] == \"\\xE3\");\n \n             Appender!S app5663c;\n             assertNotThrown(app5663c.put(cast(const(char)[])\"\\xE3\"));\n-            assert(app5663c.data == \"\\xE3\");\n+            assert(app5663c[] == \"\\xE3\");\n \n             Appender!S app5663m;\n             assertNotThrown(app5663m.put(\"\\xE3\".dup));\n-            assert(app5663m.data == \"\\xE3\");\n+            assert(app5663m[] == \"\\xE3\");\n         }\n         // ditto for ~=\n         {\n             Appender!S app5663i;\n             assertNotThrown(app5663i ~= \"\\xE3\");\n-            assert(app5663i.data == \"\\xE3\");\n+            assert(app5663i[] == \"\\xE3\");\n \n             Appender!S app5663c;\n             assertNotThrown(app5663c ~= cast(const(char)[])\"\\xE3\");\n-            assert(app5663c.data == \"\\xE3\");\n+            assert(app5663c[] == \"\\xE3\");\n \n             Appender!S app5663m;\n             assertNotThrown(app5663m ~= \"\\xE3\".dup);\n-            assert(app5663m.data == \"\\xE3\");\n+            assert(app5663m[] == \"\\xE3\");\n         }\n     }\n \n@@ -3384,7 +3401,7 @@ Appender!(E[]) appender(A : E[], E)(auto ref A array)\n     {\n         auto w = appender!(S10122[])();\n         w.put(S10122(1));\n-        assert(w.data.length == 1 && w.data[0].val == 1);\n+        assert(w[].length == 1 && w[][0].val == 1);\n     });\n }\n \n@@ -3404,7 +3421,7 @@ unittest\n     w ~= 'd';\n     w ~= \"ef\";\n \n-    assert(w.data == \"abcdef\");\n+    assert(w[] == \"abcdef\");\n }\n \n @safe pure nothrow unittest\n@@ -3413,7 +3430,7 @@ unittest\n         auto w = appender!string();\n         w.reserve(4);\n         cast(void) w.capacity;\n-        cast(void) w.data;\n+        cast(void) w[];\n         try\n         {\n             wchar wc = 'a';\n@@ -3427,7 +3444,7 @@ unittest\n         auto w = appender!(int[])();\n         w.reserve(4);\n         cast(void) w.capacity;\n-        cast(void) w.data;\n+        cast(void) w[];\n         w.put(10);\n         w.put([10]);\n         w.clear();\n@@ -3528,7 +3545,7 @@ unittest\n             auto app = appender!(const(E)[])();\n             foreach (i, e; src)\n                     app.put(e);\n-            return app.data;\n+            return app[];\n     }\n \n     class C {}\n@@ -3554,6 +3571,8 @@ unittest\n \n @safe unittest\n {\n+    import std.algorithm.comparison : equal;\n+\n     //New appender signature tests\n     alias mutARR = int[];\n     alias conARR = const(int)[];\n@@ -3563,27 +3582,40 @@ unittest\n     conARR con;\n     immARR imm;\n \n-    {auto app = Appender!mutARR(mut);}                //Always worked. Should work. Should not create a warning.\n+    auto app1 = Appender!mutARR(mut);                //Always worked. Should work. Should not create a warning.\n+    app1.put(7);\n+    assert(equal(app1[], [7]));\n     static assert(!is(typeof(Appender!mutARR(con)))); //Never worked.  Should not work.\n     static assert(!is(typeof(Appender!mutARR(imm)))); //Never worked.  Should not work.\n \n-    {auto app = Appender!conARR(mut);} //Always worked. Should work. Should not create a warning.\n-    {auto app = Appender!conARR(con);} //Didn't work.   Now works.   Should not create a warning.\n-    {auto app = Appender!conARR(imm);} //Didn't work.   Now works.   Should not create a warning.\n+    auto app2 = Appender!conARR(mut); //Always worked. Should work. Should not create a warning.\n+    app2.put(7);\n+    assert(equal(app2[], [7]));\n+    auto app3 = Appender!conARR(con); //Didn't work.   Now works.   Should not create a warning.\n+    app3.put(7);\n+    assert(equal(app3[], [7]));\n+    auto app4 = Appender!conARR(imm); //Didn't work.   Now works.   Should not create a warning.\n+    app4.put(7);\n+    assert(equal(app4[], [7]));\n \n     //{auto app = Appender!immARR(mut);}                //Worked. Will cease to work. Creates warning.\n     //static assert(!is(typeof(Appender!immARR(mut)))); //Worked. Will cease to work. Uncomment me after full deprecation.\n     static assert(!is(typeof(Appender!immARR(con))));   //Never worked. Should not work.\n-    {auto app = Appender!immARR(imm);}                  //Didn't work.  Now works. Should not create a warning.\n+    auto app5 = Appender!immARR(imm);                  //Didn't work.  Now works. Should not create a warning.\n+    app5.put(7);\n+    assert(equal(app5[], [7]));\n \n     //Deprecated. Please uncomment and make sure this doesn't work:\n     //char[] cc;\n     //static assert(!is(typeof(Appender!string(cc))));\n \n     //This should always work:\n-    {auto app = appender!string(null);}\n-    {auto app = appender!(const(char)[])(null);}\n-    {auto app = appender!(char[])(null);}\n+    auto app6 = appender!string(null);\n+    assert(app6[] == null);\n+    auto app7 = appender!(const(char)[])(null);\n+    assert(app7[] == null);\n+    auto app8 = appender!(char[])(null);\n+    assert(app8[] == null);\n }\n \n @safe unittest //Test large allocations (for GC.extend)\n@@ -3594,7 +3626,7 @@ unittest\n     app.reserve(1); //cover reserve on non-initialized\n     foreach (_; 0 .. 100_000)\n         app.put('a');\n-    assert(equal(app.data, 'a'.repeat(100_000)));\n+    assert(equal(app[], 'a'.repeat(100_000)));\n }\n \n @safe unittest\n@@ -3610,7 +3642,9 @@ unittest\n @safe unittest // clear method is supported only for mutable element types\n {\n     Appender!string app;\n+    app.put(\"foo\");\n     static assert(!__traits(compiles, app.clear()));\n+    assert(app[] == \"foo\");\n }\n \n @safe unittest\n@@ -3676,11 +3710,11 @@ unittest\n {\n     int[] a = [1, 2];\n     auto app2 = appender(&a);\n-    assert(app2.data == [1, 2]);\n+    assert(app2[] == [1, 2]);\n     assert(a == [1, 2]);\n     app2 ~= 3;\n     app2 ~= [4, 5, 6];\n-    assert(app2.data == [1, 2, 3, 4, 5, 6]);\n+    assert(app2[] == [1, 2, 3, 4, 5, 6]);\n     assert(a == [1, 2, 3, 4, 5, 6]);\n \n     app2.reserve(5);\n@@ -3695,35 +3729,35 @@ unittest\n         auto app = appender(&arr);\n         string b = \"abcdefg\";\n         foreach (char c; b) app.put(c);\n-        assert(app.data == \"abcdefg\");\n+        assert(app[] == \"abcdefg\");\n         assert(arr == \"abcdefg\");\n     }\n     {\n         auto arr = new char[0];\n         auto app = appender(&arr);\n         string b = \"abcdefg\";\n         foreach (char c; b) app ~= c;\n-        assert(app.data == \"abcdefg\");\n+        assert(app[] == \"abcdefg\");\n         assert(arr == \"abcdefg\");\n     }\n     {\n         int[] a = [ 1, 2 ];\n         auto app2 = appender(&a);\n-        assert(app2.data == [ 1, 2 ]);\n+        assert(app2[] == [ 1, 2 ]);\n         assert(a == [ 1, 2 ]);\n         app2.put(3);\n         app2.put([ 4, 5, 6 ][]);\n-        assert(app2.data == [ 1, 2, 3, 4, 5, 6 ]);\n+        assert(app2[] == [ 1, 2, 3, 4, 5, 6 ]);\n         assert(a == [ 1, 2, 3, 4, 5, 6 ]);\n     }\n \n     int[] a = [ 1, 2 ];\n     auto app2 = appender(&a);\n-    assert(app2.data == [ 1, 2 ]);\n+    assert(app2[] == [ 1, 2 ]);\n     assert(a == [ 1, 2 ]);\n     app2 ~= 3;\n     app2 ~= [ 4, 5, 6 ][];\n-    assert(app2.data == [ 1, 2, 3, 4, 5, 6 ]);\n+    assert(app2[] == [ 1, 2, 3, 4, 5, 6 ]);\n     assert(a == [ 1, 2, 3, 4, 5, 6 ]);\n \n     app2.reserve(5);\n@@ -3734,12 +3768,12 @@ unittest\n         app2.shrinkTo(3);\n     }\n     catch (Exception) assert(0);\n-    assert(app2.data == [ 1, 2, 3 ]);\n+    assert(app2[] == [ 1, 2, 3 ]);\n     assertThrown(app2.shrinkTo(5));\n \n     const app3 = app2;\n     assert(app3.capacity >= 3);\n-    assert(app3.data == [1, 2, 3]);\n+    assert(app3[] == [1, 2, 3]);\n }\n \n @safe unittest // issue 14605\n@@ -3753,7 +3787,7 @@ unittest\n     Appender!(int[]) app;\n     short[] range = [1, 2, 3];\n     app.put(range);\n-    assert(app.data == [1, 2, 3]);\n+    assert(app[] == [1, 2, 3]);\n }\n \n @safe unittest\n@@ -3766,6 +3800,6 @@ unittest\n     put(appA, 'w');\n     s ~= 'a'; //Clobbers here?\n     a ~= 'a'; //Clobbers here?\n-    assert(appS.data == \"hellow\");\n-    assert(appA.data == \"hellow\");\n+    assert(appS[] == \"hellow\");\n+    assert(appA[] == \"hellow\");\n }"}]}