{"sha": "49e651990a6966936a0273138dd56ac394e57b16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDllNjUxOTkwYTY5NjY5MzZhMDI3MzEzOGRkNTZhYzM5NGU1N2IxNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-04-16T11:38:02Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-04-16T11:38:02Z"}, "message": "Mark untyped calls and handle them specially [PR98689]\n\nThis patch fixes a regression introduced by the rtl-ssa patches.\nIt was seen on HPPA but it might be latent elsewhere.\n\nThe problem is that the traditional way of expanding an untyped_call\nis to emit sequences like:\n\n   (call (mem (symbol_ref \"foo\")))\n   (set (reg pseudo1) (reg result1))\n   ...\n   (set (reg pseudon) (reg resultn))\n\nThe ABI specifies that result1..resultn are clobbered by the call but\nnothing in the RTL indicates that result1..resultn are the results\nof the call.  Normally, using a clobbered value gives undefined results,\nbut in this case the results are well-defined and matter for correctness.\n\nThis seems like a niche case, so I think it would be better to mark\nit explicitly rather than try to detect it heuristically.\n\nNote that in expand_builtin_apply we already have an rtx_insn *,\nso it doesn't matter whether we call emit_call_insn or emit_insn.\nCalling emit_insn seems more natural now that the gen_* call\nhas been split out.  It also matches later code in the function.\n\ngcc/\n\tPR rtl-optimization/98689\n\t* reg-notes.def (UNTYPED_CALL): New note.\n\t* combine.c (distribute_notes): Handle it.\n\t* emit-rtl.c (try_split): Likewise.\n\t* rtlanal.c (rtx_properties::try_to_add_insn): Likewise.  Assume\n\tthat calls with the note implicitly set all return value registers.\n\t* builtins.c (expand_builtin_apply): Add a REG_UNTYPED_CALL\n\tto untyped_calls.", "tree": {"sha": "2f7562704a3604487afaa778caac2d52e1e6f1b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f7562704a3604487afaa778caac2d52e1e6f1b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49e651990a6966936a0273138dd56ac394e57b16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49e651990a6966936a0273138dd56ac394e57b16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49e651990a6966936a0273138dd56ac394e57b16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49e651990a6966936a0273138dd56ac394e57b16/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4d6af55fe55c0eab87ab875bfd0346677e12236", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4d6af55fe55c0eab87ab875bfd0346677e12236", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4d6af55fe55c0eab87ab875bfd0346677e12236"}], "stats": {"total": 34, "additions": 32, "deletions": 2}, "files": [{"sha": "d30c4eb62fc54a70a283634129bf116ced3b2958", "filename": "gcc/builtins.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49e651990a6966936a0273138dd56ac394e57b16/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49e651990a6966936a0273138dd56ac394e57b16/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=49e651990a6966936a0273138dd56ac394e57b16", "patch": "@@ -2490,8 +2490,12 @@ expand_builtin_apply (rtx function, rtx arguments, rtx argsize)\n   if (targetm.have_untyped_call ())\n     {\n       rtx mem = gen_rtx_MEM (FUNCTION_MODE, function);\n-      emit_call_insn (targetm.gen_untyped_call (mem, result,\n-\t\t\t\t\t\tresult_vector (1, result)));\n+      rtx_insn *seq = targetm.gen_untyped_call (mem, result,\n+\t\t\t\t\t\tresult_vector (1, result));\n+      for (rtx_insn *insn = seq; insn; insn = NEXT_INSN (insn))\n+\tif (CALL_P (insn))\n+\t  add_reg_note (insn, REG_UNTYPED_CALL, NULL_RTX);\n+      emit_insn (seq);\n     }\n   else if (targetm.have_call_value ())\n     {"}, {"sha": "9063a07bd0098a4d3464e10b07e4a69aa3341506", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49e651990a6966936a0273138dd56ac394e57b16/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49e651990a6966936a0273138dd56ac394e57b16/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=49e651990a6966936a0273138dd56ac394e57b16", "patch": "@@ -14337,6 +14337,7 @@ distribute_notes (rtx notes, rtx_insn *from_insn, rtx_insn *i3, rtx_insn *i2,\n \tcase REG_SETJMP:\n \tcase REG_TM:\n \tcase REG_CALL_DECL:\n+\tcase REG_UNTYPED_CALL:\n \tcase REG_CALL_NOCF_CHECK:\n \t  /* These notes must remain with the call.  It should not be\n \t     possible for both I2 and I3 to be a call.  */"}, {"sha": "07e908624a0935d38598a8870bdec393b552e305", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49e651990a6966936a0273138dd56ac394e57b16/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49e651990a6966936a0273138dd56ac394e57b16/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=49e651990a6966936a0273138dd56ac394e57b16", "patch": "@@ -3964,6 +3964,7 @@ try_split (rtx pat, rtx_insn *trial, int last)\n \t  break;\n \n \tcase REG_CALL_DECL:\n+\tcase REG_UNTYPED_CALL:\n \t  gcc_assert (call_insn != NULL_RTX);\n \t  add_reg_note (call_insn, REG_NOTE_KIND (note), XEXP (note, 0));\n \t  break;"}, {"sha": "995052ebc28e7b005aad2039cfee6b3964603d62", "filename": "gcc/reg-notes.def", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49e651990a6966936a0273138dd56ac394e57b16/gcc%2Freg-notes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49e651990a6966936a0273138dd56ac394e57b16/gcc%2Freg-notes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-notes.def?ref=49e651990a6966936a0273138dd56ac394e57b16", "patch": "@@ -233,6 +233,21 @@ REG_NOTE (STACK_CHECK)\n    insn.  This note is a SYMBOL_REF.  */\n REG_NOTE (CALL_DECL)\n \n+/* Indicates that the call is an untyped_call.  These calls are special\n+   in that they set all of the target ABI's return value registers to a\n+   defined value without explicitly saying so.  For example, a typical\n+   untyped_call sequence has the form:\n+\n+       (call (mem (symbol_ref \"foo\")))\n+       (set (reg pseudo1) (reg result1))\n+       ...\n+       (set (reg pseudon) (reg resultn))\n+\n+   The ABI specifies that result1..resultn are clobbered by the call,\n+   but the RTL does not indicate that result1..resultn are the results\n+   of the call.  */\n+REG_NOTE (UNTYPED_CALL)\n+\n /* Indicate that a call should not be verified for control-flow consistency.\n    The target address of the call is assumed as a valid address and no check\n    to validate a branch to the target address is needed.  The call is marked"}, {"sha": "67a49e65fd850f885aa787db2313c385d62105da", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49e651990a6966936a0273138dd56ac394e57b16/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49e651990a6966936a0273138dd56ac394e57b16/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=49e651990a6966936a0273138dd56ac394e57b16", "patch": "@@ -2333,6 +2333,15 @@ rtx_properties::try_to_add_insn (const rtx_insn *insn, bool include_notes)\n \t      *ref_iter++ = rtx_obj_reference (regno, flags,\n \t\t\t\t\t       reg_raw_mode[regno], 0);\n \t}\n+      /* Untyped calls implicitly set all function value registers.\n+\t Again, we add them first in case the main pattern contains\n+\t a fixed-form clobber.  */\n+      if (find_reg_note (insn, REG_UNTYPED_CALL, NULL_RTX))\n+\tfor (unsigned int regno = 0; regno < FIRST_PSEUDO_REGISTER; ++regno)\n+\t  if (targetm.calls.function_value_regno_p (regno)\n+\t      && ref_iter != ref_end)\n+\t    *ref_iter++ = rtx_obj_reference (regno, rtx_obj_flags::IS_WRITE,\n+\t\t\t\t\t     reg_raw_mode[regno], 0);\n       if (ref_iter != ref_end && !RTL_CONST_CALL_P (insn))\n \t{\n \t  auto mem_flags = rtx_obj_flags::IS_READ;"}]}