{"sha": "0b33adf1a552da45bafde9a512d23330c449ecde", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGIzM2FkZjFhNTUyZGE0NWJhZmRlOWE1MTJkMjMzMzBjNDQ5ZWNkZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-21T12:53:05Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-21T12:53:05Z"}, "message": "[multiple changes]\n\n2010-06-21  Emmanuel Briot  <briot@adacore.com>\n\n\t* s-regpat.adb: Improve debug traces\n\t(Dump): Change output format to keep it smaller.\n\n2010-06-21  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_cg.adb (Generate_CG_Output): Disable redirection of standard\n\toutput to the output file when this routine completes its work.\n\nFrom-SVN: r161073", "tree": {"sha": "734e4e856bf51878241348b0c53b3542314f779a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/734e4e856bf51878241348b0c53b3542314f779a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b33adf1a552da45bafde9a512d23330c449ecde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b33adf1a552da45bafde9a512d23330c449ecde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b33adf1a552da45bafde9a512d23330c449ecde", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b33adf1a552da45bafde9a512d23330c449ecde/comments", "author": null, "committer": null, "parents": [{"sha": "a4c97feb762b546573cbae0abc89303f65845be0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4c97feb762b546573cbae0abc89303f65845be0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4c97feb762b546573cbae0abc89303f65845be0"}], "stats": {"total": 442, "additions": 310, "deletions": 132}, "files": [{"sha": "a79fef6beeb4e33b2a9c33e80a2b30349402a658", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b33adf1a552da45bafde9a512d23330c449ecde/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b33adf1a552da45bafde9a512d23330c449ecde/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0b33adf1a552da45bafde9a512d23330c449ecde", "patch": "@@ -1,3 +1,13 @@\n+2010-06-21  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* s-regpat.adb: Improve debug traces\n+\t(Dump): Change output format to keep it smaller.\n+\n+2010-06-21  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_cg.adb (Generate_CG_Output): Disable redirection of standard\n+\toutput to the output file when this routine completes its work.\n+\n 2010-06-20  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (Subprogram_Body_to_gnu): Use while instead of"}, {"sha": "f307e98619eee8c2362af77d539cb175ecb0d39c", "filename": "gcc/ada/exp_cg.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b33adf1a552da45bafde9a512d23330c449ecde/gcc%2Fada%2Fexp_cg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b33adf1a552da45bafde9a512d23330c449ecde/gcc%2Fada%2Fexp_cg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_cg.adb?ref=0b33adf1a552da45bafde9a512d23330c449ecde", "patch": "@@ -132,6 +132,8 @@ package body Exp_CG is\n             Write_Type_Info (N);\n          end if;\n       end loop;\n+\n+      Set_Special_Output (null);\n    end Generate_CG_Output;\n \n    ----------------"}, {"sha": "0a0ace5cee52a542bc073674570354e3270f19fd", "filename": "gcc/ada/s-regpat.adb", "status": "modified", "additions": 298, "deletions": 132, "changes": 430, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b33adf1a552da45bafde9a512d23330c449ecde/gcc%2Fada%2Fs-regpat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b33adf1a552da45bafde9a512d23330c449ecde/gcc%2Fada%2Fs-regpat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-regpat.adb?ref=0b33adf1a552da45bafde9a512d23330c449ecde", "patch": "@@ -7,7 +7,7 @@\n --                                 B o d y                                  --\n --                                                                          --\n --               Copyright (C) 1986 by University of Toronto.               --\n---                      Copyright (C) 1999-2009, AdaCore                    --\n+--                      Copyright (C) 1999-2010, AdaCore                    --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -47,6 +47,9 @@ with Ada.Unchecked_Conversion;\n \n package body System.Regpat is\n \n+   Debug : constant Boolean := False;\n+   --  Set to True to activate debug traces\n+\n    MAGIC : constant Character := Character'Val (10#0234#);\n    --  The first byte of the regexp internal \"program\" is actually\n    --  this magic number; the start node begins in the second byte.\n@@ -318,6 +321,23 @@ package body System.Regpat is\n    Worst_Expression : constant Expression_Flags := (others => False);\n    --  Worst case\n \n+   procedure Dump_Until\n+     (Program  : Program_Data;\n+      Index    : in out Pointer;\n+      Till     : Pointer;\n+      Indent   : Natural;\n+      Do_Print : Boolean := True);\n+   --  Dump the program until the node Till (not included) is met.\n+   --  Every line is indented with Index spaces at the beginning\n+   --  Dumps till the end if Till is 0.\n+\n+   procedure Dump_Operation\n+      (Program      : Program_Data;\n+       Index        : Pointer;\n+       Indent       : Natural);\n+   --  Same as above, but only dumps a single operation, and compute its\n+   --  indentation from the program\n+\n    ---------\n    -- \"=\" --\n    ---------\n@@ -2036,88 +2056,89 @@ package body System.Regpat is\n       Compile (Matcher, Expression, Size, Flags);\n    end Compile;\n \n-   ----------\n-   -- Dump --\n-   ----------\n-\n-   procedure Dump (Self : Pattern_Matcher) is\n-      Op      : Opcode;\n-      Program : Program_Data renames Self.Program;\n-\n-      procedure Dump_Until\n-        (Start  : Pointer;\n-         Till   : Pointer;\n-         Indent : Natural := 0);\n-      --  Dump the program until the node Till (not included) is met.\n-      --  Every line is indented with Index spaces at the beginning\n-      --  Dumps till the end if Till is 0.\n-\n-      ----------------\n-      -- Dump_Until --\n-      ----------------\n+   --------------------\n+   -- Dump_Operation --\n+   --------------------\n \n-      procedure Dump_Until\n-        (Start  : Pointer;\n-         Till   : Pointer;\n-         Indent : Natural := 0)\n-      is\n-         Next         : Pointer;\n-         Index        : Pointer;\n-         Local_Indent : Natural := Indent;\n-         Length       : Pointer;\n+   procedure Dump_Operation\n+      (Program      : Program_Data;\n+       Index        : Pointer;\n+       Indent       : Natural)\n+   is\n+      Current : Pointer := Index;\n+   begin\n+      Dump_Until (Program, Current, Current + 1, Indent);\n+   end Dump_Operation;\n+\n+   ----------------\n+   -- Dump_Until --\n+   ----------------\n+\n+   procedure Dump_Until\n+      (Program  : Program_Data;\n+       Index    : in out Pointer;\n+       Till     : Pointer;\n+       Indent   : Natural;\n+       Do_Print : Boolean := True)\n+   is\n+      function Image (S : String) return String;\n+      --  Remove leading space\n \n+      function Image (S : String) return String is\n       begin\n-         Index := Start;\n-         while Index < Till loop\n-            Op := Opcode'Val (Character'Pos ((Self.Program (Index))));\n+         if S (S'First) = ' ' then\n+            return S (S'First + 1 .. S'Last);\n+         else\n+            return S;\n+         end if;\n+      end Image;\n \n-            if Op = CLOSE then\n-               Local_Indent := Local_Indent - 3;\n-            end if;\n+      Op      : Opcode;\n+      Next    : Pointer;\n+      Length  : Pointer;\n+      Local_Indent : Natural := Indent;\n \n-            declare\n-               Point : constant String := Pointer'Image (Index);\n+   begin\n+      while Index < Till loop\n+         Op   := Opcode'Val (Character'Pos ((Program (Index))));\n+         Next := Index + Get_Next_Offset (Program, Index);\n \n+         if Do_Print then\n+            declare\n+               Point   : constant String := Pointer'Image (Index);\n             begin\n-               for J in 1 .. 6 - Point'Length loop\n-                  Put (' ');\n-               end loop;\n-\n-               Put (Point\n-                    & \" : \"\n-                    & (1 .. Local_Indent => ' ')\n-                    & Opcode'Image (Op));\n+               Put ((1 .. 4 - Point'Length => ' ')\n+                    & Point & \":\"\n+                    & (1 .. Local_Indent * 2 => ' ') & Opcode'Image (Op));\n             end;\n \n             --  Print the parenthesis number\n \n             if Op = OPEN or else Op = CLOSE or else Op = REFF then\n-               Put (Natural'Image (Character'Pos (Program (Index + 3))));\n+               Put\n+                 (Image (Natural'Image (Character'Pos (Program (Index + 3)))));\n             end if;\n \n-            Next := Index + Get_Next_Offset (Program, Index);\n-\n             if Next = Index then\n-               Put (\"  (next at 0)\");\n+               Put (\" (-)\");\n             else\n-               Put (\"  (next at \" & Pointer'Image (Next) & \")\");\n+               Put (\" (\" & Image (Pointer'Image (Next)) & \")\");\n             end if;\n+         end if;\n \n-            case Op is\n-\n-               --  Character class operand\n-\n-               when ANYOF =>  null;\n-                  declare\n-                     Bitmap  : Character_Class;\n-                     Last    : Character := ASCII.NUL;\n-                     Current : Natural := 0;\n+         case Op is\n+            when ANYOF =>\n+               declare\n+                  Bitmap  : Character_Class;\n+                  Last    : Character := ASCII.NUL;\n+                  Current : Natural := 0;\n+                  Current_Char : Character;\n \n-                     Current_Char : Character;\n+               begin\n+                  Bitmap_Operand (Program, Index, Bitmap);\n \n-                  begin\n-                     Bitmap_Operand (Program, Index, Bitmap);\n-                     Put (\"   operand=\");\n+                  if Do_Print then\n+                     Put (\"[\");\n \n                      while Current <= 255 loop\n                         Current_Char := Character'Val (Current);\n@@ -2135,87 +2156,105 @@ package body System.Regpat is\n                               Current_Char := Character'Val (Current);\n                               exit when\n                                 not Get_From_Class (Bitmap, Current_Char);\n-\n                            end loop;\n \n-                           if Last <= ' ' then\n+                           if not Is_Graphic (Last) then\n                               Put (Last'Img);\n                            else\n                               Put (Last);\n                            end if;\n \n                            if Character'Succ (Last) /= Current_Char then\n-                              Put (\"-\" & Character'Pred (Current_Char));\n+                              Put (\"\\-\" & Character'Pred (Current_Char));\n                            end if;\n \n                         else\n                            Current := Current + 1;\n                         end if;\n                      end loop;\n \n-                     New_Line;\n-                     Index := Index + 3 + Bitmap'Length;\n-                  end;\n+                     Put_Line (\"]\");\n+                  end if;\n \n-               --  string operand\n+                  Index := Index + 3 + Bitmap'Length;\n+               end;\n \n-               when EXACT | EXACTF =>\n-                  Length := String_Length (Program, Index);\n-                  Put (\"   operand (length:\" & Program_Size'Image (Length + 1)\n-                       & \") =\"\n-                       & String (Program (String_Operand (Index)\n-                                          .. String_Operand (Index)\n-                                          + Length)));\n-                  Index := String_Operand (Index) + Length + 1;\n-                  New_Line;\n+            when EXACT | EXACTF =>\n+               Length := String_Length (Program, Index);\n+               if Do_Print then\n+                  Put (\" (\" & Image (Program_Size'Image (Length + 1))\n+                         & \" chars) <\"\n+                         & String (Program (String_Operand (Index)\n+                                              .. String_Operand (Index)\n+                                              + Length)));\n+                  Put_Line (\">\");\n+               end if;\n \n-               --  Node operand\n+               Index := String_Operand (Index) + Length + 1;\n \n-               when BRANCH =>\n-                  New_Line;\n-                  Dump_Until (Index + 3, Next, Local_Indent + 3);\n-                  Index := Next;\n+               --  Node operand\n \n-               when STAR | PLUS =>\n+            when BRANCH | STAR | PLUS =>\n+               if Do_Print then\n                   New_Line;\n+               end if;\n \n-                  --  Only one instruction\n+               Index  := Index + 3;\n+               Dump_Until (Program, Index, Pointer'Min (Next, Till),\n+                           Local_Indent + 1, Do_Print);\n+\n+            when CURLY | CURLYX =>\n+               if Do_Print then\n+                  Put_Line\n+                    (\" {\"\n+                    & Image (Natural'Image (Read_Natural (Program, Index + 3)))\n+                    & \",\"\n+                    & Image (Natural'Image (Read_Natural (Program, Index + 5)))\n+                    & \"}\");\n+               end if;\n \n-                  Dump_Until (Index + 3, Index + 4, Local_Indent + 3);\n-                  Index := Next;\n+               Index  := Index + 7;\n+               Dump_Until (Program, Index, Pointer'Min (Next, Till),\n+                           Local_Indent + 1, Do_Print);\n \n-               when CURLY | CURLYX =>\n-                  Put (\"  {\"\n-                       & Natural'Image (Read_Natural (Program, Index + 3))\n-                       & \",\"\n-                       & Natural'Image (Read_Natural (Program, Index + 5))\n-                       & \"}\");\n+            when OPEN =>\n+               if Do_Print then\n                   New_Line;\n-                  Dump_Until (Index + 7, Next, Local_Indent + 3);\n-                  Index := Next;\n+               end if;\n \n-               when OPEN =>\n-                  New_Line;\n-                  Index := Index + 4;\n-                  Local_Indent := Local_Indent + 3;\n+               Index := Index + 4;\n+               Local_Indent := Local_Indent + 1;\n \n-               when CLOSE | REFF =>\n+            when CLOSE | REFF =>\n+               if Do_Print then\n                   New_Line;\n-                  Index := Index + 4;\n+               end if;\n \n-               when EOP =>\n-                  Index := Index + 3;\n-                  New_Line;\n-                  exit;\n+               Index := Index + 4;\n \n-               --  No operand\n+               if Op = CLOSE then\n+                  Local_Indent := Local_Indent - 1;\n+               end if;\n \n-               when others =>\n-                  Index := Index + 3;\n+            when others =>\n+               Index := Index + 3;\n+\n+               if Do_Print then\n                   New_Line;\n-            end case;\n-         end loop;\n-      end Dump_Until;\n+               end if;\n+\n+               exit when Op = EOP;\n+         end case;\n+      end loop;\n+   end Dump_Until;\n+\n+   ----------\n+   -- Dump --\n+   ----------\n+\n+   procedure Dump (Self : Pattern_Matcher) is\n+      Program : Program_Data renames Self.Program;\n+      Index   : Pointer := Program'First + 1;\n \n    --  Start of processing for Dump\n \n@@ -2238,8 +2277,8 @@ package body System.Regpat is\n          Put_Line (\"  Multiple_Lines mode\");\n       end if;\n \n-      Put_Line (\"     1 : MAGIC\");\n-      Dump_Until (Program_First + 1, Self.Program'Last + 1);\n+      Put_Line (\"   1:MAGIC\");\n+      Dump_Until (Program, Index, Self.Program'Last + 1, 0);\n    end Dump;\n \n    --------------------\n@@ -2401,9 +2440,8 @@ package body System.Regpat is\n       --  using a loop instead of recursion.\n       --  Why is the above comment part of the spec rather than body ???\n \n-      function Match_Whilem (IP : Pointer) return Boolean;\n-      --  Return True if a WHILEM matches\n-      --  How come IP is unreferenced in the body ???\n+      function Match_Whilem return Boolean;\n+      --  Return True if a WHILEM matches the Current_Curly\n \n       function Recurse_Match (IP : Pointer; From : Natural) return Boolean;\n       pragma Inline (Recurse_Match);\n@@ -2418,6 +2456,11 @@ package body System.Regpat is\n          Greedy : Boolean) return Boolean;\n       --  Return True it the simple operator (possibly non-greedy) matches\n \n+      Dump_Indent : Integer := -1;\n+      procedure Dump_Current (Scan : Pointer; Prefix : Boolean := True);\n+      procedure Dump_Error (Msg : String);\n+      --  Debug: print the current context\n+\n       pragma Inline (Index);\n       pragma Inline (Repeat);\n \n@@ -2447,13 +2490,12 @@ package body System.Regpat is\n \n       function Recurse_Match (IP : Pointer; From : Natural) return Boolean is\n          L : constant Natural := Last_Paren;\n-\n          Tmp_F : constant Match_Array :=\n                    Matches_Full (From + 1 .. Matches_Full'Last);\n-\n          Start : constant Natural_Array :=\n                    Matches_Tmp (From + 1 .. Matches_Tmp'Last);\n          Input : constant Natural := Input_Pos;\n+         Dump_Indent_Save : constant Integer := Dump_Indent;\n \n       begin\n          if Match (IP) then\n@@ -2464,9 +2506,42 @@ package body System.Regpat is\n          Matches_Full (Tmp_F'Range) := Tmp_F;\n          Matches_Tmp (Start'Range) := Start;\n          Input_Pos := Input;\n+         Dump_Indent := Dump_Indent_Save;\n          return False;\n       end Recurse_Match;\n \n+      ------------------\n+      -- Dump_Current --\n+      ------------------\n+\n+      procedure Dump_Current (Scan : Pointer; Prefix : Boolean := True) is\n+         Length : constant := 10;\n+         Pos : constant String := Integer'Image (Input_Pos);\n+      begin\n+         if Prefix then\n+            Put ((1 .. 5 - Pos'Length => ' '));\n+            Put (Pos & \" <\"\n+                 & Data (Input_Pos\n+                     .. Integer'Min (Last_In_Data, Input_Pos + Length - 1)));\n+            Put ((1 .. Length - 1 - Last_In_Data + Input_Pos => ' '));\n+            Put (\"> |\");\n+         else\n+            Put (\"                    \");\n+         end if;\n+         Dump_Operation (Program, Scan, Indent => Dump_Indent);\n+      end Dump_Current;\n+\n+      ----------------\n+      -- Dump_Error --\n+      ----------------\n+\n+      procedure Dump_Error (Msg : String) is\n+      begin\n+         Put (\"                   |     \");\n+         Put ((1 .. Dump_Indent * 2 => ' '));\n+         Put_Line (Msg);\n+      end Dump_Error;\n+\n       -----------\n       -- Match --\n       -----------\n@@ -2475,8 +2550,11 @@ package body System.Regpat is\n          Scan   : Pointer := IP;\n          Next   : Pointer;\n          Op     : Opcode;\n+         Result : Boolean;\n \n       begin\n+         Dump_Indent := Dump_Indent + 1;\n+\n          State_Machine :\n          loop\n             pragma Assert (Scan /= 0);\n@@ -2490,8 +2568,13 @@ package body System.Regpat is\n \n             Next := Get_Next (Program, Scan);\n \n+            if Debug then\n+               Dump_Current (Scan);\n+            end if;\n+\n             case Op is\n                when EOP =>\n+                  Dump_Indent := Dump_Indent - 1;\n                   return True;  --  Success !\n \n                when BRANCH =>\n@@ -2501,6 +2584,7 @@ package body System.Regpat is\n                   else\n                      loop\n                         if Recurse_Match (Operand (Scan), 0) then\n+                           Dump_Indent := Dump_Indent - 1;\n                            return True;\n                         end if;\n \n@@ -2517,7 +2601,7 @@ package body System.Regpat is\n                when BOL =>\n                   exit State_Machine when Input_Pos /= BOL_Pos\n                     and then ((Self.Flags and Multiple_Lines) = 0\n-                              or else Data (Input_Pos - 1) /= ASCII.LF);\n+                      or else Data (Input_Pos - 1) /= ASCII.LF);\n \n                when MBOL =>\n                   exit State_Machine when Input_Pos /= BOL_Pos\n@@ -2686,6 +2770,10 @@ package body System.Regpat is\n                      --  If we haven't seen that parenthesis yet\n \n                      if Last_Paren < No then\n+                        Dump_Indent := Dump_Indent - 1;\n+                        if Debug then\n+                           Dump_Error (\"REFF: No match, backtracking\");\n+                        end if;\n                         return False;\n                      end if;\n \n@@ -2695,6 +2783,10 @@ package body System.Regpat is\n                         if Input_Pos > Last_In_Data\n                           or else Data (Input_Pos) /= Data (Data_Pos)\n                         then\n+                           Dump_Indent := Dump_Indent - 1;\n+                           if Debug then\n+                              Dump_Error (\"REFF: No match, backtracking\");\n+                           end if;\n                            return False;\n                         end if;\n \n@@ -2711,7 +2803,9 @@ package body System.Regpat is\n                      Greed : constant Boolean := Greedy;\n                   begin\n                      Greedy := True;\n-                     return Match_Simple_Operator (Op, Scan, Next, Greed);\n+                     Result := Match_Simple_Operator (Op, Scan, Next, Greed);\n+                     Dump_Indent := Dump_Indent - 1;\n+                     return Result;\n                   end;\n \n                when CURLYX =>\n@@ -2742,23 +2836,40 @@ package body System.Regpat is\n                             Next        => Next,\n                             Lastloc     => 0,\n                             Old_Cc      => Current_Curly);\n+                     Greedy := True;\n                      Current_Curly := Cc'Unchecked_Access;\n \n                      Has_Match := Match (Next - 3);\n \n                      --  Start on the WHILEM\n \n                      Current_Curly := Cc.Old_Cc;\n+                     Dump_Indent := Dump_Indent - 1;\n+                     if not Has_Match then\n+                        if Debug then\n+                           Dump_Error (\"CURLYX failed...\");\n+                        end if;\n+                     end if;\n                      return Has_Match;\n                   end;\n \n                when WHILEM =>\n-                  return Match_Whilem (IP);\n+                  Result := Match_Whilem;\n+                  Dump_Indent := Dump_Indent - 1;\n+                  if Debug and then not Result then\n+                     Dump_Error (\"WHILEM: no match, backtracking\");\n+                  end if;\n+                  return Result;\n             end case;\n \n             Scan := Next;\n          end loop State_Machine;\n \n+         if Debug then\n+            Dump_Error (\"failed...\");\n+            Dump_Indent := Dump_Indent - 1;\n+         end if;\n+\n          --  If we get here, there is no match.\n          --  For successful matches when EOP is the terminating point.\n \n@@ -2811,16 +2922,24 @@ package body System.Regpat is\n                Operand_Code := Scan + 7;\n          end case;\n \n+         if Debug then\n+            Dump_Current (Operand_Code, Prefix => False);\n+         end if;\n+\n          --  Non greedy operators\n \n          if not Greedy then\n \n-            --  Test the minimal repetitions\n+            --  Test we can repeat at least Min times\n \n-            if Min /= 0\n-              and then Repeat (Operand_Code, Min) < Min\n-            then\n-               return False;\n+            if Min /= 0 then\n+               No := Repeat (Operand_Code, Min);\n+               if No < Min then\n+                  if Debug then\n+                     Dump_Error (\"failed... matched\" & No'Img & \" times\");\n+                  end if;\n+                  return False;\n+               end if;\n             end if;\n \n             Old := Input_Pos;\n@@ -2842,6 +2961,10 @@ package body System.Regpat is\n \n                --  Look for the first possible opportunity\n \n+               if Debug then\n+                  Dump_Error (\"Next_Char must be \" & Next_Char);\n+               end if;\n+\n                loop\n                   --  Find the next possible position\n \n@@ -2864,6 +2987,10 @@ package body System.Regpat is\n                   begin\n                      Input_Pos := Old;\n \n+                     if Debug then\n+                        Dump_Error (\"Would we still match at that position?\");\n+                     end if;\n+\n                      if Repeat (Operand_Code, Num) < Num then\n                         return False;\n                      end if;\n@@ -2879,14 +3006,18 @@ package body System.Regpat is\n                   Input_Pos := Input_Pos + 1;\n                end loop;\n \n-            --  We know what the next character is\n+            --  We do not know what the next character is\n \n             else\n                while Max >= Min loop\n+                  if Debug then\n+                     Dump_Error (\"Non-greedy repeat, N=\" & Min'Img);\n+                     Dump_Error (\"Do we still match Next if we stop here?\");\n+                  end if;\n \n                   --  If the next character matches\n \n-                  if Match (Next) then\n+                  if Recurse_Match (Next, 1) then\n                      return True;\n                   end if;\n \n@@ -2897,6 +3028,9 @@ package body System.Regpat is\n                   if Repeat (Operand_Code, 1) /= 0 then\n                      Min := Min + 1;\n                   else\n+                     if Debug then\n+                        Dump_Error (\"Non-greedy repeat failed...\");\n+                     end if;\n                      return False;\n                   end if;\n                end loop;\n@@ -2909,6 +3043,10 @@ package body System.Regpat is\n          else\n             No := Repeat (Operand_Code, Max);\n \n+            if Debug and then No < Min then\n+               Dump_Error (\"failed... matched\" & No'Img & \" times\");\n+            end if;\n+\n             --  ??? Perl has some special code here in case the\n             --  next instruction is of type EOL, since $ and \\Z\n             --  can match before *and* after newline at the end.\n@@ -2948,9 +3086,7 @@ package body System.Regpat is\n       --  tree by recursing ever deeper.  And if it fails, we have to reset\n       --  our parent's current state that we can try again after backing off.\n \n-      function Match_Whilem (IP : Pointer) return Boolean is\n-         pragma Unreferenced (IP);\n-\n+      function Match_Whilem return Boolean is\n          Cc : constant Current_Curly_Access := Current_Curly;\n          N  : constant Natural              := Cc.Cur + 1;\n          Ln : Natural                       := 0;\n@@ -2991,12 +3127,22 @@ package body System.Regpat is\n             Cc.Cur := N;\n             Cc.Lastloc := Input_Pos;\n \n+            if Debug then\n+               Dump_Error\n+                 (\"Tests that we match at least\" & Cc.Min'Img & \" N=\" & N'Img);\n+            end if;\n+\n             if Match (Cc.Scan) then\n                return True;\n             end if;\n \n             Cc.Cur := N - 1;\n             Cc.Lastloc := Lastloc;\n+\n+            if Debug then\n+               Dump_Error (\"failed...\");\n+            end if;\n+\n             return False;\n          end if;\n \n@@ -3022,13 +3168,20 @@ package body System.Regpat is\n             --  Maximum greed exceeded ?\n \n             if N >= Cc.Max then\n+               if Debug then\n+                  Dump_Error (\"failed...\");\n+               end if;\n                return False;\n             end if;\n \n             --  Try scanning more and see if it helps\n             Cc.Cur := N;\n             Cc.Lastloc := Input_Pos;\n \n+            if Debug then\n+               Dump_Error (\"Next failed, what about Current?\");\n+            end if;\n+\n             if Recurse_Match (Cc.Scan, Cc.Paren_Floor) then\n                return True;\n             end if;\n@@ -3044,6 +3197,10 @@ package body System.Regpat is\n             Cc.Cur := N;\n             Cc.Lastloc := Input_Pos;\n \n+            if Debug then\n+               Dump_Error (\"Recurse at current position\");\n+            end if;\n+\n             if Recurse_Match (Cc.Scan, Cc.Paren_Floor) then\n                return True;\n             end if;\n@@ -3057,6 +3214,10 @@ package body System.Regpat is\n             Ln := Current_Curly.Cur;\n          end if;\n \n+         if Debug then\n+            Dump_Error (\"Failed matching for later positions\");\n+         end if;\n+\n          if Match (Cc.Next) then\n             return True;\n          end if;\n@@ -3068,6 +3229,11 @@ package body System.Regpat is\n          Current_Curly := Cc;\n          Cc.Cur := N - 1;\n          Cc.Lastloc := Lastloc;\n+\n+         if Debug then\n+            Dump_Error (\"failed...\");\n+         end if;\n+\n          return False;\n       end Match_Whilem;\n "}]}