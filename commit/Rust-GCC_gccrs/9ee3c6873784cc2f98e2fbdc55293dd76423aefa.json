{"sha": "9ee3c6873784cc2f98e2fbdc55293dd76423aefa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWVlM2M2ODczNzg0Y2MyZjk4ZTJmYmRjNTUyOTNkZDc2NDIzYWVmYQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1997-04-21T17:57:09Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1997-04-21T17:57:09Z"}, "message": "(output_addsi3): New function.  From addsi3 pattern.\n\nFrom-SVN: r13952", "tree": {"sha": "85b35d7eae975572a271c88a11784b4828ae9e8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85b35d7eae975572a271c88a11784b4828ae9e8a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ee3c6873784cc2f98e2fbdc55293dd76423aefa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ee3c6873784cc2f98e2fbdc55293dd76423aefa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ee3c6873784cc2f98e2fbdc55293dd76423aefa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ee3c6873784cc2f98e2fbdc55293dd76423aefa/comments", "author": null, "committer": null, "parents": [{"sha": "079e639f76c1754f74b8e2dd3f5c88c9437e4596", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/079e639f76c1754f74b8e2dd3f5c88c9437e4596", "html_url": "https://github.com/Rust-GCC/gccrs/commit/079e639f76c1754f74b8e2dd3f5c88c9437e4596"}], "stats": {"total": 91, "additions": 91, "deletions": 0}, "files": [{"sha": "2b3022e156387641b3869b234d2d6dbe2ffddae3", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ee3c6873784cc2f98e2fbdc55293dd76423aefa/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ee3c6873784cc2f98e2fbdc55293dd76423aefa/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=9ee3c6873784cc2f98e2fbdc55293dd76423aefa", "patch": "@@ -1951,6 +1951,97 @@ find_addr_reg (addr)\n     return addr;\n   abort ();\n }\n+\n+/* Output assembler code to perform a 32 bit 3 operand add.  */\n+\n+char *\n+output_addsi3 (operands)\n+     rtx *operands;\n+{\n+  if (! operands_match_p (operands[0], operands[1]))\n+    {\n+      if (!ADDRESS_REG_P (operands[1]))\n+\t{\n+\t  rtx tmp = operands[1];\n+\n+\t  operands[1] = operands[2];\n+\t  operands[2] = tmp;\n+\t}\n+\n+      /* These insns can result from reloads to access\n+\t stack slots over 64k from the frame pointer.  */\n+      if (GET_CODE (operands[2]) == CONST_INT\n+\t  && INTVAL (operands[2]) + 0x8000 >= (unsigned) 0x10000)\n+        return \"move%.l %2,%0\\\\;add%.l %1,%0\";\n+#ifdef SGS\n+      if (GET_CODE (operands[2]) == REG)\n+\treturn \"lea 0(%1,%2.l),%0\";\n+      else\n+\treturn \"lea %c2(%1),%0\";\n+#else /* not SGS */\n+#ifdef MOTOROLA\n+      if (GET_CODE (operands[2]) == REG)\n+\treturn \"lea (%1,%2.l),%0\";\n+      else\n+\treturn \"lea (%c2,%1),%0\";\n+#else /* not MOTOROLA (MIT syntax) */\n+      if (GET_CODE (operands[2]) == REG)\n+\treturn \"lea %1@(0,%2:l),%0\";\n+      else\n+\treturn \"lea %1@(%c2),%0\";\n+#endif /* not MOTOROLA */\n+#endif /* not SGS */\n+    }\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+#ifndef NO_ADDSUB_Q\n+      if (INTVAL (operands[2]) > 0\n+\t  && INTVAL (operands[2]) <= 8)\n+\treturn \"addq%.l %2,%0\";\n+      if (INTVAL (operands[2]) < 0\n+\t  && INTVAL (operands[2]) >= -8)\n+        {\n+\t  operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t         - INTVAL (operands[2]));\n+\t  return \"subq%.l %2,%0\";\n+\t}\n+      /* On the CPU32 it is faster to use two addql instructions to\n+\t add a small integer (8 < N <= 16) to a register.\n+\t Likewise for subql. */\n+      if (TARGET_CPU32 && REG_P (operands[0]))\n+\t{\n+\t  if (INTVAL (operands[2]) > 8\n+\t      && INTVAL (operands[2]) <= 16)\n+\t    {\n+\t      operands[2] = gen_rtx (CONST_INT, VOIDmode, \n+\t\t\t\t      INTVAL (operands[2]) - 8);\n+\t      return \"addq%.l %#8,%0\\\\;addq%.l %2,%0\";\n+\t    }\n+\t  if (INTVAL (operands[2]) < -8\n+\t      && INTVAL (operands[2]) >= -16)\n+\t    {\n+\t      operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t      - INTVAL (operands[2]) - 8);\n+\t      return \"subq%.l %#8,%0\\\\;subq%.l %2,%0\";\n+\t    }\n+\t}\n+#endif\n+      if (ADDRESS_REG_P (operands[0])\n+\t  && INTVAL (operands[2]) >= -0x8000\n+\t  && INTVAL (operands[2]) < 0x8000)\n+\t{\n+\t  if (TARGET_68040)\n+\t    return \"add%.w %2,%0\";\n+\t  else\n+#ifdef MOTOROLA  \n+\t    return \"lea (%c2,%0),%0\";\n+#else\n+\t    return \"lea %0@(%c2),%0\";\n+#endif\n+\t}\n+    }\n+  return \"add%.l %2,%0\";\n+}\n \f\n /* Store in cc_status the expressions that the condition codes will\n    describe after execution of an instruction whose pattern is EXP."}]}