{"sha": "204a913bda3c3228723ea13e41c9dd831c362b33", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA0YTkxM2JkYTNjMzIyODcyM2VhMTNlNDFjOWRkODMxYzM2MmIzMw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2015-01-08T21:30:56Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2015-01-08T21:30:56Z"}, "message": "re PR tree-optimization/63989 (tree-ssa-strlen.c doesn't handle constant pointer plus and array refs if constant offset is smaller than known constant string length)\n\n\tPR tree-optimization/63989\n\t* params.def (PARAM_MAX_TRACKED_STRLENS): Increment default\n\tfrom 1000 to 10000.\n\t* tree-ssa-strlen.c (get_strinfo): Moved earlier.\n\t(get_stridx): If we don't have a record for certain SSA_NAME,\n\tbut it is POINTER_PLUS_EXPR of some SSA_NAME we do with\n\tconstant offset, call get_stridx_plus_constant.\n\t(get_stridx_plus_constant): New function.\n\t(zero_length_string): Don't use get_stridx here.\n\n\t* gcc.dg/strlenopt-27.c: New test.\n\nFrom-SVN: r219362", "tree": {"sha": "769905ce0ea2dd0ec84a6ed340016c2adba5f3d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/769905ce0ea2dd0ec84a6ed340016c2adba5f3d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/204a913bda3c3228723ea13e41c9dd831c362b33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/204a913bda3c3228723ea13e41c9dd831c362b33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/204a913bda3c3228723ea13e41c9dd831c362b33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/204a913bda3c3228723ea13e41c9dd831c362b33/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "57534689d75b6164dae4ac7f5c6f23d543f63583", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57534689d75b6164dae4ac7f5c6f23d543f63583", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57534689d75b6164dae4ac7f5c6f23d543f63583"}], "stats": {"total": 182, "additions": 168, "deletions": 14}, "files": [{"sha": "33ba9dae10a771a70ece9856b786a4a35955fb03", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/204a913bda3c3228723ea13e41c9dd831c362b33/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/204a913bda3c3228723ea13e41c9dd831c362b33/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=204a913bda3c3228723ea13e41c9dd831c362b33", "patch": "@@ -1,5 +1,15 @@\n 2015-01-08  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR tree-optimization/63989\n+\t* params.def (PARAM_MAX_TRACKED_STRLENS): Increment default\n+\tfrom 1000 to 10000.\n+\t* tree-ssa-strlen.c (get_strinfo): Moved earlier.\n+\t(get_stridx): If we don't have a record for certain SSA_NAME,\n+\tbut it is POINTER_PLUS_EXPR of some SSA_NAME we do with\n+\tconstant offset, call get_stridx_plus_constant.\n+\t(get_stridx_plus_constant): New function.\n+\t(zero_length_string): Don't use get_stridx here.\n+\n \tPR target/55023\n \tPR middle-end/64388\n \t* dse.c (struct insn_info): Mention frame_read set also"}, {"sha": "cbdc4774047cda482d447a0a9e58af5e010cfbf7", "filename": "gcc/params.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/204a913bda3c3228723ea13e41c9dd831c362b33/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/204a913bda3c3228723ea13e41c9dd831c362b33/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=204a913bda3c3228723ea13e41c9dd831c362b33", "patch": "@@ -1078,7 +1078,7 @@ DEFPARAM (PARAM_MAX_TRACKED_STRLENS,\n \t  \"max-tracked-strlens\",\n \t  \"Maximum number of strings for which strlen optimization pass will \"\n \t  \"track string lengths\",\n-\t  1000, 0, 0)\n+\t  10000, 0, 0)\n \n /* Keep this in sync with the sched_pressure_algorithm enum.  */\n DEFPARAM (PARAM_SCHED_PRESSURE_ALGORITHM,"}, {"sha": "c3ab41832ad3a8fbbf7b70c6cfec3fa63df659b7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/204a913bda3c3228723ea13e41c9dd831c362b33/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/204a913bda3c3228723ea13e41c9dd831c362b33/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=204a913bda3c3228723ea13e41c9dd831c362b33", "patch": "@@ -1,3 +1,8 @@\n+2015-01-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/63989\n+\t* gcc.dg/strlenopt-27.c: New test.\n+\n 2015-01-08  David Malcolm  <dmalcolm@redhat.com>\n \n \t* jit.dg/harness.h (set_up_logging): New function."}, {"sha": "8d06aac26111f0abe7eaf25abbad7608f2e7f958", "filename": "gcc/testsuite/gcc.dg/strlenopt-27.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/204a913bda3c3228723ea13e41c9dd831c362b33/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-27.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/204a913bda3c3228723ea13e41c9dd831c362b33/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-27.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-27.c?ref=204a913bda3c3228723ea13e41c9dd831c362b33", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+#include \"strlenopt.h\"\n+\n+__attribute__((noinline, noclone)) size_t\n+fn1 (char *p)\n+{\n+  strcpy (p, \"foobar\");\n+  return strlen (p + 2); // This strlen should be optimized into 4.\n+}\n+\n+int\n+main (void)\n+{\n+  char p[] = \"barfoo\";\n+  if (fn1 (p) != 4)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { cleanup-tree-dump \"strlen\" } } */"}, {"sha": "c9e8f1e5292aab0436b1d4d501dec00a7bdca81a", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 129, "deletions": 13, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/204a913bda3c3228723ea13e41c9dd831c362b33/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/204a913bda3c3228723ea13e41c9dd831c362b33/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=204a913bda3c3228723ea13e41c9dd831c362b33", "patch": "@@ -181,6 +181,18 @@ struct laststmt_struct\n   int stridx;\n } laststmt;\n \n+static int get_stridx_plus_constant (strinfo, HOST_WIDE_INT, tree);\n+\n+/* Return strinfo vector entry IDX.  */\n+\n+static inline strinfo\n+get_strinfo (int idx)\n+{\n+  if (vec_safe_length (stridx_to_strinfo) <= (unsigned int) idx)\n+    return NULL;\n+  return (*stridx_to_strinfo)[idx];\n+}\n+\n /* Helper function for get_stridx.  */\n \n static int\n@@ -219,7 +231,43 @@ get_stridx (tree exp)\n   tree s, o;\n \n   if (TREE_CODE (exp) == SSA_NAME)\n-    return ssa_ver_to_stridx[SSA_NAME_VERSION (exp)];\n+    {\n+      if (ssa_ver_to_stridx[SSA_NAME_VERSION (exp)])\n+\treturn ssa_ver_to_stridx[SSA_NAME_VERSION (exp)];\n+      int i;\n+      tree e = exp;\n+      HOST_WIDE_INT off = 0;\n+      for (i = 0; i < 5; i++)\n+\t{\n+\t  gimple def_stmt = SSA_NAME_DEF_STMT (e);\n+\t  if (!is_gimple_assign (def_stmt)\n+\t      || gimple_assign_rhs_code (def_stmt) != POINTER_PLUS_EXPR)\n+\t    return 0;\n+\t  tree rhs1 = gimple_assign_rhs1 (def_stmt);\n+\t  tree rhs2 = gimple_assign_rhs2 (def_stmt);\n+\t  if (TREE_CODE (rhs1) != SSA_NAME\n+\t      || !tree_fits_shwi_p (rhs2))\n+\t    return 0;\n+\t  HOST_WIDE_INT this_off = tree_to_shwi (rhs2);\n+\t  if (this_off < 0)\n+\t    return 0;\n+\t  off = (unsigned HOST_WIDE_INT) off + this_off;\n+\t  if (off < 0)\n+\t    return 0;\n+\t  if (ssa_ver_to_stridx[SSA_NAME_VERSION (rhs1)])\n+\t    {\n+\t      strinfo si\n+\t\t= get_strinfo (ssa_ver_to_stridx[SSA_NAME_VERSION (rhs1)]);\n+\t      if (si\n+\t\t  && si->length\n+\t\t  && TREE_CODE (si->length) == INTEGER_CST\n+\t\t  && compare_tree_int (si->length, off) != -1)\n+\t\treturn get_stridx_plus_constant (si, off, exp);\n+\t    }\n+\t  e = rhs1;\n+\t}\n+      return 0;\n+    }\n \n   if (TREE_CODE (exp) == ADDR_EXPR)\n     {\n@@ -388,16 +436,6 @@ free_strinfo (strinfo si)\n     pool_free (strinfo_pool, si);\n }\n \n-/* Return strinfo vector entry IDX.  */\n-\n-static inline strinfo\n-get_strinfo (int idx)\n-{\n-  if (vec_safe_length (stridx_to_strinfo) <= (unsigned int) idx)\n-    return NULL;\n-  return (*stridx_to_strinfo)[idx];\n-}\n-\n /* Set strinfo in the vector entry IDX to SI.  */\n \n static inline void\n@@ -555,7 +593,7 @@ maybe_invalidate (gimple stmt)\n   return nonempty;\n }\n \n-/* Unshare strinfo record SI, if it has recount > 1 or\n+/* Unshare strinfo record SI, if it has refcount > 1 or\n    if stridx_to_strinfo vector is shared with some other\n    bbs.  */\n \n@@ -605,6 +643,82 @@ verify_related_strinfos (strinfo origsi)\n   return si;\n }\n \n+/* Attempt to create a new strinfo for BASESI + OFF, or find existing\n+   strinfo if there is any.  Return it's idx, or 0 if no strinfo has\n+   been created.  */\n+\n+static int\n+get_stridx_plus_constant (strinfo basesi, HOST_WIDE_INT off, tree ptr)\n+{\n+  gcc_checking_assert (TREE_CODE (ptr) == SSA_NAME);\n+\n+  if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ptr))\n+    return 0;\n+\n+  if (basesi->length == NULL_TREE\n+      || TREE_CODE (basesi->length) != INTEGER_CST\n+      || compare_tree_int (basesi->length, off) == -1\n+      || !tree_fits_shwi_p (basesi->length))\n+    return 0;\n+\n+  HOST_WIDE_INT len = tree_to_shwi (basesi->length) - off;\n+  strinfo si = basesi, chainsi;\n+  if (si->first || si->prev || si->next)\n+    si = verify_related_strinfos (basesi);\n+  if (si == NULL\n+      || si->length == NULL_TREE\n+      || TREE_CODE (si->length) != INTEGER_CST)\n+    return 0;\n+\n+  if (ssa_ver_to_stridx.length () <= SSA_NAME_VERSION (ptr))\n+    ssa_ver_to_stridx.safe_grow_cleared (num_ssa_names);\n+\n+  gcc_checking_assert (compare_tree_int (si->length, off) != -1);\n+  for (chainsi = si; chainsi->next; chainsi = si)\n+    {\n+      si = get_strinfo (chainsi->next);\n+      if (si == NULL\n+\t  || si->first != chainsi->first\n+\t  || si->prev != chainsi->idx\n+\t  || si->length == NULL_TREE\n+\t  || TREE_CODE (si->length) != INTEGER_CST)\n+\tbreak;\n+      int r = compare_tree_int (si->length, len);\n+      if (r != 1)\n+\t{\n+\t  if (r == 0)\n+\t    {\n+\t      ssa_ver_to_stridx[SSA_NAME_VERSION (ptr)] = si->idx;\n+\t      return si->idx;\n+\t    }\n+\t  break;\n+\t}\n+    }\n+\n+  int idx = new_stridx (ptr);\n+  if (idx == 0)\n+    return 0;\n+  si = new_strinfo (ptr, idx, build_int_cst (size_type_node, len));\n+  set_strinfo (idx, si);\n+  if (chainsi->next)\n+    {\n+      strinfo nextsi = unshare_strinfo (get_strinfo (chainsi->next));\n+      si->next = nextsi->idx;\n+      nextsi->prev = idx;\n+    }\n+  chainsi = unshare_strinfo (chainsi);\n+  if (chainsi->first == 0)\n+    chainsi->first = chainsi->idx;\n+  chainsi->next = idx;\n+  if (chainsi->endptr == NULL_TREE && len == 0)\n+    chainsi->endptr = ptr;\n+  si->endptr = chainsi->endptr;\n+  si->prev = chainsi->idx;\n+  si->first = chainsi->first;\n+  si->writable = chainsi->writable;\n+  return si->idx;\n+}\n+\n /* Note that PTR, a pointer SSA_NAME initialized in the current stmt, points\n    to a zero-length string and if possible chain it to a related strinfo\n    chain whose part is or might be CHAINSI.  */\n@@ -614,8 +728,10 @@ zero_length_string (tree ptr, strinfo chainsi)\n {\n   strinfo si;\n   int idx;\n+  if (ssa_ver_to_stridx.length () <= SSA_NAME_VERSION (ptr))\n+    ssa_ver_to_stridx.safe_grow_cleared (num_ssa_names);\n   gcc_checking_assert (TREE_CODE (ptr) == SSA_NAME\n-\t\t       && get_stridx (ptr) == 0);\n+\t\t       && ssa_ver_to_stridx[SSA_NAME_VERSION (ptr)] == 0);\n \n   if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ptr))\n     return NULL;"}]}