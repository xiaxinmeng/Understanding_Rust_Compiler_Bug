{"sha": "2d143ba8cfef7ef480c639882fd5518b7afd822b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQxNDNiYThjZmVmN2VmNDgwYzYzOTg4MmZkNTUxOGI3YWZkODIyYg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-04-07T08:20:24Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-04-07T08:20:24Z"}, "message": "re PR middle-end/80341 (gcc miscompiles division of signed char)\n\n2017-04-07  Richard Biener  <rguenther@suse.de>\n\n\tPR middle-end/80341\n\t* tree.c (get_unwidened): Also handle ! for_type case for\n\tINTEGER_CSTs.\n\t* convert.c (do_narrow): Split out from ...\n\t(convert_to_integer_1): ... here.  Do not pass final truncation\n\ttype to get_unwidened for TRUNC_DIV_EXPR.\n\n\t* gcc.dg/torture/pr80341.c: New testcase.\n\nFrom-SVN: r246756", "tree": {"sha": "88b5a716645aa02574e38f724825464aecb22de9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88b5a716645aa02574e38f724825464aecb22de9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d143ba8cfef7ef480c639882fd5518b7afd822b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d143ba8cfef7ef480c639882fd5518b7afd822b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d143ba8cfef7ef480c639882fd5518b7afd822b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d143ba8cfef7ef480c639882fd5518b7afd822b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5291ab733b6584b2b0252178625088812f66e689", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5291ab733b6584b2b0252178625088812f66e689", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5291ab733b6584b2b0252178625088812f66e689"}], "stats": {"total": 211, "additions": 136, "deletions": 75}, "files": [{"sha": "e6ad7cefd9284163e0a28fa633ff446e648bb53e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d143ba8cfef7ef480c639882fd5518b7afd822b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d143ba8cfef7ef480c639882fd5518b7afd822b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2d143ba8cfef7ef480c639882fd5518b7afd822b", "patch": "@@ -1,3 +1,12 @@\n+2017-04-07  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/80341\n+\t* tree.c (get_unwidened): Also handle ! for_type case for\n+\tINTEGER_CSTs.\n+\t* convert.c (do_narrow): Split out from ...\n+\t(convert_to_integer_1): ... here.  Do not pass final truncation\n+\ttype to get_unwidened for TRUNC_DIV_EXPR.\n+\n 2017-04-07  Richard Biener  <rguenther@suse.de>\n \n \t* tree-affine.c (wide_int_ext_for_comb): Take type rather"}, {"sha": "af8dfda0eb44769885d2f06b92aac8b36c665ca5", "filename": "gcc/convert.c", "status": "modified", "additions": 89, "deletions": 69, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d143ba8cfef7ef480c639882fd5518b7afd822b/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d143ba8cfef7ef480c639882fd5518b7afd822b/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=2d143ba8cfef7ef480c639882fd5518b7afd822b", "patch": "@@ -413,6 +413,83 @@ convert_to_real_maybe_fold (tree type, tree expr, bool dofold)\n   return convert_to_real_1 (type, expr, dofold || CONSTANT_CLASS_P (expr));\n }\n \n+/* Try to narrow EX_FORM ARG0 ARG1 in narrowed arg types producing a\n+   result in TYPE.  */\n+\n+static tree\n+do_narrow (location_t loc,\n+\t   enum tree_code ex_form, tree type, tree arg0, tree arg1,\n+\t   tree expr, unsigned inprec, unsigned outprec, bool dofold)\n+{\n+  /* Do the arithmetic in type TYPEX,\n+     then convert result to TYPE.  */\n+  tree typex = type;\n+\n+  /* Can't do arithmetic in enumeral types\n+     so use an integer type that will hold the values.  */\n+  if (TREE_CODE (typex) == ENUMERAL_TYPE)\n+    typex = lang_hooks.types.type_for_size (TYPE_PRECISION (typex),\n+\t\t\t\t\t    TYPE_UNSIGNED (typex));\n+\n+  /* But now perhaps TYPEX is as wide as INPREC.\n+     In that case, do nothing special here.\n+     (Otherwise would recurse infinitely in convert.  */\n+  if (TYPE_PRECISION (typex) != inprec)\n+    {\n+      /* Don't do unsigned arithmetic where signed was wanted,\n+\t or vice versa.\n+\t Exception: if both of the original operands were\n+\t unsigned then we can safely do the work as unsigned.\n+\t Exception: shift operations take their type solely\n+\t from the first argument.\n+\t Exception: the LSHIFT_EXPR case above requires that\n+\t we perform this operation unsigned lest we produce\n+\t signed-overflow undefinedness.\n+\t And we may need to do it as unsigned\n+\t if we truncate to the original size.  */\n+      if (TYPE_UNSIGNED (TREE_TYPE (expr))\n+\t  || (TYPE_UNSIGNED (TREE_TYPE (arg0))\n+\t      && (TYPE_UNSIGNED (TREE_TYPE (arg1))\n+\t\t  || ex_form == LSHIFT_EXPR\n+\t\t  || ex_form == RSHIFT_EXPR\n+\t\t  || ex_form == LROTATE_EXPR\n+\t\t  || ex_form == RROTATE_EXPR))\n+\t  || ex_form == LSHIFT_EXPR\n+\t  /* If we have !flag_wrapv, and either ARG0 or\n+\t     ARG1 is of a signed type, we have to do\n+\t     PLUS_EXPR, MINUS_EXPR or MULT_EXPR in an unsigned\n+\t     type in case the operation in outprec precision\n+\t     could overflow.  Otherwise, we would introduce\n+\t     signed-overflow undefinedness.  */\n+\t  || ((!TYPE_OVERFLOW_WRAPS (TREE_TYPE (arg0))\n+\t       || !TYPE_OVERFLOW_WRAPS (TREE_TYPE (arg1)))\n+\t      && ((TYPE_PRECISION (TREE_TYPE (arg0)) * 2u\n+\t\t   > outprec)\n+\t\t  || (TYPE_PRECISION (TREE_TYPE (arg1)) * 2u\n+\t\t      > outprec))\n+\t      && (ex_form == PLUS_EXPR\n+\t\t  || ex_form == MINUS_EXPR\n+\t\t  || ex_form == MULT_EXPR)))\n+\t{\n+\t  if (!TYPE_UNSIGNED (typex))\n+\t    typex = unsigned_type_for (typex);\n+\t}\n+      else\n+\t{\n+\t  if (TYPE_UNSIGNED (typex))\n+\t    typex = signed_type_for (typex);\n+\t}\n+      /* We should do away with all this once we have a proper\n+\t type promotion/demotion pass, see PR45397.  */\n+      expr = maybe_fold_build2_loc (dofold, loc, ex_form, typex,\n+\t\t\t\t    convert (typex, arg0),\n+\t\t\t\t    convert (typex, arg1));\n+      return convert (type, expr);\n+    }\n+  \n+  return NULL_TREE;\n+}\n+\n /* Convert EXPR to some integer (or enum) type TYPE.\n \n    EXPR must be pointer, integer, discrete (enum, char, or bool), float,\n@@ -719,8 +796,8 @@ convert_to_integer_1 (tree type, tree expr, bool dofold)\n \n \t  case TRUNC_DIV_EXPR:\n \t    {\n-\t      tree arg0 = get_unwidened (TREE_OPERAND (expr, 0), type);\n-\t      tree arg1 = get_unwidened (TREE_OPERAND (expr, 1), type);\n+\t      tree arg0 = get_unwidened (TREE_OPERAND (expr, 0), NULL_TREE);\n+\t      tree arg1 = get_unwidened (TREE_OPERAND (expr, 1), NULL_TREE);\n \n \t      /* Don't distribute unless the output precision is at least as\n \t\t big as the actual inputs and it has the same signedness.  */\n@@ -738,7 +815,12 @@ convert_to_integer_1 (tree type, tree expr, bool dofold)\n \t\t  && (TYPE_UNSIGNED (TREE_TYPE (arg0))\n \t\t      || (TREE_CODE (arg1) == INTEGER_CST\n \t\t\t  && !integer_all_onesp (arg1))))\n-\t\tgoto trunc1;\n+\t\t{\n+\t\t  tree tem = do_narrow (loc, ex_form, type, arg0, arg1,\n+\t\t\t\t\texpr, inprec, outprec, dofold);\n+\t\t  if (tem)\n+\t\t    return tem;\n+\t\t}\n \t      break;\n \t    }\n \n@@ -786,72 +868,10 @@ convert_to_integer_1 (tree type, tree expr, bool dofold)\n \t\t  || inprec > TYPE_PRECISION (TREE_TYPE (arg0))\n \t\t  || inprec > TYPE_PRECISION (TREE_TYPE (arg1)))\n \t\t{\n-\t\t  /* Do the arithmetic in type TYPEX,\n-\t\t     then convert result to TYPE.  */\n-\t\t  tree typex = type;\n-\n-\t\t  /* Can't do arithmetic in enumeral types\n-\t\t     so use an integer type that will hold the values.  */\n-\t\t  if (TREE_CODE (typex) == ENUMERAL_TYPE)\n-\t\t    typex\n-\t\t      = lang_hooks.types.type_for_size (TYPE_PRECISION (typex),\n-\t\t\t\t\t\t\tTYPE_UNSIGNED (typex));\n-\n-\t\t  /* But now perhaps TYPEX is as wide as INPREC.\n-\t\t     In that case, do nothing special here.\n-\t\t     (Otherwise would recurse infinitely in convert.  */\n-\t\t  if (TYPE_PRECISION (typex) != inprec)\n-\t\t    {\n-\t\t      /* Don't do unsigned arithmetic where signed was wanted,\n-\t\t\t or vice versa.\n-\t\t\t Exception: if both of the original operands were\n-\t\t\t unsigned then we can safely do the work as unsigned.\n-\t\t\t Exception: shift operations take their type solely\n-\t\t\t from the first argument.\n-\t\t\t Exception: the LSHIFT_EXPR case above requires that\n-\t\t\t we perform this operation unsigned lest we produce\n-\t\t\t signed-overflow undefinedness.\n-\t\t\t And we may need to do it as unsigned\n-\t\t\t if we truncate to the original size.  */\n-\t\t      if (TYPE_UNSIGNED (TREE_TYPE (expr))\n-\t\t\t  || (TYPE_UNSIGNED (TREE_TYPE (arg0))\n-\t\t\t      && (TYPE_UNSIGNED (TREE_TYPE (arg1))\n-\t\t\t\t  || ex_form == LSHIFT_EXPR\n-\t\t\t\t  || ex_form == RSHIFT_EXPR\n-\t\t\t\t  || ex_form == LROTATE_EXPR\n-\t\t\t\t  || ex_form == RROTATE_EXPR))\n-\t\t\t  || ex_form == LSHIFT_EXPR\n-\t\t\t  /* If we have !flag_wrapv, and either ARG0 or\n-\t\t\t     ARG1 is of a signed type, we have to do\n-\t\t\t     PLUS_EXPR, MINUS_EXPR or MULT_EXPR in an unsigned\n-\t\t\t     type in case the operation in outprec precision\n-\t\t\t     could overflow.  Otherwise, we would introduce\n-\t\t\t     signed-overflow undefinedness.  */\n-\t\t\t  || ((!TYPE_OVERFLOW_WRAPS (TREE_TYPE (arg0))\n-\t\t\t       || !TYPE_OVERFLOW_WRAPS (TREE_TYPE (arg1)))\n-\t\t\t      && ((TYPE_PRECISION (TREE_TYPE (arg0)) * 2u\n-\t\t\t\t   > outprec)\n-\t\t\t\t  || (TYPE_PRECISION (TREE_TYPE (arg1)) * 2u\n-\t\t\t\t      > outprec))\n-\t\t\t      && (ex_form == PLUS_EXPR\n-\t\t\t\t  || ex_form == MINUS_EXPR\n-\t\t\t\t  || ex_form == MULT_EXPR)))\n-\t\t\t{\n-\t\t\t  if (!TYPE_UNSIGNED (typex))\n-\t\t\t    typex = unsigned_type_for (typex);\n-\t\t\t}\n-\t\t      else\n-\t\t\t{\n-\t\t\t  if (TYPE_UNSIGNED (typex))\n-\t\t\t    typex = signed_type_for (typex);\n-\t\t\t}\n-\t\t      /* We should do away with all this once we have a proper\n-\t\t\t type promotion/demotion pass, see PR45397.  */\n-\t\t      expr = maybe_fold_build2_loc (dofold, loc, ex_form, typex,\n-\t\t\t\t\t\t    convert (typex, arg0),\n-\t\t\t\t\t\t    convert (typex, arg1));\n-\t\t      return convert (type, expr);\n-\t\t    }\n+\t\t  tree tem = do_narrow (loc, ex_form, type, arg0, arg1,\n+\t\t\t\t\texpr, inprec, outprec, dofold);\n+\t\t  if (tem)\n+\t\t    return tem;\n \t\t}\n \t    }\n \t    break;"}, {"sha": "fc772c467239b846004ffb24cba21b5e86fcedf8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d143ba8cfef7ef480c639882fd5518b7afd822b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d143ba8cfef7ef480c639882fd5518b7afd822b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2d143ba8cfef7ef480c639882fd5518b7afd822b", "patch": "@@ -1,3 +1,8 @@\n+2017-04-07  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/80341\n+\t* gcc.dg/torture/pr80341.c: New testcase.\n+\n 2017-04-06  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/80234"}, {"sha": "40cf660dff911a181dfcd306391ce20216545e13", "filename": "gcc/testsuite/gcc.dg/torture/pr80341.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d143ba8cfef7ef480c639882fd5518b7afd822b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr80341.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d143ba8cfef7ef480c639882fd5518b7afd822b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr80341.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr80341.c?ref=2d143ba8cfef7ef480c639882fd5518b7afd822b", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do run } */\n+/* { dg-additional-options \"-Wno-overflow\" } */\n+\n+const signed char c = -84;\n+signed char s;\n+\n+void\n+foo ()\n+{\n+  s = (unsigned short) c / -55;\n+}\n+\n+int\n+main ()\n+{\n+  foo ();\n+  if (s != 90)\n+    __builtin_abort ();\n+}"}, {"sha": "c18889caeb564c1d599b3a0e7821b3ab11a9b2a2", "filename": "gcc/tree.c", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d143ba8cfef7ef480c639882fd5518b7afd822b/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d143ba8cfef7ef480c639882fd5518b7afd822b/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=2d143ba8cfef7ef480c639882fd5518b7afd822b", "patch": "@@ -9033,13 +9033,21 @@ get_unwidened (tree op, tree for_type)\n \t}\n     }\n \n-  /* If we finally reach a constant see if it fits in for_type and\n+  /* If we finally reach a constant see if it fits in sth smaller and\n      in that case convert it.  */\n-  if (for_type\n-      && TREE_CODE (win) == INTEGER_CST\n-      && TREE_TYPE (win) != for_type\n-      && int_fits_type_p (win, for_type))\n-    win = fold_convert (for_type, win);\n+  if (TREE_CODE (win) == INTEGER_CST)\n+    {\n+      tree wtype = TREE_TYPE (win);\n+      unsigned prec = wi::min_precision (win, TYPE_SIGN (wtype));\n+      if (for_type)\n+\tprec = MAX (prec, final_prec);\n+      if (prec < TYPE_PRECISION (wtype))\n+\t{\n+\t  tree t = lang_hooks.types.type_for_size (prec, TYPE_UNSIGNED (wtype));\n+\t  if (t && TYPE_PRECISION (t) < TYPE_PRECISION (wtype))\n+\t    win = fold_convert (t, win);\n+\t}\n+    }\n \n   return win;\n }"}]}