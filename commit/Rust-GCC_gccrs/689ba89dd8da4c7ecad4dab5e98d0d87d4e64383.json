{"sha": "689ba89dd8da4c7ecad4dab5e98d0d87d4e64383", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njg5YmE4OWRkOGRhNGM3ZWNhZDRkYWI1ZTk4ZDBkODdkNGU2NDM4Mw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2004-03-18T16:42:34Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-03-18T16:42:34Z"}, "message": "doloop.c: Removed.\n\n\t* doloop.c: Removed.\n\t* loop-doloop.c: New file.\n\t* Makefile.in (doloop.o): Remove.\n\t(loop-doloop.o): New.\n\t* cfgloop.h (get_loop_level, doloop_optimize_loops): Declare.\n\t* cfgloopanal.c (get_loop_level): New function.\n\t* loop-iv.c (iv_number_of_iterations): Handle case when loop\n\tis leaved immediatelly.\n\t* loop.c (strength_reduce): Do not call doloop optimization.\n\t* loop.h (LOOP_BCT): Removed.\n\t* passes.c (rest_of_handle_loop_optimize): Do not use LOOP_BCT.\n\t(rest_of_handle_loop2): Call doloop_optimize_loops.\n\t(rest_of_compilation): Test for optimizations moved to\n\trest_of_handle_loop2.\n\nFrom-SVN: r79625", "tree": {"sha": "245f4992ca85428a919452579f49376b65e76f95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/245f4992ca85428a919452579f49376b65e76f95"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/689ba89dd8da4c7ecad4dab5e98d0d87d4e64383", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/689ba89dd8da4c7ecad4dab5e98d0d87d4e64383", "html_url": "https://github.com/Rust-GCC/gccrs/commit/689ba89dd8da4c7ecad4dab5e98d0d87d4e64383", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/689ba89dd8da4c7ecad4dab5e98d0d87d4e64383/comments", "author": null, "committer": null, "parents": [{"sha": "327e5343434d5a2b3e3e10bef5f4be570aed4d0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/327e5343434d5a2b3e3e10bef5f4be570aed4d0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/327e5343434d5a2b3e3e10bef5f4be570aed4d0c"}], "stats": {"total": 1524, "additions": 612, "deletions": 912}, "files": [{"sha": "94a75a4d74c2fcea5bc5e75049f0a7aa39ff07ce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/689ba89dd8da4c7ecad4dab5e98d0d87d4e64383/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/689ba89dd8da4c7ecad4dab5e98d0d87d4e64383/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=689ba89dd8da4c7ecad4dab5e98d0d87d4e64383", "patch": "@@ -1,3 +1,20 @@\n+2004-03-18  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* doloop.c: Removed.\n+\t* loop-doloop.c: New file.\n+\t* Makefile.in (doloop.o): Remove.\n+\t(loop-doloop.o): New.\n+\t* cfgloop.h (get_loop_level, doloop_optimize_loops): Declare.\n+\t* cfgloopanal.c (get_loop_level): New function.\n+\t* loop-iv.c (iv_number_of_iterations): Handle case when loop\n+\tis leaved immediatelly.\n+\t* loop.c (strength_reduce): Do not call doloop optimization.\n+\t* loop.h (LOOP_BCT): Removed.\n+\t* passes.c (rest_of_handle_loop_optimize): Do not use LOOP_BCT.\n+\t(rest_of_handle_loop2): Call doloop_optimize_loops.\n+\t(rest_of_compilation): Test for optimizations moved to\n+\trest_of_handle_loop2.\n+\n 2004-03-17  Fariborz Jahanian <fjahanian@apple.com>\n \n         * config/rs6000/rs6000.c (rs6000_stack_info): correct reg_size"}, {"sha": "84103f259c7a6d031575891155f495e124810cd4", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/689ba89dd8da4c7ecad4dab5e98d0d87d4e64383/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/689ba89dd8da4c7ecad4dab5e98d0d87d4e64383/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=689ba89dd8da4c7ecad4dab5e98d0d87d4e64383", "patch": "@@ -849,7 +849,7 @@ OBJS-common = \\\n  cfg.o cfganal.o cfgbuild.o cfgcleanup.o cfglayout.o cfgloop.o\t\t   \\\n  cfgloopanal.o cfgloopmanip.o loop-init.o loop-unswitch.o loop-unroll.o\t   \\\n  cfgrtl.o combine.o conflict.o convert.o coverage.o cse.o cselib.o \t   \\\n- dbxout.o debug.o df.o diagnostic.o dojump.o doloop.o dominance.o\t   \\\n+ dbxout.o debug.o df.o diagnostic.o dojump.o dominance.o loop-doloop.o\t   \\\n  dwarf2asm.o dwarf2out.o emit-rtl.o except.o explow.o loop-iv.o\t\t   \\\n  expmed.o expr.o final.o flow.o fold-const.o function.o gcse.o\t\t   \\\n  genrtl.o ggc-common.o global.o graph.o gtype-desc.o\t\t\t   \\\n@@ -1702,9 +1702,9 @@ loop.o : loop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h $(L\n    insn-config.h $(REGS_H) hard-reg-set.h $(RECOG_H) $(EXPR_H) \\\n    real.h $(PREDICT_H) $(BASIC_BLOCK_H) function.h cfgloop.h \\\n    toplev.h varray.h except.h cselib.h $(OPTABS_H) $(TM_P_H) $(GGC_H)\n-doloop.o : doloop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h \\\n-   $(LOOP_H) $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) $(TM_P_H) toplev.h \\\n-   cfgloop.h\n+loop-doloop.o : loop-doloop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(RTL_H) flags.h $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) $(TM_P_H) \\\n+   toplev.h cfgloop.h output.h $(PARAMS_H)\n unroll.o : unroll.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) insn-config.h \\\n    function.h $(INTEGRATE_H) $(REGS_H) $(RECOG_H) flags.h $(EXPR_H) $(LOOP_H) toplev.h \\\n    hard-reg-set.h varray.h $(BASIC_BLOCK_H) $(TM_P_H) $(PREDICT_H) $(PARAMS_H) \\"}, {"sha": "b233d2652c663fe6e7131d3a5a5e06bd775b6111", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/689ba89dd8da4c7ecad4dab5e98d0d87d4e64383/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/689ba89dd8da4c7ecad4dab5e98d0d87d4e64383/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=689ba89dd8da4c7ecad4dab5e98d0d87d4e64383", "patch": "@@ -247,6 +247,7 @@ extern bool flow_bb_inside_loop_p (const struct loop *, const basic_block);\n extern struct loop * find_common_loop (struct loop *, struct loop *);\n extern int num_loop_insns (struct loop *);\n extern int average_num_loop_insns (struct loop *);\n+extern unsigned get_loop_level (const struct loop *);\n \n /* Loops & cfg manipulation.  */\n extern basic_block *get_loop_body (const struct loop *);\n@@ -417,3 +418,4 @@ enum\n };\n \n extern void unroll_and_peel_loops (struct loops *, int);\n+extern void doloop_optimize_loops (struct loops *);"}, {"sha": "63d6f4121b0ee065bcfadb3d79dffb486fe3defa", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/689ba89dd8da4c7ecad4dab5e98d0d87d4e64383/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/689ba89dd8da4c7ecad4dab5e98d0d87d4e64383/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=689ba89dd8da4c7ecad4dab5e98d0d87d4e64383", "patch": "@@ -457,3 +457,20 @@ expected_loop_iterations (const struct loop *loop)\n       return (freq_latch + freq_in - 1) / freq_in;\n     }\n }\n+\n+/* Returns the maximum level of nesting of subloops of LOOP.  */\n+\n+unsigned\n+get_loop_level (const struct loop *loop)\n+{\n+  const struct loop *ploop;\n+  unsigned mx = 0, l;\n+\n+  for (ploop = loop->inner; ploop; ploop = ploop->next)\n+    {\n+      l = get_loop_level (ploop);\n+      if (l >= mx)\n+\tmx = l + 1;\n+    }\n+  return mx;\n+}"}, {"sha": "6d4840a236c351766a0f940dfd557849c0ca6bfd", "filename": "gcc/doloop.c", "status": "removed", "additions": 0, "deletions": 883, "changes": 883, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/327e5343434d5a2b3e3e10bef5f4be570aed4d0c/gcc%2Fdoloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/327e5343434d5a2b3e3e10bef5f4be570aed4d0c/gcc%2Fdoloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoloop.c?ref=327e5343434d5a2b3e3e10bef5f4be570aed4d0c", "patch": "@@ -1,883 +0,0 @@\n-/* Perform doloop optimizations\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004\n-   Free Software Foundation, Inc.\n-   Contributed by Michael P. Hayes (m.hayes@elec.canterbury.ac.nz)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 2, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"rtl.h\"\n-#include \"flags.h\"\n-#include \"expr.h\"\n-#include \"loop.h\"\n-#include \"hard-reg-set.h\"\n-#include \"basic-block.h\"\n-#include \"toplev.h\"\n-#include \"tm_p.h\"\n-#include \"cfgloop.h\"\n-\n-\n-/* This module is used to modify loops with a determinable number of\n-   iterations to use special low-overhead looping instructions.\n-\n-   It first validates whether the loop is well behaved and has a\n-   determinable number of iterations (either at compile or run-time).\n-   It then modifies the loop to use a low-overhead looping pattern as\n-   follows:\n-\n-   1. A pseudo register is allocated as the loop iteration counter.\n-\n-   2. The number of loop iterations is calculated and is stored\n-      in the loop counter.\n-\n-   3. At the end of the loop, the jump insn is replaced by the\n-      doloop_end pattern.  The compare must remain because it might be\n-      used elsewhere.  If the loop-variable or condition register are\n-      used elsewhere, they will be eliminated by flow.\n-\n-   4. An optional doloop_begin pattern is inserted at the top of the\n-      loop.\n-*/\n-\n-\n-#ifdef HAVE_doloop_end\n-\n-static rtx doloop_condition_get (rtx);\n-static unsigned HOST_WIDE_INT doloop_iterations_max (const struct loop_info *,\n-\t\t\t\t\t\t     enum machine_mode, int);\n-static int doloop_valid_p (const struct loop *, rtx);\n-static int doloop_modify (const struct loop *, rtx, rtx, rtx, rtx, rtx);\n-static int doloop_modify_runtime (const struct loop *, rtx, rtx, rtx,\n-\t\t\t\t  enum machine_mode, rtx);\n-\n-\n-/* Return the loop termination condition for PATTERN or zero\n-   if it is not a decrement and branch jump insn.  */\n-static rtx\n-doloop_condition_get (rtx pattern)\n-{\n-  rtx cmp;\n-  rtx inc;\n-  rtx reg;\n-  rtx condition;\n-\n-  /* The canonical doloop pattern we expect is:\n-\n-     (parallel [(set (pc) (if_then_else (condition)\n-                                        (label_ref (label))\n-                                        (pc)))\n-                (set (reg) (plus (reg) (const_int -1)))\n-                (additional clobbers and uses)])\n-\n-     Some machines (IA-64) make the decrement conditional on\n-     the condition as well, so we don't bother verifying the\n-     actual decrement.  In summary, the branch must be the\n-     first entry of the parallel (also required by jump.c),\n-     and the second entry of the parallel must be a set of\n-     the loop counter register.  */\n-\n-  if (GET_CODE (pattern) != PARALLEL)\n-    return 0;\n-\n-  cmp = XVECEXP (pattern, 0, 0);\n-  inc = XVECEXP (pattern, 0, 1);\n-\n-  /* Check for (set (reg) (something)).  */\n-  if (GET_CODE (inc) != SET || ! REG_P (SET_DEST (inc)))\n-    return 0;\n-\n-  /* Extract loop counter register.  */\n-  reg = SET_DEST (inc);\n-\n-  /* Check for (set (pc) (if_then_else (condition)\n-                                       (label_ref (label))\n-                                       (pc))).  */\n-  if (GET_CODE (cmp) != SET\n-      || SET_DEST (cmp) != pc_rtx\n-      || GET_CODE (SET_SRC (cmp)) != IF_THEN_ELSE\n-      || GET_CODE (XEXP (SET_SRC (cmp), 1)) != LABEL_REF\n-      || XEXP (SET_SRC (cmp), 2) != pc_rtx)\n-    return 0;\n-\n-  /* Extract loop termination condition.  */\n-  condition = XEXP (SET_SRC (cmp), 0);\n-\n-  if ((GET_CODE (condition) != GE && GET_CODE (condition) != NE)\n-      || GET_CODE (XEXP (condition, 1)) != CONST_INT)\n-    return 0;\n-\n-  if (XEXP (condition, 0) == reg)\n-    return condition;\n-\n-  if (GET_CODE (XEXP (condition, 0)) == PLUS\n-      && XEXP (XEXP (condition, 0), 0) == reg)\n-    return condition;\n-\n-  /* ??? If a machine uses a funny comparison, we could return a\n-     canonicalised form here.  */\n-\n-  return 0;\n-}\n-\n-\n-/* Return an estimate of the maximum number of loop iterations for the\n-   loop specified by LOOP or zero if the loop is not normal.\n-   MODE is the mode of the iteration count and NONNEG is nonzero if\n-   the iteration count has been proved to be non-negative.  */\n-static unsigned HOST_WIDE_INT\n-doloop_iterations_max (const struct loop_info *loop_info,\n-\t\t       enum machine_mode mode, int nonneg)\n-{\n-  unsigned HOST_WIDE_INT n_iterations_max;\n-  enum rtx_code code;\n-  rtx min_value;\n-  rtx max_value;\n-  HOST_WIDE_INT abs_inc;\n-  int neg_inc;\n-\n-  neg_inc = 0;\n-  abs_inc = INTVAL (loop_info->increment);\n-  if (abs_inc < 0)\n-    {\n-      abs_inc = -abs_inc;\n-      neg_inc = 1;\n-    }\n-\n-  if (neg_inc)\n-    {\n-      code = swap_condition (loop_info->comparison_code);\n-      min_value = loop_info->final_equiv_value;\n-      max_value = loop_info->initial_equiv_value;\n-    }\n-  else\n-    {\n-      code = loop_info->comparison_code;\n-      min_value = loop_info->initial_equiv_value;\n-      max_value = loop_info->final_equiv_value;\n-    }\n-\n-  /* Since the loop has a VTOP, we know that the initial test will be\n-     true and thus the value of max_value should be greater than the\n-     value of min_value.  Thus the difference should always be positive\n-     and the code must be LT, LE, LTU, LEU, or NE.  Otherwise the loop is\n-     not normal, e.g., `for (i = 0; i < 10; i--)'.  */\n-  switch (code)\n-    {\n-    case LTU:\n-    case LEU:\n-      {\n-\tunsigned HOST_WIDE_INT umax;\n-\tunsigned HOST_WIDE_INT umin;\n-\n-\tif (GET_CODE (min_value) == CONST_INT)\n-\t  umin = INTVAL (min_value);\n-\telse\n-\t  umin = 0;\n-\n-\tif (GET_CODE (max_value) == CONST_INT)\n-\t  umax = INTVAL (max_value);\n-\telse\n-\t  umax = ((unsigned) 2 << (GET_MODE_BITSIZE (mode) - 1)) - 1;\n-\n-\tn_iterations_max = umax - umin;\n-\tbreak;\n-      }\n-\n-    case LT:\n-    case LE:\n-      {\n-\tHOST_WIDE_INT smax;\n-\tHOST_WIDE_INT smin;\n-\n-\tif (GET_CODE (min_value) == CONST_INT)\n-\t  smin = INTVAL (min_value);\n-\telse\n-\t  smin = -((unsigned) 1 << (GET_MODE_BITSIZE (mode) - 1));\n-\n-\tif (GET_CODE (max_value) == CONST_INT)\n-\t  smax = INTVAL (max_value);\n-\telse\n-\t  smax = ((unsigned) 1 << (GET_MODE_BITSIZE (mode) - 1)) - 1;\n-\n-\tn_iterations_max = smax - smin;\n-\tbreak;\n-      }\n-\n-    case NE:\n-      if (GET_CODE (min_value) == CONST_INT\n-\t  && GET_CODE (max_value) == CONST_INT)\n-\tn_iterations_max = INTVAL (max_value) - INTVAL (min_value);\n-      else\n-\t/* We need to conservatively assume that we might have the maximum\n-\t   number of iterations without any additional knowledge.  */\n-\tn_iterations_max = ((unsigned) 2 << (GET_MODE_BITSIZE (mode) - 1)) - 1;\n-      break;\n-\n-    default:\n-      return 0;\n-    }\n-\n-  n_iterations_max /= abs_inc;\n-\n-  /* If we know that the iteration count is non-negative then adjust\n-     n_iterations_max if it is so large that it appears negative.  */\n-  if (nonneg\n-      && n_iterations_max > ((unsigned) 1 << (GET_MODE_BITSIZE (mode) - 1)))\n-    n_iterations_max = ((unsigned) 1 << (GET_MODE_BITSIZE (mode) - 1)) - 1;\n-\n-  return n_iterations_max;\n-}\n-\n-\n-/* Return nonzero if the loop specified by LOOP is suitable for\n-   the use of special low-overhead looping instructions.  */\n-static int\n-doloop_valid_p (const struct loop *loop, rtx jump_insn)\n-{\n-  const struct loop_info *loop_info = LOOP_INFO (loop);\n-\n-  /* The loop must have a conditional jump at the end.  */\n-  if (! any_condjump_p (jump_insn)\n-      || ! onlyjump_p (jump_insn))\n-    {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"Doloop: Invalid jump at loop end.\\n\");\n-      return 0;\n-    }\n-\n-  /* Give up if a loop has been completely unrolled.  */\n-  if (loop_info->n_iterations == loop_info->unroll_number)\n-    {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"Doloop: Loop completely unrolled.\\n\");\n-      return 0;\n-    }\n-\n-  /* The loop must have a single exit target.  A break or return\n-     statement within a loop will generate multiple loop exits.\n-     Another example of a loop that currently generates multiple exit\n-     targets is for (i = 0; i < (foo ? 8 : 4); i++) { }.  */\n-  if (loop_info->has_multiple_exit_targets || loop->exit_count)\n-    {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"Doloop: Loop has multiple exit targets.\\n\");\n-      return 0;\n-    }\n-\n-  /* An indirect jump may jump out of the loop.  */\n-  if (loop_info->has_indirect_jump)\n-    {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"Doloop: Indirect jump in function.\\n\");\n-      return 0;\n-    }\n-\n-  /* A called function may clobber any special registers required for\n-     low-overhead looping.  */\n-  if (loop_info->has_call)\n-    {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"Doloop: Function call in loop.\\n\");\n-      return 0;\n-    }\n-\n-  /* Some targets (eg, PPC) use the count register for branch on table\n-     instructions.  ??? This should be a target specific check.  */\n-  if (loop_info->has_tablejump)\n-    {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"Doloop: Computed branch in the loop.\\n\");\n-      return 0;\n-    }\n-\n-  if (! loop_info->increment)\n-    {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"Doloop: Could not determine iteration info.\\n\");\n-      return 0;\n-    }\n-\n-  if (GET_CODE (loop_info->increment) != CONST_INT)\n-    {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"Doloop: Increment not an integer constant.\\n\");\n-      return 0;\n-    }\n-\n-  /* There is no guarantee that a NE loop will terminate if the\n-     absolute increment is not unity.  ??? We could compute this\n-     condition at run-time and have an additional jump around the loop\n-     to ensure an infinite loop.  */\n-  if (loop_info->comparison_code == NE\n-      && !loop_info->preconditioned\n-      && INTVAL (loop_info->increment) != -1\n-      && INTVAL (loop_info->increment) != 1)\n-    {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"Doloop: NE loop with non-unity increment.\\n\");\n-      return 0;\n-    }\n-\n-  /* Check for loops that may not terminate under special conditions.  */\n-  if (! loop_info->n_iterations\n-      && ((loop_info->comparison_code == LEU\n-\t   && INTVAL (loop_info->increment) > 0)\n-\t  || (loop_info->comparison_code == GEU\n-\t      && INTVAL (loop_info->increment) < 0)\n-\t  || (loop_info->comparison_code == LTU\n-\t      && INTVAL (loop_info->increment) > 1)\n-\t  || (loop_info->comparison_code == GTU\n-\t      && INTVAL (loop_info->increment) < -1)))\n-    {\n-      /* If the comparison is LEU and the comparison value is UINT_MAX\n-\t then the loop will not terminate.  Similarly, if the\n-\t comparison code is GEU and the comparison value is 0, the\n-\t loop will not terminate.\n-\n-\t If the absolute increment is not 1, the loop can be infinite\n-\t even with LTU/GTU, e.g. for (i = 3; i > 0; i -= 2)\n-\n-\t Note that with LE and GE, the loop behavior is undefined\n-\t (C++ standard section 5 clause 5) if an overflow occurs, say\n-\t between INT_MAX and INT_MAX + 1.  We thus don't have to worry\n-\t about these two cases.\n-\n-\t ??? We could compute these conditions at run-time and have a\n-\t additional jump around the loop to ensure an infinite loop.\n-\t However, it is very unlikely that this is the intended\n-\t behavior of the loop and checking for these rare boundary\n-\t conditions would pessimize all other code.\n-\n-\t If the loop is executed only a few times an extra check to\n-\t restart the loop could use up most of the benefits of using a\n-\t count register loop.  Note however, that normally, this\n-\t restart branch would never execute, so it could be predicted\n-\t well by the CPU.  We should generate the pessimistic code by\n-\t default, and have an option, e.g. -funsafe-loops that would\n-\t enable count-register loops in this case.  */\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"Doloop: Possible infinite iteration case ignored.\\n\");\n-    }\n-\n-  return 1;\n-}\n-\n-\n-/* Modify the loop to use the low-overhead looping insn where LOOP\n-   describes the loop, ITERATIONS is an RTX containing the desired\n-   number of loop iterations, ITERATIONS_MAX is a CONST_INT specifying\n-   the maximum number of loop iterations, and DOLOOP_INSN is the\n-   low-overhead looping insn to emit at the end of the loop.  This\n-   returns nonzero if it was successful.  */\n-static int\n-doloop_modify (const struct loop *loop, rtx iterations, rtx iterations_max,\n-\t       rtx doloop_seq, rtx start_label, rtx condition)\n-{\n-  rtx counter_reg;\n-  rtx count;\n-  rtx sequence;\n-  rtx jump_insn;\n-  int nonneg = 0;\n-  int decrement_count;\n-\n-  jump_insn = prev_nonnote_insn (loop->end);\n-\n-  if (loop_dump_stream)\n-    {\n-      fprintf (loop_dump_stream, \"Doloop: Inserting doloop pattern (\");\n-      if (GET_CODE (iterations) == CONST_INT)\n-\tfprintf (loop_dump_stream, HOST_WIDE_INT_PRINT_DEC,\n-\t\t INTVAL (iterations));\n-      else\n-\tfputs (\"runtime\", loop_dump_stream);\n-      fputs (\" iterations).\", loop_dump_stream);\n-    }\n-\n-  /* Emit the label that will delimit the top of the loop.\n-     This has to be done before the delete_insn call below, to prevent\n-     delete_insn from deleting too much.  */\n-  emit_label_after (start_label, loop->top ? loop->top : loop->start);\n-  LABEL_NUSES (start_label)++;\n-\n-  /* Discard original jump to continue loop.  The original compare\n-     result may still be live, so it cannot be discarded explicitly.  */\n-  delete_related_insns (jump_insn);\n-\n-  counter_reg = XEXP (condition, 0);\n-  if (GET_CODE (counter_reg) == PLUS)\n-    counter_reg = XEXP (counter_reg, 0);\n-\n-  start_sequence ();\n-\n-  count = iterations;\n-  decrement_count = 0;\n-  switch (GET_CODE (condition))\n-    {\n-    case NE:\n-      /* Currently only NE tests against zero and one are supported.  */\n-      if (XEXP (condition, 1) == const0_rtx)\n-\tdecrement_count = 1;\n-      else if (XEXP (condition, 1) != const1_rtx)\n-\tabort ();\n-      break;\n-\n-    case GE:\n-      /* Currently only GE tests against zero are supported.  */\n-      if (XEXP (condition, 1) != const0_rtx)\n-\tabort ();\n-\n-      /* The iteration count needs decrementing for a GE test.  */\n-      decrement_count = 1;\n-\n-      /* Determine if the iteration counter will be non-negative.\n-\t Note that the maximum value loaded is iterations_max - 1.  */\n-      if ((unsigned HOST_WIDE_INT) INTVAL (iterations_max)\n-\t  <= ((unsigned) 1 << (GET_MODE_BITSIZE (GET_MODE (counter_reg)) - 1)))\n-\tnonneg = 1;\n-      break;\n-\n-      /* Abort if an invalid doloop pattern has been generated.  */\n-    default:\n-      abort ();\n-    }\n-\n-  if (decrement_count)\n-    {\n-      if (GET_CODE (count) == CONST_INT)\n-\tcount = GEN_INT (INTVAL (count) - 1);\n-      else\n-\tcount = expand_simple_binop (GET_MODE (counter_reg), MINUS,\n-\t\t\t\t     count, const1_rtx,\n-\t\t\t\t     0, 0, OPTAB_LIB_WIDEN);\n-    }\n-\n-  /* Insert initialization of the count register into the loop header.  */\n-  convert_move (counter_reg, count, 1);\n-  sequence = get_insns ();\n-  end_sequence ();\n-  emit_insn_before (sequence, loop->start);\n-\n-  /* Some targets (eg, C4x) need to initialize special looping\n-     registers.  */\n-#ifdef HAVE_doloop_begin\n-  {\n-    rtx init;\n-\n-    init = gen_doloop_begin (counter_reg,\n-\t\t\t     GET_CODE (iterations) == CONST_INT\n-\t\t\t     ? iterations : const0_rtx, iterations_max,\n-\t\t\t     GEN_INT (loop->level));\n-    if (init)\n-      {\n-\tstart_sequence ();\n-\temit_insn (init);\n-\tsequence = get_insns ();\n-\tend_sequence ();\n-\temit_insn_after (sequence, loop->start);\n-      }\n-  }\n-#endif\n-\n-  /* Insert the new low-overhead looping insn.  */\n-  emit_jump_insn_before (doloop_seq, loop->end);\n-  jump_insn = prev_nonnote_insn (loop->end);\n-  JUMP_LABEL (jump_insn) = start_label;\n-\n-  /* Add a REG_NONNEG note if the actual or estimated maximum number\n-     of iterations is non-negative.  */\n-  if (nonneg)\n-    {\n-      REG_NOTES (jump_insn)\n-\t= gen_rtx_EXPR_LIST (REG_NONNEG, NULL_RTX, REG_NOTES (jump_insn));\n-    }\n-  return 1;\n-}\n-\n-\n-/* Handle the more complex case, where the bounds are not known at\n-   compile time.  In this case we generate a run_time calculation of\n-   the number of iterations.  We rely on the existence of a run-time\n-   guard to ensure that the loop executes at least once, i.e.,\n-   initial_value obeys the loop comparison condition.  If a guard is\n-   not present, we emit one.  The loop to modify is described by LOOP.\n-   ITERATIONS_MAX is a CONST_INT specifying the estimated maximum\n-   number of loop iterations.  DOLOOP_INSN is the low-overhead looping\n-   insn to insert.  Returns nonzero if loop successfully modified.  */\n-static int\n-doloop_modify_runtime (const struct loop *loop, rtx iterations_max,\n-\t\t       rtx doloop_seq, rtx start_label,\n-\t\t       enum machine_mode mode, rtx condition)\n-{\n-  const struct loop_info *loop_info = LOOP_INFO (loop);\n-  HOST_WIDE_INT abs_inc;\n-  HOST_WIDE_INT abs_loop_inc;\n-  int neg_inc;\n-  rtx diff;\n-  rtx sequence;\n-  rtx iterations;\n-  rtx initial_value;\n-  rtx final_value;\n-  rtx increment;\n-  int unsigned_p;\n-  enum rtx_code comparison_code;\n-\n-  increment = loop_info->increment;\n-  initial_value = loop_info->initial_value;\n-  final_value = loop_info->final_value;\n-\n-  neg_inc = 0;\n-  abs_inc = INTVAL (increment);\n-  if (abs_inc < 0)\n-    {\n-      abs_inc = -abs_inc;\n-      neg_inc = 1;\n-    }\n-\n-  comparison_code = loop_info->comparison_code;\n-  unsigned_p = (comparison_code == LTU\n-\t\t|| comparison_code == LEU\n-\t\t|| comparison_code == GTU\n-\t\t|| comparison_code == GEU\n-\t\t|| comparison_code == NE);\n-\n-  /* The number of iterations (prior to any loop unrolling) is given by:\n-\n-       n = (abs (final - initial) + abs_inc - 1) / abs_inc.\n-\n-     However, it is possible for the summation to overflow, and a\n-     safer method is:\n-\n-       n = abs (final - initial) / abs_inc;\n-       n += (abs (final - initial) % abs_inc) != 0;\n-\n-     But when abs_inc is a power of two, the summation won't overflow\n-     except in cases where the loop never terminates.  So we don't\n-     need to use this more costly calculation.\n-\n-     If the loop has been unrolled, the full calculation is\n-\n-       t1 = abs_inc * unroll_number;\t\t        increment per loop\n-       n = (abs (final - initial) + abs_inc - 1) / t1;    full loops\n-       n += (abs (final - initial) + abs_inc - 1) % t1) >= abs_inc;\n-                                                          partial loop\n-     which works out to be equivalent to\n-\n-       n = (abs (final - initial) + t1 - 1) / t1;\n-\n-     In the case where the loop was preconditioned, a few iterations\n-     may have been executed earlier; but 'initial' was adjusted as they\n-     were executed, so we don't need anything special for that case here.\n-     As above, when t1 is a power of two we don't need to worry about\n-     overflow.\n-\n-     The division and modulo operations can be avoided by requiring\n-     that the increment is a power of 2 (precondition_loop_p enforces\n-     this requirement).  Nevertheless, the RTX_COSTS should be checked\n-     to see if a fast divmod is available.  */\n-\n-  start_sequence ();\n-  /* abs (final - initial)  */\n-  diff = expand_simple_binop (mode, MINUS,\n-\t\t\t      copy_rtx (neg_inc ? initial_value : final_value),\n-\t\t\t      copy_rtx (neg_inc ? final_value : initial_value),\n-\t\t\t      NULL_RTX, unsigned_p, OPTAB_LIB_WIDEN);\n-\n-  /* Some code transformations can result in code akin to\n-\n-\t  tmp = i + 1;\n-\t  ...\n-\t  goto scan_start;\n-\ttop:\n-\t  tmp = tmp + 1;\n-\tscan_start:\n-\t  i = tmp;\n-\t  if (i < n) goto top;\n-\n-     We'll have already detected this form of loop in scan_loop,\n-     and set loop->top and loop->scan_start appropriately.\n-\n-     In this situation, we skip the increment the first time through\n-     the loop, which results in an incorrect estimate of the number\n-     of iterations.  Adjust the difference to compensate.  */\n-  /* ??? Logically, it would seem this belongs in loop_iterations.\n-     However, this causes regressions e.g. on x86 execute/20011008-3.c,\n-     so I do not believe we've properly characterized the exact nature\n-     of the problem.  In the meantime, this fixes execute/20011126-2.c\n-     on ia64 and some Ada front end miscompilation on ppc.  */\n-\n-  if (loop->scan_start)\n-    {\n-      rtx iteration_var = loop_info->iteration_var;\n-      struct loop_ivs *ivs = LOOP_IVS (loop);\n-      struct iv_class *bl;\n-\n-      if (REG_IV_TYPE (ivs, REGNO (iteration_var)) == BASIC_INDUCT)\n-\tbl = REG_IV_CLASS (ivs, REGNO (iteration_var));\n-      else if (REG_IV_TYPE (ivs, REGNO (iteration_var)) == GENERAL_INDUCT)\n-\t{\n-\t  struct induction *v = REG_IV_INFO (ivs, REGNO (iteration_var));\n-\t  bl = REG_IV_CLASS (ivs, REGNO (v->src_reg));\n-\t}\n-      else\n-\t/* Iteration var must be an induction variable to get here.  */\n-\tabort ();\n-\n-      if (INSN_UID (bl->biv->insn) < max_uid_for_loop\n-\t  && INSN_LUID (bl->biv->insn) < INSN_LUID (loop->scan_start))\n-\t{\n-\t  if (loop_dump_stream)\n-\t    fprintf (loop_dump_stream,\n-\t         \"Doloop: Basic induction var skips initial incr.\\n\");\n-\n-\t  diff = expand_simple_binop (mode, PLUS, diff, GEN_INT (abs_inc),\n-\t\t\t\t      diff, unsigned_p, OPTAB_LIB_WIDEN);\n-\t}\n-    }\n-\n-  abs_loop_inc = abs_inc * loop_info->unroll_number;\n-  if (abs_loop_inc != 1)\n-    {\n-      int shift_count;\n-\n-      shift_count = exact_log2 (abs_loop_inc);\n-      if (shift_count < 0)\n-\tabort ();\n-\n-      /* (abs (final - initial) + abs_inc * unroll_number - 1) */\n-      diff = expand_simple_binop (GET_MODE (diff), PLUS,\n-\t\t\t\t  diff, GEN_INT (abs_loop_inc - 1),\n-\t\t\t\t  diff, 1, OPTAB_LIB_WIDEN);\n-\n-      /* (abs (final - initial) + abs_inc * unroll_number - 1)\n-\t / (abs_inc * unroll_number)  */\n-      diff = expand_simple_binop (GET_MODE (diff), LSHIFTRT,\n-\t\t\t\t  diff, GEN_INT (shift_count),\n-\t\t\t\t  diff, 1, OPTAB_LIB_WIDEN);\n-    }\n-  iterations = diff;\n-\n-  /* If there is a NOTE_INSN_LOOP_VTOP, we have a `for' or `while'\n-     style loop, with a loop exit test at the start.  Thus, we can\n-     assume that the loop condition was true when the loop was\n-     entered.\n-\n-     `do-while' loops require special treatment since the exit test is\n-     not executed before the start of the loop.  We need to determine\n-     if the loop will terminate after the first pass and to limit the\n-     iteration count to one if necessary.  */\n-  if (! loop->vtop)\n-    {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream, \"Doloop: Do-while loop.\\n\");\n-\n-      /* A `do-while' loop must iterate at least once.  For code like\n-\t i = initial; do { ... } while (++i < final);\n-\t we will calculate a bogus iteration count if initial > final.\n-\t So detect this and set the iteration count to 1.\n-\t Note that if the loop has been unrolled, then the loop body\n-\t is guaranteed to execute at least once.  Also, when the\n-\t comparison is NE, our calculated count will be OK.  */\n-      if (loop_info->unroll_number == 1 && comparison_code != NE)\n-\t{\n-\t  rtx label;\n-\n-\t  /*  Emit insns to test if the loop will immediately\n-\t      terminate and to set the iteration count to 1 if true.  */\n-\t  label = gen_label_rtx();\n-\t  emit_cmp_and_jump_insns (copy_rtx (initial_value),\n-\t\t\t\t   copy_rtx (loop_info->comparison_value),\n-\t\t\t\t   comparison_code, NULL_RTX, mode, 0,\n-\t\t\t\t   label);\n-\t  JUMP_LABEL (get_last_insn ()) = label;\n-\t  LABEL_NUSES (label)++;\n-\t  emit_move_insn (iterations, const1_rtx);\n-\t  emit_label (label);\n-\t}\n-    }\n-\n-  sequence = get_insns ();\n-  end_sequence ();\n-  emit_insn_before (sequence, loop->start);\n-\n-  return doloop_modify (loop, iterations, iterations_max, doloop_seq,\n-\t\t\tstart_label, condition);\n-}\n-\n-\n-/* This is the main entry point.  Process loop described by LOOP\n-   validating that the loop is suitable for conversion to use a low\n-   overhead looping instruction, replacing the jump insn where\n-   suitable.  We distinguish between loops with compile-time bounds\n-   and those with run-time bounds.  Information from LOOP is used to\n-   compute the number of iterations and to determine whether the loop\n-   is a candidate for this optimization.  Returns nonzero if loop\n-   successfully modified.  */\n-int\n-doloop_optimize (const struct loop *loop)\n-{\n-  struct loop_info *loop_info = LOOP_INFO (loop);\n-  rtx initial_value;\n-  rtx final_value;\n-  rtx increment;\n-  rtx jump_insn;\n-  enum machine_mode mode;\n-  unsigned HOST_WIDE_INT n_iterations;\n-  unsigned HOST_WIDE_INT n_iterations_max;\n-  rtx doloop_seq, doloop_pat, doloop_reg;\n-  rtx iterations;\n-  rtx iterations_max;\n-  rtx start_label;\n-  rtx condition;\n-\n-  if (loop_dump_stream)\n-    fprintf (loop_dump_stream,\n-\t     \"Doloop: Processing loop %d, enclosed levels %d.\\n\",\n-\t     loop->num, loop->level);\n-\n-  jump_insn = prev_nonnote_insn (loop->end);\n-\n-  /* Check that loop is a candidate for a low-overhead looping insn.  */\n-  if (! doloop_valid_p (loop, jump_insn))\n-    return 0;\n-\n-  /* Determine if the loop can be safely, and profitably,\n-     preconditioned.  While we don't precondition the loop in a loop\n-     unrolling sense, this test ensures that the loop is well behaved\n-     and that the increment is a constant integer.  */\n-  if (! precondition_loop_p (loop, &initial_value, &final_value,\n-\t\t\t     &increment, &mode))\n-    {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"Doloop: Cannot precondition loop.\\n\");\n-      return 0;\n-    }\n-\n-  /* Determine or estimate the maximum number of loop iterations.  */\n-  n_iterations = loop_info->n_iterations;\n-  if (n_iterations)\n-    {\n-      /* This is the simple case where the initial and final loop\n-\t values are constants.  */\n-      n_iterations_max = n_iterations;\n-    }\n-  else\n-    {\n-      int nonneg = find_reg_note (jump_insn, REG_NONNEG, 0) != 0;\n-\n-      /* This is the harder case where the initial and final loop\n-\t values may not be constants.  */\n-      n_iterations_max = doloop_iterations_max (loop_info, mode, nonneg);\n-\n-      if (! n_iterations_max)\n-\t{\n-\t  /* We have something like `for (i = 0; i < 10; i--)'.  */\n-\t  if (loop_dump_stream)\n-\t    fprintf (loop_dump_stream,\n-\t\t     \"Doloop: Not normal loop.\\n\");\n-\t  return 0;\n-\t}\n-    }\n-\n-  /* Account for loop unrolling in the iteration count.  This will\n-     have no effect if loop_iterations could not determine the number\n-     of iterations.  */\n-  n_iterations /= loop_info->unroll_number;\n-  n_iterations_max /= loop_info->unroll_number;\n-\n-  if (n_iterations && n_iterations < 3)\n-    {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"Doloop: Too few iterations (%ld) to be profitable.\\n\",\n-\t\t (long int) n_iterations);\n-      return 0;\n-    }\n-\n-  iterations = GEN_INT (n_iterations);\n-  iterations_max = GEN_INT (n_iterations_max);\n-\n-  /* Generate looping insn.  If the pattern FAILs then give up trying\n-     to modify the loop since there is some aspect the back-end does\n-     not like.  */\n-  start_label = gen_label_rtx ();\n-  doloop_reg = gen_reg_rtx (mode);\n-  doloop_seq = gen_doloop_end (doloop_reg, iterations, iterations_max,\n-\t\t\t       GEN_INT (loop->level), start_label);\n-  if (! doloop_seq && mode != word_mode)\n-    {\n-      PUT_MODE (doloop_reg, word_mode);\n-      doloop_seq = gen_doloop_end (doloop_reg, iterations, iterations_max,\n-\t\t\t\t   GEN_INT (loop->level), start_label);\n-    }\n-  if (! doloop_seq)\n-    {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"Doloop: Target unwilling to use doloop pattern!\\n\");\n-      return 0;\n-    }\n-\n-  /* If multiple instructions were created, the last must be the\n-     jump instruction.  Also, a raw define_insn may yield a plain\n-     pattern.  */\n-  doloop_pat = doloop_seq;\n-  if (INSN_P (doloop_pat))\n-    {\n-      while (NEXT_INSN (doloop_pat) != NULL_RTX)\n-\tdoloop_pat = NEXT_INSN (doloop_pat);\n-      if (GET_CODE (doloop_pat) == JUMP_INSN)\n-\tdoloop_pat = PATTERN (doloop_pat);\n-      else\n-\tdoloop_pat = NULL_RTX;\n-    }\n-\n-  if (! doloop_pat\n-      || ! (condition = doloop_condition_get (doloop_pat)))\n-    {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"Doloop: Unrecognizable doloop pattern!\\n\");\n-      return 0;\n-    }\n-\n-  if (n_iterations != 0)\n-    /* Handle the simpler case, where we know the iteration count at\n-       compile time.  */\n-    return doloop_modify (loop, iterations, iterations_max, doloop_seq,\n-\t\t\t  start_label, condition);\n-  else\n-    /* Handle the harder case, where we must add additional runtime tests.  */\n-    return doloop_modify_runtime (loop, iterations_max, doloop_seq,\n-\t\t\t\t  start_label, mode, condition);\n-}\n-\n-#endif /* HAVE_doloop_end */"}, {"sha": "b75b9dc03a6102759c5d83a04ae0f63826454452", "filename": "gcc/loop-doloop.c", "status": "added", "additions": 553, "deletions": 0, "changes": 553, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/689ba89dd8da4c7ecad4dab5e98d0d87d4e64383/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/689ba89dd8da4c7ecad4dab5e98d0d87d4e64383/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=689ba89dd8da4c7ecad4dab5e98d0d87d4e64383", "patch": "@@ -0,0 +1,553 @@\n+/* Perform doloop optimizations\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Based on code by Michael P. Hayes (m.hayes@elec.canterbury.ac.nz)\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"flags.h\"\n+#include \"expr.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"toplev.h\"\n+#include \"tm_p.h\"\n+#include \"cfgloop.h\"\n+#include \"output.h\"\n+#include \"params.h\"\n+\n+/* This module is used to modify loops with a determinable number of\n+   iterations to use special low-overhead looping instructions.\n+\n+   It first validates whether the loop is well behaved and has a\n+   determinable number of iterations (either at compile or run-time).\n+   It then modifies the loop to use a low-overhead looping pattern as\n+   follows:\n+\n+   1. A pseudo register is allocated as the loop iteration counter.\n+\n+   2. The number of loop iterations is calculated and is stored\n+      in the loop counter.\n+\n+   3. At the end of the loop, the jump insn is replaced by the\n+      doloop_end pattern.  The compare must remain because it might be\n+      used elsewhere.  If the loop-variable or condition register are\n+      used elsewhere, they will be eliminated by flow.\n+\n+   4. An optional doloop_begin pattern is inserted at the top of the\n+      loop.\n+\n+   TODO The optimization should only performed when either the biv used for exit\n+   condition is unused at all except for the exit test, or if we do not have to\n+   change its value, since otherwise we have to add a new induction variable,\n+   which usually will not pay up (unless the cost of the doloop pattern is\n+   somehow extremely lower than the cost of compare & jump, or unless the bct\n+   register cannot be used for anything else but doloop -- ??? detect these\n+   cases).  */\n+\n+#ifdef HAVE_doloop_end\n+\n+/* Return the loop termination condition for PATTERN or zero\n+   if it is not a decrement and branch jump insn.  */\n+\n+static rtx\n+doloop_condition_get (rtx pattern)\n+{\n+  rtx cmp;\n+  rtx inc;\n+  rtx reg;\n+  rtx condition;\n+\n+  /* The canonical doloop pattern we expect is:\n+\n+     (parallel [(set (pc) (if_then_else (condition)\n+                                        (label_ref (label))\n+                                        (pc)))\n+                (set (reg) (plus (reg) (const_int -1)))\n+                (additional clobbers and uses)])\n+\n+     Some machines (IA-64) make the decrement conditional on\n+     the condition as well, so we don't bother verifying the\n+     actual decrement.  In summary, the branch must be the\n+     first entry of the parallel (also required by jump.c),\n+     and the second entry of the parallel must be a set of\n+     the loop counter register.  */\n+\n+  if (GET_CODE (pattern) != PARALLEL)\n+    return 0;\n+\n+  cmp = XVECEXP (pattern, 0, 0);\n+  inc = XVECEXP (pattern, 0, 1);\n+\n+  /* Check for (set (reg) (something)).  */\n+  if (GET_CODE (inc) != SET || ! REG_P (SET_DEST (inc)))\n+    return 0;\n+\n+  /* Extract loop counter register.  */\n+  reg = SET_DEST (inc);\n+\n+  /* Check for (set (pc) (if_then_else (condition)\n+                                       (label_ref (label))\n+                                       (pc))).  */\n+  if (GET_CODE (cmp) != SET\n+      || SET_DEST (cmp) != pc_rtx\n+      || GET_CODE (SET_SRC (cmp)) != IF_THEN_ELSE\n+      || GET_CODE (XEXP (SET_SRC (cmp), 1)) != LABEL_REF\n+      || XEXP (SET_SRC (cmp), 2) != pc_rtx)\n+    return 0;\n+\n+  /* Extract loop termination condition.  */\n+  condition = XEXP (SET_SRC (cmp), 0);\n+\n+  if ((GET_CODE (condition) != GE && GET_CODE (condition) != NE)\n+      || GET_CODE (XEXP (condition, 1)) != CONST_INT)\n+    return 0;\n+\n+  if (XEXP (condition, 0) == reg)\n+    return condition;\n+\n+  if (GET_CODE (XEXP (condition, 0)) == PLUS\n+      && XEXP (XEXP (condition, 0), 0) == reg)\n+    return condition;\n+\n+  /* ??? If a machine uses a funny comparison, we could return a\n+     canonicalised form here.  */\n+\n+  return 0;\n+}\n+\n+/* Return nonzero if the loop specified by LOOP is suitable for\n+   the use of special low-overhead looping instructions.  DESC\n+   describes the number of iterations of the loop.  */\n+\n+static bool\n+doloop_valid_p (struct loop *loop, struct niter_desc *desc)\n+{\n+  basic_block *body = get_loop_body (loop), bb;\n+  rtx insn;\n+  unsigned i;\n+\n+  /* Check for loops that may not terminate under special conditions.  */\n+  if (!desc->simple_p\n+      || desc->assumptions\n+      || desc->infinite)\n+    {\n+      /* There are some cases that would require a special attention.\n+\t For example if the comparison is LEU and the comparison value\n+\t is UINT_MAX then the loop will not terminate.  Similarly, if the\n+\t comparison code is GEU and the comparison value is 0, the\n+\t loop will not terminate.\n+\n+\t If the absolute increment is not 1, the loop can be infinite\n+\t even with LTU/GTU, e.g. for (i = 3; i > 0; i -= 2)\n+\n+\t ??? We could compute these conditions at run-time and have a\n+\t additional jump around the loop to ensure an infinite loop.\n+\t However, it is very unlikely that this is the intended\n+\t behavior of the loop and checking for these rare boundary\n+\t conditions would pessimize all other code.\n+\n+\t If the loop is executed only a few times an extra check to\n+\t restart the loop could use up most of the benefits of using a\n+\t count register loop.  Note however, that normally, this\n+\t restart branch would never execute, so it could be predicted\n+\t well by the CPU.  We should generate the pessimistic code by\n+\t default, and have an option, e.g. -funsafe-loops that would\n+\t enable count-register loops in this case.  */\n+      if (dump_file)\n+\tfprintf (dump_file, \"Doloop: Possible infinite iteration case.\\n\");\n+      return false;\n+    }\n+\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      bb = body[i];\n+\n+      for (insn = BB_HEAD (bb);\n+\t   insn != NEXT_INSN (BB_END (bb));\n+\t   insn = NEXT_INSN (insn))\n+\t{\n+\t  /* A called function may clobber any special registers required for\n+\t     low-overhead looping.  */\n+\t  if (GET_CODE (insn) == CALL_INSN)\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"Doloop: Function call in loop.\\n\");\n+\t      return false;\n+\t    }\n+\n+\t  /* Some targets (eg, PPC) use the count register for branch on table\n+\t     instructions.  ??? This should be a target specific check.  */\n+\t  if (GET_CODE (insn) == JUMP_INSN\n+\t      && (GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC\n+\t\t  || GET_CODE (PATTERN (insn)) == ADDR_VEC))\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"Doloop: Computed branch in the loop.\\n\");\n+\t      return false;\n+\t    }\n+\t}\n+    }\n+  free (body);\n+\n+  return true;\n+}\n+\n+/* Adds test of COND jumping to DEST to the end of BB.  */\n+\n+static void\n+add_test (rtx cond, basic_block bb, basic_block dest)\n+{\n+  rtx seq, jump, label;\n+  enum machine_mode mode;\n+  rtx op0 = XEXP (cond, 0), op1 = XEXP (cond, 1);\n+  enum rtx_code code = GET_CODE (cond);\n+\n+  mode = GET_MODE (XEXP (cond, 0));\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (XEXP (cond, 1));\n+\n+  start_sequence ();\n+  op0 = force_operand (op0, NULL_RTX);\n+  op1 = force_operand (op1, NULL_RTX);\n+  label = block_label (dest);\n+  do_compare_rtx_and_jump (op0, op1, code, 0, mode, NULL_RTX, NULL_RTX, label);\n+\n+  jump = get_last_insn ();\n+  JUMP_LABEL (jump) = label;\n+\n+  /* The jump is supposed to handle an unlikely special case.  */\n+  REG_NOTES (jump)\n+\t  = gen_rtx_EXPR_LIST (REG_BR_PROB,\n+\t\t\t       GEN_INT (0), REG_NOTES (jump));\n+\n+  LABEL_NUSES (label)++;\n+\n+  seq = get_insns ();\n+  end_sequence ();\n+  emit_insn_after (seq, BB_END (bb));\n+}\n+\n+/* Modify the loop to use the low-overhead looping insn where LOOP\n+   describes the loop, DESC describes the number of iterations of the\n+   loop, and DOLOOP_INSN is the low-overhead looping insn to emit at the\n+   end of the loop.  CONDITION is the condition separated from the\n+   DOLOOP_SEQ.  */\n+\n+static void\n+doloop_modify (struct loop *loop, struct niter_desc *desc,\n+\t       rtx doloop_seq, rtx condition)\n+{\n+  rtx counter_reg;\n+  rtx count, tmp, noloop = NULL_RTX;\n+  rtx sequence;\n+  rtx jump_insn;\n+  rtx jump_label;\n+  int nonneg = 0, irr;\n+  bool increment_count;\n+  basic_block loop_end = desc->out_edge->src;\n+\n+  jump_insn = BB_END (loop_end);\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"Doloop: Inserting doloop pattern (\");\n+      if (desc->const_iter)\n+\tfprintf (dump_file, HOST_WIDEST_INT_PRINT_DEC, desc->niter);\n+      else\n+\tfputs (\"runtime\", dump_file);\n+      fputs (\" iterations).\\n\", dump_file);\n+    }\n+\n+  /* Discard original jump to continue loop.  The original compare\n+     result may still be live, so it cannot be discarded explicitly.  */\n+  delete_insn (jump_insn);\n+\n+  counter_reg = XEXP (condition, 0);\n+  if (GET_CODE (counter_reg) == PLUS)\n+    counter_reg = XEXP (counter_reg, 0);\n+\n+  count = desc->niter_expr;\n+  increment_count = false;\n+  switch (GET_CODE (condition))\n+    {\n+    case NE:\n+      /* Currently only NE tests against zero and one are supported.  */\n+      if (XEXP (condition, 1) == const1_rtx)\n+\t{\n+\t  increment_count = true;\n+\t  noloop = const1_rtx;\n+\t}\n+      else if (XEXP (condition, 1) == const0_rtx)\n+       \tnoloop = const0_rtx;\n+      else\n+\tabort ();\n+      break;\n+\n+    case GE:\n+      /* Currently only GE tests against zero are supported.  */\n+      if (XEXP (condition, 1) != const0_rtx)\n+\tabort ();\n+\n+      noloop = constm1_rtx;\n+\n+      /* The iteration count does not need incrementing for a GE test.  */\n+      increment_count = false;\n+\n+      /* Determine if the iteration counter will be non-negative.\n+\t Note that the maximum value loaded is iterations_max - 1.  */\n+      if (desc->niter_max\n+\t  <= ((unsigned HOST_WIDEST_INT) 1\n+\t      << (GET_MODE_BITSIZE (GET_MODE (counter_reg)) - 1)))\n+\tnonneg = 1;\n+      break;\n+\n+      /* Abort if an invalid doloop pattern has been generated.  */\n+    default:\n+      abort ();\n+    }\n+\n+  if (increment_count)\n+    count = simplify_gen_binary (PLUS, desc->mode, count, const1_rtx);\n+\n+  /* Insert initialization of the count register into the loop header.  */\n+  start_sequence ();\n+  tmp = force_operand (count, counter_reg);\n+  convert_move (counter_reg, tmp, 1);\n+  sequence = get_insns ();\n+  end_sequence ();\n+  emit_insn_after (sequence, BB_END (loop_preheader_edge (loop)->src));\n+\n+  if (desc->noloop_assumptions)\n+    {\n+      rtx ass = desc->noloop_assumptions;\n+      basic_block preheader = loop_preheader_edge (loop)->src;\n+      basic_block set_zero\n+\t      = loop_split_edge_with (loop_preheader_edge (loop), NULL_RTX);\n+      basic_block new_preheader\n+\t      = loop_split_edge_with (loop_preheader_edge (loop), NULL_RTX);\n+      basic_block bb;\n+      edge te;\n+      gcov_type cnt;\n+\n+      /* Expand the condition testing the assumptions and if it does not pass,\n+\t reset the count register to 0.  */\n+      add_test (XEXP (ass, 0), preheader, set_zero);\n+      preheader->succ->flags &= ~EDGE_FALLTHRU;\n+      cnt = preheader->succ->count;\n+      preheader->succ->probability = 0;\n+      preheader->succ->count = 0;\n+      irr = preheader->succ->flags & EDGE_IRREDUCIBLE_LOOP;\n+      te = make_edge (preheader, new_preheader, EDGE_FALLTHRU | irr);\n+      te->probability = REG_BR_PROB_BASE;\n+      te->count = cnt;\n+      set_immediate_dominator (CDI_DOMINATORS, new_preheader, preheader);\n+\n+      set_zero->count = 0;\n+      set_zero->frequency = 0;\n+\n+      for (ass = XEXP (ass, 1); ass; ass = XEXP (ass, 1))\n+\t{\n+\t  bb = loop_split_edge_with (te, NULL_RTX);\n+\t  te = bb->succ;\n+\t  add_test (XEXP (ass, 0), bb, set_zero);\n+\t  make_edge (bb, set_zero, irr);\n+\t}\n+  \n+      start_sequence ();\n+      convert_move (counter_reg, noloop, 0);\n+      sequence = get_insns ();\n+      end_sequence ();\n+      emit_insn_after (sequence, BB_END (set_zero));\n+    }\n+\n+  /* Some targets (eg, C4x) need to initialize special looping\n+     registers.  */\n+#ifdef HAVE_doloop_begin\n+  {\n+    rtx init;\n+    unsigned level = get_loop_level (loop) + 1;\n+    init = gen_doloop_begin (counter_reg,\n+\t\t\t     desc->const_iter ? desc->niter_expr : const0_rtx,\n+\t\t\t     desc->niter_max,\n+\t\t\t     GEN_INT (level));\n+    if (init)\n+      {\n+\tstart_sequence ();\n+\temit_insn (init);\n+\tsequence = get_insns ();\n+\tend_sequence ();\n+\temit_insn_after (sequence, BB_END (loop_preheader_edge (loop)->src));\n+      }\n+  }\n+#endif\n+\n+  /* Insert the new low-overhead looping insn.  */\n+  emit_jump_insn_after (doloop_seq, BB_END (loop_end));\n+  jump_insn = BB_END (loop_end);\n+  jump_label = block_label (desc->in_edge->dest);\n+  JUMP_LABEL (jump_insn) = jump_label;\n+  LABEL_NUSES (jump_label)++;\n+\n+  /* Ensure the right fallthru edge is marked, for case we have reversed\n+     the condition.  */\n+  desc->in_edge->flags &= ~EDGE_FALLTHRU;\n+  desc->out_edge->flags |= EDGE_FALLTHRU;\n+\n+  /* Add a REG_NONNEG note if the actual or estimated maximum number\n+     of iterations is non-negative.  */\n+  if (nonneg)\n+    {\n+      REG_NOTES (jump_insn)\n+\t= gen_rtx_EXPR_LIST (REG_NONNEG, NULL_RTX, REG_NOTES (jump_insn));\n+    }\n+}\n+\n+/* Process loop described by LOOP validating that the loop is suitable for\n+   conversion to use a low overhead looping instruction, replacing the jump\n+   insn where suitable.  Returns true if the loop was successfully\n+   modified.  */\n+\n+static bool\n+doloop_optimize (struct loop *loop)\n+{\n+  enum machine_mode mode;\n+  rtx doloop_seq, doloop_pat, doloop_reg;\n+  rtx iterations;\n+  rtx iterations_max;\n+  rtx start_label;\n+  rtx condition;\n+  unsigned level, est_niter;\n+  struct niter_desc *desc;\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Doloop: Processing loop %d.\\n\", loop->num);\n+\n+  iv_analysis_loop_init (loop);\n+\n+  /* Find the simple exit of a LOOP.  */\n+  desc = get_simple_loop_desc (loop);\n+\n+  /* Check that loop is a candidate for a low-overhead looping insn.  */\n+  if (!doloop_valid_p (loop, desc))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \"Doloop: The loop is not suitable.\\n\");\n+      return false;\n+    }\n+  mode = desc->mode;\n+\n+  est_niter = 3;\n+  if (desc->const_iter)\n+    est_niter = desc->niter;\n+  /* If the estimate on number of iterations is reliable (comes from profile\n+     feedback), use it.  Do not use it normally, since the expected number\n+     of iterations of an unrolled loop is 2.  */\n+  if (loop->header->count)\n+    est_niter = expected_loop_iterations (loop);\n+\n+  if (est_niter < 3)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \"Doloop: Too few iterations (%u) to be profitable.\\n\",\n+\t\t est_niter);\n+      return false;\n+    }\n+\n+  iterations = desc->const_iter ? desc->niter_expr : const0_rtx;\n+  iterations_max = GEN_INT (desc->niter_max);\n+  level = get_loop_level (loop) + 1;\n+\n+  /* Generate looping insn.  If the pattern FAILs then give up trying\n+     to modify the loop since there is some aspect the back-end does\n+     not like.  */\n+  start_label = block_label (desc->in_edge->dest);\n+  doloop_reg = gen_reg_rtx (mode);\n+  doloop_seq = gen_doloop_end (doloop_reg, iterations, iterations_max,\n+\t\t\t       GEN_INT (level), start_label);\n+  if (! doloop_seq && mode != word_mode)\n+    {\n+      PUT_MODE (doloop_reg, word_mode);\n+      doloop_seq = gen_doloop_end (doloop_reg, iterations, iterations_max,\n+\t\t\t\t   GEN_INT (level), start_label);\n+    }\n+  if (! doloop_seq)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \"Doloop: Target unwilling to use doloop pattern!\\n\");\n+      return false;\n+    }\n+\n+  /* If multiple instructions were created, the last must be the\n+     jump instruction.  Also, a raw define_insn may yield a plain\n+     pattern.  */\n+  doloop_pat = doloop_seq;\n+  if (INSN_P (doloop_pat))\n+    {\n+      while (NEXT_INSN (doloop_pat) != NULL_RTX)\n+\tdoloop_pat = NEXT_INSN (doloop_pat);\n+      if (GET_CODE (doloop_pat) == JUMP_INSN)\n+\tdoloop_pat = PATTERN (doloop_pat);\n+      else\n+\tdoloop_pat = NULL_RTX;\n+    }\n+\n+  if (! doloop_pat\n+      || ! (condition = doloop_condition_get (doloop_pat)))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Doloop: Unrecognizable doloop pattern!\\n\");\n+      return false;\n+    }\n+\n+  doloop_modify (loop, desc, doloop_seq, condition);\n+  return true;\n+}\n+\n+/* This is the main entry point.  Process all LOOPS using doloop_optimize.  */\n+\n+void\n+doloop_optimize_loops (struct loops *loops)\n+{\n+  unsigned i;\n+  struct loop *loop;\n+\n+  for (i = 1; i < loops->num; i++)\n+    {\n+      loop = loops->parray[i];\n+      if (!loop)\n+\tcontinue;\n+\n+      doloop_optimize (loop);\n+    }\n+\n+  iv_analysis_done ();\n+\n+#ifdef ENABLE_CHECKING\n+  verify_dominators (CDI_DOMINATORS);\n+  verify_loop_structure (loops);\n+#endif\n+}\n+#endif /* HAVE_doloop_end */\n+"}, {"sha": "face41d3f326b07e1975bc6f4a40e1fc7092f060", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/689ba89dd8da4c7ecad4dab5e98d0d87d4e64383/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/689ba89dd8da4c7ecad4dab5e98d0d87d4e64383/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=689ba89dd8da4c7ecad4dab5e98d0d87d4e64383", "patch": "@@ -2281,6 +2281,10 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n   simplify_using_initial_values (loop, IOR, &desc->infinite);\n   simplify_using_initial_values (loop, NIL, &desc->niter_expr);\n \n+  if (desc->noloop_assumptions\n+      && XEXP (desc->noloop_assumptions, 0) == const_true_rtx)\n+    goto zero_iter;\n+\n   if (GET_CODE (desc->niter_expr) == CONST_INT)\n     {\n       unsigned HOST_WIDEST_INT val = INTVAL (desc->niter_expr);"}, {"sha": "1b488fe5dbc27a1bede64d646271861022ececa8", "filename": "gcc/loop.c", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/689ba89dd8da4c7ecad4dab5e98d0d87d4e64383/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/689ba89dd8da4c7ecad4dab5e98d0d87d4e64383/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=689ba89dd8da4c7ecad4dab5e98d0d87d4e64383", "patch": "@@ -5352,23 +5352,6 @@ strength_reduce (struct loop *loop, int flags)\n \t  && unrolled_insn_copies <= insn_count))\n     unroll_loop (loop, insn_count, 1);\n \n-#ifdef HAVE_doloop_end\n-  if (HAVE_doloop_end && (flags & LOOP_BCT) && flag_branch_on_count_reg)\n-    doloop_optimize (loop);\n-#endif  /* HAVE_doloop_end  */\n-\n-  /* In case number of iterations is known, drop branch prediction note\n-     in the branch.  Do that only in second loop pass, as loop unrolling\n-     may change the number of iterations performed.  */\n-  if (flags & LOOP_BCT)\n-    {\n-      unsigned HOST_WIDE_INT n\n-\t= loop_info->n_iterations / loop_info->unroll_number;\n-      if (n > 1)\n-\tpredict_insn (prev_nonnote_insn (loop->end), PRED_LOOP_ITERATIONS,\n-\t\t      REG_BR_PROB_BASE - REG_BR_PROB_BASE / n);\n-    }\n-\n   if (loop_dump_stream)\n     fprintf (loop_dump_stream, \"\\n\");\n "}, {"sha": "bd88bb8c90e93889ba9140bfacdf799abf8fcf79", "filename": "gcc/loop.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/689ba89dd8da4c7ecad4dab5e98d0d87d4e64383/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/689ba89dd8da4c7ecad4dab5e98d0d87d4e64383/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=689ba89dd8da4c7ecad4dab5e98d0d87d4e64383", "patch": "@@ -26,9 +26,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n /* Flags passed to loop_optimize.  */\n #define LOOP_UNROLL 1\n-#define LOOP_BCT 2\n-#define LOOP_PREFETCH 4\n-#define LOOP_AUTO_UNROLL 8\n+#define LOOP_PREFETCH 2\n+#define LOOP_AUTO_UNROLL 4\n \n /* Get the loop info pointer of a loop.  */\n #define LOOP_INFO(LOOP) ((struct loop_info *) (LOOP)->aux)"}, {"sha": "24a2d232080d425e570bda37c07d543f90609d91", "filename": "gcc/passes.c", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/689ba89dd8da4c7ecad4dab5e98d0d87d4e64383/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/689ba89dd8da4c7ecad4dab5e98d0d87d4e64383/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=689ba89dd8da4c7ecad4dab5e98d0d87d4e64383", "patch": "@@ -1456,7 +1456,7 @@ rest_of_handle_loop_optimize (tree decl, rtx insns)\n       reg_scan (insns, max_reg_num (), 1);\n     }\n   cleanup_barriers ();\n-  loop_optimize (insns, dump_file, do_unroll | LOOP_BCT | do_prefetch);\n+  loop_optimize (insns, dump_file, do_unroll | do_prefetch);\n \n   /* Loop can create trivially dead instructions.  */\n   delete_trivially_dead_insns (insns, max_reg_num ());\n@@ -1476,6 +1476,12 @@ rest_of_handle_loop2 (tree decl, rtx insns)\n   struct loops *loops;\n   basic_block bb;\n \n+  if (!flag_unswitch_loops\n+      && !flag_peel_loops\n+      && !flag_unroll_loops\n+      && !flag_branch_on_count_reg)\n+    return;\n+\n   timevar_push (TV_LOOP);\n   open_dump_file (DFI_loop2, decl);\n   if (dump_file)\n@@ -1498,6 +1504,11 @@ rest_of_handle_loop2 (tree decl, rtx insns)\n \t\t\t       (flag_unroll_loops ? UAP_UNROLL : 0) |\n \t\t\t       (flag_unroll_all_loops ? UAP_UNROLL_ALL : 0));\n \n+#ifdef HAVE_doloop_end\n+      if (flag_branch_on_count_reg && HAVE_doloop_end)\n+\tdoloop_optimize_loops (loops);\n+#endif /* HAVE_doloop_end */\n+\n       loop_optimizer_finalize (loops, dump_file);\n     }\n \n@@ -1776,10 +1787,7 @@ rest_of_compilation (tree decl)\n   if (flag_tracer)\n     rest_of_handle_tracer (decl, insns);\n \n-  if (optimize > 0\n-      && (flag_unswitch_loops\n-\t  || flag_peel_loops\n-\t  || flag_unroll_loops))\n+  if (optimize > 0)\n     rest_of_handle_loop2 (decl, insns);\n \n   if (flag_web)"}]}