{"sha": "174cc7d12781fcced14be9b0af9ab7e1b9120206", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTc0Y2M3ZDEyNzgxZmNjZWQxNGJlOWIwYWY5YWI3ZTFiOTEyMDIwNg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-05-20T01:17:14Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-05-20T01:17:14Z"}, "message": "gensupport.c (init_include_reader): Merge into ...\n\n        * gensupport.c (init_include_reader): Merge into ...\n        (process_include): ... here.  Simplify composite path creation.\n        Plug memory leaks.  Fix file/line number tracking.  Do not\n        process_define_cond_exec.  Return void.\n        (process_rtx): Don't check process_include return value.\n\nFrom-SVN: r53643", "tree": {"sha": "c990d0287bd826e282b355864e94f75ef7eb798b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c990d0287bd826e282b355864e94f75ef7eb798b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/174cc7d12781fcced14be9b0af9ab7e1b9120206", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/174cc7d12781fcced14be9b0af9ab7e1b9120206", "html_url": "https://github.com/Rust-GCC/gccrs/commit/174cc7d12781fcced14be9b0af9ab7e1b9120206", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/174cc7d12781fcced14be9b0af9ab7e1b9120206/comments", "author": null, "committer": null, "parents": [{"sha": "918ed612a1b2328a11887b7166bc07a9efde130f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/918ed612a1b2328a11887b7166bc07a9efde130f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/918ed612a1b2328a11887b7166bc07a9efde130f"}], "stats": {"total": 187, "additions": 64, "deletions": 123}, "files": [{"sha": "50bb057c89fa71be6ce47ffbcc9286f530c6bb6c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/174cc7d12781fcced14be9b0af9ab7e1b9120206/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/174cc7d12781fcced14be9b0af9ab7e1b9120206/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=174cc7d12781fcced14be9b0af9ab7e1b9120206", "patch": "@@ -1,3 +1,11 @@\n+2002-05-19  Richard Henderson  <rth@redhat.com>\n+\n+\t* gensupport.c (init_include_reader): Merge into ...\n+\t(process_include): ... here.  Simplify composite path creation.\n+\tPlug memory leaks.  Fix file/line number tracking.  Do not\n+\tprocess_define_cond_exec.  Return void.\n+\t(process_rtx): Don't check process_include return value.\n+\n 2002-05-20  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n \n \t* basic_block.h (struct basic_block_def): Added prev_bb and next_bb"}, {"sha": "8b52eaecab8374c4243f6fe204e2fb52425924dc", "filename": "gcc/gensupport.c", "status": "modified", "additions": 56, "deletions": 123, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/174cc7d12781fcced14be9b0af9ab7e1b9120206/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/174cc7d12781fcced14be9b0af9ab7e1b9120206/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=174cc7d12781fcced14be9b0af9ab7e1b9120206", "patch": "@@ -97,9 +97,8 @@ static const char *alter_output_for_insn PARAMS ((struct queue_elem *,\n \t\t\t\t\t\t  int, int));\n static void process_one_cond_exec PARAMS ((struct queue_elem *));\n static void process_define_cond_exec PARAMS ((void));\n-static int process_include PARAMS ((rtx, int));\n+static void process_include PARAMS ((rtx, int));\n static char *save_string PARAMS ((const char *, int));\n-static int init_include_reader PARAMS ((FILE  *));\n \f\n void\n message_with_line VPARAMS ((int lineno, const char *msg, ...))\n@@ -179,142 +178,81 @@ remove_constraints (part)\n       }\n }\n \n-/* The entry point for initializing the reader.  */\n-\n-static int\n-init_include_reader (inf)\n-     FILE *inf;\n-{\n-  int c;\n-\n-  errors = 0;\n-\n-  /* Read the entire file.  */\n-  while (1)\n-    {\n-      rtx desc;\n-      int lineno;\n-\n-      c = read_skip_spaces (inf);\n-      if (c == EOF)\n-\tbreak;\n-\n-      ungetc (c, inf);\n-      lineno = read_rtx_lineno;\n-      desc = read_rtx (inf);\n-      process_rtx (desc, lineno);\n-    }\n-  fclose (inf);\n-\n-  /* Process define_cond_exec patterns.  */\n-  if (define_cond_exec_queue != NULL)\n-    process_define_cond_exec ();\n-\n-  return errors ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE;\n-}\n-\n /* Process an include file assuming that it lives in gcc/config/{target}/ \n-   if the include looks line (include \"file\" )  */\n-static int\n+   if the include looks line (include \"file\").  */\n+\n+static void\n process_include (desc, lineno)\n      rtx desc;\n      int lineno;\n {\n   const char *filename = XSTR (desc, 0);\n-  char *pathname = NULL;\n+  const char *old_filename;\n+  int old_lineno;\n+  char *pathname;\n   FILE *input_file;\n-  char *fname = NULL;\n-  struct file_name_list *stackp;\n-  int flen;\n \n-  stackp = first_dir_md_include;\n-\n-  /* If specified file name is absolute, just open it.  */\n-  if (IS_ABSOLUTE_PATHNAME (filename) || !stackp)\n+  /* If specified file name is absolute, skip the include stack.  */\n+  if (! IS_ABSOLUTE_PATHNAME (filename))\n     {\n-      if (base_dir)\n-        {\n-          pathname = xmalloc (strlen (base_dir) + strlen (filename) + 1);\n-          pathname = strcpy (pathname, base_dir);\n-          strcat (pathname, filename);\n-          strcat (pathname, \"\\0\");\n-\t}\n-      else\n-        {\n-\t  pathname = xstrdup (filename);\n-        }\n-      read_rtx_filename = pathname;\n-      input_file = fopen (pathname, \"r\");\n+      struct file_name_list *stackp;\n \n-      if (input_file == 0)\n+      /* Search directory path, trying to open the file.  */\n+      for (stackp = first_dir_md_include; stackp; stackp = stackp->next)\n \t{\n-\t  perror (pathname);\n-\t  return FATAL_EXIT_CODE;\n+\t  static const char sep[2] = { DIR_SEPARATOR, '\\0' };\n+\n+\t  pathname = concat (stackp->fname, sep, filename, NULL);\n+\t  input_file = fopen (pathname, \"r\");\n+\t  if (input_file != NULL) \n+\t    goto success;\n+\t  free (pathname);\n \t}\n     }\n-  else if (stackp)\n-    {\n-\n-      flen = strlen (filename);\n-\n-      fname = (char *) xmalloc (max_include_len + flen + 2);\n \n-      /* + 2 above for slash and terminating null.  */\n+  if (base_dir)\n+    pathname = concat (base_dir, filename, NULL);\n+  else\n+    pathname = xstrdup (filename);\n+  input_file = fopen (pathname, \"r\");\n+  if (input_file == NULL)\n+    {\n+      free (pathname);\n+      message_with_line (lineno, \"include file `%s' not found\", filename);\n+      errors = 1;\n+      return;\n+    }\n+ success:\n \n-      /* Search directory path, trying to open the file.\n-         Copy each filename tried into FNAME.  */\n+  /* Save old cursor; setup new for the new file.  Note that \"lineno\" the\n+     argument to this function is the beginning of the include statement,\n+     while read_rtx_lineno has already been advanced.  */\n+  old_filename = read_rtx_filename;\n+  old_lineno = read_rtx_lineno;\n+  read_rtx_filename = pathname;\n+  read_rtx_lineno = 1;\n \n-      for (; stackp; stackp = stackp->next)\n-\t{\n-\t  if (stackp->fname)\n-\t    {\n-\t      strcpy (fname, stackp->fname);\n-\t      strcat (fname, \"/\");\n-\t      fname[strlen (fname) + flen] = 0;\n-\t    }\n-\t  else\n-\t    {\n-\t      fname[0] = 0;\n-\t    }\n-\t  strncat (fname, (const char *) filename, flen);\n-\t  read_rtx_filename = fname;\n-\t  input_file = fopen (fname, \"r\");\n-\t  if (input_file != NULL) \n-\t    break;\n-\t}\n-      if (stackp == NULL)\n-\t{\n-\t  if (strchr (fname, '/') == NULL || strchr (fname, '\\\\' ) || base_dir)\n-\t    {\n-\t      if (base_dir)\n-\t\t{\n-\t\t  pathname =\n-\t\t    xmalloc (strlen (base_dir) + strlen (filename) + 1);\n-\t\t  pathname = strcpy (pathname, base_dir);\n-\t\t  strcat (pathname, filename);\n-\t\t  strcat (pathname, \"\\0\");\n-\t\t}\n-\t      else\n-\t\tpathname = xstrdup (filename);\n-\t    }\n-\t  read_rtx_filename = pathname;\n-\t  input_file = fopen (pathname, \"r\");\n+  /* Read the entire file.  */\n+  while (1)\n+    {\n+      rtx desc;\n+      int c;\n \n-\t  if (input_file == 0)\n-\t    {\n-\t      perror (filename);\n-\t      return FATAL_EXIT_CODE;\n-\t    }\n-\t}\n+      c = read_skip_spaces (input_file);\n+      if (c == EOF)\n+\tbreak;\n \n+      ungetc (c, input_file);\n+      lineno = read_rtx_lineno;\n+      desc = read_rtx (input_file);\n+      process_rtx (desc, lineno);\n     }\n \n-  if (init_include_reader (input_file) == FATAL_EXIT_CODE)\n-    message_with_line (lineno, \"read errors found in include file  %s\\n\", pathname);\n+  read_rtx_filename = old_filename;\n+  read_rtx_lineno = old_lineno;\n \n-  if (fname)\n-    free (fname);\n-  return SUCCESS_EXIT_CODE;\n+  fclose (input_file);\n+  free (pathname);\n }\n \n /* Process a top level rtx in some way, queueing as appropriate.  */\n@@ -339,12 +277,7 @@ process_rtx (desc, lineno)\n       break;\n \n     case INCLUDE:\n-      if (process_include (desc, lineno) == FATAL_EXIT_CODE)\n-\t{\n-\t  const char *filename = XSTR (desc, 0);\n-\t  message_with_line (lineno, \"include file at  %s not found\\n\",\n-\t\t\t     filename);\n-\t}\n+      process_include (desc, lineno);\n       break;\n \n     case DEFINE_INSN_AND_SPLIT:"}]}