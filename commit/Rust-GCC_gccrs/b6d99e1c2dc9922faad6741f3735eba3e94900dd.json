{"sha": "b6d99e1c2dc9922faad6741f3735eba3e94900dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZkOTllMWMyZGM5OTIyZmFhZDY3NDFmMzczNWViYTNlOTQ5MDBkZA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2015-07-09T18:57:06Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2015-07-09T18:57:06Z"}, "message": "rs6000-protos.h (rs6000_secondary_reload_memory): Use machine mode, not enum machine_mode in the prototype.\n\n2015-07-09  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000-protos.h (rs6000_secondary_reload_memory):\n\tUse machine mode, not enum machine_mode in the prototype.\n\n\t* config/rs6000/rs6000.h (FLOAT128_IEEE_P): New helper macros to\n\tclassify 128-bit floating point support.\n\t(FLOAT128_IBM_P): Likewise.\n\t(FLOAT128_VECTOR_P): Likewise.\n\t(FLOAT128_2REG_P): Likewise.\n\t(SCALAR_FLOAT_MODE_NOT_VECTOR_P): Likewise.\n\t(SLOW_UNALIGNED_ACCESS): Add IEEE 128-bit floating point support.\n\t(HARD_REGNO_CALLER_SAVE_MODE): Likewise.\n\t(HARD_REGNO_CALL_PART_CLOBBERED): Likewise.\n\n\t* config/rs6000/rs6000.c (rs6000_hard_regno_nregs_internal): Drop\n\ttests against TFmode/TDmode, since those modes do not use VSX\n\taddresses.\n\t(rs6000_hard_regno_mode_ok): Add IEEE 128-bit floating point\n\tsupport.\n\t(rs6000_init_hard_regno_mode_ok): Use new helper macros instead of\n\ttests against TFmode, etc.\n\t(invalid_e500_subreg): Add tests against IFmode/KFmode.\n\t(reg_offset_addressing_ok_p): Likewise.\n\t(rs6000_legitimate_offset_address_p): Likewise.\n\t(rs6000_legitimize_address): Likewise.\n\t(rs6000_legitimize_reload_address): Likewise.\n\t(rs6000_legitimate_address_p): Clean up tests against TFmode and\n\tTDmode to use the new helper macros, which will include IFmode and\n\tKFmode.\n\t(rs6000_emit_move): Likewise.\n\t(rs6000_darwin64_record_arg_recurse): Likewise.\n\t(print_operand): Likewise.\n\t(rs6000_member_type_forces_blk): Treat IEEE 128-bit floating point\n\tthat uses a single vector register as a vector and not as a\n\tfloating point register in terms of the calling sequence.\n\t(rs6000_discover_homogeneous_aggregate): Likewise.\n\t(rs6000_return_in_memory): Likewise.\n\t(init_cumulative_args): Likewise.\n\t(rs6000_function_arg_boundary): Likewise.\n\t(rs6000_function_arg_advance_1): Likewise.\n\t(rs6000_function_arg): Likewise.\n\t(rs6000_pass_by_reference): Likewise.\n\t(rs6000_gimplify_va_arg): Likewise.\n\t(rs6000_secondary_reload_memory): Use machine_mode not enum\n\tmachine mode.\n\t(rs6000_split_multireg_move): Use new helper macros.\n\t(spe_func_has_64bit_regs_p): Likewise.\n\t(rs6000_output_function_epilogue): Add IFmode/KFmode support.\n\t(output_toc): Use new helper macros.\n\t(rs6000_register_move_cost): Likewise.\n\t(rs6000_function_value): Add IEEE 128-bit floating point calling\n\tsequence support.\n\t(rs6000_libcall_value): Likewise.\n\t(rs6000_scalar_mode_supported_p): Add support for IEEE 128-bit\n\tfloating point support.\n\t(rs6000_vector_mode_supported_p): Likewise.\n\nFrom-SVN: r225632", "tree": {"sha": "9ae6d8eb2e55e56ec1d61834f103e30a4c9f759f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ae6d8eb2e55e56ec1d61834f103e30a4c9f759f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6d99e1c2dc9922faad6741f3735eba3e94900dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6d99e1c2dc9922faad6741f3735eba3e94900dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6d99e1c2dc9922faad6741f3735eba3e94900dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6d99e1c2dc9922faad6741f3735eba3e94900dd/comments", "author": null, "committer": null, "parents": [{"sha": "2c83faf86827bf5d49ededf3baf8c89a432028ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c83faf86827bf5d49ededf3baf8c89a432028ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c83faf86827bf5d49ededf3baf8c89a432028ee"}], "stats": {"total": 58, "additions": 58, "deletions": 0}, "files": [{"sha": "c05f3dfea2759ed42944bd5d4f63fa11e82585bb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6d99e1c2dc9922faad6741f3735eba3e94900dd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6d99e1c2dc9922faad6741f3735eba3e94900dd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b6d99e1c2dc9922faad6741f3735eba3e94900dd", "patch": "@@ -1,3 +1,61 @@\n+2015-07-09  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000-protos.h (rs6000_secondary_reload_memory):\n+\tUse machine mode, not enum machine_mode in the prototype.\n+\n+\t* config/rs6000/rs6000.h (FLOAT128_IEEE_P): New helper macros to\n+\tclassify 128-bit floating point support.\n+\t(FLOAT128_IBM_P): Likewise.\n+\t(FLOAT128_VECTOR_P): Likewise.\n+\t(FLOAT128_2REG_P): Likewise.\n+\t(SCALAR_FLOAT_MODE_NOT_VECTOR_P): Likewise.\n+\t(SLOW_UNALIGNED_ACCESS): Add IEEE 128-bit floating point support.\n+\t(HARD_REGNO_CALLER_SAVE_MODE): Likewise.\n+\t(HARD_REGNO_CALL_PART_CLOBBERED): Likewise.\n+\n+\t* config/rs6000/rs6000.c (rs6000_hard_regno_nregs_internal): Drop\n+\ttests against TFmode/TDmode, since those modes do not use VSX\n+\taddresses.\n+\t(rs6000_hard_regno_mode_ok): Add IEEE 128-bit floating point\n+\tsupport.\n+\t(rs6000_init_hard_regno_mode_ok): Use new helper macros instead of\n+\ttests against TFmode, etc.\n+\t(invalid_e500_subreg): Add tests against IFmode/KFmode.\n+\t(reg_offset_addressing_ok_p): Likewise.\n+\t(rs6000_legitimate_offset_address_p): Likewise.\n+\t(rs6000_legitimize_address): Likewise.\n+\t(rs6000_legitimize_reload_address): Likewise.\n+\t(rs6000_legitimate_address_p): Clean up tests against TFmode and\n+\tTDmode to use the new helper macros, which will include IFmode and\n+\tKFmode.\n+\t(rs6000_emit_move): Likewise.\n+\t(rs6000_darwin64_record_arg_recurse): Likewise.\n+\t(print_operand): Likewise.\n+\t(rs6000_member_type_forces_blk): Treat IEEE 128-bit floating point\n+\tthat uses a single vector register as a vector and not as a\n+\tfloating point register in terms of the calling sequence.\n+\t(rs6000_discover_homogeneous_aggregate): Likewise.\n+\t(rs6000_return_in_memory): Likewise.\n+\t(init_cumulative_args): Likewise.\n+\t(rs6000_function_arg_boundary): Likewise.\n+\t(rs6000_function_arg_advance_1): Likewise.\n+\t(rs6000_function_arg): Likewise.\n+\t(rs6000_pass_by_reference): Likewise.\n+\t(rs6000_gimplify_va_arg): Likewise.\n+\t(rs6000_secondary_reload_memory): Use machine_mode not enum\n+\tmachine mode.\n+\t(rs6000_split_multireg_move): Use new helper macros.\n+\t(spe_func_has_64bit_regs_p): Likewise.\n+\t(rs6000_output_function_epilogue): Add IFmode/KFmode support.\n+\t(output_toc): Use new helper macros.\n+\t(rs6000_register_move_cost): Likewise.\n+\t(rs6000_function_value): Add IEEE 128-bit floating point calling\n+\tsequence support.\n+\t(rs6000_libcall_value): Likewise.\n+\t(rs6000_scalar_mode_supported_p): Add support for IEEE 128-bit\n+\tfloating point support.\n+\t(rs6000_vector_mode_supported_p): Likewise.\n+\n 2015-07-09  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR rtl-optimization/66782"}]}