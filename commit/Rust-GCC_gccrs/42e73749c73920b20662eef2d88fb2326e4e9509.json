{"sha": "42e73749c73920b20662eef2d88fb2326e4e9509", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJlNzM3NDljNzM5MjBiMjA2NjJlZWYyZDg4ZmIyMzI2ZTRlOTUwOQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2006-02-06T18:48:38Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-02-06T18:48:38Z"}, "message": "trans-stmt.c (gfc_evaluate_where_mask): Allow the NMASK argument to be NULL to indicate that the not mask isn't required.\n\n\n\t* trans-stmt.c (gfc_evaluate_where_mask): Allow the NMASK argument\n\tto be NULL to indicate that the not mask isn't required.\n\t(gfc_trans_where_2): Remove PMASK argument.  Avoid calculating the\n\tpending mask for the last clause of a WHERE chain.  Update recursive\n\tcall.\n\t(gfc_trans_forall_1): Update call to gfc_trans_where_2.\n\t(gfc_trans_where): Likewise.\n\nFrom-SVN: r110659", "tree": {"sha": "c68395044c83ac4156edfdb53a7828421655f21c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c68395044c83ac4156edfdb53a7828421655f21c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42e73749c73920b20662eef2d88fb2326e4e9509", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42e73749c73920b20662eef2d88fb2326e4e9509", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42e73749c73920b20662eef2d88fb2326e4e9509", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42e73749c73920b20662eef2d88fb2326e4e9509/comments", "author": null, "committer": null, "parents": [{"sha": "4505055765863df3942fbef63dcc663be1b480c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4505055765863df3942fbef63dcc663be1b480c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4505055765863df3942fbef63dcc663be1b480c7"}], "stats": {"total": 88, "additions": 61, "deletions": 27}, "files": [{"sha": "9cffe66f0bc6f41a469a7d2722d7961b007086a6", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42e73749c73920b20662eef2d88fb2326e4e9509/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42e73749c73920b20662eef2d88fb2326e4e9509/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=42e73749c73920b20662eef2d88fb2326e4e9509", "patch": "@@ -1,3 +1,13 @@\n+2006-02-06  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* trans-stmt.c (gfc_evaluate_where_mask): Allow the NMASK argument\n+\tto be NULL to indicate that the not mask isn't required.\n+\t* trans-stmt.c (gfc_trans_where_2): Remove PMASK argument.  Avoid\n+\tcalculating the pending mask for the last clause of a WHERE chain.\n+\tUpdate call to trans_where\n+\t(gfc_trans_forall_1): Update call to gfc_trans_where_2.\n+\t(gfc_trans_where): Likewise.\n+\n 2006-02-06  Jakub Jelinek  <jakub@redhat.com>\n \n \tBackport from gomp-20050608-branch"}, {"sha": "d857f47bb40617bd52f019123587b7c7cf9b0f93", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 51, "deletions": 27, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42e73749c73920b20662eef2d88fb2326e4e9509/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42e73749c73920b20662eef2d88fb2326e4e9509/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=42e73749c73920b20662eef2d88fb2326e4e9509", "patch": "@@ -69,7 +69,7 @@ typedef struct forall_info\n }\n forall_info;\n \n-static void gfc_trans_where_2 (gfc_code *, tree, tree, forall_info *,\n+static void gfc_trans_where_2 (gfc_code *, tree, forall_info *,\n                                stmtblock_t *, temporary_list **temp);\n \n /* Translate a F95 label number to a LABEL_EXPR.  */\n@@ -2526,7 +2526,7 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n \n \t  /* Translate WHERE or WHERE construct nested in FORALL.  */\n           temp = NULL;\n-\t  gfc_trans_where_2 (c, NULL, NULL, nested_forall_info, &block, &temp);\n+\t  gfc_trans_where_2 (c, NULL, nested_forall_info, &block, &temp);\n \n           while (temp)\n             {\n@@ -2622,10 +2622,10 @@ tree gfc_trans_forall (gfc_code * code)\n    needed by the WHERE mask expression multiplied by the iterator number of\n    the nested forall.\n    ME is the WHERE mask expression.\n-   MASK is the temporary which value is mask's value.\n-   NMASK is another temporary which value is !mask.\n-   TEMP records the temporary's address allocated in this function in order to\n-   free them outside this function.\n+   MASK is the temporary whose value is mask's value.\n+   NMASK is another temporary whose value is !mask, or NULL if not required.\n+   TEMP records the temporary's address allocated in this function in order\n+   to free them outside this function.\n    MASK, NMASK and TEMP are all OUT arguments.  */\n \n static tree\n@@ -2670,18 +2670,23 @@ gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n       *temp = tempo;\n     }\n \n-  /* Allocate temporary for !mask.  */\n-  ntmp = allocate_temp_for_forall_nest_1 (mask_type, size, block, &ptemp2);\n-\n-  /* Record the temporary  in order to free it later.  */\n-  if (ptemp2)\n+  if (nmask)\n     {\n-      temporary_list *tempo;\n-      tempo = (temporary_list *) gfc_getmem (sizeof (temporary_list));\n-      tempo->temporary = ptemp2;\n-      tempo->next = *temp;\n-      *temp = tempo;\n+      /* Allocate temporary for !mask.  */\n+      ntmp = allocate_temp_for_forall_nest_1 (mask_type, size, block, &ptemp2);\n+\n+      /* Record the temporary  in order to free it later.  */\n+      if (ptemp2)\n+\t{\n+\t  temporary_list *tempo;\n+\t  tempo = (temporary_list *) gfc_getmem (sizeof (temporary_list));\n+\t  tempo->temporary = ptemp2;\n+\t  tempo->next = *temp;\n+\t  *temp = tempo;\n+\t}\n     }\n+  else\n+    ntmp = NULL_TREE;\n \n   /* Variable to index the temporary.  */\n   count = gfc_create_var (gfc_array_index_type, \"count\");\n@@ -2720,15 +2725,18 @@ gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n     }\n   /* Form the expression of the temporary.  */\n   lse.expr = gfc_build_array_ref (tmp, count);\n-  tmpexpr = gfc_build_array_ref (ntmp, count);\n \n   /* Use the scalar assignment to fill temporary TMP.  */\n   tmp1 = gfc_trans_scalar_assign (&lse, &rse, me->ts.type);\n   gfc_add_expr_to_block (&body1, tmp1);\n \n-  /* Fill temporary NTMP.  */\n-  tmp1 = build1 (TRUTH_NOT_EXPR, TREE_TYPE (lse.expr), lse.expr);\n-  gfc_add_modify_expr (&body1, tmpexpr, tmp1);\n+  if (nmask)\n+    {\n+      /* Fill temporary NTMP.  */\n+      tmp1 = build1 (TRUTH_NOT_EXPR, TREE_TYPE (lse.expr), lse.expr);\n+      tmpexpr = gfc_build_array_ref (ntmp, count);\n+      gfc_add_modify_expr (&body1, tmpexpr, tmp1);\n+    }\n \n  if (lss == gfc_ss_terminator)\n     {\n@@ -2760,7 +2768,8 @@ gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n   gfc_add_expr_to_block (block, tmp1);\n \n   *mask = tmp;\n-  *nmask = ntmp;\n+  if (nmask)\n+    *nmask = ntmp;\n \n   return tmp1;\n }\n@@ -2990,12 +2999,12 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2, tree mask,\n /* Translate the WHERE construct or statement.\n    This function can be called iteratively to translate the nested WHERE\n    construct or statement.\n-   MASK is the control mask, and PMASK is the pending control mask.\n+   MASK is the control mask.\n    TEMP records the temporary address which must be freed later.  */\n \n static void\n-gfc_trans_where_2 (gfc_code * code, tree mask, tree pmask,\n-                   forall_info * nested_forall_info, stmtblock_t * block,\n+gfc_trans_where_2 (gfc_code * code, tree mask,\n+\t\t   forall_info * nested_forall_info, stmtblock_t * block,\n                    temporary_list ** temp)\n {\n   gfc_expr *expr1;\n@@ -3006,6 +3015,10 @@ gfc_trans_where_2 (gfc_code * code, tree mask, tree pmask,\n   tree count1, count2;\n   tree mask_copy;\n   int need_temp;\n+  tree *tmp1_ptr;\n+  tree pmask;\n+\n+  pmask = NULL_TREE;\n \n   /* the WHERE statement or the WHERE construct statement.  */\n   cblock = code->block;\n@@ -3014,9 +3027,20 @@ gfc_trans_where_2 (gfc_code * code, tree mask, tree pmask,\n       /* Has mask-expr.  */\n       if (cblock->expr)\n         {\n+\t  /* If this is the last clause of the WHERE construct, then\n+\t     we don't need to allocate/populate/deallocate a complementary\n+\t     pending control mask (pmask).  */\n+\t  if (! cblock->block)\n+\t    {\n+\t      tmp1 = NULL_TREE;\n+\t      tmp1_ptr = NULL;\n+\t    }\n+\t  else\n+\t    tmp1_ptr = &tmp1;\n+\n           /* Ensure that the WHERE mask be evaluated only once.  */\n           tmp2 = gfc_evaluate_where_mask (cblock->expr, nested_forall_info,\n-                                          &tmp, &tmp1, temp, block);\n+                                          &tmp, tmp1_ptr, temp, block);\n \n           /* Set the control mask and the pending control mask.  */\n           /* It's a where-stmt.  */\n@@ -3102,7 +3126,7 @@ gfc_trans_where_2 (gfc_code * code, tree mask, tree pmask,\n             case EXEC_WHERE:\n               /* Ensure that MASK is not modified by next gfc_trans_where_2.  */\n               mask_copy = copy_list (mask);\n-              gfc_trans_where_2 (cnext, mask_copy, NULL, nested_forall_info,\n+              gfc_trans_where_2 (cnext, mask_copy, nested_forall_info,\n                                  block, temp);\n               break;\n \n@@ -3311,7 +3335,7 @@ gfc_trans_where (gfc_code * code)\n   gfc_start_block (&block);\n   temp = NULL;\n \n-  gfc_trans_where_2 (code, NULL, NULL, NULL, &block, &temp);\n+  gfc_trans_where_2 (code, NULL, NULL, &block, &temp);\n \n   /* Add calls to free temporaries which were dynamically allocated.  */\n   while (temp)"}]}