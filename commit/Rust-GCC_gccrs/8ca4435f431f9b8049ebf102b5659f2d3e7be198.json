{"sha": "8ca4435f431f9b8049ebf102b5659f2d3e7be198", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNhNDQzNWY0MzFmOWI4MDQ5ZWJmMTAyYjU2NTlmMmQzZTdiZTE5OA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-01-13T22:38:19Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-01-14T01:30:18Z"}, "message": "\tPR c++/92582 - ICE with member template as requirement.\n\nHere, we weren't recognizing that the template parameter of A is used by the\nreference to d in the requires-clause of f.  Fixed by passing down the\nactive template parameters in the context of normalization, and adding to\nthe mapping any such parameters shared by a member template used in the\nconstraint-expression.\n\n\t* pt.c (struct find_template_parameter_info): Add ctx_parms.\n\t(any_template_parm_r): Handle TEMPLATE_DECL.\n\t(find_template_parameters): Take parms instead of their depth.\n\t* constraint.cc (build_parameter_mapping): Pass them.", "tree": {"sha": "577caca36cad64bb399b2dd2efec17d348921b36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/577caca36cad64bb399b2dd2efec17d348921b36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ca4435f431f9b8049ebf102b5659f2d3e7be198", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ca4435f431f9b8049ebf102b5659f2d3e7be198", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ca4435f431f9b8049ebf102b5659f2d3e7be198", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ca4435f431f9b8049ebf102b5659f2d3e7be198/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1ba88b1b20cb579b3b7ce6ce65470205742be7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1ba88b1b20cb579b3b7ce6ce65470205742be7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1ba88b1b20cb579b3b7ce6ce65470205742be7e"}], "stats": {"total": 68, "additions": 57, "deletions": 11}, "files": [{"sha": "59646c70fa465d7bf640b674693fb2ad9038899b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca4435f431f9b8049ebf102b5659f2d3e7be198/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca4435f431f9b8049ebf102b5659f2d3e7be198/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8ca4435f431f9b8049ebf102b5659f2d3e7be198", "patch": "@@ -1,5 +1,11 @@\n 2020-01-13  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/92582 - ICE with member template as requirement.\n+\t* pt.c (struct find_template_parameter_info): Add ctx_parms.\n+\t(any_template_parm_r): Handle TEMPLATE_DECL.\n+\t(find_template_parameters): Take parms instead of their depth.\n+\t* constraint.cc (build_parameter_mapping): Pass them.\n+\n \tPR c++/33799 - destroy return value if local cleanup throws.\n \t* cp-tree.h (current_retval_sentinel): New macro.\n \t* decl.c (start_preparsed_function): Set up cleanup for retval."}, {"sha": "128ab8ae0b21b6171412a9e798d5b9905577e61f", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca4435f431f9b8049ebf102b5659f2d3e7be198/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca4435f431f9b8049ebf102b5659f2d3e7be198/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=8ca4435f431f9b8049ebf102b5659f2d3e7be198", "patch": "@@ -559,23 +559,22 @@ map_arguments (tree parms, tree args)\n static tree\n build_parameter_mapping (tree expr, tree args, tree decl)\n {\n-  int depth = 0;\n+  tree ctx_parms = NULL_TREE;\n   if (decl)\n     {\n       gcc_assert (TREE_CODE (decl) == TEMPLATE_DECL);\n-      tree parms = DECL_TEMPLATE_PARMS (decl);\n-      depth = TREE_INT_CST_LOW (TREE_PURPOSE (parms));\n+      ctx_parms = DECL_TEMPLATE_PARMS (decl);\n     }\n   else if (current_template_parms)\n     {\n       /* TODO: This should probably be the only case, but because the\n \t point of declaration of concepts is currently set after the\n \t initializer, the template parameter lists are not available\n \t when normalizing concept definitions, hence the case above.  */\n-      depth = TMPL_PARMS_DEPTH (current_template_parms);\n+      ctx_parms = current_template_parms;\n     }\n \n-  tree parms = find_template_parameters (expr, depth);\n+  tree parms = find_template_parameters (expr, ctx_parms);\n   tree map = map_arguments (parms, args);\n   return map;\n }"}, {"sha": "01fcf663a29446edb05d68c486d8e91e7809aa56", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca4435f431f9b8049ebf102b5659f2d3e7be198/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca4435f431f9b8049ebf102b5659f2d3e7be198/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8ca4435f431f9b8049ebf102b5659f2d3e7be198", "patch": "@@ -7865,7 +7865,7 @@ extern bool constraints_satisfied_p\t\t(tree, tree);\n extern void clear_satisfaction_cache\t\t();\n extern bool* lookup_subsumption_result          (tree, tree);\n extern bool save_subsumption_result             (tree, tree, bool);\n-extern tree find_template_parameters\t\t(tree, int);\n+extern tree find_template_parameters\t\t(tree, tree);\n extern bool equivalent_constraints              (tree, tree);\n extern bool equivalently_constrained            (tree, tree);\n extern bool subsumes_constraints                (tree, tree);"}, {"sha": "fa82ecad233ffe904d4f9a3cd10d224250187778", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca4435f431f9b8049ebf102b5659f2d3e7be198/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca4435f431f9b8049ebf102b5659f2d3e7be198/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=8ca4435f431f9b8049ebf102b5659f2d3e7be198", "patch": "@@ -10364,12 +10364,14 @@ for_each_template_parm (tree t, tree_fn_t fn, void* data,\n \n struct find_template_parameter_info\n {\n-  explicit find_template_parameter_info (int d)\n-    : max_depth (d)\n+  explicit find_template_parameter_info (tree ctx_parms)\n+    : ctx_parms (ctx_parms),\n+      max_depth (TMPL_PARMS_DEPTH (ctx_parms))\n   {}\n \n   hash_set<tree> visited;\n   hash_set<tree> parms;\n+  tree ctx_parms;\n   int max_depth;\n };\n \n@@ -10459,6 +10461,29 @@ any_template_parm_r (tree t, void *data)\n       WALK_SUBTREE (TREE_TYPE (t));\n       break;\n \n+    case TEMPLATE_DECL:\n+      {\n+\t/* If T is a member template that shares template parameters with\n+\t   ctx_parms, we need to mark all those parameters for mapping.  */\n+\ttree dparms = DECL_TEMPLATE_PARMS (t);\n+\ttree cparms = ftpi->ctx_parms;\n+\twhile (TMPL_PARMS_DEPTH (dparms) > ftpi->max_depth)\n+\t  dparms = TREE_CHAIN (dparms);\n+\twhile (dparms\n+\t       && (TREE_TYPE (TREE_VALUE (dparms))\n+\t\t   != TREE_TYPE (TREE_VALUE (cparms))))\n+\t  dparms = TREE_CHAIN (dparms),\n+\t    cparms = TREE_CHAIN (cparms);\n+\tif (dparms)\n+\t  {\n+\t    int ddepth = TMPL_PARMS_DEPTH (dparms);\n+\t    tree dargs = TI_ARGS (get_template_info (DECL_TEMPLATE_RESULT (t)));\n+\t    for (int i = 0; i < ddepth; ++i)\n+\t      WALK_SUBTREE (TMPL_ARGS_LEVEL (dargs, i+1));\n+\t  }\n+      }\n+      break;\n+\n     default:\n       break;\n     }\n@@ -10467,12 +10492,16 @@ any_template_parm_r (tree t, void *data)\n   return 0;\n }\n \n-/* Returns a list of unique template parameters found within T.  */\n+/* Returns a list of unique template parameters found within T, where CTX_PARMS\n+   are the template parameters in scope.  */\n \n tree\n-find_template_parameters (tree t, int depth)\n+find_template_parameters (tree t, tree ctx_parms)\n {\n-  find_template_parameter_info ftpi (depth);\n+  if (!ctx_parms)\n+    return NULL_TREE;\n+\n+  find_template_parameter_info ftpi (ctx_parms);\n   for_each_template_parm (t, keep_template_parm, &ftpi, &ftpi.visited,\n \t\t\t  /*include_nondeduced*/true, any_template_parm_r);\n   tree list = NULL_TREE;"}, {"sha": "353937b060cff97106ddc92d7fa63678bfb85978", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-memtmpl3.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca4435f431f9b8049ebf102b5659f2d3e7be198/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-memtmpl3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca4435f431f9b8049ebf102b5659f2d3e7be198/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-memtmpl3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-memtmpl3.C?ref=8ca4435f431f9b8049ebf102b5659f2d3e7be198", "patch": "@@ -0,0 +1,12 @@\n+// PR c++/92582\n+// { dg-do compile { target concepts } }\n+\n+template <class a, class> concept b = true;\n+template <typename> struct A {\n+  template <typename c> static constexpr bool d = b<c, int>;\n+  template <typename c> static void f(c) requires d<c>;\n+};\n+int main()\n+{\n+  A<void>::f(0);\n+}"}]}