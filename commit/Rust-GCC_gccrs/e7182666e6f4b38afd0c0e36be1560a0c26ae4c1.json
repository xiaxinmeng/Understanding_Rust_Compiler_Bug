{"sha": "e7182666e6f4b38afd0c0e36be1560a0c26ae4c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTcxODI2NjZlNmY0YjM4YWZkMGMwZTM2YmUxNTYwYTBjMjZhZTRjMQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-03-14T19:35:08Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-03-14T19:35:08Z"}, "message": "cppfiles.c (stack_include_file): Only increase the include count if we actually process the file properly...\n\n        * cppfiles.c (stack_include_file): Only increase the include\n\tcount if we actually process the file properly, as opposed\n\tto treating it as length zero.  Only call read_include_file\n\tif not DO_NOT_REREAD.  Handle the -H include file output\n\there.\n\t(read_include_file): Remove now redundant DO_NOT_REREAD check.\n\t(cpp_included, find_include_file): Simplify pathnames after\n\tremapping them.  If remapping, don't use the remapped file\n\tname's buffer as our scratch buffer.\n\t(cpp_pop_file_buffer): Replace the multiple include macro\n\tonly if it isn't yet set.\n\t(read_name_map): Simplify remapped names when reading in.\n\t(remap_filename): Move code to code path that uses it.\n\t(_cpp_simplify_pathname): Return the input pointer.\n\t* cpphash.h (_cpp_simplify_pathname): Update prototype.\n\nFrom-SVN: r40467", "tree": {"sha": "89ee63cfa3141e40d8e17c5c20b7ea0f80c0f8bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89ee63cfa3141e40d8e17c5c20b7ea0f80c0f8bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7182666e6f4b38afd0c0e36be1560a0c26ae4c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7182666e6f4b38afd0c0e36be1560a0c26ae4c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7182666e6f4b38afd0c0e36be1560a0c26ae4c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7182666e6f4b38afd0c0e36be1560a0c26ae4c1/comments", "author": null, "committer": null, "parents": [{"sha": "f80022ff3df97a3f8f47e32ad22b989c7c70c00b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f80022ff3df97a3f8f47e32ad22b989c7c70c00b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f80022ff3df97a3f8f47e32ad22b989c7c70c00b"}], "stats": {"total": 133, "additions": 75, "deletions": 58}, "files": [{"sha": "f7450b386721074ed29933fcc7c3a9808e534f33", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7182666e6f4b38afd0c0e36be1560a0c26ae4c1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7182666e6f4b38afd0c0e36be1560a0c26ae4c1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e7182666e6f4b38afd0c0e36be1560a0c26ae4c1", "patch": "@@ -1,3 +1,21 @@\n+2001-03-14  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+        * cppfiles.c (stack_include_file): Only increase the include\n+\tcount if we actually process the file properly, as opposed\n+\tto treating it as length zero.  Only call read_include_file\n+\tif not DO_NOT_REREAD.  Handle the -H include file output\n+\there.\n+\t(read_include_file): Remove now redundant DO_NOT_REREAD check.\n+\t(cpp_included, find_include_file): Simplify pathnames after\n+\tremapping them.  If remapping, don't use the remapped file\n+\tname's buffer as our scratch buffer.\n+\t(cpp_pop_file_buffer): Replace the multiple include macro\n+\tonly if it isn't yet set.\n+\t(read_name_map): Simplify remapped names when reading in.\n+\t(remap_filename): Move code to code path that uses it.\n+\t(_cpp_simplify_pathname): Return the input pointer.\n+\t* cpphash.h (_cpp_simplify_pathname): Update prototype.\n+\n 2001-03-14  Mark Mitchell  <mark@codesourcery.com>\n \n \t* expr.c (expand_expr): Revove bogus conditional."}, {"sha": "62c3e8629126c39d6e2cf32456e97839ee8d550d", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 56, "deletions": 57, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7182666e6f4b38afd0c0e36be1560a0c26ae4c1/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7182666e6f4b38afd0c0e36be1560a0c26ae4c1/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=e7182666e6f4b38afd0c0e36be1560a0c26ae4c1", "patch": "@@ -261,7 +261,7 @@ open_file (pfile, filename)\n \n /* Place the file referenced by INC into a new buffer on PFILE's\n    stack.  If there are errors, or the file should not be re-included,\n-   a null buffer is pushed.  */\n+   a null (zero-length) buffer is pushed.  */\n \n static void\n stack_include_file (pfile, inc)\n@@ -281,16 +281,27 @@ stack_include_file (pfile, inc)\n   if (CPP_OPTION (pfile, print_deps) > deps_sysp && !inc->include_count)\n     deps_add_dep (pfile->deps, inc->name);\n \n-  /* We don't want multiple include guard advice for the main file.  */\n-  if (pfile->buffer)\n-    inc->include_count++;\n+  if (! DO_NOT_REREAD (inc))\n+    {\n+      /* Not in cache?  */\n+      if (! inc->buffer)\n+\tread_include_file (pfile, inc);\n+      len = inc->st.st_size;\n \n-  /* Not in cache?  */\n-  if (! inc->buffer)\n-    read_include_file (pfile, inc);\n+      if (pfile->buffer)\n+\t{\n+\t  /* We don't want MI guard advice for the main file.  */\n+\t  inc->include_count++;\n \n-  if (! DO_NOT_REREAD (inc))\n-    len = inc->st.st_size;\n+\t  /* Handle -H option.  */\n+\t  if (CPP_OPTION (pfile, print_include_names))\n+\t    {\n+\t      for (fp = pfile->buffer; fp; fp = fp->prev)\n+\t\tputc ('.', stderr);\n+\t      fprintf (stderr, \" %s\\n\", inc->name);\n+\t    }\n+\t}\n+    }\n \n   /* Push a buffer.  */\n   fp = cpp_push_buffer (pfile, inc->buffer, len, BUF_FILE, inc->name);\n@@ -336,9 +347,6 @@ read_include_file (pfile, inc)\n   static int pagesize = -1;\n #endif\n \n-  if (DO_NOT_REREAD (inc))\n-    return;\n-\n   if (S_ISREG (inc->st.st_mode))\n     {\n       /* off_t might have a wider range than ssize_t - in other words,\n@@ -459,7 +467,7 @@ cpp_included (pfile, fname)\n      const char *fname;\n {\n   struct search_path *path;\n-  char *name;\n+  char *name, *n;\n   splay_tree_node nd;\n \n   if (IS_ABSOLUTE_PATHNAME (fname))\n@@ -476,11 +484,12 @@ cpp_included (pfile, fname)\n       memcpy (name, path->name, path->len);\n       name[path->len] = '/';\n       strcpy (&name[path->len + 1], fname);\n-      _cpp_simplify_pathname (name);\n       if (CPP_OPTION (pfile, remap))\n-\tname = remap_filename (pfile, name, path);\n+\tn = remap_filename (pfile, name, path);\n+      else\n+\tn = _cpp_simplify_pathname (name);\n \n-      nd = splay_tree_lookup (pfile->all_include_files, (splay_tree_key) name);\n+      nd = splay_tree_lookup (pfile->all_include_files, (splay_tree_key) n);\n       if (nd && nd->value)\n \treturn 1;\n     }\n@@ -502,15 +511,14 @@ find_include_file (pfile, header, include_next)\n   const char *fname = (const char *) header->val.str.text;\n   struct search_path *path;\n   struct include_file *file;\n-  char *name;\n+  char *name, *n;\n \n   if (IS_ABSOLUTE_PATHNAME (fname))\n     return open_file (pfile, fname);\n \n   /* For #include_next, skip in the search path past the dir in which\n-     the current file was found.  If this is the last directory in the\n-     search path, don't include anything.  If the current file was\n-     specified with an absolute path, use the normal search logic.  */\n+     the current file was found, but if it was found via an absolute\n+     path use the normal search logic.  */\n   if (include_next && pfile->buffer->inc->foundhere)\n     path = pfile->buffer->inc->foundhere->next;\n   else if (header->type == CPP_HEADER_NAME)\n@@ -531,11 +539,12 @@ find_include_file (pfile, header, include_next)\n       memcpy (name, path->name, path->len);\n       name[path->len] = '/';\n       strcpy (&name[path->len + 1], fname);\n-      _cpp_simplify_pathname (name);\n       if (CPP_OPTION (pfile, remap))\n-\tname = remap_filename (pfile, name, path);\n+\tn = remap_filename (pfile, name, path);\n+      else\n+\tn = _cpp_simplify_pathname (name);\n \n-      file = open_file (pfile, name);\n+      file = open_file (pfile, n);\n       if (file)\n \t{\n \t  file->foundhere = path;\n@@ -632,14 +641,14 @@ handle_missing_header (pfile, fname, angle_brackets)\n \t  deps_add_dep (pfile->deps, p);\n \t}\n     }\n-  /* If -M was specified, and this header file won't be added to\n-     the dependency list, then don't count this as an error,\n-     because we can still produce correct output.  Otherwise, we\n-     can't produce correct output, because there may be\n-     dependencies we need inside the missing file, and we don't\n-     know what directory this missing file exists in. */\n+  /* If -M was specified, then don't count this as an error, because\n+     we can still produce correct output.  Otherwise, we can't produce\n+     correct output, because there may be dependencies we need inside\n+     the missing file, and we don't know what directory this missing\n+     file exists in.  FIXME: Use a future cpp_diagnotic_with_errno ()\n+     for both of these cases.  */\n   else if (CPP_PRINT_DEPS (pfile) && ! print_dep)\n-    cpp_warning (pfile, \"No include path in which to find %s\", fname);\n+    cpp_warning (pfile, \"%s: %s\", fname, xstrerror (errno));\n   else\n     cpp_error_from_errno (pfile, fname);\n }\n@@ -679,20 +688,8 @@ _cpp_execute_include (pfile, header, no_reinclude, include_next)\n \n       stack_include_file (pfile, inc);\n \n-      if (! DO_NOT_REREAD (inc))\n-\t{\n-\t  if (no_reinclude)\n-\t    _cpp_never_reread (inc);\n-\n-\t  /* Handle -H option.  */\n-\t  if (CPP_OPTION (pfile, print_include_names))\n-\t    {\n-\t      cpp_buffer *fp = pfile->buffer;\n-\t      while ((fp = fp->prev) != NULL)\n-\t\tputc ('.', stderr);\n-\t      fprintf (stderr, \" %s\\n\", inc->name);\n-\t    }\n-\t}\n+      if (no_reinclude)\n+\t_cpp_never_reread (inc);\n     }\n }\n \n@@ -753,7 +750,7 @@ _cpp_pop_file_buffer (pfile, buf)\n     pfile->include_depth--;\n \n   /* Record the inclusion-preventing macro and its definedness.  */\n-  if (pfile->mi_state == MI_OUTSIDE && inc->cmacro != NEVER_REREAD)\n+  if (pfile->mi_state == MI_OUTSIDE && inc->cmacro == NULL)\n     {\n       /* This could be NULL meaning no controlling macro.  */\n       inc->cmacro = pfile->mi_cmacro;\n@@ -931,6 +928,8 @@ read_name_map (pfile, dirname)\n \t      strcpy (ptr->map_to + dirlen + 1, to);\n \t      free (to);\n \t    }\t      \n+\t  /* Simplify the result now.  */\n+\t  _cpp_simplify_pathname (ptr->map_to);\n \n \t  ptr->map_next = map_list_ptr->map_list_map;\n \t  map_list_ptr->map_list_map = ptr;\n@@ -949,8 +948,8 @@ read_name_map (pfile, dirname)\n   return map_list_ptr->map_list_map;\n }  \n \n-/* Remap NAME based on the file_name_map (if any) for LOC. */\n-\n+/* Remap an unsimplified path NAME based on the file_name_map (if any)\n+   for LOC.  */\n static char *\n remap_filename (pfile, name, loc)\n      cpp_reader *pfile;\n@@ -959,21 +958,21 @@ remap_filename (pfile, name, loc)\n {\n   struct file_name_map *map;\n   const char *from, *p;\n-  char *dir, *dname;\n-\n-  /* Get a null-terminated path.  */\n-  dname = alloca (loc->len + 1);\n-  memcpy (dname, loc->name, loc->len);\n-  dname[loc->len] = '\\0';\n+  char *dir;\n \n   if (! loc->name_map)\n     {\n+      /* Get a null-terminated path.  */\n+      char *dname = alloca (loc->len + 1);\n+      memcpy (dname, loc->name, loc->len);\n+      dname[loc->len] = '\\0';\n+\n       loc->name_map = read_name_map (pfile, dname);\n       if (! loc->name_map)\n \treturn name;\n     }\n   \n-  /* FIXME: this doesn't look right - NAME has been simplified.  */\n+  /* This works since NAME has not been simplified yet.  */\n   from = name + loc->len + 1;\n   \n   for (map = loc->name_map; map; map = map->map_next)\n@@ -1016,9 +1015,9 @@ remap_filename (pfile, name, loc)\n    //quux\t\t//quux  (POSIX allows leading // as a namespace escape)\n \n    Guarantees no trailing slashes. All transforms reduce the length\n-   of the string.\n+   of the string.  Returns PATH;\n  */\n-void\n+char *\n _cpp_simplify_pathname (path)\n     char *path;\n {\n@@ -1134,5 +1133,5 @@ _cpp_simplify_pathname (path)\n     \n     *to = '\\0';\n \n-    return;\n+    return path;\n }"}, {"sha": "5d452c38661e338ee2a74e084bbee361f16e2c4e", "filename": "gcc/cpphash.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7182666e6f4b38afd0c0e36be1560a0c26ae4c1/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7182666e6f4b38afd0c0e36be1560a0c26ae4c1/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=e7182666e6f4b38afd0c0e36be1560a0c26ae4c1", "patch": "@@ -409,7 +409,7 @@ extern cpp_hashnode *_cpp_lookup_with_hash PARAMS ((cpp_reader*, size_t,\n /* In cppfiles.c */\n extern void _cpp_fake_include\t\tPARAMS ((cpp_reader *, const char *));\n extern void _cpp_never_reread\t\tPARAMS ((struct include_file *));\n-extern void _cpp_simplify_pathname\tPARAMS ((char *));\n+extern char *_cpp_simplify_pathname\tPARAMS ((char *));\n extern int _cpp_read_file\t\tPARAMS ((cpp_reader *, const char *));\n extern void _cpp_execute_include\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t const cpp_token *, int, int));"}]}