{"sha": "3cf3da88be453f3fceaa596ee78be8d1e5aa21ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NmM2RhODhiZTQ1M2YzZmNlYWE1OTZlZTc4YmU4ZDFlNWFhMjFjYQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-11-06T10:57:18Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2019-11-06T10:57:18Z"}, "message": "introduce -fcallgraph-info option\n\nThis was first submitted many years ago\nhttps://gcc.gnu.org/ml/gcc-patches/2010-10/msg02468.html\n\nThe command line option -fcallgraph-info is added and makes the\ncompiler generate another output file (xxx.ci) for each compilation\nunit (or LTO partitoin), which is a valid VCG file (you can launch\nyour favorite VCG viewer on it unmodified) and contains the \"final\"\ncallgraph of the unit.  \"final\" is a bit of a misnomer as this is\nactually the callgraph at RTL expansion time, but since most\nhigh-level optimizations are done at the Tree level and RTL doesn't\nusually fiddle with calls, it's final in almost all cases.  Moreover,\nthe nodes can be decorated with additional info: -fcallgraph-info=su\nadds stack usage info and -fcallgraph-info=da dynamic allocation info.\n\n\nfor  gcc/ChangeLog\nFrom  Eric Botcazou  <ebotcazou@adacore.com>, Alexandre Oliva  <oliva@adacore.com>\n\n\t* common.opt (-fcallgraph-info[=]): New option.\n\t* doc/invoke.texi (Developer options): Document it.\n\t* opts.c (common_handle_option): Handle it.\n\t* builtins.c (expand_builtin_alloca): Record allocation if\n\t-fcallgraph-info=da.\n\t* calls.c (expand_call): If -fcallgraph-info, record the call.\n\t(emit_library_call_value_1): Likewise.\n\t* flag-types.h (enum callgraph_info_type): New type.\n\t* explow.c: Include stringpool.h.\n\t(set_stack_check_libfunc): Set SET_SYMBOL_REF_DECL on the symbol.\n\t* function.c (allocate_stack_usage_info): New.\n\t(allocate_struct_function): Call it for -fcallgraph-info.\n\t(prepare_function_start): Call it otherwise.\n\t(record_final_call, record_dynamic_alloc): New.\n\t* function.h (struct callinfo_callee): New.\n\t(CALLEE_FROM_CGRAPH_P): New.\n\t(struct callinfo_dalloc): New.\n\t(struct stack_usage): Add callees and dallocs.\n\t(record_final_call, record_dynamic_alloc): Declare.\n\t* gimplify.c (gimplify_decl_expr): Record dynamically-allocated\n\tobject if -fcallgraph-info=da.\n\t* optabs-libfuncs.c (build_libfunc_function): Keep SYMBOL_REF_DECL.\n\t* print-tree.h (print_decl_identifier): Declare.\n\t(PRINT_DECL_ORIGIN, PRINT_DECL_NAME, PRINT_DECL_UNIQUE_NAME): New.\n\t* print-tree.c: Include print-tree.h.\n\t(print_decl_identifier): New function.\n\t* toplev.c: Include print-tree.h.\n\t(callgraph_info_file): New global variable.\n\t(callgraph_info_external_printed): Likewise.\n\t(output_stack_usage): Rename to...\n\t(output_stack_usage_1): ... this.  Make it static, add cf\n\tparameter.  If -fcallgraph-info=su, print stack usage to cf.\n\tIf -fstack-usage, use print_decl_identifier for\n\tpretty-printing.\n\t(INDIRECT_CALL_NAME): New.\n\t(dump_final_node_vcg_start): New.\n\t(dump_final_callee_vcg, dump_final_node_vcg): New.\n\t(output_stack_usage): New.\n\t(lang_dependent_init): Open and start file if\n\t-fcallgraph-info.  Allocated callgraph_info_external_printed.\n\t(finalize): If callgraph_info_file is not null, finish it,\n\tclose it, and release callgraph_info_external_printed.\n\nfor  gcc/ada/ChangeLog\n\n\t* gcc-interface/misc.c (callgraph_info_file): Delete.\n\nCo-Authored-By: Alexandre Oliva <oliva@adacore.com>\n\nFrom-SVN: r277876", "tree": {"sha": "ead0ae87adfe46ab5e364107f3cfe9d60d9d3761", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ead0ae87adfe46ab5e364107f3cfe9d60d9d3761"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/comments", "author": null, "committer": null, "parents": [{"sha": "5d183d1740d8d8b84991f186ce4d992ee799536f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d183d1740d8d8b84991f186ce4d992ee799536f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d183d1740d8d8b84991f186ce4d992ee799536f"}], "stats": {"total": 501, "additions": 449, "deletions": 52}, "files": [{"sha": "897b494517291867e8b3830307c23253a14664bc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3cf3da88be453f3fceaa596ee78be8d1e5aa21ca", "patch": "@@ -1,3 +1,49 @@\n+2019-11-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\t    Alexandre Oliva  <oliva@adacore.com>\n+\n+\t* common.opt (-fcallgraph-info[=]): New option.\n+\t* doc/invoke.texi (Developer options): Document it.\n+\t* opts.c (common_handle_option): Handle it.\n+\t* builtins.c (expand_builtin_alloca): Record allocation if\n+\t-fcallgraph-info=da.\n+\t* calls.c (expand_call): If -fcallgraph-info, record the call.\n+\t(emit_library_call_value_1): Likewise.\n+\t* flag-types.h (enum callgraph_info_type): New type.\n+\t* explow.c: Include stringpool.h.\n+\t(set_stack_check_libfunc): Set SET_SYMBOL_REF_DECL on the symbol.\n+\t* function.c (allocate_stack_usage_info): New.\n+\t(allocate_struct_function): Call it for -fcallgraph-info.\n+\t(prepare_function_start): Call it otherwise.\n+\t(record_final_call, record_dynamic_alloc): New.\n+\t* function.h (struct callinfo_callee): New.\n+\t(CALLEE_FROM_CGRAPH_P): New.\n+\t(struct callinfo_dalloc): New.\n+\t(struct stack_usage): Add callees and dallocs.\n+\t(record_final_call, record_dynamic_alloc): Declare.\n+\t* gimplify.c (gimplify_decl_expr): Record dynamically-allocated\n+\tobject if -fcallgraph-info=da.\n+\t* optabs-libfuncs.c (build_libfunc_function): Keep SYMBOL_REF_DECL.\n+\t* print-tree.h (print_decl_identifier): Declare.\n+\t(PRINT_DECL_ORIGIN, PRINT_DECL_NAME, PRINT_DECL_UNIQUE_NAME): New.\n+\t* print-tree.c: Include print-tree.h.\n+\t(print_decl_identifier): New function.\n+\t* toplev.c: Include print-tree.h.\n+\t(callgraph_info_file): New global variable.\n+\t(callgraph_info_external_printed): Likewise.\n+\t(output_stack_usage): Rename to...\n+\t(output_stack_usage_1): ... this.  Make it static, add cf\n+\tparameter.  If -fcallgraph-info=su, print stack usage to cf.\n+\tIf -fstack-usage, use print_decl_identifier for\n+\tpretty-printing.\n+\t(INDIRECT_CALL_NAME): New.\n+\t(dump_final_node_vcg_start): New.\n+\t(dump_final_callee_vcg, dump_final_node_vcg): New.\n+\t(output_stack_usage): New.\n+\t(lang_dependent_init): Open and start file if\n+\t-fcallgraph-info.  Allocated callgraph_info_external_printed.\n+\t(finalize): If callgraph_info_file is not null, finish it,\n+\tclose it, and release callgraph_info_external_printed.\n+\n 2019-11-06  Gerg\u00f6 Barany  <gergo@codesourcery.com>\n \t    Frederik Harwath  <frederik@codesourcery.com>\n \t    Thomas Schwinge  <thomas@codesourcery.com>\n@@ -7,7 +53,7 @@\n \t(new_omp_context): Initialize these.\n \t(scan_sharing_clauses): Record reduction clauses on OpenACC constructs.\n \t(scan_omp_for): Check reduction clauses for incorrect nesting.\n-\t\n+\n 2019-11-06  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR inline-asm/92352"}, {"sha": "c69910c97cc4a1ab135fc553b6f44a2fde2d1f22", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3cf3da88be453f3fceaa596ee78be8d1e5aa21ca", "patch": "@@ -1,3 +1,8 @@\n+2019-11-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\t    Alexandre Oliva  <oliva@adacore.com>\n+\n+\t* gcc-interface/misc.c (callgraph_info_file): Delete.\n+\n 2019-10-27  Jakub Jelinek  <jakub@redhat.com>\n \n \t* locales.c (iso_3166): Add missing comma after \"United-States\"."}, {"sha": "d68b37384ff7f2682f81e4a371afa998e4d7a1b4", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=3cf3da88be453f3fceaa596ee78be8d1e5aa21ca", "patch": "@@ -54,9 +54,6 @@\n #include \"ada-tree.h\"\n #include \"gigi.h\"\n \n-/* This symbol needs to be defined for the front-end.  */\n-void *callgraph_info_file = NULL;\n-\n /* Command-line argc and argv.  These variables are global since they are\n    imported in back_end.adb.  */\n unsigned int save_argc;"}, {"sha": "245fad02d9c6638c0aae47d2ef31150fb7b342d8", "filename": "gcc/builtins.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=3cf3da88be453f3fceaa596ee78be8d1e5aa21ca", "patch": "@@ -5407,6 +5407,10 @@ expand_builtin_alloca (tree exp)\n     = allocate_dynamic_stack_space (op0, 0, align, max_size, alloca_for_var);\n   result = convert_memory_address (ptr_mode, result);\n \n+  /* Dynamic allocations for variables are recorded during gimplification.  */\n+  if (!alloca_for_var && (flag_callgraph_info & CALLGRAPH_INFO_DYNAMIC_ALLOC))\n+    record_dynamic_alloc (exp);\n+\n   return result;\n }\n "}, {"sha": "62921351b112c7fdd9004924fd44a854c0763da7", "filename": "gcc/calls.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=3cf3da88be453f3fceaa596ee78be8d1e5aa21ca", "patch": "@@ -3759,6 +3759,9 @@ expand_call (tree exp, rtx target, int ignore)\n \n   preferred_unit_stack_boundary = preferred_stack_boundary / BITS_PER_UNIT;\n \n+  if (flag_callgraph_info)\n+    record_final_call (fndecl, EXPR_LOCATION (exp));\n+\n   /* We want to make two insn chains; one for a sibling call, the other\n      for a normal call.  We will select one of the two chains after\n      initial RTL generation is complete.  */\n@@ -5343,6 +5346,9 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \n   before_call = get_last_insn ();\n \n+  if (flag_callgraph_info)\n+    record_final_call (SYMBOL_REF_DECL (orgfun), UNKNOWN_LOCATION);\n+\n   /* We pass the old value of inhibit_defer_pop + 1 to emit_call_1, which\n      will set inhibit_defer_pop to that value.  */\n   /* The return type is needed to decide how many bytes the function pops."}, {"sha": "12c0083964ec2e192ba739e23cea53e4df85f869", "filename": "gcc/common.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=3cf3da88be453f3fceaa596ee78be8d1e5aa21ca", "patch": "@@ -1093,6 +1093,14 @@ fbtr-bb-exclusive\n Common Ignore\n Does nothing.  Preserved for backward compatibility.\n \n+fcallgraph-info\n+Common Report RejectNegative Var(flag_callgraph_info) Init(NO_CALLGRAPH_INFO);\n+Output callgraph information on a per-file basis.\n+\n+fcallgraph-info=\n+Common Report RejectNegative Joined\n+Output callgraph information on a per-file basis with decorations.\n+\n fcall-saved-\n Common Joined RejectNegative Var(common_deferred_options) Defer\n -fcall-saved-<register>\tMark <register> as being preserved across functions."}, {"sha": "227ad27390e63b613d55c49c6d885b7fcbc88e9b", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=3cf3da88be453f3fceaa596ee78be8d1e5aa21ca", "patch": "@@ -584,8 +584,9 @@ Objective-C and Objective-C++ Dialects}.\n @item Developer Options\n @xref{Developer Options,,GCC Developer Options}.\n @gccoptlist{-d@var{letters}  -dumpspecs  -dumpmachine  -dumpversion @gol\n--dumpfullversion  -fchecking  -fchecking=@var{n}  -fdbg-cnt-list @gol\n--fdbg-cnt=@var{counter-value-list} @gol\n+-dumpfullversion  -fcallgraph-info@r{[}=su,da@r{]}\n+-fchecking  -fchecking=@var{n}\n+-fdbg-cnt-list @gol  -fdbg-cnt=@var{counter-value-list} @gol\n -fdisable-ipa-@var{pass_name} @gol\n -fdisable-rtl-@var{pass_name} @gol\n -fdisable-rtl-@var{pass-name}=@var{range-list} @gol\n@@ -14567,6 +14568,24 @@ The files are created in the directory of the output file.\n \n @table @gcctabopt\n \n+@item -fcallgraph-info\n+@itemx -fcallgraph-info=@var{MARKERS}\n+@opindex fcallgraph-info\n+Makes the compiler output callgraph information for the program, on a\n+per-object-file basis.  The information is generated in the common VCG\n+format.  It can be decorated with additional, per-node and/or per-edge\n+information, if a list of comma-separated markers is additionally\n+specified.  When the @code{su} marker is specified, the callgraph is\n+decorated with stack usage information; it is equivalent to\n+@option{-fstack-usage}.  When the @code{da} marker is specified, the\n+callgraph is decorated with information about dynamically allocated\n+objects.\n+\n+When compiling with @option{-flto}, no callgraph information is output\n+along with the object file.  At LTO link time, @option{-fcallgraph-info}\n+may generate multiple callgraph information files next to intermediate\n+LTO output files.\n+\n @item -d@var{letters}\n @itemx -fdump-rtl-@var{pass}\n @itemx -fdump-rtl-@var{pass}=@var{filename}"}, {"sha": "83c786366c1aaaaefd251e9805d4c698da485a3f", "filename": "gcc/explow.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=3cf3da88be453f3fceaa596ee78be8d1e5aa21ca", "patch": "@@ -38,6 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dojump.h\"\n #include \"explow.h\"\n #include \"expr.h\"\n+#include \"stringpool.h\"\n #include \"common/common-target.h\"\n #include \"output.h\"\n #include \"params.h\"\n@@ -1611,6 +1612,10 @@ set_stack_check_libfunc (const char *libfunc_name)\n {\n   gcc_assert (stack_check_libfunc == NULL_RTX);\n   stack_check_libfunc = gen_rtx_SYMBOL_REF (Pmode, libfunc_name);\n+  tree decl = build_decl (UNKNOWN_LOCATION, FUNCTION_DECL,\n+\t\t\t  get_identifier (libfunc_name), void_type_node);\n+  DECL_EXTERNAL (decl) = 1;\n+  SET_SYMBOL_REF_DECL (stack_check_libfunc, decl);\n }\n \f\n /* Emit one stack probe at ADDRESS, an address within the stack.  */"}, {"sha": "b23d3a271f1ee69abb85d229a69222651fc4ba24", "filename": "gcc/flag-types.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=3cf3da88be453f3fceaa596ee78be8d1e5aa21ca", "patch": "@@ -200,6 +200,22 @@ enum stack_check_type\n   FULL_BUILTIN_STACK_CHECK\n };\n \n+/* Type of callgraph information.  */\n+enum callgraph_info_type\n+{\n+  /* No information.  */\n+  NO_CALLGRAPH_INFO = 0,\n+\n+  /* Naked callgraph.  */\n+  CALLGRAPH_INFO_NAKED = 1,\n+\n+  /* Callgraph decorated with stack usage information.  */\n+  CALLGRAPH_INFO_STACK_USAGE = 2,\n+\n+  /* Callgraph decoration with dynamic allocation information.  */\n+  CALLGRAPH_INFO_DYNAMIC_ALLOC = 4\n+};\n+\n /* Floating-point contraction mode.  */\n enum fp_contract_mode {\n   FP_CONTRACT_OFF = 0,"}, {"sha": "3f79a38aeaec81537445eaf09ac1db40184437d4", "filename": "gcc/function.c", "status": "modified", "additions": 53, "deletions": 6, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=3cf3da88be453f3fceaa596ee78be8d1e5aa21ca", "patch": "@@ -4725,6 +4725,16 @@ get_last_funcdef_no (void)\n   return funcdef_no;\n }\n \n+/* Allocate and initialize the stack usage info data structure for the\n+   current function.  */\n+static void\n+allocate_stack_usage_info (void)\n+{\n+  gcc_assert (!cfun->su);\n+  cfun->su = ggc_cleared_alloc<stack_usage> ();\n+  cfun->su->static_stack_size = -1;\n+}\n+\n /* Allocate a function structure for FNDECL and set its contents\n    to the defaults.  Set cfun to the newly-allocated object.\n    Some of the helper functions invoked during initialization assume\n@@ -4802,6 +4812,9 @@ allocate_struct_function (tree fndecl, bool abstract_p)\n \n       if (!profile_flag && !flag_instrument_function_entry_exit)\n \tDECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (fndecl) = 1;\n+\n+      if (flag_callgraph_info)\n+\tallocate_stack_usage_info ();\n     }\n \n   /* Don't enable begin stmt markers if var-tracking at assignments is\n@@ -4846,11 +4859,8 @@ prepare_function_start (void)\n   init_expr ();\n   default_rtl_profile ();\n \n-  if (flag_stack_usage_info)\n-    {\n-      cfun->su = ggc_cleared_alloc<stack_usage> ();\n-      cfun->su->static_stack_size = -1;\n-    }\n+  if (flag_stack_usage_info && !flag_callgraph_info)\n+    allocate_stack_usage_info ();\n \n   cse_not_expected = ! optimize;\n \n@@ -6373,12 +6383,49 @@ rest_of_handle_thread_prologue_and_epilogue (void)\n   cleanup_cfg (optimize ? CLEANUP_EXPENSIVE : 0);\n \n   /* The stack usage info is finalized during prologue expansion.  */\n-  if (flag_stack_usage_info)\n+  if (flag_stack_usage_info || flag_callgraph_info)\n     output_stack_usage ();\n \n   return 0;\n }\n \n+/* Record a final call to CALLEE at LOCATION.  */\n+\n+void\n+record_final_call (tree callee, location_t location)\n+{\n+  if (!callee || CALLEE_FROM_CGRAPH_P (callee))\n+    return;\n+\n+  struct callinfo_callee datum = { location, callee };\n+  vec_safe_push (cfun->su->callees, datum);\n+}\n+\n+/* Record a dynamic allocation made for DECL_OR_EXP.  */\n+\n+void\n+record_dynamic_alloc (tree decl_or_exp)\n+{\n+  struct callinfo_dalloc datum;\n+\n+  if (DECL_P (decl_or_exp))\n+    {\n+      datum.location = DECL_SOURCE_LOCATION (decl_or_exp);\n+      const char *name = lang_hooks.decl_printable_name (decl_or_exp, 2);\n+      const char *dot = strrchr (name, '.');\n+      if (dot)\n+\tname = dot + 1;\n+      datum.name = ggc_strdup (name);\n+    }\n+  else\n+    {\n+      datum.location = EXPR_LOCATION (decl_or_exp);\n+      datum.name = NULL;\n+    }\n+\n+  vec_safe_push (cfun->su->dallocs, datum);\n+}\n+\n namespace {\n \n const pass_data pass_data_thread_prologue_and_epilogue ="}, {"sha": "14794c420a215bc9c53e41ecfef555c9fd221a22", "filename": "gcc/function.h", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=3cf3da88be453f3fceaa596ee78be8d1e5aa21ca", "patch": "@@ -192,6 +192,23 @@ class GTY(()) frame_space\n   poly_int64 length;\n };\n \n+/* Describe emitted builtin calls for -fcallgraph-info.  Those that\n+   are not builtin are taken from cgraph edges.  */\n+struct GTY(()) callinfo_callee\n+{\n+  location_t location;\n+  tree decl;\n+};\n+#define CALLEE_FROM_CGRAPH_P(T)\t\t\t\t\\\n+  (!fndecl_built_in_p (T) && !DECL_IS_BUILTIN (T))\n+\n+/* Describe dynamic allocation for -fcallgraph-info=da.  */\n+struct GTY(()) callinfo_dalloc\n+{\n+  location_t location;\n+  char const *name;\n+};\n+\n class GTY(()) stack_usage\n {\n public:\n@@ -210,6 +227,13 @@ class GTY(()) stack_usage\n   /* Nonzero if the amount of stack space allocated dynamically cannot\n      be bounded at compile-time.  */\n   unsigned int has_unbounded_dynamic_stack_size : 1;\n+\n+  /* Functions called within the function, if callgraph is enabled.  */\n+  vec<callinfo_callee, va_gc> *callees;\n+\n+  /* Dynamic allocations encountered within the function, if callgraph\n+     da is enabled.  */\n+  vec<callinfo_dalloc, va_gc> *dallocs;\n };\n \n #define current_function_static_stack_size (cfun->su->static_stack_size)\n@@ -406,6 +430,12 @@ void add_local_decl (struct function *fun, tree d);\n #define FOR_EACH_LOCAL_DECL(FUN, I, D)\t\t\\\n   FOR_EACH_VEC_SAFE_ELT_REVERSE ((FUN)->local_decls, I, D)\n \n+/* Record a final call to CALLEE at LOCATION.  */\n+void record_final_call (tree callee, location_t location);\n+\n+/* Record a dynamic allocation made for DECL_OR_EXP.  */\n+void record_dynamic_alloc (tree decl_or_exp);\n+\n /* If va_list_[gf]pr_size is set to this, it means we don't know how\n    many units need to be saved.  */\n #define VA_LIST_MAX_GPR_SIZE\t255"}, {"sha": "5fa0ba6dda60979e75061ef4333a81a65e64fb15", "filename": "gcc/gimplify.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=3cf3da88be453f3fceaa596ee78be8d1e5aa21ca", "patch": "@@ -1698,6 +1698,10 @@ gimplify_vla_decl (tree decl, gimple_seq *seq_p)\n   t = build2 (MODIFY_EXPR, TREE_TYPE (addr), addr, t);\n \n   gimplify_and_add (t, seq_p);\n+\n+  /* Record the dynamic allocation associated with DECL if requested.  */\n+  if (flag_callgraph_info & CALLGRAPH_INFO_DYNAMIC_ALLOC)\n+    record_dynamic_alloc (decl);\n }\n \n /* A helper function to be called via walk_tree.  Mark all labels under *TP"}, {"sha": "8916f7e4da0bbf281a4251741cbad80425cf76ec", "filename": "gcc/optabs-libfuncs.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Foptabs-libfuncs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Foptabs-libfuncs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-libfuncs.c?ref=3cf3da88be453f3fceaa596ee78be8d1e5aa21ca", "patch": "@@ -735,10 +735,6 @@ build_libfunc_function_visibility (const char *name, symbol_visibility vis)\n   DECL_VISIBILITY_SPECIFIED (decl) = 1;\n   gcc_assert (DECL_ASSEMBLER_NAME (decl));\n \n-  /* Zap the nonsensical SYMBOL_REF_DECL for this.  What we're left with\n-     are the flags assigned by targetm.encode_section_info.  */\n-  SET_SYMBOL_REF_DECL (XEXP (DECL_RTL (decl), 0), NULL);\n-\n   return decl;\n }\n "}, {"sha": "f46b468a968e717b216cbb612d38497df563a9c5", "filename": "gcc/opts.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=3cf3da88be453f3fceaa596ee78be8d1e5aa21ca", "patch": "@@ -2433,6 +2433,32 @@ common_handle_option (struct gcc_options *opts,\n       /* Deferred.  */\n       break;\n \n+    case OPT_fcallgraph_info:\n+      opts->x_flag_callgraph_info = CALLGRAPH_INFO_NAKED;\n+      break;\n+\n+    case OPT_fcallgraph_info_:\n+      {\n+\tchar *my_arg, *p;\n+\tmy_arg = xstrdup (arg);\n+\tp = strtok (my_arg, \",\");\n+\twhile (p)\n+\t  {\n+\t    if (strcmp (p, \"su\") == 0)\n+\t      {\n+\t\topts->x_flag_callgraph_info |= CALLGRAPH_INFO_STACK_USAGE;\n+\t\topts->x_flag_stack_usage_info = true;\n+\t      }\n+\t    else if (strcmp (p, \"da\") == 0)\n+\t      opts->x_flag_callgraph_info |= CALLGRAPH_INFO_DYNAMIC_ALLOC;\n+\t    else\n+\t      return 0;\n+\t    p = strtok (NULL, \",\");\n+\t  }\n+\tfree (my_arg);\n+      }\n+      break;\n+\n     case OPT_fdiagnostics_show_location_:\n       diagnostic_prefixing_rule (dc) = (diagnostic_prefixing_rule_t) value;\n       break;"}, {"sha": "6cccada4aeb1decad5050a282c8afa1524d5b9f4", "filename": "gcc/output.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=3cf3da88be453f3fceaa596ee78be8d1e5aa21ca", "patch": "@@ -604,7 +604,7 @@ extern int maybe_assemble_visibility (tree);\n \n extern int default_address_cost (rtx, machine_mode, addr_space_t, bool);\n \n-/* Output stack usage information.  */\n+/* Stack usage.  */\n extern void output_stack_usage (void);\n \n #endif /* ! GCC_OUTPUT_H */"}, {"sha": "bd09ec4d7a7afcfdef0e5278e3cd232febb5266a", "filename": "gcc/print-tree.c", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=3cf3da88be453f3fceaa596ee78be8d1e5aa21ca", "patch": "@@ -1035,6 +1035,82 @@ print_node (FILE *file, const char *prefix, tree node, int indent,\n   fprintf (file, \">\");\n }\n \n+/* Print the identifier for DECL according to FLAGS.  */\n+\n+void\n+print_decl_identifier (FILE *file, tree decl, int flags)\n+{\n+  bool needs_colon = false;\n+  const char *name;\n+  char c;\n+\n+  if (flags & PRINT_DECL_ORIGIN)\n+    {\n+      if (DECL_IS_BUILTIN (decl))\n+\tfputs (\"<built-in>\", file);\n+      else\n+\t{\n+\t  expanded_location loc\n+\t    = expand_location (DECL_SOURCE_LOCATION (decl));\n+\t  fprintf (file, \"%s:%d:%d\", loc.file, loc.line, loc.column);\n+\t}\n+      needs_colon = true;\n+    }\n+\n+  if (flags & PRINT_DECL_UNIQUE_NAME)\n+    {\n+      name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+      if (!TREE_PUBLIC (decl)\n+\t  || (DECL_WEAK (decl) && !DECL_EXTERNAL (decl)))\n+\t/* The symbol has internal or weak linkage so its assembler name\n+\t   is not necessarily unique among the compilation units of the\n+\t   program.  We therefore have to further mangle it.  But we can't\n+\t   simply use DECL_SOURCE_FILE because it contains the name of the\n+\t   file the symbol originates from so, e.g. for function templates\n+\t   in C++ where the templates are defined in a header file, we can\n+\t   have symbols with the same assembler name and DECL_SOURCE_FILE.\n+\t   That's why we use the name of the top-level source file of the\n+\t   compilation unit.  ??? Unnecessary for Ada.  */\n+\tname = ACONCAT ((main_input_filename, \":\", name, NULL));\n+    }\n+  else if (flags & PRINT_DECL_NAME)\n+    {\n+      /* We don't want to print the full qualified name because it can be long,\n+\t so we strip the scope prefix, but we may need to deal with the suffix\n+\t created by the compiler.  */\n+      const char *suffix = strchr (IDENTIFIER_POINTER (DECL_NAME (decl)), '.');\n+      name = lang_hooks.decl_printable_name (decl, 2);\n+      if (suffix)\n+\t{\n+\t  const char *dot = strchr (name, '.');\n+\t  while (dot && strcasecmp (dot, suffix) != 0)\n+\t    {\n+\t      name = dot + 1;\n+\t      dot = strchr (name, '.');\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const char *dot = strrchr (name, '.');\n+\t  if (dot)\n+\t    name = dot + 1;\n+\t}\n+    }\n+  else\n+    return;\n+\n+  if (needs_colon)\n+    fputc (':', file);\n+\n+  while ((c = *name++) != '\\0')\n+    {\n+      /* Strip double-quotes because of VCG.  */\n+      if (c == '\"')\n+\tcontinue;\n+      fputc (c, file);\n+    }\n+}\n+\n \n /* Print the node NODE on standard error, for debugging.\n    Most nodes referred to by this one are printed recursively"}, {"sha": "cbea48c486e3cc4f3ea7ff19fcf5b3991f7b9a96", "filename": "gcc/print-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Fprint-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Fprint-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.h?ref=3cf3da88be453f3fceaa596ee78be8d1e5aa21ca", "patch": "@@ -42,5 +42,9 @@ extern void print_node (FILE *, const char *, tree, int,\n extern void print_node_brief (FILE *, const char *, const_tree, int);\n extern void indent_to (FILE *, int);\n #endif\n+#define PRINT_DECL_ORIGIN       0x1\n+#define PRINT_DECL_NAME         0x2\n+#define PRINT_DECL_UNIQUE_NAME  0x4\n+extern void print_decl_identifier (FILE *, tree, int flags);\n \n #endif  // GCC_PRINT_TREE_H"}, {"sha": "18fea1c3dd1cbecd195ee2a5656a322b4e7feb5f", "filename": "gcc/toplev.c", "status": "modified", "additions": 143, "deletions": 35, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf3da88be453f3fceaa596ee78be8d1e5aa21ca/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=3cf3da88be453f3fceaa596ee78be8d1e5aa21ca", "patch": "@@ -84,6 +84,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dumpfile.h\"\n #include \"ipa-fnsummary.h\"\n #include \"dump-context.h\"\n+#include \"print-tree.h\"\n #include \"optinfo-emit-json.h\"\n \n #if defined(DBX_DEBUGGING_INFO) || defined(XCOFF_DEBUGGING_INFO)\n@@ -174,6 +175,8 @@ const char *user_label_prefix;\n \n FILE *asm_out_file;\n FILE *aux_info_file;\n+FILE *callgraph_info_file = NULL;\n+static bitmap callgraph_info_external_printed;\n FILE *stack_usage_file = NULL;\n \n /* The current working directory of a translation.  It's generally the\n@@ -913,8 +916,8 @@ alloc_for_identifier_to_locale (size_t len)\n }\n \n /* Output stack usage information.  */\n-void\n-output_stack_usage (void)\n+static void\n+output_stack_usage_1 (FILE *cf)\n {\n   static bool warning_issued = false;\n   enum stack_usage_kind_type { STATIC = 0, DYNAMIC, DYNAMIC_BOUNDED };\n@@ -970,41 +973,17 @@ output_stack_usage (void)\n       stack_usage += current_function_dynamic_stack_size;\n     }\n \n+  if (flag_callgraph_info & CALLGRAPH_INFO_STACK_USAGE)\n+    fprintf (cf, \"\\\\n\" HOST_WIDE_INT_PRINT_DEC \" bytes (%s)\",\n+\t     stack_usage,\n+\t     stack_usage_kind_str[stack_usage_kind]);\n+\n   if (stack_usage_file)\n     {\n-      expanded_location loc\n-\t= expand_location (DECL_SOURCE_LOCATION (current_function_decl));\n-      /* We don't want to print the full qualified name because it can be long,\n-\t so we strip the scope prefix, but we may need to deal with the suffix\n-\t created by the compiler.  */\n-      const char *suffix\n-\t= strchr (IDENTIFIER_POINTER (DECL_NAME (current_function_decl)), '.');\n-      const char *name\n-\t= lang_hooks.decl_printable_name (current_function_decl, 2);\n-      if (suffix)\n-\t{\n-\t  const char *dot = strchr (name, '.');\n-\t  while (dot && strcasecmp (dot, suffix) != 0)\n-\t    {\n-\t      name = dot + 1;\n-\t      dot = strchr (name, '.');\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  const char *dot = strrchr (name, '.');\n-\t  if (dot)\n-\t    name = dot + 1;\n-\t}\n-\n-      fprintf (stack_usage_file,\n-\t       \"%s:%d:%d:%s\\t\" HOST_WIDE_INT_PRINT_DEC\"\\t%s\\n\",\n-\t       loc.file == NULL ? \"(artificial)\" : lbasename (loc.file),\n-\t       loc.line,\n-\t       loc.column,\n-\t       name,\n-\t       stack_usage,\n-\t       stack_usage_kind_str[stack_usage_kind]);\n+      print_decl_identifier (stack_usage_file, current_function_decl,\n+\t\t\t     PRINT_DECL_ORIGIN | PRINT_DECL_NAME);\n+      fprintf (stack_usage_file, \"\\t\" HOST_WIDE_INT_PRINT_DEC\"\\t%s\\n\",\n+\t       stack_usage, stack_usage_kind_str[stack_usage_kind]);\n     }\n \n   if (warn_stack_usage >= 0 && warn_stack_usage < HOST_WIDE_INT_MAX)\n@@ -1026,6 +1005,115 @@ output_stack_usage (void)\n     }\n }\n \n+/* Dump placeholder node for indirect calls in VCG format.  */\n+\n+#define INDIRECT_CALL_NAME  \"__indirect_call\"\n+\n+static void\n+dump_final_node_vcg_start (FILE *f, tree decl)\n+{\n+  fputs (\"node: { title: \\\"\", f);\n+  if (decl)\n+    print_decl_identifier (f, decl, PRINT_DECL_UNIQUE_NAME);\n+  else\n+    fputs (INDIRECT_CALL_NAME, f);\n+  fputs (\"\\\" label: \\\"\", f);\n+  if (decl)\n+    {\n+      print_decl_identifier (f, decl, PRINT_DECL_NAME);\n+      fputs (\"\\\\n\", f);\n+      print_decl_identifier (f, decl, PRINT_DECL_ORIGIN);\n+    }\n+  else\n+    fputs (\"Indirect Call Placeholder\", f);\n+}\n+\n+/* Dump final cgraph edge in VCG format.  */\n+\n+static void\n+dump_final_callee_vcg (FILE *f, location_t location, tree callee)\n+{\n+  if ((!callee || DECL_EXTERNAL (callee))\n+      && bitmap_set_bit (callgraph_info_external_printed,\n+\t\t\t callee ? DECL_UID (callee) + 1 : 0))\n+    {\n+      dump_final_node_vcg_start (f, callee);\n+      fputs (\"\\\" shape : ellipse }\\n\", f);\n+    }\n+\n+  fputs (\"edge: { sourcename: \\\"\", f);\n+  print_decl_identifier (f, current_function_decl, PRINT_DECL_UNIQUE_NAME);\n+  fputs (\"\\\" targetname: \\\"\", f);\n+  if (callee)\n+    print_decl_identifier (f, callee, PRINT_DECL_UNIQUE_NAME);\n+  else\n+    fputs (INDIRECT_CALL_NAME, f);\n+  if (LOCATION_LOCUS (location) != UNKNOWN_LOCATION)\n+    {\n+      expanded_location loc;\n+      fputs (\"\\\" label: \\\"\", f);\n+      loc = expand_location (location);\n+      fprintf (f, \"%s:%d:%d\", loc.file, loc.line, loc.column);\n+    }\n+  fputs (\"\\\" }\\n\", f);\n+}\n+\n+/* Dump final cgraph node in VCG format.  */\n+\n+static void\n+dump_final_node_vcg (FILE *f)\n+{\n+  dump_final_node_vcg_start (f, current_function_decl);\n+\n+  if (flag_stack_usage_info\n+      || (flag_callgraph_info & CALLGRAPH_INFO_STACK_USAGE))\n+    output_stack_usage_1 (f);\n+\n+  if (flag_callgraph_info & CALLGRAPH_INFO_DYNAMIC_ALLOC)\n+    {\n+      fprintf (f, \"\\\\n%u dynamic objects\", vec_safe_length (cfun->su->dallocs));\n+\n+      unsigned i;\n+      callinfo_dalloc *cda;\n+      FOR_EACH_VEC_SAFE_ELT (cfun->su->dallocs, i, cda)\n+\t{\n+\t  expanded_location loc = expand_location (cda->location);\n+\t  fprintf (f, \"\\\\n %s\", cda->name);\n+\t  fprintf (f, \" %s:%d:%d\", loc.file, loc.line, loc.column);\n+\t}\n+\n+      vec_free (cfun->su->dallocs);\n+      cfun->su->dallocs = NULL;\n+    }\n+\n+  fputs (\"\\\" }\\n\", f);\n+\n+  unsigned i;\n+  callinfo_callee *c;\n+  FOR_EACH_VEC_SAFE_ELT (cfun->su->callees, i, c)\n+    dump_final_callee_vcg (f, c->location, c->decl);\n+  vec_free (cfun->su->callees);\n+  cfun->su->callees = NULL;\n+\n+  cgraph_node *cnode = cgraph_node::get (current_function_decl);\n+  for (cgraph_edge *e = cnode->callees; e; e = e->next_callee)\n+    if (CALLEE_FROM_CGRAPH_P (e->callee->decl))\n+      dump_final_callee_vcg (f, gimple_location (e->call_stmt),\n+\t\t\t     e->callee->decl);\n+  for (cgraph_edge *e = cnode->indirect_calls; e; e = e->next_callee)\n+    dump_final_callee_vcg (f, gimple_location (e->call_stmt), NULL);\n+}\n+\n+/* Output stack usage and callgraph info, as requested.  */\n+void\n+output_stack_usage (void)\n+{\n+  if (flag_callgraph_info)\n+    dump_final_node_vcg (callgraph_info_file);\n+  else\n+    output_stack_usage_1 (NULL);\n+}\n+\n /* Open an auxiliary output file.  */\n static FILE *\n open_auxiliary_file (const char *ext)\n@@ -1900,6 +1988,17 @@ lang_dependent_init (const char *name)\n       /* If stack usage information is desired, open the output file.  */\n       if (flag_stack_usage && !flag_generate_lto)\n \tstack_usage_file = open_auxiliary_file (\"su\");\n+\n+      /* If call graph information is desired, open the output file.  */\n+      if (flag_callgraph_info && !flag_generate_lto)\n+\t{\n+\t  callgraph_info_file = open_auxiliary_file (\"ci\");\n+\t  /* Write the file header.  */\n+\t  fprintf (callgraph_info_file,\n+\t\t   \"graph: { title: \\\"%s\\\"\\n\", main_input_filename);\n+\t  bitmap_obstack_initialize (NULL);\n+\t  callgraph_info_external_printed = BITMAP_ALLOC (NULL);\n+\t}\n     }\n \n   /* This creates various _DECL nodes, so needs to be called after the\n@@ -2053,6 +2152,15 @@ finalize (bool no_backend)\n       stack_usage_file = NULL;\n     }\n \n+  if (callgraph_info_file)\n+    {\n+      fputs (\"}\\n\", callgraph_info_file);\n+      fclose (callgraph_info_file);\n+      callgraph_info_file = NULL;\n+      BITMAP_FREE (callgraph_info_external_printed);\n+      bitmap_obstack_release (NULL);\n+    }\n+\n   if (seen_error ())\n     coverage_remove_note_file ();\n "}]}