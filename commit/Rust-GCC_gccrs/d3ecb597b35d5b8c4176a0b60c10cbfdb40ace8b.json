{"sha": "d3ecb597b35d5b8c4176a0b60c10cbfdb40ace8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDNlY2I1OTdiMzVkNWI4YzQxNzZhMGI2MGMxMGNiZmRiNDBhY2U4Yg==", "commit": {"author": {"name": "Bryce McKinlay", "email": "mckinlay@redhat.com", "date": "2004-07-10T05:38:15Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2004-07-10T05:38:15Z"}, "message": "re PR java/8618 (call to private constructor allowed for anonymous inner class)\n\n2004-07-09  Bryce McKinlay  <mckinlay@redhat.com>\n\n        PR java/8618\n        * parse.y (create_anonymous_class): Remove 'location' argument. Use\n        the WFL from TYPE_NAME to get line number for the decl. Fix comment.\n        (craft_constructor): Inherit access flags for implicit constructor\n        from the enclosing class.\n        (create_class): Fix comment typo.\n        (resolve_qualified_expression_name): Pass type of qualifier to\n        not_accessible_p, not the type in which target field was found.\n        (not_accessible_p): Handle inner classes. Expand protected\n        qualifier-subtype check to enclosing instances, but don't apply this\n        check to static members. Allow protected access to inner classes\n        of a subtype. Allow private access within common enclosing context.\n        (build_super_invocation): Get WFL line number info from current\n        class decl.\n        (build_incomplete_class_ref): Update for new create_anonymous_class\n        signature.\n        * parse.h (INNER_ENCLOSING_SCOPE_CHECK): Use\n        common_enclosing_instance_p.\n        * class.c (common_enclosing_context_p): New. Determine if types\n        share a common enclosing context, even across static contexts.\n        (common_enclosing_instance_p): Renamed from\n        common_enclosing_context_p. Determines if types share a common\n        non-static enclosing instance.\n        * java-tree.h (common_enclosing_instance_p): Declare.\n        * jcf-write.c (get_method_access_flags): New. Surpress private flag\n        for inner class constructors.\n        (generate_classfile): Use get_method_access_flags.\n\nFrom-SVN: r84443", "tree": {"sha": "bcd4a6d234666cbea3ddc05897321cf2a6b159ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bcd4a6d234666cbea3ddc05897321cf2a6b159ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3ecb597b35d5b8c4176a0b60c10cbfdb40ace8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3ecb597b35d5b8c4176a0b60c10cbfdb40ace8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3ecb597b35d5b8c4176a0b60c10cbfdb40ace8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3ecb597b35d5b8c4176a0b60c10cbfdb40ace8b/comments", "author": null, "committer": null, "parents": [{"sha": "a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7e5372d6a8e2f12b6d9a15f71d5ad0794e6507f"}], "stats": {"total": 165, "additions": 125, "deletions": 40}, "files": [{"sha": "fea2c218baf5b005a673bf41eb3993f3251ddd2e", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3ecb597b35d5b8c4176a0b60c10cbfdb40ace8b/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3ecb597b35d5b8c4176a0b60c10cbfdb40ace8b/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=d3ecb597b35d5b8c4176a0b60c10cbfdb40ace8b", "patch": "@@ -1,3 +1,33 @@\n+2004-07-09  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\tPR java/8618\n+\t* parse.y (create_anonymous_class): Remove 'location' argument. Use\n+\tthe WFL from TYPE_NAME to get line number for the decl. Fix comment.\n+\t(craft_constructor): Inherit access flags for implicit constructor\n+\tfrom the enclosing class.\n+\t(create_class): Fix comment typo.\n+\t(resolve_qualified_expression_name): Pass type of qualifier to\n+\tnot_accessible_p, not the type in which target field was found.\n+\t(not_accessible_p): Handle inner classes. Expand protected \n+\tqualifier-subtype check to enclosing instances, but don't apply this \n+\tcheck to static members. Allow protected access to inner classes\n+\tof a subtype. Allow private access within common enclosing context.\n+\t(build_super_invocation): Get WFL line number info from current\n+\tclass decl.\n+\t(build_incomplete_class_ref): Update for new create_anonymous_class\n+\tsignature.\n+\t* parse.h (INNER_ENCLOSING_SCOPE_CHECK): Use\n+\tcommon_enclosing_instance_p.\n+\t* class.c (common_enclosing_context_p): New. Determine if types\n+\tshare a common enclosing context, even across static contexts.\n+\t(common_enclosing_instance_p): Renamed from \n+\tcommon_enclosing_context_p. Determines if types share a common\n+\tnon-static enclosing instance.\n+\t* java-tree.h (common_enclosing_instance_p): Declare.\n+\t* jcf-write.c (get_method_access_flags): New. Surpress private flag\n+\tfor inner class constructors.\n+\t(generate_classfile): Use get_method_access_flags.\n+\n 2004-07-09  Bryce McKinlay  <mckinlay@redhat.com>\n \n \t* class.c (interface_of_p): Check for null TYPE_BINFO."}, {"sha": "1273b62155f465bdc2f368c9947a1bcad08b07e0", "filename": "gcc/java/class.c", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3ecb597b35d5b8c4176a0b60c10cbfdb40ace8b/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3ecb597b35d5b8c4176a0b60c10cbfdb40ace8b/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=d3ecb597b35d5b8c4176a0b60c10cbfdb40ace8b", "patch": "@@ -587,11 +587,33 @@ enclosing_context_p (tree type1, tree type2)\n   return 0;\n }\n \n-/* Return 1 iff there exists a common enclosing context between TYPE1\n-   and TYPE2.  */\n+\n+/* Return 1 iff TYPE1 and TYPE2 share a common enclosing class, regardless of\n+   nesting level.  */\n \n int\n common_enclosing_context_p (tree type1, tree type2)\n+{\n+  for (type1; type1; \n+       type1 = (INNER_CLASS_TYPE_P (type1) ?\n+\t\tTREE_TYPE (DECL_CONTEXT (TYPE_NAME (type1))) : NULL_TREE))\n+    {\n+      tree current;\n+      for (current = type2; current;\n+\t   current = (INNER_CLASS_TYPE_P (current) ?\n+\t\t      TREE_TYPE (DECL_CONTEXT (TYPE_NAME (current))) : \n+\t\t      NULL_TREE))\n+\tif (type1 == current)\n+\t  return 1;\n+    }\n+  return 0;\n+}\n+\n+/* Return 1 iff there exists a common enclosing \"this\" between TYPE1\n+   and TYPE2, without crossing any static context.  */\n+\n+int\n+common_enclosing_instance_p (tree type1, tree type2)\n {\n   if (!PURE_INNER_CLASS_TYPE_P (type1) || !PURE_INNER_CLASS_TYPE_P (type2))\n     return 0;"}, {"sha": "d9e641547bdff589b850d514e3a7368eb802ff97", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3ecb597b35d5b8c4176a0b60c10cbfdb40ace8b/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3ecb597b35d5b8c4176a0b60c10cbfdb40ace8b/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=d3ecb597b35d5b8c4176a0b60c10cbfdb40ace8b", "patch": "@@ -1238,6 +1238,7 @@ extern int get_access_flags_from_decl (tree);\n extern int interface_of_p (tree, tree);\n extern int inherits_from_p (tree, tree);\n extern int common_enclosing_context_p (tree, tree);\n+extern int common_enclosing_instance_p (tree, tree);\n extern int enclosing_context_p (tree, tree);\n extern tree build_result_decl (tree);\n extern void emit_handlers (void);"}, {"sha": "e34543c44c77fcfe7d52c933adc40263f738406b", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3ecb597b35d5b8c4176a0b60c10cbfdb40ace8b/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3ecb597b35d5b8c4176a0b60c10cbfdb40ace8b/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=d3ecb597b35d5b8c4176a0b60c10cbfdb40ace8b", "patch": "@@ -2903,6 +2903,22 @@ get_classfile_modifiers (tree class)\n   return flags;\n }\n \n+/* Get the access flags (modifiers) for a method to be used in the class \n+   file.  */\n+\n+static int\n+get_method_access_flags (tree decl)\n+{\n+  int flags = get_access_flags (decl);\n+\n+  /* Promote \"private\" inner-class constructors to package-private.  */\n+  if (DECL_CONSTRUCTOR_P (decl)\n+      && INNER_CLASS_DECL_P (TYPE_NAME (DECL_CONTEXT (decl))))\n+    flags &= ~(ACC_PRIVATE);\n+\n+  return flags;\n+}\n+\n /* Generate and return a list of chunks containing the class CLAS\n    in the .class file representation.  The list can be written to a\n    .class file using write_chunks.  Allocate chunks from obstack WORK. */\n@@ -3034,7 +3050,7 @@ generate_classfile (tree clas, struct jcf_partial *state)\n \n       current_function_decl = part;\n       ptr = append_chunk (NULL, 8, state);\n-      i = get_access_flags (part);  PUT2 (i);\n+      i = get_method_access_flags (part);  PUT2 (i);\n       i = find_utf8_constant (&state->cpool, name);  PUT2 (i);\n       i = find_utf8_constant (&state->cpool, build_java_signature (type));\n       PUT2 (i);"}, {"sha": "f0fb67acdb02d2c08cf031e16da6f86a424d9ca2", "filename": "gcc/java/parse.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3ecb597b35d5b8c4176a0b60c10cbfdb40ace8b/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3ecb597b35d5b8c4176a0b60c10cbfdb40ace8b/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=d3ecb597b35d5b8c4176a0b60c10cbfdb40ace8b", "patch": "@@ -842,7 +842,7 @@ struct parser_ctxt GTY(()) {\n \t    != TYPE_NAME (TREE_TYPE (TREE_TYPE (current_this))))\t      \\\n \t&& !inherits_from_p (TREE_TYPE (TREE_TYPE (current_this)),\t      \\\n \t\t\t     TREE_TYPE (DECL_CONTEXT (TYPE_NAME (T))))\t      \\\n-        && !common_enclosing_context_p (TREE_TYPE (TREE_TYPE (current_this)), \\\n+        && !common_enclosing_instance_p (TREE_TYPE (TREE_TYPE (current_this)),\\\n \t\t\t\t\t(T))                                  \\\n \t&& INNER_CLASS_TYPE_P (TREE_TYPE (TREE_TYPE (current_this)))          \\\n \t&& !inherits_from_p                                                   \\"}, {"sha": "8d65bd1e52f4eca139e90aecad590a908a930565", "filename": "gcc/java/parse.y", "status": "modified", "additions": 52, "deletions": 36, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3ecb597b35d5b8c4176a0b60c10cbfdb40ace8b/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3ecb597b35d5b8c4176a0b60c10cbfdb40ace8b/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=d3ecb597b35d5b8c4176a0b60c10cbfdb40ace8b", "patch": "@@ -320,7 +320,7 @@ static int outer_field_expanded_access_p (tree, tree *,\n static tree outer_field_access_fix (tree, tree, tree);\n static tree build_incomplete_class_ref (int, tree);\n static tree patch_incomplete_class_ref (tree);\n-static tree create_anonymous_class (int, tree);\n+static tree create_anonymous_class (tree);\n static void patch_anonymous_class (tree, tree, tree);\n static void add_inner_class_fields (tree, tree);\n \n@@ -2034,7 +2034,7 @@ class_instance_creation_expression:\n \n anonymous_class_creation:\n \tNEW_TK class_type OP_TK argument_list CP_TK\n-\t\t{ create_anonymous_class ($1.location, $2); }\n+\t\t{ create_anonymous_class ($2); }\n         class_body\n \t\t{\n \t\t  tree id = build_wfl_node (DECL_NAME (GET_CPC ()));\n@@ -2067,7 +2067,7 @@ anonymous_class_creation:\n \n \t\t}\n |\tNEW_TK class_type OP_TK CP_TK\n-\t\t{ create_anonymous_class ($1.location, $2); }\n+\t\t{ create_anonymous_class ($2); }\n         class_body\n \t\t{\n \t\t  tree id = build_wfl_node (DECL_NAME (GET_CPC ()));\n@@ -3905,8 +3905,11 @@ patch_anonymous_class (tree type_decl, tree class_decl, tree wfl)\n     }\n }\n \n+/* Create an anonymous class which extends/implements TYPE_NAME, and return\n+   its decl.  */\n+\n static tree\n-create_anonymous_class (int location, tree type_name)\n+create_anonymous_class (tree type_name)\n {\n   char buffer [80];\n   tree super = NULL_TREE, itf = NULL_TREE;\n@@ -3915,7 +3918,7 @@ create_anonymous_class (int location, tree type_name)\n   /* The unqualified name of the anonymous class. It's just a number. */\n   sprintf (buffer, \"%d\", anonymous_class_counter++);\n   id = build_wfl_node (get_identifier (buffer));\n-  EXPR_WFL_LINECOL (id) = location;\n+  EXPR_WFL_LINECOL (id) = EXPR_WFL_LINECOL (type_name);\n \n   /* We know about the type to extend/implement. We go ahead */\n   if ((type_decl = IDENTIFIER_CLASS_VALUE (EXPR_WFL_NODE (type_name))))\n@@ -4035,7 +4038,7 @@ create_class (int flags, tree id, tree super, tree interfaces)\n \n   /* Add the private this$<n> field, Replicate final locals still in\n      scope as private final fields mangled like val$<local_name>.\n-     This doesn't not occur for top level (static) inner classes. */\n+     This does not occur for top level (static) inner classes. */\n   if (PURE_INNER_CLASS_DECL_P (decl))\n     add_inner_class_fields (decl, current_function_decl);\n \n@@ -5393,8 +5396,9 @@ craft_constructor (tree class_decl, tree args)\n {\n   tree class_type = TREE_TYPE (class_decl);\n   tree parm = NULL_TREE;\n-  int flags = (get_access_flags_from_decl (class_decl) & ACC_PUBLIC ?\n-\t       ACC_PUBLIC : 0);\n+  /* Inherit access flags for the constructor from its enclosing class. */\n+  int valid_ctor_flags = ACC_PUBLIC | ACC_PROTECTED | ACC_PRIVATE;\n+  int flags = (get_access_flags_from_decl (class_decl) & valid_ctor_flags);\n   int i = 0, artificial = 0;\n   tree decl, ctor_name;\n   char buffer [80];\n@@ -9961,7 +9965,7 @@ resolve_qualified_expression_name (tree wfl, tree *found_decl,\n \n \t      /* Check on accessibility here */\n \t      if (not_accessible_p (current_class, field_decl,\n-\t\t\t\t    DECL_CONTEXT (field_decl), from_super))\n+\t\t\t\t    *type_found, from_super))\n  \t\treturn not_accessible_field_error (qual_wfl,field_decl);    \n \t      check_deprecation (qual_wfl, field_decl);\n \n@@ -10047,10 +10051,13 @@ static int\n not_accessible_p (tree reference, tree member, tree where, int from_super)\n {\n   int access_flag = get_access_flags_from_decl (member);\n-\n-  /* Inner classes are processed by check_inner_class_access */\n-  if (INNER_CLASS_TYPE_P (reference))\n-    return 0;\n+  bool is_static = false;\n+ \n+  if (TREE_CODE (member) == FIELD_DECL ||\n+      TREE_CODE (member) == VAR_DECL)\n+    is_static = FIELD_STATIC (member);\n+  else\n+    is_static = METHOD_STATIC (member);\n \n   /* Access always granted for members declared public */\n   if (access_flag & ACC_PUBLIC)\n@@ -10069,26 +10076,34 @@ not_accessible_p (tree reference, tree member, tree where, int from_super)\n       if (from_super)\n \treturn 0;\n \n-      /* If where is active, access was made through a\n-\t qualifier. Access is granted if the type of the qualifier is\n-\t or is a sublass of the type the access made from (6.6.2.1.)  */\n-      if (where && !inherits_from_p (reference, where))\n-\treturn 1;\n-\n-      /* Otherwise, access is granted if occurring from the class where\n-\t member is declared or a subclass of it. Find the right\n-\t context to perform the check */\n-      if (PURE_INNER_CLASS_TYPE_P (reference))\n+      /* If WHERE is active, access was made through a qualifier. For \n+         non-static members, access is granted if the type of the qualifier \n+\t is or is a sublass of the type the access is made from (6.6.2.1.)  */\n+      if (where && !is_static)\n         {\n-          while (INNER_CLASS_TYPE_P (reference))\n+\t  while (reference)\n             {\n-              if (inherits_from_p (reference, DECL_CONTEXT (member)))\n-                return 0;\n-              reference = TREE_TYPE (DECL_CONTEXT (TYPE_NAME (reference)));\n-            }\n+\t      if (inherits_from_p (where, reference))\n+\t        return 0;\n+\t      if (PURE_INNER_CLASS_TYPE_P (reference))\n+\t\treference = TREE_TYPE (DECL_CONTEXT (TYPE_NAME (reference)));\n+\t      else\n+\t        break;\n+\t    }\n+\t  return 1;\n+\t}\n+\n+      /* Otherwise, access is granted if occurring from within the class\n+         where member is declared, or a subclass of it.  */\n+      while (reference)\n+        {\n+          if (inherits_from_p (reference, DECL_CONTEXT (member)))\n+            return 0;\n+\t  if (PURE_INNER_CLASS_TYPE_P (reference))\n+            reference = TREE_TYPE (DECL_CONTEXT (TYPE_NAME (reference)));\n+\t  else\n+\t    break;\n         }\n-      if (inherits_from_p (reference, DECL_CONTEXT (member)))\n-\treturn 0;\n       return 1;\n     }\n \n@@ -10097,9 +10112,8 @@ not_accessible_p (tree reference, tree member, tree where, int from_super)\n      it for innerclasses too. */\n   if (access_flag & ACC_PRIVATE)\n     {\n-      if (reference == DECL_CONTEXT (member))\n-\treturn 0;\n-      if (enclosing_context_p (reference, DECL_CONTEXT (member)))\n+      if (reference == DECL_CONTEXT (member) ||\n+          common_enclosing_context_p (DECL_CONTEXT (member), reference))\n \treturn 0;\n       return 1;\n     }\n@@ -10506,8 +10520,6 @@ patch_method_invocation (tree patch, tree primary, tree where, int from_super,\n \tIDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (current_class)));\n       const char *const what = (DECL_CONSTRUCTOR_P (list)\n \t\t\t\t? \"constructor\" : \"method\");\n-      /* FIXME: WFL yields the wrong message here but I don't know\n-\t what else to use.  */\n       parse_error_context (wfl,\n \t\t\t   \"Can't access %s %s `%s.%s' from `%s'\",\n \t\t\t   access, what, klass, fct_name, refklass);\n@@ -12343,6 +12355,10 @@ build_super_invocation (tree mdecl)\n   else\n     {\n       tree super_wfl = build_wfl_node (super_identifier_node);\n+      /* This is called after parsing is done, so the parser context\n+         won't be accurate. Set location info from current_class decl. */\n+      tree class_wfl = lookup_cl (TYPE_NAME (current_class));\n+      EXPR_WFL_LINECOL (super_wfl) = EXPR_WFL_LINECOL (class_wfl);\n       tree a = NULL_TREE, t;\n       /* If we're dealing with an anonymous class, pass the arguments\n          of the crafted constructor along. */\n@@ -13922,7 +13938,7 @@ build_incomplete_class_ref (int location, tree class_name)\n \t  /* We want the generated inner class inside the outermost class. */\n \t  GET_CPC_LIST() = cpc;\n \t  t = build_wfl_node (DECL_NAME (TYPE_NAME (object_type_node)));\n-\t  inner = create_anonymous_class (0, t);\n+\t  inner = create_anonymous_class (t);\n \t  target_class = TREE_TYPE (inner);\n \t  end_class_declaration (1);\n \t  GET_CPC_LIST() = cpc_list;"}]}