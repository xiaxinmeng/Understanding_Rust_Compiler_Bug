{"sha": "2c53b149b7476fabd329429b2a6dce090f580ff4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM1M2IxNDliNzQ3NmZhYmQzMjk0MjliMmE2ZGNlMDkwZjU4MGZmNA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-05-25T08:08:21Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-05-25T08:08:21Z"}, "message": "tree-vectorizer.h (STMT_VINFO_GROUP_*, GROUP_*): Remove.\n\n2018-05-25  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (STMT_VINFO_GROUP_*, GROUP_*): Remove.\n\t(DR_GROUP_*): New, assert we have non-NULL ->data_ref_info.\n\t(REDUC_GROUP_*): New, assert we have NULL ->data_ref_info.\n\t(STMT_VINFO_GROUPED_ACCESS): Adjust.\n\t* tree-vect-data-refs.c (everywhere): Adjust users.\n\t* tree-vect-loop.c (everywhere): Likewise.\n\t* tree-vect-slp.c (everywhere): Likewise.\n\t* tree-vect-stmts.c (everywhere): Likewise.\n\t* tree-vect-patterns.c (vect_reassociating_reduction_p): Likewise.\n\nFrom-SVN: r260709", "tree": {"sha": "f9629faba7998b861e0b748c4f139d7edf744a13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9629faba7998b861e0b748c4f139d7edf744a13"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c53b149b7476fabd329429b2a6dce090f580ff4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c53b149b7476fabd329429b2a6dce090f580ff4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c53b149b7476fabd329429b2a6dce090f580ff4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c53b149b7476fabd329429b2a6dce090f580ff4/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f8d704048f0900b88a459a60c5fed0e9b7ed8658", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8d704048f0900b88a459a60c5fed0e9b7ed8658", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8d704048f0900b88a459a60c5fed0e9b7ed8658"}], "stats": {"total": 533, "additions": 279, "deletions": 254}, "files": [{"sha": "840bdf7c89e88d640df3633fa7e7c0d2dace42fa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c53b149b7476fabd329429b2a6dce090f580ff4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c53b149b7476fabd329429b2a6dce090f580ff4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c53b149b7476fabd329429b2a6dce090f580ff4", "patch": "@@ -1,3 +1,15 @@\n+2018-05-25  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (STMT_VINFO_GROUP_*, GROUP_*): Remove.\n+\t(DR_GROUP_*): New, assert we have non-NULL ->data_ref_info.\n+\t(REDUC_GROUP_*): New, assert we have NULL ->data_ref_info.\n+\t(STMT_VINFO_GROUPED_ACCESS): Adjust.\n+\t* tree-vect-data-refs.c (everywhere): Adjust users.\n+\t* tree-vect-loop.c (everywhere): Likewise.\n+\t* tree-vect-slp.c (everywhere): Likewise.\n+\t* tree-vect-stmts.c (everywhere): Likewise.\n+\t* tree-vect-patterns.c (vect_reassociating_reduction_p): Likewise.\n+\n 2018-05-25  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* configure.ac (gcc_cv_as_section_has_e): Move to common section."}, {"sha": "fe4c4a5a1be24e8e249ed1e59b5b2b8d40ecf1b2", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 64, "deletions": 63, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c53b149b7476fabd329429b2a6dce090f580ff4/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c53b149b7476fabd329429b2a6dce090f580ff4/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=2c53b149b7476fabd329429b2a6dce090f580ff4", "patch": "@@ -307,8 +307,9 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n   /* We do not have to consider dependences between accesses that belong\n      to the same group, unless the stride could be smaller than the\n      group size.  */\n-  if (GROUP_FIRST_ELEMENT (stmtinfo_a)\n-      && GROUP_FIRST_ELEMENT (stmtinfo_a) == GROUP_FIRST_ELEMENT (stmtinfo_b)\n+  if (DR_GROUP_FIRST_ELEMENT (stmtinfo_a)\n+      && (DR_GROUP_FIRST_ELEMENT (stmtinfo_a)\n+\t  == DR_GROUP_FIRST_ELEMENT (stmtinfo_b))\n       && !STMT_VINFO_STRIDED_P (stmtinfo_a))\n     return false;\n \n@@ -614,8 +615,8 @@ vect_slp_analyze_data_ref_dependence (struct data_dependence_relation *ddr)\n   /* If dra and drb are part of the same interleaving chain consider\n      them independent.  */\n   if (STMT_VINFO_GROUPED_ACCESS (vinfo_for_stmt (DR_STMT (dra)))\n-      && (GROUP_FIRST_ELEMENT (vinfo_for_stmt (DR_STMT (dra)))\n-\t  == GROUP_FIRST_ELEMENT (vinfo_for_stmt (DR_STMT (drb)))))\n+      && (DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (DR_STMT (dra)))\n+\t  == DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (DR_STMT (drb)))))\n     return false;\n \n   /* Unknown data dependence.  */\n@@ -1056,9 +1057,9 @@ vect_update_misalignment_for_peel (struct data_reference *dr,\n  /* For interleaved data accesses the step in the loop must be multiplied by\n      the size of the interleaving group.  */\n   if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n-    dr_size *= GROUP_SIZE (vinfo_for_stmt (GROUP_FIRST_ELEMENT (stmt_info)));\n+    dr_size *= DR_GROUP_SIZE (vinfo_for_stmt (DR_GROUP_FIRST_ELEMENT (stmt_info)));\n   if (STMT_VINFO_GROUPED_ACCESS (peel_stmt_info))\n-    dr_peel_size *= GROUP_SIZE (peel_stmt_info);\n+    dr_peel_size *= DR_GROUP_SIZE (peel_stmt_info);\n \n   /* It can be assumed that the data refs with the same alignment as dr_peel\n      are aligned in the vector loop.  */\n@@ -1151,7 +1152,7 @@ vect_verify_datarefs_alignment (loop_vec_info vinfo)\n \n       /* For interleaving, only the alignment of the first access matters.   */\n       if (STMT_VINFO_GROUPED_ACCESS (stmt_info)\n-\t  && GROUP_FIRST_ELEMENT (stmt_info) != stmt)\n+\t  && DR_GROUP_FIRST_ELEMENT (stmt_info) != stmt)\n \tcontinue;\n \n       /* Strided accesses perform only component accesses, alignment is\n@@ -1208,7 +1209,7 @@ vector_alignment_reachable_p (struct data_reference *dr)\n       elem_size = vector_element_size (vector_size, nelements);\n       mis_in_elements = DR_MISALIGNMENT (dr) / elem_size;\n \n-      if (!multiple_p (nelements - mis_in_elements, GROUP_SIZE (stmt_info)))\n+      if (!multiple_p (nelements - mis_in_elements, DR_GROUP_SIZE (stmt_info)))\n \treturn false;\n     }\n \n@@ -1396,7 +1397,7 @@ vect_get_peeling_costs_all_drs (vec<data_reference_p> datarefs,\n       /* For interleaving, only the alignment of the first access\n          matters.  */\n       if (STMT_VINFO_GROUPED_ACCESS (stmt_info)\n-          && GROUP_FIRST_ELEMENT (stmt_info) != stmt)\n+          && DR_GROUP_FIRST_ELEMENT (stmt_info) != stmt)\n         continue;\n \n       /* Strided accesses perform only component accesses, alignment is\n@@ -1530,7 +1531,7 @@ vect_peeling_supportable (loop_vec_info loop_vinfo, struct data_reference *dr0,\n       /* For interleaving, only the alignment of the first access\n \t matters.  */\n       if (STMT_VINFO_GROUPED_ACCESS (stmt_info)\n-\t  && GROUP_FIRST_ELEMENT (stmt_info) != stmt)\n+\t  && DR_GROUP_FIRST_ELEMENT (stmt_info) != stmt)\n \tcontinue;\n \n       /* Strided accesses perform only component accesses, alignment is\n@@ -1718,7 +1719,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       /* For interleaving, only the alignment of the first access\n          matters.  */\n       if (STMT_VINFO_GROUPED_ACCESS (stmt_info)\n-          && GROUP_FIRST_ELEMENT (stmt_info) != stmt)\n+          && DR_GROUP_FIRST_ELEMENT (stmt_info) != stmt)\n         continue;\n \n       /* For invariant accesses there is nothing to enhance.  */\n@@ -1764,7 +1765,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n               if (unlimited_cost_model (LOOP_VINFO_LOOP (loop_vinfo)))\n \t\t{\n \t\t  poly_uint64 nscalars = (STMT_SLP_TYPE (stmt_info)\n-\t\t\t\t\t  ? vf * GROUP_SIZE (stmt_info) : vf);\n+\t\t\t\t\t  ? vf * DR_GROUP_SIZE (stmt_info) : vf);\n \t\t  possible_npeel_number\n \t\t    = vect_get_num_vectors (nscalars, vectype);\n \n@@ -2027,7 +2028,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t     by the group size.  */\n \t  stmt_info = vinfo_for_stmt (DR_STMT (dr0));\n \t  if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n-\t    npeel /= GROUP_SIZE (stmt_info);\n+\t    npeel /= DR_GROUP_SIZE (stmt_info);\n \n           if (dump_enabled_p ())\n             dump_printf_loc (MSG_NOTE, vect_location,\n@@ -2155,7 +2156,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t     matters.  */\n \t  if (aligned_access_p (dr)\n \t      || (STMT_VINFO_GROUPED_ACCESS (stmt_info)\n-\t\t  && GROUP_FIRST_ELEMENT (stmt_info) != stmt))\n+\t\t  && DR_GROUP_FIRST_ELEMENT (stmt_info) != stmt))\n \t    continue;\n \n \t  if (STMT_VINFO_STRIDED_P (stmt_info))\n@@ -2380,7 +2381,7 @@ vect_slp_analyze_and_verify_node_alignment (slp_tree node)\n   gimple *first_stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n   data_reference_p first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n   if (SLP_TREE_LOAD_PERMUTATION (node).exists ())\n-    first_stmt = GROUP_FIRST_ELEMENT (vinfo_for_stmt (first_stmt));\n+    first_stmt = DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (first_stmt));\n \n   data_reference_p dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n   if (! vect_compute_data_ref_alignment (dr)\n@@ -2455,10 +2456,10 @@ vect_analyze_group_access_1 (struct data_reference *dr)\n       dr_step = tree_to_shwi (step);\n       /* Check that STEP is a multiple of type size.  Otherwise there is\n          a non-element-sized gap at the end of the group which we\n-\t cannot represent in GROUP_GAP or GROUP_SIZE.\n+\t cannot represent in DR_GROUP_GAP or DR_GROUP_SIZE.\n \t ???  As we can handle non-constant step fine here we should\n-\t simply remove uses of GROUP_GAP between the last and first\n-\t element and instead rely on DR_STEP.  GROUP_SIZE then would\n+\t simply remove uses of DR_GROUP_GAP between the last and first\n+\t element and instead rely on DR_STEP.  DR_GROUP_SIZE then would\n \t simply not include that gap.  */\n       if ((dr_step % type_size) != 0)\n \t{\n@@ -2480,7 +2481,7 @@ vect_analyze_group_access_1 (struct data_reference *dr)\n     groupsize = 0;\n \n   /* Not consecutive access is possible only if it is a part of interleaving.  */\n-  if (!GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n+  if (!DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n     {\n       /* Check if it this DR is a part of interleaving, and is a single\n \t element of the group that is accessed in the loop.  */\n@@ -2491,9 +2492,9 @@ vect_analyze_group_access_1 (struct data_reference *dr)\n \t  && (dr_step % type_size) == 0\n \t  && groupsize > 0)\n \t{\n-\t  GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) = stmt;\n-\t  GROUP_SIZE (vinfo_for_stmt (stmt)) = groupsize;\n-\t  GROUP_GAP (stmt_info) = groupsize - 1;\n+\t  DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) = stmt;\n+\t  DR_GROUP_SIZE (vinfo_for_stmt (stmt)) = groupsize;\n+\t  DR_GROUP_GAP (stmt_info) = groupsize - 1;\n \t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location,\n@@ -2526,10 +2527,10 @@ vect_analyze_group_access_1 (struct data_reference *dr)\n       return true;\n     }\n \n-  if (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) == stmt)\n+  if (DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) == stmt)\n     {\n       /* First stmt in the interleaving chain. Check the chain.  */\n-      gimple *next = GROUP_NEXT_ELEMENT (vinfo_for_stmt (stmt));\n+      gimple *next = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (stmt));\n       struct data_reference *data_ref = dr;\n       unsigned int count = 1;\n       tree prev_init = DR_INIT (data_ref);\n@@ -2560,10 +2561,10 @@ vect_analyze_group_access_1 (struct data_reference *dr)\n \t\t\t\t \"Two or more load stmts share the same dr.\\n\");\n \n               /* For load use the same data-ref load.  */\n-              GROUP_SAME_DR_STMT (vinfo_for_stmt (next)) = prev;\n+              DR_GROUP_SAME_DR_STMT (vinfo_for_stmt (next)) = prev;\n \n               prev = next;\n-              next = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next));\n+              next = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (next));\n               continue;\n             }\n \n@@ -2595,11 +2596,11 @@ vect_analyze_group_access_1 (struct data_reference *dr)\n \t  last_accessed_element += diff;\n \n           /* Store the gap from the previous member of the group. If there is no\n-             gap in the access, GROUP_GAP is always 1.  */\n-          GROUP_GAP (vinfo_for_stmt (next)) = diff;\n+             gap in the access, DR_GROUP_GAP is always 1.  */\n+          DR_GROUP_GAP (vinfo_for_stmt (next)) = diff;\n \n           prev_init = DR_INIT (data_ref);\n-          next = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next));\n+          next = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (next));\n           /* Count the number of data-refs in the chain.  */\n           count++;\n         }\n@@ -2632,9 +2633,9 @@ vect_analyze_group_access_1 (struct data_reference *dr)\n \t difference between the groupsize and the last accessed\n \t element.\n \t When there is no gap, this difference should be 0.  */\n-      GROUP_GAP (vinfo_for_stmt (stmt)) = groupsize - last_accessed_element;\n+      DR_GROUP_GAP (vinfo_for_stmt (stmt)) = groupsize - last_accessed_element;\n \n-      GROUP_SIZE (vinfo_for_stmt (stmt)) = groupsize;\n+      DR_GROUP_SIZE (vinfo_for_stmt (stmt)) = groupsize;\n       if (dump_enabled_p ())\n \t{\n \t  dump_printf_loc (MSG_NOTE, vect_location,\n@@ -2646,10 +2647,10 @@ vect_analyze_group_access_1 (struct data_reference *dr)\n \t  dump_printf (MSG_NOTE, \"of size %u starting with \",\n \t\t       (unsigned)groupsize);\n \t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n-\t  if (GROUP_GAP (vinfo_for_stmt (stmt)) != 0)\n+\t  if (DR_GROUP_GAP (vinfo_for_stmt (stmt)) != 0)\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t     \"There is a gap of %u elements after the group\\n\",\n-\t\t\t     GROUP_GAP (vinfo_for_stmt (stmt)));\n+\t\t\t     DR_GROUP_GAP (vinfo_for_stmt (stmt)));\n \t}\n \n       /* SLP: create an SLP data structure for every interleaving group of\n@@ -2678,13 +2679,13 @@ vect_analyze_group_access (struct data_reference *dr)\n     {\n       /* Dissolve the group if present.  */\n       gimple *next;\n-      gimple *stmt = GROUP_FIRST_ELEMENT (vinfo_for_stmt (DR_STMT (dr)));\n+      gimple *stmt = DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (DR_STMT (dr)));\n       while (stmt)\n \t{\n \t  stmt_vec_info vinfo = vinfo_for_stmt (stmt);\n-\t  next = GROUP_NEXT_ELEMENT (vinfo);\n-\t  GROUP_FIRST_ELEMENT (vinfo) = NULL;\n-\t  GROUP_NEXT_ELEMENT (vinfo) = NULL;\n+\t  next = DR_GROUP_NEXT_ELEMENT (vinfo);\n+\t  DR_GROUP_FIRST_ELEMENT (vinfo) = NULL;\n+\t  DR_GROUP_NEXT_ELEMENT (vinfo) = NULL;\n \t  stmt = next;\n \t}\n       return false;\n@@ -2723,7 +2724,7 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n   /* Allow loads with zero step in inner-loop vectorization.  */\n   if (loop_vinfo && integer_zerop (step))\n     {\n-      GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) = NULL;\n+      DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) = NULL;\n       if (!nested_in_vect_loop_p (loop, stmt))\n \treturn DR_IS_READ (dr);\n       /* Allow references with zero step for outer loops marked\n@@ -2742,7 +2743,7 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n     {\n       /* Interleaved accesses are not yet supported within outer-loop\n         vectorization for references in the inner-loop.  */\n-      GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) = NULL;\n+      DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) = NULL;\n \n       /* For the rest of the analysis we use the outer-loop step.  */\n       step = STMT_VINFO_DR_STEP (stmt_info);\n@@ -2764,7 +2765,7 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n \t      && !compare_tree_int (TYPE_SIZE_UNIT (scalar_type), -dr_step)))\n \t{\n \t  /* Mark that it is not interleaving.  */\n-\t  GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) = NULL;\n+\t  DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) = NULL;\n \t  return true;\n \t}\n     }\n@@ -3052,13 +3053,13 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n \t    }\n \n \t  /* Link the found element into the group list.  */\n-\t  if (!GROUP_FIRST_ELEMENT (stmtinfo_a))\n+\t  if (!DR_GROUP_FIRST_ELEMENT (stmtinfo_a))\n \t    {\n-\t      GROUP_FIRST_ELEMENT (stmtinfo_a) = DR_STMT (dra);\n+\t      DR_GROUP_FIRST_ELEMENT (stmtinfo_a) = DR_STMT (dra);\n \t      lastinfo = stmtinfo_a;\n \t    }\n-\t  GROUP_FIRST_ELEMENT (stmtinfo_b) = DR_STMT (dra);\n-\t  GROUP_NEXT_ELEMENT (lastinfo) = DR_STMT (drb);\n+\t  DR_GROUP_FIRST_ELEMENT (stmtinfo_b) = DR_STMT (dra);\n+\t  DR_GROUP_NEXT_ELEMENT (lastinfo) = DR_STMT (drb);\n \t  lastinfo = stmtinfo_b;\n \t}\n     }\n@@ -3119,10 +3120,10 @@ vect_vfa_access_size (data_reference *dr)\n   tree ref_type = TREE_TYPE (DR_REF (dr));\n   unsigned HOST_WIDE_INT ref_size = tree_to_uhwi (TYPE_SIZE_UNIT (ref_type));\n   unsigned HOST_WIDE_INT access_size = ref_size;\n-  if (GROUP_FIRST_ELEMENT (stmt_vinfo))\n+  if (DR_GROUP_FIRST_ELEMENT (stmt_vinfo))\n     {\n-      gcc_assert (GROUP_FIRST_ELEMENT (stmt_vinfo) == DR_STMT (dr));\n-      access_size *= GROUP_SIZE (stmt_vinfo) - GROUP_GAP (stmt_vinfo);\n+      gcc_assert (DR_GROUP_FIRST_ELEMENT (stmt_vinfo) == DR_STMT (dr));\n+      access_size *= DR_GROUP_SIZE (stmt_vinfo) - DR_GROUP_GAP (stmt_vinfo);\n     }\n   if (STMT_VINFO_VEC_STMT (stmt_vinfo)\n       && (vect_supportable_dr_alignment (dr, false)\n@@ -3292,8 +3293,8 @@ vect_small_gap_p (loop_vec_info loop_vinfo, data_reference *dr, poly_int64 gap)\n   stmt_vec_info stmt_info = vinfo_for_stmt (DR_STMT (dr));\n   HOST_WIDE_INT count\n     = estimated_poly_value (LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n-  if (GROUP_FIRST_ELEMENT (stmt_info))\n-    count *= GROUP_SIZE (vinfo_for_stmt (GROUP_FIRST_ELEMENT (stmt_info)));\n+  if (DR_GROUP_FIRST_ELEMENT (stmt_info))\n+    count *= DR_GROUP_SIZE (vinfo_for_stmt (DR_GROUP_FIRST_ELEMENT (stmt_info)));\n   return estimated_poly_value (gap) <= count * vect_get_scalar_dr_size (dr);\n }\n \n@@ -3481,14 +3482,14 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \t  continue;\n \t}\n \n-      dr_group_first_a = GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt_a));\n+      dr_group_first_a = DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt_a));\n       if (dr_group_first_a)\n \t{\n \t  stmt_a = dr_group_first_a;\n \t  dr_a = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt_a));\n \t}\n \n-      dr_group_first_b = GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt_b));\n+      dr_group_first_b = DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt_b));\n       if (dr_group_first_b)\n \t{\n \t  stmt_b = dr_group_first_b;\n@@ -4784,9 +4785,9 @@ vect_create_data_ref_ptr (gimple *stmt, tree aggr_type, struct loop *at_loop,\n \t\t\t      get_alias_set (DR_REF (dr))))\n     need_ref_all = true;\n   /* Likewise for any of the data references in the stmt group.  */\n-  else if (STMT_VINFO_GROUP_SIZE (stmt_info) > 1)\n+  else if (DR_GROUP_SIZE (stmt_info) > 1)\n     {\n-      gimple *orig_stmt = STMT_VINFO_GROUP_FIRST_ELEMENT (stmt_info);\n+      gimple *orig_stmt = DR_GROUP_FIRST_ELEMENT (stmt_info);\n       do\n \t{\n \t  stmt_vec_info sinfo = vinfo_for_stmt (orig_stmt);\n@@ -4797,7 +4798,7 @@ vect_create_data_ref_ptr (gimple *stmt, tree aggr_type, struct loop *at_loop,\n \t      need_ref_all = true;\n \t      break;\n \t    }\n-\t  orig_stmt = STMT_VINFO_GROUP_NEXT_ELEMENT (sinfo);\n+\t  orig_stmt = DR_GROUP_NEXT_ELEMENT (sinfo);\n \t}\n       while (orig_stmt);\n     }\n@@ -6395,7 +6396,7 @@ vect_transform_grouped_load (gimple *stmt, vec<tree> dr_chain, int size,\n void\n vect_record_grouped_load_vectors (gimple *stmt, vec<tree> result_chain)\n {\n-  gimple *first_stmt = GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt));\n+  gimple *first_stmt = DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt));\n   gimple *next_stmt, *new_stmt;\n   unsigned int i, gap_count;\n   tree tmp_data_ref;\n@@ -6413,11 +6414,11 @@ vect_record_grouped_load_vectors (gimple *stmt, vec<tree> result_chain)\n       /* Skip the gaps.  Loads created for the gaps will be removed by dead\n        code elimination pass later.  No need to check for the first stmt in\n        the group, since it always exists.\n-       GROUP_GAP is the number of steps in elements from the previous\n-       access (if there is no gap GROUP_GAP is 1).  We skip loads that\n+       DR_GROUP_GAP is the number of steps in elements from the previous\n+       access (if there is no gap DR_GROUP_GAP is 1).  We skip loads that\n        correspond to the gaps.  */\n       if (next_stmt != first_stmt\n-          && gap_count < GROUP_GAP (vinfo_for_stmt (next_stmt)))\n+          && gap_count < DR_GROUP_GAP (vinfo_for_stmt (next_stmt)))\n       {\n         gap_count++;\n         continue;\n@@ -6433,7 +6434,7 @@ vect_record_grouped_load_vectors (gimple *stmt, vec<tree> result_chain)\n \t    STMT_VINFO_VEC_STMT (vinfo_for_stmt (next_stmt)) = new_stmt;\n \t  else\n             {\n-              if (!GROUP_SAME_DR_STMT (vinfo_for_stmt (next_stmt)))\n+              if (!DR_GROUP_SAME_DR_STMT (vinfo_for_stmt (next_stmt)))\n                 {\n \t\t  gimple *prev_stmt =\n \t\t    STMT_VINFO_VEC_STMT (vinfo_for_stmt (next_stmt));\n@@ -6451,12 +6452,12 @@ vect_record_grouped_load_vectors (gimple *stmt, vec<tree> result_chain)\n                 }\n             }\n \n-\t  next_stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n+\t  next_stmt = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n \t  gap_count = 1;\n \t  /* If NEXT_STMT accesses the same DR as the previous statement,\n \t     put the same TMP_DATA_REF as its vectorized statement; otherwise\n \t     get the next data-ref from RESULT_CHAIN.  */\n-\t  if (!next_stmt || !GROUP_SAME_DR_STMT (vinfo_for_stmt (next_stmt)))\n+\t  if (!next_stmt || !DR_GROUP_SAME_DR_STMT (vinfo_for_stmt (next_stmt)))\n \t    break;\n         }\n     }\n@@ -6598,8 +6599,8 @@ vect_supportable_dr_alignment (struct data_reference *dr,\n \t  if (loop_vinfo\n \t      && STMT_SLP_TYPE (stmt_info)\n \t      && !multiple_p (LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n-\t\t\t      * GROUP_SIZE (vinfo_for_stmt\n-\t\t\t\t\t    (GROUP_FIRST_ELEMENT (stmt_info))),\n+\t\t\t      * DR_GROUP_SIZE (vinfo_for_stmt\n+\t\t\t\t\t    (DR_GROUP_FIRST_ELEMENT (stmt_info))),\n \t\t\t      TYPE_VECTOR_SUBPARTS (vectype)))\n \t    ;\n \t  else if (!loop_vinfo"}, {"sha": "af9177efbb03f07f478fdc3561640ab0cf4173f8", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 60, "deletions": 58, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c53b149b7476fabd329429b2a6dce090f580ff4/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c53b149b7476fabd329429b2a6dce090f580ff4/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=2c53b149b7476fabd329429b2a6dce090f580ff4", "patch": "@@ -598,7 +598,7 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n                   /* Store the reduction cycles for possible vectorization in\n                      loop-aware SLP if it was not detected as reduction\n \t\t     chain.  */\n-\t\t  if (! GROUP_FIRST_ELEMENT (vinfo_for_stmt (reduc_stmt)))\n+\t\t  if (! REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (reduc_stmt)))\n \t\t    LOOP_VINFO_REDUCTIONS (loop_vinfo).safe_push (reduc_stmt);\n                 }\n             }\n@@ -659,16 +659,17 @@ vect_fixup_reduc_chain (gimple *stmt)\n {\n   gimple *firstp = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (stmt));\n   gimple *stmtp;\n-  gcc_assert (!GROUP_FIRST_ELEMENT (vinfo_for_stmt (firstp))\n-\t      && GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)));\n-  GROUP_SIZE (vinfo_for_stmt (firstp)) = GROUP_SIZE (vinfo_for_stmt (stmt));\n+  gcc_assert (!REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (firstp))\n+\t      && REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)));\n+  REDUC_GROUP_SIZE (vinfo_for_stmt (firstp))\n+    = REDUC_GROUP_SIZE (vinfo_for_stmt (stmt));\n   do\n     {\n       stmtp = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (stmt));\n-      GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmtp)) = firstp;\n-      stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (stmt));\n+      REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmtp)) = firstp;\n+      stmt = REDUC_GROUP_NEXT_ELEMENT (vinfo_for_stmt (stmt));\n       if (stmt)\n-\tGROUP_NEXT_ELEMENT (vinfo_for_stmt (stmtp))\n+\tREDUC_GROUP_NEXT_ELEMENT (vinfo_for_stmt (stmtp))\n \t  = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (stmt));\n     }\n   while (stmt);\n@@ -686,12 +687,12 @@ vect_fixup_scalar_cycles_with_patterns (loop_vec_info loop_vinfo)\n   FOR_EACH_VEC_ELT (LOOP_VINFO_REDUCTION_CHAINS (loop_vinfo), i, first)\n     if (STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (first)))\n       {\n-\tgimple *next = GROUP_NEXT_ELEMENT (vinfo_for_stmt (first));\n+\tgimple *next = REDUC_GROUP_NEXT_ELEMENT (vinfo_for_stmt (first));\n \twhile (next)\n \t  {\n \t    if (! STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (next)))\n \t      break;\n-\t    next = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next));\n+\t    next = REDUC_GROUP_NEXT_ELEMENT (vinfo_for_stmt (next));\n \t  }\n \t/* If not all stmt in the chain are patterns try to handle\n \t   the chain without patterns.  */\n@@ -2194,8 +2195,8 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n \t  (SLP_TREE_SCALAR_STMTS (SLP_INSTANCE_TREE (instance))[0]);\n       if (! STMT_VINFO_GROUPED_ACCESS (vinfo))\n \tcontinue;\n-      vinfo = vinfo_for_stmt (STMT_VINFO_GROUP_FIRST_ELEMENT (vinfo));\n-      unsigned int size = STMT_VINFO_GROUP_SIZE (vinfo);\n+      vinfo = vinfo_for_stmt (DR_GROUP_FIRST_ELEMENT (vinfo));\n+      unsigned int size = DR_GROUP_SIZE (vinfo);\n       tree vectype = STMT_VINFO_VECTYPE (vinfo);\n       if (! vect_store_lanes_supported (vectype, size, false)\n \t && ! known_eq (TYPE_VECTOR_SUBPARTS (vectype), 1U)\n@@ -2204,9 +2205,9 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n       FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (instance), j, node)\n \t{\n \t  vinfo = vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (node)[0]);\n-\t  vinfo = vinfo_for_stmt (STMT_VINFO_GROUP_FIRST_ELEMENT (vinfo));\n-\t  bool single_element_p = !STMT_VINFO_GROUP_NEXT_ELEMENT (vinfo);\n-\t  size = STMT_VINFO_GROUP_SIZE (vinfo);\n+\t  vinfo = vinfo_for_stmt (DR_GROUP_FIRST_ELEMENT (vinfo));\n+\t  bool single_element_p = !DR_GROUP_NEXT_ELEMENT (vinfo);\n+\t  size = DR_GROUP_SIZE (vinfo);\n \t  vectype = STMT_VINFO_VECTYPE (vinfo);\n \t  if (! vect_load_lanes_supported (vectype, size, false)\n \t      && ! vect_grouped_load_supported (vectype, single_element_p,\n@@ -2577,12 +2578,12 @@ vect_is_slp_reduction (loop_vec_info loop_info, gimple *phi,\n       if (current_stmt)\n         {\n           current_stmt_info = vinfo_for_stmt (current_stmt);\n-\t  GROUP_NEXT_ELEMENT (current_stmt_info) = loop_use_stmt;\n-          GROUP_FIRST_ELEMENT (use_stmt_info)\n-            = GROUP_FIRST_ELEMENT (current_stmt_info);\n+\t  REDUC_GROUP_NEXT_ELEMENT (current_stmt_info) = loop_use_stmt;\n+          REDUC_GROUP_FIRST_ELEMENT (use_stmt_info)\n+            = REDUC_GROUP_FIRST_ELEMENT (current_stmt_info);\n         }\n       else\n-\tGROUP_FIRST_ELEMENT (use_stmt_info) = loop_use_stmt;\n+\tREDUC_GROUP_FIRST_ELEMENT (use_stmt_info) = loop_use_stmt;\n \n       lhs = gimple_assign_lhs (loop_use_stmt);\n       current_stmt = loop_use_stmt;\n@@ -2595,7 +2596,7 @@ vect_is_slp_reduction (loop_vec_info loop_info, gimple *phi,\n   /* Swap the operands, if needed, to make the reduction operand be the second\n      operand.  */\n   lhs = PHI_RESULT (phi);\n-  next_stmt = GROUP_FIRST_ELEMENT (vinfo_for_stmt (current_stmt));\n+  next_stmt = REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (current_stmt));\n   while (next_stmt)\n     {\n       if (gimple_assign_rhs2 (next_stmt) == lhs)\n@@ -2622,7 +2623,7 @@ vect_is_slp_reduction (loop_vec_info loop_info, gimple *phi,\n                       && !is_loop_header_bb_p (gimple_bb (def_stmt)))))\n \t    {\n \t      lhs = gimple_assign_lhs (next_stmt);\n-\t      next_stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n+\t      next_stmt = REDUC_GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n  \t      continue;\n \t    }\n \n@@ -2670,13 +2671,13 @@ vect_is_slp_reduction (loop_vec_info loop_info, gimple *phi,\n         }\n \n       lhs = gimple_assign_lhs (next_stmt);\n-      next_stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n+      next_stmt = REDUC_GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n     }\n \n   /* Save the chain for further analysis in SLP detection.  */\n-  first = GROUP_FIRST_ELEMENT (vinfo_for_stmt (current_stmt));\n+  first = REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (current_stmt));\n   LOOP_VINFO_REDUCTION_CHAINS (loop_info).safe_push (first);\n-  GROUP_SIZE (vinfo_for_stmt (first)) = size;\n+  REDUC_GROUP_SIZE (vinfo_for_stmt (first)) = size;\n \n   return true;\n }\n@@ -3278,12 +3279,12 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple *phi,\n     }\n \n   /* Dissolve group eventually half-built by vect_is_slp_reduction.  */\n-  gimple *first = GROUP_FIRST_ELEMENT (vinfo_for_stmt (def_stmt));\n+  gimple *first = REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (def_stmt));\n   while (first)\n     {\n-      gimple *next = GROUP_NEXT_ELEMENT (vinfo_for_stmt (first));\n-      GROUP_FIRST_ELEMENT (vinfo_for_stmt (first)) = NULL;\n-      GROUP_NEXT_ELEMENT (vinfo_for_stmt (first)) = NULL;\n+      gimple *next = REDUC_GROUP_NEXT_ELEMENT (vinfo_for_stmt (first));\n+      REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (first)) = NULL;\n+      REDUC_GROUP_NEXT_ELEMENT (vinfo_for_stmt (first)) = NULL;\n       first = next;\n     }\n \n@@ -4270,8 +4271,8 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n      two copies of each scalar operand: {s1, s2, s1, s2}.  (NUMBER_OF_COPIES\n      will be 2).\n \n-     If GROUP_SIZE > NUNITS, the scalars will be split into several vectors\n-     containing the operands.\n+     If REDUC_GROUP_SIZE > NUNITS, the scalars will be split into several\n+     vectors containing the operands.\n \n      For example, NUNITS is four as before, and the group size is 8\n      (s1, s2, ..., s8).  We will create two vectors {s1, s2, s3, s4} and\n@@ -4551,7 +4552,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n       vec_initial_defs.reserve (vec_num);\n       get_initial_defs_for_reduction (slp_node_instance->reduc_phis,\n \t\t\t\t      &vec_initial_defs, vec_num,\n-\t\t\t\t      GROUP_FIRST_ELEMENT (stmt_info),\n+\t\t\t\t      REDUC_GROUP_FIRST_ELEMENT (stmt_info),\n \t\t\t\t      neutral_op);\n     }\n   else\n@@ -4857,7 +4858,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n      # b1 = phi <b2, b0>\n      a2 = operation (a1)\n      b2 = operation (b1)  */\n-  slp_reduc = (slp_node && !GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)));\n+  slp_reduc = (slp_node && !REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)));\n \n   /* True if we should implement SLP_REDUC using native reduction operations\n      instead of scalar operations.  */\n@@ -4872,7 +4873,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n \n      we may end up with more than one vector result.  Here we reduce them to\n      one vector.  */\n-  if (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) || direct_slp_reduc)\n+  if (REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) || direct_slp_reduc)\n     {\n       tree first_vect = PHI_RESULT (new_phis[0]);\n       gassign *new_vec_stmt = NULL;\n@@ -5165,7 +5166,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n     }\n   else if (direct_slp_reduc)\n     {\n-      /* Here we create one vector for each of the GROUP_SIZE results,\n+      /* Here we create one vector for each of the REDUC_GROUP_SIZE results,\n \t with the elements for other SLP statements replaced with the\n \t neutral value.  We can then do a normal reduction on each vector.  */\n \n@@ -5185,7 +5186,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n       tree mask_type = build_same_sized_truth_vector_type (index_type);\n \n       /* Create a vector that, for each element, identifies which of\n-\t the GROUP_SIZE results should use it.  */\n+\t the REDUC_GROUP_SIZE results should use it.  */\n       tree index_mask = build_int_cst (index_elt_type, group_size - 1);\n       index = gimple_build (&seq, BIT_AND_EXPR, index_type, index,\n \t\t\t    build_vector_from_val (index_type, index_mask));\n@@ -5493,8 +5494,8 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n \n           /* The only case where we need to reduce scalar results in SLP, is\n              unrolling.  If the size of SCALAR_RESULTS is greater than\n-             GROUP_SIZE, we reduce them combining elements modulo \n-             GROUP_SIZE.  */\n+             REDUC_GROUP_SIZE, we reduce them combining elements modulo \n+             REDUC_GROUP_SIZE.  */\n           if (slp_reduc)\n             {\n               tree res, first_res, new_res;\n@@ -5614,10 +5615,10 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n \n \n   /* In SLP reduction chain we reduce vector results into one vector if\n-     necessary, hence we set here GROUP_SIZE to 1.  SCALAR_DEST is the LHS of\n-     the last stmt in the reduction chain, since we are looking for the loop\n-     exit phi node.  */\n-  if (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n+     necessary, hence we set here REDUC_GROUP_SIZE to 1.  SCALAR_DEST is the\n+     LHS of the last stmt in the reduction chain, since we are looking for\n+     the loop exit phi node.  */\n+  if (REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n     {\n       gimple *dest_stmt = SLP_TREE_SCALAR_STMTS (slp_node)[group_size - 1];\n       /* Handle reduction patterns.  */\n@@ -5628,12 +5629,12 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n       group_size = 1;\n     }\n \n-  /* In SLP we may have several statements in NEW_PHIS and REDUCTION_PHIS (in \n-     case that GROUP_SIZE is greater than vectorization factor).  Therefore, we\n-     need to match SCALAR_RESULTS with corresponding statements.  The first\n-     (GROUP_SIZE / number of new vector stmts) scalar results correspond to\n-     the first vector stmt, etc.  \n-     (RATIO is equal to (GROUP_SIZE / number of new vector stmts)).  */ \n+  /* In SLP we may have several statements in NEW_PHIS and REDUCTION_PHIS (in\n+     case that REDUC_GROUP_SIZE is greater than vectorization factor).\n+     Therefore, we need to match SCALAR_RESULTS with corresponding statements.\n+     The first (REDUC_GROUP_SIZE / number of new vector stmts) scalar results\n+     correspond to the first vector stmt, etc.\n+     (RATIO is equal to (REDUC_GROUP_SIZE / number of new vector stmts)).  */\n   if (group_size > new_phis.length ())\n     {\n       ratio = group_size / new_phis.length ();\n@@ -6184,10 +6185,10 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   /* In case of reduction chain we switch to the first stmt in the chain, but\n      we don't update STMT_INFO, since only the last stmt is marked as reduction\n      and has reduction properties.  */\n-  if (GROUP_FIRST_ELEMENT (stmt_info)\n-      && GROUP_FIRST_ELEMENT (stmt_info) != stmt)\n+  if (REDUC_GROUP_FIRST_ELEMENT (stmt_info)\n+      && REDUC_GROUP_FIRST_ELEMENT (stmt_info) != stmt)\n     {\n-      stmt = GROUP_FIRST_ELEMENT (stmt_info);\n+      stmt = REDUC_GROUP_FIRST_ELEMENT (stmt_info);\n       first_p = false;\n     }\n \n@@ -6299,7 +6300,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   /* Not supportable if the reduction variable is used in the loop, unless\n      it's a reduction chain.  */\n   if (STMT_VINFO_RELEVANT (stmt_info) > vect_used_in_outer\n-      && !GROUP_FIRST_ELEMENT (stmt_info))\n+      && !REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n     return false;\n \n   /* Reductions that are not used even in an enclosing outer-loop,\n@@ -6604,12 +6605,13 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   if (orig_stmt)\n     gcc_assert (tmp == orig_stmt\n-\t\t|| GROUP_FIRST_ELEMENT (vinfo_for_stmt (tmp)) == orig_stmt);\n+\t\t|| (REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (tmp))\n+\t\t    == orig_stmt));\n   else\n     /* We changed STMT to be the first stmt in reduction chain, hence we\n        check that in this case the first element in the chain is STMT.  */\n     gcc_assert (stmt == tmp\n-\t\t|| GROUP_FIRST_ELEMENT (vinfo_for_stmt (tmp)) == stmt);\n+\t\t|| REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (tmp)) == stmt);\n \n   if (STMT_VINFO_LIVE_P (vinfo_for_stmt (reduc_def_stmt)))\n     return false;\n@@ -6843,9 +6845,9 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   /* For SLP reductions, see if there is a neutral value we can use.  */\n   tree neutral_op = NULL_TREE;\n   if (slp_node)\n-    neutral_op\n-      = neutral_op_for_slp_reduction (slp_node_instance->reduc_phis, code,\n-\t\t\t\t      GROUP_FIRST_ELEMENT (stmt_info) != NULL);\n+    neutral_op = neutral_op_for_slp_reduction\n+\t\t   (slp_node_instance->reduc_phis, code,\n+\t\t    REDUC_GROUP_FIRST_ELEMENT (stmt_info) != NULL);\n \n   if (double_reduc && reduction_type == FOLD_LEFT_REDUCTION)\n     {\n@@ -6872,7 +6874,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   if (reduction_type == FOLD_LEFT_REDUCTION\n       && slp_node\n-      && !GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n+      && !REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n     {\n       /* We cannot use in-order reductions in this case because there is\n \t an implicit reassociation of the operations involved.  */\n@@ -6901,7 +6903,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   /* Check extra constraints for variable-length unchained SLP reductions.  */\n   if (STMT_SLP_TYPE (stmt_info)\n-      && !GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt))\n+      && !REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt))\n       && !nunits_out.is_constant ())\n     {\n       /* We checked above that we could build the initial vector when\n@@ -8635,7 +8637,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t\t     interleaving chain was completed - free all the stores in\n \t\t     the chain.  */\n \t\t  gsi_next (&si);\n-\t\t  vect_remove_stores (GROUP_FIRST_ELEMENT (stmt_info));\n+\t\t  vect_remove_stores (DR_GROUP_FIRST_ELEMENT (stmt_info));\n \t\t}\n \t      else\n \t\t{"}, {"sha": "75bf84b7645187406e8273c7b368757cb2eb7caa", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c53b149b7476fabd329429b2a6dce090f580ff4/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c53b149b7476fabd329429b2a6dce090f580ff4/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=2c53b149b7476fabd329429b2a6dce090f580ff4", "patch": "@@ -231,7 +231,7 @@ vect_reassociating_reduction_p (stmt_vec_info stmt_vinfo)\n {\n   return (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def\n \t  ? STMT_VINFO_REDUC_TYPE (stmt_vinfo) != FOLD_LEFT_REDUCTION\n-\t  : GROUP_FIRST_ELEMENT (stmt_vinfo) != NULL);\n+\t  : REDUC_GROUP_FIRST_ELEMENT (stmt_vinfo) != NULL);\n }\n \n /* Function vect_recog_dot_prod_pattern"}, {"sha": "27c316e8ad8610180d746ef19b22946f9c7355cf", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 77, "deletions": 65, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c53b149b7476fabd329429b2a6dce090f580ff4/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c53b149b7476fabd329429b2a6dce090f580ff4/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=2c53b149b7476fabd329429b2a6dce090f580ff4", "patch": "@@ -195,16 +195,16 @@ vect_get_place_in_interleaving_chain (gimple *stmt, gimple *first_stmt)\n   gimple *next_stmt = first_stmt;\n   int result = 0;\n \n-  if (first_stmt != GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n+  if (first_stmt != DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n     return -1;\n \n   do\n     {\n       if (next_stmt == stmt)\n \treturn result;\n-      next_stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n+      next_stmt = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n       if (next_stmt)\n-\tresult += GROUP_GAP (vinfo_for_stmt (next_stmt));\n+\tresult += DR_GROUP_GAP (vinfo_for_stmt (next_stmt));\n     }\n   while (next_stmt);\n \n@@ -906,7 +906,7 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t  else\n \t    {\n \t      /* Load.  */\n-              first_load = GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt));\n+              first_load = DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt));\n               if (prev_first_load)\n                 {\n                   /* Check that there are no loads from different interleaving\n@@ -1182,8 +1182,8 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t  FOR_EACH_VEC_ELT (stmts, i, stmt)\n \t    {\n \t      /* But for reduction chains only check on the first stmt.  */\n-\t      if (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt))\n-\t\t  && GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) != stmt)\n+\t      if (REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt))\n+\t\t  && REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) != stmt)\n \t\tcontinue;\n \t      if (STMT_VINFO_DEF_TYPE (vinfo_for_stmt (stmt)) != def_type)\n \t\treturn NULL;\n@@ -1660,12 +1660,12 @@ vect_attempt_slp_rearrange_stmts (slp_instance slp_instn)\n   FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (slp_instn), i, node)\n     {\n       gimple *first_stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n-      first_stmt = GROUP_FIRST_ELEMENT (vinfo_for_stmt (first_stmt));\n+      first_stmt = DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (first_stmt));\n       /* But we have to keep those permutations that are required because\n          of handling of gaps.  */\n       if (known_eq (unrolling_factor, 1U)\n-\t  || (group_size == GROUP_SIZE (vinfo_for_stmt (first_stmt))\n-\t      && GROUP_GAP (vinfo_for_stmt (first_stmt)) == 0))\n+\t  || (group_size == DR_GROUP_SIZE (vinfo_for_stmt (first_stmt))\n+\t      && DR_GROUP_GAP (vinfo_for_stmt (first_stmt)) == 0))\n \tSLP_TREE_LOAD_PERMUTATION (node).release ();\n       else\n \tfor (j = 0; j < SLP_TREE_LOAD_PERMUTATION (node).length (); ++j)\n@@ -1718,7 +1718,7 @@ vect_supported_load_permutation_p (slp_instance slp_instn)\n   /* Reduction (there are no data-refs in the root).\n      In reduction chain the order of the loads is not important.  */\n   if (!STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt))\n-      && !GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n+      && !REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n     vect_attempt_slp_rearrange_stmts (slp_instn);\n \n   /* In basic block vectorization we allow any subchain of an interleaving\n@@ -1738,30 +1738,30 @@ vect_supported_load_permutation_p (slp_instance slp_instn)\n             {\n               if (j != 0\n \t\t  && (next_load != load\n-\t\t      || GROUP_GAP (vinfo_for_stmt (load)) != 1))\n+\t\t      || DR_GROUP_GAP (vinfo_for_stmt (load)) != 1))\n \t\t{\n \t\t  subchain_p = false;\n \t\t  break;\n \t\t}\n-              next_load = GROUP_NEXT_ELEMENT (vinfo_for_stmt (load));\n+              next_load = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (load));\n             }\n \t  if (subchain_p)\n \t    SLP_TREE_LOAD_PERMUTATION (node).release ();\n \t  else\n \t    {\n \t      stmt_vec_info group_info\n \t\t= vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (node)[0]);\n-\t      group_info = vinfo_for_stmt (GROUP_FIRST_ELEMENT (group_info));\n+\t      group_info = vinfo_for_stmt (DR_GROUP_FIRST_ELEMENT (group_info));\n \t      unsigned HOST_WIDE_INT nunits;\n \t      unsigned k, maxk = 0;\n \t      FOR_EACH_VEC_ELT (SLP_TREE_LOAD_PERMUTATION (node), j, k)\n \t\tif (k > maxk)\n \t\t  maxk = k;\n \t      /* In BB vectorization we may not actually use a loaded vector\n-\t\t accessing elements in excess of GROUP_SIZE.  */\n+\t\t accessing elements in excess of DR_GROUP_SIZE.  */\n \t      tree vectype = STMT_VINFO_VECTYPE (group_info);\n \t      if (!TYPE_VECTOR_SUBPARTS (vectype).is_constant (&nunits)\n-\t\t  || maxk >= (GROUP_SIZE (group_info) & ~(nunits - 1)))\n+\t\t  || maxk >= (DR_GROUP_SIZE (group_info) & ~(nunits - 1)))\n \t\t{\n \t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t   \"BB vectorization with gaps at the end of \"\n@@ -1834,36 +1834,36 @@ static gimple *\n vect_split_slp_store_group (gimple *first_stmt, unsigned group1_size)\n {\n   stmt_vec_info first_vinfo = vinfo_for_stmt (first_stmt);\n-  gcc_assert (GROUP_FIRST_ELEMENT (first_vinfo) == first_stmt);\n+  gcc_assert (DR_GROUP_FIRST_ELEMENT (first_vinfo) == first_stmt);\n   gcc_assert (group1_size > 0);\n-  int group2_size = GROUP_SIZE (first_vinfo) - group1_size;\n+  int group2_size = DR_GROUP_SIZE (first_vinfo) - group1_size;\n   gcc_assert (group2_size > 0);\n-  GROUP_SIZE (first_vinfo) = group1_size;\n+  DR_GROUP_SIZE (first_vinfo) = group1_size;\n \n   gimple *stmt = first_stmt;\n   for (unsigned i = group1_size; i > 1; i--)\n     {\n-      stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (stmt));\n-      gcc_assert (GROUP_GAP (vinfo_for_stmt (stmt)) == 1);\n+      stmt = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (stmt));\n+      gcc_assert (DR_GROUP_GAP (vinfo_for_stmt (stmt)) == 1);\n     }\n   /* STMT is now the last element of the first group.  */\n-  gimple *group2 = GROUP_NEXT_ELEMENT (vinfo_for_stmt (stmt));\n-  GROUP_NEXT_ELEMENT (vinfo_for_stmt (stmt)) = 0;\n+  gimple *group2 = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (stmt));\n+  DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (stmt)) = 0;\n \n-  GROUP_SIZE (vinfo_for_stmt (group2)) = group2_size;\n-  for (stmt = group2; stmt; stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (stmt)))\n+  DR_GROUP_SIZE (vinfo_for_stmt (group2)) = group2_size;\n+  for (stmt = group2; stmt; stmt = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (stmt)))\n     {\n-      GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) = group2;\n-      gcc_assert (GROUP_GAP (vinfo_for_stmt (stmt)) == 1);\n+      DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) = group2;\n+      gcc_assert (DR_GROUP_GAP (vinfo_for_stmt (stmt)) == 1);\n     }\n \n-  /* For the second group, the GROUP_GAP is that before the original group,\n+  /* For the second group, the DR_GROUP_GAP is that before the original group,\n      plus skipping over the first vector.  */\n-  GROUP_GAP (vinfo_for_stmt (group2)) =\n-    GROUP_GAP (first_vinfo) + group1_size;\n+  DR_GROUP_GAP (vinfo_for_stmt (group2))\n+    = DR_GROUP_GAP (first_vinfo) + group1_size;\n \n-  /* GROUP_GAP of the first group now has to skip over the second group too.  */\n-  GROUP_GAP (first_vinfo) += group2_size;\n+  /* DR_GROUP_GAP of the first group now has to skip over the second group too.  */\n+  DR_GROUP_GAP (first_vinfo) += group2_size;\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location, \"Split group into %d and %d\\n\",\n@@ -1891,28 +1891,25 @@ vect_analyze_slp_instance (vec_info *vinfo,\n {\n   slp_instance new_instance;\n   slp_tree node;\n-  unsigned int group_size = GROUP_SIZE (vinfo_for_stmt (stmt));\n+  unsigned int group_size;\n   tree vectype, scalar_type = NULL_TREE;\n   gimple *next;\n   unsigned int i;\n   vec<slp_tree> loads;\n   struct data_reference *dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt));\n   vec<gimple *> scalar_stmts;\n \n-  if (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n+  if (STMT_VINFO_GROUPED_ACCESS (vinfo_for_stmt (stmt)))\n     {\n-      if (dr)\n-        {\n-          scalar_type = TREE_TYPE (DR_REF (dr));\n-          vectype = get_vectype_for_scalar_type (scalar_type);\n-        }\n-      else\n-        {\n-          gcc_assert (is_a <loop_vec_info> (vinfo));\n-          vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt));\n-        }\n-\n-      group_size = GROUP_SIZE (vinfo_for_stmt (stmt));\n+      scalar_type = TREE_TYPE (DR_REF (dr));\n+      vectype = get_vectype_for_scalar_type (scalar_type);\n+      group_size = DR_GROUP_SIZE (vinfo_for_stmt (stmt));\n+    }\n+  else if (!dr && REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n+    {\n+      gcc_assert (is_a <loop_vec_info> (vinfo));\n+      vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt));\n+      group_size = REDUC_GROUP_SIZE (vinfo_for_stmt (stmt));\n     }\n   else\n     {\n@@ -1938,7 +1935,7 @@ vect_analyze_slp_instance (vec_info *vinfo,\n   /* Create a node (a root of the SLP tree) for the packed grouped stores.  */\n   scalar_stmts.create (group_size);\n   next = stmt;\n-  if (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n+  if (STMT_VINFO_GROUPED_ACCESS (vinfo_for_stmt (stmt)))\n     {\n       /* Collect the stores and store them in SLP_TREE_SCALAR_STMTS.  */\n       while (next)\n@@ -1949,13 +1946,27 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t\t  STMT_VINFO_RELATED_STMT (vinfo_for_stmt (next)));\n \t  else\n             scalar_stmts.safe_push (next);\n-          next = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next));\n+          next = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (next));\n+        }\n+    }\n+  else if (!dr && REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n+    {\n+      /* Collect the reduction stmts and store them in\n+\t SLP_TREE_SCALAR_STMTS.  */\n+      while (next)\n+        {\n+\t  if (STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (next))\n+\t      && STMT_VINFO_RELATED_STMT (vinfo_for_stmt (next)))\n+\t    scalar_stmts.safe_push (\n+\t\t  STMT_VINFO_RELATED_STMT (vinfo_for_stmt (next)));\n+\t  else\n+            scalar_stmts.safe_push (next);\n+          next = REDUC_GROUP_NEXT_ELEMENT (vinfo_for_stmt (next));\n         }\n       /* Mark the first element of the reduction chain as reduction to properly\n \t transform the node.  In the reduction analysis phase only the last\n \t element of the chain is marked as reduction.  */\n-      if (!STMT_VINFO_GROUPED_ACCESS (vinfo_for_stmt (stmt)))\n-\tSTMT_VINFO_DEF_TYPE (vinfo_for_stmt (stmt)) = vect_reduction_def;\n+      STMT_VINFO_DEF_TYPE (vinfo_for_stmt (stmt)) = vect_reduction_def;\n     }\n   else\n     {\n@@ -2022,7 +2033,7 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t  gimple *load, *first_stmt;\n \t  bool this_load_permuted = false;\n \t  load_permutation.create (group_size);\n-\t  first_stmt = GROUP_FIRST_ELEMENT\n+\t  first_stmt = DR_GROUP_FIRST_ELEMENT\n \t      (vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (load_node)[0]));\n \t  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (load_node), j, load)\n \t    {\n@@ -2038,8 +2049,8 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t         a gap either because the group is larger than the SLP\n \t\t group-size or because there is a gap between the groups.  */\n \t      && (known_eq (unrolling_factor, 1U)\n-\t\t  || (group_size == GROUP_SIZE (vinfo_for_stmt (first_stmt))\n-\t\t      && GROUP_GAP (vinfo_for_stmt (first_stmt)) == 0)))\n+\t\t  || (group_size == DR_GROUP_SIZE (vinfo_for_stmt (first_stmt))\n+\t\t      && DR_GROUP_GAP (vinfo_for_stmt (first_stmt)) == 0)))\n \t    {\n \t      load_permutation.release ();\n \t      continue;\n@@ -2074,15 +2085,15 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t  slp_tree load_node;\n \t  FOR_EACH_VEC_ELT (loads, i, load_node)\n \t    {\n-\t      gimple *first_stmt = GROUP_FIRST_ELEMENT\n+\t      gimple *first_stmt = DR_GROUP_FIRST_ELEMENT\n \t\t  (vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (load_node)[0]));\n \t      stmt_vec_info stmt_vinfo = vinfo_for_stmt (first_stmt);\n \t\t  /* Use SLP for strided accesses (or if we\n \t\t     can't load-lanes).  */\n \t      if (STMT_VINFO_STRIDED_P (stmt_vinfo)\n \t\t  || ! vect_load_lanes_supported\n \t\t\t(STMT_VINFO_VECTYPE (stmt_vinfo),\n-\t\t\t GROUP_SIZE (stmt_vinfo), false))\n+\t\t\t DR_GROUP_SIZE (stmt_vinfo), false))\n \t\tbreak;\n \t    }\n \t  if (i == loads.length ())\n@@ -2120,8 +2131,8 @@ vect_analyze_slp_instance (vec_info *vinfo,\n      vector size.  */\n   unsigned HOST_WIDE_INT const_nunits;\n   if (is_a <bb_vec_info> (vinfo)\n-      && GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt))\n       && STMT_VINFO_GROUPED_ACCESS (vinfo_for_stmt (stmt))\n+      && DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt))\n       && nunits.is_constant (&const_nunits))\n     {\n       /* We consider breaking the group only on VF boundaries from the existing\n@@ -2187,9 +2198,9 @@ vect_analyze_slp (vec_info *vinfo, unsigned max_tree_size)\n \t\twhile (stmt)\n \t\t  {\n \t\t    stmt_vec_info vinfo = vinfo_for_stmt (stmt);\n-\t\t    next = GROUP_NEXT_ELEMENT (vinfo);\n-\t\t    GROUP_FIRST_ELEMENT (vinfo) = NULL;\n-\t\t    GROUP_NEXT_ELEMENT (vinfo) = NULL;\n+\t\t    next = REDUC_GROUP_NEXT_ELEMENT (vinfo);\n+\t\t    REDUC_GROUP_FIRST_ELEMENT (vinfo) = NULL;\n+\t\t    REDUC_GROUP_NEXT_ELEMENT (vinfo) = NULL;\n \t\t    stmt = next;\n \t\t  }\n \t\tSTMT_VINFO_DEF_TYPE (vinfo_for_stmt (first_element))\n@@ -2521,10 +2532,10 @@ vect_slp_analyze_node_operations_1 (vec_info *vinfo, slp_tree node,\n      scalar stmts in this node.  For SLP reductions it is equal to the\n      number of vector statements in the children (which has already been\n      calculated by the recursive call).  Otherwise it is the number of\n-     scalar elements in one scalar iteration (GROUP_SIZE) multiplied by\n+     scalar elements in one scalar iteration (DR_GROUP_SIZE) multiplied by\n      VF divided by the number of elements in a vector.  */\n-  if (GROUP_FIRST_ELEMENT (stmt_info)\n-      && !STMT_VINFO_GROUPED_ACCESS (stmt_info))\n+  if (!STMT_VINFO_GROUPED_ACCESS (stmt_info)\n+      && REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n     SLP_TREE_NUMBER_OF_VEC_STMTS (node)\n       = SLP_TREE_NUMBER_OF_VEC_STMTS (SLP_TREE_CHILDREN (node)[0]);\n   else\n@@ -3654,7 +3665,7 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n   if (!STMT_VINFO_GROUPED_ACCESS (stmt_info))\n     return false;\n \n-  stmt_info = vinfo_for_stmt (GROUP_FIRST_ELEMENT (stmt_info));\n+  stmt_info = vinfo_for_stmt (DR_GROUP_FIRST_ELEMENT (stmt_info));\n \n   mode = TYPE_MODE (vectype);\n \n@@ -3711,7 +3722,7 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n       for (int k = 0; k < group_size; k++)\n \t{\n \t  unsigned int i = (SLP_TREE_LOAD_PERMUTATION (node)[k]\n-\t\t\t    + j * STMT_VINFO_GROUP_SIZE (stmt_info));\n+\t\t\t    + j * DR_GROUP_SIZE (stmt_info));\n \t  vec_index = i / nunits;\n \t  mask_element = i % nunits;\n \t  if (vec_index == first_vec_index\n@@ -3878,8 +3889,9 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n   /* Mark the first element of the reduction chain as reduction to properly\n      transform the node.  In the analysis phase only the last element of the\n      chain is marked as reduction.  */\n-  if (GROUP_FIRST_ELEMENT (stmt_info) && !STMT_VINFO_GROUPED_ACCESS (stmt_info)\n-      && GROUP_FIRST_ELEMENT (stmt_info) == stmt)\n+  if (!STMT_VINFO_GROUPED_ACCESS (stmt_info)\n+      && REDUC_GROUP_FIRST_ELEMENT (stmt_info)\n+      && REDUC_GROUP_FIRST_ELEMENT (stmt_info) == stmt)\n     {\n       STMT_VINFO_DEF_TYPE (stmt_info) = vect_reduction_def;\n       STMT_VINFO_TYPE (stmt_info) = reduc_vec_info_type;"}, {"sha": "66c78de8e2ace3da4c81dc87b91fd78ead5ed306", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c53b149b7476fabd329429b2a6dce090f580ff4/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c53b149b7476fabd329429b2a6dce090f580ff4/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=2c53b149b7476fabd329429b2a6dce090f580ff4", "patch": "@@ -1017,7 +1017,7 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n      so we want the DR for the first statement.  */\n   if (!slp_node && grouped_access_p)\n     {\n-      first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n+      first_stmt = DR_GROUP_FIRST_ELEMENT (stmt_info);\n       dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n     }\n \n@@ -1027,15 +1027,15 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n   bool first_stmt_p = (first_stmt == STMT_VINFO_STMT (stmt_info));\n \n   /* We assume that the cost of a single store-lanes instruction is\n-     equivalent to the cost of GROUP_SIZE separate stores.  If a grouped\n+     equivalent to the cost of DR_GROUP_SIZE separate stores.  If a grouped\n      access is instead being provided by a permute-and-store operation,\n      include the cost of the permutes.  */\n   if (first_stmt_p\n       && memory_access_type == VMAT_CONTIGUOUS_PERMUTE)\n     {\n       /* Uses a high and low interleave or shuffle operations for each\n \t needed permute.  */\n-      int group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n+      int group_size = DR_GROUP_SIZE (vinfo_for_stmt (first_stmt));\n       int nstmts = ncopies * ceil_log2 (group_size) * group_size;\n       inside_cost = record_stmt_cost (cost_vec, nstmts, vec_perm,\n \t\t\t\t      stmt_info, 0, vect_body);\n@@ -1159,7 +1159,7 @@ vect_model_load_cost (stmt_vec_info stmt_info, unsigned ncopies,\n     {\n       /* If the load is permuted then the alignment is determined by\n \t the first group element not by the first scalar stmt DR.  */\n-      gimple *stmt = GROUP_FIRST_ELEMENT (stmt_info);\n+      gimple *stmt = DR_GROUP_FIRST_ELEMENT (stmt_info);\n       stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n       /* Record the cost for the permutation.  */\n       unsigned n_perms;\n@@ -1173,14 +1173,14 @@ vect_model_load_cost (stmt_vec_info stmt_info, unsigned ncopies,\n \t\t\t\t       stmt_info, 0, vect_body);\n       /* And adjust the number of loads performed.  This handles\n \t redundancies as well as loads that are later dead.  */\n-      auto_sbitmap perm (GROUP_SIZE (stmt_info));\n+      auto_sbitmap perm (DR_GROUP_SIZE (stmt_info));\n       bitmap_clear (perm);\n       for (unsigned i = 0;\n \t   i < SLP_TREE_LOAD_PERMUTATION (slp_node).length (); ++i)\n \tbitmap_set_bit (perm, SLP_TREE_LOAD_PERMUTATION (slp_node)[i]);\n       ncopies = 0;\n       bool load_seen = false;\n-      for (unsigned i = 0; i < GROUP_SIZE (stmt_info); ++i)\n+      for (unsigned i = 0; i < DR_GROUP_SIZE (stmt_info); ++i)\n \t{\n \t  if (i % assumed_nunits == 0)\n \t    {\n@@ -1194,7 +1194,7 @@ vect_model_load_cost (stmt_vec_info stmt_info, unsigned ncopies,\n       if (load_seen)\n \tncopies++;\n       gcc_assert (ncopies\n-\t\t  <= (GROUP_SIZE (stmt_info) - GROUP_GAP (stmt_info)\n+\t\t  <= (DR_GROUP_SIZE (stmt_info) - DR_GROUP_GAP (stmt_info)\n \t\t      + assumed_nunits - 1) / assumed_nunits);\n     }\n \n@@ -1205,7 +1205,7 @@ vect_model_load_cost (stmt_vec_info stmt_info, unsigned ncopies,\n      so we want the DR for the first statement.  */\n   if (!slp_node && grouped_access_p)\n     {\n-      first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n+      first_stmt = DR_GROUP_FIRST_ELEMENT (stmt_info);\n       dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n     }\n \n@@ -1215,15 +1215,15 @@ vect_model_load_cost (stmt_vec_info stmt_info, unsigned ncopies,\n   bool first_stmt_p = (first_stmt == STMT_VINFO_STMT (stmt_info));\n \n   /* We assume that the cost of a single load-lanes instruction is\n-     equivalent to the cost of GROUP_SIZE separate loads.  If a grouped\n+     equivalent to the cost of DR_GROUP_SIZE separate loads.  If a grouped\n      access is instead being provided by a load-and-permute operation,\n      include the cost of the permutes.  */\n   if (first_stmt_p\n       && memory_access_type == VMAT_CONTIGUOUS_PERMUTE)\n     {\n       /* Uses an even and odd extract operations or shuffle operations\n \t for each needed permute.  */\n-      int group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n+      int group_size = DR_GROUP_SIZE (vinfo_for_stmt (first_stmt));\n       int nstmts = ncopies * ceil_log2 (group_size) * group_size;\n       inside_cost += record_stmt_cost (cost_vec, nstmts, vec_perm,\n \t\t\t\t       stmt_info, 0, vect_body);\n@@ -2211,12 +2211,12 @@ get_group_load_store_type (gimple *stmt, tree vectype, bool slp,\n   vec_info *vinfo = stmt_info->vinfo;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = loop_vinfo ? LOOP_VINFO_LOOP (loop_vinfo) : NULL;\n-  gimple *first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n+  gimple *first_stmt = DR_GROUP_FIRST_ELEMENT (stmt_info);\n   data_reference *first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n-  unsigned int group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n+  unsigned int group_size = DR_GROUP_SIZE (vinfo_for_stmt (first_stmt));\n   bool single_element_p = (stmt == first_stmt\n-\t\t\t   && !GROUP_NEXT_ELEMENT (stmt_info));\n-  unsigned HOST_WIDE_INT gap = GROUP_GAP (vinfo_for_stmt (first_stmt));\n+\t\t\t   && !DR_GROUP_NEXT_ELEMENT (stmt_info));\n+  unsigned HOST_WIDE_INT gap = DR_GROUP_GAP (vinfo_for_stmt (first_stmt));\n   poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n \n   /* True if the vectorized statements would access beyond the last\n@@ -2241,7 +2241,7 @@ get_group_load_store_type (gimple *stmt, tree vectype, bool slp,\n     {\n       if (STMT_VINFO_STRIDED_P (stmt_info))\n \t{\n-\t  /* Try to use consecutive accesses of GROUP_SIZE elements,\n+\t  /* Try to use consecutive accesses of DR_GROUP_SIZE elements,\n \t     separated by the stride, until we have a complete vector.\n \t     Fall back to scalar accesses if that isn't possible.  */\n \t  if (multiple_p (nunits, group_size))\n@@ -2347,7 +2347,7 @@ get_group_load_store_type (gimple *stmt, tree vectype, bool slp,\n     {\n       /* STMT is the leader of the group. Check the operands of all the\n \t stmts of the group.  */\n-      gimple *next_stmt = GROUP_NEXT_ELEMENT (stmt_info);\n+      gimple *next_stmt = DR_GROUP_NEXT_ELEMENT (stmt_info);\n       while (next_stmt)\n \t{\n \t  tree op = vect_get_store_rhs (next_stmt);\n@@ -2360,7 +2360,7 @@ get_group_load_store_type (gimple *stmt, tree vectype, bool slp,\n \t\t\t\t \"use not simple.\\n\");\n \t      return false;\n \t    }\n-\t  next_stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n+\t  next_stmt = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n \t}\n     }\n \n@@ -2512,9 +2512,9 @@ get_load_store_type (gimple *stmt, tree vectype, bool slp, bool masked_p,\n      traditional behavior until that can be fixed.  */\n   if (*memory_access_type == VMAT_ELEMENTWISE\n       && !STMT_VINFO_STRIDED_P (stmt_info)\n-      && !(stmt == GROUP_FIRST_ELEMENT (stmt_info)\n-\t   && !GROUP_NEXT_ELEMENT (stmt_info)\n-\t   && !pow2p_hwi (GROUP_SIZE (stmt_info))))\n+      && !(stmt == DR_GROUP_FIRST_ELEMENT (stmt_info)\n+\t   && !DR_GROUP_NEXT_ELEMENT (stmt_info)\n+\t   && !pow2p_hwi (DR_GROUP_SIZE (stmt_info))))\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -6182,7 +6182,7 @@ get_group_alias_ptr_type (gimple *first_stmt)\n   gimple *next_stmt;\n \n   first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n-  next_stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (first_stmt));\n+  next_stmt = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (first_stmt));\n   while (next_stmt)\n     {\n       next_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (next_stmt));\n@@ -6194,7 +6194,7 @@ get_group_alias_ptr_type (gimple *first_stmt)\n \t\t\t     \"conflicting alias set types.\\n\");\n \t  return ptr_type_node;\n \t}\n-      next_stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n+      next_stmt = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n     }\n   return reference_alias_ptr_type (DR_REF (first_dr));\n }\n@@ -6385,9 +6385,9 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t   && (slp || memory_access_type != VMAT_CONTIGUOUS));\n   if (grouped_store)\n     {\n-      first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n+      first_stmt = DR_GROUP_FIRST_ELEMENT (stmt_info);\n       first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n-      group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n+      group_size = DR_GROUP_SIZE (vinfo_for_stmt (first_stmt));\n     }\n   else\n     {\n@@ -6568,8 +6568,8 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n   if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n     {\n-      gimple *group_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n-      GROUP_STORE_COUNT (vinfo_for_stmt (group_stmt))++;\n+      gimple *group_stmt = DR_GROUP_FIRST_ELEMENT (stmt_info);\n+      DR_GROUP_STORE_COUNT (vinfo_for_stmt (group_stmt))++;\n     }\n \n   if (grouped_store)\n@@ -6579,8 +6579,8 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n       /* We vectorize all the stmts of the interleaving group when we\n \t reach the last stmt in the group.  */\n-      if (GROUP_STORE_COUNT (vinfo_for_stmt (first_stmt))\n-\t  < GROUP_SIZE (vinfo_for_stmt (first_stmt))\n+      if (DR_GROUP_STORE_COUNT (vinfo_for_stmt (first_stmt))\n+\t  < DR_GROUP_SIZE (vinfo_for_stmt (first_stmt))\n \t  && !slp)\n \t{\n \t  *vec_stmt = NULL;\n@@ -6594,7 +6594,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n              group.  */\n           vec_num = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n           first_stmt = SLP_TREE_SCALAR_STMTS (slp_node)[0]; \n-\t  gcc_assert (GROUP_FIRST_ELEMENT (vinfo_for_stmt (first_stmt)) == first_stmt);\n+\t  gcc_assert (DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (first_stmt)) == first_stmt);\n           first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n \t  op = vect_get_store_rhs (first_stmt);\n         } \n@@ -6848,7 +6848,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t    }\n \t\t}\n \t    }\n-\t  next_stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n+\t  next_stmt = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n \t  if (slp)\n \t    break;\n \t}\n@@ -6965,21 +6965,21 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t used as an input to vect_permute_store_chain(), and OPRNDS as\n \t\t an input to vect_get_vec_def_for_stmt_copy() for the next copy.\n \n-\t\t If the store is not grouped, GROUP_SIZE is 1, and DR_CHAIN and\n+\t\t If the store is not grouped, DR_GROUP_SIZE is 1, and DR_CHAIN and\n \t\t OPRNDS are of size 1.  */\n \t      next_stmt = first_stmt;\n \t      for (i = 0; i < group_size; i++)\n \t\t{\n \t\t  /* Since gaps are not supported for interleaved stores,\n-\t\t     GROUP_SIZE is the exact number of stmts in the chain.\n+\t\t     DR_GROUP_SIZE is the exact number of stmts in the chain.\n \t\t     Therefore, NEXT_STMT can't be NULL_TREE.  In case that\n-\t\t     there is no interleaving, GROUP_SIZE is 1, and only one\n+\t\t     there is no interleaving, DR_GROUP_SIZE is 1, and only one\n \t\t     iteration of the loop will be executed.  */\n \t\t  op = vect_get_store_rhs (next_stmt);\n \t\t  vec_oprnd = vect_get_vec_def_for_operand (op, next_stmt);\n \t\t  dr_chain.quick_push (vec_oprnd);\n \t\t  oprnds.quick_push (vec_oprnd);\n-\t\t  next_stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n+\t\t  next_stmt = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n \t\t}\n \t      if (mask)\n \t\tvec_mask = vect_get_vec_def_for_operand (mask, stmt,\n@@ -7025,7 +7025,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t     DR_CHAIN is then used as an input to vect_permute_store_chain(),\n \t     and OPRNDS as an input to vect_get_vec_def_for_stmt_copy() for the\n \t     next copy.\n-\t     If the store is not grouped, GROUP_SIZE is 1, and DR_CHAIN and\n+\t     If the store is not grouped, DR_GROUP_SIZE is 1, and DR_CHAIN and\n \t     OPRNDS are of size 1.  */\n \t  for (i = 0; i < group_size; i++)\n \t    {\n@@ -7229,7 +7229,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t      if (slp)\n \t\tcontinue;\n \n-\t      next_stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n+\t      next_stmt = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n \t      if (!next_stmt)\n \t\tbreak;\n \t    }\n@@ -7545,8 +7545,8 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       gcc_assert (!nested_in_vect_loop);\n       gcc_assert (!STMT_VINFO_GATHER_SCATTER_P (stmt_info));\n \n-      first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n-      group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n+      first_stmt = DR_GROUP_FIRST_ELEMENT (stmt_info);\n+      group_size = DR_GROUP_SIZE (vinfo_for_stmt (first_stmt));\n \n       if (slp && SLP_TREE_LOAD_PERMUTATION (slp_node).exists ())\n \tslp_perm = true;\n@@ -7568,10 +7568,10 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       /* Similarly when the stmt is a load that is both part of a SLP\n          instance and a loop vectorized stmt via the same-dr mechanism\n \t we have to give up.  */\n-      if (STMT_VINFO_GROUP_SAME_DR_STMT (stmt_info)\n+      if (DR_GROUP_SAME_DR_STMT (stmt_info)\n \t  && (STMT_SLP_TYPE (stmt_info)\n \t      != STMT_SLP_TYPE (vinfo_for_stmt\n-\t\t\t\t (STMT_VINFO_GROUP_SAME_DR_STMT (stmt_info)))))\n+\t\t\t\t (DR_GROUP_SAME_DR_STMT (stmt_info)))))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -7676,7 +7676,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n       if (grouped_load)\n \t{\n-\t  first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n+\t  first_stmt = DR_GROUP_FIRST_ELEMENT (stmt_info);\n \t  first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n \t}\n       else\n@@ -7686,7 +7686,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t}\n       if (slp && grouped_load)\n \t{\n-\t  group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n+\t  group_size = DR_GROUP_SIZE (vinfo_for_stmt (first_stmt));\n \t  ref_type = get_group_alias_ptr_type (first_stmt);\n \t}\n       else\n@@ -7899,8 +7899,8 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n   if (grouped_load)\n     {\n-      first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n-      group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n+      first_stmt = DR_GROUP_FIRST_ELEMENT (stmt_info);\n+      group_size = DR_GROUP_SIZE (vinfo_for_stmt (first_stmt));\n       /* For SLP vectorization we directly vectorize a subchain\n          without permutation.  */\n       if (slp && ! SLP_TREE_LOAD_PERMUTATION (slp_node).exists ())\n@@ -8525,7 +8525,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n \t      /* With SLP permutation we load the gaps as well, without\n \t         we need to skip the gaps after we manage to fully load\n-\t\t all elements.  group_gap_adj is GROUP_SIZE here.  */\n+\t\t all elements.  group_gap_adj is DR_GROUP_SIZE here.  */\n \t      group_elt += nunits;\n \t      if (maybe_ne (group_gap_adj, 0U)\n \t\t  && !slp_perm\n@@ -9685,8 +9685,8 @@ vect_transform_stmt (gimple *stmt, gimple_stmt_iterator *gsi,\n \t     meanwhile.  */\n \t  *grouped_store = true;\n \t  stmt_vec_info group_info\n-\t    = vinfo_for_stmt (GROUP_FIRST_ELEMENT (stmt_info));\n-\t  if (GROUP_STORE_COUNT (group_info) == GROUP_SIZE (group_info))\n+\t    = vinfo_for_stmt (DR_GROUP_FIRST_ELEMENT (stmt_info));\n+\t  if (DR_GROUP_STORE_COUNT (group_info) == DR_GROUP_SIZE (group_info))\n \t    is_store = true;\n \t}\n       else\n@@ -9802,7 +9802,7 @@ vect_remove_stores (gimple *first_stmt)\n     {\n       stmt_vec_info stmt_info = vinfo_for_stmt (next);\n \n-      tmp = GROUP_NEXT_ELEMENT (stmt_info);\n+      tmp = DR_GROUP_NEXT_ELEMENT (stmt_info);\n       if (is_pattern_stmt_p (stmt_info))\n \tnext = STMT_VINFO_RELATED_STMT (stmt_info);\n       /* Free the attached stmt_vec_info and remove the stmt.  */\n@@ -9851,12 +9851,12 @@ new_stmt_vec_info (gimple *stmt, vec_info *vinfo)\n   STMT_SLP_TYPE (res) = loop_vect;\n   STMT_VINFO_NUM_SLP_USES (res) = 0;\n \n-  GROUP_FIRST_ELEMENT (res) = NULL;\n-  GROUP_NEXT_ELEMENT (res) = NULL;\n-  GROUP_SIZE (res) = 0;\n-  GROUP_STORE_COUNT (res) = 0;\n-  GROUP_GAP (res) = 0;\n-  GROUP_SAME_DR_STMT (res) = NULL;\n+  res->first_element = NULL; /* GROUP_FIRST_ELEMENT */\n+  res->next_element = NULL; /* GROUP_NEXT_ELEMENT */\n+  res->size = 0; /* GROUP_SIZE */\n+  res->store_count = 0; /* GROUP_STORE_COUNT */\n+  res->gap = 0; /* GROUP_GAP */\n+  res->same_dr_stmt = NULL; /* GROUP_SAME_DR_STMT */\n \n   return res;\n }"}, {"sha": "c2fb7702bdce8af20038ce0945c118f45e98bb7f", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c53b149b7476fabd329429b2a6dce090f580ff4/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c53b149b7476fabd329429b2a6dce090f580ff4/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=2c53b149b7476fabd329429b2a6dce090f580ff4", "patch": "@@ -951,26 +951,24 @@ STMT_VINFO_BB_VINFO (stmt_vec_info stmt_vinfo)\n #define STMT_VINFO_SAME_ALIGN_REFS(S)      (S)->same_align_refs\n #define STMT_VINFO_SIMD_CLONE_INFO(S)\t   (S)->simd_clone_info\n #define STMT_VINFO_DEF_TYPE(S)             (S)->def_type\n-#define STMT_VINFO_GROUP_FIRST_ELEMENT(S)  (S)->first_element\n-#define STMT_VINFO_GROUP_NEXT_ELEMENT(S)   (S)->next_element\n-#define STMT_VINFO_GROUP_SIZE(S)           (S)->size\n-#define STMT_VINFO_GROUP_STORE_COUNT(S)    (S)->store_count\n-#define STMT_VINFO_GROUP_GAP(S)            (S)->gap\n-#define STMT_VINFO_GROUP_SAME_DR_STMT(S)   (S)->same_dr_stmt\n-#define STMT_VINFO_GROUPED_ACCESS(S)      ((S)->first_element != NULL && (S)->data_ref_info)\n+#define STMT_VINFO_GROUPED_ACCESS(S)      ((S)->data_ref_info && DR_GROUP_FIRST_ELEMENT(S))\n #define STMT_VINFO_LOOP_PHI_EVOLUTION_BASE_UNCHANGED(S) (S)->loop_phi_evolution_base_unchanged\n #define STMT_VINFO_LOOP_PHI_EVOLUTION_PART(S) (S)->loop_phi_evolution_part\n #define STMT_VINFO_MIN_NEG_DIST(S)\t(S)->min_neg_dist\n #define STMT_VINFO_NUM_SLP_USES(S)\t(S)->num_slp_uses\n #define STMT_VINFO_REDUC_TYPE(S)\t(S)->reduc_type\n #define STMT_VINFO_REDUC_DEF(S)\t\t(S)->reduc_def\n \n-#define GROUP_FIRST_ELEMENT(S)          (S)->first_element\n-#define GROUP_NEXT_ELEMENT(S)           (S)->next_element\n-#define GROUP_SIZE(S)                   (S)->size\n-#define GROUP_STORE_COUNT(S)            (S)->store_count\n-#define GROUP_GAP(S)                    (S)->gap\n-#define GROUP_SAME_DR_STMT(S)           (S)->same_dr_stmt\n+#define DR_GROUP_FIRST_ELEMENT(S)  (gcc_checking_assert ((S)->data_ref_info), (S)->first_element)\n+#define DR_GROUP_NEXT_ELEMENT(S)   (gcc_checking_assert ((S)->data_ref_info), (S)->next_element)\n+#define DR_GROUP_SIZE(S)           (gcc_checking_assert ((S)->data_ref_info), (S)->size)\n+#define DR_GROUP_STORE_COUNT(S)    (gcc_checking_assert ((S)->data_ref_info), (S)->store_count)\n+#define DR_GROUP_GAP(S)            (gcc_checking_assert ((S)->data_ref_info), (S)->gap)\n+#define DR_GROUP_SAME_DR_STMT(S)   (gcc_checking_assert ((S)->data_ref_info), (S)->same_dr_stmt)\n+\n+#define REDUC_GROUP_FIRST_ELEMENT(S)\t(gcc_checking_assert (!(S)->data_ref_info), (S)->first_element)\n+#define REDUC_GROUP_NEXT_ELEMENT(S)\t(gcc_checking_assert (!(S)->data_ref_info), (S)->next_element)\n+#define REDUC_GROUP_SIZE(S)\t\t(gcc_checking_assert (!(S)->data_ref_info), (S)->size)\n \n #define STMT_VINFO_RELEVANT_P(S)          ((S)->relevant != vect_unused_in_scope)\n "}]}