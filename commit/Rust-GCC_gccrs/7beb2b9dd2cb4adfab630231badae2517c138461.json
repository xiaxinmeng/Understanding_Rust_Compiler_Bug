{"sha": "7beb2b9dd2cb4adfab630231badae2517c138461", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2JlYjJiOWRkMmNiNGFkZmFiNjMwMjMxYmFkYWUyNTE3YzEzODQ2MQ==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@adacore.com", "date": "2018-12-03T15:47:57Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-12-03T15:47:57Z"}, "message": "[Ada] Gigi support for OpenACC pragmas\n\nMatching front-end bits to support Acc_Kernels, Acc_Parallel,\nAcc_Loop and Acc_Data.\n\n2018-12-03  Olivier Hainque  <hainque@adacore.com>\n\ngcc/ada/\n\n\t* gcc-interface/lang.opt (fopenacc): New option for Ada.\n\t* gcc-interface/misc.c (gnat_handle_option): Handle it.\n\t* gcc-interface/trans.c (struct loop_info_d): Add OMP\n\tattributes.\n\t(Iterate_Acc_Clause_Arg, Acc_gnat_to_gnu): New functions,\n\thelpers for OpenACC pragmas processing in Pragma_to_gnu.\n\t(Acc_Var_to_gnu, Acc_Reduc_Var_to_gnu, Acc_Reduc_to_gnu):\n\tLikewise.\n\t(Acc_Size_Expr_to_gnu, Acc_Size_List_to_gnu): Likewise.\n\t(Pragma_Acc_Data_to_gnu): Likewise.\n\t(Pragma_to_gnu): Handle Pragma_Acc_Loop, Pragma_Acc_Data,\n\tPragma_Acc_Kernels and Pragma_Acc_Parallel.\n\t(Acc_Loop_to_gnu, Regular_Loop_to_gnu): New functions. Helpers\n\tfor ...\n\t(Loop_Statement_to_gnu): Rework to handle OpenACC loops.\n\nFrom-SVN: r266748", "tree": {"sha": "362b005cf64ce4ddd1e4878dc7c7823606f57a73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/362b005cf64ce4ddd1e4878dc7c7823606f57a73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7beb2b9dd2cb4adfab630231badae2517c138461", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7beb2b9dd2cb4adfab630231badae2517c138461", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7beb2b9dd2cb4adfab630231badae2517c138461", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7beb2b9dd2cb4adfab630231badae2517c138461/comments", "author": {"login": "hainque", "id": 18735142, "node_id": "MDQ6VXNlcjE4NzM1MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/18735142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hainque", "html_url": "https://github.com/hainque", "followers_url": "https://api.github.com/users/hainque/followers", "following_url": "https://api.github.com/users/hainque/following{/other_user}", "gists_url": "https://api.github.com/users/hainque/gists{/gist_id}", "starred_url": "https://api.github.com/users/hainque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hainque/subscriptions", "organizations_url": "https://api.github.com/users/hainque/orgs", "repos_url": "https://api.github.com/users/hainque/repos", "events_url": "https://api.github.com/users/hainque/events{/privacy}", "received_events_url": "https://api.github.com/users/hainque/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e663d4d985b60ba445f140df2481af573073cbc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e663d4d985b60ba445f140df2481af573073cbc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e663d4d985b60ba445f140df2481af573073cbc7"}], "stats": {"total": 759, "additions": 739, "deletions": 20}, "files": [{"sha": "a036eb1322be3cd3ec5ef69a007ddaed84197d8b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7beb2b9dd2cb4adfab630231badae2517c138461/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7beb2b9dd2cb4adfab630231badae2517c138461/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7beb2b9dd2cb4adfab630231badae2517c138461", "patch": "@@ -1,3 +1,21 @@\n+2018-12-03  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* gcc-interface/lang.opt (fopenacc): New option for Ada.\n+\t* gcc-interface/misc.c (gnat_handle_option): Handle it.\n+\t* gcc-interface/trans.c (struct loop_info_d): Add OMP\n+\tattributes.\n+\t(Iterate_Acc_Clause_Arg, Acc_gnat_to_gnu): New functions,\n+\thelpers for OpenACC pragmas processing in Pragma_to_gnu.\n+\t(Acc_Var_to_gnu, Acc_Reduc_Var_to_gnu, Acc_Reduc_to_gnu):\n+\tLikewise.\n+\t(Acc_Size_Expr_to_gnu, Acc_Size_List_to_gnu): Likewise.\n+\t(Pragma_Acc_Data_to_gnu): Likewise.\n+\t(Pragma_to_gnu): Handle Pragma_Acc_Loop, Pragma_Acc_Data,\n+\tPragma_Acc_Kernels and Pragma_Acc_Parallel.\n+\t(Acc_Loop_to_gnu, Regular_Loop_to_gnu): New functions. Helpers\n+\tfor ...\n+\t(Loop_Statement_to_gnu): Rework to handle OpenACC loops.\n+\n 2018-12-03  Olivier Hainque  <hainque@adacore.com>\n \n \t* gcc-interface/targtyps.c (MALLOC_OBSERVABLE_ALIGNMENT): Set to"}, {"sha": "cc9fa497933ae1f6ebf91ac851f1a8d48743b294", "filename": "gcc/ada/gcc-interface/lang.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7beb2b9dd2cb4adfab630231badae2517c138461/gcc%2Fada%2Fgcc-interface%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7beb2b9dd2cb4adfab630231badae2517c138461/gcc%2Fada%2Fgcc-interface%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Flang.opt?ref=7beb2b9dd2cb4adfab630231badae2517c138461", "patch": "@@ -100,4 +100,8 @@ fbuiltin-printf\n Ada Undocumented\n Ignored.\n \n+fopenacc\n+Ada LTO\n+; Documented in C but it should be: Enable OpenACC support\n+\n ; This comment is to ensure we retain the blank line above."}, {"sha": "29323b0560fa36389341ff4e640514b8556d9d22", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7beb2b9dd2cb4adfab630231badae2517c138461/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7beb2b9dd2cb4adfab630231badae2517c138461/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=7beb2b9dd2cb4adfab630231badae2517c138461", "patch": "@@ -166,6 +166,7 @@ gnat_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,\n       /* These are handled by the front-end.  */\n       break;\n \n+    case OPT_fopenacc:\n     case OPT_fshort_enums:\n     case OPT_fsigned_char:\n     case OPT_funsigned_char:"}, {"sha": "4c066c024210905ed83960ea90a85978a01facc7", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 716, "deletions": 20, "changes": 736, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7beb2b9dd2cb4adfab630231badae2517c138461/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7beb2b9dd2cb4adfab630231badae2517c138461/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=7beb2b9dd2cb4adfab630231badae2517c138461", "patch": "@@ -47,6 +47,7 @@\n #include \"gimplify.h\"\n #include \"opts.h\"\n #include \"common/common-target.h\"\n+#include \"gomp-constants.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n \n@@ -196,6 +197,9 @@ struct GTY(()) loop_info_d {\n   tree loop_var;\n   tree low_bound;\n   tree high_bound;\n+  tree omp_loop_clauses;\n+  tree omp_construct_clauses;\n+  enum tree_code omp_code;\n   vec<range_check_info, va_gc> *checks;\n   bool artificial;\n };\n@@ -1249,6 +1253,226 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n   return gnu_result;\n }\n \f\n+\n+/* If GNAT_EXPR is an N_Identifier, N_Integer_Literal or N_Operator_Symbol,\n+   call FN on it.  If GNAT_EXPR is an aggregate, call FN on each of its\n+   elements.  In both cases, pass GNU_EXPR and DATA as additional arguments.\n+\n+   This function is used everywhere OpenAcc pragmas are processed if these\n+   pragmas can accept aggregates.  */\n+\n+static tree\n+Iterate_Acc_Clause_Arg (Node_Id gnat_expr, tree gnu_expr,\n+\t\t\ttree (*fn)(Node_Id, tree, void*),\n+\t\t\tvoid* data)\n+{\n+  switch (Nkind (gnat_expr))\n+    {\n+    case N_Aggregate:\n+      if (Present (Expressions (gnat_expr)))\n+\t{\n+\t  for (Node_Id gnat_list_expr = First (Expressions (gnat_expr));\n+\t       Present (gnat_list_expr);\n+\t       gnat_list_expr = Next (gnat_list_expr))\n+\t    gnu_expr = fn (gnat_list_expr, gnu_expr, data);\n+\t}\n+      else if (Present (Component_Associations (gnat_expr)))\n+\t{\n+\t  for (Node_Id gnat_list_expr = First (Component_Associations\n+\t\t\t\t\t       (gnat_expr));\n+\t       Present (gnat_list_expr);\n+\t       gnat_list_expr = Next (gnat_list_expr))\n+\t    gnu_expr = fn (Expression (gnat_list_expr), gnu_expr, data);\n+\t}\n+      else\n+\t  gcc_unreachable();\n+\tbreak;\n+    case N_Identifier:\n+    case N_Integer_Literal:\n+    case N_Operator_Symbol:\n+\tgnu_expr = fn (gnat_expr, gnu_expr, data);\n+\tbreak;\n+    default:\n+\tgcc_unreachable();\n+    }\n+  return gnu_expr;\n+}\n+\n+/* Same as gnat_to_gnu for a GNAT_NODE referenced within an OpenAcc directive,\n+   undoing transformations that are inappropriate for such context.  */\n+\n+tree\n+Acc_gnat_to_gnu (Node_Id gnat_node)\n+{\n+  tree gnu_result = gnat_to_gnu (gnat_node);\n+\n+    /* If gnat_node is an identifier for a boolean, gnat_to_gnu might have\n+       turned it into `identifier != 0`.  Since arguments to OpenAcc pragmas\n+       need to be writable, we need to return the identifier residing in such\n+       expressions rather than the expression itself.  */\n+    if (Nkind (gnat_node) == N_Identifier\n+\t&& TREE_CODE (gnu_result) == NE_EXPR\n+\t&& TREE_CODE (TREE_TYPE (TREE_OPERAND (gnu_result, 0))) == BOOLEAN_TYPE\n+\t&& integer_zerop (TREE_OPERAND (gnu_result, 1)))\n+      gnu_result = TREE_OPERAND (gnu_result, 0);\n+\n+  return gnu_result;\n+}\n+\n+/* Turn GNAT_EXPR into a tree node representing an OMP data clause and chain\n+   it to GNU_CLAUSES, a list of pre-existing OMP clauses.  GNAT_EXPR should be\n+   a N_Identifier, this is enforced by the frontend.\n+\n+   This function is called every time translation of an argument for an OpenAcc\n+   clause (e.g. Acc_Parallel(Copy => My_Identifier)) is needed.  */\n+\n+static tree\n+Acc_Data_to_gnu (Node_Id gnat_expr, tree gnu_clauses, void* data)\n+{\n+  tree gnu_clause;\n+  enum gomp_map_kind kind = *((enum gomp_map_kind*) data);\n+  gnu_clause = build_omp_clause (EXPR_LOCATION(gnu_loop_stack->last ()->stmt),\n+\t\t\t\t OMP_CLAUSE_MAP);\n+\n+  gcc_assert (Nkind (gnat_expr) == N_Identifier);\n+  OMP_CLAUSE_DECL (gnu_clause) =\n+    gnat_to_gnu_entity (Entity (gnat_expr), NULL_TREE, false);\n+\n+  TREE_ADDRESSABLE (OMP_CLAUSE_DECL (gnu_clause)) = 1;\n+  OMP_CLAUSE_SET_MAP_KIND (gnu_clause, kind);\n+  OMP_CLAUSE_CHAIN (gnu_clause) = gnu_clauses;\n+  return gnu_clause;\n+}\n+\n+/* Turn GNAT_EXPR into a tree node representing an OMP clause and chain it to\n+   GNU_CLAUSES, a list of existing OMP clauses.\n+\n+   This function is used for parsing arguments of non-data clauses (e.g.\n+   Acc_Parallel(Wait => gnatexpr)).  */\n+\n+static tree\n+Acc_Var_to_gnu (Node_Id gnat_expr, tree gnu_clauses, void* data)\n+{\n+  tree gnu_clause;\n+  enum omp_clause_code kind = *((enum omp_clause_code*) data);\n+  gnu_clause =\n+    build_omp_clause (EXPR_LOCATION (gnu_loop_stack->last ()->stmt), kind);\n+\n+  OMP_CLAUSE_DECL (gnu_clause) = Acc_gnat_to_gnu (gnat_expr);\n+  OMP_CLAUSE_CHAIN (gnu_clause) = gnu_clauses;\n+  return gnu_clause;\n+}\n+\n+/* Turn GNAT_EXPR into a tree OMP clause representing a reduction clause.\n+   GNAT_EXPR has to be a N_Identifier, this is enforced by the frontend.\n+\n+   For example, GNAT_EXPR could be My_Identifier in the following pragma:\n+   Acc_Parallel(Reduction => (\"+\" => My_Identifier)).  */\n+\n+static tree\n+Acc_Reduc_Var_to_gnu (Node_Id gnat_expr, tree gnu_clauses, void* data)\n+{\n+  tree gnu_clause;\n+  tree_code code = *((tree_code*) data);\n+  gnu_clause = build_omp_clause (EXPR_LOCATION (gnu_loop_stack->last ()->stmt),\n+\t\t\t\t OMP_CLAUSE_REDUCTION);\n+  OMP_CLAUSE_DECL (gnu_clause) = Acc_gnat_to_gnu (gnat_expr);\n+  OMP_CLAUSE_REDUCTION_CODE (gnu_clause) = code;\n+  OMP_CLAUSE_CHAIN (gnu_clause) = gnu_clauses;\n+  return gnu_clause;\n+}\n+\n+/* Turn GNAT_EXPR into a list of OMP reduction clauses.  GNAT_EXPR has to\n+   follow the structure of a reduction clause, e.g. (\"+\" => Identifier).  */\n+\n+static tree\n+Acc_Reduc_to_gnu (Node_Id gnat_expr)\n+{\n+  tree gnu_clauses = NULL_TREE;\n+  for (Node_Id gnat_op = First (Component_Associations (gnat_expr));\n+       Present (gnat_op);\n+       gnat_op = Next (gnat_op))\n+    {\n+      tree_code code = ERROR_MARK;\n+      String_Id str = Strval (First (Choices (gnat_op)));\n+      switch (Get_String_Char (str, 1))\n+\t{\n+\tcase '+':\n+\t  code = PLUS_EXPR;\n+\t  break;\n+\tcase '*':\n+\t  code = MULT_EXPR;\n+\t  break;\n+\tcase 'm':\n+\t  if (Get_String_Char (str, 2) == 'i'\n+\t      && Get_String_Char (str, 3) == 'n')\n+\t    code = MIN_EXPR;\n+\t  else if (Get_String_Char (str, 2) == 'a'\n+\t\t   && Get_String_Char (str, 3) == 'x')\n+\t    code = MAX_EXPR;\n+\t  break;\n+\tcase 'a':\n+\t  if (Get_String_Char (str, 2) == 'n'\n+\t      && Get_String_Char (str, 3) == 'd')\n+\t    code = TRUTH_ANDIF_EXPR;\n+\t  break;\n+\tcase 'o':\n+\t  if (Get_String_Char (str, 2) == 'r')\n+\t    code = TRUTH_ORIF_EXPR;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable();\n+\t}\n+      /* Unsupported reduction operation.  This should have been\n+\t caught in sem_prag.adb.  */\n+      gcc_assert (code != ERROR_MARK);\n+\n+      gnu_clauses = Iterate_Acc_Clause_Arg (Expression (gnat_op),\n+\t\t\t\t\t    gnu_clauses,\n+\t\t\t\t\t    Acc_Reduc_Var_to_gnu,\n+\t\t\t\t\t    &code);\n+    }\n+  return gnu_clauses;\n+}\n+\n+/* Turn GNAT_EXPR, either '*' or an integer literal, into a tree_cons.  This is\n+   only used by Acc_Size_List_to_gnu.  */\n+\n+static tree\n+Acc_Size_Expr_to_gnu (Node_Id gnat_expr, tree gnu_clauses, void *)\n+{\n+  tree gnu_expr;\n+\n+  if (Nkind (gnat_expr) == N_Operator_Symbol\n+      && Get_String_Char (Strval (gnat_expr), 1) == '*')\n+    gnu_expr = integer_zero_node;\n+  else\n+    gnu_expr = Acc_gnat_to_gnu (gnat_expr);\n+\n+  return tree_cons (NULL_TREE, gnu_expr, gnu_clauses);\n+}\n+\n+/* Turn GNAT_EXPR, an aggregate of either '*' or integer literals, into an OMP\n+   clause node.\n+\n+   This function is used for the Tile clause of the Loop directive.  This is\n+   what GNAT_EXPR might look like: (1, 1, '*').  */\n+\n+static tree\n+Acc_Size_List_to_gnu (Node_Id gnat_expr)\n+{\n+  tree gnu_clause;\n+  tree gnu_list;\n+\n+  gnu_clause = build_omp_clause (EXPR_LOCATION (gnu_loop_stack->last ()->stmt),\n+\t\t\t\t OMP_CLAUSE_TILE);\n+  gnu_list = Iterate_Acc_Clause_Arg (gnat_expr, NULL_TREE,\n+\t\t\t\t     Acc_Size_Expr_to_gnu,\n+\t\t\t\t     NULL);\n+  OMP_CLAUSE_TILE_LIST (gnu_clause) = nreverse (gnu_list);\n+  return gnu_clause;\n+}\n+\n /* Subroutine of gnat_to_gnu to process gnat_node, an N_Pragma.  Return\n    any statements we generate.  */\n \n@@ -1309,6 +1533,274 @@ Pragma_to_gnu (Node_Id gnat_node)\n \t}\n       break;\n \n+    case Pragma_Acc_Loop:\n+      {\n+\ttree gnu_clauses = gnu_loop_stack->last ()->omp_loop_clauses;\n+\tif (!flag_openacc)\n+          break;\n+        if (!Present (Pragma_Argument_Associations (gnat_node)))\n+\t  break;\n+\tfor (gnat_temp = First (Pragma_Argument_Associations (gnat_node));\n+\t     Present (gnat_temp);\n+\t     gnat_temp = Next (gnat_temp))\n+\t  {\n+\t    Node_Id gnat_expr = Expression (gnat_temp);\n+\t    tree gnu_clause = NULL_TREE;\n+\t    enum omp_clause_code kind;\n+\n+\t    if (Chars (gnat_temp) == No_Name)\n+\t      {\n+\t\t/* The clause is an identifier without a parameter.  */\n+\t\tswitch (Chars (gnat_expr))\n+\t\t  {\n+\t\t  case Name_Auto:\n+\t\t    kind = OMP_CLAUSE_AUTO;\n+\t\t    break;\n+\t\t  case Name_Gang:\n+\t\t    kind = OMP_CLAUSE_GANG;\n+\t\t    break;\n+\t\t  case Name_Independent:\n+\t\t    kind = OMP_CLAUSE_INDEPENDENT;\n+\t\t    break;\n+\t\t  case Name_Seq:\n+\t\t    kind = OMP_CLAUSE_SEQ;\n+\t\t    break;\n+\t\t  case Name_Vector:\n+\t\t    kind = OMP_CLAUSE_VECTOR;\n+\t\t    break;\n+\t\t  case Name_Worker:\n+\t\t    kind = OMP_CLAUSE_WORKER;\n+\t\t    break;\n+\t\t  default:\n+\t\t    gcc_unreachable();\n+\t\t  }\n+\t\tgnu_clause = build_omp_clause (EXPR_LOCATION\n+\t\t\t\t\t       (gnu_loop_stack->last ()->stmt),\n+\t\t\t\t\t       kind);\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* The clause is an identifier parameter(s).  */\n+\t\tswitch (Chars (gnat_temp))\n+\t\t  {\n+\t\t  case Name_Collapse:\n+\t\t    gnu_clause = build_omp_clause\n+\t\t      (EXPR_LOCATION (gnu_loop_stack->last ()->stmt),\n+\t\t       OMP_CLAUSE_COLLAPSE);\n+\t\t    OMP_CLAUSE_COLLAPSE_EXPR (gnu_clause) =\n+\t\t      Acc_gnat_to_gnu (gnat_expr);\n+\t\t    break;\n+\t\t  case Name_Device_Type:\n+\t\t    /* Unimplemented by GCC yet.  */\n+\t\t    gcc_unreachable();\n+\t\t    break;\n+\t\t  case Name_Independent:\n+\t\t    gnu_clause = build_omp_clause\n+\t\t      (EXPR_LOCATION (gnu_loop_stack->last ()->stmt),\n+\t\t       OMP_CLAUSE_INDEPENDENT);\n+\t\t    break;\n+\t\t  case Name_Acc_Private:\n+\t\t    kind = OMP_CLAUSE_PRIVATE;\n+\t\t    gnu_clause = Iterate_Acc_Clause_Arg (gnat_expr, 0,\n+\t\t\t\t\t\t\t Acc_Var_to_gnu,\n+\t\t\t\t\t\t\t &kind);\n+\t\t    break;\n+\t\t  case Name_Reduction:\n+\t\t    gnu_clause = Acc_Reduc_to_gnu (gnat_expr);\n+\t\t    break;\n+\t\t  case Name_Tile:\n+\t\t    gnu_clause = Acc_Size_List_to_gnu (gnat_expr);\n+\t\t    break;\n+\t\t  case Name_Gang:\n+\t\t  case Name_Vector:\n+\t\t  case Name_Worker:\n+\t\t    /* These are for the Loop+Kernel combination, which is\n+\t\t       unimplemented by the frontend for now.  */\n+\t\t  default:\n+\t\t    gcc_unreachable();\n+\t\t  }\n+\t      }\n+\t    OMP_CLAUSE_CHAIN (gnu_clause) = gnu_clauses;\n+\t    gnu_clauses = gnu_clause;\n+\t  }\n+\tgnu_loop_stack->last ()->omp_loop_clauses = gnu_clauses;\n+      }\n+    break;\n+    /* Grouping the transformation of these pragmas together makes sense\n+       because they are mutually exclusive, share most of their clauses and\n+       the verification that each clause can legally appear for the pragma has\n+       been done in the frontend.  */\n+    case Pragma_Acc_Data:\n+    case Pragma_Acc_Kernels:\n+    case Pragma_Acc_Parallel:\n+      {\n+\tif (!flag_openacc)\n+\t  break;\n+\n+\ttree gnu_clauses = gnu_loop_stack->last ()->omp_construct_clauses;\n+\tif (pragma_id == Pragma_Acc_Data)\n+\t  gnu_loop_stack->last ()->omp_code = OACC_DATA;\n+\telse if (pragma_id == Pragma_Acc_Kernels)\n+\t  gnu_loop_stack->last ()->omp_code = OACC_KERNELS;\n+\telse if (pragma_id == Pragma_Acc_Parallel)\n+\t  gnu_loop_stack->last ()->omp_code = OACC_PARALLEL;\n+\telse\n+\t  gcc_unreachable ();\n+\n+\tif (!Present (Pragma_Argument_Associations (gnat_node)))\n+\t  break;\n+\n+\tfor (gnat_temp = First (Pragma_Argument_Associations (gnat_node));\n+\t    Present (gnat_temp);\n+\t    gnat_temp = Next (gnat_temp))\n+\t  {\n+\t    Node_Id gnat_expr = Expression (gnat_temp);\n+\t    tree gnu_clause;\n+\t    enum omp_clause_code clause_code;\n+\t    enum gomp_map_kind map_kind;\n+\n+\t    switch (Chars (gnat_temp))\n+\t      {\n+\t      case Name_Async:\n+\t\tgnu_clause = build_omp_clause\n+\t\t  (EXPR_LOCATION (gnu_loop_stack->last ()->stmt),\n+\t\t   OMP_CLAUSE_ASYNC);\n+\t\tOMP_CLAUSE_ASYNC_EXPR (gnu_clause) =\n+\t\t  Acc_gnat_to_gnu (gnat_expr);\n+\t\tOMP_CLAUSE_CHAIN (gnu_clause) = gnu_clauses;\n+\t\tgnu_clauses = gnu_clause;\n+\t\tbreak;\n+\n+\t      case Name_Num_Gangs:\n+\t\tgnu_clause = build_omp_clause\n+\t\t  (EXPR_LOCATION (gnu_loop_stack->last ()->stmt),\n+\t\t   OMP_CLAUSE_NUM_GANGS);\n+\t\tOMP_CLAUSE_NUM_GANGS_EXPR (gnu_clause) =\n+\t\t  Acc_gnat_to_gnu (gnat_expr);\n+\t\tOMP_CLAUSE_CHAIN (gnu_clause) = gnu_clauses;\n+\t\tgnu_clauses = gnu_clause;\n+\t\tbreak;\n+\n+\t      case Name_Num_Workers:\n+\t\tgnu_clause = build_omp_clause\n+\t\t  (EXPR_LOCATION (gnu_loop_stack->last ()->stmt),\n+\t\t   OMP_CLAUSE_NUM_WORKERS);\n+\t\tOMP_CLAUSE_NUM_WORKERS_EXPR (gnu_clause) =\n+\t\t  Acc_gnat_to_gnu (gnat_expr);\n+\t\tOMP_CLAUSE_CHAIN (gnu_clause) = gnu_clauses;\n+\t\tgnu_clauses = gnu_clause;\n+\t\tbreak;\n+\n+\t      case Name_Vector_Length:\n+\t\tgnu_clause = build_omp_clause\n+\t\t  (EXPR_LOCATION (gnu_loop_stack->last ()->stmt),\n+\t\t   OMP_CLAUSE_VECTOR_LENGTH);\n+\t\tOMP_CLAUSE_VECTOR_LENGTH_EXPR (gnu_clause) =\n+\t\t  Acc_gnat_to_gnu (gnat_expr);\n+\t\tOMP_CLAUSE_CHAIN (gnu_clause) = gnu_clauses;\n+\t\tgnu_clauses = gnu_clause;\n+\t\tbreak;\n+\n+\t      case Name_Wait:\n+\t\tclause_code = OMP_CLAUSE_WAIT;\n+\t\tgnu_clauses = Iterate_Acc_Clause_Arg (gnat_expr, gnu_clauses,\n+\t\t\t\t\t\t      Acc_Var_to_gnu,\n+\t\t\t\t\t\t      &clause_code);\n+\t\tbreak;\n+\n+\t      case Name_Acc_If:\n+\t\tgnu_clause = build_omp_clause (EXPR_LOCATION\n+\t\t\t\t\t       (gnu_loop_stack->last ()->stmt),\n+\t\t\t\t\t       OMP_CLAUSE_IF);\n+\t\tOMP_CLAUSE_IF_MODIFIER (gnu_clause) = ERROR_MARK;\n+\t\tOMP_CLAUSE_IF_EXPR (gnu_clause) = Acc_gnat_to_gnu (gnat_expr);\n+\t\tOMP_CLAUSE_CHAIN (gnu_clause) = gnu_clauses;\n+\t\tgnu_clauses = gnu_clause;\n+\t\tbreak;\n+\n+\t      case Name_Copy:\n+\t\tmap_kind = GOMP_MAP_FORCE_TOFROM;\n+\t\tgnu_clauses = Iterate_Acc_Clause_Arg (gnat_expr, gnu_clauses,\n+\t\t\t\t\t\t      Acc_Data_to_gnu,\n+\t\t\t\t\t\t      &map_kind);\n+\t\tbreak;\n+\n+\t      case Name_Copy_In:\n+\t\tmap_kind = GOMP_MAP_FORCE_TO;\n+\t\tgnu_clauses = Iterate_Acc_Clause_Arg (gnat_expr, gnu_clauses,\n+\t\t\t\t\t\t      Acc_Data_to_gnu,\n+\t\t\t\t\t\t      &map_kind);\n+\t\tbreak;\n+\n+\t      case Name_Copy_Out:\n+\t\tmap_kind = GOMP_MAP_FORCE_FROM;\n+\t\tgnu_clauses = Iterate_Acc_Clause_Arg (gnat_expr, gnu_clauses,\n+\t\t\t\t\t\t      Acc_Data_to_gnu,\n+\t\t\t\t\t\t      &map_kind);\n+\t\tbreak;\n+\n+\t      case Name_Present:\n+\t\tmap_kind = GOMP_MAP_FORCE_PRESENT;\n+\t\tgnu_clauses = Iterate_Acc_Clause_Arg (gnat_expr, gnu_clauses,\n+\t\t\t\t\t\t      Acc_Data_to_gnu,\n+\t\t\t\t\t\t      &map_kind);\n+\t\tbreak;\n+\n+\t      case Name_Create:\n+\t\tmap_kind = GOMP_MAP_FORCE_ALLOC;\n+\t\tgnu_clauses = Iterate_Acc_Clause_Arg (gnat_expr, gnu_clauses,\n+\t\t\t\t\t\t      Acc_Data_to_gnu,\n+\t\t\t\t\t\t      &map_kind);\n+\t\tbreak;\n+\n+\t      case Name_Device_Ptr:\n+\t\tmap_kind = GOMP_MAP_FORCE_DEVICEPTR;\n+\t\tgnu_clauses = Iterate_Acc_Clause_Arg (gnat_expr, gnu_clauses,\n+\t\t\t\t\t\t      Acc_Data_to_gnu,\n+\t\t\t\t\t\t      &map_kind);\n+\t\tbreak;\n+\n+\t      case Name_Acc_Private:\n+\t\tclause_code = OMP_CLAUSE_PRIVATE;\n+\t\tgnu_clauses = Iterate_Acc_Clause_Arg (gnat_expr, gnu_clauses,\n+\t\t\t\t\t\t      Acc_Var_to_gnu,\n+\t\t\t\t\t\t      &clause_code);\n+\t\tbreak;\n+\n+\t      case Name_First_Private:\n+\t\tclause_code = OMP_CLAUSE_FIRSTPRIVATE;\n+\t\tgnu_clauses = Iterate_Acc_Clause_Arg (gnat_expr, gnu_clauses,\n+\t\t\t\t\t\t      Acc_Var_to_gnu,\n+\t\t\t\t\t\t      &clause_code); break;\n+\n+\t      case Name_Default:\n+\t\tgnu_clause = build_omp_clause (EXPR_LOCATION\n+\t\t\t\t\t       (gnu_loop_stack->last ()->stmt),\n+\t\t\t\t\t       OMP_CLAUSE_DEFAULT);\n+\t\tOMP_CLAUSE_CHAIN (gnu_clause) = gnu_clauses;\n+\t\t/* The standard also accepts \"present\" but this isn't\n+\t\t   implemented in GCC yet.  */\n+\t\tOMP_CLAUSE_DEFAULT_KIND (gnu_clause) = OMP_CLAUSE_DEFAULT_NONE;\n+\t\tOMP_CLAUSE_CHAIN (gnu_clause) = gnu_clauses;\n+\t\tgnu_clauses = gnu_clause;\n+\t\tbreak;\n+\n+\t      case Name_Reduction:\n+\t\tgnu_clauses = Acc_Reduc_to_gnu(gnat_expr);\n+\t\tbreak;\n+\n+\t      case Name_Detach:\n+\t      case Name_Attach:\n+\t      case Name_Device_Type:\n+\t\t/* Unimplemented by GCC.  */\n+\t      default:\n+\t\tgcc_unreachable ();\n+\t      }\n+\t  }\n+\tgnu_loop_stack->last ()->omp_construct_clauses = gnu_clauses;\n+      }\n+      break;\n+\n     case Pragma_Loop_Optimize:\n       for (gnat_temp = First (Pragma_Argument_Associations (gnat_node));\n \t   Present (gnat_temp);\n@@ -2838,32 +3330,174 @@ independent_iterations_p (tree stmt_list)\n   return true;\n }\n \n-/* Subroutine of gnat_to_gnu to translate gnat_node, an N_Loop_Statement,\n-   to a GCC tree, which is returned.  */\n+/* Helper for Loop_Statement_to_gnu to translate the body of a loop,\n+   designated by GNAT_LOOP, to which an Acc_Loop pragma applies.  The pragma\n+   arguments might instruct us to collapse a nest of loops, where computation\n+   statements are expected only within the innermost loop, as in:\n+\n+   for I in 1 .. 5 loop\n+      pragma Acc_Parallel;\n+      pragma Acc_Loop(Collapse => 3);\n+      for J in 1 .. 8 loop\n+         for K in 1 .. 4 loop\n+            X (I, J, K) := Y (I, J, K) + 2;\n+         end loop;\n+      end loop;\n+   end loop;\n+\n+   We expect the top of gnu_loop_stack to hold a pointer to the loop info\n+   setup for the translation of GNAT_LOOP, which holds a pointer to the\n+   initial gnu loop stmt node.  We return the new gnu loop statement to\n+   use.  */\n \n static tree\n-Loop_Statement_to_gnu (Node_Id gnat_node)\n+Acc_Loop_to_gnu (Node_Id gnat_loop)\n {\n-  const Node_Id gnat_iter_scheme = Iteration_Scheme (gnat_node);\n-  struct loop_info_d *gnu_loop_info = ggc_cleared_alloc<loop_info_d> ();\n-  tree gnu_loop_stmt = build4 (LOOP_STMT, void_type_node, NULL_TREE,\n-\t\t\t       NULL_TREE, NULL_TREE, NULL_TREE);\n-  tree gnu_loop_label = create_artificial_label (input_location);\n-  tree gnu_cond_expr = NULL_TREE, gnu_low = NULL_TREE, gnu_high = NULL_TREE;\n-  tree gnu_result;\n+  const struct loop_info_d * const gnu_loop_info = gnu_loop_stack->last ();\n+  tree gnu_loop_stmt = gnu_loop_info->stmt;\n+\n+  tree acc_loop = make_node (OACC_LOOP);\n+  tree acc_bind_expr = NULL_TREE;\n+  Node_Id cur_loop = gnat_loop;\n+  int collapse_count = 1;\n+  tree initv;\n+  tree condv;\n+  tree incrv;\n+\n+  /* Parse the pragmas, adding clauses to the current gnu_loop_stack through\n+     side effects.  */\n+  for (Node_Id tmp = First (Statements (gnat_loop));\n+       Present (tmp) && Nkind (tmp) == N_Pragma;\n+       tmp = Next (tmp))\n+    Pragma_to_gnu(tmp);\n+\n+  /* Find the number of loops that should be collapsed.  */\n+  for (tree tmp = gnu_loop_stack->last ()->omp_loop_clauses; tmp ;\n+       tmp = OMP_CLAUSE_CHAIN (tmp))\n+    if (OMP_CLAUSE_CODE (tmp) == OMP_CLAUSE_COLLAPSE)\n+      collapse_count = tree_to_shwi (OMP_CLAUSE_COLLAPSE_EXPR (tmp));\n+    else if (OMP_CLAUSE_CODE (tmp) == OMP_CLAUSE_TILE)\n+      collapse_count = list_length (OMP_CLAUSE_TILE_LIST (tmp));\n+\n+  initv = make_tree_vec (collapse_count);\n+  condv = make_tree_vec (collapse_count);\n+  incrv = make_tree_vec (collapse_count);\n \n-  /* Push the loop_info structure associated with the LOOP_STMT.  */\n-  vec_safe_push (gnu_loop_stack, gnu_loop_info);\n+  start_stmt_group ();\n+  gnat_pushlevel ();\n \n-  /* Set location information for statement and end label.  */\n-  set_expr_location_from_node (gnu_loop_stmt, gnat_node);\n-  Sloc_to_locus (Sloc (End_Label (gnat_node)),\n-\t\t &DECL_SOURCE_LOCATION (gnu_loop_label));\n-  LOOP_STMT_LABEL (gnu_loop_stmt) = gnu_loop_label;\n+  /* For each nested loop that should be collapsed ...  */\n+  for (int count = 0; count < collapse_count; ++count)\n+    {\n+      Node_Id lps =\n+        Loop_Parameter_Specification (Iteration_Scheme (cur_loop));\n+      tree low =\n+        Acc_gnat_to_gnu (Low_Bound (Discrete_Subtype_Definition (lps)));\n+      tree high =\n+        Acc_gnat_to_gnu (High_Bound (Discrete_Subtype_Definition (lps)));\n+      tree variable =\n+\tgnat_to_gnu_entity (Defining_Identifier (lps), NULL_TREE, true);\n+\n+      /* Build the initial value of the variable of the invariant.  */\n+      TREE_VEC_ELT (initv, count) = build2 (MODIFY_EXPR,\n+\t\t\t\t\t    TREE_TYPE (variable),\n+\t\t\t\t\t    variable,\n+\t\t\t\t\t    low);\n+      add_stmt (TREE_VEC_ELT (initv, count));\n+\n+      /* Build the invariant of the loop.  */\n+      TREE_VEC_ELT (condv, count) = build2 (LE_EXPR,\n+\t\t\t\t\t    boolean_type_node,\n+\t\t\t\t\t    variable,\n+\t\t\t\t\t    high);\n+\n+      /* Build the incrementation expression of the loop.  */\n+      TREE_VEC_ELT (incrv, count) =\n+\tbuild2 (MODIFY_EXPR,\n+\t\tTREE_TYPE (variable),\n+\t\tvariable,\n+\t\tbuild2 (PLUS_EXPR,\n+\t\t\tTREE_TYPE (variable),\n+\t\t\tvariable,\n+\t\t\tbuild_int_cst (TREE_TYPE (variable), 1)));\n+\n+      /* Don't process the innermost loop because its statements belong to\n+         another statement group.  */\n+      if (count < collapse_count - 1)\n+\t/* Process the current loop's body.  */\n+\tfor (Node_Id stmt = First (Statements (cur_loop));\n+\t     Present (stmt); stmt = Next (stmt))\n+\t  {\n+\t    /* If we are processsing the outermost loop, it is ok for it to\n+\t       contain pragmas.  */\n+\t    if (Nkind (stmt) == N_Pragma && count == 0)\n+\t      ;\n+\t    /* The frontend might have inserted a N_Object_Declaration in the\n+\t       loop's body to declare the iteration variable of the next loop.\n+\t       It will need to be hoisted before the collapsed loops.  */\n+\t    else if (Nkind (stmt) == N_Object_Declaration)\n+\t      Acc_gnat_to_gnu (stmt);\n+\t    else if (Nkind (stmt) == N_Loop_Statement)\n+\t      cur_loop = stmt;\n+\t    /* Every other kind of statement is prohibited in collapsed\n+               loops.  */\n+\t    else if (count < collapse_count - 1)\n+\t      gcc_unreachable();\n+\t  }\n+    }\n+  gnat_poplevel ();\n+  acc_bind_expr = end_stmt_group ();\n \n-  /* Save the statement for later reuse.  */\n-  gnu_loop_info->stmt = gnu_loop_stmt;\n-  gnu_loop_info->artificial = !Comes_From_Source (gnat_node);\n+  /* Parse the innermost loop.  */\n+  start_stmt_group();\n+  for (Node_Id stmt = First (Statements (cur_loop));\n+       Present (stmt);\n+       stmt = Next (stmt))\n+    {\n+      /* When the innermost loop is the only loop, do not parse the pragmas\n+         again.  */\n+      if (Nkind (stmt) == N_Pragma && collapse_count == 1)\n+\tcontinue;\n+      add_stmt (Acc_gnat_to_gnu (stmt));\n+    }\n+\n+  TREE_TYPE (acc_loop) = void_type_node;\n+  OMP_FOR_INIT (acc_loop) = initv;\n+  OMP_FOR_COND (acc_loop) = condv;\n+  OMP_FOR_INCR (acc_loop) = incrv;\n+  OMP_FOR_BODY (acc_loop) = end_stmt_group ();\n+  OMP_FOR_PRE_BODY (acc_loop) = NULL;\n+  OMP_FOR_ORIG_DECLS (acc_loop) = NULL;\n+  OMP_FOR_CLAUSES (acc_loop) = gnu_loop_stack->last ()->omp_loop_clauses;\n+\n+  BIND_EXPR_BODY (acc_bind_expr) = acc_loop;\n+\n+  return gnu_loop_stmt;\n+}\n+\n+/* Helper for Loop_Statement_to_gnu, to translate the body of a loop not\n+   subject to any sort of parallelization directive or restriction, designated\n+   by GNAT_NODE.\n+\n+   We expect the top of gnu_loop_stack to hold a pointer to the loop info\n+   setup for the translation, which holds a pointer to the initial gnu loop\n+   stmt node.  We return the new gnu loop statement to use.\n+\n+   We might also set *GNU_COND_EXPR_P to request a variant of the translation\n+   scheme in Loop_Statement_to_gnu.  */\n+\n+static tree\n+Regular_Loop_to_gnu (Node_Id gnat_node, tree *gnu_cond_expr_p)\n+{\n+  struct loop_info_d * const gnu_loop_info = gnu_loop_stack->last ();\n+  tree gnu_loop_stmt = gnu_loop_info->stmt;\n+\n+  const Node_Id gnat_iter_scheme = Iteration_Scheme (gnat_node);\n+  tree gnu_low = NULL_TREE, gnu_high = NULL_TREE;\n+\n+  tree gnu_cond_expr = *gnu_cond_expr_p;\n+\n+  tree gnu_loop_label = LOOP_STMT_LABEL (gnu_loop_stmt);\n \n   /* Set the condition under which the loop must keep going.\n      For the case \"LOOP .... END LOOP;\" the condition is always true.  */\n@@ -3203,6 +3837,68 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n       gnu_loop_stmt = end_stmt_group ();\n     }\n \n+  *gnu_cond_expr_p = gnu_cond_expr;\n+\n+  return gnu_loop_stmt;\n+}\n+\n+/* Subroutine of gnat_to_gnu to translate gnat_node, an N_Loop_Statement,\n+   to a GCC tree, which is returned.  */\n+\n+static tree\n+Loop_Statement_to_gnu (Node_Id gnat_node)\n+{\n+  struct loop_info_d *gnu_loop_info = ggc_cleared_alloc<loop_info_d> ();\n+\n+  tree gnu_loop_stmt = build4 (LOOP_STMT, void_type_node, NULL_TREE,\n+\t\t\t       NULL_TREE, NULL_TREE, NULL_TREE);\n+  tree gnu_cond_expr = NULL_TREE;\n+  tree gnu_loop_label = create_artificial_label (input_location);\n+  tree gnu_result;\n+\n+  /* Push the loop_info structure associated with the LOOP_STMT.  */\n+  vec_safe_push (gnu_loop_stack, gnu_loop_info);\n+\n+  /* Set location information for statement and end label.  */\n+  set_expr_location_from_node (gnu_loop_stmt, gnat_node);\n+  Sloc_to_locus (Sloc (End_Label (gnat_node)),\n+\t\t &DECL_SOURCE_LOCATION (gnu_loop_label));\n+  LOOP_STMT_LABEL (gnu_loop_stmt) = gnu_loop_label;\n+\n+  /* Save the statement for later reuse.  */\n+  gnu_loop_info->stmt = gnu_loop_stmt;\n+  gnu_loop_info->artificial = !Comes_From_Source (gnat_node);\n+\n+  /* Perform the core loop body translation.  */\n+  if (Is_OpenAcc_Loop (gnat_node))\n+    gnu_loop_stmt = Acc_Loop_to_gnu (gnat_node);\n+  else\n+    gnu_loop_stmt = Regular_Loop_to_gnu (gnat_node, &gnu_cond_expr);\n+\n+  /* A gnat_node that has its OpenAcc_Environment flag set needs to be\n+     offloaded.  Note that the OpenAcc_Loop flag is not necessarily set.  */\n+  if (Is_OpenAcc_Environment (gnat_node))\n+    {\n+      tree_code code = gnu_loop_stack->last ()->omp_code;\n+      tree tmp = make_node (code);\n+      TREE_TYPE (tmp) = void_type_node;\n+      if (code == OACC_PARALLEL || code == OACC_KERNELS)\n+\t{\n+\t  OMP_BODY (tmp) = gnu_loop_stmt;\n+\t  OMP_CLAUSES (tmp) = gnu_loop_stack->last ()->omp_construct_clauses;\n+\t}\n+      else if (code == OACC_DATA)\n+\t{\n+\t  OACC_DATA_BODY (tmp) = gnu_loop_stmt;\n+\t  OACC_DATA_CLAUSES (tmp) =\n+\t    gnu_loop_stack->last ()->omp_construct_clauses;\n+\t}\n+      else\n+\tgcc_unreachable();\n+      set_expr_location_from_node (tmp, gnat_node);\n+      gnu_loop_stmt = tmp;\n+    }\n+\n   /* If we have an outer COND_EXPR, that's our result and this loop is its\n      \"true\" statement.  Otherwise, the result is the LOOP_STMT.  */\n   if (gnu_cond_expr)"}]}