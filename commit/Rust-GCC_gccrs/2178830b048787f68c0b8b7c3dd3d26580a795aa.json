{"sha": "2178830b048787f68c0b8b7c3dd3d26580a795aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjE3ODgzMGIwNDg3ODdmNjhjMGI4YjdjM2RkM2QyNjU4MGE3OTVhYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-30T13:54:18Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-30T13:54:18Z"}, "message": "[multiple changes]\n\n2014-07-30  Pat Rogers  <rogers@adacore.com>\n\n\t* gnat_rm.texi: Minor word error.\n\n2014-07-30  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_prag.adb (Expand_Old): Insert declarationss of temporaries\n\tcreated to capture the value of the prefix of 'Old at the\n\tbeginning of the current declarative part, to prevent data flow\n\tanomalies in the postcondition procedure that will follow.\n\n2014-07-30  Yannick Moy  <moy@adacore.com>\n\n\t* debug.adb: Retire debug flag -gnatdQ.\n\t* inline.adb (Can_Be_Inlined_In_GNATprove_Mode): Check SPARK_Mode\n\ton decl, not on body.  Ignore predicate functions.\n\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): Remove use of\n\tdebug flag -gnatdQ.  Correctly analyze SPARK_Mode on decl and\n\tbody when generating a decl for a body on which SPARK_Mode aspect\n\tis given.\n\t* sem_prag.adb (Analyze_Pragma|SPARK_Mode): Reorder tests for\n\tattaching pragma to entity, to account for declaration not coming\n\tfrom source.\n\t* sem_res.adb (Resolve_Call): Issue warning and flag subprogram\n\tas not always inlined in GNATprove mode, when called in an\n\tassertion context.\n\nFrom-SVN: r213271", "tree": {"sha": "4d659dd4ed85f83c6aebe912ce1e774a2e95d1f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d659dd4ed85f83c6aebe912ce1e774a2e95d1f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2178830b048787f68c0b8b7c3dd3d26580a795aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2178830b048787f68c0b8b7c3dd3d26580a795aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2178830b048787f68c0b8b7c3dd3d26580a795aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2178830b048787f68c0b8b7c3dd3d26580a795aa/comments", "author": null, "committer": null, "parents": [{"sha": "d3e16619ae38fba5a464064046114a6638d1816f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3e16619ae38fba5a464064046114a6638d1816f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3e16619ae38fba5a464064046114a6638d1816f"}], "stats": {"total": 168, "additions": 132, "deletions": 36}, "files": [{"sha": "408f6d07c4abe2b304e264ad4fac0fa6a61291b5", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2178830b048787f68c0b8b7c3dd3d26580a795aa/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2178830b048787f68c0b8b7c3dd3d26580a795aa/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2178830b048787f68c0b8b7c3dd3d26580a795aa", "patch": "@@ -1,3 +1,30 @@\n+2014-07-30  Pat Rogers  <rogers@adacore.com>\n+\n+\t* gnat_rm.texi: Minor word error.\n+\n+2014-07-30  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_prag.adb (Expand_Old): Insert declarationss of temporaries\n+\tcreated to capture the value of the prefix of 'Old at the\n+\tbeginning of the current declarative part, to prevent data flow\n+\tanomalies in the postcondition procedure that will follow.\n+\n+2014-07-30  Yannick Moy  <moy@adacore.com>\n+\n+\t* debug.adb: Retire debug flag -gnatdQ.\n+\t* inline.adb (Can_Be_Inlined_In_GNATprove_Mode): Check SPARK_Mode\n+\ton decl, not on body.  Ignore predicate functions.\n+\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): Remove use of\n+\tdebug flag -gnatdQ.  Correctly analyze SPARK_Mode on decl and\n+\tbody when generating a decl for a body on which SPARK_Mode aspect\n+\tis given.\n+\t* sem_prag.adb (Analyze_Pragma|SPARK_Mode): Reorder tests for\n+\tattaching pragma to entity, to account for declaration not coming\n+\tfrom source.\n+\t* sem_res.adb (Resolve_Call): Issue warning and flag subprogram\n+\tas not always inlined in GNATprove mode, when called in an\n+\tassertion context.\n+\n 2014-07-30  Vincent Celier  <celier@adacore.com>\n \n \t* debug.adb: Minor comment update."}, {"sha": "64162ef060224da5f2e1f4a5e9c7e5cfcbf2bcd1", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2178830b048787f68c0b8b7c3dd3d26580a795aa/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2178830b048787f68c0b8b7c3dd3d26580a795aa/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=2178830b048787f68c0b8b7c3dd3d26580a795aa", "patch": "@@ -80,7 +80,7 @@ package body Debug is\n    --  dN   No file name information in exception messages\n    --  dO   Output immediate error messages\n    --  dP   Do not check for controlled objects in preelaborable packages\n-   --  dQ   Enable inlining of bodies-without-decl in GNATprove mode\n+   --  dQ\n    --  dR   Bypass check for correct version of s-rpc\n    --  dS   Never convert numbers to machine numbers in Sem_Eval\n    --  dT   Convert to machine numbers only for constant declarations\n@@ -438,11 +438,6 @@ package body Debug is\n    --       in preelaborable packages, but this restriction is a huge pain,\n    --       especially in the predefined library units.\n \n-   --  dQ   Enable inlining of bodies-without-decl in GNATprove mode. A decl is\n-   --       created by the frontend so that the usual frontend inlining\n-   --       mechanism can be used for formal verification. Under a debug flag\n-   --       until fully reliable.\n-\n    --  dR   Bypass the check for a proper version of s-rpc being present\n    --       to use the -gnatz? switch. This allows debugging of the use\n    --       of stubs generation without needing to have GLADE (or some"}, {"sha": "c48f3d2acf10ade42dc841b64c06113a3418c9d0", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2178830b048787f68c0b8b7c3dd3d26580a795aa/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2178830b048787f68c0b8b7c3dd3d26580a795aa/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=2178830b048787f68c0b8b7c3dd3d26580a795aa", "patch": "@@ -440,6 +440,9 @@ package body Exp_Prag is\n \n                --  Generate a temporary to capture the value of the prefix:\n                --    Temp : <Pref type>;\n+               --  Place that temporary at the beginning of declarations, to\n+               --  prevent anomolies in the GNATprove flow analysis pass in\n+               --  the precondition procedure that follows.\n \n                Decl :=\n                  Make_Object_Declaration (Loc,\n@@ -448,7 +451,7 @@ package body Exp_Prag is\n                      New_Occurrence_Of (Etype (Pref), Loc));\n                Set_No_Initialization (Decl);\n \n-               Append_To (Decls, Decl);\n+               Prepend_To (Decls, Decl);\n \n                --  Evaluate the prefix, generate:\n                --    Temp := <Pref>;"}, {"sha": "b0a018bf497995f8c33cac593eb78a07732a5ddb", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2178830b048787f68c0b8b7c3dd3d26580a795aa/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2178830b048787f68c0b8b7c3dd3d26580a795aa/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=2178830b048787f68c0b8b7c3dd3d26580a795aa", "patch": "@@ -7215,7 +7215,7 @@ The meaning of a test case is that there is at least one context where\n that context, then @code{Ensures} holds when the subprogram returns.\n Mode @code{Nominal} indicates that the input context should also satisfy the\n precondition of the subprogram, and the output context should also satisfy its\n-postcondition. More @code{Robustness} indicates that the precondition and\n+postcondition. Mode @code{Robustness} indicates that the precondition and\n postcondition of the subprogram should be ignored for this test case.\n \n @node Pragma Thread_Local_Storage"}, {"sha": "be556fb2eb8bedc5c32205c965eed05ad78fe87c", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2178830b048787f68c0b8b7c3dd3d26580a795aa/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2178830b048787f68c0b8b7c3dd3d26580a795aa/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=2178830b048787f68c0b8b7c3dd3d26580a795aa", "patch": "@@ -1692,13 +1692,14 @@ package body Inline is\n       elsif Is_Generic_Instance (Spec_Id) then\n          return False;\n \n-      --  Only inline subprograms whose body is marked SPARK_Mode On. Other\n-      --  subprogram bodies should not be analyzed.\n-\n-      elsif Present (Body_Id)\n-        and then (No (SPARK_Pragma (Body_Id))\n-                   or else\n-                     Get_SPARK_Mode_From_Pragma (SPARK_Pragma (Body_Id)) /= On)\n+      --  Only inline subprograms whose spec is marked SPARK_Mode On. For\n+      --  the subprogram body, a similar check is performed after the body\n+      --  is analyzed, as this is where a pragma SPARK_Mode might be inserted.\n+\n+      elsif Present (Spec_Id)\n+        and then (No (SPARK_Pragma (Spec_Id))\n+                    or else\n+                  Get_SPARK_Mode_From_Pragma (SPARK_Pragma (Spec_Id)) /= On)\n       then\n          return False;\n \n@@ -1708,6 +1709,12 @@ package body Inline is\n       elsif Instantiation_Location (Sloc (Id)) /= No_Location then\n          return False;\n \n+      --  Predicate functions are treated specially by GNATprove. Do not inline\n+      --  them.\n+\n+      elsif Is_Predicate_Function (Id) then\n+         return False;\n+\n       --  Otherwise, this is a subprogram declared inside the private part of a\n       --  package, or inside a package body, or locally in a subprogram, and it\n       --  does not have any contract. Inline it."}, {"sha": "f359b486901e38c0494df985b4028e63805a542c", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2178830b048787f68c0b8b7c3dd3d26580a795aa/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2178830b048787f68c0b8b7c3dd3d26580a795aa/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=2178830b048787f68c0b8b7c3dd3d26580a795aa", "patch": "@@ -1497,7 +1497,7 @@ package body Sem_Ch13 is\n          --  Start of processing for Analyze_One_Aspect\n \n          begin\n-            --  Skip aspect if already analyzed (not clear if this is needed)\n+            --  Skip aspect if already analyzed, to avoid looping in some cases\n \n             if Analyzed (Aspect) then\n                goto Continue;"}, {"sha": "72ee382468794e79c1b32133cdb0fc48da63c387", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2178830b048787f68c0b8b7c3dd3d26580a795aa/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2178830b048787f68c0b8b7c3dd3d26580a795aa/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=2178830b048787f68c0b8b7c3dd3d26580a795aa", "patch": "@@ -3034,10 +3034,6 @@ package body Sem_Ch6 is\n                if No (Spec_Id)\n                  and then GNATprove_Mode\n \n-                 --  Under a debug flag until remaining issues are fixed\n-\n-                 and then Debug_Flag_QQ\n-\n                  --  Inlining does not apply during pre-analysis of code\n \n                  and then Full_Analysis\n@@ -3077,13 +3073,51 @@ package body Sem_Ch6 is\n                      New_Decl : constant Node_Id :=\n                                   Make_Subprogram_Declaration (Loc,\n                                     Copy_Separate_Tree (Specification (N)));\n+                     SPARK_Mode_Aspect : Node_Id;\n+                     Aspects : List_Id;\n+                     Prag, Aspect : Node_Id;\n \n                   begin\n                      Insert_Before (N, New_Decl);\n                      Move_Aspects (From => N, To => New_Decl);\n+\n+                     --  Mark the newly moved aspects as not analyzed, so that\n+                     --  their effect on New_Decl is properly analyzed.\n+\n+                     Aspect := First (Aspect_Specifications (New_Decl));\n+                     while Present (Aspect) loop\n+                        Set_Analyzed (Aspect, False);\n+                        Next (Aspect);\n+                     end loop;\n+\n                      Analyze (New_Decl);\n+\n+                     --  The analysis of the generated subprogram declaration\n+                     --  may have introduced pragmas, which need to be\n+                     --  analyzed.\n+\n+                     Prag := Next (New_Decl);\n+                     while Prag /= N loop\n+                        Analyze (Prag);\n+                        Next (Prag);\n+                     end loop;\n+\n                      Spec_Id := Defining_Entity (New_Decl);\n \n+                     --  If aspect SPARK_Mode was specified on the body, it\n+                     --  needs to be repeated on the generated decl and the\n+                     --  body. Since the original aspect was moved to the\n+                     --  generated decl, copy it for the body.\n+\n+                     if Has_Aspect (Spec_Id, Aspect_SPARK_Mode) then\n+                        SPARK_Mode_Aspect :=\n+                          New_Copy (Find_Aspect (Spec_Id, Aspect_SPARK_Mode));\n+                        Set_Analyzed (SPARK_Mode_Aspect, False);\n+                        Aspects := New_List;\n+                        Append (SPARK_Mode_Aspect, Aspects);\n+                        Set_Aspect_Specifications (N, Aspects);\n+                     end if;\n+\n                      Set_Specification (N, Body_Spec);\n                      Body_Id := Analyze_Subprogram_Specification (Body_Spec);\n                      Set_Corresponding_Spec (N, Spec_Id);"}, {"sha": "983cb321752b1dbeba5b5fbfde9550db03728574", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2178830b048787f68c0b8b7c3dd3d26580a795aa/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2178830b048787f68c0b8b7c3dd3d26580a795aa/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=2178830b048787f68c0b8b7c3dd3d26580a795aa", "patch": "@@ -19830,11 +19830,6 @@ package body Sem_Prag is\n                         raise Pragma_Exit;\n                      end if;\n \n-                  --  Skip internally generated code\n-\n-                  elsif not Comes_From_Source (Stmt) then\n-                     null;\n-\n                   elsif Nkind (Stmt) in N_Generic_Declaration then\n                      Error_Pragma\n                        (\"incorrect placement of pragma% on a generic\");\n@@ -19869,6 +19864,11 @@ package body Sem_Prag is\n                      Set_SPARK_Pragma_Inherited     (Spec_Id, False);\n                      return;\n \n+                  --  Skip internally generated code\n+\n+                  elsif not Comes_From_Source (Stmt) then\n+                     null;\n+\n                   --  The pragma does not apply to a legal construct, issue an\n                   --  error and stop the analysis.\n "}, {"sha": "92317edaf497d2d24c2e1c28e38d8c79ad7a15f3", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 41, "deletions": 11, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2178830b048787f68c0b8b7c3dd3d26580a795aa/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2178830b048787f68c0b8b7c3dd3d26580a795aa/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=2178830b048787f68c0b8b7c3dd3d26580a795aa", "patch": "@@ -6210,7 +6210,6 @@ package body Sem_Res is\n       if GNATprove_Mode\n         and then Is_Overloadable (Nam)\n         and then SPARK_Mode = On\n-        and then Full_Analysis\n       then\n          --  Retrieve the body to inline from the ultimate alias of Nam, if\n          --  there is one, otherwise calls that should be inlined end up not\n@@ -6220,23 +6219,54 @@ package body Sem_Res is\n             Nam_Alias : constant Entity_Id := Ultimate_Alias (Nam);\n             Decl : constant Node_Id := Unit_Declaration_Node (Nam_Alias);\n          begin\n-            if Nkind (Decl) = N_Subprogram_Declaration\n-              and then Can_Be_Inlined_In_GNATprove_Mode (Nam_Alias, Empty)\n-              and then No (Corresponding_Body (Decl))\n+            --  If the subprogram is not eligible for inlining in GNATprove\n+            --  mode, do nothing.\n+\n+            if not Can_Be_Inlined_In_GNATprove_Mode (Nam_Alias, Empty)\n+              or else Nkind (Decl) /= N_Subprogram_Declaration\n+              or else not Is_Inlined_Always (Nam_Alias)\n             then\n-               Error_Msg_NE\n-                 (\"?cannot inline call to & (body not seen yet)\", N, Nam);\n+               null;\n+\n+            --  Calls cannot be inlined inside assertions, as GNATprove treats\n+            --  assertions as logic expressions.\n+\n+            elsif In_Assertion_Expr /= 0 then\n+               Error_Msg_NE (\"?cannot inline call to &\", N, Nam);\n+               Error_Msg_N (\"\\call appears in assertion expression\", N);\n                Set_Is_Inlined_Always (Nam_Alias, False);\n \n-            elsif Nkind (Decl) = N_Subprogram_Declaration\n-              and then Present (Body_To_Inline (Decl))\n-              and then Is_Inlined (Nam_Alias)\n-            then\n-               if Is_Potentially_Unevaluated (N) then\n+            --  Inlining should not be performed during pre-analysis\n+\n+            elsif Full_Analysis then\n+\n+               --  With the one-pass inlining technique, a call cannot be\n+               --  inlined if the corresponding body has not been seen yet.\n+\n+               if No (Corresponding_Body (Decl)) then\n+                  Error_Msg_NE\n+                    (\"?cannot inline call to & (body not seen yet)\", N, Nam);\n+                  Set_Is_Inlined_Always (Nam_Alias, False);\n+\n+               --  Nothing to do if there is no body to inline, indicating that\n+               --  the subprogram is not suitable for inlining in GNATprove\n+               --  mode.\n+\n+               elsif No (Body_To_Inline (Decl)) then\n+                  null;\n+\n+               --  Calls cannot be inlined inside potentially unevaluated\n+               --  expressions, as this would create complex actions inside\n+               --  expressions, that are not handled by GNATprove.\n+\n+               elsif Is_Potentially_Unevaluated (N) then\n                   Error_Msg_NE (\"?cannot inline call to &\", N, Nam);\n                   Error_Msg_N\n                     (\"\\call appears in potentially unevaluated context\", N);\n                   Set_Is_Inlined_Always (Nam_Alias, False);\n+\n+               --  Otherwise, inline the call\n+\n                else\n                   Expand_Inlined_Call (N, Nam_Alias, Nam);\n                end if;"}]}