{"sha": "bb79aba479cf228832b8d2c6bfb8bf420a1f6f4a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI3OWFiYTQ3OWNmMjI4ODMyYjhkMmM2YmZiOGJmNDIwYTFmNmY0YQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-08-27T12:21:11Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-08-27T12:21:11Z"}, "message": "Improve switch code emission for a balanced tree (PR tree-optimization/86847).\n\n2018-08-27  Martin Liska  <mliska@suse.cz>\n\n        PR tree-optimization/86847\n\t* tree-switch-conversion.c (switch_decision_tree::dump_case_nodes):\n        Dump also subtree probability.\n\t(switch_decision_tree::do_jump_if_equal): New function.\n\t(switch_decision_tree::emit_case_nodes): Handle special\n        situations in balanced tree that can be emitted much simpler.\n        Fix calculation of probabilities that happen in tree expansion.\n\t* tree-switch-conversion.h (struct cluster): Add\n        is_single_value_p.\n\t(struct simple_cluster): Likewise.\n\t(struct case_tree_node): Add new function has_child.\n\t(do_jump_if_equal): New.\n2018-08-27  Martin Liska  <mliska@suse.cz>\n\n        PR tree-optimization/86847\n\t* gcc.dg/tree-ssa/switch-3.c: New test.\n\t* gcc.dg/tree-ssa/vrp105.c: Remove.\n\nFrom-SVN: r263879", "tree": {"sha": "d61a4d8814d2d3bcab0e31877144218695fa88ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d61a4d8814d2d3bcab0e31877144218695fa88ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb79aba479cf228832b8d2c6bfb8bf420a1f6f4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb79aba479cf228832b8d2c6bfb8bf420a1f6f4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb79aba479cf228832b8d2c6bfb8bf420a1f6f4a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb79aba479cf228832b8d2c6bfb8bf420a1f6f4a/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "377afcd5beb350a1b7cd07b0a868a766345073e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/377afcd5beb350a1b7cd07b0a868a766345073e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/377afcd5beb350a1b7cd07b0a868a766345073e0"}], "stats": {"total": 346, "additions": 278, "deletions": 68}, "files": [{"sha": "47844ef46783088590b40f9f4be78a48a61d52ff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb79aba479cf228832b8d2c6bfb8bf420a1f6f4a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb79aba479cf228832b8d2c6bfb8bf420a1f6f4a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bb79aba479cf228832b8d2c6bfb8bf420a1f6f4a", "patch": "@@ -1,3 +1,18 @@\n+2018-08-27  Martin Liska  <mliska@suse.cz>\n+\n+        PR tree-optimization/86847\n+\t* tree-switch-conversion.c (switch_decision_tree::dump_case_nodes):\n+        Dump also subtree probability.\n+\t(switch_decision_tree::do_jump_if_equal): New function.\n+\t(switch_decision_tree::emit_case_nodes): Handle special\n+        situations in balanced tree that can be emitted much simpler.\n+        Fix calculation of probabilities that happen in tree expansion.\n+\t* tree-switch-conversion.h (struct cluster): Add\n+        is_single_value_p.\n+\t(struct simple_cluster): Likewise.\n+\t(struct case_tree_node): Add new function has_child.\n+\t(do_jump_if_equal): New.\n+\n 2018-08-27  Martin Liska  <mliska@suse.cz>\n \n \t* tree-switch-conversion.c (bit_test_cluster::find_bit_tests):"}, {"sha": "6e74b17c2fc879265bd0b408d16c85386e33df30", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb79aba479cf228832b8d2c6bfb8bf420a1f6f4a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb79aba479cf228832b8d2c6bfb8bf420a1f6f4a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bb79aba479cf228832b8d2c6bfb8bf420a1f6f4a", "patch": "@@ -1,3 +1,9 @@\n+2018-08-27  Martin Liska  <mliska@suse.cz>\n+\n+        PR tree-optimization/86847\n+\t* gcc.dg/tree-ssa/switch-3.c: New test.\n+\t* gcc.dg/tree-ssa/vrp105.c: Remove.\n+\n 2018-08-27  Martin Liska  <mliska@suse.cz>\n \n \t* gcc.dg/tree-ssa/switch-2.c: New test."}, {"sha": "44981e1d1861fc7596929a90bdbf6878d8a4caf3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/switch-3.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb79aba479cf228832b8d2c6bfb8bf420a1f6f4a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fswitch-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb79aba479cf228832b8d2c6bfb8bf420a1f6f4a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fswitch-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fswitch-3.c?ref=bb79aba479cf228832b8d2c6bfb8bf420a1f6f4a", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-options \"-O2 -fdump-tree-switchlower1\" } */\n+\n+int cipher_to_alg(int cipher)        \n+{                                    \n+  switch (cipher)              \n+    {                            \n+      case 8:   return 2;  \n+      case 16:  return 3;  \n+      case 32:  return 4;  \n+      case 64:  return 6;  \n+      case 256: return 9;  \n+      case 512: return 10; \n+      case 2048: return 11;\n+      case 4096: return 12;\n+      case 8192: return 13;\n+    }                            \n+  return 0;                    \n+}     \n+\n+/* { dg-final { scan-tree-dump-times \"if \\\\(cipher\\[^\\n ]*\" 12 \"switchlower1\" } } */"}, {"sha": "7cdd4dd8f3a5c47d70651386e57ac0016bcc6993", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp105.c", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/377afcd5beb350a1b7cd07b0a868a766345073e0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp105.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/377afcd5beb350a1b7cd07b0a868a766345073e0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp105.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp105.c?ref=377afcd5beb350a1b7cd07b0a868a766345073e0", "patch": "@@ -1,37 +0,0 @@\n-/* PR tree-optimization/18046  */\n-/* { dg-options \"-O2 -fdump-tree-vrp2-details\" }  */\n-/* { dg-final { scan-tree-dump-times \"Threaded jump\" 1 \"vrp2\" } }  */\n-/* In the 2nd VRP pass (after PRE) we expect to thread the default label of the\n-   1st switch straight to that of the 2nd switch.  */\n-\n-extern void foo (void);\n-extern void bar (void);\n-\n-extern int i;\n-void\n-test (void)\n-{\n-  switch (i)\n-    {\n-    case 0:\n-      foo ();\n-      break;\n-    case 1:\n-      bar ();\n-      break;\n-    default:\n-      break;\n-    }\n-\n-  switch (i)\n-    {\n-    case 0:\n-      foo ();\n-      break;\n-    case 1:\n-      bar ();\n-      break;\n-    default:\n-      break;\n-    }\n-}"}, {"sha": "a31ff94b895d9ce5606e070295ad00fd96d6188a", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 213, "deletions": 31, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb79aba479cf228832b8d2c6bfb8bf420a1f6f4a/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb79aba479cf228832b8d2c6bfb8bf420a1f6f4a/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=bb79aba479cf228832b8d2c6bfb8bf420a1f6f4a", "patch": "@@ -2004,7 +2004,9 @@ switch_decision_tree::dump_case_nodes (FILE *f, case_tree_node *root,\n   fprintf (f, \"%*s\", indent_step * indent_level, \"\");\n   root->m_c->dump (f);\n   root->m_c->m_prob.dump (f);\n-  fputs (\"\\n\", f);\n+  fputs (\" subtree: \", f);\n+  root->m_c->m_subtree_prob.dump (f);\n+  fputs (\")\\n\", f);\n \n   dump_case_nodes (f, root->m_right, indent_step, indent_level);\n }\n@@ -2050,6 +2052,34 @@ switch_decision_tree::emit_cmp_and_jump_insns (basic_block bb, tree op0,\n   return false_edge->dest;\n }\n \n+/* Generate code to jump to LABEL if OP0 and OP1 are equal.\n+   PROB is the probability of jumping to LABEL_BB.\n+   BB is a basic block where the new condition will be placed.  */\n+\n+basic_block\n+switch_decision_tree::do_jump_if_equal (basic_block bb, tree op0, tree op1,\n+\t\t\t\t\tbasic_block label_bb,\n+\t\t\t\t\tprofile_probability prob)\n+{\n+  op1 = fold_convert (TREE_TYPE (op0), op1);\n+\n+  gcond *cond = gimple_build_cond (EQ_EXPR, op0, op1, NULL_TREE, NULL_TREE);\n+  gimple_stmt_iterator gsi = gsi_last_bb (bb);\n+  gsi_insert_before (&gsi, cond, GSI_SAME_STMT);\n+\n+  gcc_assert (single_succ_p (bb));\n+\n+  /* Make a new basic block where false branch will take place.  */\n+  edge false_edge = split_block (bb, cond);\n+  false_edge->flags = EDGE_FALSE_VALUE;\n+  false_edge->probability = prob.invert ();\n+\n+  edge true_edge = make_edge (bb, label_bb, EDGE_TRUE_VALUE);\n+  true_edge->probability = prob;\n+\n+  return false_edge->dest;\n+}\n+\n /* Emit step-by-step code to select a case for the value of INDEX.\n    The thus generated decision tree follows the form of the\n    case-node binary tree NODE, whose nodes represent test conditions.\n@@ -2062,41 +2092,193 @@ switch_decision_tree::emit_case_nodes (basic_block bb, tree index,\n \t\t\t\t       profile_probability default_prob,\n \t\t\t\t       tree index_type)\n {\n+  profile_probability p;\n+\n   /* If node is null, we are done.  */\n   if (node == NULL)\n     return bb;\n \n-  /* Branch to a label where we will handle it later.  */\n-  basic_block test_bb = split_edge (single_succ_edge (bb));\n-  redirect_edge_succ (single_pred_edge (test_bb),\n-\t\t      single_succ_edge (bb)->dest);\n-\n-  profile_probability probability\n-    = (node->m_right\n-       ? node->m_right->m_c->m_subtree_prob : profile_probability::never ());\n-  probability = ((probability + default_prob.apply_scale (1, 2))\n-\t\t / (node->m_c->m_subtree_prob + default_prob));\n-  bb = emit_cmp_and_jump_insns (bb, index, node->m_c->get_high (), GT_EXPR,\n-\t\t\t\ttest_bb, probability);\n-  default_prob = default_prob.apply_scale (1, 2);\n-\n-  /* Value belongs to this node or to the left-hand subtree.  */\n-  probability = node->m_c->m_prob /\n-    (node->m_c->m_subtree_prob + default_prob);\n-  bb = emit_cmp_and_jump_insns (bb, index, node->m_c->get_low (), GE_EXPR,\n-\t\t\t\tnode->m_c->m_case_bb, probability);\n-\n-  /* Handle the left-hand subtree.  */\n-  bb = emit_case_nodes (bb, index, node->m_left,\n-\t\t\tdefault_prob, index_type);\n-\n-  /* If the left-hand subtree fell through,\n-     don't let it fall into the right-hand subtree.  */\n-  if (m_default_bb)\n-    emit_jump (bb, m_default_bb);\n+  /* Single value case.  */\n+  if (node->m_c->is_single_value_p ())\n+    {\n+      /* Node is single valued.  First see if the index expression matches\n+\t this node and then check our children, if any.  */\n+      p = node->m_c->m_prob / (node->m_c->m_subtree_prob + default_prob);\n+      bb = do_jump_if_equal (bb, index, node->m_c->get_low (),\n+\t\t\t     node->m_c->m_case_bb, p);\n+      /* Since this case is taken at this point, reduce its weight from\n+\t subtree_weight.  */\n+      node->m_c->m_subtree_prob -= p;\n+\n+      if (node->m_left != NULL && node->m_right != NULL)\n+\t{\n+\t  /* 1) the node has both children\n+\n+\t     If both children are single-valued cases with no\n+\t     children, finish up all the work.  This way, we can save\n+\t     one ordered comparison.  */\n+\n+\t  if (!node->m_left->has_child ()\n+\t      && node->m_left->m_c->is_single_value_p ()\n+\t      && !node->m_right->has_child ()\n+\t      && node->m_right->m_c->is_single_value_p ())\n+\t    {\n+\t      p = (node->m_right->m_c->m_prob\n+\t\t   / (node->m_c->m_subtree_prob + default_prob));\n+\t      bb = do_jump_if_equal (bb, index, node->m_right->m_c->get_low (),\n+\t\t\t\t     node->m_right->m_c->m_case_bb, p);\n+\n+\t      p = (node->m_left->m_c->m_prob\n+\t\t   / (node->m_c->m_subtree_prob + default_prob));\n+\t      bb = do_jump_if_equal (bb, index, node->m_left->m_c->get_low (),\n+\t\t\t\t     node->m_left->m_c->m_case_bb, p);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Branch to a label where we will handle it later.  */\n+\t      basic_block test_bb = split_edge (single_succ_edge (bb));\n+\t      redirect_edge_succ (single_pred_edge (test_bb),\n+\t\t\t\t  single_succ_edge (bb)->dest);\n+\n+\t      p = ((node->m_right->m_c->m_subtree_prob\n+\t\t    + default_prob.apply_scale (1, 2))\n+\t\t   / (node->m_c->m_subtree_prob + default_prob));\n+\t      bb = emit_cmp_and_jump_insns (bb, index, node->m_c->get_high (),\n+\t\t\t\t\t    GT_EXPR, test_bb, p);\n+\t      default_prob = default_prob.apply_scale (1, 2);\n+\n+\t      /* Handle the left-hand subtree.  */\n+\t      bb = emit_case_nodes (bb, index, node->m_left,\n+\t\t\t\t    default_prob, index_type);\n+\n+\t      /* If the left-hand subtree fell through,\n+\t\t don't let it fall into the right-hand subtree.  */\n+\t      if (bb && m_default_bb)\n+\t\temit_jump (bb, m_default_bb);\n+\n+\t      bb = emit_case_nodes (test_bb, index, node->m_right,\n+\t\t\t\t    default_prob, index_type);\n+\t    }\n+\t}\n+      else if (node->m_left == NULL && node->m_right != NULL)\n+\t{\n+\t  /* 2) the node has only right child.  */\n \n-  bb = emit_case_nodes (test_bb, index, node->m_right,\n-\t\t\tdefault_prob, index_type);\n+\t  /* Here we have a right child but no left so we issue a conditional\n+\t     branch to default and process the right child.\n+\n+\t     Omit the conditional branch to default if the right child\n+\t     does not have any children and is single valued; it would\n+\t     cost too much space to save so little time.  */\n+\n+\t  if (node->m_right->has_child ()\n+\t      || !node->m_right->m_c->is_single_value_p ())\n+\t    {\n+\t      p = (default_prob.apply_scale (1, 2)\n+\t\t   / (node->m_c->m_subtree_prob + default_prob));\n+\t      bb = emit_cmp_and_jump_insns (bb, index, node->m_c->get_low (),\n+\t\t\t\t\t    LT_EXPR, m_default_bb, p);\n+\t      default_prob = default_prob.apply_scale (1, 2);\n+\n+\t      bb = emit_case_nodes (bb, index, node->m_right, default_prob,\n+\t\t\t\t    index_type);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* We cannot process node->right normally\n+\t\t since we haven't ruled out the numbers less than\n+\t\t this node's value.  So handle node->right explicitly.  */\n+\t      p = (node->m_right->m_c->m_subtree_prob\n+\t\t   / (node->m_c->m_subtree_prob + default_prob));\n+\t      bb = do_jump_if_equal (bb, index, node->m_right->m_c->get_low (),\n+\t\t\t\t     node->m_right->m_c->m_case_bb, p);\n+\t    }\n+\t}\n+      else if (node->m_left != NULL && node->m_right == NULL)\n+\t{\n+\t  /* 3) just one subtree, on the left.  Similar case as previous.  */\n+\n+\t  if (node->m_left->has_child ()\n+\t      || !node->m_left->m_c->is_single_value_p ())\n+\t    {\n+\t      p = (default_prob.apply_scale (1, 2)\n+\t\t   / (node->m_c->m_subtree_prob + default_prob));\n+\t      bb = emit_cmp_and_jump_insns (bb, index, node->m_c->get_high (),\n+\t\t\t\t\t    GT_EXPR, m_default_bb, p);\n+\t\t  default_prob = default_prob.apply_scale (1, 2);\n+\n+\t      bb = emit_case_nodes (bb, index, node->m_left, default_prob,\n+\t\t\t\t    index_type);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* We cannot process node->left normally\n+\t\t since we haven't ruled out the numbers less than\n+\t\t this node's value.  So handle node->left explicitly.  */\n+\t      p = (node->m_left->m_c->m_subtree_prob\n+\t\t   / (node->m_c->m_subtree_prob + default_prob));\n+\t      bb = do_jump_if_equal (bb, index, node->m_left->m_c->get_low (),\n+\t\t\t\t     node->m_left->m_c->m_case_bb, p);\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      /* Node is a range.  These cases are very similar to those for a single\n+\t value, except that we do not start by testing whether this node\n+\t is the one to branch to.  */\n+      if (node->has_child () || node->m_c->get_type () != SIMPLE_CASE)\n+\t{\n+\t  /* Branch to a label where we will handle it later.  */\n+\t  basic_block test_bb = split_edge (single_succ_edge (bb));\n+\t  redirect_edge_succ (single_pred_edge (test_bb),\n+\t\t\t      single_succ_edge (bb)->dest);\n+\n+\n+\t   profile_probability right_prob = profile_probability::never ();\n+\t   if (node->m_right)\n+\t     right_prob = node->m_right->m_c->m_subtree_prob;\n+\t  p = ((right_prob + default_prob.apply_scale (1, 2))\n+\t       / (node->m_c->m_subtree_prob + default_prob));\n+\n+\t  bb = emit_cmp_and_jump_insns (bb, index, node->m_c->get_high (),\n+\t\t\t\t\tGT_EXPR, test_bb, p);\n+\t  default_prob = default_prob.apply_scale (1, 2);\n+\n+\t  /* Value belongs to this node or to the left-hand subtree.  */\n+\t  p = node->m_c->m_prob / (node->m_c->m_subtree_prob + default_prob);\n+\t  bb = emit_cmp_and_jump_insns (bb, index, node->m_c->get_low (),\n+\t\t\t\t\tGE_EXPR, node->m_c->m_case_bb, p);\n+\n+\t  /* Handle the left-hand subtree.  */\n+\t  bb = emit_case_nodes (bb, index, node->m_left,\n+\t\t\t\tdefault_prob, index_type);\n+\n+\t  /* If the left-hand subtree fell through,\n+\t     don't let it fall into the right-hand subtree.  */\n+\t  if (bb && m_default_bb)\n+\t    emit_jump (bb, m_default_bb);\n+\n+\t  bb = emit_case_nodes (test_bb, index, node->m_right,\n+\t\t\t\tdefault_prob, index_type);\n+\t}\n+      else\n+\t{\n+\t  /* Node has no children so we check low and high bounds to remove\n+\t     redundant tests.  Only one of the bounds can exist,\n+\t     since otherwise this node is bounded--a case tested already.  */\n+\t  tree lhs, rhs;\n+\t  generate_range_test (bb, index, node->m_c->get_low (),\n+\t\t\t       node->m_c->get_high (), &lhs, &rhs);\n+\t  p = default_prob / (node->m_c->m_subtree_prob + default_prob);\n+\n+\t  bb = emit_cmp_and_jump_insns (bb, lhs, rhs, GT_EXPR,\n+\t\t\t\t\tm_default_bb, p);\n+\n+\t  emit_jump (bb, node->m_c->m_case_bb);\n+\t  return NULL;\n+\t}\n+    }\n \n   return bb;\n }"}, {"sha": "37ed21937244ad5be6ee159f27c819bb64db6622", "filename": "gcc/tree-switch-conversion.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb79aba479cf228832b8d2c6bfb8bf420a1f6f4a/gcc%2Ftree-switch-conversion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb79aba479cf228832b8d2c6bfb8bf420a1f6f4a/gcc%2Ftree-switch-conversion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.h?ref=bb79aba479cf228832b8d2c6bfb8bf420a1f6f4a", "patch": "@@ -72,6 +72,13 @@ struct cluster\n   /* Emit GIMPLE code to handle the cluster.  */\n   virtual void emit (tree, tree, tree, basic_block) = 0;\n \n+  /* Return true if a cluster handles only a single case value and the\n+     value is not a range.  */\n+  virtual bool is_single_value_p ()\n+  {\n+    return false;\n+  }\n+\n   /* Return range of a cluster.  If value would overflow in type of LOW,\n      then return 0.  */\n   static unsigned HOST_WIDE_INT get_range (tree low, tree high)\n@@ -161,6 +168,11 @@ struct simple_cluster: public cluster\n     gcc_unreachable ();\n   }\n \n+  bool is_single_value_p ()\n+  {\n+    return tree_int_cst_equal (get_low (), get_high ());\n+  }\n+\n   /* Low value of the case.  */\n   tree m_low;\n \n@@ -435,6 +447,12 @@ struct case_tree_node\n   /* Empty Constructor.  */\n   case_tree_node ();\n \n+  /* Return true when it has a child.  */\n+  bool has_child ()\n+  {\n+    return m_left != NULL || m_right != NULL;\n+  }\n+\n   /* Left son in binary tree.  */\n   case_tree_node *m_left;\n \n@@ -578,6 +596,12 @@ struct switch_decision_tree\n \t\t\t\t\t      basic_block label_bb,\n \t\t\t\t\t      profile_probability prob);\n \n+  /* Generate code to jump to LABEL if OP0 and OP1 are equal in mode MODE.\n+     PROB is the probability of jumping to LABEL_BB.  */\n+  static basic_block do_jump_if_equal (basic_block bb, tree op0, tree op1,\n+\t\t\t\t       basic_block label_bb,\n+\t\t\t\t       profile_probability prob);\n+\n   /* Reset the aux field of all outgoing edges of switch basic block.  */\n   static inline void reset_out_edges_aux (gswitch *swtch);\n "}]}