{"sha": "2a33a75f60261a6012d4840ac3bbe15c5e2c84d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmEzM2E3NWY2MDI2MWE2MDEyZDQ4NDBhYzNiYmUxNWM1ZTJjODRkOA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2007-01-11T21:26:02Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2007-01-11T21:26:02Z"}, "message": "ifcvt.c (struct noce_if_info): Add comments to the fields.\n\n\t* ifcvt.c (struct noce_if_info): Add comments to the fields.\n\tRemove the b_unconditional field.\n\t(noce_try_sign_mask): Do not look at b_unconditional.\n\t(noce_process_if_block): Do not use merge_if_blocks.  Update\n\tthe CFG here.  Do not set b_unconditional.\n\t(cond_move_process_if_block): Likewise.\n\t(find_cond_trap): Likewise.\n\t(check_cond_move_block): Require simple jump insns at the end\n\tof the basic block.\n\nFrom-SVN: r120686", "tree": {"sha": "673e586ce2cd1320a6a6e0fc6f0e63f0aceea817", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/673e586ce2cd1320a6a6e0fc6f0e63f0aceea817"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a33a75f60261a6012d4840ac3bbe15c5e2c84d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a33a75f60261a6012d4840ac3bbe15c5e2c84d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a33a75f60261a6012d4840ac3bbe15c5e2c84d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a33a75f60261a6012d4840ac3bbe15c5e2c84d8/comments", "author": null, "committer": null, "parents": [{"sha": "90d715b0a524cb1dc534f470bc552915bb41663c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90d715b0a524cb1dc534f470bc552915bb41663c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90d715b0a524cb1dc534f470bc552915bb41663c"}], "stats": {"total": 160, "additions": 107, "deletions": 53}, "files": [{"sha": "ba94be3fcc6945237eb72fcea63be5fb626a4b45", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a33a75f60261a6012d4840ac3bbe15c5e2c84d8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a33a75f60261a6012d4840ac3bbe15c5e2c84d8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2a33a75f60261a6012d4840ac3bbe15c5e2c84d8", "patch": "@@ -1,3 +1,15 @@\n+2007-01-11  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* ifcvt.c (struct noce_if_info): Add comments to the fields.\n+\tRemove the b_unconditional field.\n+\t(noce_try_sign_mask): Do not look at b_unconditional.\n+\t(noce_process_if_block): Do not use merge_if_blocks.  Update\n+\tthe CFG here.  Do not set b_unconditional.\n+\t(cond_move_process_if_block): Likewise.\n+\t(find_cond_trap): Likewise.\n+\t(check_cond_move_block): Require simple jump insns at the end\n+\tof the basic block.\n+\n 2007-01-11  Jan Hubicka  <jh@suse.cz>\n \n \tPR tree-optimization/1046"}, {"sha": "74696d7f1af8d2a344a6ff4f17d87850e2dbec09", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 95, "deletions": 53, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a33a75f60261a6012d4840ac3bbe15c5e2c84d8/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a33a75f60261a6012d4840ac3bbe15c5e2c84d8/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=2a33a75f60261a6012d4840ac3bbe15c5e2c84d8", "patch": "@@ -596,12 +596,31 @@ cond_exec_process_if_block (ce_if_block_t * ce_info,\n \n struct noce_if_info\n {\n+  /* A basic block that ends in a simple conditional jump.  */\n   basic_block test_bb;\n+\n+  /* The jump that ends TEST_BB.  */\n+  rtx jump;\n+ \n+  /* The jump condition.  */\n+  rtx cond;\n+\n+  /* New insns should be inserted before this one.  */\n+  rtx cond_earliest;\n+\n+  /* Insns in the THEN and ELSE block.  There is always just this\n+     one insns in those blocks.  The insns are single_set insns.\n+     If there was no ELSE block, INSN_B is the last insn before\n+     COND_EARLIEST, or NULL_RTX.  In the former case, the insn\n+     operands are still valid, as if INSN_B was moved down below\n+     the jump.  */\n   rtx insn_a, insn_b;\n-  rtx x, a, b;\n-  rtx jump, cond, cond_earliest;\n-  /* True if \"b\" was originally evaluated unconditionally.  */\n-  bool b_unconditional;\n+\n+  /* The SET_SRC of INSN_A and INSN_B.  */\n+  rtx a, b;\n+\n+  /* The SET_DEST of INSN_A.  */\n+  rtx x;\n };\n \n static rtx noce_emit_store_flag (struct noce_if_info *, rtx, int, int);\n@@ -1877,9 +1896,10 @@ noce_try_sign_mask (struct noce_if_info *if_info)\n     return FALSE;\n \n   /* This is only profitable if T is cheap, or T is unconditionally\n-     executed/evaluated in the original insn sequence.  */\n+     executed/evaluated in the original insn sequence.  The latter\n+     happens if INSN_B was taken from TEST_BB.  */\n   if (rtx_cost (t, SET) >= COSTS_N_INSNS (2)\n-      && (!if_info->b_unconditional\n+      && (BLOCK_FOR_INSN (if_info->insn_b) != if_info->test_bb\n           || t != if_info->b))\n     return FALSE;\n \n@@ -2173,6 +2193,7 @@ noce_process_if_block (struct ce_if_block * ce_info)\n   basic_block test_bb = ce_info->test_bb;\t/* test block */\n   basic_block then_bb = ce_info->then_bb;\t/* THEN */\n   basic_block else_bb = ce_info->else_bb;\t/* ELSE or NULL */\n+  basic_block join_bb;\n   struct noce_if_info if_info;\n   rtx insn_a, insn_b;\n   rtx set_a, set_b;\n@@ -2283,7 +2304,6 @@ noce_process_if_block (struct ce_if_block * ce_info)\n   if_info.x = x;\n   if_info.a = a;\n   if_info.b = b;\n-  if_info.b_unconditional = else_bb == 0;\n \n   /* Try optimizations in some approximation of a useful order.  */\n   /* ??? Should first look to see if X is live incoming at all.  If it\n@@ -2364,39 +2384,47 @@ noce_process_if_block (struct ce_if_block * ce_info)\n   return FALSE;\n \n  success:\n-  /* The original sets may now be killed.  */\n-  delete_insn (insn_a);\n-\n-  /* Several special cases here: First, we may have reused insn_b above,\n-     in which case insn_b is now NULL.  Second, we want to delete insn_b\n-     if it came from the ELSE block, because follows the now correct\n-     write that appears in the TEST block.  However, if we got insn_b from\n-     the TEST block, it may in fact be loading data needed for the comparison.\n-     We'll let life_analysis remove the insn if it's really dead.  */\n-  if (insn_b && else_bb)\n-    delete_insn (insn_b);\n-\n-  /* The new insns will have been inserted immediately before the jump.  We\n-     should be able to remove the jump with impunity, but the condition itself\n-     may have been modified by gcse to be shared across basic blocks.  */\n-  delete_insn (jump);\n \n   /* If we used a temporary, fix it up now.  */\n   if (orig_x != x)\n     {\n+      rtx seq;\n+\n       start_sequence ();\n       noce_emit_move_insn (orig_x, x);\n-      insn_b = get_insns ();\n+      seq = get_insns ();\n       set_used_flags (orig_x);\n-      unshare_all_rtl_in_chain (insn_b);\n+      unshare_all_rtl_in_chain (seq);\n       end_sequence ();\n \n-      emit_insn_after_setloc (insn_b, BB_END (test_bb), INSN_LOCATOR (insn_a));\n+      emit_insn_before_setloc (seq, BB_END (test_bb), INSN_LOCATOR (insn_a));\n     }\n \n-  /* Merge the blocks!  */\n-  merge_if_block (ce_info);\n+  /* The original THEN and ELSE blocks may now be removed.  The test block\n+     must now jump to the join block.  If the test block and the join block\n+     can be merged, do so.  */\n \n+  join_bb = single_succ (then_bb);\n+  if (else_bb)\n+    {\n+      delete_basic_block (else_bb);\n+      num_true_changes++;\n+    }\n+  else\n+    remove_edge (find_edge (test_bb, join_bb));\n+\n+  remove_edge (find_edge (then_bb, join_bb));\n+  redirect_edge_and_branch_force (single_succ_edge (test_bb), join_bb);\n+  delete_basic_block (then_bb);\n+  num_true_changes++;\n+  \n+  if (can_merge_blocks_p (test_bb, join_bb))\n+    {\n+      merge_blocks (test_bb, join_bb);\n+      num_true_changes++;\n+    }\n+\n+  num_updated_if_blocks++;\n   return TRUE;\n }\n \n@@ -2463,6 +2491,12 @@ check_cond_move_block (basic_block bb, rtx *vals, rtx cond)\n \treturn FALSE;\n     }\n \n+  /* We can only handle simple jumps at the end of the basic block.\n+     It is almost impossible to update the CFG otherwise.  */\n+  insn = BB_END (bb);\n+  if (JUMP_P (insn) && ! onlyjump_p (insn))\n+    return FALSE;\n+  \n   return TRUE;\n }\n \n@@ -2537,10 +2571,12 @@ cond_move_convert_if_block (struct noce_if_info *if_infop,\n static int\n cond_move_process_if_block (struct ce_if_block *ce_info)\n {\n+  basic_block test_bb = ce_info->test_bb;\n   basic_block then_bb = ce_info->then_bb;\n   basic_block else_bb = ce_info->else_bb;\n+  basic_block join_bb;\n   struct noce_if_info if_info;\n-  rtx jump, cond, insn, seq, loc_insn;\n+  rtx jump, cond, seq, loc_insn;\n   int max_reg, size, c, i;\n   rtx *then_vals;\n   rtx *else_vals;\n@@ -2624,21 +2660,30 @@ cond_move_process_if_block (struct ce_if_block *ce_info)\n     }\n   emit_insn_before_setloc (seq, jump, INSN_LOCATOR (loc_insn));\n \n-  FOR_BB_INSNS (then_bb, insn)\n-    if (INSN_P (insn) && !JUMP_P (insn))\n-      delete_insn (insn);\n+  join_bb = single_succ (then_bb);\n   if (else_bb)\n     {\n-      FOR_BB_INSNS (else_bb, insn)\n-\tif (INSN_P (insn) && !JUMP_P (insn))\n-\t  delete_insn (insn);\n+      delete_basic_block (else_bb);\n+      num_true_changes++;\n     }\n-  delete_insn (jump);\n+  else\n+    remove_edge (find_edge (test_bb, join_bb));\n \n-  merge_if_block (ce_info);\n+  remove_edge (find_edge (then_bb, join_bb));\n+  redirect_edge_and_branch_force (single_succ_edge (test_bb), join_bb);\n+  delete_basic_block (then_bb);\n+  num_true_changes++;\n+  \n+  if (can_merge_blocks_p (test_bb, join_bb))\n+    {\n+      merge_blocks (test_bb, join_bb);\n+      num_true_changes++;\n+    }\n \n+  num_updated_if_blocks++;\n   return TRUE;\n }\n+\n \f\n /* Attempt to convert an IF-THEN or IF-THEN-ELSE block into\n    straight line code.  Return true if successful.  */\n@@ -3201,29 +3246,20 @@ find_cond_trap (basic_block test_bb, edge then_edge, edge else_edge)\n   if (seq == NULL)\n     return FALSE;\n \n-  num_true_changes++;\n-\n   /* Emit the new insns before cond_earliest.  */\n   emit_insn_before_setloc (seq, cond_earliest, INSN_LOCATOR (trap));\n \n   /* Delete the trap block if possible.  */\n   remove_edge (trap_bb == then_bb ? then_edge : else_edge);\n   if (EDGE_COUNT (trap_bb->preds) == 0)\n-    delete_basic_block (trap_bb);\n-\n-  /* If the non-trap block and the test are now adjacent, merge them.\n-     Otherwise we must insert a direct branch.  */\n-  if (test_bb->next_bb == other_bb)\n     {\n-      struct ce_if_block new_ce_info;\n-      delete_insn (jump);\n-      memset (&new_ce_info, '\\0', sizeof (new_ce_info));\n-      new_ce_info.test_bb = test_bb;\n-      new_ce_info.then_bb = NULL;\n-      new_ce_info.else_bb = NULL;\n-      new_ce_info.join_bb = other_bb;\n-      merge_if_block (&new_ce_info);\n+      delete_basic_block (trap_bb);\n+      num_true_changes++;\n     }\n+\n+  /* Wire together the blocks again.  */\n+  if (current_ir_type () == IR_RTL_CFGLAYOUT)\n+    single_succ_edge (test_bb)->flags |= EDGE_FALLTHRU;\n   else\n     {\n       rtx lab, newjump;\n@@ -3233,10 +3269,16 @@ find_cond_trap (basic_block test_bb, edge then_edge, edge else_edge)\n       LABEL_NUSES (lab) += 1;\n       JUMP_LABEL (newjump) = lab;\n       emit_barrier_after (newjump);\n+    }\n+  delete_insn (jump);\n \n-      delete_insn (jump);\n+  if (can_merge_blocks_p (test_bb, other_bb))\n+    {\n+      merge_blocks (test_bb, other_bb);\n+      num_true_changes++;\n     }\n \n+  num_updated_if_blocks++;\n   return TRUE;\n }\n "}]}