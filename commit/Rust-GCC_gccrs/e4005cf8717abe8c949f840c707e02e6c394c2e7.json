{"sha": "e4005cf8717abe8c949f840c707e02e6c394c2e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQwMDVjZjg3MTdhYmU4Yzk0OWY4NDBjNzA3ZTAyZTZjMzk0YzJlNw==", "commit": {"author": {"name": "Alex Coplan", "email": "alex.coplan@arm.com", "date": "2021-03-29T11:18:19Z"}, "committer": {"name": "Alex Coplan", "email": "alex.coplan@arm.com", "date": "2021-03-29T11:18:19Z"}, "message": "aarch64: Fix SVE ACLE builtins with LTO [PR99216]\n\nAs discussed in the PR, we currently have two different numbering\nschemes for SVE builtins: one for C, and one for C++. This is\nproblematic for LTO, where we end up getting confused about which\nintrinsic we're talking about. This patch inserts placeholders into the\nregistered_functions vector to ensure that there is a consistent\nnumbering scheme for both C and C++.\n\nWe use integer_zero_node as a placeholder node instead of building a\nfunction decl. This is safe because the node is only returned by the\nTARGET_BUILTIN_DECL hook, which (on AArch64) is only used for validation\nwhen builtin decls are streamed into lto1.\n\ngcc/ChangeLog:\n\n\tPR target/99216\n\t* config/aarch64/aarch64-sve-builtins.cc\n\t(function_builder::add_function): Add placeholder_p argument, use\n\tplaceholder decls if this is set.\n\t(function_builder::add_unique_function): Instead of conditionally adding\n\tdirect overloads, unconditionally add either a direct overload or a\n\tplaceholder.\n\t(function_builder::add_overloaded_function): Set placeholder_p if we're\n\tusing C++ overloads. Use the obstack for string storage instead\n\tof relying on the tree nodes.\n\t(function_builder::add_overloaded_functions): Don't return early for\n\tm_direct_overloads: we need to add placeholders.\n\t* config/aarch64/aarch64-sve-builtins.h\n\t(function_builder::add_function): Add placeholder_p argument.\n\ngcc/testsuite/ChangeLog:\n\n\tPR target/99216\n\t* g++.target/aarch64/sve/pr99216.C: New test.", "tree": {"sha": "cf1294a14115be417d75d18b4b8c52f6ce68930e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf1294a14115be417d75d18b4b8c52f6ce68930e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4005cf8717abe8c949f840c707e02e6c394c2e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4005cf8717abe8c949f840c707e02e6c394c2e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4005cf8717abe8c949f840c707e02e6c394c2e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4005cf8717abe8c949f840c707e02e6c394c2e7/comments", "author": {"login": "acoplan-arm", "id": 86676934, "node_id": "MDQ6VXNlcjg2Njc2OTM0", "avatar_url": "https://avatars.githubusercontent.com/u/86676934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/acoplan-arm", "html_url": "https://github.com/acoplan-arm", "followers_url": "https://api.github.com/users/acoplan-arm/followers", "following_url": "https://api.github.com/users/acoplan-arm/following{/other_user}", "gists_url": "https://api.github.com/users/acoplan-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/acoplan-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/acoplan-arm/subscriptions", "organizations_url": "https://api.github.com/users/acoplan-arm/orgs", "repos_url": "https://api.github.com/users/acoplan-arm/repos", "events_url": "https://api.github.com/users/acoplan-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/acoplan-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "acoplan-arm", "id": 86676934, "node_id": "MDQ6VXNlcjg2Njc2OTM0", "avatar_url": "https://avatars.githubusercontent.com/u/86676934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/acoplan-arm", "html_url": "https://github.com/acoplan-arm", "followers_url": "https://api.github.com/users/acoplan-arm/followers", "following_url": "https://api.github.com/users/acoplan-arm/following{/other_user}", "gists_url": "https://api.github.com/users/acoplan-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/acoplan-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/acoplan-arm/subscriptions", "organizations_url": "https://api.github.com/users/acoplan-arm/orgs", "repos_url": "https://api.github.com/users/acoplan-arm/repos", "events_url": "https://api.github.com/users/acoplan-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/acoplan-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8cf2812cfceaf464dff99651b2d911d6e12b52b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cf2812cfceaf464dff99651b2d911d6e12b52b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cf2812cfceaf464dff99651b2d911d6e12b52b7"}], "stats": {"total": 67, "additions": 43, "deletions": 24}, "files": [{"sha": "f44f81f13754b2d7f7391086c846ee2f966d54a7", "filename": "gcc/config/aarch64/aarch64-sve-builtins.cc", "status": "modified", "additions": 36, "deletions": 23, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4005cf8717abe8c949f840c707e02e6c394c2e7/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4005cf8717abe8c949f840c707e02e6c394c2e7/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc?ref=e4005cf8717abe8c949f840c707e02e6c394c2e7", "patch": "@@ -999,12 +999,29 @@ registered_function &\n function_builder::add_function (const function_instance &instance,\n \t\t\t\tconst char *name, tree fntype, tree attrs,\n \t\t\t\tuint64_t required_extensions,\n-\t\t\t\tbool overloaded_p)\n+\t\t\t\tbool overloaded_p,\n+\t\t\t\tbool placeholder_p)\n {\n   unsigned int code = vec_safe_length (registered_functions);\n   code = (code << AARCH64_BUILTIN_SHIFT) | AARCH64_BUILTIN_SVE;\n-  tree decl = simulate_builtin_function_decl (input_location, name, fntype,\n-\t\t\t\t\t      code, NULL, attrs);\n+\n+  /* We need to be able to generate placeholders to enusre that we have a\n+     consistent numbering scheme for function codes between the C and C++\n+     frontends, so that everything ties up in LTO.\n+\n+     Currently, tree-streamer-in.c:unpack_ts_function_decl_value_fields\n+     validates that tree nodes returned by TARGET_BUILTIN_DECL are non-NULL and\n+     some node other than error_mark_node. This is a holdover from when builtin\n+     decls were streamed by code rather than by value.\n+\n+     Ultimately, we should be able to remove this validation of BUILT_IN_MD\n+     nodes and remove the target hook. For now, however, we need to appease the\n+     validation and return a non-NULL, non-error_mark_node node, so we\n+     arbitrarily choose integer_zero_node.  */\n+  tree decl = placeholder_p\n+    ? integer_zero_node\n+    : simulate_builtin_function_decl (input_location, name, fntype,\n+\t\t\t\t      code, NULL, attrs);\n \n   registered_function &rfn = *ggc_alloc <registered_function> ();\n   rfn.instance = instance;\n@@ -1036,7 +1053,7 @@ function_builder::add_unique_function (const function_instance &instance,\n \t\t\t\t\t   argument_types.address ());\n   tree attrs = get_attributes (instance);\n   registered_function &rfn = add_function (instance, name, fntype, attrs,\n-\t\t\t\t\t   required_extensions, false);\n+\t\t\t\t\t   required_extensions, false, false);\n \n   /* Enter the function into the hash table.  */\n   hashval_t hash = instance.hash ();\n@@ -1047,16 +1064,14 @@ function_builder::add_unique_function (const function_instance &instance,\n \n   /* Also add the function under its overloaded alias, if we want\n      a separate decl for each instance of an overloaded function.  */\n-  if (m_direct_overloads || force_direct_overloads)\n+  char *overload_name = get_name (instance, true);\n+  if (strcmp (name, overload_name) != 0)\n     {\n-      char *overload_name = get_name (instance, true);\n-      if (strcmp (name, overload_name) != 0)\n-\t{\n-\t  /* Attribute lists shouldn't be shared.  */\n-\t  tree attrs = get_attributes (instance);\n-\t  add_function (instance, overload_name, fntype, attrs,\n-\t\t\trequired_extensions, false);\n-\t}\n+      /* Attribute lists shouldn't be shared.  */\n+      tree attrs = get_attributes (instance);\n+      bool placeholder_p = !(m_direct_overloads || force_direct_overloads);\n+      add_function (instance, overload_name, fntype, attrs,\n+\t\t    required_extensions, false, placeholder_p);\n     }\n \n   obstack_free (&m_string_obstack, name);\n@@ -1077,18 +1092,19 @@ function_builder::add_overloaded_function (const function_instance &instance,\n {\n   char *name = get_name (instance, true);\n   if (registered_function **map_value = m_overload_names.get (name))\n-    gcc_assert ((*map_value)->instance == instance\n-\t\t&& ((*map_value)->required_extensions\n-\t\t    & ~required_extensions) == 0);\n+    {\n+      gcc_assert ((*map_value)->instance == instance\n+\t\t  && ((*map_value)->required_extensions\n+\t\t      & ~required_extensions) == 0);\n+      obstack_free (&m_string_obstack, name);\n+    }\n   else\n     {\n       registered_function &rfn\n \t= add_function (instance, name, m_overload_type, NULL_TREE,\n-\t\t\trequired_extensions, true);\n-      const char *permanent_name = IDENTIFIER_POINTER (DECL_NAME (rfn.decl));\n-      m_overload_names.put (permanent_name, &rfn);\n+\t\t\trequired_extensions, true, m_direct_overloads);\n+      m_overload_names.put (name, &rfn);\n     }\n-  obstack_free (&m_string_obstack, name);\n }\n \n /* If we are using manual overload resolution, add one function decl\n@@ -1098,9 +1114,6 @@ void\n function_builder::add_overloaded_functions (const function_group_info &group,\n \t\t\t\t\t    mode_suffix_index mode)\n {\n-  if (m_direct_overloads)\n-    return;\n-\n   unsigned int explicit_type0 = (*group.shape)->explicit_type_suffix_p (0);\n   unsigned int explicit_type1 = (*group.shape)->explicit_type_suffix_p (1);\n   for (unsigned int pi = 0; group.preds[pi] != NUM_PREDS; ++pi)"}, {"sha": "b701f90ac1aa393bb814ad0f6d565c049705a9b8", "filename": "gcc/config/aarch64/aarch64-sve-builtins.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4005cf8717abe8c949f840c707e02e6c394c2e7/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4005cf8717abe8c949f840c707e02e6c394c2e7/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.h?ref=e4005cf8717abe8c949f840c707e02e6c394c2e7", "patch": "@@ -337,7 +337,8 @@ class function_builder\n   tree get_attributes (const function_instance &);\n \n   registered_function &add_function (const function_instance &,\n-\t\t\t\t     const char *, tree, tree, uint64_t, bool);\n+\t\t\t\t     const char *, tree, tree,\n+\t\t\t\t     uint64_t, bool, bool);\n \n   /* The function type to use for functions that are resolved by\n      function_resolver.  */"}, {"sha": "61a58a7fcf4bbf7032670051dd832828f9fc1b9d", "filename": "gcc/testsuite/g++.target/aarch64/sve/pr99216.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4005cf8717abe8c949f840c707e02e6c394c2e7/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Fpr99216.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4005cf8717abe8c949f840c707e02e6c394c2e7/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Fpr99216.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Fpr99216.C?ref=e4005cf8717abe8c949f840c707e02e6c394c2e7", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do link { target aarch64_asm_sve_ok } } */\n+/* { dg-additional-options \"-flto\" } */\n+#include <arm_sve.h>\n+bool a;\n+int main() { a = svaddv(svptrue_b8(), svdup_s8(0)); }"}]}