{"sha": "4b685e144da6c5a196714ba7ef2fdae1fdf140e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI2ODVlMTQ0ZGE2YzVhMTk2NzE0YmE3ZWYyZmRhZTFmZGYxNDBlMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-05-10T11:36:11Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-05-10T11:36:11Z"}, "message": "re PR middle-end/40084 (Revision 147294 failed 483.xalancbmk in SPEC CPU 2006 at -O3)\n\n\tPR middle-end/40084\n\t* cgraph.c (cgraph_update_edges_for_call_stmt_node): Take old_call argument;\n\trewrite.\n\t(cgraph_update_edges_for_call_stmt): Take old_decl argument.\n\t* cgraph.h (cgraph_update_edges_for_call_stmt): Update prototype.\n\t* tree-inline.c (copy_bb): Set frequency correctly.\n\t(fold_marked_statements): Update call of cgraph_update_edges_for_call_stmt.\n\nFrom-SVN: r147337", "tree": {"sha": "91f699aef787d7d4ddaf57b0ac4ea331b8a1dd61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91f699aef787d7d4ddaf57b0ac4ea331b8a1dd61"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b685e144da6c5a196714ba7ef2fdae1fdf140e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b685e144da6c5a196714ba7ef2fdae1fdf140e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b685e144da6c5a196714ba7ef2fdae1fdf140e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b685e144da6c5a196714ba7ef2fdae1fdf140e2/comments", "author": null, "committer": null, "parents": [{"sha": "51e61d333a020e331fdd9a690815045a3600ab62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51e61d333a020e331fdd9a690815045a3600ab62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51e61d333a020e331fdd9a690815045a3600ab62"}], "stats": {"total": 98, "additions": 64, "deletions": 34}, "files": [{"sha": "932044d37ef8d099218723445d2831f285caaca6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b685e144da6c5a196714ba7ef2fdae1fdf140e2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b685e144da6c5a196714ba7ef2fdae1fdf140e2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b685e144da6c5a196714ba7ef2fdae1fdf140e2", "patch": "@@ -1,3 +1,13 @@\n+2009-05-10  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR middle-end/40084\n+\t* cgraph.c (cgraph_update_edges_for_call_stmt_node): Take old_call argument;\n+\trewrite.\n+\t(cgraph_update_edges_for_call_stmt): Take old_decl argument.\n+\t* cgraph.h (cgraph_update_edges_for_call_stmt): Update prototype.\n+\t* tree-inline.c (copy_bb): Set frequency correctly.\n+\t(fold_marked_statements): Update call of cgraph_update_edges_for_call_stmt.\n+\n 2009-05-10  Joseph Myers  <joseph@codesourcery.com>\n \n \t* config/arc/arc.c (arc_handle_interrupt_attribute): Use %qE for"}, {"sha": "5d2cc1d66342fba1eab0615433d8b5cc8f7e411e", "filename": "gcc/cgraph.c", "status": "modified", "additions": 47, "deletions": 30, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b685e144da6c5a196714ba7ef2fdae1fdf140e2/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b685e144da6c5a196714ba7ef2fdae1fdf140e2/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=4b685e144da6c5a196714ba7ef2fdae1fdf140e2", "patch": "@@ -898,64 +898,81 @@ cgraph_redirect_edge_callee (struct cgraph_edge *e, struct cgraph_node *n)\n \n \n /* Update or remove the corresponding cgraph edge if a GIMPLE_CALL\n-   OLD_STMT changed into NEW_STMT.  */\n+   OLD_STMT changed into NEW_STMT.  OLD_CALL is gimple_call_fndecl\n+   of OLD_STMT if it was previously call statement.  */\n \n static void\n cgraph_update_edges_for_call_stmt_node (struct cgraph_node *node,\n-\t\t\t\t\tgimple old_stmt, gimple new_stmt)\n+\t\t\t\t\tgimple old_stmt, tree old_call, gimple new_stmt)\n {\n-  tree new_call = (is_gimple_call (new_stmt)) ? gimple_call_fn (new_stmt) : 0;\n-  tree old_call = (is_gimple_call (old_stmt)) ? gimple_call_fn (old_stmt) : 0;\n+  tree new_call = (is_gimple_call (new_stmt)) ? gimple_call_fndecl (new_stmt) : 0;\n \n+  /* We are seeing indirect calls, then there is nothing to update.  */\n+  if (!new_call && !old_call)\n+    return;\n+  /* See if we turned indirect call into direct call or folded call to one builtin\n+     into different bultin.  */\n   if (old_call != new_call)\n     {\n       struct cgraph_edge *e = cgraph_edge (node, old_stmt);\n       struct cgraph_edge *ne = NULL;\n-      tree new_decl;\n+      gcov_type count;\n+      int frequency;\n+      int loop_nest;\n \n       if (e)\n \t{\n-\t  gcov_type count = e->count;\n-\t  int frequency = e->frequency;\n-\t  int loop_nest = e->loop_nest;\n-\n+\t  /* See if the call is already there.  It might be because of indirect\n+\t     inlining already found it.  */\n+\t  if (new_call && e->callee->decl == new_call)\n+\t    return;\n+\n+\t  /* Otherwise remove edge and create new one; we can't simply redirect\n+\t     since function has changed, so inline plan and other information\n+\t     attached to edge is invalid.  */\n \t  cgraph_remove_edge (e);\n-\t  if (new_call)\n-\t    {\n-\t      new_decl = gimple_call_fndecl (new_stmt);\n-\t      if (new_decl)\n-\t\t{\n-\t\t  ne = cgraph_create_edge (node, cgraph_node (new_decl),\n-\t\t\t\t\t   new_stmt, count, frequency,\n-\t\t\t\t\t   loop_nest);\n-\t\t  gcc_assert (ne->inline_failed);\n-\t\t}\n-\t    }\n+\t  count = e->count;\n+\t  frequency = e->frequency;\n+\t  loop_nest = e->loop_nest;\n+\t}\n+      else\n+\t{\n+\t  /* We are seeing new direct call; compute profile info based on BB.  */\n+\t  basic_block bb = gimple_bb (new_stmt);\n+\t  count = bb->count;\n+\t  frequency = compute_call_stmt_bb_frequency (current_function_decl,\n+\t\t\t\t\t\t      bb);\n+\t  loop_nest = bb->loop_depth;\n \t}\n-    }\n-  else if (old_stmt != new_stmt)\n-    {\n-      struct cgraph_edge *e = cgraph_edge (node, old_stmt);\n \n-      if (e)\n-\tcgraph_set_call_stmt (e, new_stmt);\n+      if (new_call)\n+\t{\n+\t  ne = cgraph_create_edge (node, cgraph_node (new_call),\n+\t\t\t\t   new_stmt, count, frequency,\n+\t\t\t\t   loop_nest);\n+\t  gcc_assert (ne->inline_failed);\n+\t}\n     }\n+  /* We only updated the call stmt; update pointer in cgraph edge..  */\n+  else if (old_stmt != new_stmt)\n+    cgraph_set_call_stmt (cgraph_edge (node, old_stmt), new_stmt);\n }\n \n /* Update or remove the corresponding cgraph edge if a GIMPLE_CALL\n-   OLD_STMT changed into NEW_STMT.  */\n+   OLD_STMT changed into NEW_STMT.  OLD_DECL is gimple_call_fndecl\n+   of OLD_STMT before it was updated (updating can happen inplace).  */\n \n void\n-cgraph_update_edges_for_call_stmt (gimple old_stmt, gimple new_stmt)\n+cgraph_update_edges_for_call_stmt (gimple old_stmt, tree old_decl, gimple new_stmt)\n {\n   struct cgraph_node *orig = cgraph_node (cfun->decl);\n   struct cgraph_node *node;\n \n-  cgraph_update_edges_for_call_stmt_node (orig, old_stmt, new_stmt);\n+  cgraph_update_edges_for_call_stmt_node (orig, old_stmt, old_decl, new_stmt);\n   if (orig->clones)\n     for (node = orig->clones; node != orig;)\n       {\n-        cgraph_update_edges_for_call_stmt_node (node, old_stmt, new_stmt);\n+        cgraph_update_edges_for_call_stmt_node (node, old_stmt, old_decl, new_stmt);\n \tif (node->clones)\n \t  node = node->clones;\n \telse if (node->next_sibling_clone)"}, {"sha": "c1a1a0ab9223fc8f13bba178e4e1d85254bc0a39", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b685e144da6c5a196714ba7ef2fdae1fdf140e2/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b685e144da6c5a196714ba7ef2fdae1fdf140e2/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=4b685e144da6c5a196714ba7ef2fdae1fdf140e2", "patch": "@@ -385,7 +385,7 @@ void cgraph_create_edge_including_clones (struct cgraph_node *,\n \t\t\t\t\t  struct cgraph_node *,\n \t\t\t\t\t  gimple, gcov_type, int, int,\n \t\t\t\t\t  cgraph_inline_failed_t);\n-void cgraph_update_edges_for_call_stmt (gimple, gimple);\n+void cgraph_update_edges_for_call_stmt (gimple, tree, gimple);\n struct cgraph_local_info *cgraph_local_info (tree);\n struct cgraph_global_info *cgraph_global_info (tree);\n struct cgraph_rtl_info *cgraph_rtl_info (tree);"}, {"sha": "403b5a0a17cda54884966ab41457e4dec807ba33", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b685e144da6c5a196714ba7ef2fdae1fdf140e2/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b685e144da6c5a196714ba7ef2fdae1fdf140e2/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=4b685e144da6c5a196714ba7ef2fdae1fdf140e2", "patch": "@@ -1522,7 +1522,8 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\tgcc_assert (dest->needed || !dest->analyzed);\n \t\tif (id->transform_call_graph_edges == CB_CGE_MOVE_CLONES)\n \t\t  cgraph_create_edge_including_clones (id->dst_node, dest, stmt,\n-\t\t\t\t\t\t       bb->count, CGRAPH_FREQ_BASE,\n+\t\t\t\t\t\t       bb->count,\n+\t\t\t\t\t\t       compute_call_stmt_bb_frequency (id->dst_node->decl, bb),\n \t\t\t\t\t\t       bb->loop_depth,\n \t\t\t\t\t\t       CIF_ORIGINALLY_INDIRECT_CALL);\n \t\telse\n@@ -3542,6 +3543,7 @@ fold_marked_statements (int first, struct pointer_set_t *statements)\n \t  if (pointer_set_contains (statements, gsi_stmt (gsi)))\n \t    {\n \t      gimple old_stmt = gsi_stmt (gsi);\n+\t      tree old_decl = is_gimple_call (old_stmt) ? gimple_call_fndecl (old_stmt) : 0;\n \n \t      if (fold_stmt (&gsi))\n \t\t{\n@@ -3550,8 +3552,9 @@ fold_marked_statements (int first, struct pointer_set_t *statements)\n \t\t  gimple new_stmt = gsi_stmt (gsi);\n \t\t  update_stmt (new_stmt);\n \n-\t\t  if (is_gimple_call (old_stmt))\n-\t\t    cgraph_update_edges_for_call_stmt (old_stmt, new_stmt);\n+\t\t  if (is_gimple_call (old_stmt)\n+\t\t      || is_gimple_call (new_stmt))\n+\t\t    cgraph_update_edges_for_call_stmt (old_stmt, old_decl, new_stmt);\n \n \t\t  if (maybe_clean_or_replace_eh_stmt (old_stmt, new_stmt))\n \t\t    gimple_purge_dead_eh_edges (BASIC_BLOCK (first));"}]}