{"sha": "64c8ebc7b2796fb2376de6e011443d2b688cfd98", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjRjOGViYzdiMjc5NmZiMjM3NmRlNmUwMTE0NDNkMmI2ODhjZmQ5OA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-12-03T10:06:15Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2019-12-03T10:06:15Z"}, "message": "decl.c (gnat_to_gnu_subprog_type): With the Copy-In/ Copy-Out mechanism...\n\n\t* gcc-interface/decl.c (gnat_to_gnu_subprog_type): With the Copy-In/\n\tCopy-Out mechanism, do not promote the mode of the return type to an\n\tintegral mode if it contains a field on a non-integral type and even\n\tdemote it for 64-bit targets.\n\nFrom-SVN: r278927", "tree": {"sha": "d8db053e5675f6921b2d8e70a6dc42d9bdffb7eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8db053e5675f6921b2d8e70a6dc42d9bdffb7eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64c8ebc7b2796fb2376de6e011443d2b688cfd98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64c8ebc7b2796fb2376de6e011443d2b688cfd98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64c8ebc7b2796fb2376de6e011443d2b688cfd98", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64c8ebc7b2796fb2376de6e011443d2b688cfd98/comments", "author": null, "committer": null, "parents": [{"sha": "819fb019338d2c46fb8b8def7855a36b9b361109", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/819fb019338d2c46fb8b8def7855a36b9b361109", "html_url": "https://github.com/Rust-GCC/gccrs/commit/819fb019338d2c46fb8b8def7855a36b9b361109"}], "stats": {"total": 66, "additions": 58, "deletions": 8}, "files": [{"sha": "487176d958af2f67ae68038ec873c5554f56c95a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64c8ebc7b2796fb2376de6e011443d2b688cfd98/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64c8ebc7b2796fb2376de6e011443d2b688cfd98/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=64c8ebc7b2796fb2376de6e011443d2b688cfd98", "patch": "@@ -1,3 +1,10 @@\n+2019-12-03  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_subprog_type): With the Copy-In/\n+\tCopy-Out mechanism, do not promote the mode of the return type to an\n+\tintegral mode if it contains a field on a non-integral type and even\n+\tdemote it for 64-bit targets.\n+\n 2019-11-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR ada/92362"}, {"sha": "b83f38c86a56bd92fd1a48a2a492b7972e6a1f56", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 51, "deletions": 8, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64c8ebc7b2796fb2376de6e011443d2b688cfd98/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64c8ebc7b2796fb2376de6e011443d2b688cfd98/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=64c8ebc7b2796fb2376de6e011443d2b688cfd98", "patch": "@@ -5620,6 +5620,32 @@ gnat_to_gnu_profile_type (Entity_Id gnat_type)\n   return gnu_type;\n }\n \n+/* Return true if TYPE contains only integral data, recursively if need be.  */\n+\n+static bool\n+type_contains_only_integral_data (tree type)\n+{\n+  switch (TREE_CODE (type))\n+    {\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case QUAL_UNION_TYPE:\n+      for (tree field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n+\tif (!type_contains_only_integral_data (TREE_TYPE (field)))\n+\t  return false;\n+      return true;\n+\n+    case ARRAY_TYPE:\n+    case COMPLEX_TYPE:\n+      return type_contains_only_integral_data (TREE_TYPE (type));\n+\n+    default:\n+      return INTEGRAL_TYPE_P (type);\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n /* Return a GCC tree for a subprogram type corresponding to GNAT_SUBPROG.\n    DEFINITION is true if this is for a subprogram being defined.  DEBUG_INFO_P\n    is true if we need to write debug information for other types that we may\n@@ -5649,8 +5675,8 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n      the TYPE_CI_CO_LIST field of the FUNCTION_TYPE node we create.  */\n   tree gnu_cico_list = NULL_TREE;\n   tree gnu_cico_return_type = NULL_TREE;\n-  /* Fields in return type of procedure with copy-in copy-out parameters.  */\n-  tree gnu_field_list = NULL_TREE;\n+  tree gnu_cico_field_list = NULL_TREE;\n+  bool gnu_cico_only_integral_type = true;\n   /* The semantics of \"pure\" in Ada essentially matches that of \"const\"\n      or \"pure\" in GCC.  In particular, both properties are orthogonal\n      to the \"nothrow\" property if the EH circuitry is explicit in the\n@@ -5976,9 +6002,11 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n \t\t\t\t         NULL_TREE, 0, 0);\n \t\t  Sloc_to_locus (Sloc (gnat_subprog),\n \t\t\t         &DECL_SOURCE_LOCATION (gnu_field));\n-\t\t  gnu_field_list = gnu_field;\n+\t\t  gnu_cico_field_list = gnu_field;\n \t\t  gnu_cico_list\n \t\t    = tree_cons (gnu_field, void_type_node, NULL_TREE);\n+\t\t  if (!type_contains_only_integral_data (gnu_return_type))\n+\t\t    gnu_cico_only_integral_type = false;\n \t\t}\n \n \t      TYPE_NAME (gnu_cico_return_type) = get_identifier (\"RETURN\");\n@@ -5995,9 +6023,11 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n \t\t\t\t 0, 0);\n \t  Sloc_to_locus (Sloc (gnat_param),\n \t\t\t &DECL_SOURCE_LOCATION (gnu_field));\n-\t  DECL_CHAIN (gnu_field) = gnu_field_list;\n-\t  gnu_field_list = gnu_field;\n+\t  DECL_CHAIN (gnu_field) = gnu_cico_field_list;\n+\t  gnu_cico_field_list = gnu_field;\n \t  gnu_cico_list = tree_cons (gnu_field, gnu_param, gnu_cico_list);\n+\t  if (!type_contains_only_integral_data (gnu_param_type))\n+\t    gnu_cico_only_integral_type = false;\n \t}\n     }\n \n@@ -6014,12 +6044,14 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n \t since structures are incomplete for the back-end.  */\n       else if (Convention (gnat_subprog) != Convention_Stubbed)\n \t{\n-\t  finish_record_type (gnu_cico_return_type, nreverse (gnu_field_list),\n+\t  finish_record_type (gnu_cico_return_type,\n+\t\t\t      nreverse (gnu_cico_field_list),\n \t\t\t      0, false);\n \n-\t  /* Try to promote the mode of the return type if it is passed\n-\t     in registers, again to speed up accesses.  */\n+\t  /* Try to promote the mode if the return type is fully returned\n+\t     in integer registers, again to speed up accesses.  */\n \t  if (TYPE_MODE (gnu_cico_return_type) == BLKmode\n+\t      && gnu_cico_only_integral_type\n \t      && !targetm.calls.return_in_memory (gnu_cico_return_type,\n \t\t\t\t\t\t  NULL_TREE))\n \t    {\n@@ -6042,6 +6074,17 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n \t\t}\n \t    }\n \n+\t  /* But demote the mode if the return type is partly returned in FP\n+\t     registers to avoid creating problematic paradoxical subregs.\n+\t     Note that we need to cater to historical 32-bit architectures\n+\t     that incorrectly use the mode to select the return mechanism.  */\n+\t  else if (INTEGRAL_MODE_P (TYPE_MODE (gnu_cico_return_type))\n+\t\t   && !gnu_cico_only_integral_type\n+\t\t   && BITS_PER_WORD >= 64\n+\t\t   && !targetm.calls.return_in_memory (gnu_cico_return_type,\n+\t\t\t\t\t\t       NULL_TREE))\n+\t    SET_TYPE_MODE (gnu_cico_return_type, BLKmode);\n+\n \t  if (debug_info_p)\n \t    rest_of_record_type_compilation (gnu_cico_return_type);\n \t}"}]}