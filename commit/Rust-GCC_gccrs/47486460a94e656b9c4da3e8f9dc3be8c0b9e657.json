{"sha": "47486460a94e656b9c4da3e8f9dc3be8c0b9e657", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc0ODY0NjBhOTRlNjU2YjljNGRhM2U4ZjlkYzNiZThjMGI5ZTY1Nw==", "commit": {"author": {"name": "Venkataramanan Kumar", "email": "venkataramanan.kumar@amd.com", "date": "2015-08-06T12:00:57Z"}, "committer": {"name": "Venkataramanan Kumar", "email": "vekumar@gcc.gnu.org", "date": "2015-08-06T12:00:57Z"}, "message": "Vectorize mult expressions with power 2 constants via shift, for targets has no vector multiplication support.\n\n \n2015-08-06  Venkataramanan Kumar  <Venkataramanan.kumar@amd.com>\n\n\t* tree-vect-patterns.c (vect_recog_mult_pattern): New function\n\tfor vectorizing multiplication patterns.\n\t* tree-vectorizer.h: Adjust the number of patterns.\n\n2015-08-06  Venkataramanan Kumar  <Venkataramanan.kumar@amd.com>\n\n\t* gcc.dg/vect/vect-mult-pattern-1.c: New test.\n\t* gcc.dg/vect/vect-mult-pattern-2.c: New test.\n\nFrom-SVN: r226675", "tree": {"sha": "3fa68dfa2871615959ae1f5a18890421157f045b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3fa68dfa2871615959ae1f5a18890421157f045b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47486460a94e656b9c4da3e8f9dc3be8c0b9e657", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47486460a94e656b9c4da3e8f9dc3be8c0b9e657", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47486460a94e656b9c4da3e8f9dc3be8c0b9e657", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47486460a94e656b9c4da3e8f9dc3be8c0b9e657/comments", "author": null, "committer": null, "parents": [{"sha": "b0b0e68ca0b48eebf773696d9c9a099222592c97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0b0e68ca0b48eebf773696d9c9a099222592c97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0b0e68ca0b48eebf773696d9c9a099222592c97"}], "stats": {"total": 201, "additions": 200, "deletions": 1}, "files": [{"sha": "43df172a4db0a9f3650383febaaca195fdbffa63", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47486460a94e656b9c4da3e8f9dc3be8c0b9e657/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47486460a94e656b9c4da3e8f9dc3be8c0b9e657/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=47486460a94e656b9c4da3e8f9dc3be8c0b9e657", "patch": "@@ -1,3 +1,9 @@\n+2015-08-06  Venkataramanan Kumar  <Venkataramanan.kumar@amd.com>\n+\n+\t* tree-vect-patterns.c (vect_recog_mult_pattern): New function\n+\tfor vectorizing multiplication patterns.\n+\t* tree-vectorizer.h: Adjust the number of patterns.\n+\n 2015-08-06  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/sse.md (*vec_concatv2df): Declare added"}, {"sha": "76afd8e89fe0c70ed6bf28288a1ff00a3a6a86d1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47486460a94e656b9c4da3e8f9dc3be8c0b9e657/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47486460a94e656b9c4da3e8f9dc3be8c0b9e657/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=47486460a94e656b9c4da3e8f9dc3be8c0b9e657", "patch": "@@ -1,3 +1,8 @@\n+2015-08-06  Venkataramanan Kumar  <Venkataramanan.kumar@amd.com>\n+\n+\t* gcc.dg/vect/vect-mult-pattern-1.c: New test.\n+\t* gcc.dg/vect/vect-mult-pattern-2.c: New test.\n+\n 2015-08-06  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n \n \t* gcc.target/s390/dwarfregtable-1.c: New test."}, {"sha": "764d0e34c320496aa700f9cf1e64e9525383f00c", "filename": "gcc/testsuite/gcc.dg/vect/vect-mult-pattern-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47486460a94e656b9c4da3e8f9dc3be8c0b9e657/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-mult-pattern-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47486460a94e656b9c4da3e8f9dc3be8c0b9e657/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-mult-pattern-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-mult-pattern-1.c?ref=47486460a94e656b9c4da3e8f9dc3be8c0b9e657", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_shift } */\n+\n+unsigned  long int __attribute__ ((aligned (64)))arr[100];\n+int i;\n+\n+void test_for_vectorshifts_via_mul_with_power2_const ()\n+{\n+  for (i=0; i<=99; i++)\n+    arr[i] = arr[i] * 4;\n+}\n+\n+void test_for_vectorshifts_via_mul_with_negative_power2_const ()\n+{\n+  for (i=0; i<=99; i++)\n+    arr[i] = arr[i] * (-4);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\"  {target  { ! { vect_int_mult } } } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_mult_pattern: detected\" 2 \"vect\" {target  { ! { vect_int_mult } } } } } */"}, {"sha": "77e8cff792dc2c9a41902bd1e73e9acdd6721a67", "filename": "gcc/testsuite/gcc.dg/vect/vect-mult-pattern-2.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47486460a94e656b9c4da3e8f9dc3be8c0b9e657/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-mult-pattern-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47486460a94e656b9c4da3e8f9dc3be8c0b9e657/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-mult-pattern-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-mult-pattern-2.c?ref=47486460a94e656b9c4da3e8f9dc3be8c0b9e657", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_shift } */\n+\n+unsigned  long int __attribute__ ((aligned (64)))arr[100];\n+int i;\n+\n+void negative_test_for_vectorshifts_via_mul_with_const ()\n+{\n+  for (i=0; i<=99; i++)\n+    arr[i] = arr[i] * 123;\n+}\n+\n+void negative_test_for_vectorshifts_via_mul_with_negative_const ()\n+{\n+  for (i=0; i<=99; i++)\n+    arr[i] = arr[i] * (-123);\n+}\n+\n+void negative_test_for_vectorshifts_via_mul_with_varable (int x)\n+{\n+  for (i=0; i<=99; i++)\n+    arr[i] = arr[i] * x;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 3 \"vect\"  {target  { ! { vect_int_mult } } } } } */\n+/* { dg-final { scan-tree-dump-not \"vect_recog_mult_pattern: detected\" \"vect\" {target  { ! { vect_int_mult } } } } } */"}, {"sha": "bc3117d0ad2674a9542132dcf809f9c9e8681dcb", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47486460a94e656b9c4da3e8f9dc3be8c0b9e657/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47486460a94e656b9c4da3e8f9dc3be8c0b9e657/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=47486460a94e656b9c4da3e8f9dc3be8c0b9e657", "patch": "@@ -76,6 +76,10 @@ static gimple vect_recog_vector_vector_shift_pattern (vec<gimple> *,\n \t\t\t\t\t\t      tree *, tree *);\n static gimple vect_recog_divmod_pattern (vec<gimple> *,\n \t\t\t\t\t tree *, tree *);\n+\n+static gimple vect_recog_mult_pattern (vec<gimple> *,\n+\t\t\t\t       tree *, tree *);\n+\n static gimple vect_recog_mixed_size_cond_pattern (vec<gimple> *,\n \t\t\t\t\t\t  tree *, tree *);\n static gimple vect_recog_bool_pattern (vec<gimple> *, tree *, tree *);\n@@ -90,6 +94,7 @@ static vect_recog_func_ptr vect_vect_recog_func_ptrs[NUM_PATTERNS] = {\n \tvect_recog_rotate_pattern,\n \tvect_recog_vector_vector_shift_pattern,\n \tvect_recog_divmod_pattern,\n+\tvect_recog_mult_pattern,\n \tvect_recog_mixed_size_cond_pattern,\n \tvect_recog_bool_pattern};\n \n@@ -2147,6 +2152,140 @@ vect_recog_vector_vector_shift_pattern (vec<gimple> *stmts,\n   return pattern_stmt;\n }\n \n+/* Detect multiplication by constant which are postive or negatives of power 2,\n+   and convert them to shift patterns.\n+\n+   Mult with constants that are postive power of two.\n+   type a_t;\n+   type b_t\n+   S1: b_t = a_t * n\n+\n+   or\n+\n+   Mult with constants that are negative power of two.\n+   S2: b_t = a_t * -n\n+\n+   Input/Output:\n+\n+   STMTS: Contains a stmt from which the pattern search begins,\n+   i.e. the mult stmt.  Convert the mult operation to LSHIFT if\n+   constant operand is a power of 2.\n+   type a_t, b_t\n+   S1': b_t = a_t << log2 (n)\n+\n+   Convert the mult operation to LSHIFT and followed by a NEGATE\n+   if constant operand is a negative power of 2.\n+   type a_t, b_t, res_T;\n+   S2': b_t = a_t << log2 (n)\n+   S3': res_T  = - (b_t)\n+\n+ Output:\n+\n+  * TYPE_IN: The type of the input arguments to the pattern.\n+\n+  * TYPE_OUT: The type of the output of this pattern.\n+\n+  * Return value: A new stmt that will be used to replace the multiplication\n+    S1 or S2 stmt.  */\n+\n+static gimple\n+vect_recog_mult_pattern (vec<gimple> *stmts,\n+\t\t\t tree *type_in, tree *type_out)\n+{\n+  gimple last_stmt = stmts->pop ();\n+  tree oprnd0, oprnd1, vectype, itype;\n+  gimple pattern_stmt, def_stmt;\n+  optab optab;\n+  stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n+  int power2_val, power2_neg_val;\n+  tree shift;\n+\n+  if (!is_gimple_assign (last_stmt))\n+    return NULL;\n+\n+  if (gimple_assign_rhs_code (last_stmt) != MULT_EXPR)\n+    return NULL;\n+\n+  oprnd0 = gimple_assign_rhs1 (last_stmt);\n+  oprnd1 = gimple_assign_rhs2 (last_stmt);\n+  itype = TREE_TYPE (oprnd0);\n+\n+  if (TREE_CODE (oprnd0) != SSA_NAME\n+      || TREE_CODE (oprnd1) != INTEGER_CST\n+      || !INTEGRAL_TYPE_P (itype)\n+      || TYPE_PRECISION (itype) != GET_MODE_PRECISION (TYPE_MODE (itype)))\n+    return NULL;\n+\n+  vectype = get_vectype_for_scalar_type (itype);\n+  if (vectype == NULL_TREE)\n+    return NULL;\n+\n+  /* If the target can handle vectorized multiplication natively,\n+     don't attempt to optimize this.  */\n+  optab = optab_for_tree_code (MULT_EXPR, vectype, optab_default);\n+  if (optab != unknown_optab)\n+    {\n+      machine_mode vec_mode = TYPE_MODE (vectype);\n+      int icode = (int) optab_handler (optab, vec_mode);\n+      if (icode != CODE_FOR_nothing)\n+\treturn NULL;\n+    }\n+\n+  /* If target cannot handle vector left shift then we cannot\n+     optimize and bail out.  */\n+  optab = optab_for_tree_code (LSHIFT_EXPR, vectype, optab_vector);\n+  if (!optab\n+      || optab_handler (optab, TYPE_MODE (vectype)) == CODE_FOR_nothing)\n+    return NULL;\n+\n+  power2_val = wi::exact_log2 (oprnd1);\n+  power2_neg_val = wi::exact_log2 (wi::neg (oprnd1));\n+\n+  /* Handle constant operands that are postive or negative powers of 2.  */\n+  if (power2_val != -1)\n+    {\n+      shift = build_int_cst (itype, power2_val);\n+      pattern_stmt\n+\t= gimple_build_assign (vect_recog_temp_ssa_var (itype, NULL),\n+\t\t\t       LSHIFT_EXPR, oprnd0, shift);\n+    }\n+  else if (power2_neg_val != -1)\n+    {\n+      /* If the target cannot handle vector NEGATE then we cannot\n+\t do the optimization.  */\n+      optab = optab_for_tree_code (NEGATE_EXPR, vectype, optab_vector);\n+      if (!optab\n+\t  || optab_handler (optab, TYPE_MODE (vectype)) == CODE_FOR_nothing)\n+\treturn NULL;\n+\n+      shift = build_int_cst (itype, power2_neg_val);\n+      def_stmt\n+\t= gimple_build_assign (vect_recog_temp_ssa_var (itype, NULL),\n+\t\t\t       LSHIFT_EXPR, oprnd0, shift);\n+      new_pattern_def_seq (stmt_vinfo, def_stmt);\n+      pattern_stmt\n+\t = gimple_build_assign (vect_recog_temp_ssa_var (itype, NULL),\n+\t\t\t\tNEGATE_EXPR, gimple_assign_lhs (def_stmt));\n+    }\n+  else\n+    return NULL;\n+\n+  /* Pattern detected.  */\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"vect_recog_mult_pattern: detected:\\n\");\n+\n+  if (dump_enabled_p ())\n+    dump_gimple_stmt_loc (MSG_NOTE, vect_location, TDF_SLIM,\n+\t\t\t  pattern_stmt,0);\n+\n+  stmts->safe_push (last_stmt);\n+  *type_in = vectype;\n+  *type_out = vectype;\n+\n+  return pattern_stmt;\n+}\n+\n /* Detect a signed division by a constant that wouldn't be\n    otherwise vectorized:\n "}, {"sha": "4b9837861a6b90451131b09cfeccdb72509eee8b", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47486460a94e656b9c4da3e8f9dc3be8c0b9e657/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47486460a94e656b9c4da3e8f9dc3be8c0b9e657/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=47486460a94e656b9c4da3e8f9dc3be8c0b9e657", "patch": "@@ -1135,7 +1135,7 @@ extern void vect_slp_transform_bb (basic_block);\n    Additional pattern recognition functions can (and will) be added\n    in the future.  */\n typedef gimple (* vect_recog_func_ptr) (vec<gimple> *, tree *, tree *);\n-#define NUM_PATTERNS 12\n+#define NUM_PATTERNS 13\n void vect_pattern_recog (loop_vec_info, bb_vec_info);\n \n /* In tree-vectorizer.c.  */"}]}