{"sha": "d574e624a9d156600731554133db68dc6868e7b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDU3NGU2MjRhOWQxNTY2MDA3MzE1NTQxMzNkYjY4ZGM2ODY4ZTdiNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-11-09T15:15:47Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-11-09T15:15:47Z"}, "message": "Add available_vector_sizes to target-supports.exp\n\nThis patch adds a routine that lists the available vector sizes\nfor a target and uses it for some existing target conditions.\nLater patches add more uses.\n\nThe cases are taken from multiple_sizes.\n\n2017-11-09  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/testsuite/\n\t* lib/target-supports.exp (available_vector_sizes): New proc.\n\t(check_effective_target_vect_multiple_sizes): Use it.\n\t(check_effective_target_vect64): Likewise.\n\t(check_effective_target_vect_sizes_32B_16B): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r254590", "tree": {"sha": "adb5c386eba4fd4c0910cb2d7ba061783d9a9267", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/adb5c386eba4fd4c0910cb2d7ba061783d9a9267"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d574e624a9d156600731554133db68dc6868e7b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d574e624a9d156600731554133db68dc6868e7b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d574e624a9d156600731554133db68dc6868e7b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d574e624a9d156600731554133db68dc6868e7b5/comments", "author": null, "committer": null, "parents": [{"sha": "a826c5019e1439181a822c2b5079fec22654e37b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a826c5019e1439181a822c2b5079fec22654e37b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a826c5019e1439181a822c2b5079fec22654e37b"}], "stats": {"total": 71, "additions": 34, "deletions": 37}, "files": [{"sha": "8881232bc4d525d88b9dc788df267d29d44df7fc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d574e624a9d156600731554133db68dc6868e7b5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d574e624a9d156600731554133db68dc6868e7b5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d574e624a9d156600731554133db68dc6868e7b5", "patch": "@@ -1,3 +1,12 @@\n+2017-11-09  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* lib/target-supports.exp (available_vector_sizes): New proc.\n+\t(check_effective_target_vect_multiple_sizes): Use it.\n+\t(check_effective_target_vect64): Likewise.\n+\t(check_effective_target_vect_sizes_32B_16B): Likewise.\n+\n 2017-11-09  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "8e7b64122487292d42c88a730c20f9afa5b32804", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 25, "deletions": 37, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d574e624a9d156600731554133db68dc6868e7b5/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d574e624a9d156600731554133db68dc6868e7b5/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=d574e624a9d156600731554133db68dc6868e7b5", "patch": "@@ -6581,46 +6581,38 @@ foreach N {2 3 4 8} {\n     }]\n }\n \n-# Return 1 if the target supports multiple vector sizes\n-\n-proc check_effective_target_vect_multiple_sizes { } {\n-    global et_vect_multiple_sizes_saved\n-    global et_index\n+# Return the list of vector sizes (in bits) that each target supports.\n+# A vector length of \"0\" indicates variable-length vectors.\n \n-    set et_vect_multiple_sizes_saved($et_index) 0\n-    if { [istarget aarch64*-*-*]\n-\t || [is-effective-target arm_neon]\n-\t || (([istarget i?86-*-*] || [istarget x86_64-*-*])\n-\t     && ([check_avx_available] && ![check_prefer_avx128])) } {\n-\tset et_vect_multiple_sizes_saved($et_index) 1\n+proc available_vector_sizes { } {\n+    set result {}\n+    if { [istarget aarch64*-*-*] } {\n+\tlappend result 128 64\n+    } elseif { [istarget arm*-*-*]\n+\t\t&& [check_effective_target_arm_neon_ok] } {\n+\tlappend result 128 64\n+    } elseif { (([istarget i?86-*-*] || [istarget x86_64-*-*])\n+\t\t && ([check_avx_available] && ![check_prefer_avx128])) } {\n+\tlappend result 256 128\n+    } elseif { [istarget sparc*-*-*] } {\n+\tlappend result 64\n+    } else {\n+\t# The traditional default asumption.\n+\tlappend result 128\n     }\n+    return $result\n+}\n+\n+# Return 1 if the target supports multiple vector sizes\n \n-    verbose \"check_effective_target_vect_multiple_sizes:\\\n-\t     returning $et_vect_multiple_sizes_saved($et_index)\" 2\n-    return $et_vect_multiple_sizes_saved($et_index)\n+proc check_effective_target_vect_multiple_sizes { } {\n+    return [expr { [llength [available_vector_sizes]] > 1 }]\n }\n \n # Return 1 if the target supports vectors of 64 bits.\n \n proc check_effective_target_vect64 { } {\n-    global et_vect64_saved\n-    global et_index\n-\n-    if [info exists et_vect64_saved($et_index)] {\n-        verbose \"check_effective_target_vect64: using cached result\" 2\n-    } else {\n-\tset et_vect64_saved($et_index) 0\n-        if { ([is-effective-target arm_neon]\n-\t      && [check_effective_target_arm_little_endian])\n-\t     || [istarget aarch64*-*-*]\n-             || [istarget sparc*-*-*] } {\n-\t   set et_vect64_saved($et_index) 1\n-        }\n-    }\n-\n-    verbose \"check_effective_target_vect64:\\\n-\t     returning $et_vect64_saved($et_index)\" 2\n-    return $et_vect64_saved($et_index)\n+    return [expr { [lsearch -exact [available_vector_sizes] 64] >= 0 }]\n }\n \n # Return 1 if the target supports vector copysignf calls.\n@@ -7747,11 +7739,7 @@ proc check_avx_available { } {\n # Return true if 32- and 16-bytes vectors are available.\n \n proc check_effective_target_vect_sizes_32B_16B { } {\n-  if { [check_avx_available] && ![check_prefer_avx128] } {\n-     return 1;\n-  } else {\n-    return 0;\n-  }\n+    return [expr { [available_vector_sizes] == [list 256 128] }]\n }\n \n # Return true if 16- and 8-bytes vectors are available."}]}