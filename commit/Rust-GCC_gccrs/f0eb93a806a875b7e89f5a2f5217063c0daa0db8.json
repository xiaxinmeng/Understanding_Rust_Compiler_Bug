{"sha": "f0eb93a806a875b7e89f5a2f5217063c0daa0db8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjBlYjkzYTgwNmE4NzViN2U4OWY1YTJmNTIxNzA2M2MwZGFhMGRiOA==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2004-11-05T00:53:49Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2004-11-05T00:53:49Z"}, "message": "c-tree.texi, [...]: Remove trailing whitespace.\n\n\t* doc/c-tree.texi, doc/cfg.texi, doc/extend.texi, doc/gty.texi,\n\tdoc/install.texi, doc/invoke.texi, doc/md.texi, doc/passes.texi,\n\tdoc/rtl.texi, doc/tm.texi, doc/tree-ssa.texi: Remove trailing\n\twhitespace.\n\nFrom-SVN: r90100", "tree": {"sha": "510d68a2ce26cf216088cf583abb195855e06d3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/510d68a2ce26cf216088cf583abb195855e06d3b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0eb93a806a875b7e89f5a2f5217063c0daa0db8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0eb93a806a875b7e89f5a2f5217063c0daa0db8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0eb93a806a875b7e89f5a2f5217063c0daa0db8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0eb93a806a875b7e89f5a2f5217063c0daa0db8/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04fb56d5990d68f903b15b367e23be9a27d27673", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04fb56d5990d68f903b15b367e23be9a27d27673", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04fb56d5990d68f903b15b367e23be9a27d27673"}], "stats": {"total": 223, "additions": 115, "deletions": 108}, "files": [{"sha": "45169122ee47ac160f7ad23070803972b4ef47bc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0eb93a806a875b7e89f5a2f5217063c0daa0db8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0eb93a806a875b7e89f5a2f5217063c0daa0db8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f0eb93a806a875b7e89f5a2f5217063c0daa0db8", "patch": "@@ -1,3 +1,10 @@\n+2004-11-05  Joseph S. Myers  <joseph@codesourcery.com>\n+\n+\t* doc/c-tree.texi, doc/cfg.texi, doc/extend.texi, doc/gty.texi,\n+\tdoc/install.texi, doc/invoke.texi, doc/md.texi, doc/passes.texi,\n+\tdoc/rtl.texi, doc/tm.texi, doc/tree-ssa.texi: Remove trailing\n+\twhitespace.\n+\n 2004-11-04  Mark Mitchell  <mark@codesourcery.com>\n \n \t* config/arm/arm.c (arm_handle_notshared_attribute): New function."}, {"sha": "9cd582e05b82bcf79422d8f8f6f9698cccfd1478", "filename": "gcc/doc/c-tree.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0eb93a806a875b7e89f5a2f5217063c0daa0db8/gcc%2Fdoc%2Fc-tree.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0eb93a806a875b7e89f5a2f5217063c0daa0db8/gcc%2Fdoc%2Fc-tree.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fc-tree.texi?ref=f0eb93a806a875b7e89f5a2f5217063c0daa0db8", "patch": "@@ -2170,7 +2170,7 @@ variable is initialized, rather than assigned to subsequently.\n These nodes represent non-static data member accesses.  The first\n operand is the object (rather than a pointer to it); the second operand\n is the @code{FIELD_DECL} for the data member.  The third operand represents\n-the byte offset of the field, but should not be used directly; call \n+the byte offset of the field, but should not be used directly; call\n @code{component_ref_field_offset} instead.\n \n @item COMPOUND_EXPR"}, {"sha": "d83e992e32023e1213d1a807e7724c42265d20d2", "filename": "gcc/doc/cfg.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0eb93a806a875b7e89f5a2f5217063c0daa0db8/gcc%2Fdoc%2Fcfg.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0eb93a806a875b7e89f5a2f5217063c0daa0db8/gcc%2Fdoc%2Fcfg.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcfg.texi?ref=f0eb93a806a875b7e89f5a2f5217063c0daa0db8", "patch": "@@ -229,7 +229,7 @@ and many computed jumps may have @emph{very} dense flow graphs, so\n these edges need to be handled with special care.  During the earlier\n stages of the compilation process, GCC tries to avoid such dense flow\n graphs by factoring computed jumps.  For example, given the following\n-series of jumps, \n+series of jumps,\n \n @smallexample\n   goto *x;\n@@ -580,7 +580,7 @@ be freely reused for other values when a register is dead.\n @findex REG_DEAD, REG_UNUSED\n The liveness information is stored partly in the RTL instruction\n stream and partly in the flow graph.  Local information is stored in\n-the instruction stream: \n+the instruction stream:\n Each instruction may contain @code{REG_DEAD} notes representing that\n the value of a given register is no longer needed, or\n @code{REG_UNUSED} notes representing that the value computed by the"}, {"sha": "8f383b220e45b091ee6dc8388d35527f8c33633d", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0eb93a806a875b7e89f5a2f5217063c0daa0db8/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0eb93a806a875b7e89f5a2f5217063c0daa0db8/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=f0eb93a806a875b7e89f5a2f5217063c0daa0db8", "patch": "@@ -3310,14 +3310,14 @@ above in recent GCC versions.\n @subsection ARM Type Attributes\n \n On those ARM targets that support @code{dllimport} (such as Symbian\n-OS), you can use the @code{notshared} attribute to indicate that the \n+OS), you can use the @code{notshared} attribute to indicate that the\n virtual table and other similar data for a class should not be\n exported from a DLL.  For example:\n \n @smallexample\n class __declspec(notshared) C @{\n public:\n-  __declspec(dllimport) C(); \n+  __declspec(dllimport) C();\n   virtual void f();\n @}\n \n@@ -3689,7 +3689,7 @@ int foo ()\n   int result;\n   asm (\"magic stuff accessing an 'int' pointed to by '%1'\"\n         \"=&d\" (r) : \"a\" (y), \"m\" (*y));\n-  return result;     \n+  return result;\n @}\n @end smallexample\n \n@@ -3790,10 +3790,10 @@ The @code{volatile} keyword indicates that the instruction has\n important side-effects.  GCC will not delete a volatile @code{asm} if\n it is reachable.  (The instruction can still be deleted if GCC can\n prove that control-flow will never reach the location of the\n-instruction.)  Note that even a volatile @code{asm} instruction \n+instruction.)  Note that even a volatile @code{asm} instruction\n can be moved relative to other code, including across jump\n-instructions.  For example, on many targets there is a system \n-register which can be set to control the rounding mode of \n+instructions.  For example, on many targets there is a system\n+register which can be set to control the rounding mode of\n floating point operations.  You might try\n setting it with a volatile @code{asm}, like this PowerPC example:\n "}, {"sha": "cf4bde76d7328959d921901d78b2486311a0de94", "filename": "gcc/doc/gty.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0eb93a806a875b7e89f5a2f5217063c0daa0db8/gcc%2Fdoc%2Fgty.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0eb93a806a875b7e89f5a2f5217063c0daa0db8/gcc%2Fdoc%2Fgty.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgty.texi?ref=f0eb93a806a875b7e89f5a2f5217063c0daa0db8", "patch": "@@ -61,7 +61,7 @@ static GTY(()) int @var{counter};        /* @r{save counter in a PCH} */\n @end smallexample\n \n The parser understands simple typedefs such as\n-@code{typedef struct @var{tag} *@var{name};} and \n+@code{typedef struct @var{tag} *@var{name};} and\n @code{typedef int @var{name};}.\n These don't need to be marked.\n "}, {"sha": "ff013a7fe8b314c332663ef920ab95be79f7a650", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0eb93a806a875b7e89f5a2f5217063c0daa0db8/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0eb93a806a875b7e89f5a2f5217063c0daa0db8/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=f0eb93a806a875b7e89f5a2f5217063c0daa0db8", "patch": "@@ -1235,7 +1235,7 @@ The following options apply to the build of the Fortran front end.\n @itemx --with-mpfr=@var{pathname}\n @itemx --with-gmp-dir=@var{pathname}\n @itemx --with-mpfr-dir=@var{pathname}\n-If you don't have GMP (the GNU Multiple Precision library) and the MPFR \n+If you don't have GMP (the GNU Multiple Precision library) and the MPFR\n Libraries installed in a standard location and you want to build the Fortran\n front-end, you can explicitly specify the directory where they are installed\n (@samp{--with-gmp=gmpinstalldir}, @samp{--with-mpfr=mpfrinstalldir}) or where\n@@ -2751,7 +2751,7 @@ needed whenever @env{CC} is used.\n \n Specifically, options that determine the runtime architecture must be\n in @env{CC} to correctly select the target for the build.  It is also\n-convenient to place many other compiler options in @env{CC}.  For example, \n+convenient to place many other compiler options in @env{CC}.  For example,\n @env{CC=\"cc -Ac +DA2.0W -Wp,-H16376 -D_CLASSIC_TYPES -D_HPUX_SOURCE\"}\n can be used to bootstrap the GCC 3.3 branch with the HP compiler in\n 64-bit K&R/bundled mode.  The @option{+DA2.0W} option will result in"}, {"sha": "b5074f9c78e0f8f45f48b69873cdda7475a323f9", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0eb93a806a875b7e89f5a2f5217063c0daa0db8/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0eb93a806a875b7e89f5a2f5217063c0daa0db8/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=f0eb93a806a875b7e89f5a2f5217063c0daa0db8", "patch": "@@ -1834,7 +1834,7 @@ Objective-C and Objective-C++ programs; you can use the other options with\n any language supported by GCC@.\n \n Note that since Objective-C is an extension of the C language, Objective-C\n-compilations may also use options specific to the C front-end (e.g., \n+compilations may also use options specific to the C front-end (e.g.,\n @option{-Wtraditional}).  Similarly, Objective-C++ compilations may use\n C++-specific options (e.g., @option{-Wabi}).\n \n@@ -3516,7 +3516,7 @@ loop optimization pass, to @file{@var{file}.06.loop}.  @option{-dL} and\n @itemx -fdump-rtl-sms\n @opindex dm\n @opindex fdump-rtl-sms\n-Dump after modulo scheduling, to @file{@var{file}.20.sms}. \n+Dump after modulo scheduling, to @file{@var{file}.20.sms}.\n \n @item -dM\n @itemx -fdump-rtl-mach\n@@ -3842,7 +3842,7 @@ file name.\n \n @item vect\n @opindex fdump-tree-vect\n-Dump each function after applying vectorization of loops.  The file name is \n+Dump each function after applying vectorization of loops.  The file name is\n made by appending @file{.vect} to the source file name.\n \n @item all\n@@ -4650,7 +4650,7 @@ Perform loop optimizations on trees.  This flag is enabled by default\n at @option{-O} and higher.\n \n @item -ftree-loop-linear\n-Perform linear loop transformations on tree. This flag can improve cache \n+Perform linear loop transformations on tree. This flag can improve cache\n performance and allow further loop optimizations to take place.\n \n @item -ftree-lim\n@@ -4733,7 +4733,7 @@ This optimization is enabled by default.\n \n @item -fvariable-expansion-in-unroller\n @opindex -fvariable-expansion-in-unroller\n-With this option, the compiler will create multiple copies of some \n+With this option, the compiler will create multiple copies of some\n local variables when unrolling a loop which can result in superior code.\n \n @item -fprefetch-loop-arrays\n@@ -7252,14 +7252,14 @@ Emit debugging information for all symbols and types.\n @item -mone-byte-bool\n @opindex -mone-byte-bool\n Override the defaults for @samp{bool} so that @samp{sizeof(bool)==1}.\n-By default @samp{sizeof(bool)} is @samp{4} when compiling for \n+By default @samp{sizeof(bool)} is @samp{4} when compiling for\n Darwin/PowerPC and @samp{1} when compiling for Darwin/x86, so this\n option has no effect on x86.\n \n @strong{Warning:} The @option{-mone-byte-bool} switch causes GCC\n to generate code that is not binary compatible with code generated\n without that switch.  Using this switch may require recompiling all\n-other modules in a program, including system libraries.  Use this \n+other modules in a program, including system libraries.  Use this\n switch to conform to a non-default data model.\n \n @item -mfix-and-continue\n@@ -10837,18 +10837,18 @@ In order to provide a backchain the address of the caller's frame\n is stored within the callee's stack frame.\n A backchain may be needed to allow debugging using tools that do not understand\n DWARF-2 call frame information.\n-For @option{-mno-backchain} no backchain is maintained at all which is the \n-default. \n-If one of the other options is present the backchain pointer is placed either \n+For @option{-mno-backchain} no backchain is maintained at all which is the\n+default.\n+If one of the other options is present the backchain pointer is placed either\n on top of the stack frame  (@option{-mkernel-backchain}) or on\n the bottom (@option{-mbackchain}).\n Beside the different backchain location @option{-mkernel-backchain}\n also changes stack frame layout breaking the ABI. This option\n is intended to be used for code which internally needs a backchain but has\n-to get by with a limited stack size e.g.@: the linux kernel. \n+to get by with a limited stack size e.g.@: the linux kernel.\n Internal unwinding code not using DWARF-2 info has to be able to locate the\n return address of a function. That will be eased be the fact that\n-the return address of a function is placed two words below the backchain \n+the return address of a function is placed two words below the backchain\n pointer.\n \n @item -msmall-exec\n@@ -10936,8 +10936,8 @@ hardware floating point is used.\n @opindex mwarn-framesize\n Emit a warning if the current function exceeds the given frame size.  Because\n this is a compile time check it doesn't need to be a real problem when the program\n-runs.  It is intended to identify functions which most probably cause \n-a stack overflow.  It is useful to be used in an environment with limited stack \n+runs.  It is intended to identify functions which most probably cause\n+a stack overflow.  It is useful to be used in an environment with limited stack\n size e.g.@: the linux kernel.\n \n @item -mwarn-dynamicstack\n@@ -10951,11 +10951,11 @@ sized arrays.  This is generally a bad idea with a limited stack size.\n @opindex mstack-size\n These arguments always have to be used in conjunction.  If they are present the s390\n back end emits additional instructions in the function prologue which trigger a trap\n-if the stack size is @var{stack-guard} bytes above the @var{stack-size} \n-(remember that the stack on s390 grows downward).  These options are intended to \n-be used to help debugging stack overflow problems.  The additionally emitted code \n-cause only little overhead and hence can also be used in production like systems \n-without greater performance degradation.  The given values have to be exact \n+if the stack size is @var{stack-guard} bytes above the @var{stack-size}\n+(remember that the stack on s390 grows downward).  These options are intended to\n+be used to help debugging stack overflow problems.  The additionally emitted code\n+cause only little overhead and hence can also be used in production like systems\n+without greater performance degradation.  The given values have to be exact\n powers of 2 and @var{stack-size} has to be greater than @var{stack-guard}.\n In order to be efficient the extra code makes the assumption that the stack starts\n at an address aligned to the value given by @var{stack-size}.\n@@ -12181,7 +12181,7 @@ load times of shared object libraries, produce more optimized\n code, provide near-perfect API export and prevent symbol clashes.\n It is @strong{strongly} recommended that you use this in any shared objects\n you distribute.\n-     \n+\n Despite the nomenclature, @code{default} always means public ie;\n available to be linked against from outside the shared object.\n @code{protected} and @code{internal} are pretty useless in real-world\n@@ -12190,7 +12190,7 @@ The default if @option{-fvisibility} isn't specified is\n @code{default}, i.e., make every\n symbol public---this causes the same behavior as previous versions of\n GCC.\n-     \n+\n A good explanation of the benefits offered by ensuring ELF\n symbols have the correct visibility is given by ``How To Write\n Shared Libraries'' by Ulrich Drepper (which can be found at"}, {"sha": "e01bd317ef772bc8f9e779703b961be6db0a85c7", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0eb93a806a875b7e89f5a2f5217063c0daa0db8/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0eb93a806a875b7e89f5a2f5217063c0daa0db8/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=f0eb93a806a875b7e89f5a2f5217063c0daa0db8", "patch": "@@ -919,7 +919,7 @@ logical operators, which have the semantics of the C operators\n @end table\n \n @item\n-An optional block of C code, which should execute \n+An optional block of C code, which should execute\n @samp{@w{return true}} if the predicate is found to match and\n @samp{@w{return false}} if it does not.  It must not have any side\n effects.  The predicate arguments, @var{op} and @var{mode}, are"}, {"sha": "f3714cb230cfe62ffedf1d8b3acbe84055b1a296", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0eb93a806a875b7e89f5a2f5217063c0daa0db8/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0eb93a806a875b7e89f5a2f5217063c0daa0db8/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=f0eb93a806a875b7e89f5a2f5217063c0daa0db8", "patch": "@@ -12,7 +12,7 @@\n @cindex compiler passes and files\n \n This chapter is dedicated to giving an overview of the optimization and\n-code generation passes of the compiler.  In the process, it describes \n+code generation passes of the compiler.  In the process, it describes\n some of the language front end interface, though this description is no\n where near complete.\n \n@@ -30,7 +30,7 @@ where near complete.\n @findex lang_hooks.parse_file\n The language front end is invoked only once, via\n @code{lang_hooks.parse_file}, to parse the entire input.  The language\n-front end may use any intermediate language representation deemed \n+front end may use any intermediate language representation deemed\n appropriate.  The C front end uses GENERIC trees (CROSSREF), plus\n a double handful of language specific tree codes defined in\n @file{c-common.def}.  The Fortran front end uses a completely different\n@@ -43,10 +43,10 @@ private representation.\n @cindex intermediate representation lowering\n @cindex lowering, language-dependent intermediate representation\n At some point the front end must translate the representation used in the\n-front end to a representation understood by the language-independent \n+front end to a representation understood by the language-independent\n portions of the compiler.  Current practice takes one of two forms.\n The C front end manually invokes the gimplifier (CROSSREF) on each function,\n-and uses the gimplifier callbacks to convert the language-specific tree \n+and uses the gimplifier callbacks to convert the language-specific tree\n nodes directly to GIMPLE (CROSSREF) before passing the function off to\n be compiled.\n The Fortran front end converts from a private representation to GENERIC,\n@@ -72,22 +72,22 @@ Hum... this sounds overly complicated.  Perhaps we should just\n have the front end gimplify always; in most cases it's only one\n function call.\n \n-The front end needs to pass all function definitions and top level \n+The front end needs to pass all function definitions and top level\n declarations off to the middle-end so that they can be compiled and\n emitted to the object file.  For a simple procedural language, it is\n usually most convenient to do this as each top level declaration or\n definition is seen.  There is also a distinction to be made between\n generating functional code and generating complete debug information.\n The only thing that is absolutely required for functional code is that\n function and data @emph{definitions} be passed to the middle-end.  For\n-complete debug information, function, data and type declarations \n+complete debug information, function, data and type declarations\n should all be passed as well.\n \n @findex rest_of_decl_compilation\n @findex rest_of_type_compilation\n @findex cgraph_finalize_function\n In any case, the front end needs each complete top-level function or\n-data declaration, and each data definition should be passed to \n+data declaration, and each data definition should be passed to\n @code{rest_of_decl_compilation}.  Each complete type definition should\n be passed to @code{rest_of_type_compilation}.  Each function definition\n should be passed to @code{cgraph_finalize_function}.\n@@ -100,7 +100,7 @@ as the official interface?  Possibly we should rename all three\n interfaces such that the names match in some meaningful way and\n that is more descriptive than \"rest_of\".\n \n-The middle-end will, at its option, emit the function and data \n+The middle-end will, at its option, emit the function and data\n definitions immediately or queue them for later processing.\n \n @node Gimplification pass\n@@ -116,7 +116,7 @@ section of code.\n \n @cindex GENERIC\n While a front end may certainly choose to generate GIMPLE directly if\n-it chooses, this can be a moderately complex process unless the \n+it chooses, this can be a moderately complex process unless the\n intermediate language used by the front end is already fairly simple.\n Usually it is easier to generate GENERIC trees plus extensions\n and let the language-independent gimplifier do most of the work.\n@@ -125,7 +125,7 @@ and let the language-independent gimplifier do most of the work.\n @findex gimplify_expr\n @findex lang_hooks.gimplify_expr\n The main entry point to this pass is @code{gimplify_function_tree}\n-located in @file{gimplify.c}.  From here we process the entire \n+located in @file{gimplify.c}.  From here we process the entire\n function gimplifying each statement in turn.  The main workhorse\n for this pass is @code{gimplify_expr}.  Approximately everything\n passes through here at least once, and it is from here that we\n@@ -135,7 +135,7 @@ The callback should examine the expression in question and return\n @code{GS_UNHANDLED} if the expression is not a language specific\n construct that requires attention.  Otherwise it should alter the\n expression in some way to such that forward progress is made toward\n-producing valid GIMPLE.  If the callback is certain that the \n+producing valid GIMPLE.  If the callback is certain that the\n transformation is complete and the expression is valid GIMPLE, it\n should return @code{GS_ALL_DONE}.  Otherwise it should return\n @code{GS_OK}, which will cause the expression to be processed again.\n@@ -152,7 +152,7 @@ and take care of standard bookkeeping that applies to every pass.\n \n The theory of operation is that each pass defines a structure that\n represents everything we need to know about that pass---when it\n-should be run, how it should be run, what intermediate language \n+should be run, how it should be run, what intermediate language\n form or on-the-side data structures it needs.  We register the pass\n to be run in some particular order, and the pass manager arranges\n for everything to happen in the correct order.\n@@ -203,13 +203,13 @@ by @code{pass_mudflap_1}.\n \n @item Lower control flow\n \n-This pass flattens @code{if} statements (@code{COND_EXPR}) and \n+This pass flattens @code{if} statements (@code{COND_EXPR}) and\n and moves lexical bindings (@code{BIND_EXPR}) out of line.  After\n this pass, all @code{if} statements will have exactly two @code{goto}\n statements in its @code{then} and @code{else} arms.  Lexical binding\n information for each statement will be found in @code{TREE_BLOCK} rather\n than being inferred from its position under a @code{BIND_EXPR}.  This\n-pass is found in @file{gimple-low.c} and is described by \n+pass is found in @file{gimple-low.c} and is described by\n @code{pass_lower_cf}.\n \n @item Lower exception handling control flow\n@@ -233,7 +233,7 @@ is described by @code{pass_build_cfg}.\n \n @item Find all referenced variables\n \n-This pass walks the entire function and collects an array of all \n+This pass walks the entire function and collects an array of all\n variables referenced in the function, @code{referenced_vars}.  The\n index at which a variable is found in the array is used as a UID\n for the variable within this function.  This data is needed by the\n@@ -244,8 +244,8 @@ and is described by @code{pass_referenced_vars}.\n \n This pass rewrites the function such that it is in SSA form.  After\n this pass, all @code{is_gimple_reg} variables will be referenced by\n-@code{SSA_NAME}, and all occurrences of other variables will be \n-annotated with @code{VDEFS} and @code{VUSES}; phi nodes will have \n+@code{SSA_NAME}, and all occurrences of other variables will be\n+annotated with @code{VDEFS} and @code{VUSES}; phi nodes will have\n been inserted as necessary for each basic block.  This pass is\n located in @file{tree-ssa.c} and is described by @code{pass_build_ssa}.\n \n@@ -287,23 +287,23 @@ described by @code{pass_redundant_phi}.o\n \n This pass attempts to remove redundant computation by substituting\n variables that are used once into the expression that uses them and\n-seeing if the result can be simplified.  It is located in \n+seeing if the result can be simplified.  It is located in\n @file{tree-ssa-forwprop.c} and is described by @code{pass_forwprop}.\n \n @item Copy Renaming\n \n-This pass attempts to change the name of compiler temporaries involved in \n+This pass attempts to change the name of compiler temporaries involved in\n copy operations such that SSA->normal can coalesce the copy away. When compiler\n temporaries are copies of user variables, it also renames the compiler\n-temporary to the user variable resulting in better use of user symbols.  It is \n-located in @file{tree-ssa-copyrename.c} and is described by \n+temporary to the user variable resulting in better use of user symbols.  It is\n+located in @file{tree-ssa-copyrename.c} and is described by\n @code{pass_copyrename}.\n \n @item PHI node optimizations\n \n This pass recognizes forms of phi inputs that can be represented as\n conditional expressions and rewrites them into straight line code.\n-It is located in @file{tree-ssa-phiopt.c} and is described by \n+It is located in @file{tree-ssa-phiopt.c} and is described by\n @code{pass_phiopt}.\n \n @item May-alias optimization\n@@ -333,7 +333,7 @@ and is described by @code{pass_lower_complex}.\n @item Scalar replacement of aggregates\n \n This pass rewrites suitable non-aliased local aggregate variables into\n-a set of scalar variables.  The resulting scalar variables are \n+a set of scalar variables.  The resulting scalar variables are\n rewritten into SSA form, which allows subsequent optimization passes\n to do a significantly better job with them.  The pass is located in\n @file{tree-sra.c} and is described by @code{pass_sra}.\n@@ -410,7 +410,7 @@ by @code{pass_ccp}.\n \n @item Folding builtin functions\n \n-This pass simplifies builtin functions, as applicable, with constant \n+This pass simplifies builtin functions, as applicable, with constant\n arguments or with inferrable string lengths.  It is located in\n @file{tree-ssa-ccp.c} and is described by @code{pass_fold_builtins}.\n \n@@ -440,7 +440,7 @@ data and control flow problem is solved.  The code transformation\n requires target support, and so is delayed until RTL.  In the\n meantime @code{CALL_EXPR_TAILCALL} is set indicating the possibility.\n The pass is located in @file{tree-tailcall.c} and is described by\n-@code{pass_tail_calls}.  The RTL transformation is handled by \n+@code{pass_tail_calls}.  The RTL transformation is handled by\n @code{fixup_tail_calls} in @file{calls.c}.\n \n @item Warn for function return without value\n@@ -516,13 +516,13 @@ for this pass is located within @file{except.c}.\n This pass removes unreachable code, simplifies jumps to next, jumps to\n jump, jumps across jumps, etc.  The pass is run multiple times.\n For historical reasons, it is occasionally referred to as the ``jump\n-optimization pass''.  The bulk of the code for this pass is in \n+optimization pass''.  The bulk of the code for this pass is in\n @file{cfgcleanup.c}, and there are support routines in @file{cfgrtl.c}\n and @file{jump.c}.\n \n @item Common subexpression elimination\n \n-This pass removes redundant computation within basic blocks, and \n+This pass removes redundant computation within basic blocks, and\n optimizes addressing modes based on cost.  The pass is run twice.\n The source is located in @file{cse.c}.\n \n@@ -617,12 +617,12 @@ completely target-specific.  The source is located in @file{lcm.c}.\n \n @cindex modulo scheduling\n @cindex sms, swing, software pipelining\n-@item Modulo scheduling \n+@item Modulo scheduling\n \n-This pass looks at innermost loops and reorders their instructions \n-by overlapping different iterations.  Modulo scheduling is performed \n+This pass looks at innermost loops and reorders their instructions\n+by overlapping different iterations.  Modulo scheduling is performed\n immediately before instruction scheduling.\n-The pass is located in (@file{modulo-sched.c}).  \n+The pass is located in (@file{modulo-sched.c}).\n \n @item Instruction scheduling\n "}, {"sha": "84a23408e6555a8890539058fbffeb08da3223ac", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0eb93a806a875b7e89f5a2f5217063c0daa0db8/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0eb93a806a875b7e89f5a2f5217063c0daa0db8/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=f0eb93a806a875b7e89f5a2f5217063c0daa0db8", "patch": "@@ -1772,7 +1772,7 @@ saturates at the maximum signed value representable in @var{m};\n This expression represents the sum of @var{x} and the low-order bits\n of @var{y}.  It is used with @code{high} (@pxref{Constants}) to\n represent the typical two-instruction sequence used in RISC machines\n-to reference a global memory location.  \n+to reference a global memory location.\n \n The number of low order bits is machine-dependent but is\n normally the number of bits in a @code{Pmode} item minus the number of"}, {"sha": "ae7599be854490db36354ec3edc89bf5e244f980", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0eb93a806a875b7e89f5a2f5217063c0daa0db8/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0eb93a806a875b7e89f5a2f5217063c0daa0db8/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=f0eb93a806a875b7e89f5a2f5217063c0daa0db8", "patch": "@@ -5024,7 +5024,7 @@ you define this macro, the compiler will use it instead of\n A C expression which is nonzero if @var{x} (assumed to be a @code{reg} RTX)\n is suitable for use as a base register in base plus index operand addresses,\n accessing memory in mode @var{mode}.  It may be either a suitable hard\n-register or a pseudo register that has been allocated such a hard register. \n+register or a pseudo register that has been allocated such a hard register.\n You should define this macro if base plus index addresses have different\n requirements than other base register uses.\n @end defmac"}, {"sha": "68c4f56e0a014c7fb44057fd5f03e916ef89233a", "filename": "gcc/doc/tree-ssa.texi", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0eb93a806a875b7e89f5a2f5217063c0daa0db8/gcc%2Fdoc%2Ftree-ssa.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0eb93a806a875b7e89f5a2f5217063c0daa0db8/gcc%2Fdoc%2Ftree-ssa.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftree-ssa.texi?ref=f0eb93a806a875b7e89f5a2f5217063c0daa0db8", "patch": "@@ -102,7 +102,7 @@ place of the container.\n \n The compiler pass which lowers GENERIC to GIMPLE is referred to as the\n @samp{gimplifier}.  The gimplifier works recursively, replacing complex\n-statements with sequences of simple statements.  \n+statements with sequences of simple statements.\n \n @c Currently, the only way to\n @c tell whether or not an expression is in GIMPLE form is by recursively\n@@ -195,7 +195,7 @@ GIMPLE rvalue (@code{is_gimple_val}), i.e.@: a constant or a register\n variable.  More complex operands are factored out into temporaries, so\n that\n @smallexample\n-  a = b + c + d \n+  a = b + c + d\n @end smallexample\n becomes\n @smallexample\n@@ -293,7 +293,7 @@ Most statements will be assignment statements, represented by\n @code{MODIFY_EXPR}.  A @code{CALL_EXPR} whose value is ignored can\n also be a statement.  No other C expressions can appear at statement level;\n a reference to a volatile object is converted into a @code{MODIFY_EXPR}.\n-In GIMPLE form, type of @code{MODIFY_EXPR} is not meaningful. Instead, use type \n+In GIMPLE form, type of @code{MODIFY_EXPR} is not meaningful. Instead, use type\n of LHS or RHS.\n \n There are also several varieties of complex statements.\n@@ -318,7 +318,7 @@ expressed using the @code{BIND_EXPR} code, which in previous versions of\n GCC was primarily used for the C statement-expression extension.\n \n Variables in a block are collected into @code{BIND_EXPR_VARS} in\n-declaration order.  Any runtime initialization is moved out of \n+declaration order.  Any runtime initialization is moved out of\n @code{DECL_INITIAL} and into a statement in the controlled block.  When\n gimplifying from C or C++, this initialization replaces the\n @code{DECL_STMT}.\n@@ -328,7 +328,7 @@ refers to variables initialized earlier in the block.  To handle this, we\n currently split the block at that point, and move the VLA into a new, inner\n @code{BIND_EXPR}.  This strategy may change in the future.\n \n-@code{DECL_SAVED_TREE} for a GIMPLE function will always be a \n+@code{DECL_SAVED_TREE} for a GIMPLE function will always be a\n @code{BIND_EXPR} which contains declarations for the temporary variables\n used in the function.\n \n@@ -422,7 +422,7 @@ edge.\n @cindex GIMPLE Exception Handling\n \n Other exception handling constructs are represented using\n-@code{TRY_CATCH_EXPR}.  The handler operand of a @code{TRY_CATCH_EXPR} \n+@code{TRY_CATCH_EXPR}.  The handler operand of a @code{TRY_CATCH_EXPR}\n can be a normal statement to be executed if the controlled block throws an\n exception, or it can have one of two special forms:\n \n@@ -711,7 +711,7 @@ operands, they are organized into arrays associated inside each\n statement's annotation.  Each element in an operand array is a pointer\n to a @code{VAR_DECL}, @code{PARM_DECL} or @code{SSA_NAME} tree node.\n This provides a very convenient way of examining and replacing\n-operands.  \n+operands.\n \n Data flow analysis and optimization is done on all tree nodes\n representing variables.  Any node for which @code{SSA_VAR_P} returns\n@@ -755,12 +755,12 @@ In contrast, virtual operands are used with variables that can have\n a partial or ambiguous reference. This includes structures, arrays,\n globals, and aliased variables. In these cases, we have two types of\n definitions. For globals, structures, and arrays, we can determine from\n-a statement whether a variable of these types has a killing definition. \n+a statement whether a variable of these types has a killing definition.\n If the variable does, then the statement is marked as having a\n @dfn{must definition} of that variable. However, if a statement is only\n defining a part of the variable (i.e.@: a field in a structure), or if we\n know that a statement might define the variable but we cannot say for sure,\n-then we mark that statement as having a @dfn{may definition}.  For \n+then we mark that statement as having a @dfn{may definition}.  For\n instance, given\n \n @smallexample\n@@ -814,9 +814,9 @@ incorrect assumptions about them.\n \n Operands are collected by @file{tree-ssa-operands.c}.  They are stored\n inside each statement's annotation and can be accessed with\n-@code{DEF_OPS}, @code{USE_OPS}, @code{V_MAY_DEF_OPS}, \n-@code{V_MUST_DEF_OPS} and @code{VUSE_OPS}. The following are all the \n-accessor macros available to access USE operands.  To access all the \n+@code{DEF_OPS}, @code{USE_OPS}, @code{V_MAY_DEF_OPS},\n+@code{V_MUST_DEF_OPS} and @code{VUSE_OPS}. The following are all the\n+accessor macros available to access USE operands.  To access all the\n other operand arrays, just change the name accordingly:\n \n @defmac USE_OPS (@var{ann})\n@@ -858,15 +858,15 @@ print_ops (tree stmt)\n \n   get_stmt_operands (stmt);\n   ann = stmt_ann (stmt);\n-  \n+\n   defs = DEF_OPS (ann);\n   for (i = 0; i < NUM_DEFS (defs); i++)\n     print_generic_expr (stderr, DEF_OP (defs, i), 0);\n \n   uses = USE_OPS (ann);\n   for (i = 0; i < NUM_USES (uses); i++)\n     print_generic_expr (stderr, USE_OP (uses, i), 0);\n-  \n+\n   v_may_defs = V_MAY_DEF_OPS (ann);\n   for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n     @{\n@@ -877,7 +877,7 @@ print_ops (tree stmt)\n   v_must_defs = V_MUST_DEF_OPS (ann);\n   for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n     print_generic_expr (stderr, V_MUST_DEF_OP (v_must_defs, i), 0);\n-  \n+\n   vuses = VUSE_OPS (ann);\n   for (i = 0; i < NUM_VUSES (vuses); i++)\n     print_generic_expr (stderr, VUSE_OP (vuses, i), 0);\n@@ -914,23 +914,23 @@ print_ops (tree stmt)\n \n @enumerate\n @item Determine whether you are need to see the operand pointers, or just the\n-    trees, and choose the appropriate macro: \n+    trees, and choose the appropriate macro:\n \n @smallexample\n-Need            Macro: \n-----            ------- \n-use_operand_p   FOR_EACH_SSA_USE_OPERAND \n-def_operand_p   FOR_EACH_SSA_DEF_OPERAND \n-tree            FOR_EACH_SSA_TREE_OPERAND \n+Need            Macro:\n+----            -------\n+use_operand_p   FOR_EACH_SSA_USE_OPERAND\n+def_operand_p   FOR_EACH_SSA_DEF_OPERAND\n+tree            FOR_EACH_SSA_TREE_OPERAND\n @end smallexample\n \n @item You need to declare a variable of the type you are interested\n     in, and an ssa_op_iter structure which serves as the loop\n-    controlling variable. \n+    controlling variable.\n \n @item Determine which operands you wish to use, and specify the flags of\n     those you are interested in.  They are documented in\n-    @file{tree-ssa-operands.h}: \n+    @file{tree-ssa-operands.h}:\n \n @smallexample\n #define SSA_OP_USE              0x01    /* Real USE operands.  */\n@@ -950,22 +950,22 @@ tree            FOR_EACH_SSA_TREE_OPERAND\n @end enumerate\n \n So if you want to look at the use pointers for all the @code{USE} and\n-@code{VUSE} operands, you would do something like: \n+@code{VUSE} operands, you would do something like:\n \n @smallexample\n-  use_operand_p use_p; \n-  ssa_op_iter iter; \n+  use_operand_p use_p;\n+  ssa_op_iter iter;\n \n   FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, (SSA_OP_USE | SSA_OP_VUSE))\n-    @{ \n-      process_use_ptr (use_p); \n-    @} \n+    @{\n+      process_use_ptr (use_p);\n+    @}\n @end smallexample\n \n The @code{_TREE_} macro is basically the same as the @code{USE} and\n @code{DEF} macros, only with the use or def dereferenced via\n @code{USE_FROM_PTR (use_p)} and @code{DEF_FROM_PTR (def_p)}. Since we\n-aren't using operand pointers, use and defs flags can be mixed. \n+aren't using operand pointers, use and defs flags can be mixed.\n \n @smallexample\n   tree var;\n@@ -983,22 +983,22 @@ Note that @code{V_MAY_DEFS} are broken into 2 flags, one for the\n @code{V_MAY_DEFS} together, there is a fourth iterator macro for this,\n which returns both a def_operand_p and a use_operand_p for each\n @code{V_MAY_DEF} in the statement. Note that you don't need any flags for\n-this one. \n+this one.\n \n @smallexample\n-  use_operand_p use_p; \n-  def_operand_p def_p; \n-  ssa_op_iter iter; \n-\n-  FOR_EACH_SSA_MAYDEF_OPERAND (def_p, use_p, stmt, iter) \n-    @{ \n-      my_code; \n-    @} \n+  use_operand_p use_p;\n+  def_operand_p def_p;\n+  ssa_op_iter iter;\n+\n+  FOR_EACH_SSA_MAYDEF_OPERAND (def_p, use_p, stmt, iter)\n+    @{\n+      my_code;\n+    @}\n @end smallexample\n \n \n There are many examples in the code as well, as well as the\n-documentation in @file{tree-ssa-operands.h}. \n+documentation in @file{tree-ssa-operands.h}.\n \n \n @node SSA\n@@ -1127,7 +1127,7 @@ Calls function @var{fn} at each reaching definition found.  Function\n (@var{def_stmt}) and a generic pointer to whatever state information\n that @var{fn} may want to maintain (@var{data}).  Function @var{fn} is\n able to stop the walk by returning @code{true}, otherwise in order to\n-continue the walk, @var{fn} should return @code{false}.  \n+continue the walk, @var{fn} should return @code{false}.\n \n Note, that if @var{def_stmt} is a @code{PHI} node, the semantics are\n slightly different.  For each argument @var{arg} of the PHI node, this"}]}