{"sha": "86ce59b4f05d8f68ec4d9a14a7732acb370412db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZjZTU5YjRmMDVkOGY2OGVjNGQ5YTE0YTc3MzJhY2IzNzA0MTJkYg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-06-25T09:21:20Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-06-25T10:29:52Z"}, "message": "tree-optimization/95866 - avoid using scalar ops for vectorized shift\n\nThis avoids using the original scalar SSA operand when vectorizing\na shift with a vectorized shift operand where we know all vector\ncomponents have the same value and thus we can use a vector by\nscalar shift.  Using the scalar SSA operand causes a possibly\nlong chain of scalar computation to be retained so it's better\nto simply extract lane zero from the available vectorized shift\noperand.\n\n2020-06-25  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/95866\n\t* tree-vect-stmts.c (vectorizable_shift): Reject incompatible\n\tvectorized shift operands.  For scalar shifts use lane zero\n\tof a vectorized shift operand.\n\n\t* gcc.dg/vect/bb-slp-pr95866.c: New testcase.", "tree": {"sha": "eb7c81a823bc2aaef6319c4cf91d561847bab2d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb7c81a823bc2aaef6319c4cf91d561847bab2d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86ce59b4f05d8f68ec4d9a14a7732acb370412db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86ce59b4f05d8f68ec4d9a14a7732acb370412db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86ce59b4f05d8f68ec4d9a14a7732acb370412db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86ce59b4f05d8f68ec4d9a14a7732acb370412db/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88891c5ff0e3e20d3dd743c4eb6cc45399ee5c33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88891c5ff0e3e20d3dd743c4eb6cc45399ee5c33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88891c5ff0e3e20d3dd743c4eb6cc45399ee5c33"}], "stats": {"total": 47, "additions": 44, "deletions": 3}, "files": [{"sha": "5de46719101e9d3ea1c4ab2434cba88c31e04623", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-pr95866.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ce59b4f05d8f68ec4d9a14a7732acb370412db/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr95866.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ce59b4f05d8f68ec4d9a14a7732acb370412db/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr95866.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr95866.c?ref=86ce59b4f05d8f68ec4d9a14a7732acb370412db", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_shift } */\n+\n+int x[4];\n+int j[4];\n+void foo()\n+{\n+  x[0] = (x[0] << j[0]) + j[0];\n+  x[1] = (x[1] << j[0]) + j[1];\n+  x[2] = (x[2] << j[0]) + j[2];\n+  x[3] = (x[3] << j[0]) + j[3];\n+}\n+\n+/* The scalar shift argument should be extracted from the available vector.  */\n+/* { dg-final { scan-tree-dump \"BIT_FIELD_REF\" \"slp2\" } } */\n+/* { dg-final { scan-tree-dump \"basic block vectorized\" \"slp2\" } } */"}, {"sha": "edd28534cb0fb5f0e9d27efbf15d62cf7942cb2c", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ce59b4f05d8f68ec4d9a14a7732acb370412db/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ce59b4f05d8f68ec4d9a14a7732acb370412db/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=86ce59b4f05d8f68ec4d9a14a7732acb370412db", "patch": "@@ -5413,6 +5413,15 @@ vectorizable_shift (vec_info *vinfo,\n \t\t= (!op1_vectype\n \t\t   || !tree_nop_conversion_p (TREE_TYPE (vectype),\n \t\t\t\t\t      TREE_TYPE (op1)));\n+\t      if (incompatible_op1_vectype_p\n+\t\t  && dt[1] == vect_internal_def)\n+\t\t{\n+\t\t  if (dump_enabled_p ())\n+\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t     \"unusable type for last operand in\"\n+\t\t\t\t     \" vector/vector shift/rotate.\\n\");\n+\t\t  return false;\n+\t\t}\n             }\n         }\n     }\n@@ -5457,7 +5466,7 @@ vectorizable_shift (vec_info *vinfo,\n     {\n       if (slp_node\n \t  && (!vect_maybe_update_slp_op_vectype (slp_op0, vectype)\n-\t      || (!scalar_shift_arg\n+\t      || ((!scalar_shift_arg || dt[1] == vect_internal_def)\n \t\t  && (!incompatible_op1_vectype_p\n \t\t      || dt[1] == vect_constant_def)\n \t\t  && !vect_maybe_update_slp_op_vectype\n@@ -5499,6 +5508,7 @@ vectorizable_shift (vec_info *vinfo,\n \n   if (incompatible_op1_vectype_p && !slp_node)\n     {\n+      gcc_assert (!scalar_shift_arg && was_scalar_shift_arg);\n       op1 = fold_convert (TREE_TYPE (vectype), op1);\n       if (dt[1] != vect_constant_def)\n \top1 = vect_init_vector (vinfo, stmt_info, op1,\n@@ -5508,7 +5518,7 @@ vectorizable_shift (vec_info *vinfo,\n   /* Handle def.  */\n   vec_dest = vect_create_destination_var (scalar_dest, vectype);\n \n-  if (scalar_shift_arg)\n+  if (scalar_shift_arg && dt[1] != vect_internal_def)\n     {\n       /* Vector shl and shr insn patterns can be defined with scalar\n \t operand 2 (shift operand).  In this case, use constant or loop\n@@ -5533,7 +5543,7 @@ vectorizable_shift (vec_info *vinfo,\n \t    vec_oprnds1.quick_push (vec_oprnd1);\n \t}\n     }\n-  else if (slp_node && incompatible_op1_vectype_p)\n+  else if (!scalar_shift_arg && slp_node && incompatible_op1_vectype_p)\n     {\n       if (was_scalar_shift_arg)\n \t{\n@@ -5566,6 +5576,20 @@ vectorizable_shift (vec_info *vinfo,\n   FOR_EACH_VEC_ELT (vec_oprnds0, i, vop0)\n     {\n       vop1 = vec_oprnds1[i];\n+      /* For internal defs where we need to use a scalar shift arg\n+\t extract the first lane.  */\n+      if (scalar_shift_arg && dt[1] == vect_internal_def)\n+\t{\n+\t  new_temp = make_ssa_name (TREE_TYPE (TREE_TYPE (vop1)));\n+\t  gassign *new_stmt\n+\t    = gimple_build_assign (new_temp,\n+\t\t\t\t   build3 (BIT_FIELD_REF, TREE_TYPE (new_temp),\n+\t\t\t\t\t   vop1,\n+\t\t\t\t\t   TYPE_SIZE (TREE_TYPE (new_temp)),\n+\t\t\t\t\t   bitsize_zero_node));\n+\t  vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n+\t  vop1 = new_temp;\n+\t}\n       gassign *new_stmt = gimple_build_assign (vec_dest, code, vop0, vop1);\n       new_temp = make_ssa_name (vec_dest, new_stmt);\n       gimple_assign_set_lhs (new_stmt, new_temp);"}]}