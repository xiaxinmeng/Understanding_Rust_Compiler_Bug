{"sha": "5782bb7ab9dc34f6b15497ad1901a0e04f60edaa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc4MmJiN2FiOWRjMzRmNmIxNTQ5N2FkMTkwMWEwZTA0ZjYwZWRhYQ==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2009-08-16T09:02:25Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2009-08-16T09:02:25Z"}, "message": "re PR debug/37801 (DWARF output for inlined functions doesn't always use DW_TAG_inlined_subroutine)\n\nFix for PR debug/37801\n\ngcc/ChangeLog:\n\t* gcc/dwarf2out.c (gen_inlined_subroutine_die): Concentrate on\n\tgenerating inlined subroutine die only. We shouldn't be\n\tcalled for anything else.\n\t(gen_block_die): Don't generate inline subroutine debug info for\n\tabstract blocks.\n\ngcc/testsuite/ChangeLog:\n\t* gcc/testsuite/gcc.dg/debug/20020224-1.c: Adjust the comment.\n\tMake sure to trigger inlining optimizations.\n\t* gcc/testsuite/gcc.dg/debug/dwarf2/inline2.c: New test.\n\nFrom-SVN: r150796", "tree": {"sha": "ff8f417d6afbf65980df2ad5caf6f29f56f4a769", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff8f417d6afbf65980df2ad5caf6f29f56f4a769"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5782bb7ab9dc34f6b15497ad1901a0e04f60edaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5782bb7ab9dc34f6b15497ad1901a0e04f60edaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5782bb7ab9dc34f6b15497ad1901a0e04f60edaa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5782bb7ab9dc34f6b15497ad1901a0e04f60edaa/comments", "author": null, "committer": null, "parents": [{"sha": "e9dcb5db7d0e3906f5b13c875013012151a0778c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9dcb5db7d0e3906f5b13c875013012151a0778c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9dcb5db7d0e3906f5b13c875013012151a0778c"}], "stats": {"total": 143, "additions": 123, "deletions": 20}, "files": [{"sha": "f0a306195e1b1f5d0ffdaa22b61238d54e3b52a1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5782bb7ab9dc34f6b15497ad1901a0e04f60edaa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5782bb7ab9dc34f6b15497ad1901a0e04f60edaa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5782bb7ab9dc34f6b15497ad1901a0e04f60edaa", "patch": "@@ -1,3 +1,11 @@\n+2009-08-16  Dodji Seketeli  <dodji@redhat.com>\n+\n+\t* gcc/dwarf2out.c (gen_inlined_subroutine_die): Concentrate on\n+\tgenerating inlined subroutine die only. We shouldn't be\n+\tcalled for anything else.\n+\t(gen_block_die): Don't generate inline subroutine debug info for\n+\tabstract blocks.\n+\n 2009-08-15  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* graphite-poly.c (print_pbb): Print PBB index."}, {"sha": "2ee1df80ca0d6329820ba146a25c305943378927", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5782bb7ab9dc34f6b15497ad1901a0e04f60edaa/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5782bb7ab9dc34f6b15497ad1901a0e04f60edaa/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=5782bb7ab9dc34f6b15497ad1901a0e04f60edaa", "patch": "@@ -15003,7 +15003,13 @@ gen_lexical_block_die (tree stmt, dw_die_ref context_die, int depth)\n static void\n gen_inlined_subroutine_die (tree stmt, dw_die_ref context_die, int depth)\n {\n-  tree decl = block_ultimate_origin (stmt);\n+  tree decl;\n+\n+  /* The instance of function that is effectively being inlined shall not\n+     be abstract.  */\n+  gcc_assert (! BLOCK_ABSTRACT (stmt));\n+\n+  decl = block_ultimate_origin (stmt);\n \n   /* Emit info for the abstract instance first, if we haven't yet.  We\n      must emit this even if the block is abstract, otherwise when we\n@@ -15024,20 +15030,6 @@ gen_inlined_subroutine_die (tree stmt, dw_die_ref context_die, int depth)\n       decls_for_scope (stmt, subr_die, depth);\n       current_function_has_inlines = 1;\n     }\n-  else\n-    /* We may get here if we're the outer block of function A that was\n-       inlined into function B that was inlined into function C.  When\n-       generating debugging info for C, dwarf2out_abstract_function(B)\n-       would mark all inlined blocks as abstract, including this one.\n-       So, we wouldn't (and shouldn't) expect labels to be generated\n-       for this one.  Instead, just emit debugging info for\n-       declarations within the block.  This is particularly important\n-       in the case of initializers of arguments passed from B to us:\n-       if they're statement expressions containing declarations, we\n-       wouldn't generate dies for their abstract variables, and then,\n-       when generating dies for the real variables, we'd die (pun\n-       intended :-)  */\n-    gen_lexical_block_die (stmt, context_die, depth);\n }\n \n /* Generate a DIE for a field in a record, or structure.  */\n@@ -15666,7 +15658,23 @@ gen_block_die (tree stmt, dw_die_ref context_die, int depth)\n   if (must_output_die)\n     {\n       if (inlined_func)\n-\tgen_inlined_subroutine_die (stmt, context_die, depth);\n+\t{\n+\t  /* If STMT block is abstract, that means we have been called\n+\t     indirectly from dwarf2out_abstract_function.\n+\t     That function rightfully marks the descendent blocks (of\n+\t     the abstract function it is dealing with) as being abstract,\n+\t     precisely to prevent us from emitting any\n+\t     DW_TAG_inlined_subroutine DIE as a descendent\n+\t     of an abstract function instance. So in that case, we should\n+\t     not call gen_inlined_subroutine_die.\n+\n+\t     Later though, when cgraph asks dwarf2out to emit info\n+\t     for the concrete instance of the function decl into which\n+\t     the concrete instance of STMT got inlined, the later will lead\n+\t     to the generation of a DW_TAG_inlined_subroutine DIE.  */\n+\t  if (! BLOCK_ABSTRACT (stmt))\n+\t    gen_inlined_subroutine_die (stmt, context_die, depth);\n+\t}\n       else\n \tgen_lexical_block_die (stmt, context_die, depth);\n     }"}, {"sha": "6c7bb39f12adaeba60ff612491158af0ab673445", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5782bb7ab9dc34f6b15497ad1901a0e04f60edaa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5782bb7ab9dc34f6b15497ad1901a0e04f60edaa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5782bb7ab9dc34f6b15497ad1901a0e04f60edaa", "patch": "@@ -1,3 +1,9 @@\n+2009-08-16  Dodji Seketeli  <dodji@redhat.com>\n+\n+\t* gcc/testsuite/gcc.dg/debug/20020224-1.c: Adjust the comment.\n+\tMake sure to trigger inlining optimizations.\n+\t* gcc/testsuite/gcc.dg/debug/dwarf2/inline2.c: New test.\n+\n 2009-08-14  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/41070"}, {"sha": "968b5655b39121b27b7d303f44cb6cdfa87366e1", "filename": "gcc/testsuite/gcc.dg/debug/20020224-1.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5782bb7ab9dc34f6b15497ad1901a0e04f60edaa/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2F20020224-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5782bb7ab9dc34f6b15497ad1901a0e04f60edaa/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2F20020224-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2F20020224-1.c?ref=5782bb7ab9dc34f6b15497ad1901a0e04f60edaa", "patch": "@@ -1,9 +1,13 @@\n+/* { dg-options \"-g3 -O\" } */\n /* { dg-do compile } */\n \n-/* Here's the deal: f3 is not inlined because it's too big, but f2 and\n-   f1 are inlined into it.  We used to fail to emit debugging info for\n-   t1, because it was moved inside the (inlined) block of f1, marked\n-   as abstract, then we'd crash.  */\n+/* Here's the deal: f4 is inlined into main, f3 is inlined into f4, f2 is\n+   inlined into f1. The DIE of main should contain DW_TAG_inlined_subroutines\n+   children for f4, f3, f2 and f1. Also, there should be a DIE representing\n+   and out of line instance of f4, aside the DIE representing its abstract\n+   instance.\n+   We used to fail to emit debugging info for t1, because it was moved\n+   inside the (inlined) block of f1, marked as abstract, then we'd crash.  */\n \n #define UNUSED __attribute__((unused))\n #define EXT __extension__\n@@ -58,3 +62,10 @@ f4 (void)\n \n   return;\n }\n+\n+int\n+main ()\n+{\n+    int foo = 1;\n+    f4 ();\n+}"}, {"sha": "6ef01dff48f7b06776dca4abf918ae5b531b81dd", "filename": "gcc/testsuite/gcc.dg/debug/dwarf2/inline2.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5782bb7ab9dc34f6b15497ad1901a0e04f60edaa/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Finline2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5782bb7ab9dc34f6b15497ad1901a0e04f60edaa/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Finline2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Finline2.c?ref=5782bb7ab9dc34f6b15497ad1901a0e04f60edaa", "patch": "@@ -0,0 +1,70 @@\n+/* Contributed by Dodji Seketeli <dodji@redhat.com>\n+   Origin: PR debug/37801\n+\n+  Abstract instances (DW_TAG_subroutines having the DW_AT_inline attribute)\n+  of second and first were having a DW_TAG_lexical_block DIE wrongly\n+  representing the inlined calls to third (in second) and to\n+  second (in first). At the same time, main didn't have children\n+  DW_TAG_inlined_subroutine DIEs representing the inlined calls to\n+  first, second and third.\n+\n+  The ideal goal here is to test that we have no superfluous\n+  DW_TAG_lexical_block DIE anymore, that abstract instances DIEs have\n+  no descendant DIE with a DW_AT_abstract_origin attribute, and that main has\n+  properly nested DW_TAG_inlined_subroutine DIEs for third, second and first.\n+*/\n+\n+/* { dg-options \"-O -g3\" } */\n+/* { dg-do compile } */\n+\n+/* There are 6 inlined subroutines:\n+   - One for each subroutine inlined into main, that's 3.\n+   - One for earch subroutine inline into the out of line instances\n+     of third, second and first.  */\n+/* { dg-final { scan-assembler-times \"\\\\(DIE \\\\(.*?\\\\) DW_TAG_inlined_subroutine\" 6 } } */\n+\n+/* Likewise we should have 6 DW_TAG_lexical_block DIEs:\n+   - One for each subroutine inlined into main, so that's 3.\n+   - One for each subroutine inlined in the out of line instances\n+     of third, second and first, that's 3.\n+*/\n+/* { dg-final { scan-assembler-times \"\\\\(DIE \\\\(.*?\\\\) DW_TAG_lexical_block\" 6 } } */\n+\n+\n+/* There are 3 DW_AT_inline attributes: one per abstract inline instance.\n+   The value of the attribute must be 0x3, meaning the function was\n+   actually inlined.  */\n+/* { dg-final { scan-assembler-times \"byte.*?0x3.*? DW_AT_inline\" 3 } } */\n+\n+\n+inline void\n+third (int arg3)\n+{\n+  int var3 = arg3;\n+  int* a = 0;\n+  a[0] = var3;\n+}\n+\n+inline void\n+second (int arg2)\n+{\n+  int var2 = arg2;\n+  third (var2+1);\n+}\n+\n+inline void\n+first (int arg1)\n+{\n+  int var1 = arg1;\n+  second (var1+1);\n+}\n+\n+int\n+main ()\n+{\n+  int some_int = 1;\n+  first (some_int);\n+  return 0;\n+}\n+\n+"}]}