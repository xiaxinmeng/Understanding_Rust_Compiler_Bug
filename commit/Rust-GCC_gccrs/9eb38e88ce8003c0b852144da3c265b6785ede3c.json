{"sha": "9eb38e88ce8003c0b852144da3c265b6785ede3c", "node_id": "C_kwDOANBUbNoAKDllYjM4ZTg4Y2U4MDAzYzBiODUyMTQ0ZGEzYzI2NWI2Nzg1ZWRlM2M", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-04-28T18:19:14Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-04-29T08:44:18Z"}, "message": "Move common code from range-op.cc to header files.\n\nIn preparation for the agnostication of ranger, this patch moves\ncommon code that can be shared between non-integer ranges (initially\npointers) into the relevant header files.\n\nThis is a relatively non-invasive change, as any changes that would\nneed to be ported to GCC 12, would occur in the range-op entries\nthemselves, not in the supporting glue which I'm moving.\n\nTested and benchmarked on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* range-op.cc (empty_range_varying): Move to range-op.h.\n\t(range_true): Move to range.h.\n\t(range_false): Same.\n\t(range_true_and_false): Same.\n\t(enum bool_range_state): Move to range-op.h.\n\t(relop_early_resolve): Same.\n\t(operator_equal::op1_op2_relation): Abstract code to...\n\t(equal_op1_op2_relation): ...here.\n\t(operator_not_equal::op1_op2_relation): Abstract code to...\n\t(not_equal_op1_op2_relation): ...here.\n\t(operator_lt::op1_op2_relation): Abstract code to...\n\t(lt_op1_op2_relation): ...here.\n\t(operator_le::op1_op2_relation): Abstract code to...\n\t(le_op1_op2_relation): ...here.\n\t(operator_gt::op1_op2_relation): Abstract code to...\n\t(gt_op1_op2_relation): ...here.\n\t(operator_ge::op1_op2_relation): Abstract code to...\n\t(ge_op1_op2_relation): ...here.\n\t(class range_op_table): Move to range-op.h.\n\t* range-op.h (equal_op1_op2_relation): Moved from range-op.cc.\n\t(not_equal_op1_op2_relation): Same.\n\t(lt_op1_op2_relation): Same.\n\t(le_op1_op2_relation): Same.\n\t(gt_op1_op2_relation): Same.\n\t(ge_op1_op2_relation): Same.\n\t(enum bool_range_state): Same.\n\t(get_bool_state): Same.\n\t(empty_range_varying): Same.\n\t(relop_early_resolve): Same.\n\t(class range_op_table): Same.\n\t* range.h (range_true): Same.\n\t(range_false): Same.\n\t(range_true_and_false): Same.", "tree": {"sha": "de9fa3bb22a6ca19b61d597912911d45c87cc536", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de9fa3bb22a6ca19b61d597912911d45c87cc536"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9eb38e88ce8003c0b852144da3c265b6785ede3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eb38e88ce8003c0b852144da3c265b6785ede3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9eb38e88ce8003c0b852144da3c265b6785ede3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eb38e88ce8003c0b852144da3c265b6785ede3c/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c13fd1b8fd8eef009370a629bd2ca2bbdb2f828d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c13fd1b8fd8eef009370a629bd2ca2bbdb2f828d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c13fd1b8fd8eef009370a629bd2ca2bbdb2f828d"}], "stats": {"total": 240, "additions": 143, "deletions": 97}, "files": [{"sha": "fa962507b929f868a47ca8c643c3ba86fafbcd4b", "filename": "gcc/range-op.cc", "status": "modified", "additions": 43, "deletions": 97, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb38e88ce8003c0b852144da3c265b6785ede3c/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb38e88ce8003c0b852144da3c265b6785ede3c/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=9eb38e88ce8003c0b852144da3c265b6785ede3c", "patch": "@@ -63,24 +63,6 @@ min_limit (const_tree type)\n   return wi::min_value (TYPE_PRECISION (type) , TYPE_SIGN (type));\n }\n \n-// If the range of either op1 or op2 is undefined, set the result to\n-// varying and return TRUE.  If the caller truely cares about a result,\n-// they should pass in a varying if it has an undefined that it wants\n-// treated as a varying.\n-\n-inline bool\n-empty_range_varying (irange &r, tree type,\n-\t\t     const irange &op1, const irange & op2)\n-{\n-  if (op1.undefined_p () || op2.undefined_p ())\n-    {\n-      r.set_varying (type);\n-      return true;\n-    }\n-  else\n-    return false;\n-}\n-\n // Return false if shifting by OP is undefined behavior.  Otherwise, return\n // true and the range it is to be shifted by.  This allows trimming out of\n // undefined ranges, leaving only valid ranges if there are any.\n@@ -432,39 +414,10 @@ create_possibly_reversed_range (irange &r, tree type,\n     r.set (wide_int_to_tree (type, new_lb), wide_int_to_tree (type, new_ub));\n }\n \n-// Return an irange instance that is a boolean TRUE.\n-\n-static inline int_range<1>\n-range_true (tree type)\n-{\n-  unsigned prec = TYPE_PRECISION (type);\n-  return int_range<1> (type, wi::one (prec), wi::one (prec));\n-}\n-\n-// Return an irange instance that is a boolean FALSE.\n-\n-static inline int_range<1>\n-range_false (tree type)\n-{\n-  unsigned prec = TYPE_PRECISION (type);\n-  return int_range<1> (type, wi::zero (prec), wi::zero (prec));\n-}\n-\n-// Return an irange that covers both true and false.\n-\n-static inline int_range<1>\n-range_true_and_false (tree type)\n-{\n-  unsigned prec = TYPE_PRECISION (type);\n-  return int_range<1> (type, wi::zero (prec), wi::one (prec));\n-}\n-\n-enum bool_range_state { BRS_FALSE, BRS_TRUE, BRS_EMPTY, BRS_FULL };\n-\n // Return the summary information about boolean range LHS.  If EMPTY/FULL,\n // return the equivalent range for TYPE in R; if FALSE/TRUE, do nothing.\n \n-static bool_range_state\n+bool_range_state\n get_bool_state (irange &r, const irange &lhs, tree val_type)\n {\n   // If there is no result, then this is unexecutable.\n@@ -488,37 +441,6 @@ get_bool_state (irange &r, const irange &lhs, tree val_type)\n   return BRS_TRUE;\n }\n \n-// For relation opcodes, first try to see if the supplied relation\n-// forces a true or false result, and return that.\n-// Then check for undefined operands.  If none of this applies,\n-// return false.\n-\n-static inline bool\n-relop_early_resolve (irange &r, tree type, const irange &op1,\n-\t\t     const irange &op2, relation_kind rel,\n-\t\t     relation_kind my_rel)\n-{\n-  // If known relation is a complete subset of this relation, always true.\n-  if (relation_union (rel, my_rel) == my_rel)\n-    {\n-      r = range_true (type);\n-      return true;\n-    }\n-\n-  // If known relation has no subset of this relation, always false.\n-  if (relation_intersect (rel, my_rel) == VREL_EMPTY)\n-    {\n-      r = range_false (type);\n-      return true;\n-    }\n-\n-  // If either operand is undefined, return VARYING.\n-  if (empty_range_varying (r, type, op1, op2))\n-    return true;\n-\n-  return false;\n-}\n-\n \n class operator_equal : public range_operator\n {\n@@ -541,7 +463,7 @@ class operator_equal : public range_operator\n // Check if the LHS range indicates a relation between OP1 and OP2.\n \n enum tree_code\n-operator_equal::op1_op2_relation (const irange &lhs) const\n+equal_op1_op2_relation (const irange &lhs)\n {\n   if (lhs.undefined_p ())\n     return VREL_EMPTY;\n@@ -556,6 +478,12 @@ operator_equal::op1_op2_relation (const irange &lhs) const\n   return VREL_NONE;\n }\n \n+enum tree_code\n+operator_equal::op1_op2_relation (const irange &lhs) const\n+{\n+  return equal_op1_op2_relation (lhs);\n+}\n+\n \n bool\n operator_equal::fold_range (irange &r, tree type,\n@@ -651,7 +579,7 @@ class operator_not_equal : public range_operator\n // Check if the LHS range indicates a relation between OP1 and OP2.\n \n enum tree_code\n-operator_not_equal::op1_op2_relation (const irange &lhs) const\n+not_equal_op1_op2_relation (const irange &lhs)\n {\n   if (lhs.undefined_p ())\n     return VREL_EMPTY;\n@@ -666,6 +594,12 @@ operator_not_equal::op1_op2_relation (const irange &lhs) const\n   return VREL_NONE;\n }\n \n+enum tree_code\n+operator_not_equal::op1_op2_relation (const irange &lhs) const\n+{\n+  return not_equal_op1_op2_relation (lhs);\n+}\n+\n bool\n operator_not_equal::fold_range (irange &r, tree type,\n \t\t\t\tconst irange &op1,\n@@ -821,7 +755,7 @@ class operator_lt :  public range_operator\n // Check if the LHS range indicates a relation between OP1 and OP2.\n \n enum tree_code\n-operator_lt::op1_op2_relation (const irange &lhs) const\n+lt_op1_op2_relation (const irange &lhs)\n {\n   if (lhs.undefined_p ())\n     return VREL_EMPTY;\n@@ -836,6 +770,12 @@ operator_lt::op1_op2_relation (const irange &lhs) const\n   return VREL_NONE;\n }\n \n+enum tree_code\n+operator_lt::op1_op2_relation (const irange &lhs) const\n+{\n+  return lt_op1_op2_relation (lhs);\n+}\n+\n bool\n operator_lt::fold_range (irange &r, tree type,\n \t\t\t const irange &op1,\n@@ -923,7 +863,7 @@ class operator_le :  public range_operator\n // Check if the LHS range indicates a relation between OP1 and OP2.\n \n enum tree_code\n-operator_le::op1_op2_relation (const irange &lhs) const\n+le_op1_op2_relation (const irange &lhs)\n {\n   if (lhs.undefined_p ())\n     return VREL_EMPTY;\n@@ -938,6 +878,12 @@ operator_le::op1_op2_relation (const irange &lhs) const\n   return VREL_NONE;\n }\n \n+enum tree_code\n+operator_le::op1_op2_relation (const irange &lhs) const\n+{\n+  return le_op1_op2_relation (lhs);\n+}\n+\n bool\n operator_le::fold_range (irange &r, tree type,\n \t\t\t const irange &op1,\n@@ -1025,7 +971,7 @@ class operator_gt :  public range_operator\n // Check if the LHS range indicates a relation between OP1 and OP2.\n \n enum tree_code\n-operator_gt::op1_op2_relation (const irange &lhs) const\n+gt_op1_op2_relation (const irange &lhs)\n {\n   if (lhs.undefined_p ())\n     return VREL_EMPTY;\n@@ -1040,6 +986,12 @@ operator_gt::op1_op2_relation (const irange &lhs) const\n   return VREL_NONE;\n }\n \n+enum tree_code\n+operator_gt::op1_op2_relation (const irange &lhs) const\n+{\n+  return gt_op1_op2_relation (lhs);\n+}\n+\n \n bool\n operator_gt::fold_range (irange &r, tree type,\n@@ -1126,7 +1078,7 @@ class operator_ge :  public range_operator\n // Check if the LHS range indicates a relation between OP1 and OP2.\n \n enum tree_code\n-operator_ge::op1_op2_relation (const irange &lhs) const\n+ge_op1_op2_relation (const irange &lhs)\n {\n   if (lhs.undefined_p ())\n     return VREL_EMPTY;\n@@ -1141,6 +1093,12 @@ operator_ge::op1_op2_relation (const irange &lhs) const\n   return VREL_NONE;\n }\n \n+enum tree_code\n+operator_ge::op1_op2_relation (const irange &lhs) const\n+{\n+  return ge_op1_op2_relation (lhs);\n+}\n+\n bool\n operator_ge::fold_range (irange &r, tree type,\n \t\t\t const irange &op1,\n@@ -3993,18 +3951,6 @@ pointer_or_operator::wi_fold (irange &r, tree type,\n     r.set_varying (type);\n }\n \f\n-// This implements the range operator tables as local objects in this file.\n-\n-class range_op_table\n-{\n-public:\n-  inline range_operator *operator[] (enum tree_code code);\n-protected:\n-  void set (enum tree_code code, range_operator &op);\n-private:\n-  range_operator *m_range_tree[MAX_TREE_CODES];\n-};\n-\n // Return a pointer to the range_operator instance, if there is one\n // associated with tree_code CODE.\n "}, {"sha": "c93eb84454700678c770381e32f958851a695a93", "filename": "gcc/range-op.h", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb38e88ce8003c0b852144da3c265b6785ede3c/gcc%2Frange-op.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb38e88ce8003c0b852144da3c265b6785ede3c/gcc%2Frange-op.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.h?ref=9eb38e88ce8003c0b852144da3c265b6785ede3c", "patch": "@@ -112,4 +112,76 @@ extern void wi_set_zero_nonzero_bits (tree type,\n \t\t\t\t      wide_int &maybe_nonzero,\n \t\t\t\t      wide_int &mustbe_nonzero);\n \n+// op1_op2_relation methods that are the same across irange and frange.\n+enum tree_code equal_op1_op2_relation (const irange &lhs);\n+enum tree_code not_equal_op1_op2_relation (const irange &lhs);\n+enum tree_code lt_op1_op2_relation (const irange &lhs);\n+enum tree_code le_op1_op2_relation (const irange &lhs);\n+enum tree_code gt_op1_op2_relation (const irange &lhs);\n+enum tree_code ge_op1_op2_relation (const irange &lhs);\n+\n+enum bool_range_state { BRS_FALSE, BRS_TRUE, BRS_EMPTY, BRS_FULL };\n+bool_range_state get_bool_state (irange &r, const irange &lhs, tree val_type);\n+\n+// If the range of either op1 or op2 is undefined, set the result to\n+// varying and return TRUE.  If the caller truely cares about a result,\n+// they should pass in a varying if it has an undefined that it wants\n+// treated as a varying.\n+\n+inline bool\n+empty_range_varying (irange &r, tree type,\n+\t\t     const irange &op1, const irange & op2)\n+{\n+  if (op1.undefined_p () || op2.undefined_p ())\n+    {\n+      r.set_varying (type);\n+      return true;\n+    }\n+  else\n+    return false;\n+}\n+\n+// For relation opcodes, first try to see if the supplied relation\n+// forces a true or false result, and return that.\n+// Then check for undefined operands.  If none of this applies,\n+// return false.\n+\n+inline bool\n+relop_early_resolve (irange &r, tree type, const irange &op1,\n+\t\t     const irange &op2, relation_kind rel,\n+\t\t     relation_kind my_rel)\n+{\n+  // If known relation is a complete subset of this relation, always true.\n+  if (relation_union (rel, my_rel) == my_rel)\n+    {\n+      r = range_true (type);\n+      return true;\n+    }\n+\n+  // If known relation has no subset of this relation, always false.\n+  if (relation_intersect (rel, my_rel) == VREL_EMPTY)\n+    {\n+      r = range_false (type);\n+      return true;\n+    }\n+\n+  // If either operand is undefined, return VARYING.\n+  if (empty_range_varying (r, type, op1, op2))\n+    return true;\n+\n+  return false;\n+}\n+\n+// This implements the range operator tables as local objects.\n+\n+class range_op_table\n+{\n+public:\n+  range_operator *operator[] (enum tree_code code);\n+protected:\n+  void set (enum tree_code code, range_operator &op);\n+private:\n+  range_operator *m_range_tree[MAX_TREE_CODES];\n+};\n+\n #endif // GCC_RANGE_OP_H"}, {"sha": "5c70c66566c59ca0a4976a7e75b39e597d5f2854", "filename": "gcc/range.h", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb38e88ce8003c0b852144da3c265b6785ede3c/gcc%2Frange.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb38e88ce8003c0b852144da3c265b6785ede3c/gcc%2Frange.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange.h?ref=9eb38e88ce8003c0b852144da3c265b6785ede3c", "patch": "@@ -25,4 +25,32 @@ value_range range_zero (tree type);\n value_range range_nonzero (tree type);\n value_range range_positives (tree type);\n value_range range_negatives (tree type);\n+\n+// Return an irange instance that is a boolean TRUE.\n+\n+static inline int_range<1>\n+range_true (tree type)\n+{\n+  unsigned prec = TYPE_PRECISION (type);\n+  return int_range<1> (type, wi::one (prec), wi::one (prec));\n+}\n+\n+// Return an irange instance that is a boolean FALSE.\n+\n+static inline int_range<1>\n+range_false (tree type)\n+{\n+  unsigned prec = TYPE_PRECISION (type);\n+  return int_range<1> (type, wi::zero (prec), wi::zero (prec));\n+}\n+\n+// Return an irange that covers both true and false.\n+\n+static inline int_range<1>\n+range_true_and_false (tree type)\n+{\n+  unsigned prec = TYPE_PRECISION (type);\n+  return int_range<1> (type, wi::zero (prec), wi::one (prec));\n+}\n+\n #endif // GCC_RANGE_H"}]}