{"sha": "2acceeac67a10df936fd59f47e3ee72f87e162f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmFjY2VlYWM2N2ExMGRmOTM2ZmQ1OWY0N2UzZWU3MmY4N2UxNjJmNQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2008-05-25T16:55:23Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2008-05-25T16:55:23Z"}, "message": "complex: Trivial stylistic changes...\n\n2008-05-25  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* include/std/complex: Trivial stylistic changes, define inline\n\tmembers inline, consistently with the rest of the library.\n\t(pow(const _Tp&, const complex<>&)): Minor tweak.\n\nFrom-SVN: r135872", "tree": {"sha": "7c7891fa47e5b19706ffa61ef426d2420078bef4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c7891fa47e5b19706ffa61ef426d2420078bef4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2acceeac67a10df936fd59f47e3ee72f87e162f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2acceeac67a10df936fd59f47e3ee72f87e162f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2acceeac67a10df936fd59f47e3ee72f87e162f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2acceeac67a10df936fd59f47e3ee72f87e162f5/comments", "author": null, "committer": null, "parents": [{"sha": "3bffa1954c786a96419edce86343f6e66f111941", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bffa1954c786a96419edce86343f6e66f111941", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bffa1954c786a96419edce86343f6e66f111941"}], "stats": {"total": 803, "additions": 347, "deletions": 456}, "files": [{"sha": "19e3dca233fd0e68866cb11084f217862ae3ec37", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2acceeac67a10df936fd59f47e3ee72f87e162f5/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2acceeac67a10df936fd59f47e3ee72f87e162f5/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=2acceeac67a10df936fd59f47e3ee72f87e162f5", "patch": "@@ -1,3 +1,9 @@\n+2008-05-25  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* include/std/complex: Trivial stylistic changes, define inline\n+\tmembers inline, consistently with the rest of the library.\n+\t(pow(const _Tp&, const complex<>&)): Minor tweak.\n+\n 2008-05-24  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* src/atomic.cc (atomic_flag_test_and_set_explicit,"}, {"sha": "947ab0ec9ef8498e57a9cbbd0b367ad757c7dc26", "filename": "libstdc++-v3/include/std/complex", "status": "modified", "additions": 341, "deletions": 456, "changes": 797, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2acceeac67a10df936fd59f47e3ee72f87e162f5/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcomplex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2acceeac67a10df936fd59f47e3ee72f87e162f5/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcomplex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcomplex?ref=2acceeac67a10df936fd59f47e3ee72f87e162f5", "patch": "@@ -121,29 +121,53 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       \n       ///  Default constructor.  First parameter is x, second parameter is y.\n       ///  Unspecified parameters default to 0.\n-      complex(const _Tp& = _Tp(), const _Tp & = _Tp());\n+      complex(const _Tp& __r = _Tp(), const _Tp& __i = _Tp())\n+      : _M_real(__r), _M_imag(__i) { }\n \n       // Lets the compiler synthesize the copy constructor   \n       // complex (const complex<_Tp>&);\n       ///  Copy constructor.\n       template<typename _Up>\n-        complex(const complex<_Up>&);\n+        complex(const complex<_Up>& __z)\n+\t: _M_real(__z.real()), _M_imag(__z.imag()) { }\n \n       ///  Return real part of complex number.\n-      _Tp& real(); \n+      _Tp& real()\n+      { return _M_real; }\n+\n       ///  Return real part of complex number.\n-      const _Tp& real() const;\n+      const _Tp& real() const\n+      { return _M_real; }\n+\n       ///  Return imaginary part of complex number.\n-      _Tp& imag();\n+      _Tp& imag()\n+      { return _M_imag; }\n+\n       ///  Return imaginary part of complex number.\n-      const _Tp& imag() const;\n+      const _Tp& imag() const\n+      { return _M_imag; }\n \n       /// Assign this complex number to scalar @a t.\n       complex<_Tp>& operator=(const _Tp&);\n+      \n       /// Add @a t to this complex number.\n-      complex<_Tp>& operator+=(const _Tp&);\n+      // 26.2.5/1\n+      complex<_Tp>&\n+      operator+=(const _Tp& __t)\n+      {\n+\t_M_real += __t;\n+\treturn *this;\n+      }\n+\n       /// Subtract @a t from this complex number.\n-      complex<_Tp>& operator-=(const _Tp&);\n+      // 26.2.5/3\n+      complex<_Tp>&\n+      operator-=(const _Tp& __t)\n+      {\n+\t_M_real -= __t;\n+\treturn *this;\n+      }\n+\n       /// Multiply this complex number by @a t.\n       complex<_Tp>& operator*=(const _Tp&);\n       /// Divide this complex number by @a t.\n@@ -168,40 +192,14 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       template<typename _Up>\n         complex<_Tp>& operator/=(const complex<_Up>&);\n \n-      const complex& __rep() const;\n+      const complex& __rep() const\n+      { return *this; }\n \n     private:\n       _Tp _M_real;\n       _Tp _M_imag;\n     };\n \n-  template<typename _Tp>\n-    inline _Tp&\n-    complex<_Tp>::real() { return _M_real; }\n-\n-  template<typename _Tp>\n-    inline const _Tp&\n-    complex<_Tp>::real() const { return _M_real; }\n-\n-  template<typename _Tp>\n-    inline _Tp&\n-    complex<_Tp>::imag() { return _M_imag; }\n-\n-  template<typename _Tp>\n-    inline const _Tp&\n-    complex<_Tp>::imag() const { return _M_imag; }\n-\n-  template<typename _Tp>\n-    inline \n-    complex<_Tp>::complex(const _Tp& __r, const _Tp& __i)\n-    : _M_real(__r), _M_imag(__i) { }\n-\n-  template<typename _Tp>\n-    template<typename _Up>\n-    inline \n-    complex<_Tp>::complex(const complex<_Up>& __z)\n-    : _M_real(__z.real()), _M_imag(__z.imag()) { }\n-        \n   template<typename _Tp>\n     complex<_Tp>&\n     complex<_Tp>::operator=(const _Tp& __t)\n@@ -211,24 +209,6 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n      return *this;\n     } \n \n-  // 26.2.5/1\n-  template<typename _Tp>\n-    inline complex<_Tp>&\n-    complex<_Tp>::operator+=(const _Tp& __t)\n-    {\n-      _M_real += __t;\n-      return *this;\n-    }\n-\n-  // 26.2.5/3\n-  template<typename _Tp>\n-    inline complex<_Tp>&\n-    complex<_Tp>::operator-=(const _Tp& __t)\n-    {\n-      _M_real -= __t;\n-      return *this;\n-    }\n-\n   // 26.2.5/5\n   template<typename _Tp>\n     complex<_Tp>&\n@@ -307,10 +287,6 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       _M_real = __r / __n;\n       return *this;\n     }\n-\n-  template<typename _Tp>\n-    inline const complex<_Tp>&\n-    complex<_Tp>::__rep() const { return *this; }\n     \n   // Operators:\n   //@{\n@@ -995,7 +971,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     {\n       return __x > _Tp() ? std::polar(pow(__x, __y.real()),\n \t\t\t\t      __y.imag() * log(__x))\n-\t                 : std::pow(complex<_Tp>(__x, _Tp()), __y);\n+\t                 : std::pow(complex<_Tp>(__x), __y);\n     }\n \n   // 26.2.3  complex specializations\n@@ -1008,150 +984,122 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n       complex(_ComplexT __z) : _M_value(__z) { }\n \n-      complex(float = 0.0f, float = 0.0f);\n+      complex(float __r = 0.0f, float __i = 0.0f)\n+      {\n+\t__real__ _M_value = __r;\n+\t__imag__ _M_value = __i;\n+      }\n \n       explicit complex(const complex<double>&);\n-      explicit complex(const complex<long double>&);\n-\n-      float& real();\n-      const float& real() const;\n-      float& imag();\n-      const float& imag() const;\n-\n-      complex<float>& operator=(float);\n-      complex<float>& operator+=(float);\n-      complex<float>& operator-=(float);\n-      complex<float>& operator*=(float);\n-      complex<float>& operator/=(float);\n+      explicit complex(const complex<long double>&);\t\n+\n+      float& real()\n+      { return __real__ _M_value; }\n+\n+      const float& real() const\n+      { return __real__ _M_value; }      \n+\n+      float& imag()\n+      { return __imag__ _M_value; }\n+\n+      const float& imag() const\n+      { return __imag__ _M_value; }\n+\n+      complex<float>&\n+      operator=(float __f)\n+      {\n+\t__real__ _M_value = __f;\n+\t__imag__ _M_value = 0.0f;\n+\treturn *this;\n+      }\n+\n+      complex<float>&\n+      operator+=(float __f)\n+      {\n+\t__real__ _M_value += __f;\n+\treturn *this;\n+      }\n+\n+      complex<float>&\n+      operator-=(float __f)\n+      {\n+\t__real__ _M_value -= __f;\n+\treturn *this;\n+      }\n+\n+      complex<float>&\n+      operator*=(float __f)\n+      {\n+\t_M_value *= __f;\n+\treturn *this;\n+      }\n+\n+      complex<float>&\n+      operator/=(float __f)\n+      {\n+\t_M_value /= __f;\n+\treturn *this;\n+      }\n \n       // Let the compiler synthesize the copy and assignment\n       // operator.  It always does a pretty good job.\n-      // complex& operator= (const complex&);\n+      // complex& operator=(const complex&);\n+\n       template<typename _Tp>\n-        complex<float>&operator=(const complex<_Tp>&);\n+        complex<float>&\n+        operator=(const complex<_Tp>&  __z)\n+\t{\n+\t  __real__ _M_value = __z.real();\n+\t  __imag__ _M_value = __z.imag();\n+\t  return *this;\n+\t}\n+\n       template<typename _Tp>\n-        complex<float>& operator+=(const complex<_Tp>&);\n+        complex<float>&\n+        operator+=(const complex<_Tp>& __z)\n+\t{\n+\t  __real__ _M_value += __z.real();\n+\t  __imag__ _M_value += __z.imag();\n+\t  return *this;\n+\t}\n+\n       template<class _Tp>\n-        complex<float>& operator-=(const complex<_Tp>&);\n+        complex<float>&\n+        operator-=(const complex<_Tp>& __z)\n+\t{\n+\t  __real__ _M_value -= __z.real();\n+\t  __imag__ _M_value -= __z.imag();\n+\t  return *this;\n+\t}\n+\n       template<class _Tp>\n-        complex<float>& operator*=(const complex<_Tp>&);\n+        complex<float>&\n+        operator*=(const complex<_Tp>& __z)\n+\t{\n+\t  _ComplexT __t;\n+\t  __real__ __t = __z.real();\n+\t  __imag__ __t = __z.imag();\n+\t  _M_value *= __t;\n+\t  return *this;\n+\t}\n+\n       template<class _Tp>\n-        complex<float>&operator/=(const complex<_Tp>&);\n+        complex<float>&\n+        operator/=(const complex<_Tp>& __z)\n+\t{\n+\t  _ComplexT __t;\n+\t  __real__ __t = __z.real();\n+\t  __imag__ __t = __z.imag();\n+\t  _M_value /= __t;\n+\t  return *this;\n+\t}\n \n       const _ComplexT& __rep() const { return _M_value; }\n \n     private:\n       _ComplexT _M_value;\n     };\n \n-  inline float&\n-  complex<float>::real()\n-  { return __real__ _M_value; }\n-\n-  inline const float&\n-  complex<float>::real() const\n-  { return __real__ _M_value; }\n-\n-  inline float&\n-  complex<float>::imag()\n-  { return __imag__ _M_value; }\n-\n-  inline const float&\n-  complex<float>::imag() const\n-  { return __imag__ _M_value; }\n-\n-  inline\n-  complex<float>::complex(float __r, float __i)\n-  {\n-    __real__ _M_value = __r;\n-    __imag__ _M_value = __i;\n-  }\n-\n-  inline complex<float>&\n-  complex<float>::operator=(float __f)\n-  {\n-    __real__ _M_value = __f;\n-    __imag__ _M_value = 0.0f;\n-    return *this;\n-  }\n-\n-  inline complex<float>&\n-  complex<float>::operator+=(float __f)\n-  {\n-    __real__ _M_value += __f;\n-    return *this;\n-  }\n-\n-  inline complex<float>&\n-  complex<float>::operator-=(float __f)\n-  {\n-    __real__ _M_value -= __f;\n-    return *this;\n-  }\n-\n-  inline complex<float>&\n-  complex<float>::operator*=(float __f)\n-  {\n-    _M_value *= __f;\n-    return *this;\n-  }\n-\n-  inline complex<float>&\n-  complex<float>::operator/=(float __f)\n-  {\n-    _M_value /= __f;\n-    return *this;\n-  }\n-\n-  template<typename _Tp>\n-  inline complex<float>&\n-  complex<float>::operator=(const complex<_Tp>& __z)\n-  {\n-    __real__ _M_value = __z.real();\n-    __imag__ _M_value = __z.imag();\n-    return *this;\n-  }\n-\n-  template<typename _Tp>\n-  inline complex<float>&\n-  complex<float>::operator+=(const complex<_Tp>& __z)\n-  {\n-    __real__ _M_value += __z.real();\n-    __imag__ _M_value += __z.imag();\n-    return *this;\n-  }\n-    \n-  template<typename _Tp>\n-    inline complex<float>&\n-    complex<float>::operator-=(const complex<_Tp>& __z)\n-    {\n-     __real__ _M_value -= __z.real();\n-     __imag__ _M_value -= __z.imag();\n-     return *this;\n-    } \n-\n-  template<typename _Tp>\n-    inline complex<float>&\n-    complex<float>::operator*=(const complex<_Tp>& __z)\n-    {\n-      _ComplexT __t;\n-      __real__ __t = __z.real();\n-      __imag__ __t = __z.imag();\n-      _M_value *= __t;\n-      return *this;\n-    }\n-\n-  template<typename _Tp>\n-    inline complex<float>&\n-    complex<float>::operator/=(const complex<_Tp>& __z)\n-    {\n-      _ComplexT __t;\n-      __real__ __t = __z.real();\n-      __imag__ __t = __z.imag();\n-      _M_value /= __t;\n-      return *this;\n-    }\n-\n   // 26.2.3  complex specializations\n   // complex<double> specialization\n   template<>\n@@ -1162,149 +1110,123 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n       complex(_ComplexT __z) : _M_value(__z) { }\n \n-      complex(double = 0.0, double = 0.0);\n-\n-      complex(const complex<float>&);\n-      explicit complex(const complex<long double>&);\n-\n-      double& real();\n-      const double& real() const;\n-      double& imag();\n-      const double& imag() const;\n-\n-      complex<double>& operator=(double);\n-      complex<double>& operator+=(double);\n-      complex<double>& operator-=(double);\n-      complex<double>& operator*=(double);\n-      complex<double>& operator/=(double);\n+      complex(double __r = 0.0, double __i = 0.0)\n+      {\n+\t__real__ _M_value = __r;\n+\t__imag__ _M_value = __i;\n+      }\n+\n+      complex(const complex<float>& __z)\n+      : _M_value(__z.__rep()) { }\n+\n+      explicit complex(const complex<long double>&);\t\n+\n+      double& real()\n+      { return __real__ _M_value; }\n+\n+      const double& real() const\n+      { return __real__ _M_value; }\n+\n+      double& imag()\n+      { return __imag__ _M_value; }\n+\n+      const double& imag() const\n+      { return __imag__ _M_value; }\n+\n+      complex<double>&\n+      operator=(double __d)\n+      {\n+\t__real__ _M_value = __d;\n+\t__imag__ _M_value = 0.0;\n+\treturn *this;\n+      }\n+\n+      complex<double>&\n+      operator+=(double __d)\n+      {\n+\t__real__ _M_value += __d;\n+\treturn *this;\n+      }\n+\t\n+      complex<double>&\n+      operator-=(double __d)\n+      {\n+\t__real__ _M_value -= __d;\n+\treturn *this;\n+      }\n+\n+      complex<double>&\n+      operator*=(double __d)\n+      {\n+\t_M_value *= __d;\n+\treturn *this;\n+      }\n+\n+      complex<double>&\n+      operator/=(double __d)\n+      {\n+\t_M_value /= __d;\n+\treturn *this;\n+      }\n \n       // The compiler will synthesize this, efficiently.\n-      // complex& operator= (const complex&);\n+      // complex& operator=(const complex&);\n+\n       template<typename _Tp>\n-        complex<double>& operator=(const complex<_Tp>&);\n+        complex<double>&\n+        operator=(const complex<_Tp>& __z)\n+\t{\n+\t  __real__ _M_value = __z.real();\n+\t  __imag__ _M_value = __z.imag();\n+\t  return *this;\n+\t}\n+\n       template<typename _Tp>\n-        complex<double>& operator+=(const complex<_Tp>&);\n+        complex<double>&\n+        operator+=(const complex<_Tp>& __z)\n+\t{\n+\t  __real__ _M_value += __z.real();\n+\t  __imag__ _M_value += __z.imag();\n+\t  return *this;\n+\t}\n+\n       template<typename _Tp>\n-        complex<double>& operator-=(const complex<_Tp>&);\n+        complex<double>&\n+        operator-=(const complex<_Tp>& __z)\n+\t{\n+\t  __real__ _M_value -= __z.real();\n+\t  __imag__ _M_value -= __z.imag();\n+\t  return *this;\n+\t}\n+\n       template<typename _Tp>\n-        complex<double>& operator*=(const complex<_Tp>&);\n+        complex<double>&\n+        operator*=(const complex<_Tp>& __z)\n+\t{\n+\t  _ComplexT __t;\n+\t  __real__ __t = __z.real();\n+\t  __imag__ __t = __z.imag();\n+\t  _M_value *= __t;\n+\t  return *this;\n+\t}\n+\n       template<typename _Tp>\n-        complex<double>& operator/=(const complex<_Tp>&);\n+        complex<double>&\n+        operator/=(const complex<_Tp>& __z)\n+\t{\n+\t  _ComplexT __t;\n+\t  __real__ __t = __z.real();\n+\t  __imag__ __t = __z.imag();\n+\t  _M_value /= __t;\n+\t  return *this;\n+\t}\n \n       const _ComplexT& __rep() const { return _M_value; }\n \n     private:\n       _ComplexT _M_value;\n     };\n \n-  inline double&\n-  complex<double>::real()\n-  { return __real__ _M_value; }\n-\n-  inline const double&\n-  complex<double>::real() const\n-  { return __real__ _M_value; }\n-\n-  inline double&\n-  complex<double>::imag()\n-  { return __imag__ _M_value; }\n-\n-  inline const double&\n-  complex<double>::imag() const\n-  { return __imag__ _M_value; }\n-\n-  inline\n-  complex<double>::complex(double __r, double __i)\n-  {\n-    __real__ _M_value = __r;\n-    __imag__ _M_value = __i;\n-  }\n-\n-  inline complex<double>&\n-  complex<double>::operator=(double __d)\n-  {\n-    __real__ _M_value = __d;\n-    __imag__ _M_value = 0.0;\n-    return *this;\n-  }\n-\n-  inline complex<double>&\n-  complex<double>::operator+=(double __d)\n-  {\n-    __real__ _M_value += __d;\n-    return *this;\n-  }\n-\n-  inline complex<double>&\n-  complex<double>::operator-=(double __d)\n-  {\n-    __real__ _M_value -= __d;\n-    return *this;\n-  }\n-\n-  inline complex<double>&\n-  complex<double>::operator*=(double __d)\n-  {\n-    _M_value *= __d;\n-    return *this;\n-  }\n-\n-  inline complex<double>&\n-  complex<double>::operator/=(double __d)\n-  {\n-    _M_value /= __d;\n-    return *this;\n-  }\n-\n-  template<typename _Tp>\n-    inline complex<double>&\n-    complex<double>::operator=(const complex<_Tp>& __z)\n-    {\n-      __real__ _M_value = __z.real();\n-      __imag__ _M_value = __z.imag();\n-      return *this;\n-    }\n-    \n-  template<typename _Tp>\n-    inline complex<double>&\n-    complex<double>::operator+=(const complex<_Tp>& __z)\n-    {\n-      __real__ _M_value += __z.real();\n-      __imag__ _M_value += __z.imag();\n-      return *this;\n-    }\n-\n-  template<typename _Tp>\n-    inline complex<double>&\n-    complex<double>::operator-=(const complex<_Tp>& __z)\n-    {\n-      __real__ _M_value -= __z.real();\n-      __imag__ _M_value -= __z.imag();\n-      return *this;\n-    }\n-\n-  template<typename _Tp>\n-    inline complex<double>&\n-    complex<double>::operator*=(const complex<_Tp>& __z)\n-    {\n-      _ComplexT __t;\n-      __real__ __t = __z.real();\n-      __imag__ __t = __z.imag();\n-      _M_value *= __t;\n-      return *this;\n-    }\n-\n-  template<typename _Tp>\n-    inline complex<double>&\n-    complex<double>::operator/=(const complex<_Tp>& __z)\n-    {\n-      _ComplexT __t;\n-      __real__ __t = __z.real();\n-      __imag__ __t = __z.imag();\n-      _M_value /= __t;\n-      return *this;\n-    }\n-\n   // 26.2.3  complex specializations\n   // complex<long double> specialization\n   template<>\n@@ -1315,149 +1237,124 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n       complex(_ComplexT __z) : _M_value(__z) { }\n \n-      complex(long double = 0.0L, long double = 0.0L);\n-\n-      complex(const complex<float>&);\n-      complex(const complex<double>&);\n-\n-      long double& real();\n-      const long double& real() const;\n-      long double& imag();\n-      const long double& imag() const;\n-\n-      complex<long double>& operator= (long double);\n-      complex<long double>& operator+= (long double);\n-      complex<long double>& operator-= (long double);\n-      complex<long double>& operator*= (long double);\n-      complex<long double>& operator/= (long double);\n+      complex(long double __r = 0.0L, long double __i = 0.0L)\n+      {\n+\t__real__ _M_value = __r;\n+\t__imag__ _M_value = __i;\n+      }\n+\n+      complex(const complex<float>& __z)\n+      : _M_value(__z.__rep()) { }\n+\n+      complex(const complex<double>& __z)\n+      : _M_value(__z.__rep()) { }\n+\n+      long double& real()\n+      { return __real__ _M_value; }\n+\n+      const long double& real() const\n+      { return __real__ _M_value; }\n+\n+      long double& imag()\n+      { return __imag__ _M_value; }\n+\n+      const long double& imag() const\n+      { return __imag__ _M_value; }\n+\n+      complex<long double>&\n+      operator=(long double __r)\n+      {\n+\t__real__ _M_value = __r;\n+\t__imag__ _M_value = 0.0L;\n+\treturn *this;\n+      }\n+\n+      complex<long double>&\n+      operator+=(long double __r)\n+      {\n+\t__real__ _M_value += __r;\n+\treturn *this;\n+      }\n+\n+      complex<long double>&\n+      operator-=(long double __r)\n+      {\n+\t__real__ _M_value -= __r;\n+\treturn *this;\n+      }\n+\n+      complex<long double>&\n+      operator*=(long double __r)\n+      {\n+\t_M_value *= __r;\n+\treturn *this;\n+      }\n+\n+      complex<long double>&\n+      operator/=(long double __r)\n+      {\n+\t_M_value /= __r;\n+\treturn *this;\n+      }\n \n       // The compiler knows how to do this efficiently\n-      // complex& operator= (const complex&);\n+      // complex& operator=(const complex&);\n+\n       template<typename _Tp>\n-        complex<long double>& operator=(const complex<_Tp>&);\n+        complex<long double>&\n+        operator=(const complex<_Tp>& __z)\n+\t{\n+\t  __real__ _M_value = __z.real();\n+\t  __imag__ _M_value = __z.imag();\n+\t  return *this;\n+\t}\n+\n       template<typename _Tp>\n-        complex<long double>& operator+=(const complex<_Tp>&);\n+        complex<long double>&\n+\toperator+=(const complex<_Tp>& __z)\n+\t{\n+\t  __real__ _M_value += __z.real();\n+\t  __imag__ _M_value += __z.imag();\n+\t  return *this;\n+\t}\n+\n       template<typename _Tp>\n-        complex<long double>& operator-=(const complex<_Tp>&);\n+        complex<long double>&\n+\toperator-=(const complex<_Tp>& __z)\n+\t{\n+\t  __real__ _M_value -= __z.real();\n+\t  __imag__ _M_value -= __z.imag();\n+\t  return *this;\n+\t}\n+\n       template<typename _Tp>\n-        complex<long double>& operator*=(const complex<_Tp>&);\n+        complex<long double>&\n+\toperator*=(const complex<_Tp>& __z)\n+\t{\n+\t  _ComplexT __t;\n+\t  __real__ __t = __z.real();\n+\t  __imag__ __t = __z.imag();\n+\t  _M_value *= __t;\n+\t  return *this;\n+\t}\n+\n       template<typename _Tp>\n-        complex<long double>& operator/=(const complex<_Tp>&);\n+        complex<long double>&\n+\toperator/=(const complex<_Tp>& __z)\n+\t{\n+\t  _ComplexT __t;\n+\t  __real__ __t = __z.real();\n+\t  __imag__ __t = __z.imag();\n+\t  _M_value /= __t;\n+\t  return *this;\n+\t}\n \n       const _ComplexT& __rep() const { return _M_value; }\n \n     private:\n       _ComplexT _M_value;\n     };\n \n-  inline\n-  complex<long double>::complex(long double __r, long double __i)\n-  {\n-    __real__ _M_value = __r;\n-    __imag__ _M_value = __i;\n-  }\n-\n-  inline long double&\n-  complex<long double>::real()\n-  { return __real__ _M_value; }\n-\n-  inline const long double&\n-  complex<long double>::real() const\n-  { return __real__ _M_value; }\n-\n-  inline long double&\n-  complex<long double>::imag()\n-  { return __imag__ _M_value; }\n-\n-  inline const long double&\n-  complex<long double>::imag() const\n-  { return __imag__ _M_value; }\n-\n-  inline complex<long double>&   \n-  complex<long double>::operator=(long double __r)\n-  {\n-    __real__ _M_value = __r;\n-    __imag__ _M_value = 0.0L;\n-    return *this;\n-  }\n-\n-  inline complex<long double>&\n-  complex<long double>::operator+=(long double __r)\n-  {\n-    __real__ _M_value += __r;\n-    return *this;\n-  }\n-\n-  inline complex<long double>&\n-  complex<long double>::operator-=(long double __r)\n-  {\n-    __real__ _M_value -= __r;\n-    return *this;\n-  }\n-\n-  inline complex<long double>&\n-  complex<long double>::operator*=(long double __r)\n-  {\n-    _M_value *= __r;\n-    return *this;\n-  }\n-\n-  inline complex<long double>&\n-  complex<long double>::operator/=(long double __r)\n-  {\n-    _M_value /= __r;\n-    return *this;\n-  }\n-\n-  template<typename _Tp>\n-    inline complex<long double>&\n-    complex<long double>::operator=(const complex<_Tp>& __z)\n-    {\n-      __real__ _M_value = __z.real();\n-      __imag__ _M_value = __z.imag();\n-      return *this;\n-    }\n-\n-  template<typename _Tp>\n-    inline complex<long double>&\n-    complex<long double>::operator+=(const complex<_Tp>& __z)\n-    {\n-      __real__ _M_value += __z.real();\n-      __imag__ _M_value += __z.imag();\n-      return *this;\n-    }\n-\n-  template<typename _Tp>\n-    inline complex<long double>&\n-    complex<long double>::operator-=(const complex<_Tp>& __z)\n-    {\n-      __real__ _M_value -= __z.real();\n-      __imag__ _M_value -= __z.imag();\n-      return *this;\n-    }\n-    \n-  template<typename _Tp>\n-    inline complex<long double>&\n-    complex<long double>::operator*=(const complex<_Tp>& __z)\n-    {\n-      _ComplexT __t;\n-      __real__ __t = __z.real();\n-      __imag__ __t = __z.imag();\n-      _M_value *= __t;\n-      return *this;\n-    }\n-\n-  template<typename _Tp>\n-    inline complex<long double>&\n-    complex<long double>::operator/=(const complex<_Tp>& __z)\n-    {\n-      _ComplexT __t;\n-      __real__ __t = __z.real();\n-      __imag__ __t = __z.imag();\n-      _M_value /= __t;\n-      return *this;\n-    }\n-\n   // These bits have to be at the end of this file, so that the\n   // specializations have all been defined.\n   // ??? No, they have to be there because of compiler limitation at\n@@ -1470,22 +1367,10 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n   complex<float>::complex(const complex<long double>& __z)\n   : _M_value(__z.__rep()) { }\n \n-  inline\n-  complex<double>::complex(const complex<float>& __z) \n-  : _M_value(__z.__rep()) { }\n-\n   inline\n   complex<double>::complex(const complex<long double>& __z)\n   : _M_value(__z.__rep()) { }\n \n-  inline\n-  complex<long double>::complex(const complex<float>& __z)\n-  : _M_value(__z.__rep()) { }\n-\n-  inline\n-  complex<long double>::complex(const complex<double>& __z)\n-  : _M_value(__z.__rep()) { }\n-\n   // Inhibit implicit instantiations for required instantiations,\n   // which are defined via explicit instantiations elsewhere.\n   // NB:  This syntax is a GNU extension."}]}