{"sha": "ea588d41f39428b0c3b02f016353dceb1aaaaa39", "node_id": "C_kwDOANBUbNoAKGVhNTg4ZDQxZjM5NDI4YjBjM2IwMmYwMTYzNTNkY2ViMWFhYWFhMzk", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-12-02T09:55:49Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2022-12-06T13:58:48Z"}, "message": "ada: Elide the copy in extended returns for nonlimited by-reference types\n\nThis implements elision of the copy operation for extended return statements\nin the case of nonlimited by-reference types (the copy operation is already\nelided for limited types by the front-end and nonlimited non-by-reference\ntypes by the code generator), which comprise controlled and tagged types.\n\nThe implementation partly reuses the machinery implemented for limited types\n(the build-in-place machinery) to allocate the return object directly on the\nprimary or the secondary stack, depending on whether the result type of the\nfunction is constrained or not.\n\nThis requires further special-casing for the allocators generated by this\nmachinery as well as an adjustment to the implementation of a specific case\nof string concatenation.\n\ngcc/ada/\n\n\t* einfo.ads (Actual_Subtype): Document additional usage.\n\t* exp_aggr.adb (Expand_Array_Aggregate): Replace test on\n\tIs_Build_In_Place_Return_Object with Is_Special_Return_Object.\n\t* exp_ch3.adb (Expand_N_Object_Declaration): Factor out parts of the\n\tprocessing done for build-in-place return objects and reuse them to\n\timplement a similar processing for specific return objects.\n\t* exp_ch4.adb (Expand_Allocator_Expression): Do not generate a tag\n\tassignment or an adjustment if the allocator was made for a special\n\treturn object.\n\t(Expand_Concatenate): If the result is allocated on the secondary\n\tstack, use an unconstrained allocation.\n\t* exp_ch6.ads (Apply_CW_Accessibility_Check): New declaration.\n\t(Is_By_Reference_Return_Object): Likewise.\n\t(Is_Secondary_Stack_Return_Object): Likewise.\n\t(Is_Special_Return_Object): Likewise.\n\t* exp_ch6.adb (Expand_Ctrl_Function_Call): Do not bail out for the\n\texpression in the declaration of a special return object.\n\t(Expand_N_Extended_Return_Statement): Add missing guard and move\n\tthe class-wide accessibility check to Expand_N_Object_Declaration.\n\t(Expand_Simple_Function_Return): Delete obsolete commentary.\n\tSkip the special processing for types that require finalization or\n\tare returned on the secondary stack if the return originally comes\n\tfrom an extended return statement.  Add missing Constant_Present.\n\t(Is_By_Reference_Return_Object): New predicate.\n\t(Is_Secondary_Stack_Return_Object): Likewise.\n\t(Is_Special_Return_Object): Likewise.\n\t* exp_util.adb (Is_Related_To_Func_Return): Also return true if the\n\tparent of the expression is the renaming declaration generated for\n\tthe expansion of a return object.\n\t* gen_il-fields.ads (Opt_Field_Enum): Replace Alloc_For_BIP_Return\n\twith For_Special_Return_Object.\n\t* gen_il-gen-gen_nodes.adb (N_Allocator): Likewise.\n\t* gen_il-internals.adb (Image): Remove Alloc_For_BIP_Return.\n\t* sem_ch3.adb (Check_Return_Subtype_Indication): New procedure\n\tmoved from sem_ch6.adb.\n\t(Analyze_Object_Declaration): Call it on a return object.\n\t* sem_ch4.adb: Add with and use clauses for Rtsfind.\n\t(Analyze_Allocator): Test For_Special_Return_Object to skip checks\n\tfor allocators made for special return objects.\n\tDo not report restriction violations for the return stack pool.\n\t* sem_ch5.adb (Analyze_Assignment.Set_Assignment_Type): Return the\n\tActual_Subtype for return objects that live on the secondary stack.\n\t* sem_ch6.adb (Check_Return_Subtype_Indication): Move procedure to\n\tsem_ch3.adb.\n\t(Analyze_Function_Return): Do not call above procedure.\n\t* sem_res.adb (Resolve_Allocator): Replace Alloc_For_BIP_Return\n\twith For_Special_Return_Object.\n\t* sinfo.ads: Likewise.\n\t* treepr.adb (Image): Remove Alloc_For_BIP_Return.\n\t* gcc-interface/trans.cc (gnat_to_gnu): Do not convert to the result\n\ttype in the unconstrained array type case if the parent is a simple\n\treturn statement.", "tree": {"sha": "ce91f5abdcd15583a7e4e5f4ed70e44022c10d07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce91f5abdcd15583a7e4e5f4ed70e44022c10d07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea588d41f39428b0c3b02f016353dceb1aaaaa39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea588d41f39428b0c3b02f016353dceb1aaaaa39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea588d41f39428b0c3b02f016353dceb1aaaaa39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea588d41f39428b0c3b02f016353dceb1aaaaa39/comments", "author": null, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a444c05623faa2b6bd1bbc8f7908b8ea3d83b475", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a444c05623faa2b6bd1bbc8f7908b8ea3d83b475", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a444c05623faa2b6bd1bbc8f7908b8ea3d83b475"}], "stats": {"total": 1117, "additions": 706, "deletions": 411}, "files": [{"sha": "d71dcaf8969fbb3290e6dca114b255ade0feefbf", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=ea588d41f39428b0c3b02f016353dceb1aaaaa39", "patch": "@@ -358,9 +358,11 @@ package Einfo is\n --\n --       For objects, the Actual_Subtype is set only if this is a discriminated\n --       type. For arrays, the bounds of the expression are obtained and the\n---       Etype of the object is directly the constrained subtype. This is\n---       rather irregular, and the semantic checks that depend on the nominal\n---       subtype being unconstrained use flag Is_Constr_Subt_For_U_Nominal(qv).\n+--       Etype of the object is directly the constrained subtype, except in the\n+--       case of a return object that lives on the secondary stack where Etype\n+--       is the nominal unconstrained subtype. This is rather irregular and the\n+--       semantic checks that depend on the nominal subtype being unconstrained\n+--       use flag Is_Constr_Subt_For_U_Nominal(qv).\n \n --    Address_Clause (synthesized)\n --       Applies to entries, objects and subprograms. Set if an address clause"}, {"sha": "4d8bb817b8010ef09830f2ddf98b32b7d8c17cd5", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=ea588d41f39428b0c3b02f016353dceb1aaaaa39", "patch": "@@ -6841,7 +6841,7 @@ package body Exp_Aggr is\n         or else Parent_Kind = N_Component_Association\n         or else (Parent_Kind = N_Object_Declaration\n                   and then (Needs_Finalization (Typ)\n-                             or else Is_Build_In_Place_Return_Object\n+                             or else Is_Special_Return_Object\n                                        (Defining_Identifier (Parent_Node))))\n         or else (Parent_Kind = N_Assignment_Statement\n                   and then Inside_Init_Proc)"}, {"sha": "6de5843b4ba45bb0401453b904fb6b4fdfd61ec3", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 349, "deletions": 119, "changes": 468, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=ea588d41f39428b0c3b02f016353dceb1aaaaa39", "patch": "@@ -6289,6 +6289,18 @@ package body Exp_Ch3 is\n       --  Generate all default initialization actions for object Def_Id. Any\n       --  new code is inserted after node After.\n \n+      procedure Initialize_Return_Object\n+        (Tag_Assign : Node_Id;\n+         Adj_Call   : Node_Id;\n+         Expr       : Node_Id;\n+         Init_Stmt  : Node_Id;\n+         After      : Node_Id);\n+      --  Generate all initialization actions for return object Def_Id. Any\n+      --  new code is inserted after node After.\n+\n+      function Make_Allocator_For_Return (Expr : Node_Id) return Node_Id;\n+      --  Make an allocator for a return object initialized with Expr\n+\n       function OK_To_Rename_Ref (N : Node_Id) return Boolean;\n       --  Return True if N denotes an entity with OK_To_Rename set\n \n@@ -7047,6 +7059,108 @@ package body Exp_Ch3 is\n          end if;\n       end Default_Initialize_Object;\n \n+      ------------------------------\n+      -- Initialize_Return_Object --\n+      ------------------------------\n+\n+      procedure Initialize_Return_Object\n+        (Tag_Assign : Node_Id;\n+         Adj_Call   : Node_Id;\n+         Expr       : Node_Id;\n+         Init_Stmt  : Node_Id;\n+         After      : Node_Id)\n+      is\n+      begin\n+         if Present (Tag_Assign) then\n+            Insert_Action_After (After, Tag_Assign);\n+         end if;\n+\n+         if Present (Adj_Call) then\n+            Insert_Action_After (After, Adj_Call);\n+         end if;\n+\n+         if No (Expr) then\n+            Default_Initialize_Object (After);\n+\n+         elsif Is_Delayed_Aggregate (Expr)\n+           and then not No_Initialization (N)\n+         then\n+            Convert_Aggr_In_Object_Decl (N);\n+\n+         elsif Present (Init_Stmt) then\n+            Insert_Action_After (After, Init_Stmt);\n+            Set_Expression (N, Empty);\n+         end if;\n+      end Initialize_Return_Object;\n+\n+      -------------------------------\n+      -- Make_Allocator_For_Return --\n+      -------------------------------\n+\n+      function Make_Allocator_For_Return (Expr : Node_Id) return Node_Id is\n+         Func_Id : constant Entity_Id := Return_Applies_To (Scope (Def_Id));\n+\n+         Alloc : Node_Id;\n+\n+      begin\n+         --  If the return object's declaration includes an expression and the\n+         --  declaration isn't marked as No_Initialization, then we generate an\n+         --  allocator with a qualified expression. Although this is necessary\n+         --  only in the case where the result type is an interface (or class-\n+         --  wide interface), we do it in all cases for the sake of consistency\n+         --  instead of subsequently generating a separate assignment.\n+\n+         if Present (Expr)\n+           and then not Is_Delayed_Aggregate (Expr)\n+           and then not No_Initialization (N)\n+         then\n+            --  Ada 2005 (AI95-344): If the result type is class-wide, insert\n+            --  a check that the level of the return expression's underlying\n+            --  type is not deeper than the level of the master enclosing the\n+            --  function.\n+\n+            --  AI12-043: The check is made immediately after the return object\n+            --  is created.\n+\n+            if Is_Class_Wide_Type (Etype (Func_Id)) then\n+               Apply_CW_Accessibility_Check (Expr, Func_Id);\n+            end if;\n+\n+            --  We always use the type of the expression for the qualified\n+            --  expression, rather than the return object's type. We cannot\n+            --  always use the return object's type because the expression\n+            --  might be of a specific type and the result object mignt not.\n+\n+            Alloc :=\n+              Make_Allocator (Loc,\n+                Expression =>\n+                  Make_Qualified_Expression (Loc,\n+                    Subtype_Mark =>\n+                      New_Occurrence_Of (Etype (Expr), Loc),\n+                    Expression   => New_Copy_Tree (Expr)));\n+\n+         else\n+            Alloc :=\n+              Make_Allocator (Loc,\n+                Expression => New_Occurrence_Of (Typ, Loc));\n+\n+            --  If the return object requires default initialization, then it\n+            --  will happen later following the elaboration of the renaming.\n+            --  If we don't turn it off here, then the object will be default\n+            --  initialized twice.\n+\n+            Set_No_Initialization (Alloc);\n+         end if;\n+\n+         --  Set the flag indicating that the allocator is made for a special\n+         --  return object. This is used to bypass various legality checks as\n+         --  well as to make sure that the result is not adjusted twice.\n+\n+         Set_For_Special_Return_Object (Alloc);\n+\n+         return Alloc;\n+      end Make_Allocator_For_Return;\n+\n       ----------------------\n       -- OK_To_Rename_Ref --\n       ----------------------\n@@ -7060,10 +7174,9 @@ package body Exp_Ch3 is\n \n       --  Local variables\n \n-      Adj_Call   : Node_Id;\n-      Expr_Q     : Node_Id;\n-      Id_Ref     : Node_Id;\n-      Tag_Assign : Node_Id;\n+      Adj_Call   : Node_Id := Empty;\n+      Expr_Q     : Node_Id := Empty;\n+      Tag_Assign : Node_Id := Empty;\n \n       Init_After : Node_Id := N;\n       --  Node after which the initialization actions are to be inserted. This\n@@ -7172,8 +7285,6 @@ package body Exp_Ch3 is\n       --  Default initialization required, and no expression present\n \n       if No (Expr) then\n-         Expr_Q := Expr;\n-\n          --  If we have a type with a variant part, the initialization proc\n          --  will contain implicit tests of the discriminant values, which\n          --  counts as a violation of the restriction No_Implicit_Conditionals.\n@@ -7232,7 +7343,7 @@ package body Exp_Ch3 is\n             end if;\n          end if;\n \n-         if not Is_Build_In_Place_Return_Object (Def_Id) then\n+         if not Is_Special_Return_Object (Def_Id) then\n             Default_Initialize_Object (Init_After);\n          end if;\n \n@@ -7292,7 +7403,7 @@ package body Exp_Ch3 is\n                Expander_Mode_Restore;\n             end if;\n \n-            if not Is_Build_In_Place_Return_Object (Def_Id) then\n+            if not Is_Special_Return_Object (Def_Id) then\n                Convert_Aggr_In_Object_Decl (N);\n             end if;\n \n@@ -7363,12 +7474,12 @@ package body Exp_Ch3 is\n          then\n             pragma Assert (Is_Class_Wide_Type (Typ));\n \n-            --  If the object is a built-in-place return object, bypass special\n+            --  If the object is a special return object, then bypass special\n             --  treatment of class-wide interface initialization below. In this\n             --  case, the expansion of the return statement will take care of\n             --  creating the object (via allocator) and initializing it.\n \n-            if Is_Build_In_Place_Return_Object (Def_Id) then\n+            if Is_Special_Return_Object (Def_Id) then\n                null;\n \n             elsif Tagged_Type_Expansion then\n@@ -7668,8 +7779,7 @@ package body Exp_Ch3 is\n             if Present (Tag_Assign) then\n                if Present (Following_Address_Clause (N)) then\n                   Ensure_Freeze_Node (Def_Id);\n-\n-               else\n+               elsif not Is_Special_Return_Object (Def_Id) then\n                   Insert_Action_After (Init_After, Tag_Assign);\n                end if;\n \n@@ -7679,23 +7789,26 @@ package body Exp_Ch3 is\n             --  record type.\n \n             elsif Is_CPP_Constructor_Call (Expr) then\n+               declare\n+                  Id_Ref : constant Node_Id := New_Occurrence_Of (Def_Id, Loc);\n \n-               --  The call to the initialization procedure does NOT freeze the\n-               --  object being initialized.\n+               begin\n+                  --  The call to the initialization procedure does NOT freeze\n+                  --  the object being initialized.\n \n-               Id_Ref := New_Occurrence_Of (Def_Id, Loc);\n-               Set_Must_Not_Freeze (Id_Ref);\n-               Set_Assignment_OK (Id_Ref);\n+                  Set_Must_Not_Freeze (Id_Ref);\n+                  Set_Assignment_OK (Id_Ref);\n \n-               Insert_Actions_After (Init_After,\n-                 Build_Initialization_Call (Loc, Id_Ref, Typ,\n-                   Constructor_Ref => Expr));\n+                  Insert_Actions_After (Init_After,\n+                    Build_Initialization_Call (Loc, Id_Ref, Typ,\n+                      Constructor_Ref => Expr));\n \n-               --  We remove here the original call to the constructor\n-               --  to avoid its management in the backend\n+                  --  We remove here the original call to the constructor\n+                  --  to avoid its management in the backend\n \n-               Set_Expression (N, Empty);\n-               return;\n+                  Set_Expression (N, Empty);\n+                  return;\n+               end;\n \n             --  Handle initialization of limited tagged types\n \n@@ -7735,18 +7848,15 @@ package body Exp_Ch3 is\n             then\n                Set_Is_Known_Valid (Def_Id);\n \n-            elsif Is_Access_Type (Typ) then\n-\n-               --  For access types set the Is_Known_Non_Null flag if the\n-               --  initializing value is known to be non-null. We can also set\n-               --  Can_Never_Be_Null if this is a constant.\n+            --  For access types, set the Is_Known_Non_Null flag if the\n+            --  initializing value is known to be non-null. We can also\n+            --  set Can_Never_Be_Null if this is a constant.\n \n-               if Known_Non_Null (Expr) then\n-                  Set_Is_Known_Non_Null (Def_Id, True);\n+            elsif Is_Access_Type (Typ) and then Known_Non_Null (Expr) then\n+               Set_Is_Known_Non_Null (Def_Id, True);\n \n-                  if Constant_Present (N) then\n-                     Set_Can_Never_Be_Null (Def_Id);\n-                  end if;\n+               if Constant_Present (N) then\n+                  Set_Can_Never_Be_Null (Def_Id);\n                end if;\n             end if;\n \n@@ -7762,6 +7872,7 @@ package body Exp_Ch3 is\n               and then not Is_Generic_Type (Typ)\n             then\n                Ensure_Valid (Expr);\n+\n                if Safe_To_Capture_Value (N, Def_Id) then\n                   Set_Is_Known_Valid (Def_Id);\n                end if;\n@@ -7839,10 +7950,9 @@ package body Exp_Ch3 is\n                    Obj_Ref => New_Occurrence_Of (Def_Id, Loc),\n                    Typ     => Base_Typ);\n \n-               --  Guard against a missing [Deep_]Adjust when the base type\n-               --  was not properly frozen.\n-\n-               if Present (Adj_Call) then\n+               if Present (Adj_Call)\n+                 and then not Is_Special_Return_Object (Def_Id)\n+               then\n                   Insert_Action_After (Init_After, Adj_Call);\n                end if;\n             end if;\n@@ -8092,78 +8202,12 @@ package body Exp_Ch3 is\n                   --  an unconstrained array on the heap. In this case the\n                   --  result object's type is a constrained array type even\n                   --  though the function's type is unconstrained.\n+\n                   Obj_Alloc_Formal : constant Entity_Id :=\n                     Build_In_Place_Formal (Func_Id, BIP_Alloc_Form);\n                   Pool_Id          : constant Entity_Id :=\n                     Make_Temporary (Loc, 'P');\n \n-                  function Make_Allocator_For_BIP_Return return Node_Id;\n-                  --  Make an allocator for the BIP return being processed\n-\n-                  -----------------------------------\n-                  -- Make_Allocator_For_BIP_Return --\n-                  -----------------------------------\n-\n-                  function Make_Allocator_For_BIP_Return return Node_Id is\n-                     Alloc : Node_Id;\n-\n-                  begin\n-                     if Present (Expr_Q)\n-                       and then not Is_Delayed_Aggregate (Expr_Q)\n-                       and then not No_Initialization (N)\n-                     then\n-                        --  Always use the type of the expression for the\n-                        --  qualified expression, rather than the result type.\n-                        --  In general we cannot always use the result type\n-                        --  for the allocator, because the expression might be\n-                        --  of a specific type, such as in the case of an\n-                        --  aggregate or even a nonlimited object when the\n-                        --  result type is a limited class-wide interface type.\n-\n-                        Alloc :=\n-                          Make_Allocator (Loc,\n-                            Expression =>\n-                              Make_Qualified_Expression (Loc,\n-                                Subtype_Mark =>\n-                                  New_Occurrence_Of (Etype (Expr_Q), Loc),\n-                                Expression   => New_Copy_Tree (Expr_Q)));\n-\n-                     else\n-                        --  If the function returns a class-wide type we cannot\n-                        --  use the return type for the allocator. Instead we\n-                        --  use the type of the expression, which must be an\n-                        --  aggregate of a definite type.\n-\n-                        if Is_Class_Wide_Type (Typ) then\n-                           Alloc :=\n-                             Make_Allocator (Loc,\n-                               Expression =>\n-                                 New_Occurrence_Of (Etype (Expr_Q), Loc));\n-\n-                        else\n-                           Alloc :=\n-                             Make_Allocator (Loc,\n-                               Expression =>\n-                                 New_Occurrence_Of (Typ, Loc));\n-                        end if;\n-\n-                        --  If the object requires default initialization then\n-                        --  that will happen later following the elaboration of\n-                        --  the object renaming. If we don't turn it off here\n-                        --  then the object will be default initialized twice.\n-\n-                        Set_No_Initialization (Alloc);\n-                     end if;\n-\n-                     --  Set the flag indicating that the allocator came from\n-                     --  a build-in-place return statement, so we can avoid\n-                     --  adjusting the allocated object.\n-\n-                     Set_Alloc_For_BIP_Return (Alloc);\n-\n-                     return Alloc;\n-                  end Make_Allocator_For_BIP_Return;\n-\n                   Acc_Typ        : Entity_Id;\n                   Alloc_Obj_Decl : Node_Id;\n                   Alloc_Obj_Id   : Entity_Id;\n@@ -8209,13 +8253,13 @@ package body Exp_Ch3 is\n \n                   --  First create the Heap_Allocator\n \n-                  Heap_Allocator := Make_Allocator_For_BIP_Return;\n+                  Heap_Allocator := Make_Allocator_For_Return (Expr_Q);\n \n                   --  The Pool_Allocator is just like the Heap_Allocator,\n                   --  except we set Storage_Pool and Procedure_To_Call so\n                   --  it will use the user-defined storage pool.\n \n-                  Pool_Allocator := Make_Allocator_For_BIP_Return;\n+                  Pool_Allocator := Make_Allocator_For_Return (Expr_Q);\n \n                   --  Do not generate the renaming of the build-in-place\n                   --  pool parameter on ZFP because the parameter is not\n@@ -8256,7 +8300,7 @@ package body Exp_Ch3 is\n                   --  allocation.\n \n                   else\n-                     SS_Allocator := Make_Allocator_For_BIP_Return;\n+                     SS_Allocator := Make_Allocator_For_Return (Expr_Q);\n \n                      --  The heap and pool allocators are marked as\n                      --  Comes_From_Source since they correspond to an\n@@ -8427,7 +8471,10 @@ package body Exp_Ch3 is\n                   --  From now on, the type of the return object is the\n                   --  designated type.\n \n-                  Set_Etype (Def_Id, Desig_Typ);\n+                  if Desig_Typ /= Typ then\n+                     Set_Etype (Def_Id, Desig_Typ);\n+                     Set_Actual_Subtype (Def_Id, Typ);\n+                  end if;\n \n                   --  Remember the local access object for use in the\n                   --  dereference of the renaming created below.\n@@ -8474,6 +8521,7 @@ package body Exp_Ch3 is\n                   Alloc_Obj_Decl :=\n                     Make_Object_Declaration (Loc,\n                       Defining_Identifier => Alloc_Obj_Id,\n+                      Constant_Present    => True,\n                       Object_Definition   =>\n                         New_Occurrence_Of (Acc_Typ, Loc),\n                       Expression =>\n@@ -8492,25 +8540,207 @@ package body Exp_Ch3 is\n             --  Initialize the object now that it has got its final subtype,\n             --  but before rewriting it as a renaming.\n \n-            if No (Expr_Q) then\n-               Default_Initialize_Object (Init_After);\n+            Initialize_Return_Object\n+              (Tag_Assign, Adj_Call, Expr_Q, Init_Stmt, Init_After);\n \n-            elsif Is_Delayed_Aggregate (Expr_Q)\n-              and then not No_Initialization (N)\n-            then\n-               Convert_Aggr_In_Object_Decl (N);\n+            --  Replace the return object declaration with a renaming of a\n+            --  dereference of the access value designating the return object.\n \n-            elsif Present (Init_Stmt) then\n-               Insert_Action_After (Init_After, Init_Stmt);\n-               Set_Expression (N, Empty);\n+            Expr_Q :=\n+              Make_Explicit_Dereference (Loc,\n+                Prefix => New_Occurrence_Of (Obj_Acc_Formal, Loc));\n+            Set_Etype (Expr_Q, Etype (Def_Id));\n+\n+            Rewrite_As_Renaming := True;\n+         end;\n+\n+      --  If we can rename the initialization expression, we need to make sure\n+      --  that we use the proper type in the case of a return object that lives\n+      --  on the secondary stack. See other cases below for a similar handling.\n+\n+      elsif Rewrite_As_Renaming then\n+         if Is_Secondary_Stack_Return_Object (Def_Id) then\n+            declare\n+               Func_Id  : constant Entity_Id  :=\n+                 Return_Applies_To (Scope (Def_Id));\n+\n+               Desig_Typ : constant Entity_Id :=\n+                 (if Ekind (Typ) = E_Array_Subtype\n+                  then Etype (Func_Id) else Typ);\n+\n+            begin\n+               --  From now on, the type of the return object is the\n+               --  designated type.\n+\n+               if Desig_Typ /= Typ then\n+                  Set_Etype (Def_Id, Desig_Typ);\n+                  Set_Actual_Subtype (Def_Id, Typ);\n+               end if;\n+            end;\n+         end if;\n+\n+      --  If this is the return object of a function returning on the secondary\n+      --  stack, convert the declaration to a renaming of the dereference of ah\n+      --  allocator for the secondary stack.\n+\n+      --    Result : T [:= <expression>];\n+\n+      --  is converted to\n+\n+      --    type Txx is access all ...;\n+      --    Rxx : constant Txx :=\n+      --      new <expression-type>['(<expression>)][storage_pool =\n+      --        system__secondary_stack__ss_pool][procedure_to_call =\n+      --        system__secondary_stack__ss_allocate];\n+\n+      --    Result : T renames Rxx.all;\n+\n+      elsif Is_Secondary_Stack_Return_Object (Def_Id) then\n+         declare\n+            Func_Id  : constant Entity_Id  :=\n+              Return_Applies_To (Scope (Def_Id));\n+\n+            Desig_Typ : constant Entity_Id :=\n+              (if Ekind (Typ) = E_Array_Subtype\n+               then Etype (Func_Id) else Typ);\n+            --  Ensure that the we use a fat pointer when allocating\n+            --  an unconstrained array on the heap. In this case the\n+            --  result object's type is a constrained array type even\n+            --  though the function's type is unconstrained.\n+\n+            Acc_Typ        : Entity_Id;\n+            Alloc_Obj_Decl : Node_Id;\n+            Alloc_Obj_Id   : Entity_Id;\n+            Ptr_Type_Decl  : Node_Id;\n+\n+         begin\n+            --  Create an access type designating the function's\n+            --  result subtype.\n+\n+            Acc_Typ := Make_Temporary (Loc, 'A');\n+\n+            Ptr_Type_Decl :=\n+              Make_Full_Type_Declaration (Loc,\n+                Defining_Identifier => Acc_Typ,\n+                Type_Definition     =>\n+                  Make_Access_To_Object_Definition (Loc,\n+                    All_Present        => True,\n+                    Subtype_Indication =>\n+                      New_Occurrence_Of (Desig_Typ, Loc)));\n+\n+            Insert_Action (N, Ptr_Type_Decl, Suppress => All_Checks);\n+\n+            Set_Associated_Storage_Pool (Acc_Typ, RTE (RE_SS_Pool));\n+\n+            Alloc_Obj_Id := Make_Temporary (Loc, 'R');\n+\n+            Alloc_Obj_Decl :=\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Alloc_Obj_Id,\n+                Constant_Present    => True,\n+                Object_Definition   =>\n+                  New_Occurrence_Of (Acc_Typ, Loc),\n+                Expression => Make_Allocator_For_Return (Expr_Q));\n+\n+            Insert_Action (N, Alloc_Obj_Decl, Suppress => All_Checks);\n+\n+            Set_Uses_Sec_Stack (Func_Id);\n+            Set_Uses_Sec_Stack (Scope (Def_Id));\n+            Set_Sec_Stack_Needed_For_Return (Scope (Def_Id));\n+\n+            --  From now on, the type of the return object is the\n+            --  designated type.\n+\n+            if Desig_Typ /= Typ then\n+               Set_Etype (Def_Id, Desig_Typ);\n+               Set_Actual_Subtype (Def_Id, Typ);\n             end if;\n \n+            --  Initialize the object now that it has got its final subtype,\n+            --  but before rewriting it as a renaming.\n+\n+            Initialize_Return_Object\n+              (Tag_Assign, Adj_Call, Expr_Q, Empty, Init_After);\n+\n             --  Replace the return object declaration with a renaming of a\n             --  dereference of the access value designating the return object.\n \n             Expr_Q :=\n               Make_Explicit_Dereference (Loc,\n-                Prefix => New_Occurrence_Of (Obj_Acc_Formal, Loc));\n+                Prefix => New_Occurrence_Of (Alloc_Obj_Id, Loc));\n+            Set_Etype (Expr_Q, Etype (Def_Id));\n+\n+            Rewrite_As_Renaming := True;\n+         end;\n+\n+      --  If this is the return object of a function returning a by-reference\n+      --  type, convert the declaration to a renaming of the dereference of ah\n+      --  allocator for the return stack.\n+\n+      --    Result : T [:= <expression>];\n+\n+      --  is converted to\n+\n+      --    type Txx is access all ...;\n+      --    Rxx : constant Txx :=\n+      --      new <expression-type>['(<expression>)][storage_pool =\n+      --        system__secondary_stack__rs_pool][procedure_to_call =\n+      --        system__secondary_stack__rs_allocate];\n+\n+      --    Result : T renames Rxx.all;\n+\n+      elsif Back_End_Return_Slot\n+        and then Is_By_Reference_Return_Object (Def_Id)\n+      then\n+         declare\n+            Acc_Typ        : Entity_Id;\n+            Alloc_Obj_Decl : Node_Id;\n+            Alloc_Obj_Id   : Entity_Id;\n+            Ptr_Type_Decl  : Node_Id;\n+\n+         begin\n+            --  Create an access type designating the function's\n+            --  result subtype.\n+\n+            Acc_Typ := Make_Temporary (Loc, 'A');\n+\n+            Ptr_Type_Decl :=\n+              Make_Full_Type_Declaration (Loc,\n+                Defining_Identifier => Acc_Typ,\n+                Type_Definition     =>\n+                  Make_Access_To_Object_Definition (Loc,\n+                    All_Present        => True,\n+                    Subtype_Indication =>\n+                      New_Occurrence_Of (Typ, Loc)));\n+\n+            Insert_Action (N, Ptr_Type_Decl, Suppress => All_Checks);\n+\n+            Set_Associated_Storage_Pool (Acc_Typ, RTE (RE_RS_Pool));\n+\n+            Alloc_Obj_Id := Make_Temporary (Loc, 'R');\n+\n+            Alloc_Obj_Decl :=\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Alloc_Obj_Id,\n+                Constant_Present    => True,\n+                Object_Definition   =>\n+                  New_Occurrence_Of (Acc_Typ, Loc),\n+                Expression => Make_Allocator_For_Return (Expr_Q));\n+\n+            Insert_Action (N, Alloc_Obj_Decl, Suppress => All_Checks);\n+\n+            --  Initialize the object now that it has got its final subtype,\n+            --  but before rewriting it as a renaming.\n+\n+            Initialize_Return_Object\n+              (Tag_Assign, Adj_Call, Expr_Q, Empty, Init_After);\n+\n+            --  Replace the return object declaration with a renaming of a\n+            --  dereference of the access value designating the return object.\n+\n+            Expr_Q :=\n+              Make_Explicit_Dereference (Loc,\n+                Prefix => New_Occurrence_Of (Alloc_Obj_Id, Loc));\n             Set_Etype (Expr_Q, Etype (Def_Id));\n \n             Rewrite_As_Renaming := True;"}, {"sha": "a8980a63d465a3335d8aad9b6454093a811fec8a", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 73, "deletions": 53, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=ea588d41f39428b0c3b02f016353dceb1aaaaa39", "patch": "@@ -898,6 +898,11 @@ package body Exp_Ch4 is\n                             (Directly_Designated_Type (Etype (N))));\n             null;\n \n+         --  Likewise if the allocator is made for a special return object\n+\n+         elsif For_Special_Return_Object (N) then\n+            null;\n+\n          elsif Is_Tagged_Type (T) and then not Is_Class_Wide_Type (T) then\n             TagT := T;\n             TagR :=\n@@ -946,19 +951,18 @@ package body Exp_Ch4 is\n          --  Adjust procedure, and the object is built in place. In Ada 95, the\n          --  object can be limited but not inherently limited if this allocator\n          --  came from a return statement (we're allocating the result on the\n-         --  secondary stack). In that case, the object will be moved, so we do\n-         --  want to Adjust. However, if it's a nonlimited build-in-place\n-         --  function call, Adjust is not wanted.\n-         --\n-         --  Needs_Finalization (DesigT) can differ from Needs_Finalization (T)\n+         --  secondary stack); in that case, the object will be moved, so we do\n+         --  want to Adjust. But the call is always skipped if the allocator is\n+         --  made for a special return object because it's generated elsewhere.\n+\n+         --  Needs_Finalization (DesigT) may differ from Needs_Finalization (T)\n          --  if one of the two types is class-wide, and the other is not.\n \n          if Needs_Finalization (DesigT)\n            and then Needs_Finalization (T)\n            and then not Aggr_In_Place\n            and then not Is_Limited_View (T)\n-           and then not Alloc_For_BIP_Return (N)\n-           and then not Is_Build_In_Place_Function_Call (Expression (N))\n+           and then not For_Special_Return_Object (N)\n          then\n             --  An unchecked conversion is needed in the classwide case because\n             --  the designated type can be an ancestor of the subtype mark of\n@@ -2724,6 +2728,7 @@ package body Exp_Ch4 is\n       Len        : Unat;\n       J          : Nat;\n       Clen       : Node_Id;\n+      Decl       : Node_Id;\n       Set        : Boolean;\n \n    --  Start of processing for Expand_Concatenate\n@@ -3250,10 +3255,32 @@ package body Exp_Ch4 is\n       Set_Is_Internal       (Ent);\n       Set_Debug_Info_Needed (Ent);\n \n+      --  If the bound is statically known to be out of range, we do not want\n+      --  to abort, we want a warning and a constraint error at run time. Note\n+      --  that we have arranged that the result will not be treated as a static\n+      --  constant, so we won't get an illegality during the insertion. We also\n+      --  enable all checks (in particular range checks) in case the bounds of\n+      --  Subtyp_Ind are out of range.\n+\n+      Decl :=\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Ent,\n+          Object_Definition   => Subtyp_Ind);\n+      Insert_Action (Cnode, Decl);\n+\n+      --  If the result of the concatenation appears as the initializing\n+      --  expression of an object declaration, we can just rename the\n+      --  result, rather than copying it.\n+\n+      Set_OK_To_Rename (Ent);\n+\n       --  If we are concatenating strings and the current scope already uses\n-      --  the secondary stack, allocate the resulting string also on the\n-      --  secondary stack to avoid putting too much pressure on the primary\n-      --  stack.\n+      --  the secondary stack, allocate the result also on the secondary stack\n+      --  to avoid putting too much pressure on the primary stack.\n+\n+      --  We use an unconstrained allocation, i.e. we also allocate the bounds,\n+      --  so that the result can be renamed in all contexts.\n+\n       --  Don't do this if -gnatd.h is set, as this will break the wrapping of\n       --  Cnode in an Expression_With_Actions, see Expand_N_Op_Concat.\n \n@@ -3263,84 +3290,77 @@ package body Exp_Ch4 is\n         and then not Debug_Flag_Dot_H\n       then\n          --  Generate:\n-         --     subtype Axx is ...;\n-         --     type Ayy is access Axx;\n-         --     Rxx : Ayy := new <subtype> [storage_pool = ss_pool];\n-         --     Sxx : <subtype> renames Rxx.all;\n+         --     subtype Axx is String (<low-bound> .. <high-bound>)\n+         --     type Ayy is access String;\n+         --     Rxx : Ayy := new <Axx> [storage_pool = ss_pool];\n+         --     Sxx : String renames Rxx.all;\n \n          declare\n-            Alloc   : Node_Id;\n             ConstrT : constant Entity_Id := Make_Temporary (Loc, 'A');\n             Acc_Typ : constant Entity_Id := Make_Temporary (Loc, 'A');\n+\n+            Alloc   : Node_Id;\n+            Deref   : Node_Id;\n             Temp    : Entity_Id;\n \n          begin\n-            Insert_Action (Cnode,\n+            Insert_Action (Decl,\n               Make_Subtype_Declaration (Loc,\n                 Defining_Identifier => ConstrT,\n                 Subtype_Indication  => Subtyp_Ind),\n               Suppress => All_Checks);\n-            Freeze_Itype (ConstrT, Cnode);\n \n-            Insert_Action (Cnode,\n+            Freeze_Itype (ConstrT, Decl);\n+\n+            Insert_Action (Decl,\n               Make_Full_Type_Declaration (Loc,\n                 Defining_Identifier => Acc_Typ,\n                 Type_Definition     =>\n                   Make_Access_To_Object_Definition (Loc,\n-                    Subtype_Indication => New_Occurrence_Of (ConstrT, Loc))),\n+                    Subtype_Indication => New_Occurrence_Of (Atyp, Loc))),\n               Suppress => All_Checks);\n+\n+            Mutate_Ekind (Acc_Typ, E_Access_Type);\n+            Set_Associated_Storage_Pool (Acc_Typ, RTE (RE_SS_Pool));\n+\n             Alloc :=\n               Make_Allocator (Loc,\n                 Expression => New_Occurrence_Of (ConstrT, Loc));\n \n-            --  Allocate on the secondary stack. This is currently done\n-            --  only for type String, which normally doesn't have default\n-            --  initialization, but we need to Set_No_Initialization in case\n-            --  of Initialize_Scalars or Normalize_Scalars; otherwise, the\n-            --  allocator will get transformed and will not use the secondary\n-            --  stack.\n+            --  This is currently done only for type String, which normally\n+            --  doesn't have default initialization, but we need to set the\n+            --  No_Initialization flag in case of either Initialize_Scalars\n+            --  or Normalize_Scalars.\n \n-            Set_Storage_Pool (Alloc, RTE (RE_SS_Pool));\n-            Set_Procedure_To_Call (Alloc, RTE (RE_SS_Allocate));\n             Set_No_Initialization (Alloc);\n \n             Temp := Make_Temporary (Loc, 'R', Alloc);\n-            Insert_Action (Cnode,\n+            Insert_Action (Decl,\n               Make_Object_Declaration (Loc,\n                 Defining_Identifier => Temp,\n                 Object_Definition   => New_Occurrence_Of (Acc_Typ, Loc),\n                 Expression          => Alloc),\n               Suppress => All_Checks);\n \n-            Insert_Action (Cnode,\n+            Deref :=\n+              Make_Explicit_Dereference (Loc,\n+                Prefix => New_Occurrence_Of (Temp, Loc));\n+            Set_Etype (Deref, Atyp);\n+\n+            Rewrite (Decl,\n               Make_Object_Renaming_Declaration (Loc,\n                 Defining_Identifier => Ent,\n-                Subtype_Mark        => New_Occurrence_Of (ConstrT, Loc),\n-                Name                =>\n-                  Make_Explicit_Dereference (Loc,\n-                    Prefix => New_Occurrence_Of (Temp, Loc))),\n-              Suppress => All_Checks);\n-         end;\n-      else\n-         --  If the bound is statically known to be out of range, we do not\n-         --  want to abort, we want a warning and a runtime constraint error.\n-         --  Note that we have arranged that the result will not be treated as\n-         --  a static constant, so we won't get an illegality during this\n-         --  insertion.\n-         --  We also enable checks (in particular range checks) in case the\n-         --  bounds of Subtyp_Ind are out of range.\n-\n-         Insert_Action (Cnode,\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Ent,\n-             Object_Definition   => Subtyp_Ind));\n-      end if;\n+                Subtype_Mark        => New_Occurrence_Of (Atyp, Loc),\n+                Name                => Deref));\n \n-      --  If the result of the concatenation appears as the initializing\n-      --  expression of an object declaration, we can just rename the\n-      --  result, rather than copying it.\n+            --  We do not analyze this renaming declaration because this would\n+            --  change the subtype of Ent back to a constrained string.\n \n-      Set_OK_To_Rename (Ent);\n+            Set_Etype (Ent, Atyp);\n+            Set_Renamed_Object (Ent, Deref);\n+            Set_Analyzed (Decl);\n+         end;\n+      end if;\n \n       --  Catch the static out of range case now\n "}, {"sha": "7555bf5dcf5b21f432736d113b4c288a623c331c", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 57, "deletions": 44, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=ea588d41f39428b0c3b02f016353dceb1aaaaa39", "patch": "@@ -192,16 +192,6 @@ package body Exp_Ch6 is\n    --  the activation Chain. Note: Master_Actual can be Empty, but only if\n    --  there are no tasks.\n \n-   procedure Apply_CW_Accessibility_Check (Exp : Node_Id; Func : Entity_Id);\n-   --  Ada 2005 (AI95-344): If the result type is class-wide, insert a check\n-   --  that the level of the return expression's underlying type is not deeper\n-   --  than the level of the master enclosing the function. Always generate the\n-   --  check when the type of the return expression is class-wide, when it's a\n-   --  type conversion, or when it's a formal parameter. Otherwise suppress the\n-   --  check in the case where the return expression has a specific type whose\n-   --  level is known not to be statically deeper than the result type of the\n-   --  function.\n-\n    function Caller_Known_Size\n      (Func_Call   : Node_Id;\n       Result_Subt : Entity_Id) return Boolean;\n@@ -5140,10 +5130,15 @@ package body Exp_Ch6 is\n       end if;\n \n       --  Another optimization: if the returned value is used to initialize an\n-      --  object, and the secondary stack is not involved in the call, then no\n-      --  need to copy/readjust/finalize, we can just initialize it in place.\n-\n-      if Nkind (Par) = N_Object_Declaration and then not Use_Sec_Stack then\n+      --  object, then no need to copy/readjust/finalize, we can initialize it\n+      --  in place. However, if the call returns on the secondary stack or this\n+      --  is a special return object, then we need the expansion because we'll\n+      --  be renaming the temporary as the (permanent) object.\n+\n+      if Nkind (Par) = N_Object_Declaration\n+        and then not Use_Sec_Stack\n+        and then not Is_Special_Return_Object (Defining_Entity (Par))\n+      then\n          return;\n       end if;\n \n@@ -5300,24 +5295,14 @@ package body Exp_Ch6 is\n          --  Assert that if F says \"return R : T := G(...) do...\"\n          --  then F and G are both b-i-p, or neither b-i-p.\n \n-         if Nkind (Exp) = N_Function_Call then\n+         if Present (Exp) and then Nkind (Exp) = N_Function_Call then\n             pragma Assert (Ekind (Current_Subprogram) = E_Function);\n             pragma Assert\n               (Is_Build_In_Place_Function (Current_Subprogram) =\n                Is_Build_In_Place_Function_Call (Exp));\n             null;\n          end if;\n \n-         --  Ada 2005 (AI95-344): If the result type is class-wide, then insert\n-         --  a check that the level of the return expression's underlying type\n-         --  is not deeper than the level of the master enclosing the function.\n-\n-         --  AI12-043: The check is made immediately after the return object\n-         --  is created.\n-\n-         if Present (Exp) and then Is_Class_Wide_Type (Ret_Typ) then\n-            Apply_CW_Accessibility_Check (Exp, Func_Id);\n-         end if;\n       else\n          Exp := Empty;\n       end if;\n@@ -6529,19 +6514,6 @@ package body Exp_Ch6 is\n       --  need to reify the return object, so we can build it \"in place\", and\n       --  we need a block statement to hang finalization and tasking stuff.\n \n-      --  ??? In order to avoid disruption, we avoid translating to extended\n-      --  return except in the cases where we really need to (Ada 2005 for\n-      --  inherently limited). We might prefer to do this translation in all\n-      --  cases (except perhaps for the case of Ada 95 inherently limited),\n-      --  in order to fully exercise the Expand_N_Extended_Return_Statement\n-      --  code. This would also allow us to do the build-in-place optimization\n-      --  for efficiency even in cases where it is semantically not required.\n-\n-      --  As before, we check the type of the return expression rather than the\n-      --  return type of the function, because the latter may be a limited\n-      --  class-wide interface type, which is not a limited type, even though\n-      --  the type of the expression may be.\n-\n       pragma Assert\n         (Comes_From_Extended_Return_Statement (N)\n           or else not Is_Build_In_Place_Function_Call (Exp)\n@@ -6682,15 +6654,18 @@ package body Exp_Ch6 is\n \n          --    type Ann is access R_Type;\n          --    for Ann'Storage_pool use rs_pool;\n-         --    Rnn : Ann := new Exp_Typ'(Exp);\n+         --    Rnn : constant Ann := new Exp_Typ'(Exp);\n          --    return Rnn.all;\n \n          --  but optimize the case where the result is a function call that\n          --  also needs finalization. In this case the result can directly be\n          --  allocated on the return stack of the caller and no further\n-         --  processing is required.\n+         --  processing is required. Likewise if this is a return object.\n \n-         if Present (Utyp)\n+         if Comes_From_Extended_Return_Statement (N) then\n+            null;\n+\n+         elsif Present (Utyp)\n            and then Needs_Finalization (Utyp)\n            and then not (Exp_Is_Function_Call\n                           and then Needs_Finalization (Exp_Typ))\n@@ -6733,6 +6708,7 @@ package body Exp_Ch6 is\n \n                  Make_Object_Declaration (Loc,\n                    Defining_Identifier => Temp,\n+                   Constant_Present    => True,\n                    Object_Definition   => New_Occurrence_Of (Acc_Typ, Loc),\n                    Expression          => Alloc_Node)));\n \n@@ -6753,11 +6729,16 @@ package body Exp_Ch6 is\n \n          Set_Enclosing_Sec_Stack_Return (N);\n \n+         --  Nothing else to do for a return object\n+\n+         if Comes_From_Extended_Return_Statement (N) then\n+            null;\n+\n          --  Optimize the case where the result is a function call that also\n          --  returns on the secondary stack. In this case the result is already\n          --  on the secondary stack and no further processing is required.\n \n-         if Exp_Is_Function_Call\n+         elsif Exp_Is_Function_Call\n            and then Needs_Secondary_Stack (Exp_Typ)\n          then\n             --  Remove side effects from the expression now so that other parts\n@@ -6782,7 +6763,7 @@ package body Exp_Ch6 is\n \n          --    type Ann is access R_Type;\n          --    for Ann'Storage_pool use ss_pool;\n-         --    Rnn : Ann := new Exp_Typ'(Exp);\n+         --    Rnn : constant Ann := new Exp_Typ'(Exp);\n          --    return Rnn.all;\n \n          --  And we do the same for class-wide types that are not potentially\n@@ -6806,7 +6787,6 @@ package body Exp_Ch6 is\n \n             begin\n                Mutate_Ekind (Acc_Typ, E_Access_Type);\n-\n                Set_Associated_Storage_Pool (Acc_Typ, RTE (RE_SS_Pool));\n \n                --  This is an allocator for the secondary stack, and it's fine\n@@ -6836,6 +6816,7 @@ package body Exp_Ch6 is\n \n                  Make_Object_Declaration (Loc,\n                    Defining_Identifier => Temp,\n+                   Constant_Present    => True,\n                    Object_Definition   => New_Occurrence_Of (Acc_Typ, Loc),\n                    Expression          => Alloc_Node)));\n \n@@ -7900,6 +7881,16 @@ package body Exp_Ch6 is\n         and then Is_Build_In_Place_Function (Return_Applies_To (Scope (E)));\n    end Is_Build_In_Place_Return_Object;\n \n+   -----------------------------------\n+   -- Is_By_Reference_Return_Object --\n+   -----------------------------------\n+\n+   function Is_By_Reference_Return_Object (E : Entity_Id) return Boolean is\n+   begin\n+      return Is_Return_Object (E)\n+        and then Is_By_Reference_Type (Etype (Return_Applies_To (Scope (E))));\n+   end Is_By_Reference_Return_Object;\n+\n    -----------------------\n    -- Is_Null_Procedure --\n    -----------------------\n@@ -7959,6 +7950,28 @@ package body Exp_Ch6 is\n       end if;\n    end Is_Null_Procedure;\n \n+   --------------------------------------\n+   -- Is_Secondary_Stack_Return_Object --\n+   --------------------------------------\n+\n+   function Is_Secondary_Stack_Return_Object (E : Entity_Id) return Boolean is\n+   begin\n+      return Is_Return_Object (E)\n+        and then Needs_Secondary_Stack (Etype (Return_Applies_To (Scope (E))));\n+   end Is_Secondary_Stack_Return_Object;\n+\n+   ------------------------------\n+   -- Is_Special_Return_Object --\n+   ------------------------------\n+\n+   function Is_Special_Return_Object (E : Entity_Id) return Boolean is\n+   begin\n+      return Is_Build_In_Place_Return_Object (E)\n+         or else Is_Secondary_Stack_Return_Object (E)\n+         or else (Back_End_Return_Slot\n+                   and then Is_By_Reference_Return_Object (E));\n+   end Is_Special_Return_Object;\n+\n    -------------------------------------------\n    -- Make_Build_In_Place_Call_In_Allocator --\n    -------------------------------------------"}, {"sha": "41ddf8dd8d0eafb13db787854d0b94c0efa9d11d", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=ea588d41f39428b0c3b02f016353dceb1aaaaa39", "patch": "@@ -99,6 +99,16 @@ package Exp_Ch6 is\n    --  Adds Extra_Actual as a named parameter association for the formal\n    --  Extra_Formal in Subprogram_Call.\n \n+   procedure Apply_CW_Accessibility_Check (Exp : Node_Id; Func : Entity_Id);\n+   --  Ada 2005 (AI95-344): If the result type is class-wide, insert a check\n+   --  that the level of the return expression's underlying type is not deeper\n+   --  than the level of the master enclosing the function. Always generate the\n+   --  check when the type of the return expression is class-wide, when it's a\n+   --  type conversion, or when it's a formal parameter. Otherwise suppress the\n+   --  check in the case where the return expression has a specific type whose\n+   --  level is known not to be statically deeper than the result type of the\n+   --  function.\n+\n    function BIP_Formal_Suffix (Kind : BIP_Formal_Kind) return String;\n    --  Ada 2005 (AI-318-02): Returns a string to be used as the suffix of names\n    --  for build-in-place formal parameters of the given kind.\n@@ -158,13 +168,28 @@ package Exp_Ch6 is\n    --  True in >= Ada 2005 and must be False in Ada 95.\n \n    function Is_Build_In_Place_Return_Object (E : Entity_Id) return Boolean;\n-   --  Ada 2005 (AI-318-02): Return True is E is a return object of a function\n+   --  Ada 2005 (AI-318-02): Return True if E is a return object of a function\n    --  that uses build-in-place protocols.\n \n+   function Is_By_Reference_Return_Object (E : Entity_Id) return Boolean;\n+   --  Return True if E is a return object of a function whose return type is\n+   --  required to be passed by reference, as defined in (RM 6.2(4-9)).\n+\n    function Is_Null_Procedure (Subp : Entity_Id) return Boolean;\n    --  Predicate to recognize stubbed procedures and null procedures, which\n    --  can be inlined unconditionally in all cases.\n \n+   function Is_Secondary_Stack_Return_Object (E : Entity_Id) return Boolean;\n+   --  Return True if E is a return object of a function whose return type is\n+   --  returned on the secondary stack.\n+\n+   function Is_Special_Return_Object (E : Entity_Id) return Boolean;\n+   --  Return True if E is the return object of a function and is handled in a\n+   --  special way by the expander. In most cases, return objects are handled\n+   --  like any other variables or constants but, in a few special cases, they\n+   --  are further expanded into more elaborate constructs, whose common goal\n+   --  is to elide the copy operation associated with the return.\n+\n    procedure Make_Build_In_Place_Call_In_Allocator\n      (Allocator     : Node_Id;\n       Function_Call : Node_Id);"}, {"sha": "84b0c0e29412b0c1f3d5b78441b11e54f9beeff9", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=ea588d41f39428b0c3b02f016353dceb1aaaaa39", "patch": "@@ -9166,7 +9166,11 @@ package body Exp_Util is\n       return\n         Present (Expr)\n           and then Nkind (Unqual_Conv (Expr)) = N_Explicit_Dereference\n-          and then Nkind (Parent (Expr)) = N_Simple_Return_Statement;\n+          and then (Nkind (Parent (Expr)) = N_Simple_Return_Statement\n+                     or else\n+                       (Nkind (Parent (Expr)) = N_Object_Renaming_Declaration\n+                         and then\n+                        Is_Return_Object (Defining_Entity (Parent (Expr)))));\n    end Is_Related_To_Func_Return;\n \n    --------------------------------"}, {"sha": "59332f93614a97995a9072eba10bf8c76af40616", "filename": "gcc/ada/gcc-interface/trans.cc", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fgcc-interface%2Ftrans.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fgcc-interface%2Ftrans.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.cc?ref=ea588d41f39428b0c3b02f016353dceb1aaaaa39", "patch": "@@ -8473,9 +8473,10 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  declaration, return the result unmodified because we want to use the\n \t  return slot optimization in this case.\n \n-       5. If this is a reference to an unconstrained array which is used as the\n-\t  prefix of an attribute reference that requires an lvalue, return the\n-\t  result unmodified because we want to return the original bounds.\n+       5. If this is a reference to an unconstrained array which is used either\n+\t  as the prefix of an attribute reference that requires an lvalue or in\n+\t  a return statement, then return the result unmodified because we want\n+\t  to return the original bounds.\n \n        6. Finally, if the type of the result is already correct.  */\n \n@@ -8539,8 +8540,9 @@ gnat_to_gnu (Node_Id gnat_node)\n \n   else if (TREE_CODE (TREE_TYPE (gnu_result)) == UNCONSTRAINED_ARRAY_TYPE\n \t   && Present (Parent (gnat_node))\n-\t   && Nkind (Parent (gnat_node)) == N_Attribute_Reference\n-\t   && lvalue_required_for_attribute_p (Parent (gnat_node)))\n+\t   && ((Nkind (Parent (gnat_node)) == N_Attribute_Reference\n+\t        && lvalue_required_for_attribute_p (Parent (gnat_node)))\n+\t       || Nkind (Parent (gnat_node)) == N_Simple_Return_Statement))\n     ;\n \n   else if (TREE_TYPE (gnu_result) != gnu_result_type)"}, {"sha": "bc424ab3c3b472e80a65e5898795f8472f8977f1", "filename": "gcc/ada/gen_il-fields.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fgen_il-fields.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fgen_il-fields.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-fields.ads?ref=ea588d41f39428b0c3b02f016353dceb1aaaaa39", "patch": "@@ -69,7 +69,6 @@ package Gen_IL.Fields is\n       Address_Warning_Posted,\n       Aggregate_Bounds,\n       Aliased_Present,\n-      Alloc_For_BIP_Return,\n       All_Others,\n       All_Present,\n       Alternatives,\n@@ -189,6 +188,7 @@ package Gen_IL.Fields is\n       Float_Truncate,\n       Formal_Type_Definition,\n       Forwards_OK,\n+      For_Special_Return_Object,\n       From_Aspect_Specification,\n       From_At_Mod,\n       From_Conditional_Expression,"}, {"sha": "ec0eba74d06b0fedcd359bd9d96951effb8df9f4", "filename": "gcc/ada/gen_il-gen-gen_nodes.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb?ref=ea588d41f39428b0c3b02f016353dceb1aaaaa39", "patch": "@@ -494,7 +494,7 @@ begin -- Gen_IL.Gen.Gen_Nodes\n        (Sy (Expression, Node_Id, Default_Empty),\n         Sy (Subpool_Handle_Name, Node_Id, Default_Empty),\n         Sy (Null_Exclusion_Present, Flag, Default_False),\n-        Sm (Alloc_For_BIP_Return, Flag),\n+        Sm (For_Special_Return_Object, Flag),\n         Sm (Do_Storage_Check, Flag),\n         Sm (Is_Dynamic_Coextension, Flag),\n         Sm (Is_Static_Coextension, Flag),"}, {"sha": "09fe99f44bcd84adc1e6320f32338336d16859a9", "filename": "gcc/ada/gen_il-internals.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fgen_il-internals.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fgen_il-internals.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-internals.adb?ref=ea588d41f39428b0c3b02f016353dceb1aaaaa39", "patch": "@@ -257,8 +257,6 @@ package body Gen_IL.Internals is\n          --  Special cases for the same reason as in the above Image\n          --  function for Opt_Type_Enum.\n \n-         when Alloc_For_BIP_Return =>\n-            return \"Alloc_For_BIP_Return\";\n          when Assignment_OK =>\n             return \"Assignment_OK\";\n          when Backwards_OK =>"}, {"sha": "5334e486800addc1f2c356934aeadf9ee19da6d5", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=ea588d41f39428b0c3b02f016353dceb1aaaaa39", "patch": "@@ -3781,6 +3781,11 @@ package body Sem_Ch3 is\n       --  Obj_Decl carrying type Obj_Typ has explicit initialization. Emit\n       --  a compile-time warning if this is not the case.\n \n+      procedure Check_Return_Subtype_Indication (Obj_Decl : Node_Id);\n+      --  Check that the return subtype indication properly matches the result\n+      --  subtype of the function in an extended return object declaration, as\n+      --  required by RM 6.5(5.1/2-5.3/2).\n+\n       function Count_Tasks (T : Entity_Id) return Uint;\n       --  This function is called when a non-generic library level object of a\n       --  task type is declared. Its function is to count the static number of\n@@ -3954,6 +3959,134 @@ package body Sem_Ch3 is\n          Check_Component (Obj_Typ, Obj_Decl);\n       end Check_For_Null_Excluding_Components;\n \n+      -------------------------------------\n+      -- Check_Return_Subtype_Indication --\n+      -------------------------------------\n+\n+      procedure Check_Return_Subtype_Indication (Obj_Decl : Node_Id) is\n+         Obj_Id  : constant Entity_Id := Defining_Identifier (Obj_Decl);\n+         Obj_Typ : constant Entity_Id := Etype (Obj_Id);\n+         Func_Id : constant Entity_Id := Return_Applies_To (Scope (Obj_Id));\n+         R_Typ   : constant Entity_Id := Etype (Func_Id);\n+         Indic   : constant Node_Id   :=\n+                     Object_Definition (Original_Node (Obj_Decl));\n+\n+         procedure Error_No_Match (N : Node_Id);\n+         --  Output error messages for case where types do not statically\n+         --  match. N is the location for the messages.\n+\n+         --------------------\n+         -- Error_No_Match --\n+         --------------------\n+\n+         procedure Error_No_Match (N : Node_Id) is\n+         begin\n+            Error_Msg_N\n+              (\"subtype must statically match function result subtype\", N);\n+\n+            if not Predicates_Match (Obj_Typ, R_Typ) then\n+               Error_Msg_Node_2 := R_Typ;\n+               Error_Msg_NE\n+                 (\"\\predicate of& does not match predicate of&\",\n+                  N, Obj_Typ);\n+            end if;\n+         end Error_No_Match;\n+\n+      --  Start of processing for Check_Return_Subtype_Indication\n+\n+      begin\n+         --  First, avoid cascaded errors\n+\n+         if Error_Posted (Obj_Decl) or else Error_Posted (Indic) then\n+            return;\n+         end if;\n+\n+         --  \"return access T\" case; check that the return statement also has\n+         --  \"access T\", and that the subtypes statically match:\n+         --   if this is an access to subprogram the signatures must match.\n+\n+         if Is_Anonymous_Access_Type (R_Typ) then\n+            if Is_Anonymous_Access_Type (Obj_Typ) then\n+               if Ekind (Designated_Type (Obj_Typ)) /= E_Subprogram_Type\n+               then\n+                  if Base_Type (Designated_Type (Obj_Typ)) /=\n+                     Base_Type (Designated_Type (R_Typ))\n+                    or else not Subtypes_Statically_Match (Obj_Typ, R_Typ)\n+                  then\n+                     Error_No_Match (Subtype_Mark (Indic));\n+                  end if;\n+\n+               else\n+                  --  For two anonymous access to subprogram types, the types\n+                  --  themselves must be type conformant.\n+\n+                  if not Conforming_Types\n+                           (Obj_Typ, R_Typ, Fully_Conformant)\n+                  then\n+                     Error_No_Match (Indic);\n+                  end if;\n+               end if;\n+\n+            else\n+               Error_Msg_N (\"must use anonymous access type\", Indic);\n+            end if;\n+\n+         --  If the return object is of an anonymous access type, then report\n+         --  an error if the function's result type is not also anonymous.\n+\n+         elsif Is_Anonymous_Access_Type (Obj_Typ) then\n+            pragma Assert (not Is_Anonymous_Access_Type (R_Typ));\n+            Error_Msg_N\n+              (\"anonymous access not allowed for function with named access \"\n+               & \"result\", Indic);\n+\n+         --  Subtype indication case: check that the return object's type is\n+         --  covered by the result type, and that the subtypes statically match\n+         --  when the result subtype is constrained. Also handle record types\n+         --  with unknown discriminants for which we have built the underlying\n+         --  record view. Coverage is needed to allow specific-type return\n+         --  objects when the result type is class-wide (see AI05-32).\n+\n+         elsif Covers (Base_Type (R_Typ), Base_Type (Obj_Typ))\n+           or else (Is_Underlying_Record_View (Base_Type (Obj_Typ))\n+                     and then\n+                       Covers\n+                         (Base_Type (R_Typ),\n+                          Underlying_Record_View (Base_Type (Obj_Typ))))\n+         then\n+            --  A null exclusion may be present on the return type, on the\n+            --  function specification, on the object declaration or on the\n+            --  subtype itself.\n+\n+            if Is_Access_Type (R_Typ)\n+              and then\n+                (Can_Never_Be_Null (R_Typ)\n+                  or else Null_Exclusion_Present (Parent (Func_Id))) /=\n+                            Can_Never_Be_Null (Obj_Typ)\n+            then\n+               Error_No_Match (Indic);\n+            end if;\n+\n+            --  AI05-103: for elementary types, subtypes must statically match\n+\n+            if Is_Constrained (R_Typ) or else Is_Access_Type (R_Typ) then\n+               if not Subtypes_Statically_Match (Obj_Typ, R_Typ) then\n+                  Error_No_Match (Indic);\n+               end if;\n+            end if;\n+\n+         --  All remaining cases are illegal\n+\n+         --  Note: previous versions of this subprogram allowed the return\n+         --  value to be the ancestor of the return type if the return type\n+         --  was a null extension. This was plainly incorrect.\n+\n+         else\n+            Error_Msg_N\n+              (\"wrong type for return_subtype_indication\", Indic);\n+         end if;\n+      end Check_Return_Subtype_Indication;\n+\n       -----------------\n       -- Count_Tasks --\n       -----------------\n@@ -5047,6 +5180,12 @@ package body Sem_Ch3 is\n          end if;\n       end if;\n \n+      --  Check specific legality rules for a return object\n+\n+      if Is_Return_Object (Id) then\n+         Check_Return_Subtype_Indication (N);\n+      end if;\n+\n       --  Some simple constant-propagation: if the expression is a constant\n       --  string initialized with a literal, share the literal. This avoids\n       --  a run-time copy."}, {"sha": "da5aa5fe88f969938ef8547c52e22fc2031c13cb", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 29, "deletions": 35, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=ea588d41f39428b0c3b02f016353dceb1aaaaa39", "patch": "@@ -44,6 +44,7 @@ with Opt;            use Opt;\n with Output;         use Output;\n with Restrict;       use Restrict;\n with Rident;         use Rident;\n+with Rtsfind;        use Rtsfind;\n with Sem;            use Sem;\n with Sem_Aux;        use Sem_Aux;\n with Sem_Case;       use Sem_Case;\n@@ -733,43 +734,16 @@ package body Sem_Ch4 is\n             end;\n          end if;\n \n-         --  Check for missing initialization. Skip this check if we already\n-         --  had errors on analyzing the allocator, since in that case these\n-         --  are probably cascaded errors.\n+         --  Check for missing initialization. Skip this check if the allocator\n+         --  is made for a special return object or if we already had errors on\n+         --  analyzing the allocator since, in that case, these are very likely\n+         --  cascaded errors.\n \n          if not Is_Definite_Subtype (Type_Id)\n+           and then not For_Special_Return_Object (N)\n            and then Serious_Errors_Detected = Sav_Errs\n          then\n-            --  The build-in-place machinery may produce an allocator when\n-            --  the designated type is indefinite but the underlying type is\n-            --  not. In this case the unknown discriminants are meaningless\n-            --  and should not trigger error messages. Check the parent node\n-            --  because the allocator is marked as coming from source.\n-\n-            if Present (Underlying_Type (Type_Id))\n-              and then Is_Definite_Subtype (Underlying_Type (Type_Id))\n-              and then not Comes_From_Source (Parent (N))\n-            then\n-               null;\n-\n-            --  An unusual case arises when the parent of a derived type is\n-            --  a limited record extension  with unknown discriminants, and\n-            --  its full view has no discriminants.\n-            --\n-            --  A more general fix might be to create the proper underlying\n-            --  type for such a derived type, but it is a record type with\n-            --  no private attributes, so this required extending the\n-            --  meaning of this attribute. ???\n-\n-            elsif Ekind (Etype (Type_Id)) = E_Record_Type_With_Private\n-              and then Present (Underlying_Type (Etype (Type_Id)))\n-              and then\n-                not Has_Discriminants (Underlying_Type (Etype (Type_Id)))\n-              and then not Comes_From_Source (Parent (N))\n-            then\n-               null;\n-\n-            elsif Is_Class_Wide_Type (Type_Id) then\n+            if Is_Class_Wide_Type (Type_Id) then\n                Error_Msg_N\n                  (\"initialization required in class-wide allocation\", N);\n \n@@ -842,6 +816,27 @@ package body Sem_Ch4 is\n          Error_Msg_N (\"cannot allocate abstract object\", E);\n       end if;\n \n+      Set_Etype (N, Acc_Type);\n+\n+      --  If this is an allocator for the return stack, then no restriction may\n+      --  be violated since it's just a low-level access to the primary stack.\n+\n+      if Nkind (Parent (N)) = N_Object_Declaration\n+        and then Is_Entity_Name (Object_Definition (Parent (N)))\n+        and then Is_Access_Type (Entity (Object_Definition (Parent (N))))\n+      then\n+         declare\n+            Pool : constant Entity_Id :=\n+              Associated_Storage_Pool\n+                (Root_Type (Entity (Object_Definition (Parent (N)))));\n+\n+         begin\n+            if Present (Pool) and then Is_RTE (Pool, RE_RS_Pool) then\n+               goto Leave;\n+            end if;\n+         end;\n+      end if;\n+\n       if Has_Task (Designated_Type (Acc_Type)) then\n          Check_Restriction (No_Tasking, N);\n          Check_Restriction (Max_Tasks, N);\n@@ -893,12 +888,11 @@ package body Sem_Ch4 is\n          end if;\n       end if;\n \n-      Set_Etype (N, Acc_Type);\n-\n       if not Is_Library_Level_Entity (Acc_Type) then\n          Check_Restriction (No_Local_Allocators, N);\n       end if;\n \n+   <<Leave>>\n       if Serious_Errors_Detected > Sav_Errs then\n          Set_Error_Posted (N);\n          Set_Etype (N, Any_Type);"}, {"sha": "344b3ebfdb2dfebc3c473394d673879da220cf7e", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=ea588d41f39428b0c3b02f016353dceb1aaaaa39", "patch": "@@ -307,7 +307,8 @@ package body Sem_Ch5 is\n          --  get the actual subtype (needed for the unconstrained case). If the\n          --  operand is the actual in an entry declaration, then within the\n          --  accept statement it is replaced with a local renaming, which may\n-         --  also have an actual subtype.\n+         --  also have an actual subtype. Likewise for a return object that\n+         --  lives on the secondary stack.\n \n          if Is_Entity_Name (Opnd)\n            and then (Ekind (Entity (Opnd)) in E_Out_Parameter\n@@ -318,7 +319,8 @@ package body Sem_Ch5 is\n                           and then Nkind (Parent (Entity (Opnd))) =\n                                      N_Object_Renaming_Declaration\n                           and then Nkind (Parent (Parent (Entity (Opnd)))) =\n-                                     N_Accept_Statement))\n+                                     N_Accept_Statement)\n+                      or else Is_Secondary_Stack_Return_Object (Entity (Opnd)))\n          then\n             Opnd_Type := Get_Actual_Subtype (Opnd);\n "}, {"sha": "f46ca46fc6447245985e4023f10725204bb5ff63", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 0, "deletions": 135, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=ea588d41f39428b0c3b02f016353dceb1aaaaa39", "patch": "@@ -746,10 +746,6 @@ package body Sem_Ch6 is\n       --  Ada 2022: Check that the return expression in a No_Return function\n       --  meets the conditions specified by RM 6.5.1(5.1/5).\n \n-      procedure Check_Return_Subtype_Indication (Obj_Decl : Node_Id);\n-      --  Check that the return_subtype_indication properly matches the result\n-      --  subtype of the function, as required by RM-6.5(5.1/2-5.3/2).\n-\n       --------------------------------\n       -- Check_No_Return_Expression --\n       --------------------------------\n@@ -778,135 +774,6 @@ package body Sem_Ch6 is\n             Return_Expr);\n       end Check_No_Return_Expression;\n \n-      -------------------------------------\n-      -- Check_Return_Subtype_Indication --\n-      -------------------------------------\n-\n-      procedure Check_Return_Subtype_Indication (Obj_Decl : Node_Id) is\n-         Return_Obj : constant Node_Id   := Defining_Identifier (Obj_Decl);\n-\n-         R_Stm_Type : constant Entity_Id := Etype (Return_Obj);\n-         --  Subtype given in the extended return statement (must match R_Type)\n-\n-         Subtype_Ind : constant Node_Id :=\n-                         Object_Definition (Original_Node (Obj_Decl));\n-\n-         procedure Error_No_Match (N : Node_Id);\n-         --  Output error messages for case where types do not statically\n-         --  match. N is the location for the messages.\n-\n-         --------------------\n-         -- Error_No_Match --\n-         --------------------\n-\n-         procedure Error_No_Match (N : Node_Id) is\n-         begin\n-            Error_Msg_N\n-              (\"subtype must statically match function result subtype\", N);\n-\n-            if not Predicates_Match (R_Stm_Type, R_Type) then\n-               Error_Msg_Node_2 := R_Type;\n-               Error_Msg_NE\n-                 (\"\\predicate of& does not match predicate of&\",\n-                  N, R_Stm_Type);\n-            end if;\n-         end Error_No_Match;\n-\n-      --  Start of processing for Check_Return_Subtype_Indication\n-\n-      begin\n-         --  First, avoid cascaded errors\n-\n-         if Error_Posted (Obj_Decl) or else Error_Posted (Subtype_Ind) then\n-            return;\n-         end if;\n-\n-         --  \"return access T\" case; check that the return statement also has\n-         --  \"access T\", and that the subtypes statically match:\n-         --   if this is an access to subprogram the signatures must match.\n-\n-         if Is_Anonymous_Access_Type (R_Type) then\n-            if Is_Anonymous_Access_Type (R_Stm_Type) then\n-               if Ekind (Designated_Type (R_Stm_Type)) /= E_Subprogram_Type\n-               then\n-                  if Base_Type (Designated_Type (R_Stm_Type)) /=\n-                     Base_Type (Designated_Type (R_Type))\n-                    or else not Subtypes_Statically_Match (R_Stm_Type, R_Type)\n-                  then\n-                     Error_No_Match (Subtype_Mark (Subtype_Ind));\n-                  end if;\n-\n-               else\n-                  --  For two anonymous access to subprogram types, the types\n-                  --  themselves must be type conformant.\n-\n-                  if not Conforming_Types\n-                           (R_Stm_Type, R_Type, Fully_Conformant)\n-                  then\n-                     Error_No_Match (Subtype_Ind);\n-                  end if;\n-               end if;\n-\n-            else\n-               Error_Msg_N (\"must use anonymous access type\", Subtype_Ind);\n-            end if;\n-\n-         --  If the return object is of an anonymous access type, then report\n-         --  an error if the function's result type is not also anonymous.\n-\n-         elsif Is_Anonymous_Access_Type (R_Stm_Type) then\n-            pragma Assert (not Is_Anonymous_Access_Type (R_Type));\n-            Error_Msg_N\n-              (\"anonymous access not allowed for function with named access \"\n-               & \"result\", Subtype_Ind);\n-\n-         --  Subtype indication case: check that the return object's type is\n-         --  covered by the result type, and that the subtypes statically match\n-         --  when the result subtype is constrained. Also handle record types\n-         --  with unknown discriminants for which we have built the underlying\n-         --  record view. Coverage is needed to allow specific-type return\n-         --  objects when the result type is class-wide (see AI05-32).\n-\n-         elsif Covers (Base_Type (R_Type), Base_Type (R_Stm_Type))\n-           or else (Is_Underlying_Record_View (Base_Type (R_Stm_Type))\n-                     and then\n-                       Covers\n-                         (Base_Type (R_Type),\n-                          Underlying_Record_View (Base_Type (R_Stm_Type))))\n-         then\n-            --  A null exclusion may be present on the return type, on the\n-            --  function specification, on the object declaration or on the\n-            --  subtype itself.\n-\n-            if Is_Access_Type (R_Type)\n-              and then\n-                (Can_Never_Be_Null (R_Type)\n-                  or else Null_Exclusion_Present (Parent (Scope_Id))) /=\n-                            Can_Never_Be_Null (R_Stm_Type)\n-            then\n-               Error_No_Match (Subtype_Ind);\n-            end if;\n-\n-            --  AI05-103: for elementary types, subtypes must statically match\n-\n-            if Is_Constrained (R_Type) or else Is_Access_Type (R_Type) then\n-               if not Subtypes_Statically_Match (R_Stm_Type, R_Type) then\n-                  Error_No_Match (Subtype_Ind);\n-               end if;\n-            end if;\n-\n-         --  All remaining cases are illegal\n-\n-         --  Note: previous versions of this subprogram allowed the return\n-         --  value to be the ancestor of the return type if the return type\n-         --  was a null extension. This was plainly incorrect.\n-\n-         else\n-            Error_Msg_N\n-              (\"wrong type for return_subtype_indication\", Subtype_Ind);\n-         end if;\n-      end Check_Return_Subtype_Indication;\n-\n       ---------------------\n       -- Local Variables --\n       ---------------------\n@@ -1016,8 +883,6 @@ package body Sem_Ch6 is\n             Set_Is_Return_Object (Defining_Identifier (Obj_Decl));\n             Analyze (Obj_Decl);\n \n-            Check_Return_Subtype_Indication (Obj_Decl);\n-\n             if Present (HSS) then\n                Analyze (HSS);\n "}, {"sha": "b54ed93a7f76873c012db3c3738953b8d11b9de2", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=ea588d41f39428b0c3b02f016353dceb1aaaaa39", "patch": "@@ -5622,7 +5622,7 @@ package body Sem_Res is\n       --  caller does use an allocator, it will be caught at the call site.\n \n       if No_Pool_Assigned (Typ)\n-        and then not Alloc_For_BIP_Return (N)\n+        and then not For_Special_Return_Object (N)\n       then\n          Error_Msg_N (\"allocation from empty storage pool!\", N);\n "}, {"sha": "104ee663c0e82be52688c17a800a36a96dea92ce", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=ea588d41f39428b0c3b02f016353dceb1aaaaa39", "patch": "@@ -842,10 +842,6 @@ package Sinfo is\n    --    known at compile time, this field points to an N_Range node with those\n    --    bounds. Otherwise Empty.\n \n-   --  Alloc_For_BIP_Return\n-   --    Present in N_Allocator nodes. True if the allocator is one of those\n-   --    generated for a build-in-place return statement.\n-\n    --  All_Others\n    --    Present in an N_Others_Choice node. This flag is set for an others\n    --    exception where all exceptions are to be caught, even those that are\n@@ -1344,6 +1340,10 @@ package Sinfo is\n    --    cannot figure it out. If both flags Forwards_OK and Backwards_OK are\n    --    set, it means that the front end can assure no overlap of operands.\n \n+   --  For_Special_Return_Object\n+   --    Present in N_Allocator nodes. True if the allocator is generated for\n+   --    the initialization of a special return object.\n+\n    --  From_Aspect_Specification\n    --    Processing of aspect specifications typically results in insertion in\n    --    the tree of corresponding pragma or attribute definition clause nodes.\n@@ -4777,7 +4777,7 @@ package Sinfo is\n       --  Subpool_Handle_Name (set to Empty if not present)\n       --  Storage_Pool\n       --  Procedure_To_Call\n-      --  Alloc_For_BIP_Return\n+      --  For_Special_Return_Object\n       --  Null_Exclusion_Present\n       --  No_Initialization\n       --  Is_Static_Coextension"}, {"sha": "a0f45c422befc2bddbd2d0591435e3c867447e63", "filename": "gcc/ada/treepr.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Ftreepr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea588d41f39428b0c3b02f016353dceb1aaaaa39/gcc%2Fada%2Ftreepr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreepr.adb?ref=ea588d41f39428b0c3b02f016353dceb1aaaaa39", "patch": "@@ -269,8 +269,9 @@ package body Treepr is\n    function Image (F : Node_Or_Entity_Field) return String is\n    begin\n       case F is\n-         when F_Alloc_For_BIP_Return =>\n-            return \"Alloc_For_BIP_Return\";\n+         --  We special case the following; otherwise the compiler will use\n+         --  the usual Mixed_Case convention.\n+\n          when F_Assignment_OK =>\n             return \"Assignment_OK\";\n          when F_Backwards_OK =>"}]}