{"sha": "937e96763e42c48c29e3a5edf2eea3fb2c59fb27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTM3ZTk2NzYzZTQyYzQ4YzI5ZTNhNWVkZjJlZWEzZmIyYzU5ZmIyNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-07-06T12:37:54Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-07-06T12:37:54Z"}, "message": "[multiple changes]\n\n2016-07-06  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* einfo.adb Flag252 is now used as Is_Finalized_Transient. Flag295\n\tis now used as Is_Ignored_Transient.\n\t(Is_Finalized_Transient): New routine.\n\t(Is_Ignored_Transient): New routine.\n\t(Is_Processed_Transient): Removed.\n\t(Set_Is_Finalized_Transient): New routine.\n\t(Set_Is_Ignored_Transient): New routine.\n\t(Set_Is_Processed_Transient): Removed.\n\t(Write_Entity_Flags): Output Flag252 and Flag295.\n\t* einfo.ads: New attributes Is_Finalized_Transient\n\tand Is_Ignored_Transient along with occurrences in\n\tentities. Remove attribute Is_Processed_Transient.\n\t(Is_Finalized_Transient): New routine along with pragma Inline.\n\t(Is_Ignored_Transient): New routine along with pragma Inline.\n\t(Is_Processed_Transient): Removed along with pragma Inline.\n\t(Set_Is_Finalized_Transient): New routine along with pragma Inline.\n\t(Set_Is_Ignored_Transient): New routine along with pragma Inline.\n\t(Set_Is_Processed_Transient): Removed along with pragma Inline.\n\t* exp_aggr.adb Add with and use clauses for Exp_Ch11 and Inline.\n\t(Build_Record_Aggr_Code): Change the handling\n\tof controlled record components.\n\t(Ctrl_Init_Expression): Removed.\n\t(Gen_Assign): Add new formal parameter In_Loop\n\talong with comment on usage.  Remove local variables Stmt and\n\tStmt_Expr. Change the handling of controlled array components.\n\t(Gen_Loop): Update the call to Gen_Assign.\n\t(Gen_While): Update the call to Gen_Assign.\n\t(Initialize_Array_Component): New routine.\n\t(Initialize_Ctrl_Array_Component): New routine.\n\t(Initialize_Ctrl_Record_Component): New routine.\n\t(Initialize_Record_Component): New routine.\n\t(Process_Transient_Component): New routine.\n\t(Process_Transient_Component_Completion): New routine.\n\t* exp_ch4.adb (Process_Transient_In_Expression): New routine.\n\t(Process_Transient_Object): Removed. Replace all existing calls\n\tto this routine with calls to Process_Transient_In_Expression.\n\t* exp_ch6.adb (Expand_Ctrl_Function_Call): Remove local constant\n\tIs_Elem_Ref. Update the comment on ignoring transients.\n\t* exp_ch7.adb (Process_Declarations): Do not process ignored\n\tor finalized transient objects.\n\t(Process_Transient_In_Scope): New routine.\n\t(Process_Transients_In_Scope): New routine.\n\t(Process_Transient_Objects): Removed. Replace all existing calls\n\tto this routine with calls to Process_Transients_In_Scope.\n\t* exp_util.adb (Build_Transient_Object_Statements): New routine.\n\t(Is_Finalizable_Transient): Do not consider a transient object\n\twhich has been finalized.\n\t(Requires_Cleanup_Actions): Do not consider ignored or finalized\n\ttransient objects.\n\t* exp_util.ads (Build_Transient_Object_Statements): New routine.\n\t* sem_aggr.adb: Major code clean up.\n\t* sem_res.adb: Update documentation.\n\n2016-07-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Analyze_Subtype_Declaration): For generated\n\tsubtypes, such as actual subtypes of unconstrained formals,\n\tinherit predicate functions, if any, from the parent type rather\n\tthan creating redundant new ones.\n\nFrom-SVN: r238044", "tree": {"sha": "e06e4ba4a6b2f4134dd131533a73bc7e185a6ac6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e06e4ba4a6b2f4134dd131533a73bc7e185a6ac6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/937e96763e42c48c29e3a5edf2eea3fb2c59fb27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/937e96763e42c48c29e3a5edf2eea3fb2c59fb27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/937e96763e42c48c29e3a5edf2eea3fb2c59fb27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/937e96763e42c48c29e3a5edf2eea3fb2c59fb27/comments", "author": null, "committer": null, "parents": [{"sha": "75e4e36dfe12f78efa61c071caf95ba9d5f4f722", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75e4e36dfe12f78efa61c071caf95ba9d5f4f722", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75e4e36dfe12f78efa61c071caf95ba9d5f4f722"}], "stats": {"total": 3303, "additions": 2022, "deletions": 1281}, "files": [{"sha": "be8759c4274ff23d76e4b7f20d989e77c301eb72", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/937e96763e42c48c29e3a5edf2eea3fb2c59fb27/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/937e96763e42c48c29e3a5edf2eea3fb2c59fb27/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=937e96763e42c48c29e3a5edf2eea3fb2c59fb27", "patch": "@@ -1,3 +1,65 @@\n+2016-07-06  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* einfo.adb Flag252 is now used as Is_Finalized_Transient. Flag295\n+\tis now used as Is_Ignored_Transient.\n+\t(Is_Finalized_Transient): New routine.\n+\t(Is_Ignored_Transient): New routine.\n+\t(Is_Processed_Transient): Removed.\n+\t(Set_Is_Finalized_Transient): New routine.\n+\t(Set_Is_Ignored_Transient): New routine.\n+\t(Set_Is_Processed_Transient): Removed.\n+\t(Write_Entity_Flags): Output Flag252 and Flag295.\n+\t* einfo.ads: New attributes Is_Finalized_Transient\n+\tand Is_Ignored_Transient along with occurrences in\n+\tentities. Remove attribute Is_Processed_Transient.\n+\t(Is_Finalized_Transient): New routine along with pragma Inline.\n+\t(Is_Ignored_Transient): New routine along with pragma Inline.\n+\t(Is_Processed_Transient): Removed along with pragma Inline.\n+\t(Set_Is_Finalized_Transient): New routine along with pragma Inline.\n+\t(Set_Is_Ignored_Transient): New routine along with pragma Inline.\n+\t(Set_Is_Processed_Transient): Removed along with pragma Inline.\n+\t* exp_aggr.adb Add with and use clauses for Exp_Ch11 and Inline.\n+\t(Build_Record_Aggr_Code): Change the handling\n+\tof controlled record components.\n+\t(Ctrl_Init_Expression): Removed.\n+\t(Gen_Assign): Add new formal parameter In_Loop\n+\talong with comment on usage.  Remove local variables Stmt and\n+\tStmt_Expr. Change the handling of controlled array components.\n+\t(Gen_Loop): Update the call to Gen_Assign.\n+\t(Gen_While): Update the call to Gen_Assign.\n+\t(Initialize_Array_Component): New routine.\n+\t(Initialize_Ctrl_Array_Component): New routine.\n+\t(Initialize_Ctrl_Record_Component): New routine.\n+\t(Initialize_Record_Component): New routine.\n+\t(Process_Transient_Component): New routine.\n+\t(Process_Transient_Component_Completion): New routine.\n+\t* exp_ch4.adb (Process_Transient_In_Expression): New routine.\n+\t(Process_Transient_Object): Removed. Replace all existing calls\n+\tto this routine with calls to Process_Transient_In_Expression.\n+\t* exp_ch6.adb (Expand_Ctrl_Function_Call): Remove local constant\n+\tIs_Elem_Ref. Update the comment on ignoring transients.\n+\t* exp_ch7.adb (Process_Declarations): Do not process ignored\n+\tor finalized transient objects.\n+\t(Process_Transient_In_Scope): New routine.\n+\t(Process_Transients_In_Scope): New routine.\n+\t(Process_Transient_Objects): Removed. Replace all existing calls\n+\tto this routine with calls to Process_Transients_In_Scope.\n+\t* exp_util.adb (Build_Transient_Object_Statements): New routine.\n+\t(Is_Finalizable_Transient): Do not consider a transient object\n+\twhich has been finalized.\n+\t(Requires_Cleanup_Actions): Do not consider ignored or finalized\n+\ttransient objects.\n+\t* exp_util.ads (Build_Transient_Object_Statements): New routine.\n+\t* sem_aggr.adb: Major code clean up.\n+\t* sem_res.adb: Update documentation.\n+\n+2016-07-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Analyze_Subtype_Declaration): For generated\n+\tsubtypes, such as actual subtypes of unconstrained formals,\n+\tinherit predicate functions, if any, from the parent type rather\n+\tthan creating redundant new ones.\n+\n 2016-07-06  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_attr.adb, sem_attr.adb, sem_ch13.adb: Minor reformatting."}, {"sha": "1748efd0b660195cac03fe874939b134328465a2", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/937e96763e42c48c29e3a5edf2eea3fb2c59fb27/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/937e96763e42c48c29e3a5edf2eea3fb2c59fb27/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=937e96763e42c48c29e3a5edf2eea3fb2c59fb27", "patch": "@@ -561,7 +561,7 @@ package body Einfo is\n    --    Has_Predicates                  Flag250\n \n    --    Has_Implicit_Dereference        Flag251\n-   --    Is_Processed_Transient          Flag252\n+   --    Is_Finalized_Transient          Flag252\n    --    Disable_Controlled              Flag253\n    --    Is_Implementation_Defined       Flag254\n    --    Is_Predicate_Function           Flag255\n@@ -609,8 +609,8 @@ package body Einfo is\n    --    Is_Partial_Invariant_Procedure  Flag292\n    --    Is_Actual_Subtype               Flag293\n    --    Has_Pragma_Unused               Flag294\n+   --    Is_Ignored_Transient            Flag295\n \n-   --    (unused)                        Flag295\n    --    (unused)                        Flag296\n    --    (unused)                        Flag297\n    --    (unused)                        Flag298\n@@ -2185,6 +2185,12 @@ package body Einfo is\n       return Flag99 (Id);\n    end Is_Exported;\n \n+   function Is_Finalized_Transient (Id : E) return B is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Constant, E_Loop_Parameter, E_Variable));\n+      return Flag252 (Id);\n+   end Is_Finalized_Transient;\n+\n    function Is_First_Subtype (Id : E) return B is\n    begin\n       return Flag70 (Id);\n@@ -2250,6 +2256,12 @@ package body Einfo is\n       return Flag278 (Id);\n    end Is_Ignored_Ghost_Entity;\n \n+   function Is_Ignored_Transient (Id : E) return B is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Constant, E_Loop_Parameter, E_Variable));\n+      return Flag295 (Id);\n+   end Is_Ignored_Transient;\n+\n    function Is_Immediately_Visible (Id : E) return B is\n    begin\n       pragma Assert (Nkind (Id) in N_Entity);\n@@ -2466,12 +2478,6 @@ package body Einfo is\n       return Flag245 (Id);\n    end Is_Private_Primitive;\n \n-   function Is_Processed_Transient (Id : E) return B is\n-   begin\n-      pragma Assert (Ekind_In (Id, E_Constant, E_Loop_Parameter, E_Variable));\n-      return Flag252 (Id);\n-   end Is_Processed_Transient;\n-\n    function Is_Public (Id : E) return B is\n    begin\n       pragma Assert (Nkind (Id) in N_Entity);\n@@ -5248,6 +5254,12 @@ package body Einfo is\n       Set_Flag99 (Id, V);\n    end Set_Is_Exported;\n \n+   procedure Set_Is_Finalized_Transient (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Constant, E_Loop_Parameter, E_Variable));\n+      Set_Flag252 (Id, V);\n+   end Set_Is_Finalized_Transient;\n+\n    procedure Set_Is_First_Subtype (Id : E; V : B := True) is\n    begin\n       Set_Flag70 (Id, V);\n@@ -5329,6 +5341,12 @@ package body Einfo is\n       Set_Flag278 (Id, V);\n    end Set_Is_Ignored_Ghost_Entity;\n \n+   procedure Set_Is_Ignored_Transient (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Constant, E_Loop_Parameter, E_Variable));\n+      Set_Flag295 (Id, V);\n+   end Set_Is_Ignored_Transient;\n+\n    procedure Set_Is_Immediately_Visible (Id : E; V : B := True) is\n    begin\n       pragma Assert (Nkind (Id) in N_Entity);\n@@ -5543,12 +5561,6 @@ package body Einfo is\n       Set_Flag245 (Id, V);\n    end Set_Is_Private_Primitive;\n \n-   procedure Set_Is_Processed_Transient (Id : E; V : B := True) is\n-   begin\n-      pragma Assert (Ekind_In (Id, E_Constant, E_Loop_Parameter, E_Variable));\n-      Set_Flag252 (Id, V);\n-   end Set_Is_Processed_Transient;\n-\n    procedure Set_Is_Public (Id : E; V : B := True) is\n    begin\n       pragma Assert (Nkind (Id) in N_Entity);\n@@ -9241,6 +9253,7 @@ package body Einfo is\n       W (\"Is_Entry_Formal\",                 Flag52  (Id));\n       W (\"Is_Exception_Handler\",            Flag286 (Id));\n       W (\"Is_Exported\",                     Flag99  (Id));\n+      W (\"Is_Finalized_Transient\",          Flag252 (Id));\n       W (\"Is_First_Subtype\",                Flag70  (Id));\n       W (\"Is_For_Access_Subtype\",           Flag118 (Id));\n       W (\"Is_Formal_Subprogram\",            Flag111 (Id));\n@@ -9253,6 +9266,7 @@ package body Einfo is\n       W (\"Is_Hidden_Non_Overridden_Subpgm\", Flag2   (Id));\n       W (\"Is_Hidden_Open_Scope\",            Flag171 (Id));\n       W (\"Is_Ignored_Ghost_Entity\",         Flag278 (Id));\n+      W (\"Is_Ignored_Transient\",            Flag295 (Id));\n       W (\"Is_Immediately_Visible\",          Flag7   (Id));\n       W (\"Is_Implementation_Defined\",       Flag254 (Id));\n       W (\"Is_Imported\",                     Flag24  (Id));\n@@ -9292,7 +9306,6 @@ package body Einfo is\n       W (\"Is_Private_Composite\",            Flag107 (Id));\n       W (\"Is_Private_Descendant\",           Flag53  (Id));\n       W (\"Is_Private_Primitive\",            Flag245 (Id));\n-      W (\"Is_Processed_Transient\",          Flag252 (Id));\n       W (\"Is_Public\",                       Flag10  (Id));\n       W (\"Is_Pure\",                         Flag44  (Id));\n       W (\"Is_Pure_Unit_Access_Type\",        Flag189 (Id));"}, {"sha": "ec065a91a02b5f5df310454a8983d8e14c45d73d", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/937e96763e42c48c29e3a5edf2eea3fb2c59fb27/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/937e96763e42c48c29e3a5edf2eea3fb2c59fb27/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=937e96763e42c48c29e3a5edf2eea3fb2c59fb27", "patch": "@@ -535,7 +535,7 @@ package Einfo is\n --       a build-in-place function call. Contains the relocated build-in-place\n --       call after the expansion has decoupled the call from the object. This\n --       attribute is used by the finalization machinery to insert cleanup code\n---       for all additional transient variables found in the transient block.\n+--       for all additional transient objects found in the transient block.\n \n --    C_Pass_By_Copy (Flag125) [implementation base type only]\n --       Defined in record types. Set if a pragma Convention for the record\n@@ -2484,6 +2484,12 @@ package Einfo is\n --       Applies to all entities, true for abstract states that are subject to\n --       option External.\n \n+--    Is_Finalized_Transient (Flag252)\n+--       Defined in constants, loop parameters of generalized iterators, and\n+--       variables. Set when a transient object has been finalized by one of\n+--       the transient finalization mechanisms. The flag prevents the double\n+--       finalization of the object.\n+\n --    Is_Finalizer (synthesized)\n --       Applies to all entities, true for procedures containing finalization\n --       code to process local or library level objects.\n@@ -2595,6 +2601,13 @@ package Einfo is\n --       pragma Ghost or inherit \"ghostness\" from an enclosing construct, and\n --       subject to Assertion_Policy Ghost => Ignore.\n \n+--    Is_Ignored_Transient (Flag295)\n+--       Defined in constants, loop parameters of generalized iterators, and\n+--       variables. Set when a transient object must be processed by one of\n+--       the transient finalization mechanisms. Once marked, a transient is\n+--       intentionally ignored by the general finalization mechanism because\n+--       its clean up actions are context specific.\n+\n --    Is_Immediately_Visible (Flag7)\n --       Defined in all entities. Set if entity is immediately visible, i.e.\n --       is defined in some currently open scope (RM 8.3(4)).\n@@ -2997,13 +3010,6 @@ package Einfo is\n --       Applies to all entities, true for private types and subtypes,\n --       as well as for record with private types as subtypes.\n \n---    Is_Processed_Transient (Flag252)\n---       Defined in variables, loop parameters, and constants, including the\n---       loop parameters of generalized iterators. Set when a transient object\n---       needs to be finalized and has already been processed by the transient\n---       scope machinery. This flag signals the general finalization mechanism\n---       to ignore the transient object.\n-\n --    Is_Protected_Component (synthesized)\n --       Applicable to all entities, true if the entity denotes a private\n --       component of a protected type.\n@@ -5786,8 +5792,9 @@ package Einfo is\n    --    Has_Volatile_Components             (Flag87)\n    --    Is_Atomic                           (Flag85)\n    --    Is_Eliminated                       (Flag124)\n+   --    Is_Finalized_Transient              (Flag252)\n+   --    Is_Ignored_Transient                (Flag295)\n    --    Is_Independent                      (Flag268)\n-   --    Is_Processed_Transient              (Flag252)  (constants only)\n    --    Is_Return_Object                    (Flag209)\n    --    Is_True_Constant                    (Flag163)\n    --    Is_Uplevel_Referenced_Entity        (Flag283)\n@@ -6552,8 +6559,9 @@ package Einfo is\n    --    Has_Volatile_Components             (Flag87)\n    --    Is_Atomic                           (Flag85)\n    --    Is_Eliminated                       (Flag124)\n+   --    Is_Finalized_Transient              (Flag252)\n+   --    Is_Ignored_Transient                (Flag295)\n    --    Is_Independent                      (Flag268)\n-   --    Is_Processed_Transient              (Flag252)\n    --    Is_Return_Object                    (Flag209)\n    --    Is_Safe_To_Reevaluate               (Flag249)\n    --    Is_Shared_Passive                   (Flag60)\n@@ -7062,6 +7070,7 @@ package Einfo is\n    function Is_Entry_Formal                     (Id : E) return B;\n    function Is_Exception_Handler                (Id : E) return B;\n    function Is_Exported                         (Id : E) return B;\n+   function Is_Finalized_Transient              (Id : E) return B;\n    function Is_First_Subtype                    (Id : E) return B;\n    function Is_For_Access_Subtype               (Id : E) return B;\n    function Is_Frozen                           (Id : E) return B;\n@@ -7070,6 +7079,7 @@ package Einfo is\n    function Is_Hidden_Non_Overridden_Subpgm     (Id : E) return B;\n    function Is_Hidden_Open_Scope                (Id : E) return B;\n    function Is_Ignored_Ghost_Entity             (Id : E) return B;\n+   function Is_Ignored_Transient                (Id : E) return B;\n    function Is_Immediately_Visible              (Id : E) return B;\n    function Is_Implementation_Defined           (Id : E) return B;\n    function Is_Imported                         (Id : E) return B;\n@@ -7108,7 +7118,6 @@ package Einfo is\n    function Is_Private_Composite                (Id : E) return B;\n    function Is_Private_Descendant               (Id : E) return B;\n    function Is_Private_Primitive                (Id : E) return B;\n-   function Is_Processed_Transient              (Id : E) return B;\n    function Is_Public                           (Id : E) return B;\n    function Is_Pure                             (Id : E) return B;\n    function Is_Pure_Unit_Access_Type            (Id : E) return B;\n@@ -7736,6 +7745,7 @@ package Einfo is\n    procedure Set_Is_Entry_Formal                 (Id : E; V : B := True);\n    procedure Set_Is_Exception_Handler            (Id : E; V : B := True);\n    procedure Set_Is_Exported                     (Id : E; V : B := True);\n+   procedure Set_Is_Finalized_Transient          (Id : E; V : B := True);\n    procedure Set_Is_First_Subtype                (Id : E; V : B := True);\n    procedure Set_Is_For_Access_Subtype           (Id : E; V : B := True);\n    procedure Set_Is_Formal_Subprogram            (Id : E; V : B := True);\n@@ -7748,6 +7758,7 @@ package Einfo is\n    procedure Set_Is_Hidden_Non_Overridden_Subpgm (Id : E; V : B := True);\n    procedure Set_Is_Hidden_Open_Scope            (Id : E; V : B := True);\n    procedure Set_Is_Ignored_Ghost_Entity         (Id : E; V : B := True);\n+   procedure Set_Is_Ignored_Transient            (Id : E; V : B := True);\n    procedure Set_Is_Immediately_Visible          (Id : E; V : B := True);\n    procedure Set_Is_Implementation_Defined       (Id : E; V : B := True);\n    procedure Set_Is_Imported                     (Id : E; V : B := True);\n@@ -7787,7 +7798,6 @@ package Einfo is\n    procedure Set_Is_Private_Composite            (Id : E; V : B := True);\n    procedure Set_Is_Private_Descendant           (Id : E; V : B := True);\n    procedure Set_Is_Private_Primitive            (Id : E; V : B := True);\n-   procedure Set_Is_Processed_Transient          (Id : E; V : B := True);\n    procedure Set_Is_Public                       (Id : E; V : B := True);\n    procedure Set_Is_Pure                         (Id : E; V : B := True);\n    procedure Set_Is_Pure_Unit_Access_Type        (Id : E; V : B := True);\n@@ -8544,6 +8554,7 @@ package Einfo is\n    pragma Inline (Is_Enumeration_Type);\n    pragma Inline (Is_Exception_Handler);\n    pragma Inline (Is_Exported);\n+   pragma Inline (Is_Finalized_Transient);\n    pragma Inline (Is_First_Subtype);\n    pragma Inline (Is_Fixed_Point_Type);\n    pragma Inline (Is_Floating_Point_Type);\n@@ -8563,6 +8574,7 @@ package Einfo is\n    pragma Inline (Is_Hidden_Non_Overridden_Subpgm);\n    pragma Inline (Is_Hidden_Open_Scope);\n    pragma Inline (Is_Ignored_Ghost_Entity);\n+   pragma Inline (Is_Ignored_Transient);\n    pragma Inline (Is_Immediately_Visible);\n    pragma Inline (Is_Implementation_Defined);\n    pragma Inline (Is_Imported);\n@@ -8612,7 +8624,6 @@ package Einfo is\n    pragma Inline (Is_Private_Descendant);\n    pragma Inline (Is_Private_Primitive);\n    pragma Inline (Is_Private_Type);\n-   pragma Inline (Is_Processed_Transient);\n    pragma Inline (Is_Protected_Type);\n    pragma Inline (Is_Public);\n    pragma Inline (Is_Pure);\n@@ -9039,6 +9050,7 @@ package Einfo is\n    pragma Inline (Set_Is_Entry_Formal);\n    pragma Inline (Set_Is_Exception_Handler);\n    pragma Inline (Set_Is_Exported);\n+   pragma Inline (Set_Is_Finalized_Transient);\n    pragma Inline (Set_Is_First_Subtype);\n    pragma Inline (Set_Is_For_Access_Subtype);\n    pragma Inline (Set_Is_Formal_Subprogram);\n@@ -9051,6 +9063,7 @@ package Einfo is\n    pragma Inline (Set_Is_Hidden_Non_Overridden_Subpgm);\n    pragma Inline (Set_Is_Hidden_Open_Scope);\n    pragma Inline (Set_Is_Ignored_Ghost_Entity);\n+   pragma Inline (Set_Is_Ignored_Transient);\n    pragma Inline (Set_Is_Immediately_Visible);\n    pragma Inline (Set_Is_Implementation_Defined);\n    pragma Inline (Set_Is_Imported);\n@@ -9090,7 +9103,6 @@ package Einfo is\n    pragma Inline (Set_Is_Private_Composite);\n    pragma Inline (Set_Is_Private_Descendant);\n    pragma Inline (Set_Is_Private_Primitive);\n-   pragma Inline (Set_Is_Processed_Transient);\n    pragma Inline (Set_Is_Public);\n    pragma Inline (Set_Is_Pure);\n    pragma Inline (Set_Is_Pure_Unit_Access_Type);"}, {"sha": "7d1db3e4987209e5a5f4cb60be1a934b0d267ffa", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 1062, "deletions": 503, "changes": 1565, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/937e96763e42c48c29e3a5edf2eea3fb2c59fb27/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/937e96763e42c48c29e3a5edf2eea3fb2c59fb27/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=937e96763e42c48c29e3a5edf2eea3fb2c59fb27", "patch": "@@ -35,10 +35,12 @@ with Exp_Ch3;  use Exp_Ch3;\n with Exp_Ch6;  use Exp_Ch6;\n with Exp_Ch7;  use Exp_Ch7;\n with Exp_Ch9;  use Exp_Ch9;\n+with Exp_Ch11; use Exp_Ch11;\n with Exp_Disp; use Exp_Disp;\n with Exp_Tss;  use Exp_Tss;\n with Fname;    use Fname;\n with Freeze;   use Freeze;\n+with Inline;   use Inline;\n with Itypes;   use Itypes;\n with Lib;      use Lib;\n with Namet;    use Namet;\n@@ -95,6 +97,25 @@ package body Exp_Aggr is\n    --  Returns true if N is an aggregate used to initialize the components\n    --  of a statically allocated dispatch table.\n \n+   function Late_Expansion\n+     (N      : Node_Id;\n+      Typ    : Entity_Id;\n+      Target : Node_Id) return List_Id;\n+   --  This routine implements top-down expansion of nested aggregates. In\n+   --  doing so, it avoids the generation of temporaries at each level. N is\n+   --  a nested record or array aggregate with the Expansion_Delayed flag.\n+   --  Typ is the expected type of the aggregate. Target is a (duplicatable)\n+   --  expression that will hold the result of the aggregate expansion.\n+\n+   function Make_OK_Assignment_Statement\n+     (Sloc       : Source_Ptr;\n+      Name       : Node_Id;\n+      Expression : Node_Id) return Node_Id;\n+   --  This is like Make_Assignment_Statement, except that Assignment_OK\n+   --  is set in the left operand. All assignments built by this unit use\n+   --  this routine. This is needed to deal with assignments to initialized\n+   --  constants that are done in place.\n+\n    function Must_Slide\n      (Obj_Type : Entity_Id;\n       Typ      : Entity_Id) return Boolean;\n@@ -109,6 +130,41 @@ package body Exp_Aggr is\n    --  when a component may be given with bounds that differ from those of the\n    --  component type.\n \n+   function Number_Of_Choices (N : Node_Id) return Nat;\n+   --  Returns the number of discrete choices (not including the others choice\n+   --  if present) contained in (sub-)aggregate N.\n+\n+   procedure Process_Transient_Component\n+     (Loc        : Source_Ptr;\n+      Comp_Typ   : Entity_Id;\n+      Init_Expr  : Node_Id;\n+      Fin_Call   : out Node_Id;\n+      Hook_Clear : out Node_Id;\n+      Aggr       : Node_Id := Empty;\n+      Stmts      : List_Id := No_List);\n+   --  Subsidiary to the expansion of array and record aggregates. Generate\n+   --  part of the necessary code to finalize a transient component. Comp_Typ\n+   --  is the component type. Init_Expr is the initialization expression of the\n+   --  component which is always a function call. Fin_Call is the finalization\n+   --  call used to clean up the transient function result. Hook_Clear is the\n+   --  hook reset statement. Aggr and Stmts both control the placement of the\n+   --  generated code. Aggr is the related aggregate. If present, all code is\n+   --  inserted prior to Aggr using Insert_Action. Stmts is the initialization\n+   --  statements of the component. If present, all code is added to Stmts.\n+\n+   procedure Process_Transient_Component_Completion\n+     (Loc        : Source_Ptr;\n+      Aggr       : Node_Id;\n+      Fin_Call   : Node_Id;\n+      Hook_Clear : Node_Id;\n+      Stmts      : List_Id);\n+   --  Subsidiary to the expansion of array and record aggregates. Generate\n+   --  part of the necessary code to finalize a transient component. Aggr is\n+   --  the related aggregate. Fin_Clear is the finalization call used to clean\n+   --  up the transient component. Hook_Clear is the hook reset statment. Stmts\n+   --  is the initialization statement list for the component. All generated\n+   --  code is added to Stmts.\n+\n    procedure Sort_Case_Table (Case_Table : in out Case_Table_Type);\n    --  Sort the Case Table using the Lower Bound of each Choice as the key.\n    --  A simple insertion sort is used since the number of choices in a case\n@@ -260,29 +316,6 @@ package body Exp_Aggr is\n    --  an array that is suitable for this optimization: it returns True if Typ\n    --  is a two dimensional bit packed array with component size 1, 2, or 4.\n \n-   function Late_Expansion\n-     (N      : Node_Id;\n-      Typ    : Entity_Id;\n-      Target : Node_Id) return List_Id;\n-   --  This routine implements top-down expansion of nested aggregates. In\n-   --  doing so, it avoids the generation of temporaries at each level. N is\n-   --  a nested record or array aggregate with the Expansion_Delayed flag.\n-   --  Typ is the expected type of the aggregate. Target is a (duplicatable)\n-   --  expression that will hold the result of the aggregate expansion.\n-\n-   function Make_OK_Assignment_Statement\n-     (Sloc       : Source_Ptr;\n-      Name       : Node_Id;\n-      Expression : Node_Id) return Node_Id;\n-   --  This is like Make_Assignment_Statement, except that Assignment_OK\n-   --  is set in the left operand. All assignments built by this unit use\n-   --  this routine. This is needed to deal with assignments to initialized\n-   --  constants that are done in place.\n-\n-   function Number_Of_Choices (N : Node_Id) return Nat;\n-   --  Returns the number of discrete choices (not including the others choice\n-   --  if present) contained in (sub-)aggregate N.\n-\n    function Packed_Array_Aggregate_Handled (N : Node_Id) return Boolean;\n    --  Given an array aggregate, this function handles the case of a packed\n    --  array aggregate with all constant values, where the aggregate can be\n@@ -794,14 +827,18 @@ package body Exp_Aggr is\n       function Index_Base_Name return Node_Id;\n       --  Returns a new reference to the index type name\n \n-      function Gen_Assign (Ind : Node_Id; Expr : Node_Id) return List_Id;\n+      function Gen_Assign\n+        (Ind     : Node_Id;\n+         Expr    : Node_Id;\n+         In_Loop : Boolean := False) return List_Id;\n       --  Ind must be a side-effect-free expression. If the input aggregate N\n       --  to Build_Loop contains no subaggregates, then this function returns\n       --  the assignment statement:\n       --\n       --     Into (Indexes, Ind) := Expr;\n       --\n-      --  Otherwise we call Build_Code recursively\n+      --  Otherwise we call Build_Code recursively. Flag In_Loop should be set\n+      --  when the assignment appears within a generated loop.\n       --\n       --  Ada 2005 (AI-287): In case of default initialized component, Expr\n       --  is empty and we generate a call to the corresponding IP subprogram.\n@@ -815,9 +852,9 @@ package body Exp_Aggr is\n       --        Into (Indexes, J) := Expr;\n       --     end loop;\n       --\n-      --  Otherwise we call Build_Code recursively.\n-      --  As an optimization if the loop covers 3 or fewer scalar elements we\n-      --  generate a sequence of assignments.\n+      --  Otherwise we call Build_Code recursively. As an optimization if the\n+      --  loop covers 3 or fewer scalar elements we generate a sequence of\n+      --  assignments.\n \n       function Gen_While (L, H : Node_Id; Expr : Node_Id) return List_Id;\n       --  Nodes L and H must be side-effect-free expressions. If the input\n@@ -1016,20 +1053,36 @@ package body Exp_Aggr is\n       -- Gen_Assign --\n       ----------------\n \n-      function Gen_Assign (Ind : Node_Id; Expr : Node_Id) return List_Id is\n+      function Gen_Assign\n+        (Ind     : Node_Id;\n+         Expr    : Node_Id;\n+         In_Loop : Boolean := False) return List_Id\n+       is\n          function Add_Loop_Actions (Lis : List_Id) return List_Id;\n-         --  Collect insert_actions generated in the construction of a\n-         --  loop, and prepend them to the sequence of assignments to\n-         --  complete the eventual body of the loop.\n-\n-         function Ctrl_Init_Expression\n-           (Comp_Typ : Entity_Id;\n-            Stmts    : List_Id) return Node_Id;\n-         --  Perform in-place side effect removal if expression Expr denotes a\n-         --  controlled function call. Return a reference to the entity which\n-         --  captures the result of the call. Comp_Typ is the expected type of\n-         --  the component. Stmts is the list of initialization statmenets. Any\n-         --  generated code is added to Stmts.\n+         --  Collect insert_actions generated in the construction of a loop,\n+         --  and prepend them to the sequence of assignments to complete the\n+         --  eventual body of the loop.\n+\n+         procedure Initialize_Array_Component\n+           (Arr_Comp  : Node_Id;\n+            Comp_Typ  : Node_Id;\n+            Init_Expr : Node_Id;\n+            Stmts     : List_Id);\n+         --  Perform the initialization of array component Arr_Comp with\n+         --  expected type Comp_Typ. Init_Expr denotes the initialization\n+         --  expression of the array component. All generated code is added\n+         --  to list Stmts.\n+\n+         procedure Initialize_Ctrl_Array_Component\n+           (Arr_Comp  : Node_Id;\n+            Comp_Typ  : Entity_Id;\n+            Init_Expr : Node_Id;\n+            Stmts     : List_Id);\n+         --  Perform the initialization of array component Arr_Comp when its\n+         --  expected type Comp_Typ needs finalization actions. Init_Expr is\n+         --  the initialization expression of the array component. All hook-\n+         --  related declarations are inserted prior to aggregate N. Remaining\n+         --  code is added to list Stmts.\n \n          ----------------------\n          -- Add_Loop_Actions --\n@@ -1058,79 +1111,208 @@ package body Exp_Aggr is\n             end if;\n          end Add_Loop_Actions;\n \n-         --------------------------\n-         -- Ctrl_Init_Expression --\n-         --------------------------\n+         --------------------------------\n+         -- Initialize_Array_Component --\n+         --------------------------------\n \n-         function Ctrl_Init_Expression\n-           (Comp_Typ : Entity_Id;\n-            Stmts    : List_Id) return Node_Id\n-         is\n+         procedure Initialize_Array_Component\n+           (Arr_Comp  : Node_Id;\n+            Comp_Typ  : Node_Id;\n             Init_Expr : Node_Id;\n-            Obj_Id    : Entity_Id;\n-            Ptr_Typ   : Entity_Id;\n+            Stmts     : List_Id)\n+         is\n+            Full_Typ  : constant Entity_Id := Underlying_Type (Comp_Typ);\n+            Init_Stmt : Node_Id;\n \n          begin\n-            Init_Expr := New_Copy_Tree (Expr);\n+            --  Initialize the array element. Generate:\n \n-            --  Perform a preliminary analysis and resolution to determine\n-            --  what the expression denotes. Note that a function call may\n-            --  appear as an identifier or an indexed component.\n+            --    Arr_Comp := Init_Expr;\n \n-            Preanalyze_And_Resolve (Init_Expr, Comp_Typ);\n+            --  Note that the initialization expression is replicated because\n+            --  it has to be reevaluated within a generated loop.\n \n-            --  The initialization expression is a controlled function call.\n-            --  Perform in-place removal of side effects to avoid creating a\n-            --  transient scope. In the end the temporary function result is\n-            --  finalized by the general finalization machinery.\n+            Init_Stmt :=\n+              Make_OK_Assignment_Statement (Loc,\n+                Name       => New_Copy_Tree (Arr_Comp),\n+                Expression => New_Copy_Tree (Init_Expr));\n+            Set_No_Ctrl_Actions (Init_Stmt);\n \n-            if Nkind (Init_Expr) = N_Function_Call then\n+            --  If this is an aggregate for an array of arrays, each\n+            --  subaggregate will be expanded as well, and even with\n+            --  No_Ctrl_Actions the assignments of inner components will\n+            --  require attachment in their assignments to temporaries. These\n+            --  temporaries must be finalized for each subaggregate. Generate:\n \n-               --  Suppress the removal of side effects by generatal analysis\n-               --  because this behavior is emulated here.\n+            --    begin\n+            --       Arr_Comp := Init_Expr;\n+            --    end;\n \n-               Set_No_Side_Effect_Removal (Init_Expr);\n+            if Present (Comp_Typ)\n+              and then Needs_Finalization (Comp_Typ)\n+              and then Is_Array_Type (Comp_Typ)\n+            then\n+               Init_Stmt :=\n+                 Make_Block_Statement (Loc,\n+                   Handled_Statement_Sequence =>\n+                     Make_Handled_Sequence_Of_Statements (Loc,\n+                       Statements => New_List (Init_Stmt)));\n+            end if;\n \n-               --  Generate:\n-               --    type Ptr_Typ is access all Comp_Typ;\n+            Append_To (Stmts, Init_Stmt);\n \n-               Ptr_Typ := Make_Temporary (Loc, 'A');\n+            --  Adjust the tag due to a possible view conversion. Generate:\n \n+            --    Arr_Comp._tag := Full_TypP;\n+\n+            if Tagged_Type_Expansion\n+              and then Present (Comp_Typ)\n+              and then Is_Tagged_Type (Comp_Typ)\n+            then\n                Append_To (Stmts,\n-                 Make_Full_Type_Declaration (Loc,\n-                   Defining_Identifier => Ptr_Typ,\n-                   Type_Definition     =>\n-                     Make_Access_To_Object_Definition (Loc,\n-                       All_Present        => True,\n-                       Subtype_Indication =>\n-                         New_Occurrence_Of (Comp_Typ, Loc))));\n+                 Make_OK_Assignment_Statement (Loc,\n+                   Name       =>\n+                     Make_Selected_Component (Loc,\n+                       Prefix        => New_Copy_Tree (Arr_Comp),\n+                       Selector_Name =>\n+                         New_Occurrence_Of\n+                           (First_Tag_Component (Full_Typ), Loc)),\n+\n+                   Expression =>\n+                     Unchecked_Convert_To (RTE (RE_Tag),\n+                       New_Occurrence_Of\n+                         (Node (First_Elmt (Access_Disp_Table (Full_Typ))),\n+                          Loc))));\n+            end if;\n \n-               --  Generate:\n-               --    Obj : constant Ptr_Typ := Init_Expr'Reference;\n+            --  Adjust the array component. Controlled subaggregates are not\n+            --  considered because each of their individual elements will\n+            --  receive an adjustment of its own. Generate:\n \n-               Obj_Id := Make_Temporary (Loc, 'R');\n+            --    [Deep_]Adjust (Arr_Comp);\n \n+            if Present (Comp_Typ)\n+              and then Needs_Finalization (Comp_Typ)\n+              and then not Is_Limited_Type (Comp_Typ)\n+              and then not\n+                (Is_Array_Type (Comp_Typ)\n+                  and then Is_Controlled (Component_Type (Comp_Typ))\n+                  and then Nkind (Expr) = N_Aggregate)\n+            then\n                Append_To (Stmts,\n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier => Obj_Id,\n-                   Object_Definition   => New_Occurrence_Of (Ptr_Typ, Loc),\n-                   Expression          => Make_Reference (Loc, Init_Expr)));\n+                 Make_Adjust_Call\n+                   (Obj_Ref => New_Copy_Tree (Arr_Comp),\n+                    Typ     => Comp_Typ));\n+            end if;\n+         end Initialize_Array_Component;\n \n-               --  Generate:\n-               --    Obj.all;\n+         -------------------------------------\n+         -- Initialize_Ctrl_Array_Component --\n+         -------------------------------------\n \n-               return\n-                 Make_Explicit_Dereference (Loc,\n-                   Prefix => New_Occurrence_Of (Obj_Id, Loc));\n+         procedure Initialize_Ctrl_Array_Component\n+           (Arr_Comp  : Node_Id;\n+            Comp_Typ  : Entity_Id;\n+            Init_Expr : Node_Id;\n+            Stmts     : List_Id)\n+         is\n+            Act_Aggr   : Node_Id;\n+            Act_Stmts  : List_Id;\n+            Fin_Call   : Node_Id;\n+            Hook_Clear : Node_Id;\n \n-            --  Otherwise the initialization expression denotes a controlled\n-            --  object. There is nothing special to be done here as there is\n-            --  no possible transient scope involvement.\n+            In_Place_Expansion : Boolean;\n+            --  Flag set when a nonlimited controlled function call requires\n+            --  in-place expansion.\n \n-            else\n-               return Init_Expr;\n+         begin\n+            --  Perform a preliminary analysis and resolution to determine what\n+            --  the initialization expression denotes. An unanalyzed function\n+            --  call may appear as an identifier or an indexed component.\n+\n+            if Nkind_In (Init_Expr, N_Function_Call,\n+                                    N_Identifier,\n+                                    N_Indexed_Component)\n+              and then not Analyzed (Init_Expr)\n+            then\n+               Preanalyze_And_Resolve (Init_Expr, Comp_Typ);\n+            end if;\n+\n+            In_Place_Expansion :=\n+              Nkind (Init_Expr) = N_Function_Call\n+                and then not Is_Limited_Type (Comp_Typ);\n+\n+            --  The initialization expression is a controlled function call.\n+            --  Perform in-place removal of side effects to avoid creating a\n+            --  transient scope, which leads to premature finalization.\n+\n+            --  This in-place expansion is not performed for limited transient\n+            --  objects because the initialization is already done in-place.\n+\n+            if In_Place_Expansion then\n+\n+               --  Suppress the removal of side effects by general analysis\n+               --  because this behavior is emulated here. This avoids the\n+               --  generation of a transient scope, which leads to out-of-order\n+               --  adjustment and finalization.\n+\n+               Set_No_Side_Effect_Removal (Init_Expr);\n+\n+               --  When the transient component initialization is related to a\n+               --  range or an \"others\", keep all generated statements within\n+               --  the enclosing loop. This way the controlled function call\n+               --  will be evaluated at each iteration, and its result will be\n+               --  finalized at the end of each iteration.\n+\n+               if In_Loop then\n+                  Act_Aggr  := Empty;\n+                  Act_Stmts := Stmts;\n+\n+               --  Otherwise this is a single component initialization. Hook-\n+               --  related statements are inserted prior to the aggregate.\n+\n+               else\n+                  Act_Aggr  := N;\n+                  Act_Stmts := No_List;\n+               end if;\n+\n+               --  Install all hook-related declarations and prepare the clean\n+               --  up statements.\n+\n+               Process_Transient_Component\n+                 (Loc        => Loc,\n+                  Comp_Typ   => Comp_Typ,\n+                  Init_Expr  => Init_Expr,\n+                  Fin_Call   => Fin_Call,\n+                  Hook_Clear => Hook_Clear,\n+                  Aggr       => Act_Aggr,\n+                  Stmts      => Act_Stmts);\n             end if;\n-         end Ctrl_Init_Expression;\n+\n+            --  Use the noncontrolled component initialization circuitry to\n+            --  assign the result of the function call to the array element.\n+            --  This also performs subaggregate wrapping, tag adjustment, and\n+            --  [deep] adjustment of the array element.\n+\n+            Initialize_Array_Component\n+              (Arr_Comp  => Arr_Comp,\n+               Comp_Typ  => Comp_Typ,\n+               Init_Expr => Init_Expr,\n+               Stmts     => Stmts);\n+\n+            --  At this point the array element is fully initialized. Complete\n+            --  the processing of the controlled array component by finalizing\n+            --  the transient function result.\n+\n+            if In_Place_Expansion then\n+               Process_Transient_Component_Completion\n+                 (Loc        => Loc,\n+                  Aggr       => N,\n+                  Fin_Call   => Fin_Call,\n+                  Hook_Clear => Hook_Clear,\n+                  Stmts      => Stmts);\n+            end if;\n+         end Initialize_Ctrl_Array_Component;\n \n          --  Local variables\n \n@@ -1140,8 +1322,6 @@ package body Exp_Aggr is\n          Expr_Q       : Node_Id;\n          Indexed_Comp : Node_Id;\n          New_Indexes  : List_Id;\n-         Stmt         : Node_Id;\n-         Stmt_Expr    : Node_Id;\n \n       --  Start of processing for Gen_Assign\n \n@@ -1253,7 +1433,7 @@ package body Exp_Aggr is\n                --  component associations that provide different bounds from\n                --  those of the component type, and sliding must occur. Instead\n                --  of decomposing the current aggregate assignment, force the\n-               --  re-analysis of the assignment, so that a temporary will be\n+               --  reanalysis of the assignment, so that a temporary will be\n                --  generated in the usual fashion, and sliding will take place.\n \n                if Nkind (Parent (N)) = N_Assignment_Statement\n@@ -1272,6 +1452,59 @@ package body Exp_Aggr is\n             end if;\n          end if;\n \n+         if Present (Expr) then\n+\n+            --  Handle an initialization expression of a controlled type in\n+            --  case it denotes a function call. In general such a scenario\n+            --  will produce a transient scope, but this will lead to wrong\n+            --  order of initialization, adjustment, and finalization in the\n+            --  context of aggregates.\n+\n+            --    Target (1) := Ctrl_Func_Call;\n+\n+            --    begin                                  --  scope\n+            --       Trans_Obj : ... := Ctrl_Func_Call;  --  object\n+            --       Target (1) := Trans_Obj;\n+            --       Finalize (Trans_Obj);\n+            --    end;\n+            --    Target (1)._tag := ...;\n+            --    Adjust (Target (1));\n+\n+            --  In the example above, the call to Finalize occurs too early\n+            --  and as a result it may leave the array component in a bad\n+            --  state. Finalization of the transient object should really\n+            --  happen after adjustment.\n+\n+            --  To avoid this scenario, perform in-place side-effect removal\n+            --  of the function call. This eliminates the transient property\n+            --  of the function result and ensures correct order of actions.\n+\n+            --    Res : ... := Ctrl_Func_Call;\n+            --    Target (1) := Res;\n+            --    Target (1)._tag := ...;\n+            --    Adjust (Target (1));\n+            --    Finalize (Res);\n+\n+            if Present (Comp_Typ)\n+              and then Needs_Finalization (Comp_Typ)\n+              and then Nkind (Expr) /= N_Aggregate\n+            then\n+               Initialize_Ctrl_Array_Component\n+                 (Arr_Comp  => Indexed_Comp,\n+                  Comp_Typ  => Comp_Typ,\n+                  Init_Expr => Expr,\n+                  Stmts     => Stmts);\n+\n+            --  Otherwise perform simple component initialization\n+\n+            else\n+               Initialize_Array_Component\n+                 (Arr_Comp  => Indexed_Comp,\n+                  Comp_Typ  => Comp_Typ,\n+                  Init_Expr => Expr,\n+                  Stmts     => Stmts);\n+            end if;\n+\n          --  Ada 2005 (AI-287): In case of default initialized component, call\n          --  the initialization subprogram associated with the component type.\n          --  If the component type is an access type, add an explicit null\n@@ -1283,7 +1516,7 @@ package body Exp_Aggr is\n          --  its Initialize procedure explicitly, because there is no explicit\n          --  object creation that will invoke it otherwise.\n \n-         if No (Expr) then\n+         else\n             if Present (Base_Init_Proc (Base_Type (Ctype)))\n               or else Has_Task (Base_Type (Ctype))\n             then\n@@ -1316,154 +1549,6 @@ package body Exp_Aggr is\n                    (Obj_Ref => New_Copy_Tree (Indexed_Comp),\n                     Typ     => Ctype));\n             end if;\n-\n-         else\n-            --  Handle an initialization expression of a controlled type in\n-            --  case it denotes a function call. In general such a scenario\n-            --  will produce a transient scope, but this will lead to wrong\n-            --  order of initialization, adjustment, and finalization in the\n-            --  context of aggregates.\n-\n-            --    Arr_Comp (1) := Ctrl_Func_Call;\n-\n-            --    begin                                  --  transient scope\n-            --       Trans_Obj : ... := Ctrl_Func_Call;  --  transient object\n-            --       Arr_Comp (1) := Trans_Obj;\n-            --       Finalize (Trans_Obj);\n-            --    end;\n-            --    Arr_Comp (1)._tag := ...;\n-            --    Adjust (Arr_Comp (1));\n-\n-            --  In the example above, the call to Finalize occurs too early\n-            --  and as a result it may leave the array component in a bad\n-            --  state. Finalization of the transient object should really\n-            --  happen after adjustment.\n-\n-            --  To avoid this scenario, perform in-place side effect removal\n-            --  of the function call. This eliminates the transient property\n-            --  of the function result and ensures correct order of actions.\n-            --  Note that the function result behaves as a source controlled\n-            --  object and is finalized by the general finalization mechanism.\n-\n-            --    begin\n-            --       Res : ... := Ctrl_Func_Call;\n-            --       Arr_Comp (1) := Res;\n-            --       Arr_Comp (1)._tag := ...;\n-            --       Adjust (Arr_Comp (1));\n-            --    at end\n-            --       Finalize (Res);\n-            --    end;\n-\n-            --  There is no need to perform this kind of light expansion when\n-            --  the component type is limited controlled because everything is\n-            --  already done in place.\n-\n-            if Present (Comp_Typ)\n-              and then Needs_Finalization (Comp_Typ)\n-              and then not Is_Limited_Type (Comp_Typ)\n-              and then Nkind (Expr) /= N_Aggregate\n-            then\n-               Stmt_Expr := Ctrl_Init_Expression (Comp_Typ, Stmts);\n-\n-            --  Otherwise use the initialization expression directly\n-\n-            else\n-               Stmt_Expr := New_Copy_Tree (Expr);\n-            end if;\n-\n-            Stmt :=\n-              Make_OK_Assignment_Statement (Loc,\n-                Name       => New_Copy_Tree (Indexed_Comp),\n-                Expression => Stmt_Expr);\n-\n-            --  The target of the assignment may not have been initialized,\n-            --  so it is not possible to call Finalize as expected in normal\n-            --  controlled assignments. We must also avoid using the primitive\n-            --  _assign (which depends on a valid target, and may for example\n-            --  perform discriminant checks on it).\n-\n-            --  Both Finalize and usage of _assign are disabled by setting\n-            --  No_Ctrl_Actions on the assignment. The rest of the controlled\n-            --  actions are done manually with the proper finalization list\n-            --  coming from the context.\n-\n-            Set_No_Ctrl_Actions (Stmt);\n-\n-            --  If this is an aggregate for an array of arrays, each\n-            --  subaggregate will be expanded as well, and even with\n-            --  No_Ctrl_Actions the assignments of inner components will\n-            --  require attachment in their assignments to temporaries. These\n-            --  temporaries must be finalized for each subaggregate, to prevent\n-            --  multiple attachments of the same temporary location to same\n-            --  finalization chain (and consequently circular lists). To ensure\n-            --  that finalization takes place for each subaggregate we wrap the\n-            --  assignment in a block.\n-\n-            if Present (Comp_Typ)\n-              and then Needs_Finalization (Comp_Typ)\n-              and then Is_Array_Type (Comp_Typ)\n-              and then Present (Expr)\n-            then\n-               Stmt :=\n-                 Make_Block_Statement (Loc,\n-                   Handled_Statement_Sequence =>\n-                     Make_Handled_Sequence_Of_Statements (Loc,\n-                       Statements => New_List (Stmt)));\n-            end if;\n-\n-            Append_To (Stmts, Stmt);\n-\n-            --  Adjust the tag due to a possible view conversion\n-\n-            if Present (Comp_Typ)\n-              and then Is_Tagged_Type (Comp_Typ)\n-              and then Tagged_Type_Expansion\n-            then\n-               declare\n-                  Full_Typ : constant Entity_Id := Underlying_Type (Comp_Typ);\n-\n-               begin\n-                  Append_To (Stmts,\n-                    Make_OK_Assignment_Statement (Loc,\n-                      Name       =>\n-                        Make_Selected_Component (Loc,\n-                          Prefix        =>  New_Copy_Tree (Indexed_Comp),\n-                          Selector_Name =>\n-                            New_Occurrence_Of\n-                              (First_Tag_Component (Full_Typ), Loc)),\n-\n-                      Expression =>\n-                        Unchecked_Convert_To (RTE (RE_Tag),\n-                          New_Occurrence_Of\n-                            (Node (First_Elmt (Access_Disp_Table (Full_Typ))),\n-                             Loc))));\n-               end;\n-            end if;\n-\n-            --  Adjust and attach the component to the proper final list, which\n-            --  can be the controller of the outer record object or the final\n-            --  list associated with the scope.\n-\n-            --  If the component is itself an array of controlled types, whose\n-            --  value is given by a subaggregate, then the attach calls have\n-            --  been generated when individual subcomponent are assigned, and\n-            --  must not be done again to prevent malformed finalization chains\n-            --  (see comments above, concerning the creation of a block to hold\n-            --  inner finalization actions).\n-\n-            if Present (Comp_Typ)\n-              and then Needs_Finalization (Comp_Typ)\n-              and then not Is_Limited_Type (Comp_Typ)\n-              and then not\n-                (Is_Array_Type (Comp_Typ)\n-                  and then Is_Controlled (Component_Type (Comp_Typ))\n-                  and then Nkind (Expr) = N_Aggregate)\n-            then\n-               Append_To (Stmts,\n-                 Make_Adjust_Call\n-                   (Obj_Ref => New_Copy_Tree (Indexed_Comp),\n-                    Typ     => Comp_Typ));\n-            end if;\n          end if;\n \n          return Add_Loop_Actions (Stmts);\n@@ -1545,7 +1630,6 @@ package body Exp_Aggr is\n            and then Local_Compile_Time_Known_Value (H)\n            and then Local_Expr_Value (H) - Local_Expr_Value (L) <= 2\n          then\n-\n             Append_List_To (S, Gen_Assign (New_Copy_Tree (L), Expr));\n             Append_List_To (S, Gen_Assign (Add (1, To => L), Expr));\n \n@@ -1600,7 +1684,8 @@ package body Exp_Aggr is\n \n          --  Construct the statements to execute in the loop body\n \n-         L_Body := Gen_Assign (New_Occurrence_Of (L_J, Loc), Expr);\n+         L_Body :=\n+           Gen_Assign (New_Occurrence_Of (L_J, Loc), Expr, In_Loop => True);\n \n          --  Construct the final loop\n \n@@ -1707,8 +1792,9 @@ package body Exp_Aggr is\n               Expression => W_Index_Succ);\n \n          Append_To (W_Body, W_Increment);\n+\n          Append_List_To (W_Body,\n-           Gen_Assign (New_Occurrence_Of (W_J, Loc), Expr));\n+           Gen_Assign (New_Occurrence_Of (W_J, Loc), Expr, In_Loop => True));\n \n          --  Construct the final loop\n \n@@ -1784,14 +1870,9 @@ package body Exp_Aggr is\n          end if;\n       end Local_Expr_Value;\n \n-      --  Build_Array_Aggr_Code Variables\n-\n-      Assoc  : Node_Id;\n-      Choice : Node_Id;\n-      Expr   : Node_Id;\n-      Typ    : Entity_Id;\n+      --  Local variables\n \n-      Others_Assoc        : Node_Id := Empty;\n+      New_Code : constant List_Id := New_List;\n \n       Aggr_L : constant Node_Id := Low_Bound (Aggregate_Bounds (N));\n       Aggr_H : constant Node_Id := High_Bound (Aggregate_Bounds (N));\n@@ -1803,8 +1884,12 @@ package body Exp_Aggr is\n       Aggr_High : constant Node_Id := Duplicate_Subexpr_No_Checks (Aggr_H);\n       --  After Duplicate_Subexpr these are side-effect free\n \n-      Low        : Node_Id;\n-      High       : Node_Id;\n+      Assoc  : Node_Id;\n+      Choice : Node_Id;\n+      Expr   : Node_Id;\n+      High   : Node_Id;\n+      Low    : Node_Id;\n+      Typ    : Entity_Id;\n \n       Nb_Choices : Nat := 0;\n       Table      : Case_Table_Type (1 .. Number_Of_Choices (N));\n@@ -1813,7 +1898,7 @@ package body Exp_Aggr is\n       Nb_Elements : Int;\n       --  Number of elements in the positional aggregate\n \n-      New_Code : constant List_Id := New_List;\n+      Others_Assoc : Node_Id := Empty;\n \n    --  Start of processing for Build_Array_Aggr_Code\n \n@@ -2076,13 +2161,42 @@ package body Exp_Aggr is\n       --  The type of the aggregate is a subtype created ealier using the\n       --  given values of the discriminant components of the aggregate.\n \n+      procedure Initialize_Ctrl_Record_Component\n+        (Rec_Comp  : Node_Id;\n+         Comp_Typ  : Entity_Id;\n+         Init_Expr : Node_Id;\n+         Stmts     : List_Id);\n+      --  Perform the initialization of controlled record component Rec_Comp.\n+      --  Comp_Typ is the component type. Init_Expr is the initialization\n+      --  expression for the record component. Hook-related declarations are\n+      --  inserted prior to aggregate N using Insert_Action. All remaining\n+      --  generated code is added to list Stmts.\n+\n+      procedure Initialize_Record_Component\n+        (Rec_Comp  : Node_Id;\n+         Comp_Typ  : Entity_Id;\n+         Init_Expr : Node_Id;\n+         Stmts     : List_Id);\n+      --  Perform the initialization of record component Rec_Comp. Comp_Typ\n+      --  is the component type. Init_Expr is the initialization expression\n+      --  of the record component. All generated code is added to list Stmts.\n+\n       function Is_Int_Range_Bounds (Bounds : Node_Id) return Boolean;\n       --  Check whether Bounds is a range node and its lower and higher bounds\n       --  are integers literals.\n \n-      ---------------------------------\n-      -- Ancestor_Discriminant_Value --\n-      ---------------------------------\n+      function Replace_Type (Expr : Node_Id) return Traverse_Result;\n+      --  If the aggregate contains a self-reference, traverse each expression\n+      --  to replace a possible self-reference with a reference to the proper\n+      --  component of the target of the assignment.\n+\n+      function Rewrite_Discriminant (Expr : Node_Id) return Traverse_Result;\n+      --  If default expression of a component mentions a discriminant of the\n+      --  type, it must be rewritten as the discriminant of the target object.\n+\n+      ---------------------------------\n+      -- Ancestor_Discriminant_Value --\n+      ---------------------------------\n \n       function Ancestor_Discriminant_Value (Disc : Entity_Id) return Node_Id is\n          Assoc        : Node_Id;\n@@ -2259,6 +2373,39 @@ package body Exp_Aggr is\n          return Typ_Lo <= Agg_Lo and then Agg_Hi <= Typ_Hi;\n       end Compatible_Int_Bounds;\n \n+      -----------------------------------\n+      -- Generate_Finalization_Actions --\n+      -----------------------------------\n+\n+      procedure Generate_Finalization_Actions is\n+      begin\n+         --  Do the work only the first time this is called\n+\n+         if Finalization_Done then\n+            return;\n+         end if;\n+\n+         Finalization_Done := True;\n+\n+         --  Determine the external finalization list. It is either the\n+         --  finalization list of the outer scope or the one coming from an\n+         --  outer aggregate. When the target is not a temporary, the proper\n+         --  scope is the scope of the target rather than the potentially\n+         --  transient current scope.\n+\n+         if Is_Controlled (Typ) and then Ancestor_Is_Subtype_Mark then\n+            Ref := Convert_To (Init_Typ, New_Copy_Tree (Target));\n+            Set_Assignment_OK (Ref);\n+\n+            Append_To (L,\n+              Make_Procedure_Call_Statement (Loc,\n+                Name                   =>\n+                  New_Occurrence_Of\n+                    (Find_Prim_Op (Init_Typ, Name_Initialize), Loc),\n+                Parameter_Associations => New_List (New_Copy_Tree (Ref))));\n+         end if;\n+      end Generate_Finalization_Actions;\n+\n       --------------------------------\n       -- Get_Constraint_Association --\n       --------------------------------\n@@ -2528,80 +2675,167 @@ package body Exp_Aggr is\n          end loop;\n       end Init_Stored_Discriminants;\n \n-      -------------------------\n-      -- Is_Int_Range_Bounds --\n-      -------------------------\n+      --------------------------------------\n+      -- Initialize_Ctrl_Record_Component --\n+      --------------------------------------\n \n-      function Is_Int_Range_Bounds (Bounds : Node_Id) return Boolean is\n-      begin\n-         return Nkind (Bounds) = N_Range\n-           and then Nkind (Low_Bound  (Bounds)) = N_Integer_Literal\n-           and then Nkind (High_Bound (Bounds)) = N_Integer_Literal;\n-      end Is_Int_Range_Bounds;\n+      procedure Initialize_Ctrl_Record_Component\n+        (Rec_Comp  : Node_Id;\n+         Comp_Typ  : Entity_Id;\n+         Init_Expr : Node_Id;\n+         Stmts     : List_Id)\n+      is\n+         Fin_Call   : Node_Id;\n+         Hook_Clear : Node_Id;\n \n-      -----------------------------------\n-      -- Generate_Finalization_Actions --\n-      -----------------------------------\n+         In_Place_Expansion : Boolean;\n+         --  Flag set when a nonlimited controlled function call requires\n+         --  in-place expansion.\n \n-      procedure Generate_Finalization_Actions is\n       begin\n-         --  Do the work only the first time this is called\n-\n-         if Finalization_Done then\n-            return;\n+         --  Perform a preliminary analysis and resolution to determine what\n+         --  the initialization expression denotes. Unanalyzed function calls\n+         --  may appear as identifiers or indexed components.\n+\n+         if Nkind_In (Init_Expr, N_Function_Call,\n+                                 N_Identifier,\n+                                 N_Indexed_Component)\n+           and then not Analyzed (Init_Expr)\n+         then\n+            Preanalyze_And_Resolve (Init_Expr, Comp_Typ);\n          end if;\n \n-         Finalization_Done := True;\n+         In_Place_Expansion :=\n+           Nkind (Init_Expr) = N_Function_Call\n+             and then not Is_Limited_Type (Comp_Typ);\n \n-         --  Determine the external finalization list. It is either the\n-         --  finalization list of the outer-scope or the one coming from an\n-         --  outer aggregate. When the target is not a temporary, the proper\n-         --  scope is the scope of the target rather than the potentially\n-         --  transient current scope.\n+         --  The initialization expression is a controlled function call.\n+         --  Perform in-place removal of side effects to avoid creating a\n+         --  transient scope.\n \n-         if Is_Controlled (Typ) and then Ancestor_Is_Subtype_Mark then\n-            Ref := Convert_To (Init_Typ, New_Copy_Tree (Target));\n-            Set_Assignment_OK (Ref);\n+         --  This in-place expansion is not performed for limited transient\n+         --  objects because the initialization is already done in place.\n \n-            Append_To (L,\n-              Make_Procedure_Call_Statement (Loc,\n-                Name                   =>\n-                  New_Occurrence_Of\n-                    (Find_Prim_Op (Init_Typ, Name_Initialize), Loc),\n-                Parameter_Associations => New_List (New_Copy_Tree (Ref))));\n+         if In_Place_Expansion then\n+\n+            --  Suppress the removal of side effects by general analysis\n+            --  because this behavior is emulated here. This avoids the\n+            --  generation of a transient scope, which leads to out-of-order\n+            --  adjustment and finalization.\n+\n+            Set_No_Side_Effect_Removal (Init_Expr);\n+\n+            --  Install all hook-related declarations and prepare the clean up\n+            --  statements.\n+\n+            Process_Transient_Component\n+              (Loc        => Loc,\n+               Comp_Typ   => Comp_Typ,\n+               Init_Expr  => Init_Expr,\n+               Fin_Call   => Fin_Call,\n+               Hook_Clear => Hook_Clear,\n+               Aggr       => N);\n          end if;\n-      end Generate_Finalization_Actions;\n \n-      function Rewrite_Discriminant (Expr : Node_Id) return Traverse_Result;\n-      --  If default expression of a component mentions a discriminant of the\n-      --  type, it must be rewritten as the discriminant of the target object.\n+         --  Use the noncontrolled component initialization circuitry to\n+         --  assign the result of the function call to the record component.\n+         --  This also performs tag adjustment and [deep] adjustment of the\n+         --  record component.\n+\n+         Initialize_Record_Component\n+           (Rec_Comp  => Rec_Comp,\n+            Comp_Typ  => Comp_Typ,\n+            Init_Expr => Init_Expr,\n+            Stmts     => Stmts);\n+\n+         --  At this point the record component is fully initialized. Complete\n+         --  the processing of the controlled record component by finalizing\n+         --  the transient function result.\n+\n+         if In_Place_Expansion then\n+            Process_Transient_Component_Completion\n+              (Loc        => Loc,\n+               Aggr       => N,\n+               Fin_Call   => Fin_Call,\n+               Hook_Clear => Hook_Clear,\n+               Stmts      => Stmts);\n+         end if;\n+      end Initialize_Ctrl_Record_Component;\n \n-      function Replace_Type (Expr : Node_Id) return Traverse_Result;\n-      --  If the aggregate contains a self-reference, traverse each expression\n-      --  to replace a possible self-reference with a reference to the proper\n-      --  component of the target of the assignment.\n+      ---------------------------------\n+      -- Initialize_Record_Component --\n+      ---------------------------------\n \n-      --------------------------\n-      -- Rewrite_Discriminant --\n-      --------------------------\n+      procedure Initialize_Record_Component\n+        (Rec_Comp  : Node_Id;\n+         Comp_Typ  : Entity_Id;\n+         Init_Expr : Node_Id;\n+         Stmts     : List_Id)\n+      is\n+         Full_Typ  : constant Entity_Id := Underlying_Type (Comp_Typ);\n+         Init_Stmt : Node_Id;\n \n-      function Rewrite_Discriminant (Expr : Node_Id) return Traverse_Result is\n       begin\n-         if Is_Entity_Name (Expr)\n-           and then Present (Entity (Expr))\n-           and then Ekind (Entity (Expr)) = E_In_Parameter\n-           and then Present (Discriminal_Link (Entity (Expr)))\n-           and then Scope (Discriminal_Link (Entity (Expr))) =\n-                                                       Base_Type (Etype (N))\n+         --  Initialize the record component. Generate:\n+\n+         --    Rec_Comp := Init_Expr;\n+\n+         --  Note that the initialization expression is NOT replicated because\n+         --  only a single component may be initialized by it.\n+\n+         Init_Stmt :=\n+           Make_OK_Assignment_Statement (Loc,\n+             Name       => New_Copy_Tree (Rec_Comp),\n+             Expression => Init_Expr);\n+         Set_No_Ctrl_Actions (Init_Stmt);\n+\n+         Append_To (Stmts, Init_Stmt);\n+\n+         --  Adjust the tag due to a possible view conversion. Generate:\n+\n+         --    Rec_Comp._tag := Full_TypeP;\n+\n+         if Tagged_Type_Expansion and then Is_Tagged_Type (Comp_Typ) then\n+            Append_To (Stmts,\n+              Make_OK_Assignment_Statement (Loc,\n+                Name       =>\n+                  Make_Selected_Component (Loc,\n+                    Prefix        => New_Copy_Tree (Rec_Comp),\n+                    Selector_Name =>\n+                      New_Occurrence_Of\n+                        (First_Tag_Component (Full_Typ), Loc)),\n+\n+                Expression =>\n+                  Unchecked_Convert_To (RTE (RE_Tag),\n+                    New_Occurrence_Of\n+                      (Node (First_Elmt (Access_Disp_Table (Full_Typ))),\n+                       Loc))));\n+         end if;\n+\n+         --  Adjust the component. Generate:\n+\n+         --    [Deep_]Adjust (Rec_Comp);\n+\n+         if Needs_Finalization (Comp_Typ)\n+           and then not Is_Limited_Type (Comp_Typ)\n          then\n-            Rewrite (Expr,\n-              Make_Selected_Component (Loc,\n-                Prefix        => New_Copy_Tree (Lhs),\n-                Selector_Name => Make_Identifier (Loc, Chars (Expr))));\n+            Append_To (Stmts,\n+              Make_Adjust_Call\n+                (Obj_Ref => New_Copy_Tree (Rec_Comp),\n+                 Typ     => Comp_Typ));\n          end if;\n+      end Initialize_Record_Component;\n \n-         return OK;\n-      end Rewrite_Discriminant;\n+      -------------------------\n+      -- Is_Int_Range_Bounds --\n+      -------------------------\n+\n+      function Is_Int_Range_Bounds (Bounds : Node_Id) return Boolean is\n+      begin\n+         return Nkind (Bounds) = N_Range\n+           and then Nkind (Low_Bound  (Bounds)) = N_Integer_Literal\n+           and then Nkind (High_Bound (Bounds)) = N_Integer_Literal;\n+      end Is_Int_Range_Bounds;\n \n       ------------------\n       -- Replace_Type --\n@@ -2646,12 +2880,34 @@ package body Exp_Aggr is\n          return OK;\n       end Replace_Type;\n \n-      procedure Replace_Self_Reference is\n-        new Traverse_Proc (Replace_Type);\n+      --------------------------\n+      -- Rewrite_Discriminant --\n+      --------------------------\n+\n+      function Rewrite_Discriminant (Expr : Node_Id) return Traverse_Result is\n+      begin\n+         if Is_Entity_Name (Expr)\n+           and then Present (Entity (Expr))\n+           and then Ekind (Entity (Expr)) = E_In_Parameter\n+           and then Present (Discriminal_Link (Entity (Expr)))\n+           and then Scope (Discriminal_Link (Entity (Expr))) =\n+                                                       Base_Type (Etype (N))\n+         then\n+            Rewrite (Expr,\n+              Make_Selected_Component (Loc,\n+                Prefix        => New_Copy_Tree (Lhs),\n+                Selector_Name => Make_Identifier (Loc, Chars (Expr))));\n+         end if;\n+\n+         return OK;\n+      end Rewrite_Discriminant;\n \n       procedure Replace_Discriminants is\n         new Traverse_Proc (Rewrite_Discriminant);\n \n+      procedure Replace_Self_Reference is\n+        new Traverse_Proc (Replace_Type);\n+\n    --  Start of processing for Build_Record_Aggr_Code\n \n    begin\n@@ -3238,57 +3494,61 @@ package body Exp_Aggr is\n                           Ctype       => Component_Type (Expr_Q_Type),\n                           Index       => First_Index (Expr_Q_Type),\n                           Into        => Comp_Expr,\n-                          Scalar_Comp => Is_Scalar_Type\n-                                           (Component_Type (Expr_Q_Type))));\n+                          Scalar_Comp =>\n+                            Is_Scalar_Type (Component_Type (Expr_Q_Type))));\n                   end;\n \n                else\n-                  Instr :=\n-                    Make_OK_Assignment_Statement (Loc,\n-                      Name       => Comp_Expr,\n-                      Expression => Expr_Q);\n-\n-                  Set_No_Ctrl_Actions (Instr);\n-                  Append_To (L, Instr);\n-               end if;\n-\n-               --  Adjust the tag if tagged (because of possible view\n-               --  conversions), unless compiling for a VM where tags are\n-               --  implicit.\n-\n-               --    tmp.comp._tag := comp_typ'tag;\n-\n-               if Is_Tagged_Type (Comp_Type)\n-                 and then Tagged_Type_Expansion\n-               then\n-                  Instr :=\n-                    Make_OK_Assignment_Statement (Loc,\n-                      Name =>\n-                        Make_Selected_Component (Loc,\n-                          Prefix =>  New_Copy_Tree (Comp_Expr),\n-                          Selector_Name =>\n-                            New_Occurrence_Of\n-                              (First_Tag_Component (Comp_Type), Loc)),\n-\n-                      Expression =>\n-                        Unchecked_Convert_To (RTE (RE_Tag),\n-                          New_Occurrence_Of\n-                            (Node (First_Elmt (Access_Disp_Table (Comp_Type))),\n-                             Loc)));\n-\n-                  Append_To (L, Instr);\n-               end if;\n+                  --  Handle an initialization expression of a controlled type\n+                  --  in case it denotes a function call. In general such a\n+                  --  scenario will produce a transient scope, but this will\n+                  --  lead to wrong order of initialization, adjustment, and\n+                  --  finalization in the context of aggregates.\n+\n+                  --    Target.Comp := Ctrl_Func_Call;\n+\n+                  --    begin                                  --  scope\n+                  --       Trans_Obj : ... := Ctrl_Func_Call;  --  object\n+                  --       Target.Comp := Trans_Obj;\n+                  --       Finalize (Trans_Obj);\n+                  --    end\n+                  --    Target.Comp._tag := ...;\n+                  --    Adjust (Target.Comp);\n+\n+                  --  In the example above, the call to Finalize occurs too\n+                  --  early and as a result it may leave the record component\n+                  --  in a bad state. Finalization of the transient object\n+                  --  should really happen after adjustment.\n+\n+                  --  To avoid this scenario, perform in-place side-effect\n+                  --  removal of the function call. This eliminates the\n+                  --  transient property of the function result and ensures\n+                  --  correct order of actions.\n+\n+                  --    Res : ... := Ctrl_Func_Call;\n+                  --    Target.Comp := Res;\n+                  --    Target.Comp._tag := ...;\n+                  --    Adjust (Target.Comp);\n+                  --    Finalize (Res);\n+\n+                  if Needs_Finalization (Comp_Type)\n+                    and then Nkind (Expr_Q) /= N_Aggregate\n+                  then\n+                     Initialize_Ctrl_Record_Component\n+                       (Rec_Comp   => Comp_Expr,\n+                        Comp_Typ   => Etype (Selector),\n+                        Init_Expr  => Expr_Q,\n+                        Stmts      => L);\n \n-               --  Generate:\n-               --    Adjust (tmp.comp);\n+                  --  Otherwise perform single component initialization\n \n-               if Needs_Finalization (Comp_Type)\n-                 and then not Is_Limited_Type (Comp_Type)\n-               then\n-                  Append_To (L,\n-                    Make_Adjust_Call\n-                      (Obj_Ref => New_Copy_Tree (Comp_Expr),\n-                       Typ     => Comp_Type));\n+                  else\n+                     Initialize_Record_Component\n+                       (Rec_Comp  => Comp_Expr,\n+                        Comp_Typ  => Etype (Selector),\n+                        Init_Expr => Expr_Q,\n+                        Stmts     => L);\n+                  end if;\n                end if;\n             end if;\n \n@@ -3692,19 +3952,17 @@ package body Exp_Aggr is\n          --  case the current delayed expansion mechanism doesn't work when\n          --  the declared object size depend on the initializing expr.\n \n-         begin\n-            Parent_Node := Parent (Parent_Node);\n-            Parent_Kind := Nkind (Parent_Node);\n+         Parent_Node := Parent (Parent_Node);\n+         Parent_Kind := Nkind (Parent_Node);\n \n-            if Parent_Kind = N_Object_Declaration then\n-               Unc_Decl :=\n-                 not Is_Entity_Name (Object_Definition (Parent_Node))\n-                   or else Has_Discriminants\n-                             (Entity (Object_Definition (Parent_Node)))\n-                   or else Is_Class_Wide_Type\n-                             (Entity (Object_Definition (Parent_Node)));\n-            end if;\n-         end;\n+         if Parent_Kind = N_Object_Declaration then\n+            Unc_Decl :=\n+              not Is_Entity_Name (Object_Definition (Parent_Node))\n+                or else Has_Discriminants\n+                          (Entity (Object_Definition (Parent_Node)))\n+                or else Is_Class_Wide_Type\n+                          (Entity (Object_Definition (Parent_Node)));\n+         end if;\n       end if;\n \n       --  Just set the Delay flag in the cases where the transformation will be\n@@ -3758,13 +4016,14 @@ package body Exp_Aggr is\n       --  the target of the assignment must not be declared within a local\n       --  block, and because cleanup will take place on return from the\n       --  initialization procedure.\n+\n       --  Should the condition be more restrictive ???\n \n       if Requires_Transient_Scope (Typ) and then not Inside_Init_Proc then\n          Establish_Transient_Scope (N, Sec_Stack => Needs_Finalization (Typ));\n       end if;\n \n-      --  If the aggregate is non-limited, create a temporary. If it is limited\n+      --  If the aggregate is nonlimited, create a temporary. If it is limited\n       --  and context is an assignment, this is a subaggregate for an enclosing\n       --  aggregate being expanded. It must be built in place, so use target of\n       --  the current assignment.\n@@ -7295,176 +7554,305 @@ package body Exp_Aggr is\n       end if;\n    end Must_Slide;\n \n-   ----------------------------------\n-   -- Two_Dim_Packed_Array_Handled --\n-   ----------------------------------\n+   ---------------------------------\n+   -- Process_Transient_Component --\n+   ---------------------------------\n \n-   function Two_Dim_Packed_Array_Handled (N : Node_Id) return Boolean is\n-      Loc          : constant Source_Ptr := Sloc (N);\n-      Typ          : constant Entity_Id  := Etype (N);\n-      Ctyp         : constant Entity_Id  := Component_Type (Typ);\n-      Comp_Size    : constant Int        := UI_To_Int (Component_Size (Typ));\n-      Packed_Array : constant Entity_Id  :=\n-                       Packed_Array_Impl_Type (Base_Type (Typ));\n+   procedure Process_Transient_Component\n+     (Loc        : Source_Ptr;\n+      Comp_Typ   : Entity_Id;\n+      Init_Expr  : Node_Id;\n+      Fin_Call   : out Node_Id;\n+      Hook_Clear : out Node_Id;\n+      Aggr       : Node_Id := Empty;\n+      Stmts      : List_Id := No_List)\n+   is\n+      procedure Add_Item (Item : Node_Id);\n+      --  Insert arbitrary node Item into the tree depending on the values of\n+      --  Aggr and Stmts.\n \n-      One_Comp : Node_Id;\n-      --  Expression in original aggregate\n+      --------------\n+      -- Add_Item --\n+      --------------\n \n-      One_Dim : Node_Id;\n-      --  One-dimensional subaggregate\n+      procedure Add_Item (Item : Node_Id) is\n+      begin\n+         if Present (Aggr) then\n+            Insert_Action (Aggr, Item);\n+         else\n+            pragma Assert (Present (Stmts));\n+            Append_To (Stmts, Item);\n+         end if;\n+      end Add_Item;\n+\n+      --  Local variables\n+\n+      Hook_Assign : Node_Id;\n+      Hook_Decl   : Node_Id;\n+      Ptr_Decl    : Node_Id;\n+      Res_Decl    : Node_Id;\n+      Res_Id      : Entity_Id;\n+      Res_Typ     : Entity_Id;\n+\n+   --  Start of processing for Process_Transient_Component\n \n    begin\n+      --  Add the access type, which provides a reference to the function\n+      --  result. Generate:\n \n-      --  For now, only deal with cases where an integral number of elements\n-      --  fit in a single byte. This includes the most common boolean case.\n+      --    type Res_Typ is access all Comp_Typ;\n \n-      if not (Comp_Size = 1 or else\n-              Comp_Size = 2 or else\n-              Comp_Size = 4)\n-      then\n-         return False;\n-      end if;\n+      Res_Typ := Make_Temporary (Loc, 'A');\n+      Set_Ekind (Res_Typ, E_General_Access_Type);\n+      Set_Directly_Designated_Type (Res_Typ, Comp_Typ);\n \n-      Convert_To_Positional\n-        (N, Max_Others_Replicate => 64, Handle_Bit_Packed => True);\n+      Add_Item\n+        (Make_Full_Type_Declaration (Loc,\n+           Defining_Identifier => Res_Typ,\n+           Type_Definition     =>\n+             Make_Access_To_Object_Definition (Loc,\n+               All_Present        => True,\n+               Subtype_Indication => New_Occurrence_Of (Comp_Typ, Loc))));\n \n-      --  Verify that all components are static\n+      --  Add the temporary which captures the result of the function call.\n+      --  Generate:\n \n-      if Nkind (N) = N_Aggregate\n-        and then Compile_Time_Known_Aggregate (N)\n-      then\n-         null;\n+      --    Res : constant Res_Typ := Init_Expr'Reference;\n \n-      --  The aggregate may have been re-analyzed and converted already\n+      --  Note that this temporary is effectively a transient object because\n+      --  its lifetime is bounded by the current array or record component.\n \n-      elsif Nkind (N) /= N_Aggregate then\n-         return True;\n+      Res_Id := Make_Temporary (Loc, 'R');\n+      Set_Ekind (Res_Id, E_Constant);\n+      Set_Etype (Res_Id, Res_Typ);\n \n-      --  If component associations remain, the aggregate is not static\n+      --  Mark the transient object as successfully processed to avoid double\n+      --  finalization.\n \n-      elsif Present (Component_Associations (N)) then\n-         return False;\n+      Set_Is_Finalized_Transient (Res_Id);\n \n-      else\n-         One_Dim := First (Expressions (N));\n-         while Present (One_Dim) loop\n-            if Present (Component_Associations (One_Dim)) then\n-               return False;\n-            end if;\n+      --  Signal the general finalization machinery that this transient object\n+      --  should not be considered for finalization actions because its cleanup\n+      --  will be performed by Process_Transient_Component_Completion.\n \n-            One_Comp := First (Expressions (One_Dim));\n-            while Present (One_Comp) loop\n-               if not Is_OK_Static_Expression (One_Comp) then\n-                  return False;\n-               end if;\n+      Set_Is_Ignored_Transient (Res_Id);\n \n-               Next (One_Comp);\n-            end loop;\n+      Res_Decl :=\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Res_Id,\n+          Constant_Present    => True,\n+          Object_Definition   => New_Occurrence_Of (Res_Typ, Loc),\n+          Expression          =>\n+            Make_Reference (Loc, New_Copy_Tree (Init_Expr)));\n \n-            Next (One_Dim);\n-         end loop;\n-      end if;\n+      Add_Item (Res_Decl);\n \n-      --  Two-dimensional aggregate is now fully positional so pack one\n-      --  dimension to create a static one-dimensional array, and rewrite\n-      --  as an unchecked conversion to the original type.\n+      --  Construct all pieces necessary to hook and finalize the transient\n+      --  result.\n \n-      declare\n-         Byte_Size : constant Int := UI_To_Int (Component_Size (Packed_Array));\n-         --  The packed array type is a byte array\n+      Build_Transient_Object_Statements\n+        (Obj_Decl    => Res_Decl,\n+         Fin_Call    => Fin_Call,\n+         Hook_Assign => Hook_Assign,\n+         Hook_Clear  => Hook_Clear,\n+         Hook_Decl   => Hook_Decl,\n+         Ptr_Decl    => Ptr_Decl);\n \n-         Packed_Num : Nat;\n-         --  Number of components accumulated in current byte\n+      --  Add the access type which provides a reference to the transient\n+      --  result. Generate:\n \n-         Comps : List_Id;\n-         --  Assembled list of packed values for equivalent aggregate\n+      --    type Ptr_Typ is access all Comp_Typ;\n \n-         Comp_Val : Uint;\n-         --  integer value of component\n+      Add_Item (Ptr_Decl);\n \n-         Incr : Int;\n-         --  Step size for packing\n+      --  Add the temporary which acts as a hook to the transient result.\n+      --  Generate:\n \n-         Init_Shift : Int;\n-         --  Endian-dependent start position for packing\n+      --    Hook : Ptr_Typ := null;\n \n-         Shift : Int;\n-         --  Current insertion position\n+      Add_Item (Hook_Decl);\n \n-         Val : Int;\n-         --  Component of packed array being assembled.\n+      --  Attach the transient result to the hook. Generate:\n \n-      begin\n-         Comps := New_List;\n-         Val   := 0;\n-         Packed_Num := 0;\n+      --    Hook := Ptr_Typ (Res);\n \n-         --  Account for endianness.  See corresponding comment in\n-         --  Packed_Array_Aggregate_Handled concerning the following.\n+      Add_Item (Hook_Assign);\n \n-         if Bytes_Big_Endian\n-           xor Debug_Flag_8\n-           xor Reverse_Storage_Order (Base_Type (Typ))\n-         then\n-            Init_Shift := Byte_Size - Comp_Size;\n-            Incr := -Comp_Size;\n-         else\n-            Init_Shift := 0;\n-            Incr := +Comp_Size;\n-         end if;\n+      --  The original initialization expression now references the value of\n+      --  the temporary function result. Generate:\n \n-         --  Iterate over each subaggregate\n+      --    Res.all\n \n-         Shift := Init_Shift;\n-         One_Dim := First (Expressions (N));\n-         while Present (One_Dim) loop\n-            One_Comp := First (Expressions (One_Dim));\n-            while Present (One_Comp) loop\n-               if Packed_Num = Byte_Size / Comp_Size then\n+      Rewrite (Init_Expr,\n+        Make_Explicit_Dereference (Loc,\n+          Prefix => New_Occurrence_Of (Res_Id, Loc)));\n+   end Process_Transient_Component;\n \n-                  --  Byte is complete, add to list of expressions\n+   --------------------------------------------\n+   -- Process_Transient_Component_Completion --\n+   --------------------------------------------\n \n-                  Append (Make_Integer_Literal (Sloc (One_Dim), Val), Comps);\n-                  Val := 0;\n-                  Shift := Init_Shift;\n-                  Packed_Num := 0;\n+   procedure Process_Transient_Component_Completion\n+     (Loc        : Source_Ptr;\n+      Aggr       : Node_Id;\n+      Fin_Call   : Node_Id;\n+      Hook_Clear : Node_Id;\n+      Stmts      : List_Id)\n+   is\n+      Exceptions_OK : constant Boolean :=\n+                        not Restriction_Active (No_Exception_Propagation);\n \n-               else\n-                  Comp_Val := Expr_Rep_Value (One_Comp);\n+   begin\n+      pragma Assert (Present (Fin_Call));\n+      pragma Assert (Present (Hook_Clear));\n \n-                  --  Adjust for bias, and strip proper number of bits\n+      --  Generate the following code if exception propagation is allowed:\n \n-                  if Has_Biased_Representation (Ctyp) then\n-                     Comp_Val := Comp_Val - Expr_Value (Type_Low_Bound (Ctyp));\n-                  end if;\n+      --    declare\n+      --       Abort : constant Boolean := Triggered_By_Abort;\n+      --         <or>\n+      --       Abort : constant Boolean := False;  --  no abort\n \n-                  Comp_Val := Comp_Val mod Uint_2 ** Comp_Size;\n-                  Val := UI_To_Int (Val + Comp_Val * Uint_2 ** Shift);\n-                  Shift := Shift + Incr;\n-                  One_Comp := Next (One_Comp);\n-                  Packed_Num := Packed_Num + 1;\n-               end if;\n-            end loop;\n+      --       E      : Exception_Occurrence;\n+      --       Raised : Boolean := False;\n \n-            One_Dim := Next (One_Dim);\n-         end loop;\n+      --    begin\n+      --       [Abort_Defer;]\n \n-         if Packed_Num > 0 then\n+      --       begin\n+      --          Hook := null;\n+      --          [Deep_]Finalize (Res.all);\n \n-            --  Add final incomplete byte if present\n+      --       exception\n+      --          when others =>\n+      --             if not Raised then\n+      --                Raised := True;\n+      --                Save_Occurrence (E,\n+      --                  Get_Curent_Excep.all.all);\n+      --             end if;\n+      --       end;\n \n-            Append (Make_Integer_Literal (Sloc (One_Dim), Val), Comps);\n-         end if;\n+      --       [Abort_Undefer;]\n \n-         Rewrite (N,\n-             Unchecked_Convert_To (Typ,\n-               Make_Qualified_Expression (Loc,\n-                 Subtype_Mark => New_Occurrence_Of (Packed_Array, Loc),\n-                 Expression   => Make_Aggregate (Loc, Expressions => Comps))));\n-         Analyze_And_Resolve (N);\n-         return True;\n-      end;\n-   end Two_Dim_Packed_Array_Handled;\n+      --       if Raised and then not Abort then\n+      --          Raise_From_Controlled_Operation (E);\n+      --       end if;\n+      --    end;\n+\n+      if Exceptions_OK then\n+         Abort_And_Exception : declare\n+            Blk_Decls : constant List_Id := New_List;\n+            Blk_Stmts : constant List_Id := New_List;\n+\n+            Fin_Data : Finalization_Exception_Data;\n+\n+         begin\n+            --  Create the declarations of the two flags and the exception\n+            --  occurrence.\n+\n+            Build_Object_Declarations (Fin_Data, Blk_Decls, Loc);\n+\n+            --  Generate:\n+            --    Abort_Defer;\n+\n+            if Abort_Allowed then\n+               Append_To (Blk_Stmts,\n+                 Build_Runtime_Call (Loc, RE_Abort_Defer));\n+            end if;\n+\n+            --  Wrap the hook clear and the finalization call in order to trap\n+            --  a potential exception.\n+\n+            Append_To (Blk_Stmts,\n+              Make_Block_Statement (Loc,\n+                Handled_Statement_Sequence =>\n+                  Make_Handled_Sequence_Of_Statements (Loc,\n+                    Statements         => New_List (\n+                      Hook_Clear,\n+                      Fin_Call),\n+                    Exception_Handlers => New_List (\n+                      Build_Exception_Handler (Fin_Data)))));\n+\n+            --  Generate:\n+            --    Abort_Undefer;\n+\n+            if Abort_Allowed then\n+               Append_To (Blk_Stmts,\n+                 Build_Runtime_Call (Loc, RE_Abort_Undefer));\n+            end if;\n+\n+            --  Reraise the potential exception with a proper \"upgrade\" to\n+            --  Program_Error if needed.\n+\n+            Append_To (Blk_Stmts, Build_Raise_Statement (Fin_Data));\n+\n+            --  Wrap everything in a block\n+\n+            Append_To (Stmts,\n+              Make_Block_Statement (Loc,\n+                Declarations               => Blk_Decls,\n+                Handled_Statement_Sequence =>\n+                  Make_Handled_Sequence_Of_Statements (Loc,\n+                    Statements => Blk_Stmts)));\n+         end Abort_And_Exception;\n+\n+      --  Generate the following code if exception propagation is not allowed\n+      --  and aborts are allowed:\n+\n+      --    begin\n+      --       Abort_Defer;\n+      --       Hook := null;\n+      --       [Deep_]Finalize (Res.all);\n+      --    at end\n+      --       Abort_Undefer;\n+      --    end;\n+\n+      elsif Abort_Allowed then\n+         Abort_Only : declare\n+            Blk_Stmts : constant List_Id := New_List;\n+\n+            AUD     : Entity_Id;\n+            Blk     : Node_Id;\n+            Blk_HSS : Node_Id;\n+            Blk_Id  : Entity_Id;\n+\n+         begin\n+            Append_To (Blk_Stmts, Build_Runtime_Call (Loc, RE_Abort_Defer));\n+            Append_To (Blk_Stmts, Hook_Clear);\n+            Append_To (Blk_Stmts, Fin_Call);\n+\n+            AUD := RTE (RE_Abort_Undefer_Direct);\n+\n+            Blk_HSS :=\n+              Make_Handled_Sequence_Of_Statements (Loc,\n+                Statements  => Blk_Stmts,\n+                At_End_Proc => New_Occurrence_Of (AUD, Loc));\n+\n+            Blk :=\n+              Make_Block_Statement (Loc,\n+                Handled_Statement_Sequence => Blk_HSS);\n+\n+            Add_Block_Identifier (Blk, Blk_Id);\n+            Expand_At_End_Handler (Blk_HSS, Blk_Id);\n+\n+            --  Present the Abort_Undefer_Direct function to the back end so\n+            --  that it can inline the call to the function.\n+\n+            Add_Inlined_Body (AUD, Aggr);\n+\n+            Append_To (Stmts, Blk);\n+         end Abort_Only;\n+\n+      --  Otherwise generate:\n+\n+      --    Hook := null;\n+      --    [Deep_]Finalize (Res.all);\n+\n+      else\n+         Append_To (Stmts, Hook_Clear);\n+         Append_To (Stmts, Fin_Call);\n+      end if;\n+   end Process_Transient_Component_Completion;\n \n    ---------------------\n    -- Sort_Case_Table --\n@@ -7612,4 +8000,175 @@ package body Exp_Aggr is\n       end if;\n    end Static_Array_Aggregate;\n \n+   ----------------------------------\n+   -- Two_Dim_Packed_Array_Handled --\n+   ----------------------------------\n+\n+   function Two_Dim_Packed_Array_Handled (N : Node_Id) return Boolean is\n+      Loc          : constant Source_Ptr := Sloc (N);\n+      Typ          : constant Entity_Id  := Etype (N);\n+      Ctyp         : constant Entity_Id  := Component_Type (Typ);\n+      Comp_Size    : constant Int        := UI_To_Int (Component_Size (Typ));\n+      Packed_Array : constant Entity_Id  :=\n+                       Packed_Array_Impl_Type (Base_Type (Typ));\n+\n+      One_Comp : Node_Id;\n+      --  Expression in original aggregate\n+\n+      One_Dim : Node_Id;\n+      --  One-dimensional subaggregate\n+\n+   begin\n+\n+      --  For now, only deal with cases where an integral number of elements\n+      --  fit in a single byte. This includes the most common boolean case.\n+\n+      if not (Comp_Size = 1 or else\n+              Comp_Size = 2 or else\n+              Comp_Size = 4)\n+      then\n+         return False;\n+      end if;\n+\n+      Convert_To_Positional\n+        (N, Max_Others_Replicate => 64, Handle_Bit_Packed => True);\n+\n+      --  Verify that all components are static\n+\n+      if Nkind (N) = N_Aggregate\n+        and then Compile_Time_Known_Aggregate (N)\n+      then\n+         null;\n+\n+      --  The aggregate may have been reanalyzed and converted already\n+\n+      elsif Nkind (N) /= N_Aggregate then\n+         return True;\n+\n+      --  If component associations remain, the aggregate is not static\n+\n+      elsif Present (Component_Associations (N)) then\n+         return False;\n+\n+      else\n+         One_Dim := First (Expressions (N));\n+         while Present (One_Dim) loop\n+            if Present (Component_Associations (One_Dim)) then\n+               return False;\n+            end if;\n+\n+            One_Comp := First (Expressions (One_Dim));\n+            while Present (One_Comp) loop\n+               if not Is_OK_Static_Expression (One_Comp) then\n+                  return False;\n+               end if;\n+\n+               Next (One_Comp);\n+            end loop;\n+\n+            Next (One_Dim);\n+         end loop;\n+      end if;\n+\n+      --  Two-dimensional aggregate is now fully positional so pack one\n+      --  dimension to create a static one-dimensional array, and rewrite\n+      --  as an unchecked conversion to the original type.\n+\n+      declare\n+         Byte_Size : constant Int := UI_To_Int (Component_Size (Packed_Array));\n+         --  The packed array type is a byte array\n+\n+         Packed_Num : Nat;\n+         --  Number of components accumulated in current byte\n+\n+         Comps : List_Id;\n+         --  Assembled list of packed values for equivalent aggregate\n+\n+         Comp_Val : Uint;\n+         --  Integer value of component\n+\n+         Incr : Int;\n+         --  Step size for packing\n+\n+         Init_Shift : Int;\n+         --  Endian-dependent start position for packing\n+\n+         Shift : Int;\n+         --  Current insertion position\n+\n+         Val : Int;\n+         --  Component of packed array being assembled\n+\n+      begin\n+         Comps := New_List;\n+         Val   := 0;\n+         Packed_Num := 0;\n+\n+         --  Account for endianness.  See corresponding comment in\n+         --  Packed_Array_Aggregate_Handled concerning the following.\n+\n+         if Bytes_Big_Endian\n+           xor Debug_Flag_8\n+           xor Reverse_Storage_Order (Base_Type (Typ))\n+         then\n+            Init_Shift := Byte_Size - Comp_Size;\n+            Incr := -Comp_Size;\n+         else\n+            Init_Shift := 0;\n+            Incr := +Comp_Size;\n+         end if;\n+\n+         --  Iterate over each subaggregate\n+\n+         Shift := Init_Shift;\n+         One_Dim := First (Expressions (N));\n+         while Present (One_Dim) loop\n+            One_Comp := First (Expressions (One_Dim));\n+            while Present (One_Comp) loop\n+               if Packed_Num = Byte_Size / Comp_Size then\n+\n+                  --  Byte is complete, add to list of expressions\n+\n+                  Append (Make_Integer_Literal (Sloc (One_Dim), Val), Comps);\n+                  Val := 0;\n+                  Shift := Init_Shift;\n+                  Packed_Num := 0;\n+\n+               else\n+                  Comp_Val := Expr_Rep_Value (One_Comp);\n+\n+                  --  Adjust for bias, and strip proper number of bits\n+\n+                  if Has_Biased_Representation (Ctyp) then\n+                     Comp_Val := Comp_Val - Expr_Value (Type_Low_Bound (Ctyp));\n+                  end if;\n+\n+                  Comp_Val := Comp_Val mod Uint_2 ** Comp_Size;\n+                  Val := UI_To_Int (Val + Comp_Val * Uint_2 ** Shift);\n+                  Shift := Shift + Incr;\n+                  One_Comp := Next (One_Comp);\n+                  Packed_Num := Packed_Num + 1;\n+               end if;\n+            end loop;\n+\n+            One_Dim := Next (One_Dim);\n+         end loop;\n+\n+         if Packed_Num > 0 then\n+\n+            --  Add final incomplete byte if present\n+\n+            Append (Make_Integer_Literal (Sloc (One_Dim), Val), Comps);\n+         end if;\n+\n+         Rewrite (N,\n+             Unchecked_Convert_To (Typ,\n+               Make_Qualified_Expression (Loc,\n+                 Subtype_Mark => New_Occurrence_Of (Packed_Array, Loc),\n+                 Expression   => Make_Aggregate (Loc, Expressions => Comps))));\n+         Analyze_And_Resolve (N);\n+         return True;\n+      end;\n+   end Two_Dim_Packed_Array_Handled;\n+\n end Exp_Aggr;"}, {"sha": "f6a5c2c9067bc2a95a8332f674eb89baf29a6e23", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 99, "deletions": 152, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/937e96763e42c48c29e3a5edf2eea3fb2c59fb27/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/937e96763e42c48c29e3a5edf2eea3fb2c59fb27/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=937e96763e42c48c29e3a5edf2eea3fb2c59fb27", "patch": "@@ -226,22 +226,21 @@ package body Exp_Ch4 is\n \n    procedure Process_If_Case_Statements (N : Node_Id; Stmts : List_Id);\n    --  Inspect and process statement list Stmt of if or case expression N for\n-   --  transient controlled objects. If such objects are found, the routine\n-   --  generates code to clean them up when the context of the expression is\n-   --  evaluated or elaborated.\n-\n-   procedure Process_Transient_Object\n-     (Decl  : Node_Id;\n-      N     : Node_Id;\n-      Stmts : List_Id);\n+   --  transient objects. If such objects are found, the routine generates code\n+   --  to clean them up when the context of the expression is evaluated.\n+\n+   procedure Process_Transient_In_Expression\n+     (Obj_Decl : Node_Id;\n+      Expr     : Node_Id;\n+      Stmts    : List_Id);\n    --  Subsidiary routine to the expansion of expression_with_actions, if and\n    --  case expressions. Generate all necessary code to finalize a transient\n-   --  controlled object when the enclosing context is elaborated or evaluated.\n-   --  Decl denotes the declaration of the transient controlled object which is\n-   --  usually the result of a controlled function call. N denotes the related\n-   --  expression_with_actions, if expression, or case expression node. Stmts\n-   --  denotes the statement list which contains Decl, either at the top level\n-   --  or within a nested construct.\n+   --  object when the enclosing context is elaborated or evaluated. Obj_Decl\n+   --  denotes the declaration of the transient object, which is usually the\n+   --  result of a controlled function call. Expr denotes the expression with\n+   --  actions, if expression, or case expression node. Stmts denotes the\n+   --  statement list which contains Decl, either at the top level or within a\n+   --  nested construct.\n \n    procedure Rewrite_Comparison (N : Node_Id);\n    --  If N is the node for a comparison whose outcome can be determined at\n@@ -4866,11 +4865,10 @@ package body Exp_Ch4 is\n                Prepend_List (Actions (Alt), Stmts);\n             end if;\n \n-            --  Finalize any transient controlled objects on exit from the\n-            --  alternative. This is done only in the return optimization case\n-            --  because otherwise the case expression is converted into an\n-            --  expression with actions which already contains this form of\n-            --  processing.\n+            --  Finalize any transient objects on exit from the alternative.\n+            --  This is done only in the return optimization case because\n+            --  otherwise the case expression is converted into an expression\n+            --  with actions which already contains this form of processing.\n \n             if Optimize_Return_Stmt then\n                Process_If_Case_Statements (N, Stmts);\n@@ -4952,9 +4950,9 @@ package body Exp_Ch4 is\n \n       function Process_Action (Act : Node_Id) return Traverse_Result;\n       --  Inspect and process a single action of an expression_with_actions for\n-      --  transient controlled objects. If such objects are found, the routine\n-      --  generates code to clean them up when the context of the expression is\n-      --  evaluated or elaborated.\n+      --  transient objects. If such objects are found, the routine generates\n+      --  code to clean them up when the context of the expression is evaluated\n+      --  or elaborated.\n \n       ------------------------------\n       -- Force_Boolean_Evaluation --\n@@ -4997,7 +4995,7 @@ package body Exp_Ch4 is\n          if Nkind (Act) = N_Object_Declaration\n            and then Is_Finalizable_Transient (Act, N)\n          then\n-            Process_Transient_Object (Act, N, Acts);\n+            Process_Transient_In_Expression (Act, N, Acts);\n             return Abandon;\n \n          --  Avoid processing temporary function results multiple times when\n@@ -5038,8 +5036,8 @@ package body Exp_Ch4 is\n          null;\n \n       --  Force the evaluation of the expression by capturing its value in a\n-      --  temporary. This ensures that aliases of transient controlled objects\n-      --  do not leak to the expression of the expression_with_actions node:\n+      --  temporary. This ensures that aliases of transient objects do not leak\n+      --  to the expression of the expression_with_actions node:\n \n       --    do\n       --       Trans_Id : Ctrl_Typ := ...;\n@@ -5059,12 +5057,12 @@ package body Exp_Ch4 is\n       --    in Val end;\n \n       --  Once this transformation is performed, it is safe to finalize the\n-      --  transient controlled object at the end of the actions list.\n+      --  transient object at the end of the actions list.\n \n       --  Note that Force_Evaluation does not remove side effects in operators\n       --  because it assumes that all operands are evaluated and side effect\n       --  free. This is not the case when an operand depends implicitly on the\n-      --  transient controlled object through the use of access types.\n+      --  transient object through the use of access types.\n \n       elsif Is_Boolean_Type (Etype (Expression (N))) then\n          Force_Boolean_Evaluation (Expression (N));\n@@ -5077,8 +5075,8 @@ package body Exp_Ch4 is\n          Force_Evaluation (Expression (N));\n       end if;\n \n-      --  Process all transient controlled objects found within the actions of\n-      --  the EWA node.\n+      --  Process all transient objects found within the actions of the EWA\n+      --  node.\n \n       Act := First (Acts);\n       while Present (Act) loop\n@@ -12956,44 +12954,44 @@ package body Exp_Ch4 is\n          if Nkind (Decl) = N_Object_Declaration\n            and then Is_Finalizable_Transient (Decl, N)\n          then\n-            Process_Transient_Object (Decl, N, Stmts);\n+            Process_Transient_In_Expression (Decl, N, Stmts);\n          end if;\n \n          Next (Decl);\n       end loop;\n    end Process_If_Case_Statements;\n \n-   ------------------------------\n-   -- Process_Transient_Object --\n-   ------------------------------\n+   -------------------------------------\n+   -- Process_Transient_In_Expression --\n+   -------------------------------------\n \n-   procedure Process_Transient_Object\n-     (Decl  : Node_Id;\n-      N     : Node_Id;\n-      Stmts : List_Id)\n+   procedure Process_Transient_In_Expression\n+     (Obj_Decl : Node_Id;\n+      Expr     : Node_Id;\n+      Stmts    : List_Id)\n    is\n-      Loc     : constant Source_Ptr := Sloc (Decl);\n-      Obj_Id  : constant Entity_Id  := Defining_Identifier (Decl);\n-      Obj_Typ : constant Node_Id    := Etype (Obj_Id);\n+      Loc    : constant Source_Ptr := Sloc (Obj_Decl);\n+      Obj_Id : constant Entity_Id  := Defining_Identifier (Obj_Decl);\n \n-      Desig_Typ   : Entity_Id;\n-      Expr        : Node_Id;\n-      Hook_Id     : Entity_Id;\n-      Hook_Insert : Node_Id;\n-      Ptr_Id      : Entity_Id;\n-\n-      Hook_Context : constant Node_Id := Find_Hook_Context (N);\n+      Hook_Context : constant Node_Id := Find_Hook_Context (Expr);\n       --  The node on which to insert the hook as an action. This is usually\n       --  the innermost enclosing non-transient construct.\n \n+      Fin_Call    : Node_Id;\n+      Hook_Assign : Node_Id;\n+      Hook_Clear  : Node_Id;\n+      Hook_Decl   : Node_Id;\n+      Hook_Insert : Node_Id;\n+      Ptr_Decl    : Node_Id;\n+\n       Fin_Context : Node_Id;\n       --  The node after which to insert the finalization actions of the\n-      --  transient controlled object.\n+      --  transient object.\n \n    begin\n-      pragma Assert (Nkind_In (N, N_Case_Expression,\n-                                  N_Expression_With_Actions,\n-                                  N_If_Expression));\n+      pragma Assert (Nkind_In (Expr, N_Case_Expression,\n+                                     N_Expression_With_Actions,\n+                                     N_If_Expression));\n \n       --  When the context is a Boolean evaluation, all three nodes capture the\n       --  result of their computation in a local temporary:\n@@ -13004,157 +13002,106 @@ package body Exp_Ch4 is\n       --       <finalize Trans_Id>\n       --    in Result end;\n \n-      --  As a result, the finalization of any transient controlled objects can\n-      --  safely take place after the result capture.\n+      --  As a result, the finalization of any transient objects can safely\n+      --  take place after the result capture.\n \n       --  ??? could this be extended to elementary types?\n \n-      if Is_Boolean_Type (Etype (N)) then\n+      if Is_Boolean_Type (Etype (Expr)) then\n          Fin_Context := Last (Stmts);\n \n-      --  Otherwise the immediate context may not be safe enough to carry out\n-      --  transient controlled object finalization due to aliasing and nesting\n-      --  of constructs. Insert calls to [Deep_]Finalize after the innermost\n+      --  Otherwise the immediate context may not be safe enough to carry\n+      --  out transient object finalization due to aliasing and nesting of\n+      --  constructs. Insert calls to [Deep_]Finalize after the innermost\n       --  enclosing non-transient construct.\n \n       else\n          Fin_Context := Hook_Context;\n       end if;\n \n-      --  Step 1: Create the access type which provides a reference to the\n-      --  transient controlled object.\n+      --  Mark the transient object as successfully processed to avoid double\n+      --  finalization.\n \n-      if Is_Access_Type (Obj_Typ) then\n-         Desig_Typ := Directly_Designated_Type (Obj_Typ);\n-      else\n-         Desig_Typ := Obj_Typ;\n-      end if;\n+      Set_Is_Finalized_Transient (Obj_Id);\n \n-      Desig_Typ := Base_Type (Desig_Typ);\n+      --  Construct all the pieces necessary to hook and finalize a transient\n+      --  object.\n \n-      --  Generate:\n-      --    Ann : access [all] <Desig_Typ>;\n+      Build_Transient_Object_Statements\n+        (Obj_Decl     => Obj_Decl,\n+         Fin_Call     => Fin_Call,\n+         Hook_Assign  => Hook_Assign,\n+         Hook_Clear   => Hook_Clear,\n+         Hook_Decl    => Hook_Decl,\n+         Ptr_Decl     => Ptr_Decl,\n+         Finalize_Obj => False);\n \n-      Ptr_Id := Make_Temporary (Loc, 'A');\n+      --  Add the access type which provides a reference to the transient\n+      --  object. Generate:\n \n-      Insert_Action (Hook_Context,\n-        Make_Full_Type_Declaration (Loc,\n-          Defining_Identifier => Ptr_Id,\n-          Type_Definition     =>\n-            Make_Access_To_Object_Definition (Loc,\n-              All_Present        => Ekind (Obj_Typ) = E_General_Access_Type,\n-              Subtype_Indication => New_Occurrence_Of (Desig_Typ, Loc))));\n+      --    type Ptr_Typ is access all Desig_Typ;\n \n-      --  Step 2: Create a temporary which acts as a hook to the transient\n-      --  controlled object. Generate:\n+      Insert_Action (Hook_Context, Ptr_Decl);\n+\n+      --  Add the temporary which acts as a hook to the transient object.\n+      --  Generate:\n \n       --    Hook : Ptr_Id := null;\n \n-      Hook_Id := Make_Temporary (Loc, 'T');\n+      Insert_Action (Hook_Context, Hook_Decl);\n \n-      Insert_Action (Hook_Context,\n-        Make_Object_Declaration (Loc,\n-          Defining_Identifier => Hook_Id,\n-          Object_Definition   => New_Occurrence_Of (Ptr_Id, Loc)));\n-\n-      --  Mark the hook as created for the purposes of exporting the transient\n-      --  controlled object out of the expression_with_action or if expression.\n-      --  This signals the machinery in Build_Finalizer to treat this case in\n-      --  a special manner.\n-\n-      Set_Status_Flag_Or_Transient_Decl (Hook_Id, Decl);\n-\n-      --  Step 3: Associate the transient object to the hook\n-\n-      --  This must be inserted right after the object declaration, so that\n-      --  the assignment is executed if, and only if, the object is actually\n-      --  created (whereas the declaration of the hook pointer, and the\n-      --  finalization call, may be inserted at an outer level, and may\n-      --  remain unused for some executions, if the actual creation of\n-      --  the object is conditional).\n-\n-      --  The use of unchecked conversion / unrestricted access is needed to\n-      --  avoid an accessibility violation. Note that the finalization code is\n-      --  structured in such a way that the \"hook\" is processed only when it\n-      --  points to an existing object.\n-\n-      if Is_Access_Type (Obj_Typ) then\n-         Expr :=\n-           Unchecked_Convert_To\n-             (Typ  => Ptr_Id,\n-              Expr => New_Occurrence_Of (Obj_Id, Loc));\n-      else\n-         Expr :=\n-           Make_Attribute_Reference (Loc,\n-             Prefix         => New_Occurrence_Of (Obj_Id, Loc),\n-             Attribute_Name => Name_Unrestricted_Access);\n-      end if;\n+      --  When the transient object is initialized by an aggregate, the hook\n+      --  must capture the object after the last aggregate assignment takes\n+      --  place. Only then is the object considered initialized. Generate:\n \n-      --  Generate:\n-      --    Hook := Ptr_Id (Obj_Id);\n+      --    Hook := Ptr_Typ (Obj_Id);\n       --      <or>\n       --    Hook := Obj_Id'Unrestricted_Access;\n \n-      --  When the transient object is initialized by an aggregate, the hook\n-      --  must capture the object after the last component assignment takes\n-      --  place. Only then is the object fully initialized.\n-\n-      if Ekind (Obj_Id) = E_Variable\n+      if Ekind_In (Obj_Id, E_Constant, E_Variable)\n         and then Present (Last_Aggregate_Assignment (Obj_Id))\n       then\n          Hook_Insert := Last_Aggregate_Assignment (Obj_Id);\n \n       --  Otherwise the hook seizes the related object immediately\n \n       else\n-         Hook_Insert := Decl;\n+         Hook_Insert := Obj_Decl;\n       end if;\n \n-      Insert_After_And_Analyze (Hook_Insert,\n-        Make_Assignment_Statement (Loc,\n-          Name       => New_Occurrence_Of (Hook_Id, Loc),\n-          Expression => Expr));\n-\n-      --  Step 4: Finalize the hook after the context has been evaluated or\n-      --  elaborated. Generate:\n-\n-      --    if Hook /= null then\n-      --       [Deep_]Finalize (Hook.all);\n-      --       Hook := null;\n-      --    end if;\n+      Insert_After_And_Analyze (Hook_Insert, Hook_Assign);\n \n       --  When the node is part of a return statement, there is no need to\n       --  insert a finalization call, as the general finalization mechanism\n-      --  (see Build_Finalizer) would take care of the transient controlled\n-      --  object on subprogram exit. Note that it would also be impossible to\n-      --  insert the finalization code after the return statement as this will\n-      --  render it unreachable.\n+      --  (see Build_Finalizer) would take care of the transient object on\n+      --  subprogram exit. Note that it would also be impossible to insert the\n+      --  finalization code after the return statement as this will render it\n+      --  unreachable.\n \n       if Nkind (Fin_Context) = N_Simple_Return_Statement then\n          null;\n \n-      --  Otherwise finalize the hook\n+      --  Finalize the hook after the context has been evaluated. Generate:\n+\n+      --    if Hook /= null then\n+      --       [Deep_]Finalize (Hook.all);\n+      --       Hook := null;\n+      --    end if;\n \n       else\n          Insert_Action_After (Fin_Context,\n-           Make_Implicit_If_Statement (Decl,\n+           Make_Implicit_If_Statement (Obj_Decl,\n              Condition =>\n                Make_Op_Ne (Loc,\n-                 Left_Opnd  => New_Occurrence_Of (Hook_Id, Loc),\n+                 Left_Opnd  =>\n+                   New_Occurrence_Of (Defining_Entity (Hook_Decl), Loc),\n                  Right_Opnd => Make_Null (Loc)),\n \n              Then_Statements => New_List (\n-               Make_Final_Call\n-                 (Obj_Ref =>\n-                    Make_Explicit_Dereference (Loc,\n-                      Prefix => New_Occurrence_Of (Hook_Id, Loc)),\n-                  Typ     => Desig_Typ),\n-\n-               Make_Assignment_Statement (Loc,\n-                 Name       => New_Occurrence_Of (Hook_Id, Loc),\n-                 Expression => Make_Null (Loc)))));\n+               Fin_Call,\n+               Hook_Clear)));\n       end if;\n-   end Process_Transient_Object;\n+   end Process_Transient_In_Expression;\n \n    ------------------------\n    -- Rewrite_Comparison --"}, {"sha": "938484b22a2145cc54fdbd4d9b2b9c0c04b268d7", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/937e96763e42c48c29e3a5edf2eea3fb2c59fb27/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/937e96763e42c48c29e3a5edf2eea3fb2c59fb27/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=937e96763e42c48c29e3a5edf2eea3fb2c59fb27", "patch": "@@ -4115,10 +4115,6 @@ package body Exp_Ch6 is\n              and then Present (Generalized_Indexing (Ref));\n       end Is_Element_Reference;\n \n-      --  Local variables\n-\n-      Is_Elem_Ref : constant Boolean := Is_Element_Reference (N);\n-\n    --  Start of processing for Expand_Ctrl_Function_Call\n \n    begin\n@@ -4142,20 +4138,24 @@ package body Exp_Ch6 is\n \n       Remove_Side_Effects (N);\n \n-      --  When the temporary function result appears inside a case expression\n-      --  or an if expression, its lifetime must be extended to match that of\n-      --  the context. If not, the function result will be finalized too early\n-      --  and the evaluation of the expression could yield incorrect result. An\n-      --  exception to this rule are references to Ada 2012 container elements.\n+      --  The side effect removal of the function call produced a temporary.\n+      --  When the context is a case expression, if expression, or expression\n+      --  with actions, the lifetime of the temporary must be extended to match\n+      --  that of the context. Otherwise the function result will be finalized\n+      --  too early and affect the result of the expression. To prevent this\n+      --  unwanted effect, the temporary should not be considered for clean up\n+      --  actions by the general finalization machinery.\n+\n+      --  Exception to this rule are references to Ada 2012 container elements.\n       --  Such references must be finalized at the end of each iteration of the\n       --  related quantified expression, otherwise the container will remain\n       --  busy.\n \n-      if not Is_Elem_Ref\n+      if Nkind (N) = N_Explicit_Dereference\n         and then Within_Case_Or_If_Expression (N)\n-        and then Nkind (N) = N_Explicit_Dereference\n+        and then not Is_Element_Reference (N)\n       then\n-         Set_Is_Processed_Transient (Entity (Prefix (N)));\n+         Set_Is_Ignored_Transient (Entity (Prefix (N)));\n       end if;\n    end Expand_Ctrl_Function_Call;\n "}, {"sha": "2338deb675fd42e1a37bad6e9d5aa27e9fa0ef26", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 207, "deletions": 229, "changes": 436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/937e96763e42c48c29e3a5edf2eea3fb2c59fb27/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/937e96763e42c48c29e3a5edf2eea3fb2c59fb27/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=937e96763e42c48c29e3a5edf2eea3fb2c59fb27", "patch": "@@ -2080,11 +2080,19 @@ package body Exp_Ch7 is\n                if For_Package and then Finalize_Storage_Only (Obj_Typ) then\n                   null;\n \n-               --  Transient variables are treated separately in order to\n-               --  minimize the size of the generated code. For details, see\n-               --  Process_Transient_Objects.\n+               --  Finalization of transient objects are treated separately in\n+               --  order to handle sensitive cases. These include:\n \n-               elsif Is_Processed_Transient (Obj_Id) then\n+               --    * Aggregate expansion\n+               --    * If, case, and expression with actions expansion\n+               --    * Transient scopes\n+\n+               --  If one of those contexts has marked the transient object as\n+               --  ignored, do not generate finalization actions for it.\n+\n+               elsif Is_Finalized_Transient (Obj_Id)\n+                 or else Is_Ignored_Transient (Obj_Id)\n+               then\n                   null;\n \n                --  Ignored Ghost objects do not need any cleanup actions\n@@ -2139,8 +2147,8 @@ package body Exp_Ch7 is\n                then\n                   Processing_Actions (Has_No_Init => True);\n \n-               --  Processing for \"hook\" objects generated for controlled\n-               --  transients declared inside an Expression_With_Actions.\n+               --  Processing for \"hook\" objects generated for transient\n+               --  objects declared inside an Expression_With_Actions.\n \n                elsif Is_Access_Type (Obj_Typ)\n                  and then Present (Status_Flag_Or_Transient_Decl (Obj_Id))\n@@ -2353,7 +2361,7 @@ package body Exp_Ch7 is\n                   end if;\n                end if;\n \n-            --  Handle a rare case caused by a controlled transient variable\n+            --  Handle a rare case caused by a controlled transient object\n             --  created as part of a record init proc. The variable is wrapped\n             --  in a block, but the block is not associated with a transient\n             --  scope.\n@@ -3124,7 +3132,7 @@ package body Exp_Ch7 is\n               and then Present (Status_Flag_Or_Transient_Decl (Obj_Id))\n             then\n                --  Temporaries created for the purpose of \"exporting\" a\n-               --  controlled transient out of an Expression_With_Actions (EWA)\n+               --  transient object out of an Expression_With_Actions (EWA)\n                --  need guards. The following illustrates the usage of such\n                --  temporaries.\n \n@@ -6392,30 +6400,31 @@ package body Exp_Ch7 is\n       Act_Cleanup : constant List_Id :=\n         Scope_Stack.Table (Scope_Stack.Last).Actions_To_Be_Wrapped (Cleanup);\n       --  Note: We used to use renamings of Scope_Stack.Table (Scope_Stack.\n-      --  Last), but this was incorrect as Process_Transient_Object may\n+      --  Last), but this was incorrect as Process_Transients_In_Scope may\n       --  introduce new scopes and cause a reallocation of Scope_Stack.Table.\n \n-      procedure Process_Transient_Objects\n+      procedure Process_Transients_In_Scope\n         (First_Object : Node_Id;\n          Last_Object  : Node_Id;\n          Related_Node : Node_Id);\n-      --  First_Object and Last_Object define a list which contains potential\n-      --  controlled transient objects. Finalization flags are inserted before\n-      --  First_Object and finalization calls are inserted after Last_Object.\n-      --  Related_Node is the node for which transient objects have been\n-      --  created.\n+      --  Find all transient objects in the list First_Object .. Last_Object\n+      --  and generate finalization actions for them. Related_Node denotes the\n+      --  node which created all transient objects.\n \n-      -------------------------------\n-      -- Process_Transient_Objects --\n-      -------------------------------\n+      ---------------------------------\n+      -- Process_Transients_In_Scope --\n+      ---------------------------------\n \n-      procedure Process_Transient_Objects\n+      procedure Process_Transients_In_Scope\n         (First_Object : Node_Id;\n          Last_Object  : Node_Id;\n          Related_Node : Node_Id)\n       is\n+         Exceptions_OK : constant Boolean :=\n+                           not Restriction_Active (No_Exception_Propagation);\n+\n          Must_Hook : Boolean := False;\n-         --  Flag denoting whether the context requires transient variable\n+         --  Flag denoting whether the context requires transient object\n          --  export to the outer finalizer.\n \n          function Is_Subprogram_Call (N : Node_Id) return Traverse_Result;\n@@ -6424,6 +6433,15 @@ package body Exp_Ch7 is\n          procedure Detect_Subprogram_Call is\n            new Traverse_Proc (Is_Subprogram_Call);\n \n+         procedure Process_Transient_In_Scope\n+           (Obj_Decl  : Node_Id;\n+            Blk_Data  : Finalization_Exception_Data;\n+            Blk_Stmts : List_Id);\n+         --  Generate finalization actions for a single transient object\n+         --  denoted by object declaration Obj_Decl. Blk_Data is the\n+         --  exception data of the enclosing block. Blk_Stmts denotes the\n+         --  statements of the enclosing block.\n+\n          ------------------------\n          -- Is_Subprogram_Call --\n          ------------------------\n@@ -6466,32 +6484,149 @@ package body Exp_Ch7 is\n             end if;\n          end Is_Subprogram_Call;\n \n-         --  Local variables\n+         --------------------------------\n+         -- Process_Transient_In_Scope --\n+         --------------------------------\n \n-         Exceptions_OK : constant Boolean :=\n-                           not Restriction_Active (No_Exception_Propagation);\n+         procedure Process_Transient_In_Scope\n+           (Obj_Decl  : Node_Id;\n+            Blk_Data  : Finalization_Exception_Data;\n+            Blk_Stmts : List_Id)\n+         is\n+            Loc         : constant Source_Ptr := Sloc (Obj_Decl);\n+            Obj_Id      : constant Entity_Id  := Defining_Entity (Obj_Decl);\n+            Fin_Call    : Node_Id;\n+            Fin_Stmts   : List_Id;\n+            Hook_Assign : Node_Id;\n+            Hook_Clear  : Node_Id;\n+            Hook_Decl   : Node_Id;\n+            Hook_Insert : Node_Id;\n+            Ptr_Decl    : Node_Id;\n+\n+         begin\n+            --  Mark the transient object as successfully processed to avoid\n+            --  double finalization.\n+\n+            Set_Is_Finalized_Transient (Obj_Id);\n+\n+            --  Construct all the pieces necessary to hook and finalize the\n+            --  transient object.\n+\n+            Build_Transient_Object_Statements\n+              (Obj_Decl    => Obj_Decl,\n+               Fin_Call    => Fin_Call,\n+               Hook_Assign => Hook_Assign,\n+               Hook_Clear  => Hook_Clear,\n+               Hook_Decl   => Hook_Decl,\n+               Ptr_Decl    => Ptr_Decl);\n+\n+            --  The context contains at least one subprogram call which may\n+            --  raise an exception. This scenario employs \"hooking\" to pass\n+            --  transient objects to the enclosing finalizer in case of an\n+            --  exception.\n+\n+            if Must_Hook then\n+\n+               --  Add the access type which provides a reference to the\n+               --  transient object. Generate:\n+\n+               --    type Ptr_Typ is access all Desig_Typ;\n+\n+               Insert_Action (Obj_Decl, Ptr_Decl);\n+\n+               --  Add the temporary which acts as a hook to the transient\n+               --  object. Generate:\n+\n+               --    Hook : Ptr_Typ := null;\n+\n+               Insert_Action (Obj_Decl, Hook_Decl);\n+\n+               --  When the transient object is initialized by an aggregate,\n+               --  the hook must capture the object after the last aggregate\n+               --  assignment takes place. Only then is the object considered\n+               --  fully initialized. Generate:\n+\n+               --    Hook := Ptr_Typ (Obj_Id);\n+               --      <or>\n+               --    Hook := Obj_Id'Unrestricted_Access;\n+\n+               if Ekind_In (Obj_Id, E_Constant, E_Variable)\n+                 and then Present (Last_Aggregate_Assignment (Obj_Id))\n+               then\n+                  Hook_Insert := Last_Aggregate_Assignment (Obj_Id);\n+\n+               --  Otherwise the hook seizes the related object immediately\n+\n+               else\n+                  Hook_Insert := Obj_Decl;\n+               end if;\n+\n+               Insert_After_And_Analyze (Hook_Insert, Hook_Assign);\n+            end if;\n+\n+            --  When exception propagation is enabled wrap the hook clear\n+            --  statement and the finalization call into a block to catch\n+            --  potential exceptions raised during finalization. Generate:\n+\n+            --    begin\n+            --       [Hook := null;]\n+            --       [Deep_]Finalize (Obj_Ref);\n+\n+            --    exception\n+            --       when others =>\n+            --          if not Raised then\n+            --             Raised := True;\n+            --             Save_Occurrence\n+            --               (Enn, Get_Current_Excep.all.all);\n+            --          end if;\n+            --    end;\n+\n+            if Exceptions_OK then\n+               Fin_Stmts := New_List;\n+\n+               if Must_Hook then\n+                  Append_To (Fin_Stmts, Hook_Clear);\n+               end if;\n+\n+               Append_To (Fin_Stmts, Fin_Call);\n+\n+               Prepend_To (Blk_Stmts,\n+                 Make_Block_Statement (Loc,\n+                   Handled_Statement_Sequence =>\n+                     Make_Handled_Sequence_Of_Statements (Loc,\n+                       Statements         => Fin_Stmts,\n+                       Exception_Handlers => New_List (\n+                         Build_Exception_Handler (Blk_Data)))));\n+\n+            --  Otherwise generate:\n+\n+            --    [Hook := null;]\n+            --    [Deep_]Finalize (Obj_Ref);\n+\n+            --  Note that the statements are inserted in reverse order to\n+            --  achieve the desired final order outlined above.\n+\n+            else\n+               Prepend_To (Blk_Stmts, Fin_Call);\n+\n+               if Must_Hook then\n+                  Prepend_To (Blk_Stmts, Hook_Clear);\n+               end if;\n+            end if;\n+         end Process_Transient_In_Scope;\n+\n+         --  Local variables\n \n          Built     : Boolean := False;\n+         Blk_Data  : Finalization_Exception_Data;\n          Blk_Decl  : Node_Id := Empty;\n          Blk_Decls : List_Id := No_List;\n          Blk_Ins   : Node_Id;\n          Blk_Stmts : List_Id;\n-         Desig_Typ : Entity_Id;\n-         Fin_Call  : Node_Id;\n-         Fin_Data  : Finalization_Exception_Data;\n-         Fin_Stmts : List_Id;\n-         Hook_Clr  : Node_Id := Empty;\n-         Hook_Id   : Entity_Id;\n-         Hook_Ins  : Node_Id;\n-         Init_Expr : Node_Id;\n          Loc       : Source_Ptr;\n          Obj_Decl  : Node_Id;\n-         Obj_Id    : Entity_Id;\n-         Obj_Ref   : Node_Id;\n-         Obj_Typ   : Entity_Id;\n-         Ptr_Typ   : Entity_Id;\n \n-      --  Start of processing for Process_Transient_Objects\n+      --  Start of processing for Process_Transients_In_Scope\n \n       begin\n          --  The expansion performed by this routine is as follows:\n@@ -6536,11 +6671,11 @@ package body Exp_Ch7 is\n          --                Save_Occurrence (Ex, Get_Current_Excep.all.all);\n          --       end;\n \n+         --       Abort_Undefer;\n+\n          --       if Raised and not Abrt then\n          --          Raise_From_Controlled_Operation (Ex);\n          --       end if;\n-\n-         --       Abort_Undefer_Direct;\n          --    end;\n \n          --  Recognize a scenario where the transient context is an object\n@@ -6554,8 +6689,8 @@ package body Exp_Ch7 is\n          --    Obj  : ...;\n          --    Res  : ... := BIP_Func_Call (..., Obj, ...);\n \n-         --  The finalization of any controlled transient must happen after\n-         --  the build-in-place function call is executed.\n+         --  The finalization of any transient object must happen after the\n+         --  build-in-place function call is executed.\n \n          if Nkind (N) = N_Object_Declaration\n            and then Present (BIP_Initialization_Call (Defining_Identifier (N)))\n@@ -6589,114 +6724,7 @@ package body Exp_Ch7 is\n \n               and then Obj_Decl /= Related_Node\n             then\n-               Loc       := Sloc (Obj_Decl);\n-               Obj_Id    := Defining_Identifier (Obj_Decl);\n-               Obj_Typ   := Base_Type (Etype (Obj_Id));\n-               Desig_Typ := Obj_Typ;\n-\n-               Set_Is_Processed_Transient (Obj_Id);\n-\n-               --  Handle access types\n-\n-               if Is_Access_Type (Desig_Typ) then\n-                  Desig_Typ := Available_View (Designated_Type (Desig_Typ));\n-               end if;\n-\n-               --  Transient objects associated with subprogram calls need\n-               --  extra processing. These objects are usually created right\n-               --  before the call and finalized immediately after the call.\n-               --  If an exception occurs during the call, the clean up code\n-               --  is skipped due to the sudden change in control and the\n-               --  transient is never finalized.\n-\n-               --  To handle this case, such variables are \"exported\" to the\n-               --  enclosing sequence of statements where their corresponding\n-               --  \"hooks\" are picked up by the finalization machinery.\n-\n-               if Must_Hook then\n-\n-                  --  Create an access type which provides a reference to the\n-                  --  transient object. Generate:\n-                  --    type Ptr_Typ is access [all] Desig_Typ;\n-\n-                  Ptr_Typ := Make_Temporary (Loc, 'A');\n-\n-                  Insert_Action (Obj_Decl,\n-                    Make_Full_Type_Declaration (Loc,\n-                      Defining_Identifier => Ptr_Typ,\n-                      Type_Definition     =>\n-                        Make_Access_To_Object_Definition (Loc,\n-                          All_Present        =>\n-                            Ekind (Obj_Typ) = E_General_Access_Type,\n-                          Subtype_Indication =>\n-                            New_Occurrence_Of (Desig_Typ, Loc))));\n-\n-                  --  Create a temporary which acts as a hook to the transient\n-                  --  object. Generate:\n-                  --    Hook : Ptr_Typ := null;\n-\n-                  Hook_Id := Make_Temporary (Loc, 'T');\n-\n-                  Insert_Action (Obj_Decl,\n-                    Make_Object_Declaration (Loc,\n-                      Defining_Identifier => Hook_Id,\n-                      Object_Definition   =>\n-                        New_Occurrence_Of (Ptr_Typ, Loc)));\n-\n-                  --  Mark the temporary as a hook. This signals the machinery\n-                  --  in Build_Finalizer to recognize this special case.\n-\n-                  Set_Status_Flag_Or_Transient_Decl (Hook_Id, Obj_Decl);\n-\n-                  --  Hook the transient object to the temporary. Generate:\n-                  --    Hook := Ptr_Typ (Obj_Id);\n-                  --      <or>\n-                  --    Hook := Obj_Id'Unrestricted_Access;\n-\n-                  if Is_Access_Type (Obj_Typ) then\n-                     Init_Expr :=\n-                       Convert_To (Ptr_Typ, New_Occurrence_Of (Obj_Id, Loc));\n-\n-                  else\n-                     Init_Expr :=\n-                       Make_Attribute_Reference (Loc,\n-                         Prefix         => New_Occurrence_Of (Obj_Id, Loc),\n-                         Attribute_Name => Name_Unrestricted_Access);\n-                  end if;\n-\n-                  --  When the transient object is initialized by an aggregate,\n-                  --  the hook must capture the object after the last component\n-                  --  assignment takes place. Only then is the object fully\n-                  --  initialized.\n-\n-                  if Ekind (Obj_Id) = E_Variable\n-                    and then Present (Last_Aggregate_Assignment (Obj_Id))\n-                  then\n-                     Hook_Ins := Last_Aggregate_Assignment (Obj_Id);\n-\n-                  --  Otherwise the hook seizes the related object immediately\n-\n-                  else\n-                     Hook_Ins := Obj_Decl;\n-                  end if;\n-\n-                  Insert_After_And_Analyze (Hook_Ins,\n-                    Make_Assignment_Statement (Loc,\n-                      Name       => New_Occurrence_Of (Hook_Id, Loc),\n-                      Expression => Init_Expr));\n-\n-                  --  The transient object is about to be finalized by the\n-                  --  clean up code following the subprogram call. In order\n-                  --  to avoid double finalization, clear the hook.\n-\n-                  --  Generate:\n-                  --    Hook := null;\n-\n-                  Hook_Clr :=\n-                    Make_Assignment_Statement (Loc,\n-                      Name       => New_Occurrence_Of (Hook_Id, Loc),\n-                      Expression => Make_Null (Loc));\n-               end if;\n+               Loc := Sloc (Obj_Decl);\n \n                --  Before generating the clean up code for the first transient\n                --  object, create a wrapper block which houses all hook clear\n@@ -6707,25 +6735,14 @@ package body Exp_Ch7 is\n                   Built     := True;\n                   Blk_Stmts := New_List;\n \n-                  --  Create the declarations of all entities that participate\n-                  --  in exception detection and propagation.\n+                  --  Generate:\n+                  --    Abrt   : constant Boolean := ...;\n+                  --    Ex     : Exception_Occurrence;\n+                  --    Raised : Boolean := False;\n \n                   if Exceptions_OK then\n                      Blk_Decls := New_List;\n-\n-                     --  Generate:\n-                     --    Abrt   : constant Boolean := ...;\n-                     --    Ex     : Exception_Occurrence;\n-                     --    Raised : Boolean := False;\n-\n-                     Build_Object_Declarations (Fin_Data, Blk_Decls, Loc);\n-\n-                     --  Generate:\n-                     --    if Raised and then not Abrt then\n-                     --       Raise_From_Controlled_Operation (Ex);\n-                     --    end if;\n-\n-                     Append_To (Blk_Stmts, Build_Raise_Statement (Fin_Data));\n+                     Build_Object_Declarations (Blk_Data, Blk_Decls, Loc);\n                   end if;\n \n                   Blk_Decl :=\n@@ -6736,64 +6753,13 @@ package body Exp_Ch7 is\n                           Statements => Blk_Stmts));\n                end if;\n \n-               --  Generate:\n-               --    [Deep_]Finalize (Obj_Ref);\n-\n-               Obj_Ref := New_Occurrence_Of (Obj_Id, Loc);\n-\n-               if Is_Access_Type (Obj_Typ) then\n-                  Obj_Ref := Make_Explicit_Dereference (Loc, Obj_Ref);\n-                  Set_Etype (Obj_Ref, Desig_Typ);\n-               end if;\n-\n-               Fin_Call :=\n-                 Make_Final_Call (Obj_Ref => Obj_Ref, Typ => Desig_Typ);\n-\n-               --  When exception propagation is enabled wrap the hook clear\n-               --  statement and the finalization call into a block to catch\n-               --  potential exceptions raised during finalization. Generate:\n-\n-               --    begin\n-               --       [Temp := null;]\n-               --       [Deep_]Finalize (Obj_Ref);\n-\n-               --    exception\n-               --       when others =>\n-               --          if not Raised then\n-               --             Raised := True;\n-               --             Save_Occurrence\n-               --               (Enn, Get_Current_Excep.all.all);\n-               --          end if;\n-               --    end;\n-\n-               if Exceptions_OK then\n-                  Fin_Stmts := New_List;\n+               --  Construct all necessary circuitry to hook and finalize a\n+               --  single transient object.\n \n-                  if Present (Hook_Clr) then\n-                     Append_To (Fin_Stmts, Hook_Clr);\n-                  end if;\n-\n-                  Append_To (Fin_Stmts, Fin_Call);\n-\n-                  Prepend_To (Blk_Stmts,\n-                    Make_Block_Statement (Loc,\n-                      Handled_Statement_Sequence =>\n-                        Make_Handled_Sequence_Of_Statements (Loc,\n-                          Statements         => Fin_Stmts,\n-                          Exception_Handlers => New_List (\n-                            Build_Exception_Handler (Fin_Data)))));\n-\n-               --  Otherwise generate:\n-               --    [Temp := null;]\n-               --    [Deep_]Finalize (Obj_Ref);\n-\n-               else\n-                  Prepend_To (Blk_Stmts, Fin_Call);\n-\n-                  if Present (Hook_Clr) then\n-                     Prepend_To (Blk_Stmts, Hook_Clr);\n-                  end if;\n-               end if;\n+               Process_Transient_In_Scope\n+                 (Obj_Decl  => Obj_Decl,\n+                  Blk_Data  => Blk_Data,\n+                  Blk_Stmts => Blk_Stmts);\n             end if;\n \n             --  Terminate the scan after the last object has been processed to\n@@ -6806,12 +6772,15 @@ package body Exp_Ch7 is\n             Next (Obj_Decl);\n          end loop;\n \n+         --  Complete the decoration of the enclosing finalization block and\n+         --  insert it into the tree.\n+\n          if Present (Blk_Decl) then\n \n-            --  Note that the abort defer / undefer pair does not require an\n-            --  extra block because each finalization exception is caught in\n-            --  its corresponding finalization block. As a result, the call to\n-            --  Abort_Defer always takes place.\n+            --  Note that this Abort_Undefer does not require a extra block or\n+            --  an AT_END handler because each finalization exception is caught\n+            --  in its own corresponding finalization block. As a result, the\n+            --  call to Abort_Defer always takes place.\n \n             if Abort_Allowed then\n                Prepend_To (Blk_Stmts,\n@@ -6821,9 +6790,18 @@ package body Exp_Ch7 is\n                  Build_Runtime_Call (Loc, RE_Abort_Undefer));\n             end if;\n \n+            --  Generate:\n+            --    if Raised and then not Abrt then\n+            --       Raise_From_Controlled_Operation (Ex);\n+            --    end if;\n+\n+            if Exceptions_OK then\n+               Append_To (Blk_Stmts, Build_Raise_Statement (Blk_Data));\n+            end if;\n+\n             Insert_After_And_Analyze (Blk_Ins, Blk_Decl);\n          end if;\n-      end Process_Transient_Objects;\n+      end Process_Transients_In_Scope;\n \n       --  Local variables\n \n@@ -6901,10 +6879,10 @@ package body Exp_Ch7 is\n            (Last_Obj, Build_SS_Release_Call (Loc, Mark_Id));\n       end if;\n \n-      --  Check for transient controlled objects associated with Target and\n-      --  generate the appropriate finalization actions for them.\n+      --  Check for transient objects associated with Target and generate the\n+      --  appropriate finalization actions for them.\n \n-      Process_Transient_Objects\n+      Process_Transients_In_Scope\n         (First_Object => First_Obj,\n          Last_Object  => Last_Obj,\n          Related_Node => Target);"}, {"sha": "92a3aab53a594bcc66481914cf5f6b1325e9d8a0", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 147, "deletions": 8, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/937e96763e42c48c29e3a5edf2eea3fb2c59fb27/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/937e96763e42c48c29e3a5edf2eea3fb2c59fb27/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=937e96763e42c48c29e3a5edf2eea3fb2c59fb27", "patch": "@@ -1653,6 +1653,133 @@ package body Exp_Util is\n       return Build_Task_Image_Function (Loc, Decls, Stats, Res);\n    end Build_Task_Record_Image;\n \n+   ---------------------------------------\n+   -- Build_Transient_Object_Statements --\n+   ---------------------------------------\n+\n+   procedure Build_Transient_Object_Statements\n+     (Obj_Decl     : Node_Id;\n+      Fin_Call     : out Node_Id;\n+      Hook_Assign  : out Node_Id;\n+      Hook_Clear   : out Node_Id;\n+      Hook_Decl    : out Node_Id;\n+      Ptr_Decl     : out Node_Id;\n+      Finalize_Obj : Boolean := True)\n+   is\n+      Loc     : constant Source_Ptr := Sloc (Obj_Decl);\n+      Obj_Id  : constant Entity_Id  := Defining_Entity (Obj_Decl);\n+      Obj_Typ : constant Entity_Id  := Base_Type (Etype (Obj_Id));\n+\n+      Desig_Typ : Entity_Id;\n+      Hook_Expr : Node_Id;\n+      Hook_Id   : Entity_Id;\n+      Obj_Ref   : Node_Id;\n+      Ptr_Typ   : Entity_Id;\n+\n+   begin\n+      --  Recover the type of the object\n+\n+      Desig_Typ := Obj_Typ;\n+\n+      if Is_Access_Type (Desig_Typ) then\n+         Desig_Typ := Available_View (Designated_Type (Desig_Typ));\n+      end if;\n+\n+      --  Create an access type which provides a reference to the transient\n+      --  object. Generate:\n+\n+      --    type Ptr_Typ is access all Desig_Typ;\n+\n+      Ptr_Typ := Make_Temporary (Loc, 'A');\n+      Set_Ekind (Ptr_Typ, E_General_Access_Type);\n+      Set_Directly_Designated_Type (Ptr_Typ, Desig_Typ);\n+\n+      Ptr_Decl :=\n+        Make_Full_Type_Declaration (Loc,\n+          Defining_Identifier => Ptr_Typ,\n+          Type_Definition     =>\n+            Make_Access_To_Object_Definition (Loc,\n+              All_Present        => True,\n+              Subtype_Indication => New_Occurrence_Of (Desig_Typ, Loc)));\n+\n+      --  Create a temporary check which acts as a hook to the transient\n+      --  object. Generate:\n+\n+      --    Hook : Ptr_Typ := null;\n+\n+      Hook_Id := Make_Temporary (Loc, 'T');\n+      Set_Ekind (Hook_Id, E_Variable);\n+      Set_Etype (Hook_Id, Ptr_Typ);\n+\n+      Hook_Decl :=\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Hook_Id,\n+          Object_Definition   => New_Occurrence_Of (Ptr_Typ, Loc),\n+          Expression          => Make_Null (Loc));\n+\n+      --  Mark the temporary as a hook. This signals the machinery in\n+      --  Build_Finalizer to recognize this special case.\n+\n+      Set_Status_Flag_Or_Transient_Decl (Hook_Id, Obj_Decl);\n+\n+      --  Hook the transient object to the temporary. Generate:\n+\n+      --    Hook := Ptr_Typ (Obj_Id);\n+      --      <or>\n+      --    Hool := Obj_Id'Unrestricted_Access;\n+\n+      if Is_Access_Type (Obj_Typ) then\n+         Hook_Expr :=\n+           Unchecked_Convert_To (Ptr_Typ, New_Occurrence_Of (Obj_Id, Loc));\n+      else\n+         Hook_Expr :=\n+           Make_Attribute_Reference (Loc,\n+             Prefix         => New_Occurrence_Of (Obj_Id, Loc),\n+             Attribute_Name => Name_Unrestricted_Access);\n+      end if;\n+\n+      Hook_Assign :=\n+        Make_Assignment_Statement (Loc,\n+          Name       => New_Occurrence_Of (Hook_Id, Loc),\n+          Expression => Hook_Expr);\n+\n+      --  Crear the hook prior to finalizing the object. Generate:\n+\n+      --    Hook := null;\n+\n+      Hook_Clear :=\n+        Make_Assignment_Statement (Loc,\n+          Name       => New_Occurrence_Of (Hook_Id, Loc),\n+          Expression => Make_Null (Loc));\n+\n+      --  Finalize the object. Generate:\n+\n+      --    [Deep_]Finalize (Obj_Ref[.all]);\n+\n+      if Finalize_Obj then\n+         Obj_Ref := New_Occurrence_Of (Obj_Id, Loc);\n+\n+         if Is_Access_Type (Obj_Typ) then\n+            Obj_Ref := Make_Explicit_Dereference (Loc, Obj_Ref);\n+            Set_Etype (Obj_Ref, Desig_Typ);\n+         end if;\n+\n+         Fin_Call := Make_Final_Call (Obj_Ref, Desig_Typ);\n+\n+      --  Otherwise finalize the hook. Generate:\n+\n+      --    [Deep_]Finalize (Hook.all);\n+\n+      else\n+         Fin_Call :=\n+           Make_Final_Call (\n+             Obj_Ref =>\n+               Make_Explicit_Dereference (Loc,\n+                 Prefix => New_Occurrence_Of (Hook_Id, Loc)),\n+             Typ     => Desig_Typ);\n+      end if;\n+   end Build_Transient_Object_Statements;\n+\n    -----------------------------\n    -- Check_Float_Op_Overflow --\n    -----------------------------\n@@ -5067,7 +5194,7 @@ package body Exp_Util is\n          --  explicit aliases of it:\n \n          --    do\n-         --       Trans_Id : Ctrl_Typ ...;  --  controlled transient object\n+         --       Trans_Id : Ctrl_Typ ...;  --  transient object\n          --       Alias : ... := Trans_Id;  --  object is aliased\n          --       Val : constant Boolean :=\n          --               ... Alias ...;    --  aliasing ends\n@@ -5236,6 +5363,10 @@ package body Exp_Util is\n           and then Requires_Transient_Scope (Desig)\n           and then Nkind (Rel_Node) /= N_Simple_Return_Statement\n \n+          --  Do not consider a transient object that was already processed\n+\n+          and then not Is_Finalized_Transient (Obj_Id)\n+\n           --  Do not consider renamed or 'reference-d transient objects because\n           --  the act of renaming extends the object's lifetime.\n \n@@ -8255,11 +8386,19 @@ package body Exp_Util is\n             if Lib_Level and then Finalize_Storage_Only (Obj_Typ) then\n                null;\n \n-            --  Transient variables are treated separately in order to minimize\n-            --  the size of the generated code. See Exp_Ch7.Process_Transient_\n-            --  Objects.\n+            --  Finalization of transient objects are treated separately in\n+            --  order to handle sensitive cases. These include:\n \n-            elsif Is_Processed_Transient (Obj_Id) then\n+            --    * Aggregate expansion\n+            --    * If, case, and expression with actions expansion\n+            --    * Transient scopes\n+\n+            --  If one of those contexts has marked the transient object as\n+            --  ignored, do not generate finalization actions for it.\n+\n+            elsif Is_Finalized_Transient (Obj_Id)\n+              or else Is_Ignored_Transient (Obj_Id)\n+            then\n                null;\n \n             --  Ignored Ghost objects do not need any cleanup actions because\n@@ -8315,8 +8454,8 @@ package body Exp_Util is\n             then\n                return True;\n \n-            --  Processing for \"hook\" objects generated for controlled\n-            --  transients declared inside an Expression_With_Actions.\n+            --  Processing for \"hook\" objects generated for transient objects\n+            --  declared inside an Expression_With_Actions.\n \n             elsif Is_Access_Type (Obj_Typ)\n               and then Present (Status_Flag_Or_Transient_Decl (Obj_Id))\n@@ -8464,7 +8603,7 @@ package body Exp_Util is\n          elsif Nkind (Decl) = N_Block_Statement\n            and then\n \n-           --  Handle a rare case caused by a controlled transient variable\n+           --  Handle a rare case caused by a controlled transient object\n            --  created as part of a record init proc. The variable is wrapped\n            --  in a block, but the block is not associated with a transient\n            --  scope."}, {"sha": "e5b991690b4be2228ff9f5d4cdb5e4492b01e084", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/937e96763e42c48c29e3a5edf2eea3fb2c59fb27/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/937e96763e42c48c29e3a5edf2eea3fb2c59fb27/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=937e96763e42c48c29e3a5edf2eea3fb2c59fb27", "patch": "@@ -280,6 +280,35 @@ package Exp_Util is\n    --  is false, the call is for a stand-alone object, and the generated\n    --  function itself must do its own cleanups.\n \n+   procedure Build_Transient_Object_Statements\n+     (Obj_Decl     : Node_Id;\n+      Fin_Call     : out Node_Id;\n+      Hook_Assign  : out Node_Id;\n+      Hook_Clear   : out Node_Id;\n+      Hook_Decl    : out Node_Id;\n+      Ptr_Decl     : out Node_Id;\n+      Finalize_Obj : Boolean := True);\n+   --  Subsidiary to the processing of transient objects in transient scopes,\n+   --  if expressions, case expressions, expression_with_action nodes, array\n+   --  aggregates, and record aggregates. Obj_Decl denotes the declaration of\n+   --  the transient object. Generate the following nodes:\n+   --\n+   --    * Fin_Call - the call to [Deep_]Finalize which cleans up the transient\n+   --    object if flag Finalize_Obj is set to True, or finalizes the hook when\n+   --    the flag is False.\n+   --\n+   --    * Hook_Assign - the assignment statement which captures a reference to\n+   --    the transient object in the hook.\n+   --\n+   --    * Hook_Clear - the assignment statement which resets the hook to null\n+   --\n+   --    * Hook_Decl - the declaration of the hook object\n+   --\n+   --    * Ptr_Decl - the full type declaration of the hook type\n+   --\n+   --  These nodes are inserted in specific places depending on the context by\n+   --  the various Process_Transient_xxx routines.\n+\n    procedure Check_Float_Op_Overflow (N : Node_Id);\n    --  Called where we could have a floating-point binary operator where we\n    --  must check for infinities if we are operating in Check_Float_Overflow"}, {"sha": "580d33ecce60dc4e256d8db203cab9c65b7e73fa", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 328, "deletions": 344, "changes": 672, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/937e96763e42c48c29e3a5edf2eea3fb2c59fb27/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/937e96763e42c48c29e3a5edf2eea3fb2c59fb27/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=937e96763e42c48c29e3a5edf2eea3fb2c59fb27", "patch": "@@ -2930,7 +2930,7 @@ package body Sem_Aggr is\n          end if;\n \n       else\n-         Error_Msg_N (\"no unique type for this aggregate\",  A);\n+         Error_Msg_N (\"no unique type for this aggregate\", A);\n       end if;\n \n       Check_Function_Writable_Actuals (N);\n@@ -2941,25 +2941,9 @@ package body Sem_Aggr is\n    ------------------------------\n \n    procedure Resolve_Record_Aggregate (N : Node_Id; Typ : Entity_Id) is\n-      Assoc : Node_Id;\n-      --  N_Component_Association node belonging to the input aggregate N\n-\n-      Expr            : Node_Id;\n-      Positional_Expr : Node_Id;\n-      Component       : Entity_Id;\n-      Component_Elmt  : Elmt_Id;\n-\n-      Components : constant Elist_Id := New_Elmt_List;\n-      --  Components is the list of the record components whose value must be\n-      --  provided in the aggregate. This list does include discriminants.\n-\n       New_Assoc_List : constant List_Id := New_List;\n-      New_Assoc      : Node_Id;\n       --  New_Assoc_List is the newly built list of N_Component_Association\n-      --  nodes. New_Assoc is one such N_Component_Association node in it.\n-      --  Note that while Assoc and New_Assoc contain the same kind of nodes,\n-      --  they are used to iterate over two different N_Component_Association\n-      --  lists.\n+      --  nodes.\n \n       Others_Etype : Entity_Id := Empty;\n       --  This variable is used to save the Etype of the last record component\n@@ -2975,17 +2959,16 @@ package body Sem_Aggr is\n       Box_Node       : Node_Id;\n       Is_Box_Present : Boolean := False;\n       Others_Box     : Integer := 0;\n-\n       --  Ada 2005 (AI-287): Variables used in case of default initialization\n       --  to provide a functionality similar to Others_Etype. Box_Present\n       --  indicates that the component takes its default initialization;\n       --  Others_Box counts the number of components of the current aggregate\n       --  (which may be a sub-aggregate of a larger one) that are default-\n       --  initialized. A value of One indicates that an others_box is present.\n       --  Any larger value indicates that the others_box is not redundant.\n-      --  These variables, similar to Others_Etype, are also updated as a\n-      --  side effect of function Get_Value.\n-      --  Box_Node is used to place a warning on a redundant others_box.\n+      --  These variables, similar to Others_Etype, are also updated as a side\n+      --  effect of function Get_Value. Box_Node is used to place a warning on\n+      --  a redundant others_box.\n \n       procedure Add_Association\n         (Component      : Entity_Id;\n@@ -2997,26 +2980,40 @@ package body Sem_Aggr is\n       --  either New_Assoc_List, or the association being built for an inner\n       --  aggregate.\n \n-      function Discr_Present (Discr : Entity_Id) return Boolean;\n+      procedure Add_Discriminant_Values\n+        (New_Aggr   : Node_Id;\n+         Assoc_List : List_Id);\n+      --  The constraint to a component may be given by a discriminant of the\n+      --  enclosing type, in which case we have to retrieve its value, which is\n+      --  part of the enclosing aggregate. Assoc_List provides the discriminant\n+      --  associations of the current type or of some enclosing record.\n+\n+      function Discriminant_Present (Input_Discr : Entity_Id) return Boolean;\n       --  If aggregate N is a regular aggregate this routine will return True.\n-      --  Otherwise, if N is an extension aggregate, Discr is a discriminant\n-      --  whose value may already have been specified by N's ancestor part.\n-      --  This routine checks whether this is indeed the case and if so returns\n-      --  False, signaling that no value for Discr should appear in N's\n-      --  aggregate part. Also, in this case, the routine appends to\n-      --  New_Assoc_List the discriminant value specified in the ancestor part.\n+      --  Otherwise, if N is an extension aggregate, then Input_Discr denotes\n+      --  a discriminant whose value may already have been specified by N's\n+      --  ancestor part. This routine checks whether this is indeed the case\n+      --  and if so returns False, signaling that no value for Input_Discr\n+      --  should appear in N's aggregate part. Also, in this case, the routine\n+      --  appends to New_Assoc_List the discriminant value specified in the\n+      --  ancestor part.\n       --\n       --  If the aggregate is in a context with expansion delayed, it will be\n       --  reanalyzed. The inherited discriminant values must not be reinserted\n       --  in the component list to prevent spurious errors, but they must be\n       --  present on first analysis to build the proper subtype indications.\n       --  The flag Inherited_Discriminant is used to prevent the re-insertion.\n \n+      function Find_Private_Ancestor (Typ : Entity_Id) return Entity_Id;\n+      --  AI05-0115: Find earlier ancestor in the derivation chain that is\n+      --  derived from private view Typ. Whether the aggregate is legal depends\n+      --  on the current visibility of the type as well as that of the parent\n+      --  of the ancestor.\n+\n       function Get_Value\n         (Compon                 : Node_Id;\n          From                   : List_Id;\n-         Consider_Others_Choice : Boolean := False)\n-         return                   Node_Id;\n+         Consider_Others_Choice : Boolean := False) return Node_Id;\n       --  Given a record component stored in parameter Compon, this function\n       --  returns its value as it appears in the list From, which is a list\n       --  of N_Component_Association nodes.\n@@ -3041,7 +3038,14 @@ package body Sem_Aggr is\n       --  Same as New_Copy_Tree (defined in Sem_Util), except that this routine\n       --  also copies the dimensions of Source to the returned node.\n \n-      procedure Resolve_Aggr_Expr (Expr : Node_Id; Component : Node_Id);\n+      procedure Propagate_Discriminants\n+        (Aggr       : Node_Id;\n+         Assoc_List : List_Id);\n+      --  Nested components may themselves be discriminated types constrained\n+      --  by outer discriminants, whose values must be captured before the\n+      --  aggregate is expanded into assignments.\n+\n+      procedure Resolve_Aggr_Expr (Expr : Node_Id; Component : Entity_Id);\n       --  Analyzes and resolves expression Expr against the Etype of the\n       --  Component. This routine also applies all appropriate checks to Expr.\n       --  It finally saves a Expr in the newly created association list that\n@@ -3059,48 +3063,110 @@ package body Sem_Aggr is\n          Assoc_List     : List_Id;\n          Is_Box_Present : Boolean := False)\n       is\n-         Loc : Source_Ptr;\n          Choice_List : constant List_Id := New_List;\n-         New_Assoc   : Node_Id;\n+         Loc         : Source_Ptr;\n \n       begin\n-         --  If this is a box association the expression is missing, so\n-         --  use the Sloc of the aggregate itself for the new association.\n+         --  If this is a box association the expression is missing, so use the\n+         --  Sloc of the aggregate itself for the new association.\n \n          if Present (Expr) then\n             Loc := Sloc (Expr);\n          else\n             Loc := Sloc (N);\n          end if;\n \n-         Append (New_Occurrence_Of (Component, Loc), Choice_List);\n-         New_Assoc :=\n+         Append_To (Choice_List, New_Occurrence_Of (Component, Loc));\n+\n+         Append_To (Assoc_List,\n            Make_Component_Association (Loc,\n              Choices     => Choice_List,\n              Expression  => Expr,\n-             Box_Present => Is_Box_Present);\n-         Append (New_Assoc, Assoc_List);\n+             Box_Present => Is_Box_Present));\n       end Add_Association;\n \n-      -------------------\n-      -- Discr_Present --\n-      -------------------\n+      -----------------------------\n+      -- Add_Discriminant_Values --\n+      -----------------------------\n+\n+      procedure Add_Discriminant_Values\n+        (New_Aggr   : Node_Id;\n+         Assoc_List : List_Id)\n+      is\n+         Assoc      : Node_Id;\n+         Discr      : Entity_Id;\n+         Discr_Elmt : Elmt_Id;\n+         Discr_Val  : Node_Id;\n+         Val        : Entity_Id;\n+\n+      begin\n+         Discr      := First_Discriminant (Etype (New_Aggr));\n+         Discr_Elmt := First_Elmt (Discriminant_Constraint (Etype (New_Aggr)));\n+         while Present (Discr_Elmt) loop\n+            Discr_Val := Node (Discr_Elmt);\n+\n+            --  If the constraint is given by a discriminant then it is a\n+            --  discriminant of an enclosing record, and its value has already\n+            --  been placed in the association list.\n \n-      function Discr_Present (Discr : Entity_Id) return Boolean is\n+            if Is_Entity_Name (Discr_Val)\n+              and then Ekind (Entity (Discr_Val)) = E_Discriminant\n+            then\n+               Val := Entity (Discr_Val);\n+\n+               Assoc := First (Assoc_List);\n+               while Present (Assoc) loop\n+                  if Present (Entity (First (Choices (Assoc))))\n+                    and then Entity (First (Choices (Assoc))) = Val\n+                  then\n+                     Discr_Val := Expression (Assoc);\n+                     exit;\n+                  end if;\n+\n+                  Next (Assoc);\n+               end loop;\n+            end if;\n+\n+            Add_Association\n+              (Discr, New_Copy_Tree (Discr_Val),\n+               Component_Associations (New_Aggr));\n+\n+            --  If the discriminant constraint is a current instance, mark the\n+            --  current aggregate so that the self-reference can be expanded\n+            --  later. The constraint may refer to the subtype of aggregate, so\n+            --  use base type for comparison.\n+\n+            if Nkind (Discr_Val) = N_Attribute_Reference\n+              and then Is_Entity_Name (Prefix (Discr_Val))\n+              and then Is_Type (Entity (Prefix (Discr_Val)))\n+              and then Base_Type (Etype (N)) = Entity (Prefix (Discr_Val))\n+            then\n+               Set_Has_Self_Reference (N);\n+            end if;\n+\n+            Next_Elmt (Discr_Elmt);\n+            Next_Discriminant (Discr);\n+         end loop;\n+      end Add_Discriminant_Values;\n+\n+      --------------------------\n+      -- Discriminant_Present --\n+      --------------------------\n+\n+      function Discriminant_Present (Input_Discr : Entity_Id) return Boolean is\n          Regular_Aggr : constant Boolean := Nkind (N) /= N_Extension_Aggregate;\n \n+         Ancestor_Is_Subtyp : Boolean;\n+\n          Loc : Source_Ptr;\n \n          Ancestor     : Node_Id;\n+         Ancestor_Typ : Entity_Id;\n          Comp_Assoc   : Node_Id;\n+         Discr        : Entity_Id;\n          Discr_Expr   : Node_Id;\n-\n-         Ancestor_Typ : Entity_Id;\n+         Discr_Val    : Elmt_Id := No_Elmt;\n          Orig_Discr   : Entity_Id;\n-         D            : Entity_Id;\n-         D_Val        : Elmt_Id := No_Elmt; -- stop junk warning\n-\n-         Ancestor_Is_Subtyp : Boolean;\n \n       begin\n          if Regular_Aggr then\n@@ -3157,41 +3223,66 @@ package body Sem_Aggr is\n          --  Now look to see if Discr was specified in the ancestor part\n \n          if Ancestor_Is_Subtyp then\n-            D_Val := First_Elmt (Discriminant_Constraint (Entity (Ancestor)));\n+            Discr_Val :=\n+              First_Elmt (Discriminant_Constraint (Entity (Ancestor)));\n          end if;\n \n-         Orig_Discr := Original_Record_Component (Discr);\n+         Orig_Discr := Original_Record_Component (Input_Discr);\n \n-         D := First_Discriminant (Ancestor_Typ);\n-         while Present (D) loop\n+         Discr := First_Discriminant (Ancestor_Typ);\n+         while Present (Discr) loop\n \n             --  If Ancestor has already specified Disc value then insert its\n             --  value in the final aggregate.\n \n-            if Original_Record_Component (D) = Orig_Discr then\n+            if Original_Record_Component (Discr) = Orig_Discr then\n                if Ancestor_Is_Subtyp then\n-                  Discr_Expr := New_Copy_Tree (Node (D_Val));\n+                  Discr_Expr := New_Copy_Tree (Node (Discr_Val));\n                else\n                   Discr_Expr :=\n                     Make_Selected_Component (Loc,\n                       Prefix        => Duplicate_Subexpr (Ancestor),\n-                      Selector_Name => New_Occurrence_Of (Discr, Loc));\n+                      Selector_Name => New_Occurrence_Of (Input_Discr, Loc));\n                end if;\n \n-               Resolve_Aggr_Expr (Discr_Expr, Discr);\n+               Resolve_Aggr_Expr (Discr_Expr, Input_Discr);\n                Set_Inherited_Discriminant (Last (New_Assoc_List));\n                return False;\n             end if;\n \n-            Next_Discriminant (D);\n+            Next_Discriminant (Discr);\n \n             if Ancestor_Is_Subtyp then\n-               Next_Elmt (D_Val);\n+               Next_Elmt (Discr_Val);\n             end if;\n          end loop;\n \n          return True;\n-      end Discr_Present;\n+      end Discriminant_Present;\n+\n+      ---------------------------\n+      -- Find_Private_Ancestor --\n+      ---------------------------\n+\n+      function Find_Private_Ancestor (Typ : Entity_Id) return Entity_Id is\n+         Par : Entity_Id;\n+\n+      begin\n+         Par := Typ;\n+         loop\n+            if Has_Private_Ancestor (Par)\n+              and then not Has_Private_Ancestor (Etype (Base_Type (Par)))\n+            then\n+               return Par;\n+\n+            elsif not Is_Derived_Type (Par) then\n+               return Empty;\n+\n+            else\n+               Par := Etype (Base_Type (Par));\n+            end if;\n+         end loop;\n+      end Find_Private_Ancestor;\n \n       ---------------\n       -- Get_Value --\n@@ -3200,8 +3291,7 @@ package body Sem_Aggr is\n       function Get_Value\n         (Compon                 : Node_Id;\n          From                   : List_Id;\n-         Consider_Others_Choice : Boolean := False)\n-         return                   Node_Id\n+         Consider_Others_Choice : Boolean := False) return Node_Id\n       is\n          Typ           : constant Entity_Id := Etype (Compon);\n          Assoc         : Node_Id;\n@@ -3266,14 +3356,14 @@ package body Sem_Aggr is\n                               null;\n                            else\n                               Error_Msg_N\n-                                (\"components in OTHERS choice must \"\n-                                 & \"have same type\", Selector_Name);\n+                                (\"components in OTHERS choice must have same \"\n+                                 & \"type\", Selector_Name);\n                            end if;\n                         end if;\n \n                         Others_Etype := Typ;\n \n-                        --  Copy expression so that it is resolved\n+                        --  Copy the expression so that it is resolved\n                         --  independently for each component, This is needed\n                         --  for accessibility checks on compoents of anonymous\n                         --  access types, even in compile_only mode.\n@@ -3414,11 +3504,110 @@ package body Sem_Aggr is\n          return New_Copy;\n       end New_Copy_Tree_And_Copy_Dimensions;\n \n+      -----------------------------\n+      -- Propagate_Discriminants --\n+      -----------------------------\n+\n+      procedure Propagate_Discriminants\n+        (Aggr       : Node_Id;\n+         Assoc_List : List_Id)\n+      is\n+         Loc : constant Source_Ptr := Sloc (N);\n+\n+         Needs_Box : Boolean := False;\n+\n+         procedure Process_Component (Comp : Entity_Id);\n+         --  Add one component with a box association to the inner aggregate,\n+         --  and recurse if component is itself composite.\n+\n+         -----------------------\n+         -- Process_Component --\n+         -----------------------\n+\n+         procedure Process_Component (Comp : Entity_Id) is\n+            T        : constant Entity_Id := Etype (Comp);\n+            New_Aggr : Node_Id;\n+\n+         begin\n+            if Is_Record_Type (T) and then Has_Discriminants (T) then\n+               New_Aggr := Make_Aggregate (Loc, New_List, New_List);\n+               Set_Etype (New_Aggr, T);\n+\n+               Add_Association\n+                 (Comp, New_Aggr, Component_Associations (Aggr));\n+\n+               --  Collect discriminant values and recurse\n+\n+               Add_Discriminant_Values (New_Aggr, Assoc_List);\n+               Propagate_Discriminants (New_Aggr, Assoc_List);\n+\n+            else\n+               Needs_Box := True;\n+            end if;\n+         end Process_Component;\n+\n+         --  Local variables\n+\n+         Aggr_Type  : constant Entity_Id := Base_Type (Etype (Aggr));\n+         Components : constant Elist_Id  := New_Elmt_List;\n+         Def_Node   : constant Node_Id   :=\n+                       Type_Definition (Declaration_Node (Aggr_Type));\n+\n+         Comp      : Node_Id;\n+         Comp_Elmt : Elmt_Id;\n+         Errors    : Boolean;\n+\n+      --  Start of processing for Propagate_Discriminants\n+\n+      begin\n+         --  The component type may be a variant type. Collect the components\n+         --  that are ruled by the known values of the discriminants. Their\n+         --  values have already been inserted into the component list of the\n+         --  current aggregate.\n+\n+         if Nkind (Def_Node) = N_Record_Definition\n+           and then Present (Component_List (Def_Node))\n+           and then Present (Variant_Part (Component_List (Def_Node)))\n+         then\n+            Gather_Components (Aggr_Type,\n+              Component_List (Def_Node),\n+              Governed_By   => Component_Associations (Aggr),\n+              Into          => Components,\n+              Report_Errors => Errors);\n+\n+            Comp_Elmt := First_Elmt (Components);\n+            while Present (Comp_Elmt) loop\n+               if Ekind (Node (Comp_Elmt)) /= E_Discriminant then\n+                  Process_Component (Node (Comp_Elmt));\n+               end if;\n+\n+               Next_Elmt (Comp_Elmt);\n+            end loop;\n+\n+            --  No variant part, iterate over all components\n+\n+         else\n+            Comp := First_Component (Etype (Aggr));\n+            while Present (Comp) loop\n+               Process_Component (Comp);\n+               Next_Component (Comp);\n+            end loop;\n+         end if;\n+\n+         if Needs_Box then\n+            Append_To (Component_Associations (Aggr),\n+              Make_Component_Association (Loc,\n+                Choices     => New_List (Make_Others_Choice (Loc)),\n+                Expression  => Empty,\n+                Box_Present => True));\n+         end if;\n+      end Propagate_Discriminants;\n+\n       -----------------------\n       -- Resolve_Aggr_Expr --\n       -----------------------\n \n-      procedure Resolve_Aggr_Expr (Expr : Node_Id; Component : Node_Id) is\n+      procedure Resolve_Aggr_Expr (Expr : Node_Id; Component : Entity_Id) is\n          function Has_Expansion_Delayed (Expr : Node_Id) return Boolean;\n          --  If the expression is an aggregate (possibly qualified) then its\n          --  expansion is delayed until the enclosing aggregate is expanded\n@@ -3433,14 +3622,15 @@ package body Sem_Aggr is\n          ---------------------------\n \n          function Has_Expansion_Delayed (Expr : Node_Id) return Boolean is\n-            Kind : constant Node_Kind := Nkind (Expr);\n          begin\n-            return (Nkind_In (Kind, N_Aggregate, N_Extension_Aggregate)\n-                     and then Present (Etype (Expr))\n-                     and then Is_Record_Type (Etype (Expr))\n-                     and then Expansion_Delayed (Expr))\n-              or else (Kind = N_Qualified_Expression\n-                        and then Has_Expansion_Delayed (Expression (Expr)));\n+            return\n+               (Nkind_In (Expr, N_Aggregate, N_Extension_Aggregate)\n+                 and then Present (Etype (Expr))\n+                 and then Is_Record_Type (Etype (Expr))\n+                 and then Expansion_Delayed (Expr))\n+              or else\n+                (Nkind (Expr) = N_Qualified_Expression\n+                  and then Has_Expansion_Delayed (Expression (Expr)));\n          end Has_Expansion_Delayed;\n \n          --  Local variables\n@@ -3580,6 +3770,8 @@ package body Sem_Aggr is\n             Generate_Range_Check (Expr, Expr_Type, CE_Range_Check_Failed);\n          end if;\n \n+         --  Add association Component => Expr if the caller requests it\n+\n          if Relocate then\n             New_Expr := Relocate_Node (Expr);\n \n@@ -3595,6 +3787,17 @@ package body Sem_Aggr is\n          Add_Association (New_C, New_Expr, New_Assoc_List);\n       end Resolve_Aggr_Expr;\n \n+      --  Local variables\n+\n+      Components : constant Elist_Id := New_Elmt_List;\n+      --  Components is the list of the record components whose value must be\n+      --  provided in the aggregate. This list does include discriminants.\n+\n+      Expr            : Node_Id;\n+      Component       : Entity_Id;\n+      Component_Elmt  : Elmt_Id;\n+      Positional_Expr : Node_Id;\n+\n    --  Start of processing for Resolve_Record_Aggregate\n \n    begin\n@@ -3607,7 +3810,6 @@ package body Sem_Aggr is\n       if Present (Component_Associations (N))\n         and then Present (First (Component_Associations (N)))\n       then\n-\n          if Present (Expressions (N)) then\n             Check_SPARK_05_Restriction\n               (\"named association cannot follow positional one\",\n@@ -3678,8 +3880,9 @@ package body Sem_Aggr is\n       --  STEP 2: Verify aggregate structure\n \n       Step_2 : declare\n-         Selector_Name : Node_Id;\n+         Assoc         : Node_Id;\n          Bad_Aggregate : Boolean := False;\n+         Selector_Name : Node_Id;\n \n       begin\n          if Present (Component_Associations (N)) then\n@@ -3774,7 +3977,7 @@ package body Sem_Aggr is\n          --  First find the discriminant values in the positional components\n \n          while Present (Discrim) and then Present (Positional_Expr) loop\n-            if Discr_Present (Discrim) then\n+            if Discriminant_Present (Discrim) then\n                Resolve_Aggr_Expr (Positional_Expr, Discrim);\n \n                --  Ada 2005 (AI-231)\n@@ -3802,7 +4005,7 @@ package body Sem_Aggr is\n          while Present (Discrim) loop\n             Expr := Get_Value (Discrim, Component_Associations (N), True);\n \n-            if not Discr_Present (Discrim) then\n+            if not Discriminant_Present (Discrim) then\n                if Present (Expr) then\n                   Error_Msg_NE\n                     (\"more than one value supplied for discriminant &\",\n@@ -3850,17 +4053,17 @@ package body Sem_Aggr is\n                   and then Present (Underlying_Record_View (Typ)))\n       then\n          Build_Constrained_Itype : declare\n+            Constrs     : constant List_Id    := New_List;\n             Loc         : constant Source_Ptr := Sloc (N);\n+            Def_Id      : Entity_Id;\n             Indic       : Node_Id;\n+            New_Assoc   : Node_Id;\n             Subtyp_Decl : Node_Id;\n-            Def_Id      : Entity_Id;\n-\n-            C : constant List_Id := New_List;\n \n          begin\n             New_Assoc := First (New_Assoc_List);\n             while Present (New_Assoc) loop\n-               Append (Duplicate_Subexpr (Expression (New_Assoc)), To => C);\n+               Append_To (Constrs, Duplicate_Subexpr (Expression (New_Assoc)));\n                Next (New_Assoc);\n             end loop;\n \n@@ -3872,14 +4075,16 @@ package body Sem_Aggr is\n                    Subtype_Mark =>\n                      New_Occurrence_Of (Underlying_Record_View (Typ), Loc),\n                    Constraint   =>\n-                     Make_Index_Or_Discriminant_Constraint (Loc, C));\n+                     Make_Index_Or_Discriminant_Constraint (Loc,\n+                       Constraints => Constrs));\n             else\n                Indic :=\n                  Make_Subtype_Indication (Loc,\n                    Subtype_Mark =>\n                      New_Occurrence_Of (Base_Type (Typ), Loc),\n                    Constraint   =>\n-                     Make_Index_Or_Discriminant_Constraint (Loc, C));\n+                     Make_Index_Or_Discriminant_Constraint (Loc,\n+                       Constraints => Constrs));\n             end if;\n \n             Def_Id := Create_Itype (Ekind (Typ), N);\n@@ -3906,45 +4111,13 @@ package body Sem_Aggr is\n       --  STEP 5: Get remaining components according to discriminant values\n \n       Step_5 : declare\n+         Dnode           : Node_Id;\n+         Errors_Found    : Boolean := False;\n          Record_Def      : Node_Id;\n          Parent_Typ      : Entity_Id;\n-         Root_Typ        : Entity_Id;\n          Parent_Typ_List : Elist_Id;\n          Parent_Elmt     : Elmt_Id;\n-         Errors_Found    : Boolean := False;\n-         Dnode           : Node_Id;\n-\n-         function Find_Private_Ancestor return Entity_Id;\n-         --  AI05-0115: Find earlier ancestor in the derivation chain that is\n-         --  derived from a private view. Whether the aggregate is legal\n-         --  depends on the current visibility of the type as well as that\n-         --  of the parent of the ancestor.\n-\n-         ---------------------------\n-         -- Find_Private_Ancestor --\n-         ---------------------------\n-\n-         function Find_Private_Ancestor return Entity_Id is\n-            Par : Entity_Id;\n-\n-         begin\n-            Par := Typ;\n-            loop\n-               if Has_Private_Ancestor (Par)\n-                 and then not Has_Private_Ancestor (Etype (Base_Type (Par)))\n-               then\n-                  return Par;\n-\n-               elsif not Is_Derived_Type (Par) then\n-                  return Empty;\n-\n-               else\n-                  Par := Etype (Base_Type (Par));\n-               end if;\n-            end loop;\n-         end Find_Private_Ancestor;\n-\n-      --  Start of processing for Step_5\n+         Root_Typ        : Entity_Id;\n \n       begin\n          if Is_Derived_Type (Typ) and then Is_Tagged_Type (Typ) then\n@@ -3959,19 +4132,20 @@ package body Sem_Aggr is\n                Root_Typ := Base_Type (Etype (Ancestor_Part (N)));\n \n             else\n-               --  AI05-0115:  check legality of aggregate for type with\n-               --  aa private ancestor.\n+               --  AI05-0115: check legality of aggregate for type with a\n+               --  private ancestor.\n \n                Root_Typ := Root_Type (Typ);\n                if Has_Private_Ancestor (Typ) then\n                   declare\n                      Ancestor      : constant Entity_Id :=\n-                       Find_Private_Ancestor;\n+                                       Find_Private_Ancestor (Typ);\n                      Ancestor_Unit : constant Entity_Id :=\n-                       Cunit_Entity (Get_Source_Unit (Ancestor));\n+                                       Cunit_Entity\n+                                         (Get_Source_Unit (Ancestor));\n                      Parent_Unit   : constant Entity_Id :=\n-                       Cunit_Entity\n-                         (Get_Source_Unit (Base_Type (Etype (Ancestor))));\n+                                       Cunit_Entity (Get_Source_Unit\n+                                         (Base_Type (Etype (Ancestor))));\n                   begin\n                      --  Check whether we are in a scope that has full view\n                      --  over the private ancestor and its parent. This can\n@@ -4189,8 +4363,7 @@ package body Sem_Aggr is\n                --  object of the aggregate.\n \n                if Present (Parent (Component))\n-                 and then\n-                   Nkind (Parent (Component)) = N_Component_Declaration\n+                 and then Nkind (Parent (Component)) = N_Component_Declaration\n                  and then Present (Expression (Parent (Component)))\n                then\n                   Expr :=\n@@ -4213,26 +4386,18 @@ package body Sem_Aggr is\n                elsif Present (Underlying_Type (Ctyp))\n                  and then Is_Access_Type (Underlying_Type (Ctyp))\n                then\n-                  if not Is_Private_Type (Ctyp) then\n-                     Expr := Make_Null (Sloc (N));\n-                     Set_Etype (Expr, Ctyp);\n-                     Add_Association\n-                       (Component  => Component,\n-                        Expr       => Expr,\n-                        Assoc_List => New_Assoc_List);\n-\n                   --  If the component's type is private with an access type as\n                   --  its underlying type then we have to create an unchecked\n                   --  conversion to satisfy type checking.\n \n-                  else\n+                  if Is_Private_Type (Ctyp) then\n                      declare\n                         Qual_Null : constant Node_Id :=\n                                       Make_Qualified_Expression (Sloc (N),\n                                         Subtype_Mark =>\n                                           New_Occurrence_Of\n                                             (Underlying_Type (Ctyp), Sloc (N)),\n-                                        Expression => Make_Null (Sloc (N)));\n+                                        Expression   => Make_Null (Sloc (N)));\n \n                         Convert_Null : constant Node_Id :=\n                                          Unchecked_Convert_To\n@@ -4245,6 +4410,17 @@ package body Sem_Aggr is\n                            Expr       => Convert_Null,\n                            Assoc_List => New_Assoc_List);\n                      end;\n+\n+                  --  Otherwise the component type is non-private\n+\n+                  else\n+                     Expr := Make_Null (Sloc (N));\n+                     Set_Etype (Expr, Ctyp);\n+\n+                     Add_Association\n+                       (Component  => Component,\n+                        Expr       => Expr,\n+                        Assoc_List => New_Assoc_List);\n                   end if;\n \n                --  Ada 2012: If component is scalar with default value, use it\n@@ -4254,8 +4430,9 @@ package body Sem_Aggr is\n                then\n                   Add_Association\n                     (Component  => Component,\n-                     Expr       => Default_Aspect_Value\n-                                     (First_Subtype (Underlying_Type (Ctyp))),\n+                     Expr       =>\n+                       Default_Aspect_Value\n+                         (First_Subtype (Underlying_Type (Ctyp))),\n                      Assoc_List => New_Assoc_List);\n \n                elsif Has_Non_Null_Base_Init_Proc (Ctyp)\n@@ -4270,8 +4447,8 @@ package body Sem_Aggr is\n                      --  for the rest, if other components are present.\n \n                      --  The type of the aggregate is the known subtype of\n-                     --  the component. The capture of discriminants must\n-                     --  be recursive because subcomponents may be constrained\n+                     --  the component. The capture of discriminants must be\n+                     --  recursive because subcomponents may be constrained\n                      --  (transitively) by discriminants of enclosing types.\n                      --  For a private type with discriminants, a call to the\n                      --  initialization procedure will be generated, and no\n@@ -4281,206 +4458,6 @@ package body Sem_Aggr is\n                         Loc  : constant Source_Ptr := Sloc (N);\n                         Expr : Node_Id;\n \n-                        procedure Add_Discriminant_Values\n-                          (New_Aggr   : Node_Id;\n-                           Assoc_List : List_Id);\n-                        --  The constraint to a component may be given by a\n-                        --  discriminant of the enclosing type, in which case\n-                        --  we have to retrieve its value, which is part of the\n-                        --  enclosing aggregate. Assoc_List provides the\n-                        --  discriminant associations of the current type or\n-                        --  of some enclosing record.\n-\n-                        procedure Propagate_Discriminants\n-                          (Aggr       : Node_Id;\n-                           Assoc_List : List_Id);\n-                        --  Nested components may themselves be discriminated\n-                        --  types constrained by outer discriminants, whose\n-                        --  values must be captured before the aggregate is\n-                        --  expanded into assignments.\n-\n-                        -----------------------------\n-                        -- Add_Discriminant_Values --\n-                        -----------------------------\n-\n-                        procedure Add_Discriminant_Values\n-                          (New_Aggr   : Node_Id;\n-                           Assoc_List : List_Id)\n-                        is\n-                           Assoc      : Node_Id;\n-                           Discr      : Entity_Id;\n-                           Discr_Elmt : Elmt_Id;\n-                           Discr_Val  : Node_Id;\n-                           Val        : Entity_Id;\n-\n-                        begin\n-                           Discr := First_Discriminant (Etype (New_Aggr));\n-                           Discr_Elmt :=\n-                             First_Elmt\n-                               (Discriminant_Constraint (Etype (New_Aggr)));\n-                           while Present (Discr_Elmt) loop\n-                              Discr_Val := Node (Discr_Elmt);\n-\n-                              --  If the constraint is given by a discriminant\n-                              --  it is a discriminant of an enclosing record,\n-                              --  and its value has already been placed in the\n-                              --  association list.\n-\n-                              if Is_Entity_Name (Discr_Val)\n-                                and then\n-                                  Ekind (Entity (Discr_Val)) = E_Discriminant\n-                              then\n-                                 Val := Entity (Discr_Val);\n-\n-                                 Assoc := First (Assoc_List);\n-                                 while Present (Assoc) loop\n-                                    if Present\n-                                         (Entity (First (Choices (Assoc))))\n-                                      and then\n-                                        Entity (First (Choices (Assoc))) = Val\n-                                    then\n-                                       Discr_Val := Expression (Assoc);\n-                                       exit;\n-                                    end if;\n-\n-                                    Next (Assoc);\n-                                 end loop;\n-                              end if;\n-\n-                              Add_Association\n-                                (Discr, New_Copy_Tree (Discr_Val),\n-                                 Component_Associations (New_Aggr));\n-\n-                              --  If the discriminant constraint is a current\n-                              --  instance, mark the current aggregate so that\n-                              --  the self-reference can be expanded later.\n-                              --  The constraint may refer to the subtype of\n-                              --  aggregate, so use base type for comparison.\n-\n-                              if Nkind (Discr_Val) = N_Attribute_Reference\n-                                and then Is_Entity_Name (Prefix (Discr_Val))\n-                                and then Is_Type (Entity (Prefix (Discr_Val)))\n-                                and then Base_Type (Etype (N)) =\n-                                           Entity (Prefix (Discr_Val))\n-                              then\n-                                 Set_Has_Self_Reference (N);\n-                              end if;\n-\n-                              Next_Elmt (Discr_Elmt);\n-                              Next_Discriminant (Discr);\n-                           end loop;\n-                        end Add_Discriminant_Values;\n-\n-                        -----------------------------\n-                        -- Propagate_Discriminants --\n-                        -----------------------------\n-\n-                        procedure Propagate_Discriminants\n-                          (Aggr       : Node_Id;\n-                           Assoc_List : List_Id)\n-                        is\n-                           Aggr_Type : constant Entity_Id :=\n-                                         Base_Type (Etype (Aggr));\n-                           Def_Node  : constant Node_Id :=\n-                                         Type_Definition\n-                                           (Declaration_Node (Aggr_Type));\n-\n-                           Comp       : Node_Id;\n-                           Comp_Elmt  : Elmt_Id;\n-                           Components : constant Elist_Id := New_Elmt_List;\n-                           Needs_Box  : Boolean := False;\n-                           Errors     : Boolean;\n-\n-                           procedure Process_Component (Comp : Entity_Id);\n-                           --  Add one component with a box association to the\n-                           --  inner aggregate, and recurse if component is\n-                           --  itself composite.\n-\n-                           -----------------------\n-                           -- Process_Component --\n-                           -----------------------\n-\n-                           procedure Process_Component (Comp : Entity_Id) is\n-                              T        : constant Entity_Id := Etype (Comp);\n-                              New_Aggr : Node_Id;\n-\n-                           begin\n-                              if Is_Record_Type (T)\n-                                and then Has_Discriminants (T)\n-                              then\n-                                 New_Aggr :=\n-                                   Make_Aggregate (Loc, New_List, New_List);\n-                                 Set_Etype (New_Aggr, T);\n-                                 Add_Association\n-                                   (Comp, New_Aggr,\n-                                     Component_Associations (Aggr));\n-\n-                                 --  Collect discriminant values and recurse\n-\n-                                 Add_Discriminant_Values\n-                                   (New_Aggr, Assoc_List);\n-                                 Propagate_Discriminants\n-                                   (New_Aggr, Assoc_List);\n-\n-                              else\n-                                 Needs_Box := True;\n-                              end if;\n-                           end Process_Component;\n-\n-                        --  Start of processing for Propagate_Discriminants\n-\n-                        begin\n-                           --  The component type may be a variant type, so\n-                           --  collect the components that are ruled by the\n-                           --  known values of the discriminants. Their values\n-                           --  have already been inserted into the component\n-                           --  list of the current aggregate.\n-\n-                           if Nkind (Def_Node) = N_Record_Definition\n-                             and then Present (Component_List (Def_Node))\n-                             and then\n-                               Present\n-                                 (Variant_Part (Component_List (Def_Node)))\n-                           then\n-                              Gather_Components (Aggr_Type,\n-                                Component_List (Def_Node),\n-                                Governed_By   => Component_Associations (Aggr),\n-                                Into          => Components,\n-                                Report_Errors => Errors);\n-\n-                              Comp_Elmt := First_Elmt (Components);\n-                              while Present (Comp_Elmt) loop\n-                                 if Ekind (Node (Comp_Elmt)) /=\n-                                      E_Discriminant\n-                                 then\n-                                    Process_Component (Node (Comp_Elmt));\n-                                 end if;\n-\n-                                 Next_Elmt (Comp_Elmt);\n-                              end loop;\n-\n-                           --  No variant part, iterate over all components\n-\n-                           else\n-                              Comp := First_Component (Etype (Aggr));\n-                              while Present (Comp) loop\n-                                 Process_Component (Comp);\n-                                 Next_Component (Comp);\n-                              end loop;\n-                           end if;\n-\n-                           if Needs_Box then\n-                              Append_To (Component_Associations (Aggr),\n-                                Make_Component_Association (Loc,\n-                                  Choices     =>\n-                                    New_List (Make_Others_Choice (Loc)),\n-                                  Expression  => Empty,\n-                                  Box_Present => True));\n-                           end if;\n-                        end Propagate_Discriminants;\n-\n-                     --  Start of processing for Capture_Discriminants\n-\n                      begin\n                         Expr := Make_Aggregate (Loc, New_List, New_List);\n                         Set_Etype (Expr, Ctyp);\n@@ -4498,9 +4475,9 @@ package body Sem_Aggr is\n \n                         elsif Has_Discriminants (Ctyp) then\n                            Add_Discriminant_Values\n-                              (Expr, Component_Associations (Expr));\n+                             (Expr, Component_Associations (Expr));\n                            Propagate_Discriminants\n-                              (Expr, Component_Associations (Expr));\n+                             (Expr, Component_Associations (Expr));\n \n                         else\n                            declare\n@@ -4523,6 +4500,7 @@ package body Sem_Aggr is\n                                             Expression  => Empty,\n                                             Box_Present => True));\n                                     end if;\n+\n                                     exit;\n                                  end if;\n \n@@ -4537,6 +4515,9 @@ package body Sem_Aggr is\n                            Assoc_List => New_Assoc_List);\n                      end Capture_Discriminants;\n \n+                  --  Otherwise the component type is not a record, or it has\n+                  --  not discriminants, or it is private.\n+\n                   else\n                      Add_Association\n                        (Component      => Component,\n@@ -4576,6 +4557,9 @@ package body Sem_Aggr is\n       --  STEP 7: check for invalid components + check type in choice list\n \n       Step_7 : declare\n+         Assoc     : Node_Id;\n+         New_Assoc : Node_Id;\n+\n          Selectr : Node_Id;\n          --  Selector name\n \n@@ -4651,7 +4635,7 @@ package body Sem_Aggr is\n                               if Nkind (N) /= N_Extension_Aggregate\n                                 or else\n                                   Scope (Original_Record_Component (C)) /=\n-                                                     Etype (Ancestor_Part (N))\n+                                    Etype (Ancestor_Part (N))\n                               then\n                                  exit;\n                               end if;"}, {"sha": "07fa54da0db6ad1553fd84232e0e909be1575a51", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/937e96763e42c48c29e3a5edf2eea3fb2c59fb27/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/937e96763e42c48c29e3a5edf2eea3fb2c59fb27/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=937e96763e42c48c29e3a5edf2eea3fb2c59fb27", "patch": "@@ -4802,6 +4802,24 @@ package body Sem_Ch3 is\n       then\n          Set_Has_Predicates (Id);\n          Set_Has_Delayed_Freeze (Id);\n+\n+         --  Generated subtypes inherit the predicate function from the parent\n+         --  (no aspects to examine on the generated declaration).\n+\n+         if not Comes_From_Source (N) then\n+            Set_Ekind (Id, Ekind (T));\n+\n+            if Present (Predicate_Function (T)) then\n+               Set_Predicate_Function (Id, Predicate_Function (T));\n+\n+            elsif Present (Ancestor_Subtype (T))\n+              and then Has_Predicates (Ancestor_Subtype (T))\n+              and then Present (Predicate_Function (Ancestor_Subtype (T)))\n+            then\n+               Set_Predicate_Function (Id,\n+                 Predicate_Function (Ancestor_Subtype (T)));\n+            end if;\n+         end if;\n       end if;\n \n       --  Subtype of Boolean cannot have a constraint in SPARK"}, {"sha": "f35c9e25145bdd8e9b3bfab2b4253dea036a9bdb", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/937e96763e42c48c29e3a5edf2eea3fb2c59fb27/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/937e96763e42c48c29e3a5edf2eea3fb2c59fb27/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=937e96763e42c48c29e3a5edf2eea3fb2c59fb27", "patch": "@@ -9951,10 +9951,10 @@ package body Sem_Res is\n \n    begin\n       --  Ensure all actions associated with the left operand (e.g.\n-      --  finalization of transient controlled objects) are fully evaluated\n-      --  locally within an expression with actions. This is particularly\n-      --  helpful for coverage analysis. However this should not happen in\n-      --  generics or if Minimize_Expression_With_Actions is set.\n+      --  finalization of transient objects) are fully evaluated locally within\n+      --  an expression with actions. This is particularly helpful for coverage\n+      --  analysis. However this should not happen in generics or if option\n+      --  Minimize_Expression_With_Actions is set.\n \n       if Expander_Active and not Minimize_Expression_With_Actions then\n          declare"}]}