{"sha": "52843a4726629c92066668cf79979676560efce6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTI4NDNhNDcyNjYyOWM5MjA2NjY2OGNmNzk5Nzk2NzY1NjBlZmNlNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-11-11T18:14:35Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-11-11T18:14:35Z"}, "message": "re PR fortran/48636 (Enable more inlining with -O2 and higher)\n\n\n\tPR middle-end/48636\n\t* ipa-inline.c (want_inline_small_function_p): Take aray index hint.\n\t(edge_badness): Likewise.\n\t* ipa-inline.h (inline_hints_vals): Add array_index and comments.\n\t(inline_summary_: Add ARRAY_INDEX.\n\t* ipa-inline-analysis.c (dump_inline_hints): Dump array_index hint.\n\t(reset_inline_summary): Handle array_index hint.\n\t(inline_node_duplication_hook): Likewise.\n\t(dump_inline_summary): Likewise.\n\t(array_index_predicate): New function.\n\t(estimate_function_body_sizes): Use it.\n\t(estimate_node_size_and_time): Use array_index hint.\n\t(inline_merge_summary, inline_read_section): Likewise.\n\nFrom-SVN: r193406", "tree": {"sha": "5c72b6d621b40aab51257d773d939ff6d2be4567", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c72b6d621b40aab51257d773d939ff6d2be4567"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52843a4726629c92066668cf79979676560efce6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52843a4726629c92066668cf79979676560efce6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52843a4726629c92066668cf79979676560efce6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52843a4726629c92066668cf79979676560efce6/comments", "author": null, "committer": null, "parents": [{"sha": "6e7e4ca2e8a83335929695eca491c587ae1fcc56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e7e4ca2e8a83335929695eca491c587ae1fcc56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e7e4ca2e8a83335929695eca491c587ae1fcc56"}], "stats": {"total": 159, "additions": 141, "deletions": 18}, "files": [{"sha": "535c0ef8e7e960308231cff63dddd6918ab43b00", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52843a4726629c92066668cf79979676560efce6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52843a4726629c92066668cf79979676560efce6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=52843a4726629c92066668cf79979676560efce6", "patch": "@@ -1,3 +1,19 @@\n+2012-11-10  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR middle-end/48636\n+\t* ipa-inline.c (want_inline_small_function_p): Take aray index hint.\n+\t(edge_badness): Likewise.\n+\t* ipa-inline.h (inline_hints_vals): Add array_index and comments.\n+\t(inline_summary_: Add ARRAY_INDEX.\n+\t* ipa-inline-analysis.c (dump_inline_hints): Dump array_index hint.\n+\t(reset_inline_summary): Handle array_index hint.\n+\t(inline_node_duplication_hook): Likewise.\n+\t(dump_inline_summary): Likewise.\n+\t(array_index_predicate): New function.\n+\t(estimate_function_body_sizes): Use it.\n+\t(estimate_node_size_and_time): Use array_index hint.\n+\t(inline_merge_summary, inline_read_section): Likewise.\n+\n 2012-11-10  Sandra Loosemore  <sandra@codesourcery.com>\n \n \t* doc/extend.texi: Copy-edit to use \"bit-field\" consistently"}, {"sha": "f7b3af13cf6bfb08e82c487bcb49f4029f4ec2f4", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 101, "deletions": 15, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52843a4726629c92066668cf79979676560efce6/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52843a4726629c92066668cf79979676560efce6/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=52843a4726629c92066668cf79979676560efce6", "patch": "@@ -659,6 +659,11 @@ dump_inline_hints (FILE *f, inline_hints hints)\n       hints &= ~INLINE_HINT_declared_inline;\n       fprintf (f, \" declared_inline\");\n     }\n+  if (hints & INLINE_HINT_array_index)\n+    {\n+      hints &= ~INLINE_HINT_array_index;\n+      fprintf (f, \" array_index\");\n+    }\n   gcc_assert (!hints);\n }\n \n@@ -1007,6 +1012,11 @@ reset_inline_summary (struct cgraph_node *node)\n       pool_free (edge_predicate_pool, info->loop_stride);\n       info->loop_stride = NULL;\n     }\n+  if (info->array_index)\n+    {\n+      pool_free (edge_predicate_pool, info->array_index);\n+      info->array_index = NULL;\n+    }\n   VEC_free (condition, gc, info->conds);\n   VEC_free (size_time_entry,gc, info->entry);\n   for (e = node->callees; e; e = e->next_callee)\n@@ -1201,6 +1211,9 @@ inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n       remap_hint_predicate_after_duplication (&info->loop_stride,\n \t\t\t\t\t      possible_truths,\n \t\t\t\t\t      info);\n+      remap_hint_predicate_after_duplication (&info->array_index,\n+\t\t\t\t\t      possible_truths,\n+\t\t\t\t\t      info);\n \n       /* If inliner or someone after inliner will ever start producing\n \t non-trivial clones, we will get trouble with lack of information\n@@ -1224,6 +1237,12 @@ inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \t  info->loop_stride = NULL;\n \t  set_hint_predicate (&info->loop_stride, p);\n \t}\n+      if (info->array_index)\n+\t{\n+\t  predicate p = *info->array_index;\n+\t  info->array_index = NULL;\n+\t  set_hint_predicate (&info->array_index, p);\n+\t}\n     }\n   inline_update_overall_summary (dst);\n }\n@@ -1413,6 +1432,11 @@ dump_inline_summary (FILE * f, struct cgraph_node *node)\n \t  fprintf (f, \"  loop stride:\");\n \t  dump_predicate (f, s->conds, s->loop_stride);\n \t}\n+      if (s->array_index)\n+\t{\n+\t  fprintf (f, \"  array index:\");\n+\t  dump_predicate (f, s->conds, s->array_index);\n+\t}\n       fprintf (f, \"  calls:\\n\");\n       dump_inline_edge_summary (f, 4, node, s);\n       fprintf (f, \"\\n\");\n@@ -2262,6 +2286,28 @@ predicate_for_phi_result (struct inline_summary *summary, gimple phi,\n \t       SSA_NAME_VERSION (gimple_phi_result (phi)), *p);\n }\n \n+/* Return predicate specifying when array index in access OP becomes non-constant.  */\n+\n+static struct predicate\n+array_index_predicate (struct inline_summary *info,\n+\t\t       VEC (predicate_t, heap) *nonconstant_names, tree op)\n+{\n+  struct predicate p = false_predicate ();\n+  while (handled_component_p (op))\n+    {\n+      if (TREE_CODE (op) == ARRAY_REF\n+\t  || TREE_CODE (op) == ARRAY_RANGE_REF)\n+        {\n+\t  if (TREE_CODE (TREE_OPERAND (op, 1)) == SSA_NAME)\n+\t     p = or_predicates (info->conds, &p,\n+\t\t\t\t&VEC_index (predicate_t, nonconstant_names,\n+                                            SSA_NAME_VERSION (TREE_OPERAND (op, 1))));\n+        }\n+      op = TREE_OPERAND (op, 0);\n+    }\n+  return p;\n+}\n+\n /* Compute function body size parameters for NODE.\n    When EARLY is true, we compute only simple summaries without\n    non-trivial predicates to drive the early inliner.  */\n@@ -2284,6 +2330,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n   VEC (predicate_t, heap) *nonconstant_names = NULL;\n   int nblocks, n;\n   int *order;\n+  predicate array_index = true_predicate ();\n \n   info->conds = 0;\n   info->entry = 0;\n@@ -2380,6 +2427,24 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t\t       ((double)freq)/CGRAPH_FREQ_BASE, this_size, this_time);\n \t    }\n \n+\t  if (gimple_assign_load_p (stmt) && nonconstant_names)\n+\t    {\n+\t      struct predicate this_array_index;\n+\t      this_array_index = array_index_predicate (info, nonconstant_names,\n+\t\t\t\t\t\t        gimple_assign_rhs1 (stmt));\n+\t      if (!false_predicate_p (&this_array_index))\n+\t        array_index = and_predicates (info->conds, &array_index, &this_array_index);\n+\t    }\n+\t  if (gimple_store_p (stmt) && nonconstant_names)\n+\t    {\n+\t      struct predicate this_array_index;\n+\t      this_array_index = array_index_predicate (info, nonconstant_names,\n+\t\t\t\t\t\t        gimple_get_lhs (stmt));\n+\t      if (!false_predicate_p (&this_array_index))\n+\t        array_index = and_predicates (info->conds, &array_index, &this_array_index);\n+\t    }\n+\t   \n+\n \t  if (is_gimple_call (stmt))\n \t    {\n \t      struct cgraph_edge *edge = cgraph_edge (node, stmt);\n@@ -2476,21 +2541,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t    }\n \t}\n     }\n-  FOR_ALL_BB_FN (bb, my_function)\n-    {\n-      edge e;\n-      edge_iterator ei;\n-\n-      if (bb->aux)\n-\tpool_free (edge_predicate_pool, bb->aux);\n-      bb->aux = NULL;\n-      FOR_EACH_EDGE (e, ei, bb->succs)\n-\t{\n-\t  if (e->aux)\n-\t    pool_free (edge_predicate_pool, e->aux);\n-\t  e->aux = NULL;\n-\t}\n-    }\n+  set_hint_predicate (&inline_summary (node)->array_index, array_index);\n   time = (time + CGRAPH_FREQ_BASE / 2) / CGRAPH_FREQ_BASE;\n   if (time > MAX_TIME)\n     time = MAX_TIME;\n@@ -2513,6 +2564,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t  unsigned int j, i;\n \t  struct tree_niter_desc niter_desc;\n \t  basic_block *body = get_loop_body (loop);\n+\t  bb_predicate = *(struct predicate *)loop->header->aux;\n \n \t  exits = get_loop_exit_edges (loop);\n           FOR_EACH_VEC_ELT (edge, exits, j, ex)\n@@ -2522,6 +2574,10 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t\tpredicate will_be_nonconstant\n \t\t = will_be_nonconstant_expr_predicate (parms_info, info,\n \t\t\t\t\t\t       niter_desc.niter, nonconstant_names);\n+\t        if (!true_predicate_p (&will_be_nonconstant))\n+\t\t  will_be_nonconstant = and_predicates (info->conds,\n+\t\t\t\t\t\t\t&bb_predicate,\n+\t\t\t\t\t\t\t&will_be_nonconstant);\n \t\tif (!true_predicate_p (&will_be_nonconstant)\n \t\t    && !false_predicate_p (&will_be_nonconstant))\n \t\t  /* This is slightly inprecise.  We may want to represent each loop with\n@@ -2533,6 +2589,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n           for (i = 0; i < loop->num_nodes; i++)\n \t    {\n \t      gimple_stmt_iterator gsi;\n+\t      bb_predicate = *(struct predicate *)body[i]->aux;\n \t      for (gsi = gsi_start_bb (body[i]); !gsi_end_p (gsi); gsi_next (&gsi))\n \t\t{\n \t\t  gimple stmt = gsi_stmt (gsi);\n@@ -2550,6 +2607,10 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t\t      will_be_nonconstant\n \t\t       = will_be_nonconstant_expr_predicate (parms_info, info,\n \t\t\t\t\t\t\t     iv.step, nonconstant_names);\n+\t\t      if (!true_predicate_p (&will_be_nonconstant))\n+\t\t\twill_be_nonconstant = and_predicates (info->conds,\n+\t\t\t\t\t\t\t      &bb_predicate,\n+\t\t\t\t\t\t\t      &will_be_nonconstant);\n \t\t      if (!true_predicate_p (&will_be_nonconstant)\n \t\t\t  && !false_predicate_p (&will_be_nonconstant))\n \t\t\t/* This is slightly inprecise.  We may want to represent each loop with\n@@ -2564,6 +2625,21 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n       set_hint_predicate (&inline_summary (node)->loop_stride, loop_stride);\n       scev_finalize ();\n     }\n+  FOR_ALL_BB_FN (bb, my_function)\n+    {\n+      edge e;\n+      edge_iterator ei;\n+\n+      if (bb->aux)\n+\tpool_free (edge_predicate_pool, bb->aux);\n+      bb->aux = NULL;\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t{\n+\t  if (e->aux)\n+\t    pool_free (edge_predicate_pool, e->aux);\n+\t  e->aux = NULL;\n+\t}\n+    }\n   inline_summary (node)->self_time = time;\n   inline_summary (node)->self_size = size;\n   VEC_free (predicate_t, heap, nonconstant_names);\n@@ -2881,6 +2957,9 @@ estimate_node_size_and_time (struct cgraph_node *node,\n   if (info->loop_stride\n       && !evaluate_predicate (info->loop_stride, possible_truths))\n     hints |=INLINE_HINT_loop_stride;\n+  if (info->array_index\n+      && !evaluate_predicate (info->array_index, possible_truths))\n+    hints |=INLINE_HINT_array_index;\n   if (info->scc_no)\n     hints |= INLINE_HINT_in_scc;\n   if (DECL_DECLARED_INLINE_P (node->symbol.decl))\n@@ -3311,6 +3390,10 @@ inline_merge_summary (struct cgraph_edge *edge)\n \t\t\t&callee_info->loop_stride,\n \t\t\toperand_map, offset_map,\n \t\t\tclause, &toplev_predicate);\n+  remap_hint_predicate (info, callee_info,\n+\t\t\t&callee_info->array_index,\n+\t\t\toperand_map, offset_map,\n+\t\t\tclause, &toplev_predicate);\n \n   inline_update_callee_summaries (edge->callee,\n \t\t\t\t  inline_edge_summary (edge)->loop_depth);\n@@ -3803,6 +3886,8 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n       set_hint_predicate (&info->loop_iterations, p);\n       p = read_predicate (&ib);\n       set_hint_predicate (&info->loop_stride, p);\n+      p = read_predicate (&ib);\n+      set_hint_predicate (&info->array_index, p);\n       for (e = node->callees; e; e = e->next_callee)\n \tread_inline_edge_summary (&ib, e);\n       for (e = node->indirect_calls; e; e = e->next_callee)\n@@ -3954,6 +4039,7 @@ inline_write_summary (void)\n \t    }\n \t  write_predicate (ob, info->loop_iterations);\n \t  write_predicate (ob, info->loop_stride);\n+\t  write_predicate (ob, info->array_index);\n \t  for (edge = node->callees; edge; edge = edge->next_callee)\n \t    write_inline_edge_summary (ob, edge);\n \t  for (edge = node->indirect_calls; edge; edge = edge->next_callee)"}, {"sha": "9f792ff7aa913129868ef3ead52a2e2602e31105", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52843a4726629c92066668cf79979676560efce6/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52843a4726629c92066668cf79979676560efce6/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=52843a4726629c92066668cf79979676560efce6", "patch": "@@ -541,6 +541,7 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t       && !big_speedup\n \t       && !(hints & (INLINE_HINT_indirect_call\n \t\t\t     | INLINE_HINT_loop_iterations\n+\t\t\t     | INLINE_HINT_array_index\n \t\t\t     | INLINE_HINT_loop_stride)))\n \t{\n           e->inline_failed = CIF_MAX_INLINE_INSNS_SINGLE_LIMIT;\n@@ -595,6 +596,7 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t       && !big_speedup\n \t       && growth >= ((hints & (INLINE_HINT_indirect_call\n \t\t\t\t       | INLINE_HINT_loop_iterations\n+\t\t\t               | INLINE_HINT_array_index\n \t\t\t\t       | INLINE_HINT_loop_stride))\n \t\t\t     ? MAX (MAX_INLINE_INSNS_AUTO,\n \t\t\t\t    MAX_INLINE_INSNS_SINGLE)\n@@ -919,6 +921,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n       gcc_checking_assert (badness <=0 && badness >= INT_MIN / 16);\n       if ((hints & (INLINE_HINT_indirect_call\n \t\t    | INLINE_HINT_loop_iterations\n+\t            | INLINE_HINT_array_index\n \t\t    | INLINE_HINT_loop_stride))\n \t  || callee_info->growth <= 0)\n \tbadness *= 8;"}, {"sha": "1e9658c3b96186aefcc220c4ec23904956591a23", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52843a4726629c92066668cf79979676560efce6/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52843a4726629c92066668cf79979676560efce6/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=52843a4726629c92066668cf79979676560efce6", "patch": "@@ -44,16 +44,32 @@ typedef struct GTY(()) condition\n     unsigned by_ref : 1;\n   } condition;\n \n-/* Inline hints are reasons why inline heuristics should preffer inlining given function.\n-   They are represtented as bitmap of the following values.  */\n+/* Inline hints are reasons why inline heuristics should preffer inlining given\n+   function.  They are represtented as bitmap of the following values.  */\n enum inline_hints_vals {\n+  /* When inlining turns indirect call into a direct call,\n+     it is good idea to do so.  */\n   INLINE_HINT_indirect_call = 1,\n+  /* Inlining may make loop iterations or loop stride known.  It is good idea\n+     to do so because it enables loop optimizatoins.  */\n   INLINE_HINT_loop_iterations = 2,\n   INLINE_HINT_loop_stride = 4,\n+  /* Inlining withing same strongly connected component of callgraph is often\n+     a loss due to increased stack frame usage and prologue setup costs.  */\n   INLINE_HINT_same_scc = 8,\n+  /* Inlining functions in strongly connected component is not such a great\n+     win.  */\n   INLINE_HINT_in_scc = 16,\n+  /* If function is declared inline by user, it may be good idea to inline\n+     it.  */\n   INLINE_HINT_declared_inline = 32,\n-  INLINE_HINT_cross_module = 64\n+  /* Programs are usually still organized for non-LTO compilation and thus\n+     if functions are in different modules, inlining may not be so important. \n+   */\n+  INLINE_HINT_cross_module = 64,\n+  /* If array indexes of loads/stores become known there may be room for\n+     futher optimization.  */\n+  INLINE_HINT_array_index = 128\n };\n typedef int inline_hints;\n \n@@ -133,6 +149,8 @@ struct GTY(()) inline_summary\n   /* Predicate on when some loop in the function becomes to have known\n      stride.   */\n   struct predicate * GTY((skip)) loop_stride;\n+  /* Predicate on when some array indexes become constants.  */\n+  struct predicate * GTY((skip)) array_index;\n   /* Estimated growth for inlining all copies of the function before start\n      of small functions inlining.\n      This value will get out of date as the callers are duplicated, but"}]}