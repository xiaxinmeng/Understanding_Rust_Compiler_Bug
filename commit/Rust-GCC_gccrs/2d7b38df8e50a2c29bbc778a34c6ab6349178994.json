{"sha": "2d7b38df8e50a2c29bbc778a34c6ab6349178994", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQ3YjM4ZGY4ZTUwYTJjMjliYmM3NzhhMzRjNmFiNjM0OTE3ODk5NA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-20T12:53:44Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-20T12:53:44Z"}, "message": "poly_int: store_bit_field bitrange\n\nThis patch changes the bitnum and bitsize arguments to\nstore_bit_field from unsigned HOST_WIDE_INTs to poly_uint64s.\nThe later part of store_bit_field_1 still needs to operate\non constant bit positions and sizes, so the patch splits\nit out into a subfunction (store_integral_bit_field).\n\n2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* expmed.h (store_bit_field): Take bitsize and bitnum as\n\tpoly_uint64s rather than unsigned HOST_WIDE_INTs.\n\t* expmed.c (simple_mem_bitfield_p): Likewise.  Add a parameter\n\tthat returns the byte size.\n\t(store_bit_field_1): Take bitsize and bitnum as\n\tpoly_uint64s rather than unsigned HOST_WIDE_INTs.  Update call\n\tto simple_mem_bitfield_p.  Split the part that can only handle\n\tconstant bitsize and bitnum out into...\n\t(store_integral_bit_field): ...this new function.\n\t(store_bit_field): Take bitsize and bitnum as poly_uint64s rather\n\tthan unsigned HOST_WIDE_INTs.\n\t(extract_bit_field_1): Update call to simple_mem_bitfield_p.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255877", "tree": {"sha": "9434a81dbc47de40990db4b2e1ba787ae865df97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9434a81dbc47de40990db4b2e1ba787ae865df97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d7b38df8e50a2c29bbc778a34c6ab6349178994", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d7b38df8e50a2c29bbc778a34c6ab6349178994", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d7b38df8e50a2c29bbc778a34c6ab6349178994", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d7b38df8e50a2c29bbc778a34c6ab6349178994/comments", "author": null, "committer": null, "parents": [{"sha": "73ca989cb823c3857336ada13446bc5c04cec3eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73ca989cb823c3857336ada13446bc5c04cec3eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73ca989cb823c3857336ada13446bc5c04cec3eb"}], "stats": {"total": 159, "additions": 108, "deletions": 51}, "files": [{"sha": "fe99aabdfe96f28ac3f64bebb36c5b7a577b161d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d7b38df8e50a2c29bbc778a34c6ab6349178994/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d7b38df8e50a2c29bbc778a34c6ab6349178994/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2d7b38df8e50a2c29bbc778a34c6ab6349178994", "patch": "@@ -1,3 +1,20 @@\n+2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* expmed.h (store_bit_field): Take bitsize and bitnum as\n+\tpoly_uint64s rather than unsigned HOST_WIDE_INTs.\n+\t* expmed.c (simple_mem_bitfield_p): Likewise.  Add a parameter\n+\tthat returns the byte size.\n+\t(store_bit_field_1): Take bitsize and bitnum as\n+\tpoly_uint64s rather than unsigned HOST_WIDE_INTs.  Update call\n+\tto simple_mem_bitfield_p.  Split the part that can only handle\n+\tconstant bitsize and bitnum out into...\n+\t(store_integral_bit_field): ...this new function.\n+\t(store_bit_field): Take bitsize and bitnum as poly_uint64s rather\n+\tthan unsigned HOST_WIDE_INTs.\n+\t(extract_bit_field_1): Update call to simple_mem_bitfield_p.\n+\n 2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "9a92c940e57de028202598ac1ec4f41dbc796b8d", "filename": "gcc/expmed.c", "status": "modified", "additions": 90, "deletions": 49, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d7b38df8e50a2c29bbc778a34c6ab6349178994/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d7b38df8e50a2c29bbc778a34c6ab6349178994/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=2d7b38df8e50a2c29bbc778a34c6ab6349178994", "patch": "@@ -47,6 +47,12 @@ struct target_expmed default_target_expmed;\n struct target_expmed *this_target_expmed = &default_target_expmed;\n #endif\n \n+static bool store_integral_bit_field (rtx, opt_scalar_int_mode,\n+\t\t\t\t      unsigned HOST_WIDE_INT,\n+\t\t\t\t      unsigned HOST_WIDE_INT,\n+\t\t\t\t      unsigned HOST_WIDE_INT,\n+\t\t\t\t      unsigned HOST_WIDE_INT,\n+\t\t\t\t      machine_mode, rtx, bool, bool);\n static void store_fixed_bit_field (rtx, opt_scalar_int_mode,\n \t\t\t\t   unsigned HOST_WIDE_INT,\n \t\t\t\t   unsigned HOST_WIDE_INT,\n@@ -564,17 +570,18 @@ strict_volatile_bitfield_p (rtx op0, unsigned HOST_WIDE_INT bitsize,\n }\n \n /* Return true if OP is a memory and if a bitfield of size BITSIZE at\n-   bit number BITNUM can be treated as a simple value of mode MODE.  */\n+   bit number BITNUM can be treated as a simple value of mode MODE.\n+   Store the byte offset in *BYTENUM if so.  */\n \n static bool\n-simple_mem_bitfield_p (rtx op0, unsigned HOST_WIDE_INT bitsize,\n-\t\t       unsigned HOST_WIDE_INT bitnum, machine_mode mode)\n+simple_mem_bitfield_p (rtx op0, poly_uint64 bitsize, poly_uint64 bitnum,\n+\t\t       machine_mode mode, poly_uint64 *bytenum)\n {\n   return (MEM_P (op0)\n-\t  && bitnum % BITS_PER_UNIT == 0\n-\t  && bitsize == GET_MODE_BITSIZE (mode)\n+\t  && multiple_p (bitnum, BITS_PER_UNIT, bytenum)\n+\t  && known_eq (bitsize, GET_MODE_BITSIZE (mode))\n \t  && (!targetm.slow_unaligned_access (mode, MEM_ALIGN (op0))\n-\t      || (bitnum % GET_MODE_ALIGNMENT (mode) == 0\n+\t      || (multiple_p (bitnum, GET_MODE_ALIGNMENT (mode))\n \t\t  && MEM_ALIGN (op0) >= GET_MODE_ALIGNMENT (mode))));\n }\n \f\n@@ -719,15 +726,13 @@ store_bit_field_using_insv (const extraction_insn *insv, rtx op0,\n    return false instead.  */\n \n static bool\n-store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n-\t\t   unsigned HOST_WIDE_INT bitnum,\n+store_bit_field_1 (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,\n \t\t   unsigned HOST_WIDE_INT bitregion_start,\n \t\t   unsigned HOST_WIDE_INT bitregion_end,\n \t\t   machine_mode fieldmode,\n \t\t   rtx value, bool reverse, bool fallback_p)\n {\n   rtx op0 = str_rtx;\n-  rtx orig_value;\n \n   while (GET_CODE (op0) == SUBREG)\n     {\n@@ -738,23 +743,23 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n   /* No action is needed if the target is a register and if the field\n      lies completely outside that register.  This can occur if the source\n      code contains an out-of-bounds access to a small array.  */\n-  if (REG_P (op0) && bitnum >= GET_MODE_BITSIZE (GET_MODE (op0)))\n+  if (REG_P (op0) && known_ge (bitnum, GET_MODE_BITSIZE (GET_MODE (op0))))\n     return true;\n \n   /* Use vec_set patterns for inserting parts of vectors whenever\n      available.  */\n   machine_mode outermode = GET_MODE (op0);\n   scalar_mode innermode = GET_MODE_INNER (outermode);\n+  poly_uint64 pos;\n   if (VECTOR_MODE_P (outermode)\n       && !MEM_P (op0)\n       && optab_handler (vec_set_optab, outermode) != CODE_FOR_nothing\n       && fieldmode == innermode\n-      && bitsize == GET_MODE_BITSIZE (innermode)\n-      && !(bitnum % GET_MODE_BITSIZE (innermode)))\n+      && known_eq (bitsize, GET_MODE_BITSIZE (innermode))\n+      && multiple_p (bitnum, GET_MODE_BITSIZE (innermode), &pos))\n     {\n       struct expand_operand ops[3];\n       enum insn_code icode = optab_handler (vec_set_optab, outermode);\n-      int pos = bitnum / GET_MODE_BITSIZE (innermode);\n \n       create_fixed_operand (&ops[0], op0);\n       create_input_operand (&ops[1], value, innermode);\n@@ -766,16 +771,16 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n   /* If the target is a register, overwriting the entire object, or storing\n      a full-word or multi-word field can be done with just a SUBREG.  */\n   if (!MEM_P (op0)\n-      && bitsize == GET_MODE_BITSIZE (fieldmode)\n-      && ((bitsize == GET_MODE_BITSIZE (GET_MODE (op0)) && bitnum == 0)\n-\t  || (bitsize % BITS_PER_WORD == 0 && bitnum % BITS_PER_WORD == 0)))\n+      && known_eq (bitsize, GET_MODE_BITSIZE (fieldmode)))\n     {\n       /* Use the subreg machinery either to narrow OP0 to the required\n \t words or to cope with mode punning between equal-sized modes.\n \t In the latter case, use subreg on the rhs side, not lhs.  */\n       rtx sub;\n-\n-      if (bitsize == GET_MODE_BITSIZE (GET_MODE (op0)))\n+      HOST_WIDE_INT regnum;\n+      HOST_WIDE_INT regsize = REGMODE_NATURAL_SIZE (GET_MODE (op0));\n+      if (known_eq (bitnum, 0U)\n+\t  && known_eq (bitsize, GET_MODE_BITSIZE (GET_MODE (op0))))\n \t{\n \t  sub = simplify_gen_subreg (GET_MODE (op0), value, fieldmode, 0);\n \t  if (sub)\n@@ -786,10 +791,11 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t      return true;\n \t    }\n \t}\n-      else\n+      else if (constant_multiple_p (bitnum, regsize * BITS_PER_UNIT, &regnum)\n+\t       && multiple_p (bitsize, regsize * BITS_PER_UNIT))\n \t{\n \t  sub = simplify_gen_subreg (fieldmode, op0, GET_MODE (op0),\n-\t\t\t\t     bitnum / BITS_PER_UNIT);\n+\t\t\t\t     regnum * regsize);\n \t  if (sub)\n \t    {\n \t      if (reverse)\n@@ -803,15 +809,23 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n   /* If the target is memory, storing any naturally aligned field can be\n      done with a simple store.  For targets that support fast unaligned\n      memory, any naturally sized, unit aligned field can be done directly.  */\n-  if (simple_mem_bitfield_p (op0, bitsize, bitnum, fieldmode))\n+  poly_uint64 bytenum;\n+  if (simple_mem_bitfield_p (op0, bitsize, bitnum, fieldmode, &bytenum))\n     {\n-      op0 = adjust_bitfield_address (op0, fieldmode, bitnum / BITS_PER_UNIT);\n+      op0 = adjust_bitfield_address (op0, fieldmode, bytenum);\n       if (reverse)\n \tvalue = flip_storage_order (fieldmode, value);\n       emit_move_insn (op0, value);\n       return true;\n     }\n \n+  /* It's possible we'll need to handle other cases here for\n+     polynomial bitnum and bitsize.  */\n+\n+  /* From here on we need to be looking at a fixed-size insertion.  */\n+  unsigned HOST_WIDE_INT ibitsize = bitsize.to_constant ();\n+  unsigned HOST_WIDE_INT ibitnum = bitnum.to_constant ();\n+\n   /* Make sure we are playing with integral modes.  Pun with subregs\n      if we aren't.  This must come after the entire register case above,\n      since that case is valid for any mode.  The following cases are only\n@@ -827,12 +841,31 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \top0 = gen_lowpart (op0_mode.require (), op0);\n     }\n \n+  return store_integral_bit_field (op0, op0_mode, ibitsize, ibitnum,\n+\t\t\t\t   bitregion_start, bitregion_end,\n+\t\t\t\t   fieldmode, value, reverse, fallback_p);\n+}\n+\n+/* Subroutine of store_bit_field_1, with the same arguments, except\n+   that BITSIZE and BITNUM are constant.  Handle cases specific to\n+   integral modes.  If OP0_MODE is defined, it is the mode of OP0,\n+   otherwise OP0 is a BLKmode MEM.  */\n+\n+static bool\n+store_integral_bit_field (rtx op0, opt_scalar_int_mode op0_mode,\n+\t\t\t  unsigned HOST_WIDE_INT bitsize,\n+\t\t\t  unsigned HOST_WIDE_INT bitnum,\n+\t\t\t  unsigned HOST_WIDE_INT bitregion_start,\n+\t\t\t  unsigned HOST_WIDE_INT bitregion_end,\n+\t\t\t  machine_mode fieldmode,\n+\t\t\t  rtx value, bool reverse, bool fallback_p)\n+{\n   /* Storing an lsb-aligned field in a register\n      can be done with a movstrict instruction.  */\n \n   if (!MEM_P (op0)\n       && !reverse\n-      && lowpart_bit_field_p (bitnum, bitsize, GET_MODE (op0))\n+      && lowpart_bit_field_p (bitnum, bitsize, op0_mode.require ())\n       && bitsize == GET_MODE_BITSIZE (fieldmode)\n       && optab_handler (movstrict_optab, fieldmode) != CODE_FOR_nothing)\n     {\n@@ -884,26 +917,29 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t subwords to extract.  Note that fieldmode will often (always?) be\n \t VOIDmode, because that is what store_field uses to indicate that this\n \t is a bit field, but passing VOIDmode to operand_subword_force\n-\t is not allowed.  */\n-      fieldmode = GET_MODE (value);\n-      if (fieldmode == VOIDmode)\n-\tfieldmode = smallest_int_mode_for_size (nwords * BITS_PER_WORD);\n+\t is not allowed.\n+\n+\t The mode must be fixed-size, since insertions into variable-sized\n+\t objects are meant to be handled before calling this function.  */\n+      fixed_size_mode value_mode = as_a <fixed_size_mode> (GET_MODE (value));\n+      if (value_mode == VOIDmode)\n+\tvalue_mode = smallest_int_mode_for_size (nwords * BITS_PER_WORD);\n \n       last = get_last_insn ();\n       for (i = 0; i < nwords; i++)\n \t{\n \t  /* If I is 0, use the low-order word in both field and target;\n \t     if I is 1, use the next to lowest word; and so on.  */\n \t  unsigned int wordnum = (backwards\n-\t\t\t\t  ? GET_MODE_SIZE (fieldmode) / UNITS_PER_WORD\n+\t\t\t\t  ? GET_MODE_SIZE (value_mode) / UNITS_PER_WORD\n \t\t\t\t  - i - 1\n \t\t\t\t  : i);\n \t  unsigned int bit_offset = (backwards ^ reverse\n \t\t\t\t     ? MAX ((int) bitsize - ((int) i + 1)\n \t\t\t\t\t    * BITS_PER_WORD,\n \t\t\t\t\t    0)\n \t\t\t\t     : (int) i * BITS_PER_WORD);\n-\t  rtx value_word = operand_subword_force (value, wordnum, fieldmode);\n+\t  rtx value_word = operand_subword_force (value, wordnum, value_mode);\n \t  unsigned HOST_WIDE_INT new_bitsize =\n \t    MIN (BITS_PER_WORD, bitsize - i * BITS_PER_WORD);\n \n@@ -937,7 +973,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n      integer of the corresponding size.  This can occur on a machine\n      with 64 bit registers that uses SFmode for float.  It can also\n      occur for unaligned float or complex fields.  */\n-  orig_value = value;\n+  rtx orig_value = value;\n   scalar_int_mode value_mode;\n   if (GET_MODE (value) == VOIDmode)\n     /* By this point we've dealt with values that are bigger than a word,\n@@ -1045,41 +1081,43 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n    If REVERSE is true, the store is to be done in reverse order.  */\n \n void\n-store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n-\t\t unsigned HOST_WIDE_INT bitnum,\n+store_bit_field (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,\n \t\t unsigned HOST_WIDE_INT bitregion_start,\n \t\t unsigned HOST_WIDE_INT bitregion_end,\n \t\t machine_mode fieldmode,\n \t\t rtx value, bool reverse)\n {\n   /* Handle -fstrict-volatile-bitfields in the cases where it applies.  */\n+  unsigned HOST_WIDE_INT ibitsize = 0, ibitnum = 0;\n   scalar_int_mode int_mode;\n-  if (is_a <scalar_int_mode> (fieldmode, &int_mode)\n-      && strict_volatile_bitfield_p (str_rtx, bitsize, bitnum, int_mode,\n+  if (bitsize.is_constant (&ibitsize)\n+      && bitnum.is_constant (&ibitnum)\n+      && is_a <scalar_int_mode> (fieldmode, &int_mode)\n+      && strict_volatile_bitfield_p (str_rtx, ibitsize, ibitnum, int_mode,\n \t\t\t\t     bitregion_start, bitregion_end))\n     {\n       /* Storing of a full word can be done with a simple store.\n \t We know here that the field can be accessed with one single\n \t instruction.  For targets that support unaligned memory,\n \t an unaligned access may be necessary.  */\n-      if (bitsize == GET_MODE_BITSIZE (int_mode))\n+      if (ibitsize == GET_MODE_BITSIZE (int_mode))\n \t{\n \t  str_rtx = adjust_bitfield_address (str_rtx, int_mode,\n-\t\t\t\t\t     bitnum / BITS_PER_UNIT);\n+\t\t\t\t\t     ibitnum / BITS_PER_UNIT);\n \t  if (reverse)\n \t    value = flip_storage_order (int_mode, value);\n-\t  gcc_assert (bitnum % BITS_PER_UNIT == 0);\n+\t  gcc_assert (ibitnum % BITS_PER_UNIT == 0);\n \t  emit_move_insn (str_rtx, value);\n \t}\n       else\n \t{\n \t  rtx temp;\n \n-\t  str_rtx = narrow_bit_field_mem (str_rtx, int_mode, bitsize, bitnum,\n-\t\t\t\t\t  &bitnum);\n-\t  gcc_assert (bitnum + bitsize <= GET_MODE_BITSIZE (int_mode));\n+\t  str_rtx = narrow_bit_field_mem (str_rtx, int_mode, ibitsize,\n+\t\t\t\t\t  ibitnum, &ibitnum);\n+\t  gcc_assert (ibitnum + ibitsize <= GET_MODE_BITSIZE (int_mode));\n \t  temp = copy_to_reg (str_rtx);\n-\t  if (!store_bit_field_1 (temp, bitsize, bitnum, 0, 0,\n+\t  if (!store_bit_field_1 (temp, ibitsize, ibitnum, 0, 0,\n \t\t\t\t  int_mode, value, reverse, true))\n \t    gcc_unreachable ();\n \n@@ -1096,19 +1134,21 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n     {\n       scalar_int_mode best_mode;\n       machine_mode addr_mode = VOIDmode;\n-      HOST_WIDE_INT offset, size;\n+      HOST_WIDE_INT offset;\n \n       gcc_assert ((bitregion_start % BITS_PER_UNIT) == 0);\n \n       offset = bitregion_start / BITS_PER_UNIT;\n       bitnum -= bitregion_start;\n-      size = (bitnum + bitsize + BITS_PER_UNIT - 1) / BITS_PER_UNIT;\n+      poly_int64 size = bits_to_bytes_round_up (bitnum + bitsize);\n       bitregion_end -= bitregion_start;\n       bitregion_start = 0;\n-      if (get_best_mode (bitsize, bitnum,\n-\t\t\t bitregion_start, bitregion_end,\n-\t\t\t MEM_ALIGN (str_rtx), INT_MAX,\n-\t\t\t MEM_VOLATILE_P (str_rtx), &best_mode))\n+      if (bitsize.is_constant (&ibitsize)\n+\t  && bitnum.is_constant (&ibitnum)\n+\t  && get_best_mode (ibitsize, ibitnum,\n+\t\t\t    bitregion_start, bitregion_end,\n+\t\t\t    MEM_ALIGN (str_rtx), INT_MAX,\n+\t\t\t    MEM_VOLATILE_P (str_rtx), &best_mode))\n \taddr_mode = best_mode;\n       str_rtx = adjust_bitfield_address_size (str_rtx, addr_mode,\n \t\t\t\t\t      offset, size);\n@@ -1740,9 +1780,10 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n   /* Extraction of a full MODE1 value can be done with a load as long as\n      the field is on a byte boundary and is sufficiently aligned.  */\n-  if (simple_mem_bitfield_p (op0, bitsize, bitnum, mode1))\n+  poly_uint64 bytenum;\n+  if (simple_mem_bitfield_p (op0, bitsize, bitnum, mode1, &bytenum))\n     {\n-      op0 = adjust_bitfield_address (op0, mode1, bitnum / BITS_PER_UNIT);\n+      op0 = adjust_bitfield_address (op0, mode1, bytenum);\n       if (reverse)\n \top0 = flip_storage_order (mode1, op0);\n       return convert_extracted_bit_field (op0, mode, tmode, unsignedp);"}, {"sha": "2148e1b65a6fbc89e12972b59a1eb63146273f84", "filename": "gcc/expmed.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d7b38df8e50a2c29bbc778a34c6ab6349178994/gcc%2Fexpmed.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d7b38df8e50a2c29bbc778a34c6ab6349178994/gcc%2Fexpmed.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.h?ref=2d7b38df8e50a2c29bbc778a34c6ab6349178994", "patch": "@@ -718,8 +718,7 @@ extern rtx expand_divmod (int, enum tree_code, machine_mode, rtx, rtx,\n \t\t\t  rtx, int);\n #endif\n \n-extern void store_bit_field (rtx, unsigned HOST_WIDE_INT,\n-\t\t\t     unsigned HOST_WIDE_INT,\n+extern void store_bit_field (rtx, poly_uint64, poly_uint64,\n \t\t\t     unsigned HOST_WIDE_INT,\n \t\t\t     unsigned HOST_WIDE_INT,\n \t\t\t     machine_mode, rtx, bool);"}]}