{"sha": "124092ee8afddc68ec7905bd951cc647f7de84e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTI0MDkyZWU4YWZkZGM2OGVjNzkwNWJkOTUxY2M2NDdmN2RlODRlNg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-14T12:42:04Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-14T12:42:04Z"}, "message": "[multiple changes]\n\n2013-10-14  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* einfo.adb: Flag263 is now known as Has_Null_Refinement.\n\t(Has_Null_Refinement): New routine.\n\t(Set_Has_Null_Refinement): New routine.\n\t(Write_Entity_Flags): Output the status of flag\n\tHas_Null_Refinement.\n\t* einfo.ads: Add new flag Has_Null_Refinement along with\n\tcomment on usage and update all nodes subject to the flag.\n\t(Has_Null_Refinement): New routine along with pragma Inline.\n\t(Set_Has_Null_Refinement): New rouitine along with pragma Inline.\n\t* sem_prag.adb (Analyze_Constituent): Mark a state as having\n\ta null refinement when the sole constituent is \"null\".\n\t(Analyze_Global_List): Handle null input/output items.\n\t(Analyze_Refined_Global_In_Decl_Part): Add local variable\n\tHas_Null_State. Add logic to handle combinations of states\n\twith null refinements and null global lists and/or items.\n\t(Check_In_Out_States, Check_Input_States, Check_Output_States):\n\tUse attribute Has_Null_Refinement to detect states with\n\tconstituents.\n\t(Check_Refined_Global_List): Handle null input/output items.\n\t(Process_Global_Item): Handle states with null refinements.\n\t(Process_Global_List): Handle null input/output items.\n\n2013-10-14  Robert Dewar  <dewar@adacore.com>\n\n\t* freeze.adb (Freeze_Entity): Reset Is_True_Constant for\n\taliased object\n\t* gnat_ugn.texi: Update doc on aliased variables and constants.\n\n2013-10-14  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_pakd.adb (Expand_Packed_Element_Reference): If the\n\treference is an actual in a call, the prefix has not been fully\n\texpanded, to account for the additional expansion for parameter\n\tpassing. the prefix itself is a packed reference as well,\n\trecurse to complete the transformation of the prefix.\n\n2013-10-14  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* exp_dbug.adb (Debug_Renaming_Declaration): Do not\n\tmaterialize the entity when the renamed object contains an\n\tN_Explicit_Dereference.\n\t* sem_ch8.adb (Analyze_Object_Renaming):\n\tIf the renaming comes from source and the renamed object is a\n\tdereference, mark the prefix as needing debug information.\n\n2013-10-14  Doug Rupp  <rupp@adacore.com>\n\n\t* system-vxworks-arm.ads (Stack_Check_Probes, Stack_Check_Limits):\n\tEnable Stack Probes, Disable Stack Limit Checking.\n\t* init.c [VxWorks] (__gnat_inum_to_ivec): Caste return value.\n\t(__gnat_map_signal): Fix signature.\n\t(__gnat_error_handler): Make\n\tstatic, fix signature, remove prototype, fix prototype warning.\n\t[ARMEL and VxWorks6] (__gnat_map_signal): Check and re-arm guard\n\tpage for storage_error.\n\t* exp_pakd.adb: Minor reformatting.\n\nFrom-SVN: r203526", "tree": {"sha": "63af518b9244da060ec1650330653be5fc5a02cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63af518b9244da060ec1650330653be5fc5a02cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/124092ee8afddc68ec7905bd951cc647f7de84e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/124092ee8afddc68ec7905bd951cc647f7de84e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/124092ee8afddc68ec7905bd951cc647f7de84e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/124092ee8afddc68ec7905bd951cc647f7de84e6/comments", "author": null, "committer": null, "parents": [{"sha": "b447a7578e82b2d2bbe284fa3044f0070a2d8c12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b447a7578e82b2d2bbe284fa3044f0070a2d8c12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b447a7578e82b2d2bbe284fa3044f0070a2d8c12"}], "stats": {"total": 495, "additions": 370, "deletions": 125}, "files": [{"sha": "af254c97de90907035eeae9247b8a31dc4ce1d47", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/124092ee8afddc68ec7905bd951cc647f7de84e6/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/124092ee8afddc68ec7905bd951cc647f7de84e6/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=124092ee8afddc68ec7905bd951cc647f7de84e6", "patch": "@@ -1,3 +1,62 @@\n+2013-10-14  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* einfo.adb: Flag263 is now known as Has_Null_Refinement.\n+\t(Has_Null_Refinement): New routine.\n+\t(Set_Has_Null_Refinement): New routine.\n+\t(Write_Entity_Flags): Output the status of flag\n+\tHas_Null_Refinement.\n+\t* einfo.ads: Add new flag Has_Null_Refinement along with\n+\tcomment on usage and update all nodes subject to the flag.\n+\t(Has_Null_Refinement): New routine along with pragma Inline.\n+\t(Set_Has_Null_Refinement): New rouitine along with pragma Inline.\n+\t* sem_prag.adb (Analyze_Constituent): Mark a state as having\n+\ta null refinement when the sole constituent is \"null\".\n+\t(Analyze_Global_List): Handle null input/output items.\n+\t(Analyze_Refined_Global_In_Decl_Part): Add local variable\n+\tHas_Null_State. Add logic to handle combinations of states\n+\twith null refinements and null global lists and/or items.\n+\t(Check_In_Out_States, Check_Input_States, Check_Output_States):\n+\tUse attribute Has_Null_Refinement to detect states with\n+\tconstituents.\n+\t(Check_Refined_Global_List): Handle null input/output items.\n+\t(Process_Global_Item): Handle states with null refinements.\n+\t(Process_Global_List): Handle null input/output items.\n+\n+2013-10-14  Robert Dewar  <dewar@adacore.com>\n+\n+\t* freeze.adb (Freeze_Entity): Reset Is_True_Constant for\n+\taliased object\n+\t* gnat_ugn.texi: Update doc on aliased variables and constants.\n+\n+2013-10-14  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_pakd.adb (Expand_Packed_Element_Reference): If the\n+\treference is an actual in a call, the prefix has not been fully\n+\texpanded, to account for the additional expansion for parameter\n+\tpassing. the prefix itself is a packed reference as well,\n+\trecurse to complete the transformation of the prefix.\n+\n+2013-10-14  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_dbug.adb (Debug_Renaming_Declaration): Do not\n+\tmaterialize the entity when the renamed object contains an\n+\tN_Explicit_Dereference.\n+\t* sem_ch8.adb (Analyze_Object_Renaming):\n+\tIf the renaming comes from source and the renamed object is a\n+\tdereference, mark the prefix as needing debug information.\n+\n+2013-10-14  Doug Rupp  <rupp@adacore.com>\n+\n+\t* system-vxworks-arm.ads (Stack_Check_Probes, Stack_Check_Limits):\n+\tEnable Stack Probes, Disable Stack Limit Checking.\n+\t* init.c [VxWorks] (__gnat_inum_to_ivec): Caste return value.\n+\t(__gnat_map_signal): Fix signature.\n+\t(__gnat_error_handler): Make\n+\tstatic, fix signature, remove prototype, fix prototype warning.\n+\t[ARMEL and VxWorks6] (__gnat_map_signal): Check and re-arm guard\n+\tpage for storage_error.\n+\t* exp_pakd.adb: Minor reformatting.\n+\n 2013-10-14  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_prag.adb (Analyze_Global_In_Decl_Part): Remove local"}, {"sha": "a78452dd93eab2e9e8e6131b07543700ff5da552", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/124092ee8afddc68ec7905bd951cc647f7de84e6/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/124092ee8afddc68ec7905bd951cc647f7de84e6/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=124092ee8afddc68ec7905bd951cc647f7de84e6", "patch": "@@ -551,8 +551,8 @@ package body Einfo is\n \n    --    Has_Delayed_Rep_Aspects         Flag261\n    --    May_Inherit_Delayed_Rep_Aspects Flag262\n+   --    Has_Null_Refinement             Flag263\n \n-   --    (unused)                        Flag263\n    --    (unused)                        Flag264\n    --    (unused)                        Flag265\n    --    (unused)                        Flag266\n@@ -1483,6 +1483,12 @@ package body Einfo is\n       return Flag75 (Implementation_Base_Type (Id));\n    end Has_Non_Standard_Rep;\n \n+   function Has_Null_Refinement (Id : E) return B is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Abstract_State);\n+      return Flag263 (Id);\n+   end Has_Null_Refinement;\n+\n    function Has_Object_Size_Clause (Id : E) return B is\n    begin\n       pragma Assert (Is_Type (Id));\n@@ -4104,6 +4110,12 @@ package body Einfo is\n       Set_Flag75 (Id, V);\n    end Set_Has_Non_Standard_Rep;\n \n+   procedure Set_Has_Null_Refinement (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Abstract_State);\n+      Set_Flag263 (Id, V);\n+   end Set_Has_Null_Refinement;\n+\n    procedure Set_Has_Object_Size_Clause (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Type (Id));\n@@ -7957,6 +7969,7 @@ package body Einfo is\n       W (\"Has_Missing_Return\",              Flag142 (Id));\n       W (\"Has_Nested_Block_With_Handler\",   Flag101 (Id));\n       W (\"Has_Non_Standard_Rep\",            Flag75  (Id));\n+      W (\"Has_Null_Refinement\",             Flag263 (Id));\n       W (\"Has_Object_Size_Clause\",          Flag172 (Id));\n       W (\"Has_Per_Object_Constraint\",       Flag154 (Id));\n       W (\"Has_Postconditions\",              Flag240 (Id));"}, {"sha": "1f69fef0229524e7865529a7fa3dce4887db7eba", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 86, "deletions": 77, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/124092ee8afddc68ec7905bd951cc647f7de84e6/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/124092ee8afddc68ec7905bd951cc647f7de84e6/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=124092ee8afddc68ec7905bd951cc647f7de84e6", "patch": "@@ -505,10 +505,10 @@ package Einfo is\n \n --    Can_Never_Be_Null (Flag38)\n --       This flag is defined in all entities, but can only be set in an object\n---       which can never have a null value. This is set True for constant\n---       access values initialized to a non-null value. This is also True for\n---       all access parameters in Ada 83 and Ada 95 modes, and for access\n---       parameters that explicitly exclude null in Ada 2005.\n+--       which can never have a null value. Set for constant access values\n+--       initialized to a non-null value. This is also set for all access\n+--       parameters in Ada 83 and Ada 95 modes, and for access parameters\n+--       that explicitly exclude null in Ada 2005.\n --\n --       This is used to avoid unnecessary resetting of the Is_Known_Non_Null\n --       flag for such entities. In Ada 2005 mode, this is also used when\n@@ -651,7 +651,7 @@ package Einfo is\n --    Corresponding_Concurrent_Type (Node18)\n --       Defined in record types that are constructed by the expander to\n --       represent task and protected types (Is_Concurrent_Record_Type flag\n---       set True). Points to the entity for the corresponding task type or\n+--       set). Points to the entity for the corresponding task type or the\n --       protected type.\n \n --    Corresponding_Discriminant (Node19)\n@@ -1361,14 +1361,14 @@ package Einfo is\n --       of derived type declarations).\n \n --    Has_All_Calls_Remote (Flag79)\n---       Defined in all library unit entities. Set true if the library unit\n---       has an All_Calls_Remote pragma. Note that such entities must also\n---       be RCI entities, so the flag Is_Remote_Call_Interface will always\n---       be set if this flag is set.\n+--       Defined in all library unit entities. Set if the library unit has an\n+--       All_Calls_Remote pragma. Note that such entities must also be RCI\n+--       entities, so the flag Is_Remote_Call_Interface will always be set if\n+--       this flag is set.\n \n --    Has_Anonymous_Master (Flag253)\n --       Defined in units (top-level functions and procedures, library-level\n---       packages). Set to True if the associated unit contains a heterogeneous\n+--       packages). Set if the associated unit contains a heterogeneous\n --       finalization master. The master's name is of the form <unit>AM and it\n --       services anonymous access-to-controlled types with an undetermined\n --       lifetime.\n@@ -1438,11 +1438,11 @@ package Einfo is\n --       in sem_aux is used to test for this case.\n \n --    Has_Contiguous_Rep (Flag181)\n---       Defined in enumeration types. True if the type as a representation\n+--       Defined in enumeration types. Set if the type as a representation\n --       clause whose entries are successive integers.\n \n --    Has_Controlling_Result (Flag98)\n---       Defined in E_Function entities. True if the function is a primitive\n+--       Defined in E_Function entities. Set if the function is a primitive\n --       function of a tagged type which can dispatch on result.\n \n --    Has_Controlled_Component (Flag43) [base type only]\n@@ -1452,13 +1452,13 @@ package Einfo is\n --       Has_Controlled_Component is set for at least one component).\n \n --    Has_Convention_Pragma (Flag119)\n---       Defined in all entities. Set true for an entity for which a valid\n---       Convention, Import, or Export pragma has been given. Used to prevent\n---       more than one such pragma appearing for a given entity (RM B.1(45)).\n+--       Defined in all entities. Set for an entity for which a valid pragma\n+--       Convention, Import, or Export has been given. Used to prevent more\n+--       than one such pragma appearing for a given entity (RM B.1(45)).\n \n --    Has_Delayed_Aspects (Flag200)\n---      Defined in all entities. Set true if the Rep_Item chain for the entity\n---      has one or more N_Aspect_Definition nodes chained which are not to be\n+--      Defined in all entities. Set if the Rep_Item chain for the entity has\n+--      one or more N_Aspect_Definition nodes chained which are not to be\n --      evaluated till the freeze point. The aspect definition expression\n --      clause has been preanalyzed to get visibility at the point of use,\n --      but no other action has been taken.\n@@ -1531,18 +1531,18 @@ package Einfo is\n --       Convention_Intrinsic, Convention_Entry or Convention_Protected).\n \n --    Has_Forward_Instantiation (Flag175)\n---       Defined in package entities. Set true for packages that contain\n---       instantiations of local generic entities, before the corresponding\n---       generic body has been seen. If a package has a forward instantiation,\n---       we cannot inline subprograms appearing in the same package because\n---       the placement requirements of the instance will conflict with the\n---       linear elaboration of front-end inlining.\n+--       Defined in package entities. Set for packages that instantiate local\n+--       generic entities before the corresponding generic body has been seen.\n+--       If a package has a forward instantiation, we cannot inline subprograms\n+--       appearing in the same package because the placement requirements of\n+--       the instance will conflict with the  linear elaboration of front-end\n+--       inlining.\n \n --    Has_Fully_Qualified_Name (Flag173)\n---       Defined in all entities. Set True if the name in the Chars field has\n---       been replaced by the fully qualified name, as used for debug output.\n---       See Exp_Dbug for a full description of the use of this flag and also\n---       the related flag Has_Qualified_Name.\n+--       Defined in all entities. Set if the name in the Chars field has been\n+--       replaced by the fully qualified name, as used for debug output. See\n+--       Exp_Dbug for a full description of the use of this flag and also the\n+--       related flag Has_Qualified_Name.\n \n --    Has_Gigi_Rep_Item (Flag82)\n --       Defined in all entities. Set if the rep item chain (referenced by\n@@ -1576,7 +1576,7 @@ package Einfo is\n --       applies (as set by coresponding pragma or aspect specification).\n \n --    Has_Inheritable_Invariants (Flag248)\n---       Defined in all type entities. Set True in private types from which one\n+--       Defined in all type entities. Set in private types from which one\n --       or more Invariant'Class aspects will be inherited if a another type is\n --       derived from the type (i.e. those types which have an Invariant'Class\n --       aspect, or which inherit one or more Invariant'Class aspects). Also\n@@ -1599,7 +1599,7 @@ package Einfo is\n --       Interrupt_Handler applies.\n \n --    Has_Invariants (Flag232)\n---       Defined in all type entities and in subprogram entities. Set True in\n+--       Defined in all type entities and in subprogram entities. Set in\n --       private types if an Invariant or Invariant'Class aspect applies to the\n --       type, or if the type inherits one or more Invariant'Class aspects.\n --       Also set in the corresponding full type. Note: if this flag is set\n@@ -1650,15 +1650,19 @@ package Einfo is\n --       Defined in package entities. True if the package is subject to a null\n --       Abstract_State aspect/pragma.\n \n+--    Has_Null_Refinement (Flag263)\n+--       Defined in E_Abstract_State entities. Set if the state has a null\n+--       refinement in aspect/pragma Refined_State.\n+\n --    Has_Object_Size_Clause (Flag172)\n --       Defined in entities for types and subtypes. Set if an Object_Size\n --       clause has been processed for the type Used to prevent multiple\n --       Object_Size clauses for a given entity.\n \n --    Has_Per_Object_Constraint (Flag154)\n---       Defined in E_Component entities, true if the subtype of the\n---       component has a per object constraint. Per object constraints result\n---       from the following situations:\n+--       Defined in E_Component entities. Set if the subtype of the component\n+--       has a per object constraint. Per object constraints result from the\n+--       following situations :\n --\n --       1. N_Attribute_Reference - when the prefix is the enclosing type and\n --          the attribute is Access.\n@@ -1770,27 +1774,27 @@ package Einfo is\n --       some ancestor is derived from a private type, making some components\n --       invisible and aggregates illegal. Used to check the legality of\n --       selected components and aggregates. The flag is set at the point of\n---       derivation.\n---       The legality of an aggregate of a type with a private ancestor  must\n---       be checked because it also depends on the visibility at the point the\n---       aggregate is resolved. See sem_aggr.adb. This is part of AI05-0115.\n+--       derivation. The legality of an aggregate of a type with a private\n+--       ancestor must be checked because it also depends on the visibility\n+--       at the point the aggregate is resolved. See sem_aggr.adb. This is\n+--       part of AI05-0115.\n \n --    Has_Private_Declaration (Flag155)\n---       Defined in all entities. Returns True if it is the defining entity\n---       of a private type declaration or its corresponding full declaration.\n---       This flag is thus preserved when the full and the partial views are\n---       exchanged, to indicate if a full type declaration is a completion.\n---       Used for semantic checks in E.4(18) and elsewhere.\n+--       Defined in all entities. Set if it is the defining entity of a private\n+--       type declaration or its corresponding full declaration. This flag is\n+--       thus preserved when the full and the partial views are exchanged, to\n+--       indicate if a full type declaration is a completion. Used for semantic\n+--       checks in E.4(18) and elsewhere.\n \n --    Has_Qualified_Name (Flag161)\n---       Defined in all entities. Set True if the name in the Chars field\n---       has been replaced by its qualified name, as used for debug output.\n---       See Exp_Dbug for a full description of qualification requirements.\n---       For some entities, the name is the fully qualified name, but there\n---       are exceptions. In particular, for local variables in procedures,\n---       we do not include the procedure itself or higher scopes. See also\n---       the flag Has_Fully_Qualified_Name, which is set if the name does\n---       indeed include the fully qualified name.\n+--       Defined in all entities. Set if the name in the Chars field has\n+--       been replaced by its qualified name, as used for debug output. See\n+--       Exp_Dbug for a full description of qualification requirements. For\n+--       some entities, the name is the fully qualified name, but there are\n+--       exceptions. In particular, for local variables in procedures, we\n+--       do not include the procedure itself or higher scopes. See also the\n+--       flag Has_Fully_Qualified_Name, which is set if the name does indeed\n+--       include the fully qualified name.\n \n --    Has_RACW (Flag214)\n --       Defined in package spec entities. Set if the spec contains the\n@@ -2168,7 +2172,7 @@ package Einfo is\n --       Set if the type or subtype is constrained.\n \n --    Is_Constr_Subt_For_U_Nominal (Flag80)\n---       Defined in all types and subtypes. Set true only for the constructed\n+--       Defined in all types and subtypes. Set only for the constructed\n --       subtype of an object whose nominal subtype is unconstrained. Note\n --       that the constructed subtype itself will be constrained.\n \n@@ -2225,9 +2229,9 @@ package Einfo is\n --       entity is associated with a dispatch table.\n \n --    Is_Dispatching_Operation (Flag6)\n---       Defined in all entities. Set true for procedures, functions,\n---       generic procedures and generic functions if the corresponding\n---       operation is dispatching.\n+--       Defined in all entities. Set for procedures, functions, generic\n+--       procedures, and generic functions if the corresponding operation\n+--       is dispatching.\n \n --    Is_Dynamic_Scope (synthesized)\n --       Applies to all Entities. Returns True if the entity is a dynamic\n@@ -2253,9 +2257,9 @@ package Einfo is\n --       entities and False for all other entity kinds.\n \n --    Is_Entry_Formal (Flag52)\n---       Defined in all entities. Set only for entry formals (which can\n---       only be in, in-out or out parameters). This flag is used to speed\n---       up the test for the need to replace references in Exp_Ch2.\n+--       Defined in all entities. Set only for entry formals (which can only\n+--       be in, in-out or out parameters). This flag is used to speed up the\n+--       test for the need to replace references in Exp_Ch2.\n \n --    Is_Exported (Flag99)\n --       Defined in all entities. Set if the entity is exported. For now we\n@@ -2338,7 +2342,7 @@ package Einfo is\n --       convention.\n \n --    Is_Hidden (Flag57)\n---       Defined in all entities. Set true for all entities declared in the\n+--       Defined in all entities. Set for all entities declared in the\n --       private part or body of a package. Also marks generic formals of a\n --       formal package declared without a box. For library level entities,\n --       this flag is set if the entity is not publicly visible. This flag\n@@ -2348,7 +2352,7 @@ package Einfo is\n --       Private_Declaration in sem_ch7).\n \n --    Is_Hidden_Open_Scope (Flag171)\n---       Defined in all entities. Set true for a scope that contains the\n+--       Defined in all entities. Set for a scope that contains the\n --       instantiation of a child unit, and whose entities are not visible\n --       during analysis of the instance.\n \n@@ -2462,28 +2466,28 @@ package Einfo is\n --       to be defined) must be in the same scope as the type.\n \n --    Is_Known_Non_Null (Flag37)\n---       Defined in all entities. Relevant (and can be set True) only for\n+--       Defined in all entities. Relevant (and can be set) only for\n --       objects of an access type. It is set if the object is currently\n --       known to have a non-null value (meaning that no access checks\n --       are needed). The indication can for example come from assignment\n --       of an access parameter or an allocator whose value is known non-null.\n --\n --       Note: this flag is set according to the sequential flow of the\n---       program, watching the current value of the variable. However,\n---       this processing can miss cases of changing the value of an aliased\n---       or constant object, so even if this flag is set, it should not\n---       be believed if the variable is aliased or volatile. It would\n---       be a little neater to avoid the flag being set in the first\n---       place in such cases, but that's trickier, and there is only\n---       one place that tests the value anyway.\n+--       program, watching the current value of the variable. However, this\n+--       processing can miss cases of changing the value of an aliased or\n+--       constant object, so even if this flag is set, it should not be\n+--       believed if the variable is aliased or volatile. It would be a\n+--       little neater to avoid the flag being set in the first place in\n+--       such cases, but that's trickier, and there is only one place that\n+--       tests the value anyway.\n --\n --       The flag is dynamically set and reset as semantic analysis and\n --       expansion proceeds. Its value is meaningless once the tree is\n --       fully constructed, since it simply indicates the last state.\n --       Thus this flag has no meaning to the back end.\n \n --    Is_Known_Null (Flag204)\n---       Defined in all entities. Relevant (and can be set True) only for\n+--       Defined in all entities. Relevant (and can be set ) only for\n --       objects of an access type. It is set if the object is currently known\n --       to have a null value (meaning that a dereference will surely raise\n --       constraint error exception). The indication can come from an\n@@ -2841,7 +2845,7 @@ package Einfo is\n --       Wide_Wide_Character).\n \n --    Is_Statically_Allocated (Flag28)\n---       Defined in all entities. This can only be set True for exception,\n+--       Defined in all entities. This can only be set for exception,\n --       variable, constant, and type/subtype entities. If the flag is set,\n --       then the variable or constant must be allocated statically rather\n --       than on the local stack frame. For exceptions, the meaning is that\n@@ -2951,7 +2955,7 @@ package Einfo is\n --       or Export_Valued_Procedure pragma applies to the procedure entity.\n \n --    Is_Visible_Formal (Flag206)\n---       Defined in all entities. Set True for instances of the formals of a\n+--       Defined in all entities. Set for instances of the formals of a\n --       formal package. Indicates that the entity must be made visible in the\n --       body of the instance, to reproduce the visibility of the generic.\n --       This simplifies visibility settings in instance bodies.\n@@ -3058,10 +3062,10 @@ package Einfo is\n --       Value attributes for the enumeration type in question.\n \n --    Low_Bound_Tested (Flag205)\n---       Defined in all entities. Currently this can only be set True for\n---       formal parameter entries of a standard unconstrained one-dimensional\n---       array or string type. Indicates that an explicit test of the low bound\n---       of the formal appeared in the code, e.g. in a pragma Assert. If this\n+--       Defined in all entities. Currently this can only be set for formal\n+--       parameter entries of a standard unconstrained one-dimensional array\n+--       or string type. Indicates that an explicit test of the low bound of\n+--       the formal appeared in the code, e.g. in a pragma Assert. If this\n --       flag is set, warnings about assuming the index low bound to be one\n --       are suppressed.\n \n@@ -3252,8 +3256,8 @@ package Einfo is\n --       the defining entity in the original declaration.\n \n --    Nonzero_Is_True (Flag162) [base type only]\n---       Defined in enumeration types. True if any non-zero value is to be\n---       interpreted as true. Currently this is set true for derived Boolean\n+--       Defined in enumeration types. Set if any non-zero value is to be\n+--       interpreted as true. Currently this is set for derived Boolean\n --       types which have a convention of C, C++ or Fortran.\n \n --    No_Pool_Assigned (Flag131) [root type only]\n@@ -3796,8 +3800,8 @@ package Einfo is\n \n --    Static_Predicate (List25)\n --       Defined in discrete types/subtypes with predicates (Has_Predicates\n---       set True). Set if the type/subtype has a static predicate. Points to\n---       a list of expression and N_Range nodes that represent the predicate\n+--       set). Set if the type/subtype has a static predicate. Points to a\n+--       list of expression and N_Range nodes that represent the predicate\n --       in canonical form. The canonical form has entries sorted in ascending\n --       order, with duplicates eliminated, and adjacent ranges coalesced, so\n --       that there is always a gap in the values between successive entries.\n@@ -5104,6 +5108,7 @@ package Einfo is\n    --  E_Abstract_State\n    --    Refinement_Constituents             (Elist8)\n    --    Refined_State                       (Node10)\n+   --    Has_Null_Refinement                 (Flag263)\n    --    Is_External_State                   (synth)\n    --    Is_Input_Only_State                 (synth)\n    --    Is_Null_State                       (synth)\n@@ -6344,6 +6349,7 @@ package Einfo is\n    function Has_Missing_Return                  (Id : E) return B;\n    function Has_Nested_Block_With_Handler       (Id : E) return B;\n    function Has_Non_Standard_Rep                (Id : E) return B;\n+   function Has_Null_Refinement                 (Id : E) return B;\n    function Has_Object_Size_Clause              (Id : E) return B;\n    function Has_Per_Object_Constraint           (Id : E) return B;\n    function Has_Postconditions                  (Id : E) return B;\n@@ -6957,6 +6963,7 @@ package Einfo is\n    procedure Set_Has_Missing_Return              (Id : E; V : B := True);\n    procedure Set_Has_Nested_Block_With_Handler   (Id : E; V : B := True);\n    procedure Set_Has_Non_Standard_Rep            (Id : E; V : B := True);\n+   procedure Set_Has_Null_Refinement             (Id : E; V : B := True);\n    procedure Set_Has_Object_Size_Clause          (Id : E; V : B := True);\n    procedure Set_Has_Per_Object_Constraint       (Id : E; V : B := True);\n    procedure Set_Has_Postconditions              (Id : E; V : B := True);\n@@ -7672,6 +7679,7 @@ package Einfo is\n    pragma Inline (Has_Missing_Return);\n    pragma Inline (Has_Nested_Block_With_Handler);\n    pragma Inline (Has_Non_Standard_Rep);\n+   pragma Inline (Has_Null_Refinement);\n    pragma Inline (Has_Object_Size_Clause);\n    pragma Inline (Has_Per_Object_Constraint);\n    pragma Inline (Has_Postconditions);\n@@ -8132,6 +8140,7 @@ package Einfo is\n    pragma Inline (Set_Has_Missing_Return);\n    pragma Inline (Set_Has_Nested_Block_With_Handler);\n    pragma Inline (Set_Has_Non_Standard_Rep);\n+   pragma Inline (Set_Has_Null_Refinement);\n    pragma Inline (Set_Has_Object_Size_Clause);\n    pragma Inline (Set_Has_Per_Object_Constraint);\n    pragma Inline (Set_Has_Postconditions);"}, {"sha": "7dd72069acad880b7623a620a63ff022941e2060", "filename": "gcc/ada/exp_dbug.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/124092ee8afddc68ec7905bd951cc647f7de84e6/gcc%2Fada%2Fexp_dbug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/124092ee8afddc68ec7905bd951cc647f7de84e6/gcc%2Fada%2Fexp_dbug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dbug.adb?ref=124092ee8afddc68ec7905bd951cc647f7de84e6", "patch": "@@ -411,7 +411,6 @@ package body Exp_Dbug is\n                Ren := Prefix (Ren);\n \n             when N_Explicit_Dereference =>\n-               Set_Materialize_Entity (Ent);\n                Prepend_String_To_Buffer (\"XA\");\n                Ren := Prefix (Ren);\n "}, {"sha": "a6a1f0dc70b77e85d75ae0874acd021607e8e440", "filename": "gcc/ada/exp_pakd.adb", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/124092ee8afddc68ec7905bd951cc647f7de84e6/gcc%2Fada%2Fexp_pakd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/124092ee8afddc68ec7905bd951cc647f7de84e6/gcc%2Fada%2Fexp_pakd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.adb?ref=124092ee8afddc68ec7905bd951cc647f7de84e6", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1992,6 +1992,19 @@ package body Exp_Pakd is\n       Arg   : Node_Id;\n \n    begin\n+      --  If the node is an actual in a call, the prefix has not been fully\n+      --  expanded, to account for the additional expansion for in-out actuals\n+      --  (see expand_actuals for details). If the prefix itself is a packed\n+      --  reference as well, we have to recurse to complete the transformation\n+      --  of the prefix.\n+\n+      if Nkind (Prefix (N)) = N_Indexed_Component\n+        and then not Analyzed (Prefix (N))\n+        and then Is_Bit_Packed_Array (Etype (Prefix (Prefix (N))))\n+      then\n+         Expand_Packed_Element_Reference (Prefix (N));\n+      end if;\n+\n       --  If not bit packed, we have the enumeration case, which is easily\n       --  dealt with (just adjust the subscripts of the indexed component)\n "}, {"sha": "b810a18e321b68214c040c14eeadec952a444b70", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/124092ee8afddc68ec7905bd951cc647f7de84e6/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/124092ee8afddc68ec7905bd951cc647f7de84e6/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=124092ee8afddc68ec7905bd951cc647f7de84e6", "patch": "@@ -3345,6 +3345,24 @@ package body Freeze is\n \n                Check_Address_Clause (E);\n \n+               --  Reset Is_True_Constant for aliased object. We consider that\n+               --  the fact that something is aliased may indicate that some\n+               --  funny business is going on, e.g. an aliased object is passed\n+               --  by reference to a procedure which captures the address of\n+               --  the object, which is later used to assign a new value. Such\n+               --  code is highly dubious, but we choose to make it \"work\" for\n+               --  aliased objects.\n+\n+               --  However, we don't do that for internal entities. We figure\n+               --  that if we deliberately set Is_True_Constant for an internal\n+               --  entity, e.g. a dispatch table entry, then we mean it!\n+\n+               if (Is_Aliased (E) or else Is_Aliased (Etype (E)))\n+                 and then not Is_Internal_Name (Chars (E))\n+               then\n+                  Set_Is_True_Constant (E, False);\n+               end if;\n+\n                --  If the object needs any kind of default initialization, an\n                --  error must be issued if No_Default_Initialization applies.\n                --  The check doesn't apply to imported objects, which are not\n@@ -3521,7 +3539,6 @@ package body Freeze is\n                   end if;\n                end;\n             end if;\n-\n          end if;\n \n       --  Case of a type or subtype being frozen"}, {"sha": "7374f04f6a49ac12d78fae62ebf46288bb6d59fa", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/124092ee8afddc68ec7905bd951cc647f7de84e6/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/124092ee8afddc68ec7905bd951cc647f7de84e6/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=124092ee8afddc68ec7905bd951cc647f7de84e6", "patch": "@@ -10004,6 +10004,7 @@ some guidelines on debugging optimized code.\n * Vectorization of loops::\n * Other Optimization Switches::\n * Optimization and Strict Aliasing::\n+* Aliased Variables and Optimization::\n \n @ifset vms\n * Coverage Analysis::\n@@ -10802,6 +10803,58 @@ has on size and speed of the code. If you really need to use\n review any uses of unchecked conversion of access types,\n particularly if you are getting the warnings described above.\n \n+@node Aliased Variables and Optimization\n+@subsection Aliased Variables and Optimization\n+@cindex Aliasing\n+There are scenarios in which programs may\n+use low level techniques to modify variables\n+that otherwise might be considered to be unassigned. For example,\n+a variable can be passed to a procedure by reference, which takes\n+the address of the parameter and uses the address to modify the\n+variable's value, even though it is passed as an IN parameter.\n+Consider the following example:\n+\n+@smallexample @c ada\n+procedure P is\n+   Max_Length : constant Natural := 16;\n+   type Char_Ptr is access all Character;\n+\n+   procedure Get_String(Buffer: Char_Ptr; Size : Integer);\n+   pragma Import (C, Get_String, \"get_string\");\n+\n+   Name : aliased String (1 .. Max_Length) := (others => ' ');\n+   Temp : Char_Ptr;\n+\n+   function Addr (S : String) return Char_Ptr is\n+      function To_Char_Ptr is\n+        new Ada.Unchecked_Conversion (System.Address, Char_Ptr);\n+   begin\n+      return To_Char_Ptr (S (S'First)'Address);\n+   end;\n+\n+begin\n+   Temp := Addr (Name);\n+   Get_String (Temp, Max_Length);\n+end;\n+@end smallexample\n+\n+@noindent\n+where Get_String is a C function that uses the address in Temp to\n+modify the variable @code{Name}. This code is dubious, and arguably\n+erroneous, and the compiler would be entitled to assume that\n+@code{Name} is never modified, and generate code accordingly.\n+\n+However, in practice, this would cause some existing code that\n+seems to work with no optimization to start failing at high\n+levels of optimzization.\n+\n+What the compiler does for such cases is to assume that marking\n+a variable as aliased indicates that some \"funny business\" may\n+be going on. The optimizer recognizes the aliased keyword and\n+inhibits optimizations that assume the value cannot be assigned.\n+This means that the above example will in fact \"work\" reliably,\n+that is, it will produce the expected results.\n+\n @ifset vms\n @node Coverage Analysis\n @subsection Coverage Analysis"}, {"sha": "d7653c7d737d6196fee9b3188bfc4f795793d4b7", "filename": "gcc/ada/init.c", "status": "modified", "additions": 56, "deletions": 8, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/124092ee8afddc68ec7905bd951cc647f7de84e6/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/124092ee8afddc68ec7905bd951cc647f7de84e6/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=124092ee8afddc68ec7905bd951cc647f7de84e6", "patch": "@@ -1665,8 +1665,6 @@ __gnat_install_handler ()\n #include \"private/vThreadsP.h\"\n #endif\n \n-void __gnat_error_handler (int, void *, struct sigcontext *);\n-\n #ifndef __RTP__\n \n /* Directly vectored Interrupt routines are not supported when using RTPs.  */\n@@ -1677,7 +1675,7 @@ extern int __gnat_inum_to_ivec (int);\n int\n __gnat_inum_to_ivec (int num)\n {\n-  return INUM_TO_IVEC (num);\n+  return (int) INUM_TO_IVEC (num);\n }\n #endif\n \n@@ -1711,8 +1709,8 @@ __gnat_clear_exception_count (void)\n /* Handle different SIGnal to exception mappings in different VxWorks\n    versions.   */\n static void\n-__gnat_map_signal (int sig, void *si ATTRIBUTE_UNUSED,\n-\t\t   struct sigcontext *sc ATTRIBUTE_UNUSED)\n+__gnat_map_signal (int sig, siginfo_t *si ATTRIBUTE_UNUSED,\n+\t\t   void *sc ATTRIBUTE_UNUSED)\n {\n   struct Exception_Data *exception;\n   const char *msg;\n@@ -1799,15 +1797,65 @@ __gnat_map_signal (int sig, void *si ATTRIBUTE_UNUSED,\n       msg = \"unhandled signal\";\n     }\n \n+  /* On ARM VxWorks 6.x, the guard page is left in a RWX state by the kernel\n+     after being violated, so subsequent violations aren't detected.  Even if\n+     this defect is fixed, it seems dubious to rely on the signal value alone,\n+     so we retrieve the address of the guard page from the TCB and compare it\n+     with the page that is violated (pREG 12 in the context) and re-arm that\n+     page if there's a match.  Additionally we're are assured this is a\n+     genuine stack overflow condition and and set the message and exception\n+     to that effect.  */\n+#if defined (ARMEL) && (_WRS_VXWORKS_MAJOR == 6)\n+\n+  /* We re-arm the guard page by re-setting it's attributes, however the\n+     protection bits are just the low order seven (0x3f).\n+     0x00040 is the Valid Mask\n+     0x00f00 are Cache attributes\n+     0xff000 are Special attributes\n+     We don't meddle with the 0xfff40 attributes.  */\n+\n+#define PAGE_SIZE 4096\n+#define MMU_ATTR_PROT_MSK 0x0000003f /* Protection Mask.  */\n+#define GUARD_PAGE_PROT 0x8101       /* Found by experiment.  */\n+\n+  if (sig == SIGSEGV || sig == SIGBUS || sig == SIGILL)\n+    {\n+      TASK_ID tid = taskIdSelf ();\n+      WIND_TCB *pTcb = taskTcb (tid);\n+      unsigned long Violated_Page\n+          = ((struct sigcontext *) sc)->sc_pregs->r[12] & ~(PAGE_SIZE - 1);\n+\n+      if ((unsigned long) (pTcb->pStackEnd - PAGE_SIZE) == Violated_Page)\n+        {\n+\t  vmStateSet (NULL, Violated_Page,\n+\t\t      PAGE_SIZE, MMU_ATTR_PROT_MSK, GUARD_PAGE_PROT);\n+\t  exception = &storage_error;\n+\n+\t  switch (sig)\n+\t  {\n+            case SIGSEGV:\n+\t      msg = \"SIGSEGV: stack overflow\";\n+\t      break;\n+            case SIGBUS:\n+\t      msg = \"SIGBUS: stack overflow\";\n+\t      break;\n+            case SIGILL:\n+\t      msg = \"SIGILL: stack overflow\";\n+\t      break;\n+\t  }\n+       }\n+    }\n+#endif /* defined (ARMEL) && (_WRS_VXWORKS_MAJOR == 6) */\n+\n   __gnat_clear_exception_count ();\n   Raise_From_Signal_Handler (exception, msg);\n }\n \n /* Tasking and Non-tasking signal handler.  Map SIGnal to Ada exception\n    propagation after the required low level adjustments.  */\n \n-void\n-__gnat_error_handler (int sig, void *si, struct sigcontext *sc)\n+static void\n+__gnat_error_handler (int sig, siginfo_t *si, void *sc)\n {\n   sigset_t mask;\n \n@@ -1865,7 +1913,7 @@ __gnat_install_handler (void)\n      exceptions.  Make sure that the handler isn't interrupted by another\n      signal that might cause a scheduling event!  */\n \n-  act.sa_handler = __gnat_error_handler;\n+  act.sa_sigaction = __gnat_error_handler;\n   act.sa_flags = SA_SIGINFO | SA_ONSTACK;\n   sigemptyset (&act.sa_mask);\n "}, {"sha": "e617a16bc77555bc7bc015c5b9781fc0def56614", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/124092ee8afddc68ec7905bd951cc647f7de84e6/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/124092ee8afddc68ec7905bd951cc647f7de84e6/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=124092ee8afddc68ec7905bd951cc647f7de84e6", "patch": "@@ -1208,11 +1208,22 @@ package body Sem_Ch8 is\n       --  may have been rewritten in several ways.\n \n       elsif Is_Object_Reference (Nam) then\n-         if Comes_From_Source (N)\n-           and then Is_Dependent_Component_Of_Mutable_Object (Nam)\n-         then\n-            Error_Msg_N\n-              (\"illegal renaming of discriminant-dependent component\", Nam);\n+         if Comes_From_Source (N) then\n+            if Is_Dependent_Component_Of_Mutable_Object (Nam) then\n+               Error_Msg_N\n+                 (\"illegal renaming of discriminant-dependent component\", Nam);\n+            end if;\n+\n+            --  If the renaming comes from source and the renamed object is a\n+            --  dereference, then mark the prefix as needing debug information,\n+            --  since it might have been rewritten hence internally generated\n+            --  and Debug_Renaming_Declaration will link the renaming to it.\n+\n+            if Nkind (Nam) = N_Explicit_Dereference\n+              and then Is_Entity_Name (Prefix (Nam))\n+            then\n+               Set_Debug_Info_Needed (Entity (Prefix (Nam)));\n+            end if;\n          end if;\n \n       --  A static function call may have been folded into a literal"}, {"sha": "16902d63b4ec74acb515b821c35f3ac537dbcc48", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 51, "deletions": 28, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/124092ee8afddc68ec7905bd951cc647f7de84e6/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/124092ee8afddc68ec7905bd951cc647f7de84e6/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=124092ee8afddc68ec7905bd951cc647f7de84e6", "patch": "@@ -1600,11 +1600,14 @@ package body Sem_Prag is\n       --  Start of processing for Analyze_Global_List\n \n       begin\n+         if Nkind (List) = N_Null then\n+            null;\n+\n          --  Single global item declaration\n \n-         if Nkind_In (List, N_Expanded_Name,\n-                            N_Identifier,\n-                            N_Selected_Component)\n+         elsif Nkind_In (List, N_Expanded_Name,\n+                               N_Identifier,\n+                               N_Selected_Component)\n          then\n             Analyze_Global_Item (List, Global_Mode);\n \n@@ -1691,7 +1694,7 @@ package body Sem_Prag is\n \n       --  Local variables\n \n-      List      : Node_Id;\n+      Items     : Node_Id;\n       Subp_Decl : Node_Id;\n \n       Restore_Scope : Boolean := False;\n@@ -1704,11 +1707,11 @@ package body Sem_Prag is\n \n       Subp_Decl := Find_Related_Subprogram (N);\n       Subp_Id   := Defining_Unit_Name (Specification (Subp_Decl));\n-      List      := Get_Pragma_Arg (First (Pragma_Argument_Associations (N)));\n+      Items     := Get_Pragma_Arg (First (Pragma_Argument_Associations (N)));\n \n       --  There is nothing to be done for a null global list\n \n-      if Nkind (List) = N_Null then\n+      if Nkind (Items) = N_Null then\n          null;\n \n       --  Analyze the various forms of global lists and items. Note that some\n@@ -1726,7 +1729,7 @@ package body Sem_Prag is\n             Install_Formals (Subp_Id);\n          end if;\n \n-         Analyze_Global_List (List);\n+         Analyze_Global_List (Items);\n \n          if Restore_Scope then\n             End_Scope;\n@@ -19358,6 +19361,10 @@ package body Sem_Prag is\n       --  a state of mode Input, In_Out and Output respectively with a visible\n       --  refinement.\n \n+      Has_Null_State : Boolean := False;\n+      --  This flag is set when the corresponding Global aspect/pragma has at\n+      --  least one state with a null refinement.\n+\n       In_Constits     : Elist_Id := No_Elist;\n       In_Out_Constits : Elist_Id := No_Elist;\n       Out_Constits    : Elist_Id := No_Elist;\n@@ -19512,7 +19519,7 @@ package body Sem_Prag is\n                --  Ensure that one of the three coverage variants is satisfied\n \n                if Ekind (Item_Id) = E_Abstract_State\n-                 and then Present (Refinement_Constituents (Item_Id))\n+                 and then not Has_Null_Refinement (Item_Id)\n                then\n                   Check_Constituent_Usage (Item_Id);\n                end if;\n@@ -19595,7 +19602,7 @@ package body Sem_Prag is\n                --  is of mode Input.\n \n                if Ekind (Item_Id) = E_Abstract_State\n-                 and then Present (Refinement_Constituents (Item_Id))\n+                 and then not Has_Null_Refinement (Item_Id)\n                then\n                   Check_Constituent_Usage (Item_Id);\n                end if;\n@@ -19665,7 +19672,7 @@ package body Sem_Prag is\n                --  have mode Output.\n \n                if Ekind (Item_Id) = E_Abstract_State\n-                 and then Present (Refinement_Constituents (Item_Id))\n+                 and then not Has_Null_Refinement (Item_Id)\n                then\n                   Check_Constituent_Usage (Item_Id);\n                end if;\n@@ -19881,11 +19888,14 @@ package body Sem_Prag is\n       --  Start of processing for Check_Refined_Global_List\n \n       begin\n+         if Nkind (List) = N_Null then\n+            null;\n+\n          --  Single global item declaration\n \n-         if Nkind_In (List, N_Expanded_Name,\n-                            N_Identifier,\n-                            N_Selected_Component)\n+         elsif Nkind_In (List, N_Expanded_Name,\n+                               N_Identifier,\n+                               N_Selected_Component)\n          then\n             Check_Refined_Global_Item (List, Global_Mode);\n \n@@ -19963,17 +19973,20 @@ package body Sem_Prag is\n \n             begin\n                --  Signal that the global list contains at least one abstract\n-               --  state with a visible refinement.\n+               --  state with a visible refinement. Note that the refinement\n+               --  may be null in which case there are no constituents.\n \n-               if Ekind (Item_Id) = E_Abstract_State\n-                 and then Present (Refinement_Constituents (Item_Id))\n-               then\n-                  if Mode = Name_Input then\n-                     Has_In_State := True;\n-                  elsif Mode = Name_In_Out then\n-                     Has_In_Out_State := True;\n-                  elsif Mode = Name_Output then\n-                     Has_Out_State := True;\n+               if Ekind (Item_Id) = E_Abstract_State then\n+                  if Has_Null_Refinement (Item_Id) then\n+                     Has_Null_State := True;\n+                  else\n+                     if Mode = Name_Input then\n+                        Has_In_State := True;\n+                     elsif Mode = Name_In_Out then\n+                        Has_In_Out_State := True;\n+                     elsif Mode = Name_Output then\n+                        Has_Out_State := True;\n+                     end if;\n                   end if;\n                end if;\n \n@@ -19995,11 +20008,14 @@ package body Sem_Prag is\n          --  Start of processing for Process_Global_List\n \n          begin\n+            if Nkind (List) = N_Null then\n+               null;\n+\n             --  Single global item declaration\n \n-            if Nkind_In (List, N_Expanded_Name,\n-                               N_Identifier,\n-                               N_Selected_Component)\n+            elsif Nkind_In (List, N_Expanded_Name,\n+                                  N_Identifier,\n+                                  N_Selected_Component)\n             then\n                Process_Global_Item (List, Mode);\n \n@@ -20148,11 +20164,13 @@ package body Sem_Prag is\n \n       --  The corresponding Global aspect/pragma must mention at least one\n       --  state with a visible refinement at the point Refined_Global is\n-      --  processed.\n+      --  processed. States with null refinements warrant a Refined_Global\n+      --  aspect/pragma.\n \n       if not Has_In_State\n         and then not Has_In_Out_State\n         and then not Has_Out_State\n+        and then not Has_Null_State\n       then\n          Error_Msg_NE\n            (\"useless refinement, subprogram & does not mention abstract state \"\n@@ -20161,13 +20179,15 @@ package body Sem_Prag is\n       end if;\n \n       --  The global refinement of inputs and outputs cannot be null when the\n-      --  corresponding Global aspect/pragma contains at least one item.\n+      --  corresponding Global aspect/pragma contains at least one item except\n+      --  in the case where we have states with null refinements.\n \n       if Nkind (List) = N_Null\n         and then\n           (Present (In_Items)\n             or else Present (In_Out_Items)\n             or else Present (Out_Items))\n+         and then not Has_Null_State\n       then\n          Error_Msg_NE\n            (\"refinement cannot be null, subprogram & has global items\",\n@@ -20370,8 +20390,11 @@ package body Sem_Prag is\n                   Error_Msg_N\n                     (\"cannot mix null and non-null constituents\", Constit);\n \n+               --  Mark the related state as having a null refinement\n+\n                else\n                   Null_Seen := True;\n+                  Set_Has_Null_Refinement (State_Id);\n                end if;\n \n             --  Non-null constituents"}, {"sha": "60a41e1b27b54b66bcd625b56a0c1a5ca8d3c068", "filename": "gcc/ada/system-vxworks-arm.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/124092ee8afddc68ec7905bd951cc647f7de84e6/gcc%2Fada%2Fsystem-vxworks-arm.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/124092ee8afddc68ec7905bd951cc647f7de84e6/gcc%2Fada%2Fsystem-vxworks-arm.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsystem-vxworks-arm.ads?ref=124092ee8afddc68ec7905bd951cc647f7de84e6", "patch": "@@ -7,7 +7,7 @@\n --                                 S p e c                                  --\n --                          (VxWorks Version ARM)                           --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -142,8 +142,8 @@ private\n    Preallocated_Stacks       : constant Boolean := False;\n    Signed_Zeros              : constant Boolean := True;\n    Stack_Check_Default       : constant Boolean := False;\n-   Stack_Check_Probes        : constant Boolean := False;\n-   Stack_Check_Limits        : constant Boolean := True;\n+   Stack_Check_Probes        : constant Boolean := True;\n+   Stack_Check_Limits        : constant Boolean := False;\n    Support_Aggregates        : constant Boolean := True;\n    Support_Composite_Assign  : constant Boolean := True;\n    Support_Composite_Compare : constant Boolean := True;"}]}