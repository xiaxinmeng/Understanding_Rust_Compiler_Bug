{"sha": "f43eb7707c06e8824d07d5c87ed2019d796fa8a0", "node_id": "C_kwDOANBUbNoAKGY0M2ViNzcwN2MwNmU4ODI0ZDA3ZDVjODdlZDIwMTlkNzk2ZmE4YTA", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-10-06T08:13:51Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-10-06T08:13:51Z"}, "message": "libcpp: Implement C++23 P2334R1 - #elifdef/#elifndef\n\nThis patch implements C++23 P2334R1, which is easy because Joseph has done\nall the hard work for C2X already.\nUnlike the C N2645 paper, the C++ P2334R1 contains one important addition\n(but not in the normative text):\n\"While this is a new preprocessor feature and cannot be treated as a defect\nreport, implementations that support older versions of the standard are\nencouraged to implement this feature in the older language modes as well\nas C++23.\"\nso there are different variants how to implement it.\nOne is ignoring that sentence and only implementing it\nfor -std=c++23/-std=gnu++23 like it is only implemented for -std=c2x.\nAnother option would be to implement it also in the older GNU modes but\nnot in the C/CXX modes (but it would be strange if we did that just for\nC++ and not for C).\nYet another option is to enable it unconditionally.\nAnd yet another option would be to enable it unconditionally but emit\na warning (or pedwarn) when it is seen.\nNote, when it is enabled for the older language modes, as Joseph wrote\nin the c11-elifdef-1.c testcase, it can result e.g. in rejecting previously\nvalid code:\n #define A\n #undef B\n #if 0\n #elifdef A\n #error \"#elifdef A applied\"\n #endif\n #if 0\n #elifndef B\n #error \"#elifndef B applied\"\n #endif\nNote, seems clang went the enable it unconditionally in all standard\nversions of both C and C++, no warnings or anything whatsoever, so\nessentially treated it as a DR that changed behavior of e.g. the above code.\nAfter feedback, this option enables #elifdef/#elifndef for -std=c2x\nand -std=c++2{b,3} and enables it also for -std=gnu*, but for GNU modes\nolder than C2X or C++23 if -pedantic it emits a pedwarn on the directives\nthat either would be rejected in the corresponding -std=c* modes, e.g.\n  #if 1\n  #elifdef A // pedwarn if -pedantic\n  #endif\nor when the directives would be silently accepted, but when they are\nrecognized it changes behavior, so e.g.\n  #define A\n  #if 0\n  #elifdef A // pedwarn if -pedantic\n  #define M 1\n  #endif\nIt won't pedwarn if the directives would be silently ignored and wouldn't\nchange anything, like:\n  #define A\n  #if 0\n  #elifndef A\n  #define M 1\n  #endif\nor\n  #undef B\n  #if 0\n  #elifdef B\n  #define M 1\n  #endif\n\n2021-10-06  Jakub Jelinek  <jakub@redhat.com>\n\nlibcpp/\n\t* init.c (lang_defaults): Implement P2334R1, enable elifdef for\n\t-std=c++23 and -std=gnu++23.\n\t* directives.c (_cpp_handle_directive): Support elifdef/elifndef if\n\teither CPP_OPTION (pfile, elifdef) or !CPP_OPTION (pfile, std).\n\t(do_elif): For older non-std modes if pedantic pedwarn about\n\t#elifdef/#elifndef directives that change behavior.\ngcc/testsuite/\n\t* gcc.dg/cpp/gnu11-elifdef-1.c: New test.\n\t* gcc.dg/cpp/gnu11-elifdef-2.c: New test.\n\t* gcc.dg/cpp/gnu11-elifdef-3.c: New test.\n\t* gcc.dg/cpp/gnu11-elifdef-4.c: New test.\n\t* g++.dg/cpp/elifdef-1.C: New test.\n\t* g++.dg/cpp/elifdef-2.C: New test.\n\t* g++.dg/cpp/elifdef-3.C: New test.\n\t* g++.dg/cpp/elifdef-4.C: New test.\n\t* g++.dg/cpp/elifdef-5.C: New test.\n\t* g++.dg/cpp/elifdef-6.C: New test.\n\t* g++.dg/cpp/elifdef-7.C: New test.", "tree": {"sha": "de2393608bfe1d6a93145f93343c7222ac8fe704", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de2393608bfe1d6a93145f93343c7222ac8fe704"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f43eb7707c06e8824d07d5c87ed2019d796fa8a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f43eb7707c06e8824d07d5c87ed2019d796fa8a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f43eb7707c06e8824d07d5c87ed2019d796fa8a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f43eb7707c06e8824d07d5c87ed2019d796fa8a0/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ece8b0fce6bbfb1e531de8164da47eeed80d3cf1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ece8b0fce6bbfb1e531de8164da47eeed80d3cf1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ece8b0fce6bbfb1e531de8164da47eeed80d3cf1"}], "stats": {"total": 512, "additions": 508, "deletions": 4}, "files": [{"sha": "f7965e3c2e89ad6db4170a1accf81d6b88853474", "filename": "gcc/testsuite/g++.dg/cpp/elifdef-1.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f43eb7707c06e8824d07d5c87ed2019d796fa8a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Felifdef-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f43eb7707c06e8824d07d5c87ed2019d796fa8a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Felifdef-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Felifdef-1.C?ref=f43eb7707c06e8824d07d5c87ed2019d796fa8a0", "patch": "@@ -0,0 +1,3 @@\n+// { dg-do preprocess { target { ! c++23 } } }\n+\n+#include \"../../gcc.dg/cpp/c11-elifdef-1.c\""}, {"sha": "64082710fdefd6cbea02e7009064371a80e4cd73", "filename": "gcc/testsuite/g++.dg/cpp/elifdef-2.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f43eb7707c06e8824d07d5c87ed2019d796fa8a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Felifdef-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f43eb7707c06e8824d07d5c87ed2019d796fa8a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Felifdef-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Felifdef-2.C?ref=f43eb7707c06e8824d07d5c87ed2019d796fa8a0", "patch": "@@ -0,0 +1,4 @@\n+// P2334R1\n+// { dg-do preprocess { target c++23 } }\n+\n+#include \"../../gcc.dg/cpp/c2x-elifdef-1.c\""}, {"sha": "d9acce06e057e54412798e4ad0d03e8d5ff47373", "filename": "gcc/testsuite/g++.dg/cpp/elifdef-3.C", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f43eb7707c06e8824d07d5c87ed2019d796fa8a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Felifdef-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f43eb7707c06e8824d07d5c87ed2019d796fa8a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Felifdef-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Felifdef-3.C?ref=f43eb7707c06e8824d07d5c87ed2019d796fa8a0", "patch": "@@ -0,0 +1,62 @@\n+// P2334R1\n+// { dg-do preprocess { target c++23 } }\n+\n+#define A\n+#undef B\n+\n+#elifdef A // { dg-error \"#elifdef without #if\" }\n+#elifdef B // { dg-error \"#elifdef without #if\" }\n+#elifndef A // { dg-error \"#elifndef without #if\" }\n+#elifndef B // { dg-error \"#elifndef without #if\" }\n+\n+#if 1 // { dg-error \"-:began here\" }\n+#else\n+#elifdef A // { dg-error \"#elifdef after #else\" }\n+#endif\n+\n+#if 1 // { dg-error \"-:began here\" }\n+#else\n+#elifdef B // { dg-error \"#elifdef after #else\" }\n+#endif\n+\n+#if 1 // { dg-error \"-:began here\" }\n+#else\n+#elifndef A // { dg-error \"#elifndef after #else\" }\n+#endif\n+\n+#if 1 // { dg-error \"-:began here\" }\n+#else\n+#elifndef B // { dg-error \"#elifndef after #else\" }\n+#endif\n+\n+#if 0\n+#elifdef A = // { dg-error \"extra tokens at end of #elifdef directive\" }\n+#endif\n+\n+#if 0\n+#elifdef B = // { dg-error \"extra tokens at end of #elifdef directive\" }\n+#endif\n+\n+#if 0\n+#elifndef A = // { dg-error \"extra tokens at end of #elifndef directive\" }\n+#endif\n+\n+#if 0\n+#elifndef B = // { dg-error \"extra tokens at end of #elifndef directive\" }\n+#endif\n+\n+#if 0\n+#elifdef // { dg-error \"no macro name given in #elifdef directive\" }\n+#endif\n+\n+#if 0\n+#elifndef // { dg-error \"no macro name given in #elifndef directive\" }\n+#endif\n+\n+#if 0\n+#elifdef , // { dg-error \"macro names must be identifiers\" }\n+#endif\n+\n+#if 0\n+#elifndef , // { dg-error \"macro names must be identifiers\" }\n+#endif"}, {"sha": "08edf583fa588dc8fbffe6bd1a9593ff4295e073", "filename": "gcc/testsuite/g++.dg/cpp/elifdef-4.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f43eb7707c06e8824d07d5c87ed2019d796fa8a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Felifdef-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f43eb7707c06e8824d07d5c87ed2019d796fa8a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Felifdef-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Felifdef-4.C?ref=f43eb7707c06e8824d07d5c87ed2019d796fa8a0", "patch": "@@ -0,0 +1,5 @@\n+// P2334R1\n+// { dg-do preprocess }\n+// { dg-options \"\" }\n+\n+#include \"../../gcc.dg/cpp/c2x-elifdef-1.c\""}, {"sha": "f7d4007d3451389d8dee5fff198bd628eb32919b", "filename": "gcc/testsuite/g++.dg/cpp/elifdef-5.C", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f43eb7707c06e8824d07d5c87ed2019d796fa8a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Felifdef-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f43eb7707c06e8824d07d5c87ed2019d796fa8a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Felifdef-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Felifdef-5.C?ref=f43eb7707c06e8824d07d5c87ed2019d796fa8a0", "patch": "@@ -0,0 +1,63 @@\n+// P2334R1\n+// { dg-do preprocess }\n+// { dg-options \"\" }\n+\n+#define A\n+#undef B\n+\n+#elifdef A // { dg-error \"#elifdef without #if\" }\n+#elifdef B // { dg-error \"#elifdef without #if\" }\n+#elifndef A // { dg-error \"#elifndef without #if\" }\n+#elifndef B // { dg-error \"#elifndef without #if\" }\n+\n+#if 1 // { dg-error \"-:began here\" }\n+#else\n+#elifdef A // { dg-error \"#elifdef after #else\" }\n+#endif\n+\n+#if 1 // { dg-error \"-:began here\" }\n+#else\n+#elifdef B // { dg-error \"#elifdef after #else\" }\n+#endif\n+\n+#if 1 // { dg-error \"-:began here\" }\n+#else\n+#elifndef A // { dg-error \"#elifndef after #else\" }\n+#endif\n+\n+#if 1 // { dg-error \"-:began here\" }\n+#else\n+#elifndef B // { dg-error \"#elifndef after #else\" }\n+#endif\n+\n+#if 0\n+#elifdef A = // { dg-warning \"extra tokens at end of #elifdef directive\" }\n+#endif\n+\n+#if 0\n+#elifdef B = // { dg-warning \"extra tokens at end of #elifdef directive\" }\n+#endif\n+\n+#if 0\n+#elifndef A = // { dg-warning \"extra tokens at end of #elifndef directive\" }\n+#endif\n+\n+#if 0\n+#elifndef B = // { dg-warning \"extra tokens at end of #elifndef directive\" }\n+#endif\n+\n+#if 0\n+#elifdef // { dg-error \"no macro name given in #elifdef directive\" }\n+#endif\n+\n+#if 0\n+#elifndef // { dg-error \"no macro name given in #elifndef directive\" }\n+#endif\n+\n+#if 0\n+#elifdef , // { dg-error \"macro names must be identifiers\" }\n+#endif\n+\n+#if 0\n+#elifndef , // { dg-error \"macro names must be identifiers\" }\n+#endif"}, {"sha": "94d2118aae0c1adce2414d39f91cfc8fc3263e68", "filename": "gcc/testsuite/g++.dg/cpp/elifdef-6.C", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f43eb7707c06e8824d07d5c87ed2019d796fa8a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Felifdef-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f43eb7707c06e8824d07d5c87ed2019d796fa8a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Felifdef-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Felifdef-6.C?ref=f43eb7707c06e8824d07d5c87ed2019d796fa8a0", "patch": "@@ -0,0 +1,65 @@\n+// P2334R1\n+// { dg-do preprocess }\n+// { dg-options \"-pedantic\" }\n+\n+#define A\n+#undef B\n+\n+#if 0\n+#elifdef A\t// { dg-warning \"#elifdef before C\\\\\\+\\\\\\+23 is a GCC extension\" \"\" { target c++20_down } }\n+#define M1 1\n+#endif\n+\n+#if M1 != 1\n+#error \"#elifdef A did not apply\"\n+#endif\n+\n+#if 0\n+#elifdef B\n+#error \"#elifdef B applied\"\n+#endif\n+\n+#if 0\n+#elifndef A\n+#error \"#elifndef A applied\"\n+#endif\n+\n+#if 0\n+#elifndef B\t// { dg-warning \"#elifndef before C\\\\\\+\\\\\\+23 is a GCC extension\" \"\" { target c++20_down } }\n+#define M2 2\n+#endif\n+\n+#if M2 != 2\n+#error \"#elifndef B did not apply\"\n+#endif\n+\n+#if 0\n+#elifdef A\t// { dg-warning \"#elifdef before C\\\\\\+\\\\\\+23 is a GCC extension\" \"\" { target c++20_down } }\n+#else\n+#error \"#elifdef A did not apply\"\n+#endif\n+\n+#if 0\n+#elifndef B\t// { dg-warning \"#elifndef before C\\\\\\+\\\\\\+23 is a GCC extension\" \"\" { target c++20_down } }\n+#else\n+#error \"#elifndef B did not apply\"\n+#endif\n+\n+#if 1\n+#elifdef A\t// { dg-warning \"#elifdef before C\\\\\\+\\\\\\+23 is a GCC extension\" \"\" { target c++20_down } }\n+#endif\n+\n+#if 1\n+#elifndef B\t// { dg-warning \"#elifndef before C\\\\\\+\\\\\\+23 is a GCC extension\" \"\" { target c++20_down } }\n+#endif\n+\n+// As with #elif, the syntax of the new directives is relaxed after a\n+   non-skipped group. \n+\n+#if 1\n+#elifdef x * y\t// { dg-warning \"#elifdef before C\\\\\\+\\\\\\+23 is a GCC extension\" \"\" { target c++20_down } }\n+#endif\n+\n+#if 1\n+#elifndef !\t// { dg-warning \"#elifndef before C\\\\\\+\\\\\\+23 is a GCC extension\" \"\" { target c++20_down } }\n+#endif"}, {"sha": "bb9b8efab9484fbaaf72f7d298440d75a549fd0f", "filename": "gcc/testsuite/g++.dg/cpp/elifdef-7.C", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f43eb7707c06e8824d07d5c87ed2019d796fa8a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Felifdef-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f43eb7707c06e8824d07d5c87ed2019d796fa8a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Felifdef-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Felifdef-7.C?ref=f43eb7707c06e8824d07d5c87ed2019d796fa8a0", "patch": "@@ -0,0 +1,65 @@\n+// P2334R1\n+// { dg-do preprocess }\n+// { dg-options \"-pedantic-errors\" }\n+\n+#define A\n+#undef B\n+\n+#if 0\n+#elifdef A\t// { dg-error \"#elifdef before C\\\\\\+\\\\\\+23 is a GCC extension\" \"\" { target c++20_down } }\n+#define M1 1\n+#endif\n+\n+#if M1 != 1\n+#error \"#elifdef A did not apply\"\n+#endif\n+\n+#if 0\n+#elifdef B\n+#error \"#elifdef B applied\"\n+#endif\n+\n+#if 0\n+#elifndef A\n+#error \"#elifndef A applied\"\n+#endif\n+\n+#if 0\n+#elifndef B\t// { dg-error \"#elifndef before C\\\\\\+\\\\\\+23 is a GCC extension\" \"\" { target c++20_down } }\n+#define M2 2\n+#endif\n+\n+#if M2 != 2\n+#error \"#elifndef B did not apply\"\n+#endif\n+\n+#if 0\n+#elifdef A\t// { dg-error \"#elifdef before C\\\\\\+\\\\\\+23 is a GCC extension\" \"\" { target c++20_down } }\n+#else\n+#error \"#elifdef A did not apply\"\n+#endif\n+\n+#if 0\n+#elifndef B\t// { dg-error \"#elifndef before C\\\\\\+\\\\\\+23 is a GCC extension\" \"\" { target c++20_down } }\n+#else\n+#error \"#elifndef B did not apply\"\n+#endif\n+\n+#if 1\n+#elifdef A\t// { dg-error \"#elifdef before C\\\\\\+\\\\\\+23 is a GCC extension\" \"\" { target c++20_down } }\n+#endif\n+\n+#if 1\n+#elifndef B\t// { dg-error \"#elifndef before C\\\\\\+\\\\\\+23 is a GCC extension\" \"\" { target c++20_down } }\n+#endif\n+\n+// As with #elif, the syntax of the new directives is relaxed after a\n+   non-skipped group. \n+\n+#if 1\n+#elifdef x * y\t// { dg-error \"#elifdef before C\\\\\\+\\\\\\+23 is a GCC extension\" \"\" { target c++20_down } }\n+#endif\n+\n+#if 1\n+#elifndef !\t// { dg-error \"#elifndef before C\\\\\\+\\\\\\+23 is a GCC extension\" \"\" { target c++20_down } }\n+#endif"}, {"sha": "efcfbc932706ebaca936ca08322340319a54902a", "filename": "gcc/testsuite/gcc.dg/cpp/gnu11-elifdef-1.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f43eb7707c06e8824d07d5c87ed2019d796fa8a0/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fgnu11-elifdef-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f43eb7707c06e8824d07d5c87ed2019d796fa8a0/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fgnu11-elifdef-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fgnu11-elifdef-1.c?ref=f43eb7707c06e8824d07d5c87ed2019d796fa8a0", "patch": "@@ -0,0 +1,5 @@\n+/* Test #elifdef and #elifndef in GNU11.  */\n+/* { dg-do preprocess } */\n+/* { dg-options \"-std=gnu11\" } */\n+\n+#include \"c2x-elifdef-1.c\""}, {"sha": "e5bd7056de341c6feeebcd4fee0f7832b0f3ee7f", "filename": "gcc/testsuite/gcc.dg/cpp/gnu11-elifdef-2.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f43eb7707c06e8824d07d5c87ed2019d796fa8a0/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fgnu11-elifdef-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f43eb7707c06e8824d07d5c87ed2019d796fa8a0/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fgnu11-elifdef-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fgnu11-elifdef-2.c?ref=f43eb7707c06e8824d07d5c87ed2019d796fa8a0", "patch": "@@ -0,0 +1,63 @@\n+/* Test #elifdef and #elifndef in GNU11: erroneous usages.  */\n+/* { dg-do preprocess } */\n+/* { dg-options \"-std=gnu11\" } */\n+\n+#define A\n+#undef B\n+\n+#elifdef A /* { dg-error \"#elifdef without #if\" } */\n+#elifdef B /* { dg-error \"#elifdef without #if\" } */\n+#elifndef A /* { dg-error \"#elifndef without #if\" } */\n+#elifndef B /* { dg-error \"#elifndef without #if\" } */\n+\n+#if 1 /* { dg-error \"-:began here\" } */\n+#else\n+#elifdef A /* { dg-error \"#elifdef after #else\" } */\n+#endif\n+\n+#if 1 /* { dg-error \"-:began here\" } */\n+#else\n+#elifdef B /* { dg-error \"#elifdef after #else\" } */\n+#endif\n+\n+#if 1 /* { dg-error \"-:began here\" } */\n+#else\n+#elifndef A /* { dg-error \"#elifndef after #else\" } */\n+#endif\n+\n+#if 1 /* { dg-error \"-:began here\" } */\n+#else\n+#elifndef B /* { dg-error \"#elifndef after #else\" } */\n+#endif\n+\n+#if 0\n+#elifdef A = /* { dg-warning \"extra tokens at end of #elifdef directive\" } */\n+#endif\n+\n+#if 0\n+#elifdef B = /* { dg-warning \"extra tokens at end of #elifdef directive\" } */\n+#endif\n+\n+#if 0\n+#elifndef A = /* { dg-warning \"extra tokens at end of #elifndef directive\" } */\n+#endif\n+\n+#if 0\n+#elifndef B = /* { dg-warning \"extra tokens at end of #elifndef directive\" } */\n+#endif\n+\n+#if 0\n+#elifdef /* { dg-error \"no macro name given in #elifdef directive\" } */\n+#endif\n+\n+#if 0\n+#elifndef /* { dg-error \"no macro name given in #elifndef directive\" } */\n+#endif\n+\n+#if 0\n+#elifdef , /* { dg-error \"macro names must be identifiers\" } */\n+#endif\n+\n+#if 0\n+#elifndef , /* { dg-error \"macro names must be identifiers\" } */\n+#endif"}, {"sha": "0b769a73a830e7bd9ed79e30d691058f32021652", "filename": "gcc/testsuite/gcc.dg/cpp/gnu11-elifdef-3.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f43eb7707c06e8824d07d5c87ed2019d796fa8a0/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fgnu11-elifdef-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f43eb7707c06e8824d07d5c87ed2019d796fa8a0/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fgnu11-elifdef-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fgnu11-elifdef-3.c?ref=f43eb7707c06e8824d07d5c87ed2019d796fa8a0", "patch": "@@ -0,0 +1,65 @@\n+/* Test #elifdef and #elifndef in GNU11.  */\n+/* { dg-do preprocess } */\n+/* { dg-options \"-std=gnu11 -pedantic\" } */\n+\n+#define A\n+#undef B\n+\n+#if 0\n+#elifdef A\t/* { dg-warning \"#elifdef before C2X is a GCC extension\" } */\n+#define M1 1\n+#endif\n+\n+#if M1 != 1\n+#error \"#elifdef A did not apply\"\n+#endif\n+\n+#if 0\n+#elifdef B\n+#error \"#elifdef B applied\"\n+#endif\n+\n+#if 0\n+#elifndef A\n+#error \"#elifndef A applied\"\n+#endif\n+\n+#if 0\n+#elifndef B\t/* { dg-warning \"#elifndef before C2X is a GCC extension\" } */\n+#define M2 2\n+#endif\n+\n+#if M2 != 2\n+#error \"#elifndef B did not apply\"\n+#endif\n+\n+#if 0\n+#elifdef A\t/* { dg-warning \"#elifdef before C2X is a GCC extension\" } */\n+#else\n+#error \"#elifdef A did not apply\"\n+#endif\n+\n+#if 0\n+#elifndef B\t/* { dg-warning \"#elifndef before C2X is a GCC extension\" } */\n+#else\n+#error \"#elifndef B did not apply\"\n+#endif\n+\n+#if 1\n+#elifdef A\t/* { dg-warning \"#elifdef before C2X is a GCC extension\" } */\n+#endif\n+\n+#if 1\n+#elifndef B\t/* { dg-warning \"#elifndef before C2X is a GCC extension\" } */\n+#endif\n+\n+/* As with #elif, the syntax of the new directives is relaxed after a\n+   non-skipped group.  */\n+\n+#if 1\n+#elifdef x * y\t/* { dg-warning \"#elifdef before C2X is a GCC extension\" } */\n+#endif\n+\n+#if 1\n+#elifndef !\t/* { dg-warning \"#elifndef before C2X is a GCC extension\" } */\n+#endif"}, {"sha": "aba3467336645c796a28039defbec468c07e54f8", "filename": "gcc/testsuite/gcc.dg/cpp/gnu11-elifdef-4.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f43eb7707c06e8824d07d5c87ed2019d796fa8a0/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fgnu11-elifdef-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f43eb7707c06e8824d07d5c87ed2019d796fa8a0/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fgnu11-elifdef-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fgnu11-elifdef-4.c?ref=f43eb7707c06e8824d07d5c87ed2019d796fa8a0", "patch": "@@ -0,0 +1,65 @@\n+/* Test #elifdef and #elifndef in GNU11.  */\n+/* { dg-do preprocess } */\n+/* { dg-options \"-std=gnu11 -pedantic-errors\" } */\n+\n+#define A\n+#undef B\n+\n+#if 0\n+#elifdef A\t/* { dg-error \"#elifdef before C2X is a GCC extension\" } */\n+#define M1 1\n+#endif\n+\n+#if M1 != 1\n+#error \"#elifdef A did not apply\"\n+#endif\n+\n+#if 0\n+#elifdef B\n+#error \"#elifdef B applied\"\n+#endif\n+\n+#if 0\n+#elifndef A\n+#error \"#elifndef A applied\"\n+#endif\n+\n+#if 0\n+#elifndef B\t/* { dg-error \"#elifndef before C2X is a GCC extension\" } */\n+#define M2 2\n+#endif\n+\n+#if M2 != 2\n+#error \"#elifndef B did not apply\"\n+#endif\n+\n+#if 0\n+#elifdef A\t/* { dg-error \"#elifdef before C2X is a GCC extension\" } */\n+#else\n+#error \"#elifdef A did not apply\"\n+#endif\n+\n+#if 0\n+#elifndef B\t/* { dg-error \"#elifndef before C2X is a GCC extension\" } */\n+#else\n+#error \"#elifndef B did not apply\"\n+#endif\n+\n+#if 1\n+#elifdef A\t/* { dg-error \"#elifdef before C2X is a GCC extension\" } */\n+#endif\n+\n+#if 1\n+#elifndef B\t/* { dg-error \"#elifndef before C2X is a GCC extension\" } */\n+#endif\n+\n+/* As with #elif, the syntax of the new directives is relaxed after a\n+   non-skipped group.  */\n+\n+#if 1\n+#elifdef x * y\t/* { dg-error \"#elifdef before C2X is a GCC extension\" } */\n+#endif\n+\n+#if 1\n+#elifndef !\t/* { dg-error \"#elifndef before C2X is a GCC extension\" } */\n+#endif"}, {"sha": "b4bc8b4df30fa8b6ef15e1721132c997a41f2a8a", "filename": "libcpp/directives.c", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f43eb7707c06e8824d07d5c87ed2019d796fa8a0/libcpp%2Fdirectives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f43eb7707c06e8824d07d5c87ed2019d796fa8a0/libcpp%2Fdirectives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives.c?ref=f43eb7707c06e8824d07d5c87ed2019d796fa8a0", "patch": "@@ -447,7 +447,11 @@ _cpp_handle_directive (cpp_reader *pfile, bool indented)\n       if (dname->val.node.node->is_directive)\n \t{\n \t  dir = &dtable[dname->val.node.node->directive_index];\n-\t  if ((dir->flags & ELIFDEF) && !CPP_OPTION (pfile, elifdef))\n+\t  if ((dir->flags & ELIFDEF)\n+\t      && !CPP_OPTION (pfile, elifdef)\n+\t      /* For -std=gnu* modes elifdef is supported with\n+\t\t a pedwarn if pedantic.  */\n+\t      && CPP_OPTION (pfile, std))\n \t    dir = 0;\n \t}\n     }\n@@ -2117,7 +2121,26 @@ do_elif (cpp_reader *pfile)\n \t are skipped and their controlling directives are processed as\n \t if they were in a group that is skipped.\"  */\n       if (ifs->skip_elses)\n-\tpfile->state.skipping = 1;\n+\t{\n+\t  /* In older GNU standards, #elifdef/#elifndef is supported\n+\t     as an extension, but pedwarn if -pedantic if the presence\n+\t     of the directive would be rejected.  */\n+\t  if (pfile->directive != &dtable[T_ELIF]\n+\t      && ! CPP_OPTION (pfile, elifdef)\n+\t      && CPP_PEDANTIC (pfile)\n+\t      && !pfile->state.skipping)\n+\t    {\n+\t      if (CPP_OPTION (pfile, cplusplus))\n+\t\tcpp_error (pfile, CPP_DL_PEDWARN,\n+\t\t\t   \"#%s before C++23 is a GCC extension\",\n+\t\t\t   pfile->directive->name);\n+\t      else\n+\t\tcpp_error (pfile, CPP_DL_PEDWARN,\n+\t\t\t   \"#%s before C2X is a GCC extension\",\n+\t\t\t   pfile->directive->name);\n+\t    }\n+\t  pfile->state.skipping = 1;\n+\t}\n       else\n \t{\n \t  if (pfile->directive == &dtable[T_ELIF])\n@@ -2139,6 +2162,22 @@ do_elif (cpp_reader *pfile)\n \t\t  if (pfile->cb.used)\n \t\t    pfile->cb.used (pfile, pfile->directive_line, node);\n \t\t  check_eol (pfile, false);\n+\t\t  /* In older GNU standards, #elifdef/#elifndef is supported\n+\t\t     as an extension, but pedwarn if -pedantic if the presence\n+\t\t     of the directive would change behavior.  */\n+\t\t  if (! CPP_OPTION (pfile, elifdef)\n+\t\t      && CPP_PEDANTIC (pfile)\n+\t\t      && pfile->state.skipping != skip)\n+\t\t    {\n+\t\t      if (CPP_OPTION (pfile, cplusplus))\n+\t\t\tcpp_error (pfile, CPP_DL_PEDWARN,\n+\t\t\t\t   \"#%s before C++23 is a GCC extension\",\n+\t\t\t\t   pfile->directive->name);\n+\t\t      else\n+\t\t\tcpp_error (pfile, CPP_DL_PEDWARN,\n+\t\t\t\t   \"#%s before C2X is a GCC extension\",\n+\t\t\t\t   pfile->directive->name);\n+\t\t    }\n \t\t  pfile->state.skipping = skip;\n \t\t}\n \t    }"}, {"sha": "5a424e2355347bde983ac83e9e61a55092b4980d", "filename": "libcpp/init.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f43eb7707c06e8824d07d5c87ed2019d796fa8a0/libcpp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f43eb7707c06e8824d07d5c87ed2019d796fa8a0/libcpp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finit.c?ref=f43eb7707c06e8824d07d5c87ed2019d796fa8a0", "patch": "@@ -122,8 +122,8 @@ static const struct lang_flags lang_defaults[] =\n   /* CXX17    */  { 1,  1,  1,  1,  1,  0,    1,  1,   1,   1,   1,    1,     1,     0,   1,      0,   1,     0,   0,   0 },\n   /* GNUCXX20 */  { 1,  1,  1,  1,  1,  0,    0,  1,   1,   1,   1,    1,     1,     0,   1,      1,   1,     0,   0,   0 },\n   /* CXX20    */  { 1,  1,  1,  1,  1,  0,    1,  1,   1,   1,   1,    1,     1,     0,   1,      1,   1,     0,   0,   0 },\n-  /* GNUCXX23 */  { 1,  1,  1,  1,  1,  1,    0,  1,   1,   1,   1,    1,     1,     0,   1,      1,   1,     0,   1,   0 },\n-  /* CXX23    */  { 1,  1,  1,  1,  1,  1,    1,  1,   1,   1,   1,    1,     1,     0,   1,      1,   1,     0,   1,   0 },\n+  /* GNUCXX23 */  { 1,  1,  1,  1,  1,  1,    0,  1,   1,   1,   1,    1,     1,     0,   1,      1,   1,     0,   1,   1 },\n+  /* CXX23    */  { 1,  1,  1,  1,  1,  1,    1,  1,   1,   1,   1,    1,     1,     0,   1,      1,   1,     0,   1,   1 },\n   /* ASM      */  { 0,  0,  1,  0,  0,  0,    0,  0,   0,   0,   0,    0,     0,     0,   0,      0,   0,     0,   0,   0 }\n };\n "}]}