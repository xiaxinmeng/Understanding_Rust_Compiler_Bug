{"sha": "2ed5b74848f711b62fb30cfa324377217534411a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVkNWI3NDg0OGY3MTFiNjJmYjMwY2ZhMzI0Mzc3MjE3NTM0NDExYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-07-12T10:24:41Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-07-12T10:24:41Z"}, "message": "[multiple changes]\n\n2012-07-12  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch3.adb (Make_Neq_Body): Fix typo in comment.\n\n2012-07-12  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* tb-gcc.c (trace_callback): On IA-64/HP-UX, use workaround only\n\tif USE_LIBUNWIND_EXCEPTIONS is defined.\n\t* init.c: Further tweaks for IA-64/HP-UX.\n\n2012-07-12  Tristan Gingold  <gingold@adacore.com>\n\n\t* raise-gcc.c: Do not include unwind-dw2-fde.h. Adjust comments.\n\t(db_region_for): Second argument is ip.  Do not recompute ip.\n\t(action_kind): Remove typedef, add unhandler enum const.\n\t(action_descriptor): Adjust type of kind field.\n\t(db_action_for): Second argument is ip, do not recompute it.\n\t(get_call_site_action_for): First argument is call_site, do not\n\trecompute it.  Remove useless return.\n\t(is_handled_by): Now return enum action_kind.\n\tHandle GNAT_ALL_OTHERS first.\n\tReturn unhandler for GNAT_UNHANDLED_OTHERS.\n\t(get_action_description_for): First argument is now ip, do not\n\trecompute it.  Adjust code for call to is_handled_by.\n\t(__gnat_notify_unhandled_exception): Add prototype.\n\t(PERSONALITY_FUNCTION): Call get_ip_from_context.  Adjust calls.\n\tHandle unhandler case.\n\t(__gnat_cleanupunwind_handler): Add comments, add\n\tATTRIBUTE_UNUSED on arguments.\n\t(__gnat_Unwind_RaiseException, __gnat_Unwind_ForcedUnwind): Define\n\tonly once.\n\t* raise.h: Makes struct Exception_Data opaque.\n\nFrom-SVN: r189433", "tree": {"sha": "a039ecea9bedef27b6c20801e0b1666f99a5aa23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a039ecea9bedef27b6c20801e0b1666f99a5aa23"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ed5b74848f711b62fb30cfa324377217534411a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ed5b74848f711b62fb30cfa324377217534411a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ed5b74848f711b62fb30cfa324377217534411a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ed5b74848f711b62fb30cfa324377217534411a/comments", "author": null, "committer": null, "parents": [{"sha": "cd20e505e752c0434869baec3ac4fe7ac55a32b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd20e505e752c0434869baec3ac4fe7ac55a32b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd20e505e752c0434869baec3ac4fe7ac55a32b9"}], "stats": {"total": 228, "additions": 119, "deletions": 109}, "files": [{"sha": "87c66985a2c6b71cb0cc218756c242f1b21e803f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed5b74848f711b62fb30cfa324377217534411a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed5b74848f711b62fb30cfa324377217534411a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2ed5b74848f711b62fb30cfa324377217534411a", "patch": "@@ -1,3 +1,36 @@\n+2012-07-12  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch3.adb (Make_Neq_Body): Fix typo in comment.\n+\n+2012-07-12  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* tb-gcc.c (trace_callback): On IA-64/HP-UX, use workaround only\n+\tif USE_LIBUNWIND_EXCEPTIONS is defined.\n+\t* init.c: Further tweaks for IA-64/HP-UX.\n+\n+2012-07-12  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* raise-gcc.c: Do not include unwind-dw2-fde.h. Adjust comments.\n+\t(db_region_for): Second argument is ip.  Do not recompute ip.\n+\t(action_kind): Remove typedef, add unhandler enum const.\n+\t(action_descriptor): Adjust type of kind field.\n+\t(db_action_for): Second argument is ip, do not recompute it.\n+\t(get_call_site_action_for): First argument is call_site, do not\n+\trecompute it.  Remove useless return.\n+\t(is_handled_by): Now return enum action_kind.\n+\tHandle GNAT_ALL_OTHERS first.\n+\tReturn unhandler for GNAT_UNHANDLED_OTHERS.\n+\t(get_action_description_for): First argument is now ip, do not\n+\trecompute it.  Adjust code for call to is_handled_by.\n+\t(__gnat_notify_unhandled_exception): Add prototype.\n+\t(PERSONALITY_FUNCTION): Call get_ip_from_context.  Adjust calls.\n+\tHandle unhandler case.\n+\t(__gnat_cleanupunwind_handler): Add comments, add\n+\tATTRIBUTE_UNUSED on arguments.\n+\t(__gnat_Unwind_RaiseException, __gnat_Unwind_ForcedUnwind): Define\n+\tonly once.\n+\t* raise.h: Makes struct Exception_Data opaque.\n+\n 2012-07-12  Robert Dewar  <dewar@adacore.com>\n \n \t* make.adb, sem_ch9.adb, prj.adb, s-rident.ads, snames.ads-tmpl: Minor"}, {"sha": "318a2dd5cf7df6abea76c6aba395db0f69bfca21", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed5b74848f711b62fb30cfa324377217534411a/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed5b74848f711b62fb30cfa324377217534411a/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=2ed5b74848f711b62fb30cfa324377217534411a", "patch": "@@ -8204,7 +8204,7 @@ package body Exp_Ch3 is\n       --  otherwise, the inherited or predefined subprogram is called, see\n       --  (RM 8.5.4(8))\n \n-      --  Stage 1: Search for a renaming of the unequality primitive and also\n+      --  Stage 1: Search for a renaming of the inequality primitive and also\n       --  search for an overriding of the equality primitive located before the\n       --  renaming declaration.\n "}, {"sha": "8a27a601617572c16b109c1afa09dd7b80690c94", "filename": "gcc/ada/init.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed5b74848f711b62fb30cfa324377217534411a/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed5b74848f711b62fb30cfa324377217534411a/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=2ed5b74848f711b62fb30cfa324377217534411a", "patch": "@@ -304,8 +304,10 @@ __gnat_install_handler (void)\n #include <signal.h>\n #include <sys/ucontext.h>\n \n-#if defined(__ia64__)\n+#if defined (IN_RTS) && defined (__ia64__)\n+\n #include <sys/uc_access.h>\n+\n #define HAVE_GNAT_ADJUST_CONTEXT_FOR_RAISE\n \n void\n@@ -318,7 +320,7 @@ __gnat_adjust_context_for_raise (int signo ATTRIBUTE_UNUSED, void *ucontext)\n   __uc_get_ip (uc, &ip);\n   __uc_set_ip (uc, ip + 1);\n }\n-#endif /* __ia64__ */\n+#endif /* IN_RTS && __ia64__ */\n \n /* Tasking and Non-tasking signal handler.  Map SIGnal to Ada exception\n    propagation after the required low level adjustments.  */\n@@ -331,9 +333,7 @@ __gnat_error_handler (int sig,\n   struct Exception_Data *exception;\n   const char *msg;\n \n-#if defined(__ia64__)\n   __gnat_adjust_context_for_raise (sig, ucontext);\n-#endif\n \n   switch (sig)\n     {"}, {"sha": "c46108c762061311219a2d371ebdecb094463779", "filename": "gcc/ada/raise-gcc.c", "status": "modified", "additions": 77, "deletions": 91, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed5b74848f711b62fb30cfa324377217534411a/gcc%2Fada%2Fraise-gcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed5b74848f711b62fb30cfa324377217534411a/gcc%2Fada%2Fraise-gcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise-gcc.c?ref=2ed5b74848f711b62fb30cfa324377217534411a", "patch": "@@ -81,7 +81,6 @@ extern void __gnat_setup_current_excep (_Unwind_Exception *);\n extern void __gnat_unhandled_except_handler (_Unwind_Exception *);\n \n #include \"dwarf2.h\"\n-#include \"unwind-dw2-fde.h\"\n #include \"unwind-pe.h\"\n \n /* The known and handled exception classes.  */\n@@ -426,7 +425,7 @@ db_phases (int phases)\n \t   |\n \t   +--> get_region_description_for (context)\n \t   |\n-\t   +--> get_action_description_for (context, exception, region)\n+\t   +--> get_action_description_for (ip, exception, region)\n \t   |       |\n \t   |       +--> get_call_site_action_for (context, region)\n \t   |            (one version for each underlying scheme)\n@@ -514,15 +513,11 @@ get_ip_from_context (_Unwind_Context *uw_context)\n }\n \n static void\n-db_region_for (region_descriptor *region, _Unwind_Context *uw_context)\n+db_region_for (region_descriptor *region, _Unwind_Ptr ip)\n {\n-  _Unwind_Ptr ip;\n-\n   if (! (db_accepted_codes () & DB_REGIONS))\n     return;\n \n-  ip = get_ip_from_context (uw_context);\n-\n   db (DB_REGIONS, \"For ip @ %p => \", (void *)ip);\n \n   if (region->lsda)\n@@ -607,7 +602,7 @@ get_region_description_for (_Unwind_Context *uw_context,\n /* Describe an action to be taken when propagating an exception up to\n    some context.  */\n \n-typedef enum\n+enum action_kind\n {\n   /* Found some call site base data, but need to analyze further\n      before being able to decide.  */\n@@ -620,16 +615,20 @@ typedef enum\n   cleanup,\n \n   /* There is a handler for the exception in this context.  */\n-  handler\n-} action_kind;\n+  handler,\n+\n+  /* There is a handler for the exception, but it is only for catching\n+     unhandled exceptions.  */\n+  unhandler\n+};\n \n /* filter value for cleanup actions.  */\n static const int cleanup_filter = 0;\n \n typedef struct\n {\n   /* The kind of action to be taken.  */\n-  action_kind kind;\n+  enum action_kind kind;\n \n   /* A pointer to the action record entry.  */\n   const unsigned char *table_entry;\n@@ -645,10 +644,8 @@ typedef struct\n } action_descriptor;\n \n static void\n-db_action_for (action_descriptor *action, _Unwind_Context *uw_context)\n+db_action_for (action_descriptor *action, _Unwind_Ptr ip)\n {\n-  _Unwind_Ptr ip = get_ip_from_context (uw_context);\n-\n   db (DB_ACTIONS, \"For ip @ %p => \", (void *)ip);\n \n   switch (action->kind)\n@@ -691,12 +688,10 @@ db_action_for (action_descriptor *action, _Unwind_Context *uw_context)\n #define __builtin_eh_return_data_regno(x) x\n \n static void\n-get_call_site_action_for (_Unwind_Context *uw_context,\n+get_call_site_action_for (_Unwind_Ptr call_site,\n                           region_descriptor *region,\n                           action_descriptor *action)\n {\n-  _Unwind_Ptr call_site = get_ip_from_context (uw_context);\n-\n   /* call_site is a direct index into the call-site table, with two special\n      values : -1 for no-action and 0 for \"terminate\".  The latter should never\n      show up for Ada.  To test for the former, beware that _Unwind_Ptr might\n@@ -705,17 +700,16 @@ get_call_site_action_for (_Unwind_Context *uw_context,\n   if ((int)call_site < 0)\n     {\n       action->kind = nothing;\n-      return;\n     }\n   else if (call_site == 0)\n     {\n       db (DB_ERR, \"========> Err, null call_site for Ada/sjlj\\n\");\n       action->kind = nothing;\n-      return;\n     }\n   else\n     {\n       _uleb128_t cs_lp, cs_action;\n+      const unsigned char *p = region->call_site_table;\n \n       /* Let the caller know there may be an action to take, but let it\n \t determine the kind.  */\n@@ -725,34 +719,31 @@ get_call_site_action_for (_Unwind_Context *uw_context,\n \t made of leb128 values, the encoding length of which is variable.  We\n \t can't merely compute an offset from the index, then, but have to read\n \t all the entries before the one of interest.  */\n-\n-      const unsigned char *p = region->call_site_table;\n-\n-      do {\n-\tp = read_uleb128 (p, &cs_lp);\n-\tp = read_uleb128 (p, &cs_action);\n-      } while (--call_site);\n+      p = region->call_site_table;\n+      do\n+\t{\n+\t  p = read_uleb128 (p, &cs_lp);\n+\t  p = read_uleb128 (p, &cs_action);\n+\t}\n+      while (--call_site);\n \n       action->landing_pad = cs_lp + 1;\n \n       if (cs_action)\n \taction->table_entry = region->action_table + cs_action - 1;\n       else\n \taction->table_entry = 0;\n-\n-      return;\n     }\n }\n \n #else /* !__USING_SJLJ_EXCEPTIONS__  */\n \n static void\n-get_call_site_action_for (_Unwind_Context *uw_context,\n+get_call_site_action_for (_Unwind_Ptr ip,\n                           region_descriptor *region,\n                           action_descriptor *action)\n {\n   const unsigned char *p = region->call_site_table;\n-  _Unwind_Ptr ip = get_ip_from_context (uw_context);\n \n   /* Unless we are able to determine otherwise...  */\n   action->kind = nothing;\n@@ -824,24 +815,28 @@ extern Exception_Code Import_Code_For (_Unwind_Ptr eid);\n \n extern Exception_Id EID_For (_GNAT_Exception * e);\n \n-static int\n+static enum action_kind\n is_handled_by (_Unwind_Ptr choice, _GNAT_Exception * propagated_exception)\n {\n+  if (choice == GNAT_ALL_OTHERS)\n+    return handler;\n+\n   if (propagated_exception->common.exception_class == GNAT_EXCEPTION_CLASS)\n     {\n       /* Pointer to the GNAT exception data corresponding to the propagated\n          occurrence.  */\n       _Unwind_Ptr E = (_Unwind_Ptr) EID_For (propagated_exception);\n \n+      if (choice == GNAT_UNHANDLED_OTHERS)\n+\treturn unhandler;\n+\n+      E = (_Unwind_Ptr) EID_For (propagated_exception);\n+\n       /* Base matching rules: An exception data (id) matches itself, \"when\n          all_others\" matches anything and \"when others\" matches anything\n          unless explicitly stated otherwise in the propagated occurrence.  */\n-\n-      bool is_handled =\n-        choice == E\n-        || (choice == GNAT_OTHERS && Is_Handled_By_Others (E))\n-        || choice == GNAT_ALL_OTHERS\n-        || choice == GNAT_UNHANDLED_OTHERS;\n+      if (choice == E || (choice == GNAT_OTHERS && Is_Handled_By_Others (E)))\n+\treturn handler;\n \n       /* In addition, on OpenVMS, Non_Ada_Error matches VMS exceptions, and we\n          may have different exception data pointers that should match for the\n@@ -854,43 +849,44 @@ is_handled_by (_Unwind_Ptr choice, _GNAT_Exception * propagated_exception)\n #     define Non_Ada_Error system__aux_dec__non_ada_error\n       extern struct Exception_Data Non_Ada_Error;\n \n-      is_handled |=\n-        (Language_For (E) == 'V'\n-         && choice != GNAT_OTHERS && choice != GNAT_ALL_OTHERS\n-         && ((Language_For (choice) == 'V' && Import_Code_For (choice) != 0\n-              && Import_Code_For (choice) == Import_Code_For (E))\n-             || choice == (_Unwind_Ptr)&Non_Ada_Error));\n+      if ((Language_For (E) == 'V'\n+\t   && choice != GNAT_OTHERS\n+\t   && ((Language_For (choice) == 'V'\n+\t\t&& Import_Code_For (choice) != 0\n+\t\t&& Import_Code_For (choice) == Import_Code_For (E))\n+\t       || choice == (_Unwind_Ptr)&Non_Ada_Error)))\n+\treturn handler;\n #endif\n-\n-      return is_handled;\n     }\n   else\n     {\n-#     define Foreign_Exception system__exceptions__foreign_exception;\n+#     define Foreign_Exception system__exceptions__foreign_exception\n       extern struct Exception_Data Foreign_Exception;\n \n-      return choice == GNAT_ALL_OTHERS\n-        || choice == GNAT_OTHERS\n-        || choice == (_Unwind_Ptr)&Foreign_Exception;\n+      if (choice == GNAT_ALL_OTHERS\n+\t  || choice == GNAT_OTHERS\n+\t  || choice == (_Unwind_Ptr) &Foreign_Exception)\n+\treturn handler;\n     }\n+  return nothing;\n }\n \n /* Fill out the ACTION to be taken from propagating UW_EXCEPTION up to\n    UW_CONTEXT in REGION.  */\n \n static void\n-get_action_description_for (_Unwind_Context *uw_context,\n+get_action_description_for (_Unwind_Ptr ip,\n                             _Unwind_Exception *uw_exception,\n                             _Unwind_Action uw_phase,\n                             region_descriptor *region,\n                             action_descriptor *action)\n {\n-  _GNAT_Exception * gnat_exception = (_GNAT_Exception *) uw_exception;\n+  _GNAT_Exception *gnat_exception = (_GNAT_Exception *) uw_exception;\n \n   /* Search the call site table first, which may get us a landing pad as well\n      as the head of an action record list.  */\n-  get_call_site_action_for (uw_context, region, action);\n-  db_action_for (action, uw_context);\n+  get_call_site_action_for (ip, region, action);\n+  db_action_for (action, ip);\n \n   /* If there is not even a call_site entry, we are done.  */\n   if (action->kind == nothing)\n@@ -954,9 +950,9 @@ get_action_description_for (_Unwind_Context *uw_context,\n                      matches the one we are propagating.  */\n                   _Unwind_Ptr choice = get_ttype_entry_for (region, ar_filter);\n \n-                  if (is_handled_by (choice, gnat_exception))\n+\t\t  action->kind = is_handled_by (choice, gnat_exception);\n+                  if (action->kind != nothing)\n                     {\n-                      action->kind = handler;\n                       action->ttype_filter = ar_filter;\n                       return;\n                     }\n@@ -1006,6 +1002,7 @@ setup_to_install (_Unwind_Context *uw_context,\n    automatic backtraces upon exception raise, as provided through the\n    GNAT.Traceback facilities.  */\n extern void __gnat_notify_handled_exception (void);\n+extern void __gnat_notify_unhandled_exception (void);\n \n /* Below is the eh personality routine per se. We currently assume that only\n    GNU-Ada exceptions are met.  */\n@@ -1072,6 +1069,7 @@ PERSONALITY_FUNCTION (version_arg_t version_arg,\n   _Unwind_Action uw_phases = (_Unwind_Action) phases_arg;\n   region_descriptor region;\n   action_descriptor action;\n+  _Unwind_Ptr ip;\n \n   /* Check that we're called from the ABI context we expect, with a major\n      possible variation on VMS for IA64.  */\n@@ -1104,17 +1102,17 @@ PERSONALITY_FUNCTION (version_arg_t version_arg,\n      will tell us if there is some lsda, call_site, action and/or ttype data\n      for the associated ip.  */\n   get_region_description_for (uw_context, &region);\n-  db_region_for (&region, uw_context);\n+  ip = get_ip_from_context (uw_context);\n+  db_region_for (&region, ip);\n \n   /* No LSDA => no handlers or cleanups => we shall unwind further up.  */\n   if (! region.lsda)\n     return _URC_CONTINUE_UNWIND;\n \n   /* Search the call-site and action-record tables for the action associated\n      with this IP.  */\n-  get_action_description_for (uw_context, uw_exception, uw_phases,\n-                              &region, &action);\n-  db_action_for (&action, uw_context);\n+  get_action_description_for (ip, uw_exception, uw_phases, &region, &action);\n+  db_action_for (&action, ip);\n \n   /* Whatever the phase, if there is nothing relevant in this frame,\n      unwinding should just go on.  */\n@@ -1137,7 +1135,10 @@ PERSONALITY_FUNCTION (version_arg_t version_arg,\n \t     phase starts, which ensures the stack is still intact.\n              First, setup the Ada occurrence.  */\n           __gnat_setup_current_excep (uw_exception);\n-\t  __gnat_notify_handled_exception ();\n+\t  if (action.kind == unhandler)\n+\t    __gnat_notify_unhandled_exception ();\n+\t  else\n+\t    __gnat_notify_handled_exception ();\n \n \t  return _URC_HANDLER_FOUND;\n \t}\n@@ -1157,13 +1158,16 @@ PERSONALITY_FUNCTION (version_arg_t version_arg,\n   return _URC_INSTALL_CONTEXT;\n }\n \n+/* Callback routine called by Unwind_ForcedUnwind to execute all the cleanup\n+   before exiting the task.  */\n+\n _Unwind_Reason_Code\n-__gnat_cleanupunwind_handler (int version,\n+__gnat_cleanupunwind_handler (int version ATTRIBUTE_UNUSED,\n \t\t\t      _Unwind_Action phases,\n-\t\t\t      _Unwind_Exception_Class eclass,\n+\t\t\t      _Unwind_Exception_Class eclass ATTRIBUTE_UNUSED,\n \t\t\t      struct _Unwind_Exception *exception,\n-\t\t\t      struct _Unwind_Context *context,\n-\t\t\t      void *arg)\n+\t\t\t      struct _Unwind_Context *context ATTRIBUTE_UNUSED,\n+\t\t\t      void *arg ATTRIBUTE_UNUSED)\n {\n   /* Terminate when the end of the stack is reached.  */\n   if ((phases & _UA_END_OF_STACK) != 0\n@@ -1184,46 +1188,28 @@ __gnat_cleanupunwind_handler (int version,\n \n /* Define the consistently named wrappers imported by Propagate_Exception.  */\n \n-#ifdef __USING_SJLJ_EXCEPTIONS__\n-\n-#undef _Unwind_RaiseException\n-\n _Unwind_Reason_Code\n __gnat_Unwind_RaiseException (_Unwind_Exception *e)\n {\n+#ifdef __USING_SJLJ_EXCEPTIONS__\n   return _Unwind_SjLj_RaiseException (e);\n-}\n-\n-\n-#undef _Unwind_ForcedUnwind\n-\n-_Unwind_Reason_Code\n-__gnat_Unwind_ForcedUnwind (_Unwind_Exception *e,\n-                            void * handler,\n-                            void * argument)\n-{\n-  return _Unwind_SjLj_ForcedUnwind (e, handler, argument);\n-}\n-\n-\n-#else /* __USING_SJLJ_EXCEPTIONS__ */\n-\n-_Unwind_Reason_Code\n-__gnat_Unwind_RaiseException (_Unwind_Exception *e)\n-{\n+#else\n   return _Unwind_RaiseException (e);\n+#endif\n }\n \n _Unwind_Reason_Code\n __gnat_Unwind_ForcedUnwind (_Unwind_Exception *e,\n-                            void * handler,\n-                            void * argument)\n+\t\t\t    void *handler,\n+\t\t\t    void *argument)\n {\n+#ifdef __USING_SJLJ_EXCEPTIONS__\n+  return _Unwind_SjLj_ForcedUnwind (e, handler, argument);\n+#else\n   return _Unwind_ForcedUnwind (e, handler, argument);\n+#endif\n }\n \n-#endif /* __USING_SJLJ_EXCEPTIONS__ */\n-\n #ifdef __SEH__\n \n #define STATUS_USER_DEFINED\t\t(1U << 29)"}, {"sha": "1c4eb36e9c67ed98caa67c02f9e78e9b638b6f63", "filename": "gcc/ada/raise.h", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed5b74848f711b62fb30cfa324377217534411a/gcc%2Fada%2Fraise.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed5b74848f711b62fb30cfa324377217534411a/gcc%2Fada%2Fraise.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise.h?ref=2ed5b74848f711b62fb30cfa324377217534411a", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2011, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2012, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -37,16 +37,7 @@ extern \"C\" {\n \n typedef unsigned Exception_Code;\n \n-struct Exception_Data\n-{\n-  char Not_Handled_By_Others;\n-  char Lang;\n-  int Name_Length;\n-  char *Full_Name, *Htable_Ptr;\n-  Exception_Code Import_Code;\n-  void (*Raise_Hook)(void);\n-};\n-\n+struct Exception_Data;\n typedef struct Exception_Data *Exception_Id;\n \n extern void _gnat_builtin_longjmp\t(void *, int);"}, {"sha": "737f29a479b0cc3b477c7b8fff772b812b1992c5", "filename": "gcc/ada/tb-gcc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed5b74848f711b62fb30cfa324377217534411a/gcc%2Fada%2Ftb-gcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed5b74848f711b62fb30cfa324377217534411a/gcc%2Fada%2Ftb-gcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftb-gcc.c?ref=2ed5b74848f711b62fb30cfa324377217534411a", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 2004-2011, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 2004-2012, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -64,7 +64,7 @@ trace_callback (struct _Unwind_Context * uw_context, uw_data_t * uw_data)\n {\n   char * pc;\n \n-#if defined (__ia64__) && defined (__hpux__)\n+#if defined (__ia64__) && defined (__hpux__) && defined (USE_LIBUNWIND_EXCEPTIONS)\n   /* Work around problem with _Unwind_GetIP on ia64 HP-UX. */\n   uwx_get_reg ((struct uwx_env *) uw_context, UWX_REG_IP, (uint64_t *) &pc);\n #else"}]}