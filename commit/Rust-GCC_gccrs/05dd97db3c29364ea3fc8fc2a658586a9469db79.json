{"sha": "05dd97db3c29364ea3fc8fc2a658586a9469db79", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDVkZDk3ZGIzYzI5MzY0ZWEzZmM4ZmMyYTY1ODU4NmE5NDY5ZGI3OQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2016-02-04T04:50:42Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2016-02-04T04:50:42Z"}, "message": "PR c++/69251 - [6 Regression] ICE in unify_array_domain on a flexible array\n\nPR c++/69251 - [6 Regression] ICE in unify_array_domain on a flexible array\n               member\nPR c++/69253 - [6 Regression] ICE in cxx_incomplete_type_diagnostic initializing\n               a flexible array member with empty string\nPR c++/69290 - [6 Regression] ICE on invalid initialization of a flexible array\n               member\nPR c++/69277 - [6 Regression] ICE mangling a flexible array member\nPR c++/69349 - template substitution error for flexible array members\n\ngcc/testsuite/ChangeLog:\n2016-02-03  Martin Sebor  <msebor@redhat.com>\n\n\tPR c++/69251\n\tPR c++/69253\n\tPR c++/69290\n\tPR c++/69277\n\tPR c++/69349\n\t* g++.dg/ext/flexarray-mangle-2.C: New test.\n\t* g++.dg/ext/flexarray-mangle.C: New test.\n\t* g++.dg/ext/flexarray-subst.C: New test.\n\t* g++.dg/ext/flexary11.C: New test.\n\t* g++.dg/ext/flexary12.C: New test.\n\t* g++.dg/ext/flexary13.C: New test.\n\t* g++.dg/ext/flexary14.C: New test.\n\t* g++.dg/other/dump-ada-spec-2.C: Adjust.\n\ngcc/cp/ChangeLog:\n2016-02-03  Martain Sebor  <msebor@redhat.com>\n\n\tPR c++/69251\n\tPR c++/69253\n\tPR c++/69290\n\tPR c++/69277\n\tPR c++/69349\n\t* class.c (walk_subobject_offsets): Avoid testing the upper bound\n\tof a flexible array member for equality to null.\n\t(find_flexarrays): Remove spurious whitespace introduced in r231665.\n\t(diagnose_flexarrays): Avoid checking the upper bound of arrays.\n\t(check_flexarrays): Same.\n\t* decl.c (compute_array_index_type): Avoid special case for flexible\n\tarray members.\n\t(grokdeclarator): Avoid calling compute_array_index_type for flexible\n\tarray members.\n\t* error.c (dump_type_suffix): Revert changes introduced in r231665\n\tand rendered unnecessary by the changes above.\n\t* pt.c (tsubst):  Same.\n\t* tree.c (build_ctor_subob_ref): Handle flexible array members.\n\t* typeck2.c (digest_init_r): Revert changes introduced in r231665.\n\t(process_init_constructor_array): Same.\n\t(process_init_constructor_record): Same.\n\nFrom-SVN: r233126", "tree": {"sha": "c95b5fda5f7341a303dd2415b1a7bb2caabcd8b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c95b5fda5f7341a303dd2415b1a7bb2caabcd8b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05dd97db3c29364ea3fc8fc2a658586a9469db79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05dd97db3c29364ea3fc8fc2a658586a9469db79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05dd97db3c29364ea3fc8fc2a658586a9469db79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05dd97db3c29364ea3fc8fc2a658586a9469db79/comments", "author": null, "committer": null, "parents": [{"sha": "dac2fc29181a6905dd5a61f1582cf946b3424ca7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dac2fc29181a6905dd5a61f1582cf946b3424ca7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dac2fc29181a6905dd5a61f1582cf946b3424ca7"}], "stats": {"total": 451, "additions": 375, "deletions": 76}, "files": [{"sha": "c8ccf405d841117d833405213ed86840cb19ccf4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=05dd97db3c29364ea3fc8fc2a658586a9469db79", "patch": "@@ -1,3 +1,27 @@\n+2016-02-02  Martain Sebor  <msebor@redhat.com>\n+\n+\tPR c++/69251\n+\tPR c++/69253\n+\tPR c++/69290\n+\tPR c++/69277\n+\tPR c++/69349\n+\t* class.c (walk_subobject_offsets): Avoid testing the upper bound\n+\tof a flexible array member for equality to null.\n+\t(find_flexarrays): Remove spurious whitespace introduced in r231665.\n+\t(diagnose_flexarrays): Avoid checking the upper bound of arrays.\n+\t(check_flexarrays): Same.\n+\t* decl.c (compute_array_index_type): Avoid special case for flexible\n+\tarray members.\n+\t(grokdeclarator): Avoid calling compute_array_index_type for flexible\n+\tarray members.\n+\t* error.c (dump_type_suffix): Revert changes introduced in r231665\n+\tand rendered unnecessary by the changes above.\n+\t* pt.c (tsubst):  Same.\n+\t* tree.c (build_ctor_subob_ref): Handle flexible array members.\n+\t* typeck2.c (digest_init_r): Revert changes introduced in r231665.\n+\t(process_init_constructor_array): Same.\n+\t(process_init_constructor_record): Same.\n+\n 2016-02-03  Patrick Palka  <ppalka@gcc.gnu.org>\n \n \tPR c++/69056"}, {"sha": "67b3f81de25729f7edc7bf007032a94d816433dc", "filename": "gcc/cp/class.c", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=05dd97db3c29364ea3fc8fc2a658586a9469db79", "patch": "@@ -4120,9 +4120,7 @@ walk_subobject_offsets (tree type,\n       /* Avoid recursing into objects that are not interesting.  */\n       if (!CLASS_TYPE_P (element_type)\n \t  || !CLASSTYPE_CONTAINS_EMPTY_CLASS_P (element_type)\n-\t  || !domain\n-\t  /* Flexible array members have no upper bound.  */\n-\t  || !TYPE_MAX_VALUE (domain))\n+\t  || !domain)\n \treturn 0;\n \n       /* Step through each of the elements in the array.  */\n@@ -6645,7 +6643,7 @@ find_flexarrays (tree t, flexmems_t *fmem)\n       for (next = fld;\n \t   (next = DECL_CHAIN (next))\n \t     && TREE_CODE (next) != FIELD_DECL; );\n-      \n+\n       tree fldtype = TREE_TYPE (fld);\n       if (TREE_CODE (fld) != TYPE_DECL\n \t  && RECORD_OR_UNION_TYPE_P (fldtype)\n@@ -6672,22 +6670,20 @@ find_flexarrays (tree t, flexmems_t *fmem)\n \t  /* Remember the first non-static data member.  */\n \t  if (!fmem->first)\n \t    fmem->first = fld;\n-\t  \n+\n \t  /* Remember the first non-static data member after the flexible\n \t     array member, if one has been found, or the zero-length array\n \t     if it has been found.  */\n \t  if (!fmem->after && fmem->array)\n \t    fmem->after = fld;\n \t}\n-\t    \n+\n       /* Skip non-arrays.  */\n       if (TREE_CODE (fldtype) != ARRAY_TYPE)\n \tcontinue;\n \n       /* Determine the upper bound of the array if it has one.  */\n-      tree dom = TYPE_DOMAIN (fldtype);\n-\n-      if (dom && TYPE_MAX_VALUE (dom))\n+      if (tree dom = TYPE_DOMAIN (fldtype))\n \t{\n \t  if (fmem->array)\n \t    {\n@@ -6710,14 +6706,13 @@ find_flexarrays (tree t, flexmems_t *fmem)\n \t    {\n \t      /* Replace the zero-length array if it's been stored and\n \t\t reset the after pointer.  */\n-\t      dom = TYPE_DOMAIN (TREE_TYPE (fmem->array));\n-\t      if (dom && TYPE_MAX_VALUE (dom))\n+\t      if (TYPE_DOMAIN (TREE_TYPE (fmem->array)))\n \t\t{\n \t\t  fmem->array = fld;\n \t\t  fmem->after = NULL_TREE;\n \t\t}\n \t    }\n-\t  else\t\n+\t  else\n \t    fmem->array = fld;\n \t}\n     }\n@@ -6737,8 +6732,7 @@ diagnose_flexarrays (tree t, const flexmems_t *fmem)\n \n   const char *msg = 0;\n \n-  const_tree dom = TYPE_DOMAIN (TREE_TYPE (fmem->array));\n-  if (dom && TYPE_MAX_VALUE (dom))\n+  if (const_tree dom = TYPE_DOMAIN (TREE_TYPE (fmem->array)))\n     {\n       if (fmem->after)\n \tmsg = G_(\"zero-size array member %qD not at end of %q#T\");\n@@ -6770,7 +6764,7 @@ diagnose_flexarrays (tree t, const flexmems_t *fmem)\n \t      inform (DECL_SOURCE_LOCATION (fmem->after),\n \t\t      \"next member %q#D declared here\",\n \t\t      fmem->after);\n-\t  \n+\n \t  inform (location_of (t), \"in the definition of %q#T\", t);\n \t}\n     }\n@@ -6844,7 +6838,7 @@ check_flexarrays (tree t, flexmems_t *fmem /* = NULL */)\n   find_flexarrays (t, fmem);\n \n   if (fmem == &flexmems)\n-    { \n+    {\n       /* Issue diagnostics for invalid flexible and zero-length array members\n \t found in base classes or among the members of the current class.  */\n       diagnose_flexarrays (t, fmem);"}, {"sha": "2c337bc3d188cdae6f99dfe9fe2bf5718f6a02d8", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=05dd97db3c29364ea3fc8fc2a658586a9469db79", "patch": "@@ -8645,20 +8645,16 @@ fold_sizeof_expr (tree t)\n   return r;\n }\n \n-/* Given the SIZE (i.e., number of elements) in an array, compute an\n-   appropriate index type for the array.  When SIZE is null, the array\n-   is a flexible array member.  If non-NULL, NAME is the name of\n-   the entity being declared.  */\n+/* Given the SIZE (i.e., number of elements) in an array, compute\n+   an appropriate index type for the array.  If non-NULL, NAME is\n+   the name of the entity being declared.  */\n \n tree\n compute_array_index_type (tree name, tree size, tsubst_flags_t complain)\n {\n   tree itype;\n   tree osize = size;\n \n-  if (size == NULL_TREE)\n-    return build_index_type (NULL_TREE);\n-\n   if (error_operand_p (size))\n     return error_mark_node;\n \n@@ -10967,11 +10963,10 @@ grokdeclarator (const cp_declarator *declarator,\n \t\terror (\"flexible array member in union\");\n \t\ttype = error_mark_node;\n \t      }\n-\t    else\n+\t    else \n \t      {\n-\t\ttree itype = compute_array_index_type (dname, NULL_TREE,\n-\t\t\t\t\t\t       tf_warning_or_error);\n-\t\ttype = build_cplus_array_type (TREE_TYPE (type), itype);\n+\t\t/* Flexible array member has a null domain.  */\n+\t\ttype = build_cplus_array_type (TREE_TYPE (type), NULL_TREE);\n \t      }\n \t  }\n "}, {"sha": "3f9cf4a793f93dfaf4663a72a0d840c3a3ff057b", "filename": "gcc/cp/error.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=05dd97db3c29364ea3fc8fc2a658586a9469db79", "patch": "@@ -875,10 +875,10 @@ dump_type_suffix (cxx_pretty_printer *pp, tree t, int flags)\n     case ARRAY_TYPE:\n       pp_maybe_space (pp);\n       pp_cxx_left_bracket (pp);\n-      if (TYPE_DOMAIN (t) && TYPE_MAX_VALUE (TYPE_DOMAIN (t)))\n+      if (tree dtype = TYPE_DOMAIN (t))\n \t{\n-\t  tree dtype = TYPE_DOMAIN (t);\n \t  tree max = TYPE_MAX_VALUE (dtype);\n+\t  /* Zero-length arrays have an upper bound of SIZE_MAX.  */\n \t  if (integer_all_onesp (max))\n \t    pp_character (pp, '0');\n \t  else if (tree_fits_shwi_p (max))"}, {"sha": "410c7f46dcab45d1bff1954350ac9afdb483170a", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=05dd97db3c29364ea3fc8fc2a658586a9469db79", "patch": "@@ -3280,8 +3280,10 @@ write_template_template_arg (const tree decl)\n \t\t  ::= A <expression> _ </element/ type>\n \n      \"Array types encode the dimension (number of elements) and the\n-     element type. For variable length arrays, the dimension (but not\n-     the '_' separator) is omitted.\"  */\n+     element type.  For variable length arrays, the dimension (but not\n+     the '_' separator) is omitted.\"\n+     Note that for flexible array members, like for other arrays of\n+     unspecified size, the dimension is also omitted.  */\n \n static void\n write_array_type (const tree type)\n@@ -3290,29 +3292,31 @@ write_array_type (const tree type)\n   if (TYPE_DOMAIN (type))\n     {\n       tree index_type;\n-      tree max;\n \n       index_type = TYPE_DOMAIN (type);\n-      /* The INDEX_TYPE gives the upper and lower bounds of the\n-\t array.  */\n-      max = TYPE_MAX_VALUE (index_type);\n-      if (TREE_CODE (max) == INTEGER_CST)\n+      /* The INDEX_TYPE gives the upper and lower bounds of the array.\n+\t It's null for flexible array members which have no upper bound\n+\t (this is a change from GCC 5 and prior where such members were\n+\t incorrectly mangled as zero-length arrays).  */\n+      if (tree max = TYPE_MAX_VALUE (index_type))\n \t{\n-\t  /* The ABI specifies that we should mangle the number of\n-\t     elements in the array, not the largest allowed index.  */\n-\t  offset_int wmax = wi::to_offset (max) + 1;\n-\t  /* Truncate the result - this will mangle [0, SIZE_INT_MAX]\n-\t     number of elements as zero.  */\n-\t  wmax = wi::zext (wmax, TYPE_PRECISION (TREE_TYPE (max)));\n-\t  gcc_assert (wi::fits_uhwi_p (wmax));\n-\t  write_unsigned_number (wmax.to_uhwi ());\n-\t}\n-      else\n-\t{\n-\t  max = TREE_OPERAND (max, 0);\n-\t  write_expression (max);\n+\t  if (TREE_CODE (max) == INTEGER_CST)\n+\t    {\n+\t      /* The ABI specifies that we should mangle the number of\n+\t\t elements in the array, not the largest allowed index.  */\n+\t      offset_int wmax = wi::to_offset (max) + 1;\n+\t      /* Truncate the result - this will mangle [0, SIZE_INT_MAX]\n+\t\t number of elements as zero.  */\n+\t      wmax = wi::zext (wmax, TYPE_PRECISION (TREE_TYPE (max)));\n+\t      gcc_assert (wi::fits_uhwi_p (wmax));\n+\t      write_unsigned_number (wmax.to_uhwi ());\n+\t    }\n+\t  else\n+\t    {\n+\t      max = TREE_OPERAND (max, 0);\n+\t      write_expression (max);\n+\t    }\n \t}\n-\n     }\n   write_char ('_');\n   write_type (TREE_TYPE (type));"}, {"sha": "e7ce74c6c05239dabb55067488a353262e7ea4f1", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=05dd97db3c29364ea3fc8fc2a658586a9469db79", "patch": "@@ -12846,14 +12846,9 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       if (t == integer_type_node)\n \treturn t;\n \n-      if (TREE_CODE (TYPE_MIN_VALUE (t)) == INTEGER_CST)\n-        {\n-          if (!TYPE_MAX_VALUE (t))\n-            return compute_array_index_type (NULL_TREE, NULL_TREE, complain);\n-          \n-          if (TREE_CODE (TYPE_MAX_VALUE (t)) == INTEGER_CST)\n-            return t;\n-        }\n+      if (TREE_CODE (TYPE_MIN_VALUE (t)) == INTEGER_CST\n+          && TREE_CODE (TYPE_MAX_VALUE (t)) == INTEGER_CST)\n+        return t;\n \n       {\n \ttree max, omax = TREE_OPERAND (TYPE_MAX_VALUE (t), 0);"}, {"sha": "3203acaff9e94f6d6c23a4f8390b82764ef5158e", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=05dd97db3c29364ea3fc8fc2a658586a9469db79", "patch": "@@ -2586,8 +2586,19 @@ build_ctor_subob_ref (tree index, tree type, tree obj)\n     obj = build_class_member_access_expr (obj, index, NULL_TREE,\n \t\t\t\t\t  /*reference*/false, tf_none);\n   if (obj)\n-    gcc_assert (same_type_ignoring_top_level_qualifiers_p (type,\n-\t\t\t\t\t\t\t   TREE_TYPE (obj)));\n+    {\n+      tree objtype = TREE_TYPE (obj);\n+      if (TREE_CODE (objtype) == ARRAY_TYPE && !TYPE_DOMAIN (objtype))\n+\t{\n+\t  /* When the destination object refers to a flexible array member\n+\t     verify that it matches the type of the source object except\n+\t     for its domain.  */\n+\t  gcc_assert (comptypes (type, objtype, COMPARE_REDECLARATION));\n+\t}\n+      else\n+\tgcc_assert (same_type_ignoring_top_level_qualifiers_p (type, objtype));\n+    }\n+\n   return obj;\n }\n "}, {"sha": "419faa2655e55960a484537723bb40ae2aa4f423", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=05dd97db3c29364ea3fc8fc2a658586a9469db79", "patch": "@@ -1015,14 +1015,13 @@ digest_init_r (tree type, tree init, bool nested, int flags,\n      them if they were present.  */\n   if (code == ARRAY_TYPE)\n     {\n-      if (nested\n-\t  && (!TYPE_DOMAIN (type) || !TYPE_MAX_VALUE (TYPE_DOMAIN (type))))\n+      if (nested && !TYPE_DOMAIN (type))\n \t{\n-\t  /* Flexible array members do not have an upper bound.  */\n+\t  /* C++ flexible array members have a null domain.  */\n \t  pedwarn (EXPR_LOC_OR_LOC (init, input_location), OPT_Wpedantic,\n \t\t   \"initialization of a flexible array member\");\n \t}\n-      \n+\n       tree typ1 = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n       if (char_type_p (typ1)\n \t  /*&& init */\n@@ -1061,9 +1060,7 @@ digest_init_r (tree type, tree init, bool nested, int flags,\n \t      init = copy_node (init);\n \t      TREE_TYPE (init) = type;\n \t    }\n-\t  if (TYPE_DOMAIN (type)\n-\t      && TYPE_MAX_VALUE (TYPE_DOMAIN (type))\n-\t      && TREE_CONSTANT (TYPE_SIZE (type)))\n+\t  if (TYPE_DOMAIN (type) && TREE_CONSTANT (TYPE_SIZE (type)))\n \t    {\n \t      /* Not a flexible array member.  */\n \t      int size = TREE_INT_CST_LOW (TYPE_SIZE (type));\n@@ -1252,12 +1249,11 @@ process_init_constructor_array (tree type, tree init,\n \n   if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n+      /* C++ flexible array members have a null domain.  */\n       tree domain = TYPE_DOMAIN (type);\n-      /* Flexible array members have no upper bound.  */\n-      tree maxval = domain ? TYPE_MAX_VALUE (domain) : NULL_TREE;\n-      if (domain && maxval && TREE_CONSTANT (maxval))\n-\tlen = wi::ext (wi::to_offset (maxval)\n-\t\t       - wi::to_offset (TYPE_MIN_VALUE (domain)) + 1,\n+      if (domain && TREE_CONSTANT (TYPE_MAX_VALUE (domain)))\n+\tlen = wi::ext (wi::to_offset (TYPE_MAX_VALUE (domain))\n+                       - wi::to_offset (TYPE_MIN_VALUE (domain)) + 1,\n \t\t       TYPE_PRECISION (TREE_TYPE (domain)),\n \t\t       TYPE_SIGN (TREE_TYPE (domain))).to_uhwi ();\n       else\n@@ -1451,9 +1447,7 @@ process_init_constructor_record (tree type, tree init,\n \t  /* Warn when some struct elements are implicitly initialized\n \t     to zero.  However, avoid issuing the warning for flexible\n \t     array members since they need not have any elements.  */\n-\t  if ((TREE_CODE (fldtype) != ARRAY_TYPE\n-\t       || (TYPE_DOMAIN (fldtype)\n-\t\t   && TYPE_MAX_VALUE (TYPE_DOMAIN (fldtype))))\n+\t  if ((TREE_CODE (fldtype) != ARRAY_TYPE || TYPE_DOMAIN (fldtype))\n \t      && (complain & tf_warning)\n \t      && !EMPTY_CONSTRUCTOR_P (init))\n \t    warning (OPT_Wmissing_field_initializers,"}, {"sha": "b050772ece8fcfa98f833c0124355f07f87c14f2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=05dd97db3c29364ea3fc8fc2a658586a9469db79", "patch": "@@ -1,3 +1,19 @@\n+2016-02-03  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/69251\n+\tPR c++/69253\n+\tPR c++/69290\n+\tPR c++/69277\n+\tPR c++/69349\n+\t* g++.dg/ext/flexarray-mangle-2.C: New test.\n+\t* g++.dg/ext/flexarray-mangle.C: New test.\n+\t* g++.dg/ext/flexarray-subst.C: New test.\n+\t* g++.dg/ext/flexary11.C: New test.\n+\t* g++.dg/ext/flexary12.C: New test.\n+\t* g++.dg/ext/flexary13.C: New test.\n+\t* g++.dg/ext/flexary14.C: New test.\n+\t* g++.dg/other/dump-ada-spec-2.C: Adjust.\n+\n 2016-02-03  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* gcc.target/i386/iamcu/test_passing_unions.c (check_union_passing6):"}, {"sha": "98bd5f5da0ea00e6fcd8789734cf4c507a53ac16", "filename": "gcc/testsuite/g++.dg/ext/flexarray-mangle-2.C", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexarray-mangle-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexarray-mangle-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexarray-mangle-2.C?ref=05dd97db3c29364ea3fc8fc2a658586a9469db79", "patch": "@@ -0,0 +1,46 @@\n+// PR c++/69277 - [6 Regression] ICE mangling a flexible array member\n+// { dg-do compile { target c++11 } }\n+\n+struct A {\n+  int n;\n+  char a [];\n+};\n+\n+// Declare but do not define function templates.\n+template <class T>\n+void foo ();\n+\n+template <typename T>\n+void fooref (T&);\n+\n+// Rvalue references are a C++ 11 feature.\n+template <typename T>\n+void foorefref (T&&);\n+\n+void bar (A a)\n+{\n+  // Decltype is also a C++ 11 feature.\n+  // Verify that decltype gets the right type and that foo is\n+  // mangled correctly.\n+  foo<decltype (a.a)>();\n+\n+  // Verify that function templates taking a reference and an rvalue\n+  // references (as in PR c++/69277) are also mangled correctly.\n+  fooref (a.a);\n+  foorefref (a.a);\n+}\n+\n+// In G++ versions prior to 6, flexible array members were incorrectly\n+// mangled as arrays of zero elements.  Verify that flexible array\n+// members are mangled correctly as arrays of an unspecified number\n+// of elements.\n+\n+// void foo<char []>():\n+// { dg-final { scan-assembler _Z3fooIA_cEvv } }\n+\n+// The following is derived from PR c++/69277:\n+// void fooref<char []>(char (&) [])\n+// { dg-final { scan-assembler _Z6foorefIA_cEvRT_ } }\n+\n+// void foorefref<char (&) []>(char (&) [])\n+// { dg-final { scan-assembler _Z9foorefrefIRA_cEvOT_ } }"}, {"sha": "d8a8c0ac59bb74fc9b24ad6012fe93218dfdbcc3", "filename": "gcc/testsuite/g++.dg/ext/flexarray-mangle.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexarray-mangle.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexarray-mangle.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexarray-mangle.C?ref=05dd97db3c29364ea3fc8fc2a658586a9469db79", "patch": "@@ -0,0 +1,24 @@\n+// PR c++/69277 - [6 Regression] ICE mangling a flexible array member\n+// { dg-do compile }\n+\n+struct A {\n+  int n;\n+  char a [];\n+};\n+\n+// Declare but do not define function templates.\n+template <typename T>\n+void fooref (T&);\n+\n+void bar (A a)\n+{\n+  fooref (a.a);\n+}\n+\n+// In G++ versions prior to 6, flexible array members were incorrectly\n+// mangled as arrays of zero elements.  Verify that flexible array\n+// members are mangled correctly as arrays of an unspecified number\n+// of elements.\n+\n+// void fooref<char []>(char (&) [])\n+// { dg-final { scan-assembler _Z6foorefIA_cEvRT_ } }"}, {"sha": "f6446366165415008dbe9054c3c78e5d4cb98167", "filename": "gcc/testsuite/g++.dg/ext/flexarray-subst.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexarray-subst.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexarray-subst.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexarray-subst.C?ref=05dd97db3c29364ea3fc8fc2a658586a9469db79", "patch": "@@ -0,0 +1,33 @@\n+// PR c++/69251 - [6 Regression] ICE (segmentation fault) in unify_array_domain\n+// on i686-linux-gnu\n+// { dg-do compile }\n+\n+struct A { int n; char a[]; };\n+\n+template <class>\n+struct B;\n+\n+// The following definition shouldn't be needed but is provided to prevent\n+// the test from failing with an error due to PR c++/69349 - template\n+// substitution error for flexible array members.  (This doesn't compromise\n+// the validity of this test since all it tests for is the absennce of\n+// the ICE.)\n+template <class>\n+struct B { typedef int X; };\n+\n+template <class T>\n+struct B<T[]> { typedef int X; };\n+\n+template <class T>\n+struct C { typedef typename B<T>::X X; };\n+\n+template <class T>\n+int foo (T&, typename C<T>::X = 0)\n+{\n+  return 0;\n+}\n+\n+void bar (A *a)\n+{\n+  foo (a->a);\n+}"}, {"sha": "5bf774fb3b30d9e605768687adfbec4cd19a8f0f", "filename": "gcc/testsuite/g++.dg/ext/flexary11.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary11.C?ref=05dd97db3c29364ea3fc8fc2a658586a9469db79", "patch": "@@ -0,0 +1,19 @@\n+// PR c++/69253 - [6 Regression] g++ ICE at -O0 on x86_64-linux-gnu\n+//                in \"cxx_incomplete_type_diagnostic\"\n+// { dg-do compile }\n+\n+struct A {\n+  int n;\n+  char a [];\n+};\n+\n+void f ()\n+{\n+  // Compound literals and flexible array members are G++ extensions\n+  // accepted for compatibility with C and GCC.\n+\n+  // The following use of a flexible array member in a compound literal\n+  // is invalid in C and rejected by GCC in C mode and so it's also\n+  // rejected in C++ mode.\n+  (struct A){ 1, \"\" };   // { dg-error \"forbids compound-literals|initialization of a flexible array member|invalid use of a flexible array member\" }\n+}"}, {"sha": "3d8c8059223e39410bc7c0ae78142197c9702b47", "filename": "gcc/testsuite/g++.dg/ext/flexary12.C", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary12.C?ref=05dd97db3c29364ea3fc8fc2a658586a9469db79", "patch": "@@ -0,0 +1,63 @@\n+// PR c++/69290 - [6 Regression] g++ ICE on invalid initialization\n+//     of a flexible array member\n+// { dg-do compile }\n+\n+// Suppress pedantic errors about initialization of a flexible array member.\n+// { dg-options \"-Wno-pedantic\" }\n+\n+struct A {\n+  int a [];  // { dg-error \"flexible array member .A::a. in an otherwise empty .struct A.\" }\n+};\n+\n+void f1 ()\n+{\n+  // This is the meat of the test from c++/69290:\n+  struct A a\n+    = { \"c\" };   // { dg-error \"invalid conversion from .const char\\\\*. to .int.\" }\n+\n+  (void)&a;\n+}\n+\n+\n+// Exercise other forms of invalid initialization besides the one in the bug.\n+struct B {\n+  int n;\n+  int a [];\n+};\n+\n+void f2 ()\n+{\n+  struct B b1\n+    = { 0, \"c\" };   // { dg-error \"invalid conversion from .const char\\\\*. to .int.\" }\n+\n+  (void)&b1;\n+\n+  const char s[] = \"c\";\n+  struct B b2\n+    = { 0, s };   // { dg-error \"invalid conversion from .const char\\\\*. to .int.\" }\n+\n+  (void)&b2;\n+}\n+\n+struct D {\n+  int a [];  // { dg-error \"flexible array member .D::a. in an otherwise empty .struct D.\" }\n+  D ();\n+};\n+\n+D::D ():\n+  a (\"c\")   // { dg-error \"incompatible types in assignment of .const char \\\\\\[2\\\\\\]. to .int \\\\\\[\\\\\\].\" }\n+{ }\n+\n+\n+template <class T>\n+struct C {\n+  T a [];  // { dg-error \"flexible array member\" }\n+};\n+\n+void f3 ()\n+{\n+  struct C<double> cd\n+    = { \"c\" };   // { dg-error \"cannot convert .const char\\\\*. to .double.\" }\n+\n+  (void)&cd;\n+}"}, {"sha": "462ed6520e020261cd56da18bff7e06932305c15", "filename": "gcc/testsuite/g++.dg/ext/flexary13.C", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary13.C?ref=05dd97db3c29364ea3fc8fc2a658586a9469db79", "patch": "@@ -0,0 +1,64 @@\n+// { dg-do compile }\n+// { dg-options -Wno-pedantic }\n+\n+#define STR(s) #s\n+#define ASSERT(exp) \\\n+  ((exp) ? (void)0 : (void)(__builtin_printf (\"%s:%i: assertion %s failed\\n\", \\\n+                     __FILE__, __LINE__, STR(exp)), \\\n+                      __builtin_abort ()))\n+\n+struct Ax { int n, a[]; };\n+struct AAx { int i; Ax ax; };\n+\n+int i = 12345678;\n+\n+int main ()\n+{\n+  {\n+    Ax s = { 0 };\n+    ASSERT (s.n == 0);\n+  }\n+  {\n+    Ax s =\n+      { 0, { } };   // dg-warning \"initialization of a flexible array member\" }\n+    ASSERT (s.n == 0);\n+  }\n+  {\n+    Ax s =\n+      { 1, { 2 } };   // dg-warning \"initialization of a flexible array member\" }\n+    ASSERT (s.n == 1 && s.a [0] == 2);\n+  }\n+  {\n+    Ax s =\n+      { 2, { 3, 4 } }; // dg-warning \"initialization of a flexible array member\" }\n+    ASSERT (s.n = 2 && s.a [0] == 3 && s.a [1] == 4);\n+  }\n+  {\n+    Ax s =\n+      { 123, i };   // dg-warning \"initialization of a flexible array member\" }\n+    ASSERT (s.n == 123 && s.a [0] == i);\n+  }\n+  {\n+    Ax s =\n+      { 456, { i } }; // dg-warning \"initialization of a flexible array member\" }\n+    ASSERT (s.n == 456 && s.a [0] == i);\n+  }\n+  {\n+    int j = i + 1, k = j + 1;\n+    Ax s =\n+      { 3, { i, j, k } }; // dg-warning \"initialization of a flexible array member\" }\n+    ASSERT (s.n == 3 && s.a [0] == i && s.a [1] == j && s.a [2] == k);\n+  }\n+\n+  {\n+    AAx s =\n+      { 1, { 2 } };   // dg-warning \"initialization of a flexible array member\" }\n+    ASSERT (s.i == 1 && s.ax.n == 2);\n+  }\n+\n+  {\n+    AAx s =\n+      { 1, { 2, { 3 } } };   // dg-warning \"initialization of a flexible array member\" }\n+    ASSERT (s.i == 1 && s.ax.n == 2 && s.ax.a [0] == 3);\n+  }\n+}"}, {"sha": "73653575e0a75945fbdd2561c319a6cc693fabcb", "filename": "gcc/testsuite/g++.dg/ext/flexary14.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary14.C?ref=05dd97db3c29364ea3fc8fc2a658586a9469db79", "patch": "@@ -0,0 +1,17 @@\n+// PR c++/69349 - template substitution error for flexible array members\n+// { dg-do compile }\n+\n+template <class>\n+struct A;\n+\n+template <class T>\n+struct A<T[]> { typedef int X; };\n+\n+template <class T> int foo (T&, typename A<T>::X = 0) { return 0; }\n+\n+struct B { int n, a[]; };\n+\n+void bar (B *b)\n+{\n+    foo (b->a);\n+}"}, {"sha": "608b5be9f342cf11af0f8a5710ed77fd0c0cadbb", "filename": "gcc/testsuite/g++.dg/other/dump-ada-spec-2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fdump-ada-spec-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05dd97db3c29364ea3fc8fc2a658586a9469db79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fdump-ada-spec-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fdump-ada-spec-2.C?ref=05dd97db3c29364ea3fc8fc2a658586a9469db79", "patch": "@@ -7,5 +7,5 @@ struct S\n   __extension__ unsigned char data[];\n };\n \n-/* { dg-final { scan-ada-spec \"array \\\\(0 .. 0\\\\)\" } } */\n+/* { dg-final { scan-ada-spec \"array \\\\(size_t\\\\)\" } } */\n /* { dg-final { cleanup-ada-spec } } */"}]}