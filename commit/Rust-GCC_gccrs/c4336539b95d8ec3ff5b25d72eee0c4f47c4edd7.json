{"sha": "c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQzMzY1MzliOTVkOGVjM2ZmNWIyNWQ3MmVlZTBjNGY0N2M0ZWRkNw==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2005-04-27T09:12:05Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2005-04-27T09:12:05Z"}, "message": "tree-complex.c (expand_vector_operation): New, extracted from expand_vector_operations_1.\n\ngcc:\n2004-04-27  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* tree-complex.c (expand_vector_operation): New, extracted from\n\texpand_vector_operations_1.\n\t(tree_vec_extract): Build a NOP_EXPR.\n\t(expand_vec_parallel): Do not care about returning the correct type.\n\t(expand_vector_operations_1): Call expand_vector_operation.\n\tBuild the VIEW_CONVERT_EXPR on the left side of MODIFY_EXPRs.\n\n\t* tree-complex.c (gate_expand_vector_operations): New.\n\t(pass_lower_vector_ssa): Use it.\n\t* tree-optimize.c (init_tree_optimization_passes): Include\n\tpass_lower_vector_ssa.\n\t* tree-vect-transform.c (vect_min_worthwhile_factor): New.\n\t(vectorizable_operation): Use it.\n\t* tree-vectorizer.c (get_vectype_for_scalar_type): Accept\n\tinteger modes for the vector type.\n\n\t* defaults.h (UNITS_PER_SIMD_WORD): Default to UNITS_PER_WORD.\n\t* tree-vect-analyze.c (vect_enhance_data_refs_alignment):\n\tDo not cope with UNITS_PER_SIMD_WORD == 0.\n\t* tree-vectorizer.c (get_vectype_for_scalar_type): Check\n\tif the scalar type is not bigger than UNITS_PER_SIMD_WORD.\n\t(vectorize_loops): Do not check that UNITS_PER_SIMD_WORD > 0.\n\t* config/i386/i386.h (UNITS_PER_SIMD_WORD): Default to UNITS_PER_WORD.\n\t* config/mips/mips.h (UNITS_PER_SIMD_WORD): Likewise.\n\t* config/rs6000/rs6000.h (UNITS_PER_SIMD_WORD): Likewise.\n\t* config/sparc/sparc.h (UNITS_PER_SIMD_WORD): Likewise.\n\n\t* config/alpha/alpha.h (UNITS_PER_SIMD_WORD): Remove.\n\t* config/bfin/bfin.h (UNITS_PER_SIMD_WORD): Remove.\n\t* config/ia64/ia64.h (UNITS_PER_SIMD_WORD): Remove.\n\n\t* doc/tm.texi (UNITS_PER_WORD): Rephrase more accurately.\n\t(UNITS_PER_SIMD_WORD): New.\n\ngcc/testsuite:\n2004-04-27  Paolo Bonzini  <bonzini@gnu.org>\n\n        * gcc.dg/tree-ssa/gen-vect-11.c, gcc.dg/tree-ssa/gen-vect-11a.c,\n        gcc.dg/tree-ssa/gen-vect-11b.c, gcc.dg/tree-ssa/gen-vect-11c.c,\n        gcc.dg/tree-ssa/gen-vect-2.c, gcc.dg/tree-ssa/gen-vect-25.c,\n        gcc.dg/tree-ssa/gen-vect-26.c, gcc.dg/tree-ssa/gen-vect-28.c,\n        gcc.dg/tree-ssa/gen-vect-32.c: New.\n        * gcc.dg/vect/vect-82.c, gcc.dg/vect/vect-83.c: Fix dg-final.\n        * gcc.dg/vect/vect-82_64.c, gcc.dg/vect/vect-83_64.c: Remove xfail,\n        don't run on PPC32.\n\nCVS: Enter Log.  Lines beginning with `CVS:' are removed automatically\nCVS:\nCVS: Committing in .\nCVS:\nCVS: Modified Files:\nCVS: \ttree-complex.c tree-optimize.c tree-vect-analyze.c defaults.h\nCVS: \ttree-vect-transform.c tree-vectorizer.c ChangeLog\nCVS: \ttestsuite/ChangeLog config/alpha/alpha.h config/bfin/bfin.h\nCVS: \tconfig/i386/i386.h config/ia64/ia64.h config/mips/mips.h\nCVS: \tconfig/rs6000/rs6000.h\nCVS: \tconfig/sparc/sparc.h doc/tm.texi\nCVS: \ttestsuite/gcc.dg/vect/vect-82.c\nCVS: \ttestsuite/gcc.dg/vect/vect-82_64.c\nCVS: \ttestsuite/gcc.dg/vect/vect-83.c\nCVS: \ttestsuite/gcc.dg/vect/vect-83_64.c\nCVS: Added Files:\nCVS: \ttestsuite/gcc.dg/tree-ssa/gen-vect-11.c\nCVS: \ttestsuite/gcc.dg/tree-ssa/gen-vect-11a.c\nCVS: \ttestsuite/gcc.dg/tree-ssa/gen-vect-11b.c\nCVS: \ttestsuite/gcc.dg/tree-ssa/gen-vect-11c.c\nCVS: \ttestsuite/gcc.dg/tree-ssa/gen-vect-2.c\nCVS: \ttestsuite/gcc.dg/tree-ssa/gen-vect-25.c\nCVS: \ttestsuite/gcc.dg/tree-ssa/gen-vect-26.c\nCVS: \ttestsuite/gcc.dg/tree-ssa/gen-vect-28.c\nCVS: \ttestsuite/gcc.dg/tree-ssa/gen-vect-32.c\nCVS: ----------------------------------------------------------------------\n\nFrom-SVN: r98818", "tree": {"sha": "e30fc63fb8514b4f3b004d75368766b03aee6866", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e30fc63fb8514b4f3b004d75368766b03aee6866"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/comments", "author": null, "committer": null, "parents": [{"sha": "e820471b5803045c21828abf910953991771ce50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e820471b5803045c21828abf910953991771ce50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e820471b5803045c21828abf910953991771ce50"}], "stats": {"total": 673, "additions": 563, "deletions": 110}, "files": [{"sha": "5a99ffa1aff3cb56efce03b72ca1cdab67e94fdf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "patch": "@@ -1,3 +1,39 @@\n+2004-04-27  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* tree-complex.c (expand_vector_operation): New, extracted from\n+\texpand_vector_operations_1.\n+\t(tree_vec_extract): Build a NOP_EXPR.\n+\t(expand_vec_parallel): Do not care about returning the correct type.\n+\t(expand_vector_operations_1): Call expand_vector_operation.\n+\tBuild the VIEW_CONVERT_EXPR on the left side of MODIFY_EXPRs.\n+\n+\t* tree-complex.c (gate_expand_vector_operations): New.\n+\t(pass_lower_vector_ssa): Use it.\n+\t* tree-optimize.c (init_tree_optimization_passes): Include\n+\tpass_lower_vector_ssa.\n+\t* tree-vect-transform.c (vect_min_worthwhile_factor): New.\n+\t(vectorizable_operation): Use it.\n+\t* tree-vectorizer.c (get_vectype_for_scalar_type): Accept\n+\tinteger modes for the vector type.\n+\n+\t* defaults.h (UNITS_PER_SIMD_WORD): Default to UNITS_PER_WORD.\n+\t* tree-vect-analyze.c (vect_enhance_data_refs_alignment):\n+\tDo not cope with UNITS_PER_SIMD_WORD == 0.\n+\t* tree-vectorizer.c (get_vectype_for_scalar_type): Check\n+\tif the scalar type is not bigger than UNITS_PER_SIMD_WORD.\n+\t(vectorize_loops): Do not check that UNITS_PER_SIMD_WORD > 0.\n+\t* config/i386/i386.h (UNITS_PER_SIMD_WORD): Default to UNITS_PER_WORD.\n+\t* config/mips/mips.h (UNITS_PER_SIMD_WORD): Likewise.\n+\t* config/rs6000/rs6000.h (UNITS_PER_SIMD_WORD): Likewise.\n+\t* config/sparc/sparc.h (UNITS_PER_SIMD_WORD): Likewise.\n+\n+\t* config/alpha/alpha.h (UNITS_PER_SIMD_WORD): Remove.\n+\t* config/bfin/bfin.h (UNITS_PER_SIMD_WORD): Remove.\n+\t* config/ia64/ia64.h (UNITS_PER_SIMD_WORD): Remove.\n+\n+\t* doc/tm.texi (UNITS_PER_WORD): Rephrase more accurately.\n+\t(UNITS_PER_SIMD_WORD): New.\n+\n 2005-04-27  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* config/ia64/ia64.c (ia64_encode_addr_area): Use gcc_assert and\n@@ -29,17 +65,38 @@\n \t(INDEX_REGISTER_P): New.\n \t(BASE_REGISTER_P): New.\n \t(indirectable_constant_address_p): New.  Adapted from\n+<<<<<<< ChangeLog\n+\tINDIRECTABLE_CONSTANT_ADDRESS_P in vax.h.\n+\tUse SYMBOL_REF_LOCAL_P.\n+=======\n \tINDIRECTABLE_CONSTANT_ADDRESS_P in vax.h. Use SYMBOL_REF_LOCAL_P.\n+>>>>>>> 2.8478\n \t(indirectable_address_p): New.  Adapted from\n \tINDIRECTABLE_ADDRESS_P in vax.h.\n \t(nonindexed_address_p): New.  Adapted from\n+<<<<<<< ChangeLog\n+\tGO_IF_NONINDEXED_ADDRESS in vax.h.\n+\t(index_temp_p): New.  Adapted from\n+\tINDEX_TERM_P in vax.h.\n+\t(reg_plus_index_p): New.  Adapted from\n+\tGO_IF_REG_PLUS_INDEX in vax.h.\n+=======\n \tGO_IF_NONINDEXED_ADDRESS in vax.h.\n \t(index_temp_p): New.  Adapted from INDEX_TERM_P in vax.h.\n \t(reg_plus_index_p): New.  Adapted from GO_IF_REG_PLUS_INDEX in vax.h.\n+>>>>>>> 2.8478\n \t(legitimate_address_p): New.  Adapted from\n+<<<<<<< ChangeLog\n+\tGO_IF_LEGITIMATE_ADDRESS in vax.h\n+=======\n \tGO_IF_LEGITIMATE_ADDRESS in vax.h.\n+>>>>>>> 2.8478\n \t(vax_mode_dependent_address_p): New.  Adapted from\n+<<<<<<< ChangeLog\n+\tGO_IF_MODE_DEPENDENT_ADDRESS in vax.h\n+=======\n \tGO_IF_MODE_DEPENDENT_ADDRESS in vax.h.\n+>>>>>>> 2.8478\n \t* config/vax/vax.h (CONSTANT_ADDRESS_P): Use\n \tlegitimate_constant_address_p.\n \t(CONSTANT_P): Use legitimate_constant_p.\n@@ -48,8 +105,13 @@\n \t(GO_IF_NONINDEXED_ADDRESS): Removed.\n \t(INDEX_TEMP_P): Removed.\n \t(GO_IF_REG_PLUS_INDEX): Removed.\n+<<<<<<< ChangeLog\n+\t(GO_IF_LEGITIMATE_ADDRESS): Use legitimate_address_p.\n+\tTwo definitions, depending on whether REG_OK_STRICT is defined.\n+=======\n \t(GO_IF_LEGITIMATE_ADDRESS): Use legitimate_address_p. Two\n \tdefinitions, depending on whether REG_OK_STRICT is defined.\n+>>>>>>> 2.8478\n \t(GO_IF_MODE_DEPENDENT_ADDRESS): Use vax_mode_dependent_address_p.\n \tTwo definitions, depending on whether REG_OK_STRICT is defined.\n \t* config/vax/vax-protos.h (legitimate_constant_address_p): Prototype"}, {"sha": "97bd9efde6a8a48984065aea7f6a9a8fa9d8c635", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "patch": "@@ -394,9 +394,6 @@ extern int alpha_tls_size;\n \n #define SLOW_UNALIGNED_ACCESS(MODE, ALIGN) 1\n \n-/* Our SIMD is all done on single integer registers.  */\n-#define UNITS_PER_SIMD_WORD UNITS_PER_WORD\n-\f\n /* Standard register usage.  */\n \n /* Number of actual hardware registers."}, {"sha": "608188ae882d6409ace5772b4a1fd70dd69f2d19", "filename": "gcc/config/bfin/bfin.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Fconfig%2Fbfin%2Fbfin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Fconfig%2Fbfin%2Fbfin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.h?ref=c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "patch": "@@ -773,9 +773,6 @@ do {                                              \\\n /* Width of a word, in units (bytes).  */\n #define UNITS_PER_WORD 4\n \n-/* Size of a vector for autovectorization.  */\n-#define UNITS_PER_SIMD_WORD 4\n-\n /* Width in bits of a pointer.\n    See also the macro `Pmode1' defined below.  */\n #define POINTER_SIZE 32"}, {"sha": "9b04fadbcca2c110fe8a837bae8d6ec4b6e0a42a", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "patch": "@@ -836,7 +836,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* ??? No autovectorization into MMX or 3DNOW until we can reliably\n    place emms and femms instructions.  */\n-#define UNITS_PER_SIMD_WORD (TARGET_SSE ? 16 : 0)\n+#define UNITS_PER_SIMD_WORD (TARGET_SSE ? 16 : UNITS_PER_WORD)\n \n #define VALID_FP_MODE_P(MODE)\t\t\t\t\t\t\\\n     ((MODE) == SFmode || (MODE) == DFmode || (MODE) == XFmode\t\t\\"}, {"sha": "4aca02471da1c0379e1fab092a949c9825de166d", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "patch": "@@ -168,8 +168,6 @@ extern enum processor_type ia64_tune;\n \n #define UNITS_PER_WORD 8\n \n-#define UNITS_PER_SIMD_WORD UNITS_PER_WORD\n-\n #define POINTER_SIZE (TARGET_ILP32 ? 32 : 64)\n \n /* A C expression whose value is zero if pointers that need to be extended"}, {"sha": "f81e7e97e235b635744db22083fd8a4905250f45", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "patch": "@@ -966,7 +966,7 @@ extern const struct mips_cpu_info *mips_tune_info;\n /* The number of bytes in a double.  */\n #define UNITS_PER_DOUBLE (TYPE_PRECISION (double_type_node) / BITS_PER_UNIT)\n \n-#define UNITS_PER_SIMD_WORD (TARGET_PAIRED_SINGLE_FLOAT ? 8 : 0)\n+#define UNITS_PER_SIMD_WORD (TARGET_PAIRED_SINGLE_FLOAT ? 8 : UNITS_PER_WORD)\n \n /* Set the sizes of the core types.  */\n #define SHORT_TYPE_SIZE 16"}, {"sha": "c2f78a576aeb4812f2d3502f7db1253075b22584", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "patch": "@@ -1043,8 +1043,9 @@ extern const char *rs6000_warn_altivec_long_switch;\n          || (MODE) == V1DImode          \\\n          || (MODE) == V2SImode)\n \n-#define UNITS_PER_SIMD_WORD     \\\n-        (TARGET_ALTIVEC ? 16 : (TARGET_SPE ? 8 : 0) )\n+#define UNITS_PER_SIMD_WORD\t\t\t\t\t\\\n+        (TARGET_ALTIVEC ? UNITS_PER_ALTIVEC_WORD\t\t\\\n+\t : (TARGET_SPE ? UNITS_PER_SPE_WORD : UNITS_PER_WORD))\n \n /* Value is TRUE if hard register REGNO can hold a value of\n    machine-mode MODE.  */"}, {"sha": "fddb2e0e0bbd5341089c9c056a965e4f04b3575c", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "patch": "@@ -588,7 +588,7 @@ extern struct sparc_cpu_select sparc_select[];\n #define MIN_UNITS_PER_WORD\t4\n #endif\n \n-#define UNITS_PER_SIMD_WORD\t(TARGET_VIS ? 8 : 0)\n+#define UNITS_PER_SIMD_WORD\t(TARGET_VIS ? 8 : UNITS_PER_WORD)\n \n /* Now define the sizes of the C data types.  */\n "}, {"sha": "e4ef7f3624644f23986e62f8b63d15821fa76d68", "filename": "gcc/defaults.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "patch": "@@ -702,8 +702,10 @@ do { fputs (integer_asm_op (POINTER_SIZE / BITS_PER_UNIT, TRUE), FILE); \\\n #define HAS_LONG_UNCOND_BRANCH 0\n #endif\n \n+/* By default, only attempt to parallelize bitwise operations, and\n+   possibly adds/subtracts using bit-twiddling.  */\n #ifndef UNITS_PER_SIMD_WORD\n-#define UNITS_PER_SIMD_WORD 0\n+#define UNITS_PER_SIMD_WORD UNITS_PER_WORD\n #endif\n \n /* Determine whether __cxa_atexit, rather than atexit, is used to"}, {"sha": "514f59d5bbe524e9073d77710eca8fab22b8fcbb", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "patch": "@@ -1076,7 +1076,8 @@ largest value that @code{BITS_PER_WORD} can have at run-time.\n @end defmac\n \n @defmac UNITS_PER_WORD\n-Number of storage units in a word; normally 4.\n+Number of storage units in a word; normally the size of a general-purpose\n+register, a power of two from 1 or 8.\n @end defmac\n \n @defmac MIN_UNITS_PER_WORD\n@@ -1085,6 +1086,13 @@ Minimum number of units in a word.  If this is undefined, the default is\n smallest value that @code{UNITS_PER_WORD} can have at run-time.\n @end defmac\n \n+@defmac UNITS_PER_SIMD_WORD\n+Number of units in the vectors that the vectorizer can produce.\n+The default is equal to @code{UNITS_PER_WORD}, because the vectorizer\n+can do some transformations even in absence of specialized @acronym{SIMD}\n+hardware.\n+@end defmac\n+\n @defmac POINTER_SIZE\n Width of a pointer, in bits.  You must specify a value no wider than the\n width of @code{Pmode}.  If it is not equal to the width of @code{Pmode},"}, {"sha": "0f69c320f7d2ce00d78aa6c5726502bb5942be8a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "patch": "@@ -1,3 +1,14 @@\n+2004-04-27  Paolo Bonzini  <bonzini@gnu.org>\n+\n+        * gcc.dg/tree-ssa/gen-vect-11.c, gcc.dg/tree-ssa/gen-vect-11a.c,\n+        gcc.dg/tree-ssa/gen-vect-11b.c, gcc.dg/tree-ssa/gen-vect-11c.c,\n+        gcc.dg/tree-ssa/gen-vect-2.c, gcc.dg/tree-ssa/gen-vect-25.c,\n+        gcc.dg/tree-ssa/gen-vect-26.c, gcc.dg/tree-ssa/gen-vect-28.c,\n+        gcc.dg/tree-ssa/gen-vect-32.c: New.\n+        * gcc.dg/vect/vect-82.c, gcc.dg/vect/vect-83.c: Fix dg-final.\n+        * gcc.dg/vect/vect-82_64.c, gcc.dg/vect/vect-83_64.c: Remove xfail,\n+        don't run on PPC32.\n+        \n 2005-04-27  Joseph S. Myers  <joseph@codesourcery.com>\n \n \tPR c/21213"}, {"sha": "bc6c2869d75faac1c1c8e77013cdf22146649f09", "filename": "gcc/testsuite/gcc.dg/tree-ssa/gen-vect-11.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fgen-vect-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fgen-vect-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fgen-vect-11.c?ref=c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -ftree-vectorize -ftree-vectorizer-verbose=3 -fdump-tree-vect-stats\" } */\n+\n+#include <stdlib.h>\n+\n+#define N 16\n+\n+int main ()\n+{\n+  int i;\n+  char ia[N];\n+  char ic[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+  char ib[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      ia[i] = ib[i] + ic[i];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (ia[i] != ib[i] + ic[i])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "75ec7ce8863d7d49765fdc3be34cca94ca48047b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/gen-vect-11a.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fgen-vect-11a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fgen-vect-11a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fgen-vect-11a.c?ref=c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -ftree-vectorize -ftree-vectorizer-verbose=3 -fdump-tree-vect-stats\" } */\n+\n+#include <stdlib.h>\n+\n+#define N 16\n+\n+#if __LONG_MAX__ == 2147483647\n+typedef short half_word;\n+#else\n+typedef int half_word;\n+#endif\n+\n+int main ()\n+{\n+  int i;\n+  half_word ia[N];\n+  half_word ic[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+  half_word ib[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      ia[i] = ib[i] & ic[i];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (ia[i] != ib[i] & ic[i])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "20833533468afc1979e8068ec4ad868a34e77cb6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/gen-vect-11b.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fgen-vect-11b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fgen-vect-11b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fgen-vect-11b.c?ref=c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -ftree-vectorize -ftree-vectorizer-verbose=3 -fdump-tree-vect-stats\" } */\n+\n+#include <stdlib.h>\n+\n+#define N 16\n+\n+int main ()\n+{\n+  int i;\n+  char ia[N];\n+  char ic[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+  char ib[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+\n+  /* Not vectorizable, multiplication */\n+  for (i = 0; i < N; i++)\n+    {\n+      ia[i] = ib[i] * ic[i];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (ia[i] != (char) (ib[i] * ic[i]))\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "8632ae42b3abfbacf99868f20bc39f356f719695", "filename": "gcc/testsuite/gcc.dg/tree-ssa/gen-vect-11c.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fgen-vect-11c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fgen-vect-11c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fgen-vect-11c.c?ref=c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -ftree-vectorize -ftree-vectorizer-verbose=3 -fdump-tree-vect-stats\" } */\n+\n+#include <stdlib.h>\n+\n+#define N 16\n+\n+#if LONG_MAX == 2147483647\n+typedef short half_word;\n+#else\n+typedef int half_word;\n+#endif\n+\n+int main ()\n+{\n+  int i;\n+  half_word ia[N];\n+  half_word ic[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+  half_word ib[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+\n+  /* Not worthwhile, only 2 parts per int */\n+  for (i = 0; i < N; i++)\n+    {\n+      ia[i] = ib[i] + ic[i];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (ia[i] != ib[i] + ic[i])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "be89c268258c3cb83f77a394290bf0e1135b6477", "filename": "gcc/testsuite/gcc.dg/tree-ssa/gen-vect-2.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fgen-vect-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fgen-vect-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fgen-vect-2.c?ref=c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -ftree-vectorize -ftree-vectorizer-verbose=3 -fdump-tree-vect-stats\" } */\n+\n+#include <stdlib.h>\n+\n+#define N 16\n+ \n+#if __LONG_MAX__ == 2147483647\n+typedef short half_word;\n+#else\n+typedef int half_word;\n+#endif\n+\n+int main ()\n+{\n+  half_word cb[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+  half_word ca[N];\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      ca[i] = cb[i];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (ca[i] != cb[i])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "1e0c2c11cf8400705dae5ed1dd501687641fb24a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/gen-vect-25.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fgen-vect-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fgen-vect-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fgen-vect-25.c?ref=c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -ftree-vectorize -ftree-vectorizer-verbose=3 -fdump-tree-vect-stats\" } */\n+\n+#include <stdlib.h>\n+\n+#define N 128\n+\n+#if __LONG_MAX__ == 2147483647\n+typedef short half_word;\n+#else\n+typedef int half_word;\n+#endif\n+\n+int main (int n, int *p)\n+{\n+  int i;\n+  half_word ib[N];\n+  half_word ia[N];\n+  int k;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      ia[i] = n;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (ia[i] != n)\n+        abort ();\n+    }\n+\n+  k = *p;\n+  for (i = 0; i < N; i++)\n+    {\n+      ib[i] = k;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (ib[i] != k)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "b90413aa4bf6c2d773b2ea4cf4769dde23dba94a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/gen-vect-26.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fgen-vect-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fgen-vect-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fgen-vect-26.c?ref=c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -ftree-vectorize -ftree-vectorizer-verbose=3 -fdump-tree-vect-stats\" } */\n+\n+#include <stdlib.h>\n+\n+#define N 128\n+\n+/* unaligned store.  */\n+\n+int main ()\n+{\n+  int i;\n+  char ia[N+1];\n+\n+  for (i = 1; i <= N; i++)\n+    {\n+      ia[i] = 5;\n+    }\n+\n+  /* check results:  */\n+  for (i = 1; i <= N; i++)\n+    {\n+      if (ia[i] != 5)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "0d017529357d6248ef65c3c0a680f55c431ce9ef", "filename": "gcc/testsuite/gcc.dg/tree-ssa/gen-vect-28.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fgen-vect-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fgen-vect-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fgen-vect-28.c?ref=c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -ftree-vectorize -ftree-vectorizer-verbose=3 -fdump-tree-vect-stats\" } */\n+\n+#include <stdlib.h>\n+\n+#define N 128\n+#define OFF 3\n+\n+/* unaligned store.  */\n+\n+int main (int off)\n+{\n+  int i;\n+  char ia[N+OFF];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      ia[i+off] = 5;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (ia[i+off] != 5)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "681c7071685f1c07a48a772d5bc534c6c4f438af", "filename": "gcc/testsuite/gcc.dg/tree-ssa/gen-vect-32.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fgen-vect-32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fgen-vect-32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fgen-vect-32.c?ref=c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -ftree-vectorize -ftree-vectorizer-verbose=3 -fdump-tree-vect-stats\" } */\n+\n+#include <stdlib.h>\n+\n+#define N 16\n+ \n+int main ()\n+{  \n+  struct {\n+    char ca[N];\n+  } s;\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      s.ca[i] = 5;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (s.ca[i] != 5)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "aecd61970d59571229644a49fefa291917526d35", "filename": "gcc/testsuite/gcc.dg/vect/vect-82.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-82.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-82.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-82.c?ref=c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "patch": "@@ -32,5 +32,5 @@ int main (void)\n   return main1 ();\n } \n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "a21ed1281fe8f46648019a6274588da108e2fbc5", "filename": "gcc/testsuite/gcc.dg/vect/vect-82_64.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-82_64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-82_64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-82_64.c?ref=c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "patch": "@@ -1,4 +1,5 @@\n-/* { dg-do run { target powerpc*-*-* } } */\n+/* { dg-do run { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */\n /* { dg-options \"-O2 -ftree-vectorize -mpowerpc64 -fdump-tree-vect-stats -maltivec\" } */\n \n #include <stdarg.h>\n@@ -33,5 +34,5 @@ int main (void)\n   return main1 ();\n } \n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "5c21cbbe341b7321f4017272ff584e6a850bd45c", "filename": "gcc/testsuite/gcc.dg/vect/vect-83.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-83.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-83.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-83.c?ref=c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "patch": "@@ -32,5 +32,5 @@ int main (void)\n   return main1 ();\n } \n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "b5f6f6f08a536f25608187ac0deeede0274fc4a6", "filename": "gcc/testsuite/gcc.dg/vect/vect-83_64.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-83_64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-83_64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-83_64.c?ref=c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "patch": "@@ -1,4 +1,5 @@\n-/* { dg-do run { target powerpc*-*-* } } */\n+/* { dg-do run { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */\n /* { dg-options \"-O2 -ftree-vectorize -mpowerpc64 -fdump-tree-vect-stats -maltivec\" } */\n \n #include <stdarg.h>\n@@ -33,5 +34,5 @@ int main (void)\n   return main1 ();\n } \n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "98b6c561503bffb83b3b243e919cd584ee1a79ad", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 90, "deletions": 67, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "patch": "@@ -632,8 +632,13 @@ tree_vec_extract (block_stmt_iterator *bsi, tree type,\n {\n   if (bitpos)\n     return gimplify_build3 (bsi, BIT_FIELD_REF, type, t, bitsize, bitpos);\n-  else\n+\n+  /* Build a conversion; VIEW_CONVERT_EXPR is very expensive unless T will\n+     anyway be stored in memory, so prefer NOP_EXPR.  */\n+  else if (TYPE_MODE (type) == BLKmode)\n     return gimplify_build1 (bsi, VIEW_CONVERT_EXPR, type, t);\n+  else\n+    return gimplify_build1 (bsi, NOP_EXPR, type, t);\n }\n \n static tree\n@@ -783,7 +788,7 @@ expand_vector_parallel (block_stmt_iterator *bsi, elem_op_func f, tree type,\n       result = f (bsi, compute_type, a, b, NULL_TREE, NULL_TREE, code);\n     }\n \n-  return build1 (VIEW_CONVERT_EXPR, type, result);\n+  return result;\n }\n \n /* Expand a vector operation to scalars; for integer types we can use\n@@ -810,6 +815,60 @@ expand_vector_addition (block_stmt_iterator *bsi,\n \t\t\t\t    a, b, code);\n }\n \n+static tree\n+expand_vector_operation (block_stmt_iterator *bsi, tree type, tree compute_type,\n+\t\t\t tree rhs, enum tree_code code)\n+{\n+  enum machine_mode compute_mode = TYPE_MODE (compute_type);\n+\n+  /* If the compute mode is not a vector mode (hence we are not decomposing\n+     a BLKmode vector to smaller, hardware-supported vectors), we may want\n+     to expand the operations in parallel.  */\n+  if (GET_MODE_CLASS (compute_mode) != MODE_VECTOR_INT\n+      && GET_MODE_CLASS (compute_mode) != MODE_VECTOR_FLOAT)\n+    switch (code)\n+      {\n+      case PLUS_EXPR:\n+      case MINUS_EXPR:\n+        if (!TYPE_TRAP_SIGNED (type))\n+          return expand_vector_addition (bsi, do_binop, do_plus_minus, type,\n+\t\t      \t\t         TREE_OPERAND (rhs, 0),\n+\t\t\t\t\t TREE_OPERAND (rhs, 1), code);\n+\tbreak;\n+\n+      case NEGATE_EXPR:\n+        if (!TYPE_TRAP_SIGNED (type))\n+          return expand_vector_addition (bsi, do_unop, do_negate, type,\n+\t\t      \t\t         TREE_OPERAND (rhs, 0),\n+\t\t\t\t\t NULL_TREE, code);\n+\tbreak;\n+\n+      case BIT_AND_EXPR:\n+      case BIT_IOR_EXPR:\n+      case BIT_XOR_EXPR:\n+        return expand_vector_parallel (bsi, do_binop, type,\n+\t\t      \t\t       TREE_OPERAND (rhs, 0),\n+\t\t\t\t       TREE_OPERAND (rhs, 1), code);\n+\n+      case BIT_NOT_EXPR:\n+        return expand_vector_parallel (bsi, do_unop, type,\n+\t\t      \t\t       TREE_OPERAND (rhs, 0),\n+\t\t\t\t       NULL_TREE, code);\n+\n+      default:\n+\tbreak;\n+      }\n+\n+  if (TREE_CODE_CLASS (code) == tcc_unary)\n+    return expand_vector_piecewise (bsi, do_unop, type, compute_type,\n+\t\t\t\t    TREE_OPERAND (rhs, 0),\n+\t\t\t\t    NULL_TREE, code);\n+  else\n+    return expand_vector_piecewise (bsi, do_binop, type, compute_type,\n+\t\t\t\t    TREE_OPERAND (rhs, 0),\n+\t\t\t\t    TREE_OPERAND (rhs, 1), code);\n+}\n+\f\n /* Return a type for the widest vector mode whose components are of mode\n    INNER_MODE, or NULL_TREE if none is found.  */\n static tree\n@@ -841,7 +900,7 @@ static void\n expand_vector_operations_1 (block_stmt_iterator *bsi)\n {\n   tree stmt = bsi_stmt (*bsi);\n-  tree *p_rhs, rhs, type, compute_type;\n+  tree *p_lhs, *p_rhs, lhs, rhs, type, compute_type;\n   enum tree_code code;\n   enum machine_mode compute_mode;\n   optab op;\n@@ -856,7 +915,9 @@ expand_vector_operations_1 (block_stmt_iterator *bsi)\n       /* FALLTHRU */\n \n     case MODIFY_EXPR:\n+      p_lhs = &TREE_OPERAND (stmt, 0);\n       p_rhs = &TREE_OPERAND (stmt, 1);\n+      lhs = *p_lhs;\n       rhs = *p_rhs;\n       break;\n \n@@ -897,86 +958,48 @@ expand_vector_operations_1 (block_stmt_iterator *bsi)\n         compute_type = vector_compute_type;\n     }\n \n-  compute_mode = TYPE_MODE (compute_type);\n-\n   /* If we are breaking a BLKmode vector into smaller pieces,\n      type_for_widest_vector_mode has already looked into the optab,\n      so skip these checks.  */\n   if (compute_type == type)\n     {\n+      compute_mode = TYPE_MODE (compute_type);\n       if ((GET_MODE_CLASS (compute_mode) == MODE_VECTOR_INT\n \t   || GET_MODE_CLASS (compute_mode) == MODE_VECTOR_FLOAT)\n           && op != NULL\n \t  && op->handlers[compute_mode].insn_code != CODE_FOR_nothing)\n \treturn;\n       else\n-\t{\n-\t  /* There is no operation in hardware, so fall back to scalars.  */\n-\t  compute_type = TREE_TYPE (type);\n-\t  compute_mode = TYPE_MODE (compute_type);\n-\t}\n+\t/* There is no operation in hardware, so fall back to scalars.  */\n+\tcompute_type = TREE_TYPE (type);\n     }\n \n-  /* If the compute mode is not a vector mode (hence we are decomposing\n-     a BLKmode vector to smaller, hardware-supported vectors), we may\n-     want to expand the operations in parallel.  */\n-  if (GET_MODE_CLASS (compute_mode) != MODE_VECTOR_INT\n-      && GET_MODE_CLASS (compute_mode) != MODE_VECTOR_FLOAT)\n-    switch (code)\n-      {\n-      case PLUS_EXPR:\n-      case MINUS_EXPR:\n-        if (TYPE_TRAP_SIGNED (type))\n-\t  break;\n-\n-        *p_rhs = expand_vector_addition (bsi, do_binop, do_plus_minus, type,\n-\t\t      \t\t         TREE_OPERAND (rhs, 0),\n-\t\t\t\t         TREE_OPERAND (rhs, 1), code);\n-\tmark_stmt_modified (bsi_stmt (*bsi));\n-        return;\n-\n-      case NEGATE_EXPR:\n-        if (TYPE_TRAP_SIGNED (type))\n-\t  break;\n-\n-        *p_rhs = expand_vector_addition (bsi, do_unop, do_negate, type,\n-\t\t      \t\t         TREE_OPERAND (rhs, 0),\n-\t\t\t\t\t NULL_TREE, code);\n-\tmark_stmt_modified (bsi_stmt (*bsi));\n-        return;\n-\n-      case BIT_AND_EXPR:\n-      case BIT_IOR_EXPR:\n-      case BIT_XOR_EXPR:\n-        *p_rhs = expand_vector_parallel (bsi, do_binop, type,\n-\t\t      \t\t         TREE_OPERAND (rhs, 0),\n-\t\t\t\t         TREE_OPERAND (rhs, 1), code);\n-\tmark_stmt_modified (bsi_stmt (*bsi));\n-        return;\n-\n-      case BIT_NOT_EXPR:\n-        *p_rhs = expand_vector_parallel (bsi, do_unop, type,\n-\t\t      \t\t         TREE_OPERAND (rhs, 0),\n-\t\t\t\t\t NULL_TREE, code);\n-\tmark_stmt_modified (bsi_stmt (*bsi));\n-        return;\n-\n-      default:\n-\tbreak;\n-      }\n-\n-  if (TREE_CODE_CLASS (code) == tcc_unary)\n-    *p_rhs = expand_vector_piecewise (bsi, do_unop, type, compute_type,\n-\t\t\t\t      TREE_OPERAND (rhs, 0),\n-\t\t\t\t      NULL_TREE, code);\n+  rhs = expand_vector_operation (bsi, type, compute_type, rhs, code);\n+  if (lang_hooks.types_compatible_p (TREE_TYPE (lhs), TREE_TYPE (rhs)))\n+    *p_rhs = rhs;\n   else\n-    *p_rhs = expand_vector_piecewise (bsi, do_binop, type, compute_type,\n-\t\t\t\t      TREE_OPERAND (rhs, 0),\n-\t\t\t\t      TREE_OPERAND (rhs, 1), code);\n+    {\n+      /* Build a conversion; VIEW_CONVERT_EXPR is very expensive unless T will\n+         be stored in memory anyway, so prefer NOP_EXPR.  Also, perform the\n+\t VIEW_CONVERT_EXPR on the left side of the assignment.  */\n+      if (TYPE_MODE (TREE_TYPE (rhs)) == BLKmode)\n+        *p_lhs = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (rhs), lhs);\n+      else\n+\t*p_rhs = gimplify_build1 (bsi, NOP_EXPR, TREE_TYPE (lhs), rhs);\n+    }\n \n   mark_stmt_modified (bsi_stmt (*bsi));\n }\n \f\n+/* Use this to lower vector operations introduced by the vectorizer,\n+   if it may need the bit-twiddling tricks implemented in this file.  */\n+\n+static bool\n+gate_expand_vector_operations (void)\n+{\n+  return flag_tree_vectorize != 0;\n+}\n+\n static void\n expand_vector_operations (void)\n {\n@@ -1015,8 +1038,8 @@ tree_lower_operations (void)\n \n struct tree_opt_pass pass_lower_vector_ssa = \n {\n-  \"vector\",\t\t\t\t/* name */\n-  NULL,\t\t\t\t\t/* gate */\n+  \"veclower\",\t\t\t\t/* name */\n+  gate_expand_vector_operations,\t/* gate */\n   expand_vector_operations,\t\t/* execute */\n   NULL,\t\t\t\t\t/* sub */\n   NULL,\t\t\t\t\t/* next */"}, {"sha": "e77c29c573a041a5757d89ca940e25880de3a7ae", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "patch": "@@ -437,6 +437,7 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_iv_canon);\n   NEXT_PASS (pass_if_conversion);\n   NEXT_PASS (pass_vectorize);\n+  NEXT_PASS (pass_lower_vector_ssa);\n   NEXT_PASS (pass_complete_unroll);\n   NEXT_PASS (pass_iv_optimize);\n   NEXT_PASS (pass_loop_done);"}, {"sha": "1416bc435e11da31433f377656b7a10148c9fd9c", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "patch": "@@ -1076,13 +1076,6 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n   struct data_reference *dr0 = NULL;\n   unsigned int i, j;\n \n-  /* Sigh, a hack to make targets that do not define UNITS_PER_SIMD_WORD\n-     bootstrap.  Copy UNITS_PER_SIMD_WORD to a local variable to avoid a\n-     \"division by zero\" error.  This error would be issued because we\n-     we do \"... % UNITS_PER_SIMD_WORD\" below, and UNITS_PER_SIMD_WORD\n-     defaults to 0 if it is not defined by the target.  */\n-  int units_per_simd_word = UNITS_PER_SIMD_WORD;\n-\n   /*\n      This pass will require a cost model to guide it whether to apply peeling \n      or versioning or a combination of the two. For example, the scheme that\n@@ -1237,7 +1230,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t\t  int drsize = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr))));\n \n \t\t  DR_MISALIGNMENT (dr) += npeel * drsize;\n-\t\t  DR_MISALIGNMENT (dr) %= units_per_simd_word;\n+\t\t  DR_MISALIGNMENT (dr) %= UNITS_PER_SIMD_WORD;\n \t\t}\n \t      else\n \t\tDR_MISALIGNMENT (dr) = -1;"}, {"sha": "68222e95ce512329d9392e3267b99ca877858a5d", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "patch": "@@ -720,6 +720,32 @@ vectorizable_assignment (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n }\n \n \n+/* Function vect_min_worthwhile_factor.\n+\n+   For a loop where we could vectorize the operation indicated by CODE,\n+   return the minimum vectorization factor that makes it worthwhile\n+   to use generic vectors.  */\n+static int\n+vect_min_worthwhile_factor (enum tree_code code)\n+{\n+  switch (code)\n+    {\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case NEGATE_EXPR:\n+      return 4;\n+\n+    case BIT_AND_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+    case BIT_NOT_EXPR:\n+      return 2;\n+\n+    default:\n+      return INT_MAX;\n+    }\n+}\n+\n /* Function vectorizable_operation.\n \n    Check if STMT performs a binary or unary operation that can be vectorized. \n@@ -792,6 +818,16 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       return false;\n     }\n \n+  /* Worthwhile without SIMD support?  */\n+  if (!VECTOR_MODE_P (TYPE_MODE (vectype))\n+      && LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n+\t < vect_min_worthwhile_factor (code))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\tfprintf (vect_dump, \"not worthwhile without SIMD support.\");\n+      return false;\n+    }\n+\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = op_vec_info_type;"}, {"sha": "2285bb1cad56b72c5f5c9e57ea02a07baa21e59b", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=c4336539b95d8ec3ff5b25d72eee0c4f47c4edd7", "patch": "@@ -1525,7 +1525,7 @@ get_vectype_for_scalar_type (tree scalar_type)\n   int nunits;\n   tree vectype;\n \n-  if (nbytes == 0)\n+  if (nbytes == 0 || nbytes >= UNITS_PER_SIMD_WORD)\n     return NULL_TREE;\n \n   /* FORNOW: Only a single vector size per target (UNITS_PER_SIMD_WORD)\n@@ -1548,11 +1548,9 @@ get_vectype_for_scalar_type (tree scalar_type)\n       print_generic_expr (vect_dump, vectype, TDF_SLIM);\n     }\n \n-  if (!VECTOR_MODE_P (TYPE_MODE (vectype)))\n+  if (!VECTOR_MODE_P (TYPE_MODE (vectype))\n+      && !INTEGRAL_MODE_P (TYPE_MODE (vectype)))\n     {\n-      /* TODO: tree-complex.c sometimes can parallelize operations\n-         on generic vectors.  We can vectorize the loop in that case,\n-         but then we should re-run the lowering pass.  */\n       if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n         fprintf (vect_dump, \"mode not supported by target.\");\n       return NULL_TREE;\n@@ -1733,15 +1731,6 @@ vectorize_loops (struct loops *loops)\n   /* Fix the verbosity level if not defined explicitly by the user.  */\n   vect_set_dump_settings ();\n \n-  /* Does the target support SIMD?  */\n-  /* FORNOW: until more sophisticated machine modelling is in place.  */\n-  if (!UNITS_PER_SIMD_WORD)\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n-\tfprintf (vect_dump, \"vectorizer: target vector size is not defined.\");\n-      return;\n-    }\n-\n   /*  ----------- Analyze loops. -----------  */\n \n   /* If some loop was duplicated, it gets bigger number "}]}