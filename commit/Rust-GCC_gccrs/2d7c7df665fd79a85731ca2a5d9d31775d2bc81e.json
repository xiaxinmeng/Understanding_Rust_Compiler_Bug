{"sha": "2d7c7df665fd79a85731ca2a5d9d31775d2bc81e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQ3YzdkZjY2NWZkNzlhODU3MzFjYTJhNWQ5ZDMxNzc1ZDJiYzgxZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2006-01-27T20:01:55Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2006-01-27T20:01:55Z"}, "message": "re PR fortran/25324 (Wrong DW_TAG_compile_unit generated when compiling preprocessed fortran code)\n\n\tPR fortran/25324\n\t* Make-lang.in (fortran/scanner.o): Depend on toplev.h.\n\t* lang.opt (fpreprocessed): New option.\n\t* scanner.c: Include toplev.h.\n\t(gfc_src_file, gfc_src_preprocessor_lines): New variables.\n\t(preprocessor_line): Unescape filename if there were any\n\tbackslashes.\n\t(load_file): If initial and gfc_src_file is not NULL,\n\tuse it rather than opening the file.  If gfc_src_preprocessor_lines\n\thas non-NULL elements, pass it to preprocessor_line.\n\t(unescape_filename, gfc_read_orig_filename): New functions.\n\t* gfortran.h (gfc_option_t): Add flag_preprocessed.\n\t(gfc_read_orig_filename): New prototype.\n\t* options.c (gfc_init_options): Clear flag_preprocessed.\n\t(gfc_post_options): If flag_preprocessed, call\n\tgfc_read_orig_filename.\n\t(gfc_handle_option): Handle OPT_fpreprocessed.\n\t* lang-specs.h: Pass -fpreprocessed to f951 if preprocessing\n\tsources.\n\nFrom-SVN: r110304", "tree": {"sha": "b37f5669c2cae6d982523e270287247aebe416d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b37f5669c2cae6d982523e270287247aebe416d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d7c7df665fd79a85731ca2a5d9d31775d2bc81e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d7c7df665fd79a85731ca2a5d9d31775d2bc81e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d7c7df665fd79a85731ca2a5d9d31775d2bc81e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d7c7df665fd79a85731ca2a5d9d31775d2bc81e/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "602ea4d30716a6c72c6ee7fc8207a87e58a40d80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/602ea4d30716a6c72c6ee7fc8207a87e58a40d80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/602ea4d30716a6c72c6ee7fc8207a87e58a40d80"}], "stats": {"total": 234, "additions": 220, "deletions": 14}, "files": [{"sha": "37f100d4ce7c89546d61f8584e2f0b8a5c542766", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d7c7df665fd79a85731ca2a5d9d31775d2bc81e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d7c7df665fd79a85731ca2a5d9d31775d2bc81e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=2d7c7df665fd79a85731ca2a5d9d31775d2bc81e", "patch": "@@ -1,3 +1,25 @@\n+2006-01-27  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/25324\n+\t* Make-lang.in (fortran/scanner.o): Depend on toplev.h.\n+\t* lang.opt (fpreprocessed): New option.\n+\t* scanner.c: Include toplev.h.\n+\t(gfc_src_file, gfc_src_preprocessor_lines): New variables.\n+\t(preprocessor_line): Unescape filename if there were any\n+\tbackslashes.\n+\t(load_file): If initial and gfc_src_file is not NULL,\n+\tuse it rather than opening the file.  If gfc_src_preprocessor_lines\n+\thas non-NULL elements, pass it to preprocessor_line.\n+\t(unescape_filename, gfc_read_orig_filename): New functions.\n+\t* gfortran.h (gfc_option_t): Add flag_preprocessed.\n+\t(gfc_read_orig_filename): New prototype.\n+\t* options.c (gfc_init_options): Clear flag_preprocessed.\n+\t(gfc_post_options): If flag_preprocessed, call\n+\tgfc_read_orig_filename.\n+\t(gfc_handle_option): Handle OPT_fpreprocessed.\n+\t* lang-specs.h: Pass -fpreprocessed to f951 if preprocessing\n+\tsources.\n+\n 2005-01-27  Erik Edelmann  <eedelman@gcc.gnu.org>\n \n \t* symbol.c (free_old_symbol): Fix confusing comment, and add code"}, {"sha": "622892823ed42dcf480791f3d11622190a4baebe", "filename": "gcc/fortran/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d7c7df665fd79a85731ca2a5d9d31775d2bc81e/gcc%2Ffortran%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d7c7df665fd79a85731ca2a5d9d31775d2bc81e/gcc%2Ffortran%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FMake-lang.in?ref=2d7c7df665fd79a85731ca2a5d9d31775d2bc81e", "patch": "@@ -269,6 +269,7 @@ GFORTRAN_TRANS_DEPS = fortran/gfortran.h fortran/intrinsic.h fortran/trans-array\n \n fortran/f95-lang.o: $(GFORTRAN_TRANS_DEPS) fortran/mathbuiltins.def \\\n   gt-fortran-f95-lang.h gtype-fortran.h cgraph.h $(TARGET_H)\n+fortran/scanner.o: toplev.h\n fortran/convert.o: $(GFORTRAN_TRANS_DEPS)\n fortran/trans.o: $(GFORTRAN_TRANS_DEPS)\n fortran/trans-decl.o: $(GFORTRAN_TRANS_DEPS) gt-fortran-trans-decl.h \\"}, {"sha": "c8813ec070a2281e51a564608856e59b8bd7667e", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d7c7df665fd79a85731ca2a5d9d31775d2bc81e/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d7c7df665fd79a85731ca2a5d9d31775d2bc81e/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=2d7c7df665fd79a85731ca2a5d9d31775d2bc81e", "patch": "@@ -1516,6 +1516,7 @@ typedef struct\n   int flag_no_backend;\n   int flag_pack_derived;\n   int flag_repack_arrays;\n+  int flag_preprocessed;\n   int flag_f2c;\n   int flag_automatic;\n   int flag_backslash;\n@@ -1596,6 +1597,7 @@ int gfc_peek_char (void);\n void gfc_error_recovery (void);\n void gfc_gobble_whitespace (void);\n try gfc_new_file (void);\n+const char * gfc_read_orig_filename (const char *, const char **);\n \n extern gfc_source_form gfc_current_form;\n extern const char *gfc_source_file;"}, {"sha": "eac5caa41c74ab8095d6630b7ba77992d728e1c2", "filename": "gcc/fortran/lang-specs.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d7c7df665fd79a85731ca2a5d9d31775d2bc81e/gcc%2Ffortran%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d7c7df665fd79a85731ca2a5d9d31775d2bc81e/gcc%2Ffortran%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flang-specs.h?ref=2d7c7df665fd79a85731ca2a5d9d31775d2bc81e", "patch": "@@ -1,6 +1,6 @@\n /* Contribution to the specs for the GNU Compiler Collection\n    from GNU Fortran 95 compiler.\n-   Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004, 2006 Free Software Foundation, Inc.\n \n This file is licensed under the GPL.  */\n \n@@ -15,15 +15,15 @@ This file is licensed under the GPL.  */\n       %{E|M|MM:%(cpp_debug_options)}\\\n       %{!M:%{!MM:%{!E: -o %|.f |\\n\\\n     f951 %|.f %{!ffree-form:-ffixed-form} %(cc1_options) %{J*} %{I*}\\\n-      %{!fsyntax-only:%(invoke_as)}}}}\", 0, 0, 0},\n+      -fpreprocessed %{!fsyntax-only:%(invoke_as)}}}}\", 0, 0, 0},\n {\".F90\", \"@f95-cpp-input\", 0, 0, 0},\n {\".F95\", \"@f95-cpp-input\", 0, 0, 0},\n {\"@f95-cpp-input\",\n   \"cc1 -E -lang-fortran -traditional-cpp -D_LANGUAGE_FORTRAN %(cpp_options) \\\n       %{E|M|MM:%(cpp_debug_options)}\\\n       %{!M:%{!MM:%{!E: -o %|.f95 |\\n\\\n     f951 %|.f95 %(cc1_options) %{J*} %{I*}\\\n-      %{!fsyntax-only:%(invoke_as)}}}}\", 0, 0, 0},\n+      -fpreprocessed %{!fsyntax-only:%(invoke_as)}}}}\", 0, 0, 0},\n {\".f90\", \"@f95\", 0, 0, 0},\n {\".f95\", \"@f95\", 0, 0, 0},\n {\"@f95\", \"%{!E:f951 %i %(cc1_options) %{J*} %{I*}\\"}, {"sha": "465d589813a6753ec20e8ff518e5396cf44ce817", "filename": "gcc/fortran/lang.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d7c7df665fd79a85731ca2a5d9d31775d2bc81e/gcc%2Ffortran%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d7c7df665fd79a85731ca2a5d9d31775d2bc81e/gcc%2Ffortran%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flang.opt?ref=2d7c7df665fd79a85731ca2a5d9d31775d2bc81e", "patch": "@@ -173,6 +173,10 @@ frepack-arrays\n Fortran\n Copy array sections into a contiguous block on procedure entry\n \n+fpreprocessed\n+Fortran\n+Treat the input file as preprocessed\n+\n qkind=\n Fortran RejectNegative Joined UInteger\n -qkind=<n>\tSet the kind for a real with the 'q' exponent to 'n'"}, {"sha": "d65827c9bb3181721ecc0fc49bb42fa07be6a231", "filename": "gcc/fortran/options.c", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d7c7df665fd79a85731ca2a5d9d31775d2bc81e/gcc%2Ffortran%2Foptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d7c7df665fd79a85731ca2a5d9d31775d2bc81e/gcc%2Ffortran%2Foptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Foptions.c?ref=2d7c7df665fd79a85731ca2a5d9d31775d2bc81e", "patch": "@@ -72,6 +72,7 @@ gfc_init_options (unsigned int argc ATTRIBUTE_UNUSED,\n   gfc_option.flag_no_backend = 0;\n   gfc_option.flag_pack_derived = 0;\n   gfc_option.flag_repack_arrays = 0;\n+  gfc_option.flag_preprocessed = 0;\n   gfc_option.flag_automatic = 1;\n   gfc_option.flag_backslash = 1;\n   gfc_option.flag_cray_pointer = 0;\n@@ -172,7 +173,7 @@ form_from_filename (const char *filename)\n bool\n gfc_post_options (const char **pfilename)\n {\n-  const char *filename = *pfilename;\n+  const char *filename = *pfilename, *canon_source_file = NULL;\n   char *source_path;\n   int i;\n \n@@ -182,23 +183,40 @@ gfc_post_options (const char **pfilename)\n       filename = \"\";\n     }\n \n-  gfc_source_file = filename;\n+  if (gfc_option.flag_preprocessed)\n+    {\n+      /* For preprocessed files, if the first tokens are of the form # NUM.\n+\t handle the directives so we know the original file name.  */\n+      gfc_source_file = gfc_read_orig_filename (filename, &canon_source_file);\n+      if (gfc_source_file == NULL)\n+\tgfc_source_file = filename;\n+      else\n+\t*pfilename = gfc_source_file;\n+    }\n+  else\n+    gfc_source_file = filename;\n+\n+  if (canon_source_file == NULL)\n+    canon_source_file = gfc_source_file;\n \n   /* Adds the path where the source file is to the list of include files.  */\n \n-  i = strlen(gfc_source_file);\n-  while (i > 0 && !IS_DIR_SEPARATOR(gfc_source_file[i]))\n+  i = strlen (canon_source_file);\n+  while (i > 0 && !IS_DIR_SEPARATOR (canon_source_file[i]))\n     i--;\n   if (i != 0)\n     {\n       source_path = alloca (i + 1);\n-      memcpy (source_path, gfc_source_file, i);\n+      memcpy (source_path, canon_source_file, i);\n       source_path[i] = 0;\n       gfc_add_include_path (source_path);\n     }\n   else\n     gfc_add_include_path (\".\");\n \n+  if (canon_source_file != gfc_source_file)\n+    gfc_free ((void *) canon_source_file);\n+\n   /* Decide which form the file will be read in as.  */\n \n   if (gfc_option.source_form != FORM_UNKNOWN)\n@@ -211,7 +229,7 @@ gfc_post_options (const char **pfilename)\n \t{\n \t  gfc_current_form = FORM_FREE;\n \t  gfc_warning_now (\"Reading file '%s' as free form.\", \n-\t\t\t   (filename[0] == '\\0') ? \"<stdin>\" : filename); \n+\t\t\t   (filename[0] == '\\0') ? \"<stdin>\" : filename);\n \t}\n     }\n \n@@ -478,6 +496,10 @@ gfc_handle_option (size_t scode, const char *arg, int value)\n       gfc_option.flag_repack_arrays = value;\n       break;\n \n+    case OPT_fpreprocessed:\n+      gfc_option.flag_preprocessed = value;\n+      break;\n+\n     case OPT_fmax_identifier_length_:\n       if (value > GFC_MAX_SYMBOL_LEN)\n \tgfc_fatal_error (\"Maximum supported idenitifier length is %d\","}, {"sha": "690d6d7876611dd1f85d1e980e23197e9d74e5fe", "filename": "gcc/fortran/scanner.c", "status": "modified", "additions": 160, "deletions": 5, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d7c7df665fd79a85731ca2a5d9d31775d2bc81e/gcc%2Ffortran%2Fscanner.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d7c7df665fd79a85731ca2a5d9d31775d2bc81e/gcc%2Ffortran%2Fscanner.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fscanner.c?ref=2d7c7df665fd79a85731ca2a5d9d31775d2bc81e", "patch": "@@ -45,6 +45,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"config.h\"\n #include \"system.h\"\n #include \"gfortran.h\"\n+#include \"toplev.h\"\n \n /* Structure for holding module and include file search path.  */\n typedef struct gfc_directorylist\n@@ -66,7 +67,9 @@ static gfc_linebuf *line_head, *line_tail;\n        \n locus gfc_current_locus;\n const char *gfc_source_file;\n-      \n+static FILE *gfc_src_file;\n+static char *gfc_src_preprocessor_lines[2];\n+\n \n /* Main scanner initialization.  */\n \n@@ -861,7 +864,7 @@ preprocessor_line (char *c)\n   int i, line;\n   char *filename;\n   gfc_file *f;\n-  int escaped;\n+  int escaped, unescape;\n \n   c++;\n   while (*c == ' ' || *c == '\\t')\n@@ -892,13 +895,17 @@ preprocessor_line (char *c)\n   filename = c;\n \n   /* Make filename end at quote.  */\n+  unescape = 0;\n   escaped = false;\n   while (*c && ! (! escaped && *c == '\"'))\n     {\n       if (escaped)\n         escaped = false;\n-      else\n-        escaped = *c == '\\\\';\n+      else if (*c == '\\\\')\n+\t{\n+\t  escaped = true;\n+\t  unescape++;\n+\t}\n       ++c;\n     }\n \n@@ -908,7 +915,23 @@ preprocessor_line (char *c)\n \n   *c++ = '\\0';\n \n+  /* Undo effects of cpp_quote_string.  */\n+  if (unescape)\n+    {\n+      char *s = filename;\n+      char *d = gfc_getmem (c - filename - unescape);\n \n+      filename = d;\n+      while (*s)\n+\t{\n+\t  if (*s == '\\\\')\n+\t    *d++ = *++s;\n+\t  else\n+\t    *d++ = *s;\n+\t  s++;\n+\t}\n+      *d = '\\0';\n+    }\n \n   /* Get flags.  */\n \n@@ -944,6 +967,8 @@ preprocessor_line (char *c)\n \t  gfc_warning_now (\"%s:%d: file %s left but not entered\",\n \t\t\t   current_file->filename, current_file->line,\n \t\t\t   filename);\n+\t  if (unescape)\n+\t    gfc_free (filename);\n \t  return;\n \t}\n       current_file = current_file->up;\n@@ -961,6 +986,8 @@ preprocessor_line (char *c)\n \n   /* Set new line number.  */\n   current_file->line = line;\n+  if (unescape)\n+    gfc_free (filename);\n   return;\n \n  bad_cpp_line:\n@@ -1045,7 +1072,13 @@ load_file (const char *filename, bool initial)\n \n   if (initial)\n     {\n-      input = gfc_open_file (filename);\n+      if (gfc_src_file)\n+\t{\n+\t  input = gfc_src_file;\n+\t  gfc_src_file = NULL;\n+\t}\n+      else\n+\tinput = gfc_open_file (filename);\n       if (input == NULL)\n \t{\n \t  gfc_error_now (\"Can't open file '%s'\", filename);\n@@ -1071,6 +1104,19 @@ load_file (const char *filename, bool initial)\n   line = NULL;\n   line_len = 0;\n \n+  if (initial && gfc_src_preprocessor_lines[0])\n+    {\n+      preprocessor_line (gfc_src_preprocessor_lines[0]);\n+      gfc_free (gfc_src_preprocessor_lines[0]);\n+      gfc_src_preprocessor_lines[0] = NULL;\n+      if (gfc_src_preprocessor_lines[1])\n+\t{\n+\t  preprocessor_line (gfc_src_preprocessor_lines[1]);\n+\t  gfc_free (gfc_src_preprocessor_lines[1]);\n+\t  gfc_src_preprocessor_lines[1] = NULL;\n+\t}\n+    }\n+\n   for (;;)\n     {\n       int trunc = load_line (input, &line, &line_len);\n@@ -1159,3 +1205,112 @@ gfc_new_file (void)\n \n   return result;\n }\n+\n+static char *\n+unescape_filename (const char *ptr)\n+{\n+  const char *p = ptr, *s;\n+  char *d, *ret;\n+  int escaped, unescape = 0;\n+\n+  /* Make filename end at quote.  */\n+  escaped = false;\n+  while (*p && ! (! escaped && *p == '\"'))\n+    {\n+      if (escaped)\n+\tescaped = false;\n+      else if (*p == '\\\\')\n+\t{\n+\t  escaped = true;\n+\t  unescape++;\n+\t}\n+      ++p;\n+    }\n+\n+  if (! *p || p[1])\n+    return NULL;\n+\n+  /* Undo effects of cpp_quote_string.  */\n+  s = ptr;\n+  d = gfc_getmem (p + 1 - ptr - unescape);\n+  ret = d;\n+\n+  while (s != p)\n+    {\n+      if (*s == '\\\\')\n+\t*d++ = *++s;\n+      else\n+\t*d++ = *s;\n+      s++;\n+    }\n+  *d = '\\0';\n+  return ret;\n+}\n+\n+/* For preprocessed files, if the first tokens are of the form # NUM.\n+   handle the directives so we know the original file name.  */\n+\n+const char *\n+gfc_read_orig_filename (const char *filename, const char **canon_source_file)\n+{\n+  int c, len;\n+  char *dirname;\n+\n+  gfc_src_file = gfc_open_file (filename);\n+  if (gfc_src_file == NULL)\n+    return NULL;\n+\n+  c = fgetc (gfc_src_file);\n+  ungetc (c, gfc_src_file);\n+\n+  if (c != '#')\n+    return NULL;\n+\n+  len = 0;\n+  load_line (gfc_src_file, &gfc_src_preprocessor_lines[0], &len);\n+\n+  if (strncmp (gfc_src_preprocessor_lines[0], \"# 1 \\\"\", 5) != 0)\n+    return NULL;\n+\n+  filename = unescape_filename (gfc_src_preprocessor_lines[0] + 5);\n+  if (filename == NULL)\n+    return NULL;\n+\n+  c = fgetc (gfc_src_file);\n+  ungetc (c, gfc_src_file);\n+\n+  if (c != '#')\n+    return filename;\n+\n+  len = 0;\n+  load_line (gfc_src_file, &gfc_src_preprocessor_lines[1], &len);\n+\n+  if (strncmp (gfc_src_preprocessor_lines[1], \"# 1 \\\"\", 5) != 0)\n+    return filename;\n+\n+  dirname = unescape_filename (gfc_src_preprocessor_lines[1] + 5);\n+  if (dirname == NULL)\n+    return filename;\n+\n+  len = strlen (dirname);\n+  if (len < 3 || dirname[len - 1] != '/' || dirname[len - 2] != '/')\n+    {\n+      gfc_free (dirname);\n+      return filename;\n+    }\n+  dirname[len - 2] = '\\0';\n+  set_src_pwd (dirname);\n+\n+  if (! IS_ABSOLUTE_PATH (filename))\n+    {\n+      char *p = gfc_getmem (len + strlen (filename));\n+\n+      memcpy (p, dirname, len - 2);\n+      p[len - 2] = '/';\n+      strcpy (p + len - 1, filename);\n+      *canon_source_file = p;\n+    }\n+\n+  gfc_free (dirname);\n+  return filename;\n+}"}]}