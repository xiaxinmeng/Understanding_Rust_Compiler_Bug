{"sha": "db89d474ad812e57895cb8866ebaeedad0cc3e3f", "node_id": "C_kwDOANBUbNoAKGRiODlkNDc0YWQ4MTJlNTc4OTVjYjg4NjZlYmFlZWRhZDBjYzNlM2Y", "commit": {"author": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2021-11-05T16:07:35Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2021-11-05T16:07:35Z"}, "message": "Support TI mode and soft float on PA64\n\nThis change implements TI mode on PA64.  Various new patterns are\nadded to pa.md.  The libgcc build needed modification to build both\nDI and TI routines.  We also need various softfp routines to\nconvert to and from TImode.\n\nI added full softfp for the -msoft-float option.  At the moment,\nthis doesn't completely eliminate all use of the floating-point\nco-processor.  For this, libgcc needs to be built with -msoft-mult.\nThe floating-point exception support also needs a soft option.\n\n2021-11-05  John David Anglin  <danglin@gcc.gnu.org>\n\n\tPR libgomp/96661\n\ngcc/ChangeLog:\n\n\t* config/pa/pa-modes.def: Add OImode integer type.\n\t* config/pa/pa.c (pa_scalar_mode_supported_p): Allow TImode\n\tfor TARGET_64BIT.\n\t* config/pa/pa.h (MIN_UNITS_PER_WORD) Define to MIN_UNITS_PER_WORD\n\tto UNITS_PER_WORD if IN_LIBGCC2.\n\t* config/pa/pa.md (addti3, addvti3, subti3, subvti3, negti2,\n\tnegvti2, ashlti3, shrpd_internal): New patterns.\n\tChange some multi instruction types to multi.\n\nlibgcc/ChangeLog:\n\n\t* config.host (hppa*64*-*-linux*): Revise tmake_file.\n\t(hppa*64*-*-hpux11*): Likewise.\n\t* config/pa/sfp-exceptions.c: New.\n\t* config/pa/sfp-machine.h: New.\n\t* config/pa/t-dimode: New.\n\t* config/pa/t-softfp-sfdftf: New.", "tree": {"sha": "19a626b97100d137525c01f398c19dcfa158e8ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19a626b97100d137525c01f398c19dcfa158e8ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db89d474ad812e57895cb8866ebaeedad0cc3e3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db89d474ad812e57895cb8866ebaeedad0cc3e3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db89d474ad812e57895cb8866ebaeedad0cc3e3f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db89d474ad812e57895cb8866ebaeedad0cc3e3f/comments", "author": null, "committer": null, "parents": [{"sha": "858d7ee1a0cd97c01d844ea73ab81918da738344", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/858d7ee1a0cd97c01d844ea73ab81918da738344", "html_url": "https://github.com/Rust-GCC/gccrs/commit/858d7ee1a0cd97c01d844ea73ab81918da738344"}], "stats": {"total": 498, "additions": 483, "deletions": 15}, "files": [{"sha": "6020233c171a39032eed1baa580281fa30a1c34f", "filename": "gcc/config/pa/pa-modes.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db89d474ad812e57895cb8866ebaeedad0cc3e3f/gcc%2Fconfig%2Fpa%2Fpa-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db89d474ad812e57895cb8866ebaeedad0cc3e3f/gcc%2Fconfig%2Fpa%2Fpa-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-modes.def?ref=db89d474ad812e57895cb8866ebaeedad0cc3e3f", "patch": "@@ -30,3 +30,6 @@ FLOAT_MODE (TF, 16, mips_quad_format);\n \n /* HPPA floating comparisons produce distinct condition codes.  */\n CC_MODE (CCFP);\n+\n+/* Mode used for signed overflow checking of TImode.  */\n+INT_MODE (OI, 32);"}, {"sha": "f22d25a40668da4229beda985068cf5fc8456e79", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db89d474ad812e57895cb8866ebaeedad0cc3e3f/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db89d474ad812e57895cb8866ebaeedad0cc3e3f/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=db89d474ad812e57895cb8866ebaeedad0cc3e3f", "patch": "@@ -6550,18 +6550,16 @@ hppa_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n \n /* True if MODE is valid for the target.  By \"valid\", we mean able to\n    be manipulated in non-trivial ways.  In particular, this means all\n-   the arithmetic is supported.\n-\n-   Currently, TImode is not valid as the HP 64-bit runtime documentation\n-   doesn't document the alignment and calling conventions for this type. \n-   Thus, we return false when PRECISION is 2 * BITS_PER_WORD and\n-   2 * BITS_PER_WORD isn't equal LONG_LONG_TYPE_SIZE.  */\n+   the arithmetic is supported.  */\n \n static bool\n pa_scalar_mode_supported_p (scalar_mode mode)\n {\n   int precision = GET_MODE_PRECISION (mode);\n \n+  if (TARGET_64BIT && mode == TImode)\n+    return true;\n+\n   switch (GET_MODE_CLASS (mode))\n     {\n     case MODE_PARTIAL_INT:"}, {"sha": "96815ec69cbb891b904733b011fa722dd07f2373", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db89d474ad812e57895cb8866ebaeedad0cc3e3f/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db89d474ad812e57895cb8866ebaeedad0cc3e3f/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=db89d474ad812e57895cb8866ebaeedad0cc3e3f", "patch": "@@ -258,11 +258,17 @@ typedef struct GTY(()) machine_function\n    is UNITS_PER_WORD.  Otherwise, it is the constant value that is the\n    smallest value that UNITS_PER_WORD can have at run-time.\n \n-   FIXME: This needs to be 4 when TARGET_64BIT is true to suppress the\n-   building of various TImode routines in libgcc.  The HP runtime\n-   specification doesn't provide the alignment requirements and calling\n-   conventions for TImode variables.  */\n-#define MIN_UNITS_PER_WORD 4\n+   This needs to be 8 when TARGET_64BIT is true to allow building various\n+   TImode routines in libgcc.  However, we also need the DImode DIVMOD\n+   routines because they are not currently implemented in pa.md.\n+   \n+   The HP runtime specification doesn't provide the alignment requirements\n+   and calling conventions for TImode variables.  */\n+#ifdef IN_LIBGCC2\n+#define MIN_UNITS_PER_WORD      UNITS_PER_WORD\n+#else\n+#define MIN_UNITS_PER_WORD      4\n+#endif\n \n /* The widest floating point format supported by the hardware.  Note that\n    setting this influences some Ada floating point type sizes, currently"}, {"sha": "f124c301b7a1a44e5db0ca80382ff5d8e0d7af70", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 162, "deletions": 2, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db89d474ad812e57895cb8866ebaeedad0cc3e3f/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db89d474ad812e57895cb8866ebaeedad0cc3e3f/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=db89d474ad812e57895cb8866ebaeedad0cc3e3f", "patch": "@@ -5357,6 +5357,88 @@\n   [(set_attr \"type\" \"binary,binary\")\n    (set_attr \"length\" \"4,4\")])\n \n+(define_insn \"addti3\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=r\")\n+\t(plus:TI (match_operand:TI 1 \"register_operand\" \"r\")\n+\t\t (match_operand:TI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  operands[3] = gen_lowpart (DImode, operands[0]);\n+  operands[4] = gen_lowpart (DImode, operands[1]);\n+  operands[5] = gen_lowpart (DImode, operands[2]);\n+  operands[0] = gen_highpart (DImode, operands[0]);\n+  operands[1] = gen_highpart (DImode, operands[1]);\n+  operands[2] = gen_highpart (DImode, operands[2]);\n+  return \\\"add %4,%5,%3\\;add,dc %1,%2,%0\\\";\n+}\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"addvti3\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=r\")\n+\t(plus:TI (match_operand:TI 1 \"register_operand\" \"r\")\n+\t\t (match_operand:TI 2 \"register_operand\" \"r\")))\n+   (trap_if (ne (plus:OI (sign_extend:OI (match_dup 1))\n+\t\t\t (sign_extend:OI (match_dup 2)))\n+\t\t(sign_extend:OI (plus:TI (match_dup 1)\n+\t\t\t\t\t (match_dup 2))))\n+\t    (const_int 0))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  operands[3] = gen_lowpart (DImode, operands[0]);\n+  operands[4] = gen_lowpart (DImode, operands[1]);\n+  operands[5] = gen_lowpart (DImode, operands[2]);\n+  operands[0] = gen_highpart (DImode, operands[0]);\n+  operands[1] = gen_highpart (DImode, operands[1]);\n+  operands[2] = gen_highpart (DImode, operands[2]);\n+  return \\\"add %4,%5,%3\\;add,dc,tsv %1,%2,%0\\\";\n+}\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"subti3\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=r\")\n+\t(minus:TI (match_operand:TI 1 \"register_operand\" \"r\")\n+\t\t  (match_operand:TI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  operands[3] = gen_lowpart (DImode, operands[0]);\n+  operands[4] = gen_lowpart (DImode, operands[1]);\n+  operands[5] = gen_lowpart (DImode, operands[2]);\n+  operands[0] = gen_highpart (DImode, operands[0]);\n+  operands[1] = gen_highpart (DImode, operands[1]);\n+  operands[2] = gen_highpart (DImode, operands[2]);\n+  return \\\"sub %4,%5,%3\\;sub,db %1,%2,%0\\\";\n+}\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"subvti3\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=r\")\n+\t(minus:TI (match_operand:TI 1 \"register_operand\" \"r\")\n+\t\t  (match_operand:TI 2 \"register_operand\" \"r\")))\n+   (trap_if (ne (minus:OI (sign_extend:OI (match_dup 1))\n+\t\t\t  (sign_extend:OI (match_dup 2)))\n+\t\t(sign_extend:OI (minus:TI (match_dup 1)\n+\t\t\t\t\t  (match_dup 2))))\n+\t    (const_int 0))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  operands[3] = gen_lowpart (DImode, operands[0]);\n+  operands[4] = gen_lowpart (DImode, operands[1]);\n+  operands[5] = gen_lowpart (DImode, operands[2]);\n+  operands[0] = gen_highpart (DImode, operands[0]);\n+  operands[1] = gen_highpart (DImode, operands[1]);\n+  operands[2] = gen_highpart (DImode, operands[2]);\n+  return \\\"sub %4,%5,%3\\;sub,db,tsv %1,%2,%0\\\";\n+}\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"8\")])\n+\n ;; Trap instructions.\n \n (define_insn \"trap\"\n@@ -5897,7 +5979,7 @@\n \t(neg:DI (match_operand:DI 1 \"register_operand\" \"r\")))]\n   \"!TARGET_64BIT\"\n   \"sub %%r0,%R1,%R0\\;{subb|sub,b} %%r0,%1,%0\"\n-  [(set_attr \"type\" \"unary\")\n+  [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"8\")])\n \n (define_insn \"\"\n@@ -5908,6 +5990,21 @@\n   [(set_attr \"type\" \"unary\")\n    (set_attr \"length\" \"4\")])\n \n+(define_insn \"negti2\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=r\")\n+\t(neg:TI (match_operand:TI 1 \"register_operand\" \"r\")))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  operands[2] = gen_lowpart (DImode, operands[0]);\n+  operands[3] = gen_lowpart (DImode, operands[1]);\n+  operands[0] = gen_highpart (DImode, operands[0]);\n+  operands[1] = gen_highpart (DImode, operands[1]);\n+  return \\\"sub %%r0,%3,%2\\;sub,db %%r0,%1,%0\\\";\n+}\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"8\")])\n+\n (define_expand \"negvdi2\"\n   [(parallel [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t\t   (neg:DI (match_operand:DI 1 \"register_operand\" \"\")))\n@@ -5925,7 +6022,7 @@\n \t    (const_int 0))]\n   \"!TARGET_64BIT\"\n   \"sub %%r0,%R1,%R0\\;{subbo|sub,b,tsv} %%r0,%1,%0\"\n-  [(set_attr \"type\" \"unary\")\n+  [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"8\")])\n \n (define_insn \"\"\n@@ -5939,6 +6036,24 @@\n   [(set_attr \"type\" \"unary\")\n    (set_attr \"length\" \"4\")])\n \n+(define_insn \"negvti2\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=r\")\n+\t(neg:TI (match_operand:TI 1 \"register_operand\" \"r\")))\n+   (trap_if (ne (neg:OI (sign_extend:OI (match_dup 1)))\n+\t\t(sign_extend:OI (neg:TI (match_dup 1))))\n+\t    (const_int 0))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  operands[2] = gen_lowpart (DImode, operands[0]);\n+  operands[3] = gen_lowpart (DImode, operands[1]);\n+  operands[0] = gen_highpart (DImode, operands[0]);\n+  operands[1] = gen_highpart (DImode, operands[1]);\n+  return \\\"sub %%r0,%3,%2\\;sub,db,tsv %%r0,%1,%0\\\";\n+}\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"8\")])\n+\n (define_insn \"negsi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(neg:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n@@ -6566,6 +6681,42 @@\n   operands[1] = force_reg (DImode, operands[1]);\n }\")\n \n+(define_expand \"ashlti3\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"\")\n+\t(ashift:TI (match_operand:TI 1 \"lhs_lshift_operand\" \"\")\n+\t\t   (match_operand:TI 2 \"arith32_operand\" \"\")))]\n+  \"TARGET_64BIT\"\n+{\n+  if (REG_P (operands[0]) && GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      unsigned HOST_WIDE_INT shift = UINTVAL (operands[2]);\n+      rtx dst = operands[0];\n+      rtx src = force_reg (TImode, operands[1]);\n+      if (shift >= 1 && shift <= 63)\n+\t{\n+\t  emit_insn (gen_shrpd_internal (gen_highpart (DImode, dst),\n+\t\t\t\t\t gen_lowpart (DImode, src),\n+\t\t\t\t\t GEN_INT (64-shift),\n+\t\t\t\t\t gen_highpart (DImode, src),\n+\t\t\t\t\t GEN_INT (shift)));\n+\t  emit_insn (gen_ashldi3 (gen_lowpart (DImode, dst),\n+\t\t\t\t  gen_lowpart (DImode, src),\n+\t\t\t\t  GEN_INT (shift)));\n+\t  DONE;\n+\t}\n+      else if (shift >= 64 && shift <= 127)\n+\t{\n+\t  emit_insn (gen_ashldi3 (gen_highpart (DImode, dst),\n+\t\t\t\t  gen_lowpart (DImode, src),\n+\t\t\t\t  GEN_INT (shift - 64)));\n+\t  emit_move_insn (gen_lowpart (DImode, dst), GEN_INT (0));\n+\t  DONE;\n+\t}\n+    }\n+  /* Fallback to using optabs.c's expand_doubleword_shift.  */\n+  FAIL;\n+})\n+\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(ashift:DI (match_operand:DI 1 \"register_operand\" \"r\")\n@@ -6944,6 +7095,15 @@\n \t\t     (match_operand:SI 4 \"const_int_operand\"))))]\n   \"\")\n \n+(define_expand \"shrpd_internal\"\n+  [(set (match_operand:DI 0 \"register_operand\")\n+\t(ior:DI\n+\t  (lshiftrt:DI (match_operand:DI 1 \"register_operand\")\n+\t\t       (match_operand:DI 2 \"const_int_operand\"))\n+\t  (ashift:DI (match_operand:DI 3 \"register_operand\")\n+\t\t     (match_operand:DI 4 \"const_int_operand\"))))]\n+  \"TARGET_64BIT\")\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(and:SI (ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")"}, {"sha": "168535b1780dca803b4cff73961afc40058174a1", "filename": "libgcc/config.host", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db89d474ad812e57895cb8866ebaeedad0cc3e3f/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db89d474ad812e57895cb8866ebaeedad0cc3e3f/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=db89d474ad812e57895cb8866ebaeedad0cc3e3f", "patch": "@@ -619,7 +619,8 @@ h8300-*-linux*)\n \ttm_file=\"$tm_file h8300/h8300-lib.h\"\n \t;;\n hppa*64*-*-linux*)\n-\ttmake_file=\"$tmake_file pa/t-linux64\"\n+\ttmake_file=\"$tmake_file pa/t-linux64 pa/t-dimode\"\n+\ttmake_file=\"$tmake_file pa/t-softfp-sfdftf t-softfp\"\n \textra_parts=\"crtbegin.o crtbeginS.o crtbeginT.o crtend.o crtendS.o\"\n \t;;\n hppa*-*-linux*)\n@@ -645,14 +646,16 @@ hppa[12]*-*-hpux10*)\n \tmd_unwind_header=pa/hpux-unwind.h\n \t;;\n hppa*64*-*-hpux11*)\n-\ttmake_file=\"$tmake_file pa/t-hpux pa/t-pa64 pa/t-stublib t-libgcc-pic t-slibgcc\"\n+\ttmake_file=\"$tmake_file pa/t-hpux pa/t-pa64 pa/t-dimode\"\n+\ttmake_file=\"$tmake_file pa/t-stublib t-libgcc-pic t-slibgcc\"\n \t# Set the libgcc version number\n \tif test x$ac_cv_sjlj_exceptions = xyes; then\n \t    tmake_file=\"$tmake_file pa/t-slibgcc-sjlj-ver\"\n \telse\n \t    tmake_file=\"$tmake_file pa/t-slibgcc-dwarf-ver\"\n \tfi\n \ttmake_file=\"$tmake_file pa/t-slibgcc-hpux t-slibgcc-hpux\"\n+\ttmake_file=\"$tmake_file pa/t-softfp-sfdftf t-softfp\"\n \ttm_file=\"$tm_file pa/pa64-hpux-lib.h\"\n \textra_parts=\"crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o \\\n \t\t     libgcc_stub.a\""}, {"sha": "4dadaf43d17851fdfce196f01f28ddac2bdd472c", "filename": "libgcc/config/pa/sfp-exceptions.c", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db89d474ad812e57895cb8866ebaeedad0cc3e3f/libgcc%2Fconfig%2Fpa%2Fsfp-exceptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db89d474ad812e57895cb8866ebaeedad0cc3e3f/libgcc%2Fconfig%2Fpa%2Fsfp-exceptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fpa%2Fsfp-exceptions.c?ref=db89d474ad812e57895cb8866ebaeedad0cc3e3f", "patch": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright (C) 1997-2021 Free Software Foundation, Inc.\n+ *\n+ * This file is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License as published by the\n+ * Free Software Foundation; either version 3, or (at your option) any\n+ * later version.\n+ *\n+ * This file is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * General Public License for more details.\n+ *\n+ * Under Section 7 of GPL version 3, you are granted additional\n+ * permissions described in the GCC Runtime Library Exception, version\n+ * 3.1, as published by the Free Software Foundation.\n+ *\n+ * You should have received a copy of the GNU General Public License and\n+ * a copy of the GCC Runtime Library Exception along with this program;\n+ * see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+ * <http://www.gnu.org/licenses/>.\n+ */\n+\n+\n+#include \"sfp-machine.h\"\n+\n+#define HUGE_VAL (__builtin_huge_val ())\n+\n+/* Please see section 10,\n+   page 10-5 \"Delayed Trapping\" in the PA-RISC 2.0 Architecture manual */\n+\n+void\n+__sfp_handle_exceptions (int _fex)\n+{\n+  /* Raise exceptions represented by _FEX.  But we must raise only one\n+     signal at a time.  It is important that if the overflow/underflow\n+     exception and the divide by zero exception are given at the same\n+     time, the overflow/underflow exception follows the divide by zero\n+     exception.  */\n+\n+  /* We do these bits in assembly to be certain GCC doesn't optimize\n+     away something important, and so we can force delayed traps to\n+     occur. */\n+\n+  /* We use \"fldd 0(%%sr0,%%sp),%0\" to flush the delayed exception */\n+\n+  /* First: Invalid exception.  */\n+  if (_fex & FP_EX_INVALID)\n+    {\n+      /* One example of an invalid operation is 0 * Infinity.  */\n+      double d = HUGE_VAL;\n+      __asm__ __volatile__ (\n+\t\t\"\tfcpy,dbl %%fr0,%%fr22\\n\"\n+\t\t\"\tfmpy,dbl %0,%%fr22,%0\\n\"\n+\t\t\"\tfldd 0(%%sr0,%%sp),%0\"\n+\t\t: \"+f\" (d) : : \"%fr22\" );\n+    }\n+\n+  /* Second: Division by zero.  */\n+  if (_fex & FP_EX_DIVZERO)\n+    {\n+      double d = 1.0;\n+      __asm__ __volatile__ (\n+\t\t\"\tfcpy,dbl %%fr0,%%fr22\\n\"\n+\t\t\"\tfdiv,dbl %0,%%fr22,%0\\n\"\n+\t\t\"\tfldd 0(%%sr0,%%sp),%0\"\n+\t\t: \"+f\" (d) : : \"%fr22\" );\n+    }\n+\n+  /* Third: Overflow.  */\n+  if (_fex & FP_EX_OVERFLOW)\n+    {\n+      double d = __DBL_MAX__;\n+      __asm__ __volatile__ (\n+\t\t\"\tfadd,dbl %0,%0,%0\\n\"\n+\t\t\"\tfldd 0(%%sr0,%%sp),%0\"\n+\t\t: \"+f\" (d) );\n+    }\n+\n+  /* Fourth: Underflow.  */\n+  if (_fex & FP_EX_UNDERFLOW)\n+    {\n+      double d = __DBL_MIN__;\n+      double e = 3.0;\n+      __asm__ __volatile__ (\n+\t\t\"\tfdiv,dbl %0,%1,%0\\n\"\n+\t\t\"\tfldd 0(%%sr0,%%sp),%0\"\n+\t\t: \"+f\" (d) : \"f\" (e) );\n+    }\n+\n+  /* Fifth: Inexact */\n+  if (_fex & FP_EX_INEXACT)\n+    {\n+      double d = 3.14159265358979323846;\n+      double e = 69.69;\n+      __asm__ __volatile__ (\n+\t\t\"\tfdiv,dbl %0,%1,%%fr22\\n\"\n+\t\t\"\tfcnvfxt,dbl,sgl %%fr22,%%fr22L\\n\"\n+\t\t\"\tfldd 0(%%sr0,%%sp),%%fr22\"\n+\t\t: : \"f\" (d), \"f\" (e) : \"%fr22\" );\n+    }\n+}"}, {"sha": "661b1cf2cf41bc08aa0db6b5f38fa224c8028fe0", "filename": "libgcc/config/pa/sfp-machine.h", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db89d474ad812e57895cb8866ebaeedad0cc3e3f/libgcc%2Fconfig%2Fpa%2Fsfp-machine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db89d474ad812e57895cb8866ebaeedad0cc3e3f/libgcc%2Fconfig%2Fpa%2Fsfp-machine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fpa%2Fsfp-machine.h?ref=db89d474ad812e57895cb8866ebaeedad0cc3e3f", "patch": "@@ -0,0 +1,155 @@\n+/* softfp machine description for PA-RISC.\n+   Copyright (C) 2009-2021 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifdef __LP64__\n+#define _FP_W_TYPE_SIZE\t\t64\n+#define _FP_W_TYPE\t\tunsigned long\n+#define _FP_WS_TYPE\t\tsigned long\n+#define _FP_I_TYPE\t\tlong\n+\n+typedef int TItype __attribute__ ((mode (TI)));\n+typedef unsigned int UTItype __attribute__ ((mode (TI)));\n+#define TI_BITS (__CHAR_BIT__ * (int) sizeof (TItype))\n+\n+#define _FP_MUL_MEAT_S(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)\n+#define _FP_MUL_MEAT_D(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)\n+#define _FP_MUL_MEAT_Q(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)\n+\n+#define _FP_DIV_MEAT_S(R,X,Y)\t_FP_DIV_MEAT_1_udiv_norm(S,R,X,Y)\n+#define _FP_DIV_MEAT_D(R,X,Y)\t_FP_DIV_MEAT_1_udiv_norm(D,R,X,Y)\n+#define _FP_DIV_MEAT_Q(R,X,Y)\t_FP_DIV_MEAT_2_udiv(Q,R,X,Y)\n+\n+#define _FP_NANFRAC_S\t\t(_FP_QNANBIT_S - 1)\n+#define _FP_NANFRAC_D\t\t(_FP_QNANBIT_D - 1)\n+#define _FP_NANFRAC_Q\t\t(_FP_QNANBIT_Q - 1), -1\n+#else\n+#define _FP_W_TYPE_SIZE\t\t32\n+#define _FP_W_TYPE\t\tunsigned int\n+#define _FP_WS_TYPE\t\tsigned int\n+#define _FP_I_TYPE\t\tint\n+\n+#define _FP_MUL_MEAT_S(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)\n+#define _FP_MUL_MEAT_D(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)\n+#define _FP_MUL_MEAT_Q(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)\n+\n+#define _FP_DIV_MEAT_S(R,X,Y)\t_FP_DIV_MEAT_1_udiv_norm(S,R,X,Y)\n+#define _FP_DIV_MEAT_D(R,X,Y)\t_FP_DIV_MEAT_2_udiv(D,R,X,Y)\n+#define _FP_DIV_MEAT_Q(R,X,Y)\t_FP_DIV_MEAT_4_udiv(Q,R,X,Y)\n+\n+#define _FP_NANFRAC_S\t\t(_FP_QNANBIT_S - 1)\n+#define _FP_NANFRAC_D\t\t(_FP_QNANBIT_D - 1), -1\n+#define _FP_NANFRAC_Q\t\t(_FP_QNANBIT_Q - 1), -1, -1, -1\n+#endif\n+\n+/* The type of the result of a floating point comparison.  This must\n+   match __libgcc_cmp_return__ in GCC for the target.  */\n+typedef int __gcc_CMPtype __attribute__ ((mode (__libgcc_cmp_return__)));\n+#define CMPtype __gcc_CMPtype\n+\n+#define _FP_NANSIGN_S\t\t0\n+#define _FP_NANSIGN_D\t\t0\n+#define _FP_NANSIGN_Q\t\t0\n+\n+#define _FP_KEEPNANFRACP\t1\n+#define _FP_QNANNEGATEDP\t1\n+\n+/* Comment from glibc: */\n+/* From my experiments it seems X is chosen unless one of the\n+   NaNs is sNaN,  in which case the result is NANSIGN/NANFRAC.  */\n+# define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    if ((_FP_FRAC_HIGH_RAW_##fs(X) |\t\t\t\t\\\n+\t _FP_FRAC_HIGH_RAW_##fs(Y)) & _FP_QNANBIT_##fs)\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tR##_s = _FP_NANSIGN_##fs;\t\t\t\t\\\n+\t_FP_FRAC_SET_##wc(R,_FP_NANFRAC_##fs);\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tR##_s = X##_s;\t\t\t\t\t\t\\\n+\t_FP_FRAC_COPY_##wc(R,X);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    R##_c = FP_CLS_NAN;\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define FP_RND_NEAREST\t\t(0 << 9)\n+#define FP_RND_ZERO\t\t(1 << 9)\n+#define FP_RND_PINF\t\t(2 << 9)\n+#define FP_RND_MINF\t\t(3 << 9)\n+#define FP_RND_MASK\t\t(3 << 9)\n+\n+#define FP_EX_INEXACT\t\t0x01\n+#define FP_EX_UNDERFLOW\t\t0x02\n+#define FP_EX_OVERFLOW\t\t0x04\n+#define FP_EX_DIVZERO\t\t0x08\n+#define FP_EX_INVALID\t\t0x10\n+#define FP_EX_ALL\t\t0x1F\n+#define FP_EX_SHIFT\t\t27\n+\n+#define _FP_TININESS_AFTER_ROUNDING 1\n+\n+#define _FP_DECL_EX \\\n+  unsigned int _fcsr __attribute__ ((unused)) = FP_RND_NEAREST\n+\n+/* Get floating-point status.  */\n+#define _FPU_GETCW(cw)\t\t\t\t\t\t\\\n+({\t\t\t\t\t\t\t\t\\\n+  union { unsigned long long __fpreg;\t\t\t\t\\\n+\t  unsigned int __halfreg[2]; } __fullfp;\t\t\\\n+  /* Get the current status word. */\t\t\t\t\\\n+  __asm__ (\"fstd %%fr0,0(%1)\\n\\t\"\t\t\t\t\\\n+\t   \"fldd 0(%1),%%fr0\\n\\t\"\t\t\t\t\\\n+\t    : \"=m\" (__fullfp.__fpreg)\t\t\t\t\\\n+\t    : \"r\" (&__fullfp.__fpreg)\t\t\t\t\\\n+\t    : \"%r0\");\t\t\t\t\t\t\\\n+  cw = __fullfp.__halfreg[0];\t\t\t\t\t\\\n+})\n+\n+#define FP_INIT_ROUNDMODE _FPU_GETCW(_fcsr)\n+#define FP_ROUNDMODE (_fcsr & FP_RND_MASK)\n+#define FP_TRAPPING_EXCEPTIONS (_fcsr & FP_EX_ALL)\n+\n+void __sfp_handle_exceptions (int);\n+\n+#define FP_HANDLE_EXCEPTIONS\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    if (__builtin_expect (_fex, 0))\t\t\t\\\n+      __sfp_handle_exceptions (_fex);\t\t\t\\\n+  } while (0)\n+\n+#define\t__LITTLE_ENDIAN\t1234\n+#define\t__BIG_ENDIAN\t4321\n+\n+#define __BYTE_ORDER __BIG_ENDIAN\n+\n+/* Define ALIASNAME as a strong alias for NAME.  */\n+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)\n+# define _strong_alias(name, aliasname) \\\n+  extern __typeof (name) aliasname __attribute__ ((alias (#name)));"}, {"sha": "1344e9376444a07a86d9faa74db382eca69aee0f", "filename": "libgcc/config/pa/t-dimode", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db89d474ad812e57895cb8866ebaeedad0cc3e3f/libgcc%2Fconfig%2Fpa%2Ft-dimode", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db89d474ad812e57895cb8866ebaeedad0cc3e3f/libgcc%2Fconfig%2Fpa%2Ft-dimode", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fpa%2Ft-dimode?ref=db89d474ad812e57895cb8866ebaeedad0cc3e3f", "patch": "@@ -0,0 +1,33 @@\n+# Extra DImode libgcc2 functions to build.\n+lib2difuncs = _muldi3 _negdi2 _lshrdi _ashldi3 _ashrdi3 _cmpdi2 _ucmpdi2\n+\n+# Build lib2difuncs.\n+lib2difuncs-o = $(patsubst %,%_di$(objext),$(lib2difuncs))\n+$(lib2difuncs-o): %_di$(objext): $(srcdir)/libgcc2.c\n+\t$(gcc_compile) -DLIBGCC2_UNITS_PER_WORD=4 -DL$* -c $< $(vis_hide)\n+libgcc-objects += $(lib2difuncs-o)\n+\n+ifeq ($(enable_shared),yes)\n+lib2difuncs-s-o = $(patsubst %,%_di_s$(objext),$(lib2difuncs))\n+$(lib2difuncs-s-o): %_di_s$(objext): $(srcdir)/libgcc2.c\n+\t$(gcc_s_compile) -DLIBGCC2_UNITS_PER_WORD=4 -DL$* -c $<\n+libgcc-s-objects += $(lib2difuncs-s-o)\n+endif\n+\n+# Extra DImode divmod functions to build.\n+lib2didivmodfuncs = _divdi3 _moddi3 _udivdi3 _umoddi3\n+\n+# Build lib2didivmodfuncs.\n+lib2didivmod-o = $(patsubst %,%_di$(objext),$(lib2didivmodfuncs))\n+$(lib2didivmod-o): %_di$(objext): $(srcdir)/libgcc2.c\n+\t$(gcc_compile) -DLIBGCC2_UNITS_PER_WORD=4 -DL$* -c $< \\\n+\t  $(LIB2_DIVMOD_EXCEPTION_FLAGS) $(vis_hide)\n+libgcc-objects += $(lib2didivmod-o)\n+\n+ifeq ($(enable_shared),yes)\n+lib2didivmod-s-o = $(patsubst %,%_di_s$(objext),$(lib2didivmodfuncs))\n+$(lib2didivmod-s-o): %_di_s$(objext): $(srcdir)/libgcc2.c\n+\t$(gcc_s_compile) -DLIBGCC2_UNITS_PER_WORD=4 -DL$* -c $< \\\n+\t  $(LIB2_DIVMOD_EXCEPTION_FLAGS)\n+libgcc-s-objects += $(lib2didivmod-s-o)\n+endif"}, {"sha": "51ff051ede215a752107c190b84e6a5f28444815", "filename": "libgcc/config/pa/t-softfp-sfdftf", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db89d474ad812e57895cb8866ebaeedad0cc3e3f/libgcc%2Fconfig%2Fpa%2Ft-softfp-sfdftf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db89d474ad812e57895cb8866ebaeedad0cc3e3f/libgcc%2Fconfig%2Fpa%2Ft-softfp-sfdftf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fpa%2Ft-softfp-sfdftf?ref=db89d474ad812e57895cb8866ebaeedad0cc3e3f", "patch": "@@ -0,0 +1,8 @@\n+# Soft float configuration for PA64\n+LIB2ADD += $(srcdir)/config/pa/sfp-exceptions.c\n+\n+softfp_float_modes := sf df tf\n+softfp_int_modes := si di ti\n+softfp_extensions := sfdf sftf dftf\n+softfp_truncations := dfsf tfsf tfdf\n+softfp_exclude_libgcc2 := n"}]}