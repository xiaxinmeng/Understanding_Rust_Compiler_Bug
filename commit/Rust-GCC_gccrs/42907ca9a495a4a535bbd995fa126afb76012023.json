{"sha": "42907ca9a495a4a535bbd995fa126afb76012023", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDI5MDdjYTlhNDk1YTRhNTM1YmJkOTk1ZmExMjZhZmI3NjAxMjAyMw==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-09-24T16:58:39Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-09-24T16:58:39Z"}, "message": "libstdc++: Specialize ranges::__detail::__box for semiregular types\n\nThe class template semiregular-box<T> defined in [range.semi.wrap] is\nused by a number of views to accomodate non-semiregular subobjects\nwhile ensuring that the overall view remains semiregular.  It provides\na stand-in default constructor, copy assignment operator and move\nassignment operator whenever the underlying type lacks them.  The\nwrapper derives from std::optional<T> to support default construction\nwhen T is not default constructible.\n\nIt would be nice for this wrapper to essentially be a no-op when the\nunderlying type is already semiregular, but this is currently not the\ncase due to its use of std::optional<T>, which incurs space overhead\ncompared to storing just T.\n\nTo that end, this patch specializes the semiregular wrapper for\nsemiregular T.  Compared to the primary template, this specialization\nuses less space, and it allows [[no_unique_address]] to optimize away\nwrapped data members whose underlying type is empty and semiregular\n(e.g. a non-capturing lambda).  This patch also applies\n[[no_unique_address]] to the five data members that use the wrapper.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/ranges (__detail::__boxable): Split out the\n\tassociated constraints of __box into here.\n\t(__detail::__box): Use the __boxable concept.  Define a leaner\n\tpartial specialization for semiregular types.\n\t(single_view::_M_value): Give it [[no_unique_address]].\n\t(filter_view::_M_pred): Likewise.\n\t(transform_view::_M_fun): Likewise.\n\t(take_while_view::_M_pred): Likewise.\n\t(drop_while_view::_M_pred):: Likewise.\n\t* testsuite/std/ranges/adaptors/detail/semiregular_box.cc: New\n\ttest.", "tree": {"sha": "ad506765bc4ff2bbeb905331e2e096e464c163a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad506765bc4ff2bbeb905331e2e096e464c163a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42907ca9a495a4a535bbd995fa126afb76012023", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42907ca9a495a4a535bbd995fa126afb76012023", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42907ca9a495a4a535bbd995fa126afb76012023", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42907ca9a495a4a535bbd995fa126afb76012023/comments", "author": null, "committer": null, "parents": [{"sha": "61f7995398a719f2ff91d07e8f8ed6d4413db697", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61f7995398a719f2ff91d07e8f8ed6d4413db697", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61f7995398a719f2ff91d07e8f8ed6d4413db697"}], "stats": {"total": 141, "additions": 135, "deletions": 6}, "files": [{"sha": "ed04fa0001d1c093f06c173f4c383796d8e3cd84", "filename": "libstdc++-v3/include/std/ranges", "status": "modified", "additions": 62, "deletions": 6, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42907ca9a495a4a535bbd995fa126afb76012023/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42907ca9a495a4a535bbd995fa126afb76012023/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges?ref=42907ca9a495a4a535bbd995fa126afb76012023", "patch": "@@ -86,7 +86,10 @@ namespace ranges\n \n   namespace __detail\n   {\n-    template<copy_constructible _Tp> requires is_object_v<_Tp>\n+    template<typename _Tp>\n+      concept __boxable = copy_constructible<_Tp> && is_object_v<_Tp>;\n+\n+    template<__boxable _Tp>\n       struct __box : std::optional<_Tp>\n       {\n \tusing std::optional<_Tp>::optional;\n@@ -130,6 +133,59 @@ namespace ranges\n \t}\n       };\n \n+    // For types which are already semiregular, this specialization of the\n+    // semiregular wrapper stores the object directly without going through\n+    // std::optional.  It provides just the subset of the primary template's\n+    // API that we currently use.\n+    template<__boxable _Tp> requires semiregular<_Tp>\n+      struct __box<_Tp>\n+      {\n+      private:\n+\t[[no_unique_address]] _Tp _M_value;\n+\n+      public:\n+\t__box() = default;\n+\n+\tconstexpr explicit\n+\t__box(const _Tp& __t)\n+\tnoexcept(is_nothrow_copy_constructible_v<_Tp>)\n+\t: _M_value{__t}\n+\t{ }\n+\n+\tconstexpr explicit\n+\t__box(_Tp&& __t)\n+\tnoexcept(is_nothrow_move_constructible_v<_Tp>)\n+\t: _M_value{std::move(__t)}\n+\t{ }\n+\n+\ttemplate<typename... _Args>\n+\t  requires constructible_from<_Tp, _Args...>\n+\t  constexpr\n+\t  __box(in_place_t, _Args&&... __args)\n+\t  noexcept(is_nothrow_constructible_v<_Tp, _Args...>)\n+\t  : _M_value{std::forward<_Args>(__args)...}\n+\t  { }\n+\n+\tconstexpr bool\n+\thas_value() const noexcept\n+\t{ return true; };\n+\n+\tconstexpr _Tp&\n+\toperator*() noexcept\n+\t{ return _M_value; }\n+\n+\tconstexpr const _Tp&\n+\toperator*() const noexcept\n+\t{ return _M_value; }\n+\n+\tconstexpr _Tp*\n+\toperator->() noexcept\n+\t{ return &_M_value; }\n+\n+\tconstexpr const _Tp*\n+\toperator->() const noexcept\n+\t{ return &_M_value; }\n+      };\n   } // namespace __detail\n \n   /// A view that contains exactly one element.\n@@ -185,7 +241,7 @@ namespace ranges\n       { return _M_value.operator->(); }\n \n     private:\n-      __detail::__box<_Tp> _M_value;\n+      [[no_unique_address]] __detail::__box<_Tp> _M_value;\n     };\n \n   namespace __detail\n@@ -1195,7 +1251,7 @@ namespace views\n       };\n \n       _Vp _M_base = _Vp();\n-      __detail::__box<_Pred> _M_pred;\n+      [[no_unique_address]] __detail::__box<_Pred> _M_pred;\n       [[no_unique_address]] __detail::_CachedPosition<_Vp> _M_cached_begin;\n \n     public:\n@@ -1533,7 +1589,7 @@ namespace views\n \t};\n \n       _Vp _M_base = _Vp();\n-      __detail::__box<_Fp> _M_fun;\n+      [[no_unique_address]] __detail::__box<_Fp> _M_fun;\n \n     public:\n       transform_view() = default;\n@@ -1787,7 +1843,7 @@ namespace views\n \t};\n \n       _Vp _M_base = _Vp();\n-      __detail::__box<_Pred> _M_pred;\n+      [[no_unique_address]] __detail::__box<_Pred> _M_pred;\n \n     public:\n       take_while_view() = default;\n@@ -1947,7 +2003,7 @@ namespace views\n     {\n     private:\n       _Vp _M_base = _Vp();\n-      __detail::__box<_Pred> _M_pred;\n+      [[no_unique_address]] __detail::__box<_Pred> _M_pred;\n       [[no_unique_address]] __detail::_CachedPosition<_Vp> _M_cached_begin;\n \n     public:"}, {"sha": "392acff3eb6c8c3f181b0cf073778f3b42a32926", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/detail/semiregular_box.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42907ca9a495a4a535bbd995fa126afb76012023/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fdetail%2Fsemiregular_box.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42907ca9a495a4a535bbd995fa126afb76012023/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fdetail%2Fsemiregular_box.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fdetail%2Fsemiregular_box.cc?ref=42907ca9a495a4a535bbd995fa126afb76012023", "patch": "@@ -0,0 +1,73 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <ranges>\n+\n+using std::ranges::__detail::__box;\n+\n+using T = decltype([] { return 0; });\n+static_assert(std::is_empty_v<__box<T>>);\n+static_assert(std::is_nothrow_copy_constructible_v<__box<T>>);\n+static_assert(std::is_nothrow_move_constructible_v<__box<T>>);\n+static_assert(std::is_nothrow_constructible_v<__box<T>, std::in_place_t>);\n+static_assert(requires (__box<T> a) {\n+  a = a;\n+  a = std::move(a);\n+  a.operator*();\n+  a.operator->();\n+  a.has_value();\n+});\n+\n+struct S\n+{\n+  S();\n+  ~S();\n+  S(const S&);\n+  S(S&&);\n+  S& operator=(const S&);\n+  S& operator=(S&&);\n+};\n+static_assert(std::is_empty_v<__box<S>>);\n+static_assert(!std::is_nothrow_copy_constructible_v<__box<S>>\n+\t      && std::is_copy_constructible_v<__box<S>>);\n+static_assert(!std::is_nothrow_move_constructible_v<__box<S>>\n+\t      && std::is_move_constructible_v<__box<S>>);\n+static_assert(!std::is_nothrow_constructible_v<__box<S>, std::in_place_t>\n+\t      && std::is_constructible_v<__box<S>, std::in_place_t>);\n+static_assert(requires (__box<S> a) {\n+  a = a;\n+  a = std::move(a);\n+  a.operator*();\n+  a.operator->();\n+  a.has_value();\n+});\n+\n+using U = decltype([i=0] { return 0; });\n+static_assert(!std::is_empty_v<__box<U>>);\n+static_assert(std::is_nothrow_copy_constructible_v<__box<U>>);\n+static_assert(std::is_nothrow_move_constructible_v<__box<U>>);\n+static_assert(!std::is_nothrow_constructible_v<__box<U>, std::in_place_t>);\n+static_assert(requires (__box<U> a) {\n+  a = a;\n+  a = std::move(a);\n+  a.operator*();\n+  a.operator->();\n+  a.has_value();\n+});"}]}