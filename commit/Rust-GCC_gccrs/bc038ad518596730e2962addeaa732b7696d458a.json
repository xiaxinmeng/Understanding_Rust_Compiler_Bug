{"sha": "bc038ad518596730e2962addeaa732b7696d458a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmMwMzhhZDUxODU5NjczMGUyOTYyYWRkZWFhNzMyYjc2OTZkNDU4YQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2006-09-02T06:55:09Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2006-09-02T06:55:09Z"}, "message": "re PR middle-end/27567 (__builtin_memcpy generates redundant stores/moves.)\n\n\tPR middle-end/27567\n\t* builtins.c (fold_builtin_memcpy, fold_builtin_memmove): Remove.\n\t(fold_builtin_mempcpy): Rename to...\n\t(fold_builtin_memory_op): ... this.  Optimize one element copy\n\tinto an assignment.\n\t(fold_builtin_memset, fold_builtin_bzero, fold_builtin_bcopy): New\n\tfunctions.\n\t(expand_builtin_strcpy, expand_builtin_strncpy): Handle COMPOUND_EXPR.\n\t(expand_builtin_memcpy, expand_builtin_mempcpy,\n\texpand_builtin_memmove): Likewise.  Use fold_builtin_memory_op.\n\t(fold_builtin_1): Handle BUILT_IN_MEMSET, BUILT_IN_BZERO and\n\tBUILT_IN_BCOPY.  Use fold_builtin_memory_op for\n\tBUILT_IN_MEM{CPY,PCPY,MOVE}.\n\nFrom-SVN: r116656", "tree": {"sha": "02d19035fad0f716f04cc6b84482344c5a902c7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02d19035fad0f716f04cc6b84482344c5a902c7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc038ad518596730e2962addeaa732b7696d458a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc038ad518596730e2962addeaa732b7696d458a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc038ad518596730e2962addeaa732b7696d458a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc038ad518596730e2962addeaa732b7696d458a/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "07515729e96d9c36052b6894c3c49afa8a2582b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07515729e96d9c36052b6894c3c49afa8a2582b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07515729e96d9c36052b6894c3c49afa8a2582b7"}], "stats": {"total": 327, "additions": 269, "deletions": 58}, "files": [{"sha": "0674f547fd827885fe3e5a2edde10145625b8591", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc038ad518596730e2962addeaa732b7696d458a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc038ad518596730e2962addeaa732b7696d458a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc038ad518596730e2962addeaa732b7696d458a", "patch": "@@ -1,3 +1,19 @@\n+2006-09-02  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/27567\n+\t* builtins.c (fold_builtin_memcpy, fold_builtin_memmove): Remove.\n+\t(fold_builtin_mempcpy): Rename to...\n+\t(fold_builtin_memory_op): ... this.  Optimize one element copy\n+\tinto an assignment.\n+\t(fold_builtin_memset, fold_builtin_bzero, fold_builtin_bcopy): New\n+\tfunctions.\n+\t(expand_builtin_strcpy, expand_builtin_strncpy): Handle COMPOUND_EXPR.\n+\t(expand_builtin_memcpy, expand_builtin_mempcpy,\n+\texpand_builtin_memmove): Likewise.  Use fold_builtin_memory_op.\n+\t(fold_builtin_1): Handle BUILT_IN_MEMSET, BUILT_IN_BZERO and\n+\tBUILT_IN_BCOPY.  Use fold_builtin_memory_op for\n+\tBUILT_IN_MEM{CPY,PCPY,MOVE}.\n+\n 2006-09-01  DJ Delorie  <dj@redhat.com>\n \n \t* config/m32c/cond.md (cbranch<mode>4): Defer splitting until after reload."}, {"sha": "1f62dcaaf00b346e5aae7605d0c0fd56487ac25e", "filename": "gcc/builtins.c", "status": "modified", "additions": 253, "deletions": 58, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc038ad518596730e2962addeaa732b7696d458a/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc038ad518596730e2962addeaa732b7696d458a/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=bc038ad518596730e2962addeaa732b7696d458a", "patch": "@@ -160,9 +160,7 @@ static tree fold_builtin_ceil (tree, tree);\n static tree fold_builtin_round (tree, tree);\n static tree fold_builtin_int_roundingfn (tree, tree);\n static tree fold_builtin_bitop (tree, tree);\n-static tree fold_builtin_memcpy (tree, tree);\n-static tree fold_builtin_mempcpy (tree, tree, int);\n-static tree fold_builtin_memmove (tree, tree);\n+static tree fold_builtin_memory_op (tree, tree, bool, int);\n static tree fold_builtin_strchr (tree, tree);\n static tree fold_builtin_memcmp (tree);\n static tree fold_builtin_strcmp (tree);\n@@ -2888,10 +2886,19 @@ expand_builtin_memcpy (tree exp, rtx target, enum machine_mode mode)\n       unsigned int dest_align\n \t= get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n       rtx dest_mem, src_mem, dest_addr, len_rtx;\n-      tree result = fold_builtin_memcpy (fndecl, arglist);\n+      tree result = fold_builtin_memory_op (arglist, TREE_TYPE (TREE_TYPE (fndecl)),\n+\t\t\t\t\t    false, /*endp=*/0);\n \n       if (result)\n-\treturn expand_expr (result, target, mode, EXPAND_NORMAL);\n+\t{\n+\t  while (TREE_CODE (result) == COMPOUND_EXPR)\n+\t    {\n+\t      expand_expr (TREE_OPERAND (result, 0), const0_rtx, VOIDmode,\n+\t\t\t   EXPAND_NORMAL);\n+\t      result = TREE_OPERAND (result, 1);\n+\t    }\n+\t  return expand_expr (result, target, mode, EXPAND_NORMAL);\n+\t}\n \n       /* If DEST is not a pointer type, call the normal function.  */\n       if (dest_align == 0)\n@@ -2977,10 +2984,18 @@ expand_builtin_mempcpy (tree arglist, tree type, rtx target, enum machine_mode m\n       unsigned int dest_align\n \t= get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n       rtx dest_mem, src_mem, len_rtx;\n-      tree result = fold_builtin_mempcpy (arglist, type, endp);\n+      tree result = fold_builtin_memory_op (arglist, type, false, endp);\n \n       if (result)\n-\treturn expand_expr (result, target, mode, EXPAND_NORMAL);\n+\t{\n+\t  while (TREE_CODE (result) == COMPOUND_EXPR)\n+\t    {\n+\t      expand_expr (TREE_OPERAND (result, 0), const0_rtx, VOIDmode,\n+\t\t\t   EXPAND_NORMAL);\n+\t      result = TREE_OPERAND (result, 1);\n+\t    }\n+\t  return expand_expr (result, target, mode, EXPAND_NORMAL);\n+\t}\n \n       /* If either SRC or DEST is not a pointer type, don't do this\n \t operation in-line.  */\n@@ -3051,10 +3066,18 @@ expand_builtin_memmove (tree arglist, tree type, rtx target,\n       unsigned int src_align = get_pointer_alignment (src, BIGGEST_ALIGNMENT);\n       unsigned int dest_align\n \t= get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n-      tree result = fold_builtin_memmove (arglist, type);\n+      tree result = fold_builtin_memory_op (arglist, type, false, /*endp=*/3);\n \n       if (result)\n-\treturn expand_expr (result, target, mode, EXPAND_NORMAL);\n+\t{\n+\t  while (TREE_CODE (result) == COMPOUND_EXPR)\n+\t    {\n+\t      expand_expr (TREE_OPERAND (result, 0), const0_rtx, VOIDmode,\n+\t\t\t   EXPAND_NORMAL);\n+\t      result = TREE_OPERAND (result, 1);\n+\t    }\n+\t  return expand_expr (result, target, mode, EXPAND_NORMAL);\n+\t}\n \n       /* If DEST is not a pointer type, call the normal function.  */\n       if (dest_align == 0)\n@@ -3202,7 +3225,15 @@ expand_builtin_strcpy (tree fndecl, tree arglist, rtx target, enum machine_mode\n     {\n       tree result = fold_builtin_strcpy (fndecl, arglist, 0);\n       if (result)\n-\treturn expand_expr (result, target, mode, EXPAND_NORMAL);\n+\t{\n+\t  while (TREE_CODE (result) == COMPOUND_EXPR)\n+\t    {\n+\t      expand_expr (TREE_OPERAND (result, 0), const0_rtx, VOIDmode,\n+\t\t\t   EXPAND_NORMAL);\n+\t      result = TREE_OPERAND (result, 1);\n+\t    }\n+\t  return expand_expr (result, target, mode, EXPAND_NORMAL);\n+\t}\n \n       return expand_movstr (TREE_VALUE (arglist),\n \t\t\t    TREE_VALUE (TREE_CHAIN (arglist)),\n@@ -3328,7 +3359,15 @@ expand_builtin_strncpy (tree exp, rtx target, enum machine_mode mode)\n       tree result = fold_builtin_strncpy (fndecl, arglist, slen);\n \n       if (result)\n-\treturn expand_expr (result, target, mode, EXPAND_NORMAL);\n+\t{\n+\t  while (TREE_CODE (result) == COMPOUND_EXPR)\n+\t    {\n+\t      expand_expr (TREE_OPERAND (result, 0), const0_rtx, VOIDmode,\n+\t\t\t   EXPAND_NORMAL);\n+\t      result = TREE_OPERAND (result, 1);\n+\t    }\n+\t  return expand_expr (result, target, mode, EXPAND_NORMAL);\n+\t}\n \n       /* We must be passed a constant len and src parameter.  */\n       if (!host_integerp (len, 1) || !slen || !host_integerp (slen, 1))\n@@ -7849,78 +7888,121 @@ fold_builtin_exponent (tree fndecl, tree arglist,\n   return 0;\n }\n \n-/* Fold function call to builtin memcpy.  Return\n+/* Fold function call to builtin memset.  Return\n    NULL_TREE if no simplification can be made.  */\n \n static tree\n-fold_builtin_memcpy (tree fndecl, tree arglist)\n+fold_builtin_memset (tree arglist, tree type, bool ignore)\n {\n-  tree dest, src, len;\n+  tree dest, c, len, var, ret;\n+  unsigned HOST_WIDE_INT length, cval;\n \n   if (!validate_arglist (arglist,\n-\t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n+\t\t\t POINTER_TYPE, INTEGER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return 0;\n \n   dest = TREE_VALUE (arglist);\n-  src = TREE_VALUE (TREE_CHAIN (arglist));\n+  c = TREE_VALUE (TREE_CHAIN (arglist));\n   len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n \n+  if (! host_integerp (len, 1))\n+    return 0;\n+\n   /* If the LEN parameter is zero, return DEST.  */\n   if (integer_zerop (len))\n-    return omit_one_operand (TREE_TYPE (TREE_TYPE (fndecl)), dest, src);\n+    return omit_one_operand (type, dest, c);\n \n-  /* If SRC and DEST are the same (and not volatile), return DEST.  */\n-  if (operand_equal_p (src, dest, 0))\n-    return omit_one_operand (TREE_TYPE (TREE_TYPE (fndecl)), dest, len);\n+  if (! host_integerp (c, 1) || TREE_SIDE_EFFECTS (dest))\n+    return 0;\n \n-  return 0;\n+  var = dest;\n+  STRIP_NOPS (var);\n+  if (TREE_CODE (var) != ADDR_EXPR)\n+    return 0;\n+\n+  var = TREE_OPERAND (var, 0);\n+  if (TREE_THIS_VOLATILE (var))\n+    return 0;\n+\n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (var))\n+      && !POINTER_TYPE_P (TREE_TYPE (var)))\n+    return 0;\n+\n+  length = tree_low_cst (len, 1);\n+  if (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (var))) != length\n+      || get_pointer_alignment (dest, BIGGEST_ALIGNMENT) / BITS_PER_UNIT\n+\t < (int) length)\n+    return 0;\n+\n+  if (length > HOST_BITS_PER_WIDE_INT / BITS_PER_UNIT)\n+    return 0;\n+\n+  if (integer_zerop (c))\n+    cval = 0;\n+  else\n+    {\n+      if (CHAR_BIT != 8 || BITS_PER_UNIT != 8 || HOST_BITS_PER_WIDE_INT > 64)\n+\treturn 0;\n+\n+      cval = tree_low_cst (c, 1);\n+      cval &= 0xff;\n+      cval |= cval << 8;\n+      cval |= cval << 16;\n+      cval |= (cval << 31) << 1;\n+    }\n+\n+  ret = build_int_cst_type (TREE_TYPE (var), cval);\n+  ret = build2 (MODIFY_EXPR, TREE_TYPE (var), var, ret);\n+  if (ignore)\n+    return ret;\n+\n+  return omit_one_operand (type, dest, ret);\n }\n \n-/* Fold function call to builtin mempcpy.  Return\n+/* Fold function call to builtin memset.  Return\n    NULL_TREE if no simplification can be made.  */\n \n static tree\n-fold_builtin_mempcpy (tree arglist, tree type, int endp)\n+fold_builtin_bzero (tree arglist, bool ignore)\n {\n-  if (validate_arglist (arglist,\n-\t\t\tPOINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n-    {\n-      tree dest = TREE_VALUE (arglist);\n-      tree src = TREE_VALUE (TREE_CHAIN (arglist));\n-      tree len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+  tree dest, size, newarglist;\n \n-      /* If the LEN parameter is zero, return DEST.  */\n-      if (integer_zerop (len))\n-\treturn omit_one_operand (type, dest, src);\n+  if (!validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n+    return 0;\n \n-      /* If SRC and DEST are the same (and not volatile), return DEST+LEN.  */\n-      if (operand_equal_p (src, dest, 0))\n-\t{\n-\t  if (endp == 0)\n-\t    return omit_one_operand (type, dest, len);\n+  if (!ignore)\n+    return 0;\n \n-\t  if (endp == 2)\n-\t    len = fold_build2 (MINUS_EXPR, TREE_TYPE (len), len,\n-\t\t\t       ssize_int (1));\n+  dest = TREE_VALUE (arglist);\n+  size = TREE_VALUE (TREE_CHAIN (arglist));\n \n-\t  len = fold_convert (TREE_TYPE (dest), len);\n-\t  len = fold_build2 (PLUS_EXPR, TREE_TYPE (dest), dest, len);\n-\t  return fold_convert (type, len);\n-\t}\n-    }\n-  return 0;\n+  /* New argument list transforming bzero(ptr x, int y) to\n+     memset(ptr x, int 0, size_t y).   This is done this way\n+     so that if it isn't expanded inline, we fallback to\n+     calling bzero instead of memset.  */\n+\n+  newarglist = build_tree_list (NULL_TREE, fold_convert (sizetype, size));\n+  newarglist = tree_cons (NULL_TREE, integer_zero_node, newarglist);\n+  newarglist = tree_cons (NULL_TREE, dest, newarglist);\n+  return fold_builtin_memset (newarglist, void_type_node, ignore);\n }\n \n-/* Fold function call to builtin memmove.  Return\n-   NULL_TREE if no simplification can be made.  */\n+/* Fold function call to builtin mem{{,p}cpy,move}.  Return\n+   NULL_TREE if no simplification can be made.\n+   If ENDP is 0, return DEST (like memcpy).\n+   If ENDP is 1, return DEST+LEN (like mempcpy).\n+   If ENDP is 2, return DEST+LEN-1 (like stpcpy).\n+   If ENDP is 3, return DEST, additionally *SRC and *DEST may overlap\n+   (memmove).   */\n \n static tree\n-fold_builtin_memmove (tree arglist, tree type)\n+fold_builtin_memory_op (tree arglist, tree type, bool ignore, int endp)\n {\n-  tree dest, src, len;\n+  tree dest, src, len, destvar, srcvar, expr;\n+  unsigned HOST_WIDE_INT length;\n \n-  if (!validate_arglist (arglist,\n-\t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n+  if (! validate_arglist (arglist,\n+\t\t\t  POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return 0;\n \n   dest = TREE_VALUE (arglist);\n@@ -7931,11 +8013,115 @@ fold_builtin_memmove (tree arglist, tree type)\n   if (integer_zerop (len))\n     return omit_one_operand (type, dest, src);\n \n-  /* If SRC and DEST are the same (and not volatile), return DEST.  */\n+  /* If SRC and DEST are the same (and not volatile), return\n+     DEST{,+LEN,+LEN-1}.  */\n   if (operand_equal_p (src, dest, 0))\n-    return omit_one_operand (type, dest, len);\n+    expr = len;\n+  else\n+    {\n+      if (! host_integerp (len, 1))\n+\treturn 0;\n \n-  return 0;\n+      if (TREE_SIDE_EFFECTS (dest) || TREE_SIDE_EFFECTS (src))\n+\treturn 0;\n+\n+      destvar = dest;\n+      STRIP_NOPS (destvar);\n+      if (TREE_CODE (destvar) != ADDR_EXPR)\n+\treturn 0;\n+\n+      destvar = TREE_OPERAND (destvar, 0);\n+      if (TREE_THIS_VOLATILE (destvar))\n+\treturn 0;\n+\n+      if (!INTEGRAL_TYPE_P (TREE_TYPE (destvar))\n+\t  && !POINTER_TYPE_P (TREE_TYPE (destvar))\n+\t  && !SCALAR_FLOAT_TYPE_P (TREE_TYPE (destvar)))\n+\treturn 0;\n+\n+      srcvar = src;\n+      STRIP_NOPS (srcvar);\n+      if (TREE_CODE (srcvar) != ADDR_EXPR)\n+\treturn 0;\n+\n+      srcvar = TREE_OPERAND (srcvar, 0);\n+      if (TREE_THIS_VOLATILE (srcvar))\n+\treturn 0;\n+\n+      if (!INTEGRAL_TYPE_P (TREE_TYPE (srcvar))\n+\t  && !POINTER_TYPE_P (TREE_TYPE (srcvar))\n+\t  && !SCALAR_FLOAT_TYPE_P (TREE_TYPE (srcvar)))\n+\treturn 0;\n+\n+      length = tree_low_cst (len, 1);\n+      if (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (destvar))) != length\n+\t  || get_pointer_alignment (dest, BIGGEST_ALIGNMENT) / BITS_PER_UNIT\n+\t     < (int) length\n+\t  || GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (srcvar))) != length\n+\t  || get_pointer_alignment (src, BIGGEST_ALIGNMENT) / BITS_PER_UNIT\n+\t     < (int) length)\n+\treturn 0;\n+\n+      if ((INTEGRAL_TYPE_P (TREE_TYPE (srcvar))\n+\t   || POINTER_TYPE_P (TREE_TYPE (srcvar)))\n+\t  && (INTEGRAL_TYPE_P (TREE_TYPE (destvar))\n+\t      || POINTER_TYPE_P (TREE_TYPE (destvar))))\n+\texpr = fold_convert (TREE_TYPE (destvar), srcvar);\n+      else\n+\texpr = fold_build1 (VIEW_CONVERT_EXPR, TREE_TYPE (destvar), srcvar);\n+      expr = build2 (MODIFY_EXPR, TREE_TYPE (destvar), destvar, expr);\n+    }\n+\n+  if (ignore)\n+    return expr;\n+\n+  if (endp == 0 || endp == 3)\n+    return omit_one_operand (type, dest, expr);\n+\n+  if (expr == len)\n+    expr = 0;\n+\n+  if (endp == 2)\n+    len = fold_build2 (MINUS_EXPR, TREE_TYPE (len), len,\n+\t\t       ssize_int (1));\n+\n+  len = fold_convert (TREE_TYPE (dest), len);\n+  dest = fold_build2 (PLUS_EXPR, TREE_TYPE (dest), dest, len);\n+  dest = fold_convert (type, dest);\n+  if (expr)\n+    dest = omit_one_operand (type, dest, expr);\n+  return dest;\n+}\n+\n+/* Fold function call to builtin bcopy.  Return NULL_TREE if no\n+   simplification can be made.  */\n+\n+static tree\n+fold_builtin_bcopy (tree arglist, bool ignore)\n+{\n+  tree src, dest, size, newarglist;\n+\n+  if (!validate_arglist (arglist,\n+\t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n+    return 0;\n+\n+  if (! ignore)\n+    return 0;\n+\n+  src = TREE_VALUE (arglist);\n+  dest = TREE_VALUE (TREE_CHAIN (arglist));\n+  size = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+\n+  /* New argument list transforming bcopy(ptr x, ptr y, int z) to\n+     memmove(ptr y, ptr x, size_t z).   This is done this way\n+     so that if it isn't expanded inline, we fallback to\n+     calling bcopy instead of memmove.  */\n+\n+  newarglist = build_tree_list (NULL_TREE, fold_convert (sizetype, size));\n+  newarglist = tree_cons (NULL_TREE, src, newarglist);\n+  newarglist = tree_cons (NULL_TREE, dest, newarglist);\n+\n+  return fold_builtin_memory_op (newarglist, void_type_node, true, /*endp=*/3);\n }\n \n /* Fold function call to builtin strcpy.  If LEN is not NULL, it represents\n@@ -8826,14 +9012,23 @@ fold_builtin_1 (tree fndecl, tree arglist, bool ignore)\n     CASE_INT_FN (BUILT_IN_PARITY):\n       return fold_builtin_bitop (fndecl, arglist);\n \n+    case BUILT_IN_MEMSET:\n+      return fold_builtin_memset (arglist, type, ignore);\n+\n     case BUILT_IN_MEMCPY:\n-      return fold_builtin_memcpy (fndecl, arglist);\n+      return fold_builtin_memory_op (arglist, type, ignore, /*endp=*/0);\n \n     case BUILT_IN_MEMPCPY:\n-      return fold_builtin_mempcpy (arglist, type, /*endp=*/1);\n+      return fold_builtin_memory_op (arglist, type, ignore, /*endp=*/1);\n \n     case BUILT_IN_MEMMOVE:\n-      return fold_builtin_memmove (arglist, type);\n+      return fold_builtin_memory_op (arglist, type, ignore, /*endp=*/3);\n+\n+    case BUILT_IN_BZERO:\n+      return fold_builtin_bzero (arglist, ignore);\n+\n+    case BUILT_IN_BCOPY:\n+      return fold_builtin_bcopy (arglist, ignore);\n \n     CASE_FLT_FN (BUILT_IN_SIGNBIT):\n       return fold_builtin_signbit (fndecl, arglist);"}]}