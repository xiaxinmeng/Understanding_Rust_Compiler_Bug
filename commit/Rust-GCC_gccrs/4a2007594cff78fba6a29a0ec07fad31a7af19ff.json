{"sha": "4a2007594cff78fba6a29a0ec07fad31a7af19ff", "node_id": "C_kwDOANBUbNoAKDRhMjAwNzU5NGNmZjc4ZmJhNmEyOWEwZWMwN2ZhZDMxYTdhZjE5ZmY", "commit": {"author": {"name": "Siddhesh Poyarekar", "email": "siddhesh@gotplt.org", "date": "2021-11-26T03:14:58Z"}, "committer": {"name": "Siddhesh Poyarekar", "email": "siddhesh@gotplt.org", "date": "2021-11-26T18:03:59Z"}, "message": "tree-object-size: Abstract object_sizes array\n\nPut all accesses to object_sizes behind functions so that we can add\ndynamic capability more easily.\n\ngcc/ChangeLog:\n\n\t* tree-object-size.c (object_sizes_grow, object_sizes_release,\n\tobject_sizes_unknown_p, object_sizes_get, object_size_set_force,\n\tobject_sizes_set): New functions.\n\t(addr_object_size, compute_builtin_object_size,\n\texpr_object_size, call_object_size, unknown_object_size,\n\tmerge_object_sizes, plus_stmt_object_size,\n\tcond_expr_object_size, collect_object_sizes_for,\n\tcheck_for_plus_in_loops_1, init_object_sizes,\n\tfini_object_sizes): Adjust.\n\nSigned-off-by: Siddhesh Poyarekar <siddhesh@gotplt.org>", "tree": {"sha": "889fd62a2c5719f4ffb769d624128e57096e6e87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/889fd62a2c5719f4ffb769d624128e57096e6e87"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a2007594cff78fba6a29a0ec07fad31a7af19ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a2007594cff78fba6a29a0ec07fad31a7af19ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a2007594cff78fba6a29a0ec07fad31a7af19ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a2007594cff78fba6a29a0ec07fad31a7af19ff/comments", "author": {"login": "siddhesh", "id": 158582, "node_id": "MDQ6VXNlcjE1ODU4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/158582?v=4", "gravatar_id": "", "url": "https://api.github.com/users/siddhesh", "html_url": "https://github.com/siddhesh", "followers_url": "https://api.github.com/users/siddhesh/followers", "following_url": "https://api.github.com/users/siddhesh/following{/other_user}", "gists_url": "https://api.github.com/users/siddhesh/gists{/gist_id}", "starred_url": "https://api.github.com/users/siddhesh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/siddhesh/subscriptions", "organizations_url": "https://api.github.com/users/siddhesh/orgs", "repos_url": "https://api.github.com/users/siddhesh/repos", "events_url": "https://api.github.com/users/siddhesh/events{/privacy}", "received_events_url": "https://api.github.com/users/siddhesh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "siddhesh", "id": 158582, "node_id": "MDQ6VXNlcjE1ODU4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/158582?v=4", "gravatar_id": "", "url": "https://api.github.com/users/siddhesh", "html_url": "https://github.com/siddhesh", "followers_url": "https://api.github.com/users/siddhesh/followers", "following_url": "https://api.github.com/users/siddhesh/following{/other_user}", "gists_url": "https://api.github.com/users/siddhesh/gists{/gist_id}", "starred_url": "https://api.github.com/users/siddhesh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/siddhesh/subscriptions", "organizations_url": "https://api.github.com/users/siddhesh/orgs", "repos_url": "https://api.github.com/users/siddhesh/repos", "events_url": "https://api.github.com/users/siddhesh/events{/privacy}", "received_events_url": "https://api.github.com/users/siddhesh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35c8bbe96b53ad13f770c9288e016ef08b6706ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35c8bbe96b53ad13f770c9288e016ef08b6706ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35c8bbe96b53ad13f770c9288e016ef08b6706ed"}], "stats": {"total": 177, "additions": 98, "deletions": 79}, "files": [{"sha": "3780437ff910fcd0f3142d51009f0868d8c67002", "filename": "gcc/tree-object-size.c", "status": "modified", "additions": 98, "deletions": 79, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2007594cff78fba6a29a0ec07fad31a7af19ff/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2007594cff78fba6a29a0ec07fad31a7af19ff/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=4a2007594cff78fba6a29a0ec07fad31a7af19ff", "patch": "@@ -88,6 +88,71 @@ unknown (int object_size_type)\n   return ((unsigned HOST_WIDE_INT) -((object_size_type >> 1) ^ 1));\n }\n \n+/* Grow object_sizes[OBJECT_SIZE_TYPE] to num_ssa_names.  */\n+\n+static inline void\n+object_sizes_grow (int object_size_type)\n+{\n+  if (num_ssa_names > object_sizes[object_size_type].length ())\n+    object_sizes[object_size_type].safe_grow (num_ssa_names, true);\n+}\n+\n+/* Release object_sizes[OBJECT_SIZE_TYPE].  */\n+\n+static inline void\n+object_sizes_release (int object_size_type)\n+{\n+  object_sizes[object_size_type].release ();\n+}\n+\n+/* Return true if object_sizes[OBJECT_SIZE_TYPE][VARNO] is unknown.  */\n+\n+static inline bool\n+object_sizes_unknown_p (int object_size_type, unsigned varno)\n+{\n+  return (object_sizes[object_size_type][varno]\n+\t  == unknown (object_size_type));\n+}\n+\n+/* Return size for VARNO corresponding to OSI.  */\n+\n+static inline unsigned HOST_WIDE_INT\n+object_sizes_get (struct object_size_info *osi, unsigned varno)\n+{\n+  return object_sizes[osi->object_size_type][varno];\n+}\n+\n+/* Set size for VARNO corresponding to OSI to VAL.  */\n+\n+static inline bool\n+object_sizes_set_force (struct object_size_info *osi, unsigned varno,\n+\t\t\tunsigned HOST_WIDE_INT val)\n+{\n+  object_sizes[osi->object_size_type][varno] = val;\n+  return true;\n+}\n+\n+/* Set size for VARNO corresponding to OSI to VAL if it is the new minimum or\n+   maximum.  */\n+\n+static inline bool\n+object_sizes_set (struct object_size_info *osi, unsigned varno,\n+\t\t  unsigned HOST_WIDE_INT val)\n+{\n+  int object_size_type = osi->object_size_type;\n+  if ((object_size_type & OST_MINIMUM) == 0)\n+    {\n+      if (object_sizes[object_size_type][varno] < val)\n+\treturn object_sizes_set_force (osi, varno, val);\n+    }\n+  else\n+    {\n+      if (object_sizes[object_size_type][varno] > val)\n+\treturn object_sizes_set_force (osi, varno, val);\n+    }\n+  return false;\n+}\n+\n /* Initialize OFFSET_LIMIT variable.  */\n static void\n init_offset_limit (void)\n@@ -247,7 +312,7 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n \t    collect_object_sizes_for (osi, var);\n \t  if (bitmap_bit_p (computed[object_size_type],\n \t\t\t    SSA_NAME_VERSION (var)))\n-\t    sz = object_sizes[object_size_type][SSA_NAME_VERSION (var)];\n+\t    sz = object_sizes_get (osi, SSA_NAME_VERSION (var));\n \t  else\n \t    sz = unknown (object_size_type);\n \t}\n@@ -582,14 +647,14 @@ compute_builtin_object_size (tree ptr, int object_size_type,\n       return false;\n     }\n \n+  struct object_size_info osi;\n+  osi.object_size_type = object_size_type;\n   if (!bitmap_bit_p (computed[object_size_type], SSA_NAME_VERSION (ptr)))\n     {\n-      struct object_size_info osi;\n       bitmap_iterator bi;\n       unsigned int i;\n \n-      if (num_ssa_names > object_sizes[object_size_type].length ())\n-\tobject_sizes[object_size_type].safe_grow (num_ssa_names, true);\n+      object_sizes_grow (object_size_type);\n       if (dump_file)\n \t{\n \t  fprintf (dump_file, \"Computing %s %sobject size for \",\n@@ -601,7 +666,6 @@ compute_builtin_object_size (tree ptr, int object_size_type,\n \n       osi.visited = BITMAP_ALLOC (NULL);\n       osi.reexamine = BITMAP_ALLOC (NULL);\n-      osi.object_size_type = object_size_type;\n       osi.depths = NULL;\n       osi.stack = NULL;\n       osi.tos = NULL;\n@@ -678,8 +742,7 @@ compute_builtin_object_size (tree ptr, int object_size_type,\n       if (dump_file)\n \t{\n \t  EXECUTE_IF_SET_IN_BITMAP (osi.visited, 0, i, bi)\n-\t    if (object_sizes[object_size_type][i]\n-\t\t!= unknown (object_size_type))\n+\t    if (!object_sizes_unknown_p (object_size_type, i))\n \t      {\n \t\tprint_generic_expr (dump_file, ssa_name (i),\n \t\t\t\t    dump_flags);\n@@ -689,15 +752,15 @@ compute_builtin_object_size (tree ptr, int object_size_type,\n \t\t\t ((object_size_type & OST_MINIMUM) ? \"minimum\"\n \t\t\t  : \"maximum\"),\n \t\t\t (object_size_type & OST_SUBOBJECT) ? \"sub\" : \"\",\n-\t\t\t object_sizes[object_size_type][i]);\n+\t\t\t object_sizes_get (&osi, i));\n \t      }\n \t}\n \n       BITMAP_FREE (osi.reexamine);\n       BITMAP_FREE (osi.visited);\n     }\n \n-  *psize = object_sizes[object_size_type][SSA_NAME_VERSION (ptr)];\n+  *psize = object_sizes_get (&osi, SSA_NAME_VERSION (ptr));\n   return *psize != unknown (object_size_type);\n }\n \n@@ -710,8 +773,7 @@ expr_object_size (struct object_size_info *osi, tree ptr, tree value)\n   unsigned int varno = SSA_NAME_VERSION (ptr);\n   unsigned HOST_WIDE_INT bytes;\n \n-  gcc_assert (object_sizes[object_size_type][varno]\n-\t      != unknown (object_size_type));\n+  gcc_assert (!object_sizes_unknown_p (object_size_type, varno));\n   gcc_assert (osi->pass == 0);\n \n   if (TREE_CODE (value) == WITH_SIZE_EXPR)\n@@ -726,16 +788,7 @@ expr_object_size (struct object_size_info *osi, tree ptr, tree value)\n   else\n     bytes = unknown (object_size_type);\n \n-  if ((object_size_type & OST_MINIMUM) == 0)\n-    {\n-      if (object_sizes[object_size_type][varno] < bytes)\n-\tobject_sizes[object_size_type][varno] = bytes;\n-    }\n-  else\n-    {\n-      if (object_sizes[object_size_type][varno] > bytes)\n-\tobject_sizes[object_size_type][varno] = bytes;\n-    }\n+  object_sizes_set (osi, varno, bytes);\n }\n \n \n@@ -750,22 +803,12 @@ call_object_size (struct object_size_info *osi, tree ptr, gcall *call)\n \n   gcc_assert (is_gimple_call (call));\n \n-  gcc_assert (object_sizes[object_size_type][varno]\n-\t      != unknown (object_size_type));\n+  gcc_assert (!object_sizes_unknown_p (object_size_type, varno));\n   gcc_assert (osi->pass == 0);\n \n   bytes = alloc_object_size (call, object_size_type);\n \n-  if ((object_size_type & OST_MINIMUM) == 0)\n-    {\n-      if (object_sizes[object_size_type][varno] < bytes)\n-\tobject_sizes[object_size_type][varno] = bytes;\n-    }\n-  else\n-    {\n-      if (object_sizes[object_size_type][varno] > bytes)\n-\tobject_sizes[object_size_type][varno] = bytes;\n-    }\n+  object_sizes_set (osi, varno, bytes);\n }\n \n \n@@ -776,12 +819,11 @@ unknown_object_size (struct object_size_info *osi, tree ptr)\n {\n   int object_size_type = osi->object_size_type;\n   unsigned int varno = SSA_NAME_VERSION (ptr);\n-  unsigned HOST_WIDE_INT bytes = unknown (object_size_type);\n \n-  gcc_checking_assert (object_sizes[object_size_type][varno] != bytes);\n+  gcc_checking_assert (!object_sizes_unknown_p (object_size_type, varno));\n   gcc_checking_assert (osi->pass == 0);\n \n-  object_sizes[object_size_type][varno] = bytes;\n+  object_sizes_set (osi, varno, unknown (object_size_type));\n }\n \n \n@@ -796,38 +838,24 @@ merge_object_sizes (struct object_size_info *osi, tree dest, tree orig,\n   unsigned int varno = SSA_NAME_VERSION (dest);\n   unsigned HOST_WIDE_INT orig_bytes;\n \n-  if (object_sizes[object_size_type][varno] == unknown (object_size_type))\n+  if (object_sizes_unknown_p (object_size_type, varno))\n     return false;\n   if (offset >= offset_limit)\n     {\n-      object_sizes[object_size_type][varno] = unknown (object_size_type);\n+      object_sizes_set (osi, varno, unknown (object_size_type));\n       return false;\n     }\n \n   if (osi->pass == 0)\n     collect_object_sizes_for (osi, orig);\n \n-  orig_bytes = object_sizes[object_size_type][SSA_NAME_VERSION (orig)];\n+  orig_bytes = object_sizes_get (osi, SSA_NAME_VERSION (orig));\n   if (orig_bytes != unknown (object_size_type))\n     orig_bytes = (offset > orig_bytes)\n \t\t ? HOST_WIDE_INT_0U : orig_bytes - offset;\n \n-  if ((object_size_type & OST_MINIMUM) == 0)\n-    {\n-      if (object_sizes[object_size_type][varno] < orig_bytes)\n-\t{\n-\t  object_sizes[object_size_type][varno] = orig_bytes;\n-\t  osi->changed = true;\n-\t}\n-    }\n-  else\n-    {\n-      if (object_sizes[object_size_type][varno] > orig_bytes)\n-\t{\n-\t  object_sizes[object_size_type][varno] = orig_bytes;\n-\t  osi->changed = true;\n-\t}\n-    }\n+  osi->changed = object_sizes_set (osi, varno, orig_bytes);\n+\n   return bitmap_bit_p (osi->reexamine, SSA_NAME_VERSION (orig));\n }\n \n@@ -859,7 +887,7 @@ plus_stmt_object_size (struct object_size_info *osi, tree var, gimple *stmt)\n   else\n     gcc_unreachable ();\n \n-  if (object_sizes[object_size_type][varno] == unknown (object_size_type))\n+  if (object_sizes_unknown_p (object_size_type, varno))\n     return false;\n \n   /* Handle PTR + OFFSET here.  */\n@@ -890,16 +918,7 @@ plus_stmt_object_size (struct object_size_info *osi, tree var, gimple *stmt)\n   else\n     bytes = unknown (object_size_type);\n \n-  if ((object_size_type & OST_MINIMUM) == 0)\n-    {\n-      if (object_sizes[object_size_type][varno] < bytes)\n-\tobject_sizes[object_size_type][varno] = bytes;\n-    }\n-  else\n-    {\n-      if (object_sizes[object_size_type][varno] > bytes)\n-\tobject_sizes[object_size_type][varno] = bytes;\n-    }\n+  object_sizes_set (osi, varno, bytes);\n   return false;\n }\n \n@@ -918,7 +937,7 @@ cond_expr_object_size (struct object_size_info *osi, tree var, gimple *stmt)\n \n   gcc_assert (gimple_assign_rhs_code (stmt) == COND_EXPR);\n \n-  if (object_sizes[object_size_type][varno] == unknown (object_size_type))\n+  if (object_sizes_unknown_p (object_size_type, varno))\n     return false;\n \n   then_ = gimple_assign_rhs2 (stmt);\n@@ -929,7 +948,7 @@ cond_expr_object_size (struct object_size_info *osi, tree var, gimple *stmt)\n   else\n     expr_object_size (osi, var, then_);\n \n-  if (object_sizes[object_size_type][varno] == unknown (object_size_type))\n+  if (object_sizes_unknown_p (object_size_type, varno))\n     return reexamine;\n \n   if (TREE_CODE (else_) == SSA_NAME)\n@@ -975,8 +994,10 @@ collect_object_sizes_for (struct object_size_info *osi, tree var)\n     {\n       if (bitmap_set_bit (osi->visited, varno))\n \t{\n-\t  object_sizes[object_size_type][varno]\n-\t    = (object_size_type & OST_MINIMUM) ? -1 : 0;\n+\t  /* Initialize to 0 for maximum size and M1U for minimum size so that\n+\t     it gets immediately overridden.  */\n+\t  object_sizes_set_force (osi, varno,\n+\t\t\t\t  unknown (object_size_type ^ OST_MINIMUM));\n \t}\n       else\n \t{\n@@ -1047,7 +1068,7 @@ collect_object_sizes_for (struct object_size_info *osi, tree var)\n \n     case GIMPLE_ASM:\n       /* Pointers defined by __asm__ statements can point anywhere.  */\n-      object_sizes[object_size_type][varno] = unknown (object_size_type);\n+      object_sizes_set (osi, varno, unknown (object_size_type));\n       break;\n \n     case GIMPLE_NOP:\n@@ -1056,7 +1077,7 @@ collect_object_sizes_for (struct object_size_info *osi, tree var)\n \texpr_object_size (osi, var, SSA_NAME_VAR (var));\n       else\n \t/* Uninitialized SSA names point nowhere.  */\n-\tobject_sizes[object_size_type][varno] = unknown (object_size_type);\n+\tobject_sizes_set (osi, varno, unknown (object_size_type));\n       break;\n \n     case GIMPLE_PHI:\n@@ -1067,8 +1088,7 @@ collect_object_sizes_for (struct object_size_info *osi, tree var)\n \t  {\n \t    tree rhs = gimple_phi_arg (stmt, i)->def;\n \n-\t    if (object_sizes[object_size_type][varno]\n-\t\t== unknown (object_size_type))\n+\t    if (object_sizes_unknown_p (object_size_type, varno))\n \t      break;\n \n \t    if (TREE_CODE (rhs) == SSA_NAME)\n@@ -1083,8 +1103,7 @@ collect_object_sizes_for (struct object_size_info *osi, tree var)\n       gcc_unreachable ();\n     }\n \n-  if (! reexamine\n-      || object_sizes[object_size_type][varno] == unknown (object_size_type))\n+  if (! reexamine || object_sizes_unknown_p (object_size_type, varno))\n     {\n       bitmap_set_bit (computed[object_size_type], varno);\n       bitmap_clear_bit (osi->reexamine, varno);\n@@ -1124,7 +1143,7 @@ check_for_plus_in_loops_1 (struct object_size_info *osi, tree var,\n \t      --sp;\n \t      bitmap_clear_bit (osi->reexamine, *sp);\n \t      bitmap_set_bit (computed[osi->object_size_type], *sp);\n-\t      object_sizes[osi->object_size_type][*sp] = 0;\n+\t      object_sizes_set_force (osi, *sp, 0);\n \t      if (*sp == varno)\n \t\tbreak;\n \t    }\n@@ -1248,7 +1267,7 @@ init_object_sizes (void)\n \n   for (object_size_type = 0; object_size_type < OST_END; object_size_type++)\n     {\n-      object_sizes[object_size_type].safe_grow (num_ssa_names, true);\n+      object_sizes_grow (object_size_type);\n       computed[object_size_type] = BITMAP_ALLOC (NULL);\n     }\n \n@@ -1265,7 +1284,7 @@ fini_object_sizes (void)\n \n   for (object_size_type = 0; object_size_type < OST_END; object_size_type++)\n     {\n-      object_sizes[object_size_type].release ();\n+      object_sizes_release (object_size_type);\n       BITMAP_FREE (computed[object_size_type]);\n     }\n }"}]}