{"sha": "5f24a82a10c91d5c809510e9232b5fbe21c963fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWYyNGE4MmExMGM5MWQ1YzgwOTUxMGU5MjMyYjVmYmUyMWM5NjNmYg==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2014-02-25T15:05:39Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-25T15:05:39Z"}, "message": "exp_ch6.adb (Add_Or_Save_Precondition): New routine.\n\n2014-02-25  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch6.adb (Add_Or_Save_Precondition): New routine.\n\t(Collect_Body_Postconditions_In_Decls): New routine.\n\t(Collect_Body_Postconditions_Of_Kind): Factor out code. Handle\n\tpostcondition aspects or pragmas that appear on a subprogram\n\tbody stub.\n\t(Collect_Spec_Preconditions): Factor out code. Handle\n\tprecondition aspects or pragmas that appear on a subprogram\n\tbody stub.\n\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): The analysis of\n\taspects that apply to a subprogram body stub is no longer delayed,\n\tthe aspects are analyzed on the spot.\n\t(SPARK_Aspect_Error):\n\tAspects that apply to a subprogram declaration cannot appear in\n\ta subunit.\n\t* sem_ch10.adb Remove with and use clause for Sem_Ch13.\n\t(Analyze_Proper_Body): Add local variable Comp_Unit. Unum\n\tis now a local variable. Code cleanup. Analysis related to\n\tthe aspects of a subprogram body stub is now carried out by\n\tAnalyze_Subprogram_Body_Helper. Do not propagate the aspects\n\tand/or pragmas of a subprogram body stub to the proper body\n\tas this is no longer needed. Do not analyze the aspects of a\n\tsubprogram stub when the corresponding source unit is missing.\n\t(Analyze_Protected_Body_Stub): Flag the illegal use of aspects\n\ton a stub.\n\t(Analyze_Task_Body_Stub): Flag the illegal use of\n\taspects on a stub.\n\t(Optional_Subunit): Add local variable Unum.\n\t* sem_ch13.adb (Insert_Delayed_Pragma): Do not analyze a generated\n\tpragma when it applies to a subprogram body stub.\n\t* sem_prag.adb (Analyze_Pragma): Pragmas Contract_Cases,\n\tDepends and Global can now apply to a subprogram body stub as\n\tlong as it acts as its own spec.\n\t(Analyze_Refined_Pragma):\n\tCode reformatting. Refinement pragmas cannot apply to a subunit.\n\nFrom-SVN: r208134", "tree": {"sha": "48f255ef070ad622be4207d83e6991472e576211", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48f255ef070ad622be4207d83e6991472e576211"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f24a82a10c91d5c809510e9232b5fbe21c963fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f24a82a10c91d5c809510e9232b5fbe21c963fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f24a82a10c91d5c809510e9232b5fbe21c963fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f24a82a10c91d5c809510e9232b5fbe21c963fb/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7edfb4c6492dc8f503f5277adcaf5ab25c62cc46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7edfb4c6492dc8f503f5277adcaf5ab25c62cc46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7edfb4c6492dc8f503f5277adcaf5ab25c62cc46"}], "stats": {"total": 493, "additions": 323, "deletions": 170}, "files": [{"sha": "ad3b82d2086bc278ad6c0e902f176771e7399e96", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f24a82a10c91d5c809510e9232b5fbe21c963fb/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f24a82a10c91d5c809510e9232b5fbe21c963fb/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5f24a82a10c91d5c809510e9232b5fbe21c963fb", "patch": "@@ -1,3 +1,40 @@\n+2014-02-25  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch6.adb (Add_Or_Save_Precondition): New routine.\n+\t(Collect_Body_Postconditions_In_Decls): New routine.\n+\t(Collect_Body_Postconditions_Of_Kind): Factor out code. Handle\n+\tpostcondition aspects or pragmas that appear on a subprogram\n+\tbody stub.\n+\t(Collect_Spec_Preconditions): Factor out code. Handle\n+\tprecondition aspects or pragmas that appear on a subprogram\n+\tbody stub.\n+\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): The analysis of\n+\taspects that apply to a subprogram body stub is no longer delayed,\n+\tthe aspects are analyzed on the spot.\n+\t(SPARK_Aspect_Error):\n+\tAspects that apply to a subprogram declaration cannot appear in\n+\ta subunit.\n+\t* sem_ch10.adb Remove with and use clause for Sem_Ch13.\n+\t(Analyze_Proper_Body): Add local variable Comp_Unit. Unum\n+\tis now a local variable. Code cleanup. Analysis related to\n+\tthe aspects of a subprogram body stub is now carried out by\n+\tAnalyze_Subprogram_Body_Helper. Do not propagate the aspects\n+\tand/or pragmas of a subprogram body stub to the proper body\n+\tas this is no longer needed. Do not analyze the aspects of a\n+\tsubprogram stub when the corresponding source unit is missing.\n+\t(Analyze_Protected_Body_Stub): Flag the illegal use of aspects\n+\ton a stub.\n+\t(Analyze_Task_Body_Stub): Flag the illegal use of\n+\taspects on a stub.\n+\t(Optional_Subunit): Add local variable Unum.\n+\t* sem_ch13.adb (Insert_Delayed_Pragma): Do not analyze a generated\n+\tpragma when it applies to a subprogram body stub.\n+\t* sem_prag.adb (Analyze_Pragma): Pragmas Contract_Cases,\n+\tDepends and Global can now apply to a subprogram body stub as\n+\tlong as it acts as its own spec.\n+\t(Analyze_Refined_Pragma):\n+\tCode reformatting. Refinement pragmas cannot apply to a subunit.\n+\n 2014-02-25  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* einfo.ads Update the usage of flag"}, {"sha": "4aa43ba10d510992f1e033aceb925861b87b7d0d", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 147, "deletions": 46, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f24a82a10c91d5c809510e9232b5fbe21c963fb/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f24a82a10c91d5c809510e9232b5fbe21c963fb/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=5f24a82a10c91d5c809510e9232b5fbe21c963fb", "patch": "@@ -8671,58 +8671,100 @@ package body Exp_Ch6 is\n \n       procedure Collect_Body_Postconditions (Stmts : in out List_Id) is\n          procedure Collect_Body_Postconditions_Of_Kind (Post_Nam : Name_Id);\n-         --  Process postconditions of a particular kind denoted by Post_Nam\n+         --  Process all postconditions of a particular kind denoted by\n+         --  Post_Nam.\n \n          -----------------------------------------\n          -- Collect_Body_Postconditions_Of_Kind --\n          -----------------------------------------\n \n          procedure Collect_Body_Postconditions_Of_Kind (Post_Nam : Name_Id) is\n-            Check_Prag : Node_Id;\n-            Decl       : Node_Id;\n+            procedure Collect_Body_Postconditions_In_Decls\n+              (First_Decl : Node_Id);\n+            --  Process all postconditions found in a declarative list starting\n+            --  with declaration First_Decl.\n \n-         begin\n-            pragma Assert (Nam_In (Post_Nam, Name_Postcondition,\n-                                             Name_Refined_Post));\n+            ------------------------------------------\n+            -- Collect_Body_Postconditions_In_Decls --\n+            ------------------------------------------\n \n-            --  Inspect the declarations of the subprogram body looking for a\n-            --  pragma that matches the desired name.\n+            procedure Collect_Body_Postconditions_In_Decls\n+              (First_Decl : Node_Id)\n+            is\n+               Check_Prag : Node_Id;\n+               Decl       : Node_Id;\n \n-            Decl := First (Declarations (N));\n-            while Present (Decl) loop\n-               if Nkind (Decl) = N_Pragma then\n-                  if Pragma_Name (Decl) = Post_Nam then\n-                     Analyze (Decl);\n-                     Check_Prag := Build_Pragma_Check_Equivalent (Decl);\n+            begin\n+               --  Inspect the declarative list looking for a pragma that\n+               --  matches the desired name.\n \n-                     if Expander_Active then\n-                        Append_Enabled_Item\n-                          (Item => Check_Prag,\n-                           List => Stmts);\n+               Decl := First_Decl;\n+               while Present (Decl) loop\n \n-                     --  When analyzing a generic unit, save the pragma for\n-                     --  later.\n+                  --  Note that non-matching pragmas are skipped\n \n-                     else\n-                        Prepend_To_Declarations (Check_Prag);\n+                  if Nkind (Decl) = N_Pragma then\n+                     if Pragma_Name (Decl) = Post_Nam then\n+                        if not Analyzed (Decl) then\n+                           Analyze (Decl);\n+                        end if;\n+\n+                        Check_Prag := Build_Pragma_Check_Equivalent (Decl);\n+\n+                        if Expander_Active then\n+                           Append_Enabled_Item\n+                             (Item => Check_Prag,\n+                              List => Stmts);\n+\n+                        --  When analyzing a generic unit, save the pragma for\n+                        --  later.\n+\n+                        else\n+                           Prepend_To_Declarations (Check_Prag);\n+                        end if;\n                      end if;\n+\n+                  --  Skip internally generated code\n+\n+                  elsif not Comes_From_Source (Decl) then\n+                     null;\n+\n+                  --  Postcondition pragmas are usually grouped together. There\n+                  --  is no need to inspect the whole declarative list.\n+\n+                  else\n+                     exit;\n                   end if;\n \n-               --  Skip internally generated code\n+                  Next (Decl);\n+               end loop;\n+            end Collect_Body_Postconditions_In_Decls;\n \n-               elsif not Comes_From_Source (Decl) then\n-                  null;\n+            --  Local variables\n \n-               --  Postconditions in bodies are usually grouped at the top of\n-               --  the declarations. There is no point in inspecting the whole\n-               --  source list.\n+            Unit_Decl : constant Node_Id := Parent (N);\n \n-               else\n-                  exit;\n-               end if;\n+         --  Start of processing for Collect_Body_Postconditions_Of_Kind\n \n-               Next (Decl);\n-            end loop;\n+         begin\n+            pragma Assert (Nam_In (Post_Nam, Name_Postcondition,\n+                                             Name_Refined_Post));\n+\n+            --  Inspect the declarations of the subprogram body looking for a\n+            --  pragma that matches the desired name.\n+\n+            Collect_Body_Postconditions_In_Decls\n+              (First_Decl => First (Declarations (N)));\n+\n+            --  The subprogram body being processed is actually the proper body\n+            --  of a stub with a corresponding spec. The subprogram stub may\n+            --  carry a postcondition pragma in which case it must be taken\n+            --  into account. The pragma appears after the stub.\n+\n+            if Present (Spec_Id) and then Nkind (Unit_Decl) = N_Subunit then\n+               Collect_Body_Postconditions_In_Decls\n+                 (First_Decl => Next (Corresponding_Stub (Unit_Decl)));\n+            end if;\n          end Collect_Body_Postconditions_Of_Kind;\n \n       --  Start of processing for Collect_Body_Postconditions\n@@ -8808,11 +8850,45 @@ package body Exp_Ch6 is\n       --------------------------------\n \n       procedure Collect_Spec_Preconditions (Subp_Id : Entity_Id) is\n+         Class_Pre : Node_Id := Empty;\n+         --  The sole class-wide precondition pragma that applies to the\n+         --  subprogram.\n+\n+         procedure Add_Or_Save_Precondition (Prag : Node_Id);\n+         --  Save a class-wide precondition or add a regulat precondition to\n+         --  the declarative list of the body.\n+\n          procedure Merge_Preconditions (From : Node_Id; Into : Node_Id);\n          --  Merge two class-wide preconditions by \"or else\"-ing them. The\n          --  changes are accumulated in parameter Into. Update the error\n          --  message of Into.\n \n+         ------------------------------\n+         -- Add_Or_Save_Precondition --\n+         ------------------------------\n+\n+         procedure Add_Or_Save_Precondition (Prag : Node_Id) is\n+            Check_Prag : Node_Id;\n+\n+         begin\n+            Check_Prag := Build_Pragma_Check_Equivalent (Prag);\n+\n+            --  Save the sole class-wide precondition (if any) for the next\n+            --  step where it will be merged with inherited preconditions.\n+\n+            if Class_Present (Prag) then\n+               pragma Assert (No (Class_Pre));\n+               Class_Pre := Check_Prag;\n+\n+            --  Accumulate the corresponding Check pragmas to the top of the\n+            --  declarations. Prepending the items ensures that they will be\n+            --  evaluated in their original order.\n+\n+            else\n+               Prepend_To_Declarations (Check_Prag);\n+            end if;\n+         end Add_Or_Save_Precondition;\n+\n          -------------------------\n          -- Merge_Preconditions --\n          -------------------------\n@@ -8889,8 +8965,9 @@ package body Exp_Ch6 is\n \n          Inher_Subps   : constant Subprogram_List :=\n                            Inherited_Subprograms (Subp_Id);\n+         Subp_Decl     : constant Node_Id := Parent (Parent (Subp_Id));\n          Check_Prag    : Node_Id;\n-         Class_Pre     : Node_Id := Empty;\n+         Decl          : Node_Id;\n          Inher_Subp_Id : Entity_Id;\n          Prag          : Node_Id;\n \n@@ -8902,25 +8979,49 @@ package body Exp_Ch6 is\n          Prag := Pre_Post_Conditions (Contract (Subp_Id));\n          while Present (Prag) loop\n             if Pragma_Name (Prag) = Name_Precondition then\n-               Check_Prag := Build_Pragma_Check_Equivalent (Prag);\n+               Add_Or_Save_Precondition (Prag);\n+            end if;\n \n-               --  Save the sole class-wide precondition (if any) for the next\n-               --  step where it will be merged with inherited preconditions.\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n \n-               if Class_Present (Prag) then\n-                  Class_Pre := Check_Prag;\n+         --  The subprogram declaration being processed is actually a body\n+         --  stub. The stub may carry a precondition pragma in which case it\n+         --  must be taken into account. The pragma appears after the stub.\n \n-               --  Accumulate the corresponding Check pragmas to the top of the\n-               --  declarations. Prepending the items ensures that they will\n-               --  be evaluated in their original order.\n+         if Nkind (Subp_Decl) = N_Subprogram_Body_Stub then\n+\n+            --  Inspect the declarations following the body stub\n+\n+            Decl := Next (Subp_Decl);\n+            while Present (Decl) loop\n+\n+               --  Note that non-matching pragmas are skipped\n+\n+               if Nkind (Decl) = N_Pragma then\n+                  if Pragma_Name (Decl) = Name_Precondition then\n+                     if not Analyzed (Decl) then\n+                        Analyze (Decl);\n+                     end if;\n+\n+                     Add_Or_Save_Precondition (Decl);\n+                  end if;\n+\n+               --  Skip internally generated code\n+\n+               elsif not Comes_From_Source (Decl) then\n+                  null;\n+\n+               --  Preconditions are usually grouped together. There is no need\n+               --  to inspect the whole declarative list.\n \n                else\n-                  Prepend_To_Declarations (Check_Prag);\n+                  exit;\n                end if;\n-            end if;\n \n-            Prag := Next_Pragma (Prag);\n-         end loop;\n+               Next (Decl);\n+            end loop;\n+         end if;\n \n          --  Process the contracts of all inherited subprograms, looking for\n          --  class-wide preconditions."}, {"sha": "df4aacf6fc6b549b6047ad811fe6ba07008af050", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 54, "deletions": 72, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f24a82a10c91d5c809510e9232b5fbe21c963fb/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f24a82a10c91d5c809510e9232b5fbe21c963fb/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=5f24a82a10c91d5c809510e9232b5fbe21c963fb", "patch": "@@ -53,7 +53,6 @@ with Sem_Ch3;  use Sem_Ch3;\n with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch7;  use Sem_Ch7;\n with Sem_Ch8;  use Sem_Ch8;\n-with Sem_Ch13; use Sem_Ch13;\n with Sem_Dist; use Sem_Dist;\n with Sem_Prag; use Sem_Prag;\n with Sem_Util; use Sem_Util;\n@@ -1558,7 +1557,6 @@ package body Sem_Ch10 is\n \n    procedure Analyze_Proper_Body (N : Node_Id; Nam : Entity_Id) is\n       Subunit_Name : constant Unit_Name_Type := Get_Unit_Name (N);\n-      Unum         : Unit_Number_Type;\n \n       procedure Optional_Subunit;\n       --  This procedure is called when the main unit is a stub, or when we\n@@ -1573,6 +1571,7 @@ package body Sem_Ch10 is\n \n       procedure Optional_Subunit is\n          Comp_Unit : Node_Id;\n+         Unum      : Unit_Number_Type;\n \n       begin\n          --  Try to load subunit, but ignore any errors that occur during the\n@@ -1633,7 +1632,8 @@ package body Sem_Ch10 is\n \n       --  Local variables\n \n-      Stub_Id : Entity_Id;\n+      Comp_Unit : Node_Id;\n+      Unum      : Unit_Number_Type;\n \n    --  Start of processing for Analyze_Proper_Body\n \n@@ -1787,86 +1787,45 @@ package body Sem_Ch10 is\n                   Write_Eol;\n                end if;\n \n-               declare\n-                  Comp_Unit : constant Node_Id := Cunit (Unum);\n-                  Prop_Body : Node_Id;\n-\n-               begin\n-                  --  Check for child unit instead of subunit\n-\n-                  if Nkind (Unit (Comp_Unit)) /= N_Subunit then\n-                     Error_Msg_N\n-                       (\"expected SEPARATE subunit, found child unit\",\n-                        Cunit_Entity (Unum));\n-\n-                  --  OK, we have a subunit\n-\n-                  else\n-                     Prop_Body := Proper_Body (Unit (Comp_Unit));\n-\n-                     --  Set corresponding stub (even if errors)\n+               Comp_Unit := Cunit (Unum);\n \n-                     Set_Corresponding_Stub (Unit (Comp_Unit), N);\n+               --  Check for child unit instead of subunit\n \n-                     --  Collect SCO information for loaded subunit if we are\n-                     --  in the main unit.\n+               if Nkind (Unit (Comp_Unit)) /= N_Subunit then\n+                  Error_Msg_N\n+                    (\"expected SEPARATE subunit, found child unit\",\n+                     Cunit_Entity (Unum));\n \n-                     if Generate_SCO\n-                       and then\n-                         In_Extended_Main_Source_Unit\n-                           (Cunit_Entity (Current_Sem_Unit))\n-                     then\n-                        SCO_Record (Unum);\n-                     end if;\n-\n-                     --  Propagate all aspect specifications associated with\n-                     --  the stub to the proper body.\n-\n-                     Move_Or_Merge_Aspects (From => N, To => Prop_Body);\n-\n-                     --  Move all source pragmas that follow the body stub and\n-                     --  apply to it to the declarations of the proper body.\n+               --  OK, we have a subunit\n \n-                     if Nkind (N) = N_Subprogram_Body_Stub then\n-                        Relocate_Pragmas_To_Body (N, Target_Body => Prop_Body);\n-                     end if;\n-\n-                     --  Analyze the unit if semantics active\n-\n-                     if not Fatal_Error (Unum) or else Try_Semantics then\n-                        Analyze_Subunit (Comp_Unit);\n-                     end if;\n+               else\n+                  Set_Corresponding_Stub (Unit (Comp_Unit), N);\n+                  Set_Library_Unit (N, Comp_Unit);\n \n-                     --  Set the library unit pointer in any case\n+                  --  We update the version. Although we are not technically\n+                  --  semantically dependent on the subunit, given our approach\n+                  --  of macro substitution of subunits, it makes sense to\n+                  --  include it in the version identification.\n \n-                     Set_Library_Unit (N, Comp_Unit);\n+                  Version_Update (Cunit (Main_Unit), Comp_Unit);\n \n-                     --  We update the version. Although we are not technically\n-                     --  semantically dependent on the subunit, given our\n-                     --  approach of macro substitution of subunits, it makes\n-                     --  sense to include it in the version identification.\n+                  --  Collect SCO information for loaded subunit if we are in\n+                  --  the main unit.\n \n-                     Version_Update (Cunit (Main_Unit), Comp_Unit);\n+                  if Generate_SCO\n+                    and then\n+                      In_Extended_Main_Source_Unit\n+                        (Cunit_Entity (Current_Sem_Unit))\n+                  then\n+                     SCO_Record (Unum);\n                   end if;\n-               end;\n-\n-            --  The unit which should contain the proper subprogram body does\n-            --  not exist. Analyze the aspect specifications of the stub (if\n-            --  any).\n-\n-            elsif Nkind (N) = N_Subprogram_Body_Stub\n-              and then Has_Aspects (N)\n-            then\n-               Stub_Id := Defining_Unit_Name (Specification (N));\n-\n-               --  Restore the proper visibility of the stub and its formals\n-\n-               Push_Scope (Stub_Id);\n-               Install_Formals (Stub_Id);\n \n-               Analyze_Aspect_Specifications (N, Stub_Id);\n+                  --  Analyze the unit if semantics active\n \n-               Pop_Scope;\n+                  if not Fatal_Error (Unum) or else Try_Semantics then\n+                     Analyze_Subunit (Comp_Unit);\n+                  end if;\n+               end if;\n             end if;\n          end if;\n \n@@ -1901,6 +1860,17 @@ package body Sem_Ch10 is\n          Error_Msg_N (\"missing specification for Protected body\", N);\n \n       else\n+         --  Currently there are no language-defined aspects that can apply to\n+         --  a protected body stub. Issue an error and remove the aspects to\n+         --  prevent cascaded errors.\n+\n+         if Has_Aspects (N) then\n+            Error_Msg_N\n+              (\"aspects on protected bodies are not allowed\",\n+               First (Aspect_Specifications (N)));\n+            Remove_Aspects (N);\n+         end if;\n+\n          Set_Scope (Defining_Entity (N), Current_Scope);\n          Set_Has_Completion (Etype (Nam));\n          Set_Corresponding_Spec_Of_Stub (N, Nam);\n@@ -2351,7 +2321,19 @@ package body Sem_Ch10 is\n \n       if No (Nam) or else not Is_Task_Type (Etype (Nam)) then\n          Error_Msg_N (\"missing specification for task body\", N);\n+\n       else\n+         --  Currently there are no language-defined aspects that can apply to\n+         --  a task body stub. Issue an error and remove the aspects to prevent\n+         --  cascaded errors.\n+\n+         if Has_Aspects (N) then\n+            Error_Msg_N\n+              (\"aspects on task bodies are not allowed\",\n+               First (Aspect_Specifications (N)));\n+            Remove_Aspects (N);\n+         end if;\n+\n          Set_Scope (Defining_Entity (N), Current_Scope);\n          Generate_Reference (Nam, Defining_Identifier (N), 'b');\n          Set_Corresponding_Spec_Of_Stub (N, Nam);"}, {"sha": "d8c71d778cbde964e9ca4872cf607683c985f052", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f24a82a10c91d5c809510e9232b5fbe21c963fb/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f24a82a10c91d5c809510e9232b5fbe21c963fb/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=5f24a82a10c91d5c809510e9232b5fbe21c963fb", "patch": "@@ -1234,14 +1234,6 @@ package body Sem_Ch13 is\n \n          else\n             Insert_After (N, Prag);\n-\n-            --  Analyze the pragma before analyzing the proper body of a stub.\n-            --  This ensures that the pragma will appear on the proper contract\n-            --  list (see N_Contract).\n-\n-            if Nkind (N) = N_Subprogram_Body_Stub then\n-               Analyze (Prag);\n-            end if;\n          end if;\n       end Insert_Delayed_Pragma;\n "}, {"sha": "2433b32392d7cfc079cc1544b8bd15cf19d37b11", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f24a82a10c91d5c809510e9232b5fbe21c963fb/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f24a82a10c91d5c809510e9232b5fbe21c963fb/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=5f24a82a10c91d5c809510e9232b5fbe21c963fb", "patch": "@@ -2485,8 +2485,17 @@ package body Sem_Ch6 is\n \n             if Has_Aspect (Spec_Id, Asp_Id) then\n                Error_Msg_Name_1 := Asp_Nam;\n-               Error_Msg_Name_2 := Ref_Nam;\n-               Error_Msg_N (\"aspect % should be %\", Asp);\n+\n+               --  Subunits cannot carry aspects that apply to a subprogram\n+               --  declaration.\n+\n+               if Nkind (Parent (N)) = N_Subunit then\n+                  Error_Msg_N (\"aspect % cannot apply to a subunit\", Asp);\n+\n+               else\n+                  Error_Msg_Name_2 := Ref_Nam;\n+                  Error_Msg_N (\"aspect % should be %\", Asp);\n+               end if;\n \n             --  Otherwise the aspect must appear in the spec, not in the body:\n \n@@ -2912,28 +2921,16 @@ package body Sem_Ch6 is\n          end if;\n       end if;\n \n-      --  Language-defined aspects cannot appear in a subprogram body [stub] if\n-      --  the subprogram has a separate spec. Certainly implementation-defined\n-      --  aspects are allowed to appear (per Aspects_On_Body_Of_Stub_OK).\n+      --  Language-defined aspects cannot appear on a subprogram body [stub] if\n+      --  the subprogram has a spec. Certain implementation-defined aspects are\n+      --  allowed to break this rule (see table Aspect_On_Body_Or_Stub_OK).\n \n       if Has_Aspects (N) then\n          if Present (Spec_Id)\n            and then not Aspects_On_Body_Or_Stub_OK (N)\n-\n-            --  Do not emit an error on a subprogram body stub that act as\n-            --  its own spec.\n-\n-           and then Nkind (Parent (Parent (Spec_Id))) /= N_Subprogram_Body_Stub\n          then\n             Diagnose_Misplaced_Aspect_Specifications;\n \n-         --  Delay the analysis of aspect specifications that apply to a body\n-         --  stub until the proper body is analyzed. If the corresponding body\n-         --  is missing, the aspects are still analyzed in Analyze_Proper_Body.\n-\n-         elsif Nkind (N) in N_Body_Stub then\n-            null;\n-\n          else\n             Analyze_Aspect_Specifications (N, Body_Id);\n          end if;"}, {"sha": "a5eaf1304bd97f09fa912c5c0859b0fb0f53a416", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 71, "deletions": 27, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f24a82a10c91d5c809510e9232b5fbe21c963fb/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f24a82a10c91d5c809510e9232b5fbe21c963fb/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=5f24a82a10c91d5c809510e9232b5fbe21c963fb", "patch": "@@ -3601,40 +3601,42 @@ package body Sem_Prag is\n \n          Body_Decl := Find_Related_Subprogram_Or_Body (N, Do_Checks => True);\n \n-         if not Nkind_In (Body_Decl, N_Subprogram_Body,\n-                                     N_Subprogram_Body_Stub)\n-         then\n-            Pragma_Misplaced;\n-            return;\n-         end if;\n-\n-         Body_Id := Defining_Entity (Body_Decl);\n-\n-         --  The body [stub] must not act as a spec, in other words it has to\n-         --  be paired with a corresponding spec.\n+         --  Extract the entities of the spec and body\n \n          if Nkind (Body_Decl) = N_Subprogram_Body then\n+            Body_Id := Defining_Entity (Body_Decl);\n             Spec_Id := Corresponding_Spec (Body_Decl);\n-         else\n+\n+         elsif Nkind (Body_Decl) = N_Subprogram_Body_Stub then\n+            Body_Id := Defining_Entity (Body_Decl);\n             Spec_Id := Corresponding_Spec_Of_Stub (Body_Decl);\n+\n+         else\n+            Pragma_Misplaced;\n+            return;\n          end if;\n \n+         --  The pragma must apply to the second declaration of a subprogram.\n+         --  In other words, the body [stub] cannot acts as a spec.\n+\n          if No (Spec_Id) then\n             Error_Pragma (\"pragma % cannot apply to a stand alone body\");\n             return;\n+\n+         --  Catch the case where the subprogram body is a subunit and acts as\n+         --  the third declaration of the subprogram.\n+\n+         elsif Nkind (Parent (Body_Decl)) = N_Subunit then\n+            Error_Pragma (\"pragma % cannot apply to a subunit\");\n+            return;\n          end if;\n \n-         --  The pragma may only apply to the body [stub] of a subprogram\n+         --  The pragma can only apply to the body [stub] of a subprogram\n          --  declared in the visible part of a package. Retrieve the context of\n          --  the subprogram declaration.\n \n          Spec_Decl := Parent (Parent (Spec_Id));\n \n-         pragma Assert\n-           (Nkind_In (Spec_Decl, N_Abstract_Subprogram_Declaration,\n-                                 N_Generic_Subprogram_Declaration,\n-                                 N_Subprogram_Declaration));\n-\n          if Nkind (Parent (Spec_Decl)) /= N_Package_Specification then\n             Error_Pragma\n               (\"pragma % must apply to the body of a subprogram declared in a \"\n@@ -12445,10 +12447,24 @@ package body Sem_Prag is\n             Subp_Decl :=\n               Find_Related_Subprogram_Or_Body (N, Do_Checks => True);\n \n-            if Nkind (Subp_Decl) /= N_Subprogram_Declaration\n-              and then (Nkind (Subp_Decl) /= N_Subprogram_Body\n-                         or else not Acts_As_Spec (Subp_Decl))\n+            if Nkind (Subp_Decl) = N_Subprogram_Declaration then\n+               null;\n+\n+            --  Body acts as spec\n+\n+            elsif Nkind (Subp_Decl) = N_Subprogram_Body\n+              and then No (Corresponding_Spec (Subp_Decl))\n+            then\n+               null;\n+\n+            --  Body stub acts as spec\n+\n+            elsif Nkind (Subp_Decl) = N_Subprogram_Body_Stub\n+              and then No (Corresponding_Spec_Of_Stub (Subp_Decl))\n             then\n+               null;\n+\n+            else\n                Pragma_Misplaced;\n                return;\n             end if;\n@@ -12969,10 +12985,24 @@ package body Sem_Prag is\n             Subp_Decl :=\n               Find_Related_Subprogram_Or_Body (N, Do_Checks => True);\n \n-            if Nkind (Subp_Decl) /= N_Subprogram_Declaration\n-              and then (Nkind (Subp_Decl) /= N_Subprogram_Body\n-                          or else not Acts_As_Spec (Subp_Decl))\n+            if Nkind (Subp_Decl) = N_Subprogram_Declaration then\n+               null;\n+\n+            --  Body acts as spec\n+\n+            elsif Nkind (Subp_Decl) = N_Subprogram_Body\n+              and then No (Corresponding_Spec (Subp_Decl))\n             then\n+               null;\n+\n+            --  Body stub acts as spec\n+\n+            elsif Nkind (Subp_Decl) = N_Subprogram_Body_Stub\n+              and then No (Corresponding_Spec_Of_Stub (Subp_Decl))\n+            then\n+               null;\n+\n+            else\n                Pragma_Misplaced;\n                return;\n             end if;\n@@ -14239,10 +14269,24 @@ package body Sem_Prag is\n             Subp_Decl :=\n               Find_Related_Subprogram_Or_Body (N, Do_Checks => True);\n \n-            if Nkind (Subp_Decl) /= N_Subprogram_Declaration\n-              and then (Nkind (Subp_Decl) /= N_Subprogram_Body\n-                          or else not Acts_As_Spec (Subp_Decl))\n+            if Nkind (Subp_Decl) = N_Subprogram_Declaration then\n+               null;\n+\n+            --  Body acts as spec\n+\n+            elsif Nkind (Subp_Decl) = N_Subprogram_Body\n+              and then No (Corresponding_Spec (Subp_Decl))\n             then\n+               null;\n+\n+            --  Body stub acts as spec\n+\n+            elsif Nkind (Subp_Decl) = N_Subprogram_Body_Stub\n+              and then No (Corresponding_Spec_Of_Stub (Subp_Decl))\n+            then\n+               null;\n+\n+            else\n                Pragma_Misplaced;\n                return;\n             end if;"}]}