{"sha": "84bc717b510cc56f64120dd58c64e1f6ebfad5e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRiYzcxN2I1MTBjYzU2ZjY0MTIwZGQ1OGM2NGUxZjZlYmZhZDVlMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-20T12:52:22Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-20T12:52:22Z"}, "message": "poly_int: REG_OFFSET\n\nThis patch changes the type of the reg_attrs offset field\nfrom HOST_WIDE_INT to poly_int64 and updates uses accordingly.\nThis includes changing reg_attr_hasher::hash to use inchash.\n(Doing this has no effect on code generation since the only\nuse of the hasher is to avoid creating duplicate objects.)\n\n2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n            Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* rtl.h (reg_attrs::offset): Change from HOST_WIDE_INT to poly_int64.\n\t(gen_rtx_REG_offset): Take the offset as a poly_int64.\n\t* inchash.h (inchash::hash::add_poly_hwi): New function.\n\t* gengtype.c (main): Register poly_int64.\n\t* emit-rtl.c (reg_attr_hasher::hash): Use inchash.  Treat the\n\toffset as a poly_int.\n\t(reg_attr_hasher::equal): Use must_eq to compare offsets.\n\t(get_reg_attrs, update_reg_offset, gen_rtx_REG_offset): Take the\n\toffset as a poly_int64.\n\t(set_reg_attrs_from_value): Treat the offset as a poly_int64.\n\t* print-rtl.c (print_poly_int): New function.\n\t(rtx_writer::print_rtx_operand_code_r): Treat REG_OFFSET as\n\ta poly_int.\n\t* var-tracking.c (track_offset_p, get_tracked_reg_offset): New\n\tfunctions.\n\t(var_reg_set, var_reg_delete_and_set, var_reg_delete): Use them.\n\t(same_variable_part_p, track_loc_p): Take the offset as a poly_int64.\n\t(vt_get_decl_and_offset): Return the offset as a poly_int64.\n\tEnforce track_offset_p for parts of a PARALLEL.\n\t(vt_add_function_parameter): Use const_offset for the final\n\toffset to track.  Use get_tracked_reg_offset for the parts\n\tof a PARALLEL.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255867", "tree": {"sha": "453653202c11c4dbbfe83c406937159f5b19a558", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/453653202c11c4dbbfe83c406937159f5b19a558"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84bc717b510cc56f64120dd58c64e1f6ebfad5e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84bc717b510cc56f64120dd58c64e1f6ebfad5e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84bc717b510cc56f64120dd58c64e1f6ebfad5e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84bc717b510cc56f64120dd58c64e1f6ebfad5e3/comments", "author": null, "committer": null, "parents": [{"sha": "37b2b8f95783b449aca30d32f4c97a4db3bd395e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37b2b8f95783b449aca30d32f4c97a4db3bd395e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37b2b8f95783b449aca30d32f4c97a4db3bd395e"}], "stats": {"total": 167, "additions": 127, "deletions": 40}, "files": [{"sha": "78cd21e955622669aeca85c7f457b33d122302c5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84bc717b510cc56f64120dd58c64e1f6ebfad5e3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84bc717b510cc56f64120dd58c64e1f6ebfad5e3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=84bc717b510cc56f64120dd58c64e1f6ebfad5e3", "patch": "@@ -1,3 +1,30 @@\n+2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n+            Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* rtl.h (reg_attrs::offset): Change from HOST_WIDE_INT to poly_int64.\n+\t(gen_rtx_REG_offset): Take the offset as a poly_int64.\n+\t* inchash.h (inchash::hash::add_poly_hwi): New function.\n+\t* gengtype.c (main): Register poly_int64.\n+\t* emit-rtl.c (reg_attr_hasher::hash): Use inchash.  Treat the\n+\toffset as a poly_int.\n+\t(reg_attr_hasher::equal): Use must_eq to compare offsets.\n+\t(get_reg_attrs, update_reg_offset, gen_rtx_REG_offset): Take the\n+\toffset as a poly_int64.\n+\t(set_reg_attrs_from_value): Treat the offset as a poly_int64.\n+\t* print-rtl.c (print_poly_int): New function.\n+\t(rtx_writer::print_rtx_operand_code_r): Treat REG_OFFSET as\n+\ta poly_int.\n+\t* var-tracking.c (track_offset_p, get_tracked_reg_offset): New\n+\tfunctions.\n+\t(var_reg_set, var_reg_delete_and_set, var_reg_delete): Use them.\n+\t(same_variable_part_p, track_loc_p): Take the offset as a poly_int64.\n+\t(vt_get_decl_and_offset): Return the offset as a poly_int64.\n+\tEnforce track_offset_p for parts of a PARALLEL.\n+\t(vt_add_function_parameter): Use const_offset for the final\n+\toffset to track.  Use get_tracked_reg_offset for the parts\n+\tof a PARALLEL.\n+\n 2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n             Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "ff3585e305ab16e3fb0b2b1999425ea051012cdb", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84bc717b510cc56f64120dd58c64e1f6ebfad5e3/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84bc717b510cc56f64120dd58c64e1f6ebfad5e3/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=84bc717b510cc56f64120dd58c64e1f6ebfad5e3", "patch": "@@ -196,7 +196,6 @@ static rtx lookup_const_wide_int (rtx);\n #endif\n static rtx lookup_const_double (rtx);\n static rtx lookup_const_fixed (rtx);\n-static reg_attrs *get_reg_attrs (tree, int);\n static rtx gen_const_vector (machine_mode, int);\n static void copy_rtx_if_shared_1 (rtx *orig);\n \n@@ -393,7 +392,10 @@ reg_attr_hasher::hash (reg_attrs *x)\n {\n   const reg_attrs *const p = x;\n \n-  return ((p->offset * 1000) ^ (intptr_t) p->decl);\n+  inchash::hash h;\n+  h.add_ptr (p->decl);\n+  h.add_poly_hwi (p->offset);\n+  return h.end ();\n }\n \n /* Returns nonzero if the value represented by X  is the same as that given by\n@@ -405,19 +407,19 @@ reg_attr_hasher::equal (reg_attrs *x, reg_attrs *y)\n   const reg_attrs *const p = x;\n   const reg_attrs *const q = y;\n \n-  return (p->decl == q->decl && p->offset == q->offset);\n+  return (p->decl == q->decl && known_eq (p->offset, q->offset));\n }\n /* Allocate a new reg_attrs structure and insert it into the hash table if\n    one identical to it is not already in the table.  We are doing this for\n    MEM of mode MODE.  */\n \n static reg_attrs *\n-get_reg_attrs (tree decl, int offset)\n+get_reg_attrs (tree decl, poly_int64 offset)\n {\n   reg_attrs attrs;\n \n   /* If everything is the default, we can just return zero.  */\n-  if (decl == 0 && offset == 0)\n+  if (decl == 0 && known_eq (offset, 0))\n     return 0;\n \n   attrs.decl = decl;\n@@ -1218,18 +1220,18 @@ reg_is_parm_p (rtx reg)\n    to the REG_OFFSET.  */\n \n static void\n-update_reg_offset (rtx new_rtx, rtx reg, int offset)\n+update_reg_offset (rtx new_rtx, rtx reg, poly_int64 offset)\n {\n   REG_ATTRS (new_rtx) = get_reg_attrs (REG_EXPR (reg),\n-\t\t\t\t   REG_OFFSET (reg) + offset);\n+\t\t\t\t       REG_OFFSET (reg) + offset);\n }\n \n /* Generate a register with same attributes as REG, but with OFFSET\n    added to the REG_OFFSET.  */\n \n rtx\n gen_rtx_REG_offset (rtx reg, machine_mode mode, unsigned int regno,\n-\t\t    int offset)\n+\t\t    poly_int64 offset)\n {\n   rtx new_rtx = gen_rtx_REG (mode, regno);\n \n@@ -1265,7 +1267,7 @@ adjust_reg_mode (rtx reg, machine_mode mode)\n void\n set_reg_attrs_from_value (rtx reg, rtx x)\n {\n-  int offset;\n+  poly_int64 offset;\n   bool can_be_reg_pointer = true;\n \n   /* Don't call mark_reg_pointer for incompatible pointer sign"}, {"sha": "8be413070f0f87db1c4d4ec0403164ef38c0e1cb", "filename": "gcc/gengtype.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84bc717b510cc56f64120dd58c64e1f6ebfad5e3/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84bc717b510cc56f64120dd58c64e1f6ebfad5e3/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=84bc717b510cc56f64120dd58c64e1f6ebfad5e3", "patch": "@@ -5190,6 +5190,7 @@ main (int argc, char **argv)\n       POS_HERE (do_scalar_typedef (\"offset_int\", &pos));\n       POS_HERE (do_scalar_typedef (\"widest_int\", &pos));\n       POS_HERE (do_scalar_typedef (\"int64_t\", &pos));\n+      POS_HERE (do_scalar_typedef (\"poly_int64\", &pos));\n       POS_HERE (do_scalar_typedef (\"uint64_t\", &pos));\n       POS_HERE (do_scalar_typedef (\"uint8\", &pos));\n       POS_HERE (do_scalar_typedef (\"uintptr_t\", &pos));"}, {"sha": "614462933ba14a64817b98ba833591b2873077e2", "filename": "gcc/inchash.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84bc717b510cc56f64120dd58c64e1f6ebfad5e3/gcc%2Finchash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84bc717b510cc56f64120dd58c64e1f6ebfad5e3/gcc%2Finchash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finchash.h?ref=84bc717b510cc56f64120dd58c64e1f6ebfad5e3", "patch": "@@ -63,6 +63,14 @@ class hash\n     val = iterative_hash_host_wide_int (v, val);\n   }\n \n+  /* Add polynomial value V, treating each element as a HOST_WIDE_INT.  */\n+  template<unsigned int N, typename T>\n+  void add_poly_hwi (const poly_int_pod<N, T> &v)\n+  {\n+    for (unsigned int i = 0; i < N; ++i)\n+      add_hwi (v.coeffs[i]);\n+  }\n+\n   /* Add wide_int-based value V.  */\n   template<typename T>\n   void add_wide_int (const generic_wide_int<T> &x)"}, {"sha": "7e0a0a015747be695a4e9d80892053ec89d948f5", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84bc717b510cc56f64120dd58c64e1f6ebfad5e3/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84bc717b510cc56f64120dd58c64e1f6ebfad5e3/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=84bc717b510cc56f64120dd58c64e1f6ebfad5e3", "patch": "@@ -178,6 +178,23 @@ print_mem_expr (FILE *outfile, const_tree expr)\n   fputc (' ', outfile);\n   print_generic_expr (outfile, CONST_CAST_TREE (expr), dump_flags);\n }\n+\n+/* Print X to FILE.  */\n+\n+static void\n+print_poly_int (FILE *file, poly_int64 x)\n+{\n+  HOST_WIDE_INT const_x;\n+  if (x.is_constant (&const_x))\n+    fprintf (file, HOST_WIDE_INT_PRINT_DEC, const_x);\n+  else\n+    {\n+      fprintf (file, \"[\" HOST_WIDE_INT_PRINT_DEC, x.coeffs[0]);\n+      for (int i = 1; i < NUM_POLY_INT_COEFFS; ++i)\n+\tfprintf (file, \", \" HOST_WIDE_INT_PRINT_DEC, x.coeffs[i]);\n+      fprintf (file, \"]\");\n+    }\n+}\n #endif\n \n /* Subroutine of print_rtx_operand for handling code '0'.\n@@ -509,9 +526,11 @@ rtx_writer::print_rtx_operand_code_r (const_rtx in_rtx)\n       if (REG_EXPR (in_rtx))\n \tprint_mem_expr (m_outfile, REG_EXPR (in_rtx));\n \n-      if (REG_OFFSET (in_rtx))\n-\tfprintf (m_outfile, \"+\" HOST_WIDE_INT_PRINT_DEC,\n-\t\t REG_OFFSET (in_rtx));\n+      if (maybe_ne (REG_OFFSET (in_rtx), 0))\n+\t{\n+\t  fprintf (m_outfile, \"+\");\n+\t  print_poly_int (m_outfile, REG_OFFSET (in_rtx));\n+\t}\n       fputs (\" ]\", m_outfile);\n     }\n   if (regno != ORIGINAL_REGNO (in_rtx))"}, {"sha": "ed944a4d98941896c2fa731abdde8329e3f52195", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84bc717b510cc56f64120dd58c64e1f6ebfad5e3/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84bc717b510cc56f64120dd58c64e1f6ebfad5e3/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=84bc717b510cc56f64120dd58c64e1f6ebfad5e3", "patch": "@@ -187,7 +187,7 @@ struct GTY(()) mem_attrs\n \n struct GTY((for_user)) reg_attrs {\n   tree decl;\t\t\t/* decl corresponding to REG.  */\n-  HOST_WIDE_INT offset;\t\t/* Offset from start of DECL.  */\n+  poly_int64 offset;\t\t/* Offset from start of DECL.  */\n };\n \n /* Common union for an element of an rtx.  */\n@@ -3023,7 +3023,7 @@ subreg_promoted_mode (rtx x)\n extern rtvec gen_rtvec_v (int, rtx *);\n extern rtvec gen_rtvec_v (int, rtx_insn **);\n extern rtx gen_reg_rtx (machine_mode);\n-extern rtx gen_rtx_REG_offset (rtx, machine_mode, unsigned int, int);\n+extern rtx gen_rtx_REG_offset (rtx, machine_mode, unsigned int, poly_int64);\n extern rtx gen_reg_rtx_offset (rtx, machine_mode, int);\n extern rtx gen_reg_rtx_and_attrs (rtx);\n extern rtx_code_label *gen_label_rtx (void);"}, {"sha": "2f68298ac78d2fc2b05cd7e18ea8979de9f21ddf", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 56, "deletions": 26, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84bc717b510cc56f64120dd58c64e1f6ebfad5e3/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84bc717b510cc56f64120dd58c64e1f6ebfad5e3/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=84bc717b510cc56f64120dd58c64e1f6ebfad5e3", "patch": "@@ -673,7 +673,6 @@ static bool dataflow_set_different (dataflow_set *, dataflow_set *);\n static void dataflow_set_destroy (dataflow_set *);\n \n static bool track_expr_p (tree, bool);\n-static bool same_variable_part_p (rtx, tree, HOST_WIDE_INT);\n static void add_uses_1 (rtx *, void *);\n static void add_stores (rtx, const_rtx, void *);\n static bool compute_bb_dataflow (basic_block);\n@@ -704,7 +703,6 @@ static void delete_variable_part (dataflow_set *, rtx,\n static void emit_notes_in_bb (basic_block, dataflow_set *);\n static void vt_emit_notes (void);\n \n-static bool vt_get_decl_and_offset (rtx, tree *, HOST_WIDE_INT *);\n static void vt_add_function_parameters (void);\n static bool vt_initialize (void);\n static void vt_finalize (void);\n@@ -1850,14 +1848,40 @@ var_reg_decl_set (dataflow_set *set, rtx loc, enum var_init_status initialized,\n   set_variable_part (set, loc, dv, offset, initialized, set_src, iopt);\n }\n \n+/* Return true if we should track a location that is OFFSET bytes from\n+   a variable.  Store the constant offset in *OFFSET_OUT if so.  */\n+\n+static bool\n+track_offset_p (poly_int64 offset, HOST_WIDE_INT *offset_out)\n+{\n+  HOST_WIDE_INT const_offset;\n+  if (!offset.is_constant (&const_offset)\n+      || !IN_RANGE (const_offset, 0, MAX_VAR_PARTS - 1))\n+    return false;\n+  *offset_out = const_offset;\n+  return true;\n+}\n+\n+/* Return the offset of a register that track_offset_p says we\n+   should track.  */\n+\n+static HOST_WIDE_INT\n+get_tracked_reg_offset (rtx loc)\n+{\n+  HOST_WIDE_INT offset;\n+  if (!track_offset_p (REG_OFFSET (loc), &offset))\n+    gcc_unreachable ();\n+  return offset;\n+}\n+\n /* Set the register to contain REG_EXPR (LOC), REG_OFFSET (LOC).  */\n \n static void\n var_reg_set (dataflow_set *set, rtx loc, enum var_init_status initialized,\n \t     rtx set_src)\n {\n   tree decl = REG_EXPR (loc);\n-  HOST_WIDE_INT offset = REG_OFFSET (loc);\n+  HOST_WIDE_INT offset = get_tracked_reg_offset (loc);\n \n   var_reg_decl_set (set, loc, initialized,\n \t\t    dv_from_decl (decl), offset, set_src, INSERT);\n@@ -1903,7 +1927,7 @@ var_reg_delete_and_set (dataflow_set *set, rtx loc, bool modify,\n \t\t\tenum var_init_status initialized, rtx set_src)\n {\n   tree decl = REG_EXPR (loc);\n-  HOST_WIDE_INT offset = REG_OFFSET (loc);\n+  HOST_WIDE_INT offset = get_tracked_reg_offset (loc);\n   attrs *node, *next;\n   attrs **nextp;\n \n@@ -1944,10 +1968,10 @@ var_reg_delete (dataflow_set *set, rtx loc, bool clobber)\n   attrs **nextp = &set->regs[REGNO (loc)];\n   attrs *node, *next;\n \n-  if (clobber)\n+  HOST_WIDE_INT offset;\n+  if (clobber && track_offset_p (REG_OFFSET (loc), &offset))\n     {\n       tree decl = REG_EXPR (loc);\n-      HOST_WIDE_INT offset = REG_OFFSET (loc);\n \n       decl = var_debug_decl (decl);\n \n@@ -5245,10 +5269,10 @@ track_expr_p (tree expr, bool need_rtl)\n    EXPR+OFFSET.  */\n \n static bool\n-same_variable_part_p (rtx loc, tree expr, HOST_WIDE_INT offset)\n+same_variable_part_p (rtx loc, tree expr, poly_int64 offset)\n {\n   tree expr2;\n-  HOST_WIDE_INT offset2;\n+  poly_int64 offset2;\n \n   if (! DECL_P (expr))\n     return false;\n@@ -5272,7 +5296,7 @@ same_variable_part_p (rtx loc, tree expr, HOST_WIDE_INT offset)\n   expr = var_debug_decl (expr);\n   expr2 = var_debug_decl (expr2);\n \n-  return (expr == expr2 && offset == offset2);\n+  return (expr == expr2 && known_eq (offset, offset2));\n }\n \n /* LOC is a REG or MEM that we would like to track if possible.\n@@ -5286,7 +5310,7 @@ same_variable_part_p (rtx loc, tree expr, HOST_WIDE_INT offset)\n    from EXPR in *OFFSET_OUT (if nonnull).  */\n \n static bool\n-track_loc_p (rtx loc, tree expr, HOST_WIDE_INT offset, bool store_reg_p,\n+track_loc_p (rtx loc, tree expr, poly_int64 offset, bool store_reg_p,\n \t     machine_mode *mode_out, HOST_WIDE_INT *offset_out)\n {\n   machine_mode mode;\n@@ -5320,19 +5344,20 @@ track_loc_p (rtx loc, tree expr, HOST_WIDE_INT offset, bool store_reg_p,\n        || (store_reg_p\n \t   && !COMPLEX_MODE_P (DECL_MODE (expr))\n \t   && hard_regno_nregs (REGNO (loc), DECL_MODE (expr)) == 1))\n-      && offset + byte_lowpart_offset (DECL_MODE (expr), mode) == 0)\n+      && known_eq (offset + byte_lowpart_offset (DECL_MODE (expr), mode), 0))\n     {\n       mode = DECL_MODE (expr);\n       offset = 0;\n     }\n \n-  if (offset < 0 || offset >= MAX_VAR_PARTS)\n+  HOST_WIDE_INT const_offset;\n+  if (!track_offset_p (offset, &const_offset))\n     return false;\n \n   if (mode_out)\n     *mode_out = mode;\n   if (offset_out)\n-    *offset_out = offset;\n+    *offset_out = const_offset;\n   return true;\n }\n \n@@ -9561,7 +9586,7 @@ vt_emit_notes (void)\n    assign declaration to *DECLP and offset to *OFFSETP, and return true.  */\n \n static bool\n-vt_get_decl_and_offset (rtx rtl, tree *declp, HOST_WIDE_INT *offsetp)\n+vt_get_decl_and_offset (rtx rtl, tree *declp, poly_int64 *offsetp)\n {\n   if (REG_P (rtl))\n     {\n@@ -9587,8 +9612,10 @@ vt_get_decl_and_offset (rtx rtl, tree *declp, HOST_WIDE_INT *offsetp)\n \t    decl = REG_EXPR (reg);\n \t  if (REG_EXPR (reg) != decl)\n \t    break;\n-\t  if (REG_OFFSET (reg) < offset)\n-\t    offset = REG_OFFSET (reg);\n+\t  HOST_WIDE_INT this_offset;\n+\t  if (!track_offset_p (REG_OFFSET (reg), &this_offset))\n+\t    break;\n+\t  offset = MIN (offset, this_offset);\n \t}\n \n       if (i == len)\n@@ -9632,7 +9659,7 @@ vt_add_function_parameter (tree parm)\n   rtx incoming = DECL_INCOMING_RTL (parm);\n   tree decl;\n   machine_mode mode;\n-  HOST_WIDE_INT offset;\n+  poly_int64 offset;\n   dataflow_set *out;\n   decl_or_value dv;\n \n@@ -9755,7 +9782,8 @@ vt_add_function_parameter (tree parm)\n       offset = 0;\n     }\n \n-  if (!track_loc_p (incoming, parm, offset, false, &mode, &offset))\n+  HOST_WIDE_INT const_offset;\n+  if (!track_loc_p (incoming, parm, offset, false, &mode, &const_offset))\n     return;\n \n   out = &VTI (ENTRY_BLOCK_PTR_FOR_FN (cfun))->out;\n@@ -9776,7 +9804,7 @@ vt_add_function_parameter (tree parm)\n \t arguments passed by invisible reference aren't dealt with\n \t above: incoming-rtl will have Pmode rather than the\n \t expected mode for the type.  */\n-      if (offset)\n+      if (const_offset)\n \treturn;\n \n       lowpart = var_lowpart (mode, incoming);\n@@ -9791,7 +9819,7 @@ vt_add_function_parameter (tree parm)\n       if (val)\n \t{\n \t  preserve_value (val);\n-\t  set_variable_part (out, val->val_rtx, dv, offset,\n+\t  set_variable_part (out, val->val_rtx, dv, const_offset,\n \t\t\t     VAR_INIT_STATUS_INITIALIZED, NULL, INSERT);\n \t  dv = dv_from_value (val->val_rtx);\n \t}\n@@ -9812,9 +9840,9 @@ vt_add_function_parameter (tree parm)\n     {\n       incoming = var_lowpart (mode, incoming);\n       gcc_assert (REGNO (incoming) < FIRST_PSEUDO_REGISTER);\n-      attrs_list_insert (&out->regs[REGNO (incoming)], dv, offset,\n+      attrs_list_insert (&out->regs[REGNO (incoming)], dv, const_offset,\n \t\t\t incoming);\n-      set_variable_part (out, incoming, dv, offset,\n+      set_variable_part (out, incoming, dv, const_offset,\n \t\t\t VAR_INIT_STATUS_INITIALIZED, NULL, INSERT);\n       if (dv_is_value_p (dv))\n \t{\n@@ -9845,17 +9873,19 @@ vt_add_function_parameter (tree parm)\n       for (i = 0; i < XVECLEN (incoming, 0); i++)\n \t{\n \t  rtx reg = XEXP (XVECEXP (incoming, 0, i), 0);\n-\t  offset = REG_OFFSET (reg);\n+\t  /* vt_get_decl_and_offset has already checked that the offset\n+\t     is a valid variable part.  */\n+\t  const_offset = get_tracked_reg_offset (reg);\n \t  gcc_assert (REGNO (reg) < FIRST_PSEUDO_REGISTER);\n-\t  attrs_list_insert (&out->regs[REGNO (reg)], dv, offset, reg);\n-\t  set_variable_part (out, reg, dv, offset,\n+\t  attrs_list_insert (&out->regs[REGNO (reg)], dv, const_offset, reg);\n+\t  set_variable_part (out, reg, dv, const_offset,\n \t\t\t     VAR_INIT_STATUS_INITIALIZED, NULL, INSERT);\n \t}\n     }\n   else if (MEM_P (incoming))\n     {\n       incoming = var_lowpart (mode, incoming);\n-      set_variable_part (out, incoming, dv, offset,\n+      set_variable_part (out, incoming, dv, const_offset,\n \t\t\t VAR_INIT_STATUS_INITIALIZED, NULL, INSERT);\n     }\n }"}]}