{"sha": "52ceb03971fb7f878b8a610fa97b07a4de510057", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJjZWIwMzk3MWZiN2Y4NzhiOGE2MTBmYTk3YjA3YTRkZTUxMDA1Nw==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2004-05-22T21:07:28Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2004-05-22T21:07:28Z"}, "message": "cxxabi.h: Remove duplicated and useless public and private keywords in class declarations.\n\n\n2004-05-22  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* libsupc++/cxxabi.h: Remove duplicated and useless public and\n        private keywords in class declarations. Format. Use\n        stddef.h. Expose declarations to \"C\" compilation.\n        * libsupc++/tinfo.cc (__upcast_result): Add copy constructor and\n        assignment operator.\n        (__dyncast_result): Same.\n        * libsupc++/vec.cc (uncatch_exception): Same, use member\n        initialization list.\n\nFrom-SVN: r82147", "tree": {"sha": "23654e9da6110cd9ea2622acdc23878553d079e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23654e9da6110cd9ea2622acdc23878553d079e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52ceb03971fb7f878b8a610fa97b07a4de510057", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52ceb03971fb7f878b8a610fa97b07a4de510057", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52ceb03971fb7f878b8a610fa97b07a4de510057", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52ceb03971fb7f878b8a610fa97b07a4de510057/comments", "author": null, "committer": null, "parents": [{"sha": "8e657c46b4a82b1fc4e4487fad9d9e9be07da2bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e657c46b4a82b1fc4e4487fad9d9e9be07da2bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e657c46b4a82b1fc4e4487fad9d9e9be07da2bf"}], "stats": {"total": 954, "additions": 482, "deletions": 472}, "files": [{"sha": "5a360726d96afeaa251e435db88d3f9c34044663", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ceb03971fb7f878b8a610fa97b07a4de510057/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ceb03971fb7f878b8a610fa97b07a4de510057/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=52ceb03971fb7f878b8a610fa97b07a4de510057", "patch": "@@ -1,3 +1,14 @@\n+2004-05-22  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* libsupc++/cxxabi.h: Remove duplicated and useless public and\n+        private keywords in class declarations. Format. Use\n+        stddef.h. Expose declarations to \"C\" compilation.\n+        * libsupc++/tinfo.cc (__upcast_result): Add copy constructor and\n+        assignment operator.\n+        (__dyncast_result): Same.\n+        * libsupc++/vec.cc (uncatch_exception): Same, use member\n+        initialization list.\n+                 \n 2004-05-22  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* testsuite/abi_check.cc: Add unistd.h."}, {"sha": "35535491035b733623a370decd4b5d550f52ce7e", "filename": "libstdc++-v3/libsupc++/cxxabi.h", "status": "modified", "additions": 436, "deletions": 466, "changes": 902, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ceb03971fb7f878b8a610fa97b07a4de510057/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ceb03971fb7f878b8a610fa97b07a4de510057/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi.h?ref=52ceb03971fb7f878b8a610fa97b07a4de510057", "patch": "@@ -1,6 +1,6 @@\n // new abi support -*- C++ -*-\n   \n-// Copyright (C) 2000, 2002, 2003 Free Software Foundation, Inc.\n+// Copyright (C) 2000, 2002, 2003, 2004 Free Software Foundation, Inc.\n //\n // This file is part of GCC.\n //\n@@ -42,517 +42,487 @@\n #ifndef _CXXABI_H\n #define _CXXABI_H 1\n \n+#include <stddef.h>\n+ \n #ifdef __cplusplus\n+namespace __cxxabiv1\n+{  \n+  extern \"C\" \n+  {\n+#endif\n+\n+  // Allocate array.\n+  void* \n+  __cxa_vec_new(size_t __element_count, size_t __element_size, \n+\t\tsize_t __padding_size, void (*__constructor) (void*),\n+\t\tvoid (*__destructor) (void*));\n+\n+  void*\n+  __cxa_vec_new2(size_t __element_count, size_t __element_size,\n+\t\t size_t __padding_size, void (*__constructor) (void*),\n+\t\t void (*__destructor) (void*), void *(*__alloc) (size_t), \n+\t\t void (*__dealloc) (void*));\n+\n+  void*\n+  __cxa_vec_new3(size_t __element_count, size_t __element_size,\n+\t\t size_t __padding_size, void (*__constructor) (void*),\n+\t\t void (*__destructor) (void*), void *(*__alloc) (size_t), \n+\t\t void (*__dealloc) (void*, size_t));\n+\n+  // Construct array.\n+  void \n+  __cxa_vec_ctor(void* __array_address, size_t __element_count,\n+\t\t size_t __element_size, void (*__constructor) (void*),\n+\t\t void (*__destructor) (void*));\n+\n+  void \n+  __cxa_vec_cctor(void* dest_array, void* src_array, size_t element_count, \n+\t\t  size_t element_size, void (*constructor) (void*, void*), \n+\t\t  void (*destructor) (void*));\n+ \n+  // Destruct array.\n+  void \n+  __cxa_vec_dtor(void* __array_address, size_t __element_count,\n+\t\t size_t __element_size, void (*__destructor) (void*));\n+  \n+  void \n+  __cxa_vec_cleanup(void* __array_address, size_t __element_count,\n+\t\t    size_t __element_size, void (*__destructor) (void*));\n+  \n+  // Destruct and release array.\n+  void \n+  __cxa_vec_delete(void* __array_address, size_t __element_size,\n+\t\t   size_t __padding_size, void (*__destructor) (void*));\n+\n+  void \n+  __cxa_vec_delete2(void* __array_address, size_t __element_size,\n+\t\t    size_t __padding_size, void (*__destructor) (void*),\n+\t\t    void (*__dealloc) (void*));\n+                  \n+  void \n+  __cxa_vec_delete3(void* __array_address, size_t __element_size,\n+\t\t    size_t __padding_size, void (*__destructor) (void*),\n+\t\t    void (*__dealloc) (void*, size_t));\n \n-// We use the compiler builtins __SIZE_TYPE__ and __PTRDIFF_TYPE__ instead of\n-// std::size_t and std::ptrdiff_t respectively. This makes us independent of\n-// the conformance level of <cstddef> and whether -fhonor-std was supplied.\n-// <cstddef> is not currently available during compiler building anyway.\n-// Including <stddef.h> would be wrong, as that would rudely place size_t in\n-// the global namespace.\n+  // The ABI requires a 64-bit type.\n+  __extension__ typedef int __guard __attribute__((mode (__DI__)));\n \n-#include <typeinfo>\n+  int \n+  __cxa_guard_acquire(__guard*);\n \n-namespace __cxxabiv1\n-{\n+  void \n+  __cxa_guard_release(__guard*);\n \n-/* type information for int, float etc */\n-class __fundamental_type_info\n-  : public std::type_info\n-{\n-public:\n-  virtual ~__fundamental_type_info ();\n-public:\n-  explicit __fundamental_type_info (const char *__n)\n-    : std::type_info (__n)\n-    { }\n-};\n+  void \n+  __cxa_guard_abort(__guard*);\n \n-/* type information for array objects */\n-class __array_type_info\n-  : public std::type_info\n-{\n-/* abi defined member functions */\n-protected:\n-  virtual ~__array_type_info ();\n-public:\n-  explicit __array_type_info (const char *__n)\n-    : std::type_info (__n)\n-    { }\n-};\n+  // Pure virtual functions.\n+  void\n+  __cxa_pure_virtual(void);\n \n-/* type information for functions (both member and non-member) */\n-class __function_type_info\n-  : public std::type_info\n-{\n-/* abi defined member functions */\n-public:\n-  virtual ~__function_type_info ();\n-public:\n-  explicit __function_type_info (const char *__n)\n-    : std::type_info (__n)\n-    { }\n-  \n-/* implementation defined member functions */\n-protected:\n-  virtual bool __is_function_p () const;\n-};\n-\n-/* type information for enumerations */\n-class __enum_type_info\n-  : public std::type_info\n-{\n-/* abi defined member functions */\n-public:\n-  virtual ~__enum_type_info ();\n-public:\n-  explicit __enum_type_info (const char *__n)\n-    : std::type_info (__n)\n-    { }\n-};\n+  // Exception handling.\n+  void\n+  __cxa_bad_cast();\n \n-/* common type information for simple pointers and pointers to member */\n-class __pbase_type_info\n-  : public std::type_info\n-{\n-/* abi defined member variables */\n-public:\n-  unsigned int __flags; /* qualification of the target object */\n-  const std::type_info *__pointee;   /* type of pointed to object */\n-\n-/* abi defined member functions */\n-public:\n-  virtual ~__pbase_type_info ();\n-public:\n-  explicit __pbase_type_info (const char *__n,\n-                                int __quals,\n-                                const std::type_info *__type)\n-    : std::type_info (__n), __flags (__quals), __pointee (__type)\n-    { }\n+  void\n+  __cxa_bad_typeid();\n \n-/* implementation defined types */\n-public:\n-  enum __masks {\n-    __const_mask = 0x1,\n-    __volatile_mask = 0x2,\n-    __restrict_mask = 0x4,\n-    __incomplete_mask = 0x8,\n-    __incomplete_class_mask = 0x10\n-  };\n+  // DSO destruction.\n+  int\n+  __cxa_atexit(void (*)(void*), void*, void*);\n \n-/* implementation defined member functions */\n-protected:\n-  virtual bool __do_catch (const std::type_info *__thr_type,\n-                           void **__thr_obj,\n-                           unsigned __outer) const;\n-protected:\n-  inline virtual bool __pointer_catch (const __pbase_type_info *__thr_type,\n-                                       void **__thr_obj,\n-                                       unsigned __outer) const;\n-};\n-\n-/* type information for simple pointers */\n-class __pointer_type_info\n-  : public __pbase_type_info\n-{\n-/* abi defined member functions */\n-public:\n-  virtual ~__pointer_type_info ();\n-public:\n-  explicit __pointer_type_info (const char *__n,\n-                                int __quals,\n-                                const std::type_info *__type)\n-    : __pbase_type_info (__n, __quals, __type)\n-    { }\n+  int\n+  __cxa_finalize(void*);\n \n-/* implementation defined member functions */\n-protected:\n-  virtual bool __is_pointer_p () const;\n+  // Demangling routines. \n+  char*\n+  __cxa_demangle(const char* __mangled_name, char* __output_buffer,\n+\t\t size_t* __length, int* __status);\n+#ifdef __cplusplus\n+  }\n+} // namespace __cxxabiv1\n+#endif\n \n-protected:\n-  virtual bool __pointer_catch (const __pbase_type_info *__thr_type,\n-                                void **__thr_obj,\n-                                unsigned __outer) const;\n-};\n+#ifdef __cplusplus\n \n-class __class_type_info;\n+#include <typeinfo>\n \n-/* type information for a pointer to member variable */\n-class __pointer_to_member_type_info\n-  : public __pbase_type_info\n+namespace __cxxabiv1\n {\n-/* abi defined member variables */\n-public:\n-  __class_type_info *__context;   /* class of the member */\n-\n-/* abi defined member functions */\n-public:\n-  virtual ~__pointer_to_member_type_info ();\n-public:\n-  explicit __pointer_to_member_type_info (const char *__n,\n-                                          int __quals,\n-                                          const std::type_info *__type,\n-                                          __class_type_info *__klass)\n-    : __pbase_type_info (__n, __quals, __type), __context (__klass)\n-    { }\n+  // Type information for int, float etc.\n+  class __fundamental_type_info : public std::type_info\n+  {\n+  public:\n+    explicit \n+    __fundamental_type_info(const char* __n) : std::type_info(__n) { }\n \n-/* implementation defined member functions */\n-protected:\n-  virtual bool __pointer_catch (const __pbase_type_info *__thr_type,\n-                                void **__thr_obj,\n-                                unsigned __outer) const;\n-};\n+    virtual \n+    ~__fundamental_type_info();\n+  };\n \n-/* helper class for __vmi_class_type */\n-class __base_class_type_info\n-{\n-/* abi defined member variables */\n-public:\n-  const __class_type_info* __base_type;    /* base class type */\n-  long __offset_flags;            /* offset and info */\n-\n-/* implementation defined types */\n-public:\n-  enum __offset_flags_masks {\n-    __virtual_mask = 0x1,\n-    __public_mask = 0x2,\n-    __hwm_bit = 2,\n-    __offset_shift = 8          /* bits to shift offset by */\n+  // Type information for array objects.\n+  class __array_type_info : public std::type_info\n+  {\n+  public:\n+    explicit \n+    __array_type_info(const char* __n) : std::type_info(__n) { }\n+\n+    virtual \n+    ~__array_type_info();\n   };\n-  \n-/* implementation defined member functions */\n-public:\n-  bool __is_virtual_p () const\n-    { return __offset_flags & __virtual_mask; }\n-  bool __is_public_p () const\n-    { return __offset_flags & __public_mask; }\n-  __PTRDIFF_TYPE__ __offset () const\n-    { \n-      // This shift, being of a signed type, is implementation defined. GCC\n-      // implements such shifts as arithmetic, which is what we want.\n-      return static_cast<__PTRDIFF_TYPE__> (__offset_flags) >> __offset_shift;\n-    }\n-};\n \n-/* type information for a class */\n-class __class_type_info\n-  : public std::type_info\n-{\n-/* abi defined member functions */\n-public:\n-  virtual ~__class_type_info ();\n-public:\n-  explicit __class_type_info (const char *__n)\n-    : type_info (__n)\n-    { }\n+  // Type information for functions (both member and non-member).\n+  class __function_type_info : public std::type_info\n+  {\n+  public:\n+    explicit \n+    __function_type_info(const char* __n) : std::type_info(__n) { }\n \n-/* implementation defined types */\n-public:\n-  /* sub_kind tells us about how a base object is contained within a derived\n-     object. We often do this lazily, hence the UNKNOWN value. At other times\n-     we may use NOT_CONTAINED to mean not publicly contained. */\n-  enum __sub_kind\n+    virtual \n+    ~__function_type_info();\n+\n+  protected:\n+    // Implementation defined member function.\n+    virtual bool \n+    __is_function_p() const;\n+  };\n+\n+  // Type information for enumerations.\n+  class __enum_type_info : public std::type_info\n   {\n-    __unknown = 0,              /* we have no idea */\n-    __not_contained,            /* not contained within us (in some */\n-                                /* circumstances this might mean not contained */\n-                                /* publicly) */\n-    __contained_ambig,          /* contained ambiguously */\n-    \n-    __contained_virtual_mask = __base_class_type_info::__virtual_mask, /* via a virtual path */\n-    __contained_public_mask = __base_class_type_info::__public_mask,   /* via a public path */\n-    __contained_mask = 1 << __base_class_type_info::__hwm_bit,         /* contained within us */\n-    \n-    __contained_private = __contained_mask,\n-    __contained_public = __contained_mask | __contained_public_mask\n+  public:\n+    explicit \n+    __enum_type_info(const char* __n) : std::type_info(__n) { }\n+\n+    virtual \n+    ~__enum_type_info();\n   };\n \n-public:  \n-  struct __upcast_result;\n-  struct __dyncast_result;\n-\n-/* implementation defined member functions */\n-protected:\n-  virtual bool __do_upcast (const __class_type_info *__dst_type, void **__obj_ptr) const;\n-\n-protected:\n-  virtual bool __do_catch (const type_info *__thr_type, void **__thr_obj,\n-                           unsigned __outer) const;\n-\n-\n-public:\n-  /* Helper for upcast. See if DST is us, or one of our bases. */\n-  /* Return false if not found, true if found. */\n-  virtual bool __do_upcast (const __class_type_info *__dst,\n-                            const void *__obj,\n-                            __upcast_result &__restrict __result) const;\n-\n-public:\n-  /* Indicate whether SRC_PTR of type SRC_TYPE is contained publicly within\n-     OBJ_PTR. OBJ_PTR points to a base object of our type, which is the\n-     destination type. SRC2DST indicates how SRC objects might be contained\n-     within this type.  If SRC_PTR is one of our SRC_TYPE bases, indicate the\n-     virtuality. Returns not_contained for non containment or private\n-     containment. */\n-  inline __sub_kind __find_public_src (__PTRDIFF_TYPE__ __src2dst,\n-                                       const void *__obj_ptr,\n-                                       const __class_type_info *__src_type,\n-                                       const void *__src_ptr) const;\n-\n-public:\n-  /* dynamic cast helper. ACCESS_PATH gives the access from the most derived\n-     object to this base. DST_TYPE indicates the desired type we want. OBJ_PTR\n-     points to a base of our type within the complete object. SRC_TYPE\n-     indicates the static type started from and SRC_PTR points to that base\n-     within the most derived object. Fill in RESULT with what we find. Return\n-     true if we have located an ambiguous match. */\n-  virtual bool __do_dyncast (__PTRDIFF_TYPE__ __src2dst,\n-                             __sub_kind __access_path,\n-                             const __class_type_info *__dst_type,\n-                             const void *__obj_ptr,\n-                             const __class_type_info *__src_type,\n-                             const void *__src_ptr,\n-                             __dyncast_result &__result) const;\n-public:\n-  /* Helper for find_public_subobj. SRC2DST indicates how SRC_TYPE bases are\n-     inherited by the type started from -- which is not necessarily the\n-     current type. The current type will be a base of the destination type.\n-     OBJ_PTR points to the current base. */\n-  virtual __sub_kind __do_find_public_src (__PTRDIFF_TYPE__ __src2dst,\n-                                           const void *__obj_ptr,\n-                                           const __class_type_info *__src_type,\n-                                           const void *__src_ptr) const;\n-};\n-\n-/* type information for a class with a single non-virtual base */\n-class __si_class_type_info\n-  : public __class_type_info\n-{\n-/* abi defined member variables */\n-public:\n-  const __class_type_info *__base_type;\n-\n-/* abi defined member functions */\n-public:\n-  virtual ~__si_class_type_info ();\n-public:\n-  explicit __si_class_type_info (const char *__n,\n-                                 const __class_type_info *__base)\n-    : __class_type_info (__n), __base_type (__base)\n+  // Common type information for simple pointers and pointers to member.\n+  class __pbase_type_info : public std::type_info\n+  {\n+  public:\n+    unsigned int \t\t__flags; // Qualification of the target object.\n+    const std::type_info* \t__pointee; // Type of pointed to object.\n+\n+    explicit \n+    __pbase_type_info(const char* __n, int __quals, \n+\t\t      const std::type_info* __type)\n+    : std::type_info(__n), __flags(__quals), __pointee(__type)\n     { }\n+    \n+    virtual \n+    ~__pbase_type_info();\n+\n+    // Implementation defined type.\n+    enum __masks \n+      {\n+\t__const_mask = 0x1,\n+\t__volatile_mask = 0x2,\n+\t__restrict_mask = 0x4,\n+\t__incomplete_mask = 0x8,\n+\t__incomplete_class_mask = 0x10\n+      };\n+\n+  protected:\n+    __pbase_type_info(const __pbase_type_info&);\n+\n+    __pbase_type_info&\n+    operator=(const __pbase_type_info&);\n+\n+    // Implementation defined member functions.\n+    virtual bool \n+    __do_catch(const std::type_info* __thr_type, void** __thr_obj, \n+\t       unsigned int __outer) const;\n+\n+    inline virtual bool \n+    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,\n+\t\t    unsigned __outer) const;\n+  };\n \n-/* implementation defined member functions */\n-protected:\n-  virtual bool __do_dyncast (__PTRDIFF_TYPE__ __src2dst,\n-                             __sub_kind __access_path,\n-                             const __class_type_info *__dst_type,\n-                             const void *__obj_ptr,\n-                             const __class_type_info *__src_type,\n-                             const void *__src_ptr,\n-                             __dyncast_result &__result) const;\n-  virtual __sub_kind __do_find_public_src (__PTRDIFF_TYPE__ __src2dst,\n-                                           const void *__obj_ptr,\n-                                           const __class_type_info *__src_type,\n-                                           const void *__sub_ptr) const;\n-  virtual bool __do_upcast (const __class_type_info *__dst,\n-                            const void *__obj,\n-                            __upcast_result &__restrict __result) const;\n-};\n-\n-/* type information for a class with multiple and/or virtual bases */\n-class __vmi_class_type_info : public __class_type_info {\n-/* abi defined member variables */\n-public:\n-  unsigned int __flags;         /* details about the class hierarchy */\n-  unsigned int __base_count;    /* number of direct bases */\n-  __base_class_type_info __base_info[1]; /* array of bases */\n-  /* The array of bases uses the trailing array struct hack\n-     so this class is not constructable with a normal constructor. It is\n-     internally generated by the compiler. */\n-\n-/* abi defined member functions */\n-public:\n-  virtual ~__vmi_class_type_info ();\n-public:\n-  explicit __vmi_class_type_info (const char *__n,\n-                                  int ___flags)\n-    : __class_type_info (__n), __flags (___flags), __base_count (0)\n-    { }\n+  // Type information for simple pointers.\n+  class __pointer_type_info : public __pbase_type_info\n+  {\n+  public:\n+    explicit \n+    __pointer_type_info(const char* __n, int __quals, \n+\t\t\tconst std::type_info* __type)\n+    : __pbase_type_info (__n, __quals, __type) { }\n+\n+\n+    virtual \n+    ~__pointer_type_info();\n \n-/* implementation defined types */\n-public:\n-  enum __flags_masks {\n-    __non_diamond_repeat_mask = 0x1,   /* distinct instance of repeated base */\n-    __diamond_shaped_mask = 0x2,       /* diamond shaped multiple inheritance */\n-    __flags_unknown_mask = 0x10\n+  protected:\n+    // Implementation defined member functions.\n+    virtual bool \n+    __is_pointer_p() const;\n+\n+    virtual bool \n+    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj, \n+\t\t    unsigned __outer) const;\n   };\n \n-/* implementation defined member functions */\n-protected:\n-  virtual bool __do_dyncast (__PTRDIFF_TYPE__ __src2dst,\n-                             __sub_kind __access_path,\n-                             const __class_type_info *__dst_type,\n-                             const void *__obj_ptr,\n-                             const __class_type_info *__src_type,\n-                             const void *__src_ptr,\n-                             __dyncast_result &__result) const;\n-  virtual __sub_kind __do_find_public_src (__PTRDIFF_TYPE__ __src2dst,\n-                                           const void *__obj_ptr,\n-                                           const __class_type_info *__src_type,\n-                                           const void *__src_ptr) const;\n-  virtual bool __do_upcast (const __class_type_info *__dst,\n-                            const void *__obj,\n-                            __upcast_result &__restrict __result) const;\n-};\n-\n-/* dynamic cast runtime */\n-extern \"C\"\n-void *__dynamic_cast (const void *__src_ptr,    /* object started from */\n-                      const __class_type_info *__src_type, /* static type of object */\n-                      const __class_type_info *__dst_type, /* desired target type */\n-                      __PTRDIFF_TYPE__ __src2dst); /* how src and dst are related */\n-\n-    /* src2dst has the following possible values\n-       >= 0: src_type is a unique public non-virtual base of dst_type\n-             dst_ptr + src2dst == src_ptr\n-       -1: unspecified relationship\n-       -2: src_type is not a public base of dst_type\n-       -3: src_type is a multiple public non-virtual base of dst_type */\n-\n-/* array ctor/dtor routines */\n-\n-/* allocate and construct array */\n-extern \"C\"\n-void *__cxa_vec_new (__SIZE_TYPE__ __element_count,\n-                     __SIZE_TYPE__ __element_size,\n-                     __SIZE_TYPE__ __padding_size,\n-                     void (*__constructor) (void *),\n-                     void (*__destructor) (void *));\n-\n-extern \"C\"\n-void *__cxa_vec_new2 (__SIZE_TYPE__ __element_count,\n-                      __SIZE_TYPE__ __element_size,\n-                      __SIZE_TYPE__ __padding_size,\n-                      void (*__constructor) (void *),\n-                      void (*__destructor) (void *),\n-                      void *(*__alloc) (__SIZE_TYPE__),\n-                      void (*__dealloc) (void *));\n-\n-extern \"C\"\n-void *__cxa_vec_new3 (__SIZE_TYPE__ __element_count,\n-                      __SIZE_TYPE__ __element_size,\n-                      __SIZE_TYPE__ __padding_size,\n-                      void (*__constructor) (void *),\n-                      void (*__destructor) (void *),\n-                      void *(*__alloc) (__SIZE_TYPE__),\n-                      void (*__dealloc) (void *, __SIZE_TYPE__));\n-\n-/* construct array */\n-extern \"C\"\n-void __cxa_vec_ctor (void *__array_address,\n-                     __SIZE_TYPE__ __element_count,\n-                     __SIZE_TYPE__ __element_size,\n-                     void (*__constructor) (void *),\n-                     void (*__destructor) (void *));\n-\n-extern \"C\"\n-void __cxa_vec_cctor (void *dest_array,\n-\t\t      void *src_array,\n-\t\t      __SIZE_TYPE__ element_count,\n-\t\t      __SIZE_TYPE__ element_size,\n-\t\t      void (*constructor) (void *, void *),\n-\t\t      void (*destructor) (void *));\n- \n-/* destruct array */\n-extern \"C\"\n-void __cxa_vec_dtor (void *__array_address,\n-                     __SIZE_TYPE__ __element_count,\n-                     __SIZE_TYPE__ __element_size,\n-                     void (*__destructor) (void *));\n-\n-/* destruct array */\n-extern \"C\"\n-void __cxa_vec_cleanup (void *__array_address,\n-\t\t\t__SIZE_TYPE__ __element_count,\n-\t\t\t__SIZE_TYPE__ __element_size,\n-\t\t\tvoid (*__destructor) (void *));\n-\n-/* destruct and release array */\n-extern \"C\"\n-void __cxa_vec_delete (void *__array_address,\n-                       __SIZE_TYPE__ __element_size,\n-                       __SIZE_TYPE__ __padding_size,\n-                       void (*__destructor) (void *));\n-\n-extern \"C\"\n-void __cxa_vec_delete2 (void *__array_address,\n-                        __SIZE_TYPE__ __element_size,\n-                        __SIZE_TYPE__ __padding_size,\n-                        void (*__destructor) (void *),\n-                        void (*__dealloc) (void *));\n-                  \n-extern \"C\"\n-void __cxa_vec_delete3 (void *__array_address,\n-                        __SIZE_TYPE__ __element_size,\n-                        __SIZE_TYPE__ __padding_size,\n-                        void (*__destructor) (void *),\n-                        void (*__dealloc) (void *, __SIZE_TYPE__));\n+  class __class_type_info;\n \n-/* guard variables */\n+  // Type information for a pointer to member variable.\n+  class __pointer_to_member_type_info : public __pbase_type_info\n+  {\n+  public:\n+    __class_type_info* __context;   // Class of the member.\n \n-/* The ABI requires a 64-bit type.  */\n-__extension__ typedef int __guard __attribute__((mode (__DI__)));\n+    explicit \n+    __pointer_to_member_type_info(const char* __n, int __quals,\n+\t\t\t\t  const std::type_info* __type, \n+\t\t\t\t  __class_type_info* __klass)\n+    : __pbase_type_info(__n, __quals, __type), __context(__klass) { }\n \n-extern \"C\"\n-int __cxa_guard_acquire (__guard *);\n+    virtual \n+    ~__pointer_to_member_type_info();\n \n-extern \"C\"\n-void __cxa_guard_release (__guard *);\n+  protected:\n+    __pointer_to_member_type_info(const __pointer_to_member_type_info&);\n \n-extern \"C\"\n-void __cxa_guard_abort (__guard *);\n+    __pointer_to_member_type_info&\n+    operator=(const __pointer_to_member_type_info&);\n \n-/* pure virtual functions */\n+    // Implementation defined member function.\n+    virtual bool \n+    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,\n+\t\t    unsigned __outer) const;\n+  };\n \n-extern \"C\" void\n-__cxa_pure_virtual (void);\n+  // Helper class for __vmi_class_type.\n+  class __base_class_type_info\n+  {\n+  public:\n+    const __class_type_info* \t__base_type;  // Base class type.\n+    long \t\t\t__offset_flags;  // Offset and info.\n+\n+    enum __offset_flags_masks \n+      {\n+\t__virtual_mask = 0x1,\n+\t__public_mask = 0x2,\n+\t__hwm_bit = 2,\n+\t__offset_shift = 8          // Bits to shift offset.\n+      };\n+  \n+    // Implementation defined member functions.\n+    bool \n+    __is_virtual_p() const\n+    { return __offset_flags & __virtual_mask; }\n+\n+    bool \n+    __is_public_p() const\n+    { return __offset_flags & __public_mask; }\n+\n+    ptrdiff_t \n+    __offset() const\n+    { \n+      // This shift, being of a signed type, is implementation\n+      // defined. GCC implements such shifts as arithmetic, which is\n+      // what we want.\n+      return static_cast<ptrdiff_t>(__offset_flags) >> __offset_shift;\n+    }\n+  };\n+\n+  // Type information for a class.\n+  class __class_type_info : public std::type_info\n+  {\n+  public:\n+    explicit \n+    __class_type_info (const char *__n) : type_info(__n) { }\n+\n+    virtual \n+    ~__class_type_info ();\n+\n+    // Implementation defined types.\n+    // The type sub_kind tells us about how a base object is contained\n+    // within a derived object. We often do this lazily, hence the\n+    // UNKNOWN value. At other times we may use NOT_CONTAINED to mean\n+    // not publicly contained.\n+    enum __sub_kind\n+      {\n+\t// We have no idea.\n+\t__unknown = 0, \n+\n+\t// Not contained within us (in some circumstances this might\n+\t// mean not contained publicly)\n+\t__not_contained, \n+\n+\t// Contained ambiguously.\n+\t__contained_ambig, \n+    \n+\t// Via a virtual path.\n+\t__contained_virtual_mask = __base_class_type_info::__virtual_mask, \n \n-/* exception handling */\n+\t// Via a public path.\n+\t__contained_public_mask = __base_class_type_info::__public_mask,   \n \n-extern \"C\" void\n-__cxa_bad_cast ();\n+\t// Contained within us.\n+\t__contained_mask = 1 << __base_class_type_info::__hwm_bit,\n+    \n+\t__contained_private = __contained_mask,\n+\t__contained_public = __contained_mask | __contained_public_mask\n+      };\n+\n+    struct __upcast_result;\n+    struct __dyncast_result;\n+\n+  protected:\n+    // Implementation defined member functions.\n+    virtual bool \n+    __do_upcast(const __class_type_info* __dst_type, void**__obj_ptr) const;\n+\n+    virtual bool \n+    __do_catch(const type_info* __thr_type, void** __thr_obj, \n+\t       unsigned __outer) const;\n+\n+  public:\n+    // Helper for upcast. See if DST is us, or one of our bases. \n+    // Return false if not found, true if found. \n+    virtual bool \n+    __do_upcast(const __class_type_info* __dst, const void* __obj,\n+\t\t__upcast_result& __restrict __result) const;\n+\n+    // Indicate whether SRC_PTR of type SRC_TYPE is contained publicly\n+    // within OBJ_PTR. OBJ_PTR points to a base object of our type,\n+    // which is the destination type. SRC2DST indicates how SRC\n+    // objects might be contained within this type.  If SRC_PTR is one\n+    // of our SRC_TYPE bases, indicate the virtuality. Returns\n+    // not_contained for non containment or private containment.\n+    inline __sub_kind \n+    __find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,\n+\t\t      const __class_type_info* __src_type, \n+\t\t      const void* __src_ptr) const;\n+\n+    // Helper for dynamic cast. ACCESS_PATH gives the access from the\n+    // most derived object to this base. DST_TYPE indicates the\n+    // desired type we want. OBJ_PTR points to a base of our type\n+    // within the complete object. SRC_TYPE indicates the static type\n+    // started from and SRC_PTR points to that base within the most\n+    // derived object. Fill in RESULT with what we find. Return true\n+    // if we have located an ambiguous match.\n+    virtual bool \n+    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,\n+\t\t const __class_type_info* __dst_type, const void* __obj_ptr, \n+\t\t const __class_type_info* __src_type, const void* __src_ptr, \n+\t\t __dyncast_result& __result) const;\n+    \n+    // Helper for find_public_subobj. SRC2DST indicates how SRC_TYPE\n+    // bases are inherited by the type started from -- which is not\n+    // necessarily the current type. The current type will be a base\n+    // of the destination type.  OBJ_PTR points to the current base.\n+    virtual __sub_kind \n+    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,\n+\t\t\t const __class_type_info* __src_type,\n+\t\t\t const void* __src_ptr) const;\n+  };\n+\n+  // Type information for a class with a single non-virtual base.\n+  class __si_class_type_info : public __class_type_info\n+  {\n+  public:\n+    const __class_type_info* __base_type;\n \n-extern \"C\" void\n-__cxa_bad_typeid ();\n+    explicit \n+    __si_class_type_info(const char *__n, const __class_type_info *__base)\n+    : __class_type_info(__n), __base_type(__base) { }\n \n-/* DSO destruction */\n+    virtual \n+    ~__si_class_type_info();\n \n-extern \"C\" int\n-__cxa_atexit (void (*)(void *), void *, void *);\n+  protected:\n+    __si_class_type_info(const __si_class_type_info&);\n \n-extern \"C\" int\n-__cxa_finalize (void *);\n+    __si_class_type_info&\n+    operator=(const __si_class_type_info&);\n \n-/* demangling routines */\n+    // Implementation defined member functions.\n+    virtual bool \n+    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,\n+\t\t const __class_type_info* __dst_type, const void* __obj_ptr,\n+\t\t const __class_type_info* __src_type, const void* __src_ptr,\n+\t\t __dyncast_result& __result) const;\n \n-extern \"C\" \n-char *__cxa_demangle (const char *__mangled_name,\n-\t\t      char *__output_buffer,\n-\t\t      __SIZE_TYPE__ *__length,\n-\t\t      int *__status);\n+    virtual __sub_kind \n+    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,\n+\t\t\t const __class_type_info* __src_type,\n+\t\t\t const void* __sub_ptr) const;\n \n-// Returns the type_info for the currently handled exception [15.3/8], or\n-// null if there is none.\n-extern \"C\"\n-std::type_info *__cxa_current_exception_type ();\n+    virtual bool \n+    __do_upcast(const __class_type_info*__dst, const void*__obj,\n+\t\t__upcast_result& __restrict __result) const;\n+  };\n \n-} /* namespace __cxxabiv1 */\n+  // Type information for a class with multiple and/or virtual bases.\n+  class __vmi_class_type_info : public __class_type_info \n+  {\n+  public:\n+    unsigned int \t\t__flags;  // Details about the class hierarchy.\n+    unsigned int \t\t__base_count;  // Dumber of direct bases.\n+\n+    // The array of bases uses the trailing array struct hack so this\n+    // class is not constructable with a normal constructor. It is\n+    // internally generated by the compiler.\n+    __base_class_type_info \t__base_info[1];  // Array of bases.\n+\n+    explicit \n+    __vmi_class_type_info(const char* __n, int ___flags)\n+    : __class_type_info(__n), __flags(___flags), __base_count(0) { }\n+\n+    virtual \n+    ~__vmi_class_type_info();\n+\n+    // Implementation defined types.\n+    enum __flags_masks \n+      {\n+\t__non_diamond_repeat_mask = 0x1, // Distinct instance of repeated base.\n+\t__diamond_shaped_mask = 0x2, // Diamond shaped multiple inheritance.\n+\t__flags_unknown_mask = 0x10\n+      };\n+\n+  protected:\n+    // Implementation defined member functions.\n+    virtual bool \n+    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,\n+\t\t const __class_type_info* __dst_type, const void* __obj_ptr,\n+\t\t const __class_type_info* __src_type, const void* __src_ptr,\n+\t\t __dyncast_result& __result) const;\n+\n+    virtual __sub_kind \n+    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr, \n+\t\t\t const __class_type_info* __src_type,\n+\t\t\t const void* __src_ptr) const;\n+    \n+    virtual bool \n+    __do_upcast(const __class_type_info* __dst, const void* __obj,\n+\t\t__upcast_result& __restrict __result) const;\n+  };\n \n-/* User programs should use the alias `abi'. */\n+  // Dynamic cast runtime.\n+  // src2dst has the following possible values\n+  //  >-1: src_type is a unique public non-virtual base of dst_type\n+  //       dst_ptr + src2dst == src_ptr\n+  //   -1: unspecified relationship\n+  //   -2: src_type is not a public base of dst_type\n+  //   -3: src_type is a multiple public non-virtual base of dst_type\n+  extern \"C\" void*\n+  __dynamic_cast(const void* __src_ptr, // Starting object.\n+\t\t const __class_type_info* __src_type, // Static type of object.\n+\t\t const __class_type_info* __dst_type, // Desired target type.\n+\t\t ptrdiff_t __src2dst); // How src and dst are related.\n+\n+\n+  // Returns the type_info for the currently handled exception [15.3/8], or\n+  // null if there is none.\n+  extern \"C\" std::type_info*\n+  __cxa_current_exception_type();\n+} // namespace __cxxabiv1\n+\n+// User programs should use the alias `abi'. \n namespace abi = __cxxabiv1;\n \n-#else\n-#endif /* __cplusplus */\n-\n+#endif // __cplusplus\n \n-#endif /* __CXXABI_H */\n+#endif // __CXXABI_H "}, {"sha": "ed6500697f0e6c2a27e0f1128a8643bea8b79b66", "filename": "libstdc++-v3/libsupc++/tinfo.cc", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ceb03971fb7f878b8a610fa97b07a4de510057/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ceb03971fb7f878b8a610fa97b07a4de510057/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo.cc?ref=52ceb03971fb7f878b8a610fa97b07a4de510057", "patch": "@@ -200,10 +200,28 @@ struct __class_type_info::__upcast_result\n                               // if in vbase the __class_type_info of vbase\n                               // if a non-virtual base then 1\n                               // else NULL\n-  public:\n   __upcast_result (int d)\n     :dst_ptr (NULL), part2dst (__unknown), src_details (d), base_type (NULL)\n     {}\n+\n+  explicit\n+  __upcast_result(const __upcast_result& r)\n+  : dst_ptr(r.dst_ptr), part2dst(r.part2dst), src_details(r.src_details), \n+    base_type(r.base_type) \n+  { }\n+\n+  __upcast_result&\n+  operator=(const __upcast_result& r)\n+  {\n+    if (&r != this)\n+      {\n+\tdst_ptr = r.dst_ptr;\n+\tpart2dst = r.part2dst;\n+\tsrc_details = r.src_details;\n+\tbase_type = r.base_type;\n+      }\n+    return *this;\n+  }\n };\n \n // __dyncast_result is used to hold information during traversal of a class\n@@ -216,12 +234,17 @@ struct __class_type_info::__dyncast_result\n   __sub_kind dst2src;         // path from target to sub object\n   int whole_details;          // details of the whole class hierarchy\n   \n-  public:\n   __dyncast_result (int details_ = __vmi_class_type_info::__flags_unknown_mask)\n     :dst_ptr (NULL), whole2dst (__unknown),\n      whole2src (__unknown), dst2src (__unknown),\n      whole_details (details_)\n     {}\n+\n+protected:\n+  __dyncast_result(const __dyncast_result&);\n+  \n+  __dyncast_result&\n+  operator=(const __dyncast_result&);\n };\n \n bool __class_type_info::"}, {"sha": "86d41d9ea98b4a49dc868b6898d1cfc86b7a9043", "filename": "libstdc++-v3/libsupc++/vec.cc", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ceb03971fb7f878b8a610fa97b07a4de510057/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fvec.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ceb03971fb7f878b8a610fa97b07a4de510057/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fvec.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fvec.cc?ref=52ceb03971fb7f878b8a610fa97b07a4de510057", "patch": "@@ -1,6 +1,6 @@\n // New abi Support -*- C++ -*-\n \n-// Copyright (C) 2000, 2001, 2003 Free Software Foundation, Inc.\n+// Copyright (C) 2000, 2001, 2003, 2004 Free Software Foundation, Inc.\n //  \n // This file is part of GCC.\n //\n@@ -42,13 +42,19 @@ namespace __cxxabiv1\n   {\n     struct uncatch_exception \n     {\n-      uncatch_exception ();\n+      uncatch_exception();\n       ~uncatch_exception () { __cxa_begin_catch (&p->unwindHeader); }\n       \n-      __cxa_exception *p;\n+      __cxa_exception* p;\n+\n+    private:\n+      uncatch_exception&\n+      operator=(const uncatch_exception&);\n+\n+      uncatch_exception(const uncatch_exception&);\n     };\n \n-    uncatch_exception::uncatch_exception ()\n+    uncatch_exception::uncatch_exception() : p(0)\n     {\n       __cxa_eh_globals *globals = __cxa_get_globals_fast ();\n "}]}