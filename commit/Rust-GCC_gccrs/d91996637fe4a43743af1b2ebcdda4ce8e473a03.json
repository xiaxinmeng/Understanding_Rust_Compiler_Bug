{"sha": "d91996637fe4a43743af1b2ebcdda4ce8e473a03", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDkxOTk2NjM3ZmU0YTQzNzQzYWYxYjJlYmNkZGE0Y2U4ZTQ3M2EwMw==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2003-03-01T15:05:46Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2003-03-01T15:05:46Z"}, "message": "ObjectInputStream.java: Reindent.\n\n       * java/io/ObjectInputStream.java: Reindent.\n       * java/io/ObjectOutputStream.java: Likewise.\n\nFrom-SVN: r63614", "tree": {"sha": "e5decafcdd4c08aee2930324e407189cd7b6a830", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5decafcdd4c08aee2930324e407189cd7b6a830"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d91996637fe4a43743af1b2ebcdda4ce8e473a03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d91996637fe4a43743af1b2ebcdda4ce8e473a03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d91996637fe4a43743af1b2ebcdda4ce8e473a03", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d91996637fe4a43743af1b2ebcdda4ce8e473a03/comments", "author": null, "committer": null, "parents": [{"sha": "5793b27668ae1b63e6518f84eab151ad66890eec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5793b27668ae1b63e6518f84eab151ad66890eec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5793b27668ae1b63e6518f84eab151ad66890eec"}], "stats": {"total": 1433, "additions": 709, "deletions": 724}, "files": [{"sha": "aa79a0692dd2d694eae557d33e6800c71ecd25eb", "filename": "libjava/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91996637fe4a43743af1b2ebcdda4ce8e473a03/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91996637fe4a43743af1b2ebcdda4ce8e473a03/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=d91996637fe4a43743af1b2ebcdda4ce8e473a03", "patch": "@@ -1,7 +1,12 @@\n+2003-03-01  Mark Wielaard  <mark@klomp.org>\n+\n+\t* java/io/ObjectInputStream.java: Reindent.\n+\t* java/io/ObjectOutputStream.java: Likewise.\n+\n 2003-02-28  Hans Boehm  <Hans.Boehm@hp.com>\n \n \t* java/lang/reflect/natMethod.cc (_Jv_CallAnyMethodA): Allocate a full\n-        jvalue for each argument. Simplify.\n+\tjvalue for each argument. Simplify.\n \t* testsuite/libjava.jni/calls.c (docall),\n \ttestsuite/libjava.jni/calls.java (longpb_f): check for argument\n \tmisalignment."}, {"sha": "38c790a0ca15839dd5194265d9e26e082cb0c891", "filename": "libjava/java/io/ObjectInputStream.java", "status": "modified", "additions": 412, "deletions": 433, "changes": 845, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91996637fe4a43743af1b2ebcdda4ce8e473a03/libjava%2Fjava%2Fio%2FObjectInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91996637fe4a43743af1b2ebcdda4ce8e473a03/libjava%2Fjava%2Fio%2FObjectInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectInputStream.java?ref=d91996637fe4a43743af1b2ebcdda4ce8e473a03", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -146,11 +146,11 @@ public final Object readObject () throws ClassNotFoundException, IOException\n \t      is_consumed = true;\n \t      break;\n \t    }\n-\t    \n+\n \t  case TC_BLOCKDATA:\n \t  case TC_BLOCKDATALONG:\n \t    {\n-\t      if (marker == TC_BLOCKDATALONG) \n+\t      if (marker == TC_BLOCKDATALONG)\n \t\tdumpElementln (\"BLOCKDATALONG\");\n \t      else\n \t\tdumpElementln (\"BLOCKDATA\");\n@@ -164,7 +164,7 @@ public final Object readObject () throws ClassNotFoundException, IOException\n \t      ret_val = null;\n \t      break;\n \t    }\n-\t    \n+\n \t  case TC_REFERENCE:\n \t    {\n \t      dumpElement (\"REFERENCE \");\n@@ -174,7 +174,7 @@ public final Object readObject () throws ClassNotFoundException, IOException\n \t\t\t this.objectLookupTable.get (oid)).object;\n \t      break;\n \t    }\n-\t    \n+\n \t  case TC_CLASS:\n \t    {\n \t      dumpElementln (\"CLASS\");\n@@ -229,7 +229,6 @@ public final Object readObject () throws ClassNotFoundException, IOException\n \t      short field_count = this.realInputStream.readShort ();\n \t      dumpElementln (Short.toString(field_count));\n \t      ObjectStreamField[] fields = new ObjectStreamField[field_count];\n-\t      \n \t      ObjectStreamClass osc = new ObjectStreamClass (name, uid,\n \t\t\t\t\t\t\t     flags, fields);\n \t      assignNewHandle (osc);\n@@ -272,7 +271,7 @@ public final Object readObject () throws ClassNotFoundException, IOException\n \t      ret_val = osc;\n \t      break;\n \t    }\n-\t    \n+\n \t  case TC_STRING:\n \t  case TC_LONGSTRING:\n \t    {\n@@ -357,9 +356,6 @@ public final Object readObject () throws ClassNotFoundException, IOException\n \t\t     || Modifier.isAbstract (first_nonserial.getModifiers ()))\n \t\tfirst_nonserial = first_nonserial.getSuperclass ();\n \t      \n-\t      //\tDEBUGln (\"Using \" + first_nonserial\n-\t      //\t\t + \" as starting point for constructing \" + clazz);\n-\t      \n \t      Object obj = null;\n \t      obj = newObject (clazz, first_nonserial);\n \t      \n@@ -372,8 +368,6 @@ public final Object readObject () throws ClassNotFoundException, IOException\n \t      ObjectStreamClass[] hierarchy =\n \t\tObjectStreamClass.getObjectStreamClasses (clazz);\n \t      \n-\t      //\tDEBUGln (\"Got class hierarchy of depth \" + hierarchy.length);\n-\t      \n \t      boolean has_read;\n \t      for (int i=0; i < hierarchy.length; i++)\n \t\t{\n@@ -428,13 +422,13 @@ public final Object readObject () throws ClassNotFoundException, IOException\n \t      ret_val = processResolution (obj, handle);\n \t      break;\n \t    }\n-\t    \n+\n \t  case TC_RESET:\n \t    dumpElementln (\"RESET\");\n \t    clearHandles ();\n \t    ret_val = readObject ();\n \t    break;\n-\t    \n+\n \t  case TC_EXCEPTION:\n \t    {\n \t      dumpElement (\"EXCEPTION=\");\n@@ -443,10 +437,9 @@ public final Object readObject () throws ClassNotFoundException, IOException\n \t      clearHandles ();\n \t      throw new WriteAbortedException (\"Exception thrown during writing of stream\", e);\n \t    }\n-\t      \n+\n \t  default:\n \t    throw new IOException (\"Unknown marker on stream: \" + marker);\n-\n \t  }\n       }\n     finally\n@@ -464,7 +457,6 @@ public final Object readObject () throws ClassNotFoundException, IOException\n     \n     return ret_val;\n   }\n-\t\n \n   /**\n      Reads the current objects non-transient, non-static fields from\n@@ -665,51 +657,51 @@ protected void readStreamHeader ()\n   public int read () throws IOException\n   {\n     if (this.readDataFromBlock)\n-    {\n-      if (this.blockDataPosition >= this.blockDataBytes)\n-\treadNextBlock ();\n-      return (this.blockData[this.blockDataPosition++] & 0xff);\n-    }\n+      {\n+\tif (this.blockDataPosition >= this.blockDataBytes)\n+\t  readNextBlock ();\n+\treturn (this.blockData[this.blockDataPosition++] & 0xff);\n+      }\n     else\n       return this.realInputStream.read ();\n   }\n \n   public int read (byte[] data, int offset, int length) throws IOException\n   {\n     if (this.readDataFromBlock)\n-    {\n-      if (this.blockDataPosition + length > this.blockDataBytes)\n-\t{\n-\t  int remain = this.blockDataBytes - this.blockDataPosition;\n-\t  if (remain != 0)\n-\t    {\n-\t      System.arraycopy (this.blockData, this.blockDataPosition,\n-\t\t\t\tdata, offset, remain);\n-\t      offset += remain;\n-\t      length -= remain;\n-\t    }\n-\t  readNextBlock ();\n-\t}\n+      {\n+\tif (this.blockDataPosition + length > this.blockDataBytes)\n+\t  {\n+\t    int remain = this.blockDataBytes - this.blockDataPosition;\n+\t    if (remain != 0)\n+\t      {\n+\t\tSystem.arraycopy (this.blockData, this.blockDataPosition,\n+\t\t\t\t  data, offset, remain);\n+\t\toffset += remain;\n+\t\tlength -= remain;\n+\t      }\n+\t    readNextBlock ();\n+\t  }\n \n-      System.arraycopy (this.blockData, this.blockDataPosition,\n-\t\t\tdata, offset, length);\n-      blockDataPosition += length;\t\n+\tSystem.arraycopy (this.blockData, this.blockDataPosition,\n+\t\t\t  data, offset, length);\n+\tthis.blockDataPosition += length;\n \n-      return length;\n-    }\n+\treturn length;\n+      }\n     else\n       return this.realInputStream.read (data, offset, length);\n   }\n \n   public int available () throws IOException\n   {\n     if (this.readDataFromBlock)\n-    {\n-      if (this.blockDataPosition >= this.blockDataBytes)\n-\treadNextBlock ();\n+      {\n+\tif (this.blockDataPosition >= this.blockDataBytes)\n+\t  readNextBlock ();\n \n-      return this.blockDataBytes - this.blockDataPosition;\n-    }\n+\treturn this.blockDataBytes - this.blockDataPosition;\n+      }\n     else\n       return this.realInputStream.available ();\n   }\n@@ -864,174 +856,174 @@ public GetField readFields ()\n     setBlockDataMode (oldmode);\n \n     return new GetField ()\n-    {\n-      public ObjectStreamClass getObjectStreamClass ()\n       {\n-\treturn clazz;\n-      }\n+\tpublic ObjectStreamClass getObjectStreamClass ()\n+\t{\n+\t  return clazz;\n+\t}\n \n-      public boolean defaulted (String name)\n-\tthrows IOException, IllegalArgumentException\n-      {\n-\treturn clazz.getField (name) == null;\n-      }\n+\tpublic boolean defaulted (String name)\n+\t  throws IOException, IllegalArgumentException\n+\t{\n+\t  return clazz.getField (name) == null;\n+\t}\n \n-      public boolean get (String name, boolean defvalue)\n-\tthrows IOException, IllegalArgumentException\n-      {\n-\tObjectStreamField field = getField (name, Boolean.TYPE);\n+\tpublic boolean get (String name, boolean defvalue)\n+\t  throws IOException, IllegalArgumentException\n+\t{\n+\t  ObjectStreamField field = getField (name, Boolean.TYPE);\n \n-\tif (field == null)\n-\t  return defvalue;\n+\t  if (field == null)\n+\t    return defvalue;\n \n-\treturn prim_field_data[field.getOffset ()] == 0 ? false : true;\n-      }\n+\t  return prim_field_data[field.getOffset ()] == 0 ? false : true;\n+\t}\n \n-      public char get (String name, char defvalue)\n-\tthrows IOException, IllegalArgumentException\n-      {\n-\tObjectStreamField field = getField (name, Character.TYPE);\n+\tpublic char get (String name, char defvalue)\n+\t  throws IOException, IllegalArgumentException\n+\t{\n+\t  ObjectStreamField field = getField (name, Character.TYPE);\n \n-\tif (field == null)\n-\t  return defvalue;\n+\t  if (field == null)\n+\t    return defvalue;\n \n-\tint off = field.getOffset ();\n+\t  int off = field.getOffset ();\n \n-\treturn (char)(((prim_field_data[off++] & 0xFF) << 8)\n-\t\t      | (prim_field_data[off] & 0xFF));\n-      }\n+\t  return (char)(((prim_field_data[off++] & 0xFF) << 8)\n+\t\t\t| (prim_field_data[off] & 0xFF));\n+\t}\n \n-      public byte get (String name, byte defvalue)\n-\tthrows IOException, IllegalArgumentException\n-      {\n-\tObjectStreamField field = getField (name, Byte.TYPE);\n+\tpublic byte get (String name, byte defvalue)\n+\t  throws IOException, IllegalArgumentException\n+\t{\n+\t  ObjectStreamField field = getField (name, Byte.TYPE);\n \n-\tif (field == null)\n-\t  return defvalue;\n+\t  if (field == null)\n+\t    return defvalue;\n \n-\treturn prim_field_data[field.getOffset ()];\n-      }\n+\t  return prim_field_data[field.getOffset ()];\n+\t}\n \n-      public short get (String name, short defvalue)\n-\tthrows IOException, IllegalArgumentException\n-      {\n-\tObjectStreamField field = getField (name, Short.TYPE);\n+\tpublic short get (String name, short defvalue)\n+\t  throws IOException, IllegalArgumentException\n+\t{\n+\t  ObjectStreamField field = getField (name, Short.TYPE);\n \n-\tif (field == null)\n-\t  return defvalue;\n+\t  if (field == null)\n+\t    return defvalue;\n \n-\tint off = field.getOffset ();\n+\t  int off = field.getOffset ();\n \n-\treturn (short)(((prim_field_data[off++] & 0xFF) << 8)\n-\t\t       | (prim_field_data[off] & 0xFF));\n-      }\n+\t  return (short)(((prim_field_data[off++] & 0xFF) << 8)\n+\t\t\t | (prim_field_data[off] & 0xFF));\n+\t}\n \n-      public int get (String name, int defvalue)\n-\tthrows IOException, IllegalArgumentException\n-      {\n-\tObjectStreamField field = getField (name, Integer.TYPE);\n+\tpublic int get (String name, int defvalue)\n+\t  throws IOException, IllegalArgumentException\n+\t{\n+\t  ObjectStreamField field = getField (name, Integer.TYPE);\n \n-\tif (field == null)\n-\t  return defvalue;\n+\t  if (field == null)\n+\t    return defvalue;\n \n-\tint off = field.getOffset ();\n+\t  int off = field.getOffset ();\n \n-\treturn ((prim_field_data[off++] & 0xFF) << 24)\n-\t  | ((prim_field_data[off++] & 0xFF) << 16)\n-\t  | ((prim_field_data[off++] & 0xFF) << 8)\n-\t  | (prim_field_data[off] & 0xFF);\n-      }\n+\t  return ((prim_field_data[off++] & 0xFF) << 24)\n+\t    | ((prim_field_data[off++] & 0xFF) << 16)\n+\t    | ((prim_field_data[off++] & 0xFF) << 8)\n+\t    | (prim_field_data[off] & 0xFF);\n+\t}\n \n-      public long get (String name, long defvalue)\n-\tthrows IOException, IllegalArgumentException\n-      {\n-\tObjectStreamField field = getField (name, Long.TYPE);\n+\tpublic long get (String name, long defvalue)\n+\t  throws IOException, IllegalArgumentException\n+\t{\n+\t  ObjectStreamField field = getField (name, Long.TYPE);\n+\n+\t  if (field == null)\n+\t    return defvalue;\n \n-\tif (field == null)\n-\t  return defvalue;\n+\t  int off = field.getOffset ();\n \n-\tint off = field.getOffset ();\n+\t  return (long)(((prim_field_data[off++] & 0xFF) << 56)\n+\t\t\t| ((prim_field_data[off++] & 0xFF) << 48)\n+\t\t\t| ((prim_field_data[off++] & 0xFF) << 40)\n+\t\t\t| ((prim_field_data[off++] & 0xFF) << 32)\n+\t\t\t| ((prim_field_data[off++] & 0xFF) << 24)\n+\t\t\t| ((prim_field_data[off++] & 0xFF) << 16)\n+\t\t\t| ((prim_field_data[off++] & 0xFF) << 8)\n+\t\t\t| (prim_field_data[off] & 0xFF));\n+\t}\n+\n+\tpublic float get (String name, float defvalue)\n+\t  throws IOException, IllegalArgumentException\n+\t{\n+\t  ObjectStreamField field = getField (name, Float.TYPE);\n+\n+\t  if (field == null)\n+\t    return defvalue;\n+\n+\t  int off = field.getOffset ();\n+\n+\t  return Float.intBitsToFloat (((prim_field_data[off++] & 0xFF) << 24)\n+\t\t\t\t       | ((prim_field_data[off++] & 0xFF) << 16)\n+\t\t\t\t       | ((prim_field_data[off++] & 0xFF) << 8)\n+\t\t\t\t       | (prim_field_data[off] & 0xFF));\n+\t}\n+\n+\tpublic double get (String name, double defvalue)\n+\t  throws IOException, IllegalArgumentException\n+\t{\n+\t  ObjectStreamField field = getField (name, Double.TYPE);\n+\n+\t  if (field == null)\n+\t    return defvalue;\n \n-\treturn (long)(((prim_field_data[off++] & 0xFF) << 56)\n+\t  int off = field.getOffset ();\n+\n+\t  return Double.longBitsToDouble\n+\t    ( (long) (((prim_field_data[off++] & 0xFF) << 56)\n \t\t      | ((prim_field_data[off++] & 0xFF) << 48)\n \t\t      | ((prim_field_data[off++] & 0xFF) << 40)\n \t\t      | ((prim_field_data[off++] & 0xFF) << 32)\n \t\t      | ((prim_field_data[off++] & 0xFF) << 24)\n \t\t      | ((prim_field_data[off++] & 0xFF) << 16)\n \t\t      | ((prim_field_data[off++] & 0xFF) << 8)\n-\t\t      | (prim_field_data[off] & 0xFF));\n-      }\n-\n-      public float get (String name, float defvalue)\n-\tthrows IOException, IllegalArgumentException\n-      {\n-\tObjectStreamField field = getField (name, Float.TYPE);\n-\n-\tif (field == null)\n-\t  return defvalue;\n-\n-\tint off = field.getOffset ();\n-\n-\treturn Float.intBitsToFloat (((prim_field_data[off++] & 0xFF) << 24)\n-\t\t\t\t    | ((prim_field_data[off++] & 0xFF) << 16)\n-\t\t\t\t    | ((prim_field_data[off++] & 0xFF) << 8)\n-\t\t\t\t    | (prim_field_data[off] & 0xFF));\n-      }\n-\n-      public double get (String name, double defvalue)\n-\tthrows IOException, IllegalArgumentException\n-      {\n-\tObjectStreamField field = getField (name, Double.TYPE);\n-\n-\tif (field == null)\n-\t  return defvalue;\n-\n-\tint off = field.getOffset ();\n-\n-\treturn Double.longBitsToDouble (\n-\t  (long)(((prim_field_data[off++] & 0xFF) << 56)\n-\t\t | ((prim_field_data[off++] & 0xFF) << 48)\n-\t\t | ((prim_field_data[off++] & 0xFF) << 40)\n-\t\t | ((prim_field_data[off++] & 0xFF) << 32)\n-\t\t | ((prim_field_data[off++] & 0xFF) << 24)\n-\t\t | ((prim_field_data[off++] & 0xFF) << 16)\n-\t\t | ((prim_field_data[off++] & 0xFF) << 8)\n-\t\t | (prim_field_data[off] & 0xFF)));\n-      }\n+\t\t      | (prim_field_data[off] & 0xFF)));\n+\t}\n \n-      public Object get (String name, Object defvalue)\n-\tthrows IOException, IllegalArgumentException\n-      {\n-\tObjectStreamField field =\n-\t  getField (name, defvalue == null ? null : defvalue.getClass ());\n+\tpublic Object get (String name, Object defvalue)\n+\t  throws IOException, IllegalArgumentException\n+\t{\n+\t  ObjectStreamField field =\n+\t    getField (name, defvalue == null ? null : defvalue.getClass ());\n \n-\tif (field == null)\n-\t  return defvalue;\n+\t  if (field == null)\n+\t    return defvalue;\n \n-\treturn objs[field.getOffset ()];\n-      }\n+\t  return objs[field.getOffset ()];\n+\t}\n \n-      private ObjectStreamField getField (String name, Class type)\n-\tthrows IllegalArgumentException\n-      {\n-\tObjectStreamField field = clazz.getField (name);\n+\tprivate ObjectStreamField getField (String name, Class type)\n+\t  throws IllegalArgumentException\n+\t{\n+\t  ObjectStreamField field = clazz.getField (name);\n \n-\tif (field == null)\n-\t  return null;\n+\t  if (field == null)\n+\t    return null;\n \n-\tClass field_type = field.getType ();\n+\t  Class field_type = field.getType ();\n \n-\tif (type == field_type ||\n-\t    (type == null && ! field_type.isPrimitive ()))\n-\t  return field;\n+\t  if (type == field_type ||\n+\t      (type == null && ! field_type.isPrimitive ()))\n+\t    return field;\n \n-\tthrow new IllegalArgumentException (\"Field requested is of type \"\n-\t\t\t\t\t    + field_type.getName ()\n-\t\t\t\t\t    + \", but requested type was \"\n-\t\t\t\t\t    + (type == null ?\n-\t\t\t\t\t       \"Object\" : type.getName ()));\n-      }\n-    };\n+\t  throw new IllegalArgumentException (\"Field requested is of type \"\n+\t\t\t\t\t      + field_type.getName ()\n+\t\t\t\t\t      + \", but requested type was \"\n+\t\t\t\t\t      + (type == null ?\n+\t\t\t\t\t\t \"Object\" : type.getName ()));\n+\t}\n+      };\n \n   }\n \n@@ -1077,15 +1069,7 @@ protected Object readObjectOverride ()\n   private int assignNewHandle (Object obj)\n   {\n     this.objectLookupTable.put (new Integer (this.nextOID),\n-\t\t\t     new ObjectIdentityWrapper (obj));\n-\n-//    try\n-//    {\n-//      DEBUG (\"Assigning handle \" + this.nextOID);\n-//      DEBUGln (\" to \" + obj);\n-//    }\n-//    catch (Throwable t) {}\n-\n+\t\t\t\tnew ObjectIdentityWrapper (obj));\n     return this.nextOID++;\n   }\n \n@@ -1097,22 +1081,22 @@ private Object processResolution (Object obj, int handle)\n       {\n         Method m = null; \n \ttry\n-\t{\n-\t  Class classArgs[] = {};\n-\t  m = obj.getClass ().getDeclaredMethod (\"readResolve\", classArgs);\n-\t  // m can't be null by definition since an exception would\n-\t  // have been thrown so a check for null is not needed.\n-\t  obj = m.invoke (obj, new Object[] {});\t\n-\t}\n+\t  {\n+\t    Class classArgs[] = {};\n+\t    m = obj.getClass ().getDeclaredMethod (\"readResolve\", classArgs);\n+\t    // m can't be null by definition since an exception would\n+\t    // have been thrown so a check for null is not needed.\n+\t    obj = m.invoke (obj, new Object[] {});\t\n+\t  }\n \tcatch (NoSuchMethodException ignore)\n-\t{\n-\t}\n+\t  {\n+\t  }\n \tcatch (IllegalAccessException ignore)\n-\t{\n-\t}\n+\t  {\n+\t  }\n \tcatch (InvocationTargetException ignore)\n-\t{\n-\t}\n+\t  {\n+\t  }\n       }\n \n     if (this.resolveEnabled)\n@@ -1134,29 +1118,28 @@ private void clearHandles ()\n \n   private void readNextBlock () throws IOException\n   {\n-//  DEBUGln (\"In readNextBlock \");\n     readNextBlock (this.realInputStream.readByte ());\n   }\n \n \n   private void readNextBlock (byte marker) throws IOException\n   {\n     if (marker == TC_BLOCKDATA)\n-    {\n-      dumpElement (\"BLOCK DATA SIZE=\");\n-      this.blockDataBytes = this.realInputStream.readUnsignedByte ();\n-      dumpElementln (Integer.toString(this.blockDataBytes));\n-    }\n+      {\n+\tdumpElement (\"BLOCK DATA SIZE=\");\n+\tthis.blockDataBytes = this.realInputStream.readUnsignedByte ();\n+\tdumpElementln (Integer.toString(this.blockDataBytes));\n+      }\n     else if (marker == TC_BLOCKDATALONG)\n-    {\n-      dumpElement (\"BLOCK DATA LONG SIZE=\");\n-      this.blockDataBytes = this.realInputStream.readInt ();\n-      dumpElementln (Integer.toString(this.blockDataBytes));\n-    }\n+      {\n+\tdumpElement (\"BLOCK DATA LONG SIZE=\");\n+\tthis.blockDataBytes = this.realInputStream.readInt ();\n+\tdumpElementln (Integer.toString(this.blockDataBytes));\n+      }\n     else\n-    {\n-      throw new EOFException (\"Attempt to read primitive data, but no data block is active.\");\n-    }\n+      {\n+\tthrow new EOFException (\"Attempt to read primitive data, but no data block is active.\");\n+      }\n \n     if (this.blockData.length < this.blockDataBytes)\n       this.blockData = new byte[this.blockDataBytes];\n@@ -1170,70 +1153,70 @@ private void readArrayElements (Object array, Class clazz)\n     throws ClassNotFoundException, IOException\n   {\n     if (clazz.isPrimitive ())\n-    {\n-      if (clazz == Boolean.TYPE)\n-      {\n-\tboolean[] cast_array = (boolean[])array;\n-\tfor (int i=0; i < cast_array.length; i++)\n-\t  cast_array[i] = this.realInputStream.readBoolean ();\n-\treturn;\n-      }\n-      if (clazz == Byte.TYPE)\n       {\n-\tbyte[] cast_array = (byte[])array;\n-\tfor (int i=0; i < cast_array.length; i++)\n-\t  cast_array[i] = this.realInputStream.readByte ();\n-\treturn;\n-      }\n-      if (clazz == Character.TYPE)\n-      {\n-\tchar[] cast_array = (char[])array;\n-\tfor (int i=0; i < cast_array.length; i++)\n-\t  cast_array[i] = this.realInputStream.readChar ();\n-\treturn;\n-      }\n-      if (clazz == Double.TYPE)\n-      {\n-\tdouble[] cast_array = (double[])array;\n-\tfor (int i=0; i < cast_array.length; i++)\n-\t  cast_array[i] = this.realInputStream.readDouble ();\n-\treturn;\n-      }\n-      if (clazz == Float.TYPE)\n-      {\n-\tfloat[] cast_array = (float[])array;\n-\tfor (int i=0; i < cast_array.length; i++)\n-\t  cast_array[i] = this.realInputStream.readFloat ();\n-\treturn;\n-      }\n-      if (clazz == Integer.TYPE)\n-      {\n-\tint[] cast_array = (int[])array;\n-\tfor (int i=0; i < cast_array.length; i++)\n-\t  cast_array[i] = this.realInputStream.readInt ();\n-\treturn;\n-      }\n-      if (clazz == Long.TYPE)\n-      {\n-\tlong[] cast_array = (long[])array;\n-\tfor (int i=0; i < cast_array.length; i++)\n-\t  cast_array[i] = this.realInputStream.readLong ();\n-\treturn;\n+\tif (clazz == Boolean.TYPE)\n+\t  {\n+\t    boolean[] cast_array = (boolean[])array;\n+\t    for (int i=0; i < cast_array.length; i++)\n+\t      cast_array[i] = this.realInputStream.readBoolean ();\n+\t    return;\n+\t  }\n+\tif (clazz == Byte.TYPE)\n+\t  {\n+\t    byte[] cast_array = (byte[])array;\n+\t    for (int i=0; i < cast_array.length; i++)\n+\t      cast_array[i] = this.realInputStream.readByte ();\n+\t    return;\n+\t  }\n+\tif (clazz == Character.TYPE)\n+\t  {\n+\t    char[] cast_array = (char[])array;\n+\t    for (int i=0; i < cast_array.length; i++)\n+\t      cast_array[i] = this.realInputStream.readChar ();\n+\t    return;\n+\t  }\n+\tif (clazz == Double.TYPE)\n+\t  {\n+\t    double[] cast_array = (double[])array;\n+\t    for (int i=0; i < cast_array.length; i++)\n+\t      cast_array[i] = this.realInputStream.readDouble ();\n+\t    return;\n+\t  }\n+\tif (clazz == Float.TYPE)\n+\t  {\n+\t    float[] cast_array = (float[])array;\n+\t    for (int i=0; i < cast_array.length; i++)\n+\t      cast_array[i] = this.realInputStream.readFloat ();\n+\t    return;\n+\t  }\n+\tif (clazz == Integer.TYPE)\n+\t  {\n+\t    int[] cast_array = (int[])array;\n+\t    for (int i=0; i < cast_array.length; i++)\n+\t      cast_array[i] = this.realInputStream.readInt ();\n+\t    return;\n+\t  }\n+\tif (clazz == Long.TYPE)\n+\t  {\n+\t    long[] cast_array = (long[])array;\n+\t    for (int i=0; i < cast_array.length; i++)\n+\t      cast_array[i] = this.realInputStream.readLong ();\n+\t    return;\n+\t  }\n+\tif (clazz == Short.TYPE)\n+\t  {\n+\t    short[] cast_array = (short[])array;\n+\t    for (int i=0; i < cast_array.length; i++)\n+\t      cast_array[i] = this.realInputStream.readShort ();\n+\t    return;\n+\t  }\n       }\n-      if (clazz == Short.TYPE)\n+    else\n       {\n-\tshort[] cast_array = (short[])array;\n+\tObject[] cast_array = (Object[])array;\n \tfor (int i=0; i < cast_array.length; i++)\n-\t  cast_array[i] = this.realInputStream.readShort ();\n-\treturn;\n-      }\n-    }\n-    else\n-    {\n-      Object[] cast_array = (Object[])array;\n-      for (int i=0; i < cast_array.length; i++)\n  \t  cast_array[i] = readObject ();\n-    }\n+      }\n   }\n \n \n@@ -1242,16 +1225,14 @@ private void readFields (Object obj, ObjectStreamField[] stream_fields,\n \t\t\t   ObjectStreamClass stream_osc)\n     throws ClassNotFoundException, IOException\n   {\n-//  DEBUGln (\"In readFields\");\n     if (call_read_method)\n-    {\n-//    DEBUGln (\"  call_read_method is true\");\n-      fieldsAlreadyRead = false;\n-      boolean oldmode = setBlockDataMode (true);\n-      callReadMethod (obj, stream_osc.forClass ());\n-      setBlockDataMode (oldmode);\n-      return;\n-    }\n+      {\n+\tfieldsAlreadyRead = false;\n+\tboolean oldmode = setBlockDataMode (true);\n+\tcallReadMethod (obj, stream_osc.forClass ());\n+\tsetBlockDataMode (oldmode);\n+\treturn;\n+      }\n \n     ObjectStreamField[] real_fields =\n       ObjectStreamClass.lookup (stream_osc.forClass ()).fields;\n@@ -1266,144 +1247,142 @@ private void readFields (Object obj, ObjectStreamField[] stream_fields,\n \n     while (stream_idx < stream_fields.length\n \t   && real_idx < real_fields.length)\n-    {\n-      default_initialize = false;\n-      set_value = true;\n-\n-      if (stream_idx == stream_fields.length)\n-\tdefault_initialize = true;\n-      else\n-      {\n-\tstream_field = stream_fields[stream_idx];\n-\ttype = stream_field.getType ();\n-      }\n-\n-      if (real_idx == real_fields.length)\n-\tset_value = false;\n-      else\n       {\n-\treal_field = real_fields[real_idx];\n-\ttype = real_field.getType ();\n-\tfield_name = real_field.getName ();\n-      }\n+\tdefault_initialize = false;\n+\tset_value = true;\n \n-      if (set_value && !default_initialize)\n-      {\n-\tint comp_val =\n-\t  real_field.compareTo (stream_field);\n-\n-\tif (comp_val < 0)\n-\t{\n+\tif (stream_idx == stream_fields.length)\n \t  default_initialize = true;\n-\t  real_idx++;\n-\t}\n-\telse if (comp_val > 0)\n-\t{\n+\telse\n+\t  {\n+\t    stream_field = stream_fields[stream_idx];\n+\t    type = stream_field.getType ();\n+\t  }\n+\n+\tif (real_idx == real_fields.length)\n \t  set_value = false;\n-\t  stream_idx++;\n-\t}\n \telse\n-\t{\n-\t  real_idx++;\n-\t  stream_idx++;\n-\t}\n-      }\n+\t  {\n+\t    real_field = real_fields[real_idx];\n+\t    type = real_field.getType ();\n+\t    field_name = real_field.getName ();\n+\t  }\n \n-      try\n-\t{\n-\t  if (type == Boolean.TYPE)\n-\t    {\n-\t      boolean value =\n-\t\tdefault_initialize ? false : this.realInputStream.readBoolean ();\n-\t      if (!default_initialize && set_value)\n-\t\tdumpElementln (\"  \" + field_name + \": \" + value);\n-\t      if (set_value)\n-\t\tsetBooleanField (obj, field_name, value);\n-\t    }\n-\t  else if (type == Byte.TYPE)\n-\t    {\n-\t      byte value =\n-\t\tdefault_initialize ? 0 : this.realInputStream.readByte ();\n-\t      if (!default_initialize && set_value)\n-\t\tdumpElementln (\"  \" + field_name + \": \" + value);\n-\t      if (set_value)\n-\t\tsetByteField (obj, field_name, value);\n-\t    }\n-\t  else if (type == Character.TYPE)\n-\t    {\n-\t      char value =\n-\t\tdefault_initialize ? (char)0 : this.realInputStream.readChar ();\n-\t      if (!default_initialize && set_value)\n-\t\tdumpElementln (\"  \" + field_name + \": \" + value);\n-\t      if (set_value)\n-\t\tsetCharField (obj, field_name, value);\n-\t    }\n-\t  else if (type == Double.TYPE)\n-\t    {\n-\t      double value =\n-\t\tdefault_initialize ? 0 : this.realInputStream.readDouble ();\n-\t      if (!default_initialize && set_value)\n-\t\tdumpElementln (\"  \" + field_name + \": \" + value);\n-\t      if (set_value)\n-\t\tsetDoubleField (obj, field_name, value);\n-\t    }\n-\t  else if (type == Float.TYPE)\n-\t    {\n-\t      float value =\n-\t\tdefault_initialize ? 0 : this.realInputStream.readFloat ();\n-\t      if (!default_initialize && set_value)\n-\t\tdumpElementln (\"  \" + field_name + \": \" + value);\n-\t      if (set_value)\n-\t\tsetFloatField (obj, field_name, value);\n-\t    }\n-\t  else if (type == Integer.TYPE)\n-\t    {\n-\t      int value =\n-\t\tdefault_initialize ? 0 : this.realInputStream.readInt ();\n-\t      if (!default_initialize && set_value)\n-\t\tdumpElementln (\"  \" + field_name + \": \" + value);\n-\t      if (set_value)\n-\t\tsetIntField (obj, field_name, value);\n-\t    }\n-\t  else if (type == Long.TYPE)\n-\t    {\n-\t      long value =\n-\t\tdefault_initialize ? 0 : this.realInputStream.readLong ();\n-\t      if (!default_initialize && set_value)\n-\t\tdumpElementln (\"  \" + field_name + \": \" + value);\n-\t      if (set_value)\n-\t\tsetLongField (obj, field_name, value);\n-\t    }\n-\t  else if (type == Short.TYPE)\n-\t    {\n-\t      short value =\n-\t\tdefault_initialize ? (short)0 : this.realInputStream.readShort ();\n-\t      if (!default_initialize && set_value)\n-\t\tdumpElementln (\"  \" + field_name + \": \" + value);\n-\t      if (set_value)\n-\t\tsetShortField (obj, field_name, value);\n-\t    }\n-\t  else\n-\t    {\n-\t      Object value =\n-\t\tdefault_initialize ? null : readObject ();\n-\t      if (set_value)\n-\t\tsetObjectField (obj, field_name,\n-\t\t\t\treal_field.getTypeString (), value);\n-\t    }\n-\t}\n-      catch (NoSuchFieldError e)\n-\t{\n-\t  dumpElementln(\"XXXX \" + field_name + \" does not exist.\");\n-\t}\n-    }\n-  }\n+\tif (set_value && !default_initialize)\n+\t  {\n+\t    int comp_val =\n+\t      real_field.compareTo (stream_field);\n+\n+\t    if (comp_val < 0)\n+\t      {\n+\t\tdefault_initialize = true;\n+\t\treal_idx++;\n+\t      }\n+\t    else if (comp_val > 0)\n+\t      {\n+\t\tset_value = false;\n+\t\tstream_idx++;\n+\t      }\n+\t    else\n+\t      {\n+\t\treal_idx++;\n+\t\tstream_idx++;\n+\t      }\n+\t  }\n \n+\ttry\n+\t  {\n+\t    if (type == Boolean.TYPE)\n+\t      {\n+\t\tboolean value =\n+\t\t  default_initialize ? false : this.realInputStream.readBoolean ();\n+\t\tif (!default_initialize && set_value)\n+\t\t  dumpElementln (\"  \" + field_name + \": \" + value);\n+\t\tif (set_value)\n+\t\t  setBooleanField (obj, field_name, value);\n+\t      }\n+\t    else if (type == Byte.TYPE)\n+\t      {\n+\t\tbyte value =\n+\t\t  default_initialize ? 0 : this.realInputStream.readByte ();\n+\t\tif (!default_initialize && set_value)\n+\t\t  dumpElementln (\"  \" + field_name + \": \" + value);\n+\t\tif (set_value)\n+\t\t  setByteField (obj, field_name, value);\n+\t      }\n+\t    else if (type == Character.TYPE)\n+\t      {\n+\t\tchar value =\n+\t\t  default_initialize ? (char)0 : this.realInputStream.readChar ();\n+\t\tif (!default_initialize && set_value)\n+\t\t  dumpElementln (\"  \" + field_name + \": \" + value);\n+\t\tif (set_value)\n+\t\t  setCharField (obj, field_name, value);\n+\t      }\n+\t    else if (type == Double.TYPE)\n+\t      {\n+\t\tdouble value =\n+\t\t  default_initialize ? 0 : this.realInputStream.readDouble ();\n+\t\tif (!default_initialize && set_value)\n+\t\t  dumpElementln (\"  \" + field_name + \": \" + value);\n+\t\tif (set_value)\n+\t\t  setDoubleField (obj, field_name, value);\n+\t      }\n+\t    else if (type == Float.TYPE)\n+\t      {\n+\t\tfloat value =\n+\t\t  default_initialize ? 0 : this.realInputStream.readFloat ();\n+\t\tif (!default_initialize && set_value)\n+\t\t  dumpElementln (\"  \" + field_name + \": \" + value);\n+\t\tif (set_value)\n+\t\t  setFloatField (obj, field_name, value);\n+\t      }\n+\t    else if (type == Integer.TYPE)\n+\t      {\n+\t\tint value =\n+\t\t  default_initialize ? 0 : this.realInputStream.readInt ();\n+\t\tif (!default_initialize && set_value)\n+\t\t  dumpElementln (\"  \" + field_name + \": \" + value);\n+\t\tif (set_value)\n+\t\t  setIntField (obj, field_name, value);\n+\t      }\n+\t    else if (type == Long.TYPE)\n+\t      {\n+\t\tlong value =\n+\t\t  default_initialize ? 0 : this.realInputStream.readLong ();\n+\t\tif (!default_initialize && set_value)\n+\t\t  dumpElementln (\"  \" + field_name + \": \" + value);\n+\t\tif (set_value)\n+\t\t  setLongField (obj, field_name, value);\n+\t      }\n+\t    else if (type == Short.TYPE)\n+\t      {\n+\t\tshort value =\n+\t\t  default_initialize ? (short)0 : this.realInputStream.readShort ();\n+\t\tif (!default_initialize && set_value)\n+\t\t  dumpElementln (\"  \" + field_name + \": \" + value);\n+\t\tif (set_value)\n+\t\t  setShortField (obj, field_name, value);\n+\t      }\n+\t    else\n+\t      {\n+\t\tObject value =\n+\t\t  default_initialize ? null : readObject ();\n+\t\tif (set_value)\n+\t\t  setObjectField (obj, field_name,\n+\t\t\t\t  real_field.getTypeString (), value);\n+\t      }\n+\t  }\n+\tcatch (NoSuchFieldError e)\n+\t  {\n+\t    dumpElementln(\"XXXX \" + field_name + \" does not exist.\");\n+\t  }\n+      }\n+  }\n \n   // Toggles writing primitive data to block-data buffer.\n   private boolean setBlockDataMode (boolean on)\n   {\n-//    DEBUGln (\"Setting block data mode to \" + on);\n     boolean oldmode = this.readDataFromBlock;\n     this.readDataFromBlock = on;\n \n@@ -1420,15 +1399,15 @@ private boolean setBlockDataMode (boolean on)\n   private Object newObject (Class real_class, Class constructor_class)\n   {\n     try\n-    {\n-      Object obj = allocateObject (real_class);\n-      callConstructor (constructor_class, obj);\n-      return obj;\n-    }\n+      {\n+\tObject obj = allocateObject (real_class);\n+\tcallConstructor (constructor_class, obj);\n+\treturn obj;\n+      }\n     catch (InstantiationException e)\n-    {\n-      return null;\n-    }\n+      {\n+\treturn null;\n+      }\n   }\n \n \n@@ -1441,14 +1420,14 @@ private void invokeValidators () throws InvalidObjectException\n     Arrays.sort (validators);\n \n     try\n-    {\n-      for (int i=0; i < validators.length; i++)\n-\t((ObjectInputValidation)validators[i]).validateObject ();\n-    }\n+      {\n+\tfor (int i=0; i < validators.length; i++)\n+\t  ((ObjectInputValidation)validators[i]).validateObject ();\n+      }\n     finally\n-    {\n-      this.validators.removeAllElements ();\n-    }\n+      {\n+\tthis.validators.removeAllElements ();\n+      }\n   }\n \n \n@@ -1465,13 +1444,13 @@ private static Field getField (Class klass, String name)\n   {\n     return klass.getDeclaredField(name);\n   }\n-                                                                                \n+\n   private static Method getMethod (Class klass, String name, Class args[])\n     throws java.lang.NoSuchMethodException\n   {\n     return klass.getDeclaredMethod(name, args);\n   }\n-                                                                                \n+\n   private void callReadMethod (Object obj, Class klass) throws IOException\n   {\n     try\n@@ -1523,7 +1502,7 @@ private void setBooleanField (Object obj, String field_name,\n   }\n \n   private void setByteField (Object obj, String field_name,\n-\t\t\t\tbyte val)\n+\t\t\t     byte val)\n   {\n     try\n       {\n@@ -1583,7 +1562,7 @@ private void setFloatField (Object obj, String field_name,\n   }\n \n   private void setIntField (Object obj, String field_name,\n-\t\t\t      int val)\n+\t\t\t    int val)\n   {\n     try\n       {\n@@ -1599,7 +1578,7 @@ private void setIntField (Object obj, String field_name,\n \n \n   private void setLongField (Object obj, String field_name,\n-\t\t\t      long val)\n+\t\t\t     long val)\n   {\n     try\n       {\n@@ -1666,7 +1645,7 @@ private void setObjectField (Object obj, String field_name, String type_code,\n   private boolean fieldsAlreadyRead;\n   private Vector validators;\n \n-  private static boolean dump;  \n+  private static boolean dump;\n \n   private void dumpElement (String msg)\n   {\n@@ -1681,12 +1660,12 @@ private void dumpElementln (String msg)\n   }\n \n   static\n-    {\n-      if (Configuration.INIT_LOAD_LIBRARY)\n-\t{\n-\t  System.loadLibrary (\"javaio\");\n-\t}\n-    }\n+  {\n+    if (Configuration.INIT_LOAD_LIBRARY)\n+      {\n+\tSystem.loadLibrary (\"javaio\");\n+      }\n+  }\n }\n \n "}, {"sha": "69f789abbf8f1588dddbae9bf83247a4fcbb0ca7", "filename": "libjava/java/io/ObjectOutputStream.java", "status": "modified", "additions": 291, "deletions": 290, "changes": 581, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91996637fe4a43743af1b2ebcdda4ce8e473a03/libjava%2Fjava%2Fio%2FObjectOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91996637fe4a43743af1b2ebcdda4ce8e473a03/libjava%2Fjava%2Fio%2FObjectOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectOutputStream.java?ref=d91996637fe4a43743af1b2ebcdda4ce8e473a03", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -77,22 +77,22 @@\n    in a graph lost.\n \n    Example usage:\n-     <pre>\n-     Hashtable map = new Hashtable ();\n-     map.put (\"one\", new Integer (1));\n-     map.put (\"two\", new Integer (2));\n+   <pre>\n+   Hashtable map = new Hashtable ();\n+   map.put (\"one\", new Integer (1));\n+   map.put (\"two\", new Integer (2));\n \n-     ObjectOutputStream oos =\n-       new ObjectOutputStream (new FileOutputStream (\"numbers\"));\n-     oos.writeObject (map);\n-     oos.close ();\n+   ObjectOutputStream oos =\n+   new ObjectOutputStream (new FileOutputStream (\"numbers\"));\n+   oos.writeObject (map);\n+   oos.close ();\n \n-     ObjectInputStream ois =\n-       new ObjectInputStream (new FileInputStream (\"numbers\"));\n-     Hashtable newmap = (Hashtable)ois.readObject ();\n+   ObjectInputStream ois =\n+   new ObjectInputStream (new FileInputStream (\"numbers\"));\n+   Hashtable newmap = (Hashtable)ois.readObject ();\n \n-     System.out.println (newmap);\n-     </pre>\n+   System.out.println (newmap);\n+   </pre>\n \n    The default serialization can be overriden in two ways.\n \n@@ -188,24 +188,24 @@ public final void writeObject (Object obj) throws IOException\n \t\trealOutput.writeByte (TC_NULL);\n \t\tbreak;\n \t      }\n-\t    \n+\n \t    Integer handle = findHandle (obj);\n \t    if (handle != null)\n \t      {\n \t\trealOutput.writeByte (TC_REFERENCE);\n \t\trealOutput.writeInt (handle.intValue ());\n \t\tbreak;\n \t      }\n-\t    \n+\n \t    if (obj instanceof Class)\n \t      {\n \t\tClass cl = (Class)obj;\n-\t\tObjectStreamClass osc = ObjectStreamClass.lookupForClassObject(cl);\n+\t\tObjectStreamClass osc = ObjectStreamClass.lookupForClassObject (cl);\n \t\tassignNewHandle (obj);\n \t\trealOutput.writeByte (TC_CLASS);\n \t\tif (!osc.isProxyClass)\n \t\t  {\n-\t\t    writeObject(osc);\n+\t\t    writeObject (osc);\n \t\t  }\n \t\telse\n \t\t  {\n@@ -224,54 +224,54 @@ public final void writeObject (Object obj) throws IOException\n \t\t  }\n \t\tbreak;\n \t      }\n-\t    \n+\n \t    if (obj instanceof ObjectStreamClass)\n \t      {\n \t\tObjectStreamClass osc = (ObjectStreamClass)obj;\n \t\trealOutput.writeByte (TC_CLASSDESC);\n \t\trealOutput.writeUTF (osc.getName ());\n \t\trealOutput.writeLong (osc.getSerialVersionUID ());\n \t\tassignNewHandle (obj);\n-\t\t\n+\n \t\tint flags = osc.getFlags ();\n-\t\t\n+\n \t\tif (protocolVersion == PROTOCOL_VERSION_2\n \t\t    && osc.isExternalizable ())\n \t\t  flags |= SC_BLOCK_DATA;\n-\t\t\n+\n \t\trealOutput.writeByte (flags);\n-\t\t\n+\n \t\tObjectStreamField[] fields = osc.fields;\n \t\trealOutput.writeShort (fields.length);\n-\t\t\n+\n \t\tObjectStreamField field;\n \t\tfor (int i=0; i < fields.length; i++)\n \t\t  {\n \t\t    field = fields[i];\n \t\t    realOutput.writeByte (field.getTypeCode ());\n \t\t    realOutput.writeUTF (field.getName ());\n-\t\t    \n+\n \t\t    if (! field.isPrimitive ())\n \t\t      writeObject (field.getTypeString ());\n \t\t  }\n-\t\t\n+\n \t\tboolean oldmode = setBlockDataMode (true);\n \t\tannotateClass (osc.forClass ());\n \t\tsetBlockDataMode (oldmode);\n \t\trealOutput.writeByte (TC_ENDBLOCKDATA);\n-\t\t\n+\n \t\tif (osc.isSerializable ())\n \t\t  writeObject (osc.getSuper ());\n \t\telse\n \t\t  writeObject (null);\n \t\tbreak;\n \t      }\n-\t    \n+\n \t    if ((replacementEnabled || obj instanceof Serializable)\n \t\t&& ! replaceDone)\n \t      {\n \t\treplacedObject = obj;\n-\t\t\n+\n \t\tif (obj instanceof Serializable)\n \t\t  {\n \t\t    Method m = null;\n@@ -294,27 +294,27 @@ public final void writeObject (Object obj) throws IOException\n \t\t      {\n \t\t      }\n \t\t  }\n-\t\t\n+\n \t\tif (replacementEnabled)\n \t\t  obj = replaceObject (obj);\n-\t\t\n+\n \t\treplaceDone = true;\n \t\tcontinue;\n \t      }\n-\t    \n+\n \t    if (obj instanceof String)\n \t      {\n \t\trealOutput.writeByte (TC_STRING);\n \t\tassignNewHandle (obj);\n \t\trealOutput.writeUTF ((String)obj);\n \t\tbreak;\n \t      }\n-\t    \n+\n \t    Class clazz = obj.getClass ();\n \t    ObjectStreamClass osc = ObjectStreamClass.lookupForClassObject (clazz);\n \t    if (osc == null)\n \t      throw new NotSerializableException (clazz.getName ());\n-\t    \n+\n \t    if (clazz.isArray ())\n \t      {\n \t\trealOutput.writeByte (TC_ARRAY);\n@@ -323,56 +323,55 @@ public final void writeObject (Object obj) throws IOException\n \t\twriteArraySizeAndElements (obj, clazz.getComponentType ());\n \t\tbreak;\n \t      }\n-\t    \n+\n \t    realOutput.writeByte (TC_OBJECT);\n \t    writeObject (osc);\n-\t    \n+\n \t    if (replaceDone)\n \t      assignNewHandle (replacedObject);\n \t    else\n \t      assignNewHandle (obj);\n-\t    \n+\n \t    if (obj instanceof Externalizable)\n \t      {\n \t\tif (protocolVersion == PROTOCOL_VERSION_2)\n \t\t  setBlockDataMode (true);\n-\t\t\n+\n \t\t((Externalizable)obj).writeExternal (this);\n-\t\t\n+\n \t\tif (protocolVersion == PROTOCOL_VERSION_2)\n \t\t  {\n \t\t    setBlockDataMode (false);\n \t\t    realOutput.writeByte (TC_ENDBLOCKDATA);\n \t\t  }\n-\t\t\n+\n \t\tbreak;\n \t      }\n-\t    \n+\n \t    if (obj instanceof Serializable)\n \t      {\n \t\tcurrentObject = obj;\n \t\tObjectStreamClass[] hierarchy =\n \t\t  ObjectStreamClass.getObjectStreamClasses (clazz);\n-\t\t\n+\n \t\tboolean has_write;\n \t\tfor (int i=0; i < hierarchy.length; i++)\n \t\t  {\n \t\t    currentObjectStreamClass = hierarchy[i];\n-\t\t    \n+\n \t\t    fieldsAlreadyWritten = false;\n \t\t    has_write = currentObjectStreamClass.hasWriteMethod ();\n-\t\t    \n+\n \t\t    writeFields (obj, currentObjectStreamClass.fields,\n \t\t\t\t has_write);\n-\t\t    \n \t\t  }\n-\t\t\n+\n \t\tcurrentObject = null;\n \t\tcurrentObjectStreamClass = null;\n \t\tcurrentPutField = null;\n \t\tbreak;\n \t      }\n-\t    \n+\n \t    throw new NotSerializableException (clazz.getName ());\n \t  } // end pseudo-loop\n       }\n@@ -395,18 +394,16 @@ public final void writeObject (Object obj) throws IOException\n \t  {\n \t    throw new StreamCorruptedException (\"Exception \" + ioe + \" thrown while exception was being written to stream.\");\n \t  }\n-\t\n+\n \treset (true);\n       }\n     finally\n       {\n \tisSerializing = was_serializing;\n-\n \tsetBlockDataMode (old_mode);\n       }\n   }\n \n-\n   /**\n      Writes the current objects non-transient, non-static fields from\n      the current class to the underlying output stream.\n@@ -464,12 +461,12 @@ public void reset () throws IOException\n   private void reset (boolean internal) throws IOException\n   {\n     if (!internal)\n-    {\n-      if (isSerializing)\n-\tthrow new IOException (\"Reset called while serialization in progress\");\n+      {\n+\tif (isSerializing)\n+\t  throw new IOException (\"Reset called while serialization in progress\");\n \n-      realOutput.writeByte (TC_RESET);\n-    }\n+\trealOutput.writeByte (TC_RESET);\n+      }\n \n     clearHandles ();\n   }\n@@ -649,12 +646,12 @@ protected void writeObjectOverride (Object obj) throws NotActiveException,\n   public void write (int data) throws IOException\n   {\n     if (writeDataAsBlocks)\n-    {\n-      if (blockDataCount == BUFFER_SIZE)\n-\tdrain ();\n+      {\n+\tif (blockDataCount == BUFFER_SIZE)\n+\t  drain ();\n \n-      blockData[ blockDataCount++ ] = (byte)data;\n-    }\n+\tblockData[ blockDataCount++ ] = (byte)data;\n+      }\n     else\n       realOutput.write (data);\n   }\n@@ -675,22 +672,22 @@ public void write (byte[] b) throws IOException\n   public void write (byte[] b, int off, int len) throws IOException\n   {\n     if (writeDataAsBlocks)\n-    {\n-      if (len < 0)\n-\tthrow new IndexOutOfBoundsException ();\n-\n-      if (blockDataCount + len < BUFFER_SIZE)\n-      {\n-\tSystem.arraycopy (b, off, blockData, blockDataCount, len);\n-\tblockDataCount += len;\n-      }\n-      else\n       {\n-\tdrain ();\n-\twriteBlockDataHeader (len);\n-\trealOutput.write (b, off, len);\n+\tif (len < 0)\n+\t  throw new IndexOutOfBoundsException ();\n+\n+\tif (blockDataCount + len < BUFFER_SIZE)\n+\t  {\n+\t    System.arraycopy (b, off, blockData, blockDataCount, len);\n+\t    blockDataCount += len;\n+\t  }\n+\telse\n+\t  {\n+\t    drain ();\n+\t    writeBlockDataHeader (len);\n+\t    realOutput.write (b, off, len);\n+\t  }\n       }\n-    }\n     else\n       realOutput.write (b, off, len);\n   }\n@@ -871,143 +868,143 @@ public PutField putFields () throws IOException\n     currentPutField = new PutField ()\n       {\n \tprivate byte[] prim_field_data\n-\t  = new byte[currentObjectStreamClass.primFieldSize];\n+\t= new byte[currentObjectStreamClass.primFieldSize];\n \tprivate Object[] objs\n-\t  = new Object[currentObjectStreamClass.objectFieldCount];\n+\t= new Object[currentObjectStreamClass.objectFieldCount];\n \n \tpublic void put (String name, boolean value)\n \t  throws IOException, IllegalArgumentException\n-\t  {\n-\t    ObjectStreamField field\n-\t      = currentObjectStreamClass.getField (name);\n-\t    checkType (field, 'Z');\n-\t    prim_field_data[field.getOffset ()] = (byte)(value ? 1 : 0);\n-\t  }\n+\t{\n+\t  ObjectStreamField field\n+\t    = currentObjectStreamClass.getField (name);\n+\t  checkType (field, 'Z');\n+\t  prim_field_data[field.getOffset ()] = (byte)(value ? 1 : 0);\n+\t}\n \n \tpublic void put (String name, byte value)\n \t  throws IOException, IllegalArgumentException\n-\t  {\n-\t    ObjectStreamField field\n-\t      = currentObjectStreamClass.getField (name);\n-\t    checkType (field, 'B');\n-\t    prim_field_data[field.getOffset ()] = value;\n-\t  }\n+\t{\n+\t  ObjectStreamField field\n+\t    = currentObjectStreamClass.getField (name);\n+\t  checkType (field, 'B');\n+\t  prim_field_data[field.getOffset ()] = value;\n+\t}\n \n \tpublic void put (String name, char value)\n \t  throws IOException, IllegalArgumentException\n-\t  {\n-\t    ObjectStreamField field\n-\t      = currentObjectStreamClass.getField (name);\n-\t    checkType (field, 'C');\n-\t    int off = field.getOffset ();\n-\t    prim_field_data[off++] = (byte)(value >>> 8);\n-\t    prim_field_data[off] = (byte)value;\n-\t  }\n+\t{\n+\t  ObjectStreamField field\n+\t    = currentObjectStreamClass.getField (name);\n+\t  checkType (field, 'C');\n+\t  int off = field.getOffset ();\n+\t  prim_field_data[off++] = (byte)(value >>> 8);\n+\t  prim_field_data[off] = (byte)value;\n+\t}\n \n \tpublic void put (String name, double value)\n \t  throws IOException, IllegalArgumentException\n-\t  {\n-\t    ObjectStreamField field\n-\t      = currentObjectStreamClass.getField (name);\n-\t    checkType (field, 'D');\n-\t    int off = field.getOffset ();\n-\t    long l_value = Double.doubleToLongBits (value);\n-\t    prim_field_data[off++] = (byte)(l_value >>> 52);\n-\t    prim_field_data[off++] = (byte)(l_value >>> 48);\n-\t    prim_field_data[off++] = (byte)(l_value >>> 40);\n-\t    prim_field_data[off++] = (byte)(l_value >>> 32);\n-\t    prim_field_data[off++] = (byte)(l_value >>> 24);\n-\t    prim_field_data[off++] = (byte)(l_value >>> 16);\n-\t    prim_field_data[off++] = (byte)(l_value >>> 8);\n-\t    prim_field_data[off] = (byte)l_value;\n-\t  }\n+\t{\n+\t  ObjectStreamField field\n+\t    = currentObjectStreamClass.getField (name);\n+\t  checkType (field, 'D');\n+\t  int off = field.getOffset ();\n+\t  long l_value = Double.doubleToLongBits (value);\n+\t  prim_field_data[off++] = (byte)(l_value >>> 52);\n+\t  prim_field_data[off++] = (byte)(l_value >>> 48);\n+\t  prim_field_data[off++] = (byte)(l_value >>> 40);\n+\t  prim_field_data[off++] = (byte)(l_value >>> 32);\n+\t  prim_field_data[off++] = (byte)(l_value >>> 24);\n+\t  prim_field_data[off++] = (byte)(l_value >>> 16);\n+\t  prim_field_data[off++] = (byte)(l_value >>> 8);\n+\t  prim_field_data[off] = (byte)l_value;\n+\t}\n \n \tpublic void put (String name, float value)\n \t  throws IOException, IllegalArgumentException\n-\t  {\n-\t    ObjectStreamField field\n-\t      = currentObjectStreamClass.getField (name);\n-\t    checkType (field, 'F');\n-\t    int off = field.getOffset ();\n-\t    int i_value = Float.floatToIntBits (value);\n-\t    prim_field_data[off++] = (byte)(i_value >>> 24);\n-\t    prim_field_data[off++] = (byte)(i_value >>> 16);\n-\t    prim_field_data[off++] = (byte)(i_value >>> 8);\n-\t    prim_field_data[off] = (byte)i_value;\n-\t  }\n+\t{\n+\t  ObjectStreamField field\n+\t    = currentObjectStreamClass.getField (name);\n+\t  checkType (field, 'F');\n+\t  int off = field.getOffset ();\n+\t  int i_value = Float.floatToIntBits (value);\n+\t  prim_field_data[off++] = (byte)(i_value >>> 24);\n+\t  prim_field_data[off++] = (byte)(i_value >>> 16);\n+\t  prim_field_data[off++] = (byte)(i_value >>> 8);\n+\t  prim_field_data[off] = (byte)i_value;\n+\t}\n \n \tpublic void put (String name, int value)\n \t  throws IOException, IllegalArgumentException\n-\t  {\n-\t    ObjectStreamField field\n-\t      = currentObjectStreamClass.getField (name);\n-\t    checkType (field, 'I');\n-\t    int off = field.getOffset ();\n-\t    prim_field_data[off++] = (byte)(value >>> 24);\n-\t    prim_field_data[off++] = (byte)(value >>> 16);\n-\t    prim_field_data[off++] = (byte)(value >>> 8);\n-\t    prim_field_data[off] = (byte)value;\n-\t  }\n+\t{\n+\t  ObjectStreamField field\n+\t    = currentObjectStreamClass.getField (name);\n+\t  checkType (field, 'I');\n+\t  int off = field.getOffset ();\n+\t  prim_field_data[off++] = (byte)(value >>> 24);\n+\t  prim_field_data[off++] = (byte)(value >>> 16);\n+\t  prim_field_data[off++] = (byte)(value >>> 8);\n+\t  prim_field_data[off] = (byte)value;\n+\t}\n \n \tpublic void put (String name, long value)\n \t  throws IOException, IllegalArgumentException\n-\t  {\n-\t    ObjectStreamField field\n-\t      = currentObjectStreamClass.getField (name);\n-\t    checkType (field, 'J');\n-\t    int off = field.getOffset ();\n-\t    prim_field_data[off++] = (byte)(value >>> 52);\n-\t    prim_field_data[off++] = (byte)(value >>> 48);\n-\t    prim_field_data[off++] = (byte)(value >>> 40);\n-\t    prim_field_data[off++] = (byte)(value >>> 32);\n-\t    prim_field_data[off++] = (byte)(value >>> 24);\n-\t    prim_field_data[off++] = (byte)(value >>> 16);\n-\t    prim_field_data[off++] = (byte)(value >>> 8);\n-\t    prim_field_data[off] = (byte)value;\n-\t  }\n+\t{\n+\t  ObjectStreamField field\n+\t    = currentObjectStreamClass.getField (name);\n+\t  checkType (field, 'J');\n+\t  int off = field.getOffset ();\n+\t  prim_field_data[off++] = (byte)(value >>> 52);\n+\t  prim_field_data[off++] = (byte)(value >>> 48);\n+\t  prim_field_data[off++] = (byte)(value >>> 40);\n+\t  prim_field_data[off++] = (byte)(value >>> 32);\n+\t  prim_field_data[off++] = (byte)(value >>> 24);\n+\t  prim_field_data[off++] = (byte)(value >>> 16);\n+\t  prim_field_data[off++] = (byte)(value >>> 8);\n+\t  prim_field_data[off] = (byte)value;\n+\t}\n \n \tpublic void put (String name, short value)\n \t  throws IOException, IllegalArgumentException\n-\t  {\n-\t    ObjectStreamField field\n-\t      = currentObjectStreamClass.getField (name);\n-\t    checkType (field, 'S');\n-\t    int off = field.getOffset ();\n-\t    prim_field_data[off++] = (byte)(value >>> 8);\n-\t    prim_field_data[off] = (byte)value;\n-\t  }\n+\t{\n+\t  ObjectStreamField field\n+\t    = currentObjectStreamClass.getField (name);\n+\t  checkType (field, 'S');\n+\t  int off = field.getOffset ();\n+\t  prim_field_data[off++] = (byte)(value >>> 8);\n+\t  prim_field_data[off] = (byte)value;\n+\t}\n \n \tpublic void put (String name, Object value)\n \t  throws IOException, IllegalArgumentException\n-\t  {\n-\t    ObjectStreamField field\n-\t      = currentObjectStreamClass.getField (name);\n-\t    if (field == null)\n-\t      throw new IllegalArgumentException ();\n-\t    if (value != null &&\n-\t    \t! field.getType ().isAssignableFrom (value.getClass ()))\n-\t      throw new IllegalArgumentException ();\n-\t    objs[field.getOffset ()] = value;\n-\t  }\n+\t{\n+\t  ObjectStreamField field\n+\t    = currentObjectStreamClass.getField (name);\n+\t  if (field == null)\n+\t    throw new IllegalArgumentException ();\n+\t  if (value != null &&\n+\t      ! field.getType ().isAssignableFrom (value.getClass ()))\n+\t    throw new IllegalArgumentException ();\n+\t  objs[field.getOffset ()] = value;\n+\t}\n \n \tpublic void write (ObjectOutput out) throws IOException\n-\t  {\n-\t    // Apparently Block data is not used with PutField as per\n-\t    // empirical evidence against JDK 1.2.  Also see Mauve test\n-\t    // java.io.ObjectInputOutput.Test.GetPutField.\n-\t    boolean oldmode = setBlockDataMode (false);\n-\t    out.write (prim_field_data);\n-\t    for (int i = 0; i < objs.length; ++ i)\n-\t      out.writeObject (objs[i]);\n-\t    setBlockDataMode (oldmode);\n-\t  }\n+\t{\n+\t  // Apparently Block data is not used with PutField as per\n+\t  // empirical evidence against JDK 1.2.  Also see Mauve test\n+\t  // java.io.ObjectInputOutput.Test.GetPutField.\n+\t  boolean oldmode = setBlockDataMode (false);\n+\t  out.write (prim_field_data);\n+\t  for (int i = 0; i < objs.length; ++ i)\n+\t    out.writeObject (objs[i]);\n+\t  setBlockDataMode (oldmode);\n+\t}\n \n \tprivate void checkType (ObjectStreamField field, char type)\n \t  throws IllegalArgumentException\n-\t  {\n-\t    if (TypeSignature.getEncodingOfClass (field.getType ()).charAt (0) != type)\n-\t      throw new IllegalArgumentException ();\n-\t  }\n+\t{\n+\t  if (TypeSignature.getEncodingOfClass (field.getType ()).charAt (0) != type)\n+\t    throw new IllegalArgumentException ();\n+\t}\n       };\n     // end PutFieldImpl\n \n@@ -1029,15 +1026,15 @@ public void writeFields () throws IOException\n   private void writeBlockDataHeader (int size) throws IOException\n   {\n     if (size < 256)\n-    {\n-      realOutput.writeByte (TC_BLOCKDATA);\n-      realOutput.write (size);\n-    }\n+      {\n+\trealOutput.writeByte (TC_BLOCKDATA);\n+\trealOutput.write (size);\n+      }\n     else\n-    {\n-      realOutput.writeByte (TC_BLOCKDATALONG);\n-      realOutput.writeInt (size);\n-    }\n+      {\n+\trealOutput.writeByte (TC_BLOCKDATALONG);\n+\trealOutput.writeInt (size);\n+      }\n   }\n \n \n@@ -1073,78 +1070,78 @@ private void writeArraySizeAndElements (Object array, Class clazz)\n     int length = Array.getLength (array);\n \n     if (clazz.isPrimitive ())\n-    {\n-      if (clazz == Boolean.TYPE)\n-      {\n-\tboolean[] cast_array = (boolean[])array;\n-\trealOutput.writeInt (length);\n-\tfor (int i=0; i < length; i++)\n-\t  realOutput.writeBoolean (cast_array[i]);\n-\treturn;\n-      }\n-      if (clazz == Byte.TYPE)\n-      {\n-\tbyte[] cast_array = (byte[])array;\n-\trealOutput.writeInt (length);\n-\trealOutput.write(cast_array, 0, length);\n-\treturn;\n-      }\n-      if (clazz == Character.TYPE)\n-      {\n-\tchar[] cast_array = (char[])array;\n-\trealOutput.writeInt (length);\n-\tfor (int i=0; i < length; i++)\n-\t  realOutput.writeChar (cast_array[i]);\n-\treturn;\n-      }\n-      if (clazz == Double.TYPE)\n-      {\n-\tdouble[] cast_array = (double[])array;\n-\trealOutput.writeInt (length);\n-\tfor (int i=0; i < length; i++)\n-\t  realOutput.writeDouble (cast_array[i]);\n-\treturn;\n-      }\n-      if (clazz == Float.TYPE)\n-      {\n-\tfloat[] cast_array = (float[])array;\n-\trealOutput.writeInt (length);\n-\tfor (int i=0; i < length; i++)\n-\t  realOutput.writeFloat (cast_array[i]);\n-\treturn;\n-      }\n-      if (clazz == Integer.TYPE)\n-      {\n-\tint[] cast_array = (int[])array;\n-\trealOutput.writeInt (length);\n-\tfor (int i=0; i < length; i++)\n-\t  realOutput.writeInt (cast_array[i]);\n-\treturn;\n-      }\n-      if (clazz == Long.TYPE)\n       {\n-\tlong[] cast_array = (long[])array;\n-\trealOutput.writeInt (length);\n-\tfor (int i=0; i < length; i++)\n-\t  realOutput.writeLong (cast_array[i]);\n-\treturn;\n+\tif (clazz == Boolean.TYPE)\n+\t  {\n+\t    boolean[] cast_array = (boolean[])array;\n+\t    realOutput.writeInt (length);\n+\t    for (int i=0; i < length; i++)\n+\t      realOutput.writeBoolean (cast_array[i]);\n+\t    return;\n+\t  }\n+\tif (clazz == Byte.TYPE)\n+\t  {\n+\t    byte[] cast_array = (byte[])array;\n+\t    realOutput.writeInt (length);\n+\t    realOutput.write(cast_array, 0, length);\n+\t    return;\n+\t  }\n+\tif (clazz == Character.TYPE)\n+\t  {\n+\t    char[] cast_array = (char[])array;\n+\t    realOutput.writeInt (length);\n+\t    for (int i=0; i < length; i++)\n+\t      realOutput.writeChar (cast_array[i]);\n+\t    return;\n+\t  }\n+\tif (clazz == Double.TYPE)\n+\t  {\n+\t    double[] cast_array = (double[])array;\n+\t    realOutput.writeInt (length);\n+\t    for (int i=0; i < length; i++)\n+\t      realOutput.writeDouble (cast_array[i]);\n+\t    return;\n+\t  }\n+\tif (clazz == Float.TYPE)\n+\t  {\n+\t    float[] cast_array = (float[])array;\n+\t    realOutput.writeInt (length);\n+\t    for (int i=0; i < length; i++)\n+\t      realOutput.writeFloat (cast_array[i]);\n+\t    return;\n+\t  }\n+\tif (clazz == Integer.TYPE)\n+\t  {\n+\t    int[] cast_array = (int[])array;\n+\t    realOutput.writeInt (length);\n+\t    for (int i=0; i < length; i++)\n+\t      realOutput.writeInt (cast_array[i]);\n+\t    return;\n+\t  }\n+\tif (clazz == Long.TYPE)\n+\t  {\n+\t    long[] cast_array = (long[])array;\n+\t    realOutput.writeInt (length);\n+\t    for (int i=0; i < length; i++)\n+\t      realOutput.writeLong (cast_array[i]);\n+\t    return;\n+\t  }\n+\tif (clazz == Short.TYPE)\n+\t  {\n+\t    short[] cast_array = (short[])array;\n+\t    realOutput.writeInt (length);\n+\t    for (int i=0; i < length; i++)\n+\t      realOutput.writeShort (cast_array[i]);\n+\t    return;\n+\t  }\n       }\n-      if (clazz == Short.TYPE)\n+    else\n       {\n-\tshort[] cast_array = (short[])array;\n+\tObject[] cast_array = (Object[])array;\n \trealOutput.writeInt (length);\n \tfor (int i=0; i < length; i++)\n-\t  realOutput.writeShort (cast_array[i]);\n-\treturn;\n+\t  writeObject (cast_array[i]);\n       }\n-    }\n-    else\n-    {\n-      Object[] cast_array = (Object[])array;\n-      realOutput.writeInt (length);\n-      for (int i=0; i < length; i++)\n-\twriteObject (cast_array[i]);\n-    }\n   }\n \n \n@@ -1156,43 +1153,43 @@ private void writeFields (Object obj,\n \t\t\t    boolean call_write_method) throws IOException\n   {\n     if (call_write_method)\n-    {\n-      setBlockDataMode (true);\n-      callWriteMethod (obj);\n-      setBlockDataMode (false);\n-      realOutput.writeByte (TC_ENDBLOCKDATA);\n-      return;\n-    }\n+      {\n+\tsetBlockDataMode (true);\n+\tcallWriteMethod (obj);\n+\tsetBlockDataMode (false);\n+\trealOutput.writeByte (TC_ENDBLOCKDATA);\n+\treturn;\n+      }\n \n     boolean oldmode = setBlockDataMode (false);\n     String field_name;\n     Class type;\n     for (int i=0; i < fields.length; i++)\n-    {\n-      field_name = fields[i].getName ();\n-      type = fields[i].getType ();\n-\n-      if (type == Boolean.TYPE)\n-\trealOutput.writeBoolean (getBooleanField (obj, field_name));\n-      else if (type == Byte.TYPE)\n-\trealOutput.writeByte (getByteField (obj, field_name));\n-      else if (type == Character.TYPE)\n-\trealOutput.writeChar (getCharField (obj, field_name));\n-      else if (type == Double.TYPE)\n-\trealOutput.writeDouble (getDoubleField (obj, field_name));\n-      else if (type == Float.TYPE)\n-\trealOutput.writeFloat (getFloatField (obj, field_name));\n-      else if (type == Integer.TYPE)\n-\trealOutput.writeInt (getIntField (obj, field_name));\n-      else if (type == Long.TYPE)\n-\trealOutput.writeLong (getLongField (obj, field_name));\n-      else if (type == Short.TYPE)\n-\trealOutput.writeShort (getShortField (obj, field_name));\n-      else\n-\twriteObject (getObjectField (obj, field_name,\n-\t\t\t\t     fields[i].getTypeString ()));\n-    }\n-    setBlockDataMode(oldmode);\n+      {\n+\tfield_name = fields[i].getName ();\n+\ttype = fields[i].getType ();\n+\n+\tif (type == Boolean.TYPE)\n+\t  realOutput.writeBoolean (getBooleanField (obj, field_name));\n+\telse if (type == Byte.TYPE)\n+\t  realOutput.writeByte (getByteField (obj, field_name));\n+\telse if (type == Character.TYPE)\n+\t  realOutput.writeChar (getCharField (obj, field_name));\n+\telse if (type == Double.TYPE)\n+\t  realOutput.writeDouble (getDoubleField (obj, field_name));\n+\telse if (type == Float.TYPE)\n+\t  realOutput.writeFloat (getFloatField (obj, field_name));\n+\telse if (type == Integer.TYPE)\n+\t  realOutput.writeInt (getIntField (obj, field_name));\n+\telse if (type == Long.TYPE)\n+\t  realOutput.writeLong (getLongField (obj, field_name));\n+\telse if (type == Short.TYPE)\n+\t  realOutput.writeShort (getShortField (obj, field_name));\n+\telse\n+\t  writeObject (getObjectField (obj, field_name,\n+\t\t\t\t       fields[i].getTypeString ()));\n+      }\n+    setBlockDataMode (oldmode);\n   }\n \n \n@@ -1246,7 +1243,8 @@ private void callWriteMethod (Object obj) throws IOException\n       }\n   }\n \n-  private boolean getBooleanField (Object obj, String field_name) throws IOException\n+  private boolean getBooleanField (Object obj, String field_name)\n+    throws IOException\n   {\n     try\n       {\n@@ -1291,7 +1289,8 @@ private char getCharField (Object obj, String field_name) throws IOException\n       }    \n   }\n \n-  private double getDoubleField (Object obj, String field_name) throws IOException\n+  private double getDoubleField (Object obj, String field_name)\n+    throws IOException\n   {\n     try\n       {\n@@ -1306,7 +1305,8 @@ private double getDoubleField (Object obj, String field_name) throws IOException\n       }    \n   }\n \n-  private float getFloatField (Object obj, String field_name) throws IOException\n+  private float getFloatField (Object obj, String field_name)\n+    throws IOException\n   {\n     try\n       {\n@@ -1351,7 +1351,8 @@ private long getLongField (Object obj, String field_name) throws IOException\n       }    \n   }\n \n-  private short getShortField (Object obj, String field_name) throws IOException\n+  private short getShortField (Object obj, String field_name)\n+    throws IOException\n   {\n     try\n       {\n@@ -1388,13 +1389,13 @@ private static Field getField (Class klass, String name)\n   {\n     return klass.getDeclaredField(name);\n   }\n-                                                                                \n+\n   private static Method getMethod (Class klass, String name, Class[] args)\n     throws java.lang.NoSuchMethodException\n   {\n     return klass.getDeclaredMethod(name, args);\n   }\n-                                                                                \n+\n   // this value comes from 1.2 spec, but is used in 1.1 as well\n   private final static int BUFFER_SIZE = 1024;\n "}]}