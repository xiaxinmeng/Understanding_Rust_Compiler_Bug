{"sha": "e9619a8a00b43727bfb72d9b578f830053c02249", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTk2MTlhOGEwMGI0MzcyN2JmYjcyZDliNTc4ZjgzMDA1M2MwMjI0OQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-12-13T19:58:56Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-12-13T19:58:56Z"}, "message": "arm: Implement vec_perm and vec_perm_const for NEON.\n\nFrom-SVN: r182299", "tree": {"sha": "a14c5288599260552140cc49e253b319c66e80f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a14c5288599260552140cc49e253b319c66e80f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9619a8a00b43727bfb72d9b578f830053c02249", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9619a8a00b43727bfb72d9b578f830053c02249", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9619a8a00b43727bfb72d9b578f830053c02249", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9619a8a00b43727bfb72d9b578f830053c02249/comments", "author": null, "committer": null, "parents": [{"sha": "8c75d41b920807568bd799f5ba4b46be8dd45ca2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c75d41b920807568bd799f5ba4b46be8dd45ca2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c75d41b920807568bd799f5ba4b46be8dd45ca2"}], "stats": {"total": 623, "additions": 619, "deletions": 4}, "files": [{"sha": "8c3e412a50daffe8520e472d2d2ef0af54653990", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9619a8a00b43727bfb72d9b578f830053c02249/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9619a8a00b43727bfb72d9b578f830053c02249/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=e9619a8a00b43727bfb72d9b578f830053c02249", "patch": "@@ -244,4 +244,7 @@ extern const struct tune_params *current_tune;\n extern int vfp3_const_double_for_fract_bits (rtx);\n #endif /* RTX_CODE */\n \n+extern void arm_expand_vec_perm (rtx target, rtx op0, rtx op1, rtx sel);\n+extern bool arm_expand_vec_perm_const (rtx target, rtx op0, rtx op1, rtx sel);\n+\n #endif /* ! GCC_ARM_PROTOS_H */"}, {"sha": "f8de09e1071d4a357f03cc6d1e16273a5e88053f", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 525, "deletions": 1, "changes": 526, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9619a8a00b43727bfb72d9b578f830053c02249/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9619a8a00b43727bfb72d9b578f830053c02249/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=e9619a8a00b43727bfb72d9b578f830053c02249", "patch": "@@ -267,6 +267,9 @@ static unsigned int arm_autovectorize_vector_sizes (void);\n static int arm_default_branch_cost (bool, bool);\n static int arm_cortex_a5_branch_cost (bool, bool);\n \n+static bool arm_vectorize_vec_perm_const_ok (enum machine_mode vmode,\n+\t\t\t\t\t     const unsigned char *sel);\n+\n \f\n /* Table of machine attributes.  */\n static const struct attribute_spec arm_attribute_table[] =\n@@ -604,6 +607,10 @@ static const struct attribute_spec arm_attribute_table[] =\n #define TARGET_PREFERRED_RENAME_CLASS \\\n   arm_preferred_rename_class\n \n+#undef TARGET_VECTORIZE_VEC_PERM_CONST_OK\n+#define TARGET_VECTORIZE_VEC_PERM_CONST_OK \\\n+  arm_vectorize_vec_perm_const_ok\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Obstack for minipool constant handling.  */\n@@ -25064,6 +25071,523 @@ vfp3_const_double_for_fract_bits (rtx operand)\n     }\n   return 0;\n }\n+\f\n+#define MAX_VECT_LEN 16\n \n-#include \"gt-arm.h\"\n+struct expand_vec_perm_d\n+{\n+  rtx target, op0, op1;\n+  unsigned char perm[MAX_VECT_LEN];\n+  enum machine_mode vmode;\n+  unsigned char nelt;\n+  bool one_vector_p;\n+  bool testing_p;\n+};\n+\n+/* Generate a variable permutation.  */\n+\n+static void\n+arm_expand_vec_perm_1 (rtx target, rtx op0, rtx op1, rtx sel)\n+{\n+  enum machine_mode vmode = GET_MODE (target);\n+  bool one_vector_p = rtx_equal_p (op0, op1);\n+\n+  gcc_checking_assert (vmode == V8QImode || vmode == V16QImode);\n+  gcc_checking_assert (GET_MODE (op0) == vmode);\n+  gcc_checking_assert (GET_MODE (op1) == vmode);\n+  gcc_checking_assert (GET_MODE (sel) == vmode);\n+  gcc_checking_assert (TARGET_NEON);\n+\n+  if (one_vector_p)\n+    {\n+      if (vmode == V8QImode)\n+\temit_insn (gen_neon_vtbl1v8qi (target, op0, sel));\n+      else\n+\temit_insn (gen_neon_vtbl1v16qi (target, op0, sel));\n+    }\n+  else\n+    {\n+      enum machine_mode mode1, mode2;\n+      rtx pair, part;\n+\n+      if (vmode == V8QImode)\n+\tmode1 = DImode, mode2 = TImode;\n+      else\n+\tmode1 = TImode, mode2 = OImode;\n+\n+      pair = gen_reg_rtx (mode2);\n+      emit_insn (gen_rtx_CLOBBER (VOIDmode, pair));\n+\n+      part = simplify_gen_subreg (mode1, pair, mode2,\n+\t\t\t\t  subreg_lowpart_offset (mode1, mode2));\n+      emit_move_insn (part, gen_lowpart (mode1, op0));\n+\n+      part = simplify_gen_subreg (mode1, pair, mode2,\n+\t\t\t\t  subreg_highpart_offset (mode1, mode2));\n+      emit_move_insn (part, gen_lowpart (mode1, op1));\n+\n+      if (vmode == V8QImode)\n+\temit_insn (gen_neon_vtbl2v8qi (target, pair, sel));\n+      else\n+\temit_insn (gen_neon_vtbl2v16qi (target, pair, sel));\n+    }\n+}\n+\n+void\n+arm_expand_vec_perm (rtx target, rtx op0, rtx op1, rtx sel)\n+{\n+  enum machine_mode vmode = GET_MODE (target);\n+  unsigned int i, nelt = GET_MODE_NUNITS (vmode);\n+  bool one_vector_p = rtx_equal_p (op0, op1);\n+  rtx rmask[MAX_VECT_LEN], mask;\n+\n+  /* TODO: ARM's VTBL indexing is little-endian.  In order to handle GCC's\n+     numbering of elements for big-endian, we must reverse the order.  */\n+  gcc_checking_assert (!BYTES_BIG_ENDIAN);\n+\n+  /* The VTBL instruction does not use a modulo index, so we must take care\n+     of that ourselves.  */\n+  mask = GEN_INT (one_vector_p ? nelt - 1 : 2 * nelt - 1);\n+  for (i = 0; i < nelt; ++i)\n+    rmask[i] = mask;\n+  mask = gen_rtx_CONST_VECTOR (vmode, gen_rtvec_v (nelt, rmask));\n+  sel = expand_simple_binop (vmode, AND, sel, mask, NULL, 0, OPTAB_LIB_WIDEN);\n+\n+  arm_expand_vec_perm_1 (target, op0, op1, sel);\n+}\n+\n+/* Generate or test for an insn that supports a constant permutation.  */\n+\n+/* Recognize patterns for the VUZP insns.  */\n+\n+static bool\n+arm_evpc_neon_vuzp (struct expand_vec_perm_d *d)\n+{\n+  unsigned int i, odd, mask, nelt = d->nelt;\n+  rtx out0, out1, in0, in1, x;\n+  rtx (*gen)(rtx, rtx, rtx, rtx);\n+\n+  if (GET_MODE_UNIT_SIZE (d->vmode) >= 8)\n+    return false;\n+\n+  /* Note that these are little-endian tests.  Adjust for big-endian later.  */\n+  if (d->perm[0] == 0)\n+    odd = 0;\n+  else if (d->perm[0] == 1)\n+    odd = 1;\n+  else\n+    return false;\n+  mask = (d->one_vector_p ? nelt - 1 : 2 * nelt - 1);\n+\n+  for (i = 0; i < nelt; i++)\n+    {\n+      unsigned elt = (i * 2 + odd) & mask;\n+      if (d->perm[i] != elt)\n+\treturn false;\n+    }\n+\n+  /* Success!  */\n+  if (d->testing_p)\n+    return true;\n+\n+  switch (d->vmode)\n+    {\n+    case V16QImode: gen = gen_neon_vuzpv16qi_internal; break;\n+    case V8QImode:  gen = gen_neon_vuzpv8qi_internal;  break;\n+    case V8HImode:  gen = gen_neon_vuzpv8hi_internal;  break;\n+    case V4HImode:  gen = gen_neon_vuzpv4hi_internal;  break;\n+    case V4SImode:  gen = gen_neon_vuzpv4si_internal;  break;\n+    case V2SImode:  gen = gen_neon_vuzpv2si_internal;  break;\n+    case V2SFmode:  gen = gen_neon_vuzpv2sf_internal;  break;\n+    case V4SFmode:  gen = gen_neon_vuzpv4sf_internal;  break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  in0 = d->op0;\n+  in1 = d->op1;\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      x = in0, in0 = in1, in1 = x;\n+      odd = !odd;\n+    }\n \n+  out0 = d->target;\n+  out1 = gen_reg_rtx (d->vmode);\n+  if (odd)\n+    x = out0, out0 = out1, out1 = x;\n+\n+  emit_insn (gen (out0, in0, in1, out1));\n+  return true;\n+}\n+\n+/* Recognize patterns for the VZIP insns.  */\n+\n+static bool\n+arm_evpc_neon_vzip (struct expand_vec_perm_d *d)\n+{\n+  unsigned int i, high, mask, nelt = d->nelt;\n+  rtx out0, out1, in0, in1, x;\n+  rtx (*gen)(rtx, rtx, rtx, rtx);\n+\n+  if (GET_MODE_UNIT_SIZE (d->vmode) >= 8)\n+    return false;\n+\n+  /* Note that these are little-endian tests.  Adjust for big-endian later.  */\n+  high = nelt / 2;\n+  if (d->perm[0] == high)\n+    ;\n+  else if (d->perm[0] == 0)\n+    high = 0;\n+  else\n+    return false;\n+  mask = (d->one_vector_p ? nelt - 1 : 2 * nelt - 1);\n+\n+  for (i = 0; i < nelt / 2; i++)\n+    {\n+      unsigned elt = (i + high) & mask;\n+      if (d->perm[i * 2] != elt)\n+\treturn false;\n+      elt = (elt + nelt) & mask;\n+      if (d->perm[i * 2 + 1] != elt)\n+\treturn false;\n+    }\n+\n+  /* Success!  */\n+  if (d->testing_p)\n+    return true;\n+\n+  switch (d->vmode)\n+    {\n+    case V16QImode: gen = gen_neon_vzipv16qi_internal; break;\n+    case V8QImode:  gen = gen_neon_vzipv8qi_internal;  break;\n+    case V8HImode:  gen = gen_neon_vzipv8hi_internal;  break;\n+    case V4HImode:  gen = gen_neon_vzipv4hi_internal;  break;\n+    case V4SImode:  gen = gen_neon_vzipv4si_internal;  break;\n+    case V2SImode:  gen = gen_neon_vzipv2si_internal;  break;\n+    case V2SFmode:  gen = gen_neon_vzipv2sf_internal;  break;\n+    case V4SFmode:  gen = gen_neon_vzipv4sf_internal;  break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  in0 = d->op0;\n+  in1 = d->op1;\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      x = in0, in0 = in1, in1 = x;\n+      high = !high;\n+    }\n+\n+  out0 = d->target;\n+  out1 = gen_reg_rtx (d->vmode);\n+  if (high)\n+    x = out0, out0 = out1, out1 = x;\n+\n+  emit_insn (gen (out0, in0, in1, out1));\n+  return true;\n+}\n+\n+/* Recognize patterns for the VREV insns.  */\n+\n+static bool\n+arm_evpc_neon_vrev (struct expand_vec_perm_d *d)\n+{\n+  unsigned int i, j, diff, nelt = d->nelt;\n+  rtx (*gen)(rtx, rtx, rtx);\n+\n+  if (!d->one_vector_p)\n+    return false;\n+\n+  diff = d->perm[0];\n+  switch (diff)\n+    {\n+    case 7:\n+      switch (d->vmode)\n+\t{\n+\tcase V16QImode: gen = gen_neon_vrev64v16qi; break;\n+\tcase V8QImode:  gen = gen_neon_vrev64v8qi;  break;\n+\tdefault:\n+\t  return false;\n+\t}\n+      break;\n+    case 3:\n+      switch (d->vmode)\n+\t{\n+\tcase V16QImode: gen = gen_neon_vrev32v16qi; break;\n+\tcase V8QImode:  gen = gen_neon_vrev32v8qi;  break;\n+\tcase V8HImode:  gen = gen_neon_vrev64v8hi;  break;\n+\tcase V4HImode:  gen = gen_neon_vrev64v4hi;  break;\n+\tdefault:\n+\t  return false;\n+\t}\n+      break;\n+    case 1:\n+      switch (d->vmode)\n+\t{\n+\tcase V16QImode: gen = gen_neon_vrev16v16qi; break;\n+\tcase V8QImode:  gen = gen_neon_vrev16v8qi;  break;\n+\tcase V8HImode:  gen = gen_neon_vrev32v8hi;  break;\n+\tcase V4HImode:  gen = gen_neon_vrev32v4hi;  break;\n+\tcase V4SImode:  gen = gen_neon_vrev64v4si;  break;\n+\tcase V2SImode:  gen = gen_neon_vrev64v2si;  break;\n+\tcase V4SFmode:  gen = gen_neon_vrev64v4sf;  break;\n+\tcase V2SFmode:  gen = gen_neon_vrev64v2sf;  break;\n+\tdefault:\n+\t  return false;\n+\t}\n+      break;\n+    default:\n+      return false;\n+    }\n+\n+  for (i = 0; i < nelt; i += diff)\n+    for (j = 0; j <= diff; j += 1)\n+      if (d->perm[i + j] != i + diff - j)\n+\treturn false;\n+\n+  /* Success! */\n+  if (d->testing_p)\n+    return true;\n+\n+  /* ??? The third operand is an artifact of the builtin infrastructure\n+     and is ignored by the actual instruction.  */\n+  emit_insn (gen (d->target, d->op0, const0_rtx));\n+  return true;\n+}\n+\n+/* Recognize patterns for the VTRN insns.  */\n+\n+static bool\n+arm_evpc_neon_vtrn (struct expand_vec_perm_d *d)\n+{\n+  unsigned int i, odd, mask, nelt = d->nelt;\n+  rtx out0, out1, in0, in1, x;\n+  rtx (*gen)(rtx, rtx, rtx, rtx);\n+\n+  if (GET_MODE_UNIT_SIZE (d->vmode) >= 8)\n+    return false;\n+\n+  /* Note that these are little-endian tests.  Adjust for big-endian later.  */\n+  if (d->perm[0] == 0)\n+    odd = 0;\n+  else if (d->perm[0] == 1)\n+    odd = 1;\n+  else\n+    return false;\n+  mask = (d->one_vector_p ? nelt - 1 : 2 * nelt - 1);\n+\n+  for (i = 0; i < nelt; i += 2)\n+    {\n+      if (d->perm[i] != i + odd)\n+\treturn false;\n+      if (d->perm[i + 1] != ((i + nelt + odd) & mask))\n+\treturn false;\n+    }\n+\n+  /* Success!  */\n+  if (d->testing_p)\n+    return true;\n+\n+  switch (d->vmode)\n+    {\n+    case V16QImode: gen = gen_neon_vtrnv16qi_internal; break;\n+    case V8QImode:  gen = gen_neon_vtrnv8qi_internal;  break;\n+    case V8HImode:  gen = gen_neon_vtrnv8hi_internal;  break;\n+    case V4HImode:  gen = gen_neon_vtrnv4hi_internal;  break;\n+    case V4SImode:  gen = gen_neon_vtrnv4si_internal;  break;\n+    case V2SImode:  gen = gen_neon_vtrnv2si_internal;  break;\n+    case V2SFmode:  gen = gen_neon_vtrnv2sf_internal;  break;\n+    case V4SFmode:  gen = gen_neon_vtrnv4sf_internal;  break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  in0 = d->op0;\n+  in1 = d->op1;\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      x = in0, in0 = in1, in1 = x;\n+      odd = !odd;\n+    }\n+\n+  out0 = d->target;\n+  out1 = gen_reg_rtx (d->vmode);\n+  if (odd)\n+    x = out0, out0 = out1, out1 = x;\n+\n+  emit_insn (gen (out0, in0, in1, out1));\n+  return true;\n+}\n+\n+/* The NEON VTBL instruction is a fully variable permuation that's even\n+   stronger than what we expose via VEC_PERM_EXPR.  What it doesn't do\n+   is mask the index operand as VEC_PERM_EXPR requires.  Therefore we\n+   can do slightly better by expanding this as a constant where we don't\n+   have to apply a mask.  */\n+\n+static bool\n+arm_evpc_neon_vtbl (struct expand_vec_perm_d *d)\n+{\n+  rtx rperm[MAX_VECT_LEN], sel;\n+  enum machine_mode vmode = d->vmode;\n+  unsigned int i, nelt = d->nelt;\n+\n+  /* TODO: ARM's VTBL indexing is little-endian.  In order to handle GCC's\n+     numbering of elements for big-endian, we must reverse the order.  */\n+  if (BYTES_BIG_ENDIAN)\n+    return false;\n+\n+  if (d->testing_p)\n+    return true;\n+\n+  /* Generic code will try constant permutation twice.  Once with the\n+     original mode and again with the elements lowered to QImode.\n+     So wait and don't do the selector expansion ourselves.  */\n+  if (vmode != V8QImode && vmode != V16QImode)\n+    return false;\n+\n+  for (i = 0; i < nelt; ++i)\n+    rperm[i] = GEN_INT (d->perm[i]);\n+  sel = gen_rtx_CONST_VECTOR (vmode, gen_rtvec_v (nelt, rperm));\n+  sel = force_reg (vmode, sel);\n+\n+  arm_expand_vec_perm_1 (d->target, d->op0, d->op1, sel);\n+  return true;\n+}\n+\n+static bool\n+arm_expand_vec_perm_const_1 (struct expand_vec_perm_d *d)\n+{\n+  /* The pattern matching functions above are written to look for a small\n+     number to begin the sequence (0, 1, N/2).  If we begin with an index\n+     from the second operand, we can swap the operands.  */\n+  if (d->perm[0] >= d->nelt)\n+    {\n+      unsigned i, nelt = d->nelt;\n+      rtx x;\n+\n+      for (i = 0; i < nelt; ++i)\n+\td->perm[i] = (d->perm[i] + nelt) & (2 * nelt - 1);\n+\n+      x = d->op0;\n+      d->op0 = d->op1;\n+      d->op1 = x;\n+    }\n+\n+  if (TARGET_NEON)\n+    {\n+      if (arm_evpc_neon_vuzp (d))\n+\treturn true;\n+      if (arm_evpc_neon_vzip (d))\n+\treturn true;\n+      if (arm_evpc_neon_vrev (d))\n+\treturn true;\n+      if (arm_evpc_neon_vtrn (d))\n+\treturn true;\n+      return arm_evpc_neon_vtbl (d);\n+    }\n+  return false;\n+}\n+\n+/* Expand a vec_perm_const pattern.  */\n+\n+bool\n+arm_expand_vec_perm_const (rtx target, rtx op0, rtx op1, rtx sel)\n+{\n+  struct expand_vec_perm_d d;\n+  int i, nelt, which;\n+\n+  d.target = target;\n+  d.op0 = op0;\n+  d.op1 = op1;\n+\n+  d.vmode = GET_MODE (target);\n+  gcc_assert (VECTOR_MODE_P (d.vmode));\n+  d.nelt = nelt = GET_MODE_NUNITS (d.vmode);\n+  d.testing_p = false;\n+\n+  for (i = which = 0; i < nelt; ++i)\n+    {\n+      rtx e = XVECEXP (sel, 0, i);\n+      int ei = INTVAL (e) & (2 * nelt - 1);\n+      which |= (ei < nelt ? 1 : 2);\n+      d.perm[i] = ei;\n+    }\n+\n+  switch (which)\n+    {\n+    default:\n+      gcc_unreachable();\n+\n+    case 3:\n+      d.one_vector_p = false;\n+      if (!rtx_equal_p (op0, op1))\n+\tbreak;\n+\n+      /* The elements of PERM do not suggest that only the first operand\n+\t is used, but both operands are identical.  Allow easier matching\n+\t of the permutation by folding the permutation into the single\n+\t input vector.  */\n+      /* FALLTHRU */\n+    case 2:\n+      for (i = 0; i < nelt; ++i)\n+        d.perm[i] &= nelt - 1;\n+      d.op0 = op1;\n+      d.one_vector_p = true;\n+      break;\n+\n+    case 1:\n+      d.op1 = op0;\n+      d.one_vector_p = true;\n+      break;\n+    }\n+\n+  return arm_expand_vec_perm_const_1 (&d);\n+}\n+\n+/* Implement TARGET_VECTORIZE_VEC_PERM_CONST_OK.  */\n+\n+static bool\n+arm_vectorize_vec_perm_const_ok (enum machine_mode vmode,\n+\t\t\t\t const unsigned char *sel)\n+{\n+  struct expand_vec_perm_d d;\n+  unsigned int i, nelt, which;\n+  bool ret;\n+\n+  d.vmode = vmode;\n+  d.nelt = nelt = GET_MODE_NUNITS (d.vmode);\n+  d.testing_p = true;\n+  memcpy (d.perm, sel, nelt);\n+\n+  /* Categorize the set of elements in the selector.  */\n+  for (i = which = 0; i < nelt; ++i)\n+    {\n+      unsigned char e = d.perm[i];\n+      gcc_assert (e < 2 * nelt);\n+      which |= (e < nelt ? 1 : 2);\n+    }\n+\n+  /* For all elements from second vector, fold the elements to first.  */\n+  if (which == 2)\n+    for (i = 0; i < nelt; ++i)\n+      d.perm[i] -= nelt;\n+\n+  /* Check whether the mask can be applied to the vector type.  */\n+  d.one_vector_p = (which != 3);\n+\n+  d.target = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 1);\n+  d.op1 = d.op0 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 2);\n+  if (!d.one_vector_p)\n+    d.op1 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 3);\n+\n+  start_sequence ();\n+  ret = arm_expand_vec_perm_const_1 (&d);\n+  end_sequence ();\n+\n+  return ret;\n+}\n+\n+\f\n+#include \"gt-arm.h\""}, {"sha": "bd68d39789a446f997a29b49cca54214ac917d27", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9619a8a00b43727bfb72d9b578f830053c02249/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9619a8a00b43727bfb72d9b578f830053c02249/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=e9619a8a00b43727bfb72d9b578f830053c02249", "patch": "@@ -3876,6 +3876,65 @@\n   [(set_attr \"neon_type\" \"neon_bp_3cycle\")]\n )\n \n+;; These two are used by the vec_perm infrastructure for V16QImode.\n+(define_insn_and_split \"neon_vtbl1v16qi\"\n+  [(set (match_operand:V16QI 0 \"s_register_operand\" \"=w\")\n+\t(unspec:V16QI [(match_operand:V16QI 1 \"s_register_operand\" \"w\")\n+\t\t       (match_operand:V16QI 2 \"s_register_operand\" \"w\")]\n+\t\t      UNSPEC_VTBL))]\n+  \"TARGET_NEON\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx op0, op1, op2, part0, part2;\n+  unsigned ofs;\n+\n+  op0 = operands[0];\n+  op1 = gen_lowpart (TImode, operands[1]);\n+  op2 = operands[2];\n+\n+  ofs = subreg_lowpart_offset (V8QImode, V16QImode);\n+  part0 = simplify_subreg (V8QImode, op0, V16QImode, ofs);\n+  part2 = simplify_subreg (V8QImode, op2, V16QImode, ofs);\n+  emit_insn (gen_neon_vtbl2v8qi (part0, op1, part2));\n+\n+  ofs = subreg_highpart_offset (V8QImode, V16QImode);\n+  part0 = simplify_subreg (V8QImode, op0, V16QImode, ofs);\n+  part2 = simplify_subreg (V8QImode, op2, V16QImode, ofs);\n+  emit_insn (gen_neon_vtbl2v8qi (part0, op1, part2));\n+  DONE;\n+})\n+\n+(define_insn_and_split \"neon_vtbl2v16qi\"\n+  [(set (match_operand:V16QI 0 \"s_register_operand\" \"=w\")\n+\t(unspec:V16QI [(match_operand:OI 1 \"s_register_operand\" \"w\")\n+\t\t       (match_operand:V16QI 2 \"s_register_operand\" \"w\")]\n+\t\t      UNSPEC_VTBL))]\n+  \"TARGET_NEON\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx op0, op1, op2, part0, part2;\n+  unsigned ofs;\n+\n+  op0 = operands[0];\n+  op1 = operands[1];\n+  op2 = operands[2];\n+\n+  ofs = subreg_lowpart_offset (V8QImode, V16QImode);\n+  part0 = simplify_subreg (V8QImode, op0, V16QImode, ofs);\n+  part2 = simplify_subreg (V8QImode, op2, V16QImode, ofs);\n+  emit_insn (gen_neon_vtbl2v8qi (part0, op1, part2));\n+\n+  ofs = subreg_highpart_offset (V8QImode, V16QImode);\n+  part0 = simplify_subreg (V8QImode, op0, V16QImode, ofs);\n+  part2 = simplify_subreg (V8QImode, op2, V16QImode, ofs);\n+  emit_insn (gen_neon_vtbl2v8qi (part0, op1, part2));\n+  DONE;\n+})\n+\n (define_insn \"neon_vtbx1v8qi\"\n   [(set (match_operand:V8QI 0 \"s_register_operand\" \"=w\")\n \t(unspec:V8QI [(match_operand:V8QI 1 \"s_register_operand\" \"0\")"}, {"sha": "eb29900b0bca25c228c98ac20098bcb71baa145d", "filename": "gcc/config/arm/vec-common.md", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9619a8a00b43727bfb72d9b578f830053c02249/gcc%2Fconfig%2Farm%2Fvec-common.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9619a8a00b43727bfb72d9b578f830053c02249/gcc%2Fconfig%2Farm%2Fvec-common.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvec-common.md?ref=e9619a8a00b43727bfb72d9b578f830053c02249", "patch": "@@ -108,3 +108,29 @@\n    || (TARGET_REALLY_IWMMXT && VALID_IWMMXT_REG_MODE (<MODE>mode))\"\n {\n })\n+\n+(define_expand \"vec_perm_const<mode>\"\n+  [(match_operand:VALL 0 \"s_register_operand\" \"\")\n+   (match_operand:VALL 1 \"s_register_operand\" \"\")\n+   (match_operand:VALL 2 \"s_register_operand\" \"\")\n+   (match_operand:<V_cmp_result> 3 \"\" \"\")]\n+  \"TARGET_NEON\n+   || (TARGET_REALLY_IWMMXT && VALID_IWMMXT_REG_MODE (<MODE>mode))\"\n+{\n+  if (arm_expand_vec_perm_const (operands[0], operands[1],\n+\t\t\t\t operands[2], operands[3]))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n+(define_expand \"vec_perm<mode>\"\n+  [(match_operand:VE 0 \"s_register_operand\" \"\")\n+   (match_operand:VE 1 \"s_register_operand\" \"\")\n+   (match_operand:VE 2 \"s_register_operand\" \"\")\n+   (match_operand:VE 3 \"s_register_operand\" \"\")]\n+  \"TARGET_NEON && !BYTES_BIG_ENDIAN\"\n+{\n+  arm_expand_vec_perm (operands[0], operands[1], operands[2], operands[3]);\n+  DONE;\n+})"}, {"sha": "d99a0b3af66c23da9ba25e7e92af743826adaa24", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9619a8a00b43727bfb72d9b578f830053c02249/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9619a8a00b43727bfb72d9b578f830053c02249/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=e9619a8a00b43727bfb72d9b578f830053c02249", "patch": "@@ -2725,7 +2725,8 @@ proc check_effective_target_vect_perm { } {\n         verbose \"check_effective_target_vect_perm: using cached result\" 2\n     } else {\n         set et_vect_perm_saved 0\n-        if { [istarget powerpc*-*-*]\n+        if { [is-effective-target arm_neon_ok]\n+\t     || [istarget powerpc*-*-*]\n              || [istarget spu-*-*]\n \t     || [istarget i?86-*-*]\n \t     || [istarget x86_64-*-*] } {\n@@ -2748,7 +2749,8 @@ proc check_effective_target_vect_perm_byte { } {\n         verbose \"check_effective_target_vect_perm_byte: using cached result\" 2\n     } else {\n         set et_vect_perm_byte_saved 0\n-        if { [istarget powerpc*-*-*]\n+        if { [is-effective-target arm_neon_ok]\n+\t     || [istarget powerpc*-*-*]\n              || [istarget spu-*-*] } {\n             set et_vect_perm_byte_saved 1\n         }\n@@ -2769,7 +2771,8 @@ proc check_effective_target_vect_perm_short { } {\n         verbose \"check_effective_target_vect_perm_short: using cached result\" 2\n     } else {\n         set et_vect_perm_short_saved 0\n-        if { [istarget powerpc*-*-*]\n+        if { [is-effective-target arm_neon_ok]\n+\t     || [istarget powerpc*-*-*]\n              || [istarget spu-*-*] } {\n             set et_vect_perm_short_saved 1\n         }"}]}