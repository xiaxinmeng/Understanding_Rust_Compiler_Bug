{"sha": "af8590d281c5ee310242a8afcd519f040f13b0ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWY4NTkwZDI4MWM1ZWUzMTAyNDJhOGFmY2Q1MTlmMDQwZjEzYjBlYw==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2006-01-20T02:38:54Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2006-01-20T02:38:54Z"}, "message": "Implement list::splice (and merge) bits of N1599\n\n2006-01-19  Paolo Carlini  <pcarlini@suse.de>\n\n\tImplement list::splice (and merge) bits of N1599\n\t* include/bits/stl_list.h (list<>::_M_check_equal_allocators): New.\n\t(list<>::splice(iterator, list&), splice(iterator, list&, iterator),\n\tsplice(iterator, list&, iterator, iterator)): Use it.\n\t* include/bits/stl_list.h (list<>::merge(list&), merge(list&,\n\t_StrictWeakOrdering)): Likewise.\n\t* testsuite/23_containers/list/operators/5.cc: New.\n\nFrom-SVN: r110011", "tree": {"sha": "20ddd71f6f06b008fd6f23029fc804a8d29867ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20ddd71f6f06b008fd6f23029fc804a8d29867ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af8590d281c5ee310242a8afcd519f040f13b0ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af8590d281c5ee310242a8afcd519f040f13b0ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af8590d281c5ee310242a8afcd519f040f13b0ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af8590d281c5ee310242a8afcd519f040f13b0ec/comments", "author": null, "committer": null, "parents": [{"sha": "3b8266e279c432acdc9feca326cf7410ca584f68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b8266e279c432acdc9feca326cf7410ca584f68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b8266e279c432acdc9feca326cf7410ca584f68"}], "stats": {"total": 249, "additions": 214, "deletions": 35}, "files": [{"sha": "d699d6f16d70851791202d05552f033cf9396b42", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af8590d281c5ee310242a8afcd519f040f13b0ec/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af8590d281c5ee310242a8afcd519f040f13b0ec/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=af8590d281c5ee310242a8afcd519f040f13b0ec", "patch": "@@ -1,3 +1,13 @@\n+2006-01-19  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tImplement list::splice (and merge) bits of N1599\n+\t* include/bits/stl_list.h (list<>::_M_check_equal_allocators): New.\n+\t(list<>::splice(iterator, list&), splice(iterator, list&, iterator),\n+\tsplice(iterator, list&, iterator, iterator)): Use it.\n+\t* include/bits/stl_list.h (list<>::merge(list&), merge(list&,\n+\t_StrictWeakOrdering)): Likewise.\n+\t* testsuite/23_containers/list/operators/5.cc: New.\n+\n 2006-01-19  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR libstdc++/25797"}, {"sha": "f2849fb6e52a280d820830540317bb30e734ca54", "filename": "libstdc++-v3/include/bits/list.tcc", "status": "modified", "additions": 34, "deletions": 29, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af8590d281c5ee310242a8afcd519f040f13b0ec/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af8590d281c5ee310242a8afcd519f040f13b0ec/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc?ref=af8590d281c5ee310242a8afcd519f040f13b0ec", "patch": "@@ -1,6 +1,7 @@\n // List implementation (out of line) -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006\n+// Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -214,6 +215,8 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n       // 300. list::merge() specification incomplete\n       if (this != &__x)\n \t{\n+\t  _M_check_equal_allocators(__x); \n+\n \t  iterator __first1 = begin();\n \t  iterator __last1 = end();\n \t  iterator __first2 = __x.begin();\n@@ -232,6 +235,36 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n \t}\n     }\n \n+  template<typename _Tp, typename _Alloc>\n+    template <typename _StrictWeakOrdering>\n+      void\n+      list<_Tp, _Alloc>::\n+      merge(list& __x, _StrictWeakOrdering __comp)\n+      {\n+\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t// 300. list::merge() specification incomplete\n+\tif (this != &__x)\n+\t  {\n+\t    _M_check_equal_allocators(__x);\n+\n+\t    iterator __first1 = begin();\n+\t    iterator __last1 = end();\n+\t    iterator __first2 = __x.begin();\n+\t    iterator __last2 = __x.end();\n+\t    while (__first1 != __last1 && __first2 != __last2)\n+\t      if (__comp(*__first2, *__first1))\n+\t\t{\n+\t\t  iterator __next = __first2;\n+\t\t  _M_transfer(__first1, __first2, ++__next);\n+\t\t  __first2 = __next;\n+\t\t}\n+\t      else\n+\t\t++__first1;\n+\t    if (__first2 != __last2)\n+\t      _M_transfer(__last1, __first2, __last2);\n+\t  }\n+      }\n+\n   template<typename _Tp, typename _Alloc>\n     void\n     list<_Tp, _Alloc>::\n@@ -308,34 +341,6 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n \t  }\n       }\n \n-  template<typename _Tp, typename _Alloc>\n-    template <typename _StrictWeakOrdering>\n-      void\n-      list<_Tp, _Alloc>::\n-      merge(list& __x, _StrictWeakOrdering __comp)\n-      {\n-\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n-\t// 300. list::merge() specification incomplete\n-\tif (this != &__x)\n-\t  {\n-\t    iterator __first1 = begin();\n-\t    iterator __last1 = end();\n-\t    iterator __first2 = __x.begin();\n-\t    iterator __last2 = __x.end();\n-\t    while (__first1 != __last1 && __first2 != __last2)\n-\t      if (__comp(*__first2, *__first1))\n-\t\t{\n-\t\t  iterator __next = __first2;\n-\t\t  _M_transfer(__first1, __first2, ++__next);\n-\t\t  __first2 = __next;\n-\t\t}\n-\t      else\n-\t\t++__first1;\n-\t    if (__first2 != __last2)\n-\t      _M_transfer(__last1, __first2, __last2);\n-\t  }\n-      }\n-\n   template<typename _Tp, typename _Alloc>\n     template <typename _StrictWeakOrdering>\n       void"}, {"sha": "5ae400f6f0f47bcaa706f37390ab827bc2271576", "filename": "libstdc++-v3/include/bits/stl_list.h", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af8590d281c5ee310242a8afcd519f040f13b0ec/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af8590d281c5ee310242a8afcd519f040f13b0ec/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h?ref=af8590d281c5ee310242a8afcd519f040f13b0ec", "patch": "@@ -919,12 +919,18 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n        *  The elements of @a x are inserted in constant time in front of\n        *  the element referenced by @a position.  @a x becomes an empty\n        *  list.\n+       *\n+       *  Requires this != @a x.\n        */\n       void\n       splice(iterator __position, list& __x)\n       {\n \tif (!__x.empty())\n-\t  this->_M_transfer(__position, __x.begin(), __x.end());\n+\t  {\n+\t    _M_check_equal_allocators(__x);\n+\n+\t    this->_M_transfer(__position, __x.begin(), __x.end());\n+\t  }\n       }\n \n       /**\n@@ -937,12 +943,16 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n        *  inserts it into the current list before @a position.\n        */\n       void\n-      splice(iterator __position, list&, iterator __i)\n+      splice(iterator __position, list& __x, iterator __i)\n       {\n \titerator __j = __i;\n \t++__j;\n \tif (__position == __i || __position == __j)\n \t  return;\n+\n+\tif (this != &__x)\n+\t  _M_check_equal_allocators(__x);\n+\n \tthis->_M_transfer(__position, __i, __j);\n       }\n \n@@ -959,10 +969,15 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n        *  Undefined if @a position is in [first,last).\n        */\n       void\n-      splice(iterator __position, list&, iterator __first, iterator __last)\n+      splice(iterator __position, list& __x, iterator __first, iterator __last)\n       {\n \tif (__first != __last)\n-\t  this->_M_transfer(__position, __first, __last);\n+\t  {\n+\t    if (this != &__x)\n+\t      _M_check_equal_allocators(__x);\n+\n+\t    this->_M_transfer(__position, __first, __last);\n+\t  }\n       }\n \n       /**\n@@ -991,8 +1006,8 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n        *  responsibilty.\n        */\n       template<typename _Predicate>\n-      void\n-      remove_if(_Predicate);\n+        void\n+        remove_if(_Predicate);\n \n       /**\n        *  @brief  Remove consecutive duplicate elements.\n@@ -1156,6 +1171,14 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n         _M_get_Tp_allocator().destroy(&__n->_M_data);\n         _M_put_node(__n);\n       }\n+\n+      // To implement the splice (and merge) bits of N1599.\n+      void\n+      _M_check_equal_allocators(list& __x)\n+      {\n+\tif (_M_get_Node_allocator() != __x._M_get_Node_allocator())\n+\t  __throw_runtime_error(__N(\"list::_M_check_equal_allocators\"));\n+      }\n     };\n \n   /**"}, {"sha": "22f504691d96f77cb5b7523a86199417276693e9", "filename": "libstdc++-v3/testsuite/23_containers/list/operators/5.cc", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af8590d281c5ee310242a8afcd519f040f13b0ec/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Foperators%2F5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af8590d281c5ee310242a8afcd519f040f13b0ec/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Foperators%2F5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Foperators%2F5.cc?ref=af8590d281c5ee310242a8afcd519f040f13b0ec", "patch": "@@ -0,0 +1,141 @@\n+// 2006-01-19  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2006 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.2.4 list operations [lib.list.ops]\n+\n+#include <list>\n+#include <stdexcept>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+// Check the splice (and merge) bits of N1599.\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  \n+  typedef __gnu_test::uneq_allocator<int> my_alloc;\n+  typedef std::list<int, my_alloc> my_list;\n+\n+  const int data1[] = {1, 2, 3, 4, 5};\n+  const int data2[] = {6, 7, 8, 9, 10};\n+  const size_t N1 = sizeof(data1) / sizeof(int);\n+  const size_t N2 = sizeof(data2) / sizeof(int);\n+  \n+  my_alloc alloc01(1), alloc02(2);\n+\n+  my_list l01(data1, data1 + N1, alloc01);\n+  const my_list l01_ref = l01;\n+\n+  my_list l02(data2, data2 + N2, alloc02);\n+  const my_list l02_ref = l02;\n+\n+  bool catched = false;\n+\n+  try\n+    {\n+      l01.splice(l01.begin(), l02);\n+    }\n+  catch(std::runtime_error&)\n+    {\n+      catched = true;\n+    }\n+  catch(...)\n+    {\n+      VERIFY( false );\n+    }\n+  VERIFY( catched );\n+  VERIFY( l01 == l01_ref );\n+  VERIFY( l02 == l02_ref );\n+  \n+  catched = false;\n+  try\n+    {\n+      l01.splice(l01.begin(), l02, l02.begin());\n+    }\n+  catch(std::runtime_error&)\n+    {\n+      catched = true;\n+    }\n+  catch(...)\n+    {\n+      VERIFY( false );\n+    }\n+  VERIFY( catched );\n+  VERIFY( l01 == l01_ref );\n+  VERIFY( l02 == l02_ref );\n+\n+  catched = false;\n+  try\n+    {\n+      l01.splice(l01.begin(), l02, l02.begin(), l02.end());\n+    }\n+  catch(std::runtime_error&)\n+    {\n+      catched = true;\n+    }\n+  catch(...)\n+    {\n+      VERIFY( false );\n+    }\n+  VERIFY( catched );\n+  VERIFY( l01 == l01_ref );\n+  VERIFY( l02 == l02_ref );\n+\n+  catched = false;\n+  try\n+    {\n+      l01.merge(l02);\n+    }\n+  catch(std::runtime_error&)\n+    {\n+      catched = true;\n+    }\n+  catch(...)\n+    {\n+      VERIFY( false );\n+    }\n+  VERIFY( catched );\n+  VERIFY( l01 == l01_ref );\n+  VERIFY( l02 == l02_ref );\n+\n+  catched = false;\n+  try\n+    {\n+      l01.merge(l02, std::less<int>());\n+    }\n+  catch(std::runtime_error&)\n+    {\n+      catched = true;\n+    }\n+  catch(...)\n+    {\n+      VERIFY( false );\n+    }\n+  VERIFY( catched );\n+  VERIFY( l01 == l01_ref );\n+  VERIFY( l02 == l02_ref );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}]}