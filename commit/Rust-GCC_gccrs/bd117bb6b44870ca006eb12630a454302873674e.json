{"sha": "bd117bb6b44870ca006eb12630a454302873674e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQxMTdiYjZiNDQ4NzBjYTAwNmViMTI2MzBhNDU0MzAyODczNjc0ZQ==", "commit": {"author": {"name": "Basile Starynkevitch", "email": "basile@starynkevitch.net", "date": "2009-06-16T05:56:39Z"}, "committer": {"name": "Basile Starynkevitch", "email": "bstarynk@gcc.gnu.org", "date": "2009-06-16T05:56:39Z"}, "message": "plugins.texi (Interacting with the GCC Garbage Collector): Mention the plugin mode of gengtype.\n\n2009-06-16  Basile Starynkevitch  <basile@starynkevitch.net>\n\n\t* gcc/doc/plugins.texi (Interacting with the GCC Garbage Collector):\n\tMention the plugin mode of gengtype.\n\t* gcc/doc/gty.texi (Source Files Containing Type Information):\n\tLikewise.\n\t* gcc/gengtype.c: Updated copyright.\n\t(plugin_files, nb_plugin_files) Added new static variables.\n\t(measure_input_list) Care about plugin_files.\n\t(write_rtx_next): Added early return in plugin mode.\n\t(create_file): Updated copyright year in generated file. Added\n\tasserts.\n\t(oprintf): Added early return if NULL outf.\n\t(get_output_file_with_visibility): Care of plugin_files.\n\t(get_output_file_name): May return null.\n\t(write_local): Added early return.\n\t(put_mangled_filename): Ditto.\n\t(finish_root_table): Added check for base_files.\n\t(write_roots): Care about null when plugins.\n\t(main): Added plugin mode.\n\nFrom-SVN: r148515", "tree": {"sha": "9bf2e3f5e895411e8065588b15ce395cabf67fe6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9bf2e3f5e895411e8065588b15ce395cabf67fe6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd117bb6b44870ca006eb12630a454302873674e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd117bb6b44870ca006eb12630a454302873674e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd117bb6b44870ca006eb12630a454302873674e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd117bb6b44870ca006eb12630a454302873674e/comments", "author": {"login": "bstarynk", "id": 90412, "node_id": "MDQ6VXNlcjkwNDEy", "avatar_url": "https://avatars.githubusercontent.com/u/90412?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bstarynk", "html_url": "https://github.com/bstarynk", "followers_url": "https://api.github.com/users/bstarynk/followers", "following_url": "https://api.github.com/users/bstarynk/following{/other_user}", "gists_url": "https://api.github.com/users/bstarynk/gists{/gist_id}", "starred_url": "https://api.github.com/users/bstarynk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bstarynk/subscriptions", "organizations_url": "https://api.github.com/users/bstarynk/orgs", "repos_url": "https://api.github.com/users/bstarynk/repos", "events_url": "https://api.github.com/users/bstarynk/events{/privacy}", "received_events_url": "https://api.github.com/users/bstarynk/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e1b7793c8ebdc72bd3d7283d70a29444da614c13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1b7793c8ebdc72bd3d7283d70a29444da614c13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1b7793c8ebdc72bd3d7283d70a29444da614c13"}], "stats": {"total": 129, "additions": 109, "deletions": 20}, "files": [{"sha": "cb29d9681f4208b39d783b41cc60c42a7cb80fd2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd117bb6b44870ca006eb12630a454302873674e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd117bb6b44870ca006eb12630a454302873674e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bd117bb6b44870ca006eb12630a454302873674e", "patch": "@@ -1,3 +1,24 @@\n+2009-06-16  Basile Starynkevitch  <basile@starynkevitch.net>\n+\n+\t* doc/plugins.texi (Interacting with the GCC Garbage Collector):\n+\tMention the plugin mode of gengtype.\n+\t* doc/gty.texi (Source Files Containing Type Information):\n+\tLikewise.\n+\t* gengtype.c: Updated copyright.\n+\t(plugin_files, nb_plugin_files) Added new static variables.\n+\t(measure_input_list) Care about plugin_files.\n+\t(write_rtx_next): Added early return in plugin mode.\n+\t(create_file): Updated copyright year in generated file. Added\n+\tasserts.\n+\t(oprintf): Added early return if NULL outf.\n+\t(get_output_file_with_visibility): Care of plugin_files.\n+\t(get_output_file_name): May return null.\n+\t(write_local): Added early return.\n+\t(put_mangled_filename): Ditto.\n+\t(finish_root_table): Added check for base_files.\n+\t(write_roots): Care about null when plugins.\n+\t(main): Added plugin mode.\n+\n 2009-06-15  Ian Lance Taylor  <iant@google.com>\n \n \t* df-problems.c (df_simulate_one_insn_forwards): Fix braces in"}, {"sha": "b59d5f3d35e993e2487eab2e2be2ae5652f2ec22", "filename": "gcc/doc/gty.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd117bb6b44870ca006eb12630a454302873674e/gcc%2Fdoc%2Fgty.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd117bb6b44870ca006eb12630a454302873674e/gcc%2Fdoc%2Fgty.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgty.texi?ref=bd117bb6b44870ca006eb12630a454302873674e", "patch": "@@ -450,6 +450,14 @@ For language frontends, there is another file that needs to be included\n somewhere.  It will be called @file{gtype-@var{lang}.h}, where\n @var{lang} is the name of the subdirectory the language is contained in.\n \n+Plugins can add additional root tables.  Run the @code{gengtype}\n+utility in plugin mode as @code{gengtype -p @var{source-dir}\n+@var{file-list} @var{plugin*.c}} with your plugin files\n+@var{plugin*.c} using @code{GTY} to generate the corresponding\n+@var{gt-plugin*.h} files.  The GCC build tree is needed to be present in\n+that mode.\n+\n+\n @node Invoking the garbage collector\n @section How to invoke the garbage collector\n @cindex garbage collector, invocation"}, {"sha": "f02f931b102608656b64837ec7ff898651ddb054", "filename": "gcc/doc/plugins.texi", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd117bb6b44870ca006eb12630a454302873674e/gcc%2Fdoc%2Fplugins.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd117bb6b44870ca006eb12630a454302873674e/gcc%2Fdoc%2Fplugins.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fplugins.texi?ref=bd117bb6b44870ca006eb12630a454302873674e", "patch": "@@ -198,13 +198,15 @@ Some plugins may need to have GGC mark additional data. This can be\n done by registering a callback (called with a null @code{gcc_data})\n for the @code{PLUGIN_GGC_MARKING} event. Such callbacks can call the\n @code{ggc_set_mark} routine, preferably thru the @code{ggc_mark} macro\n-(and conversly, these routines should usually not be used in plugins\n-outside of the @code{PLUGIN_GGC_MARKING} event).\n+(and conversely, these routines should usually not be used in plugins\n+outside of the @code{PLUGIN_GGC_MARKING} event).  \n \n Some plugins may need to add extra GGC root tables, e.g. to handle\n their own @code{GTY}-ed data. This can be done with the\n-@code{PLUGIN_REGISTER_GGC_ROOTS} pseudo-event with a null callback and the\n-extra root table as @code{user_data}.\n+@code{PLUGIN_REGISTER_GGC_ROOTS} pseudo-event with a null callback and\n+the extra root table as @code{user_data}.  Running the @code{gengtype\n+-p @var{source-dir} @var{file-list} @var{plugin*.c} ...} utility\n+generates this extra root table.\n \n You should understand the details of memory management inside GCC\n before using @code{PLUGIN_GGC_MARKING} or"}, {"sha": "1b1e6fa70787b33b777bc1f318761db6b22419f4", "filename": "gcc/gengtype.c", "status": "modified", "additions": 74, "deletions": 16, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd117bb6b44870ca006eb12630a454302873674e/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd117bb6b44870ca006eb12630a454302873674e/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=bd117bb6b44870ca006eb12630a454302873674e", "patch": "@@ -128,18 +128,24 @@ typedef struct outf * outf_p;\n \n /* An output file, suitable for definitions, that can see declarations\n    made in INPUT_FILE and is linked into every language that uses\n-   INPUT_FILE.  */\n+   INPUT_FILE.  May return NULL in plugin mode. */\n extern outf_p get_output_file_with_visibility\n    (const char *input_file);\n const char *get_output_file_name (const char *);\n \n-/* Print, like fprintf, to O.  */\n+/* Print, like fprintf, to O.  No-op if O is NULL. */\n static void oprintf (outf_p o, const char *S, ...)\n      ATTRIBUTE_PRINTF_2;\n \n /* The list of output files.  */\n static outf_p output_files;\n \n+/* The plugin input files and their number; in that case only\n+   corresponding gt-<plugin>.h are generated in the current\n+   directory.  */\n+static char** plugin_files;\n+static int nb_plugin_files;\n+\n /* The output header file that is included into pretty much every\n    source file.  */\n static outf_p header_file;\n@@ -274,7 +280,7 @@ measure_input_list (FILE *list)\n   int c;\n   bool atbol = true;\n   num_lang_dirs = 0;\n-  num_gt_files = 0;\n+  num_gt_files = plugin_files ? nb_plugin_files : 0;\n   while ((c = getc (list)) != EOF)\n     {\n       n++;\n@@ -455,6 +461,13 @@ read_input_list (const char *listname)\n       /* Update the global counts now that we know accurately how many\n \t things there are.  (We do not bother resizing the arrays down.)  */\n       num_lang_dirs = langno;\n+      /* Add the plugin files if provided.  */\n+      if (plugin_files) \n+\t{\n+\t  int i;\n+\t  for (i = 0; i < nb_plugin_files; i++)\n+\t    gt_files[nfiles++] = plugin_files[i];\n+\t}\n       num_gt_files = nfiles;\n     }\n \n@@ -962,6 +975,8 @@ write_rtx_next (void)\n {\n   outf_p f = get_output_file_with_visibility (NULL);\n   int i;\n+  if (!f) \n+    return;\n \n   oprintf (f, \"\\n/* Used to implement the RTX_NEXT macro.  */\\n\");\n   oprintf (f, \"EXPORTED_CONST unsigned char rtx_next[NUM_RTX_CODE] = {\\n\");\n@@ -1449,7 +1464,7 @@ static outf_p\n create_file (const char *name, const char *oname)\n {\n   static const char *const hdr[] = {\n-    \"   Copyright (C) 2004, 2007 Free Software Foundation, Inc.\\n\",\n+    \"   Copyright (C) 2004, 2007, 2009 Free Software Foundation, Inc.\\n\",\n     \"\\n\",\n     \"This file is part of GCC.\\n\",\n     \"\\n\",\n@@ -1472,6 +1487,8 @@ create_file (const char *name, const char *oname)\n   outf_p f;\n   size_t i;\n \n+  gcc_assert (name != NULL);\n+  gcc_assert (oname != NULL);\n   f = XCNEW (struct outf);\n   f->next = output_files;\n   f->name = oname;\n@@ -1495,6 +1512,11 @@ oprintf (outf_p o, const char *format, ...)\n   size_t slength;\n   va_list ap;\n \n+  /* In plugin mode, the O could be a NULL pointer, so avoid crashing\n+     in that case.  */\n+  if (!o) \n+    return;\n+\n   va_start (ap, format);\n   slength = vasprintf (&s, format, ap);\n   if (s == NULL || (int)slength < 0)\n@@ -1524,6 +1546,9 @@ open_base_files (void)\n {\n   size_t i;\n \n+  if (nb_plugin_files > 0 && plugin_files)\n+    return;\n+\n   header_file = create_file (\"GCC\", \"gtype-desc.h\");\n \n   base_files = XNEWVEC (outf_p, num_lang_dirs);\n@@ -1686,6 +1711,18 @@ get_output_file_with_visibility (const char *input_file)\n   if (input_file == NULL)\n     input_file = \"system.h\";\n \n+  /* In plugin mode, return NULL unless the input_file is one of the\n+     plugin_files.  */\n+  if (plugin_files && nb_plugin_files > 0) \n+    { \n+      int ix= -1, i;\n+      for (i = 0; i < nb_plugin_files && ix < 0; i++)\n+      if (strcmp (input_file, plugin_files[i]) == 0) \n+\tix = i;\n+      if (ix < 0) \n+\treturn NULL;\n+    }\n+\n   /* Determine the output file name.  */\n   basename = get_file_basename (input_file);\n \n@@ -1737,6 +1774,7 @@ get_output_file_with_visibility (const char *input_file)\n   /* If not, create it.  */\n   r = create_file (for_name, output_name);\n \n+  gcc_assert (r && r->name);\n   return r;\n }\n \n@@ -1747,7 +1785,10 @@ get_output_file_with_visibility (const char *input_file)\n const char *\n get_output_file_name (const char *input_file)\n {\n-  return get_output_file_with_visibility (input_file)->name;\n+  outf_p o =  get_output_file_with_visibility (input_file);\n+  if (o)\n+    return o->name;\n+  return NULL;\n }\n \n /* Copy the output to its final destination,\n@@ -2812,7 +2853,6 @@ write_local_func_for_structure (type_p orig_s, type_p s, type_p *param)\n \n   memset (&d, 0, sizeof (d));\n   d.of = get_output_file_with_visibility (fn);\n-\n   d.process_field = write_types_local_process_field;\n   d.opt = s->u.s.opt;\n   d.line = &s->u.s.line;\n@@ -2848,6 +2888,8 @@ write_local (type_p structures, type_p param_structs)\n {\n   type_p s;\n \n+  if (!header_file) \n+    return;\n   oprintf (header_file, \"\\n/* Local pointer-walking routines.  */\\n\");\n   for (s = structures; s; s = s->next)\n     if (s->gc_used == GC_POINTED_TO\n@@ -2933,6 +2975,8 @@ write_enum_defn (type_p structures, type_p param_structs)\n {\n   type_p s;\n \n+  if (!header_file) \n+    return;\n   oprintf (header_file, \"\\n/* Enumeration of types known.  */\\n\");\n   oprintf (header_file, \"enum gt_types_enum {\\n\");\n   for (s = structures; s; s = s->next)\n@@ -2983,6 +3027,8 @@ static void\n put_mangled_filename (outf_p f, const char *fn)\n {\n   const char *name = get_output_file_name (fn);\n+  if (!f || !name) \n+    return;\n   for (; *name != 0; name++)\n     if (ISALNUM (*name))\n       oprintf (f, \"%c\", *name);\n@@ -3007,7 +3053,7 @@ finish_root_table (struct flist *flp, const char *pfx, const char *lastname,\n \toprintf (fli2->f, \"};\\n\\n\");\n       }\n \n-  for (fli2 = flp; fli2; fli2 = fli2->next)\n+  for (fli2 = flp; fli2 && base_files; fli2 = fli2->next)\n     if (fli2->started_p)\n       {\n \tlang_bitmap bitmap = get_lang_bitmap (fli2->name);\n@@ -3026,7 +3072,7 @@ finish_root_table (struct flist *flp, const char *pfx, const char *lastname,\n \n   {\n     size_t fnum;\n-    for (fnum = 0; fnum < num_lang_dirs; fnum++)\n+    for (fnum = 0; base_files && fnum < num_lang_dirs; fnum++)\n       oprintf (base_files [fnum],\n \t       \"EXPORTED_CONST struct %s * const %s[] = {\\n\",\n \t       tname, name);\n@@ -3041,7 +3087,7 @@ finish_root_table (struct flist *flp, const char *pfx, const char *lastname,\n \n \tfli2->started_p = 0;\n \n-\tfor (fnum = 0; bitmap != 0; fnum++, bitmap >>= 1)\n+\tfor (fnum = 0; base_files && bitmap != 0; fnum++, bitmap >>= 1)\n \t  if (bitmap & 1)\n \t    {\n \t      oprintf (base_files[fnum], \"  gt_%s_\", pfx);\n@@ -3052,7 +3098,7 @@ finish_root_table (struct flist *flp, const char *pfx, const char *lastname,\n \n   {\n     size_t fnum;\n-    for (fnum = 0; fnum < num_lang_dirs; fnum++)\n+    for (fnum = 0; base_files && fnum < num_lang_dirs; fnum++)\n       {\n \toprintf (base_files[fnum], \"  NULL\\n\");\n \toprintf (base_files[fnum], \"};\\n\");\n@@ -3309,7 +3355,7 @@ write_roots (pair_p variables)\n \t\t\t v->name, o->name);\n \n       for (fli = flp; fli; fli = fli->next)\n-\tif (fli->f == f)\n+\tif (fli->f == f && f)\n \t  break;\n       if (fli == NULL)\n \t{\n@@ -3318,6 +3364,7 @@ write_roots (pair_p variables)\n \t  fli->next = flp;\n \t  fli->started_p = 0;\n \t  fli->name = v->line.file;\n+\t  gcc_assert(fli->name);\n \t  flp = fli;\n \n \t  oprintf (f, \"\\n/* GC roots.  */\\n\\n\");\n@@ -3586,17 +3633,28 @@ main (int argc, char **argv)\n {\n   size_t i;\n   static struct fileloc pos = { this_file, 0 };\n-\n+  char* inputlist = 0;\n   /* fatal uses this */\n   progname = \"gengtype\";\n \n-  if (argc != 3)\n-    fatal (\"usage: gengtype srcdir input-list\");\n+  if (argc >= 5 && !strcmp (argv[1], \"-p\")) \n+    {\n+      srcdir = argv[2];\n+      inputlist = argv[3];\n+      plugin_files = argv+4;\n+      nb_plugin_files = argc-4;\n+    }\n+  else if (argc == 3) \n+    {\n+      srcdir = argv[1];\n+      inputlist = argv[2];\n+    } \n+  else\n+    fatal (\"usage: gengtype [-p] srcdir input-list [file1 file2 ... fileN]\");\n \n-  srcdir = argv[1];\n   srcdir_len = strlen (srcdir);\n \n-  read_input_list (argv[2]);\n+  read_input_list (inputlist);\n   if (hit_error)\n     return 1;\n "}]}