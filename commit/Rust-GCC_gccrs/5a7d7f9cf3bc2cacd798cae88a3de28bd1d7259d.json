{"sha": "5a7d7f9cf3bc2cacd798cae88a3de28bd1d7259d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWE3ZDdmOWNmM2JjMmNhY2Q3OThjYWU4OGEzZGUyOGJkMWQ3MjU5ZA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-09-06T13:17:50Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-09-06T13:17:50Z"}, "message": "re PR tree-optimization/48317 (SCCVN does not handle vector constructors)\n\n2011-09-06  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/48317\n\t* tree-ssa-sccvn.h (struct vn_nary_op_s): Make op a true\n\ttrailing array.\n\t(sizeof_vn_nary_op): New inline function.\n\t(vn_nary_op_lookup_pieces): Adjust.\n\t(vn_nary_op_insert_pieces): Likewise.\n\t* tree-ssa-sccvn.c (vn_nary_op_eq): Also compare the length.\n\t(init_vn_nary_op_from_pieces): Adjust signature.  Deal with\n\tany number of operands.\n\t(vn_nary_length_from_stmt): New function.\n\t(init_vn_nary_op_from_stmt): Adjust for CONSTRUCTOR handling.\n\t(vn_nary_op_lookup_pieces): Adjust signature and allocate properly\n\tsized temporary.\n\t(vn_nary_op_lookup): Likewise.\n\t(vn_nary_op_lookup_stmt): Likewise.\n\t(vn_nary_op_insert_into): Likewise.\n\t(vn_nary_op_insert_stmt): Likewise.\n\t(visit_use): Handle CONSTRUCTOR as nary.\n\t* tree-ssa-pre.c (phi_translate_1): Adjust.\n\t(create_expression_by_pieces): Likewise.\n\t(compute_avail): Likewise.\n\n\t* gcc.dg/tree-ssa/ssa-fre-31.c: New testcase.\n\nFrom-SVN: r178595", "tree": {"sha": "79a6f72b4c729032adb2e9fb056921d1ebcc1a92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79a6f72b4c729032adb2e9fb056921d1ebcc1a92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a7d7f9cf3bc2cacd798cae88a3de28bd1d7259d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a7d7f9cf3bc2cacd798cae88a3de28bd1d7259d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a7d7f9cf3bc2cacd798cae88a3de28bd1d7259d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a7d7f9cf3bc2cacd798cae88a3de28bd1d7259d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0a03460680a09ac9dc7119f569ae9e59d5fc778b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a03460680a09ac9dc7119f569ae9e59d5fc778b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a03460680a09ac9dc7119f569ae9e59d5fc778b"}], "stats": {"total": 356, "additions": 222, "deletions": 134}, "files": [{"sha": "0a59a05fd1d3ed87c1452241285a797dacee267e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a7d7f9cf3bc2cacd798cae88a3de28bd1d7259d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a7d7f9cf3bc2cacd798cae88a3de28bd1d7259d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5a7d7f9cf3bc2cacd798cae88a3de28bd1d7259d", "patch": "@@ -1,3 +1,27 @@\n+2011-09-06  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/48317\n+\t* tree-ssa-sccvn.h (struct vn_nary_op_s): Make op a true\n+\ttrailing array.\n+\t(sizeof_vn_nary_op): New inline function.\n+\t(vn_nary_op_lookup_pieces): Adjust.\n+\t(vn_nary_op_insert_pieces): Likewise.\n+\t* tree-ssa-sccvn.c (vn_nary_op_eq): Also compare the length.\n+\t(init_vn_nary_op_from_pieces): Adjust signature.  Deal with\n+\tany number of operands.\n+\t(vn_nary_length_from_stmt): New function.\n+\t(init_vn_nary_op_from_stmt): Adjust for CONSTRUCTOR handling.\n+\t(vn_nary_op_lookup_pieces): Adjust signature and allocate properly\n+\tsized temporary.\n+\t(vn_nary_op_lookup): Likewise.\n+\t(vn_nary_op_lookup_stmt): Likewise.\n+\t(vn_nary_op_insert_into): Likewise.\n+\t(vn_nary_op_insert_stmt): Likewise.\n+\t(visit_use): Handle CONSTRUCTOR as nary.\n+\t* tree-ssa-pre.c (phi_translate_1): Adjust.\n+\t(create_expression_by_pieces): Likewise.\n+\t(compute_avail): Likewise.\n+\n 2011-09-06  Ira Rosen  <ira.rosen@linaro.org>\n \n \t * config/arm/arm.c (arm_preferred_simd_mode): Check"}, {"sha": "d22fe495d15b1d6cd59907ea00024d3f67a2b607", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a7d7f9cf3bc2cacd798cae88a3de28bd1d7259d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a7d7f9cf3bc2cacd798cae88a3de28bd1d7259d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5a7d7f9cf3bc2cacd798cae88a3de28bd1d7259d", "patch": "@@ -1,3 +1,8 @@\n+2011-09-06  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/48317\n+\t* gcc.dg/tree-ssa/ssa-fre-31.c: New testcase.\n+\n 2011-09-06  Ira Rosen  <ira.rosen@linaro.org>\n \n \t* lib/target-supports.exp (check_effective_target_vect_multiple_sizes):"}, {"sha": "42257cca5ad4b3e922d4869e7feac5d568fd1d0b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-31.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a7d7f9cf3bc2cacd798cae88a3de28bd1d7259d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-31.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a7d7f9cf3bc2cacd798cae88a3de28bd1d7259d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-31.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-31.c?ref=5a7d7f9cf3bc2cacd798cae88a3de28bd1d7259d", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-fre1-details\" } */\n+\n+typedef double d128 __attribute__((vector_size(16)));\n+typedef float f128 __attribute__((vector_size(16)));\n+typedef short s128 __attribute__((vector_size(16)));\n+typedef char c256 __attribute__((vector_size(32)));\n+\n+d128 d;\n+f128 f;\n+s128 s;\n+c256 c;\n+\n+void test1 (double x)\n+{\n+  d = (d128){x + x, x + x};\n+  d = (d128){x + x, x + x};\n+}\n+\n+void test2 (float x)\n+{\n+  f = (f128){x + x, x + x, x + x, x + x};\n+  f = (f128){x + x, x + x, x + x, x + x};\n+}\n+\n+void test3 (short x)\n+{\n+  s = (s128){x + x, x + x, x + x, x + x, x + x, x + x, x + x, x + x};\n+  s = (s128){x + x, x + x, x + x, x + x, x + x, x + x, x + x, x + x};\n+}\n+\n+void test4 (unsigned char x)\n+{\n+  c = (c256){x + x, x + x, x + x, x + x, x + x, x + x, x + x, x + x,\n+      x + x, x + x, x + x, x + x, x + x, x + x, x + x, x + x,\n+      x + x, x + x, x + x, x + x, x + x, x + x, x + x, x + x,\n+      x + x, x + x, x + x, x + x, x + x, x + x, x + x, x + x};\n+  c = (c256){x + x, x + x, x + x, x + x, x + x, x + x, x + x, x + x,\n+      x + x, x + x, x + x, x + x, x + x, x + x, x + x, x + x,\n+      x + x, x + x, x + x, x + x, x + x, x + x, x + x, x + x,\n+      x + x, x + x, x + x, x + x, x + x, x + x, x + x, x + x};\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Replaced \\{\" 4 \"fre1\" } } */\n+/* { dg-final { scan-tree-dump-times \"Deleted redundant store\" 4 \"fre1\" } } */\n+/* { dg-final { cleanup-tree-dump \"fre1\" } } */"}, {"sha": "f69aec0dd4d06c4e4db8ee45b8873a44b23cad6a", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 63, "deletions": 76, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a7d7f9cf3bc2cacd798cae88a3de28bd1d7259d/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a7d7f9cf3bc2cacd798cae88a3de28bd1d7259d/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=5a7d7f9cf3bc2cacd798cae88a3de28bd1d7259d", "patch": "@@ -1443,47 +1443,42 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n \tunsigned int i;\n \tbool changed = false;\n \tvn_nary_op_t nary = PRE_EXPR_NARY (expr);\n-\tstruct vn_nary_op_s newnary;\n-\t/* The NARY structure is only guaranteed to have been\n-\t   allocated to the nary->length operands.  */\n-\tmemcpy (&newnary, nary, (sizeof (struct vn_nary_op_s)\n-\t\t\t\t - sizeof (tree) * (4 - nary->length)));\n+\tvn_nary_op_t newnary = XALLOCAVAR (struct vn_nary_op_s,\n+\t\t\t\t\t   sizeof_vn_nary_op (nary->length));\n+\tmemcpy (newnary, nary, sizeof_vn_nary_op (nary->length));\n \n-\tfor (i = 0; i < newnary.length; i++)\n+\tfor (i = 0; i < newnary->length; i++)\n \t  {\n-\t    if (TREE_CODE (newnary.op[i]) != SSA_NAME)\n+\t    if (TREE_CODE (newnary->op[i]) != SSA_NAME)\n \t      continue;\n \t    else\n \t      {\n                 pre_expr leader, result;\n-\t\tunsigned int op_val_id = VN_INFO (newnary.op[i])->value_id;\n+\t\tunsigned int op_val_id = VN_INFO (newnary->op[i])->value_id;\n \t\tleader = find_leader_in_sets (op_val_id, set1, set2);\n                 result = phi_translate (leader, set1, set2, pred, phiblock);\n \t\tif (result && result != leader)\n \t\t  {\n \t\t    tree name = get_representative_for (result);\n \t\t    if (!name)\n \t\t      return NULL;\n-\t\t    newnary.op[i] = name;\n+\t\t    newnary->op[i] = name;\n \t\t  }\n \t\telse if (!result)\n \t\t  return NULL;\n \n-\t\tchanged |= newnary.op[i] != nary->op[i];\n+\t\tchanged |= newnary->op[i] != nary->op[i];\n \t      }\n \t  }\n \tif (changed)\n \t  {\n \t    pre_expr constant;\n \t    unsigned int new_val_id;\n \n-\t    tree result = vn_nary_op_lookup_pieces (newnary.length,\n-\t\t\t\t\t\t    newnary.opcode,\n-\t\t\t\t\t\t    newnary.type,\n-\t\t\t\t\t\t    newnary.op[0],\n-\t\t\t\t\t\t    newnary.op[1],\n-\t\t\t\t\t\t    newnary.op[2],\n-\t\t\t\t\t\t    newnary.op[3],\n+\t    tree result = vn_nary_op_lookup_pieces (newnary->length,\n+\t\t\t\t\t\t    newnary->opcode,\n+\t\t\t\t\t\t    newnary->type,\n+\t\t\t\t\t\t    &newnary->op[0],\n \t\t\t\t\t\t    &nary);\n \t    if (result && is_gimple_min_invariant (result))\n \t      return get_or_alloc_expr_for_constant (result);\n@@ -1507,13 +1502,10 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n \t\tVEC_safe_grow_cleared (bitmap_set_t, heap,\n \t\t\t\t       value_expressions,\n \t\t\t\t       get_max_value_id() + 1);\n-\t\tnary = vn_nary_op_insert_pieces (newnary.length,\n-\t\t\t\t\t\t newnary.opcode,\n-\t\t\t\t\t\t newnary.type,\n-\t\t\t\t\t\t newnary.op[0],\n-\t\t\t\t\t\t newnary.op[1],\n-\t\t\t\t\t\t newnary.op[2],\n-\t\t\t\t\t\t newnary.op[3],\n+\t\tnary = vn_nary_op_insert_pieces (newnary->length,\n+\t\t\t\t\t\t newnary->opcode,\n+\t\t\t\t\t\t newnary->type,\n+\t\t\t\t\t\t &newnary->op[0],\n \t\t\t\t\t\t result, new_val_id);\n \t\tPRE_EXPR_NARY (expr) = nary;\n \t\tconstant = fully_constant_expression (expr);\n@@ -1708,9 +1700,7 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n \n \t\tnresult = vn_nary_op_lookup_pieces (1, TREE_CODE (result),\n \t\t\t\t\t\t    TREE_TYPE (result),\n-\t\t\t\t\t\t    TREE_OPERAND (result, 0),\n-\t\t\t\t\t\t    NULL_TREE, NULL_TREE,\n-\t\t\t\t\t\t    NULL_TREE,\n+\t\t\t\t\t\t    &TREE_OPERAND (result, 0),\n \t\t\t\t\t\t    &nary);\n \t\tif (nresult && is_gimple_min_invariant (nresult))\n \t\t  return get_or_alloc_expr_for_constant (nresult);\n@@ -1734,9 +1724,8 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n \t\t\t\t\t   get_max_value_id() + 1);\n \t\t    nary = vn_nary_op_insert_pieces (1, TREE_CODE (result),\n \t\t\t\t\t\t     TREE_TYPE (result),\n-\t\t\t\t\t\t     TREE_OPERAND (result, 0),\n-\t\t\t\t\t\t     NULL_TREE, NULL_TREE,\n-\t\t\t\t\t\t     NULL_TREE, NULL_TREE,\n+\t\t\t\t\t\t     &TREE_OPERAND (result, 0),\n+\t\t\t\t\t\t     NULL_TREE,\n \t\t\t\t\t\t     new_val_id);\n \t\t    PRE_EXPR_NARY (expr) = nary;\n \t\t    constant = fully_constant_expression (expr);\n@@ -3087,50 +3076,49 @@ create_expression_by_pieces (basic_block block, pre_expr expr,\n     case NARY:\n       {\n \tvn_nary_op_t nary = PRE_EXPR_NARY (expr);\n-\tswitch (nary->length)\n+\ttree genop[4];\n+\tunsigned i;\n+\tfor (i = 0; i < nary->length; ++i)\n \t  {\n-\t  case 2:\n-\t    {\n-\t      pre_expr op1 = get_or_alloc_expr_for (nary->op[0]);\n-\t      pre_expr op2 = get_or_alloc_expr_for (nary->op[1]);\n-\t      tree genop1 = find_or_generate_expression (block, op1,\n-\t\t\t\t\t\t\t stmts, domstmt);\n-\t      tree genop2 = find_or_generate_expression (block, op2,\n-\t\t\t\t\t\t\t stmts, domstmt);\n-\t      if (!genop1 || !genop2)\n-\t\treturn NULL_TREE;\n-\t      /* Ensure op2 is a ptrofftype for POINTER_PLUS_EXPR.  It\n-\t\t may be a constant with the wrong type.  */\n-\t      if (nary->opcode == POINTER_PLUS_EXPR)\n-\t\t{\n-\t\t  genop1 = fold_convert (nary->type, genop1);\n-\t\t  genop2 = convert_to_ptrofftype (genop2);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  genop1 = fold_convert (TREE_TYPE (nary->op[0]), genop1);\n-\t\t  genop2 = fold_convert (TREE_TYPE (nary->op[1]), genop2);\n-\t\t}\n-\n-\t      folded = fold_build2 (nary->opcode, nary->type,\n-\t\t\t\t    genop1, genop2);\n-\t    }\n-\t    break;\n-\t  case 1:\n-\t    {\n-\t      pre_expr op1 = get_or_alloc_expr_for (nary->op[0]);\n-\t      tree genop1 = find_or_generate_expression (block, op1,\n-\t\t\t\t\t\t\t stmts, domstmt);\n-\t      if (!genop1)\n-\t\treturn NULL_TREE;\n-\t      genop1 = fold_convert (TREE_TYPE (nary->op[0]), genop1);\n-\n-\t      folded = fold_build1 (nary->opcode, nary->type,\n-\t\t\t\t    genop1);\n-\t    }\n-\t    break;\n-\t  default:\n-\t    return NULL_TREE;\n+\t    pre_expr op = get_or_alloc_expr_for (nary->op[i]);\n+\t    genop[i] = find_or_generate_expression (block, op,\n+\t\t\t\t\t\t    stmts, domstmt);\n+\t    if (!genop[i])\n+\t      return NULL_TREE;\n+\t    /* Ensure genop[1] is a ptrofftype for POINTER_PLUS_EXPR.  It\n+\t       may be a constant with the wrong type.  */\n+\t    if (i == 1\n+\t\t&& nary->opcode == POINTER_PLUS_EXPR)\n+\t      genop[i] = convert_to_ptrofftype (genop[i]);\n+\t    else\n+\t      genop[i] = fold_convert (TREE_TYPE (nary->op[i]), genop[i]);\n+\t  }\n+\tif (nary->opcode == CONSTRUCTOR)\n+\t  {\n+\t    VEC(constructor_elt,gc) *elts = NULL;\n+\t    for (i = 0; i < nary->length; ++i)\n+\t      CONSTRUCTOR_APPEND_ELT (elts, NULL_TREE, genop[i]);\n+\t    folded = build_constructor (nary->type, elts);\n+\t  }\n+\telse\n+\t  {\n+\t    switch (nary->length)\n+\t      {\n+\t      case 1:\n+\t\tfolded = fold_build1 (nary->opcode, nary->type,\n+\t\t\t\t      genop[0]);\n+\t\tbreak;\n+\t      case 2:\n+\t\tfolded = fold_build2 (nary->opcode, nary->type,\n+\t\t\t\t      genop[0], genop[1]);\n+\t\tbreak;\n+\t      case 3:\n+\t\tfolded = fold_build3 (nary->opcode, nary->type,\n+\t\t\t\t      genop[0], genop[1], genop[3]);\n+\t\tbreak;\n+\t      default:\n+\t\tgcc_unreachable ();\n+\t      }\n \t  }\n       }\n       break;\n@@ -4053,9 +4041,8 @@ compute_avail (void)\n \t\t      vn_nary_op_lookup_pieces (gimple_num_ops (stmt) - 1,\n \t\t\t\t\t\tgimple_assign_rhs_code (stmt),\n \t\t\t\t\t\tgimple_expr_type (stmt),\n-\t\t\t\t\t\tgimple_assign_rhs1 (stmt),\n-\t\t\t\t\t\tgimple_assign_rhs2 (stmt),\n-\t\t\t\t\t\tNULL_TREE, NULL_TREE, &nary);\n+\t\t\t\t\t\tgimple_assign_rhs1_ptr (stmt),\n+\t\t\t\t\t\t&nary);\n \n \t\t      if (!nary)\n \t\t\tcontinue;"}, {"sha": "aeb2e0831417faf846b7709e922f646f01bca7b0", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 73, "deletions": 53, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a7d7f9cf3bc2cacd798cae88a3de28bd1d7259d/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a7d7f9cf3bc2cacd798cae88a3de28bd1d7259d/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=5a7d7f9cf3bc2cacd798cae88a3de28bd1d7259d", "patch": "@@ -1923,6 +1923,9 @@ vn_nary_op_eq (const void *p1, const void *p2)\n   if (vno1->hashcode != vno2->hashcode)\n     return false;\n \n+  if (vno1->length != vno2->length)\n+    return false;\n+\n   if (vno1->opcode != vno2->opcode\n       || !types_compatible_p (vno1->type, vno2->type))\n     return false;\n@@ -1938,22 +1941,12 @@ vn_nary_op_eq (const void *p1, const void *p2)\n \n static void\n init_vn_nary_op_from_pieces (vn_nary_op_t vno, unsigned int length,\n-\t\t\t     enum tree_code code, tree type, tree op0,\n-\t\t\t     tree op1, tree op2, tree op3)\n+\t\t\t     enum tree_code code, tree type, tree *ops)\n {\n   vno->opcode = code;\n   vno->length = length;\n   vno->type = type;\n-  switch (length)\n-    {\n-      /* The fallthrus here are deliberate.  */\n-    case 4: vno->op[3] = op3;\n-    case 3: vno->op[2] = op2;\n-    case 2: vno->op[1] = op1;\n-    case 1: vno->op[0] = op0;\n-    default:\n-      break;\n-    }\n+  memcpy (&vno->op[0], ops, sizeof (tree) * length);\n }\n \n /* Initialize VNO from OP.  */\n@@ -1970,6 +1963,26 @@ init_vn_nary_op_from_op (vn_nary_op_t vno, tree op)\n     vno->op[i] = TREE_OPERAND (op, i);\n }\n \n+/* Return the number of operands for a vn_nary ops structure from STMT.  */\n+\n+static unsigned int\n+vn_nary_length_from_stmt (gimple stmt)\n+{\n+  switch (gimple_assign_rhs_code (stmt))\n+    {\n+    case REALPART_EXPR:\n+    case IMAGPART_EXPR:\n+    case VIEW_CONVERT_EXPR:\n+      return 1;\n+\n+    case CONSTRUCTOR:\n+      return CONSTRUCTOR_NELTS (gimple_assign_rhs1 (stmt));\n+\n+    default:\n+      return gimple_num_ops (stmt) - 1;\n+    }\n+}\n+\n /* Initialize VNO from STMT.  */\n \n static void\n@@ -1978,14 +1991,27 @@ init_vn_nary_op_from_stmt (vn_nary_op_t vno, gimple stmt)\n   unsigned i;\n \n   vno->opcode = gimple_assign_rhs_code (stmt);\n-  vno->length = gimple_num_ops (stmt) - 1;\n   vno->type = gimple_expr_type (stmt);\n-  for (i = 0; i < vno->length; ++i)\n-    vno->op[i] = gimple_op (stmt, i + 1);\n-  if (vno->opcode == REALPART_EXPR\n-      || vno->opcode == IMAGPART_EXPR\n-      || vno->opcode == VIEW_CONVERT_EXPR)\n-    vno->op[0] = TREE_OPERAND (vno->op[0], 0);\n+  switch (vno->opcode)\n+    {\n+    case REALPART_EXPR:\n+    case IMAGPART_EXPR:\n+    case VIEW_CONVERT_EXPR:\n+      vno->length = 1;\n+      vno->op[0] = TREE_OPERAND (gimple_assign_rhs1 (stmt), 0);\n+      break;\n+\n+    case CONSTRUCTOR:\n+      vno->length = CONSTRUCTOR_NELTS (gimple_assign_rhs1 (stmt));\n+      for (i = 0; i < vno->length; ++i)\n+\tvno->op[i] = CONSTRUCTOR_ELT (gimple_assign_rhs1 (stmt), i)->value;\n+      break;\n+\n+    default:\n+      vno->length = gimple_num_ops (stmt) - 1;\n+      for (i = 0; i < vno->length; ++i)\n+\tvno->op[i] = gimple_op (stmt, i + 1);\n+    }\n }\n \n /* Compute the hashcode for VNO and look for it in the hash table;\n@@ -2023,12 +2049,12 @@ vn_nary_op_lookup_1 (vn_nary_op_t vno, vn_nary_op_t *vnresult)\n \n tree\n vn_nary_op_lookup_pieces (unsigned int length, enum tree_code code,\n-\t\t\t  tree type, tree op0, tree op1, tree op2,\n-\t\t\t  tree op3, vn_nary_op_t *vnresult)\n+\t\t\t  tree type, tree *ops, vn_nary_op_t *vnresult)\n {\n-  struct vn_nary_op_s vno1;\n-  init_vn_nary_op_from_pieces (&vno1, length, code, type, op0, op1, op2, op3);\n-  return vn_nary_op_lookup_1 (&vno1, vnresult);\n+  vn_nary_op_t vno1 = XALLOCAVAR (struct vn_nary_op_s,\n+\t\t\t\t  sizeof_vn_nary_op (length));\n+  init_vn_nary_op_from_pieces (vno1, length, code, type, ops);\n+  return vn_nary_op_lookup_1 (vno1, vnresult);\n }\n \n /* Lookup OP in the current hash table, and return the resulting value\n@@ -2040,9 +2066,11 @@ vn_nary_op_lookup_pieces (unsigned int length, enum tree_code code,\n tree\n vn_nary_op_lookup (tree op, vn_nary_op_t *vnresult)\n {\n-  struct vn_nary_op_s vno1;\n-  init_vn_nary_op_from_op (&vno1, op);\n-  return vn_nary_op_lookup_1 (&vno1, vnresult);\n+  vn_nary_op_t vno1\n+    = XALLOCAVAR (struct vn_nary_op_s,\n+\t\t  sizeof_vn_nary_op (TREE_CODE_LENGTH (TREE_CODE (op))));\n+  init_vn_nary_op_from_op (vno1, op);\n+  return vn_nary_op_lookup_1 (vno1, vnresult);\n }\n \n /* Lookup the rhs of STMT in the current hash table, and return the resulting\n@@ -2053,17 +2081,11 @@ vn_nary_op_lookup (tree op, vn_nary_op_t *vnresult)\n tree\n vn_nary_op_lookup_stmt (gimple stmt, vn_nary_op_t *vnresult)\n {\n-  struct vn_nary_op_s vno1;\n-  init_vn_nary_op_from_stmt (&vno1, stmt);\n-  return vn_nary_op_lookup_1 (&vno1, vnresult);\n-}\n-\n-/* Return the size of a vn_nary_op_t with LENGTH operands.  */\n-\n-static size_t\n-sizeof_vn_nary_op (unsigned int length)\n-{\n-  return sizeof (struct vn_nary_op_s) - sizeof (tree) * (4 - length);\n+  vn_nary_op_t vno1\n+    = XALLOCAVAR (struct vn_nary_op_s,\n+\t\t  sizeof_vn_nary_op (vn_nary_length_from_stmt (stmt)));\n+  init_vn_nary_op_from_stmt (vno1, stmt);\n+  return vn_nary_op_lookup_1 (vno1, vnresult);\n }\n \n /* Allocate a vn_nary_op_t with LENGTH operands on STACK.  */\n@@ -2114,15 +2136,11 @@ vn_nary_op_insert_into (vn_nary_op_t vno, htab_t table, bool compute_hash)\n \n vn_nary_op_t\n vn_nary_op_insert_pieces (unsigned int length, enum tree_code code,\n-\t\t\t  tree type, tree op0,\n-\t\t\t  tree op1, tree op2, tree op3,\n-\t\t\t  tree result,\n-\t\t\t  unsigned int value_id)\n+\t\t\t  tree type, tree *ops,\n+\t\t\t  tree result, unsigned int value_id)\n {\n-  vn_nary_op_t vno1;\n-\n-  vno1 = alloc_vn_nary_op (length, result, value_id);\n-  init_vn_nary_op_from_pieces (vno1, length, code, type, op0, op1, op2, op3);\n+  vn_nary_op_t vno1 = alloc_vn_nary_op (length, result, value_id);\n+  init_vn_nary_op_from_pieces (vno1, length, code, type, ops);\n   return vn_nary_op_insert_into (vno1, current_info->nary, true);\n }\n \n@@ -2147,10 +2165,9 @@ vn_nary_op_insert (tree op, tree result)\n vn_nary_op_t\n vn_nary_op_insert_stmt (gimple stmt, tree result)\n {\n-  unsigned length = gimple_num_ops (stmt) - 1;\n-  vn_nary_op_t vno1;\n-\n-  vno1 = alloc_vn_nary_op (length, result, VN_INFO (result)->value_id);\n+  vn_nary_op_t vno1\n+    = alloc_vn_nary_op (vn_nary_length_from_stmt (stmt),\n+\t\t\tresult, VN_INFO (result)->value_id);\n   init_vn_nary_op_from_stmt (vno1, stmt);\n   return vn_nary_op_insert_into (vno1, current_info->nary, true);\n }\n@@ -3171,14 +3188,17 @@ visit_use (tree use)\n \t\t\tcase tcc_declaration:\n \t\t\t  changed = visit_reference_op_load (lhs, rhs1, stmt);\n \t\t\t  break;\n-\t\t\tcase tcc_expression:\n+\t\t\tdefault:\n \t\t\t  if (code == ADDR_EXPR)\n \t\t\t    {\n \t\t\t      changed = visit_nary_op (lhs, stmt);\n \t\t\t      break;\n \t\t\t    }\n-\t\t\t  /* Fallthrough.  */\n-\t\t\tdefault:\n+\t\t\t  else if (code == CONSTRUCTOR)\n+\t\t\t    {\n+\t\t\t      changed = visit_nary_op (lhs, stmt);\n+\t\t\t      break;\n+\t\t\t    }\n \t\t\t  changed = defs_to_varying (stmt);\n \t\t\t}\n \t\t      break;"}, {"sha": "97d7f8f39213e84c5d97a7bd3706415669cdcec7", "filename": "gcc/tree-ssa-sccvn.h", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a7d7f9cf3bc2cacd798cae88a3de28bd1d7259d/gcc%2Ftree-ssa-sccvn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a7d7f9cf3bc2cacd798cae88a3de28bd1d7259d/gcc%2Ftree-ssa-sccvn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.h?ref=5a7d7f9cf3bc2cacd798cae88a3de28bd1d7259d", "patch": "@@ -42,10 +42,18 @@ typedef struct vn_nary_op_s\n   hashval_t hashcode;\n   tree result;\n   tree type;\n-  tree op[4];\n+  tree op[1];\n } *vn_nary_op_t;\n typedef const struct vn_nary_op_s *const_vn_nary_op_t;\n \n+/* Return the size of a vn_nary_op_t with LENGTH operands.  */\n+\n+static inline size_t\n+sizeof_vn_nary_op (unsigned int length)\n+{\n+  return sizeof (struct vn_nary_op_s) + sizeof (tree) * (length - 1);\n+}\n+\n /* Phi nodes in the hashtable consist of their non-VN_TOP phi\n    arguments, and the basic block the phi is in. Result is the value\n    number of the operation, and hashcode is stored to avoid having to\n@@ -176,13 +184,11 @@ void free_scc_vn (void);\n tree vn_nary_op_lookup (tree, vn_nary_op_t *);\n tree vn_nary_op_lookup_stmt (gimple, vn_nary_op_t *);\n tree vn_nary_op_lookup_pieces (unsigned int, enum tree_code,\n-\t\t\t       tree, tree, tree, tree, tree,\n-\t\t\t       vn_nary_op_t *);\n+\t\t\t       tree, tree *, vn_nary_op_t *);\n vn_nary_op_t vn_nary_op_insert (tree, tree);\n vn_nary_op_t vn_nary_op_insert_stmt (gimple, tree);\n vn_nary_op_t vn_nary_op_insert_pieces (unsigned int, enum tree_code,\n-\t\t\t\t       tree, tree, tree, tree,\n-\t\t\t\t       tree, tree, unsigned int);\n+\t\t\t\t       tree, tree *, tree, unsigned int);\n void vn_reference_fold_indirect (VEC (vn_reference_op_s, heap) **,\n \t\t\t\t unsigned int *);\n void copy_reference_ops_from_ref (tree, VEC(vn_reference_op_s, heap) **);"}]}