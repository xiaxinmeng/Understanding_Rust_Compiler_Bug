{"sha": "8d2af3a25bdb6b7996e0a55551ae0fd599e1739b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQyYWYzYTI1YmRiNmI3OTk2ZTBhNTU1NTFhZTBmZDU5OWUxNzM5Yg==", "commit": {"author": {"name": "Dimitar Dimitrov", "email": "dimitar@dinux.eu", "date": "2019-06-12T19:04:24Z"}, "committer": {"name": "Dimitar Dimitrov", "email": "dimitar@gcc.gnu.org", "date": "2019-06-12T19:04:24Z"}, "message": "Initial TI PRU GCC port\n\nChangeLog:\n\n2019-06-19  Dimitar Dimitrov  <dimitar@dinux.eu>\n\n\t* configure: Regenerate.\n\t* configure.ac: Add PRU target.\n\ngcc/ChangeLog:\n\n2019-06-19  Dimitar Dimitrov  <dimitar@dinux.eu>\n\n\t* common/config/pru/pru-common.c: New file.\n\t* config.gcc: Add PRU target.\n\t* config/pru/alu-zext.md: New file.\n\t* config/pru/constraints.md: New file.\n\t* config/pru/predicates.md: New file.\n\t* config/pru/pru-opts.h: New file.\n\t* config/pru/pru-passes.c: New file.\n\t* config/pru/pru-pragma.c: New file.\n\t* config/pru/pru-protos.h: New file.\n\t* config/pru/pru.c: New file.\n\t* config/pru/pru.h: New file.\n\t* config/pru/pru.md: New file.\n\t* config/pru/pru.opt: New file.\n\t* config/pru/t-pru: New file.\n\t* doc/extend.texi: Document PRU pragmas.\n\t* doc/invoke.texi: Document PRU-specific options.\n\t* doc/md.texi: Document PRU asm constraints.\n\nFrom-SVN: r272202", "tree": {"sha": "c1b54695d64b2c8b3283bf25d00ccb3bfcdcd93a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1b54695d64b2c8b3283bf25d00ccb3bfcdcd93a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/comments", "author": null, "committer": null, "parents": [{"sha": "974b8e618b52dd1d30ca067e75995fe9fc8e6895", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/974b8e618b52dd1d30ca067e75995fe9fc8e6895", "html_url": "https://github.com/Rust-GCC/gccrs/commit/974b8e618b52dd1d30ca067e75995fe9fc8e6895"}], "stats": {"total": 5898, "additions": 5898, "deletions": 0}, "files": [{"sha": "ec8a76cbddd085931b6bd9601e3451685ef4dd48", "filename": "ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=8d2af3a25bdb6b7996e0a55551ae0fd599e1739b", "patch": "@@ -1,3 +1,8 @@\n+2019-06-19  Dimitar Dimitrov  <dimitar@dinux.eu>\n+\n+\t* configure: Regenerate.\n+\t* configure.ac: Add PRU target.\n+\n 2019-06-11 \u00a0Matthew Beliveau \u00a0<mbelivea@redhat.com>\n \n \t* MAINTAINERS (Write After Approval): Add myself."}, {"sha": "17d7e0a7da31a5d14a03bd69d3d6f2b421ea1da6", "filename": "configure", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=8d2af3a25bdb6b7996e0a55551ae0fd599e1739b", "patch": "@@ -3356,6 +3356,10 @@ case \"${target}\" in\n   powerpc-*-aix* | rs6000-*-aix*)\n     noconfigdirs=\"$noconfigdirs target-libssp\"\n     ;;\n+  pru-*-*)\n+    # No hosted I/O support.\n+    noconfigdirs=\"$noconfigdirs target-libssp\"\n+    ;;\n   rl78-*-*)\n     # libssp uses a misaligned load to trigger a fault, but the RL78\n     # doesn't fault for those - instead, it gives a build-time error\n@@ -3574,6 +3578,9 @@ case \"${target}\" in\n   powerpc*-*-*)\n     libgloss_dir=rs6000\n     ;;\n+  pru-*-*)\n+    libgloss_dir=pru\n+    ;;\n   sparc*-*-*)\n     libgloss_dir=sparc\n     ;;"}, {"sha": "5f02008dd1596ee2900cfea54ca34c3d1ab74bbb", "filename": "configure.ac", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=8d2af3a25bdb6b7996e0a55551ae0fd599e1739b", "patch": "@@ -641,6 +641,10 @@ case \"${target}\" in\n   powerpc-*-aix* | rs6000-*-aix*)\n     noconfigdirs=\"$noconfigdirs target-libssp\"\n     ;;\n+  pru-*-*)\n+    # No hosted I/O support.\n+    noconfigdirs=\"$noconfigdirs target-libssp\"\n+    ;;\n   rl78-*-*)\n     # libssp uses a misaligned load to trigger a fault, but the RL78\n     # doesn't fault for those - instead, it gives a build-time error\n@@ -856,6 +860,9 @@ case \"${target}\" in\n   powerpc*-*-*)\n     libgloss_dir=rs6000\n     ;;\n+  pru-*-*)\n+    libgloss_dir=pru\n+    ;;\n   sparc*-*-*)\n     libgloss_dir=sparc\n     ;;"}, {"sha": "e28cbef44edd5636eca945e54d559b435b5d416a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8d2af3a25bdb6b7996e0a55551ae0fd599e1739b", "patch": "@@ -1,3 +1,23 @@\n+2019-06-19  Dimitar Dimitrov  <dimitar@dinux.eu>\n+\n+\t* common/config/pru/pru-common.c: New file.\n+\t* config.gcc: Add PRU target.\n+\t* config/pru/alu-zext.md: New file.\n+\t* config/pru/constraints.md: New file.\n+\t* config/pru/predicates.md: New file.\n+\t* config/pru/pru-opts.h: New file.\n+\t* config/pru/pru-passes.c: New file.\n+\t* config/pru/pru-pragma.c: New file.\n+\t* config/pru/pru-protos.h: New file.\n+\t* config/pru/pru.c: New file.\n+\t* config/pru/pru.h: New file.\n+\t* config/pru/pru.md: New file.\n+\t* config/pru/pru.opt: New file.\n+\t* config/pru/t-pru: New file.\n+\t* doc/extend.texi: Document PRU pragmas.\n+\t* doc/invoke.texi: Document PRU-specific options.\n+\t* doc/md.texi: Document PRU asm constraints.\n+\n 2019-06-12  Martin Sebor  <msebor@redhat.com>\n \n \tPR middle-end/90676"}, {"sha": "7d1e934b13334f3409f375f346b66c38ac900cf6", "filename": "gcc/common/config/pru/pru-common.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fcommon%2Fconfig%2Fpru%2Fpru-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fcommon%2Fconfig%2Fpru%2Fpru-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fpru%2Fpru-common.c?ref=8d2af3a25bdb6b7996e0a55551ae0fd599e1739b", "patch": "@@ -0,0 +1,36 @@\n+/* Common hooks for TI PRU\n+   Copyright (C) 2014-2019 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"diagnostic-core.h\"\n+#include \"tm.h\"\n+#include \"common/common-target.h\"\n+#include \"common/common-target-def.h\"\n+#include \"opts.h\"\n+#include \"flags.h\"\n+\n+#undef TARGET_DEFAULT_TARGET_FLAGS\n+#define TARGET_DEFAULT_TARGET_FLAGS\t\t(MASK_OPT_LOOP)\n+\n+#undef TARGET_EXCEPT_UNWIND_INFO\n+#define TARGET_EXCEPT_UNWIND_INFO sjlj_except_unwind_info\n+\n+struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;"}, {"sha": "48e6bb70e40ca0542718be21d6059b06b680104e", "filename": "gcc/config.gcc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=8d2af3a25bdb6b7996e0a55551ae0fd599e1739b", "patch": "@@ -514,6 +514,9 @@ powerpc*-*-*)\n \tesac\n \textra_options=\"${extra_options} g.opt fused-madd.opt rs6000/rs6000-tables.opt\"\n \t;;\n+pru-*-*)\n+\tcpu_type=pru\n+\t;;\n riscv*)\n \tcpu_type=riscv\n \textra_objs=\"riscv-builtins.o riscv-c.o\"\n@@ -2764,6 +2767,12 @@ powerpcle-*-eabi*)\n \textra_options=\"${extra_options} rs6000/sysv4.opt\"\n \tuse_gcc_stdint=wrap\n \t;;\n+pru*-*-*)\n+\ttm_file=\"elfos.h newlib-stdint.h ${tm_file}\"\n+\ttmake_file=\"${tmake_file} pru/t-pru\"\n+\textra_objs=\"pru-pragma.o pru-passes.o\"\n+\tuse_gcc_stdint=wrap\n+\t;;\n rs6000-ibm-aix6.* | powerpc-ibm-aix6.*)\n \ttm_file=\"${tm_file} rs6000/aix.h rs6000/aix61.h rs6000/xcoff.h rs6000/aix-stdint.h\"\n \ttmake_file=\"rs6000/t-aix52 t-slibgcc\""}, {"sha": "80e24d59fedadb1c2b3c88d658596b057a417d15", "filename": "gcc/config/pru/alu-zext.md", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fconfig%2Fpru%2Falu-zext.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fconfig%2Fpru%2Falu-zext.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Falu-zext.md?ref=8d2af3a25bdb6b7996e0a55551ae0fd599e1739b", "patch": "@@ -0,0 +1,181 @@\n+;; ALU operations with zero extensions\n+;;\n+;; Copyright (C) 2015-2019 Free Software Foundation, Inc.\n+;; Contributed by Dimitar Dimitrov <dimitar@dinux.eu>\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+; All PRU ALU instructions automatically zero-extend their source operands,\n+; and zero-extract the result into the destination register.  This is\n+; described in the machine description by defining a separate pattern\n+; for each possible combination of zero_extend and mode for input operands.\n+;\n+; An unfortunate side effect is that quite a few invalid RTL patterns are\n+; generated.  For example:\n+;      ... (zero_extend:SI (match_operand:SI ...)) ...\n+; These patterns are harmless since no pass should generate such RTL.  This\n+; shortcut allows us to keep small and concise machine description patterns.\n+\n+\n+(define_subst_attr \"alu2_zext\"     \"alu2_zext_subst\"     \"_z\" \"_noz\")\n+\n+(define_subst_attr \"alu3_zext_op1\" \"alu3_zext_op1_subst\" \"_z1\" \"_noz1\")\n+(define_subst_attr \"alu3_zext_op2\" \"alu3_zext_op2_subst\" \"_z2\" \"_noz2\")\n+(define_subst_attr \"alu3_zext\"     \"alu3_zext_subst\"     \"_z\" \"_noz\")\n+\n+(define_subst_attr \"bitalu_zext\"   \"bitalu_zext_subst\"   \"_z\" \"_noz\")\n+\n+(define_code_iterator ALUOP3 [plus minus and ior xor umin umax ashift lshiftrt])\n+(define_code_iterator ALUOP2 [neg not])\n+\n+;; Arithmetic Operations\n+\n+(define_insn \"add_impl<EQD:mode><EQS0:mode><EQS1:mode>_<alu3_zext><alu3_zext_op1><alu3_zext_op2>\"\n+  [(set (match_operand:EQD 0 \"register_operand\" \"=r,r,r\")\n+\t(plus:EQD\n+\t (zero_extend:EQD\n+\t  (match_operand:EQS0 1 \"register_operand\" \"%r,r,r\"))\n+\t (zero_extend:EQD\n+\t  (match_operand:EQS1 2 \"nonmemory_operand\" \"r,<EQS1:ubyte_constr>,M\"))))]\n+  \"\"\n+  \"@\n+   add\\\\t%0, %1, %2\n+   add\\\\t%0, %1, %u2\n+   sub\\\\t%0, %1, %n2\"\n+  [(set_attr \"type\" \"alu\")])\n+\n+(define_insn \"sub_impl<EQD:mode><EQS0:mode><EQS1:mode>_<alu3_zext><alu3_zext_op1><alu3_zext_op2>\"\n+  [(set (match_operand:EQD 0 \"register_operand\" \"=r,r\")\n+\t(minus:EQD\n+\t (zero_extend:EQD\n+\t  (match_operand:EQS0 1 \"reg_or_ubyte_operand\" \"r,<EQS0:ubyte_constr>\"))\n+\t (zero_extend:EQD\n+\t  (match_operand:EQS1 2 \"register_operand\" \"r,r\"))))]\n+  \"\"\n+  \"@\n+   sub\\\\t%0, %1, %2\n+   rsb\\\\t%0, %2, %u1\"\n+  [(set_attr \"type\" \"alu\")])\n+\n+\n+(define_insn \"neg_impl<EQD:mode><EQS0:mode>_<alu2_zext>\"\n+  [(set (match_operand:EQD 0 \"register_operand\" \"=r\")\n+\t(neg:EQD\n+\t  (zero_extend:EQD (match_operand:EQS0 1 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"rsb\\\\t%0, %1, 0\"\n+  [(set_attr \"type\" \"alu\")])\n+\n+\n+(define_insn \"one_cmpl_impl<EQD:mode><EQS0:mode>_<alu2_zext>\"\n+  [(set (match_operand:EQD 0 \"register_operand\" \"=r\")\n+\t(not:EQD\n+\t  (zero_extend:EQD (match_operand:EQS0 1 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"not\\\\t%0, %1\"\n+  [(set_attr \"type\" \"alu\")])\n+\n+; Specialized IOR/AND patterns for matching setbit/clearbit instructions.\n+;\n+; TODO - allow clrbit and setbit to support (1 << REG) constructs\n+\n+(define_insn \"clearbit_<EQD:mode><EQS0:mode>_<bitalu_zext>\"\n+  [(set (match_operand:EQD 0 \"register_operand\" \"=r\")\n+\t(and:EQD\n+\t  (zero_extend:EQD\n+\t    (match_operand:EQS0 1 \"register_operand\" \"r\"))\n+\t  (match_operand:EQD 2 \"single_zero_operand\" \"n\")))]\n+  \"\"\n+  \"clr\\\\t%0, %1, %V2\"\n+  [(set_attr \"type\" \"alu\")])\n+\n+(define_insn \"setbit_<EQD:mode><EQS0:mode>_<bitalu_zext>\"\n+  [(set (match_operand:EQD 0 \"register_operand\" \"=r\")\n+\t(ior:EQD\n+\t  (zero_extend:EQD\n+\t    (match_operand:EQS0 1 \"register_operand\" \"r\"))\n+\t  (match_operand:EQD 2 \"single_one_operand\" \"n\")))]\n+  \"\"\n+  \"set\\\\t%0, %1, %T2\"\n+  [(set_attr \"type\" \"alu\")])\n+\n+; Regular ALU ops\n+(define_insn \"<code>_impl<EQD:mode><EQS0:mode><EQS1:mode>_<alu3_zext><alu3_zext_op1><alu3_zext_op2>\"\n+  [(set (match_operand:EQD 0 \"register_operand\" \"=r\")\n+\t(LOGICAL:EQD\n+\t  (zero_extend:EQD\n+\t    (match_operand:EQS0 1 \"register_operand\" \"%r\"))\n+\t  (zero_extend:EQD\n+\t    (match_operand:EQS1 2 \"reg_or_ubyte_operand\" \"r<EQS1:ubyte_constr>\"))))]\n+  \"\"\n+  \"<logical_asm>\\\\t%0, %1, %u2\"\n+  [(set_attr \"type\" \"alu\")])\n+\n+; Shift ALU ops\n+(define_insn \"<shift_op>_impl<EQD:mode><EQS0:mode><EQS1:mode>_<alu3_zext><alu3_zext_op1><alu3_zext_op2>\"\n+  [(set (match_operand:EQD 0 \"register_operand\" \"=r\")\n+\t(SHIFT:EQD\n+\t (zero_extend:EQD (match_operand:EQS0 1 \"register_operand\" \"r\"))\n+\t (zero_extend:EQD (match_operand:EQS1 2 \"shift_operand\" \"rL\"))))]\n+  \"\"\n+  \"<shift_asm>\\\\t%0, %1, %2\"\n+  [(set_attr \"type\" \"alu\")])\n+\n+;; Substitutions\n+\n+(define_subst \"alu2_zext_subst\"\n+  [(set (match_operand:EQD 0)\n+\t(ALUOP2:EQD (zero_extend:EQD (match_operand:EQD 1))))]\n+  \"\"\n+  [(set (match_dup 0)\n+\t(ALUOP2:EQD (match_dup 1)))])\n+\n+(define_subst \"bitalu_zext_subst\"\n+  [(set (match_operand:EQD 0)\n+\t(ALUOP3:EQD (zero_extend:EQD (match_operand:EQD 1))\n+\t\t    (match_operand:EQD 2)))]\n+  \"\"\n+  [(set (match_dup 0)\n+\t(ALUOP3:EQD (match_dup 1)\n+\t\t    (match_dup 2)))])\n+\n+(define_subst \"alu3_zext_subst\"\n+  [(set (match_operand:EQD 0)\n+\t(ALUOP3:EQD (zero_extend:EQD (match_operand:EQD 1))\n+\t\t    (zero_extend:EQD (match_operand:EQD 2))))]\n+  \"\"\n+  [(set (match_dup 0)\n+\t(ALUOP3:EQD (match_dup 1)\n+\t\t    (match_dup 2)))])\n+\n+(define_subst \"alu3_zext_op1_subst\"\n+  [(set (match_operand:EQD 0)\n+\t(ALUOP3:EQD (zero_extend:EQD (match_operand:EQD 1))\n+\t\t    (zero_extend:EQD (match_operand:EQS1 2))))]\n+  \"\"\n+  [(set (match_dup 0)\n+\t(ALUOP3:EQD (match_dup 1)\n+\t\t    (zero_extend:EQD (match_dup 2))))])\n+\n+(define_subst \"alu3_zext_op2_subst\"\n+  [(set (match_operand:EQD 0)\n+\t(ALUOP3:EQD (zero_extend:EQD (match_operand:EQS0 1))\n+\t\t    (zero_extend:EQD (match_operand:EQD 2))))]\n+  \"\"\n+  [(set (match_dup 0)\n+\t(ALUOP3:EQD (zero_extend:EQD (match_dup 1))\n+\t\t    (match_dup 2)))])"}, {"sha": "c8856d112cbb4dc4da199ef13ad9cf4ee3fe5ee0", "filename": "gcc/config/pru/constraints.md", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fconfig%2Fpru%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fconfig%2Fpru%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fconstraints.md?ref=8d2af3a25bdb6b7996e0a55551ae0fd599e1739b", "patch": "@@ -0,0 +1,108 @@\n+;; Constraint definitions for TI PRU.\n+;; Copyright (C) 2014-2019 Free Software Foundation, Inc.\n+;; Contributed by Dimitar Dimitrov <dimitar@dinux.eu>\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; We use the following constraint letters for constants:\n+;;\n+;;  I: 0 to 255.\n+;;  J: 0 to 65535.\n+;;  L: 0 to 31 (for shift counts).\n+;;  T: Text segment label.  Needed to know when to select %pmem relocation.\n+;;  Z: Constant integer zero.\n+;;\n+;; We use the following built-in register classes:\n+;;\n+;;  r: General purpose register (r0..r31).\n+;;  m: Memory operand.\n+;;\n+;; The following constraints are intended for internal use only:\n+;;  Rmd0, Rms0, Rms1: Registers for MUL instruction operands.\n+;;  Rsib: Jump address register suitable for sibling calls.\n+;;  M: -255 to 0 (for converting ADD to SUB with suitable UBYTE OP2).\n+;;  N: -32768 to 32767 (16-bit signed integer).\n+;;  O: -128 to 127 (8-bit signed integer).\n+;;  P: 1\n+\n+;; Register constraints.\n+\n+(define_register_constraint \"Rsib\" \"SIB_REGS\"\n+  \"@internal\n+  A register suitable for an indirect sibcall.\")\n+\n+(define_register_constraint \"Rmd0\" \"MULDST_REGS\"\n+  \"@internal\n+  The multiply destination register.\")\n+\n+(define_register_constraint \"Rms0\" \"MULSRC0_REGS\"\n+  \"@internal\n+  The multiply source 0 register.\")\n+\n+(define_register_constraint \"Rms1\" \"MULSRC1_REGS\"\n+  \"@internal\n+  The multiply source 1 register.\")\n+\n+;; Integer constraints.\n+\n+(define_constraint \"I\"\n+  \"An unsigned 8-bit constant.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"UBYTE_INT (ival)\")))\n+\n+(define_constraint \"J\"\n+  \"An unsigned 16-bit constant.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"UHWORD_INT (ival)\")))\n+\n+(define_constraint \"L\"\n+  \"An unsigned 5-bit constant (for shift counts).\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= 0 && ival <= 31\")))\n+\n+(define_constraint \"M\"\n+  \"@internal\n+  A constant in the range [-255, 0].\"\n+  (and (match_code \"const_int\")\n+       (match_test \"UBYTE_INT (-ival)\")))\n+\n+(define_constraint \"N\"\n+  \"@internal\n+  A constant in the range [-32768, 32767].\"\n+  (and (match_code \"const_int\")\n+       (match_test \"SHWORD_INT (ival)\")))\n+\n+(define_constraint \"O\"\n+  \"@internal\n+  A constant in the range [-128, 127].\"\n+  (and (match_code \"const_int\")\n+       (match_test \"SBYTE_INT (ival)\")))\n+\n+(define_constraint \"P\"\n+  \"@internal\n+  A constant 1.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 1\")))\n+\n+(define_constraint \"T\"\n+  \"A text segment (program memory) constant label.\"\n+  (match_test \"text_segment_operand (op, VOIDmode)\"))\n+\n+(define_constraint \"Z\"\n+  \"An integer constant zero.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 0\")))"}, {"sha": "568d6f3fa91ada5ed555a27fb9182ef6bccf46b5", "filename": "gcc/config/pru/predicates.md", "status": "added", "additions": 287, "deletions": 0, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fconfig%2Fpru%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fconfig%2Fpru%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpredicates.md?ref=8d2af3a25bdb6b7996e0a55551ae0fd599e1739b", "patch": "@@ -0,0 +1,287 @@\n+;; Predicate definitions for TI PRU.\n+;; Copyright (C) 2014-2019 Free Software Foundation, Inc.\n+;; Contributed by Dimitar Dimitrov <dimitar@dinux.eu>\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_predicate \"const_1_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) == 1\")))\n+\n+; Note: Always pass a valid mode!\n+(define_predicate \"const_ubyte_operand\"\n+  (match_code \"const_int\")\n+{\n+  gcc_assert (mode != VOIDmode);\n+  return IN_RANGE (INTVAL (op) & GET_MODE_MASK (mode), 0, 0xff);\n+})\n+\n+(define_predicate \"const_uhword_operand\"\n+  (match_code \"const_int\")\n+{\n+  gcc_assert (mode != VOIDmode);\n+  return IN_RANGE (INTVAL (op) & GET_MODE_MASK (mode), 0, 0xffff);\n+})\n+\n+; TRUE for comparisons we support.\n+(define_predicate \"pru_cmp_operator\"\n+  (match_code \"eq,ne,leu,ltu,geu,gtu\"))\n+\n+; TRUE for signed comparisons that need special handling for PRU.\n+(define_predicate \"pru_signed_cmp_operator\"\n+  (match_code \"ge,gt,le,lt\"))\n+\n+;; FP Comparisons handled by pru_expand_pru_compare.\n+(define_predicate \"pru_fp_comparison_operator\"\n+  (match_code \"eq,ne,lt,gt,le,ge\"))\n+\n+;; Return true if OP is a constant that contains only one 1 in its\n+;; binary representation.\n+(define_predicate \"single_one_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"exact_log2 (INTVAL (op) & GET_MODE_MASK (mode)) >= 0\")))\n+\n+;; Return true if OP is a constant that contains only one 0 in its\n+;; binary representation.\n+(define_predicate \"single_zero_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"exact_log2 (~INTVAL (op) & GET_MODE_MASK (mode)) >= 0\")))\n+\n+(define_predicate \"pru_muldst_operand\"\n+  (match_code \"subreg,reg\")\n+{\n+  if (register_operand (op, mode))\n+    {\n+      int regno;\n+\n+      if (REG_P (op))\n+\tregno = REGNO (op);\n+      else if (GET_CODE (op) == SUBREG && REG_P (SUBREG_REG (op)))\n+\tregno = REGNO (SUBREG_REG (op));\n+      else\n+\treturn 0;\n+\n+      return REGNO_REG_CLASS (regno) == MULDST_REGS\n+\t     || regno >= FIRST_PSEUDO_REGISTER;\n+    }\n+  return 0;\n+})\n+\n+(define_predicate \"pru_mulsrc0_operand\"\n+  (match_code \"subreg,reg\")\n+{\n+  if (register_operand (op, mode))\n+    {\n+      int regno;\n+\n+      if (REG_P (op))\n+\tregno = REGNO (op);\n+      else if (GET_CODE (op) == SUBREG && REG_P (SUBREG_REG (op)))\n+\tregno = REGNO (SUBREG_REG (op));\n+      else\n+\treturn 0;\n+\n+      return REGNO_REG_CLASS (regno) == MULSRC0_REGNUM\n+\t     || regno >= FIRST_PSEUDO_REGISTER;\n+    }\n+  return 0;\n+})\n+\n+(define_predicate \"pru_mulsrc1_operand\"\n+  (match_code \"subreg,reg\")\n+{\n+  if (register_operand (op, mode))\n+    {\n+      int regno;\n+\n+      if (REG_P (op))\n+\tregno = REGNO (op);\n+      else if (GET_CODE (op) == SUBREG && REG_P (SUBREG_REG (op)))\n+\tregno = REGNO (SUBREG_REG (op));\n+      else\n+\treturn 0;\n+\n+      return REGNO_REG_CLASS (regno) == MULSRC1_REGNUM\n+\t     || regno >= FIRST_PSEUDO_REGISTER;\n+    }\n+  return 0;\n+})\n+\n+(define_predicate \"reg_or_const_int_operand\"\n+  (ior (match_operand 0 \"const_int_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"reg_or_ubyte_operand\"\n+  (ior (match_operand 0 \"const_ubyte_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"reg_or_const_1_operand\"\n+  (ior (match_operand 0 \"const_1_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"const_shift_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"SHIFT_INT (INTVAL (op))\")))\n+\n+(define_predicate \"shift_operand\"\n+  (ior (match_operand 0 \"const_shift_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"ctable_addr_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"pru_get_ctable_base_index (INTVAL (op)) >= 0\")))\n+\n+(define_predicate \"ctable_base_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"pru_get_ctable_exact_base_index (INTVAL (op)) >= 0\")))\n+\n+;; Ideally we should enforce a restriction to all text labels to fit in\n+;; 16bits, as required by the PRU ISA.  But for the time being we'll rely on\n+;; binutils to catch text segment overflows.\n+(define_predicate \"call_operand\"\n+  (ior (match_operand 0 \"immediate_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n+;; Return true if OP is a text segment reference.\n+;; This is needed for program memory address expressions.  Borrowed from AVR.\n+(define_predicate \"text_segment_operand\"\n+  (match_code \"code_label,label_ref,symbol_ref,plus,minus\")\n+{\n+  poly_int64 offset;\n+  rtx base = strip_offset (op, &offset);\n+\n+  switch (GET_CODE (base))\n+    {\n+    case CODE_LABEL:\n+      /* Why AVR lists this as a valid option?  Let's catch it.  */\n+      gcc_unreachable ();\n+      return false;\n+    case LABEL_REF:\n+      return true;\n+    case SYMBOL_REF:\n+      return SYMBOL_REF_FUNCTION_P (base);\n+    case PLUS:\n+    case MINUS:\n+      /* Handle constructs like (&&label1 - &&label2).  See pr70460.c.  */\n+      return text_segment_operand (XEXP (op, 0), VOIDmode);\n+    default:\n+      return false;\n+    }\n+})\n+\n+;; Return true if OP is a load multiple operation.  It is known to be a\n+;; PARALLEL and the first section will be tested.\n+\n+(define_special_predicate \"load_multiple_operation\"\n+  (match_code \"parallel\")\n+{\n+  machine_mode elt_mode;\n+  int count = XVECLEN (op, 0);\n+  unsigned int dest_regno;\n+  rtx src_addr, base_reg;\n+  poly_int64 base_offs;\n+  int i;\n+\n+  /* Perform a quick check so we don't blow up below.  */\n+  if (GET_CODE (XVECEXP (op, 0, 0)) != SET\n+      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != REG\n+      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != MEM)\n+    return false;\n+\n+  dest_regno = REGNO (SET_DEST (XVECEXP (op, 0, 0)));\n+  src_addr = XEXP (SET_SRC (XVECEXP (op, 0, 0)), 0);\n+  elt_mode = GET_MODE (SET_DEST (XVECEXP (op, 0, 0)));\n+\n+  base_reg = strip_offset (src_addr, &base_offs);\n+  if (GET_CODE (base_reg) != REG)\n+    return false;\n+\n+  for (i = 1; i < count; i++)\n+    {\n+      rtx elt_reg;\n+      poly_int64 elt_offs;\n+      rtx elt = XVECEXP (op, 0, i);\n+\n+      if (GET_CODE (elt) != SET\n+\t  || GET_CODE (SET_DEST (elt)) != REG\n+\t  || GET_MODE (SET_DEST (elt)) != elt_mode\n+\t  || REGNO (SET_DEST (elt)) != dest_regno + i * GET_MODE_SIZE (elt_mode)\n+\t  || GET_CODE (SET_SRC (elt)) != MEM\n+\t  || GET_MODE (SET_SRC (elt)) != elt_mode)\n+\treturn false;\n+\n+      elt_reg = strip_offset (XEXP (SET_SRC (elt), 0), &elt_offs);\n+\n+      if (GET_CODE (elt_reg) != REG\n+\t  || ! rtx_equal_p (elt_reg, base_reg)\n+\t  || elt_offs != base_offs + i * GET_MODE_SIZE (elt_mode))\n+\treturn false;\n+    }\n+\n+  return true;\n+})\n+\n+;; Return true if OP is a store multiple operation.  It is known to be a\n+;; PARALLEL and the first section will be tested.\n+\n+(define_special_predicate \"store_multiple_operation\"\n+  (match_code \"parallel\")\n+{\n+  machine_mode elt_mode;\n+  int count = XVECLEN (op, 0);\n+  unsigned int src_regno;\n+  rtx dest_addr, base_reg;\n+  poly_int64 base_offs;\n+  int i;\n+\n+  /* Perform a quick check so we don't blow up below.  */\n+  if (GET_CODE (XVECEXP (op, 0, 0)) != SET\n+      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != MEM\n+      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != REG)\n+    return false;\n+\n+  src_regno = REGNO (SET_SRC (XVECEXP (op, 0, 0)));\n+  dest_addr = XEXP (SET_DEST (XVECEXP (op, 0, 0)), 0);\n+  elt_mode = GET_MODE (SET_SRC (XVECEXP (op, 0, 0)));\n+\n+  base_reg = strip_offset (dest_addr, &base_offs);\n+  if (GET_CODE (base_reg) != REG)\n+    return false;\n+\n+  for (i = 1; i < count; i++)\n+    {\n+      rtx elt_reg;\n+      poly_int64 elt_offs;\n+      rtx elt = XVECEXP (op, 0, i);\n+\n+      if (GET_CODE (elt) != SET\n+\t  || GET_CODE (SET_SRC (elt)) != REG\n+\t  || GET_MODE (SET_SRC (elt)) != elt_mode\n+\t  || REGNO (SET_SRC (elt)) != src_regno + i * GET_MODE_SIZE (elt_mode)\n+\t  || GET_CODE (SET_DEST (elt)) != MEM\n+\t  || GET_MODE (SET_DEST (elt)) != elt_mode)\n+\treturn false;\n+\n+      elt_reg = strip_offset (XEXP (SET_DEST (elt), 0), &elt_offs);\n+\n+      if (GET_CODE (elt_reg) != REG\n+\t  || ! rtx_equal_p (elt_reg, base_reg)\n+\t  || elt_offs != base_offs + i * GET_MODE_SIZE (elt_mode))\n+\treturn false;\n+    }\n+  return true;\n+})"}, {"sha": "70bc147ac599ee038cc4c7bfc90b33f3ef5a3db9", "filename": "gcc/config/pru/pru-opts.h", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fconfig%2Fpru%2Fpru-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fconfig%2Fpru%2Fpru-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpru-opts.h?ref=8d2af3a25bdb6b7996e0a55551ae0fd599e1739b", "patch": "@@ -0,0 +1,31 @@\n+/* Copyright (C) 2017-2019 Free Software Foundation, Inc.\n+   Contributed by Dimitar Dimitrov <dimitar@dinux.eu>\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Definitions for option handling for PRU.  */\n+\n+#ifndef GCC_PRU_OPTS_H\n+#define GCC_PRU_OPTS_H\n+\n+/* ABI variant for code generation.  */\n+enum pru_abi {\n+    PRU_ABI_GNU,\n+    PRU_ABI_TI\n+};\n+\n+#endif"}, {"sha": "8efba54e7e0c1eb0bce8f9dec4045276ca0c5990", "filename": "gcc/config/pru/pru-passes.c", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fconfig%2Fpru%2Fpru-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fconfig%2Fpru%2Fpru-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpru-passes.c?ref=8d2af3a25bdb6b7996e0a55551ae0fd599e1739b", "patch": "@@ -0,0 +1,228 @@\n+/* PRU target specific passes\n+   Copyright (C) 2017-2019 Free Software Foundation, Inc.\n+   Dimitar Dimitrov <dimitar@dinux.eu>\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#define IN_TARGET_CODE 1\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"context.h\"\n+#include \"tm.h\"\n+#include \"alias.h\"\n+#include \"symtab.h\"\n+#include \"tree.h\"\n+#include \"diagnostic-core.h\"\n+#include \"function.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"gimple-walk.h\"\n+#include \"gimple-expr.h\"\n+#include \"tree-pass.h\"\n+\n+#include \"pru-protos.h\"\n+\n+namespace {\n+\n+/* Scan the tree to ensure that the compiled code by GCC\n+   conforms to the TI ABI specification.  If GCC cannot\n+   output a conforming code, raise an error.  */\n+const pass_data pass_data_tiabi_check =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"*tiabi_check\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_NONE, /* tv_id */\n+  PROP_gimple_any, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+/* Implementation class for the TI ABI compliance-check pass.  */\n+class pass_tiabi_check : public gimple_opt_pass\n+{\n+public:\n+  pass_tiabi_check (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_tiabi_check, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual unsigned int execute (function *);\n+\n+  virtual bool gate (function *fun ATTRIBUTE_UNUSED)\n+  {\n+    return pru_current_abi == PRU_ABI_TI;\n+  }\n+\n+}; // class pass_tiabi_check\n+\f\n+/* Return 1 if type TYPE is a pointer to function type or a\n+   structure having a pointer to function type as one of its fields.\n+   Otherwise return 0.  */\n+static bool\n+chkp_type_has_function_pointer (const_tree type)\n+{\n+  bool res = false;\n+\n+  if (POINTER_TYPE_P (type) && FUNC_OR_METHOD_TYPE_P (TREE_TYPE (type)))\n+    res = true;\n+  else if (RECORD_OR_UNION_TYPE_P (type))\n+    {\n+      tree field;\n+\n+      for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n+\tif (TREE_CODE (field) == FIELD_DECL)\n+\t  res = res || chkp_type_has_function_pointer (TREE_TYPE (field));\n+    }\n+  else if (TREE_CODE (type) == ARRAY_TYPE)\n+    res = chkp_type_has_function_pointer (TREE_TYPE (type));\n+\n+  return res;\n+}\n+\n+/* Check the function declaration FNTYPE for TI ABI compatibility.  */\n+static void\n+chk_function_decl (const_tree fntype, location_t call_location)\n+{\n+  /* GCC does not check if the RETURN VALUE pointer is NULL,\n+     so do not allow GCC functions with large return values.  */\n+  if (!VOID_TYPE_P (TREE_TYPE (fntype))\n+      && pru_return_in_memory (TREE_TYPE (fntype), fntype))\n+    error_at (call_location,\n+\t      \"large return values not supported with %<-mabi=ti%> option\");\n+\n+  /* Check this function's arguments.  */\n+  for (tree p = TYPE_ARG_TYPES (fntype); p; p = TREE_CHAIN (p))\n+    {\n+      tree arg_type = TREE_VALUE (p);\n+      if (chkp_type_has_function_pointer (arg_type))\n+\terror_at (call_location,\n+\t\t  \"function pointers not supported with %<-mabi=ti%> option\");\n+    }\n+}\n+\n+/* Callback for walk_gimple_seq that checks TP tree for TI ABI compliance.  */\n+static tree\n+check_op_callback (tree *tp, int *walk_subtrees, void *data)\n+{\n+  struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n+\n+  if (RECORD_OR_UNION_TYPE_P (*tp) || TREE_CODE (*tp) == ENUMERAL_TYPE)\n+    {\n+      /* Forward declarations have NULL tree type.  Skip them.  */\n+      if (TREE_TYPE (*tp) == NULL)\n+\treturn NULL;\n+    }\n+\n+  /* TODO - why C++ leaves INTEGER_TYPE forward declarations around?  */\n+  if (TREE_TYPE (*tp) == NULL)\n+    return NULL;\n+\n+  const tree type = TREE_TYPE (*tp);\n+\n+  /* Direct function calls are allowed, obviously.  */\n+  gcall *call = dyn_cast <gcall *> (gsi_stmt (wi->gsi));\n+  if (call\n+      && tp == gimple_call_fn_ptr (call)\n+      && gimple_call_fndecl (call))\n+    return NULL;\n+\n+  switch (TREE_CODE (type))\n+    {\n+    case FUNCTION_TYPE:\n+    case METHOD_TYPE:\n+\t{\n+\t  /* Note: Do not enforce a small return value.  It is safe to\n+\t     call any TI ABI function from GCC, since GCC will\n+\t     never pass NULL.  */\n+\n+\t  /* Check arguments for function pointers.  */\n+\t  for (tree p = TYPE_ARG_TYPES (type); p; p = TREE_CHAIN (p))\n+\t    {\n+\t      tree arg_type = TREE_VALUE (p);\n+\t      if (chkp_type_has_function_pointer (arg_type))\n+\t\terror_at (gimple_location (wi->stmt), \"function pointers \"\n+\t\t\t  \"not supported with %<-mabi=ti%> option\");\n+\t    }\n+\t  break;\n+\t}\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case QUAL_UNION_TYPE:\n+    case POINTER_TYPE:\n+\t{\n+\t  if (chkp_type_has_function_pointer (type))\n+\t    {\n+\t      error_at (gimple_location (wi->stmt),\n+\t\t\t\"function pointers not supported with \"\n+\t\t\t\"%<-mabi=ti%> option\");\n+\t      *walk_subtrees = false;\n+\t    }\n+\t  break;\n+\t}\n+    default:\n+\t  break;\n+    }\n+  return NULL;\n+}\n+\n+/* Pass implementation.  */\n+unsigned\n+pass_tiabi_check::execute (function *fun)\n+{\n+  struct walk_stmt_info wi;\n+  const_tree fntype = TREE_TYPE (fun->decl);\n+\n+  gimple_seq body = gimple_body (current_function_decl);\n+\n+  memset (&wi, 0, sizeof (wi));\n+  wi.info = NULL;\n+  wi.want_locations = true;\n+\n+  /* Check the function body.  */\n+  walk_gimple_seq (body, NULL, check_op_callback, &wi);\n+\n+  /* Check the function declaration.  */\n+  chk_function_decl (fntype, fun->function_start_locus);\n+\n+  return 0;\n+}\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_tiabi_check (gcc::context *ctxt)\n+{\n+  return new pass_tiabi_check (ctxt);\n+}\n+\n+/* Register as early as possible.  */\n+void\n+pru_register_abicheck_pass (void)\n+{\n+  opt_pass *tiabi_check = make_pass_tiabi_check (g);\n+  struct register_pass_info tiabi_check_info\n+    = { tiabi_check, \"*warn_unused_result\",\n+\t1, PASS_POS_INSERT_AFTER\n+      };\n+  register_pass (&tiabi_check_info);\n+}"}, {"sha": "868001169507dfb3807a0ef9c6223a456d5ec666", "filename": "gcc/config/pru/pru-pragma.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fconfig%2Fpru%2Fpru-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fconfig%2Fpru%2Fpru-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpru-pragma.c?ref=8d2af3a25bdb6b7996e0a55551ae0fd599e1739b", "patch": "@@ -0,0 +1,86 @@\n+/* PRU target specific pragmas\n+   Copyright (C) 2015-2019 Free Software Foundation, Inc.\n+   Contributed by Dimitar Dimitrov <dimitar@dinux.eu>\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#define IN_TARGET_CODE 1\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"alias.h\"\n+#include \"symtab.h\"\n+#include \"tree.h\"\n+#include \"c-family/c-pragma.h\"\n+#include \"c-family/c-common.h\"\n+#include \"diagnostic-core.h\"\n+#include \"cpplib.h\"\n+#include \"pru-protos.h\"\n+\n+\n+/* Implements the \"pragma CTABLE_ENTRY\" pragma.  This pragma takes a\n+   CTABLE index and an address, and instructs the compiler that\n+   LBCO/SBCO can be used on that base address.\n+\n+   WARNING: Only immediate constant addresses are currently supported.  */\n+static void\n+pru_pragma_ctable_entry (cpp_reader * reader ATTRIBUTE_UNUSED)\n+{\n+  tree ctable_index, base_addr;\n+  enum cpp_ttype type;\n+\n+  type = pragma_lex (&ctable_index);\n+  if (type == CPP_NUMBER && tree_fits_uhwi_p (ctable_index))\n+    {\n+      type = pragma_lex (&base_addr);\n+      if (type == CPP_NUMBER  && tree_fits_uhwi_p (base_addr))\n+\t{\n+\t  unsigned HOST_WIDE_INT i = tree_to_uhwi (ctable_index);\n+\t  unsigned HOST_WIDE_INT base = tree_to_uhwi (base_addr);\n+\n+\t  type = pragma_lex (&base_addr);\n+\t  if (type != CPP_EOF)\n+\t    error (\"junk at end of %<#pragma CTABLE_ENTRY%>\");\n+\t  else if (i >= ARRAY_SIZE (pru_ctable))\n+\t    error (\"%<CTABLE_ENTRY%> index %\" HOST_WIDE_INT_PRINT \"d\"\n+\t\t   \" is not valid\", i);\n+\t  else if (pru_ctable[i].valid && pru_ctable[i].base != base)\n+\t    error (\"redefinition of %<CTABLE_ENTRY \"\n+\t\t   \"%\" HOST_WIDE_INT_PRINT \"d%>\", i);\n+\t  else\n+\t    {\n+\t      if (base & 0xff)\n+\t\twarning (0, \"%<CTABLE_ENTRY%> base address is not \"\n+\t\t\t    \"a multiple of 256\");\n+\t      pru_ctable[i].base = base;\n+\t      pru_ctable[i].valid = true;\n+\t    }\n+\t  return;\n+\t}\n+    }\n+  error (\"malformed %<#pragma CTABLE_ENTRY%> variable address\");\n+}\n+\n+/* Implements REGISTER_TARGET_PRAGMAS.  */\n+void\n+pru_register_pragmas (void)\n+{\n+  c_register_pragma (NULL, \"ctable_entry\", pru_pragma_ctable_entry);\n+  c_register_pragma (NULL, \"CTABLE_ENTRY\", pru_pragma_ctable_entry);\n+}"}, {"sha": "0090521d00f891bd03a922709b15d19dcb985fe8", "filename": "gcc/config/pru/pru-protos.h", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fconfig%2Fpru%2Fpru-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fconfig%2Fpru%2Fpru-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpru-protos.h?ref=8d2af3a25bdb6b7996e0a55551ae0fd599e1739b", "patch": "@@ -0,0 +1,72 @@\n+/* Subroutine declarations for TI PRU target support.\n+   Copyright (C) 2014-2019 Free Software Foundation, Inc.\n+   Contributed by Dimitar Dimitrov <dimitar@dinux.eu>\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_PRU_PROTOS_H\n+#define GCC_PRU_PROTOS_H\n+\n+struct pru_ctable_entry {\n+    bool valid;\n+    unsigned HOST_WIDE_INT base;\n+};\n+\n+extern struct pru_ctable_entry pru_ctable[32];\n+\n+extern int pru_initial_elimination_offset (int, int);\n+extern int pru_can_use_return_insn (void);\n+extern void pru_expand_prologue (void);\n+extern void pru_expand_epilogue (bool);\n+extern void pru_function_profiler (FILE *, int);\n+\n+void pru_register_pragmas (void);\n+\n+#ifdef RTX_CODE\n+extern rtx pru_get_return_address (int);\n+extern int pru_hard_regno_rename_ok (unsigned int, unsigned int);\n+\n+extern const char *pru_output_sign_extend (rtx *);\n+extern const char *pru_output_signed_cbranch (rtx *, bool);\n+extern const char *pru_output_signed_cbranch_ubyteop2 (rtx *, bool);\n+extern const char *pru_output_signed_cbranch_zeroop2 (rtx *, bool);\n+\n+extern rtx pru_expand_fp_compare (rtx comparison, machine_mode mode);\n+\n+extern void pru_emit_doloop (rtx *, int);\n+\n+extern bool pru_regno_ok_for_base_p (int, bool);\n+\n+static inline bool\n+pru_regno_ok_for_index_p (int regno, bool strict_p)\n+{\n+  /* Selection logic is the same - PRU instructions are quite orthogonal.  */\n+  return pru_regno_ok_for_base_p (regno, strict_p);\n+}\n+\n+extern int pru_get_ctable_exact_base_index (unsigned HOST_WIDE_INT caddr);\n+extern int pru_get_ctable_base_index (unsigned HOST_WIDE_INT caddr);\n+extern int pru_get_ctable_base_offset (unsigned HOST_WIDE_INT caddr);\n+\n+extern void pru_register_abicheck_pass (void);\n+#endif /* RTX_CODE */\n+\n+#ifdef TREE_CODE\n+extern bool pru_return_in_memory (const_tree type, const_tree fntype);\n+#endif /* TREE_CODE */\n+\n+#endif /* GCC_PRU_PROTOS_H */"}, {"sha": "c764694f4f78982ab1339d5f2e56d19ec512dcfc", "filename": "gcc/config/pru/pru.c", "status": "added", "additions": 3036, "deletions": 0, "changes": 3036, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fconfig%2Fpru%2Fpru.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fconfig%2Fpru%2Fpru.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpru.c?ref=8d2af3a25bdb6b7996e0a55551ae0fd599e1739b"}, {"sha": "15fb637dec6a71b84a30f86d8981505be641b5a5", "filename": "gcc/config/pru/pru.h", "status": "added", "additions": 573, "deletions": 0, "changes": 573, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fconfig%2Fpru%2Fpru.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fconfig%2Fpru%2Fpru.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpru.h?ref=8d2af3a25bdb6b7996e0a55551ae0fd599e1739b", "patch": "@@ -0,0 +1,573 @@\n+/* Definitions of target machine for TI PRU.\n+   Copyright (C) 2014-2019 Free Software Foundation, Inc.\n+   Contributed by Dimitar Dimitrov <dimitar@dinux.eu>\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_PRU_H\n+#define GCC_PRU_H\n+\n+#include \"config/pru/pru-opts.h\"\n+\n+/* Define built-in preprocessor macros.  */\n+#define TARGET_CPU_CPP_BUILTINS()\t\t    \\\n+  do\t\t\t\t\t\t    \\\n+    {\t\t\t\t\t\t    \\\n+      builtin_define_std (\"__PRU__\");\t\t    \\\n+      builtin_define_std (\"__pru__\");\t\t    \\\n+      builtin_define_std (\"__PRU_V3__\");\t    \\\n+      builtin_define_std (\"__LITTLE_ENDIAN__\");\t    \\\n+      builtin_define_std (\"__little_endian__\");\t    \\\n+      /* Trampolines are disabled for now.  */\t    \\\n+      builtin_define_std (\"NO_TRAMPOLINES\");\t    \\\n+    }\t\t\t\t\t\t    \\\n+  while (0)\n+\n+/* TI ABI implementation is not feature-complete enough (e.g. function\n+   pointers are not supported), so we cannot list it as a multilib variant.\n+   To prevent misuse from users, do not link any of the standard libraries.  */\n+#define DRIVER_SELF_SPECS\t\t\t      \\\n+  \"%{mabi=ti:-nodefaultlibs} \"\t\t\t      \\\n+  \"%{mmcu=*:-specs=device-specs/%*%s %<mmcu=*} \"\n+\n+#undef CPP_SPEC\n+#define CPP_SPEC\t\t\t\t\t\\\n+  \"%(cpp_device) \"\t\t\t\t\t\\\n+  \"%{mabi=ti:-D__PRU_EABI_TI__; :-D__PRU_EABI_GNU__}\"\n+\n+/* Do not relax when in TI ABI mode since TI tools do not always\n+   put PRU_S10_PCREL.  */\n+#undef  LINK_SPEC\n+#define LINK_SPEC\t\t\t\t\t    \\\n+  \"%(link_device) \"\t\t\t\t\t    \\\n+  \"%{mabi=ti:--no-relax;:%{mno-relax:--no-relax;:--relax}} \"   \\\n+  \"%{shared:%eshared is not supported} \"\n+\n+/* CRT0 is carefully maintained to be compatible with both GNU and TI ABIs.  */\n+#undef  STARTFILE_SPEC\n+#define STARTFILE_SPEC\t\t\t\t\t\t\t\\\n+  \"%{!pg:%{minrt:crt0-minrt.o%s}%{!minrt:crt0.o%s}} %{!mabi=ti:-lgcc} \"\n+\n+#undef  ENDFILE_SPEC\n+#define ENDFILE_SPEC \"%{!mabi=ti:-lgloss} \"\n+\n+/* TI ABI mandates that ELF symbols do not start with any prefix.  */\n+#undef USER_LABEL_PREFIX\n+#define USER_LABEL_PREFIX \"\"\n+\n+#undef LOCAL_LABEL_PREFIX\n+#define LOCAL_LABEL_PREFIX \".L\"\n+\n+/* Storage layout.  */\n+\n+#define DEFAULT_SIGNED_CHAR 0\n+#define BITS_BIG_ENDIAN 0\n+#define BYTES_BIG_ENDIAN 0\n+#define WORDS_BIG_ENDIAN 0\n+\n+/* PRU is represented in GCC as an 8-bit CPU with fast 16-bit and 32-bit\n+   arithmetic.  */\n+#define BITS_PER_WORD 8\n+\n+#ifdef IN_LIBGCC2\n+/* This is to get correct SI and DI modes in libgcc2.c (32 and 64 bits).  */\n+#define UNITS_PER_WORD 4\n+#else\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD 1\n+#endif\n+\n+#define POINTER_SIZE 32\n+#define BIGGEST_ALIGNMENT 8\n+#define STRICT_ALIGNMENT 0\n+#define FUNCTION_BOUNDARY 8\t/* Func pointers are word-addressed.  */\n+#define PARM_BOUNDARY 8\n+#define STACK_BOUNDARY 8\n+#define MAX_FIXED_MODE_SIZE 64\n+\n+#define POINTERS_EXTEND_UNSIGNED 1\n+\n+/* Layout of source language data types.  */\n+\n+#define INT_TYPE_SIZE 32\n+#define SHORT_TYPE_SIZE 16\n+#define LONG_TYPE_SIZE 32\n+#define LONG_LONG_TYPE_SIZE 64\n+#define FLOAT_TYPE_SIZE 32\n+#define DOUBLE_TYPE_SIZE 64\n+#define LONG_DOUBLE_TYPE_SIZE DOUBLE_TYPE_SIZE\n+\n+#undef SIZE_TYPE\n+#define SIZE_TYPE \"unsigned int\"\n+\n+#undef PTRDIFF_TYPE\n+#define PTRDIFF_TYPE \"int\"\n+\n+\n+/* Basic characteristics of PRU registers:\n+\n+   Regno  Name\n+   0      r0\t\t  Caller Saved.  Also used as a static chain register.\n+   1      r1\t\t  Caller Saved.  Also used as a temporary by function.\n+\t\t\t  profiler and function prologue/epilogue.\n+   2      r2       sp\t  Stack Pointer.\n+   3*     r3.w0    ra\t  Return Address (16-bit).\n+   4      r4       fp\t  Frame Pointer, also called Argument Pointer in ABI.\n+   5-13   r5-r13\t  Callee Saved Registers.\n+   14-29  r14-r29\t  Register Arguments.  Caller Saved Registers.\n+   14-15  r14-r15\t  Return Location.\n+   30     r30\t\t  Special I/O register.  Not used by compiler.\n+   31     r31\t\t  Special I/O register.  Not used by compiler.\n+\n+   32     loop_cntr\t  Internal register used as a counter by LOOP insns.\n+\n+   33     pc\t\t  Not an actual register.\n+\n+   34     fake_fp\t  Fake Frame Pointer (always eliminated).\n+   35     fake_ap\t  Fake Argument Pointer (always eliminated).\n+   36\t\t\t  First Pseudo Register.\n+\n+   The definitions for some hard register numbers are located in pru.md.\n+   Note that GCC's internal register numbering differs from the conventional\n+   register naming in PRU ISA.  PRU ISA defines word-based register numbers\n+   and sub-register suffixes (e.g. RA is r3.w0).  GCC uses linear numbering\n+   of 8 bit sub-registers (e.g. RA starts at r12).  When outputting assembly,\n+   GCC will take into account the RTL operand size (e.g. r12:HI) in order to\n+   translate to the conventional PRU ISA format expected by GAS (r3.w0).\n+*/\n+\n+#define FIXED_REGISTERS\t\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+/*   0 */  0,0,0,0, 0,0,0,0, 1,1,1,1, 1,1,1,1,\t\\\n+/*   4 */  0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\t\\\n+/*   8 */  0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\t\\\n+/*  12 */  0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\t\\\n+/*  16 */  0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\t\\\n+/*  20 */  0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\t\\\n+/*  24 */  0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\t\\\n+/*  28 */  0,0,0,0, 0,0,0,0, 1,1,1,1, 1,1,1,1,\t\\\n+/*  32 */  1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1\t\\\n+  }\n+\n+/* Call used == caller saved + fixed regs + args + ret vals.  */\n+#define CALL_USED_REGISTERS\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+/*   0 */  1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1,\t\\\n+/*   4 */  0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\t\\\n+/*   8 */  0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\t\\\n+/*  12 */  0,0,0,0, 0,0,0,0, 1,1,1,1, 1,1,1,1,\t\\\n+/*  16 */  1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1,\t\\\n+/*  20 */  1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1,\t\\\n+/*  24 */  1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1,\t\\\n+/*  28 */  1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1,\t\\\n+/*  32 */  1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1\t\\\n+  }\n+\n+#define PRU_SEQ_R(X)  (X) * 4 + 0, (X) * 4 + 1, (X) * 4 + 2, (X) * 4 + 3\n+#define REG_ALLOC_ORDER\t\t\t\t\t\t\t    \\\n+  {\t\t\t\t\t\t\t\t\t    \\\n+    /* Call-clobbered, yet not used for parameters.  */\t\t\t    \\\n+    PRU_SEQ_R (0),  PRU_SEQ_R ( 1),\t\t\t\t\t    \\\n+\t\t\t\t\t\t\t\t\t    \\\n+    PRU_SEQ_R (14), PRU_SEQ_R (15), PRU_SEQ_R (16), PRU_SEQ_R (17),\t    \\\n+    PRU_SEQ_R (18), PRU_SEQ_R (19), PRU_SEQ_R (20), PRU_SEQ_R (21),\t    \\\n+    PRU_SEQ_R (22), PRU_SEQ_R (23), PRU_SEQ_R (24), PRU_SEQ_R (25),\t    \\\n+    PRU_SEQ_R (26), PRU_SEQ_R (27), PRU_SEQ_R (28), PRU_SEQ_R (29),\t    \\\n+\t\t\t\t\t\t\t\t\t    \\\n+    PRU_SEQ_R ( 5), PRU_SEQ_R ( 6), PRU_SEQ_R ( 7), PRU_SEQ_R ( 8),\t    \\\n+    PRU_SEQ_R ( 9), PRU_SEQ_R (10), PRU_SEQ_R (11), PRU_SEQ_R (12),\t    \\\n+    PRU_SEQ_R (13),\t\t\t\t\t\t\t    \\\n+\t\t\t\t\t\t\t\t\t    \\\n+    PRU_SEQ_R ( 4),\t\t\t\t\t\t\t    \\\n+    PRU_SEQ_R ( 2), PRU_SEQ_R ( 3),\t\t\t\t\t    \\\n+\t\t\t\t\t\t\t\t\t    \\\n+    /* I/O and virtual registers.  */\t\t\t\t\t    \\\n+    PRU_SEQ_R (30), PRU_SEQ_R (31), PRU_SEQ_R (32), PRU_SEQ_R (33),\t    \\\n+    PRU_SEQ_R (34), PRU_SEQ_R (35)\t\t\t\t\t    \\\n+  }\n+\n+/* Register Classes.  */\n+\n+enum reg_class\n+{\n+  NO_REGS,\n+  SIB_REGS,\n+  LOOPCNTR_REGS,\n+  MULDST_REGS,\n+  MULSRC0_REGS,\n+  MULSRC1_REGS,\n+  GP_REGS,\n+  ALL_REGS,\n+  LIM_REG_CLASSES\n+};\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+#define REG_CLASS_NAMES   \\\n+  {  \"NO_REGS\",\t\t  \\\n+     \"SIB_REGS\",\t  \\\n+     \"LOOPCNTR_REGS\",\t  \\\n+     \"MULDST_REGS\",\t  \\\n+     \"MULSRC0_REGS\",\t  \\\n+     \"MULSRC1_REGS\",\t  \\\n+     \"GP_REGS\",\t\t  \\\n+     \"ALL_REGS\" }\n+\n+#define GENERAL_REGS ALL_REGS\n+\n+#define REG_CLASS_CONTENTS\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    /* NO_REGS\t      */ { 0, 0, 0, 0, 0},\t\t\t\\\n+    /* SIB_REGS\t      */ { 0xf, 0xff000000, ~0, 0xffffff, 0},\t\\\n+    /* LOOPCNTR_REGS  */ { 0, 0, 0, 0, 0xf},\t\t\t\\\n+    /* MULDST_REGS    */ { 0, 0, 0, 0x00000f00, 0},\t\t\\\n+    /* MULSRC0_REGS   */ { 0, 0, 0, 0x000f0000, 0},\t\t\\\n+    /* MULSRC1_REGS   */ { 0, 0, 0, 0x00f00000, 0},\t\t\\\n+    /* GP_REGS\t      */ { ~0, ~0, ~0, ~0, 0},\t\t\t\\\n+    /* ALL_REGS\t      */ { ~0,~0, ~0, ~0, ~0}\t\t\t\\\n+  }\n+\n+\n+#define GP_REG_P(REGNO) ((unsigned)(REGNO) <= LAST_GP_REGNUM)\n+#define REGNO_REG_CLASS(REGNO)\t\t\t\t\t\t    \\\n+\t((REGNO) == MULDST_REGNUM ? MULDST_REGS\t\t\t\t    \\\n+\t : (REGNO) == MULSRC0_REGNUM ? MULSRC0_REGS\t\t\t    \\\n+\t : (REGNO) == MULSRC1_REGNUM ? MULSRC1_REGS\t\t\t    \\\n+\t : (REGNO) >= FIRST_ARG_REGNUM\t\t\t\t\t    \\\n+\t    && (REGNO) <= LAST_ARG_REGNUM ? SIB_REGS\t\t\t    \\\n+\t : (REGNO) == STATIC_CHAIN_REGNUM ? SIB_REGS\t\t\t    \\\n+\t : (REGNO) == LOOPCNTR_REGNUM ? LOOPCNTR_REGS\t\t\t    \\\n+\t : (REGNO) <= LAST_NONIO_GP_REGNUM ? GP_REGS\t\t\t    \\\n+\t : ALL_REGS)\n+\n+#define CLASS_MAX_NREGS(CLASS, MODE) \\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Arbitrarily set to a non-argument register.  Not defined by TI ABI.  */\n+#define STATIC_CHAIN_REGNUM      0\t/* r0 */\n+\n+/* Tests for various kinds of constants used in the PRU port.  */\n+#define SHIFT_INT(X) (IN_RANGE ((X), 0, 31))\n+\n+#define UHWORD_INT(X) (IN_RANGE ((X), 0, 0xffff))\n+#define SHWORD_INT(X) (IN_RANGE ((X), -32768, 32767))\n+#define UBYTE_INT(X) (IN_RANGE ((X), 0, 0xff))\n+#define SBYTE_INT(X) (IN_RANGE ((X), -128, 127))\n+\n+/* Say that the epilogue uses the return address register.  Note that\n+   in the case of sibcalls, the values \"used by the epilogue\" are\n+   considered live at the start of the called function.  */\n+#define EPILOGUE_USES(REGNO) (epilogue_completed\t\t\\\n+\t\t\t      && (((REGNO) == RA_REGNUM)\t\t\\\n+\t\t\t\t  || (REGNO) == (RA_REGNUM + 1)))\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+\n+#define EXIT_IGNORE_STACK 1\n+\n+/* Trampolines are not supported, but put a define to keep the build.  */\n+#define TRAMPOLINE_SIZE 4\n+\n+/* Stack layout.  */\n+#define STACK_GROWS_DOWNWARD  1\n+#undef FRAME_GROWS_DOWNWARD\n+#define FIRST_PARM_OFFSET(FUNDECL) 0\n+\n+/* Before the prologue, RA lives in r3.w2.  */\n+#define INCOMING_RETURN_ADDR_RTX\tgen_rtx_REG (HImode, RA_REGNUM)\n+\n+#define RETURN_ADDR_RTX(C,F) pru_get_return_address (C)\n+\n+#define DWARF_FRAME_RETURN_COLUMN RA_REGNUM\n+\n+/* The CFA includes the pretend args.  */\n+#define ARG_POINTER_CFA_OFFSET(FNDECL) \\\n+  (gcc_assert ((FNDECL) == current_function_decl), \\\n+   FIRST_PARM_OFFSET (FNDECL) + crtl->args.pretend_args_size)\n+\n+/* Frame/arg pointer elimination settings.  */\n+#define ELIMINABLE_REGS\t\t\t\t\t\t\t\\\n+{{ ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM},\t\t\t\t\\\n+ { ARG_POINTER_REGNUM,   HARD_FRAME_POINTER_REGNUM},\t\t\t\\\n+ { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\t\t\\\n+ { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n+  (OFFSET) = pru_initial_elimination_offset ((FROM), (TO))\n+\n+#define HARD_REGNO_RENAME_OK(OLD_REG, NEW_REG) \\\n+  pru_hard_regno_rename_ok (OLD_REG, NEW_REG)\n+\n+/* Calling convention definitions.  */\n+#if !defined(IN_LIBGCC2)\n+\n+#define NUM_ARG_REGS (LAST_ARG_REGNUM - FIRST_ARG_REGNUM + 1)\n+\n+typedef struct pru_args\n+{\n+  bool regs_used[NUM_ARG_REGS];\n+} CUMULATIVE_ARGS;\n+\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL, N_NAMED_ARGS)  \\\n+  do {\t\t\t\t\t\t\t\t\t  \\\n+      memset ((CUM).regs_used, 0, sizeof ((CUM).regs_used));\t\t  \\\n+  } while (0)\n+\n+#define FUNCTION_ARG_REGNO_P(REGNO) \\\n+  ((REGNO) >= FIRST_ARG_REGNUM && (REGNO) <= LAST_ARG_REGNUM)\n+\n+/* Passing function arguments on stack.  */\n+#define PUSH_ARGS 0\n+#define ACCUMULATE_OUTGOING_ARGS 1\n+\n+/* We define TARGET_RETURN_IN_MEMORY, so set to zero.  */\n+#define DEFAULT_PCC_STRUCT_RETURN 0\n+\n+/* Profiling.  */\n+#define PROFILE_BEFORE_PROLOGUE\n+#define NO_PROFILE_COUNTERS 1\n+#define FUNCTION_PROFILER(FILE, LABELNO) \\\n+  pru_function_profiler ((FILE), (LABELNO))\n+\n+#endif\t/* IN_LIBGCC2 */\n+\n+/* Addressing modes.  */\n+\n+#define CONSTANT_ADDRESS_P(X) \\\n+  (CONSTANT_P (X) && memory_address_p (SImode, X))\n+\n+#define MAX_REGS_PER_ADDRESS 2\n+#define BASE_REG_CLASS ALL_REGS\n+#define INDEX_REG_CLASS ALL_REGS\n+\n+#define REGNO_OK_FOR_BASE_P(REGNO) pru_regno_ok_for_base_p ((REGNO), true)\n+#define REGNO_OK_FOR_INDEX_P(REGNO) pru_regno_ok_for_index_p ((REGNO), true)\n+\n+/* Limited by the insns in pru-ldst-multiple.md.  */\n+#define MOVE_MAX 8\n+#define SLOW_BYTE_ACCESS 1\n+\n+/* It is as good to call a constant function address as to call an address\n+   kept in a register.  */\n+#define NO_FUNCTION_CSE 1\n+\n+/* Define output assembler language.  */\n+\n+#define ASM_APP_ON \"#APP\\n\"\n+#define ASM_APP_OFF \"#NO_APP\\n\"\n+\n+#define ASM_COMMENT_START \"# \"\n+\n+#define GLOBAL_ASM_OP \"\\t.global\\t\"\n+\n+#define PRU_NAME_R(X)  X\".b0\", X\".b1\", X\".b2\", X\".b3\"\n+#define REGISTER_NAMES\t\t  \\\n+  {\t\t\t\t  \\\n+    PRU_NAME_R (\"r0\"),\t\t  \\\n+    PRU_NAME_R (\"r1\"),\t\t  \\\n+    PRU_NAME_R (\"r2\"),\t\t  \\\n+    PRU_NAME_R (\"r3\"),\t\t  \\\n+    PRU_NAME_R (\"r4\"),\t\t  \\\n+    PRU_NAME_R (\"r5\"),\t\t  \\\n+    PRU_NAME_R (\"r6\"),\t\t  \\\n+    PRU_NAME_R (\"r7\"),\t\t  \\\n+    PRU_NAME_R (\"r8\"),\t\t  \\\n+    PRU_NAME_R (\"r9\"),\t\t  \\\n+    PRU_NAME_R (\"r10\"),\t\t  \\\n+    PRU_NAME_R (\"r11\"),\t\t  \\\n+    PRU_NAME_R (\"r12\"),\t\t  \\\n+    PRU_NAME_R (\"r13\"),\t\t  \\\n+    PRU_NAME_R (\"r14\"),\t\t  \\\n+    PRU_NAME_R (\"r15\"),\t\t  \\\n+    PRU_NAME_R (\"r16\"),\t\t  \\\n+    PRU_NAME_R (\"r17\"),\t\t  \\\n+    PRU_NAME_R (\"r18\"),\t\t  \\\n+    PRU_NAME_R (\"r19\"),\t\t  \\\n+    PRU_NAME_R (\"r20\"),\t\t  \\\n+    PRU_NAME_R (\"r21\"),\t\t  \\\n+    PRU_NAME_R (\"r22\"),\t\t  \\\n+    PRU_NAME_R (\"r23\"),\t\t  \\\n+    PRU_NAME_R (\"r24\"),\t\t  \\\n+    PRU_NAME_R (\"r25\"),\t\t  \\\n+    PRU_NAME_R (\"r26\"),\t\t  \\\n+    PRU_NAME_R (\"r27\"),\t\t  \\\n+    PRU_NAME_R (\"r28\"),\t\t  \\\n+    PRU_NAME_R (\"r29\"),\t\t  \\\n+    PRU_NAME_R (\"r30\"),\t\t  \\\n+    PRU_NAME_R (\"r31\"),\t\t  \\\n+    PRU_NAME_R (\"loopcntr_reg\"),  \\\n+    PRU_NAME_R (\"pc\"),\t\t  \\\n+    PRU_NAME_R (\"fake_fp\"),\t  \\\n+    PRU_NAME_R (\"fake_ap\"),\t  \\\n+}\n+\n+#define PRU_OVERLAP_R(X)\t      \\\n+  { \"r\" #X\t, X * 4\t    ,  4 },   \\\n+  { \"r\" #X \".w0\", X * 4 + 0 ,  2 },   \\\n+  { \"r\" #X \".w1\", X * 4 + 1 ,  2 },   \\\n+  { \"r\" #X \".w2\", X * 4 + 2 ,  2 }\n+\n+#define OVERLAPPING_REGISTER_NAMES  \\\n+  {\t\t\t\t    \\\n+    /* Aliases.  */\t\t    \\\n+    { \"sp\", 2 * 4, 4 },\t\t    \\\n+    { \"ra\", 3 * 4, 2 },\t\t    \\\n+    { \"fp\", 4 * 4, 4 },\t\t    \\\n+    PRU_OVERLAP_R (0),\t\t    \\\n+    PRU_OVERLAP_R (1),\t\t    \\\n+    PRU_OVERLAP_R (2),\t\t    \\\n+    PRU_OVERLAP_R (3),\t\t    \\\n+    PRU_OVERLAP_R (4),\t\t    \\\n+    PRU_OVERLAP_R (5),\t\t    \\\n+    PRU_OVERLAP_R (6),\t\t    \\\n+    PRU_OVERLAP_R (7),\t\t    \\\n+    PRU_OVERLAP_R (8),\t\t    \\\n+    PRU_OVERLAP_R (9),\t\t    \\\n+    PRU_OVERLAP_R (10),\t\t    \\\n+    PRU_OVERLAP_R (11),\t\t    \\\n+    PRU_OVERLAP_R (12),\t\t    \\\n+    PRU_OVERLAP_R (13),\t\t    \\\n+    PRU_OVERLAP_R (14),\t\t    \\\n+    PRU_OVERLAP_R (15),\t\t    \\\n+    PRU_OVERLAP_R (16),\t\t    \\\n+    PRU_OVERLAP_R (17),\t\t    \\\n+    PRU_OVERLAP_R (18),\t\t    \\\n+    PRU_OVERLAP_R (19),\t\t    \\\n+    PRU_OVERLAP_R (20),\t\t    \\\n+    PRU_OVERLAP_R (21),\t\t    \\\n+    PRU_OVERLAP_R (22),\t\t    \\\n+    PRU_OVERLAP_R (23),\t\t    \\\n+    PRU_OVERLAP_R (24),\t\t    \\\n+    PRU_OVERLAP_R (25),\t\t    \\\n+    PRU_OVERLAP_R (26),\t\t    \\\n+    PRU_OVERLAP_R (27),\t\t    \\\n+    PRU_OVERLAP_R (28),\t\t    \\\n+    PRU_OVERLAP_R (29),\t\t    \\\n+    PRU_OVERLAP_R (30),\t\t    \\\n+    PRU_OVERLAP_R (31),\t\t    \\\n+}\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)\t\t\t\t    \\\n+  do\t\t\t\t\t\t\t\t\t    \\\n+    {\t\t\t\t\t\t\t\t\t    \\\n+      fputs (integer_asm_op (POINTER_SIZE / BITS_PER_UNIT, TRUE), FILE);    \\\n+      fprintf (FILE, \"%%pmem(.L%u)\\n\", (unsigned) (VALUE));\t\t    \\\n+    }\t\t\t\t\t\t\t\t\t    \\\n+  while (0)\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, BODY, VALUE, REL)\t\t    \\\n+  do\t\t\t\t\t\t\t\t\t    \\\n+    {\t\t\t\t\t\t\t\t\t    \\\n+      fputs (integer_asm_op (POINTER_SIZE / BITS_PER_UNIT, TRUE), STREAM);  \\\n+      fprintf (STREAM, \"%%pmem(.L%u-.L%u)\\n\", (unsigned) (VALUE),\t    \\\n+\t       (unsigned) (REL));\t\t\t\t\t    \\\n+    }\t\t\t\t\t\t\t\t\t    \\\n+  while (0)\n+\n+/* Section directives.  */\n+\n+/* Output before read-only data.  */\n+#define TEXT_SECTION_ASM_OP \"\\t.section\\t.text\"\n+\n+/* Output before writable data.  */\n+#define DATA_SECTION_ASM_OP \"\\t.section\\t.data\"\n+\n+/* Output before uninitialized data.  */\n+#define BSS_SECTION_ASM_OP \"\\t.section\\t.bss\"\n+\n+#define CTORS_SECTION_ASM_OP \"\\t.section\\t.init_array,\\\"aw\\\",%init_array\"\n+#define DTORS_SECTION_ASM_OP \"\\t.section\\t.fini_array,\\\"aw\\\",%fini_array\"\n+\n+#undef INIT_SECTION_ASM_OP\n+#undef FINI_SECTION_ASM_OP\n+#define INIT_ARRAY_SECTION_ASM_OP CTORS_SECTION_ASM_OP\n+#define FINI_ARRAY_SECTION_ASM_OP DTORS_SECTION_ASM_OP\n+\n+/* Since we use .init_array/.fini_array we don't need the markers at\n+   the start and end of the ctors/dtors arrays.  */\n+#define CTOR_LIST_BEGIN asm (CTORS_SECTION_ASM_OP)\n+#define CTOR_LIST_END\t\t/* empty */\n+#define DTOR_LIST_BEGIN asm (DTORS_SECTION_ASM_OP)\n+#define DTOR_LIST_END\t\t/* empty */\n+\n+#undef TARGET_ASM_CONSTRUCTOR\n+#define TARGET_ASM_CONSTRUCTOR pru_elf_asm_constructor\n+\n+#undef TARGET_ASM_DESTRUCTOR\n+#define TARGET_ASM_DESTRUCTOR pru_elf_asm_destructor\n+\n+#define ASM_OUTPUT_ALIGN(FILE, LOG)\t\t      \\\n+  do {\t\t\t\t\t\t      \\\n+    fprintf ((FILE), \"%s%d\\n\", ALIGN_ASM_OP, (LOG));  \\\n+  } while (0)\n+\n+#undef  ASM_OUTPUT_ALIGNED_COMMON\n+#define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGN)\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    fprintf ((FILE), \"%s\", COMMON_ASM_OP);\t\t\t\t\\\n+    assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n+    fprintf ((FILE), \",\" HOST_WIDE_INT_PRINT_UNSIGNED \",%u\\n\", (SIZE),\t\\\n+\t     (ALIGN) / BITS_PER_UNIT);\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+\n+/* This says how to output assembler code to declare an\n+   uninitialized internal linkage data object.  Under SVR4,\n+   the linker seems to want the alignment of data objects\n+   to depend on their types.  We do exactly that here.  */\n+\n+#undef  ASM_OUTPUT_ALIGNED_LOCAL\n+#define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  switch_to_section (bss_section);\t\t\t\t\t\\\n+  ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, \"object\");\t\t\t\\\n+  if (!flag_inhibit_size_directive)\t\t\t\t\t\\\n+    ASM_OUTPUT_SIZE_DIRECTIVE (FILE, NAME, SIZE);\t\t\t\\\n+  ASM_OUTPUT_ALIGN ((FILE), exact_log2 ((ALIGN) / BITS_PER_UNIT));      \\\n+  ASM_OUTPUT_LABEL (FILE, NAME);\t\t\t\t\t\\\n+  ASM_OUTPUT_SKIP ((FILE), (SIZE) ? (SIZE) : 1);\t\t\t\\\n+} while (0)\n+\n+/* Misc parameters.  */\n+\n+#define TARGET_SUPPORTS_WIDE_INT 1\n+\n+#define STORE_FLAG_VALUE 1\n+#define Pmode SImode\n+#define FUNCTION_MODE Pmode\n+\n+#define CASE_VECTOR_MODE Pmode\n+\n+/* Jumps are cheap on PRU.  */\n+#define LOGICAL_OP_NON_SHORT_CIRCUIT\t\t0\n+\n+/* Unfortunately the LBBO instruction does not zero-extend data.  */\n+#undef LOAD_EXTEND_OP\n+\n+#undef WORD_REGISTER_OPERATIONS\n+\n+#define HAS_LONG_UNCOND_BRANCH\t\t\t1\n+#define HAS_LONG_COND_BRANCH\t\t\t1\n+\n+#define REGISTER_TARGET_PRAGMAS() pru_register_pragmas ()\n+\n+#endif /* GCC_PRU_H */"}, {"sha": "53fa73dec03ad8a3d5a86465d9279bbcdb59e897", "filename": "gcc/config/pru/pru.md", "status": "added", "additions": 1022, "deletions": 0, "changes": 1022, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fconfig%2Fpru%2Fpru.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fconfig%2Fpru%2Fpru.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpru.md?ref=8d2af3a25bdb6b7996e0a55551ae0fd599e1739b", "patch": "@@ -0,0 +1,1022 @@\n+;; Machine Description for TI PRU.\n+;; Copyright (C) 2014-2019 Free Software Foundation, Inc.\n+;; Contributed by Dimitar Dimitrov <dimitar@dinux.eu>\n+;; Based on the NIOS2 GCC port.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; Register numbers.\n+(define_constants\n+  [\n+   (FIRST_ARG_REGNUM\t\t56) ; Argument registers.\n+   (LAST_ARG_REGNUM\t\t119) ;\n+   (FIRST_RETVAL_REGNUM\t\t56) ; Return value registers.\n+   (LAST_RETVAL_REGNUM\t\t60) ;\n+   (FIRST_CALLEE_SAVED_REGNUM\t12) ; Callee saved registers.\n+   (LAST_CALEE_SAVED_REGNUM\t55) ;\n+   (PROLOGUE_TEMP_REGNUM\t4) ; Temporary register to use in prologue.\n+\n+   (RA_REGNUM\t\t\t14) ; Return address register r3.w2.\n+   (FP_REGNUM\t\t\t16) ; Frame pointer register.\n+   (MULDST_REGNUM\t\t104) ; Multiply destination register.\n+   (MULSRC0_REGNUM\t\t112) ; Multiply source register.\n+   (MULSRC1_REGNUM\t\t116) ; Multiply source register.\n+   (LAST_NONIO_GP_REGNUM\t119) ; Last non-I/O general purpose register.\n+   (LOOPCNTR_REGNUM\t\t128) ; internal LOOP counter register\n+   (LAST_GP_REGNUM\t\t132) ; Last general purpose register.\n+\n+   ;; Target register definitions.\n+   (STACK_POINTER_REGNUM\t8)\n+   (HARD_FRAME_POINTER_REGNUM\tFP_REGNUM)\n+   (PC_REGNUM\t\t\t132)\n+   (FRAME_POINTER_REGNUM\t136)\n+   (ARG_POINTER_REGNUM\t\t140)\n+   (FIRST_PSEUDO_REGISTER\t144)\n+  ]\n+)\n+\n+;; Enumeration of UNSPECs.\n+\n+(define_c_enum \"unspecv\" [\n+  UNSPECV_DELAY_CYCLES_START\n+  UNSPECV_DELAY_CYCLES_END\n+  UNSPECV_DELAY_CYCLES_2X_HI\n+  UNSPECV_DELAY_CYCLES_2X_SI\n+  UNSPECV_DELAY_CYCLES_1\n+\n+  UNSPECV_LOOP_BEGIN\n+  UNSPECV_LOOP_END\n+\n+  UNSPECV_BLOCKAGE\n+])\n+\f\n+; Length of an instruction (in bytes).\n+(define_attr \"length\" \"\" (const_int 4))\n+(define_attr \"type\"\n+  \"unknown,complex,control,alu,cond_alu,st,ld,shift\"\n+  (const_string \"complex\"))\n+\n+(define_asm_attributes\n+ [(set_attr \"length\" \"4\")\n+  (set_attr \"type\" \"complex\")])\n+\n+; There is no pipeline, so our scheduling description is simple.\n+(define_automaton \"pru\")\n+(define_cpu_unit \"cpu\" \"pru\")\n+\n+(define_insn_reservation \"everything\" 1 (match_test \"true\") \"cpu\")\n+\n+(include \"predicates.md\")\n+(include \"constraints.md\")\n+\n+;; All supported direct move-modes\n+(define_mode_iterator MOV8_16_32 [QI QQ UQQ\n+\t\t\t\t  HI HQ UHQ HA UHA\n+\t\t\t\t  SI SQ USQ SA USA SF SD])\n+\n+(define_mode_iterator MOV8_16 [QI QQ UQQ\n+\t\t\t       HI HQ UHQ HA UHA])\n+(define_mode_iterator MOV32 [SI SQ USQ SA USA SF SD])\n+(define_mode_iterator MOV64 [DI DF DD DQ UDQ])\n+(define_mode_iterator QISI [QI HI SI])\n+(define_mode_iterator HISI [HI SI])\n+(define_mode_iterator SFDF [SF DF])\n+\n+;; EQS0/1 for extension source 0/1 and EQD for extension destination patterns.\n+(define_mode_iterator EQS0 [QI HI SI])\n+(define_mode_iterator EQS1 [QI HI SI])\n+(define_mode_iterator EQD [QI HI SI])\n+\n+;; GCC sign-extends its integer constants.  Hence 0x80 will be represented\n+;; as -128 for QI mode and 128 for HI and SI modes.  To cope with this,\n+;; use different constraints to match UBYTE in different modes.\n+;;\n+;; Wherever this iterator is used, the corresponding operand has the 'u'\n+;; print format modifier.  That is how the QI signedness is cured, and\n+;; the generated assembly contains unsigned constants.\n+;;\n+;; If the pattern has no QI operands, then this iterator need not be used.\n+;;\n+;; Note that we do not require \"uhword_constr\" since ALU instructions\n+;; can use only UBYTE constants.  The MOV patterns are already separately\n+;; defined for each size, hence no need for an iterator.\n+(define_mode_attr ubyte_constr [(QI \"O\") (HI \"I\") (SI \"I\")])\n+\f\n+;; Move instructions\n+\n+(define_expand \"mov<mode>\"\n+  [(set (match_operand:MOV8_16_32 0 \"nonimmediate_operand\")\n+\t(match_operand:MOV8_16_32 1 \"general_operand\"))]\n+  \"\"\n+{\n+  /* It helps to split constant loading and memory access\n+     early, so that the LDI/LDI32 instructions can be hoisted\n+     outside a loop body.  */\n+  if (MEM_P (operands[0]))\n+    operands[1] = force_reg (<MODE>mode, operands[1]);\n+})\n+\n+;; Keep a single pattern for 32 bit MOV operations.  LRA requires that the\n+;; movXX patterns be unified for any given mode.\n+;;\n+;; Note: Assume that Program Mem (T constraint) can fit in 16 bits!\n+(define_insn \"prumov<mode>\"\n+  [(set (match_operand:MOV32 0 \"nonimmediate_operand\" \"=m,r,r,r,r,r\")\n+\t(match_operand:MOV32 1 \"general_operand\"      \"r,m,r,T,J,iF\"))]\n+  \"\"\n+  \"@\n+    sb%B0o\\\\t%b1, %0, %S0\n+    lb%B1o\\\\t%b0, %1, %S1\n+    mov\\\\t%0, %1\n+    ldi\\\\t%0, %%pmem(%1)\n+    ldi\\\\t%0, %1\n+    ldi32\\\\t%0, %1\"\n+  [(set_attr \"type\" \"st,ld,alu,alu,alu,alu\")\n+   (set_attr \"length\" \"4,4,4,4,4,8\")])\n+\n+\n+;; Separate pattern for 8 and 16 bit moves, since LDI32 pseudo instruction\n+;; cannot handle byte and word-sized registers.\n+;;\n+;; Note: Constraint N is fine for both QI and HI mode, since it is used\n+;; in the context of 16 bit constant integer.\n+(define_insn \"prumov<mode>\"\n+  [(set (match_operand:MOV8_16 0 \"nonimmediate_operand\" \"=m,r,r,r,r\")\n+\t(match_operand:MOV8_16 1 \"general_operand\"      \"r,m,r,T,N\"))]\n+  \"\"\n+  \"@\n+    sb%B0o\\\\t%b1, %0, %S0\n+    lb%B1o\\\\t%b0, %1, %S1\n+    mov\\\\t%0, %1\n+    ldi\\\\t%0, %%pmem(%1)\n+    ldi\\\\t%0, (%1) & 0xffff\"\n+  [(set_attr \"type\" \"st,ld,alu,alu,alu\")\n+   (set_attr \"length\" \"4\")])\n+\n+\n+; Pmode is 32 bits for PRU so symbolic constants cannot be 64 bits.  Hence\n+; this pattern handles only numeric constants.\n+;\n+; Note: Unlike the arithmetics, here we cannot use \"&\" output modifier.\n+; GCC expects to be able to move registers around \"no matter what\".\n+; Forcing DI reg alignment (akin to microblaze's HARD_REGNO_MODE_OK)\n+; does not seem efficient, and will violate TI ABI.\n+(define_insn \"mov<mode>\"\n+  [(set (match_operand:MOV64 0 \"nonimmediate_operand\" \"=m,r,r,r,r,r\")\n+\t(match_operand:MOV64 1 \"general_operand\"      \"r,m,r,T,J,nF\"))]\n+  \"\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \"sb%B0o\\\\t%b1, %0, %S0\";\n+    case 1:\n+      return \"lb%B1o\\\\t%b0, %1, %S1\";\n+    case 2:\n+      /* careful with overlapping source and destination regs.  */\n+      gcc_assert (GP_REG_P (REGNO (operands[0])));\n+      gcc_assert (GP_REG_P (REGNO (operands[1])));\n+      if (REGNO (operands[0]) == (REGNO (operands[1]) + 4))\n+\treturn \"mov\\\\t%N0, %N1\\;mov\\\\t%F0, %F1\";\n+      else\n+\treturn \"mov\\\\t%F0, %F1\\;mov\\\\t%N0, %N1\";\n+    case 3:\n+      return \"ldi\\\\t%F0, %%pmem(%1)\\;ldi\\\\t%N0, 0\";\n+    case 4:\n+      return \"ldi\\\\t%F0, %1\\;ldi\\\\t%N0, 0\";\n+    case 5:\n+      return \"ldi32\\\\t%F0, %w1\\;ldi32\\\\t%N0, %W1\";\n+    default:\n+      gcc_unreachable ();\n+  }\n+}\n+  [(set_attr \"type\" \"st,ld,alu,alu,alu,alu\")\n+   (set_attr \"length\" \"4,4,8,8,8,16\")])\n+\n+;\n+; load_multiple pattern(s).\n+;\n+; ??? Due to reload problems with replacing registers inside match_parallel\n+; we currently support load_multiple/store_multiple only after reload.\n+;\n+; Idea taken from the s390 port.\n+\n+(define_expand \"load_multiple\"\n+  [(match_par_dup 3 [(set (match_operand 0 \"\")\n+\t\t\t  (match_operand 1 \"\"))\n+\t\t     (use (match_operand 2 \"\"))])]\n+  \"reload_completed\"\n+{\n+  machine_mode mode;\n+  int regno;\n+  int count;\n+  rtx base_reg;\n+  poly_int64 base_offs;\n+  int i;\n+\n+  /* Support only loading a constant number of fixed-point registers from\n+     memory.  */\n+  if (GET_CODE (operands[2]) != CONST_INT\n+      || GET_CODE (operands[1]) != MEM\n+      || GET_CODE (operands[0]) != REG)\n+    FAIL;\n+\n+  count = INTVAL (operands[2]);\n+  regno = REGNO (operands[0]);\n+  mode = GET_MODE (operands[0]);\n+  if (mode != QImode)\n+    FAIL;\n+\n+  operands[3] = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count));\n+\n+  gcc_assert (!can_create_pseudo_p ());\n+\n+  base_reg = strip_offset (XEXP (operands[1], 0), &base_offs);\n+  if (GET_CODE (base_reg) != REG)\n+    FAIL;\n+\n+  for (i = 0; i < count; i++)\n+    XVECEXP (operands[3], 0, i)\n+      = gen_rtx_SET (gen_rtx_REG (mode, regno + i),\n+\t\t     change_address (operands[1], mode,\n+\t\t       plus_constant (Pmode, base_reg,\n+\t\t\t\t      base_offs + i * GET_MODE_SIZE (mode))));\n+})\n+\n+(define_insn \"*pru_load_multiple\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+\t\t   [(set (match_operand:QI 1 \"register_operand\" \"=r\")\n+\t\t\t (match_operand:QI 2 \"memory_operand\"   \"m\"))])]\n+  \"reload_completed\"\n+{\n+  int nregs = XVECLEN (operands[0], 0);\n+  operands[0] = GEN_INT (nregs);\n+  return \"lb%B2o\\\\t%b1, %2, %0\";\n+}\n+  [(set_attr \"type\" \"ld\")])\n+\n+;\n+; store multiple pattern(s).\n+;\n+\n+(define_expand \"store_multiple\"\n+  [(match_par_dup 3 [(set (match_operand 0 \"\")\n+\t\t\t  (match_operand 1 \"\"))\n+\t\t     (use (match_operand 2 \"\"))])]\n+  \"reload_completed\"\n+{\n+  machine_mode mode;\n+  int regno;\n+  int count;\n+  rtx base_reg;\n+  poly_int64 base_offs;\n+  int i;\n+\n+  /* Support only storing a constant number of fixed-point registers to\n+     memory.  */\n+  if (GET_CODE (operands[2]) != CONST_INT\n+      || GET_CODE (operands[0]) != MEM\n+      || GET_CODE (operands[1]) != REG)\n+    FAIL;\n+\n+  count = INTVAL (operands[2]);\n+  regno = REGNO (operands[1]);\n+  mode = GET_MODE (operands[1]);\n+  if (mode != QImode)\n+    FAIL;\n+\n+  operands[3] = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count));\n+\n+  gcc_assert (!can_create_pseudo_p ());\n+\n+  base_reg = strip_offset (XEXP (operands[0], 0), &base_offs);\n+  if (GET_CODE (base_reg) != REG)\n+    FAIL;\n+\n+  for (i = 0; i < count; i++)\n+    XVECEXP (operands[3], 0, i)\n+      = gen_rtx_SET (change_address (operands[0], mode,\n+\t\t       plus_constant (Pmode, base_reg,\n+\t\t\t\t      base_offs + i * GET_MODE_SIZE (mode))),\n+\t\t     gen_rtx_REG (mode, regno + i));\n+})\n+\n+(define_insn \"*pru_store_multiple\"\n+  [(match_parallel 0 \"store_multiple_operation\"\n+\t\t   [(set (match_operand:QI 1 \"memory_operand\"   \"=m\")\n+\t\t\t (match_operand:QI 2 \"register_operand\" \"r\"))])]\n+  \"reload_completed\"\n+{\n+  int nregs = XVECLEN (operands[0], 0);\n+  operands[0] = GEN_INT (nregs);\n+  return \"sb%B1o\\\\t%b2, %1, %0\";\n+}\n+  [(set_attr \"type\" \"st\")])\n+\f\n+;; Zero extension patterns\n+;;\n+;; Unfortunately we cannot use lbbo to load AND zero-extent a value.\n+;; The burst length parameter of the LBBO instruction designates not only\n+;; the number of memory data bytes fetched, but also the number of register\n+;; byte fields written.\n+(define_expand \"zero_extend<EQS0:mode><EQD:mode>2\"\n+  [(set (match_operand:EQD 0 \"register_operand\")\n+\t(zero_extend:EQD (match_operand:EQS0 1 \"register_operand\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*zero_extend<EQS0:mode><EQD:mode>2\"\n+  [(set (match_operand:EQD 0 \"register_operand\" \"=r\")\n+\t(zero_extend:EQD (match_operand:EQS0 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"mov\\\\t%0, %1\"\n+  [(set_attr \"type\"     \"alu\")])\n+\n+;; Sign extension patterns.  We have to emulate them due to lack of\n+;; signed operations in PRU's ALU.\n+\n+(define_insn \"extend<EQS0:mode><EQD:mode>2\"\n+  [(set (match_operand:EQD 0 \"register_operand\"\t\t\t  \"=r\")\n+\t(sign_extend:EQD (match_operand:EQS0 1 \"register_operand\"  \"r\")))]\n+  \"\"\n+{\n+  return pru_output_sign_extend (operands);\n+}\n+  [(set_attr \"type\" \"complex\")\n+   (set_attr \"length\" \"12\")])\n+\f\n+;; Bit extraction\n+;; We define it solely to allow combine to choose SImode\n+;; for word mode when trying to match our cbranch_qbbx_* insn.\n+;;\n+;; Check how combine.c:make_extraction() uses\n+;; get_best_reg_extraction_insn() to select the op size.\n+(define_insn \"extzv<mode>\"\n+  [(set (match_operand:QISI 0 \"register_operand\"\t\"=r\")\n+\t  (zero_extract:QISI\n+\t   (match_operand:QISI 1 \"register_operand\"\t\"r\")\n+\t   (match_operand:QISI 2 \"const_int_operand\"\t\"i\")\n+\t   (match_operand:QISI 3 \"const_int_operand\"\t\"i\")))]\n+  \"\"\n+  \"lsl\\\\t%0, %1, (%S0 * 8 - %2 - %3)\\;lsr\\\\t%0, %0, (%S0 * 8 - %2)\"\n+  [(set_attr \"type\" \"complex\")\n+   (set_attr \"length\" \"8\")])\n+\n+\n+\f\n+;; Arithmetic Operations\n+\n+(define_expand \"add<mode>3\"\n+  [(set (match_operand:QISI 0 \"register_operand\")\n+\t(plus:QISI (match_operand:QISI 1 \"register_operand\")\n+\t\t (match_operand:QISI 2 \"nonmemory_operand\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"adddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\"\t\t    \"=&r,&r,&r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\"\t    \"%r,r,r\")\n+\t\t (match_operand:DI 2 \"reg_or_ubyte_operand\" \"r,I,M\")))]\n+  \"\"\n+  \"@\n+   add\\\\t%F0, %F1, %F2\\;adc\\\\t%N0, %N1, %N2\n+   add\\\\t%F0, %F1, %2\\;adc\\\\t%N0, %N1, 0\n+   sub\\\\t%F0, %F1, %n2\\;suc\\\\t%N0, %N1, 0\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_expand \"sub<mode>3\"\n+  [(set (match_operand:QISI 0 \"register_operand\")\n+\t(minus:QISI (match_operand:QISI 1 \"reg_or_ubyte_operand\")\n+\t\t    (match_operand:QISI 2 \"reg_or_ubyte_operand\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"subdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\"\t\t      \"=&r,&r\")\n+\t(minus:DI (match_operand:DI 1 \"reg_or_ubyte_operand\"  \"r,I\")\n+\t\t  (match_operand:DI 2 \"register_operand\"      \"r,r\")))]\n+  \"\"\n+  \"@\n+   sub\\\\t%F0, %F1, %F2\\;suc\\\\t%N0, %N1, %N2\n+   rsb\\\\t%F0, %F2, %1\\;rsc\\\\t%N0, %N2, 0\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"length\" \"8\")])\n+\f\n+;;  Negate and ones complement\n+\n+(define_expand \"neg<mode>2\"\n+  [(set (match_operand:QISI 0 \"register_operand\")\n+\t(neg:QISI (match_operand:QISI 1 \"register_operand\")))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"one_cmpl<mode>2\"\n+  [(set (match_operand:QISI 0 \"register_operand\")\n+\t(not:QISI (match_operand:QISI 1 \"register_operand\")))]\n+  \"\"\n+  \"\")\n+\f\n+;;  Integer logical Operations\n+;;\n+;; TODO - add optimized cases that exploit the fact that we can get away\n+;; with a single machine op for special constants, e.g. UBYTE << (0/8/16/24)\n+\n+(define_code_iterator LOGICAL [and ior xor umin umax])\n+(define_code_attr logical_asm [(and \"and\") (ior \"or\") (xor \"xor\") (umin \"min\") (umax \"max\")])\n+\n+(define_code_iterator LOGICAL_BITOP [and ior xor])\n+(define_code_attr logical_bitop_asm [(and \"and\") (ior \"or\") (xor \"xor\")])\n+\n+(define_expand \"<code><mode>3\"\n+  [(set (match_operand:QISI 0 \"register_operand\")\n+\t(LOGICAL:QISI (match_operand:QISI 1 \"register_operand\")\n+\t\t      (match_operand:QISI 2 \"reg_or_ubyte_operand\")))]\n+  \"\"\n+  \"\")\n+\n+\f\n+;;  Shift instructions\n+\n+(define_code_iterator SHIFT  [ashift lshiftrt])\n+(define_code_attr shift_op   [(ashift \"ashl\") (lshiftrt \"lshr\")])\n+(define_code_attr shift_asm  [(ashift \"lsl\") (lshiftrt \"lsr\")])\n+\n+(define_expand \"<shift_op><mode>3\"\n+  [(set (match_operand:QISI 0 \"register_operand\")\n+\t(SHIFT:QISI (match_operand:QISI 1 \"register_operand\")\n+\t\t    (match_operand:QISI 2 \"shift_operand\")))]\n+  \"\"\n+  \"\")\n+\n+; Expand to a loop of single-position arithmetic shifts, which\n+; we can handle.  Pseudo code:\n+;     tmpval = src;\n+;     QImode cntr = nshifts & 0xff;\n+;     while (cntr)\n+;       {\n+;         tmpval >>= 1;\n+;         cntr--;\n+;       }\n+;     dst = tmpval;\n+;\n+; Note that the number of shifts is truncated to QImode.  This is a fair\n+; assumption for a loop-based shifting implementation.\n+(define_expand \"ashr<mode>3\"\n+  [(set (match_operand:QISI 0 \"register_operand\")\n+\t  (ashiftrt:QISI\n+\t    (match_operand:QISI 1 \"register_operand\")\n+\t    (match_operand:QI 2 \"reg_or_const_1_operand\")))]\n+  \"\"\n+{\n+  rtx dst = operands[0];\n+  rtx src = operands[1];\n+  rtx nshifts = operands[2];\n+  rtx_code_label *loop_label;\n+  rtx_code_label *ashr_end_label;\n+  rtx test, tmpval, cntr;\n+\n+  if (const_1_operand (nshifts, VOIDmode))\n+    {\n+      emit_insn (gen_ashr<mode>3_single (dst, src, nshifts));\n+      DONE;\n+    }\n+\n+  tmpval = gen_reg_rtx (<MODE>mode);\n+  emit_move_insn (tmpval, src);\n+\n+  cntr = gen_reg_rtx (QImode);\n+  emit_move_insn (cntr, nshifts);\n+\n+  loop_label = gen_label_rtx ();\n+  ashr_end_label = gen_label_rtx ();\n+\n+  emit_label (loop_label);\n+  test = gen_rtx_EQ (VOIDmode, cntr, const0_rtx);\n+  emit_jump_insn (gen_cbranchqi4 (test, cntr, const0_rtx, ashr_end_label));\n+\n+  emit_insn (gen_ashr<mode>3_single (tmpval, tmpval, const1_rtx));\n+  emit_insn (gen_addqi3 (cntr, cntr, GEN_INT (-1)));\n+\n+  emit_jump_insn (gen_jump (loop_label));\n+  JUMP_LABEL (get_last_insn ()) = loop_label;\n+  LABEL_NUSES (loop_label)++;\n+  emit_barrier ();\n+\n+  emit_label (ashr_end_label);\n+\n+  emit_move_insn (dst, tmpval);\n+\n+  DONE;\n+})\n+\n+(define_insn \"ashr<mode>3_single\"\n+  [(set (match_operand:QISI 0 \"register_operand\"\t\"=r\")\n+\t  (ashiftrt:QISI\n+\t    (match_operand:QISI 1 \"register_operand\"\t\"r\")\n+\t    (match_operand:QI 2 \"const_1_operand\"\t\"P\")))]\n+  \"\"\n+  \"lsr\\\\t%0, %1, 1\\;qbbc LSIGN%=, %0, (%S0 * 8) - 2\\;set %0, %0, (%S0 * 8) - 1\\;LSIGN%=:\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"length\" \"12\")])\n+\n+\f\n+;; Include ALU patterns with zero-extension of operands.  That's where\n+;; the real insns are defined.\n+\n+(include \"alu-zext.md\")\n+\f\n+;; DI logical ops could be automatically split into WORD-mode ops in\n+;; expand_binop().  But then we'll miss an opportunity to use SI mode\n+;; operations, since WORD mode for PRU is QI.\n+(define_insn \"<code>di3\"\n+  [(set (match_operand:DI 0 \"register_operand\"\t\t\"=&r,&r\")\n+\t  (LOGICAL_BITOP:DI\n+\t    (match_operand:DI 1 \"register_operand\"\t\"%r,r\")\n+\t    (match_operand:DI 2 \"reg_or_ubyte_operand\"\t\"r,I\")))]\n+  \"\"\n+  \"@\n+   <logical_bitop_asm>\\\\t%F0, %F1, %F2\\;<logical_bitop_asm>\\\\t%N0, %N1, %N2\n+   <logical_bitop_asm>\\\\t%F0, %F1, %2\\;<logical_bitop_asm>\\\\t%N0, %N1, 0\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"length\" \"8\")])\n+\n+\n+(define_insn \"one_cmpldi2\"\n+  [(set (match_operand:DI 0 \"register_operand\"\t\t\"=r\")\n+\t(not:DI (match_operand:DI 1 \"register_operand\"\t\"r\")))]\n+  \"\"\n+{\n+  /* careful with overlapping source and destination regs.  */\n+  gcc_assert (GP_REG_P (REGNO (operands[0])));\n+  gcc_assert (GP_REG_P (REGNO (operands[1])));\n+  if (REGNO (operands[0]) == (REGNO (operands[1]) + 4))\n+    return \"not\\\\t%N0, %N1\\;not\\\\t%F0, %F1\";\n+  else\n+    return \"not\\\\t%F0, %F1\\;not\\\\t%N0, %N1\";\n+}\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"length\" \"8\")])\n+\f\n+;; Multiply instruction.  The nop is required to ensure that Rmd0 and Rms0\n+;; registers are sampled and multiplication is executed on those values.\n+;; Only after that one cycle can xin obtain the result.\n+\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"pru_muldst_operand\"\t   \"=Rmd0\")\n+\t(mult:SI (match_operand:SI 1 \"pru_mulsrc0_operand\" \"%Rms0\")\n+\t\t (match_operand:SI 2 \"pru_mulsrc1_operand\" \"Rms1\")))]\n+  \"\"\n+  \"nop\\;xin\\\\t0, %0, 4\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"length\" \"8\")])\n+\f\n+;; Prologue, Epilogue and Return\n+\n+(define_expand \"prologue\"\n+  [(const_int 1)]\n+  \"\"\n+{\n+  pru_expand_prologue ();\n+  DONE;\n+})\n+\n+(define_expand \"epilogue\"\n+  [(return)]\n+  \"\"\n+{\n+  pru_expand_epilogue (false);\n+  DONE;\n+})\n+\n+(define_expand \"sibcall_epilogue\"\n+  [(return)]\n+  \"\"\n+{\n+  pru_expand_epilogue (true);\n+  DONE;\n+})\n+\n+(define_insn \"return\"\n+  [(simple_return)]\n+  \"pru_can_use_return_insn ()\"\n+  \"ret\")\n+\n+(define_insn \"simple_return\"\n+  [(simple_return)]\n+  \"\"\n+  \"ret\")\n+\n+;; Block any insns from being moved before this point, since the\n+;; profiling call to mcount can use various registers that aren't\n+;; saved or used to pass arguments.\n+\n+(define_insn \"blockage\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_BLOCKAGE)]\n+  \"\"\n+  \"\"\n+  [(set_attr \"type\" \"unknown\")\n+   (set_attr \"length\" \"0\")])\n+\f\n+;;  Jumps and calls\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"jmp\\\\t%0\"\n+  [(set_attr \"type\" \"control\")])\n+\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0)))]\n+  \"\"\n+  \"jmp\\\\t%%label(%l0)\"\n+  [(set_attr \"type\" \"control\")])\n+\n+\n+(define_expand \"call\"\n+  [(parallel [(call (match_operand 0 \"\")\n+\t\t    (match_operand 1 \"\"))\n+\t      (clobber (reg:HI RA_REGNUM))])]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"call_value\"\n+  [(parallel [(set (match_operand 0 \"\")\n+\t\t   (call (match_operand 1 \"\")\n+\t\t\t (match_operand 2 \"\")))\n+\t      (clobber (reg:HI RA_REGNUM))])]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*call\"\n+  [(call (mem:SI (match_operand:SI 0 \"call_operand\" \"i,r\"))\n+\t (match_operand 1))\n+   (clobber (reg:HI RA_REGNUM))]\n+  \"\"\n+  \"@\n+    call\\\\t%%label(%0)\n+    call\\\\t%0\"\n+  [(set_attr \"type\" \"control\")])\n+\n+(define_insn \"*call_value\"\n+  [(set (match_operand 0)\n+\t(call (mem:SI (match_operand:SI 1 \"call_operand\" \"i,r\"))\n+\t      (match_operand 2)))\n+   (clobber (reg:HI RA_REGNUM))]\n+  \"\"\n+  \"@\n+    call\\\\t%%label(%1)\n+    call\\\\t%1\"\n+  [(set_attr \"type\" \"control\")])\n+\n+(define_expand \"sibcall\"\n+  [(parallel [(call (match_operand 0 \"\")\n+\t\t    (match_operand 1 \"\"))\n+\t      (return)])]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"sibcall_value\"\n+  [(parallel [(set (match_operand 0 \"\")\n+\t\t   (call (match_operand 1 \"\")\n+\t\t\t (match_operand 2 \"\")))\n+\t      (return)])]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*sibcall\"\n+ [(call (mem:SI (match_operand:SI 0 \"call_operand\" \"i,Rsib\"))\n+\t(match_operand 1))\n+  (return)]\n+  \"SIBLING_CALL_P (insn)\"\n+  \"@\n+    jmp\\\\t%%label(%0)\n+    jmp\\\\t%0\"\n+  [(set_attr \"type\" \"control\")])\n+\n+(define_insn \"*sibcall_value\"\n+ [(set (match_operand 0 \"register_operand\" \"\")\n+       (call (mem:SI (match_operand:SI 1 \"call_operand\" \"i,Rsib\"))\n+\t     (match_operand 2)))\n+  (return)]\n+  \"SIBLING_CALL_P (insn)\"\n+  \"@\n+    jmp\\\\t%%label(%1)\n+    jmp\\\\t%1\"\n+  [(set_attr \"type\" \"control\")])\n+\n+(define_insn \"*tablejump\"\n+  [(set (pc)\n+\t(match_operand:SI 0 \"register_operand\" \"r\"))\n+   (use (label_ref (match_operand 1)))]\n+  \"\"\n+  \"jmp\\\\t%0\"\n+  [(set_attr \"type\" \"control\")])\n+\f\n+;; Expand the cbranch pattern in order to assign different constraints for\n+;; signed and unsigned comparisons.\n+(define_expand \"cbranch<mode>4\"\n+  [(set (pc)\n+     (if_then_else\n+       (match_operator 0 \"ordered_comparison_operator\"\n+\t [(match_operand:QISI 1 \"register_operand\")\n+\t  (match_operand:QISI 2 \"reg_or_const_int_operand\")])\n+       (label_ref (match_operand 3 \"\"))\n+       (pc)))]\n+  \"\"\n+{\n+  /* Ensure our patterns will be able to handle the particular const_int.  */\n+  if (CONST_INT_P (operands[2]))\n+    {\n+      HOST_WIDE_INT ival = INTVAL (operands[2]);\n+\n+      /* For signed comparisons, we cannot play games with the const_int's\n+\t sign.  PRU patterns do not support negative integer constants.  */\n+      if (pru_signed_cmp_operator (operands[0], VOIDmode) && !UBYTE_INT (ival))\n+\t{\n+\t  if (can_create_pseudo_p ())\n+\t    operands[2] = force_reg (<MODE>mode, operands[2]);\n+\t  else\n+\t    FAIL;\n+\t}\n+\n+      /* For unsigned comparisons, be prepared to handle the QI quirk.  */\n+      if (pru_cmp_operator (operands[0], VOIDmode)\n+\t  && !const_ubyte_operand (operands[2], <MODE>mode))\n+\t{\n+\t  if (can_create_pseudo_p ())\n+\t    operands[2] = force_reg (<MODE>mode, operands[2]);\n+\t  else\n+\t    FAIL;\n+\t}\n+    }\n+})\n+\n+(define_insn \"cbranch<mode>4_unsigned\"\n+  [(set (pc)\n+     (if_then_else\n+       (match_operator 0 \"pru_cmp_operator\"\n+\t [(match_operand:QISI 1 \"register_operand\" \"r\")\n+\t  (match_operand:QISI 2 \"reg_or_ubyte_operand\" \"r<QISI:ubyte_constr>\")])\n+       (label_ref (match_operand 3))\n+       (pc)))]\n+  \"\"\n+{\n+  const bool is_near = (get_attr_length (insn) == 4);\n+\n+  /* PRU comparisons reverse the operand order (OP2 cmp OP1),\n+     so swap the condition.  */\n+  if (is_near)\n+    return \"qb%P0\\t%l3, %1, %u2\";\n+  else\n+    return \"qb%Q0\\t.+8, %1, %u2\\;jmp\\t%%label(%l3)\";\n+}\n+  [(set_attr \"type\" \"control\")\n+   (set (attr \"length\")\n+\t(if_then_else\n+\t    (and (ge (minus (match_dup 3) (pc)) (const_int -2040))\n+\t\t (le (minus (match_dup 3) (pc)) (const_int 2036)))\n+\t    (const_int 4)\n+\t    (const_int 8)))])\n+\n+;; Unlike ALU operations, the const_int's sign here is important.  So we\n+;; cannot use ubyte_constr.\n+;;\n+;; NOTE: The short branch check has no typo!  We must be conservative and\n+;; take into account the worst case of having a signed comparison with a\n+;; \"far taken branch\" label, which amounts to 7 instructions.\n+(define_insn \"cbranch<mode>4_signed\"\n+  [(set (pc)\n+     (if_then_else\n+       (match_operator 0 \"pru_signed_cmp_operator\"\n+\t [(match_operand:QISI 1 \"register_operand\" \"r,r,r\")\n+\t  (match_operand:QISI 2 \"reg_or_ubyte_operand\" \"r,Z,I\")])\n+       (label_ref (match_operand 3))\n+       (pc)))]\n+  \"\"\n+{\n+  const int length = (get_attr_length (insn));\n+  const bool is_near = (length == 20);\n+  enum rtx_code code = GET_CODE (operands[0]);\n+\n+  if (which_alternative == 0)\n+    return pru_output_signed_cbranch (operands, is_near);\n+  else if (which_alternative == 1 && (code == LT || code == GE))\n+    return pru_output_signed_cbranch_zeroop2 (operands, is_near);\n+  else\n+    return pru_output_signed_cbranch_ubyteop2 (operands, is_near);\n+}\n+  [(set_attr \"type\" \"control\")\n+   (set (attr \"length\")\n+\t(if_then_else\n+\t    (and (ge (minus (match_dup 3) (pc)) (const_int -2020))\n+\t\t (le (minus (match_dup 3) (pc)) (const_int 2016)))\n+\t    (const_int 20)\n+\t    (const_int 28)))])\n+\n+(define_expand \"cbranch<mode>4\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"pru_fp_comparison_operator\"\n+\t\t       [(match_operand:SFDF 1 \"register_operand\")\n+\t\t\t(match_operand:SFDF 2 \"register_operand\")])\n+\t\t      (label_ref (match_operand 3 \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+{\n+  rtx t = pru_expand_fp_compare (operands[0], VOIDmode);\n+  operands[0] = t;\n+  operands[1] = XEXP (t, 0);\n+  operands[2] = XEXP (t, 1);\n+})\n+\n+;\n+; Bit test branch\n+\n+(define_code_iterator BIT_TEST  [eq ne])\n+(define_code_attr qbbx_op   [(eq \"qbbc\") (ne \"qbbs\")])\n+(define_code_attr qbbx_negop   [(eq \"qbbs\") (ne \"qbbc\")])\n+\n+(define_insn \"cbranch_qbbx_<BIT_TEST:code><EQS0:mode><EQS1:mode><EQD:mode>4\"\n+ [(set (pc)\n+   (if_then_else\n+    (BIT_TEST (zero_extract:EQD\n+\t (match_operand:EQS0 0 \"register_operand\" \"r\")\n+\t (const_int 1)\n+\t (match_operand:EQS1 1 \"reg_or_ubyte_operand\" \"r<EQS1:ubyte_constr>\"))\n+     (const_int 0))\n+    (label_ref (match_operand 2))\n+    (pc)))]\n+  \"\"\n+{\n+  const int length = (get_attr_length (insn));\n+  const bool is_near = (length == 4);\n+  if (is_near)\n+    return \"<BIT_TEST:qbbx_op>\\\\t%l2, %0, %u1\";\n+  else\n+    return \"<BIT_TEST:qbbx_negop>\\\\t.+8, %0, %u1\\;jmp\\\\t%%label(%l2)\";\n+}\n+  [(set_attr \"type\" \"control\")\n+   (set (attr \"length\")\n+      (if_then_else\n+\t  (and (ge (minus (match_dup 2) (pc)) (const_int -2048))\n+\t       (le (minus (match_dup 2) (pc)) (const_int 2044)))\n+\t  (const_int 4)\n+\t  (const_int 8)))])\n+\f\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: Low Overhead Looping - idea \"borrowed\" from MEP\n+;; ::\n+;; ::::::::::::::::::::\n+\n+;; This insn is volatile because we'd like it to stay in its original\n+;; position, just before the loop header.  If it stays there, we might\n+;; be able to convert it into a \"loop\" insn.\n+(define_insn \"doloop_begin_internal<mode>\"\n+  [(set (match_operand:HISI 0 \"register_operand\" \"=r\")\n+\t(unspec_volatile:HISI\n+\t [(match_operand:HISI 1 \"reg_or_ubyte_operand\" \"rI\")\n+\t  (match_operand 2 \"const_int_operand\" \"\")] UNSPECV_LOOP_BEGIN))]\n+  \"\"\n+{\n+  gcc_unreachable ();\n+})\n+\n+(define_expand \"doloop_begin\"\n+  [(use (match_operand 0 \"register_operand\"))\n+   (use (match_operand 1 \"\"))]\n+  \"TARGET_OPT_LOOP\"\n+{\n+  pru_emit_doloop (operands, 0);\n+  DONE;\n+})\n+\n+; Note: \"JUMP_INSNs and CALL_INSNs are not allowed to have any output\n+; reloads;\".  Hence this insn must be prepared for a counter that is\n+; not a register.\n+(define_insn \"doloop_end_internal<mode>\"\n+  [(set (pc)\n+\t(if_then_else (ne (match_operand:HISI 0 \"nonimmediate_operand\" \"+r,*m\")\n+\t\t\t  (const_int 1))\n+\t\t      (label_ref (match_operand 1))\n+\t\t      (pc)))\n+   (set (match_dup 0)\n+\t(plus:HISI (match_dup 0)\n+\t\t (const_int -1)))\n+   (unspec [(match_operand 2 \"const_int_operand\" \"\")] UNSPECV_LOOP_END)\n+   (clobber (match_scratch:HISI 3 \"=X,&r\"))]\n+  \"\"\n+{\n+  gcc_unreachable ();\n+}\n+  ;; Worst case length:\n+  ;;\n+  ;;\t  lbbo op3_reg, op3_ptr\t  4'\n+  ;;\t  sub <op3_reg>, 1\t  4\n+  ;;\t  qbeq .+8, <op3_reg>, 0  4\n+  ;;\t  jmp <op1>\t\t  4\n+  ;;\t  sbbo op3_reg, op3_ptr\t  4\n+  [(set (attr \"length\")\n+      (if_then_else\n+\t(and (ge (minus (pc) (match_dup 1)) (const_int 0))\n+\t     (le (minus (pc) (match_dup 1)) (const_int 1020)))\n+\t(cond [(eq_attr \"alternative\" \"0\") (const_int 4)]\n+\t       (const_int 12))\n+\t(cond [(eq_attr \"alternative\" \"0\") (const_int 12)]\n+\t       (const_int 20))))])\n+\n+(define_expand \"doloop_end\"\n+  [(use (match_operand 0 \"nonimmediate_operand\"))\n+   (use (label_ref (match_operand 1 \"\")))]\n+  \"TARGET_OPT_LOOP\"\n+{\n+  if (GET_CODE (operands[0]) == REG && GET_MODE (operands[0]) == QImode)\n+    FAIL;\n+  pru_emit_doloop (operands, 1);\n+  DONE;\n+})\n+\n+(define_insn \"pruloop<mode>\"\n+  [(set (reg:HISI LOOPCNTR_REGNUM)\n+\t(unspec:HISI [(match_operand:HISI 0 \"reg_or_ubyte_operand\" \"rI\")\n+\t\t    (label_ref (match_operand 1))]\n+\t\t   UNSPECV_LOOP_BEGIN))]\n+  \"\"\n+  \"loop\\\\t%l1, %0\")\n+\n+(define_insn \"pruloop_end\"\n+  [(unspec [(const_int 0)] UNSPECV_LOOP_END)]\n+  \"\"\n+  \"# loop end\"\n+  [(set_attr \"length\" \"0\")])\n+\n+\f\n+;;  Misc patterns\n+\n+(define_insn \"delay_cycles_start\"\n+  [(unspec_volatile [(match_operand 0 \"immediate_operand\" \"i\")]\n+\t\t    UNSPECV_DELAY_CYCLES_START)]\n+  \"\"\n+  \"/* Begin %0 cycle delay.  */\"\n+  [(set_attr \"length\" \"0\")])\n+\n+(define_insn \"delay_cycles_end\"\n+  [(unspec_volatile [(match_operand 0 \"immediate_operand\" \"i\")]\n+\t\t    UNSPECV_DELAY_CYCLES_END)]\n+  \"\"\n+  \"/* End %0 cycle delay.  */\"\n+  [(set_attr \"length\" \"0\")])\n+\n+\n+(define_insn \"delay_cycles_2x_plus1_hi\"\n+  [(unspec_volatile [(match_operand:SI 0 \"const_uhword_operand\" \"J\")]\n+\t\t    UNSPECV_DELAY_CYCLES_2X_HI)\n+   (clobber (match_scratch:SI 1 \"=&r\"))]\n+  \"\"\n+  \"ldi\\\\t%1, %0\\;sub\\\\t%1, %1, 1\\;qbne\\\\t.-4, %1, 0\"\n+  [(set_attr \"length\" \"12\")])\n+\n+\n+; Do not use LDI32 here because we do not want\n+; to accidentally loose one instruction cycle.\n+(define_insn \"delay_cycles_2x_plus2_si\"\n+  [(unspec_volatile [(match_operand:SI 0 \"const_int_operand\" \"n\")]\n+\t\t    UNSPECV_DELAY_CYCLES_2X_SI)\n+   (clobber (match_scratch:SI 1 \"=&r\"))]\n+  \"\"\n+  \"ldi\\\\t%1.w0, %L0\\;ldi\\\\t%1.w2, %H0\\;sub\\\\t%1, %1, 1\\;qbne\\\\t.-4, %1, 0\"\n+  [(set_attr \"length\" \"16\")])\n+\n+(define_insn \"delay_cycles_1\"\n+  [(unspec_volatile [(const_int 0) ] UNSPECV_DELAY_CYCLES_1)]\n+  \"\"\n+  \"nop\\\\t# delay_cycles_1\"\n+)\n+\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\"\n+  [(set_attr \"type\" \"alu\")])\n+\n+(define_insn \"nop_loop_guard\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\\\\t# Loop end guard\"\n+  [(set_attr \"type\" \"alu\")])"}, {"sha": "9bc14745047eedb2f1471da11049171a35b51704", "filename": "gcc/config/pru/pru.opt", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fconfig%2Fpru%2Fpru.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fconfig%2Fpru%2Fpru.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpru.opt?ref=8d2af3a25bdb6b7996e0a55551ae0fd599e1739b", "patch": "@@ -0,0 +1,54 @@\n+; Options for the TI PRU port of the compiler.\n+; Copyright (C) 2018-2019 Free Software Foundation, Inc.\n+; Contributed by Dimitar Dimitrov <dimitar@dinux.eu>\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify\n+; it under the terms of the GNU General Public License as published by\n+; the Free Software Foundation; either version 3, or (at your option)\n+; any later version.\n+;\n+; GCC is distributed in the hope that it will be useful,\n+; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+; GNU General Public License for more details.\n+;\n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING3.  If not see\n+; <http://www.gnu.org/licenses/>.\n+\n+HeaderInclude\n+config/pru/pru-opts.h\n+\n+minrt\n+Target Report Mask(MINRT) RejectNegative\n+Use a minimum runtime (no static initializers or ctors) for memory-constrained\n+devices.\n+\n+mmcu=\n+Target RejectNegative Joined\n+-mmcu=MCU\tSelect the target System-On-Chip variant that embeds this PRU.\n+\n+mno-relax\n+Target Report RejectNegative\n+Make GCC pass the --no-relax command-line option to the linker instead of\n+the --relax option.\n+\n+mloop\n+Target Mask(OPT_LOOP)\n+Allow (or do not allow) gcc to use the LOOP instruction.\n+\n+mabi=\n+Target RejectNegative Report Joined Enum(pru_abi_t) Var(pru_current_abi) Init(PRU_ABI_GNU) Save\n+Select target ABI variant.\n+\n+Enum\n+Name(pru_abi_t) Type(enum pru_abi)\n+ABI variant code generation (for use with -mabi= option):\n+\n+EnumValue\n+Enum(pru_abi_t) String(gnu) Value(PRU_ABI_GNU)\n+\n+EnumValue\n+Enum(pru_abi_t) String(ti) Value(PRU_ABI_TI)"}, {"sha": "cfb0368edbce2918b55ad389c3e0b9f0f918364d", "filename": "gcc/config/pru/t-pru", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fconfig%2Fpru%2Ft-pru", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fconfig%2Fpru%2Ft-pru", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Ft-pru?ref=8d2af3a25bdb6b7996e0a55551ae0fd599e1739b", "patch": "@@ -0,0 +1,31 @@\n+# Makefile fragment for building GCC for the TI PRU target.\n+# Copyright (C) 2012-2019 Free Software Foundation, Inc.\n+# Contributed by Dimitar Dimitrov <dimitar.dinux.eu>\n+# Based on the t-nios2\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published\n+# by the Free Software Foundation; either version 3, or (at your\n+# option) any later version.\n+#\n+# GCC is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n+# the GNU General Public License for more details.\n+#\n+# You should have received a copy of the  GNU General Public\n+# License along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Unfortunately mabi=ti is not feature-complete enough to build newlib.\n+# Hence we cannot present mabi=gnu/ti as a multilib option.\n+\n+pru-pragma.o: $(srcdir)/config/pru/pru-pragma.c $(RTL_H) $(TREE_H) \\\n+\t\t$(CONFIG_H) $(TM_H) $(srcdir)/config/pru/pru-protos.h\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<\n+\n+pru-passes.o: $(srcdir)/config/pru/pru-passes.c $(RTL_H) $(TREE_H) \\\n+\t\t$(CONFIG_H) $(TM_H) $(srcdir)/config/pru/pru-protos.h\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<"}, {"sha": "a87bfe1c05ed178052ce06e8991bdf9237952090", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=8d2af3a25bdb6b7996e0a55551ae0fd599e1739b", "patch": "@@ -23039,6 +23039,7 @@ information.\n * ARM Pragmas::\n * M32C Pragmas::\n * MeP Pragmas::\n+* PRU Pragmas::\n * RS/6000 and PowerPC Pragmas::\n * S/390 Pragmas::\n * Darwin Pragmas::\n@@ -23190,6 +23191,26 @@ extern int foo ();\n \n @end table\n \n+@node PRU Pragmas\n+@subsection PRU Pragmas\n+\n+@table @code\n+\n+@item ctable_entry @var{index} @var{constant_address}\n+@cindex pragma, ctable_entry\n+Specifies that the PRU CTABLE entry given by @var{index} has the value\n+@var{constant_address}.  This enables GCC to emit LBCO/SBCO instructions\n+when the load/store address is known and can be addressed with some CTABLE\n+entry.  For example:\n+\n+@smallexample\n+/* will compile to \"sbco Rx, 2, 0x10, 4\" */\n+#pragma ctable_entry 2 0x4802a000\n+*(unsigned int *)0x4802a010 = val;\n+@end smallexample\n+\n+@end table\n+\n @node RS/6000 and PowerPC Pragmas\n @subsection RS/6000 and PowerPC Pragmas\n "}, {"sha": "090d606b3ba68cc8ad86e2c68dcb647f1b0767c7", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=8d2af3a25bdb6b7996e0a55551ae0fd599e1739b", "patch": "@@ -1045,6 +1045,10 @@ Objective-C and Objective-C++ Dialects}.\n @emph{PowerPC Options}\n See RS/6000 and PowerPC Options.\n \n+@emph{PRU Options}\n+@gccoptlist{-mmcu=@var{mcu}  -minrt  -mno-relax  -mloop @gol\n+-mabi=@var{variant} @gol}\n+\n @emph{RISC-V Options}\n @gccoptlist{-mbranch-cost=@var{N-instruction} @gol\n -mplt  -mno-plt @gol\n@@ -15588,6 +15592,7 @@ platform.\n * PDP-11 Options::\n * picoChip Options::\n * PowerPC Options::\n+* PRU Options::\n * RISC-V Options::\n * RL78 Options::\n * RS/6000 and PowerPC Options::\n@@ -23763,6 +23768,66 @@ these warnings.\n \n These are listed under @xref{RS/6000 and PowerPC Options}.\n \n+@node PRU Options\n+@subsection PRU Options\n+@cindex PRU Options\n+\n+These command-line options are defined for PRU target:\n+\n+@table @gcctabopt\n+@item -minrt\n+@opindex minrt\n+Link with a minimum runtime environment, with no support for static\n+initializers and constructors.  Using this option can significantly reduce\n+the size of the final ELF binary.  Beware that the compiler could still\n+generate code with static initializers and constructors.  It is up to the\n+programmer to ensure that the source program will not use those features.\n+\n+@item -mmcu=@var{mcu}\n+@opindex mmcu\n+Specify the PRU MCU variant to use.  Check Newlib for the exact list of\n+supported MCUs.\n+\n+@item -mno-relax\n+@opindex mno-relax\n+Make GCC pass the @option{--no-relax} command-line option to the linker\n+instead of the @option{--relax} option.\n+\n+@item -mloop\n+@opindex mloop\n+Allow (or do not allow) GCC to use the LOOP instruction.\n+\n+@item -mabi=@var{variant}\n+@opindex mabi\n+Specify the ABI variant to output code for.  @option{-mabi=ti} selects the\n+unmodified TI ABI while @option{-mabi=gnu} selects a GNU variant that copes\n+more naturally with certain GCC assumptions.  These are the differences:\n+\n+@table @samp\n+@item Function Pointer Size\n+TI ABI specifies that function (code) pointers are 16-bit, whereas GNU\n+supports only 32-bit data and code pointers.\n+\n+@item Optional Return Value Pointer\n+Function return values larger than 64 bits are passed by using a hidden\n+pointer as the first argument of the function.  TI ABI, though, mandates that\n+the pointer can be NULL in case the caller is not using the returned value.\n+GNU always passes and expects a valid return value pointer.\n+\n+@end table\n+\n+The current @option{-mabi=ti} implementation simply raises a compile error\n+when any of the above code constructs is detected.  As a consequence\n+the standard C library cannot be built and it is omitted when linking with\n+@option{-mabi=ti}.\n+\n+Relaxation is a GNU feature and for safety reasons is disabled when using\n+@option{-mabi=ti}.  The TI toolchain does not emit relocations for QBBx\n+instructions, so the GNU linker cannot adjust them when shortening adjacent\n+LDI32 pseudo instructions.\n+\n+@end table\n+\n @node RISC-V Options\n @subsection RISC-V Options\n @cindex RISC-V Options"}, {"sha": "844fb6ef18dd4d8176977248e8407ee5263ed072", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2af3a25bdb6b7996e0a55551ae0fd599e1739b/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=8d2af3a25bdb6b7996e0a55551ae0fd599e1739b", "patch": "@@ -3400,6 +3400,25 @@ Vector constant that is all zeros.\n \n @end table\n \n+@item PRU---@file{config/pru/constraints.md}\n+@table @code\n+@item I\n+An unsigned 8-bit integer constant.\n+\n+@item J\n+An unsigned 16-bit integer constant.\n+\n+@item L\n+An unsigned 5-bit integer constant (for shift counts).\n+\n+@item T\n+A text segment (program memory) constant label.\n+\n+@item Z\n+Integer constant zero.\n+\n+@end table\n+\n @item RL78---@file{config/rl78/constraints.md}\n @table @code\n "}]}