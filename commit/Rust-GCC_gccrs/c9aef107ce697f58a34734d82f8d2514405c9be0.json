{"sha": "c9aef107ce697f58a34734d82f8d2514405c9be0", "node_id": "C_kwDOANBUbNoAKGM5YWVmMTA3Y2U2OTdmNThhMzQ3MzRkODJmOGQyNTE0NDA1YzliZTA", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2023-02-03T15:52:18Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2023-02-03T15:52:18Z"}, "message": "libstdc++: Implement ranges::find_last{,_if,_if_not} from P1223R5\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/ranges_algo.h (__find_last_fn, find_last):\n\tDefine.\n\t(__find_last_if_fn, find_last_if): Define.\n\t(__find_last_if_not_fn, find_last_if_not): Define.\n\t* testsuite/25_algorithms/find_last/1.cc: New test.\n\t* testsuite/25_algorithms/find_last_if/1.cc: New test.\n\t* testsuite/25_algorithms/find_last_if_not/1.cc: New test.", "tree": {"sha": "71dd3092d98aa58dccb12b67ab0932bebf5285f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71dd3092d98aa58dccb12b67ab0932bebf5285f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9aef107ce697f58a34734d82f8d2514405c9be0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9aef107ce697f58a34734d82f8d2514405c9be0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9aef107ce697f58a34734d82f8d2514405c9be0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9aef107ce697f58a34734d82f8d2514405c9be0/comments", "author": null, "committer": null, "parents": [{"sha": "28752bcbbfb2efa1b57db725d7a3e352eabcc336", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28752bcbbfb2efa1b57db725d7a3e352eabcc336", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28752bcbbfb2efa1b57db725d7a3e352eabcc336"}], "stats": {"total": 400, "additions": 400, "deletions": 0}, "files": [{"sha": "5577d862cb51eea4cdee07d88ebf497809895de1", "filename": "libstdc++-v3/include/bits/ranges_algo.h", "status": "modified", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9aef107ce697f58a34734d82f8d2514405c9be0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9aef107ce697f58a34734d82f8d2514405c9be0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h?ref=c9aef107ce697f58a34734d82f8d2514405c9be0", "patch": "@@ -3565,6 +3565,132 @@ namespace ranges\n   };\n \n   inline constexpr __iota_fn iota{};\n+\n+  struct __find_last_fn\n+  {\n+    template<forward_iterator _Iter, sentinel_for<_Iter> _Sent, typename T, typename _Proj = identity>\n+      requires indirect_binary_predicate<ranges::equal_to, projected<_Iter, _Proj>, const T*>\n+      constexpr subrange<_Iter>\n+      operator()(_Iter __first, _Sent __last, const T& __value, _Proj __proj = {}) const\n+      {\n+\tif constexpr (same_as<_Iter, _Sent> && bidirectional_iterator<_Iter>)\n+\t  {\n+\t    _Iter __found = ranges::find(reverse_iterator<_Iter>{__last},\n+\t\t\t\t\t reverse_iterator<_Iter>{__first},\n+\t\t\t\t\t __value, std::move(__proj)).base();\n+\t    if (__found == __first)\n+\t      return {__last, __last};\n+\t    else\n+\t      return {ranges::prev(__found), __last};\n+\t  }\n+\telse\n+\t  {\n+\t    _Iter __found = ranges::find(__first, __last, __value, __proj);\n+\t    if (__found == __last)\n+\t      return {__found, __found};\n+\t    __first = __found;\n+\t    for (;;)\n+\t      {\n+\t\t__first = ranges::find(ranges::next(__first), __last, __value, __proj);\n+\t\tif (__first == __last)\n+\t\t  return {__found, __first};\n+\t\t__found = __first;\n+\t      }\n+\t  }\n+      }\n+\n+    template<forward_range _Range, typename T, typename _Proj = identity>\n+      requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<_Range>, _Proj>, const T*>\n+      constexpr borrowed_subrange_t<_Range>\n+      operator()(_Range&& __r, const T& __value, _Proj __proj = {}) const\n+      { return (*this)(ranges::begin(__r), ranges::end(__r), __value, std::move(__proj)); }\n+  };\n+\n+  inline constexpr __find_last_fn find_last{};\n+\n+  struct __find_last_if_fn\n+  {\n+    template<forward_iterator _Iter, sentinel_for<_Iter> _Sent, typename _Proj = identity,\n+\t     indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>\n+      constexpr subrange<_Iter>\n+      operator()(_Iter __first, _Sent __last, _Pred __pred, _Proj __proj = {}) const\n+      {\n+\tif constexpr (same_as<_Iter, _Sent> && bidirectional_iterator<_Iter>)\n+\t  {\n+\t    _Iter __found = ranges::find_if(reverse_iterator<_Iter>{__last},\n+\t\t\t\t\t    reverse_iterator<_Iter>{__first},\n+\t\t\t\t\t    std::move(__pred), std::move(__proj)).base();\n+\t    if (__found == __first)\n+\t      return {__last, __last};\n+\t    else\n+\t      return {ranges::prev(__found), __last};\n+\t  }\n+\telse\n+\t  {\n+\t    _Iter __found = ranges::find_if(__first, __last, __pred, __proj);\n+\t    if (__found == __last)\n+\t      return {__found, __found};\n+\t    __first = __found;\n+\t    for (;;)\n+\t      {\n+\t\t__first = ranges::find_if(ranges::next(__first), __last, __pred, __proj);\n+\t\tif (__first == __last)\n+\t\t  return {__found, __first};\n+\t\t__found = __first;\n+\t      }\n+\t  }\n+      }\n+\n+    template<forward_range _Range, typename _Proj = identity,\n+\t     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>\n+      constexpr borrowed_subrange_t<_Range>\n+      operator()(_Range&& __r, _Pred __pred, _Proj __proj = {}) const\n+      { return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__pred), std::move(__proj)); }\n+  };\n+\n+  inline constexpr __find_last_if_fn find_last_if{};\n+\n+  struct __find_last_if_not_fn\n+  {\n+    template<forward_iterator _Iter, sentinel_for<_Iter> _Sent, typename _Proj = identity,\n+\t     indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>\n+      constexpr subrange<_Iter>\n+      operator()(_Iter __first, _Sent __last, _Pred __pred, _Proj __proj = {}) const\n+      {\n+\tif constexpr (same_as<_Iter, _Sent> && bidirectional_iterator<_Iter>)\n+\t  {\n+\t    _Iter __found = ranges::find_if_not(reverse_iterator<_Iter>{__last},\n+\t\t\t\t\t\treverse_iterator<_Iter>{__first},\n+\t\t\t\t\t\tstd::move(__pred), std::move(__proj)).base();\n+\t    if (__found == __first)\n+\t      return {__last, __last};\n+\t    else\n+\t      return {ranges::prev(__found), __last};\n+\t  }\n+\telse\n+\t  {\n+\t    _Iter __found = ranges::find_if_not(__first, __last, __pred, __proj);\n+\t    if (__found == __last)\n+\t      return {__found, __found};\n+\t    __first = __found;\n+\t    for (;;)\n+\t      {\n+\t\t__first = ranges::find_if_not(ranges::next(__first), __last, __pred, __proj);\n+\t\tif (__first == __last)\n+\t\t  return {__found, __first};\n+\t\t__found = __first;\n+\t      }\n+\t  }\n+      }\n+\n+    template<forward_range _Range, typename _Proj = identity,\n+\t     indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>\n+      constexpr borrowed_subrange_t<_Range>\n+      operator()(_Range&& __r, _Pred __pred, _Proj __proj = {}) const\n+      { return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__pred), std::move(__proj)); }\n+  };\n+\n+  inline constexpr __find_last_if_not_fn find_last_if_not{};\n #endif // C++23\n } // namespace ranges\n "}, {"sha": "ef5844c8afd8ab2da8d058d17d417f0b806489b1", "filename": "libstdc++-v3/testsuite/25_algorithms/find_last/1.cc", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9aef107ce697f58a34734d82f8d2514405c9be0/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_last%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9aef107ce697f58a34734d82f8d2514405c9be0/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_last%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_last%2F1.cc?ref=c9aef107ce697f58a34734d82f8d2514405c9be0", "patch": "@@ -0,0 +1,90 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do run { target c++23 } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+namespace ranges = std::ranges;\n+\n+constexpr bool\n+test01()\n+{\n+  int x[] = {1, 2, 1, 2, 1, 2, 1, 2};\n+\n+  auto sr0 = ranges::find_last(x, 0);\n+  VERIFY( ranges::empty(sr0) );\n+  VERIFY( sr0.begin() == ranges::end(x) );\n+\n+  auto sr1 = ranges::find_last(x, 1);\n+  VERIFY( ranges::equal(sr1, (int[]){1, 2}) );\n+  VERIFY( sr1.begin() == &x[6] );\n+\n+  auto sr2 = ranges::find_last(x, 2);\n+  VERIFY( ranges::equal(sr2, (int[]){2}) );\n+  VERIFY( sr2.begin() == &x[7] );\n+\n+  auto plus3 = [](int n) { return n+3; };\n+\n+  auto sr3 = ranges::find_last(x, 3, plus3);\n+  VERIFY( ranges::empty(sr3) );\n+  VERIFY( sr3.begin() == ranges::end(x) );\n+\n+  auto sr4 = ranges::find_last(x, 4, plus3);\n+  VERIFY( ranges::equal(sr4, (int[]){1, 2}) );\n+  VERIFY( sr4.begin() == &x[6] );\n+\n+  auto sr5 = ranges::find_last(x, 5, plus3);\n+  VERIFY( ranges::equal(sr5, (int[]){2}) );\n+  VERIFY( sr5.begin() == &x[7] );\n+\n+  return true;\n+}\n+\n+void\n+test02()\n+{\n+  int x[] = {1, 2, 3, 1, 2, 3, 1, 2, 3};\n+  __gnu_test::test_forward_range<int> rx(x);\n+\n+  auto sr0 = ranges::find_last(rx, 0);\n+  VERIFY( ranges::empty(sr0) );\n+  VERIFY( sr0.begin() == ranges::end(rx) );\n+\n+  auto sr1 = ranges::find_last(rx, 1);\n+  VERIFY( ranges::equal(sr1, (int[]){1, 2, 3}) );\n+  VERIFY( sr1.begin().ptr == &x[6] );\n+\n+  auto sr2 = ranges::find_last(rx, 2);\n+  VERIFY( ranges::equal(sr2, (int[]){2, 3}) );\n+  VERIFY( sr2.begin().ptr == &x[7] );\n+\n+  auto sr3 = ranges::find_last(rx, 3);\n+  VERIFY( ranges::equal(sr3, (int[]){3}) );\n+  VERIFY( sr3.begin().ptr == &x[8] );\n+\n+  auto plus4 = [](int n) { return n+4; };\n+\n+  auto sr4 = ranges::find_last(rx, 4, plus4);\n+  VERIFY( ranges::empty(sr4) );\n+  VERIFY( sr4.begin() == ranges::end(rx) );\n+\n+  auto sr5 = ranges::find_last(rx, 5, plus4);\n+  VERIFY( ranges::equal(sr5, (int[]){1, 2, 3}) );\n+  VERIFY( sr5.begin().ptr == &x[6] );\n+\n+  auto sr6 = ranges::find_last(rx, 6, plus4);\n+  VERIFY( ranges::equal(sr6, (int[]){2, 3}) );\n+  VERIFY( sr6.begin().ptr == &x[7] );\n+\n+  auto sr7 = ranges::find_last(rx, 7, plus4);\n+  VERIFY( ranges::equal(sr7, (int[]){3}) );\n+  VERIFY( sr7.begin().ptr == &x[8] );\n+}\n+\n+int\n+main()\n+{\n+  static_assert(test01());\n+  test02();\n+}"}, {"sha": "0a723475decd233d2cc3050dde6b714cd565cc4a", "filename": "libstdc++-v3/testsuite/25_algorithms/find_last_if/1.cc", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9aef107ce697f58a34734d82f8d2514405c9be0/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_last_if%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9aef107ce697f58a34734d82f8d2514405c9be0/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_last_if%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_last_if%2F1.cc?ref=c9aef107ce697f58a34734d82f8d2514405c9be0", "patch": "@@ -0,0 +1,92 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do run { target c++23 } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+namespace ranges = std::ranges;\n+\n+template<int N> constexpr auto eq = [](int m) { return m == N; };\n+\n+constexpr bool\n+test01()\n+{\n+  int x[] = {1, 2, 1, 2, 1, 2, 1, 2};\n+\n+  auto sr0 = ranges::find_last_if(x, eq<0>);\n+  VERIFY( ranges::empty(sr0) );\n+  VERIFY( sr0.begin() == ranges::end(x) );\n+\n+  auto sr1 = ranges::find_last_if(x, eq<1>);\n+  VERIFY( ranges::equal(sr1, (int[]){1, 2}) );\n+  VERIFY( sr1.begin() == &x[6] );\n+\n+  auto sr2 = ranges::find_last_if(x, eq<2>);\n+  VERIFY( ranges::equal(sr2, (int[]){2}) );\n+  VERIFY( sr2.begin() == &x[7] );\n+\n+  auto plus3 = [](int n) { return n+3; };\n+\n+  auto sr3 = ranges::find_last_if(x, eq<3>, plus3);\n+  VERIFY( ranges::empty(sr3) );\n+  VERIFY( sr3.begin() == ranges::end(x) );\n+\n+  auto sr4 = ranges::find_last_if(x, eq<4>, plus3);\n+  VERIFY( ranges::equal(sr4, (int[]){1, 2}) );\n+  VERIFY( sr4.begin() == &x[6] );\n+\n+  auto sr5 = ranges::find_last_if(x, eq<5>, plus3);\n+  VERIFY( ranges::equal(sr5, (int[]){2}) );\n+  VERIFY( sr5.begin() == &x[7] );\n+\n+  return true;\n+}\n+\n+void\n+test02()\n+{\n+  int x[] = {1, 2, 3, 1, 2, 3, 1, 2, 3};\n+  __gnu_test::test_forward_range<int> rx(x);\n+\n+  auto sr0 = ranges::find_last_if(rx, eq<0>);\n+  VERIFY( ranges::empty(sr0) );\n+  VERIFY( sr0.begin() == ranges::end(rx) );\n+\n+  auto sr1 = ranges::find_last_if(rx, eq<1>);\n+  VERIFY( ranges::equal(sr1, (int[]){1, 2, 3}) );\n+  VERIFY( sr1.begin().ptr == &x[6] );\n+\n+  auto sr2 = ranges::find_last_if(rx, eq<2>);\n+  VERIFY( ranges::equal(sr2, (int[]){2, 3}) );\n+  VERIFY( sr2.begin().ptr == &x[7] );\n+\n+  auto sr3 = ranges::find_last_if(rx, eq<3>);\n+  VERIFY( ranges::equal(sr3, (int[]){3}) );\n+  VERIFY( sr3.begin().ptr == &x[8] );\n+\n+  auto plus4 = [](int n) { return n+4; };\n+\n+  auto sr4 = ranges::find_last_if(rx, eq<4>, plus4);\n+  VERIFY( ranges::empty(sr4) );\n+  VERIFY( sr4.begin() == ranges::end(rx) );\n+\n+  auto sr5 = ranges::find_last_if(rx, eq<5>, plus4);\n+  VERIFY( ranges::equal(sr5, (int[]){1, 2, 3}) );\n+  VERIFY( sr5.begin().ptr == &x[6] );\n+\n+  auto sr6 = ranges::find_last_if(rx, eq<6>, plus4);\n+  VERIFY( ranges::equal(sr6, (int[]){2, 3}) );\n+  VERIFY( sr6.begin().ptr == &x[7] );\n+\n+  auto sr7 = ranges::find_last_if(rx, eq<7>, plus4);\n+  VERIFY( ranges::equal(sr7, (int[]){3}) );\n+  VERIFY( sr7.begin().ptr == &x[8] );\n+}\n+\n+int\n+main()\n+{\n+  static_assert(test01());\n+  test02();\n+}"}, {"sha": "98aa94b7f2c9456e6cf1d33743f5f3b4be905b2f", "filename": "libstdc++-v3/testsuite/25_algorithms/find_last_if_not/1.cc", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9aef107ce697f58a34734d82f8d2514405c9be0/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_last_if_not%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9aef107ce697f58a34734d82f8d2514405c9be0/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_last_if_not%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_last_if_not%2F1.cc?ref=c9aef107ce697f58a34734d82f8d2514405c9be0", "patch": "@@ -0,0 +1,92 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do run { target c++23 } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+namespace ranges = std::ranges;\n+\n+template<int N> constexpr auto ne = [](int m) { return m != N; };\n+\n+constexpr bool\n+test01()\n+{\n+  int x[] = {1, 2, 1, 2, 1, 2, 1, 2};\n+\n+  auto sr0 = ranges::find_last_if_not(x, ne<0>);\n+  VERIFY( ranges::empty(sr0) );\n+  VERIFY( sr0.begin() == ranges::end(x) );\n+\n+  auto sr1 = ranges::find_last_if_not(x, ne<1>);\n+  VERIFY( ranges::equal(sr1, (int[]){1, 2}) );\n+  VERIFY( sr1.begin() == &x[6] );\n+\n+  auto sr2 = ranges::find_last_if_not(x, ne<2>);\n+  VERIFY( ranges::equal(sr2, (int[]){2}) );\n+  VERIFY( sr2.begin() == &x[7] );\n+\n+  auto plus3 = [](int n) { return n+3; };\n+\n+  auto sr3 = ranges::find_last_if_not(x, ne<3>, plus3);\n+  VERIFY( ranges::empty(sr3) );\n+  VERIFY( sr3.begin() == ranges::end(x) );\n+\n+  auto sr4 = ranges::find_last_if_not(x, ne<4>, plus3);\n+  VERIFY( ranges::equal(sr4, (int[]){1, 2}) );\n+  VERIFY( sr4.begin() == &x[6] );\n+\n+  auto sr5 = ranges::find_last_if_not(x, ne<5>, plus3);\n+  VERIFY( ranges::equal(sr5, (int[]){2}) );\n+  VERIFY( sr5.begin() == &x[7] );\n+\n+  return true;\n+}\n+\n+void\n+test02()\n+{\n+  int x[] = {1, 2, 3, 1, 2, 3, 1, 2, 3};\n+  __gnu_test::test_forward_range<int> rx(x);\n+\n+  auto sr0 = ranges::find_last_if_not(rx, ne<0>);\n+  VERIFY( ranges::empty(sr0) );\n+  VERIFY( sr0.begin() == ranges::end(rx) );\n+\n+  auto sr1 = ranges::find_last_if_not(rx, ne<1>);\n+  VERIFY( ranges::equal(sr1, (int[]){1, 2, 3}) );\n+  VERIFY( sr1.begin().ptr == &x[6] );\n+\n+  auto sr2 = ranges::find_last_if_not(rx, ne<2>);\n+  VERIFY( ranges::equal(sr2, (int[]){2, 3}) );\n+  VERIFY( sr2.begin().ptr == &x[7] );\n+\n+  auto sr3 = ranges::find_last_if_not(rx, ne<3>);\n+  VERIFY( ranges::equal(sr3, (int[]){3}) );\n+  VERIFY( sr3.begin().ptr == &x[8] );\n+\n+  auto plus4 = [](int n) { return n+4; };\n+\n+  auto sr4 = ranges::find_last_if_not(rx, ne<4>, plus4);\n+  VERIFY( ranges::empty(sr4) );\n+  VERIFY( sr4.begin() == ranges::end(rx) );\n+\n+  auto sr5 = ranges::find_last_if_not(rx, ne<5>, plus4);\n+  VERIFY( ranges::equal(sr5, (int[]){1, 2, 3}) );\n+  VERIFY( sr5.begin().ptr == &x[6] );\n+\n+  auto sr6 = ranges::find_last_if_not(rx, ne<6>, plus4);\n+  VERIFY( ranges::equal(sr6, (int[]){2, 3}) );\n+  VERIFY( sr6.begin().ptr == &x[7] );\n+\n+  auto sr7 = ranges::find_last_if_not(rx, ne<7>, plus4);\n+  VERIFY( ranges::equal(sr7, (int[]){3}) );\n+  VERIFY( sr7.begin().ptr == &x[8] );\n+}\n+\n+int\n+main()\n+{\n+  static_assert(test01());\n+  test02();\n+}"}]}