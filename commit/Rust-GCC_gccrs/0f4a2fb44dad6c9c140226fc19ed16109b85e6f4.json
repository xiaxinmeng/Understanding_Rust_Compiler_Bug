{"sha": "0f4a2fb44dad6c9c140226fc19ed16109b85e6f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY0YTJmYjQ0ZGFkNmM5YzE0MDIyNmZjMTllZDE2MTA5Yjg1ZTZmNA==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-06-17T13:46:04Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-06-17T13:46:04Z"}, "message": "libstdc++: Refine range adaptors' \"simple extra args\" mechanism [PR100940]\n\nThe _S_has_simple_extra_args mechanism is used to simplify forwarding\nof range adaptor's extra arguments when perfect forwarding call wrapper\nsemantics isn't required for correctness, on a per-adaptor basis.\nBoth views::take and views::drop are flagged as such, but it turns out\nperfect forwarding semantics are needed for these adaptors in some\ncontrived cases, e.g. when their extra argument is a move-only class\nthat's implicitly convertible to an integral type.\n\nTo fix this, we could just clear the flag for views::take/drop as with\nviews::split, but that'd come at the cost of acceptable diagnostics\nfor ill-formed uses of these adaptors (see PR100577).\n\nThis patch instead allows adaptors to parameterize their\n_S_has_simple_extra_args flag according the types of the captured extra\narguments, so that we could conditionally disable perfect forwarding\nsemantics only when the types of the extra arguments permit it.  We\nthen use this finer-grained mechanism to safely disable perfect\nforwarding semantics for views::take/drop when the extra argument is\ninteger-like, rather than incorrectly always disabling it.  Similarly,\nfor views::split, rather than always enabling perfect forwarding\nsemantics we now safely disable it when the extra argument is a scalar\nor a view, and recover good diagnostics for these common cases.\n\n\tPR libstdc++/100940\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/ranges (__adaptor::_RangeAdaptor): Document the\n\ttemplate form of _S_has_simple_extra_args.\n\t(__adaptor::__adaptor_has_simple_extra_args): Add _Args template\n\tparameter pack.  Try to treat _S_has_simple_extra_args as a\n\tvariable template parameterized by _Args.\n\t(__adaptor::_Partial): Pass _Arg/_Args to the constraint\n\t__adaptor_has_simple_extra_args.\n\t(views::_Take::_S_has_simple_extra_args): Templatize according\n\tto the type of the extra argument.\n\t(views::_Drop::_S_has_simple_extra_args): Likewise.\n\t(views::_Split::_S_has_simple_extra_args): Define.\n\t* testsuite/std/ranges/adaptors/100577.cc (test01, test02):\n\tAdjust after changes to _S_has_simple_extra_args mechanism.\n\t(test03): Define.", "tree": {"sha": "eaaca310f95be3a29096b753f263a2820cad908c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eaaca310f95be3a29096b753f263a2820cad908c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f4a2fb44dad6c9c140226fc19ed16109b85e6f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f4a2fb44dad6c9c140226fc19ed16109b85e6f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f4a2fb44dad6c9c140226fc19ed16109b85e6f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f4a2fb44dad6c9c140226fc19ed16109b85e6f4/comments", "author": null, "committer": null, "parents": [{"sha": "275c736e732d29934e4d22e8f030d5aae8c12a52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/275c736e732d29934e4d22e8f030d5aae8c12a52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/275c736e732d29934e4d22e8f030d5aae8c12a52"}], "stats": {"total": 92, "additions": 61, "deletions": 31}, "files": [{"sha": "a4289009bc4bcb67ddbf129332d17e374cbb4a3d", "filename": "libstdc++-v3/include/std/ranges", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f4a2fb44dad6c9c140226fc19ed16109b85e6f4/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f4a2fb44dad6c9c140226fc19ed16109b85e6f4/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges?ref=0f4a2fb44dad6c9c140226fc19ed16109b85e6f4", "patch": "@@ -796,7 +796,9 @@ namespace views::__adaptor\n   //\n   // The optional static data member _Derived::_S_has_simple_extra_args should\n   // be defined to true if the behavior of this adaptor is independent of the\n-  // constness/value category of the extra arguments.\n+  // constness/value category of the extra arguments.  This data member could\n+  // also be defined as a variable template parameterized by the types of the\n+  // extra arguments.\n   template<typename _Derived>\n     struct _RangeAdaptor\n     {\n@@ -818,9 +820,10 @@ namespace views::__adaptor\n     concept __closure_has_simple_call_op = _Adaptor::_S_has_simple_call_op;\n \n   // True if the behavior of the range adaptor non-closure _Adaptor is\n-  // independent of the value category of its extra arguments.\n-  template<typename _Adaptor>\n-    concept __adaptor_has_simple_extra_args = _Adaptor::_S_has_simple_extra_args;\n+  // independent of the value category of its extra arguments _Args.\n+  template<typename _Adaptor, typename... _Args>\n+    concept __adaptor_has_simple_extra_args = _Adaptor::_S_has_simple_extra_args\n+      || _Adaptor::template _S_has_simple_extra_args<_Args...>;\n \n   // A range adaptor closure that represents partial application of\n   // the range adaptor _Adaptor with arguments _Args.\n@@ -897,7 +900,7 @@ namespace views::__adaptor\n   // This lets us get away with a single operator() overload, which makes\n   // overload resolution failure diagnostics more concise.\n   template<typename _Adaptor, typename... _Args>\n-    requires __adaptor_has_simple_extra_args<_Adaptor>\n+    requires __adaptor_has_simple_extra_args<_Adaptor, _Args...>\n     struct _Partial<_Adaptor, _Args...> : _RangeAdaptorClosure\n     {\n       tuple<_Args...> _M_args;\n@@ -926,7 +929,7 @@ namespace views::__adaptor\n   // A lightweight specialization of the above template for the common case\n   // where _Adaptor accepts a single extra argument.\n   template<typename _Adaptor, typename _Arg>\n-    requires __adaptor_has_simple_extra_args<_Adaptor>\n+    requires __adaptor_has_simple_extra_args<_Adaptor, _Arg>\n     struct _Partial<_Adaptor, _Arg> : _RangeAdaptorClosure\n     {\n       _Arg _M_arg;\n@@ -2112,7 +2115,12 @@ namespace views::__adaptor\n \n       using _RangeAdaptor<_Take>::operator();\n       static constexpr int _S_arity = 2;\n-      static constexpr bool _S_has_simple_extra_args = true;\n+      // The count argument of views::take is not always simple -- it can be\n+      // e.g. a move-only class that's implicitly convertible to the difference\n+      // type.  But an integer-like count argument is surely simple.\n+      template<typename _Tp>\n+\tstatic constexpr bool _S_has_simple_extra_args\n+\t  = ranges::__detail::__is_integer_like<_Tp>;\n     };\n \n     inline constexpr _Take take;\n@@ -2352,7 +2360,9 @@ namespace views::__adaptor\n \n       using _RangeAdaptor<_Drop>::operator();\n       static constexpr int _S_arity = 2;\n-      static constexpr bool _S_has_simple_extra_args = true;\n+      template<typename _Tp>\n+\tstatic constexpr bool _S_has_simple_extra_args\n+\t  = _Take::_S_has_simple_extra_args<_Tp>;\n     };\n \n     inline constexpr _Drop drop;\n@@ -3230,9 +3240,14 @@ namespace views::__adaptor\n \n       using _RangeAdaptor<_Split>::operator();\n       static constexpr int _S_arity = 2;\n-      // The second argument of views::split is _not_ simple -- it can be a\n-      // non-view range, the value category of which affects whether the call is\n-      // well-formed.  So we must not define _S_has_simple_extra_args to true.\n+      // The pattern argument of views::split is not always simple -- it can be\n+      // a non-view range, the value category of which affects whether the call\n+      // is well-formed.  But a scalar or a view pattern argument is surely\n+      // simple.\n+      template<typename _Pattern>\n+\tstatic constexpr bool _S_has_simple_extra_args\n+\t  = is_scalar_v<_Pattern> || (view<_Pattern>\n+\t\t\t\t      && copy_constructible<_Pattern>);\n     };\n \n     inline constexpr _Split split;"}, {"sha": "8ef084621f9346ac9b4afc39059ffaca73b0cf6f", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/100577.cc", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f4a2fb44dad6c9c140226fc19ed16109b85e6f4/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2F100577.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f4a2fb44dad6c9c140226fc19ed16109b85e6f4/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2F100577.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2F100577.cc?ref=0f4a2fb44dad6c9c140226fc19ed16109b85e6f4", "patch": "@@ -28,16 +28,18 @@ namespace views = std::ranges::views;\n void\n test01()\n {\n-  // Verify all multi-argument adaptors except for views::split are denoted\n-  // to have simple extra arguments.\n+  // Verify adaptors are deemed to have simple extra arguments when appropriate.\n   using views::__adaptor::__adaptor_has_simple_extra_args;\n-  static_assert(__adaptor_has_simple_extra_args<decltype(views::transform)>);\n-  static_assert(__adaptor_has_simple_extra_args<decltype(views::filter)>);\n-  static_assert(__adaptor_has_simple_extra_args<decltype(views::drop)>);\n-  static_assert(__adaptor_has_simple_extra_args<decltype(views::take)>);\n-  static_assert(__adaptor_has_simple_extra_args<decltype(views::take_while)>);\n-  static_assert(__adaptor_has_simple_extra_args<decltype(views::drop_while)>);\n-  static_assert(!__adaptor_has_simple_extra_args<decltype(views::split)>);\n+  using std::identity;\n+  static_assert(__adaptor_has_simple_extra_args<decltype(views::transform), identity>);\n+  static_assert(__adaptor_has_simple_extra_args<decltype(views::filter), identity>);\n+  static_assert(__adaptor_has_simple_extra_args<decltype(views::drop), int>);\n+  static_assert(__adaptor_has_simple_extra_args<decltype(views::take), int>);\n+  static_assert(__adaptor_has_simple_extra_args<decltype(views::take_while), identity>);\n+  static_assert(__adaptor_has_simple_extra_args<decltype(views::drop_while), identity>);\n+  static_assert(__adaptor_has_simple_extra_args<decltype(views::split), std::string_view>);\n+  static_assert(__adaptor_has_simple_extra_args<decltype(views::split), char>);\n+  static_assert(!__adaptor_has_simple_extra_args<decltype(views::split), std::string>);\n \n   // Verify all adaptor closures except for views::split(pattern) have a simple\n   // operator().\n@@ -53,15 +55,17 @@ test01()\n   __closure_has_simple_call_op auto a08 = views::common;\n   __closure_has_simple_call_op auto a09 = views::reverse;\n   __closure_has_simple_call_op auto a10 = views::keys;\n+  __closure_has_simple_call_op auto a11 = views::split(' ');\n   // Verify composition of simple closures is simple.\n   __closure_has_simple_call_op auto b\n-    = (a00 | a01) | (a02 | a03) | (a04 | a05 | a06) | (a07 | a08 | a09 | a10);\n+    = (a00 | a01) | (a02 | a03) | (a04 | a05 | a06) | (a07 | a08 | a09 | a10) | a11;\n \n-  // Verify views::split is the exception.\n-  auto a11 = views::split(' ');\n-  static_assert(!__closure_has_simple_call_op<decltype(a11)>);\n-  static_assert(!__closure_has_simple_call_op<decltype(a11 | a00)>);\n-  static_assert(!__closure_has_simple_call_op<decltype(a00 | a11)>);\n+  // Verify views::split(non_view_range) is an exception.\n+  extern std::string s;\n+  auto a12 = views::split(s);\n+  static_assert(!__closure_has_simple_call_op<decltype(a12)>);\n+  static_assert(!__closure_has_simple_call_op<decltype(a12 | a00)>);\n+  static_assert(!__closure_has_simple_call_op<decltype(a00 | a12)>);\n }\n \n void\n@@ -71,18 +75,14 @@ test02()\n   // fallback deleted overload, so when a call is ill-formed overload resolution\n   // fails.\n   extern int x[10];\n-  auto badarg = nullptr;\n+  struct { } badarg;\n   views::transform(badarg)(x); // { dg-error \"no match\" }\n   views::filter(badarg)(x); // { dg-error \"no match\" }\n-  views::take(badarg)(x); // { dg-error \"no match\" }\n-  views::drop(badarg)(x); // { dg-error \"no match\" }\n   views::take_while(badarg)(x); // { dg-error \"no match\" }\n   views::drop_while(badarg)(x); // { dg-error \"no match\" }\n \n   (views::transform(badarg) | views::all)(x); // { dg-error \"no match\" }\n   (views::filter(badarg) | views::all)(x); // { dg-error \"no match\" }\n-  (views::take(badarg) | views::all)(x); // { dg-error \"no match\" }\n-  (views::drop(badarg) | views::all)(x); // { dg-error \"no match\" }\n   (views::take_while(badarg) | views::all)(x); // { dg-error \"no match\" }\n   (views::drop_while(badarg) | views::all)(x); // { dg-error \"no match\" }\n \n@@ -96,6 +96,21 @@ test02()\n   a0(x); // { dg-error \"no match\" };\n   auto a1 = a0 | views::all;\n   a1(x); // { dg-error \"no match\" }\n+\n+  views::take(badarg)(x); // { dg-error \"deleted\" }\n+  views::drop(badarg)(x); // { dg-error \"deleted\" }\n+  (views::take(badarg) | views::all)(x); // { dg-error \"deleted\" }\n+  (views::drop(badarg) | views::all)(x); // { dg-error \"deleted\" }\n+}\n+\n+void\n+test03()\n+{\n+  // PR libstdc++/100940\n+  extern int x[10];\n+  struct S { operator int() && { return 5; }; };\n+  x | std::views::take(S{});\n+  x | std::views::drop(S{});\n }\n \n // { dg-prune-output \"in requirements\" }"}]}