{"sha": "ef2be24905e5133c356ffc606560954df3874bd1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWYyYmUyNDkwNWU1MTMzYzM1NmZmYzYwNjU2MDk1NGRmMzg3NGJkMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2012-01-09T19:43:10Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2012-01-09T19:43:10Z"}, "message": "sched-int.h (bb_note): Move to...\n\ngcc/\n\t* sched-int.h (bb_note): Move to...\n\t* basic-block.h: ...here.\n\t* haifa-sched.c (bb_note): Move to...\n\t* cfgrtl.c: ...here.\n\t* function.c (next_block_for_reg): New function.\n\t(move_insn_for_shrink_wrap): Likewise.\n\t(prepare_shrink_wrap): Rewrite to use the above.\n\nFrom-SVN: r183028", "tree": {"sha": "a80e3d0754d775d696f7dd9afc3cf5fabbf319bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a80e3d0754d775d696f7dd9afc3cf5fabbf319bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef2be24905e5133c356ffc606560954df3874bd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef2be24905e5133c356ffc606560954df3874bd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef2be24905e5133c356ffc606560954df3874bd1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef2be24905e5133c356ffc606560954df3874bd1/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3c157c27baefcea754fcb95b1f3c6160493faaa4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c157c27baefcea754fcb95b1f3c6160493faaa4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c157c27baefcea754fcb95b1f3c6160493faaa4"}], "stats": {"total": 310, "additions": 188, "deletions": 122}, "files": [{"sha": "6affd168e7ca2941335423a262c43bbcda0faa72", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef2be24905e5133c356ffc606560954df3874bd1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef2be24905e5133c356ffc606560954df3874bd1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ef2be24905e5133c356ffc606560954df3874bd1", "patch": "@@ -1,3 +1,13 @@\n+2012-01-09  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* sched-int.h (bb_note): Move to...\n+\t* basic-block.h: ...here.\n+\t* haifa-sched.c (bb_note): Move to...\n+\t* cfgrtl.c: ...here.\n+\t* function.c (next_block_for_reg): New function.\n+\t(move_insn_for_shrink_wrap): Likewise.\n+\t(prepare_shrink_wrap): Rewrite to use the above.\n+\n 2012-01-09  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* gimple.c (is_gimple_non_addressable): Remove."}, {"sha": "3ff1cd645ea42194ab51e4f6ad7be05cb514a37b", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef2be24905e5133c356ffc606560954df3874bd1/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef2be24905e5133c356ffc606560954df3874bd1/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=ef2be24905e5133c356ffc606560954df3874bd1", "patch": "@@ -801,6 +801,7 @@ extern void flow_edge_list_print (const char *, const edge *, int, FILE *);\n \n /* In cfgrtl.c  */\n extern rtx block_label (basic_block);\n+extern rtx bb_note (basic_block);\n extern bool purge_all_dead_edges (void);\n extern bool purge_dead_edges (basic_block);\n extern bool fixup_abnormal_edges (void);"}, {"sha": "9312a4b69f1fa7de055c3168a2a02b4be99dd2e7", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef2be24905e5133c356ffc606560954df3874bd1/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef2be24905e5133c356ffc606560954df3874bd1/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=ef2be24905e5133c356ffc606560954df3874bd1", "patch": "@@ -500,6 +500,20 @@ update_bb_for_insn (basic_block bb)\n }\n \n \f\n+/* Return the NOTE_INSN_BASIC_BLOCK of BB.  */\n+rtx\n+bb_note (basic_block bb)\n+{\n+  rtx note;\n+\n+  note = BB_HEAD (bb);\n+  if (LABEL_P (note))\n+    note = NEXT_INSN (note);\n+\n+  gcc_assert (NOTE_INSN_BASIC_BLOCK_P (note));\n+  return note;\n+}\n+\n /* Return the INSN immediately following the NOTE_INSN_BASIC_BLOCK\n    note associated with the BLOCK.  */\n "}, {"sha": "cd82da404d29e7e8481d2b5b8a8a61a0ba4828fa", "filename": "gcc/function.c", "status": "modified", "additions": 163, "deletions": 107, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef2be24905e5133c356ffc606560954df3874bd1/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef2be24905e5133c356ffc606560954df3874bd1/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=ef2be24905e5133c356ffc606560954df3874bd1", "patch": "@@ -5329,126 +5329,182 @@ requires_stack_frame_p (rtx insn, HARD_REG_SET prologue_used,\n   return false;\n }\n \n-/* Look for sets of call-saved registers in the first block of the\n-   function, and move them down into successor blocks if the register\n-   is used only on one path.  This exposes more opportunities for\n-   shrink-wrapping.\n-   These kinds of sets often occur when incoming argument registers are\n-   moved to call-saved registers because their values are live across\n-   one or more calls during the function.  */\n+/* See whether BB has a single successor that uses [REGNO, END_REGNO),\n+   and if BB is its only predecessor.  Return that block if so,\n+   otherwise return null.  */\n \n-static void\n-prepare_shrink_wrap (basic_block entry_block)\n+static basic_block\n+next_block_for_reg (basic_block bb, int regno, int end_regno)\n {\n-  rtx insn, curr;\n-  FOR_BB_INSNS_SAFE (entry_block, insn, curr)\n+  edge e, live_edge;\n+  edge_iterator ei;\n+  bitmap live;\n+  int i;\n+\n+  live_edge = NULL;\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n-      basic_block next_bb;\n-      edge e, live_edge;\n-      edge_iterator ei;\n-      rtx set, scan;\n-      unsigned destreg, srcreg;\n+      live = df_get_live_in (e->dest);\n+      for (i = regno; i < end_regno; i++)\n+\tif (REGNO_REG_SET_P (live, i))\n+\t  {\n+\t    if (live_edge && live_edge != e)\n+\t      return NULL;\n+\t    live_edge = e;\n+\t  }\n+    }\n \n-      if (!NONDEBUG_INSN_P (insn))\n-\tcontinue;\n-      set = single_set (insn);\n-      if (!set)\n-\tcontinue;\n+  /* We can sometimes encounter dead code.  Don't try to move it\n+     into the exit block.  */\n+  if (!live_edge || live_edge->dest == EXIT_BLOCK_PTR)\n+    return NULL;\n \n-      if (!REG_P (SET_SRC (set)) || !REG_P (SET_DEST (set)))\n-\tcontinue;\n-      srcreg = REGNO (SET_SRC (set));\n-      destreg = REGNO (SET_DEST (set));\n-      if (hard_regno_nregs[srcreg][GET_MODE (SET_SRC (set))] > 1\n-\t  || hard_regno_nregs[destreg][GET_MODE (SET_DEST (set))] > 1)\n-\tcontinue;\n+  /* Reject targets of abnormal edges.  This is needed for correctness\n+     on ports like Alpha and MIPS, whose pic_offset_table_rtx can die on\n+     exception edges even though it is generally treated as call-saved\n+     for the majority of the compilation.  Moving across abnormal edges\n+     isn't going to be interesting for shrink-wrap usage anyway.  */\n+  if (live_edge->flags & EDGE_ABNORMAL)\n+    return NULL;\n \n-      next_bb = entry_block;\n-      scan = insn;\n+  if (EDGE_COUNT (live_edge->dest->preds) > 1)\n+    return NULL;\n \n-      for (;;)\n+  return live_edge->dest;\n+}\n+\n+/* Try to move INSN from BB to a successor.  Return true on success.\n+   USES and DEFS are the set of registers that are used and defined\n+   after INSN in BB.  */\n+\n+static bool\n+move_insn_for_shrink_wrap (basic_block bb, rtx insn,\n+\t\t\t   const HARD_REG_SET uses,\n+\t\t\t   const HARD_REG_SET defs)\n+{\n+  rtx set, src, dest;\n+  bitmap live_out, live_in, bb_uses, bb_defs;\n+  unsigned int i, dregno, end_dregno, sregno, end_sregno;\n+  basic_block next_block;\n+\n+  /* Look for a simple register copy.  */\n+  set = single_set (insn);\n+  if (!set)\n+    return false;\n+  src = SET_SRC (set);\n+  dest = SET_DEST (set);\n+  if (!REG_P (dest) || !REG_P (src))\n+    return false;\n+\n+  /* Make sure that the source register isn't defined later in BB.  */\n+  sregno = REGNO (src);\n+  end_sregno = END_REGNO (src);\n+  if (overlaps_hard_reg_set_p (defs, GET_MODE (src), sregno))\n+    return false;\n+\n+  /* Make sure that the destination register isn't referenced later in BB.  */\n+  dregno = REGNO (dest);\n+  end_dregno = END_REGNO (dest);\n+  if (overlaps_hard_reg_set_p (uses, GET_MODE (dest), dregno)\n+      || overlaps_hard_reg_set_p (defs, GET_MODE (dest), dregno))\n+    return false;\n+\n+  /* See whether there is a successor block to which we could move INSN.  */\n+  next_block = next_block_for_reg (bb, dregno, end_dregno);\n+  if (!next_block)\n+    return false;\n+\n+  /* At this point we are committed to moving INSN, but let's try to\n+     move it as far as we can.  */\n+  do\n+    {\n+      live_out = df_get_live_out (bb);\n+      live_in = df_get_live_in (next_block);\n+      bb = next_block;\n+\n+      /* Check whether BB uses DEST or clobbers DEST.  We need to add\n+\t INSN to BB if so.  Either way, DEST is no longer live on entry,\n+\t except for any part that overlaps SRC (next loop).  */\n+      bb_uses = &DF_LR_BB_INFO (bb)->use;\n+      bb_defs = &DF_LR_BB_INFO (bb)->def;\n+      for (i = dregno; i < end_dregno; i++)\n \t{\n-\t  live_edge = NULL;\n-\t  /* Try to find a single edge across which the register is live.\n-\t     If we find one, we'll try to move the set across this edge.  */\n-\t  FOR_EACH_EDGE (e, ei, next_bb->succs)\n-\t    {\n-\t      if (REGNO_REG_SET_P (df_get_live_in (e->dest), destreg))\n-\t\t{\n-\t\t  if (live_edge)\n-\t\t    {\n-\t\t      live_edge = NULL;\n-\t\t      break;\n-\t\t    }\n-\t\t  live_edge = e;\n-\t\t}\n-\t    }\n-\t  if (!live_edge)\n-\t    break;\n-\t  /* We can sometimes encounter dead code.  Don't try to move it\n-\t     into the exit block.  */\n-\t  if (live_edge->dest == EXIT_BLOCK_PTR)\n-\t    break;\n-\t  if (EDGE_COUNT (live_edge->dest->preds) > 1)\n-\t    break;\n-\t  while (scan != BB_END (next_bb))\n-\t    {\n-\t      scan = NEXT_INSN (scan);\n-\t      if (NONDEBUG_INSN_P (scan))\n-\t\t{\n-\t\t  rtx link;\n-\t\t  HARD_REG_SET set_regs;\n-\n-\t\t  CLEAR_HARD_REG_SET (set_regs);\n-\t\t  note_stores (PATTERN (scan), record_hard_reg_sets,\n-\t\t\t       &set_regs);\n-\t\t  if (CALL_P (scan))\n-\t\t    IOR_HARD_REG_SET (set_regs, call_used_reg_set);\n-\t\t  for (link = REG_NOTES (scan); link; link = XEXP (link, 1))\n-\t\t    if (REG_NOTE_KIND (link) == REG_INC)\n-\t\t      record_hard_reg_sets (XEXP (link, 0), NULL, &set_regs);\n-\n-\t\t  if (TEST_HARD_REG_BIT (set_regs, srcreg)\n-\t\t      || reg_referenced_p (SET_DEST (set),\n-\t\t\t\t\t   PATTERN (scan)))\n-\t\t    {\n-\t\t      scan = NULL_RTX;\n-\t\t      break;\n-\t\t    }\n-\t\t  if (CALL_P (scan))\n-\t\t    {\n-\t\t      rtx link = CALL_INSN_FUNCTION_USAGE (scan);\n-\t\t      while (link)\n-\t\t\t{\n-\t\t\t  rtx tmp = XEXP (link, 0);\n-\t\t\t  if (GET_CODE (tmp) == USE\n-\t\t\t      && reg_referenced_p (SET_DEST (set), tmp))\n-\t\t\t    break;\n-\t\t\t  link = XEXP (link, 1);\n-\t\t\t}\n-\t\t      if (link)\n-\t\t\t{\n-\t\t\t  scan = NULL_RTX;\n-\t\t\t  break;\n-\t\t\t}\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  if (!scan)\n-\t    break;\n-\t  next_bb = live_edge->dest;\n+\t  if (REGNO_REG_SET_P (bb_uses, i) || REGNO_REG_SET_P (bb_defs, i))\n+\t    next_block = NULL;\n+\t  CLEAR_REGNO_REG_SET (live_out, i);\n+\t  CLEAR_REGNO_REG_SET (live_in, i);\n \t}\n \n-      if (next_bb != entry_block)\n+      /* Check whether BB clobbers SRC.  We need to add INSN to BB if so.\n+\t Either way, SRC is now live on entry.  */\n+      for (i = sregno; i < end_sregno; i++)\n \t{\n-\t  rtx after = BB_HEAD (next_bb);\n-\t  while (!NOTE_P (after)\n-\t\t || NOTE_KIND (after) != NOTE_INSN_BASIC_BLOCK)\n-\t    after = NEXT_INSN (after);\n-\t  emit_insn_after (PATTERN (insn), after);\n-\t  delete_insn (insn);\n+\t  if (REGNO_REG_SET_P (bb_defs, i))\n+\t    next_block = NULL;\n+\t  SET_REGNO_REG_SET (live_out, i);\n+\t  SET_REGNO_REG_SET (live_in, i);\n \t}\n+\n+      /* If we don't need to add the move to BB, look for a single\n+\t successor block.  */\n+      if (next_block)\n+\tnext_block = next_block_for_reg (next_block, dregno, end_dregno);\n     }\n+  while (next_block);\n+\n+  /* BB now defines DEST.  It only uses the parts of DEST that overlap SRC\n+     (next loop).  */\n+  for (i = dregno; i < end_dregno; i++)\n+    {\n+      CLEAR_REGNO_REG_SET (bb_uses, i);\n+      SET_REGNO_REG_SET (bb_defs, i);\n+    }\n+\n+  /* BB now uses SRC.  */\n+  for (i = sregno; i < end_sregno; i++)\n+    SET_REGNO_REG_SET (bb_uses, i);\n+\n+  emit_insn_after (PATTERN (insn), bb_note (bb));\n+  delete_insn (insn);\n+  return true;\n+}\n+\n+/* Look for register copies in the first block of the function, and move\n+   them down into successor blocks if the register is used only on one\n+   path.  This exposes more opportunities for shrink-wrapping.  These\n+   kinds of sets often occur when incoming argument registers are moved\n+   to call-saved registers because their values are live across one or\n+   more calls during the function.  */\n+\n+static void\n+prepare_shrink_wrap (basic_block entry_block)\n+{\n+  rtx insn, curr, x;\n+  HARD_REG_SET uses, defs;\n+  df_ref *ref;\n+\n+  CLEAR_HARD_REG_SET (uses);\n+  CLEAR_HARD_REG_SET (defs);\n+  FOR_BB_INSNS_REVERSE_SAFE (entry_block, insn, curr)\n+    if (NONDEBUG_INSN_P (insn)\n+\t&& !move_insn_for_shrink_wrap (entry_block, insn, uses, defs))\n+      {\n+\t/* Add all defined registers to DEFs.  */\n+\tfor (ref = DF_INSN_DEFS (insn); *ref; ref++)\n+\t  {\n+\t    x = DF_REF_REG (*ref);\n+\t    if (REG_P (x) && HARD_REGISTER_P (x))\n+\t      SET_HARD_REG_BIT (defs, REGNO (x));\n+\t  }\n+\n+\t/* Add all used registers to USESs.  */\n+\tfor (ref = DF_INSN_USES (insn); *ref; ref++)\n+\t  {\n+\t    x = DF_REF_REG (*ref);\n+\t    if (REG_P (x) && HARD_REGISTER_P (x))\n+\t      SET_HARD_REG_BIT (uses, REGNO (x));\n+\t  }\n+      }\n }\n \n #endif"}, {"sha": "4e1909a535fa709caf3e88c85fdb88a4ad46d96f", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef2be24905e5133c356ffc606560954df3874bd1/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef2be24905e5133c356ffc606560954df3874bd1/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=ef2be24905e5133c356ffc606560954df3874bd1", "patch": "@@ -6489,20 +6489,6 @@ add_jump_dependencies (rtx insn, rtx jump)\n   gcc_assert (!sd_lists_empty_p (jump, SD_LIST_BACK));\n }\n \n-/* Return the NOTE_INSN_BASIC_BLOCK of BB.  */\n-rtx\n-bb_note (basic_block bb)\n-{\n-  rtx note;\n-\n-  note = BB_HEAD (bb);\n-  if (LABEL_P (note))\n-    note = NEXT_INSN (note);\n-\n-  gcc_assert (NOTE_INSN_BASIC_BLOCK_P (note));\n-  return note;\n-}\n-\n /* Extend data structures for logical insn UID.  */\n void\n sched_extend_luids (void)"}, {"sha": "2fa5f759e85ab301b691507e5c744343422e7873", "filename": "gcc/sched-int.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef2be24905e5133c356ffc606560954df3874bd1/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef2be24905e5133c356ffc606560954df3874bd1/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=ef2be24905e5133c356ffc606560954df3874bd1", "patch": "@@ -130,7 +130,6 @@ extern void sched_insns_init (rtx);\n extern void sched_insns_finish (void);\n \n extern void *xrecalloc (void *, size_t, size_t, size_t);\n-extern rtx bb_note (basic_block);\n \n extern void reemit_notes (rtx);\n "}]}