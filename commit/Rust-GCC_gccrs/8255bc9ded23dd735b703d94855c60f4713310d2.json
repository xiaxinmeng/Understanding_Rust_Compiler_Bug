{"sha": "8255bc9ded23dd735b703d94855c60f4713310d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODI1NWJjOWRlZDIzZGQ3MzViNzAzZDk0ODU1YzYwZjQ3MTMzMTBkMg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-14T08:20:41Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-14T08:20:41Z"}, "message": "[multiple changes]\n\n2010-06-14  Jerome Lambourg  <lambourg@adacore.com>\n\n\t* sem_prag.adb (Check_Duplicated_Export_Name): Remove check for\n\tCLI_Target as this prevents proper detection of exported names\n\tduplicates when the exported language is different to CIL.\n\t(Process_Interface_Name): Add check for CIL convention exports,\n\treplacing the old one from Check_Duplicated_Export_Name.\n\n2010-06-14  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-coinve.adb, a-convec.adb (operator \"&\"): Check both that new length\n\tand new last satisfy constraints.\n\t(Delete_Last): prevent overflow for subtraction of index values\n\t(To_Vector): prevent overflow for addition of index values\n\nFrom-SVN: r160710", "tree": {"sha": "93e45f8610aadd74316bbcbedaee0a0fba300fd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93e45f8610aadd74316bbcbedaee0a0fba300fd3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8255bc9ded23dd735b703d94855c60f4713310d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8255bc9ded23dd735b703d94855c60f4713310d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8255bc9ded23dd735b703d94855c60f4713310d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8255bc9ded23dd735b703d94855c60f4713310d2/comments", "author": null, "committer": null, "parents": [{"sha": "438ff97c274020cf44c92a47593ebceffa6c06cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/438ff97c274020cf44c92a47593ebceffa6c06cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/438ff97c274020cf44c92a47593ebceffa6c06cf"}], "stats": {"total": 647, "additions": 427, "deletions": 220}, "files": [{"sha": "a0b0f07824be02fab8a74550bf9d7c238ec92e22", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8255bc9ded23dd735b703d94855c60f4713310d2/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8255bc9ded23dd735b703d94855c60f4713310d2/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8255bc9ded23dd735b703d94855c60f4713310d2", "patch": "@@ -1,3 +1,18 @@\n+2010-06-14  Jerome Lambourg  <lambourg@adacore.com>\n+\n+\t* sem_prag.adb (Check_Duplicated_Export_Name): Remove check for\n+\tCLI_Target as this prevents proper detection of exported names\n+\tduplicates when the exported language is different to CIL.\n+\t(Process_Interface_Name): Add check for CIL convention exports,\n+\treplacing the old one from Check_Duplicated_Export_Name.\n+\n+2010-06-14  Matthew Heaney  <heaney@adacore.com>\n+\n+\t* a-coinve.adb, a-convec.adb (operator \"&\"): Check both that new length\n+\tand new last satisfy constraints.\n+\t(Delete_Last): prevent overflow for subtraction of index values\n+\t(To_Vector): prevent overflow for addition of index values\n+\n 2010-06-14  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch4.adb (Complete_Object_Operation): After analyzing the"}, {"sha": "fb4038db259e84dbd0a86ec20c85b8f605778429", "filename": "gcc/ada/a-coinve.adb", "status": "modified", "additions": 230, "deletions": 127, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8255bc9ded23dd735b703d94855c60f4713310d2/gcc%2Fada%2Fa-coinve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8255bc9ded23dd735b703d94855c60f4713310d2/gcc%2Fada%2Fa-coinve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinve.adb?ref=8255bc9ded23dd735b703d94855c60f4713310d2", "patch": "@@ -117,22 +117,63 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       declare\n-         N           : constant Int'Base := Int (LN) + Int (RN);\n-         Last_As_Int : Int'Base;\n+         N : constant Int'Base := Int (LN) + Int (RN);\n+         J : Int'Base;\n \n       begin\n-         if Int (No_Index) > Int'Last - N then\n+         --  There are two constraints we need to satisfy. The first constraint\n+         --  is that a container cannot have more than Count_Type'Last\n+         --  elements, so we must check the sum of the combined lengths. (It\n+         --  would be rare for vectors to have such a large number of elements,\n+         --  so we would normally expect this first check to succeed.) The\n+         --  second constraint is that the new Last index value cannot exceed\n+         --  Index_Type'Last.\n+\n+         if N > Count_Type'Pos (Count_Type'Last) then\n             raise Constraint_Error with \"new length is out of range\";\n          end if;\n \n-         Last_As_Int := Int (No_Index) + N;\n+         --  We now check whether the new length would create a Last index\n+         --  value greater than Index_Type'Last. This calculation requires\n+         --  care, because overflow can occur when Index_Type'First is near the\n+         --  end of the range of Int.\n \n-         if Last_As_Int > Int (Index_Type'Last) then\n-            raise Constraint_Error with \"new length is out of range\";\n+         if Index_Type'First <= 0 then\n+\n+            --  Compute the potential Last index value in the normal way, using\n+            --  Int as the type in which to perform intermediate\n+            --  calculations. Int is a 64-bit type, and Count_Type is a 32-bit\n+            --  type, so no overflow can occur.\n+\n+            J := Int (Index_Type'First - 1) + N;\n+\n+            if J > Int (Index_Type'Last) then\n+               raise Constraint_Error with \"new length is out of range\";\n+            end if;\n+\n+         else\n+            --  If Index_Type'First is within N of Int'Last, then overflow\n+            --  would occur if we simply computed Last directly. So instead of\n+            --  computing Last, and then determining whether its value is\n+            --  greater than Index_Type'Last (as we do above), we work\n+            --  backwards by computing the potential First index value, and\n+            --  then checking whether that value is less than Index_Type'First.\n+\n+            J := Int (Index_Type'Last) - N + 1;\n+\n+            if J < Int (Index_Type'First) then\n+               raise Constraint_Error with \"new length is out of range\";\n+            end if;\n+\n+            --  We have determined that Length would not create a Last index\n+            --  value outside of the range of Index_Type, so we can now safely\n+            --  compute its value.\n+\n+            J := Int (Index_Type'First - 1) + N;\n          end if;\n \n          declare\n-            Last : constant Index_Type := Index_Type (Last_As_Int);\n+            Last : constant Index_Type := Index_Type (J);\n \n             LE : Elements_Array renames\n                    Left.Elements.EA (Index_Type'First .. Left.Last);\n@@ -189,10 +230,8 @@ package body Ada.Containers.Indefinite_Vectors is\n    end \"&\";\n \n    function \"&\" (Left : Vector; Right : Element_Type) return Vector is\n-      LN : constant Count_Type := Length (Left);\n-\n    begin\n-      if LN = 0 then\n+      if Left.Is_Empty then\n          declare\n             Elements : Elements_Access := new Elements_Type (Index_Type'First);\n \n@@ -209,70 +248,65 @@ package body Ada.Containers.Indefinite_Vectors is\n          end;\n       end if;\n \n-      declare\n-         Last_As_Int : Int'Base;\n-\n-      begin\n-         if Int (Index_Type'First) > Int'Last - Int (LN) then\n-            raise Constraint_Error with \"new length is out of range\";\n-         end if;\n-\n-         Last_As_Int := Int (Index_Type'First) + Int (LN);\n-\n-         if Last_As_Int > Int (Index_Type'Last) then\n-            raise Constraint_Error with \"new length is out of range\";\n-         end if;\n+      --  We must satisfy two constraints: the new length cannot exceed\n+      --  Count_Type'Last, and the new Last index cannot exceed\n+      --  Index_Type'Last.\n \n-         declare\n-            Last : constant Index_Type := Index_Type (Last_As_Int);\n-\n-            LE : Elements_Array renames\n-                   Left.Elements.EA (Index_Type'First .. Left.Last);\n+      if Left.Length = Count_Type'Last then\n+         raise Constraint_Error with \"new length is out of range\";\n+      end if;\n \n-            Elements : Elements_Access :=\n-                        new Elements_Type (Last);\n+      if Left.Last >= Index_Type'Last then\n+         raise Constraint_Error with \"new length is out of range\";\n+      end if;\n \n-         begin\n-            for I in LE'Range loop\n-               begin\n-                  if LE (I) /= null then\n-                     Elements.EA (I) := new Element_Type'(LE (I).all);\n-                  end if;\n+      declare\n+         Last : constant Index_Type := Left.Last + 1;\n \n-               exception\n-                  when others =>\n-                     for J in Index_Type'First .. I - 1 loop\n-                        Free (Elements.EA (J));\n-                     end loop;\n+         LE : Elements_Array renames\n+                 Left.Elements.EA (Index_Type'First .. Left.Last);\n \n-                     Free (Elements);\n-                     raise;\n-               end;\n-            end loop;\n+         Elements : Elements_Access :=\n+                       new Elements_Type (Last);\n \n+      begin\n+         for I in LE'Range loop\n             begin\n-               Elements.EA (Last) := new Element_Type'(Right);\n+               if LE (I) /= null then\n+                  Elements.EA (I) := new Element_Type'(LE (I).all);\n+               end if;\n \n             exception\n                when others =>\n-                  for J in Index_Type'First .. Last - 1 loop\n+                  for J in Index_Type'First .. I - 1 loop\n                      Free (Elements.EA (J));\n                   end loop;\n \n                   Free (Elements);\n                   raise;\n             end;\n+         end loop;\n \n-            return (Controlled with Elements, Last, 0, 0);\n+         begin\n+            Elements.EA (Last) := new Element_Type'(Right);\n+\n+         exception\n+            when others =>\n+               for J in Index_Type'First .. Last - 1 loop\n+                  Free (Elements.EA (J));\n+               end loop;\n+\n+               Free (Elements);\n+               raise;\n          end;\n+\n+         return (Controlled with Elements, Last, 0, 0);\n       end;\n    end \"&\";\n \n    function \"&\" (Left : Element_Type; Right : Vector) return Vector is\n-      RN : constant Count_Type := Length (Right);\n-\n    begin\n-      if RN = 0 then\n+      if Right.Is_Empty then\n          declare\n             Elements : Elements_Access := new Elements_Type (Index_Type'First);\n \n@@ -289,61 +323,58 @@ package body Ada.Containers.Indefinite_Vectors is\n          end;\n       end if;\n \n-      declare\n-         Last_As_Int : Int'Base;\n+      --  We must satisfy two constraints: the new length cannot exceed\n+      --  Count_Type'Last, and the new Last index cannot exceed\n+      --  Index_Type'Last.\n \n-      begin\n-         if Int (Index_Type'First) > Int'Last - Int (RN) then\n-            raise Constraint_Error with \"new length is out of range\";\n-         end if;\n-\n-         Last_As_Int := Int (Index_Type'First) + Int (RN);\n+      if Right.Length = Count_Type'Last then\n+         raise Constraint_Error with \"new length is out of range\";\n+      end if;\n \n-         if Last_As_Int > Int (Index_Type'Last) then\n-            raise Constraint_Error with \"new length is out of range\";\n-         end if;\n+      if Right.Last >= Index_Type'Last then\n+         raise Constraint_Error with \"new length is out of range\";\n+      end if;\n \n-         declare\n-            Last : constant Index_Type := Index_Type (Last_As_Int);\n+      declare\n+         Last : constant Index_Type := Right.Last + 1;\n \n-            RE : Elements_Array renames\n-                   Right.Elements.EA (Index_Type'First .. Right.Last);\n+         RE : Elements_Array renames\n+                Right.Elements.EA (Index_Type'First .. Right.Last);\n \n-            Elements : Elements_Access :=\n-                         new Elements_Type (Last);\n+         Elements : Elements_Access :=\n+                      new Elements_Type (Last);\n \n-            I : Index_Type'Base := Index_Type'First;\n+         I : Index_Type'Base := Index_Type'First;\n \n+      begin\n          begin\n+            Elements.EA (I) := new Element_Type'(Left);\n+         exception\n+            when others =>\n+               Free (Elements);\n+               raise;\n+         end;\n+\n+         for RI in RE'Range loop\n+            I := I + 1;\n+\n             begin\n-               Elements.EA (I) := new Element_Type'(Left);\n+               if RE (RI) /= null then\n+                  Elements.EA (I) := new Element_Type'(RE (RI).all);\n+               end if;\n+\n             exception\n                when others =>\n+                  for J in Index_Type'First .. I - 1 loop\n+                     Free (Elements.EA (J));\n+                  end loop;\n+\n                   Free (Elements);\n                   raise;\n             end;\n+         end loop;\n \n-            for RI in RE'Range loop\n-               I := I + 1;\n-\n-               begin\n-                  if RE (RI) /= null then\n-                     Elements.EA (I) := new Element_Type'(RE (RI).all);\n-                  end if;\n-\n-               exception\n-                  when others =>\n-                     for J in Index_Type'First .. I - 1 loop\n-                        Free (Elements.EA (J));\n-                     end loop;\n-\n-                     Free (Elements);\n-                     raise;\n-               end;\n-            end loop;\n-\n-            return (Controlled with Elements, Last, 0, 0);\n-         end;\n+         return (Controlled with Elements, Last, 0, 0);\n       end;\n    end \"&\";\n \n@@ -2498,73 +2529,145 @@ package body Ada.Containers.Indefinite_Vectors is\n    ---------------\n \n    function To_Vector (Length : Count_Type) return Vector is\n+      Index    : Int'Base;\n+      Last     : Index_Type;\n+      Elements : Elements_Access;\n+\n    begin\n       if Length = 0 then\n          return Empty_Vector;\n       end if;\n \n-      declare\n-         First       : constant Int := Int (Index_Type'First);\n-         Last_As_Int : constant Int'Base := First + Int (Length) - 1;\n-         Last        : Index_Type;\n-         Elements    : Elements_Access;\n+      --  We create a vector object with a capacity that matches the specified\n+      --  Length. We do not allow the vector capacity (the length of the\n+      --  internal array) to exceed the number of values in Index_Type'Range\n+      --  (otherwise, there would be no way to refer to those components via an\n+      --  index), so we must check whether the specified Length would create a\n+      --  Last index value greater than Index_Type'Last. This calculation\n+      --  requires care, because overflow can occur when Index_Type'First is\n+      --  near the end of the range of Int.\n \n-      begin\n-         if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n+      if Index_Type'First <= 0 then\n+         --  Compute the potential Last index value in the normal way, using\n+         --  Int as the type in which to perform intermediate calculations. Int\n+         --  is a 64-bit type, and Count_Type is a 32-bit type, so no overflow\n+         --  can occur.\n+         Index := Int (Index_Type'First - 1) + Int (Length);\n+\n+         if Index > Int (Index_Type'Last) then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n-         Last := Index_Type (Last_As_Int);\n-         Elements := new Elements_Type (Last);\n+      else\n+         --  If Index_Type'First is within Length of Int'Last, then overflow\n+         --  would occur if we simply computed Last directly. So instead of\n+         --  computing Last, and then determining whether its value is greater\n+         --  than Index_Type'Last, we work backwards by computing the potential\n+         --  First index value, and then checking whether that value is less\n+         --  than Index_Type'First.\n+         Index := Int (Index_Type'Last) - Int (Length) + 1;\n+\n+         if Index < Int (Index_Type'First) then\n+            raise Constraint_Error with \"Length is out of range\";\n+         end if;\n \n-         return (Controlled with Elements, Last, 0, 0);\n-      end;\n+         --  We have determined that Length would not create a Last index value\n+         --  outside of the range of Index_Type, so we can now safely compute\n+         --  its value.\n+         Index := Int (Index_Type'First - 1) + Int (Length);\n+      end if;\n+\n+      Last := Index_Type (Index);\n+      Elements := new Elements_Type (Last);\n+\n+      return Vector'(Controlled with Elements, Last, 0, 0);\n    end To_Vector;\n \n    function To_Vector\n      (New_Item : Element_Type;\n       Length   : Count_Type) return Vector\n    is\n+      Index    : Int'Base;\n+      Last     : Index_Type;\n+      Elements : Elements_Access;\n+\n    begin\n       if Length = 0 then\n          return Empty_Vector;\n       end if;\n \n-      declare\n-         First       : constant Int := Int (Index_Type'First);\n-         Last_As_Int : constant Int'Base := First + Int (Length) - 1;\n-         Last        : Index_Type'Base;\n-         Elements    : Elements_Access;\n+      --  We create a vector object with a capacity that matches the specified\n+      --  Length.  We do not allow the vector capacity (the length of the\n+      --  internal array) to exceed the number of values in Index_Type'Range\n+      --  (otherwise, there would be no way to refer to those components via an\n+      --  index), so we must check whether the specified Length would create a\n+      --  Last index value greater than Index_Type'Last. This calculation\n+      --  requires care, because overflow can occur when Index_Type'First is\n+      --  near the end of the range of Int.\n \n-      begin\n-         if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n+      if Index_Type'First <= 0 then\n+         --  Compute the potential Last index value in the normal way, using\n+         --  Int as the type in which to perform intermediate calculations. Int\n+         --  is a 64-bit type, and Count_Type is a 32-bit type, so no overflow\n+         --  can occur.\n+         Index := Int (Index_Type'First - 1) + Int (Length);\n+\n+         if Index > Int (Index_Type'Last) then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n-         Last := Index_Type (Last_As_Int);\n-         Elements := new Elements_Type (Last);\n+      else\n+         --  If Index_Type'First is within Length of Int'Last, then overflow\n+         --  would occur if we simply computed Last directly. So instead of\n+         --  computing Last, and then determining whether its value is greater\n+         --  than Index_Type'Last, we work backwards by computing the potential\n+         --  First index value, and then checking whether that value is less\n+         --  than Index_Type'First.\n+         Index := Int (Index_Type'Last) - Int (Length) + 1;\n+\n+         if Index < Int (Index_Type'First) then\n+            raise Constraint_Error with \"Length is out of range\";\n+         end if;\n \n-         Last := Index_Type'First;\n+         --  We have determined that Length would not create a Last index value\n+         --  outside of the range of Index_Type, so we can now safely compute\n+         --  its value.\n+         Index := Int (Index_Type'First - 1) + Int (Length);\n+      end if;\n \n-         begin\n-            loop\n-               Elements.EA (Last) := new Element_Type'(New_Item);\n-               exit when Last = Elements.Last;\n-               Last := Last + 1;\n-            end loop;\n+      Last := Index_Type (Index);\n+      Elements := new Elements_Type (Last);\n \n-         exception\n-            when others =>\n-               for J in Index_Type'First .. Last - 1 loop\n-                  Free (Elements.EA (J));\n-               end loop;\n+      --  We use Last as the index of the loop used to populate the internal\n+      --  array with items. In general, we prefer to initialize the loop index\n+      --  immediately prior to entering the loop. However, Last is also used in\n+      --  the exception handler (it reclaims elements that have been allocated,\n+      --  before propagating the exception), and the initialization of Last\n+      --  after entering the block containing the handler confuses some static\n+      --  analysis tools, with respect to whether Last has been properly\n+      --  initialized when the handler executes. So here we initialize our loop\n+      --  variable earlier than we prefer, before entering the block, so there\n+      --  is no ambiguity.\n+      Last := Index_Type'First;\n \n-               Free (Elements);\n-               raise;\n-         end;\n+      begin\n+         loop\n+            Elements.EA (Last) := new Element_Type'(New_Item);\n+            exit when Last = Elements.Last;\n+            Last := Last + 1;\n+         end loop;\n \n-         return (Controlled with Elements, Last, 0, 0);\n+      exception\n+         when others =>\n+            for J in Index_Type'First .. Last - 1 loop\n+               Free (Elements.EA (J));\n+            end loop;\n+\n+            Free (Elements);\n+            raise;\n       end;\n+\n+      return (Controlled with Elements, Last, 0, 0);\n    end To_Vector;\n \n    --------------------"}, {"sha": "73151bc9870455940525a32d27dbbb3d90375814", "filename": "gcc/ada/a-convec.adb", "status": "modified", "additions": 174, "deletions": 84, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8255bc9ded23dd735b703d94855c60f4713310d2/gcc%2Fada%2Fa-convec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8255bc9ded23dd735b703d94855c60f4713310d2/gcc%2Fada%2Fa-convec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.adb?ref=8255bc9ded23dd735b703d94855c60f4713310d2", "patch": "@@ -81,22 +81,59 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       declare\n-         N           : constant Int'Base := Int (LN) + Int (RN);\n-         Last_As_Int : Int'Base;\n+         N : constant Int'Base := Int (LN) + Int (RN);\n+         J : Int'Base;\n \n       begin\n-         if Int (No_Index) > Int'Last - N then\n+         --  There are two constraints we need to satisfy. The first constraint\n+         --  is that a container cannot have more than Count_Type'Last\n+         --  elements, so we must check the sum of the combined lengths. (It\n+         --  would be rare for vectors to have such a large number of elements,\n+         --  so we would normally expect this first check to succeed.) The\n+         --  second constraint is that the new Last index value cannot exceed\n+         --  Index_Type'Last.\n+\n+         if N > Count_Type'Pos (Count_Type'Last) then\n             raise Constraint_Error with \"new length is out of range\";\n          end if;\n \n-         Last_As_Int := Int (No_Index) + N;\n+         --  We now check whether the new length would create a Last index\n+         --  value greater than Index_Type'Last. This calculation requires\n+         --  care, because overflow can occur when Index_Type'First is near the\n+         --  end of the range of Int.\n \n-         if Last_As_Int > Int (Index_Type'Last) then\n-            raise Constraint_Error with \"new length is out of range\";\n+         if Index_Type'First <= 0 then\n+            --  Compute the potential Last index value in the normal way, using\n+            --  Int as the type in which to perform intermediate\n+            --  calculations. Int is a 64-bit type, and Count_Type is a 32-bit\n+            --  type, so no overflow can occur.\n+            J := Int (Index_Type'First - 1) + N;\n+\n+            if J > Int (Index_Type'Last) then\n+               raise Constraint_Error with \"new length is out of range\";\n+            end if;\n+\n+         else\n+            --  If Index_Type'First is within N of Int'Last, then overflow\n+            --  would occur if we simply computed Last directly. So instead of\n+            --  computing Last, and then determining whether its value is\n+            --  greater than Index_Type'Last (as we do above), we work\n+            --  backwards by computing the potential First index value, and\n+            --  then checking whether that value is less than Index_Type'First.\n+            J := Int (Index_Type'Last) - N + 1;\n+\n+            if J < Int (Index_Type'First) then\n+               raise Constraint_Error with \"new length is out of range\";\n+            end if;\n+\n+            --  We have determined that Length would not create a Last index\n+            --  value outside of the range of Index_Type, so we can now safely\n+            --  compute its value.\n+            J := Int (Index_Type'First - 1) + N;\n          end if;\n \n          declare\n-            Last : constant Index_Type := Index_Type (Last_As_Int);\n+            Last : constant Index_Type := Index_Type (J);\n \n             LE : Elements_Array renames\n                    Left.Elements.EA (Index_Type'First .. Left.Last);\n@@ -114,10 +151,8 @@ package body Ada.Containers.Vectors is\n    end \"&\";\n \n    function \"&\" (Left  : Vector; Right : Element_Type) return Vector is\n-      LN : constant Count_Type := Length (Left);\n-\n    begin\n-      if LN = 0 then\n+      if Left.Is_Empty then\n          declare\n             Elements : constant Elements_Access :=\n                          new Elements_Type'\n@@ -129,42 +164,37 @@ package body Ada.Containers.Vectors is\n          end;\n       end if;\n \n-      declare\n-         Last_As_Int : Int'Base;\n-\n-      begin\n-         if Int (Index_Type'First) > Int'Last - Int (LN) then\n-            raise Constraint_Error with \"new length is out of range\";\n-         end if;\n+      --  We must satisfy two constraints: the new length cannot exceed\n+      --  Count_Type'Last, and the new Last index cannot exceed\n+      --  Index_Type'Last.\n \n-         Last_As_Int := Int (Index_Type'First) + Int (LN);\n+      if Left.Length = Count_Type'Last then\n+         raise Constraint_Error with \"new length is out of range\";\n+      end if;\n \n-         if Last_As_Int > Int (Index_Type'Last) then\n-            raise Constraint_Error with \"new length is out of range\";\n-         end if;\n+      if Left.Last >= Index_Type'Last then\n+         raise Constraint_Error with \"new length is out of range\";\n+      end if;\n \n-         declare\n-            Last : constant Index_Type := Index_Type (Last_As_Int);\n+      declare\n+         Last : constant Index_Type := Left.Last + 1;\n \n-            LE : Elements_Array renames\n-                   Left.Elements.EA (Index_Type'First .. Left.Last);\n+         LE : Elements_Array renames\n+           Left.Elements.EA (Index_Type'First .. Left.Last);\n \n-            Elements : constant Elements_Access :=\n-                         new Elements_Type'\n-                               (Last => Last,\n-                                EA   => LE & Right);\n+         Elements : constant Elements_Access :=\n+           new Elements_Type'\n+                 (Last => Last,\n+                  EA   => LE & Right);\n \n-         begin\n-            return (Controlled with Elements, Last, 0, 0);\n-         end;\n+      begin\n+         return (Controlled with Elements, Last, 0, 0);\n       end;\n    end \"&\";\n \n    function \"&\" (Left  : Element_Type; Right : Vector) return Vector is\n-      RN : constant Count_Type := Length (Right);\n-\n    begin\n-      if RN = 0 then\n+      if Right.Is_Empty then\n          declare\n             Elements : constant Elements_Access :=\n                          new Elements_Type'\n@@ -176,34 +206,31 @@ package body Ada.Containers.Vectors is\n          end;\n       end if;\n \n-      declare\n-         Last_As_Int : Int'Base;\n+      --  We must satisfy two constraints: the new length cannot exceed\n+      --  Count_Type'Last, and the new Last index cannot exceed\n+      --  Index_Type'Last.\n \n-      begin\n-         if Int (Index_Type'First) > Int'Last - Int (RN) then\n-            raise Constraint_Error with \"new length is out of range\";\n-         end if;\n-\n-         Last_As_Int := Int (Index_Type'First) + Int (RN);\n+      if Right.Length = Count_Type'Last then\n+         raise Constraint_Error with \"new length is out of range\";\n+      end if;\n \n-         if Last_As_Int > Int (Index_Type'Last) then\n-            raise Constraint_Error with \"new length is out of range\";\n-         end if;\n+      if Right.Last >= Index_Type'Last then\n+         raise Constraint_Error with \"new length is out of range\";\n+      end if;\n \n-         declare\n-            Last : constant Index_Type := Index_Type (Last_As_Int);\n+      declare\n+         Last : constant Index_Type := Right.Last + 1;\n \n-            RE : Elements_Array renames\n-                   Right.Elements.EA (Index_Type'First .. Right.Last);\n+         RE : Elements_Array renames\n+                Right.Elements.EA (Index_Type'First .. Right.Last);\n \n-            Elements : constant Elements_Access :=\n-                         new Elements_Type'\n-                               (Last => Last,\n-                                EA   => Left & RE);\n+         Elements : constant Elements_Access :=\n+                      new Elements_Type'\n+                        (Last => Last,\n+                         EA   => Left & RE);\n \n-         begin\n-            return (Controlled with Elements, Last, 0, 0);\n-         end;\n+      begin\n+         return (Controlled with Elements, Last, 0, 0);\n       end;\n    end \"&\";\n \n@@ -488,12 +515,13 @@ package body Ada.Containers.Vectors is\n            \"attempt to tamper with elements (vector is busy)\";\n       end if;\n \n-      Index := Int'Base (Container.Last) - Int'Base (Count);\n+      if Count >= Container.Length then\n+         Container.Last := No_Index;\n \n-      Container.Last :=\n-         (if Index < Index_Type'Pos (Index_Type'First)\n-          then No_Index\n-          else Index_Type (Index));\n+      else\n+         Index := Int (Container.Last) - Int (Count);\n+         Container.Last := Index_Type (Index);\n+      end if;\n    end Delete_Last;\n \n    -------------\n@@ -2135,54 +2163,116 @@ package body Ada.Containers.Vectors is\n    ---------------\n \n    function To_Vector (Length : Count_Type) return Vector is\n+      Index    : Int'Base;\n+      Last     : Index_Type;\n+      Elements : Elements_Access;\n+\n    begin\n       if Length = 0 then\n          return Empty_Vector;\n       end if;\n \n-      declare\n-         First       : constant Int := Int (Index_Type'First);\n-         Last_As_Int : constant Int'Base := First + Int (Length) - 1;\n-         Last        : Index_Type;\n-         Elements    : Elements_Access;\n+      --  We create a vector object with a capacity that matches the specified\n+      --  Length, but we do not allow the vector capacity (the length of the\n+      --  internal array) to exceed the number of values in Index_Type'Range\n+      --  (otherwise, there would be no way to refer to those components via an\n+      --  index).  We must therefore check whether the specified Length would\n+      --  create a Last index value greater than Index_Type'Last. This\n+      --  calculation requires care, because overflow can occur when\n+      --  Index_Type'First is near the end of the range of Int.\n \n-      begin\n-         if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n+      if Index_Type'First <= 0 then\n+         --  Compute the potential Last index value in the normal way, using\n+         --  Int as the type in which to perform intermediate calculations. Int\n+         --  is a 64-bit type, and Count_Type is a 32-bit type, so no overflow\n+         --  can occur.\n+         Index := Int (Index_Type'First - 1) + Int (Length);\n+\n+         if Index > Int (Index_Type'Last) then\n+            raise Constraint_Error with \"Length is out of range\";\n+         end if;\n+\n+      else\n+         --  If Index_Type'First is within Length of Int'Last, then overflow\n+         --  would occur if we simply computed Last directly. So instead of\n+         --  computing Last, and then determining whether its value is greater\n+         --  than Index_Type'Last, we work backwards by computing the potential\n+         --  First index value, and then checking whether that value is less\n+         --  than Index_Type'First.\n+         Index := Int (Index_Type'Last) - Int (Length) + 1;\n+\n+         if Index < Int (Index_Type'First) then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n-         Last := Index_Type (Last_As_Int);\n-         Elements := new Elements_Type (Last);\n+         --  We have determined that Length would not create a Last index value\n+         --  outside of the range of Index_Type, so we can now safely compute\n+         --  its value.\n+         Index := Int (Index_Type'First - 1) + Int (Length);\n+      end if;\n+\n+      Last := Index_Type (Index);\n+      Elements := new Elements_Type (Last);\n \n-         return Vector'(Controlled with Elements, Last, 0, 0);\n-      end;\n+      return Vector'(Controlled with Elements, Last, 0, 0);\n    end To_Vector;\n \n    function To_Vector\n      (New_Item : Element_Type;\n       Length   : Count_Type) return Vector\n    is\n+      Index    : Int'Base;\n+      Last     : Index_Type;\n+      Elements : Elements_Access;\n+\n    begin\n       if Length = 0 then\n          return Empty_Vector;\n       end if;\n \n-      declare\n-         First       : constant Int := Int (Index_Type'First);\n-         Last_As_Int : constant Int'Base := First + Int (Length) - 1;\n-         Last        : Index_Type;\n-         Elements    : Elements_Access;\n+      --  We create a vector object with a capacity that matches the specified\n+      --  Length, but we do not allow the vector capacity (the length of the\n+      --  internal array) to exceed the number of values in Index_Type'Range\n+      --  (otherwise, there would be no way to refer to those components via an\n+      --  index). We must therefore check whether the specified Length would\n+      --  create a Last index value greater than Index_Type'Last. This\n+      --  calculation requires care, because overflow can occur when\n+      --  Index_Type'First is near the end of the range of Int.\n \n-      begin\n-         if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n+      if Index_Type'First <= 0 then\n+         --  Compute the potential Last index value in the normal way, using\n+         --  Int as the type in which to perform intermediate calculations. Int\n+         --  is a 64-bit type, and Count_Type is a 32-bit type, so no overflow\n+         --  can occur.\n+         Index := Int (Index_Type'First - 1) + Int (Length);\n+\n+         if Index > Int (Index_Type'Last) then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n-         Last := Index_Type (Last_As_Int);\n-         Elements := new Elements_Type'(Last, EA => (others => New_Item));\n+      else\n+         --  If Index_Type'First is within Length of Int'Last, then overflow\n+         --  would occur if we simply computed Last directly. So instead of\n+         --  computing Last, and then determining whether its value is greater\n+         --  than Index_Type'Last, we work backwards by computing the potential\n+         --  First index value, and then checking whether that value is less\n+         --  than Index_Type'First.\n+         Index := Int (Index_Type'Last) - Int (Length) + 1;\n+\n+         if Index < Int (Index_Type'First) then\n+            raise Constraint_Error with \"Length is out of range\";\n+         end if;\n \n-         return Vector'(Controlled with Elements, Last, 0, 0);\n-      end;\n+         --  We have determined that Length would not create a Last index value\n+         --  outside of the range of Index_Type, so we can now safely compute\n+         --  its value.\n+         Index := Int (Index_Type'First - 1) + Int (Length);\n+      end if;\n+\n+      Last := Index_Type (Index);\n+      Elements := new Elements_Type'(Last, EA => (others => New_Item));\n+\n+      return Vector'(Controlled with Elements, Last, 0, 0);\n    end To_Vector;\n \n    --------------------"}, {"sha": "54823e2b63cf258b2638e64b7f1fca4243eaac86", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8255bc9ded23dd735b703d94855c60f4713310d2/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8255bc9ded23dd735b703d94855c60f4713310d2/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=8255bc9ded23dd735b703d94855c60f4713310d2", "patch": "@@ -1154,14 +1154,6 @@ package body Sem_Prag is\n          String_Val : constant String_Id := Strval (Nam);\n \n       begin\n-         --  We allow duplicated export names in CIL, as they are always\n-         --  enclosed in a namespace that differentiates them, and overloaded\n-         --  entities are supported by the VM.\n-\n-         if VM_Target = CLI_Target then\n-            return;\n-         end if;\n-\n          --  We are only interested in the export case, and in the case of\n          --  generics, it is the instance, not the template, that is the\n          --  problem (the template will generate a warning in any case).\n@@ -4140,7 +4132,14 @@ package body Sem_Prag is\n \n          Set_Encoded_Interface_Name\n            (Get_Base_Subprogram (Subprogram_Def), Link_Nam);\n-         Check_Duplicated_Export_Name (Link_Nam);\n+\n+         --  We allow duplicated export names in CIL, as they are always\n+         --  enclosed in a namespace that differentiates them, and overloaded\n+         --  entities are supported by the VM.\n+\n+         if Convention (Subprogram_Def) /= Convention_CIL then\n+            Check_Duplicated_Export_Name (Link_Nam);\n+         end if;\n       end Process_Interface_Name;\n \n       -----------------------------------------"}]}