{"sha": "5368224f426c0dbe08a42e89d4cd18b0c8435834", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM2ODIyNGY0MjZjMGRiZTA4YTQyZTg5ZDRjZDE4YjBjODQzNTgzNA==", "commit": {"author": {"name": "Dehao Chen", "email": "dehao@google.com", "date": "2012-09-19T19:56:42Z"}, "committer": {"name": "Dehao Chen", "email": "dehao@gcc.gnu.org", "date": "2012-09-19T19:56:42Z"}, "message": "Integrate lexical block into source_location.\n\ngcc:\n\t2012-09-19  Dehao Chen  <dehao@google.com>\n\n\t* toplev.c (general_init): Init block_locations.\n\t* tree.c (tree_set_block): New.\n\t(tree_block): Change to use LOCATION_BLOCK.\n\t* tree.h (TREE_SET_BLOCK): New.\n\t* final.c (reemit_insn_block_notes): Change to use LOCATION_BLOCK.\n\t(final_start_function): Likewise.\n\t* input.c (expand_location_1): Likewise.\n\t* input.h (LOCATION_LOCUS): New.\n\t(LOCATION_BLOCK): New.\n\t(IS_UNKNOWN_LOCATION): New.\n\t* fold-const.c (expr_location_or): Change to use new location.\n\t* reorg.c (emit_delay_sequence): Likewise.\n\t(try_merge_delay_insns): Likewise.\n\t* modulo-sched.c (dump_insn_location): Likewise.\n\t* lto-streamer-out.c (lto_output_location_bitpack): Likewise.\n\t* lto-cgraph.c (output_node_opt_summary): Likewise.\n\t* jump.c (rtx_renumbered_equal_p): Likewise.\n\t* ifcvt.c (noce_try_move): Likewise.\n\t(noce_try_store_flag): Likewise.\n\t(noce_try_store_flag_constants): Likewise.\n\t(noce_try_addcc): Likewise.\n\t(noce_try_store_flag_mask): Likewise.\n\t(noce_try_cmove): Likewise.\n\t(noce_try_cmove_arith): Likewise.\n\t(noce_try_minmax): Likewise.\n\t(noce_try_abs): Likewise.\n\t(noce_try_sign_mask): Likewise.\n\t(noce_try_bitop): Likewise.\n\t(noce_process_if_block): Likewise.\n\t(cond_move_process_if_block): Likewise.\n\t(find_cond_trap): Likewise.\n\t* ipa-prop.c (ipa_set_jf_constant): Likewise.\n\t(ipa_write_jump_function): Likewise.\n\t* dwarf2out.c (add_src_coords_attributes): Likewise.\n\t* expr.c (expand_expr_real): Likewise.\n\t* tree-parloops.c (create_loop_fn): Likewise.\n\t* recog.c (peep2_attempt): Likewise.\n\t* function.c (free_after_compilation): Likewise.\n\t(expand_function_end): Likewise.\n\t(set_insn_locations): Likewise.\n\t(thread_prologue_and_epilogue_insns): Likewise.\n\t* print-rtl.c (print_rtx): Likewise.\n\t* profile.c (branch_prob): Likewise.\n\t* trans-mem.c (ipa_tm_scan_irr_block): Likewise.\n\t* gimplify.c (gimplify_call_expr): Likewise.\n\t* except.c (duplicate_eh_regions_1): Likewise.\n\t* emit-rtl.c (try_split): Likewise.\n\t(make_insn_raw): Likewise.\n\t(make_debug_insn_raw): Likewise.\n\t(make_jump_insn_raw): Likewise.\n\t(make_call_insn_raw): Likewise.\n\t(emit_pattern_after_setloc): Likewise.\n\t(emit_pattern_after): Likewise.\n\t(emit_debug_insn_after): Likewise.\n\t(emit_pattern_before): Likewise.\n\t(emit_insn_before_setloc): Likewise.\n\t(emit_jump_insn_before): Likewise.\n\t(emit_call_insn_before_setloc): Likewise.\n\t(emit_call_insn_before): Likeise.\n\t(emit_debug_insn_before_setloc): Likewise.\n\t(emit_copy_of_insn_after): Likewise.\n\t(insn_locators_alloc): Remove.\n\t(insn_locators_finalize): Remove.\n\t(insn_locators_free): Remove.\n\t(set_curr_insn_source_location): Remove.\n\t(get_curr_insn_source_location): Remove.\n\t(set_curr_insn_block): Remove.\n\t(get_curr_insn_block): Remove.\n\t(locator_scope): Remove.\n\t(insn_scope): Change to use new location.\n\t(locator_location): Remove.\n\t(insn_line): Change to use new location.\n\t(locator_file): Remove.\n\t(insn_file): Change to use new location.\n\t(locator_eq): Remove.\n\t(insn_locations_init): New.\n\t(insn_locations_finalize): New.\n\t(set_curr_insn_location): New.\n\t(curr_insn_location): New.\n\t* cfgexpand.c (gimple_assign_rhs_to_tree): Change to use new location.\n\t(expand_gimple_cond): Likewise.\n\t(expand_call_stmt): Likewise.\n\t(expand_gimple_stmt_1): Likewise.\n\t(expand_gimple_basic_block): Likewise.\n\t(construct_exit_block): Likewise.\n\t(gimple_expand_cfg): Likewise.\n\t* cfgcleanup.c (try_forward_edges): Likewise.\n\t* tree-ssa-live.c (remove_unused_scope_block_p): Likewise.\n\t(dump_scope_block): Likewise.\n\t(remove_unused_locals): Likewise.\n\t* rtl.c (rtx_equal_p_cb): Likewise.\n\t(rtx_equal_p): Likewise.\n\t* rtl.h (XUINT): New.\n\t(INSN_LOCATOR): Remove.\n\t(CURR_INSN_LOCATION): Remove.\n\t(INSN_LOCATION): New.\n\t(INSN_HAS_LOCATION): New.\n\t* tree-inline.c (remap_gimple_op_r): Change to use new location.\n\t(copy_tree_body_r): Likewise.\n\t(copy_phis_for_bb): Likewise.\n\t(expand_call_inline): Likewise.\n\t* tree-streamer-in.c (lto_input_ts_exp_tree_pointers): Likewise.\n\t* tree-streamer-out.c (write_ts_decl_minimal_tree_pointers): Likewise.\n\t* gimple-streamer-out.c (output_gimple_stmt): Likewise.\n\t* combine.c (try_combine): Likewise.\n\t* tree-outof-ssa.c (set_location_for_edge): Likewise.\n\t(insert_partition_copy_on_edge): Likewise.\n\t(insert_value_copy_on_edge): Likewise.\n\t(insert_rtx_to_part_on_edge): Likewise.\n\t(insert_part_to_rtx_on_edge): Likewise.\n\t* basic-block.h (edge_def): Remove field.\n\t* gimple.h (gimple_statement_base): Remove field.\n\t(gimple_bb): Change to use new location.\n\t(gimple_set_block): Likewise.\n\t(gimple_has_location): Likewise.\n\t* tree-cfg.c (make_cond_expr_edges): Likewise.\n\t(make_goto_expr_edges): Likewise.\n\t(gimple_can_merge_blocks_p): Likewise.\n\t(move_stmt_op): Likewise.\n\t(move_block_to_fn): Likewise.\n\t* config/alpha/alpha.c (alpha_output_mi_thunk_osf): Likewise.\n\t* config/sparc/sparc.c (sparc_output_mi_thunk): Likewise.\n\t* config/i386/i386.c (x86_output_mi_thunk): Likewise.\n\t* config/tilegx/tilegx.c (tilegx_output_mi_thunk): Likewise.\n\t* config/sh/sh.c (sh_output_mi_thunk): Likewise.\n\t* config/ia64/ia64.c (ia64_output_mi_thunk): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_output_mi_thunk): Likewise.\n\t* config/score/score.c (score_output_mi_thunk): Likewise.\n\t* config/tilepro/tilepro.c (tilepro_asm_output_mi_thunk): Likewise.\n\t* config/mips/mips.c (mips_output_mi_thunk): Likewise.\n\t* cfgrtl.c (unique_locus_on_edge_between_p): Likewise.\n\t(unique_locus_on_edge_between_p): Likewise.\n\t(emit_nop_for_unique_locus_between): Likewise.\n\t(force_nonfallthru_and_redirect): Likewise.\n\t(fixup_reorder_chain): Likewise.\n\t(cfg_layout_merge_blocks): Likewise.\n\t* stmt.c (emit_case_nodes): Likewise.\n\ngcc/lto:\n\t2012-09-19  Dehao Chen  <dehao@google.com>\n\n\t* lto/lto.c (lto_fixup_prevailing_decls): Remove tree.exp.block field.\n\nlibcpp:\n\t2012-09-19  Dehao Chen  <dehao@google.com>\n\n\t* include/line-map.h (MAX_SOURCE_LOCATION): New value.\n\t(location_adhoc_data_fini): New.\n\t(get_combined_adhoc_loc): New.\n\t(get_data_from_adhoc_loc): New.\n\t(get_location_from_adhoc_loc): New.\n\t(location_adhoc_data_map): New.\n\t(COMBINE_LOCATION_DATA): New.\n\t(IS_ADHOC_LOC): New.\n\t(expanded_location): New field.\n\t(line_maps): New field.\n\t* line-map.c (location_adhoc_data): New.\n\t(location_adhoc_data_hash): New.\n\t(location_adhoc_data_eq): New.\n\t(location_adhoc_data_update): New.\n\t(get_combined_adhoc_loc): New.\n\t(get_data_from_adhoc_loc): New.\n\t(get_location_from_adhoc_loc): New.\n\t(location_adhoc_data_init): New.\n\t(location_adhoc_data_fini): New.\n\t(linemap_init): Initialize location_adhoc_data.\n\t(linemap_lookup): Change to use new location.\n\t(linemap_ordinary_map_lookup): Likewise.\n\t(linemap_macro_map_lookup): Likewise.\n\t(linemap_macro_map_loc_to_def_point): Likewise.\n\t(linemap_macro_map_loc_unwind_toward_spel): Likewise.\n\t(linemap_get_expansion_line): Likewise.\n\t(linemap_get_expansion_filename): Likewise.\n\t(linemap_location_in_system_header_p): Likewise.\n\t(linemap_location_from_macro_expansion_p): Likewise.\n\t(linemap_macro_loc_to_spelling_point): Likewise.\n\t(linemap_macro_loc_to_def_point): Likewise.\n\t(linemap_macro_loc_to_exp_point): Likewise.\n\t(linemap_resolve_location): Likewise.\n\t(linemap_unwind_toward_expansion): Likewise.\n\t(linemap_unwind_to_first_non_reserved_loc): Likewise.\n\t(linemap_expand_location): Likewise.\n\t(linemap_dump_location): Likewise.\n\t(linemap_line_start): Likewise.\n\nFrom-SVN: r191494", "tree": {"sha": "cb527556784345ff0f9931444fd4e51652a67835", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb527556784345ff0f9931444fd4e51652a67835"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5368224f426c0dbe08a42e89d4cd18b0c8435834", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5368224f426c0dbe08a42e89d4cd18b0c8435834", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5368224f426c0dbe08a42e89d4cd18b0c8435834", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5368224f426c0dbe08a42e89d4cd18b0c8435834/comments", "author": {"login": "danielcdh", "id": 694263, "node_id": "MDQ6VXNlcjY5NDI2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/694263?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danielcdh", "html_url": "https://github.com/danielcdh", "followers_url": "https://api.github.com/users/danielcdh/followers", "following_url": "https://api.github.com/users/danielcdh/following{/other_user}", "gists_url": "https://api.github.com/users/danielcdh/gists{/gist_id}", "starred_url": "https://api.github.com/users/danielcdh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danielcdh/subscriptions", "organizations_url": "https://api.github.com/users/danielcdh/orgs", "repos_url": "https://api.github.com/users/danielcdh/repos", "events_url": "https://api.github.com/users/danielcdh/events{/privacy}", "received_events_url": "https://api.github.com/users/danielcdh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1a83e602a157b844ed98d0dab832c1240ed6bf4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a83e602a157b844ed98d0dab832c1240ed6bf4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a83e602a157b844ed98d0dab832c1240ed6bf4b"}], "stats": {"total": 1250, "additions": 748, "deletions": 502}, "files": [{"sha": "d3222b81365d79ebab4a15207b79625ce996494d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -1,3 +1,143 @@\n+2012-09-19  Dehao Chen  <dehao@google.com>\n+\n+\t* toplev.c (general_init): Init block_locations.\n+\t* tree.c (tree_set_block): New.\n+\t(tree_block): Change to use LOCATION_BLOCK.\n+\t* tree.h (TREE_SET_BLOCK): New.\n+\t* final.c (reemit_insn_block_notes): Change to use LOCATION_BLOCK.\n+\t(final_start_function): Likewise.\n+\t* input.c (expand_location_1): Likewise.\n+\t* input.h (LOCATION_LOCUS): New.\n+\t(LOCATION_BLOCK): New.\n+\t(IS_UNKNOWN_LOCATION): New.\n+\t* fold-const.c (expr_location_or): Change to use new location.\n+\t* reorg.c (emit_delay_sequence): Likewise.\n+\t(try_merge_delay_insns): Likewise.\n+\t* modulo-sched.c (dump_insn_location): Likewise.\n+\t* lto-streamer-out.c (lto_output_location_bitpack): Likewise.\n+\t* lto-cgraph.c (output_node_opt_summary): Likewise.\n+\t* jump.c (rtx_renumbered_equal_p): Likewise.\n+\t* ifcvt.c (noce_try_move): Likewise.\n+\t(noce_try_store_flag): Likewise.\n+\t(noce_try_store_flag_constants): Likewise.\n+\t(noce_try_addcc): Likewise.\n+\t(noce_try_store_flag_mask): Likewise.\n+\t(noce_try_cmove): Likewise.\n+\t(noce_try_cmove_arith): Likewise.\n+\t(noce_try_minmax): Likewise.\n+\t(noce_try_abs): Likewise.\n+\t(noce_try_sign_mask): Likewise.\n+\t(noce_try_bitop): Likewise.\n+\t(noce_process_if_block): Likewise.\n+\t(cond_move_process_if_block): Likewise.\n+\t(find_cond_trap): Likewise.\n+\t* ipa-prop.c (ipa_set_jf_constant): Likewise.\n+\t(ipa_write_jump_function): Likewise.\n+\t* dwarf2out.c (add_src_coords_attributes): Likewise.\n+\t* expr.c (expand_expr_real): Likewise.\n+\t* tree-parloops.c (create_loop_fn): Likewise.\n+\t* recog.c (peep2_attempt): Likewise.\n+\t* function.c (free_after_compilation): Likewise.\n+\t(expand_function_end): Likewise.\n+\t(set_insn_locations): Likewise.\n+\t(thread_prologue_and_epilogue_insns): Likewise.\n+\t* print-rtl.c (print_rtx): Likewise.\n+\t* profile.c (branch_prob): Likewise.\n+\t* trans-mem.c (ipa_tm_scan_irr_block): Likewise.\n+\t* gimplify.c (gimplify_call_expr): Likewise.\n+\t* except.c (duplicate_eh_regions_1): Likewise.\n+\t* emit-rtl.c (try_split): Likewise.\n+\t(make_insn_raw): Likewise.\n+\t(make_debug_insn_raw): Likewise.\n+\t(make_jump_insn_raw): Likewise.\n+\t(make_call_insn_raw): Likewise.\n+\t(emit_pattern_after_setloc): Likewise.\n+\t(emit_pattern_after): Likewise.\n+\t(emit_debug_insn_after): Likewise.\n+\t(emit_pattern_before): Likewise.\n+\t(emit_insn_before_setloc): Likewise.\n+\t(emit_jump_insn_before): Likewise.\n+\t(emit_call_insn_before_setloc): Likewise.\n+\t(emit_call_insn_before): Likeise.\n+\t(emit_debug_insn_before_setloc): Likewise.\n+\t(emit_copy_of_insn_after): Likewise.\n+\t(insn_locators_alloc): Remove.\n+\t(insn_locators_finalize): Remove.\n+\t(insn_locators_free): Remove.\n+\t(set_curr_insn_source_location): Remove.\n+\t(get_curr_insn_source_location): Remove.\n+\t(set_curr_insn_block): Remove.\n+\t(get_curr_insn_block): Remove.\n+\t(locator_scope): Remove.\n+\t(insn_scope): Change to use new location.\n+\t(locator_location): Remove.\n+\t(insn_line): Change to use new location.\n+\t(locator_file): Remove.\n+\t(insn_file): Change to use new location.\n+\t(locator_eq): Remove.\n+\t(insn_locations_init): New.\n+\t(insn_locations_finalize): New.\n+\t(set_curr_insn_location): New.\n+\t(curr_insn_location): New.\n+\t* cfgexpand.c (gimple_assign_rhs_to_tree): Change to use new location.\n+\t(expand_gimple_cond): Likewise.\n+\t(expand_call_stmt): Likewise.\n+\t(expand_gimple_stmt_1): Likewise.\n+\t(expand_gimple_basic_block): Likewise.\n+\t(construct_exit_block): Likewise.\n+\t(gimple_expand_cfg): Likewise.\n+\t* cfgcleanup.c (try_forward_edges): Likewise.\n+\t* tree-ssa-live.c (remove_unused_scope_block_p): Likewise.\n+\t(dump_scope_block): Likewise.\n+\t(remove_unused_locals): Likewise.\n+\t* rtl.c (rtx_equal_p_cb): Likewise.\n+\t(rtx_equal_p): Likewise.\n+\t* rtl.h (XUINT): New.\n+\t(INSN_LOCATOR): Remove.\n+\t(CURR_INSN_LOCATION): Remove.\n+\t(INSN_LOCATION): New.\n+\t(INSN_HAS_LOCATION): New.\n+\t* tree-inline.c (remap_gimple_op_r): Change to use new location.\n+\t(copy_tree_body_r): Likewise.\n+\t(copy_phis_for_bb): Likewise.\n+\t(expand_call_inline): Likewise.\n+\t* tree-streamer-in.c (lto_input_ts_exp_tree_pointers): Likewise.\n+\t* tree-streamer-out.c (write_ts_decl_minimal_tree_pointers): Likewise.\n+\t* gimple-streamer-out.c (output_gimple_stmt): Likewise.\n+\t* combine.c (try_combine): Likewise.\n+\t* tree-outof-ssa.c (set_location_for_edge): Likewise.\n+\t(insert_partition_copy_on_edge): Likewise.\n+\t(insert_value_copy_on_edge): Likewise.\n+\t(insert_rtx_to_part_on_edge): Likewise.\n+\t(insert_part_to_rtx_on_edge): Likewise.\n+\t* basic-block.h (edge_def): Remove field.\n+\t* gimple.h (gimple_statement_base): Remove field.\n+\t(gimple_bb): Change to use new location.\n+\t(gimple_set_block): Likewise.\n+\t(gimple_has_location): Likewise.\n+\t* tree-cfg.c (make_cond_expr_edges): Likewise.\n+\t(make_goto_expr_edges): Likewise.\n+\t(gimple_can_merge_blocks_p): Likewise.\n+\t(move_stmt_op): Likewise.\n+\t(move_block_to_fn): Likewise.\n+\t* config/alpha/alpha.c (alpha_output_mi_thunk_osf): Likewise.\n+\t* config/sparc/sparc.c (sparc_output_mi_thunk): Likewise.\n+\t* config/i386/i386.c (x86_output_mi_thunk): Likewise.\n+\t* config/tilegx/tilegx.c (tilegx_output_mi_thunk): Likewise.\n+\t* config/sh/sh.c (sh_output_mi_thunk): Likewise.\n+\t* config/ia64/ia64.c (ia64_output_mi_thunk): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_output_mi_thunk): Likewise.\n+\t* config/score/score.c (score_output_mi_thunk): Likewise.\n+\t* config/tilepro/tilepro.c (tilepro_asm_output_mi_thunk): Likewise.\n+\t* config/mips/mips.c (mips_output_mi_thunk): Likewise.\n+\t* cfgrtl.c (unique_locus_on_edge_between_p): Likewise.\n+\t(unique_locus_on_edge_between_p): Likewise.\n+\t(emit_nop_for_unique_locus_between): Likewise.\n+\t(force_nonfallthru_and_redirect): Likewise.\n+\t(fixup_reorder_chain): Likewise.\n+\t(cfg_layout_merge_blocks): Likewise.\n+\t* stmt.c (emit_case_nodes): Likewise.\n+\n 2012-09-19  Bernd Schmidt  <bernds@codesourcery.com>\n \n \t* dbgcnt.def (sched_breakdep): New counter."}, {"sha": "32dd17736647107652deac4988ea9f83af85d986", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -48,8 +48,7 @@ struct GTY((user)) edge_def {\n   /* Auxiliary info specific to a pass.  */\n   PTR aux;\n \n-  /* Location of any goto implicit in the edge and associated BLOCK.  */\n-  tree goto_block;\n+  /* Location of any goto implicit in the edge.  */\n   location_t goto_locus;\n \n   /* The index number corresponding to this edge in the edge vector"}, {"sha": "cb53c96b545c51ce3eba1e1bda2e9b902fc86e2a", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -481,27 +481,31 @@ try_forward_edges (int mode, basic_block b)\n \t\t  int new_locus = single_succ_edge (target)->goto_locus;\n \t\t  int locus = goto_locus;\n \n-\t\t  if (new_locus && locus && !locator_eq (new_locus, locus))\n+\t\t  if (!IS_UNKNOWN_LOCATION (new_locus)\n+\t\t      && !IS_UNKNOWN_LOCATION (locus)\n+\t\t      && new_locus != locus)\n \t\t    new_target = NULL;\n \t\t  else\n \t\t    {\n \t\t      rtx last;\n \n-\t\t      if (new_locus)\n+\t\t      if (!IS_UNKNOWN_LOCATION (new_locus))\n \t\t\tlocus = new_locus;\n \n \t\t      last = BB_END (target);\n \t\t      if (DEBUG_INSN_P (last))\n \t\t\tlast = prev_nondebug_insn (last);\n \n \t\t      new_locus = last && INSN_P (last)\n-\t\t\t\t  ? INSN_LOCATOR (last) : 0;\n+\t\t\t\t  ? INSN_LOCATION (last) : 0;\n \n-\t\t      if (new_locus && locus && !locator_eq (new_locus, locus))\n+\t\t      if (!IS_UNKNOWN_LOCATION (new_locus)\n+\t\t\t  && !IS_UNKNOWN_LOCATION (locus)\n+\t\t\t  && new_locus != locus)\n \t\t\tnew_target = NULL;\n \t\t      else\n \t\t\t{\n-\t\t\t  if (new_locus)\n+\t\t\t  if (!IS_UNKNOWN_LOCATION (new_locus))\n \t\t\t    locus = new_locus;\n \n \t\t\t  goto_locus = locus;"}, {"sha": "6b580d7439cdf14a4a2971c5ccd530235c4cbd7b", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 31, "deletions": 73, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -92,17 +92,14 @@ gimple_assign_rhs_to_tree (gimple stmt)\n \t   && gimple_location (stmt) != EXPR_LOCATION (t))\n \t  || (gimple_block (stmt)\n \t      && currently_expanding_to_rtl\n-\t      && EXPR_P (t)\n-\t      && gimple_block (stmt) != TREE_BLOCK (t)))\n+\t      && EXPR_P (t)))\n \tt = copy_node (t);\n     }\n   else\n     gcc_unreachable ();\n \n   if (gimple_has_location (stmt) && CAN_HAVE_LOCATION_P (t))\n     SET_EXPR_LOCATION (t, gimple_location (stmt));\n-  if (gimple_block (stmt) && currently_expanding_to_rtl && EXPR_P (t))\n-    TREE_BLOCK (t) = gimple_block (stmt);\n \n   return t;\n }\n@@ -1831,8 +1828,7 @@ expand_gimple_cond (basic_block bb, gimple stmt)\n   last2 = last = get_last_insn ();\n \n   extract_true_false_edges_from_block (bb, &true_edge, &false_edge);\n-  set_curr_insn_source_location (gimple_location (stmt));\n-  set_curr_insn_block (gimple_block (stmt));\n+  set_curr_insn_location (gimple_location (stmt));\n \n   /* These flags have no purpose in RTL land.  */\n   true_edge->flags &= ~EDGE_TRUE_VALUE;\n@@ -1845,13 +1841,8 @@ expand_gimple_cond (basic_block bb, gimple stmt)\n       jumpif_1 (code, op0, op1, label_rtx_for_bb (true_edge->dest),\n \t\ttrue_edge->probability);\n       maybe_dump_rtl_for_gimple_stmt (stmt, last);\n-      if (true_edge->goto_locus)\n-\t{\n-\t  set_curr_insn_source_location (true_edge->goto_locus);\n-\t  set_curr_insn_block (true_edge->goto_block);\n-\t  true_edge->goto_locus = curr_insn_locator ();\n-\t}\n-      true_edge->goto_block = NULL;\n+      if (!IS_UNKNOWN_LOCATION (true_edge->goto_locus))\n+\tset_curr_insn_location (true_edge->goto_locus);\n       false_edge->flags |= EDGE_FALLTHRU;\n       maybe_cleanup_end_of_block (false_edge, last);\n       return NULL;\n@@ -1861,13 +1852,8 @@ expand_gimple_cond (basic_block bb, gimple stmt)\n       jumpifnot_1 (code, op0, op1, label_rtx_for_bb (false_edge->dest),\n \t\t   false_edge->probability);\n       maybe_dump_rtl_for_gimple_stmt (stmt, last);\n-      if (false_edge->goto_locus)\n-\t{\n-\t  set_curr_insn_source_location (false_edge->goto_locus);\n-\t  set_curr_insn_block (false_edge->goto_block);\n-\t  false_edge->goto_locus = curr_insn_locator ();\n-\t}\n-      false_edge->goto_block = NULL;\n+      if (!IS_UNKNOWN_LOCATION (false_edge->goto_locus))\n+\tset_curr_insn_location (false_edge->goto_locus);\n       true_edge->flags |= EDGE_FALLTHRU;\n       maybe_cleanup_end_of_block (true_edge, last);\n       return NULL;\n@@ -1876,13 +1862,8 @@ expand_gimple_cond (basic_block bb, gimple stmt)\n   jumpif_1 (code, op0, op1, label_rtx_for_bb (true_edge->dest),\n \t    true_edge->probability);\n   last = get_last_insn ();\n-  if (false_edge->goto_locus)\n-    {\n-      set_curr_insn_source_location (false_edge->goto_locus);\n-      set_curr_insn_block (false_edge->goto_block);\n-      false_edge->goto_locus = curr_insn_locator ();\n-    }\n-  false_edge->goto_block = NULL;\n+  if (!IS_UNKNOWN_LOCATION (false_edge->goto_locus))\n+    set_curr_insn_location (false_edge->goto_locus);\n   emit_jump (label_rtx_for_bb (false_edge->dest));\n \n   BB_END (bb) = last;\n@@ -1907,13 +1888,11 @@ expand_gimple_cond (basic_block bb, gimple stmt)\n \n   maybe_dump_rtl_for_gimple_stmt (stmt, last2);\n \n-  if (true_edge->goto_locus)\n+  if (!IS_UNKNOWN_LOCATION (true_edge->goto_locus))\n     {\n-      set_curr_insn_source_location (true_edge->goto_locus);\n-      set_curr_insn_block (true_edge->goto_block);\n-      true_edge->goto_locus = curr_insn_locator ();\n+      set_curr_insn_location (true_edge->goto_locus);\n+      true_edge->goto_locus = curr_insn_location ();\n     }\n-  true_edge->goto_block = NULL;\n \n   return new_bb;\n }\n@@ -2013,7 +1992,6 @@ expand_call_stmt (gimple stmt)\n     CALL_FROM_THUNK_P (exp) = gimple_call_from_thunk_p (stmt);\n   CALL_EXPR_VA_ARG_PACK (exp) = gimple_call_va_arg_pack_p (stmt);\n   SET_EXPR_LOCATION (exp, gimple_location (stmt));\n-  TREE_BLOCK (exp) = gimple_block (stmt);\n \n   /* Ensure RTL is created for debug args.  */\n   if (decl && DECL_HAS_DEBUG_ARGS_P (decl))\n@@ -2048,8 +2026,7 @@ expand_gimple_stmt_1 (gimple stmt)\n {\n   tree op0;\n \n-  set_curr_insn_source_location (gimple_location (stmt));\n-  set_curr_insn_block (gimple_block (stmt));\n+  set_curr_insn_location (gimple_location (stmt));\n \n   switch (gimple_code (stmt))\n     {\n@@ -3793,8 +3770,7 @@ expand_gimple_basic_block (basic_block bb)\n \t  tree op;\n \t  gimple def;\n \n-\t  location_t sloc = get_curr_insn_source_location ();\n-\t  tree sblock = get_curr_insn_block ();\n+\t  location_t sloc = curr_insn_location ();\n \n \t  /* Look for SSA names that have their last use here (TERed\n \t     names always have only one real use).  */\n@@ -3827,8 +3803,7 @@ expand_gimple_basic_block (basic_block bb)\n \t\t    rtx val;\n \t\t    enum machine_mode mode;\n \n-\t\t    set_curr_insn_source_location (gimple_location (def));\n-\t\t    set_curr_insn_block (gimple_block (def));\n+\t\t    set_curr_insn_location (gimple_location (def));\n \n \t\t    DECL_ARTIFICIAL (vexpr) = 1;\n \t\t    TREE_TYPE (vexpr) = TREE_TYPE (value);\n@@ -3855,8 +3830,7 @@ expand_gimple_basic_block (basic_block bb)\n \t\t      }\n \t\t  }\n \t      }\n-\t  set_curr_insn_source_location (sloc);\n-\t  set_curr_insn_block (sblock);\n+\t  set_curr_insn_location (sloc);\n \t}\n \n       currently_expanding_gimple_stmt = stmt;\n@@ -3871,8 +3845,7 @@ expand_gimple_basic_block (basic_block bb)\n \t}\n       else if (gimple_debug_bind_p (stmt))\n \t{\n-\t  location_t sloc = get_curr_insn_source_location ();\n-\t  tree sblock = get_curr_insn_block ();\n+\t  location_t sloc = curr_insn_location ();\n \t  gimple_stmt_iterator nsi = gsi;\n \n \t  for (;;)\n@@ -3894,8 +3867,7 @@ expand_gimple_basic_block (basic_block bb)\n \n \t      last = get_last_insn ();\n \n-\t      set_curr_insn_source_location (gimple_location (stmt));\n-\t      set_curr_insn_block (gimple_block (stmt));\n+\t      set_curr_insn_location (gimple_location (stmt));\n \n \t      if (DECL_P (var))\n \t\tmode = DECL_MODE (var);\n@@ -3933,22 +3905,19 @@ expand_gimple_basic_block (basic_block bb)\n \t\tbreak;\n \t    }\n \n-\t  set_curr_insn_source_location (sloc);\n-\t  set_curr_insn_block (sblock);\n+\t  set_curr_insn_location (sloc);\n \t}\n       else if (gimple_debug_source_bind_p (stmt))\n \t{\n-\t  location_t sloc = get_curr_insn_source_location ();\n-\t  tree sblock = get_curr_insn_block ();\n+\t  location_t sloc = curr_insn_location ();\n \t  tree var = gimple_debug_source_bind_get_var (stmt);\n \t  tree value = gimple_debug_source_bind_get_value (stmt);\n \t  rtx val;\n \t  enum machine_mode mode;\n \n \t  last = get_last_insn ();\n \n-\t  set_curr_insn_source_location (gimple_location (stmt));\n-\t  set_curr_insn_block (gimple_block (stmt));\n+\t  set_curr_insn_location (gimple_location (stmt));\n \n \t  mode = DECL_MODE (var);\n \n@@ -3966,8 +3935,7 @@ expand_gimple_basic_block (basic_block bb)\n \t      PAT_VAR_LOCATION_LOC (val) = (rtx)value;\n \t    }\n \n-\t  set_curr_insn_source_location (sloc);\n-\t  set_curr_insn_block (sblock);\n+\t  set_curr_insn_location (sloc);\n \t}\n       else\n \t{\n@@ -4008,13 +3976,8 @@ expand_gimple_basic_block (basic_block bb)\n   /* Expand implicit goto and convert goto_locus.  */\n   FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n-      if (e->goto_locus && e->goto_block)\n-\t{\n-\t  set_curr_insn_source_location (e->goto_locus);\n-\t  set_curr_insn_block (e->goto_block);\n-\t  e->goto_locus = curr_insn_locator ();\n-\t}\n-      e->goto_block = NULL;\n+      if (!IS_UNKNOWN_LOCATION (e->goto_locus))\n+\tset_curr_insn_location (e->goto_locus);\n       if ((e->flags & EDGE_FALLTHRU) && e->dest != bb->next_bb)\n \t{\n \t  emit_jump (label_rtx_for_bb (e->dest));\n@@ -4134,12 +4097,9 @@ construct_exit_block (void)\n \n   /* Make sure the locus is set to the end of the function, so that\n      epilogue line numbers and warnings are set properly.  */\n-  if (cfun->function_end_locus != UNKNOWN_LOCATION)\n+  if (!IS_UNKNOWN_LOCATION (cfun->function_end_locus))\n     input_location = cfun->function_end_locus;\n \n-  /* The following insns belong to the top scope.  */\n-  set_curr_insn_block (DECL_INITIAL (current_function_decl));\n-\n   /* Generate rtl for function exit.  */\n   expand_function_end ();\n \n@@ -4357,20 +4317,19 @@ gimple_expand_cfg (void)\n \n   rtl_profile_for_bb (ENTRY_BLOCK_PTR);\n \n-  insn_locators_alloc ();\n+  insn_locations_init ();\n   if (!DECL_IS_BUILTIN (current_function_decl))\n     {\n       /* Eventually, all FEs should explicitly set function_start_locus.  */\n-      if (cfun->function_start_locus == UNKNOWN_LOCATION)\n-       set_curr_insn_source_location\n+      if (IS_UNKNOWN_LOCATION (cfun->function_start_locus))\n+       set_curr_insn_location\n          (DECL_SOURCE_LOCATION (current_function_decl));\n       else\n-       set_curr_insn_source_location (cfun->function_start_locus);\n+       set_curr_insn_location (cfun->function_start_locus);\n     }\n   else\n-    set_curr_insn_source_location (UNKNOWN_LOCATION);\n-  set_curr_insn_block (DECL_INITIAL (current_function_decl));\n-  prologue_locator = curr_insn_locator ();\n+    set_curr_insn_location (UNKNOWN_LOCATION);\n+  prologue_location = curr_insn_location ();\n \n #ifdef INSN_SCHEDULING\n   init_sched_attrs ();\n@@ -4551,8 +4510,7 @@ gimple_expand_cfg (void)\n   free_histograms ();\n \n   construct_exit_block ();\n-  set_curr_insn_block (DECL_INITIAL (current_function_decl));\n-  insn_locators_finalize ();\n+  insn_locations_finalize ();\n \n   /* Zap the tree EH table.  */\n   set_eh_throw_stmt_table (cfun, NULL);"}, {"sha": "c04482ecca8a45920b420643ec3a930623172854", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -720,19 +720,19 @@ rtl_split_block (basic_block bb, void *insnp)\n static bool\n unique_locus_on_edge_between_p (basic_block a, basic_block b)\n {\n-  const int goto_locus = EDGE_SUCC (a, 0)->goto_locus;\n+  const location_t goto_locus = EDGE_SUCC (a, 0)->goto_locus;\n   rtx insn, end;\n \n-  if (!goto_locus)\n+  if (IS_UNKNOWN_LOCATION (goto_locus))\n     return false;\n \n   /* First scan block A backward.  */\n   insn = BB_END (a);\n   end = PREV_INSN (BB_HEAD (a));\n-  while (insn != end && (!NONDEBUG_INSN_P (insn) || INSN_LOCATOR (insn) == 0))\n+  while (insn != end && (!NONDEBUG_INSN_P (insn) || !INSN_HAS_LOCATION (insn)))\n     insn = PREV_INSN (insn);\n \n-  if (insn != end && locator_eq (INSN_LOCATOR (insn), goto_locus))\n+  if (insn != end && INSN_LOCATION (insn) == goto_locus)\n     return false;\n \n   /* Then scan block B forward.  */\n@@ -743,8 +743,8 @@ unique_locus_on_edge_between_p (basic_block a, basic_block b)\n       while (insn != end && !NONDEBUG_INSN_P (insn))\n \tinsn = NEXT_INSN (insn);\n \n-      if (insn != end && INSN_LOCATOR (insn) != 0\n-\t  && locator_eq (INSN_LOCATOR (insn), goto_locus))\n+      if (insn != end && INSN_HAS_LOCATION (insn)\n+\t  && INSN_LOCATION (insn) == goto_locus)\n \treturn false;\n     }\n \n@@ -761,7 +761,7 @@ emit_nop_for_unique_locus_between (basic_block a, basic_block b)\n     return;\n \n   BB_END (a) = emit_insn_after_noloc (gen_nop (), BB_END (a), a);\n-  INSN_LOCATOR (BB_END (a)) = EDGE_SUCC (a, 0)->goto_locus;\n+  INSN_LOCATION (BB_END (a)) = EDGE_SUCC (a, 0)->goto_locus;\n }\n \n /* Blocks A and B are to be merged into a single block A.  The insns\n@@ -1477,7 +1477,7 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n   else\n     jump_block = e->src;\n \n-  if (e->goto_locus && e->goto_block == NULL)\n+  if (!IS_UNKNOWN_LOCATION (e->goto_locus))\n     loc = e->goto_locus;\n   else\n     loc = 0;\n@@ -3335,7 +3335,8 @@ fixup_reorder_chain (void)\n         edge_iterator ei;\n \n         FOR_EACH_EDGE (e, ei, bb->succs)\n-\t  if (e->goto_locus && !(e->flags & EDGE_ABNORMAL))\n+\t  if (!IS_UNKNOWN_LOCATION (e->goto_locus)\n+\t      && !(e->flags & EDGE_ABNORMAL))\n \t    {\n \t      edge e2;\n \t      edge_iterator ei2;\n@@ -3345,15 +3346,15 @@ fixup_reorder_chain (void)\n \t      insn = BB_END (e->src);\n \t      end = PREV_INSN (BB_HEAD (e->src));\n \t      while (insn != end\n-\t\t     && (!NONDEBUG_INSN_P (insn) || INSN_LOCATOR (insn) == 0))\n+\t\t     && (!NONDEBUG_INSN_P (insn) || !INSN_HAS_LOCATION (insn)))\n \t\tinsn = PREV_INSN (insn);\n \t      if (insn != end\n-\t\t  && locator_eq (INSN_LOCATOR (insn), (int) e->goto_locus))\n+\t\t  && INSN_LOCATION (insn) == e->goto_locus)\n \t\tcontinue;\n \t      if (simplejump_p (BB_END (e->src))\n-\t\t  && INSN_LOCATOR (BB_END (e->src)) == 0)\n+\t\t  && !INSN_HAS_LOCATION (BB_END (e->src)))\n \t\t{\n-\t\t  INSN_LOCATOR (BB_END (e->src)) = e->goto_locus;\n+\t\t  INSN_LOCATION (BB_END (e->src)) = e->goto_locus;\n \t\t  continue;\n \t\t}\n \t      dest = e->dest;\n@@ -3369,24 +3370,24 @@ fixup_reorder_chain (void)\n \t\t  end = NEXT_INSN (BB_END (dest));\n \t\t  while (insn != end && !NONDEBUG_INSN_P (insn))\n \t\t    insn = NEXT_INSN (insn);\n-\t\t  if (insn != end && INSN_LOCATOR (insn)\n-\t\t      && locator_eq (INSN_LOCATOR (insn), (int) e->goto_locus))\n+\t\t  if (insn != end && INSN_HAS_LOCATION (insn)\n+\t\t      && INSN_LOCATION (insn) == e->goto_locus)\n \t\t    continue;\n \t\t}\n \t      nb = split_edge (e);\n \t      if (!INSN_P (BB_END (nb)))\n \t\tBB_END (nb) = emit_insn_after_noloc (gen_nop (), BB_END (nb),\n \t\t\t\t\t\t     nb);\n-\t      INSN_LOCATOR (BB_END (nb)) = e->goto_locus;\n+\t      INSN_LOCATION (BB_END (nb)) = e->goto_locus;\n \n \t      /* If there are other incoming edges to the destination block\n \t\t with the same goto locus, redirect them to the new block as\n \t\t well, this can prevent other such blocks from being created\n \t\t in subsequent iterations of the loop.  */\n \t      for (ei2 = ei_start (dest->preds); (e2 = ei_safe_edge (ei2)); )\n-\t\tif (e2->goto_locus\n+\t\tif (!IS_UNKNOWN_LOCATION (e2->goto_locus)\n \t\t    && !(e2->flags & (EDGE_ABNORMAL | EDGE_FALLTHRU))\n-\t\t    && locator_eq (e->goto_locus, e2->goto_locus))\n+\t\t    && e->goto_locus == e2->goto_locus)\n \t\t  redirect_edge_and_branch (e2, nb);\n \t\telse\n \t\t  ei_next (&ei2);\n@@ -4086,7 +4087,7 @@ cfg_layout_merge_blocks (basic_block a, basic_block b)\n     }\n \n   /* If B was a forwarder block, propagate the locus on the edge.  */\n-  if (forwarder_p && !EDGE_SUCC (b, 0)->goto_locus)\n+  if (forwarder_p && IS_UNKNOWN_LOCATION (EDGE_SUCC (b, 0)->goto_locus))\n     EDGE_SUCC (b, 0)->goto_locus = EDGE_SUCC (a, 0)->goto_locus;\n \n   if (dump_file)"}, {"sha": "ad86f68d26dd0f609fee1b0777ac03dab9e4605e", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -2739,7 +2739,7 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n \n \t  i1 = gen_rtx_INSN (VOIDmode, INSN_UID (i2), NULL_RTX, i2,\n \t\t\t     BLOCK_FOR_INSN (i2), XVECEXP (PATTERN (i2), 0, 1),\n-\t\t\t     INSN_LOCATOR (i2), -1, NULL_RTX);\n+\t\t\t     INSN_LOCATION (i2), -1, NULL_RTX);\n \n \t  SUBST (PATTERN (i2), XVECEXP (PATTERN (i2), 0, 0));\n \t  SUBST (XEXP (SET_SRC (PATTERN (i2)), 0),"}, {"sha": "9aaa4f2bd2fd6290ee9a3e9cee1eee0e5a93c359", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -8362,7 +8362,6 @@ alpha_output_mi_thunk_osf (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n      instruction scheduling worth while.  Note that use_thunk calls\n      assemble_start_function and assemble_end_function.  */\n   insn = get_insns ();\n-  insn_locators_alloc ();\n   shorten_branches (insn);\n   final_start_function (insn, file, 1);\n   final (insn, file, 1);"}, {"sha": "68285717d8a62c2d115b77d400fcccd90db9fd58", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -33433,7 +33433,6 @@ x86_output_mi_thunk (FILE *file,\n   /* Emit just enough of rest_of_compilation to get the insns emitted.\n      Note that use_thunk calls assemble_start_function et al.  */\n   tmp = get_insns ();\n-  insn_locators_alloc ();\n   shorten_branches (tmp);\n   final_start_function (tmp, file, 1);\n   final (tmp, file, 1);"}, {"sha": "66f85dede86c9437945859f989b68a6fcb574710", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -10852,7 +10852,6 @@ ia64_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n      instruction scheduling worth while.  Note that use_thunk calls\n      assemble_start_function and assemble_end_function.  */\n \n-  insn_locators_alloc ();\n   emit_all_insn_group_barriers (NULL);\n   insn = get_insns ();\n   shorten_branches (insn);"}, {"sha": "fe5ee840383760c8d1fa308f1a5f11159fc3bcf3", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -15864,7 +15864,6 @@ mips_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   /* Run just enough of rest_of_compilation.  This sequence was\n      \"borrowed\" from alpha.c.  */\n   insn = get_insns ();\n-  insn_locators_alloc ();\n   split_all_insns_noflow ();\n   mips16_lay_out_constants (true);\n   shorten_branches (insn);"}, {"sha": "ce68d0a8804e114cad796c3c8f11d36c4ad35fc5", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -21696,7 +21696,6 @@ rs6000_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n      instruction scheduling worth while.  Note that use_thunk calls\n      assemble_start_function and assemble_end_function.  */\n   insn = get_insns ();\n-  insn_locators_alloc ();\n   shorten_branches (insn);\n   final_start_function (insn, file, 1);\n   final (insn, file, 1);"}, {"sha": "33efe6f0029f037361053989b84bc12c08f70e96", "filename": "gcc/config/score/score.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fconfig%2Fscore%2Fscore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fconfig%2Fscore%2Fscore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -502,7 +502,6 @@ score_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   /* Run just enough of rest_of_compilation.  This sequence was\n      \"borrowed\" from alpha.c.  */\n   insn = get_insns ();\n-  insn_locators_alloc ();\n   split_all_insns_noflow ();\n   shorten_branches (insn);\n   final_start_function (insn, file, 1);"}, {"sha": "63d6db028bb1d075f807550110939d22d8bc0f2d", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -12225,7 +12225,6 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n      the insns emitted.  Note that use_thunk calls\n      assemble_start_function and assemble_end_function.  */\n \n-  insn_locators_alloc ();\n   insns = get_insns ();\n \n   if (optimize > 0)"}, {"sha": "0f744e091abef78ec1f9cb231262f73a0100163c", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -10670,7 +10670,6 @@ sparc_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n      instruction scheduling worth while.  Note that use_thunk calls\n      assemble_start_function and assemble_end_function.  */\n   insn = get_insns ();\n-  insn_locators_alloc ();\n   shorten_branches (insn);\n   final_start_function (insn, file, 1);\n   final (insn, file, 1);"}, {"sha": "ef259361fb26c0fbce7f0ad9405cbc5e5a8c0bca", "filename": "gcc/config/tilegx/tilegx.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -4883,7 +4883,6 @@ tilegx_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n      serial except for the tail call, so we're only wasting one cycle.\n    */\n   insn = get_insns ();\n-  insn_locators_alloc ();\n   shorten_branches (insn);\n   final_start_function (insn, file, 1);\n   final (insn, file, 1);"}, {"sha": "e4c430872e78bb7f139839d3f65f80b9fd2ad187", "filename": "gcc/config/tilepro/tilepro.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -4407,7 +4407,6 @@ tilepro_asm_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n      serial except for the tail call, so we're only wasting one cycle.\n    */\n   insn = get_insns ();\n-  insn_locators_alloc ();\n   shorten_branches (insn);\n   final_start_function (insn, file, 1);\n   final (insn, file, 1);"}, {"sha": "8ee0f6a6327f517414eca234286d338b5546b974", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -15552,7 +15552,7 @@ add_src_coords_attributes (dw_die_ref die, tree decl)\n {\n   expanded_location s;\n \n-  if (DECL_SOURCE_LOCATION (decl) == UNKNOWN_LOCATION)\n+  if (IS_UNKNOWN_LOCATION (DECL_SOURCE_LOCATION (decl)))\n     return;\n   s = expand_location (DECL_SOURCE_LOCATION (decl));\n   add_AT_file (die, DW_AT_decl_file, lookup_filename (s.file));"}, {"sha": "a65558d0c8e56d030d8ec98e19dc01f9f38851bc", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 41, "deletions": 225, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -3653,7 +3653,7 @@ try_split (rtx pat, rtx trial, int last)\n \t}\n     }\n \n-  tem = emit_insn_after_setloc (seq, trial, INSN_LOCATOR (trial));\n+  tem = emit_insn_after_setloc (seq, trial, INSN_LOCATION (trial));\n \n   delete_insn (trial);\n   if (has_barrier)\n@@ -3689,7 +3689,7 @@ make_insn_raw (rtx pattern)\n   PATTERN (insn) = pattern;\n   INSN_CODE (insn) = -1;\n   REG_NOTES (insn) = NULL;\n-  INSN_LOCATOR (insn) = curr_insn_locator ();\n+  INSN_LOCATION (insn) = curr_insn_location ();\n   BLOCK_FOR_INSN (insn) = NULL;\n \n #ifdef ENABLE_RTL_CHECKING\n@@ -3722,7 +3722,7 @@ make_debug_insn_raw (rtx pattern)\n   PATTERN (insn) = pattern;\n   INSN_CODE (insn) = -1;\n   REG_NOTES (insn) = NULL;\n-  INSN_LOCATOR (insn) = curr_insn_locator ();\n+  INSN_LOCATION (insn) = curr_insn_location ();\n   BLOCK_FOR_INSN (insn) = NULL;\n \n   return insn;\n@@ -3742,7 +3742,7 @@ make_jump_insn_raw (rtx pattern)\n   INSN_CODE (insn) = -1;\n   REG_NOTES (insn) = NULL;\n   JUMP_LABEL (insn) = NULL;\n-  INSN_LOCATOR (insn) = curr_insn_locator ();\n+  INSN_LOCATION (insn) = curr_insn_location ();\n   BLOCK_FOR_INSN (insn) = NULL;\n \n   return insn;\n@@ -3762,7 +3762,7 @@ make_call_insn_raw (rtx pattern)\n   INSN_CODE (insn) = -1;\n   REG_NOTES (insn) = NULL;\n   CALL_INSN_FUNCTION_USAGE (insn) = NULL;\n-  INSN_LOCATOR (insn) = curr_insn_locator ();\n+  INSN_LOCATION (insn) = curr_insn_location ();\n   BLOCK_FOR_INSN (insn) = NULL;\n \n   return insn;\n@@ -4435,8 +4435,8 @@ emit_pattern_after_setloc (rtx pattern, rtx after, int loc,\n   after = NEXT_INSN (after);\n   while (1)\n     {\n-      if (active_insn_p (after) && !INSN_LOCATOR (after))\n-\tINSN_LOCATOR (after) = loc;\n+      if (active_insn_p (after) && !INSN_LOCATION (after))\n+\tINSN_LOCATION (after) = loc;\n       if (after == last)\n \tbreak;\n       after = NEXT_INSN (after);\n@@ -4459,62 +4459,62 @@ emit_pattern_after (rtx pattern, rtx after, bool skip_debug_insns,\n       prev = PREV_INSN (prev);\n \n   if (INSN_P (prev))\n-    return emit_pattern_after_setloc (pattern, after, INSN_LOCATOR (prev),\n+    return emit_pattern_after_setloc (pattern, after, INSN_LOCATION (prev),\n \t\t\t\t      make_raw);\n   else\n     return emit_pattern_after_noloc (pattern, after, NULL, make_raw);\n }\n \n-/* Like emit_insn_after_noloc, but set INSN_LOCATOR according to LOC.  */\n+/* Like emit_insn_after_noloc, but set INSN_LOCATION according to LOC.  */\n rtx\n emit_insn_after_setloc (rtx pattern, rtx after, int loc)\n {\n   return emit_pattern_after_setloc (pattern, after, loc, make_insn_raw);\n }\n \n-/* Like emit_insn_after_noloc, but set INSN_LOCATOR according to AFTER.  */\n+/* Like emit_insn_after_noloc, but set INSN_LOCATION according to AFTER.  */\n rtx\n emit_insn_after (rtx pattern, rtx after)\n {\n   return emit_pattern_after (pattern, after, true, make_insn_raw);\n }\n \n-/* Like emit_jump_insn_after_noloc, but set INSN_LOCATOR according to LOC.  */\n+/* Like emit_jump_insn_after_noloc, but set INSN_LOCATION according to LOC.  */\n rtx\n emit_jump_insn_after_setloc (rtx pattern, rtx after, int loc)\n {\n   return emit_pattern_after_setloc (pattern, after, loc, make_jump_insn_raw);\n }\n \n-/* Like emit_jump_insn_after_noloc, but set INSN_LOCATOR according to AFTER.  */\n+/* Like emit_jump_insn_after_noloc, but set INSN_LOCATION according to AFTER.  */\n rtx\n emit_jump_insn_after (rtx pattern, rtx after)\n {\n   return emit_pattern_after (pattern, after, true, make_jump_insn_raw);\n }\n \n-/* Like emit_call_insn_after_noloc, but set INSN_LOCATOR according to LOC.  */\n+/* Like emit_call_insn_after_noloc, but set INSN_LOCATION according to LOC.  */\n rtx\n emit_call_insn_after_setloc (rtx pattern, rtx after, int loc)\n {\n   return emit_pattern_after_setloc (pattern, after, loc, make_call_insn_raw);\n }\n \n-/* Like emit_call_insn_after_noloc, but set INSN_LOCATOR according to AFTER.  */\n+/* Like emit_call_insn_after_noloc, but set INSN_LOCATION according to AFTER.  */\n rtx\n emit_call_insn_after (rtx pattern, rtx after)\n {\n   return emit_pattern_after (pattern, after, true, make_call_insn_raw);\n }\n \n-/* Like emit_debug_insn_after_noloc, but set INSN_LOCATOR according to LOC.  */\n+/* Like emit_debug_insn_after_noloc, but set INSN_LOCATION according to LOC.  */\n rtx\n emit_debug_insn_after_setloc (rtx pattern, rtx after, int loc)\n {\n   return emit_pattern_after_setloc (pattern, after, loc, make_debug_insn_raw);\n }\n \n-/* Like emit_debug_insn_after_noloc, but set INSN_LOCATOR according to AFTER.  */\n+/* Like emit_debug_insn_after_noloc, but set INSN_LOCATION according to AFTER.  */\n rtx\n emit_debug_insn_after (rtx pattern, rtx after)\n {\n@@ -4544,8 +4544,8 @@ emit_pattern_before_setloc (rtx pattern, rtx before, int loc, bool insnp,\n     first = NEXT_INSN (first);\n   while (1)\n     {\n-      if (active_insn_p (first) && !INSN_LOCATOR (first))\n-\tINSN_LOCATOR (first) = loc;\n+      if (active_insn_p (first) && !INSN_LOCATION (first))\n+\tINSN_LOCATION (first) = loc;\n       if (first == last)\n \tbreak;\n       first = NEXT_INSN (first);\n@@ -4569,46 +4569,46 @@ emit_pattern_before (rtx pattern, rtx before, bool skip_debug_insns,\n       next = PREV_INSN (next);\n \n   if (INSN_P (next))\n-    return emit_pattern_before_setloc (pattern, before, INSN_LOCATOR (next),\n+    return emit_pattern_before_setloc (pattern, before, INSN_LOCATION (next),\n \t\t\t\t       insnp, make_raw);\n   else\n     return emit_pattern_before_noloc (pattern, before,\n                                       insnp ? before : NULL_RTX,\n                                       NULL, make_raw);\n }\n \n-/* Like emit_insn_before_noloc, but set INSN_LOCATOR according to LOC.  */\n+/* Like emit_insn_before_noloc, but set INSN_LOCATION according to LOC.  */\n rtx\n emit_insn_before_setloc (rtx pattern, rtx before, int loc)\n {\n   return emit_pattern_before_setloc (pattern, before, loc, true,\n \t\t\t\t     make_insn_raw);\n }\n \n-/* Like emit_insn_before_noloc, but set INSN_LOCATOR according to BEFORE.  */\n+/* Like emit_insn_before_noloc, but set INSN_LOCATION according to BEFORE.  */\n rtx\n emit_insn_before (rtx pattern, rtx before)\n {\n   return emit_pattern_before (pattern, before, true, true, make_insn_raw);\n }\n \n-/* like emit_insn_before_noloc, but set INSN_LOCATOR according to LOC.  */\n+/* like emit_insn_before_noloc, but set INSN_LOCATION according to LOC.  */\n rtx\n emit_jump_insn_before_setloc (rtx pattern, rtx before, int loc)\n {\n   return emit_pattern_before_setloc (pattern, before, loc, false,\n \t\t\t\t     make_jump_insn_raw);\n }\n \n-/* Like emit_jump_insn_before_noloc, but set INSN_LOCATOR according to BEFORE.  */\n+/* Like emit_jump_insn_before_noloc, but set INSN_LOCATION according to BEFORE.  */\n rtx\n emit_jump_insn_before (rtx pattern, rtx before)\n {\n   return emit_pattern_before (pattern, before, true, false,\n \t\t\t      make_jump_insn_raw);\n }\n \n-/* Like emit_insn_before_noloc, but set INSN_LOCATOR according to LOC.  */\n+/* Like emit_insn_before_noloc, but set INSN_LOCATION according to LOC.  */\n rtx\n emit_call_insn_before_setloc (rtx pattern, rtx before, int loc)\n {\n@@ -4617,15 +4617,15 @@ emit_call_insn_before_setloc (rtx pattern, rtx before, int loc)\n }\n \n /* Like emit_call_insn_before_noloc,\n-   but set insn_locator according to BEFORE.  */\n+   but set insn_location according to BEFORE.  */\n rtx\n emit_call_insn_before (rtx pattern, rtx before)\n {\n   return emit_pattern_before (pattern, before, true, false,\n \t\t\t      make_call_insn_raw);\n }\n \n-/* Like emit_insn_before_noloc, but set INSN_LOCATOR according to LOC.  */\n+/* Like emit_insn_before_noloc, but set INSN_LOCATION according to LOC.  */\n rtx\n emit_debug_insn_before_setloc (rtx pattern, rtx before, int loc)\n {\n@@ -4634,7 +4634,7 @@ emit_debug_insn_before_setloc (rtx pattern, rtx before, int loc)\n }\n \n /* Like emit_debug_insn_before_noloc,\n-   but set insn_locator according to BEFORE.  */\n+   but set insn_location according to BEFORE.  */\n rtx\n emit_debug_insn_before (rtx pattern, rtx before)\n {\n@@ -5881,7 +5881,7 @@ emit_copy_of_insn_after (rtx insn, rtx after)\n   /* Update LABEL_NUSES.  */\n   mark_jump_label (PATTERN (new_rtx), new_rtx, 0);\n \n-  INSN_LOCATOR (new_rtx) = INSN_LOCATOR (insn);\n+  INSN_LOCATION (new_rtx) = INSN_LOCATION (insn);\n \n   /* If the old insn is frame related, then so is the new one.  This is\n      primarily needed for IA-64 unwind info which marks epilogue insns,\n@@ -5916,249 +5916,65 @@ gen_hard_reg_clobber (enum machine_mode mode, unsigned int regno)\n \t    gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (mode, regno)));\n }\n \n-/* Data structures representing mapping of INSN_LOCATOR into scope blocks, line\n-   numbers and files.  In order to be GGC friendly we need to use separate\n-   varrays.  This also slightly improve the memory locality in binary search.\n-   The _locs array contains locators where the given property change.  The\n-   block_locators_blocks contains the scope block that is used for all insn\n-   locator greater than corresponding block_locators_locs value and smaller\n-   than the following one.  Similarly for the other properties.  */\n-static VEC(int,heap) *block_locators_locs;\n-static GTY(()) VEC(tree,gc) *block_locators_blocks;\n-static VEC(int,heap) *locations_locators_locs;\n-DEF_VEC_A(location_t);\n-DEF_VEC_ALLOC_A(location_t,heap);\n-static VEC(location_t,heap) *locations_locators_vals;\n-int prologue_locator;\n-int epilogue_locator;\n+location_t prologue_location;\n+location_t epilogue_location;\n \n /* Hold current location information and last location information, so the\n    datastructures are built lazily only when some instructions in given\n    place are needed.  */\n static location_t curr_location, last_location;\n-static tree curr_block, last_block;\n-static int curr_rtl_loc = -1;\n \n-/* Allocate insn locator datastructure.  */\n+/* Allocate insn location datastructure.  */\n void\n-insn_locators_alloc (void)\n+insn_locations_init (void)\n {\n-  prologue_locator = epilogue_locator = 0;\n-\n-  block_locators_locs = VEC_alloc (int, heap, 32);\n-  block_locators_blocks = VEC_alloc (tree, gc, 32);\n-  locations_locators_locs = VEC_alloc (int, heap, 32);\n-  locations_locators_vals = VEC_alloc (location_t, heap, 32);\n-\n+  prologue_location = epilogue_location = 0;\n   curr_location = UNKNOWN_LOCATION;\n   last_location = UNKNOWN_LOCATION;\n-  curr_block = NULL;\n-  last_block = NULL;\n-  curr_rtl_loc = 0;\n }\n \n /* At the end of emit stage, clear current location.  */\n void\n-insn_locators_finalize (void)\n+insn_locations_finalize (void)\n {\n-  if (curr_rtl_loc >= 0)\n-    epilogue_locator = curr_insn_locator ();\n-  curr_rtl_loc = -1;\n-}\n-\n-/* Allocate insn locator datastructure.  */\n-void\n-insn_locators_free (void)\n-{\n-  prologue_locator = epilogue_locator = 0;\n-\n-  VEC_free (int, heap, block_locators_locs);\n-  VEC_free (tree,gc, block_locators_blocks);\n-  VEC_free (int, heap, locations_locators_locs);\n-  VEC_free (location_t, heap, locations_locators_vals);\n+  epilogue_location = curr_location;\n+  curr_location = UNKNOWN_LOCATION;\n }\n \n /* Set current location.  */\n void\n-set_curr_insn_source_location (location_t location)\n+set_curr_insn_location (location_t location)\n {\n-  /* IV opts calls into RTL expansion to compute costs of operations.  At this\n-     time locators are not initialized.  */\n-  if (curr_rtl_loc == -1)\n-    return;\n   curr_location = location;\n }\n \n /* Get current location.  */\n location_t\n-get_curr_insn_source_location (void)\n+curr_insn_location (void)\n {\n   return curr_location;\n }\n \n-/* Set current scope block.  */\n-void\n-set_curr_insn_block (tree b)\n-{\n-  /* IV opts calls into RTL expansion to compute costs of operations.  At this\n-     time locators are not initialized.  */\n-  if (curr_rtl_loc == -1)\n-    return;\n-  if (b)\n-    curr_block = b;\n-}\n-\n-/* Get current scope block.  */\n-tree\n-get_curr_insn_block (void)\n-{\n-  return curr_block;\n-}\n-\n-/* Return current insn locator.  */\n-int\n-curr_insn_locator (void)\n-{\n-  if (curr_rtl_loc == -1 || curr_location == UNKNOWN_LOCATION)\n-    return 0;\n-  if (last_block != curr_block)\n-    {\n-      curr_rtl_loc++;\n-      VEC_safe_push (int, heap, block_locators_locs, curr_rtl_loc);\n-      VEC_safe_push (tree, gc, block_locators_blocks, curr_block);\n-      last_block = curr_block;\n-    }\n-  if (last_location != curr_location)\n-    {\n-      curr_rtl_loc++;\n-      VEC_safe_push (int, heap, locations_locators_locs, curr_rtl_loc);\n-      VEC_safe_push (location_t, heap, locations_locators_vals, curr_location);\n-      last_location = curr_location;\n-    }\n-  return curr_rtl_loc;\n-}\n-\f\n-\n-/* Return lexical scope block locator belongs to.  */\n-static tree\n-locator_scope (int loc)\n-{\n-  int max = VEC_length (int, block_locators_locs);\n-  int min = 0;\n-\n-  /* When block_locators_locs was initialized, the pro- and epilogue\n-     insns didn't exist yet and can therefore not be found this way.\n-     But we know that they belong to the outer most block of the\n-     current function.\n-     Without this test, the prologue would be put inside the block of\n-     the first valid instruction in the function and when that first\n-     insn is part of an inlined function then the low_pc of that\n-     inlined function is messed up.  Likewise for the epilogue and\n-     the last valid instruction.  */\n-  if (loc == prologue_locator || loc == epilogue_locator)\n-    return DECL_INITIAL (cfun->decl);\n-\n-  if (!max || !loc)\n-    return NULL;\n-  while (1)\n-    {\n-      int pos = (min + max) / 2;\n-      int tmp = VEC_index (int, block_locators_locs, pos);\n-\n-      if (tmp <= loc && min != pos)\n-\tmin = pos;\n-      else if (tmp > loc && max != pos)\n-\tmax = pos;\n-      else\n-\t{\n-\t  min = pos;\n-\t  break;\n-\t}\n-    }\n-  return VEC_index (tree, block_locators_blocks, min);\n-}\n-\n /* Return lexical scope block insn belongs to.  */\n tree\n insn_scope (const_rtx insn)\n {\n-  return locator_scope (INSN_LOCATOR (insn));\n-}\n-\n-/* Return line number of the statement specified by the locator.  */\n-location_t\n-locator_location (int loc)\n-{\n-  int max = VEC_length (int, locations_locators_locs);\n-  int min = 0;\n-\n-  while (1)\n-    {\n-      int pos = (min + max) / 2;\n-      int tmp = VEC_index (int, locations_locators_locs, pos);\n-\n-      if (tmp <= loc && min != pos)\n-\tmin = pos;\n-      else if (tmp > loc && max != pos)\n-\tmax = pos;\n-      else\n-\t{\n-\t  min = pos;\n-\t  break;\n-\t}\n-    }\n-  return VEC_index (location_t, locations_locators_vals, min);\n-}\n-\n-/* Return source line of the statement that produced this insn.  */\n-int\n-locator_line (int loc)\n-{\n-  expanded_location xloc;\n-  if (!loc)\n-    return 0;\n-  else\n-    xloc = expand_location (locator_location (loc));\n-  return xloc.line;\n+  return LOCATION_BLOCK (INSN_LOCATION (insn));\n }\n \n /* Return line number of the statement that produced this insn.  */\n int\n insn_line (const_rtx insn)\n {\n-  return locator_line (INSN_LOCATOR (insn));\n-}\n-\n-/* Return source file of the statement specified by LOC.  */\n-const char *\n-locator_file (int loc)\n-{\n-  expanded_location xloc;\n-  if (!loc)\n-    return 0;\n-  else\n-    xloc = expand_location (locator_location (loc));\n-  return xloc.file;\n+  return LOCATION_LINE (INSN_LOCATION (insn));\n }\n \n /* Return source file of the statement that produced this insn.  */\n const char *\n insn_file (const_rtx insn)\n {\n-  return locator_file (INSN_LOCATOR (insn));\n-}\n-\n-/* Return true if LOC1 and LOC2 locators have the same location and scope.  */\n-bool\n-locator_eq (int loc1, int loc2)\n-{\n-  if (loc1 == loc2)\n-    return true;\n-  if (locator_location (loc1) != locator_location (loc2))\n-    return false;\n-  return locator_scope (loc1) == locator_scope (loc2);\n+  return LOCATION_FILE (INSN_LOCATION (insn));\n }\n-\f\n \n /* Return true if memory model MODEL requires a pre-operation (release-style)\n    barrier or a post-operation (acquire-style) barrier.  While not universal,"}, {"sha": "88cac856dad36ce8f2a4c325e79a01debc6242ad", "filename": "gcc/except.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -526,7 +526,10 @@ duplicate_eh_regions_1 (struct duplicate_eh_regions_data *data,\n       break;\n \n     case ERT_MUST_NOT_THROW:\n-      new_r->u.must_not_throw = old_r->u.must_not_throw;\n+      new_r->u.must_not_throw.failure_loc =\n+\tLOCATION_LOCUS (old_r->u.must_not_throw.failure_loc);\n+      new_r->u.must_not_throw.failure_decl =\n+\told_r->u.must_not_throw.failure_decl;\n       break;\n     }\n "}, {"sha": "762444853064c50a5c086b11c92fa0dd53146975", "filename": "gcc/expr.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -7839,19 +7839,14 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n   if (cfun && EXPR_HAS_LOCATION (exp))\n     {\n       location_t saved_location = input_location;\n-      location_t saved_curr_loc = get_curr_insn_source_location ();\n-      tree saved_block = get_curr_insn_block ();\n+      location_t saved_curr_loc = curr_insn_location ();\n       input_location = EXPR_LOCATION (exp);\n-      set_curr_insn_source_location (input_location);\n-\n-      /* Record where the insns produced belong.  */\n-      set_curr_insn_block (TREE_BLOCK (exp));\n+      set_curr_insn_location (input_location);\n \n       ret = expand_expr_real_1 (exp, target, tmode, modifier, alt_rtl);\n \n       input_location = saved_location;\n-      set_curr_insn_block (saved_block);\n-      set_curr_insn_source_location (saved_curr_loc);\n+      set_curr_insn_location (saved_curr_loc);\n     }\n   else\n     {"}, {"sha": "08393405e8f77356ec3c80d95aab0e49ed8dbfcc", "filename": "gcc/final.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -1606,7 +1606,7 @@ reemit_insn_block_notes (void)\n \t\t\t\t\t     insn_scope (XVECEXP (body, 0, i)));\n \t}\n       if (! this_block)\n-\tcontinue;\n+\tthis_block = DECL_INITIAL (cfun->decl);\n \n       if (this_block != cur_block)\n \t{\n@@ -1641,8 +1641,8 @@ final_start_function (rtx first ATTRIBUTE_UNUSED, FILE *file,\n \n   this_is_asm_operands = 0;\n \n-  last_filename = locator_file (prologue_locator);\n-  last_linenum = locator_line (prologue_locator);\n+  last_filename = LOCATION_FILE (prologue_location);\n+  last_linenum = LOCATION_LINE (prologue_location);\n   last_discriminator = discriminator = 0;\n \n   high_block_linenum = high_function_linenum = last_linenum;"}, {"sha": "223dc684894350dcb6a7397a08e216c8b350883a", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -145,7 +145,7 @@ static location_t\n expr_location_or (tree t, location_t loc)\n {\n   location_t tloc = EXPR_LOCATION (t);\n-  return tloc != UNKNOWN_LOCATION ? tloc : loc;\n+  return IS_UNKNOWN_LOCATION (tloc) ? loc : tloc;\n }\n \n /* Similar to protected_set_expr_location, but never modify x in place,"}, {"sha": "ec21d9c3ea461fcc937814be97ebb4af4cc0bb96", "filename": "gcc/function.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -133,7 +133,7 @@ static bool contains (const_rtx, htab_t);\n static void prepare_function_start (void);\n static void do_clobber_return_reg (rtx, void *);\n static void do_use_return_reg (rtx, void *);\n-static void set_insn_locators (rtx, int) ATTRIBUTE_UNUSED;\n+static void set_insn_locations (rtx, int) ATTRIBUTE_UNUSED;\n \f\n /* Stack of nested functions.  */\n /* Keep track of the cfun stack.  */\n@@ -200,7 +200,6 @@ free_after_compilation (struct function *f)\n   f->cfg = NULL;\n \n   regno_reg_rtx = NULL;\n-  insn_locators_free ();\n }\n \f\n /* Return size needed for stack frame based on slots so far allocated.\n@@ -4979,7 +4978,7 @@ expand_function_end (void)\n \t      probe_stack_range (STACK_OLD_CHECK_PROTECT, max_frame_size);\n \t    seq = get_insns ();\n \t    end_sequence ();\n-\t    set_insn_locators (seq, prologue_locator);\n+\t    set_insn_locations (seq, prologue_location);\n \t    emit_insn_before (seq, stack_check_probe_note);\n \t    break;\n \t  }\n@@ -4994,7 +4993,7 @@ expand_function_end (void)\n \n   /* Output a linenumber for the end of the function.\n      SDB depends on this.  */\n-  set_curr_insn_source_location (input_location);\n+  set_curr_insn_location (input_location);\n \n   /* Before the return label (if any), clobber the return\n      registers so that they are not propagated live to the rest of\n@@ -5277,14 +5276,14 @@ maybe_copy_prologue_epilogue_insn (rtx insn, rtx copy)\n   *slot = copy;\n }\n \n-/* Set the locator of the insn chain starting at INSN to LOC.  */\n+/* Set the location of the insn chain starting at INSN to LOC.  */\n static void\n-set_insn_locators (rtx insn, int loc)\n+set_insn_locations (rtx insn, int loc)\n {\n   while (insn != NULL_RTX)\n     {\n       if (INSN_P (insn))\n-\tINSN_LOCATOR (insn) = loc;\n+\tINSN_LOCATION (insn) = loc;\n       insn = NEXT_INSN (insn);\n     }\n }\n@@ -5893,7 +5892,7 @@ thread_prologue_and_epilogue_insns (void)\n       end_sequence ();\n \n       record_insns (split_prologue_seq, NULL, &prologue_insn_hash);\n-      set_insn_locators (split_prologue_seq, prologue_locator);\n+      set_insn_locations (split_prologue_seq, prologue_location);\n #endif\n     }\n \n@@ -5922,7 +5921,7 @@ thread_prologue_and_epilogue_insns (void)\n \n       prologue_seq = get_insns ();\n       end_sequence ();\n-      set_insn_locators (prologue_seq, prologue_locator);\n+      set_insn_locations (prologue_seq, prologue_location);\n     }\n #endif\n \n@@ -6418,7 +6417,7 @@ thread_prologue_and_epilogue_insns (void)\n \n       /* Retain a map of the epilogue insns.  */\n       record_insns (seq, NULL, &epilogue_insn_hash);\n-      set_insn_locators (seq, epilogue_locator);\n+      set_insn_locations (seq, epilogue_location);\n \n       seq = get_insns ();\n       returnjump = get_last_insn ();\n@@ -6608,7 +6607,7 @@ thread_prologue_and_epilogue_insns (void)\n \t     avoid getting rid of sibcall epilogue insns.  Do this before we\n \t     actually emit the sequence.  */\n \t  record_insns (seq, NULL, &epilogue_insn_hash);\n-\t  set_insn_locators (seq, epilogue_locator);\n+\t  set_insn_locations (seq, epilogue_location);\n \n \t  emit_insn_before (seq, insn);\n \t}"}, {"sha": "22bcbca8d179ff4b000bb962287fb1481a47f2b0", "filename": "gcc/gimple-streamer-out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fgimple-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fgimple-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-out.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -74,7 +74,7 @@ output_gimple_stmt (struct output_block *ob, gimple stmt)\n   streamer_write_bitpack (&bp);\n \n   /* Emit location information for the statement.  */\n-  lto_output_location (ob, gimple_location (stmt));\n+  lto_output_location (ob, LOCATION_LOCUS (gimple_location (stmt)));\n \n   /* Emit the lexical block holding STMT.  */\n   stream_write_tree (ob, gimple_block (stmt), true);"}, {"sha": "7065040eb31e97974597c4082d62f0e1b69974e6", "filename": "gcc/gimple.c", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -856,10 +856,7 @@ gimple_build_debug_bind_stat (tree var, tree value, gimple stmt MEM_STAT_DECL)\n   gimple_debug_bind_set_var (p, var);\n   gimple_debug_bind_set_value (p, value);\n   if (stmt)\n-    {\n-      gimple_set_block (p, gimple_block (stmt));\n-      gimple_set_location (p, gimple_location (stmt));\n-    }\n+    gimple_set_location (p, gimple_location (stmt));\n \n   return p;\n }\n@@ -880,10 +877,7 @@ gimple_build_debug_source_bind_stat (tree var, tree value,\n   gimple_debug_source_bind_set_var (p, var);\n   gimple_debug_source_bind_set_value (p, value);\n   if (stmt)\n-    {\n-      gimple_set_block (p, gimple_block (stmt));\n-      gimple_set_location (p, gimple_location (stmt));\n-    }\n+    gimple_set_location (p, gimple_location (stmt));\n \n   return p;\n }\n@@ -3003,7 +2997,6 @@ gimple_call_copy_skip_args (gimple stmt, bitmap args_to_skip)\n   gimple_set_vuse (new_stmt, gimple_vuse (stmt));\n   gimple_set_vdef (new_stmt, gimple_vdef (stmt));\n \n-  gimple_set_block (new_stmt, gimple_block (stmt));\n   if (gimple_has_location (stmt))\n     gimple_set_location (new_stmt, gimple_location (stmt));\n   gimple_call_copy_flags (new_stmt, stmt);"}, {"sha": "27887e8211f3bbcd4de09dfa0e7a5127fcd94c09", "filename": "gcc/gimple.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -210,10 +210,6 @@ struct GTY((chain_next (\"%h.next\"))) gimple_statement_base {\n      and the prev pointer being the last.  */\n   gimple next;\n   gimple GTY((skip)) prev;\n-\n-  /* [ WORD 6 ]\n-     Lexical block holding this statement.  */\n-  tree block;\n };\n \n \n@@ -1196,7 +1192,7 @@ gimple_bb (const_gimple g)\n static inline tree\n gimple_block (const_gimple g)\n {\n-  return g->gsbase.block;\n+  return LOCATION_BLOCK (g->gsbase.location);\n }\n \n \n@@ -1205,7 +1201,11 @@ gimple_block (const_gimple g)\n static inline void\n gimple_set_block (gimple g, tree block)\n {\n-  g->gsbase.block = block;\n+  if (block)\n+    g->gsbase.location =\n+\tCOMBINE_LOCATION_DATA (line_table, g->gsbase.location, block);\n+  else\n+    g->gsbase.location = LOCATION_LOCUS (g->gsbase.location);\n }\n \n \n@@ -1240,7 +1240,7 @@ gimple_set_location (gimple g, location_t location)\n static inline bool\n gimple_has_location (const_gimple g)\n {\n-  return gimple_location (g) != UNKNOWN_LOCATION;\n+  return !IS_UNKNOWN_LOCATION (gimple_location (g));\n }\n \n "}, {"sha": "2bb334c37a8b4371e10447e7d93ee0fa1c11b2f7", "filename": "gcc/gimplify.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -2612,7 +2612,6 @@ gimplify_call_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n \t    = CALL_EXPR_RETURN_SLOT_OPT (call);\n \t  CALL_FROM_THUNK_P (*expr_p) = CALL_FROM_THUNK_P (call);\n \t  SET_EXPR_LOCATION (*expr_p, EXPR_LOCATION (call));\n-\t  TREE_BLOCK (*expr_p) = TREE_BLOCK (call);\n \n \t  /* Set CALL_EXPR_VA_ARG_PACK.  */\n \t  CALL_EXPR_VA_ARG_PACK (*expr_p) = 1;"}, {"sha": "2f486a231b7dc3a1f0831b1f09ad57f3e3a2b0b7", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -1020,7 +1020,7 @@ noce_try_move (struct noce_if_info *if_info)\n \t    return FALSE;\n \n \t  emit_insn_before_setloc (seq, if_info->jump,\n-\t\t\t\t   INSN_LOCATOR (if_info->insn_a));\n+\t\t\t\t   INSN_LOCATION (if_info->insn_a));\n \t}\n       return TRUE;\n     }\n@@ -1065,7 +1065,7 @@ noce_try_store_flag (struct noce_if_info *if_info)\n \treturn FALSE;\n \n       emit_insn_before_setloc (seq, if_info->jump,\n-\t\t\t       INSN_LOCATOR (if_info->insn_a));\n+\t\t\t       INSN_LOCATION (if_info->insn_a));\n       return TRUE;\n     }\n   else\n@@ -1196,7 +1196,7 @@ noce_try_store_flag_constants (struct noce_if_info *if_info)\n \treturn FALSE;\n \n       emit_insn_before_setloc (seq, if_info->jump,\n-\t\t\t       INSN_LOCATOR (if_info->insn_a));\n+\t\t\t       INSN_LOCATION (if_info->insn_a));\n       return TRUE;\n     }\n \n@@ -1244,7 +1244,7 @@ noce_try_addcc (struct noce_if_info *if_info)\n \t\treturn FALSE;\n \n \t      emit_insn_before_setloc (seq, if_info->jump,\n-\t\t\t\t       INSN_LOCATOR (if_info->insn_a));\n+\t\t\t\t       INSN_LOCATION (if_info->insn_a));\n \t      return TRUE;\n \t    }\n \t  end_sequence ();\n@@ -1284,7 +1284,7 @@ noce_try_addcc (struct noce_if_info *if_info)\n \t\treturn FALSE;\n \n \t      emit_insn_before_setloc (seq, if_info->jump,\n-\t\t\t\t       INSN_LOCATOR (if_info->insn_a));\n+\t\t\t\t       INSN_LOCATION (if_info->insn_a));\n \t      return TRUE;\n \t    }\n \t  end_sequence ();\n@@ -1333,7 +1333,7 @@ noce_try_store_flag_mask (struct noce_if_info *if_info)\n \t    return FALSE;\n \n \t  emit_insn_before_setloc (seq, if_info->jump,\n-\t\t\t\t   INSN_LOCATOR (if_info->insn_a));\n+\t\t\t\t   INSN_LOCATION (if_info->insn_a));\n \t  return TRUE;\n \t}\n \n@@ -1482,7 +1482,7 @@ noce_try_cmove (struct noce_if_info *if_info)\n \t    return FALSE;\n \n \t  emit_insn_before_setloc (seq, if_info->jump,\n-\t\t\t\t   INSN_LOCATOR (if_info->insn_a));\n+\t\t\t\t   INSN_LOCATION (if_info->insn_a));\n \t  return TRUE;\n \t}\n       else\n@@ -1683,7 +1683,7 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n   if (!tmp)\n     return FALSE;\n \n-  emit_insn_before_setloc (tmp, if_info->jump, INSN_LOCATOR (if_info->insn_a));\n+  emit_insn_before_setloc (tmp, if_info->jump, INSN_LOCATION (if_info->insn_a));\n   return TRUE;\n \n  end_seq_and_fail:\n@@ -1930,7 +1930,7 @@ noce_try_minmax (struct noce_if_info *if_info)\n   if (!seq)\n     return FALSE;\n \n-  emit_insn_before_setloc (seq, if_info->jump, INSN_LOCATOR (if_info->insn_a));\n+  emit_insn_before_setloc (seq, if_info->jump, INSN_LOCATION (if_info->insn_a));\n   if_info->cond = cond;\n   if_info->cond_earliest = earliest;\n \n@@ -2077,7 +2077,7 @@ noce_try_abs (struct noce_if_info *if_info)\n   if (!seq)\n     return FALSE;\n \n-  emit_insn_before_setloc (seq, if_info->jump, INSN_LOCATOR (if_info->insn_a));\n+  emit_insn_before_setloc (seq, if_info->jump, INSN_LOCATION (if_info->insn_a));\n   if_info->cond = cond;\n   if_info->cond_earliest = earliest;\n \n@@ -2156,7 +2156,7 @@ noce_try_sign_mask (struct noce_if_info *if_info)\n   if (!seq)\n     return FALSE;\n \n-  emit_insn_before_setloc (seq, if_info->jump, INSN_LOCATOR (if_info->insn_a));\n+  emit_insn_before_setloc (seq, if_info->jump, INSN_LOCATION (if_info->insn_a));\n   return TRUE;\n }\n \n@@ -2256,7 +2256,7 @@ noce_try_bitop (struct noce_if_info *if_info)\n \treturn FALSE;\n \n       emit_insn_before_setloc (seq, if_info->jump,\n-\t\t\t       INSN_LOCATOR (if_info->insn_a));\n+\t\t\t       INSN_LOCATION (if_info->insn_a));\n     }\n   return TRUE;\n }\n@@ -2657,7 +2657,7 @@ noce_process_if_block (struct noce_if_info *if_info)\n       unshare_all_rtl_in_chain (seq);\n       end_sequence ();\n \n-      emit_insn_before_setloc (seq, BB_END (test_bb), INSN_LOCATOR (insn_a));\n+      emit_insn_before_setloc (seq, BB_END (test_bb), INSN_LOCATION (insn_a));\n     }\n \n   /* The original THEN and ELSE blocks may now be removed.  The test block\n@@ -2929,7 +2929,7 @@ cond_move_process_if_block (struct noce_if_info *if_info)\n       loc_insn = first_active_insn (else_bb);\n       gcc_assert (loc_insn);\n     }\n-  emit_insn_before_setloc (seq, jump, INSN_LOCATOR (loc_insn));\n+  emit_insn_before_setloc (seq, jump, INSN_LOCATION (loc_insn));\n \n   if (else_bb)\n     {\n@@ -3652,7 +3652,7 @@ find_cond_trap (basic_block test_bb, edge then_edge, edge else_edge)\n     return FALSE;\n \n   /* Emit the new insns before cond_earliest.  */\n-  emit_insn_before_setloc (seq, cond_earliest, INSN_LOCATOR (trap));\n+  emit_insn_before_setloc (seq, cond_earliest, INSN_LOCATION (trap));\n \n   /* Delete the trap block if possible.  */\n   remove_edge (trap_bb == then_bb ? then_edge : else_edge);"}, {"sha": "c88e4c0c4487548f735290d7e60ead54cfa052aa", "filename": "gcc/input.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -51,6 +51,13 @@ expand_location_1 (source_location loc,\n   expanded_location xloc;\n   const struct line_map *map;\n   enum location_resolution_kind lrk = LRK_MACRO_EXPANSION_POINT;\n+  tree block = NULL;\n+\n+  if (IS_ADHOC_LOC (loc))\n+    {\n+      block = LOCATION_BLOCK (loc);\n+      loc = LOCATION_LOCUS (loc);\n+    }\n \n   memset (&xloc, 0, sizeof (xloc));\n \n@@ -74,6 +81,7 @@ expand_location_1 (source_location loc,\n       xloc = linemap_expand_location (line_table, map, loc);\n     }\n \n+  xloc.data = block;\n   if (loc <= BUILTINS_LOCATION)\n     xloc.file = loc == UNKNOWN_LOCATION ? NULL : _(\"<built-in>\");\n "}, {"sha": "689e25be3f391eff47b087c6d7a1f1fd0f26bc69", "filename": "gcc/input.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Finput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Finput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.h?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -51,6 +51,14 @@ extern location_t input_location;\n #define LOCATION_FILE(LOC) ((expand_location (LOC)).file)\n #define LOCATION_LINE(LOC) ((expand_location (LOC)).line)\n #define LOCATION_COLUMN(LOC)((expand_location (LOC)).column)\n+#define LOCATION_LOCUS(LOC) \\\n+  ((IS_ADHOC_LOC(LOC)) ? get_location_from_adhoc_loc (line_table, LOC) : (LOC))\n+#define LOCATION_BLOCK(LOC) \\\n+  ((tree) ((IS_ADHOC_LOC (LOC)) ? get_data_from_adhoc_loc (line_table, (LOC)) \\\n+  : NULL))\n+#define IS_UNKNOWN_LOCATION(LOC) \\\n+  ((IS_ADHOC_LOC (LOC)) ? get_location_from_adhoc_loc (line_table, LOC) == 0 \\\n+  : (LOC) == 0)\n \n #define input_line LOCATION_LINE (input_location)\n #define input_filename LOCATION_FILE (input_location)"}, {"sha": "13538d73a56672ccec26ff2dc7c7896f3fd9eadc", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -304,6 +304,9 @@ ipa_set_jf_known_type (struct ipa_jump_func *jfunc, HOST_WIDE_INT offset,\n static void\n ipa_set_jf_constant (struct ipa_jump_func *jfunc, tree constant)\n {\n+  constant = unshare_expr (constant);\n+  if (constant && EXPR_P (constant))\n+    SET_EXPR_LOCATION (constant, UNKNOWN_LOCATION);\n   jfunc->type = IPA_JF_CONST;\n   jfunc->value.constant = constant;\n }\n@@ -3150,6 +3153,8 @@ ipa_write_jump_function (struct output_block *ob,\n       stream_write_tree (ob, jump_func->value.known_type.component_type, true);\n       break;\n     case IPA_JF_CONST:\n+      gcc_assert (\n+\t  IS_UNKNOWN_LOCATION (EXPR_LOCATION (jump_func->value.constant)));\n       stream_write_tree (ob, jump_func->value.constant, true);\n       break;\n     case IPA_JF_PASS_THROUGH:"}, {"sha": "735824357493fedb785dc79ae9ddb81671022ab4", "filename": "gcc/jump.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -1815,8 +1815,7 @@ rtx_renumbered_equal_p (const_rtx x, const_rtx y)\n \t  if (XINT (x, i) != XINT (y, i))\n \t    {\n \t      if (((code == ASM_OPERANDS && i == 6)\n-\t\t   || (code == ASM_INPUT && i == 1))\n-\t\t  && locator_eq (XINT (x, i), XINT (y, i)))\n+\t\t   || (code == ASM_INPUT && i == 1)))\n \t\tbreak;\n \t      return 0;\n \t    }"}, {"sha": "a6ef6fc69df546ac5a300d11bb32d5a2d5f8c5be", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -1412,6 +1412,7 @@ output_node_opt_summary (struct output_block *ob,\n          mechanism to store function local declarations into summaries.  */\n       gcc_assert (parm);\n       streamer_write_uhwi (ob, parm_num);\n+      gcc_assert (IS_UNKNOWN_LOCATION (EXPR_LOCATION (map->new_tree)));\n       stream_write_tree (ob, map->new_tree, true);\n       bp = bitpack_create (ob->main_stream);\n       bp_pack_value (&bp, map->replace_p, 1);"}, {"sha": "e7e2d4ad9f6813ec127d326803c5bea18d0b9058", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -155,6 +155,7 @@ lto_output_location_bitpack (struct bitpack_d *bp,\n {\n   expanded_location xloc;\n \n+  loc = LOCATION_LOCUS (loc);\n   bp_pack_value (bp, loc == UNKNOWN_LOCATION, 1);\n   if (loc == UNKNOWN_LOCATION)\n     return;"}, {"sha": "4f3dd73fa350a6f64dcbf8d885fc6d4ab19e5c6d", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -1,3 +1,7 @@\n+2012-09-19  Dehao Chen  <dehao@google.com>\n+\n+\t* lto/lto.c (lto_fixup_prevailing_decls): Remove tree.exp.block field.\n+\n 2012-09-19  Jan Hubicka  <jh@suse.cz>\n \n \t* lto.c (lto_materialize_function): Update confused comment."}, {"sha": "689322673617f7459bfd99c3b202ebb065a2c96d", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -2734,7 +2734,6 @@ lto_fixup_prevailing_decls (tree t)\n   else if (EXPR_P (t))\n     {\n       int i;\n-      LTO_NO_PREVAIL (t->exp.block);\n       for (i = TREE_OPERAND_LENGTH (t) - 1; i >= 0; --i)\n \tLTO_SET_PREVAIL (TREE_OPERAND (t, i));\n     }"}, {"sha": "34d2e8302257cbf635129b2f6c73b75f6f4919d4", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -1246,9 +1246,9 @@ loop_single_full_bb_p (struct loop *loop)\n /* Dump file:line from INSN's location info to dump_file.  */\n \n static void\n-dump_insn_locator (rtx insn)\n+dump_insn_location (rtx insn)\n {\n-  if (dump_file && INSN_LOCATOR (insn))\n+  if (dump_file && INSN_LOCATION (insn))\n     {\n       const char *file = insn_file (insn);\n       if (file)\n@@ -1282,7 +1282,7 @@ loop_canon_p (struct loop *loop)\n \t  rtx insn = BB_END (loop->header);\n \n \t  fprintf (dump_file, \"SMS loop many exits\");\n-\t  dump_insn_locator (insn);\n+\t  dump_insn_location (insn);\n \t  fprintf (dump_file, \"\\n\");\n \t}\n       return false;\n@@ -1295,7 +1295,7 @@ loop_canon_p (struct loop *loop)\n \t  rtx insn = BB_END (loop->header);\n \n \t  fprintf (dump_file, \"SMS loop many BBs.\");\n-\t  dump_insn_locator (insn);\n+\t  dump_insn_location (insn);\n \t  fprintf (dump_file, \"\\n\");\n \t}\n       return false;\n@@ -1421,7 +1421,7 @@ sms_schedule (void)\n \t  rtx insn = BB_END (loop->header);\n \n \t  fprintf (dump_file, \"SMS loop num: %d\", loop->num);\n-\t  dump_insn_locator (insn);\n+\t  dump_insn_location (insn);\n \t  fprintf (dump_file, \"\\n\");\n \t}\n \n@@ -1450,7 +1450,7 @@ sms_schedule (void)\n \t{\n \t  if (dump_file)\n \t    {\n-\t      dump_insn_locator (tail);\n+\t      dump_insn_location (tail);\n \t      fprintf (dump_file, \"\\nSMS single-bb-loop\\n\");\n \t      if (profile_info && flag_branch_probabilities)\n \t    \t{\n@@ -1556,7 +1556,7 @@ sms_schedule (void)\n \t  rtx insn = BB_END (loop->header);\n \n \t  fprintf (dump_file, \"SMS loop num: %d\", loop->num);\n-\t  dump_insn_locator (insn);\n+\t  dump_insn_location (insn);\n \t  fprintf (dump_file, \"\\n\");\n \n \t  print_ddg (dump_file, g);\n@@ -1571,7 +1571,7 @@ sms_schedule (void)\n \n       if (dump_file)\n \t{\n-\t  dump_insn_locator (tail);\n+\t  dump_insn_location (tail);\n \t  fprintf (dump_file, \"\\nSMS single-bb-loop\\n\");\n \t  if (profile_info && flag_branch_probabilities)\n \t    {\n@@ -1714,7 +1714,7 @@ sms_schedule (void)\n \n           if (dump_file)\n             {\n-\t      dump_insn_locator (tail);\n+\t      dump_insn_location (tail);\n \t      fprintf (dump_file, \" SMS succeeded %d %d (with ii, sc)\\n\",\n \t\t       ps->ii, stage_count);\n \t      print_partial_schedule (ps, dump_file);"}, {"sha": "c2a04a8bef5acb5d42102ed14e14f1825edec5d6", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -416,27 +416,27 @@ print_rtx (const_rtx in_rtx)\n \tif (i == 5 && INSN_P (in_rtx))\n \t  {\n #ifndef GENERATOR_FILE\n-\t    /*  Pretty-print insn locators.  Ignore scoping as it is mostly\n+\t    /*  Pretty-print insn locations.  Ignore scoping as it is mostly\n \t\tredundant with line number information and do not print anything\n \t\twhen there is no location information available.  */\n-\t    if (INSN_LOCATOR (in_rtx) && insn_file (in_rtx))\n+\t    if (INSN_LOCATION (in_rtx) && insn_file (in_rtx))\n \t      fprintf(outfile, \" %s:%i\", insn_file (in_rtx), insn_line (in_rtx));\n #endif\n \t  }\n \telse if (i == 6 && GET_CODE (in_rtx) == ASM_OPERANDS)\n \t  {\n #ifndef GENERATOR_FILE\n \t    fprintf (outfile, \" %s:%i\",\n-\t\t     locator_file (ASM_OPERANDS_SOURCE_LOCATION (in_rtx)),\n-\t\t     locator_line (ASM_OPERANDS_SOURCE_LOCATION (in_rtx)));\n+\t\t     LOCATION_FILE (ASM_OPERANDS_SOURCE_LOCATION (in_rtx)),\n+\t\t     LOCATION_LINE (ASM_OPERANDS_SOURCE_LOCATION (in_rtx)));\n #endif\n \t  }\n \telse if (i == 1 && GET_CODE (in_rtx) == ASM_INPUT)\n \t  {\n #ifndef GENERATOR_FILE\n \t    fprintf (outfile, \" %s:%i\",\n-\t\t     locator_file (ASM_INPUT_SOURCE_LOCATION (in_rtx)),\n-\t\t     locator_line (ASM_INPUT_SOURCE_LOCATION (in_rtx)));\n+\t\t     LOCATION_FILE (ASM_INPUT_SOURCE_LOCATION (in_rtx)),\n+\t\t     LOCATION_LINE (ASM_INPUT_SOURCE_LOCATION (in_rtx)));\n #endif\n \t  }\n \telse if (i == 6 && NOTE_P (in_rtx))"}, {"sha": "dd9c389fa1e4109c60d5475e77fe231f75c221d0", "filename": "gcc/profile.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -1123,7 +1123,7 @@ branch_prob (void)\n \t     is not computed twice.  */\n \t  if (last\n \t      && gimple_has_location (last)\n-\t      && e->goto_locus != UNKNOWN_LOCATION\n+\t      && !IS_UNKNOWN_LOCATION (e->goto_locus)\n \t      && !single_succ_p (bb)\n \t      && (LOCATION_FILE (e->goto_locus)\n \t          != LOCATION_FILE (gimple_location (last))\n@@ -1133,7 +1133,6 @@ branch_prob (void)\n \t      basic_block new_bb = split_edge (e);\n \t      edge ne = single_succ_edge (new_bb);\n \t      ne->goto_locus = e->goto_locus;\n-\t      ne->goto_block = e->goto_block;\n \t    }\n \t  if ((e->flags & (EDGE_ABNORMAL | EDGE_ABNORMAL_CALL))\n \t       && e->dest != EXIT_BLOCK_PTR)\n@@ -1345,7 +1344,7 @@ branch_prob (void)\n \n \t  /* Notice GOTO expressions eliminated while constructing the CFG.  */\n \t  if (single_succ_p (bb)\n-\t      && single_succ_edge (bb)->goto_locus != UNKNOWN_LOCATION)\n+\t      && !IS_UNKNOWN_LOCATION (single_succ_edge (bb)->goto_locus))\n \t    {\n \t      expanded_location curr_location\n \t\t= expand_location (single_succ_edge (bb)->goto_locus);"}, {"sha": "5058da2e11e89555849b7065b22ffc7943b8071f", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -3326,7 +3326,7 @@ peep2_attempt (basic_block bb, rtx insn, int match_len, rtx attempt)\n   /* Replace the old sequence with the new.  */\n   last = emit_insn_after_setloc (attempt,\n \t\t\t\t peep2_insn_data[i].insn,\n-\t\t\t\t INSN_LOCATOR (peep2_insn_data[i].insn));\n+\t\t\t\t INSN_LOCATION (peep2_insn_data[i].insn));\n   before_try = PREV_INSN (insn);\n   delete_insn_chain (insn, peep2_insn_data[i].insn, false);\n "}, {"sha": "f3bf15a4dd0ddfdb06641049649f8084d6d7874b", "filename": "gcc/reorg.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -545,7 +545,7 @@ emit_delay_sequence (rtx insn, rtx list, int length)\n   INSN_DELETED_P (delay_insn) = 0;\n   PREV_INSN (delay_insn) = PREV_INSN (seq_insn);\n \n-  INSN_LOCATOR (seq_insn) = INSN_LOCATOR (delay_insn);\n+  INSN_LOCATION (seq_insn) = INSN_LOCATION (delay_insn);\n \n   for (li = list; li; li = XEXP (li, 1), i++)\n     {\n@@ -561,9 +561,9 @@ emit_delay_sequence (rtx insn, rtx list, int length)\n \n       /* SPARC assembler, for instance, emit warning when debug info is output\n          into the delay slot.  */\n-      if (INSN_LOCATOR (tem) && !INSN_LOCATOR (seq_insn))\n-\tINSN_LOCATOR (seq_insn) = INSN_LOCATOR (tem);\n-      INSN_LOCATOR (tem) = 0;\n+      if (INSN_LOCATION (tem) && !INSN_LOCATION (seq_insn))\n+\tINSN_LOCATION (seq_insn) = INSN_LOCATION (tem);\n+      INSN_LOCATION (tem) = 0;\n \n       for (note = REG_NOTES (tem); note; note = next)\n \t{\n@@ -4065,7 +4065,7 @@ dbr_schedule (rtx first)\n     for (link = crtl->epilogue_delay_list;\n          link;\n          link = XEXP (link, 1))\n-      INSN_LOCATOR (XEXP (link, 0)) = 0;\n+      INSN_LOCATION (XEXP (link, 0)) = 0;\n   }\n \n #endif"}, {"sha": "c42abda1e0266dd0434875b00da48d67ceeaaf3a", "filename": "gcc/rtl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -435,7 +435,7 @@ rtx_equal_p_cb (const_rtx x, const_rtx y, rtx_equal_p_callback_function cb)\n #ifndef GENERATOR_FILE\n \t      if (((code == ASM_OPERANDS && i == 6)\n \t\t   || (code == ASM_INPUT && i == 1))\n-\t\t  && locator_eq (XINT (x, i), XINT (y, i)))\n+\t\t  && XINT (x, i) == XINT (y, i))\n \t\tbreak;\n #endif\n \t      return 0;\n@@ -572,7 +572,7 @@ rtx_equal_p (const_rtx x, const_rtx y)\n #ifndef GENERATOR_FILE\n \t      if (((code == ASM_OPERANDS && i == 6)\n \t\t   || (code == ASM_INPUT && i == 1))\n-\t\t  && locator_eq (XINT (x, i), XINT (y, i)))\n+\t\t  && XINT (x, i) == XINT (y, i))\n \t\tbreak;\n #endif\n \t      return 0;"}, {"sha": "f0daf44ab83f5d048fd3ddb816b6ccb3cc50ddcc", "filename": "gcc/rtl.h", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -763,6 +763,7 @@ extern void rtl_check_failed_flag (const char *, const_rtx, const char *,\n #endif\n \n #define XINT(RTX, N)\t(RTL_CHECK2 (RTX, N, 'i', 'n').rt_int)\n+#define XUINT(RTX, N)   (RTL_CHECK2 (RTX, N, 'i', 'n').rt_uint)\n #define XSTR(RTX, N)\t(RTL_CHECK2 (RTX, N, 's', 'S').rt_str)\n #define XEXP(RTX, N)\t(RTL_CHECK2 (RTX, N, 'e', 'u').rt_rtx)\n #define XVEC(RTX, N)\t(RTL_CHECK2 (RTX, N, 'E', 'V').rt_rtvec)\n@@ -826,13 +827,13 @@ extern void rtl_check_failed_flag (const char *, const_rtx, const char *,\n /* The body of an insn.  */\n #define PATTERN(INSN)\tXEXP (INSN, 4)\n \n-#define INSN_LOCATOR(INSN) XINT (INSN, 5)\n+#define INSN_LOCATION(INSN) XUINT (INSN, 5)\n+\n+#define INSN_HAS_LOCATION(INSN) (!IS_UNKNOWN_LOCATION (INSN_LOCATION (INSN)))\n+\n /* LOCATION of an RTX if relevant.  */\n #define RTL_LOCATION(X) (INSN_P (X) ? \\\n-\t\t\t locator_location (INSN_LOCATOR (X)) \\\n-\t\t\t : UNKNOWN_LOCATION)\n-/* LOCATION of current INSN.  */\n-#define CURR_INSN_LOCATION (locator_location (curr_insn_locator ()))\n+\t\t\t INSN_LOCATION (X) : UNKNOWN_LOCATION)\n \n /* Code number of instruction, from when it was recognized.\n    -1 means this instruction has not been recognized yet.  */\n@@ -1831,12 +1832,8 @@ extern rtx prev_cc0_setter (rtx);\n /* In emit-rtl.c  */\n extern int insn_line (const_rtx);\n extern const char * insn_file (const_rtx);\n-extern location_t locator_location (int);\n-extern int locator_line (int);\n-extern const char * locator_file (int);\n-extern bool locator_eq (int, int);\n-extern int prologue_locator, epilogue_locator;\n extern tree insn_scope (const_rtx);\n+extern location_t prologue_location, epilogue_location;\n \n /* In jump.c */\n extern enum rtx_code reverse_condition (enum rtx_code);\n@@ -2674,14 +2671,10 @@ extern const struct rtl_hooks general_rtl_hooks;\n /* Keep this for the nonce.  */\n #define gen_lowpart rtl_hooks.gen_lowpart\n \n-extern void insn_locators_alloc (void);\n-extern void insn_locators_free (void);\n-extern void insn_locators_finalize (void);\n-extern void set_curr_insn_source_location (location_t);\n-extern location_t get_curr_insn_source_location (void);\n-extern void set_curr_insn_block (tree);\n-extern tree get_curr_insn_block (void);\n-extern int curr_insn_locator (void);\n+extern void insn_locations_init (void);\n+extern void insn_locations_finalize (void);\n+extern void set_curr_insn_location (location_t);\n+extern location_t curr_insn_location (void);\n extern bool optimize_insn_for_size_p (void);\n extern bool optimize_insn_for_speed_p (void);\n "}, {"sha": "fb3323e1910ee6f2ffab4664e27f1a330dde4f96", "filename": "gcc/stmt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -2483,7 +2483,7 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \t\t then emit the code for one side at a time.  */\n \n \t      tree test_label\n-\t\t= build_decl (CURR_INSN_LOCATION,\n+\t\t= build_decl (curr_insn_location (),\n \t\t\t      LABEL_DECL, NULL_TREE, NULL_TREE);\n \n \t      /* See if the value is on the right.  */\n@@ -2607,7 +2607,7 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \t      /* Right hand node requires testing.\n \t\t Branch to a label where we will handle it later.  */\n \n-\t      test_label = build_decl (CURR_INSN_LOCATION,\n+\t      test_label = build_decl (curr_insn_location (),\n \t\t\t\t       LABEL_DECL, NULL_TREE, NULL_TREE);\n \t      emit_cmp_and_jump_insns (index,\n \t\t\t\t       convert_modes"}, {"sha": "2aa3e40004b9f7cc4ea362a80fe9f510e6958ba3", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -1946,6 +1946,7 @@ toplev_main (int argc, char **argv)\n   invoke_plugin_callbacks (PLUGIN_FINISH, NULL);\n \n   finalize_plugins ();\n+  location_adhoc_data_fini (line_table);\n   if (seen_error ())\n     return (FATAL_EXIT_CODE);\n "}, {"sha": "0b1c8a5f0e7530e29678c2e7cd12a933ffa2b422", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -3803,7 +3803,6 @@ ipa_tm_scan_irr_block (basic_block bb)\n \t    {\n \t      tree t = build1 (NOP_EXPR, void_type_node, size_zero_node);\n \t      SET_EXPR_LOCATION (t, gimple_location (stmt));\n-\t      TREE_BLOCK (t) = gimple_block (stmt);\n \t      error (\"%Kasm not allowed in %<transaction_safe%> function\", t);\n \t    }\n \t  return true;"}, {"sha": "eea9a5cf92fdc306f2252b47dd21d4df5189397a", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -809,15 +809,11 @@ make_cond_expr_edges (basic_block bb)\n   e = make_edge (bb, then_bb, EDGE_TRUE_VALUE);\n   assign_discriminator (entry_locus, then_bb);\n   e->goto_locus = gimple_location (then_stmt);\n-  if (e->goto_locus)\n-    e->goto_block = gimple_block (then_stmt);\n   e = make_edge (bb, else_bb, EDGE_FALSE_VALUE);\n   if (e)\n     {\n       assign_discriminator (entry_locus, else_bb);\n       e->goto_locus = gimple_location (else_stmt);\n-      if (e->goto_locus)\n-\te->goto_block = gimple_block (else_stmt);\n     }\n \n   /* We do not need the labels anymore.  */\n@@ -1027,8 +1023,6 @@ make_goto_expr_edges (basic_block bb)\n       edge e = make_edge (bb, label_bb, EDGE_FALLTHRU);\n       e->goto_locus = gimple_location (goto_t);\n       assign_discriminator (e->goto_locus, label_bb);\n-      if (e->goto_locus)\n-\te->goto_block = gimple_block (goto_t);\n       gsi_remove (&last, true);\n       return;\n     }\n@@ -6018,9 +6012,10 @@ move_stmt_op (tree *tp, int *walk_subtrees, void *data)\n   tree t = *tp;\n \n   if (EXPR_P (t))\n-    /* We should never have TREE_BLOCK set on non-statements.  */\n-    gcc_assert (!TREE_BLOCK (t));\n-\n+    {\n+      if (TREE_BLOCK (t))\n+\tTREE_SET_BLOCK (t, p->new_block);\n+    }\n   else if (DECL_P (t) || TREE_CODE (t) == SSA_NAME)\n     {\n       if (TREE_CODE (t) == SSA_NAME)\n@@ -6320,12 +6315,14 @@ move_block_to_fn (struct function *dest_cfun, basic_block bb,\n     }\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n-    if (e->goto_locus)\n+    if (!IS_UNKNOWN_LOCATION (e->goto_locus))\n       {\n-\ttree block = e->goto_block;\n+\ttree block = LOCATION_BLOCK (e->goto_locus);\n \tif (d->orig_block == NULL_TREE\n \t    || block == d->orig_block)\n-\t  e->goto_block = d->new_block;\n+\t  e->goto_locus = d->new_block ?\n+\t      COMBINE_LOCATION_DATA (line_table, e->goto_locus, d->new_block) :\n+\t      LOCATION_LOCUS (e->goto_locus);\n #ifdef ENABLE_CHECKING\n \telse if (block != d->new_block)\n \t  {\n@@ -7901,13 +7898,14 @@ extern void gt_ggc_mx (basic_block&);\n void\n gt_ggc_mx (edge_def *e)\n {\n+  tree block = LOCATION_BLOCK (e->goto_locus);\n   gt_ggc_mx (e->src);\n   gt_ggc_mx (e->dest);\n   if (current_ir_type () == IR_GIMPLE)\n     gt_ggc_mx (e->insns.g);\n   else\n     gt_ggc_mx (e->insns.r);\n-  gt_ggc_mx (e->goto_block);\n+  gt_ggc_mx (block);\n }\n \n /* PCH support for edge_def.  */\n@@ -7920,23 +7918,25 @@ extern void gt_pch_nx (basic_block&);\n void\n gt_pch_nx (edge_def *e)\n {\n+  tree block = LOCATION_BLOCK (e->goto_locus);\n   gt_pch_nx (e->src);\n   gt_pch_nx (e->dest);\n   if (current_ir_type () == IR_GIMPLE)\n     gt_pch_nx (e->insns.g);\n   else\n     gt_pch_nx (e->insns.r);\n-  gt_pch_nx (e->goto_block);\n+  gt_pch_nx (block);\n }\n \n void\n gt_pch_nx (edge_def *e, gt_pointer_operator op, void *cookie)\n {\n+  tree block = LOCATION_BLOCK (e->goto_locus);\n   op (&(e->src), cookie);\n   op (&(e->dest), cookie);\n   if (current_ir_type () == IR_GIMPLE)\n     op (&(e->insns.g), cookie);\n   else\n     op (&(e->insns.r), cookie);\n-  op (&(e->goto_block), cookie);\n+  op (&(block), cookie);\n }"}, {"sha": "cd48f64582f05da5b9bd61f0f2543ccbd8eb3105", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -883,7 +883,7 @@ lower_try_finally_dup_block (gimple_seq seq, struct leh_state *outer_state,\n   new_seq = copy_gimple_seq_and_replace_locals (seq);\n \n   for (gsi = gsi_start (new_seq); !gsi_end_p (gsi); gsi_next (&gsi))\n-    if (gimple_location (gsi_stmt (gsi)) == UNKNOWN_LOCATION)\n+    if (IS_UNKNOWN_LOCATION (gimple_location (gsi_stmt (gsi))))\n       gimple_set_location (gsi_stmt (gsi), loc);\n \n   if (outer_state->tf)\n@@ -981,7 +981,7 @@ honor_protect_cleanup_actions (struct leh_state *outer_state,\n     }\n   else if (this_state)\n     finally = lower_try_finally_dup_block (finally, outer_state,\n-\t\t\t\t\t   UNKNOWN_LOCATION);\n+\tgimple_location (tf->try_finally_expr));\n   finally_may_fallthru = gimple_seq_may_fallthru (finally);\n \n   /* If this cleanup consists of a TRY_CATCH_EXPR with TRY_CATCH_IS_CLEANUP"}, {"sha": "ad62caef6389bb3d35a479bd97f0643edf2521c5", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 35, "deletions": 16, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -830,10 +830,6 @@ remap_gimple_op_r (tree *tp, int *walk_subtrees, void *data)\n       /* Otherwise, just copy the node.  Note that copy_tree_r already\n \t knows not to copy VAR_DECLs, etc., so this is safe.  */\n \n-      /* We should never have TREE_BLOCK set on non-statements.  */\n-      if (EXPR_P (*tp))\n-\tgcc_assert (!TREE_BLOCK (*tp));\n-\n       if (TREE_CODE (*tp) == MEM_REF)\n \t{\n \t  tree ptr = TREE_OPERAND (*tp, 0);\n@@ -872,13 +868,9 @@ remap_gimple_op_r (tree *tp, int *walk_subtrees, void *data)\n \t{\n \t  /* Variable substitution need not be simple.  In particular,\n \t     the MEM_REF substitution above.  Make sure that\n-\t     TREE_CONSTANT and friends are up-to-date.  But make sure\n-\t     to not improperly set TREE_BLOCK on some sub-expressions.  */\n+\t     TREE_CONSTANT and friends are up-to-date.  */\n \t  int invariant = is_gimple_min_invariant (*tp);\n-\t  tree block = id->block;\n-\t  id->block = NULL_TREE;\n \t  walk_tree (&TREE_OPERAND (*tp, 0), remap_gimple_op_r, data, NULL);\n-\t  id->block = block;\n \t  recompute_tree_invariant_for_addr_expr (*tp);\n \n \t  /* If this used to be invariant, but is not any longer,\n@@ -890,6 +882,22 @@ remap_gimple_op_r (tree *tp, int *walk_subtrees, void *data)\n \t}\n     }\n \n+  /* Update the TREE_BLOCK for the cloned expr.  */\n+  if (EXPR_P (*tp))\n+    {\n+      tree new_block = id->remapping_type_depth == 0 ? id->block : NULL;\n+      tree old_block = TREE_BLOCK (*tp);\n+      if (old_block)\n+\t{\n+\t  tree *n;\n+\t  n = (tree *) pointer_map_contains (id->decl_map,\n+\t\t\t\t\t     TREE_BLOCK (*tp));\n+\t  if (n)\n+\t    new_block = *n;\n+\t}\n+      TREE_SET_BLOCK (*tp, new_block);\n+    }\n+\n   /* Keep iterating.  */\n   return NULL_TREE;\n }\n@@ -1107,11 +1115,10 @@ copy_tree_body_r (tree *tp, int *walk_subtrees, void *data)\n \t      tree *n;\n \t      n = (tree *) pointer_map_contains (id->decl_map,\n \t\t\t\t\t\t TREE_BLOCK (*tp));\n-\t      gcc_assert (n || id->remapping_type_depth != 0);\n \t      if (n)\n \t\tnew_block = *n;\n \t    }\n-\t  TREE_BLOCK (*tp) = new_block;\n+\t  TREE_SET_BLOCK (*tp, new_block);\n \t}\n \n       if (TREE_CODE (*tp) != OMP_CLAUSE)\n@@ -1982,6 +1989,7 @@ copy_phis_for_bb (basic_block bb, copy_body_data *id)\n \t      tree new_arg;\n \t      tree block = id->block;\n \t      edge_iterator ei2;\n+\t      location_t locus;\n \n \t      /* When doing partial cloning, we allow PHIs on the entry block\n \t\t as long as all the arguments are the same.  Find any input\n@@ -1993,9 +2001,7 @@ copy_phis_for_bb (basic_block bb, copy_body_data *id)\n \n \t      arg = PHI_ARG_DEF_FROM_EDGE (phi, old_edge);\n \t      new_arg = arg;\n-\t      id->block = NULL_TREE;\n \t      walk_tree (&new_arg, copy_tree_body_r, id, NULL);\n-\t      id->block = block;\n \t      gcc_assert (new_arg);\n \t      /* With return slot optimization we can end up with\n \t         non-gimple (foo *)&this->m, fix that here.  */\n@@ -2008,8 +2014,20 @@ copy_phis_for_bb (basic_block bb, copy_body_data *id)\n \t\t  gsi_insert_seq_on_edge (new_edge, stmts);\n \t\t  inserted = true;\n \t\t}\n-\t      add_phi_arg (new_phi, new_arg, new_edge,\n-\t\t\t   gimple_phi_arg_location_from_edge (phi, old_edge));\n+\t      locus = gimple_phi_arg_location_from_edge (phi, old_edge);\n+\t      block = id->block;\n+\t      if (LOCATION_BLOCK (locus))\n+\t\t{\n+\t\t  tree *n;\n+\t\t  n = (tree *) pointer_map_contains (id->decl_map,\n+\t\t\tLOCATION_BLOCK (locus));\n+\t\t  gcc_assert (n);\n+\t\t  block = *n;\n+\t\t}\n+\n+\t      add_phi_arg (new_phi, new_arg, new_edge, block ?\n+\t\t  COMBINE_LOCATION_DATA (line_table, locus, block) :\n+\t\t  LOCATION_LOCUS (locus));\n \t    }\n \t}\n     }\n@@ -3874,7 +3892,8 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n   id->block = make_node (BLOCK);\n   BLOCK_ABSTRACT_ORIGIN (id->block) = fn;\n   BLOCK_SOURCE_LOCATION (id->block) = input_location;\n-  prepend_lexical_block (gimple_block (stmt), id->block);\n+  if (gimple_block (stmt))\n+    prepend_lexical_block (gimple_block (stmt), id->block);\n \n   /* Local declarations will be replaced by their equivalents in this\n      map.  */"}, {"sha": "4d0f32083203090143de34dfa714bb80f4183b28", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -108,8 +108,7 @@ set_location_for_edge (edge e)\n {\n   if (e->goto_locus)\n     {\n-      set_curr_insn_source_location (e->goto_locus);\n-      set_curr_insn_block (e->goto_block);\n+      set_curr_insn_location (e->goto_locus);\n     }\n   else\n     {\n@@ -125,8 +124,7 @@ set_location_for_edge (edge e)\n \t\tcontinue;\n \t      if (gimple_has_location (stmt) || gimple_block (stmt))\n \t\t{\n-\t\t  set_curr_insn_source_location (gimple_location (stmt));\n-\t\t  set_curr_insn_block (gimple_block (stmt));\n+\t\t  set_curr_insn_location (gimple_location (stmt));\n \t\t  return;\n \t\t}\n \t    }\n@@ -191,7 +189,7 @@ insert_partition_copy_on_edge (edge e, int dest, int src, source_location locus)\n   set_location_for_edge (e);\n   /* If a locus is provided, override the default.  */\n   if (locus)\n-    set_curr_insn_source_location (locus);\n+    set_curr_insn_location (locus);\n \n   var = partition_to_var (SA.map, src);\n   seq = emit_partition_copy (SA.partition_to_pseudo[dest],\n@@ -228,7 +226,7 @@ insert_value_copy_on_edge (edge e, int dest, tree src, source_location locus)\n   set_location_for_edge (e);\n   /* If a locus is provided, override the default.  */\n   if (locus)\n-    set_curr_insn_source_location (locus);\n+    set_curr_insn_location (locus);\n \n   start_sequence ();\n \n@@ -284,7 +282,7 @@ insert_rtx_to_part_on_edge (edge e, int dest, rtx src, int unsignedsrcp,\n   set_location_for_edge (e);\n   /* If a locus is provided, override the default.  */\n   if (locus)\n-    set_curr_insn_source_location (locus);\n+    set_curr_insn_location (locus);\n \n   /* We give the destination as sizeexp in case src/dest are BLKmode\n      mems.  Usually we give the source.  As we result from SSA names\n@@ -320,7 +318,7 @@ insert_part_to_rtx_on_edge (edge e, rtx dest, int src, source_location locus)\n   set_location_for_edge (e);\n   /* If a locus is provided, override the default.  */\n   if (locus)\n-    set_curr_insn_source_location (locus);\n+    set_curr_insn_location (locus);\n \n   var = partition_to_var (SA.map, src);\n   seq = emit_partition_copy (dest,"}, {"sha": "41ddf57d608d33357e4acc48a472e6d9dde14663", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -1403,6 +1403,7 @@ create_loop_fn (location_t loc)\n   struct function *act_cfun = cfun;\n   static unsigned loopfn_num;\n \n+  loc = LOCATION_LOCUS (loc);\n   snprintf (buf, 100, \"%s.$loopfn\", current_function_name ());\n   ASM_FORMAT_PRIVATE_NAME (tname, buf, loopfn_num++);\n   clean_symbol_name (tname);"}, {"sha": "af09806a2cf75e96c3e3c881bbbf0ccf1935ae3e", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 50, "deletions": 3, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -597,7 +597,7 @@ remove_unused_scope_block_p (tree scope)\n    else\n    /* Verfify that only blocks with source location set\n       are entry points to the inlined functions.  */\n-     gcc_assert (BLOCK_SOURCE_LOCATION (scope) == UNKNOWN_LOCATION);\n+     gcc_assert (IS_UNKNOWN_LOCATION (BLOCK_SOURCE_LOCATION (scope)));\n \n    TREE_USED (scope) = !unused;\n    return unused;\n@@ -612,6 +612,47 @@ mark_all_vars_used (tree *expr_p)\n   walk_tree (expr_p, mark_all_vars_used_1, NULL, NULL);\n }\n \n+/* Helper function for clear_unused_block_pointer, called via walk_tree.  */\n+\n+static tree\n+clear_unused_block_pointer_1 (tree *tp, int *, void *)\n+{\n+  if (EXPR_P (*tp) && TREE_BLOCK (*tp)\n+      && !TREE_USED (TREE_BLOCK (*tp)))\n+    TREE_SET_BLOCK (*tp, NULL);\n+  if (TREE_CODE (*tp) == VAR_DECL && DECL_DEBUG_EXPR_IS_FROM (*tp))\n+    {\n+      tree debug_expr = DECL_DEBUG_EXPR (*tp);\n+      walk_tree (&debug_expr, clear_unused_block_pointer_1, NULL, NULL);\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Set all block pointer in debug stmt to NULL if the block is unused,\n+   so that they will not be streamed out.  */\n+\n+static void\n+clear_unused_block_pointer ()\n+{\n+  basic_block bb;\n+  gimple_stmt_iterator gsi;\n+  FOR_EACH_BB (bb)\n+    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      {\n+\tunsigned i;\n+\ttree b;\n+\tgimple stmt = gsi_stmt (gsi);\n+\n+\tif (!is_gimple_debug (stmt))\n+\t  continue;\n+\tb = gimple_block (stmt);\n+\tif (b && !TREE_USED (b))\n+\t  gimple_set_block (stmt, NULL);\n+\tfor (i = 0; i < gimple_num_ops (stmt); i++)\n+\t  walk_tree (gimple_op_ptr (stmt, i), clear_unused_block_pointer_1,\n+\t\t     NULL, NULL);\n+      }\n+}\n \n /* Dump scope blocks starting at SCOPE to FILE.  INDENT is the\n    indentation level and FLAGS is as in print_generic_expr.  */\n@@ -625,7 +666,7 @@ dump_scope_block (FILE *file, int indent, tree scope, int flags)\n   fprintf (file, \"\\n%*s{ Scope block #%i%s%s\",indent, \"\" , BLOCK_NUMBER (scope),\n   \t   TREE_USED (scope) ? \"\" : \" (unused)\",\n \t   BLOCK_ABSTRACT (scope) ? \" (abstract)\": \"\");\n-  if (BLOCK_SOURCE_LOCATION (scope) != UNKNOWN_LOCATION)\n+  if (!IS_UNKNOWN_LOCATION (BLOCK_SOURCE_LOCATION (scope)))\n     {\n       expanded_location s = expand_location (BLOCK_SOURCE_LOCATION (scope));\n       fprintf (file, \" %s:%i\", s.file, s.line);\n@@ -758,13 +799,18 @@ remove_unused_locals (void)\n           FOR_EACH_PHI_ARG (arg_p, phi, i, SSA_OP_ALL_USES)\n             {\n \t      tree arg = USE_FROM_PTR (arg_p);\n+\t      int index = PHI_ARG_INDEX_FROM_USE (arg_p);\n+\t      tree block =\n+\t\tLOCATION_BLOCK (gimple_phi_arg_location (phi, index));\n+\t      if (block != NULL)\n+\t\tTREE_USED (block) = true;\n \t      mark_all_vars_used (&arg);\n             }\n         }\n \n       FOR_EACH_EDGE (e, ei, bb->succs)\n \tif (e->goto_locus)\n-\t  TREE_USED (e->goto_block) = true;\n+\t  TREE_USED (LOCATION_BLOCK (e->goto_locus)) = true;\n     }\n \n   /* We do a two-pass approach about the out-of-scope clobbers.  We want\n@@ -836,6 +882,7 @@ remove_unused_locals (void)\n     VEC_truncate (tree, cfun->local_decls, dstidx);\n \n   remove_unused_scope_block_p (DECL_INITIAL (current_function_decl));\n+  clear_unused_block_pointer ();\n \n   BITMAP_FREE (usedvars);\n "}, {"sha": "4e3cdc731560329a40f77f35ee23e9e59515f698", "filename": "gcc/tree-streamer-in.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Ftree-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Ftree-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -775,7 +775,7 @@ lto_input_ts_exp_tree_pointers (struct lto_input_block *ib,\n \n   loc = lto_input_location (ib, data_in);\n   SET_EXPR_LOCATION (expr, loc);\n-  TREE_BLOCK (expr) = stream_read_tree (ib, data_in);\n+  TREE_SET_BLOCK (expr, stream_read_tree (ib, data_in));\n }\n \n "}, {"sha": "ab86b1e2180f743945af878daa49406edcfa879d", "filename": "gcc/tree-streamer-out.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Ftree-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Ftree-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-out.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -471,7 +471,7 @@ write_ts_decl_minimal_tree_pointers (struct output_block *ob, tree expr,\n {\n   stream_write_tree (ob, DECL_NAME (expr), ref_p);\n   stream_write_tree (ob, DECL_CONTEXT (expr), ref_p);\n-  lto_output_location (ob, DECL_SOURCE_LOCATION (expr));\n+  lto_output_location (ob, LOCATION_LOCUS (DECL_SOURCE_LOCATION (expr)));\n }\n \n \n@@ -668,7 +668,7 @@ write_ts_exp_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n   streamer_write_hwi (ob, TREE_OPERAND_LENGTH (expr));\n   for (i = 0; i < TREE_OPERAND_LENGTH (expr); i++)\n     stream_write_tree (ob, TREE_OPERAND (expr, i), ref_p);\n-  lto_output_location (ob, EXPR_LOCATION (expr));\n+  lto_output_location (ob, LOCATION_LOCUS (EXPR_LOCATION (expr)));\n   stream_write_tree (ob, TREE_BLOCK (expr), ref_p);\n }\n "}, {"sha": "9169424a01b14b90088e491d69e831d130f1f9e3", "filename": "gcc/tree.c", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -3760,7 +3760,6 @@ build1_stat (enum tree_code code, tree type, tree node MEM_STAT_DECL)\n   TREE_TYPE (t) = type;\n   SET_EXPR_LOCATION (t, UNKNOWN_LOCATION);\n   TREE_OPERAND (t, 0) = node;\n-  TREE_BLOCK (t) = NULL_TREE;\n   if (node && !TYPE_P (node))\n     {\n       TREE_SIDE_EFFECTS (t) = TREE_SIDE_EFFECTS (node);\n@@ -10826,17 +10825,33 @@ walk_tree_without_duplicates_1 (tree *tp, walk_tree_fn func, void *data,\n }\n \n \n-tree *\n+tree\n tree_block (tree t)\n {\n   char const c = TREE_CODE_CLASS (TREE_CODE (t));\n \n   if (IS_EXPR_CODE_CLASS (c))\n-    return &t->exp.block;\n+    return LOCATION_BLOCK (t->exp.locus);\n   gcc_unreachable ();\n   return NULL;\n }\n \n+void\n+tree_set_block (tree t, tree b)\n+{\n+  char const c = TREE_CODE_CLASS (TREE_CODE (t));\n+\n+  if (IS_EXPR_CODE_CLASS (c))\n+    {\n+      if (b)\n+\tt->exp.locus = COMBINE_LOCATION_DATA (line_table, t->exp.locus, b);\n+      else\n+\tt->exp.locus = LOCATION_LOCUS (t->exp.locus);\n+    }\n+  else\n+    gcc_unreachable ();\n+}\n+\n /* Create a nameless artificial label and put it in the current\n    function context.  The label has a location of LOC.  Returns the\n    newly created label.  */"}, {"sha": "edc47eec432479e918a6044a8ce8bccf8675fe11", "filename": "gcc/tree.h", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -907,7 +907,8 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n \n #endif\n \n-#define TREE_BLOCK(NODE)\t\t*(tree_block (NODE))\n+#define TREE_BLOCK(NODE)\t\t(tree_block (NODE))\n+#define TREE_SET_BLOCK(T, B)\t\t(tree_set_block ((T), (B)))\n \n #include \"tree-check.h\"\n \n@@ -1611,7 +1612,7 @@ struct GTY(()) tree_constructor {\n #define EXPR_LOCATION(NODE) \\\n   (CAN_HAVE_LOCATION_P ((NODE)) ? (NODE)->exp.locus : UNKNOWN_LOCATION)\n #define SET_EXPR_LOCATION(NODE, LOCUS) EXPR_CHECK ((NODE))->exp.locus = (LOCUS)\n-#define EXPR_HAS_LOCATION(NODE) (EXPR_LOCATION (NODE) != UNKNOWN_LOCATION)\n+#define EXPR_HAS_LOCATION(NODE) (!IS_UNKNOWN_LOCATION (EXPR_LOCATION (NODE)))\n /* The location to be used in a diagnostic about this expression.  Do not\n    use this macro if the location will be assigned to other expressions.  */\n #define EXPR_LOC_OR_HERE(NODE) (EXPR_HAS_LOCATION (NODE) ? (NODE)->exp.locus : input_location)\n@@ -1790,7 +1791,7 @@ extern void protected_set_expr_location (tree, location_t);\n \t\t\t\t\t      OMP_CLAUSE_PRIVATE,\t\\\n \t                                      OMP_CLAUSE_COPYPRIVATE), 0)\n #define OMP_CLAUSE_HAS_LOCATION(NODE) \\\n-  ((OMP_CLAUSE_CHECK (NODE))->omp_clause.locus != UNKNOWN_LOCATION)\n+  (!IS_UNKNOWN_LOCATION ((OMP_CLAUSE_CHECK (NODE))->omp_clause.locus))\n #define OMP_CLAUSE_LOCATION(NODE)  (OMP_CLAUSE_CHECK (NODE))->omp_clause.locus\n \n /* True on an OMP_SECTION statement that was the last lexical member.\n@@ -1881,7 +1882,6 @@ enum omp_clause_default_kind\n struct GTY(()) tree_exp {\n   struct tree_typed typed;\n   location_t locus;\n-  tree block;\n   tree GTY ((special (\"tree_exp\"),\n \t     desc (\"TREE_CODE ((tree) &%0)\")))\n     operands[1];\n@@ -5535,7 +5535,7 @@ function_args_iter_next (function_args_iterator *i)\n static inline bool\n inlined_function_outer_scope_p (const_tree block)\n {\n- return BLOCK_SOURCE_LOCATION (block) != UNKNOWN_LOCATION;\n+ return !IS_UNKNOWN_LOCATION (BLOCK_SOURCE_LOCATION (block));\n }\n \n /* Loop over all function arguments of FNTYPE.  In each iteration, PTR is set\n@@ -5910,7 +5910,8 @@ extern bool subrange_type_for_debug_p (const_tree, tree *, tree *);\n extern HOST_WIDE_INT int_cst_value (const_tree);\n extern HOST_WIDEST_INT widest_int_cst_value (const_tree);\n \n-extern tree *tree_block (tree);\n+extern tree tree_block (tree);\n+extern void tree_set_block (tree, tree);\n extern location_t *block_nonartificial_location (tree);\n extern location_t tree_nonartificial_location (tree);\n "}, {"sha": "ab0e2ec3c4310d50feb0fe33befd019e0d559842", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -1,3 +1,44 @@\n+2012-09-19  Dehao Chen  <dehao@google.com>\n+\n+\t* include/line-map.h (MAX_SOURCE_LOCATION): New value.\n+\t(location_adhoc_data_fini): New.\n+\t(get_combined_adhoc_loc): New.\n+\t(get_data_from_adhoc_loc): New.\n+\t(get_location_from_adhoc_loc): New.\n+\t(location_adhoc_data_map): New.\n+\t(COMBINE_LOCATION_DATA): New.\n+\t(IS_ADHOC_LOC): New.\n+\t(expanded_location): New field.\n+\t(line_maps): New field.\n+\t* line-map.c (location_adhoc_data): New.\n+\t(location_adhoc_data_hash): New.\n+\t(location_adhoc_data_eq): New.\n+\t(location_adhoc_data_update): New.\n+\t(get_combined_adhoc_loc): New.\n+\t(get_data_from_adhoc_loc): New.\n+\t(get_location_from_adhoc_loc): New.\n+\t(location_adhoc_data_init): New.\n+\t(location_adhoc_data_fini): New.\n+\t(linemap_init): Initialize location_adhoc_data.\n+\t(linemap_lookup): Change to use new location.\n+\t(linemap_ordinary_map_lookup): Likewise.\n+\t(linemap_macro_map_lookup): Likewise.\n+\t(linemap_macro_map_loc_to_def_point): Likewise.\n+\t(linemap_macro_map_loc_unwind_toward_spel): Likewise.\n+\t(linemap_get_expansion_line): Likewise.\n+\t(linemap_get_expansion_filename): Likewise.\n+\t(linemap_location_in_system_header_p): Likewise.\n+\t(linemap_location_from_macro_expansion_p): Likewise.\n+\t(linemap_macro_loc_to_spelling_point): Likewise.\n+\t(linemap_macro_loc_to_def_point): Likewise.\n+\t(linemap_macro_loc_to_exp_point): Likewise.\n+\t(linemap_resolve_location): Likewise.\n+\t(linemap_unwind_toward_expansion): Likewise.\n+\t(linemap_unwind_to_first_non_reserved_loc): Likewise.\n+\t(linemap_expand_location): Likewise.\n+\t(linemap_dump_location): Likewise.\n+\t(linemap_line_start): Likewise.\n+\n 2012-05-25  Dodji Seketeli  <dodji@redhat.com>\n \n \tPR preprocessor/53469"}, {"sha": "86f8383dcd8d74bd0ce3f76883726e5ad2929879", "filename": "libcpp/include/line-map.h", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/libcpp%2Finclude%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/libcpp%2Finclude%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fline-map.h?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -89,7 +89,7 @@ struct GTY(()) line_map_ordinary {\n \n /* This is the highest possible source location encoded within an\n    ordinary or macro map.  */\n-#define MAX_SOURCE_LOCATION 0xFFFFFFFF\n+#define MAX_SOURCE_LOCATION 0x7FFFFFFF\n \n struct cpp_hashnode;\n \n@@ -259,6 +259,31 @@ struct GTY(()) maps_info {\n   unsigned int cache;\n };\n \n+/* Data structure to associate an arbitrary data to a source location.  */\n+struct location_adhoc_data {\n+  source_location locus;\n+  void *data;\n+};\n+\n+struct htab;\n+\n+/* The following data structure encodes a location with some adhoc data\n+   and maps it to a new unsigned integer (called an adhoc location)\n+   that replaces the original location to represent the mapping.\n+\n+   The new adhoc_loc uses the highest bit as the enabling bit, i.e. if the\n+   highest bit is 1, then the number is adhoc_loc. Otherwise, it serves as\n+   the original location. Once identified as the adhoc_loc, the lower 31\n+   bits of the integer is used to index the location_adhoc_data array,\n+   in which the locus and associated data is stored.  */\n+\n+struct location_adhoc_data_map {\n+  struct htab *htab;\n+  source_location curr_loc;\n+  struct location_adhoc_data *data;\n+  unsigned int allocated;\n+};\n+\n /* A set of chronological line_map structures.  */\n struct GTY(()) line_maps {\n   \n@@ -289,6 +314,8 @@ struct GTY(()) line_maps {\n   /* The allocators' function used to know the actual size it\n      allocated, for a certain allocation size requested.  */\n   line_map_round_alloc_size_func round_alloc_size;\n+\n+  struct location_adhoc_data_map GTY((skip)) location_adhoc_data_map;\n };\n \n /* Returns the pointer to the memory region where information about\n@@ -408,6 +435,17 @@ struct GTY(()) line_maps {\n #define LINEMAPS_LAST_ALLOCATED_MACRO_MAP(SET) \\\n   LINEMAPS_LAST_ALLOCATED_MAP (SET, true)\n \n+extern void location_adhoc_data_fini (struct line_maps *);\n+extern source_location get_combined_adhoc_loc (struct line_maps *,\n+\t\t\t\t\t       source_location, void *);\n+extern void *get_data_from_adhoc_loc (struct line_maps *, source_location);\n+extern source_location get_location_from_adhoc_loc (struct line_maps *,\n+\t\t\t\t\t\t    source_location);\n+\n+#define IS_ADHOC_LOC(LOC) (((LOC) & MAX_SOURCE_LOCATION) != (LOC))\n+#define COMBINE_LOCATION_DATA(SET, LOC, BLOCK) \\\n+  get_combined_adhoc_loc ((SET), (LOC), (BLOCK))\n+\n /* Initialize a line map set.  */\n extern void linemap_init (struct line_maps *);\n \n@@ -594,6 +632,8 @@ typedef struct\n \n   int column;\n \n+  void *data;\n+\n   /* In a system header?. */\n   bool sysp;\n } expanded_location;"}, {"sha": "54da4bca8bd56fb6ffe5cd5978c286152a8b3d35", "filename": "libcpp/line-map.c", "status": "modified", "additions": 172, "deletions": 2, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5368224f426c0dbe08a42e89d4cd18b0c8435834/libcpp%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5368224f426c0dbe08a42e89d4cd18b0c8435834/libcpp%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fline-map.c?ref=5368224f426c0dbe08a42e89d4cd18b0c8435834", "patch": "@@ -25,6 +25,7 @@ along with this program; see the file COPYING3.  If not see\n #include \"line-map.h\"\n #include \"cpplib.h\"\n #include \"internal.h\"\n+#include \"hashtab.h\"\n \n static void trace_include (const struct line_maps *, const struct line_map *);\n static const struct line_map * linemap_ordinary_map_lookup (struct line_maps *,\n@@ -50,6 +51,120 @@ static source_location linemap_macro_loc_to_exp_point (struct line_maps *,\n extern unsigned num_expanded_macros_counter;\n extern unsigned num_macro_tokens_counter;\n \n+/* Hash function for location_adhoc_data hashtable.  */\n+\n+static hashval_t\n+location_adhoc_data_hash (const void *l)\n+{\n+  const struct location_adhoc_data *lb =\n+      (const struct location_adhoc_data *) l;\n+  return (hashval_t) lb->locus + (size_t) &lb->data;\n+}\n+\n+/* Compare function for location_adhoc_data hashtable.  */\n+\n+static int\n+location_adhoc_data_eq (const void *l1, const void *l2)\n+{\n+  const struct location_adhoc_data *lb1 =\n+      (const struct location_adhoc_data *) l1;\n+  const struct location_adhoc_data *lb2 =\n+      (const struct location_adhoc_data *) l2;\n+  return lb1->locus == lb2->locus && lb1->data == lb2->data;\n+}\n+\n+/* Update the hashtable when location_adhoc_data is reallocated.  */\n+\n+static int\n+location_adhoc_data_update (void **slot, void *data)\n+{\n+  *((char **) slot) += *((long long *) data);\n+  return 1;\n+}\n+\n+/* Combine LOCUS and DATA to a combined adhoc loc.  */\n+\n+source_location\n+get_combined_adhoc_loc (struct line_maps *set,\n+\t\t\tsource_location locus, void *data)\n+{\n+  struct location_adhoc_data lb;\n+  struct location_adhoc_data **slot;\n+\n+  linemap_assert (data);\n+\n+  if (IS_ADHOC_LOC (locus))\n+    locus =\n+\tset->location_adhoc_data_map.data[locus & MAX_SOURCE_LOCATION].locus;\n+  if (locus == 0 && data == NULL)\n+    return 0;\n+  lb.locus = locus;\n+  lb.data = data;\n+  slot = (struct location_adhoc_data **)\n+      htab_find_slot (set->location_adhoc_data_map.htab, &lb, INSERT);\n+  if (*slot == NULL)\n+    {\n+      if (set->location_adhoc_data_map.curr_loc >=\n+\t  set->location_adhoc_data_map.allocated)\n+\t{\n+\t  char *orig_data = (char *) set->location_adhoc_data_map.data;\n+\t  long long offset;\n+\t  set->location_adhoc_data_map.allocated *= 2;\n+\t  set->location_adhoc_data_map.data =\n+\t      XRESIZEVEC (struct location_adhoc_data,\n+\t\t\t  set->location_adhoc_data_map.data,\n+\t\t\t  set->location_adhoc_data_map.allocated);\n+\t  offset = (char *) (set->location_adhoc_data_map.data) - orig_data;\n+\t  htab_traverse (set->location_adhoc_data_map.htab,\n+\t\t\t location_adhoc_data_update, &offset);\n+\t}\n+      *slot = set->location_adhoc_data_map.data\n+\t      + set->location_adhoc_data_map.curr_loc;\n+      set->location_adhoc_data_map.data[\n+\t  set->location_adhoc_data_map.curr_loc++] = lb;\n+    }\n+  return ((*slot) - set->location_adhoc_data_map.data) | 0x80000000;\n+}\n+\n+/* Return the data for the adhoc loc.  */\n+\n+void *\n+get_data_from_adhoc_loc (struct line_maps *set, source_location loc)\n+{\n+  linemap_assert (IS_ADHOC_LOC (loc));\n+  return set->location_adhoc_data_map.data[loc & MAX_SOURCE_LOCATION].data;\n+}\n+\n+/* Return the location for the adhoc loc.  */\n+\n+source_location\n+get_location_from_adhoc_loc (struct line_maps *set, source_location loc)\n+{\n+  linemap_assert (IS_ADHOC_LOC (loc));\n+  return set->location_adhoc_data_map.data[loc & MAX_SOURCE_LOCATION].locus;\n+}\n+\n+/* Initialize the location_adhoc_data structure.  */\n+\n+static void\n+location_adhoc_data_init (struct line_maps *set)\n+{\n+  set->location_adhoc_data_map.htab =\n+      htab_create (100, location_adhoc_data_hash, location_adhoc_data_eq, NULL);\n+  set->location_adhoc_data_map.curr_loc = 0;\n+  set->location_adhoc_data_map.allocated = 100;\n+  set->location_adhoc_data_map.data = XNEWVEC (struct location_adhoc_data, 100);\n+}\n+\n+/* Finalize the location_adhoc_data structure.  */\n+void\n+location_adhoc_data_fini (struct line_maps *set)\n+{\n+  set->location_adhoc_data_map.allocated = 0;\n+  XDELETEVEC (set->location_adhoc_data_map.data);\n+  htab_delete (set->location_adhoc_data_map.htab);\n+}\n+\n /* Initialize a line map set.  */\n \n void\n@@ -58,6 +173,7 @@ linemap_init (struct line_maps *set)\n   memset (set, 0, sizeof (struct line_maps));\n   set->highest_location = RESERVED_LOCATION_COUNT - 1;\n   set->highest_line = RESERVED_LOCATION_COUNT - 1;\n+  location_adhoc_data_init (set);\n }\n \n /* Check for and warn about line_maps entered but not exited.  */\n@@ -408,12 +524,12 @@ linemap_line_start (struct line_maps *set, linenum_type to_line,\n   if (add_map)\n     {\n       int column_bits;\n-      if (max_column_hint > 100000 || highest > 0xC0000000)\n+      if (max_column_hint > 100000 || highest > 0x60000000)\n \t{\n \t  /* If the column number is ridiculous or we've allocated a huge\n \t     number of source_locations, give up on column numbers. */\n \t  max_column_hint = 0;\n-\t  if (highest >0xF0000000)\n+\t  if (highest >0x70000000)\n \t    return 0;\n \t  column_bits = 0;\n \t}\n@@ -509,6 +625,8 @@ linemap_position_for_line_and_column (struct line_map *map,\n const struct line_map*\n linemap_lookup (struct line_maps *set, source_location line)\n {\n+  if (IS_ADHOC_LOC (line))\n+    line = set->location_adhoc_data_map.data[line & MAX_SOURCE_LOCATION].locus;\n   if (linemap_location_from_macro_expansion_p (set, line))\n     return linemap_macro_map_lookup (set, line);\n   return linemap_ordinary_map_lookup (set, line);\n@@ -525,6 +643,9 @@ linemap_ordinary_map_lookup (struct line_maps *set, source_location line)\n   unsigned int md, mn, mx;\n   const struct line_map *cached, *result;\n \n+  if (IS_ADHOC_LOC (line))\n+    line = set->location_adhoc_data_map.data[line & MAX_SOURCE_LOCATION].locus;\n+\n   if (set ==  NULL || line < RESERVED_LOCATION_COUNT)\n     return NULL;\n \n@@ -570,6 +691,9 @@ linemap_macro_map_lookup (struct line_maps *set, source_location line)\n   unsigned int md, mn, mx;\n   const struct line_map *cached, *result;\n \n+  if (IS_ADHOC_LOC (line))\n+    line = set->location_adhoc_data_map.data[line & MAX_SOURCE_LOCATION].locus;\n+\n   linemap_assert (line >= LINEMAPS_MACRO_LOWEST_LOCATION (set));\n \n   if (set ==  NULL)\n@@ -696,6 +820,10 @@ linemap_get_expansion_line (struct line_maps *set,\n {\n   const struct line_map *map = NULL;\n \n+  if (IS_ADHOC_LOC (location))\n+    location = set->location_adhoc_data_map.data[\n+\tlocation & MAX_SOURCE_LOCATION].locus;\n+\n   if (location < RESERVED_LOCATION_COUNT)\n     return 0;\n \n@@ -720,6 +848,10 @@ linemap_get_expansion_filename (struct line_maps *set,\n {\n   const struct line_map *map = NULL;\n \n+  if (IS_ADHOC_LOC (location))\n+    location = set->location_adhoc_data_map.data[\n+\tlocation & MAX_SOURCE_LOCATION].locus;\n+\n   if (location < RESERVED_LOCATION_COUNT)\n     return NULL;\n \n@@ -754,6 +886,10 @@ linemap_location_in_system_header_p (struct line_maps *set,\n {\n   const struct line_map *map = NULL;\n \n+  if (IS_ADHOC_LOC (location))\n+    location = set->location_adhoc_data_map.data[\n+\tlocation & MAX_SOURCE_LOCATION].locus;\n+\n   if (location < RESERVED_LOCATION_COUNT)\n     return false;\n \n@@ -793,6 +929,10 @@ bool\n linemap_location_from_macro_expansion_p (struct line_maps *set,\n \t\t\t\t\t source_location location)\n {\n+  if (IS_ADHOC_LOC (location))\n+    location = set->location_adhoc_data_map.data[\n+\tlocation & MAX_SOURCE_LOCATION].locus;\n+\n   linemap_assert (location <= MAX_SOURCE_LOCATION\n \t\t  && (set->highest_location\n \t\t      < LINEMAPS_MACRO_LOWEST_LOCATION (set)));\n@@ -933,6 +1073,10 @@ linemap_macro_loc_to_spelling_point (struct line_maps *set,\n {\n   struct line_map *map;\n \n+  if (IS_ADHOC_LOC (location))\n+    location = set->location_adhoc_data_map.data[\n+\tlocation & MAX_SOURCE_LOCATION].locus;\n+\n   linemap_assert (set && location >= RESERVED_LOCATION_COUNT);\n \n   while (true)\n@@ -967,6 +1111,10 @@ linemap_macro_loc_to_def_point (struct line_maps *set,\n {\n   struct line_map *map;\n \n+  if (IS_ADHOC_LOC (location))\n+    location = set->location_adhoc_data_map.data[\n+\tlocation & MAX_SOURCE_LOCATION].locus;\n+\n   linemap_assert (set && location >= RESERVED_LOCATION_COUNT);\n \n   while (true)\n@@ -1005,6 +1153,10 @@ linemap_macro_loc_to_exp_point (struct line_maps *set,\n {\n   struct line_map *map;\n \n+  if (IS_ADHOC_LOC (location))\n+    location = set->location_adhoc_data_map.data[\n+\tlocation & MAX_SOURCE_LOCATION].locus;\n+\n   linemap_assert (set && location >= RESERVED_LOCATION_COUNT);\n \n   while (true)\n@@ -1074,6 +1226,9 @@ linemap_resolve_location (struct line_maps *set,\n \t\t\t  enum location_resolution_kind lrk,\n \t\t\t  const struct line_map **map)\n {\n+  if (IS_ADHOC_LOC (loc))\n+    loc = set->location_adhoc_data_map.data[loc & MAX_SOURCE_LOCATION].locus;\n+\n   if (loc < RESERVED_LOCATION_COUNT)\n     {\n       /* A reserved location wasn't encoded in a map.  Let's return a\n@@ -1121,6 +1276,9 @@ linemap_unwind_toward_expansion (struct line_maps *set,\n   source_location resolved_location;\n   const struct line_map *resolved_map;\n \n+  if (IS_ADHOC_LOC (loc))\n+    loc = set->location_adhoc_data_map.data[loc & MAX_SOURCE_LOCATION].locus;\n+\n   resolved_location =\n     linemap_macro_map_loc_unwind_toward_spelling (*map, loc);\n   resolved_map = linemap_lookup (set, resolved_location);\n@@ -1157,6 +1315,9 @@ linemap_unwind_to_first_non_reserved_loc (struct line_maps *set,\n   source_location resolved_loc;\n   const struct line_map *map0 = NULL, *map1 = NULL;\n \n+  if (IS_ADHOC_LOC (loc))\n+    loc = set->location_adhoc_data_map.data[loc & MAX_SOURCE_LOCATION].locus;\n+\n   map0 = linemap_lookup (set, loc);\n   if (!linemap_macro_expansion_map_p (map0))\n     return loc;\n@@ -1198,6 +1359,12 @@ linemap_expand_location (struct line_maps *set,\n   expanded_location xloc;\n \n   memset (&xloc, 0, sizeof (xloc));\n+  if (IS_ADHOC_LOC (loc))\n+    {\n+      loc = set->location_adhoc_data_map.data[loc & MAX_SOURCE_LOCATION].locus;\n+      xloc.data = set->location_adhoc_data_map.data[\n+\t  loc & MAX_SOURCE_LOCATION].data;\n+    }\n \n   if (loc < RESERVED_LOCATION_COUNT)\n     /* The location for this token wasn't generated from a line map.\n@@ -1290,6 +1457,9 @@ linemap_dump_location (struct line_maps *set,\n   const char *path = \"\", *from = \"\";\n   int l = -1, c = -1, s = -1, e = -1;\n \n+  if (IS_ADHOC_LOC (loc))\n+    loc = set->location_adhoc_data_map.data[loc & MAX_SOURCE_LOCATION].locus;\n+\n   if (loc == 0)\n     return;\n "}]}