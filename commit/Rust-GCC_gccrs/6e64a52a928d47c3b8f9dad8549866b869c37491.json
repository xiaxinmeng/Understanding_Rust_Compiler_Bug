{"sha": "6e64a52a928d47c3b8f9dad8549866b869c37491", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU2NGE1MmE5MjhkNDdjM2I4ZjlkYWQ4NTQ5ODY2Yjg2OWMzNzQ5MQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-07-25T20:51:24Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-07-25T20:51:24Z"}, "message": "flow.c (delete_dead_jumptables): New function.\n\n\t* flow.c (delete_dead_jumptables): New function.\n\t(life_analyzis): Call it.\n\t* bb-reorder.c (skip_insns_after_block): Handle contradictive sequences.\n\nFrom-SVN: r44365", "tree": {"sha": "5205cf427c945b033bd08b12e5836f7ef40eecd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5205cf427c945b033bd08b12e5836f7ef40eecd0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e64a52a928d47c3b8f9dad8549866b869c37491", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e64a52a928d47c3b8f9dad8549866b869c37491", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e64a52a928d47c3b8f9dad8549866b869c37491", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e64a52a928d47c3b8f9dad8549866b869c37491/comments", "author": null, "committer": null, "parents": [{"sha": "7f206d8f42ecbe874b67712a5994dc4459ca4795", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f206d8f42ecbe874b67712a5994dc4459ca4795", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f206d8f42ecbe874b67712a5994dc4459ca4795"}], "stats": {"total": 118, "additions": 102, "deletions": 16}, "files": [{"sha": "9eb513e515a44c8169a932561ce033332ff41ee2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e64a52a928d47c3b8f9dad8549866b869c37491/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e64a52a928d47c3b8f9dad8549866b869c37491/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e64a52a928d47c3b8f9dad8549866b869c37491", "patch": "@@ -1,3 +1,9 @@\n+Wed Jul 25 22:48:59 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* flow.c (delete_dead_jumptables): New function.\n+\t(life_analyzis): Call it.\n+\t* bb-reorder.c (skip_insns_after_block): Handle contradictive sequences.\n+\n 2001-07-25  Richard Henderson  <rth@redhat.com>\n \n \t* except.c (reachable_handlers): Handle a region being removed"}, {"sha": "e1b341755b1b62a19b989cc4f52e2b8c59bd2871", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e64a52a928d47c3b8f9dad8549866b869c37491/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e64a52a928d47c3b8f9dad8549866b869c37491/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=6e64a52a928d47c3b8f9dad8549866b869c37491", "patch": "@@ -205,7 +205,7 @@ static rtx\n skip_insns_after_block (bb)\n      basic_block bb;\n {\n-  rtx insn, last_insn, next_head;\n+  rtx insn, last_insn, next_head, prev;\n \n   next_head = NULL_RTX;\n   if (bb->index + 1 != n_basic_blocks)\n@@ -234,12 +234,7 @@ skip_insns_after_block (bb)\n \t      continue;\n \n \t    default:\n-\t      /* Make line notes attached to the succesor block unless they\n-\t         are followed by something attached to predecesor block.\n-\t         These notes remained after removing code in the predecesor\n-\t         block and thus should be kept together.  */\n-\t      if (NOTE_LINE_NUMBER (insn) >= 0)\n-\t\tcontinue;\n+\t      continue;\n \t      break;\n \t    }\n \t  break;\n@@ -262,6 +257,32 @@ skip_insns_after_block (bb)\n \n       break;\n     }\n+  /* It is possible to hit contradicting sequence.  For instance:\n+    \n+     jump_insn\n+     NOTE_INSN_LOOP_BEG\n+     barrier\n+\n+     Where barrier belongs to jump_insn, but the note does not.\n+     This can be created by removing the basic block originally\n+     following NOTE_INSN_LOOP_BEG.\n+\n+     In such case reorder the notes.  */\n+  for (insn = last_insn; insn != bb->end; insn = prev)\n+    {\n+    prev = PREV_INSN (insn);\n+    if (GET_CODE (insn) == NOTE)\n+      switch (NOTE_LINE_NUMBER (insn))\n+        {\n+          case NOTE_INSN_LOOP_END:\n+          case NOTE_INSN_BLOCK_END:\n+          case NOTE_INSN_DELETED:\n+          case NOTE_INSN_DELETED_LABEL:\n+    \tcontinue;\n+          default:\n+    \treorder_insns (insn, insn, last_insn);\n+        }\n+    }\n \n   return last_insn;\n }"}, {"sha": "529eb00ddf03e2b29372b6dff23ab63df5e24702", "filename": "gcc/flow.c", "status": "modified", "additions": 68, "deletions": 9, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e64a52a928d47c3b8f9dad8549866b869c37491/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e64a52a928d47c3b8f9dad8549866b869c37491/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=6e64a52a928d47c3b8f9dad8549866b869c37491", "patch": "@@ -481,6 +481,7 @@ static void flow_loop_tree_node_add\tPARAMS ((struct loop *, struct loop *));\n static void flow_loops_tree_build\tPARAMS ((struct loops *));\n static int flow_loop_level_compute\tPARAMS ((struct loop *, int));\n static int flow_loops_level_compute\tPARAMS ((struct loops *));\n+static void delete_dead_jumptables\tPARAMS ((void));\n \f\n /* Find basic blocks of the current function.\n    F is the first insn of the function and NREGS the number of register\n@@ -4081,6 +4082,8 @@ life_analysis (f, file, flags)\n       }\n   }\n #endif\n+  /* Removing dead insns should've made jumptables really dead.  */\n+  delete_dead_jumptables ();\n }\n \n /* A subroutine of verify_wide_reg, called through for_each_rtx.\n@@ -4334,6 +4337,32 @@ delete_noop_moves (f)\n     }\n }\n \n+/* Delete any jump tables never referenced.  We can't delete them at the\n+   time of removing tablejump insn as they are referenced by the preceeding\n+   insns computing the destination, so we delay deleting and garbagecollect\n+   them once life information is computed.  */\n+static void\n+delete_dead_jumptables ()\n+{\n+  rtx insn, next;\n+  for (insn = get_insns (); insn; insn = next)\n+    {\n+      next = NEXT_INSN (insn);\n+      if (GET_CODE (insn) == CODE_LABEL\n+\t  && LABEL_NUSES (insn) == 0\n+\t  && GET_CODE (next) == JUMP_INSN\n+\t  && (GET_CODE (PATTERN (next)) == ADDR_VEC\n+\t      || GET_CODE (PATTERN (next)) == ADDR_DIFF_VEC))\n+\t{\n+\t  if (rtl_dump_file)\n+\t    fprintf (rtl_dump_file, \"Dead jumptable %i removed\\n\", INSN_UID (insn));\n+\t  flow_delete_insn (NEXT_INSN (insn));\n+\t  flow_delete_insn (insn);\n+\t  next = NEXT_INSN (next);\n+\t}\n+    }\n+}\n+\n /* Determine if the stack pointer is constant over the life of the function.\n    Only useful before prologues have been emitted.  */\n \n@@ -7956,7 +7985,7 @@ set_block_for_new_insns (insn, bb)\n \n    - test head/end pointers\n    - overlapping of basic blocks\n-   - edge list corectness\n+   - edge list correctness\n    - headers of basic blocks (the NOTE_INSN_BASIC_BLOCK note)\n    - tails of basic blocks (ensure that boundary is necesary)\n    - scans body of the basic block for JUMP_INSN, CODE_LABEL\n@@ -8031,8 +8060,9 @@ verify_flow_info ()\n   for (i = n_basic_blocks - 1; i >= 0; i--)\n     {\n       basic_block bb = BASIC_BLOCK (i);\n-      /* Check corectness of edge lists */\n+      /* Check correctness of edge lists. */\n       edge e;\n+      int has_fallthru = 0;\n \n       e = bb->succ;\n       while (e)\n@@ -8045,17 +8075,31 @@ verify_flow_info ()\n \t    }\n \t  last_visited [e->dest->index + 2] = bb;\n \n+\t  if (e->flags & EDGE_FALLTHRU)\n+\t    has_fallthru = 1;\n+\n \t  if ((e->flags & EDGE_FALLTHRU)\n \t      && e->src != ENTRY_BLOCK_PTR\n-\t      && e->dest != EXIT_BLOCK_PTR\n-\t      && (e->src->index + 1 != e->dest->index\n-\t\t  || !can_fallthru (e->src, e->dest)))\n+\t      && e->dest != EXIT_BLOCK_PTR)\n \t    {\n-\t      error (\"verify_flow_info: Incorrect fallthru edge %i->%i\",\n-\t\t     e->src->index, e->dest->index);\n-\t      err = 1;\n+\t      rtx insn;\n+\t      if (e->src->index + 1 != e->dest->index)\n+\t\t{\n+\t\t    error (\"verify_flow_info: Incorrect blocks for fallthru %i->%i\",\n+\t\t\t   e->src->index, e->dest->index);\n+\t\t    err = 1;\n+\t\t}\n+\t      else\n+\t\tfor (insn = NEXT_INSN (e->src->end); insn != e->dest->head;\n+\t\t     insn = NEXT_INSN (insn))\n+\t\t  if (GET_CODE (insn) == BARRIER || INSN_P (insn))\n+\t\t    {\n+\t\t      error (\"verify_flow_info: Incorrect fallthru %i->%i\",\n+\t\t\t     e->src->index, e->dest->index);\n+\t\t      fatal_insn (\"Wrong insn in the fallthru edge\", insn);\n+\t\t      err = 1;\n+\t\t    }\n \t    }\n-\t    \n \t  if (e->src != bb)\n \t    {\n \t      error (\"verify_flow_info: Basic block %d succ edge is corrupted\",\n@@ -8080,6 +8124,21 @@ verify_flow_info ()\n \t    }\n \t  e = e->succ_next;\n \t}\n+      if (!has_fallthru)\n+\t{\n+\t  rtx insn = bb->end;\n+\n+\t  /* Ensure existence of barrier in BB with no fallthru edges.  */\n+\t  for (insn = bb->end; GET_CODE (insn) != BARRIER;\n+\t       insn = NEXT_INSN (insn))\n+\t    if (!insn\n+\t\t|| (GET_CODE (insn) == NOTE\n+\t\t    && NOTE_LINE_NUMBER (insn) == NOTE_INSN_BASIC_BLOCK))\n+\t\t{\n+\t\t  error (\"Missing barrier after block %i\", bb->index);\n+\t\t  err = 1;\n+\t\t}\n+\t}\n \n       e = bb->pred;\n       while (e)"}]}