{"sha": "74601d7c09fba7d38715dc1adb1b24fdd98cf1f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ2MDFkN2MwOWZiYTdkMzg3MTVkYzFhZGIxYjI0ZmRkOThjZjFmMw==", "commit": {"author": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@users.sourceforge.net", "date": "2000-12-07T07:17:09Z"}, "committer": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@gcc.gnu.org", "date": "2000-12-07T07:17:09Z"}, "message": "pt.c (verify_class_unification): New function.\n\n\t* pt.c (verify_class_unification): New function.\n\t(get_class_bindings): Use it.\n\t(try_class_unification): Tidy.\n\t(unify): Handle when argument of a template-id is not\n\ttemplate parameter dependent.\n\t(template_args_equal): Handle when TREE_CODE's do not match.\n\n\t* g++.old-deja/g++.oliva/partspec1.C: Remove XFAIL.\n\t* g++.old-deja/g++.pt/partial4.C: New test.\n\nFrom-SVN: r38102", "tree": {"sha": "42bc9043447773d2eac4ced16950fa0b3283cbb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42bc9043447773d2eac4ced16950fa0b3283cbb2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74601d7c09fba7d38715dc1adb1b24fdd98cf1f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74601d7c09fba7d38715dc1adb1b24fdd98cf1f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74601d7c09fba7d38715dc1adb1b24fdd98cf1f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74601d7c09fba7d38715dc1adb1b24fdd98cf1f3/comments", "author": null, "committer": null, "parents": [{"sha": "9ba2e1ef8028112b47eb48041ae387c60acea6b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ba2e1ef8028112b47eb48041ae387c60acea6b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ba2e1ef8028112b47eb48041ae387c60acea6b1"}], "stats": {"total": 154, "additions": 124, "deletions": 30}, "files": [{"sha": "49c3d64f856dfb04078bad449c607bd7b8235f7f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74601d7c09fba7d38715dc1adb1b24fdd98cf1f3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74601d7c09fba7d38715dc1adb1b24fdd98cf1f3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=74601d7c09fba7d38715dc1adb1b24fdd98cf1f3", "patch": "@@ -1,3 +1,12 @@\n+2000-12-06  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\t* pt.c (verify_class_unification): New function.\n+\t(get_class_bindings): Use it.\n+\t(try_class_unification): Tidy.\n+\t(unify): Handle when argument of a template-id is not\n+\ttemplate parameter dependent.\n+\t(template_args_equal): Handle when TREE_CODE's do not match.\n+\n 2000-12-06  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* lang-specs.h (c++): When invoking the stand-alone preprocessor"}, {"sha": "900ef3c6c6233d43b0e5c59f1c3ccd5fa72f24da", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 83, "deletions": 27, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74601d7c09fba7d38715dc1adb1b24fdd98cf1f3/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74601d7c09fba7d38715dc1adb1b24fdd98cf1f3/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=74601d7c09fba7d38715dc1adb1b24fdd98cf1f3", "patch": "@@ -157,6 +157,7 @@ static tree tsubst_call_declarator_parms PARAMS ((tree, tree, int, tree));\n static tree get_template_base_recursive PARAMS ((tree, tree,\n \t\t\t\t\t       tree, tree, tree, int)); \n static tree get_template_base PARAMS ((tree, tree, tree, tree));\n+static int verify_class_unification PARAMS ((tree, tree, tree));\n static tree try_class_unification PARAMS ((tree, tree, tree, tree));\n static int coerce_template_template_parms PARAMS ((tree, tree, int,\n \t\t\t\t\t\t tree, tree));\n@@ -3464,13 +3465,14 @@ template_args_equal (ot, nt)\n {\n   if (nt == ot)\n     return 1;\n-  if (TREE_CODE (nt) != TREE_CODE (ot))\n-    return 0;\n+\n   if (TREE_CODE (nt) == TREE_VEC)\n     /* For member templates */\n-    return comp_template_args (ot, nt);\n-  else if (TYPE_P (ot))\n-    return same_type_p (ot, nt);\n+    return TREE_CODE (ot) == TREE_VEC && comp_template_args (ot, nt);\n+  else if (TYPE_P (nt))\n+    return TYPE_P (ot) && same_type_p (ot, nt);\n+  else if (TREE_CODE (ot) == TREE_VEC || TYPE_P (ot))\n+    return 0;\n   else\n     return (cp_tree_equal (ot, nt) > 0);\n }\n@@ -8039,6 +8041,52 @@ try_one_overload (tparms, orig_targs, targs, parm, arg, strict,\n   return 1;\n }\n \n+/* Verify that nondeduce template argument agrees with the type\n+   obtained from argument deduction.  Return nonzero if the\n+   verification fails.\n+\n+   For example:\n+\n+     struct A { typedef int X; };\n+     template <class T, class U> struct C {};\n+     template <class T> struct C<T, typename T::X> {};\n+\n+   Then with the instantiation `C<A, int>', we can deduce that\n+   `T' is `A' but unify () does not check whether `typename T::X'\n+   is `int'.  This function ensure that they agree.\n+\n+   TARGS, PARMS are the same as the arguments of unify.\n+   ARGS contains template arguments from all levels.  */\n+\n+static int\n+verify_class_unification (targs, parms, args)\n+     tree targs, parms, args;\n+{\n+  int i;\n+  int nparms = TREE_VEC_LENGTH (parms);\n+  tree new_parms = tsubst (parms, add_outermost_template_args (args, targs),\n+  \t\t\t   /*complain=*/0, NULL_TREE);\n+  if (new_parms == error_mark_node)\n+    return 1;\n+\n+  args = INNERMOST_TEMPLATE_ARGS (args);\n+\n+  for (i = 0; i < nparms; i++)\n+    {\n+      tree parm = TREE_VEC_ELT (new_parms, i);\n+      tree arg = TREE_VEC_ELT (args, i);\n+\n+      /* In case we are deducing from a function argument of a function\n+\t templates, some parameters may not be deduced yet.  So we\n+\t make sure that only fully substituted elements of PARM are\n+\t compared below.  */\n+\n+      if (!uses_template_parms (parm) && !template_args_equal (parm, arg))\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\n /* PARM is a template class (perhaps with unbound template\n    parameters).  ARG is a fully instantiated type.  If ARG can be\n    bound to PARM, return ARG, otherwise return NULL_TREE.  TPARMS and\n@@ -8051,7 +8099,6 @@ try_class_unification (tparms, targs, parm, arg)\n      tree parm;\n      tree arg;\n {\n-  int i;\n   tree copy_of_targs;\n \n   if (!CLASSTYPE_TEMPLATE_INFO (arg)\n@@ -8089,14 +8136,13 @@ try_class_unification (tparms, targs, parm, arg)\n      with S<I, I, I>.  If we kept the already deduced knowledge, we\n      would reject the possibility I=1.  */\n   copy_of_targs = make_tree_vec (TREE_VEC_LENGTH (targs));\n-  i = unify (tparms, copy_of_targs, CLASSTYPE_TI_ARGS (parm),\n-\t     CLASSTYPE_TI_ARGS (arg), UNIFY_ALLOW_NONE);\n   \n   /* If unification failed, we're done.  */\n-  if (i != 0)\n+  if (unify (tparms, copy_of_targs, CLASSTYPE_TI_ARGS (parm),\n+\t     CLASSTYPE_TI_ARGS (arg), UNIFY_ALLOW_NONE))\n     return NULL_TREE;\n-  else\n-    return arg;\n+\n+  return arg;\n }\n \n /* Subroutine of get_template_base.  RVAL, if non-NULL, is a base we\n@@ -8699,25 +8745,33 @@ unify (tparms, targs, parm, arg, strict)\n \n     default:\n       if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (parm))))\n-\t/* We're looking at an expression.  This can happen with\n-\t   something like: \n+\t{\n+\n+\t  /* We're looking at an expression.  This can happen with\n+\t     something like: \n \t   \n-\t     template <int I>\n-\t     void foo(S<I>, S<I + 2>);\n+\t       template <int I>\n+\t       void foo(S<I>, S<I + 2>);\n \n-\t   This is a \"nondeduced context\":\n+\t     This is a \"nondeduced context\":\n \n-\t     [deduct.type]\n+\t       [deduct.type]\n \t   \n-\t     The nondeduced contexts are:\n+\t       The nondeduced contexts are:\n \n-\t     --A type that is a template-id in which one or more of\n-\t       the template-arguments is an expression that references\n-\t       a template-parameter.  \n+\t       --A type that is a template-id in which one or more of\n+\t         the template-arguments is an expression that references\n+\t         a template-parameter.  \n \n-\t   In these cases, we assume deduction succeeded, but don't\n-\t   actually infer any unifications.  */\n-\treturn 0;\n+\t     In these cases, we assume deduction succeeded, but don't\n+\t     actually infer any unifications.  */\n+\n+\t  if (!uses_template_parms (parm)\n+\t      && !template_args_equal (parm, arg))\n+\t    return 1;\n+\t  else\n+\t    return 0;\n+\t}\n       else\n \tsorry (\"use of `%s' in template type unification\",\n \t       tree_code_name [(int) TREE_CODE (parm)]);\n@@ -8923,15 +8977,17 @@ get_class_bindings (tparms, parms, args)\n   int i, ntparms = TREE_VEC_LENGTH (tparms);\n   tree vec = make_tree_vec (ntparms);\n \n-  args = INNERMOST_TEMPLATE_ARGS (args);\n-\n-  if (unify (tparms, vec, parms, args, UNIFY_ALLOW_NONE))\n+  if (unify (tparms, vec, parms, INNERMOST_TEMPLATE_ARGS (args),\n+  \t     UNIFY_ALLOW_NONE))\n     return NULL_TREE;\n \n   for (i =  0; i < ntparms; ++i)\n     if (! TREE_VEC_ELT (vec, i))\n       return NULL_TREE;\n \n+  if (verify_class_unification (vec, parms, args))\n+    return NULL_TREE;\n+\n   return vec;\n }\n "}, {"sha": "340a7654f205425e21130a644995762083f92561", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74601d7c09fba7d38715dc1adb1b24fdd98cf1f3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74601d7c09fba7d38715dc1adb1b24fdd98cf1f3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=74601d7c09fba7d38715dc1adb1b24fdd98cf1f3", "patch": "@@ -1,3 +1,8 @@\n+2000-12-06  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\t* g++.old-deja/g++.oliva/partspec1.C: Remove XFAIL.\n+\t* g++.old-deja/g++.pt/partial4.C: New test.\n+\n 2000-12-06  J. David Anglin  <dave@hiauly1.hia.nrc.ca>\n \n \t* gcc.c-torture/execute/ieee/hugeval.x: New."}, {"sha": "067a6352efede974e8f7559c30796a10ad70a8ad", "filename": "gcc/testsuite/g++.old-deja/g++.oliva/partspec1.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74601d7c09fba7d38715dc1adb1b24fdd98cf1f3/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.oliva%2Fpartspec1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74601d7c09fba7d38715dc1adb1b24fdd98cf1f3/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.oliva%2Fpartspec1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.oliva%2Fpartspec1.C?ref=74601d7c09fba7d38715dc1adb1b24fdd98cf1f3", "patch": "@@ -10,11 +10,11 @@ template <typename A, int* P> struct X;\n int a;\n \n template <typename A>\n-struct X<A,&a> {}; // gets bogus error - candidate - XFAIL *-*-*\n+struct X<A,&a> {};\n \n int b;\n \n template <typename A>\n-struct X<A,&b> {}; // gets bogus error - candidate - XFAIL *-*-*\n+struct X<A,&b> {};\n \n-X<int,&a> x; // gets bogus error - ambiguous - XFAIL *-*-*\n+X<int,&a> x;"}, {"sha": "3956a0c87e163933092603b546a3c34cd69c3271", "filename": "gcc/testsuite/g++.old-deja/g++.pt/partial4.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74601d7c09fba7d38715dc1adb1b24fdd98cf1f3/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fpartial4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74601d7c09fba7d38715dc1adb1b24fdd98cf1f3/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fpartial4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fpartial4.C?ref=74601d7c09fba7d38715dc1adb1b24fdd98cf1f3", "patch": "@@ -0,0 +1,24 @@\n+// Build don't link:\n+// Origin: Gabriel Dos Reis <Gabriel.Dos-Reis@cmla.ens-cachan.fr>\n+\n+// Bug 29.  We failed to verify that template argument deduction\n+// produces a valid result in nondeduce context.\n+\n+template<class T> struct Y { typedef T X; };\n+\n+template<class T, class U> struct Base {};\n+\n+template<class T> struct Base<T, typename T::X> {};\n+\n+template<class T> struct Base<typename T::X, T> {};\n+\n+template<class T, class U> struct Derived : Base <T, U> {};\n+\n+struct A {};\n+\n+template<class T> struct Derived<A, T> : Base< Y<T>, Y<T> > {};\n+\n+int main()\n+{\n+  Derived<A, int> d;\n+}"}]}