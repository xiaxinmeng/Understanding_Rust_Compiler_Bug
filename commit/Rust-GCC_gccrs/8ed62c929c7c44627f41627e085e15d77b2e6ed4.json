{"sha": "8ed62c929c7c44627f41627e085e15d77b2e6ed4", "node_id": "C_kwDOANBUbNoAKDhlZDYyYzkyOWM3YzQ0NjI3ZjQxNjI3ZTA4NWUxNWQ3N2IyZTZlZDQ", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2021-11-10T15:58:15Z"}, "committer": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2021-11-10T15:58:15Z"}, "message": "middle-end: Add an RPO pass after successful vectorization\n\nFollowing my current SVE predicate optimization series a problem has presented\nitself in that the way vector masks are generated for masked operations relies\non CSE to share masks efficiently.\n\nThe issue however is that masking is done using the & operand and & is\nassociative and so reassoc decides to reassociate the masked operations.\n\nThis makes CSE then unable to CSE an unmasked and a masked operation leading to\nduplicate operations being performed.\n\nTo counter this we want to add an RPO pass over the vectorized loop body when\nvectorization succeeds.  This makes it then no longer reliant on the RTL level\nCSE.\n\nI have not added a testcase for this as it requires the changes in my patch\nseries, however the entire series relies on this patch to work so all the\ntests there cover it.\n\ngcc/ChangeLog:\n\n\t* tree-vectorizer.c (vectorize_loops): Do local CSE through RPVN upon\n\tsuccessful vectorization.", "tree": {"sha": "42dc3f70824bc9c9643bdbcb9826d1857972a15b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42dc3f70824bc9c9643bdbcb9826d1857972a15b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ed62c929c7c44627f41627e085e15d77b2e6ed4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ed62c929c7c44627f41627e085e15d77b2e6ed4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ed62c929c7c44627f41627e085e15d77b2e6ed4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ed62c929c7c44627f41627e085e15d77b2e6ed4/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eaec20fde587e0695b100dcba5ff56944c3ae8c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaec20fde587e0695b100dcba5ff56944c3ae8c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaec20fde587e0695b100dcba5ff56944c3ae8c0"}], "stats": {"total": 53, "additions": 32, "deletions": 21}, "files": [{"sha": "3247c9af23b3854efb0d902c738a54e6883ff4b0", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 32, "deletions": 21, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ed62c929c7c44627f41627e085e15d77b2e6ed4/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ed62c929c7c44627f41627e085e15d77b2e6ed4/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=8ed62c929c7c44627f41627e085e15d77b2e6ed4", "patch": "@@ -81,7 +81,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-pretty-print.h\"\n #include \"opt-problem.h\"\n #include \"internal-fn.h\"\n-\n+#include \"tree-ssa-sccvn.h\"\n \n /* Loop or bb location, with hotness information.  */\n dump_user_location_t vect_location;\n@@ -1276,48 +1276,59 @@ vectorize_loops (void)\n \t  }\n       }\n \n-  for (i = 1; i < number_of_loops (cfun); i++)\n-    {\n-      loop_vec_info loop_vinfo;\n-      bool has_mask_store;\n-\n-      loop = get_loop (cfun, i);\n-      if (!loop || !loop->aux)\n-\tcontinue;\n-      loop_vinfo = (loop_vec_info) loop->aux;\n-      has_mask_store = LOOP_VINFO_HAS_MASK_STORE (loop_vinfo);\n-      delete loop_vinfo;\n-      if (has_mask_store\n-\t  && targetm.vectorize.empty_mask_is_expensive (IFN_MASK_STORE))\n-\toptimize_mask_stores (loop);\n-      loop->aux = NULL;\n-    }\n-\n   /* Fold IFN_GOMP_SIMD_{VF,LANE,LAST_LANE,ORDERED_{START,END}} builtins.  */\n   if (cfun->has_simduid_loops)\n     {\n       adjust_simduid_builtins (simduid_to_vf_htab);\n       /* Avoid stale SCEV cache entries for the SIMD_LANE defs.  */\n       scev_reset ();\n     }\n-\n   /* Shrink any \"omp array simd\" temporary arrays to the\n      actual vectorization factors.  */\n   if (simd_array_to_simduid_htab)\n     shrink_simd_arrays (simd_array_to_simduid_htab, simduid_to_vf_htab);\n   delete simduid_to_vf_htab;\n   cfun->has_simduid_loops = false;\n-  vect_slp_fini ();\n \n   if (num_vectorized_loops > 0)\n     {\n       /* If we vectorized any loop only virtual SSA form needs to be updated.\n \t ???  Also while we try hard to update loop-closed SSA form we fail\n \t to properly do this in some corner-cases (see PR56286).  */\n       rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa_only_virtuals);\n-      return TODO_cleanup_cfg;\n+      ret |= TODO_cleanup_cfg;\n     }\n \n+  for (i = 1; i < number_of_loops (cfun); i++)\n+    {\n+      loop_vec_info loop_vinfo;\n+      bool has_mask_store;\n+\n+      loop = get_loop (cfun, i);\n+      if (!loop || !loop->aux)\n+\tcontinue;\n+      loop_vinfo = (loop_vec_info) loop->aux;\n+      has_mask_store = LOOP_VINFO_HAS_MASK_STORE (loop_vinfo);\n+      delete loop_vinfo;\n+      if (has_mask_store\n+\t  && targetm.vectorize.empty_mask_is_expensive (IFN_MASK_STORE))\n+\toptimize_mask_stores (loop);\n+\n+      auto_bitmap exit_bbs;\n+      /* Perform local CSE, this esp. helps because we emit code for\n+\t predicates that need to be shared for optimal predicate usage.\n+\t However reassoc will re-order them and prevent CSE from working\n+\t as it should.  CSE only the loop body, not the entry.  */\n+      bitmap_set_bit (exit_bbs, single_exit (loop)->dest->index);\n+\n+      edge entry = EDGE_PRED (loop_preheader_edge (loop)->src, 0);\n+      do_rpo_vn (cfun, entry, exit_bbs);\n+\n+      loop->aux = NULL;\n+    }\n+\n+  vect_slp_fini ();\n+\n   return ret;\n }\n "}]}