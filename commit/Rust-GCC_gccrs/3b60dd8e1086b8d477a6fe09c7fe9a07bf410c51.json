{"sha": "3b60dd8e1086b8d477a6fe09c7fe9a07bf410c51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2I2MGRkOGUxMDg2YjhkNDc3YTZmZTA5YzdmZTlhMDdiZjQxMGM1MQ==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@albatross.co.nz", "date": "2001-02-02T00:27:39Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2001-02-02T00:27:39Z"}, "message": "Add support for Java demangling under the v3 ABI:\n\n\t* cp-demangle.c (NAMESPACE_SEPARATOR): New define.\n\t(struct demangling_def): Add `style' field.\n\t(demangling_new): New parameter `style'. Set it in demangling_t.\n\t(demangle_prefix): Use NAMESPACE_SEPARATOR.\n\t(demangle_type_ptr): Don't emit pointer symbol if doing Java output.\n\t(cp_demangle): New parameter `style'. Pass it to demangling_new().\n\t(main): Call cp_demangle with extra parameter.\n\t(java_demangle_v3): New function.\n\t(java_builtin_type_names): New. Table of primitive type names used\n\tfor Java demangling.\n\t(demangle_builtin_type): Look up in java_builtin_type_names if doing\n\tJava output.\n\t* cplus-dem.c (cplus_demangle): Use java_demangle_v3 to do Java\n\tdemangling.\n\t(long_options): Remove obsolete `java' option.\n\t(main): Remove explicit handling of `java' option. Instead, pass style\n\tparameter in cplus_demangle flags as gdb does.\n\t* testsuite/demangle.expected: Add some Java test cases.\n\nFrom-SVN: r39399", "tree": {"sha": "820789e9640a2091af40cb492ec11fc7d9cd143f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/820789e9640a2091af40cb492ec11fc7d9cd143f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b60dd8e1086b8d477a6fe09c7fe9a07bf410c51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b60dd8e1086b8d477a6fe09c7fe9a07bf410c51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b60dd8e1086b8d477a6fe09c7fe9a07bf410c51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b60dd8e1086b8d477a6fe09c7fe9a07bf410c51/comments", "author": null, "committer": null, "parents": [{"sha": "4bae4eb55f43063018e5299274f7da5a0c057247", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bae4eb55f43063018e5299274f7da5a0c057247", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bae4eb55f43063018e5299274f7da5a0c057247"}], "stats": {"total": 254, "additions": 229, "deletions": 25}, "files": [{"sha": "5206aa19550a02eacb71e49a72d740b6fe81dd5c", "filename": "ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b60dd8e1086b8d477a6fe09c7fe9a07bf410c51/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b60dd8e1086b8d477a6fe09c7fe9a07bf410c51/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=3b60dd8e1086b8d477a6fe09c7fe9a07bf410c51", "patch": "@@ -1,3 +1,7 @@\n+2001-01-31  Bryce McKinlay  <bryce@albatross.co.nz>\n+\n+\t* include/demangle.h: Add prototype for java_demangle_v3.\n+\n 2001-01-29  Phil Edwards  <pme@sources.redhat.com>\n \n \t* COPYING.LIB:  Update to LGPL 2.1 from the FSF."}, {"sha": "a3b664b0e7c9145b4776374946c4d777df6e29e0", "filename": "include/demangle.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b60dd8e1086b8d477a6fe09c7fe9a07bf410c51/include%2Fdemangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b60dd8e1086b8d477a6fe09c7fe9a07bf410c51/include%2Fdemangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdemangle.h?ref=3b60dd8e1086b8d477a6fe09c7fe9a07bf410c51", "patch": "@@ -120,8 +120,11 @@ cplus_demangle_set_style PARAMS ((enum demangling_styles style));\n extern enum demangling_styles \n cplus_demangle_name_to_style PARAMS ((const char *name));\n \n-/* V3 ABI demangling entry point, defined in cp-demangle.c.  */\n+/* V3 ABI demangling entry points, defined in cp-demangle.c.  */\n extern char*\n cplus_demangle_v3 PARAMS ((const char* mangled));\n \n+extern char*\n+java_demangle_v3 PARAMS ((const char* mangled));\n+\n #endif\t/* DEMANGLE_H */"}, {"sha": "e74015d5a1ee33c75c2cbc008c759e1e6401d6e7", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b60dd8e1086b8d477a6fe09c7fe9a07bf410c51/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b60dd8e1086b8d477a6fe09c7fe9a07bf410c51/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=3b60dd8e1086b8d477a6fe09c7fe9a07bf410c51", "patch": "@@ -1,3 +1,25 @@\n+2001-01-31  Bryce McKinlay  <bryce@albatross.co.nz>\n+\n+\tAdd support for Java demangling under the v3 ABI:\n+\t* cp-demangle.c (NAMESPACE_SEPARATOR): New define.\n+\t(struct demangling_def): Add `style' field.\n+\t(demangling_new): New parameter `style'. Set it in demangling_t.\n+\t(demangle_prefix): Use NAMESPACE_SEPARATOR.\n+\t(demangle_type_ptr): Don't emit pointer symbol if doing Java output.\n+\t(cp_demangle): New parameter `style'. Pass it to demangling_new().\n+\t(main): Call cp_demangle with extra parameter.\n+\t(java_demangle_v3): New function.\n+\t(java_builtin_type_names): New. Table of primitive type names used\n+\tfor Java demangling.\n+\t(demangle_builtin_type): Look up in java_builtin_type_names if doing\n+\tJava output.\n+\t* cplus-dem.c (cplus_demangle): Use java_demangle_v3 to do Java \n+\tdemangling.\n+\t(long_options): Remove obsolete `java' option.\n+\t(main): Remove explicit handling of `java' option. Instead, pass style\n+\tparameter in cplus_demangle flags as gdb does.\n+\t* testsuite/demangle.expected: Add some Java test cases.\n+\n 2001-01-29  Phil Edwards  <pme@sources.redhat.com>\n \n \t* COPYING.LIB:  Update to LGPL 2.1 from the FSF."}, {"sha": "db34b58b1c5b60ed13f99db7be894871400a0296", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 168, "deletions": 15, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b60dd8e1086b8d477a6fe09c7fe9a07bf410c51/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b60dd8e1086b8d477a6fe09c7fe9a07bf410c51/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=3b60dd8e1086b8d477a6fe09c7fe9a07bf410c51", "patch": "@@ -1,5 +1,5 @@\n /* Demangler for IA64 / g++ V3 ABI.\n-   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n    Written by Alex Samuel <samuel@codesourcery.com>. \n \n    This file is part of GNU CC.\n@@ -68,6 +68,9 @@\n    anonymous namespace.  */\n #define ANONYMOUS_NAMESPACE_PREFIX \"_GLOBAL_\"\n \n+/* Character(s) to use for namespace separation in demangled output */\n+#define NAMESPACE_SEPARATOR (dm->style == DMGL_JAVA ? \".\" : \"::\")\n+\n /* If flag_verbose is zero, some simplifications will be made to the\n    output to make it easier to read and supress details that are\n    generally not of interest to the average C++ programmer.\n@@ -166,6 +169,9 @@ struct demangling_def\n \n   /* The most recently demangled source-name.  */\n   dyn_string_t last_source_name;\n+  \n+  /* Language style to use for demangled output. */\n+  int style;\n };\n \n typedef struct demangling_def *demangling_t;\n@@ -240,7 +246,7 @@ static void template_arg_list_print\n static template_arg_list_t current_template_arg_list\n   PARAMS ((demangling_t));\n static demangling_t demangling_new\n-  PARAMS ((const char *));\n+  PARAMS ((const char *, int));\n static void demangling_delete \n   PARAMS ((demangling_t));\n \n@@ -783,8 +789,9 @@ current_template_arg_list (dm)\n    Returns NULL if allocation fails.  */\n \n static demangling_t\n-demangling_new (name)\n+demangling_new (name, style)\n      const char *name;\n+     int style;\n {\n   demangling_t dm;\n   dm = (demangling_t) malloc (sizeof (struct demangling_def));\n@@ -807,6 +814,7 @@ demangling_new (name)\n       dyn_string_delete (dm->last_source_name);\n       return NULL;\n     }\n+  dm->style = style;\n \n   return dm;\n }\n@@ -918,7 +926,7 @@ static status_t demangle_local_name\n static status_t demangle_discriminator \n   PARAMS ((demangling_t, int));\n static status_t cp_demangle\n-  PARAMS ((const char *, dyn_string_t));\n+  PARAMS ((const char *, dyn_string_t, int));\n #ifdef IN_LIBGCC2\n static status_t cp_demangle_type\n   PARAMS ((const char*, dyn_string_t));\n@@ -1222,7 +1230,7 @@ demangle_prefix (dm, encode_return_type)\n \t{\n \t  /* We have another level of scope qualification.  */\n \t  if (nested)\n-\t    RETURN_IF_ERROR (result_add (dm, \"::\"));\n+\t    RETURN_IF_ERROR (result_add (dm, NAMESPACE_SEPARATOR));\n \t  else\n \t    nested = 1;\n \n@@ -2093,8 +2101,10 @@ demangle_type_ptr (dm, insert_pos, substitution_start)\n       RETURN_IF_ERROR (demangle_type_ptr (dm, insert_pos, \n \t\t\t\t\t  substitution_start));\n       /* Insert an asterisk where we're told to; it doesn't\n-\t necessarily go at the end.  */\n-      RETURN_IF_ERROR (result_insert_char (dm, *insert_pos, '*'));\n+\t necessarily go at the end.  If we're doing Java style output, \n+\t there is no pointer symbol.  */\n+      if (dm->style != DMGL_JAVA)\n+\tRETURN_IF_ERROR (result_insert_char (dm, *insert_pos, '*'));\n       /* The next (outermost) pointer or reference character should go\n \t after this one.  */\n       ++(*insert_pos);\n@@ -2469,6 +2479,39 @@ static const char *const builtin_type_names[26] =\n   \"...\"                       /* z */\n };\n \n+/* Java source names of builtin types.  Types that arn't valid in Java\n+   are also included here - we don't fail if someone attempts to demangle a \n+   C++ symbol in Java style. */\n+static const char *const java_builtin_type_names[26] = \n+{\n+  \"signed char\",                /* a */\n+  \"boolean\", /* C++ \"bool\" */   /* b */\n+  \"byte\", /* C++ \"char\" */      /* c */\n+  \"double\",                     /* d */\n+  \"long double\",                /* e */\n+  \"float\",                      /* f */\n+  \"__float128\",                 /* g */\n+  \"unsigned char\",              /* h */\n+  \"int\",                        /* i */\n+  \"unsigned\",                   /* j */\n+  NULL,                         /* k */\n+  \"long\",                       /* l */\n+  \"unsigned long\",              /* m */\n+  \"__int128\",                   /* n */\n+  \"unsigned __int128\",          /* o */\n+  NULL,                         /* p */\n+  NULL,                         /* q */\n+  NULL,                         /* r */\n+  \"short\",                      /* s */\n+  \"unsigned short\",             /* t */\n+  NULL,                         /* u */\n+  \"void\",                       /* v */\n+  \"char\", /* C++ \"wchar_t\" */   /* w */\n+  \"long\", /* C++ \"long long\" */ /* x */\n+  \"unsigned long long\",         /* y */\n+  \"...\"                         /* z */\n+};\n+\n /* Demangles and emits a <builtin-type>.  \n \n     <builtin-type> ::= v  # void\n@@ -2511,7 +2554,12 @@ demangle_builtin_type (dm)\n     }\n   else if (code >= 'a' && code <= 'z')\n     {\n-      const char *type_name = builtin_type_names[code - 'a'];\n+      const char *type_name;\n+      /* Java uses different names for some built-in types. */\n+      if (dm->style == DMGL_JAVA)\n+        type_name = java_builtin_type_names[code - 'a'];\n+      else\n+        type_name = builtin_type_names[code - 'a'];\n       if (type_name == NULL)\n \treturn \"Unrecognized <builtin-type> code.\";\n \n@@ -3395,16 +3443,17 @@ demangle_discriminator (dm, suppress_first)\n    an error message, and the contents of RESULT are unchanged.  */\n \n static status_t\n-cp_demangle (name, result)\n+cp_demangle (name, result, style)\n      const char *name;\n      dyn_string_t result;\n+     int style;\n {\n   status_t status;\n   int length = strlen (name);\n \n   if (length > 2 && name[0] == '_' && name[1] == 'Z')\n     {\n-      demangling_t dm = demangling_new (name);\n+      demangling_t dm = demangling_new (name, style);\n       if (dm == NULL)\n \treturn STATUS_ALLOCATION_FAILED;\n \n@@ -3551,7 +3600,7 @@ __cxa_demangle (mangled_name, output_buffer, length, status)\n   if (mangled_name[0] == '_' && mangled_name[1] == 'Z')\n     /* MANGLED_NAME apprears to be a function or variable name.\n        Demangle it accordingly.  */\n-    result = cp_demangle (mangled_name, &demangled_name);\n+    result = cp_demangle (mangled_name, &demangled_name, 0);\n   else\n     /* Try to demangled MANGLED_NAME as the name of a type.  */\n     result = cp_demangle_type (mangled_name, &demangled_name);\n@@ -3610,7 +3659,7 @@ cplus_demangle_v3 (mangled)\n   /* Create a dyn_string to hold the demangled name.  */\n   demangled = dyn_string_new (0);\n   /* Attempt the demangling.  */\n-  status = cp_demangle ((char *) mangled, demangled);\n+  status = cp_demangle ((char *) mangled, demangled, 0);\n \n   if (STATUS_NO_ERROR (status))\n     /* Demangling succeeded.  */\n@@ -3634,6 +3683,110 @@ cplus_demangle_v3 (mangled)\n     }\n }\n \n+/* Demangle a Java symbol.  Java uses a subset of the V3 ABI C++ mangling \n+   conventions, but the output formatting is a little different.\n+   This instructs the C++ demangler not to emit pointer characters (\"*\"), and \n+   to use Java's namespace separator symbol (\".\" instead of \"::\").  It then \n+   does an additional pass over the demangled output to replace instances \n+   of JArray<TYPE> with TYPE[].  */\n+\n+char *\n+java_demangle_v3 (mangled)\n+     const char* mangled;\n+{\n+  dyn_string_t demangled;\n+  char *next;\n+  char *end;\n+  int len;\n+  status_t status;\n+  int nesting = 0;\n+  char *cplus_demangled;\n+  char *return_value;\n+    \n+  /* Create a dyn_string to hold the demangled name.  */\n+  demangled = dyn_string_new (0);\n+\n+  /* Attempt the demangling.  */\n+  status = cp_demangle ((char *) mangled, demangled, DMGL_JAVA);\n+\n+  if (STATUS_NO_ERROR (status))\n+    /* Demangling succeeded.  */\n+    {\n+      /* Grab the demangled result from the dyn_string. */\n+      cplus_demangled = dyn_string_release (demangled);\n+    }\n+  else if (status == STATUS_ALLOCATION_FAILED)\n+    {\n+      fprintf (stderr, \"Memory allocation failed.\\n\");\n+      abort ();\n+    }\n+  else\n+    /* Demangling failed.  */\n+    {\n+      dyn_string_delete (demangled);\n+      return NULL;\n+    }\n+  \n+  len = strlen (cplus_demangled);\n+  next = cplus_demangled;\n+  end = next + len;\n+  demangled = NULL;\n+\n+  /* Replace occurances of JArray<TYPE> with TYPE[]. */\n+  while (next < end)\n+    {\n+      char *open_str = strstr (next, \"JArray<\");\n+      char *close_str = NULL;\n+      if (nesting > 0)\n+\tclose_str = strchr (next, '>');\n+    \n+      if (open_str != NULL && (close_str == NULL || close_str > open_str))\n+        {\n+\t  ++nesting;\n+\t  \n+\t  if (!demangled)\n+\t    demangled = dyn_string_new(len);\n+\n+          /* Copy prepending symbols, if any. */\n+\t  if (open_str > next)\n+\t    {\n+\t      open_str[0] = 0;\n+\t      dyn_string_append_cstr (demangled, next);\n+\t    }\t  \n+\t  next = open_str + 7;\n+\t}\n+      else if (close_str != NULL)\n+        {\n+\t  --nesting;\n+\t  \n+          /* Copy prepending type symbol, if any. Squash any spurious \n+\t     whitespace. */\n+\t  if (close_str > next && next[0] != ' ')\n+\t    {\n+\t      close_str[0] = 0;\n+\t      dyn_string_append_cstr (demangled, next);\n+\t    }\n+\t  dyn_string_append_cstr (demangled, \"[]\");\t  \n+\t  next = close_str + 1;\n+\t}\n+      else\n+        {\n+\t  /* There are no more arrays. Copy the rest of the symbol, or\n+\t     simply return the original symbol if no changes were made. */\n+\t  if (next == cplus_demangled)\n+\t    return cplus_demangled;\n+\n+          dyn_string_append_cstr (demangled, next);\n+\t  next = end;\n+\t}\n+    }\n+\n+  free (cplus_demangled);\n+  \n+  return_value = dyn_string_release (demangled);\n+  return return_value;\n+}\n+\n #endif /* IN_LIBGCC2 */\n \n #ifdef STANDALONE_DEMANGLER\n@@ -3771,7 +3924,7 @@ main (argc, argv)\n \t    }\n \n \t  /* Attempt to demangle the name.  */\n-\t  status = cp_demangle (dyn_string_buf (mangled), demangled);\n+\t  status = cp_demangle (dyn_string_buf (mangled), demangled, 0);\n \n \t  /* If the demangling succeeded, great!  Print out the\n \t     demangled version.  */\n@@ -3810,15 +3963,15 @@ main (argc, argv)\n       for (i = optind; i < argc; ++i)\n \t{\n \t  /* Attempt to demangle.  */\n-\t  status = cp_demangle (argv[i], result);\n+\t  status = cp_demangle (argv[i], result, 0);\n \n \t  /* If it worked, print the demangled name.  */\n \t  if (STATUS_NO_ERROR (status))\n \t    printf (\"%s\\n\", dyn_string_buf (result));\n \t  /* Abort on allocaiton failures.  */\n \t  else if (status == STATUS_ALLOCATION_FAILED)\n \t    {\n-\t      fprintf (stderr, \"Memory allocaiton failed.\\n\");\n+\t      fprintf (stderr, \"Memory allocation failed.\\n\");\n \t      abort ();\n \t    }\n \t  /* If not, print the error message to stderr instead.  */"}, {"sha": "d49ec7c7e1dd60601488c03e174867d28194c435", "filename": "libiberty/cplus-dem.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b60dd8e1086b8d477a6fe09c7fe9a07bf410c51/libiberty%2Fcplus-dem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b60dd8e1086b8d477a6fe09c7fe9a07bf410c51/libiberty%2Fcplus-dem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcplus-dem.c?ref=3b60dd8e1086b8d477a6fe09c7fe9a07bf410c51", "patch": "@@ -1,6 +1,6 @@\n /* Demangler for GNU C++\n    Copyright 1989, 1991, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000 Free Software Foundation, Inc.\n+   2000, 2001 Free Software Foundation, Inc.\n    Written by James Clark (jjc@jclark.uucp)\n    Rewritten by Fred Fish (fnf@cygnus.com) for ARM and Lucid demangling\n    Modified by Satish Pai (pai@apollo.hp.com) for HP demangling\n@@ -922,6 +922,13 @@ cplus_demangle (mangled, options)\n \treturn ret;\n     }\n \n+  if (JAVA_DEMANGLING)\n+    {\n+      ret = java_demangle_v3 (mangled);\n+      if (ret)\n+        return ret;\n+    }\n+\n   if (GNAT_DEMANGLING)\n     return ada_demangle(mangled,options);\n \n@@ -4950,7 +4957,6 @@ static struct option long_options[] = {\n   {\"strip-underscores\", no_argument, 0, '_'},\n   {\"format\", required_argument, 0, 's'},\n   {\"help\", no_argument, 0, 'h'},\n-  {\"java\", no_argument, 0, 'j'},\n   {\"no-strip-underscores\", no_argument, 0, 'n'},\n   {\"version\", no_argument, 0, 'v'},\n   {0, no_argument, 0, 0}\n@@ -5044,12 +5050,13 @@ main (argc, argv)\n   char *result;\n   int c;\n   const char *valid_symbols;\n+  enum demangling_styles style;\n \n   program_name = argv[0];\n \n   strip_underscore = prepends_underscore;\n \n-  while ((c = getopt_long (argc, argv, \"_ns:j\", long_options, (int *) 0)) != EOF)\n+  while ((c = getopt_long (argc, argv, \"_ns:\", long_options, (int *) 0)) != EOF)\n     {\n       switch (c)\n \t{\n@@ -5067,13 +5074,8 @@ main (argc, argv)\n \tcase '_':\n \t  strip_underscore = 1;\n \t  break;\n-\tcase 'j':\n-\t  flags |= DMGL_JAVA;\n-\t  break;\n \tcase 's':\n \t  {\n-\t    enum demangling_styles style;\n-\n \t    style = cplus_demangle_name_to_style (optarg);\n \t    if (style == unknown_demangling)\n \t      {\n@@ -5146,7 +5148,7 @@ main (argc, argv)\n \t\tskip_first = i;\n \n \t      mbuffer[i] = 0;\n-\n+\t      flags |= style;\n \t      result = cplus_demangle (mbuffer + skip_first, flags);\n \t      if (result)\n \t\t{"}, {"sha": "4953c7d11032cf598456d29bfc629dab1cf18da8", "filename": "libiberty/testsuite/demangle-expected", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b60dd8e1086b8d477a6fe09c7fe9a07bf410c51/libiberty%2Ftestsuite%2Fdemangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b60dd8e1086b8d477a6fe09c7fe9a07bf410c51/libiberty%2Ftestsuite%2Fdemangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Fdemangle-expected?ref=3b60dd8e1086b8d477a6fe09c7fe9a07bf410c51", "patch": "@@ -2566,3 +2566,23 @@ _27_GLOBAL_.N.__12burst_app_ct.app_instance\n --format=gnu\n _26_GLOBAL_\\$N\\$_tmp_n.iilg4Gya\\$app_instance\n {anonymous}::app_instance\n+#\n+--format=java\n+_ZN4java3awt10ScrollPane7addImplEPNS0_9ComponentEPNS_4lang6ObjectEi\n+java.awt.ScrollPane.addImpl(java.awt.Component, java.lang.Object, int)\n+#\n+--format=java\n+_ZN4java3awt4geom15AffineTransform9getMatrixEP6JArrayIdE\n+java.awt.geom.AffineTransform.getMatrix(double[])\n+#\n+--format=java\n+_ZN23Mangle$Inner$InnerInner3fooEP6JArrayIPS0_IiEEdPS0_IPS0_IPS0_IPS0_IPN4java4lang6StringEEEEEPS0_IPS0_IPN6MangleEEE\n+Mangle$Inner$InnerInner.foo(int[][], double, java.lang.String[][][][], Mangle[][])\n+#\n+--format=java\n+_ZN6JArray1tEP6JArrayIPS_E\n+JArray.t(JArray[])\n+#\n+--format=java\n+_ZN4Prim1iEibcdfwPN4java4lang6StringEsx\n+Prim.i(int, boolean, byte, double, float, char, java.lang.String, short, long)"}]}