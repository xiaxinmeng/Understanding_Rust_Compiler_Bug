{"sha": "4c124b4c6f4e9017f5682cede57bd84c1129da2a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGMxMjRiNGM2ZjRlOTAxN2Y1NjgyY2VkZTU3YmQ4NGMxMTI5ZGEyYQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2004-08-25T21:21:19Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2004-08-25T21:21:19Z"}, "message": "tree-ssa-operands.h (struct ssa_operand_iterator_d): New.\n\n\n2004-08-25  Andrew MacLeod  <amacleod@redhat.com>\n\n\t* tree-ssa-operands.h (struct ssa_operand_iterator_d): New.  SSA operand\n\titerator controlling structure.\n\t(SSA_OP_USE, SSA_OP_DEF, SSA_OP_VUSE, SSA_OP_VMAYUSE, SSA_OP_VMAYDEF,\n\tSSA_OP_VMUSTDEF, SSA_OP_VIRTUAL_USES, SSA_OP_VIRTUAL_DEFS,\n\tSSA_OP_ALL_USES, SSA_OP_ALL_DEFS, SSA_OP_ALL_OPERANDS): New.  Operand\n\titerator flags.\n\t(FOR_EACH_SSA_TREE_OPERAND): New.  Iterate over operands as trees.\n\t(FOR_EACH_SSA_USE_OPERAND): New.  Iterate over operands as uses.\n\t(FOR_EACH_SSA_DEF_OPERAND): New.  Iterate over operands as defs.\n\t(FOR_EACH_SSA_MAYDEF_OPERAND): New.  Iterate over V_MAY_DEFs.\n\t* tree-ssa-operands.c (NULL_DEF_OPERAND_P, NULL_USE_OPERAND_P): New.\n\tEmpty operand pointers.\n\t* tree-flow-inline.h (op_iter_done): New.  Return true if finished.\n\t(op_iter_next_use): New.  Return next use_operand_p.\n\t(op_iter_next_def): New.  Return next def_operand_p.\n\t(op_iter_next_tree): New.  Return next operands as a tree.\n\t(op_iter_init): New.  Initialize an iterator structure.\n\t(op_iter_init_use): New.  Initialize structure and get the first use.\n\t(op_iter_init_def): New.  Initialize structure and get the first def.\n\t(op_iter_init_tree): New.  Initialize structure and get the first tree.\n\t(op_iter_next_maydef): New.  Return next V_MAY_DEF operands.\n\t(op_iter_init_maydef): New.  Initialize structure and get the first\n\tV_MAY_DEF operands.\n\t* tree-cfg.c (tree_duplicate_bb): Use new operand iterator.\n\t* tree-dfa.c (compute_immediate_uses_for_stmt,\n\tredirect_immediate_uses): Use new operand iterator.\n\t(v_may_defs_disappeared_p, v_must_defs_disappeared_p): Delete.\n\t(mark_new_vars_to_rename): Use new operand iterator.  Count virtual\n\toperands instead of using *_disappeared_p routines.\n\t* tree-into-ssa.c (mark_def_sites, ssa_mark_def_sites, rewrite_stmt,\n\tssa_rewrite_stmt): Use new operand iterator.\n\t* tree-outof-ssa.c (check_replaceable, find_replaceable_in_bb,\n\trewrite_trees): Use new operand iterator.\n\t* tree-pretty-print.c (dump_vops): Use new operand iterator.\n\t* tree-sra.c (mark_all_v_defs): Use new operand iterator.\n\t* tree-ssa-alias.c (compute_points_to_and_addr_escape,\n\tdump_points_to_info): Use new operand iterator.\n\t* tree-ssa-ccp.c (cp_lattice_meet, visit_stmt, initialize,\n\treplace_uses_in, replace_vuse_in, likely_value, set_rhs): Use new\n\toperand iterator.\n\t* tree-ssa-dce.c (mark_stmt_if_obviously_necessary,\n\tpropagate_necessity): Use new operand iterator.\n\t* tree-ssa-dom.c (cprop_into_stmt, optimize_stmt): Use operand iterator.\n\t(register_definitions_for_stmt): Use new operand iterator.  Take stmt as\n\ta parameter instead of a stmt_ann_t.\n\t* tree-ssa-live.c (create_ssa_var_map, calculate_live_on_entry,\n\tbuild_tree_conflict_graph): Use new operand iterator.\n\t* tree-ssa-loop-im.c (determine_max_movement, single_reachable_address,\n\trewrite_mem_refs): Use new operand iterator.\n\t* tree-ssa-loop-manip.c (find_uses_to_rename_stmt,\n\tcheck_loop_closed_ssa_use): Use new operand iterator.\n\t* tree-ssa.c (verify_ssa, replace_immediate_uses): Use operand iterator.\n\t* tree-ssanames.c (release_defs): Use new operand iterator.\n\t* tree-vectorizer.c (vect_create_data_ref): Use new operand iterator.\n\nFrom-SVN: r86583", "tree": {"sha": "22414e194e2c3d5262c72554997d72332edaa89c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22414e194e2c3d5262c72554997d72332edaa89c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c124b4c6f4e9017f5682cede57bd84c1129da2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c124b4c6f4e9017f5682cede57bd84c1129da2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c124b4c6f4e9017f5682cede57bd84c1129da2a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c124b4c6f4e9017f5682cede57bd84c1129da2a/comments", "author": null, "committer": null, "parents": [{"sha": "75101febd89c94bf6a9ddca6742879af9044c1c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75101febd89c94bf6a9ddca6742879af9044c1c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75101febd89c94bf6a9ddca6742879af9044c1c4"}], "stats": {"total": 1361, "additions": 509, "deletions": 852}, "files": [{"sha": "7229f5a6e25ffe002110ef187496c437fec4c71d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4c124b4c6f4e9017f5682cede57bd84c1129da2a", "patch": "@@ -1,3 +1,60 @@\n+2004-08-25  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* tree-ssa-operands.h (struct ssa_operand_iterator_d): New.  SSA operand\n+\titerator controlling structure.\n+\t(SSA_OP_USE, SSA_OP_DEF, SSA_OP_VUSE, SSA_OP_VMAYUSE, SSA_OP_VMAYDEF,\n+\tSSA_OP_VMUSTDEF, SSA_OP_VIRTUAL_USES, SSA_OP_VIRTUAL_DEFS,\n+\tSSA_OP_ALL_USES, SSA_OP_ALL_DEFS, SSA_OP_ALL_OPERANDS): New.  Operand\n+\titerator flags.\n+\t(FOR_EACH_SSA_TREE_OPERAND): New.  Iterate over operands as trees.\n+\t(FOR_EACH_SSA_USE_OPERAND): New.  Iterate over operands as uses.\n+\t(FOR_EACH_SSA_DEF_OPERAND): New.  Iterate over operands as defs.\n+\t(FOR_EACH_SSA_MAYDEF_OPERAND): New.  Iterate over V_MAY_DEFs.\n+\t* tree-ssa-operands.c (NULL_DEF_OPERAND_P, NULL_USE_OPERAND_P): New. \n+\tEmpty operand pointers.\n+\t* tree-flow-inline.h (op_iter_done): New.  Return true if finished.\n+\t(op_iter_next_use): New.  Return next use_operand_p.\n+\t(op_iter_next_def): New.  Return next def_operand_p.\n+\t(op_iter_next_tree): New.  Return next operands as a tree.\n+\t(op_iter_init): New.  Initialize an iterator structure.\n+\t(op_iter_init_use): New.  Initialize structure and get the first use.\n+\t(op_iter_init_def): New.  Initialize structure and get the first def.\n+\t(op_iter_init_tree): New.  Initialize structure and get the first tree.\n+\t(op_iter_next_maydef): New.  Return next V_MAY_DEF operands.\n+\t(op_iter_init_maydef): New.  Initialize structure and get the first \n+\tV_MAY_DEF operands.\n+\t* tree-cfg.c (tree_duplicate_bb): Use new operand iterator.\n+\t* tree-dfa.c (compute_immediate_uses_for_stmt, \n+\tredirect_immediate_uses): Use new operand iterator.\n+\t(v_may_defs_disappeared_p, v_must_defs_disappeared_p): Delete.\n+\t(mark_new_vars_to_rename): Use new operand iterator.  Count virtual\n+\toperands instead of using *_disappeared_p routines.\n+\t* tree-into-ssa.c (mark_def_sites, ssa_mark_def_sites, rewrite_stmt,\n+\tssa_rewrite_stmt): Use new operand iterator.\n+\t* tree-outof-ssa.c (check_replaceable, find_replaceable_in_bb,\n+\trewrite_trees): Use new operand iterator.\n+\t* tree-pretty-print.c (dump_vops): Use new operand iterator.\n+\t* tree-sra.c (mark_all_v_defs): Use new operand iterator.\n+\t* tree-ssa-alias.c (compute_points_to_and_addr_escape, \n+\tdump_points_to_info): Use new operand iterator.\n+\t* tree-ssa-ccp.c (cp_lattice_meet, visit_stmt, initialize, \n+\treplace_uses_in, replace_vuse_in, likely_value, set_rhs): Use new \n+\toperand iterator.\n+\t* tree-ssa-dce.c (mark_stmt_if_obviously_necessary, \n+\tpropagate_necessity): Use new operand iterator.\n+\t* tree-ssa-dom.c (cprop_into_stmt, optimize_stmt): Use operand iterator.\n+\t(register_definitions_for_stmt): Use new operand iterator.  Take stmt as\n+\ta parameter instead of a stmt_ann_t.\n+\t* tree-ssa-live.c (create_ssa_var_map, calculate_live_on_entry,\n+\tbuild_tree_conflict_graph): Use new operand iterator.\n+\t* tree-ssa-loop-im.c (determine_max_movement, single_reachable_address,\n+\trewrite_mem_refs): Use new operand iterator.\n+\t* tree-ssa-loop-manip.c (find_uses_to_rename_stmt, \n+\tcheck_loop_closed_ssa_use): Use new operand iterator.\n+\t* tree-ssa.c (verify_ssa, replace_immediate_uses): Use operand iterator.\n+\t* tree-ssanames.c (release_defs): Use new operand iterator.\n+\t* tree-vectorizer.c (vect_create_data_ref): Use new operand iterator.\n+\n 2004-08-25  Adam Nemet  <anemet@lnxw.com>\n \n \t* tlink.c (initial_cwd): New variable."}, {"sha": "dab912550d61d3813c96bc50dc3a917c334ae197", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=4c124b4c6f4e9017f5682cede57bd84c1129da2a", "patch": "@@ -4245,11 +4245,8 @@ tree_duplicate_bb (basic_block bb)\n {\n   basic_block new_bb;\n   block_stmt_iterator bsi, bsi_tgt;\n-  tree phi;\n-  def_optype defs;\n-  v_may_def_optype v_may_defs;\n-  v_must_def_optype v_must_defs;\n-  unsigned j;\n+  tree phi, val;\n+  ssa_op_iter op_iter;\n \n   new_bb = create_empty_bb (EXIT_BLOCK_PTR->prev_bb);\n \n@@ -4270,17 +4267,8 @@ tree_duplicate_bb (basic_block bb)\n       /* Record the definitions.  */\n       get_stmt_operands (stmt);\n \n-      defs = STMT_DEF_OPS (stmt);\n-      for (j = 0; j < NUM_DEFS (defs); j++)\n-\tmark_for_rewrite (DEF_OP (defs, j));\n-\n-      v_may_defs = STMT_V_MAY_DEF_OPS (stmt);\n-      for (j = 0; j < NUM_V_MAY_DEFS (v_may_defs); j++)\n-\tmark_for_rewrite (V_MAY_DEF_RESULT (v_may_defs, j));\n-\n-      v_must_defs = STMT_V_MUST_DEF_OPS (stmt);\n-      for (j = 0; j < NUM_V_MUST_DEFS (v_must_defs); j++)\n-\tmark_for_rewrite (V_MUST_DEF_OP (v_must_defs, j));\n+      FOR_EACH_SSA_TREE_OPERAND (val, stmt, op_iter, SSA_OP_ALL_DEFS)\n+\tmark_for_rewrite (val);\n \n       copy = unshare_expr (stmt);\n "}, {"sha": "8e7dec5825ca9da5b97750582adc2ccdeff30f5d", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 29, "deletions": 161, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=4c124b4c6f4e9017f5682cede57bd84c1129da2a", "patch": "@@ -270,11 +270,8 @@ compute_immediate_uses_for_phi (tree phi, bool (*calc_for)(tree))\n static void\n compute_immediate_uses_for_stmt (tree stmt, int flags, bool (*calc_for)(tree))\n {\n-  size_t i;\n-  use_optype uses;\n-  vuse_optype vuses;\n-  v_may_def_optype v_may_defs;\n-  stmt_ann_t ann;\n+  tree use;\n+  ssa_op_iter iter;\n \n #ifdef ENABLE_CHECKING\n   /* PHI nodes are handled elsewhere.  */\n@@ -283,13 +280,10 @@ compute_immediate_uses_for_stmt (tree stmt, int flags, bool (*calc_for)(tree))\n #endif\n \n   /* Look at USE_OPS or VUSE_OPS according to FLAGS.  */\n-  ann = stmt_ann (stmt);\n   if (flags & TDFA_USE_OPS)\n     {\n-      uses = USE_OPS (ann);\n-      for (i = 0; i < NUM_USES (uses); i++)\n+      FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n \t{\n-\t  tree use = USE_OP (uses, i);\n \t  tree imm_stmt = SSA_NAME_DEF_STMT (use);\n \t  if (!IS_EMPTY_STMT (imm_stmt) && (!calc_for || calc_for (use)))\n \t    add_immediate_use (imm_stmt, stmt);\n@@ -298,21 +292,10 @@ compute_immediate_uses_for_stmt (tree stmt, int flags, bool (*calc_for)(tree))\n \n   if (flags & TDFA_USE_VOPS)\n     {\n-      vuses = VUSE_OPS (ann);\n-      for (i = 0; i < NUM_VUSES (vuses); i++)\n+      FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_VIRTUAL_USES)\n \t{\n-\t  tree vuse = VUSE_OP (vuses, i);\n-\t  tree imm_rdef_stmt = SSA_NAME_DEF_STMT (vuse);\n-\t  if (!IS_EMPTY_STMT (imm_rdef_stmt) && (!calc_for || calc_for (vuse)))\n-\t    add_immediate_use (imm_rdef_stmt, stmt);\n-\t}\n-\n-      v_may_defs = V_MAY_DEF_OPS (ann);\n-      for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n-\t{\n-\t  tree vuse = V_MAY_DEF_OP (v_may_defs, i);\n-\t  tree imm_rdef_stmt = SSA_NAME_DEF_STMT (vuse);\n-\t  if (!IS_EMPTY_STMT (imm_rdef_stmt) && (!calc_for || calc_for (vuse)))\n+\t  tree imm_rdef_stmt = SSA_NAME_DEF_STMT (use);\n+\t  if (!IS_EMPTY_STMT (imm_rdef_stmt) && (!calc_for || calc_for (use)))\n \t    add_immediate_use (imm_rdef_stmt, stmt);\n \t}\n     }\n@@ -380,21 +363,11 @@ redirect_immediate_use (tree use, tree old, tree new)\n void\n redirect_immediate_uses (tree old, tree new)\n {\n-  stmt_ann_t ann = get_stmt_ann (old);\n-  use_optype uses = USE_OPS (ann);\n-  vuse_optype vuses = VUSE_OPS (ann);\n-  v_may_def_optype v_may_defs = V_MAY_DEF_OPS (ann);\n-  unsigned int i;\n+  ssa_op_iter iter;\n+  tree val;\n \n-  /* Look at USE_OPS or VUSE_OPS according to FLAGS.  */\n-  for (i = 0; i < NUM_USES (uses); i++)\n-    redirect_immediate_use (USE_OP (uses, i), old, new);\n-\n-  for (i = 0; i < NUM_VUSES (vuses); i++)\n-    redirect_immediate_use (VUSE_OP (vuses, i), old, new);\n-\n-  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n-    redirect_immediate_use (V_MAY_DEF_OP (v_may_defs, i), old, new);\n+  FOR_EACH_SSA_TREE_OPERAND (val, old, iter, SSA_OP_ALL_USES)\n+    redirect_immediate_use (val, old, new);\n }\n \n \n@@ -956,66 +929,19 @@ add_referenced_tmp_var (tree var)\n   add_referenced_var (var, NULL);\n }\n \n-/* Return true if V_MAY_DEFS_AFTER contains fewer entries than\n-   V_MAY_DEFS_BEFORE. Note that this assumes that both varrays\n-   are V_MAY_DEF operands for the same statement.  */\n-\n-static inline bool\n-v_may_defs_disappeared_p (v_may_def_optype v_may_defs_before,\n-                          v_may_def_optype v_may_defs_after)\n-{\n-  /* If there was nothing before, nothing could've disappeared.  */\n-  if (v_may_defs_before == NULL)\n-    return false;\n-\n-  /* All/some of them gone.  */\n-  if (v_may_defs_after == NULL\n-      || NUM_V_MAY_DEFS (v_may_defs_before) >\n-         NUM_V_MAY_DEFS (v_may_defs_after))\n-    return true;\n-\n-  return false;\n-}\n-\n-/* Return true if V_MUST_DEFS_AFTER contains fewer entries than\n-   V_MUST_DEFS_BEFORE. Note that this assumes that both varrays\n-   are V_MUST_DEF operands for the same statement.  */\n-\n-static inline bool\n-v_must_defs_disappeared_p (v_must_def_optype v_must_defs_before,\n-                           v_must_def_optype v_must_defs_after)\n-{\n-  /* If there was nothing before, nothing could've disappeared.  */\n-  if (v_must_defs_before == NULL)\n-    return false;\n-\n-  /* All/some of them gone.  */\n-  if (v_must_defs_after == NULL\n-      || NUM_V_MUST_DEFS (v_must_defs_before) >\n-         NUM_V_MUST_DEFS (v_must_defs_after))\n-    return true;\n-\n-  return false;\n-}\n-\n \n /* Add all the non-SSA variables found in STMT's operands to the bitmap\n    VARS_TO_RENAME.  */\n \n void\n mark_new_vars_to_rename (tree stmt, bitmap vars_to_rename)\n {\n-  def_optype defs;\n-  use_optype uses;\n-  v_may_def_optype v_may_defs;\n-  vuse_optype vuses;\n-  v_must_def_optype v_must_defs;\n-  size_t i;\n+  ssa_op_iter iter;\n+  tree val;\n   bitmap vars_in_vops_to_rename;\n   bool found_exposed_symbol = false;\n-  v_may_def_optype v_may_defs_before, v_may_defs_after;\n-  v_must_def_optype v_must_defs_before, v_must_defs_after;\n-  stmt_ann_t ann;\n+  int v_may_defs_before, v_may_defs_after;\n+  int v_must_defs_before, v_must_defs_after;\n \n   vars_in_vops_to_rename = BITMAP_XMALLOC ();\n \n@@ -1028,91 +954,33 @@ mark_new_vars_to_rename (tree stmt, bitmap vars_to_rename)\n      We flag them in a separate bitmap because we don't really want to\n      rename them if there are not any newly exposed symbols in the\n      statement operands.  */\n-  ann = stmt_ann (stmt);\n-  v_may_defs_before = v_may_defs = V_MAY_DEF_OPS (ann);\n-  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n-    {\n-      tree var = V_MAY_DEF_RESULT (v_may_defs, i);\n-      if (!DECL_P (var))\n-\tvar = SSA_NAME_VAR (var);\n-      bitmap_set_bit (vars_in_vops_to_rename, var_ann (var)->uid);\n-    }\n+  v_may_defs_before = NUM_V_MAY_DEFS (STMT_V_MAY_DEF_OPS (stmt));\n+  v_must_defs_before = NUM_V_MUST_DEFS (STMT_V_MUST_DEF_OPS (stmt));\n \n-  vuses = VUSE_OPS (ann);\n-  for (i = 0; i < NUM_VUSES (vuses); i++)\n+  FOR_EACH_SSA_TREE_OPERAND (val, stmt, iter, \n+\t\t\t     SSA_OP_VMAYDEF | SSA_OP_VUSE | SSA_OP_VMUSTDEF)\n     {\n-      tree var = VUSE_OP (vuses, i);\n-      if (!DECL_P (var))\n-\tvar = SSA_NAME_VAR (var);\n-      bitmap_set_bit (vars_in_vops_to_rename, var_ann (var)->uid);\n-    }\n-\n-  v_must_defs_before = v_must_defs = V_MUST_DEF_OPS (ann);\n-  for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n-    {\n-      tree var = V_MUST_DEF_OP (v_must_defs, i);\n-      if (!DECL_P (var))\n-\tvar = SSA_NAME_VAR (var);\n-      bitmap_set_bit (vars_in_vops_to_rename, var_ann (var)->uid);\n+      if (!DECL_P (val))\n+\tval = SSA_NAME_VAR (val);\n+      bitmap_set_bit (vars_in_vops_to_rename, var_ann (val)->uid);\n     }\n \n   /* Now force an operand re-scan on the statement and mark any newly\n      exposed variables.  */\n   modify_stmt (stmt);\n   get_stmt_operands (stmt);\n \n-  defs = DEF_OPS (ann);\n-  for (i = 0; i < NUM_DEFS (defs); i++)\n-    {\n-      tree var = DEF_OP (defs, i);\n-      if (DECL_P (var))\n-\t{\n-\t  found_exposed_symbol = true;\n-\t  bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n-\t}\n-    }\n+  v_may_defs_after = NUM_V_MAY_DEFS (STMT_V_MAY_DEF_OPS (stmt));\n+  v_must_defs_after = NUM_V_MUST_DEFS (STMT_V_MUST_DEF_OPS (stmt));\n \n-  uses = USE_OPS (ann);\n-  for (i = 0; i < NUM_USES (uses); i++)\n-    {\n-      tree var = USE_OP (uses, i);\n-      if (DECL_P (var))\n-\t{\n-\t  found_exposed_symbol = true;\n-\t  bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n-\t}\n-    }\n-\n-  v_may_defs_after = v_may_defs = V_MAY_DEF_OPS (ann);\n-  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n-    {\n-      tree var = V_MAY_DEF_RESULT (v_may_defs, i);\n-      if (DECL_P (var))\n-\t{\n-\t  found_exposed_symbol = true;\n-\t  bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n-\t}\n-    }\n-\n-  vuses = VUSE_OPS (ann);\n-  for (i = 0; i < NUM_VUSES (vuses); i++)\n-    {\n-      tree var = VUSE_OP (vuses, i);\n-      if (DECL_P (var))\n-\t{\n-\t  found_exposed_symbol = true;\n-\t  bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n-\t}\n-    }\n+  FOR_EACH_SSA_TREE_OPERAND (val, stmt, iter, \n+\t\t\t     SSA_OP_VMAYDEF | SSA_OP_VUSE | SSA_OP_VMUSTDEF)\n \n-  v_must_defs_after = v_must_defs = V_MUST_DEF_OPS (ann);\n-  for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n     {\n-      tree var = V_MUST_DEF_OP (v_must_defs, i);\n-      if (DECL_P (var))\n+      if (DECL_P (val))\n \t{\n \t  found_exposed_symbol = true;\n-\t  bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n+\t  bitmap_set_bit (vars_to_rename, var_ann (val)->uid);\n \t}\n     }\n \n@@ -1122,8 +990,8 @@ mark_new_vars_to_rename (tree stmt, bitmap vars_to_rename)\n      vanishing VDEFs because in those cases, the names that were formerly\n      generated by this statement are not going to be available anymore.  */\n   if (found_exposed_symbol\n-      || v_may_defs_disappeared_p (v_may_defs_before, v_may_defs_after)\n-      || v_must_defs_disappeared_p (v_must_defs_before, v_must_defs_after))\n+      || v_may_defs_before > v_may_defs_after\n+      || v_must_defs_before > v_must_defs_after)\n     bitmap_a_or_b (vars_to_rename, vars_to_rename, vars_in_vops_to_rename);\n \n   BITMAP_XFREE (vars_in_vops_to_rename);"}, {"sha": "423088c9e51f5800c83b2d2766ae21c88ec8b8fa", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=4c124b4c6f4e9017f5682cede57bd84c1129da2a", "patch": "@@ -673,4 +673,176 @@ get_tree_ann (tree t)\n   return (ann) ? ann : create_tree_ann (t);\n }\n \n+/*  -----------------------------------------------------------------------  */\n+\n+/* The following set of routines are used to iterator over various type of\n+   SSA operands.  */\n+\n+/* Return true if PTR is finished iterating.  */\n+static inline bool\n+op_iter_done (ssa_op_iter *ptr)\n+{\n+  return ptr->done;\n+}\n+\n+/* Get the next iterator use value for PTR.  */\n+static inline use_operand_p\n+op_iter_next_use (ssa_op_iter *ptr)\n+{\n+  if (ptr->use_i < ptr->num_use)\n+    {\n+      return USE_OP_PTR (ptr->ops->use_ops, (ptr->use_i)++);\n+    }\n+  if (ptr->vuse_i < ptr->num_vuse)\n+    {\n+      return VUSE_OP_PTR (ptr->ops->vuse_ops, (ptr->vuse_i)++);\n+    }\n+  if (ptr->v_mayu_i < ptr->num_v_mayu)\n+    {\n+      return V_MAY_DEF_OP_PTR (ptr->ops->v_may_def_ops,\n+\t\t\t\t       (ptr->v_mayu_i)++);\n+    }\n+  ptr->done = true;\n+  return NULL_USE_OPERAND_P;\n+}\n+\n+/* Get the next iterator def value for PTR.  */\n+static inline def_operand_p\n+op_iter_next_def (ssa_op_iter *ptr)\n+{\n+  if (ptr->def_i < ptr->num_def)\n+    {\n+      return DEF_OP_PTR (ptr->ops->def_ops, (ptr->def_i)++);\n+    }\n+  if (ptr->v_must_i < ptr->num_v_must)\n+    {\n+      return V_MUST_DEF_OP_PTR (ptr->ops->v_must_def_ops, \n+\t\t\t\t\t(ptr->v_must_i)++);\n+    }\n+  if (ptr->v_mayd_i < ptr->num_v_mayd)\n+    {\n+      return V_MAY_DEF_RESULT_PTR (ptr->ops->v_may_def_ops,\n+\t\t\t\t\t   (ptr->v_mayd_i)++);\n+    }\n+  ptr->done = true;\n+  return NULL_DEF_OPERAND_P;\n+}\n+\n+/* Get the next iterator tree value for PTR.  */\n+static inline tree\n+op_iter_next_tree (ssa_op_iter *ptr)\n+{\n+  if (ptr->use_i < ptr->num_use)\n+    {\n+      return USE_OP (ptr->ops->use_ops, (ptr->use_i)++);\n+    }\n+  if (ptr->vuse_i < ptr->num_vuse)\n+    {\n+      return VUSE_OP (ptr->ops->vuse_ops, (ptr->vuse_i)++);\n+    }\n+  if (ptr->v_mayu_i < ptr->num_v_mayu)\n+    {\n+      return V_MAY_DEF_OP (ptr->ops->v_may_def_ops, (ptr->v_mayu_i)++);\n+    }\n+  if (ptr->def_i < ptr->num_def)\n+    {\n+      return DEF_OP (ptr->ops->def_ops, (ptr->def_i)++);\n+    }\n+  if (ptr->v_must_i < ptr->num_v_must)\n+    {\n+      return V_MUST_DEF_OP (ptr->ops->v_must_def_ops, \n+\t\t\t\t\t(ptr->v_must_i)++);\n+    }\n+  if (ptr->v_mayd_i < ptr->num_v_mayd)\n+    {\n+      return V_MAY_DEF_RESULT (ptr->ops->v_may_def_ops,\n+\t\t\t\t\t   (ptr->v_mayd_i)++);\n+    }\n+  ptr->done = true;\n+  return NULL;\n+}\n+\n+/* Initialize the iterator PTR to the virtual defs in STMT.  */\n+static inline void\n+op_iter_init (ssa_op_iter *ptr, tree stmt, int flags)\n+{\n+  stmt_operands_p ops;\n+  stmt_ann_t ann = get_stmt_ann (stmt);\n+\n+  ops = &(ann->operands);\n+  ptr->done = false;\n+  ptr->ops = ops;\n+  ptr->num_def = (flags & SSA_OP_DEF) ? NUM_DEFS (ops->def_ops) : 0;\n+  ptr->num_use = (flags & SSA_OP_USE) ? NUM_USES (ops->use_ops) : 0;\n+  ptr->num_vuse = (flags & SSA_OP_VUSE) ? NUM_VUSES (ops->vuse_ops) : 0;\n+  ptr->num_v_mayu = (flags & SSA_OP_VMAYUSE)\n+\t\t     ?  NUM_V_MAY_DEFS (ops->v_may_def_ops) : 0;\n+  ptr->num_v_mayd = (flags & SSA_OP_VMAYDEF) \n+\t\t     ?  NUM_V_MAY_DEFS (ops->v_may_def_ops) : 0;\n+  ptr->num_v_must = (flags & SSA_OP_VMUSTDEF) \n+\t\t     ? NUM_V_MUST_DEFS (ops->v_must_def_ops) : 0;\n+  ptr->def_i = 0;\n+  ptr->use_i = 0;\n+  ptr->vuse_i = 0;\n+  ptr->v_mayu_i = 0;\n+  ptr->v_mayd_i = 0;\n+  ptr->v_must_i = 0;\n+}\n+\n+/* Initialize iterator PTR to the use operands in STMT based on FLAGS. Return\n+   the first use.  */\n+static inline use_operand_p\n+op_iter_init_use (ssa_op_iter *ptr, tree stmt, int flags)\n+{\n+  op_iter_init (ptr, stmt, flags);\n+  return op_iter_next_use (ptr);\n+}\n+\n+/* Initialize iterator PTR to the def operands in STMT based on FLAGS. Return\n+   the first def.  */\n+static inline def_operand_p\n+op_iter_init_def (ssa_op_iter *ptr, tree stmt, int flags)\n+{\n+  op_iter_init (ptr, stmt, flags);\n+  return op_iter_next_def (ptr);\n+}\n+\n+/* Initialize iterator PTR to the operands in STMT based on FLAGS. Return\n+   the first operand as a tree.  */\n+static inline tree\n+op_iter_init_tree (ssa_op_iter *ptr, tree stmt, int flags)\n+{\n+  op_iter_init (ptr, stmt, flags);\n+  return op_iter_next_tree (ptr);\n+}\n+\n+/* Get the next iterator maydef value for PTR, returning the maydef values in\n+   USE and DEF.  */\n+static inline void\n+op_iter_next_maydef (use_operand_p *use, def_operand_p *def, ssa_op_iter *ptr)\n+{\n+  if (ptr->v_mayu_i < ptr->num_v_mayu)\n+    {\n+      *def = V_MAY_DEF_RESULT_PTR (ptr->ops->v_may_def_ops, ptr->v_mayu_i);\n+      *use = V_MAY_DEF_OP_PTR (ptr->ops->v_may_def_ops, (ptr->v_mayu_i)++);\n+      return;\n+    }\n+  else\n+    {\n+      *def = NULL_DEF_OPERAND_P;\n+      *use = NULL_USE_OPERAND_P;\n+    }\n+  ptr->done = true;\n+  return;\n+}\n+\n+/* Initialize iterator PTR to the operands in STMT.  Return the first operands\n+   in USE and DEF.  */\n+static inline void\n+op_iter_init_maydef (ssa_op_iter *ptr, tree stmt, use_operand_p *use, \n+\t\t     def_operand_p *def)\n+{\n+  op_iter_init (ptr, stmt, SSA_OP_VMAYUSE);\n+  op_iter_next_maydef (use, def, ptr);\n+}\n #endif /* _TREE_FLOW_INLINE_H  */"}, {"sha": "6387b7fadd560b903e140d1c72279341be08b18b", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 26, "deletions": 217, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=4c124b4c6f4e9017f5682cede57bd84c1129da2a", "patch": "@@ -342,91 +342,57 @@ mark_def_sites (struct dom_walk_data *walk_data,\n {\n   struct mark_def_sites_global_data *gd = walk_data->global_data;\n   sbitmap kills = gd->kills;\n-  v_may_def_optype v_may_defs;\n-  v_must_def_optype v_must_defs;\n-  vuse_optype vuses;\n-  def_optype defs;\n-  use_optype uses;\n-  size_t i, uid;\n-  tree stmt;\n-  stmt_ann_t ann;\n+  size_t uid;\n+  tree stmt, def;\n+  use_operand_p use_p;\n+  def_operand_p def_p;\n+  ssa_op_iter iter;\n \n   /* Mark all the blocks that have definitions for each variable in the\n      VARS_TO_RENAME bitmap.  */\n   stmt = bsi_stmt (bsi);\n   get_stmt_operands (stmt);\n-  ann = stmt_ann (stmt);\n \n   /* If a variable is used before being set, then the variable is live\n      across a block boundary, so mark it live-on-entry to BB.  */\n-  uses = USE_OPS (ann);\n-  for (i = 0; i < NUM_USES (uses); i++)\n-    {\n-      use_operand_p use_p = USE_OP_PTR (uses, i);\n \n-      if (prepare_use_operand_for_rename (use_p, &uid)\n-\t  && !TEST_BIT (kills, uid))\n-\tset_livein_block (USE_FROM_PTR (use_p), bb);\n-    }\n-\t  \n-  /* Similarly for virtual uses.  */\n-  vuses = VUSE_OPS (ann);\n-  for (i = 0; i < NUM_VUSES (vuses); i++)\n+  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE | SSA_OP_VUSE)\n     {\n-      use_operand_p use_p = VUSE_OP_PTR (vuses, i);\n-\n       if (prepare_use_operand_for_rename (use_p, &uid)\n \t  && !TEST_BIT (kills, uid))\n \tset_livein_block (USE_FROM_PTR (use_p), bb);\n     }\n-\n+\t  \n   /* Note that virtual definitions are irrelevant for computing KILLS\n      because a V_MAY_DEF does not constitute a killing definition of the\n      variable.  However, the operand of a virtual definitions is a use\n      of the variable, so it may cause the variable to be considered\n      live-on-entry.  */\n-  v_may_defs = V_MAY_DEF_OPS (ann);\n-  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n+\n+  FOR_EACH_SSA_MAYDEF_OPERAND (def_p, use_p, stmt, iter)\n     {\n-      use_operand_p use_p = V_MAY_DEF_OP_PTR (v_may_defs, i);\n       if (prepare_use_operand_for_rename (use_p, &uid))\n \t{\n \t  /* If we do not already have an SSA_NAME for our destination,\n \t     then set the destination to the source.  */\n-\t  if (TREE_CODE (V_MAY_DEF_RESULT (v_may_defs, i)) != SSA_NAME)\n-\t    SET_V_MAY_DEF_RESULT (v_may_defs, i, USE_FROM_PTR (use_p));\n+\t  if (TREE_CODE (DEF_FROM_PTR (def_p)) != SSA_NAME)\n+\t    SET_DEF (def_p, USE_FROM_PTR (use_p));\n \t    \n           set_livein_block (USE_FROM_PTR (use_p), bb);\n-\t  set_def_block (V_MAY_DEF_RESULT (v_may_defs, i), bb, false, false);\n+\t  set_def_block (DEF_FROM_PTR (def_p), bb, false, false);\n \t}\n     }\n \n   /* Now process the virtual must-defs made by this statement.  */\n-  v_must_defs = V_MUST_DEF_OPS (ann);\n-  for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n+  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_DEF | SSA_OP_VMUSTDEF)\n     {\n-      tree def = V_MUST_DEF_OP (v_must_defs, i);\n-\n       if (prepare_def_operand_for_rename (def, &uid))\n \t{\n \t  set_def_block (def, bb, false, false);\n \t  SET_BIT (kills, uid);\n \t}\n     }\n \n-  /* Now process the definition made by this statement.  Mark the\n-     variables in KILLS.  */\n-  defs = DEF_OPS (ann);\n-  for (i = 0; i < NUM_DEFS (defs); i++)\n-    {\n-      tree def = DEF_OP (defs, i);\n-\n-      if (prepare_def_operand_for_rename (def, &uid))\n-\t{\n-\t  set_def_block (def, bb, false, false);\n-\t  SET_BIT (kills, uid);\n-\t}\n-    }\n }\n \n /* Ditto, but works over ssa names.  */\n@@ -438,89 +404,30 @@ ssa_mark_def_sites (struct dom_walk_data *walk_data,\n {\n   struct mark_def_sites_global_data *gd = walk_data->global_data;\n   sbitmap kills = gd->kills;\n-  v_may_def_optype v_may_defs;\n-  v_must_def_optype v_must_defs;\n-  vuse_optype vuses;\n-  def_optype defs;\n-  use_optype uses;\n-  size_t i, uid, def_uid;\n+  size_t uid, def_uid;\n   tree stmt, use, def;\n-  stmt_ann_t ann;\n+  ssa_op_iter iter;\n \n   /* Mark all the blocks that have definitions for each variable in the\n      names_to_rename bitmap.  */\n   stmt = bsi_stmt (bsi);\n   get_stmt_operands (stmt);\n-  ann = stmt_ann (stmt);\n \n   /* If a variable is used before being set, then the variable is live\n      across a block boundary, so mark it live-on-entry to BB.  */\n-  uses = USE_OPS (ann);\n-  for (i = 0; i < NUM_USES (uses); i++)\n+  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_ALL_USES)\n     {\n-      use = USE_OP (uses, i);\n       uid = SSA_NAME_VERSION (use);\n \n       if (TEST_BIT (gd->names_to_rename, uid)\n \t  && !TEST_BIT (kills, uid))\n \tset_livein_block (use, bb);\n     }\n \t  \n-  /* Similarly for virtual uses.  */\n-  vuses = VUSE_OPS (ann);\n-  for (i = 0; i < NUM_VUSES (vuses); i++)\n-    {\n-      use = VUSE_OP (vuses, i);\n-      uid = SSA_NAME_VERSION (use);\n-\n-      if (TEST_BIT (gd->names_to_rename, uid)\n-\t  && !TEST_BIT (kills, uid))\n-\tset_livein_block (use, bb);\n-    }\n-\n-  v_may_defs = V_MAY_DEF_OPS (ann);\n-  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n-    {\n-      use = V_MAY_DEF_OP (v_may_defs, i);\n-      uid = SSA_NAME_VERSION (use);\n-\n-      if (TEST_BIT (gd->names_to_rename, uid)\n-\t  && !TEST_BIT (kills, uid))\n-\tset_livein_block (use, bb);\n-    }\n-\n   /* Now process the definition made by this statement.  Mark the\n      variables in KILLS.  */\n-  defs = DEF_OPS (ann);\n-  for (i = 0; i < NUM_DEFS (defs); i++)\n-    {\n-      def = DEF_OP (defs, i);\n-      def_uid = SSA_NAME_VERSION (def);\n-\n-      if (TEST_BIT (gd->names_to_rename, def_uid))\n-\t{\n-\t  set_def_block (def, bb, false, true);\n-\t  SET_BIT (kills, def_uid);\n-\t}\n-    }\n-\n-  v_may_defs = V_MAY_DEF_OPS (ann);\n-  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n-    {\n-      def = V_MAY_DEF_RESULT (v_may_defs, i);\n-      def_uid = SSA_NAME_VERSION (def);\n-\n-      if (TEST_BIT (gd->names_to_rename, def_uid))\n-\t{\n-\t  set_def_block (def, bb, false, true);\n-\t  SET_BIT (kills, def_uid);\n-\t}\n-    }\n-\n-  v_must_defs = V_MUST_DEF_OPS (ann);\n-  for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n+  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_ALL_DEFS)\n     {\n-      def = V_MUST_DEF_OP (v_must_defs, i);\n       def_uid = SSA_NAME_VERSION (def);\n \n       if (TEST_BIT (gd->names_to_rename, def_uid))\n@@ -1138,14 +1045,11 @@ rewrite_stmt (struct dom_walk_data *walk_data,\n \t      basic_block bb ATTRIBUTE_UNUSED,\n \t      block_stmt_iterator si)\n {\n-  size_t i;\n   stmt_ann_t ann;\n   tree stmt;\n-  vuse_optype vuses;\n-  v_may_def_optype v_may_defs;\n-  v_must_def_optype v_must_defs;\n-  def_optype defs;\n-  use_optype uses;\n+  use_operand_p use_p;\n+  def_operand_p def_p;\n+  ssa_op_iter iter;\n   struct rewrite_block_data *bd;\n \n   bd = VARRAY_TOP_GENERIC_PTR (walk_data->block_data_stack);\n@@ -1167,62 +1071,20 @@ rewrite_stmt (struct dom_walk_data *walk_data,\n     abort ();\n #endif\n \n-  defs = DEF_OPS (ann);\n-  uses = USE_OPS (ann);\n-  vuses = VUSE_OPS (ann);\n-  v_may_defs = V_MAY_DEF_OPS (ann);\n-  v_must_defs = V_MUST_DEF_OPS (ann);\n-\n   /* Step 1.  Rewrite USES and VUSES in the statement.  */\n-  for (i = 0; i < NUM_USES (uses); i++)\n-    rewrite_operand (USE_OP_PTR (uses, i));\n-\n-  /* Rewrite virtual uses in the statement.  */\n-  for (i = 0; i < NUM_VUSES (vuses); i++)\n-    rewrite_operand (VUSE_OP_PTR (vuses, i));\n+  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES)\n+    rewrite_operand (use_p);\n \n   /* Step 2.  Register the statement's DEF and VDEF operands.  */\n-  for (i = 0; i < NUM_DEFS (defs); i++)\n+  FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, iter, SSA_OP_ALL_DEFS)\n     {\n-      def_operand_p def_p = DEF_OP_PTR (defs, i);\n-\n       if (TREE_CODE (DEF_FROM_PTR (def_p)) != SSA_NAME)\n \tSET_DEF (def_p, make_ssa_name (DEF_FROM_PTR (def_p), stmt));\n \n       /* FIXME: We shouldn't be registering new defs if the variable\n \t doesn't need to be renamed.  */\n       register_new_def (DEF_FROM_PTR (def_p), &bd->block_defs);\n     }\n-\n-  /* Register new virtual definitions made by the statement.  */\n-  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n-    {\n-      rewrite_operand (V_MAY_DEF_OP_PTR (v_may_defs, i));\n-\n-      if (TREE_CODE (V_MAY_DEF_RESULT (v_may_defs, i)) != SSA_NAME)\n-\tSET_V_MAY_DEF_RESULT (v_may_defs, i,\n-\t\t\t      make_ssa_name (V_MAY_DEF_RESULT (v_may_defs, i), \n-\t\t\t\t\t     stmt));\n-\n-      /* FIXME: We shouldn't be registering new defs if the variable\n-\t doesn't need to be renamed.  */\n-      register_new_def (V_MAY_DEF_RESULT (v_may_defs, i), &bd->block_defs);\n-    }\n-        \n-  /* Register new virtual mustdefs made by the statement.  */\n-  for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n-    {\n-      def_operand_p v_must_def_p = V_MUST_DEF_OP_PTR (v_must_defs, i);\n-\n-      if (TREE_CODE (DEF_FROM_PTR (v_must_def_p)) != SSA_NAME)\n-\tSET_DEF (v_must_def_p, \n-\t\t make_ssa_name (DEF_FROM_PTR (v_must_def_p), stmt));\n-\n-      /* FIXME: We shouldn't be registering new mustdefs if the variable\n-\t doesn't need to be renamed.  */\n-      register_new_def (DEF_FROM_PTR (v_must_def_p), &bd->block_defs);\n-    }\n-    \n }\n \n /* Ditto, for rewriting ssa names.  */\n@@ -1232,16 +1094,11 @@ ssa_rewrite_stmt (struct dom_walk_data *walk_data,\n \t\t  basic_block bb ATTRIBUTE_UNUSED,\n \t\t  block_stmt_iterator si)\n {\n-  size_t i;\n   stmt_ann_t ann;\n   tree stmt, var;\n+  ssa_op_iter iter;\n   use_operand_p use_p;\n   def_operand_p def_p;\n-  vuse_optype vuses;\n-  v_may_def_optype v_may_defs;\n-  v_must_def_optype v_must_defs;\n-  def_optype defs;\n-  use_optype uses;\n   struct rewrite_block_data *bd;\n   sbitmap names_to_rename = walk_data->global_data;\n \n@@ -1264,64 +1121,16 @@ ssa_rewrite_stmt (struct dom_walk_data *walk_data,\n     abort ();\n #endif\n \n-  defs = DEF_OPS (ann);\n-  uses = USE_OPS (ann);\n-  vuses = VUSE_OPS (ann);\n-  v_may_defs = V_MAY_DEF_OPS (ann);\n-  v_must_defs = V_MUST_DEF_OPS (ann);\n-\n   /* Step 1.  Rewrite USES and VUSES in the statement.  */\n-  for (i = 0; i < NUM_USES (uses); i++)\n+  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES)\n     {\n-      use_p = USE_OP_PTR (uses, i);\n-      if (TEST_BIT (names_to_rename, SSA_NAME_VERSION (USE_FROM_PTR (use_p))))\n-\tSET_USE (use_p, get_reaching_def (USE_FROM_PTR (use_p)));\n-    }\n-\n-  /* Rewrite virtual uses in the statement.  */\n-  for (i = 0; i < NUM_VUSES (vuses); i++)\n-    {\n-      use_p = VUSE_OP_PTR (vuses, i);\n-      if (TEST_BIT (names_to_rename, SSA_NAME_VERSION (USE_FROM_PTR (use_p))))\n-\tSET_USE (use_p, get_reaching_def (USE_FROM_PTR (use_p)));\n-    }\n-\n-  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n-    {\n-      use_p = V_MAY_DEF_OP_PTR (v_may_defs, i);\n       if (TEST_BIT (names_to_rename, SSA_NAME_VERSION (USE_FROM_PTR (use_p))))\n \tSET_USE (use_p, get_reaching_def (USE_FROM_PTR (use_p)));\n     }\n \n   /* Step 2.  Register the statement's DEF and VDEF operands.  */\n-  for (i = 0; i < NUM_DEFS (defs); i++)\n-    {\n-      def_p = DEF_OP_PTR (defs, i);\n-      var = DEF_FROM_PTR (def_p);\n-\n-      if (!TEST_BIT (names_to_rename, SSA_NAME_VERSION (var)))\n-\tcontinue;\n-\n-      SET_DEF (def_p, duplicate_ssa_name (var, stmt));\n-      ssa_register_new_def (var, DEF_FROM_PTR (def_p), &bd->block_defs);\n-    }\n-\n-  /* Register new virtual definitions made by the statement.  */\n-  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n-    {\n-      def_p = V_MAY_DEF_RESULT_PTR (v_may_defs, i);\n-      var = DEF_FROM_PTR (def_p);\n-\n-      if (!TEST_BIT (names_to_rename, SSA_NAME_VERSION (var)))\n-\tcontinue;\n-\n-      SET_DEF (def_p, duplicate_ssa_name (var, stmt));\n-      ssa_register_new_def (var, DEF_FROM_PTR (def_p), &bd->block_defs);\n-    }\n-\n-  for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n+  FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, iter, SSA_OP_ALL_DEFS)\n     {\n-      def_p = V_MUST_DEF_OP_PTR (v_must_defs, i);\n       var = DEF_FROM_PTR (def_p);\n \n       if (!TEST_BIT (names_to_rename, SSA_NAME_VERSION (var)))"}, {"sha": "0245494690ae36b77d5eda00a9d159c3cec60133", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=4c124b4c6f4e9017f5682cede57bd84c1129da2a", "patch": "@@ -1461,8 +1461,9 @@ check_replaceable (temp_expr_table_p tab, tree stmt)\n   def_optype defs;\n   use_optype uses;\n   tree var, def;\n-  int num_use_ops, version, i;\n+  int num_use_ops, version;\n   var_map map = tab->map;\n+  ssa_op_iter iter;\n \n   if (TREE_CODE (stmt) != MODIFY_EXPR)\n     return false;\n@@ -1512,9 +1513,8 @@ check_replaceable (temp_expr_table_p tab, tree stmt)\n   version = SSA_NAME_VERSION (def);\n \n   /* Add this expression to the dependency list for each use partition.  */\n-  for (i = 0; i < num_use_ops; i++)\n+  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_USE)\n     {\n-      var = USE_OP (uses, i);\n       add_dependance (tab, version, var);\n     }\n \n@@ -1646,23 +1646,19 @@ find_replaceable_in_bb (temp_expr_table_p tab, basic_block bb)\n   block_stmt_iterator bsi;\n   tree stmt, def;\n   stmt_ann_t ann;\n-  int partition, num, i;\n-  use_optype uses;\n-  def_optype defs;\n+  int partition;\n   var_map map = tab->map;\n   value_expr_p p;\n+  ssa_op_iter iter;\n \n   for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n     {\n       stmt = bsi_stmt (bsi);\n       ann = stmt_ann (stmt);\n \n       /* Determine if this stmt finishes an existing expression.  */\n-      uses = USE_OPS (ann);\n-      num = NUM_USES (uses);\n-      for (i = 0; i < num; i++)\n+      FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_USE)\n \t{\n-\t  def = USE_OP (uses, i);\n \t  if (tab->version_info[SSA_NAME_VERSION (def)])\n \t    {\n \t      /* Mark expression as replaceable unless stmt is volatile.  */\n@@ -1674,11 +1670,8 @@ find_replaceable_in_bb (temp_expr_table_p tab, basic_block bb)\n \t}\n       \n       /* Next, see if this stmt kills off an active expression.  */\n-      defs = DEF_OPS (ann);\n-      num = NUM_DEFS (defs);\n-      for (i = 0; i < num; i++)\n+      FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_DEF)\n \t{\n-\t  def = DEF_OP (defs, i);\n \t  partition = var_to_partition (map, def);\n \t  if (partition != NO_PARTITION && tab->partition_dep_list[partition])\n \t    kill_expr (tab, partition, true);\n@@ -1880,13 +1873,15 @@ rewrite_trees (var_map map, tree *values)\n     {\n       for (si = bsi_start (bb); !bsi_end_p (si); )\n \t{\n-\t  size_t i, num_uses, num_defs;\n+\t  size_t num_uses, num_defs;\n \t  use_optype uses;\n \t  def_optype defs;\n \t  tree stmt = bsi_stmt (si);\n \t  use_operand_p use_p;\n+\t  def_operand_p def_p;\n \t  int remove = 0, is_copy = 0;\n \t  stmt_ann_t ann;\n+\t  ssa_op_iter iter;\n \n \t  get_stmt_operands (stmt);\n \t  ann = stmt_ann (stmt);\n@@ -1898,10 +1893,8 @@ rewrite_trees (var_map map, tree *values)\n \n \t  uses = USE_OPS (ann);\n \t  num_uses = NUM_USES (uses);\n-\n-\t  for (i = 0; i < num_uses; i++)\n+\t  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n \t    {\n-\t      use_p = USE_OP_PTR (uses, i);\n \t      if (replace_use_variable (map, use_p, values))\n \t        changed = true;\n \t    }\n@@ -1921,10 +1914,8 @@ rewrite_trees (var_map map, tree *values)\n \t    }\n \t  if (!remove)\n \t    {\n-\t      for (i = 0; i < num_defs; i++)\n+\t      FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, iter, SSA_OP_DEF)\n \t\t{\n-\t\t  def_operand_p def_p = DEF_OP_PTR (defs, i);\n-\n \t\t  if (replace_def_variable (map, def_p, NULL))\n \t\t    changed = true;\n "}, {"sha": "1cc5e7494c340188a1518d85def4b128ea0b8534", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=4c124b4c6f4e9017f5682cede57bd84c1129da2a", "patch": "@@ -2036,38 +2036,35 @@ newline_and_indent (pretty_printer *buffer, int spc)\n static void\n dump_vops (pretty_printer *buffer, tree stmt, int spc, int flags)\n {\n-  size_t i;\n-  stmt_ann_t ann = stmt_ann (stmt);\n-  v_may_def_optype v_may_defs = V_MAY_DEF_OPS (ann);\n-  v_must_def_optype v_must_defs = V_MUST_DEF_OPS (ann);\n-  vuse_optype vuses = VUSE_OPS (ann);\n+  tree use, def;\n+  use_operand_p use_p;\n+  def_operand_p def_p;\n+  ssa_op_iter iter;\n \n-  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n+  FOR_EACH_SSA_MAYDEF_OPERAND (def_p, use_p, stmt, iter)\n     {\n       pp_string (buffer, \"#   \");\n-      dump_generic_node (buffer, V_MAY_DEF_RESULT (v_may_defs, i),\n+      dump_generic_node (buffer, DEF_FROM_PTR (def_p),\n                          spc + 2, flags, false);\n       pp_string (buffer, \" = V_MAY_DEF <\");\n-      dump_generic_node (buffer, V_MAY_DEF_OP (v_may_defs, i),\n+      dump_generic_node (buffer, USE_FROM_PTR (use_p),\n                          spc + 2, flags, false);\n       pp_string (buffer, \">;\");\n       newline_and_indent (buffer, spc);\n     }\n \n-  for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n+  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_VMUSTDEF)\n     {\n-      tree v_must_def = V_MUST_DEF_OP (v_must_defs, i);\n       pp_string (buffer, \"#   V_MUST_DEF <\");\n-      dump_generic_node (buffer, v_must_def, spc + 2, flags, false);\n+      dump_generic_node (buffer, def, spc + 2, flags, false);\n       pp_string (buffer, \">;\");\n       newline_and_indent (buffer, spc);\n     }\n \n-  for (i = 0; i < NUM_VUSES (vuses); i++)\n+  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_VUSE)\n     {\n-      tree vuse = VUSE_OP (vuses, i);\n       pp_string (buffer, \"#   VUSE <\");\n-      dump_generic_node (buffer, vuse, spc + 2, flags, false);\n+      dump_generic_node (buffer, use, spc + 2, flags, false);\n       pp_string (buffer, \">;\");\n       newline_and_indent (buffer, spc);\n     }"}, {"sha": "66980ff6956b2adc4bf25fe7397a9bbdae67bdfb", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=4c124b4c6f4e9017f5682cede57bd84c1129da2a", "patch": "@@ -1397,27 +1397,13 @@ decide_instantiations (void)\n static void\n mark_all_v_defs (tree stmt)\n {\n-  v_may_def_optype v_may_defs;\n-  v_must_def_optype v_must_defs;\n-  size_t i, n;\n+  tree sym;\n+  ssa_op_iter iter;\n \n   get_stmt_operands (stmt);\n \n-  v_may_defs = V_MAY_DEF_OPS (stmt_ann (stmt));\n-  n = NUM_V_MAY_DEFS (v_may_defs);\n-  for (i = 0; i < n; i++)\n+  FOR_EACH_SSA_TREE_OPERAND (sym, stmt, iter, SSA_OP_VIRTUAL_DEFS)\n     {\n-      tree sym = V_MAY_DEF_RESULT (v_may_defs, i);\n-      if (TREE_CODE (sym) == SSA_NAME)\n-\tsym = SSA_NAME_VAR (sym);\n-      bitmap_set_bit (vars_to_rename, var_ann (sym)->uid);\n-    }\n-\n-  v_must_defs = V_MUST_DEF_OPS (stmt_ann (stmt));\n-  n = NUM_V_MUST_DEFS (v_must_defs);\n-  for (i = 0; i < n; i++)\n-    {\n-      tree sym = V_MUST_DEF_OP (v_must_defs, i);\n       if (TREE_CODE (sym) == SSA_NAME)\n \tsym = SSA_NAME_VAR (sym);\n       bitmap_set_bit (vars_to_rename, var_ann (sym)->uid);"}, {"sha": "25c7cf0fa0f863c0195a3afefe4685ed48b4dad5", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 11, "deletions": 31, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=4c124b4c6f4e9017f5682cede57bd84c1129da2a", "patch": "@@ -576,6 +576,8 @@ compute_points_to_and_addr_escape (struct alias_info *ai)\n {\n   basic_block bb;\n   size_t i;\n+  tree op;\n+  ssa_op_iter iter;\n \n   timevar_push (TV_TREE_PTA);\n \n@@ -586,11 +588,6 @@ compute_points_to_and_addr_escape (struct alias_info *ai)\n \n       for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n \t{\n-\t  use_optype uses;\n-\t  def_optype defs;\n-\t  v_may_def_optype v_may_defs;\n-\t  v_must_def_optype v_must_defs;\n-\t  stmt_ann_t ann;\n \t  bitmap addr_taken;\n \t  tree stmt = bsi_stmt (si);\n \t  bool stmt_escapes_p = is_escape_site (stmt, &ai->num_calls_found);\n@@ -629,11 +626,8 @@ compute_points_to_and_addr_escape (struct alias_info *ai)\n \t\t  mark_call_clobbered (var);\n \t\t});\n \n-\t  ann = stmt_ann (stmt);\n-\t  uses = USE_OPS (ann);\n-\t  for (i = 0; i < NUM_USES (uses); i++)\n+\t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_USE)\n \t    {\n-\t      tree op = USE_OP (uses, i);\n \t      var_ann_t v_ann = var_ann (SSA_NAME_VAR (op));\n \t      struct ptr_info_def *pi;\n \t      bool is_store;\n@@ -698,10 +692,8 @@ compute_points_to_and_addr_escape (struct alias_info *ai)\n \t  /* Update reference counter for definitions to any\n \t     potentially aliased variable.  This is used in the alias\n \t     grouping heuristics.  */\n-\t  defs = DEF_OPS (ann);\n-\t  for (i = 0; i < NUM_DEFS (defs); i++)\n+\t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_DEF)\n \t    {\n-\t      tree op = DEF_OP (defs, i);\n \t      tree var = SSA_NAME_VAR (op);\n \t      var_ann_t ann = var_ann (var);\n \t      bitmap_set_bit (ai->written_vars, ann->uid);\n@@ -710,25 +702,13 @@ compute_points_to_and_addr_escape (struct alias_info *ai)\n \t    }\n \n \t  /* Mark variables in V_MAY_DEF operands as being written to.  */\n-\t  v_may_defs = V_MAY_DEF_OPS (ann);\n-\t  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n+\t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_VIRTUAL_DEFS)\n \t    {\n-\t      tree op = V_MAY_DEF_OP (v_may_defs, i);\n \t      tree var = SSA_NAME_VAR (op);\n \t      var_ann_t ann = var_ann (var);\n \t      bitmap_set_bit (ai->written_vars, ann->uid);\n \t    }\n \t    \n-\t  /* Mark variables in V_MUST_DEF operands as being written to.  */\n-\t  v_must_defs = V_MUST_DEF_OPS (ann);\n-\t  for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n-\t    {\n-\t      tree op = V_MUST_DEF_OP (v_must_defs, i);\n-\t      tree var = SSA_NAME_VAR (op);\n-\t      var_ann_t ann = var_ann (var);\n-\t      bitmap_set_bit (ai->written_vars, ann->uid);\n-\t    }\n-\n \t  /* After promoting variables and computing aliasing we will\n \t     need to re-scan most statements.  FIXME: Try to minimize the\n \t     number of statements re-scanned.  It's not really necessary to\n@@ -2391,6 +2371,7 @@ dump_points_to_info (FILE *file)\n   basic_block bb;\n   block_stmt_iterator si;\n   size_t i;\n+  ssa_op_iter iter;\n   const char *fname =\n     lang_hooks.decl_printable_name (current_function_decl, 2);\n \n@@ -2424,12 +2405,11 @@ dump_points_to_info (FILE *file)\n \n \tfor (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n \t  {\n-\t    stmt_ann_t ann = stmt_ann (bsi_stmt (si));\n-\t    def_optype defs = DEF_OPS (ann);\n-\t    if (defs)\n-\t      for (i = 0; i < NUM_DEFS (defs); i++)\n-\t\tif (POINTER_TYPE_P (TREE_TYPE (DEF_OP (defs, i))))\n-\t\t  dump_points_to_info_for (file, DEF_OP (defs, i));\n+\t    tree stmt = bsi_stmt (si);\n+\t    tree def;\n+\t    FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_DEF)\n+\t      if (POINTER_TYPE_P (TREE_TYPE (def)))\n+\t\tdump_points_to_info_for (file, def);\n \t  }\n     }\n "}, {"sha": "bffc888fc0ede29144a2e277f8e369ea519b6ef3", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 25, "deletions": 66, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=4c124b4c6f4e9017f5682cede57bd84c1129da2a", "patch": "@@ -644,11 +644,11 @@ cp_lattice_meet (value val1, value val2)\n static void\n visit_stmt (tree stmt)\n {\n-  size_t i;\n   stmt_ann_t ann;\n-  def_optype defs;\n   v_may_def_optype v_may_defs;\n   v_must_def_optype v_must_defs;\n+  tree def;\n+  ssa_op_iter iter;\n \n   /* If the statement has already been deemed to be VARYING, don't simulate\n      it again.  */\n@@ -684,12 +684,11 @@ visit_stmt (tree stmt)\n \n   /* Definitions made by statements other than assignments to SSA_NAMEs\n      represent unknown modifications to their outputs.  Mark them VARYING.  */\n-  else if (NUM_DEFS (defs = DEF_OPS (ann)) != 0)\n+  else if (NUM_DEFS (DEF_OPS (ann)) != 0)\n     {\n       DONT_SIMULATE_AGAIN (stmt) = 1;\n-      for (i = 0; i < NUM_DEFS (defs); i++)\n+      FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_DEF)\n \t{\n-\t  tree def = DEF_OP (defs, i);\n \t  def_to_varying (def);\n \t}\n     }\n@@ -712,9 +711,8 @@ visit_stmt (tree stmt)\n     }\n \n   /* Mark all V_MAY_DEF operands VARYING.  */\n-  v_may_defs = V_MAY_DEF_OPS (ann);\n-  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n-    def_to_varying (V_MAY_DEF_RESULT (v_may_defs, i));\n+  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_VMAYDEF)\n+    def_to_varying (def);\n     \n }\n \n@@ -1187,6 +1185,8 @@ initialize (void)\n   edge e;\n   basic_block bb;\n   sbitmap virtual_var;\n+  tree def;\n+  ssa_op_iter iter;\n \n   /* Worklists of SSA edges.  */\n   VARRAY_TREE_INIT (ssa_edges, 20, \"ssa_edges\");\n@@ -1211,11 +1211,6 @@ initialize (void)\n     {\n       block_stmt_iterator i;\n       tree stmt;\n-      stmt_ann_t ann;\n-      def_optype defs;\n-      v_may_def_optype v_may_defs;\n-      v_must_def_optype v_must_defs;\n-      size_t x;\n       int vary;\n \n       /* Get the default value for each definition.  */\n@@ -1224,33 +1219,22 @@ initialize (void)\n \t  vary = 0;\n \t  stmt = bsi_stmt (i);\n \t  get_stmt_operands (stmt);\n-\t  ann = stmt_ann (stmt);\n-\t  defs = DEF_OPS (ann);\n-\t  for (x = 0; x < NUM_DEFS (defs); x++)\n+\n+\t  /* Get the default value for each DEF and V_MUST_DEF.  */\n+\t  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, \n+\t\t\t\t     (SSA_OP_DEF | SSA_OP_VMUSTDEF))\n \t    {\n-\t      tree def = DEF_OP (defs, x);\n \t      if (get_value (def)->lattice_val == VARYING)\n \t\tvary = 1;\n \t    }\n \t  \n-\t  /* Get the default value for each V_MUST_DEF.  */\n-\t  v_must_defs = V_MUST_DEF_OPS (ann);\n-\t  for (x = 0; x < NUM_V_MUST_DEFS (v_must_defs); x++)\n-\t    {\n-\t      tree v_must_def = V_MUST_DEF_OP (v_must_defs, x);\n-\t      if (get_value (v_must_def)->lattice_val == VARYING)\n-\t        vary = 1;\n-\t    }\n-\t  \n \t  DONT_SIMULATE_AGAIN (stmt) = vary;\n \n \t  /* Mark all V_MAY_DEF operands VARYING.  */\n-\t  v_may_defs = V_MAY_DEF_OPS (ann);\n-\t  for (x = 0; x < NUM_V_MAY_DEFS (v_may_defs); x++)\n+\t  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_VMAYDEF)\n \t    {\n-\t      tree res = V_MAY_DEF_RESULT (v_may_defs, x);\n-\t      get_value (res)->lattice_val = VARYING;\n-\t      SET_BIT (virtual_var, SSA_NAME_VERSION (res));\n+\t      get_value (def)->lattice_val = VARYING;\n+\t      SET_BIT (virtual_var, SSA_NAME_VERSION (def));\n \t    }\n \t}\n \n@@ -1494,18 +1478,16 @@ static bool\n replace_uses_in (tree stmt, bool *replaced_addresses_p)\n {\n   bool replaced = false;\n-  use_optype uses;\n-  size_t i;\n+  use_operand_p use;\n+  ssa_op_iter iter;\n \n   if (replaced_addresses_p)\n     *replaced_addresses_p = false;\n \n   get_stmt_operands (stmt);\n \n-  uses = STMT_USE_OPS (stmt);\n-  for (i = 0; i < NUM_USES (uses); i++)\n+  FOR_EACH_SSA_USE_OPERAND (use, stmt, iter, SSA_OP_USE)\n     {\n-      use_operand_p use = USE_OP_PTR (uses, i);\n       value *val = get_value (USE_FROM_PTR (use));\n \n       if (val->lattice_val == CONSTANT)\n@@ -1575,11 +1557,11 @@ replace_vuse_in (tree stmt, bool *replaced_addresses_p)\n static latticevalue\n likely_value (tree stmt)\n {\n-  use_optype uses;\n   vuse_optype vuses;\n-  size_t i;\n   int found_constant = 0;\n   stmt_ann_t ann;\n+  tree use;\n+  ssa_op_iter iter;\n \n   /* If the statement makes aliased loads or has volatile operands, it\n      won't fold to a constant value.  */\n@@ -1594,10 +1576,8 @@ likely_value (tree stmt)\n \n   get_stmt_operands (stmt);\n \n-  uses = USE_OPS (ann);\n-  for (i = 0; i < NUM_USES (uses); i++)\n+  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n     {\n-      tree use = USE_OP (uses, i);\n       value *val = get_value (use);\n \n       if (val->lattice_val == UNDEFINED)\n@@ -1627,7 +1607,7 @@ likely_value (tree stmt)\n \tfound_constant = 1;\n     }\n \n-  return ((found_constant || (!uses && !vuses)) ? CONSTANT : VARYING);\n+  return ((found_constant || (!USE_OPS (ann) && !vuses)) ? CONSTANT : VARYING);\n }\n \n /* A subroutine of fold_stmt_r.  Attempts to fold *(A+O) to A[X].\n@@ -2266,6 +2246,8 @@ set_rhs (tree *stmt_p, tree expr)\n   tree stmt = *stmt_p, op;\n   enum tree_code code = TREE_CODE (expr);\n   stmt_ann_t ann;\n+  tree var;\n+  ssa_op_iter iter;\n \n   /* Verify the constant folded result is valid gimple.  */\n   if (TREE_CODE_CLASS (code) == '2')\n@@ -2321,33 +2303,10 @@ set_rhs (tree *stmt_p, tree expr)\n \n       if (TREE_SIDE_EFFECTS (expr))\n \t{\n-\t  def_optype defs;\n-\t  v_may_def_optype v_may_defs;\n-\t  v_must_def_optype v_must_defs;\n-\t  size_t i;\n-\n \t  /* Fix all the SSA_NAMEs created by *STMT_P to point to its new\n \t     replacement.  */\n-\t  defs = DEF_OPS (ann);\n-\t  for (i = 0; i < NUM_DEFS (defs); i++)\n-\t    {\n-\t      tree var = DEF_OP (defs, i);\n-\t      if (TREE_CODE (var) == SSA_NAME)\n-\t\tSSA_NAME_DEF_STMT (var) = *stmt_p;\n-\t    }\n-\n-\t  v_may_defs = V_MAY_DEF_OPS (ann);\n-\t  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n-\t    {\n-\t      tree var = V_MAY_DEF_RESULT (v_may_defs, i);\n-\t      if (TREE_CODE (var) == SSA_NAME)\n-\t\tSSA_NAME_DEF_STMT (var) = *stmt_p;\n-\t    }\n-\t    \n-\t  v_must_defs = V_MUST_DEF_OPS (ann);\n-\t  for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n+\t  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_ALL_DEFS)\n \t    {\n-\t      tree var = V_MUST_DEF_OP (v_must_defs, i);\n \t      if (TREE_CODE (var) == SSA_NAME)\n \t\tSSA_NAME_DEF_STMT (var) = *stmt_p;\n \t    }"}, {"sha": "1041858887655659c63dd89a2644d68fb8a22673", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 8, "deletions": 23, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=4c124b4c6f4e9017f5682cede57bd84c1129da2a", "patch": "@@ -276,12 +276,11 @@ mark_operand_necessary (tree op)\n static void\n mark_stmt_if_obviously_necessary (tree stmt, bool aggressive)\n {\n-  def_optype defs;\n   v_may_def_optype v_may_defs;\n   v_must_def_optype v_must_defs;\n   stmt_ann_t ann;\n-  size_t i;\n-  tree op;\n+  tree op, def;\n+  ssa_op_iter iter;\n \n   /* Statements that are implicitly live.  Most function calls, asm and return\n      statements are required.  Labels and BIND_EXPR nodes are kept because\n@@ -370,10 +369,8 @@ mark_stmt_if_obviously_necessary (tree stmt, bool aggressive)\n \n   get_stmt_operands (stmt);\n \n-  defs = DEF_OPS (ann);\n-  for (i = 0; i < NUM_DEFS (defs); i++)\n+  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_DEF)\n     {\n-      tree def = DEF_OP (defs, i);\n       if (is_global_var (SSA_NAME_VAR (def)))\n \t{\n \t  mark_stmt_necessary (stmt, true);\n@@ -627,30 +624,18 @@ propagate_necessity (struct edge_list *el)\n \t  /* Propagate through the operands.  Examine all the USE, VUSE and\n \t     V_MAY_DEF operands in this statement.  Mark all the statements \n \t     which feed this statement's uses as necessary.  */\n-\t  vuse_optype vuses;\n-\t  v_may_def_optype v_may_defs;\n-\t  use_optype uses;\n-\t  stmt_ann_t ann;\n-\t  size_t k;\n+\t  ssa_op_iter iter;\n+\t  tree use;\n \n \t  get_stmt_operands (i);\n-\t  ann = stmt_ann (i);\n-\n-\t  uses = USE_OPS (ann);\n-\t  for (k = 0; k < NUM_USES (uses); k++)\n-\t    mark_operand_necessary (USE_OP (uses, k));\n-\n-\t  vuses = VUSE_OPS (ann);\n-\t  for (k = 0; k < NUM_VUSES (vuses); k++)\n-\t    mark_operand_necessary (VUSE_OP (vuses, k));\n \n \t  /* The operands of V_MAY_DEF expressions are also needed as they\n \t     represent potential definitions that may reach this\n \t     statement (V_MAY_DEF operands allow us to follow def-def \n \t     links).  */\n-\t  v_may_defs = V_MAY_DEF_OPS (ann);\n-\t  for (k = 0; k < NUM_V_MAY_DEFS (v_may_defs); k++)\n-\t    mark_operand_necessary (V_MAY_DEF_OP (v_may_defs, k));\n+\n+\t  FOR_EACH_SSA_TREE_OPERAND (use, i, iter, SSA_OP_ALL_USES)\n+\t    mark_operand_necessary (use);\n \t}\n     }\n }"}, {"sha": "0660cc6952d7f1762adeeb54dba252595bd67d02", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 9, "deletions": 56, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=4c124b4c6f4e9017f5682cede57bd84c1129da2a", "patch": "@@ -253,7 +253,7 @@ static void restore_vars_to_original_value (varray_type locals,\n \t\t\t\t\t    varray_type table);\n static void restore_currdefs_to_original_value (varray_type locals,\n \t\t\t\t\t\tunsigned limit);\n-static void register_definitions_for_stmt (stmt_ann_t, varray_type *);\n+static void register_definitions_for_stmt (tree, varray_type *);\n static edge single_incoming_edge_ignoring_loop_edges (basic_block);\n \n /* Local version of fold that doesn't introduce cruft.  */\n@@ -2698,41 +2698,16 @@ static bool\n cprop_into_stmt (tree stmt, varray_type const_and_copies)\n {\n   bool may_have_exposed_new_symbols = false;\n-  stmt_ann_t ann = stmt_ann (stmt);\n-  size_t i, num_uses, num_vuses, num_v_may_defs;\n-  vuse_optype vuses;\n-  v_may_def_optype v_may_defs;\n-  use_optype uses;\n-\n-  uses = USE_OPS (ann);\n-  num_uses = NUM_USES (uses);\n-  for (i = 0; i < num_uses; i++)\n-    {\n-      use_operand_p op_p = USE_OP_PTR (uses, i);\n-      if (TREE_CODE (USE_FROM_PTR (op_p)) == SSA_NAME)\n-\tmay_have_exposed_new_symbols\n-\t  |= cprop_operand (stmt, op_p, const_and_copies);\n-    }\n+  use_operand_p op_p;\n+  ssa_op_iter iter;\n \n-  vuses = VUSE_OPS (ann);\n-  num_vuses = NUM_VUSES (vuses);\n-  for (i = 0; i < num_vuses; i++)\n+  FOR_EACH_SSA_USE_OPERAND (op_p, stmt, iter, SSA_OP_ALL_USES)\n     {\n-      use_operand_p op_p = VUSE_OP_PTR (vuses, i);\n       if (TREE_CODE (USE_FROM_PTR (op_p)) == SSA_NAME)\n \tmay_have_exposed_new_symbols\n \t  |= cprop_operand (stmt, op_p, const_and_copies);\n     }\n \n-  v_may_defs = V_MAY_DEF_OPS (ann);\n-  num_v_may_defs = NUM_V_MAY_DEFS (v_may_defs);\n-  for (i = 0; i < num_v_may_defs; i++)\n-    {\n-      use_operand_p op_p = V_MAY_DEF_OP_PTR (v_may_defs, i);\n-      if (TREE_CODE (USE_FROM_PTR (op_p)) == SSA_NAME)\n-\tmay_have_exposed_new_symbols\n-\t  |= cprop_operand (stmt, op_p, const_and_copies);\n-    }\n   return may_have_exposed_new_symbols;\n }\n \n@@ -2830,7 +2805,7 @@ optimize_stmt (struct dom_walk_data *walk_data, basic_block bb,\n \t\t\t\t   may_optimize_p,\n \t\t\t\t   ann);\n \n-  register_definitions_for_stmt (ann, &bd->block_defs);\n+  register_definitions_for_stmt (stmt, &bd->block_defs);\n \n   /* If STMT is a COND_EXPR and it was modified, then we may know\n      where it goes.  If that is the case, then mark the CFG as altered.\n@@ -3373,39 +3348,17 @@ avail_expr_eq (const void *p1, const void *p2)\n    and CURRDEFS.  */\n \n static void\n-register_definitions_for_stmt (stmt_ann_t ann, varray_type *block_defs_p)\n+register_definitions_for_stmt (tree stmt, varray_type *block_defs_p)\n {\n-  def_optype defs;\n-  v_may_def_optype v_may_defs;\n-  v_must_def_optype v_must_defs;\n-  unsigned int i;\n+  tree def;\n+  ssa_op_iter iter;\n \n-  defs = DEF_OPS (ann);\n-  for (i = 0; i < NUM_DEFS (defs); i++)\n+  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_ALL_DEFS)\n     {\n-      tree def = DEF_OP (defs, i);\n \n       /* FIXME: We shouldn't be registering new defs if the variable\n \t doesn't need to be renamed.  */\n       register_new_def (def, block_defs_p);\n     }\n-\n-  /* Register new virtual definitions made by the statement.  */\n-  v_may_defs = V_MAY_DEF_OPS (ann);\n-  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n-    {\n-      /* FIXME: We shouldn't be registering new defs if the variable\n-\t doesn't need to be renamed.  */\n-      register_new_def (V_MAY_DEF_RESULT (v_may_defs, i), block_defs_p);\n-    }\n-    \n-  /* Register new virtual mustdefs made by the statement.  */\n-  v_must_defs = V_MUST_DEF_OPS (ann);\n-  for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n-    {\n-      /* FIXME: We shouldn't be registering new defs if the variable\n-\t doesn't need to be renamed.  */\n-      register_new_def (V_MUST_DEF_OP (v_must_defs, i), block_defs_p);\n-    }\n }\n "}, {"sha": "014ec2d552623c7f1402db237add76b0c92a448c", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 18, "deletions": 52, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=4c124b4c6f4e9017f5682cede57bd84c1129da2a", "patch": "@@ -325,16 +325,11 @@ create_ssa_var_map (int flags)\n   tree dest, use;\n   tree stmt;\n   stmt_ann_t ann;\n-  use_optype uses;\n-  def_optype defs;\n-  unsigned x;\n   var_map map;\n+  ssa_op_iter iter;\n #ifdef ENABLE_CHECKING\n   sbitmap used_in_real_ops;\n   sbitmap used_in_virtual_ops;\n-  vuse_optype vuses;\n-  v_may_def_optype v_may_defs;\n-  v_must_def_optype v_must_defs;\n #endif\n \n   map = init_var_map (num_ssa_names + 1);\n@@ -378,21 +373,17 @@ create_ssa_var_map (int flags)\n \t  ann = stmt_ann (stmt);\n \n \t  /* Register USE and DEF operands in each statement.  */\n-\t  uses = USE_OPS (ann);\n-\t  for (x = 0; x < NUM_USES (uses); x++)\n+\t  FOR_EACH_SSA_TREE_OPERAND (use , stmt, iter, SSA_OP_USE)\n \t    {\n-\t      use = USE_OP (uses, x);\n \t      register_ssa_partition (map, use, true);\n \n #ifdef ENABLE_CHECKING\n \t      SET_BIT (used_in_real_ops, var_ann (SSA_NAME_VAR (use))->uid);\n #endif\n \t    }\n \n-\t  defs = DEF_OPS (ann);\n-\t  for (x = 0; x < NUM_DEFS (defs); x++)\n+\t  FOR_EACH_SSA_TREE_OPERAND (dest, stmt, iter, SSA_OP_DEF)\n \t    {\n-\t      dest = DEF_OP (defs, x);\n \t      register_ssa_partition (map, dest, false);\n \n #ifdef ENABLE_CHECKING\n@@ -402,26 +393,12 @@ create_ssa_var_map (int flags)\n \n #ifdef ENABLE_CHECKING\n \t  /* Validate that virtual ops don't get used in funny ways.  */\n-\t  vuses = VUSE_OPS (ann);\n-\t  for (x = 0; x < NUM_VUSES (vuses); x++)\n+\t  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, \n+\t\t\t\t     SSA_OP_VIRTUAL_USES | SSA_OP_VMUSTDEF)\n \t    {\n-\t      tree var = VUSE_OP (vuses, x);\n-\t      SET_BIT (used_in_virtual_ops, var_ann (SSA_NAME_VAR (var))->uid);\n+\t      SET_BIT (used_in_virtual_ops, var_ann (SSA_NAME_VAR (use))->uid);\n \t    }\n \n-\t  v_may_defs = V_MAY_DEF_OPS (ann);\n-\t  for (x = 0; x < NUM_V_MAY_DEFS (v_may_defs); x++)\n-\t    {\n-\t      tree var = V_MAY_DEF_OP (v_may_defs, x);\n-\t      SET_BIT (used_in_virtual_ops, var_ann (SSA_NAME_VAR (var))->uid);\n-\t    }\n-\t    \n-\t  v_must_defs = V_MUST_DEF_OPS (ann);\n-\t  for (x = 0; x < NUM_V_MUST_DEFS (v_must_defs); x++)\n-\t    {\n-\t      tree var = V_MUST_DEF_OP (v_must_defs, x);\n-\t      SET_BIT (used_in_virtual_ops, var_ann (SSA_NAME_VAR (var))->uid);\n-\t    }\t    \n #endif /* ENABLE_CHECKING */\n \n \t  mark_all_vars_used (bsi_stmt_ptr (bsi));\n@@ -579,17 +556,20 @@ tree_live_info_p\n calculate_live_on_entry (var_map map)\n {\n   tree_live_info_p live;\n-  int num, i;\n+  int i;\n   basic_block bb;\n   bitmap saw_def;\n   tree phi, var, stmt;\n   tree op;\n   edge e;\n   varray_type stack;\n   block_stmt_iterator bsi;\n-  use_optype uses;\n-  def_optype defs;\n   stmt_ann_t ann;\n+  ssa_op_iter iter;\n+#ifdef ENABLE_CHECKING\n+  int num;\n+#endif\n+\n \n   saw_def = BITMAP_XMALLOC ();\n \n@@ -636,19 +616,13 @@ calculate_live_on_entry (var_map map)\n \t  get_stmt_operands (stmt);\n \t  ann = stmt_ann (stmt);\n \n-\t  uses = USE_OPS (ann);\n-\t  num = NUM_USES (uses);\n-\t  for (i = 0; i < num; i++)\n+\t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_USE)\n \t    {\n-\t      op = USE_OP (uses, i);\n \t      add_livein_if_notdef (live, saw_def, op, bb);\n \t    }\n \n-\t  defs = DEF_OPS (ann);\n-\t  num = NUM_DEFS (defs);\n-\t  for (i = 0; i < num; i++)\n+\t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_DEF)\n \t    {\n-\t      op = DEF_OP (defs, i);\n \t      set_if_valid (map, saw_def, op);\n \t    }\n \t}\n@@ -1332,12 +1306,11 @@ build_tree_conflict_graph (tree_live_info_p liveinfo, tpa_p tpa,\n   conflict_graph graph;\n   var_map map;\n   bitmap live;\n-  int num, x, y, i;\n+  int x, y, i;\n   basic_block bb;\n   varray_type partition_link, tpa_to_clear, tpa_nodes;\n-  def_optype defs;\n-  use_optype uses;\n   unsigned l;\n+  ssa_op_iter iter;\n \n   map = live_var_map (liveinfo);\n   graph = conflict_graph_new (num_var_partitions (map));\n@@ -1415,20 +1388,13 @@ build_tree_conflict_graph (tree_live_info_p liveinfo, tpa_p tpa,\n \t  if (!is_a_copy)\n \t    {\n \t      tree var;\n-\n-\t      defs = DEF_OPS (ann);\n-\t      num = NUM_DEFS (defs);\n-\t      for (x = 0; x < num; x++)\n+\t      FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_DEF)\n \t\t{\n-\t\t  var = DEF_OP (defs, x);\n \t\t  add_conflicts_if_valid (tpa, graph, map, live, var);\n \t\t}\n \n-\t      uses = USE_OPS (ann);\n-\t      num = NUM_USES (uses);\n-\t      for (x = 0; x < num; x++)\n+\t      FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_USE)\n \t\t{\n-\t\t  var = USE_OP (uses, x);\n \t\t  set_if_valid (map, live, var);\n \t\t}\n \t    }"}, {"sha": "c5de645234c572c89f070aa63fdbab00fc6d7ae7", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 14, "deletions": 47, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=4c124b4c6f4e9017f5682cede57bd84c1129da2a", "patch": "@@ -406,31 +406,21 @@ determine_max_movement (tree stmt, bool must_preserve_exec)\n   struct loop *loop = bb->loop_father;\n   struct loop *level;\n   struct lim_aux_data *lim_data = LIM_DATA (stmt);\n-  use_optype uses;\n-  vuse_optype vuses;\n-  v_may_def_optype v_may_defs;\n-  stmt_ann_t ann = stmt_ann (stmt);\n-  unsigned i;\n+  tree val;\n+  ssa_op_iter iter;\n   \n   if (must_preserve_exec)\n     level = ALWAYS_EXECUTED_IN (bb);\n   else\n     level = superloop_at_depth (loop, 1);\n   lim_data->max_loop = level;\n \n-  uses = USE_OPS (ann);\n-  for (i = 0; i < NUM_USES (uses); i++)\n-    if (!add_dependency (USE_OP (uses, i), lim_data, loop, true))\n-      return false;\n-\n-  vuses = VUSE_OPS (ann);\n-  for (i = 0; i < NUM_VUSES (vuses); i++)\n-    if (!add_dependency (VUSE_OP (vuses, i), lim_data, loop, false))\n+  FOR_EACH_SSA_TREE_OPERAND (val, stmt, iter, SSA_OP_USE)\n+    if (!add_dependency (val, lim_data, loop, true))\n       return false;\n \n-  v_may_defs = V_MAY_DEF_OPS (ann);\n-  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n-    if (!add_dependency (V_MAY_DEF_OP (v_may_defs, i), lim_data, loop, false))\n+  FOR_EACH_SSA_TREE_OPERAND (val, stmt, iter, SSA_OP_VIRTUAL_USES)\n+    if (!add_dependency (val, lim_data, loop, false))\n       return false;\n \n   lim_data->cost += stmt_cost (stmt);\n@@ -926,10 +916,10 @@ single_reachable_address (struct loop *loop, tree stmt,\n   unsigned in_queue = 1;\n   dataflow_t df;\n   unsigned i, n;\n-  v_may_def_optype v_may_defs;\n-  vuse_optype vuses;\n   struct sra_data sra_data;\n   tree call;\n+  tree val;\n+  ssa_op_iter iter;\n \n   sbitmap_zero (seen);\n \n@@ -970,15 +960,9 @@ single_reachable_address (struct loop *loop, tree stmt,\n \n \t  /* Traverse also definitions of the VUSES (there may be other\n \t     distinct from the one we used to get to this statement).  */\n-\t  v_may_defs = STMT_V_MAY_DEF_OPS (stmt);\n-\t  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n-\t    maybe_queue_var (V_MAY_DEF_OP (v_may_defs, i), loop,\n-\t\t\t     seen, queue, &in_queue);\n+\t  FOR_EACH_SSA_TREE_OPERAND (val, stmt, iter, SSA_OP_VIRTUAL_USES)\n+\t    maybe_queue_var (val, loop, seen, queue, &in_queue);\n \n-\t  vuses = STMT_VUSE_OPS (stmt);\n-\t  for (i = 0; i < NUM_VUSES (vuses); i++)\n-\t    maybe_queue_var (VUSE_OP (vuses, i), loop,\n-\t\t\t     seen, queue, &in_queue);\n \t  break;\n \n \tcase PHI_NODE:\n@@ -1029,32 +1013,15 @@ single_reachable_address (struct loop *loop, tree stmt,\n static void\n rewrite_mem_refs (tree tmp_var, struct mem_ref *mem_refs)\n {\n-  v_may_def_optype v_may_defs;\n-  v_must_def_optype v_must_defs;\n-  vuse_optype vuses;\n-  unsigned i;\n   tree var;\n+  ssa_op_iter iter;\n \n   for (; mem_refs; mem_refs = mem_refs->next)\n     {\n-      v_may_defs = STMT_V_MAY_DEF_OPS (mem_refs->stmt);\n-      for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n-\t{\n-\t  var = SSA_NAME_VAR (V_MAY_DEF_RESULT (v_may_defs, i));\n-\t  bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n-\t}\n-\n-      v_must_defs = STMT_V_MUST_DEF_OPS (mem_refs->stmt);\n-      for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n-\t{\n-\t  var = SSA_NAME_VAR (V_MUST_DEF_OP (v_must_defs, i));\n-\t  bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n-\t}\n-\n-      vuses = STMT_VUSE_OPS (mem_refs->stmt);\n-      for (i = 0; i < NUM_VUSES (vuses); i++)\n+      FOR_EACH_SSA_TREE_OPERAND (var, mem_refs->stmt, iter,\n+\t\t\t\t (SSA_OP_VIRTUAL_DEFS | SSA_OP_VUSE))\n \t{\n-\t  var = SSA_NAME_VAR (VUSE_OP (vuses, i));\n+\t  var = SSA_NAME_VAR (var);\n \t  bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n \t}\n "}, {"sha": "edb821d24f7266de823560d4d31619340e2be138", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 8, "deletions": 34, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=4c124b4c6f4e9017f5682cede57bd84c1129da2a", "patch": "@@ -236,27 +236,14 @@ find_uses_to_rename_use (basic_block bb, tree use, bitmap *use_blocks)\n static void\n find_uses_to_rename_stmt (tree stmt, bitmap *use_blocks)\n {\n-  use_optype uses;\n-  vuse_optype vuses;\n-  v_may_def_optype v_may_defs;\n-  stmt_ann_t ann;\n-  unsigned i;\n+  ssa_op_iter iter;\n+  tree var;\n   basic_block bb = bb_for_stmt (stmt);\n \n   get_stmt_operands (stmt);\n-  ann = stmt_ann (stmt);\n-\n-  uses = USE_OPS (ann);\n-  for (i = 0; i < NUM_USES (uses); i++)\n-    find_uses_to_rename_use (bb, USE_OP (uses, i), use_blocks);\n-\n-  vuses = VUSE_OPS (ann);\n-  for (i = 0; i < NUM_VUSES (vuses); i++)\n-    find_uses_to_rename_use (bb, VUSE_OP (vuses, i),use_blocks);\n \n-  v_may_defs = V_MAY_DEF_OPS (ann);\n-  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n-    find_uses_to_rename_use (bb, V_MAY_DEF_OP (v_may_defs, i), use_blocks);\n+  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_ALL_USES)\n+    find_uses_to_rename_use (bb, var, use_blocks);\n }\n \n /* Marks names that are used outside of the loop they are defined in\n@@ -363,26 +350,13 @@ check_loop_closed_ssa_use (basic_block bb, tree use)\n static void\n check_loop_closed_ssa_stmt (basic_block bb, tree stmt)\n {\n-  use_optype uses;\n-  vuse_optype vuses;\n-  v_may_def_optype v_may_defs;\n-  stmt_ann_t ann;\n-  unsigned i;\n+  ssa_op_iter iter;\n+  tree var;\n \n   get_stmt_operands (stmt);\n-  ann = stmt_ann (stmt);\n-\n-  uses = USE_OPS (ann);\n-  for (i = 0; i < NUM_USES (uses); i++)\n-    check_loop_closed_ssa_use (bb, USE_OP (uses, i));\n-\n-  vuses = VUSE_OPS (ann);\n-  for (i = 0; i < NUM_VUSES (vuses); i++)\n-    check_loop_closed_ssa_use (bb, VUSE_OP (vuses, i));\n \n-  v_may_defs = V_MAY_DEF_OPS (ann);\n-  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n-    check_loop_closed_ssa_use (bb, V_MAY_DEF_OP (v_may_defs, i));\n+  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_ALL_USES)\n+    check_loop_closed_ssa_use (bb, var);\n }\n \n /* Checks that invariants of the loop closed ssa form are preserved.  */"}, {"sha": "c57d486c21cc879d53f60b15853e712e69c4b11f", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=4c124b4c6f4e9017f5682cede57bd84c1129da2a", "patch": "@@ -114,11 +114,15 @@ static GTY (()) varray_type build_vuses;\n /* Array for building all the v_must_def operands.  */\n static GTY (()) varray_type build_v_must_defs;\n \n+\n #ifdef ENABLE_CHECKING\n /* Used to make sure operand construction is working on the proper stmt.  */\n tree check_build_stmt;\n #endif\n \n+def_operand_p NULL_DEF_OPERAND_P = { NULL };\n+use_operand_p NULL_USE_OPERAND_P = { NULL };\n+\n static void note_addressable (tree, stmt_ann_t);\n static void get_expr_operands (tree, tree *, int);\n static void get_asm_expr_operands (tree);"}, {"sha": "50459e507f65458e905e5e6c3cf50c8ea5d1b502", "filename": "gcc/tree-ssa-operands.h", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-ssa-operands.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-ssa-operands.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.h?ref=4c124b4c6f4e9017f5682cede57bd84c1129da2a", "patch": "@@ -36,6 +36,8 @@ typedef struct use_operand_ptr GTY(())\n   tree * GTY((skip(\"\"))) use;\n } use_operand_p;\n \n+extern def_operand_p NULL_DEF_OPERAND_P;\n+extern use_operand_p NULL_USE_OPERAND_P;\n \n /* This represents the DEF operands of a stmt.  */\n typedef struct def_optype_d GTY(())\n@@ -184,4 +186,76 @@ extern void get_stmt_operands (tree);\n extern void copy_virtual_operands (tree, tree);\n extern void create_ssa_artficial_load_stmt (stmt_operands_p, tree);\n \n+\n+/* This structure is used in the operand iterator loops.  It contains the \n+   items required to determine which operand is retreived next.  During\n+   optimization, this structure is scalarized, and any unused fields are \n+   optimized away, resulting in little overhead.  */\n+\n+typedef struct ssa_operand_iterator_d\n+{\n+  int num_use;\n+  int num_def;\n+  int num_vuse;\n+  int num_v_mayu;\n+  int num_v_mayd;\n+  int num_v_must;\n+  int use_i;\n+  int def_i;\n+  int vuse_i;\n+  int v_mayu_i;\n+  int v_mayd_i;\n+  int v_must_i;\n+  stmt_operands_p ops;\n+  bool done;\n+} ssa_op_iter;\n+\n+/* These flags are used to determine which operands are returned during \n+   execution of the loop.  */\n+#define SSA_OP_USE\t\t0x01\t/* Real USE operands.  */\n+#define SSA_OP_DEF\t\t0x02\t/* Real DEF operands.  */\n+#define SSA_OP_VUSE\t\t0x04\t/* VUSE operands.  */\n+#define SSA_OP_VMAYUSE\t\t0x08\t/* USE portion of V_MAY_DEFS.  */\n+#define SSA_OP_VMAYDEF\t\t0x10\t/* DEF portion of V_MAY_DEFS.  */\n+#define SSA_OP_VMUSTDEF\t\t0x20\t/* V_MUST_DEF defintions.  */\n+\n+/* These are commonly grouped operand flags.  */\n+#define SSA_OP_VIRTUAL_USES\t(SSA_OP_VUSE | SSA_OP_VMAYUSE)\n+#define SSA_OP_VIRTUAL_DEFS\t(SSA_OP_VMAYDEF | SSA_OP_VMUSTDEF)\n+#define SSA_OP_ALL_USES\t\t(SSA_OP_VIRTUAL_USES | SSA_OP_USE)\n+#define SSA_OP_ALL_DEFS\t\t(SSA_OP_VIRTUAL_DEFS | SSA_OP_DEF)\n+#define SSA_OP_ALL_OPERANDS\t(SSA_OP_ALL_USES | SSA_OP_ALL_DEFS)\n+\n+/* This macro executes a loop over the operands of STMT specified in FLAG, \n+   returning each operand as a 'tree' in the variable TREEVAR.  ITER is an\n+   ssa_op_iter structure used to control the loop.  */\n+#define FOR_EACH_SSA_TREE_OPERAND(TREEVAR, STMT, ITER, FLAGS)\t\\\n+  for (TREEVAR = op_iter_init_tree (&(ITER), STMT, FLAGS);\t\\\n+       !op_iter_done (&(ITER));\t\t\t\t\t\\\n+       TREEVAR = op_iter_next_tree (&(ITER)))\n+\n+/* This macro executes a loop over the operands of STMT specified in FLAG, \n+   returning each operand as a 'use_operand_p' in the variable USEVAR.  \n+   ITER is an ssa_op_iter structure used to control the loop.  */\n+#define FOR_EACH_SSA_USE_OPERAND(USEVAR, STMT, ITER, FLAGS)\t\\\n+  for (USEVAR = op_iter_init_use (&(ITER), STMT, FLAGS);\t\\\n+       !op_iter_done (&(ITER));\t\t\t\t\t\\\n+       USEVAR = op_iter_next_use (&(ITER)))\n+\n+/* This macro executes a loop over the operands of STMT specified in FLAG, \n+   returning each operand as a 'def_operand_p' in the variable DEFVAR.  \n+   ITER is an ssa_op_iter structure used to control the loop.  */\n+#define FOR_EACH_SSA_DEF_OPERAND(DEFVAR, STMT, ITER, FLAGS)\t\\\n+  for (DEFVAR = op_iter_init_def (&(ITER), STMT, FLAGS);\t\\\n+       !op_iter_done (&(ITER));\t\t\t\t\t\\\n+       DEFVAR = op_iter_next_def (&(ITER)))\n+\n+/* This macro executes a loop over the V_MAY_DEF operands of STMT.  The def\n+   and use for each V_MAY_DEF is returned in DEFVAR and USEVAR. \n+   ITER is an ssa_op_iter structure used to control the loop.  */\n+#define FOR_EACH_SSA_MAYDEF_OPERAND(DEFVAR, USEVAR, STMT, ITER)\t\\\n+  for (op_iter_init_maydef (&(ITER), STMT, &(USEVAR), &(DEFVAR));\t\\\n+       !op_iter_done (&(ITER));\t\t\t\t\t\\\n+       op_iter_next_maydef (&(USEVAR), &(DEFVAR), &(ITER)))\n+\n #endif  /* GCC_TREE_SSA_OPERANDS_H  */"}, {"sha": "46068e5c99e63f237c9724e23093eb5af48f79c3", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 16, "deletions": 57, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=4c124b4c6f4e9017f5682cede57bd84c1129da2a", "patch": "@@ -504,6 +504,8 @@ verify_ssa (void)\n   size_t i;\n   basic_block bb;\n   basic_block *definition_block = xcalloc (num_ssa_names, sizeof (basic_block));\n+  ssa_op_iter iter;\n+  tree op;\n \n   timevar_push (TV_TREE_SSA_VERIFY);\n \n@@ -528,43 +530,26 @@ verify_ssa (void)\n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n \t{\n \t  tree stmt;\n-\t  stmt_ann_t ann;\n-\t  unsigned int j;\n-\t  v_may_def_optype v_may_defs;\n-\t  v_must_def_optype v_must_defs;\n-\t  def_optype defs;\n \n \t  stmt = bsi_stmt (bsi);\n-\t  ann = stmt_ann (stmt);\n \t  get_stmt_operands (stmt);\n \n-\t  v_may_defs = V_MAY_DEF_OPS (ann);\n-\t  if (ann->makes_aliased_stores && NUM_V_MAY_DEFS (v_may_defs) == 0)\n+\t  if (stmt_ann (stmt)->makes_aliased_stores \n+\t      && NUM_V_MAY_DEFS (STMT_V_MAY_DEF_OPS (stmt)) == 0)\n \t    {\n \t      error (\"Statement makes aliased stores, but has no V_MAY_DEFS\");\n \t      debug_generic_stmt (stmt);\n \t      goto err;\n \t    }\n \t    \n-\t  for (j = 0; j < NUM_V_MAY_DEFS (v_may_defs); j++)\n+\t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_VIRTUAL_DEFS)\n \t    {\n-\t      tree op = V_MAY_DEF_RESULT (v_may_defs, j);\n \t      if (verify_def (bb, definition_block, op, stmt, true))\n \t\tgoto err;\n \t    }\n           \n-\t  v_must_defs = STMT_V_MUST_DEF_OPS (stmt);\n-\t  for (j = 0; j < NUM_V_MUST_DEFS (v_must_defs); j++)\n+\t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_DEF)\n \t    {\n-\t      tree op = V_MUST_DEF_OP (v_must_defs, j);\n-\t      if (verify_def (bb, definition_block, op, stmt, true))\n-\t\tgoto err;\n-\t    }\n-\n-\t  defs = DEF_OPS (ann);\n-\t  for (j = 0; j < NUM_DEFS (defs); j++)\n-\t    {\n-\t      tree op = DEF_OP (defs, j);\n \t      if (verify_def (bb, definition_block, op, stmt, false))\n \t\tgoto err;\n \t    }\n@@ -600,34 +585,16 @@ verify_ssa (void)\n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n \t{\n \t  tree stmt = bsi_stmt (bsi);\n-\t  stmt_ann_t ann = stmt_ann (stmt);\n-\t  unsigned int j;\n-\t  vuse_optype vuses;\n-\t  v_may_def_optype v_may_defs;\n-\t  use_optype uses;\n-\n-\t  vuses = VUSE_OPS (ann); \n-\t  for (j = 0; j < NUM_VUSES (vuses); j++)\n-\t    {\n-\t      tree op = VUSE_OP (vuses, j);\n-\t      if (verify_use (bb, definition_block[SSA_NAME_VERSION (op)],\n-\t\t\t      op, stmt, false, true))\n-\t\tgoto err;\n-\t    }\n \n-\t  v_may_defs = V_MAY_DEF_OPS (ann);\n-\t  for (j = 0; j < NUM_V_MAY_DEFS (v_may_defs); j++)\n+\t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_VIRTUAL_USES)\n \t    {\n-\t      tree op = V_MAY_DEF_OP (v_may_defs, j);\n \t      if (verify_use (bb, definition_block[SSA_NAME_VERSION (op)],\n \t\t\t      op, stmt, false, true))\n \t\tgoto err;\n \t    }\n \n-\t  uses = USE_OPS (ann);\n-\t  for (j = 0; j < NUM_USES (uses); j++)\n+\t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_USE)\n \t    {\n-\t      tree op = USE_OP (uses, j);\n \t      if (verify_use (bb, definition_block[SSA_NAME_VERSION (op)],\n \t\t\t      op, stmt, false, false))\n \t\tgoto err;\n@@ -941,14 +908,13 @@ propagate_into_addr (tree stmt, tree var, tree *x, tree repl)\n static void\n replace_immediate_uses (tree var, tree repl)\n {\n-  use_optype uses;\n-  vuse_optype vuses;\n-  v_may_def_optype v_may_defs;\n   int i, j, n;\n   dataflow_t df;\n   tree stmt;\n   stmt_ann_t ann;\n   bool mark_new_vars;\n+  ssa_op_iter iter;\n+  use_operand_p use_p;\n \n   df = get_immediate_uses (SSA_NAME_DEF_STMT (var));\n   n = num_immediate_uses (df);\n@@ -982,25 +948,18 @@ replace_immediate_uses (tree var, tree repl)\n \t      propagate_into_addr (stmt, var, &TREE_OPERAND (stmt, 1), repl);\n \t    }\n \n-\t  uses = USE_OPS (ann);\n-\t  for (j = 0; j < (int) NUM_USES (uses); j++)\n-\t    if (USE_OP (uses, j) == var)\n+\t  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n+\t    if (USE_FROM_PTR (use_p) == var)\n \t      {\n-\t\tpropagate_value (USE_OP_PTR (uses, j), repl);\n+\t\tpropagate_value (use_p, repl);\n \t\tmark_new_vars = POINTER_TYPE_P (TREE_TYPE (repl));\n \t      }\n \t}\n       else\n \t{\n-\t  vuses = VUSE_OPS (ann);\n-\t  for (j = 0; j < (int) NUM_VUSES (vuses); j++)\n-\t    if (VUSE_OP (vuses, j) == var)\n-\t      propagate_value (VUSE_OP_PTR (vuses, j), repl);\n-\n-\t  v_may_defs = V_MAY_DEF_OPS (ann);\n-\t  for (j = 0; j < (int) NUM_V_MAY_DEFS (v_may_defs); j++)\n-\t    if (V_MAY_DEF_OP (v_may_defs, j) == var)\n-\t      propagate_value (V_MAY_DEF_OP_PTR (v_may_defs, j), repl);\n+\t  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_VIRTUAL_USES)\n+\t    if (USE_FROM_PTR (use_p) == var)\n+\t      propagate_value (use_p, repl);\n \t}\n \n       /* If REPL is a pointer, it may have different memory tags associated"}, {"sha": "d46014a277dd1827ba4364c74f67720751278c56", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=4c124b4c6f4e9017f5682cede57bd84c1129da2a", "patch": "@@ -296,25 +296,11 @@ duplicate_ssa_name (tree name, tree stmt)\n void\n release_defs (tree stmt)\n {\n-  size_t i;\n-  v_may_def_optype v_may_defs;\n-  v_must_def_optype v_must_defs;\n-  def_optype defs;\n-  stmt_ann_t ann;\n+  tree def;\n+  ssa_op_iter iter;\n \n-  ann = stmt_ann (stmt);\n-  defs = DEF_OPS (ann);\n-  v_may_defs = V_MAY_DEF_OPS (ann);\n-  v_must_defs = V_MUST_DEF_OPS (ann);\n-\n-  for (i = 0; i < NUM_DEFS (defs); i++)\n-    release_ssa_name (DEF_OP (defs, i));\n-\n-  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n-    release_ssa_name (V_MAY_DEF_RESULT (v_may_defs, i));\n-\n-  for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n-    release_ssa_name (V_MUST_DEF_OP (v_must_defs, i));\n+  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_ALL_DEFS)\n+    release_ssa_name (def);\n }\n \n "}, {"sha": "770772cc9517d5b7d16e4e700168d8646949474d", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c124b4c6f4e9017f5682cede57bd84c1129da2a/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=4c124b4c6f4e9017f5682cede57bd84c1129da2a", "patch": "@@ -674,11 +674,6 @@ vect_create_data_ref (tree stmt, block_stmt_iterator *bsi)\n   tree vect_ptr_type;\n   tree vect_ptr;\n   tree addr_ref;\n-  v_may_def_optype v_may_defs = STMT_V_MAY_DEF_OPS (stmt);\n-  v_must_def_optype v_must_defs = STMT_V_MUST_DEF_OPS (stmt);\n-  vuse_optype vuses = STMT_VUSE_OPS (stmt);\n-  int nvuses, nv_may_defs, nv_must_defs;\n-  int i;\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   tree array_type;\n   tree base_addr = NULL_TREE;\n@@ -687,6 +682,8 @@ vect_create_data_ref (tree stmt, block_stmt_iterator *bsi)\n   tree tag;\n   tree addr_expr;\n   tree scalar_ptr_type;\n+  tree use;\n+  ssa_op_iter iter;\n \n   /* FORNOW: make sure the data reference is aligned.  */\n   vect_align_data_ref (stmt);\n@@ -743,27 +740,12 @@ vect_create_data_ref (tree stmt, block_stmt_iterator *bsi)\n   \n   /* Mark for renaming all aliased variables\n      (i.e, the may-aliases of the type-mem-tag) */\n-  nvuses = NUM_VUSES (vuses);\n-  nv_may_defs = NUM_V_MAY_DEFS (v_may_defs);\n-  nv_must_defs = NUM_V_MUST_DEFS (v_must_defs);\n-  for (i = 0; i < nvuses; i++)\n+  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter,\n+\t\t\t     (SSA_OP_VIRTUAL_DEFS | SSA_OP_VUSE))\n     {\n-      tree use = VUSE_OP (vuses, i);\n       if (TREE_CODE (use) == SSA_NAME)\n         bitmap_set_bit (vars_to_rename, var_ann (SSA_NAME_VAR (use))->uid);\n     }\n-  for (i = 0; i < nv_may_defs; i++)\n-    {\n-      tree def = V_MAY_DEF_RESULT (v_may_defs, i);\n-      if (TREE_CODE (def) == SSA_NAME)\n-        bitmap_set_bit (vars_to_rename, var_ann (SSA_NAME_VAR (def))->uid);\n-    }\n-  for (i = 0; i < nv_must_defs; i++)\n-    {\n-      tree def = V_MUST_DEF_OP (v_must_defs, i);\n-      if (TREE_CODE (def) == SSA_NAME)\n-        bitmap_set_bit (vars_to_rename, var_ann (SSA_NAME_VAR (def))->uid);\n-    }\n \n   pe = loop_preheader_edge (loop);\n "}]}