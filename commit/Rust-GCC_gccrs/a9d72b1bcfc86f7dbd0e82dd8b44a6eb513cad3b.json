{"sha": "a9d72b1bcfc86f7dbd0e82dd8b44a6eb513cad3b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTlkNzJiMWJjZmM4NmY3ZGJkMGU4MmRkOGI0NGE2ZWI1MTNjYWQzYg==", "commit": {"author": {"name": "Piotr Trojanek", "email": "trojanek@adacore.com", "date": "2020-05-06T20:02:11Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-07-10T09:16:16Z"}, "message": "[Ada] Reuse SPARK expansion of attribute Update for delta_aggregate\n\ngcc/ada/\n\n\t* exp_spark.adb (Expand_SPARK_Delta_Or_Update): Refactored from\n\tExpand_SPARK_N_Attribute_Reference; rewrite into N_Aggregate or\n\tN_Delta_Aggregate depending on what is being rewritten.\n\t(Expand_SPARK_N_Delta_Aggregate): New routine to expand\n\tdelta_aggregate.\n\t(Expand_SPARK_N_Attribute_Reference): Call the refactored\n\troutine.", "tree": {"sha": "0f2cf2fa09e2bbfc3de7bbd2c42a4c256e700494", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f2cf2fa09e2bbfc3de7bbd2c42a4c256e700494"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9d72b1bcfc86f7dbd0e82dd8b44a6eb513cad3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9d72b1bcfc86f7dbd0e82dd8b44a6eb513cad3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9d72b1bcfc86f7dbd0e82dd8b44a6eb513cad3b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9d72b1bcfc86f7dbd0e82dd8b44a6eb513cad3b/comments", "author": {"login": "ptroja", "id": 161602, "node_id": "MDQ6VXNlcjE2MTYwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/161602?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ptroja", "html_url": "https://github.com/ptroja", "followers_url": "https://api.github.com/users/ptroja/followers", "following_url": "https://api.github.com/users/ptroja/following{/other_user}", "gists_url": "https://api.github.com/users/ptroja/gists{/gist_id}", "starred_url": "https://api.github.com/users/ptroja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ptroja/subscriptions", "organizations_url": "https://api.github.com/users/ptroja/orgs", "repos_url": "https://api.github.com/users/ptroja/repos", "events_url": "https://api.github.com/users/ptroja/events{/privacy}", "received_events_url": "https://api.github.com/users/ptroja/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "964cf38cb37e4766837b284a566cabe0fc737f26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/964cf38cb37e4766837b284a566cabe0fc737f26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/964cf38cb37e4766837b284a566cabe0fc737f26"}], "stats": {"total": 358, "additions": 198, "deletions": 160}, "files": [{"sha": "9bdd3d0aa201ba1613657b5078ef98fc73726e50", "filename": "gcc/ada/exp_spark.adb", "status": "modified", "additions": 198, "deletions": 160, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9d72b1bcfc86f7dbd0e82dd8b44a6eb513cad3b/gcc%2Fada%2Fexp_spark.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9d72b1bcfc86f7dbd0e82dd8b44a6eb513cad3b/gcc%2Fada%2Fexp_spark.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_spark.adb?ref=a9d72b1bcfc86f7dbd0e82dd8b44a6eb513cad3b", "patch": "@@ -54,6 +54,9 @@ package body Exp_SPARK is\n    procedure Expand_SPARK_N_Attribute_Reference (N : Node_Id);\n    --  Perform attribute-reference-specific expansion\n \n+   procedure Expand_SPARK_N_Delta_Aggregate (N : Node_Id);\n+   --  Perform delta-aggregate-specific expansion\n+\n    procedure Expand_SPARK_N_Freeze_Type (E : Entity_Id);\n    --  Build the DIC procedure of a type when needed, if not already done\n \n@@ -69,6 +72,9 @@ package body Exp_SPARK is\n    procedure Expand_SPARK_N_Op_Ne (N : Node_Id);\n    --  Rewrite operator /= based on operator = when defined explicitly\n \n+   procedure Expand_SPARK_Delta_Or_Update (Typ : Entity_Id; Aggr : Node_Id);\n+   --  Common expansion of attribute Update and delta_aggregate\n+\n    ------------------\n    -- Expand_SPARK --\n    ------------------\n@@ -101,6 +107,9 @@ package body Exp_SPARK is\n          when N_Attribute_Reference =>\n             Expand_SPARK_N_Attribute_Reference (N);\n \n+         when N_Delta_Aggregate =>\n+            Expand_SPARK_N_Delta_Aggregate (N);\n+\n          when N_Expanded_Name\n             | N_Identifier\n          =>\n@@ -137,6 +146,185 @@ package body Exp_SPARK is\n       end case;\n    end Expand_SPARK;\n \n+   ----------------------------------\n+   -- Expand_SPARK_Delta_Or_Update --\n+   ----------------------------------\n+\n+   procedure Expand_SPARK_Delta_Or_Update\n+     (Typ  : Entity_Id;\n+      Aggr : Node_Id)\n+   is\n+      Assoc     : Node_Id;\n+      Comp      : Node_Id;\n+      Comp_Id   : Entity_Id;\n+      Comp_Type : Entity_Id;\n+      Expr      : Node_Id;\n+      Index     : Node_Id;\n+      Index_Typ : Entity_Id;\n+      New_Assoc : Node_Id;\n+\n+   begin\n+      --  Apply scalar range checks on the updated components, if needed\n+\n+      if Is_Array_Type (Typ) then\n+\n+         --  Multi-dimensional array\n+\n+         if Present (Next_Index (First_Index (Typ))) then\n+            Assoc := First (Component_Associations (Aggr));\n+\n+            while Present (Assoc) loop\n+               Expr      := Expression (Assoc);\n+               Comp_Type := Component_Type (Typ);\n+\n+               if Is_Scalar_Type (Comp_Type) then\n+                  Apply_Scalar_Range_Check (Expr, Comp_Type);\n+               end if;\n+\n+               --  The current association contains a sequence of indexes\n+               --  denoting an element of a multidimensional array:\n+               --\n+               --    (Index_1, ..., Index_N)\n+\n+               Expr := First (Choices (Assoc));\n+\n+               pragma Assert (Nkind (Aggr) = N_Aggregate);\n+\n+               while Present (Expr) loop\n+                  Index     := First (Expressions (Expr));\n+                  Index_Typ := First_Index (Typ);\n+\n+                  while Present (Index_Typ) loop\n+                     Apply_Scalar_Range_Check (Index, Etype (Index_Typ));\n+                     Next (Index);\n+                     Next_Index (Index_Typ);\n+                  end loop;\n+\n+                  Next (Expr);\n+               end loop;\n+\n+               Next (Assoc);\n+            end loop;\n+\n+         --  One-dimensional array\n+\n+         else\n+            Assoc := First (Component_Associations (Aggr));\n+\n+            while Present (Assoc) loop\n+               Expr      := Expression (Assoc);\n+               Comp_Type := Component_Type (Typ);\n+\n+               if Is_Scalar_Type (Comp_Type) then\n+                  Apply_Scalar_Range_Check (Expr, Comp_Type);\n+               end if;\n+\n+               Index     := First (Choices (Assoc));\n+               Index_Typ := First_Index (Typ);\n+\n+               while Present (Index) loop\n+                  --  The index denotes a range of elements\n+\n+                  if Nkind (Index) = N_Range then\n+                     Apply_Scalar_Range_Check\n+                       (Low_Bound  (Index), Etype (Index_Typ));\n+                     Apply_Scalar_Range_Check\n+                       (High_Bound (Index), Etype (Index_Typ));\n+\n+                     --  Otherwise the index denotes a single element\n+\n+                  else\n+                     Apply_Scalar_Range_Check (Index, Etype (Index_Typ));\n+                  end if;\n+\n+                  Next (Index);\n+               end loop;\n+\n+               Next (Assoc);\n+            end loop;\n+         end if;\n+\n+      else pragma Assert (Is_Record_Type (Typ));\n+\n+         --  If the aggregate has multiple component choices, e.g.\n+         --\n+         --    X'Update (A | B | C => 123)\n+         --\n+         --  then each component might be of a different type and might\n+         --  or might not require a range check. We first rewrite\n+         --  associations into single-component choices, e.g.:\n+         --\n+         --    X'Update (A => 123, B => 123, C => 123)\n+         --\n+         --  and then apply range checks to individual copies of the\n+         --  expressions. We do the same for delta aggregates, accordingly.\n+\n+         --  Iterate over associations of the original aggregate\n+\n+         Assoc := First (Component_Associations (Aggr));\n+\n+         --  Rewrite into a new aggregate and decorate\n+\n+         case Nkind (Aggr) is\n+            when N_Aggregate =>\n+               Rewrite\n+                 (Aggr,\n+                  Make_Aggregate\n+                    (Sloc                   => Sloc (Aggr),\n+                     Component_Associations => New_List));\n+\n+            when N_Delta_Aggregate =>\n+               Rewrite\n+                 (Aggr,\n+                  Make_Delta_Aggregate\n+                    (Sloc                   => Sloc (Aggr),\n+                     Expression             => Expression (Aggr),\n+                     Component_Associations => New_List));\n+\n+            when others =>\n+               raise Program_Error;\n+         end case;\n+\n+         Set_Etype (Aggr, Typ);\n+\n+         --  Populate the new aggregate with component associations\n+\n+         while Present (Assoc) loop\n+            Expr := Expression (Assoc);\n+            Comp := First (Choices (Assoc));\n+\n+            while Present (Comp) loop\n+               Comp_Id   := Entity (Comp);\n+               Comp_Type := Etype (Comp_Id);\n+\n+               New_Assoc :=\n+                 Make_Component_Association\n+                   (Sloc       => Sloc (Assoc),\n+                    Choices    =>\n+                      New_List\n+                        (New_Occurrence_Of (Comp_Id, Sloc (Comp))),\n+                    Expression => New_Copy_Tree (Expr));\n+\n+               --  New association must be attached to the aggregate before we\n+               --  analyze it.\n+\n+               Append (New_Assoc, Component_Associations (Aggr));\n+\n+               Analyze_And_Resolve (Expression (New_Assoc), Comp_Type);\n+\n+               if Is_Scalar_Type (Comp_Type) then\n+                  Apply_Scalar_Range_Check\n+                    (Expression (New_Assoc), Comp_Type);\n+               end if;\n+\n+               Next (Comp);\n+            end loop;\n+\n+            Next (Assoc);\n+         end loop;\n+      end if;\n+   end Expand_SPARK_Delta_Or_Update;\n+\n    --------------------------------\n    -- Expand_SPARK_N_Freeze_Type --\n    --------------------------------\n@@ -252,169 +440,19 @@ package body Exp_SPARK is\n          end if;\n \n       elsif Attr_Id = Attribute_Update then\n-         declare\n-            Aggr : constant Node_Id := First (Expressions (N));\n-            --  The aggregate expression\n-\n-            Assoc     : Node_Id;\n-            Comp      : Node_Id;\n-            Comp_Id   : Entity_Id;\n-            Comp_Type : Entity_Id;\n-            Expr      : Node_Id;\n-            Index     : Node_Id;\n-            Index_Typ : Entity_Id;\n-            New_Assoc : Node_Id;\n-\n-         begin\n-            --  Apply scalar range checks on the updated components, if needed\n-\n-            if Is_Array_Type (Typ) then\n-\n-               --  Multi-dimensional array\n-\n-               if Present (Next_Index (First_Index (Typ))) then\n-                  Assoc := First (Component_Associations (Aggr));\n-\n-                  while Present (Assoc) loop\n-                     Expr      := Expression (Assoc);\n-                     Comp_Type := Component_Type (Typ);\n-\n-                     if Is_Scalar_Type (Comp_Type) then\n-                        Apply_Scalar_Range_Check (Expr, Comp_Type);\n-                     end if;\n-\n-                     --  The current association contains a sequence of indexes\n-                     --  denoting an element of a multidimensional array:\n-                     --\n-                     --    (Index_1, ..., Index_N)\n-\n-                     Expr := First (Choices (Assoc));\n-\n-                     pragma Assert (Nkind (Aggr) = N_Aggregate);\n-\n-                     while Present (Expr) loop\n-                        Index     := First (Expressions (Expr));\n-                        Index_Typ := First_Index (Typ);\n-\n-                        while Present (Index_Typ) loop\n-                           Apply_Scalar_Range_Check (Index, Etype (Index_Typ));\n-                           Next (Index);\n-                           Next_Index (Index_Typ);\n-                        end loop;\n-\n-                        Next (Expr);\n-                     end loop;\n-\n-                     Next (Assoc);\n-                  end loop;\n-\n-               --  One-dimensional array\n-\n-               else\n-                  Assoc := First (Component_Associations (Aggr));\n-\n-                  while Present (Assoc) loop\n-                     Expr      := Expression (Assoc);\n-                     Comp_Type := Component_Type (Typ);\n-\n-                     if Is_Scalar_Type (Comp_Type) then\n-                        Apply_Scalar_Range_Check (Expr, Comp_Type);\n-                     end if;\n-\n-                     Index     := First (Choices (Assoc));\n-                     Index_Typ := First_Index (Typ);\n-\n-                     while Present (Index) loop\n-                        --  The index denotes a range of elements\n-\n-                        if Nkind (Index) = N_Range then\n-                           Apply_Scalar_Range_Check\n-                             (Low_Bound  (Index), Etype (Index_Typ));\n-                           Apply_Scalar_Range_Check\n-                             (High_Bound (Index), Etype (Index_Typ));\n-\n-                        --  Otherwise the index denotes a single element\n-\n-                        else\n-                           Apply_Scalar_Range_Check (Index, Etype (Index_Typ));\n-                        end if;\n-\n-                        Next (Index);\n-                     end loop;\n-\n-                     Next (Assoc);\n-                  end loop;\n-               end if;\n-\n-            else pragma Assert (Is_Record_Type (Typ));\n-\n-               --  If the aggregate has multiple component choices, e.g.\n-               --\n-               --    X'Update (A | B | C => 123)\n-               --\n-               --  then each component might be of a different type and might\n-               --  or might not require a range check. We first rewrite\n-               --  associations into single-component choices, e.g.:\n-               --\n-               --    X'Update (A => 123, B => 123, C => 123)\n-               --\n-               --  and then apply range checks to individual copies of the\n-               --  expressions.\n-\n-               --  Iterate over associations of the original aggregate\n-\n-               Assoc := First (Component_Associations (Aggr));\n-\n-               --  Rewrite into a new aggregate and decorate\n-\n-               Rewrite\n-                 (Aggr,\n-                  Make_Aggregate\n-                    (Sloc                   => Sloc (Aggr),\n-                     Component_Associations => New_List));\n-\n-               Set_Etype (Aggr, Typ);\n-\n-               --  Populate the new aggregate with component associations\n-\n-               while Present (Assoc) loop\n-                  Expr := Expression (Assoc);\n-                  Comp := First (Choices (Assoc));\n-\n-                  while Present (Comp) loop\n-                     Comp_Id   := Entity (Comp);\n-                     Comp_Type := Etype (Comp_Id);\n-\n-                     New_Assoc :=\n-                       Make_Component_Association\n-                         (Sloc       => Sloc (Assoc),\n-                          Choices    =>\n-                            New_List\n-                              (New_Occurrence_Of (Comp_Id, Sloc (Comp))),\n-                          Expression => New_Copy_Tree (Expr));\n-\n-                     --  New association must be attached as a child of the\n-                     --  aggregate before we analyze it.\n-\n-                     Append (New_Assoc, Component_Associations (Aggr));\n-\n-                     Analyze_And_Resolve (Expression (New_Assoc), Comp_Type);\n-\n-                     if Is_Scalar_Type (Comp_Type) then\n-                        Apply_Scalar_Range_Check\n-                          (Expression (New_Assoc), Comp_Type);\n-                     end if;\n-\n-                     Next (Comp);\n-                  end loop;\n-\n-                  Next (Assoc);\n-               end loop;\n-            end if;\n-         end;\n+         Expand_SPARK_Delta_Or_Update (Typ, First (Expressions (N)));\n       end if;\n    end Expand_SPARK_N_Attribute_Reference;\n \n+   ------------------------------------\n+   -- Expand_SPARK_N_Delta_Aggregate --\n+   ------------------------------------\n+\n+   procedure Expand_SPARK_N_Delta_Aggregate (N : Node_Id) is\n+   begin\n+      Expand_SPARK_Delta_Or_Update (Etype (N), N);\n+   end Expand_SPARK_N_Delta_Aggregate;\n+\n    -----------------------------------\n    -- Expand_SPARK_N_Loop_Statement --\n    -----------------------------------"}]}