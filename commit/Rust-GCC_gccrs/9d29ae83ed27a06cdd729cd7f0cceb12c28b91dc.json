{"sha": "9d29ae83ed27a06cdd729cd7f0cceb12c28b91dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQyOWFlODNlZDI3YTA2Y2RkNzI5Y2Q3ZjBjY2ViMTJjMjhiOTFkYw==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2017-05-05T09:40:01Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wilco@gcc.gnu.org", "date": "2017-05-05T09:40:01Z"}, "message": "Code scheduling for Cortex-A53 isn't as good as it could be.\n\nCode scheduling for Cortex-A53 isn't as good as it could be.  It turns out\ncode runs faster overall if we place loads and stores with a dependency\ncloser together.  To achieve this effect, this patch adds a bypass between\ncortex_a53_load1 and cortex_a53_load*/cortex_a53_store* if the result of an\nearlier load is used in an address calculation.  This significantly improved\nbenchmark scores in a proprietary benchmark suite.\n\n    gcc/\n\t* config/arm/aarch-common.c (arm_early_load_addr_dep_ptr):\n\tNew function.\n\t(arm_early_store_addr_dep_ptr): Likewise.\n\t* config/arm/aarch-common-protos.h\n\t(arm_early_load_addr_dep_ptr): Add prototype.\n\t(arm_early_store_addr_dep_ptr): Likewise.\n\t* config/arm/cortex-a53.md: Add new bypasses.\n\nFrom-SVN: r247631", "tree": {"sha": "8e1a45a11552c8773d1770494a16e028b354522b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e1a45a11552c8773d1770494a16e028b354522b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d29ae83ed27a06cdd729cd7f0cceb12c28b91dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d29ae83ed27a06cdd729cd7f0cceb12c28b91dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d29ae83ed27a06cdd729cd7f0cceb12c28b91dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d29ae83ed27a06cdd729cd7f0cceb12c28b91dc/comments", "author": null, "committer": null, "parents": [{"sha": "dfae9048a0ce06a8f240dd17c282cb1e1eaf2097", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfae9048a0ce06a8f240dd17c282cb1e1eaf2097", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfae9048a0ce06a8f240dd17c282cb1e1eaf2097"}], "stats": {"total": 58, "additions": 58, "deletions": 0}, "files": [{"sha": "910658a970b53d4f1adc223a331d1d20f3e1db04", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d29ae83ed27a06cdd729cd7f0cceb12c28b91dc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d29ae83ed27a06cdd729cd7f0cceb12c28b91dc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9d29ae83ed27a06cdd729cd7f0cceb12c28b91dc", "patch": "@@ -1,3 +1,13 @@\n+2017-05-05  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* config/arm/aarch-common.c (arm_early_load_addr_dep_ptr):\n+\tNew function.\n+\t(arm_early_store_addr_dep_ptr): Likewise.\n+\t* config/arm/aarch-common-protos.h\n+\t(arm_early_load_addr_dep_ptr): Add prototype.\n+\t(arm_early_store_addr_dep_ptr): Likewise.\n+\t* config/arm/cortex-a53.md: Add new bypasses.\n+\n 2017-05-05  Jakub Jelinek  <jakub@redhat.com>\n \n \t* tree.c (next_type_uid): Change type to unsigned."}, {"sha": "35d2d96c9fdd2fe751cb1d37695f925892c9a898", "filename": "gcc/config/arm/aarch-common-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d29ae83ed27a06cdd729cd7f0cceb12c28b91dc/gcc%2Fconfig%2Farm%2Faarch-common-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d29ae83ed27a06cdd729cd7f0cceb12c28b91dc/gcc%2Fconfig%2Farm%2Faarch-common-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faarch-common-protos.h?ref=9d29ae83ed27a06cdd729cd7f0cceb12c28b91dc", "patch": "@@ -30,7 +30,9 @@ extern bool aarch_rev16_p (rtx);\n extern bool aarch_rev16_shleft_mask_imm_p (rtx, machine_mode);\n extern bool aarch_rev16_shright_mask_imm_p (rtx, machine_mode);\n extern int arm_early_load_addr_dep (rtx, rtx);\n+extern int arm_early_load_addr_dep_ptr (rtx, rtx);\n extern int arm_early_store_addr_dep (rtx, rtx);\n+extern int arm_early_store_addr_dep_ptr (rtx, rtx);\n extern int arm_mac_accumulator_is_mul_result (rtx, rtx);\n extern int arm_mac_accumulator_is_result (rtx, rtx);\n extern int arm_no_early_alu_shift_dep (rtx, rtx);"}, {"sha": "6a04711335db292037ede5a801bdbaa830a3e524", "filename": "gcc/config/arm/aarch-common.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d29ae83ed27a06cdd729cd7f0cceb12c28b91dc/gcc%2Fconfig%2Farm%2Faarch-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d29ae83ed27a06cdd729cd7f0cceb12c28b91dc/gcc%2Fconfig%2Farm%2Faarch-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faarch-common.c?ref=9d29ae83ed27a06cdd729cd7f0cceb12c28b91dc", "patch": "@@ -241,6 +241,24 @@ arm_early_load_addr_dep (rtx producer, rtx consumer)\n   return reg_overlap_mentioned_p (value, addr);\n }\n \n+/* Return nonzero if the CONSUMER instruction (a load) does need\n+   a Pmode PRODUCER's value to calculate the address.  */\n+\n+int\n+arm_early_load_addr_dep_ptr (rtx producer, rtx consumer)\n+{\n+  rtx value = arm_find_sub_rtx_with_code (PATTERN (producer), SET, false);\n+  rtx addr = arm_find_sub_rtx_with_code (PATTERN (consumer), SET, false);\n+\n+  if (!value || !addr || !MEM_P (SET_SRC (value)))\n+    return 0;\n+\n+  value = SET_DEST (value);\n+  addr = SET_SRC (addr);\n+\n+  return GET_MODE (value) == Pmode && reg_overlap_mentioned_p (value, addr);\n+}\n+\n /* Return nonzero if the CONSUMER instruction (an ALU op) does not\n    have an early register shift value or amount dependency on the\n    result of PRODUCER.  */\n@@ -336,6 +354,24 @@ arm_early_store_addr_dep (rtx producer, rtx consumer)\n   return !arm_no_early_store_addr_dep (producer, consumer);\n }\n \n+/* Return nonzero if the CONSUMER instruction (a store) does need\n+   a Pmode PRODUCER's value to calculate the address.  */\n+\n+int\n+arm_early_store_addr_dep_ptr (rtx producer, rtx consumer)\n+{\n+  rtx value = arm_find_sub_rtx_with_code (PATTERN (producer), SET, false);\n+  rtx addr = arm_find_sub_rtx_with_code (PATTERN (consumer), SET, false);\n+\n+  if (!value || !addr || !MEM_P (SET_SRC (value)))\n+    return 0;\n+\n+  value = SET_DEST (value);\n+  addr = SET_DEST (addr);\n+\n+  return GET_MODE (value) == Pmode && reg_overlap_mentioned_p (value, addr);\n+}\n+\n /* Return non-zero iff the consumer (a multiply-accumulate or a\n    multiple-subtract instruction) has an accumulator dependency on the\n    result of the producer and no other dependency on that result.  It"}, {"sha": "b7e0c9257f76b915ddccbc3eff28780fef7fc784", "filename": "gcc/config/arm/cortex-a53.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d29ae83ed27a06cdd729cd7f0cceb12c28b91dc/gcc%2Fconfig%2Farm%2Fcortex-a53.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d29ae83ed27a06cdd729cd7f0cceb12c28b91dc/gcc%2Fconfig%2Farm%2Fcortex-a53.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fcortex-a53.md?ref=9d29ae83ed27a06cdd729cd7f0cceb12c28b91dc", "patch": "@@ -254,6 +254,16 @@\n \t\t \"cortex_a53_store*\"\n \t\t \"arm_no_early_store_addr_dep\")\n \n+;; Model a bypass for load to load/store address.\n+\n+(define_bypass 3 \"cortex_a53_load1\"\n+\t\t \"cortex_a53_load*\"\n+\t\t \"arm_early_load_addr_dep_ptr\")\n+\n+(define_bypass 3 \"cortex_a53_load1\"\n+\t\t \"cortex_a53_store*\"\n+\t\t \"arm_early_store_addr_dep_ptr\")\n+\n ;; Model a GP->FP register move as similar to stores.\n \n (define_bypass 0 \"cortex_a53_alu*,cortex_a53_shift*\""}]}