{"sha": "1dc06b76ba609bb94f95a35c6ab21c2235ad80b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWRjMDZiNzZiYTYwOWJiOTRmOTVhMzVjNmFiMjFjMjIzNWFkODBiMQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2017-01-05T19:09:25Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2017-01-05T19:09:25Z"}, "message": "i386.md (*testqi_ext_3): No need to handle memory operands in a special way.\n\n\t* config/i386/i386.md (*testqi_ext_3): No need to handle memory\n\toperands in a special way.  Assert that pos+len <= mode precision.\n\nFrom-SVN: r244108", "tree": {"sha": "885714aa4d9a5ab7915d8666355c4306e5ac6dc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/885714aa4d9a5ab7915d8666355c4306e5ac6dc1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1dc06b76ba609bb94f95a35c6ab21c2235ad80b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dc06b76ba609bb94f95a35c6ab21c2235ad80b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1dc06b76ba609bb94f95a35c6ab21c2235ad80b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dc06b76ba609bb94f95a35c6ab21c2235ad80b1/comments", "author": null, "committer": null, "parents": [{"sha": "295ce2e534ccbf48e96d920ee23460e52bd67ccd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/295ce2e534ccbf48e96d920ee23460e52bd67ccd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/295ce2e534ccbf48e96d920ee23460e52bd67ccd"}], "stats": {"total": 47, "additions": 22, "deletions": 25}, "files": [{"sha": "0a242c07515f3e78320c30ce368e687fae9ce7f5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dc06b76ba609bb94f95a35c6ab21c2235ad80b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dc06b76ba609bb94f95a35c6ab21c2235ad80b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1dc06b76ba609bb94f95a35c6ab21c2235ad80b1", "patch": "@@ -1,3 +1,8 @@\n+2017-01-05  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.md (*testqi_ext_3): No need to handle memory\n+\toperands in a special way.  Assert that pos+len <= mode precision.\n+\n 2017-01-05  Jakub Jelinek  <jakub@redhat.com>\n \n \t* common.opt (fvect-cost-model): Remove RejectNegative flag, use\n@@ -208,8 +213,7 @@\n \t(signbit<mode>2_dm): Delete using <Fsignbit> and just use \"wa\".\n \tUpdate the length attribute if the value is in a GPR.\n \t(signbit<mode>2_dm_<su>ext): Add combiner pattern to eliminate\n-\tthe sign or zero extension instruction, since the value is always\n-\t0/1.\n+\tthe sign or zero extension instruction, since the value is always 0/1.\n \t(signbit<mode>2_dm2): Delete using <Fsignbit>.\n \n \tPR target/78953\n@@ -220,8 +224,7 @@\n \n 2017-01-03  Ian Lance Taylor  <iant@google.com>\n \n-\t* godump.c (go_format_type): Treat ENUMERAL_TYPE like\n-\tINTEGER_TYPE.\n+\t* godump.c (go_format_type): Treat ENUMERAL_TYPE like INTEGER_TYPE.\n \n 2017-01-03  Martin Sebor  <msebor@redhat.com>\n "}, {"sha": "01815170d2303f0d3abe4ad11395859a49af6cde", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dc06b76ba609bb94f95a35c6ab21c2235ad80b1/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dc06b76ba609bb94f95a35c6ab21c2235ad80b1/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=1dc06b76ba609bb94f95a35c6ab21c2235ad80b1", "patch": "@@ -8007,36 +8007,30 @@\n   rtx val = operands[2];\n   HOST_WIDE_INT len = INTVAL (operands[3]);\n   HOST_WIDE_INT pos = INTVAL (operands[4]);\n-  machine_mode mode, submode;\n+  machine_mode mode = GET_MODE (val);\n \n-  mode = GET_MODE (val);\n-  if (MEM_P (val))\n+  if (SUBREG_P (val))\n     {\n-      /* ??? Combine likes to put non-volatile mem extractions in QImode\n-\t no matter the size of the test.  So find a mode that works.  */\n-      if (! MEM_VOLATILE_P (val))\n+      machine_mode submode = GET_MODE (SUBREG_REG (val));\n+\n+      /* Narrow paradoxical subregs to prevent partial register stalls.  */\n+      if (GET_MODE_BITSIZE (mode) > GET_MODE_BITSIZE (submode)\n+\t  && GET_MODE_CLASS (submode) == MODE_INT)\n \t{\n-\t  mode = smallest_mode_for_size (pos + len, MODE_INT);\n-\t  val = adjust_address (val, mode, 0);\n+\t  val = SUBREG_REG (val);\n+\t  mode = submode;\n \t}\n     }\n-  else if (SUBREG_P (val)\n-\t   && (submode = GET_MODE (SUBREG_REG (val)),\n-\t       GET_MODE_BITSIZE (mode) > GET_MODE_BITSIZE (submode))\n-\t   && pos + len <= GET_MODE_BITSIZE (submode)\n-\t   && GET_MODE_CLASS (submode) == MODE_INT)\n-    {\n-      /* Narrow a paradoxical subreg to prevent partial register stalls.  */\n-      mode = submode;\n-      val = SUBREG_REG (val);\n-    }\n-  else if (mode == HImode && pos + len <= 8)\n+\n+  /* Small HImode tests can be converted to QImode.  */\n+  if (register_operand (val, HImode) && pos + len <= 8)\n     {\n-      /* Small HImode tests can be converted to QImode.  */\n-      mode = QImode;\n       val = gen_lowpart (QImode, val);\n+      mode = QImode;\n     }\n \n+  gcc_assert (pos + len <= GET_MODE_PRECISION (mode));\n+\n   wide_int mask\n     = wi::shifted_mask (pos, len, false, GET_MODE_PRECISION (mode));\n "}]}