{"sha": "10c98117e8f1dde3b61e3e0d358376b44b1e4b61", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBjOTgxMTdlOGYxZGRlM2I2MWUzZTBkMzU4Mzc2YjQ0YjFlNGI2MQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-10-05T16:29:42Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-10-05T16:29:42Z"}, "message": "i386.c (ia32_multipass_dfa_lookahead): Default to issue rate for post-reload scheduling.\n\n\t* i386.c (ia32_multipass_dfa_lookahead): Default to issue rate\n\tfor post-reload scheduling.\n\nFrom-SVN: r253453", "tree": {"sha": "73e5dcd6cac9a59b4409db519e06b4e0d6fe07a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73e5dcd6cac9a59b4409db519e06b4e0d6fe07a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10c98117e8f1dde3b61e3e0d358376b44b1e4b61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10c98117e8f1dde3b61e3e0d358376b44b1e4b61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10c98117e8f1dde3b61e3e0d358376b44b1e4b61", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10c98117e8f1dde3b61e3e0d358376b44b1e4b61/comments", "author": null, "committer": null, "parents": [{"sha": "592fbfb5fb376972c21d88ac57b0a4a38018e79f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/592fbfb5fb376972c21d88ac57b0a4a38018e79f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/592fbfb5fb376972c21d88ac57b0a4a38018e79f"}], "stats": {"total": 50, "additions": 12, "deletions": 38}, "files": [{"sha": "009a6eb146719cb54462eff75ba283893197b4e4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c98117e8f1dde3b61e3e0d358376b44b1e4b61/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c98117e8f1dde3b61e3e0d358376b44b1e4b61/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=10c98117e8f1dde3b61e3e0d358376b44b1e4b61", "patch": "@@ -1,3 +1,8 @@\n+2017-10-05  Jan Hubicka <hubicka@ucw.cz>\n+\n+\t* i386.c (ia32_multipass_dfa_lookahead): Default to issue rate\n+\tfor post-reload scheduling.\n+\n 2017-10-05  Tamar Christina  <tamar.christina@arm.com>\n \n \t* doc/sourcebuild.texi (vect_sizes_16B_8B, vect_sizes_32B_16B): New."}, {"sha": "e90cbfb50606d910433981a81807aad163e23c4c", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 7, "deletions": 38, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c98117e8f1dde3b61e3e0d358376b44b1e4b61/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c98117e8f1dde3b61e3e0d358376b44b1e4b61/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=10c98117e8f1dde3b61e3e0d358376b44b1e4b61", "patch": "@@ -30761,44 +30761,13 @@ ix86_adjust_cost (rtx_insn *insn, int dep_type, rtx_insn *dep_insn, int cost,\n static int\n ia32_multipass_dfa_lookahead (void)\n {\n-  switch (ix86_tune)\n-    {\n-    case PROCESSOR_PENTIUM:\n-    case PROCESSOR_LAKEMONT:\n-      return 2;\n-\n-    case PROCESSOR_PENTIUMPRO:\n-    case PROCESSOR_K6:\n-      return 1;\n-\n-    case PROCESSOR_BDVER1:\n-    case PROCESSOR_BDVER2:\n-    case PROCESSOR_BDVER3:\n-    case PROCESSOR_BDVER4:\n-      /* We use lookahead value 4 for BD both before and after reload\n-\t schedules. Plan is to have value 8 included for O3. */\n-        return 4;\n-\n-    case PROCESSOR_CORE2:\n-    case PROCESSOR_NEHALEM:\n-    case PROCESSOR_SANDYBRIDGE:\n-    case PROCESSOR_HASWELL:\n-    case PROCESSOR_BONNELL:\n-    case PROCESSOR_SILVERMONT:\n-    case PROCESSOR_KNL:\n-    case PROCESSOR_KNM:\n-    case PROCESSOR_INTEL:\n-      /* Generally, we want haifa-sched:max_issue() to look ahead as far\n-\t as many instructions can be executed on a cycle, i.e.,\n-\t issue_rate.  I wonder why tuning for many CPUs does not do this.  */\n-      if (reload_completed)\n-        return ix86_issue_rate ();\n-      /* Don't use lookahead for pre-reload schedule to save compile time.  */\n-      return 0;\n-\n-    default:\n-      return 0;\n-    }\n+  /* Generally, we want haifa-sched:max_issue() to look ahead as far\n+     as many instructions can be executed on a cycle, i.e.,\n+     issue_rate.  */\n+  if (reload_completed)\n+    return ix86_issue_rate ();\n+  /* Don't use lookahead for pre-reload schedule to save compile time.  */\n+  return 0;\n }\n \n /* Return true if target platform supports macro-fusion.  */"}]}