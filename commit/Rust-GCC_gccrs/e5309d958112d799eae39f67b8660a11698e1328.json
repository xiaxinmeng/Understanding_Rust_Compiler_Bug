{"sha": "e5309d958112d799eae39f67b8660a11698e1328", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTUzMDlkOTU4MTEyZDc5OWVhZTM5ZjY3Yjg2NjBhMTE2OThlMTMyOA==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.vnet.ibm.com", "date": "2017-07-12T14:59:36Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2017-07-12T14:59:36Z"}, "message": "S/390: Calculate costs for load/store on condition\n\nThis adds code to the backend rtx_costs function in order to model the\ncosts of a load/store on condition.\n\ngcc/ChangeLog:\n\n2017-07-12  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n\n\t* config/s390/s390.c (s390_rtx_costs): Return proper costs for\n\tload/store on condition.\n\nFrom-SVN: r250152", "tree": {"sha": "dc41b51f16c3a562c08b6beeaebce01fc2961326", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc41b51f16c3a562c08b6beeaebce01fc2961326"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5309d958112d799eae39f67b8660a11698e1328", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5309d958112d799eae39f67b8660a11698e1328", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5309d958112d799eae39f67b8660a11698e1328", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5309d958112d799eae39f67b8660a11698e1328/comments", "author": null, "committer": null, "parents": [{"sha": "8b718de8a7c45667773cd684b4e8267cfa8a27a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b718de8a7c45667773cd684b4e8267cfa8a27a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b718de8a7c45667773cd684b4e8267cfa8a27a7"}], "stats": {"total": 47, "additions": 47, "deletions": 0}, "files": [{"sha": "1960a7e1a7452e697fd5afd2b2889b2fd9a85553", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5309d958112d799eae39f67b8660a11698e1328/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5309d958112d799eae39f67b8660a11698e1328/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e5309d958112d799eae39f67b8660a11698e1328", "patch": "@@ -1,3 +1,8 @@\n+2017-07-12  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\t* config/s390/s390.c (s390_rtx_costs): Return proper costs for\n+\tload/store on condition.\n+\n 2017-07-12  Georg-Johann Lay  <avr@gjlay.de>\n \n \tPR target/81407"}, {"sha": "31ced21a043fb272598ade5559fe0017414479f4", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5309d958112d799eae39f67b8660a11698e1328/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5309d958112d799eae39f67b8660a11698e1328/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=e5309d958112d799eae39f67b8660a11698e1328", "patch": "@@ -3414,6 +3414,48 @@ s390_rtx_costs (rtx x, machine_mode mode, int outer_code,\n       *total = 0;\n       return true;\n \n+    case SET:\n+      {\n+\t/* Without this a conditional move instruction would be\n+\t   accounted as 3 * COSTS_N_INSNS (set, if_then_else,\n+\t   comparison operator).  That's a bit pessimistic.  */\n+\n+\tif (!TARGET_Z196 || GET_CODE (SET_SRC (x)) != IF_THEN_ELSE)\n+\t  return false;\n+\n+\trtx cond = XEXP (SET_SRC (x), 0);\n+\n+\tif (!CC_REG_P (XEXP (cond, 0)) || !CONST_INT_P (XEXP (cond, 1)))\n+\t  return false;\n+\n+\t/* It is going to be a load/store on condition.  Make it\n+\t   slightly more expensive than a normal load.  */\n+\t*total = COSTS_N_INSNS (1) + 1;\n+\n+\trtx dst = SET_DEST (x);\n+\trtx then = XEXP (SET_SRC (x), 1);\n+\trtx els = XEXP (SET_SRC (x), 2);\n+\n+\t/* It is a real IF-THEN-ELSE.  An additional move will be\n+\t   needed to implement that.  */\n+\tif (reload_completed\n+\t    && !rtx_equal_p (dst, then)\n+\t    && !rtx_equal_p (dst, els))\n+\t  *total += COSTS_N_INSNS (1) / 2;\n+\n+\t/* A minor penalty for constants we cannot directly handle.  */\n+\tif ((CONST_INT_P (then) || CONST_INT_P (els))\n+\t    && (!TARGET_Z13 || MEM_P (dst)\n+\t\t|| (CONST_INT_P (then) && !satisfies_constraint_K (then))\n+\t\t|| (CONST_INT_P (els) && !satisfies_constraint_K (els))))\n+\t  *total += COSTS_N_INSNS (1) / 2;\n+\n+\t/* A store on condition can only handle register src operands.  */\n+\tif (MEM_P (dst) && (!REG_P (then) || !REG_P (els)))\n+\t  *total += COSTS_N_INSNS (1) / 2;\n+\n+\treturn true;\n+      }\n     case IOR:\n       /* risbg */\n       if (GET_CODE (XEXP (x, 0)) == AND"}]}