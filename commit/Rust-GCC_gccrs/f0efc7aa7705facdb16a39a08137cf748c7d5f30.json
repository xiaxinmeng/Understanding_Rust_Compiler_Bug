{"sha": "f0efc7aa7705facdb16a39a08137cf748c7d5f30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjBlZmM3YWE3NzA1ZmFjZGIxNmEzOWEwODEzN2NmNzQ4YzdkNWYzMA==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@google.com", "date": "2011-08-08T16:49:34Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2011-08-08T16:49:34Z"}, "message": "rebase\n\nFrom-SVN: r177571", "tree": {"sha": "71d0dfebe89d85d68e84274293c25cee61f487e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71d0dfebe89d85d68e84274293c25cee61f487e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0efc7aa7705facdb16a39a08137cf748c7d5f30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0efc7aa7705facdb16a39a08137cf748c7d5f30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0efc7aa7705facdb16a39a08137cf748c7d5f30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0efc7aa7705facdb16a39a08137cf748c7d5f30/comments", "author": {"login": "dnovillo", "id": 7295335, "node_id": "MDQ6VXNlcjcyOTUzMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7295335?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dnovillo", "html_url": "https://github.com/dnovillo", "followers_url": "https://api.github.com/users/dnovillo/followers", "following_url": "https://api.github.com/users/dnovillo/following{/other_user}", "gists_url": "https://api.github.com/users/dnovillo/gists{/gist_id}", "starred_url": "https://api.github.com/users/dnovillo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dnovillo/subscriptions", "organizations_url": "https://api.github.com/users/dnovillo/orgs", "repos_url": "https://api.github.com/users/dnovillo/repos", "events_url": "https://api.github.com/users/dnovillo/events{/privacy}", "received_events_url": "https://api.github.com/users/dnovillo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b7926cf90567f9c9e12cdcc8935c58223055fe90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7926cf90567f9c9e12cdcc8935c58223055fe90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7926cf90567f9c9e12cdcc8935c58223055fe90"}], "stats": {"total": 8573, "additions": 4613, "deletions": 3960}, "files": [{"sha": "b1776f59f48def2df77a88e4a3601e94a1757518", "filename": "gcc/ChangeLog", "status": "modified", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f0efc7aa7705facdb16a39a08137cf748c7d5f30", "patch": "@@ -1,3 +1,222 @@\n+2011-08-08   Diego Novillo  <dnovillo@google.com>\n+\n+\t* Makefile.in (LTO_STREAMER_H): Add DIAGNOSTIC_H.\n+\t(DATA_STREAMER_H): New.\n+\t(GIMPLE_STREAMER_H): New.\n+\t(TREE_STREAMER_H): New.\n+\t(STREAMER_HOOKS_H): New.\n+\t(OBJS): Add data-streamer.o, data-streamer-in.o, data-streamer-out.o,\n+\tgimple-streamer-in.o, gimple-streamer-out.o, streamer-hooks.o,\n+\ttree-streamer.o, tree-streamer-in.o and tree-streamer-out.o.\n+\t(data-streamer.o): New.\n+\t(data-streamer-in.o): New.\n+\t(data-streamer-out.o): New.\n+\t(gimple-streamer-in.o): New.\n+\t(gimple-streamer-out.o): New.\n+\t(streamer-hooks.o): New.\n+\t(tree-streamer.o): New.\n+\t(tree-streamer-in.o): New.\n+\t(tree-streamer-out.o): New.\n+\t(lto-cgraph.o): Add dependency on DATA_STREAMER_H and\n+\tTREE_STREAMER_H.\n+\t(lto-streamer-in.o): Add dependency on DATA_STREAMER_H,\n+\tGIMPLE_STREAMER_H and TREE_STREAMER_H.\n+\t(lto-streamer-out.o): Add dependency on DATA_STREAMER_H,\n+\tGIMPLE_STREAMER_H and TREE_STREAMER_H.\n+\t(lto-streamer.o): Add dependency on STREAMER_HOOKS_H.\n+\t(ipa-prop.o): Add dependency on DATA_STREAMER_H and\n+\tTREE_STREAMER_H.\n+\t(ipa-inline-analysis.o): Likewise.\n+\t(ipa-pure-const.o): Likewise.\n+\t* data-streamer-in.c: New.\n+\t* data-streamer-out.c: New.\n+\t* data-streamer.c: New.\n+\t* data-streamer.h: New.\n+\t* gimple-streamer-in.c: New.\n+\t* gimple-streamer-out.c: New.\n+\t* gimple-streamer.h: New.\n+\t* ipa-inline-analysis.c: Include data-streamer.h.\n+\t* ipa-prop.c: Include data-streamer.h.\n+\t* ipa-pure-const.c: Include data-streamer.h.\n+\t* lto-cgraph.c: Include data-streamer.h.\n+\t* lto-section-in.c (lto_input_uleb128): Move to data-streamer-in.c.\n+\t(lto_input_widest_uint_uleb128): Likewise.\n+\t(lto_input_sleb128): Likewise.\n+\t(bp_unpack_var_len_unsigned): Likewise.\n+\t(bp_unpack_var_len_int): Likewise.\n+\t* lto-section-out.c (lto_output_uleb128_stream): Move to\n+\tdata-streamer-out.c.\n+\t(lto_output_widest_uint_uleb128_stream): Likewise.\n+\t(lto_output_sleb128_stream): Likewise.\n+\t(bp_pack_var_len_unsigned): Likewise.\n+\t(bp_pack_var_len_int): Likewise.\n+\t* lto-streamer-in.c: Include data-streamer.h and\n+\tgimple-streamer.h.\n+\t(struct string_slot): Remove.  Update all users.\n+\t(lto_tag_check_set): Make extern.\n+\t(lto_tag_check_range): Move to lto-streamer.h.\n+\t(lto_tag_check): Likewise.\n+\t(hash_string_slot_node): Remove.  Update all users.\n+\t(eq_string_slot_node): Remove.  Update all users.\n+\t(string_for_index): Move to data-streamer-in.c\n+\t(input_string_internal): Likewise.\n+\t(input_string_cst): Move to tree-streamer-in.c.\n+\t(input_identifier): Likewise.\n+\t(lto_input_string): Move to data-streamer-in.c\n+\t(input_record_start): Move to data-streamer.h\n+\t(canon_file_name): Use new definition of struct string_slot\n+\tfrom data-streamer.h.\n+\tSet S_SLOT.LEN.\n+\t(lto_input_location): Make extern.\n+\t(lto_input_chain): Move to tree-streamer-in.c.\n+\t(lto_init_eh): Make extern.\n+\t(input_phi): Move to gimple-streamer-in.c.\n+\t(input_gimple_stmt): Likewise.\n+\t(input_bb): Likewise.\n+\t(unpack_ts_base_value_fields): Move to tree-streamer-in.c.\n+\t(unpack_ts_real_cst_value_fields): Likewise.\n+\t(unpack_ts_fixed_cst_value_fields): Likewise.\n+\t(unpack_ts_decl_common_value_fields): Likewise.\n+\t(unpack_ts_decl_wrtl_value_fields): Likewise.\n+\t(unpack_ts_decl_with_vis_value_fields): Likewise.\n+\t(unpack_ts_function_decl_value_fields): Likewise.\n+\t(unpack_ts_type_common_value_fields): Likewise.\n+\t(unpack_ts_block_value_fields): Likewise.\n+\t(unpack_ts_translation_unit_decl_value_fields): Likewise.\n+\t(unpack_value_fields): Likewise.\n+\t(lto_materialize_tree): Likewise.\n+\t(lto_input_ts_common_tree_pointers): Likewise.\n+\t(lto_input_ts_vector_tree_pointers): Likewise.\n+\t(lto_input_ts_complex_tree_pointers): Likewise.\n+\t(lto_input_ts_decl_minimal_tree_pointers): Likewise.\n+\t(lto_input_ts_decl_common_tree_pointers): Likewise.\n+\t(lto_input_ts_decl_non_common_tree_pointers): Likewise.\n+\t(lto_input_ts_decl_with_vis_tree_pointers): Likewise.\n+\t(lto_input_ts_field_decl_tree_pointers): Likewise.\n+\t(lto_input_ts_function_decl_tree_pointers): Likewise.\n+\t(lto_input_ts_type_common_tree_pointers): Likewise.\n+\t(lto_input_ts_type_non_common_tree_pointers): Likewise.\n+\t(lto_input_ts_list_tree_pointers): Likewise.\n+\t(lto_input_ts_vec_tree_pointers): Likewise.\n+\t(lto_input_ts_exp_tree_pointers): Likewise.\n+\t(lto_input_ts_block_tree_pointers): Likewise.\n+\t(lto_input_ts_binfo_tree_pointers): Likewise.\n+\t(lto_input_ts_constructor_tree_pointers): Likewise.\n+\t(lto_input_ts_target_option): Likewise.\n+\t(lto_input_ts_translation_unit_decl_tree_pointers): Likewise.\n+\t(lto_input_tree_pointers): Likewise.\n+\t(lto_get_pickled_tree): Likewise.\n+\t(lto_get_builtin_tree): Likewise.\n+\t(lto_read_tree): Likewise.\n+\t(lto_input_integer_cst): Likewise.\n+\t(lto_input_tree): Likewise.\n+\t* lto-streamer-out.c: Include data-streamer.h,\n+\tgimple-streamer.h and streamer-hooks.h.\n+\t(struct string_slot): Move to data-streamer.h.\n+\t(hash_string_slot_node): Likewise.\n+\t(eq_string_slot_node): Likewise.\n+\t(lto_string_index): Move to data-streamer-out.c.\n+\t(lto_output_string_with_length): Likewise.\n+\t(lto_output_string): Likewise.\n+\t(output_string_cst): Move to tree-streamer-out.c.\n+\t(output_identifier): Likewise.\n+\t(output_zero): Move to data-streamer-out.c\n+\t(output_uleb128): Likewise.\n+\t(output_sleb128): Likewise.\n+\t(output_record_start): Move to data-streamer.h\n+\t(pack_ts_base_value_fields): Move to tree-streamer-out.c.\n+\t(pack_ts_real_cst_value_fields): Likewise.\n+\t(pack_ts_fixed_cst_value_fields): Likewise.\n+\t(pack_ts_decl_common_value_fields): Likewise.\n+\t(pack_ts_decl_wrtl_value_fields): Likewise.\n+\t(pack_ts_decl_with_vis_value_fields): Likewise.\n+\t(pack_ts_function_decl_value_fields): Likewise.\n+\t(pack_ts_type_common_value_fields): Likewise.\n+\t(pack_ts_block_value_fields): Likewise.\n+\t(pack_ts_translation_unit_decl_value_fields): Likewise.\n+\t(pack_value_fields): Likewise.\n+\t(lto_output_chain): Likewise.\n+\t(lto_output_ts_common_tree_pointers): Likewise.\n+\t(lto_output_ts_vector_tree_pointers): Likewise.\n+\t(lto_output_ts_complex_tree_pointers): Likewise.\n+\t(lto_output_ts_decl_minimal_tree_pointers): Likewise.\n+\t(lto_output_ts_decl_common_tree_pointers): Likewise.\n+\t(lto_output_ts_decl_non_common_tree_pointers): Likewise.\n+\t(lto_output_ts_decl_with_vis_tree_pointers): Likewise.\n+\t(lto_output_ts_field_decl_tree_pointers): Likewise.\n+\t(lto_output_ts_function_decl_tree_pointers): Likewise.\n+\t(lto_output_ts_type_common_tree_pointers): Likewise.\n+\t(lto_output_ts_type_non_common_tree_pointers): Likewise.\n+\t(lto_output_ts_list_tree_pointers): Likewise.\n+\t(lto_output_ts_vec_tree_pointers): Likewise.\n+\t(lto_output_ts_exp_tree_pointers): Likewise.\n+\t(lto_output_ts_block_tree_pointers): Likewise.\n+\t(lto_output_ts_binfo_tree_pointers): Likewise.\n+\t(lto_output_ts_constructor_tree_pointers): Likewise.\n+\t(lto_output_ts_target_option): Likewise.\n+\t(lto_output_ts_translation_unit_decl_tree_pointers): Likewise.\n+\t(lto_output_tree_pointers): Likewise.\n+\t(lto_output_tree_header): Likewise.\n+\t(lto_output_builtin_tree): Likewise.\n+\t(lto_write_tree): Likewise.\n+\t(lto_output_integer_cst): Likewise.\n+\t(lto_output_tree): Likewise.\n+\t(output_phi): Move to gimple-streamer-out.c.\n+\t(output_gimple_stmt): Likewise.\n+\t(output_bb): Likewise.\n+\t* lto-streamer.c: Include tree-streamer.h and streamer-hooks.h.\n+\t(streamer_hooks): Move to streamer-hooks.c.\n+\t(check_handled_ts_structures): Move to tree-streamer.c\n+\t(lto_streamer_cache_add_to_node_array): Likewise.\n+\t(lto_streamer_cache_insert_1): Likewise.\n+\t(lto_streamer_cache_insert): Likewise.\n+\t(lto_streamer_cache_insert_at): Likewise.\n+\t(lto_streamer_cache_append): Likewise.\n+\t(lto_streamer_cache_lookup): Likewise.\n+\t(lto_streamer_cache_get): Likewise.\n+\t(lto_record_common_node): Likewise.\n+\t(lto_preload_common_nodes): Likewise.\n+\t(lto_streamer_cache_create): Likewise.\n+\t(lto_streamer_cache_delete): Likewise.\n+\t(streamer_hooks_init): Move to streamer-hooks.c.\n+\t* lto-streamer.h: Include diagnostic.h\n+\t(struct output_block, struct lto_input_block,\n+\tstruct data_in, struct bitpack_d): Remove forward\n+\tdeclarations.\n+\t(struct bitpack_d): Move to data-streamer.h.\n+\t(struct lto_streamer_cache_d): Move to tree-streamer.h.\n+\t(struct streamer_hooks): Move to streamer-hooks.h.\n+\t(bp_pack_var_len_unsigned): Move to data-streamer.h.\n+\t(bp_pack_var_len_int): Likewise.\n+\t(bp_unpack_var_len_unsigned): Likewise.\n+\t(bp_unpack_var_len_int): Likewise.\n+\t(lto_input_location): Declare.\n+\t(lto_tag_check_set): Declare.\n+\t(lto_init_eh): Declare.\n+\t(lto_output_tree_ref): Declare.\n+\t(lto_output_location): Declare.\n+\t(bitpack_create): Move to data-streamer.h.\n+\t(bp_pack_value): Likewise.\n+\t(lto_output_bitpack): Likewise.\n+\t(lto_input_bitpack): Likewise.\n+\t(bp_unpack_value): Likewise.\n+\t(lto_output_1_stream): Likewise.\n+\t(lto_input_1_unsigned): Likewise.\n+\t(lto_output_int_in_range): Likewise.\n+\t(lto_input_int_in_range): Likewise.\n+\t(bp_pack_int_in_range): Likewise.\n+\t(bp_unpack_int_in_range): Likewise.\n+\t(lto_output_enum): Likewise.\n+\t(lto_input_enum): Likewise.\n+\t(bp_pack_enum): Likewise.\n+\t(bp_unpack_enum): Likewise.\n+\t* streamer-hooks.c: New.\n+\t* streamer-hooks.h: New.\n+\t* tree-streamer-in.c: New.\n+\t* tree-streamer-out.c: New.\n+\t* tree-streamer.c: New.\n+\t* tree-streamer.h: New.\n+\n 2011-08-08  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* gthr-posix95.h: Remove."}, {"sha": "fd9c0c1d620b43faf942db04e97aa3b61789266e", "filename": "gcc/Makefile.in", "status": "modified", "additions": 52, "deletions": 10, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f0efc7aa7705facdb16a39a08137cf748c7d5f30", "patch": "@@ -995,7 +995,12 @@ DBGCNT_H = dbgcnt.h dbgcnt.def\n EBITMAP_H = ebitmap.h sbitmap.h\n LTO_STREAMER_H = lto-streamer.h $(LINKER_PLUGIN_API_H) $(TARGET_H) \\\n \t\t$(CGRAPH_H) $(VEC_H) vecprim.h $(TREE_H) $(GIMPLE_H) \\\n-\t\t$(GCOV_IO_H)\n+\t\t$(GCOV_IO_H) $(DIAGNOSTIC_H)\n+DATA_STREAMER_H = data-streamer.h $(VEC_H) $(LTO_STREAMER_H)\n+GIMPLE_STREAMER_H = gimple-streamer.h $(LTO_STREAMER_H) $(BASIC_BLOCK_H) \\\n+\t\t    $(FUNCTION_H)\n+TREE_STREAMER_H = tree-streamer.h $(TREE_H) $(LTO_STREAMER_H)\n+STREAMER_HOOKS_H = streamer-hooks.h $(TREE_H)\n TREE_VECTORIZER_H = tree-vectorizer.h $(TREE_DATA_REF_H)\n IPA_PROP_H = ipa-prop.h $(TREE_H) $(VEC_H) $(CGRAPH_H) $(GIMPLE_H) alloc-pool.h\n GSTAB_H = gstab.h stab.def\n@@ -1239,6 +1244,9 @@ OBJS = \\\n \tcprop.o \\\n \tcse.o \\\n \tcselib.o \\\n+\tdata-streamer.o \\\n+\tdata-streamer-in.o \\\n+\tdata-streamer-out.o \\\n \tdbxout.o \\\n \tdbgcnt.o \\\n \tdce.o \\\n@@ -1275,6 +1283,8 @@ OBJS = \\\n \tgimple-fold.o \\\n \tgimple-low.o \\\n \tgimple-pretty-print.o \\\n+\tgimple-streamer-in.o \\\n+\tgimple-streamer-out.o \\\n \tgimplify.o \\\n \tgodump.o \\\n \tgraph.o \\\n@@ -1330,13 +1340,13 @@ OBJS = \\\n \tloop-unswitch.o \\\n \tlower-subreg.o \\\n \tlto-cgraph.o \\\n+\tlto-streamer.o \\\n \tlto-streamer-in.o \\\n \tlto-streamer-out.o \\\n \tlto-section-in.o \\\n \tlto-section-out.o \\\n \tlto-symtab.o \\\n \tlto-opts.o \\\n-\tlto-streamer.o \\\n \tlto-compress.o \\\n \tmatrix-reorg.o \\\n \tmcf.o \\\n@@ -1391,6 +1401,7 @@ OBJS = \\\n \tstmt.o \\\n \tstor-layout.o \\\n \tstore-motion.o \\\n+\tstreamer-hooks.o \\\n \tstringpool.o \\\n \ttarget-globals.o \\\n \ttarghooks.o \\\n@@ -1467,6 +1478,9 @@ OBJS = \\\n \ttree-ssa.o \\\n \ttree-ssanames.o \\\n \ttree-stdarg.o \\\n+\ttree-streamer.o \\\n+\ttree-streamer-in.o \\\n+\ttree-streamer-out.o \\\n \ttree-tailcall.o \\\n \ttree-vect-generic.o \\\n \ttree-vect-patterns.o \\\n@@ -2281,22 +2295,47 @@ lto-compress.o: lto-compress.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n \t$(TREE_H) langhooks.h $(LTO_STREAMER_H) $(LTO_SECTION_H) \\\n \tlto-compress.h $(DIAGNOSTIC_CORE_H) $(DIAGNOSTIC_CORE_H)\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(ZLIBINC) $< $(OUTPUT_OPTION)\n-\n+data-streamer-in.o: data-streamer-in.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+    $(DATA_STREAMER_H) $(DIAGNOSTIC_H)\n+data-streamer-out.o: data-streamer-out.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+    $(DATA_STREAMER_H)\n+data-streamer.o: data-streamer.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+    $(DATA_STREAMER_H)\n+gimple-streamer-in.o: gimple-streamer-in.c $(CONFIG_H) $(SYSTEM_H) \\\n+    coretypes.h $(GIMPLE_STREAMER_H) $(TREE_FLOW_H) $(DATA_STREAMER_H) \\\n+    $(TREE_STREAMER_H) $(DIAGNOSTIC_H)\n+gimple-streamer-out.o: gimple-streamer-out.c $(CONFIG_H) $(SYSTEM_H) \\\n+    coretypes.h $(GIMPLE_STREAMER_H) $(DATA_STREAMER_H) $(TREE_FLOW_H) \\\n+    $(LTO_STREAMER_H)\n+tree-streamer.o: tree-streamer.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+    $(TREE_STREAMER_H) $(STREAMER_HOOKS_H)\n+tree-streamer-in.o: tree-streamer-in.c $(CONFIG_H) $(SYSTEM_H) \\\n+    coretypes.h $(DIAGNOSTIC_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_STREAMER_H) \\\n+    $(DATA_STREAMER_H) $(STREAMER_HOOKS_H) $(LTO_STREAMER_H)\n+tree-streamer-out.o: tree-streamer-out.c $(CONFIG_H) $(SYSTEM_H) \\\n+    coretypes.h $(DIAGNOSTIC_H) $(TREE_STREAMER_H) $(DATA_STREAMER_H) \\\n+    $(STREAMER_HOOKS_H)\n+streamer-hooks.o: streamer-hooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+    $(STREAMER_HOOKS_H)\n lto-cgraph.o: lto-cgraph.c $(CONFIG_H) $(SYSTEM_H) coretypes.h   \\\n    $(TM_H) $(DIAGNOSTIC_CORE_H) $(EXPR_H) $(FLAGS_H) $(PARAMS_H) input.h \\\n    $(HASHTAB_H) langhooks.h $(BASIC_BLOCK_H) \\\n    $(TREE_FLOW_H) $(CGRAPH_H) $(FUNCTION_H) $(GGC_H) $(DIAGNOSTIC_CORE_H) \\\n-   $(EXCEPT_H) $(TIMEVAR_H) output.h pointer-set.h $(LTO_STREAMER_H) $(GCOV_IO_H)\n+   $(EXCEPT_H) $(TIMEVAR_H) output.h pointer-set.h $(LTO_STREAMER_H) \\\n+   $(GCOV_IO_H) $(DATA_STREAMER_H) $(TREE_STREAMER_H)\n lto-streamer-in.o: lto-streamer-in.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) toplev.h $(DIAGNOSTIC_CORE_H) $(EXPR_H) $(FLAGS_H) $(PARAMS_H) input.h \\\n    $(HASHTAB_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) $(TREE_PASS_H) $(CGRAPH_H) \\\n    $(FUNCTION_H) $(GGC_H) $(DIAGNOSTIC_H) $(LIBFUNCS_H) $(EXCEPT_H) debug.h \\\n-   $(TIMEVAR_H) output.h $(IPA_UTILS_H) $(LTO_STREAMER_H) toplev.h\n+   $(TIMEVAR_H) output.h $(IPA_UTILS_H) $(LTO_STREAMER_H) toplev.h \\\n+   $(DATA_STREAMER_H) $(GIMPLE_STREAMER_H) $(TREE_STREAMER_H)\n lto-streamer-out.o : lto-streamer-out.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(DIAGNOSTIC_CORE_H) $(TREE_H) $(EXPR_H) $(FLAGS_H) $(PARAMS_H) input.h \\\n    $(HASHTAB_H) $(BASIC_BLOCK_H) tree-iterator.h \\\n    $(TREE_FLOW_H) $(TREE_PASS_H) $(CGRAPH_H) $(FUNCTION_H) $(GGC_H) \\\n-   $(DIAGNOSTIC_CORE_H) $(EXCEPT_H) $(LTO_STREAMER_H) $(DIAGNOSTIC_CORE_H)\n+   $(DIAGNOSTIC_CORE_H) $(EXCEPT_H) $(LTO_STREAMER_H) $(DIAGNOSTIC_CORE_H) \\\n+   $(DATA_STREAMER_H) $(STREAMER_HOOKS_H) $(GIMPLE_STREAMER_H) \\\n+   $(TREE_STREAMER_H)\n lto-section-in.o: lto-section-in.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(DIAGNOSTIC_CORE_H) $(EXPR_H) $(FLAGS_H) $(PARAMS_H) input.h \\\n    $(HASHTAB_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) $(CGRAPH_H) $(FUNCTION_H) \\\n@@ -2315,7 +2354,8 @@ lto-opts.o: lto-opts.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \\\n    $(COMMON_TARGET_H) $(DIAGNOSTIC_H) $(LTO_STREAMER_H)\n lto-streamer.o: lto-streamer.c $(CONFIG_H) $(SYSTEM_H) coretypes.h   \\\n    $(TM_H) $(TREE_H) $(GIMPLE_H) $(BITMAP_H) $(LTO_STREAMER_H) $(FLAGS_H) \\\n-   $(TREE_FLOW_H) $(DIAGNOSTIC_CORE_H) $(LTO_SYMTAB_H) toplev.h $(DIAGNOSTIC_CORE_H)\n+   $(TREE_FLOW_H) $(DIAGNOSTIC_CORE_H) $(LTO_SYMTAB_H) toplev.h \\\n+   $(DIAGNOSTIC_CORE_H) $(STREAMER_HOOKS_H)\n langhooks.o : langhooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) toplev.h $(DIAGNOSTIC_CORE_H) $(TREE_INLINE_H) $(RTL_H) insn-config.h $(INTEGRATE_H) \\\n    langhooks.h $(TARGET_H) $(LANGHOOKS_DEF_H) $(FLAGS_H) $(GGC_H) $(DIAGNOSTIC_H) \\\n@@ -2995,7 +3035,8 @@ ipa-prop.o : ipa-prop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    langhooks.h $(GGC_H) $(TARGET_H) $(CGRAPH_H) $(IPA_PROP_H) $(DIAGNOSTIC_H) \\\n    $(TREE_FLOW_H) $(TM_H) $(TREE_PASS_H) $(FLAGS_H) $(TREE_H) \\\n    $(TREE_INLINE_H) $(GIMPLE_H) $(TIMEVAR_H) \\\n-   tree-pretty-print.h gimple-pretty-print.h $(LTO_STREAMER_H)\n+   tree-pretty-print.h gimple-pretty-print.h $(LTO_STREAMER_H) \\\n+   $(DATA_STREAMER_H) $(TREE_STREAMER_H)\n ipa-ref.o : ipa-ref.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    langhooks.h $(GGC_H) $(TARGET_H) $(CGRAPH_H)  $(TREE_H) $(TARGET_H) \\\n    $(TREE_FLOW_H) $(TM_H) $(TREE_PASS_H) $(FLAGS_H) $(TREE_H) $(GGC_H) \n@@ -3023,7 +3064,8 @@ ipa-inline-analysis.o : ipa-inline-analysis.c $(CONFIG_H) $(SYSTEM_H) coretypes.\n    $(TREE_H) langhooks.h $(TREE_INLINE_H) $(FLAGS_H) $(CGRAPH_H) intl.h \\\n    $(DIAGNOSTIC_H) $(PARAMS_H) $(TIMEVAR_H) $(TREE_PASS_H) \\\n    $(HASHTAB_H) $(COVERAGE_H) $(GGC_H) $(TREE_FLOW_H) $(IPA_PROP_H) \\\n-   gimple-pretty-print.h ipa-inline.h $(LTO_STREAMER_H)\n+   gimple-pretty-print.h ipa-inline.h $(LTO_STREAMER_H) $(DATA_STREAMER_H) \\\n+   $(TREE_STREAMER_H)\n ipa-inline-transform.o : ipa-inline-transform.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h $(TREE_INLINE_H) $(FLAGS_H) $(CGRAPH_H) intl.h \\\n    $(DIAGNOSTIC_H) $(PARAMS_H) $(TIMEVAR_H) $(TREE_PASS_H) \\\n@@ -3043,7 +3085,7 @@ ipa-pure-const.o : ipa-pure-const.c $(CONFIG_H) $(SYSTEM_H) \\\n    pointer-set.h $(GGC_H) $(IPA_UTILS_H) $(TARGET_H) \\\n    $(GIMPLE_H) $(CGRAPH_H) output.h $(FLAGS_H) $(TREE_PASS_H) $(TIMEVAR_H) \\\n    $(DIAGNOSTIC_H) $(CFGLOOP_H) $(SCEV_H) $(LTO_STREAMER_H) \\\n-   gimple-pretty-print.h\n+   gimple-pretty-print.h $(DATA_STREAMER_H) $(TREE_STREAMER_H)\n coverage.o : coverage.c $(GCOV_IO_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(RTL_H) $(TREE_H) $(FLAGS_H) output.h $(REGS_H) $(EXPR_H) \\\n    $(FUNCTION_H) $(BASIC_BLOCK_H) toplev.h $(DIAGNOSTIC_CORE_H) $(GGC_H) langhooks.h $(COVERAGE_H) \\"}, {"sha": "5e366b11f1a1f8ea58abf7a28bea703753362ac9", "filename": "gcc/data-streamer-in.c", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Fdata-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Fdata-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdata-streamer-in.c?ref=f0efc7aa7705facdb16a39a08137cf748c7d5f30", "patch": "@@ -0,0 +1,152 @@\n+/* Routines for restoring various data types from a file stream.  This deals\n+   with various data types like strings, integers, enums, etc.\n+\n+   Copyright 2011 Free Software Foundation, Inc.\n+   Contributed by Diego Novillo <dnovillo@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"diagnostic.h\"\n+#include \"data-streamer.h\"\n+\n+/* Read a string from the string table in DATA_IN using input block\n+   IB.  Write the length to RLEN.  */\n+\n+const char *\n+string_for_index (struct data_in *data_in, unsigned int loc, unsigned int *rlen)\n+{\n+  struct lto_input_block str_tab;\n+  unsigned int len;\n+  const char *result;\n+\n+  if (!loc)\n+    {\n+      *rlen = 0;\n+      return NULL;\n+    }\n+\n+  /* Get the string stored at location LOC in DATA_IN->STRINGS.  */\n+  LTO_INIT_INPUT_BLOCK (str_tab, data_in->strings, loc - 1,\n+\t\t\tdata_in->strings_len);\n+  len = lto_input_uleb128 (&str_tab);\n+  *rlen = len;\n+\n+  if (str_tab.p + len > data_in->strings_len)\n+    internal_error (\"bytecode stream: string too long for the string table\");\n+\n+  result = (const char *)(data_in->strings + str_tab.p);\n+\n+  return result;\n+}\n+\n+\n+/* Read a string from the string table in DATA_IN using input block\n+   IB.  Write the length to RLEN.  */\n+\n+const char *\n+input_string_internal (struct data_in *data_in, struct lto_input_block *ib,\n+\t\t       unsigned int *rlen)\n+{\n+  return string_for_index (data_in, lto_input_uleb128 (ib), rlen);\n+}\n+\n+\n+/* Read a NULL terminated string from the string table in DATA_IN.  */\n+\n+const char *\n+lto_input_string (struct data_in *data_in, struct lto_input_block *ib)\n+{\n+  unsigned int len;\n+  const char *ptr;\n+\n+  ptr = input_string_internal (data_in, ib, &len);\n+  if (!ptr)\n+    return NULL;\n+  if (ptr[len - 1] != '\\0')\n+    internal_error (\"bytecode stream: found non-null terminated string\");\n+\n+  return ptr;\n+}\n+\n+\n+/* Read an ULEB128 Number of IB.  */\n+\n+unsigned HOST_WIDE_INT\n+lto_input_uleb128 (struct lto_input_block *ib)\n+{\n+  unsigned HOST_WIDE_INT result = 0;\n+  int shift = 0;\n+  unsigned HOST_WIDE_INT byte;\n+\n+  while (true)\n+    {\n+      byte = lto_input_1_unsigned (ib);\n+      result |= (byte & 0x7f) << shift;\n+      shift += 7;\n+      if ((byte & 0x80) == 0)\n+\treturn result;\n+    }\n+}\n+\n+\n+/* HOST_WIDEST_INT version of lto_input_uleb128.  IB is as in\n+   lto_input_uleb128.  */\n+\n+unsigned HOST_WIDEST_INT\n+lto_input_widest_uint_uleb128 (struct lto_input_block *ib)\n+{\n+  unsigned HOST_WIDEST_INT result = 0;\n+  int shift = 0;\n+  unsigned HOST_WIDEST_INT byte;\n+\n+  while (true)\n+    {\n+      byte = lto_input_1_unsigned (ib);\n+      result |= (byte & 0x7f) << shift;\n+      shift += 7;\n+      if ((byte & 0x80) == 0)\n+\treturn result;\n+    }\n+}\n+\n+\n+/* Read an SLEB128 Number of IB.  */\n+\n+HOST_WIDE_INT\n+lto_input_sleb128 (struct lto_input_block *ib)\n+{\n+  HOST_WIDE_INT result = 0;\n+  int shift = 0;\n+  unsigned HOST_WIDE_INT byte;\n+\n+  while (true)\n+    {\n+      byte = lto_input_1_unsigned (ib);\n+      result |= (byte & 0x7f) << shift;\n+      shift += 7;\n+      if ((byte & 0x80) == 0)\n+\t{\n+\t  if ((shift < HOST_BITS_PER_WIDE_INT) && (byte & 0x40))\n+\t    result |= - ((HOST_WIDE_INT)1 << shift);\n+\n+\t  return result;\n+\t}\n+    }\n+}"}, {"sha": "07d5b35fba31487bc1a9effd12f2f9a6f97a44bb", "filename": "gcc/data-streamer-out.c", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Fdata-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Fdata-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdata-streamer-out.c?ref=f0efc7aa7705facdb16a39a08137cf748c7d5f30", "patch": "@@ -0,0 +1,207 @@\n+/* Routines for saving various data types to a file stream.  This deals\n+   with various data types like strings, integers, enums, etc.\n+\n+   Copyright 2011 Free Software Foundation, Inc.\n+   Contributed by Diego Novillo <dnovillo@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"data-streamer.h\"\n+\n+/* Return index used to reference STRING of LEN characters in the string table\n+   in OB.  The string might or might not include a trailing '\\0'.\n+   Then put the index onto the INDEX_STREAM.  \n+   When PERSISTENT is set, the string S is supposed to not change during\n+   duration of the OB and thus OB can keep pointer into it.  */\n+\n+unsigned\n+lto_string_index (struct output_block *ob, const char *s, unsigned int len,\n+\t\t  bool persistent)\n+{\n+  struct string_slot **slot;\n+  struct string_slot s_slot;\n+\n+  s_slot.s = s;\n+  s_slot.len = len;\n+  s_slot.slot_num = 0;\n+\n+  slot = (struct string_slot **) htab_find_slot (ob->string_hash_table,\n+\t\t\t\t\t\t &s_slot, INSERT);\n+  if (*slot == NULL)\n+    {\n+      struct lto_output_stream *string_stream = ob->string_stream;\n+      unsigned int start = string_stream->total_size;\n+      struct string_slot *new_slot = XOBNEW (&ob->obstack, struct string_slot);\n+      const char *string;\n+\n+      if (!persistent)\n+\t{\n+\t  char *tmp;\n+\t  string = tmp = XOBNEWVEC (&ob->obstack, char, len);\n+          memcpy (tmp, s, len);\n+        }\n+      else\n+\tstring = s;\n+\n+      new_slot->s = string;\n+      new_slot->len = len;\n+      new_slot->slot_num = start;\n+      *slot = new_slot;\n+      lto_output_uleb128_stream (string_stream, len);\n+      lto_output_data_stream (string_stream, string, len);\n+      return start + 1;\n+    }\n+  else\n+    {\n+      struct string_slot *old_slot = *slot;\n+      return old_slot->slot_num + 1;\n+    }\n+}\n+\n+\n+/* Output STRING of LEN characters to the string table in OB. The\n+   string might or might not include a trailing '\\0'. Then put the\n+   index onto the INDEX_STREAM. \n+   When PERSISTENT is set, the string S is supposed to not change during\n+   duration of the OB and thus OB can keep pointer into it.  */\n+\n+void\n+lto_output_string_with_length (struct output_block *ob,\n+\t\t\t       struct lto_output_stream *index_stream,\n+\t\t\t       const char *s, unsigned int len, bool persistent)\n+{\n+  if (s)\n+    lto_output_uleb128_stream (index_stream,\n+\t\t\t       lto_string_index (ob, s, len, persistent));\n+  else\n+    lto_output_1_stream (index_stream, 0);\n+}\n+\n+\n+/* Output the '\\0' terminated STRING to the string\n+   table in OB.  Then put the index onto the INDEX_STREAM.\n+   When PERSISTENT is set, the string S is supposed to not change during\n+   duration of the OB and thus OB can keep pointer into it.  */\n+\n+void\n+lto_output_string (struct output_block *ob,\n+\t           struct lto_output_stream *index_stream,\n+\t           const char *string, bool persistent)\n+{\n+  if (string)\n+    lto_output_string_with_length (ob, index_stream, string,\n+\t\t\t\t   strlen (string) + 1,\n+\t\t\t\t   persistent);\n+  else\n+    lto_output_1_stream (index_stream, 0);\n+}\n+\n+\n+/* Write a zero to the output stream.  */\n+\n+void\n+output_zero (struct output_block *ob)\n+{\n+  lto_output_1_stream (ob->main_stream, 0);\n+}\n+\n+\n+/* Output an unsigned LEB128 quantity to OB->main_stream.  */\n+\n+void\n+output_uleb128 (struct output_block *ob, unsigned HOST_WIDE_INT work)\n+{\n+  lto_output_uleb128_stream (ob->main_stream, work);\n+}\n+\n+\n+/* Output a signed LEB128 quantity to OB->main_stream.  */\n+\n+void\n+output_sleb128 (struct output_block *ob, HOST_WIDE_INT work)\n+{\n+  lto_output_sleb128_stream (ob->main_stream, work);\n+}\n+\n+\n+/* Output an unsigned LEB128 quantity to OBS.  */\n+\n+void\n+lto_output_uleb128_stream (struct lto_output_stream *obs,\n+\t\t\t   unsigned HOST_WIDE_INT work)\n+{\n+  do\n+    {\n+      unsigned int byte = (work & 0x7f);\n+      work >>= 7;\n+      if (work != 0)\n+\t/* More bytes to follow.  */\n+\tbyte |= 0x80;\n+\n+      lto_output_1_stream (obs, byte);\n+    }\n+  while (work != 0);\n+}\n+\n+\n+/* Identical to output_uleb128_stream above except using unsigned\n+   HOST_WIDEST_INT type.  For efficiency on host where unsigned HOST_WIDEST_INT\n+   is not native, we only use this if we know that HOST_WIDE_INT is not wide\n+   enough.  */\n+\n+void\n+lto_output_widest_uint_uleb128_stream (struct lto_output_stream *obs,\n+\t\t\t\t       unsigned HOST_WIDEST_INT work)\n+{\n+  do\n+    {\n+      unsigned int byte = (work & 0x7f);\n+      work >>= 7;\n+      if (work != 0)\n+\t/* More bytes to follow.  */\n+\tbyte |= 0x80;\n+\n+      lto_output_1_stream (obs, byte);\n+    }\n+  while (work != 0);\n+}\n+\n+\n+/* Output a signed LEB128 quantity.  */\n+\n+void\n+lto_output_sleb128_stream (struct lto_output_stream *obs, HOST_WIDE_INT work)\n+{\n+  int more, byte;\n+\n+  do\n+    {\n+      byte = (work & 0x7f);\n+      /* arithmetic shift */\n+      work >>= 7;\n+      more = !((work == 0 && (byte & 0x40) == 0)\n+\t       || (work == -1 && (byte & 0x40) != 0));\n+      if (more)\n+\tbyte |= 0x80;\n+\n+      lto_output_1_stream (obs, byte);\n+    }\n+  while (more);\n+}"}, {"sha": "5eaacfcad1b21d9da7b7f5e2685f3c302ff6778e", "filename": "gcc/data-streamer.c", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Fdata-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Fdata-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdata-streamer.c?ref=f0efc7aa7705facdb16a39a08137cf748c7d5f30", "patch": "@@ -0,0 +1,111 @@\n+/* Generic streaming support for basic data types.\n+\n+   Copyright 2011 Free Software Foundation, Inc.\n+   Contributed by Diego Novillo <dnovillo@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"data-streamer.h\"\n+\n+/* Pack WORK into BP in a variant of uleb format.  */\n+\n+void\n+bp_pack_var_len_unsigned (struct bitpack_d *bp, unsigned HOST_WIDE_INT work)\n+{\n+  do\n+    {\n+      unsigned int half_byte = (work & 0x7);\n+      work >>= 3;\n+      if (work != 0)\n+\t/* More half_bytes to follow.  */\n+\thalf_byte |= 0x8;\n+\n+      bp_pack_value (bp, half_byte, 4);\n+    }\n+  while (work != 0);\n+}\n+\n+\n+/* Pack WORK into BP in a variant of sleb format.  */\n+\n+void\n+bp_pack_var_len_int (struct bitpack_d *bp, HOST_WIDE_INT work)\n+{\n+  int more, half_byte;\n+\n+  do\n+    {\n+      half_byte = (work & 0x7);\n+      /* arithmetic shift */\n+      work >>= 3;\n+      more = !((work == 0 && (half_byte & 0x4) == 0)\n+\t       || (work == -1 && (half_byte & 0x4) != 0));\n+      if (more)\n+\thalf_byte |= 0x8;\n+\n+      bp_pack_value (bp, half_byte, 4);\n+    }\n+  while (more);\n+}\n+\n+\n+/* Unpack VAL from BP in a variant of uleb format.  */\n+\n+unsigned HOST_WIDE_INT\n+bp_unpack_var_len_unsigned (struct bitpack_d *bp)\n+{\n+  unsigned HOST_WIDE_INT result = 0;\n+  int shift = 0;\n+  unsigned HOST_WIDE_INT half_byte;\n+\n+  while (true)\n+    {\n+      half_byte = bp_unpack_value (bp, 4);\n+      result |= (half_byte & 0x7) << shift;\n+      shift += 3;\n+      if ((half_byte & 0x8) == 0)\n+\treturn result;\n+    }\n+}\n+\n+\n+/* Unpack VAL from BP in a variant of sleb format.  */\n+\n+HOST_WIDE_INT\n+bp_unpack_var_len_int (struct bitpack_d *bp)\n+{\n+  HOST_WIDE_INT result = 0;\n+  int shift = 0;\n+  unsigned HOST_WIDE_INT half_byte;\n+\n+  while (true)\n+    {\n+      half_byte = bp_unpack_value (bp, 4);\n+      result |= (half_byte & 0x7) << shift;\n+      shift += 3;\n+      if ((half_byte & 0x8) == 0)\n+\t{\n+\t  if ((shift < HOST_BITS_PER_WIDE_INT) && (half_byte & 0x4))\n+\t    result |= - ((HOST_WIDE_INT)1 << shift);\n+\n+\t  return result;\n+\t}\n+    }\n+}"}, {"sha": "c2f6fa81fb545ea2669e14839063dfaefd35c96e", "filename": "gcc/data-streamer.h", "status": "added", "additions": 355, "deletions": 0, "changes": 355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Fdata-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Fdata-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdata-streamer.h?ref=f0efc7aa7705facdb16a39a08137cf748c7d5f30", "patch": "@@ -0,0 +1,355 @@\n+/* Generic streaming support for various data types.\n+\n+   Copyright 2011 Free Software Foundation, Inc.\n+   Contributed by Diego Novillo <dnovillo@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_DATA_STREAMER_H\n+#define GCC_DATA_STREAMER_H\n+\n+#include \"vec.h\"\n+#include \"lto-streamer.h\"\n+\n+/* Data structures used to pack values and bitflags into a vector of\n+   words.  Used to stream values of a fixed number of bits in a space\n+   efficient way.  */\n+static unsigned const BITS_PER_BITPACK_WORD = HOST_BITS_PER_WIDE_INT;\n+\n+typedef unsigned HOST_WIDE_INT bitpack_word_t;\n+DEF_VEC_I(bitpack_word_t);\n+DEF_VEC_ALLOC_I(bitpack_word_t, heap);\n+\n+struct bitpack_d\n+{\n+  /* The position of the first unused or unconsumed bit in the word.  */\n+  unsigned pos;\n+\n+  /* The current word we are (un)packing.  */\n+  bitpack_word_t word;\n+\n+  /* The lto_output_stream or the lto_input_block we are streaming to/from.  */\n+  void *stream;\n+};\n+\n+\n+/* String hashing.  */\n+struct string_slot\n+{\n+  const char *s;\n+  int len;\n+  unsigned int slot_num;\n+};\n+\n+\n+/* Returns a hash code for P.  Adapted from libiberty's htab_hash_string\n+   to support strings that may not end in '\\0'.  */\n+\n+static inline hashval_t\n+hash_string_slot_node (const void *p)\n+{\n+  const struct string_slot *ds = (const struct string_slot *) p;\n+  hashval_t r = ds->len;\n+  int i;\n+\n+  for (i = 0; i < ds->len; i++)\n+     r = r * 67 + (unsigned)ds->s[i] - 113;\n+  return r;\n+}\n+\n+/* Returns nonzero if P1 and P2 are equal.  */\n+\n+static inline int\n+eq_string_slot_node (const void *p1, const void *p2)\n+{\n+  const struct string_slot *ds1 = (const struct string_slot *) p1;\n+  const struct string_slot *ds2 = (const struct string_slot *) p2;\n+\n+  if (ds1->len == ds2->len)\n+    return memcmp (ds1->s, ds2->s, ds1->len) == 0;\n+\n+  return 0;\n+}\n+\n+/* Returns a new bit-packing context for bit-packing into S.  */\n+static inline struct bitpack_d\n+bitpack_create (struct lto_output_stream *s)\n+{\n+  struct bitpack_d bp;\n+  bp.pos = 0;\n+  bp.word = 0;\n+  bp.stream = (void *)s;\n+  return bp;\n+}\n+\n+/* Pack the NBITS bit sized value VAL into the bit-packing context BP.  */\n+static inline void\n+bp_pack_value (struct bitpack_d *bp, bitpack_word_t val, unsigned nbits)\n+{\n+  bitpack_word_t word = bp->word;\n+  int pos = bp->pos;\n+\n+  /* Verify that VAL fits in the NBITS.  */\n+  gcc_checking_assert (nbits == BITS_PER_BITPACK_WORD\n+\t\t       || !(val & ~(((bitpack_word_t)1<<nbits)-1)));\n+\n+  /* If val does not fit into the current bitpack word switch to the\n+     next one.  */\n+  if (pos + nbits > BITS_PER_BITPACK_WORD)\n+    {\n+      lto_output_uleb128_stream ((struct lto_output_stream *) bp->stream, word);\n+      word = val;\n+      pos = nbits;\n+    }\n+  else\n+    {\n+      word |= val << pos;\n+      pos += nbits;\n+    }\n+  bp->word = word;\n+  bp->pos = pos;\n+}\n+\n+/* Finishes bit-packing of BP.  */\n+static inline void\n+lto_output_bitpack (struct bitpack_d *bp)\n+{\n+  lto_output_uleb128_stream ((struct lto_output_stream *) bp->stream,\n+\t\t\t     bp->word);\n+  bp->word = 0;\n+  bp->pos = 0;\n+}\n+\n+/* Returns a new bit-packing context for bit-unpacking from IB.  */\n+static inline struct bitpack_d\n+lto_input_bitpack (struct lto_input_block *ib)\n+{\n+  struct bitpack_d bp;\n+  bp.word = lto_input_uleb128 (ib);\n+  bp.pos = 0;\n+  bp.stream = (void *)ib;\n+  return bp;\n+}\n+\n+/* Unpacks NBITS bits from the bit-packing context BP and returns them.  */\n+static inline bitpack_word_t\n+bp_unpack_value (struct bitpack_d *bp, unsigned nbits)\n+{\n+  bitpack_word_t mask, val;\n+  int pos = bp->pos;\n+\n+  mask = (nbits == BITS_PER_BITPACK_WORD\n+\t  ? (bitpack_word_t) -1\n+\t  : ((bitpack_word_t) 1 << nbits) - 1);\n+\n+  /* If there are not continuous nbits in the current bitpack word\n+     switch to the next one.  */\n+  if (pos + nbits > BITS_PER_BITPACK_WORD)\n+    {\n+      bp->word = val = lto_input_uleb128 ((struct lto_input_block *)bp->stream);\n+      bp->pos = nbits;\n+      return val & mask;\n+    }\n+  val = bp->word;\n+  val >>= pos;\n+  bp->pos = pos + nbits;\n+\n+  return val & mask;\n+}\n+\n+\n+/* Write a character to the output block.  */\n+\n+static inline void\n+lto_output_1_stream (struct lto_output_stream *obs, char c)\n+{\n+  /* No space left.  */\n+  if (obs->left_in_block == 0)\n+    lto_append_block (obs);\n+\n+  /* Write the actual character.  */\n+  *obs->current_pointer = c;\n+  obs->current_pointer++;\n+  obs->total_size++;\n+  obs->left_in_block--;\n+}\n+\n+\n+/* Read byte from the input block.  */\n+\n+static inline unsigned char\n+lto_input_1_unsigned (struct lto_input_block *ib)\n+{\n+  if (ib->p >= ib->len)\n+    lto_section_overrun (ib);\n+  return (ib->data[ib->p++]);\n+}\n+\n+/* Output VAL into OBS and verify it is in range MIN...MAX that is supposed\n+   to be compile time constant.\n+   Be host independent, limit range to 31bits.  */\n+\n+static inline void\n+lto_output_int_in_range (struct lto_output_stream *obs,\n+\t\t\t HOST_WIDE_INT min,\n+\t\t\t HOST_WIDE_INT max,\n+\t\t\t HOST_WIDE_INT val)\n+{\n+  HOST_WIDE_INT range = max - min;\n+\n+  gcc_checking_assert (val >= min && val <= max && range > 0\n+\t\t       && range < 0x7fffffff);\n+\n+  val -= min;\n+  lto_output_1_stream (obs, val & 255);\n+  if (range >= 0xff)\n+    lto_output_1_stream (obs, (val >> 8) & 255);\n+  if (range >= 0xffff)\n+    lto_output_1_stream (obs, (val >> 16) & 255);\n+  if (range >= 0xffffff)\n+    lto_output_1_stream (obs, (val >> 24) & 255);\n+}\n+\n+/* Input VAL into OBS and verify it is in range MIN...MAX that is supposed\n+   to be compile time constant.  PURPOSE is used for error reporting.  */\n+\n+static inline HOST_WIDE_INT\n+lto_input_int_in_range (struct lto_input_block *ib,\n+\t\t\tconst char *purpose,\n+\t\t\tHOST_WIDE_INT min,\n+\t\t\tHOST_WIDE_INT max)\n+{\n+  HOST_WIDE_INT range = max - min;\n+  HOST_WIDE_INT val = lto_input_1_unsigned (ib);\n+\n+  gcc_checking_assert (range > 0 && range < 0x7fffffff);\n+\n+  if (range >= 0xff)\n+    val |= ((HOST_WIDE_INT)lto_input_1_unsigned (ib)) << 8;\n+  if (range >= 0xffff)\n+    val |= ((HOST_WIDE_INT)lto_input_1_unsigned (ib)) << 16;\n+  if (range >= 0xffffff)\n+    val |= ((HOST_WIDE_INT)lto_input_1_unsigned (ib)) << 24;\n+  val += min;\n+  if (val < min || val > max)\n+    lto_value_range_error (purpose, val, min, max);\n+  return val;\n+}\n+\n+/* Output VAL into BP and verify it is in range MIN...MAX that is supposed\n+   to be compile time constant.\n+   Be host independent, limit range to 31bits.  */\n+\n+static inline void\n+bp_pack_int_in_range (struct bitpack_d *bp,\n+\t\t      HOST_WIDE_INT min,\n+\t\t      HOST_WIDE_INT max,\n+\t\t      HOST_WIDE_INT val)\n+{\n+  HOST_WIDE_INT range = max - min;\n+  int nbits = floor_log2 (range) + 1;\n+\n+  gcc_checking_assert (val >= min && val <= max && range > 0\n+\t\t       && range < 0x7fffffff);\n+\n+  val -= min;\n+  bp_pack_value (bp, val, nbits);\n+}\n+\n+/* Input VAL into BP and verify it is in range MIN...MAX that is supposed\n+   to be compile time constant.  PURPOSE is used for error reporting.  */\n+\n+static inline HOST_WIDE_INT\n+bp_unpack_int_in_range (struct bitpack_d *bp,\n+\t\t        const char *purpose,\n+\t\t        HOST_WIDE_INT min,\n+\t\t        HOST_WIDE_INT max)\n+{\n+  HOST_WIDE_INT range = max - min;\n+  int nbits = floor_log2 (range) + 1;\n+  HOST_WIDE_INT val = bp_unpack_value (bp, nbits);\n+\n+  gcc_checking_assert (range > 0 && range < 0x7fffffff);\n+\n+  if (val < min || val > max)\n+    lto_value_range_error (purpose, val, min, max);\n+  return val;\n+}\n+\n+/* Output VAL of type \"enum enum_name\" into OBS.\n+   Assume range 0...ENUM_LAST - 1.  */\n+#define lto_output_enum(obs,enum_name,enum_last,val) \\\n+  lto_output_int_in_range ((obs), 0, (int)(enum_last) - 1, (int)(val))\n+\n+/* Input enum of type \"enum enum_name\" from IB.\n+   Assume range 0...ENUM_LAST - 1.  */\n+#define lto_input_enum(ib,enum_name,enum_last) \\\n+  (enum enum_name)lto_input_int_in_range ((ib), #enum_name, 0, \\\n+\t\t\t\t\t  (int)(enum_last) - 1)\n+\n+/* Output VAL of type \"enum enum_name\" into BP.\n+   Assume range 0...ENUM_LAST - 1.  */\n+#define bp_pack_enum(bp,enum_name,enum_last,val) \\\n+  bp_pack_int_in_range ((bp), 0, (int)(enum_last) - 1, (int)(val))\n+\n+/* Input enum of type \"enum enum_name\" from BP.\n+   Assume range 0...ENUM_LAST - 1.  */\n+#define bp_unpack_enum(bp,enum_name,enum_last) \\\n+  (enum enum_name)bp_unpack_int_in_range ((bp), #enum_name, 0, \\\n+\t\t\t\t\t(int)(enum_last) - 1)\n+\n+/* Output the start of a record with TAG to output block OB.  */\n+\n+static inline void\n+output_record_start (struct output_block *ob, enum LTO_tags tag)\n+{\n+  lto_output_enum (ob->main_stream, LTO_tags, LTO_NUM_TAGS, tag);\n+}\n+\n+/* Return the next tag in the input block IB.  */\n+\n+static inline enum LTO_tags\n+input_record_start (struct lto_input_block *ib)\n+{\n+  return lto_input_enum (ib, LTO_tags, LTO_NUM_TAGS);\n+}\n+\n+/* In data-streamer.c  */\n+void bp_pack_var_len_unsigned (struct bitpack_d *, unsigned HOST_WIDE_INT);\n+void bp_pack_var_len_int (struct bitpack_d *, HOST_WIDE_INT);\n+unsigned HOST_WIDE_INT bp_unpack_var_len_unsigned (struct bitpack_d *);\n+HOST_WIDE_INT bp_unpack_var_len_int (struct bitpack_d *);\n+\n+/* In data-streamer-out.c  */\n+void output_zero (struct output_block *);\n+void output_uleb128 (struct output_block *, unsigned HOST_WIDE_INT);\n+void output_sleb128 (struct output_block *, HOST_WIDE_INT);\n+void lto_output_string (struct output_block *, struct lto_output_stream *,\n+\t\t\tconst char *, bool);\n+unsigned lto_string_index (struct output_block *, const char *, unsigned int,\n+\t\t\t   bool);\n+void lto_output_string_with_length (struct output_block *,\n+\t\t\t\t    struct lto_output_stream *,\n+\t\t\t\t    const char *, unsigned int, bool);\n+const char *input_string_internal (struct data_in *, struct lto_input_block *,\n+\t\t\t\t   unsigned int *);\n+\n+/* In data-streamer-in.c  */\n+const char *string_for_index (struct data_in *, unsigned int, unsigned int *);\n+const char *lto_input_string (struct data_in *, struct lto_input_block *);\n+\n+#endif  /* GCC_DATA_STREAMER_H  */"}, {"sha": "dd91c73da1e65bb35f2aa69aa326cb3aad1cb33e", "filename": "gcc/gimple-streamer-in.c", "status": "added", "additions": 333, "deletions": 0, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Fgimple-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Fgimple-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-in.c?ref=f0efc7aa7705facdb16a39a08137cf748c7d5f30", "patch": "@@ -0,0 +1,333 @@\n+/* Routines for reading GIMPLE from a file stream.\n+\n+   Copyright 2011 Free Software Foundation, Inc.\n+   Contributed by Diego Novillo <dnovillo@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"diagnostic.h\"\n+#include \"tree.h\"\n+#include \"tree-flow.h\"\n+#include \"data-streamer.h\"\n+#include \"tree-streamer.h\"\n+#include \"gimple-streamer.h\"\n+\n+/* Read a PHI function for basic block BB in function FN.  DATA_IN is\n+   the file being read.  IB is the input block to use for reading.  */\n+\n+static gimple\n+input_phi (struct lto_input_block *ib, basic_block bb, struct data_in *data_in,\n+\t   struct function *fn)\n+{\n+  unsigned HOST_WIDE_INT ix;\n+  tree phi_result;\n+  int i, len;\n+  gimple result;\n+\n+  ix = lto_input_uleb128 (ib);\n+  phi_result = VEC_index (tree, SSANAMES (fn), ix);\n+  len = EDGE_COUNT (bb->preds);\n+  result = create_phi_node (phi_result, bb);\n+  SSA_NAME_DEF_STMT (phi_result) = result;\n+\n+  /* We have to go through a lookup process here because the preds in the\n+     reconstructed graph are generally in a different order than they\n+     were in the original program.  */\n+  for (i = 0; i < len; i++)\n+    {\n+      tree def = lto_input_tree (ib, data_in);\n+      int src_index = lto_input_uleb128 (ib);\n+      location_t arg_loc = lto_input_location (ib, data_in);\n+      basic_block sbb = BASIC_BLOCK_FOR_FUNCTION (fn, src_index);\n+\n+      edge e = NULL;\n+      int j;\n+\n+      for (j = 0; j < len; j++)\n+\tif (EDGE_PRED (bb, j)->src == sbb)\n+\t  {\n+\t    e = EDGE_PRED (bb, j);\n+\t    break;\n+\t  }\n+\n+      add_phi_arg (result, def, e, arg_loc);\n+    }\n+\n+  return result;\n+}\n+\n+\n+/* Read a statement with tag TAG in function FN from block IB using\n+   descriptors in DATA_IN.  */\n+\n+static gimple\n+input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n+\t\t   struct function *fn, enum LTO_tags tag)\n+{\n+  gimple stmt;\n+  enum gimple_code code;\n+  unsigned HOST_WIDE_INT num_ops;\n+  size_t i;\n+  struct bitpack_d bp;\n+\n+  code = lto_tag_to_gimple_code (tag);\n+\n+  /* Read the tuple header.  */\n+  bp = lto_input_bitpack (ib);\n+  num_ops = bp_unpack_var_len_unsigned (&bp);\n+  stmt = gimple_alloc (code, num_ops);\n+  stmt->gsbase.no_warning = bp_unpack_value (&bp, 1);\n+  if (is_gimple_assign (stmt))\n+    stmt->gsbase.nontemporal_move = bp_unpack_value (&bp, 1);\n+  stmt->gsbase.has_volatile_ops = bp_unpack_value (&bp, 1);\n+  stmt->gsbase.subcode = bp_unpack_var_len_unsigned (&bp);\n+\n+  /* Read location information.  */\n+  gimple_set_location (stmt, lto_input_location (ib, data_in));\n+\n+  /* Read lexical block reference.  */\n+  gimple_set_block (stmt, lto_input_tree (ib, data_in));\n+\n+  /* Read in all the operands.  */\n+  switch (code)\n+    {\n+    case GIMPLE_RESX:\n+      gimple_resx_set_region (stmt, lto_input_sleb128 (ib));\n+      break;\n+\n+    case GIMPLE_EH_MUST_NOT_THROW:\n+      gimple_eh_must_not_throw_set_fndecl (stmt, lto_input_tree (ib, data_in));\n+      break;\n+\n+    case GIMPLE_EH_DISPATCH:\n+      gimple_eh_dispatch_set_region (stmt, lto_input_sleb128 (ib));\n+      break;\n+\n+    case GIMPLE_ASM:\n+      {\n+\t/* FIXME lto.  Move most of this into a new gimple_asm_set_string().  */\n+\ttree str;\n+\tstmt->gimple_asm.ni = lto_input_uleb128 (ib);\n+\tstmt->gimple_asm.no = lto_input_uleb128 (ib);\n+\tstmt->gimple_asm.nc = lto_input_uleb128 (ib);\n+\tstmt->gimple_asm.nl = lto_input_uleb128 (ib);\n+\tstr = input_string_cst (data_in, ib);\n+\tstmt->gimple_asm.string = TREE_STRING_POINTER (str);\n+      }\n+      /* Fallthru  */\n+\n+    case GIMPLE_ASSIGN:\n+    case GIMPLE_CALL:\n+    case GIMPLE_RETURN:\n+    case GIMPLE_SWITCH:\n+    case GIMPLE_LABEL:\n+    case GIMPLE_COND:\n+    case GIMPLE_GOTO:\n+    case GIMPLE_DEBUG:\n+      for (i = 0; i < num_ops; i++)\n+\t{\n+\t  tree op = lto_input_tree (ib, data_in);\n+\t  gimple_set_op (stmt, i, op);\n+\t  if (!op)\n+\t    continue;\n+\n+\t  /* Fixup FIELD_DECLs in COMPONENT_REFs, they are not handled\n+\t     by decl merging.  */\n+\t  if (TREE_CODE (op) == ADDR_EXPR)\n+\t    op = TREE_OPERAND (op, 0);\n+\t  while (handled_component_p (op))\n+\t    {\n+\t      if (TREE_CODE (op) == COMPONENT_REF)\n+\t\t{\n+\t\t  tree field, type, tem;\n+\t\t  tree closest_match = NULL_TREE;\n+\t\t  field = TREE_OPERAND (op, 1);\n+\t\t  type = DECL_CONTEXT (field);\n+\t\t  for (tem = TYPE_FIELDS (type); tem; tem = TREE_CHAIN (tem))\n+\t\t    {\n+\t\t      if (tem == field)\n+\t\t\tbreak;\n+\t\t      if (DECL_NONADDRESSABLE_P (tem)\n+\t\t\t  == DECL_NONADDRESSABLE_P (field)\n+\t\t\t  && gimple_compare_field_offset (tem, field))\n+\t\t\t{\n+\t\t\t  if (types_compatible_p (TREE_TYPE (tem),\n+\t\t\t\t\t\t  TREE_TYPE (field)))\n+\t\t\t    break;\n+\t\t\t  else\n+\t\t\t    closest_match = tem;\n+\t\t\t}\n+\t\t    }\n+\t\t  /* In case of type mismatches across units we can fail\n+\t\t     to unify some types and thus not find a proper\n+\t\t     field-decl here.  */\n+\t\t  if (tem == NULL_TREE)\n+\t\t    {\n+\t\t      /* Thus, emit a ODR violation warning.  */\n+\t\t      if (warning_at (gimple_location (stmt), 0,\n+\t\t\t\t      \"use of type %<%E%> with two mismatching \"\n+\t\t\t\t      \"declarations at field %<%E%>\",\n+\t\t\t\t      type, TREE_OPERAND (op, 1)))\n+\t\t\t{\n+\t\t\t  if (TYPE_FIELDS (type))\n+\t\t\t    inform (DECL_SOURCE_LOCATION (TYPE_FIELDS (type)),\n+\t\t\t\t    \"original type declared here\");\n+\t\t\t  inform (DECL_SOURCE_LOCATION (TREE_OPERAND (op, 1)),\n+\t\t\t\t  \"field in mismatching type declared here\");\n+\t\t\t  if (TYPE_NAME (TREE_TYPE (field))\n+\t\t\t      && (TREE_CODE (TYPE_NAME (TREE_TYPE (field)))\n+\t\t\t\t  == TYPE_DECL))\n+\t\t\t    inform (DECL_SOURCE_LOCATION\n+\t\t\t\t      (TYPE_NAME (TREE_TYPE (field))),\n+\t\t\t\t    \"type of field declared here\");\n+\t\t\t  if (closest_match\n+\t\t\t      && TYPE_NAME (TREE_TYPE (closest_match))\n+\t\t\t      && (TREE_CODE (TYPE_NAME\n+\t\t\t\t   (TREE_TYPE (closest_match))) == TYPE_DECL))\n+\t\t\t    inform (DECL_SOURCE_LOCATION\n+\t\t\t\t      (TYPE_NAME (TREE_TYPE (closest_match))),\n+\t\t\t\t    \"type of mismatching field declared here\");\n+\t\t\t}\n+\t\t      /* And finally fixup the types.  */\n+\t\t      TREE_OPERAND (op, 0)\n+\t\t\t= build1 (VIEW_CONVERT_EXPR, type,\n+\t\t\t\t  TREE_OPERAND (op, 0));\n+\t\t    }\n+\t\t  else\n+\t\t    TREE_OPERAND (op, 1) = tem;\n+\t\t}\n+\n+\t      op = TREE_OPERAND (op, 0);\n+\t    }\n+\t}\n+      if (is_gimple_call (stmt))\n+\t{\n+\t  if (gimple_call_internal_p (stmt))\n+\t    gimple_call_set_internal_fn\n+\t      (stmt, lto_input_enum (ib, internal_fn, IFN_LAST));\n+\t  else\n+\t    gimple_call_set_fntype (stmt, lto_input_tree (ib, data_in));\n+\t}\n+      break;\n+\n+    case GIMPLE_NOP:\n+    case GIMPLE_PREDICT:\n+      break;\n+\n+    default:\n+      internal_error (\"bytecode stream: unknown GIMPLE statement tag %s\",\n+\t\t      lto_tag_name (tag));\n+    }\n+\n+  /* Update the properties of symbols, SSA names and labels associated\n+     with STMT.  */\n+  if (code == GIMPLE_ASSIGN || code == GIMPLE_CALL)\n+    {\n+      tree lhs = gimple_get_lhs (stmt);\n+      if (lhs && TREE_CODE (lhs) == SSA_NAME)\n+\tSSA_NAME_DEF_STMT (lhs) = stmt;\n+    }\n+  else if (code == GIMPLE_LABEL)\n+    gcc_assert (emit_label_in_global_context_p (gimple_label_label (stmt))\n+\t        || DECL_CONTEXT (gimple_label_label (stmt)) == fn->decl);\n+  else if (code == GIMPLE_ASM)\n+    {\n+      unsigned i;\n+\n+      for (i = 0; i < gimple_asm_noutputs (stmt); i++)\n+\t{\n+\t  tree op = TREE_VALUE (gimple_asm_output_op (stmt, i));\n+\t  if (TREE_CODE (op) == SSA_NAME)\n+\t    SSA_NAME_DEF_STMT (op) = stmt;\n+\t}\n+    }\n+\n+  /* Reset alias information.  */\n+  if (code == GIMPLE_CALL)\n+    gimple_call_reset_alias_info (stmt);\n+\n+  /* Mark the statement modified so its operand vectors can be filled in.  */\n+  gimple_set_modified (stmt, true);\n+\n+  return stmt;\n+}\n+\n+\n+/* Read a basic block with tag TAG from DATA_IN using input block IB.\n+   FN is the function being processed.  */\n+\n+void\n+input_bb (struct lto_input_block *ib, enum LTO_tags tag,\n+\t  struct data_in *data_in, struct function *fn,\n+\t  int count_materialization_scale)\n+{\n+  unsigned int index;\n+  basic_block bb;\n+  gimple_stmt_iterator bsi;\n+\n+  /* This routine assumes that CFUN is set to FN, as it needs to call\n+     basic GIMPLE routines that use CFUN.  */\n+  gcc_assert (cfun == fn);\n+\n+  index = lto_input_uleb128 (ib);\n+  bb = BASIC_BLOCK_FOR_FUNCTION (fn, index);\n+\n+  bb->count = (lto_input_sleb128 (ib) * count_materialization_scale\n+\t       + REG_BR_PROB_BASE / 2) / REG_BR_PROB_BASE;\n+  bb->loop_depth = lto_input_sleb128 (ib);\n+  bb->frequency = lto_input_sleb128 (ib);\n+  bb->flags = lto_input_sleb128 (ib);\n+\n+  /* LTO_bb1 has statements.  LTO_bb0 does not.  */\n+  if (tag == LTO_bb0)\n+    return;\n+\n+  bsi = gsi_start_bb (bb);\n+  tag = input_record_start (ib);\n+  while (tag)\n+    {\n+      gimple stmt = input_gimple_stmt (ib, data_in, fn, tag);\n+      if (!is_gimple_debug (stmt))\n+\tfind_referenced_vars_in (stmt);\n+      gsi_insert_after (&bsi, stmt, GSI_NEW_STMT);\n+\n+      /* After the statement, expect a 0 delimiter or the EH region\n+\t that the previous statement belongs to.  */\n+      tag = input_record_start (ib);\n+      lto_tag_check_set (tag, 2, LTO_eh_region, LTO_null);\n+\n+      if (tag == LTO_eh_region)\n+\t{\n+\t  HOST_WIDE_INT region = lto_input_sleb128 (ib);\n+\t  gcc_assert (region == (int) region);\n+\t  add_stmt_to_eh_lp (stmt, region);\n+\t}\n+\n+      tag = input_record_start (ib);\n+    }\n+\n+  tag = input_record_start (ib);\n+  while (tag)\n+    {\n+      gimple phi = input_phi (ib, bb, data_in, fn);\n+      find_referenced_vars_in (phi);\n+      tag = input_record_start (ib);\n+    }\n+}"}, {"sha": "0a4151081b4d723c31946ababfdbc708f6c14e1b", "filename": "gcc/gimple-streamer-out.c", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Fgimple-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Fgimple-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-out.c?ref=f0efc7aa7705facdb16a39a08137cf748c7d5f30", "patch": "@@ -0,0 +1,213 @@\n+/* Routines for emitting GIMPLE to a file stream.\n+\n+   Copyright 2011 Free Software Foundation, Inc.\n+   Contributed by Diego Novillo <dnovillo@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"tree-flow.h\"\n+#include \"data-streamer.h\"\n+#include \"gimple-streamer.h\"\n+#include \"lto-streamer.h\"\n+\n+/* Output PHI function PHI to the main stream in OB.  */\n+\n+static void\n+output_phi (struct output_block *ob, gimple phi)\n+{\n+  unsigned i, len = gimple_phi_num_args (phi);\n+\n+  output_record_start (ob, lto_gimple_code_to_tag (GIMPLE_PHI));\n+  output_uleb128 (ob, SSA_NAME_VERSION (PHI_RESULT (phi)));\n+\n+  for (i = 0; i < len; i++)\n+    {\n+      lto_output_tree_ref (ob, gimple_phi_arg_def (phi, i));\n+      output_uleb128 (ob, gimple_phi_arg_edge (phi, i)->src->index);\n+      lto_output_location (ob, gimple_phi_arg_location (phi, i));\n+    }\n+}\n+\n+\n+/* Emit statement STMT on the main stream of output block OB.  */\n+\n+static void\n+output_gimple_stmt (struct output_block *ob, gimple stmt)\n+{\n+  unsigned i;\n+  enum gimple_code code;\n+  enum LTO_tags tag;\n+  struct bitpack_d bp;\n+\n+  /* Emit identifying tag.  */\n+  code = gimple_code (stmt);\n+  tag = lto_gimple_code_to_tag (code);\n+  output_record_start (ob, tag);\n+\n+  /* Emit the tuple header.  */\n+  bp = bitpack_create (ob->main_stream);\n+  bp_pack_var_len_unsigned (&bp, gimple_num_ops (stmt));\n+  bp_pack_value (&bp, gimple_no_warning_p (stmt), 1);\n+  if (is_gimple_assign (stmt))\n+    bp_pack_value (&bp, gimple_assign_nontemporal_move_p (stmt), 1);\n+  bp_pack_value (&bp, gimple_has_volatile_ops (stmt), 1);\n+  bp_pack_var_len_unsigned (&bp, stmt->gsbase.subcode);\n+  lto_output_bitpack (&bp);\n+\n+  /* Emit location information for the statement.  */\n+  lto_output_location (ob, gimple_location (stmt));\n+\n+  /* Emit the lexical block holding STMT.  */\n+  lto_output_tree (ob, gimple_block (stmt), true);\n+\n+  /* Emit the operands.  */\n+  switch (gimple_code (stmt))\n+    {\n+    case GIMPLE_RESX:\n+      output_sleb128 (ob, gimple_resx_region (stmt));\n+      break;\n+\n+    case GIMPLE_EH_MUST_NOT_THROW:\n+      lto_output_tree_ref (ob, gimple_eh_must_not_throw_fndecl (stmt));\n+      break;\n+\n+    case GIMPLE_EH_DISPATCH:\n+      output_sleb128 (ob, gimple_eh_dispatch_region (stmt));\n+      break;\n+\n+    case GIMPLE_ASM:\n+      lto_output_uleb128_stream (ob->main_stream, gimple_asm_ninputs (stmt));\n+      lto_output_uleb128_stream (ob->main_stream, gimple_asm_noutputs (stmt));\n+      lto_output_uleb128_stream (ob->main_stream, gimple_asm_nclobbers (stmt));\n+      lto_output_uleb128_stream (ob->main_stream, gimple_asm_nlabels (stmt));\n+      lto_output_string (ob, ob->main_stream, gimple_asm_string (stmt), true);\n+      /* Fallthru  */\n+\n+    case GIMPLE_ASSIGN:\n+    case GIMPLE_CALL:\n+    case GIMPLE_RETURN:\n+    case GIMPLE_SWITCH:\n+    case GIMPLE_LABEL:\n+    case GIMPLE_COND:\n+    case GIMPLE_GOTO:\n+    case GIMPLE_DEBUG:\n+      for (i = 0; i < gimple_num_ops (stmt); i++)\n+\t{\n+\t  tree op = gimple_op (stmt, i);\n+\t  /* Wrap all uses of non-automatic variables inside MEM_REFs\n+\t     so that we do not have to deal with type mismatches on\n+\t     merged symbols during IL read in.  The first operand\n+\t     of GIMPLE_DEBUG must be a decl, not MEM_REF, though.  */\n+\t  if (op && (i || !is_gimple_debug (stmt)))\n+\t    {\n+\t      tree *basep = &op;\n+\t      while (handled_component_p (*basep))\n+\t\tbasep = &TREE_OPERAND (*basep, 0);\n+\t      if (TREE_CODE (*basep) == VAR_DECL\n+\t\t  && !auto_var_in_fn_p (*basep, current_function_decl)\n+\t\t  && !DECL_REGISTER (*basep))\n+\t\t{\n+\t\t  bool volatilep = TREE_THIS_VOLATILE (*basep);\n+\t\t  *basep = build2 (MEM_REF, TREE_TYPE (*basep),\n+\t\t\t\t   build_fold_addr_expr (*basep),\n+\t\t\t\t   build_int_cst (build_pointer_type\n+\t\t\t\t\t\t  (TREE_TYPE (*basep)), 0));\n+\t\t  TREE_THIS_VOLATILE (*basep) = volatilep;\n+\t\t}\n+\t    }\n+\t  lto_output_tree_ref (ob, op);\n+\t}\n+      if (is_gimple_call (stmt))\n+\t{\n+\t  if (gimple_call_internal_p (stmt))\n+\t    lto_output_enum (ob->main_stream, internal_fn,\n+\t\t\t     IFN_LAST, gimple_call_internal_fn (stmt));\n+\t  else\n+\t    lto_output_tree_ref (ob, gimple_call_fntype (stmt));\n+\t}\n+      break;\n+\n+    case GIMPLE_NOP:\n+    case GIMPLE_PREDICT:\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+\n+/* Output a basic block BB to the main stream in OB for this FN.  */\n+\n+void\n+output_bb (struct output_block *ob, basic_block bb, struct function *fn)\n+{\n+  gimple_stmt_iterator bsi = gsi_start_bb (bb);\n+\n+  output_record_start (ob,\n+\t\t       (!gsi_end_p (bsi)) || phi_nodes (bb)\n+\t\t        ? LTO_bb1\n+\t\t\t: LTO_bb0);\n+\n+  output_uleb128 (ob, bb->index);\n+  output_sleb128 (ob, bb->count);\n+  output_sleb128 (ob, bb->loop_depth);\n+  output_sleb128 (ob, bb->frequency);\n+  output_sleb128 (ob, bb->flags);\n+\n+  if (!gsi_end_p (bsi) || phi_nodes (bb))\n+    {\n+      /* Output the statements.  The list of statements is terminated\n+\t with a zero.  */\n+      for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+\t{\n+\t  int region;\n+\t  gimple stmt = gsi_stmt (bsi);\n+\n+\t  output_gimple_stmt (ob, stmt);\n+\n+\t  /* Emit the EH region holding STMT.  */\n+\t  region = lookup_stmt_eh_lp_fn (fn, stmt);\n+\t  if (region != 0)\n+\t    {\n+\t      output_record_start (ob, LTO_eh_region);\n+\t      output_sleb128 (ob, region);\n+\t    }\n+\t  else\n+\t    output_record_start (ob, LTO_null);\n+\t}\n+\n+      output_record_start (ob, LTO_null);\n+\n+      for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+\t{\n+\t  gimple phi = gsi_stmt (bsi);\n+\n+\t  /* Only emit PHIs for gimple registers.  PHI nodes for .MEM\n+\t     will be filled in on reading when the SSA form is\n+\t     updated.  */\n+\t  if (is_gimple_reg (gimple_phi_result (phi)))\n+\t    output_phi (ob, phi);\n+\t}\n+\n+      output_record_start (ob, LTO_null);\n+    }\n+}"}, {"sha": "257fdbc6bbf7f55868b0852fb7a99a5484ad5436", "filename": "gcc/gimple-streamer.h", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Fgimple-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Fgimple-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer.h?ref=f0efc7aa7705facdb16a39a08137cf748c7d5f30", "patch": "@@ -0,0 +1,36 @@\n+/* Data structures and functions for streaming GIMPLE.\n+\n+   Copyright 2011 Free Software Foundation, Inc.\n+   Contributed by Diego Novillo <dnovillo@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_GIMPLE_STREAMER_H\n+#define GCC_GIMPLE_STREAMER_H\n+\n+#include \"basic-block.h\"\n+#include \"function.h\"\n+#include \"lto-streamer.h\"\n+\n+/* In gimple-streamer-in.c  */\n+void input_bb (struct lto_input_block *, enum LTO_tags, struct data_in *,\n+\t       struct function *, int);\n+\n+/* In gimple-streamer-out.c  */\n+void output_bb (struct output_block *, basic_block, struct function *);\n+\n+#endif  /* GCC_GIMPLE_STREAMER_H  */"}, {"sha": "bc65a457d7b8d0c39625bdb0d2927cb97b274dd1", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=f0efc7aa7705facdb16a39a08137cf748c7d5f30", "patch": "@@ -84,6 +84,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-flow.h\"\n #include \"ipa-prop.h\"\n #include \"lto-streamer.h\"\n+#include \"data-streamer.h\"\n+#include \"tree-streamer.h\"\n #include \"ipa-inline.h\"\n #include \"alloc-pool.h\"\n "}, {"sha": "7f9f547d52010be27c1e7e6ca221073617d1ec2e", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=f0efc7aa7705facdb16a39a08137cf748c7d5f30", "patch": "@@ -38,6 +38,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pretty-print.h\"\n #include \"gimple-pretty-print.h\"\n #include \"lto-streamer.h\"\n+#include \"data-streamer.h\"\n+#include \"tree-streamer.h\"\n \n \n /* Intermediate information about a parameter that is only useful during the"}, {"sha": "4f02c7bf7efe86905b7a269b3a27aeba7d57f609", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=f0efc7aa7705facdb16a39a08137cf748c7d5f30", "patch": "@@ -54,6 +54,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"target.h\"\n #include \"lto-streamer.h\"\n+#include \"data-streamer.h\"\n+#include \"tree-streamer.h\"\n #include \"cfgloop.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"intl.h\""}, {"sha": "c4da1ffecb28ca426453454319e76ae599426baa", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=f0efc7aa7705facdb16a39a08137cf748c7d5f30", "patch": "@@ -43,6 +43,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"output.h\"\n #include \"pointer-set.h\"\n #include \"lto-streamer.h\"\n+#include \"data-streamer.h\"\n+#include \"tree-streamer.h\"\n #include \"gcov-io.h\"\n \n static void output_varpool (cgraph_node_set, varpool_node_set);"}, {"sha": "1c285faf19e41cc61c09bd5bffadf034ddfd610c", "filename": "gcc/lto-section-in.c", "status": "modified", "additions": 0, "deletions": 109, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Flto-section-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Flto-section-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-in.c?ref=f0efc7aa7705facdb16a39a08137cf748c7d5f30", "patch": "@@ -63,115 +63,6 @@ const char *lto_section_name[LTO_N_SECTION_TYPES] =\n };\n \n \n-/* Read an ULEB128 Number of IB.  */\n-\n-unsigned HOST_WIDE_INT\n-lto_input_uleb128 (struct lto_input_block *ib)\n-{\n-  unsigned HOST_WIDE_INT result = 0;\n-  int shift = 0;\n-  unsigned HOST_WIDE_INT byte;\n-\n-  while (true)\n-    {\n-      byte = lto_input_1_unsigned (ib);\n-      result |= (byte & 0x7f) << shift;\n-      shift += 7;\n-      if ((byte & 0x80) == 0)\n-\treturn result;\n-    }\n-}\n-\n-/* HOST_WIDEST_INT version of lto_input_uleb128.  IB is as in\n-   lto_input_uleb128.  */\n-\n-unsigned HOST_WIDEST_INT\n-lto_input_widest_uint_uleb128 (struct lto_input_block *ib)\n-{\n-  unsigned HOST_WIDEST_INT result = 0;\n-  int shift = 0;\n-  unsigned HOST_WIDEST_INT byte;\n-\n-  while (true)\n-    {\n-      byte = lto_input_1_unsigned (ib);\n-      result |= (byte & 0x7f) << shift;\n-      shift += 7;\n-      if ((byte & 0x80) == 0)\n-\treturn result;\n-    }\n-}\n-\n-/* Read an SLEB128 Number of IB.  */\n-\n-HOST_WIDE_INT\n-lto_input_sleb128 (struct lto_input_block *ib)\n-{\n-  HOST_WIDE_INT result = 0;\n-  int shift = 0;\n-  unsigned HOST_WIDE_INT byte;\n-\n-  while (true)\n-    {\n-      byte = lto_input_1_unsigned (ib);\n-      result |= (byte & 0x7f) << shift;\n-      shift += 7;\n-      if ((byte & 0x80) == 0)\n-\t{\n-\t  if ((shift < HOST_BITS_PER_WIDE_INT) && (byte & 0x40))\n-\t    result |= - ((HOST_WIDE_INT)1 << shift);\n-\n-\t  return result;\n-\t}\n-    }\n-}\n-\n-\n-/* Unpack VAL from BP in a variant of uleb format.  */\n-\n-unsigned HOST_WIDE_INT\n-bp_unpack_var_len_unsigned (struct bitpack_d *bp)\n-{\n-  unsigned HOST_WIDE_INT result = 0;\n-  int shift = 0;\n-  unsigned HOST_WIDE_INT half_byte;\n-\n-  while (true)\n-    {\n-      half_byte = bp_unpack_value (bp, 4);\n-      result |= (half_byte & 0x7) << shift;\n-      shift += 3;\n-      if ((half_byte & 0x8) == 0)\n-\treturn result;\n-    }\n-}\n-\n-\n-/* Unpack VAL from BP in a variant of sleb format.  */\n-\n-HOST_WIDE_INT\n-bp_unpack_var_len_int (struct bitpack_d *bp)\n-{\n-  HOST_WIDE_INT result = 0;\n-  int shift = 0;\n-  unsigned HOST_WIDE_INT half_byte;\n-\n-  while (true)\n-    {\n-      half_byte = bp_unpack_value (bp, 4);\n-      result |= (half_byte & 0x7) << shift;\n-      shift += 3;\n-      if ((half_byte & 0x8) == 0)\n-\t{\n-\t  if ((shift < HOST_BITS_PER_WIDE_INT) && (half_byte & 0x4))\n-\t    result |= - ((HOST_WIDE_INT)1 << shift);\n-\n-\t  return result;\n-\t}\n-    }\n-}\n-\n-\n /* Hooks so that the ipa passes can call into the lto front end to get\n    sections.  */\n "}, {"sha": "7f44d6e367546905df338a4090a85b8041920214", "filename": "gcc/lto-section-out.c", "status": "modified", "additions": 0, "deletions": 107, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Flto-section-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Flto-section-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-out.c?ref=f0efc7aa7705facdb16a39a08137cf748c7d5f30", "patch": "@@ -265,113 +265,6 @@ lto_output_data_stream (struct lto_output_stream *obs, const void *data,\n }\n \n \n-/* Output an unsigned LEB128 quantity to OBS.  */\n-\n-void\n-lto_output_uleb128_stream (struct lto_output_stream *obs,\n-\t\t\t   unsigned HOST_WIDE_INT work)\n-{\n-  do\n-    {\n-      unsigned int byte = (work & 0x7f);\n-      work >>= 7;\n-      if (work != 0)\n-\t/* More bytes to follow.  */\n-\tbyte |= 0x80;\n-\n-      lto_output_1_stream (obs, byte);\n-    }\n-  while (work != 0);\n-}\n-\n-/* Identical to output_uleb128_stream above except using unsigned\n-   HOST_WIDEST_INT type.  For efficiency on host where unsigned HOST_WIDEST_INT\n-   is not native, we only use this if we know that HOST_WIDE_INT is not wide\n-   enough.  */\n-\n-void\n-lto_output_widest_uint_uleb128_stream (struct lto_output_stream *obs,\n-\t\t\t\t       unsigned HOST_WIDEST_INT work)\n-{\n-  do\n-    {\n-      unsigned int byte = (work & 0x7f);\n-      work >>= 7;\n-      if (work != 0)\n-\t/* More bytes to follow.  */\n-\tbyte |= 0x80;\n-\n-      lto_output_1_stream (obs, byte);\n-    }\n-  while (work != 0);\n-}\n-\n-\n-/* Output a signed LEB128 quantity.  */\n-\n-void\n-lto_output_sleb128_stream (struct lto_output_stream *obs, HOST_WIDE_INT work)\n-{\n-  int more, byte;\n-\n-  do\n-    {\n-      byte = (work & 0x7f);\n-      /* arithmetic shift */\n-      work >>= 7;\n-      more = !((work == 0 && (byte & 0x40) == 0)\n-\t       || (work == -1 && (byte & 0x40) != 0));\n-      if (more)\n-\tbyte |= 0x80;\n-\n-      lto_output_1_stream (obs, byte);\n-    }\n-  while (more);\n-}\n-\n-\n-/* Pack WORK into BP in a variant of uleb format.  */\n-\n-void\n-bp_pack_var_len_unsigned (struct bitpack_d *bp, unsigned HOST_WIDE_INT work)\n-{\n-  do\n-    {\n-      unsigned int half_byte = (work & 0x7);\n-      work >>= 3;\n-      if (work != 0)\n-\t/* More half_bytes to follow.  */\n-\thalf_byte |= 0x8;\n-\n-      bp_pack_value (bp, half_byte, 4);\n-    }\n-  while (work != 0);\n-}\n-\n-\n-/* Pack WORK into BP in a variant of sleb format.  */\n-\n-void\n-bp_pack_var_len_int (struct bitpack_d *bp, HOST_WIDE_INT work)\n-{\n-  int more, half_byte;\n-\n-  do\n-    {\n-      half_byte = (work & 0x7);\n-      /* arithmetic shift */\n-      work >>= 3;\n-      more = !((work == 0 && (half_byte & 0x4) == 0)\n-\t       || (work == -1 && (half_byte & 0x4) != 0));\n-      if (more)\n-\thalf_byte |= 0x8;\n-\n-      bp_pack_value (bp, half_byte, 4);\n-    }\n-  while (more);\n-}\n-\n-\n /* Lookup NAME in ENCODER.  If NAME is not found, create a new entry in\n    ENCODER for NAME with the next available index of ENCODER,  then\n    print the index to OBS.  True is returned if NAME was added to"}, {"sha": "1330d606dc616328b8a71ff56d157b2cd97b1e48", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 14, "deletions": 1554, "changes": 1568, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=f0efc7aa7705facdb16a39a08137cf748c7d5f30", "patch": "@@ -45,24 +45,20 @@ along with GCC; see the file COPYING3.  If not see\n #include \"timevar.h\"\n #include \"output.h\"\n #include \"ipa-utils.h\"\n+#include \"data-streamer.h\"\n+#include \"gimple-streamer.h\"\n #include \"lto-streamer.h\"\n+#include \"tree-streamer.h\"\n #include \"tree-pass.h\"\n \n-/* Data structure used to hash file names in the source_location field.  */\n-struct string_slot\n-{\n-  const char *s;\n-  unsigned int slot_num;\n-};\n-\n /* The table to hold the file names.  */\n static htab_t file_name_hash_table;\n \n \n /* Check that tag ACTUAL has one of the given values.  NUM_TAGS is the\n    number of valid tag values to check.  */\n \n-static void\n+void\n lto_tag_check_set (enum LTO_tags actual, int ntags, ...)\n {\n   va_list ap;\n@@ -81,128 +77,6 @@ lto_tag_check_set (enum LTO_tags actual, int ntags, ...)\n }\n \n \n-/* Check that tag ACTUAL is in the range [TAG1, TAG2].  */\n-\n-static void\n-lto_tag_check_range (enum LTO_tags actual, enum LTO_tags tag1,\n-\t\t     enum LTO_tags tag2)\n-{\n-  if (actual < tag1 || actual > tag2)\n-    internal_error (\"bytecode stream: tag %s is not in the expected range \"\n-\t\t    \"[%s, %s]\",\n-\t\t    lto_tag_name (actual),\n-\t\t    lto_tag_name (tag1),\n-\t\t    lto_tag_name (tag2));\n-}\n-\n-\n-/* Check that tag ACTUAL == EXPECTED.  */\n-\n-static void\n-lto_tag_check (enum LTO_tags actual, enum LTO_tags expected)\n-{\n-  if (actual != expected)\n-    internal_error (\"bytecode stream: expected tag %s instead of %s\",\n-\t\t    lto_tag_name (expected), lto_tag_name (actual));\n-}\n-\n-\n-/* Return a hash code for P.  */\n-\n-static hashval_t\n-hash_string_slot_node (const void *p)\n-{\n-  const struct string_slot *ds = (const struct string_slot *) p;\n-  return (hashval_t) htab_hash_string (ds->s);\n-}\n-\n-\n-/* Returns nonzero if P1 and P2 are equal.  */\n-\n-static int\n-eq_string_slot_node (const void *p1, const void *p2)\n-{\n-  const struct string_slot *ds1 = (const struct string_slot *) p1;\n-  const struct string_slot *ds2 = (const struct string_slot *) p2;\n-  return strcmp (ds1->s, ds2->s) == 0;\n-}\n-\n-\n-/* Read a string from the string table in DATA_IN using input block\n-   IB.  Write the length to RLEN.  */\n-\n-static const char *\n-string_for_index (struct data_in *data_in,\n-\t\t  unsigned int loc,\n-\t\t  unsigned int *rlen)\n-{\n-  struct lto_input_block str_tab;\n-  unsigned int len;\n-  const char *result;\n-\n-  if (!loc)\n-    {\n-      *rlen = 0;\n-      return NULL;\n-    }\n-\n-  /* Get the string stored at location LOC in DATA_IN->STRINGS.  */\n-  LTO_INIT_INPUT_BLOCK (str_tab, data_in->strings, loc - 1, data_in->strings_len);\n-  len = lto_input_uleb128 (&str_tab);\n-  *rlen = len;\n-\n-  if (str_tab.p + len > data_in->strings_len)\n-    internal_error (\"bytecode stream: string too long for the string table\");\n-\n-  result = (const char *)(data_in->strings + str_tab.p);\n-\n-  return result;\n-}\n-\n-\n-/* Read a string from the string table in DATA_IN using input block\n-   IB.  Write the length to RLEN.  */\n-\n-static const char *\n-input_string_internal (struct data_in *data_in, struct lto_input_block *ib,\n-\t\t       unsigned int *rlen)\n-{\n-  return string_for_index (data_in, lto_input_uleb128 (ib), rlen);\n-}\n-\n-\n-/* Read a STRING_CST from the string table in DATA_IN using input\n-   block IB.  */\n-\n-static tree\n-input_string_cst (struct data_in *data_in, struct lto_input_block *ib)\n-{\n-  unsigned int len;\n-  const char * ptr;\n-\n-  ptr = input_string_internal (data_in, ib, &len);\n-  if (!ptr)\n-    return NULL;\n-  return build_string (len, ptr);\n-}\n-\n-\n-/* Read an IDENTIFIER from the string table in DATA_IN using input\n-   block IB.  */\n-\n-static tree\n-input_identifier (struct data_in *data_in, struct lto_input_block *ib)\n-{\n-  unsigned int len;\n-  const char *ptr;\n-\n-  ptr = input_string_internal (data_in, ib, &len);\n-  if (!ptr)\n-    return NULL;\n-  return get_identifier_with_length (ptr, len);\n-}\n-\n-\n /* Read LENGTH bytes from STREAM to ADDR.  */\n \n void\n@@ -216,33 +90,6 @@ lto_input_data_block (struct lto_input_block *ib, void *addr, size_t length)\n }\n \n \n-/* Read a NULL terminated string from the string table in DATA_IN.  */\n-\n-const char *\n-lto_input_string (struct data_in *data_in, struct lto_input_block *ib)\n-{\n-  unsigned int len;\n-  const char *ptr;\n-\n-  ptr = input_string_internal (data_in, ib, &len);\n-  if (!ptr)\n-    return NULL;\n-  if (ptr[len - 1] != '\\0')\n-    internal_error (\"bytecode stream: found non-null terminated string\");\n-\n-  return ptr;\n-}\n-\n-\n-/* Return the next tag in the input block IB.  */\n-\n-static inline enum LTO_tags\n-input_record_start (struct lto_input_block *ib)\n-{\n-  return lto_input_enum (ib, LTO_tags, LTO_NUM_TAGS);\n-}\n-\n-\n /* Lookup STRING in file_name_hash_table.  If found, return the existing\n    string, otherwise insert STRING as the canonical version.  */\n \n@@ -252,6 +99,7 @@ canon_file_name (const char *string)\n   void **slot;\n   struct string_slot s_slot;\n   s_slot.s = string;\n+  s_slot.len = strlen (string);\n \n   slot = htab_find_slot (file_name_hash_table, &s_slot, INSERT);\n   if (*slot == NULL)\n@@ -333,7 +181,7 @@ lto_input_location_bitpack (struct data_in *data_in, struct bitpack_d *bp)\n \n /* Read a location from input block IB.  */\n \n-static location_t\n+location_t\n lto_input_location (struct lto_input_block *ib, struct data_in *data_in)\n {\n   struct bitpack_d bp;\n@@ -350,7 +198,7 @@ lto_input_location (struct lto_input_block *ib, struct data_in *data_in)\n    representation of the tree using lto_input_tree.  FN is the\n    function scope for the read tree.  */\n \n-static tree\n+tree\n lto_input_tree_ref (struct lto_input_block *ib, struct data_in *data_in,\n \t\t    struct function *fn, enum LTO_tags tag)\n {\n@@ -411,33 +259,6 @@ lto_input_tree_ref (struct lto_input_block *ib, struct data_in *data_in,\n }\n \n \n-/* Read a chain of tree nodes from input block IB. DATA_IN contains\n-   tables and descriptors for the file being read.  */\n-\n-static tree\n-lto_input_chain (struct lto_input_block *ib, struct data_in *data_in)\n-{\n-  int i, count;\n-  tree first, prev, curr;\n-\n-  first = prev = NULL_TREE;\n-  count = lto_input_sleb128 (ib);\n-  for (i = 0; i < count; i++)\n-    {\n-      curr = lto_input_tree (ib, data_in);\n-      if (prev)\n-\tTREE_CHAIN (prev) = curr;\n-      else\n-\tfirst = curr;\n-\n-      TREE_CHAIN (curr) = NULL_TREE;\n-      prev = curr;\n-    }\n-\n-  return first;\n-}\n-\n-\n /* Read and return a double-linked list of catch handlers from input\n    block IB, using descriptors in DATA_IN.  */\n \n@@ -641,7 +462,7 @@ fixup_eh_region_pointers (struct function *fn, HOST_WIDE_INT root_region)\n \n /* Initialize EH support.  */\n \n-static void\n+void\n lto_init_eh (void)\n {\n   static bool eh_initialized_p = false;\n@@ -856,51 +677,6 @@ input_cfg (struct lto_input_block *ib, struct function *fn,\n }\n \n \n-/* Read a PHI function for basic block BB in function FN.  DATA_IN is\n-   the file being read.  IB is the input block to use for reading.  */\n-\n-static gimple\n-input_phi (struct lto_input_block *ib, basic_block bb, struct data_in *data_in,\n-\t   struct function *fn)\n-{\n-  unsigned HOST_WIDE_INT ix;\n-  tree phi_result;\n-  int i, len;\n-  gimple result;\n-\n-  ix = lto_input_uleb128 (ib);\n-  phi_result = VEC_index (tree, SSANAMES (fn), ix);\n-  len = EDGE_COUNT (bb->preds);\n-  result = create_phi_node (phi_result, bb);\n-  SSA_NAME_DEF_STMT (phi_result) = result;\n-\n-  /* We have to go through a lookup process here because the preds in the\n-     reconstructed graph are generally in a different order than they\n-     were in the original program.  */\n-  for (i = 0; i < len; i++)\n-    {\n-      tree def = lto_input_tree (ib, data_in);\n-      int src_index = lto_input_uleb128 (ib);\n-      location_t arg_loc = lto_input_location (ib, data_in);\n-      basic_block sbb = BASIC_BLOCK_FOR_FUNCTION (fn, src_index);\n-\n-      edge e = NULL;\n-      int j;\n-\n-      for (j = 0; j < len; j++)\n-\tif (EDGE_PRED (bb, j)->src == sbb)\n-\t  {\n-\t    e = EDGE_PRED (bb, j);\n-\t    break;\n-\t  }\n-\n-      add_phi_arg (result, def, e, arg_loc);\n-    }\n-\n-  return result;\n-}\n-\n-\n /* Read the SSA names array for function FN from DATA_IN using input\n    block IB.  */\n \n@@ -934,263 +710,6 @@ input_ssa_names (struct lto_input_block *ib, struct data_in *data_in,\n     }\n }\n \n-/* Read a statement with tag TAG in function FN from block IB using\n-   descriptors in DATA_IN.  */\n-\n-static gimple\n-input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n-\t\t   struct function *fn, enum LTO_tags tag)\n-{\n-  gimple stmt;\n-  enum gimple_code code;\n-  unsigned HOST_WIDE_INT num_ops;\n-  size_t i;\n-  struct bitpack_d bp;\n-\n-  code = lto_tag_to_gimple_code (tag);\n-\n-  /* Read the tuple header.  */\n-  bp = lto_input_bitpack (ib);\n-  num_ops = bp_unpack_var_len_unsigned (&bp);\n-  stmt = gimple_alloc (code, num_ops);\n-  stmt->gsbase.no_warning = bp_unpack_value (&bp, 1);\n-  if (is_gimple_assign (stmt))\n-    stmt->gsbase.nontemporal_move = bp_unpack_value (&bp, 1);\n-  stmt->gsbase.has_volatile_ops = bp_unpack_value (&bp, 1);\n-  stmt->gsbase.subcode = bp_unpack_var_len_unsigned (&bp);\n-\n-  /* Read location information.  */\n-  gimple_set_location (stmt, lto_input_location (ib, data_in));\n-\n-  /* Read lexical block reference.  */\n-  gimple_set_block (stmt, lto_input_tree (ib, data_in));\n-\n-  /* Read in all the operands.  */\n-  switch (code)\n-    {\n-    case GIMPLE_RESX:\n-      gimple_resx_set_region (stmt, lto_input_sleb128 (ib));\n-      break;\n-\n-    case GIMPLE_EH_MUST_NOT_THROW:\n-      gimple_eh_must_not_throw_set_fndecl (stmt, lto_input_tree (ib, data_in));\n-      break;\n-\n-    case GIMPLE_EH_DISPATCH:\n-      gimple_eh_dispatch_set_region (stmt, lto_input_sleb128 (ib));\n-      break;\n-\n-    case GIMPLE_ASM:\n-      {\n-\t/* FIXME lto.  Move most of this into a new gimple_asm_set_string().  */\n-\ttree str;\n-\tstmt->gimple_asm.ni = lto_input_uleb128 (ib);\n-\tstmt->gimple_asm.no = lto_input_uleb128 (ib);\n-\tstmt->gimple_asm.nc = lto_input_uleb128 (ib);\n-\tstmt->gimple_asm.nl = lto_input_uleb128 (ib);\n-\tstr = input_string_cst (data_in, ib);\n-\tstmt->gimple_asm.string = TREE_STRING_POINTER (str);\n-      }\n-      /* Fallthru  */\n-\n-    case GIMPLE_ASSIGN:\n-    case GIMPLE_CALL:\n-    case GIMPLE_RETURN:\n-    case GIMPLE_SWITCH:\n-    case GIMPLE_LABEL:\n-    case GIMPLE_COND:\n-    case GIMPLE_GOTO:\n-    case GIMPLE_DEBUG:\n-      for (i = 0; i < num_ops; i++)\n-\t{\n-\t  tree op = lto_input_tree (ib, data_in);\n-\t  gimple_set_op (stmt, i, op);\n-\t  if (!op)\n-\t    continue;\n-\n-\t  /* Fixup FIELD_DECLs in COMPONENT_REFs, they are not handled\n-\t     by decl merging.  */\n-\t  if (TREE_CODE (op) == ADDR_EXPR)\n-\t    op = TREE_OPERAND (op, 0);\n-\t  while (handled_component_p (op))\n-\t    {\n-\t      if (TREE_CODE (op) == COMPONENT_REF)\n-\t\t{\n-\t\t  tree field, type, tem;\n-\t\t  tree closest_match = NULL_TREE;\n-\t\t  field = TREE_OPERAND (op, 1);\n-\t\t  type = DECL_CONTEXT (field);\n-\t\t  for (tem = TYPE_FIELDS (type); tem; tem = TREE_CHAIN (tem))\n-\t\t    {\n-\t\t      if (tem == field)\n-\t\t\tbreak;\n-\t\t      if (DECL_NONADDRESSABLE_P (tem)\n-\t\t\t  == DECL_NONADDRESSABLE_P (field)\n-\t\t\t  && gimple_compare_field_offset (tem, field))\n-\t\t\t{\n-\t\t\t  if (types_compatible_p (TREE_TYPE (tem),\n-\t\t\t\t\t\t  TREE_TYPE (field)))\n-\t\t\t    break;\n-\t\t\t  else\n-\t\t\t    closest_match = tem;\n-\t\t\t}\n-\t\t    }\n-\t\t  /* In case of type mismatches across units we can fail\n-\t\t     to unify some types and thus not find a proper\n-\t\t     field-decl here.  */\n-\t\t  if (tem == NULL_TREE)\n-\t\t    {\n-\t\t      /* Thus, emit a ODR violation warning.  */\n-\t\t      if (warning_at (gimple_location (stmt), 0,\n-\t\t\t\t      \"use of type %<%E%> with two mismatching \"\n-\t\t\t\t      \"declarations at field %<%E%>\",\n-\t\t\t\t      type, TREE_OPERAND (op, 1)))\n-\t\t\t{\n-\t\t\t  if (TYPE_FIELDS (type))\n-\t\t\t    inform (DECL_SOURCE_LOCATION (TYPE_FIELDS (type)),\n-\t\t\t\t    \"original type declared here\");\n-\t\t\t  inform (DECL_SOURCE_LOCATION (TREE_OPERAND (op, 1)),\n-\t\t\t\t  \"field in mismatching type declared here\");\n-\t\t\t  if (TYPE_NAME (TREE_TYPE (field))\n-\t\t\t      && (TREE_CODE (TYPE_NAME (TREE_TYPE (field)))\n-\t\t\t\t  == TYPE_DECL))\n-\t\t\t    inform (DECL_SOURCE_LOCATION\n-\t\t\t\t      (TYPE_NAME (TREE_TYPE (field))),\n-\t\t\t\t    \"type of field declared here\");\n-\t\t\t  if (closest_match\n-\t\t\t      && TYPE_NAME (TREE_TYPE (closest_match))\n-\t\t\t      && (TREE_CODE (TYPE_NAME\n-\t\t\t\t   (TREE_TYPE (closest_match))) == TYPE_DECL))\n-\t\t\t    inform (DECL_SOURCE_LOCATION\n-\t\t\t\t      (TYPE_NAME (TREE_TYPE (closest_match))),\n-\t\t\t\t    \"type of mismatching field declared here\");\n-\t\t\t}\n-\t\t      /* And finally fixup the types.  */\n-\t\t      TREE_OPERAND (op, 0)\n-\t\t\t= build1 (VIEW_CONVERT_EXPR, type,\n-\t\t\t\t  TREE_OPERAND (op, 0));\n-\t\t    }\n-\t\t  else\n-\t\t    TREE_OPERAND (op, 1) = tem;\n-\t\t}\n-\n-\t      op = TREE_OPERAND (op, 0);\n-\t    }\n-\t}\n-      if (is_gimple_call (stmt))\n-\t{\n-\t  if (gimple_call_internal_p (stmt))\n-\t    gimple_call_set_internal_fn\n-\t      (stmt, lto_input_enum (ib, internal_fn, IFN_LAST));\n-\t  else\n-\t    gimple_call_set_fntype (stmt, lto_input_tree (ib, data_in));\n-\t}\n-      break;\n-\n-    case GIMPLE_NOP:\n-    case GIMPLE_PREDICT:\n-      break;\n-\n-    default:\n-      internal_error (\"bytecode stream: unknown GIMPLE statement tag %s\",\n-\t\t      lto_tag_name (tag));\n-    }\n-\n-  /* Update the properties of symbols, SSA names and labels associated\n-     with STMT.  */\n-  if (code == GIMPLE_ASSIGN || code == GIMPLE_CALL)\n-    {\n-      tree lhs = gimple_get_lhs (stmt);\n-      if (lhs && TREE_CODE (lhs) == SSA_NAME)\n-\tSSA_NAME_DEF_STMT (lhs) = stmt;\n-    }\n-  else if (code == GIMPLE_LABEL)\n-    gcc_assert (emit_label_in_global_context_p (gimple_label_label (stmt))\n-\t        || DECL_CONTEXT (gimple_label_label (stmt)) == fn->decl);\n-  else if (code == GIMPLE_ASM)\n-    {\n-      unsigned i;\n-\n-      for (i = 0; i < gimple_asm_noutputs (stmt); i++)\n-\t{\n-\t  tree op = TREE_VALUE (gimple_asm_output_op (stmt, i));\n-\t  if (TREE_CODE (op) == SSA_NAME)\n-\t    SSA_NAME_DEF_STMT (op) = stmt;\n-\t}\n-    }\n-\n-  /* Reset alias information.  */\n-  if (code == GIMPLE_CALL)\n-    gimple_call_reset_alias_info (stmt);\n-\n-  /* Mark the statement modified so its operand vectors can be filled in.  */\n-  gimple_set_modified (stmt, true);\n-\n-  return stmt;\n-}\n-\n-\n-/* Read a basic block with tag TAG from DATA_IN using input block IB.\n-   FN is the function being processed.  */\n-\n-static void\n-input_bb (struct lto_input_block *ib, enum LTO_tags tag,\n-\t  struct data_in *data_in, struct function *fn,\n-\t  int count_materialization_scale)\n-{\n-  unsigned int index;\n-  basic_block bb;\n-  gimple_stmt_iterator bsi;\n-\n-  /* This routine assumes that CFUN is set to FN, as it needs to call\n-     basic GIMPLE routines that use CFUN.  */\n-  gcc_assert (cfun == fn);\n-\n-  index = lto_input_uleb128 (ib);\n-  bb = BASIC_BLOCK_FOR_FUNCTION (fn, index);\n-\n-  bb->count = (lto_input_sleb128 (ib) * count_materialization_scale\n-\t       + REG_BR_PROB_BASE / 2) / REG_BR_PROB_BASE;\n-  bb->loop_depth = lto_input_sleb128 (ib);\n-  bb->frequency = lto_input_sleb128 (ib);\n-  bb->flags = lto_input_sleb128 (ib);\n-\n-  /* LTO_bb1 has statements.  LTO_bb0 does not.  */\n-  if (tag == LTO_bb0)\n-    return;\n-\n-  bsi = gsi_start_bb (bb);\n-  tag = input_record_start (ib);\n-  while (tag)\n-    {\n-      gimple stmt = input_gimple_stmt (ib, data_in, fn, tag);\n-      if (!is_gimple_debug (stmt))\n-\tfind_referenced_vars_in (stmt);\n-      gsi_insert_after (&bsi, stmt, GSI_NEW_STMT);\n-\n-      /* After the statement, expect a 0 delimiter or the EH region\n-\t that the previous statement belongs to.  */\n-      tag = input_record_start (ib);\n-      lto_tag_check_set (tag, 2, LTO_eh_region, LTO_null);\n-\n-      if (tag == LTO_eh_region)\n-\t{\n-\t  HOST_WIDE_INT region = lto_input_sleb128 (ib);\n-\t  gcc_assert (region == (int) region);\n-\t  add_stmt_to_eh_lp (stmt, region);\n-\t}\n-\n-      tag = input_record_start (ib);\n-    }\n-\n-  tag = input_record_start (ib);\n-  while (tag)\n-    {\n-      gimple phi = input_phi (ib, bb, data_in, fn);\n-      find_referenced_vars_in (phi);\n-      tag = input_record_start (ib);\n-    }\n-}\n \n /* Go through all NODE edges and fixup call_stmt pointers\n    so they point to STMTS.  */\n@@ -1525,994 +1044,13 @@ lto_input_constructors_and_inits (struct lto_file_decl_data *file_data,\n }\n \n \n-/* Unpack all the non-pointer fields of the TS_BASE structure of\n-   expression EXPR from bitpack BP.  */\n-\n-static void\n-unpack_ts_base_value_fields (struct bitpack_d *bp, tree expr)\n-{\n-  /* Note that the code for EXPR has already been unpacked to create EXPR in\n-     lto_materialize_tree.  */\n-  if (!TYPE_P (expr))\n-    {\n-      TREE_SIDE_EFFECTS (expr) = (unsigned) bp_unpack_value (bp, 1);\n-      TREE_CONSTANT (expr) = (unsigned) bp_unpack_value (bp, 1);\n-      TREE_READONLY (expr) = (unsigned) bp_unpack_value (bp, 1);\n-\n-      /* TREE_PUBLIC is used on types to indicate that the type\n-\t has a TYPE_CACHED_VALUES vector.  This is not streamed out,\n-\t so we skip it here.  */\n-      TREE_PUBLIC (expr) = (unsigned) bp_unpack_value (bp, 1);\n-    }\n-  else\n-    bp_unpack_value (bp, 4);\n-  TREE_ADDRESSABLE (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  TREE_THIS_VOLATILE (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  if (DECL_P (expr))\n-    DECL_UNSIGNED (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  else if (TYPE_P (expr))\n-    TYPE_UNSIGNED (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  else\n-    bp_unpack_value (bp, 1);\n-  TREE_ASM_WRITTEN (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  if (TYPE_P (expr))\n-    TYPE_ARTIFICIAL (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  else\n-    TREE_NO_WARNING (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  TREE_USED (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  TREE_NOTHROW (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  TREE_STATIC (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  TREE_PRIVATE (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  TREE_PROTECTED (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  TREE_DEPRECATED (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  if (TYPE_P (expr))\n-    TYPE_SATURATING (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  else if (TREE_CODE (expr) == SSA_NAME)\n-    SSA_NAME_IS_DEFAULT_DEF (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  else\n-    bp_unpack_value (bp, 1);\n-}\n-\n-\n-/* Unpack all the non-pointer fields of the TS_REAL_CST structure of\n-   expression EXPR from bitpack BP.  */\n-\n-static void\n-unpack_ts_real_cst_value_fields (struct bitpack_d *bp, tree expr)\n-{\n-  unsigned i;\n-  REAL_VALUE_TYPE r;\n-  REAL_VALUE_TYPE *rp;\n-\n-  r.cl = (unsigned) bp_unpack_value (bp, 2);\n-  r.decimal = (unsigned) bp_unpack_value (bp, 1);\n-  r.sign = (unsigned) bp_unpack_value (bp, 1);\n-  r.signalling = (unsigned) bp_unpack_value (bp, 1);\n-  r.canonical = (unsigned) bp_unpack_value (bp, 1);\n-  r.uexp = (unsigned) bp_unpack_value (bp, EXP_BITS);\n-  for (i = 0; i < SIGSZ; i++)\n-    r.sig[i] = (unsigned long) bp_unpack_value (bp, HOST_BITS_PER_LONG);\n-\n-  rp = ggc_alloc_real_value ();\n-  memcpy (rp, &r, sizeof (REAL_VALUE_TYPE));\n-  TREE_REAL_CST_PTR (expr) = rp;\n-}\n-\n-\n-/* Unpack all the non-pointer fields of the TS_FIXED_CST structure of\n-   expression EXPR from bitpack BP.  */\n-\n-static void\n-unpack_ts_fixed_cst_value_fields (struct bitpack_d *bp, tree expr)\n-{\n-  struct fixed_value fv;\n-\n-  fv.mode = bp_unpack_enum (bp, machine_mode, MAX_MACHINE_MODE);\n-  fv.data.low = bp_unpack_var_len_int (bp);\n-  fv.data.high = bp_unpack_var_len_int (bp);\n-  TREE_FIXED_CST (expr) = fv;\n-}\n-\n-\n-/* Unpack all the non-pointer fields of the TS_DECL_COMMON structure\n-   of expression EXPR from bitpack BP.  */\n-\n-static void\n-unpack_ts_decl_common_value_fields (struct bitpack_d *bp, tree expr)\n-{\n-  DECL_MODE (expr) = bp_unpack_enum (bp, machine_mode, MAX_MACHINE_MODE);\n-  DECL_NONLOCAL (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  DECL_VIRTUAL_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  DECL_IGNORED_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  DECL_ABSTRACT (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  DECL_ARTIFICIAL (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  DECL_USER_ALIGN (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  DECL_PRESERVE_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  DECL_DEBUG_EXPR_IS_FROM (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  DECL_EXTERNAL (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  DECL_GIMPLE_REG_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  DECL_ALIGN (expr) = (unsigned) bp_unpack_var_len_unsigned (bp);\n-\n-  if (TREE_CODE (expr) == LABEL_DECL)\n-    {\n-      DECL_ERROR_ISSUED (expr) = (unsigned) bp_unpack_value (bp, 1);\n-      EH_LANDING_PAD_NR (expr) = (int) bp_unpack_var_len_unsigned (bp);\n-\n-      /* Always assume an initial value of -1 for LABEL_DECL_UID to\n-\t force gimple_set_bb to recreate label_to_block_map.  */\n-      LABEL_DECL_UID (expr) = -1;\n-    }\n-\n-  if (TREE_CODE (expr) == FIELD_DECL)\n-    {\n-      DECL_PACKED (expr) = (unsigned) bp_unpack_value (bp, 1);\n-      DECL_NONADDRESSABLE_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n-      expr->decl_common.off_align = bp_unpack_value (bp, 8);\n-    }\n-\n-  if (TREE_CODE (expr) == RESULT_DECL\n-      || TREE_CODE (expr) == PARM_DECL\n-      || TREE_CODE (expr) == VAR_DECL)\n-    {\n-      DECL_BY_REFERENCE (expr) = (unsigned) bp_unpack_value (bp, 1);\n-      if (TREE_CODE (expr) == VAR_DECL\n-\t  || TREE_CODE (expr) == PARM_DECL)\n-\tDECL_HAS_VALUE_EXPR_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n-      DECL_RESTRICTED_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n-    }\n-}\n-\n-\n-/* Unpack all the non-pointer fields of the TS_DECL_WRTL structure\n-   of expression EXPR from bitpack BP.  */\n-\n-static void\n-unpack_ts_decl_wrtl_value_fields (struct bitpack_d *bp, tree expr)\n-{\n-  DECL_REGISTER (expr) = (unsigned) bp_unpack_value (bp, 1);\n-}\n-\n-\n-/* Unpack all the non-pointer fields of the TS_DECL_WITH_VIS structure\n-   of expression EXPR from bitpack BP.  */\n-\n-static void\n-unpack_ts_decl_with_vis_value_fields (struct bitpack_d *bp, tree expr)\n-{\n-  DECL_DEFER_OUTPUT (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  DECL_COMMON (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  DECL_DLLIMPORT_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  DECL_WEAK (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  DECL_SEEN_IN_BIND_EXPR_P (expr) = (unsigned) bp_unpack_value (bp,  1);\n-  DECL_COMDAT (expr) = (unsigned) bp_unpack_value (bp,  1);\n-  DECL_VISIBILITY (expr) = (enum symbol_visibility) bp_unpack_value (bp,  2);\n-  DECL_VISIBILITY_SPECIFIED (expr) = (unsigned) bp_unpack_value (bp,  1);\n-\n-  if (TREE_CODE (expr) == VAR_DECL)\n-    {\n-      DECL_HARD_REGISTER (expr) = (unsigned) bp_unpack_value (bp, 1);\n-      DECL_IN_TEXT_SECTION (expr) = (unsigned) bp_unpack_value (bp, 1);\n-      DECL_IN_CONSTANT_POOL (expr) = (unsigned) bp_unpack_value (bp, 1);\n-      DECL_TLS_MODEL (expr) = (enum tls_model) bp_unpack_value (bp,  3);\n-    }\n-\n-  if (VAR_OR_FUNCTION_DECL_P (expr))\n-    {\n-      priority_type p;\n-      p = (priority_type) bp_unpack_var_len_unsigned (bp);\n-      SET_DECL_INIT_PRIORITY (expr, p);\n-    }\n-}\n-\n-\n-/* Unpack all the non-pointer fields of the TS_FUNCTION_DECL structure\n-   of expression EXPR from bitpack BP.  */\n-\n-static void\n-unpack_ts_function_decl_value_fields (struct bitpack_d *bp, tree expr)\n-{\n-  DECL_BUILT_IN_CLASS (expr) = bp_unpack_enum (bp, built_in_class,\n-\t\t\t\t\t       BUILT_IN_LAST);\n-  DECL_STATIC_CONSTRUCTOR (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  DECL_STATIC_DESTRUCTOR (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  DECL_UNINLINABLE (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  DECL_POSSIBLY_INLINED (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  DECL_IS_NOVOPS (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  DECL_IS_RETURNS_TWICE (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  DECL_IS_MALLOC (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  DECL_IS_OPERATOR_NEW (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  DECL_DECLARED_INLINE_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  DECL_STATIC_CHAIN (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  DECL_NO_INLINE_WARNING_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (expr)\n-    \t\t\t= (unsigned) bp_unpack_value (bp, 1);\n-  DECL_NO_LIMIT_STACK (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  DECL_DISREGARD_INLINE_LIMITS (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  DECL_PURE_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  DECL_LOOPING_CONST_OR_PURE_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  if (DECL_BUILT_IN_CLASS (expr) != NOT_BUILT_IN)\n-    {\n-      DECL_FUNCTION_CODE (expr) = (enum built_in_function) bp_unpack_value (bp, 11);\n-      if (DECL_BUILT_IN_CLASS (expr) == BUILT_IN_NORMAL\n-\t  && DECL_FUNCTION_CODE (expr) >= END_BUILTINS)\n-\tfatal_error (\"machine independent builtin code out of range\");\n-      else if (DECL_BUILT_IN_CLASS (expr) == BUILT_IN_MD)\n-\t{\n-          tree result = targetm.builtin_decl (DECL_FUNCTION_CODE (expr), true);\n-\t  if (!result || result == error_mark_node)\n-\t    fatal_error (\"target specific builtin not available\");\n-\t}\n-    }\n-  if (DECL_STATIC_DESTRUCTOR (expr))\n-    {\n-      priority_type p;\n-      p = (priority_type) bp_unpack_var_len_unsigned (bp);\n-      SET_DECL_FINI_PRIORITY (expr, p);\n-    }\n-}\n-\n-\n-/* Unpack all the non-pointer fields of the TS_TYPE_COMMON structure\n-   of expression EXPR from bitpack BP.  */\n+/* LTO streamer hook for reading GIMPLE trees.  IB and DATA_IN are as in\n+   lto_read_tree.  EXPR is the tree was materialized by lto_read_tree and\n+   needs GIMPLE specific data to be filled in.  */\n \n-static void\n-unpack_ts_type_common_value_fields (struct bitpack_d *bp, tree expr)\n-{\n-  enum machine_mode mode;\n-\n-  mode = bp_unpack_enum (bp, machine_mode, MAX_MACHINE_MODE);\n-  SET_TYPE_MODE (expr, mode);\n-  TYPE_STRING_FLAG (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  TYPE_NO_FORCE_BLK (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  TYPE_NEEDS_CONSTRUCTING (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  if (RECORD_OR_UNION_TYPE_P (expr))\n-    TYPE_TRANSPARENT_AGGR (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  TYPE_PACKED (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  TYPE_RESTRICT (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  TYPE_CONTAINS_PLACEHOLDER_INTERNAL (expr)\n-    \t= (unsigned) bp_unpack_value (bp, 2);\n-  TYPE_USER_ALIGN (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  TYPE_READONLY (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  TYPE_PRECISION (expr) = bp_unpack_var_len_unsigned (bp);\n-  TYPE_ALIGN (expr) = bp_unpack_var_len_unsigned (bp);\n-  TYPE_ALIAS_SET (expr) = bp_unpack_var_len_int (bp);\n-}\n-\n-\n-/* Unpack all the non-pointer fields of the TS_BLOCK structure\n-   of expression EXPR from bitpack BP.  */\n-\n-static void\n-unpack_ts_block_value_fields (struct bitpack_d *bp, tree expr)\n-{\n-  BLOCK_ABSTRACT (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  /* BLOCK_NUMBER is recomputed.  */\n-}\n-\n-/* Unpack all the non-pointer fields of the TS_TRANSLATION_UNIT_DECL\n-   structure of expression EXPR from bitpack BP.  */\n-\n-static void\n-unpack_ts_translation_unit_decl_value_fields (struct bitpack_d *bp ATTRIBUTE_UNUSED, tree expr ATTRIBUTE_UNUSED)\n-{\n-}\n-\n-/* Unpack all the non-pointer fields in EXPR into a bit pack.  */\n-\n-static void\n-unpack_value_fields (struct bitpack_d *bp, tree expr)\n-{\n-  enum tree_code code;\n-\n-  code = TREE_CODE (expr);\n-\n-  /* Note that all these functions are highly sensitive to changes in\n-     the types and sizes of each of the fields being packed.  */\n-  unpack_ts_base_value_fields (bp, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_REAL_CST))\n-    unpack_ts_real_cst_value_fields (bp, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_FIXED_CST))\n-    unpack_ts_fixed_cst_value_fields (bp, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n-    unpack_ts_decl_common_value_fields (bp, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WRTL))\n-    unpack_ts_decl_wrtl_value_fields (bp, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n-    unpack_ts_decl_with_vis_value_fields (bp, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_FUNCTION_DECL))\n-    unpack_ts_function_decl_value_fields (bp, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_COMMON))\n-    unpack_ts_type_common_value_fields (bp, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_BLOCK))\n-    unpack_ts_block_value_fields (bp, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_TRANSLATION_UNIT_DECL))\n-    unpack_ts_translation_unit_decl_value_fields (bp, expr);\n-\n-  if (streamer_hooks.unpack_value_fields)\n-    streamer_hooks.unpack_value_fields (bp, expr);\n-}\n-\n-\n-/* Materialize a new tree from input block IB using descriptors in\n-   DATA_IN.  The code for the new tree should match TAG.  Store in\n-   *IX_P the index into the reader cache where the new tree is stored.  */\n-\n-static tree\n-lto_materialize_tree (struct lto_input_block *ib, struct data_in *data_in,\n-\t\t      enum LTO_tags tag)\n-{\n-  struct bitpack_d bp;\n-  enum tree_code code;\n-  tree result;\n-#ifdef LTO_STREAMER_DEBUG\n-  HOST_WIDEST_INT orig_address_in_writer;\n-#endif\n-\n-  result = NULL_TREE;\n-\n-#ifdef LTO_STREAMER_DEBUG\n-  /* Read the word representing the memory address for the tree\n-     as it was written by the writer.  This is useful when\n-     debugging differences between the writer and reader.  */\n-  orig_address_in_writer = lto_input_sleb128 (ib);\n-  gcc_assert ((intptr_t) orig_address_in_writer == orig_address_in_writer);\n-#endif\n-\n-  code = lto_tag_to_tree_code (tag);\n-\n-  /* We should never see an SSA_NAME tree.  Only the version numbers of\n-     SSA names are ever written out.  See input_ssa_names.  */\n-  gcc_assert (code != SSA_NAME);\n-\n-  /* Instantiate a new tree using the header data.  */\n-  if (CODE_CONTAINS_STRUCT (code, TS_STRING))\n-    result = input_string_cst (data_in, ib);\n-  else if (CODE_CONTAINS_STRUCT (code, TS_IDENTIFIER))\n-    result = input_identifier (data_in, ib);\n-  else if (CODE_CONTAINS_STRUCT (code, TS_VEC))\n-    {\n-      HOST_WIDE_INT len = lto_input_sleb128 (ib);\n-      result = make_tree_vec (len);\n-    }\n-  else if (CODE_CONTAINS_STRUCT (code, TS_BINFO))\n-    {\n-      unsigned HOST_WIDE_INT len = lto_input_uleb128 (ib);\n-      result = make_tree_binfo (len);\n-    }\n-  else\n-    {\n-      /* For all other nodes, see if the streamer knows how to allocate\n-\t it.  */\n-      if (streamer_hooks.alloc_tree)\n-\tresult = streamer_hooks.alloc_tree (code, ib, data_in);\n-\n-      /* If the hook did not handle it, materialize the tree with a raw\n-\t make_node call.  */\n-      if (result == NULL_TREE)\n-\tresult = make_node (code);\n-    }\n-\n-#ifdef LTO_STREAMER_DEBUG\n-  /* Store the original address of the tree as seen by the writer\n-     in RESULT's aux field.  This is useful when debugging streaming\n-     problems.  This way, a debugging session can be started on\n-     both writer and reader with a breakpoint using this address\n-     value in both.  */\n-  lto_orig_address_map (result, (intptr_t) orig_address_in_writer);\n-#endif\n-\n-  /* Read the bitpack of non-pointer values from IB.  */\n-  bp = lto_input_bitpack (ib);\n-\n-  /* The first word in BP contains the code of the tree that we\n-     are about to read.  */\n-  code = (enum tree_code) bp_unpack_value (&bp, 16);\n-  lto_tag_check (lto_tree_code_to_tag (code), tag);\n-\n-  /* Unpack all the value fields from BP.  */\n-  unpack_value_fields (&bp, result);\n-\n-  /* Enter RESULT in the reader cache.  This will make RESULT\n-     available so that circular references in the rest of the tree\n-     structure can be resolved in subsequent calls to lto_input_tree.  */\n-  lto_streamer_cache_append (data_in->reader_cache, result);\n-\n-  return result;\n-}\n-\n-\n-/* Read all pointer fields in the TS_COMMON structure of EXPR from input\n-   block IB.  DATA_IN contains tables and descriptors for the\n-   file being read.  */\n-\n-\n-static void\n-lto_input_ts_common_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t   struct data_in *data_in, tree expr)\n-{\n-  if (TREE_CODE (expr) != IDENTIFIER_NODE)\n-    TREE_TYPE (expr) = lto_input_tree (ib, data_in);\n-}\n-\n-\n-/* Read all pointer fields in the TS_VECTOR structure of EXPR from input\n-   block IB.  DATA_IN contains tables and descriptors for the\n-   file being read.  */\n-\n-static void\n-lto_input_ts_vector_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t   struct data_in *data_in, tree expr)\n-{\n-  TREE_VECTOR_CST_ELTS (expr) = lto_input_chain (ib, data_in);\n-}\n-\n-\n-/* Read all pointer fields in the TS_COMPLEX structure of EXPR from input\n-   block IB.  DATA_IN contains tables and descriptors for the\n-   file being read.  */\n-\n-static void\n-lto_input_ts_complex_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t    struct data_in *data_in, tree expr)\n-{\n-  TREE_REALPART (expr) = lto_input_tree (ib, data_in);\n-  TREE_IMAGPART (expr) = lto_input_tree (ib, data_in);\n-}\n-\n-\n-/* Read all pointer fields in the TS_DECL_MINIMAL structure of EXPR\n-   from input block IB.  DATA_IN contains tables and descriptors for the\n-   file being read.  */\n-\n-static void\n-lto_input_ts_decl_minimal_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t\t struct data_in *data_in, tree expr)\n-{\n-  DECL_NAME (expr) = lto_input_tree (ib, data_in);\n-  DECL_CONTEXT (expr) = lto_input_tree (ib, data_in);\n-  DECL_SOURCE_LOCATION (expr) = lto_input_location (ib, data_in);\n-}\n-\n-\n-/* Read all pointer fields in the TS_DECL_COMMON structure of EXPR from\n-   input block IB.  DATA_IN contains tables and descriptors for the\n-   file being read.  */\n-\n-static void\n-lto_input_ts_decl_common_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t\tstruct data_in *data_in, tree expr)\n-{\n-  DECL_SIZE (expr) = lto_input_tree (ib, data_in);\n-  DECL_SIZE_UNIT (expr) = lto_input_tree (ib, data_in);\n-  DECL_ATTRIBUTES (expr) = lto_input_tree (ib, data_in);\n-\n-  /* Do not stream DECL_ABSTRACT_ORIGIN.  We cannot handle debug information\n-     for early inlining so drop it on the floor instead of ICEing in\n-     dwarf2out.c.  */\n-\n-  if (TREE_CODE (expr) == PARM_DECL)\n-    TREE_CHAIN (expr) = lto_input_chain (ib, data_in);\n-\n-  if ((TREE_CODE (expr) == VAR_DECL\n-       || TREE_CODE (expr) == PARM_DECL)\n-      && DECL_HAS_VALUE_EXPR_P (expr))\n-    SET_DECL_VALUE_EXPR (expr, lto_input_tree (ib, data_in));\n-\n-  if (TREE_CODE (expr) == VAR_DECL)\n-    {\n-      tree dexpr = lto_input_tree (ib, data_in);\n-      if (dexpr)\n-\tSET_DECL_DEBUG_EXPR (expr, dexpr);\n-    }\n-}\n-\n-\n-/* Read all pointer fields in the TS_DECL_NON_COMMON structure of\n-   EXPR from input block IB.  DATA_IN contains tables and descriptors for the\n-   file being read.  */\n-\n-static void\n-lto_input_ts_decl_non_common_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t\t    struct data_in *data_in, tree expr)\n-{\n-  if (TREE_CODE (expr) == FUNCTION_DECL)\n-    {\n-      DECL_ARGUMENTS (expr) = lto_input_tree (ib, data_in);\n-      DECL_RESULT (expr) = lto_input_tree (ib, data_in);\n-    }\n-  DECL_VINDEX (expr) = lto_input_tree (ib, data_in);\n-}\n-\n-\n-/* Read all pointer fields in the TS_DECL_WITH_VIS structure of EXPR\n-   from input block IB.  DATA_IN contains tables and descriptors for the\n-   file being read.  */\n-\n-static void\n-lto_input_ts_decl_with_vis_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t          struct data_in *data_in, tree expr)\n-{\n-  tree id;\n-\n-  id = lto_input_tree (ib, data_in);\n-  if (id)\n-    {\n-      gcc_assert (TREE_CODE (id) == IDENTIFIER_NODE);\n-      SET_DECL_ASSEMBLER_NAME (expr, id);\n-    }\n-\n-  DECL_SECTION_NAME (expr) = lto_input_tree (ib, data_in);\n-  DECL_COMDAT_GROUP (expr) = lto_input_tree (ib, data_in);\n-}\n-\n-\n-/* Read all pointer fields in the TS_FIELD_DECL structure of EXPR from\n-   input block IB.  DATA_IN contains tables and descriptors for the\n-   file being read.  */\n-\n-static void\n-lto_input_ts_field_decl_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t       struct data_in *data_in, tree expr)\n-{\n-  DECL_FIELD_OFFSET (expr) = lto_input_tree (ib, data_in);\n-  DECL_BIT_FIELD_TYPE (expr) = lto_input_tree (ib, data_in);\n-  DECL_QUALIFIER (expr) = lto_input_tree (ib, data_in);\n-  DECL_FIELD_BIT_OFFSET (expr) = lto_input_tree (ib, data_in);\n-  DECL_FCONTEXT (expr) = lto_input_tree (ib, data_in);\n-  TREE_CHAIN (expr) = lto_input_chain (ib, data_in);\n-}\n-\n-\n-/* Read all pointer fields in the TS_FUNCTION_DECL structure of EXPR\n-   from input block IB.  DATA_IN contains tables and descriptors for the\n-   file being read.  */\n-\n-static void\n-lto_input_ts_function_decl_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t\t  struct data_in *data_in, tree expr)\n-{\n-  /* DECL_STRUCT_FUNCTION is handled by lto_input_function.  FIXME lto,\n-     maybe it should be handled here?  */\n-  DECL_FUNCTION_PERSONALITY (expr) = lto_input_tree (ib, data_in);\n-  DECL_FUNCTION_SPECIFIC_TARGET (expr) = lto_input_tree (ib, data_in);\n-  DECL_FUNCTION_SPECIFIC_OPTIMIZATION (expr) = lto_input_tree (ib, data_in);\n-\n-  /* If the file contains a function with an EH personality set,\n-     then it was compiled with -fexceptions.  In that case, initialize\n-     the backend EH machinery.  */\n-  if (DECL_FUNCTION_PERSONALITY (expr))\n-    lto_init_eh ();\n-}\n-\n-\n-/* Read all pointer fields in the TS_TYPE_COMMON structure of EXPR from\n-   input block IB.  DATA_IN contains tables and descriptors for the file\n-   being read.  */\n-\n-static void\n-lto_input_ts_type_common_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t\tstruct data_in *data_in, tree expr)\n-{\n-  TYPE_SIZE (expr) = lto_input_tree (ib, data_in);\n-  TYPE_SIZE_UNIT (expr) = lto_input_tree (ib, data_in);\n-  TYPE_ATTRIBUTES (expr) = lto_input_tree (ib, data_in);\n-  TYPE_NAME (expr) = lto_input_tree (ib, data_in);\n-  /* Do not stream TYPE_POINTER_TO or TYPE_REFERENCE_TO.  They will be\n-     reconstructed during fixup.  */\n-  /* Do not stream TYPE_NEXT_VARIANT, we reconstruct the variant lists\n-     during fixup.  */\n-  TYPE_MAIN_VARIANT (expr) = lto_input_tree (ib, data_in);\n-  TYPE_CONTEXT (expr) = lto_input_tree (ib, data_in);\n-  /* TYPE_CANONICAL gets re-computed during type merging.  */\n-  TYPE_CANONICAL (expr) = NULL_TREE;\n-  TYPE_STUB_DECL (expr) = lto_input_tree (ib, data_in);\n-}\n-\n-/* Read all pointer fields in the TS_TYPE_NON_COMMON structure of EXPR\n-   from input block IB.  DATA_IN contains tables and descriptors for the\n-   file being read.  */\n-\n-static void\n-lto_input_ts_type_non_common_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t\t    struct data_in *data_in,\n-\t\t\t\t\t    tree expr)\n-{\n-  if (TREE_CODE (expr) == ENUMERAL_TYPE)\n-    TYPE_VALUES (expr) = lto_input_tree (ib, data_in);\n-  else if (TREE_CODE (expr) == ARRAY_TYPE)\n-    TYPE_DOMAIN (expr) = lto_input_tree (ib, data_in);\n-  else if (RECORD_OR_UNION_TYPE_P (expr))\n-    TYPE_FIELDS (expr) = lto_input_tree (ib, data_in);\n-  else if (TREE_CODE (expr) == FUNCTION_TYPE\n-\t   || TREE_CODE (expr) == METHOD_TYPE)\n-    TYPE_ARG_TYPES (expr) = lto_input_tree (ib, data_in);\n-\n-  if (!POINTER_TYPE_P (expr))\n-    TYPE_MINVAL (expr) = lto_input_tree (ib, data_in);\n-  TYPE_MAXVAL (expr) = lto_input_tree (ib, data_in);\n-  if (RECORD_OR_UNION_TYPE_P (expr))\n-    TYPE_BINFO (expr) = lto_input_tree (ib, data_in);\n-}\n-\n-\n-/* Read all pointer fields in the TS_LIST structure of EXPR from input\n-   block IB.  DATA_IN contains tables and descriptors for the\n-   file being read.  */\n-\n-static void\n-lto_input_ts_list_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t struct data_in *data_in, tree expr)\n-{\n-  TREE_PURPOSE (expr) = lto_input_tree (ib, data_in);\n-  TREE_VALUE (expr) = lto_input_tree (ib, data_in);\n-  TREE_CHAIN (expr) = lto_input_chain (ib, data_in);\n-}\n-\n-\n-/* Read all pointer fields in the TS_VEC structure of EXPR from input\n-   block IB.  DATA_IN contains tables and descriptors for the\n-   file being read.  */\n-\n-static void\n-lto_input_ts_vec_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\tstruct data_in *data_in, tree expr)\n-{\n-  int i;\n-\n-  /* Note that TREE_VEC_LENGTH was read by lto_materialize_tree to\n-     instantiate EXPR.  */\n-  for (i = 0; i < TREE_VEC_LENGTH (expr); i++)\n-    TREE_VEC_ELT (expr, i) = lto_input_tree (ib, data_in);\n-}\n-\n-\n-/* Read all pointer fields in the TS_EXP structure of EXPR from input\n-   block IB.  DATA_IN contains tables and descriptors for the\n-   file being read.  */\n-\n-\n-static void\n-lto_input_ts_exp_tree_pointers (struct lto_input_block *ib,\n-\t\t\t        struct data_in *data_in, tree expr)\n-{\n-  int i, length;\n-  location_t loc;\n-\n-  length = lto_input_sleb128 (ib);\n-  gcc_assert (length == TREE_OPERAND_LENGTH (expr));\n-\n-  for (i = 0; i < length; i++)\n-    TREE_OPERAND (expr, i) = lto_input_tree (ib, data_in);\n-\n-  loc = lto_input_location (ib, data_in);\n-  SET_EXPR_LOCATION (expr, loc);\n-  TREE_BLOCK (expr) = lto_input_tree (ib, data_in);\n-}\n-\n-\n-/* Read all pointer fields in the TS_BLOCK structure of EXPR from input\n-   block IB.  DATA_IN contains tables and descriptors for the\n-   file being read.  */\n-\n-static void\n-lto_input_ts_block_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t  struct data_in *data_in, tree expr)\n-{\n-  /* Do not stream BLOCK_SOURCE_LOCATION.  We cannot handle debug information\n-     for early inlining so drop it on the floor instead of ICEing in\n-     dwarf2out.c.  */\n-  BLOCK_VARS (expr) = lto_input_chain (ib, data_in);\n-\n-  /* Do not stream BLOCK_NONLOCALIZED_VARS.  We cannot handle debug information\n-     for early inlining so drop it on the floor instead of ICEing in\n-     dwarf2out.c.  */\n-\n-  BLOCK_SUPERCONTEXT (expr) = lto_input_tree (ib, data_in);\n-  /* Do not stream BLOCK_ABSTRACT_ORIGIN.  We cannot handle debug information\n-     for early inlining so drop it on the floor instead of ICEing in\n-     dwarf2out.c.  */\n-  BLOCK_FRAGMENT_ORIGIN (expr) = lto_input_tree (ib, data_in);\n-  BLOCK_FRAGMENT_CHAIN (expr) = lto_input_tree (ib, data_in);\n-  /* We re-compute BLOCK_SUBBLOCKS of our parent here instead\n-     of streaming it.  For non-BLOCK BLOCK_SUPERCONTEXTs we still\n-     stream the child relationship explicitly.  */\n-  if (BLOCK_SUPERCONTEXT (expr)\n-      && TREE_CODE (BLOCK_SUPERCONTEXT (expr)) == BLOCK)\n-    {\n-      BLOCK_CHAIN (expr) = BLOCK_SUBBLOCKS (BLOCK_SUPERCONTEXT (expr));\n-      BLOCK_SUBBLOCKS (BLOCK_SUPERCONTEXT (expr)) = expr;\n-    }\n-  /* The global block is rooted at the TU decl.  Hook it here to\n-     avoid the need to stream in this block during WPA time.  */\n-  else if (BLOCK_SUPERCONTEXT (expr)\n-\t   && TREE_CODE (BLOCK_SUPERCONTEXT (expr)) == TRANSLATION_UNIT_DECL)\n-    DECL_INITIAL (BLOCK_SUPERCONTEXT (expr)) = expr;\n-  /* The function-level block is connected at the time we read in\n-     function bodies for the same reason.  */\n-}\n-\n-\n-/* Read all pointer fields in the TS_BINFO structure of EXPR from input\n-   block IB.  DATA_IN contains tables and descriptors for the\n-   file being read.  */\n-\n-static void\n-lto_input_ts_binfo_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t  struct data_in *data_in, tree expr)\n-{\n-  unsigned i, len;\n-  tree t;\n-\n-  /* Note that the number of slots in EXPR was read in\n-     lto_materialize_tree when instantiating EXPR.  However, the\n-     vector is empty so we cannot rely on VEC_length to know how many\n-     elements to read.  So, this list is emitted as a 0-terminated\n-     list on the writer side.  */\n-  do\n-    {\n-      t = lto_input_tree (ib, data_in);\n-      if (t)\n-\tVEC_quick_push (tree, BINFO_BASE_BINFOS (expr), t);\n-    }\n-  while (t);\n-\n-  BINFO_OFFSET (expr) = lto_input_tree (ib, data_in);\n-  BINFO_VTABLE (expr) = lto_input_tree (ib, data_in);\n-  BINFO_VIRTUALS (expr) = lto_input_tree (ib, data_in);\n-  BINFO_VPTR_FIELD (expr) = lto_input_tree (ib, data_in);\n-\n-  len = lto_input_uleb128 (ib);\n-  if (len > 0)\n-    {\n-      VEC_reserve_exact (tree, gc, BINFO_BASE_ACCESSES (expr), len);\n-      for (i = 0; i < len; i++)\n-\t{\n-\t  tree a = lto_input_tree (ib, data_in);\n-\t  VEC_quick_push (tree, BINFO_BASE_ACCESSES (expr), a);\n-\t}\n-    }\n-\n-  BINFO_INHERITANCE_CHAIN (expr) = lto_input_tree (ib, data_in);\n-  BINFO_SUBVTT_INDEX (expr) = lto_input_tree (ib, data_in);\n-  BINFO_VPTR_INDEX (expr) = lto_input_tree (ib, data_in);\n-}\n-\n-\n-/* Read all pointer fields in the TS_CONSTRUCTOR structure of EXPR from\n-   input block IB.  DATA_IN contains tables and descriptors for the\n-   file being read.  */\n-\n-static void\n-lto_input_ts_constructor_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t        struct data_in *data_in, tree expr)\n-{\n-  unsigned i, len;\n-\n-  len = lto_input_uleb128 (ib);\n-  for (i = 0; i < len; i++)\n-    {\n-      tree index, value;\n-\n-      index = lto_input_tree (ib, data_in);\n-      value = lto_input_tree (ib, data_in);\n-      CONSTRUCTOR_APPEND_ELT (CONSTRUCTOR_ELTS (expr), index, value);\n-    }\n-}\n-\n-\n-/* Input a TS_TARGET_OPTION tree from IB into EXPR.  */\n-\n-static void\n-lto_input_ts_target_option (struct lto_input_block *ib, tree expr)\n-{\n-  unsigned i, len;\n-  struct bitpack_d bp;\n-  struct cl_target_option *t = TREE_TARGET_OPTION (expr);\n-\n-  bp = lto_input_bitpack (ib);\n-  len = sizeof (struct cl_target_option);\n-  for (i = 0; i < len; i++)\n-    ((unsigned char *)t)[i] = bp_unpack_value (&bp, 8);\n-  if (bp_unpack_value (&bp, 32) != 0x12345678)\n-    fatal_error (\"cl_target_option size mismatch in LTO reader and writer\");\n-}\n-\n-/* Input a TS_TRANSLATION_UNIT_DECL tree from IB and DATA_IN into EXPR.  */\n-\n-static void\n-lto_input_ts_translation_unit_decl_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t\t\t  struct data_in *data_in,\n-\t\t\t\t\t\t  tree expr)\n-{\n-  TRANSLATION_UNIT_LANGUAGE (expr) = xstrdup (lto_input_string (data_in, ib));\n-  VEC_safe_push (tree, gc, all_translation_units, expr);\n-}\n-\n-/* Helper for lto_input_tree.  Read all pointer fields in EXPR from\n-   input block IB.  DATA_IN contains tables and descriptors for the\n-   file being read.  */\n-\n-static void\n-lto_input_tree_pointers (struct lto_input_block *ib, struct data_in *data_in,\n-\t\t\t tree expr)\n-{\n-  enum tree_code code;\n-\n-  code = TREE_CODE (expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_TYPED))\n-    lto_input_ts_common_tree_pointers (ib, data_in, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_VECTOR))\n-    lto_input_ts_vector_tree_pointers (ib, data_in, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_COMPLEX))\n-    lto_input_ts_complex_tree_pointers (ib, data_in, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_DECL_MINIMAL))\n-    lto_input_ts_decl_minimal_tree_pointers (ib, data_in, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n-    lto_input_ts_decl_common_tree_pointers (ib, data_in, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_DECL_NON_COMMON))\n-    lto_input_ts_decl_non_common_tree_pointers (ib, data_in, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n-    lto_input_ts_decl_with_vis_tree_pointers (ib, data_in, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_FIELD_DECL))\n-    lto_input_ts_field_decl_tree_pointers (ib, data_in, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_FUNCTION_DECL))\n-    lto_input_ts_function_decl_tree_pointers (ib, data_in, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_COMMON))\n-    lto_input_ts_type_common_tree_pointers (ib, data_in, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_NON_COMMON))\n-    lto_input_ts_type_non_common_tree_pointers (ib, data_in, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_LIST))\n-    lto_input_ts_list_tree_pointers (ib, data_in, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_VEC))\n-    lto_input_ts_vec_tree_pointers (ib, data_in, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_EXP))\n-    lto_input_ts_exp_tree_pointers (ib, data_in, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_BLOCK))\n-    lto_input_ts_block_tree_pointers (ib, data_in, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_BINFO))\n-    lto_input_ts_binfo_tree_pointers (ib, data_in, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_CONSTRUCTOR))\n-    lto_input_ts_constructor_tree_pointers (ib, data_in, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_TARGET_OPTION))\n-    lto_input_ts_target_option (ib, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_TRANSLATION_UNIT_DECL))\n-    lto_input_ts_translation_unit_decl_tree_pointers (ib, data_in, expr);\n-}\n-\n-\n-/* Read an index IX from input block IB and return the tree node at\n-   DATA_IN->FILE_DATA->GLOBALS_INDEX[IX].  */\n-\n-static tree\n-lto_get_pickled_tree (struct lto_input_block *ib, struct data_in *data_in)\n-{\n-  unsigned HOST_WIDE_INT ix;\n-  tree result;\n-  enum LTO_tags expected_tag;\n-\n-  ix = lto_input_uleb128 (ib);\n-  expected_tag = lto_input_enum (ib, LTO_tags, LTO_NUM_TAGS);\n-\n-  result = lto_streamer_cache_get (data_in->reader_cache, ix);\n-  gcc_assert (result\n-              && TREE_CODE (result) == lto_tag_to_tree_code (expected_tag));\n-\n-  return result;\n-}\n-\n-\n-/* Read a code and class from input block IB and return the\n-   corresponding builtin.  DATA_IN is as in lto_input_tree.  */\n-\n-static tree\n-lto_get_builtin_tree (struct lto_input_block *ib, struct data_in *data_in)\n-{\n-  enum built_in_class fclass;\n-  enum built_in_function fcode;\n-  const char *asmname;\n-  tree result;\n-\n-  fclass = lto_input_enum (ib, built_in_class, BUILT_IN_LAST);\n-  gcc_assert (fclass == BUILT_IN_NORMAL || fclass == BUILT_IN_MD);\n-\n-  fcode = (enum built_in_function) lto_input_uleb128 (ib);\n-\n-  if (fclass == BUILT_IN_NORMAL)\n-    {\n-      if (fcode >= END_BUILTINS)\n-\tfatal_error (\"machine independent builtin code out of range\");\n-      result = built_in_decls[fcode];\n-      gcc_assert (result);\n-    }\n-  else if (fclass == BUILT_IN_MD)\n-    {\n-      result = targetm.builtin_decl (fcode, true);\n-      if (!result || result == error_mark_node)\n-\tfatal_error (\"target specific builtin not available\");\n-    }\n-  else\n-    gcc_unreachable ();\n-\n-  asmname = lto_input_string (data_in, ib);\n-  if (asmname)\n-    set_builtin_user_assembler_name (result, asmname);\n-\n-  lto_streamer_cache_append (data_in->reader_cache, result);\n-\n-  return result;\n-}\n-\n-\n-/* Read the physical representation of a tree node with tag TAG from\n-   input block IB using the per-file context in DATA_IN.  */\n-\n-static tree\n-lto_read_tree (struct lto_input_block *ib, struct data_in *data_in,\n-\t       enum LTO_tags tag)\n-{\n-  tree result;\n-\n-  result = lto_materialize_tree (ib, data_in, tag);\n-\n-  /* Read all the pointer fields in RESULT.  */\n-  lto_input_tree_pointers (ib, data_in, result);\n-\n-  /* Call back into the streaming module to read anything else it\n-     may need.  */\n-  if (streamer_hooks.read_tree)\n-    streamer_hooks.read_tree (ib, data_in, result);\n-\n-  /* We should never try to instantiate an MD or NORMAL builtin here.  */\n-  if (TREE_CODE (result) == FUNCTION_DECL)\n-    gcc_assert (!lto_stream_as_builtin_p (result));\n-\n-  /* end_marker = */ lto_input_1_unsigned (ib);\n-\n-#ifdef LTO_STREAMER_DEBUG\n-  /* Remove the mapping to RESULT's original address set by\n-     lto_materialize_tree.  */\n-  lto_orig_address_remove (result);\n-#endif\n-\n-  return result;\n-}\n-\n-\n-/* LTO streamer hook for reading GIMPLE trees.  IB and DATA_IN are as in\n-   lto_read_tree.  EXPR is the tree was materialized by lto_read_tree and\n-   needs GIMPLE specific data to be filled in.  */\n-\n-void\n-lto_streamer_read_tree (struct lto_input_block *ib, struct data_in *data_in,\n-\t\t\ttree expr)\n+void\n+lto_streamer_read_tree (struct lto_input_block *ib, struct data_in *data_in,\n+\t\t\ttree expr)\n {\n   if (DECL_P (expr)\n       && TREE_CODE (expr) != FUNCTION_DECL\n@@ -2521,84 +1059,6 @@ lto_streamer_read_tree (struct lto_input_block *ib, struct data_in *data_in,\n }\n \n \n-/* Read and INTEGER_CST node from input block IB using the per-file\n-   context in DATA_IN.  */\n-\n-static tree\n-lto_input_integer_cst (struct lto_input_block *ib, struct data_in *data_in)\n-{\n-  tree result, type;\n-  HOST_WIDE_INT low, high;\n-  bool overflow_p;\n-\n-  type = lto_input_tree (ib, data_in);\n-  overflow_p = (lto_input_1_unsigned (ib) != 0);\n-  low = lto_input_uleb128 (ib);\n-  high = lto_input_uleb128 (ib);\n-  result = build_int_cst_wide (type, low, high);\n-\n-  /* If the original constant had overflown, build a replica of RESULT to\n-     avoid modifying the shared constant returned by build_int_cst_wide.  */\n-  if (overflow_p)\n-    {\n-      result = copy_node (result);\n-      TREE_OVERFLOW (result) = 1;\n-    }\n-\n-  return result;\n-}\n-\n-\n-/* Read a tree from input block IB using the per-file context in\n-   DATA_IN.  This context is used, for example, to resolve references\n-   to previously read nodes.  */\n-\n-tree\n-lto_input_tree (struct lto_input_block *ib, struct data_in *data_in)\n-{\n-  enum LTO_tags tag;\n-  tree result;\n-\n-  tag = input_record_start (ib);\n-  gcc_assert ((unsigned) tag < (unsigned) LTO_NUM_TAGS);\n-\n-  if (tag == LTO_null)\n-    result = NULL_TREE;\n-  else if (tag >= LTO_field_decl_ref && tag <= LTO_global_decl_ref)\n-    {\n-      /* If TAG is a reference to an indexable tree, the next value\n-\t in IB is the index into the table where we expect to find\n-\t that tree.  */\n-      result = lto_input_tree_ref (ib, data_in, cfun, tag);\n-    }\n-  else if (tag == LTO_tree_pickle_reference)\n-    {\n-      /* If TAG is a reference to a previously read tree, look it up in\n-\t the reader cache.  */\n-      result = lto_get_pickled_tree (ib, data_in);\n-    }\n-  else if (tag == LTO_builtin_decl)\n-    {\n-      /* If we are going to read a built-in function, all we need is\n-\t the code and class.  */\n-      result = lto_get_builtin_tree (ib, data_in);\n-    }\n-  else if (tag == lto_tree_code_to_tag (INTEGER_CST))\n-    {\n-      /* For integer constants we only need the type and its hi/low\n-\t words.  */\n-      result = lto_input_integer_cst (ib, data_in);\n-    }\n-  else\n-    {\n-      /* Otherwise, materialize a new node from IB.  */\n-      result = lto_read_tree (ib, data_in, tag);\n-    }\n-\n-  return result;\n-}\n-\n-\n /* Initialization for the LTO reader.  */\n \n void"}, {"sha": "0b84b082aac7fb9c68aaecf7254276f46ef2755e", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 166, "deletions": 1531, "changes": 1697, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=f0efc7aa7705facdb16a39a08137cf748c7d5f30", "patch": "@@ -41,45 +41,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"vec.h\"\n #include \"lto-symtab.h\"\n #include \"lto-streamer.h\"\n-\n-\n-struct string_slot\n-{\n-  const char *s;\n-  int len;\n-  unsigned int slot_num;\n-};\n-\n-\n-/* Returns a hash code for P.  \n-   Shamelessly stollen from libiberty.  */\n-\n-static hashval_t\n-hash_string_slot_node (const void *p)\n-{\n-  const struct string_slot *ds = (const struct string_slot *) p;\n-  hashval_t r = ds->len;\n-  int i;\n-\n-  for (i = 0; i < ds->len; i++)\n-     r = r * 67 + (unsigned)ds->s[i] - 113;\n-  return r;\n-}\n-\n-\n-/* Returns nonzero if P1 and P2 are equal.  */\n-\n-static int\n-eq_string_slot_node (const void *p1, const void *p2)\n-{\n-  const struct string_slot *ds1 = (const struct string_slot *) p1;\n-  const struct string_slot *ds2 = (const struct string_slot *) p2;\n-\n-  if (ds1->len == ds2->len)\n-    return memcmp (ds1->s, ds2->s, ds1->len) == 0;\n-\n-  return 0;\n-}\n+#include \"data-streamer.h\"\n+#include \"gimple-streamer.h\"\n+#include \"tree-streamer.h\"\n+#include \"streamer-hooks.h\"\n \n \n /* Clear the line info stored in DATA_IN.  */\n@@ -108,1371 +73,225 @@ create_output_block (enum lto_section_type section_type)\n   ob->writer_cache = lto_streamer_cache_create ();\n \n   if (section_type == LTO_section_function_body)\n-    ob->cfg_stream = XCNEW (struct lto_output_stream);\n-\n-  clear_line_info (ob);\n-\n-  ob->string_hash_table = htab_create (37, hash_string_slot_node,\n-\t\t\t\t       eq_string_slot_node, NULL);\n-  gcc_obstack_init (&ob->obstack);\n-\n-  return ob;\n-}\n-\n-\n-/* Destroy the output block OB.  */\n-\n-void\n-destroy_output_block (struct output_block *ob)\n-{\n-  enum lto_section_type section_type = ob->section_type;\n-\n-  htab_delete (ob->string_hash_table);\n-\n-  free (ob->main_stream);\n-  free (ob->string_stream);\n-  if (section_type == LTO_section_function_body)\n-    free (ob->cfg_stream);\n-\n-  lto_streamer_cache_delete (ob->writer_cache);\n-  obstack_free (&ob->obstack, NULL);\n-\n-  free (ob);\n-}\n-\n-/* Return index used to reference STRING of LEN characters in the string table\n-   in OB.  The string might or might not include a trailing '\\0'.\n-   Then put the index onto the INDEX_STREAM.  \n-   When PERSISTENT is set, the string S is supposed to not change during\n-   duration of the OB and thus OB can keep pointer into it.  */\n-\n-static unsigned\n-lto_string_index (struct output_block *ob,\n-\t\t  const char *s,\n-\t\t  unsigned int len,\n-\t\t  bool persistent)\n-{\n-  struct string_slot **slot;\n-  struct string_slot s_slot;\n-\n-  s_slot.s = s;\n-  s_slot.len = len;\n-  s_slot.slot_num = 0;\n-\n-  slot = (struct string_slot **) htab_find_slot (ob->string_hash_table,\n-\t\t\t\t\t\t &s_slot, INSERT);\n-  if (*slot == NULL)\n-    {\n-      struct lto_output_stream *string_stream = ob->string_stream;\n-      unsigned int start = string_stream->total_size;\n-      struct string_slot *new_slot\n-\t= XOBNEW (&ob->obstack, struct string_slot);\n-      const char *string;\n-\n-      if (!persistent)\n-\t{\n-\t  char *tmp;\n-\t  string = tmp = XOBNEWVEC (&ob->obstack, char, len);\n-          memcpy (tmp, s, len);\n-        }\n-      else\n-\tstring = s;\n-\n-      new_slot->s = string;\n-      new_slot->len = len;\n-      new_slot->slot_num = start;\n-      *slot = new_slot;\n-      lto_output_uleb128_stream (string_stream, len);\n-      lto_output_data_stream (string_stream, string, len);\n-      return start + 1;\n-    }\n-  else\n-    {\n-      struct string_slot *old_slot = *slot;\n-      return old_slot->slot_num + 1;\n-    }\n-}\n-\n-\n-/* Output STRING of LEN characters to the string\n-   table in OB. The string might or might not include a trailing '\\0'.\n-   Then put the index onto the INDEX_STREAM. \n-   When PERSISTENT is set, the string S is supposed to not change during\n-   duration of the OB and thus OB can keep pointer into it.  */\n-\n-static void\n-lto_output_string_with_length (struct output_block *ob,\n-\t\t\t       struct lto_output_stream *index_stream,\n-\t\t\t       const char *s,\n-\t\t\t       unsigned int len,\n-\t\t\t       bool persistent)\n-{\n-  if (s)\n-    lto_output_uleb128_stream (index_stream,\n-\t\t\t       lto_string_index (ob, s, len, persistent));\n-  else\n-    lto_output_1_stream (index_stream, 0);\n-}\n-\n-/* Output the '\\0' terminated STRING to the string\n-   table in OB.  Then put the index onto the INDEX_STREAM.\n-   When PERSISTENT is set, the string S is supposed to not change during\n-   duration of the OB and thus OB can keep pointer into it.  */\n-\n-static void\n-lto_output_string (struct output_block *ob,\n-\t           struct lto_output_stream *index_stream,\n-\t           const char *string,\n-\t\t   bool persistent)\n-{\n-  if (string)\n-    lto_output_string_with_length (ob, index_stream, string,\n-\t\t\t\t   strlen (string) + 1,\n-\t\t\t\t   persistent);\n-  else\n-    lto_output_1_stream (index_stream, 0);\n-}\n-\n-\n-/* Output the STRING constant to the string\n-   table in OB.  Then put the index onto the INDEX_STREAM.  */\n-\n-static void\n-output_string_cst (struct output_block *ob,\n-\t\t   struct lto_output_stream *index_stream,\n-\t\t   tree string)\n-{\n-  lto_output_string_with_length (ob, index_stream,\n-\t\t\t\t TREE_STRING_POINTER (string),\n-\t\t\t\t TREE_STRING_LENGTH (string),\n-\t\t\t\t true);\n-}\n-\n-\n-/* Output the identifier ID to the string\n-   table in OB.  Then put the index onto the INDEX_STREAM.  */\n-\n-static void\n-output_identifier (struct output_block *ob,\n-\t\t   struct lto_output_stream *index_stream,\n-\t\t   tree id)\n-{\n-  lto_output_string_with_length (ob, index_stream,\n-\t\t\t\t IDENTIFIER_POINTER (id),\n-\t\t\t\t IDENTIFIER_LENGTH (id),\n-\t\t\t\t true);\n-}\n-\n-\n-/* Write a zero to the output stream.  */\n-\n-static void\n-output_zero (struct output_block *ob)\n-{\n-  lto_output_1_stream (ob->main_stream, 0);\n-}\n-\n-\n-/* Output an unsigned LEB128 quantity to OB->main_stream.  */\n-\n-static void\n-output_uleb128 (struct output_block *ob, unsigned HOST_WIDE_INT work)\n-{\n-  lto_output_uleb128_stream (ob->main_stream, work);\n-}\n-\n-\n-/* Output a signed LEB128 quantity to OB->main_stream.  */\n-\n-static void\n-output_sleb128 (struct output_block *ob, HOST_WIDE_INT work)\n-{\n-  lto_output_sleb128_stream (ob->main_stream, work);\n-}\n-\n-\n-/* Output the start of a record with TAG to output block OB.  */\n-\n-static inline void\n-output_record_start (struct output_block *ob, enum LTO_tags tag)\n-{\n-  lto_output_enum (ob->main_stream, LTO_tags, LTO_NUM_TAGS, tag);\n-}\n-\n-\n-/* Look up NODE in the type table and write the index for it to OB.  */\n-\n-static void\n-output_type_ref (struct output_block *ob, tree node)\n-{\n-  output_record_start (ob, LTO_type_ref);\n-  lto_output_type_ref_index (ob->decl_state, ob->main_stream, node);\n-}\n-\n-\n-/* Pack all the non-pointer fields of the TS_BASE structure of\n-   expression EXPR into bitpack BP.  */\n-\n-static void\n-pack_ts_base_value_fields (struct bitpack_d *bp, tree expr)\n-{\n-  bp_pack_value (bp, TREE_CODE (expr), 16);\n-  if (!TYPE_P (expr))\n-    {\n-      bp_pack_value (bp, TREE_SIDE_EFFECTS (expr), 1);\n-      bp_pack_value (bp, TREE_CONSTANT (expr), 1);\n-      bp_pack_value (bp, TREE_READONLY (expr), 1);\n-\n-      /* TREE_PUBLIC is used on types to indicate that the type\n-\t has a TYPE_CACHED_VALUES vector.  This is not streamed out,\n-\t so we skip it here.  */\n-      bp_pack_value (bp, TREE_PUBLIC (expr), 1);\n-    }\n-  else\n-    bp_pack_value (bp, 0, 4);\n-  bp_pack_value (bp, TREE_ADDRESSABLE (expr), 1);\n-  bp_pack_value (bp, TREE_THIS_VOLATILE (expr), 1);\n-  if (DECL_P (expr))\n-    bp_pack_value (bp, DECL_UNSIGNED (expr), 1);\n-  else if (TYPE_P (expr))\n-    bp_pack_value (bp, TYPE_UNSIGNED (expr), 1);\n-  else\n-    bp_pack_value (bp, 0, 1);\n-  /* We write debug info two times, do not confuse the second one.  */\n-  bp_pack_value (bp, TYPE_P (expr) ? 0 : TREE_ASM_WRITTEN (expr), 1);\n-  if (TYPE_P (expr))\n-    bp_pack_value (bp, TYPE_ARTIFICIAL (expr), 1);\n-  else\n-    bp_pack_value (bp, TREE_NO_WARNING (expr), 1);\n-  bp_pack_value (bp, TREE_USED (expr), 1);\n-  bp_pack_value (bp, TREE_NOTHROW (expr), 1);\n-  bp_pack_value (bp, TREE_STATIC (expr), 1);\n-  bp_pack_value (bp, TREE_PRIVATE (expr), 1);\n-  bp_pack_value (bp, TREE_PROTECTED (expr), 1);\n-  bp_pack_value (bp, TREE_DEPRECATED (expr), 1);\n-  if (TYPE_P (expr))\n-    bp_pack_value (bp, TYPE_SATURATING (expr), 1);\n-  else if (TREE_CODE (expr) == SSA_NAME)\n-    bp_pack_value (bp, SSA_NAME_IS_DEFAULT_DEF (expr), 1);\n-  else\n-    bp_pack_value (bp, 0, 1);\n-}\n-\n-\n-/* Pack all the non-pointer fields of the TS_REAL_CST structure of\n-   expression EXPR into bitpack BP.  */\n-\n-static void\n-pack_ts_real_cst_value_fields (struct bitpack_d *bp, tree expr)\n-{\n-  unsigned i;\n-  REAL_VALUE_TYPE r;\n-\n-  r = TREE_REAL_CST (expr);\n-  bp_pack_value (bp, r.cl, 2);\n-  bp_pack_value (bp, r.decimal, 1);\n-  bp_pack_value (bp, r.sign, 1);\n-  bp_pack_value (bp, r.signalling, 1);\n-  bp_pack_value (bp, r.canonical, 1);\n-  bp_pack_value (bp, r.uexp, EXP_BITS);\n-  for (i = 0; i < SIGSZ; i++)\n-    bp_pack_value (bp, r.sig[i], HOST_BITS_PER_LONG);\n-}\n-\n-\n-/* Pack all the non-pointer fields of the TS_FIXED_CST structure of\n-   expression EXPR into bitpack BP.  */\n-\n-static void\n-pack_ts_fixed_cst_value_fields (struct bitpack_d *bp, tree expr)\n-{\n-  struct fixed_value fv = TREE_FIXED_CST (expr);\n-  bp_pack_enum (bp, machine_mode, MAX_MACHINE_MODE, fv.mode);\n-  bp_pack_var_len_int (bp, fv.data.low);\n-  bp_pack_var_len_int (bp, fv.data.high);\n-}\n-\n-\n-/* Pack all the non-pointer fields of the TS_DECL_COMMON structure\n-   of expression EXPR into bitpack BP.  */\n-\n-static void\n-pack_ts_decl_common_value_fields (struct bitpack_d *bp, tree expr)\n-{\n-  bp_pack_enum (bp, machine_mode, MAX_MACHINE_MODE, DECL_MODE (expr));\n-  bp_pack_value (bp, DECL_NONLOCAL (expr), 1);\n-  bp_pack_value (bp, DECL_VIRTUAL_P (expr), 1);\n-  bp_pack_value (bp, DECL_IGNORED_P (expr), 1);\n-  bp_pack_value (bp, DECL_ABSTRACT (expr), 1);\n-  bp_pack_value (bp, DECL_ARTIFICIAL (expr), 1);\n-  bp_pack_value (bp, DECL_USER_ALIGN (expr), 1);\n-  bp_pack_value (bp, DECL_PRESERVE_P (expr), 1);\n-  bp_pack_value (bp, DECL_DEBUG_EXPR_IS_FROM (expr), 1);\n-  bp_pack_value (bp, DECL_EXTERNAL (expr), 1);\n-  bp_pack_value (bp, DECL_GIMPLE_REG_P (expr), 1);\n-  bp_pack_var_len_unsigned (bp, DECL_ALIGN (expr));\n-\n-  if (TREE_CODE (expr) == LABEL_DECL)\n-    {\n-      /* Note that we do not write LABEL_DECL_UID.  The reader will\n-\t always assume an initial value of -1 so that the\n-\t label_to_block_map is recreated by gimple_set_bb.  */\n-      bp_pack_value (bp, DECL_ERROR_ISSUED (expr), 1);\n-      bp_pack_var_len_unsigned (bp, EH_LANDING_PAD_NR (expr));\n-    }\n-\n-  if (TREE_CODE (expr) == FIELD_DECL)\n-    {\n-      bp_pack_value (bp, DECL_PACKED (expr), 1);\n-      bp_pack_value (bp, DECL_NONADDRESSABLE_P (expr), 1);\n-      bp_pack_value (bp, expr->decl_common.off_align, 8);\n-    }\n-\n-  if (TREE_CODE (expr) == RESULT_DECL\n-      || TREE_CODE (expr) == PARM_DECL\n-      || TREE_CODE (expr) == VAR_DECL)\n-    {\n-      bp_pack_value (bp, DECL_BY_REFERENCE (expr), 1);\n-      if (TREE_CODE (expr) == VAR_DECL\n-\t  || TREE_CODE (expr) == PARM_DECL)\n-\tbp_pack_value (bp, DECL_HAS_VALUE_EXPR_P (expr), 1);\n-      bp_pack_value (bp, DECL_RESTRICTED_P (expr), 1);\n-    }\n-}\n-\n-\n-/* Pack all the non-pointer fields of the TS_DECL_WRTL structure\n-   of expression EXPR into bitpack BP.  */\n-\n-static void\n-pack_ts_decl_wrtl_value_fields (struct bitpack_d *bp, tree expr)\n-{\n-  bp_pack_value (bp, DECL_REGISTER (expr), 1);\n-}\n-\n-\n-/* Pack all the non-pointer fields of the TS_DECL_WITH_VIS structure\n-   of expression EXPR into bitpack BP.  */\n-\n-static void\n-pack_ts_decl_with_vis_value_fields (struct bitpack_d *bp, tree expr)\n-{\n-  bp_pack_value (bp, DECL_DEFER_OUTPUT (expr), 1);\n-  bp_pack_value (bp, DECL_COMMON (expr), 1);\n-  bp_pack_value (bp, DECL_DLLIMPORT_P (expr), 1);\n-  bp_pack_value (bp, DECL_WEAK (expr), 1);\n-  bp_pack_value (bp, DECL_SEEN_IN_BIND_EXPR_P (expr),  1);\n-  bp_pack_value (bp, DECL_COMDAT (expr),  1);\n-  bp_pack_value (bp, DECL_VISIBILITY (expr),  2);\n-  bp_pack_value (bp, DECL_VISIBILITY_SPECIFIED (expr),  1);\n-\n-  if (TREE_CODE (expr) == VAR_DECL)\n-    {\n-      bp_pack_value (bp, DECL_HARD_REGISTER (expr), 1);\n-      bp_pack_value (bp, DECL_IN_TEXT_SECTION (expr), 1);\n-      bp_pack_value (bp, DECL_IN_CONSTANT_POOL (expr), 1);\n-      bp_pack_value (bp, DECL_TLS_MODEL (expr),  3);\n-    }\n-\n-  if (VAR_OR_FUNCTION_DECL_P (expr))\n-    bp_pack_var_len_unsigned (bp, DECL_INIT_PRIORITY (expr));\n-}\n-\n-\n-/* Pack all the non-pointer fields of the TS_FUNCTION_DECL structure\n-   of expression EXPR into bitpack BP.  */\n-\n-static void\n-pack_ts_function_decl_value_fields (struct bitpack_d *bp, tree expr)\n-{\n-  /* For normal/md builtins we only write the class and code, so they\n-     should never be handled here.  */\n-  gcc_assert (!lto_stream_as_builtin_p (expr));\n-\n-  bp_pack_enum (bp, built_in_class, BUILT_IN_LAST,\n-\t\tDECL_BUILT_IN_CLASS (expr));\n-  bp_pack_value (bp, DECL_STATIC_CONSTRUCTOR (expr), 1);\n-  bp_pack_value (bp, DECL_STATIC_DESTRUCTOR (expr), 1);\n-  bp_pack_value (bp, DECL_UNINLINABLE (expr), 1);\n-  bp_pack_value (bp, DECL_POSSIBLY_INLINED (expr), 1);\n-  bp_pack_value (bp, DECL_IS_NOVOPS (expr), 1);\n-  bp_pack_value (bp, DECL_IS_RETURNS_TWICE (expr), 1);\n-  bp_pack_value (bp, DECL_IS_MALLOC (expr), 1);\n-  bp_pack_value (bp, DECL_IS_OPERATOR_NEW (expr), 1);\n-  bp_pack_value (bp, DECL_DECLARED_INLINE_P (expr), 1);\n-  bp_pack_value (bp, DECL_STATIC_CHAIN (expr), 1);\n-  bp_pack_value (bp, DECL_NO_INLINE_WARNING_P (expr), 1);\n-  bp_pack_value (bp, DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (expr), 1);\n-  bp_pack_value (bp, DECL_NO_LIMIT_STACK (expr), 1);\n-  bp_pack_value (bp, DECL_DISREGARD_INLINE_LIMITS (expr), 1);\n-  bp_pack_value (bp, DECL_PURE_P (expr), 1);\n-  bp_pack_value (bp, DECL_LOOPING_CONST_OR_PURE_P (expr), 1);\n-  if (DECL_BUILT_IN_CLASS (expr) != NOT_BUILT_IN)\n-    bp_pack_value (bp, DECL_FUNCTION_CODE (expr), 11);\n-  if (DECL_STATIC_DESTRUCTOR (expr))\n-    bp_pack_var_len_unsigned (bp, DECL_FINI_PRIORITY (expr));\n-}\n-\n-\n-/* Pack all the non-pointer fields of the TS_TYPE_COMMON structure\n-   of expression EXPR into bitpack BP.  */\n-\n-static void\n-pack_ts_type_common_value_fields (struct bitpack_d *bp, tree expr)\n-{\n-  bp_pack_enum (bp, machine_mode, MAX_MACHINE_MODE, TYPE_MODE (expr));\n-  bp_pack_value (bp, TYPE_STRING_FLAG (expr), 1);\n-  bp_pack_value (bp, TYPE_NO_FORCE_BLK (expr), 1);\n-  bp_pack_value (bp, TYPE_NEEDS_CONSTRUCTING (expr), 1);\n-  if (RECORD_OR_UNION_TYPE_P (expr))\n-    bp_pack_value (bp, TYPE_TRANSPARENT_AGGR (expr), 1);\n-  bp_pack_value (bp, TYPE_PACKED (expr), 1);\n-  bp_pack_value (bp, TYPE_RESTRICT (expr), 1);\n-  bp_pack_value (bp, TYPE_CONTAINS_PLACEHOLDER_INTERNAL (expr), 2);\n-  bp_pack_value (bp, TYPE_USER_ALIGN (expr), 1);\n-  bp_pack_value (bp, TYPE_READONLY (expr), 1);\n-  bp_pack_var_len_unsigned (bp, TYPE_PRECISION (expr));\n-  bp_pack_var_len_unsigned (bp, TYPE_ALIGN (expr));\n-  bp_pack_var_len_int (bp, TYPE_ALIAS_SET (expr) == 0 ? 0 : -1);\n-}\n-\n-\n-/* Pack all the non-pointer fields of the TS_BLOCK structure\n-   of expression EXPR into bitpack BP.  */\n-\n-static void\n-pack_ts_block_value_fields (struct bitpack_d *bp, tree expr)\n-{\n-  bp_pack_value (bp, BLOCK_ABSTRACT (expr), 1);\n-  /* BLOCK_NUMBER is recomputed.  */\n-}\n-\n-/* Pack all the non-pointer fields of the TS_TRANSLATION_UNIT_DECL structure\n-   of expression EXPR into bitpack BP.  */\n-\n-static void\n-pack_ts_translation_unit_decl_value_fields (struct bitpack_d *bp ATTRIBUTE_UNUSED, tree expr ATTRIBUTE_UNUSED)\n-{\n-}\n-\n-/* Pack all the non-pointer fields in EXPR into a bit pack.  */\n-\n-static void\n-pack_value_fields (struct bitpack_d *bp, tree expr)\n-{\n-  enum tree_code code;\n-\n-  code = TREE_CODE (expr);\n-\n-  /* Note that all these functions are highly sensitive to changes in\n-     the types and sizes of each of the fields being packed.  */\n-  pack_ts_base_value_fields (bp, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_REAL_CST))\n-    pack_ts_real_cst_value_fields (bp, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_FIXED_CST))\n-    pack_ts_fixed_cst_value_fields (bp, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n-    pack_ts_decl_common_value_fields (bp, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WRTL))\n-    pack_ts_decl_wrtl_value_fields (bp, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n-    pack_ts_decl_with_vis_value_fields (bp, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_FUNCTION_DECL))\n-    pack_ts_function_decl_value_fields (bp, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_COMMON))\n-    pack_ts_type_common_value_fields (bp, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_BLOCK))\n-    pack_ts_block_value_fields (bp, expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_TRANSLATION_UNIT_DECL))\n-    pack_ts_translation_unit_decl_value_fields (bp, expr);\n-\n-  if (streamer_hooks.pack_value_fields)\n-    streamer_hooks.pack_value_fields (bp, expr);\n-}\n-\n-\n-/* Output info about new location into bitpack BP.\n-   After outputting bitpack, lto_output_location_data has\n-   to be done to output actual data.  */\n-\n-static inline void\n-lto_output_location_bitpack (struct bitpack_d *bp,\n-\t\t\t     struct output_block *ob,\n-\t\t\t     location_t loc)\n-{\n-  expanded_location xloc;\n-\n-  bp_pack_value (bp, loc == UNKNOWN_LOCATION, 1);\n-  if (loc == UNKNOWN_LOCATION)\n-    return;\n-\n-  xloc = expand_location (loc);\n-\n-  bp_pack_value (bp, ob->current_file != xloc.file, 1);\n-  if (ob->current_file != xloc.file)\n-    bp_pack_var_len_unsigned (bp, lto_string_index (ob,\n-\t\t\t\t\t            xloc.file,\n-\t\t\t\t\t\t    strlen (xloc.file) + 1,\n-\t\t\t\t\t\t    true));\n-  ob->current_file = xloc.file;\n-\n-  bp_pack_value (bp, ob->current_line != xloc.line, 1);\n-  if (ob->current_line != xloc.line)\n-    bp_pack_var_len_unsigned (bp, xloc.line);\n-  ob->current_line = xloc.line;\n-\n-  bp_pack_value (bp, ob->current_col != xloc.column, 1);\n-  if (ob->current_col != xloc.column)\n-    bp_pack_var_len_unsigned (bp, xloc.column);\n-  ob->current_col = xloc.column;\n-}\n-\n-\n-/* Emit location LOC to output block OB.\n-   When bitpack is handy, it is more space effecient to call\n-   lto_output_location_bitpack with existing bitpack.  */\n-\n-static void\n-lto_output_location (struct output_block *ob, location_t loc)\n-{\n-  struct bitpack_d bp = bitpack_create (ob->main_stream);\n-  lto_output_location_bitpack (&bp, ob, loc);\n-  lto_output_bitpack (&bp);\n-}\n-\n-\n-/* Return true if tree node T is written to various tables.  For these\n-   nodes, we sometimes want to write their phyiscal representation\n-   (via lto_output_tree), and sometimes we need to emit an index\n-   reference into a table (via lto_output_tree_ref).  */\n-\n-static bool\n-tree_is_indexable (tree t)\n-{\n-  if (TREE_CODE (t) == PARM_DECL)\n-    return false;\n-  else if (TREE_CODE (t) == VAR_DECL && decl_function_context (t)\n-\t   && !TREE_STATIC (t))\n-    return false;\n-  else\n-    return (TYPE_P (t) || DECL_P (t) || TREE_CODE (t) == SSA_NAME);\n-}\n-\n-\n-/* If EXPR is an indexable tree node, output a reference to it to\n-   output block OB.  Otherwise, output the physical representation of\n-   EXPR to OB.  */\n-\n-static void\n-lto_output_tree_ref (struct output_block *ob, tree expr)\n-{\n-  enum tree_code code;\n-\n-  if (expr == NULL_TREE)\n-    {\n-      output_record_start (ob, LTO_null);\n-      return;\n-    }\n-\n-  if (!tree_is_indexable (expr))\n-    {\n-      /* Even though we are emitting the physical representation of\n-\t EXPR, its leaves must be emitted as references.  */\n-      lto_output_tree (ob, expr, true);\n-      return;\n-    }\n-\n-  if (TYPE_P (expr))\n-    {\n-      output_type_ref (ob, expr);\n-      return;\n-    }\n-\n-  code = TREE_CODE (expr);\n-  switch (code)\n-    {\n-    case SSA_NAME:\n-      output_record_start (ob, LTO_ssa_name_ref);\n-      output_uleb128 (ob, SSA_NAME_VERSION (expr));\n-      break;\n-\n-    case FIELD_DECL:\n-      output_record_start (ob, LTO_field_decl_ref);\n-      lto_output_field_decl_index (ob->decl_state, ob->main_stream, expr);\n-      break;\n-\n-    case FUNCTION_DECL:\n-      output_record_start (ob, LTO_function_decl_ref);\n-      lto_output_fn_decl_index (ob->decl_state, ob->main_stream, expr);\n-      break;\n-\n-    case VAR_DECL:\n-    case DEBUG_EXPR_DECL:\n-      gcc_assert (decl_function_context (expr) == NULL\n-\t\t  || TREE_STATIC (expr));\n-      output_record_start (ob, LTO_global_decl_ref);\n-      lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n-      break;\n-\n-    case CONST_DECL:\n-      output_record_start (ob, LTO_const_decl_ref);\n-      lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n-      break;\n-\n-    case IMPORTED_DECL:\n-      gcc_assert (decl_function_context (expr) == NULL);\n-      output_record_start (ob, LTO_imported_decl_ref);\n-      lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n-      break;\n-\n-    case TYPE_DECL:\n-      output_record_start (ob, LTO_type_decl_ref);\n-      lto_output_type_decl_index (ob->decl_state, ob->main_stream, expr);\n-      break;\n-\n-    case NAMESPACE_DECL:\n-      output_record_start (ob, LTO_namespace_decl_ref);\n-      lto_output_namespace_decl_index (ob->decl_state, ob->main_stream, expr);\n-      break;\n-\n-    case LABEL_DECL:\n-      output_record_start (ob, LTO_label_decl_ref);\n-      lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n-      break;\n-\n-    case RESULT_DECL:\n-      output_record_start (ob, LTO_result_decl_ref);\n-      lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n-      break;\n-\n-    case TRANSLATION_UNIT_DECL:\n-      output_record_start (ob, LTO_translation_unit_decl_ref);\n-      lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n-      break;\n-\n-    default:\n-      {\n-\t/* See if the streamer allows this node to be indexable\n-\t   like other global declarations.  */\n-\tif (streamer_hooks.indexable_with_decls_p\n-\t    && streamer_hooks.indexable_with_decls_p (expr))\n-\t  {\n-\t    output_record_start (ob, LTO_global_decl_ref);\n-\t    lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n-\t  }\n-\telse\n-\t  {\n-\t    /* No other node is indexable, so it should have been\n-\t      handled by lto_output_tree.  */\n-\t    gcc_unreachable ();\n-\t  }\n-      }\n-    }\n-}\n-\n-\n-/* If REF_P is true, emit a reference to EXPR in output block OB,\n-   otherwise emit the physical representation of EXPR in OB.  */\n-\n-static inline void\n-lto_output_tree_or_ref (struct output_block *ob, tree expr, bool ref_p)\n-{\n-  if (ref_p)\n-    lto_output_tree_ref (ob, expr);\n-  else\n-    lto_output_tree (ob, expr, false);\n-}\n-\n-\n-/* Emit the chain of tree nodes starting at T.  OB is the output block\n-   to write to.  REF_P is true if chain elements should be emitted\n-   as references.  */\n-\n-static void\n-lto_output_chain (struct output_block *ob, tree t, bool ref_p)\n-{\n-  int i, count;\n-\n-  count = list_length (t);\n-  output_sleb128 (ob, count);\n-  for (i = 0; i < count; i++)\n-    {\n-      tree saved_chain;\n-\n-      /* Clear TREE_CHAIN to avoid blindly recursing into the rest\n-\t of the list.  */\n-      saved_chain = TREE_CHAIN (t);\n-      TREE_CHAIN (t) = NULL_TREE;\n-\n-      lto_output_tree_or_ref (ob, t, ref_p);\n-\n-      TREE_CHAIN (t) = saved_chain;\n-      t = TREE_CHAIN (t);\n-    }\n-}\n-\n-\n-/* Write all pointer fields in the TS_COMMON structure of EXPR to output\n-   block OB.  If REF_P is true, write a reference to EXPR's pointer\n-   fields.  */\n-\n-static void\n-lto_output_ts_common_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t    bool ref_p)\n-{\n-  if (TREE_CODE (expr) != IDENTIFIER_NODE)\n-    lto_output_tree_or_ref (ob, TREE_TYPE (expr), ref_p);\n-}\n-\n-\n-/* Write all pointer fields in the TS_VECTOR structure of EXPR to output\n-   block OB.  If REF_P is true, write a reference to EXPR's pointer\n-   fields.  */\n-\n-static void\n-lto_output_ts_vector_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t    bool ref_p)\n-{\n-  lto_output_chain (ob, TREE_VECTOR_CST_ELTS (expr), ref_p);\n-}\n-\n-\n-/* Write all pointer fields in the TS_COMPLEX structure of EXPR to output\n-   block OB.  If REF_P is true, write a reference to EXPR's pointer\n-   fields.  */\n-\n-static void\n-lto_output_ts_complex_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t     bool ref_p)\n-{\n-  lto_output_tree_or_ref (ob, TREE_REALPART (expr), ref_p);\n-  lto_output_tree_or_ref (ob, TREE_IMAGPART (expr), ref_p);\n-}\n-\n-\n-/* Write all pointer fields in the TS_DECL_MINIMAL structure of EXPR\n-   to output block OB.  If REF_P is true, write a reference to EXPR's\n-   pointer fields.  */\n-\n-static void\n-lto_output_ts_decl_minimal_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t\t  bool ref_p)\n-{\n-  lto_output_tree_or_ref (ob, DECL_NAME (expr), ref_p);\n-  lto_output_tree_or_ref (ob, DECL_CONTEXT (expr), ref_p);\n-  lto_output_location (ob, DECL_SOURCE_LOCATION (expr));\n-}\n-\n-\n-/* Write all pointer fields in the TS_DECL_COMMON structure of EXPR to\n-   output block OB.  If REF_P is true, write a reference to EXPR's\n-   pointer fields.  */\n-\n-static void\n-lto_output_ts_decl_common_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t\t bool ref_p)\n-{\n-  lto_output_tree_or_ref (ob, DECL_SIZE (expr), ref_p);\n-  lto_output_tree_or_ref (ob, DECL_SIZE_UNIT (expr), ref_p);\n-\n-  /* Note, DECL_INITIAL is not handled here.  Since DECL_INITIAL needs\n-     special handling in LTO, it must be handled by streamer hooks.  */\n-\n-  lto_output_tree_or_ref (ob, DECL_ATTRIBUTES (expr), ref_p);\n-\n-  /* Do not stream DECL_ABSTRACT_ORIGIN.  We cannot handle debug information\n-     for early inlining so drop it on the floor instead of ICEing in\n-     dwarf2out.c.  */\n-\n-  if (TREE_CODE (expr) == PARM_DECL)\n-    lto_output_chain (ob, TREE_CHAIN (expr), ref_p);\n-\n-  if ((TREE_CODE (expr) == VAR_DECL\n-       || TREE_CODE (expr) == PARM_DECL)\n-      && DECL_HAS_VALUE_EXPR_P (expr))\n-    lto_output_tree_or_ref (ob, DECL_VALUE_EXPR (expr), ref_p);\n-\n-  if (TREE_CODE (expr) == VAR_DECL)\n-    lto_output_tree_or_ref (ob, DECL_DEBUG_EXPR (expr), ref_p);\n-}\n-\n-\n-/* Write all pointer fields in the TS_DECL_NON_COMMON structure of\n-   EXPR to output block OB.  If REF_P is true, write a reference to EXPR's\n-   pointer fields.  */\n-\n-static void\n-lto_output_ts_decl_non_common_tree_pointers (struct output_block *ob,\n-\t\t\t\t\t     tree expr, bool ref_p)\n-{\n-  if (TREE_CODE (expr) == FUNCTION_DECL)\n-    {\n-      lto_output_tree_or_ref (ob, DECL_ARGUMENTS (expr), ref_p);\n-      lto_output_tree_or_ref (ob, DECL_RESULT (expr), ref_p);\n-    }\n-  lto_output_tree_or_ref (ob, DECL_VINDEX (expr), ref_p);\n-}\n-\n-\n-/* Write all pointer fields in the TS_DECL_WITH_VIS structure of EXPR\n-   to output block OB.  If REF_P is true, write a reference to EXPR's\n-   pointer fields.  */\n-\n-static void\n-lto_output_ts_decl_with_vis_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t\t   bool ref_p)\n-{\n-  /* Make sure we don't inadvertently set the assembler name.  */\n-  if (DECL_ASSEMBLER_NAME_SET_P (expr))\n-    lto_output_tree_or_ref (ob, DECL_ASSEMBLER_NAME (expr), ref_p);\n-  else\n-    output_record_start (ob, LTO_null);\n-\n-  lto_output_tree_or_ref (ob, DECL_SECTION_NAME (expr), ref_p);\n-  lto_output_tree_or_ref (ob, DECL_COMDAT_GROUP (expr), ref_p);\n-}\n-\n-\n-/* Write all pointer fields in the TS_FIELD_DECL structure of EXPR to\n-   output block OB.  If REF_P is true, write a reference to EXPR's\n-   pointer fields.  */\n-\n-static void\n-lto_output_ts_field_decl_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t\tbool ref_p)\n-{\n-  lto_output_tree_or_ref (ob, DECL_FIELD_OFFSET (expr), ref_p);\n-  lto_output_tree_or_ref (ob, DECL_BIT_FIELD_TYPE (expr), ref_p);\n-  lto_output_tree_or_ref (ob, DECL_QUALIFIER (expr), ref_p);\n-  lto_output_tree_or_ref (ob, DECL_FIELD_BIT_OFFSET (expr), ref_p);\n-  lto_output_tree_or_ref (ob, DECL_FCONTEXT (expr), ref_p);\n-  lto_output_chain (ob, TREE_CHAIN (expr), ref_p);\n-}\n-\n-\n-/* Write all pointer fields in the TS_FUNCTION_DECL structure of EXPR\n-   to output block OB.  If REF_P is true, write a reference to EXPR's\n-   pointer fields.  */\n-\n-static void\n-lto_output_ts_function_decl_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t\t   bool ref_p)\n-{\n-  /* DECL_STRUCT_FUNCTION is handled by lto_output_function.  FIXME lto,\n-     maybe it should be handled here?  */\n-  lto_output_tree_or_ref (ob, DECL_FUNCTION_PERSONALITY (expr), ref_p);\n-  lto_output_tree_or_ref (ob, DECL_FUNCTION_SPECIFIC_TARGET (expr), ref_p);\n-  lto_output_tree_or_ref (ob, DECL_FUNCTION_SPECIFIC_OPTIMIZATION (expr),\n-\t\t\t  ref_p);\n-}\n-\n-\n-/* Write all pointer fields in the TS_TYPE_COMMON structure of EXPR to\n-   output block OB.  If REF_P is true, write a reference to EXPR's\n-   pointer fields.  */\n-\n-static void\n-lto_output_ts_type_common_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t\t bool ref_p)\n-{\n-  lto_output_tree_or_ref (ob, TYPE_SIZE (expr), ref_p);\n-  lto_output_tree_or_ref (ob, TYPE_SIZE_UNIT (expr), ref_p);\n-  lto_output_tree_or_ref (ob, TYPE_ATTRIBUTES (expr), ref_p);\n-  lto_output_tree_or_ref (ob, TYPE_NAME (expr), ref_p);\n-  /* Do not stream TYPE_POINTER_TO or TYPE_REFERENCE_TO.  They will be\n-     reconstructed during fixup.  */\n-  /* Do not stream TYPE_NEXT_VARIANT, we reconstruct the variant lists\n-     during fixup.  */\n-  lto_output_tree_or_ref (ob, TYPE_MAIN_VARIANT (expr), ref_p);\n-  lto_output_tree_or_ref (ob, TYPE_CONTEXT (expr), ref_p);\n-  /* TYPE_CANONICAL is re-computed during type merging, so no need\n-     to stream it here.  */\n-  lto_output_tree_or_ref (ob, TYPE_STUB_DECL (expr), ref_p);\n-}\n-\n-/* Write all pointer fields in the TS_TYPE_NON_COMMON structure of EXPR\n-   to output block OB.  If REF_P is true, write a reference to EXPR's\n-   pointer fields.  */\n-\n-static void\n-lto_output_ts_type_non_common_tree_pointers (struct output_block *ob,\n-\t\t\t\t\t     tree expr, bool ref_p)\n-{\n-  if (TREE_CODE (expr) == ENUMERAL_TYPE)\n-    lto_output_tree_or_ref (ob, TYPE_VALUES (expr), ref_p);\n-  else if (TREE_CODE (expr) == ARRAY_TYPE)\n-    lto_output_tree_or_ref (ob, TYPE_DOMAIN (expr), ref_p);\n-  else if (RECORD_OR_UNION_TYPE_P (expr))\n-    lto_output_tree_or_ref (ob, TYPE_FIELDS (expr), ref_p);\n-  else if (TREE_CODE (expr) == FUNCTION_TYPE\n-\t   || TREE_CODE (expr) == METHOD_TYPE)\n-    lto_output_tree_or_ref (ob, TYPE_ARG_TYPES (expr), ref_p);\n-\n-  if (!POINTER_TYPE_P (expr))\n-    lto_output_tree_or_ref (ob, TYPE_MINVAL (expr), ref_p);\n-  lto_output_tree_or_ref (ob, TYPE_MAXVAL (expr), ref_p);\n-  if (RECORD_OR_UNION_TYPE_P (expr))\n-    lto_output_tree_or_ref (ob, TYPE_BINFO (expr), ref_p);\n-}\n-\n-\n-/* Write all pointer fields in the TS_LIST structure of EXPR to output\n-   block OB.  If REF_P is true, write a reference to EXPR's pointer\n-   fields.  */\n-\n-static void\n-lto_output_ts_list_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t  bool ref_p)\n-{\n-  lto_output_tree_or_ref (ob, TREE_PURPOSE (expr), ref_p);\n-  lto_output_tree_or_ref (ob, TREE_VALUE (expr), ref_p);\n-  lto_output_chain (ob, TREE_CHAIN (expr), ref_p);\n-}\n-\n-\n-/* Write all pointer fields in the TS_VEC structure of EXPR to output\n-   block OB.  If REF_P is true, write a reference to EXPR's pointer\n-   fields.  */\n-\n-static void\n-lto_output_ts_vec_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n-{\n-  int i;\n-\n-  /* Note that the number of slots for EXPR has already been emitted\n-     in EXPR's header (see lto_output_tree_header).  */\n-  for (i = 0; i < TREE_VEC_LENGTH (expr); i++)\n-    lto_output_tree_or_ref (ob, TREE_VEC_ELT (expr, i), ref_p);\n-}\n-\n-\n-/* Write all pointer fields in the TS_EXP structure of EXPR to output\n-   block OB.  If REF_P is true, write a reference to EXPR's pointer\n-   fields.  */\n-\n-static void\n-lto_output_ts_exp_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n-{\n-  int i;\n-\n-  output_sleb128 (ob, TREE_OPERAND_LENGTH (expr));\n-  for (i = 0; i < TREE_OPERAND_LENGTH (expr); i++)\n-    lto_output_tree_or_ref (ob, TREE_OPERAND (expr, i), ref_p);\n-  lto_output_location (ob, EXPR_LOCATION (expr));\n-  lto_output_tree_or_ref (ob, TREE_BLOCK (expr), ref_p);\n-}\n-\n-\n-/* Write all pointer fields in the TS_BLOCK structure of EXPR to output\n-   block OB.  If REF_P is true, write a reference to EXPR's pointer\n-   fields.  */\n-\n-static void\n-lto_output_ts_block_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t   bool ref_p)\n-{\n-  /* Do not stream BLOCK_SOURCE_LOCATION.  We cannot handle debug information\n-     for early inlining so drop it on the floor instead of ICEing in\n-     dwarf2out.c.  */\n-  lto_output_chain (ob, BLOCK_VARS (expr), ref_p);\n-\n-  /* Do not stream BLOCK_NONLOCALIZED_VARS.  We cannot handle debug information\n-     for early inlining so drop it on the floor instead of ICEing in\n-     dwarf2out.c.  */\n-\n-  lto_output_tree_or_ref (ob, BLOCK_SUPERCONTEXT (expr), ref_p);\n-  /* Do not stream BLOCK_ABSTRACT_ORIGIN.  We cannot handle debug information\n-     for early inlining so drop it on the floor instead of ICEing in\n-     dwarf2out.c.  */\n-  lto_output_tree_or_ref (ob, BLOCK_FRAGMENT_ORIGIN (expr), ref_p);\n-  lto_output_tree_or_ref (ob, BLOCK_FRAGMENT_CHAIN (expr), ref_p);\n-  /* Do not output BLOCK_SUBBLOCKS.  Instead on streaming-in this\n-     list is re-constructed from BLOCK_SUPERCONTEXT.  */\n-}\n-\n-\n-/* Write all pointer fields in the TS_BINFO structure of EXPR to output\n-   block OB.  If REF_P is true, write a reference to EXPR's pointer\n-   fields.  */\n-\n-static void\n-lto_output_ts_binfo_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t   bool ref_p)\n-{\n-  unsigned i;\n-  tree t;\n-\n-  /* Note that the number of BINFO slots has already been emitted in\n-     EXPR's header (see lto_output_tree_header) because this length\n-     is needed to build the empty BINFO node on the reader side.  */\n-  FOR_EACH_VEC_ELT (tree, BINFO_BASE_BINFOS (expr), i, t)\n-    lto_output_tree_or_ref (ob, t, ref_p);\n-  output_record_start (ob, LTO_null);\n-\n-  lto_output_tree_or_ref (ob, BINFO_OFFSET (expr), ref_p);\n-  lto_output_tree_or_ref (ob, BINFO_VTABLE (expr), ref_p);\n-  /* BINFO_VIRTUALS is used to drive type based devirtualizatoin.  It often links\n-     together large portions of programs making it harder to partition.  Becuase\n-     devirtualization is interesting before inlining, only, there is no real\n-     need to ship it into ltrans partition.  */\n-  lto_output_tree_or_ref (ob, flag_wpa ? NULL : BINFO_VIRTUALS (expr), ref_p);\n-  lto_output_tree_or_ref (ob, BINFO_VPTR_FIELD (expr), ref_p);\n-\n-  output_uleb128 (ob, VEC_length (tree, BINFO_BASE_ACCESSES (expr)));\n-  FOR_EACH_VEC_ELT (tree, BINFO_BASE_ACCESSES (expr), i, t)\n-    lto_output_tree_or_ref (ob, t, ref_p);\n-\n-  lto_output_tree_or_ref (ob, BINFO_INHERITANCE_CHAIN (expr), ref_p);\n-  lto_output_tree_or_ref (ob, BINFO_SUBVTT_INDEX (expr), ref_p);\n-  lto_output_tree_or_ref (ob, BINFO_VPTR_INDEX (expr), ref_p);\n-}\n-\n-\n-/* Write all pointer fields in the TS_CONSTRUCTOR structure of EXPR to\n-   output block OB.  If REF_P is true, write a reference to EXPR's\n-   pointer fields.  */\n-\n-static void\n-lto_output_ts_constructor_tree_pointers (struct output_block *ob, tree expr,\n-\t\t\t\t\t bool ref_p)\n-{\n-  unsigned i;\n-  tree index, value;\n-\n-  output_uleb128 (ob, CONSTRUCTOR_NELTS (expr));\n-  FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (expr), i, index, value)\n-    {\n-      lto_output_tree_or_ref (ob, index, ref_p);\n-      lto_output_tree_or_ref (ob, value, ref_p);\n-    }\n-}\n-\n-/* Write a TS_TARGET_OPTION tree in EXPR to OB.  */\n-\n-static void\n-lto_output_ts_target_option (struct output_block *ob, tree expr)\n-{\n-  struct cl_target_option *t = TREE_TARGET_OPTION (expr);\n-  struct bitpack_d bp;\n-  unsigned i, len;\n-\n-  /* The cl_target_option is target specific and generated by the options\n-     awk script, so we just recreate a byte-by-byte copy here. */\n-\n-  bp = bitpack_create (ob->main_stream);\n-  len = sizeof (struct cl_target_option);\n-  for (i = 0; i < len; i++)\n-    bp_pack_value (&bp, ((unsigned char *)t)[i], 8);\n-  /* Catch struct size mismatches between reader and writer. */\n-  bp_pack_value (&bp, 0x12345678, 32);\n-  lto_output_bitpack (&bp);\n-}\n-\n-/* Write a TS_TRANSLATION_UNIT_DECL tree in EXPR to OB.  */\n-\n-static void\n-lto_output_ts_translation_unit_decl_tree_pointers (struct output_block *ob,\n-\t\t\t\t\t\t   tree expr)\n-{\n-  lto_output_string (ob, ob->main_stream,\n-\t\t     TRANSLATION_UNIT_LANGUAGE (expr), true);\n-}\n-\n-/* Helper for lto_output_tree.  Write all pointer fields in EXPR to output\n-   block OB.  If REF_P is true, the leaves of EXPR are emitted as\n-   references.  */\n-\n-static void\n-lto_output_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n-{\n-  enum tree_code code;\n-\n-  code = TREE_CODE (expr);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_TYPED))\n-    lto_output_ts_common_tree_pointers (ob, expr, ref_p);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_VECTOR))\n-    lto_output_ts_vector_tree_pointers (ob, expr, ref_p);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_COMPLEX))\n-    lto_output_ts_complex_tree_pointers (ob, expr, ref_p);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_DECL_MINIMAL))\n-    lto_output_ts_decl_minimal_tree_pointers (ob, expr, ref_p);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n-    lto_output_ts_decl_common_tree_pointers (ob, expr, ref_p);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_DECL_NON_COMMON))\n-    lto_output_ts_decl_non_common_tree_pointers (ob, expr, ref_p);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n-    lto_output_ts_decl_with_vis_tree_pointers (ob, expr, ref_p);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_FIELD_DECL))\n-    lto_output_ts_field_decl_tree_pointers (ob, expr, ref_p);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_FUNCTION_DECL))\n-    lto_output_ts_function_decl_tree_pointers (ob, expr, ref_p);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_COMMON))\n-    lto_output_ts_type_common_tree_pointers (ob, expr, ref_p);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_NON_COMMON))\n-    lto_output_ts_type_non_common_tree_pointers (ob, expr, ref_p);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_LIST))\n-    lto_output_ts_list_tree_pointers (ob, expr, ref_p);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_VEC))\n-    lto_output_ts_vec_tree_pointers (ob, expr, ref_p);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_EXP))\n-    lto_output_ts_exp_tree_pointers (ob, expr, ref_p);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_BLOCK))\n-    lto_output_ts_block_tree_pointers (ob, expr, ref_p);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_BINFO))\n-    lto_output_ts_binfo_tree_pointers (ob, expr, ref_p);\n+    ob->cfg_stream = XCNEW (struct lto_output_stream);\n \n-  if (CODE_CONTAINS_STRUCT (code, TS_CONSTRUCTOR))\n-    lto_output_ts_constructor_tree_pointers (ob, expr, ref_p);\n+  clear_line_info (ob);\n \n-  if (CODE_CONTAINS_STRUCT (code, TS_TARGET_OPTION))\n-    lto_output_ts_target_option (ob, expr);\n+  ob->string_hash_table = htab_create (37, hash_string_slot_node,\n+\t\t\t\t       eq_string_slot_node, NULL);\n+  gcc_obstack_init (&ob->obstack);\n \n-  if (CODE_CONTAINS_STRUCT (code, TS_TRANSLATION_UNIT_DECL))\n-    lto_output_ts_translation_unit_decl_tree_pointers (ob, expr);\n+  return ob;\n }\n \n \n-/* Emit header information for tree EXPR to output block OB.  The header\n-   contains everything needed to instantiate an empty skeleton for\n-   EXPR on the reading side.  IX is the index into the streamer cache\n-   where EXPR is stored.  REF_P is as in lto_output_tree.  */\n+/* Destroy the output block OB.  */\n \n-static void\n-lto_output_tree_header (struct output_block *ob, tree expr)\n+void\n+destroy_output_block (struct output_block *ob)\n {\n-  enum LTO_tags tag;\n-  enum tree_code code;\n+  enum lto_section_type section_type = ob->section_type;\n \n-  /* We should not see any tree nodes not handled by the streamer.  */\n-  code = TREE_CODE (expr);\n-  if (!streamer_hooks.is_streamable (expr))\n-    internal_error (\"tree code %qs is not supported in %s streams\",\n-\t\t    tree_code_name[code], streamer_hooks.name);\n-\n-  /* The header of a tree node consists of its tag, the size of\n-     the node, and any other information needed to instantiate\n-     EXPR on the reading side (such as the number of slots in\n-     variable sized nodes).  */\n-  tag = lto_tree_code_to_tag (code);\n-  output_record_start (ob, tag);\n+  htab_delete (ob->string_hash_table);\n \n-  /* The following will cause bootstrap miscomparisons.  Enable with care.  */\n-#ifdef LTO_STREAMER_DEBUG\n-  /* This is used mainly for debugging purposes.  When the reader\n-     and the writer do not agree on a streamed node, the pointer\n-     value for EXPR can be used to track down the differences in\n-     the debugger.  */\n-  gcc_assert ((HOST_WIDEST_INT) (intptr_t) expr == (intptr_t) expr);\n-  output_sleb128 (ob, (HOST_WIDEST_INT) (intptr_t) expr);\n-#endif\n+  free (ob->main_stream);\n+  free (ob->string_stream);\n+  if (section_type == LTO_section_function_body)\n+    free (ob->cfg_stream);\n+\n+  lto_streamer_cache_delete (ob->writer_cache);\n+  obstack_free (&ob->obstack, NULL);\n \n-  /* The text in strings and identifiers are completely emitted in\n-     the header.  */\n-  if (CODE_CONTAINS_STRUCT (code, TS_STRING))\n-    output_string_cst (ob, ob->main_stream, expr);\n-  else if (CODE_CONTAINS_STRUCT (code, TS_IDENTIFIER))\n-    output_identifier (ob, ob->main_stream, expr);\n-  else if (CODE_CONTAINS_STRUCT (code, TS_VEC))\n-    output_sleb128 (ob, TREE_VEC_LENGTH (expr));\n-  else if (CODE_CONTAINS_STRUCT (code, TS_BINFO))\n-    output_uleb128 (ob, BINFO_N_BASE_BINFOS (expr));\n-\n-  /* Allow the streamer to write any streamer-specific information\n-     needed to instantiate the node when reading.  */\n-  if (streamer_hooks.output_tree_header)\n-    streamer_hooks.output_tree_header (ob, expr);\n+  free (ob);\n }\n \n \n-/* Write the code and class of builtin EXPR to output block OB.  IX is\n-   the index into the streamer cache where EXPR is stored.*/\n+/* Look up NODE in the type table and write the index for it to OB.  */\n \n static void\n-lto_output_builtin_tree (struct output_block *ob, tree expr)\n+output_type_ref (struct output_block *ob, tree node)\n {\n-  gcc_assert (lto_stream_as_builtin_p (expr));\n+  output_record_start (ob, LTO_type_ref);\n+  lto_output_type_ref_index (ob->decl_state, ob->main_stream, node);\n+}\n \n-  if (DECL_BUILT_IN_CLASS (expr) == BUILT_IN_MD\n-      && !targetm.builtin_decl)\n-    sorry (\"gimple bytecode streams do not support machine specific builtin \"\n-\t   \"functions on this target\");\n \n-  output_record_start (ob, LTO_builtin_decl);\n-  lto_output_enum (ob->main_stream, built_in_class, BUILT_IN_LAST,\n-\t\t   DECL_BUILT_IN_CLASS (expr));\n-  output_uleb128 (ob, DECL_FUNCTION_CODE (expr));\n+/* Return true if tree node T is written to various tables.  For these\n+   nodes, we sometimes want to write their phyiscal representation\n+   (via lto_output_tree), and sometimes we need to emit an index\n+   reference into a table (via lto_output_tree_ref).  */\n \n-  if (DECL_ASSEMBLER_NAME_SET_P (expr))\n-    {\n-      /* When the assembler name of a builtin gets a user name,\n-\t the new name is always prefixed with '*' by\n-\t set_builtin_user_assembler_name.  So, to prevent the\n-\t reader side from adding a second '*', we omit it here.  */\n-      const char *str = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (expr));\n-      if (strlen (str) > 1 && str[0] == '*')\n-\tlto_output_string (ob, ob->main_stream, &str[1], true);\n-      else\n-\tlto_output_string (ob, ob->main_stream, NULL, true);\n-    }\n+static bool\n+tree_is_indexable (tree t)\n+{\n+  if (TREE_CODE (t) == PARM_DECL)\n+    return false;\n+  else if (TREE_CODE (t) == VAR_DECL && decl_function_context (t)\n+\t   && !TREE_STATIC (t))\n+    return false;\n   else\n-    lto_output_string (ob, ob->main_stream, NULL, true);\n+    return (TYPE_P (t) || DECL_P (t) || TREE_CODE (t) == SSA_NAME);\n }\n \n \n-/* Write a physical representation of tree node EXPR to output block\n-   OB.  If REF_P is true, the leaves of EXPR are emitted as references\n-   via lto_output_tree_ref.  IX is the index into the streamer cache\n-   where EXPR is stored.  */\n+/* Output info about new location into bitpack BP.\n+   After outputting bitpack, lto_output_location_data has\n+   to be done to output actual data.  */\n \n-static void\n-lto_write_tree (struct output_block *ob, tree expr, bool ref_p)\n+static inline void\n+lto_output_location_bitpack (struct bitpack_d *bp,\n+\t\t\t     struct output_block *ob,\n+\t\t\t     location_t loc)\n {\n-  struct bitpack_d bp;\n+  expanded_location xloc;\n \n-  /* Write the header, containing everything needed to materialize\n-     EXPR on the reading side.  */\n-  lto_output_tree_header (ob, expr);\n+  bp_pack_value (bp, loc == UNKNOWN_LOCATION, 1);\n+  if (loc == UNKNOWN_LOCATION)\n+    return;\n \n-  /* Pack all the non-pointer fields in EXPR into a bitpack and write\n-     the resulting bitpack.  */\n-  bp = bitpack_create (ob->main_stream);\n-  pack_value_fields (&bp, expr);\n-  lto_output_bitpack (&bp);\n+  xloc = expand_location (loc);\n \n-  /* Write all the pointer fields in EXPR.  */\n-  lto_output_tree_pointers (ob, expr, ref_p);\n+  bp_pack_value (bp, ob->current_file != xloc.file, 1);\n+  if (ob->current_file != xloc.file)\n+    bp_pack_var_len_unsigned (bp, lto_string_index (ob,\n+\t\t\t\t\t            xloc.file,\n+\t\t\t\t\t\t    strlen (xloc.file) + 1,\n+\t\t\t\t\t\t    true));\n+  ob->current_file = xloc.file;\n \n-  /* Call back into the streaming module to see if it needs to write\n-     anything that was not written by the common streamer.  */\n-  if (streamer_hooks.write_tree)\n-    streamer_hooks.write_tree (ob, expr, ref_p);\n+  bp_pack_value (bp, ob->current_line != xloc.line, 1);\n+  if (ob->current_line != xloc.line)\n+    bp_pack_var_len_unsigned (bp, xloc.line);\n+  ob->current_line = xloc.line;\n \n-  /* Mark the end of EXPR.  */\n-  output_zero (ob);\n+  bp_pack_value (bp, ob->current_col != xloc.column, 1);\n+  if (ob->current_col != xloc.column)\n+    bp_pack_var_len_unsigned (bp, xloc.column);\n+  ob->current_col = xloc.column;\n }\n \n \n-/* GIMPLE hook for writing GIMPLE-specific parts of trees.  OB, EXPR\n-   and REF_P are as in lto_write_tree.  */\n+/* Emit location LOC to output block OB.\n+   When bitpack is handy, it is more space effecient to call\n+   lto_output_location_bitpack with existing bitpack.  */\n \n void\n-lto_streamer_write_tree (struct output_block *ob, tree expr, bool ref_p)\n-{\n-  if (DECL_P (expr)\n-      && TREE_CODE (expr) != FUNCTION_DECL\n-      && TREE_CODE (expr) != TRANSLATION_UNIT_DECL)\n-    {\n-      /* Handle DECL_INITIAL for symbols.  */\n-      tree initial = DECL_INITIAL (expr);\n-      if (TREE_CODE (expr) == VAR_DECL\n-\t  && (TREE_STATIC (expr) || DECL_EXTERNAL (expr))\n-\t  && initial)\n-\t{\n-\t  lto_varpool_encoder_t varpool_encoder;\n-\t  struct varpool_node *vnode;\n-\n-\t  varpool_encoder = ob->decl_state->varpool_node_encoder;\n-\t  vnode = varpool_get_node (expr);\n-\t  if (!vnode)\n-\t    initial = error_mark_node;\n-\t  else if (!lto_varpool_encoder_encode_initializer_p (varpool_encoder,\n-\t\t\t\t\t\t\t      vnode))\n-\t    initial = NULL;\n-\t}\n-\n-      lto_output_tree_or_ref (ob, initial, ref_p);\n-    }\n-}\n-\n-\n-/* Emit the integer constant CST to output block OB.  If REF_P is true,\n-   CST's type will be emitted as a reference.  */\n-\n-static void\n-lto_output_integer_cst (struct output_block *ob, tree cst, bool ref_p)\n+lto_output_location (struct output_block *ob, location_t loc)\n {\n-  output_record_start (ob, lto_tree_code_to_tag (INTEGER_CST));\n-  lto_output_tree_or_ref (ob, TREE_TYPE (cst), ref_p);\n-  lto_output_1_stream (ob->main_stream, TREE_OVERFLOW_P (cst));\n-  output_uleb128 (ob, TREE_INT_CST_LOW (cst));\n-  output_uleb128 (ob, TREE_INT_CST_HIGH (cst));\n+  struct bitpack_d bp = bitpack_create (ob->main_stream);\n+  lto_output_location_bitpack (&bp, ob, loc);\n+  lto_output_bitpack (&bp);\n }\n \n \n-/* Emit the physical representation of tree node EXPR to output block\n-   OB.  If REF_P is true, the leaves of EXPR are emitted as references\n-   via lto_output_tree_ref.  */\n+/* If EXPR is an indexable tree node, output a reference to it to\n+   output block OB.  Otherwise, output the physical representation of\n+   EXPR to OB.  */\n \n void\n-lto_output_tree (struct output_block *ob, tree expr, bool ref_p)\n+lto_output_tree_ref (struct output_block *ob, tree expr)\n {\n-  unsigned ix;\n-  bool existed_p;\n+  enum tree_code code;\n \n   if (expr == NULL_TREE)\n     {\n       output_record_start (ob, LTO_null);\n       return;\n     }\n \n-  /* INTEGER_CST nodes are special because they need their original type\n-     to be materialized by the reader (to implement TYPE_CACHED_VALUES).  */\n-  if (TREE_CODE (expr) == INTEGER_CST)\n+  if (!tree_is_indexable (expr))\n     {\n-      lto_output_integer_cst (ob, expr, ref_p);\n+      /* Even though we are emitting the physical representation of\n+\t EXPR, its leaves must be emitted as references.  */\n+      lto_output_tree (ob, expr, true);\n       return;\n     }\n \n-  existed_p = lto_streamer_cache_insert (ob->writer_cache, expr, &ix);\n-  if (existed_p)\n-    {\n-      /* If a node has already been streamed out, make sure that\n-\t we don't write it more than once.  Otherwise, the reader\n-\t will instantiate two different nodes for the same object.  */\n-      output_record_start (ob, LTO_tree_pickle_reference);\n-      output_uleb128 (ob, ix);\n-      lto_output_enum (ob->main_stream, LTO_tags, LTO_NUM_TAGS,\n-\t\t       lto_tree_code_to_tag (TREE_CODE (expr)));\n-    }\n-  else if (lto_stream_as_builtin_p (expr))\n+  if (TYPE_P (expr))\n     {\n-      /* MD and NORMAL builtins do not need to be written out\n-\t completely as they are always instantiated by the\n-\t compiler on startup.  The only builtins that need to\n-\t be written out are BUILT_IN_FRONTEND.  For all other\n-\t builtins, we simply write the class and code.  */\n-      lto_output_builtin_tree (ob, expr);\n+      output_type_ref (ob, expr);\n+      return;\n     }\n-  else\n+\n+  code = TREE_CODE (expr);\n+  switch (code)\n     {\n-      /* This is the first time we see EXPR, write its fields\n-\t to OB.  */\n-      lto_write_tree (ob, expr, ref_p);\n+    case SSA_NAME:\n+      output_record_start (ob, LTO_ssa_name_ref);\n+      output_uleb128 (ob, SSA_NAME_VERSION (expr));\n+      break;\n+\n+    case FIELD_DECL:\n+      output_record_start (ob, LTO_field_decl_ref);\n+      lto_output_field_decl_index (ob->decl_state, ob->main_stream, expr);\n+      break;\n+\n+    case FUNCTION_DECL:\n+      output_record_start (ob, LTO_function_decl_ref);\n+      lto_output_fn_decl_index (ob->decl_state, ob->main_stream, expr);\n+      break;\n+\n+    case VAR_DECL:\n+    case DEBUG_EXPR_DECL:\n+      gcc_assert (decl_function_context (expr) == NULL\n+\t\t  || TREE_STATIC (expr));\n+      output_record_start (ob, LTO_global_decl_ref);\n+      lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n+      break;\n+\n+    case CONST_DECL:\n+      output_record_start (ob, LTO_const_decl_ref);\n+      lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n+      break;\n+\n+    case IMPORTED_DECL:\n+      gcc_assert (decl_function_context (expr) == NULL);\n+      output_record_start (ob, LTO_imported_decl_ref);\n+      lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n+      break;\n+\n+    case TYPE_DECL:\n+      output_record_start (ob, LTO_type_decl_ref);\n+      lto_output_type_decl_index (ob->decl_state, ob->main_stream, expr);\n+      break;\n+\n+    case NAMESPACE_DECL:\n+      output_record_start (ob, LTO_namespace_decl_ref);\n+      lto_output_namespace_decl_index (ob->decl_state, ob->main_stream, expr);\n+      break;\n+\n+    case LABEL_DECL:\n+      output_record_start (ob, LTO_label_decl_ref);\n+      lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n+      break;\n+\n+    case RESULT_DECL:\n+      output_record_start (ob, LTO_result_decl_ref);\n+      lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n+      break;\n+\n+    case TRANSLATION_UNIT_DECL:\n+      output_record_start (ob, LTO_translation_unit_decl_ref);\n+      lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n+      break;\n+\n+    default:\n+      {\n+\t/* See if the streamer allows this node to be indexable\n+\t   like other global declarations.  */\n+\tif (streamer_hooks.indexable_with_decls_p\n+\t    && streamer_hooks.indexable_with_decls_p (expr))\n+\t  {\n+\t    output_record_start (ob, LTO_global_decl_ref);\n+\t    lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n+\t  }\n+\telse\n+\t  {\n+\t    /* No other node is indexable, so it should have been\n+\t      handled by lto_output_tree.  */\n+\t    gcc_unreachable ();\n+\t  }\n+      }\n     }\n }\n \n@@ -1722,190 +541,6 @@ output_cfg (struct output_block *ob, struct function *fn)\n }\n \n \n-/* Output PHI function PHI to the main stream in OB.  */\n-\n-static void\n-output_phi (struct output_block *ob, gimple phi)\n-{\n-  unsigned i, len = gimple_phi_num_args (phi);\n-\n-  output_record_start (ob, lto_gimple_code_to_tag (GIMPLE_PHI));\n-  output_uleb128 (ob, SSA_NAME_VERSION (PHI_RESULT (phi)));\n-\n-  for (i = 0; i < len; i++)\n-    {\n-      lto_output_tree_ref (ob, gimple_phi_arg_def (phi, i));\n-      output_uleb128 (ob, gimple_phi_arg_edge (phi, i)->src->index);\n-      lto_output_location (ob, gimple_phi_arg_location (phi, i));\n-    }\n-}\n-\n-\n-/* Emit statement STMT on the main stream of output block OB.  */\n-\n-static void\n-output_gimple_stmt (struct output_block *ob, gimple stmt)\n-{\n-  unsigned i;\n-  enum gimple_code code;\n-  enum LTO_tags tag;\n-  struct bitpack_d bp;\n-\n-  /* Emit identifying tag.  */\n-  code = gimple_code (stmt);\n-  tag = lto_gimple_code_to_tag (code);\n-  output_record_start (ob, tag);\n-\n-  /* Emit the tuple header.  */\n-  bp = bitpack_create (ob->main_stream);\n-  bp_pack_var_len_unsigned (&bp, gimple_num_ops (stmt));\n-  bp_pack_value (&bp, gimple_no_warning_p (stmt), 1);\n-  if (is_gimple_assign (stmt))\n-    bp_pack_value (&bp, gimple_assign_nontemporal_move_p (stmt), 1);\n-  bp_pack_value (&bp, gimple_has_volatile_ops (stmt), 1);\n-  bp_pack_var_len_unsigned (&bp, stmt->gsbase.subcode);\n-  lto_output_bitpack (&bp);\n-\n-  /* Emit location information for the statement.  */\n-  lto_output_location (ob, gimple_location (stmt));\n-\n-  /* Emit the lexical block holding STMT.  */\n-  lto_output_tree (ob, gimple_block (stmt), true);\n-\n-  /* Emit the operands.  */\n-  switch (gimple_code (stmt))\n-    {\n-    case GIMPLE_RESX:\n-      output_sleb128 (ob, gimple_resx_region (stmt));\n-      break;\n-\n-    case GIMPLE_EH_MUST_NOT_THROW:\n-      lto_output_tree_ref (ob, gimple_eh_must_not_throw_fndecl (stmt));\n-      break;\n-\n-    case GIMPLE_EH_DISPATCH:\n-      output_sleb128 (ob, gimple_eh_dispatch_region (stmt));\n-      break;\n-\n-    case GIMPLE_ASM:\n-      lto_output_uleb128_stream (ob->main_stream, gimple_asm_ninputs (stmt));\n-      lto_output_uleb128_stream (ob->main_stream, gimple_asm_noutputs (stmt));\n-      lto_output_uleb128_stream (ob->main_stream, gimple_asm_nclobbers (stmt));\n-      lto_output_uleb128_stream (ob->main_stream, gimple_asm_nlabels (stmt));\n-      lto_output_string (ob, ob->main_stream, gimple_asm_string (stmt), true);\n-      /* Fallthru  */\n-\n-    case GIMPLE_ASSIGN:\n-    case GIMPLE_CALL:\n-    case GIMPLE_RETURN:\n-    case GIMPLE_SWITCH:\n-    case GIMPLE_LABEL:\n-    case GIMPLE_COND:\n-    case GIMPLE_GOTO:\n-    case GIMPLE_DEBUG:\n-      for (i = 0; i < gimple_num_ops (stmt); i++)\n-\t{\n-\t  tree op = gimple_op (stmt, i);\n-\t  /* Wrap all uses of non-automatic variables inside MEM_REFs\n-\t     so that we do not have to deal with type mismatches on\n-\t     merged symbols during IL read in.  The first operand\n-\t     of GIMPLE_DEBUG must be a decl, not MEM_REF, though.  */\n-\t  if (op && (i || !is_gimple_debug (stmt)))\n-\t    {\n-\t      tree *basep = &op;\n-\t      while (handled_component_p (*basep))\n-\t\tbasep = &TREE_OPERAND (*basep, 0);\n-\t      if (TREE_CODE (*basep) == VAR_DECL\n-\t\t  && !auto_var_in_fn_p (*basep, current_function_decl)\n-\t\t  && !DECL_REGISTER (*basep))\n-\t\t{\n-\t\t  bool volatilep = TREE_THIS_VOLATILE (*basep);\n-\t\t  *basep = build2 (MEM_REF, TREE_TYPE (*basep),\n-\t\t\t\t   build_fold_addr_expr (*basep),\n-\t\t\t\t   build_int_cst (build_pointer_type\n-\t\t\t\t\t\t  (TREE_TYPE (*basep)), 0));\n-\t\t  TREE_THIS_VOLATILE (*basep) = volatilep;\n-\t\t}\n-\t    }\n-\t  lto_output_tree_ref (ob, op);\n-\t}\n-      if (is_gimple_call (stmt))\n-\t{\n-\t  if (gimple_call_internal_p (stmt))\n-\t    lto_output_enum (ob->main_stream, internal_fn,\n-\t\t\t     IFN_LAST, gimple_call_internal_fn (stmt));\n-\t  else\n-\t    lto_output_tree_ref (ob, gimple_call_fntype (stmt));\n-\t}\n-      break;\n-\n-    case GIMPLE_NOP:\n-    case GIMPLE_PREDICT:\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-\n-/* Output a basic block BB to the main stream in OB for this FN.  */\n-\n-static void\n-output_bb (struct output_block *ob, basic_block bb, struct function *fn)\n-{\n-  gimple_stmt_iterator bsi = gsi_start_bb (bb);\n-\n-  output_record_start (ob,\n-\t\t       (!gsi_end_p (bsi)) || phi_nodes (bb)\n-\t\t        ? LTO_bb1\n-\t\t\t: LTO_bb0);\n-\n-  output_uleb128 (ob, bb->index);\n-  output_sleb128 (ob, bb->count);\n-  output_sleb128 (ob, bb->loop_depth);\n-  output_sleb128 (ob, bb->frequency);\n-  output_sleb128 (ob, bb->flags);\n-\n-  if (!gsi_end_p (bsi) || phi_nodes (bb))\n-    {\n-      /* Output the statements.  The list of statements is terminated\n-\t with a zero.  */\n-      for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n-\t{\n-\t  int region;\n-\t  gimple stmt = gsi_stmt (bsi);\n-\n-\t  output_gimple_stmt (ob, stmt);\n-\n-\t  /* Emit the EH region holding STMT.  */\n-\t  region = lookup_stmt_eh_lp_fn (fn, stmt);\n-\t  if (region != 0)\n-\t    {\n-\t      output_record_start (ob, LTO_eh_region);\n-\t      output_sleb128 (ob, region);\n-\t    }\n-\t  else\n-\t    output_record_start (ob, LTO_null);\n-\t}\n-\n-      output_record_start (ob, LTO_null);\n-\n-      for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n-\t{\n-\t  gimple phi = gsi_stmt (bsi);\n-\n-\t  /* Only emit PHIs for gimple registers.  PHI nodes for .MEM\n-\t     will be filled in on reading when the SSA form is\n-\t     updated.  */\n-\t  if (is_gimple_reg (gimple_phi_result (phi)))\n-\t    output_phi (ob, phi);\n-\t}\n-\n-      output_record_start (ob, LTO_null);\n-    }\n-}\n-\n /* Create the header in the file using OB.  If the section type is for\n    a function, set FN to the decl for that function.  */\n "}, {"sha": "328e65400473098a538fbd08f7ac6eadbc006cef", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 2, "deletions": 265, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=f0efc7aa7705facdb16a39a08137cf748c7d5f30", "patch": "@@ -32,14 +32,13 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n #include \"bitmap.h\"\n #include \"vec.h\"\n+#include \"tree-streamer.h\"\n #include \"lto-streamer.h\"\n+#include \"streamer-hooks.h\"\n \n /* Statistics gathered during LTO, WPA and LTRANS.  */\n struct lto_stats_d lto_stats;\n \n-/* Streamer hooks.  */\n-struct streamer_hooks streamer_hooks;\n-\n /* LTO uses bitmaps with different life-times.  So use a seperate\n    obstack for all LTO bitmaps.  */\n static bitmap_obstack lto_obstack;\n@@ -258,226 +257,6 @@ print_lto_report (void)\n }\n \n \n-/* Check that all the TS_* structures handled by the lto_output_* and\n-   lto_input_* routines are exactly ALL the structures defined in\n-   treestruct.def.  */\n-\n-static void\n-check_handled_ts_structures (void)\n-{\n-  bool handled_p[LAST_TS_ENUM];\n-  unsigned i;\n-\n-  memset (&handled_p, 0, sizeof (handled_p));\n-\n-  /* These are the TS_* structures that are either handled or\n-     explicitly ignored by the streamer routines.  */\n-  handled_p[TS_BASE] = true;\n-  handled_p[TS_TYPED] = true;\n-  handled_p[TS_COMMON] = true;\n-  handled_p[TS_INT_CST] = true;\n-  handled_p[TS_REAL_CST] = true;\n-  handled_p[TS_FIXED_CST] = true;\n-  handled_p[TS_VECTOR] = true;\n-  handled_p[TS_STRING] = true;\n-  handled_p[TS_COMPLEX] = true;\n-  handled_p[TS_IDENTIFIER] = true;\n-  handled_p[TS_DECL_MINIMAL] = true;\n-  handled_p[TS_DECL_COMMON] = true;\n-  handled_p[TS_DECL_WRTL] = true;\n-  handled_p[TS_DECL_NON_COMMON] = true;\n-  handled_p[TS_DECL_WITH_VIS] = true;\n-  handled_p[TS_FIELD_DECL] = true;\n-  handled_p[TS_VAR_DECL] = true;\n-  handled_p[TS_PARM_DECL] = true;\n-  handled_p[TS_LABEL_DECL] = true;\n-  handled_p[TS_RESULT_DECL] = true;\n-  handled_p[TS_CONST_DECL] = true;\n-  handled_p[TS_TYPE_DECL] = true;\n-  handled_p[TS_FUNCTION_DECL] = true;\n-  handled_p[TS_TYPE_COMMON] = true;\n-  handled_p[TS_TYPE_WITH_LANG_SPECIFIC] = true;\n-  handled_p[TS_TYPE_NON_COMMON] = true;\n-  handled_p[TS_LIST] = true;\n-  handled_p[TS_VEC] = true;\n-  handled_p[TS_EXP] = true;\n-  handled_p[TS_SSA_NAME] = true;\n-  handled_p[TS_BLOCK] = true;\n-  handled_p[TS_BINFO] = true;\n-  handled_p[TS_STATEMENT_LIST] = true;\n-  handled_p[TS_CONSTRUCTOR] = true;\n-  handled_p[TS_OMP_CLAUSE] = true;\n-  handled_p[TS_OPTIMIZATION] = true;\n-  handled_p[TS_TARGET_OPTION] = true;\n-  handled_p[TS_TRANSLATION_UNIT_DECL] = true;\n-\n-  /* Anything not marked above will trigger the following assertion.\n-     If this assertion triggers, it means that there is a new TS_*\n-     structure that should be handled by the streamer.  */\n-  for (i = 0; i < LAST_TS_ENUM; i++)\n-    gcc_assert (handled_p[i]);\n-}\n-\n-\n-/* Helper for lto_streamer_cache_insert_1.  Add T to CACHE->NODES at\n-   slot IX.  */\n-\n-static void\n-lto_streamer_cache_add_to_node_array (struct lto_streamer_cache_d *cache,\n-\t\t\t\t      unsigned ix, tree t)\n-{\n-  /* Make sure we're either replacing an old element or\n-     appending consecutively.  */\n-  gcc_assert (ix <= VEC_length (tree, cache->nodes));\n-\n-  if (ix == VEC_length (tree, cache->nodes))\n-    VEC_safe_push (tree, heap, cache->nodes, t);\n-  else\n-    VEC_replace (tree, cache->nodes, ix, t);\n-}\n-\n-\n-/* Helper for lto_streamer_cache_insert and lto_streamer_cache_insert_at.\n-   CACHE, T, and IX_P are as in lto_streamer_cache_insert.\n-\n-   If INSERT_AT_NEXT_SLOT_P is true, T is inserted at the next available\n-   slot in the cache.  Otherwise, T is inserted at the position indicated\n-   in *IX_P.\n-\n-   If T already existed in CACHE, return true.  Otherwise,\n-   return false.  */\n-\n-static bool\n-lto_streamer_cache_insert_1 (struct lto_streamer_cache_d *cache,\n-\t\t\t     tree t, unsigned *ix_p,\n-\t\t\t     bool insert_at_next_slot_p)\n-{\n-  void **slot;\n-  unsigned ix;\n-  bool existed_p;\n-\n-  gcc_assert (t);\n-\n-  slot = pointer_map_insert (cache->node_map, t);\n-  if (!*slot)\n-    {\n-      /* Determine the next slot to use in the cache.  */\n-      if (insert_at_next_slot_p)\n-\tix = VEC_length (tree, cache->nodes);\n-      else\n-\tix = *ix_p;\n-       *slot = (void *)(size_t) (ix + 1);\n-\n-      lto_streamer_cache_add_to_node_array (cache, ix, t);\n-\n-      /* Indicate that the item was not present in the cache.  */\n-      existed_p = false;\n-    }\n-  else\n-    {\n-      ix = (size_t) *slot - 1;\n-\n-      if (!insert_at_next_slot_p && ix != *ix_p)\n-\t{\n-\t  /* If the caller wants to insert T at a specific slot\n-\t     location, and ENTRY->TO does not match *IX_P, add T to\n-\t     the requested location slot.  */\n-\t  ix = *ix_p;\n-\t  lto_streamer_cache_add_to_node_array (cache, ix, t);\n-\t}\n-\n-      /* Indicate that T was already in the cache.  */\n-      existed_p = true;\n-    }\n-\n-  if (ix_p)\n-    *ix_p = ix;\n-\n-  return existed_p;\n-}\n-\n-\n-/* Insert tree node T in CACHE.  If T already existed in the cache\n-   return true.  Otherwise, return false.\n-\n-   If IX_P is non-null, update it with the index into the cache where\n-   T has been stored.  */\n-\n-bool\n-lto_streamer_cache_insert (struct lto_streamer_cache_d *cache, tree t,\n-\t\t\t   unsigned *ix_p)\n-{\n-  return lto_streamer_cache_insert_1 (cache, t, ix_p, true);\n-}\n-\n-\n-/* Insert tree node T in CACHE at slot IX.  If T already\n-   existed in the cache return true.  Otherwise, return false.  */\n-\n-bool\n-lto_streamer_cache_insert_at (struct lto_streamer_cache_d *cache,\n-\t\t\t      tree t, unsigned ix)\n-{\n-  return lto_streamer_cache_insert_1 (cache, t, &ix, false);\n-}\n-\n-\n-/* Appends tree node T to CACHE, even if T already existed in it.  */\n-\n-void\n-lto_streamer_cache_append (struct lto_streamer_cache_d *cache, tree t)\n-{\n-  unsigned ix = VEC_length (tree, cache->nodes);\n-  lto_streamer_cache_insert_1 (cache, t, &ix, false);\n-}\n-\n-/* Return true if tree node T exists in CACHE, otherwise false.  If IX_P is\n-   not NULL, write to *IX_P the index into the cache where T is stored\n-   ((unsigned)-1 if T is not found).  */\n-\n-bool\n-lto_streamer_cache_lookup (struct lto_streamer_cache_d *cache, tree t,\n-\t\t\t   unsigned *ix_p)\n-{\n-  void **slot;\n-  bool retval;\n-  unsigned ix;\n-\n-  gcc_assert (t);\n-\n-  slot = pointer_map_contains  (cache->node_map, t);\n-  if (slot == NULL)\n-    {\n-      retval = false;\n-      ix = -1;\n-    }\n-  else\n-    {\n-      retval = true;\n-      ix = (size_t) *slot - 1;\n-    }\n-\n-  if (ix_p)\n-    *ix_p = ix;\n-\n-  return retval;\n-}\n-\n-\n-/* Return the tree node at slot IX in CACHE.  */\n-\n-tree\n-lto_streamer_cache_get (struct lto_streamer_cache_d *cache, unsigned ix)\n-{\n-  gcc_assert (cache);\n-\n-  /* Make sure we're not requesting something we don't have.  */\n-  gcc_assert (ix < VEC_length (tree, cache->nodes));\n-\n-  return VEC_index (tree, cache->nodes, ix);\n-}\n-\n-\n /* Record NODE in CACHE.  */\n \n static void\n@@ -557,39 +336,6 @@ lto_preload_common_nodes (struct lto_streamer_cache_d *cache)\n       lto_record_common_node (cache, global_trees[i]);\n }\n \n-/* Create a cache of pickled nodes.  */\n-\n-struct lto_streamer_cache_d *\n-lto_streamer_cache_create (void)\n-{\n-  struct lto_streamer_cache_d *cache;\n-\n-  cache = XCNEW (struct lto_streamer_cache_d);\n-\n-  cache->node_map = pointer_map_create ();\n-\n-  /* Load all the well-known tree nodes that are always created by\n-     the compiler on startup.  This prevents writing them out\n-     unnecessarily.  */\n-  streamer_hooks.preload_common_nodes (cache);\n-\n-  return cache;\n-}\n-\n-\n-/* Delete the streamer cache C.  */\n-\n-void\n-lto_streamer_cache_delete (struct lto_streamer_cache_d *c)\n-{\n-  if (c == NULL)\n-    return;\n-\n-  pointer_map_destroy (c->node_map);\n-  VEC_free (tree, heap, c->nodes);\n-  free (c);\n-}\n-\n \n #ifdef LTO_STREAMER_DEBUG\n static htab_t tree_htab;\n@@ -756,12 +502,3 @@ lto_streamer_hooks_init (void)\n   streamer_hooks.write_tree = lto_streamer_write_tree;\n   streamer_hooks.read_tree = lto_streamer_read_tree;\n }\n-\n-\n-/* Initialize the current set of streamer hooks.  */\n-\n-void\n-streamer_hooks_init (void)\n-{\n-  memset (&streamer_hooks, 0, sizeof (streamer_hooks));\n-}"}, {"sha": "230838ba9c1b5d424a8c5c07e28e4b1e1fa43636", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 30, "deletions": 383, "changes": 413, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=f0efc7aa7705facdb16a39a08137cf748c7d5f30", "patch": "@@ -32,12 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"vecprim.h\"\n #include \"alloc-pool.h\"\n #include \"gcov-io.h\"\n-\n-/* Forward declarations to avoid including unnecessary headers.  */\n-struct output_block;\n-struct lto_input_block;\n-struct data_in;\n-struct bitpack_d;\n+#include \"diagnostic.h\"\n \n /* Define when debugging the LTO streamer.  This causes the writer\n    to output the numeric value for the memory address of the tree node\n@@ -152,27 +147,6 @@ struct bitpack_d;\n typedef unsigned char\tlto_decl_flags_t;\n \n \n-/* Data structures used to pack values and bitflags into a vector of\n-   words.  Used to stream values of a fixed number of bits in a space\n-   efficient way.  */\n-static unsigned const BITS_PER_BITPACK_WORD = HOST_BITS_PER_WIDE_INT;\n-\n-typedef unsigned HOST_WIDE_INT bitpack_word_t;\n-DEF_VEC_I(bitpack_word_t);\n-DEF_VEC_ALLOC_I(bitpack_word_t, heap);\n-\n-struct bitpack_d\n-{\n-  /* The position of the first unused or unconsumed bit in the word.  */\n-  unsigned pos;\n-\n-  /* The current word we are (un)packing.  */\n-  bitpack_word_t word;\n-\n-  /* The lto_output_stream or the lto_input_block we are streaming to/from.  */\n-  void *stream;\n-};\n-\n /* Tags representing the various IL objects written to the bytecode file\n    (GIMPLE statements, basic blocks, EH regions, tree nodes, etc).\n \n@@ -332,33 +306,6 @@ typedef void (lto_free_section_data_f) (struct lto_file_decl_data *,\n \t\t\t\t\tconst char *,\n \t\t\t\t\tsize_t);\n \n-/* Cache of pickled nodes.  Used to avoid writing the same node more\n-   than once.  The first time a tree node is streamed out, it is\n-   entered in this cache.  Subsequent references to the same node are\n-   resolved by looking it up in this cache.\n-\n-   This is used in two ways:\n-\n-   - On the writing side, the first time T is added to STREAMER_CACHE,\n-     a new reference index is created for T and T is emitted on the\n-     stream.  If T needs to be emitted again to the stream, instead of\n-     pickling it again, the reference index is emitted.\n-\n-   - On the reading side, the first time T is read from the stream, it\n-     is reconstructed in memory and a new reference index created for\n-     T.  The reconstructed T is inserted in some array so that when\n-     the reference index for T is found in the input stream, it can be\n-     used to look up into the array to get the reconstructed T.  */\n-struct lto_streamer_cache_d\n-{\n-  /* The mapping between tree nodes and slots into the nodes array.  */\n-  struct pointer_map_t *node_map;\n-\n-  /* The nodes pickled so far.  */\n-  VEC(tree,heap) *nodes;\n-};\n-\n-\n /* Structure used as buffer for reading an LTO file.  */\n struct lto_input_block\n {\n@@ -747,86 +694,6 @@ struct data_in\n };\n \n \n-/* Streamer hooks.  These functions do additional processing as\n-   needed by the module.  There are two types of callbacks, those that\n-   replace the default behavior and those that supplement it.\n-\n-   Hooks marked [REQ] are required to be set.  Those marked [OPT] may\n-   be NULL, if the streamer does not need to implement them.  */\n-struct streamer_hooks {\n-  /* [REQ] A string identifying this streamer.  */\n-  const char *name;\n-\n-  /* [REQ] Called by lto_streamer_cache_create to instantiate a cache of\n-     well-known nodes.  These are tree nodes that are always\n-     instantiated by the compiler on startup.  Additionally, these\n-     nodes need to be shared.  This function should call\n-     lto_streamer_cache_append on every tree node that it wishes to\n-     preload in the streamer cache.  This way, the writer will only\n-     write out a reference to the tree and the reader will instantiate\n-     the tree out of this pre-populated cache.  */\n-  void (*preload_common_nodes) (struct lto_streamer_cache_d *);\n-\n-  /* [REQ] Return true if the given tree is supported by this streamer.  */\n-  bool (*is_streamable) (tree);\n-\n-  /* [OPT] Called by lto_write_tree after writing all the common parts of\n-     a tree.  If defined, the callback is in charge of writing all\n-     the fields that lto_write_tree did not write out.  Arguments\n-     are as in lto_write_tree.\n-\n-     The following tree fields are not handled by common code:\n-\n-\tDECL_ABSTRACT_ORIGIN\n-\tDECL_INITIAL\n-\tDECL_SAVED_TREE\n-\n-     Callbacks may choose to ignore or handle them.  If handled,\n-     the reader should read them in the exact same sequence written\n-     by the writer.  */\n-  void (*write_tree) (struct output_block *, tree, bool);\n-\n-  /* [OPT] Called by lto_read_tree after reading all the common parts of\n-     a tree.  If defined, the callback is in charge of reading all\n-     the fields that lto_read_tree did not read in.  Arguments\n-     are as in lto_read_tree.  */\n-  void (*read_tree) (struct lto_input_block *, struct data_in *, tree);\n-\n-  /* [OPT] Called by lto_output_tree_ref to determine if the given tree node\n-     should be emitted as a reference to the table of declarations\n-     (the same table that holds global declarations).  */\n-  bool (*indexable_with_decls_p) (tree);\n-\n-  /* [OPT] Called by pack_value_fields to store any non-pointer fields\n-     in the tree structure.  The arguments are as in pack_value_fields.  */\n-  void (*pack_value_fields) (struct bitpack_d *, tree);\n-\n-  /* [OPT] Called by unpack_value_fields to retrieve any non-pointer fields\n-     in the tree structure.  The arguments are as in unpack_value_fields.  */\n-  void (*unpack_value_fields) (struct bitpack_d *, tree);\n-\n-  /* [OPT] Called by lto_materialize_tree for tree nodes that it does not\n-     know how to allocate memory for.  If defined, this hook should\n-     return a new tree node of the given code.  The data_in and\n-     input_block arguments are passed in case the hook needs to\n-     read more data from the stream to allocate the node.\n-     If this hook returns NULL, then lto_materialize_tree will attempt\n-     to allocate the tree by calling make_node directly.  */\n-  tree (*alloc_tree) (enum tree_code, struct lto_input_block *,\n-                      struct data_in *);\n-\n-  /* [OPT] Called by lto_output_tree_header to write any streamer-specific\n-     information needed to allocate the tree.  This hook may assume\n-     that the basic header data (tree code, etc) has already been\n-     written.  It should only write any extra data needed to allocate\n-     the node (e.g., in the case of CALL_EXPR, this hook would write\n-     the number of arguments to the CALL_EXPR).  */\n-  void (*output_tree_header) (struct output_block *, tree);\n-};\n-\n-/* Streamer hooks.  */\n-extern struct streamer_hooks streamer_hooks;\n-\n /* In lto-section-in.c  */\n extern struct lto_input_block * lto_create_simple_input_block (\n \t\t\t       struct lto_file_decl_data *,\n@@ -864,10 +731,6 @@ extern void lto_section_overrun (struct lto_input_block *) ATTRIBUTE_NORETURN;\n extern void lto_value_range_error (const char *,\n \t\t\t\t   HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t   HOST_WIDE_INT) ATTRIBUTE_NORETURN;\n-extern void bp_pack_var_len_unsigned (struct bitpack_d *, unsigned HOST_WIDE_INT);\n-extern void bp_pack_var_len_int (struct bitpack_d *, HOST_WIDE_INT);\n-extern unsigned HOST_WIDE_INT bp_unpack_var_len_unsigned (struct bitpack_d *);\n-extern HOST_WIDE_INT bp_unpack_var_len_int (struct bitpack_d *);\n \n /* In lto-section-out.c  */\n extern hashval_t lto_hash_decl_slot_node (const void *);\n@@ -919,16 +782,6 @@ extern bitmap lto_bitmap_alloc (void);\n extern void lto_bitmap_free (bitmap);\n extern char *lto_get_section_name (int, const char *, struct lto_file_decl_data *);\n extern void print_lto_report (void);\n-extern bool lto_streamer_cache_insert (struct lto_streamer_cache_d *, tree,\n-\t\t\t\t       unsigned *);\n-extern bool lto_streamer_cache_insert_at (struct lto_streamer_cache_d *, tree,\n-\t\t\t\t\t  unsigned);\n-extern void lto_streamer_cache_append (struct lto_streamer_cache_d *, tree);\n-extern bool lto_streamer_cache_lookup (struct lto_streamer_cache_d *, tree,\n-\t\t\t\t       unsigned *);\n-extern tree lto_streamer_cache_get (struct lto_streamer_cache_d *, unsigned);\n-extern struct lto_streamer_cache_d *lto_streamer_cache_create (void);\n-extern void lto_streamer_cache_delete (struct lto_streamer_cache_d *);\n extern void lto_streamer_init (void);\n extern bool gate_lto_out (void);\n #ifdef LTO_STREAMER_DEBUG\n@@ -938,15 +791,10 @@ extern void lto_orig_address_remove (tree);\n #endif\n extern void lto_check_version (int, int);\n extern void lto_streamer_hooks_init (void);\n-extern void lto_streamer_write_tree (struct output_block *, tree, bool);\n-extern void lto_streamer_read_tree (struct lto_input_block *,\n-\t\t\t\t     struct data_in *, tree);\n-extern void streamer_hooks_init (void);\n \n /* In lto-streamer-in.c */\n extern void lto_input_cgraph (struct lto_file_decl_data *, const char *);\n extern void lto_reader_init (void);\n-extern tree lto_input_tree (struct lto_input_block *, struct data_in *);\n extern void lto_input_function_body (struct lto_file_decl_data *, tree,\n \t\t\t\t     const char *);\n extern void lto_input_constructors_and_inits (struct lto_file_decl_data *,\n@@ -955,9 +803,12 @@ extern struct data_in *lto_data_in_create (struct lto_file_decl_data *,\n \t\t\t\t    const char *, unsigned,\n \t\t\t\t    VEC(ld_plugin_symbol_resolution_t,heap) *);\n extern void lto_data_in_delete (struct data_in *);\n-extern const char *lto_input_string (struct data_in *,\n-\t\t\t\t     struct lto_input_block *);\n extern void lto_input_data_block (struct lto_input_block *, void *, size_t);\n+location_t lto_input_location (struct lto_input_block *, struct data_in *);\n+tree lto_input_tree_ref (struct lto_input_block *, struct data_in *,\n+\t\t\t struct function *, enum LTO_tags);\n+void lto_tag_check_set (enum LTO_tags, int, ...);\n+void lto_init_eh (void);\n \n \n /* In lto-streamer-out.c  */\n@@ -971,6 +822,8 @@ void lto_output_decl_state_streams (struct output_block *,\n void lto_output_decl_state_refs (struct output_block *,\n \t\t\t         struct lto_output_stream *,\n \t\t\t         struct lto_out_decl_state *);\n+void lto_output_tree_ref (struct output_block *, tree);\n+void lto_output_location (struct output_block *, location_t);\n \n \n /* In lto-cgraph.c  */\n@@ -1096,6 +949,28 @@ lto_tag_to_tree_code (enum LTO_tags tag)\n   return (enum tree_code) ((unsigned) tag - 1);\n }\n \n+/* Check that tag ACTUAL == EXPECTED.  */\n+static inline void\n+lto_tag_check (enum LTO_tags actual, enum LTO_tags expected)\n+{\n+  if (actual != expected)\n+    internal_error (\"bytecode stream: expected tag %s instead of %s\",\n+\t\t    lto_tag_name (expected), lto_tag_name (actual));\n+}\n+\n+/* Check that tag ACTUAL is in the range [TAG1, TAG2].  */\n+static inline void\n+lto_tag_check_range (enum LTO_tags actual, enum LTO_tags tag1,\n+\t\t     enum LTO_tags tag2)\n+{\n+  if (actual < tag1 || actual > tag2)\n+    internal_error (\"bytecode stream: tag %s is not in the expected range \"\n+\t\t    \"[%s, %s]\",\n+\t\t    lto_tag_name (actual),\n+\t\t    lto_tag_name (tag1),\n+\t\t    lto_tag_name (tag2));\n+}\n+\n /* Initialize an lto_out_decl_buffer ENCODER.  */\n static inline void\n lto_init_tree_ref_encoder (struct lto_tree_ref_encoder *encoder,\n@@ -1160,232 +1035,4 @@ DEFINE_DECL_STREAM_FUNCS (TYPE_DECL, type_decl)\n DEFINE_DECL_STREAM_FUNCS (NAMESPACE_DECL, namespace_decl)\n DEFINE_DECL_STREAM_FUNCS (LABEL_DECL, label_decl)\n \n-/* Returns a new bit-packing context for bit-packing into S.  */\n-static inline struct bitpack_d\n-bitpack_create (struct lto_output_stream *s)\n-{\n-  struct bitpack_d bp;\n-  bp.pos = 0;\n-  bp.word = 0;\n-  bp.stream = (void *)s;\n-  return bp;\n-}\n-\n-/* Pack the NBITS bit sized value VAL into the bit-packing context BP.  */\n-static inline void\n-bp_pack_value (struct bitpack_d *bp, bitpack_word_t val, unsigned nbits)\n-{\n-  bitpack_word_t word = bp->word;\n-  int pos = bp->pos;\n-\n-  /* Verify that VAL fits in the NBITS.  */\n-  gcc_checking_assert (nbits == BITS_PER_BITPACK_WORD\n-\t\t       || !(val & ~(((bitpack_word_t)1<<nbits)-1)));\n-\n-  /* If val does not fit into the current bitpack word switch to the\n-     next one.  */\n-  if (pos + nbits > BITS_PER_BITPACK_WORD)\n-    {\n-      lto_output_uleb128_stream ((struct lto_output_stream *) bp->stream, word);\n-      word = val;\n-      pos = nbits;\n-    }\n-  else\n-    {\n-      word |= val << pos;\n-      pos += nbits;\n-    }\n-  bp->word = word;\n-  bp->pos = pos;\n-}\n-\n-/* Finishes bit-packing of BP.  */\n-static inline void\n-lto_output_bitpack (struct bitpack_d *bp)\n-{\n-  lto_output_uleb128_stream ((struct lto_output_stream *) bp->stream,\n-\t\t\t     bp->word);\n-  bp->word = 0;\n-  bp->pos = 0;\n-}\n-\n-/* Returns a new bit-packing context for bit-unpacking from IB.  */\n-static inline struct bitpack_d\n-lto_input_bitpack (struct lto_input_block *ib)\n-{\n-  struct bitpack_d bp;\n-  bp.word = lto_input_uleb128 (ib);\n-  bp.pos = 0;\n-  bp.stream = (void *)ib;\n-  return bp;\n-}\n-\n-/* Unpacks NBITS bits from the bit-packing context BP and returns them.  */\n-static inline bitpack_word_t\n-bp_unpack_value (struct bitpack_d *bp, unsigned nbits)\n-{\n-  bitpack_word_t mask, val;\n-  int pos = bp->pos;\n-\n-  mask = (nbits == BITS_PER_BITPACK_WORD\n-\t  ? (bitpack_word_t) -1\n-\t  : ((bitpack_word_t) 1 << nbits) - 1);\n-\n-  /* If there are not continuous nbits in the current bitpack word\n-     switch to the next one.  */\n-  if (pos + nbits > BITS_PER_BITPACK_WORD)\n-    {\n-      bp->word = val = lto_input_uleb128 ((struct lto_input_block *)bp->stream);\n-      bp->pos = nbits;\n-      return val & mask;\n-    }\n-  val = bp->word;\n-  val >>= pos;\n-  bp->pos = pos + nbits;\n-\n-  return val & mask;\n-}\n-\n-\n-/* Write a character to the output block.  */\n-\n-static inline void\n-lto_output_1_stream (struct lto_output_stream *obs, char c)\n-{\n-  /* No space left.  */\n-  if (obs->left_in_block == 0)\n-    lto_append_block (obs);\n-\n-  /* Write the actual character.  */\n-  *obs->current_pointer = c;\n-  obs->current_pointer++;\n-  obs->total_size++;\n-  obs->left_in_block--;\n-}\n-\n-\n-/* Read byte from the input block.  */\n-\n-static inline unsigned char\n-lto_input_1_unsigned (struct lto_input_block *ib)\n-{\n-  if (ib->p >= ib->len)\n-    lto_section_overrun (ib);\n-  return (ib->data[ib->p++]);\n-}\n-\n-/* Output VAL into OBS and verify it is in range MIN...MAX that is supposed\n-   to be compile time constant.\n-   Be host independent, limit range to 31bits.  */\n-\n-static inline void\n-lto_output_int_in_range (struct lto_output_stream *obs,\n-\t\t\t HOST_WIDE_INT min,\n-\t\t\t HOST_WIDE_INT max,\n-\t\t\t HOST_WIDE_INT val)\n-{\n-  HOST_WIDE_INT range = max - min;\n-\n-  gcc_checking_assert (val >= min && val <= max && range > 0\n-\t\t       && range < 0x7fffffff);\n-\n-  val -= min;\n-  lto_output_1_stream (obs, val & 255);\n-  if (range >= 0xff)\n-    lto_output_1_stream (obs, (val >> 8) & 255);\n-  if (range >= 0xffff)\n-    lto_output_1_stream (obs, (val >> 16) & 255);\n-  if (range >= 0xffffff)\n-    lto_output_1_stream (obs, (val >> 24) & 255);\n-}\n-\n-/* Input VAL into OBS and verify it is in range MIN...MAX that is supposed\n-   to be compile time constant.  PURPOSE is used for error reporting.  */\n-\n-static inline HOST_WIDE_INT\n-lto_input_int_in_range (struct lto_input_block *ib,\n-\t\t\tconst char *purpose,\n-\t\t\tHOST_WIDE_INT min,\n-\t\t\tHOST_WIDE_INT max)\n-{\n-  HOST_WIDE_INT range = max - min;\n-  HOST_WIDE_INT val = lto_input_1_unsigned (ib);\n-\n-  gcc_checking_assert (range > 0 && range < 0x7fffffff);\n-\n-  if (range >= 0xff)\n-    val |= ((HOST_WIDE_INT)lto_input_1_unsigned (ib)) << 8;\n-  if (range >= 0xffff)\n-    val |= ((HOST_WIDE_INT)lto_input_1_unsigned (ib)) << 16;\n-  if (range >= 0xffffff)\n-    val |= ((HOST_WIDE_INT)lto_input_1_unsigned (ib)) << 24;\n-  val += min;\n-  if (val < min || val > max)\n-    lto_value_range_error (purpose, val, min, max);\n-  return val;\n-}\n-\n-\n-/* Output VAL into BP and verify it is in range MIN...MAX that is supposed\n-   to be compile time constant.\n-   Be host independent, limit range to 31bits.  */\n-\n-static inline void\n-bp_pack_int_in_range (struct bitpack_d *bp,\n-\t\t      HOST_WIDE_INT min,\n-\t\t      HOST_WIDE_INT max,\n-\t\t      HOST_WIDE_INT val)\n-{\n-  HOST_WIDE_INT range = max - min;\n-  int nbits = floor_log2 (range) + 1;\n-\n-  gcc_checking_assert (val >= min && val <= max && range > 0\n-\t\t       && range < 0x7fffffff);\n-\n-  val -= min;\n-  bp_pack_value (bp, val, nbits);\n-}\n-\n-/* Input VAL into BP and verify it is in range MIN...MAX that is supposed\n-   to be compile time constant.  PURPOSE is used for error reporting.  */\n-\n-static inline HOST_WIDE_INT\n-bp_unpack_int_in_range (struct bitpack_d *bp,\n-\t\t        const char *purpose,\n-\t\t        HOST_WIDE_INT min,\n-\t\t        HOST_WIDE_INT max)\n-{\n-  HOST_WIDE_INT range = max - min;\n-  int nbits = floor_log2 (range) + 1;\n-  HOST_WIDE_INT val = bp_unpack_value (bp, nbits);\n-\n-  gcc_checking_assert (range > 0 && range < 0x7fffffff);\n-\n-  if (val < min || val > max)\n-    lto_value_range_error (purpose, val, min, max);\n-  return val;\n-}\n-\n-/* Output VAL of type \"enum enum_name\" into OBS.\n-   Assume range 0...ENUM_LAST - 1.  */\n-#define lto_output_enum(obs,enum_name,enum_last,val) \\\n-  lto_output_int_in_range ((obs), 0, (int)(enum_last) - 1, (int)(val))\n-\n-/* Input enum of type \"enum enum_name\" from IB.\n-   Assume range 0...ENUM_LAST - 1.  */\n-#define lto_input_enum(ib,enum_name,enum_last) \\\n-  (enum enum_name)lto_input_int_in_range ((ib), #enum_name, 0, \\\n-\t\t\t\t\t  (int)(enum_last) - 1)\n-\n-/* Output VAL of type \"enum enum_name\" into BP.\n-   Assume range 0...ENUM_LAST - 1.  */\n-#define bp_pack_enum(bp,enum_name,enum_last,val) \\\n-  bp_pack_int_in_range ((bp), 0, (int)(enum_last) - 1, (int)(val))\n-\n-/* Input enum of type \"enum enum_name\" from BP.\n-   Assume range 0...ENUM_LAST - 1.  */\n-#define bp_unpack_enum(bp,enum_name,enum_last) \\\n-  (enum enum_name)bp_unpack_int_in_range ((bp), #enum_name, 0, \\\n-\t\t\t\t\t(int)(enum_last) - 1)\n-\n #endif /* GCC_LTO_STREAMER_H  */"}, {"sha": "638e37c1f633db1c5b1f0ff53c22cf94e4434806", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=f0efc7aa7705facdb16a39a08137cf748c7d5f30", "patch": "@@ -1,3 +1,8 @@\n+2011-08-08   Diego Novillo  <dnovillo@google.com>\n+\n+\t* Make-lang.in (lto/lto.o): Add TREE_STREAMER_H.\n+\t* lto.c: Include tree-streamer.h.\n+\n 2011-07-06  Richard Guenther  <rguenther@suse.de>\n \n \t* lto-lang.c (lto_init):"}, {"sha": "c48c8d2ebce3d910123e82aa59efb7b5ef3bb839", "filename": "gcc/lto/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Flto%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Flto%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FMake-lang.in?ref=f0efc7aa7705facdb16a39a08137cf748c7d5f30", "patch": "@@ -86,7 +86,7 @@ lto/lto.o: lto/lto.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(OPTS_H) \\\n \tlanghooks.h $(VEC_H) $(BITMAP_H) pointer-set.h $(IPA_PROP_H) \\\n \t$(COMMON_H) debug.h $(TIMEVAR_H) $(GIMPLE_H) $(LTO_H) $(LTO_TREE_H) \\\n \t$(LTO_TAGS_H) $(LTO_STREAMER_H) $(SPLAY_TREE_H) gt-lto-lto.h $(PARAMS_H) \\\n-\tipa-inline.h $(IPA_UTILS_H)\n+\tipa-inline.h $(IPA_UTILS_H) $(TREE_STREAMER_H)\n lto/lto-object.o: lto/lto-object.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n \t$(DIAGNOSTIC_CORE_H) $(LTO_H) $(TM_H) $(LTO_STREAMER_H) \\\n \t../include/simple-object.h"}, {"sha": "93ff805b19902ef31c850aa5b52eaa2dff6ed353", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=f0efc7aa7705facdb16a39a08137cf748c7d5f30", "patch": "@@ -43,6 +43,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"lto.h\"\n #include \"lto-tree.h\"\n #include \"lto-streamer.h\"\n+#include \"tree-streamer.h\"\n #include \"splay-tree.h\"\n #include \"params.h\"\n #include \"ipa-inline.h\""}, {"sha": "ef5fee35f3e498eb93a45ed4aba241926fa51be5", "filename": "gcc/streamer-hooks.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Fstreamer-hooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Fstreamer-hooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstreamer-hooks.c?ref=f0efc7aa7705facdb16a39a08137cf748c7d5f30", "patch": "@@ -0,0 +1,37 @@\n+/* Streamer hooks.  Support for adding streamer-specific callbacks to\n+   generic streaming routines.\n+\n+   Copyright 2011 Free Software Foundation, Inc.\n+   Contributed by Diego Novillo <dnovillo@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"streamer-hooks.h\"\n+\n+/* Streamer hooks.  */\n+struct streamer_hooks streamer_hooks;\n+\n+/* Initialize the current set of streamer hooks.  */\n+\n+void\n+streamer_hooks_init (void)\n+{\n+  memset (&streamer_hooks, 0, sizeof (streamer_hooks));\n+}"}, {"sha": "29a6591ccc0aead8f968e321db4155fc8271bd7b", "filename": "gcc/streamer-hooks.h", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Fstreamer-hooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Fstreamer-hooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstreamer-hooks.h?ref=f0efc7aa7705facdb16a39a08137cf748c7d5f30", "patch": "@@ -0,0 +1,118 @@\n+/* Streamer hooks.  Support for adding streamer-specific callbacks to\n+   generic streaming routines.\n+\n+   Copyright 2011 Free Software Foundation, Inc.\n+   Contributed by Diego Novillo <dnovillo@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_STREAMER_HOOKS_H\n+#define GCC_STREAMER_HOOKS_H\n+\n+#include \"tree.h\"\n+\n+/* Forward declarations to avoid including unnecessary headers.  */\n+struct output_block;\n+struct lto_input_block;\n+struct data_in;\n+struct bitpack_d;\n+struct lto_streamer_cache_d;\n+\n+/* Streamer hooks.  These functions do additional processing as\n+   needed by the module.  There are two types of callbacks, those that\n+   replace the default behavior and those that supplement it.\n+\n+   Hooks marked [REQ] are required to be set.  Those marked [OPT] may\n+   be NULL, if the streamer does not need to implement them.  */\n+struct streamer_hooks {\n+  /* [REQ] A string identifying this streamer.  */\n+  const char *name;\n+\n+  /* [REQ] Called by lto_streamer_cache_create to instantiate a cache of\n+     well-known nodes.  These are tree nodes that are always\n+     instantiated by the compiler on startup.  Additionally, these\n+     nodes need to be shared.  This function should call\n+     lto_streamer_cache_append on every tree node that it wishes to\n+     preload in the streamer cache.  This way, the writer will only\n+     write out a reference to the tree and the reader will instantiate\n+     the tree out of this pre-populated cache.  */\n+  void (*preload_common_nodes) (struct lto_streamer_cache_d *);\n+\n+  /* [REQ] Return true if the given tree is supported by this streamer.  */\n+  bool (*is_streamable) (tree);\n+\n+  /* [OPT] Called by lto_write_tree after writing all the common parts of\n+     a tree.  If defined, the callback is in charge of writing all\n+     the fields that lto_write_tree did not write out.  Arguments\n+     are as in lto_write_tree.\n+\n+     The following tree fields are not handled by common code:\n+\n+\tDECL_ABSTRACT_ORIGIN\n+\tDECL_INITIAL\n+\tDECL_SAVED_TREE\n+\n+     Callbacks may choose to ignore or handle them.  If handled,\n+     the reader should read them in the exact same sequence written\n+     by the writer.  */\n+  void (*write_tree) (struct output_block *, tree, bool);\n+\n+  /* [OPT] Called by lto_read_tree after reading all the common parts of\n+     a tree.  If defined, the callback is in charge of reading all\n+     the fields that lto_read_tree did not read in.  Arguments\n+     are as in lto_read_tree.  */\n+  void (*read_tree) (struct lto_input_block *, struct data_in *, tree);\n+\n+  /* [OPT] Called by lto_output_tree_ref to determine if the given tree node\n+     should be emitted as a reference to the table of declarations\n+     (the same table that holds global declarations).  */\n+  bool (*indexable_with_decls_p) (tree);\n+\n+  /* [OPT] Called by pack_value_fields to store any non-pointer fields\n+     in the tree structure.  The arguments are as in pack_value_fields.  */\n+  void (*pack_value_fields) (struct bitpack_d *, tree);\n+\n+  /* [OPT] Called by unpack_value_fields to retrieve any non-pointer fields\n+     in the tree structure.  The arguments are as in unpack_value_fields.  */\n+  void (*unpack_value_fields) (struct bitpack_d *, tree);\n+\n+  /* [OPT] Called by lto_materialize_tree for tree nodes that it does not\n+     know how to allocate memory for.  If defined, this hook should\n+     return a new tree node of the given code.  The data_in and\n+     input_block arguments are passed in case the hook needs to\n+     read more data from the stream to allocate the node.\n+     If this hook returns NULL, then lto_materialize_tree will attempt\n+     to allocate the tree by calling make_node directly.  */\n+  tree (*alloc_tree) (enum tree_code, struct lto_input_block *,\n+                      struct data_in *);\n+\n+  /* [OPT] Called by lto_output_tree_header to write any streamer-specific\n+     information needed to allocate the tree.  This hook may assume\n+     that the basic header data (tree code, etc) has already been\n+     written.  It should only write any extra data needed to allocate\n+     the node (e.g., in the case of CALL_EXPR, this hook would write\n+     the number of arguments to the CALL_EXPR).  */\n+  void (*output_tree_header) (struct output_block *, tree);\n+};\n+\n+/* Streamer hooks.  */\n+extern struct streamer_hooks streamer_hooks;\n+\n+/* In streamer-hooks.c.  */\n+void streamer_hooks_init (void);\n+\n+#endif  /* GCC_STREAMER_HOOKS_H  */"}, {"sha": "cd2f221d6392b9d8c3b35f38e203c39c05d785d1", "filename": "gcc/tree-streamer-in.c", "status": "added", "additions": 1153, "deletions": 0, "changes": 1153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Ftree-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Ftree-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.c?ref=f0efc7aa7705facdb16a39a08137cf748c7d5f30", "patch": "@@ -0,0 +1,1153 @@\n+/* Routines for reading trees from a file stream.\n+\n+   Copyright 2011 Free Software Foundation, Inc.\n+   Contributed by Diego Novillo <dnovillo@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"diagnostic.h\"\n+#include \"tree.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-streamer.h\"\n+#include \"data-streamer.h\"\n+#include \"streamer-hooks.h\"\n+#include \"lto-streamer.h\"\n+\n+/* Read a STRING_CST from the string table in DATA_IN using input\n+   block IB.  */\n+\n+tree\n+input_string_cst (struct data_in *data_in, struct lto_input_block *ib)\n+{\n+  unsigned int len;\n+  const char * ptr;\n+\n+  ptr = input_string_internal (data_in, ib, &len);\n+  if (!ptr)\n+    return NULL;\n+  return build_string (len, ptr);\n+}\n+\n+\n+/* Read an IDENTIFIER from the string table in DATA_IN using input\n+   block IB.  */\n+\n+static tree\n+input_identifier (struct data_in *data_in, struct lto_input_block *ib)\n+{\n+  unsigned int len;\n+  const char *ptr;\n+\n+  ptr = input_string_internal (data_in, ib, &len);\n+  if (!ptr)\n+    return NULL;\n+  return get_identifier_with_length (ptr, len);\n+}\n+\n+\n+/* Read a chain of tree nodes from input block IB. DATA_IN contains\n+   tables and descriptors for the file being read.  */\n+\n+static tree\n+lto_input_chain (struct lto_input_block *ib, struct data_in *data_in)\n+{\n+  int i, count;\n+  tree first, prev, curr;\n+\n+  first = prev = NULL_TREE;\n+  count = lto_input_sleb128 (ib);\n+  for (i = 0; i < count; i++)\n+    {\n+      curr = lto_input_tree (ib, data_in);\n+      if (prev)\n+\tTREE_CHAIN (prev) = curr;\n+      else\n+\tfirst = curr;\n+\n+      TREE_CHAIN (curr) = NULL_TREE;\n+      prev = curr;\n+    }\n+\n+  return first;\n+}\n+\n+\n+/* Unpack all the non-pointer fields of the TS_BASE structure of\n+   expression EXPR from bitpack BP.  */\n+\n+static void\n+unpack_ts_base_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  /* Note that the code for EXPR has already been unpacked to create EXPR in\n+     lto_materialize_tree.  */\n+  if (!TYPE_P (expr))\n+    {\n+      TREE_SIDE_EFFECTS (expr) = (unsigned) bp_unpack_value (bp, 1);\n+      TREE_CONSTANT (expr) = (unsigned) bp_unpack_value (bp, 1);\n+      TREE_READONLY (expr) = (unsigned) bp_unpack_value (bp, 1);\n+\n+      /* TREE_PUBLIC is used on types to indicate that the type\n+\t has a TYPE_CACHED_VALUES vector.  This is not streamed out,\n+\t so we skip it here.  */\n+      TREE_PUBLIC (expr) = (unsigned) bp_unpack_value (bp, 1);\n+    }\n+  else\n+    bp_unpack_value (bp, 4);\n+  TREE_ADDRESSABLE (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  TREE_THIS_VOLATILE (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  if (DECL_P (expr))\n+    DECL_UNSIGNED (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  else if (TYPE_P (expr))\n+    TYPE_UNSIGNED (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  else\n+    bp_unpack_value (bp, 1);\n+  TREE_ASM_WRITTEN (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  if (TYPE_P (expr))\n+    TYPE_ARTIFICIAL (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  else\n+    TREE_NO_WARNING (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  TREE_USED (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  TREE_NOTHROW (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  TREE_STATIC (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  TREE_PRIVATE (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  TREE_PROTECTED (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  TREE_DEPRECATED (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  if (TYPE_P (expr))\n+    TYPE_SATURATING (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  else if (TREE_CODE (expr) == SSA_NAME)\n+    SSA_NAME_IS_DEFAULT_DEF (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  else\n+    bp_unpack_value (bp, 1);\n+}\n+\n+\n+/* Unpack all the non-pointer fields of the TS_REAL_CST structure of\n+   expression EXPR from bitpack BP.  */\n+\n+static void\n+unpack_ts_real_cst_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  unsigned i;\n+  REAL_VALUE_TYPE r;\n+  REAL_VALUE_TYPE *rp;\n+\n+  r.cl = (unsigned) bp_unpack_value (bp, 2);\n+  r.decimal = (unsigned) bp_unpack_value (bp, 1);\n+  r.sign = (unsigned) bp_unpack_value (bp, 1);\n+  r.signalling = (unsigned) bp_unpack_value (bp, 1);\n+  r.canonical = (unsigned) bp_unpack_value (bp, 1);\n+  r.uexp = (unsigned) bp_unpack_value (bp, EXP_BITS);\n+  for (i = 0; i < SIGSZ; i++)\n+    r.sig[i] = (unsigned long) bp_unpack_value (bp, HOST_BITS_PER_LONG);\n+\n+  rp = ggc_alloc_real_value ();\n+  memcpy (rp, &r, sizeof (REAL_VALUE_TYPE));\n+  TREE_REAL_CST_PTR (expr) = rp;\n+}\n+\n+\n+/* Unpack all the non-pointer fields of the TS_FIXED_CST structure of\n+   expression EXPR from bitpack BP.  */\n+\n+static void\n+unpack_ts_fixed_cst_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  struct fixed_value fv;\n+\n+  fv.mode = bp_unpack_enum (bp, machine_mode, MAX_MACHINE_MODE);\n+  fv.data.low = bp_unpack_var_len_int (bp);\n+  fv.data.high = bp_unpack_var_len_int (bp);\n+  TREE_FIXED_CST (expr) = fv;\n+}\n+\n+\n+/* Unpack all the non-pointer fields of the TS_DECL_COMMON structure\n+   of expression EXPR from bitpack BP.  */\n+\n+static void\n+unpack_ts_decl_common_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  DECL_MODE (expr) = bp_unpack_enum (bp, machine_mode, MAX_MACHINE_MODE);\n+  DECL_NONLOCAL (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_VIRTUAL_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_IGNORED_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_ABSTRACT (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_ARTIFICIAL (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_USER_ALIGN (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_PRESERVE_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_DEBUG_EXPR_IS_FROM (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_EXTERNAL (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_GIMPLE_REG_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_ALIGN (expr) = (unsigned) bp_unpack_var_len_unsigned (bp);\n+\n+  if (TREE_CODE (expr) == LABEL_DECL)\n+    {\n+      DECL_ERROR_ISSUED (expr) = (unsigned) bp_unpack_value (bp, 1);\n+      EH_LANDING_PAD_NR (expr) = (int) bp_unpack_var_len_unsigned (bp);\n+\n+      /* Always assume an initial value of -1 for LABEL_DECL_UID to\n+\t force gimple_set_bb to recreate label_to_block_map.  */\n+      LABEL_DECL_UID (expr) = -1;\n+    }\n+\n+  if (TREE_CODE (expr) == FIELD_DECL)\n+    {\n+      DECL_PACKED (expr) = (unsigned) bp_unpack_value (bp, 1);\n+      DECL_NONADDRESSABLE_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n+      expr->decl_common.off_align = bp_unpack_value (bp, 8);\n+    }\n+\n+  if (TREE_CODE (expr) == RESULT_DECL\n+      || TREE_CODE (expr) == PARM_DECL\n+      || TREE_CODE (expr) == VAR_DECL)\n+    {\n+      DECL_BY_REFERENCE (expr) = (unsigned) bp_unpack_value (bp, 1);\n+      if (TREE_CODE (expr) == VAR_DECL\n+\t  || TREE_CODE (expr) == PARM_DECL)\n+\tDECL_HAS_VALUE_EXPR_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n+      DECL_RESTRICTED_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n+    }\n+}\n+\n+\n+/* Unpack all the non-pointer fields of the TS_DECL_WRTL structure\n+   of expression EXPR from bitpack BP.  */\n+\n+static void\n+unpack_ts_decl_wrtl_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  DECL_REGISTER (expr) = (unsigned) bp_unpack_value (bp, 1);\n+}\n+\n+\n+/* Unpack all the non-pointer fields of the TS_DECL_WITH_VIS structure\n+   of expression EXPR from bitpack BP.  */\n+\n+static void\n+unpack_ts_decl_with_vis_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  DECL_DEFER_OUTPUT (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_COMMON (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_DLLIMPORT_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_WEAK (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_SEEN_IN_BIND_EXPR_P (expr) = (unsigned) bp_unpack_value (bp,  1);\n+  DECL_COMDAT (expr) = (unsigned) bp_unpack_value (bp,  1);\n+  DECL_VISIBILITY (expr) = (enum symbol_visibility) bp_unpack_value (bp,  2);\n+  DECL_VISIBILITY_SPECIFIED (expr) = (unsigned) bp_unpack_value (bp,  1);\n+\n+  if (TREE_CODE (expr) == VAR_DECL)\n+    {\n+      DECL_HARD_REGISTER (expr) = (unsigned) bp_unpack_value (bp, 1);\n+      DECL_IN_TEXT_SECTION (expr) = (unsigned) bp_unpack_value (bp, 1);\n+      DECL_IN_CONSTANT_POOL (expr) = (unsigned) bp_unpack_value (bp, 1);\n+      DECL_TLS_MODEL (expr) = (enum tls_model) bp_unpack_value (bp,  3);\n+    }\n+\n+  if (VAR_OR_FUNCTION_DECL_P (expr))\n+    {\n+      priority_type p;\n+      p = (priority_type) bp_unpack_var_len_unsigned (bp);\n+      SET_DECL_INIT_PRIORITY (expr, p);\n+    }\n+}\n+\n+\n+/* Unpack all the non-pointer fields of the TS_FUNCTION_DECL structure\n+   of expression EXPR from bitpack BP.  */\n+\n+static void\n+unpack_ts_function_decl_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  DECL_BUILT_IN_CLASS (expr) = bp_unpack_enum (bp, built_in_class,\n+\t\t\t\t\t       BUILT_IN_LAST);\n+  DECL_STATIC_CONSTRUCTOR (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_STATIC_DESTRUCTOR (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_UNINLINABLE (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_POSSIBLY_INLINED (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_IS_NOVOPS (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_IS_RETURNS_TWICE (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_IS_MALLOC (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_IS_OPERATOR_NEW (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_DECLARED_INLINE_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_STATIC_CHAIN (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_NO_INLINE_WARNING_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (expr)\n+    \t\t\t= (unsigned) bp_unpack_value (bp, 1);\n+  DECL_NO_LIMIT_STACK (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_DISREGARD_INLINE_LIMITS (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_PURE_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  DECL_LOOPING_CONST_OR_PURE_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  if (DECL_BUILT_IN_CLASS (expr) != NOT_BUILT_IN)\n+    {\n+      DECL_FUNCTION_CODE (expr) = (enum built_in_function) bp_unpack_value (bp,\n+\t                                                                    11);\n+      if (DECL_BUILT_IN_CLASS (expr) == BUILT_IN_NORMAL\n+\t  && DECL_FUNCTION_CODE (expr) >= END_BUILTINS)\n+\tfatal_error (\"machine independent builtin code out of range\");\n+      else if (DECL_BUILT_IN_CLASS (expr) == BUILT_IN_MD)\n+\t{\n+          tree result = targetm.builtin_decl (DECL_FUNCTION_CODE (expr), true);\n+\t  if (!result || result == error_mark_node)\n+\t    fatal_error (\"target specific builtin not available\");\n+\t}\n+    }\n+  if (DECL_STATIC_DESTRUCTOR (expr))\n+    {\n+      priority_type p;\n+      p = (priority_type) bp_unpack_var_len_unsigned (bp);\n+      SET_DECL_FINI_PRIORITY (expr, p);\n+    }\n+}\n+\n+\n+/* Unpack all the non-pointer fields of the TS_TYPE_COMMON structure\n+   of expression EXPR from bitpack BP.  */\n+\n+static void\n+unpack_ts_type_common_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  enum machine_mode mode;\n+\n+  mode = bp_unpack_enum (bp, machine_mode, MAX_MACHINE_MODE);\n+  SET_TYPE_MODE (expr, mode);\n+  TYPE_STRING_FLAG (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  TYPE_NO_FORCE_BLK (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  TYPE_NEEDS_CONSTRUCTING (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  if (RECORD_OR_UNION_TYPE_P (expr))\n+    TYPE_TRANSPARENT_AGGR (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  TYPE_PACKED (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  TYPE_RESTRICT (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  TYPE_CONTAINS_PLACEHOLDER_INTERNAL (expr)\n+    \t= (unsigned) bp_unpack_value (bp, 2);\n+  TYPE_USER_ALIGN (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  TYPE_READONLY (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  TYPE_PRECISION (expr) = bp_unpack_var_len_unsigned (bp);\n+  TYPE_ALIGN (expr) = bp_unpack_var_len_unsigned (bp);\n+  TYPE_ALIAS_SET (expr) = bp_unpack_var_len_int (bp);\n+}\n+\n+\n+/* Unpack all the non-pointer fields of the TS_BLOCK structure\n+   of expression EXPR from bitpack BP.  */\n+\n+static void\n+unpack_ts_block_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  BLOCK_ABSTRACT (expr) = (unsigned) bp_unpack_value (bp, 1);\n+  /* BLOCK_NUMBER is recomputed.  */\n+}\n+\n+/* Unpack all the non-pointer fields of the TS_TRANSLATION_UNIT_DECL\n+   structure of expression EXPR from bitpack BP.  */\n+\n+static void\n+unpack_ts_translation_unit_decl_value_fields (struct bitpack_d *bp ATTRIBUTE_UNUSED, tree expr ATTRIBUTE_UNUSED)\n+{\n+}\n+\n+/* Unpack all the non-pointer fields in EXPR into a bit pack.  */\n+\n+static void\n+unpack_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  enum tree_code code;\n+\n+  code = TREE_CODE (expr);\n+\n+  /* Note that all these functions are highly sensitive to changes in\n+     the types and sizes of each of the fields being packed.  */\n+  unpack_ts_base_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_REAL_CST))\n+    unpack_ts_real_cst_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_FIXED_CST))\n+    unpack_ts_fixed_cst_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n+    unpack_ts_decl_common_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WRTL))\n+    unpack_ts_decl_wrtl_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n+    unpack_ts_decl_with_vis_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_FUNCTION_DECL))\n+    unpack_ts_function_decl_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_COMMON))\n+    unpack_ts_type_common_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_BLOCK))\n+    unpack_ts_block_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TRANSLATION_UNIT_DECL))\n+    unpack_ts_translation_unit_decl_value_fields (bp, expr);\n+\n+  if (streamer_hooks.unpack_value_fields)\n+    streamer_hooks.unpack_value_fields (bp, expr);\n+}\n+\n+\n+/* Materialize a new tree from input block IB using descriptors in\n+   DATA_IN.  The code for the new tree should match TAG.  Store in\n+   *IX_P the index into the reader cache where the new tree is stored.  */\n+\n+static tree\n+lto_materialize_tree (struct lto_input_block *ib, struct data_in *data_in,\n+\t\t      enum LTO_tags tag)\n+{\n+  struct bitpack_d bp;\n+  enum tree_code code;\n+  tree result;\n+#ifdef LTO_STREAMER_DEBUG\n+  HOST_WIDEST_INT orig_address_in_writer;\n+#endif\n+\n+  result = NULL_TREE;\n+\n+#ifdef LTO_STREAMER_DEBUG\n+  /* Read the word representing the memory address for the tree\n+     as it was written by the writer.  This is useful when\n+     debugging differences between the writer and reader.  */\n+  orig_address_in_writer = lto_input_sleb128 (ib);\n+  gcc_assert ((intptr_t) orig_address_in_writer == orig_address_in_writer);\n+#endif\n+\n+  code = lto_tag_to_tree_code (tag);\n+\n+  /* We should never see an SSA_NAME tree.  Only the version numbers of\n+     SSA names are ever written out.  See input_ssa_names.  */\n+  gcc_assert (code != SSA_NAME);\n+\n+  /* Instantiate a new tree using the header data.  */\n+  if (CODE_CONTAINS_STRUCT (code, TS_STRING))\n+    result = input_string_cst (data_in, ib);\n+  else if (CODE_CONTAINS_STRUCT (code, TS_IDENTIFIER))\n+    result = input_identifier (data_in, ib);\n+  else if (CODE_CONTAINS_STRUCT (code, TS_VEC))\n+    {\n+      HOST_WIDE_INT len = lto_input_sleb128 (ib);\n+      result = make_tree_vec (len);\n+    }\n+  else if (CODE_CONTAINS_STRUCT (code, TS_BINFO))\n+    {\n+      unsigned HOST_WIDE_INT len = lto_input_uleb128 (ib);\n+      result = make_tree_binfo (len);\n+    }\n+  else\n+    {\n+      /* For all other nodes, see if the streamer knows how to allocate\n+\t it.  */\n+      if (streamer_hooks.alloc_tree)\n+\tresult = streamer_hooks.alloc_tree (code, ib, data_in);\n+\n+      /* If the hook did not handle it, materialize the tree with a raw\n+\t make_node call.  */\n+      if (result == NULL_TREE)\n+\tresult = make_node (code);\n+    }\n+\n+#ifdef LTO_STREAMER_DEBUG\n+  /* Store the original address of the tree as seen by the writer\n+     in RESULT's aux field.  This is useful when debugging streaming\n+     problems.  This way, a debugging session can be started on\n+     both writer and reader with a breakpoint using this address\n+     value in both.  */\n+  lto_orig_address_map (result, (intptr_t) orig_address_in_writer);\n+#endif\n+\n+  /* Read the bitpack of non-pointer values from IB.  */\n+  bp = lto_input_bitpack (ib);\n+\n+  /* The first word in BP contains the code of the tree that we\n+     are about to read.  */\n+  code = (enum tree_code) bp_unpack_value (&bp, 16);\n+  lto_tag_check (lto_tree_code_to_tag (code), tag);\n+\n+  /* Unpack all the value fields from BP.  */\n+  unpack_value_fields (&bp, result);\n+\n+  /* Enter RESULT in the reader cache.  This will make RESULT\n+     available so that circular references in the rest of the tree\n+     structure can be resolved in subsequent calls to lto_input_tree.  */\n+  lto_streamer_cache_append (data_in->reader_cache, result);\n+\n+  return result;\n+}\n+\n+\n+/* Read all pointer fields in the TS_COMMON structure of EXPR from input\n+   block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+\n+static void\n+lto_input_ts_common_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t   struct data_in *data_in, tree expr)\n+{\n+  if (TREE_CODE (expr) != IDENTIFIER_NODE)\n+    TREE_TYPE (expr) = lto_input_tree (ib, data_in);\n+}\n+\n+\n+/* Read all pointer fields in the TS_VECTOR structure of EXPR from input\n+   block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+static void\n+lto_input_ts_vector_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t   struct data_in *data_in, tree expr)\n+{\n+  TREE_VECTOR_CST_ELTS (expr) = lto_input_chain (ib, data_in);\n+}\n+\n+\n+/* Read all pointer fields in the TS_COMPLEX structure of EXPR from input\n+   block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+static void\n+lto_input_ts_complex_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t    struct data_in *data_in, tree expr)\n+{\n+  TREE_REALPART (expr) = lto_input_tree (ib, data_in);\n+  TREE_IMAGPART (expr) = lto_input_tree (ib, data_in);\n+}\n+\n+\n+/* Read all pointer fields in the TS_DECL_MINIMAL structure of EXPR\n+   from input block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+static void\n+lto_input_ts_decl_minimal_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t\t struct data_in *data_in, tree expr)\n+{\n+  DECL_NAME (expr) = lto_input_tree (ib, data_in);\n+  DECL_CONTEXT (expr) = lto_input_tree (ib, data_in);\n+  DECL_SOURCE_LOCATION (expr) = lto_input_location (ib, data_in);\n+}\n+\n+\n+/* Read all pointer fields in the TS_DECL_COMMON structure of EXPR from\n+   input block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+static void\n+lto_input_ts_decl_common_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t\tstruct data_in *data_in, tree expr)\n+{\n+  DECL_SIZE (expr) = lto_input_tree (ib, data_in);\n+  DECL_SIZE_UNIT (expr) = lto_input_tree (ib, data_in);\n+  DECL_ATTRIBUTES (expr) = lto_input_tree (ib, data_in);\n+\n+  /* Do not stream DECL_ABSTRACT_ORIGIN.  We cannot handle debug information\n+     for early inlining so drop it on the floor instead of ICEing in\n+     dwarf2out.c.  */\n+\n+  if (TREE_CODE (expr) == PARM_DECL)\n+    TREE_CHAIN (expr) = lto_input_chain (ib, data_in);\n+\n+  if ((TREE_CODE (expr) == VAR_DECL\n+       || TREE_CODE (expr) == PARM_DECL)\n+      && DECL_HAS_VALUE_EXPR_P (expr))\n+    SET_DECL_VALUE_EXPR (expr, lto_input_tree (ib, data_in));\n+\n+  if (TREE_CODE (expr) == VAR_DECL)\n+    {\n+      tree dexpr = lto_input_tree (ib, data_in);\n+      if (dexpr)\n+\tSET_DECL_DEBUG_EXPR (expr, dexpr);\n+    }\n+}\n+\n+\n+/* Read all pointer fields in the TS_DECL_NON_COMMON structure of\n+   EXPR from input block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+static void\n+lto_input_ts_decl_non_common_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t\t    struct data_in *data_in, tree expr)\n+{\n+  if (TREE_CODE (expr) == FUNCTION_DECL)\n+    {\n+      DECL_ARGUMENTS (expr) = lto_input_tree (ib, data_in);\n+      DECL_RESULT (expr) = lto_input_tree (ib, data_in);\n+    }\n+  DECL_VINDEX (expr) = lto_input_tree (ib, data_in);\n+}\n+\n+\n+/* Read all pointer fields in the TS_DECL_WITH_VIS structure of EXPR\n+   from input block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+static void\n+lto_input_ts_decl_with_vis_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t          struct data_in *data_in, tree expr)\n+{\n+  tree id;\n+\n+  id = lto_input_tree (ib, data_in);\n+  if (id)\n+    {\n+      gcc_assert (TREE_CODE (id) == IDENTIFIER_NODE);\n+      SET_DECL_ASSEMBLER_NAME (expr, id);\n+    }\n+\n+  DECL_SECTION_NAME (expr) = lto_input_tree (ib, data_in);\n+  DECL_COMDAT_GROUP (expr) = lto_input_tree (ib, data_in);\n+}\n+\n+\n+/* Read all pointer fields in the TS_FIELD_DECL structure of EXPR from\n+   input block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+static void\n+lto_input_ts_field_decl_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t       struct data_in *data_in, tree expr)\n+{\n+  DECL_FIELD_OFFSET (expr) = lto_input_tree (ib, data_in);\n+  DECL_BIT_FIELD_TYPE (expr) = lto_input_tree (ib, data_in);\n+  DECL_QUALIFIER (expr) = lto_input_tree (ib, data_in);\n+  DECL_FIELD_BIT_OFFSET (expr) = lto_input_tree (ib, data_in);\n+  DECL_FCONTEXT (expr) = lto_input_tree (ib, data_in);\n+  TREE_CHAIN (expr) = lto_input_chain (ib, data_in);\n+}\n+\n+\n+/* Read all pointer fields in the TS_FUNCTION_DECL structure of EXPR\n+   from input block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+static void\n+lto_input_ts_function_decl_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t\t  struct data_in *data_in, tree expr)\n+{\n+  /* DECL_STRUCT_FUNCTION is handled by lto_input_function.  FIXME lto,\n+     maybe it should be handled here?  */\n+  DECL_FUNCTION_PERSONALITY (expr) = lto_input_tree (ib, data_in);\n+  DECL_FUNCTION_SPECIFIC_TARGET (expr) = lto_input_tree (ib, data_in);\n+  DECL_FUNCTION_SPECIFIC_OPTIMIZATION (expr) = lto_input_tree (ib, data_in);\n+\n+  /* If the file contains a function with an EH personality set,\n+     then it was compiled with -fexceptions.  In that case, initialize\n+     the backend EH machinery.  */\n+  if (DECL_FUNCTION_PERSONALITY (expr))\n+    lto_init_eh ();\n+}\n+\n+\n+/* Read all pointer fields in the TS_TYPE_COMMON structure of EXPR from\n+   input block IB.  DATA_IN contains tables and descriptors for the file\n+   being read.  */\n+\n+static void\n+lto_input_ts_type_common_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t\tstruct data_in *data_in, tree expr)\n+{\n+  TYPE_SIZE (expr) = lto_input_tree (ib, data_in);\n+  TYPE_SIZE_UNIT (expr) = lto_input_tree (ib, data_in);\n+  TYPE_ATTRIBUTES (expr) = lto_input_tree (ib, data_in);\n+  TYPE_NAME (expr) = lto_input_tree (ib, data_in);\n+  /* Do not stream TYPE_POINTER_TO or TYPE_REFERENCE_TO.  They will be\n+     reconstructed during fixup.  */\n+  /* Do not stream TYPE_NEXT_VARIANT, we reconstruct the variant lists\n+     during fixup.  */\n+  TYPE_MAIN_VARIANT (expr) = lto_input_tree (ib, data_in);\n+  TYPE_CONTEXT (expr) = lto_input_tree (ib, data_in);\n+  /* TYPE_CANONICAL gets re-computed during type merging.  */\n+  TYPE_CANONICAL (expr) = NULL_TREE;\n+  TYPE_STUB_DECL (expr) = lto_input_tree (ib, data_in);\n+}\n+\n+/* Read all pointer fields in the TS_TYPE_NON_COMMON structure of EXPR\n+   from input block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+static void\n+lto_input_ts_type_non_common_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t\t    struct data_in *data_in,\n+\t\t\t\t\t    tree expr)\n+{\n+  if (TREE_CODE (expr) == ENUMERAL_TYPE)\n+    TYPE_VALUES (expr) = lto_input_tree (ib, data_in);\n+  else if (TREE_CODE (expr) == ARRAY_TYPE)\n+    TYPE_DOMAIN (expr) = lto_input_tree (ib, data_in);\n+  else if (RECORD_OR_UNION_TYPE_P (expr))\n+    TYPE_FIELDS (expr) = lto_input_tree (ib, data_in);\n+  else if (TREE_CODE (expr) == FUNCTION_TYPE\n+\t   || TREE_CODE (expr) == METHOD_TYPE)\n+    TYPE_ARG_TYPES (expr) = lto_input_tree (ib, data_in);\n+\n+  if (!POINTER_TYPE_P (expr))\n+    TYPE_MINVAL (expr) = lto_input_tree (ib, data_in);\n+  TYPE_MAXVAL (expr) = lto_input_tree (ib, data_in);\n+  if (RECORD_OR_UNION_TYPE_P (expr))\n+    TYPE_BINFO (expr) = lto_input_tree (ib, data_in);\n+}\n+\n+\n+/* Read all pointer fields in the TS_LIST structure of EXPR from input\n+   block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+static void\n+lto_input_ts_list_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t struct data_in *data_in, tree expr)\n+{\n+  TREE_PURPOSE (expr) = lto_input_tree (ib, data_in);\n+  TREE_VALUE (expr) = lto_input_tree (ib, data_in);\n+  TREE_CHAIN (expr) = lto_input_chain (ib, data_in);\n+}\n+\n+\n+/* Read all pointer fields in the TS_VEC structure of EXPR from input\n+   block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+static void\n+lto_input_ts_vec_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\tstruct data_in *data_in, tree expr)\n+{\n+  int i;\n+\n+  /* Note that TREE_VEC_LENGTH was read by lto_materialize_tree to\n+     instantiate EXPR.  */\n+  for (i = 0; i < TREE_VEC_LENGTH (expr); i++)\n+    TREE_VEC_ELT (expr, i) = lto_input_tree (ib, data_in);\n+}\n+\n+\n+/* Read all pointer fields in the TS_EXP structure of EXPR from input\n+   block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+\n+static void\n+lto_input_ts_exp_tree_pointers (struct lto_input_block *ib,\n+\t\t\t        struct data_in *data_in, tree expr)\n+{\n+  int i, length;\n+  location_t loc;\n+\n+  length = lto_input_sleb128 (ib);\n+  gcc_assert (length == TREE_OPERAND_LENGTH (expr));\n+\n+  for (i = 0; i < length; i++)\n+    TREE_OPERAND (expr, i) = lto_input_tree (ib, data_in);\n+\n+  loc = lto_input_location (ib, data_in);\n+  SET_EXPR_LOCATION (expr, loc);\n+  TREE_BLOCK (expr) = lto_input_tree (ib, data_in);\n+}\n+\n+\n+/* Read all pointer fields in the TS_BLOCK structure of EXPR from input\n+   block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+static void\n+lto_input_ts_block_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t  struct data_in *data_in, tree expr)\n+{\n+  /* Do not stream BLOCK_SOURCE_LOCATION.  We cannot handle debug information\n+     for early inlining so drop it on the floor instead of ICEing in\n+     dwarf2out.c.  */\n+  BLOCK_VARS (expr) = lto_input_chain (ib, data_in);\n+\n+  /* Do not stream BLOCK_NONLOCALIZED_VARS.  We cannot handle debug information\n+     for early inlining so drop it on the floor instead of ICEing in\n+     dwarf2out.c.  */\n+\n+  BLOCK_SUPERCONTEXT (expr) = lto_input_tree (ib, data_in);\n+\n+  /* Do not stream BLOCK_ABSTRACT_ORIGIN.  We cannot handle debug information\n+     for early inlining so drop it on the floor instead of ICEing in\n+     dwarf2out.c.  */\n+  BLOCK_FRAGMENT_ORIGIN (expr) = lto_input_tree (ib, data_in);\n+  BLOCK_FRAGMENT_CHAIN (expr) = lto_input_tree (ib, data_in);\n+\n+  /* We re-compute BLOCK_SUBBLOCKS of our parent here instead\n+     of streaming it.  For non-BLOCK BLOCK_SUPERCONTEXTs we still\n+     stream the child relationship explicitly.  */\n+  if (BLOCK_SUPERCONTEXT (expr)\n+      && TREE_CODE (BLOCK_SUPERCONTEXT (expr)) == BLOCK)\n+    {\n+      BLOCK_CHAIN (expr) = BLOCK_SUBBLOCKS (BLOCK_SUPERCONTEXT (expr));\n+      BLOCK_SUBBLOCKS (BLOCK_SUPERCONTEXT (expr)) = expr;\n+    }\n+\n+  /* The global block is rooted at the TU decl.  Hook it here to\n+     avoid the need to stream in this block during WPA time.  */\n+  else if (BLOCK_SUPERCONTEXT (expr)\n+\t   && TREE_CODE (BLOCK_SUPERCONTEXT (expr)) == TRANSLATION_UNIT_DECL)\n+    DECL_INITIAL (BLOCK_SUPERCONTEXT (expr)) = expr;\n+\n+  /* The function-level block is connected at the time we read in\n+     function bodies for the same reason.  */\n+}\n+\n+\n+/* Read all pointer fields in the TS_BINFO structure of EXPR from input\n+   block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+static void\n+lto_input_ts_binfo_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t  struct data_in *data_in, tree expr)\n+{\n+  unsigned i, len;\n+  tree t;\n+\n+  /* Note that the number of slots in EXPR was read in\n+     lto_materialize_tree when instantiating EXPR.  However, the\n+     vector is empty so we cannot rely on VEC_length to know how many\n+     elements to read.  So, this list is emitted as a 0-terminated\n+     list on the writer side.  */\n+  do\n+    {\n+      t = lto_input_tree (ib, data_in);\n+      if (t)\n+\tVEC_quick_push (tree, BINFO_BASE_BINFOS (expr), t);\n+    }\n+  while (t);\n+\n+  BINFO_OFFSET (expr) = lto_input_tree (ib, data_in);\n+  BINFO_VTABLE (expr) = lto_input_tree (ib, data_in);\n+  BINFO_VIRTUALS (expr) = lto_input_tree (ib, data_in);\n+  BINFO_VPTR_FIELD (expr) = lto_input_tree (ib, data_in);\n+\n+  len = lto_input_uleb128 (ib);\n+  if (len > 0)\n+    {\n+      VEC_reserve_exact (tree, gc, BINFO_BASE_ACCESSES (expr), len);\n+      for (i = 0; i < len; i++)\n+\t{\n+\t  tree a = lto_input_tree (ib, data_in);\n+\t  VEC_quick_push (tree, BINFO_BASE_ACCESSES (expr), a);\n+\t}\n+    }\n+\n+  BINFO_INHERITANCE_CHAIN (expr) = lto_input_tree (ib, data_in);\n+  BINFO_SUBVTT_INDEX (expr) = lto_input_tree (ib, data_in);\n+  BINFO_VPTR_INDEX (expr) = lto_input_tree (ib, data_in);\n+}\n+\n+\n+/* Read all pointer fields in the TS_CONSTRUCTOR structure of EXPR from\n+   input block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+static void\n+lto_input_ts_constructor_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t        struct data_in *data_in, tree expr)\n+{\n+  unsigned i, len;\n+\n+  len = lto_input_uleb128 (ib);\n+  for (i = 0; i < len; i++)\n+    {\n+      tree index, value;\n+\n+      index = lto_input_tree (ib, data_in);\n+      value = lto_input_tree (ib, data_in);\n+      CONSTRUCTOR_APPEND_ELT (CONSTRUCTOR_ELTS (expr), index, value);\n+    }\n+}\n+\n+\n+/* Input a TS_TARGET_OPTION tree from IB into EXPR.  */\n+\n+static void\n+lto_input_ts_target_option (struct lto_input_block *ib, tree expr)\n+{\n+  unsigned i, len;\n+  struct bitpack_d bp;\n+  struct cl_target_option *t = TREE_TARGET_OPTION (expr);\n+\n+  bp = lto_input_bitpack (ib);\n+  len = sizeof (struct cl_target_option);\n+  for (i = 0; i < len; i++)\n+    ((unsigned char *)t)[i] = bp_unpack_value (&bp, 8);\n+  if (bp_unpack_value (&bp, 32) != 0x12345678)\n+    fatal_error (\"cl_target_option size mismatch in LTO reader and writer\");\n+}\n+\n+/* Input a TS_TRANSLATION_UNIT_DECL tree from IB and DATA_IN into EXPR.  */\n+\n+static void\n+lto_input_ts_translation_unit_decl_tree_pointers (struct lto_input_block *ib,\n+\t\t\t\t\t\t  struct data_in *data_in,\n+\t\t\t\t\t\t  tree expr)\n+{\n+  TRANSLATION_UNIT_LANGUAGE (expr) = xstrdup (lto_input_string (data_in, ib));\n+  VEC_safe_push (tree, gc, all_translation_units, expr);\n+}\n+\n+/* Helper for lto_input_tree.  Read all pointer fields in EXPR from\n+   input block IB.  DATA_IN contains tables and descriptors for the\n+   file being read.  */\n+\n+static void\n+lto_input_tree_pointers (struct lto_input_block *ib, struct data_in *data_in,\n+\t\t\t tree expr)\n+{\n+  enum tree_code code;\n+\n+  code = TREE_CODE (expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPED))\n+    lto_input_ts_common_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_VECTOR))\n+    lto_input_ts_vector_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_COMPLEX))\n+    lto_input_ts_complex_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_MINIMAL))\n+    lto_input_ts_decl_minimal_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n+    lto_input_ts_decl_common_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_NON_COMMON))\n+    lto_input_ts_decl_non_common_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n+    lto_input_ts_decl_with_vis_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_FIELD_DECL))\n+    lto_input_ts_field_decl_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_FUNCTION_DECL))\n+    lto_input_ts_function_decl_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_COMMON))\n+    lto_input_ts_type_common_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_NON_COMMON))\n+    lto_input_ts_type_non_common_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_LIST))\n+    lto_input_ts_list_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_VEC))\n+    lto_input_ts_vec_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_EXP))\n+    lto_input_ts_exp_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_BLOCK))\n+    lto_input_ts_block_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_BINFO))\n+    lto_input_ts_binfo_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_CONSTRUCTOR))\n+    lto_input_ts_constructor_tree_pointers (ib, data_in, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TARGET_OPTION))\n+    lto_input_ts_target_option (ib, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TRANSLATION_UNIT_DECL))\n+    lto_input_ts_translation_unit_decl_tree_pointers (ib, data_in, expr);\n+}\n+\n+\n+/* Read the physical representation of a tree node with tag TAG from\n+   input block IB using the per-file context in DATA_IN.  */\n+\n+static tree\n+lto_read_tree (struct lto_input_block *ib, struct data_in *data_in,\n+\t       enum LTO_tags tag)\n+{\n+  tree result;\n+\n+  result = lto_materialize_tree (ib, data_in, tag);\n+\n+  /* Read all the pointer fields in RESULT.  */\n+  lto_input_tree_pointers (ib, data_in, result);\n+\n+  /* Call back into the streaming module to read anything else it\n+     may need.  */\n+  if (streamer_hooks.read_tree)\n+    streamer_hooks.read_tree (ib, data_in, result);\n+\n+  /* We should never try to instantiate an MD or NORMAL builtin here.  */\n+  if (TREE_CODE (result) == FUNCTION_DECL)\n+    gcc_assert (!lto_stream_as_builtin_p (result));\n+\n+  /* end_marker = */ lto_input_1_unsigned (ib);\n+\n+#ifdef LTO_STREAMER_DEBUG\n+  /* Remove the mapping to RESULT's original address set by\n+     lto_materialize_tree.  */\n+  lto_orig_address_remove (result);\n+#endif\n+\n+  return result;\n+}\n+\n+\n+/* Read and INTEGER_CST node from input block IB using the per-file\n+   context in DATA_IN.  */\n+\n+static tree\n+lto_input_integer_cst (struct lto_input_block *ib, struct data_in *data_in)\n+{\n+  tree result, type;\n+  HOST_WIDE_INT low, high;\n+  bool overflow_p;\n+\n+  type = lto_input_tree (ib, data_in);\n+  overflow_p = (lto_input_1_unsigned (ib) != 0);\n+  low = lto_input_uleb128 (ib);\n+  high = lto_input_uleb128 (ib);\n+  result = build_int_cst_wide (type, low, high);\n+\n+  /* If the original constant had overflown, build a replica of RESULT to\n+     avoid modifying the shared constant returned by build_int_cst_wide.  */\n+  if (overflow_p)\n+    {\n+      result = copy_node (result);\n+      TREE_OVERFLOW (result) = 1;\n+    }\n+\n+  return result;\n+}\n+\n+\n+/* Read an index IX from input block IB and return the tree node at\n+   DATA_IN->FILE_DATA->GLOBALS_INDEX[IX].  */\n+\n+static tree\n+lto_get_pickled_tree (struct lto_input_block *ib, struct data_in *data_in)\n+{\n+  unsigned HOST_WIDE_INT ix;\n+  tree result;\n+  enum LTO_tags expected_tag;\n+\n+  ix = lto_input_uleb128 (ib);\n+  expected_tag = lto_input_enum (ib, LTO_tags, LTO_NUM_TAGS);\n+\n+  result = lto_streamer_cache_get (data_in->reader_cache, ix);\n+  gcc_assert (result\n+              && TREE_CODE (result) == lto_tag_to_tree_code (expected_tag));\n+\n+  return result;\n+}\n+\n+\n+/* Read a code and class from input block IB and return the\n+   corresponding builtin.  DATA_IN is as in lto_input_tree.  */\n+\n+static tree\n+lto_get_builtin_tree (struct lto_input_block *ib, struct data_in *data_in)\n+{\n+  enum built_in_class fclass;\n+  enum built_in_function fcode;\n+  const char *asmname;\n+  tree result;\n+\n+  fclass = lto_input_enum (ib, built_in_class, BUILT_IN_LAST);\n+  gcc_assert (fclass == BUILT_IN_NORMAL || fclass == BUILT_IN_MD);\n+\n+  fcode = (enum built_in_function) lto_input_uleb128 (ib);\n+\n+  if (fclass == BUILT_IN_NORMAL)\n+    {\n+      if (fcode >= END_BUILTINS)\n+\tfatal_error (\"machine independent builtin code out of range\");\n+      result = built_in_decls[fcode];\n+      gcc_assert (result);\n+    }\n+  else if (fclass == BUILT_IN_MD)\n+    {\n+      result = targetm.builtin_decl (fcode, true);\n+      if (!result || result == error_mark_node)\n+\tfatal_error (\"target specific builtin not available\");\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  asmname = lto_input_string (data_in, ib);\n+  if (asmname)\n+    set_builtin_user_assembler_name (result, asmname);\n+\n+  lto_streamer_cache_append (data_in->reader_cache, result);\n+\n+  return result;\n+}\n+\n+\n+/* Read a tree from input block IB using the per-file context in\n+   DATA_IN.  This context is used, for example, to resolve references\n+   to previously read nodes.  */\n+\n+tree\n+lto_input_tree (struct lto_input_block *ib, struct data_in *data_in)\n+{\n+  enum LTO_tags tag;\n+  tree result;\n+\n+  tag = input_record_start (ib);\n+  gcc_assert ((unsigned) tag < (unsigned) LTO_NUM_TAGS);\n+\n+  if (tag == LTO_null)\n+    result = NULL_TREE;\n+  else if (tag >= LTO_field_decl_ref && tag <= LTO_global_decl_ref)\n+    {\n+      /* If TAG is a reference to an indexable tree, the next value\n+\t in IB is the index into the table where we expect to find\n+\t that tree.  */\n+      result = lto_input_tree_ref (ib, data_in, cfun, tag);\n+    }\n+  else if (tag == LTO_tree_pickle_reference)\n+    {\n+      /* If TAG is a reference to a previously read tree, look it up in\n+\t the reader cache.  */\n+      result = lto_get_pickled_tree (ib, data_in);\n+    }\n+  else if (tag == LTO_builtin_decl)\n+    {\n+      /* If we are going to read a built-in function, all we need is\n+\t the code and class.  */\n+      result = lto_get_builtin_tree (ib, data_in);\n+    }\n+  else if (tag == lto_tree_code_to_tag (INTEGER_CST))\n+    {\n+      /* For integer constants we only need the type and its hi/low\n+\t words.  */\n+      result = lto_input_integer_cst (ib, data_in);\n+    }\n+  else\n+    {\n+      /* Otherwise, materialize a new node from IB.  */\n+      result = lto_read_tree (ib, data_in, tag);\n+    }\n+\n+  return result;\n+}"}, {"sha": "ace84307a52f11767322f0de8721611cb97e74e2", "filename": "gcc/tree-streamer-out.c", "status": "added", "additions": 1045, "deletions": 0, "changes": 1045, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Ftree-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Ftree-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-out.c?ref=f0efc7aa7705facdb16a39a08137cf748c7d5f30", "patch": "@@ -0,0 +1,1045 @@\n+/* Routines for emitting trees to a file stream.\n+\n+   Copyright 2011 Free Software Foundation, Inc.\n+   Contributed by Diego Novillo <dnovillo@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"diagnostic.h\"\n+#include \"tree.h\"\n+#include \"tree-streamer.h\"\n+#include \"data-streamer.h\"\n+#include \"streamer-hooks.h\"\n+\n+/* Output the STRING constant to the string\n+   table in OB.  Then put the index onto the INDEX_STREAM.  */\n+\n+static void\n+output_string_cst (struct output_block *ob,\n+\t\t   struct lto_output_stream *index_stream,\n+\t\t   tree string)\n+{\n+  lto_output_string_with_length (ob, index_stream,\n+\t\t\t\t TREE_STRING_POINTER (string),\n+\t\t\t\t TREE_STRING_LENGTH (string),\n+\t\t\t\t true);\n+}\n+\n+\n+/* Output the identifier ID to the string\n+   table in OB.  Then put the index onto the INDEX_STREAM.  */\n+\n+static void\n+output_identifier (struct output_block *ob,\n+\t\t   struct lto_output_stream *index_stream,\n+\t\t   tree id)\n+{\n+  lto_output_string_with_length (ob, index_stream,\n+\t\t\t\t IDENTIFIER_POINTER (id),\n+\t\t\t\t IDENTIFIER_LENGTH (id),\n+\t\t\t\t true);\n+}\n+\n+\n+/* Pack all the non-pointer fields of the TS_BASE structure of\n+   expression EXPR into bitpack BP.  */\n+\n+static void\n+pack_ts_base_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  bp_pack_value (bp, TREE_CODE (expr), 16);\n+  if (!TYPE_P (expr))\n+    {\n+      bp_pack_value (bp, TREE_SIDE_EFFECTS (expr), 1);\n+      bp_pack_value (bp, TREE_CONSTANT (expr), 1);\n+      bp_pack_value (bp, TREE_READONLY (expr), 1);\n+\n+      /* TREE_PUBLIC is used on types to indicate that the type\n+\t has a TYPE_CACHED_VALUES vector.  This is not streamed out,\n+\t so we skip it here.  */\n+      bp_pack_value (bp, TREE_PUBLIC (expr), 1);\n+    }\n+  else\n+    bp_pack_value (bp, 0, 4);\n+  bp_pack_value (bp, TREE_ADDRESSABLE (expr), 1);\n+  bp_pack_value (bp, TREE_THIS_VOLATILE (expr), 1);\n+  if (DECL_P (expr))\n+    bp_pack_value (bp, DECL_UNSIGNED (expr), 1);\n+  else if (TYPE_P (expr))\n+    bp_pack_value (bp, TYPE_UNSIGNED (expr), 1);\n+  else\n+    bp_pack_value (bp, 0, 1);\n+  /* We write debug info two times, do not confuse the second one.  */\n+  bp_pack_value (bp, TYPE_P (expr) ? 0 : TREE_ASM_WRITTEN (expr), 1);\n+  if (TYPE_P (expr))\n+    bp_pack_value (bp, TYPE_ARTIFICIAL (expr), 1);\n+  else\n+    bp_pack_value (bp, TREE_NO_WARNING (expr), 1);\n+  bp_pack_value (bp, TREE_USED (expr), 1);\n+  bp_pack_value (bp, TREE_NOTHROW (expr), 1);\n+  bp_pack_value (bp, TREE_STATIC (expr), 1);\n+  bp_pack_value (bp, TREE_PRIVATE (expr), 1);\n+  bp_pack_value (bp, TREE_PROTECTED (expr), 1);\n+  bp_pack_value (bp, TREE_DEPRECATED (expr), 1);\n+  if (TYPE_P (expr))\n+    bp_pack_value (bp, TYPE_SATURATING (expr), 1);\n+  else if (TREE_CODE (expr) == SSA_NAME)\n+    bp_pack_value (bp, SSA_NAME_IS_DEFAULT_DEF (expr), 1);\n+  else\n+    bp_pack_value (bp, 0, 1);\n+}\n+\n+\n+/* Pack all the non-pointer fields of the TS_REAL_CST structure of\n+   expression EXPR into bitpack BP.  */\n+\n+static void\n+pack_ts_real_cst_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  unsigned i;\n+  REAL_VALUE_TYPE r;\n+\n+  r = TREE_REAL_CST (expr);\n+  bp_pack_value (bp, r.cl, 2);\n+  bp_pack_value (bp, r.decimal, 1);\n+  bp_pack_value (bp, r.sign, 1);\n+  bp_pack_value (bp, r.signalling, 1);\n+  bp_pack_value (bp, r.canonical, 1);\n+  bp_pack_value (bp, r.uexp, EXP_BITS);\n+  for (i = 0; i < SIGSZ; i++)\n+    bp_pack_value (bp, r.sig[i], HOST_BITS_PER_LONG);\n+}\n+\n+\n+/* Pack all the non-pointer fields of the TS_FIXED_CST structure of\n+   expression EXPR into bitpack BP.  */\n+\n+static void\n+pack_ts_fixed_cst_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  struct fixed_value fv = TREE_FIXED_CST (expr);\n+  bp_pack_enum (bp, machine_mode, MAX_MACHINE_MODE, fv.mode);\n+  bp_pack_var_len_int (bp, fv.data.low);\n+  bp_pack_var_len_int (bp, fv.data.high);\n+}\n+\n+\n+/* Pack all the non-pointer fields of the TS_DECL_COMMON structure\n+   of expression EXPR into bitpack BP.  */\n+\n+static void\n+pack_ts_decl_common_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  bp_pack_enum (bp, machine_mode, MAX_MACHINE_MODE, DECL_MODE (expr));\n+  bp_pack_value (bp, DECL_NONLOCAL (expr), 1);\n+  bp_pack_value (bp, DECL_VIRTUAL_P (expr), 1);\n+  bp_pack_value (bp, DECL_IGNORED_P (expr), 1);\n+  bp_pack_value (bp, DECL_ABSTRACT (expr), 1);\n+  bp_pack_value (bp, DECL_ARTIFICIAL (expr), 1);\n+  bp_pack_value (bp, DECL_USER_ALIGN (expr), 1);\n+  bp_pack_value (bp, DECL_PRESERVE_P (expr), 1);\n+  bp_pack_value (bp, DECL_DEBUG_EXPR_IS_FROM (expr), 1);\n+  bp_pack_value (bp, DECL_EXTERNAL (expr), 1);\n+  bp_pack_value (bp, DECL_GIMPLE_REG_P (expr), 1);\n+  bp_pack_var_len_unsigned (bp, DECL_ALIGN (expr));\n+\n+  if (TREE_CODE (expr) == LABEL_DECL)\n+    {\n+      /* Note that we do not write LABEL_DECL_UID.  The reader will\n+\t always assume an initial value of -1 so that the\n+\t label_to_block_map is recreated by gimple_set_bb.  */\n+      bp_pack_value (bp, DECL_ERROR_ISSUED (expr), 1);\n+      bp_pack_var_len_unsigned (bp, EH_LANDING_PAD_NR (expr));\n+    }\n+\n+  if (TREE_CODE (expr) == FIELD_DECL)\n+    {\n+      bp_pack_value (bp, DECL_PACKED (expr), 1);\n+      bp_pack_value (bp, DECL_NONADDRESSABLE_P (expr), 1);\n+      bp_pack_value (bp, expr->decl_common.off_align, 8);\n+    }\n+\n+  if (TREE_CODE (expr) == RESULT_DECL\n+      || TREE_CODE (expr) == PARM_DECL\n+      || TREE_CODE (expr) == VAR_DECL)\n+    {\n+      bp_pack_value (bp, DECL_BY_REFERENCE (expr), 1);\n+      if (TREE_CODE (expr) == VAR_DECL\n+\t  || TREE_CODE (expr) == PARM_DECL)\n+\tbp_pack_value (bp, DECL_HAS_VALUE_EXPR_P (expr), 1);\n+      bp_pack_value (bp, DECL_RESTRICTED_P (expr), 1);\n+    }\n+}\n+\n+\n+/* Pack all the non-pointer fields of the TS_DECL_WRTL structure\n+   of expression EXPR into bitpack BP.  */\n+\n+static void\n+pack_ts_decl_wrtl_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  bp_pack_value (bp, DECL_REGISTER (expr), 1);\n+}\n+\n+\n+/* Pack all the non-pointer fields of the TS_DECL_WITH_VIS structure\n+   of expression EXPR into bitpack BP.  */\n+\n+static void\n+pack_ts_decl_with_vis_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  bp_pack_value (bp, DECL_DEFER_OUTPUT (expr), 1);\n+  bp_pack_value (bp, DECL_COMMON (expr), 1);\n+  bp_pack_value (bp, DECL_DLLIMPORT_P (expr), 1);\n+  bp_pack_value (bp, DECL_WEAK (expr), 1);\n+  bp_pack_value (bp, DECL_SEEN_IN_BIND_EXPR_P (expr),  1);\n+  bp_pack_value (bp, DECL_COMDAT (expr),  1);\n+  bp_pack_value (bp, DECL_VISIBILITY (expr),  2);\n+  bp_pack_value (bp, DECL_VISIBILITY_SPECIFIED (expr),  1);\n+\n+  if (TREE_CODE (expr) == VAR_DECL)\n+    {\n+      bp_pack_value (bp, DECL_HARD_REGISTER (expr), 1);\n+      bp_pack_value (bp, DECL_IN_TEXT_SECTION (expr), 1);\n+      bp_pack_value (bp, DECL_IN_CONSTANT_POOL (expr), 1);\n+      bp_pack_value (bp, DECL_TLS_MODEL (expr),  3);\n+    }\n+\n+  if (VAR_OR_FUNCTION_DECL_P (expr))\n+    bp_pack_var_len_unsigned (bp, DECL_INIT_PRIORITY (expr));\n+}\n+\n+\n+/* Pack all the non-pointer fields of the TS_FUNCTION_DECL structure\n+   of expression EXPR into bitpack BP.  */\n+\n+static void\n+pack_ts_function_decl_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  /* For normal/md builtins we only write the class and code, so they\n+     should never be handled here.  */\n+  gcc_assert (!lto_stream_as_builtin_p (expr));\n+\n+  bp_pack_enum (bp, built_in_class, BUILT_IN_LAST,\n+\t\tDECL_BUILT_IN_CLASS (expr));\n+  bp_pack_value (bp, DECL_STATIC_CONSTRUCTOR (expr), 1);\n+  bp_pack_value (bp, DECL_STATIC_DESTRUCTOR (expr), 1);\n+  bp_pack_value (bp, DECL_UNINLINABLE (expr), 1);\n+  bp_pack_value (bp, DECL_POSSIBLY_INLINED (expr), 1);\n+  bp_pack_value (bp, DECL_IS_NOVOPS (expr), 1);\n+  bp_pack_value (bp, DECL_IS_RETURNS_TWICE (expr), 1);\n+  bp_pack_value (bp, DECL_IS_MALLOC (expr), 1);\n+  bp_pack_value (bp, DECL_IS_OPERATOR_NEW (expr), 1);\n+  bp_pack_value (bp, DECL_DECLARED_INLINE_P (expr), 1);\n+  bp_pack_value (bp, DECL_STATIC_CHAIN (expr), 1);\n+  bp_pack_value (bp, DECL_NO_INLINE_WARNING_P (expr), 1);\n+  bp_pack_value (bp, DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (expr), 1);\n+  bp_pack_value (bp, DECL_NO_LIMIT_STACK (expr), 1);\n+  bp_pack_value (bp, DECL_DISREGARD_INLINE_LIMITS (expr), 1);\n+  bp_pack_value (bp, DECL_PURE_P (expr), 1);\n+  bp_pack_value (bp, DECL_LOOPING_CONST_OR_PURE_P (expr), 1);\n+  if (DECL_BUILT_IN_CLASS (expr) != NOT_BUILT_IN)\n+    bp_pack_value (bp, DECL_FUNCTION_CODE (expr), 11);\n+  if (DECL_STATIC_DESTRUCTOR (expr))\n+    bp_pack_var_len_unsigned (bp, DECL_FINI_PRIORITY (expr));\n+}\n+\n+\n+/* Pack all the non-pointer fields of the TS_TYPE_COMMON structure\n+   of expression EXPR into bitpack BP.  */\n+\n+static void\n+pack_ts_type_common_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  bp_pack_enum (bp, machine_mode, MAX_MACHINE_MODE, TYPE_MODE (expr));\n+  bp_pack_value (bp, TYPE_STRING_FLAG (expr), 1);\n+  bp_pack_value (bp, TYPE_NO_FORCE_BLK (expr), 1);\n+  bp_pack_value (bp, TYPE_NEEDS_CONSTRUCTING (expr), 1);\n+  if (RECORD_OR_UNION_TYPE_P (expr))\n+    bp_pack_value (bp, TYPE_TRANSPARENT_AGGR (expr), 1);\n+  bp_pack_value (bp, TYPE_PACKED (expr), 1);\n+  bp_pack_value (bp, TYPE_RESTRICT (expr), 1);\n+  bp_pack_value (bp, TYPE_CONTAINS_PLACEHOLDER_INTERNAL (expr), 2);\n+  bp_pack_value (bp, TYPE_USER_ALIGN (expr), 1);\n+  bp_pack_value (bp, TYPE_READONLY (expr), 1);\n+  bp_pack_var_len_unsigned (bp, TYPE_PRECISION (expr));\n+  bp_pack_var_len_unsigned (bp, TYPE_ALIGN (expr));\n+  bp_pack_var_len_int (bp, TYPE_ALIAS_SET (expr) == 0 ? 0 : -1);\n+}\n+\n+\n+/* Pack all the non-pointer fields of the TS_BLOCK structure\n+   of expression EXPR into bitpack BP.  */\n+\n+static void\n+pack_ts_block_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  bp_pack_value (bp, BLOCK_ABSTRACT (expr), 1);\n+  /* BLOCK_NUMBER is recomputed.  */\n+}\n+\n+/* Pack all the non-pointer fields of the TS_TRANSLATION_UNIT_DECL structure\n+   of expression EXPR into bitpack BP.  */\n+\n+static void\n+pack_ts_translation_unit_decl_value_fields (struct bitpack_d *bp ATTRIBUTE_UNUSED, tree expr ATTRIBUTE_UNUSED)\n+{\n+}\n+\n+/* Pack all the non-pointer fields in EXPR into a bit pack.  */\n+\n+static void\n+pack_value_fields (struct bitpack_d *bp, tree expr)\n+{\n+  enum tree_code code;\n+\n+  code = TREE_CODE (expr);\n+\n+  /* Note that all these functions are highly sensitive to changes in\n+     the types and sizes of each of the fields being packed.  */\n+  pack_ts_base_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_REAL_CST))\n+    pack_ts_real_cst_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_FIXED_CST))\n+    pack_ts_fixed_cst_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n+    pack_ts_decl_common_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WRTL))\n+    pack_ts_decl_wrtl_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n+    pack_ts_decl_with_vis_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_FUNCTION_DECL))\n+    pack_ts_function_decl_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_COMMON))\n+    pack_ts_type_common_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_BLOCK))\n+    pack_ts_block_value_fields (bp, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TRANSLATION_UNIT_DECL))\n+    pack_ts_translation_unit_decl_value_fields (bp, expr);\n+\n+  if (streamer_hooks.pack_value_fields)\n+    streamer_hooks.pack_value_fields (bp, expr);\n+}\n+\n+\n+/* If REF_P is true, emit a reference to EXPR in output block OB,\n+   otherwise emit the physical representation of EXPR in OB.  */\n+\n+static inline void\n+lto_output_tree_or_ref (struct output_block *ob, tree expr, bool ref_p)\n+{\n+  if (ref_p)\n+    lto_output_tree_ref (ob, expr);\n+  else\n+    lto_output_tree (ob, expr, false);\n+}\n+\n+\n+/* Write the code and class of builtin EXPR to output block OB.  IX is\n+   the index into the streamer cache where EXPR is stored.*/\n+\n+static void\n+lto_output_builtin_tree (struct output_block *ob, tree expr)\n+{\n+  gcc_assert (lto_stream_as_builtin_p (expr));\n+\n+  if (DECL_BUILT_IN_CLASS (expr) == BUILT_IN_MD\n+      && !targetm.builtin_decl)\n+    sorry (\"gimple bytecode streams do not support machine specific builtin \"\n+\t   \"functions on this target\");\n+\n+  output_record_start (ob, LTO_builtin_decl);\n+  lto_output_enum (ob->main_stream, built_in_class, BUILT_IN_LAST,\n+\t\t   DECL_BUILT_IN_CLASS (expr));\n+  output_uleb128 (ob, DECL_FUNCTION_CODE (expr));\n+\n+  if (DECL_ASSEMBLER_NAME_SET_P (expr))\n+    {\n+      /* When the assembler name of a builtin gets a user name,\n+\t the new name is always prefixed with '*' by\n+\t set_builtin_user_assembler_name.  So, to prevent the\n+\t reader side from adding a second '*', we omit it here.  */\n+      const char *str = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (expr));\n+      if (strlen (str) > 1 && str[0] == '*')\n+\tlto_output_string (ob, ob->main_stream, &str[1], true);\n+      else\n+\tlto_output_string (ob, ob->main_stream, NULL, true);\n+    }\n+  else\n+    lto_output_string (ob, ob->main_stream, NULL, true);\n+}\n+\n+\n+/* GIMPLE hook for writing GIMPLE-specific parts of trees.  OB, EXPR\n+   and REF_P are as in lto_write_tree.  */\n+\n+void\n+lto_streamer_write_tree (struct output_block *ob, tree expr, bool ref_p)\n+{\n+  if (DECL_P (expr)\n+      && TREE_CODE (expr) != FUNCTION_DECL\n+      && TREE_CODE (expr) != TRANSLATION_UNIT_DECL)\n+    {\n+      /* Handle DECL_INITIAL for symbols.  */\n+      tree initial = DECL_INITIAL (expr);\n+      if (TREE_CODE (expr) == VAR_DECL\n+\t  && (TREE_STATIC (expr) || DECL_EXTERNAL (expr))\n+\t  && initial)\n+\t{\n+\t  lto_varpool_encoder_t varpool_encoder;\n+\t  struct varpool_node *vnode;\n+\n+\t  varpool_encoder = ob->decl_state->varpool_node_encoder;\n+\t  vnode = varpool_get_node (expr);\n+\t  if (!vnode)\n+\t    initial = error_mark_node;\n+\t  else if (!lto_varpool_encoder_encode_initializer_p (varpool_encoder,\n+\t\t\t\t\t\t\t      vnode))\n+\t    initial = NULL;\n+\t}\n+\n+      lto_output_tree_or_ref (ob, initial, ref_p);\n+    }\n+}\n+\n+\n+/* Emit the chain of tree nodes starting at T.  OB is the output block\n+   to write to.  REF_P is true if chain elements should be emitted\n+   as references.  */\n+\n+static void\n+lto_output_chain (struct output_block *ob, tree t, bool ref_p)\n+{\n+  int i, count;\n+\n+  count = list_length (t);\n+  output_sleb128 (ob, count);\n+  for (i = 0; i < count; i++)\n+    {\n+      tree saved_chain;\n+\n+      /* Clear TREE_CHAIN to avoid blindly recursing into the rest\n+\t of the list.  */\n+      saved_chain = TREE_CHAIN (t);\n+      TREE_CHAIN (t) = NULL_TREE;\n+\n+      lto_output_tree_or_ref (ob, t, ref_p);\n+\n+      TREE_CHAIN (t) = saved_chain;\n+      t = TREE_CHAIN (t);\n+    }\n+}\n+\n+\n+/* Write all pointer fields in the TS_COMMON structure of EXPR to output\n+   block OB.  If REF_P is true, write a reference to EXPR's pointer\n+   fields.  */\n+\n+static void\n+lto_output_ts_common_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t    bool ref_p)\n+{\n+  if (TREE_CODE (expr) != IDENTIFIER_NODE)\n+    lto_output_tree_or_ref (ob, TREE_TYPE (expr), ref_p);\n+}\n+\n+\n+/* Write all pointer fields in the TS_VECTOR structure of EXPR to output\n+   block OB.  If REF_P is true, write a reference to EXPR's pointer\n+   fields.  */\n+\n+static void\n+lto_output_ts_vector_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t    bool ref_p)\n+{\n+  lto_output_chain (ob, TREE_VECTOR_CST_ELTS (expr), ref_p);\n+}\n+\n+\n+/* Write all pointer fields in the TS_COMPLEX structure of EXPR to output\n+   block OB.  If REF_P is true, write a reference to EXPR's pointer\n+   fields.  */\n+\n+static void\n+lto_output_ts_complex_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t     bool ref_p)\n+{\n+  lto_output_tree_or_ref (ob, TREE_REALPART (expr), ref_p);\n+  lto_output_tree_or_ref (ob, TREE_IMAGPART (expr), ref_p);\n+}\n+\n+\n+/* Write all pointer fields in the TS_DECL_MINIMAL structure of EXPR\n+   to output block OB.  If REF_P is true, write a reference to EXPR's\n+   pointer fields.  */\n+\n+static void\n+lto_output_ts_decl_minimal_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t\t  bool ref_p)\n+{\n+  lto_output_tree_or_ref (ob, DECL_NAME (expr), ref_p);\n+  lto_output_tree_or_ref (ob, DECL_CONTEXT (expr), ref_p);\n+  lto_output_location (ob, DECL_SOURCE_LOCATION (expr));\n+}\n+\n+\n+/* Write all pointer fields in the TS_DECL_COMMON structure of EXPR to\n+   output block OB.  If REF_P is true, write a reference to EXPR's\n+   pointer fields.  */\n+\n+static void\n+lto_output_ts_decl_common_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t\t bool ref_p)\n+{\n+  lto_output_tree_or_ref (ob, DECL_SIZE (expr), ref_p);\n+  lto_output_tree_or_ref (ob, DECL_SIZE_UNIT (expr), ref_p);\n+\n+  /* Note, DECL_INITIAL is not handled here.  Since DECL_INITIAL needs\n+     special handling in LTO, it must be handled by streamer hooks.  */\n+\n+  lto_output_tree_or_ref (ob, DECL_ATTRIBUTES (expr), ref_p);\n+\n+  /* Do not stream DECL_ABSTRACT_ORIGIN.  We cannot handle debug information\n+     for early inlining so drop it on the floor instead of ICEing in\n+     dwarf2out.c.  */\n+\n+  if (TREE_CODE (expr) == PARM_DECL)\n+    lto_output_chain (ob, TREE_CHAIN (expr), ref_p);\n+\n+  if ((TREE_CODE (expr) == VAR_DECL\n+       || TREE_CODE (expr) == PARM_DECL)\n+      && DECL_HAS_VALUE_EXPR_P (expr))\n+    lto_output_tree_or_ref (ob, DECL_VALUE_EXPR (expr), ref_p);\n+\n+  if (TREE_CODE (expr) == VAR_DECL)\n+    lto_output_tree_or_ref (ob, DECL_DEBUG_EXPR (expr), ref_p);\n+}\n+\n+\n+/* Write all pointer fields in the TS_DECL_NON_COMMON structure of\n+   EXPR to output block OB.  If REF_P is true, write a reference to EXPR's\n+   pointer fields.  */\n+\n+static void\n+lto_output_ts_decl_non_common_tree_pointers (struct output_block *ob,\n+\t\t\t\t\t     tree expr, bool ref_p)\n+{\n+  if (TREE_CODE (expr) == FUNCTION_DECL)\n+    {\n+      lto_output_tree_or_ref (ob, DECL_ARGUMENTS (expr), ref_p);\n+      lto_output_tree_or_ref (ob, DECL_RESULT (expr), ref_p);\n+    }\n+  lto_output_tree_or_ref (ob, DECL_VINDEX (expr), ref_p);\n+}\n+\n+\n+/* Write all pointer fields in the TS_DECL_WITH_VIS structure of EXPR\n+   to output block OB.  If REF_P is true, write a reference to EXPR's\n+   pointer fields.  */\n+\n+static void\n+lto_output_ts_decl_with_vis_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t\t   bool ref_p)\n+{\n+  /* Make sure we don't inadvertently set the assembler name.  */\n+  if (DECL_ASSEMBLER_NAME_SET_P (expr))\n+    lto_output_tree_or_ref (ob, DECL_ASSEMBLER_NAME (expr), ref_p);\n+  else\n+    output_record_start (ob, LTO_null);\n+\n+  lto_output_tree_or_ref (ob, DECL_SECTION_NAME (expr), ref_p);\n+  lto_output_tree_or_ref (ob, DECL_COMDAT_GROUP (expr), ref_p);\n+}\n+\n+\n+/* Write all pointer fields in the TS_FIELD_DECL structure of EXPR to\n+   output block OB.  If REF_P is true, write a reference to EXPR's\n+   pointer fields.  */\n+\n+static void\n+lto_output_ts_field_decl_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t\tbool ref_p)\n+{\n+  lto_output_tree_or_ref (ob, DECL_FIELD_OFFSET (expr), ref_p);\n+  lto_output_tree_or_ref (ob, DECL_BIT_FIELD_TYPE (expr), ref_p);\n+  lto_output_tree_or_ref (ob, DECL_QUALIFIER (expr), ref_p);\n+  lto_output_tree_or_ref (ob, DECL_FIELD_BIT_OFFSET (expr), ref_p);\n+  lto_output_tree_or_ref (ob, DECL_FCONTEXT (expr), ref_p);\n+  lto_output_chain (ob, TREE_CHAIN (expr), ref_p);\n+}\n+\n+\n+/* Write all pointer fields in the TS_FUNCTION_DECL structure of EXPR\n+   to output block OB.  If REF_P is true, write a reference to EXPR's\n+   pointer fields.  */\n+\n+static void\n+lto_output_ts_function_decl_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t\t   bool ref_p)\n+{\n+  /* DECL_STRUCT_FUNCTION is handled by lto_output_function.  FIXME lto,\n+     maybe it should be handled here?  */\n+  lto_output_tree_or_ref (ob, DECL_FUNCTION_PERSONALITY (expr), ref_p);\n+  lto_output_tree_or_ref (ob, DECL_FUNCTION_SPECIFIC_TARGET (expr), ref_p);\n+  lto_output_tree_or_ref (ob, DECL_FUNCTION_SPECIFIC_OPTIMIZATION (expr),\n+\t\t\t  ref_p);\n+}\n+\n+\n+/* Write all pointer fields in the TS_TYPE_COMMON structure of EXPR to\n+   output block OB.  If REF_P is true, write a reference to EXPR's\n+   pointer fields.  */\n+\n+static void\n+lto_output_ts_type_common_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t\t bool ref_p)\n+{\n+  lto_output_tree_or_ref (ob, TYPE_SIZE (expr), ref_p);\n+  lto_output_tree_or_ref (ob, TYPE_SIZE_UNIT (expr), ref_p);\n+  lto_output_tree_or_ref (ob, TYPE_ATTRIBUTES (expr), ref_p);\n+  lto_output_tree_or_ref (ob, TYPE_NAME (expr), ref_p);\n+  /* Do not stream TYPE_POINTER_TO or TYPE_REFERENCE_TO.  They will be\n+     reconstructed during fixup.  */\n+  /* Do not stream TYPE_NEXT_VARIANT, we reconstruct the variant lists\n+     during fixup.  */\n+  lto_output_tree_or_ref (ob, TYPE_MAIN_VARIANT (expr), ref_p);\n+  lto_output_tree_or_ref (ob, TYPE_CONTEXT (expr), ref_p);\n+  /* TYPE_CANONICAL is re-computed during type merging, so no need\n+     to stream it here.  */\n+  lto_output_tree_or_ref (ob, TYPE_STUB_DECL (expr), ref_p);\n+}\n+\n+/* Write all pointer fields in the TS_TYPE_NON_COMMON structure of EXPR\n+   to output block OB.  If REF_P is true, write a reference to EXPR's\n+   pointer fields.  */\n+\n+static void\n+lto_output_ts_type_non_common_tree_pointers (struct output_block *ob,\n+\t\t\t\t\t     tree expr, bool ref_p)\n+{\n+  if (TREE_CODE (expr) == ENUMERAL_TYPE)\n+    lto_output_tree_or_ref (ob, TYPE_VALUES (expr), ref_p);\n+  else if (TREE_CODE (expr) == ARRAY_TYPE)\n+    lto_output_tree_or_ref (ob, TYPE_DOMAIN (expr), ref_p);\n+  else if (RECORD_OR_UNION_TYPE_P (expr))\n+    lto_output_tree_or_ref (ob, TYPE_FIELDS (expr), ref_p);\n+  else if (TREE_CODE (expr) == FUNCTION_TYPE\n+\t   || TREE_CODE (expr) == METHOD_TYPE)\n+    lto_output_tree_or_ref (ob, TYPE_ARG_TYPES (expr), ref_p);\n+\n+  if (!POINTER_TYPE_P (expr))\n+    lto_output_tree_or_ref (ob, TYPE_MINVAL (expr), ref_p);\n+  lto_output_tree_or_ref (ob, TYPE_MAXVAL (expr), ref_p);\n+  if (RECORD_OR_UNION_TYPE_P (expr))\n+    lto_output_tree_or_ref (ob, TYPE_BINFO (expr), ref_p);\n+}\n+\n+\n+/* Write all pointer fields in the TS_LIST structure of EXPR to output\n+   block OB.  If REF_P is true, write a reference to EXPR's pointer\n+   fields.  */\n+\n+static void\n+lto_output_ts_list_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t  bool ref_p)\n+{\n+  lto_output_tree_or_ref (ob, TREE_PURPOSE (expr), ref_p);\n+  lto_output_tree_or_ref (ob, TREE_VALUE (expr), ref_p);\n+  lto_output_chain (ob, TREE_CHAIN (expr), ref_p);\n+}\n+\n+\n+/* Write all pointer fields in the TS_VEC structure of EXPR to output\n+   block OB.  If REF_P is true, write a reference to EXPR's pointer\n+   fields.  */\n+\n+static void\n+lto_output_ts_vec_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n+{\n+  int i;\n+\n+  /* Note that the number of slots for EXPR has already been emitted\n+     in EXPR's header (see lto_output_tree_header).  */\n+  for (i = 0; i < TREE_VEC_LENGTH (expr); i++)\n+    lto_output_tree_or_ref (ob, TREE_VEC_ELT (expr, i), ref_p);\n+}\n+\n+\n+/* Write all pointer fields in the TS_EXP structure of EXPR to output\n+   block OB.  If REF_P is true, write a reference to EXPR's pointer\n+   fields.  */\n+\n+static void\n+lto_output_ts_exp_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n+{\n+  int i;\n+\n+  output_sleb128 (ob, TREE_OPERAND_LENGTH (expr));\n+  for (i = 0; i < TREE_OPERAND_LENGTH (expr); i++)\n+    lto_output_tree_or_ref (ob, TREE_OPERAND (expr, i), ref_p);\n+  lto_output_location (ob, EXPR_LOCATION (expr));\n+  lto_output_tree_or_ref (ob, TREE_BLOCK (expr), ref_p);\n+}\n+\n+\n+/* Write all pointer fields in the TS_BLOCK structure of EXPR to output\n+   block OB.  If REF_P is true, write a reference to EXPR's pointer\n+   fields.  */\n+\n+static void\n+lto_output_ts_block_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t   bool ref_p)\n+{\n+  /* Do not stream BLOCK_SOURCE_LOCATION.  We cannot handle debug information\n+     for early inlining so drop it on the floor instead of ICEing in\n+     dwarf2out.c.  */\n+  lto_output_chain (ob, BLOCK_VARS (expr), ref_p);\n+\n+  /* Do not stream BLOCK_NONLOCALIZED_VARS.  We cannot handle debug information\n+     for early inlining so drop it on the floor instead of ICEing in\n+     dwarf2out.c.  */\n+\n+  lto_output_tree_or_ref (ob, BLOCK_SUPERCONTEXT (expr), ref_p);\n+  /* Do not stream BLOCK_ABSTRACT_ORIGIN.  We cannot handle debug information\n+     for early inlining so drop it on the floor instead of ICEing in\n+     dwarf2out.c.  */\n+  lto_output_tree_or_ref (ob, BLOCK_FRAGMENT_ORIGIN (expr), ref_p);\n+  lto_output_tree_or_ref (ob, BLOCK_FRAGMENT_CHAIN (expr), ref_p);\n+  /* Do not output BLOCK_SUBBLOCKS.  Instead on streaming-in this\n+     list is re-constructed from BLOCK_SUPERCONTEXT.  */\n+}\n+\n+\n+/* Write all pointer fields in the TS_BINFO structure of EXPR to output\n+   block OB.  If REF_P is true, write a reference to EXPR's pointer\n+   fields.  */\n+\n+static void\n+lto_output_ts_binfo_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t   bool ref_p)\n+{\n+  unsigned i;\n+  tree t;\n+\n+  /* Note that the number of BINFO slots has already been emitted in\n+     EXPR's header (see lto_output_tree_header) because this length\n+     is needed to build the empty BINFO node on the reader side.  */\n+  FOR_EACH_VEC_ELT (tree, BINFO_BASE_BINFOS (expr), i, t)\n+    lto_output_tree_or_ref (ob, t, ref_p);\n+  output_record_start (ob, LTO_null);\n+\n+  lto_output_tree_or_ref (ob, BINFO_OFFSET (expr), ref_p);\n+  lto_output_tree_or_ref (ob, BINFO_VTABLE (expr), ref_p);\n+  /* BINFO_VIRTUALS is used to drive type based devirtualizatoin.  It often links\n+     together large portions of programs making it harder to partition.  Becuase\n+     devirtualization is interesting before inlining, only, there is no real\n+     need to ship it into ltrans partition.  */\n+  lto_output_tree_or_ref (ob, flag_wpa ? NULL : BINFO_VIRTUALS (expr), ref_p);\n+  lto_output_tree_or_ref (ob, BINFO_VPTR_FIELD (expr), ref_p);\n+\n+  output_uleb128 (ob, VEC_length (tree, BINFO_BASE_ACCESSES (expr)));\n+  FOR_EACH_VEC_ELT (tree, BINFO_BASE_ACCESSES (expr), i, t)\n+    lto_output_tree_or_ref (ob, t, ref_p);\n+\n+  lto_output_tree_or_ref (ob, BINFO_INHERITANCE_CHAIN (expr), ref_p);\n+  lto_output_tree_or_ref (ob, BINFO_SUBVTT_INDEX (expr), ref_p);\n+  lto_output_tree_or_ref (ob, BINFO_VPTR_INDEX (expr), ref_p);\n+}\n+\n+\n+/* Write all pointer fields in the TS_CONSTRUCTOR structure of EXPR to\n+   output block OB.  If REF_P is true, write a reference to EXPR's\n+   pointer fields.  */\n+\n+static void\n+lto_output_ts_constructor_tree_pointers (struct output_block *ob, tree expr,\n+\t\t\t\t\t bool ref_p)\n+{\n+  unsigned i;\n+  tree index, value;\n+\n+  output_uleb128 (ob, CONSTRUCTOR_NELTS (expr));\n+  FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (expr), i, index, value)\n+    {\n+      lto_output_tree_or_ref (ob, index, ref_p);\n+      lto_output_tree_or_ref (ob, value, ref_p);\n+    }\n+}\n+\n+/* Write a TS_TARGET_OPTION tree in EXPR to OB.  */\n+\n+static void\n+lto_output_ts_target_option (struct output_block *ob, tree expr)\n+{\n+  struct cl_target_option *t = TREE_TARGET_OPTION (expr);\n+  struct bitpack_d bp;\n+  unsigned i, len;\n+\n+  /* The cl_target_option is target specific and generated by the options\n+     awk script, so we just recreate a byte-by-byte copy here. */\n+\n+  bp = bitpack_create (ob->main_stream);\n+  len = sizeof (struct cl_target_option);\n+  for (i = 0; i < len; i++)\n+    bp_pack_value (&bp, ((unsigned char *)t)[i], 8);\n+  /* Catch struct size mismatches between reader and writer. */\n+  bp_pack_value (&bp, 0x12345678, 32);\n+  lto_output_bitpack (&bp);\n+}\n+\n+/* Write a TS_TRANSLATION_UNIT_DECL tree in EXPR to OB.  */\n+\n+static void\n+lto_output_ts_translation_unit_decl_tree_pointers (struct output_block *ob,\n+\t\t\t\t\t\t   tree expr)\n+{\n+  lto_output_string (ob, ob->main_stream,\n+\t\t     TRANSLATION_UNIT_LANGUAGE (expr), true);\n+}\n+\n+/* Helper for lto_output_tree.  Write all pointer fields in EXPR to output\n+   block OB.  If REF_P is true, the leaves of EXPR are emitted as\n+   references.  */\n+\n+static void\n+lto_output_tree_pointers (struct output_block *ob, tree expr, bool ref_p)\n+{\n+  enum tree_code code;\n+\n+  code = TREE_CODE (expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPED))\n+    lto_output_ts_common_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_VECTOR))\n+    lto_output_ts_vector_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_COMPLEX))\n+    lto_output_ts_complex_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_MINIMAL))\n+    lto_output_ts_decl_minimal_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n+    lto_output_ts_decl_common_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_NON_COMMON))\n+    lto_output_ts_decl_non_common_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n+    lto_output_ts_decl_with_vis_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_FIELD_DECL))\n+    lto_output_ts_field_decl_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_FUNCTION_DECL))\n+    lto_output_ts_function_decl_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_COMMON))\n+    lto_output_ts_type_common_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_NON_COMMON))\n+    lto_output_ts_type_non_common_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_LIST))\n+    lto_output_ts_list_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_VEC))\n+    lto_output_ts_vec_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_EXP))\n+    lto_output_ts_exp_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_BLOCK))\n+    lto_output_ts_block_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_BINFO))\n+    lto_output_ts_binfo_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_CONSTRUCTOR))\n+    lto_output_ts_constructor_tree_pointers (ob, expr, ref_p);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TARGET_OPTION))\n+    lto_output_ts_target_option (ob, expr);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TRANSLATION_UNIT_DECL))\n+    lto_output_ts_translation_unit_decl_tree_pointers (ob, expr);\n+}\n+\n+\n+/* Emit header information for tree EXPR to output block OB.  The header\n+   contains everything needed to instantiate an empty skeleton for\n+   EXPR on the reading side.  IX is the index into the streamer cache\n+   where EXPR is stored.  REF_P is as in lto_output_tree.  */\n+\n+static void\n+lto_output_tree_header (struct output_block *ob, tree expr)\n+{\n+  enum LTO_tags tag;\n+  enum tree_code code;\n+\n+  /* We should not see any tree nodes not handled by the streamer.  */\n+  code = TREE_CODE (expr);\n+  if (!streamer_hooks.is_streamable (expr))\n+    internal_error (\"tree code %qs is not supported in %s streams\",\n+\t\t    tree_code_name[code], streamer_hooks.name);\n+\n+  /* The header of a tree node consists of its tag, the size of\n+     the node, and any other information needed to instantiate\n+     EXPR on the reading side (such as the number of slots in\n+     variable sized nodes).  */\n+  tag = lto_tree_code_to_tag (code);\n+  output_record_start (ob, tag);\n+\n+  /* The following will cause bootstrap miscomparisons.  Enable with care.  */\n+#ifdef LTO_STREAMER_DEBUG\n+  /* This is used mainly for debugging purposes.  When the reader\n+     and the writer do not agree on a streamed node, the pointer\n+     value for EXPR can be used to track down the differences in\n+     the debugger.  */\n+  gcc_assert ((HOST_WIDEST_INT) (intptr_t) expr == (intptr_t) expr);\n+  output_sleb128 (ob, (HOST_WIDEST_INT) (intptr_t) expr);\n+#endif\n+\n+  /* The text in strings and identifiers are completely emitted in\n+     the header.  */\n+  if (CODE_CONTAINS_STRUCT (code, TS_STRING))\n+    output_string_cst (ob, ob->main_stream, expr);\n+  else if (CODE_CONTAINS_STRUCT (code, TS_IDENTIFIER))\n+    output_identifier (ob, ob->main_stream, expr);\n+  else if (CODE_CONTAINS_STRUCT (code, TS_VEC))\n+    output_sleb128 (ob, TREE_VEC_LENGTH (expr));\n+  else if (CODE_CONTAINS_STRUCT (code, TS_BINFO))\n+    output_uleb128 (ob, BINFO_N_BASE_BINFOS (expr));\n+\n+  /* Allow the streamer to write any streamer-specific information\n+     needed to instantiate the node when reading.  */\n+  if (streamer_hooks.output_tree_header)\n+    streamer_hooks.output_tree_header (ob, expr);\n+}\n+\n+\n+/* Emit the integer constant CST to output block OB.  If REF_P is true,\n+   CST's type will be emitted as a reference.  */\n+\n+static void\n+lto_output_integer_cst (struct output_block *ob, tree cst, bool ref_p)\n+{\n+  output_record_start (ob, lto_tree_code_to_tag (INTEGER_CST));\n+  lto_output_tree_or_ref (ob, TREE_TYPE (cst), ref_p);\n+  lto_output_1_stream (ob->main_stream, TREE_OVERFLOW_P (cst));\n+  output_uleb128 (ob, TREE_INT_CST_LOW (cst));\n+  output_uleb128 (ob, TREE_INT_CST_HIGH (cst));\n+}\n+\n+\n+/* Write a physical representation of tree node EXPR to output block\n+   OB.  If REF_P is true, the leaves of EXPR are emitted as references\n+   via lto_output_tree_ref.  IX is the index into the streamer cache\n+   where EXPR is stored.  */\n+\n+static void\n+lto_write_tree (struct output_block *ob, tree expr, bool ref_p)\n+{\n+  struct bitpack_d bp;\n+\n+  /* Write the header, containing everything needed to materialize\n+     EXPR on the reading side.  */\n+  lto_output_tree_header (ob, expr);\n+\n+  /* Pack all the non-pointer fields in EXPR into a bitpack and write\n+     the resulting bitpack.  */\n+  bp = bitpack_create (ob->main_stream);\n+  pack_value_fields (&bp, expr);\n+  lto_output_bitpack (&bp);\n+\n+  /* Write all the pointer fields in EXPR.  */\n+  lto_output_tree_pointers (ob, expr, ref_p);\n+\n+  /* Call back into the streaming module to see if it needs to write\n+     anything that was not written by the common streamer.  */\n+  if (streamer_hooks.write_tree)\n+    streamer_hooks.write_tree (ob, expr, ref_p);\n+\n+  /* Mark the end of EXPR.  */\n+  output_zero (ob);\n+}\n+\n+\n+/* Emit the physical representation of tree node EXPR to output block\n+   OB.  If REF_P is true, the leaves of EXPR are emitted as references\n+   via lto_output_tree_ref.  */\n+\n+void\n+lto_output_tree (struct output_block *ob, tree expr, bool ref_p)\n+{\n+  unsigned ix;\n+  bool existed_p;\n+\n+  if (expr == NULL_TREE)\n+    {\n+      output_record_start (ob, LTO_null);\n+      return;\n+    }\n+\n+  /* INTEGER_CST nodes are special because they need their original type\n+     to be materialized by the reader (to implement TYPE_CACHED_VALUES).  */\n+  if (TREE_CODE (expr) == INTEGER_CST)\n+    {\n+      lto_output_integer_cst (ob, expr, ref_p);\n+      return;\n+    }\n+\n+  existed_p = lto_streamer_cache_insert (ob->writer_cache, expr, &ix);\n+  if (existed_p)\n+    {\n+      /* If a node has already been streamed out, make sure that\n+\t we don't write it more than once.  Otherwise, the reader\n+\t will instantiate two different nodes for the same object.  */\n+      output_record_start (ob, LTO_tree_pickle_reference);\n+      output_uleb128 (ob, ix);\n+      lto_output_enum (ob->main_stream, LTO_tags, LTO_NUM_TAGS,\n+\t\t       lto_tree_code_to_tag (TREE_CODE (expr)));\n+    }\n+  else if (lto_stream_as_builtin_p (expr))\n+    {\n+      /* MD and NORMAL builtins do not need to be written out\n+\t completely as they are always instantiated by the\n+\t compiler on startup.  The only builtins that need to\n+\t be written out are BUILT_IN_FRONTEND.  For all other\n+\t builtins, we simply write the class and code.  */\n+      lto_output_builtin_tree (ob, expr);\n+    }\n+  else\n+    {\n+      /* This is the first time we see EXPR, write its fields\n+\t to OB.  */\n+      lto_write_tree (ob, expr, ref_p);\n+    }\n+}"}, {"sha": "d5fe93ab58976753d7a27d30778eff2bdd693eeb", "filename": "gcc/tree-streamer.c", "status": "added", "additions": 279, "deletions": 0, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Ftree-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Ftree-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer.c?ref=f0efc7aa7705facdb16a39a08137cf748c7d5f30", "patch": "@@ -0,0 +1,279 @@\n+/* Miscellaneous utilities for tree streaming.  Things that are used\n+   in both input and output are here.\n+\n+   Copyright 2011 Free Software Foundation, Inc.\n+   Contributed by Diego Novillo <dnovillo@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"streamer-hooks.h\"\n+#include \"tree-streamer.h\"\n+\n+/* Check that all the TS_* structures handled by the lto_output_* and\n+   lto_input_* routines are exactly ALL the structures defined in\n+   treestruct.def.  */\n+\n+void\n+check_handled_ts_structures (void)\n+{\n+  bool handled_p[LAST_TS_ENUM];\n+  unsigned i;\n+\n+  memset (&handled_p, 0, sizeof (handled_p));\n+\n+  /* These are the TS_* structures that are either handled or\n+     explicitly ignored by the streamer routines.  */\n+  handled_p[TS_BASE] = true;\n+  handled_p[TS_TYPED] = true;\n+  handled_p[TS_COMMON] = true;\n+  handled_p[TS_INT_CST] = true;\n+  handled_p[TS_REAL_CST] = true;\n+  handled_p[TS_FIXED_CST] = true;\n+  handled_p[TS_VECTOR] = true;\n+  handled_p[TS_STRING] = true;\n+  handled_p[TS_COMPLEX] = true;\n+  handled_p[TS_IDENTIFIER] = true;\n+  handled_p[TS_DECL_MINIMAL] = true;\n+  handled_p[TS_DECL_COMMON] = true;\n+  handled_p[TS_DECL_WRTL] = true;\n+  handled_p[TS_DECL_NON_COMMON] = true;\n+  handled_p[TS_DECL_WITH_VIS] = true;\n+  handled_p[TS_FIELD_DECL] = true;\n+  handled_p[TS_VAR_DECL] = true;\n+  handled_p[TS_PARM_DECL] = true;\n+  handled_p[TS_LABEL_DECL] = true;\n+  handled_p[TS_RESULT_DECL] = true;\n+  handled_p[TS_CONST_DECL] = true;\n+  handled_p[TS_TYPE_DECL] = true;\n+  handled_p[TS_FUNCTION_DECL] = true;\n+  handled_p[TS_TYPE_COMMON] = true;\n+  handled_p[TS_TYPE_WITH_LANG_SPECIFIC] = true;\n+  handled_p[TS_TYPE_NON_COMMON] = true;\n+  handled_p[TS_LIST] = true;\n+  handled_p[TS_VEC] = true;\n+  handled_p[TS_EXP] = true;\n+  handled_p[TS_SSA_NAME] = true;\n+  handled_p[TS_BLOCK] = true;\n+  handled_p[TS_BINFO] = true;\n+  handled_p[TS_STATEMENT_LIST] = true;\n+  handled_p[TS_CONSTRUCTOR] = true;\n+  handled_p[TS_OMP_CLAUSE] = true;\n+  handled_p[TS_OPTIMIZATION] = true;\n+  handled_p[TS_TARGET_OPTION] = true;\n+  handled_p[TS_TRANSLATION_UNIT_DECL] = true;\n+\n+  /* Anything not marked above will trigger the following assertion.\n+     If this assertion triggers, it means that there is a new TS_*\n+     structure that should be handled by the streamer.  */\n+  for (i = 0; i < LAST_TS_ENUM; i++)\n+    gcc_assert (handled_p[i]);\n+}\n+\n+\n+/* Helper for lto_streamer_cache_insert_1.  Add T to CACHE->NODES at\n+   slot IX.  */\n+\n+static void\n+lto_streamer_cache_add_to_node_array (struct lto_streamer_cache_d *cache,\n+\t\t\t\t      unsigned ix, tree t)\n+{\n+  /* Make sure we're either replacing an old element or\n+     appending consecutively.  */\n+  gcc_assert (ix <= VEC_length (tree, cache->nodes));\n+\n+  if (ix == VEC_length (tree, cache->nodes))\n+    VEC_safe_push (tree, heap, cache->nodes, t);\n+  else\n+    VEC_replace (tree, cache->nodes, ix, t);\n+}\n+\n+\n+/* Helper for lto_streamer_cache_insert and lto_streamer_cache_insert_at.\n+   CACHE, T, and IX_P are as in lto_streamer_cache_insert.\n+\n+   If INSERT_AT_NEXT_SLOT_P is true, T is inserted at the next available\n+   slot in the cache.  Otherwise, T is inserted at the position indicated\n+   in *IX_P.\n+\n+   If T already existed in CACHE, return true.  Otherwise,\n+   return false.  */\n+\n+static bool\n+lto_streamer_cache_insert_1 (struct lto_streamer_cache_d *cache,\n+\t\t\t     tree t, unsigned *ix_p,\n+\t\t\t     bool insert_at_next_slot_p)\n+{\n+  void **slot;\n+  unsigned ix;\n+  bool existed_p;\n+\n+  gcc_assert (t);\n+\n+  slot = pointer_map_insert (cache->node_map, t);\n+  if (!*slot)\n+    {\n+      /* Determine the next slot to use in the cache.  */\n+      if (insert_at_next_slot_p)\n+\tix = VEC_length (tree, cache->nodes);\n+      else\n+\tix = *ix_p;\n+       *slot = (void *)(size_t) (ix + 1);\n+\n+      lto_streamer_cache_add_to_node_array (cache, ix, t);\n+\n+      /* Indicate that the item was not present in the cache.  */\n+      existed_p = false;\n+    }\n+  else\n+    {\n+      ix = (size_t) *slot - 1;\n+\n+      if (!insert_at_next_slot_p && ix != *ix_p)\n+\t{\n+\t  /* If the caller wants to insert T at a specific slot\n+\t     location, and ENTRY->TO does not match *IX_P, add T to\n+\t     the requested location slot.  */\n+\t  ix = *ix_p;\n+\t  lto_streamer_cache_add_to_node_array (cache, ix, t);\n+\t}\n+\n+      /* Indicate that T was already in the cache.  */\n+      existed_p = true;\n+    }\n+\n+  if (ix_p)\n+    *ix_p = ix;\n+\n+  return existed_p;\n+}\n+\n+\n+/* Insert tree node T in CACHE.  If T already existed in the cache\n+   return true.  Otherwise, return false.\n+\n+   If IX_P is non-null, update it with the index into the cache where\n+   T has been stored.  */\n+\n+bool\n+lto_streamer_cache_insert (struct lto_streamer_cache_d *cache, tree t,\n+\t\t\t   unsigned *ix_p)\n+{\n+  return lto_streamer_cache_insert_1 (cache, t, ix_p, true);\n+}\n+\n+\n+/* Insert tree node T in CACHE at slot IX.  If T already\n+   existed in the cache return true.  Otherwise, return false.  */\n+\n+bool\n+lto_streamer_cache_insert_at (struct lto_streamer_cache_d *cache,\n+\t\t\t      tree t, unsigned ix)\n+{\n+  return lto_streamer_cache_insert_1 (cache, t, &ix, false);\n+}\n+\n+\n+/* Appends tree node T to CACHE, even if T already existed in it.  */\n+\n+void\n+lto_streamer_cache_append (struct lto_streamer_cache_d *cache, tree t)\n+{\n+  unsigned ix = VEC_length (tree, cache->nodes);\n+  lto_streamer_cache_insert_1 (cache, t, &ix, false);\n+}\n+\n+/* Return true if tree node T exists in CACHE, otherwise false.  If IX_P is\n+   not NULL, write to *IX_P the index into the cache where T is stored\n+   ((unsigned)-1 if T is not found).  */\n+\n+bool\n+lto_streamer_cache_lookup (struct lto_streamer_cache_d *cache, tree t,\n+\t\t\t   unsigned *ix_p)\n+{\n+  void **slot;\n+  bool retval;\n+  unsigned ix;\n+\n+  gcc_assert (t);\n+\n+  slot = pointer_map_contains  (cache->node_map, t);\n+  if (slot == NULL)\n+    {\n+      retval = false;\n+      ix = -1;\n+    }\n+  else\n+    {\n+      retval = true;\n+      ix = (size_t) *slot - 1;\n+    }\n+\n+  if (ix_p)\n+    *ix_p = ix;\n+\n+  return retval;\n+}\n+\n+\n+/* Return the tree node at slot IX in CACHE.  */\n+\n+tree\n+lto_streamer_cache_get (struct lto_streamer_cache_d *cache, unsigned ix)\n+{\n+  gcc_assert (cache);\n+\n+  /* Make sure we're not requesting something we don't have.  */\n+  gcc_assert (ix < VEC_length (tree, cache->nodes));\n+\n+  return VEC_index (tree, cache->nodes, ix);\n+}\n+\n+/* Create a cache of pickled nodes.  */\n+\n+struct lto_streamer_cache_d *\n+lto_streamer_cache_create (void)\n+{\n+  struct lto_streamer_cache_d *cache;\n+\n+  cache = XCNEW (struct lto_streamer_cache_d);\n+\n+  cache->node_map = pointer_map_create ();\n+\n+  /* Load all the well-known tree nodes that are always created by\n+     the compiler on startup.  This prevents writing them out\n+     unnecessarily.  */\n+  streamer_hooks.preload_common_nodes (cache);\n+\n+  return cache;\n+}\n+\n+\n+/* Delete the streamer cache C.  */\n+\n+void\n+lto_streamer_cache_delete (struct lto_streamer_cache_d *c)\n+{\n+  if (c == NULL)\n+    return;\n+\n+  pointer_map_destroy (c->node_map);\n+  VEC_free (tree, heap, c->nodes);\n+  free (c);\n+}"}, {"sha": "9d4740f53b186577bc652b7f9fb874fdceff2411", "filename": "gcc/tree-streamer.h", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Ftree-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0efc7aa7705facdb16a39a08137cf748c7d5f30/gcc%2Ftree-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer.h?ref=f0efc7aa7705facdb16a39a08137cf748c7d5f30", "patch": "@@ -0,0 +1,76 @@\n+/* Data structures and functions for streaming trees.\n+\n+   Copyright 2011 Free Software Foundation, Inc.\n+   Contributed by Diego Novillo <dnovillo@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_TREE_STREAMER_H\n+#define GCC_TREE_STREAMER_H\n+\n+#include \"tree.h\"\n+#include \"lto-streamer.h\"\n+\n+/* Cache of pickled nodes.  Used to avoid writing the same node more\n+   than once.  The first time a tree node is streamed out, it is\n+   entered in this cache.  Subsequent references to the same node are\n+   resolved by looking it up in this cache.\n+\n+   This is used in two ways:\n+\n+   - On the writing side, the first time T is added to STREAMER_CACHE,\n+     a new reference index is created for T and T is emitted on the\n+     stream.  If T needs to be emitted again to the stream, instead of\n+     pickling it again, the reference index is emitted.\n+\n+   - On the reading side, the first time T is read from the stream, it\n+     is reconstructed in memory and a new reference index created for\n+     T.  The reconstructed T is inserted in some array so that when\n+     the reference index for T is found in the input stream, it can be\n+     used to look up into the array to get the reconstructed T.  */\n+struct lto_streamer_cache_d\n+{\n+  /* The mapping between tree nodes and slots into the nodes array.  */\n+  struct pointer_map_t *node_map;\n+\n+  /* The nodes pickled so far.  */\n+  VEC(tree,heap) *nodes;\n+};\n+\n+/* In tree-streamer-in.c.  */\n+tree input_string_cst (struct data_in *, struct lto_input_block *);\n+tree lto_input_tree (struct lto_input_block *, struct data_in *);\n+void lto_streamer_read_tree (struct lto_input_block *,\n+\t\t\t\t     struct data_in *, tree);\n+\n+/* In tree-streamer-out.c.  */\n+void lto_streamer_write_tree (struct output_block *, tree, bool);\n+\n+/* In tree-streamer.c.  */\n+void check_handled_ts_structures (void);\n+bool lto_streamer_cache_insert (struct lto_streamer_cache_d *, tree,\n+ \t\t\t        unsigned *);\n+bool lto_streamer_cache_insert_at (struct lto_streamer_cache_d *, tree,\n+ \t\t\t\t   unsigned);\n+void lto_streamer_cache_append (struct lto_streamer_cache_d *, tree);\n+bool lto_streamer_cache_lookup (struct lto_streamer_cache_d *, tree,\n+ \t\t\t        unsigned *);\n+tree lto_streamer_cache_get (struct lto_streamer_cache_d *, unsigned);\n+struct lto_streamer_cache_d *lto_streamer_cache_create (void);\n+void lto_streamer_cache_delete (struct lto_streamer_cache_d *);\n+\n+#endif  /* GCC_TREE_STREAMER_H  */"}]}