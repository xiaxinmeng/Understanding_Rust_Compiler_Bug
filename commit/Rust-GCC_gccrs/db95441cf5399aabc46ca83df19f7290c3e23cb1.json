{"sha": "db95441cf5399aabc46ca83df19f7290c3e23cb1", "node_id": "C_kwDOANBUbNoAKGRiOTU0NDFjZjUzOTlhYWJjNDZjYTgzZGYxOWY3MjkwYzNlMjNjYjE", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.ibm.com", "date": "2022-02-06T08:07:41Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@linux.ibm.com", "date": "2022-02-07T10:18:08Z"}, "message": "Check always_inline flag in s390_can_inline_p [PR104327]\n\nMASK_MVCLE is set for -Os but not for other optimization levels. In\ngeneral it should not make much sense to inline across calls where the\nflag is different but we have to allow it for always_inline.\n\nThe patch also rearranges the hook implementation a bit based on the\nrecommendations from Jakub und Martin in the PR.\n\nBootstrapped and regression tested on s390x with various arch flags.\nWill commit after giving a few days for comments.\n\ngcc/ChangeLog:\n\n\tPR target/104327\n\t* config/s390/s390.cc (s390_can_inline_p): Accept a few more flags\n\tif always_inline is set. Don't inline when tune differs without\n\talways_inline.\n\ngcc/testsuite/ChangeLog:\n\n\tPR target/104327\n\t* gcc.c-torture/compile/pr104327.c: New test.", "tree": {"sha": "7ec67943839220c0e91d7c2f8b8efc4873e47ea0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ec67943839220c0e91d7c2f8b8efc4873e47ea0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db95441cf5399aabc46ca83df19f7290c3e23cb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db95441cf5399aabc46ca83df19f7290c3e23cb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db95441cf5399aabc46ca83df19f7290c3e23cb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db95441cf5399aabc46ca83df19f7290c3e23cb1/comments", "author": {"login": "Andreas-Krebbel", "id": 38103320, "node_id": "MDQ6VXNlcjM4MTAzMzIw", "avatar_url": "https://avatars.githubusercontent.com/u/38103320?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Andreas-Krebbel", "html_url": "https://github.com/Andreas-Krebbel", "followers_url": "https://api.github.com/users/Andreas-Krebbel/followers", "following_url": "https://api.github.com/users/Andreas-Krebbel/following{/other_user}", "gists_url": "https://api.github.com/users/Andreas-Krebbel/gists{/gist_id}", "starred_url": "https://api.github.com/users/Andreas-Krebbel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Andreas-Krebbel/subscriptions", "organizations_url": "https://api.github.com/users/Andreas-Krebbel/orgs", "repos_url": "https://api.github.com/users/Andreas-Krebbel/repos", "events_url": "https://api.github.com/users/Andreas-Krebbel/events{/privacy}", "received_events_url": "https://api.github.com/users/Andreas-Krebbel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Andreas-Krebbel", "id": 38103320, "node_id": "MDQ6VXNlcjM4MTAzMzIw", "avatar_url": "https://avatars.githubusercontent.com/u/38103320?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Andreas-Krebbel", "html_url": "https://github.com/Andreas-Krebbel", "followers_url": "https://api.github.com/users/Andreas-Krebbel/followers", "following_url": "https://api.github.com/users/Andreas-Krebbel/following{/other_user}", "gists_url": "https://api.github.com/users/Andreas-Krebbel/gists{/gist_id}", "starred_url": "https://api.github.com/users/Andreas-Krebbel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Andreas-Krebbel/subscriptions", "organizations_url": "https://api.github.com/users/Andreas-Krebbel/orgs", "repos_url": "https://api.github.com/users/Andreas-Krebbel/repos", "events_url": "https://api.github.com/users/Andreas-Krebbel/events{/privacy}", "received_events_url": "https://api.github.com/users/Andreas-Krebbel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70430001b74d0f67386a6b3642c857b3389cd5d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70430001b74d0f67386a6b3642c857b3389cd5d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70430001b74d0f67386a6b3642c857b3389cd5d0"}], "stats": {"total": 79, "additions": 62, "deletions": 17}, "files": [{"sha": "c6cfe41ad7b50dd33c6e9d4d6f1c9cf170573789", "filename": "gcc/config/s390/s390.cc", "status": "modified", "additions": 47, "deletions": 17, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db95441cf5399aabc46ca83df19f7290c3e23cb1/gcc%2Fconfig%2Fs390%2Fs390.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db95441cf5399aabc46ca83df19f7290c3e23cb1/gcc%2Fconfig%2Fs390%2Fs390.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.cc?ref=db95441cf5399aabc46ca83df19f7290c3e23cb1", "patch": "@@ -16091,6 +16091,23 @@ s390_valid_target_attribute_p (tree fndecl,\n static bool\n s390_can_inline_p (tree caller, tree callee)\n {\n+  /* Flags which if present in the callee are required in the caller as well.  */\n+  const unsigned HOST_WIDE_INT caller_required_masks = MASK_OPT_HTM;\n+\n+  /* Flags which affect the ABI and in general prevent inlining.  */\n+  unsigned HOST_WIDE_INT must_match_masks\n+    = (MASK_64BIT | MASK_ZARCH | MASK_HARD_DFP | MASK_SOFT_FLOAT\n+       | MASK_LONG_DOUBLE_128 | MASK_OPT_VX);\n+\n+  /* Flags which we in general want to prevent inlining but accept for\n+     always_inline.  */\n+  const unsigned HOST_WIDE_INT always_inline_safe_masks\n+    = MASK_MVCLE | MASK_BACKCHAIN | MASK_SMALL_EXEC;\n+\n+  const HOST_WIDE_INT all_masks\n+     = (caller_required_masks | must_match_masks | always_inline_safe_masks\n+\t| MASK_DEBUG_ARG | MASK_PACKED_STACK | MASK_ZVECTOR);\n+\n   tree caller_tree = DECL_FUNCTION_SPECIFIC_TARGET (caller);\n   tree callee_tree = DECL_FUNCTION_SPECIFIC_TARGET (callee);\n \n@@ -16103,33 +16120,46 @@ s390_can_inline_p (tree caller, tree callee)\n \n   struct cl_target_option *caller_opts = TREE_TARGET_OPTION (caller_tree);\n   struct cl_target_option *callee_opts = TREE_TARGET_OPTION (callee_tree);\n-  bool ret = true;\n \n-  if ((caller_opts->x_target_flags & ~(MASK_SOFT_FLOAT | MASK_HARD_DFP))\n-      != (callee_opts->x_target_flags & ~(MASK_SOFT_FLOAT | MASK_HARD_DFP)))\n-    ret = false;\n+  /* If one of these triggers make sure to add proper handling of your\n+     new flag to this hook.  */\n+  gcc_assert (!(caller_opts->x_target_flags & ~all_masks));\n+  gcc_assert (!(callee_opts->x_target_flags & ~all_masks));\n \n-  /* Don't inline functions to be compiled for a more recent arch into a\n-     function for an older arch.  */\n-  else if (caller_opts->x_s390_arch < callee_opts->x_s390_arch)\n-    ret = false;\n+  bool always_inline\n+    = (DECL_DISREGARD_INLINE_LIMITS (callee)\n+       && lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (callee)));\n+\n+  if (!always_inline)\n+    must_match_masks |= always_inline_safe_masks;\n \n   /* Inlining a hard float function into a soft float function is only\n      allowed if the hard float function doesn't actually make use of\n      floating point.\n \n      We are called from FEs for multi-versioning call optimization, so\n      beware of ipa_fn_summaries not available.  */\n-  else if (((TARGET_SOFT_FLOAT_P (caller_opts->x_target_flags)\n-\t     && !TARGET_SOFT_FLOAT_P (callee_opts->x_target_flags))\n-\t    || (!TARGET_HARD_DFP_P (caller_opts->x_target_flags)\n-\t\t&& TARGET_HARD_DFP_P (callee_opts->x_target_flags)))\n-\t   && (! ipa_fn_summaries\n-\t       || ipa_fn_summaries->get\n-\t       (cgraph_node::get (callee))->fp_expressions))\n-    ret = false;\n+  if (always_inline && ipa_fn_summaries\n+      && !ipa_fn_summaries->get(cgraph_node::get (callee))->fp_expressions)\n+    must_match_masks &= ~(MASK_HARD_DFP | MASK_SOFT_FLOAT);\n \n-  return ret;\n+  if ((caller_opts->x_target_flags & must_match_masks)\n+      != (callee_opts->x_target_flags & must_match_masks))\n+    return false;\n+\n+  if (~(caller_opts->x_target_flags & caller_required_masks)\n+      & (callee_opts->x_target_flags & caller_required_masks))\n+    return false;\n+\n+  /* Don't inline functions to be compiled for a more recent arch into a\n+     function for an older arch.  */\n+  if (caller_opts->x_s390_arch < callee_opts->x_s390_arch)\n+    return false;\n+\n+  if (!always_inline && caller_opts->x_s390_tune != callee_opts->x_s390_tune)\n+    return false;\n+\n+  return true;\n }\n #endif\n "}, {"sha": "d54e5d58cc447c0167edde28ac0f8c867d5fa03d", "filename": "gcc/testsuite/gcc.c-torture/compile/pr104327.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db95441cf5399aabc46ca83df19f7290c3e23cb1/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr104327.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db95441cf5399aabc46ca83df19f7290c3e23cb1/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr104327.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr104327.c?ref=db95441cf5399aabc46ca83df19f7290c3e23cb1", "patch": "@@ -0,0 +1,15 @@\n+/* PR target/104327 */\n+\n+void foo (int *);\n+\n+static inline __attribute__((always_inline)) void\n+bar (int *x)\n+{\n+  foo (x);\n+}\n+\n+__attribute__((cold, optimize(\"Os\"))) void\n+baz (int *x)\n+{\n+  bar (x);\n+}"}]}