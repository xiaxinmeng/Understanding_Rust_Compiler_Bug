{"sha": "ea395a11a35718e110d0ba783619207c9fd9d354", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWEzOTVhMTFhMzU3MThlMTEwZDBiYTc4MzYxOTIwN2M5ZmQ5ZDM1NA==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2010-09-15T13:08:56Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2010-09-15T13:08:56Z"}, "message": "tree-sra.c (generate_subtree_copies): Updated comment.\n\n2010-09-15  Martin Jambor  <mjambor@suse.cz>\n\n\t* tree-sra.c (generate_subtree_copies): Updated comment.\n\t(handle_unscalarized_data_in_subtree): Removed parameter lhs which is\n\tobtained from the statement iterator instead.\n\t(load_assign_lhs_subreplacements): Removed parameters lhs and\n\tright_offset, which is obtained from top_racc instead.  Parameter lacc\n\tis now expected to be the root of the processed tree rather than root's\n\tfirst child.  Updated all callers.\n\nFrom-SVN: r164304", "tree": {"sha": "c5e176c80eae582ebb05d473c710118717bc1367", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5e176c80eae582ebb05d473c710118717bc1367"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea395a11a35718e110d0ba783619207c9fd9d354", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea395a11a35718e110d0ba783619207c9fd9d354", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea395a11a35718e110d0ba783619207c9fd9d354", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea395a11a35718e110d0ba783619207c9fd9d354/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6d96b48ba8817d0c60426f814875b3ae338acd33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d96b48ba8817d0c60426f814875b3ae338acd33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d96b48ba8817d0c60426f814875b3ae338acd33"}], "stats": {"total": 75, "additions": 39, "deletions": 36}, "files": [{"sha": "678c373f1906e58152bf7ac7e66958c2f8acd485", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea395a11a35718e110d0ba783619207c9fd9d354/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea395a11a35718e110d0ba783619207c9fd9d354/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ea395a11a35718e110d0ba783619207c9fd9d354", "patch": "@@ -1,3 +1,13 @@\n+2010-09-15  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* tree-sra.c (generate_subtree_copies): Updated comment.\n+\t(handle_unscalarized_data_in_subtree): Removed parameter lhs which is\n+\tobtained from the statement iterator instead.\n+\t(load_assign_lhs_subreplacements): Removed parameters lhs and\n+\tright_offset, which is obtained from top_racc instead.  Parameter lacc\n+\tis now expected to be the root of the processed tree rather than root's\n+\tfirst child.  Updated all callers.\n+\n 2010-09-15  Joseph Myers  <joseph@codesourcery.com>\n \n \t* config/pdp11/pdp11.c (register_move_cost): Rename to"}, {"sha": "e3007ee59775844d34727086d701fe8afbafa297", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 29, "deletions": 36, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea395a11a35718e110d0ba783619207c9fd9d354/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea395a11a35718e110d0ba783619207c9fd9d354/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=ea395a11a35718e110d0ba783619207c9fd9d354", "patch": "@@ -2169,12 +2169,12 @@ analyze_all_variable_accesses (void)\n }\n \n /* Generate statements copying scalar replacements of accesses within a subtree\n-   into or out of AGG.  ACCESS is the first child of the root of the subtree to\n-   be processed.  AGG is an aggregate type expression (can be a declaration but\n-   does not have to be, it can for example also be a mem_ref or a series of\n-   handled components).  TOP_OFFSET is the offset of the processed subtree\n-   which has to be subtracted from offsets of individual accesses to get\n-   corresponding offsets for AGG.  If CHUNK_SIZE is non-null, copy only\n+   into or out of AGG.  ACCESS, all its children, siblings and their children\n+   are to be processed.  AGG is an aggregate type expression (can be a\n+   declaration but does not have to be, it can for example also be a mem_ref or\n+   a series of handled components).  TOP_OFFSET is the offset of the processed\n+   subtree which has to be subtracted from offsets of individual accesses to\n+   get corresponding offsets for AGG.  If CHUNK_SIZE is non-null, copy only\n    replacements in the interval <start_offset, start_offset + chunk_size>,\n    otherwise copy all.  GSI is a statement iterator used to place the new\n    statements.  WRITE should be true when the statements should write from AGG\n@@ -2405,11 +2405,11 @@ enum unscalarized_data_handling { SRA_UDH_NONE,  /* Nothing done so far. */\n \t\t\t\t  SRA_UDH_LEFT }; /* Data flushed to the LHS. */\n \n /* Store all replacements in the access tree rooted in TOP_RACC either to their\n-   base aggregate if there are unscalarized data or directly to LHS\n-   otherwise.  */\n+   base aggregate if there are unscalarized data or directly to LHS of the\n+   statement that is pointed to by GSI otherwise.  */\n \n static enum unscalarized_data_handling\n-handle_unscalarized_data_in_subtree (struct access *top_racc, tree lhs,\n+handle_unscalarized_data_in_subtree (struct access *top_racc,\n \t\t\t\t     gimple_stmt_iterator *gsi)\n {\n   if (top_racc->grp_unscalarized_data)\n@@ -2421,6 +2421,7 @@ handle_unscalarized_data_in_subtree (struct access *top_racc, tree lhs,\n     }\n   else\n     {\n+      tree lhs = gimple_assign_lhs (gsi_stmt (*gsi));\n       generate_subtree_copies (top_racc->first_child, lhs, top_racc->offset,\n \t\t\t       0, 0, gsi, false, false,\n \t\t\t       gimple_location (gsi_stmt (*gsi)));\n@@ -2429,33 +2430,30 @@ handle_unscalarized_data_in_subtree (struct access *top_racc, tree lhs,\n }\n \n \n-/* Try to generate statements to load all sub-replacements in an access\n-   (sub)tree (LACC is the first child) from scalar replacements in the TOP_RACC\n-   (sub)tree.  If that is not possible, refresh the TOP_RACC base aggregate and\n-   load the accesses from it.  LEFT_OFFSET is the offset of the left whole\n-   subtree being copied, RIGHT_OFFSET is the same thing for the right subtree.\n-   NEW_GSI is stmt iterator used for statement insertions after the original\n-   assignment, OLD_GSI is used to insert statements before the assignment.\n-   *REFRESHED keeps the information whether we have needed to refresh\n-   replacements of the LHS and from which side of the assignments this takes\n-   place.  */\n+/* Try to generate statements to load all sub-replacements in an access subtree\n+   formed by children of LACC from scalar replacements in the TOP_RACC subtree.\n+   If that is not possible, refresh the TOP_RACC base aggregate and load the\n+   accesses from it.  LEFT_OFFSET is the offset of the left whole subtree being\n+   copied. NEW_GSI is stmt iterator used for statement insertions after the\n+   original assignment, OLD_GSI is used to insert statements before the\n+   assignment.  *REFRESHED keeps the information whether we have needed to\n+   refresh replacements of the LHS and from which side of the assignments this\n+   takes place.  */\n \n static void\n load_assign_lhs_subreplacements (struct access *lacc, struct access *top_racc,\n \t\t\t\t HOST_WIDE_INT left_offset,\n-\t\t\t\t HOST_WIDE_INT right_offset,\n \t\t\t\t gimple_stmt_iterator *old_gsi,\n \t\t\t\t gimple_stmt_iterator *new_gsi,\n-\t\t\t\t enum unscalarized_data_handling *refreshed,\n-\t\t\t\t tree lhs)\n+\t\t\t\t enum unscalarized_data_handling *refreshed)\n {\n   location_t loc = gimple_location (gsi_stmt (*old_gsi));\n-  do\n+  for (lacc = lacc->first_child; lacc; lacc = lacc->next_sibling)\n     {\n       if (lacc->grp_to_be_replaced)\n \t{\n \t  struct access *racc;\n-\t  HOST_WIDE_INT offset = lacc->offset - left_offset + right_offset;\n+\t  HOST_WIDE_INT offset = lacc->offset - left_offset + top_racc->offset;\n \t  gimple stmt;\n \t  tree rhs;\n \n@@ -2471,7 +2469,7 @@ load_assign_lhs_subreplacements (struct access *lacc, struct access *top_racc,\n \t      /* No suitable access on the right hand side, need to load from\n \t\t the aggregate.  See if we have to update it first... */\n \t      if (*refreshed == SRA_UDH_NONE)\n-\t\t*refreshed = handle_unscalarized_data_in_subtree (top_racc, lhs,\n+\t\t*refreshed = handle_unscalarized_data_in_subtree (top_racc,\n \t\t\t\t\t\t\t\t  old_gsi);\n \n \t      if (*refreshed == SRA_UDH_LEFT)\n@@ -2490,16 +2488,13 @@ load_assign_lhs_subreplacements (struct access *lacc, struct access *top_racc,\n \t}\n       else if (*refreshed == SRA_UDH_NONE\n \t       && lacc->grp_read && !lacc->grp_covered)\n-\t*refreshed = handle_unscalarized_data_in_subtree (top_racc, lhs,\n+\t*refreshed = handle_unscalarized_data_in_subtree (top_racc,\n \t\t\t\t\t\t\t  old_gsi);\n \n       if (lacc->first_child)\n-\tload_assign_lhs_subreplacements (lacc->first_child, top_racc,\n-\t\t\t\t\t left_offset, right_offset,\n-\t\t\t\t\t old_gsi, new_gsi, refreshed, lhs);\n-      lacc = lacc->next_sibling;\n+\tload_assign_lhs_subreplacements (lacc, top_racc, left_offset,\n+\t\t\t\t\t old_gsi, new_gsi, refreshed);\n     }\n-  while (lacc);\n }\n \n /* Result code for SRA assignment modification.  */\n@@ -2714,14 +2709,12 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi)\n \t  enum unscalarized_data_handling refreshed;\n \n \t  if (lacc->grp_read && !lacc->grp_covered)\n-\t    refreshed = handle_unscalarized_data_in_subtree (racc, lhs, gsi);\n+\t    refreshed = handle_unscalarized_data_in_subtree (racc, gsi);\n \t  else\n \t    refreshed = SRA_UDH_NONE;\n \n-\t  load_assign_lhs_subreplacements (lacc->first_child, racc,\n-\t\t\t\t\t   lacc->offset, racc->offset,\n-\t\t\t\t\t   &orig_gsi, gsi, &refreshed,\n-\t\t\t\t\t   lhs);\n+\t  load_assign_lhs_subreplacements (lacc, racc, lacc->offset,\n+\t\t\t\t\t   &orig_gsi, gsi, &refreshed);\n \t  if (refreshed != SRA_UDH_RIGHT)\n \t    {\n \t      gsi_next (gsi);"}]}