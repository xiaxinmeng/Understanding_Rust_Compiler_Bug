{"sha": "508fa61b6319377e48cbee98da221aacd475fd10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTA4ZmE2MWI2MzE5Mzc3ZTQ4Y2JlZTk4ZGEyMjFhYWNkNDc1ZmQxMA==", "commit": {"author": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-08-31T09:16:08Z"}, "committer": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-09-01T01:07:58Z"}, "message": "Revert \"Make sure we're playing with integral modes before call extract_integral_bit_field.\"\n\nThis reverts commit 7218c2ec365ce95f5a1012a6eb425b0a36aec6bf.\n\n     PR middle-end/102133", "tree": {"sha": "6de5aafc87d534e66ca7707229d2f182bddf23a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6de5aafc87d534e66ca7707229d2f182bddf23a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/508fa61b6319377e48cbee98da221aacd475fd10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/508fa61b6319377e48cbee98da221aacd475fd10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/508fa61b6319377e48cbee98da221aacd475fd10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/508fa61b6319377e48cbee98da221aacd475fd10/comments", "author": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "committer": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d51ee4321605c704aa238d039b47bfcf59b1005", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d51ee4321605c704aa238d039b47bfcf59b1005", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d51ee4321605c704aa238d039b47bfcf59b1005"}], "stats": {"total": 103, "additions": 25, "deletions": 78}, "files": [{"sha": "3143f38e0570eabe56cf82c49fb84752d8e170f0", "filename": "gcc/expmed.c", "status": "modified", "additions": 25, "deletions": 78, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/508fa61b6319377e48cbee98da221aacd475fd10/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/508fa61b6319377e48cbee98da221aacd475fd10/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=508fa61b6319377e48cbee98da221aacd475fd10", "patch": "@@ -71,14 +71,7 @@ static void store_split_bit_field (rtx, opt_scalar_int_mode,\n static rtx extract_integral_bit_field (rtx, opt_scalar_int_mode,\n \t\t\t\t       unsigned HOST_WIDE_INT,\n \t\t\t\t       unsigned HOST_WIDE_INT, int, rtx,\n-\t\t\t\t       machine_mode, machine_mode,\n-\t\t\t\t       scalar_int_mode, bool, bool);\n-static rtx extract_and_convert_fixed_bit_field (scalar_int_mode,\n-\t\t\t\t\t\tmachine_mode, machine_mode,\n-\t\t\t\t\t\trtx, opt_scalar_int_mode,\n-\t\t\t\t\t\tunsigned HOST_WIDE_INT,\n-\t\t\t\t\t\tunsigned HOST_WIDE_INT, rtx,\n-\t\t\t\t\t\tint, bool);\n+\t\t\t\t       machine_mode, machine_mode, bool, bool);\n static rtx extract_fixed_bit_field (machine_mode, rtx, opt_scalar_int_mode,\n \t\t\t\t    unsigned HOST_WIDE_INT,\n \t\t\t\t    unsigned HOST_WIDE_INT, rtx, int, bool);\n@@ -1639,7 +1632,6 @@ extract_bit_field_1 (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,\n {\n   rtx op0 = str_rtx;\n   machine_mode mode1;\n-  scalar_int_mode int_tmode;\n \n   if (tmode == VOIDmode)\n     tmode = mode;\n@@ -1861,46 +1853,10 @@ extract_bit_field_1 (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,\n   /* It's possible we'll need to handle other cases here for\n      polynomial bitnum and bitsize.  */\n \n-  /* Make sure we are playing with integral modes.  Pun with subregs\n-     if we aren't. When tmode is HFmode, op0 is SImode, there will be ICE\n-     in extract_integral_bit_field.  */\n-  opt_scalar_int_mode target_imode = int_mode_for_mode (tmode);\n-  if (!target_imode.exists (&int_tmode) || int_tmode != tmode)\n-    {\n-      if (target_imode.exists (&int_tmode))\n-\t{\n-\t  rtx ret = extract_integral_bit_field (op0, op0_mode,\n-\t\t\t\t\t\tbitsize.to_constant (),\n-\t\t\t\t\t\tbitnum.to_constant (),\n-\t\t\t\t\t\tunsignedp, NULL, int_tmode,\n-\t\t\t\t\t\tint_tmode, int_tmode,\n-\t\t\t\t\t\treverse, fallback_p);\n-\t  gcc_assert (ret);\n-\n-\t  if (!REG_P (ret))\n-\t    ret = force_reg (int_tmode, ret);\n-\t  return gen_lowpart_SUBREG (tmode, ret);\n-\t}\n-      else\n-\t{\n-\t  if (!fallback_p)\n-\t    return NULL;\n-\n-\t  int_tmode = int_mode_for_mode (mode).require ();\n-\t  return extract_and_convert_fixed_bit_field (int_tmode, tmode, mode,\n-\t\t\t\t\t\t      op0, op0_mode,\n-\t\t\t\t\t\t      bitsize.to_constant (),\n-\t\t\t\t\t\t      bitnum.to_constant (),\n-\t\t\t\t\t\t      target, unsignedp,\n-\t\t\t\t\t\t      reverse);\n-\t}\n-    }\n-\n   /* From here on we need to be looking at a fixed-size insertion.  */\n   return extract_integral_bit_field (op0, op0_mode, bitsize.to_constant (),\n \t\t\t\t     bitnum.to_constant (), unsignedp,\n-\t\t\t\t     target, mode, tmode,\n-\t\t\t\t     int_tmode, reverse, fallback_p);\n+\t\t\t\t     target, mode, tmode, reverse, fallback_p);\n }\n \n /* Subroutine of extract_bit_field_1, with the same arguments, except\n@@ -1913,7 +1869,6 @@ extract_integral_bit_field (rtx op0, opt_scalar_int_mode op0_mode,\n \t\t\t    unsigned HOST_WIDE_INT bitsize,\n \t\t\t    unsigned HOST_WIDE_INT bitnum, int unsignedp,\n \t\t\t    rtx target, machine_mode mode, machine_mode tmode,\n-\t\t\t    scalar_int_mode int_tmode,\n \t\t\t    bool reverse, bool fallback_p)\n {\n   /* Handle fields bigger than a word.  */\n@@ -2080,10 +2035,29 @@ extract_integral_bit_field (rtx op0, opt_scalar_int_mode op0_mode,\n   if (!fallback_p)\n     return NULL;\n \n-  return extract_and_convert_fixed_bit_field (int_tmode, tmode, mode,\n-\t\t\t\t\t      op0, op0_mode, bitsize,\n-\t\t\t\t\t      bitnum, target, unsignedp,\n-\t\t\t\t\t      reverse);\n+  /* Find a correspondingly-sized integer field, so we can apply\n+     shifts and masks to it.  */\n+  scalar_int_mode int_mode;\n+  if (!int_mode_for_mode (tmode).exists (&int_mode))\n+    /* If this fails, we should probably push op0 out to memory and then\n+       do a load.  */\n+    int_mode = int_mode_for_mode (mode).require ();\n+\n+  target = extract_fixed_bit_field (int_mode, op0, op0_mode, bitsize,\n+\t\t\t\t    bitnum, target, unsignedp, reverse);\n+\n+  /* Complex values must be reversed piecewise, so we need to undo the global\n+     reversal, convert to the complex mode and reverse again.  */\n+  if (reverse && COMPLEX_MODE_P (tmode))\n+    {\n+      target = flip_storage_order (int_mode, target);\n+      target = convert_extracted_bit_field (target, mode, tmode, unsignedp);\n+      target = flip_storage_order (tmode, target);\n+    }\n+  else\n+    target = convert_extracted_bit_field (target, mode, tmode, unsignedp);\n+\n+  return target;\n }\n \n /* Generate code to extract a byte-field from STR_RTX\n@@ -2155,33 +2129,6 @@ extract_bit_field (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,\n   return extract_bit_field_1 (str_rtx, bitsize, bitnum, unsignedp,\n \t\t\t      target, mode, tmode, reverse, true, alt_rtl);\n }\n-\n-/* Combination of extract_fixed_bit_field and convert_extracted_bit_field.  */\n-static rtx\n-extract_and_convert_fixed_bit_field (scalar_int_mode int_tmode,\n-\t\t\t\t     machine_mode tmode, machine_mode mode,\n-\t\t\t\t     rtx op0, opt_scalar_int_mode op0_mode,\n-\t\t\t\t     unsigned HOST_WIDE_INT bitsize,\n-\t\t\t\t     unsigned HOST_WIDE_INT bitnum,\n-\t\t\t\t     rtx target, int unsignedp, bool reverse)\n-{\n-  target = extract_fixed_bit_field (int_tmode, op0, op0_mode, bitsize,\n-\t\t\t\t    bitnum, target, unsignedp, reverse);\n-\n-  /* Complex values must be reversed piecewise, so we need to undo the global\n-     reversal, convert to the complex mode and reverse again.  */\n-  if (reverse && COMPLEX_MODE_P (tmode))\n-    {\n-      target = flip_storage_order (int_tmode, target);\n-      target = convert_extracted_bit_field (target, mode, tmode, unsignedp);\n-      target = flip_storage_order (tmode, target);\n-    }\n-  else\n-    target = convert_extracted_bit_field (target, mode, tmode, unsignedp);\n-\n-  return target;\n-}\n-\n \f\n /* Use shifts and boolean operations to extract a field of BITSIZE bits\n    from bit BITNUM of OP0.  If OP0_MODE is defined, it is the mode of OP0,"}]}