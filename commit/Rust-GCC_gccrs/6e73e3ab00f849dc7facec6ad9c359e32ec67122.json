{"sha": "6e73e3ab00f849dc7facec6ad9c359e32ec67122", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU3M2UzYWIwMGY4NDlkYzdmYWNlYzZhZDljMzU5ZTMyZWM2NzEyMg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-12-08T11:48:22Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-12-08T11:48:22Z"}, "message": "sem_ch4.adb (Process_Implicit_Dereference_Prefix): New subprogram used to record an implicit dereference as a read operation on...\n\n\t* sem_ch4.adb (Process_Implicit_Dereference_Prefix): New subprogram\n\tused to record an implicit dereference as a read operation on its\n\tprefix when operating under -gnatc. Necessary to avoid spurious\n\t'variable assigned but never read' warnings in that mode.\n\t(Process_Indexed_Component, Analyze_Selected_Component): When the prefix\n\tis a non-overloaded implicit dereference, call the above subprogram to\n\tensure proper recording of references.\n\nFrom-SVN: r91892", "tree": {"sha": "989970b9af1a7e9e16aa51e35019f0a92e6e283e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/989970b9af1a7e9e16aa51e35019f0a92e6e283e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e73e3ab00f849dc7facec6ad9c359e32ec67122", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e73e3ab00f849dc7facec6ad9c359e32ec67122", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e73e3ab00f849dc7facec6ad9c359e32ec67122", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e73e3ab00f849dc7facec6ad9c359e32ec67122/comments", "author": null, "committer": null, "parents": [{"sha": "07233820c338516bc9978e28fe46e646e9e53197", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07233820c338516bc9978e28fe46e646e9e53197", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07233820c338516bc9978e28fe46e646e9e53197"}], "stats": {"total": 111, "additions": 68, "deletions": 43}, "files": [{"sha": "4c01fdb0809bc0b9c6605eb5f0c619c657942877", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 68, "deletions": 43, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e73e3ab00f849dc7facec6ad9c359e32ec67122/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e73e3ab00f849dc7facec6ad9c359e32ec67122/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=6e73e3ab00f849dc7facec6ad9c359e32ec67122", "patch": "@@ -145,25 +145,25 @@ package body Sem_Ch4 is\n      (L, R  : Node_Id;\n       Op_Id : Entity_Id;\n       N     : Node_Id);\n-   --  For the four varieties of concatenation.\n+   --  For the four varieties of concatenation\n \n    procedure Find_Equality_Types\n      (L, R  : Node_Id;\n       Op_Id : Entity_Id;\n       N     : Node_Id);\n-   --  Ditto for equality operators.\n+   --  Ditto for equality operators\n \n    procedure Find_Boolean_Types\n      (L, R  : Node_Id;\n       Op_Id : Entity_Id;\n       N     : Node_Id);\n-   --  Ditto for binary logical operations.\n+   --  Ditto for binary logical operations\n \n    procedure Find_Negation_Types\n      (R     : Node_Id;\n       Op_Id : Entity_Id;\n       N     : Node_Id);\n-   --  Find consistent interpretation for operand of negation operator.\n+   --  Find consistent interpretation for operand of negation operator\n \n    procedure Find_Non_Universal_Interpretations\n      (N     : Node_Id;\n@@ -181,7 +181,7 @@ package body Sem_Ch4 is\n      (R     : Node_Id;\n       Op_Id : Entity_Id;\n       N     : Node_Id);\n-   --  Unary arithmetic types: plus, minus, abs.\n+   --  Unary arithmetic types: plus, minus, abs\n \n    procedure Check_Arithmetic_Pair\n      (T1, T2 : Entity_Id;\n@@ -212,6 +212,14 @@ package body Sem_Ch4 is\n    --  for the type is not directly visible. The routine uses this type to emit\n    --  a more informative message.\n \n+   procedure Process_Implicit_Dereference_Prefix\n+     (E : Entity_Id; P : Node_Id);\n+   --  Called when P is the prefix of an implicit dereference, denoting\n+   --  an object E. If in semantics only mode (-gnatc), record that P\n+   --  is a reference to E. Normally, such a reference is generated only\n+   --  when the implicit dereference is expanded into an explicit one.\n+   --  E may be empty, in which case this procedure does nothing.\n+\n    procedure Remove_Abstract_Operations (N : Node_Id);\n    --  Ada 2005: implementation of AI-310. An abstract non-dispatching\n    --  operation is not a candidate interpretation.\n@@ -1235,7 +1243,7 @@ package body Sem_Ch4 is\n \n          End_Interp_List;\n \n-         --  Error if no interpretation of the prefix has an access type.\n+         --  Error if no interpretation of the prefix has an access type\n \n          if Etype (N) = Any_Type then\n             Error_Msg_N\n@@ -1371,7 +1379,7 @@ package body Sem_Ch4 is\n          Exp          : Node_Id;\n          Array_Type   : Entity_Id;\n          Index        : Node_Id;\n-         Entry_Family : Entity_Id;\n+         Pent         : Entity_Id := Empty;\n \n       begin\n          Exp := First (Exprs);\n@@ -1382,38 +1390,32 @@ package body Sem_Ch4 is\n          else\n             Array_Type := Etype (P);\n \n-            --  Prefix must be appropriate for an array type.\n-            --  Dereference the prefix if it is an access type.\n+            if Is_Entity_Name (P) then\n+               Pent := Entity (P);\n+            elsif Nkind (P) = N_Selected_Component\n+              and then Is_Entity_Name (Selector_Name (P))\n+            then\n+               Pent := Entity (Selector_Name (P));\n+            end if;\n+\n+            --  Prefix must be appropriate for an array type, taking into\n+            --  account a possible implicit dereference.\n \n             if Is_Access_Type (Array_Type) then\n                Array_Type := Designated_Type (Array_Type);\n                Error_Msg_NW (Warn_On_Dereference, \"?implicit dereference\", N);\n+               Process_Implicit_Dereference_Prefix (Pent, P);\n             end if;\n \n             if Is_Array_Type (Array_Type) then\n                null;\n \n-            elsif (Is_Entity_Name (P)\n-                     and then\n-                   Ekind (Entity (P)) = E_Entry_Family)\n-               or else\n-                 (Nkind (P) = N_Selected_Component\n-                    and then\n-                  Is_Entity_Name (Selector_Name (P))\n-                    and then\n-                  Ekind (Entity (Selector_Name (P))) = E_Entry_Family)\n-            then\n-               if Is_Entity_Name (P) then\n-                  Entry_Family := Entity (P);\n-               else\n-                  Entry_Family := Entity (Selector_Name (P));\n-               end if;\n-\n+            elsif Present (Pent) and then Ekind (Pent) = E_Entry_Family then\n                Analyze (Exp);\n                Set_Etype (N, Any_Type);\n \n                if not Has_Compatible_Type\n-                 (Exp, Entry_Index_Type (Entry_Family))\n+                 (Exp, Entry_Index_Type (Pent))\n                then\n                   Error_Msg_N (\"invalid index type in entry name\", N);\n \n@@ -1439,13 +1441,7 @@ package body Sem_Ch4 is\n \n             else\n                if Nkind (Parent (N)) = N_Requeue_Statement\n-                 and then\n-                   ((Is_Entity_Name (P)\n-                        and then Ekind (Entity (P)) = E_Entry)\n-                    or else\n-                     (Nkind (P) = N_Selected_Component\n-                       and then Is_Entity_Name (Selector_Name (P))\n-                       and then Ekind (Entity (Selector_Name (P))) = E_Entry))\n+                 and then Present (Pent) and then Ekind (Pent) = E_Entry\n                then\n                   Error_Msg_N\n                     (\"REQUEUE does not permit parameters\", First (Exprs));\n@@ -2471,6 +2467,7 @@ package body Sem_Ch4 is\n       Comp        : Entity_Id;\n       Entity_List : Entity_Id;\n       Prefix_Type : Entity_Id;\n+      Pent        : Entity_Id := Empty;\n       Act_Decl    : Node_Id;\n       In_Scope    : Boolean;\n       Parent_N    : Node_Id;\n@@ -2522,6 +2519,14 @@ package body Sem_Ch4 is\n \n          else\n             Error_Msg_NW (Warn_On_Dereference, \"?implicit dereference\", N);\n+            if Is_Entity_Name (Name) then\n+               Pent := Entity (Name);\n+            elsif Nkind (Name) = N_Selected_Component\n+              and then Is_Entity_Name (Selector_Name (Name))\n+            then\n+               Pent := Entity (Selector_Name (Name));\n+            end if;\n+            Process_Implicit_Dereference_Prefix (Pent, Name);\n          end if;\n \n          Prefix_Type := Designated_Type (Prefix_Type);\n@@ -3961,10 +3966,9 @@ package body Sem_Ch4 is\n \n             Find_Non_Universal_Interpretations (N, R, Op_Id, T1);\n \n-            if Etype (N) = Any_Type then\n-\n-               --  Operator was not visible.\n+            --  Case of operator was not visible, Etype still set to Any_Type\n \n+            if Etype (N) = Any_Type then\n                Found := False;\n             end if;\n          end if;\n@@ -4353,6 +4357,27 @@ package body Sem_Ch4 is\n       end if;\n    end Operator_Check;\n \n+   -----------------------------------------\n+   -- Process_Implicit_Dereference_Prefix --\n+   -----------------------------------------\n+\n+   procedure Process_Implicit_Dereference_Prefix\n+     (E : Entity_Id; P : Entity_Id)\n+   is\n+      Ref : Node_Id;\n+   begin\n+      if Operating_Mode = Check_Semantics and then Present (E) then\n+         --  We create a dummy reference to E to ensure that the reference\n+         --  is not considered as part of an assignment (an implicit\n+         --  dereference can never assign to its prefix). The Comes_From_Source\n+         --  attribute needs to be propagated for accurate warnings.\n+\n+         Ref := New_Reference_To (E, Sloc (P));\n+         Set_Comes_From_Source (Ref, Comes_From_Source (P));\n+         Generate_Reference (E, Ref);\n+      end if;\n+   end Process_Implicit_Dereference_Prefix;\n+\n    --------------------------------\n    -- Remove_Abstract_Operations --\n    --------------------------------\n@@ -4540,7 +4565,7 @@ package body Sem_Ch4 is\n \n             if No (It.Nam) then\n \n-               --  Removal of abstract operation left no viable candidate.\n+               --  Removal of abstract operation left no viable candidate\n \n                Set_Etype (N, Any_Type);\n                Error_Msg_Sloc := Sloc (Abstract_Op);\n@@ -4886,14 +4911,14 @@ package body Sem_Ch4 is\n         (Call_Node       : Node_Id;\n          Node_To_Replace : Node_Id) return Boolean\n       is\n-         Dummy          : Node_Id;\n-         Elmt           : Elmt_Id;\n-         Prim_Op        : Entity_Id;\n-         Prim_Op_Ref    : Node_Id;\n-         Success        : Boolean;\n+         Dummy       : Node_Id;\n+         Elmt        : Elmt_Id;\n+         Prim_Op     : Entity_Id;\n+         Prim_Op_Ref : Node_Id;\n+         Success     : Boolean;\n \n       begin\n-         --  Look for the subprogram in the list of primitive operations.\n+         --  Look for the subprogram in the list of primitive operations\n \n          Elmt := First_Elmt (Primitive_Operations (Obj_Type));\n          while Present (Elmt) loop"}]}