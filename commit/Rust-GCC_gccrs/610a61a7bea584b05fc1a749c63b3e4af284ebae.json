{"sha": "610a61a7bea584b05fc1a749c63b3e4af284ebae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjEwYTYxYTdiZWE1ODRiMDVmYzFhNzQ5YzYzYjNlNGFmMjg0ZWJhZQ==", "commit": {"author": {"name": "Aditya Kumar", "email": "aditya.k7@samsung.com", "date": "2015-11-30T20:39:16Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2015-11-30T20:39:16Z"}, "message": "check for ISL generated code that leads to division by zero\n\nwe used to generate modulo and division by zero because ISL uses big numbers\nwhich translate to zero in modulo arithmetic.  The patch also improves error handling\nand bails out early in case of wrong code gen.\n\n\tPR tree-optimization/68565\n\t* graphite-isl-ast-to-gimple.c (binary_op_to_tree): Early return on\n\tcodegen_error.  Fail when rhs of division operations is integer_zerop.\n\t(ternary_op_to_tree): Early return on codegen_error.\n\t(unary_op_to_tree): Same.\n\t(nary_op_to_tree): Same.\n\t(gcc_expression_from_isl_expr_op): Same.\n\t(gcc_expression_from_isl_expression): Same.\n\t(graphite_create_new_loop): On codegen_error continue generating\n\twrong code.\n\t(graphite_create_new_loop_guard): Same.\n\t(build_iv_mapping): Same.\n\t(graphite_create_new_guard): Same.\n\n\t* gfortran.dg/graphite/pr68565.f90: New.\n\nCo-Authored-By: Sebastian Pop <s.pop@samsung.com>\n\nFrom-SVN: r231086", "tree": {"sha": "f513f6a889d0a05a622ff54b851858c1b94032b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f513f6a889d0a05a622ff54b851858c1b94032b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/610a61a7bea584b05fc1a749c63b3e4af284ebae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/610a61a7bea584b05fc1a749c63b3e4af284ebae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/610a61a7bea584b05fc1a749c63b3e4af284ebae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/610a61a7bea584b05fc1a749c63b3e4af284ebae/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49385686db08da967279598d5079050794884e58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49385686db08da967279598d5079050794884e58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49385686db08da967279598d5079050794884e58"}], "stats": {"total": 138, "additions": 136, "deletions": 2}, "files": [{"sha": "a68582dae91eca77ab698579510b419fec066ddf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610a61a7bea584b05fc1a749c63b3e4af284ebae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610a61a7bea584b05fc1a749c63b3e4af284ebae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=610a61a7bea584b05fc1a749c63b3e4af284ebae", "patch": "@@ -1,3 +1,20 @@\n+2015-11-30  Aditya Kumar  <aditya.k7@samsung.com>\n+\t    Sebastian Pop  <s.pop@samsung.com>\n+\n+\tPR tree-optimization/68565\n+\t* graphite-isl-ast-to-gimple.c (binary_op_to_tree): Early return on\n+\tcodegen_error.  Fail when rhs of division operations is integer_zerop.\n+\t(ternary_op_to_tree): Early return on codegen_error.\n+\t(unary_op_to_tree): Same.\n+\t(nary_op_to_tree): Same.\n+\t(gcc_expression_from_isl_expr_op): Same.\n+\t(gcc_expression_from_isl_expression): Same.\n+\t(graphite_create_new_loop): On codegen_error continue generating\n+\twrong code.\n+\t(graphite_create_new_loop_guard): Same.\n+\t(build_iv_mapping): Same.\n+\t(graphite_create_new_guard): Same.\n+\n 2015-11-30  Aditya Kumar  <aditya.k7@samsung.com>\n \t    Sebastian Pop  <s.pop@samsung.com>\n "}, {"sha": "bfce316954994b982c53b1c45ab785d6b82a5905", "filename": "gcc/graphite-isl-ast-to-gimple.c", "status": "modified", "additions": 83, "deletions": 2, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610a61a7bea584b05fc1a749c63b3e4af284ebae/gcc%2Fgraphite-isl-ast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610a61a7bea584b05fc1a749c63b3e4af284ebae/gcc%2Fgraphite-isl-ast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-isl-ast-to-gimple.c?ref=610a61a7bea584b05fc1a749c63b3e4af284ebae", "patch": "@@ -502,7 +502,7 @@ class translate_isl_ast_to_gimple\n tree\n translate_isl_ast_to_gimple::\n gcc_expression_from_isl_ast_expr_id (tree type,\n-\t\t\t\t     __isl_keep isl_ast_expr *expr_id,\n+\t\t\t\t     __isl_take isl_ast_expr *expr_id,\n \t\t\t\t     ivs_params &ip)\n {\n   gcc_assert (isl_ast_expr_get_type (expr_id) == isl_ast_expr_id);\n@@ -550,8 +550,13 @@ binary_op_to_tree (tree type, __isl_take isl_ast_expr *expr, ivs_params &ip)\n   tree tree_lhs_expr = gcc_expression_from_isl_expression (type, arg_expr, ip);\n   arg_expr = isl_ast_expr_get_op_arg (expr, 1);\n   tree tree_rhs_expr = gcc_expression_from_isl_expression (type, arg_expr, ip);\n+\n   enum isl_ast_op_type expr_type = isl_ast_expr_get_op_type (expr);\n   isl_ast_expr_free (expr);\n+\n+  if (codegen_error)\n+    return NULL_TREE;\n+\n   switch (expr_type)\n     {\n     case isl_ast_op_add:\n@@ -564,15 +569,43 @@ binary_op_to_tree (tree type, __isl_take isl_ast_expr *expr, ivs_params &ip)\n       return fold_build2 (MULT_EXPR, type, tree_lhs_expr, tree_rhs_expr);\n \n     case isl_ast_op_div:\n+      /* As ISL operates on arbitrary precision numbers, we may end up with\n+\t division by 2^64 that is folded to 0.  */\n+      if (integer_zerop (tree_rhs_expr))\n+\t{\n+\t  codegen_error = true;\n+\t  return NULL_TREE;\n+\t}\n       return fold_build2 (EXACT_DIV_EXPR, type, tree_lhs_expr, tree_rhs_expr);\n \n     case isl_ast_op_pdiv_q:\n+      /* As ISL operates on arbitrary precision numbers, we may end up with\n+\t division by 2^64 that is folded to 0.  */\n+      if (integer_zerop (tree_rhs_expr))\n+\t{\n+\t  codegen_error = true;\n+\t  return NULL_TREE;\n+\t}\n       return fold_build2 (TRUNC_DIV_EXPR, type, tree_lhs_expr, tree_rhs_expr);\n \n     case isl_ast_op_pdiv_r:\n+      /* As ISL operates on arbitrary precision numbers, we may end up with\n+\t division by 2^64 that is folded to 0.  */\n+      if (integer_zerop (tree_rhs_expr))\n+\t{\n+\t  codegen_error = true;\n+\t  return NULL_TREE;\n+\t}\n       return fold_build2 (TRUNC_MOD_EXPR, type, tree_lhs_expr, tree_rhs_expr);\n \n     case isl_ast_op_fdiv_q:\n+      /* As ISL operates on arbitrary precision numbers, we may end up with\n+\t division by 2^64 that is folded to 0.  */\n+      if (integer_zerop (tree_rhs_expr))\n+\t{\n+\t  codegen_error = true;\n+\t  return NULL_TREE;\n+\t}\n       return fold_build2 (FLOOR_DIV_EXPR, type, tree_lhs_expr, tree_rhs_expr);\n \n     case isl_ast_op_and:\n@@ -620,6 +653,9 @@ ternary_op_to_tree (tree type, __isl_take isl_ast_expr *expr, ivs_params &ip)\n   tree tree_third_expr\n     = gcc_expression_from_isl_expression (type, arg_expr, ip);\n   isl_ast_expr_free (expr);\n+\n+  if (codegen_error)\n+    return NULL_TREE;\n   return fold_build3 (COND_EXPR, type, tree_first_expr,\n \t\t      tree_second_expr, tree_third_expr);\n }\n@@ -635,7 +671,7 @@ unary_op_to_tree (tree type, __isl_take isl_ast_expr *expr, ivs_params &ip)\n   isl_ast_expr *arg_expr = isl_ast_expr_get_op_arg (expr, 0);\n   tree tree_expr = gcc_expression_from_isl_expression (type, arg_expr, ip);\n   isl_ast_expr_free (expr);\n-  return fold_build1 (NEGATE_EXPR, type, tree_expr);\n+  return codegen_error ? NULL_TREE : fold_build1 (NEGATE_EXPR, type, tree_expr);\n }\n \n /* Converts an isl_ast_expr_op expression E with unknown number of arguments\n@@ -661,11 +697,25 @@ nary_op_to_tree (tree type, __isl_take isl_ast_expr *expr, ivs_params &ip)\n     }\n   isl_ast_expr *arg_expr = isl_ast_expr_get_op_arg (expr, 0);\n   tree res = gcc_expression_from_isl_expression (type, arg_expr, ip);\n+\n+  if (codegen_error)\n+    {\n+      isl_ast_expr_free (expr);\n+      return NULL_TREE;\n+    }\n+\n   int i;\n   for (i = 1; i < isl_ast_expr_get_op_n_arg (expr); i++)\n     {\n       arg_expr = isl_ast_expr_get_op_arg (expr, i);\n       tree t = gcc_expression_from_isl_expression (type, arg_expr, ip);\n+\n+      if (codegen_error)\n+\t{\n+\t  isl_ast_expr_free (expr);\n+\t  return NULL_TREE;\n+\t}\n+\n       res = fold_build2 (op_code, type, res, t);\n     }\n   isl_ast_expr_free (expr);\n@@ -680,6 +730,12 @@ translate_isl_ast_to_gimple::\n gcc_expression_from_isl_expr_op (tree type, __isl_take isl_ast_expr *expr,\n \t\t\t\t ivs_params &ip)\n {\n+  if (codegen_error)\n+    {\n+      isl_ast_expr_free (expr);\n+      return NULL_TREE;\n+    }\n+\n   gcc_assert (isl_ast_expr_get_type (expr) == isl_ast_expr_op);\n   switch (isl_ast_expr_get_op_type (expr))\n     {\n@@ -732,6 +788,12 @@ translate_isl_ast_to_gimple::\n gcc_expression_from_isl_expression (tree type, __isl_take isl_ast_expr *expr,\n \t\t\t\t    ivs_params &ip)\n {\n+  if (codegen_error)\n+    {\n+      isl_ast_expr_free (expr);\n+      return NULL_TREE;\n+    }\n+\n   switch (isl_ast_expr_get_type (expr))\n     {\n     case isl_ast_expr_id:\n@@ -766,6 +828,11 @@ graphite_create_new_loop (edge entry_edge, __isl_keep isl_ast_node *node_for,\n {\n   isl_ast_expr *for_inc = isl_ast_node_for_get_inc (node_for);\n   tree stride = gcc_expression_from_isl_expression (type, for_inc, ip);\n+\n+  /* To fail code generation, we generate wrong code until we discard it.  */\n+  if (codegen_error)\n+    stride = integer_zero_node;\n+\n   tree ivvar = create_tmp_var (type, \"graphite_IV\");\n   tree iv, iv_after_increment;\n   loop_p loop = create_empty_loop_on_edge\n@@ -909,8 +976,14 @@ graphite_create_new_loop_guard (edge entry_edge,\n     build_nonstandard_integer_type (graphite_expression_type_precision, 0);\n   isl_ast_expr *for_init = isl_ast_node_for_get_init (node_for);\n   *lb = gcc_expression_from_isl_expression (*type, for_init, ip);\n+  /* To fail code generation, we generate wrong code until we discard it.  */\n+  if (codegen_error)\n+    *lb = integer_zero_node;\n   isl_ast_expr *upper_bound = get_upper_bound (node_for);\n   *ub = gcc_expression_from_isl_expression (*type, upper_bound, ip);\n+  /* To fail code generation, we generate wrong code until we discard it.  */\n+  if (codegen_error)\n+    *ub = integer_zero_node;\n   \n   /* When ub is simply a constant or a parameter, use lb <= ub.  */\n   if (TREE_CODE (*ub) == INTEGER_CST || TREE_CODE (*ub) == SSA_NAME)\n@@ -993,6 +1066,10 @@ build_iv_mapping (vec<tree> iv_map, gimple_poly_bb_p gbb,\n       tree type =\n \tbuild_nonstandard_integer_type (graphite_expression_type_precision, 0);\n       tree t = gcc_expression_from_isl_expression (type, arg_expr, ip);\n+      /* To fail code generation, we generate wrong code until we discard it.  */\n+      if (codegen_error)\n+\tt = integer_zero_node;\n+\n       loop_p old_loop = gbb_loop_at_index (gbb, region, i - 1);\n       iv_map[old_loop->num] = t;\n     }\n@@ -1089,6 +1166,10 @@ graphite_create_new_guard (edge entry_edge, __isl_take isl_ast_expr *if_cond,\n   tree type =\n     build_nonstandard_integer_type (graphite_expression_type_precision, 0);\n   tree cond_expr = gcc_expression_from_isl_expression (type, if_cond, ip);\n+  /* To fail code generation, we generate wrong code until we discard it.  */\n+  if (codegen_error)\n+    cond_expr = integer_zero_node;\n+\n   edge exit_edge = create_empty_if_region_on_edge (entry_edge, cond_expr);\n   return exit_edge;\n }"}, {"sha": "d3816a259e61c925e021715ebc7ec3e9330ee381", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610a61a7bea584b05fc1a749c63b3e4af284ebae/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610a61a7bea584b05fc1a749c63b3e4af284ebae/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=610a61a7bea584b05fc1a749c63b3e4af284ebae", "patch": "@@ -1,3 +1,9 @@\n+2015-11-30  Aditya Kumar  <aditya.k7@samsung.com>\n+\t    Sebastian Pop  <s.pop@samsung.com>\n+\n+\tPR tree-optimization/68565\n+\t* gfortran.dg/graphite/pr68565.f90: New.\n+\n 2015-11-30  Aditya Kumar  <aditya.k7@samsung.com>\n \t    Sebastian Pop  <s.pop@samsung.com>\n "}, {"sha": "c8335241257cf6f53dd3e09d74fc0facf9b7bad2", "filename": "gcc/testsuite/gfortran.dg/graphite/pr68565.f90", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610a61a7bea584b05fc1a749c63b3e4af284ebae/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr68565.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610a61a7bea584b05fc1a749c63b3e4af284ebae/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr68565.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr68565.f90?ref=610a61a7bea584b05fc1a749c63b3e4af284ebae", "patch": "@@ -0,0 +1,30 @@\n+! { dg-do run }\n+! { dg-options \"-floop-nest-optimize\" }\n+\n+MODULE test\n+  IMPLICIT NONE\n+  TYPE subset_type\n+     INTEGER                                    :: ncon_tot\n+     REAL(KIND=8),DIMENSION(:,:),ALLOCATABLE   :: coeff\n+  END TYPE\n+CONTAINS\n+  SUBROUTINE foo(subset)\n+      TYPE(subset_type)                        :: subset\n+      INTEGER :: icon1\n+      DO icon1=1,subset%ncon_tot\n+       subset%coeff(:,icon1)=subset%coeff(:,icon1)/&\n+        SQRT(DOT_PRODUCT(subset%coeff(:,icon1),subset%coeff(:,icon1)))\n+      END DO\n+  END SUBROUTINE\n+END MODULE\n+\n+USE test\n+    TYPE(subset_type)                        :: subset\n+    INTEGER, VOLATILE :: n1=7,n2=4\n+    ALLOCATE(subset%coeff(n1,n2))\n+    CALL RANDOM_NUMBER(subset%coeff)\n+    subset%coeff=subset%coeff-0.5\n+    subset%ncon_tot=n2\n+    CALL foo(subset)\n+    WRITE(6,*) MAXVAL(subset%coeff)\n+END"}]}