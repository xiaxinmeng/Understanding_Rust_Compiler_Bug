{"sha": "ed6814f7b30925bf4a019009a963bd46fd6a7077", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ2ODE0ZjdiMzA5MjViZjRhMDE5MDA5YTk2M2JkNDZmZDZhNzA3Nw==", "commit": {"author": {"name": "Bernardo Innocenti", "email": "bernie@develer.com", "date": "2004-02-08T04:46:42Z"}, "committer": {"name": "Bernardo Innocenti", "email": "bernie@gcc.gnu.org", "date": "2004-02-08T04:46:42Z"}, "message": "Remove trailing whitespace (see ChangeLog for longwinded description).\n\nFrom-SVN: r77479", "tree": {"sha": "2902b23b00a318ceb938c69b9cdf28cbe0cc2e49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2902b23b00a318ceb938c69b9cdf28cbe0cc2e49"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed6814f7b30925bf4a019009a963bd46fd6a7077", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed6814f7b30925bf4a019009a963bd46fd6a7077", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed6814f7b30925bf4a019009a963bd46fd6a7077", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed6814f7b30925bf4a019009a963bd46fd6a7077/comments", "author": {"login": "codewiz", "id": 1184492, "node_id": "MDQ6VXNlcjExODQ0OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1184492?v=4", "gravatar_id": "", "url": "https://api.github.com/users/codewiz", "html_url": "https://github.com/codewiz", "followers_url": "https://api.github.com/users/codewiz/followers", "following_url": "https://api.github.com/users/codewiz/following{/other_user}", "gists_url": "https://api.github.com/users/codewiz/gists{/gist_id}", "starred_url": "https://api.github.com/users/codewiz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/codewiz/subscriptions", "organizations_url": "https://api.github.com/users/codewiz/orgs", "repos_url": "https://api.github.com/users/codewiz/repos", "events_url": "https://api.github.com/users/codewiz/events{/privacy}", "received_events_url": "https://api.github.com/users/codewiz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f276fb546f0730ae3f2abc33bd5ae00a085a0cf3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f276fb546f0730ae3f2abc33bd5ae00a085a0cf3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f276fb546f0730ae3f2abc33bd5ae00a085a0cf3"}], "stats": {"total": 6904, "additions": 3470, "deletions": 3434}, "files": [{"sha": "97126b3bae5f1bf4f8e10a67693b0967464db6cd", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -1,3 +1,39 @@\n+2004-02-08  Bernardo Innocenti  <bernie@develer.com>\n+\n+\t* include/bits/allocator.h, include/bits/basic_ios.h,\n+\tinclude/bits/basic_ios.tcc, include/bits/basic_string.h,\n+\tinclude/bits/basic_string.tcc, include/bits/boost_concept_check.h,\n+\tinclude/bits/char_traits.h, include/bits/codecvt.h,\n+\tinclude/bits/concurrence.h, include/bits/cpp_type_traits.h,\n+\tinclude/bits/demangle.h, include/bits/deque.tcc,\n+\tinclude/bits/fstream.tcc, include/bits/functexcept.h,\n+\tinclude/bits/gslice.h, include/bits/gslice_array.h,\n+\tinclude/bits/indirect_array.h, include/bits/ios_base.h,\n+\tinclude/bits/istream.tcc, include/bits/list.tcc,\n+\tinclude/bits/locale_classes.h, include/bits/locale_facets.h,\n+\tinclude/bits/locale_facets.tcc, include/bits/localefwd.h,\n+\tinclude/bits/mask_array.h, include/bits/ostream.tcc,\n+\tinclude/bits/postypes.h, include/bits/slice_array.h,\n+\tinclude/bits/sstream.tcc, include/bits/stl_algo.h,\n+\tinclude/bits/stl_algobase.h, include/bits/stl_bvector.h,\n+\tinclude/bits/stl_construct.h, include/bits/stl_deque.h,\n+\tinclude/bits/stl_function.h, include/bits/stl_heap.h,\n+\tinclude/bits/stl_iterator.h, include/bits/stl_iterator_base_funcs.h,\n+\tinclude/bits/stl_list.h, include/bits/stl_map.h,\n+\tinclude/bits/stl_multimap.h, include/bits/stl_multiset.h,\n+\tinclude/bits/stl_numeric.h, include/bits/stl_pair.h,\n+\tinclude/bits/stl_queue.h, include/bits/stl_raw_storage_iter.h,\n+\tinclude/bits/stl_relops.h, include/bits/stl_set.h,\n+\tinclude/bits/stl_stack.h, include/bits/stl_tempbuf.h,\n+\tinclude/bits/stl_threads.h, include/bits/stl_tree.h,\n+\tinclude/bits/stl_uninitialized.h, include/bits/stl_vector.h,\n+\tinclude/bits/stream_iterator.h, include/bits/streambuf.tcc,\n+\tinclude/bits/streambuf_iterator.h,include/bits/stringfwd.h,\n+\tinclude/bits/type_traits.h, include/bits/valarray_after.h,\n+\tinclude/bits/valarray_array.h, include/bits/valarray_array.tcc,\n+\tinclude/bits/valarray_before.h, include/bits/vector.tcc: Remove\n+\ttrailing whitespace.\n+\n 2004-02-06  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/bits/basic_string.h: Fix comment."}, {"sha": "a1b04b4338daea7c2b544664680544921a704dec", "filename": "libstdc++-v3/include/bits/allocator.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -84,7 +84,7 @@ namespace std\n    *  (See @link Allocators allocators info @endlink for more.)\n    */\n   template<typename _Tp>\n-    class allocator: public __glibcxx_default_allocator<_Tp>  \n+    class allocator: public __glibcxx_default_allocator<_Tp>\n     {\n    public:\n       typedef size_t     size_type;\n@@ -101,7 +101,7 @@ namespace std\n \n       allocator() throw() { }\n \n-      allocator(const allocator& a) throw() \n+      allocator(const allocator& a) throw()\n       : __glibcxx_default_allocator<_Tp>(a) { }\n \n       template<typename _Tp1>"}, {"sha": "8e0b31e37de3f3c20fcfc9be61736e51a7a9dcf5", "filename": "libstdc++-v3/include/bits/basic_ios.h", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_ios.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_ios.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_ios.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -1,6 +1,6 @@\n // Iostreams base classes -*- C++ -*-\n \n-// Copyright (C) 1997, 1998, 1999, 2001, 2002, 2003 \n+// Copyright (C) 1997, 1998, 1999, 2001, 2002, 2003\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -43,7 +43,7 @@\n #include <bits/locale_classes.h>\n #include <bits/locale_facets.h>\n \n-namespace std \n+namespace std\n {\n   // 27.4.5  Template class basic_ios\n   /**\n@@ -76,12 +76,12 @@ namespace std\n        *  @endif\n       */\n       typedef ctype<_CharT>                          __ctype_type;\n-      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >     \n+      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >\n \t\t\t\t\t\t     __num_put_type;\n-      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >     \n-      \t\t\t\t\t\t     __num_get_type;\n+      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >\n+\t\t\t\t\t\t     __num_get_type;\n       //@}\n-      \n+\n       // Data members:\n     protected:\n       basic_ostream<_CharT, _Traits>*                _M_tie;\n@@ -90,7 +90,7 @@ namespace std\n       basic_streambuf<_CharT, _Traits>*              _M_streambuf;\n \n       // Cached use_facet<ctype>, which is based on the current locale info.\n-      const __ctype_type*                            _M_ctype;      \n+      const __ctype_type*                            _M_ctype;\n       // For ostream.\n       const __num_put_type*                          _M_num_put;\n       // For istream.\n@@ -104,11 +104,11 @@ namespace std\n        *  This allows you to write constructs such as\n        *  \"if (!a_stream) ...\" and \"while (a_stream) ...\"\n       */\n-      operator void*() const \n+      operator void*() const\n       { return this->fail() ? 0 : const_cast<basic_ios*>(this); }\n \n-      bool \n-      operator!() const \n+      bool\n+      operator!() const\n       { return this->fail(); }\n       //@}\n \n@@ -119,8 +119,8 @@ namespace std\n        *  See std::ios_base::iostate for the possible bit values.  Most\n        *  users will call one of the interpreting wrappers, e.g., good().\n       */\n-      iostate \n-      rdstate() const \n+      iostate\n+      rdstate() const\n       { return _M_streambuf_state; }\n \n       /**\n@@ -130,7 +130,7 @@ namespace std\n        *  See std::ios_base::iostate for the possible bit values.  Most\n        *  users will not need to pass an argument.\n       */\n-      void \n+      void\n       clear(iostate __state = goodbit);\n \n       /**\n@@ -139,19 +139,19 @@ namespace std\n        *\n        *  See std::ios_base::iostate for the possible bit values.\n       */\n-      void \n-      setstate(iostate __state) \n+      void\n+      setstate(iostate __state)\n       { this->clear(this->rdstate() | __state); }\n \n       // Flip the internal state on for the proper state bits, then re\n       // throws the propagated exception if bit also set in\n       // exceptions().\n       void\n-      _M_setstate(iostate __state) \n-      { \n+      _M_setstate(iostate __state)\n+      {\n \t// 27.6.1.2.1 Common requirements.\n \t// Turn this on without causing an ios::failure to be thrown.\n-\t_M_streambuf_state |= __state; \n+\t_M_streambuf_state |= __state;\n \tif (this->exceptions() & __state)\n \t  __throw_exception_again;\n       }\n@@ -162,8 +162,8 @@ namespace std\n        *\n        *  A wrapper around rdstate.\n       */\n-      bool \n-      good() const \n+      bool\n+      good() const\n       { return this->rdstate() == 0; }\n \n       /**\n@@ -172,8 +172,8 @@ namespace std\n        *\n        *  Note that other iostate flags may also be set.\n       */\n-      bool \n-      eof() const \n+      bool\n+      eof() const\n       { return (this->rdstate() & eofbit) != 0; }\n \n       /**\n@@ -183,8 +183,8 @@ namespace std\n        *  Checking the badbit in fail() is historical practice.\n        *  Note that other iostate flags may also be set.\n       */\n-      bool \n-      fail() const \n+      bool\n+      fail() const\n       { return (this->rdstate() & (badbit | failbit)) != 0; }\n \n       /**\n@@ -193,8 +193,8 @@ namespace std\n        *\n        *  Note that other iostate flags may also be set.\n       */\n-      bool \n-      bad() const \n+      bool\n+      bad() const\n       { return (this->rdstate() & badbit) != 0; }\n \n       /**\n@@ -204,8 +204,8 @@ namespace std\n        *  This changes nothing in the stream.  See the one-argument version\n        *  of exceptions(iostate) for the meaning of the return value.\n       */\n-      iostate \n-      exceptions() const \n+      iostate\n+      exceptions() const\n       { return _M_exception; }\n \n       /**\n@@ -224,26 +224,26 @@ namespace std\n        *  #include <iostream>\n        *  #include <fstream>\n        *  #include <exception>\n-       *  \n+       *\n        *  int main()\n        *  {\n        *      std::set_terminate (__gnu_cxx::__verbose_terminate_handler);\n-       *  \n+       *\n        *      std::ifstream f (\"/etc/motd\");\n-       *  \n+       *\n        *      std::cerr << \"Setting badbit\\n\";\n        *      f.setstate (std::ios_base::badbit);\n-       *  \n+       *\n        *      std::cerr << \"Setting exception mask\\n\";\n        *      f.exceptions (std::ios_base::badbit);\n        *  }\n        *  @endcode\n       */\n-      void \n-      exceptions(iostate __except) \n-      { \n-        _M_exception = __except; \n-        this->clear(_M_streambuf_state); \n+      void\n+      exceptions(iostate __except)\n+      {\n+        _M_exception = __except;\n+        this->clear(_M_streambuf_state);\n       }\n \n       // Constructor/destructor:\n@@ -252,8 +252,8 @@ namespace std\n        *\n        *  The parameter is passed by derived streams.\n       */\n-      explicit \n-      basic_ios(basic_streambuf<_CharT, _Traits>* __sb) \n+      explicit\n+      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)\n       : ios_base(), _M_ctype(0), _M_num_put(0), _M_num_get(0)\n       { this->init(__sb); }\n \n@@ -263,9 +263,9 @@ namespace std\n        *  The destructor does nothing.  More specifically, it does not\n        *  destroy the streambuf held by rdbuf().\n       */\n-      virtual \n+      virtual\n       ~basic_ios() { }\n-      \n+\n       // Members:\n       /**\n        *  @brief  Fetches the current @e tied stream.\n@@ -277,7 +277,7 @@ namespace std\n        *  first flushed.  For example, @c std::cin is tied to @c std::cout.\n       */\n       basic_ostream<_CharT, _Traits>*\n-      tie() const      \n+      tie() const\n       { return _M_tie; }\n \n       /**\n@@ -303,7 +303,7 @@ namespace std\n        *  This does not change the state of the stream.\n       */\n       basic_streambuf<_CharT, _Traits>*\n-      rdbuf() const    \n+      rdbuf() const\n       { return _M_streambuf; }\n \n       /**\n@@ -328,7 +328,7 @@ namespace std\n        *  foo.ios::rdbuf(p);            // ios == basic_ios<char>\n        *  @endcode\n       */\n-      basic_streambuf<_CharT, _Traits>* \n+      basic_streambuf<_CharT, _Traits>*\n       rdbuf(basic_streambuf<_CharT, _Traits>* __sb);\n \n       /**\n@@ -351,15 +351,15 @@ namespace std\n        *\n        *  It defaults to a space (' ') in the current locale.\n       */\n-      char_type \n-      fill() const \n+      char_type\n+      fill() const\n       {\n \tif (!_M_fill_init)\n \t  {\n \t    _M_fill = this->widen(' ');\n \t    _M_fill_init = true;\n \t  }\n-\treturn _M_fill; \n+\treturn _M_fill;\n       }\n \n       /**\n@@ -371,7 +371,7 @@ namespace std\n        *  have been requested (e.g., via setw), Q characters are actually\n        *  used, and Q<P.  It defaults to a space (' ') in the current locale.\n       */\n-      char_type \n+      char_type\n       fill(char_type __ch)\n       {\n \tchar_type __old = this->fill();\n@@ -391,7 +391,7 @@ namespace std\n        *  Additional l10n notes are at\n        *  http://gcc.gnu.org/onlinedocs/libstdc++/22_locale/howto.html\n       */\n-      locale \n+      locale\n       imbue(const locale& __loc);\n \n       /**\n@@ -411,7 +411,7 @@ namespace std\n        *  Additional l10n notes are at\n        *  http://gcc.gnu.org/onlinedocs/libstdc++/22_locale/howto.html\n       */\n-      char \n+      char\n       narrow(char_type __c, char __dfault) const;\n \n       /**\n@@ -429,9 +429,9 @@ namespace std\n        *  Additional l10n notes are at\n        *  http://gcc.gnu.org/onlinedocs/libstdc++/22_locale/howto.html\n       */\n-      char_type \n+      char_type\n       widen(char __c) const;\n-     \n+\n     protected:\n       // 27.4.5.1  basic_ios constructors\n       /**\n@@ -449,7 +449,7 @@ namespace std\n        *  This is called from the public constructor.  It is not virtual and\n        *  cannot be redefined.\n       */\n-      void \n+      void\n       init(basic_streambuf<_CharT, _Traits>* __sb);\n \n       void"}, {"sha": "cc730672af911d5d7d19e9cbba755cdb2d5fe83a", "filename": "libstdc++-v3/include/bits/basic_ios.tcc", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_ios.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_ios.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_ios.tcc?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -37,17 +37,17 @@ namespace std\n   template<typename _CharT, typename _Traits>\n     void\n     basic_ios<_CharT, _Traits>::clear(iostate __state)\n-    { \n+    {\n       if (this->rdbuf())\n \t_M_streambuf_state = __state;\n       else\n \t  _M_streambuf_state = __state | badbit;\n       if (this->exceptions() & this->rdstate())\n \t__throw_ios_failure(__N(\"basic_ios::clear\"));\n     }\n-  \n+\n   template<typename _CharT, typename _Traits>\n-    basic_streambuf<_CharT, _Traits>* \n+    basic_streambuf<_CharT, _Traits>*\n     basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)\n     {\n       basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;\n@@ -66,45 +66,45 @@ namespace std\n \t{\n \t  // Per 27.1.1, do not call imbue, yet must trash all caches\n \t  // associated with imbue()\n-\t  \n+\n \t  // Alloc any new word array first, so if it fails we have \"rollback\".\n \t  _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?\n \t                     _M_local_word : new _Words[__rhs._M_word_size];\n \n \t  // Bump refs before doing callbacks, for safety.\n \t  _Callback_list* __cb = __rhs._M_callbacks;\n-\t  if (__cb) \n+\t  if (__cb)\n \t    __cb->_M_add_reference();\n \t  _M_call_callbacks(erase_event);\n-\t  if (_M_word != _M_local_word) \n+\t  if (_M_word != _M_local_word)\n \t    {\n \t      delete [] _M_word;\n \t      _M_word = 0;\n \t    }\n \t  _M_dispose_callbacks();\n \n \t  // NB: Don't want any added during above.\n-\t  _M_callbacks = __cb;  \n+\t  _M_callbacks = __cb;\n \t  for (int __i = 0; __i < __rhs._M_word_size; ++__i)\n \t    __words[__i] = __rhs._M_word[__i];\n-\t  if (_M_word != _M_local_word) \n+\t  if (_M_word != _M_local_word)\n \t    {\n \t      delete [] _M_word;\n \t      _M_word = 0;\n \t    }\n \t  _M_word = __words;\n \t  _M_word_size = __rhs._M_word_size;\n-\t  \n+\n \t  this->flags(__rhs.flags());\n \t  this->width(__rhs.width());\n \t  this->precision(__rhs.precision());\n \t  this->tie(__rhs.tie());\n \t  this->fill(__rhs.fill());\n \t  _M_ios_locale = __rhs.getloc();\n \t  _M_cache_locale(_M_ios_locale);\n-\t  \n+\n \t  _M_call_callbacks(copyfmt_event);\n-\t  \n+\n \t  // The next is required to be the last assignment.\n \t  this->exceptions(__rhs.exceptions());\n \t}\n@@ -172,13 +172,13 @@ namespace std\n       if (__builtin_expect(has_facet<__ctype_type>(__loc), true))\n \t_M_ctype = &use_facet<__ctype_type>(__loc);\n       if (__builtin_expect(has_facet<__num_put_type>(__loc), true))\n-\t_M_num_put = &use_facet<__num_put_type>(__loc); \n+\t_M_num_put = &use_facet<__num_put_type>(__loc);\n       if (__builtin_expect(has_facet<__num_get_type>(__loc), true))\n-\t_M_num_get = &use_facet<__num_get_type>(__loc); \n+\t_M_num_get = &use_facet<__num_get_type>(__loc);\n     }\n \n   // Inhibit implicit instantiations for required instantiations,\n-  // which are defined via explicit instantiations elsewhere.  \n+  // which are defined via explicit instantiations elsewhere.\n   // NB:  This syntax is a GNU extension.\n #if _GLIBCXX_EXTERN_TEMPLATE\n   extern template class basic_ios<char>;\n@@ -189,4 +189,4 @@ namespace std\n #endif\n } // namespace std\n \n-#endif \n+#endif"}, {"sha": "26c33429ee4ffb202e354c78c6d000fc81411e9c", "filename": "libstdc++-v3/include/bits/basic_string.h", "status": "modified", "additions": 92, "deletions": 92, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -111,20 +111,20 @@ namespace std\n     {\n       // Types:\n     public:\n-      typedef _Traits \t\t\t\t\t    traits_type;\n-      typedef typename _Traits::char_type \t\t    value_type;\n-      typedef _Alloc \t\t\t\t\t    allocator_type;\n-      typedef typename _Alloc::size_type \t\t    size_type;\n-      typedef typename _Alloc::difference_type \t\t    difference_type;\n-      typedef typename _Alloc::reference \t\t    reference;\n-      typedef typename _Alloc::const_reference \t\t    const_reference;\n-      typedef typename _Alloc::pointer \t\t\t    pointer;\n-      typedef typename _Alloc::const_pointer \t   \t    const_pointer;\n+      typedef _Traits\t\t\t\t\t    traits_type;\n+      typedef typename _Traits::char_type\t\t    value_type;\n+      typedef _Alloc\t\t\t\t\t    allocator_type;\n+      typedef typename _Alloc::size_type\t\t    size_type;\n+      typedef typename _Alloc::difference_type\t\t    difference_type;\n+      typedef typename _Alloc::reference\t\t    reference;\n+      typedef typename _Alloc::const_reference\t\t    const_reference;\n+      typedef typename _Alloc::pointer\t\t\t    pointer;\n+      typedef typename _Alloc::const_pointer\t\t    const_pointer;\n       typedef __gnu_cxx::__normal_iterator<pointer, basic_string>  iterator;\n       typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>\n                                                             const_iterator;\n-      typedef std::reverse_iterator<const_iterator> \tconst_reverse_iterator;\n-      typedef std::reverse_iterator<iterator> \t\t    reverse_iterator;\n+      typedef std::reverse_iterator<const_iterator>\tconst_reverse_iterator;\n+      typedef std::reverse_iterator<iterator>\t\t    reverse_iterator;\n \n     private:\n       // _Rep: string representation\n@@ -143,8 +143,8 @@ namespace std\n \n       struct _Rep_base\n       {\n-\tsize_type \t\t_M_length;\n-\tsize_type \t\t_M_capacity;\n+\tsize_type\t\t_M_length;\n+\tsize_type\t\t_M_capacity;\n \t_Atomic_word\t\t_M_refcount;\n       };\n \n@@ -166,17 +166,17 @@ namespace std\n \t// Solving for m:\n \t// m = ((npos - sizeof(_Rep))/sizeof(CharT)) - 1\n \t// In addition, this implementation quarters this amount.\n-\tstatic const size_type \t_S_max_size;\n-\tstatic const _CharT \t_S_terminal;\n+\tstatic const size_type\t_S_max_size;\n+\tstatic const _CharT\t_S_terminal;\n \n \t// The following storage is init'd to 0 by the linker, resulting\n         // (carefully) in an empty string with one reference.\n         static size_type _S_empty_rep_storage[];\n \n-        static _Rep& \n+        static _Rep&\n         _S_empty_rep()\n         { return *reinterpret_cast<_Rep*>(&_S_empty_rep_storage); }\n- \n+\n         bool\n \t_M_is_leaked() const\n         { return this->_M_refcount < 0; }\n@@ -246,11 +246,11 @@ namespace std\n       // size that the allocator can hold.\n       /// @var\n       /// Value returned by various member functions when they fail.\n-      static const size_type \tnpos = static_cast<size_type>(-1);\n+      static const size_type\tnpos = static_cast<size_type>(-1);\n \n     private:\n       // Data Members (private):\n-      mutable _Alloc_hider \t_M_dataplus;\n+      mutable _Alloc_hider\t_M_dataplus;\n \n       _CharT*\n       _M_data() const\n@@ -377,7 +377,7 @@ namespace std\n        *  @param  s  Source character array.\n        *  @param  n  Number of characters to copy.\n        *  @param  a  Allocator to use (default is default allocator).\n-       *  \n+       *\n        *  NB: s must have at least n characters, '\\0' has no special\n        *  meaning.\n        */\n@@ -606,9 +606,9 @@ namespace std\n        */\n       const_reference\n       operator[] (size_type __pos) const\n-      { \n+      {\n \t_GLIBCXX_DEBUG_ASSERT(__pos <= size());\n-\treturn _M_data()[__pos]; \n+\treturn _M_data()[__pos];\n       }\n \n       /**\n@@ -731,9 +731,9 @@ namespace std\n        */\n       basic_string&\n       append(const _CharT* __s)\n-      { \n+      {\n \t__glibcxx_requires_string(__s);\n-\treturn this->append(__s, traits_type::length(__s)); \n+\treturn this->append(__s, traits_type::length(__s));\n       }\n \n       /**\n@@ -819,9 +819,9 @@ namespace std\n        */\n       basic_string&\n       assign(const _CharT* __s)\n-      { \n+      {\n \t__glibcxx_requires_string(__s);\n-\treturn this->assign(__s, traits_type::length(__s)); \n+\treturn this->assign(__s, traits_type::length(__s));\n       }\n \n       /**\n@@ -870,7 +870,7 @@ namespace std\n        *  @brief  Insert a range of characters.\n        *  @param p  Iterator referencing location in string to insert at.\n        *  @param beg  Start of range.\n-       *  @param end  End of range. \n+       *  @param end  End of range.\n        *  @throw  std::length_error  If new length exceeds @c max_size().\n        *\n        *  Inserts characters in range [beg,end).  If adding characters causes\n@@ -929,7 +929,7 @@ namespace std\n        *  @return  Reference to this string.\n        *  @throw  std::length_error  If new length exceeds @c max_size().\n        *  @throw  std::out_of_range  If @a pos is beyond the end of this\n-       *  string. \n+       *  string.\n        *\n        *  Inserts the first @a n characters of @a s starting at @a pos.  If\n        *  adding characters causes the length to exceed max_size(),\n@@ -957,9 +957,9 @@ namespace std\n       */\n       basic_string&\n       insert(size_type __pos, const _CharT* __s)\n-      { \n+      {\n \t__glibcxx_requires_string(__s);\n-\treturn this->insert(__pos, __s, traits_type::length(__s)); \n+\treturn this->insert(__pos, __s, traits_type::length(__s));\n       }\n \n       /**\n@@ -1002,7 +1002,7 @@ namespace std\n \tconst size_type __pos = __p - _M_ibegin();\n \t_M_replace_aux(__pos, size_type(0), size_type(1), __c);\n \t_M_rep()->_M_set_leaked();\n- \treturn this->_M_ibegin() + __pos;\n+\treturn this->_M_ibegin() + __pos;\n       }\n \n       /**\n@@ -1035,7 +1035,7 @@ namespace std\n       iterator\n       erase(iterator __position)\n       {\n-\t_GLIBCXX_DEBUG_PEDASSERT(__position >= _M_ibegin() \n+\t_GLIBCXX_DEBUG_PEDASSERT(__position >= _M_ibegin()\n \t\t\t\t && __position < _M_iend());\n \tconst size_type __pos = __position - _M_ibegin();\n \t_M_replace_safe(__pos, size_type(1), NULL, size_type(0));\n@@ -1070,7 +1070,7 @@ namespace std\n        *  @param str  String to insert.\n        *  @return  Reference to this string.\n        *  @throw  std::out_of_range  If @a pos is beyond the end of this\n-       *  string. \n+       *  string.\n        *  @throw  std::length_error  If new length exceeds @c max_size().\n        *\n        *  Removes the characters in the range [pos,pos+n) from this string.\n@@ -1092,7 +1092,7 @@ namespace std\n        *  @param n2  Number of characters from str to use.\n        *  @return  Reference to this string.\n        *  @throw  std::out_of_range  If @a pos1 > size() or @a pos2 >\n-       *  str.size(). \n+       *  str.size().\n        *  @throw  std::length_error  If new length exceeds @c max_size().\n        *\n        *  Removes the characters in the range [pos1,pos1 + n) from this\n@@ -1146,9 +1146,9 @@ namespace std\n       */\n       basic_string&\n       replace(size_type __pos, size_type __n1, const _CharT* __s)\n-      { \n+      {\n \t__glibcxx_requires_string(__s);\n-\treturn this->replace(__pos, __n1, __s, traits_type::length(__s)); \n+\treturn this->replace(__pos, __n1, __s, traits_type::length(__s));\n       }\n \n       /**\n@@ -1207,7 +1207,7 @@ namespace std\n       replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)\n       {\n \t_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n-\t\t\t\t && __i2 <= _M_iend());\t\n+\t\t\t\t && __i2 <= _M_iend());\n \treturn this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);\n       }\n \n@@ -1226,9 +1226,9 @@ namespace std\n       */\n       basic_string&\n       replace(iterator __i1, iterator __i2, const _CharT* __s)\n-      { \n+      {\n \t__glibcxx_requires_string(__s);\n-\treturn this->replace(__i1, __i2, __s, traits_type::length(__s)); \n+\treturn this->replace(__i1, __i2, __s, traits_type::length(__s));\n       }\n \n       /**\n@@ -1247,10 +1247,10 @@ namespace std\n       */\n       basic_string&\n       replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)\n-      { \n+      {\n \t_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n \t\t\t\t && __i2 <= _M_iend());\n-\treturn _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c); \n+\treturn _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);\n       }\n \n       /**\n@@ -1271,40 +1271,40 @@ namespace std\n         basic_string&\n         replace(iterator __i1, iterator __i2,\n \t\t_InputIterator __k1, _InputIterator __k2)\n-        { \n+        {\n \t  _GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n \t\t\t\t   && __i2 <= _M_iend());\n \t  __glibcxx_requires_valid_range(__k1, __k2);\n \t  typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-\t  return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral()); \n+\t  return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());\n \t}\n \n       // Specializations for the common case of pointer and iterator:\n       // useful to avoid the overhead of temporary buffering in _M_replace.\n       basic_string&\n         replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)\n-        { \n+        {\n \t  _GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n \t\t\t\t   && __i2 <= _M_iend());\n \t  __glibcxx_requires_valid_range(__k1, __k2);\n \t  return this->replace(__i1 - _M_ibegin(), __i2 - __i1,\n-\t\t\t       __k1, __k2 - __k1); \n+\t\t\t       __k1, __k2 - __k1);\n \t}\n \n       basic_string&\n-        replace(iterator __i1, iterator __i2, \n+        replace(iterator __i1, iterator __i2,\n \t\tconst _CharT* __k1, const _CharT* __k2)\n-        { \n+        {\n \t  _GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n \t\t\t\t   && __i2 <= _M_iend());\n \t  __glibcxx_requires_valid_range(__k1, __k2);\n \t  return this->replace(__i1 - _M_ibegin(), __i2 - __i1,\n-\t\t\t       __k1, __k2 - __k1); \n+\t\t\t       __k1, __k2 - __k1);\n \t}\n \n       basic_string&\n         replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)\n-        { \n+        {\n \t  _GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n \t\t\t\t   && __i2 <= _M_iend());\n \t  __glibcxx_requires_valid_range(__k1, __k2);\n@@ -1313,9 +1313,9 @@ namespace std\n \t}\n \n       basic_string&\n-        replace(iterator __i1, iterator __i2, \n+        replace(iterator __i1, iterator __i2,\n \t\tconst_iterator __k1, const_iterator __k2)\n-        { \n+        {\n \t  _GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n \t\t\t\t   && __i2 <= _M_iend());\n \t  __glibcxx_requires_valid_range(__k1, __k2);\n@@ -1326,7 +1326,7 @@ namespace std\n     private:\n       template<class _Integer>\n \tbasic_string&\n-\t_M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n, \n+\t_M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,\n \t\t\t    _Integer __val, __true_type)\n         { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }\n \n@@ -1344,7 +1344,7 @@ namespace std\n \t_M_mutate(__pos1, __n1, __n2);\n \tif (__n2)\n \t  traits_type::assign(_M_data() + __pos1, __n2, __c);\n-\treturn *this;\t\n+\treturn *this;\n       }\n \n       basic_string&\n@@ -1354,7 +1354,7 @@ namespace std\n \t_M_mutate(__pos1, __n1, __n2);\n \tif (__n2)\n \t  traits_type::copy(_M_data() + __pos1, __s, __n2);\n-\treturn *this;\t\n+\treturn *this;\n       }\n \n       // _S_construct_aux is used to implement the 21.3.1 para 15 which\n@@ -1490,9 +1490,9 @@ namespace std\n       */\n       size_type\n       find(const _CharT* __s, size_type __pos = 0) const\n-      { \n+      {\n \t__glibcxx_requires_string(__s);\n-\treturn this->find(__s, __pos, traits_type::length(__s)); \n+\treturn this->find(__s, __pos, traits_type::length(__s));\n       }\n \n       /**\n@@ -1548,9 +1548,9 @@ namespace std\n       */\n       size_type\n       rfind(const _CharT* __s, size_type __pos = npos) const\n-      { \n+      {\n \t__glibcxx_requires_string(__s);\n-\treturn this->rfind(__s, __pos, traits_type::length(__s)); \n+\treturn this->rfind(__s, __pos, traits_type::length(__s));\n       }\n \n       /**\n@@ -1606,9 +1606,9 @@ namespace std\n       */\n       size_type\n       find_first_of(const _CharT* __s, size_type __pos = 0) const\n-      { \n+      {\n \t__glibcxx_requires_string(__s);\n-\treturn this->find_first_of(__s, __pos, traits_type::length(__s)); \n+\treturn this->find_first_of(__s, __pos, traits_type::length(__s));\n       }\n \n       /**\n@@ -1667,9 +1667,9 @@ namespace std\n       */\n       size_type\n       find_last_of(const _CharT* __s, size_type __pos = npos) const\n-      { \n+      {\n \t__glibcxx_requires_string(__s);\n-\treturn this->find_last_of(__s, __pos, traits_type::length(__s)); \n+\treturn this->find_last_of(__s, __pos, traits_type::length(__s));\n       }\n \n       /**\n@@ -1729,9 +1729,9 @@ namespace std\n       */\n       size_type\n       find_first_not_of(const _CharT* __s, size_type __pos = 0) const\n-      { \n+      {\n \t__glibcxx_requires_string(__s);\n-\treturn this->find_first_not_of(__s, __pos, traits_type::length(__s)); \n+\treturn this->find_first_not_of(__s, __pos, traits_type::length(__s));\n       }\n \n       /**\n@@ -1788,9 +1788,9 @@ namespace std\n       */\n       size_type\n       find_last_not_of(const _CharT* __s, size_type __pos = npos) const\n-      { \n+      {\n \t__glibcxx_requires_string(__s);\n-\treturn this->find_last_not_of(__s, __pos, traits_type::length(__s)); \n+\treturn this->find_last_not_of(__s, __pos, traits_type::length(__s));\n       }\n \n       /**\n@@ -1935,7 +1935,7 @@ namespace std\n        *  Returns an integer < 0 if this substring is ordered before the string\n        *  from @a s, 0 if their values are equivalent, or > 0 if this substring\n        *  is ordered after the string from @a s. If the lengths of this\n-       *  substring and @a n2 are different, the shorter one is ordered first. \n+       *  substring and @a n2 are different, the shorter one is ordered first.\n        *  If they are the same, returns the result of\n        *  traits::compare(substring.data(),s,size());\n        *\n@@ -1959,7 +1959,7 @@ namespace std\n    *  @param lhs  First string.\n    *  @param rhs  Last string.\n    *  @return  New string with value of @a lhs followed by @a rhs.\n-   */ \n+   */\n  template<typename _CharT, typename _Traits, typename _Alloc>\n     basic_string<_CharT, _Traits, _Alloc>\n     operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n@@ -1975,7 +1975,7 @@ namespace std\n    *  @param lhs  First string.\n    *  @param rhs  Last string.\n    *  @return  New string with value of @a lhs followed by @a rhs.\n-   */ \n+   */\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     basic_string<_CharT,_Traits,_Alloc>\n     operator+(const _CharT* __lhs,\n@@ -1986,7 +1986,7 @@ namespace std\n    *  @param lhs  First string.\n    *  @param rhs  Last string.\n    *  @return  New string with @a lhs followed by @a rhs.\n-   */ \n+   */\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     basic_string<_CharT,_Traits,_Alloc>\n     operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);\n@@ -1996,7 +1996,7 @@ namespace std\n    *  @param lhs  First string.\n    *  @param rhs  Last string.\n    *  @return  New string with @a lhs followed by @a rhs.\n-   */ \n+   */\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline basic_string<_CharT, _Traits, _Alloc>\n     operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n@@ -2012,12 +2012,12 @@ namespace std\n    *  @param lhs  First string.\n    *  @param rhs  Last string.\n    *  @return  New string with @a lhs followed by @a rhs.\n-   */ \n+   */\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline basic_string<_CharT, _Traits, _Alloc>\n     operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)\n     {\n-      typedef basic_string<_CharT, _Traits, _Alloc> \t__string_type;\n+      typedef basic_string<_CharT, _Traits, _Alloc>\t__string_type;\n       typedef typename __string_type::size_type\t\t__size_type;\n       __string_type __str(__lhs);\n       __str.append(__size_type(1), __rhs);\n@@ -2030,7 +2030,7 @@ namespace std\n    *  @param lhs  First string.\n    *  @param rhs  Second string.\n    *  @return  True if @a lhs.compare(@a rhs) == 0.  False otherwise.\n-   */ \n+   */\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n@@ -2042,7 +2042,7 @@ namespace std\n    *  @param lhs  C string.\n    *  @param rhs  String.\n    *  @return  True if @a rhs.compare(@a lhs) == 0.  False otherwise.\n-   */ \n+   */\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator==(const _CharT* __lhs,\n@@ -2054,7 +2054,7 @@ namespace std\n    *  @param lhs  String.\n    *  @param rhs  C string.\n    *  @return  True if @a lhs.compare(@a rhs) == 0.  False otherwise.\n-   */ \n+   */\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n@@ -2067,7 +2067,7 @@ namespace std\n    *  @param lhs  First string.\n    *  @param rhs  Second string.\n    *  @return  True if @a lhs.compare(@a rhs) != 0.  False otherwise.\n-   */ \n+   */\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n@@ -2079,7 +2079,7 @@ namespace std\n    *  @param lhs  C string.\n    *  @param rhs  String.\n    *  @return  True if @a rhs.compare(@a lhs) != 0.  False otherwise.\n-   */ \n+   */\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator!=(const _CharT* __lhs,\n@@ -2091,7 +2091,7 @@ namespace std\n    *  @param lhs  String.\n    *  @param rhs  C string.\n    *  @return  True if @a lhs.compare(@a rhs) != 0.  False otherwise.\n-   */ \n+   */\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n@@ -2104,7 +2104,7 @@ namespace std\n    *  @param lhs  First string.\n    *  @param rhs  Second string.\n    *  @return  True if @a lhs precedes @a rhs.  False otherwise.\n-   */ \n+   */\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n@@ -2116,7 +2116,7 @@ namespace std\n    *  @param lhs  String.\n    *  @param rhs  C string.\n    *  @return  True if @a lhs precedes @a rhs.  False otherwise.\n-   */ \n+   */\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n@@ -2128,7 +2128,7 @@ namespace std\n    *  @param lhs  C string.\n    *  @param rhs  String.\n    *  @return  True if @a lhs precedes @a rhs.  False otherwise.\n-   */ \n+   */\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator<(const _CharT* __lhs,\n@@ -2141,7 +2141,7 @@ namespace std\n    *  @param lhs  First string.\n    *  @param rhs  Second string.\n    *  @return  True if @a lhs follows @a rhs.  False otherwise.\n-   */ \n+   */\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n@@ -2153,7 +2153,7 @@ namespace std\n    *  @param lhs  String.\n    *  @param rhs  C string.\n    *  @return  True if @a lhs follows @a rhs.  False otherwise.\n-   */ \n+   */\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n@@ -2165,7 +2165,7 @@ namespace std\n    *  @param lhs  C string.\n    *  @param rhs  String.\n    *  @return  True if @a lhs follows @a rhs.  False otherwise.\n-   */ \n+   */\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator>(const _CharT* __lhs,\n@@ -2178,7 +2178,7 @@ namespace std\n    *  @param lhs  First string.\n    *  @param rhs  Second string.\n    *  @return  True if @a lhs doesn't follow @a rhs.  False otherwise.\n-   */ \n+   */\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n@@ -2190,7 +2190,7 @@ namespace std\n    *  @param lhs  String.\n    *  @param rhs  C string.\n    *  @return  True if @a lhs doesn't follow @a rhs.  False otherwise.\n-   */ \n+   */\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n@@ -2202,7 +2202,7 @@ namespace std\n    *  @param lhs  C string.\n    *  @param rhs  String.\n    *  @return  True if @a lhs doesn't follow @a rhs.  False otherwise.\n-   */ \n+   */\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator<=(const _CharT* __lhs,\n@@ -2215,7 +2215,7 @@ namespace std\n    *  @param lhs  First string.\n    *  @param rhs  Second string.\n    *  @return  True if @a lhs doesn't precede @a rhs.  False otherwise.\n-   */ \n+   */\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n@@ -2227,7 +2227,7 @@ namespace std\n    *  @param lhs  String.\n    *  @param rhs  C string.\n    *  @return  True if @a lhs doesn't precede @a rhs.  False otherwise.\n-   */ \n+   */\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n@@ -2239,7 +2239,7 @@ namespace std\n    *  @param lhs  C string.\n    *  @param rhs  String.\n    *  @return  True if @a lhs doesn't precede @a rhs.  False otherwise.\n-   */ \n+   */\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline bool\n     operator>=(const _CharT* __lhs,\n@@ -2251,7 +2251,7 @@ namespace std\n    *  @param lhs  First string.\n    *  @param rhs  Second string.\n    *\n-   *  Exchanges the contents of @a lhs and @a rhs in constant time. \n+   *  Exchanges the contents of @a lhs and @a rhs in constant time.\n    */\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline void"}, {"sha": "729b86cca0ed0d409aadd52f26e4dccfbe985ccb", "filename": "libstdc++-v3/include/bits/basic_string.tcc", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -56,12 +56,12 @@ namespace std\n     { return false; }\n \n   template<typename _CharT, typename _Traits, typename _Alloc>\n-    const typename basic_string<_CharT, _Traits, _Alloc>::size_type \n+    const typename basic_string<_CharT, _Traits, _Alloc>::size_type\n     basic_string<_CharT, _Traits, _Alloc>::\n     _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;\n \n   template<typename _CharT, typename _Traits, typename _Alloc>\n-    const _CharT \n+    const _CharT\n     basic_string<_CharT, _Traits, _Alloc>::\n     _Rep::_S_terminal = _CharT();\n \n@@ -94,62 +94,62 @@ namespace std\n \t_CharT __buf[100];\n \tsize_type __len = 0;\n \twhile (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))\n-\t  { \n-\t    __buf[__len++] = *__beg; \n+\t  {\n+\t    __buf[__len++] = *__beg;\n \t    ++__beg;\n \t  }\n \t_Rep* __r = _Rep::_S_create(__len, size_type(0), __a);\n \ttraits_type::copy(__r->_M_refdata(), __buf, __len);\n-\ttry \n+\ttry\n \t  {\n \t    while (__beg != __end)\n \t      {\n \t\tif (__len == __r->_M_capacity)\n \t\t  {\n \t\t    // Allocate more space.\n \t\t    _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);\n-\t\t    traits_type::copy(__another->_M_refdata(), \n+\t\t    traits_type::copy(__another->_M_refdata(),\n \t\t\t\t      __r->_M_refdata(), __len);\n \t\t    __r->_M_destroy(__a);\n \t\t    __r = __another;\n \t\t  }\n-\t\t__r->_M_refdata()[__len++] = *__beg; \n+\t\t__r->_M_refdata()[__len++] = *__beg;\n \t\t++__beg;\n \t      }\n \t  }\n-\tcatch(...) \n+\tcatch(...)\n \t  {\n-\t    __r->_M_destroy(__a); \n+\t    __r->_M_destroy(__a);\n \t    __throw_exception_again;\n \t  }\n \t__r->_M_length = __len;\n \t__r->_M_refdata()[__len] = _Rep::_S_terminal;       // grrr.\n \treturn __r->_M_refdata();\n       }\n-  \n+\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     template <typename _InIterator>\n       _CharT*\n       basic_string<_CharT, _Traits, _Alloc>::\n-      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a, \n+      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,\n \t\t   forward_iterator_tag)\n       {\n \tif (__beg == __end && __a == _Alloc())\n \t  return _S_empty_rep()._M_refdata();\n \n-\t// NB: Not required, but considered best practice. \n+\t// NB: Not required, but considered best practice.\n \tif (__builtin_expect(__is_null_pointer(__beg), 0))\n \t  __throw_logic_error(__N(\"basic_string::_S_construct NULL not valid\"));\n \n \tconst size_type __dnew = static_cast<size_type>(std::distance(__beg,\n \t\t\t\t\t\t\t\t      __end));\n \t// Check for out_of_range and length_error exceptions.\n \t_Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);\n-\ttry \n+\ttry\n \t  { _S_copy_chars(__r->_M_refdata(), __beg, __end); }\n-\tcatch(...) \n-\t  { \n-\t    __r->_M_destroy(__a); \n+\tcatch(...)\n+\t  {\n+\t    __r->_M_destroy(__a);\n \t    __throw_exception_again;\n \t  }\n \t__r->_M_length = __dnew;\n@@ -167,8 +167,8 @@ namespace std\n \n       // Check for out_of_range and length_error exceptions.\n       _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);\n-      if (__n) \n-\ttraits_type::assign(__r->_M_refdata(), __n, __c); \n+      if (__n)\n+\ttraits_type::assign(__r->_M_refdata(), __n, __c);\n \n       __r->_M_length = __n;\n       __r->_M_refdata()[__n] = _Rep::_S_terminal;  // grrr\n@@ -187,7 +187,7 @@ namespace std\n     basic_string(const _Alloc& __a)\n     : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)\n     { }\n- \n+\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     basic_string<_CharT, _Traits, _Alloc>::\n     basic_string(const basic_string& __str, size_type __pos, size_type __n)\n@@ -230,7 +230,7 @@ namespace std\n     : _M_dataplus(_S_construct(__n, __c, __a), __a)\n     { }\n \n-  // TBD: DPG annotate \n+  // TBD: DPG annotate\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     template<typename _InputIterator>\n     basic_string<_CharT, _Traits, _Alloc>::\n@@ -313,7 +313,7 @@ namespace std\n            return *this;\n          }\n      }\n- \n+\n    template<typename _CharT, typename _Traits, typename _Alloc>\n      basic_string<_CharT, _Traits, _Alloc>&\n      basic_string<_CharT, _Traits, _Alloc>::\n@@ -350,7 +350,7 @@ namespace std\n \t   return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);\n \t }\n      }\n-  \n+\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     void\n     basic_string<_CharT, _Traits, _Alloc>::_Rep::\n@@ -369,7 +369,7 @@ namespace std\n     {\n       if (_M_rep() == &_S_empty_rep())\n         return;\n-      if (_M_rep()->_M_is_shared()) \n+      if (_M_rep()->_M_is_shared())\n \t_M_mutate(0, 0, 0);\n       _M_rep()->_M_set_leaked();\n     }\n@@ -383,7 +383,7 @@ namespace std\n       const size_type __new_size = __old_size + __len2 - __len1;\n       const _CharT*        __src = _M_data()  + __pos + __len1;\n       const size_type __how_much = __old_size - __pos - __len1;\n-      \n+\n       if (_M_rep() == &_S_empty_rep()\n \t  || _M_rep()->_M_is_shared() || __new_size > capacity())\n \t{\n@@ -410,7 +410,7 @@ namespace std\n       _M_data()[__new_size] = _Rep::_S_terminal; // grrr. (per 21.3.4)\n       // You cannot leave those LWG people alone for a second.\n     }\n-  \n+\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     void\n     basic_string<_CharT, _Traits, _Alloc>::reserve(size_type __res)\n@@ -428,13 +428,13 @@ namespace std\n \t  _M_data(__tmp);\n         }\n     }\n-  \n+\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     void basic_string<_CharT, _Traits, _Alloc>::swap(basic_string& __s)\n     {\n-      if (_M_rep()->_M_is_leaked()) \n+      if (_M_rep()->_M_is_leaked())\n \t_M_rep()->_M_set_sharable();\n-      if (__s._M_rep()->_M_is_leaked()) \n+      if (__s._M_rep()->_M_is_leaked())\n \t__s._M_rep()->_M_set_sharable();\n       if (this->get_allocator() == __s.get_allocator())\n \t{\n@@ -443,11 +443,11 @@ namespace std\n \t  __s._M_data(__tmp);\n \t}\n       // The code below can usually be optimized away.\n-      else \n+      else\n \t{\n \t  const basic_string __tmp1(_M_ibegin(), _M_iend(),\n \t\t\t\t    __s.get_allocator());\n-\t  const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(), \n+\t  const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),\n \t\t\t\t    this->get_allocator());\n \t  *this = __tmp2;\n \t  __s = __tmp1;\n@@ -504,7 +504,7 @@ namespace std\n       const size_type __page_capacity = ((__pagesize - __malloc_header_size\n \t\t\t\t\t  - sizeof(_Rep) - sizeof(_CharT))\n \t\t\t\t\t / sizeof(_CharT));\n-      \n+\n       if (__capacity > __old_capacity && __capacity < 2 * __old_capacity\n \t  && __capacity > __page_capacity)\n \t__capacity = 2 * __old_capacity;\n@@ -558,7 +558,7 @@ namespace std\n       __r->_M_refdata()[this->_M_length] = _Rep::_S_terminal;\n       return __r->_M_refdata();\n     }\n-  \n+\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     void\n     basic_string<_CharT, _Traits, _Alloc>::resize(size_type __n, _CharT __c)\n@@ -577,7 +577,7 @@ namespace std\n     template<typename _InputIterator>\n       basic_string<_CharT, _Traits, _Alloc>&\n       basic_string<_CharT, _Traits, _Alloc>::\n-      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1, \n+      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,\n \t\t\t  _InputIterator __k2, __false_type)\n       {\n \tconst basic_string __s(__k1, __k2);\n@@ -720,16 +720,16 @@ namespace std\n \t{\n \t  __pos = std::min(size_type(__size - __n), __pos);\n \t  const _CharT* __data = _M_data();\n-\t  do \n+\t  do\n \t    {\n \t      if (traits_type::compare(__data + __pos, __s, __n) == 0)\n \t\treturn __pos;\n-\t    } \n+\t    }\n \t  while (__pos-- > 0);\n \t}\n       return npos;\n     }\n-  \n+\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     typename basic_string<_CharT, _Traits, _Alloc>::size_type\n     basic_string<_CharT, _Traits, _Alloc>::\n@@ -746,7 +746,7 @@ namespace std\n \t}\n       return npos;\n     }\n-  \n+\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     typename basic_string<_CharT, _Traits, _Alloc>::size_type\n     basic_string<_CharT, _Traits, _Alloc>::\n@@ -761,7 +761,7 @@ namespace std\n \t}\n       return npos;\n     }\n- \n+\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     typename basic_string<_CharT, _Traits, _Alloc>::size_type\n     basic_string<_CharT, _Traits, _Alloc>::\n@@ -770,19 +770,19 @@ namespace std\n       __glibcxx_requires_string_len(__s, __n);\n       size_type __size = this->size();\n       if (__size && __n)\n-\t{ \n-\t  if (--__size > __pos) \n+\t{\n+\t  if (--__size > __pos)\n \t    __size = __pos;\n \t  do\n \t    {\n \t      if (traits_type::find(__s, __n, _M_data()[__size]))\n \t\treturn __size;\n-\t    } \n+\t    }\n \t  while (__size-- != 0);\n \t}\n       return npos;\n     }\n-  \n+\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     typename basic_string<_CharT, _Traits, _Alloc>::size_type\n     basic_string<_CharT, _Traits, _Alloc>::\n@@ -817,11 +817,11 @@ namespace std\n \t{\n \t  if (--__size > __pos)\n \t    __size = __pos;\n- \t  do\n+\t  do\n \t    {\n \t      if (!traits_type::find(__s, __n, _M_data()[__size]))\n \t\treturn __size;\n-\t    } \n+\t    }\n \t  while (__size--);\n \t}\n       return npos;\n@@ -836,17 +836,17 @@ namespace std\n       if (__size)\n \t{\n \t  if (--__size > __pos)\n-\t    __size = __pos;\t  \n+\t    __size = __pos;\n \t  do\n \t    {\n \t      if (!traits_type::eq(_M_data()[__size], __c))\n \t\treturn __size;\n-\t    } \n+\t    }\n \t  while (__size--);\n \t}\n       return npos;\n     }\n-  \n+\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     int\n     basic_string<_CharT, _Traits, _Alloc>::\n@@ -873,7 +873,7 @@ namespace std\n       __n1 = _M_limit(__pos1, __n1);\n       __n2 = __str._M_limit(__pos2, __n2);\n       const size_type __len = std::min(__n1, __n2);\n-      int __r = traits_type::compare(_M_data() + __pos1, \n+      int __r = traits_type::compare(_M_data() + __pos1,\n \t\t\t\t     __str.data() + __pos2, __len);\n       if (!__r)\n \t__r = __n1 - __n2;\n@@ -914,7 +914,7 @@ namespace std\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     int\n     basic_string <_CharT, _Traits, _Alloc>::\n-    compare(size_type __pos, size_type __n1, const _CharT* __s, \n+    compare(size_type __pos, size_type __n1, const _CharT* __s,\n \t    size_type __n2) const\n     {\n       __glibcxx_requires_string_len(__s, __n2);\n@@ -928,36 +928,36 @@ namespace std\n     }\n \n   // Inhibit implicit instantiations for required instantiations,\n-  // which are defined via explicit instantiations elsewhere.  \n+  // which are defined via explicit instantiations elsewhere.\n   // NB: This syntax is a GNU extension.\n #if _GLIBCXX_EXTERN_TEMPLATE\n   extern template class basic_string<char>;\n-  extern template \n-    basic_istream<char>& \n+  extern template\n+    basic_istream<char>&\n     operator>>(basic_istream<char>&, string&);\n-  extern template \n-    basic_ostream<char>& \n+  extern template\n+    basic_ostream<char>&\n     operator<<(basic_ostream<char>&, const string&);\n-  extern template \n-    basic_istream<char>& \n+  extern template\n+    basic_istream<char>&\n     getline(basic_istream<char>&, string&, char);\n-  extern template \n-    basic_istream<char>& \n+  extern template\n+    basic_istream<char>&\n     getline(basic_istream<char>&, string&);\n \n #ifdef _GLIBCXX_USE_WCHAR_T\n   extern template class basic_string<wchar_t>;\n-  extern template \n-    basic_istream<wchar_t>& \n+  extern template\n+    basic_istream<wchar_t>&\n     operator>>(basic_istream<wchar_t>&, wstring&);\n-  extern template \n-    basic_ostream<wchar_t>& \n+  extern template\n+    basic_ostream<wchar_t>&\n     operator<<(basic_ostream<wchar_t>&, const wstring&);\n-  extern template \n-    basic_istream<wchar_t>& \n+  extern template\n+    basic_istream<wchar_t>&\n     getline(basic_istream<wchar_t>&, wstring&, wchar_t);\n-  extern template \n-    basic_istream<wchar_t>& \n+  extern template\n+    basic_istream<wchar_t>&\n     getline(basic_istream<wchar_t>&, wstring&);\n #endif\n #endif"}, {"sha": "70037eb1c3a3330895edf1baea90225e2b08f698", "filename": "libstdc++-v3/include/bits/boost_concept_check.h", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fboost_concept_check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fboost_concept_check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fboost_concept_check.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -87,7 +87,7 @@ struct _Aux_require_same<_Tp,_Tp> { typedef _Tp _Type; };\n \n   template <class _Tp>\n   struct _IntegerConcept {\n-    void __constraints() { \n+    void __constraints() {\n       this->__error_type_must_be_an_integer_type();\n     }\n   };\n@@ -103,7 +103,7 @@ struct _Aux_require_same<_Tp,_Tp> { typedef _Tp _Type; };\n \n   template <class _Tp>\n   struct _SignedIntegerConcept {\n-    void __constraints() { \n+    void __constraints() {\n       this->__error_type_must_be_a_signed_integer_type();\n     }\n   };\n@@ -114,7 +114,7 @@ struct _Aux_require_same<_Tp,_Tp> { typedef _Tp _Type; };\n \n   template <class _Tp>\n   struct _UnsignedIntegerConcept {\n-    void __constraints() { \n+    void __constraints() {\n       this->__error_type_must_be_an_unsigned_integer_type();\n     }\n   };\n@@ -312,7 +312,7 @@ struct _Aux_require_same<_Tp,_Tp> { typedef _Tp _Type; };\n \n   template <class _Func, class _Arg>\n   struct _UnaryFunctionConcept<_Func, void, _Arg> {\n-    void __constraints() { \n+    void __constraints() {\n       __f(__arg);                       // require operator()\n     }\n     _Func __f;\n@@ -322,7 +322,7 @@ struct _Aux_require_same<_Tp,_Tp> { typedef _Tp _Type; };\n   template <class _Func, class _Return, class _First, class _Second>\n   struct _BinaryFunctionConcept\n   {\n-    void __constraints() { \n+    void __constraints() {\n       __r = __f(__first, __second);     // require operator()\n     }\n     _Func __f;\n@@ -366,7 +366,7 @@ struct _Aux_require_same<_Tp,_Tp> { typedef _Tp _Type; };\n   // use this when functor is used inside a container class like std::set\n   template <class _Func, class _First, class _Second>\n   struct _Const_BinaryPredicateConcept {\n-    void __constraints() { \n+    void __constraints() {\n       __const_constraints(__f);\n     }\n     void __const_constraints(const _Func& __fun) {\n@@ -560,7 +560,7 @@ struct _Aux_require_same<_Tp,_Tp> { typedef _Tp _Type; };\n     typedef typename _Container::reference _Reference;\n     typedef typename _Container::iterator _Iterator;\n     typedef typename _Container::pointer _Pointer;\n-    \n+\n     void __constraints() {\n       __function_requires< _ContainerConcept<_Container> >();\n       __function_requires< _AssignableConcept<_Value_type> >();\n@@ -582,7 +582,7 @@ struct _Aux_require_same<_Tp,_Tp> { typedef _Tp _Type; };\n       typedef typename _ForwardContainer::const_iterator _Const_iterator;\n       __function_requires< _ForwardIteratorConcept<_Const_iterator> >();\n     }\n-  };  \n+  };\n \n   template <class _ForwardContainer>\n   struct _Mutable_ForwardContainerConcept\n@@ -593,7 +593,7 @@ struct _Aux_require_same<_Tp,_Tp> { typedef _Tp _Type; };\n       typedef typename _ForwardContainer::iterator _Iterator;\n       __function_requires< _Mutable_ForwardIteratorConcept<_Iterator> >();\n     }\n-  };  \n+  };\n \n   template <class _ReversibleContainer>\n   struct _ReversibleContainerConcept\n@@ -693,7 +693,7 @@ struct _Aux_require_same<_Tp,_Tp> { typedef _Tp _Type; };\n       __function_requires< _Mutable_ForwardContainerConcept<_Sequence> >();\n       __function_requires< _DefaultConstructibleConcept<_Sequence> >();\n \n-      _Sequence \n+      _Sequence\n         __c(__n) _IsUnused,\n         __c2(__n, __t) _IsUnused,\n         __c3(__first, __last) _IsUnused;\n@@ -758,7 +758,7 @@ struct _Aux_require_same<_Tp,_Tp> { typedef _Tp _Type; };\n       __function_requires< _ForwardContainerConcept<_AssociativeContainer> >();\n       __function_requires<\n         _DefaultConstructibleConcept<_AssociativeContainer> >();\n-    \n+\n       __i = __c.find(__k);\n       __r = __c.equal_range(__k);\n       __c.erase(__k);\n@@ -789,9 +789,9 @@ struct _Aux_require_same<_Tp,_Tp> { typedef _Tp _Type; };\n     void __constraints() {\n       __function_requires<\n         _AssociativeContainerConcept<_UniqueAssociativeContainer> >();\n-    \n+\n       _UniqueAssociativeContainer __c(__first, __last);\n-      \n+\n       __pos_flag = __c.insert(__t);\n       __c.insert(__first, __last);\n     }\n@@ -808,7 +808,7 @@ struct _Aux_require_same<_Tp,_Tp> { typedef _Tp _Type; };\n         _AssociativeContainerConcept<_MultipleAssociativeContainer> >();\n \n       _MultipleAssociativeContainer __c(__first, __last);\n-      \n+\n       __pos = __c.insert(__t);\n       __c.insert(__first, __last);\n \n@@ -855,15 +855,15 @@ struct _Aux_require_same<_Tp,_Tp> { typedef _Tp _Type; };\n       __function_requires<\n         _ReversibleContainerConcept<_SortedAssociativeContainer> >();\n \n-      _SortedAssociativeContainer \n+      _SortedAssociativeContainer\n         __c(__kc) _IsUnused,\n         __c2(__first, __last) _IsUnused,\n         __c3(__first, __last, __kc) _IsUnused;\n \n       __p = __c.upper_bound(__k);\n       __p = __c.lower_bound(__k);\n       __r = __c.equal_range(__k);\n-      \n+\n       __c.insert(__p, __t);\n     }\n     void __const_constraints(const _SortedAssociativeContainer& __c) {"}, {"sha": "323fdfb47c0909af398da04a50a280bda1aba39c", "filename": "libstdc++-v3/include/bits/char_traits.h", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fchar_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fchar_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fchar_traits.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -50,12 +50,12 @@ namespace __gnu_cxx\n {\n   /**\n    *  @brief  Mapping from character type to associated types.\n-   * \n+   *\n    *\n    *  @note This is an implementation class for the generic version\n    *  of char_traits.  It defines int_type, off_type, pos_type, and\n    *  state_type.  By default these are unsigned long, streamoff,\n-   *  streampos, and mbstate_t.  Users who need a different set of \n+   *  streampos, and mbstate_t.  Users who need a different set of\n    *  types, but who don't need to change the definitions of any function\n    *  defined in char_traits, can specialize __gnu_cxx::_Char_types\n    *  while leaving __gnu_cxx::char_traits alone. */\n@@ -91,54 +91,54 @@ namespace __gnu_cxx\n       typedef typename _Char_types<_CharT>::pos_type    pos_type;\n       typedef typename _Char_types<_CharT>::off_type    off_type;\n       typedef typename _Char_types<_CharT>::state_type  state_type;\n-      \n-      static void \n+\n+      static void\n       assign(char_type& __c1, const char_type& __c2)\n       { __c1 = __c2; }\n \n-      static bool \n+      static bool\n       eq(const char_type& __c1, const char_type& __c2)\n       { return __c1 == __c2; }\n \n-      static bool \n+      static bool\n       lt(const char_type& __c1, const char_type& __c2)\n       { return __c1 < __c2; }\n \n-      static int \n+      static int\n       compare(const char_type* __s1, const char_type* __s2, std::size_t __n);\n \n       static std::size_t\n       length(const char_type* __s);\n \n-      static const char_type* \n+      static const char_type*\n       find(const char_type* __s, std::size_t __n, const char_type& __a);\n \n-      static char_type* \n+      static char_type*\n       move(char_type* __s1, const char_type* __s2, std::size_t __n);\n \n-      static char_type* \n+      static char_type*\n       copy(char_type* __s1, const char_type* __s2, std::size_t __n);\n \n-      static char_type* \n+      static char_type*\n       assign(char_type* __s, std::size_t __n, char_type __a);\n \n-      static char_type \n+      static char_type\n       to_char_type(const int_type& __c)\n       { return static_cast<char_type>(__c); }\n \n-      static int_type \n+      static int_type\n       to_int_type(const char_type& __c)\n       { return static_cast<int_type>(__c); }\n \n-      static bool \n+      static bool\n       eq_int_type(const int_type& __c1, const int_type& __c2)\n       { return __c1 == __c2; }\n \n-      static int_type \n+      static int_type\n       eof()\n       { return static_cast<int_type>(EOF); }\n \n-      static int_type \n+      static int_type\n       not_eof(const int_type& __c)\n       { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }\n     };\n@@ -168,7 +168,7 @@ namespace __gnu_cxx\n     }\n \n   template<typename _CharT>\n-    const typename char_traits<_CharT>::char_type* \n+    const typename char_traits<_CharT>::char_type*\n     char_traits<_CharT>::\n     find(const char_type* __s, std::size_t __n, const char_type& __a)\n     {\n@@ -188,7 +188,7 @@ namespace __gnu_cxx\n     }\n \n   template<typename _CharT>\n-    typename char_traits<_CharT>::char_type* \n+    typename char_traits<_CharT>::char_type*\n     char_traits<_CharT>::\n     copy(char_type* __s1, const char_type* __s2, std::size_t __n)\n     {\n@@ -197,7 +197,7 @@ namespace __gnu_cxx\n     }\n \n   template<typename _CharT>\n-    typename char_traits<_CharT>::char_type* \n+    typename char_traits<_CharT>::char_type*\n     char_traits<_CharT>::\n     assign(char_type* __s, std::size_t __n, char_type __a)\n     {\n@@ -206,7 +206,7 @@ namespace __gnu_cxx\n     }\n }\n \n-namespace std \n+namespace std\n {\n   // 21.1\n   /**\n@@ -237,60 +237,60 @@ namespace std\n       typedef streamoff         off_type;\n       typedef mbstate_t         state_type;\n \n-      static void \n+      static void\n       assign(char_type& __c1, const char_type& __c2)\n       { __c1 = __c2; }\n \n-      static bool \n+      static bool\n       eq(const char_type& __c1, const char_type& __c2)\n       { return __c1 == __c2; }\n \n-      static bool \n+      static bool\n       lt(const char_type& __c1, const char_type& __c2)\n       { return __c1 < __c2; }\n \n-      static int \n+      static int\n       compare(const char_type* __s1, const char_type* __s2, size_t __n)\n       { return memcmp(__s1, __s2, __n); }\n \n       static size_t\n       length(const char_type* __s)\n       { return strlen(__s); }\n \n-      static const char_type* \n+      static const char_type*\n       find(const char_type* __s, size_t __n, const char_type& __a)\n       { return static_cast<const char_type*>(memchr(__s, __a, __n)); }\n \n-      static char_type* \n+      static char_type*\n       move(char_type* __s1, const char_type* __s2, size_t __n)\n       { return static_cast<char_type*>(memmove(__s1, __s2, __n)); }\n \n-      static char_type* \n+      static char_type*\n       copy(char_type* __s1, const char_type* __s2, size_t __n)\n       { return static_cast<char_type*>(memcpy(__s1, __s2, __n)); }\n \n-      static char_type* \n+      static char_type*\n       assign(char_type* __s, size_t __n, char_type __a)\n       { return static_cast<char_type*>(memset(__s, __a, __n)); }\n \n-      static char_type \n+      static char_type\n       to_char_type(const int_type& __c)\n       { return static_cast<char_type>(__c); }\n \n       // To keep both the byte 0xff and the eof symbol 0xffffffff\n       // from ending up as 0xffffffff.\n-      static int_type \n+      static int_type\n       to_int_type(const char_type& __c)\n       { return static_cast<int_type>(static_cast<unsigned char>(__c)); }\n \n-      static bool \n+      static bool\n       eq_int_type(const int_type& __c1, const int_type& __c2)\n       { return __c1 == __c2; }\n \n-      static int_type \n+      static int_type\n       eof() { return static_cast<int_type>(EOF); }\n \n-      static int_type \n+      static int_type\n       not_eof(const int_type& __c)\n       { return (__c == eof()) ? 0 : __c; }\n   };\n@@ -306,57 +306,57 @@ namespace std\n       typedef streamoff         off_type;\n       typedef wstreampos        pos_type;\n       typedef mbstate_t         state_type;\n-      \n-      static void \n+\n+      static void\n       assign(char_type& __c1, const char_type& __c2)\n       { __c1 = __c2; }\n \n-      static bool \n+      static bool\n       eq(const char_type& __c1, const char_type& __c2)\n       { return __c1 == __c2; }\n \n-      static bool \n+      static bool\n       lt(const char_type& __c1, const char_type& __c2)\n       { return __c1 < __c2; }\n \n-      static int \n+      static int\n       compare(const char_type* __s1, const char_type* __s2, size_t __n)\n       { return wmemcmp(__s1, __s2, __n); }\n \n       static size_t\n       length(const char_type* __s)\n       { return wcslen(__s); }\n \n-      static const char_type* \n+      static const char_type*\n       find(const char_type* __s, size_t __n, const char_type& __a)\n       { return wmemchr(__s, __a, __n); }\n \n-      static char_type* \n+      static char_type*\n       move(char_type* __s1, const char_type* __s2, size_t __n)\n       { return wmemmove(__s1, __s2, __n); }\n \n-      static char_type* \n+      static char_type*\n       copy(char_type* __s1, const char_type* __s2, size_t __n)\n       { return wmemcpy(__s1, __s2, __n); }\n \n-      static char_type* \n+      static char_type*\n       assign(char_type* __s, size_t __n, char_type __a)\n       { return wmemset(__s, __a, __n); }\n \n-      static char_type \n+      static char_type\n       to_char_type(const int_type& __c) { return char_type(__c); }\n \n-      static int_type \n+      static int_type\n       to_int_type(const char_type& __c) { return int_type(__c); }\n \n-      static bool \n+      static bool\n       eq_int_type(const int_type& __c1, const int_type& __c2)\n       { return __c1 == __c2; }\n \n-      static int_type \n+      static int_type\n       eof() { return static_cast<int_type>(WEOF); }\n \n-      static int_type \n+      static int_type\n       not_eof(const int_type& __c)\n       { return eq_int_type(__c, eof()) ? 0 : __c; }\n   };\n@@ -368,7 +368,7 @@ namespace std\n       _CharT _M_c;\n       _Char_traits_match(_CharT const& __c) : _M_c(__c) { }\n \n-      bool \n+      bool\n       operator()(_CharT const& __a) { return _Traits::eq(_M_c, __a); }\n     };\n } // namespace std"}, {"sha": "56b55539265b569a60d1d98612a35899675b7ea3", "filename": "libstdc++-v3/include/bits/codecvt.h", "status": "modified", "additions": 88, "deletions": 88, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcodecvt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcodecvt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcodecvt.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -71,16 +71,16 @@\n    *  functions.\n   */\n   template<typename _InternT, typename _ExternT, typename _StateT>\n-    class __codecvt_abstract_base \n+    class __codecvt_abstract_base\n     : public locale::facet, public codecvt_base\n     {\n     public:\n       // Types:\n       typedef codecvt_base::result\tresult;\n-      typedef _InternT \t\t\tintern_type;\n-      typedef _ExternT \t\t\textern_type;\n-      typedef _StateT  \t\t\tstate_type;\n-      \n+      typedef _InternT\t\t\tintern_type;\n+      typedef _ExternT\t\t\textern_type;\n+      typedef _StateT\t\t\tstate_type;\n+\n       // 22.2.1.5.1 codecvt members\n       /**\n        *  @brief  Convert from internal to external character set.\n@@ -118,13 +118,13 @@\n        *  @return  codecvt_base::result.\n       */\n       result\n-      out(state_type& __state, const intern_type* __from, \n+      out(state_type& __state, const intern_type* __from,\n \t  const intern_type* __from_end, const intern_type*& __from_next,\n-\t  extern_type* __to, extern_type* __to_end, \n+\t  extern_type* __to, extern_type* __to_end,\n \t  extern_type*& __to_next) const\n-      { \n-\treturn this->do_out(__state, __from, __from_end, __from_next, \n-\t\t\t    __to, __to_end, __to_next); \n+      {\n+\treturn this->do_out(__state, __from, __from_end, __from_next,\n+\t\t\t    __to, __to_end, __to_next);\n       }\n \n       /**\n@@ -197,20 +197,20 @@\n        *  @return  codecvt_base::result.\n       */\n       result\n-      in(state_type& __state, const extern_type* __from, \n+      in(state_type& __state, const extern_type* __from,\n \t const extern_type* __from_end, const extern_type*& __from_next,\n-\t intern_type* __to, intern_type* __to_end, \n+\t intern_type* __to, intern_type* __to_end,\n \t intern_type*& __to_next) const\n-      { \n+      {\n \treturn this->do_in(__state, __from, __from_end, __from_next,\n-\t\t\t   __to, __to_end, __to_next); \n+\t\t\t   __to, __to_end, __to_next);\n       }\n \n-      int \n+      int\n       encoding() const throw()\n       { return this->do_encoding(); }\n \n-      bool \n+      bool\n       always_noconv() const throw()\n       { return this->do_always_noconv(); }\n \n@@ -219,15 +219,15 @@\n \t     const extern_type* __end, size_t __max) const\n       { return this->do_length(__state, __from, __end, __max); }\n \n-      int \n+      int\n       max_length() const throw()\n       { return this->do_max_length(); }\n \n     protected:\n-      explicit \n+      explicit\n       __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }\n \n-      virtual \n+      virtual\n       ~__codecvt_abstract_base() { }\n \n       /**\n@@ -238,92 +238,92 @@\n        *  the value returned.  @see out for more information.\n       */\n       virtual result\n-      do_out(state_type& __state, const intern_type* __from, \n+      do_out(state_type& __state, const intern_type* __from,\n \t     const intern_type* __from_end, const intern_type*& __from_next,\n \t     extern_type* __to, extern_type* __to_end,\n \t     extern_type*& __to_next) const = 0;\n \n       virtual result\n-      do_unshift(state_type& __state, extern_type* __to, \n+      do_unshift(state_type& __state, extern_type* __to,\n \t\t extern_type* __to_end, extern_type*& __to_next) const = 0;\n-      \n+\n       virtual result\n-      do_in(state_type& __state, const extern_type* __from, \n-\t    const extern_type* __from_end, const extern_type*& __from_next, \n-\t    intern_type* __to, intern_type* __to_end, \n+      do_in(state_type& __state, const extern_type* __from,\n+\t    const extern_type* __from_end, const extern_type*& __from_next,\n+\t    intern_type* __to, intern_type* __to_end,\n \t    intern_type*& __to_next) const = 0;\n-      \n-      virtual int \n+\n+      virtual int\n       do_encoding() const throw() = 0;\n \n-      virtual bool \n+      virtual bool\n       do_always_noconv() const throw() = 0;\n \n-      virtual int \n-      do_length(state_type&, const extern_type* __from, \n+      virtual int\n+      do_length(state_type&, const extern_type* __from,\n \t\tconst extern_type* __end, size_t __max) const = 0;\n \n-      virtual int \n+      virtual int\n       do_max_length() const throw() = 0;\n     };\n \n   // 22.2.1.5 Template class codecvt\n   // NB: Generic, mostly useless implementation.\n   template<typename _InternT, typename _ExternT, typename _StateT>\n-    class codecvt \n+    class codecvt\n     : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>\n     {\n-    public:      \n+    public:\n       // Types:\n       typedef codecvt_base::result\tresult;\n-      typedef _InternT \t\t\tintern_type;\n-      typedef _ExternT \t\t\textern_type;\n-      typedef _StateT  \t\t\tstate_type;\n+      typedef _InternT\t\t\tintern_type;\n+      typedef _ExternT\t\t\textern_type;\n+      typedef _StateT\t\t\tstate_type;\n \n     protected:\n       __c_locale\t\t\t_M_c_locale_codecvt;\n \n     public:\n-      static locale::id \t\tid;\n+      static locale::id\t\t\tid;\n \n-      explicit \n-      codecvt(size_t __refs = 0) \n+      explicit\n+      codecvt(size_t __refs = 0)\n       : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs) { }\n \n-      explicit \n+      explicit\n       codecvt(__c_locale __cloc, size_t __refs = 0);\n \n     protected:\n-      virtual \n+      virtual\n       ~codecvt() { }\n \n       virtual result\n-      do_out(state_type& __state, const intern_type* __from, \n+      do_out(state_type& __state, const intern_type* __from,\n \t     const intern_type* __from_end, const intern_type*& __from_next,\n \t     extern_type* __to, extern_type* __to_end,\n \t     extern_type*& __to_next) const;\n \n       virtual result\n-      do_unshift(state_type& __state, extern_type* __to, \n+      do_unshift(state_type& __state, extern_type* __to,\n \t\t extern_type* __to_end, extern_type*& __to_next) const;\n-      \n+\n       virtual result\n-      do_in(state_type& __state, const extern_type* __from, \n-\t    const extern_type* __from_end, const extern_type*& __from_next, \n-\t    intern_type* __to, intern_type* __to_end, \n+      do_in(state_type& __state, const extern_type* __from,\n+\t    const extern_type* __from_end, const extern_type*& __from_next,\n+\t    intern_type* __to, intern_type* __to_end,\n \t    intern_type*& __to_next) const;\n-      \n-      virtual int \n+\n+      virtual int\n       do_encoding() const throw();\n \n-      virtual bool \n+      virtual bool\n       do_always_noconv() const throw();\n \n-      virtual int \n-      do_length(state_type&, const extern_type* __from, \n+      virtual int\n+      do_length(state_type&, const extern_type* __from,\n \t\tconst extern_type* __end, size_t __max) const;\n \n-      virtual int \n+      virtual int\n       do_max_length() const throw();\n     };\n \n@@ -332,91 +332,91 @@\n \n   // codecvt<char, char, mbstate_t> required specialization\n   template<>\n-    class codecvt<char, char, mbstate_t> \n+    class codecvt<char, char, mbstate_t>\n     : public __codecvt_abstract_base<char, char, mbstate_t>\n     {\n-    public:      \n+    public:\n       // Types:\n-      typedef char \t\t\tintern_type;\n-      typedef char \t\t\textern_type;\n-      typedef mbstate_t \t\tstate_type;\n+      typedef char\t\t\tintern_type;\n+      typedef char\t\t\textern_type;\n+      typedef mbstate_t\t\t\tstate_type;\n \n     protected:\n       __c_locale\t\t\t_M_c_locale_codecvt;\n \n     public:\n       static locale::id id;\n \n-      explicit \n+      explicit\n       codecvt(size_t __refs = 0);\n \n-      explicit \n+      explicit\n       codecvt(__c_locale __cloc, size_t __refs = 0);\n \n     protected:\n-      virtual \n+      virtual\n       ~codecvt();\n \n       virtual result\n-      do_out(state_type& __state, const intern_type* __from, \n+      do_out(state_type& __state, const intern_type* __from,\n \t     const intern_type* __from_end, const intern_type*& __from_next,\n \t     extern_type* __to, extern_type* __to_end,\n \t     extern_type*& __to_next) const;\n \n       virtual result\n-      do_unshift(state_type& __state, extern_type* __to, \n+      do_unshift(state_type& __state, extern_type* __to,\n \t\t extern_type* __to_end, extern_type*& __to_next) const;\n \n       virtual result\n-      do_in(state_type& __state, const extern_type* __from, \n+      do_in(state_type& __state, const extern_type* __from,\n \t    const extern_type* __from_end, const extern_type*& __from_next,\n-\t    intern_type* __to, intern_type* __to_end, \n+\t    intern_type* __to, intern_type* __to_end,\n \t    intern_type*& __to_next) const;\n \n-      virtual int \n+      virtual int\n       do_encoding() const throw();\n \n-      virtual bool \n+      virtual bool\n       do_always_noconv() const throw();\n \n-      virtual int \n-      do_length(state_type&, const extern_type* __from, \n+      virtual int\n+      do_length(state_type&, const extern_type* __from,\n \t\tconst extern_type* __end, size_t __max) const;\n \n-      virtual int \n+      virtual int\n       do_max_length() const throw();\n   };\n \n #ifdef _GLIBCXX_USE_WCHAR_T\n   // codecvt<wchar_t, char, mbstate_t> required specialization\n   template<>\n-    class codecvt<wchar_t, char, mbstate_t> \n+    class codecvt<wchar_t, char, mbstate_t>\n     : public __codecvt_abstract_base<wchar_t, char, mbstate_t>\n     {\n     public:\n       // Types:\n-      typedef wchar_t \t\t\tintern_type;\n-      typedef char \t\t\textern_type;\n-      typedef mbstate_t \t\tstate_type;\n+      typedef wchar_t\t\t\tintern_type;\n+      typedef char\t\t\textern_type;\n+      typedef mbstate_t\t\t\tstate_type;\n \n     protected:\n       __c_locale\t\t\t_M_c_locale_codecvt;\n \n     public:\n-      static locale::id \t\tid;\n+      static locale::id\t\t\tid;\n \n-      explicit \n+      explicit\n       codecvt(size_t __refs = 0);\n \n-      explicit \n+      explicit\n       codecvt(__c_locale __cloc, size_t __refs = 0);\n \n     protected:\n-      virtual \n+      virtual\n       ~codecvt();\n \n       virtual result\n-      do_out(state_type& __state, const intern_type* __from, \n+      do_out(state_type& __state, const intern_type* __from,\n \t     const intern_type* __from_end, const intern_type*& __from_next,\n \t     extern_type* __to, extern_type* __to_end,\n \t     extern_type*& __to_next) const;\n@@ -433,17 +433,17 @@\n \t     intern_type* __to, intern_type* __to_end,\n \t     intern_type*& __to_next) const;\n \n-      virtual \n+      virtual\n       int do_encoding() const throw();\n \n-      virtual \n+      virtual\n       bool do_always_noconv() const throw();\n \n-      virtual \n+      virtual\n       int do_length(state_type&, const extern_type* __from,\n \t\t    const extern_type* __end, size_t __max) const;\n \n-      virtual int \n+      virtual int\n       do_max_length() const throw();\n     };\n #endif //_GLIBCXX_USE_WCHAR_T\n@@ -453,19 +453,19 @@\n     class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>\n     {\n     public:\n-      explicit \n-      codecvt_byname(const char* __s, size_t __refs = 0) \n+      explicit\n+      codecvt_byname(const char* __s, size_t __refs = 0)\n       : codecvt<_InternT, _ExternT, _StateT>(__refs)\n-      { \n+      {\n \tif (std::strcmp(__s, \"C\") != 0 && std::strcmp(__s, \"POSIX\") != 0)\n \t  {\n \t    _S_destroy_c_locale(this->_M_c_locale_codecvt);\n-\t    _S_create_c_locale(this->_M_c_locale_codecvt, __s); \n+\t    _S_create_c_locale(this->_M_c_locale_codecvt, __s);\n \t  }\n       }\n \n     protected:\n-      virtual \n+      virtual\n       ~codecvt_byname() { }\n     };\n "}, {"sha": "fe67881c76bab0bcd0360d27216b24b54732d0be", "filename": "libstdc++-v3/include/bits/concurrence.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fconcurrence.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fconcurrence.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fconcurrence.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -27,7 +27,7 @@\n // the GNU General Public License.  This exception does not however\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n- \n+\n #ifndef _CONCURRENCE\n #define _CONCURRENCE 1\n \n@@ -47,8 +47,8 @@ __GTHREAD_MUTEX_INIT_FUNCTION(&NAME)\n # define __glibcxx_mutex_unlock(LOCK) __gthread_mutex_unlock(&LOCK)\n #else\n # define __glibcxx_mutex_define_initialized(NAME)\n-# define __glibcxx_mutex_lock(LOCK) \n-# define __glibcxx_mutex_unlock(LOCK) \n+# define __glibcxx_mutex_lock(LOCK)\n+# define __glibcxx_mutex_unlock(LOCK)\n #endif\n \n #endif"}, {"sha": "7a0e65f4016c784795dd6013188b075241c641aa", "filename": "libstdc++-v3/include/bits/cpp_type_traits.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -139,7 +139,7 @@ namespace std\n \t_M_type = 1\n       };\n     };\n-  \n+\n   template<>\n     struct __is_integer<char>\n     {\n@@ -157,7 +157,7 @@ namespace std\n \t_M_type = 1\n       };\n     };\n-  \n+\n   template<>\n   struct __is_integer<unsigned char>\n   {\n@@ -177,7 +177,7 @@ namespace std\n     };\n   };\n # endif\n-  \n+\n   template<>\n   struct __is_integer<short>\n   {"}, {"sha": "021276ae21a76c10e401c664c703c7a179d0e7ee", "filename": "libstdc++-v3/include/bits/demangle.h", "status": "modified", "additions": 89, "deletions": 89, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdemangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdemangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdemangle.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -73,7 +73,7 @@ namespace __gnu_cxx\n       int M_start_pos;\n       substitution_nt M_type;\n       int M_number_of_prefixes;\n-      \n+\n       substitution_st(int start_pos,\n \t\t      substitution_nt type,\n \t\t      int number_of_prefixes)\n@@ -209,7 +209,7 @@ namespace __gnu_cxx\n       class qualifier_list\n       {\n \ttypedef typename Allocator::template rebind<char>::other\n-  \t  char_Allocator;\n+\t  char_Allocator;\n \ttypedef std::basic_string<char, std::char_traits<char>, char_Allocator>\n \t  string_type;\n \n@@ -250,7 +250,7 @@ namespace __gnu_cxx\n \n \tvoid\n \tadd_qualifier_start(param_qualifier_nt param_qualifier,\n-\t    \t\t    int start_pos,\n+\t\t\t    int start_pos,\n \t\t\t    string_type optional_type,\n \t\t\t    int inside_substitution)\n \t{ M_qualifier_starts.\n@@ -259,7 +259,7 @@ namespace __gnu_cxx\n \n \tvoid\n \tdecode_qualifiers(string_type& prefix,\n-\t    \t\t  string_type& postfix,\n+\t\t\t  string_type& postfix,\n \t\t\t  bool member_function_pointer_qualifiers) const;\n \n \tbool\n@@ -307,7 +307,7 @@ namespace __gnu_cxx\n \t// Use (void) instead of ():\t\t\tint f(void)\n \n         static unsigned int const style_literal = 2;\n-\t// Default behaviour:\t\t\t\t(long)13, \n+\t// Default behaviour:\t\t\t\t(long)13,\n \t//\t\t\t\t\t\t(unsigned long long)19\n \t// Use extensions 'u', 'l' and 'll' for integral\n \t// literals (as in template arguments):\t\t13l, 19ull\n@@ -352,7 +352,7 @@ namespace __gnu_cxx\n       {\n \tfriend class qualifier_list<Allocator>;\n \ttypedef typename Allocator::template rebind<char>::other\n-    \t    char_Allocator;\n+\t    char_Allocator;\n \ttypedef std::basic_string<char, std::char_traits<char>, char_Allocator>\n \t    string_type;\n \n@@ -498,7 +498,7 @@ namespace __gnu_cxx\n \t  int n = M_substitutions_pos.size() - 1;\n \t  if (n > 0)\n \t    substitution_name += (n <= 10) ? (char)(n + '0' - 1)\n-\t      \t\t\t\t   : (char)(n + 'A' - 11);\n+\t\t\t\t\t   : (char)(n + 'A' - 11);\n \t  substitution_name += '_';\n \t  string_type subst;\n \t  int saved_pos = M_pos;\n@@ -1051,56 +1051,56 @@ namespace __gnu_cxx\n       }\n \n     // <operator-name> ::=\n-    //   nw\t\t\t\t# new           \n+    //   nw\t\t\t\t# new\n     //   na\t\t\t\t# new[]\n-    //   dl\t\t\t\t# delete        \n-    //   da\t\t\t\t# delete[]      \n+    //   dl\t\t\t\t# delete\n+    //   da\t\t\t\t# delete[]\n     //   ps\t\t\t\t# + (unary)\n-    //   ng\t\t\t\t# - (unary)     \n-    //   ad\t\t\t\t# & (unary)     \n-    //   de\t\t\t\t# * (unary)     \n-    //   co\t\t\t\t# ~             \n-    //   pl\t\t\t\t# +             \n-    //   mi\t\t\t\t# -             \n-    //   ml\t\t\t\t# *             \n-    //   dv\t\t\t\t# /             \n-    //   rm\t\t\t\t# %             \n-    //   an\t\t\t\t# &             \n-    //   or\t\t\t\t# |             \n-    //   eo\t\t\t\t# ^             \n-    //   aS\t\t\t\t# =             \n-    //   pL\t\t\t\t# +=            \n-    //   mI\t\t\t\t# -=            \n-    //   mL\t\t\t\t# *=            \n-    //   dV\t\t\t\t# /=            \n-    //   rM\t\t\t\t# %=            \n-    //   aN\t\t\t\t# &=            \n-    //   oR\t\t\t\t# |=            \n-    //   eO\t\t\t\t# ^=            \n-    //   ls\t\t\t\t# <<            \n-    //   rs\t\t\t\t# >>            \n-    //   lS\t\t\t\t# <<=           \n-    //   rS\t\t\t\t# >>=           \n-    //   eq\t\t\t\t# ==            \n-    //   ne\t\t\t\t# !=            \n-    //   lt\t\t\t\t# <             \n-    //   gt\t\t\t\t# >             \n-    //   le\t\t\t\t# <=            \n-    //   ge\t\t\t\t# >=            \n-    //   nt\t\t\t\t# !             \n-    //   aa\t\t\t\t# &&            \n-    //   oo\t\t\t\t# ||            \n-    //   pp\t\t\t\t# ++            \n-    //   mm\t\t\t\t# --            \n-    //   cm\t\t\t\t# ,             \n-    //   pm\t\t\t\t# ->*           \n-    //   pt\t\t\t\t# ->            \n-    //   cl\t\t\t\t# ()            \n-    //   ix\t\t\t\t# []            \n+    //   ng\t\t\t\t# - (unary)\n+    //   ad\t\t\t\t# & (unary)\n+    //   de\t\t\t\t# * (unary)\n+    //   co\t\t\t\t# ~\n+    //   pl\t\t\t\t# +\n+    //   mi\t\t\t\t# -\n+    //   ml\t\t\t\t# *\n+    //   dv\t\t\t\t# /\n+    //   rm\t\t\t\t# %\n+    //   an\t\t\t\t# &\n+    //   or\t\t\t\t# |\n+    //   eo\t\t\t\t# ^\n+    //   aS\t\t\t\t# =\n+    //   pL\t\t\t\t# +=\n+    //   mI\t\t\t\t# -=\n+    //   mL\t\t\t\t# *=\n+    //   dV\t\t\t\t# /=\n+    //   rM\t\t\t\t# %=\n+    //   aN\t\t\t\t# &=\n+    //   oR\t\t\t\t# |=\n+    //   eO\t\t\t\t# ^=\n+    //   ls\t\t\t\t# <<\n+    //   rs\t\t\t\t# >>\n+    //   lS\t\t\t\t# <<=\n+    //   rS\t\t\t\t# >>=\n+    //   eq\t\t\t\t# ==\n+    //   ne\t\t\t\t# !=\n+    //   lt\t\t\t\t# <\n+    //   gt\t\t\t\t# >\n+    //   le\t\t\t\t# <=\n+    //   ge\t\t\t\t# >=\n+    //   nt\t\t\t\t# !\n+    //   aa\t\t\t\t# &&\n+    //   oo\t\t\t\t# ||\n+    //   pp\t\t\t\t# ++\n+    //   mm\t\t\t\t# --\n+    //   cm\t\t\t\t# ,\n+    //   pm\t\t\t\t# ->*\n+    //   pt\t\t\t\t# ->\n+    //   cl\t\t\t\t# ()\n+    //   ix\t\t\t\t# []\n     //   qu\t\t\t\t# ?\n     //   st\t\t\t\t# sizeof (a type)\n     //   sz\t\t\t\t# sizeof (an expression)\n-    //   cv <type>\t\t\t# (cast)        \n+    //   cv <type>\t\t\t# (cast)\n     //   v <digit> <source-name>\t# vendor extended operator\n     //\n     // Symbol operator codes exist of two characters, we need to find a\n@@ -1579,15 +1579,15 @@ namespace __gnu_cxx\n     //   <builtin-type>\t\t# Starts with a lower case character != r.\n     //   <function-type>\t# Starts with F\n     //   <class-enum-type>\t# Starts with N, S, C, D, Z, a digit or a lower\n-    //   \t\t\t# case character.  Since a lower case character\n-    //   \t\t\t# would be an operator name, that would be an\n-    //   \t\t\t# error.  The S is a substitution or St\n-    //   \t\t\t# (::std::).  A 'C' would be a constructor and\n-    //   \t\t\t# thus also an error.\n+    //\t\t\t\t# case character.  Since a lower case character\n+    //\t\t\t\t# would be an operator name, that would be an\n+    //\t\t\t\t# error.  The S is a substitution or St\n+    //\t\t\t\t# (::std::).  A 'C' would be a constructor and\n+    //\t\t\t\t# thus also an error.\n     //   <template-param>\t# Starts with T\n     //   <substitution>         # Starts with S\n     //   <template-template-param> <template-args>  # Starts with T or S,\n-    //   \t\t\t\t\t    # equivalent with the above.\n+    //\t\t\t\t\t\t    # equivalent with the above.\n     //\n     //   <array-type>\t\t\t# Starts with A\n     //   <pointer-to-member-type>\t# Starts with M\n@@ -1596,8 +1596,8 @@ namespace __gnu_cxx\n     //   R <type>   # reference-to\t# Starts with R\n     //   C <type>   # complex (C 2000)\t# Starts with C\n     //   G <type>   # imaginary (C 2000)# Starts with G\n-    //   U <source-name> <type>     \t# vendor extended type qualifier,\n-    //   \t\t\t\t# starts with U\n+    //   U <source-name> <type>\t\t# vendor extended type qualifier,\n+    //\t\t\t\t\t# starts with U\n     //\n     // <template-template-param> ::= <template-param>\n     //                           ::= <substitution>\n@@ -1613,24 +1613,24 @@ namespace __gnu_cxx\n     // <I> is the array index.\n     //\t\t\t\t\t\tSubstitutions:\n     // <Q>M<C><Q2>F<R><B>E  ==> R (C::*Q)B Q2\t\"<C>\", \"F<R><B>E\"\n-    // \t\t\t\t\t\t    (<R> and <B> recursive),\n-    // \t\t\t\t\t\t    \"M<C><Q2>F<R><B>E\".\n-    // <Q>F<R><B>E \t    ==> R (Q)B\t\t\"<R>\", \"<B>\" (<B> recursive)\n+    //\t\t\t\t\t\t    (<R> and <B> recursive),\n+    //\t\t\t\t\t\t    \"M<C><Q2>F<R><B>E\".\n+    // <Q>F<R><B>E\t    ==> R (Q)B\t\t\"<R>\", \"<B>\" (<B> recursive)\n     //                                              and \"F<R><B>E\".\n     //\n     // Note that if <R> has postfix qualifiers (an array or function), then\n     // those are added AFTER the (member) function type.  For example:\n     // <Q>FPA<R><B>E ==> R (*(Q)B) [], where the PA added the prefix\n     // \"(*\" and the postfix \") []\".\n     //\n-    // <Q>G<T>     \t    ==> imaginary T Q\t\"<T>\", \"G<T>\" (<T> recursive).\n-    // <Q>C<T>     \t    ==> complex T Q\t\"<T>\", \"C<T>\" (<T> recursive).\n-    // <Q><T>      \t    ==> T Q\t\t\"<T>\" (<T> recursive).\n+    // <Q>G<T>\t\t    ==> imaginary T Q\t\"<T>\", \"G<T>\" (<T> recursive).\n+    // <Q>C<T>\t\t    ==> complex T Q\t\"<T>\", \"C<T>\" (<T> recursive).\n+    // <Q><T>\t\t    ==> T Q\t\t\"<T>\" (<T> recursive).\n     //\n     // where <Q> is any of:\n     //\n-    // <Q>P   \t\t==> *Q\t\t\t\t\"P...\"\n-    // <Q>R   \t\t==> &Q\t\t\t\t\"R...\"\n+    // <Q>P\t\t==> *Q\t\t\t\t\"P...\"\n+    // <Q>R\t\t==> &Q\t\t\t\t\"R...\"\n     // <Q>[K|V|r]+\t==> [ const| volatile| restrict]+Q\t\"KVr...\"\n     // <Q>U<S>\t\t==>  SQ\t\t\t\t\"U<S>...\"\n     // <Q>M<C>\t\t==> C::*Q\t\t\t\"M<C>...\" (<C> recurs.)\n@@ -1641,7 +1641,7 @@ namespace __gnu_cxx\n     //   A<I2>A<I>\t==>  [I2][I]\n     //   If <Q> ends on [KVr]+, which can happen in combination with\n     //   substitutions only, then special handling is required, see below.\n-    //  \n+    //\n     // A <substitution> is handled with an input position switch during which\n     // new substitutions are turned off.  Because recursive handling of types\n     // (and therefore the order in which substitutions must be generated) must\n@@ -1653,7 +1653,7 @@ namespace __gnu_cxx\n     //\n     // The following comment was for the demangling of g++ version 3.0.x.  The\n     // mangling (and I believe even the ABI description) have been fixed now\n-    // (as of g++ version 3.1).\t\n+    // (as of g++ version 3.1).\n     //\n     // g++ 3.0.x only:\n     // The ABI specifies for pointer-to-member function types the format\n@@ -1696,7 +1696,7 @@ namespace __gnu_cxx\n     static int const cvq_A = 8;\t\t// Saw at least one A\n     static int const cvq_last = 16;\t// No remaining qualifiers.\n     static int const cvq_A_cnt = 32;\t// Bit 5 and higher represent the\n-    \t\t\t\t\t//   number of A's in the series.\n+\t\t\t\t\t//   number of A's in the series.\n     // In the function below, iter_array points to the first (right most)\n     // A in the series, if any.\n     template<typename Allocator>\n@@ -2011,9 +2011,9 @@ namespace __gnu_cxx\n \t}\n \tif (!failure)\n \t{\n-\t  // <Q>G<T>     \t\t==> imaginary T Q\n+\t  // <Q>G<T>\t\t\t==> imaginary T Q\n \t  //     substitutions: \"<T>\", \"G<T>\" (<T> recursive).\n-\t  // <Q>C<T>     \t\t==> complex T Q\n+\t  // <Q>C<T>\t\t\t==> complex T Q\n \t  //     substitutions: \"<T>\", \"C<T>\" (<T> recursive).\n \t  if (current() == 'C' || current() == 'G')\n \t  {\n@@ -2034,8 +2034,8 @@ namespace __gnu_cxx\n \t      bool extern_C = (next() == 'Y');\n \t      if (extern_C)\n \t\teat_current();\n-\t        \n-\t      // <Q>F<R><B>E \t\t==> R (Q)B\n+\n+\t      // <Q>F<R><B>E\t\t==> R (Q)B\n \t      //     substitution: \"<R>\", \"<B>\" (<B> recursive) and \"F<R><B>E\".\n \n \t      // Return type.\n@@ -2143,7 +2143,7 @@ namespace __gnu_cxx\n \t    case '7':\n \t    case '8':\n \t    case '9':\n-\t      // <Q><T>      \t\t==> T Q\n+\t      // <Q><T>\t\t\t==> T Q\n \t      //     substitutions: \"<T>\" (<T> recursive).\n \t      if (!decode_class_enum_type(prefix))\n \t      {\n@@ -2161,7 +2161,7 @@ namespace __gnu_cxx\n \t\tqualifiers->printing_suppressed();\n \t      break;\n \t    default:\n-\t      // <Q><T>      \t\t==> T Q\n+\t      // <Q><T>\t\t\t==> T Q\n \t      //     substitutions: \"<T>\" (<T> recursive).\n \t      if (!decode_builtin_type(prefix))\n \t      {\n@@ -2246,7 +2246,7 @@ namespace __gnu_cxx\n \t    {\n \t      // substitution: \"<template-prefix> <template-args>\".\n \t      add_substitution(substitution_start, nested_name_prefix,\n-\t\t  \t       number_of_prefixes);\n+\t\t\t       number_of_prefixes);\n \t    }\n \t  }\n \t  else\n@@ -2348,7 +2348,7 @@ namespace __gnu_cxx\n \n     // <unqualified-name> ::= <operator-name>\t# Starts with lower case.\n     //                    ::= <ctor-dtor-name>  # Starts with 'C' or 'D'.\n-    //                    ::= <source-name>   \t# Starts with a digit.\n+    //                    ::= <source-name>\t# Starts with a digit.\n     //\n     template<typename Allocator>\n       bool\n@@ -2446,8 +2446,8 @@ namespace __gnu_cxx\n     //   <unscoped-template-name> <template-args> # idem\n     //   <local-name>\t\t\t\t# Starts with 'Z'\n     //   <unscoped-name>\t\t\t# Starts with 'S', 'C', 'D',\n-    //   \t\t\t\t\t# a digit or a lower case\n-    //   \t\t\t\t\t# character.\n+    //\t\t\t\t\t\t# a digit or a lower case\n+    //\t\t\t\t\t\t# character.\n     //\n     // <unscoped-template-name> ::= <unscoped-name>\n     //                          ::= <substitution>\n@@ -2488,7 +2488,7 @@ namespace __gnu_cxx\n \n     // <call-offset> ::= h <nv-offset> _\n     //               ::= v <v-offset> _\n-    // <nv-offset>   ::= <offset number> \n+    // <nv-offset>   ::= <offset number>\n     //     non-virtual base override\n     //\n     // <v-offset>    ::= <offset number> _ <virtual offset number>\n@@ -2538,10 +2538,10 @@ namespace __gnu_cxx\n     //   TS <type>\t\t\t# typeinfo name (null-terminated\n     //                                    byte string).\n     //   GV <object name>\t\t# Guard variable for one-time\n-    //   \t\t\t\t  initialization of static objects in\n-    //   \t\t\t\t  a local scope.\n+    //\t\t\t\t\t  initialization of static objects in\n+    //\t\t\t\t\t  a local scope.\n     //   T <call-offset> <base encoding># base is the nominal target function\n-    //   \t\t\t\t  of thunk.\n+    //\t\t\t\t\t  of thunk.\n     //   Tc <call-offset> <call-offset> <base encoding> # base is the nominal\n     //                                    target function of thunk; first\n     //                                    call-offset is 'this' adjustment;\n@@ -2629,8 +2629,8 @@ namespace __gnu_cxx\n \n     // <encoding> ::=\n     //   <function name> <bare-function-type>\t# Starts with 'C', 'D', 'N',\n-    //                                        \t  'S', a digit or a lower case\n-    //                                        \t  character.\n+    //\t\t\t\t\t\t  'S', a digit or a lower case\n+    //\t\t\t\t\t\t  character.\n     //   <data name>\t\t\t\t# Idem.\n     //   <special-name>\t\t\t\t# Starts with 'T' or 'G'.\n     template<typename Allocator>\n@@ -2691,7 +2691,7 @@ namespace __gnu_cxx\n     struct demangle\n     {\n       typedef typename Allocator::template rebind<char>::other char_Allocator;\n-      typedef std::basic_string<char, std::char_traits<char>, char_Allocator> \n+      typedef std::basic_string<char, std::char_traits<char>, char_Allocator>\n \t  string_type;\n       static string_type symbol(char const* in,\n                                 demangler::implementation_details const& id);\n@@ -2769,7 +2769,7 @@ namespace __gnu_cxx\n \t    || demangler_session.remaining_input_characters())\n \t{\n \t  // Failure to demangle, return the mangled name.\n-\t  result = input;\t\t\t\t\n+\t  result = input;\n \t}\n       }\n       return result;"}, {"sha": "a30c85166840f70b17a288f3f4a35ed27ef5667e", "filename": "libstdc++-v3/include/bits/deque.tcc", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -62,7 +62,7 @@\n #define _DEQUE_TCC 1\n \n namespace __gnu_norm\n-{ \n+{\n   template <typename _Tp, typename _Alloc>\n     deque<_Tp,_Alloc>&\n     deque<_Tp,_Alloc>::\n@@ -82,10 +82,10 @@ namespace __gnu_norm\n \t    }\n \t}\n       return *this;\n-    }        \n-  \n+    }\n+\n   template <typename _Tp, typename _Alloc>\n-    typename deque<_Tp,_Alloc>::iterator \n+    typename deque<_Tp,_Alloc>::iterator\n     deque<_Tp,_Alloc>::\n     insert(iterator position, const value_type& __x)\n     {\n@@ -104,9 +104,9 @@ namespace __gnu_norm\n       else\n         return _M_insert_aux(position, __x);\n     }\n-  \n+\n   template <typename _Tp, typename _Alloc>\n-    typename deque<_Tp,_Alloc>::iterator \n+    typename deque<_Tp,_Alloc>::iterator\n     deque<_Tp,_Alloc>::\n     erase(iterator __position)\n     {\n@@ -125,9 +125,9 @@ namespace __gnu_norm\n \t}\n       return this->_M_start + __index;\n     }\n-  \n+\n   template <typename _Tp, typename _Alloc>\n-    typename deque<_Tp,_Alloc>::iterator \n+    typename deque<_Tp,_Alloc>::iterator\n     deque<_Tp,_Alloc>::\n     erase(iterator __first, iterator __last)\n     {\n@@ -160,8 +160,8 @@ namespace __gnu_norm\n \t  return this->_M_start + __elems_before;\n \t}\n     }\n-    \n-  template <typename _Tp, typename _Alloc> \n+\n+  template <typename _Tp, typename _Alloc>\n     void\n     deque<_Tp,_Alloc>::\n     clear()\n@@ -173,7 +173,7 @@ namespace __gnu_norm\n \t  std::_Destroy(*__node, *__node + _S_buffer_size());\n \t  _M_deallocate_node(*__node);\n \t}\n-    \n+\n       if (this->_M_start._M_node != this->_M_finish._M_node)\n \t{\n \t  std::_Destroy(this->_M_start._M_cur, this->_M_start._M_last);\n@@ -182,10 +182,10 @@ namespace __gnu_norm\n \t}\n       else\n         std::_Destroy(this->_M_start._M_cur, this->_M_finish._M_cur);\n-      \n+\n       this->_M_finish = this->_M_start;\n     }\n-    \n+\n   template <typename _Tp, class _Alloc>\n     template <typename _InputIterator>\n       void\n@@ -201,7 +201,7 @@ namespace __gnu_norm\n         else\n           insert(end(), __first, __last);\n       }\n-    \n+\n   template <typename _Tp, typename _Alloc>\n     void\n     deque<_Tp,_Alloc>::\n@@ -232,14 +232,14 @@ namespace __gnu_norm\n \t  catch(...)\n \t    {\n \t      _M_destroy_nodes(this->_M_finish._M_node + 1,\n-\t\t\t       __new_finish._M_node + 1);    \n+\t\t\t       __new_finish._M_node + 1);\n \t      __throw_exception_again;\n \t    }\n \t}\n-      else \n+      else\n         _M_insert_aux(__pos, __n, __x);\n     }\n-    \n+\n   template <typename _Tp, typename _Alloc>\n     void\n     deque<_Tp,_Alloc>::\n@@ -262,7 +262,7 @@ namespace __gnu_norm\n           __throw_exception_again;\n         }\n     }\n-    \n+\n   template <typename _Tp, typename _Alloc>\n     template <typename _InputIterator>\n       void\n@@ -282,7 +282,7 @@ namespace __gnu_norm\n             __throw_exception_again;\n           }\n       }\n-    \n+\n   template <typename _Tp, typename _Alloc>\n     template <typename _ForwardIterator>\n       void\n@@ -292,12 +292,12 @@ namespace __gnu_norm\n       {\n         const size_type __n = std::distance(__first, __last);\n         this->_M_initialize_map(__n);\n-      \n+\n         _Map_pointer __cur_node;\n         try\n           {\n-            for (__cur_node = this->_M_start._M_node; \n-                 __cur_node < this->_M_finish._M_node; \n+            for (__cur_node = this->_M_start._M_node;\n+                 __cur_node < this->_M_finish._M_node;\n                  ++__cur_node)\n             {\n               _ForwardIterator __mid = __first;\n@@ -313,7 +313,7 @@ namespace __gnu_norm\n             __throw_exception_again;\n           }\n       }\n-    \n+\n   // Called only if _M_finish._M_cur == _M_finish._M_last - 1.\n   template <typename _Tp, typename _Alloc>\n     void\n@@ -335,7 +335,7 @@ namespace __gnu_norm\n           __throw_exception_again;\n         }\n     }\n-    \n+\n   // Called only if _M_start._M_cur == _M_start._M_first.\n   template <typename _Tp, typename _Alloc>\n     void\n@@ -357,8 +357,8 @@ namespace __gnu_norm\n           _M_deallocate_node(*(this->_M_start._M_node - 1));\n           __throw_exception_again;\n         }\n-    } \n-    \n+    }\n+\n   // Called only if _M_finish._M_cur == _M_finish._M_first.\n   template <typename _Tp, typename _Alloc>\n     void deque<_Tp,_Alloc>::\n@@ -369,10 +369,10 @@ namespace __gnu_norm\n       this->_M_finish._M_cur = this->_M_finish._M_last - 1;\n       std::_Destroy(this->_M_finish._M_cur);\n     }\n-    \n-  // Called only if _M_start._M_cur == _M_start._M_last - 1.  Note that \n-  // if the deque has at least one element (a precondition for this member \n-  // function), and if _M_start._M_cur == _M_start._M_last, then the deque \n+\n+  // Called only if _M_start._M_cur == _M_start._M_last - 1.  Note that\n+  // if the deque has at least one element (a precondition for this member\n+  // function), and if _M_start._M_cur == _M_start._M_last, then the deque\n   // must have at least two nodes.\n   template <typename _Tp, typename _Alloc>\n     void deque<_Tp,_Alloc>::\n@@ -382,8 +382,8 @@ namespace __gnu_norm\n       _M_deallocate_node(this->_M_start._M_first);\n       this->_M_start._M_set_node(this->_M_start._M_node + 1);\n       this->_M_start._M_cur = this->_M_start._M_first;\n-    }      \n-    \n+    }\n+\n   template <typename _Tp, typename _Alloc>\n     template <typename _InputIterator>\n       void\n@@ -392,7 +392,7 @@ namespace __gnu_norm\n                           _InputIterator __first, _InputIterator __last,\n                           input_iterator_tag)\n       { std::copy(__first, __last, std::inserter(*this, __pos)); }\n-    \n+\n   template <typename _Tp, typename _Alloc>\n     template <typename _ForwardIterator>\n       void\n@@ -434,7 +434,7 @@ namespace __gnu_norm\n         else\n           _M_insert_aux(__pos, __first, __last, __n);\n       }\n-    \n+\n   template <typename _Tp, typename _Alloc>\n     typename deque<_Tp, _Alloc>::iterator\n     deque<_Tp,_Alloc>::\n@@ -467,7 +467,7 @@ namespace __gnu_norm\n       *__pos = __x_copy;\n       return __pos;\n     }\n-    \n+\n   template <typename _Tp, typename _Alloc>\n     void\n     deque<_Tp,_Alloc>::\n@@ -495,14 +495,14 @@ namespace __gnu_norm\n \t      else\n \t\t{\n \t\t  std::__uninitialized_copy_fill(this->_M_start, __pos,\n-\t\t\t\t\t\t __new_start, \n+\t\t\t\t\t\t __new_start,\n \t\t\t\t\t\t this->_M_start, __x_copy);\n \t\t  this->_M_start = __new_start;\n \t\t  std::fill(__old_start, __pos, __x_copy);\n \t\t}\n \t    }\n \t  catch(...)\n-\t    { \n+\t    {\n \t      _M_destroy_nodes(__new_start._M_node, this->_M_start._M_node);\n \t      __throw_exception_again;\n \t    }\n@@ -511,7 +511,7 @@ namespace __gnu_norm\n \t{\n \t  iterator __new_finish = _M_reserve_elements_at_back(__n);\n \t  iterator __old_finish = this->_M_finish;\n-\t  const difference_type __elems_after = \n+\t  const difference_type __elems_after =\n \t    difference_type(__length) - __elems_before;\n \t  __pos = this->_M_finish - __elems_after;\n \t  try\n@@ -536,14 +536,14 @@ namespace __gnu_norm\n \t\t}\n \t    }\n \t  catch(...)\n-\t    { \n+\t    {\n \t      _M_destroy_nodes(this->_M_finish._M_node + 1,\n \t\t\t       __new_finish._M_node + 1);\n \t      __throw_exception_again;\n \t    }\n \t}\n     }\n-  \n+\n   template <typename _Tp, typename _Alloc>\n     template <typename _ForwardIterator>\n       void\n@@ -563,7 +563,7 @@ namespace __gnu_norm\n \t      {\n \t\tif (__elemsbefore >= difference_type(__n))\n \t\t  {\n-\t\t    iterator __start_n = this->_M_start + difference_type(__n); \n+\t\t    iterator __start_n = this->_M_start + difference_type(__n);\n \t\t    std::uninitialized_copy(this->_M_start, __start_n,\n \t\t\t\t\t    __new_start);\n \t\t    this->_M_start = __new_start;\n@@ -590,7 +590,7 @@ namespace __gnu_norm\n         {\n           iterator __new_finish = _M_reserve_elements_at_back(__n);\n           iterator __old_finish = this->_M_finish;\n-          const difference_type __elemsafter = \n+          const difference_type __elemsafter =\n             difference_type(__length) - __elemsbefore;\n           __pos = this->_M_finish - __elemsafter;\n           try\n@@ -624,7 +624,7 @@ namespace __gnu_norm\n             }\n         }\n       }\n-    \n+\n   template <typename _Tp, typename _Alloc>\n     void\n     deque<_Tp,_Alloc>::\n@@ -642,11 +642,11 @@ namespace __gnu_norm\n       catch(...)\n         {\n           for (size_type __j = 1; __j < __i; ++__j)\n-            _M_deallocate_node(*(this->_M_start._M_node - __j));      \n+            _M_deallocate_node(*(this->_M_start._M_node - __j));\n           __throw_exception_again;\n         }\n     }\n-    \n+\n   template <typename _Tp, typename _Alloc>\n     void\n     deque<_Tp,_Alloc>::\n@@ -664,11 +664,11 @@ namespace __gnu_norm\n       catch(...)\n         {\n           for (size_type __j = 1; __j < __i; ++__j)\n-            _M_deallocate_node(*(this->_M_finish._M_node + __j));      \n+            _M_deallocate_node(*(this->_M_finish._M_node + __j));\n           __throw_exception_again;\n         }\n     }\n-    \n+\n   template <typename _Tp, typename _Alloc>\n     void\n     deque<_Tp,_Alloc>::\n@@ -677,40 +677,40 @@ namespace __gnu_norm\n       size_type __old_num_nodes\n \t= this->_M_finish._M_node - this->_M_start._M_node + 1;\n       size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;\n-    \n+\n       _Map_pointer __new_nstart;\n       if (this->_M_map_size > 2 * __new_num_nodes)\n \t{\n \t  __new_nstart = this->_M_map + (this->_M_map_size\n-\t\t\t\t\t - __new_num_nodes) / 2 \n+\t\t\t\t\t - __new_num_nodes) / 2\n \t                 + (__add_at_front ? __nodes_to_add : 0);\n \t  if (__new_nstart < this->_M_start._M_node)\n \t    std::copy(this->_M_start._M_node,\n \t\t    this->_M_finish._M_node + 1,\n \t\t    __new_nstart);\n \t  else\n \t    std::copy_backward(this->_M_start._M_node,\n-\t\t\t       this->_M_finish._M_node + 1, \n+\t\t\t       this->_M_finish._M_node + 1,\n \t\t\t       __new_nstart + __old_num_nodes);\n \t}\n       else\n \t{\n \t  size_type __new_map_size = this->_M_map_size\n \t                             + std::max(this->_M_map_size,\n \t\t\t\t\t\t__nodes_to_add) + 2;\n-    \n+\n \t  _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);\n \t  __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2\n \t                 + (__add_at_front ? __nodes_to_add : 0);\n \t  std::copy(this->_M_start._M_node,\n \t\t    this->_M_finish._M_node + 1,\n \t\t    __new_nstart);\n \t  _M_deallocate_map(this->_M_map, this->_M_map_size);\n-\t  \n+\n \t  this->_M_map = __new_map;\n \t  this->_M_map_size = __new_map_size;\n \t}\n-      \n+\n       this->_M_start._M_set_node(__new_nstart);\n       this->_M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);\n     }"}, {"sha": "9022b5825940cf846790c35ca986ef86b28f5820", "filename": "libstdc++-v3/include/bits/fstream.tcc", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -73,20 +73,20 @@ namespace std\n \n   template<typename _CharT, typename _Traits>\n     basic_filebuf<_CharT, _Traits>::\n-    basic_filebuf() : __streambuf_type(), _M_file(&_M_lock), \n+    basic_filebuf() : __streambuf_type(), _M_file(&_M_lock),\n     _M_mode(ios_base::openmode(0)), _M_state_beg(), _M_state_cur(),\n     _M_state_last(), _M_buf(NULL), _M_buf_size(BUFSIZ),\n     _M_buf_allocated(false), _M_reading(false), _M_writing(false),\n     _M_pback_cur_save(0), _M_pback_end_save(0), _M_pback_init(false),\n     _M_codecvt(0), _M_ext_buf(0), _M_ext_buf_size(0), _M_ext_next(0),\n     _M_ext_end(0)\n-    { \n+    {\n       if (has_facet<__codecvt_type>(this->_M_buf_locale))\n \t_M_codecvt = &use_facet<__codecvt_type>(this->_M_buf_locale);\n     }\n \n   template<typename _CharT, typename _Traits>\n-    typename basic_filebuf<_CharT, _Traits>::__filebuf_type* \n+    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*\n     basic_filebuf<_CharT, _Traits>::\n     open(const char* __s, ios_base::openmode __mode)\n     {\n@@ -108,8 +108,8 @@ namespace std\n \t      _M_state_last = _M_state_cur = _M_state_beg;\n \n \t      // 27.8.1.3,4\n-\t      if ((__mode & ios_base::ate) \n-\t\t  && this->seekoff(0, ios_base::end, __mode) \n+\t      if ((__mode & ios_base::ate)\n+\t\t  && this->seekoff(0, ios_base::end, __mode)\n \t\t  == pos_type(off_type(-1)))\n \t\tthis->close();\n \t      else\n@@ -120,7 +120,7 @@ namespace std\n     }\n \n   template<typename _CharT, typename _Traits>\n-    typename basic_filebuf<_CharT, _Traits>::__filebuf_type* \n+    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*\n     basic_filebuf<_CharT, _Traits>::\n     close() throw()\n     {\n@@ -135,7 +135,7 @@ namespace std\n \t    }\n \t  catch(...)\n \t    { __testfail = true; }\n-\t      \n+\n \t  // NB: Do this here so that re-opened filebufs will be cool...\n \t  this->_M_mode = ios_base::openmode(0);\n \t  this->_M_pback_init = false;\n@@ -144,7 +144,7 @@ namespace std\n \t  _M_writing = false;\n \t  _M_set_buffer(-1);\n \t  _M_state_last = _M_state_cur = _M_state_beg;\n-\t  \n+\n \t  if (!_M_file.close())\n \t    __testfail = true;\n \n@@ -155,7 +155,7 @@ namespace std\n     }\n \n   template<typename _CharT, typename _Traits>\n-    streamsize \n+    streamsize\n     basic_filebuf<_CharT, _Traits>::\n     showmanyc()\n     {\n@@ -173,7 +173,7 @@ namespace std\n     }\n \n   template<typename _CharT, typename _Traits>\n-    typename basic_filebuf<_CharT, _Traits>::int_type \n+    typename basic_filebuf<_CharT, _Traits>::int_type\n     basic_filebuf<_CharT, _Traits>::\n     underflow()\n     {\n@@ -192,15 +192,15 @@ namespace std\n \t  // Get and convert input sequence.\n \t  const size_t __buflen = this->_M_buf_size > 1\n \t                          ? this->_M_buf_size - 1 : 1;\n-\t  \n+\n \t  // Will be set to true if ::read() returns 0 indicating EOF.\n \t  bool __got_eof = false;\n \t  // Number of internal characters produced.\n \t  streamsize __ilen = 0;\n-\t  codecvt_base::result __r = codecvt_base::ok;\t  \n+\t  codecvt_base::result __r = codecvt_base::ok;\n \t  if (__check_facet(_M_codecvt).always_noconv())\n \t    {\n-\t      __ilen = _M_file.xsgetn(reinterpret_cast<char*>(this->eback()), \n+\t      __ilen = _M_file.xsgetn(reinterpret_cast<char*>(this->eback()),\n \t\t\t\t      __buflen);\n \t      if (__ilen == 0)\n \t\t__got_eof = true;\n@@ -226,7 +226,7 @@ namespace std\n \t      // chars already present.\n \t      if (_M_reading && this->egptr() == this->eback() && __remainder)\n \t\t__rlen = 0;\n-      \n+\n \t      // Allocate buffer if necessary and move unconverted\n \t      // bytes to front.\n \t      if (_M_ext_buf_size < __blen)\n@@ -269,7 +269,7 @@ namespace std\n \n \t\t  char_type* __iend;\n \t\t  __r = _M_codecvt->in(_M_state_cur, _M_ext_next,\n-\t\t\t\t       _M_ext_end, _M_ext_next, this->eback(), \n+\t\t\t\t       _M_ext_end, _M_ext_next, this->eback(),\n \t\t\t\t       this->eback() + __buflen, __iend);\n \t\t  if (__r == codecvt_base::noconv)\n \t\t    {\n@@ -302,7 +302,7 @@ namespace std\n \t  else if (__got_eof)\n \t    {\n \t      // If the actual end of file is reached, set 'uncommitted'\n-\t      // mode, thus allowing an immediate write without an \n+\t      // mode, thus allowing an immediate write without an\n \t      // intervening seek.\n \t      _M_set_buffer(-1);\n \t      _M_reading = false;\n@@ -317,13 +317,13 @@ namespace std\n \t\t\t\t\"invalid byte sequence in file\"));\n \t  else\n \t    __throw_ios_failure(__N(\"basic_filebuf::underflow \"\n-\t\t\t\t\"error reading the file\"));\t    \n+\t\t\t\t\"error reading the file\"));\n \t}\n       return __ret;\n     }\n \n   template<typename _CharT, typename _Traits>\n-    typename basic_filebuf<_CharT, _Traits>::int_type \n+    typename basic_filebuf<_CharT, _Traits>::int_type\n     basic_filebuf<_CharT, _Traits>::\n     pbackfail(int_type __i)\n     {\n@@ -333,7 +333,7 @@ namespace std\n \t{\n \t  // Remember whether the pback buffer is active, otherwise below\n \t  // we may try to store in it a second char (libstdc++/9761).\n-\t  const bool __testpb = this->_M_pback_init;\t   \n+\t  const bool __testpb = this->_M_pback_init;\n \t  const bool __testeof = traits_type::eq_int_type(__i, __ret);\n \t  int_type __tmp;\n \t  if (this->eback() < this->gptr())\n@@ -367,15 +367,15 @@ namespace std\n \t    {\n \t      _M_create_pback();\n \t      _M_reading = true;\n-\t      *this->gptr() = traits_type::to_char_type(__i); \n+\t      *this->gptr() = traits_type::to_char_type(__i);\n \t      __ret = __i;\n \t    }\n \t}\n       return __ret;\n     }\n \n   template<typename _CharT, typename _Traits>\n-    typename basic_filebuf<_CharT, _Traits>::int_type \n+    typename basic_filebuf<_CharT, _Traits>::int_type\n     basic_filebuf<_CharT, _Traits>::\n     overflow(int_type __c)\n     {\n@@ -392,7 +392,7 @@ namespace std\n \t\t  *this->pptr() = traits_type::to_char_type(__c);\n \t\t  this->pbump(1);\n \t\t}\n-\t      \n+\n \t      // Convert pending sequence to external representation,\n \t      // and output.\n \t      if (_M_convert_to_external(this->pbase(),\n@@ -422,15 +422,15 @@ namespace std\n \t      // Unbuffered.\n \t      char_type __conv = traits_type::to_char_type(__c);\n \t      if (__testeof || _M_convert_to_external(&__conv, 1))\n-\t\t{\t\t  \n+\t\t{\n \t\t  _M_writing = true;\n \t\t  __ret = traits_type::not_eof(__c);\n \t\t}\n \t    }\n \t}\n       return __ret;\n     }\n-  \n+\n   template<typename _CharT, typename _Traits>\n     bool\n     basic_filebuf<_CharT, _Traits>::\n@@ -456,7 +456,7 @@ namespace std\n \t  codecvt_base::result __r;\n \t  __r = _M_codecvt->out(_M_state_cur, __ibuf, __ibuf + __ilen,\n \t\t\t\t__iend, __buf, __buf + __blen, __bend);\n-\t  \n+\n \t  if (__r == codecvt_base::ok || __r == codecvt_base::partial)\n \t    __blen = __bend - __buf;\n \t  else if (__r == codecvt_base::noconv)\n@@ -470,20 +470,20 @@ namespace std\n \t      // Result == error.\n \t      __blen = 0;\n \t    }\n-\t  \n+\n \t  if (__blen)\n \t    {\n \t      __elen += _M_file.xsputn(__buf, __blen);\n \t      __plen += __blen;\n \t    }\n-\t  \n+\n \t  // Try once more for partial conversions.\n \t  if (__r == codecvt_base::partial)\n \t    {\n \t      const char_type* __iresume = __iend;\n \t      streamsize __rlen = this->pptr() - __iend;\n \t      __r = _M_codecvt->out(_M_state_cur, __iresume,\n-\t\t\t\t    __iresume + __rlen, __iend, __buf, \n+\t\t\t\t    __iresume + __rlen, __iend, __buf,\n \t\t\t\t    __buf + __blen, __bend);\n \t      if (__r != codecvt_base::error)\n \t\t{\n@@ -500,7 +500,7 @@ namespace std\n      streamsize\n      basic_filebuf<_CharT, _Traits>::\n      xsputn(const _CharT* __s, streamsize __n)\n-     { \n+     {\n        // Optimization in the always_noconv() case, to be generalized in the\n        // future: when __n is sufficiently large we write directly instead of\n        // using the buffer.\n@@ -523,7 +523,7 @@ namespace std\n \t      const streamsize __buffill = this->pptr() - this->pbase();\n \t      const char* __buf = reinterpret_cast<const char*>(this->pbase());\n \t      __ret = _M_file.xsputn_2(__buf, __buffill,\n-\t\t\t\t       reinterpret_cast<const char*>(__s), \n+\t\t\t\t       reinterpret_cast<const char*>(__s),\n \t\t\t\t       __n);\n \t      if (__ret == __buffill + __n)\n \t\t{\n@@ -539,12 +539,12 @@ namespace std\n \t    __ret = __streambuf_type::xsputn(__s, __n);\n \t}\n        else\n-\t __ret = __streambuf_type::xsputn(__s, __n);      \n+\t __ret = __streambuf_type::xsputn(__s, __n);\n        return __ret;\n     }\n \n   template<typename _CharT, typename _Traits>\n-    typename basic_filebuf<_CharT, _Traits>::__streambuf_type* \n+    typename basic_filebuf<_CharT, _Traits>::__streambuf_type*\n     basic_filebuf<_CharT, _Traits>::\n     setbuf(char_type* __s, streamsize __n)\n     {\n@@ -564,9 +564,9 @@ namespace std\n \t    this->_M_buf = __s;\n \t    this->_M_buf_size = __n;\n \t  }\n-      return this; \n+      return this;\n     }\n-  \n+\n \n   // According to 27.8.1.4 p11 - 13, seekoff should ignore the last\n   // argument (of type openmode).\n@@ -581,9 +581,9 @@ namespace std\n       if (__width < 0)\n \t__width = 0;\n \n-      pos_type __ret =  pos_type(off_type(-1)); \n+      pos_type __ret =  pos_type(off_type(-1));\n       const bool __testfail = __off != 0 && __width <= 0;\n-      if (this->is_open() && !__testfail) \n+      if (this->is_open() && !__testfail)\n \t{\n \t  // Ditch any pback buffers to avoid confusion.\n \t  _M_destroy_pback();\n@@ -608,10 +608,10 @@ namespace std\n \t\t    _M_codecvt->length(_M_state_last, _M_ext_buf, _M_ext_next,\n \t\t\t\t       this->gptr() - this->eback());\n \t\t  __computed_off += _M_ext_buf + __gptr_off - _M_ext_end;\n- \t\t  \n+\n \t\t  // _M_state_last is modified by codecvt::length() so\n- \t\t  // it now corresponds to gptr().\n- \t\t  __state = _M_state_last;\n+\t\t  // it now corresponds to gptr().\n+\t\t  __state = _M_state_last;\n \t\t}\n \t    }\n \t  __ret = _M_seek(__computed_off, __way, __state);\n@@ -628,8 +628,8 @@ namespace std\n     basic_filebuf<_CharT, _Traits>::\n     seekpos(pos_type __pos, ios_base::openmode)\n     {\n-      pos_type __ret =  pos_type(off_type(-1)); \n-      if (this->is_open()) \n+      pos_type __ret =  pos_type(off_type(-1));\n+      if (this->is_open())\n \t{\n \t  // Ditch any pback buffers to avoid confusion.\n \t  _M_destroy_pback();\n@@ -645,9 +645,9 @@ namespace std\n     {\n       pos_type __ret = pos_type(off_type(-1));\n       if (_M_terminate_output())\n-\t{\t  \n+\t{\n \t  // Returns pos_type(off_type(-1)) in case of failure.\n-\t  __ret = pos_type(_M_file.seekoff(__off, __way));\t  \n+\t  __ret = pos_type(_M_file.seekoff(__off, __way));\n \t  _M_reading = false;\n \t  _M_writing = false;\n \t  _M_ext_next = _M_ext_end = _M_ext_buf;\n@@ -671,9 +671,9 @@ namespace std\n \t  if (traits_type::eq_int_type(__tmp, traits_type::eof()))\n \t    __testvalid = false;\n \t}\n-\t      \n+\n       // Part two: output unshift sequence.\n-      if (_M_writing && !__check_facet(_M_codecvt).always_noconv() \n+      if (_M_writing && !__check_facet(_M_codecvt).always_noconv()\n \t  && __testvalid)\n \t{\n \t  // Note: this value is arbitrary, since there is no way to\n@@ -694,7 +694,7 @@ namespace std\n \t      else if (__r == codecvt_base::ok ||\n \t\t       __r == codecvt_base::partial)\n \t\t{\n-\t\t  __ilen = __next - __buf;\t\t  \n+\t\t  __ilen = __next - __buf;\n \t\t  if (__ilen > 0)\n \t\t    {\n \t\t      const streamsize __elen = _M_file.xsputn(__buf, __ilen);\n@@ -733,7 +733,7 @@ namespace std\n \t  const int_type __tmp = this->overflow();\n \t  if (traits_type::eq_int_type(__tmp, traits_type::eof()))\n \t    __ret = -1;\n-\t}      \n+\t}\n       return __ret;\n     }\n \n@@ -745,8 +745,8 @@ namespace std\n       bool __testvalid = true;\n \n       const __codecvt_type* _M_codecvt_tmp = 0;\n-      if (__builtin_expect(has_facet<__codecvt_type>(__loc), true))\t      \n-\t_M_codecvt_tmp = &use_facet<__codecvt_type>(__loc);      \n+      if (__builtin_expect(has_facet<__codecvt_type>(__loc), true))\n+\t_M_codecvt_tmp = &use_facet<__codecvt_type>(__loc);\n \n       if (this->is_open())\n \t{\n@@ -768,7 +768,7 @@ namespace std\n \t\t  else\n \t\t    {\n \t\t      // External position corresponding to gptr().\n-\t\t      _M_ext_next = _M_ext_buf \n+\t\t      _M_ext_next = _M_ext_buf\n \t\t\t+ _M_codecvt->length(_M_state_last, _M_ext_buf, _M_ext_next,\n \t\t\t\t\t     this->gptr() - this->eback());\n \t\t      const streamsize __remainder = _M_ext_end - _M_ext_next;\n@@ -791,7 +791,7 @@ namespace std\n     }\n \n   // Inhibit implicit instantiations for required instantiations,\n-  // which are defined via explicit instantiations elsewhere.  \n+  // which are defined via explicit instantiations elsewhere.\n   // NB:  This syntax is a GNU extension.\n #if _GLIBCXX_EXTERN_TEMPLATE\n   extern template class basic_filebuf<char>;\n@@ -808,4 +808,4 @@ namespace std\n #endif\n } // namespace std\n \n-#endif \n+#endif"}, {"sha": "8b1d16c8e59a834e547809f54fb376378afcf00c", "filename": "libstdc++-v3/include/bits/functexcept.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffunctexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffunctexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffunctexcept.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -35,22 +35,22 @@\n \n namespace std\n {\n-  // Helper for exception objects in <except> \n+  // Helper for exception objects in <except>\n   void\n   __throw_bad_exception(void);\n \n-  // Helper for exception objects in <new> \n+  // Helper for exception objects in <new>\n   void\n   __throw_bad_alloc(void);\n \n-  // Helper for exception objects in <typeinfo> \n+  // Helper for exception objects in <typeinfo>\n   void\n   __throw_bad_cast(void);\n \n   void\n   __throw_bad_typeid(void);\n \n-  // Helpers for exception objects in <stdexcept> \n+  // Helpers for exception objects in <stdexcept>\n   void\n   __throw_logic_error(const char* __s);\n "}, {"sha": "ea8a9b4d4304e3e97fb4803197188169fa9666e8", "filename": "libstdc++-v3/include/bits/gslice.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fgslice.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fgslice.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fgslice.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -41,7 +41,7 @@\n #pragma GCC system_header\n \n namespace std {\n-    \n+\n   /**\n    *  @brief  Class defining multi-dimensional subset of an array.\n    *\n@@ -90,7 +90,7 @@ namespace std {\n       // XXX: See the note above.\n       ///  Assignment operator.\n       gslice& operator=(const gslice&);\n-        \n+\n       ///  Return array offset of first slice element.\n       size_t           start() const;\n \n@@ -99,7 +99,7 @@ namespace std {\n \n       ///  Return array of array strides for each dimension.\n       valarray<size_t> stride() const;\n-        \n+\n     private:\n       struct _Indexer {\n \tsize_t _M_count;\n@@ -114,22 +114,22 @@ namespace std {\n       };\n \n       _Indexer* _M_index;\n-        \n+\n       template<typename _Tp> friend class valarray;\n     };\n-    \n+\n     inline size_t\n     gslice::start () const\n     { return _M_index ? _M_index->_M_start : 0; }\n-    \n+\n     inline valarray<size_t>\n     gslice::size () const\n     { return _M_index ? _M_index->_M_size : valarray<size_t>(); }\n-    \n+\n     inline valarray<size_t>\n     gslice::stride () const\n     { return _M_index ? _M_index->_M_stride : valarray<size_t>(); }\n-    \n+\n     inline gslice::gslice () : _M_index(0) {}\n \n     inline\n@@ -140,7 +140,7 @@ namespace std {\n     inline\n     gslice::gslice(const gslice& __g) : _M_index(__g._M_index)\n     { if (_M_index) _M_index->_M_increment_use(); }\n-    \n+\n     inline\n     gslice::~gslice()\n     { if (_M_index && _M_index->_M_decrement_use() == 0) delete _M_index; }\n@@ -153,8 +153,8 @@ namespace std {\n         _M_index = __g._M_index;\n         return *this;\n     }\n-            \n-    \n+\n+\n } // std::\n \n "}, {"sha": "292eaec37de74d97f6b41495a9f5dc63a6fa8133", "filename": "libstdc++-v3/include/bits/gslice_array.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fgslice_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fgslice_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fgslice_array.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -108,13 +108,13 @@ namespace std {\n         void operator<<=(const _Expr<_Dom,_Tp>&) const;\n       template<class _Dom>\n         void operator>>=(const _Expr<_Dom,_Tp>&) const;\n-        \n+\n     private:\n       _Array<_Tp>    _M_array;\n       const valarray<size_t>& _M_index;\n-        \n+\n       friend class valarray<_Tp>;\n-      \n+\n       gslice_array(_Array<_Tp>, const valarray<size_t>&);\n \n       // this constructor needs to be implemented.\n@@ -141,13 +141,13 @@ namespace std {\n     gslice_array<_Tp>::gslice_array(const gslice_array<_Tp>& __a)\n       : _M_array(__a._M_array), _M_index(__a._M_index) {}\n \n-    \n+\n   template<typename _Tp>\n     inline void\n     gslice_array<_Tp>::operator=(const _Tp& __t) const\n-    { \n+    {\n       std::__valarray_fill(_M_array, _Array<size_t>(_M_index),\n-\t\t\t   _M_index.size(), __t); \n+\t\t\t   _M_index.size(), __t);\n     }\n \n   template<typename _Tp>\n@@ -178,18 +178,18 @@ namespace std {\n     }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   template<typename _Tp>                                                \\\n-    template<class _Dom>        \t\t\t                \\\n-      inline void \t\t\t\t\t\t\t\\\n+    template<class _Dom>\t\t\t\t                \\\n+      inline void\t\t\t\t\t\t\t\\\n       gslice_array<_Tp>::operator _Op##= (const _Expr<_Dom, _Tp>& __e) const\\\n       {\t\t\t\t\t\t\t\t\t\\\n \t_Array_augmented_##_Name(_M_array, _Array<size_t>(_M_index), __e,\\\n \t\t\t\t _M_index.size());\t\t\t\\\n       }\n \n _DEFINE_VALARRAY_OPERATOR(*, __multiplies)\n-_DEFINE_VALARRAY_OPERATOR(/, __divides)    \n+_DEFINE_VALARRAY_OPERATOR(/, __divides)\n _DEFINE_VALARRAY_OPERATOR(%, __modulus)\n-_DEFINE_VALARRAY_OPERATOR(+, __plus)    \n+_DEFINE_VALARRAY_OPERATOR(+, __plus)\n _DEFINE_VALARRAY_OPERATOR(-, __minus)\n _DEFINE_VALARRAY_OPERATOR(^, __bitwise_xor)\n _DEFINE_VALARRAY_OPERATOR(&, __bitwise_and)"}, {"sha": "7f240a94c65f84cb3da0f4f660108c87b9ed591a", "filename": "libstdc++-v3/include/bits/indirect_array.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Findirect_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Findirect_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Findirect_array.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -67,19 +67,19 @@ namespace std\n       ///  Assignment operator.  Assigns elements to corresponding elements\n       ///  of @a a.\n       indirect_array& operator=(const indirect_array&);\n-       \n+\n       ///  Assign slice elements to corresponding elements of @a v.\n       void operator=(const valarray<_Tp>&) const;\n       ///  Multiply slice elements by corresponding elements of @a v.\n       void operator*=(const valarray<_Tp>&) const;\n       ///  Divide slice elements by corresponding elements of @a v.\n       void operator/=(const valarray<_Tp>&) const;\n       ///  Modulo slice elements by corresponding elements of @a v.\n-      void operator%=(const valarray<_Tp>&) const; \n+      void operator%=(const valarray<_Tp>&) const;\n       ///  Add corresponding elements of @a v to slice elements.\n       void operator+=(const valarray<_Tp>&) const;\n       ///  Subtract corresponding elements of @a v from slice elements.\n-      void operator-=(const valarray<_Tp>&) const;  \n+      void operator-=(const valarray<_Tp>&) const;\n       ///  Logical xor slice elements with corresponding elements of @a v.\n       void operator^=(const valarray<_Tp>&) const;\n       ///  Logical and slice elements with corresponding elements of @a v.\n@@ -89,11 +89,11 @@ namespace std\n       ///  Left shift slice elements by corresponding elements of @a v.\n       void operator<<=(const valarray<_Tp>&) const;\n       ///  Right shift slice elements by corresponding elements of @a v.\n-      void operator>>=(const valarray<_Tp>&) const; \n+      void operator>>=(const valarray<_Tp>&) const;\n       ///  Assign all slice elements to @a t.\n       void operator= (const _Tp&) const;\n       //    ~indirect_array();\n-       \n+\n       template<class _Dom>\n       void operator=(const _Expr<_Dom, _Tp>&) const;\n       template<class _Dom>\n@@ -115,7 +115,7 @@ namespace std\n       template<class _Dom>\n       void operator<<=(const _Expr<_Dom, _Tp>&) const;\n       template<class _Dom>\n-      void operator>>=(const _Expr<_Dom, _Tp>&) const; \n+      void operator>>=(const _Expr<_Dom, _Tp>&) const;\n \n     private:\n       ///  Copy constructor.  Both slices refer to the same underlying array.\n@@ -124,23 +124,23 @@ namespace std\n \n       friend class valarray<_Tp>;\n       friend class gslice_array<_Tp>;\n-       \n-      const size_t \t _M_sz;\n+\n+      const size_t\t _M_sz;\n       const _Array<size_t> _M_index;\n-      const _Array<_Tp> \t _M_array;\n-       \n+      const _Array<_Tp>\t _M_array;\n+\n       // not implemented\n       indirect_array();\n     };\n \n   template<typename _Tp>\n-    inline \n+    inline\n     indirect_array<_Tp>::indirect_array(const indirect_array<_Tp>& __a)\n       : _M_sz(__a._M_sz), _M_index(__a._M_index), _M_array(__a._M_array) {}\n \n   template<typename _Tp>\n      inline\n-     indirect_array<_Tp>::indirect_array(_Array<_Tp> __a, size_t __s, \n+     indirect_array<_Tp>::indirect_array(_Array<_Tp> __a, size_t __s,\n \t\t\t\t\t _Array<size_t> __i)\n        : _M_sz(__s), _M_index(__i), _M_array(__a) {}\n "}, {"sha": "3c05be038448915b9d9de19fff8d2a26c7e42b5d", "filename": "libstdc++-v3/include/bits/ios_base.h", "status": "modified", "additions": 138, "deletions": 138, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fios_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fios_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fios_base.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -54,93 +54,93 @@ namespace std\n   // expressions involving them are no longer compile-time constants.\n   enum _Ios_Fmtflags { _S_ios_fmtflags_end = 1L << 16 };\n \n-  inline _Ios_Fmtflags \n+  inline _Ios_Fmtflags\n   operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)\n   { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }\n \n-  inline _Ios_Fmtflags \n+  inline _Ios_Fmtflags\n   operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)\n   { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }\n \n-  inline _Ios_Fmtflags \n+  inline _Ios_Fmtflags\n   operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)\n   { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }\n \n-  inline _Ios_Fmtflags \n+  inline _Ios_Fmtflags\n   operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)\n   { return __a = __a | __b; }\n \n-  inline _Ios_Fmtflags \n+  inline _Ios_Fmtflags\n   operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)\n   { return __a = __a & __b; }\n \n-  inline _Ios_Fmtflags \n+  inline _Ios_Fmtflags\n   operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)\n   { return __a = __a ^ __b; }\n \n-  inline _Ios_Fmtflags \n+  inline _Ios_Fmtflags\n   operator~(_Ios_Fmtflags __a)\n   { return _Ios_Fmtflags(~static_cast<int>(__a)); }\n \n \n   enum _Ios_Openmode { _S_ios_openmode_end = 1L << 16 };\n \n-  inline _Ios_Openmode \n+  inline _Ios_Openmode\n   operator&(_Ios_Openmode __a, _Ios_Openmode __b)\n   { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }\n \n-  inline _Ios_Openmode \n+  inline _Ios_Openmode\n   operator|(_Ios_Openmode __a, _Ios_Openmode __b)\n   { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }\n \n-  inline _Ios_Openmode \n+  inline _Ios_Openmode\n   operator^(_Ios_Openmode __a, _Ios_Openmode __b)\n   { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }\n \n-  inline _Ios_Openmode \n+  inline _Ios_Openmode\n   operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)\n   { return __a = __a | __b; }\n \n-  inline _Ios_Openmode \n+  inline _Ios_Openmode\n   operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)\n   { return __a = __a & __b; }\n \n-  inline _Ios_Openmode \n+  inline _Ios_Openmode\n   operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)\n   { return __a = __a ^ __b; }\n \n-  inline _Ios_Openmode \n+  inline _Ios_Openmode\n   operator~(_Ios_Openmode __a)\n   { return _Ios_Openmode(~static_cast<int>(__a)); }\n \n \n   enum _Ios_Iostate { _S_ios_iostate_end = 1L << 16 };\n \n-  inline _Ios_Iostate \n+  inline _Ios_Iostate\n   operator&(_Ios_Iostate __a, _Ios_Iostate __b)\n   { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }\n \n-  inline _Ios_Iostate \n+  inline _Ios_Iostate\n   operator|(_Ios_Iostate __a, _Ios_Iostate __b)\n   { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }\n \n-  inline _Ios_Iostate \n+  inline _Ios_Iostate\n   operator^(_Ios_Iostate __a, _Ios_Iostate __b)\n   { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }\n \n-  inline _Ios_Iostate \n+  inline _Ios_Iostate\n   operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)\n   { return __a = __a | __b; }\n \n-  inline _Ios_Iostate \n+  inline _Ios_Iostate\n   operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)\n   { return __a = __a & __b; }\n \n-  inline _Ios_Iostate \n+  inline _Ios_Iostate\n   operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)\n   { return __a = __a ^ __b; }\n \n-  inline _Ios_Iostate \n+  inline _Ios_Iostate\n   operator~(_Ios_Iostate __a)\n   { return _Ios_Iostate(~static_cast<int>(__a)); }\n \n@@ -158,25 +158,25 @@ namespace std\n   class ios_base\n   {\n   public:\n-    \n+\n     // 27.4.2.1.1  Class ios_base::failure\n     /// These are thrown to indicate problems.  Doc me.\n     class failure : public exception\n     {\n     public:\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 48.  Use of non-existent exception constructor\n-      explicit \n+      explicit\n       failure(const string& __str) throw();\n \n       // This declaration is not useless:\n       // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118\n-      virtual \n+      virtual\n       ~failure() throw();\n \n       virtual const char*\n       what() const throw();\n-      \n+\n     private:\n       string _M_msg;\n     };\n@@ -286,18 +286,18 @@ namespace std\n \n     /// Indicates a loss of integrity in an input or output sequence (such\n     /// as an irrecoverable read error from a file).\n-    static const iostate badbit =  \tiostate(__ios_flags::_S_badbit);\n+    static const iostate badbit =\tiostate(__ios_flags::_S_badbit);\n \n     /// Indicates that an input operation reached the end of an input sequence.\n-    static const iostate eofbit =  \tiostate(__ios_flags::_S_eofbit);\n+    static const iostate eofbit =\tiostate(__ios_flags::_S_eofbit);\n \n     /// Indicates that an input operation failed to read the expected\n     /// characters, or that an output operation failed to generate the\n     /// desired characters.\n-    static const iostate failbit = \tiostate(__ios_flags::_S_failbit);\n+    static const iostate failbit =\tiostate(__ios_flags::_S_failbit);\n \n     /// Indicates all is well.\n-    static const iostate goodbit = \tiostate(0);\n+    static const iostate goodbit =\tiostate(0);\n \n     // 27.4.2.1.4  Type ios_base::openmode\n     /**\n@@ -316,25 +316,25 @@ namespace std\n     typedef _Ios_Openmode openmode;\n \n     /// Seek to end before each write.\n-    static const openmode app =    \topenmode(__ios_flags::_S_app);\n+    static const openmode app =\t\topenmode(__ios_flags::_S_app);\n \n     /// Open and seek to end immediately after opening.\n-    static const openmode ate =    \topenmode(__ios_flags::_S_ate);\n+    static const openmode ate =\t\topenmode(__ios_flags::_S_ate);\n \n     /// Perform input and output in binary mode (as opposed to text mode).\n     /// This is probably not what you think it is; see\n     /// http://gcc.gnu.org/onlinedocs/libstdc++/27_io/howto.html#3 and\n     /// http://gcc.gnu.org/onlinedocs/libstdc++/27_io/howto.html#7 for more.\n-    static const openmode binary = \topenmode(__ios_flags::_S_bin);\n+    static const openmode binary =\topenmode(__ios_flags::_S_bin);\n \n     /// Open for input.  Default for @c ifstream and fstream.\n-    static const openmode in =     \topenmode(__ios_flags::_S_in);\n+    static const openmode in =\t\topenmode(__ios_flags::_S_in);\n \n     /// Open for output.  Default for @c ofstream and fstream.\n-    static const openmode out =    \topenmode(__ios_flags::_S_out);\n+    static const openmode out =\t\topenmode(__ios_flags::_S_out);\n \n     /// Open for input.  Default for @c ofstream.\n-    static const openmode trunc =  \topenmode(__ios_flags::_S_trunc);\n+    static const openmode trunc =\topenmode(__ios_flags::_S_trunc);\n \n     // 27.4.2.1.5  Type ios_base::seekdir\n     /**\n@@ -349,20 +349,20 @@ namespace std\n     typedef _Ios_Seekdir seekdir;\n \n     /// Request a seek relative to the beginning of the stream.\n-    static const seekdir beg = \t\tseekdir(0);\n+    static const seekdir beg =\t\tseekdir(0);\n \n     /// Request a seek relative to the current position within the sequence.\n-    static const seekdir cur = \t\tseekdir(SEEK_CUR);\n+    static const seekdir cur =\t\tseekdir(SEEK_CUR);\n \n     /// Request a seek relative to the current end of the sequence.\n-    static const seekdir end = \t\tseekdir(SEEK_END);\n+    static const seekdir end =\t\tseekdir(SEEK_END);\n \n #ifdef _GLIBCXX_DEPRECATED\n     // Annex D.6\n     typedef int io_state;\n     typedef int open_mode;\n     typedef int seek_dir;\n-    \n+\n     typedef std::streampos streampos;\n     typedef std::streamoff streamoff;\n #endif\n@@ -403,7 +403,7 @@ namespace std\n      *  function are allowed.  If there are multiple callbacks, they are\n      *  invoked in the order they were registered.\n     */\n-    void \n+    void\n     register_callback(event_callback __fn, int __index);\n \n   protected:\n@@ -413,85 +413,85 @@ namespace std\n      *  ios_base data members (doc me)\n      *  @endif\n     */\n-    streamsize \t\t_M_precision;\n-    streamsize \t\t_M_width;\n-    fmtflags \t\t_M_flags;\n-    iostate \t\t_M_exception;\n-    iostate \t       \t_M_streambuf_state;\n+    streamsize\t\t_M_precision;\n+    streamsize\t\t_M_width;\n+    fmtflags\t\t_M_flags;\n+    iostate\t\t_M_exception;\n+    iostate\t\t_M_streambuf_state;\n     //@}\n \n     // 27.4.2.6  Members for callbacks\n     // 27.4.2.6  ios_base callbacks\n     struct _Callback_list\n     {\n       // Data Members\n-      _Callback_list* \t\t_M_next;\n-      ios_base::event_callback \t_M_fn;\n-      int \t\t\t_M_index;\n+      _Callback_list*\t\t_M_next;\n+      ios_base::event_callback\t_M_fn;\n+      int\t\t\t_M_index;\n       _Atomic_word\t\t_M_refcount;  // 0 means one reference.\n-    \n-      _Callback_list(ios_base::event_callback __fn, int __index, \n+\n+      _Callback_list(ios_base::event_callback __fn, int __index,\n \t\t     _Callback_list* __cb)\n       : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }\n-      \n-      void \n+\n+      void\n       _M_add_reference() { __atomic_add(&_M_refcount, 1); }\n \n       // 0 => OK to delete.\n-      int \n+      int\n       _M_remove_reference() { return __exchange_and_add(&_M_refcount, -1); }\n     };\n \n-     _Callback_list*  \t_M_callbacks;\n+     _Callback_list*\t_M_callbacks;\n \n-    void \n+    void\n     _M_call_callbacks(event __ev) throw();\n \n-    void \n+    void\n     _M_dispose_callbacks(void);\n \n     // 27.4.2.5  Members for iword/pword storage\n-    struct _Words \n-    { \n-      void* \t_M_pword; \n-      long \t_M_iword; \n+    struct _Words\n+    {\n+      void*\t_M_pword;\n+      long\t_M_iword;\n       _Words() : _M_pword(0), _M_iword(0) { }\n     };\n \n     // Only for failed iword/pword calls.\n-    _Words  \t\t_M_word_zero;    \n+    _Words\t\t_M_word_zero;\n \n     // Guaranteed storage.\n     // The first 5 iword and pword slots are reserved for internal use.\n-    static const int \t_S_local_word_size = 8;\n-    _Words  \t\t_M_local_word[_S_local_word_size];  \n+    static const int\t_S_local_word_size = 8;\n+    _Words\t\t_M_local_word[_S_local_word_size];\n \n     // Allocated storage.\n-    int     \t\t_M_word_size;\n-    _Words* \t\t_M_word;\n- \n-    _Words& \n+    int\t\t\t_M_word_size;\n+    _Words*\t\t_M_word;\n+\n+    _Words&\n     _M_grow_words(int __index, bool __iword);\n \n     // Members for locale and locale caching.\n-    locale \t\t_M_ios_locale;\n+    locale\t\t_M_ios_locale;\n \n-    void \n+    void\n     _M_init();\n \n   public:\n \n     // 27.4.2.1.6  Class ios_base::Init\n     // Used to initialize standard streams. In theory, g++ could use\n     // -finit-priority to order this stuff correctly without going\n-    // through these machinations. \n-    class Init \n+    // through these machinations.\n+    class Init\n     {\n       friend class ios_base;\n     public:\n       Init();\n       ~Init();\n-      \n+\n     private:\n       static _Atomic_word\t_S_refcount;\n       static bool\t\t_S_synced_with_stdio;\n@@ -502,7 +502,7 @@ namespace std\n      *  @brief  Access to format flags.\n      *  @return  The format control flags for both input and output.\n     */\n-    inline fmtflags \n+    inline fmtflags\n     flags() const { return _M_flags; }\n \n     /**\n@@ -512,12 +512,12 @@ namespace std\n      *\n      *  This function overwrites all the format flags with @a fmtfl.\n     */\n-    inline fmtflags \n+    inline fmtflags\n     flags(fmtflags __fmtfl)\n-    { \n-      fmtflags __old = _M_flags; \n-      _M_flags = __fmtfl; \n-      return __old; \n+    {\n+      fmtflags __old = _M_flags;\n+      _M_flags = __fmtfl;\n+      return __old;\n     }\n \n     /**\n@@ -528,12 +528,12 @@ namespace std\n      *  This function sets additional flags in format control.  Flags that\n      *  were previously set remain set.\n     */\n-    inline fmtflags \n+    inline fmtflags\n     setf(fmtflags __fmtfl)\n-    { \n-      fmtflags __old = _M_flags; \n-      _M_flags |= __fmtfl; \n-      return __old; \n+    {\n+      fmtflags __old = _M_flags;\n+      _M_flags |= __fmtfl;\n+      return __old;\n     }\n \n     /**\n@@ -545,7 +545,7 @@ namespace std\n      *  This function clears @a mask in the format flags, then sets\n      *  @a fmtfl @c & @a mask.  An example mask is @c ios_base::adjustfield.\n     */\n-    inline fmtflags \n+    inline fmtflags\n     setf(fmtflags __fmtfl, fmtflags __mask)\n     {\n       fmtflags __old = _M_flags;\n@@ -560,7 +560,7 @@ namespace std\n      *\n      *  This function clears @a mask in the format flags.\n     */\n-    inline void \n+    inline void\n     unsetf(fmtflags __mask) { _M_flags &= ~__mask; }\n \n     /**\n@@ -572,20 +572,20 @@ namespace std\n      *  DR 189.\n      *  @endif\n     */\n-    inline streamsize \n+    inline streamsize\n     precision() const { return _M_precision; }\n \n     /**\n      *  @brief  Changing flags.\n      *  @param  prec  The new precision value.\n      *  @return  The previous value of precision().\n     */\n-    inline streamsize \n+    inline streamsize\n     precision(streamsize __prec)\n-    { \n-      streamsize __old = _M_precision; \n-      _M_precision = __prec; \n-      return __old; \n+    {\n+      streamsize __old = _M_precision;\n+      _M_precision = __prec;\n+      return __old;\n     }\n \n     /**\n@@ -594,20 +594,20 @@ namespace std\n      *\n      *  \"Minimum field width\" refers to the number of characters.\n     */\n-    inline streamsize \n+    inline streamsize\n     width() const { return _M_width; }\n \n     /**\n      *  @brief  Changing flags.\n      *  @param  wide  The new width value.\n      *  @return  The previous value of width().\n     */\n-    inline streamsize \n+    inline streamsize\n     width(streamsize __wide)\n-    { \n-      streamsize __old = _M_width; \n-      _M_width = __wide; \n-      return __old; \n+    {\n+      streamsize __old = _M_width;\n+      _M_width = __wide;\n+      return __old;\n     }\n \n     // [27.4.2.4] ios_base static members\n@@ -621,7 +621,7 @@ namespace std\n      *  cout).  User-declared streams are unaffected.  See\n      *  http://gcc.gnu.org/onlinedocs/libstdc++/27_io/howto.html#8 for more.\n     */\n-    static bool \n+    static bool\n     sync_with_stdio(bool __sync = true);\n \n     // [27.4.2.3] ios_base locale functions\n@@ -633,7 +633,7 @@ namespace std\n      *  Sets the new locale for this stream, and then invokes each callback\n      *  with imbue_event.\n     */\n-    locale \n+    locale\n     imbue(const locale& __loc);\n \n     /**\n@@ -644,7 +644,7 @@ namespace std\n      *  returns @c loc.  Otherwise, it returns a copy of @c std::locale(),\n      *  the global C++ locale.\n     */\n-    inline locale \n+    inline locale\n     getloc() const { return _M_ios_locale; }\n \n     /**\n@@ -654,7 +654,7 @@ namespace std\n      *  Like getloc above, but returns a reference instead of\n      *  generating a copy.\n     */\n-    inline const locale& \n+    inline const locale&\n     _M_getloc() const { return _M_ios_locale; }\n \n     // [27.4.2.5] ios_base storage functions\n@@ -672,7 +672,7 @@ namespace std\n      *  returned on each invocation.  xalloc is guaranteed to return an index\n      *  that is safe to use in the iword and pword arrays.\n     */\n-    static int \n+    static int\n     xalloc() throw();\n \n     /**\n@@ -688,10 +688,10 @@ namespace std\n      *  obtain an index that is safe to use.  Also note that since the array\n      *  can grow dynamically, it is not safe to hold onto the reference.\n     */\n-    inline long& \n+    inline long&\n     iword(int __ix)\n     {\n-      _Words& __word = (__ix < _M_word_size) \n+      _Words& __word = (__ix < _M_word_size)\n \t\t\t? _M_word[__ix] : _M_grow_words(__ix, true);\n       return __word._M_iword;\n     }\n@@ -709,10 +709,10 @@ namespace std\n      *  obtain an index that is safe to use.  Also note that since the array\n      *  can grow dynamically, it is not safe to hold onto the reference.\n     */\n-    inline void*& \n+    inline void*&\n     pword(int __ix)\n     {\n-      _Words& __word = (__ix < _M_word_size) \n+      _Words& __word = (__ix < _M_word_size)\n \t\t\t? _M_word[__ix] : _M_grow_words(__ix, false);\n       return __word._M_pword;\n     }\n@@ -736,184 +736,184 @@ namespace std\n   private:\n     ios_base(const ios_base&);\n \n-    ios_base& \n+    ios_base&\n     operator=(const ios_base&);\n   };\n- \n+\n   // [27.4.5.1] fmtflags manipulators\n   /// Calls base.setf(ios_base::boolalpha).\n-  inline ios_base& \n+  inline ios_base&\n   boolalpha(ios_base& __base)\n   {\n     __base.setf(ios_base::boolalpha);\n     return __base;\n   }\n \n   /// Calls base.unsetf(ios_base::boolalpha).\n-  inline ios_base& \n+  inline ios_base&\n   noboolalpha(ios_base& __base)\n   {\n     __base.unsetf(ios_base::boolalpha);\n     return __base;\n   }\n \n   /// Calls base.setf(ios_base::showbase).\n-  inline ios_base& \n+  inline ios_base&\n   showbase(ios_base& __base)\n   {\n     __base.setf(ios_base::showbase);\n     return __base;\n   }\n \n   /// Calls base.unsetf(ios_base::showbase).\n-  inline ios_base& \n+  inline ios_base&\n   noshowbase(ios_base& __base)\n   {\n     __base.unsetf(ios_base::showbase);\n     return __base;\n   }\n \n   /// Calls base.setf(ios_base::showpoint).\n-  inline ios_base& \n+  inline ios_base&\n   showpoint(ios_base& __base)\n   {\n     __base.setf(ios_base::showpoint);\n     return __base;\n   }\n \n   /// Calls base.unsetf(ios_base::showpoint).\n-  inline ios_base& \n+  inline ios_base&\n   noshowpoint(ios_base& __base)\n   {\n     __base.unsetf(ios_base::showpoint);\n     return __base;\n   }\n \n   /// Calls base.setf(ios_base::showpos).\n-  inline ios_base& \n+  inline ios_base&\n   showpos(ios_base& __base)\n   {\n     __base.setf(ios_base::showpos);\n     return __base;\n   }\n \n   /// Calls base.unsetf(ios_base::showpos).\n-  inline ios_base& \n+  inline ios_base&\n   noshowpos(ios_base& __base)\n   {\n     __base.unsetf(ios_base::showpos);\n     return __base;\n   }\n \n   /// Calls base.setf(ios_base::skipws).\n-  inline ios_base& \n+  inline ios_base&\n   skipws(ios_base& __base)\n   {\n     __base.setf(ios_base::skipws);\n     return __base;\n   }\n-  \n+\n   /// Calls base.unsetf(ios_base::skipws).\n-  inline ios_base& \n+  inline ios_base&\n   noskipws(ios_base& __base)\n   {\n     __base.unsetf(ios_base::skipws);\n     return __base;\n   }\n \n   /// Calls base.setf(ios_base::uppercase).\n-  inline ios_base& \n+  inline ios_base&\n   uppercase(ios_base& __base)\n   {\n     __base.setf(ios_base::uppercase);\n     return __base;\n   }\n \n   /// Calls base.unsetf(ios_base::uppercase).\n-  inline ios_base& \n+  inline ios_base&\n   nouppercase(ios_base& __base)\n   {\n     __base.unsetf(ios_base::uppercase);\n     return __base;\n   }\n \n   /// Calls base.setf(ios_base::unitbuf).\n-  inline ios_base& \n+  inline ios_base&\n   unitbuf(ios_base& __base)\n   {\n-     __base.setf(ios_base::unitbuf);      \n+     __base.setf(ios_base::unitbuf);\n      return __base;\n   }\n \n   /// Calls base.unsetf(ios_base::unitbuf).\n-  inline ios_base& \n+  inline ios_base&\n   nounitbuf(ios_base& __base)\n   {\n      __base.unsetf(ios_base::unitbuf);\n-     return __base;    \n+     return __base;\n   }\n \n   // [27.4.5.2] adjustfield anipulators\n   /// Calls base.setf(ios_base::internal, ios_base::adjustfield).\n-  inline ios_base& \n+  inline ios_base&\n   internal(ios_base& __base)\n   {\n      __base.setf(ios_base::internal, ios_base::adjustfield);\n-     return __base;    \n+     return __base;\n   }\n \n   /// Calls base.setf(ios_base::left, ios_base::adjustfield).\n-  inline ios_base& \n+  inline ios_base&\n   left(ios_base& __base)\n   {\n     __base.setf(ios_base::left, ios_base::adjustfield);\n     return __base;\n   }\n-  \n+\n   /// Calls base.setf(ios_base::right, ios_base::adjustfield).\n-  inline ios_base& \n+  inline ios_base&\n   right(ios_base& __base)\n   {\n     __base.setf(ios_base::right, ios_base::adjustfield);\n     return __base;\n   }\n-  \n+\n   // [27.4.5.3] basefield anipulators\n   /// Calls base.setf(ios_base::dec, ios_base::basefield).\n-  inline ios_base& \n+  inline ios_base&\n   dec(ios_base& __base)\n   {\n     __base.setf(ios_base::dec, ios_base::basefield);\n     return __base;\n   }\n-  \n+\n   /// Calls base.setf(ios_base::hex, ios_base::basefield).\n-  inline ios_base& \n+  inline ios_base&\n   hex(ios_base& __base)\n   {\n     __base.setf(ios_base::hex, ios_base::basefield);\n     return __base;\n   }\n \n   /// Calls base.setf(ios_base::oct, ios_base::basefield).\n-  inline ios_base& \n+  inline ios_base&\n   oct(ios_base& __base)\n   {\n     __base.setf(ios_base::oct, ios_base::basefield);\n     return __base;\n   }\n-  \n+\n   // [27.4.5.4] floatfield anipulators\n   /// Calls base.setf(ios_base::fixed, ios_base::floatfield).\n-  inline ios_base& \n+  inline ios_base&\n   fixed(ios_base& __base)\n   {\n     __base.setf(ios_base::fixed, ios_base::floatfield);\n     return __base;\n   }\n \n   /// Calls base.setf(ios_base::scientific, ios_base::floatfield).\n-  inline ios_base& \n+  inline ios_base&\n   scientific(ios_base& __base)\n   {\n     __base.setf(ios_base::scientific, ios_base::floatfield);"}, {"sha": "3edb8cdeea181365e1c651f2540fd6a2f1b633f7", "filename": "libstdc++-v3/include/bits/istream.tcc", "status": "modified", "additions": 133, "deletions": 133, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -40,26 +40,26 @@\n #include <locale>\n #include <ostream> // For flush()\n \n-namespace std \n+namespace std\n {\n   template<typename _CharT, typename _Traits>\n     basic_istream<_CharT, _Traits>::sentry::\n     sentry(basic_istream<_CharT, _Traits>& __in, bool __noskipws)\n     {\n       ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-      if (__in.good()) \n+      if (__in.good())\n \t{\n \t  if (__in.tie())\n \t    __in.tie()->flush();\n \t  if (!__noskipws && (__in.flags() & ios_base::skipws))\n-\t    {\t  \n+\t    {\n \t      const __int_type __eof = traits_type::eof();\n \t      __streambuf_type* __sb = __in.rdbuf();\n \t      __int_type __c = __sb->sgetc();\n \n \t      const __ctype_type& __ct = __check_facet(__in._M_ctype);\n \t      while (!traits_type::eq_int_type(__c, __eof)\n-\t\t     && __ct.is(ctype_base::space, \n+\t\t     && __ct.is(ctype_base::space,\n \t\t\t\ttraits_type::to_char_type(__c)))\n \t\t__c = __sb->snextc();\n \n@@ -82,39 +82,39 @@ namespace std\n     }\n \n   template<typename _CharT, typename _Traits>\n-    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>&\n     basic_istream<_CharT, _Traits>::\n     operator>>(__istream_type& (*__pf)(__istream_type&))\n     { return __pf(*this); }\n \n   template<typename _CharT, typename _Traits>\n-    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>&\n     basic_istream<_CharT, _Traits>::\n     operator>>(__ios_type& (*__pf)(__ios_type&))\n     {\n       __pf(*this);\n       return *this;\n     }\n-  \n+\n   template<typename _CharT, typename _Traits>\n-    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>&\n     basic_istream<_CharT, _Traits>::\n     operator>>(ios_base& (*__pf)(ios_base&))\n     {\n       __pf(*this);\n       return *this;\n     }\n-  \n+\n   template<typename _CharT, typename _Traits>\n-    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>&\n     basic_istream<_CharT, _Traits>::\n     operator>>(bool& __n)\n     {\n       sentry __cerb(*this, false);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n \t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t  try \n+\t  try\n \t    {\n \t      const __num_get_type& __ng = __check_facet(this->_M_num_get);\n \t      __ng.get(*this, 0, *this, __err, __n);\n@@ -128,23 +128,23 @@ namespace std\n     }\n \n   template<typename _CharT, typename _Traits>\n-    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>&\n     basic_istream<_CharT, _Traits>::\n     operator>>(short& __n)\n     {\n       sentry __cerb(*this, false);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n \t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t  try \n+\t  try\n \t    {\n \t      long __l;\n \t      const __num_get_type& __ng = __check_facet(this->_M_num_get);\n \t      __ng.get(*this, 0, *this, __err, __l);\n \t      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t      // 118. basic_istream uses nonexistent num_get member functions.\n \t      if (!(__err & ios_base::failbit)\n-\t\t  && (numeric_limits<short>::min() <= __l \n+\t\t  && (numeric_limits<short>::min() <= __l\n \t\t      && __l <= numeric_limits<short>::max()))\n \t\t__n = __l;\n \t      else\n@@ -159,15 +159,15 @@ namespace std\n     }\n \n   template<typename _CharT, typename _Traits>\n-    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>&\n     basic_istream<_CharT, _Traits>::\n     operator>>(unsigned short& __n)\n     {\n       sentry __cerb(*this, false);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n \t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t  try \n+\t  try\n \t    {\n \t      const __num_get_type& __ng = __check_facet(this->_M_num_get);\n \t      __ng.get(*this, 0, *this, __err, __n);\n@@ -181,23 +181,23 @@ namespace std\n     }\n \n   template<typename _CharT, typename _Traits>\n-    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>&\n     basic_istream<_CharT, _Traits>::\n     operator>>(int& __n)\n     {\n       sentry __cerb(*this, false);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n \t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t  try \n+\t  try\n \t    {\n \t      long __l;\n \t      const __num_get_type& __ng = __check_facet(this->_M_num_get);\n \t      __ng.get(*this, 0, *this, __err, __l);\n \t      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t      // 118. basic_istream uses nonexistent num_get member functions.\n \t      if (!(__err & ios_base::failbit)\n-\t\t  && (numeric_limits<int>::min() <= __l \n+\t\t  && (numeric_limits<int>::min() <= __l\n \t\t      && __l <= numeric_limits<int>::max()))\n \t\t__n = __l;\n \t      else\n@@ -212,15 +212,15 @@ namespace std\n     }\n \n   template<typename _CharT, typename _Traits>\n-    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>&\n     basic_istream<_CharT, _Traits>::\n     operator>>(unsigned int& __n)\n     {\n       sentry __cerb(*this, false);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n \t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t  try \n+\t  try\n \t    {\n \t      const __num_get_type& __ng = __check_facet(this->_M_num_get);\n \t      __ng.get(*this, 0, *this, __err, __n);\n@@ -234,15 +234,15 @@ namespace std\n     }\n \n   template<typename _CharT, typename _Traits>\n-    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>&\n     basic_istream<_CharT, _Traits>::\n     operator>>(long& __n)\n     {\n       sentry __cerb(*this, false);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n \t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t  try \n+\t  try\n \t    {\n \t      const __num_get_type& __ng = __check_facet(this->_M_num_get);\n \t      __ng.get(*this, 0, *this, __err, __n);\n@@ -256,15 +256,15 @@ namespace std\n     }\n \n   template<typename _CharT, typename _Traits>\n-    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>&\n     basic_istream<_CharT, _Traits>::\n     operator>>(unsigned long& __n)\n     {\n       sentry __cerb(*this, false);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n \t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t  try \n+\t  try\n \t    {\n \t      const __num_get_type& __ng = __check_facet(this->_M_num_get);\n \t      __ng.get(*this, 0, *this, __err, __n);\n@@ -279,15 +279,15 @@ namespace std\n \n #ifdef _GLIBCXX_USE_LONG_LONG\n   template<typename _CharT, typename _Traits>\n-    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>&\n     basic_istream<_CharT, _Traits>::\n     operator>>(long long& __n)\n     {\n       sentry __cerb(*this, false);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n \t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t  try \n+\t  try\n \t    {\n \t      const __num_get_type& __ng = __check_facet(this->_M_num_get);\n \t      __ng.get(*this, 0, *this, __err, __n);\n@@ -301,15 +301,15 @@ namespace std\n     }\n \n   template<typename _CharT, typename _Traits>\n-    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>&\n     basic_istream<_CharT, _Traits>::\n     operator>>(unsigned long long& __n)\n     {\n       sentry __cerb(*this, false);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n \t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t  try \n+\t  try\n \t    {\n \t      const __num_get_type& __ng = __check_facet(this->_M_num_get);\n \t      __ng.get(*this, 0, *this, __err, __n);\n@@ -324,15 +324,15 @@ namespace std\n #endif\n \n   template<typename _CharT, typename _Traits>\n-    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>&\n     basic_istream<_CharT, _Traits>::\n     operator>>(float& __n)\n     {\n       sentry __cerb(*this, false);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n \t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t  try \n+\t  try\n \t    {\n \t      const __num_get_type& __ng = __check_facet(this->_M_num_get);\n \t      __ng.get(*this, 0, *this, __err, __n);\n@@ -346,15 +346,15 @@ namespace std\n     }\n \n   template<typename _CharT, typename _Traits>\n-    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>&\n     basic_istream<_CharT, _Traits>::\n     operator>>(double& __n)\n     {\n       sentry __cerb(*this, false);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n \t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t  try \n+\t  try\n \t    {\n \t      const __num_get_type& __ng = __check_facet(this->_M_num_get);\n \t      __ng.get(*this, 0, *this, __err, __n);\n@@ -368,15 +368,15 @@ namespace std\n     }\n \n   template<typename _CharT, typename _Traits>\n-    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>&\n     basic_istream<_CharT, _Traits>::\n     operator>>(long double& __n)\n     {\n       sentry __cerb(*this, false);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n \t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t  try \n+\t  try\n \t    {\n \t      const __num_get_type& __ng = __check_facet(this->_M_num_get);\n \t      __ng.get(*this, 0, *this, __err, __n);\n@@ -390,15 +390,15 @@ namespace std\n     }\n \n   template<typename _CharT, typename _Traits>\n-    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>&\n     basic_istream<_CharT, _Traits>::\n     operator>>(void*& __n)\n     {\n       sentry __cerb(*this, false);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n \t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t  try \n+\t  try\n \t    {\n \t      const __num_get_type& __ng = __check_facet(this->_M_num_get);\n \t      __ng.get(*this, 0, *this, __err, __n);\n@@ -412,7 +412,7 @@ namespace std\n     }\n \n   template<typename _CharT, typename _Traits>\n-    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>&\n     basic_istream<_CharT, _Traits>::\n     operator>>(__streambuf_type* __sbout)\n     {\n@@ -445,9 +445,9 @@ namespace std\n       _M_gcount = 0;\n       ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n       sentry __cerb(*this, true);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n-\t  try \n+\t  try\n \t    {\n \t      __c = this->rdbuf()->sbumpc();\n \t      // 27.6.1.1 paragraph 3\n@@ -474,9 +474,9 @@ namespace std\n       _M_gcount = 0;\n       ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n       sentry __cerb(*this, true);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n- \t  try \n+\t  try\n \t    {\n \t      int_type __cb = this->rdbuf()->sbumpc();\n \t      // 27.6.1.1 paragraph 3\n@@ -506,16 +506,16 @@ namespace std\n       _M_gcount = 0;\n       ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n       sentry __cerb(*this, true);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n-\t  try \n+\t  try\n \t    {\n \t      const int_type __idelim = traits_type::to_int_type(__delim);\n \t      const int_type __eof = traits_type::eof();\n \t      __streambuf_type* __sb = this->rdbuf();\n-\t      int_type __c = __sb->sgetc();\t\n-\t      \n-\t      while (_M_gcount + 1 < __n \n+\t      int_type __c = __sb->sgetc();\n+\n+\t      while (_M_gcount + 1 < __n\n \t\t     && !traits_type::eq_int_type(__c, __eof)\n \t\t     && !traits_type::eq_int_type(__c, __idelim))\n \t\t{\n@@ -545,18 +545,18 @@ namespace std\n       _M_gcount = 0;\n       ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n       sentry __cerb(*this, true);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n-\t  try \n+\t  try\n \t    {\n \t      const int_type __idelim = traits_type::to_int_type(__delim);\n-\t      const int_type __eof = traits_type::eof();\t      \n+\t      const int_type __eof = traits_type::eof();\n \t      __streambuf_type* __this_sb = this->rdbuf();\n \t      int_type __c = __this_sb->sgetc();\n \t      char_type __c2 = traits_type::to_char_type(__c);\n-\t      \n-\t      while (!traits_type::eq_int_type(__c, __eof) \n-\t\t     && !traits_type::eq_int_type(__c, __idelim) \n+\n+\t      while (!traits_type::eq_int_type(__c, __eof)\n+\t\t     && !traits_type::eq_int_type(__c, __idelim)\n \t\t     && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))\n \t\t{\n \t\t  ++_M_gcount;\n@@ -584,16 +584,16 @@ namespace std\n       _M_gcount = 0;\n       ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n       sentry __cerb(*this, true);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n-          try \n+          try\n \t    {\n \t      const int_type __idelim = traits_type::to_int_type(__delim);\n \t      const int_type __eof = traits_type::eof();\n \t      __streambuf_type* __sb = this->rdbuf();\n \t      int_type __c = __sb->sgetc();\n-\t    \n-\t      while (_M_gcount + 1 < __n \n+\n+\t      while (_M_gcount + 1 < __n\n \t\t     && !traits_type::eq_int_type(__c, __eof)\n \t\t     && !traits_type::eq_int_type(__c, __idelim))\n \t\t{\n@@ -624,25 +624,25 @@ namespace std\n \tthis->setstate(__err);\n       return *this;\n     }\n-  \n+\n   template<typename _CharT, typename _Traits>\n     basic_istream<_CharT, _Traits>&\n     basic_istream<_CharT, _Traits>::\n     ignore(streamsize __n, int_type __delim)\n     {\n       _M_gcount = 0;\n       sentry __cerb(*this, true);\n-      if (__cerb && __n > 0) \n+      if (__cerb && __n > 0)\n \t{\n \t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t  try \n+\t  try\n \t    {\n \t      const int_type __eof = traits_type::eof();\n \t      __streambuf_type* __sb = this->rdbuf();\n \t      int_type __c;\n-\t      \n+\n \t      __n = std::min(__n, numeric_limits<streamsize>::max());\n-\t      while (_M_gcount < __n  \n+\t      while (_M_gcount < __n\n \t\t     && !traits_type::eq_int_type(__c = __sb->sbumpc(), __eof))\n \t\t{\n \t\t  ++_M_gcount;\n@@ -659,7 +659,7 @@ namespace std\n \t}\n       return *this;\n     }\n-  \n+\n   template<typename _CharT, typename _Traits>\n     typename basic_istream<_CharT, _Traits>::int_type\n     basic_istream<_CharT, _Traits>::\n@@ -671,7 +671,7 @@ namespace std\n       if (__cerb)\n \t{\n \t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t  try \n+\t  try\n \t    {\n \t      __c = this->rdbuf()->sgetc();\n \t      if (traits_type::eq_int_type(__c, traits_type::eof()))\n@@ -681,7 +681,7 @@ namespace std\n \t    { this->_M_setstate(ios_base::badbit); }\n \t  if (__err)\n \t    this->setstate(__err);\n-\t} \n+\t}\n       return __c;\n     }\n \n@@ -692,34 +692,34 @@ namespace std\n     {\n       _M_gcount = 0;\n       sentry __cerb(*this, true);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n \t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t  try \n+\t  try\n \t    {\n \t      _M_gcount = this->rdbuf()->sgetn(__s, __n);\n \t      if (_M_gcount != __n)\n \t\t__err |= (ios_base::eofbit | ios_base::failbit);\n-\t    }\t    \n+\t    }\n \t  catch(...)\n \t    { this->_M_setstate(ios_base::badbit); }\n \t  if (__err)\n \t    this->setstate(__err);\n \t}\n       return *this;\n     }\n-  \n+\n   template<typename _CharT, typename _Traits>\n-    streamsize \n+    streamsize\n     basic_istream<_CharT, _Traits>::\n     readsome(char_type* __s, streamsize __n)\n     {\n       _M_gcount = 0;\n       sentry __cerb(*this, true);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n \t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t  try \n+\t  try\n \t    {\n \t      // Cannot compare int_type with streamsize generically.\n \t      streamsize __num = this->rdbuf()->in_avail();\n@@ -739,7 +739,7 @@ namespace std\n \t}\n       return _M_gcount;\n     }\n-      \n+\n   template<typename _CharT, typename _Traits>\n     basic_istream<_CharT, _Traits>&\n     basic_istream<_CharT, _Traits>::\n@@ -749,14 +749,14 @@ namespace std\n       // 60. What is a formatted input function?\n       _M_gcount = 0;\n       sentry __cerb(*this, true);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n \t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t  try \n+\t  try\n \t    {\n \t      const int_type __eof = traits_type::eof();\n \t      __streambuf_type* __sb = this->rdbuf();\n-\t      if (!__sb \n+\t      if (!__sb\n \t\t  || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))\n \t\t__err |= ios_base::badbit;\n \t    }\n@@ -767,7 +767,7 @@ namespace std\n \t}\n       return *this;\n     }\n-  \n+\n   template<typename _CharT, typename _Traits>\n     basic_istream<_CharT, _Traits>&\n     basic_istream<_CharT, _Traits>::\n@@ -777,14 +777,14 @@ namespace std\n       // 60. What is a formatted input function?\n       _M_gcount = 0;\n       sentry __cerb(*this, true);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n \t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t  try \n+\t  try\n \t    {\n \t      const int_type __eof = traits_type::eof();\n \t      __streambuf_type* __sb = this->rdbuf();\n-\t      if (!__sb \n+\t      if (!__sb\n \t\t  || traits_type::eq_int_type(__sb->sungetc(), __eof))\n \t\t__err |= ios_base::badbit;\n \t    }\n@@ -795,7 +795,7 @@ namespace std\n \t}\n       return *this;\n     }\n-  \n+\n   template<typename _CharT, typename _Traits>\n     int\n     basic_istream<_CharT, _Traits>::\n@@ -805,17 +805,17 @@ namespace std\n       // DR60.  Do not change _M_gcount.\n       int __ret = -1;\n       sentry __cerb(*this, true);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n \t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t  try \n+\t  try\n \t    {\n \t      __streambuf_type* __sb = this->rdbuf();\n \t      if (__sb)\n \t\t{\n \t\t  if (__sb->pubsync() == -1)\n \t\t    __err |= ios_base::badbit;\n-\t\t  else \n+\t\t  else\n \t\t    __ret = 0;\n \t\t}\n \t    }\n@@ -826,7 +826,7 @@ namespace std\n \t}\n       return __ret;\n     }\n-  \n+\n   template<typename _CharT, typename _Traits>\n     typename basic_istream<_CharT, _Traits>::pos_type\n     basic_istream<_CharT, _Traits>::\n@@ -885,9 +885,9 @@ namespace std\n \t  if (!this->fail())\n \t    {\n \t      // 136.  seekp, seekg setting wrong streams?\n-\t      pos_type __p = this->rdbuf()->pubseekoff(__off, __dir, \n+\t      pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,\n \t\t\t\t\t\t       ios_base::in);\n-\t      \n+\n \t      // 129. Need error indication from seekp() and seekg()\n \t      if (__p == pos_type(off_type(-1)))\n \t\t__err |= ios_base::failbit;\n@@ -905,12 +905,12 @@ namespace std\n     basic_istream<_CharT, _Traits>&\n     operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)\n     {\n-      typedef basic_istream<_CharT, _Traits> \t\t__istream_type;\n+      typedef basic_istream<_CharT, _Traits>\t\t__istream_type;\n       typename __istream_type::sentry __cerb(__in, false);\n       if (__cerb)\n \t{\n \t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t  try \n+\t  try\n \t    {\n \t      typename __istream_type::int_type __cb = __in.rdbuf()->sbumpc();\n \t      if (!_Traits::eq_int_type(__cb, _Traits::eof()))\n@@ -930,33 +930,33 @@ namespace std\n     basic_istream<_CharT, _Traits>&\n     operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)\n     {\n-      typedef basic_istream<_CharT, _Traits> \t\t__istream_type;\n+      typedef basic_istream<_CharT, _Traits>\t\t__istream_type;\n       typedef typename __istream_type::__streambuf_type __streambuf_type;\n-      typedef typename _Traits::int_type \t\tint_type;\n-      typedef _CharT                     \t\tchar_type;\n-      typedef ctype<_CharT>     \t\t\t__ctype_type;\n+      typedef typename _Traits::int_type\t\tint_type;\n+      typedef _CharT\t\t\t\t\tchar_type;\n+      typedef ctype<_CharT>\t\t\t\t__ctype_type;\n \n       streamsize __extracted = 0;\n       ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n       typename __istream_type::sentry __cerb(__in, false);\n       if (__cerb)\n \t{\n-\t  try \n+\t  try\n \t    {\n \t      // Figure out how many characters to extract.\n \t      streamsize __num = __in.width();\n \t      if (__num <= 0)\n \t\t__num = numeric_limits<streamsize>::max();\n-\t      \n+\n \t      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());\n \n \t      const int_type __eof = _Traits::eof();\n \t      __streambuf_type* __sb = __in.rdbuf();\n \t      int_type __c = __sb->sgetc();\n-\t      \n-\t      while (__extracted < __num - 1 \n+\n+\t      while (__extracted < __num - 1\n \t\t     && !_Traits::eq_int_type(__c, __eof)\n-\t\t     && !__ct.is(ctype_base::space, \n+\t\t     && !__ct.is(ctype_base::space,\n \t\t\t\t _Traits::to_char_type(__c)))\n \t\t{\n \t\t  *__s++ = _Traits::to_char_type(__c);\n@@ -983,20 +983,20 @@ namespace std\n \n   // 27.6.1.4 Standard basic_istream manipulators\n   template<typename _CharT, typename _Traits>\n-    basic_istream<_CharT,_Traits>& \n+    basic_istream<_CharT,_Traits>&\n     ws(basic_istream<_CharT,_Traits>& __in)\n     {\n-      typedef basic_istream<_CharT, _Traits> \t\t__istream_type;\n+      typedef basic_istream<_CharT, _Traits>\t\t__istream_type;\n       typedef typename __istream_type::__streambuf_type __streambuf_type;\n-      typedef typename __istream_type::__ctype_type \t__ctype_type;\n-      typedef typename __istream_type::int_type \t__int_type;\n+      typedef typename __istream_type::__ctype_type\t__ctype_type;\n+      typedef typename __istream_type::int_type\t\t__int_type;\n \n       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());\n-      const __int_type __eof = _Traits::eof();\t      \n+      const __int_type __eof = _Traits::eof();\n       __streambuf_type* __sb = __in.rdbuf();\n       __int_type __c = __sb->sgetc();\n \n-      while (!_Traits::eq_int_type(__c, __eof) \n+      while (!_Traits::eq_int_type(__c, __eof)\n \t     && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))\n \t__c = __sb->snextc();\n \n@@ -1011,31 +1011,31 @@ namespace std\n     operator>>(basic_istream<_CharT, _Traits>& __in,\n \t       basic_string<_CharT, _Traits, _Alloc>& __str)\n     {\n-      typedef basic_istream<_CharT, _Traits> \t\t__istream_type;\n-      typedef typename __istream_type::int_type \t__int_type;\n+      typedef basic_istream<_CharT, _Traits>\t\t__istream_type;\n+      typedef typename __istream_type::int_type\t\t__int_type;\n       typedef typename __istream_type::__streambuf_type __streambuf_type;\n-      typedef typename __istream_type::__ctype_type \t__ctype_type;\n-      typedef basic_string<_CharT, _Traits, _Alloc> \t__string_type;\n+      typedef typename __istream_type::__ctype_type\t__ctype_type;\n+      typedef basic_string<_CharT, _Traits, _Alloc>\t__string_type;\n       typedef typename __string_type::size_type\t\t__size_type;\n \n       __size_type __extracted = 0;\n       ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n       typename __istream_type::sentry __cerb(__in, false);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n \t  try\n \t    {\n \t      __str.erase();\n \t      streamsize __w = __in.width();\n \t      __size_type __n;\n \t      __n = __w > 0 ? static_cast<__size_type>(__w) : __str.max_size();\n-\t      \n+\n \t      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());\n \t      const __int_type __eof = _Traits::eof();\n \t      __streambuf_type* __sb = __in.rdbuf();\n \t      __int_type __c = __sb->sgetc();\n-\t      \n-\t      while (__extracted < __n \n+\n+\t      while (__extracted < __n\n \t\t     && !_Traits::eq_int_type(__c, __eof)\n \t\t     && !__ct.is(ctype_base::space, _Traits::to_char_type(__c)))\n \t\t{\n@@ -1068,19 +1068,19 @@ namespace std\n     getline(basic_istream<_CharT, _Traits>& __in,\n \t    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)\n     {\n-      typedef basic_istream<_CharT, _Traits> \t\t__istream_type;\n-      typedef typename __istream_type::int_type \t__int_type;\n+      typedef basic_istream<_CharT, _Traits>\t\t__istream_type;\n+      typedef typename __istream_type::int_type\t\t__int_type;\n       typedef typename __istream_type::__streambuf_type __streambuf_type;\n-      typedef typename __istream_type::__ctype_type \t__ctype_type;\n-      typedef basic_string<_CharT, _Traits, _Alloc> \t__string_type;\n+      typedef typename __istream_type::__ctype_type\t__ctype_type;\n+      typedef basic_string<_CharT, _Traits, _Alloc>\t__string_type;\n       typedef typename __string_type::size_type\t\t__size_type;\n \n       __size_type __extracted = 0;\n       const __size_type __n = __str.max_size();\n       bool __testdelim = false;\n       ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n       typename __istream_type::sentry __cerb(__in, true);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n \t  try\n \t    {\n@@ -1090,7 +1090,7 @@ namespace std\n \t      __int_type __c = __sb->sbumpc();\n \t      const __int_type __eof = _Traits::eof();\n \t      __testdelim = _Traits::eq_int_type(__c, __idelim);\n-\t      \n+\n \t      while (!_Traits::eq_int_type(__c, __eof) && !__testdelim\n \t\t     && __extracted < __n)\n \t\t{\n@@ -1119,12 +1119,12 @@ namespace std\n \n   template<class _CharT, class _Traits, class _Alloc>\n     inline basic_istream<_CharT,_Traits>&\n-    getline(basic_istream<_CharT, _Traits>& __in, \n+    getline(basic_istream<_CharT, _Traits>& __in,\n \t    basic_string<_CharT,_Traits,_Alloc>& __str)\n     { return getline(__in, __str, __in.widen('\\n')); }\n \n   // Inhibit implicit instantiations for required instantiations,\n-  // which are defined via explicit instantiations elsewhere.  \n+  // which are defined via explicit instantiations elsewhere.\n   // NB:  This syntax is a GNU extension.\n #if _GLIBCXX_EXTERN_TEMPLATE\n   extern template class basic_istream<char>;"}, {"sha": "c5e20f8e5d7af135af1f3efa2f336b451c546f88", "filename": "libstdc++-v3/include/bits/list.tcc", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -78,7 +78,7 @@ namespace __gnu_norm\n         _M_put_node(__tmp);\n       }\n     }\n- \n+\n   template<typename _Tp, typename _Alloc>\n     typename list<_Tp,_Alloc>::iterator\n     list<_Tp,_Alloc>::\n@@ -88,7 +88,7 @@ namespace __gnu_norm\n       __tmp->hook(__position._M_node);\n       return __tmp;\n     }\n-  \n+\n   template<typename _Tp, typename _Alloc>\n     typename list<_Tp,_Alloc>::iterator\n     list<_Tp,_Alloc>::\n@@ -98,7 +98,7 @@ namespace __gnu_norm\n       _M_erase(__position);\n       return __ret;\n     }\n-  \n+\n   template<typename _Tp, typename _Alloc>\n     void\n     list<_Tp,_Alloc>::\n@@ -113,7 +113,7 @@ namespace __gnu_norm\n       else                          // __i == end()\n         insert(end(), __new_size - __len, __x);\n     }\n-  \n+\n   template<typename _Tp, typename _Alloc>\n     list<_Tp,_Alloc>&\n     list<_Tp,_Alloc>::\n@@ -134,7 +134,7 @@ namespace __gnu_norm\n \t}\n       return *this;\n     }\n-  \n+\n   template<typename _Tp, typename _Alloc>\n     void\n     list<_Tp,_Alloc>::\n@@ -148,25 +148,25 @@ namespace __gnu_norm\n       else\n         erase(__i, end());\n     }\n-  \n+\n   template<typename _Tp, typename _Alloc>\n     template <typename _InputIterator>\n       void\n       list<_Tp,_Alloc>::\n-      _M_assign_dispatch(_InputIterator __first2, _InputIterator __last2, \n+      _M_assign_dispatch(_InputIterator __first2, _InputIterator __last2,\n \t\t\t __false_type)\n       {\n         iterator __first1 = begin();\n         iterator __last1 = end();\n-        for (; __first1 != __last1 && __first2 != __last2; \n+        for (; __first1 != __last1 && __first2 != __last2;\n \t     ++__first1, ++__first2)\n           *__first1 = *__first2;\n         if (__first2 == __last2)\n           erase(__first1, __last1);\n         else\n           insert(__last1, __first2, __last2);\n       }\n-  \n+\n   template<typename _Tp, typename _Alloc>\n     void\n     list<_Tp,_Alloc>::\n@@ -183,7 +183,7 @@ namespace __gnu_norm\n         __first = __next;\n       }\n     }\n-  \n+\n   template<typename _Tp, typename _Alloc>\n     void\n     list<_Tp,_Alloc>::\n@@ -203,7 +203,7 @@ namespace __gnu_norm\n         __next = __first;\n       }\n     }\n-  \n+\n   template<typename _Tp, typename _Alloc>\n     void\n     list<_Tp,_Alloc>::\n@@ -230,14 +230,14 @@ namespace __gnu_norm\n \t    _M_transfer(__last1, __first2, __last2);\n \t}\n     }\n-  \n+\n   template<typename _Tp, typename _Alloc>\n     void\n     list<_Tp,_Alloc>::\n     sort()\n     {\n       // Do nothing if the list has length 0 or 1.\n-      if (this->_M_node._M_next != &this->_M_node \n+      if (this->_M_node._M_next != &this->_M_node\n \t  && this->_M_node._M_next->_M_next != &this->_M_node)\n       {\n         list __carry;\n@@ -248,7 +248,7 @@ namespace __gnu_norm\n         do\n \t  {\n \t    __carry.splice(__carry.begin(), *this, begin());\n-\t    \n+\n \t    for(__counter = &__tmp[0];\n \t\t(__counter != __fill) && !__counter->empty();\n \t\t++__counter)\n@@ -267,7 +267,7 @@ namespace __gnu_norm\n         swap( *(__fill-1) );\n       }\n     }\n-  \n+\n   template<typename _Tp, typename _Alloc>\n     template <typename _Predicate>\n       void\n@@ -285,7 +285,7 @@ namespace __gnu_norm\n           __first = __next;\n         }\n       }\n-  \n+\n   template<typename _Tp, typename _Alloc>\n     template <typename _BinaryPredicate>\n       void\n@@ -305,15 +305,15 @@ namespace __gnu_norm\n           __next = __first;\n         }\n       }\n-  \n+\n   template<typename _Tp, typename _Alloc>\n     template <typename _StrictWeakOrdering>\n       void\n       list<_Tp,_Alloc>::\n       merge(list& __x, _StrictWeakOrdering __comp)\n       {\n \t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n-\t// 300. list::merge() specification incomplete\t\n+\t// 300. list::merge() specification incomplete\n \tif (this != &__x)\n \t  {\n \t    iterator __first1 = begin();\n@@ -333,7 +333,7 @@ namespace __gnu_norm\n \t      _M_transfer(__last1, __first2, __last2);\n \t  }\n       }\n-  \n+\n   template<typename _Tp, typename _Alloc>\n     template <typename _StrictWeakOrdering>\n       void\n@@ -348,11 +348,11 @@ namespace __gnu_norm\n \t    list __tmp[64];\n \t    list * __fill = &__tmp[0];\n \t    list * __counter;\n-\t    \n+\n \t    do\n \t      {\n \t\t__carry.splice(__carry.begin(), *this, begin());\n-\t\t\n+\n \t\tfor(__counter = &__tmp[0];\n \t\t    (__counter != __fill) && !__counter->empty();\n \t\t    ++__counter)\n@@ -365,7 +365,7 @@ namespace __gnu_norm\n \t\t  ++__fill;\n \t      }\n \t    while ( !empty() );\n-\t    \n+\n \t    for (__counter =  &__tmp[1]; __counter != __fill; ++__counter)\n \t      __counter->merge( *(__counter-1), __comp );\n \t    swap( *(__fill-1) );"}, {"sha": "33eb47576db69ef97b3d3ff4abe351a23b93c75c", "filename": "libstdc++-v3/include/bits/locale_classes.h", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_classes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_classes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_classes.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -80,16 +80,16 @@ namespace std\n     friend class _Impl;\n \n     template<typename _Facet>\n-      friend bool \n+      friend bool\n       has_facet(const locale&) throw();\n \n     template<typename _Facet>\n-      friend const _Facet& \n+      friend const _Facet&\n       use_facet(const locale&);\n \n     template<typename _Cache>\n       friend struct __use_cache;\n-   \n+\n     //@{\n     /**\n      *  @brief  Category values.\n@@ -103,18 +103,18 @@ namespace std\n      *  @endif\n     */\n     static const category none\t\t= 0;\n-    static const category ctype \t= 1L << 0;\n-    static const category numeric \t= 1L << 1;\n-    static const category collate  \t= 1L << 2;\n-    static const category time \t\t= 1L << 3;\n-    static const category monetary \t= 1L << 4;\n-    static const category messages \t= 1L << 5;\n-    static const category all \t\t= (ctype | numeric | collate |\n-\t\t\t\t \t   time  | monetary | messages);\n+    static const category ctype\t\t= 1L << 0;\n+    static const category numeric\t= 1L << 1;\n+    static const category collate\t= 1L << 2;\n+    static const category time\t\t= 1L << 3;\n+    static const category monetary\t= 1L << 4;\n+    static const category messages\t= 1L << 5;\n+    static const category all\t\t= (ctype | numeric | collate |\n+\t\t\t\t\t   time  | monetary | messages);\n     //@}\n \n     // Construct/copy/destroy:\n-    \n+\n     /**\n      *  @brief  Default constructor.\n      *\n@@ -140,7 +140,7 @@ namespace std\n      *  @param  s  Name of the locale to construct.\n      *  @throw  std::runtime_error if s is null or an undefined locale.\n     */\n-    explicit  \n+    explicit\n     locale(const char* __s);\n \n     /**\n@@ -152,7 +152,7 @@ namespace std\n      *\n      *  @param  base  The locale to copy.\n      *  @param  s  Name of the locale to use facets from.\n-     *  @param  cat  Set of categories defining the facets to use from s.  \n+     *  @param  cat  Set of categories defining the facets to use from s.\n      *  @throw  std::runtime_error if s is null or an undefined locale.\n     */\n     locale(const locale& __base, const char* __s, category __cat);\n@@ -210,25 +210,25 @@ namespace std\n      *  @throw  std::runtime_error if other has no facet of type Facet.\n     */\n     template<typename _Facet>\n-      locale  \n+      locale\n       combine(const locale& __other) const;\n \n     // Locale operations:\n     /**\n      *  @brief  Return locale name.\n      *  @return  Locale name or \"*\" if unnamed.\n     */\n-    string \n+    string\n     name() const;\n \n     /**\n      *  @brief  Locale equality.\n      *\n      *  @param  other  The locale to compare against.\n      *  @return  True if other and this refer to the same locale instance, are\n-     *  \t copies, or have the same name.  False otherwise.\n+     *\t\t copies, or have the same name.  False otherwise.\n     */\n-    bool \n+    bool\n     operator==(const locale& __other) const throw ();\n \n     /**\n@@ -237,7 +237,7 @@ namespace std\n      *  @param  other  The locale to compare against.\n      *  @return  ! (*this == other)\n     */\n-    inline bool  \n+    inline bool\n     operator!=(const locale& __other) const throw ()\n     { return !(this->operator==(__other));  }\n \n@@ -257,7 +257,7 @@ namespace std\n      *  @return  True if collate<Char> facet compares s1 < s2, else false.\n     */\n     template<typename _Char, typename _Traits, typename _Alloc>\n-      bool  \n+      bool\n       operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,\n \t\t const basic_string<_Char, _Traits, _Alloc>& __s2) const;\n \n@@ -272,26 +272,26 @@ namespace std\n      *  @param  locale  The new locale to make global.\n      *  @return  Copy of the old global locale.\n     */\n-    static locale \n+    static locale\n     global(const locale&);\n \n     /**\n      *  @brief  Return reference to the \"C\" locale.\n     */\n-    static const locale& \n+    static const locale&\n     classic();\n \n   private:\n     // The (shared) implementation\n-    _Impl* \t\t_M_impl;  \n+    _Impl*\t\t_M_impl;\n \n     // The \"C\" reference locale\n     static _Impl*       _S_classic;\n \n     // Current global locale\n-    static _Impl* \t_S_global;  \n+    static _Impl*\t_S_global;\n \n-    // Names of underlying locale categories.  \n+    // Names of underlying locale categories.\n     // NB: locale::global() has to know how to modify all the\n     // underlying categories, not just the ones required by the C++\n     // standard.\n@@ -313,16 +313,16 @@ namespace std\n     static __gthread_once_t _S_once;\n #endif\n \n-    explicit \n+    explicit\n     locale(_Impl*) throw();\n \n-    static void  \n+    static void\n     _S_initialize();\n \n     static void\n     _S_initialize_once();\n \n-    static category  \n+    static category\n     _S_normalize_category(category);\n \n     void\n@@ -355,10 +355,10 @@ namespace std\n     static const char\t\t\t_S_c_name[2];\n \n #ifdef __GTHREADS\n-    static __gthread_once_t \t\t_S_once;\n+    static __gthread_once_t\t\t_S_once;\n #endif\n \n-    static void \n+    static void\n     _S_initialize_once();\n \n   protected:\n@@ -371,16 +371,16 @@ namespace std\n      *\n      *  @param refs  The initial value for reference count.\n     */\n-    explicit \n+    explicit\n     facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)\n     { }\n \n     /// Facet destructor.\n-    virtual \n+    virtual\n     ~facet();\n \n     static void\n-    _S_create_c_locale(__c_locale& __cloc, const char* __s, \n+    _S_create_c_locale(__c_locale& __cloc, const char* __s,\n \t\t       __c_locale __old = 0);\n \n     static __c_locale\n@@ -407,16 +407,16 @@ namespace std\n     {\n       if (__exchange_and_add(&_M_refcount, -1) == 1)\n \t{\n-\t  try \n-\t    { delete this; }  \n-\t  catch (...) \n+\t  try\n+\t    { delete this; }\n+\t  catch (...)\n \t    { }\n \t}\n     }\n \n     facet(const facet&);  // Not defined.\n \n-    void \n+    void\n     operator=(const facet&);  // Not defined.\n   };\n \n@@ -438,22 +438,22 @@ namespace std\n     friend class locale::_Impl;\n \n     template<typename _Facet>\n-      friend const _Facet&  \n+      friend const _Facet&\n       use_facet(const locale&);\n \n     template<typename _Facet>\n-      friend bool           \n+      friend bool\n       has_facet(const locale&) throw ();\n \n     // NB: There is no accessor for _M_index because it may be used\n     // before the constructor is run; the effect of calling a member\n     // function (even an inline) would be undefined.\n-    mutable size_t \t\t_M_index;\n+    mutable size_t\t\t_M_index;\n \n     // Last id number assigned.\n-    static _Atomic_word \t_S_refcount;   \n+    static _Atomic_word\t\t_S_refcount;\n \n-    void \n+    void\n     operator=(const id&);  // Not defined.\n \n     id(const id&);  // Not defined.\n@@ -478,11 +478,11 @@ namespace std\n     friend class locale::facet;\n \n     template<typename _Facet>\n-      friend bool  \n+      friend bool\n       has_facet(const locale&) throw();\n \n     template<typename _Facet>\n-      friend const _Facet&  \n+      friend const _Facet&\n       use_facet(const locale&);\n \n     template<typename _Cache>\n@@ -492,29 +492,29 @@ namespace std\n     // Data Members.\n     _Atomic_word\t\t\t_M_refcount;\n     const facet**\t\t\t_M_facets;\n-    size_t \t\t\t\t_M_facets_size;\n+    size_t\t\t\t\t_M_facets_size;\n     const facet**\t\t\t_M_caches;\n-    char** \t\t\t\t_M_names;\n-    static const locale::id* const \t_S_id_ctype[];\n-    static const locale::id* const \t_S_id_numeric[];\n-    static const locale::id* const \t_S_id_collate[];\n-    static const locale::id* const \t_S_id_time[];\n-    static const locale::id* const \t_S_id_monetary[];\n-    static const locale::id* const \t_S_id_messages[];\n+    char**\t\t\t\t_M_names;\n+    static const locale::id* const\t_S_id_ctype[];\n+    static const locale::id* const\t_S_id_numeric[];\n+    static const locale::id* const\t_S_id_collate[];\n+    static const locale::id* const\t_S_id_time[];\n+    static const locale::id* const\t_S_id_monetary[];\n+    static const locale::id* const\t_S_id_messages[];\n     static const locale::id* const* const _S_facet_categories[];\n \n-    inline void \n+    inline void\n     _M_add_reference() throw()\n     { __atomic_add(&_M_refcount, 1); }\n \n-    inline void \n+    inline void\n     _M_remove_reference() throw()\n     {\n       if (__exchange_and_add(&_M_refcount, -1) == 1)\n \t{\n-\t  try \n-\t    { delete this; } \n-\t  catch(...) \n+\t  try\n+\t    { delete this; }\n+\t  catch(...)\n \t    { }\n \t}\n     }\n@@ -527,7 +527,7 @@ namespace std\n \n     _Impl(const _Impl&);  // Not defined.\n \n-    void \n+    void\n     operator=(const _Impl&);  // Not defined.\n \n     inline bool\n@@ -539,29 +539,29 @@ namespace std\n       return __ret;\n     }\n \n-    void \n+    void\n     _M_replace_categories(const _Impl*, category);\n \n-    void \n+    void\n     _M_replace_category(const _Impl*, const locale::id* const*);\n \n-    void \n+    void\n     _M_replace_facet(const _Impl*, const locale::id*);\n \n-    void \n+    void\n     _M_install_facet(const locale::id*, const facet*);\n \n     template<typename _Facet>\n-      inline void \n+      inline void\n       _M_init_facet(_Facet* __facet)\n       { _M_install_facet(&_Facet::id, __facet); }\n \n     void\n     _M_install_cache(const facet* __cache, size_t __index) throw()\n-    { \n+    {\n       __cache->_M_add_reference();\n-      _M_caches[__index] = __cache; \n-    }      \n+      _M_caches[__index] = __cache;\n+    }\n   };\n \n   template<typename _Facet>\n@@ -584,7 +584,7 @@ namespace std\n \t{\n \t  _M_impl->_M_remove_reference();\n \t  for (size_t __j = 0; __j < __i; ++__j)\n-\t    delete [] _M_tmp_names[__j];\t  \n+\t    delete [] _M_tmp_names[__j];\n \t  __throw_exception_again;\n \t}\n "}, {"sha": "14fb84c1555b79193726439cd34bd1001850bbe9", "filename": "libstdc++-v3/include/bits/locale_facets.h", "status": "modified", "additions": 462, "deletions": 462, "changes": 924, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -57,28 +57,28 @@ namespace std\n # define  _GLIBCXX_NUM_FACETS 14\n #endif\n \n-  // Convert string to numeric value of type _Tv and store results.  \n+  // Convert string to numeric value of type _Tv and store results.\n   // NB: This is specialized for all required types, there is no\n   // generic definition.\n   template<typename _Tv>\n     void\n-    __convert_to_v(const char* __in, _Tv& __out, ios_base::iostate& __err, \n+    __convert_to_v(const char* __in, _Tv& __out, ios_base::iostate& __err,\n \t\t   const __c_locale& __cloc);\n \n   // Explicit specializations for required types.\n   template<>\n     void\n-    __convert_to_v(const char*, float&, ios_base::iostate&, \n+    __convert_to_v(const char*, float&, ios_base::iostate&,\n \t\t   const __c_locale&);\n \n   template<>\n     void\n-    __convert_to_v(const char*, double&, ios_base::iostate&, \n+    __convert_to_v(const char*, double&, ios_base::iostate&,\n \t\t   const __c_locale&);\n \n   template<>\n     void\n-    __convert_to_v(const char*, long double&, ios_base::iostate&, \n+    __convert_to_v(const char*, long double&, ios_base::iostate&,\n \t\t   const __c_locale&);\n \n   // NB: __pad is a struct, rather than a function, so it can be\n@@ -87,8 +87,8 @@ namespace std\n     struct __pad\n     {\n       static void\n-      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news, \n-\t     const _CharT* __olds, const streamsize __newlen, \n+      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,\n+\t     const _CharT* __olds, const streamsize __newlen,\n \t     const streamsize __oldlen, const bool __num);\n     };\n \n@@ -99,8 +99,8 @@ namespace std\n   // only with __glen != 0.\n   template<typename _CharT>\n     _CharT*\n-    __add_grouping(_CharT* __s, _CharT __sep,  \n-\t\t   const char* __gbeg, size_t __gsize, \n+    __add_grouping(_CharT* __s, _CharT __sep,\n+\t\t   const char* __gbeg, size_t __gsize,\n \t\t   const _CharT* __first, const _CharT* __last);\n \n   // This template permits specializing facet output code for\n@@ -131,7 +131,7 @@ namespace std\n   // Include host and configuration specific ctype enums for ctype_base.\n   #include <bits/ctype_base.h>\n \n-  // Common base for ctype<_CharT>.  \n+  // Common base for ctype<_CharT>.\n   /**\n    *  @brief  Common base for ctype facet\n    *\n@@ -159,7 +159,7 @@ namespace std\n        *  @param m  The mask to compare against.\n        *  @return  (M & m) != 0.\n       */\n-      bool \n+      bool\n       is(mask __m, char_type __c) const\n       { return this->do_is(__m, __c); }\n \n@@ -177,7 +177,7 @@ namespace std\n        *  @return  @a hi.\n       */\n       const char_type*\n-      is(const char_type *__lo, const char_type *__hi, mask *__vec) const   \n+      is(const char_type *__lo, const char_type *__hi, mask *__vec) const\n       { return this->do_is(__lo, __hi, __vec); }\n \n       /**\n@@ -222,7 +222,7 @@ namespace std\n        *  @param c  The char_type to convert.\n        *  @return  The uppercase char_type if convertible, else @a c.\n       */\n-      char_type \n+      char_type\n       toupper(char_type __c) const\n       { return this->do_toupper(__c); }\n \n@@ -321,7 +321,7 @@ namespace std\n        *  @param dfault  Char to return if conversion fails.\n        *  @return  The converted char.\n       */\n-      char \n+      char\n       narrow(char_type __c, char __dfault) const\n       { return this->do_narrow(__c, __dfault); }\n \n@@ -349,12 +349,12 @@ namespace std\n       { return this->do_narrow(__lo, __hi, __dfault, __to); }\n \n     protected:\n-      explicit \n+      explicit\n       __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }\n \n-      virtual \n+      virtual\n       ~__ctype_abstract_base() { }\n-      \n+\n       /**\n        *  @brief  Test char_type classification.\n        *\n@@ -388,7 +388,7 @@ namespace std\n        *  @return  @a hi.\n       */\n       virtual const char_type*\n-      do_is(const char_type* __lo, const char_type* __hi, \n+      do_is(const char_type* __lo, const char_type* __hi,\n \t    mask* __vec) const = 0;\n \n       /**\n@@ -426,7 +426,7 @@ namespace std\n        *  @return  Pointer to a non-matching char_type if found, else @a hi.\n       */\n       virtual const char_type*\n-      do_scan_not(mask __m, const char_type* __lo, \n+      do_scan_not(mask __m, const char_type* __lo,\n \t\t  const char_type* __hi) const = 0;\n \n       /**\n@@ -443,7 +443,7 @@ namespace std\n        *  @param c  The char_type to convert.\n        *  @return  The uppercase char_type if convertible, else @a c.\n       */\n-      virtual char_type \n+      virtual char_type\n       do_toupper(char_type) const = 0;\n \n       /**\n@@ -495,7 +495,7 @@ namespace std\n       */\n       virtual const char_type*\n       do_tolower(char_type* __lo, const char_type* __hi) const = 0;\n-      \n+\n       /**\n        *  @brief  Widen char\n        *\n@@ -512,7 +512,7 @@ namespace std\n        *  @param c  The char to convert.\n        *  @return  The converted char_type\n       */\n-      virtual char_type \n+      virtual char_type\n       do_widen(char) const = 0;\n \n       /**\n@@ -534,7 +534,7 @@ namespace std\n        *  @return  @a hi.\n       */\n       virtual const char*\n-      do_widen(const char* __lo, const char* __hi, \n+      do_widen(const char* __lo, const char* __hi,\n \t       char_type* __dest) const = 0;\n \n       /**\n@@ -555,7 +555,7 @@ namespace std\n        *  @param dfault  Char to return if conversion fails.\n        *  @return  The converted char.\n       */\n-      virtual char \n+      virtual char\n       do_narrow(char_type, char __dfault) const = 0;\n \n       /**\n@@ -607,20 +607,20 @@ namespace std\n     {\n     public:\n       // Types:\n-      typedef _CharT \t\t  \tchar_type;\n+      typedef _CharT\t\t\tchar_type;\n       typedef typename __ctype_abstract_base<_CharT>::mask mask;\n \n       /// The facet id for ctype<char_type>\n-      static locale::id \t       \tid;\n+      static locale::id\t\t\tid;\n \n-      explicit \n+      explicit\n       ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }\n \n    protected:\n-      virtual \n+      virtual\n       ~ctype();\n \n-      virtual bool \n+      virtual bool\n       do_is(mask __m, char_type __c) const;\n \n       virtual const char_type*\n@@ -633,25 +633,25 @@ namespace std\n       do_scan_not(mask __m, const char_type* __lo,\n \t\t  const char_type* __hi) const;\n \n-      virtual char_type \n+      virtual char_type\n       do_toupper(char_type __c) const;\n \n       virtual const char_type*\n       do_toupper(char_type* __lo, const char_type* __hi) const;\n \n-      virtual char_type \n+      virtual char_type\n       do_tolower(char_type __c) const;\n \n       virtual const char_type*\n       do_tolower(char_type* __lo, const char_type* __hi) const;\n \n-      virtual char_type \n+      virtual char_type\n       do_widen(char __c) const;\n \n       virtual const char*\n       do_widen(const char* __lo, const char* __hi, char_type* __dest) const;\n \n-      virtual char \n+      virtual char\n       do_narrow(char_type, char __dfault) const;\n \n       virtual const char_type*\n@@ -677,21 +677,21 @@ namespace std\n     public:\n       // Types:\n       /// Typedef for the template parameter char.\n-      typedef char \t       \tchar_type;\n+      typedef char\t\tchar_type;\n \n     protected:\n       // Data Members:\n       __c_locale\t\t_M_c_locale_ctype;\n-      bool \t\t       \t_M_del;\n-      __to_type \t       \t_M_toupper;\n-      __to_type  \t       \t_M_tolower;\n-      const mask*              \t_M_table;\n+      bool\t\t\t_M_del;\n+      __to_type\t\t\t_M_toupper;\n+      __to_type\t\t\t_M_tolower;\n+      const mask*\t\t_M_table;\n       mutable char\t\t_M_widen_ok;\n       mutable char\t\t_M_widen[1 + static_cast<unsigned char>(-1)];\n       mutable char\t\t_M_narrow[1 + static_cast<unsigned char>(-1)];\n       mutable char\t\t_M_narrow_ok;\t// 0 uninitialized, 1 init,\n \t\t\t\t\t\t// 2 non-consecutive\n-      \n+\n     public:\n       /// The facet id for ctype<char>\n       static locale::id        id;\n@@ -708,7 +708,7 @@ namespace std\n        *  @param del   If true, passes ownership of table to this facet.\n        *  @param refs  Passed to the base facet class.\n       */\n-      explicit \n+      explicit\n       ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);\n \n       /**\n@@ -721,8 +721,8 @@ namespace std\n        *  @param del   If true, passes ownership of table to this facet.\n        *  @param refs  Passed to the base facet class.\n       */\n-      explicit \n-      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false, \n+      explicit\n+      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,\n \t    size_t __refs = 0);\n \n       /**\n@@ -736,7 +736,7 @@ namespace std\n       */\n       inline bool\n       is(mask __m, char __c) const;\n- \n+\n       /**\n        *  @brief  Return a mask array.\n        *\n@@ -751,7 +751,7 @@ namespace std\n       */\n       inline const char*\n       is(const char* __lo, const char* __hi, mask* __vec) const;\n- \n+\n       /**\n        *  @brief  Find char matching a mask\n        *\n@@ -779,7 +779,7 @@ namespace std\n       */\n       inline const char*\n       scan_not(mask __m, const char* __lo, const char* __hi) const;\n-     \n+\n       /**\n        *  @brief  Convert to uppercase.\n        *\n@@ -792,7 +792,7 @@ namespace std\n        *  @param c  The char to convert.\n        *  @return  The uppercase char if convertible, else @a c.\n       */\n-      char_type \n+      char_type\n       toupper(char_type __c) const\n       { return this->do_toupper(__c); }\n \n@@ -825,7 +825,7 @@ namespace std\n        *  @param c  The char to convert.\n        *  @return  The lowercase char if convertible, else @a c.\n       */\n-      char_type \n+      char_type\n       tolower(char_type __c) const\n       { return this->do_tolower(__c); }\n \n@@ -862,9 +862,9 @@ namespace std\n        *  @param c  The char to convert.\n        *  @return  The converted character.\n       */\n-      char_type \n+      char_type\n       widen(char __c) const\n-      { \n+      {\n \tif (_M_widen_ok) return _M_widen[static_cast<unsigned char>(__c)];\n \tthis->_M_widen_init();\n \treturn this->do_widen(__c);\n@@ -918,7 +918,7 @@ namespace std\n        *  @param dfault  Char to return if conversion fails.\n        *  @return  The converted character.\n       */\n-      char \n+      char\n       narrow(char_type __c, char __dfault) const\n       {\n \tif (_M_narrow[static_cast<unsigned char>(__c)])\n@@ -967,12 +967,12 @@ namespace std\n     protected:\n       /// Returns a pointer to the mask table provided to the constructor, or\n       /// the default from classic_table() if none was provided.\n-      const mask* \n+      const mask*\n       table() const throw()\n       { return _M_table; }\n \n       /// Returns a pointer to the C locale mask table.\n-      static const mask* \n+      static const mask*\n       classic_table() throw();\n \n       /**\n@@ -981,7 +981,7 @@ namespace std\n        *  This function deletes table() if @a del was true in the\n        *  constructor.\n       */\n-      virtual \n+      virtual\n       ~ctype();\n \n       /**\n@@ -997,7 +997,7 @@ namespace std\n        *  @param c  The char to convert.\n        *  @return  The uppercase char if convertible, else @a c.\n       */\n-      virtual char_type \n+      virtual char_type\n       do_toupper(char_type) const;\n \n       /**\n@@ -1030,7 +1030,7 @@ namespace std\n        *  @param c  The char to convert.\n        *  @return  The lowercase char if convertible, else @a c.\n       */\n-      virtual char_type \n+      virtual char_type\n       do_tolower(char_type) const;\n \n       /**\n@@ -1049,7 +1049,7 @@ namespace std\n       */\n       virtual const char_type*\n       do_tolower(char_type* __lo, const char_type* __hi) const;\n-      \n+\n       /**\n        *  @brief  Widen char\n        *\n@@ -1067,7 +1067,7 @@ namespace std\n        *  @param c  The char to convert.\n        *  @return  The converted character.\n       */\n-      virtual char_type \n+      virtual char_type\n       do_widen(char __c) const\n       { return __c; }\n \n@@ -1116,7 +1116,7 @@ namespace std\n        *  @param dfault  Char to return if conversion fails.\n        *  @return  The converted char.\n       */\n-      virtual char \n+      virtual char\n       do_narrow(char_type __c, char) const\n       { return __c; }\n \n@@ -1158,7 +1158,7 @@ namespace std\n \tfor (size_t __i = 0; __i < sizeof(_M_widen); ++__i)\n \t  __tmp[__i] = __i;\n \tdo_widen(__tmp, __tmp + sizeof(__tmp), _M_widen);\n-\t    \n+\n \t_M_widen_ok = 1;\n \t// Set _M_widen_ok to 2 if memcpy can't be used.\n \tfor (size_t __i = 0; __i < sizeof(_M_widen); ++__i)\n@@ -1196,7 +1196,7 @@ namespace std\n \t_M_narrow_ok = __consecutive ? 1 : 2;\n       }\n     };\n- \n+\n   template<>\n     const ctype<char>&\n     use_facet<ctype<char> >(const locale& __loc);\n@@ -1219,8 +1219,8 @@ namespace std\n     public:\n       // Types:\n       /// Typedef for the template parameter wchar_t.\n-      typedef wchar_t \t       \tchar_type;\n-      typedef wctype_t\t       \t__wmask_type;\n+      typedef wchar_t\t\tchar_type;\n+      typedef wctype_t\t\t__wmask_type;\n \n     protected:\n       __c_locale\t\t_M_c_locale_ctype;\n@@ -1237,7 +1237,7 @@ namespace std\n     public:\n       // Data Members:\n       /// The facet id for ctype<wchar_t>\n-      static locale::id        \tid;\n+      static locale::id\t\tid;\n \n       /**\n        *  @brief  Constructor performs initialization.\n@@ -1246,7 +1246,7 @@ namespace std\n        *\n        *  @param refs  Passed to the base facet class.\n       */\n-      explicit \n+      explicit\n       ctype(size_t __refs = 0);\n \n       /**\n@@ -1257,15 +1257,15 @@ namespace std\n        *  @param cloc  Handle to C locale data.\n        *  @param refs  Passed to the base facet class.\n       */\n-      explicit \n+      explicit\n       ctype(__c_locale __cloc, size_t __refs = 0);\n \n     protected:\n       __wmask_type\n       _M_convert_to_wmask(const mask __m) const;\n \n       /// Destructor\n-      virtual \n+      virtual\n       ~ctype();\n \n       /**\n@@ -1281,7 +1281,7 @@ namespace std\n        *  @param m  The mask to compare against.\n        *  @return  (M & m) != 0.\n       */\n-      virtual bool \n+      virtual bool\n       do_is(mask __m, char_type __c) const;\n \n       /**\n@@ -1337,7 +1337,7 @@ namespace std\n        *  @return  Pointer to a non-matching wchar_t if found, else @a hi.\n       */\n       virtual const char_type*\n-      do_scan_not(mask __m, const char_type* __lo, \n+      do_scan_not(mask __m, const char_type* __lo,\n \t\t  const char_type* __hi) const;\n \n       /**\n@@ -1353,7 +1353,7 @@ namespace std\n        *  @param c  The wchar_t to convert.\n        *  @return  The uppercase wchar_t if convertible, else @a c.\n       */\n-      virtual char_type \n+      virtual char_type\n       do_toupper(char_type) const;\n \n       /**\n@@ -1386,7 +1386,7 @@ namespace std\n        *  @param c  The wchar_t to convert.\n        *  @return  The lowercase wchar_t if convertible, else @a c.\n       */\n-      virtual char_type \n+      virtual char_type\n       do_tolower(char_type) const;\n \n       /**\n@@ -1405,7 +1405,7 @@ namespace std\n       */\n       virtual const char_type*\n       do_tolower(char_type* __lo, const char_type* __hi) const;\n-      \n+\n       /**\n        *  @brief  Widen char to wchar_t\n        *\n@@ -1423,7 +1423,7 @@ namespace std\n        *  @param c  The char to convert.\n        *  @return  The converted wchar_t.\n       */\n-      virtual char_type \n+      virtual char_type\n       do_widen(char) const;\n \n       /**\n@@ -1467,7 +1467,7 @@ namespace std\n        *  @param dfault  Char to return if conversion fails.\n        *  @return  The converted char.\n       */\n-      virtual char \n+      virtual char\n       do_narrow(char_type, char __dfault) const;\n \n       /**\n@@ -1498,7 +1498,7 @@ namespace std\n \t\tchar __dfault, char* __dest) const;\n \n       // For use at construction time only.\n-      void \n+      void\n       _M_initialize_ctype();\n     };\n \n@@ -1515,13 +1515,13 @@ namespace std\n     class ctype_byname : public ctype<_CharT>\n     {\n     public:\n-      typedef _CharT \t\tchar_type;\n+      typedef _CharT\t\tchar_type;\n \n-      explicit \n+      explicit\n       ctype_byname(const char* __s, size_t __refs = 0);\n \n     protected:\n-      virtual \n+      virtual\n       ~ctype_byname() { };\n     };\n \n@@ -1536,26 +1536,26 @@ namespace std\n   #include <bits/codecvt.h>\n \n   // 22.2.2  The numeric category.\n-  class __num_base \n+  class __num_base\n   {\n   public:\n     // NB: Code depends on the order of _S_atoms_out elements.\n     // Below are the indices into _S_atoms_out.\n-    enum \n-      {  \n-        _S_ominus, \n-        _S_oplus, \n-        _S_ox, \n-        _S_oX, \n+    enum\n+      {\n+        _S_ominus,\n+        _S_oplus,\n+        _S_ox,\n+        _S_oX,\n         _S_odigits,\n         _S_odigits_end = _S_odigits + 16,\n-        _S_oudigits = _S_odigits_end,  \n+        _S_oudigits = _S_odigits_end,\n         _S_oudigits_end = _S_oudigits + 16,\n         _S_oe = _S_odigits + 14,  // For scientific notation, 'e'\n         _S_oE = _S_oudigits + 14, // For scientific notation, 'E'\n \t_S_oend = _S_oudigits_end\n       };\n-    \n+\n     // A list of valid numeric literals for output.  This array\n     // contains chars that will be passed through the current locale's\n     // ctype<_CharT>.widen() and then used to render numbers.\n@@ -1567,12 +1567,12 @@ namespace std\n     // \"-+xX0123456789abcdefABCDEF\"\n     static const char* _S_atoms_in;\n \n-    enum \n-    {  \n-      _S_iminus, \n-      _S_iplus, \n-      _S_ix, \n-      _S_iX, \n+    enum\n+    {\n+      _S_iminus,\n+      _S_iplus,\n+      _S_ix,\n+      _S_iX,\n       _S_izero,\n       _S_ie = _S_izero + 14,\n       _S_iE = _S_izero + 20,\n@@ -1588,36 +1588,36 @@ namespace std\n   template<typename _CharT>\n     struct __numpunct_cache : public locale::facet\n     {\n-      const char* \t\t\t_M_grouping;\n+      const char*\t\t\t_M_grouping;\n       size_t                            _M_grouping_size;\n       bool\t\t\t\t_M_use_grouping;\n-      const _CharT* \t\t\t_M_truename;\n+      const _CharT*\t\t\t_M_truename;\n       size_t                            _M_truename_size;\n       const _CharT*\t\t\t_M_falsename;\n-      size_t                            _M_falsename_size;     \n-      _CharT \t\t\t\t_M_decimal_point;\n-      _CharT \t\t\t\t_M_thousands_sep;\n-      \n+      size_t                            _M_falsename_size;\n+      _CharT\t\t\t\t_M_decimal_point;\n+      _CharT\t\t\t\t_M_thousands_sep;\n+\n       // A list of valid numeric literals for output: in the standard\n       // \"C\" locale, this is \"-+xX0123456789abcdef0123456789ABCDEF\".\n       // This array contains the chars after having been passed\n       // through the current locale's ctype<_CharT>.widen().\n-      _CharT                    \t_M_atoms_out[__num_base::_S_oend];\n+      _CharT\t\t\t\t_M_atoms_out[__num_base::_S_oend];\n \n       // A list of valid numeric literals for input: in the standard\n       // \"C\" locale, this is \"-+xX0123456789abcdefABCDEF\"\n       // This array contains the chars after having been passed\n       // through the current locale's ctype<_CharT>.widen().\n-      _CharT                    \t_M_atoms_in[__num_base::_S_iend];\n+      _CharT\t\t\t\t_M_atoms_in[__num_base::_S_iend];\n \n       bool\t\t\t\t_M_allocated;\n \n-      __numpunct_cache(size_t __refs = 0) : facet(__refs), \n+      __numpunct_cache(size_t __refs = 0) : facet(__refs),\n       _M_grouping(NULL), _M_grouping_size(0), _M_use_grouping(false),\n       _M_truename(NULL), _M_truename_size(0), _M_falsename(NULL),\n       _M_falsename_size(0), _M_decimal_point(_CharT()),\n       _M_thousands_sep(_CharT()), _M_allocated(false)\n-      { } \n+      { }\n \n       ~__numpunct_cache();\n \n@@ -1648,14 +1648,14 @@ namespace std\n       _CharT* __falsename = new _CharT[_M_falsename_size];\n       __np.falsename().copy(__falsename, _M_falsename_size);\n       _M_falsename = __falsename;\n-          \n+\n       _M_decimal_point = __np.decimal_point();\n       _M_thousands_sep = __np.thousands_sep();\n-      \n+\n       const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);\n-      __ct.widen(__num_base::_S_atoms_out, \n+      __ct.widen(__num_base::_S_atoms_out,\n \t\t __num_base::_S_atoms_out + __num_base::_S_oend, _M_atoms_out);\n-      __ct.widen(__num_base::_S_atoms_in, \n+      __ct.widen(__num_base::_S_atoms_in,\n \t\t __num_base::_S_atoms_in + __num_base::_S_iend, _M_atoms_in);\n     }\n \n@@ -1690,8 +1690,8 @@ namespace std\n       // Types:\n       //@{\n       /// Public typedefs\n-      typedef _CharT          \t\tchar_type;\n-      typedef basic_string<_CharT> \tstring_type;\n+      typedef _CharT\t\t\tchar_type;\n+      typedef basic_string<_CharT>\tstring_type;\n       //@}\n       typedef __numpunct_cache<_CharT>  __cache_type;\n \n@@ -1700,14 +1700,14 @@ namespace std\n \n     public:\n       /// Numpunct facet id.\n-      static locale::id \t\tid;\n+      static locale::id\t\t\tid;\n \n       /**\n        *  @brief  Numpunct constructor.\n        *\n        *  @param  refs  Refcount to pass to the base class.\n        */\n-      explicit \n+      explicit\n       numpunct(size_t __refs = 0) : facet(__refs), _M_data(NULL)\n       { _M_initialize_numpunct(); }\n \n@@ -1720,8 +1720,8 @@ namespace std\n        *  @param  cache  __numpunct_cache object.\n        *  @param  refs  Refcount to pass to the base class.\n        */\n-      explicit \n-      numpunct(__cache_type* __cache, size_t __refs = 0) \n+      explicit\n+      numpunct(__cache_type* __cache, size_t __refs = 0)\n       : facet(__refs), _M_data(__cache)\n       { _M_initialize_numpunct(); }\n \n@@ -1734,8 +1734,8 @@ namespace std\n        *  @param  cloc  The \"C\" locale.\n        *  @param  refs  Refcount to pass to the base class.\n        */\n-      explicit \n-      numpunct(__c_locale __cloc, size_t __refs = 0) \n+      explicit\n+      numpunct(__c_locale __cloc, size_t __refs = 0)\n       : facet(__refs), _M_data(NULL)\n       { _M_initialize_numpunct(__cloc); }\n \n@@ -1748,7 +1748,7 @@ namespace std\n        *\n        *  @return  @a char_type representing a decimal point.\n       */\n-      char_type    \n+      char_type\n       decimal_point() const\n       { return this->do_decimal_point(); }\n \n@@ -1761,7 +1761,7 @@ namespace std\n        *\n        *  @return  char_type representing a thousands separator.\n       */\n-      char_type    \n+      char_type\n       thousands_sep() const\n       { return this->do_thousands_sep(); }\n \n@@ -1790,7 +1790,7 @@ namespace std\n        *\n        *  @return  string representing grouping specification.\n       */\n-      string       \n+      string\n       grouping() const\n       { return this->do_grouping(); }\n \n@@ -1803,7 +1803,7 @@ namespace std\n        *\n        *  @return  string_type representing printed form of true.\n       */\n-      string_type  \n+      string_type\n       truename() const\n       { return this->do_truename(); }\n \n@@ -1816,13 +1816,13 @@ namespace std\n        *\n        *  @return  string_type representing printed form of false.\n       */\n-      string_type  \n+      string_type\n       falsename() const\n       { return this->do_falsename(); }\n \n     protected:\n       /// Destructor.\n-      virtual \n+      virtual\n       ~numpunct();\n \n       /**\n@@ -1833,7 +1833,7 @@ namespace std\n        *\n        *  @return  @a char_type representing a decimal point.\n       */\n-      virtual char_type    \n+      virtual char_type\n       do_decimal_point() const\n       { return _M_data->_M_decimal_point; }\n \n@@ -1845,7 +1845,7 @@ namespace std\n        *\n        *  @return  @a char_type representing a thousands separator.\n       */\n-      virtual char_type    \n+      virtual char_type\n       do_thousands_sep() const\n       { return _M_data->_M_thousands_sep; }\n \n@@ -1889,25 +1889,25 @@ namespace std\n       { return _M_data->_M_falsename; }\n \n       // For use at construction time only.\n-      void \n+      void\n       _M_initialize_numpunct(__c_locale __cloc = NULL);\n     };\n \n   template<typename _CharT>\n     locale::id numpunct<_CharT>::id;\n \n-  template<> \n+  template<>\n     numpunct<char>::~numpunct();\n \n-  template<> \n+  template<>\n     void\n     numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);\n \n #ifdef _GLIBCXX_USE_WCHAR_T\n-  template<> \n+  template<>\n     numpunct<wchar_t>::~numpunct();\n \n-  template<> \n+  template<>\n     void\n     numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);\n #endif\n@@ -1916,25 +1916,25 @@ namespace std\n     class numpunct_byname : public numpunct<_CharT>\n     {\n     public:\n-      typedef _CharT               \tchar_type;\n-      typedef basic_string<_CharT> \tstring_type;\n+      typedef _CharT\t\t\tchar_type;\n+      typedef basic_string<_CharT>\tstring_type;\n \n-      explicit \n+      explicit\n       numpunct_byname(const char* __s, size_t __refs = 0)\n       : numpunct<_CharT>(__refs)\n       {\n \tif (std::strcmp(__s, \"C\") != 0 && std::strcmp(__s, \"POSIX\") != 0)\n \t  {\n \t    __c_locale __tmp;\n \t    this->_S_create_c_locale(__tmp, __s);\n-\t    this->_M_initialize_numpunct(__tmp);\t\n-\t    this->_S_destroy_c_locale(__tmp); \n+\t    this->_M_initialize_numpunct(__tmp);\n+\t    this->_S_destroy_c_locale(__tmp);\n \t  }\n       }\n \n     protected:\n-      virtual \n-      ~numpunct_byname() { }\t\n+      virtual\n+      ~numpunct_byname() { }\n     };\n \n   /**\n@@ -1956,12 +1956,12 @@ namespace std\n       // Types:\n       //@{\n       /// Public typedefs\n-      typedef _CharT   \t\t\tchar_type;\n-      typedef _InIter  \t\t\titer_type;\n+      typedef _CharT\t\t\tchar_type;\n+      typedef _InIter\t\t\titer_type;\n       //@}\n \n       /// Numpunct facet id.\n-      static locale::id \t\tid;\n+      static locale::id\t\t\tid;\n \n       /**\n        *  @brief  Constructor performs initialization.\n@@ -1970,7 +1970,7 @@ namespace std\n        *\n        *  @param refs  Passed to the base facet class.\n       */\n-      explicit \n+      explicit\n       num_get(size_t __refs = 0) : facet(__refs) { }\n \n       /**\n@@ -1995,7 +1995,7 @@ namespace std\n        *  @param  v  Value to format and insert.\n        *  @return  Iterator after reading.\n       */\n-      iter_type \n+      iter_type\n       get(iter_type __in, iter_type __end, ios_base& __io,\n \t  ios_base::iostate& __err, bool& __v) const\n       { return this->do_get(__in, __end, __io, __err, __v); }\n@@ -2032,32 +2032,32 @@ namespace std\n        *  @return  Iterator after reading.\n       */\n       iter_type\n-      get(iter_type __in, iter_type __end, ios_base& __io, \n+      get(iter_type __in, iter_type __end, ios_base& __io,\n \t  ios_base::iostate& __err, long& __v) const\n       { return this->do_get(__in, __end, __io, __err, __v); }\n \n-      iter_type \n+      iter_type\n       get(iter_type __in, iter_type __end, ios_base& __io,\n \t  ios_base::iostate& __err, unsigned short& __v) const\n       { return this->do_get(__in, __end, __io, __err, __v); }\n \n-      iter_type \n+      iter_type\n       get(iter_type __in, iter_type __end, ios_base& __io,\n \t  ios_base::iostate& __err, unsigned int& __v)   const\n       { return this->do_get(__in, __end, __io, __err, __v); }\n \n-      iter_type \n+      iter_type\n       get(iter_type __in, iter_type __end, ios_base& __io,\n \t  ios_base::iostate& __err, unsigned long& __v)  const\n       { return this->do_get(__in, __end, __io, __err, __v); }\n \n #ifdef _GLIBCXX_USE_LONG_LONG\n-      iter_type \n+      iter_type\n       get(iter_type __in, iter_type __end, ios_base& __io,\n \t  ios_base::iostate& __err, long long& __v) const\n       { return this->do_get(__in, __end, __io, __err, __v); }\n \n-      iter_type \n+      iter_type\n       get(iter_type __in, iter_type __end, ios_base& __io,\n \t  ios_base::iostate& __err, unsigned long long& __v)  const\n       { return this->do_get(__in, __end, __io, __err, __v); }\n@@ -2090,17 +2090,17 @@ namespace std\n        *  @param  v  Value to format and insert.\n        *  @return  Iterator after reading.\n       */\n-      iter_type \n+      iter_type\n       get(iter_type __in, iter_type __end, ios_base& __io,\n \t  ios_base::iostate& __err, float& __v) const\n       { return this->do_get(__in, __end, __io, __err, __v); }\n \n-      iter_type \n+      iter_type\n       get(iter_type __in, iter_type __end, ios_base& __io,\n \t  ios_base::iostate& __err, double& __v) const\n       { return this->do_get(__in, __end, __io, __err, __v); }\n \n-      iter_type \n+      iter_type\n       get(iter_type __in, iter_type __end, ios_base& __io,\n \t  ios_base::iostate& __err, long double& __v) const\n       { return this->do_get(__in, __end, __io, __err, __v); }\n@@ -2132,22 +2132,22 @@ namespace std\n        *  @param  v  Value to format and insert.\n        *  @return  Iterator after reading.\n       */\n-      iter_type \n+      iter_type\n       get(iter_type __in, iter_type __end, ios_base& __io,\n \t  ios_base::iostate& __err, void*& __v) const\n-      { return this->do_get(__in, __end, __io, __err, __v); }      \n+      { return this->do_get(__in, __end, __io, __err, __v); }\n \n     protected:\n       /// Destructor.\n       virtual ~num_get() { }\n \n-      iter_type \n-      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&, \n+      iter_type\n+      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,\n \t\t       string& __xtrc) const;\n \n       template<typename _ValueT>\n-        iter_type \n-        _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&, \n+        iter_type\n+        _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,\n \t\t       _ValueT& __v) const;\n \n       //@{\n@@ -2165,49 +2165,49 @@ namespace std\n        *  @param  v  Value to format and insert.\n        *  @return  Iterator after reading.\n       */\n-      virtual iter_type \n+      virtual iter_type\n       do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;\n \n \n-      virtual iter_type \n+      virtual iter_type\n       do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, long&) const;\n \n-      virtual iter_type \n-      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, \n+      virtual iter_type\n+      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,\n \t      unsigned short&) const;\n \n-      virtual iter_type \n-      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, \n+      virtual iter_type\n+      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,\n \t     unsigned int&) const;\n \n-      virtual iter_type \n-      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, \n+      virtual iter_type\n+      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,\n \t     unsigned long&) const;\n \n-#ifdef _GLIBCXX_USE_LONG_LONG \n-      virtual iter_type \n-      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, \n+#ifdef _GLIBCXX_USE_LONG_LONG\n+      virtual iter_type\n+      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,\n \t     long long&) const;\n \n-      virtual iter_type \n-      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, \n+      virtual iter_type\n+      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,\n \t     unsigned long long&) const;\n #endif\n \n-      virtual iter_type \n-      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, \n+      virtual iter_type\n+      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,\n \t     float&) const;\n \n-      virtual iter_type \n-      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, \n+      virtual iter_type\n+      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,\n \t     double&) const;\n \n-      virtual iter_type \n-      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, \n+      virtual iter_type\n+      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,\n \t     long double&) const;\n \n-      virtual iter_type \n-      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, \n+      virtual iter_type\n+      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,\n \t     void*&) const;\n       //@}\n     };\n@@ -2234,8 +2234,8 @@ namespace std\n       // Types:\n       //@{\n       /// Public typedefs\n-      typedef _CharT       \tchar_type;\n-      typedef _OutIter     \titer_type;\n+      typedef _CharT\t\tchar_type;\n+      typedef _OutIter\t\titer_type;\n       //@}\n \n       /// Numpunct facet id.\n@@ -2248,7 +2248,7 @@ namespace std\n        *\n        *  @param refs  Passed to the base facet class.\n       */\n-      explicit \n+      explicit\n       num_put(size_t __refs = 0) : facet(__refs) { }\n \n       /**\n@@ -2266,7 +2266,7 @@ namespace std\n        *  @param  v  Value to format and insert.\n        *  @return  Iterator after writing.\n       */\n-      iter_type \n+      iter_type\n       put(iter_type __s, ios_base& __f, char_type __fill, bool __v) const\n       { return this->do_put(__s, __f, __fill, __v); }\n \n@@ -2308,22 +2308,22 @@ namespace std\n        *  @param  v  Value to format and insert.\n        *  @return  Iterator after writing.\n       */\n-      iter_type \n+      iter_type\n       put(iter_type __s, ios_base& __f, char_type __fill, long __v) const\n       { return this->do_put(__s, __f, __fill, __v); }\n \n-      iter_type \n-      put(iter_type __s, ios_base& __f, char_type __fill, \n+      iter_type\n+      put(iter_type __s, ios_base& __f, char_type __fill,\n \t  unsigned long __v) const\n       { return this->do_put(__s, __f, __fill, __v); }\n \n-#ifdef _GLIBCXX_USE_LONG_LONG \n-      iter_type \n+#ifdef _GLIBCXX_USE_LONG_LONG\n+      iter_type\n       put(iter_type __s, ios_base& __f, char_type __fill, long long __v) const\n       { return this->do_put(__s, __f, __fill, __v); }\n \n-      iter_type \n-      put(iter_type __s, ios_base& __f, char_type __fill, \n+      iter_type\n+      put(iter_type __s, ios_base& __f, char_type __fill,\n \t  unsigned long long __v) const\n       { return this->do_put(__s, __f, __fill, __v); }\n #endif\n@@ -2371,12 +2371,12 @@ namespace std\n        *  @param  v  Value to format and insert.\n        *  @return  Iterator after writing.\n       */\n-      iter_type \n+      iter_type\n       put(iter_type __s, ios_base& __f, char_type __fill, double __v) const\n       { return this->do_put(__s, __f, __fill, __v); }\n \n-      iter_type \n-      put(iter_type __s, ios_base& __f, char_type __fill, \n+      iter_type\n+      put(iter_type __s, ios_base& __f, char_type __fill,\n \t  long double __v) const\n       { return this->do_put(__s, __f, __fill, __v); }\n       //@}\n@@ -2396,15 +2396,15 @@ namespace std\n        *  @param  v  Value to format and insert.\n        *  @return  Iterator after writing.\n       */\n-      iter_type \n-      put(iter_type __s, ios_base& __f, char_type __fill, \n+      iter_type\n+      put(iter_type __s, ios_base& __f, char_type __fill,\n \t  const void* __v) const\n       { return this->do_put(__s, __f, __fill, __v); }\n \n     protected:\n       template<typename _ValueT>\n         iter_type\n-        _M_insert_float(iter_type, ios_base& __io, char_type __fill, \n+        _M_insert_float(iter_type, ios_base& __io, char_type __fill,\n \t\t\tchar __mod, _ValueT __v) const;\n \n       void\n@@ -2414,7 +2414,7 @@ namespace std\n \n       template<typename _ValueT>\n         iter_type\n-        _M_insert_int(iter_type, ios_base& __io, char_type __fill, \n+        _M_insert_int(iter_type, ios_base& __io, char_type __fill,\n \t\t      _ValueT __v) const;\n \n       void\n@@ -2423,11 +2423,11 @@ namespace std\n \t\t   char_type* __cs, int& __len) const;\n \n       void\n-      _M_pad(char_type __fill, streamsize __w, ios_base& __io, \n+      _M_pad(char_type __fill, streamsize __w, ios_base& __io,\n \t     char_type* __new, const char_type* __cs, int& __len) const;\n \n       /// Destructor.\n-      virtual \n+      virtual\n       ~num_put() { };\n \n       //@{\n@@ -2444,30 +2444,30 @@ namespace std\n        *  @param  v  Value to format and insert.\n        *  @return  Iterator after writing.\n       */\n-      virtual iter_type \n+      virtual iter_type\n       do_put(iter_type, ios_base&, char_type __fill, bool __v) const;\n \n-      virtual iter_type \n+      virtual iter_type\n       do_put(iter_type, ios_base&, char_type __fill, long __v) const;\n \n-      virtual iter_type \n+      virtual iter_type\n       do_put(iter_type, ios_base&, char_type __fill, unsigned long) const;\n \n-#ifdef _GLIBCXX_USE_LONG_LONG \n-      virtual iter_type \n+#ifdef _GLIBCXX_USE_LONG_LONG\n+      virtual iter_type\n       do_put(iter_type, ios_base&, char_type __fill, long long __v) const;\n \n       virtual iter_type\n       do_put(iter_type, ios_base&, char_type __fill, unsigned long long) const;\n #endif\n \n-      virtual iter_type \n+      virtual iter_type\n       do_put(iter_type, ios_base&, char_type __fill, double __v) const;\n \n-      virtual iter_type \n+      virtual iter_type\n       do_put(iter_type, ios_base&, char_type __fill, long double __v) const;\n \n-      virtual iter_type \n+      virtual iter_type\n       do_put(iter_type, ios_base&, char_type __fill, const void* __v) const;\n       //@}\n     };\n@@ -2495,18 +2495,18 @@ namespace std\n       // Types:\n       //@{\n       /// Public typedefs\n-      typedef _CharT               \tchar_type;\n-      typedef basic_string<_CharT> \tstring_type;\n+      typedef _CharT\t\t\tchar_type;\n+      typedef basic_string<_CharT>\tstring_type;\n       //@}\n \n     protected:\n       // Underlying \"C\" library locale information saved from\n       // initialization, needed by collate_byname as well.\n       __c_locale\t\t\t_M_c_locale_collate;\n- \n+\n     public:\n       /// Numpunct facet id.\n-      static locale::id \t\tid;\n+      static locale::id\t\t\tid;\n \n       /**\n        *  @brief  Constructor performs initialization.\n@@ -2515,7 +2515,7 @@ namespace std\n        *\n        *  @param refs  Passed to the base facet class.\n       */\n-      explicit \n+      explicit\n       collate(size_t __refs = 0)\n       : facet(__refs)\n       { _M_c_locale_collate = _S_get_c_locale(); }\n@@ -2529,8 +2529,8 @@ namespace std\n        *  @param cloc  The \"C\" locale.\n        *  @param refs  Passed to the base facet class.\n       */\n-      explicit \n-      collate(__c_locale __cloc, size_t __refs = 0) \n+      explicit\n+      collate(__c_locale __cloc, size_t __refs = 0)\n       : facet(__refs)\n       { _M_c_locale_collate = _S_clone_c_locale(__cloc); }\n \n@@ -2546,7 +2546,7 @@ namespace std\n        *  @param hi2  End of string 2.\n        *  @return  1 if string1 > string2, -1 if string1 < string2, else 0.\n       */\n-      int \n+      int\n       compare(const _CharT* __lo1, const _CharT* __hi1,\n \t      const _CharT* __lo2, const _CharT* __hi2) const\n       { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }\n@@ -2565,7 +2565,7 @@ namespace std\n        *  @param hi  End of string.\n        *  @return  Transformed string_type.\n       */\n-      string_type \n+      string_type\n       transform(const _CharT* __lo, const _CharT* __hi) const\n       { return this->do_transform(__lo, __hi); }\n \n@@ -2579,10 +2579,10 @@ namespace std\n        *  @param hi  End of string.\n        *  @return  Hash value.\n       */\n-      long \n+      long\n       hash(const _CharT* __lo, const _CharT* __hi) const\n       { return this->do_hash(__lo, __hi); }\n-      \n+\n       // Used to abstract out _CharT bits in virtual member functions, below.\n       int\n       _M_compare(const _CharT*, const _CharT*) const;\n@@ -2593,7 +2593,7 @@ namespace std\n   protected:\n       /// Destructor.\n       virtual\n-      ~collate() \n+      ~collate()\n       { _S_destroy_c_locale(_M_c_locale_collate); }\n \n       /**\n@@ -2608,7 +2608,7 @@ namespace std\n        *  @param hi2  End of string 2.\n        *  @return  1 if string1 > string2, -1 if string1 < string2, else 0.\n       */\n-      virtual int  \n+      virtual int\n       do_compare(const _CharT* __lo1, const _CharT* __hi1,\n \t\t const _CharT* __lo2, const _CharT* __hi2) const;\n \n@@ -2624,7 +2624,7 @@ namespace std\n        *  @param hi2  End of string 2.\n        *  @return  1 if string1 > string2, -1 if string1 < string2, else 0.\n       */\n-      virtual string_type \n+      virtual string_type\n       do_transform(const _CharT* __lo, const _CharT* __hi) const;\n \n       /**\n@@ -2637,7 +2637,7 @@ namespace std\n        *  @param hi  End of string.\n        *  @return  Hash value.\n       */\n-      virtual long   \n+      virtual long\n       do_hash(const _CharT* __lo, const _CharT* __hi) const;\n     };\n \n@@ -2646,7 +2646,7 @@ namespace std\n \n   // Specializations.\n   template<>\n-    int \n+    int\n     collate<char>::_M_compare(const char*, const char*) const;\n \n   template<>\n@@ -2655,7 +2655,7 @@ namespace std\n \n #ifdef _GLIBCXX_USE_WCHAR_T\n   template<>\n-    int \n+    int\n     collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const;\n \n   template<>\n@@ -2673,19 +2673,19 @@ namespace std\n       typedef basic_string<_CharT> string_type;\n       //@}\n \n-      explicit \n+      explicit\n       collate_byname(const char* __s, size_t __refs = 0)\n-      : collate<_CharT>(__refs) \n-      { \n+      : collate<_CharT>(__refs)\n+      {\n \tif (std::strcmp(__s, \"C\") != 0 && std::strcmp(__s, \"POSIX\") != 0)\n \t  {\n \t    this->_S_destroy_c_locale(this->_M_c_locale_collate);\n-\t    this->_S_create_c_locale(this->_M_c_locale_collate, __s); \n+\t    this->_S_create_c_locale(this->_M_c_locale_collate, __s);\n \t  }\n       }\n \n     protected:\n-      virtual   \n+      virtual\n       ~collate_byname() { }\n     };\n \n@@ -2706,82 +2706,82 @@ namespace std\n     struct __timepunct_cache : public locale::facet\n     {\n       // List of all known timezones, with GMT first.\n-      static const _CharT* \t\t_S_timezones[14];\n+      static const _CharT*\t\t_S_timezones[14];\n \n-      const _CharT* \t\t\t_M_date_format;\n-      const _CharT* \t\t\t_M_date_era_format;\n-      const _CharT* \t\t\t_M_time_format;\n-      const _CharT* \t\t\t_M_time_era_format;\n+      const _CharT*\t\t\t_M_date_format;\n+      const _CharT*\t\t\t_M_date_era_format;\n+      const _CharT*\t\t\t_M_time_format;\n+      const _CharT*\t\t\t_M_time_era_format;\n       const _CharT*\t\t\t_M_date_time_format;\n       const _CharT*\t\t\t_M_date_time_era_format;\n-      const _CharT* \t\t\t_M_am;\n-      const _CharT* \t\t\t_M_pm;\n+      const _CharT*\t\t\t_M_am;\n+      const _CharT*\t\t\t_M_pm;\n       const _CharT*\t\t\t_M_am_pm_format;\n \n       // Day names, starting with \"C\"'s Sunday.\n-      const _CharT*  \t\t\t_M_day1;\n-      const _CharT*  \t\t\t_M_day2;\n-      const _CharT*  \t\t\t_M_day3;\n-      const _CharT*  \t\t\t_M_day4;\n-      const _CharT*  \t\t\t_M_day5;\n-      const _CharT*  \t\t\t_M_day6;\n-      const _CharT*  \t\t\t_M_day7;\n+      const _CharT*\t\t\t_M_day1;\n+      const _CharT*\t\t\t_M_day2;\n+      const _CharT*\t\t\t_M_day3;\n+      const _CharT*\t\t\t_M_day4;\n+      const _CharT*\t\t\t_M_day5;\n+      const _CharT*\t\t\t_M_day6;\n+      const _CharT*\t\t\t_M_day7;\n \n       // Abbreviated day names, starting with \"C\"'s Sun.\n-      const _CharT*  \t\t\t_M_aday1;\n-      const _CharT*  \t\t\t_M_aday2;\n-      const _CharT*  \t\t\t_M_aday3;\n-      const _CharT*  \t\t\t_M_aday4;\n-      const _CharT*  \t\t\t_M_aday5;\n-      const _CharT*  \t\t\t_M_aday6;\n-      const _CharT*  \t\t\t_M_aday7;\n+      const _CharT*\t\t\t_M_aday1;\n+      const _CharT*\t\t\t_M_aday2;\n+      const _CharT*\t\t\t_M_aday3;\n+      const _CharT*\t\t\t_M_aday4;\n+      const _CharT*\t\t\t_M_aday5;\n+      const _CharT*\t\t\t_M_aday6;\n+      const _CharT*\t\t\t_M_aday7;\n \n       // Month names, starting with \"C\"'s January.\n-      const _CharT*  \t\t\t_M_month01;\n-      const _CharT*  \t\t\t_M_month02;\n-      const _CharT*  \t\t\t_M_month03;\n-      const _CharT*  \t\t\t_M_month04;\n-      const _CharT*  \t\t\t_M_month05;\n-      const _CharT*  \t\t\t_M_month06;\n-      const _CharT*  \t\t\t_M_month07;\n-      const _CharT*  \t\t\t_M_month08;\n-      const _CharT*  \t\t\t_M_month09;\n-      const _CharT*  \t\t\t_M_month10;\n-      const _CharT*  \t\t\t_M_month11;\n-      const _CharT*  \t\t\t_M_month12;\n+      const _CharT*\t\t\t_M_month01;\n+      const _CharT*\t\t\t_M_month02;\n+      const _CharT*\t\t\t_M_month03;\n+      const _CharT*\t\t\t_M_month04;\n+      const _CharT*\t\t\t_M_month05;\n+      const _CharT*\t\t\t_M_month06;\n+      const _CharT*\t\t\t_M_month07;\n+      const _CharT*\t\t\t_M_month08;\n+      const _CharT*\t\t\t_M_month09;\n+      const _CharT*\t\t\t_M_month10;\n+      const _CharT*\t\t\t_M_month11;\n+      const _CharT*\t\t\t_M_month12;\n \n       // Abbreviated month names, starting with \"C\"'s Jan.\n-      const _CharT*  \t\t\t_M_amonth01;\n-      const _CharT*  \t\t\t_M_amonth02;\n-      const _CharT*  \t\t\t_M_amonth03;\n-      const _CharT*  \t\t\t_M_amonth04;\n-      const _CharT*  \t\t\t_M_amonth05;\n-      const _CharT*  \t\t\t_M_amonth06;\n-      const _CharT*  \t\t\t_M_amonth07;\n-      const _CharT*  \t\t\t_M_amonth08;\n-      const _CharT*  \t\t\t_M_amonth09;\n-      const _CharT*  \t\t\t_M_amonth10;\n-      const _CharT*  \t\t\t_M_amonth11;\n-      const _CharT*  \t\t\t_M_amonth12;\n+      const _CharT*\t\t\t_M_amonth01;\n+      const _CharT*\t\t\t_M_amonth02;\n+      const _CharT*\t\t\t_M_amonth03;\n+      const _CharT*\t\t\t_M_amonth04;\n+      const _CharT*\t\t\t_M_amonth05;\n+      const _CharT*\t\t\t_M_amonth06;\n+      const _CharT*\t\t\t_M_amonth07;\n+      const _CharT*\t\t\t_M_amonth08;\n+      const _CharT*\t\t\t_M_amonth09;\n+      const _CharT*\t\t\t_M_amonth10;\n+      const _CharT*\t\t\t_M_amonth11;\n+      const _CharT*\t\t\t_M_amonth12;\n \n       bool\t\t\t\t_M_allocated;\n \n-      __timepunct_cache(size_t __refs = 0) : facet(__refs), \n+      __timepunct_cache(size_t __refs = 0) : facet(__refs),\n       _M_date_format(NULL), _M_date_era_format(NULL), _M_time_format(NULL),\n-      _M_time_era_format(NULL), _M_date_time_format(NULL), \n-      _M_date_time_era_format(NULL), _M_am(NULL), _M_pm(NULL), \n-      _M_am_pm_format(NULL), _M_day1(NULL), _M_day2(NULL), _M_day3(NULL), \n-      _M_day4(NULL), _M_day5(NULL), _M_day6(NULL), _M_day7(NULL), \n-      _M_aday1(NULL), _M_aday2(NULL), _M_aday3(NULL), _M_aday4(NULL), \n+      _M_time_era_format(NULL), _M_date_time_format(NULL),\n+      _M_date_time_era_format(NULL), _M_am(NULL), _M_pm(NULL),\n+      _M_am_pm_format(NULL), _M_day1(NULL), _M_day2(NULL), _M_day3(NULL),\n+      _M_day4(NULL), _M_day5(NULL), _M_day6(NULL), _M_day7(NULL),\n+      _M_aday1(NULL), _M_aday2(NULL), _M_aday3(NULL), _M_aday4(NULL),\n       _M_aday5(NULL), _M_aday6(NULL), _M_aday7(NULL), _M_month01(NULL),\n-      _M_month02(NULL), _M_month03(NULL), _M_month04(NULL), _M_month05(NULL), \n-      _M_month06(NULL), _M_month07(NULL), _M_month08(NULL), _M_month09(NULL), \n+      _M_month02(NULL), _M_month03(NULL), _M_month04(NULL), _M_month05(NULL),\n+      _M_month06(NULL), _M_month07(NULL), _M_month08(NULL), _M_month09(NULL),\n       _M_month10(NULL), _M_month11(NULL), _M_month12(NULL), _M_amonth01(NULL),\n-      _M_amonth02(NULL), _M_amonth03(NULL), _M_amonth04(NULL), \n-      _M_amonth05(NULL), _M_amonth06(NULL), _M_amonth07(NULL), \n-      _M_amonth08(NULL), _M_amonth09(NULL), _M_amonth10(NULL), \n+      _M_amonth02(NULL), _M_amonth03(NULL), _M_amonth04(NULL),\n+      _M_amonth05(NULL), _M_amonth06(NULL), _M_amonth07(NULL),\n+      _M_amonth08(NULL), _M_amonth09(NULL), _M_amonth10(NULL),\n       _M_amonth11(NULL), _M_amonth12(NULL), _M_allocated(false)\n-      { } \n+      { }\n \n       ~__timepunct_cache();\n \n@@ -2799,12 +2799,12 @@ namespace std\n     }\n \n   // Specializations.\n-  template<> \n+  template<>\n     const char*\n     __timepunct_cache<char>::_S_timezones[14];\n \n #ifdef _GLIBCXX_USE_WCHAR_T\n-  template<> \n+  template<>\n     const wchar_t*\n     __timepunct_cache<wchar_t>::_S_timezones[14];\n #endif\n@@ -2818,8 +2818,8 @@ namespace std\n     {\n     public:\n       // Types:\n-      typedef _CharT          \t\t__char_type;\n-      typedef basic_string<_CharT> \t__string_type;\n+      typedef _CharT\t\t\t__char_type;\n+      typedef basic_string<_CharT>\t__string_type;\n       typedef __timepunct_cache<_CharT>\t__cache_type;\n \n     protected:\n@@ -2829,12 +2829,12 @@ namespace std\n \n     public:\n       /// Numpunct facet id.\n-      static locale::id \t\tid;\n+      static locale::id\t\t\tid;\n \n-      explicit \n+      explicit\n       __timepunct(size_t __refs = 0);\n \n-      explicit \n+      explicit\n       __timepunct(__cache_type* __cache, size_t __refs = 0);\n \n       /**\n@@ -2847,47 +2847,47 @@ namespace std\n        *  @param s  The name of a locale.\n        *  @param refs  Passed to the base facet class.\n       */\n-      explicit \n+      explicit\n       __timepunct(__c_locale __cloc, const char* __s, size_t __refs = 0);\n \n       void\n-      _M_put(_CharT* __s, size_t __maxlen, const _CharT* __format, \n+      _M_put(_CharT* __s, size_t __maxlen, const _CharT* __format,\n \t     const tm* __tm) const;\n \n       void\n       _M_date_formats(const _CharT** __date) const\n       {\n \t// Always have default first.\n \t__date[0] = _M_data->_M_date_format;\n-\t__date[1] = _M_data->_M_date_era_format;\t\n+\t__date[1] = _M_data->_M_date_era_format;\n       }\n \n       void\n       _M_time_formats(const _CharT** __time) const\n       {\n \t// Always have default first.\n \t__time[0] = _M_data->_M_time_format;\n-\t__time[1] = _M_data->_M_time_era_format;\t\n+\t__time[1] = _M_data->_M_time_era_format;\n       }\n \n       void\n       _M_ampm(const _CharT** __ampm) const\n-      { \n+      {\n \t__ampm[0] = _M_data->_M_am;\n \t__ampm[1] = _M_data->_M_pm;\n-      }      \n+      }\n \n       void\n       _M_date_time_formats(const _CharT** __dt) const\n       {\n \t// Always have default first.\n \t__dt[0] = _M_data->_M_date_time_format;\n-\t__dt[1] = _M_data->_M_date_time_era_format;\t\n+\t__dt[1] = _M_data->_M_date_time_era_format;\n       }\n \n       void\n       _M_days(const _CharT** __days) const\n-      { \n+      {\n \t__days[0] = _M_data->_M_day1;\n \t__days[1] = _M_data->_M_day2;\n \t__days[2] = _M_data->_M_day3;\n@@ -2899,7 +2899,7 @@ namespace std\n \n       void\n       _M_days_abbreviated(const _CharT** __days) const\n-      { \n+      {\n \t__days[0] = _M_data->_M_aday1;\n \t__days[1] = _M_data->_M_aday2;\n \t__days[2] = _M_data->_M_aday3;\n@@ -2911,7 +2911,7 @@ namespace std\n \n       void\n       _M_months(const _CharT** __months) const\n-      { \n+      {\n \t__months[0] = _M_data->_M_month01;\n \t__months[1] = _M_data->_M_month02;\n \t__months[2] = _M_data->_M_month03;\n@@ -2928,7 +2928,7 @@ namespace std\n \n       void\n       _M_months_abbreviated(const _CharT** __months) const\n-      { \n+      {\n \t__months[0] = _M_data->_M_amonth01;\n \t__months[1] = _M_data->_M_amonth02;\n \t__months[2] = _M_data->_M_amonth03;\n@@ -2944,19 +2944,19 @@ namespace std\n       }\n \n     protected:\n-      virtual \n+      virtual\n       ~__timepunct();\n \n       // For use at construction time only.\n-      void \n+      void\n       _M_initialize_timepunct(__c_locale __cloc = NULL);\n     };\n \n   template<typename _CharT>\n     locale::id __timepunct<_CharT>::id;\n \n   // Specializations.\n-  template<> \n+  template<>\n     void\n     __timepunct<char>::_M_initialize_timepunct(__c_locale __cloc);\n \n@@ -2965,13 +2965,13 @@ namespace std\n     __timepunct<char>::_M_put(char*, size_t, const char*, const tm*) const;\n \n #ifdef _GLIBCXX_USE_WCHAR_T\n-  template<> \n+  template<>\n     void\n     __timepunct<wchar_t>::_M_initialize_timepunct(__c_locale __cloc);\n \n   template<>\n     void\n-    __timepunct<wchar_t>::_M_put(wchar_t*, size_t, const wchar_t*, \n+    __timepunct<wchar_t>::_M_put(wchar_t*, size_t, const wchar_t*,\n \t\t\t\t const tm*) const;\n #endif\n \n@@ -2997,13 +2997,13 @@ namespace std\n       // Types:\n       //@{\n       /// Public typedefs\n-      typedef _CharT     \t\tchar_type;\n-      typedef _InIter    \t\titer_type;\n+      typedef _CharT\t\t\tchar_type;\n+      typedef _InIter\t\t\titer_type;\n       //@}\n-      typedef basic_string<_CharT> \t__string_type;\n+      typedef basic_string<_CharT>\t__string_type;\n \n       /// Numpunct facet id.\n-      static locale::id \t\tid;\n+      static locale::id\t\t\tid;\n \n       /**\n        *  @brief  Constructor performs initialization.\n@@ -3012,8 +3012,8 @@ namespace std\n        *\n        *  @param refs  Passed to the base facet class.\n       */\n-      explicit \n-      time_get(size_t __refs = 0) \n+      explicit\n+      time_get(size_t __refs = 0)\n       : facet (__refs) { }\n \n       /**\n@@ -3023,13 +3023,13 @@ namespace std\n        *  preferred ordering if the format \"x\" given to time_put::put() only\n        *  uses month, day, and year.  If the format \"x\" for the associated\n        *  locale uses other fields, this function returns\n-       *  timebase::dateorder::noorder.  \n+       *  timebase::dateorder::noorder.\n        *\n        *  NOTE: The library always returns noorder at the moment.\n        *\n        *  @return  A member of timebase::dateorder.\n       */\n-      dateorder \n+      dateorder\n       date_order()  const\n       { return this->do_date_order(); }\n \n@@ -3053,8 +3053,8 @@ namespace std\n        *  @param  tm  Pointer to struct tm to fill in.\n        *  @return  Iterator to first char beyond time string.\n       */\n-      iter_type \n-      get_time(iter_type __beg, iter_type __end, ios_base& __io, \n+      iter_type\n+      get_time(iter_type __beg, iter_type __end, ios_base& __io,\n \t       ios_base::iostate& __err, tm* __tm)  const\n       { return this->do_get_time(__beg, __end, __io, __err, __tm); }\n \n@@ -3078,7 +3078,7 @@ namespace std\n        *  @param  tm  Pointer to struct tm to fill in.\n        *  @return  Iterator to first char beyond date string.\n       */\n-      iter_type \n+      iter_type\n       get_date(iter_type __beg, iter_type __end, ios_base& __io,\n \t       ios_base::iostate& __err, tm* __tm)  const\n       { return this->do_get_date(__beg, __end, __io, __err, __tm); }\n@@ -3106,7 +3106,7 @@ namespace std\n        *  @param  tm  Pointer to struct tm to fill in.\n        *  @return  Iterator to first char beyond weekday name.\n       */\n-      iter_type \n+      iter_type\n       get_weekday(iter_type __beg, iter_type __end, ios_base& __io,\n \t\t  ios_base::iostate& __err, tm* __tm) const\n       { return this->do_get_weekday(__beg, __end, __io, __err, __tm); }\n@@ -3135,8 +3135,8 @@ namespace std\n        *  @param  tm  Pointer to struct tm to fill in.\n        *  @return  Iterator to first char beyond month name.\n       */\n-      iter_type \n-      get_monthname(iter_type __beg, iter_type __end, ios_base& __io, \n+      iter_type\n+      get_monthname(iter_type __beg, iter_type __end, ios_base& __io,\n \t\t    ios_base::iostate& __err, tm* __tm) const\n       { return this->do_get_monthname(__beg, __end, __io, __err, __tm); }\n \n@@ -3161,14 +3161,14 @@ namespace std\n        *  @param  tm  Pointer to struct tm to fill in.\n        *  @return  Iterator to first char beyond year.\n       */\n-      iter_type \n+      iter_type\n       get_year(iter_type __beg, iter_type __end, ios_base& __io,\n \t       ios_base::iostate& __err, tm* __tm) const\n       { return this->do_get_year(__beg, __end, __io, __err, __tm); }\n \n     protected:\n       /// Destructor.\n-      virtual \n+      virtual\n       ~time_get() { }\n \n       /**\n@@ -3181,7 +3181,7 @@ namespace std\n        *\n        *  @return  A member of timebase::dateorder.\n       */\n-      virtual dateorder \n+      virtual dateorder\n       do_date_order() const;\n \n       /**\n@@ -3199,7 +3199,7 @@ namespace std\n        *  @param  tm  Pointer to struct tm to fill in.\n        *  @return  Iterator to first char beyond time string.\n       */\n-      virtual iter_type \n+      virtual iter_type\n       do_get_time(iter_type __beg, iter_type __end, ios_base& __io,\n \t\t  ios_base::iostate& __err, tm* __tm) const;\n \n@@ -3218,7 +3218,7 @@ namespace std\n        *  @param  tm  Pointer to struct tm to fill in.\n        *  @return  Iterator to first char beyond date string.\n       */\n-      virtual iter_type \n+      virtual iter_type\n       do_get_date(iter_type __beg, iter_type __end, ios_base& __io,\n \t\t  ios_base::iostate& __err, tm* __tm) const;\n \n@@ -3237,7 +3237,7 @@ namespace std\n        *  @param  tm  Pointer to struct tm to fill in.\n        *  @return  Iterator to first char beyond weekday name.\n       */\n-      virtual iter_type \n+      virtual iter_type\n       do_get_weekday(iter_type __beg, iter_type __end, ios_base&,\n \t\t     ios_base::iostate& __err, tm* __tm) const;\n \n@@ -3256,8 +3256,8 @@ namespace std\n        *  @param  tm  Pointer to struct tm to fill in.\n        *  @return  Iterator to first char beyond month name.\n       */\n-      virtual iter_type \n-      do_get_monthname(iter_type __beg, iter_type __end, ios_base&, \n+      virtual iter_type\n+      do_get_monthname(iter_type __beg, iter_type __end, ios_base&,\n \t\t       ios_base::iostate& __err, tm* __tm) const;\n \n       /**\n@@ -3275,29 +3275,29 @@ namespace std\n        *  @param  tm  Pointer to struct tm to fill in.\n        *  @return  Iterator to first char beyond year.\n       */\n-      virtual iter_type \n+      virtual iter_type\n       do_get_year(iter_type __beg, iter_type __end, ios_base& __io,\n \t\t  ios_base::iostate& __err, tm* __tm) const;\n \n       // Extract numeric component of length __len.\n       void\n       _M_extract_num(iter_type& __beg, iter_type& __end, int& __member,\n \t\t     int __min, int __max, size_t __len,\n-\t\t     const ctype<_CharT>& __ctype, \n+\t\t     const ctype<_CharT>& __ctype,\n \t\t     ios_base::iostate& __err) const;\n-      \n+\n       // Extract day or month name, or any unique array of string\n       // literals in a const _CharT* array.\n       void\n       _M_extract_name(iter_type& __beg, iter_type& __end, int& __member,\n-\t\t      const _CharT** __names, size_t __indexlen, \n-\t\t      const ctype<_CharT>& __ctype, \n+\t\t      const _CharT** __names, size_t __indexlen,\n+\t\t      const ctype<_CharT>& __ctype,\n \t\t      ios_base::iostate& __err) const;\n \n       // Extract on a component-by-component basis, via __format argument.\n       void\n       _M_extract_via_format(iter_type& __beg, iter_type& __end, ios_base& __io,\n-\t\t\t    ios_base::iostate& __err, tm* __tm, \n+\t\t\t    ios_base::iostate& __err, tm* __tm,\n \t\t\t    const _CharT* __format) const;\n     };\n \n@@ -3309,15 +3309,15 @@ namespace std\n     {\n     public:\n       // Types:\n-      typedef _CharT     \t\tchar_type;\n-      typedef _InIter    \t\titer_type;\n+      typedef _CharT\t\t\tchar_type;\n+      typedef _InIter\t\t\titer_type;\n \n-      explicit \n-      time_get_byname(const char*, size_t __refs = 0) \n+      explicit\n+      time_get_byname(const char*, size_t __refs = 0)\n       : time_get<_CharT, _InIter>(__refs) { }\n \n     protected:\n-      virtual \n+      virtual\n       ~time_get_byname() { }\n     };\n \n@@ -3339,12 +3339,12 @@ namespace std\n       // Types:\n       //@{\n       /// Public typedefs\n-      typedef _CharT     \t\tchar_type;\n-      typedef _OutIter   \t\titer_type;\n+      typedef _CharT\t\t\tchar_type;\n+      typedef _OutIter\t\t\titer_type;\n       //@}\n \n       /// Numpunct facet id.\n-      static locale::id \t     \tid;\n+      static locale::id\t\t\tid;\n \n       /**\n        *  @brief  Constructor performs initialization.\n@@ -3353,8 +3353,8 @@ namespace std\n        *\n        *  @param refs  Passed to the base facet class.\n       */\n-      explicit \n-      time_put(size_t __refs = 0) \n+      explicit\n+      time_put(size_t __refs = 0)\n       : facet(__refs) { }\n \n       /**\n@@ -3372,8 +3372,8 @@ namespace std\n        *  @param  end  End of format string.\n        *  @return  Iterator after writing.\n        */\n-      iter_type \n-      put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm, \n+      iter_type\n+      put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,\n \t  const _CharT* __beg, const _CharT* __end) const;\n \n       /**\n@@ -3392,14 +3392,14 @@ namespace std\n        *  @param  mod  Optional modifier char.\n        *  @return  Iterator after writing.\n        */\n-      iter_type \n+      iter_type\n       put(iter_type __s, ios_base& __io, char_type __fill,\n \t  const tm* __tm, char __format, char __mod = 0) const\n       { return this->do_put(__s, __io, __fill, __tm, __format, __mod); }\n \n     protected:\n       /// Destructor.\n-      virtual \n+      virtual\n       ~time_put()\n       { }\n \n@@ -3419,8 +3419,8 @@ namespace std\n        *  @param  mod  Optional modifier char.\n        *  @return  Iterator after writing.\n        */\n-      virtual iter_type \n-      do_put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm, \n+      virtual iter_type\n+      do_put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,\n \t     char __format, char __mod) const;\n     };\n \n@@ -3432,16 +3432,16 @@ namespace std\n     {\n     public:\n       // Types:\n-      typedef _CharT     \t\tchar_type;\n-      typedef _OutIter   \t\titer_type;\n+      typedef _CharT\t\t\tchar_type;\n+      typedef _OutIter\t\t\titer_type;\n \n-      explicit \n-      time_put_byname(const char*, size_t __refs = 0) \n-      : time_put<_CharT, _OutIter>(__refs) \n+      explicit\n+      time_put_byname(const char*, size_t __refs = 0)\n+      : time_put<_CharT, _OutIter>(__refs)\n       { };\n \n     protected:\n-      virtual \n+      virtual\n       ~time_put_byname() { }\n     };\n \n@@ -3466,33 +3466,33 @@ namespace std\n \n     // Construct and return valid pattern consisting of some combination of:\n     // space none symbol sign value\n-    static pattern \n+    static pattern\n     _S_construct_pattern(char __precedes, char __space, char __posn);\n   };\n \n   template<typename _CharT>\n     struct __moneypunct_cache : public locale::facet\n     {\n-      const char* \t\t\t_M_grouping;\n+      const char*\t\t\t_M_grouping;\n       bool\t\t\t\t_M_use_grouping;\n-      _CharT \t\t\t\t_M_decimal_point;\n-      _CharT \t\t\t\t_M_thousands_sep;\n-      const _CharT* \t\t\t_M_curr_symbol;\n+      _CharT\t\t\t\t_M_decimal_point;\n+      _CharT\t\t\t\t_M_thousands_sep;\n+      const _CharT*\t\t\t_M_curr_symbol;\n       const _CharT*\t\t\t_M_positive_sign;\n       const _CharT*\t\t\t_M_negative_sign;\n-      int \t\t\t\t_M_frac_digits;\n-      money_base::pattern \t\t_M_pos_format;\n-      money_base::pattern \t        _M_neg_format;\n+      int\t\t\t\t_M_frac_digits;\n+      money_base::pattern\t\t_M_pos_format;\n+      money_base::pattern\t        _M_neg_format;\n \n       bool\t\t\t\t_M_allocated;\n \n-      __moneypunct_cache(size_t __refs = 0) : facet(__refs), \n-      _M_grouping(NULL), _M_use_grouping(false), _M_decimal_point(_CharT()), \n+      __moneypunct_cache(size_t __refs = 0) : facet(__refs),\n+      _M_grouping(NULL), _M_use_grouping(false), _M_decimal_point(_CharT()),\n       _M_thousands_sep(_CharT()), _M_curr_symbol(NULL), _M_positive_sign(NULL),\n-      _M_negative_sign(NULL), _M_frac_digits(0), \n-      _M_pos_format(money_base::pattern()), \n+      _M_negative_sign(NULL), _M_frac_digits(0),\n+      _M_pos_format(money_base::pattern()),\n       _M_neg_format(money_base::pattern()), _M_allocated(false)\n-      { } \n+      { }\n \n       ~__moneypunct_cache();\n \n@@ -3522,8 +3522,8 @@ namespace std\n       // Types:\n       //@{\n       /// Public typedefs\n-      typedef _CharT \t\t       \tchar_type;\n-      typedef basic_string<_CharT> \tstring_type;\n+      typedef _CharT\t\t\tchar_type;\n+      typedef basic_string<_CharT>\tstring_type;\n       //@}\n       typedef __moneypunct_cache<_CharT>\t__cache_type;\n \n@@ -3533,9 +3533,9 @@ namespace std\n     public:\n       /// This value is provided by the standard, but no reason for its\n       /// existence.\n-      static const bool \t\tintl = _Intl;\n+      static const bool\t\t\tintl = _Intl;\n       /// Numpunct facet id.\n-      static locale::id \t\tid;\n+      static locale::id\t\t\tid;\n \n       /**\n        *  @brief  Constructor performs initialization.\n@@ -3544,7 +3544,7 @@ namespace std\n        *\n        *  @param refs  Passed to the base facet class.\n       */\n-      explicit \n+      explicit\n       moneypunct(size_t __refs = 0) : facet(__refs), _M_data(NULL)\n       { _M_initialize_moneypunct(); }\n \n@@ -3556,8 +3556,8 @@ namespace std\n        *  @param cache  Cache for optimization.\n        *  @param refs  Passed to the base facet class.\n       */\n-      explicit \n-      moneypunct(__cache_type* __cache, size_t __refs = 0) \n+      explicit\n+      moneypunct(__cache_type* __cache, size_t __refs = 0)\n       : facet(__refs), _M_data(__cache)\n       { _M_initialize_moneypunct(); }\n \n@@ -3571,8 +3571,8 @@ namespace std\n        *  @param s  The name of a locale.\n        *  @param refs  Passed to the base facet class.\n       */\n-      explicit \n-      moneypunct(__c_locale __cloc, const char* __s, size_t __refs = 0) \n+      explicit\n+      moneypunct(__c_locale __cloc, const char* __s, size_t __refs = 0)\n       : facet(__refs), _M_data(NULL)\n       { _M_initialize_moneypunct(__cloc, __s); }\n \n@@ -3588,7 +3588,7 @@ namespace std\n       char_type\n       decimal_point() const\n       { return this->do_decimal_point(); }\n-      \n+\n       /**\n        *  @brief  Return thousands separator character.\n        *\n@@ -3601,7 +3601,7 @@ namespace std\n       char_type\n       thousands_sep() const\n       { return this->do_thousands_sep(); }\n-      \n+\n       /**\n        *  @brief  Return grouping specification.\n        *\n@@ -3627,7 +3627,7 @@ namespace std\n        *\n        *  @return  string representing grouping specification.\n       */\n-      string \n+      string\n       grouping() const\n       { return this->do_grouping(); }\n \n@@ -3640,7 +3640,7 @@ namespace std\n        *\n        *  @return  @a string_type representing a currency symbol.\n       */\n-      string_type  \n+      string_type\n       curr_symbol() const\n       { return this->do_curr_symbol(); }\n \n@@ -3657,7 +3657,7 @@ namespace std\n        *\n        *  @return  @a string_type representing a positive sign.\n       */\n-      string_type  \n+      string_type\n       positive_sign() const\n       { return this->do_positive_sign(); }\n \n@@ -3674,7 +3674,7 @@ namespace std\n        *\n        *  @return  @a string_type representing a negative sign.\n       */\n-      string_type  \n+      string_type\n       negative_sign() const\n       { return this->do_negative_sign(); }\n \n@@ -3729,14 +3729,14 @@ namespace std\n       pos_format() const\n       { return this->do_pos_format(); }\n \n-      pattern      \n+      pattern\n       neg_format() const\n       { return this->do_neg_format(); }\n       //@}\n \n     protected:\n       /// Destructor.\n-      virtual \n+      virtual\n       ~moneypunct();\n \n       /**\n@@ -3750,7 +3750,7 @@ namespace std\n       virtual char_type\n       do_decimal_point() const\n       { return _M_data->_M_decimal_point; }\n-      \n+\n       /**\n        *  @brief  Return thousands separator character.\n        *\n@@ -3762,7 +3762,7 @@ namespace std\n       virtual char_type\n       do_thousands_sep() const\n       { return _M_data->_M_thousands_sep; }\n-      \n+\n       /**\n        *  @brief  Return grouping specification.\n        *\n@@ -3772,7 +3772,7 @@ namespace std\n        *\n        *  @return  String representing grouping specification.\n       */\n-      virtual string \n+      virtual string\n       do_grouping() const\n       { return _M_data->_M_grouping; }\n \n@@ -3785,7 +3785,7 @@ namespace std\n        *\n        *  @return  @a string_type representing a currency symbol.\n       */\n-      virtual string_type  \n+      virtual string_type\n       do_curr_symbol()   const\n       { return _M_data->_M_curr_symbol; }\n \n@@ -3798,7 +3798,7 @@ namespace std\n        *\n        *  @return  @a string_type representing a positive sign.\n       */\n-      virtual string_type  \n+      virtual string_type\n       do_positive_sign() const\n       { return _M_data->_M_positive_sign; }\n \n@@ -3811,7 +3811,7 @@ namespace std\n        *\n        *  @return  @a string_type representing a negative sign.\n       */\n-      virtual string_type  \n+      virtual string_type\n       do_negative_sign() const\n       { return _M_data->_M_negative_sign; }\n \n@@ -3825,7 +3825,7 @@ namespace std\n        *\n        *  @return  Number of digits in amount fraction.\n       */\n-      virtual int          \n+      virtual int\n       do_frac_digits() const\n       { return _M_data->_M_frac_digits; }\n \n@@ -3839,7 +3839,7 @@ namespace std\n        *\n        *  @return  Pattern for money values.\n       */\n-      virtual pattern      \n+      virtual pattern\n       do_pos_format() const\n       { return _M_data->_M_pos_format; }\n \n@@ -3853,13 +3853,13 @@ namespace std\n        *\n        *  @return  Pattern for money values.\n       */\n-      virtual pattern      \n+      virtual pattern\n       do_neg_format() const\n       { return _M_data->_M_neg_format; }\n \n       // For use at construction time only.\n-       void \n-       _M_initialize_moneypunct(__c_locale __cloc = NULL, \n+       void\n+       _M_initialize_moneypunct(__c_locale __cloc = NULL,\n \t\t\t\tconst char* __name = NULL);\n     };\n \n@@ -3875,11 +3875,11 @@ namespace std\n   template<>\n     moneypunct<char, false>::~moneypunct();\n \n-  template<> \n+  template<>\n     void\n     moneypunct<char, true>::_M_initialize_moneypunct(__c_locale, const char*);\n \n-  template<> \n+  template<>\n     void\n     moneypunct<char, false>::_M_initialize_moneypunct(__c_locale, const char*);\n \n@@ -3890,41 +3890,41 @@ namespace std\n   template<>\n     moneypunct<wchar_t, false>::~moneypunct();\n \n-  template<> \n+  template<>\n     void\n-    moneypunct<wchar_t, true>::_M_initialize_moneypunct(__c_locale, \n+    moneypunct<wchar_t, true>::_M_initialize_moneypunct(__c_locale,\n \t\t\t\t\t\t\tconst char*);\n \n-  template<> \n+  template<>\n     void\n-    moneypunct<wchar_t, false>::_M_initialize_moneypunct(__c_locale, \n+    moneypunct<wchar_t, false>::_M_initialize_moneypunct(__c_locale,\n \t\t\t\t\t\t\t const char*);\n #endif\n \n   template<typename _CharT, bool _Intl>\n     class moneypunct_byname : public moneypunct<_CharT, _Intl>\n     {\n     public:\n-      typedef _CharT \t\t\tchar_type;\n-      typedef basic_string<_CharT> \tstring_type;\n+      typedef _CharT\t\t\tchar_type;\n+      typedef basic_string<_CharT>\tstring_type;\n \n       static const bool intl = _Intl;\n \n-      explicit \n+      explicit\n       moneypunct_byname(const char* __s, size_t __refs = 0)\n       : moneypunct<_CharT, _Intl>(__refs)\n       {\n \tif (std::strcmp(__s, \"C\") != 0 && std::strcmp(__s, \"POSIX\") != 0)\n \t  {\n \t    __c_locale __tmp;\n \t    this->_S_create_c_locale(__tmp, __s);\n-\t    this->_M_initialize_moneypunct(__tmp);\t\n-\t    this->_S_destroy_c_locale(__tmp); \n+\t    this->_M_initialize_moneypunct(__tmp);\n+\t    this->_S_destroy_c_locale(__tmp);\n \t  }\n       }\n \n     protected:\n-      virtual \n+      virtual\n       ~moneypunct_byname() { }\n     };\n \n@@ -3950,13 +3950,13 @@ namespace std\n       // Types:\n       //@{\n       /// Public typedefs\n-      typedef _CharT        \t\tchar_type;\n-      typedef _InIter       \t\titer_type;\n-      typedef basic_string<_CharT> \tstring_type;\n+      typedef _CharT\t\t\tchar_type;\n+      typedef _InIter\t\t\titer_type;\n+      typedef basic_string<_CharT>\tstring_type;\n       //@}\n \n       /// Numpunct facet id.\n-      static locale::id \t\tid;\n+      static locale::id\t\t\tid;\n \n       /**\n        *  @brief  Constructor performs initialization.\n@@ -3965,7 +3965,7 @@ namespace std\n        *\n        *  @param refs  Passed to the base facet class.\n       */\n-      explicit \n+      explicit\n       money_get(size_t __refs = 0) : facet(__refs) { }\n \n       /**\n@@ -3993,10 +3993,10 @@ namespace std\n        *  @param  err  Error field to set if parsing fails.\n        *  @param  units  Place to store result of parsing.\n        *  @return  Iterator referencing first character beyond valid money\n-       *  \t   amount. \n+       *\t   amount.\n        */\n       iter_type\n-      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io, \n+      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,\n \t  ios_base::iostate& __err, long double& __units) const\n       { return this->do_get(__s, __end, __intl, __io, __err, __units); }\n \n@@ -4023,16 +4023,16 @@ namespace std\n        *  @param  err  Error field to set if parsing fails.\n        *  @param  digits  Place to store result of parsing.\n        *  @return  Iterator referencing first character beyond valid money\n-       *  \t   amount. \n+       *\t   amount.\n        */\n-      iter_type \n-      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io, \n+      iter_type\n+      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,\n \t  ios_base::iostate& __err, string_type& __digits) const\n       { return this->do_get(__s, __end, __intl, __io, __err, __digits); }\n \n     protected:\n       /// Destructor.\n-      virtual \n+      virtual\n       ~money_get() { }\n \n       /**\n@@ -4042,8 +4042,8 @@ namespace std\n        *  value.  This function is a hook for derived classes to change the\n        *  value returned.  @see get() for details.\n        */\n-      virtual iter_type \n-      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io, \n+      virtual iter_type\n+      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,\n \t     ios_base::iostate& __err, long double& __units) const;\n \n       /**\n@@ -4053,8 +4053,8 @@ namespace std\n        *  value.  This function is a hook for derived classes to change the\n        *  value returned.  @see get() for details.\n        */\n-      virtual iter_type \n-      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io, \n+      virtual iter_type\n+      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,\n \t     ios_base::iostate& __err, string_type& __digits) const;\n     };\n \n@@ -4079,13 +4079,13 @@ namespace std\n     public:\n       //@{\n       /// Public typedefs\n-      typedef _CharT              \tchar_type;\n-      typedef _OutIter            \titer_type;\n+      typedef _CharT\t\t\tchar_type;\n+      typedef _OutIter\t\t\titer_type;\n       typedef basic_string<_CharT>\tstring_type;\n       //@}\n \n       /// Numpunct facet id.\n-      static locale::id \t\tid;\n+      static locale::id\t\t\tid;\n \n       /**\n        *  @brief  Constructor performs initialization.\n@@ -4094,7 +4094,7 @@ namespace std\n        *\n        *  @param refs  Passed to the base facet class.\n       */\n-      explicit \n+      explicit\n       money_put(size_t __refs = 0) : facet(__refs) { }\n \n       /**\n@@ -4114,7 +4114,7 @@ namespace std\n        *  @param  units  Place to store result of parsing.\n        *  @return  Iterator after writing.\n        */\n-      iter_type \n+      iter_type\n       put(iter_type __s, bool __intl, ios_base& __io,\n \t  char_type __fill, long double __units) const\n       { return this->do_put(__s, __intl, __io, __fill, __units); }\n@@ -4136,14 +4136,14 @@ namespace std\n        *  @param  units  Place to store result of parsing.\n        *  @return  Iterator after writing.\n        */\n-      iter_type \n+      iter_type\n       put(iter_type __s, bool __intl, ios_base& __io,\n \t  char_type __fill, const string_type& __digits) const\n       { return this->do_put(__s, __intl, __io, __fill, __digits); }\n \n     protected:\n       /// Destructor.\n-      virtual \n+      virtual\n       ~money_put() { }\n \n       /**\n@@ -4229,8 +4229,8 @@ namespace std\n       // Types:\n       //@{\n       /// Public typedefs\n-      typedef _CharT \t\t\tchar_type;\n-      typedef basic_string<_CharT> \tstring_type;\n+      typedef _CharT\t\t\tchar_type;\n+      typedef basic_string<_CharT>\tstring_type;\n       //@}\n \n     protected:\n@@ -4241,7 +4241,7 @@ namespace std\n \n     public:\n       /// Numpunct facet id.\n-      static locale::id \t\tid;\n+      static locale::id\t\t\tid;\n \n       /**\n        *  @brief  Constructor performs initialization.\n@@ -4250,7 +4250,7 @@ namespace std\n        *\n        *  @param refs  Passed to the base facet class.\n       */\n-      explicit \n+      explicit\n       messages(size_t __refs = 0);\n \n       // Non-standard.\n@@ -4264,7 +4264,7 @@ namespace std\n        *  @param  s  The name of a locale.\n        *  @param  refs  Refcount to pass to the base class.\n        */\n-      explicit \n+      explicit\n       messages(__c_locale __cloc, const char* __s, size_t __refs = 0);\n \n       /*\n@@ -4277,7 +4277,7 @@ namespace std\n        *  @param  loc  Locale to use for character set conversions.\n        *  @return  Handle to the catalog or value < 0 if open fails.\n       */\n-      catalog \n+      catalog\n       open(const basic_string<char>& __s, const locale& __loc) const\n       { return this->do_open(__s, __loc); }\n \n@@ -4295,7 +4295,7 @@ namespace std\n        *  @param  dir  Message catalog root directory.\n        *  @return  Handle to the catalog or value < 0 if open fails.\n       */\n-      catalog \n+      catalog\n       open(const basic_string<char>&, const locale&, const char*) const;\n \n       /*\n@@ -4313,7 +4313,7 @@ namespace std\n        *  @param  s  Default return value if retrieval fails.\n        *  @return  Retrieved message or @a s if get fails.\n       */\n-      string_type  \n+      string_type\n       get(catalog __c, int __set, int __msgid, const string_type& __s) const\n       { return this->do_get(__c, __set, __msgid, __s); }\n \n@@ -4324,13 +4324,13 @@ namespace std\n        *\n        *  @param  c  The catalog to close.\n       */\n-      void \n+      void\n       close(catalog __c) const\n       { return this->do_close(__c); }\n \n     protected:\n       /// Destructor.\n-      virtual \n+      virtual\n       ~messages();\n \n       /*\n@@ -4344,7 +4344,7 @@ namespace std\n        *  @param  loc  Locale to use for character set conversions.\n        *  @return  Handle to the opened catalog, value < 0 if open failed.\n       */\n-      virtual catalog \n+      virtual catalog\n       do_open(const basic_string<char>&, const locale&) const;\n \n       /*\n@@ -4363,15 +4363,15 @@ namespace std\n        *  @param  s  Default return value if retrieval fails.\n        *  @return  Retrieved message or @a s if get fails.\n       */\n-      virtual string_type  \n+      virtual string_type\n       do_get(catalog, int, int, const string_type& __dfault) const;\n \n       /*\n        *  @brief  Close a message catalog.\n        *\n        *  @param  c  The catalog to close.\n       */\n-      virtual void    \n+      virtual void\n       do_close(catalog) const;\n \n       // Returns a locale and codeset-converted string, given a char* message.\n@@ -4396,12 +4396,12 @@ namespace std\n \t// Convert char* to _CharT in locale used to open catalog.\n \t// XXX need additional template parameter on messages class for this..\n \t// typedef typename codecvt<char, _CharT, _StateT> __codecvt_type;\n-\ttypedef typename codecvt<char, _CharT, mbstate_t> __codecvt_type;      \n+\ttypedef typename codecvt<char, _CharT, mbstate_t> __codecvt_type;\n \n \t__codecvt_type::state_type __state;\n \t// XXX may need to initialize state.\n \t//initialize_state(__state._M_init());\n-\t\n+\n \tchar* __from_next;\n \t// XXX what size for this string?\n \t_CharT* __to = static_cast<_CharT*>(__builtin_alloca(__len + 1));\n@@ -4442,15 +4442,15 @@ namespace std\n     class messages_byname : public messages<_CharT>\n     {\n     public:\n-      typedef _CharT               \tchar_type;\n-      typedef basic_string<_CharT> \tstring_type;\n+      typedef _CharT\t\t\tchar_type;\n+      typedef basic_string<_CharT>\tstring_type;\n \n-      explicit \n+      explicit\n       messages_byname(const char* __s, size_t __refs = 0);\n \n     protected:\n-      virtual \n-      ~messages_byname() \n+      virtual\n+      ~messages_byname()\n       { }\n     };\n \n@@ -4465,22 +4465,22 @@ namespace std\n   //@{\n   /// Convenience interface to ctype.is().\n   template<typename _CharT>\n-    inline bool \n+    inline bool\n     isspace(_CharT __c, const locale& __loc)\n     { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }\n \n   template<typename _CharT>\n-    inline bool \n+    inline bool\n     isprint(_CharT __c, const locale& __loc)\n     { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }\n \n   template<typename _CharT>\n-    inline bool \n+    inline bool\n     iscntrl(_CharT __c, const locale& __loc)\n     { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }\n \n   template<typename _CharT>\n-    inline bool \n+    inline bool\n     isupper(_CharT __c, const locale& __loc)\n     { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }\n \n@@ -4489,42 +4489,42 @@ namespace std\n     { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }\n \n   template<typename _CharT>\n-    inline bool \n+    inline bool\n     isalpha(_CharT __c, const locale& __loc)\n     { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }\n \n   template<typename _CharT>\n-    inline bool \n+    inline bool\n     isdigit(_CharT __c, const locale& __loc)\n     { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }\n \n   template<typename _CharT>\n-    inline bool \n+    inline bool\n     ispunct(_CharT __c, const locale& __loc)\n     { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }\n \n   template<typename _CharT>\n-    inline bool \n+    inline bool\n     isxdigit(_CharT __c, const locale& __loc)\n     { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }\n \n   template<typename _CharT>\n-    inline bool \n+    inline bool\n     isalnum(_CharT __c, const locale& __loc)\n     { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }\n \n   template<typename _CharT>\n-    inline bool \n+    inline bool\n     isgraph(_CharT __c, const locale& __loc)\n     { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }\n \n   template<typename _CharT>\n-    inline _CharT \n+    inline _CharT\n     toupper(_CharT __c, const locale& __loc)\n     { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }\n \n   template<typename _CharT>\n-    inline _CharT \n+    inline _CharT\n     tolower(_CharT __c, const locale& __loc)\n     { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }\n   //@}"}, {"sha": "1b7e8e63ddc956ba28ba1cab77ebaaa4d8cbaf35", "filename": "libstdc++-v3/include/bits/locale_facets.tcc", "status": "modified", "additions": 255, "deletions": 255, "changes": 510, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -35,8 +35,8 @@\n \n #pragma GCC system_header\n \n-#include <limits>    \t\t// For numeric_limits\n-#include <typeinfo>  \t\t// For bad_cast.\n+#include <limits>\t\t// For numeric_limits\n+#include <typeinfo>\t\t// For bad_cast.\n #include <bits/streambuf_iterator.h>\n \n namespace std\n@@ -169,7 +169,7 @@ namespace std\n \t\t     ios_base::iostate& __err, string& __xtrc) const\n     {\n       typedef char_traits<_CharT>\t\t\t__traits_type;\n-      typedef typename numpunct<_CharT>::__cache_type  \t__cache_type;\n+      typedef typename numpunct<_CharT>::__cache_type\t__cache_type;\n       __use_cache<__cache_type> __uc;\n       const locale& __loc = __io._M_getloc();\n       const __cache_type* __lc = __uc(__loc);\n@@ -193,13 +193,13 @@ namespace std\n \t      ++__beg;\n \t    }\n \t}\n-\t  \n+\n       // Next, look for leading zeros.\n       while (__beg != __end)\n \t{\n \t  const char_type __c = *__beg;\n \t  if (__traits_type::eq(__c, __lc->_M_decimal_point)\n-\t      || (__lc->_M_use_grouping \n+\t      || (__lc->_M_use_grouping\n \t\t  && __traits_type::eq(__c, __lc->_M_thousands_sep)))\n \t    break;\n \t  else if (__traits_type::eq(__c, __lit[_S_izero]))\n@@ -272,8 +272,8 @@ namespace std\n \t      ++__sep_pos;\n \t      ++__beg;\n \t    }\n-\t  else if ((__e = __traits_type::eq(__c, __lit[_S_ie]) \n-\t\t    || __traits_type::eq(__c, __lit[_S_iE])) \n+\t  else if ((__e = __traits_type::eq(__c, __lit[_S_ie])\n+\t\t    || __traits_type::eq(__c, __lit[_S_iE]))\n \t\t   && __found_mantissa && !__found_sci)\n \t    {\n \t      // Scientific notation.\n@@ -286,7 +286,7 @@ namespace std\n \t\t  const bool __plus = __traits_type::eq(*__beg, __lit[_S_iplus]);\n \t\t  if (__plus || __traits_type::eq(*__beg, __lit[_S_iminus]))\n \t\t    {\n-\t\t      __xtrc += __plus ? _S_atoms_in[_S_iplus] \n+\t\t      __xtrc += __plus ? _S_atoms_in[_S_iplus]\n \t\t\t               : _S_atoms_in[_S_iminus];\n \t\t      ++__beg;\n \t\t    }\n@@ -318,14 +318,14 @@ namespace std\n     }\n \n   template<typename _CharT, typename _InIter>\n-    template<typename _ValueT> \n+    template<typename _ValueT>\n       _InIter\n       num_get<_CharT, _InIter>::\n       _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,\n \t\t     ios_base::iostate& __err, _ValueT& __v) const\n       {\n         typedef char_traits<_CharT>\t\t\t__traits_type;\n-\ttypedef typename numpunct<_CharT>::__cache_type __cache_type; \n+\ttypedef typename numpunct<_CharT>::__cache_type __cache_type;\n \t__use_cache<__cache_type> __uc;\n \tconst locale& __loc = __io._M_getloc();\n \tconst __cache_type* __lc = __uc(__loc);\n@@ -342,7 +342,7 @@ namespace std\n \t// First check for sign.\n \tbool __negative = false;\n \tif (__beg != __end)\n-\t  { \n+\t  {\n \t    const char_type __c = *__beg;\n \t    if (numeric_limits<_ValueT>::is_signed)\n \t      __negative = __traits_type::eq(__c, __lit[_S_iminus]);\n@@ -466,7 +466,7 @@ namespace std\n \t\t\t__err |= ios_base::failbit;\n \t\t\tbreak;\n \t\t      }\n-\t\t  }\t\n+\t\t  }\n \t\telse if (__traits_type::eq(__c, __lc->_M_decimal_point))\n \t\t  break;\n \t\telse if (__p = __traits_type::find(__lit_zero, __len, __c))\n@@ -496,7 +496,7 @@ namespace std\n \t  {\n \t    // Add the ending grouping.\n \t    __found_grouping += static_cast<char>(__sep_pos);\n-\t    \n+\n \t    if (!std::__verify_grouping(__lc->_M_grouping, __lc->_M_grouping_size,\n \t\t\t\t\t__found_grouping))\n \t      __err |= ios_base::failbit;\n@@ -560,7 +560,7 @@ namespace std\n \t\t  break;\n \n \t      if (!__testf && !__testt)\n-\t\tbreak;      \n+\t\tbreak;\n             }\n \t  if (__testf && __n == __lc->_M_falsename_size)\n \t    __v = 0;\n@@ -587,7 +587,7 @@ namespace std\n     num_get<_CharT, _InIter>::\n     do_get(iter_type __beg, iter_type __end, ios_base& __io,\n            ios_base::iostate& __err, unsigned short& __v) const\n-    { return _M_extract_int(__beg, __end, __io, __err, __v); } \n+    { return _M_extract_int(__beg, __end, __io, __err, __v); }\n \n   template<typename _CharT, typename _InIter>\n     _InIter\n@@ -622,7 +622,7 @@ namespace std\n   template<typename _CharT, typename _InIter>\n     _InIter\n     num_get<_CharT, _InIter>::\n-    do_get(iter_type __beg, iter_type __end, ios_base& __io, \n+    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n \t   ios_base::iostate& __err, float& __v) const\n     {\n       string __xtrc;\n@@ -677,7 +677,7 @@ namespace std\n \n       if (!(__err & ios_base::failbit))\n \t__v = reinterpret_cast<void*>(__ul);\n-      else \n+      else\n \t__err |= ios_base::failbit;\n       return __beg;\n     }\n@@ -687,12 +687,12 @@ namespace std\n   template<typename _CharT, typename _OutIter>\n     void\n     num_put<_CharT, _OutIter>::\n-    _M_pad(_CharT __fill, streamsize __w, ios_base& __io, \n+    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,\n \t   _CharT* __new, const _CharT* __cs, int& __len) const\n     {\n       // [22.2.2.2.2] Stage 3.\n       // If necessary, pad.\n-      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new, __cs, \n+      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new, __cs,\n \t\t\t\t\t\t  __w, __len, true);\n       __len = static_cast<int>(__w);\n     }\n@@ -705,12 +705,12 @@ namespace std\n     {\n       unsigned long __ul = static_cast<unsigned long>(__v);\n       bool __neg = false;\n-      if (__v < 0) \n+      if (__v < 0)\n \t{\n \t  __ul = -__ul;\n \t  __neg = true;\n \t}\n-      return __int_to_char(__bufend, __ul, __lit, __flags, __neg); \n+      return __int_to_char(__bufend, __ul, __lit, __flags, __neg);\n     }\n \n   template<typename _CharT>\n@@ -724,15 +724,15 @@ namespace std\n     inline int\n     __int_to_char(_CharT* __bufend, long long __v, const _CharT* __lit,\n \t\t  ios_base::fmtflags __flags)\n-    { \n+    {\n       unsigned long long __ull = static_cast<unsigned long long>(__v);\n       bool __neg = false;\n-      if (__v < 0) \n+      if (__v < 0)\n \t{\n \t  __ull = -__ull;\n \t  __neg = true;\n \t}\n-      return __int_to_char(__bufend, __ull, __lit, __flags, __neg); \n+      return __int_to_char(__bufend, __ull, __lit, __flags, __neg);\n     }\n \n   template<typename _CharT>\n@@ -741,7 +741,7 @@ namespace std\n \t\t  ios_base::fmtflags __flags)\n     { return __int_to_char(__bufend, __v, __lit, __flags, false); }\n #endif\n-      \n+\n   template<typename _CharT, typename _ValueT>\n     int\n     __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,\n@@ -756,11 +756,11 @@ namespace std\n \t\t\t   __basefield != ios_base::hex, true))\n \t{\n \t  // Decimal.\n-\t  do \n+\t  do\n \t    {\n \t      *__buf-- = __lit[(__v % 10) + __num_base::_S_odigits];\n \t      __v /= 10;\n-\t    } \n+\t    }\n \t  while (__v != 0);\n \t  if (__neg)\n \t    *__buf-- = __lit[__num_base::_S_ominus];\n@@ -770,11 +770,11 @@ namespace std\n       else if (__basefield == ios_base::oct)\n \t{\n \t  // Octal.\n-\t  do \n+\t  do\n \t    {\n \t      *__buf-- = __lit[(__v & 0x7) + __num_base::_S_odigits];\n \t      __v >>= 3;\n-\t    } \n+\t    }\n \t  while (__v != 0);\n \t  if (__showbase)\n \t    *__buf-- = __lit[__num_base::_S_odigits];\n@@ -783,13 +783,13 @@ namespace std\n \t{\n \t  // Hex.\n \t  const bool __uppercase = __flags & ios_base::uppercase;\n-\t  const int __case_offset = __uppercase ? __num_base::_S_oudigits \n+\t  const int __case_offset = __uppercase ? __num_base::_S_oudigits\n \t                                        : __num_base::_S_odigits;\n-\t  do \n+\t  do\n \t    {\n \t      *__buf-- = __lit[(__v & 0xf) + __case_offset];\n \t      __v >>= 4;\n-\t    } \n+\t    }\n \t  while (__v != 0);\n \t  if (__showbase)\n \t    {\n@@ -814,7 +814,7 @@ namespace std\n       // However, remember that the latter do not occur if the number\n       // printed is '0' (__len == 1).\n       streamsize __off = 0;\n-      const ios_base::fmtflags __basefield = __io.flags() \n+      const ios_base::fmtflags __basefield = __io.flags()\n \t                                     & ios_base::basefield;\n       if ((__io.flags() & ios_base::showbase) && __len > 1)\n \tif (__basefield == ios_base::oct)\n@@ -839,7 +839,7 @@ namespace std\n     template<typename _ValueT>\n       _OutIter\n       num_put<_CharT, _OutIter>::\n-      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill, \n+      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,\n \t\t    _ValueT __v) const\n       {\n \ttypedef typename numpunct<_CharT>::__cache_type\t__cache_type;\n@@ -848,34 +848,34 @@ namespace std\n \tconst __cache_type* __lc = __uc(__loc);\n \tconst _CharT* __lit = __lc->_M_atoms_out;\n \n- \t// Long enough to hold hex, dec, and octal representations.\n+\t// Long enough to hold hex, dec, and octal representations.\n \tconst int __ilen = 4 * sizeof(_ValueT);\n-\t_CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) \n+\t_CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)\n \t\t\t\t\t\t\t     * __ilen));\n \n \t// [22.2.2.2.2] Stage 1, numeric conversion to character.\n \t// Result is returned right-justified in the buffer.\n \tint __len;\n \t__len = __int_to_char(__cs + __ilen, __v, __lit, __io.flags());\n \t__cs += __ilen - __len;\n-\t\n-\t// Add grouping, if necessary. \n+\n+\t// Add grouping, if necessary.\n \tif (__lc->_M_use_grouping)\n \t  {\n \t    // Grouping can add (almost) as many separators as the\n \t    // number of digits, but no more.\n-\t    _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) \n+\t    _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)\n \t\t\t\t\t\t\t\t  * __len * 2));\n \t    _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,\n \t\t\t __lc->_M_thousands_sep, __io, __cs2, __cs, __len);\n \t    __cs = __cs2;\n \t  }\n-\t\n+\n \t// Pad.\n \tconst streamsize __w = __io.width();\n \tif (__w > static_cast<streamsize>(__len))\n \t  {\n-\t    _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) \n+\t    _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)\n \t\t\t\t\t\t\t\t  * __w));\n \t    _M_pad(__fill, __w, __io, __cs3, __cs, __len);\n \t    __cs = __cs3;\n@@ -885,7 +885,7 @@ namespace std\n \t// [22.2.2.2.2] Stage 4.\n \t// Write resulting, fully-formatted string to output iterator.\n \treturn std::__write(__s, __cs, __len);\n-      } \n+      }\n \n   template<typename _CharT, typename _OutIter>\n     void\n@@ -895,19 +895,19 @@ namespace std\n     {\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 282. What types does numpunct grouping refer to?\n-      // Add grouping, if necessary. \n+      // Add grouping, if necessary.\n       _CharT* __p2;\n       const int __declen = __p ? __p - __cs : __len;\n       __p2 = std::__add_grouping(__new, __sep, __grouping, __grouping_size,\n \t\t\t\t __cs, __cs + __declen);\n-      \n+\n       // Tack on decimal part.\n       int __newlen = __p2 - __new;\n       if (__p)\n \t{\n \t  char_traits<_CharT>::copy(__p2, __p, __len - __declen);\n \t  __newlen += __len - __declen;\n-\t}    \n+\t}\n       __len = __newlen;\n     }\n \n@@ -967,7 +967,7 @@ namespace std\n \t// If the buffer was not large enough, try again with the correct size.\n \tif (__len >= __cs_size)\n \t  {\n-\t    __cs_size = __len + 1; \n+\t    __cs_size = __len + 1;\n \t    __cs = static_cast<char*>(__builtin_alloca(__cs_size));\n \t    __len = std::__convert_from_v(__cs, __cs_size, __fbuf, __v,\n \t\t\t\t\t  _S_get_c_locale(), __prec);\n@@ -983,36 +983,36 @@ namespace std\n \t// fractional part + 3 chars for sign, decimal point, '\\0'. On\n \t// the other hand, for non-fixed outputs __max_digits*3 chars\n \t// are largely sufficient.\n-\tconst int __cs_size = __fixed ? __max_exp + __max_digits + 4 \n+\tconst int __cs_size = __fixed ? __max_exp + __max_digits + 4\n \t                              : __max_digits * 3;\n \tchar* __cs = static_cast<char*>(__builtin_alloca(__cs_size));\n \n \t_S_format_float(__io, __fbuf, __mod);\n-\t__len = std::__convert_from_v(__cs, 0, __fbuf, __v, \n+\t__len = std::__convert_from_v(__cs, 0, __fbuf, __v,\n \t\t\t\t      _S_get_c_locale(), __prec);\n #endif\n \n       // [22.2.2.2.2] Stage 2, convert to char_type, using correct\n       // numpunct.decimal_point() values for '.' and adding grouping.\n       const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n \n-      _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) \n+      _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)\n \t\t\t\t\t\t\t   * __len));\n       __ctype.widen(__cs, __cs + __len, __ws);\n-      \n+\n       // Replace decimal point.\n       const _CharT __cdec = __ctype.widen('.');\n       const _CharT __dec = __lc->_M_decimal_point;\n       const _CharT* __p;\n       if (__p = char_traits<_CharT>::find(__ws, __len, __cdec))\n \t__ws[__p - __ws] = __dec;\n \n-      // Add grouping, if necessary. \n+      // Add grouping, if necessary.\n       if (__lc->_M_use_grouping)\n \t{\n \t  // Grouping can add (almost) as many separators as the\n \t  // number of digits, but no more.\n-\t  _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) \n+\t  _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)\n \t\t\t\t\t\t\t\t* __len * 2));\n \t  _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,\n \t\t\t __lc->_M_thousands_sep, __p, __ws2, __ws, __len);\n@@ -1029,7 +1029,7 @@ namespace std\n \t  __ws = __ws3;\n \t}\n       __io.width(0);\n-      \n+\n       // [22.2.2.2.2] Stage 4.\n       // Write resulting, fully-formatted string to output iterator.\n       return std::__write(__s, __ws, __len);\n@@ -1053,15 +1053,15 @@ namespace std\n \t  const locale& __loc = __io._M_getloc();\n \t  const __cache_type* __lc = __uc(__loc);\n \n-\t  const _CharT* __name = __v ? __lc->_M_truename \n+\t  const _CharT* __name = __v ? __lc->_M_truename\n \t                             : __lc->_M_falsename;\n \t  int __len = __v ? __lc->_M_truename_size\n \t                  : __lc->_M_falsename_size;\n \n \t  const streamsize __w = __io.width();\n \t  if (__w > static_cast<streamsize>(__len))\n \t    {\n-\t      _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) \n+\t      _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)\n \t\t\t\t\t\t\t\t   * __w));\n \t      _M_pad(__fill, __w, __io, __cs, __name, __len);\n \t      __name = __cs;\n@@ -1109,7 +1109,7 @@ namespace std\n   template<typename _CharT, typename _OutIter>\n     _OutIter\n     num_put<_CharT, _OutIter>::\n-    do_put(iter_type __s, ios_base& __io, char_type __fill, \n+    do_put(iter_type __s, ios_base& __io, char_type __fill,\n \t   long double __v) const\n     { return _M_insert_float(__s, __io, __fill, 'L', __v); }\n \n@@ -1123,8 +1123,8 @@ namespace std\n       const ios_base::fmtflags __fmt = ~(ios_base::showpos | ios_base::basefield\n \t\t\t\t\t | ios_base::uppercase | ios_base::internal);\n       __io.flags(__flags & __fmt | (ios_base::hex | ios_base::showbase));\n-      \n-      __s = _M_insert_int(__s, __io, __fill, \n+\n+      __s = _M_insert_int(__s, __io, __fill,\n \t\t\t  reinterpret_cast<unsigned long>(__v));\n       __io.flags(__flags);\n       return __s;\n@@ -1134,63 +1134,63 @@ namespace std\n   template<typename _CharT, typename _InIter>\n     _InIter\n     money_get<_CharT, _InIter>::\n-    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io, \n+    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,\n \t   ios_base::iostate& __err, long double& __units) const\n-    { \n+    {\n       string_type __str;\n-      __beg = this->do_get(__beg, __end, __intl, __io, __err, __str); \n+      __beg = this->do_get(__beg, __end, __intl, __io, __err, __str);\n \n       const int __cs_size = __str.size() + 1;\n       char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));\n       const locale __loc = __io.getloc();\n-      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc); \n+      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n       const _CharT* __wcs = __str.c_str();\n-      __ctype.narrow(__wcs, __wcs + __cs_size, char(), __cs);      \n+      __ctype.narrow(__wcs, __wcs + __cs_size, char(), __cs);\n       std::__convert_to_v(__cs, __units, __err, _S_get_c_locale());\n       return __beg;\n     }\n \n   template<typename _CharT, typename _InIter>\n     _InIter\n     money_get<_CharT, _InIter>::\n-    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io, \n+    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,\n \t   ios_base::iostate& __err, string_type& __units) const\n-    { \n+    {\n       // These contortions are quite unfortunate.\n-      typedef moneypunct<_CharT, true> \t\t__money_true;\n-      typedef moneypunct<_CharT, false> \t__money_false;\n-      typedef money_base::part \t\t\tpart;\n-      typedef typename string_type::size_type \tsize_type;\n+      typedef moneypunct<_CharT, true>\t\t__money_true;\n+      typedef moneypunct<_CharT, false>\t\t__money_false;\n+      typedef money_base::part\t\t\tpart;\n+      typedef typename string_type::size_type\tsize_type;\n \n       const locale __loc = __io.getloc();\n-      const __money_true& __mpt = use_facet<__money_true>(__loc); \n-      const __money_false& __mpf = use_facet<__money_false>(__loc); \n-      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc); \n+      const __money_true& __mpt = use_facet<__money_true>(__loc);\n+      const __money_false& __mpf = use_facet<__money_false>(__loc);\n+      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n \n-      const money_base::pattern __p = __intl ? __mpt.neg_format() \n+      const money_base::pattern __p = __intl ? __mpt.neg_format()\n \t\t\t\t\t     : __mpf.neg_format();\n \n-      const string_type __pos_sign = __intl ? __mpt.positive_sign() \n+      const string_type __pos_sign = __intl ? __mpt.positive_sign()\n \t\t\t\t\t    : __mpf.positive_sign();\n-      const string_type __neg_sign = __intl ? __mpt.negative_sign() \n+      const string_type __neg_sign = __intl ? __mpt.negative_sign()\n \t\t\t\t\t    : __mpf.negative_sign();\n-      const char_type __d = __intl ? __mpt.decimal_point() \n-  \t    \t       \t\t   : __mpf.decimal_point();\n-      const char_type __sep = __intl ? __mpt.thousands_sep() \n-\t\t    \t\t     : __mpf.thousands_sep();\n+      const char_type __d = __intl ? __mpt.decimal_point()\n+\t\t\t\t   : __mpf.decimal_point();\n+      const char_type __sep = __intl ? __mpt.thousands_sep()\n+\t\t\t\t     : __mpf.thousands_sep();\n \n       const string __grouping = __intl ? __mpt.grouping() : __mpf.grouping();\n \n       // Set to deduced positive or negative sign, depending.\n       string_type __sign;\n       // String of grouping info from thousands_sep plucked from __units.\n-      string __grouping_tmp; \n+      string __grouping_tmp;\n       // Marker for thousands_sep position.\n       int __sep_pos = 0;\n       // If input iterator is in a valid state.\n       bool __testvalid = true;\n       // Flag marking when a decimal point is found.\n-      bool __testdecfound = false; \n+      bool __testdecfound = false;\n \n       // The tentative returned string is stored here.\n       string_type __tmp_units;\n@@ -1202,10 +1202,10 @@ namespace std\n \t  switch (__which)\n \t    {\n \t    case money_base::symbol:\n-\t      if (__io.flags() & ios_base::showbase \n+\t      if (__io.flags() & ios_base::showbase\n \t\t  || __i < 2 || __sign.size() > 1\n \t\t  || ((static_cast<part>(__p.field[3]) != money_base::none)\n-\t\t      && __i == 2)) \n+\t\t      && __i == 2))\n \t\t{\n \t\t  // According to 22.2.6.1.2.2, symbol is required\n \t\t  // if (__io.flags() & ios_base::showbase),\n@@ -1224,7 +1224,7 @@ namespace std\n \t\t    __testvalid = false;\n \t\t}\n \t      break;\n-\t    case money_base::sign:\t\t    \n+\t    case money_base::sign:\n \t      // Sign might not exist, or be more than one character long.\n \t      if (__pos_sign.size() && *__beg == __pos_sign[0])\n \t\t{\n@@ -1282,12 +1282,12 @@ namespace std\n \t    case money_base::none:\n \t      // Only if not at the end of the pattern.\n \t      if (__i != 3)\n-\t\tfor (; __beg != __end \n+\t\tfor (; __beg != __end\n \t\t       && __ctype.is(ctype_base::space, *__beg); ++__beg);\n \t      break;\n \t    }\n \t}\n-      \n+\n       // Need to get the rest of the sign characters, if they exist.\n       if (__sign.size() > 1)\n \t{\n@@ -1296,7 +1296,7 @@ namespace std\n \t  for (; __beg != __end && __i < __len; ++__i)\n \t    for (; __beg != __end\n \t\t   && *__beg != __sign[__i]; ++__beg);\n-\t  \n+\n \t  if (__i != __len)\n \t    __testvalid = false;\n \t}\n@@ -1314,7 +1314,7 @@ namespace std\n \t\t__tmp_units.erase(0, __only_zeros ? __tmp_units.size() - 1\n \t\t\t\t                  : __first);\n \t    }\n-\t  \n+\n \t  // 22.2.6.1.2, p4\n \t  if (__sign.size() && __sign == __neg_sign\n \t      && __tmp_units[0] != __zero)\n@@ -1332,11 +1332,11 @@ namespace std\n \t\t\t\t\t  __grouping_tmp))\n \t\t__testvalid = false;\n \t    }\n-\t  \n+\n \t  // Iff not enough digits were supplied after the decimal-point.\n \t  if (__testdecfound)\n \t    {\n-\t      const int __frac = __intl ? __mpt.frac_digits() \n+\t      const int __frac = __intl ? __mpt.frac_digits()\n \t\t                        : __mpf.frac_digits();\n \t      if (__frac > 0 && __sep_pos != __frac)\n \t\t__testvalid = false;\n@@ -1345,7 +1345,7 @@ namespace std\n       else\n \t__testvalid = false;\n \n-      // Iff no more characters are available.      \n+      // Iff no more characters are available.\n       if (__beg == __end)\n \t__err |= ios_base::eofbit;\n \n@@ -1356,15 +1356,15 @@ namespace std\n \t// Use the \"swap trick\" to copy __tmp_units into __units.\n \t__tmp_units.swap(__units);\n \n-      return __beg; \n+      return __beg;\n     }\n \n   template<typename _CharT, typename _OutIter>\n     _OutIter\n     money_put<_CharT, _OutIter>::\n     do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,\n \t   long double __units) const\n-    { \n+    {\n       const locale __loc = __io.getloc();\n       const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n #ifdef _GLIBCXX_USE_C99\n@@ -1373,48 +1373,48 @@ namespace std\n       char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 328. Bad sprintf format modifier in money_put<>::do_put()\n-      int __len = std::__convert_from_v(__cs, __cs_size, \"%.0Lf\", __units, \n+      int __len = std::__convert_from_v(__cs, __cs_size, \"%.0Lf\", __units,\n \t\t\t\t\t_S_get_c_locale());\n       // If the buffer was not large enough, try again with the correct size.\n       if (__len >= __cs_size)\n \t{\n \t  __cs_size = __len + 1;\n \t  __cs = static_cast<char*>(__builtin_alloca(__cs_size));\n-\t  __len = std::__convert_from_v(__cs, __cs_size, \"%.0Lf\", __units, \n+\t  __len = std::__convert_from_v(__cs, __cs_size, \"%.0Lf\", __units,\n \t\t\t\t\t_S_get_c_locale());\n \t}\n #else\n-      // max_exponent10 + 1 for the integer part, + 2 for sign and '\\0'. \n+      // max_exponent10 + 1 for the integer part, + 2 for sign and '\\0'.\n       const int __cs_size = numeric_limits<long double>::max_exponent10 + 3;\n       char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));\n-      int __len = std::__convert_from_v(__cs, 0, \"%.0Lf\", __units, \n+      int __len = std::__convert_from_v(__cs, 0, \"%.0Lf\", __units,\n \t\t\t\t\t_S_get_c_locale());\n #endif\n-      _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) \n+      _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)\n \t\t\t\t\t\t\t   * __cs_size));\n       __ctype.widen(__cs, __cs + __len, __ws);\n       const string_type __digits(__ws, __len);\n-      return this->do_put(__s, __intl, __io, __fill, __digits); \n+      return this->do_put(__s, __intl, __io, __fill, __digits);\n     }\n \n   template<typename _CharT, typename _OutIter>\n     _OutIter\n     money_put<_CharT, _OutIter>::\n     do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,\n \t   const string_type& __digits) const\n-    { \n-      typedef typename string_type::size_type \tsize_type;\n-      typedef money_base::part \t\t\tpart;\n+    {\n+      typedef typename string_type::size_type\tsize_type;\n+      typedef money_base::part\t\t\tpart;\n \n       const locale __loc = __io.getloc();\n       const size_type __width = static_cast<size_type>(__io.width());\n \n       // These contortions are quite unfortunate.\n       typedef moneypunct<_CharT, true> __money_true;\n       typedef moneypunct<_CharT, false> __money_false;\n-      const __money_true& __mpt = use_facet<__money_true>(__loc); \n-      const __money_false& __mpf = use_facet<__money_false>(__loc); \n-      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc); \n+      const __money_true& __mpt = use_facet<__money_true>(__loc);\n+      const __money_false& __mpf = use_facet<__money_false>(__loc);\n+      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n \n       // Determine if negative or positive formats are to be used, and\n       // discard leading negative_sign if it is present.\n@@ -1433,7 +1433,7 @@ namespace std\n \t  __sign = __intl ? __mpt.negative_sign() : __mpf.negative_sign();\n \t  ++__beg;\n \t}\n-      \n+\n       // Look for valid numbers in the current ctype facet within input digits.\n       __end = __ctype.scan_not(ctype_base::digit, __beg, __end);\n       if (__beg != __end)\n@@ -1443,15 +1443,15 @@ namespace std\n \t  //   final_value = grouped units + (decimal point) + (digits)\n \t  string_type __res;\n \t  string_type __value;\n-\t  const string_type __symbol = __intl ? __mpt.curr_symbol() \n-\t    \t\t\t\t      : __mpf.curr_symbol();\n+\t  const string_type __symbol = __intl ? __mpt.curr_symbol()\n+\t\t\t\t\t      : __mpf.curr_symbol();\n \n \t  // Deal with decimal point, decimal digits.\n-\t  const int __frac = __intl ? __mpt.frac_digits() \n-\t    \t\t\t    : __mpf.frac_digits();\n+\t  const int __frac = __intl ? __mpt.frac_digits()\n+\t\t\t\t    : __mpf.frac_digits();\n \t  if (__frac > 0)\n \t    {\n-\t      const char_type __d = __intl ? __mpt.decimal_point() \n+\t      const char_type __d = __intl ? __mpt.decimal_point()\n \t\t\t\t\t   : __mpf.decimal_point();\n \t      if (__end - __beg >= __frac)\n \t\t{\n@@ -1475,18 +1475,18 @@ namespace std\n \t  // grouping rules.\n \t  if (__beg != __end)\n \t    {\n-\t      const string __grouping = __intl ? __mpt.grouping() \n+\t      const string __grouping = __intl ? __mpt.grouping()\n \t\t\t\t\t       : __mpf.grouping();\n \t      if (__grouping.size())\n \t\t{\n-\t\t  const char_type __sep = __intl ? __mpt.thousands_sep() \n-\t\t    \t\t\t         : __mpf.thousands_sep();\n+\t\t  const char_type __sep = __intl ? __mpt.thousands_sep()\n+\t\t\t\t\t         : __mpf.thousands_sep();\n \t\t  const char* __gbeg = __grouping.data();\n \t\t  const size_t __glen = __grouping.size();\n \t\t  const int __n = (__end - __beg) * 2;\n \t\t  _CharT* __ws2 =\n-       \t          static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __n));\n-\t\t  _CharT* __ws_end = std::__add_grouping(__ws2, __sep, __gbeg, \n+\t          static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __n));\n+\t\t  _CharT* __ws_end = std::__add_grouping(__ws2, __sep, __gbeg,\n \t\t\t\t\t\t\t __glen, __beg, __end);\n \t\t  __value.insert(0, __ws2, __ws_end - __ws2);\n \t\t}\n@@ -1510,7 +1510,7 @@ namespace std\n \t\t  if (__io.flags() & ios_base::showbase)\n \t\t    __res += __symbol;\n \t\t  break;\n-\t\tcase money_base::sign:\t\t    \n+\t\tcase money_base::sign:\n \t\t  // Sign might not exist, or be more than one\n \t\t  // charater long. In that case, add in the rest\n \t\t  // below.\n@@ -1557,7 +1557,7 @@ namespace std\n \t  __s = std::__write(__s, __res.data(), __len);\n \t}\n       __io.width(0);\n-      return __s; \n+      return __s;\n     }\n \n \n@@ -1577,12 +1577,12 @@ namespace std\n     void\n     time_get<_CharT, _InIter>::\n     _M_extract_via_format(iter_type& __beg, iter_type& __end, ios_base& __io,\n-\t\t\t  ios_base::iostate& __err, tm* __tm, \n+\t\t\t  ios_base::iostate& __err, tm* __tm,\n \t\t\t  const _CharT* __format) const\n-    {  \n+    {\n       const locale __loc = __io.getloc();\n       const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);\n-      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc); \n+      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n       const size_t __len = char_traits<_CharT>::length(__format);\n \n       for (size_t __i = 0; __beg != __end && __i < __len && !__err; ++__i)\n@@ -1591,7 +1591,7 @@ namespace std\n \t    {\n \t      // Verify valid formatting code, attempt to extract.\n \t      char __c = __ctype.narrow(__format[++__i], 0);\n-\t      int __mem = 0; \n+\t      int __mem = 0;\n \t      if (__c == 'E' || __c == 'O')\n \t\t__c = __ctype.narrow(__format[++__i], 0);\n \t      switch (__c)\n@@ -1602,41 +1602,41 @@ namespace std\n \t\t  // Abbreviated weekday name [tm_wday]\n \t\t  const char_type*  __days1[7];\n \t\t  __tp._M_days_abbreviated(__days1);\n-\t\t  _M_extract_name(__beg, __end, __tm->tm_wday, __days1, 7, \n+\t\t  _M_extract_name(__beg, __end, __tm->tm_wday, __days1, 7,\n \t\t\t\t  __ctype, __err);\n \t\t  break;\n \t\tcase 'A':\n \t\t  // Weekday name [tm_wday].\n \t\t  const char_type*  __days2[7];\n \t\t  __tp._M_days(__days2);\n-\t\t  _M_extract_name(__beg, __end, __tm->tm_wday, __days2, 7, \n+\t\t  _M_extract_name(__beg, __end, __tm->tm_wday, __days2, 7,\n \t\t\t\t  __ctype, __err);\n \t\t  break;\n \t\tcase 'h':\n \t\tcase 'b':\n \t\t  // Abbreviated month name [tm_mon]\n \t\t  const char_type*  __months1[12];\n \t\t  __tp._M_months_abbreviated(__months1);\n-\t\t  _M_extract_name(__beg, __end, __tm->tm_mon, __months1, 12, \n+\t\t  _M_extract_name(__beg, __end, __tm->tm_mon, __months1, 12,\n \t\t\t\t  __ctype, __err);\n \t\t  break;\n \t\tcase 'B':\n \t\t  // Month name [tm_mon].\n \t\t  const char_type*  __months2[12];\n \t\t  __tp._M_months(__months2);\n-\t\t  _M_extract_name(__beg, __end, __tm->tm_mon, __months2, 12, \n+\t\t  _M_extract_name(__beg, __end, __tm->tm_mon, __months2, 12,\n \t\t\t\t  __ctype, __err);\n \t\t  break;\n \t\tcase 'c':\n \t\t  // Default time and date representation.\n \t\t  const char_type*  __dt[2];\n \t\t  __tp._M_date_time_formats(__dt);\n-\t\t  _M_extract_via_format(__beg, __end, __io, __err, __tm, \n+\t\t  _M_extract_via_format(__beg, __end, __io, __err, __tm,\n \t\t\t\t\t__dt[0]);\n \t\t  break;\n \t\tcase 'd':\n \t\t  // Day [01, 31]. [tm_mday]\n-\t\t  _M_extract_num(__beg, __end, __tm->tm_mday, 1, 31, 2, \n+\t\t  _M_extract_num(__beg, __end, __tm->tm_mday, 1, 31, 2,\n \t\t\t\t __ctype, __err);\n \t\t  break;\n \t\tcase 'e':\n@@ -1647,13 +1647,13 @@ namespace std\n \t\t\t\t   __ctype, __err);\n \t\t  else\n \t\t    _M_extract_num(__beg, __end, __tm->tm_mday, 10, 31, 2,\n-\t\t\t\t   __ctype, __err);\t\t    \n-\t\t  break;\t\t    \n+\t\t\t\t   __ctype, __err);\n+\t\t  break;\n \t\tcase 'D':\n \t\t  // Equivalent to %m/%d/%y.[tm_mon, tm_mday, tm_year]\n \t\t  __cs = \"%m/%d/%y\";\n \t\t  __ctype.widen(__cs, __cs + 9, __wcs);\n-\t\t  _M_extract_via_format(__beg, __end, __io, __err, __tm, \n+\t\t  _M_extract_via_format(__beg, __end, __io, __err, __tm,\n \t\t\t\t\t__wcs);\n \t\t  break;\n \t\tcase 'H':\n@@ -1663,12 +1663,12 @@ namespace std\n \t\t  break;\n \t\tcase 'I':\n \t\t  // Hour [01, 12]. [tm_hour]\n-\t\t  _M_extract_num(__beg, __end, __tm->tm_hour, 1, 12, 2, \n+\t\t  _M_extract_num(__beg, __end, __tm->tm_hour, 1, 12, 2,\n \t\t\t\t __ctype, __err);\n \t\t  break;\n \t\tcase 'm':\n \t\t  // Month [01, 12]. [tm_mon]\n-\t\t  _M_extract_num(__beg, __end, __mem, 1, 12, 2, __ctype, \n+\t\t  _M_extract_num(__beg, __end, __mem, 1, 12, 2, __ctype,\n \t\t\t\t __err);\n \t\t  if (!__err)\n \t\t    __tm->tm_mon = __mem - 1;\n@@ -1688,7 +1688,7 @@ namespace std\n \t\t  // Equivalent to (%H:%M).\n \t\t  __cs = \"%H:%M\";\n \t\t  __ctype.widen(__cs, __cs + 6, __wcs);\n-\t\t  _M_extract_via_format(__beg, __end, __io, __err, __tm, \n+\t\t  _M_extract_via_format(__beg, __end, __io, __err, __tm,\n \t\t\t\t\t__wcs);\n \t\t  break;\n \t\tcase 'S':\n@@ -1706,32 +1706,32 @@ namespace std\n \t\t  // Equivalent to (%H:%M:%S).\n \t\t  __cs = \"%H:%M:%S\";\n \t\t  __ctype.widen(__cs, __cs + 9, __wcs);\n-\t\t  _M_extract_via_format(__beg, __end, __io, __err, __tm, \n+\t\t  _M_extract_via_format(__beg, __end, __io, __err, __tm,\n \t\t\t\t\t__wcs);\n \t\t  break;\n \t\tcase 'x':\n \t\t  // Locale's date.\n \t\t  const char_type*  __dates[2];\n \t\t  __tp._M_date_formats(__dates);\n-\t\t  _M_extract_via_format(__beg, __end, __io, __err, __tm, \n+\t\t  _M_extract_via_format(__beg, __end, __io, __err, __tm,\n \t\t\t\t\t__dates[0]);\n \t\t  break;\n \t\tcase 'X':\n \t\t  // Locale's time.\n \t\t  const char_type*  __times[2];\n \t\t  __tp._M_time_formats(__times);\n-\t\t  _M_extract_via_format(__beg, __end, __io, __err, __tm, \n+\t\t  _M_extract_via_format(__beg, __end, __io, __err, __tm,\n \t\t\t\t\t__times[0]);\n \t\t  break;\n \t\tcase 'y':\n \t\tcase 'C': // C99\n \t\t  // Two digit year. [tm_year]\n-\t\t  _M_extract_num(__beg, __end, __tm->tm_year, 0, 99, 2, \n+\t\t  _M_extract_num(__beg, __end, __tm->tm_year, 0, 99, 2,\n \t\t\t\t __ctype, __err);\n \t\t  break;\n \t\tcase 'Y':\n \t\t  // Year [1900). [tm_year]\n-\t\t  _M_extract_num(__beg, __end, __mem, 0, 9999, 4, \n+\t\t  _M_extract_num(__beg, __end, __mem, 0, 9999, 4,\n \t\t\t\t __ctype, __err);\n \t\t  if (!__err)\n \t\t    __tm->tm_year = __mem - 1900;\n@@ -1741,20 +1741,20 @@ namespace std\n \t\t  if (__ctype.is(ctype_base::upper, *__beg))\n \t\t    {\n \t\t      int __tmp;\n-\t\t      _M_extract_name(__beg, __end, __tmp, \n-\t\t\t\t      __timepunct_cache<_CharT>::_S_timezones, \n+\t\t      _M_extract_name(__beg, __end, __tmp,\n+\t\t\t\t      __timepunct_cache<_CharT>::_S_timezones,\n \t\t\t\t      14, __ctype, __err);\n-\t\t      \n+\n \t\t      // GMT requires special effort.\n \t\t      if (__beg != __end && !__err && __tmp == 0\n-\t\t\t  && (*__beg == __ctype.widen('-') \n+\t\t\t  && (*__beg == __ctype.widen('-')\n \t\t\t      || *__beg == __ctype.widen('+')))\n \t\t\t{\n \t\t\t  _M_extract_num(__beg, __end, __tmp, 0, 23, 2,\n \t\t\t\t\t  __ctype, __err);\n \t\t\t  _M_extract_num(__beg, __end, __tmp, 0, 59, 2,\n \t\t\t\t\t  __ctype, __err);\n-\t\t\t}\t    \n+\t\t\t}\n \t\t    }\n \t\t  else\n \t\t    __err |= ios_base::failbit;\n@@ -1779,8 +1779,8 @@ namespace std\n     void\n     time_get<_CharT, _InIter>::\n     _M_extract_num(iter_type& __beg, iter_type& __end, int& __member,\n-\t\t   int __min, int __max, size_t __len, \n-\t\t   const ctype<_CharT>& __ctype, \n+\t\t   int __min, int __max, size_t __len,\n+\t\t   const ctype<_CharT>& __ctype,\n \t\t   ios_base::iostate& __err) const\n     {\n       // As-is works for __len = 1, 2, 4, the values actually used.\n@@ -1815,37 +1815,37 @@ namespace std\n     void\n     time_get<_CharT, _InIter>::\n     _M_extract_name(iter_type& __beg, iter_type& __end, int& __member,\n-\t\t    const _CharT** __names, size_t __indexlen, \n-\t\t    const ctype<_CharT>& __ctype, \n+\t\t    const _CharT** __names, size_t __indexlen,\n+\t\t    const ctype<_CharT>& __ctype,\n \t\t    ios_base::iostate& __err) const\n     {\n-      typedef char_traits<_CharT> \t\t__traits_type;\n-      int* __matches = static_cast<int*>(__builtin_alloca(sizeof(int) \n+      typedef char_traits<_CharT>\t\t__traits_type;\n+      int* __matches = static_cast<int*>(__builtin_alloca(sizeof(int)\n \t\t\t\t\t\t\t  * __indexlen));\n       size_t __nmatches = 0;\n       size_t __pos = 0;\n       bool __testvalid = true;\n       const char_type* __name;\n \n-      // Look for initial matches.  \n+      // Look for initial matches.\n       // NB: Some of the locale data is in the form of all lowercase\n       // names, and some is in the form of initially-capitalized\n       // names. Look for both.\n       if (__beg != __end)\n \t{\n \t  const char_type __c = *__beg;\n \t  for (size_t __i1 = 0; __i1 < __indexlen; ++__i1)\n-\t    if (__c == __names[__i1][0] \n+\t    if (__c == __names[__i1][0]\n \t\t|| __c == __ctype.toupper(__names[__i1][0]))\n \t      __matches[__nmatches++] = __i1;\n \t}\n-      \n+\n       while (__nmatches > 1)\n \t{\n \t  // Find smallest matching string.\n \t  size_t __minlen = 10;\n \t  for (size_t __i2 = 0; __i2 < __nmatches; ++__i2)\n-\t    __minlen = std::min(__minlen, \n+\t    __minlen = std::min(__minlen,\n \t\t\t\t__traits_type::length(__names[__matches[__i2]]));\n \t  ++__beg;\n \t  if (__pos < __minlen && __beg != __end)\n@@ -1925,13 +1925,13 @@ namespace std\n   template<typename _CharT, typename _InIter>\n     _InIter\n     time_get<_CharT, _InIter>::\n-    do_get_weekday(iter_type __beg, iter_type __end, ios_base& __io, \n+    do_get_weekday(iter_type __beg, iter_type __end, ios_base& __io,\n \t\t   ios_base::iostate& __err, tm* __tm) const\n     {\n-      typedef char_traits<_CharT> \t\t__traits_type;\n+      typedef char_traits<_CharT>\t\t__traits_type;\n       const locale __loc = __io.getloc();\n       const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);\n-      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc); \n+      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n       const char_type*  __days[7];\n       __tp._M_days_abbreviated(__days);\n       int __tmpwday;\n@@ -1942,7 +1942,7 @@ namespace std\n       // exact same order, first to last, such that the resulting\n       // __days array with the same index points to a day, and that\n       // day's abbreviated form.\n-      // NB: Also assumes that an abbreviated name is a subset of the name. \n+      // NB: Also assumes that an abbreviated name is a subset of the name.\n       if (!__err)\n \t{\n \t  size_t __pos = __traits_type::length(__days[__tmpwday]);\n@@ -1952,7 +1952,7 @@ namespace std\n \t    {\n \t      // Extract the rest of it.\n \t      const size_t __len = __traits_type::length(__name);\n-\t      while (__pos < __len && __beg != __end \n+\t      while (__pos < __len && __beg != __end\n \t\t     && __name[__pos] == *__beg)\n \t\t++__beg, ++__pos;\n \t      if (__len != __pos)\n@@ -1972,10 +1972,10 @@ namespace std\n     do_get_monthname(iter_type __beg, iter_type __end,\n                      ios_base& __io, ios_base::iostate& __err, tm* __tm) const\n     {\n-      typedef char_traits<_CharT> \t\t__traits_type;\n+      typedef char_traits<_CharT>\t\t__traits_type;\n       const locale __loc = __io.getloc();\n       const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);\n-      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc); \n+      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n       const char_type*  __months[12];\n       __tp._M_months_abbreviated(__months);\n       int __tmpmon;\n@@ -1986,7 +1986,7 @@ namespace std\n       // exact same order, first to last, such that the resulting\n       // __months array with the same index points to a month, and that\n       // month's abbreviated form.\n-      // NB: Also assumes that an abbreviated name is a subset of the name. \n+      // NB: Also assumes that an abbreviated name is a subset of the name.\n       if (!__err)\n \t{\n \t  size_t __pos = __traits_type::length(__months[__tmpmon]);\n@@ -1996,7 +1996,7 @@ namespace std\n \t    {\n \t      // Extract the rest of it.\n \t      const size_t __len = __traits_type::length(__name);\n-\t      while (__pos < __len && __beg != __end \n+\t      while (__pos < __len && __beg != __end\n \t\t     && __name[__pos] == *__beg)\n \t\t++__beg, ++__pos;\n \t      if (__len != __pos)\n@@ -2005,7 +2005,7 @@ namespace std\n \t  if (!__err)\n \t    __tm->tm_mon = __tmpmon;\n \t}\n- \n+\n       if (__beg == __end)\n \t__err |= ios_base::eofbit;\n       return __beg;\n@@ -2014,11 +2014,11 @@ namespace std\n   template<typename _CharT, typename _InIter>\n     _InIter\n     time_get<_CharT, _InIter>::\n-    do_get_year(iter_type __beg, iter_type __end, ios_base& __io, \n+    do_get_year(iter_type __beg, iter_type __end, ios_base& __io,\n \t\tios_base::iostate& __err, tm* __tm) const\n     {\n       const locale __loc = __io.getloc();\n-      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc); \n+      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n \n       size_t __i = 0;\n       int __value = 0;\n@@ -2031,7 +2031,7 @@ namespace std\n \t    break;\n \t}\n       if (__i == 2 || __i == 4)\n-\t__tm->tm_year = __i == 2 ? __value : __value - 1900; \n+\t__tm->tm_year = __i == 2 ? __value : __value - 1900;\n       else\n \t__err |= ios_base::failbit;\n       if (__beg == __end)\n@@ -2042,7 +2042,7 @@ namespace std\n   template<typename _CharT, typename _OutIter>\n     _OutIter\n     time_put<_CharT, _OutIter>::\n-    put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm, \n+    put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,\n \tconst _CharT* __beg, const _CharT* __end) const\n     {\n       const locale __loc = __io.getloc();\n@@ -2078,9 +2078,9 @@ namespace std\n   template<typename _CharT, typename _OutIter>\n     _OutIter\n     time_put<_CharT, _OutIter>::\n-    do_put(iter_type __s, ios_base& __io, char_type, const tm* __tm, \n+    do_put(iter_type __s, ios_base& __io, char_type, const tm* __tm,\n \t   char __format, char __mod) const\n-    { \n+    {\n       const locale __loc = __io.getloc();\n       ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);\n       __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);\n@@ -2097,7 +2097,7 @@ namespace std\n       // format character: if __mod is not the default argument, assume\n       // it's a valid modifier.\n       char_type __fmt[4];\n-      __fmt[0] = __ctype.widen('%'); \n+      __fmt[0] = __ctype.widen('%');\n       if (!__mod)\n \t{\n \t  __fmt[1] = __format;\n@@ -2132,9 +2132,9 @@ namespace std\n   template<typename _CharT>\n     int\n     collate<_CharT>::\n-    do_compare(const _CharT* __lo1, const _CharT* __hi1, \n+    do_compare(const _CharT* __lo1, const _CharT* __hi1,\n \t       const _CharT* __lo2, const _CharT* __hi2) const\n-    { \n+    {\n       // strcoll assumes zero-terminated strings so we make a copy\n       // and then put a zero at the end.\n       const string_type __one(__lo1, __hi1);\n@@ -2197,7 +2197,7 @@ namespace std\n \t  if (__res >= __len)\n \t    {\n \t      __len = __res + 1;\n-\t      __c = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) \n+\t      __c = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)\n \t\t\t\t\t\t\t  * __len));\n \t      __res = _M_transform(__c, __p, __res + 1);\n \t    }\n@@ -2216,16 +2216,16 @@ namespace std\n     long\n     collate<_CharT>::\n     do_hash(const _CharT* __lo, const _CharT* __hi) const\n-    { \n+    {\n       unsigned long __val = 0;\n       for (; __lo < __hi; ++__lo)\n-\t__val = *__lo + ((__val << 7) | \n+\t__val = *__lo + ((__val << 7) |\n \t\t       (__val >> (numeric_limits<unsigned long>::digits - 7)));\n       return static_cast<long>(__val);\n     }\n \n   // Construct correctly padded string, as per 22.2.2.2.2\n-  // Assumes \n+  // Assumes\n   // __newlen > __oldlen\n   // __news is allocated for __newlen size\n   // Used by both num_put and ostream inserters: if __num,\n@@ -2236,10 +2236,10 @@ namespace std\n   // NB: Of the two parameters, _CharT can be deduced from the\n   // function arguments. The other (_Traits) has to be explicitly specified.\n   template<typename _CharT, typename _Traits>\n-    void \n-    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill, \n-\t\t\t\t   _CharT* __news, const _CharT* __olds, \n-\t\t\t\t   const streamsize __newlen, \n+    void\n+    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,\n+\t\t\t\t   _CharT* __news, const _CharT* __olds,\n+\t\t\t\t   const streamsize __newlen,\n \t\t\t\t   const streamsize __oldlen, const bool __num)\n     {\n       const size_t __plen = static_cast<size_t>(__newlen - __oldlen);\n@@ -2260,18 +2260,18 @@ namespace std\n \t  // Pad after 0[xX], if there is one.\n \t  // Who came up with these rules, anyway? Jeeze.\n           const locale& __loc = __io._M_getloc();\n-\t  const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc); \n+\t  const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n \t  const _CharT __minus = __ctype.widen('-');\n \t  const _CharT __plus = __ctype.widen('+');\n \t  const bool __testsign = _Traits::eq(__olds[0], __minus)\n \t                          || _Traits::eq(__olds[0], __plus);\n \n-\t  const bool __testhex = _Traits::eq(__ctype.widen('0'), __olds[0]) \n-\t                         && (_Traits::eq(__ctype.widen('x'), __olds[1]) \n+\t  const bool __testhex = _Traits::eq(__ctype.widen('0'), __olds[0])\n+\t                         && (_Traits::eq(__ctype.widen('x'), __olds[1])\n \t\t\t\t     || _Traits::eq(__ctype.widen('X'), __olds[1]));\n \t  if (__testhex)\n \t    {\n-\t      __news[0] = __olds[0]; \n+\t      __news[0] = __olds[0];\n \t      __news[1] = __olds[1];\n \t      __mod = 2;\n \t      __news += 2;\n@@ -2292,7 +2292,7 @@ namespace std\n   bool\n   __verify_grouping(const char* __grouping, size_t __grouping_size,\n \t\t    const string& __grouping_tmp)\n-    { \n+    {\n       const size_t __n = __grouping_tmp.size() - 1;\n       const size_t __min = std::min(__n, __grouping_size - 1);\n       size_t __i = __n;\n@@ -2333,7 +2333,7 @@ namespace std\n     }\n \n   // Inhibit implicit instantiations for required instantiations,\n-  // which are defined via explicit instantiations elsewhere.  \n+  // which are defined via explicit instantiations elsewhere.\n   // NB: This syntax is a GNU extension.\n #if _GLIBCXX_EXTERN_TEMPLATE\n   extern template class moneypunct<char, false>;\n@@ -2345,7 +2345,7 @@ namespace std\n   extern template class numpunct<char>;\n   extern template class numpunct_byname<char>;\n   extern template class num_get<char>;\n-  extern template class num_put<char>; \n+  extern template class num_put<char>;\n   extern template class __timepunct<char>;\n   extern template class time_put<char>;\n   extern template class time_put_byname<char>;\n@@ -2359,106 +2359,106 @@ namespace std\n   extern template class collate_byname<char>;\n \n   extern template\n-    const codecvt<char, char, mbstate_t>& \n+    const codecvt<char, char, mbstate_t>&\n     use_facet<codecvt<char, char, mbstate_t> >(const locale&);\n \n   extern template\n-    const collate<char>& \n+    const collate<char>&\n     use_facet<collate<char> >(const locale&);\n \n   extern template\n-    const numpunct<char>& \n+    const numpunct<char>&\n     use_facet<numpunct<char> >(const locale&);\n \n-  extern template \n-    const num_put<char>& \n+  extern template\n+    const num_put<char>&\n     use_facet<num_put<char> >(const locale&);\n \n-  extern template \n-    const num_get<char>& \n+  extern template\n+    const num_get<char>&\n     use_facet<num_get<char> >(const locale&);\n \n   extern template\n-    const moneypunct<char, true>& \n+    const moneypunct<char, true>&\n     use_facet<moneypunct<char, true> >(const locale&);\n \n   extern template\n-    const moneypunct<char, false>& \n+    const moneypunct<char, false>&\n     use_facet<moneypunct<char, false> >(const locale&);\n \n-  extern template \n-    const money_put<char>& \n+  extern template\n+    const money_put<char>&\n     use_facet<money_put<char> >(const locale&);\n \n-  extern template \n-    const money_get<char>& \n+  extern template\n+    const money_get<char>&\n     use_facet<money_get<char> >(const locale&);\n \n   extern template\n-    const __timepunct<char>& \n+    const __timepunct<char>&\n     use_facet<__timepunct<char> >(const locale&);\n \n-  extern template \n-    const time_put<char>& \n+  extern template\n+    const time_put<char>&\n     use_facet<time_put<char> >(const locale&);\n \n-  extern template \n-    const time_get<char>& \n+  extern template\n+    const time_get<char>&\n     use_facet<time_get<char> >(const locale&);\n \n-  extern template \n-    const messages<char>& \n+  extern template\n+    const messages<char>&\n     use_facet<messages<char> >(const locale&);\n \n-  extern template \n+  extern template\n     bool\n     has_facet<ctype<char> >(const locale&);\n \n-  extern template \n+  extern template\n     bool\n     has_facet<codecvt<char, char, mbstate_t> >(const locale&);\n \n-  extern template \n+  extern template\n     bool\n     has_facet<collate<char> >(const locale&);\n \n-  extern template \n+  extern template\n     bool\n     has_facet<numpunct<char> >(const locale&);\n \n-  extern template \n+  extern template\n     bool\n     has_facet<num_put<char> >(const locale&);\n \n-  extern template \n+  extern template\n     bool\n     has_facet<num_get<char> >(const locale&);\n \n-  extern template \n+  extern template\n     bool\n     has_facet<moneypunct<char> >(const locale&);\n \n-  extern template \n+  extern template\n     bool\n     has_facet<money_put<char> >(const locale&);\n \n-  extern template \n+  extern template\n     bool\n     has_facet<money_get<char> >(const locale&);\n \n-  extern template \n+  extern template\n     bool\n     has_facet<__timepunct<char> >(const locale&);\n \n-  extern template \n+  extern template\n     bool\n     has_facet<time_put<char> >(const locale&);\n \n-  extern template \n+  extern template\n     bool\n     has_facet<time_get<char> >(const locale&);\n \n-  extern template \n+  extern template\n     bool\n     has_facet<messages<char> >(const locale&);\n \n@@ -2486,106 +2486,106 @@ namespace std\n   extern template class collate_byname<wchar_t>;\n \n   extern template\n-    const codecvt<wchar_t, char, mbstate_t>& \n+    const codecvt<wchar_t, char, mbstate_t>&\n     use_facet<codecvt<wchar_t, char, mbstate_t> >(locale const&);\n \n   extern template\n-    const collate<wchar_t>& \n+    const collate<wchar_t>&\n     use_facet<collate<wchar_t> >(const locale&);\n \n   extern template\n-    const numpunct<wchar_t>& \n+    const numpunct<wchar_t>&\n     use_facet<numpunct<wchar_t> >(const locale&);\n \n-  extern template \n-    const num_put<wchar_t>& \n+  extern template\n+    const num_put<wchar_t>&\n     use_facet<num_put<wchar_t> >(const locale&);\n \n-  extern template \n-    const num_get<wchar_t>& \n+  extern template\n+    const num_get<wchar_t>&\n     use_facet<num_get<wchar_t> >(const locale&);\n \n   extern template\n-    const moneypunct<wchar_t, true>& \n+    const moneypunct<wchar_t, true>&\n     use_facet<moneypunct<wchar_t, true> >(const locale&);\n \n   extern template\n-    const moneypunct<wchar_t, false>& \n+    const moneypunct<wchar_t, false>&\n     use_facet<moneypunct<wchar_t, false> >(const locale&);\n- \n-  extern template \n-    const money_put<wchar_t>& \n+\n+  extern template\n+    const money_put<wchar_t>&\n     use_facet<money_put<wchar_t> >(const locale&);\n \n-  extern template \n-    const money_get<wchar_t>& \n+  extern template\n+    const money_get<wchar_t>&\n     use_facet<money_get<wchar_t> >(const locale&);\n \n   extern template\n-    const __timepunct<wchar_t>& \n+    const __timepunct<wchar_t>&\n     use_facet<__timepunct<wchar_t> >(const locale&);\n \n-  extern template \n-    const time_put<wchar_t>& \n+  extern template\n+    const time_put<wchar_t>&\n     use_facet<time_put<wchar_t> >(const locale&);\n \n-  extern template \n-    const time_get<wchar_t>& \n+  extern template\n+    const time_get<wchar_t>&\n     use_facet<time_get<wchar_t> >(const locale&);\n \n-  extern template \n-    const messages<wchar_t>& \n+  extern template\n+    const messages<wchar_t>&\n     use_facet<messages<wchar_t> >(const locale&);\n \n- extern template \n+ extern template\n     bool\n     has_facet<ctype<wchar_t> >(const locale&);\n \n-  extern template \n+  extern template\n     bool\n     has_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);\n \n-  extern template \n+  extern template\n     bool\n     has_facet<collate<wchar_t> >(const locale&);\n \n-  extern template \n+  extern template\n     bool\n     has_facet<numpunct<wchar_t> >(const locale&);\n \n-  extern template \n+  extern template\n     bool\n     has_facet<num_put<wchar_t> >(const locale&);\n \n-  extern template \n+  extern template\n     bool\n     has_facet<num_get<wchar_t> >(const locale&);\n \n-  extern template \n+  extern template\n     bool\n     has_facet<moneypunct<wchar_t> >(const locale&);\n \n-  extern template \n+  extern template\n     bool\n     has_facet<money_put<wchar_t> >(const locale&);\n \n-  extern template \n+  extern template\n     bool\n     has_facet<money_get<wchar_t> >(const locale&);\n \n-  extern template \n+  extern template\n     bool\n     has_facet<__timepunct<wchar_t> >(const locale&);\n \n-  extern template \n+  extern template\n     bool\n     has_facet<time_put<wchar_t> >(const locale&);\n \n-  extern template \n+  extern template\n     bool\n     has_facet<time_get<wchar_t> >(const locale&);\n \n-  extern template \n+  extern template\n     bool\n     has_facet<messages<wchar_t> >(const locale&);\n #endif"}, {"sha": "247158df374c442406e8892f582c74b3ca32c987", "filename": "libstdc++-v3/include/bits/localefwd.h", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocalefwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocalefwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocalefwd.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -44,7 +44,7 @@\n \n #include <bits/c++config.h>\n #include <bits/c++locale.h>     // Defines __c_locale, config-specific includes\n-#include <iosfwd> \t\t// For ostreambuf_iterator, istreambuf_iterator\n+#include <iosfwd>\t\t// For ostreambuf_iterator, istreambuf_iterator\n #include <bits/functexcept.h>\n \n namespace std\n@@ -53,67 +53,67 @@ namespace std\n   class locale;\n \n   // 22.1.3 Convenience interfaces\n-  template<typename _CharT> \n-    inline bool \n+  template<typename _CharT>\n+    inline bool\n     isspace(_CharT, const locale&);\n \n-  template<typename _CharT> \n-    inline bool \n+  template<typename _CharT>\n+    inline bool\n     isprint(_CharT, const locale&);\n \n-  template<typename _CharT> \n-    inline bool \n+  template<typename _CharT>\n+    inline bool\n     iscntrl(_CharT, const locale&);\n \n-  template<typename _CharT> \n-    inline bool \n+  template<typename _CharT>\n+    inline bool\n     isupper(_CharT, const locale&);\n \n-  template<typename _CharT> \n-    inline bool \n+  template<typename _CharT>\n+    inline bool\n     islower(_CharT, const locale&);\n \n-  template<typename _CharT> \n-    inline bool \n+  template<typename _CharT>\n+    inline bool\n     isalpha(_CharT, const locale&);\n \n-  template<typename _CharT> \n-    inline bool \n+  template<typename _CharT>\n+    inline bool\n     isdigit(_CharT, const locale&);\n \n-  template<typename _CharT> \n-    inline bool \n+  template<typename _CharT>\n+    inline bool\n     ispunct(_CharT, const locale&);\n \n-  template<typename _CharT> \n-    inline bool \n+  template<typename _CharT>\n+    inline bool\n     isxdigit(_CharT, const locale&);\n \n-  template<typename _CharT> \n-    inline bool \n+  template<typename _CharT>\n+    inline bool\n     isalnum(_CharT, const locale&);\n \n-  template<typename _CharT> \n-    inline bool \n+  template<typename _CharT>\n+    inline bool\n     isgraph(_CharT, const locale&);\n \n-  template<typename _CharT> \n-    inline _CharT \n+  template<typename _CharT>\n+    inline _CharT\n     toupper(_CharT, const locale&);\n \n-  template<typename _CharT> \n-    inline _CharT \n+  template<typename _CharT>\n+    inline _CharT\n     tolower(_CharT, const locale&);\n \n   // 22.2.1 and 22.2.1.3 ctype\n   class ctype_base;\n-  template<typename _CharT> \n+  template<typename _CharT>\n     class ctype;\n   template<> class ctype<char>;\n #ifdef _GLIBCXX_USE_WCHAR_T\n   template<> class ctype<wchar_t>;\n #endif\n-  template<typename _CharT> \n+  template<typename _CharT>\n     class ctype_byname;\n   // NB: Specialized for char and wchar_t in locale_facets.h.\n \n@@ -137,9 +137,9 @@ namespace std\n   template<typename _CharT> class numpunct_byname;\n \n   // 22.2.4 collation\n-  template<typename _CharT> \n+  template<typename _CharT>\n     class collate;\n-  template<typename _CharT> class \n+  template<typename _CharT> class\n     collate_byname;\n \n   // 22.2.5 date and time\n@@ -159,16 +159,16 @@ namespace std\n     class money_get;\n   template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >\n     class money_put;\n-  template<typename _CharT, bool _Intl = false> \n+  template<typename _CharT, bool _Intl = false>\n     class moneypunct;\n-  template<typename _CharT, bool _Intl = false> \n+  template<typename _CharT, bool _Intl = false>\n     class moneypunct_byname;\n \n   // 22.2.7 message retrieval\n   class messages_base;\n-  template<typename _CharT> \n+  template<typename _CharT>\n     class messages;\n-  template<typename _CharT> \n+  template<typename _CharT>\n     class messages_byname;\n \n   template<typename _Facet>\n@@ -182,9 +182,9 @@ namespace std\n   template<typename _Facet>\n     inline const _Facet&\n     __check_facet(const _Facet* __f)\n-    { \n+    {\n       if (!__f)\n-\t__throw_bad_cast(); \n+\t__throw_bad_cast();\n       return *__f;\n     }\n } // namespace std"}, {"sha": "ce13c1a99206ac9ec1064b64b572630d3fc3ee40", "filename": "libstdc++-v3/include/bits/mask_array.h", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmask_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmask_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmask_array.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -57,23 +57,23 @@ namespace std {\n    *\n    *  @param  Tp  Element type.\n    */\n-  template <class _Tp> \n+  template <class _Tp>\n     class mask_array\n-    { \n+    {\n     public:\n       typedef _Tp value_type;\n-    \n+\n       void operator=(const valarray<_Tp>&) const;\n       ///  Multiply slice elements by corresponding elements of @a v.\n       void operator*=(const valarray<_Tp>&) const;\n       ///  Divide slice elements by corresponding elements of @a v.\n       void operator/=(const valarray<_Tp>&) const;\n       ///  Modulo slice elements by corresponding elements of @a v.\n-      void operator%=(const valarray<_Tp>&) const; \n+      void operator%=(const valarray<_Tp>&) const;\n       ///  Add corresponding elements of @a v to slice elements.\n       void operator+=(const valarray<_Tp>&) const;\n       ///  Subtract corresponding elements of @a v from slice elements.\n-      void operator-=(const valarray<_Tp>&) const;  \n+      void operator-=(const valarray<_Tp>&) const;\n       ///  Logical xor slice elements with corresponding elements of @a v.\n       void operator^=(const valarray<_Tp>&) const;\n       ///  Logical and slice elements with corresponding elements of @a v.\n@@ -83,12 +83,12 @@ namespace std {\n       ///  Left shift slice elements by corresponding elements of @a v.\n       void operator<<=(const valarray<_Tp>&) const;\n       ///  Right shift slice elements by corresponding elements of @a v.\n-      void operator>>=(const valarray<_Tp>&) const; \n+      void operator>>=(const valarray<_Tp>&) const;\n       ///  Assign all slice elements to @a t.\n       void operator=(const _Tp&) const;\n-    \n+\n         //        ~mask_array ();\n-        \n+\n       template<class _Dom>\n         void operator=(const _Expr<_Dom,_Tp>&) const;\n       template<class _Dom>\n@@ -110,19 +110,19 @@ namespace std {\n       template<class _Dom>\n         void operator<<=(const _Expr<_Dom,_Tp>&) const;\n       template<class _Dom>\n-        void operator>>=(const _Expr<_Dom,_Tp>&) const; \n+        void operator>>=(const _Expr<_Dom,_Tp>&) const;\n \n     private:\n       mask_array(_Array<_Tp>, size_t, _Array<bool>);\n       friend class valarray<_Tp>;\n-        \n+\n       const size_t       _M_sz;\n       const _Array<bool> _M_mask;\n       const _Array<_Tp>   _M_array;\n-      \n+\n       ///  Copy constructor.  Both slices refer to the same underlying array.\n       mask_array (const mask_array&);\n-      \n+\n       // not implemented\n       mask_array();\n \n@@ -137,15 +137,15 @@ namespace std {\n       : _M_sz(a._M_sz), _M_mask(a._M_mask), _M_array(a._M_array) {}\n \n   template<typename _Tp>\n-    inline \n+    inline\n     mask_array<_Tp>::mask_array(_Array<_Tp> __a, size_t __s, _Array<bool> __m)\n       : _M_sz(__s), _M_mask(__m), _M_array(__a) {}\n-    \n+\n   template<typename _Tp>\n     inline void\n     mask_array<_Tp>::operator=(const _Tp& __t) const\n     { std::__valarray_fill(_M_array, _M_sz, _M_mask, __t); }\n-    \n+\n   template<typename _Tp>\n     inline void\n     mask_array<_Tp>::operator=(const valarray<_Tp>& __v) const\n@@ -186,8 +186,8 @@ _DEFINE_VALARRAY_OPERATOR(|, __bitwise_or)\n _DEFINE_VALARRAY_OPERATOR(<<, __shift_left)\n _DEFINE_VALARRAY_OPERATOR(>>, __shift_right)\n \n-#undef _DEFINE_VALARRAY_OPERATOR    \n-    \n+#undef _DEFINE_VALARRAY_OPERATOR\n+\n } // std::\n \n #endif /* _MASK_ARRAY_H */"}, {"sha": "1ff14a66ae341739775e5b34004affc23ac9f149", "filename": "libstdc++-v3/include/bits/ostream.tcc", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream.tcc?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -39,7 +39,7 @@\n \n #include <locale>\n \n-namespace std \n+namespace std\n {\n   template<typename _CharT, typename _Traits>\n     basic_ostream<_CharT, _Traits>::sentry::\n@@ -58,9 +58,9 @@ namespace std\n \t  __os.setstate(ios_base::failbit);\n \t}\n     }\n-  \n+\n   template<typename _CharT, typename _Traits>\n-    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>&\n     basic_ostream<_CharT, _Traits>::\n     operator<<(__ostream_type& (*__pf)(__ostream_type&))\n     {\n@@ -69,9 +69,9 @@ namespace std\n       // The inserters for manipulators are *not* formatted output functions.\n       return __pf(*this);\n     }\n-  \n+\n   template<typename _CharT, typename _Traits>\n-    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>&\n     basic_ostream<_CharT, _Traits>::\n     operator<<(__ios_type& (*__pf)(__ios_type&))\n     {\n@@ -83,7 +83,7 @@ namespace std\n     }\n \n   template<typename _CharT, typename _Traits>\n-    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>&\n     basic_ostream<_CharT, _Traits>::\n     operator<<(ios_base& (*__pf)(ios_base&))\n     {\n@@ -95,15 +95,15 @@ namespace std\n     }\n \n   template<typename _CharT, typename _Traits>\n-    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>&\n     basic_ostream<_CharT, _Traits>::\n     operator<<(bool __n)\n     {\n       sentry __cerb(*this);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n \t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t  try \n+\t  try\n \t    {\n \t      const __num_put_type& __np = __check_facet(this->_M_num_put);\n \t      if (__np.put(*this, *this, this->fill(), __n).failed())\n@@ -118,15 +118,15 @@ namespace std\n     }\n \n   template<typename _CharT, typename _Traits>\n-    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>&\n     basic_ostream<_CharT, _Traits>::\n     operator<<(long __n)\n     {\n       sentry __cerb(*this);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n \t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t  try \n+\t  try\n \t    {\n \t      bool __b = false;\n \t      char_type __c = this->fill();\n@@ -139,7 +139,7 @@ namespace std\n \t\t}\n \t      else\n \t\t__b = __np.put(*this, *this, __c, __n).failed();\n-\t      if (__b)  \n+\t      if (__b)\n \t\t__err |= ios_base::badbit;\n \t    }\n \t  catch(...)\n@@ -151,15 +151,15 @@ namespace std\n     }\n \n   template<typename _CharT, typename _Traits>\n-    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>&\n     basic_ostream<_CharT, _Traits>::\n     operator<<(unsigned long __n)\n     {\n       sentry __cerb(*this);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n \t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t  try \n+\t  try\n \t    {\n \t      const __num_put_type& __np = __check_facet(this->_M_num_put);\n \t      if (__np.put(*this, *this, this->fill(), __n).failed())\n@@ -175,15 +175,15 @@ namespace std\n \n #ifdef _GLIBCXX_USE_LONG_LONG\n   template<typename _CharT, typename _Traits>\n-    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>&\n     basic_ostream<_CharT, _Traits>::\n     operator<<(long long __n)\n     {\n       sentry __cerb(*this);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n \t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t  try \n+\t  try\n \t    {\n \t      bool __b = false;\n \t      char_type __c = this->fill();\n@@ -197,7 +197,7 @@ namespace std\n \t\t}\n \t      else\n \t\t__b = __np.put(*this, *this, __c, __n).failed();\n-\t      if (__b)  \n+\t      if (__b)\n \t\t__err |= ios_base::badbit;\n \t    }\n \t  catch(...)\n@@ -209,15 +209,15 @@ namespace std\n     }\n \n   template<typename _CharT, typename _Traits>\n-    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>&\n     basic_ostream<_CharT, _Traits>::\n     operator<<(unsigned long long __n)\n     {\n       sentry __cerb(*this);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n \t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t  try \n+\t  try\n \t    {\n \t      const __num_put_type& __np = __check_facet(this->_M_num_put);\n \t      if (__np.put(*this, *this, this->fill(), __n).failed())\n@@ -231,17 +231,17 @@ namespace std\n       return *this;\n     }\n #endif\n-  \n+\n   template<typename _CharT, typename _Traits>\n-    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>&\n     basic_ostream<_CharT, _Traits>::\n     operator<<(double __n)\n     {\n       sentry __cerb(*this);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n \t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t  try \n+\t  try\n \t    {\n \t      const __num_put_type& __np = __check_facet(this->_M_num_put);\n \t      if (__np.put(*this, *this, this->fill(), __n).failed())\n@@ -254,17 +254,17 @@ namespace std\n \t}\n       return *this;\n     }\n-  \n+\n   template<typename _CharT, typename _Traits>\n-    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>&\n     basic_ostream<_CharT, _Traits>::\n     operator<<(long double __n)\n     {\n       sentry __cerb(*this);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n \t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t  try \n+\t  try\n \t    {\n \t      const __num_put_type& __np = __check_facet(this->_M_num_put);\n \t      if (__np.put(*this, *this, this->fill(), __n).failed())\n@@ -279,15 +279,15 @@ namespace std\n     }\n \n   template<typename _CharT, typename _Traits>\n-    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>&\n     basic_ostream<_CharT, _Traits>::\n     operator<<(const void* __n)\n     {\n       sentry __cerb(*this);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n \t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t  try \n+\t  try\n \t    {\n \t      const __num_put_type& __np = __check_facet(this->_M_num_put);\n \t      if (__np.put(*this, *this, this->fill(), __n).failed())\n@@ -302,7 +302,7 @@ namespace std\n     }\n \n   template<typename _CharT, typename _Traits>\n-    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>&\n     basic_ostream<_CharT, _Traits>::\n     operator<<(__streambuf_type* __sbin)\n     {\n@@ -329,20 +329,20 @@ namespace std\n     basic_ostream<_CharT, _Traits>&\n     basic_ostream<_CharT, _Traits>::\n     put(char_type __c)\n-    { \n+    {\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // DR 60. What is a formatted input function?\n       // basic_ostream::put(char_type) is an unformatted output function.\n       // DR 63. Exception-handling policy for unformatted output.\n       // Unformatted output functions should catch exceptions thrown\n       // from streambuf members.\n       sentry __cerb(*this);\n-      if (__cerb) \n+      if (__cerb)\n \t{\n \t  ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n \t  try\n \t    {\n-\t      int_type __put = this->rdbuf()->sputc(__c); \n+\t      int_type __put = this->rdbuf()->sputc(__c);\n \t      if (traits_type::eq_int_type(__put, traits_type::eof()))\n \t\t__err |= ios_base::badbit;\n \t    }\n@@ -351,7 +351,7 @@ namespace std\n \t  if (__err)\n \t    this->setstate(__err);\n \t}\n-      return *this;  \n+      return *this;\n     }\n \n   template<typename _CharT, typename _Traits>\n@@ -397,7 +397,7 @@ namespace std\n \tthis->setstate(__err);\n       return *this;\n     }\n-  \n+\n   template<typename _CharT, typename _Traits>\n     typename basic_ostream<_CharT, _Traits>::pos_type\n     basic_ostream<_CharT, _Traits>::\n@@ -427,7 +427,7 @@ namespace std\n \t      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t      // 136.  seekp, seekg setting wrong streams?\n \t      pos_type __p = this->rdbuf()->pubseekpos(__pos, ios_base::out);\n-\t      \n+\n \t      // 129. Need error indication from seekp() and seekg()\n \t      if (__p == pos_type(off_type(-1)))\n \t\t__err |= ios_base::failbit;\n@@ -452,9 +452,9 @@ namespace std\n \t    {\n \t      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t      // 136.  seekp, seekg setting wrong streams?\n-\t      pos_type __p = this->rdbuf()->pubseekoff(__off, __dir, \n+\t      pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,\n \t\t\t\t\t\t       ios_base::out);\n-\t      \n+\n \t      // 129. Need error indication from seekp() and seekg()\n \t      if (__p == pos_type(off_type(-1)))\n \t\t__err |= ios_base::failbit;\n@@ -476,7 +476,7 @@ namespace std\n       typename __ostream_type::sentry __cerb(__out);\n       if (__cerb)\n \t{\n-\t  try \n+\t  try\n \t    {\n \t      const streamsize __w = __out.width();\n \t      streamsize __len = 1;\n@@ -485,7 +485,7 @@ namespace std\n \t\t{\n \t\t  __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)\n \t\t\t\t\t\t\t       * __w));\n-\t\t  __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __cs, \n+\t\t  __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __cs,\n \t\t\t\t\t\t &__c, __w, __len, false);\n \t\t  __len = __w;\n \t\t}\n@@ -497,25 +497,25 @@ namespace std\n \t}\n       return __out;\n     }\n-  \n+\n   // Specializations.\n-  template <class _Traits> \n+  template <class _Traits>\n     basic_ostream<char, _Traits>&\n     operator<<(basic_ostream<char, _Traits>& __out, char __c)\n     {\n       typedef basic_ostream<char, _Traits> __ostream_type;\n       typename __ostream_type::sentry __cerb(__out);\n       if (__cerb)\n \t{\n-\t  try \n+\t  try\n \t    {\n \t      const streamsize __w = __out.width();\n \t      streamsize __len = 1;\n \t      char* __cs = &__c;\n \t      if (__w > __len)\n \t\t{\n \t\t  __cs = static_cast<char*>(__builtin_alloca(__w));\n-\t\t  __pad<char, _Traits>::_S_pad(__out, __out.fill(), __cs, \n+\t\t  __pad<char, _Traits>::_S_pad(__out, __out.fill(), __cs,\n \t\t\t\t\t       &__c, __w, __len, false);\n \t\t  __len = __w;\n \t\t}\n@@ -536,15 +536,15 @@ namespace std\n       typename __ostream_type::sentry __cerb(__out);\n       if (__cerb && __s)\n \t{\n-\t  try \n+\t  try\n \t    {\n \t      const streamsize __w = __out.width();\n \t      streamsize __len = static_cast<streamsize>(_Traits::length(__s));\n \t      if (__w > __len)\n \t\t{\n \t\t  _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)\n \t\t\t\t\t\t\t\t       * __w));\n-\t\t  __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __cs, \n+\t\t  __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __cs,\n \t\t\t\t\t\t __s, __w, __len, false);\n \t\t  __s = __cs;\n \t\t  __len = __w;\n@@ -578,16 +578,16 @@ namespace std\n \t  for (size_t  __i = 0; __i < __clen; ++__i)\n \t    __ws[__i] = __out.widen(__s[__i]);\n \t  _CharT* __str = __ws;\n-\t  \n-\t  try \n+\n+\t  try\n \t    {\n \t      const streamsize __w = __out.width();\n \t      streamsize __len = static_cast<streamsize>(__clen);\n \t      if (__w > __len)\n \t\t{\n \t\t  _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)\n \t\t\t\t\t\t\t\t       * __w));\n-\t\t  __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __cs, \n+\t\t  __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __cs,\n \t\t\t\t\t\t __ws, __w, __len, false);\n \t\t  __str = __cs;\n \t\t  __len = __w;\n@@ -612,14 +612,14 @@ namespace std\n       typename __ostream_type::sentry __cerb(__out);\n       if (__cerb && __s)\n \t{\n-\t  try \n+\t  try\n \t    {\n \t      const streamsize __w = __out.width();\n \t      streamsize __len = static_cast<streamsize>(_Traits::length(__s));\n \t      if (__w > __len)\n \t\t{\n \t\t  char* __cs = static_cast<char*>(__builtin_alloca(__w));\n-\t\t  __pad<char, _Traits>::_S_pad(__out, __out.fill(), __cs, \n+\t\t  __pad<char, _Traits>::_S_pad(__out, __out.fill(), __cs,\n \t\t\t\t\t\t __s, __w, __len, false);\n \t\t  __s = __cs;\n \t\t  __len = __w;\n@@ -640,7 +640,7 @@ namespace std\n     basic_ostream<_CharT, _Traits>&\n     operator<<(basic_ostream<_CharT, _Traits>& __out,\n \t       const basic_string<_CharT, _Traits, _Alloc>& __str)\n-    { \n+    {\n       typedef basic_ostream<_CharT, _Traits> __ostream_type;\n       typename __ostream_type::sentry __cerb(__out);\n       if (__cerb)\n@@ -666,7 +666,7 @@ namespace std\n     }\n \n   // Inhibit implicit instantiations for required instantiations,\n-  // which are defined via explicit instantiations elsewhere.  \n+  // which are defined via explicit instantiations elsewhere.\n   // NB:  This syntax is a GNU extension.\n #if _GLIBCXX_EXTERN_TEMPLATE\n   extern template class basic_ostream<char>;"}, {"sha": "5db3d7b1d596994805706902c816c97914b2aa6f", "filename": "libstdc++-v3/include/bits/postypes.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fpostypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fpostypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fpostypes.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -158,8 +158,8 @@ namespace std\n     private:\n       friend class streamoff;\n \n-      __streamoff_base_type \t_M_off;\n-      _StateT \t\t\t_M_state;\n+      __streamoff_base_type\t_M_off;\n+      _StateT\t\t\t_M_state;\n \n     public:\n       // The standard doesn't require that fpos objects can be default"}, {"sha": "571296d9c573b31997f32d4f2d1ffd1e8fc78458", "filename": "libstdc++-v3/include/bits/slice_array.h", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fslice_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fslice_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fslice_array.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -69,14 +69,14 @@ namespace std\n      *  @param  s  Stride between array elements.\n      */\n     slice(size_t, size_t, size_t);\n-    \n+\n     ///  Return array offset of first slice element.\n     size_t start() const;\n     ///  Return size of slice.\n     size_t size() const;\n     ///  Return array stride of slice.\n     size_t stride() const;\n-    \n+\n   private:\n     size_t _M_off;                      // offset\n     size_t _M_sz;\t\t\t// size\n@@ -85,21 +85,21 @@ namespace std\n \n   // The default constructor constructor is not required to initialize\n   // data members with any meaningful values, so we choose to do nothing.\n-  inline \n+  inline\n   slice::slice() {}\n-  \n-  inline \n+\n+  inline\n   slice::slice(size_t __o, size_t __d, size_t __s)\n     : _M_off(__o), _M_sz(__d), _M_st(__s) {}\n-  \n+\n   inline size_t\n   slice::start() const\n   { return _M_off; }\n-  \n+\n   inline size_t\n   slice::size() const\n   { return _M_sz; }\n-  \n+\n   inline size_t\n   slice::stride() const\n   { return _M_st; }\n@@ -194,16 +194,16 @@ namespace std\n     };\n \n   template<typename _Tp>\n-    inline \n+    inline\n     slice_array<_Tp>::slice_array(_Array<_Tp> __a, const slice& __s)\n       : _M_sz(__s.size()), _M_stride(__s.stride()),\n \t_M_array(__a.begin() + __s.start()) {}\n \n   template<typename _Tp>\n-    inline \n+    inline\n     slice_array<_Tp>::slice_array(const slice_array<_Tp>& a)\n       : _M_sz(a._M_sz), _M_stride(a._M_stride), _M_array(a._M_array) {}\n-    \n+\n   //    template<typename _Tp>\n   //    inline slice_array<_Tp>::~slice_array () {}\n \n@@ -220,12 +220,12 @@ namespace std\n     inline void\n     slice_array<_Tp>::operator=(const _Tp& __t) const\n     { std::__valarray_fill(_M_array, _M_sz, _M_stride, __t); }\n-    \n+\n   template<typename _Tp>\n     inline void\n     slice_array<_Tp>::operator=(const valarray<_Tp>& __v) const\n     { std::__valarray_copy(_Array<_Tp>(__v), _M_array, _M_sz, _M_stride); }\n-    \n+\n   template<typename _Tp>\n   template<class _Dom>\n     inline void\n@@ -248,7 +248,7 @@ namespace std\n       {\t\t\t\t\t\t\t\t\t\\\n \t  _Array_augmented_##_Name(_M_array, _M_stride, __e, _M_sz);\t\\\n       }\n-        \n+\n \n _DEFINE_VALARRAY_OPERATOR(*, __multiplies)\n _DEFINE_VALARRAY_OPERATOR(/, __divides)"}, {"sha": "df5e619a70dc011ff17c9ed37dfefd536d7aec4c", "filename": "libstdc++-v3/include/bits/sstream.tcc", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsstream.tcc?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -42,13 +42,13 @@\n namespace std\n {\n   template <class _CharT, class _Traits, class _Alloc>\n-    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type \n+    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type\n     basic_stringbuf<_CharT, _Traits, _Alloc>::\n     pbackfail(int_type __c)\n     {\n       int_type __ret = traits_type::eof();\n       const bool __testeof = traits_type::eq_int_type(__c, __ret);\n-      \n+\n       if (this->eback() < this->gptr())\n \t{\n \t  const bool __testeq = traits_type::eq(traits_type::to_char_type(__c),\n@@ -69,9 +69,9 @@ namespace std\n \t}\n       return __ret;\n     }\n-  \n+\n   template <class _CharT, class _Traits, class _Alloc>\n-    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type \n+    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type\n     basic_stringbuf<_CharT, _Traits, _Alloc>::\n     overflow(int_type __c)\n     {\n@@ -111,7 +111,7 @@ namespace std\n     }\n \n   template <class _CharT, class _Traits, class _Alloc>\n-    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type \n+    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type\n     basic_stringbuf<_CharT, _Traits, _Alloc>::\n     underflow()\n     {\n@@ -132,7 +132,7 @@ namespace std\n     basic_stringbuf<_CharT, _Traits, _Alloc>::\n     seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)\n     {\n-      pos_type __ret =  pos_type(off_type(-1)); \n+      pos_type __ret =  pos_type(off_type(-1));\n       bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;\n       bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;\n       const bool __testboth = __testin && __testout && __way != ios_base::cur;\n@@ -156,14 +156,14 @@ namespace std\n \t    __newoffo = __newoffi = this->egptr() - __beg;\n \n \t  if ((__testin || __testboth)\n-\t      && __newoffi + __off >= 0 \n+\t      && __newoffi + __off >= 0\n \t      && this->egptr() - __beg >= __newoffi + __off)\n \t    {\n \t      this->gbump((__beg + __newoffi + __off) - this->gptr());\n \t      __ret = pos_type(__newoffi);\n \t    }\n \t  if ((__testout || __testboth)\n-\t      && __newoffo + __off >= 0 \n+\t      && __newoffo + __off >= 0\n \t      && this->egptr() - __beg >= __newoffo + __off)\n \t    {\n \t      this->pbump((__beg + __newoffo + __off) - this->pptr());\n@@ -178,14 +178,14 @@ namespace std\n     basic_stringbuf<_CharT, _Traits, _Alloc>::\n     seekpos(pos_type __sp, ios_base::openmode __mode)\n     {\n-      pos_type __ret =  pos_type(off_type(-1));       \n+      pos_type __ret =  pos_type(off_type(-1));\n       if (_M_string.capacity())\n \t{\n \t  off_type __pos (__sp);\n \t  const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;\n \t  const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;\n \t  char_type* __beg = __testin ? this->eback() : this->pbase();\n-\t  \n+\n \t  _M_update_egptr();\n \n \t  const bool __testpos = 0 <= __pos\n@@ -203,7 +203,7 @@ namespace std\n     }\n \n   // Inhibit implicit instantiations for required instantiations,\n-  // which are defined via explicit instantiations elsewhere.  \n+  // which are defined via explicit instantiations elsewhere.\n   // NB:  This syntax is a GNU extension.\n #if _GLIBCXX_EXTERN_TEMPLATE\n   extern template class basic_stringbuf<char>;"}, {"sha": "6fed5786ebd10b75c500bf31e82b826737cef286", "filename": "libstdc++-v3/include/bits/stl_algo.h", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -211,7 +211,7 @@ namespace std\n \t  if (*__first == __val)\n \t    return __first;\n \t  ++__first;\n-\t  \n+\n \t  if (*__first == __val)\n \t    return __first;\n \t  ++__first;\n@@ -1624,7 +1624,7 @@ namespace std\n \t{\n \t  const _ValueType __tmp = *__first;\n \t  _RandomAccessIterator __p = __first;\n-\t  \n+\n \t  if (__k < __l)\n \t    {\n \t      for (_Distance __j = 0; __j < __l / __d; __j++)\n@@ -1652,7 +1652,7 @@ namespace std\n \t\t  __p -= __l;\n \t\t}\n \t    }\n-\t  \n+\n \t  *__p = __tmp;\n \t  ++__first;\n \t}\n@@ -1743,7 +1743,7 @@ namespace std\n \t    _RandomAccessIterator>)\n       __glibcxx_requires_valid_range(__first, __last);\n \n-      if (__first != __last) \n+      if (__first != __last)\n \tfor (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)\n \t  std::iter_swap(__i, __first + (std::rand() % ((__i - __first) + 1)));\n     }\n@@ -1850,7 +1850,7 @@ namespace std\n    *  @return  An iterator @p middle such that @p pred(i) is true for each\n    *  iterator @p i in the range @p [first,middle) and false for each @p i\n    *  in the range @p [middle,last).\n-   *  \n+   *\n    *  @p pred must not modify its operand. @p partition() does not preserve\n    *  the relative ordering of elements in each group, use\n    *  @p stable_partition() if this is needed.\n@@ -1959,7 +1959,7 @@ namespace std\n    *  @return  An iterator @p middle such that @p pred(i) is true for each\n    *  iterator @p i in the range @p [first,middle) and false for each @p i\n    *  in the range @p [middle,last).\n-   *  \n+   *\n    *  Performs the same function as @p partition() with the additional\n    *  guarantee that the relative ordering of elements in each group is\n    *  preserved, so any two elements @p x and @p y in the range\n@@ -2477,10 +2477,10 @@ namespace std\n \t    std::__unguarded_partition(__first, __last,\n \t\t\t\t       _ValueType(std::__median(*__first,\n \t\t\t\t\t\t\t\t*(__first\n-\t\t\t\t\t\t\t\t  + (__last \n-\t\t\t\t\t\t\t\t     - __first) \n+\t\t\t\t\t\t\t\t  + (__last\n+\t\t\t\t\t\t\t\t     - __first)\n \t\t\t\t\t\t\t\t  / 2),\n-\t\t\t\t\t\t\t\t*(__last \n+\t\t\t\t\t\t\t\t*(__last\n \t\t\t\t\t\t\t\t  - 1))));\n \t  std::__introsort_loop(__cut, __last, __depth_limit);\n \t  __last = __cut;\n@@ -3095,7 +3095,7 @@ namespace std\n \t  __first += __two_step;\n \t}\n       __step_size = std::min(_Distance(__last - __first), __step_size);\n-      \n+\n       std::merge(__first, __first + __step_size,\n \t\t __first + __step_size, __last,\n \t\t __result,\n@@ -3673,7 +3673,7 @@ namespace std\n    *\n    *  Rearranges the elements in the range @p [first,last) so that @p *nth\n    *  is the same element that would have been in that position had the\n-   *  whole sequence been sorted. \n+   *  whole sequence been sorted.\n    *  whole sequence been sorted. The elements either side of @p *nth are\n    *  not completely sorted, but for any iterator @i in the range\n    *  @p [first,nth) and any iterator @j in the range @p [nth,last) it\n@@ -3753,9 +3753,9 @@ namespace std\n \t  _RandomAccessIterator __cut =\n \t    std::__unguarded_partition(__first, __last,\n \t\t\t\t       _ValueType(std::__median(*__first,\n-\t\t\t\t\t\t\t\t*(__first \n+\t\t\t\t\t\t\t\t*(__first\n \t\t\t\t\t\t\t\t  + (__last\n-\t\t\t\t\t\t\t\t     - __first) \n+\t\t\t\t\t\t\t\t     - __first)\n \t\t\t\t\t\t\t\t  / 2),\n \t\t\t\t\t\t\t\t*(__last - 1),\n \t\t\t\t\t\t\t      __comp)), __comp);\n@@ -4160,15 +4160,15 @@ namespace std\n \t      *__result = *__first2;\n \t      ++__first2;\n \t    }\n-\t  else \n+\t  else\n \t    {\n \t      *__result = *__first1;\n \t      ++__first1;\n \t      ++__first2;\n \t    }\n \t  ++__result;\n \t}\n-      return std::copy(__first2, __last2, std::copy(__first1, __last1, \n+      return std::copy(__first2, __last2, std::copy(__first1, __last1,\n \t\t\t\t\t\t    __result));\n     }\n \n@@ -4225,7 +4225,7 @@ namespace std\n \n   /**\n    *  @brief Return the intersection of two sorted ranges using comparison\n-   *  functor. \n+   *  functor.\n    *  @param  first1  Start of first range.\n    *  @param  last1   End of first range.\n    *  @param  first2  Start of second range.\n@@ -4446,7 +4446,7 @@ namespace std\n \t    ++__first1;\n \t    ++__first2;\n \t  }\n-      return std::copy(__first2, __last2, std::copy(__first1, \n+      return std::copy(__first2, __last2, std::copy(__first1,\n \t\t\t\t\t\t    __last1, __result));\n     }\n \n@@ -4683,7 +4683,7 @@ namespace std\n    *  comparison functor.\n    *  @param  first  Start of range.\n    *  @param  last   End of range.\n-   *  @param  comp   \n+   *  @param  comp\n    *  @return  False if wrapped to first permutation, true otherwise.\n    *\n    *  Treats all permutations of the range [first,last) as a set of\n@@ -4794,7 +4794,7 @@ namespace std\n    *  comparison functor.\n    *  @param  first  Start of range.\n    *  @param  last   End of range.\n-   *  @param  comp   \n+   *  @param  comp\n    *  @return  False if wrapped to last permutation, true otherwise.\n    *\n    *  Treats all permutations of the range [first,last) as a set of\n@@ -5023,9 +5023,9 @@ namespace std\n   template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,\n \t   typename _BinaryPredicate>\n     _BidirectionalIterator1\n-    __find_end(_BidirectionalIterator1 __first1, \n+    __find_end(_BidirectionalIterator1 __first1,\n \t       _BidirectionalIterator1 __last1,\n-\t       _BidirectionalIterator2 __first2, \n+\t       _BidirectionalIterator2 __first2,\n \t       _BidirectionalIterator2 __last2,\n \t       bidirectional_iterator_tag, bidirectional_iterator_tag,\n \t       _BinaryPredicate __comp)"}, {"sha": "17c3007f1f4d2e8db27125e44812fb384bdc6777", "filename": "libstdc++-v3/include/bits/stl_algobase.h", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -126,7 +126,7 @@ namespace std\n     {\n       // concept requirements\n       __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)\n-      \n+\n       const _Tp __tmp = __a;\n       __a = __b;\n       __b = __tmp;\n@@ -169,7 +169,7 @@ namespace std\n   */\n   template<typename _Tp>\n     inline const _Tp&\n-    max(const _Tp& __a, const _Tp& __b) \n+    max(const _Tp& __a, const _Tp& __b)\n     {\n       // concept requirements\n       __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)\n@@ -242,7 +242,7 @@ namespace std\n     {\n       typedef typename iterator_traits<_RandomAccessIterator>::difference_type\n           _Distance;\n-      for (_Distance __n = __last - __first; __n > 0; --__n) \n+      for (_Distance __n = __last - __first; __n > 0; --__n)\n \t{\n \t  *__result = *__first;\n \t  ++__first;\n@@ -280,7 +280,7 @@ namespace std\n \n   template<typename _Tp>\n     inline _Tp*\n-    __copy_aux2(const _Tp* __first, const _Tp* __last, _Tp* __result, \n+    __copy_aux2(const _Tp* __first, const _Tp* __last, _Tp* __result,\n \t\t__true_type)\n     { return std::__copy_trivial(__first, __last, __result); }\n \n@@ -361,7 +361,7 @@ namespace std\n   template<typename _BidirectionalIterator1, typename _BidirectionalIterator2>\n     inline _BidirectionalIterator2\n     __copy_backward(_BidirectionalIterator1 __first,\n-\t\t    _BidirectionalIterator1 __last, \n+\t\t    _BidirectionalIterator1 __last,\n \t\t    _BidirectionalIterator2 __result,\n \t\t    bidirectional_iterator_tag)\n     {\n@@ -372,7 +372,7 @@ namespace std\n \n   template<typename _RandomAccessIterator, typename _BidirectionalIterator>\n     inline _BidirectionalIterator\n-    __copy_backward(_RandomAccessIterator __first, _RandomAccessIterator __last, \n+    __copy_backward(_RandomAccessIterator __first, _RandomAccessIterator __last,\n \t\t    _BidirectionalIterator __result, random_access_iterator_tag)\n     {\n       typename iterator_traits<_RandomAccessIterator>::difference_type __n;\n@@ -382,7 +382,7 @@ namespace std\n     }\n \n \n-  // This dispatch class is a workaround for compilers that do not \n+  // This dispatch class is a workaround for compilers that do not\n   // have partial ordering of function templates.  All we're doing is\n   // creating a specialization so that we can turn a call to copy_backward\n   // into a memmove whenever possible.\n@@ -391,9 +391,9 @@ namespace std\n     struct __copy_backward_dispatch\n     {\n       static _BidirectionalIterator2\n-      copy(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last, \n+      copy(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n \t   _BidirectionalIterator2 __result)\n-      { return std::__copy_backward(__first, __last, __result, \n+      { return std::__copy_backward(__first, __last, __result,\n \t\t\t\t    std::__iterator_category(__first)); }\n     };\n \n@@ -427,8 +427,8 @@ namespace std\n       typedef typename __type_traits<typename iterator_traits<_BI2>::value_type>\n \t\t\t    ::has_trivial_assignment_operator _Trivial;\n       return\n-\tstd::__copy_backward_dispatch<_BI1, _BI2, _Trivial>::copy(__first, \n-\t\t\t\t\t\t\t\t  __last, \n+\tstd::__copy_backward_dispatch<_BI1, _BI2, _Trivial>::copy(__first,\n+\t\t\t\t\t\t\t\t  __last,\n \t\t\t\t\t\t\t\t  __result);\n     }\n \n@@ -754,7 +754,7 @@ namespace std\n       __glibcxx_requires_valid_range(__first1, __last1);\n       __glibcxx_requires_valid_range(__first2, __last2);\n \n-      for (;__first1 != __last1 && __first2 != __last2; ++__first1, ++__first2) \n+      for (;__first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n \t{\n \t  if (*__first1 < *__first2)\n \t    return true;\n@@ -790,7 +790,7 @@ namespace std\n       __glibcxx_requires_valid_range(__first2, __last2);\n \n       for ( ; __first1 != __last1 && __first2 != __last2\n-\t    ; ++__first1, ++__first2) \n+\t    ; ++__first1, ++__first2)\n \t{\n \t  if (__comp(*__first1, *__first2))\n \t    return true;\n@@ -800,10 +800,10 @@ namespace std\n       return __first1 == __last1 && __first2 != __last2;\n     }\n \n-  inline bool \n-  lexicographical_compare(const unsigned char* __first1, \n+  inline bool\n+  lexicographical_compare(const unsigned char* __first1,\n \t\t\t  const unsigned char* __last1,\n-\t\t\t  const unsigned char* __first2, \n+\t\t\t  const unsigned char* __first2,\n \t\t\t  const unsigned char* __last2)\n   {\n     __glibcxx_requires_valid_range(__first1, __last1);\n@@ -838,4 +838,4 @@ namespace std\n \n } // namespace std\n \n-#endif \n+#endif"}, {"sha": "3ed04e5031be27cdbc8739b9aedc9f9085d3ba63", "filename": "libstdc++-v3/include/bits/stl_bvector.h", "status": "modified", "additions": 147, "deletions": 147, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -62,45 +62,45 @@\n #define _BVECTOR_H 1\n \n namespace __gnu_norm\n-{ \n+{\n   typedef unsigned long _Bit_type;\n   enum { _S_word_bit = int(CHAR_BIT * sizeof(_Bit_type)) };\n \n-  struct _Bit_reference \n+  struct _Bit_reference\n   {\n     _Bit_type * _M_p;\n     _Bit_type _M_mask;\n \n-    _Bit_reference(_Bit_type * __x, _Bit_type __y) \n+    _Bit_reference(_Bit_type * __x, _Bit_type __y)\n     : _M_p(__x), _M_mask(__y) { }\n \n     _Bit_reference() : _M_p(0), _M_mask(0) { }\n \n     operator bool() const { return !!(*_M_p & _M_mask); }\n \n-    _Bit_reference& \n+    _Bit_reference&\n     operator=(bool __x)\n     {\n-      if (__x)  \n+      if (__x)\n \t*_M_p |= _M_mask;\n-      else      \n+      else\n \t*_M_p &= ~_M_mask;\n       return *this;\n     }\n \n-    _Bit_reference& \n-    operator=(const _Bit_reference& __x) \n+    _Bit_reference&\n+    operator=(const _Bit_reference& __x)\n     { return *this = bool(__x); }\n \n-    bool \n+    bool\n     operator==(const _Bit_reference& __x) const\n     { return bool(*this) == bool(__x); }\n \n-    bool \n+    bool\n     operator<(const _Bit_reference& __x) const\n     { return !bool(*this) && bool(__x); }\n \n-    void \n+    void\n     flip() { *_M_p ^= _M_mask; }\n   };\n \n@@ -112,71 +112,71 @@ namespace __gnu_norm\n     _Bit_iterator_base(_Bit_type * __x, unsigned int __y)\n     : _M_p(__x), _M_offset(__y) { }\n \n-    void \n-    _M_bump_up() \n+    void\n+    _M_bump_up()\n     {\n-      if (_M_offset++ == _S_word_bit - 1) \n+      if (_M_offset++ == _S_word_bit - 1)\n \t{\n \t  _M_offset = 0;\n \t  ++_M_p;\n \t}\n     }\n \n-    void \n-    _M_bump_down() \n+    void\n+    _M_bump_down()\n     {\n-      if (_M_offset-- == 0) \n+      if (_M_offset-- == 0)\n \t{\n \t  _M_offset = _S_word_bit - 1;\n \t  --_M_p;\n \t}\n     }\n-    \n-    void \n-    _M_incr(ptrdiff_t __i) \n+\n+    void\n+    _M_incr(ptrdiff_t __i)\n     {\n       difference_type __n = __i + _M_offset;\n       _M_p += __n / _S_word_bit;\n       __n = __n % _S_word_bit;\n-      if (__n < 0) \n+      if (__n < 0)\n \t{\n \t  _M_offset = static_cast<unsigned int>(__n + _S_word_bit);\n \t  --_M_p;\n-\t} \n+\t}\n       else\n \t_M_offset = static_cast<unsigned int>(__n);\n     }\n-    \n-    bool \n-    operator==(const _Bit_iterator_base& __i) const \n+\n+    bool\n+    operator==(const _Bit_iterator_base& __i) const\n     { return _M_p == __i._M_p && _M_offset == __i._M_offset; }\n-    \n-    bool \n-    operator<(const _Bit_iterator_base& __i) const \n+\n+    bool\n+    operator<(const _Bit_iterator_base& __i) const\n     {\n       return _M_p < __i._M_p\n \t     || (_M_p == __i._M_p && _M_offset < __i._M_offset);\n     }\n \n-    bool \n-    operator!=(const _Bit_iterator_base& __i) const \n+    bool\n+    operator!=(const _Bit_iterator_base& __i) const\n     { return !(*this == __i); }\n-    \n-    bool \n-    operator>(const _Bit_iterator_base& __i) const \n+\n+    bool\n+    operator>(const _Bit_iterator_base& __i) const\n     { return __i < *this; }\n \n-    bool \n-    operator<=(const _Bit_iterator_base& __i) const \n+    bool\n+    operator<=(const _Bit_iterator_base& __i) const\n     { return !(__i < *this); }\n \n-    bool \n-    operator>=(const _Bit_iterator_base& __i) const \n+    bool\n+    operator>=(const _Bit_iterator_base& __i) const\n     { return !(*this < __i); }\n   };\n \n   inline ptrdiff_t\n-  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y) \n+  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)\n   {\n     return _S_word_bit * (__x._M_p - __y._M_p) + __x._M_offset - __y._M_offset;\n   }\n@@ -188,76 +188,76 @@ namespace __gnu_norm\n     typedef _Bit_iterator   iterator;\n \n     _Bit_iterator() : _Bit_iterator_base(0, 0) { }\n-    _Bit_iterator(_Bit_type * __x, unsigned int __y) \n+    _Bit_iterator(_Bit_type * __x, unsigned int __y)\n     : _Bit_iterator_base(__x, __y) { }\n-    \n-    reference \n+\n+    reference\n     operator*() const { return reference(_M_p, 1UL << _M_offset); }\n \n-    iterator& \n-    operator++() \n+    iterator&\n+    operator++()\n     {\n       _M_bump_up();\n       return *this;\n     }\n-    \n-    iterator \n-    operator++(int) \n+\n+    iterator\n+    operator++(int)\n     {\n       iterator __tmp = *this;\n       _M_bump_up();\n       return __tmp;\n     }\n \n-    iterator& \n-    operator--() \n+    iterator&\n+    operator--()\n     {\n       _M_bump_down();\n       return *this;\n     }\n \n-    iterator \n-    operator--(int) \n+    iterator\n+    operator--(int)\n     {\n       iterator __tmp = *this;\n       _M_bump_down();\n       return __tmp;\n     }\n \n-    iterator& \n-    operator+=(difference_type __i) \n+    iterator&\n+    operator+=(difference_type __i)\n     {\n       _M_incr(__i);\n       return *this;\n     }\n \n     iterator&\n-    operator-=(difference_type __i) \n+    operator-=(difference_type __i)\n     {\n       *this += -__i;\n       return *this;\n     }\n \n-    iterator \n-    operator+(difference_type __i) const \n+    iterator\n+    operator+(difference_type __i) const\n     {\n       iterator __tmp = *this;\n       return __tmp += __i;\n     }\n-    \n-    iterator \n-    operator-(difference_type __i) const \n+\n+    iterator\n+    operator-(difference_type __i) const\n     {\n       iterator __tmp = *this;\n       return __tmp -= __i;\n     }\n-    \n-    reference \n+\n+    reference\n     operator[](difference_type __i)\n     { return *(*this + __i); }\n   };\n-  \n-  inline _Bit_iterator \n+\n+  inline _Bit_iterator\n   operator+(ptrdiff_t __n, const _Bit_iterator& __x) { return __x + __n; }\n \n \n@@ -267,56 +267,56 @@ namespace __gnu_norm\n     typedef bool                 const_reference;\n     typedef const bool*          pointer;\n     typedef _Bit_const_iterator  const_iterator;\n-    \n+\n     _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }\n-    _Bit_const_iterator(_Bit_type * __x, unsigned int __y) \n+    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)\n     : _Bit_iterator_base(__x, __y) { }\n-    _Bit_const_iterator(const _Bit_iterator& __x) \n+    _Bit_const_iterator(const _Bit_iterator& __x)\n     : _Bit_iterator_base(__x._M_p, __x._M_offset) { }\n \n-    const_reference \n-    operator*() const \n+    const_reference\n+    operator*() const\n     { return _Bit_reference(_M_p, 1UL << _M_offset); }\n-    \n-    const_iterator& \n-    operator++() \n+\n+    const_iterator&\n+    operator++()\n     {\n       _M_bump_up();\n       return *this;\n     }\n \n-    const_iterator \n-    operator++(int) \n+    const_iterator\n+    operator++(int)\n     {\n       const_iterator __tmp = *this;\n       _M_bump_up();\n       return __tmp;\n     }\n \n-    const_iterator& \n-    operator--() \n+    const_iterator&\n+    operator--()\n     {\n       _M_bump_down();\n       return *this;\n     }\n \n-    const_iterator \n-    operator--(int) \n+    const_iterator\n+    operator--(int)\n     {\n       const_iterator __tmp = *this;\n       _M_bump_down();\n       return __tmp;\n     }\n \n-    const_iterator& \n-    operator+=(difference_type __i) \n+    const_iterator&\n+    operator+=(difference_type __i)\n     {\n       _M_incr(__i);\n       return *this;\n     }\n \n-    const_iterator& \n-    operator-=(difference_type __i) \n+    const_iterator&\n+    operator-=(difference_type __i)\n     {\n       *this += -__i;\n       return *this;\n@@ -327,20 +327,20 @@ namespace __gnu_norm\n       return __tmp += __i;\n     }\n \n-    const_iterator \n-    operator-(difference_type __i) const \n+    const_iterator\n+    operator-(difference_type __i) const\n     {\n       const_iterator __tmp = *this;\n       return __tmp -= __i;\n     }\n \n-    const_reference \n-    operator[](difference_type __i) \n+    const_reference\n+    operator[](difference_type __i)\n     { return *(*this + __i); }\n   };\n-  \n-  inline _Bit_const_iterator \n-  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x) \n+\n+  inline _Bit_const_iterator\n+  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)\n   { return __x + __n; }\n \n   template<class _Alloc>\n@@ -352,30 +352,30 @@ namespace __gnu_norm\n \n     public:\n       typedef _Alloc allocator_type;\n-      \n+\n       allocator_type\n-      get_allocator() const \n+      get_allocator() const\n       { return *static_cast<const _Bit_alloc_type*>(this); }\n-      \n+\n       _Bvector_base(const allocator_type& __a)\n       : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0) { }\n \n       ~_Bvector_base() { this->_M_deallocate(); }\n \n     protected:\n-      _Bit_type* \n-      _M_bit_alloc(size_t __n) \n+      _Bit_type*\n+      _M_bit_alloc(size_t __n)\n       { return _Bit_alloc_type::allocate((__n + _S_word_bit - 1)\n \t\t\t\t\t / _S_word_bit); }\n \n-      void \n-      _M_deallocate() \n+      void\n+      _M_deallocate()\n       {\n \tif (_M_start._M_p)\n-\t  _Bit_alloc_type::deallocate(_M_start._M_p, \n+\t  _Bit_alloc_type::deallocate(_M_start._M_p,\n \t\t\t\t      _M_end_of_storage - _M_start._M_p);\n-      }  \n-      \n+      }\n+\n       _Bit_iterator _M_start;\n       _Bit_iterator _M_finish;\n       _Bit_type* _M_end_of_storage;\n@@ -405,36 +405,36 @@ namespace __gnu_norm\n    *  memory and size allocation.  Subscripting ( @c [] ) access is\n    *  also provided as with C-style arrays.\n   */\n-template<typename _Alloc> \n-  class vector<bool, _Alloc> : public _Bvector_base<_Alloc> \n+template<typename _Alloc>\n+  class vector<bool, _Alloc> : public _Bvector_base<_Alloc>\n   {\n   public:\n     typedef bool value_type;\n     typedef size_t size_type;\n-    typedef ptrdiff_t difference_type; \n+    typedef ptrdiff_t difference_type;\n     typedef _Bit_reference reference;\n     typedef bool const_reference;\n     typedef _Bit_reference* pointer;\n     typedef const bool* const_pointer;\n-  \n+\n     typedef _Bit_iterator                iterator;\n     typedef _Bit_const_iterator          const_iterator;\n-  \n+\n     typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n     typedef std::reverse_iterator<iterator> reverse_iterator;\n-  \n+\n     typedef typename _Bvector_base<_Alloc>::allocator_type allocator_type;\n \n     allocator_type get_allocator() const\n     { return _Bvector_base<_Alloc>::get_allocator(); }\n-  \n+\n   protected:\n     using _Bvector_base<_Alloc>::_M_bit_alloc;\n     using _Bvector_base<_Alloc>::_M_deallocate;\n     using _Bvector_base<_Alloc>::_M_start;\n     using _Bvector_base<_Alloc>::_M_finish;\n     using _Bvector_base<_Alloc>::_M_end_of_storage;\n-  \n+\n   protected:\n     void _M_initialize(size_type __n)\n     {\n@@ -466,18 +466,18 @@ template<typename _Alloc>\n \t  this->_M_start = iterator(__q, 0);\n \t}\n     }\n-  \n+\n     template<class _InputIterator>\n     void _M_initialize_range(_InputIterator __first, _InputIterator __last,\n                              input_iterator_tag)\n     {\n       this->_M_start = iterator();\n       this->_M_finish = iterator();\n       this->_M_end_of_storage = 0;\n-      for ( ; __first != __last; ++__first) \n+      for ( ; __first != __last; ++__first)\n         push_back(*__first);\n     }\n-  \n+\n     template<class _ForwardIterator>\n     void _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,\n                              forward_iterator_tag)\n@@ -486,7 +486,7 @@ template<typename _Alloc>\n       _M_initialize(__n);\n       std::copy(__first, __last, this->_M_start);\n     }\n-  \n+\n     template<class _InputIterator>\n     void _M_insert_range(iterator __pos,\n                          _InputIterator __first, _InputIterator __last,\n@@ -498,7 +498,7 @@ template<typename _Alloc>\n \t  ++__pos;\n \t}\n     }\n-  \n+\n     template<class _ForwardIterator>\n     void _M_insert_range(iterator __position,\n                          _ForwardIterator __first, _ForwardIterator __last,\n@@ -527,8 +527,8 @@ template<typename _Alloc>\n \t      this->_M_start = iterator(__q, 0);\n \t    }\n \t}\n-    }  \n-  \n+    }\n+\n   public:\n     iterator begin()\n     { return this->_M_start; }\n@@ -541,7 +541,7 @@ template<typename _Alloc>\n \n     const_iterator end() const\n     { return this->_M_finish; }\n-  \n+\n     reverse_iterator rbegin()\n     { return reverse_iterator(end()); }\n \n@@ -553,7 +553,7 @@ template<typename _Alloc>\n \n     const_reverse_iterator rend() const\n     { return const_reverse_iterator(begin()); }\n-  \n+\n     size_type size() const\n     { return size_type(end() - begin()); }\n \n@@ -565,63 +565,63 @@ template<typename _Alloc>\n \t\t       - begin()); }\n     bool empty() const\n     { return begin() == end(); }\n-  \n+\n     reference operator[](size_type __n)\n     { return *(begin() + difference_type(__n)); }\n \n     const_reference operator[](size_type __n) const\n     { return *(begin() + difference_type(__n)); }\n-  \n+\n     void _M_range_check(size_type __n) const\n     {\n       if (__n >= this->size())\n         __throw_out_of_range(__N(\"vector<bool>::_M_range_check\"));\n     }\n-  \n+\n     reference at(size_type __n)\n     { _M_range_check(__n); return (*this)[__n]; }\n \n     const_reference at(size_type __n) const\n     { _M_range_check(__n); return (*this)[__n]; }\n-  \n+\n     explicit vector(const allocator_type& __a = allocator_type())\n       : _Bvector_base<_Alloc>(__a) { }\n-  \n+\n     vector(size_type __n, bool __value,\n \t   const allocator_type& __a = allocator_type())\n       : _Bvector_base<_Alloc>(__a)\n     {\n       _M_initialize(__n);\n       std::fill(this->_M_start._M_p, this->_M_end_of_storage, __value ? ~0 : 0);\n     }\n-  \n+\n     explicit vector(size_type __n)\n       : _Bvector_base<_Alloc>(allocator_type())\n     {\n       _M_initialize(__n);\n       std::fill(this->_M_start._M_p, this->_M_end_of_storage, 0);\n     }\n-  \n+\n     vector(const vector& __x) : _Bvector_base<_Alloc>(__x.get_allocator())\n     {\n       _M_initialize(__x.size());\n       std::copy(__x.begin(), __x.end(), this->_M_start);\n     }\n-  \n+\n     // Check whether it's an integral type.  If so, it's not an iterator.\n-  \n+\n     template<class _Integer>\n     void _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)\n     {\n       _M_initialize(__n);\n       std::fill(this->_M_start._M_p, this->_M_end_of_storage, __x ? ~0 : 0);\n     }\n-  \n+\n     template<class _InputIterator>\n     void _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,\n                                 __false_type)\n     { _M_initialize_range(__first, __last, std::__iterator_category(__first)); }\n-  \n+\n     template<class _InputIterator>\n     vector(_InputIterator __first, _InputIterator __last,\n              const allocator_type& __a = allocator_type())\n@@ -630,9 +630,9 @@ template<typename _Alloc>\n       typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n       _M_initialize_dispatch(__first, __last, _Integral());\n     }\n-      \n+\n     ~vector() { }\n-  \n+\n     vector& operator=(const vector& __x)\n     {\n       if (&__x == this)\n@@ -646,12 +646,12 @@ template<typename _Alloc>\n       this->_M_finish = begin() + difference_type(__x.size());\n       return *this;\n     }\n-  \n+\n     // assign(), a generalized assignment member function.  Two\n     // versions: one that takes a count, and one that takes a range.\n     // The range version is a member template, so we dispatch on whether\n     // or not the type is an integer.\n-  \n+\n     void _M_fill_assign(size_t __n, bool __x)\n     {\n       if (__n > size())\n@@ -665,26 +665,26 @@ template<typename _Alloc>\n \t  std::fill(this->_M_start._M_p, this->_M_end_of_storage, __x ? ~0 : 0);\n \t}\n     }\n-  \n+\n     void assign(size_t __n, bool __x)\n     { _M_fill_assign(__n, __x); }\n-  \n+\n     template<class _InputIterator>\n     void assign(_InputIterator __first, _InputIterator __last)\n     {\n       typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n       _M_assign_dispatch(__first, __last, _Integral());\n     }\n-  \n+\n     template<class _Integer>\n     void _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n     { _M_fill_assign((size_t) __n, (bool) __val); }\n-  \n+\n     template<class _InputIterator>\n     void _M_assign_dispatch(_InputIterator __first, _InputIterator __last,\n \t\t\t    __false_type)\n     { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }\n-  \n+\n     template<class _InputIterator>\n     void _M_assign_aux(_InputIterator __first, _InputIterator __last,\n                        input_iterator_tag)\n@@ -697,7 +697,7 @@ template<typename _Alloc>\n       else\n         insert(end(), __first, __last);\n     }\n-  \n+\n     template<class _ForwardIterator>\n     void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n                        forward_iterator_tag)\n@@ -712,8 +712,8 @@ template<typename _Alloc>\n \t  std::copy(__first, __mid, begin());\n \t  insert(end(), __mid, __last);\n \t}\n-    }    \n-  \n+    }\n+\n     void reserve(size_type __n)\n     {\n       if (__n > this->max_size())\n@@ -727,7 +727,7 @@ template<typename _Alloc>\n \t  this->_M_end_of_storage = __q + (__n + _S_word_bit - 1) / _S_word_bit;\n \t}\n     }\n-  \n+\n     reference front()\n     { return *begin(); }\n \n@@ -773,29 +773,29 @@ template<typename _Alloc>\n         _M_insert_aux(__position, __x);\n       return begin() + __n;\n     }\n-  \n+\n     // Check whether it's an integral type.  If so, it's not an iterator.\n-  \n+\n     template<class _Integer>\n     void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,\n                             __true_type)\n     { _M_fill_insert(__pos, __n, __x); }\n-  \n+\n     template<class _InputIterator>\n     void _M_insert_dispatch(iterator __pos,\n                             _InputIterator __first, _InputIterator __last,\n                             __false_type)\n     { _M_insert_range(__pos, __first, __last,\n \t\t      std::__iterator_category(__first)); }\n-  \n+\n     template<class _InputIterator>\n     void insert(iterator __position,\n                 _InputIterator __first, _InputIterator __last)\n     {\n       typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n       _M_insert_dispatch(__position, __first, __last, _Integral());\n     }\n-  \n+\n     void _M_fill_insert(iterator __position, size_type __n, bool __x)\n     {\n       if (__n == 0)\n@@ -821,10 +821,10 @@ template<typename _Alloc>\n \t  this->_M_start = iterator(__q, 0);\n \t}\n     }\n-  \n+\n     void insert(iterator __position, size_type __n, bool __x)\n     { _M_fill_insert(__position, __n, __x); }\n-  \n+\n     void pop_back()\n     { --this->_M_finish; }\n \n@@ -844,7 +844,7 @@ template<typename _Alloc>\n \n     void resize(size_type __new_size, bool __x = bool())\n     {\n-      if (__new_size < size()) \n+      if (__new_size < size())\n         erase(begin() + difference_type(__new_size), end());\n       else\n         insert(end(), __new_size - size(), __x);\n@@ -856,7 +856,7 @@ template<typename _Alloc>\n \t   __p != this->_M_end_of_storage; ++__p)\n         *__p = ~*__p;\n     }\n-  \n+\n     void clear()\n     { erase(begin(), end()); }\n   };"}, {"sha": "afb338798521aacdd9a77e7d188e7ad70dcd8999", "filename": "libstdc++-v3/include/bits/stl_construct.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_construct.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_construct.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_construct.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -78,9 +78,9 @@ namespace std\n     {\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 402. wrong new expression in [some_]allocator::construct\n-      ::new(static_cast<void*>(__p)) _T1(__value); \n+      ::new(static_cast<void*>(__p)) _T1(__value);\n     }\n-  \n+\n   /**\n    * @if maint\n    * Constructs an object in existing memory by invoking an allocated\n@@ -92,7 +92,7 @@ namespace std\n     _Construct(_T1* __p)\n     {\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // 402. wrong new expression in [some_]allocator::construct     \n+      // 402. wrong new expression in [some_]allocator::construct\n       ::new(static_cast<void*>(__p)) _T1();\n     }\n \n@@ -108,7 +108,7 @@ namespace std\n \n   /**\n    * @if maint\n-   * Destroy a range of objects with nontrivial destructors.  \n+   * Destroy a range of objects with nontrivial destructors.\n    *\n    * This is a helper function used only by _Destroy().\n    * @endif\n@@ -128,7 +128,7 @@ namespace std\n    * This is a helper function used only by _Destroy().\n    * @endif\n    */\n-  template<typename _ForwardIterator> \n+  template<typename _ForwardIterator>\n     inline void\n     __destroy_aux(_ForwardIterator, _ForwardIterator, __true_type)\n     { }"}, {"sha": "31126775ad034d5d4909215a2ca7131f3343d8cc", "filename": "libstdc++-v3/include/bits/stl_deque.h", "status": "modified", "additions": 170, "deletions": 170, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -66,7 +66,7 @@\n #include <bits/stl_iterator_base_funcs.h>\n \n namespace __gnu_norm\n-{ \n+{\n   /**\n    *  @if maint\n    *  @brief This function controls the size of memory nodes.\n@@ -79,11 +79,11 @@ namespace __gnu_norm\n    *  been done since inheriting the SGI code.\n    *  @endif\n   */\n-  inline size_t \n-  __deque_buf_size(size_t __size) \n+  inline size_t\n+  __deque_buf_size(size_t __size)\n   { return __size < 512 ? size_t(512 / __size) : size_t(1); }\n-  \n-  \n+\n+\n   /**\n    *  @brief A deque::iterator.\n    *\n@@ -104,7 +104,7 @@ namespace __gnu_norm\n \n       static size_t _S_buffer_size()\n       { return __deque_buf_size(sizeof(_Tp)); }\n-  \n+\n       typedef random_access_iterator_tag iterator_category;\n       typedef _Tp                        value_type;\n       typedef _Ptr                       pointer;\n@@ -113,30 +113,30 @@ namespace __gnu_norm\n       typedef ptrdiff_t                  difference_type;\n       typedef _Tp**                      _Map_pointer;\n       typedef _Deque_iterator            _Self;\n-  \n+\n       _Tp* _M_cur;\n       _Tp* _M_first;\n       _Tp* _M_last;\n       _Map_pointer _M_node;\n-      \n-      _Deque_iterator(_Tp* __x, _Map_pointer __y) \n+\n+      _Deque_iterator(_Tp* __x, _Map_pointer __y)\n       : _M_cur(__x), _M_first(*__y),\n         _M_last(*__y + _S_buffer_size()), _M_node(__y) {}\n \n       _Deque_iterator() : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) {}\n \n       _Deque_iterator(const iterator& __x)\n-      : _M_cur(__x._M_cur), _M_first(__x._M_first), \n+      : _M_cur(__x._M_cur), _M_first(__x._M_first),\n         _M_last(__x._M_last), _M_node(__x._M_node) {}\n-  \n+\n       reference\n       operator*() const\n       { return *_M_cur; }\n \n       pointer\n       operator->() const\n       { return _M_cur; }\n-      \n+\n       _Self&\n       operator++()\n       {\n@@ -146,7 +146,7 @@ namespace __gnu_norm\n \t    _M_set_node(_M_node + 1);\n \t    _M_cur = _M_first;\n \t  }\n-\treturn *this; \n+\treturn *this;\n       }\n \n       _Self\n@@ -156,7 +156,7 @@ namespace __gnu_norm\n \t++*this;\n \treturn __tmp;\n       }\n-      \n+\n       _Self&\n       operator--()\n       {\n@@ -168,15 +168,15 @@ namespace __gnu_norm\n \t--_M_cur;\n \treturn *this;\n       }\n-      \n+\n       _Self\n       operator--(int)\n       {\n \t_Self __tmp = *this;\n \t--*this;\n \treturn __tmp;\n       }\n-      \n+\n       _Self&\n       operator+=(difference_type __n)\n       {\n@@ -195,29 +195,29 @@ namespace __gnu_norm\n \t  }\n \treturn *this;\n       }\n-  \n+\n       _Self\n       operator+(difference_type __n) const\n       {\n \t_Self __tmp = *this;\n \treturn __tmp += __n;\n       }\n-  \n+\n       _Self&\n       operator-=(difference_type __n)\n       { return *this += -__n; }\n-   \n+\n       _Self\n       operator-(difference_type __n) const\n       {\n \t_Self __tmp = *this;\n \treturn __tmp -= __n;\n       }\n-  \n+\n       reference\n       operator[](difference_type __n) const\n       { return *(*this + __n); }\n-  \n+\n       /** @if maint\n        *  Prepares to traverse new_node.  Sets everything except _M_cur, which\n        *  should therefore be set by the caller immediately afterwards, based on\n@@ -232,7 +232,7 @@ namespace __gnu_norm\n \t_M_last = _M_first + difference_type(_S_buffer_size());\n       }\n     };\n-  \n+\n   // Note: we also provide overloads whose operands are of the same type in\n   // order to avoid ambiguous overload resolution when std::rel_ops operators\n   // are in scope (for additional details, see libstdc++/3628)\n@@ -241,81 +241,81 @@ namespace __gnu_norm\n     operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n \t       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)\n     { return __x._M_cur == __y._M_cur; }\n-  \n+\n   template<typename _Tp, typename _RefL, typename _PtrL,\n \t   typename _RefR, typename _PtrR>\n     inline bool\n     operator==(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n \t       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n     { return __x._M_cur == __y._M_cur; }\n-  \n+\n   template<typename _Tp, typename _Ref, typename _Ptr>\n     inline bool\n     operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n \t       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)\n     { return !(__x == __y); }\n-  \n+\n   template<typename _Tp, typename _RefL, typename _PtrL,\n \t   typename _RefR, typename _PtrR>\n     inline bool\n     operator!=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n \t       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n     { return !(__x == __y); }\n-  \n+\n   template<typename _Tp, typename _Ref, typename _Ptr>\n     inline bool\n     operator<(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n \t      const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)\n     { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)\n                                           : (__x._M_node < __y._M_node); }\n-  \n+\n   template<typename _Tp, typename _RefL, typename _PtrL,\n \t   typename _RefR, typename _PtrR>\n     inline bool\n     operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n \t      const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n     { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)\n \t                                  : (__x._M_node < __y._M_node); }\n-  \n+\n   template<typename _Tp, typename _Ref, typename _Ptr>\n     inline bool\n     operator>(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n \t      const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)\n     { return __y < __x; }\n-  \n+\n   template<typename _Tp, typename _RefL, typename _PtrL,\n \t   typename _RefR, typename _PtrR>\n     inline bool\n     operator>(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n \t      const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n     { return __y < __x; }\n-  \n+\n   template<typename _Tp, typename _Ref, typename _Ptr>\n     inline bool\n     operator<=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n \t       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)\n     { return !(__y < __x); }\n-  \n+\n   template<typename _Tp, typename _RefL, typename _PtrL,\n \t   typename _RefR, typename _PtrR>\n     inline bool\n     operator<=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n \t       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n     { return !(__y < __x); }\n-  \n+\n   template<typename _Tp, typename _Ref, typename _Ptr>\n     inline bool\n     operator>=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n \t       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)\n     { return !(__x < __y); }\n-  \n+\n   template<typename _Tp, typename _RefL, typename _PtrL,\n \t   typename _RefR, typename _PtrR>\n     inline bool\n     operator>=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n \t       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n     { return !(__x < __y); }\n-  \n+\n   // _GLIBCXX_RESOLVE_LIB_DEFECTS\n   // According to the resolution of DR179 not only the various comparison\n   // operators but also operator- must accept mixed iterator/const_iterator\n@@ -331,12 +331,12 @@ namespace __gnu_norm\n \t* (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)\n \t+ (__y._M_last - __y._M_cur);\n     }\n-  \n+\n   template<typename _Tp, typename _Ref, typename _Ptr>\n     inline _Deque_iterator<_Tp, _Ref, _Ptr>\n     operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)\n     { return __x + __n; }\n-  \n+\n   /**\n    *  @if maint\n    *  Deque base class.  This class provides the unified face for %deque's\n@@ -362,15 +362,15 @@ namespace __gnu_norm\n \n       typedef _Deque_iterator<_Tp,_Tp&,_Tp*>             iterator;\n       typedef _Deque_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;\n-      \n+\n       _Deque_base(const allocator_type& __a, size_t __num_elements)\n       : _Alloc(__a), _M_start(), _M_finish()\n       { _M_initialize_map(__num_elements); }\n \n-      _Deque_base(const allocator_type& __a) \n+      _Deque_base(const allocator_type& __a)\n       : _Alloc(__a), _M_start(), _M_finish() { }\n \n-      ~_Deque_base();    \n+      ~_Deque_base();\n \n     protected:\n       typedef typename _Alloc::template rebind<_Tp*>::other _Map_alloc_type;\n@@ -380,31 +380,31 @@ namespace __gnu_norm\n       _Tp*\n       _M_allocate_node()\n       { return _Alloc::allocate(__deque_buf_size(sizeof(_Tp))); }\n-      \n+\n       void\n       _M_deallocate_node(_Tp* __p)\n       { _Alloc::deallocate(__p, __deque_buf_size(sizeof(_Tp))); }\n-      \n+\n       _Tp**\n       _M_allocate_map(size_t __n)\n       { return _M_get_map_allocator().allocate(__n); }\n-  \n+\n       void\n-      _M_deallocate_map(_Tp** __p, size_t __n) \n+      _M_deallocate_map(_Tp** __p, size_t __n)\n       { _M_get_map_allocator().deallocate(__p, __n); }\n-      \n+\n     protected:\n       void _M_initialize_map(size_t);\n       void _M_create_nodes(_Tp** __nstart, _Tp** __nfinish);\n       void _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish);\n       enum { _S_initial_map_size = 8 };\n-      \n+\n       _Tp** _M_map;\n       size_t _M_map_size;\n       iterator _M_start;\n       iterator _M_finish;\n     };\n-  \n+\n   template<typename _Tp, typename _Alloc>\n   _Deque_base<_Tp,_Alloc>::~_Deque_base()\n   {\n@@ -414,7 +414,7 @@ namespace __gnu_norm\n       _M_deallocate_map(this->_M_map, this->_M_map_size);\n     }\n   }\n-  \n+\n   /**\n    *  @if maint\n    *  @brief Layout storage.\n@@ -430,20 +430,20 @@ namespace __gnu_norm\n     _Deque_base<_Tp,_Alloc>::_M_initialize_map(size_t __num_elements)\n     {\n       size_t __num_nodes = __num_elements / __deque_buf_size(sizeof(_Tp)) + 1;\n-      \n+\n       this->_M_map_size = std::max((size_t) _S_initial_map_size,\n \t\t\t\t   __num_nodes + 2);\n       this->_M_map = _M_allocate_map(this->_M_map_size);\n-  \n+\n       // For \"small\" maps (needing less than _M_map_size nodes), allocation\n       // starts in the middle elements and grows outwards.  So nstart may be\n       // the beginning of _M_map, but for small maps it may be as far in as\n       // _M_map+3.\n-  \n+\n       _Tp** __nstart = this->_M_map + (this->_M_map_size - __num_nodes) / 2;\n       _Tp** __nfinish = __nstart + __num_nodes;\n-      \n-      try \n+\n+      try\n \t{ _M_create_nodes(__nstart, __nfinish); }\n       catch(...)\n \t{\n@@ -452,14 +452,14 @@ namespace __gnu_norm\n \t  this->_M_map_size = 0;\n \t  __throw_exception_again;\n \t}\n-      \n+\n       _M_start._M_set_node(__nstart);\n       _M_finish._M_set_node(__nfinish - 1);\n       _M_start._M_cur = _M_start._M_first;\n       _M_finish._M_cur = _M_finish._M_first + __num_elements\n \t                 % __deque_buf_size(sizeof(_Tp));\n     }\n-  \n+\n   template<typename _Tp, typename _Alloc>\n     void\n     _Deque_base<_Tp,_Alloc>::_M_create_nodes(_Tp** __nstart, _Tp** __nfinish)\n@@ -471,20 +471,20 @@ namespace __gnu_norm\n \t    *__cur = this->_M_allocate_node();\n \t}\n       catch(...)\n-\t{ \n+\t{\n \t  _M_destroy_nodes(__nstart, __cur);\n-\t  __throw_exception_again; \n+\t  __throw_exception_again;\n \t}\n     }\n-  \n+\n   template<typename _Tp, typename _Alloc>\n     void\n     _Deque_base<_Tp,_Alloc>::_M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish)\n     {\n       for (_Tp** __n = __nstart; __n < __nfinish; ++__n)\n \t_M_deallocate_node(*__n);\n     }\n-  \n+\n   /**\n    *  @brief  A standard container using fixed-size memory allocation and\n    *  constant-time manipulation of elements at either end.\n@@ -504,27 +504,27 @@ namespace __gnu_norm\n    *\n    *  @if maint\n    *  Here's how a deque<Tp> manages memory.  Each deque has 4 members:\n-   *  \n+   *\n    *  - Tp**        _M_map\n    *  - size_t      _M_map_size\n    *  - iterator    _M_start, _M_finish\n-   *  \n+   *\n    *  map_size is at least 8.  %map is an array of map_size pointers-to-\"nodes\".\n    *  (The name %map has nothing to do with the std::map class, and \"nodes\"\n    *  should not be confused with std::list's usage of \"node\".)\n-   *  \n+   *\n    *  A \"node\" has no specific type name as such, but it is referred to as\n    *  \"node\" in this file.  It is a simple array-of-Tp.  If Tp is very large,\n    *  there will be one Tp element per node (i.e., an \"array\" of one).\n    *  For non-huge Tp's, node size is inversely related to Tp size:  the\n    *  larger the Tp, the fewer Tp's will fit in a node.  The goal here is to\n    *  keep the total size of a node relatively small and constant over different\n    *  Tp's, to improve allocator efficiency.\n-   *  \n+   *\n    *  **** As I write this, the nodes are /not/ allocated using the high-speed\n    *  memory pool.  There are 20 hours left in the year; perhaps I can fix\n    *  this before 2002.\n-   *  \n+   *\n    *  Not every pointer in the %map array will point to a node.  If the initial\n    *  number of elements in the deque is small, the /middle/ %map pointers will\n    *  be valid, and the ones at the edges will be unused.  This same situation\n@@ -552,9 +552,9 @@ namespace __gnu_norm\n    *   that range are uninitialized storage.  Otherwise, [start.cur, start.last)\n    *   and [finish.first, finish.cur) are initialized objects, and [start.first,\n    *   start.cur) and [finish.cur, finish.last) are uninitialized storage.\n-   * - [%map, %map + map_size) is a valid, non-empty range.  \n-   * - [start.node, finish.node] is a valid range contained within \n-   *   [%map, %map + map_size).  \n+   * - [%map, %map + map_size) is a valid, non-empty range.\n+   * - [start.node, finish.node] is a valid range contained within\n+   *   [%map, %map + map_size).\n    * - A pointer in the range [%map, %map + map_size) points to an allocated\n    *   node if and only if the pointer is in the range\n    *   [start.node, finish.node].\n@@ -574,9 +574,9 @@ namespace __gnu_norm\n     {\n       // concept requirements\n       __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n-\t\n+\n       typedef _Deque_base<_Tp, _Alloc>           _Base;\n-      \n+\n     public:\n       typedef _Tp                                value_type;\n       typedef value_type*                        pointer;\n@@ -590,13 +590,13 @@ namespace __gnu_norm\n       typedef size_t                             size_type;\n       typedef ptrdiff_t                          difference_type;\n       typedef typename _Base::allocator_type     allocator_type;\n-      \n+\n     protected:\n       typedef pointer*                           _Map_pointer;\n-      \n+\n       static size_t _S_buffer_size()\n       { return __deque_buf_size(sizeof(_Tp)); }\n-      \n+\n       // Functions controlling memory layout, and nothing else.\n       using _Base::_M_initialize_map;\n       using _Base::_M_create_nodes;\n@@ -605,7 +605,7 @@ namespace __gnu_norm\n       using _Base::_M_deallocate_node;\n       using _Base::_M_allocate_map;\n       using _Base::_M_deallocate_map;\n-      \n+\n       /** @if maint\n        *  A total of four data members accumulated down the heirarchy.\n        *  @endif\n@@ -614,57 +614,57 @@ namespace __gnu_norm\n       using _Base::_M_map_size;\n       using _Base::_M_start;\n       using _Base::_M_finish;\n-      \n+\n     public:\n       // [23.2.1.1] construct/copy/destroy\n       // (assign() and get_allocator() are also listed in this section)\n       /**\n        *  @brief  Default constructor creates no elements.\n        */\n       explicit\n-      deque(const allocator_type& __a = allocator_type()) \n+      deque(const allocator_type& __a = allocator_type())\n       : _Base(__a, 0) {}\n-  \n+\n       /**\n        *  @brief  Create a %deque with copies of an exemplar element.\n        *  @param  n  The number of elements to initially create.\n        *  @param  value  An element to copy.\n-       * \n+       *\n        *  This constructor fills the %deque with @a n copies of @a value.\n        */\n       deque(size_type __n, const value_type& __value,\n \t    const allocator_type& __a = allocator_type())\n       : _Base(__a, __n)\n       { _M_fill_initialize(__value); }\n-  \n+\n       /**\n        *  @brief  Create a %deque with default elements.\n        *  @param  n  The number of elements to initially create.\n-       * \n+       *\n        *  This constructor fills the %deque with @a n copies of a\n        *  default-constructed element.\n        */\n       explicit\n       deque(size_type __n)\n       : _Base(allocator_type(), __n)\n       { _M_fill_initialize(value_type()); }\n-  \n+\n       /**\n        *  @brief  %Deque copy constructor.\n        *  @param  x  A %deque of identical element and allocator types.\n-       * \n+       *\n        *  The newly-created %deque uses a copy of the allocation object used\n        *  by @a x.\n        */\n       deque(const deque& __x)\n-      : _Base(__x.get_allocator(), __x.size()) \n+      : _Base(__x.get_allocator(), __x.size())\n       { std::uninitialized_copy(__x.begin(), __x.end(), this->_M_start); }\n-  \n+\n       /**\n        *  @brief  Builds a %deque from a range.\n        *  @param  first  An input iterator.\n        *  @param  last  An input iterator.\n-       * \n+       *\n        *  Create a %deque consisting of copies of the elements from [first,\n        *  last).\n        *\n@@ -683,25 +683,25 @@ namespace __gnu_norm\n \t  typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n \t  _M_initialize_dispatch(__first, __last, _Integral());\n \t}\n-  \n+\n       /**\n        *  The dtor only erases the elements, and note that if the elements\n        *  themselves are pointers, the pointed-to memory is not touched in any\n        *  way.  Managing the pointer is the user's responsibilty.\n        */\n       ~deque()\n       { std::_Destroy(this->_M_start, this->_M_finish); }\n-  \n+\n       /**\n        *  @brief  %Deque assignment operator.\n        *  @param  x  A %deque of identical element and allocator types.\n-       * \n+       *\n        *  All the elements of @a x are copied, but unlike the copy constructor,\n        *  the allocator object is not copied.\n        */\n       deque&\n       operator=(const deque& __x);\n-  \n+\n       /**\n        *  @brief  Assigns a given value to a %deque.\n        *  @param  n  Number of elements to be assigned.\n@@ -715,7 +715,7 @@ namespace __gnu_norm\n       void\n       assign(size_type __n, const value_type& __val)\n       { _M_fill_assign(__n, __val); }\n-  \n+\n       /**\n        *  @brief  Assigns a range to a %deque.\n        *  @param  first  An input iterator.\n@@ -735,12 +735,12 @@ namespace __gnu_norm\n \t  typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n \t  _M_assign_dispatch(__first, __last, _Integral());\n \t}\n-  \n+\n       /// Get a copy of the memory allocation object.\n       allocator_type\n       get_allocator() const\n       { return _Base::get_allocator(); }\n-      \n+\n       // iterators\n       /**\n        *  Returns a read/write iterator that points to the first element in the\n@@ -749,39 +749,39 @@ namespace __gnu_norm\n       iterator\n       begin()\n       { return this->_M_start; }\n-      \n+\n       /**\n        *  Returns a read-only (constant) iterator that points to the first\n        *  element in the %deque.  Iteration is done in ordinary element order.\n        */\n       const_iterator\n       begin() const\n       { return this->_M_start; }\n-      \n+\n       /**\n        *  Returns a read/write iterator that points one past the last element in\n        *  the %deque.  Iteration is done in ordinary element order.\n        */\n       iterator\n       end()\n       { return this->_M_finish; }\n-      \n+\n       /**\n        *  Returns a read-only (constant) iterator that points one past the last\n        *  element in the %deque.  Iteration is done in ordinary element order.\n        */\n       const_iterator\n       end() const\n       { return this->_M_finish; }\n-      \n+\n       /**\n        *  Returns a read/write reverse iterator that points to the last element\n        *  in the %deque.  Iteration is done in reverse element order.\n        */\n       reverse_iterator\n       rbegin()\n       { return reverse_iterator(this->_M_finish); }\n-      \n+\n       /**\n        *  Returns a read-only (constant) reverse iterator that points to the\n        *  last element in the %deque.  Iteration is done in reverse element\n@@ -790,15 +790,15 @@ namespace __gnu_norm\n       const_reverse_iterator\n       rbegin() const\n       { return const_reverse_iterator(this->_M_finish); }\n-      \n+\n       /**\n        *  Returns a read/write reverse iterator that points to one before the\n        *  first element in the %deque.  Iteration is done in reverse element\n        *  order.\n        */\n       reverse_iterator\n       rend() { return reverse_iterator(this->_M_start); }\n-      \n+\n       /**\n        *  Returns a read-only (constant) reverse iterator that points to one\n        *  before the first element in the %deque.  Iteration is done in reverse\n@@ -807,18 +807,18 @@ namespace __gnu_norm\n       const_reverse_iterator\n       rend() const\n       { return const_reverse_iterator(this->_M_start); }\n-      \n+\n       // [23.2.1.2] capacity\n       /**  Returns the number of elements in the %deque.  */\n       size_type\n       size() const\n       { return this->_M_finish - this->_M_start; }\n-      \n+\n       /**  Returns the size() of the largest possible %deque.  */\n       size_type\n       max_size() const\n       { return size_type(-1); }\n-      \n+\n       /**\n        *  @brief  Resizes the %deque to the specified number of elements.\n        *  @param  new_size  Number of elements the %deque should contain.\n@@ -833,12 +833,12 @@ namespace __gnu_norm\n       resize(size_type __new_size, const value_type& __x)\n       {\n \tconst size_type __len = size();\n-\tif (__new_size < __len) \n+\tif (__new_size < __len)\n \t  erase(this->_M_start + __new_size, this->_M_finish);\n \telse\n \t  insert(this->_M_finish, __new_size - __len, __x);\n       }\n-      \n+\n       /**\n        *  @brief  Resizes the %deque to the specified number of elements.\n        *  @param  new_size  Number of elements the %deque should contain.\n@@ -851,14 +851,14 @@ namespace __gnu_norm\n       void\n       resize(size_type new_size)\n       { resize(new_size, value_type()); }\n-  \n+\n       /**\n        *  Returns true if the %deque is empty.  (Thus begin() would equal end().)\n        */\n       bool\n       empty() const\n       { return this->_M_finish == this->_M_start; }\n-  \n+\n       // element access\n       /**\n        *  @brief  Subscript access to the data contained in the %deque.\n@@ -872,7 +872,7 @@ namespace __gnu_norm\n       reference\n       operator[](size_type __n)\n       { return this->_M_start[difference_type(__n)]; }\n-      \n+\n       /**\n        *  @brief  Subscript access to the data contained in the %deque.\n        *  @param  n  The index of the element for which data should be accessed.\n@@ -885,7 +885,7 @@ namespace __gnu_norm\n       const_reference\n       operator[](size_type __n) const\n       { return this->_M_start[difference_type(__n)]; }\n-  \n+\n     protected:\n       /// @if maint Safety check used only from at().  @endif\n       void\n@@ -894,7 +894,7 @@ namespace __gnu_norm\n \tif (__n >= this->size())\n \t  __throw_out_of_range(__N(\"deque::_M_range_check\"));\n       }\n-      \n+\n     public:\n       /**\n        *  @brief  Provides access to the data contained in the %deque.\n@@ -909,7 +909,7 @@ namespace __gnu_norm\n       reference\n       at(size_type __n)\n       { _M_range_check(__n); return (*this)[__n]; }\n-      \n+\n       /**\n        *  @brief  Provides access to the data contained in the %deque.\n        *  @param  n  The index of the element for which data should be accessed.\n@@ -926,23 +926,23 @@ namespace __gnu_norm\n \t_M_range_check(__n);\n \treturn (*this)[__n];\n       }\n-      \n+\n       /**\n        *  Returns a read/write reference to the data at the first element of the\n        *  %deque.\n        */\n       reference\n       front()\n       { return *this->_M_start; }\n-      \n+\n       /**\n        *  Returns a read-only (constant) reference to the data at the first\n        *  element of the %deque.\n        */\n       const_reference\n       front() const\n       { return *this->_M_start; }\n-      \n+\n       /**\n        *  Returns a read/write reference to the data at the last element of the\n        *  %deque.\n@@ -954,7 +954,7 @@ namespace __gnu_norm\n \t--__tmp;\n \treturn *__tmp;\n       }\n-      \n+\n       /**\n        *  Returns a read-only (constant) reference to the data at the last\n        *  element of the %deque.\n@@ -966,7 +966,7 @@ namespace __gnu_norm\n \t--__tmp;\n \treturn *__tmp;\n       }\n-      \n+\n       // [23.2.1.2] modifiers\n       /**\n        *  @brief  Add data to the front of the %deque.\n@@ -977,7 +977,7 @@ namespace __gnu_norm\n        *  nature of a %deque this operation can be done in constant time.\n        */\n       void\n-      push_front(const value_type& __x) \n+      push_front(const value_type& __x)\n       {\n \tif (this->_M_start._M_cur != this->_M_start._M_first)\n \t  {\n@@ -987,7 +987,7 @@ namespace __gnu_norm\n \telse\n \t  _M_push_front_aux(__x);\n       }\n-      \n+\n       /**\n        *  @brief  Add data to the end of the %deque.\n        *  @param  x  Data to be added.\n@@ -1007,7 +1007,7 @@ namespace __gnu_norm\n \telse\n \t  _M_push_back_aux(__x);\n       }\n-  \n+\n       /**\n        *  @brief  Removes first element.\n        *\n@@ -1024,10 +1024,10 @@ namespace __gnu_norm\n \t    std::_Destroy(this->_M_start._M_cur);\n \t    ++this->_M_start._M_cur;\n \t  }\n-\telse \n+\telse\n \t  _M_pop_front_aux();\n       }\n-      \n+\n       /**\n        *  @brief  Removes last element.\n        *\n@@ -1047,7 +1047,7 @@ namespace __gnu_norm\n \telse\n \t  _M_pop_back_aux();\n       }\n-      \n+\n       /**\n        *  @brief  Inserts given value into %deque before specified iterator.\n        *  @param  position  An iterator into the %deque.\n@@ -1059,7 +1059,7 @@ namespace __gnu_norm\n        */\n       iterator\n       insert(iterator position, const value_type& __x);\n-      \n+\n       /**\n        *  @brief  Inserts a number of copies of given data into the %deque.\n        *  @param  position  An iterator into the %deque.\n@@ -1072,7 +1072,7 @@ namespace __gnu_norm\n       void\n       insert(iterator __position, size_type __n, const value_type& __x)\n       { _M_fill_insert(__position, __n, __x); }\n-      \n+\n       /**\n        *  @brief  Inserts a range into the %deque.\n        *  @param  position  An iterator into the %deque.\n@@ -1092,7 +1092,7 @@ namespace __gnu_norm\n \t  typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n \t  _M_insert_dispatch(__position, __first, __last, _Integral());\n \t}\n-      \n+\n       /**\n        *  @brief  Remove element at given position.\n        *  @param  position  Iterator pointing to element to be erased.\n@@ -1108,7 +1108,7 @@ namespace __gnu_norm\n        */\n       iterator\n       erase(iterator __position);\n-      \n+\n       /**\n        *  @brief  Remove a range of elements.\n        *  @param  first  Iterator pointing to the first element to be erased.\n@@ -1127,7 +1127,7 @@ namespace __gnu_norm\n        */\n       iterator\n       erase(iterator __first, iterator __last);\n-  \n+\n       /**\n        *  @brief  Swaps data with another %deque.\n        *  @param  x  A %deque of the same element and allocator types.\n@@ -1145,18 +1145,18 @@ namespace __gnu_norm\n \tstd::swap(this->_M_map, __x._M_map);\n \tstd::swap(this->_M_map_size, __x._M_map_size);\n       }\n-      \n+\n       /**\n        *  Erases all the elements.  Note that this function only erases the\n        *  elements, and that if the elements themselves are pointers, the\n        *  pointed-to memory is not touched in any way.  Managing the pointer is\n        *  the user's responsibilty.\n        */\n-      void clear(); \n-      \n+      void clear();\n+\n     protected:\n       // Internal constructor functions follow.\n-      \n+\n       // called by the range constructor to implement [23.1.1]/9\n       template<typename _Integer>\n         void\n@@ -1165,7 +1165,7 @@ namespace __gnu_norm\n \t  _M_initialize_map(__n);\n \t  _M_fill_initialize(__x);\n \t}\n-      \n+\n       // called by the range constructor to implement [23.1.1]/9\n       template<typename _InputIterator>\n         void\n@@ -1176,7 +1176,7 @@ namespace __gnu_norm\n \t    _IterCategory;\n \t  _M_range_initialize(__first, __last, _IterCategory());\n \t}\n-  \n+\n       // called by the second initialize_dispatch above\n       //@{\n       /**\n@@ -1192,17 +1192,17 @@ namespace __gnu_norm\n        *  @endif\n        */\n       template<typename _InputIterator>\n-        void  \n+        void\n         _M_range_initialize(_InputIterator __first, _InputIterator __last,\n \t\t\t    input_iterator_tag);\n-  \n+\n       // called by the second initialize_dispatch above\n       template<typename _ForwardIterator>\n-        void \n+        void\n         _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,\n \t\t\t    forward_iterator_tag);\n       //@}\n-      \n+\n       /**\n        *  @if maint\n        *  @brief Fills the %deque with copies of value.\n@@ -1217,10 +1217,10 @@ namespace __gnu_norm\n        */\n       void\n       _M_fill_initialize(const value_type& __value);\n-      \n+\n       // Internal assign functions follow.  The *_aux functions do the actual\n       // assignment work for the range versions.\n-      \n+\n       // called by the range assign to implement [23.1.1]/9\n       template<typename _Integer>\n         void\n@@ -1229,7 +1229,7 @@ namespace __gnu_norm\n \t  _M_fill_assign(static_cast<size_type>(__n),\n \t\t\t static_cast<value_type>(__val));\n \t}\n-  \n+\n       // called by the range assign to implement [23.1.1]/9\n       template<typename _InputIterator>\n         void\n@@ -1240,13 +1240,13 @@ namespace __gnu_norm\n \t    _IterCategory;\n \t  _M_assign_aux(__first, __last, _IterCategory());\n \t}\n-  \n+\n       // called by the second assign_dispatch above\n       template<typename _InputIterator>\n         void\n         _M_assign_aux(_InputIterator __first, _InputIterator __last,\n \t\t      input_iterator_tag);\n-  \n+\n       // called by the second assign_dispatch above\n       template<typename _ForwardIterator>\n         void\n@@ -1264,7 +1264,7 @@ namespace __gnu_norm\n \t  else\n \t    erase(std::copy(__first, __last, begin()), end());\n \t}\n-  \n+\n       // Called by assign(n,t), and the range assign when it turns out to be the\n       // same thing.\n       void\n@@ -1281,7 +1281,7 @@ namespace __gnu_norm\n \t    std::fill(begin(), end(), __val);\n \t  }\n       }\n-  \n+\n       //@{\n       /**\n        *  @if maint\n@@ -1293,10 +1293,10 @@ namespace __gnu_norm\n       void _M_pop_back_aux();\n       void _M_pop_front_aux();\n       //@}\n-    \n+\n       // Internal insert functions follow.  The *_aux functions do the actual\n       // insertion work when all shortcuts fail.\n-  \n+\n       // called by the range insert to implement [23.1.1]/9\n       template<typename _Integer>\n         void\n@@ -1306,7 +1306,7 @@ namespace __gnu_norm\n \t  _M_fill_insert(__pos, static_cast<size_type>(__n),\n \t\t\t static_cast<value_type>(__x));\n \t}\n-  \n+\n       // called by the range insert to implement [23.1.1]/9\n       template<typename _InputIterator>\n         void\n@@ -1318,40 +1318,40 @@ namespace __gnu_norm\n \t    _IterCategory;\n           _M_range_insert_aux(__pos, __first, __last, _IterCategory());\n \t}\n-  \n+\n       // called by the second insert_dispatch above\n       template<typename _InputIterator>\n         void\n         _M_range_insert_aux(iterator __pos, _InputIterator __first,\n \t\t\t    _InputIterator __last, input_iterator_tag);\n-  \n+\n       // called by the second insert_dispatch above\n       template<typename _ForwardIterator>\n         void\n         _M_range_insert_aux(iterator __pos, _ForwardIterator __first,\n \t\t\t    _ForwardIterator __last, forward_iterator_tag);\n-  \n+\n       // Called by insert(p,n,x), and the range insert when it turns out to be\n       // the same thing.  Can use fill functions in optimal situations,\n       // otherwise passes off to insert_aux(p,n,x).\n       void\n-      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x); \n-  \n+      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);\n+\n       // called by insert(p,x)\n       iterator\n       _M_insert_aux(iterator __pos, const value_type& __x);\n-  \n+\n       // called by insert(p,n,x) via fill_insert\n       void\n       _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);\n-  \n+\n       // called by range_insert_aux for forward iterators\n       template<typename _ForwardIterator>\n         void\n-        _M_insert_aux(iterator __pos, \n+        _M_insert_aux(iterator __pos,\n \t\t      _ForwardIterator __first, _ForwardIterator __last,\n \t\t      size_type __n);\n-  \n+\n       //@{\n       /**\n        *  @if maint\n@@ -1368,7 +1368,7 @@ namespace __gnu_norm\n \t  _M_new_elements_at_front(__n - __vacancies);\n \treturn this->_M_start - difference_type(__n);\n       }\n-      \n+\n       iterator\n       _M_reserve_elements_at_back(size_type __n)\n       {\n@@ -1378,15 +1378,15 @@ namespace __gnu_norm\n \t  _M_new_elements_at_back(__n - __vacancies);\n \treturn this->_M_finish + difference_type(__n);\n       }\n-      \n+\n       void\n       _M_new_elements_at_front(size_type __new_elements);\n-      \n+\n       void\n       _M_new_elements_at_back(size_type __new_elements);\n       //@}\n-      \n-      \n+\n+\n       //@{\n       /**\n        *  @if maint\n@@ -1404,20 +1404,20 @@ namespace __gnu_norm\n \t    - (this->_M_finish._M_node - this->_M_map))\n \t  _M_reallocate_map(__nodes_to_add, false);\n       }\n-  \n+\n       void\n       _M_reserve_map_at_front (size_type __nodes_to_add = 1)\n       {\n \tif (__nodes_to_add > size_type(this->_M_start._M_node - this->_M_map))\n \t  _M_reallocate_map(__nodes_to_add, true);\n       }\n-  \n+\n       void\n       _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);\n       //@}\n     };\n-  \n-  \n+\n+\n   /**\n    *  @brief  Deque equality comparison.\n    *  @param  x  A %deque.\n@@ -1434,7 +1434,7 @@ namespace __gnu_norm\n                          const deque<_Tp, _Alloc>& __y)\n     { return __x.size() == __y.size()\n              && std::equal(__x.begin(), __x.end(), __y.begin()); }\n-  \n+\n   /**\n    *  @brief  Deque ordering relation.\n    *  @param  x  A %deque.\n@@ -1450,42 +1450,42 @@ namespace __gnu_norm\n     inline bool\n     operator<(const deque<_Tp, _Alloc>& __x,\n \t      const deque<_Tp, _Alloc>& __y)\n-    { return lexicographical_compare(__x.begin(), __x.end(), \n+    { return lexicographical_compare(__x.begin(), __x.end(),\n \t\t\t\t     __y.begin(), __y.end()); }\n-  \n+\n   /// Based on operator==\n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator!=(const deque<_Tp, _Alloc>& __x,\n \t       const deque<_Tp, _Alloc>& __y)\n     { return !(__x == __y); }\n-  \n+\n   /// Based on operator<\n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator>(const deque<_Tp, _Alloc>& __x,\n \t      const deque<_Tp, _Alloc>& __y)\n     { return __y < __x; }\n-  \n+\n   /// Based on operator<\n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator<=(const deque<_Tp, _Alloc>& __x,\n \t       const deque<_Tp, _Alloc>& __y)\n     { return !(__y < __x); }\n-  \n+\n   /// Based on operator<\n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator>=(const deque<_Tp, _Alloc>& __x,\n \t       const deque<_Tp, _Alloc>& __y)\n     { return !(__x < __y); }\n-  \n+\n   /// See std::deque::swap().\n   template<typename _Tp, typename _Alloc>\n     inline void\n     swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)\n     { __x.swap(__y); }\n } // namespace __gnu_norm\n-  \n+\n #endif /* _DEQUE_H */"}, {"sha": "74ddcce9d8bfa2fe7370950bed0d74997e5402c0", "filename": "libstdc++-v3/include/bits/stl_function.h", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_function.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_function.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_function.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -118,7 +118,7 @@ namespace std\n \n       typedef _Arg2 second_argument_type;  ///< the type of the second argument\n       typedef _Result result_type;         ///< type of the return type\n-    };      \n+    };\n   /** @}  */\n \n   // 20.3.2 arithmetic\n@@ -132,7 +132,7 @@ namespace std\n   /// One of the @link s20_3_2_arithmetic math functors@endlink.\n   template <class _Tp>\n     struct plus : public binary_function<_Tp, _Tp, _Tp>\n-    { \n+    {\n       _Tp\n       operator()(const _Tp& __x, const _Tp& __y) const\n       { return __x + __y; }\n@@ -193,7 +193,7 @@ namespace std\n    */\n   /// One of the @link s20_3_3_comparisons comparison functors@endlink.\n   template <class _Tp>\n-    struct equal_to : public binary_function<_Tp, _Tp, bool> \n+    struct equal_to : public binary_function<_Tp, _Tp, bool>\n     {\n       bool\n       operator()(const _Tp& __x, const _Tp& __y) const\n@@ -202,7 +202,7 @@ namespace std\n \n   /// One of the @link s20_3_3_comparisons comparison functors@endlink.\n   template <class _Tp>\n-    struct not_equal_to : public binary_function<_Tp, _Tp, bool> \n+    struct not_equal_to : public binary_function<_Tp, _Tp, bool>\n     {\n       bool\n       operator()(const _Tp& __x, const _Tp& __y) const\n@@ -245,7 +245,7 @@ namespace std\n       { return __x <= __y; }\n     };\n   /** @}  */\n-  \n+\n   // 20.3.4 logical operations\n   /** @defgroup s20_3_4_logical Boolean Operations Classes\n    *  Here are wrapper functors for Boolean operations:  @c &&, @c ||, and @c !.\n@@ -295,7 +295,7 @@ namespace std\n    *  {\n    *      bool operator() (int x) { return x > 3; }\n    *  };\n-   *  \n+   *\n    *  std::find_if (v.begin(), v.end(), not1(IntGreaterThanThree()));\n    *  \\endcode\n    *  The call to @c find_if will locate the first index (i) of @c v for which\n@@ -317,21 +317,21 @@ namespace std\n     public:\n       explicit\n       unary_negate(const _Predicate& __x) : _M_pred(__x) {}\n-      \n+\n       bool\n       operator()(const typename _Predicate::argument_type& __x) const\n       { return !_M_pred(__x); }\n     };\n \n   /// One of the @link s20_3_5_negators negation functors@endlink.\n   template <class _Predicate>\n-    inline unary_negate<_Predicate> \n+    inline unary_negate<_Predicate>\n     not1(const _Predicate& __pred)\n     { return unary_negate<_Predicate>(__pred); }\n \n   /// One of the @link s20_3_5_negators negation functors@endlink.\n-  template <class _Predicate> \n-    class binary_negate \n+  template <class _Predicate>\n+    class binary_negate\n     : public binary_function<typename _Predicate::first_argument_type,\n \t\t\t     typename _Predicate::second_argument_type,\n \t\t\t     bool>\n@@ -344,18 +344,18 @@ namespace std\n       : _M_pred(__x) { }\n \n       bool\n-      operator()(const typename _Predicate::first_argument_type& __x, \n+      operator()(const typename _Predicate::first_argument_type& __x,\n \t\t const typename _Predicate::second_argument_type& __y) const\n       { return !_M_pred(__x, __y); }\n     };\n \n   /// One of the @link s20_3_5_negators negation functors@endlink.\n   template <class _Predicate>\n-    inline binary_negate<_Predicate> \n+    inline binary_negate<_Predicate>\n     not2(const _Predicate& __pred)\n     { return binary_negate<_Predicate>(__pred); }\n   /** @}  */\n-  \n+\n   // 20.3.6 binders\n   /** @defgroup s20_3_6_binder Binder Classes\n    *  Binders turn functions/functors with two arguments into functors with\n@@ -388,7 +388,7 @@ namespace std\n    *  @{\n    */\n   /// One of the @link s20_3_6_binder binder functors@endlink.\n-  template <class _Operation> \n+  template <class _Operation>\n     class binder1st\n     : public unary_function<typename _Operation::second_argument_type,\n \t\t\t    typename _Operation::result_type>\n@@ -404,7 +404,7 @@ namespace std\n       typename _Operation::result_type\n       operator()(const typename _Operation::second_argument_type& __x) const\n       { return op(value, __x); }\n-      \n+\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 109.  Missing binders for non-const sequence elements\n       typename _Operation::result_type\n@@ -414,15 +414,15 @@ namespace std\n \n   /// One of the @link s20_3_6_binder binder functors@endlink.\n   template <class _Operation, class _Tp>\n-    inline binder1st<_Operation> \n-    bind1st(const _Operation& __fn, const _Tp& __x) \n+    inline binder1st<_Operation>\n+    bind1st(const _Operation& __fn, const _Tp& __x)\n     {\n       typedef typename _Operation::first_argument_type _Arg1_type;\n       return binder1st<_Operation>(__fn, _Arg1_type(__x));\n     }\n \n   /// One of the @link s20_3_6_binder binder functors@endlink.\n-  template <class _Operation> \n+  template <class _Operation>\n     class binder2nd\n     : public unary_function<typename _Operation::first_argument_type,\n \t\t\t    typename _Operation::result_type>\n@@ -432,13 +432,13 @@ namespace std\n       typename _Operation::second_argument_type value;\n     public:\n       binder2nd(const _Operation& __x,\n-\t\tconst typename _Operation::second_argument_type& __y) \n+\t\tconst typename _Operation::second_argument_type& __y)\n       : op(__x), value(__y) {}\n \n       typename _Operation::result_type\n       operator()(const typename _Operation::first_argument_type& __x) const\n       { return op(__x, value); }\n-      \n+\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 109.  Missing binders for non-const sequence elements\n       typename _Operation::result_type\n@@ -448,14 +448,14 @@ namespace std\n \n   /// One of the @link s20_3_6_binder binder functors@endlink.\n   template <class _Operation, class _Tp>\n-    inline binder2nd<_Operation> \n-    bind2nd(const _Operation& __fn, const _Tp& __x) \n+    inline binder2nd<_Operation>\n+    bind2nd(const _Operation& __fn, const _Tp& __x)\n     {\n       typedef typename _Operation::second_argument_type _Arg2_type;\n       return binder2nd<_Operation>(__fn, _Arg2_type(__x));\n     }\n   /** @}  */\n-  \n+\n   // 20.3.7 adaptors pointers functions\n   /** @defgroup s20_3_7_adaptors Adaptors for pointers to functions\n    *  The advantage of function objects over pointers to functions is that\n@@ -484,7 +484,7 @@ namespace std\n       _Result (*_M_ptr)(_Arg);\n     public:\n       pointer_to_unary_function() {}\n-      \n+\n       explicit\n       pointer_to_unary_function(_Result (*__x)(_Arg))\n       : _M_ptr(__x) {}\n@@ -511,7 +511,7 @@ namespace std\n       pointer_to_binary_function() {}\n \n       explicit\n-      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2)) \n+      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))\n       : _M_ptr(__x) {}\n \n       _Result\n@@ -521,18 +521,18 @@ namespace std\n \n   /// One of the @link s20_3_7_adaptors adaptors for function pointers@endlink.\n   template <class _Arg1, class _Arg2, class _Result>\n-    inline pointer_to_binary_function<_Arg1, _Arg2, _Result> \n+    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>\n     ptr_fun(_Result (*__x)(_Arg1, _Arg2))\n     { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }\n   /** @}  */\n-  \n+\n   template <class _Tp>\n     struct _Identity : public unary_function<_Tp,_Tp>\n     {\n       _Tp&\n       operator()(_Tp& __x) const\n       { return __x; }\n-      \n+\n       const _Tp&\n       operator()(const _Tp& __x) const\n       { return __x; }\n@@ -545,7 +545,7 @@ namespace std\n       typename _Pair::first_type&\n       operator()(_Pair& __x) const\n       { return __x.first; }\n-      \n+\n       const typename _Pair::first_type&\n       operator()(const _Pair& __x) const\n       { return __x.first; }\n@@ -558,7 +558,7 @@ namespace std\n       typename _Pair::second_type&\n       operator()(_Pair& __x) const\n       { return __x.second; }\n-      \n+\n       const typename _Pair::second_type&\n       operator()(const _Pair& __x) const\n       { return __x.second; }\n@@ -633,7 +633,7 @@ namespace std\n     private:\n       _Ret (_Tp::*_M_f)();\n   };\n-  \n+\n   /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n   template <class _Ret, class _Tp>\n     class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>\n@@ -656,7 +656,7 @@ namespace std\n     {\n     public:\n       explicit\n-      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg)) \n+      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))\n       : _M_f(__pf) {}\n \n       _Ret\n@@ -713,7 +713,7 @@ namespace std\n     private:\n       _Ret (_Tp::*_M_f)(_Arg) const;\n     };\n-  \n+\n   /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n   template <class _Tp>\n     class mem_fun_t<void, _Tp> : public unary_function<_Tp*, void>\n@@ -729,7 +729,7 @@ namespace std\n     private:\n       void (_Tp::*_M_f)();\n     };\n-  \n+\n   /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n   template <class _Tp>\n     class const_mem_fun_t<void, _Tp> : public unary_function<const _Tp*, void>\n@@ -745,7 +745,7 @@ namespace std\n     private:\n       void (_Tp::*_M_f)() const;\n     };\n-  \n+\n   /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n   template <class _Tp>\n     class mem_fun_ref_t<void, _Tp> : public unary_function<_Tp, void>\n@@ -777,7 +777,7 @@ namespace std\n     private:\n       void (_Tp::*_M_f)() const;\n     };\n-  \n+\n   /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n   template <class _Tp, class _Arg>\n     class mem_fun1_t<void, _Tp, _Arg> : public binary_function<_Tp*, _Arg, void>\n@@ -786,7 +786,7 @@ namespace std\n       explicit\n       mem_fun1_t(void (_Tp::*__pf)(_Arg))\n       : _M_f(__pf) {}\n-    \n+\n       void\n       operator()(_Tp* __p, _Arg __x) const\n       { (__p->*_M_f)(__x); }\n@@ -796,21 +796,21 @@ namespace std\n \n   /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n   template <class _Tp, class _Arg>\n-    class const_mem_fun1_t<void, _Tp, _Arg> \n+    class const_mem_fun1_t<void, _Tp, _Arg>\n     : public binary_function<const _Tp*, _Arg, void>\n     {\n     public:\n       explicit\n       const_mem_fun1_t(void (_Tp::*__pf)(_Arg) const)\n       : _M_f(__pf) {}\n-      \n+\n       void\n       operator()(const _Tp* __p, _Arg __x) const\n       { (__p->*_M_f)(__x); }\n     private:\n       void (_Tp::*_M_f)(_Arg) const;\n     };\n-  \n+\n   /// One of the @link s20_3_8_memadaptors adaptors for member pointers@endlink.\n   template <class _Tp, class _Arg>\n     class mem_fun1_ref_t<void, _Tp, _Arg>\n@@ -856,10 +856,10 @@ namespace std\n     inline const_mem_fun_t<_Ret, _Tp>\n     mem_fun(_Ret (_Tp::*__f)() const)\n     { return const_mem_fun_t<_Ret, _Tp>(__f); }\n-  \n+\n   template <class _Ret, class _Tp>\n     inline mem_fun_ref_t<_Ret, _Tp>\n-    mem_fun_ref(_Ret (_Tp::*__f)()) \n+    mem_fun_ref(_Ret (_Tp::*__f)())\n     { return mem_fun_ref_t<_Ret, _Tp>(__f); }\n \n   template <class _Ret, class _Tp>\n@@ -888,7 +888,7 @@ namespace std\n     { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }\n \n   /** @}  */\n-  \n+\n } // namespace std\n \n #endif /* _FUNCTION_H */"}, {"sha": "eff7fd351d7a448992da5de998d789c1c8466b16", "filename": "libstdc++-v3/include/bits/stl_heap.h", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_heap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_heap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_heap.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -74,7 +74,7 @@ namespace std\n       _Distance __parent = 0;\n       for (_Distance __child = 1; __child < __n; ++__child)\n \t{\n-\t  if (__first[__parent] < __first[__child]) \n+\t  if (__first[__parent] < __first[__child])\n \t    return false;\n \t  if ((__child & 1) == 0)\n \t    ++__parent;\n@@ -113,7 +113,7 @@ namespace std\n   // Heap-manipulation functions: push_heap, pop_heap, make_heap, sort_heap.\n \n   template<typename _RandomAccessIterator, typename _Distance, typename _Tp>\n-    void \n+    void\n     __push_heap(_RandomAccessIterator __first,\n \t\t_Distance __holeIndex, _Distance __topIndex, _Tp __value)\n     {\n@@ -137,7 +137,7 @@ namespace std\n    *  range [first,last-1).  After completion, [first,last) is a valid heap.\n   */\n   template<typename _RandomAccessIterator>\n-    inline void \n+    inline void\n     push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n     {\n       typedef typename iterator_traits<_RandomAccessIterator>::value_type\n@@ -156,7 +156,7 @@ namespace std\n \t\t       _DistanceType(0), _ValueType(*(__last - 1)));\n     }\n \n-  template<typename _RandomAccessIterator, typename _Distance, typename _Tp, \n+  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,\n \t    typename _Compare>\n     void\n     __push_heap(_RandomAccessIterator __first, _Distance __holeIndex,\n@@ -185,7 +185,7 @@ namespace std\n    *  Compare operations are performed using comp.\n   */\n   template<typename _RandomAccessIterator, typename _Compare>\n-    inline void \n+    inline void\n     push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n \t      _Compare __comp)\n     {\n@@ -205,7 +205,7 @@ namespace std\n     }\n \n   template<typename _RandomAccessIterator, typename _Distance, typename _Tp>\n-    void \n+    void\n     __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,\n \t\t  _Distance __len, _Tp __value)\n     {\n@@ -228,7 +228,7 @@ namespace std\n     }\n \n   template<typename _RandomAccessIterator, typename _Tp>\n-    inline void \n+    inline void\n     __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n \t       _RandomAccessIterator __result, _Tp __value)\n     {\n@@ -292,7 +292,7 @@ namespace std\n     }\n \n   template<typename _RandomAccessIterator, typename _Tp, typename _Compare>\n-    inline void \n+    inline void\n     __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n \t       _RandomAccessIterator __result, _Tp __value, _Compare __comp)\n     {\n@@ -315,7 +315,7 @@ namespace std\n    *  made using comp.\n   */\n   template<typename _RandomAccessIterator, typename _Compare>\n-    inline void \n+    inline void\n     pop_heap(_RandomAccessIterator __first,\n \t     _RandomAccessIterator __last, _Compare __comp)\n     {\n@@ -340,7 +340,7 @@ namespace std\n    *  This operation makes the elements in [first,last) into a heap.\n   */\n   template<typename _RandomAccessIterator>\n-    void \n+    void\n     make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n     {\n       typedef typename iterator_traits<_RandomAccessIterator>::value_type\n@@ -357,7 +357,7 @@ namespace std\n       if (__last - __first < 2)\n \treturn;\n \n-      const _DistanceType __len = __last - __first;    \n+      const _DistanceType __len = __last - __first;\n       _DistanceType __parent = (__len - 2) / 2;\n       while (true)\n \t{\n@@ -380,7 +380,7 @@ namespace std\n    *  Comparisons are made using comp.\n   */\n   template<typename _RandomAccessIterator, typename _Compare>\n-    inline void \n+    inline void\n     make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n \t      _Compare __comp)\n     {\n@@ -393,7 +393,7 @@ namespace std\n       __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<\n \t    _RandomAccessIterator>)\n       __glibcxx_requires_valid_range(__first, __last);\n-      \n+\n       if (__last - __first < 2)\n \treturn;\n \n@@ -444,7 +444,7 @@ namespace std\n    *  Comparisons are made using comp.\n   */\n   template<typename _RandomAccessIterator, typename _Compare>\n-    void \n+    void\n     sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n \t      _Compare __comp)\n     {"}, {"sha": "cc564314bc8b87b7e0b0b338ddbe81f6e528349e", "filename": "libstdc++-v3/include/bits/stl_iterator.h", "status": "modified", "additions": 100, "deletions": 100, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -87,7 +87,7 @@ namespace std\n    *  the requirement that the iterators must be safe.\n   */\n   template<typename _Iterator>\n-    class reverse_iterator \n+    class reverse_iterator\n     : public iterator<typename iterator_traits<_Iterator>::iterator_category,\n \t\t      typename iterator_traits<_Iterator>::value_type,\n \t\t      typename iterator_traits<_Iterator>::difference_type,\n@@ -98,9 +98,9 @@ namespace std\n       _Iterator current;\n \n     public:\n-      typedef _Iterator \t\t\t\t       iterator_type;\n-      typedef typename iterator_traits<_Iterator>::difference_type \t\n-      \t\t\t\t\t\t\t       difference_type;\n+      typedef _Iterator\t\t\t\t\t       iterator_type;\n+      typedef typename iterator_traits<_Iterator>::difference_type\n+\t\t\t\t\t\t\t       difference_type;\n       typedef typename iterator_traits<_Iterator>::reference   reference;\n       typedef typename iterator_traits<_Iterator>::pointer     pointer;\n \n@@ -116,13 +116,13 @@ namespace std\n       /**\n        *  This %iterator will move in the opposite direction that @p x does.\n       */\n-      explicit \n+      explicit\n       reverse_iterator(iterator_type __x) : current(__x) { }\n \n       /**\n        *  The copy constructor is normal.\n       */\n-      reverse_iterator(const reverse_iterator& __x) \n+      reverse_iterator(const reverse_iterator& __x)\n       : current(__x.current) { }\n \n       /**\n@@ -132,11 +132,11 @@ namespace std\n       template<typename _Iter>\n         reverse_iterator(const reverse_iterator<_Iter>& __x)\n \t: current(__x.base()) { }\n-    \n+\n       /**\n        *  @return  @c current, the %iterator used for underlying work.\n       */\n-      iterator_type \n+      iterator_type\n       base() const\n       { return current; }\n \n@@ -145,8 +145,8 @@ namespace std\n        *\n        *  @doctodo\n       */\n-      reference \n-      operator*() const \n+      reference\n+      operator*() const\n       {\n \t_Iterator __tmp = current;\n \treturn *--__tmp;\n@@ -157,7 +157,7 @@ namespace std\n        *\n        *  @doctodo\n       */\n-      pointer \n+      pointer\n       operator->() const\n       { return &(operator*()); }\n \n@@ -166,8 +166,8 @@ namespace std\n        *\n        *  @doctodo\n       */\n-      reverse_iterator& \n-      operator++() \n+      reverse_iterator&\n+      operator++()\n       {\n \t--current;\n \treturn *this;\n@@ -178,8 +178,8 @@ namespace std\n        *\n        *  @doctodo\n       */\n-      reverse_iterator \n-      operator++(int) \n+      reverse_iterator\n+      operator++(int)\n       {\n \treverse_iterator __tmp = *this;\n \t--current;\n@@ -191,8 +191,8 @@ namespace std\n        *\n        *  @doctodo\n       */\n-      reverse_iterator& \n-      operator--() \n+      reverse_iterator&\n+      operator--()\n       {\n \t++current;\n \treturn *this;\n@@ -203,29 +203,29 @@ namespace std\n        *\n        *  @doctodo\n       */\n-      reverse_iterator operator--(int) \n+      reverse_iterator operator--(int)\n       {\n \treverse_iterator __tmp = *this;\n \t++current;\n \treturn __tmp;\n       }\n-      \n+\n       /**\n        *  @return  TODO\n        *\n        *  @doctodo\n       */\n-      reverse_iterator \n-      operator+(difference_type __n) const \n+      reverse_iterator\n+      operator+(difference_type __n) const\n       { return reverse_iterator(current - __n); }\n \n       /**\n        *  @return  TODO\n        *\n        *  @doctodo\n       */\n-      reverse_iterator& \n-      operator+=(difference_type __n) \n+      reverse_iterator&\n+      operator+=(difference_type __n)\n       {\n \tcurrent -= __n;\n \treturn *this;\n@@ -236,17 +236,17 @@ namespace std\n        *\n        *  @doctodo\n       */\n-      reverse_iterator \n-      operator-(difference_type __n) const \n+      reverse_iterator\n+      operator-(difference_type __n) const\n       { return reverse_iterator(current + __n); }\n \n       /**\n        *  @return  TODO\n        *\n        *  @doctodo\n       */\n-      reverse_iterator& \n-      operator-=(difference_type __n) \n+      reverse_iterator&\n+      operator-=(difference_type __n)\n       {\n \tcurrent += __n;\n \treturn *this;\n@@ -257,11 +257,11 @@ namespace std\n        *\n        *  @doctodo\n       */\n-      reference \n+      reference\n       operator[](difference_type __n) const\n-      { return *(*this + __n); }  \n-    }; \n- \n+      { return *(*this + __n); }\n+    };\n+\n   //@{\n   /**\n    *  @param  x  A %reverse_iterator.\n@@ -273,51 +273,51 @@ namespace std\n    *\n   */\n   template<typename _Iterator>\n-    inline bool \n-    operator==(const reverse_iterator<_Iterator>& __x, \n-\t       const reverse_iterator<_Iterator>& __y) \n+    inline bool\n+    operator==(const reverse_iterator<_Iterator>& __x,\n+\t       const reverse_iterator<_Iterator>& __y)\n     { return __x.base() == __y.base(); }\n \n   template<typename _Iterator>\n-    inline bool \n-    operator<(const reverse_iterator<_Iterator>& __x, \n-\t      const reverse_iterator<_Iterator>& __y) \n+    inline bool\n+    operator<(const reverse_iterator<_Iterator>& __x,\n+\t      const reverse_iterator<_Iterator>& __y)\n     { return __y.base() < __x.base(); }\n \n   template<typename _Iterator>\n-    inline bool \n-    operator!=(const reverse_iterator<_Iterator>& __x, \n-\t       const reverse_iterator<_Iterator>& __y) \n+    inline bool\n+    operator!=(const reverse_iterator<_Iterator>& __x,\n+\t       const reverse_iterator<_Iterator>& __y)\n     { return !(__x == __y); }\n \n   template<typename _Iterator>\n-    inline bool \n-    operator>(const reverse_iterator<_Iterator>& __x, \n-\t      const reverse_iterator<_Iterator>& __y) \n+    inline bool\n+    operator>(const reverse_iterator<_Iterator>& __x,\n+\t      const reverse_iterator<_Iterator>& __y)\n     { return __y < __x; }\n \n   template<typename _Iterator>\n-    inline bool \n-    operator<=(const reverse_iterator<_Iterator>& __x, \n-\t\tconst reverse_iterator<_Iterator>& __y) \n+    inline bool\n+    operator<=(const reverse_iterator<_Iterator>& __x,\n+\t\tconst reverse_iterator<_Iterator>& __y)\n     { return !(__y < __x); }\n \n   template<typename _Iterator>\n-    inline bool \n-    operator>=(const reverse_iterator<_Iterator>& __x, \n-\t       const reverse_iterator<_Iterator>& __y) \n+    inline bool\n+    operator>=(const reverse_iterator<_Iterator>& __x,\n+\t       const reverse_iterator<_Iterator>& __y)\n     { return !(__x < __y); }\n \n   template<typename _Iterator>\n     inline typename reverse_iterator<_Iterator>::difference_type\n-    operator-(const reverse_iterator<_Iterator>& __x, \n-\t      const reverse_iterator<_Iterator>& __y) \n+    operator-(const reverse_iterator<_Iterator>& __x,\n+\t      const reverse_iterator<_Iterator>& __y)\n     { return __y.base() - __x.base(); }\n \n   template<typename _Iterator>\n-    inline reverse_iterator<_Iterator> \n+    inline reverse_iterator<_Iterator>\n     operator+(typename reverse_iterator<_Iterator>::difference_type __n,\n-\t      const reverse_iterator<_Iterator>& __x) \n+\t      const reverse_iterator<_Iterator>& __x)\n     { return reverse_iterator<_Iterator>(__x.base() - __n); }\n   //@}\n \n@@ -333,7 +333,7 @@ namespace std\n    *  save typing.\n   */\n   template<typename _Container>\n-    class back_insert_iterator \n+    class back_insert_iterator\n     : public iterator<output_iterator_tag, void, void, void, void>\n     {\n     protected:\n@@ -342,9 +342,9 @@ namespace std\n     public:\n       /// A nested typedef for the type of whatever container you used.\n       typedef _Container          container_type;\n-      \n+\n       /// The only way to create this %iterator is with a container.\n-      explicit \n+      explicit\n       back_insert_iterator(_Container& __x) : container(&__x) { }\n \n       /**\n@@ -359,19 +359,19 @@ namespace std\n        *  always append the value to the end of the container.\n       */\n       back_insert_iterator&\n-      operator=(typename _Container::const_reference __value) \n-      { \n+      operator=(typename _Container::const_reference __value)\n+      {\n \tcontainer->push_back(__value);\n \treturn *this;\n       }\n \n       /// Simply returns *this.\n-      back_insert_iterator& \n+      back_insert_iterator&\n       operator*()\n       { return *this; }\n \n       /// Simply returns *this.  (This %iterator does not \"move\".)\n-      back_insert_iterator& \n+      back_insert_iterator&\n       operator++()\n       { return *this; }\n \n@@ -393,8 +393,8 @@ namespace std\n    *  types for you.\n   */\n   template<typename _Container>\n-    inline back_insert_iterator<_Container> \n-    back_inserter(_Container& __x) \n+    inline back_insert_iterator<_Container>\n+    back_inserter(_Container& __x)\n     { return back_insert_iterator<_Container>(__x); }\n \n   /**\n@@ -408,7 +408,7 @@ namespace std\n    *  save typing.\n   */\n   template<typename _Container>\n-    class front_insert_iterator \n+    class front_insert_iterator\n     : public iterator<output_iterator_tag, void, void, void, void>\n     {\n     protected:\n@@ -433,24 +433,24 @@ namespace std\n        *  always prepend the value to the front of the container.\n       */\n       front_insert_iterator&\n-      operator=(typename _Container::const_reference __value) \n-      { \n+      operator=(typename _Container::const_reference __value)\n+      {\n \tcontainer->push_front(__value);\n \treturn *this;\n       }\n \n       /// Simply returns *this.\n-      front_insert_iterator& \n+      front_insert_iterator&\n       operator*()\n       { return *this; }\n \n       /// Simply returns *this.  (This %iterator does not \"move\".)\n-      front_insert_iterator& \n+      front_insert_iterator&\n       operator++()\n       { return *this; }\n \n       /// Simply returns *this.  (This %iterator does not \"move\".)\n-      front_insert_iterator \n+      front_insert_iterator\n       operator++(int)\n       { return *this; }\n     };\n@@ -467,8 +467,8 @@ namespace std\n    *  types for you.\n   */\n   template<typename _Container>\n-    inline front_insert_iterator<_Container> \n-    front_inserter(_Container& __x) \n+    inline front_insert_iterator<_Container>\n+    front_inserter(_Container& __x)\n     { return front_insert_iterator<_Container>(__x); }\n \n   /**\n@@ -486,7 +486,7 @@ namespace std\n    *  save typing.\n   */\n   template<typename _Container>\n-    class insert_iterator \n+    class insert_iterator\n     : public iterator<output_iterator_tag, void, void, void, void>\n     {\n     protected:\n@@ -496,14 +496,14 @@ namespace std\n     public:\n       /// A nested typedef for the type of whatever container you used.\n       typedef _Container          container_type;\n-      \n+\n       /**\n        *  The only way to create this %iterator is with a container and an\n        *  initial position (a normal %iterator into the container).\n       */\n-      insert_iterator(_Container& __x, typename _Container::iterator __i) \n+      insert_iterator(_Container& __x, typename _Container::iterator __i)\n       : container(&__x), iter(__i) {}\n-   \n+\n       /**\n        *  @param  value  An instance of whatever type\n        *                 container_type::const_reference is; presumably a\n@@ -528,29 +528,29 @@ namespace std\n        *  @endcode\n       */\n       insert_iterator&\n-      operator=(const typename _Container::const_reference __value) \n-      { \n+      operator=(const typename _Container::const_reference __value)\n+      {\n \titer = container->insert(iter, __value);\n \t++iter;\n \treturn *this;\n       }\n \n       /// Simply returns *this.\n-      insert_iterator& \n+      insert_iterator&\n       operator*()\n       { return *this; }\n \n       /// Simply returns *this.  (This %iterator does not \"move\".)\n-      insert_iterator& \n+      insert_iterator&\n       operator++()\n       { return *this; }\n \n       /// Simply returns *this.  (This %iterator does not \"move\".)\n-      insert_iterator& \n+      insert_iterator&\n       operator++(int)\n       { return *this; }\n     };\n-  \n+\n   /**\n    *  @param  x  A container of arbitrary type.\n    *  @return  An instance of insert_iterator working on @p x.\n@@ -563,16 +563,16 @@ namespace std\n    *  types for you.\n   */\n   template<typename _Container, typename _Iterator>\n-    inline insert_iterator<_Container> \n+    inline insert_iterator<_Container>\n     inserter(_Container& __x, _Iterator __i)\n     {\n-      return insert_iterator<_Container>(__x, \n+      return insert_iterator<_Container>(__x,\n \t\t\t\t\t typename _Container::iterator(__i));\n     }\n } // namespace std\n \n namespace __gnu_cxx\n-{  \n+{\n   // This iterator adapter is 'normal' in the sense that it does not\n   // change the semantics of any of the operators of its iterator\n   // parameter.  Its primary purpose is to convert an iterator that is\n@@ -587,19 +587,19 @@ namespace __gnu_cxx\n     {\n     protected:\n       _Iterator _M_current;\n-      \n+\n     public:\n       typedef typename iterator_traits<_Iterator>::iterator_category\n                                                              iterator_category;\n       typedef typename iterator_traits<_Iterator>::value_type  value_type;\n-      typedef typename iterator_traits<_Iterator>::difference_type \t\n+      typedef typename iterator_traits<_Iterator>::difference_type\n                                                              difference_type;\n       typedef typename iterator_traits<_Iterator>::reference reference;\n       typedef typename iterator_traits<_Iterator>::pointer   pointer;\n \n       __normal_iterator() : _M_current(_Iterator()) { }\n \n-      explicit \n+      explicit\n       __normal_iterator(const _Iterator& __i) : _M_current(__i) { }\n \n       // Allow iterator to const_iterator conversion\n@@ -612,56 +612,56 @@ namespace __gnu_cxx\n       reference\n       operator*() const\n       { return *_M_current; }\n-      \n+\n       pointer\n       operator->() const\n       { return _M_current; }\n-      \n+\n       __normal_iterator&\n       operator++()\n       {\n \t++_M_current;\n \treturn *this;\n       }\n-      \n+\n       __normal_iterator\n       operator++(int)\n       { return __normal_iterator(_M_current++); }\n-      \n+\n       // Bidirectional iterator requirements\n       __normal_iterator&\n       operator--()\n       {\n \t--_M_current;\n \treturn *this;\n       }\n-      \n+\n       __normal_iterator\n       operator--(int)\n       { return __normal_iterator(_M_current--); }\n-      \n+\n       // Random access iterator requirements\n       reference\n       operator[](const difference_type& __n) const\n       { return _M_current[__n]; }\n-      \n+\n       __normal_iterator&\n       operator+=(const difference_type& __n)\n       { _M_current += __n; return *this; }\n \n       __normal_iterator\n       operator+(const difference_type& __n) const\n       { return __normal_iterator(_M_current + __n); }\n-      \n+\n       __normal_iterator&\n       operator-=(const difference_type& __n)\n       { _M_current -= __n; return *this; }\n-      \n+\n       __normal_iterator\n       operator-(const difference_type& __n) const\n       { return __normal_iterator(_M_current - __n); }\n-      \n-      const _Iterator& \n+\n+      const _Iterator&\n       base() const\n       { return _M_current; }\n     };\n@@ -673,7 +673,7 @@ namespace __gnu_cxx\n   // will make overload resolution ambiguous (when in scope) if we don't\n   // provide overloads whose operands are of the same type.  Can someone\n   // remind me what generic programming is about? -- Gaby\n-  \n+\n   // Forward iterator requirements\n   template<typename _IteratorL, typename _IteratorR, typename _Container>\n     inline bool\n@@ -701,7 +701,7 @@ namespace __gnu_cxx\n \n   // Random access iterator requirements\n   template<typename _IteratorL, typename _IteratorR, typename _Container>\n-    inline bool \n+    inline bool\n     operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,\n \t      const __normal_iterator<_IteratorR, _Container>& __rhs)\n     { return __lhs.base() < __rhs.base(); }\n@@ -765,7 +765,7 @@ namespace __gnu_cxx\n     { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }\n } // namespace __gnu_cxx\n \n-#endif \n+#endif\n \n // Local Variables:\n // mode:C++"}, {"sha": "c514e81a0893e291ade2aeaf32cd92804f196d59", "filename": "libstdc++-v3/include/bits/stl_iterator_base_funcs.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_funcs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_funcs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_funcs.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -76,7 +76,7 @@ namespace std\n     {\n       // concept requirements\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)\n-  \n+\n       typename iterator_traits<_InputIterator>::difference_type __n = 0;\n       while (__first != __last)\n \t{\n@@ -85,7 +85,7 @@ namespace std\n \t}\n       return __n;\n     }\n-  \n+\n   template<typename _RandomAccessIterator>\n     inline typename iterator_traits<_RandomAccessIterator>::difference_type\n     __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,\n@@ -96,7 +96,7 @@ namespace std\n \t\t\t\t  _RandomAccessIterator>)\n       return __last - __first;\n     }\n-  \n+\n   /**\n    *  @brief A generalization of pointer arithmetic.\n    *  @param  first  An input iterator.\n@@ -117,7 +117,7 @@ namespace std\n       return std::__distance(__first, __last,\n \t\t\t     std::__iterator_category(__first));\n     }\n-  \n+\n   template<typename _InputIterator, typename _Distance>\n     inline void\n     __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)\n@@ -127,7 +127,7 @@ namespace std\n       while (__n--)\n \t++__i;\n     }\n-  \n+\n   template<typename _BidirectionalIterator, typename _Distance>\n     inline void\n     __advance(_BidirectionalIterator& __i, _Distance __n,\n@@ -143,7 +143,7 @@ namespace std\n         while (__n++)\n \t  --__i;\n     }\n-  \n+\n   template<typename _RandomAccessIterator, typename _Distance>\n     inline void\n     __advance(_RandomAccessIterator& __i, _Distance __n,\n@@ -154,7 +154,7 @@ namespace std\n \t\t\t\t  _RandomAccessIterator>)\n       __i += __n;\n     }\n-  \n+\n   /**\n    *  @brief A generalization of pointer arithmetic.\n    *  @param  i  An input iterator."}, {"sha": "15f73914a2df33fe98e101434098d0276a22510f", "filename": "libstdc++-v3/include/bits/stl_list.h", "status": "modified", "additions": 122, "deletions": 122, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -69,7 +69,7 @@ namespace __gnu_norm\n   // latter publicly inherits from the former in an effort to reduce code\n   // duplication.  This results in some \"needless\" static_cast'ing later on,\n   // but it's all safe downcasting.\n-  \n+\n   /// @if maint Common part of a node in the %list.  @endif\n   struct _List_node_base\n   {\n@@ -88,18 +88,18 @@ namespace __gnu_norm\n \n     void\n     hook(_List_node_base * const __position);\n-    \n+\n     void\n     unhook();\n   };\n-  \n+\n   /// @if maint An actual node in the %list.  @endif\n   template<typename _Tp>\n     struct _List_node : public _List_node_base\n     {\n       _Tp _M_data;                ///< User's data.\n     };\n-  \n+\n   /**\n    *  @brief A list::iterator.\n    *\n@@ -112,13 +112,13 @@ namespace __gnu_norm\n     {\n       typedef _List_iterator<_Tp>           _Self;\n       typedef _List_node<_Tp>               _Node;\n-      \n+\n       typedef ptrdiff_t                     difference_type;\n       typedef bidirectional_iterator_tag    iterator_category;\n       typedef _Tp                           value_type;\n       typedef _Tp*                          pointer;\n       typedef _Tp&                          reference;\n-      \n+\n       _List_iterator() { }\n \n       _List_iterator(_List_node_base* __x)\n@@ -132,49 +132,49 @@ namespace __gnu_norm\n       pointer\n       operator->() const\n       { return &static_cast<_Node*>(_M_node)->_M_data; }\n-      \n+\n       _Self&\n       operator++()\n       {\n \t_M_node = _M_node->_M_next;\n \treturn *this;\n       }\n-  \n+\n       _Self\n       operator++(int)\n       {\n \t_Self __tmp = *this;\n \t_M_node = _M_node->_M_next;\n \treturn __tmp;\n       }\n-      \n+\n       _Self&\n       operator--()\n       {\n \t_M_node = _M_node->_M_prev;\n \treturn *this;\n       }\n-  \n+\n       _Self\n       operator--(int)\n       {\n \t_Self __tmp = *this;\n \t_M_node = _M_node->_M_prev;\n \treturn __tmp;\n       }\n-      \n+\n       bool\n       operator==(const _Self& __x) const\n       { return _M_node == __x._M_node; }\n \n       bool\n       operator!=(const _Self& __x) const\n       { return _M_node != __x._M_node; }\n-      \n+\n       // The only member points to the %list element.\n       _List_node_base* _M_node;\n     };\n-  \n+\n   /**\n    *  @brief A list::const_iterator.\n    *\n@@ -188,13 +188,13 @@ namespace __gnu_norm\n       typedef _List_const_iterator<_Tp>     _Self;\n       typedef const _List_node<_Tp>         _Node;\n       typedef _List_iterator<_Tp>           iterator;\n-      \n+\n       typedef ptrdiff_t                     difference_type;\n       typedef bidirectional_iterator_tag    iterator_category;\n       typedef _Tp                           value_type;\n       typedef const _Tp*                    pointer;\n       typedef const _Tp&                    reference;\n-      \n+\n       _List_const_iterator() { }\n \n       _List_const_iterator(const _List_node_base* __x)\n@@ -212,62 +212,62 @@ namespace __gnu_norm\n       pointer\n       operator->() const\n       { return &static_cast<_Node*>(_M_node)->_M_data; }\n-      \n+\n       _Self&\n       operator++()\n       {\n \t_M_node = _M_node->_M_next;\n \treturn *this;\n       }\n-      \n+\n       _Self\n       operator++(int)\n       {\n \t_Self __tmp = *this;\n \t_M_node = _M_node->_M_next;\n \treturn __tmp;\n       }\n-      \n+\n       _Self&\n       operator--()\n       {\n \t_M_node = _M_node->_M_prev;\n \treturn *this;\n       }\n-  \n+\n       _Self\n       operator--(int)\n       {\n \t_Self __tmp = *this;\n \t_M_node = _M_node->_M_prev;\n \treturn __tmp;\n       }\n-      \n+\n       bool\n       operator==(const _Self& __x) const\n       { return _M_node == __x._M_node; }\n-      \n+\n       bool\n       operator!=(const _Self& __x) const\n       { return _M_node != __x._M_node; }\n-      \n+\n       // The only member points to the %list element.\n       const _List_node_base* _M_node;\n     };\n-  \n+\n   template<typename _Val>\n-    inline bool \n-    operator==(const _List_iterator<_Val>& __x, \n-\t       const _List_const_iterator<_Val>& __y) \n+    inline bool\n+    operator==(const _List_iterator<_Val>& __x,\n+\t       const _List_const_iterator<_Val>& __y)\n     { return __x._M_node == __y._M_node; }\n \n   template<typename _Val>\n-    inline bool \n+    inline bool\n     operator!=(const _List_iterator<_Val>& __x,\n-               const _List_const_iterator<_Val>& __y) \n+               const _List_const_iterator<_Val>& __y)\n     { return __x._M_node != __y._M_node; }\n \n-  \n+\n   /**\n    *  @if maint\n    *  See bits/stl_deque.h's _Deque_base for an explanation.\n@@ -300,26 +300,26 @@ namespace __gnu_norm\n       _List_node<_Tp>*\n       _M_get_node()\n       { return _Node_Alloc_type::allocate(1); }\n-      \n+\n       void\n       _M_put_node(_List_node<_Tp>* __p)\n       { _Node_Alloc_type::deallocate(__p, 1); }\n \n   public:\n       typedef _Alloc allocator_type;\n \n-      allocator_type \n+      allocator_type\n       get_allocator() const\n       { return allocator_type(*static_cast<const _Node_Alloc_type*>(this)); }\n \n       _List_base(const allocator_type& __a)\n       : _Node_Alloc_type(__a)\n       { _M_init(); }\n-  \n+\n       // This is what actually destroys the list.\n       ~_List_base()\n       { _M_clear(); }\n-      \n+\n       void\n       _M_clear();\n \n@@ -330,7 +330,7 @@ namespace __gnu_norm\n         this->_M_node._M_prev = &this->_M_node;\n       }\n     };\n-  \n+\n   /**\n    *  @brief A standard container with linear time access to elements,\n    *  and fixed time insertion/deletion at any point in the sequence.\n@@ -381,9 +381,9 @@ namespace __gnu_norm\n     {\n       // concept requirements\n       __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n-  \n+\n       typedef _List_base<_Tp, _Alloc>                   _Base;\n-  \n+\n     public:\n       typedef _Tp                                       value_type;\n       typedef value_type*                               pointer;\n@@ -397,12 +397,12 @@ namespace __gnu_norm\n       typedef size_t                                    size_type;\n       typedef ptrdiff_t                                 difference_type;\n       typedef typename _Base::allocator_type            allocator_type;\n-  \n+\n     protected:\n       // Note that pointers-to-_Node's can be ctor-converted to\n       // iterator types.\n-      typedef _List_node<_Tp>               \t\t_Node;\n-  \n+      typedef _List_node<_Tp>\t\t\t\t_Node;\n+\n       /** @if maint\n        *  One data member plus two memory-handling functions.  If the\n        *  _Alloc type requires separate instances, then one of those\n@@ -412,7 +412,7 @@ namespace __gnu_norm\n       using _Base::_M_node;\n       using _Base::_M_put_node;\n       using _Base::_M_get_node;\n-      \n+\n       /**\n        *  @if maint\n        *  @param  x  An instance of user data.\n@@ -424,7 +424,7 @@ namespace __gnu_norm\n       _M_create_node(const value_type& __x)\n       {\n \t_Node* __p = this->_M_get_node();\n-\ttry \n+\ttry\n \t  {\n \t    std::_Construct(&__p->_M_data, __x);\n \t  }\n@@ -435,7 +435,7 @@ namespace __gnu_norm\n \t  }\n \treturn __p;\n       }\n-  \n+\n       /**\n        *  @if maint\n        *  Allocates space for a new node and default-constructs a new\n@@ -446,7 +446,7 @@ namespace __gnu_norm\n       _M_create_node()\n       {\n \t_Node* __p = this->_M_get_node();\n-\ttry \n+\ttry\n \t  {\n \t    std::_Construct(&__p->_M_data);\n \t  }\n@@ -457,7 +457,7 @@ namespace __gnu_norm\n \t  }\n \treturn __p;\n       }\n-      \n+\n     public:\n       // [23.2.2.1] construct/copy/destroy\n       // (assign() and get_allocator() are also listed in this section)\n@@ -467,47 +467,47 @@ namespace __gnu_norm\n       explicit\n       list(const allocator_type& __a = allocator_type())\n       : _Base(__a) { }\n-  \n+\n       /**\n        *  @brief  Create a %list with copies of an exemplar element.\n        *  @param  n  The number of elements to initially create.\n        *  @param  value  An element to copy.\n-       * \n+       *\n        *  This constructor fills the %list with @a n copies of @a value.\n        */\n       list(size_type __n, const value_type& __value,\n \t   const allocator_type& __a = allocator_type())\n       : _Base(__a)\n       { this->insert(begin(), __n, __value); }\n-  \n+\n       /**\n        *  @brief  Create a %list with default elements.\n        *  @param  n  The number of elements to initially create.\n-       * \n+       *\n        *  This constructor fills the %list with @a n copies of a\n        *  default-constructed element.\n        */\n       explicit\n       list(size_type __n)\n       : _Base(allocator_type())\n       { this->insert(begin(), __n, value_type()); }\n-  \n+\n       /**\n        *  @brief  %List copy constructor.\n        *  @param  x  A %list of identical element and allocator types.\n-       * \n+       *\n        *  The newly-created %list uses a copy of the allocation object used\n        *  by @a x.\n        */\n       list(const list& __x)\n       : _Base(__x.get_allocator())\n       { this->insert(begin(), __x.begin(), __x.end()); }\n-      \n+\n       /**\n        *  @brief  Builds a %list from a range.\n        *  @param  first  An input iterator.\n        *  @param  last  An input iterator.\n-       * \n+       *\n        *  Create a %list consisting of copies of the elements from\n        *  [@a first,@a last).  This is linear in N (where N is\n        *  distance(@a first,@a last)).\n@@ -522,25 +522,25 @@ namespace __gnu_norm\n \t     const allocator_type& __a = allocator_type())\n         : _Base(__a)\n         { this->insert(begin(), __first, __last); }\n-  \n+\n       /**\n        *  No explicit dtor needed as the _Base dtor takes care of\n        *  things.  The _Base dtor only erases the elements, and note\n        *  that if the elements themselves are pointers, the pointed-to\n        *  memory is not touched in any way.  Managing the pointer is\n        *  the user's responsibilty.\n        */\n-  \n+\n       /**\n        *  @brief  %List assignment operator.\n        *  @param  x  A %list of identical element and allocator types.\n-       * \n+       *\n        *  All the elements of @a x are copied, but unlike the copy\n        *  constructor, the allocator object is not copied.\n        */\n       list&\n       operator=(const list& __x);\n-      \n+\n       /**\n        *  @brief  Assigns a given value to a %list.\n        *  @param  n  Number of elements to be assigned.\n@@ -552,9 +552,9 @@ namespace __gnu_norm\n        *  of elements assigned.  Old data may be lost.\n        */\n       void\n-      assign(size_type __n, const value_type& __val) \n+      assign(size_type __n, const value_type& __val)\n       { _M_fill_assign(__n, __val); }\n-      \n+\n       /**\n        *  @brief  Assigns a range to a %list.\n        *  @param  first  An input iterator.\n@@ -570,17 +570,17 @@ namespace __gnu_norm\n       template<typename _InputIterator>\n         void\n         assign(_InputIterator __first, _InputIterator __last)\n-        { \n+        {\n \t  // Check whether it's an integral type.  If so, it's not an iterator.\n \t  typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n \t  _M_assign_dispatch(__first, __last, _Integral());\n \t}\n-  \n+\n       /// Get a copy of the memory allocation object.\n       allocator_type\n       get_allocator() const\n       { return _Base::get_allocator(); }\n-      \n+\n       // iterators\n       /**\n        *  Returns a read/write iterator that points to the first element in the\n@@ -589,7 +589,7 @@ namespace __gnu_norm\n       iterator\n       begin()\n       { return this->_M_node._M_next; }\n-      \n+\n       /**\n        *  Returns a read-only (constant) iterator that points to the\n        *  first element in the %list.  Iteration is done in ordinary\n@@ -598,15 +598,15 @@ namespace __gnu_norm\n       const_iterator\n       begin() const\n       { return this->_M_node._M_next; }\n-      \n+\n       /**\n        *  Returns a read/write iterator that points one past the last\n        *  element in the %list.  Iteration is done in ordinary element\n        *  order.\n        */\n       iterator\n       end() { return &this->_M_node; }\n-      \n+\n       /**\n        *  Returns a read-only (constant) iterator that points one past\n        *  the last element in the %list.  Iteration is done in ordinary\n@@ -615,7 +615,7 @@ namespace __gnu_norm\n       const_iterator\n       end() const\n       { return &this->_M_node; }\n-      \n+\n       /**\n        *  Returns a read/write reverse iterator that points to the last\n        *  element in the %list.  Iteration is done in reverse element\n@@ -624,7 +624,7 @@ namespace __gnu_norm\n       reverse_iterator\n       rbegin()\n       { return reverse_iterator(end()); }\n-      \n+\n       /**\n        *  Returns a read-only (constant) reverse iterator that points to\n        *  the last element in the %list.  Iteration is done in reverse\n@@ -633,7 +633,7 @@ namespace __gnu_norm\n       const_reverse_iterator\n       rbegin() const\n       { return const_reverse_iterator(end()); }\n-      \n+\n       /**\n        *  Returns a read/write reverse iterator that points to one\n        *  before the first element in the %list.  Iteration is done in\n@@ -642,7 +642,7 @@ namespace __gnu_norm\n       reverse_iterator\n       rend()\n       { return reverse_iterator(begin()); }\n-      \n+\n       /**\n        *  Returns a read-only (constant) reverse iterator that points to one\n        *  before the first element in the %list.  Iteration is done in reverse\n@@ -651,7 +651,7 @@ namespace __gnu_norm\n       const_reverse_iterator\n       rend() const\n       { return const_reverse_iterator(begin()); }\n-      \n+\n       // [23.2.2.2] capacity\n       /**\n        *  Returns true if the %list is empty.  (Thus begin() would equal\n@@ -660,17 +660,17 @@ namespace __gnu_norm\n       bool\n       empty() const\n       { return this->_M_node._M_next == &this->_M_node; }\n-      \n+\n       /**  Returns the number of elements in the %list.  */\n       size_type\n       size() const\n       { return std::distance(begin(), end()); }\n-      \n+\n       /**  Returns the size() of the largest possible %list.  */\n       size_type\n       max_size() const\n       { return size_type(-1); }\n-      \n+\n       /**\n        *  @brief Resizes the %list to the specified number of elements.\n        *  @param new_size Number of elements the %list should contain.\n@@ -683,7 +683,7 @@ namespace __gnu_norm\n        */\n       void\n       resize(size_type __new_size, const value_type& __x);\n-      \n+\n       /**\n        *  @brief  Resizes the %list to the specified number of elements.\n        *  @param  new_size  Number of elements the %list should contain.\n@@ -696,7 +696,7 @@ namespace __gnu_norm\n       void\n       resize(size_type __new_size)\n       { this->resize(__new_size, value_type()); }\n-      \n+\n       // element access\n       /**\n        *  Returns a read/write reference to the data at the first\n@@ -705,31 +705,31 @@ namespace __gnu_norm\n       reference\n       front()\n       { return *begin(); }\n-      \n+\n       /**\n        *  Returns a read-only (constant) reference to the data at the first\n        *  element of the %list.\n        */\n       const_reference\n       front() const\n       { return *begin(); }\n-      \n+\n       /**\n        *  Returns a read/write reference to the data at the last element\n        *  of the %list.\n        */\n       reference\n       back()\n       { return *(--end()); }\n-      \n+\n       /**\n        *  Returns a read-only (constant) reference to the data at the last\n        *  element of the %list.\n        */\n       const_reference\n       back() const\n       { return *(--end()); }\n-      \n+\n       // [23.2.2.3] modifiers\n       /**\n        *  @brief  Add data to the front of the %list.\n@@ -744,7 +744,7 @@ namespace __gnu_norm\n       void\n       push_front(const value_type& __x)\n       { this->_M_insert(begin(), __x); }\n-  \n+\n       /**\n        *  @brief  Removes first element.\n        *\n@@ -760,7 +760,7 @@ namespace __gnu_norm\n       void\n       pop_front()\n       { this->_M_erase(begin()); }\n-      \n+\n       /**\n        *  @brief  Add data to the end of the %list.\n        *  @param  x  Data to be added.\n@@ -774,7 +774,7 @@ namespace __gnu_norm\n       void\n       push_back(const value_type& __x)\n       { this->_M_insert(end(), __x); }\n-      \n+\n       /**\n        *  @brief  Removes last element.\n        *\n@@ -789,7 +789,7 @@ namespace __gnu_norm\n       void\n       pop_back()\n       { this->_M_erase(this->_M_node._M_prev); }\n-      \n+\n       /**\n        *  @brief  Inserts given value into %list before specified iterator.\n        *  @param  position  An iterator into the %list.\n@@ -803,7 +803,7 @@ namespace __gnu_norm\n        */\n       iterator\n       insert(iterator __position, const value_type& __x);\n-      \n+\n       /**\n        *  @brief  Inserts a number of copies of given data into the %list.\n        *  @param  position  An iterator into the %list.\n@@ -820,7 +820,7 @@ namespace __gnu_norm\n       void\n       insert(iterator __position, size_type __n, const value_type& __x)\n       { _M_fill_insert(__position, __n, __x); }\n-      \n+\n       /**\n        *  @brief  Inserts a range into the %list.\n        *  @param  position  An iterator into the %list.\n@@ -837,14 +837,14 @@ namespace __gnu_norm\n        */\n       template<typename _InputIterator>\n         void\n-        insert(iterator __position, _InputIterator __first, \n+        insert(iterator __position, _InputIterator __first,\n \t       _InputIterator __last)\n         {\n \t  // Check whether it's an integral type.  If so, it's not an iterator.\n \t  typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n \t  _M_insert_dispatch(__position, __first, __last, _Integral());\n \t}\n-      \n+\n       /**\n        *  @brief  Remove element at given position.\n        *  @param  position  Iterator pointing to element to be erased.\n@@ -862,7 +862,7 @@ namespace __gnu_norm\n        */\n       iterator\n       erase(iterator __position);\n-  \n+\n       /**\n        *  @brief  Remove a range of elements.\n        *  @param  first  Iterator pointing to the first element to be erased.\n@@ -889,7 +889,7 @@ namespace __gnu_norm\n \t  __first = erase(__first);\n \treturn __last;\n       }\n-  \n+\n       /**\n        *  @brief  Swaps data with another %list.\n        *  @param  x  A %list of the same element and allocator types.\n@@ -902,7 +902,7 @@ namespace __gnu_norm\n       void\n       swap(list& __x)\n       { _List_node_base::swap(this->_M_node,__x._M_node); }\n-  \n+\n       /**\n        *  Erases all the elements.  Note that this function only erases\n        *  the elements, and that if the elements themselves are\n@@ -915,7 +915,7 @@ namespace __gnu_norm\n         _Base::_M_clear();\n         _Base::_M_init();\n       }\n-  \n+\n       // [23.2.2.4] list operations\n       /**\n        *  @brief  Insert contents of another %list.\n@@ -932,7 +932,7 @@ namespace __gnu_norm\n \tif (!__x.empty())\n \t  this->_M_transfer(__position, __x.begin(), __x.end());\n       }\n-  \n+\n       /**\n        *  @brief  Insert element from another %list.\n        *  @param  position  Iterator referencing the element to insert before.\n@@ -951,7 +951,7 @@ namespace __gnu_norm\n \t  return;\n \tthis->_M_transfer(__position, __i, __j);\n       }\n-  \n+\n       /**\n        *  @brief  Insert range from another %list.\n        *  @param  position  Iterator referencing the element to insert before.\n@@ -970,7 +970,7 @@ namespace __gnu_norm\n \tif (__first != __last)\n \t  this->_M_transfer(__position, __first, __last);\n       }\n-  \n+\n       /**\n        *  @brief  Remove all elements equal to value.\n        *  @param  value  The value to remove.\n@@ -984,7 +984,7 @@ namespace __gnu_norm\n        */\n       void\n       remove(const _Tp& __value);\n-  \n+\n       /**\n        *  @brief  Remove all elements satisfying a predicate.\n        *  @param  Predicate  Unary predicate function or object.\n@@ -999,7 +999,7 @@ namespace __gnu_norm\n       template<typename _Predicate>\n       void\n       remove_if(_Predicate);\n-  \n+\n       /**\n        *  @brief  Remove consecutive duplicate elements.\n        *\n@@ -1012,7 +1012,7 @@ namespace __gnu_norm\n        */\n       void\n       unique();\n-  \n+\n       /**\n        *  @brief  Remove consecutive elements satisfying a predicate.\n        *  @param  BinaryPredicate  Binary predicate function or object.\n@@ -1028,7 +1028,7 @@ namespace __gnu_norm\n       template<typename _BinaryPredicate>\n         void\n         unique(_BinaryPredicate);\n-  \n+\n       /**\n        *  @brief  Merge sorted lists.\n        *  @param  x  Sorted list to merge.\n@@ -1040,7 +1040,7 @@ namespace __gnu_norm\n        */\n       void\n       merge(list& __x);\n-  \n+\n       /**\n        *  @brief  Merge sorted lists according to comparison function.\n        *  @param  x  Sorted list to merge.\n@@ -1056,7 +1056,7 @@ namespace __gnu_norm\n       template<typename _StrictWeakOrdering>\n         void\n         merge(list&, _StrictWeakOrdering);\n-  \n+\n       /**\n        *  @brief  Reverse the elements in list.\n        *\n@@ -1065,7 +1065,7 @@ namespace __gnu_norm\n       void\n       reverse()\n       { this->_M_node.reverse(); }\n-  \n+\n       /**\n        *  @brief  Sort the elements.\n        *\n@@ -1074,7 +1074,7 @@ namespace __gnu_norm\n        */\n       void\n       sort();\n-  \n+\n       /**\n        *  @brief  Sort the elements according to comparison function.\n        *\n@@ -1084,10 +1084,10 @@ namespace __gnu_norm\n       template<typename _StrictWeakOrdering>\n         void\n         sort(_StrictWeakOrdering);\n-  \n+\n     protected:\n       // Internal assign functions follow.\n-      \n+\n       // Called by the range assign to implement [23.1.1]/9\n       template<typename _Integer>\n         void\n@@ -1096,21 +1096,21 @@ namespace __gnu_norm\n \t  _M_fill_assign(static_cast<size_type>(__n),\n \t\t\t static_cast<value_type>(__val));\n \t}\n-  \n+\n       // Called by the range assign to implement [23.1.1]/9\n       template<typename _InputIterator>\n         void\n-        _M_assign_dispatch(_InputIterator __first, _InputIterator __last, \n+        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,\n \t\t\t   __false_type);\n-  \n+\n       // Called by assign(n,t), and the range assign when it turns out\n       // to be the same thing.\n       void\n       _M_fill_assign(size_type __n, const value_type& __val);\n-      \n-      \n+\n+\n       // Internal insert functions follow.\n-      \n+\n       // Called by the range insert to implement [23.1.1]/9\n       template<typename _Integer>\n         void\n@@ -1120,7 +1120,7 @@ namespace __gnu_norm\n \t  _M_fill_insert(__pos, static_cast<size_type>(__n),\n \t\t\t static_cast<value_type>(__x));\n \t}\n-      \n+\n       // Called by the range insert to implement [23.1.1]/9\n       template<typename _InputIterator>\n         void\n@@ -1131,7 +1131,7 @@ namespace __gnu_norm\n \t  for ( ; __first != __last; ++__first)\n \t    _M_insert(__pos, *__first);\n \t}\n-      \n+\n       // Called by insert(p,n,x), and the range insert when it turns out\n       // to be the same thing.\n       void\n@@ -1140,8 +1140,8 @@ namespace __gnu_norm\n \tfor ( ; __n > 0; --__n)\n \t  _M_insert(__pos, __x);\n       }\n-      \n-      \n+\n+\n       // Moves the elements from [first,last) before position.\n       void\n       _M_transfer(iterator __position, iterator __first, iterator __last)\n@@ -1165,7 +1165,7 @@ namespace __gnu_norm\n         _M_put_node(__n);\n       }\n     };\n-  \n+\n   /**\n    *  @brief  List equality comparison.\n    *  @param  x  A %list.\n@@ -1183,17 +1183,17 @@ namespace __gnu_norm\n       typedef typename list<_Tp,_Alloc>::const_iterator const_iterator;\n       const_iterator __end1 = __x.end();\n       const_iterator __end2 = __y.end();\n-  \n+\n       const_iterator __i1 = __x.begin();\n       const_iterator __i2 = __y.begin();\n-      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2) \n+      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2)\n \t{\n \t  ++__i1;\n \t  ++__i2;\n \t}\n       return __i1 == __end1 && __i2 == __end2;\n     }\n-  \n+\n   /**\n    *  @brief  List ordering relation.\n    *  @param  x  A %list.\n@@ -1210,31 +1210,31 @@ namespace __gnu_norm\n     operator<(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n     { return std::lexicographical_compare(__x.begin(), __x.end(),\n \t\t\t\t\t  __y.begin(), __y.end()); }\n-  \n+\n   /// Based on operator==\n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator!=(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n     { return !(__x == __y); }\n-  \n+\n   /// Based on operator<\n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator>(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n     { return __y < __x; }\n-  \n+\n   /// Based on operator<\n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator<=(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n     { return !(__y < __x); }\n-  \n+\n   /// Based on operator<\n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator>=(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n     { return !(__x < __y); }\n-  \n+\n   /// See std::list::swap().\n   template<typename _Tp, typename _Alloc>\n     inline void"}, {"sha": "3a563f174be45198b17c44f2789c02937f1279ff", "filename": "libstdc++-v3/include/bits/stl_map.h", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -94,35 +94,35 @@ namespace __gnu_norm\n       __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n       __glibcxx_class_requires4(_Compare, bool, _Key, _Key,\n \t\t\t\t_BinaryFunctionConcept)\n-  \n+\n     public:\n       typedef _Key                                          key_type;\n       typedef _Tp                                           mapped_type;\n       typedef pair<const _Key, _Tp>                         value_type;\n       typedef _Compare                                      key_compare;\n-  \n+\n       class value_compare\n       : public binary_function<value_type, value_type, bool>\n       {\n \tfriend class map<_Key,_Tp,_Compare,_Alloc>;\n       protected:\n \t_Compare comp;\n-\t\n+\n \tvalue_compare(_Compare __c)\n \t: comp(__c) { }\n-\t\n+\n       public:\n \tbool operator()(const value_type& __x, const value_type& __y) const\n \t{ return comp(__x.first, __y.first); }\n       };\n-  \n+\n     private:\n       /// @if maint  This turns a red-black tree into a [multi]map.  @endif\n       typedef _Rb_tree<key_type, value_type,\n \t\t       _Select1st<value_type>, key_compare, _Alloc> _Rep_type;\n       /// @if maint  The actual tree structure.  @endif\n       _Rep_type _M_t;\n-      \n+\n     public:\n       // many of these are specified differently in ISO, but the following are\n       // \"functionally equivalent\"\n@@ -137,7 +137,7 @@ namespace __gnu_norm\n       typedef typename _Rep_type::const_pointer            const_pointer;\n       typedef typename _Rep_type::reverse_iterator         reverse_iterator;\n       typedef typename _Rep_type::const_reverse_iterator   const_reverse_iterator;\n-      \n+\n       // [23.3.1.1] construct/copy/destroy\n       // (get_allocator() is normally listed in this section, but seems to have\n       // been accidentally omitted in the printed standard)\n@@ -146,15 +146,15 @@ namespace __gnu_norm\n        */\n       map()\n       : _M_t(_Compare(), allocator_type()) { }\n-      \n+\n       // for some reason this was made a separate function\n       /**\n        *  @brief  Default constructor creates no elements.\n        */\n       explicit\n       map(const _Compare& __comp, const allocator_type& __a = allocator_type())\n       : _M_t(__comp, __a) { }\n-  \n+\n       /**\n        *  @brief  Map copy constructor.\n        *  @param  x  A %map of identical element and allocator types.\n@@ -164,7 +164,7 @@ namespace __gnu_norm\n        */\n       map(const map& __x)\n       : _M_t(__x._M_t) { }\n-  \n+\n       /**\n        *  @brief  Builds a %map from a range.\n        *  @param  first  An input iterator.\n@@ -178,7 +178,7 @@ namespace __gnu_norm\n         map(_InputIterator __first, _InputIterator __last)\n \t: _M_t(_Compare(), allocator_type())\n         { _M_t.insert_unique(__first, __last); }\n-  \n+\n       /**\n        *  @brief  Builds a %map from a range.\n        *  @param  first  An input iterator.\n@@ -195,7 +195,7 @@ namespace __gnu_norm\n \t    const _Compare& __comp, const allocator_type& __a = allocator_type())\n \t: _M_t(__comp, __a)\n         { _M_t.insert_unique(__first, __last); }\n-  \n+\n       // FIXME There is no dtor declared, but we should have something generated\n       // by Doxygen.  I don't know what tags to add to this paragraph to make\n       // that happen:\n@@ -204,7 +204,7 @@ namespace __gnu_norm\n        *  themselves are pointers, the pointed-to memory is not touched in any\n        *  way.  Managing the pointer is the user's responsibilty.\n        */\n-      \n+\n       /**\n        *  @brief  Map assignment operator.\n        *  @param  x  A %map of identical element and allocator types.\n@@ -218,22 +218,22 @@ namespace __gnu_norm\n \t_M_t = __x._M_t;\n \treturn *this;\n       }\n-      \n+\n       /// Get a copy of the memory allocation object.\n       allocator_type\n       get_allocator() const\n       { return _M_t.get_allocator(); }\n-      \n+\n       // iterators\n       /**\n-       *  Returns a read/write iterator that points to the first pair in the \n+       *  Returns a read/write iterator that points to the first pair in the\n        *  %map.\n        *  Iteration is done in ascending order according to the keys.\n        */\n       iterator\n       begin()\n       { return _M_t.begin(); }\n-      \n+\n       /**\n        *  Returns a read-only (constant) iterator that points to the first pair\n        *  in the %map.  Iteration is done in ascending order according to the\n@@ -242,15 +242,15 @@ namespace __gnu_norm\n       const_iterator\n       begin() const\n       { return _M_t.begin(); }\n-  \n+\n       /**\n        *  Returns a read/write iterator that points one past the last pair in\n        *  the %map.  Iteration is done in ascending order according to the keys.\n        */\n       iterator\n       end()\n       { return _M_t.end(); }\n-  \n+\n       /**\n        *  Returns a read-only (constant) iterator that points one past the last\n        *  pair in the %map.  Iteration is done in ascending order according to\n@@ -259,7 +259,7 @@ namespace __gnu_norm\n       const_iterator\n       end() const\n       { return _M_t.end(); }\n-      \n+\n       /**\n        *  Returns a read/write reverse iterator that points to the last pair in\n        *  the %map.  Iteration is done in descending order according to the\n@@ -268,7 +268,7 @@ namespace __gnu_norm\n       reverse_iterator\n       rbegin()\n       { return _M_t.rbegin(); }\n-      \n+\n       /**\n        *  Returns a read-only (constant) reverse iterator that points to the\n        *  last pair in the %map.  Iteration is done in descending order\n@@ -277,7 +277,7 @@ namespace __gnu_norm\n       const_reverse_iterator\n       rbegin() const\n       { return _M_t.rbegin(); }\n-      \n+\n       /**\n        *  Returns a read/write reverse iterator that points to one before the\n        *  first pair in the %map.  Iteration is done in descending order\n@@ -286,7 +286,7 @@ namespace __gnu_norm\n       reverse_iterator\n       rend()\n       { return _M_t.rend(); }\n-      \n+\n       /**\n        *  Returns a read-only (constant) reverse iterator that points to one\n        *  before the first pair in the %map.  Iteration is done in descending\n@@ -295,25 +295,25 @@ namespace __gnu_norm\n       const_reverse_iterator\n       rend() const\n       { return _M_t.rend(); }\n-      \n+\n       // capacity\n       /** Returns true if the %map is empty.  (Thus begin() would equal\n        *  end().)\n       */\n       bool\n       empty() const\n       { return _M_t.empty(); }\n-      \n+\n       /** Returns the size of the %map.  */\n       size_type\n       size() const\n       { return _M_t.size(); }\n-      \n+\n       /** Returns the maximum size of the %map.  */\n       size_type\n       max_size() const\n       { return _M_t.max_size(); }\n-      \n+\n       // [23.3.1.2] element access\n       /**\n        *  @brief  Subscript ( @c [] ) access to %map data.\n@@ -332,14 +332,14 @@ namespace __gnu_norm\n       {\n \t// concept requirements\n \t__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)\n-\t\n+\n \titerator __i = lower_bound(__k);\n \t// __i->first is greater than or equivalent to __k.\n \tif (__i == end() || key_comp()(__k, (*__i).first))\n           __i = insert(__i, value_type(__k, mapped_type()));\n \treturn (*__i).second;\n       }\n-      \n+\n       // modifiers\n       /**\n        *  @brief Attempts to insert a std::pair into the %map.\n@@ -358,7 +358,7 @@ namespace __gnu_norm\n       pair<iterator,bool>\n       insert(const value_type& __x)\n       { return _M_t.insert_unique(__x); }\n-      \n+\n       /**\n        *  @brief Attempts to insert a std::pair into the %map.\n        *  @param  position  An iterator that serves as a hint as to where the\n@@ -382,7 +382,7 @@ namespace __gnu_norm\n       iterator\n       insert(iterator position, const value_type& __x)\n       { return _M_t.insert_unique(position, __x); }\n-  \n+\n       /**\n        *  @brief A template function that attemps to insert a range of elements.\n        *  @param  first  Iterator pointing to the start of the range to be\n@@ -395,7 +395,7 @@ namespace __gnu_norm\n         void\n         insert(_InputIterator __first, _InputIterator __last)\n         { _M_t.insert_unique(__first, __last); }\n-  \n+\n       /**\n        *  @brief Erases an element from a %map.\n        *  @param  position  An iterator pointing to the element to be erased.\n@@ -408,7 +408,7 @@ namespace __gnu_norm\n       void\n       erase(iterator __position)\n       { _M_t.erase(__position); }\n-  \n+\n       /**\n        *  @brief Erases elements according to the provided key.\n        *  @param  x  Key of element to be erased.\n@@ -423,7 +423,7 @@ namespace __gnu_norm\n       size_type\n       erase(const key_type& __x)\n       { return _M_t.erase(__x); }\n-      \n+\n       /**\n        *  @brief Erases a [first,last) range of elements from a %map.\n        *  @param  first  Iterator pointing to the start of the range to be\n@@ -438,7 +438,7 @@ namespace __gnu_norm\n       void\n       erase(iterator __first, iterator __last)\n       { _M_t.erase(__first, __last); }\n-      \n+\n       /**\n        *  @brief  Swaps data with another %map.\n        *  @param  x  A %map of the same element and allocator types.\n@@ -453,7 +453,7 @@ namespace __gnu_norm\n       void\n       swap(map& __x)\n       { _M_t.swap(__x._M_t); }\n-  \n+\n       /**\n        *  Erases all elements in a %map.  Note that this function only erases\n        *  the elements, and that if the elements themselves are pointers, the\n@@ -463,7 +463,7 @@ namespace __gnu_norm\n       void\n       clear()\n       { _M_t.clear(); }\n-  \n+\n       // observers\n       /**\n        *  Returns the key comparison object out of which the %map was\n@@ -472,15 +472,15 @@ namespace __gnu_norm\n       key_compare\n       key_comp() const\n       { return _M_t.key_comp(); }\n-      \n+\n       /**\n        *  Returns a value comparison object, built from the key comparison\n        *  object out of which the %map was constructed.\n        */\n       value_compare\n       value_comp() const\n       { return value_compare(_M_t.key_comp()); }\n-      \n+\n       // [23.3.1.3] map operations\n       /**\n        *  @brief Tries to locate an element in a %map.\n@@ -496,7 +496,7 @@ namespace __gnu_norm\n       iterator\n       find(const key_type& __x)\n       { return _M_t.find(__x); }\n-  \n+\n       /**\n        *  @brief Tries to locate an element in a %map.\n        *  @param  x  Key of (key, value) %pair to be located.\n@@ -511,7 +511,7 @@ namespace __gnu_norm\n       const_iterator\n       find(const key_type& __x) const\n       { return _M_t.find(__x); }\n-      \n+\n       /**\n        *  @brief  Finds the number of elements with given key.\n        *  @param  x  Key of (key, value) pairs to be located.\n@@ -523,7 +523,7 @@ namespace __gnu_norm\n       size_type\n       count(const key_type& __x) const\n       { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }\n-  \n+\n       /**\n        *  @brief Finds the beginning of a subsequence matching given key.\n        *  @param  x  Key of (key, value) pair to be located.\n@@ -538,7 +538,7 @@ namespace __gnu_norm\n       iterator\n       lower_bound(const key_type& __x)\n       { return _M_t.lower_bound(__x); }\n-      \n+\n       /**\n        *  @brief Finds the beginning of a subsequence matching given key.\n        *  @param  x  Key of (key, value) pair to be located.\n@@ -553,7 +553,7 @@ namespace __gnu_norm\n       const_iterator\n       lower_bound(const key_type& __x) const\n       { return _M_t.lower_bound(__x); }\n-      \n+\n       /**\n        *  @brief Finds the end of a subsequence matching given key.\n        *  @param  x  Key of (key, value) pair to be located.\n@@ -563,7 +563,7 @@ namespace __gnu_norm\n       iterator\n       upper_bound(const key_type& __x)\n       { return _M_t.upper_bound(__x); }\n-      \n+\n       /**\n        *  @brief Finds the end of a subsequence matching given key.\n        *  @param  x  Key of (key, value) pair to be located.\n@@ -573,7 +573,7 @@ namespace __gnu_norm\n       const_iterator\n       upper_bound(const key_type& __x) const\n       { return _M_t.upper_bound(__x); }\n-      \n+\n       /**\n        *  @brief Finds a subsequence matching given key.\n        *  @param  x  Key of (key, value) pairs to be located.\n@@ -592,7 +592,7 @@ namespace __gnu_norm\n       pair<iterator,iterator>\n       equal_range(const key_type& __x)\n       { return _M_t.equal_range(__x); }\n-  \n+\n       /**\n        *  @brief Finds a subsequence matching given key.\n        *  @param  x  Key of (key, value) pairs to be located.\n@@ -611,7 +611,7 @@ namespace __gnu_norm\n       pair<const_iterator,const_iterator>\n       equal_range(const key_type& __x) const\n       { return _M_t.equal_range(__x); }\n-      \n+\n       template <typename _K1, typename _T1, typename _C1, typename _A1>\n         friend bool\n         operator== (const map<_K1,_T1,_C1,_A1>&,\n@@ -622,7 +622,7 @@ namespace __gnu_norm\n         operator< (const map<_K1,_T1,_C1,_A1>&,\n \t\t   const map<_K1,_T1,_C1,_A1>&);\n     };\n-  \n+\n   /**\n    *  @brief  Map equality comparison.\n    *  @param  x  A %map.\n@@ -638,7 +638,7 @@ namespace __gnu_norm\n     operator==(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n                const map<_Key,_Tp,_Compare,_Alloc>& __y)\n     { return __x._M_t == __y._M_t; }\n-  \n+\n   /**\n    *  @brief  Map ordering relation.\n    *  @param  x  A %map.\n@@ -655,35 +655,35 @@ namespace __gnu_norm\n     operator<(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n               const map<_Key,_Tp,_Compare,_Alloc>& __y)\n     { return __x._M_t < __y._M_t; }\n-  \n+\n   /// Based on operator==\n   template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator!=(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n                const map<_Key,_Tp,_Compare,_Alloc>& __y)\n     { return !(__x == __y); }\n-  \n+\n   /// Based on operator<\n   template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator>(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n               const map<_Key,_Tp,_Compare,_Alloc>& __y)\n     { return __y < __x; }\n-  \n+\n   /// Based on operator<\n   template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator<=(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n                const map<_Key,_Tp,_Compare,_Alloc>& __y)\n     { return !(__y < __x); }\n-  \n+\n   /// Based on operator<\n   template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator>=(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n                const map<_Key,_Tp,_Compare,_Alloc>& __y)\n     { return !(__x < __y); }\n-  \n+\n   /// See std::map::swap().\n   template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline void"}, {"sha": "cbc7b07a804c741a93f633938e978ed3bb889624", "filename": "libstdc++-v3/include/bits/stl_multimap.h", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -66,22 +66,22 @@\n namespace __gnu_norm\n {\n   // Forward declaration of operators < and ==, needed for friend declaration.\n-  \n+\n   template <typename _Key, typename _Tp,\n             typename _Compare = less<_Key>,\n             typename _Alloc = allocator<pair<const _Key, _Tp> > >\n     class multimap;\n-  \n+\n   template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator==(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n \t       const multimap<_Key,_Tp,_Compare,_Alloc>& __y);\n-  \n+\n   template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator<(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n \t      const multimap<_Key,_Tp,_Compare,_Alloc>& __y);\n-  \n+\n   /**\n    *  @brief A standard container made up of (key,value) pairs, which can be\n    *  retrieved based on a key, in logarithmic time.\n@@ -110,35 +110,35 @@ namespace __gnu_norm\n       __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n       __glibcxx_class_requires4(_Compare, bool, _Key, _Key,\n \t\t\t\t_BinaryFunctionConcept)\n-\t\n+\n     public:\n       typedef _Key                                          key_type;\n       typedef _Tp                                           mapped_type;\n       typedef pair<const _Key, _Tp>                         value_type;\n       typedef _Compare                                      key_compare;\n-      \n+\n       class value_compare\n       : public binary_function<value_type, value_type, bool>\n       {\n \tfriend class multimap<_Key,_Tp,_Compare,_Alloc>;\n       protected:\n \t_Compare comp;\n-\t\n+\n \tvalue_compare(_Compare __c)\n \t: comp(__c) { }\n-\t\n+\n       public:\n \tbool operator()(const value_type& __x, const value_type& __y) const\n \t{ return comp(__x.first, __y.first); }\n       };\n-      \n+\n     private:\n       /// @if maint  This turns a red-black tree into a [multi]map.  @endif\n       typedef _Rb_tree<key_type, value_type,\n \t\t       _Select1st<value_type>, key_compare, _Alloc> _Rep_type;\n       /// @if maint  The actual tree structure.  @endif\n       _Rep_type _M_t;\n-  \n+\n     public:\n       // many of these are specified differently in ISO, but the following are\n       // \"functionally equivalent\"\n@@ -153,16 +153,16 @@ namespace __gnu_norm\n       typedef typename _Rep_type::const_pointer          const_pointer;\n       typedef typename _Rep_type::reverse_iterator       reverse_iterator;\n       typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;\n-  \n-  \n+\n+\n       // [23.3.2] construct/copy/destroy\n       // (get_allocator() is also listed in this section)\n       /**\n        *  @brief  Default constructor creates no elements.\n        */\n       multimap()\n       : _M_t(_Compare(), allocator_type()) { }\n-  \n+\n       // for some reason this was made a separate function\n       /**\n        *  @brief  Default constructor creates no elements.\n@@ -171,7 +171,7 @@ namespace __gnu_norm\n       multimap(const _Compare& __comp,\n \t       const allocator_type& __a = allocator_type())\n       : _M_t(__comp, __a) { }\n-  \n+\n       /**\n        *  @brief  %Multimap copy constructor.\n        *  @param  x  A %multimap of identical element and allocator types.\n@@ -181,7 +181,7 @@ namespace __gnu_norm\n        */\n       multimap(const multimap& __x)\n       : _M_t(__x._M_t) { }\n-  \n+\n       /**\n        *  @brief  Builds a %multimap from a range.\n        *  @param  first  An input iterator.\n@@ -195,7 +195,7 @@ namespace __gnu_norm\n         multimap(_InputIterator __first, _InputIterator __last)\n \t: _M_t(_Compare(), allocator_type())\n         { _M_t.insert_equal(__first, __last); }\n-  \n+\n       /**\n        *  @brief  Builds a %multimap from a range.\n        *  @param  first  An input iterator.\n@@ -213,7 +213,7 @@ namespace __gnu_norm\n \t\t const allocator_type& __a = allocator_type())\n         : _M_t(__comp, __a)\n         { _M_t.insert_equal(__first, __last); }\n-  \n+\n       // FIXME There is no dtor declared, but we should have something generated\n       // by Doxygen.  I don't know what tags to add to this paragraph to make\n       // that happen:\n@@ -222,7 +222,7 @@ namespace __gnu_norm\n        *  themselves are pointers, the pointed-to memory is not touched in any\n        *  way.  Managing the pointer is the user's responsibilty.\n        */\n-  \n+\n       /**\n        *  @brief  %Multimap assignment operator.\n        *  @param  x  A %multimap of identical element and allocator types.\n@@ -236,12 +236,12 @@ namespace __gnu_norm\n \t_M_t = __x._M_t;\n \treturn *this;\n       }\n-      \n+\n       /// Get a copy of the memory allocation object.\n       allocator_type\n       get_allocator() const\n       { return _M_t.get_allocator(); }\n-      \n+\n       // iterators\n       /**\n        *  Returns a read/write iterator that points to the first pair in the\n@@ -251,7 +251,7 @@ namespace __gnu_norm\n       iterator\n       begin()\n       { return _M_t.begin(); }\n-  \n+\n       /**\n        *  Returns a read-only (constant) iterator that points to the first pair\n        *  in the %multimap.  Iteration is done in ascending order according to\n@@ -260,7 +260,7 @@ namespace __gnu_norm\n       const_iterator\n       begin() const\n       { return _M_t.begin(); }\n-      \n+\n       /**\n        *  Returns a read/write iterator that points one past the last pair in\n        *  the %multimap.  Iteration is done in ascending order according to the\n@@ -269,7 +269,7 @@ namespace __gnu_norm\n       iterator\n       end()\n       { return _M_t.end(); }\n-      \n+\n       /**\n        *  Returns a read-only (constant) iterator that points one past the last\n        *  pair in the %multimap.  Iteration is done in ascending order according\n@@ -278,7 +278,7 @@ namespace __gnu_norm\n       const_iterator\n       end() const\n       { return _M_t.end(); }\n-      \n+\n       /**\n        *  Returns a read/write reverse iterator that points to the last pair in\n        *  the %multimap.  Iteration is done in descending order according to the\n@@ -287,7 +287,7 @@ namespace __gnu_norm\n       reverse_iterator\n       rbegin()\n       { return _M_t.rbegin(); }\n-      \n+\n       /**\n        *  Returns a read-only (constant) reverse iterator that points to the\n        *  last pair in the %multimap.  Iteration is done in descending order\n@@ -296,7 +296,7 @@ namespace __gnu_norm\n       const_reverse_iterator\n       rbegin() const\n       { return _M_t.rbegin(); }\n-      \n+\n       /**\n        *  Returns a read/write reverse iterator that points to one before the\n        *  first pair in the %multimap.  Iteration is done in descending order\n@@ -305,7 +305,7 @@ namespace __gnu_norm\n       reverse_iterator\n       rend()\n       { return _M_t.rend(); }\n-      \n+\n       /**\n        *  Returns a read-only (constant) reverse iterator that points to one\n        *  before the first pair in the %multimap.  Iteration is done in\n@@ -314,31 +314,31 @@ namespace __gnu_norm\n       const_reverse_iterator\n       rend() const\n       { return _M_t.rend(); }\n-      \n+\n       // capacity\n       /** Returns true if the %multimap is empty.  */\n       bool\n       empty() const\n       { return _M_t.empty(); }\n-      \n+\n       /** Returns the size of the %multimap.  */\n       size_type\n       size() const\n       { return _M_t.size(); }\n-      \n+\n       /** Returns the maximum size of the %multimap.  */\n       size_type\n       max_size() const\n       { return _M_t.max_size(); }\n-      \n+\n       // modifiers\n       /**\n        *  @brief Inserts a std::pair into the %multimap.\n        *  @param  x  Pair to be inserted (see std::make_pair for easy creation\n        *             of pairs).\n        *  @return An iterator that points to the inserted (key,value) pair.\n        *\n-       *  This function inserts a (key, value) pair into the %multimap. \n+       *  This function inserts a (key, value) pair into the %multimap.\n        *  Contrary to a std::map the %multimap does not rely on unique keys and\n        *  thus multiple pairs with the same key can be inserted.\n        *\n@@ -347,7 +347,7 @@ namespace __gnu_norm\n       iterator\n       insert(const value_type& __x)\n       { return _M_t.insert_equal(__x); }\n-  \n+\n       /**\n        *  @brief Inserts a std::pair into the %multimap.\n        *  @param  position  An iterator that serves as a hint as to where the\n@@ -356,7 +356,7 @@ namespace __gnu_norm\n        *             of pairs).\n        *  @return An iterator that points to the inserted (key,value) pair.\n        *\n-       *  This function inserts a (key, value) pair into the %multimap. \n+       *  This function inserts a (key, value) pair into the %multimap.\n        *  Contrary to a std::map the %multimap does not rely on unique keys and\n        *  thus multiple pairs with the same key can be inserted.\n        *  Note that the first parameter is only a hint and can potentially\n@@ -371,7 +371,7 @@ namespace __gnu_norm\n       iterator\n       insert(iterator __position, const value_type& __x)\n       { return _M_t.insert_equal(__position, __x); }\n-      \n+\n       /**\n        *  @brief A template function that attemps to insert a range of elements.\n        *  @param  first  Iterator pointing to the start of the range to be\n@@ -384,7 +384,7 @@ namespace __gnu_norm\n         void\n         insert(_InputIterator __first, _InputIterator __last)\n         { _M_t.insert_equal(__first, __last); }\n-  \n+\n       /**\n        *  @brief Erases an element from a %multimap.\n        *  @param  position  An iterator pointing to the element to be erased.\n@@ -398,7 +398,7 @@ namespace __gnu_norm\n       void\n       erase(iterator __position)\n       { _M_t.erase(__position); }\n-      \n+\n       /**\n        *  @brief Erases elements according to the provided key.\n        *  @param  x  Key of element to be erased.\n@@ -413,7 +413,7 @@ namespace __gnu_norm\n       size_type\n       erase(const key_type& __x)\n       { return _M_t.erase(__x); }\n-  \n+\n       /**\n        *  @brief Erases a [first,last) range of elements from a %multimap.\n        *  @param  first  Iterator pointing to the start of the range to be\n@@ -428,7 +428,7 @@ namespace __gnu_norm\n       void\n       erase(iterator __first, iterator __last)\n       { _M_t.erase(__first, __last); }\n-      \n+\n       /**\n        *  @brief  Swaps data with another %multimap.\n        *  @param  x  A %multimap of the same element and allocator types.\n@@ -443,7 +443,7 @@ namespace __gnu_norm\n       void\n       swap(multimap& __x)\n       { _M_t.swap(__x._M_t); }\n-      \n+\n       /**\n        *  Erases all elements in a %multimap.  Note that this function only\n        *  erases the elements, and that if the elements themselves are pointers,\n@@ -453,7 +453,7 @@ namespace __gnu_norm\n       void\n       clear()\n       { _M_t.clear(); }\n-      \n+\n       // observers\n       /**\n        *  Returns the key comparison object out of which the %multimap\n@@ -462,15 +462,15 @@ namespace __gnu_norm\n       key_compare\n       key_comp() const\n       { return _M_t.key_comp(); }\n-      \n+\n       /**\n        *  Returns a value comparison object, built from the key comparison\n        *  object out of which the %multimap was constructed.\n        */\n       value_compare\n       value_comp() const\n       { return value_compare(_M_t.key_comp()); }\n-      \n+\n       // multimap operations\n       /**\n        *  @brief Tries to locate an element in a %multimap.\n@@ -486,7 +486,7 @@ namespace __gnu_norm\n       iterator\n       find(const key_type& __x)\n       { return _M_t.find(__x); }\n-      \n+\n       /**\n        *  @brief Tries to locate an element in a %multimap.\n        *  @param  x  Key of (key, value) pair to be located.\n@@ -501,7 +501,7 @@ namespace __gnu_norm\n       const_iterator\n       find(const key_type& __x) const\n       { return _M_t.find(__x); }\n-      \n+\n       /**\n        *  @brief Finds the number of elements with given key.\n        *  @param  x  Key of (key, value) pairs to be located.\n@@ -510,7 +510,7 @@ namespace __gnu_norm\n       size_type\n       count(const key_type& __x) const\n       { return _M_t.count(__x); }\n-      \n+\n       /**\n        *  @brief Finds the beginning of a subsequence matching given key.\n        *  @param  x  Key of (key, value) pair to be located.\n@@ -525,7 +525,7 @@ namespace __gnu_norm\n       iterator\n       lower_bound(const key_type& __x)\n       { return _M_t.lower_bound(__x); }\n-  \n+\n       /**\n        *  @brief Finds the beginning of a subsequence matching given key.\n        *  @param  x  Key of (key, value) pair to be located.\n@@ -540,7 +540,7 @@ namespace __gnu_norm\n       const_iterator\n       lower_bound(const key_type& __x) const\n       { return _M_t.lower_bound(__x); }\n-      \n+\n       /**\n        *  @brief Finds the end of a subsequence matching given key.\n        *  @param  x  Key of (key, value) pair to be located.\n@@ -550,7 +550,7 @@ namespace __gnu_norm\n       iterator\n       upper_bound(const key_type& __x)\n       { return _M_t.upper_bound(__x); }\n-      \n+\n       /**\n        *  @brief Finds the end of a subsequence matching given key.\n        *  @param  x  Key of (key, value) pair to be located.\n@@ -560,7 +560,7 @@ namespace __gnu_norm\n       const_iterator\n       upper_bound(const key_type& __x) const\n       { return _M_t.upper_bound(__x); }\n-  \n+\n       /**\n        *  @brief Finds a subsequence matching given key.\n        *  @param  x  Key of (key, value) pairs to be located.\n@@ -577,7 +577,7 @@ namespace __gnu_norm\n       pair<iterator,iterator>\n       equal_range(const key_type& __x)\n       { return _M_t.equal_range(__x); }\n-  \n+\n       /**\n        *  @brief Finds a subsequence matching given key.\n        *  @param  x  Key of (key, value) pairs to be located.\n@@ -594,18 +594,18 @@ namespace __gnu_norm\n       pair<const_iterator,const_iterator>\n       equal_range(const key_type& __x) const\n       { return _M_t.equal_range(__x); }\n-  \n+\n       template <typename _K1, typename _T1, typename _C1, typename _A1>\n         friend bool\n         operator== (const multimap<_K1,_T1,_C1,_A1>&,\n \t\t    const multimap<_K1,_T1,_C1,_A1>&);\n-      \n+\n       template <typename _K1, typename _T1, typename _C1, typename _A1>\n         friend bool\n         operator< (const multimap<_K1,_T1,_C1,_A1>&,\n \t\t   const multimap<_K1,_T1,_C1,_A1>&);\n   };\n-    \n+\n   /**\n    *  @brief  Multimap equality comparison.\n    *  @param  x  A %multimap.\n@@ -621,7 +621,7 @@ namespace __gnu_norm\n     operator==(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n                const multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n     { return __x._M_t == __y._M_t; }\n-  \n+\n   /**\n    *  @brief  Multimap ordering relation.\n    *  @param  x  A %multimap.\n@@ -638,35 +638,35 @@ namespace __gnu_norm\n     operator<(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n               const multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n     { return __x._M_t < __y._M_t; }\n-  \n+\n   /// Based on operator==\n   template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator!=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n                const multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n     { return !(__x == __y); }\n-  \n+\n   /// Based on operator<\n   template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator>(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n               const multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n     { return __y < __x; }\n-  \n+\n   /// Based on operator<\n   template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator<=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n                const multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n     { return !(__y < __x); }\n-  \n+\n   /// Based on operator<\n   template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator>=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n                const multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n     { return !(__x < __y); }\n-  \n+\n   /// See std::multimap::swap().\n   template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline void"}, {"sha": "c85dbcb754b96c7be519fba292297932b5a2a28f", "filename": "libstdc++-v3/include/bits/stl_multiset.h", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -73,12 +73,12 @@ namespace __gnu_norm\n \n   template <class _Key, class _Compare, class _Alloc>\n     inline bool\n-    operator==(const multiset<_Key,_Compare,_Alloc>& __x, \n+    operator==(const multiset<_Key,_Compare,_Alloc>& __x,\n \t       const multiset<_Key,_Compare,_Alloc>& __y);\n \n   template <class _Key, class _Compare, class _Alloc>\n     inline bool\n-    operator<(const multiset<_Key,_Compare,_Alloc>& __x, \n+    operator<(const multiset<_Key,_Compare,_Alloc>& __x,\n \t      const multiset<_Key,_Compare,_Alloc>& __y);\n \n   /**\n@@ -108,17 +108,17 @@ namespace __gnu_norm\n       __glibcxx_class_requires(_Key, _SGIAssignableConcept)\n       __glibcxx_class_requires4(_Compare, bool, _Key, _Key,\n \t\t\t\t_BinaryFunctionConcept)\n-\t\n+\n     public:\n       // typedefs:\n       typedef _Key     key_type;\n       typedef _Key     value_type;\n       typedef _Compare key_compare;\n       typedef _Compare value_compare;\n-      \n+\n     private:\n       /// @if maint  This turns a red-black tree into a [multi]set.  @endif\n-      typedef _Rb_tree<key_type, value_type, \n+      typedef _Rb_tree<key_type, value_type,\n \t\t       _Identity<value_type>, key_compare, _Alloc> _Rep_type;\n       /// @if maint  The actual tree structure.  @endif\n       _Rep_type _M_t;\n@@ -137,7 +137,7 @@ namespace __gnu_norm\n       typedef typename _Rep_type::allocator_type allocator_type;\n \n     // allocation/deallocation\n-      \n+\n     /**\n      *  @brief  Default constructor creates no elements.\n      */\n@@ -201,12 +201,12 @@ namespace __gnu_norm\n       multiset<_Key,_Compare,_Alloc>&\n       operator=(const multiset<_Key,_Compare,_Alloc>& __x)\n       {\n-\t_M_t = __x._M_t; \n+\t_M_t = __x._M_t;\n \treturn *this;\n       }\n-      \n+\n       // accessors:\n-      \n+\n       ///  Returns the comparison object.\n       key_compare\n       key_comp() const\n@@ -219,7 +219,7 @@ namespace __gnu_norm\n       allocator_type\n       get_allocator() const\n       { return _M_t.get_allocator(); }\n-      \n+\n       /**\n        *  Returns a read/write iterator that points to the first element in the\n        *  %multiset.  Iteration is done in ascending order according to the\n@@ -237,16 +237,16 @@ namespace __gnu_norm\n       iterator\n       end() const\n       { return _M_t.end(); }\n-      \n+\n       /**\n        *  Returns a read/write reverse iterator that points to the last element\n        *  in the %multiset.  Iteration is done in descending order according to\n        *  the keys.\n        */\n       reverse_iterator\n       rbegin() const\n-      { return _M_t.rbegin(); } \n-      \n+      { return _M_t.rbegin(); }\n+\n       /**\n        *  Returns a read/write reverse iterator that points to the last element\n        *  in the %multiset.  Iteration is done in descending order according to\n@@ -255,22 +255,22 @@ namespace __gnu_norm\n       reverse_iterator\n       rend() const\n       { return _M_t.rend(); }\n-      \n+\n       ///  Returns true if the %set is empty.\n       bool\n       empty() const\n       { return _M_t.empty(); }\n-      \n+\n       ///  Returns the size of the %set.\n       size_type\n       size() const\n       { return _M_t.size(); }\n-      \n+\n       ///  Returns the maximum size of the %set.\n       size_type\n       max_size() const\n       { return _M_t.max_size(); }\n-      \n+\n       /**\n        *  @brief  Swaps data with another %multiset.\n        *  @param  x  A %multiset of the same element and allocator types.\n@@ -285,7 +285,7 @@ namespace __gnu_norm\n       void\n       swap(multiset<_Key,_Compare,_Alloc>& __x)\n       { _M_t.swap(__x._M_t); }\n-      \n+\n       // insert/erase\n       /**\n        *  @brief Inserts an element into the %multiset.\n@@ -301,7 +301,7 @@ namespace __gnu_norm\n       iterator\n       insert(const value_type& __x)\n       { return _M_t.insert_equal(__x); }\n-      \n+\n       /**\n        *  @brief Inserts an element into the %multiset.\n        *  @param  position  An iterator that serves as a hint as to where the\n@@ -354,11 +354,11 @@ namespace __gnu_norm\n        */\n       void\n       erase(iterator __position)\n-      { \n+      {\n \ttypedef typename _Rep_type::iterator _Rep_iterator;\n-\t_M_t.erase((_Rep_iterator&)__position); \n+\t_M_t.erase((_Rep_iterator&)__position);\n       }\n-      \n+\n       /**\n        *  @brief Erases elements according to the provided key.\n        *  @param  x  Key of element to be erased.\n@@ -373,7 +373,7 @@ namespace __gnu_norm\n       size_type\n       erase(const key_type& __x)\n       { return _M_t.erase(__x); }\n-      \n+\n       /**\n        *  @brief Erases a [first,last) range of elements from a %multiset.\n        *  @param  first  Iterator pointing to the start of the range to be\n@@ -387,11 +387,11 @@ namespace __gnu_norm\n        */\n       void\n       erase(iterator __first, iterator __last)\n-      { \n+      {\n \ttypedef typename _Rep_type::iterator _Rep_iterator;\n-\t_M_t.erase((_Rep_iterator&)__first, (_Rep_iterator&)__last); \n+\t_M_t.erase((_Rep_iterator&)__first, (_Rep_iterator&)__last);\n       }\n-      \n+\n       /**\n        *  Erases all elements in a %multiset.  Note that this function only\n        *  erases the elements, and that if the elements themselves are pointers,\n@@ -401,9 +401,9 @@ namespace __gnu_norm\n       void\n       clear()\n       { _M_t.clear(); }\n-      \n+\n       // multiset operations:\n-      \n+\n       /**\n        *  @brief Finds the number of elements with given key.\n        *  @param  x  Key of elements to be located.\n@@ -412,7 +412,7 @@ namespace __gnu_norm\n       size_type\n       count(const key_type& __x) const\n       { return _M_t.count(__x); }\n-      \n+\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 214.  set::find() missing const overload\n       //@{\n@@ -430,12 +430,12 @@ namespace __gnu_norm\n       iterator\n       find(const key_type& __x)\n       { return _M_t.find(__x); }\n-      \n+\n       const_iterator\n       find(const key_type& __x) const\n       { return _M_t.find(__x); }\n       //@}\n-      \n+\n       //@{\n       /**\n        *  @brief Finds the beginning of a subsequence matching given key.\n@@ -451,12 +451,12 @@ namespace __gnu_norm\n       iterator\n       lower_bound(const key_type& __x)\n       { return _M_t.lower_bound(__x); }\n-      \n+\n       const_iterator\n       lower_bound(const key_type& __x) const\n       { return _M_t.lower_bound(__x); }\n       //@}\n-      \n+\n       //@{\n       /**\n        *  @brief Finds the end of a subsequence matching given key.\n@@ -467,12 +467,12 @@ namespace __gnu_norm\n       iterator\n       upper_bound(const key_type& __x)\n       { return _M_t.upper_bound(__x); }\n-      \n+\n       const_iterator\n       upper_bound(const key_type& __x) const\n       { return _M_t.upper_bound(__x); }\n       //@}\n-      \n+\n       //@{\n       /**\n        *  @brief Finds a subsequence matching given key.\n@@ -492,11 +492,11 @@ namespace __gnu_norm\n       pair<iterator,iterator>\n       equal_range(const key_type& __x)\n       { return _M_t.equal_range(__x); }\n-      \n+\n       pair<const_iterator,const_iterator>\n       equal_range(const key_type& __x) const\n       { return _M_t.equal_range(__x); }\n-      \n+\n       template <class _K1, class _C1, class _A1>\n         friend bool\n         operator== (const multiset<_K1,_C1,_A1>&,\n@@ -521,10 +521,10 @@ namespace __gnu_norm\n   */\n   template <class _Key, class _Compare, class _Alloc>\n     inline bool\n-    operator==(const multiset<_Key,_Compare,_Alloc>& __x, \n+    operator==(const multiset<_Key,_Compare,_Alloc>& __x,\n \t       const multiset<_Key,_Compare,_Alloc>& __y)\n     { return __x._M_t == __y._M_t; }\n-  \n+\n   /**\n    *  @brief  Multiset ordering relation.\n    *  @param  x  A %multiset.\n@@ -538,42 +538,42 @@ namespace __gnu_norm\n   */\n   template <class _Key, class _Compare, class _Alloc>\n     inline bool\n-    operator<(const multiset<_Key,_Compare,_Alloc>& __x, \n+    operator<(const multiset<_Key,_Compare,_Alloc>& __x,\n \t      const multiset<_Key,_Compare,_Alloc>& __y)\n     { return __x._M_t < __y._M_t; }\n \n   ///  Returns !(x == y).\n   template <class _Key, class _Compare, class _Alloc>\n     inline bool\n-    operator!=(const multiset<_Key,_Compare,_Alloc>& __x, \n+    operator!=(const multiset<_Key,_Compare,_Alloc>& __x,\n \t       const multiset<_Key,_Compare,_Alloc>& __y)\n     { return !(__x == __y); }\n \n   ///  Returns y < x.\n   template <class _Key, class _Compare, class _Alloc>\n     inline bool\n-    operator>(const multiset<_Key,_Compare,_Alloc>& __x, \n+    operator>(const multiset<_Key,_Compare,_Alloc>& __x,\n \t      const multiset<_Key,_Compare,_Alloc>& __y)\n     { return __y < __x; }\n \n   ///  Returns !(y < x)\n   template <class _Key, class _Compare, class _Alloc>\n     inline bool\n-    operator<=(const multiset<_Key,_Compare,_Alloc>& __x, \n+    operator<=(const multiset<_Key,_Compare,_Alloc>& __x,\n \t       const multiset<_Key,_Compare,_Alloc>& __y)\n     { return !(__y < __x); }\n \n   ///  Returns !(x < y)\n   template <class _Key, class _Compare, class _Alloc>\n     inline bool\n-    operator>=(const multiset<_Key,_Compare,_Alloc>& __x, \n+    operator>=(const multiset<_Key,_Compare,_Alloc>& __x,\n \t       const multiset<_Key,_Compare,_Alloc>& __y)\n     { return !(__x < __y); }\n \n   /// See std::multiset::swap().\n   template <class _Key, class _Compare, class _Alloc>\n     inline void\n-    swap(multiset<_Key,_Compare,_Alloc>& __x, \n+    swap(multiset<_Key,_Compare,_Alloc>& __x,\n \t multiset<_Key,_Compare,_Alloc>& __y)\n     { __x.swap(__y); }\n "}, {"sha": "58762a40a7d236725fed41419511b1287d4bc256", "filename": "libstdc++-v3/include/bits/stl_numeric.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_numeric.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_numeric.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_numeric.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -166,7 +166,7 @@ namespace std\n \t    typename _BinaryOperation1, typename _BinaryOperation2>\n     _Tp\n     inner_product(_InputIterator1 __first1, _InputIterator1 __last1,\n-\t\t  _InputIterator2 __first2, _Tp __init, \n+\t\t  _InputIterator2 __first2, _Tp __init,\n \t\t  _BinaryOperation1 __binary_op1,\n \t\t  _BinaryOperation2 __binary_op2)\n     {\n@@ -195,7 +195,7 @@ namespace std\n    *  @return  Iterator pointing just beyond the values written to result.\n    */\n   template<typename _InputIterator, typename _OutputIterator>\n-    _OutputIterator \n+    _OutputIterator\n     partial_sum(_InputIterator __first, _InputIterator __last,\n \t\t_OutputIterator __result)\n     {\n@@ -231,7 +231,7 @@ namespace std\n    *  @return  Iterator pointing just beyond the values written to result.\n    */\n   template<typename _InputIterator, typename _OutputIterator, typename _BinaryOperation>\n-    _OutputIterator \n+    _OutputIterator\n     partial_sum(_InputIterator __first, _InputIterator __last,\n \t\t_OutputIterator __result, _BinaryOperation __binary_op)\n     {\n@@ -299,7 +299,7 @@ namespace std\n    *  @return  Iterator pointing just beyond the values written to result.\n    */\n   template<typename _InputIterator, typename _OutputIterator, typename _BinaryOperation>\n-    _OutputIterator \n+    _OutputIterator\n     adjacent_difference(_InputIterator __first, _InputIterator __last,\n \t\t\t_OutputIterator __result, _BinaryOperation __binary_op)\n     {"}, {"sha": "0bbaa24ad6ee7814e5a6942d26dbd470cb4fd963", "filename": "libstdc++-v3/include/bits/stl_pair.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -145,7 +145,7 @@ namespace std\n   inline pair<_T1, _T2>\n   make_pair(_T1 __x, _T2 __y)\n   { return pair<_T1, _T2>(__x, __y); }\n-  \n+\n } // namespace std\n \n #endif /* _PAIR_H */"}, {"sha": "3583547dbb4db2a668d06ac64f8a225a8bbcbcbf", "filename": "libstdc++-v3/include/bits/stl_queue.h", "status": "modified", "additions": 74, "deletions": 74, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_queue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_queue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_queue.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -69,15 +69,15 @@ namespace std\n   // Forward declarations of operators < and ==, needed for friend declaration.\n   template<typename _Tp, typename _Sequence = deque<_Tp> >\n     class queue;\n-  \n+\n   template<typename _Tp, typename _Seq>\n-    inline bool \n+    inline bool\n     operator==(const queue<_Tp,_Seq>&, const queue<_Tp,_Seq>&);\n-  \n+\n   template<typename _Tp, typename _Seq>\n-    inline bool \n+    inline bool\n     operator<(const queue<_Tp,_Seq>&, const queue<_Tp,_Seq>&);\n-  \n+\n   /**\n    *  @brief  A standard container giving FIFO behavior.\n    *\n@@ -111,22 +111,22 @@ namespace std\n       __glibcxx_class_requires(_Sequence, _FrontInsertionSequenceConcept)\n       __glibcxx_class_requires(_Sequence, _BackInsertionSequenceConcept)\n       __glibcxx_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept)\n-  \n+\n       template<typename _Tp1, typename _Seq1>\n-        friend bool \n+        friend bool\n         operator==(const queue<_Tp1, _Seq1>&, const queue<_Tp1, _Seq1>&);\n \n       template<typename _Tp1, typename _Seq1>\n-        friend bool \n+        friend bool\n         operator<(const queue<_Tp1, _Seq1>&, const queue<_Tp1, _Seq1>&);\n-  \n+\n     public:\n       typedef typename _Sequence::value_type                value_type;\n       typedef typename _Sequence::reference                 reference;\n       typedef typename _Sequence::const_reference           const_reference;\n       typedef typename _Sequence::size_type                 size_type;\n       typedef          _Sequence                            container_type;\n-      \n+\n     protected:\n       /**\n        *  'c' is the underlying container.  Maintainers wondering why\n@@ -137,70 +137,70 @@ namespace std\n        *  containers allow for derivation.  Odd.)\n        */\n       _Sequence c;\n-      \n+\n     public:\n       /**\n        *  @brief  Default constructor creates no elements.\n        */\n       explicit\n       queue(const _Sequence& __c = _Sequence()) : c(__c) {}\n-      \n+\n       /**\n        *  Returns true if the %queue is empty.\n        */\n       bool\n       empty() const\n       { return c.empty(); }\n-      \n+\n       /**  Returns the number of elements in the %queue.  */\n       size_type\n       size() const\n       { return c.size(); }\n-      \n+\n       /**\n        *  Returns a read/write reference to the data at the first\n        *  element of the %queue.\n        */\n       reference\n-      front() \n-      { \n+      front()\n+      {\n \t__glibcxx_requires_nonempty();\n-\treturn c.front(); \n+\treturn c.front();\n       }\n-      \n+\n       /**\n        *  Returns a read-only (constant) reference to the data at the first\n        *  element of the %queue.\n        */\n       const_reference\n-      front() const \n-      { \n+      front() const\n+      {\n \t__glibcxx_requires_nonempty();\n-\treturn c.front(); \n+\treturn c.front();\n       }\n-      \n+\n       /**\n        *  Returns a read/write reference to the data at the last\n        *  element of the %queue.\n        */\n       reference\n-      back() \n+      back()\n       {\n \t__glibcxx_requires_nonempty();\n-\treturn c.back(); \n+\treturn c.back();\n       }\n-      \n+\n       /**\n        *  Returns a read-only (constant) reference to the data at the last\n        *  element of the %queue.\n        */\n       const_reference\n-      back() const \n+      back() const\n       {\n \t__glibcxx_requires_nonempty();\n-\treturn c.back(); \n+\treturn c.back();\n       }\n-      \n+\n       /**\n        *  @brief  Add data to the end of the %queue.\n        *  @param  x  Data to be added.\n@@ -213,7 +213,7 @@ namespace std\n       void\n       push(const value_type& __x)\n       { c.push_back(__x); }\n-      \n+\n       /**\n        *  @brief  Removes first element.\n        *\n@@ -226,14 +226,14 @@ namespace std\n        *  called.\n        */\n       void\n-      pop() \n-      { \n+      pop()\n+      {\n \t__glibcxx_requires_nonempty();\n-\tc.pop_front(); \n+\tc.pop_front();\n       }\n     };\n-  \n-  \n+\n+\n   /**\n    *  @brief  Queue equality comparison.\n    *  @param  x  A %queue.\n@@ -246,11 +246,11 @@ namespace std\n    *  if their sequences compare equal.\n   */\n   template<typename _Tp, typename _Sequence>\n-    inline bool \n-    operator==(const queue<_Tp,_Sequence>& __x, \n+    inline bool\n+    operator==(const queue<_Tp,_Sequence>& __x,\n \t       const queue<_Tp,_Sequence>& __y)\n     { return __x.c == __y.c; }\n-  \n+\n   /**\n    *  @brief  Queue ordering relation.\n    *  @param  x  A %queue.\n@@ -268,34 +268,34 @@ namespace std\n     inline bool\n     operator<(const queue<_Tp,_Sequence>& __x, const queue<_Tp,_Sequence>& __y)\n     { return __x.c < __y.c; }\n-  \n+\n   /// Based on operator==\n   template<typename _Tp, typename _Sequence>\n     inline bool\n-    operator!=(const queue<_Tp,_Sequence>& __x, \n+    operator!=(const queue<_Tp,_Sequence>& __x,\n \t       const queue<_Tp,_Sequence>& __y)\n     { return !(__x == __y); }\n-  \n+\n   /// Based on operator<\n   template<typename _Tp, typename _Sequence>\n-    inline bool \n+    inline bool\n     operator>(const queue<_Tp,_Sequence>& __x, const queue<_Tp,_Sequence>& __y)\n     { return __y < __x; }\n-  \n+\n   /// Based on operator<\n   template<typename _Tp, typename _Sequence>\n-    inline bool \n-    operator<=(const queue<_Tp,_Sequence>& __x, \n+    inline bool\n+    operator<=(const queue<_Tp,_Sequence>& __x,\n \t       const queue<_Tp,_Sequence>& __y)\n     { return !(__y < __x); }\n-  \n+\n   /// Based on operator<\n   template<typename _Tp, typename _Sequence>\n-    inline bool \n-    operator>=(const queue<_Tp,_Sequence>& __x, \n+    inline bool\n+    operator>=(const queue<_Tp,_Sequence>& __x,\n \t       const queue<_Tp,_Sequence>& __y)\n     { return !(__x < __y); }\n-    \n+\n   /**\n    *  @brief  A standard container automatically sorting its contents.\n    *\n@@ -345,36 +345,36 @@ namespace std\n       __glibcxx_class_requires(_Sequence, _RandomAccessContainerConcept)\n       __glibcxx_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept)\n       __glibcxx_class_requires4(_Compare, bool, _Tp,_Tp,_BinaryFunctionConcept)\n-  \n+\n     public:\n       typedef typename _Sequence::value_type                value_type;\n       typedef typename _Sequence::reference                 reference;\n       typedef typename _Sequence::const_reference           const_reference;\n       typedef typename _Sequence::size_type                 size_type;\n       typedef          _Sequence                            container_type;\n-      \n+\n     protected:\n       //  See queue::c for notes on these names.\n       _Sequence  c;\n       _Compare   comp;\n-      \n+\n     public:\n       /**\n        *  @brief  Default constructor creates no elements.\n        */\n       explicit\n-      priority_queue(const _Compare& __x = _Compare(), \n-\t\t     const _Sequence& __s = _Sequence()) \n-      : c(__s), comp(__x) \n+      priority_queue(const _Compare& __x = _Compare(),\n+\t\t     const _Sequence& __s = _Sequence())\n+      : c(__s), comp(__x)\n       { std::make_heap(c.begin(), c.end(), comp); }\n-  \n+\n       /**\n        *  @brief  Builds a %queue from a range.\n        *  @param  first  An input iterator.\n        *  @param  last  An input iterator.\n        *  @param  x  A comparison functor describing a strict weak ordering.\n        *  @param  s  An initial sequence with which to start.\n-       * \n+       *\n        *  Begins by copying @a s, inserting a copy of the elements\n        *  from @a [first,last) into the copy of @a s, then ordering\n        *  the copy according to @a x.\n@@ -388,33 +388,33 @@ namespace std\n \t\t       const _Compare& __x = _Compare(),\n \t\t       const _Sequence& __s = _Sequence())\n \t: c(__s), comp(__x)\n-        { \n+        {\n \t  __glibcxx_requires_valid_range(__first, __last);\n \t  c.insert(c.end(), __first, __last);\n \t  std::make_heap(c.begin(), c.end(), comp);\n \t}\n-      \n+\n       /**\n        *  Returns true if the %queue is empty.\n        */\n       bool\n       empty() const { return c.empty(); }\n-      \n+\n       /**  Returns the number of elements in the %queue.  */\n       size_type\n       size() const { return c.size(); }\n-      \n+\n       /**\n        *  Returns a read-only (constant) reference to the data at the first\n        *  element of the %queue.\n        */\n       const_reference\n-      top() const \n+      top() const\n       {\n \t__glibcxx_requires_nonempty();\n-\treturn c.front(); \n+\treturn c.front();\n       }\n-      \n+\n       /**\n        *  @brief  Add data to the %queue.\n        *  @param  x  Data to be added.\n@@ -423,21 +423,21 @@ namespace std\n        *  The time complexity of the operation depends on the underlying\n        *  sequence.\n        */\n-      void \n-      push(const value_type& __x) \n+      void\n+      push(const value_type& __x)\n       {\n-\ttry \n+\ttry\n         {\n-          c.push_back(__x); \n+          c.push_back(__x);\n           std::push_heap(c.begin(), c.end(), comp);\n         }\n \tcatch(...)\n         {\n           c.clear();\n-          __throw_exception_again; \n+          __throw_exception_again;\n         }\n       }\n-      \n+\n       /**\n        *  @brief  Removes first element.\n        *\n@@ -449,23 +449,23 @@ namespace std\n        *  data is needed, it should be retrieved before pop() is\n        *  called.\n        */\n-      void \n-      pop() \n+      void\n+      pop()\n       {\n \t__glibcxx_requires_nonempty();\n-\ttry \n+\ttry\n         {\n           std::pop_heap(c.begin(), c.end(), comp);\n           c.pop_back();\n         }\n \tcatch(...)\n         {\n           c.clear();\n-          __throw_exception_again; \n+          __throw_exception_again;\n         }\n       }\n     };\n-  \n+\n   // No equality/comparison operators are provided for priority_queue.\n } // namespace std\n "}, {"sha": "732142e1e6b9da3399ff5e6331fabe45edbd304c", "filename": "libstdc++-v3/include/bits/stl_raw_storage_iter.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_raw_storage_iter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_raw_storage_iter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_raw_storage_iter.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -68,36 +68,36 @@ namespace std\n    *  uninitialized memory.\n   */\n   template <class _ForwardIterator, class _Tp>\n-    class raw_storage_iterator \n+    class raw_storage_iterator\n     : public iterator<output_iterator_tag, void, void, void, void>\n     {\n     protected:\n       _ForwardIterator _M_iter;\n \n     public:\n-      explicit \n+      explicit\n       raw_storage_iterator(_ForwardIterator __x)\n       : _M_iter(__x) {}\n \n-      raw_storage_iterator& \n+      raw_storage_iterator&\n       operator*() { return *this; }\n \n-      raw_storage_iterator& \n-      operator=(const _Tp& __element) \n+      raw_storage_iterator&\n+      operator=(const _Tp& __element)\n       {\n \tstd::_Construct(&*_M_iter, __element);\n \treturn *this;\n-      }        \n+      }\n \n-      raw_storage_iterator<_ForwardIterator, _Tp>& \n-      operator++() \n+      raw_storage_iterator<_ForwardIterator, _Tp>&\n+      operator++()\n       {\n \t++_M_iter;\n \treturn *this;\n       }\n \n-      raw_storage_iterator<_ForwardIterator, _Tp> \n-      operator++(int) \n+      raw_storage_iterator<_ForwardIterator, _Tp>\n+      operator++(int)\n       {\n \traw_storage_iterator<_ForwardIterator, _Tp> __tmp = *this;\n \t++_M_iter;"}, {"sha": "3e9f060f28775ee11396d41c90199ce9f8dfb410", "filename": "libstdc++-v3/include/bits/stl_relops.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_relops.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_relops.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_relops.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -78,7 +78,7 @@ namespace std\n     /** @namespace std::rel_ops\n      *  @brief  The generated relational operators are sequestered here.\n      */\n-    \n+\n     /**\n      *  @brief Defines @c != for arbitrary types, in terms of @c ==.\n      *  @param  x  A thing."}, {"sha": "f5619ba8999120f43da8e04e0d88ba77e1876953", "filename": "libstdc++-v3/include/bits/stl_set.h", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -66,18 +66,18 @@\n namespace __gnu_norm\n {\n   // Forward declarations of operators < and ==, needed for friend declaration.\n-  template<class _Key, class _Compare = less<_Key>, \n+  template<class _Key, class _Compare = less<_Key>,\n \t   class _Alloc = allocator<_Key> >\n     class set;\n \n   template<class _Key, class _Compare, class _Alloc>\n-    inline bool \n-    operator==(const set<_Key,_Compare,_Alloc>& __x, \n+    inline bool\n+    operator==(const set<_Key,_Compare,_Alloc>& __x,\n \t       const set<_Key,_Compare,_Alloc>& __y);\n \n   template<class _Key, class _Compare, class _Alloc>\n-    inline bool \n-    operator<(const set<_Key,_Compare,_Alloc>& __x, \n+    inline bool\n+    operator<(const set<_Key,_Compare,_Alloc>& __x,\n \t      const set<_Key,_Compare,_Alloc>& __y);\n \n   /**\n@@ -110,7 +110,7 @@ namespace __gnu_norm\n       __glibcxx_class_requires(_Key, _SGIAssignableConcept)\n       __glibcxx_class_requires4(_Compare, bool, _Key, _Key,\n \t\t\t\t_BinaryFunctionConcept)\n-\t\n+\n     public:\n       // typedefs:\n       //@{\n@@ -122,7 +122,7 @@ namespace __gnu_norm\n       //@}\n \n     private:\n-      typedef _Rb_tree<key_type, value_type, \n+      typedef _Rb_tree<key_type, value_type,\n \t\t       _Identity<value_type>, key_compare, _Alloc> _Rep_type;\n       _Rep_type _M_t;  // red-black tree representing set\n     public:\n@@ -197,7 +197,7 @@ namespace __gnu_norm\n        */\n       set(const set<_Key,_Compare,_Alloc>& __x)\n       : _M_t(__x._M_t) { }\n-      \n+\n       /**\n        *  @brief  Set assignment operator.\n        *  @param  x  A %set of identical element and allocator types.\n@@ -207,8 +207,8 @@ namespace __gnu_norm\n        */\n       set<_Key,_Compare,_Alloc>&\n       operator=(const set<_Key, _Compare, _Alloc>& __x)\n-      { \n-\t_M_t = __x._M_t; \n+      {\n+\t_M_t = __x._M_t;\n \treturn *this;\n       }\n \n@@ -250,7 +250,7 @@ namespace __gnu_norm\n        */\n       reverse_iterator\n       rbegin() const\n-      { return _M_t.rbegin(); } \n+      { return _M_t.rbegin(); }\n \n       /**\n        *  Returns a read-only (constant) reverse iterator that points to the\n@@ -307,7 +307,7 @@ namespace __gnu_norm\n        */\n       pair<iterator,bool>\n       insert(const value_type& __x)\n-      { \n+      {\n \tpair<typename _Rep_type::iterator, bool> __p = _M_t.insert_unique(__x);\n \treturn pair<iterator, bool>(__p.first, __p.second);\n       }\n@@ -350,7 +350,7 @@ namespace __gnu_norm\n       void\n       insert(_InputIterator __first, _InputIterator __last)\n       { _M_t.insert_unique(__first, __last); }\n-      \n+\n       /**\n        *  @brief Erases an element from a %set.\n        *  @param  position  An iterator pointing to the element to be erased.\n@@ -362,9 +362,9 @@ namespace __gnu_norm\n        */\n       void\n       erase(iterator __position)\n-      { \n+      {\n \ttypedef typename _Rep_type::iterator _Rep_iterator;\n-\t_M_t.erase((_Rep_iterator&)__position); \n+\t_M_t.erase((_Rep_iterator&)__position);\n       }\n \n       /**\n@@ -396,7 +396,7 @@ namespace __gnu_norm\n       erase(iterator __first, iterator __last)\n       {\n \ttypedef typename _Rep_type::iterator _Rep_iterator;\n-\t_M_t.erase((_Rep_iterator&)__first, (_Rep_iterator&)__last); \n+\t_M_t.erase((_Rep_iterator&)__first, (_Rep_iterator&)__last);\n       }\n \n       /**\n@@ -461,7 +461,7 @@ namespace __gnu_norm\n       iterator\n       lower_bound(const key_type& __x)\n       { return _M_t.lower_bound(__x); }\n-      \n+\n       const_iterator\n       lower_bound(const key_type& __x) const\n       { return _M_t.lower_bound(__x); }\n@@ -502,7 +502,7 @@ namespace __gnu_norm\n       pair<iterator,iterator>\n       equal_range(const key_type& __x)\n       { return _M_t.equal_range(__x); }\n-      \n+\n       pair<const_iterator,const_iterator>\n       equal_range(const key_type& __x) const\n       { return _M_t.equal_range(__x); }\n@@ -511,7 +511,7 @@ namespace __gnu_norm\n       template<class _K1, class _C1, class _A1>\n         friend bool\n         operator== (const set<_K1,_C1,_A1>&, const set<_K1,_C1,_A1>&);\n-      \n+\n       template<class _K1, class _C1, class _A1>\n         friend bool\n         operator< (const set<_K1,_C1,_A1>&, const set<_K1,_C1,_A1>&);\n@@ -530,7 +530,7 @@ namespace __gnu_norm\n   */\n   template<class _Key, class _Compare, class _Alloc>\n     inline bool\n-    operator==(const set<_Key,_Compare,_Alloc>& __x, \n+    operator==(const set<_Key,_Compare,_Alloc>& __x,\n \t       const set<_Key,_Compare,_Alloc>& __y)\n     { return __x._M_t == __y._M_t; }\n \n@@ -547,35 +547,35 @@ namespace __gnu_norm\n   */\n   template<class _Key, class _Compare, class _Alloc>\n     inline bool\n-    operator<(const set<_Key,_Compare,_Alloc>& __x, \n+    operator<(const set<_Key,_Compare,_Alloc>& __x,\n \t      const set<_Key,_Compare,_Alloc>& __y)\n     { return __x._M_t < __y._M_t; }\n \n   ///  Returns !(x == y).\n   template<class _Key, class _Compare, class _Alloc>\n     inline bool\n-    operator!=(const set<_Key,_Compare,_Alloc>& __x, \n+    operator!=(const set<_Key,_Compare,_Alloc>& __x,\n \t       const set<_Key,_Compare,_Alloc>& __y)\n     { return !(__x == __y); }\n \n   ///  Returns y < x.\n   template<class _Key, class _Compare, class _Alloc>\n     inline bool\n-    operator>(const set<_Key,_Compare,_Alloc>& __x, \n+    operator>(const set<_Key,_Compare,_Alloc>& __x,\n \t      const set<_Key,_Compare,_Alloc>& __y)\n     { return __y < __x; }\n \n   ///  Returns !(y < x)\n   template<class _Key, class _Compare, class _Alloc>\n     inline bool\n-    operator<=(const set<_Key,_Compare,_Alloc>& __x, \n+    operator<=(const set<_Key,_Compare,_Alloc>& __x,\n \t       const set<_Key,_Compare,_Alloc>& __y)\n     { return !(__y < __x); }\n-  \n+\n   ///  Returns !(x < y)\n   template<class _Key, class _Compare, class _Alloc>\n     inline bool\n-    operator>=(const set<_Key,_Compare,_Alloc>& __x, \n+    operator>=(const set<_Key,_Compare,_Alloc>& __x,\n \t       const set<_Key,_Compare,_Alloc>& __y)\n     { return !(__x < __y); }\n "}, {"sha": "ada50ee350eac189eb5c7cf5051c8975a86438c5", "filename": "libstdc++-v3/include/bits/stl_stack.h", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_stack.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -70,15 +70,15 @@ namespace std\n   // declaration.\n   template<typename _Tp, typename _Sequence = deque<_Tp> >\n     class stack;\n-  \n+\n   template<typename _Tp, typename _Seq>\n-    inline bool \n+    inline bool\n     operator==(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y);\n-  \n+\n   template<typename _Tp, typename _Seq>\n-    inline bool \n+    inline bool\n     operator<(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y);\n-  \n+\n   /**\n    *  @brief  A standard container giving FILO behavior.\n    *\n@@ -114,26 +114,26 @@ namespace std\n       __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n       __glibcxx_class_requires(_Sequence, _BackInsertionSequenceConcept)\n       __glibcxx_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept)\n-  \n+\n       template<typename _Tp1, typename _Seq1>\n-        friend bool \n+        friend bool\n         operator==(const stack<_Tp1, _Seq1>&, const stack<_Tp1, _Seq1>&);\n \n       template<typename _Tp1, typename _Seq1>\n-        friend bool \n+        friend bool\n         operator<(const stack<_Tp1, _Seq1>&, const stack<_Tp1, _Seq1>&);\n-  \n+\n     public:\n       typedef typename _Sequence::value_type                value_type;\n       typedef typename _Sequence::reference                 reference;\n       typedef typename _Sequence::const_reference           const_reference;\n       typedef typename _Sequence::size_type                 size_type;\n       typedef          _Sequence                            container_type;\n-      \n+\n     protected:\n       //  See queue::c for notes on this name.\n       _Sequence c;\n-      \n+\n     public:\n       // XXX removed old def ctor, added def arg to this one to match 14882\n       /**\n@@ -142,41 +142,41 @@ namespace std\n       explicit\n       stack(const _Sequence& __c = _Sequence())\n       : c(__c) {}\n-      \n+\n       /**\n        *  Returns true if the %stack is empty.\n        */\n       bool\n       empty() const\n       { return c.empty(); }\n-      \n+\n       /**  Returns the number of elements in the %stack.  */\n       size_type\n       size() const\n       { return c.size(); }\n-      \n+\n       /**\n        *  Returns a read/write reference to the data at the first\n        *  element of the %stack.\n        */\n       reference\n-      top() \n-      { \n+      top()\n+      {\n \t__glibcxx_requires_nonempty();\n-\treturn c.back(); \n+\treturn c.back();\n       }\n-      \n+\n       /**\n        *  Returns a read-only (constant) reference to the data at the first\n        *  element of the %stack.\n        */\n       const_reference\n-      top() const \n+      top() const\n       {\n \t__glibcxx_requires_nonempty();\n-\treturn c.back(); \n+\treturn c.back();\n       }\n-      \n+\n       /**\n        *  @brief  Add data to the top of the %stack.\n        *  @param  x  Data to be added.\n@@ -189,7 +189,7 @@ namespace std\n       void\n       push(const value_type& __x)\n       { c.push_back(__x); }\n-  \n+\n       /**\n        *  @brief  Removes first element.\n        *\n@@ -202,13 +202,13 @@ namespace std\n        *  called.\n        */\n       void\n-      pop() \n+      pop()\n       {\n \t__glibcxx_requires_nonempty();\n-\tc.pop_back(); \n+\tc.pop_back();\n       }\n     };\n-  \n+\n   /**\n    *  @brief  Stack equality comparison.\n    *  @param  x  A %stack.\n@@ -225,7 +225,7 @@ namespace std\n     inline bool\n     operator==(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n     { return __x.c == __y.c; }\n-  \n+\n   /**\n    *  @brief  Stack ordering relation.\n    *  @param  x  A %stack.\n@@ -243,25 +243,25 @@ namespace std\n     inline bool\n     operator<(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n     { return __x.c < __y.c; }\n-  \n+\n   /// Based on operator==\n   template<typename _Tp, typename _Seq>\n     inline bool\n     operator!=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n     { return !(__x == __y); }\n-  \n+\n   /// Based on operator<\n   template<typename _Tp, typename _Seq>\n     inline bool\n     operator>(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n     { return __y < __x; }\n-  \n+\n   /// Based on operator<\n   template<typename _Tp, typename _Seq>\n     inline bool\n     operator<=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n     { return !(__y < __x); }\n-  \n+\n   /// Based on operator<\n   template<typename _Tp, typename _Seq>\n     inline bool"}, {"sha": "399cffb3311c38b8da6b5b767b9e5de7afc1a3c8", "filename": "libstdc++-v3/include/bits/stl_tempbuf.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tempbuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tempbuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tempbuf.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -83,65 +83,65 @@ namespace std\n       typedef value_type* pointer;\n       typedef pointer     iterator;\n       typedef ptrdiff_t   size_type;\n-      \n+\n     protected:\n       size_type  _M_original_len;\n       size_type  _M_len;\n       pointer    _M_buffer;\n-      \n+\n       void\n       _M_initialize_buffer(const _Tp&, __true_type) { }\n \n       void\n       _M_initialize_buffer(const _Tp& val, __false_type)\n       { std::uninitialized_fill_n(_M_buffer, _M_len, val); }\n-      \n+\n     public:\n       /// As per Table mumble.\n       size_type\n       size() const\n       { return _M_len; }\n-      \n+\n       /// Returns the size requested by the constructor; may be >size().\n       size_type\n       requested_size() const\n       { return _M_original_len; }\n-      \n+\n       /// As per Table mumble.\n       iterator\n       begin()\n       { return _M_buffer; }\n-      \n+\n       /// As per Table mumble.\n       iterator\n       end()\n       { return _M_buffer + _M_len; }\n-      \n+\n       /**\n        * Constructs a temporary buffer of a size somewhere between\n        * zero and the size of the given range.\n        */\n       _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);\n-      \n+\n       ~_Temporary_buffer()\n-      {  \n+      {\n \tstd::_Destroy(_M_buffer, _M_buffer + _M_len);\n \tstd::return_temporary_buffer(_M_buffer);\n       }\n-      \n+\n     private:\n       // Disable copy constructor and assignment operator.\n       _Temporary_buffer(const _Temporary_buffer&);\n \n       void\n       operator=(const _Temporary_buffer&);\n     };\n-  \n+\n \n   template<typename _ForwardIterator, typename _Tp>\n     _Temporary_buffer<_ForwardIterator, _Tp>::\n     _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)\n-    : _M_original_len(std::distance(__first, __last)), \n+    : _M_original_len(std::distance(__first, __last)),\n       _M_len(0), _M_buffer(0)\n     {\n       // Workaround for a __type_traits bug in the pre-7.3 compiler.\n@@ -158,11 +158,11 @@ namespace std\n \t    _M_initialize_buffer(*__first, _Trivial());\n \t}\n       catch(...)\n-\t{ \n+\t{\n \t  std::return_temporary_buffer(_M_buffer);\n-\t  _M_buffer = 0; \n+\t  _M_buffer = 0;\n \t  _M_len = 0;\n-\t  __throw_exception_again; \n+\t  __throw_exception_again;\n \t}\n     }\n } // namespace std"}, {"sha": "93fb9e99ee68b8f96ebf7f0c1897a4144b1f964f", "filename": "libstdc++-v3/include/bits/stl_threads.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -85,8 +85,8 @@ namespace __gnu_cxx\n #endif\n     __gthread_mutex_t _M_lock;\n \n-    void \n-    _M_initialize() \n+    void\n+    _M_initialize()\n     {\n #ifdef __GTHREAD_MUTEX_INIT\n       // There should be no code in this path given the usage rules above.\n@@ -97,7 +97,7 @@ namespace __gnu_cxx\n \t  && __gthread_active_p())\n \tabort ();\n       __gthread_mutex_lock(&__gnu_cxx::_GLIBCXX_mutex);\n-      if (!_M_init_flag) \n+      if (!_M_init_flag)\n \t{\n \t  // Even though we have a global lock, we use __gthread_once to be\n \t  // absolutely certain the _M_lock mutex is only initialized once on\n@@ -113,25 +113,25 @@ namespace __gnu_cxx\n #endif\n     }\n \n-    void \n-    _M_acquire_lock() \n+    void\n+    _M_acquire_lock()\n     {\n #if !defined(__GTHREAD_MUTEX_INIT) && defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n       if (!_M_init_flag) _M_initialize();\n #endif\n       __gthread_mutex_lock(&_M_lock);\n     }\n \n-    void \n-    _M_release_lock() \n+    void\n+    _M_release_lock()\n     {\n #if !defined(__GTHREAD_MUTEX_INIT) && defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n       if (!_M_init_flag) _M_initialize();\n #endif\n       __gthread_mutex_unlock(&_M_lock);\n     }\n   };\n-  \n+\n #ifdef __GTHREAD_MUTEX_INIT\n #define __STL_MUTEX_INITIALIZER = { __GTHREAD_MUTEX_INIT }\n #elif defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n@@ -144,4 +144,4 @@ namespace __gnu_cxx\n #endif\n } // namespace __gnu_cxx\n \n-#endif \n+#endif"}, {"sha": "35f1c08678c0f89593136f8c6d7d6692f1c07493", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 248, "deletions": 248, "changes": 496, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -89,20 +89,20 @@ iterators invalidated are those referring to the deleted node.\n #include <bits/stl_function.h>\n \n namespace std\n-{ \n+{\n   enum _Rb_tree_color { _S_red = false, _S_black = true };\n \n   struct _Rb_tree_node_base\n   {\n     typedef _Rb_tree_node_base* _Base_ptr;\n     typedef const _Rb_tree_node_base* _Const_Base_ptr;\n-    \n-    _Rb_tree_color \t_M_color; \n-    _Base_ptr \t\t_M_parent;\n-    _Base_ptr \t\t_M_left;\n-    _Base_ptr \t\t_M_right;\n-    \n-    static _Base_ptr \n+\n+    _Rb_tree_color\t_M_color;\n+    _Base_ptr\t\t_M_parent;\n+    _Base_ptr\t\t_M_left;\n+    _Base_ptr\t\t_M_right;\n+\n+    static _Base_ptr\n     _S_minimum(_Base_ptr __x)\n     {\n       while (__x->_M_left != 0) __x = __x->_M_left;\n@@ -116,7 +116,7 @@ namespace std\n       return __x;\n     }\n \n-    static _Base_ptr \n+    static _Base_ptr\n     _S_maximum(_Base_ptr __x)\n     {\n       while (__x->_M_right != 0) __x = __x->_M_right;\n@@ -137,7 +137,7 @@ namespace std\n       typedef _Rb_tree_node<_Val>* _Link_type;\n       _Val _M_value_field;\n     };\n-  \n+\n   _Rb_tree_node_base*\n   _Rb_tree_increment(_Rb_tree_node_base* __x);\n \n@@ -163,44 +163,44 @@ namespace std\n       typedef _Rb_tree_iterator<_Tp>        _Self;\n       typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;\n       typedef _Rb_tree_node<_Tp>*           _Link_type;\n-      \n+\n       _Rb_tree_iterator() {}\n \n       _Rb_tree_iterator(_Link_type __x)\n       : _M_node(__x) {}\n \n-      reference \n+      reference\n       operator*() const\n       { return static_cast<_Link_type>(_M_node)->_M_value_field; }\n \n-      pointer \n+      pointer\n       operator->() const\n       { return &static_cast<_Link_type>(_M_node)->_M_value_field; }\n \n-      _Self& \n-      operator++() \n-      { \n+      _Self&\n+      operator++()\n+      {\n \t_M_node = _Rb_tree_increment(_M_node);\n-\treturn *this; \n+\treturn *this;\n       }\n \n-      _Self \n-      operator++(int) \n+      _Self\n+      operator++(int)\n       {\n \t_Self __tmp = *this;\n \t_M_node = _Rb_tree_increment(_M_node);\n \treturn __tmp;\n       }\n-    \n-      _Self& \n+\n+      _Self&\n       operator--()\n       {\n \t_M_node = _Rb_tree_decrement(_M_node);\n \treturn *this;\n       }\n \n-      _Self \n-      operator--(int) \n+      _Self\n+      operator--(int)\n       {\n \t_Self __tmp = *this;\n \t_M_node = _Rb_tree_decrement(_M_node);\n@@ -233,7 +233,7 @@ namespace std\n       typedef _Rb_tree_const_iterator<_Tp>        _Self;\n       typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;\n       typedef const _Rb_tree_node<_Tp>*           _Link_type;\n-      \n+\n       _Rb_tree_const_iterator() {}\n \n       _Rb_tree_const_iterator(_Link_type __x)\n@@ -250,30 +250,30 @@ namespace std\n       operator->() const\n       { return &static_cast<_Link_type>(_M_node)->_M_value_field; }\n \n-      _Self& \n-      operator++() \n-      { \n+      _Self&\n+      operator++()\n+      {\n \t_M_node = _Rb_tree_increment(_M_node);\n-\treturn *this; \n+\treturn *this;\n       }\n \n-      _Self \n-      operator++(int) \n+      _Self\n+      operator++(int)\n       {\n \t_Self __tmp = *this;\n \t_M_node = _Rb_tree_increment(_M_node);\n \treturn __tmp;\n       }\n-    \n-      _Self& \n+\n+      _Self&\n       operator--()\n       {\n \t_M_node = _Rb_tree_decrement(_M_node);\n \treturn *this;\n       }\n \n-      _Self \n-      operator--(int) \n+      _Self\n+      operator--(int)\n       {\n \t_Self __tmp = *this;\n \t_M_node = _Rb_tree_decrement(_M_node);\n@@ -292,49 +292,49 @@ namespace std\n     };\n \n   template<typename _Val>\n-    inline bool \n+    inline bool\n     operator==(const _Rb_tree_iterator<_Val>& __x,\n-               const _Rb_tree_const_iterator<_Val>& __y) \n+               const _Rb_tree_const_iterator<_Val>& __y)\n     { return __x._M_node == __y._M_node; }\n \n   template<typename _Val>\n-    inline bool \n+    inline bool\n     operator!=(const _Rb_tree_iterator<_Val>& __x,\n-               const _Rb_tree_const_iterator<_Val>& __y) \n+               const _Rb_tree_const_iterator<_Val>& __y)\n     { return __x._M_node != __y._M_node; }\n \n-  void \n+  void\n   _Rb_tree_rotate_left(_Rb_tree_node_base* const __x,\n                        _Rb_tree_node_base*& __root);\n \n-  void \n+  void\n   _Rb_tree_rotate_right(_Rb_tree_node_base* const __x,\n                         _Rb_tree_node_base*& __root);\n \n-  void \n+  void\n   _Rb_tree_insert_and_rebalance(const bool          __insert_left,\n                                 _Rb_tree_node_base* __x,\n                                 _Rb_tree_node_base* __p,\n                                 _Rb_tree_node_base& __header);\n \n   _Rb_tree_node_base*\n-  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z, \n-\t\t\t       _Rb_tree_node_base& \t __header);\n+  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,\n+\t\t\t       _Rb_tree_node_base&\t __header);\n \n \n-  template<typename _Key, typename _Val, typename _KeyOfValue, \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc = allocator<_Val> >\n     class _Rb_tree\n     : protected _Alloc::template rebind<_Rb_tree_node<_Val> >::other\n     {\n       typedef typename _Alloc::template rebind<_Rb_tree_node<_Val> >::other\n               _Node_allocator;\n-      \n+\n     protected:\n       typedef _Rb_tree_node_base* _Base_ptr;\n       typedef const _Rb_tree_node_base* _Const_Base_ptr;\n       typedef _Rb_tree_node<_Val> _Rb_tree_node;\n-      \n+\n     public:\n       typedef _Key key_type;\n       typedef _Val value_type;\n@@ -346,35 +346,35 @@ namespace std\n       typedef const _Rb_tree_node* _Const_Link_type;\n       typedef size_t size_type;\n       typedef ptrdiff_t difference_type;\n-      \n+\n       typedef _Alloc allocator_type;\n       allocator_type get_allocator() const\n       { return *static_cast<const _Node_allocator*>(this); }\n-      \n+\n     protected:\n       _Rb_tree_node*\n       _M_get_node()\n       { return _Node_allocator::allocate(1); }\n \n-      void \n+      void\n       _M_put_node(_Rb_tree_node* __p)\n       { _Node_allocator::deallocate(__p, 1); }\n-      \n+\n       _Link_type\n       _M_create_node(const value_type& __x)\n       {\n \t_Link_type __tmp = _M_get_node();\n-\ttry \n+\ttry\n \t  { std::_Construct(&__tmp->_M_value_field, __x); }\n \tcatch(...)\n \t  {\n \t    _M_put_node(__tmp);\n-\t    __throw_exception_again; \n+\t    __throw_exception_again;\n \t  }\n \treturn __tmp;\n       }\n-      \n-      _Link_type \n+\n+      _Link_type\n       _M_clone_node(_Const_Link_type __x)\n       {\n \t_Link_type __tmp = _M_create_node(__x->_M_value_field);\n@@ -395,7 +395,7 @@ namespace std\n       _Rb_tree_node_base _M_header;\n       size_type _M_node_count; // keeps track of size of tree\n       _Compare _M_key_compare;\n-      \n+\n     protected:\n       _Base_ptr&\n       _M_root()\n@@ -437,11 +437,11 @@ namespace std\n       _M_end() const\n       { return static_cast<_Const_Link_type>(&this->_M_header); }\n \n-      static const_reference \n+      static const_reference\n       _S_value(_Const_Link_type __x)\n       { return __x->_M_value_field; }\n \n-      static const _Key& \n+      static const _Key&\n       _S_key(_Const_Link_type __x)\n       { return _KeyOfValue()(_S_value(__x)); }\n \n@@ -465,12 +465,12 @@ namespace std\n       _S_value(_Const_Base_ptr __x)\n       { return static_cast<_Const_Link_type>(__x)->_M_value_field; }\n \n-      static const _Key& \n+      static const _Key&\n       _S_key(_Const_Base_ptr __x)\n       { return _KeyOfValue()(_S_value(__x)); }\n \n-      static _Base_ptr \n-      _S_minimum(_Base_ptr __x) \n+      static _Base_ptr\n+      _S_minimum(_Base_ptr __x)\n       { return _Rb_tree_node_base::_S_minimum(__x); }\n \n       static _Const_Base_ptr\n@@ -493,13 +493,13 @@ namespace std\n       typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n \n     private:\n-      iterator \n+      iterator\n       _M_insert(_Base_ptr __x, _Base_ptr __y, const value_type& __v);\n \n-      _Link_type \n+      _Link_type\n       _M_copy(_Const_Link_type __x, _Link_type __p);\n \n-      void \n+      void\n       _M_erase(_Link_type __x);\n \n     public:\n@@ -513,23 +513,23 @@ namespace std\n       _Rb_tree(const _Compare& __comp)\n       : _Node_allocator(allocator_type()),\n \t_M_node_count(0),\n-\t_M_key_compare(__comp) \n+\t_M_key_compare(__comp)\n       { _M_empty_initialize(); }\n \n       _Rb_tree(const _Compare& __comp, const allocator_type& __a)\n       : _Node_allocator(__a),\n \t_M_node_count(0),\n-\t_M_key_compare(__comp) \n+\t_M_key_compare(__comp)\n       { _M_empty_initialize(); }\n \n-      _Rb_tree(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x) \n+      _Rb_tree(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x)\n       : _Node_allocator(__x.get_allocator()),\n-\t_M_node_count(0), \n+\t_M_node_count(0),\n \t_M_key_compare(__x._M_key_compare)\n-      { \n+      {\n \tif (__x._M_root() == 0)\n \t  _M_empty_initialize();\n-\telse \n+\telse\n \t  {\n \t    this->_M_header._M_color = _S_red;\n \t    _M_root() = _M_copy(__x._M_begin(), _M_end());\n@@ -542,103 +542,103 @@ namespace std\n       ~_Rb_tree()\n       { _M_erase(_M_begin()); }\n \n-      _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& \n+      _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>&\n       operator=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x);\n \n     private:\n-      void _M_empty_initialize() \n+      void _M_empty_initialize()\n       {\n \t// Used to distinguish header from __root, in iterator.operator++.\n-\tthis->_M_header._M_color = _S_red; \n+\tthis->_M_header._M_color = _S_red;\n \t_M_root() = 0;\n \t_M_leftmost() = _M_end();\n \t_M_rightmost() = _M_end();\n       }\n \n-    public:    \n+    public:\n       // Accessors.\n-      _Compare \n+      _Compare\n       key_comp() const\n       { return _M_key_compare; }\n \n-      iterator \n+      iterator\n       begin()\n       { return static_cast<_Link_type>(this->_M_header._M_left); }\n \n-      const_iterator \n+      const_iterator\n       begin() const\n       { return static_cast<_Const_Link_type>(this->_M_header._M_left); }\n \n-      iterator \n+      iterator\n       end()\n       { return static_cast<_Link_type>(&this->_M_header); }\n \n       const_iterator\n       end() const\n       { return static_cast<_Const_Link_type>(&this->_M_header); }\n \n-      reverse_iterator \n+      reverse_iterator\n       rbegin()\n       { return reverse_iterator(end()); }\n \n-      const_reverse_iterator \n+      const_reverse_iterator\n       rbegin() const\n       { return const_reverse_iterator(end()); }\n \n-      reverse_iterator \n+      reverse_iterator\n       rend()\n       { return reverse_iterator(begin()); }\n \n-      const_reverse_iterator \n+      const_reverse_iterator\n       rend() const\n       { return const_reverse_iterator(begin()); }\n- \n-      bool \n+\n+      bool\n       empty() const\n       { return _M_node_count == 0; }\n \n-      size_type \n+      size_type\n       size() const\n       { return _M_node_count; }\n \n-      size_type \n+      size_type\n       max_size() const\n       { return size_type(-1); }\n \n-      void \n+      void\n       swap(_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __t);\n-    \n+\n       // Insert/erase.\n-      pair<iterator,bool> \n+      pair<iterator,bool>\n       insert_unique(const value_type& __x);\n \n-      iterator \n+      iterator\n       insert_equal(const value_type& __x);\n \n-      iterator \n+      iterator\n       insert_unique(iterator __position, const value_type& __x);\n \n-      iterator \n+      iterator\n       insert_equal(iterator __position, const value_type& __x);\n \n       template<typename _InputIterator>\n-      void \n+      void\n       insert_unique(_InputIterator __first, _InputIterator __last);\n \n       template<typename _InputIterator>\n-      void \n+      void\n       insert_equal(_InputIterator __first, _InputIterator __last);\n \n-      void \n+      void\n       erase(iterator __position);\n \n-      size_type \n+      size_type\n       erase(const key_type& __x);\n \n-      void \n+      void\n       erase(iterator __first, iterator __last);\n \n-      void \n+      void\n       erase(const key_type* __first, const key_type* __last);\n \n       void\n@@ -652,105 +652,105 @@ namespace std\n       }\n \n       // Set operations.\n-      iterator \n+      iterator\n       find(const key_type& __x);\n \n-      const_iterator \n+      const_iterator\n       find(const key_type& __x) const;\n \n-      size_type \n+      size_type\n       count(const key_type& __x) const;\n \n-      iterator \n+      iterator\n       lower_bound(const key_type& __x);\n \n-      const_iterator \n+      const_iterator\n       lower_bound(const key_type& __x) const;\n \n-      iterator \n+      iterator\n       upper_bound(const key_type& __x);\n \n-      const_iterator \n+      const_iterator\n       upper_bound(const key_type& __x) const;\n \n-      pair<iterator,iterator> \n+      pair<iterator,iterator>\n       equal_range(const key_type& __x);\n \n-      pair<const_iterator, const_iterator> \n+      pair<const_iterator, const_iterator>\n       equal_range(const key_type& __x) const;\n \n       // Debugging.\n-      bool \n+      bool\n       __rb_verify() const;\n     };\n \n-  template<typename _Key, typename _Val, typename _KeyOfValue, \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    inline bool \n-    operator==(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x, \n+    inline bool\n+    operator==(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x,\n \t       const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)\n     {\n       return __x.size() == __y.size()\n \t     && equal(__x.begin(), __x.end(), __y.begin());\n     }\n \n-  template<typename _Key, typename _Val, typename _KeyOfValue, \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    inline bool \n-    operator<(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x, \n+    inline bool\n+    operator<(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x,\n \t      const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)\n     {\n       return lexicographical_compare(__x.begin(), __x.end(),\n \t\t\t\t     __y.begin(), __y.end());\n     }\n \n-  template<typename _Key, typename _Val, typename _KeyOfValue, \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    inline bool \n-    operator!=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x, \n-\t       const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y) \n+    inline bool\n+    operator!=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x,\n+\t       const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)\n     { return !(__x == __y); }\n \n-  template<typename _Key, typename _Val, typename _KeyOfValue, \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    inline bool \n-    operator>(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x, \n-\t      const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y) \n+    inline bool\n+    operator>(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x,\n+\t      const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)\n     { return __y < __x; }\n \n-  template<typename _Key, typename _Val, typename _KeyOfValue, \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    inline bool \n-    operator<=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x, \n-\t       const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y) \n+    inline bool\n+    operator<=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x,\n+\t       const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)\n     { return !(__y < __x); }\n \n-  template<typename _Key, typename _Val, typename _KeyOfValue, \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    inline bool \n-    operator>=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x, \n-\t       const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y) \n+    inline bool\n+    operator>=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x,\n+\t       const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)\n     { return !(__x < __y); }\n \n-  template<typename _Key, typename _Val, typename _KeyOfValue, \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    inline void \n-    swap(_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x, \n+    inline void\n+    swap(_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x,\n \t _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)\n     { __x.swap(__y); }\n \n-  template<typename _Key, typename _Val, typename _KeyOfValue, \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& \n+    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>&\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     operator=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x)\n     {\n-      if (this != &__x) \n+      if (this != &__x)\n \t{\n \t  // Note that _Key may be a constant type.\n \t  clear();\n-\t  _M_key_compare = __x._M_key_compare;        \n-\t  if (__x._M_root() != 0) \n+\t  _M_key_compare = __x._M_key_compare;\n+\t  if (__x._M_root() != 0)\n \t    {\n \t      _M_root() = _M_copy(__x._M_begin(), _M_end());\n \t      _M_leftmost() = _S_minimum(_M_root());\n@@ -761,7 +761,7 @@ namespace std\n       return *this;\n     }\n \n-  template<typename _Key, typename _Val, typename _KeyOfValue, \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n@@ -778,15 +778,15 @@ namespace std\n       return iterator(__z);\n     }\n \n-  template<typename _Key, typename _Val, typename _KeyOfValue, \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     insert_equal(const _Val& __v)\n     {\n       _Link_type __x = _M_begin();\n       _Link_type __y = _M_end();\n-      while (__x != 0) \n+      while (__x != 0)\n \t{\n \t  __y = __x;\n \t  __x = _M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ?\n@@ -795,7 +795,7 @@ namespace std\n       return _M_insert(__x, __y, __v);\n     }\n \n-  template<typename _Key, typename _Val, typename _KeyOfValue, \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     void\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n@@ -840,9 +840,9 @@ namespace std\n       std::swap(this->_M_key_compare, __t._M_key_compare);\n     }\n \n-  template<typename _Key, typename _Val, typename _KeyOfValue, \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    pair<typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator, \n+    pair<typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator,\n     bool>\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     insert_unique(const _Val& __v)\n@@ -866,130 +866,130 @@ namespace std\n \treturn pair<iterator,bool>(_M_insert(__x, __y, __v), true);\n       return pair<iterator,bool>(__j, false);\n     }\n-  \n-  template<typename _Key, typename _Val, typename _KeyOfValue, \n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator \n+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n     insert_unique(iterator __position, const _Val& __v)\n     {\n       if (__position._M_node == _M_leftmost())\n-\t{ \n+\t{\n \t  // begin()\n \t  if (size() > 0\n \t      && _M_key_compare(_KeyOfValue()(__v), _S_key(__position._M_node)))\n \t    return _M_insert(__position._M_node, __position._M_node, __v);\n-\t  // first argument just needs to be non-null \n+\t  // first argument just needs to be non-null\n \t  else\n \t    return insert_unique(__v).first;\n-\t} \n-      else if (__position._M_node == _M_end()) \n-\t{ \n+\t}\n+      else if (__position._M_node == _M_end())\n+\t{\n \t  // end()\n \t  if (_M_key_compare(_S_key(_M_rightmost()), _KeyOfValue()(__v)))\n \t    return _M_insert(0, _M_rightmost(), __v);\n \t  else\n \t    return insert_unique(__v).first;\n-\t} \n-      else \n+\t}\n+      else\n \t{\n \t  iterator __before = __position;\n \t  --__before;\n-\t  if (_M_key_compare(_S_key(__before._M_node), _KeyOfValue()(__v)) \n+\t  if (_M_key_compare(_S_key(__before._M_node), _KeyOfValue()(__v))\n \t      && _M_key_compare(_KeyOfValue()(__v),_S_key(__position._M_node)))\n \t    {\n \t      if (_S_right(__before._M_node) == 0)\n-\t\treturn _M_insert(0, __before._M_node, __v); \n+\t\treturn _M_insert(0, __before._M_node, __v);\n \t      else\n \t\treturn _M_insert(__position._M_node, __position._M_node, __v);\n-\t      // first argument just needs to be non-null \n-\t    } \n+\t      // first argument just needs to be non-null\n+\t    }\n \t  else\n \t    return insert_unique(__v).first;\n \t}\n     }\n \n-  template<typename _Key, typename _Val, typename _KeyOfValue, \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator \n+    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     insert_equal(iterator __position, const _Val& __v)\n     {\n       if (__position._M_node == _M_leftmost())\n-\t{ \n+\t{\n \t  // begin()\n \t  if (size() > 0\n \t      && !_M_key_compare(_S_key(__position._M_node),\n \t\t\t\t _KeyOfValue()(__v)))\n \t    return _M_insert(__position._M_node, __position._M_node, __v);\n-\t  // first argument just needs to be non-null \n+\t  // first argument just needs to be non-null\n \t  else\n \t    return insert_equal(__v);\n-\t} \n-      else if (__position._M_node == _M_end()) \n+\t}\n+      else if (__position._M_node == _M_end())\n \t{\n \t  // end()\n \t  if (!_M_key_compare(_KeyOfValue()(__v), _S_key(_M_rightmost())))\n \t    return _M_insert(0, _M_rightmost(), __v);\n \t  else\n \t    return insert_equal(__v);\n-\t} \n-      else \n+\t}\n+      else\n \t{\n \t  iterator __before = __position;\n \t  --__before;\n \t  if (!_M_key_compare(_KeyOfValue()(__v), _S_key(__before._M_node))\n \t      && !_M_key_compare(_S_key(__position._M_node),\n-\t\t\t\t _KeyOfValue()(__v))) \n+\t\t\t\t _KeyOfValue()(__v)))\n \t    {\n \t      if (_S_right(__before._M_node) == 0)\n-\t\treturn _M_insert(0, __before._M_node, __v); \n+\t\treturn _M_insert(0, __before._M_node, __v);\n \t      else\n \t\treturn _M_insert(__position._M_node, __position._M_node, __v);\n-\t      // first argument just needs to be non-null \n-\t    } \n+\t      // first argument just needs to be non-null\n+\t    }\n \t  else\n \t    return insert_equal(__v);\n \t}\n     }\n \n-  template<typename _Key, typename _Val, typename _KoV, \n+  template<typename _Key, typename _Val, typename _KoV,\n            typename _Cmp, typename _Alloc>\n     template<class _II>\n-      void \n+      void\n       _Rb_tree<_Key,_Val,_KoV,_Cmp,_Alloc>::\n       insert_equal(_II __first, _II __last)\n       {\n \tfor ( ; __first != __last; ++__first)\n \t  insert_equal(*__first);\n       }\n \n-  template<typename _Key, typename _Val, typename _KoV, \n-           typename _Cmp, typename _Alloc> \n+  template<typename _Key, typename _Val, typename _KoV,\n+           typename _Cmp, typename _Alloc>\n     template<class _II>\n-    void \n+    void\n     _Rb_tree<_Key,_Val,_KoV,_Cmp,_Alloc>::\n-    insert_unique(_II __first, _II __last) \n+    insert_unique(_II __first, _II __last)\n     {\n       for ( ; __first != __last; ++__first)\n \tinsert_unique(*__first);\n     }\n \n-  template<typename _Key, typename _Val, typename _KeyOfValue, \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    inline void \n+    inline void\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::erase(iterator __position)\n     {\n-      _Link_type __y = \n+      _Link_type __y =\n \tstatic_cast<_Link_type>(_Rb_tree_rebalance_for_erase(__position._M_node,\n \t\t\t\t\t\t\t     this->_M_header));\n       destroy_node(__y);\n       --_M_node_count;\n     }\n \n-  template<typename _Key, typename _Val, typename _KeyOfValue, \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::size_type \n+    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::size_type\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::erase(const _Key& __x)\n     {\n       pair<iterator,iterator> __p = equal_range(__x);\n@@ -998,24 +998,24 @@ namespace std\n       return __n;\n     }\n \n-  template<typename _Key, typename _Val, typename _KoV, \n+  template<typename _Key, typename _Val, typename _KoV,\n            typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type \n+    typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type\n     _Rb_tree<_Key,_Val,_KoV,_Compare,_Alloc>::\n     _M_copy(_Const_Link_type __x, _Link_type __p)\n     {\n       // Structural copy.  __x and __p must be non-null.\n       _Link_type __top = _M_clone_node(__x);\n       __top->_M_parent = __p;\n-      \n-      try \n+\n+      try\n \t{\n \t  if (__x->_M_right)\n \t    __top->_M_right = _M_copy(_S_right(__x), __top);\n \t  __p = __top;\n \t  __x = _S_left(__x);\n-\t  \n-\t  while (__x != 0) \n+\n+\t  while (__x != 0)\n \t    {\n \t      _Link_type __y = _M_clone_node(__x);\n \t      __p->_M_left = __y;\n@@ -1029,18 +1029,18 @@ namespace std\n       catch(...)\n \t{\n \t  _M_erase(__top);\n-\t  __throw_exception_again; \n+\t  __throw_exception_again;\n \t}\n       return __top;\n     }\n \n-  template<typename _Key, typename _Val, typename _KeyOfValue, \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    void \n+    void\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_M_erase(_Link_type __x)\n     {\n       // Erase without rebalancing.\n-      while (__x != 0) \n+      while (__x != 0)\n \t{\n \t  _M_erase(_S_right(__x));\n \t  _Link_type __y = _S_left(__x);\n@@ -1049,9 +1049,9 @@ namespace std\n \t}\n     }\n \n-  template<typename _Key, typename _Val, typename _KeyOfValue, \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    void \n+    void\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     erase(iterator __first, iterator __last)\n     {\n@@ -1061,59 +1061,59 @@ namespace std\n \twhile (__first != __last) erase(__first++);\n     }\n \n-  template<typename _Key, typename _Val, typename _KeyOfValue, \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    void \n+    void\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n-    erase(const _Key* __first, const _Key* __last) \n-    { \n-      while (__first != __last) \n-\terase(*__first++); \n+    erase(const _Key* __first, const _Key* __last)\n+    {\n+      while (__first != __last)\n+\terase(*__first++);\n     }\n \n-  template<typename _Key, typename _Val, typename _KeyOfValue, \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator \n+    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::find(const _Key& __k)\n     {\n       _Link_type __x = _M_begin(); // Current node.\n       _Link_type __y = _M_end(); // Last node which is not less than __k.\n-      \n-      while (__x != 0) \n+\n+      while (__x != 0)\n \tif (!_M_key_compare(_S_key(__x), __k))\n \t  __y = __x, __x = _S_left(__x);\n \telse\n \t  __x = _S_right(__x);\n-      \n-      iterator __j = iterator(__y);   \n-      return (__j == end() || _M_key_compare(__k, _S_key(__j._M_node))) ? \n+\n+      iterator __j = iterator(__y);\n+      return (__j == end() || _M_key_compare(__k, _S_key(__j._M_node))) ?\n \tend() : __j;\n     }\n-  \n-  template<typename _Key, typename _Val, typename _KeyOfValue, \n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     find(const _Key& __k) const\n     {\n       _Const_Link_type __x = _M_begin(); // Current node.\n       _Const_Link_type __y = _M_end(); // Last node which is not less than __k.\n- \n-     while (__x != 0) \n+\n+     while (__x != 0)\n        {\n \t if (!_M_key_compare(_S_key(__x), __k))\n \t   __y = __x, __x = _S_left(__x);\n \t else\n \t   __x = _S_right(__x);\n-       } \n-     const_iterator __j = const_iterator(__y);   \n+       }\n+     const_iterator __j = const_iterator(__y);\n      return (__j == end() || _M_key_compare(__k, _S_key(__j._M_node))) ?\n        end() : __j;\n     }\n \n-  template<typename _Key, typename _Val, typename _KeyOfValue, \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::size_type \n+    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::size_type\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     count(const _Key& __k) const\n     {\n@@ -1122,91 +1122,91 @@ namespace std\n       return __n;\n     }\n \n-  template<typename _Key, typename _Val, typename _KeyOfValue, \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator \n+    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     lower_bound(const _Key& __k)\n     {\n       _Link_type __x = _M_begin(); // Current node.\n       _Link_type __y = _M_end(); // Last node which is not less than __k.\n-      \n-      while (__x != 0) \n+\n+      while (__x != 0)\n \tif (!_M_key_compare(_S_key(__x), __k))\n \t  __y = __x, __x = _S_left(__x);\n \telse\n \t  __x = _S_right(__x);\n-      \n+\n       return iterator(__y);\n     }\n \n-  template<typename _Key, typename _Val, typename _KeyOfValue, \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator \n+    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     lower_bound(const _Key& __k) const\n     {\n       _Const_Link_type __x = _M_begin(); // Current node.\n       _Const_Link_type __y = _M_end(); // Last node which is not less than __k.\n-      \n-      while (__x != 0) \n+\n+      while (__x != 0)\n \tif (!_M_key_compare(_S_key(__x), __k))\n \t  __y = __x, __x = _S_left(__x);\n \telse\n \t  __x = _S_right(__x);\n-      \n+\n       return const_iterator(__y);\n     }\n \n-  template<typename _Key, typename _Val, typename _KeyOfValue, \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator \n+    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     upper_bound(const _Key& __k)\n     {\n       _Link_type __x = _M_begin(); // Current node.\n       _Link_type __y = _M_end(); // Last node which is greater than __k.\n-      \n-      while (__x != 0) \n+\n+      while (__x != 0)\n \tif (_M_key_compare(__k, _S_key(__x)))\n \t  __y = __x, __x = _S_left(__x);\n \telse\n \t  __x = _S_right(__x);\n-      \n+\n       return iterator(__y);\n     }\n \n-  template<typename _Key, typename _Val, typename _KeyOfValue, \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator \n+    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     upper_bound(const _Key& __k) const\n     {\n       _Const_Link_type __x = _M_begin(); // Current node.\n       _Const_Link_type __y = _M_end(); // Last node which is greater than __k.\n-      \n-      while (__x != 0) \n+\n+      while (__x != 0)\n \tif (_M_key_compare(__k, _S_key(__x)))\n \t  __y = __x, __x = _S_left(__x);\n \telse\n \t  __x = _S_right(__x);\n-      \n+\n       return const_iterator(__y);\n     }\n \n-  template<typename _Key, typename _Val, typename _KeyOfValue, \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    inline \n+    inline\n     pair<typename _Rb_tree<_Key,_Val,_KeyOfValue,\n \t\t\t   _Compare,_Alloc>::iterator,\n \t typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator>\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     equal_range(const _Key& __k)\n     { return pair<iterator, iterator>(lower_bound(__k), upper_bound(__k)); }\n \n-  template<typename _Key, typename _Val, typename _KoV, \n+  template<typename _Key, typename _Val, typename _KoV,\n            typename _Compare, typename _Alloc>\n-    inline \n+    inline\n     pair<typename _Rb_tree<_Key, _Val, _KoV,\n \t\t\t   _Compare, _Alloc>::const_iterator,\n \t typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::const_iterator>\n@@ -1219,43 +1219,43 @@ namespace std\n   _Rb_tree_black_count(const _Rb_tree_node_base* __node,\n                        const _Rb_tree_node_base* __root);\n \n-  template<typename _Key, typename _Val, typename _KeyOfValue, \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    bool \n+    bool\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const\n     {\n       if (_M_node_count == 0 || begin() == end())\n \treturn _M_node_count == 0 && begin() == end()\n \t       && this->_M_header._M_left == _M_end()\n \t       && this->_M_header._M_right == _M_end();\n-  \n+\n       unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());\n-      for (const_iterator __it = begin(); __it != end(); ++__it) \n+      for (const_iterator __it = begin(); __it != end(); ++__it)\n \t{\n \t  _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);\n \t  _Const_Link_type __L = _S_left(__x);\n \t  _Const_Link_type __R = _S_right(__x);\n-\t\n+\n \t  if (__x->_M_color == _S_red)\n-\t    if ((__L && __L->_M_color == _S_red) \n+\t    if ((__L && __L->_M_color == _S_red)\n \t\t|| (__R && __R->_M_color == _S_red))\n \t      return false;\n-\t\n+\n \t  if (__L && _M_key_compare(_S_key(__x), _S_key(__L)))\n \t    return false;\n \t  if (__R && _M_key_compare(_S_key(__R), _S_key(__x)))\n \t    return false;\n-\t  \n+\n \t  if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)\n \t    return false;\n \t}\n-    \n+\n       if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))\n \treturn false;\n       if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))\n \treturn false;\n       return true;\n     }\n-} // namespace std \n+} // namespace std\n \n-#endif \n+#endif"}, {"sha": "f4f8d187f646c32c82468aa95430be464418b601", "filename": "libstdc++-v3/include/bits/stl_uninitialized.h", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -67,20 +67,20 @@ namespace std\n {\n   // uninitialized_copy\n   template<typename _InputIterator, typename _ForwardIterator>\n-    inline _ForwardIterator \n+    inline _ForwardIterator\n     __uninitialized_copy_aux(_InputIterator __first, _InputIterator __last,\n \t\t\t     _ForwardIterator __result,\n \t\t\t     __true_type)\n     { return std::copy(__first, __last, __result); }\n \n   template<typename _InputIterator, typename _ForwardIterator>\n-    inline _ForwardIterator \n+    inline _ForwardIterator\n     __uninitialized_copy_aux(_InputIterator __first, _InputIterator __last,\n \t\t\t     _ForwardIterator __result,\n \t\t\t     __false_type)\n     {\n       _ForwardIterator __cur = __result;\n-      try \n+      try\n \t{\n \t  for ( ; __first != __last; ++__first, ++__cur)\n \t    std::_Construct(&*__cur, *__first);\n@@ -89,7 +89,7 @@ namespace std\n       catch(...)\n \t{\n \t  std::_Destroy(__result, __cur);\n-\t  __throw_exception_again; \n+\t  __throw_exception_again;\n \t}\n     }\n \n@@ -104,7 +104,7 @@ namespace std\n   */\n   template<typename _InputIterator, typename _ForwardIterator>\n     inline _ForwardIterator\n-    uninitialized_copy(_InputIterator __first, _InputIterator __last, \n+    uninitialized_copy(_InputIterator __first, _InputIterator __last,\n \t\t       _ForwardIterator __result)\n     {\n       typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;\n@@ -120,7 +120,7 @@ namespace std\n     return __result + (__last - __first);\n   }\n \n-  inline wchar_t* \n+  inline wchar_t*\n   uninitialized_copy(const wchar_t* __first, const wchar_t* __last,\n \t\t     wchar_t* __result)\n   {\n@@ -132,14 +132,14 @@ namespace std\n   // destructor is trivial.\n   template<typename _ForwardIterator, typename _Tp>\n     inline void\n-    __uninitialized_fill_aux(_ForwardIterator __first, \n-\t\t\t     _ForwardIterator __last, \n+    __uninitialized_fill_aux(_ForwardIterator __first,\n+\t\t\t     _ForwardIterator __last,\n \t\t\t     const _Tp& __x, __true_type)\n     { std::fill(__first, __last, __x); }\n \n   template<typename _ForwardIterator, typename _Tp>\n     void\n-    __uninitialized_fill_aux(_ForwardIterator __first, _ForwardIterator __last, \n+    __uninitialized_fill_aux(_ForwardIterator __first, _ForwardIterator __last,\n \t\t\t     const _Tp& __x, __false_type)\n     {\n       _ForwardIterator __cur = __first;\n@@ -151,7 +151,7 @@ namespace std\n       catch(...)\n \t{\n \t  std::_Destroy(__first, __cur);\n-\t  __throw_exception_again; \n+\t  __throw_exception_again;\n \t}\n     }\n \n@@ -166,7 +166,7 @@ namespace std\n   */\n   template<typename _ForwardIterator, typename _Tp>\n     inline void\n-    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last, \n+    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,\n \t\t       const _Tp& __x)\n     {\n       typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;\n@@ -188,16 +188,16 @@ namespace std\n \t\t\t       const _Tp& __x, __false_type)\n     {\n       _ForwardIterator __cur = __first;\n-      try \n+      try\n \t{\n \t  for ( ; __n > 0; --__n, ++__cur)\n \t    std::_Construct(&*__cur, __x);\n \t  return __cur;\n \t}\n       catch(...)\n-\t{ \n+\t{\n \t  std::_Destroy(__first, __cur);\n-\t  __throw_exception_again; \n+\t  __throw_exception_again;\n \t}\n     }\n \n@@ -211,28 +211,28 @@ namespace std\n    *  Like fill_n(), but does not require an initialized output range.\n   */\n   template<typename _ForwardIterator, typename _Size, typename _Tp>\n-    inline _ForwardIterator \n+    inline _ForwardIterator\n     uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)\n     {\n       typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;\n       typedef typename __type_traits<_ValueType>::is_POD_type _Is_POD;\n       return std::__uninitialized_fill_n_aux(__first, __n, __x, _Is_POD());\n     }\n \n-  // Extensions: __uninitialized_copy_copy, __uninitialized_copy_fill, \n+  // Extensions: __uninitialized_copy_copy, __uninitialized_copy_fill,\n   // __uninitialized_fill_copy.\n \n   // __uninitialized_copy_copy\n   // Copies [first1, last1) into [result, result + (last1 - first1)), and\n   //  copies [first2, last2) into\n   //  [result, result + (last1 - first1) + (last2 - first2)).\n \n-  template<typename _InputIterator1, typename _InputIterator2, \n+  template<typename _InputIterator1, typename _InputIterator2,\n \t   typename _ForwardIterator>\n     inline _ForwardIterator\n-    __uninitialized_copy_copy(_InputIterator1 __first1, \n+    __uninitialized_copy_copy(_InputIterator1 __first1,\n \t\t\t      _InputIterator1 __last1,\n-\t\t\t      _InputIterator2 __first2, \n+\t\t\t      _InputIterator2 __first2,\n \t\t\t      _InputIterator2 __last2,\n \t\t\t      _ForwardIterator __result)\n     {\n@@ -243,17 +243,17 @@ namespace std\n \t  return std::uninitialized_copy(__first2, __last2, __mid);\n \t}\n       catch(...)\n-\t{ \n+\t{\n \t  std::_Destroy(__result, __mid);\n-\t  __throw_exception_again; \n+\t  __throw_exception_again;\n \t}\n     }\n \n   // __uninitialized_fill_copy\n   // Fills [result, mid) with x, and copies [first, last) into\n   //  [mid, mid + (last - first)).\n   template<typename _ForwardIterator, typename _Tp, typename _InputIterator>\n-    inline _ForwardIterator \n+    inline _ForwardIterator\n     __uninitialized_fill_copy(_ForwardIterator __result, _ForwardIterator __mid,\n \t\t\t      const _Tp& __x, _InputIterator __first,\n \t\t\t      _InputIterator __last)\n@@ -266,7 +266,7 @@ namespace std\n       catch(...)\n \t{\n \t  std::_Destroy(__result, __mid);\n-\t  __throw_exception_again; \n+\t  __throw_exception_again;\n \t}\n     }\n \n@@ -279,16 +279,16 @@ namespace std\n \t\t\t      _ForwardIterator __first2,\n \t\t\t      _ForwardIterator __last2, const _Tp& __x)\n     {\n-      _ForwardIterator __mid2 = std::uninitialized_copy(__first1, __last1, \n+      _ForwardIterator __mid2 = std::uninitialized_copy(__first1, __last1,\n \t\t\t\t\t\t\t__first2);\n-      try \n+      try\n \t{\n \t  std::uninitialized_fill(__mid2, __last2, __x);\n \t}\n       catch(...)\n \t{\n \t  std::_Destroy(__first2, __mid2);\n-\t  __throw_exception_again; \n+\t  __throw_exception_again;\n \t}\n     }\n "}, {"sha": "06048015b87515b69e108bf37587e611a32d4eed", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 110, "deletions": 110, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -84,33 +84,33 @@ namespace __gnu_norm\n \n       _Vector_base(const allocator_type& __a)\n       : _Alloc(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0) { }\n-      \n+\n       _Vector_base(size_t __n, const allocator_type& __a)\n       : _Alloc(__a)\n       {\n \tthis->_M_start = this->_M_allocate(__n);\n \tthis->_M_finish = this->_M_start;\n \tthis->_M_end_of_storage = this->_M_start + __n;\n       }\n-      \n-      ~_Vector_base() \n-      { _M_deallocate(this->_M_start, \n+\n+      ~_Vector_base()\n+      { _M_deallocate(this->_M_start,\n \t\t      this->_M_end_of_storage - this->_M_start); }\n \n     public:\n       _Tp*           _M_start;\n       _Tp*           _M_finish;\n       _Tp*           _M_end_of_storage;\n-  \n+\n       _Tp*\n       _M_allocate(size_t __n) { return _Alloc::allocate(__n); }\n-  \n+\n       void\n       _M_deallocate(_Tp* __p, size_t __n)\n       { if (__p) _Alloc::deallocate(__p, __n); }\n     };\n-  \n-  \n+\n+\n   /**\n    *  @brief A standard container which offers fixed time access to\n    *  individual elements in any order.\n@@ -135,25 +135,25 @@ namespace __gnu_norm\n     {\n       // Concept requirements.\n       __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n-  \n-      typedef _Vector_base<_Tp, _Alloc>                     _Base;\n-      typedef vector<_Tp, _Alloc>                           vector_type;\n-  \n+\n+      typedef _Vector_base<_Tp, _Alloc>\t\t\t_Base;\n+      typedef vector<_Tp, _Alloc>\t\t\tvector_type;\n+\n     public:\n-      typedef _Tp \t\t\t\t\t\tvalue_type;\n-      typedef value_type* \t\t\t\t\tpointer;\n-      typedef const value_type* \t\t\t\tconst_pointer;\n+      typedef _Tp\t\t\t\t\tvalue_type;\n+      typedef value_type*\t\t\t\tpointer;\n+      typedef const value_type*\t\t\t\tconst_pointer;\n       typedef __gnu_cxx::__normal_iterator<pointer, vector_type> iterator;\n       typedef __gnu_cxx::__normal_iterator<const_pointer, vector_type>\n       const_iterator;\n-      typedef std::reverse_iterator<const_iterator>    \tconst_reverse_iterator;\n-      typedef std::reverse_iterator<iterator>                reverse_iterator;\n-      typedef value_type& \t\t\t\t\treference;\n-      typedef const value_type& \t\t\t\tconst_reference;\n-      typedef size_t \t\t\t\t\tsize_type;\n-      typedef ptrdiff_t \t\t\t\t\tdifference_type;\n-      typedef typename _Base::allocator_type                allocator_type;\n-      \n+      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n+      typedef std::reverse_iterator<iterator>\t\treverse_iterator;\n+      typedef value_type&\t\t\t\treference;\n+      typedef const value_type&\t\t\t\tconst_reference;\n+      typedef size_t\t\t\t\t\tsize_type;\n+      typedef ptrdiff_t\t\t\t\t\tdifference_type;\n+      typedef typename _Base::allocator_type\t\tallocator_type;\n+\n     protected:\n       /** @if maint\n        *  These two functions and three data members are all from the\n@@ -165,7 +165,7 @@ namespace __gnu_norm\n       using _Base::_M_start;\n       using _Base::_M_finish;\n       using _Base::_M_end_of_storage;\n-      \n+\n     public:\n       // [23.2.4.1] construct/copy/destroy\n       // (assign() and get_allocator() are also listed in this section)\n@@ -175,24 +175,24 @@ namespace __gnu_norm\n       explicit\n       vector(const allocator_type& __a = allocator_type())\n       : _Base(__a) { }\n-  \n+\n       /**\n        *  @brief  Create a %vector with copies of an exemplar element.\n        *  @param  n  The number of elements to initially create.\n        *  @param  value  An element to copy.\n-       * \n+       *\n        *  This constructor fills the %vector with @a n copies of @a value.\n        */\n       vector(size_type __n, const value_type& __value,\n \t     const allocator_type& __a = allocator_type())\n       : _Base(__n, __a)\n-      { this->_M_finish = std::uninitialized_fill_n(this->_M_start, \n+      { this->_M_finish = std::uninitialized_fill_n(this->_M_start,\n \t\t\t\t\t\t    __n, __value); }\n-  \n+\n       /**\n        *  @brief  Create a %vector with default elements.\n        *  @param  n  The number of elements to initially create.\n-       * \n+       *\n        *  This constructor fills the %vector with @a n copies of a\n        *  default-constructed element.\n        */\n@@ -201,11 +201,11 @@ namespace __gnu_norm\n       : _Base(__n, allocator_type())\n       { this->_M_finish = std::uninitialized_fill_n(this->_M_start,\n \t\t\t\t\t\t    __n, value_type()); }\n-      \n+\n       /**\n        *  @brief  %Vector copy constructor.\n        *  @param  x  A %vector of identical element and allocator types.\n-       * \n+       *\n        *  The newly-created %vector uses a copy of the allocation\n        *  object used by @a x.  All the elements of @a x are copied,\n        *  but any extra memory in\n@@ -216,12 +216,12 @@ namespace __gnu_norm\n       { this->_M_finish = std::uninitialized_copy(__x.begin(), __x.end(),\n \t\t\t\t\t\t  this->_M_start);\n       }\n-  \n+\n       /**\n        *  @brief  Builds a %vector from a range.\n        *  @param  first  An input iterator.\n        *  @param  last  An input iterator.\n-       * \n+       *\n        *  Create a %vector consisting of copies of the elements from\n        *  [first,last).\n        *\n@@ -241,26 +241,26 @@ namespace __gnu_norm\n \t  typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n \t  _M_initialize_dispatch(__first, __last, _Integral());\n \t}\n-      \n+\n       /**\n        *  The dtor only erases the elements, and note that if the\n        *  elements themselves are pointers, the pointed-to memory is\n        *  not touched in any way.  Managing the pointer is the user's\n        *  responsibilty.\n        */\n       ~vector() { std::_Destroy(this->_M_start, this->_M_finish); }\n-  \n+\n       /**\n        *  @brief  %Vector assignment operator.\n        *  @param  x  A %vector of identical element and allocator types.\n-       * \n+       *\n        *  All the elements of @a x are copied, but any extra memory in\n        *  @a x (for fast expansion) will not be copied.  Unlike the\n        *  copy constructor, the allocator object is not copied.\n        */\n       vector&\n       operator=(const vector& __x);\n-  \n+\n       /**\n        *  @brief  Assigns a given value to a %vector.\n        *  @param  n  Number of elements to be assigned.\n@@ -272,9 +272,9 @@ namespace __gnu_norm\n        *  the number of elements assigned.  Old data may be lost.\n        */\n       void\n-      assign(size_type __n, const value_type& __val) \n+      assign(size_type __n, const value_type& __val)\n       { _M_fill_assign(__n, __val); }\n-  \n+\n       /**\n        *  @brief  Assigns a range to a %vector.\n        *  @param  first  An input iterator.\n@@ -295,10 +295,10 @@ namespace __gnu_norm\n \t  typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n \t  _M_assign_dispatch(__first, __last, _Integral());\n \t}\n-  \n+\n       /// Get a copy of the memory allocation object.\n       using _Base::get_allocator;\n-      \n+\n       // iterators\n       /**\n        *  Returns a read/write iterator that points to the first\n@@ -307,72 +307,72 @@ namespace __gnu_norm\n        */\n       iterator\n       begin() { return iterator (this->_M_start); }\n-      \n+\n       /**\n        *  Returns a read-only (constant) iterator that points to the\n        *  first element in the %vector.  Iteration is done in ordinary\n        *  element order.\n        */\n       const_iterator\n       begin() const { return const_iterator (this->_M_start); }\n-      \n+\n       /**\n        *  Returns a read/write iterator that points one past the last\n        *  element in the %vector.  Iteration is done in ordinary\n        *  element order.\n        */\n       iterator\n       end() { return iterator (this->_M_finish); }\n-      \n+\n       /**\n        *  Returns a read-only (constant) iterator that points one past\n        *  the last element in the %vector.  Iteration is done in\n        *  ordinary element order.\n        */\n       const_iterator\n       end() const { return const_iterator (this->_M_finish); }\n-      \n+\n       /**\n        *  Returns a read/write reverse iterator that points to the\n        *  last element in the %vector.  Iteration is done in reverse\n        *  element order.\n        */\n       reverse_iterator\n       rbegin() { return reverse_iterator(end()); }\n-      \n+\n       /**\n        *  Returns a read-only (constant) reverse iterator that points\n        *  to the last element in the %vector.  Iteration is done in\n        *  reverse element order.\n        */\n       const_reverse_iterator\n       rbegin() const { return const_reverse_iterator(end()); }\n-      \n+\n       /**\n        *  Returns a read/write reverse iterator that points to one\n        *  before the first element in the %vector.  Iteration is done\n        *  in reverse element order.\n        */\n       reverse_iterator\n       rend() { return reverse_iterator(begin()); }\n-      \n+\n       /**\n        *  Returns a read-only (constant) reverse iterator that points\n        *  to one before the first element in the %vector.  Iteration\n        *  is done in reverse element order.\n        */\n       const_reverse_iterator\n       rend() const { return const_reverse_iterator(begin()); }\n-  \n+\n       // [23.2.4.2] capacity\n       /**  Returns the number of elements in the %vector.  */\n       size_type\n       size() const { return size_type(end() - begin()); }\n-      \n+\n       /**  Returns the size() of the largest possible %vector.  */\n       size_type\n       max_size() const { return size_type(-1) / sizeof(value_type); }\n-      \n+\n       /**\n        *  @brief  Resizes the %vector to the specified number of elements.\n        *  @param  new_size  Number of elements the %vector should contain.\n@@ -392,7 +392,7 @@ namespace __gnu_norm\n \telse\n \t  insert(end(), __new_size - size(), __x);\n       }\n-      \n+\n       /**\n        *  @brief  Resizes the %vector to the specified number of elements.\n        *  @param  new_size  Number of elements the %vector should contain.\n@@ -405,22 +405,22 @@ namespace __gnu_norm\n        */\n       void\n       resize(size_type __new_size) { resize(__new_size, value_type()); }\n-      \n+\n       /**\n        *  Returns the total number of elements that the %vector can\n        *  hold before needing to allocate more memory.\n        */\n       size_type\n       capacity() const\n       { return size_type(const_iterator(this->_M_end_of_storage) - begin()); }\n-      \n+\n       /**\n        *  Returns true if the %vector is empty.  (Thus begin() would\n        *  equal end().)\n        */\n       bool\n       empty() const { return begin() == end(); }\n-      \n+\n       /**\n        *  @brief  Attempt to preallocate enough memory for specified number of\n        *          elements.\n@@ -440,7 +440,7 @@ namespace __gnu_norm\n        */\n       void\n       reserve(size_type __n);\n-      \n+\n       // element access\n       /**\n        *  @brief  Subscript access to the data contained in the %vector.\n@@ -455,7 +455,7 @@ namespace __gnu_norm\n        */\n       reference\n       operator[](size_type __n) { return *(begin() + __n); }\n-      \n+\n       /**\n        *  @brief  Subscript access to the data contained in the %vector.\n        *  @param n The index of the element for which data should be\n@@ -469,7 +469,7 @@ namespace __gnu_norm\n        */\n       const_reference\n       operator[](size_type __n) const { return *(begin() + __n); }\n-  \n+\n     protected:\n       /// @if maint Safety check used only from at().  @endif\n       void\n@@ -478,7 +478,7 @@ namespace __gnu_norm\n \tif (__n >= this->size())\n \t  __throw_out_of_range(__N(\"vector::_M_range_check\"));\n       }\n-      \n+\n     public:\n       /**\n        *  @brief  Provides access to the data contained in the %vector.\n@@ -493,7 +493,7 @@ namespace __gnu_norm\n        */\n       reference\n       at(size_type __n) { _M_range_check(__n); return (*this)[__n]; }\n-      \n+\n       /**\n        *  @brief  Provides access to the data contained in the %vector.\n        *  @param n The index of the element for which data should be\n@@ -507,35 +507,35 @@ namespace __gnu_norm\n        */\n       const_reference\n       at(size_type __n) const { _M_range_check(__n); return (*this)[__n]; }\n-      \n+\n       /**\n        *  Returns a read/write reference to the data at the first\n        *  element of the %vector.\n        */\n       reference\n       front() { return *begin(); }\n-      \n+\n       /**\n        *  Returns a read-only (constant) reference to the data at the first\n        *  element of the %vector.\n        */\n       const_reference\n       front() const { return *begin(); }\n-      \n+\n       /**\n        *  Returns a read/write reference to the data at the last\n        *  element of the %vector.\n        */\n       reference\n       back() { return *(end() - 1); }\n-      \n+\n       /**\n        *  Returns a read-only (constant) reference to the data at the\n        *  last element of the %vector.\n        */\n       const_reference\n       back() const { return *(end() - 1); }\n-  \n+\n       // [23.2.4.3] modifiers\n       /**\n        *  @brief  Add data to the end of the %vector.\n@@ -558,7 +558,7 @@ namespace __gnu_norm\n \telse\n \t  _M_insert_aux(end(), __x);\n       }\n-      \n+\n       /**\n        *  @brief  Removes last element.\n        *\n@@ -574,7 +574,7 @@ namespace __gnu_norm\n \t--this->_M_finish;\n \tstd::_Destroy(this->_M_finish);\n       }\n-      \n+\n       /**\n        *  @brief  Inserts given value into %vector before specified iterator.\n        *  @param  position  An iterator into the %vector.\n@@ -605,7 +605,7 @@ namespace __gnu_norm\n       void\n       insert(iterator __position, size_type __n, const value_type& __x)\n       { _M_fill_insert(__position, __n, __x); }\n-      \n+\n       /**\n        *  @brief  Inserts a range into the %vector.\n        *  @param  position  An iterator into the %vector.\n@@ -622,14 +622,14 @@ namespace __gnu_norm\n        */\n       template<typename _InputIterator>\n         void\n-        insert(iterator __position, _InputIterator __first, \n+        insert(iterator __position, _InputIterator __first,\n \t       _InputIterator __last)\n         {\n \t  // Check whether it's an integral type.  If so, it's not an iterator.\n \t  typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n \t  _M_insert_dispatch(__position, __first, __last, _Integral());\n \t}\n-      \n+\n       /**\n        *  @brief  Remove element at given position.\n        *  @param  position  Iterator pointing to element to be erased.\n@@ -647,7 +647,7 @@ namespace __gnu_norm\n        */\n       iterator\n       erase(iterator __position);\n-  \n+\n       /**\n        *  @brief  Remove a range of elements.\n        *  @param  first  Iterator pointing to the first element to be erased.\n@@ -668,7 +668,7 @@ namespace __gnu_norm\n        */\n       iterator\n       erase(iterator __first, iterator __last);\n-      \n+\n       /**\n        *  @brief  Swaps data with another %vector.\n        *  @param  x  A %vector of the same element and allocator types.\n@@ -685,7 +685,7 @@ namespace __gnu_norm\n \tstd::swap(this->_M_finish, __x._M_finish);\n \tstd::swap(this->_M_end_of_storage, __x._M_end_of_storage);\n       }\n-      \n+\n       /**\n        *  Erases all the elements.  Note that this function only erases the\n        *  elements, and that if the elements themselves are pointers, the\n@@ -694,7 +694,7 @@ namespace __gnu_norm\n        */\n       void\n       clear() { erase(begin(), end()); }\n-      \n+\n     protected:\n       /**\n        *  @if maint\n@@ -719,21 +719,21 @@ namespace __gnu_norm\n \t      __throw_exception_again;\n \t    }\n \t}\n-      \n-      \n+\n+\n       // Internal constructor functions follow.\n-      \n+\n       // Called by the range constructor to implement [23.1.1]/9\n       template<typename _Integer>\n         void\n         _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)\n         {\n \t  this->_M_start = _M_allocate(__n);\n \t  this->_M_end_of_storage = this->_M_start + __n;\n-\t  this->_M_finish = std::uninitialized_fill_n(this->_M_start, \n+\t  this->_M_finish = std::uninitialized_fill_n(this->_M_start,\n \t\t\t\t\t\t      __n, __value);\n \t}\n-      \n+\n       // Called by the range constructor to implement [23.1.1]/9\n       template<typename _InputIterator>\n         void\n@@ -744,7 +744,7 @@ namespace __gnu_norm\n \t    _IterCategory;\n \t  _M_range_initialize(__first, __last, _IterCategory());\n \t}\n-      \n+\n       // Called by the second initialize_dispatch above\n       template<typename _InputIterator>\n         void\n@@ -754,10 +754,10 @@ namespace __gnu_norm\n \t  for ( ; __first != __last; ++__first)\n \t    push_back(*__first);\n \t}\n-      \n+\n       // Called by the second initialize_dispatch above\n       template<typename _ForwardIterator>\n-        void \n+        void\n         _M_range_initialize(_ForwardIterator __first,\n \t\t\t    _ForwardIterator __last, forward_iterator_tag)\n         {\n@@ -767,11 +767,11 @@ namespace __gnu_norm\n \t  this->_M_finish = std::uninitialized_copy(__first, __last,\n \t\t\t\t\t\t    this->_M_start);\n \t}\n-      \n-      \n+\n+\n       // Internal assign functions follow.  The *_aux functions do the actual\n       // assignment work for the range versions.\n-      \n+\n       // Called by the range assign to implement [23.1.1]/9\n       template<typename _Integer>\n         void\n@@ -780,38 +780,38 @@ namespace __gnu_norm\n \t  _M_fill_assign(static_cast<size_type>(__n),\n \t\t\t static_cast<value_type>(__val));\n \t}\n-      \n+\n       // Called by the range assign to implement [23.1.1]/9\n       template<typename _InputIterator>\n         void\n-        _M_assign_dispatch(_InputIterator __first, _InputIterator __last, \n+        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,\n \t\t\t   __false_type)\n         {\n \t  typedef typename iterator_traits<_InputIterator>::iterator_category\n \t    _IterCategory;\n \t  _M_assign_aux(__first, __last, _IterCategory());\n \t}\n-      \n+\n       // Called by the second assign_dispatch above\n       template<typename _InputIterator>\n-        void \n+        void\n         _M_assign_aux(_InputIterator __first, _InputIterator __last,\n \t\t      input_iterator_tag);\n-  \n+\n       // Called by the second assign_dispatch above\n       template<typename _ForwardIterator>\n-        void \n+        void\n         _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n \t\t      forward_iterator_tag);\n-  \n+\n       // Called by assign(n,t), and the range assign when it turns out\n       // to be the same thing.\n       void\n       _M_fill_assign(size_type __n, const value_type& __val);\n-  \n-      \n+\n+\n       // Internal insert functions follow.\n-      \n+\n       // Called by the range insert to implement [23.1.1]/9\n       template<typename _Integer>\n         void\n@@ -821,7 +821,7 @@ namespace __gnu_norm\n \t  _M_fill_insert(__pos, static_cast<size_type>(__n),\n \t\t\t static_cast<value_type>(__val));\n \t}\n-      \n+\n       // Called by the range insert to implement [23.1.1]/9\n       template<typename _InputIterator>\n         void\n@@ -832,30 +832,30 @@ namespace __gnu_norm\n \t    _IterCategory;\n \t  _M_range_insert(__pos, __first, __last, _IterCategory());\n \t}\n-      \n+\n       // Called by the second insert_dispatch above\n       template<typename _InputIterator>\n         void\n-        _M_range_insert(iterator __pos, _InputIterator __first, \n+        _M_range_insert(iterator __pos, _InputIterator __first,\n \t\t\t_InputIterator __last, input_iterator_tag);\n-      \n+\n       // Called by the second insert_dispatch above\n       template<typename _ForwardIterator>\n         void\n-        _M_range_insert(iterator __pos, _ForwardIterator __first, \n+        _M_range_insert(iterator __pos, _ForwardIterator __first,\n \t\t\t_ForwardIterator __last, forward_iterator_tag);\n-      \n+\n       // Called by insert(p,n,x), and the range insert when it turns out to be\n       // the same thing.\n       void\n       _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);\n-      \n+\n       // Called by insert(p,x)\n       void\n       _M_insert_aux(iterator __position, const value_type& __x);\n     };\n-  \n-  \n+\n+\n   /**\n    *  @brief  Vector equality comparison.\n    *  @param  x  A %vector.\n@@ -873,7 +873,7 @@ namespace __gnu_norm\n       return __x.size() == __y.size() &&\n              std::equal(__x.begin(), __x.end(), __y.begin());\n     }\n-  \n+\n   /**\n    *  @brief  Vector ordering relation.\n    *  @param  x  A %vector.\n@@ -892,31 +892,31 @@ namespace __gnu_norm\n       return std::lexicographical_compare(__x.begin(), __x.end(),\n \t\t\t\t\t  __y.begin(), __y.end());\n     }\n-  \n+\n   /// Based on operator==\n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator!=(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)\n     { return !(__x == __y); }\n-  \n+\n   /// Based on operator<\n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator>(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)\n     { return __y < __x; }\n-  \n+\n   /// Based on operator<\n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator<=(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)\n     { return !(__y < __x); }\n-  \n+\n   /// Based on operator<\n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator>=(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)\n     { return !(__x < __y); }\n-  \n+\n   /// See std::vector::swap().\n   template<typename _Tp, typename _Alloc>\n     inline void"}, {"sha": "fa11bd6b28fb6f4920f76cb7ac9d324358582f44", "filename": "libstdc++-v3/include/bits/stream_iterator.h", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstream_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstream_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstream_iterator.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -42,9 +42,9 @@\n namespace std\n {\n   /// Provides input iterator semantics for streams.\n-  template<typename _Tp, typename _CharT = char, \n-           typename _Traits = char_traits<_CharT>, typename _Dist = ptrdiff_t> \n-    class istream_iterator \n+  template<typename _Tp, typename _CharT = char,\n+           typename _Traits = char_traits<_CharT>, typename _Dist = ptrdiff_t>\n+    class istream_iterator\n     : public iterator<input_iterator_tag, _Tp, _Dist, const _Tp*, const _Tp&>\n     {\n     public:\n@@ -53,9 +53,9 @@ namespace std\n       typedef basic_istream<_CharT, _Traits> istream_type;\n \n     private:\n-      istream_type* \t_M_stream;\n-      _Tp \t\t_M_value;\n-      bool \t\t_M_ok;\n+      istream_type*\t_M_stream;\n+      _Tp\t\t_M_value;\n+      bool\t\t_M_ok;\n \n     public:\n       ///  Construct end of input stream iterator.\n@@ -67,14 +67,14 @@ namespace std\n       : _M_stream(&__s)\n       { _M_read(); }\n \n-      istream_iterator(const istream_iterator& __obj) \n-      : _M_stream(__obj._M_stream), _M_value(__obj._M_value), \n-        _M_ok(__obj._M_ok) \n+      istream_iterator(const istream_iterator& __obj)\n+      : _M_stream(__obj._M_stream), _M_value(__obj._M_value),\n+        _M_ok(__obj._M_ok)\n       { }\n \n       const _Tp&\n-      operator*() const \n-      { \n+      operator*() const\n+      {\n \t__glibcxx_requires_cond(_M_ok,\n \t\t\t\t_M_message(__gnu_debug::__msg_deref_istream)\n \t\t\t\t._M_iterator(*this));\n@@ -84,34 +84,34 @@ namespace std\n       const _Tp*\n       operator->() const { return &(operator*()); }\n \n-      istream_iterator& \n-      operator++() \n-      { \n+      istream_iterator&\n+      operator++()\n+      {\n \t__glibcxx_requires_cond(_M_ok,\n \t\t\t\t_M_message(__gnu_debug::__msg_inc_istream)\n \t\t\t\t._M_iterator(*this));\n-\t_M_read(); \n-\treturn *this; \n+\t_M_read();\n+\treturn *this;\n       }\n \n-      istream_iterator \n-      operator++(int)  \n+      istream_iterator\n+      operator++(int)\n       {\n \t__glibcxx_requires_cond(_M_ok,\n \t\t\t\t_M_message(__gnu_debug::__msg_inc_istream)\n-\t\t\t\t._M_iterator(*this)); \n+\t\t\t\t._M_iterator(*this));\n \tistream_iterator __tmp = *this;\n \t_M_read();\n \treturn __tmp;\n       }\n \n-      bool \n+      bool\n       _M_equal(const istream_iterator& __x) const\n       { return (_M_ok == __x._M_ok) && (!_M_ok || _M_stream == __x._M_stream); }\n \n-    private:      \n-      void \n-      _M_read() \n+    private:\n+      void\n+      _M_read()\n       {\n \t_M_ok = (_M_stream && *_M_stream) ? true : false;\n \tif (_M_ok)\n@@ -121,19 +121,19 @@ namespace std\n \t  }\n       }\n     };\n-  \n+\n   ///  Return true if x and y are both end or not end, or x and y are the same.\n   template<typename _Tp, typename _CharT, typename _Traits, typename _Dist>\n-    inline bool \n+    inline bool\n     operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n-\t       const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y) \n+\t       const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)\n     { return __x._M_equal(__y); }\n \n   ///  Return false if x and y are both end or not end, or x and y are the same.\n   template <class _Tp, class _CharT, class _Traits, class _Dist>\n-    inline bool \n+    inline bool\n     operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n-\t       const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y) \n+\t       const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)\n     { return !__x._M_equal(__y); }\n \n   /**\n@@ -147,9 +147,9 @@ namespace std\n    *  @param  CharT  The ostream char_type.\n    *  @param  Traits  The ostream char_traits.\n   */\n-  template<typename _Tp, typename _CharT = char, \n+  template<typename _Tp, typename _CharT = char,\n            typename _Traits = char_traits<_CharT> >\n-    class ostream_iterator \n+    class ostream_iterator\n     : public iterator<output_iterator_tag, void, void, void, void>\n     {\n     public:\n@@ -161,8 +161,8 @@ namespace std\n       //@}\n \n     private:\n-      ostream_type* \t_M_stream;\n-      const _CharT* \t_M_string;\n+      ostream_type*\t_M_stream;\n+      const _CharT*\t_M_string;\n \n     public:\n       /// Construct from an ostream.\n@@ -178,7 +178,7 @@ namespace std\n        *  @param  s  Underlying ostream to write to.\n        *  @param  c  CharT delimiter string to insert.\n       */\n-      ostream_iterator(ostream_type& __s, const _CharT* __c) \n+      ostream_iterator(ostream_type& __s, const _CharT* __c)\n       : _M_stream(&__s), _M_string(__c)  { }\n \n       /// Copy constructor.\n@@ -187,28 +187,28 @@ namespace std\n \n       /// Writes @a value to underlying ostream using operator<<.  If\n       /// constructed with delimiter string, writes delimiter to ostream.\n-      ostream_iterator& \n-      operator=(const _Tp& __value) \n-      { \n+      ostream_iterator&\n+      operator=(const _Tp& __value)\n+      {\n \t__glibcxx_requires_cond(_M_stream != 0,\n \t\t\t\t_M_message(__gnu_debug::__msg_output_ostream)\n \t\t\t\t._M_iterator(*this));\n \t*_M_stream << __value;\n \tif (_M_string) *_M_stream << _M_string;\n \treturn *this;\n       }\n-      \n-      ostream_iterator& \n+\n+      ostream_iterator&\n       operator*()\n       { return *this; }\n-      \n-      ostream_iterator& \n+\n+      ostream_iterator&\n       operator++()\n-      { return *this; } \n-      \n-      ostream_iterator& \n+      { return *this; }\n+\n+      ostream_iterator&\n       operator++(int)\n-      { return *this; } \n+      { return *this; }\n     };\n } // namespace std\n #endif"}, {"sha": "554d06178997e1a0fb1cf29c2784041a7a2de63b", "filename": "libstdc++-v3/include/bits/streambuf.tcc", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf.tcc?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -37,7 +37,7 @@\n \n #pragma GCC system_header\n \n-namespace std \n+namespace std\n {\n   template<typename _CharT, typename _Traits>\n     streamsize\n@@ -57,10 +57,10 @@ namespace std\n \t      __s += __len;\n \t      this->gbump(__len);\n \t    }\n-\t  \n+\n \t  if (__ret < __n)\n \t    {\n-\t      const int_type __c = this->uflow();  \n+\t      const int_type __c = this->uflow();\n \t      if (!traits_type::eq_int_type(__c, traits_type::eof()))\n \t\t{\n \t\t  traits_type::assign(*__s++, traits_type::to_char_type(__c));\n@@ -114,7 +114,7 @@ namespace std\n   template<typename _CharT, typename _Traits>\n     streamsize\n     __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,\n-\t\t      basic_streambuf<_CharT, _Traits>* __sbout) \n+\t\t      basic_streambuf<_CharT, _Traits>* __sbout)\n     {\n       streamsize __ret = 0;\n       typename _Traits::int_type __c = __sbin->sgetc();\n@@ -130,7 +130,7 @@ namespace std\n \t\tbreak;\n \t      __c = __sbin->underflow();\n \t    }\n-\t  else \n+\t  else\n \t    {\n \t      __c = __sbout->sputc(_Traits::to_char_type(__c));\n \t      if (_Traits::eq_int_type(__c, _Traits::eof()))\n@@ -143,21 +143,21 @@ namespace std\n     }\n \n   // Inhibit implicit instantiations for required instantiations,\n-  // which are defined via explicit instantiations elsewhere.  \n+  // which are defined via explicit instantiations elsewhere.\n   // NB:  This syntax is a GNU extension.\n #if _GLIBCXX_EXTERN_TEMPLATE\n   extern template class basic_streambuf<char>;\n   extern template\n     streamsize\n-    __copy_streambufs(basic_streambuf<char>*, basic_streambuf<char>*); \n+    __copy_streambufs(basic_streambuf<char>*, basic_streambuf<char>*);\n \n #ifdef _GLIBCXX_USE_WCHAR_T\n   extern template class basic_streambuf<wchar_t>;\n   extern template\n     streamsize\n-    __copy_streambufs(basic_streambuf<wchar_t>*, basic_streambuf<wchar_t>*); \n+    __copy_streambufs(basic_streambuf<wchar_t>*, basic_streambuf<wchar_t>*);\n #endif\n #endif\n } // namespace std\n \n-#endif \n+#endif"}, {"sha": "970933578c734e4cc23fffc91c96a3a291dff007", "filename": "libstdc++-v3/include/bits/streambuf_iterator.h", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf_iterator.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -50,72 +50,72 @@ namespace std\n   template<typename _CharT, typename _Traits>\n     class istreambuf_iterator\n     : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,\n-    \t\t      _CharT*, _CharT&>\n+\t\t      _CharT*, _CharT&>\n     {\n     public:\n       // Types:\n       //@{\n       /// Public typedefs\n-      typedef _CharT                         \t\tchar_type;\n-      typedef _Traits                        \t\ttraits_type;\n-      typedef typename _Traits::int_type     \t\tint_type;\n-      typedef basic_streambuf<_CharT, _Traits> \t\tstreambuf_type;\n-      typedef basic_istream<_CharT, _Traits>         \tistream_type;\n+      typedef _CharT\t\t\t\t\tchar_type;\n+      typedef _Traits\t\t\t\t\ttraits_type;\n+      typedef typename _Traits::int_type\t\tint_type;\n+      typedef basic_streambuf<_CharT, _Traits>\t\tstreambuf_type;\n+      typedef basic_istream<_CharT, _Traits>\t\tistream_type;\n       //@}\n \n     private:\n-      // 24.5.3 istreambuf_iterator \n-      // p 1 \n+      // 24.5.3 istreambuf_iterator\n+      // p 1\n       // If the end of stream is reached (streambuf_type::sgetc()\n       // returns traits_type::eof()), the iterator becomes equal to\n       // the \"end of stream\" iterator value.\n       // NB: This implementation assumes the \"end of stream\" value\n       // is EOF, or -1.\n-      mutable streambuf_type* \t_M_sbuf;  \n-      int_type \t\t\t_M_c;\n+      mutable streambuf_type*\t_M_sbuf;\n+      int_type\t\t\t_M_c;\n \n     public:\n       ///  Construct end of input stream iterator.\n-      istreambuf_iterator() throw() \n+      istreambuf_iterator() throw()\n       : _M_sbuf(0), _M_c(traits_type::eof()) { }\n-      \n+\n       ///  Construct start of input stream iterator.\n       istreambuf_iterator(istream_type& __s) throw()\n       : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }\n \n       ///  Construct start of streambuf iterator.\n       istreambuf_iterator(streambuf_type* __s) throw()\n       : _M_sbuf(__s), _M_c(traits_type::eof()) { }\n-       \n+\n       ///  Return the current character pointed to by iterator.  This returns\n       ///  streambuf.sgetc().  It cannot be assigned.  NB: The result of\n       ///  operator*() on an end of stream is undefined.\n-      char_type \n+      char_type\n       operator*() const\n-      { \n+      {\n #ifdef _GLIBCXX_DEBUG_PEDANTIC\n \t// Dereferencing a past-the-end istreambuf_iterator is a\n \t// libstdc++ extension\n \t__glibcxx_requires_cond(!_M_at_eof(),\n \t\t\t\t_M_message(__gnu_debug::__msg_deref_istreambuf)\n-\t\t\t\t._M_iterator(*this)); \n+\t\t\t\t._M_iterator(*this));\n #endif\n-\treturn traits_type::to_char_type(_M_get()); \n+\treturn traits_type::to_char_type(_M_get());\n       }\n \n       /// Advance the iterator.  Calls streambuf.sbumpc().\n-      istreambuf_iterator& \n+      istreambuf_iterator&\n       operator++()\n-      { \n+      {\n \t__glibcxx_requires_cond(!_M_at_eof(),\n \t\t\t\t_M_message(__gnu_debug::__msg_inc_istreambuf)\n-\t\t\t\t._M_iterator(*this)); \n+\t\t\t\t._M_iterator(*this));\n \tconst int_type __eof = traits_type::eof();\n \tif (_M_sbuf && traits_type::eq_int_type(_M_sbuf->sbumpc(), __eof))\n \t  _M_sbuf = 0;\n \telse\n \t  _M_c = __eof;\n-\treturn *this; \n+\treturn *this;\n       }\n \n       /// Advance the iterator.  Calls streambuf.sbumpc().\n@@ -124,24 +124,24 @@ namespace std\n       {\n \t__glibcxx_requires_cond(!_M_at_eof(),\n \t\t\t\t_M_message(__gnu_debug::__msg_inc_istreambuf)\n-\t\t\t\t._M_iterator(*this)); \n+\t\t\t\t._M_iterator(*this));\n \n \tconst int_type __eof = traits_type::eof();\n \tistreambuf_iterator __old = *this;\n \tif (_M_sbuf\n-\t    && traits_type::eq_int_type((__old._M_c = _M_sbuf->sbumpc()), \n+\t    && traits_type::eq_int_type((__old._M_c = _M_sbuf->sbumpc()),\n \t\t\t\t\t__eof))\n \t  _M_sbuf = 0;\n \telse\n \t  _M_c = __eof;\n-\treturn __old; \n+\treturn __old;\n       }\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 110 istreambuf_iterator::equal not const\n       // NB: there is also number 111 (NAD, Future) pending on this function.\n       /// Return true both iterators are end or both are not end.\n-      bool \n+      bool\n       equal(const istreambuf_iterator& __b) const\n       {\n \tconst bool __thiseof = _M_at_eof();\n@@ -150,13 +150,13 @@ namespace std\n       }\n \n     private:\n-      int_type \n+      int_type\n       _M_get() const\n-      { \n+      {\n \tconst int_type __eof = traits_type::eof();\n \tint_type __ret = __eof;\n \tif (_M_sbuf)\n-\t  { \n+\t  {\n \t    if (!traits_type::eq_int_type(_M_c, __eof))\n \t      __ret = _M_c;\n \t    else if (traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),\n@@ -166,7 +166,7 @@ namespace std\n \treturn __ret;\n       }\n \n-      bool \n+      bool\n       _M_at_eof() const\n       {\n \tconst int_type __eof = traits_type::eof();\n@@ -175,13 +175,13 @@ namespace std\n     };\n \n   template<typename _CharT, typename _Traits>\n-    inline bool \n+    inline bool\n     operator==(const istreambuf_iterator<_CharT, _Traits>& __a,\n \t       const istreambuf_iterator<_CharT, _Traits>& __b)\n     { return __a.equal(__b); }\n \n   template<typename _CharT, typename _Traits>\n-    inline bool \n+    inline bool\n     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,\n \t       const istreambuf_iterator<_CharT, _Traits>& __b)\n     { return !__a.equal(__b); }\n@@ -202,49 +202,49 @@ namespace std\n       //@}\n \n     private:\n-      streambuf_type* \t_M_sbuf;\n-      bool \t\t_M_failed;\n+      streambuf_type*\t_M_sbuf;\n+      bool\t\t_M_failed;\n \n     public:\n       ///  Construct output iterator from ostream.\n       ostreambuf_iterator(ostream_type& __s) throw ()\n       : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }\n-      \n+\n       ///  Construct output iterator from streambuf.\n       ostreambuf_iterator(streambuf_type* __s) throw ()\n       : _M_sbuf(__s), _M_failed(!_M_sbuf) { }\n \n       ///  Write character to streambuf.  Calls streambuf.sputc().\n-      ostreambuf_iterator& \n+      ostreambuf_iterator&\n       operator=(_CharT __c)\n       {\n-\tif (!_M_failed && \n+\tif (!_M_failed &&\n \t    _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))\n \t  _M_failed = true;\n \treturn *this;\n       }\n \n       /// Return *this.\n-      ostreambuf_iterator& \n+      ostreambuf_iterator&\n       operator*()\n       { return *this; }\n \n       /// Return *this.\n-      ostreambuf_iterator& \n+      ostreambuf_iterator&\n       operator++(int)\n       { return *this; }\n \n       /// Return *this.\n-      ostreambuf_iterator& \n+      ostreambuf_iterator&\n       operator++()\n       { return *this; }\n \n       /// Return true if previous operator=() failed.\n-      bool \n+      bool\n       failed() const throw()\n       { return _M_failed; }\n \n-      ostreambuf_iterator& \n+      ostreambuf_iterator&\n       _M_put(const _CharT* __ws, streamsize __len)\n       {\n \tif (__builtin_expect(!_M_failed, true)"}, {"sha": "99d3ce3a534eee4244e3ca4cf73daddc707c7c33", "filename": "libstdc++-v3/include/bits/stringfwd.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstringfwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstringfwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstringfwd.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -45,16 +45,16 @@\n \n namespace std\n {\n-  template<typename _Alloc> \n+  template<typename _Alloc>\n     class allocator;\n \n   template<class _CharT>\n     struct char_traits;\n \n-  template<typename _CharT, typename _Traits = char_traits<_CharT>, \n+  template<typename _CharT, typename _Traits = char_traits<_CharT>,\n            typename _Alloc = allocator<_CharT> >\n     class basic_string;\n-  \n+\n   template<> struct char_traits<char>;\n \n   typedef basic_string<char>    string;"}, {"sha": "9b91e5c5cdf0320cecb241c57be6b359534c662b", "filename": "libstdc++-v3/include/bits/type_traits.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ftype_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ftype_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ftype_traits.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077", "patch": "@@ -74,10 +74,10 @@ attain their correct values by one of these means:\n EXAMPLE:\n \n //Copy an array of elements which have non-trivial copy constructors\n-template <class _Tp> void \n+template <class _Tp> void\n   copy(_Tp* __source,_Tp* __destination,int __n,__false_type);\n //Copy an array of elements which have trivial copy constructors. Use memcpy.\n-template <class _Tp> void \n+template <class _Tp> void\n   copy(_Tp* __source,_Tp* __destination,int __n,__true_type);\n \n //Copy an array of any type by using the most efficient copy mechanism\n@@ -92,7 +92,7 @@ struct __false_type {};\n \n template <class _Tp>\n   struct __type_traits\n-  { \n+  {\n     typedef __true_type     this_dummy_member_must_be_first;\n     /* Do not remove this member. It informs a compiler which\n        automatically specializes __type_traits that this\n@@ -101,15 +101,15 @@ template <class _Tp>\n        called __type_traits for something unrelated. */\n \n    /* The following restrictions should be observed for the sake of\n-      compilers which automatically produce type specific specializations \n+      compilers which automatically produce type specific specializations\n       of this class:\n           - You may reorder the members below if you wish\n           - You may remove any of the members below if you wish\n           - You must not rename members without making the corresponding\n             name change in the compiler\n           - Members you add will be treated like regular members unless\n             you add the appropriate support in the compiler. */\n- \n+\n \n     typedef __false_type    has_trivial_default_constructor;\n     typedef __false_type    has_trivial_copy_constructor;\n@@ -291,7 +291,7 @@ template <class _Tp>\n     typedef __true_type    is_POD_type;\n   };\n \n-// The following could be written in terms of numeric_limits.  \n+// The following could be written in terms of numeric_limits.\n // We're doing it separately to reduce the number of dependencies.\n \n template <class _Tp>"}, {"sha": "b74cab5dbac3645f04c73708a347ca5ad0b28b32", "filename": "libstdc++-v3/include/bits/valarray_after.h", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_after.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_after.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_after.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077"}, {"sha": "e18e8e8e9e8190dfe6e0df4aabf231aa10adc538", "filename": "libstdc++-v3/include/bits/valarray_array.h", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_array.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077"}, {"sha": "cf660346472eef95230b608f72021fe79e46461d", "filename": "libstdc++-v3/include/bits/valarray_array.tcc", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_array.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_array.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_array.tcc?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077"}, {"sha": "263ac2f0e22518bd45897a881eddfa5ffea959aa", "filename": "libstdc++-v3/include/bits/valarray_before.h", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_before.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_before.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_before.h?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077"}, {"sha": "207367cf59f205cae43bcca5d6625b224ddf57bc", "filename": "libstdc++-v3/include/bits/vector.tcc", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6814f7b30925bf4a019009a963bd46fd6a7077/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc?ref=ed6814f7b30925bf4a019009a963bd46fd6a7077"}]}