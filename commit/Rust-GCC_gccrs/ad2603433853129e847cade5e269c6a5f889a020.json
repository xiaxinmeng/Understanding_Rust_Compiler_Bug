{"sha": "ad2603433853129e847cade5e269c6a5f889a020", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQyNjAzNDMzODUzMTI5ZTg0N2NhZGU1ZTI2OWM2YTVmODg5YTAyMA==", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2021-01-15T18:50:27Z"}, "committer": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2021-01-15T18:50:27Z"}, "message": "AArch64: Add NEON, SVE and SVE2 RTL patterns for Multiply, FMS and FMA.\n\nThis adds implementation for the optabs for complex operations.  With this the\nfollowing C code:\n\n  void g (float complex a[restrict N], float complex b[restrict N],\n\t  float complex c[restrict N])\n  {\n    for (int i=0; i < N; i++)\n      c[i] =  a[i] * b[i];\n  }\n\ngenerates\n\nNEON:\n\ng:\n        movi    v3.4s, 0\n        mov     x3, 0\n        .p2align 3,,7\n.L2:\n        mov     v0.16b, v3.16b\n        ldr     q2, [x1, x3]\n        ldr     q1, [x0, x3]\n        fcmla   v0.4s, v1.4s, v2.4s, #0\n        fcmla   v0.4s, v1.4s, v2.4s, #90\n        str     q0, [x2, x3]\n        add     x3, x3, 16\n        cmp     x3, 1600\n        bne     .L2\n        ret\n\nSVE:\n\ng:\n        mov     x3, 0\n        mov     x4, 400\n        ptrue   p1.b, all\n        whilelo p0.s, xzr, x4\n        mov     z3.s, #0\n        .p2align 3,,7\n.L2:\n        ld1w    z1.s, p0/z, [x0, x3, lsl 2]\n        ld1w    z2.s, p0/z, [x1, x3, lsl 2]\n        movprfx z0, z3\n        fcmla   z0.s, p1/m, z1.s, z2.s, #0\n        fcmla   z0.s, p1/m, z1.s, z2.s, #90\n        st1w    z0.s, p0, [x2, x3, lsl 2]\n        incw    x3\n        whilelo p0.s, x3, x4\n        b.any   .L2\n        ret\n\nSVE2 (with int instead of float)\ng:\n        mov     x3, 0\n        mov     x4, 400\n        mov     z3.b, #0\n        whilelo p0.s, xzr, x4\n        .p2align 3,,7\n.L2:\n        ld1w    z1.s, p0/z, [x0, x3, lsl 2]\n        ld1w    z2.s, p0/z, [x1, x3, lsl 2]\n        movprfx z0, z3\n        cmla    z0.s, z1.s, z2.s, #0\n        cmla    z0.s, z1.s, z2.s, #90\n        st1w    z0.s, p0, [x2, x3, lsl 2]\n        incw    x3\n        whilelo p0.s, x3, x4\n        b.any   .L2\n        ret\n\ngcc/ChangeLog:\n\n\t* config/aarch64/aarch64-simd.md (cml<fcmac1><conj_op><mode>4,\n\tcmul<conj_op><mode>3): New.\n\t* config/aarch64/iterators.md (UNSPEC_FCMUL,\n\tUNSPEC_FCMUL180, UNSPEC_FCMLA_CONJ, UNSPEC_FCMLA180_CONJ,\n\tUNSPEC_CMLA_CONJ, UNSPEC_CMLA180_CONJ, UNSPEC_CMUL, UNSPEC_CMUL180,\n\tFCMLA_OP, FCMUL_OP, conj_op, rotsplit1, rotsplit2, fcmac1, sve_rot1,\n\tsve_rot2, SVE2_INT_CMLA_OP, SVE2_INT_CMUL_OP, SVE2_INT_CADD_OP): New.\n\t(rot): Add UNSPEC_FCMUL, UNSPEC_FCMUL180.\n\t(rot_op): Renamed to conj_op.\n\t* config/aarch64/aarch64-sve.md (cml<fcmac1><conj_op><mode>4,\n\tcmul<conj_op><mode>3): New.\n\t* config/aarch64/aarch64-sve2.md (cml<fcmac1><conj_op><mode>4,\n\tcmul<conj_op><mode>3): New.", "tree": {"sha": "ed2c071757a1da01b9b99b29fed0a2355d22ca70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed2c071757a1da01b9b99b29fed0a2355d22ca70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad2603433853129e847cade5e269c6a5f889a020", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad2603433853129e847cade5e269c6a5f889a020", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad2603433853129e847cade5e269c6a5f889a020", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad2603433853129e847cade5e269c6a5f889a020/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd09079cfd50d289cbb05eadb728a0713f6bae8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd09079cfd50d289cbb05eadb728a0713f6bae8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd09079cfd50d289cbb05eadb728a0713f6bae8a"}], "stats": {"total": 245, "additions": 242, "deletions": 3}, "files": [{"sha": "41071b668fd0982f55f9e48510403b9f50fe0f60", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2603433853129e847cade5e269c6a5f889a020/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2603433853129e847cade5e269c6a5f889a020/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=ad2603433853129e847cade5e269c6a5f889a020", "patch": "@@ -516,6 +516,44 @@\n   [(set_attr \"type\" \"neon_fcmla\")]\n )\n \n+;; The complex mla/mls operations always need to expand to two instructions.\n+;; The first operation does half the computation and the second does the\n+;; remainder.  Because of this, expand early.\n+(define_expand \"cml<fcmac1><conj_op><mode>4\"\n+  [(set (match_operand:VHSDF 0 \"register_operand\")\n+\t(plus:VHSDF (match_operand:VHSDF 1 \"register_operand\")\n+\t\t    (unspec:VHSDF [(match_operand:VHSDF 2 \"register_operand\")\n+\t\t\t\t   (match_operand:VHSDF 3 \"register_operand\")]\n+\t\t\t\t   FCMLA_OP)))]\n+  \"TARGET_COMPLEX && !BYTES_BIG_ENDIAN\"\n+{\n+  rtx tmp = gen_reg_rtx (<MODE>mode);\n+  emit_insn (gen_aarch64_fcmla<rotsplit1><mode> (tmp, operands[1],\n+\t\t\t\t\t\t operands[3], operands[2]));\n+  emit_insn (gen_aarch64_fcmla<rotsplit2><mode> (operands[0], tmp,\n+\t\t\t\t\t\t operands[3], operands[2]));\n+  DONE;\n+})\n+\n+;; The complex mul operations always need to expand to two instructions.\n+;; The first operation does half the computation and the second does the\n+;; remainder.  Because of this, expand early.\n+(define_expand \"cmul<conj_op><mode>3\"\n+  [(set (match_operand:VHSDF 0 \"register_operand\")\n+\t(unspec:VHSDF [(match_operand:VHSDF 1 \"register_operand\")\n+\t\t       (match_operand:VHSDF 2 \"register_operand\")]\n+\t\t       FCMUL_OP))]\n+  \"TARGET_COMPLEX && !BYTES_BIG_ENDIAN\"\n+{\n+  rtx tmp = force_reg (<MODE>mode, CONST0_RTX (<MODE>mode));\n+  rtx res1 = gen_reg_rtx (<MODE>mode);\n+  emit_insn (gen_aarch64_fcmla<rotsplit1><mode> (res1, tmp,\n+\t\t\t\t\t\t operands[2], operands[1]));\n+  emit_insn (gen_aarch64_fcmla<rotsplit2><mode> (operands[0], res1,\n+\t\t\t\t\t\t operands[2], operands[1]));\n+  DONE;\n+})\n+\n ;; These instructions map to the __builtins for the Dot Product operations.\n (define_insn \"aarch64_<sur>dot<vsi2qi>\"\n   [(set (match_operand:VS 0 \"register_operand\" \"=w\")"}, {"sha": "608319600318974b414e47285ee1474b041f0e05", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2603433853129e847cade5e269c6a5f889a020/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2603433853129e847cade5e269c6a5f889a020/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=ad2603433853129e847cade5e269c6a5f889a020", "patch": "@@ -7243,6 +7243,62 @@\n   [(set_attr \"movprfx\" \"*,yes\")]\n )\n \n+;; unpredicated optab pattern for auto-vectorizer\n+;; The complex mla/mls operations always need to expand to two instructions.\n+;; The first operation does half the computation and the second does the\n+;; remainder.  Because of this, expand early.\n+(define_expand \"cml<fcmac1><conj_op><mode>4\"\n+  [(set (match_operand:SVE_FULL_F 0 \"register_operand\")\n+\t(unspec:SVE_FULL_F\n+\t  [(match_dup 4)\n+\t   (match_dup 5)\n+\t   (match_operand:SVE_FULL_F 1 \"register_operand\")\n+\t   (match_operand:SVE_FULL_F 2 \"register_operand\")\n+\t   (match_operand:SVE_FULL_F 3 \"register_operand\")]\n+\t  FCMLA_OP))]\n+  \"TARGET_SVE\"\n+{\n+  operands[4] = aarch64_ptrue_reg (<VPRED>mode);\n+  operands[5] = gen_int_mode (SVE_RELAXED_GP, SImode);\n+  rtx tmp = gen_reg_rtx (<MODE>mode);\n+  emit_insn\n+    (gen_aarch64_pred_fcmla<sve_rot1><mode> (tmp, operands[4],\n+\t\t\t\t\t     operands[3], operands[2],\n+\t\t\t\t\t     operands[1], operands[5]));\n+  emit_insn\n+    (gen_aarch64_pred_fcmla<sve_rot2><mode> (operands[0], operands[4],\n+\t\t\t\t\t     operands[3], operands[2],\n+\t\t\t\t\t     tmp, operands[5]));\n+  DONE;\n+})\n+\n+;; unpredicated optab pattern for auto-vectorizer\n+;; The complex mul operations always need to expand to two instructions.\n+;; The first operation does half the computation and the second does the\n+;; remainder.  Because of this, expand early.\n+(define_expand \"cmul<conj_op><mode>3\"\n+  [(set (match_operand:SVE_FULL_F 0 \"register_operand\")\n+\t(unspec:SVE_FULL_F\n+\t   [(match_operand:SVE_FULL_F 1 \"register_operand\")\n+\t    (match_operand:SVE_FULL_F 2 \"register_operand\")]\n+\t  FCMUL_OP))]\n+  \"TARGET_SVE\"\n+{\n+  rtx pred_reg = aarch64_ptrue_reg (<VPRED>mode);\n+  rtx gp_mode = gen_int_mode (SVE_RELAXED_GP, SImode);\n+  rtx accum = force_reg (<MODE>mode, CONST0_RTX (<MODE>mode));\n+  rtx tmp = gen_reg_rtx (<MODE>mode);\n+  emit_insn\n+    (gen_aarch64_pred_fcmla<sve_rot1><mode> (tmp, pred_reg,\n+\t\t\t\t\t     operands[2], operands[1],\n+\t\t\t\t\t     accum, gp_mode));\n+  emit_insn\n+    (gen_aarch64_pred_fcmla<sve_rot2><mode> (operands[0], pred_reg,\n+\t\t\t\t\t     operands[2], operands[1],\n+\t\t\t\t\t     tmp, gp_mode));\n+  DONE;\n+})\n+\n ;; Predicated FCMLA with merging.\n (define_expand \"@cond_<optab><mode>\"\n   [(set (match_operand:SVE_FULL_F 0 \"register_operand\")"}, {"sha": "e7cd2b86d25f9a74dada4321aec22439dd07ae19", "filename": "gcc/config/aarch64/aarch64-sve2.md", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2603433853129e847cade5e269c6a5f889a020/gcc%2Fconfig%2Faarch64%2Faarch64-sve2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2603433853129e847cade5e269c6a5f889a020/gcc%2Fconfig%2Faarch64%2Faarch64-sve2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve2.md?ref=ad2603433853129e847cade5e269c6a5f889a020", "patch": "@@ -1848,6 +1848,48 @@\n   [(set_attr \"movprfx\" \"*,yes\")]\n )\n \n+;; unpredicated optab pattern for auto-vectorizer\n+;; The complex mla/mls operations always need to expand to two instructions.\n+;; The first operation does half the computation and the second does the\n+;; remainder.  Because of this, expand early.\n+(define_expand \"cml<fcmac1><conj_op><mode>4\"\n+  [(set (match_operand:SVE_FULL_I 0 \"register_operand\")\n+\t(plus:SVE_FULL_I (match_operand:SVE_FULL_I 1 \"register_operand\")\n+\t  (unspec:SVE_FULL_I\n+\t    [(match_operand:SVE_FULL_I 2 \"register_operand\")\n+\t     (match_operand:SVE_FULL_I 3 \"register_operand\")]\n+\t    SVE2_INT_CMLA_OP)))]\n+  \"TARGET_SVE2\"\n+{\n+  rtx tmp = gen_reg_rtx (<MODE>mode);\n+  emit_insn (gen_aarch64_sve_cmla<sve_rot1><mode> (tmp, operands[1],\n+\t\t\t\t\t\t   operands[3], operands[2]));\n+  emit_insn (gen_aarch64_sve_cmla<sve_rot2><mode> (operands[0], tmp,\n+\t\t\t\t\t\t   operands[3], operands[2]));\n+  DONE;\n+})\n+\n+;; unpredicated optab pattern for auto-vectorizer\n+;; The complex mul operations always need to expand to two instructions.\n+;; The first operation does half the computation and the second does the\n+;; remainder.  Because of this, expand early.\n+(define_expand \"cmul<conj_op><mode>3\"\n+  [(set (match_operand:SVE_FULL_I 0 \"register_operand\")\n+\t(unspec:SVE_FULL_I\n+\t  [(match_operand:SVE_FULL_I 1 \"register_operand\")\n+\t   (match_operand:SVE_FULL_I 2 \"register_operand\")]\n+\t  SVE2_INT_CMUL_OP))]\n+  \"TARGET_SVE2\"\n+{\n+  rtx accum = force_reg (<MODE>mode, CONST0_RTX (<MODE>mode));\n+  rtx tmp = gen_reg_rtx (<MODE>mode);\n+  emit_insn (gen_aarch64_sve_cmla<sve_rot1><mode> (tmp, accum,\n+\t\t\t\t\t\t   operands[2], operands[1]));\n+  emit_insn (gen_aarch64_sve_cmla<sve_rot2><mode> (operands[0], tmp,\n+\t\t\t\t\t\t   operands[2], operands[1]));\n+  DONE;\n+})\n+\n ;; -------------------------------------------------------------------------\n ;; ---- [INT] Complex dot product\n ;; -------------------------------------------------------------------------"}, {"sha": "b64d77037af7345b2664362be34119eddc14ad93", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 106, "deletions": 3, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad2603433853129e847cade5e269c6a5f889a020/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad2603433853129e847cade5e269c6a5f889a020/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=ad2603433853129e847cade5e269c6a5f889a020", "patch": "@@ -712,6 +712,10 @@\n     UNSPEC_FCMLA90\t; Used in aarch64-simd.md.\n     UNSPEC_FCMLA180\t; Used in aarch64-simd.md.\n     UNSPEC_FCMLA270\t; Used in aarch64-simd.md.\n+    UNSPEC_FCMUL\t; Used in aarch64-simd.md.\n+    UNSPEC_FCMUL_CONJ\t; Used in aarch64-simd.md.\n+    UNSPEC_FCMLA_CONJ\t; Used in aarch64-simd.md.\n+    UNSPEC_FCMLA180_CONJ\t; Used in aarch64-simd.md.\n     UNSPEC_ASRD\t\t; Used in aarch64-sve.md.\n     UNSPEC_ADCLB\t; Used in aarch64-sve2.md.\n     UNSPEC_ADCLT\t; Used in aarch64-sve2.md.\n@@ -730,6 +734,10 @@\n     UNSPEC_CMLA180\t; Used in aarch64-sve2.md.\n     UNSPEC_CMLA270\t; Used in aarch64-sve2.md.\n     UNSPEC_CMLA90\t; Used in aarch64-sve2.md.\n+    UNSPEC_CMLA_CONJ\t; Used in aarch64-sve2.md.\n+    UNSPEC_CMLA180_CONJ\t; Used in aarch64-sve2.md.\n+    UNSPEC_CMUL\t\t; Used in aarch64-sve2.md.\n+    UNSPEC_CMUL_CONJ\t; Used in aarch64-sve2.md.\n     UNSPEC_COND_FCVTLT\t; Used in aarch64-sve2.md.\n     UNSPEC_COND_FCVTNT\t; Used in aarch64-sve2.md.\n     UNSPEC_COND_FCVTX\t; Used in aarch64-sve2.md.\n@@ -1291,7 +1299,7 @@\n \n ;; Widened mode register suffixes for VD_BHSI/VQW/VQ_HSF.\n (define_mode_attr Vwtype [(V8QI \"8h\") (V4HI \"4s\")\n-\t\t\t  (V2SI \"2d\") (V16QI \"8h\") \n+\t\t\t  (V2SI \"2d\") (V16QI \"8h\")\n \t\t\t  (V8HI \"4s\") (V4SI \"2d\")\n \t\t\t  (V8HF \"4s\") (V4SF \"2d\")])\n \n@@ -1313,7 +1321,7 @@\n \n ;; Widened mode register suffixes for VDW/VQW.\n (define_mode_attr Vmwtype [(V8QI \".8h\") (V4HI \".4s\")\n-\t\t\t   (V2SI \".2d\") (V16QI \".8h\") \n+\t\t\t   (V2SI \".2d\") (V16QI \".8h\")\n \t\t\t   (V8HI \".4s\") (V4SI \".2d\")\n \t\t\t   (V4HF \".4s\") (V2SF \".2d\")\n \t\t\t   (SI   \"\")    (HI   \"\")])\n@@ -2611,6 +2619,20 @@\n \t\t\t\t    UNSPEC_SQRDCMLAH180\n \t\t\t\t    UNSPEC_SQRDCMLAH270])\n \n+;; Unlike the normal CMLA instructions these represent the actual operation\n+;; to be performed.  They will always need to be expanded into multiple\n+;; sequences consisting of CMLA.\n+(define_int_iterator SVE2_INT_CMLA_OP [UNSPEC_CMLA\n+\t\t\t\t       UNSPEC_CMLA_CONJ\n+\t\t\t\t       UNSPEC_CMLA180\n+\t\t\t\t       UNSPEC_CMLA180_CONJ])\n+\n+;; Unlike the normal CMLA instructions these represent the actual operation\n+;; to be performed.  They will always need to be expanded into multiple\n+;; sequences consisting of CMLA.\n+(define_int_iterator SVE2_INT_CMUL_OP [UNSPEC_CMUL\n+\t\t\t\t       UNSPEC_CMUL_CONJ])\n+\n ;; Same as SVE2_INT_CADD but exclude the saturating instructions\n (define_int_iterator SVE2_INT_CADD_OP [UNSPEC_CADD90\n \t\t\t\t       UNSPEC_CADD270])\n@@ -2725,6 +2747,14 @@\n (define_int_iterator BF_MLA [UNSPEC_BFMLALB\n \t\t\t     UNSPEC_BFMLALT])\n \n+(define_int_iterator FCMLA_OP [UNSPEC_FCMLA\n+\t\t\t       UNSPEC_FCMLA180\n+\t\t\t       UNSPEC_FCMLA_CONJ\n+\t\t\t       UNSPEC_FCMLA180_CONJ])\n+\n+(define_int_iterator FCMUL_OP [UNSPEC_FCMUL\n+\t\t\t       UNSPEC_FCMUL_CONJ])\n+\n ;; Iterators for atomic operations.\n \n (define_int_iterator ATOMIC_LDOP\n@@ -3435,7 +3465,80 @@\n \t\t      (UNSPEC_COND_FCMLA \"0\")\n \t\t      (UNSPEC_COND_FCMLA90 \"90\")\n \t\t      (UNSPEC_COND_FCMLA180 \"180\")\n-\t\t      (UNSPEC_COND_FCMLA270 \"270\")])\n+\t\t      (UNSPEC_COND_FCMLA270 \"270\")\n+\t\t      (UNSPEC_FCMUL \"0\")\n+\t\t      (UNSPEC_FCMUL_CONJ \"180\")])\n+\n+;; A conjucate is a negation of the imaginary component\n+;; The number in the unspecs are the rotation component of the instruction, e.g\n+;; FCMLA180 means use the instruction with #180.\n+;; The iterator is used to produce the right name mangling for the function.\n+(define_int_attr conj_op [(UNSPEC_FCMLA180 \"\")\n+\t\t\t  (UNSPEC_FCMLA180_CONJ \"_conj\")\n+\t\t\t  (UNSPEC_FCMLA \"\")\n+\t\t\t  (UNSPEC_FCMLA_CONJ \"_conj\")\n+\t\t\t  (UNSPEC_FCMUL \"\")\n+\t\t\t  (UNSPEC_FCMUL_CONJ \"_conj\")\n+\t\t\t  (UNSPEC_CMLA \"\")\n+\t\t\t  (UNSPEC_CMLA180 \"\")\n+\t\t\t  (UNSPEC_CMLA180_CONJ \"_conj\")\n+\t\t\t  (UNSPEC_CMLA_CONJ \"_conj\")\n+\t\t\t  (UNSPEC_CMUL \"\")\n+\t\t\t  (UNSPEC_CMUL_CONJ \"_conj\")])\n+\n+;; The complex operations when performed on a real complex number require two\n+;; instructions to perform the operation. e.g. complex multiplication requires\n+;; two FCMUL with a particular rotation value.\n+;;\n+;; These values can be looked up in rotsplit1 and rotsplit2.  as an example\n+;; FCMUL needs the first instruction to use #0 and the second #90.\n+(define_int_attr rotsplit1 [(UNSPEC_FCMLA \"0\")\n+\t\t\t    (UNSPEC_FCMLA_CONJ \"0\")\n+\t\t\t    (UNSPEC_FCMUL \"0\")\n+\t\t\t    (UNSPEC_FCMUL_CONJ \"0\")\n+\t\t\t    (UNSPEC_FCMLA180 \"180\")\n+\t\t\t    (UNSPEC_FCMLA180_CONJ \"180\")])\n+\n+(define_int_attr rotsplit2 [(UNSPEC_FCMLA \"90\")\n+\t\t\t    (UNSPEC_FCMLA_CONJ \"270\")\n+\t\t\t    (UNSPEC_FCMUL \"90\")\n+\t\t\t    (UNSPEC_FCMUL_CONJ \"270\")\n+\t\t\t    (UNSPEC_FCMLA180 \"270\")\n+\t\t\t    (UNSPEC_FCMLA180_CONJ \"90\")])\n+\n+;; SVE has slightly different namings from NEON so we have to split these\n+;; iterators.\n+(define_int_attr sve_rot1 [(UNSPEC_FCMLA \"\")\n+\t\t\t   (UNSPEC_FCMLA_CONJ \"\")\n+\t\t\t   (UNSPEC_FCMUL \"\")\n+\t\t\t   (UNSPEC_FCMUL_CONJ \"\")\n+\t\t\t   (UNSPEC_FCMLA180 \"180\")\n+\t\t\t   (UNSPEC_FCMLA180_CONJ \"180\")\n+\t\t\t   (UNSPEC_CMLA \"\")\n+\t\t\t   (UNSPEC_CMLA_CONJ \"\")\n+\t\t\t   (UNSPEC_CMUL \"\")\n+\t\t\t   (UNSPEC_CMUL_CONJ \"\")\n+\t\t\t   (UNSPEC_CMLA180 \"180\")\n+\t\t\t   (UNSPEC_CMLA180_CONJ \"180\")])\n+\n+(define_int_attr sve_rot2 [(UNSPEC_FCMLA \"90\")\n+\t\t\t   (UNSPEC_FCMLA_CONJ \"270\")\n+\t\t\t   (UNSPEC_FCMUL \"90\")\n+\t\t\t   (UNSPEC_FCMUL_CONJ \"270\")\n+\t\t\t   (UNSPEC_FCMLA180 \"270\")\n+\t\t\t   (UNSPEC_FCMLA180_CONJ \"90\")\n+\t\t\t   (UNSPEC_CMLA \"90\")\n+\t\t\t   (UNSPEC_CMLA_CONJ \"270\")\n+\t\t\t   (UNSPEC_CMUL \"90\")\n+\t\t\t   (UNSPEC_CMUL_CONJ \"270\")\n+\t\t\t   (UNSPEC_CMLA180 \"270\")\n+\t\t\t   (UNSPEC_CMLA180_CONJ \"90\")])\n+\n+\n+(define_int_attr fcmac1 [(UNSPEC_FCMLA \"a\") (UNSPEC_FCMLA_CONJ \"a\")\n+\t\t\t (UNSPEC_FCMLA180 \"s\") (UNSPEC_FCMLA180_CONJ \"s\")\n+\t\t\t (UNSPEC_CMLA \"a\") (UNSPEC_CMLA_CONJ \"a\")\n+\t\t\t (UNSPEC_CMLA180 \"s\") (UNSPEC_CMLA180_CONJ \"s\")])\n \n (define_int_attr sve_fmla_op [(UNSPEC_COND_FMLA \"fmla\")\n \t\t\t      (UNSPEC_COND_FMLS \"fmls\")"}]}