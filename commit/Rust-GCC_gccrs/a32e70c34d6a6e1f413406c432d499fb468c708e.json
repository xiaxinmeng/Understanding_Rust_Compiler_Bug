{"sha": "a32e70c34d6a6e1f413406c432d499fb468c708e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTMyZTcwYzM0ZDZhNmUxZjQxMzQwNmM0MzJkNDk5ZmI0NjhjNzA4ZQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-07-08T17:40:22Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-07-08T17:40:22Z"}, "message": "builtins.c (fold_builtin_strcpy): Merge functionality from simplify_builtin_strcpy.\n\n\n\t* builtins.c (fold_builtin_strcpy): Merge functionality from\n\tsimplify_builtin_strcpy.  Add additional len argument.  No longer\n\tstatic.  Remove function prototype.\n\t(fold_builtin_strncpy): Likewise integrate functionality from\n\tsimplify_builtin_strncpy.  Add additional slen argument.  No\n\tlonger static.  Remove function prototype.\n\t(simplify_builtin_strcy, simplify_builtin_strncpy): Delete.\n\t(simplify_builtin_fputs): Rename to fold_builtin_fputs.  Change\n\ttypes of \"ignore\" and \"unlocked\" parameters to bool.\n\t(fold_builtin_1):  Add additional ignore argument.  Call renamed\n\tfold_builtin_fputs to simplify GCC \"fputs\" and \"fputs_unlocked\"\n\tbuiltins.  Update arguments to fold_builtin_strncpy and\n\tfold_builtin_strcpy.  Add function prototype.\n\t(fold_builtin): Add additional Boolean ignore argument to pass\n\tto fold_builtin_1.\n\t(simplify_builtin): Call fold_builtin_fputs, fold_builtin_strcpy\n\tand fold_builtin_strncpy instead of simplify_builtin_fputs,\n\tsimplify_builtin_strcpy and simplify_builtin_strncpy respectively.\n\n\t* expr.h (simplify_builtin_fputs, simplify_builtin_strcpy,\n\tsimplify_builtin_strncpy): Delete function prototypes.\n\t* tree.h (fold_builtin_fputs, fold_builtin_strcpy,\n\tfold_builtin_strncpy): Add function prototypes here.\n\t(fold_builtin): Update function prototype with new \"bool ignore\".\n\n\t* tree-ssa-ccp.c (ccp_fold): Update call to fold_builtin.\n\t(ccp_fold_builtin):  Update call to fold_builtin.  Call\n\tfold_builtin_fputs, fold_builtin_strcpy and fold_builtin_strncpy\n\tinstead of simplify_builtin_fputs, simplify_builtin_strcpy and\n\tsimplify_builtin_strncpy respectively.\n\t* fold-const.c (fold): Update call to fold_builtin.\n\nFrom-SVN: r84302", "tree": {"sha": "39e4ab0ff10a947c37ee4abcbe91d60592309b6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39e4ab0ff10a947c37ee4abcbe91d60592309b6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a32e70c34d6a6e1f413406c432d499fb468c708e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a32e70c34d6a6e1f413406c432d499fb468c708e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a32e70c34d6a6e1f413406c432d499fb468c708e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a32e70c34d6a6e1f413406c432d499fb468c708e/comments", "author": null, "committer": null, "parents": [{"sha": "ad4319ec12a27512566edfe9364ea59f63d397bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad4319ec12a27512566edfe9364ea59f63d397bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad4319ec12a27512566edfe9364ea59f63d397bc"}], "stats": {"total": 371, "additions": 168, "deletions": 203}, "files": [{"sha": "3ca80b4f07f53f8109d6b2aca88112d6b38f7dae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32e70c34d6a6e1f413406c432d499fb468c708e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32e70c34d6a6e1f413406c432d499fb468c708e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a32e70c34d6a6e1f413406c432d499fb468c708e", "patch": "@@ -1,3 +1,37 @@\n+2004-07-08  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* builtins.c (fold_builtin_strcpy): Merge functionality from\n+\tsimplify_builtin_strcpy.  Add additional len argument.  No longer\n+\tstatic.  Remove function prototype.\n+\t(fold_builtin_strncpy): Likewise integrate functionality from\n+\tsimplify_builtin_strncpy.  Add additional slen argument.  No\n+\tlonger static.  Remove function prototype.\n+\t(simplify_builtin_strcy, simplify_builtin_strncpy): Delete.\n+\t(simplify_builtin_fputs): Rename to fold_builtin_fputs.  Change\n+\ttypes of \"ignore\" and \"unlocked\" parameters to bool.\n+\t(fold_builtin_1):  Add additional ignore argument.  Call renamed\n+\tfold_builtin_fputs to simplify GCC \"fputs\" and \"fputs_unlocked\"\n+\tbuiltins.  Update arguments to fold_builtin_strncpy and\n+\tfold_builtin_strcpy.  Add function prototype.\n+\t(fold_builtin): Add additional Boolean ignore argument to pass\n+\tto fold_builtin_1.\n+\t(simplify_builtin): Call fold_builtin_fputs, fold_builtin_strcpy\n+\tand fold_builtin_strncpy instead of simplify_builtin_fputs,\n+\tsimplify_builtin_strcpy and simplify_builtin_strncpy respectively.\n+\n+\t* expr.h (simplify_builtin_fputs, simplify_builtin_strcpy,\n+\tsimplify_builtin_strncpy): Delete function prototypes.\n+\t* tree.h (fold_builtin_fputs, fold_builtin_strcpy,\n+\tfold_builtin_strncpy): Add function prototypes here.\n+\t(fold_builtin): Update function prototype with new \"bool ignore\".\n+\n+\t* tree-ssa-ccp.c (ccp_fold): Update call to fold_builtin.\n+\t(ccp_fold_builtin):  Update call to fold_builtin.  Call\n+\tfold_builtin_fputs, fold_builtin_strcpy and fold_builtin_strncpy\n+\tinstead of simplify_builtin_fputs, simplify_builtin_strcpy and\n+\tsimplify_builtin_strncpy respectively.\n+\t* fold-const.c (fold): Update call to fold_builtin.\n+\n 2004-07-08  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* builtins.c (expand_builtin_stpcpy): Un-simplify decay of stpcpy"}, {"sha": "c07ff044e3e02e3def06cb3827fb51d3dda705dc", "filename": "gcc/builtins.c", "status": "modified", "additions": 87, "deletions": 161, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32e70c34d6a6e1f413406c432d499fb468c708e/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32e70c34d6a6e1f413406c432d499fb468c708e/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=a32e70c34d6a6e1f413406c432d499fb468c708e", "patch": "@@ -156,8 +156,6 @@ static tree fold_builtin_bitop (tree);\n static tree fold_builtin_memcpy (tree);\n static tree fold_builtin_mempcpy (tree);\n static tree fold_builtin_memmove (tree);\n-static tree fold_builtin_strcpy (tree);\n-static tree fold_builtin_strncpy (tree);\n static tree fold_builtin_strchr (tree, bool);\n static tree fold_builtin_memcmp (tree);\n static tree fold_builtin_strcmp (tree);\n@@ -170,6 +168,7 @@ static tree fold_builtin_isdigit (tree);\n static tree fold_builtin_fabs (tree, tree);\n static tree fold_builtin_abs (tree, tree);\n static tree fold_builtin_unordered_cmp (tree, enum tree_code, enum tree_code);\n+static tree fold_builtin_1 (tree, bool);\n \n static tree simplify_builtin_memcmp (tree);\n static tree simplify_builtin_strcmp (tree);\n@@ -7314,14 +7313,15 @@ fold_builtin_memmove (tree exp)\n   return 0;\n }\n \n-/* Fold function call to builtin strcpy.  Return\n-   NULL_TREE if no simplification can be made.  */\n+/* Fold function call to builtin strcpy.  If LEN is not NULL, it represents\n+   the length of the string to be copied.  Return NULL_TREE if no\n+   simplification can be made.  */\n \n-static tree\n-fold_builtin_strcpy (tree exp)\n+tree\n+fold_builtin_strcpy (tree exp, tree len)\n {\n   tree arglist = TREE_OPERAND (exp, 1);\n-  tree dest, src;\n+  tree dest, src, fn;\n \n   if (!validate_arglist (arglist,\n \t\t\t POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n@@ -7334,17 +7334,37 @@ fold_builtin_strcpy (tree exp)\n   if (operand_equal_p (src, dest, 0))\n     return fold_convert (TREE_TYPE (exp), dest);\n \n-  return 0;\n+  if (optimize_size)\n+    return 0;\n+\n+  fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n+  if (!fn)\n+    return 0;\n+\n+  if (!len)\n+    {\n+      len = c_strlen (src, 1);\n+      if (! len || TREE_SIDE_EFFECTS (len))\n+\treturn 0;\n+    }\n+\n+  len = size_binop (PLUS_EXPR, len, ssize_int (1));\n+  arglist = build_tree_list (NULL_TREE, len);\n+  arglist = tree_cons (NULL_TREE, src, arglist);\n+  arglist = tree_cons (NULL_TREE, dest, arglist);\n+  return fold_convert (TREE_TYPE (exp),\n+\t\t       build_function_call_expr (fn, arglist));\n }\n \n-/* Fold function call to builtin strncpy.  Return\n-   NULL_TREE if no simplification can be made.  */\n+/* Fold function call to builtin strncpy.  If SLEN is not NULL, it represents\n+   the length of the source string.  Return NULL_TREE if no simplification\n+   can be made.  */\n \n-static tree\n-fold_builtin_strncpy (tree exp)\n+tree\n+fold_builtin_strncpy (tree exp, tree slen)\n {\n   tree arglist = TREE_OPERAND (exp, 1);\n-  tree dest, src, len;\n+  tree dest, src, len, fn;\n \n   if (!validate_arglist (arglist,\n \t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n@@ -7358,7 +7378,27 @@ fold_builtin_strncpy (tree exp)\n   if (integer_zerop (len))\n     return omit_one_operand (TREE_TYPE (exp), dest, src);\n \n-  return 0;\n+  if (!slen)\n+    slen = c_strlen (src, 1);\n+\n+  /* Now, we must be passed a constant src ptr parameter.  */\n+  if (slen == 0 || TREE_CODE (slen) != INTEGER_CST)\n+    return 0;\n+\n+  slen = size_binop (PLUS_EXPR, slen, ssize_int (1));\n+\n+  /* We do not support simplification of this case, though we do\n+     support it when expanding trees into RTL.  */\n+  /* FIXME: generate a call to __builtin_memset.  */\n+  if (tree_int_cst_lt (slen, len))\n+    return 0;\n+\n+  /* OK transform into builtin memcpy.  */\n+  fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n+  if (!fn)\n+    return 0;\n+  return fold_convert (TREE_TYPE (exp),\n+\t\t       build_function_call_expr (fn, arglist));\n }\n \n /* Fold function call to builtin strchr and strrchr.\n@@ -7886,11 +7926,13 @@ fold_builtin_unordered_cmp (tree exp,\n \t\t       fold (build2 (code, type, arg0, arg1))));\n }\n \n-/* Used by constant folding to eliminate some builtin calls early.  EXP is\n-   the CALL_EXPR of a call to a builtin function.  */\n+/* Used by constant folding to simplify calls to builtin functions.  EXP is\n+   the CALL_EXPR of a call to a builtin function.  IGNORE is true if the\n+   result of the function call is ignored.  This function returns NULL_TREE\n+   if no simplification was possible.  */\n \n static tree\n-fold_builtin_1 (tree exp)\n+fold_builtin_1 (tree exp, bool ignore)\n {\n   tree fndecl = get_callee_fndecl (exp);\n   tree arglist = TREE_OPERAND (exp, 1);\n@@ -8397,10 +8439,10 @@ fold_builtin_1 (tree exp)\n       return fold_builtin_memmove (exp);\n \n     case BUILT_IN_STRCPY:\n-      return fold_builtin_strcpy (exp);\n+      return fold_builtin_strcpy (exp, NULL_TREE);\n \n     case BUILT_IN_STRNCPY:\n-      return fold_builtin_strncpy (exp);\n+      return fold_builtin_strncpy (exp, NULL_TREE);\n \n     case BUILT_IN_INDEX:\n     case BUILT_IN_STRCHR:\n@@ -8466,6 +8508,12 @@ fold_builtin_1 (tree exp)\n     case BUILT_IN_ISUNORDERED:\n       return fold_builtin_unordered_cmp (exp, UNORDERED_EXPR, NOP_EXPR);\n \n+    case BUILT_IN_FPUTS:\n+      return fold_builtin_fputs (arglist, ignore, false, NULL_TREE);\n+\n+    case BUILT_IN_FPUTS_UNLOCKED:\n+      return fold_builtin_fputs (arglist, ignore, true, NULL_TREE);\n+\n     default:\n       break;\n     }\n@@ -8478,9 +8526,9 @@ fold_builtin_1 (tree exp)\n    call node earlier than the warning is generated.  */\n \n tree\n-fold_builtin (tree exp)\n+fold_builtin (tree exp, bool ignore)\n {\n-  exp = fold_builtin_1 (exp);\n+  exp = fold_builtin_1 (exp, ignore);\n   if (exp)\n     {\n       /* ??? Don't clobber shared nodes such as integer_zero_node.  */\n@@ -8614,10 +8662,10 @@ simplify_builtin (tree exp, int ignore)\n   switch (fcode)\n     {\n     case BUILT_IN_FPUTS:\n-      val = simplify_builtin_fputs (arglist, ignore, 0, NULL_TREE);\n+      val = fold_builtin_fputs (arglist, ignore, false, NULL_TREE);\n       break;\n     case BUILT_IN_FPUTS_UNLOCKED:\n-      val = simplify_builtin_fputs (arglist, ignore, 1, NULL_TREE);\n+      val = fold_builtin_fputs (arglist, ignore, true, NULL_TREE);\n       break;\n     case BUILT_IN_STRSTR:\n       val = simplify_builtin_strstr (arglist);\n@@ -8643,10 +8691,10 @@ simplify_builtin (tree exp, int ignore)\n       val = simplify_builtin_strrchr (arglist);\n       break;\n     case BUILT_IN_STRCPY:\n-      val = simplify_builtin_strcpy (arglist, NULL_TREE);\n+      val = fold_builtin_strcpy (exp, NULL_TREE);\n       break;\n     case BUILT_IN_STRNCPY:\n-      val = simplify_builtin_strncpy (arglist, NULL_TREE);\n+      val = fold_builtin_strncpy (exp, NULL_TREE);\n       break;\n     case BUILT_IN_STRCMP:\n       val = simplify_builtin_strcmp (arglist);\n@@ -8936,115 +8984,6 @@ simplify_builtin_strpbrk (tree arglist)\n     }\n }\n \n-/* Simplify a call to the strcpy builtin.\n-\n-   Return 0 if no simplification was possible, otherwise return the\n-   simplified form of the call as a tree.\n-\n-   The simplified form may be a constant or other expression which\n-   computes the same value, but in a more efficient manner (including\n-   calls to other builtin functions).\n-\n-   The call may contain arguments which need to be evaluated, but\n-   which are not useful to determine the result of the call.  In\n-   this case we return a chain of COMPOUND_EXPRs.  The LHS of each\n-   COMPOUND_EXPR will be an argument which must be evaluated.\n-   COMPOUND_EXPRs are chained through their RHS.  The RHS of the last\n-   COMPOUND_EXPR in the chain will contain the tree for the simplified\n-   form of the builtin function call.  */\n-\n-tree\n-simplify_builtin_strcpy (tree arglist, tree len)\n-{\n-  tree fn, src, dst;\n-\n-  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n-    return 0;\n-\n-  fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n-  if (!fn)\n-    return 0;\n-\n-  src = TREE_VALUE (TREE_CHAIN (arglist));\n-  dst = TREE_VALUE (arglist);\n-\n-  if (!len)\n-    {\n-      len = c_strlen (src, 1);\n-      if (!len || TREE_SIDE_EFFECTS (len))\n-\treturn 0;\n-    }\n-\n-  len = size_binop (PLUS_EXPR, len, ssize_int (1));\n-  arglist = build_tree_list (NULL_TREE, len);\n-  arglist = tree_cons (NULL_TREE, src, arglist);\n-  arglist = tree_cons (NULL_TREE, dst, arglist);\n-  return build_function_call_expr (fn, arglist);\n-}\n-\n-/* Simplify a call to the strncpy builtin.\n-\n-   Return 0 if no simplification was possible, otherwise return the\n-   simplified form of the call as a tree.\n-\n-   The simplified form may be a constant or other expression which\n-   computes the same value, but in a more efficient manner (including\n-   calls to other builtin functions).\n-\n-   The call may contain arguments which need to be evaluated, but\n-   which are not useful to determine the result of the call.  In\n-   this case we return a chain of COMPOUND_EXPRs.  The LHS of each\n-   COMPOUND_EXPR will be an argument which must be evaluated.\n-   COMPOUND_EXPRs are chained through their RHS.  The RHS of the last\n-   COMPOUND_EXPR in the chain will contain the tree for the simplified\n-   form of the builtin function call.  */\n-\n-tree\n-simplify_builtin_strncpy (tree arglist, tree slen)\n-{\n-  if (!validate_arglist (arglist,\n-\t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n-    return 0;\n-  else\n-    {\n-      tree len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n-      tree fn;\n-\n-      /* We must be passed a constant len parameter.  */\n-      if (TREE_CODE (len) != INTEGER_CST)\n-\treturn 0;\n-\n-      /* If the len parameter is zero, return the dst parameter.  */\n-      if (integer_zerop (len))\n-\t/* Evaluate and ignore the src argument in case it has\n-\t   side-effects and return the dst parameter.  */\n-\treturn omit_one_operand (TREE_TYPE (TREE_VALUE (arglist)),\n-\t\t\t\t TREE_VALUE (arglist),\n-\t\t\t\t TREE_VALUE (TREE_CHAIN (arglist)));\n-\n-      if (!slen)\n-        slen = c_strlen (TREE_VALUE (TREE_CHAIN (arglist)), 0);\n-\n-      /* Now, we must be passed a constant src ptr parameter.  */\n-      if (slen == 0 || TREE_CODE (slen) != INTEGER_CST)\n-\treturn 0;\n-\n-      slen = size_binop (PLUS_EXPR, slen, ssize_int (1));\n-\n-      /* We do not support simplification of this case, though we do\n-         support it when expanding trees into RTL.  */\n-      /* FIXME: generate a call to __builtin_memset.  */\n-      if (tree_int_cst_lt (slen, len))\n-\treturn 0;\n-\n-      /* OK transform into builtin memcpy.  */\n-      fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n-      if (!fn)\n-\treturn 0;\n-      return build_function_call_expr (fn, arglist);\n-    }\n-}\n-\n /* Simplify a call to the memcmp builtin.\n \n    Return 0 if no simplification was possible, otherwise return the\n@@ -9454,31 +9393,16 @@ simplify_builtin_strcspn (tree arglist)\n     }\n }\n \n-/* Simplify a call to the fputs builtin.\n-\n-   Return 0 if no simplification was possible, otherwise return the\n-   simplified form of the call as a tree.\n-\n-   The simplified form may be a constant or other expression which\n-   computes the same value, but in a more efficient manner (including\n-   calls to other builtin functions).\n-\n-   The call may contain arguments which need to be evaluated, but\n-   which are not useful to determine the result of the call.  In\n-   this case we return a chain of COMPOUND_EXPRs.  The LHS of each\n-   COMPOUND_EXPR will be an argument which must be evaluated.\n-   COMPOUND_EXPRs are chained through their RHS.  The RHS of the last\n-   COMPOUND_EXPR in the chain will contain the tree for the simplified\n-   form of the builtin function call.\n-\n-   If KNOWN_LEN is non-NULL, it represents the known length of the string.\n-   This is determined by SSA-CCP in cases where the string itself is not\n-   known to be constant but its length is always the same constant.  */\n+/* Fold a call to the fputs builtin.  IGNORE is true if the value returned\n+   by the builtin will be ignored.  UNLOCKED is true is true if this\n+   actually a call to fputs_unlocked.  If LEN in non-NULL, it represents\n+   the known length of the string.  Return NULL_TREE if no simplification\n+   was possible.  */\n \n tree\n-simplify_builtin_fputs (tree arglist, int ignore, int unlocked, tree known_len)\n+fold_builtin_fputs (tree arglist, bool ignore, bool unlocked, tree len)\n {\n-  tree len, fn;\n+  tree fn;\n   tree fn_fputc = unlocked ? implicit_built_in_decls[BUILT_IN_FPUTC_UNLOCKED]\n     : implicit_built_in_decls[BUILT_IN_FPUTC];\n   tree fn_fwrite = unlocked ? implicit_built_in_decls[BUILT_IN_FWRITE_UNLOCKED]\n@@ -9493,7 +9417,8 @@ simplify_builtin_fputs (tree arglist, int ignore, int unlocked, tree known_len)\n   if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     return 0;\n \n-  len = (known_len) ? known_len : c_strlen (TREE_VALUE (arglist), 0);\n+  if (! len)\n+    len = c_strlen (TREE_VALUE (arglist), 0);\n \n   /* Get the length of the string passed to fputs.  If the length\n      can't be determined, punt.  */\n@@ -9517,8 +9442,7 @@ simplify_builtin_fputs (tree arglist, int ignore, int unlocked, tree known_len)\n \t       fputc(string[0], stream).  */\n \t    arglist =\n \t      build_tree_list (NULL_TREE, TREE_VALUE (TREE_CHAIN (arglist)));\n-\t    arglist =\n-\t      tree_cons (NULL_TREE, build_int_2 (p[0], 0), arglist);\n+\t    arglist = tree_cons (NULL_TREE, build_int_2 (p[0], 0), arglist);\n \t    fn = fn_fputc;\n \t    break;\n \t  }\n@@ -9534,7 +9458,8 @@ simplify_builtin_fputs (tree arglist, int ignore, int unlocked, tree known_len)\n \tstring_arg = TREE_VALUE (arglist);\n \t/* New argument list transforming fputs(string, stream) to\n \t   fwrite(string, 1, len, stream).  */\n-\targlist = build_tree_list (NULL_TREE, TREE_VALUE (TREE_CHAIN (arglist)));\n+\targlist = build_tree_list (NULL_TREE,\n+\t\t\t\t   TREE_VALUE (TREE_CHAIN (arglist)));\n \targlist = tree_cons (NULL_TREE, len, arglist);\n \targlist = tree_cons (NULL_TREE, size_one_node, arglist);\n \targlist = tree_cons (NULL_TREE, string_arg, arglist);\n@@ -9545,7 +9470,8 @@ simplify_builtin_fputs (tree arglist, int ignore, int unlocked, tree known_len)\n       abort ();\n     }\n \n-  return build_function_call_expr (fn, arglist);\n+  return fold_convert (integer_type_node,\n+\t\t       build_function_call_expr (fn, arglist));\n }\n \n static void"}, {"sha": "c7d600c60f7cda27b2d66bd8057f25f6133373b6", "filename": "gcc/expr.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32e70c34d6a6e1f413406c432d499fb468c708e/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32e70c34d6a6e1f413406c432d499fb468c708e/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=a32e70c34d6a6e1f413406c432d499fb468c708e", "patch": "@@ -389,9 +389,6 @@ extern void expand_builtin_setjmp_receiver (rtx);\n extern void expand_builtin_longjmp (rtx, rtx);\n extern rtx expand_builtin_saveregs (void);\n extern void expand_builtin_trap (void);\n-extern tree simplify_builtin_fputs (tree, int, int, tree);\n-extern tree simplify_builtin_strcpy (tree, tree);\n-extern tree simplify_builtin_strncpy (tree, tree);\n \f\n /* Functions from expr.c:  */\n "}, {"sha": "a1efab1184bffca760f1c2b261a501570acd5732", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32e70c34d6a6e1f413406c432d499fb468c708e/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32e70c34d6a6e1f413406c432d499fb468c708e/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=a32e70c34d6a6e1f413406c432d499fb468c708e", "patch": "@@ -8937,7 +8937,7 @@ fold (tree expr)\n \t      == FUNCTION_DECL)\n \t  && DECL_BUILT_IN (TREE_OPERAND (TREE_OPERAND (t, 0), 0)))\n \t{\n-\t  tree tmp = fold_builtin (t);\n+\t  tree tmp = fold_builtin (t, false);\n \t  if (tmp)\n \t    return tmp;\n \t}"}, {"sha": "d2c503d6cebcd90a224182eed9a473a32a300cc3", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 42, "deletions": 37, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32e70c34d6a6e1f413406c432d499fb468c708e/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32e70c34d6a6e1f413406c432d499fb468c708e/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=a32e70c34d6a6e1f413406c432d499fb468c708e", "patch": "@@ -950,7 +950,7 @@ ccp_fold (tree stmt)\n \n \t  /* Substitute operands with their values and try to fold.  */\n \t  replace_uses_in (stmt, NULL);\n-\t  retval = fold_builtin (rhs);\n+\t  retval = fold_builtin (rhs, false);\n \n \t  /* Restore operands to their original form.  */\n \t  for (i = 0; i < NUM_USES (uses); i++)\n@@ -963,13 +963,7 @@ ccp_fold (tree stmt)\n \n   /* If we got a simplified form, see if we need to convert its type.  */\n   if (retval)\n-    {\n-      if (TREE_TYPE (retval) != TREE_TYPE (rhs))\n-\tretval = fold_convert (TREE_TYPE (rhs), retval);\n-\n-      if (TREE_TYPE (retval) == TREE_TYPE (rhs))\n-\treturn retval;\n-    }\n+    return fold_convert (TREE_TYPE (rhs), retval);\n \n   /* No simplification was possible.  */\n   return rhs;\n@@ -2307,23 +2301,31 @@ static tree\n ccp_fold_builtin (tree stmt, tree fn)\n {\n   tree result, strlen_val[2];\n-  tree arglist = TREE_OPERAND (fn, 1), a;\n-  tree callee = get_callee_fndecl (fn);\n-  bitmap visited;\n+  tree callee, arglist, a;\n   int strlen_arg, i;\n+  bitmap visited;\n+  bool ignore;\n \n-  /* Ignore MD builtins.  */\n-  if (DECL_BUILT_IN_CLASS (callee) == BUILT_IN_MD)\n-    return NULL_TREE;\n+  ignore = TREE_CODE (stmt) != MODIFY_EXPR;\n \n   /* First try the generic builtin folder.  If that succeeds, return the\n      result directly.  */\n-  result = fold_builtin (fn);\n+  result = fold_builtin (fn, ignore);\n   if (result)\n+  {\n+    if (ignore)\n+      STRIP_NOPS (result);\n     return result;\n+  }\n+\n+  /* Ignore MD builtins.  */\n+  callee = get_callee_fndecl (fn);\n+  if (DECL_BUILT_IN_CLASS (callee) == BUILT_IN_MD)\n+    return NULL_TREE;\n \n   /* If the builtin could not be folded, and it has no argument list,\n      we're done.  */\n+  arglist = TREE_OPERAND (fn, 1);\n   if (!arglist)\n     return NULL_TREE;\n \n@@ -2359,49 +2361,52 @@ ccp_fold_builtin (tree stmt, tree fn)\n \n   BITMAP_XFREE (visited);\n \n-  /* FIXME.  All this code looks dangerous in the sense that it might\n-     create non-gimple expressions.  */\n+  result = NULL_TREE;\n   switch (DECL_FUNCTION_CODE (callee))\n     {\n     case BUILT_IN_STRLEN:\n-      /* Convert from the internal \"sizetype\" type to \"size_t\".  */\n-      if (strlen_val[0]\n-\t  && size_type_node)\n+      if (strlen_val[0])\n \t{\n-\t  tree new = convert (size_type_node, strlen_val[0]);\n+\t  tree new = fold_convert (TREE_TYPE (fn), strlen_val[0]);\n \n \t  /* If the result is not a valid gimple value, or not a cast\n \t     of a valid gimple value, then we can not use the result.  */\n \t  if (is_gimple_val (new)\n \t      || (is_gimple_cast (new)\n \t\t  && is_gimple_val (TREE_OPERAND (new, 0))))\n \t    return new;\n-\t  else\n-\t    return NULL_TREE;\n \t}\n-      return strlen_val[0];\n+      break;\n+\n     case BUILT_IN_STRCPY:\n-      if (strlen_val[1]\n-\t  && is_gimple_val (strlen_val[1]))\n-      return simplify_builtin_strcpy (arglist, strlen_val[1]);\n+      if (strlen_val[1] && is_gimple_val (strlen_val[1]))\n+        result = fold_builtin_strcpy (fn, strlen_val[1]);\n+      break;\n+\n     case BUILT_IN_STRNCPY:\n-      if (strlen_val[1]\n-\t  && is_gimple_val (strlen_val[1]))\n-      return simplify_builtin_strncpy (arglist, strlen_val[1]);\n+      if (strlen_val[1] && is_gimple_val (strlen_val[1]))\n+\tresult = fold_builtin_strncpy (fn, strlen_val[1]);\n+      break;\n+\n     case BUILT_IN_FPUTS:\n-      return simplify_builtin_fputs (arglist,\n-\t\t\t\t     TREE_CODE (stmt) != MODIFY_EXPR, 0,\n-\t\t\t\t     strlen_val[0]);\n+      result = fold_builtin_fputs (arglist,\n+\t\t\t\t   TREE_CODE (stmt) != MODIFY_EXPR, 0,\n+\t\t\t\t   strlen_val[0]);\n+      break;\n+\n     case BUILT_IN_FPUTS_UNLOCKED:\n-      return simplify_builtin_fputs (arglist,\n-\t\t\t\t     TREE_CODE (stmt) != MODIFY_EXPR, 1,\n-\t\t\t\t     strlen_val[0]);\n+      result = fold_builtin_fputs (arglist,\n+\t\t\t\t   TREE_CODE (stmt) != MODIFY_EXPR, 1,\n+\t\t\t\t   strlen_val[0]);\n+      break;\n \n     default:\n       abort ();\n     }\n \n-  return NULL_TREE;\n+  if (result && ignore)\n+    STRIP_NOPS (result);\n+  return result;\n }\n \n "}, {"sha": "4dab73f0f6dc549a26b4ef9e5034c31172589902", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32e70c34d6a6e1f413406c432d499fb468c708e/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32e70c34d6a6e1f413406c432d499fb468c708e/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=a32e70c34d6a6e1f413406c432d499fb468c708e", "patch": "@@ -3423,7 +3423,10 @@ extern bool tree_swap_operands_p (tree, tree, bool);\n extern enum tree_code swap_tree_comparison (enum tree_code);\n \n /* In builtins.c */\n-extern tree fold_builtin (tree);\n+extern tree fold_builtin (tree, bool);\n+extern tree fold_builtin_fputs (tree, bool, bool, tree);\n+extern tree fold_builtin_strcpy (tree, tree);\n+extern tree fold_builtin_strncpy (tree, tree);\n extern enum built_in_function builtin_mathfn_code (tree);\n extern tree build_function_call_expr (tree, tree);\n extern tree mathfn_built_in (tree, enum built_in_function fn);"}]}