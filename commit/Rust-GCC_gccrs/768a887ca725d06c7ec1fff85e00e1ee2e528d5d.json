{"sha": "768a887ca725d06c7ec1fff85e00e1ee2e528d5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY4YTg4N2NhNzI1ZDA2YzdlYzFmZmY4NWUwMGUxZWUyZTUyOGQ1ZA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-09-02T12:33:33Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-09-02T12:33:33Z"}, "message": "Initial revision\n\nFrom-SVN: r22179", "tree": {"sha": "09060114c00333afbee285e97d3b80b65589eec2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09060114c00333afbee285e97d3b80b65589eec2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/768a887ca725d06c7ec1fff85e00e1ee2e528d5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/768a887ca725d06c7ec1fff85e00e1ee2e528d5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/768a887ca725d06c7ec1fff85e00e1ee2e528d5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/768a887ca725d06c7ec1fff85e00e1ee2e528d5d/comments", "author": null, "committer": null, "parents": [{"sha": "72e4bfd9e42fee1f39c24571caf8b82c0b457482", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72e4bfd9e42fee1f39c24571caf8b82c0b457482", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72e4bfd9e42fee1f39c24571caf8b82c0b457482"}], "stats": {"total": 1199, "additions": 1199, "deletions": 0}, "files": [{"sha": "5660855b05956183d141d211a7fd0eef7dc388d2", "filename": "libstdc++/stl/bitset", "status": "added", "additions": 1064, "deletions": 0, "changes": 1064, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/768a887ca725d06c7ec1fff85e00e1ee2e528d5d/libstdc%2B%2B%2Fstl%2Fbitset", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/768a887ca725d06c7ec1fff85e00e1ee2e528d5d/libstdc%2B%2B%2Fstl%2Fbitset", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fbitset?ref=768a887ca725d06c7ec1fff85e00e1ee2e528d5d", "patch": "@@ -0,0 +1,1064 @@\n+/*\n+ * Copyright (c) 1998\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */ \n+\n+#ifndef __SGI_STL_BITSET\n+#define __SGI_STL_BITSET\n+\n+// This implementation of bitset<> has a second template parameter,\n+// _WordT, which defaults to unsigned long.  *YOU SHOULD NOT USE\n+// THIS FEATURE*.  It is experimental, and it may be removed in\n+// future releases.\n+\n+// A bitset of size N, using words of type _WordT, will have \n+// N % (sizeof(_WordT) * CHAR_BIT) unused bits.  (They are the high-\n+// order bits in the highest word.)  It is a class invariant\n+// of class bitset<> that those unused bits are always zero.\n+\n+// Most of the actual code isn't contained in bitset<> itself, but in the \n+// base class _Base_bitset.  The base class works with whole words, not with\n+// individual bits.  This allows us to specialize _Base_bitset for the\n+// important special case where the bitset is only a single word.\n+\n+// The C++ standard does not define the precise semantics of operator[].\n+// In this implementation the const version of operator[] is equivalent\n+// to test(), except that it does no range checking.  The non-const version\n+// returns a reference to a bit, again without doing any range checking.\n+\n+\n+#include <stddef.h>     // for size_t\n+#include <string>\n+#include <stdexcept>    // for invalid_argument, out_of_range, overflow_error\n+#include <iostream.h>   // for istream, ostream\n+\n+#define __BITS_PER_WORDT(__wt) (CHAR_BIT*sizeof(__wt))\n+#define __BITSET_WORDS(__n,__wt) \\\n+ ((__n) < 1 ? 1 : ((__n) + __BITS_PER_WORDT(__wt) - 1)/__BITS_PER_WORDT(__wt))\n+\n+__STL_BEGIN_NAMESPACE\n+\n+#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n+#pragma set woff 1209\n+#endif\n+\n+// structure to aid in counting bits\n+template<bool __dummy> \n+struct _Bit_count {\n+  static unsigned char _S_bit_count[256];\n+};\n+\n+// Mapping from 8 bit unsigned integers to the index of the first one\n+// bit:\n+template<bool __dummy> \n+struct _First_one {\n+  static unsigned char _S_first_one[256];\n+};\n+\n+//\n+// Base class: general case.\n+//\n+\n+template<size_t _Nw, class _WordT>\n+struct _Base_bitset {\n+  _WordT _M_w[_Nw];                // 0 is the least significant word.\n+\n+  _Base_bitset( void ) { _M_do_reset(); }\n+\n+  _Base_bitset(unsigned long __val);\n+\n+  static size_t _S_whichword( size_t __pos ) {\n+    return __pos / __BITS_PER_WORDT(_WordT);\n+  }\n+  static size_t _S_whichbyte( size_t __pos ) {\n+    return (__pos % __BITS_PER_WORDT(_WordT)) / CHAR_BIT;\n+  }\n+  static size_t _S_whichbit( size_t __pos ) {\n+    return __pos % __BITS_PER_WORDT(_WordT);\n+  }\n+  static _WordT _S_maskbit( size_t __pos ) {\n+    return (static_cast<_WordT>(1)) << _S_whichbit(__pos);\n+  }\n+\n+  _WordT& _M_getword(size_t __pos)       { return _M_w[_S_whichword(__pos)]; }\n+  _WordT  _M_getword(size_t __pos) const { return _M_w[_S_whichword(__pos)]; }\n+\n+  _WordT& _M_hiword()       { return _M_w[_Nw - 1]; }\n+  _WordT  _M_hiword() const { return _M_w[_Nw - 1]; }\n+\n+  void _M_do_and(const _Base_bitset<_Nw,_WordT>& __x) {\n+    for ( size_t __i = 0; __i < _Nw; __i++ ) {\n+      _M_w[__i] &= __x._M_w[__i];\n+    }\n+  }\n+\n+  void _M_do_or(const _Base_bitset<_Nw,_WordT>& __x) {\n+    for ( size_t __i = 0; __i < _Nw; __i++ ) {\n+      _M_w[__i] |= __x._M_w[__i];\n+    }\n+  }\n+\n+  void _M_do_xor(const _Base_bitset<_Nw,_WordT>& __x) {\n+    for ( size_t __i = 0; __i < _Nw; __i++ ) {\n+      _M_w[__i] ^= __x._M_w[__i];\n+    }\n+  }\n+\n+  void _M_do_left_shift(size_t __shift);\n+\n+  void _M_do_right_shift(size_t __shift);\n+\n+  void _M_do_flip() {\n+    for ( size_t __i = 0; __i < _Nw; __i++ ) {\n+      _M_w[__i] = ~_M_w[__i];\n+    }\n+  }\n+\n+  void _M_do_set() {\n+    for ( size_t __i = 0; __i < _Nw; __i++ ) {\n+      _M_w[__i] = ~static_cast<_WordT>(0);\n+    }\n+  }\n+\n+  void _M_do_reset() {\n+    for ( size_t __i = 0; __i < _Nw; __i++ ) {\n+      _M_w[__i] = 0;\n+    }\n+  }\n+\n+  bool _M_is_equal(const _Base_bitset<_Nw,_WordT>& __x) const {\n+    for (size_t __i = 0; __i < _Nw; ++__i) {\n+      if (_M_w[__i] != __x._M_w[__i])\n+        return false;\n+    }\n+    return true;\n+  }\n+\n+  bool _M_is_any() const {\n+    for ( size_t __i = 0; __i < __BITSET_WORDS(_Nw,_WordT); __i++ ) {\n+      if ( _M_w[__i] != static_cast<_WordT>(0) )\n+        return true;\n+    }\n+    return false;\n+  }\n+\n+  size_t _M_do_count() const {\n+    size_t __result = 0;\n+    const unsigned char* __byte_ptr = (const unsigned char*)_M_w;\n+    const unsigned char* __end_ptr = (const unsigned char*)(_M_w+_Nw);\n+\n+    while ( __byte_ptr < __end_ptr ) {\n+      __result += _Bit_count<true>::_S_bit_count[*__byte_ptr];\n+      __byte_ptr++;\n+    }\n+    return __result;\n+  }\n+\n+  unsigned long _M_do_to_ulong() const; \n+\n+  // find first \"on\" bit\n+  size_t _M_do_find_first(size_t __not_found) const;\n+\n+  // find the next \"on\" bit that follows \"prev\"\n+  size_t _M_do_find_next(size_t __prev, size_t __not_found) const;\n+};\n+\n+//\n+// Definitions of non-inline functions from _Base_bitset.\n+// \n+\n+template<size_t _Nw, class _WordT>\n+_Base_bitset<_Nw, _WordT>::_Base_bitset(unsigned long __val)\n+{\n+  _M_do_reset();\n+  const size_t __n = min(sizeof(unsigned long)*CHAR_BIT,\n+                         __BITS_PER_WORDT(_WordT)*_Nw);\n+  for(size_t __i = 0; __i < __n; ++__i, __val >>= 1)\n+    if ( __val & 0x1 )\n+      _M_getword(__i) |= _S_maskbit(__i);\n+}\n+\n+template<size_t _Nw, class _WordT>\n+void _Base_bitset<_Nw, _WordT>::_M_do_left_shift(size_t __shift) \n+{\n+  if (__shift != 0) {\n+    const size_t __wshift = __shift / __BITS_PER_WORDT(_WordT);\n+    const size_t __offset = __shift % __BITS_PER_WORDT(_WordT);\n+    const size_t __sub_offset = __BITS_PER_WORDT(_WordT) - __offset;\n+    size_t __n = _Nw - 1;\n+    for ( ; __n > __wshift; --__n)\n+      _M_w[__n] = (_M_w[__n - __wshift] << __offset) | \n+                (_M_w[__n - __wshift - 1] >> __sub_offset);\n+    if (__n == __wshift)\n+      _M_w[__n] = _M_w[0] << __offset;\n+    for (size_t __n1 = 0; __n1 < __n; ++__n1)\n+      _M_w[__n1] = static_cast<_WordT>(0);\n+  }\n+}\n+\n+template<size_t _Nw, class _WordT>\n+void _Base_bitset<_Nw, _WordT>::_M_do_right_shift(size_t __shift) \n+{\n+  if (__shift != 0) {\n+    const size_t __wshift = __shift / __BITS_PER_WORDT(_WordT);\n+    const size_t __offset = __shift % __BITS_PER_WORDT(_WordT);\n+    const size_t __sub_offset = __BITS_PER_WORDT(_WordT) - __offset;\n+    const size_t __limit = _Nw - __wshift - 1;\n+    size_t __n = 0;\n+    for ( ; __n < __limit; ++__n)\n+      _M_w[__n] = (_M_w[__n + __wshift] >> __offset) | \n+                  (_M_w[__n + __wshift + 1] << __sub_offset);\n+    _M_w[__limit] = _M_w[_Nw-1] >> __offset;\n+    for (size_t __n1 = __limit + 1; __n1 < _Nw; ++__n1)\n+      _M_w[__n1] = static_cast<_WordT>(0);\n+  }\n+}\n+\n+template<size_t _Nw, class _WordT>\n+unsigned long _Base_bitset<_Nw, _WordT>::_M_do_to_ulong() const\n+{\n+  const overflow_error __overflow(\"bitset\");\n+\n+  if (sizeof(_WordT) >= sizeof(unsigned long)) {\n+    for (size_t __i = 1; __i < _Nw; ++__i) \n+      if (_M_w[__i]) \n+        __STL_THROW(__overflow);\n+\n+    const _WordT __mask = static_cast<_WordT>(static_cast<unsigned long>(-1));\n+    if (_M_w[0] & ~__mask) \n+      __STL_THROW(__overflow);\n+\n+    return static_cast<unsigned long>(_M_w[0] & __mask);\n+  }\n+  else {                      // sizeof(_WordT) < sizeof(unsigned long).\n+    const size_t __nwords =\n+      (sizeof(unsigned long) + sizeof(_WordT) - 1) / sizeof(_WordT);\n+\n+    size_t __min_nwords = __nwords;\n+    if (_Nw > __nwords) {\n+      for (size_t __i = __nwords; __i < _Nw; ++__i) \n+        if (_M_w[__i]) \n+          __STL_THROW(__overflow);\n+    }\n+    else \n+      __min_nwords = _Nw;\n+      \n+    // If unsigned long is 8 bytes and _WordT is 6 bytes, then an unsigned\n+    // long consists of all of one word plus 2 bytes from another word.\n+    const size_t __part = sizeof(unsigned long) % sizeof(_WordT);\n+\n+    if (__part != 0 && __nwords <= _Nw && \n+        (_M_w[__min_nwords - 1] >> ((sizeof(_WordT) - __part) * CHAR_BIT)) != 0)\n+      __STL_THROW(__overflow);\n+\n+    unsigned long __result = 0;\n+    for (size_t __i = 0; __i < __min_nwords; ++__i) {\n+      __result |= static_cast<unsigned long>(\n+         _M_w[__i]) << (__i * sizeof(_WordT) * CHAR_BIT);\n+    }\n+    return __result;\n+  }\n+} // End _M_do_to_ulong\n+\n+template<size_t _Nw, class _WordT>\n+size_t _Base_bitset<_Nw, _WordT>::_M_do_find_first(size_t __not_found) const \n+{\n+  for ( size_t __i = 0; __i < _Nw; __i++ ) {\n+    _WordT __thisword = _M_w[__i];\n+    if ( __thisword != static_cast<_WordT>(0) ) {\n+      // find byte within word\n+      for ( size_t __j = 0; __j < sizeof(_WordT); __j++ ) {\n+        unsigned char __this_byte\n+          = static_cast<unsigned char>(__thisword & (~(unsigned char)0));\n+        if ( __this_byte )\n+          return __i*__BITS_PER_WORDT(_WordT) + __j*CHAR_BIT +\n+            _First_one<true>::_S_first_one[__this_byte];\n+\n+        __thisword >>= CHAR_BIT;\n+      }\n+    }\n+  }\n+  // not found, so return an indication of failure.\n+  return __not_found;\n+}\n+\n+template<size_t _Nw, class _WordT>\n+size_t\n+_Base_bitset<_Nw, _WordT>::_M_do_find_next(size_t __prev, \n+                                           size_t __not_found) const\n+{\n+  // make bound inclusive\n+  ++__prev;\n+\n+  // check out of bounds\n+  if ( __prev >= _Nw * __BITS_PER_WORDT(_WordT) )\n+    return __not_found;\n+\n+    // search first word\n+  size_t __i = _S_whichword(__prev);\n+  _WordT __thisword = _M_w[__i];\n+\n+    // mask off bits below bound\n+  __thisword &= (~static_cast<_WordT>(0)) << _S_whichbit(__prev);\n+\n+  if ( __thisword != static_cast<_WordT>(0) ) {\n+    // find byte within word\n+    // get first byte into place\n+    __thisword >>= _S_whichbyte(__prev) * CHAR_BIT;\n+    for ( size_t __j = _S_whichbyte(__prev); __j < sizeof(_WordT); __j++ ) {\n+      unsigned char __this_byte\n+        = static_cast<unsigned char>(__thisword & (~(unsigned char)0));\n+      if ( __this_byte )\n+        return __i*__BITS_PER_WORDT(_WordT) + __j*CHAR_BIT +\n+          _First_one<true>::_S_first_one[__this_byte];\n+\n+      __thisword >>= CHAR_BIT;\n+    }\n+  }\n+\n+  // check subsequent words\n+  __i++;\n+  for ( ; __i < _Nw; __i++ ) {\n+    _WordT __thisword = _M_w[__i];\n+    if ( __thisword != static_cast<_WordT>(0) ) {\n+      // find byte within word\n+      for ( size_t __j = 0; __j < sizeof(_WordT); __j++ ) {\n+        unsigned char __this_byte\n+          = static_cast<unsigned char>(__thisword & (~(unsigned char)0));\n+        if ( __this_byte )\n+          return __i*__BITS_PER_WORDT(_WordT) + __j*CHAR_BIT +\n+            _First_one<true>::_S_first_one[__this_byte];\n+\n+        __thisword >>= CHAR_BIT;\n+      }\n+    }\n+  }\n+\n+  // not found, so return an indication of failure.\n+  return __not_found;\n+} // end _M_do_find_next\n+\n+\n+// ------------------------------------------------------------\n+\n+//\n+// Base class: specialization for a single word.\n+//\n+\n+template<class _WordT>\n+struct _Base_bitset<1, _WordT> {\n+  _WordT _M_w;\n+\n+  _Base_bitset( void ) { _M_do_reset(); }\n+\n+  _Base_bitset(unsigned long __val); \n+\n+  static size_t _S_whichword( size_t __pos ) {\n+    return __pos / __BITS_PER_WORDT(_WordT);\n+  }\n+  static size_t _S_whichbyte( size_t __pos ) {\n+    return (__pos % __BITS_PER_WORDT(_WordT)) / CHAR_BIT;\n+  }\n+  static size_t _S_whichbit( size_t __pos ) {\n+    return __pos % __BITS_PER_WORDT(_WordT);\n+  }\n+  static _WordT _S_maskbit( size_t __pos ) {\n+    return (static_cast<_WordT>(1)) << _S_whichbit(__pos);\n+  }\n+\n+  _WordT& _M_getword(size_t)       { return _M_w; }\n+  _WordT  _M_getword(size_t) const { return _M_w; }\n+\n+  _WordT& _M_hiword()       { return _M_w; }\n+  _WordT  _M_hiword() const { return _M_w; }\n+\n+  void _M_do_and(const _Base_bitset<1,_WordT>& __x) { _M_w &= __x._M_w; }\n+  void _M_do_or(const _Base_bitset<1,_WordT>& __x)  { _M_w |= __x._M_w; }\n+  void _M_do_xor(const _Base_bitset<1,_WordT>& __x) { _M_w ^= __x._M_w; }\n+  void _M_do_left_shift(size_t __shift)     { _M_w <<= __shift; }\n+  void _M_do_right_shift(size_t __shift)    { _M_w >>= __shift; }\n+  void _M_do_flip()                       { _M_w = ~_M_w; }\n+  void _M_do_set()                        { _M_w = ~static_cast<_WordT>(0); }\n+  void _M_do_reset()                      { _M_w = 0; }\n+\n+  bool _M_is_equal(const _Base_bitset<1,_WordT>& __x) const {\n+    return _M_w == __x._M_w;\n+  }\n+  bool _M_is_any() const {\n+    return _M_w != 0;\n+  }\n+\n+  size_t _M_do_count() const {\n+    size_t __result = 0;\n+    const unsigned char* __byte_ptr = (const unsigned char*)&_M_w;\n+    const unsigned char* __end_ptr = ((const unsigned char*)&_M_w)+sizeof(_M_w);\n+    while ( __byte_ptr < __end_ptr ) {\n+      __result += _Bit_count<true>::_S_bit_count[*__byte_ptr];\n+      __byte_ptr++;\n+    }\n+    return __result;\n+  }\n+\n+  unsigned long _M_do_to_ulong() const {\n+    if (sizeof(_WordT) <= sizeof(unsigned long))\n+        return static_cast<unsigned long>(_M_w);\n+    else {\n+      const _WordT __mask = static_cast<_WordT>(static_cast<unsigned long>(-1));\n+      if (_M_w & ~__mask) \n+        __STL_THROW(overflow_error(\"bitset\"));\n+      return static_cast<unsigned long>(_M_w);\n+    }\n+  }\n+\n+  size_t _M_do_find_first(size_t __not_found) const;\n+\n+  // find the next \"on\" bit that follows \"prev\"\n+  size_t _M_do_find_next(size_t __prev, size_t __not_found) const; \n+\n+};\n+\n+//\n+// Definitions of non-inline functions from the single-word version of\n+//  _Base_bitset.\n+//\n+\n+template <class _WordT>\n+_Base_bitset<1, _WordT>::_Base_bitset(unsigned long __val) \n+{\n+  _M_do_reset();\n+  const size_t __n = min(sizeof(unsigned long)*CHAR_BIT,\n+                         __BITS_PER_WORDT(_WordT)*_Nw);\n+  for(size_t __i = 0; __i < __n; ++__i, __val >>= 1)\n+    if ( __val & 0x1 )\n+      _M_w |= _S_maskbit(__i);\n+}\n+\n+template <class _WordT>\n+size_t _Base_bitset<1, _WordT>::_M_do_find_first(size_t __not_found) const\n+{\n+  _WordT __thisword = _M_w;\n+\n+  if ( __thisword != static_cast<_WordT>(0) ) {\n+    // find byte within word\n+    for ( size_t __j = 0; __j < sizeof(_WordT); __j++ ) {\n+      unsigned char __this_byte\n+        = static_cast<unsigned char>(__thisword & (~(unsigned char)0));\n+      if ( __this_byte )\n+        return __j*CHAR_BIT + _First_one<true>::_S_first_one[__this_byte];\n+\n+      __thisword >>= CHAR_BIT;\n+    }\n+  }\n+  // not found, so return a value that indicates failure.\n+  return __not_found;\n+}\n+\n+template <class _WordT>\n+size_t \n+_Base_bitset<1, _WordT>::_M_do_find_next(size_t __prev, \n+                                         size_t __not_found ) const\n+{\n+  // make bound inclusive\n+  ++__prev;\n+\n+  // check out of bounds\n+  if ( __prev >= __BITS_PER_WORDT(_WordT) )\n+    return __not_found;\n+\n+    // search first (and only) word\n+  _WordT __thisword = _M_w;\n+\n+  // mask off bits below bound\n+  __thisword &= (~static_cast<_WordT>(0)) << _S_whichbit(__prev);\n+\n+  if ( __thisword != static_cast<_WordT>(0) ) {\n+    // find byte within word\n+    // get first byte into place\n+    __thisword >>= _S_whichbyte(__prev) * CHAR_BIT;\n+    for ( size_t __j = _S_whichbyte(__prev); __j < sizeof(_WordT); __j++ ) {\n+      unsigned char __this_byte\n+        = static_cast<unsigned char>(__thisword & (~(unsigned char)0));\n+      if ( __this_byte )\n+        return __j*CHAR_BIT + _First_one<true>::_S_first_one[__this_byte];\n+\n+      __thisword >>= CHAR_BIT;\n+    }\n+  }\n+\n+  // not found, so return a value that indicates failure.\n+  return __not_found;\n+} // end _M_do_find_next\n+\n+//\n+// One last specialization: _M_do_to_ulong() and the constructor from\n+// unsigned long are very simple if the bitset consists of a single \n+// word of type unsigned long.\n+//\n+\n+template<>\n+inline unsigned long \n+_Base_bitset<1, unsigned long>::_M_do_to_ulong() const { return _M_w; }\n+\n+template<>\n+inline _Base_bitset<1, unsigned long>::_Base_bitset(unsigned long __val) {\n+  _M_w = __val;\n+}\n+\n+\n+// ------------------------------------------------------------\n+// Helper class to zero out the unused high-order bits in the highest word.\n+\n+template <class _WordT, size_t _Extrabits> struct _Sanitize {\n+  static void _M_do_sanitize(_WordT& __val)\n+    { __val &= ~((~static_cast<_WordT>(0)) << _Extrabits); }\n+};\n+\n+template <class _WordT> struct _Sanitize<_WordT, 0> {\n+  static void _M_do_sanitize(_WordT) {}\n+};\n+\n+// ------------------------------------------------------------\n+// Class bitset.\n+//   _Nb may be any nonzero number of type size_t.\n+//   Type _WordT may be any unsigned integral type.\n+\n+template<size_t _Nb, class _WordT = unsigned long>\n+class bitset : private _Base_bitset<__BITSET_WORDS(_Nb,_WordT), _WordT> \n+{\n+private:\n+  typedef _Base_bitset<__BITSET_WORDS(_Nb,_WordT), _WordT> _Base;\n+\n+  // Import base's protected interface.  Necessary because of new template\n+  // name resolution rules.\n+  using _Base::_S_whichword;\n+  using _Base::_S_whichbyte;\n+  using _Base::_S_whichbit;\n+  using _Base::_S_maskbit;\n+  using _Base::_M_getword;\n+  using _Base::_M_hiword;\n+  using _Base::_M_do_and;\n+  using _Base::_M_do_or;\n+  using _Base::_M_do_xor;\n+  using _Base::_M_do_left_shift;\n+  using _Base::_M_do_right_shift;\n+  using _Base::_M_do_flip;\n+  using _Base::_M_do_set;\n+  using _Base::_M_do_reset;\n+  using _Base::_M_is_equal;\n+  using _Base::_M_is_any;\n+  using _Base::_M_do_count;\n+  using _Base::_M_do_to_ulong;\n+  using _Base::_M_do_find_first;\n+  using _Base::_M_do_find_next;\n+\n+private:\n+  void _M_do_sanitize() {\n+    _Sanitize<_WordT,_Nb%__BITS_PER_WORDT(_WordT) >\n+      ::_M_do_sanitize(_M_hiword());\n+  }\n+\n+public:\n+\n+  // bit reference:\n+  class reference {\n+    friend class bitset;\n+\n+    _WordT *_M_wp;\n+    size_t _M_bpos;\n+\n+    // left undefined\n+    reference();\n+\n+    reference( bitset& __b, size_t __pos ) {\n+      _M_wp = &__b._M_getword(__pos);\n+      _M_bpos = _S_whichbit(__pos);\n+    }\n+\n+  public:\n+    ~reference() {}\n+\n+    // for b[i] = __x;\n+    reference& operator=(bool __x) {\n+      if ( __x )\n+        *_M_wp |= _S_maskbit(_M_bpos);\n+      else\n+        *_M_wp &= ~_S_maskbit(_M_bpos);\n+\n+      return *this;\n+    }\n+\n+    // for b[i] = b[__j];\n+    reference& operator=(const reference& __j) {\n+      if ( (*(__j._M_wp) & _S_maskbit(__j._M_bpos)) )\n+        *_M_wp |= _S_maskbit(_M_bpos);\n+      else\n+        *_M_wp &= ~_S_maskbit(_M_bpos);\n+\n+      return *this;\n+    }\n+\n+    // flips the bit\n+    bool operator~() const { return (*(_M_wp) & _S_maskbit(_M_bpos)) == 0; }\n+\n+    // for __x = b[i];\n+    operator bool() const { return (*(_M_wp) & _S_maskbit(_M_bpos)) != 0; }\n+\n+    // for b[i].flip();\n+    reference& flip() {\n+      *_M_wp ^= _S_maskbit(_M_bpos);\n+      return *this;\n+    }\n+  };\n+\n+  // 23.3.5.1 constructors:\n+  bitset() {}\n+  bitset(unsigned long __val) : \n+    _Base_bitset<__BITSET_WORDS(_Nb,_WordT), _WordT>(__val) {}\n+\n+  template<class _CharT, class _Traits, class _Alloc>\n+  explicit bitset(const basic_string<_CharT,_Traits,_Alloc>& __s,\n+                  size_t __pos = 0,\n+                  size_t __n = basic_string<_CharT,_Traits,_Alloc>::npos) \n+    : _Base() \n+  {\n+    if (__pos > __s.size()) \n+      __STL_THROW(out_of_range(\"bitset\"));\n+    _M_copy_from_string(__s, __pos, __n);\n+  }\n+\n+  // 23.3.5.2 bitset operations:\n+  bitset<_Nb,_WordT>& operator&=(const bitset<_Nb,_WordT>& __rhs) {\n+    _M_do_and(__rhs);\n+    return *this;\n+  }\n+\n+  bitset<_Nb,_WordT>& operator|=(const bitset<_Nb,_WordT>& __rhs) {\n+    _M_do_or(__rhs);\n+    return *this;\n+  }\n+\n+  bitset<_Nb,_WordT>& operator^=(const bitset<_Nb,_WordT>& __rhs) {\n+    _M_do_xor(__rhs);\n+    return *this;\n+  }\n+\n+  bitset<_Nb,_WordT>& operator<<=(size_t __pos) {\n+    _M_do_left_shift(__pos);\n+    _M_do_sanitize();\n+    return *this;\n+  }\n+\n+  bitset<_Nb,_WordT>& operator>>=(size_t __pos) {\n+    _M_do_right_shift(__pos);\n+    _M_do_sanitize();\n+    return *this;\n+  }\n+\n+  //\n+  // Extension:\n+  // Versions of single-bit set, reset, flip, test with no range checking.\n+  //\n+\n+  bitset<_Nb,_WordT>& _Unchecked_set(size_t __pos) {\n+    _M_getword(__pos) |= _S_maskbit(__pos);\n+    return *this;\n+  }\n+\n+  bitset<_Nb,_WordT>& _Unchecked_set(size_t __pos, int __val) {\n+    if (__val)\n+      _M_getword(__pos) |= _S_maskbit(__pos);\n+    else\n+      _M_getword(__pos) &= ~_S_maskbit(__pos);\n+\n+    return *this;\n+  }\n+\n+  bitset<_Nb,_WordT>& _Unchecked_reset(size_t __pos) {\n+    _M_getword(__pos) &= ~_S_maskbit(__pos);\n+    return *this;\n+  }\n+\n+  bitset<_Nb,_WordT>& _Unchecked_flip(size_t __pos) {\n+    _M_getword(__pos) ^= _S_maskbit(__pos);\n+    return *this;\n+  }\n+\n+  bool _Unchecked_test(size_t __pos) const {\n+    return (_M_getword(__pos) & _S_maskbit(__pos)) != static_cast<_WordT>(0);\n+  }\n+\n+  // Set, reset, and flip.\n+\n+  bitset<_Nb,_WordT>& set() {\n+    _M_do_set();\n+    _M_do_sanitize();\n+    return *this;\n+  }\n+\n+  bitset<_Nb,_WordT>& set(size_t __pos) {\n+    if (__pos >= _Nb)\n+      __STL_THROW(out_of_range(\"bitset\"));\n+\n+    return _Unchecked_set(__pos);\n+  }\n+\n+  bitset<_Nb,_WordT>& set(size_t __pos, int __val) {\n+    if (__pos >= _Nb)\n+      __STL_THROW(out_of_range(\"bitset\"));\n+\n+    return _Unchecked_set(__pos, __val);\n+  }\n+\n+  bitset<_Nb,_WordT>& reset() {\n+    _M_do_reset();\n+    return *this;\n+  }\n+\n+  bitset<_Nb,_WordT>& reset(size_t __pos) {\n+    if (__pos >= _Nb)\n+      __STL_THROW(out_of_range(\"bitset\"));\n+\n+    return _Unchecked_reset(__pos);\n+  }\n+\n+  bitset<_Nb,_WordT>& flip() {\n+    _M_do_flip();\n+    _M_do_sanitize();\n+    return *this;\n+  }\n+\n+  bitset<_Nb,_WordT>& flip(size_t __pos) {\n+    if (__pos >= _Nb)\n+      __STL_THROW(out_of_range(\"bitset\"));\n+\n+    return _Unchecked_flip(__pos);\n+  }\n+\n+  bitset<_Nb,_WordT> operator~() const { \n+    return bitset<_Nb,_WordT>(*this).flip();\n+  }\n+\n+  // element access:\n+  //for b[i];\n+  reference operator[](size_t __pos) { return reference(*this,__pos); }\n+  bool operator[](size_t __pos) const { return _Unchecked_test(__pos); }\n+\n+  unsigned long to_ulong() const { return _M_do_to_ulong(); }\n+\n+#if __STL_EXPLICIT_FUNCTION_TMPL_ARGS\n+  template <class _CharT, class _Traits, class _Alloc>\n+  basic_string<_CharT, _Traits, _Alloc> to_string() const {\n+    basic_string<_CharT, _Traits, _Alloc> __result;\n+    _M_copy_to_string(__result);\n+    return __result;\n+  }\n+#endif /* __STL_EXPLICIT_FUNCTION_TMPL_ARGS */\n+\n+  // Helper functions for string operations.\n+  template<class _CharT, class _Traits, class _Alloc>\n+  void _M_copy_from_string(const basic_string<_CharT,_Traits,_Alloc>& __s,\n+                          size_t,\n+                          size_t);\n+\n+  // Helper functions for string operations.\n+  template<class _CharT, class _Traits, class _Alloc>\n+  void _M_copy_to_string(basic_string<_CharT,_Traits,_Alloc>&) const;\n+\n+  size_t count() const { return _M_do_count(); }\n+\n+  size_t size() const { return _Nb; }\n+\n+  bool operator==(const bitset<_Nb,_WordT>& __rhs) const {\n+    return _M_is_equal(__rhs);\n+  }\n+  bool operator!=(const bitset<_Nb,_WordT>& __rhs) const {\n+    return !_M_is_equal(__rhs);\n+  }\n+\n+  bool test(size_t __pos) const {\n+    if (__pos > _Nb)\n+      __STL_THROW(out_of_range(\"bitset\"));\n+\n+    return _Unchecked_test(__pos);\n+  }\n+\n+  bool any() const { return _M_is_any(); }\n+  bool none() const { return !_M_is_any(); }\n+\n+  bitset<_Nb,_WordT> operator<<(size_t __pos) const\n+    { return bitset<_Nb,_WordT>(*this) <<= __pos; }\n+  bitset<_Nb,_WordT> operator>>(size_t __pos) const\n+    { return bitset<_Nb,_WordT>(*this) >>= __pos; }\n+\n+  //\n+  // EXTENSIONS: bit-find operations.  These operations are\n+  // experimental, and are subject to change or removal in future\n+  // versions.\n+  // \n+\n+  // find the index of the first \"on\" bit\n+  size_t _Find_first() const \n+    { return _M_do_find_first(_Nb); }\n+\n+  // find the index of the next \"on\" bit after prev\n+  size_t _Find_next( size_t __prev ) const \n+    { return _M_do_find_next(__prev, _Nb); }\n+\n+};\n+\n+//\n+// Definitions of non-inline member functions.\n+//\n+\n+template <size_t _Nb, class _WordT>\n+template<class _CharT, class _Traits, class _Alloc>\n+void bitset<_Nb, _WordT>\n+  ::_M_copy_from_string(const basic_string<_CharT,_Traits,_Alloc>& __s,\n+                        size_t __pos,\n+                        size_t __n)\n+{\n+  reset();\n+  const size_t __nbits = min(_Nb, min(__n, __s.size() - __pos));\n+  for (size_t __i = 0; __i < __nbits; ++__i) {\n+    switch(__s[__pos + __nbits - __i - 1]) {\n+    case '0':\n+      break;\n+    case '1':\n+      set(__i);\n+      break;\n+    default:\n+      __STL_THROW(invalid_argument(\"bitset\"));\n+    }\n+  }\n+}\n+\n+template <size_t _Nb, class _WordT>\n+template <class _CharT, class _Traits, class _Alloc>\n+void bitset<_Nb, _WordT>\n+  ::_M_copy_to_string(basic_string<_CharT, _Traits, _Alloc>& __s) const\n+{\n+  __s.assign(_Nb, '0');\n+  \n+  for (size_t __i = 0; __i < _Nb; ++__i) \n+    if (_Unchecked_test(__i))\n+      __s[_Nb - 1 - __i] = '1';\n+}\n+\n+// ------------------------------------------------------------\n+\n+//\n+// 23.3.5.3 bitset operations:\n+//\n+\n+template <size_t _Nb, class _WordT>\n+inline bitset<_Nb,_WordT> operator&(const bitset<_Nb,_WordT>& __x,\n+                                    const bitset<_Nb,_WordT>& __y) {\n+  bitset<_Nb,_WordT> __result(__x);\n+  __result &= __y;\n+  return __result;\n+}\n+\n+\n+template <size_t _Nb, class _WordT>\n+inline bitset<_Nb,_WordT> operator|(const bitset<_Nb,_WordT>& __x,\n+                                    const bitset<_Nb,_WordT>& __y) {\n+  bitset<_Nb,_WordT> __result(__x);\n+  __result |= __y;\n+  return __result;\n+}\n+\n+template <size_t _Nb, class _WordT>\n+inline bitset<_Nb,_WordT> operator^(const bitset<_Nb,_WordT>& __x,\n+                                    const bitset<_Nb,_WordT>& __y) {\n+  bitset<_Nb,_WordT> __result(__x);\n+  __result ^= __y;\n+  return __result;\n+}\n+\n+// NOTE: these must be rewritten once we have templatized iostreams.\n+\n+template <size_t _Nb, class _WordT>\n+istream&\n+operator>>(istream& __is, bitset<_Nb,_WordT>& __x) {\n+  string __tmp;\n+  __tmp.reserve(_Nb);\n+\n+  // In new templatized iostreams, use istream::sentry\n+  if (__is.flags() & ios::skipws) {\n+    char __c;\n+    do \n+      __is.get(__c);\n+    while (__is && isspace(__c));\n+    if (__is)\n+      __is.putback(__c);\n+  }\n+\n+  for (size_t __i = 0; __i < _Nb; ++__i) {\n+    char __c;\n+    __is.get(__c);\n+\n+    if (!__is)\n+      break;\n+    else if (__c != '0' && __c != '1') {\n+      __is.putback(__c);\n+      break;\n+    }\n+    else\n+      __tmp.push_back(__c);\n+  }\n+\n+  if (__tmp.empty()) \n+    __is.clear(__is.rdstate() | ios::failbit);\n+  else\n+    __x._M_copy_from_string(__tmp, static_cast<size_t>(0), _Nb);\n+\n+  return __is;\n+}\n+\n+template <size_t _Nb, class _WordT>\n+ostream& operator<<(ostream& __os, const bitset<_Nb,_WordT>& __x) {\n+  string __tmp;\n+  __x._M_copy_to_string(__tmp);\n+  return __os << __tmp;\n+}\n+\n+// ------------------------------------------------------------\n+// Lookup tables for find and count operations.\n+\n+template<bool __dummy>\n+unsigned char _Bit_count<__dummy>::_S_bit_count[] = {\n+  0, /*   0 */ 1, /*   1 */ 1, /*   2 */ 2, /*   3 */ 1, /*   4 */\n+  2, /*   5 */ 2, /*   6 */ 3, /*   7 */ 1, /*   8 */ 2, /*   9 */\n+  2, /*  10 */ 3, /*  11 */ 2, /*  12 */ 3, /*  13 */ 3, /*  14 */\n+  4, /*  15 */ 1, /*  16 */ 2, /*  17 */ 2, /*  18 */ 3, /*  19 */\n+  2, /*  20 */ 3, /*  21 */ 3, /*  22 */ 4, /*  23 */ 2, /*  24 */\n+  3, /*  25 */ 3, /*  26 */ 4, /*  27 */ 3, /*  28 */ 4, /*  29 */\n+  4, /*  30 */ 5, /*  31 */ 1, /*  32 */ 2, /*  33 */ 2, /*  34 */\n+  3, /*  35 */ 2, /*  36 */ 3, /*  37 */ 3, /*  38 */ 4, /*  39 */\n+  2, /*  40 */ 3, /*  41 */ 3, /*  42 */ 4, /*  43 */ 3, /*  44 */\n+  4, /*  45 */ 4, /*  46 */ 5, /*  47 */ 2, /*  48 */ 3, /*  49 */\n+  3, /*  50 */ 4, /*  51 */ 3, /*  52 */ 4, /*  53 */ 4, /*  54 */\n+  5, /*  55 */ 3, /*  56 */ 4, /*  57 */ 4, /*  58 */ 5, /*  59 */\n+  4, /*  60 */ 5, /*  61 */ 5, /*  62 */ 6, /*  63 */ 1, /*  64 */\n+  2, /*  65 */ 2, /*  66 */ 3, /*  67 */ 2, /*  68 */ 3, /*  69 */\n+  3, /*  70 */ 4, /*  71 */ 2, /*  72 */ 3, /*  73 */ 3, /*  74 */\n+  4, /*  75 */ 3, /*  76 */ 4, /*  77 */ 4, /*  78 */ 5, /*  79 */\n+  2, /*  80 */ 3, /*  81 */ 3, /*  82 */ 4, /*  83 */ 3, /*  84 */\n+  4, /*  85 */ 4, /*  86 */ 5, /*  87 */ 3, /*  88 */ 4, /*  89 */\n+  4, /*  90 */ 5, /*  91 */ 4, /*  92 */ 5, /*  93 */ 5, /*  94 */\n+  6, /*  95 */ 2, /*  96 */ 3, /*  97 */ 3, /*  98 */ 4, /*  99 */\n+  3, /* 100 */ 4, /* 101 */ 4, /* 102 */ 5, /* 103 */ 3, /* 104 */\n+  4, /* 105 */ 4, /* 106 */ 5, /* 107 */ 4, /* 108 */ 5, /* 109 */\n+  5, /* 110 */ 6, /* 111 */ 3, /* 112 */ 4, /* 113 */ 4, /* 114 */\n+  5, /* 115 */ 4, /* 116 */ 5, /* 117 */ 5, /* 118 */ 6, /* 119 */\n+  4, /* 120 */ 5, /* 121 */ 5, /* 122 */ 6, /* 123 */ 5, /* 124 */\n+  6, /* 125 */ 6, /* 126 */ 7, /* 127 */ 1, /* 128 */ 2, /* 129 */\n+  2, /* 130 */ 3, /* 131 */ 2, /* 132 */ 3, /* 133 */ 3, /* 134 */\n+  4, /* 135 */ 2, /* 136 */ 3, /* 137 */ 3, /* 138 */ 4, /* 139 */\n+  3, /* 140 */ 4, /* 141 */ 4, /* 142 */ 5, /* 143 */ 2, /* 144 */\n+  3, /* 145 */ 3, /* 146 */ 4, /* 147 */ 3, /* 148 */ 4, /* 149 */\n+  4, /* 150 */ 5, /* 151 */ 3, /* 152 */ 4, /* 153 */ 4, /* 154 */\n+  5, /* 155 */ 4, /* 156 */ 5, /* 157 */ 5, /* 158 */ 6, /* 159 */\n+  2, /* 160 */ 3, /* 161 */ 3, /* 162 */ 4, /* 163 */ 3, /* 164 */\n+  4, /* 165 */ 4, /* 166 */ 5, /* 167 */ 3, /* 168 */ 4, /* 169 */\n+  4, /* 170 */ 5, /* 171 */ 4, /* 172 */ 5, /* 173 */ 5, /* 174 */\n+  6, /* 175 */ 3, /* 176 */ 4, /* 177 */ 4, /* 178 */ 5, /* 179 */\n+  4, /* 180 */ 5, /* 181 */ 5, /* 182 */ 6, /* 183 */ 4, /* 184 */\n+  5, /* 185 */ 5, /* 186 */ 6, /* 187 */ 5, /* 188 */ 6, /* 189 */\n+  6, /* 190 */ 7, /* 191 */ 2, /* 192 */ 3, /* 193 */ 3, /* 194 */\n+  4, /* 195 */ 3, /* 196 */ 4, /* 197 */ 4, /* 198 */ 5, /* 199 */\n+  3, /* 200 */ 4, /* 201 */ 4, /* 202 */ 5, /* 203 */ 4, /* 204 */\n+  5, /* 205 */ 5, /* 206 */ 6, /* 207 */ 3, /* 208 */ 4, /* 209 */\n+  4, /* 210 */ 5, /* 211 */ 4, /* 212 */ 5, /* 213 */ 5, /* 214 */\n+  6, /* 215 */ 4, /* 216 */ 5, /* 217 */ 5, /* 218 */ 6, /* 219 */\n+  5, /* 220 */ 6, /* 221 */ 6, /* 222 */ 7, /* 223 */ 3, /* 224 */\n+  4, /* 225 */ 4, /* 226 */ 5, /* 227 */ 4, /* 228 */ 5, /* 229 */\n+  5, /* 230 */ 6, /* 231 */ 4, /* 232 */ 5, /* 233 */ 5, /* 234 */\n+  6, /* 235 */ 5, /* 236 */ 6, /* 237 */ 6, /* 238 */ 7, /* 239 */\n+  4, /* 240 */ 5, /* 241 */ 5, /* 242 */ 6, /* 243 */ 5, /* 244 */\n+  6, /* 245 */ 6, /* 246 */ 7, /* 247 */ 5, /* 248 */ 6, /* 249 */\n+  6, /* 250 */ 7, /* 251 */ 6, /* 252 */ 7, /* 253 */ 7, /* 254 */\n+  8  /* 255 */\n+}; // end _Bit_count\n+\n+template<bool __dummy>\n+unsigned char _First_one<__dummy>::_S_first_one[] = {\n+  0, /*   0 */ 0, /*   1 */ 1, /*   2 */ 0, /*   3 */ 2, /*   4 */\n+  0, /*   5 */ 1, /*   6 */ 0, /*   7 */ 3, /*   8 */ 0, /*   9 */\n+  1, /*  10 */ 0, /*  11 */ 2, /*  12 */ 0, /*  13 */ 1, /*  14 */\n+  0, /*  15 */ 4, /*  16 */ 0, /*  17 */ 1, /*  18 */ 0, /*  19 */\n+  2, /*  20 */ 0, /*  21 */ 1, /*  22 */ 0, /*  23 */ 3, /*  24 */\n+  0, /*  25 */ 1, /*  26 */ 0, /*  27 */ 2, /*  28 */ 0, /*  29 */\n+  1, /*  30 */ 0, /*  31 */ 5, /*  32 */ 0, /*  33 */ 1, /*  34 */\n+  0, /*  35 */ 2, /*  36 */ 0, /*  37 */ 1, /*  38 */ 0, /*  39 */\n+  3, /*  40 */ 0, /*  41 */ 1, /*  42 */ 0, /*  43 */ 2, /*  44 */\n+  0, /*  45 */ 1, /*  46 */ 0, /*  47 */ 4, /*  48 */ 0, /*  49 */\n+  1, /*  50 */ 0, /*  51 */ 2, /*  52 */ 0, /*  53 */ 1, /*  54 */\n+  0, /*  55 */ 3, /*  56 */ 0, /*  57 */ 1, /*  58 */ 0, /*  59 */\n+  2, /*  60 */ 0, /*  61 */ 1, /*  62 */ 0, /*  63 */ 6, /*  64 */\n+  0, /*  65 */ 1, /*  66 */ 0, /*  67 */ 2, /*  68 */ 0, /*  69 */\n+  1, /*  70 */ 0, /*  71 */ 3, /*  72 */ 0, /*  73 */ 1, /*  74 */\n+  0, /*  75 */ 2, /*  76 */ 0, /*  77 */ 1, /*  78 */ 0, /*  79 */\n+  4, /*  80 */ 0, /*  81 */ 1, /*  82 */ 0, /*  83 */ 2, /*  84 */\n+  0, /*  85 */ 1, /*  86 */ 0, /*  87 */ 3, /*  88 */ 0, /*  89 */\n+  1, /*  90 */ 0, /*  91 */ 2, /*  92 */ 0, /*  93 */ 1, /*  94 */\n+  0, /*  95 */ 5, /*  96 */ 0, /*  97 */ 1, /*  98 */ 0, /*  99 */\n+  2, /* 100 */ 0, /* 101 */ 1, /* 102 */ 0, /* 103 */ 3, /* 104 */\n+  0, /* 105 */ 1, /* 106 */ 0, /* 107 */ 2, /* 108 */ 0, /* 109 */\n+  1, /* 110 */ 0, /* 111 */ 4, /* 112 */ 0, /* 113 */ 1, /* 114 */\n+  0, /* 115 */ 2, /* 116 */ 0, /* 117 */ 1, /* 118 */ 0, /* 119 */\n+  3, /* 120 */ 0, /* 121 */ 1, /* 122 */ 0, /* 123 */ 2, /* 124 */\n+  0, /* 125 */ 1, /* 126 */ 0, /* 127 */ 7, /* 128 */ 0, /* 129 */\n+  1, /* 130 */ 0, /* 131 */ 2, /* 132 */ 0, /* 133 */ 1, /* 134 */\n+  0, /* 135 */ 3, /* 136 */ 0, /* 137 */ 1, /* 138 */ 0, /* 139 */\n+  2, /* 140 */ 0, /* 141 */ 1, /* 142 */ 0, /* 143 */ 4, /* 144 */\n+  0, /* 145 */ 1, /* 146 */ 0, /* 147 */ 2, /* 148 */ 0, /* 149 */\n+  1, /* 150 */ 0, /* 151 */ 3, /* 152 */ 0, /* 153 */ 1, /* 154 */\n+  0, /* 155 */ 2, /* 156 */ 0, /* 157 */ 1, /* 158 */ 0, /* 159 */\n+  5, /* 160 */ 0, /* 161 */ 1, /* 162 */ 0, /* 163 */ 2, /* 164 */\n+  0, /* 165 */ 1, /* 166 */ 0, /* 167 */ 3, /* 168 */ 0, /* 169 */\n+  1, /* 170 */ 0, /* 171 */ 2, /* 172 */ 0, /* 173 */ 1, /* 174 */\n+  0, /* 175 */ 4, /* 176 */ 0, /* 177 */ 1, /* 178 */ 0, /* 179 */\n+  2, /* 180 */ 0, /* 181 */ 1, /* 182 */ 0, /* 183 */ 3, /* 184 */\n+  0, /* 185 */ 1, /* 186 */ 0, /* 187 */ 2, /* 188 */ 0, /* 189 */\n+  1, /* 190 */ 0, /* 191 */ 6, /* 192 */ 0, /* 193 */ 1, /* 194 */\n+  0, /* 195 */ 2, /* 196 */ 0, /* 197 */ 1, /* 198 */ 0, /* 199 */\n+  3, /* 200 */ 0, /* 201 */ 1, /* 202 */ 0, /* 203 */ 2, /* 204 */\n+  0, /* 205 */ 1, /* 206 */ 0, /* 207 */ 4, /* 208 */ 0, /* 209 */\n+  1, /* 210 */ 0, /* 211 */ 2, /* 212 */ 0, /* 213 */ 1, /* 214 */\n+  0, /* 215 */ 3, /* 216 */ 0, /* 217 */ 1, /* 218 */ 0, /* 219 */\n+  2, /* 220 */ 0, /* 221 */ 1, /* 222 */ 0, /* 223 */ 5, /* 224 */\n+  0, /* 225 */ 1, /* 226 */ 0, /* 227 */ 2, /* 228 */ 0, /* 229 */\n+  1, /* 230 */ 0, /* 231 */ 3, /* 232 */ 0, /* 233 */ 1, /* 234 */\n+  0, /* 235 */ 2, /* 236 */ 0, /* 237 */ 1, /* 238 */ 0, /* 239 */\n+  4, /* 240 */ 0, /* 241 */ 1, /* 242 */ 0, /* 243 */ 2, /* 244 */\n+  0, /* 245 */ 1, /* 246 */ 0, /* 247 */ 3, /* 248 */ 0, /* 249 */\n+  1, /* 250 */ 0, /* 251 */ 2, /* 252 */ 0, /* 253 */ 1, /* 254 */\n+  0, /* 255 */\n+}; // end _First_one\n+\n+#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n+#pragma reset woff 1209\n+#endif\n+\n+__STL_END_NAMESPACE\n+\n+\n+#undef __BITS_PER_WORDT\n+#undef __BITSET_WORDS\n+\n+#endif /* __SGI_STL_BITSET */\n+\n+\n+// Local Variables:\n+// mode:C++\n+// End:\n+"}, {"sha": "44ec2fb60e48067ce1235a9d73daf8dbf933920b", "filename": "libstdc++/stl/char_traits.h", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/768a887ca725d06c7ec1fff85e00e1ee2e528d5d/libstdc%2B%2B%2Fstl%2Fchar_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/768a887ca725d06c7ec1fff85e00e1ee2e528d5d/libstdc%2B%2B%2Fstl%2Fchar_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fchar_traits.h?ref=768a887ca725d06c7ec1fff85e00e1ee2e528d5d", "patch": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright (c) 1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */ \n+\n+#ifndef __SGI_STL_CHAR_TRAITS_H\n+#define __SGI_STL_CHAR_TRAITS_H\n+\n+#include <string.h>\n+#include <wchar.h>\n+\n+__STL_BEGIN_NAMESPACE\n+\n+// Class __char_traits_base.\n+\n+template <class _CharT, class _IntT> struct __char_traits_base {\n+  typedef _CharT char_type;\n+  typedef _IntT int_type;\n+  // typedef streamoff off_type;\n+  // typedef streampos pos_type;\n+  // typedef mbstate_t state_type;\n+\n+  static void assign(char_type& __c1, const char_type& __c2) { __c1 = __c2; }\n+  static bool eq(const _CharT& __c1, const _CharT& __c2) \n+    { return __c1 == __c2; }\n+  static bool lt(const _CharT& __c1, const _CharT& __c2) \n+    { return __c1 < __c2; }\n+\n+  static int compare(const _CharT* __s1, const _CharT* __s2, size_t __n) {\n+    for (size_t __i = 0; __i < __n; ++__i)\n+      if (!eq(__s1[__i], __s2[__i]))\n+        return __s1[__i] < __s2[__i] ? -1 : 1;\n+    return 0;\n+  }\n+\n+  static size_t length(const _CharT* __s) {\n+    const _CharT __null = _CharT();\n+    size_t __i;\n+    for (__i = 0; !eq(__s[__i], __null); ++__i)\n+      {}\n+    return __i;\n+  }\n+\n+  static const _CharT* find(const _CharT* __s, size_t __n, const _CharT& __c)\n+  {\n+    for ( ; __n > 0 ; ++__s, --__n)\n+      if (eq(*__s, __c))\n+        return __s;\n+    return 0;\n+  }\n+\n+  static _CharT* move(_CharT* __s1, const _CharT* __s2, size_t __n) {\n+    memmove(__s1, __s2, __n * sizeof(_CharT));\n+    return __s1;\n+  }\n+    \n+  static _CharT* copy(_CharT* __s1, const _CharT* __s2, size_t __n) {\n+    memcpy(__s1, __s2, __n * sizeof(_CharT));\n+    return __s1;\n+  } \n+\n+  static _CharT* assign(_CharT* __s, size_t __n, _CharT __c) {\n+    for (size_t __i = 0; __i < __n; ++__i)\n+      __s[__i] = __c;\n+    return __s;\n+  }\n+\n+  static int_type not_eof(const int_type& __c) {\n+    return !eq(__c, eof()) ? __c : 0;\n+  }\n+\n+  static char_type to_char_type(const int_type& __c) {\n+    return static_cast<char_type>(__c);\n+  }\n+\n+  static int_type to_int_type(const char_type& __c) {\n+    return static_cast<int_type>(__c);\n+  }\n+\n+  static bool eq_int_type(const int_type& __c1, const int_type& __c2) {\n+    return __c1 == __c2;\n+  }\n+\n+  static int_type eof() {\n+    return static_cast<int_type>(-1);\n+  }\n+};\n+\n+// Generic char_traits class.  Note that this class is provided only\n+//  as a base for explicit specialization; it is unlikely to be useful\n+//  as is for any particular user-defined type.  In particular, it \n+//  *will not work* for a non-POD type.\n+\n+template <class _CharT> struct char_traits\n+  : public __char_traits_base<_CharT, _CharT>\n+{};\n+\n+// Specialization for char.\n+\n+template<> struct char_traits<char> \n+  : public __char_traits_base<char, int>\n+{\n+  static int compare(const char* __s1, const char* __s2, size_t __n) \n+    { return memcmp(__s1, __s2, __n); }\n+  \n+  static size_t length(const char* __s) { return strlen(__s); }\n+\n+  static void assign(char& __c1, const char& __c2) { __c1 = __c2; }\n+\n+  static char* assign(char* __s, size_t __n, char __c)\n+    { memset(__s, __c, __n); return __s; }\n+};\n+\n+// Specialization for wchar_t.\n+\n+template<> struct char_traits<wchar_t>\n+  : public __char_traits_base<wchar_t, wint_t>\n+{};\n+\n+__STL_END_NAMESPACE\n+\n+#endif /* __SGI_STL_CHAR_TRAITS_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:\n+"}]}