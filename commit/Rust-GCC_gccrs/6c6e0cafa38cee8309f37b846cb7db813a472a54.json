{"sha": "6c6e0cafa38cee8309f37b846cb7db813a472a54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM2ZTBjYWZhMzhjZWU4MzA5ZjM3Yjg0NmNiN2RiODEzYTQ3MmE1NA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-14T13:37:51Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-16T11:44:37Z"}, "message": "Adjust BB vectorization SLP build heuristics\n\nThis changes SLP def gathering to not fail due to mismatched\ndef type but instead demote the def to external.  This allows the\nnew testcase to be vectorized in full (with GCC 10 it is not\nvectorized at all and with current trunk we vectorize only the\nstore).  This is important since with BB vectorization being\napplied to bigger pieces of code the chance that we mix\ninternal and external defs for an operand that should end up\ntreated as external (built from scalars) increases.\n\n2020-10-16  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-slp.c (vect_get_and_check_slp_defs): For BB\n\tvectorization swap operands only if it helps, demote mismatches to\n\texternal.\n\n\t* gcc.dg/vect/bb-slp-53.c: New testcase.", "tree": {"sha": "be453072dd2cb2876e9f70853057e27b043f5af7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be453072dd2cb2876e9f70853057e27b043f5af7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c6e0cafa38cee8309f37b846cb7db813a472a54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c6e0cafa38cee8309f37b846cb7db813a472a54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c6e0cafa38cee8309f37b846cb7db813a472a54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c6e0cafa38cee8309f37b846cb7db813a472a54/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "377535881166969dba43794f298170978d797ef6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/377535881166969dba43794f298170978d797ef6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/377535881166969dba43794f298170978d797ef6"}], "stats": {"total": 51, "additions": 45, "deletions": 6}, "files": [{"sha": "f3b5f31744403874862598b1f6c8a435ce410ec0", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-53.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c6e0cafa38cee8309f37b846cb7db813a472a54/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-53.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c6e0cafa38cee8309f37b846cb7db813a472a54/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-53.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-53.c?ref=6c6e0cafa38cee8309f37b846cb7db813a472a54", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_double } */\n+\n+double a[2], b[2];\n+\n+void foo(double x, double y)\n+{\n+  double breakme1 = y + 3.;\n+  double a1 = b[1] + 2.;\n+  double breakme0 = x;\n+  double a0 = b[0] + 1.;\n+  a[0] = a0 * breakme0;\n+  a[1] = a1 * breakme1;\n+}\n+\n+/* We should vectorize the SLP opportunity starting from the\n+   grouped store to a[] including the load from b[] at the\n+   leaf even though the multiplication requires another\n+   vector invariant to be built.  */\n+/* { dg-final { scan-tree-dump \"transform load\" \"slp2\" } } */"}, {"sha": "c3e6d67067cbf8ca77be54df8a1b954a347e0eb0", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c6e0cafa38cee8309f37b846cb7db813a472a54/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c6e0cafa38cee8309f37b846cb7db813a472a54/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=6c6e0cafa38cee8309f37b846cb7db813a472a54", "patch": "@@ -564,8 +564,15 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char swap,\n \t\t      != (oprnd_info->first_dt != vect_reduction_def))))\n \t    {\n \t      /* Try swapping operands if we got a mismatch.  For BB\n-\t\t vectorization only in case that will improve things.  */\n-\t      if (i == commutative_op && !swapped)\n+\t\t vectorization only in case it will clearly improve things.  */\n+\t      if (i == commutative_op && !swapped\n+\t\t  && (!is_a <bb_vec_info> (vinfo)\n+\t\t      || (!vect_def_types_match ((*oprnds_info)[i+1]->first_dt,\n+\t\t\t\t\t\t dts[i+1])\n+\t\t\t  && (vect_def_types_match (oprnd_info->first_dt,\n+\t\t\t\t\t\t    dts[i+1])\n+\t\t\t      || vect_def_types_match\n+\t\t\t\t   ((*oprnds_info)[i+1]->first_dt, dts[i])))))\n \t\t{\n \t\t  if (dump_enabled_p ())\n \t\t    dump_printf_loc (MSG_NOTE, vect_location,\n@@ -579,10 +586,22 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char swap,\n \t\t  continue;\n \t\t}\n \n-\t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t \"Build SLP failed: different types\\n\");\n-\t      return 1;\n+\t      if (is_a <bb_vec_info> (vinfo))\n+\t\t{\n+\t\t  /* Now for commutative ops we should see whether we can\n+\t\t     make the other operand matching.  */\n+\t\t  if (dump_enabled_p ())\n+\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t     \"treating operand as external\\n\");\n+\t\t  oprnd_info->first_dt = dt = vect_external_def;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (dump_enabled_p ())\n+\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t     \"Build SLP failed: different types\\n\");\n+\t\t  return 1;\n+\t\t}\n \t    }\n \n       /* Make sure to demote the overall operand to external.  */"}]}