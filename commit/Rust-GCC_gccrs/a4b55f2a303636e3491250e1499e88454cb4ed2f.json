{"sha": "a4b55f2a303636e3491250e1499e88454cb4ed2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTRiNTVmMmEzMDM2MzZlMzQ5MTI1MGUxNDk5ZTg4NDU0Y2I0ZWQyZg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2015-03-14T08:54:08Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2015-03-14T08:54:08Z"}, "message": "re PR rtl-optimization/65401 (make_field_assignment broken for big-endian)\n\n\tPR rtl-optimization/65401\n\t* combine.c (rtx_equal_for_field_assignment_p): Add widen_x\n\targument.  If true, adjust_address_nv of x with big-endian\n\tcorrection for the mode widening to GET_MODE (y).\n\t(make_field_assignment): Don't do MEM mode widening here.\n\tUse MEM_P instead of GET_CODE == MEM.\n\n\t* gcc.c-torture/execute/pr65401.c: New test.\n\nFrom-SVN: r221433", "tree": {"sha": "bc114b2b6eba0116cb808d58d4045446b9a73fd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc114b2b6eba0116cb808d58d4045446b9a73fd8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4b55f2a303636e3491250e1499e88454cb4ed2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4b55f2a303636e3491250e1499e88454cb4ed2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4b55f2a303636e3491250e1499e88454cb4ed2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4b55f2a303636e3491250e1499e88454cb4ed2f/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "efdea4d54b2af7ad3ef5dd3f1a0ca5284e60a33c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efdea4d54b2af7ad3ef5dd3f1a0ca5284e60a33c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efdea4d54b2af7ad3ef5dd3f1a0ca5284e60a33c"}], "stats": {"total": 110, "additions": 98, "deletions": 12}, "files": [{"sha": "e62f67b5ce5ccf7898c46ffb1783fd4f0797e95e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4b55f2a303636e3491250e1499e88454cb4ed2f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4b55f2a303636e3491250e1499e88454cb4ed2f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a4b55f2a303636e3491250e1499e88454cb4ed2f", "patch": "@@ -1,3 +1,12 @@\n+2015-03-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR rtl-optimization/65401\n+\t* combine.c (rtx_equal_for_field_assignment_p): Add widen_x\n+\targument.  If true, adjust_address_nv of x with big-endian\n+\tcorrection for the mode widening to GET_MODE (y).\n+\t(make_field_assignment): Don't do MEM mode widening here.\n+\tUse MEM_P instead of GET_CODE == MEM.\n+\n 2015-03-13  Ilya Verbin  <ilya.verbin@intel.com>\n \n \t* varpool.c (varpool_node::get_create): Don't set 'offloadable' flag for"}, {"sha": "71e5690459d5e61f052c02920ab7c9f2d38b2dc4", "filename": "gcc/combine.c", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4b55f2a303636e3491250e1499e88454cb4ed2f/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4b55f2a303636e3491250e1499e88454cb4ed2f/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=a4b55f2a303636e3491250e1499e88454cb4ed2f", "patch": "@@ -475,7 +475,7 @@ static rtx force_to_mode (rtx, machine_mode,\n \t\t\t  unsigned HOST_WIDE_INT, int);\n static rtx if_then_else_cond (rtx, rtx *, rtx *);\n static rtx known_cond (rtx, enum rtx_code, rtx, rtx);\n-static int rtx_equal_for_field_assignment_p (rtx, rtx);\n+static int rtx_equal_for_field_assignment_p (rtx, rtx, bool = false);\n static rtx make_field_assignment (rtx);\n static rtx apply_distributive_law (rtx);\n static rtx distribute_and_simplify_rtx (rtx, int);\n@@ -9184,8 +9184,23 @@ known_cond (rtx x, enum rtx_code cond, rtx reg, rtx val)\n    assignment as a field assignment.  */\n \n static int\n-rtx_equal_for_field_assignment_p (rtx x, rtx y)\n+rtx_equal_for_field_assignment_p (rtx x, rtx y, bool widen_x)\n {\n+  if (widen_x && GET_MODE (x) != GET_MODE (y))\n+    {\n+      if (GET_MODE_SIZE (GET_MODE (x)) > GET_MODE_SIZE (GET_MODE (y)))\n+\treturn 0;\n+      if (BYTES_BIG_ENDIAN != WORDS_BIG_ENDIAN)\n+\treturn 0;\n+      /* For big endian, adjust the memory offset.  */\n+      if (BYTES_BIG_ENDIAN)\n+\tx = adjust_address_nv (x, GET_MODE (y),\n+\t\t\t       -subreg_lowpart_offset (GET_MODE (x),\n+\t\t\t\t\t\t       GET_MODE (y)));\n+      else\n+\tx = adjust_address_nv (x, GET_MODE (y), 0);\n+    }\n+\n   if (x == y || rtx_equal_p (x, y))\n     return 1;\n \n@@ -9339,16 +9354,15 @@ make_field_assignment (rtx x)\n   /* The second SUBREG that might get in the way is a paradoxical\n      SUBREG around the first operand of the AND.  We want to \n      pretend the operand is as wide as the destination here.   We\n-     do this by creating a new MEM in the wider mode for the sole\n+     do this by adjusting the MEM to wider mode for the sole\n      purpose of the call to rtx_equal_for_field_assignment_p.   Also\n      note this trick only works for MEMs.  */\n   else if (GET_CODE (rhs) == AND\n \t   && paradoxical_subreg_p (XEXP (rhs, 0))\n-\t   && GET_CODE (SUBREG_REG (XEXP (rhs, 0))) == MEM\n+\t   && MEM_P (SUBREG_REG (XEXP (rhs, 0)))\n \t   && CONST_INT_P (XEXP (rhs, 1))\n-\t   && rtx_equal_for_field_assignment_p (gen_rtx_MEM (GET_MODE (dest),\n-\t\t\t\t\t\t\t     XEXP (SUBREG_REG (XEXP (rhs, 0)), 0)),\n-\t\t\t\t\t\tdest))\n+\t   && rtx_equal_for_field_assignment_p (SUBREG_REG (XEXP (rhs, 0)),\n+\t\t\t\t\t\tdest, true))\n     c1 = INTVAL (XEXP (rhs, 1)), other = lhs;\n   else if (GET_CODE (lhs) == AND\n \t   && CONST_INT_P (XEXP (lhs, 1))\n@@ -9357,16 +9371,15 @@ make_field_assignment (rtx x)\n   /* The second SUBREG that might get in the way is a paradoxical\n      SUBREG around the first operand of the AND.  We want to \n      pretend the operand is as wide as the destination here.   We\n-     do this by creating a new MEM in the wider mode for the sole\n+     do this by adjusting the MEM to wider mode for the sole\n      purpose of the call to rtx_equal_for_field_assignment_p.   Also\n      note this trick only works for MEMs.  */\n   else if (GET_CODE (lhs) == AND\n \t   && paradoxical_subreg_p (XEXP (lhs, 0))\n-\t   && GET_CODE (SUBREG_REG (XEXP (lhs, 0))) == MEM\n+\t   && MEM_P (SUBREG_REG (XEXP (lhs, 0)))\n \t   && CONST_INT_P (XEXP (lhs, 1))\n-\t   && rtx_equal_for_field_assignment_p (gen_rtx_MEM (GET_MODE (dest),\n-\t\t\t\t\t\t\t     XEXP (SUBREG_REG (XEXP (lhs, 0)), 0)),\n-\t\t\t\t\t\tdest))\n+\t   && rtx_equal_for_field_assignment_p (SUBREG_REG (XEXP (lhs, 0)),\n+\t\t\t\t\t\tdest, true))\n     c1 = INTVAL (XEXP (lhs, 1)), other = rhs;\n   else\n     return x;"}, {"sha": "d9a46cbfb6690632d12efad84e9900a884008075", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4b55f2a303636e3491250e1499e88454cb4ed2f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4b55f2a303636e3491250e1499e88454cb4ed2f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a4b55f2a303636e3491250e1499e88454cb4ed2f", "patch": "@@ -1,3 +1,8 @@\n+2015-03-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR rtl-optimization/65401\n+\t* gcc.c-torture/execute/pr65401.c: New test.\n+\n 2015-03-13  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \tPR target/64600"}, {"sha": "82cfafc04c0614b3acc1e4cb6a8821ce64b4f65d", "filename": "gcc/testsuite/gcc.c-torture/execute/pr65401.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4b55f2a303636e3491250e1499e88454cb4ed2f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr65401.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4b55f2a303636e3491250e1499e88454cb4ed2f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr65401.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr65401.c?ref=a4b55f2a303636e3491250e1499e88454cb4ed2f", "patch": "@@ -0,0 +1,59 @@\n+/* PR rtl-optimization/65401 */\n+\n+struct S { unsigned short s[64]; };\n+\n+__attribute__((noinline, noclone)) void\n+foo (struct S *x)\n+{\n+  unsigned int i;\n+  unsigned char *s;\n+\n+  s = (unsigned char *) x->s;\n+  for (i = 0; i < 64; i++)\n+    x->s[i] = s[i * 2] | (s[i * 2 + 1] << 8);\n+}  \n+\n+__attribute__((noinline, noclone)) void\n+bar (struct S *x)\n+{\n+  unsigned int i;\n+  unsigned char *s;\n+\n+  s = (unsigned char *) x->s;\n+  for (i = 0; i < 64; i++)\n+    x->s[i] = (s[i * 2] << 8) | s[i * 2 + 1];\n+}  \n+\n+int\n+main ()\n+{\n+  unsigned int i;\n+  struct S s;\n+  if (sizeof (unsigned short) != 2)\n+    return 0;\n+  for (i = 0; i < 64; i++)\n+    s.s[i] = i + ((64 - i) << 8);\n+  foo (&s);\n+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+  for (i = 0; i < 64; i++)\n+    if (s.s[i] != (64 - i) + (i << 8))\n+      __builtin_abort ();\n+#elif __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+  for (i = 0; i < 64; i++)\n+    if (s.s[i] != i + ((64 - i) << 8))\n+      __builtin_abort ();\n+#endif\n+  for (i = 0; i < 64; i++)\n+    s.s[i] = i + ((64 - i) << 8);\n+  bar (&s);\n+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+  for (i = 0; i < 64; i++)\n+    if (s.s[i] != (64 - i) + (i << 8))\n+      __builtin_abort ();\n+#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+  for (i = 0; i < 64; i++)\n+    if (s.s[i] != i + ((64 - i) << 8))\n+      __builtin_abort ();\n+#endif\n+  return 0;\n+}"}]}