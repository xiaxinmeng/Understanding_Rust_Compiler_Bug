{"sha": "362d42dcc965c63977160984292b3429c2d15de7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzYyZDQyZGNjOTY1YzYzOTc3MTYwOTg0MjkyYjM0MjljMmQxNWRlNw==", "commit": {"author": {"name": "Kugan Vivekanandarajah", "email": "kuganv@linaro.org", "date": "2014-08-08T05:24:12Z"}, "committer": {"name": "Kugan Vivekanandarajah", "email": "kugan@gcc.gnu.org", "date": "2014-08-08T05:24:12Z"}, "message": "calls.c (precompute_arguments): Use new SUBREG_PROMOTED_SET instead of SUBREG_PROMOTED_UNSIGNED_SET.\n\ngcc/\n2014-08-08  Kugan Vivekanandarajah  <kuganv@linaro.org>\n\n\t* calls.c (precompute_arguments): Use new SUBREG_PROMOTED_SET\n\tinstead of SUBREG_PROMOTED_UNSIGNED_SET.\n\t(expand_call): Likewise.\n\t* cfgexpand.c (expand_gimple_stmt_1): Use SUBREG_PROMOTED_SIGN\n\tto get promoted mode.\n\t* combine.c (record_promoted_value): Skip > 0 comparison with\n\tSUBREG_PROMOTED_UNSIGNED_P as it now returns only 0 or 1.\n\t* expr.c (convert_move): Use SUBREG_CHECK_PROMOTED_SIGN instead\n\tof SUBREG_PROMOTED_UNSIGNED_P.\n\t(convert_modes): Likewise.\n\t(store_expr): Use SUBREG_PROMOTED_SIGN to get promoted mode.\n\tUse SUBREG_CHECK_PROMOTED_SIGN instead of SUBREG_PROMOTED_UNSIGNED_P.\n\t(expand_expr_real_1): Use new SUBREG_PROMOTED_SET instead of\n\tSUBREG_PROMOTED_UNSIGNED_SET.\n\t* function.c (assign_parm_setup_reg): Use new SUBREG_PROMOTED_SET\n\tinstead of SUBREG_PROMOTED_UNSIGNED_SET.\n\t* ifcvt.c (noce_emit_cmove): Updated to use SUBREG_PROMOTED_GET and\n\tSUBREG_PROMOTED_SET.\n\t* internal-fn.c (ubsan_expand_si_overflow_mul_check): Use\n\tSUBREG_PROMOTED_SET instead of SUBREG_PROMOTED_UNSIGNED_SET.\n\t* optabs.c (widen_operand): Use SUBREG_CHECK_PROMOTED_SIGN instead\n\tof SUBREG_PROMOTED_UNSIGNED_P.\n\t* rtl.h (SUBREG_PROMOTED_UNSIGNED_SET): Remove.\n\t(SUBREG_PROMOTED_SET): New define.\n\t(SUBREG_PROMOTED_GET): Likewise.\n\t(SUBREG_PROMOTED_SIGN): Likewise.\n\t(SUBREG_PROMOTED_SIGNED_P): Likewise.\n\t(SUBREG_CHECK_PROMOTED_SIGN): Likewise.\n\t(SUBREG_PROMOTED_UNSIGNED_P): Updated.\n\t* rtlanal.c (unsigned_reg_p): Use new SUBREG_PROMOTED_GET\n\tinstead of SUBREG_PROMOTED_UNSIGNED_GET.\n\t(nonzero_bits1): Skip > 0 comparison with the results as\n\tSUBREG_PROMOTED_UNSIGNED_P now returns only 0 or 1.\n\t(num_sign_bit_copies1): Use SUBREG_PROMOTED_SIGNED_P instead\n\tof !SUBREG_PROMOTED_UNSIGNED_P.\n\t* simplify-rtx.c (simplify_unary_operation_1): Use new\n\tSUBREG_PROMOTED_SIGNED_P instead of !SUBREG_PROMOTED_UNSIGNED_P.\n\t(simplify_subreg): Use new SUBREG_PROMOTED_SIGNED_P,\n\tSUBREG_PROMOTED_UNSIGNED_P and SUBREG_PROMOTED_SET instead of\n\tSUBREG_PROMOTED_UNSIGNED_P and SUBREG_PROMOTED_UNSIGNED_SET.\n\nFrom-SVN: r213749", "tree": {"sha": "dc76a9c031ef039c59b55789766d2c9bad7a1fa0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc76a9c031ef039c59b55789766d2c9bad7a1fa0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/362d42dcc965c63977160984292b3429c2d15de7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/362d42dcc965c63977160984292b3429c2d15de7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/362d42dcc965c63977160984292b3429c2d15de7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/362d42dcc965c63977160984292b3429c2d15de7/comments", "author": null, "committer": null, "parents": [{"sha": "07ad7382cfd7461069131d0bd23d9e88c1d089de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07ad7382cfd7461069131d0bd23d9e88c1d089de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07ad7382cfd7461069131d0bd23d9e88c1d089de"}], "stats": {"total": 183, "additions": 135, "deletions": 48}, "files": [{"sha": "e9cdcc04b465f3b0286d3a96e9dd873b557eb808", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/362d42dcc965c63977160984292b3429c2d15de7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/362d42dcc965c63977160984292b3429c2d15de7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=362d42dcc965c63977160984292b3429c2d15de7", "patch": "@@ -1,3 +1,46 @@\n+2014-08-08  Kugan Vivekanandarajah  <kuganv@linaro.org>\n+\n+\t* calls.c (precompute_arguments): Use new SUBREG_PROMOTED_SET\n+\tinstead of SUBREG_PROMOTED_UNSIGNED_SET.\n+\t(expand_call): Likewise.\n+\t* cfgexpand.c (expand_gimple_stmt_1): Use SUBREG_PROMOTED_SIGN\n+\tto get promoted mode.\n+\t* combine.c (record_promoted_value): Skip > 0 comparison with\n+\tSUBREG_PROMOTED_UNSIGNED_P as it now returns only 0 or 1.\n+\t* expr.c (convert_move): Use SUBREG_CHECK_PROMOTED_SIGN instead\n+\tof SUBREG_PROMOTED_UNSIGNED_P.\n+\t(convert_modes): Likewise.\n+\t(store_expr): Use SUBREG_PROMOTED_SIGN to get promoted mode.\n+\tUse SUBREG_CHECK_PROMOTED_SIGN instead of SUBREG_PROMOTED_UNSIGNED_P.\n+\t(expand_expr_real_1): Use new SUBREG_PROMOTED_SET instead of\n+\tSUBREG_PROMOTED_UNSIGNED_SET.\n+\t* function.c (assign_parm_setup_reg): Use new SUBREG_PROMOTED_SET\n+\tinstead of SUBREG_PROMOTED_UNSIGNED_SET.\n+\t* ifcvt.c (noce_emit_cmove): Updated to use SUBREG_PROMOTED_GET and\n+\tSUBREG_PROMOTED_SET.\n+\t* internal-fn.c (ubsan_expand_si_overflow_mul_check): Use\n+\tSUBREG_PROMOTED_SET instead of SUBREG_PROMOTED_UNSIGNED_SET.\n+\t* optabs.c (widen_operand): Use SUBREG_CHECK_PROMOTED_SIGN instead\n+\tof SUBREG_PROMOTED_UNSIGNED_P.\n+\t* rtl.h (SUBREG_PROMOTED_UNSIGNED_SET): Remove.\n+\t(SUBREG_PROMOTED_SET): New define.\n+\t(SUBREG_PROMOTED_GET): Likewise.\n+\t(SUBREG_PROMOTED_SIGN): Likewise.\n+\t(SUBREG_PROMOTED_SIGNED_P): Likewise.\n+\t(SUBREG_CHECK_PROMOTED_SIGN): Likewise.\n+\t(SUBREG_PROMOTED_UNSIGNED_P): Updated.\n+\t* rtlanal.c (unsigned_reg_p): Use new SUBREG_PROMOTED_GET\n+\tinstead of SUBREG_PROMOTED_UNSIGNED_GET.\n+\t(nonzero_bits1): Skip > 0 comparison with the results as\n+\tSUBREG_PROMOTED_UNSIGNED_P now returns only 0 or 1.\n+\t(num_sign_bit_copies1): Use SUBREG_PROMOTED_SIGNED_P instead\n+\tof !SUBREG_PROMOTED_UNSIGNED_P.\n+\t* simplify-rtx.c (simplify_unary_operation_1): Use new\n+\tSUBREG_PROMOTED_SIGNED_P instead of !SUBREG_PROMOTED_UNSIGNED_P.\n+\t(simplify_subreg): Use new SUBREG_PROMOTED_SIGNED_P,\n+\tSUBREG_PROMOTED_UNSIGNED_P and SUBREG_PROMOTED_SET instead of\n+\tSUBREG_PROMOTED_UNSIGNED_P and SUBREG_PROMOTED_UNSIGNED_SET.\n+\n 2014-08-07  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-devirt.c: Include gimple-pretty-print.h"}, {"sha": "00c502858298dc68f6befbc6374a6a9f774ea6b9", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/362d42dcc965c63977160984292b3429c2d15de7/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/362d42dcc965c63977160984292b3429c2d15de7/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=362d42dcc965c63977160984292b3429c2d15de7", "patch": "@@ -1484,8 +1484,7 @@ precompute_arguments (int num_actuals, struct arg_data *args)\n \t      args[i].initial_value\n \t\t= gen_lowpart_SUBREG (mode, args[i].value);\n \t      SUBREG_PROMOTED_VAR_P (args[i].initial_value) = 1;\n-\t      SUBREG_PROMOTED_UNSIGNED_SET (args[i].initial_value,\n-\t\t\t\t\t    args[i].unsignedp);\n+\t      SUBREG_PROMOTED_SET (args[i].initial_value, args[i].unsignedp);\n \t    }\n \t}\n     }\n@@ -3365,7 +3364,7 @@ expand_call (tree exp, rtx target, int ignore)\n \n \t  target = gen_rtx_SUBREG (TYPE_MODE (type), target, offset);\n \t  SUBREG_PROMOTED_VAR_P (target) = 1;\n-\t  SUBREG_PROMOTED_UNSIGNED_SET (target, unsignedp);\n+\t  SUBREG_PROMOTED_SET (target, unsignedp);\n \t}\n \n       /* If size of args is variable or this was a constructor call for a stack"}, {"sha": "0e9410e0cc85a8065fd08646727abf698d847129", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/362d42dcc965c63977160984292b3429c2d15de7/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/362d42dcc965c63977160984292b3429c2d15de7/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=362d42dcc965c63977160984292b3429c2d15de7", "patch": "@@ -3308,7 +3308,7 @@ expand_gimple_stmt_1 (gimple stmt)\n \t      ;\n \t    else if (promoted)\n \t      {\n-\t\tint unsignedp = SUBREG_PROMOTED_UNSIGNED_P (target);\n+\t\tint unsignedp = SUBREG_PROMOTED_SIGN (target);\n \t\t/* If TEMP is a VOIDmode constant, use convert_modes to make\n \t\t   sure that we properly convert it.  */\n \t\tif (CONSTANT_P (temp) && GET_MODE (temp) == VOIDmode)"}, {"sha": "c3f0ae767ab89d019b3d64da9e46a9555e301211", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/362d42dcc965c63977160984292b3429c2d15de7/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/362d42dcc965c63977160984292b3429c2d15de7/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=362d42dcc965c63977160984292b3429c2d15de7", "patch": "@@ -12458,7 +12458,7 @@ record_promoted_value (rtx insn, rtx subreg)\n       rsp = &reg_stat[regno];\n       if (rsp->last_set == insn)\n \t{\n-\t  if (SUBREG_PROMOTED_UNSIGNED_P (subreg) > 0)\n+\t  if (SUBREG_PROMOTED_UNSIGNED_P (subreg))\n \t    rsp->last_set_nonzero_bits &= GET_MODE_MASK (mode);\n \t}\n "}, {"sha": "12420314fa09574428853a604bf8ec8bbe2ca4e9", "filename": "gcc/expr.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/362d42dcc965c63977160984292b3429c2d15de7/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/362d42dcc965c63977160984292b3429c2d15de7/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=362d42dcc965c63977160984292b3429c2d15de7", "patch": "@@ -329,7 +329,7 @@ convert_move (rtx to, rtx from, int unsignedp)\n   if (GET_CODE (from) == SUBREG && SUBREG_PROMOTED_VAR_P (from)\n       && (GET_MODE_PRECISION (GET_MODE (SUBREG_REG (from)))\n \t  >= GET_MODE_PRECISION (to_mode))\n-      && SUBREG_PROMOTED_UNSIGNED_P (from) == unsignedp)\n+      && SUBREG_CHECK_PROMOTED_SIGN (from, unsignedp))\n     from = gen_lowpart (to_mode, from), from_mode = to_mode;\n \n   gcc_assert (GET_CODE (to) != SUBREG || !SUBREG_PROMOTED_VAR_P (to));\n@@ -703,7 +703,7 @@ convert_modes (enum machine_mode mode, enum machine_mode oldmode, rtx x, int uns\n \n   if (GET_CODE (x) == SUBREG && SUBREG_PROMOTED_VAR_P (x)\n       && GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))) >= GET_MODE_SIZE (mode)\n-      && SUBREG_PROMOTED_UNSIGNED_P (x) == unsignedp)\n+      && SUBREG_CHECK_PROMOTED_SIGN (x, unsignedp))\n     x = gen_lowpart (mode, SUBREG_REG (x));\n \n   if (GET_MODE (x) != VOIDmode)\n@@ -5202,25 +5202,25 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n \t  && GET_MODE_PRECISION (GET_MODE (target))\n \t     == TYPE_PRECISION (TREE_TYPE (exp)))\n \t{\n-\t  if (TYPE_UNSIGNED (TREE_TYPE (exp))\n-\t      != SUBREG_PROMOTED_UNSIGNED_P (target))\n+\t  if (!SUBREG_CHECK_PROMOTED_SIGN (target,\n+\t\t\t\t\t  TYPE_UNSIGNED (TREE_TYPE (exp))))\n \t    {\n \t      /* Some types, e.g. Fortran's logical*4, won't have a signed\n \t\t version, so use the mode instead.  */\n \t      tree ntype\n \t\t= (signed_or_unsigned_type_for\n-\t\t   (SUBREG_PROMOTED_UNSIGNED_P (target), TREE_TYPE (exp)));\n+\t\t   (SUBREG_PROMOTED_SIGN (target), TREE_TYPE (exp)));\n \t      if (ntype == NULL)\n \t\tntype = lang_hooks.types.type_for_mode\n \t\t  (TYPE_MODE (TREE_TYPE (exp)),\n-\t\t   SUBREG_PROMOTED_UNSIGNED_P (target));\n+\t\t   SUBREG_PROMOTED_SIGN (target));\n \n \t      exp = fold_convert_loc (loc, ntype, exp);\n \t    }\n \n \t  exp = fold_convert_loc (loc, lang_hooks.types.type_for_mode\n \t\t\t\t  (GET_MODE (SUBREG_REG (target)),\n-\t\t\t\t   SUBREG_PROMOTED_UNSIGNED_P (target)),\n+\t\t\t\t   SUBREG_PROMOTED_SIGN (target)),\n \t\t\t\t  exp);\n \n \t  inner_target = SUBREG_REG (target);\n@@ -5234,14 +5234,14 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n       if (CONSTANT_P (temp) && GET_MODE (temp) == VOIDmode)\n \t{\n \t  temp = convert_modes (GET_MODE (target), TYPE_MODE (TREE_TYPE (exp)),\n-\t\t\t\ttemp, SUBREG_PROMOTED_UNSIGNED_P (target));\n+\t\t\t\ttemp, SUBREG_PROMOTED_SIGN (target));\n \t  temp = convert_modes (GET_MODE (SUBREG_REG (target)),\n \t\t\t        GET_MODE (target), temp,\n-\t\t\t        SUBREG_PROMOTED_UNSIGNED_P (target));\n+\t\t\t\tSUBREG_PROMOTED_SIGN (target));\n \t}\n \n       convert_move (SUBREG_REG (target), temp,\n-\t\t    SUBREG_PROMOTED_UNSIGNED_P (target));\n+\t\t    SUBREG_PROMOTED_SIGN (target));\n \n       return NULL_RTX;\n     }\n@@ -9527,7 +9527,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n \t  temp = gen_lowpart_SUBREG (mode, decl_rtl);\n \t  SUBREG_PROMOTED_VAR_P (temp) = 1;\n-\t  SUBREG_PROMOTED_UNSIGNED_SET (temp, unsignedp);\n+\t  SUBREG_PROMOTED_SET (temp, unsignedp);\n \t  return temp;\n \t}\n "}, {"sha": "a9153142d35f21b2db7f62851445c5f2a5edd292", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/362d42dcc965c63977160984292b3429c2d15de7/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/362d42dcc965c63977160984292b3429c2d15de7/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=362d42dcc965c63977160984292b3429c2d15de7", "patch": "@@ -3094,7 +3094,7 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n \t  /* The argument is already sign/zero extended, so note it\n \t     into the subreg.  */\n \t  SUBREG_PROMOTED_VAR_P (tempreg) = 1;\n-\t  SUBREG_PROMOTED_UNSIGNED_SET (tempreg, unsignedp);\n+\t  SUBREG_PROMOTED_SET (tempreg, unsignedp);\n \t}\n \n       /* TREE_USED gets set erroneously during expand_assignment.  */"}, {"sha": "e44c1dcd197e2200a5edfb2259d8f87985ce98bd", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/362d42dcc965c63977160984292b3429c2d15de7/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/362d42dcc965c63977160984292b3429c2d15de7/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=362d42dcc965c63977160984292b3429c2d15de7", "patch": "@@ -1447,8 +1447,8 @@ noce_emit_cmove (struct noce_if_info *if_info, rtx x, enum rtx_code code,\n \t  || byte_vtrue != byte_vfalse\n \t  || (SUBREG_PROMOTED_VAR_P (vtrue)\n \t      != SUBREG_PROMOTED_VAR_P (vfalse))\n-\t  || (SUBREG_PROMOTED_UNSIGNED_P (vtrue)\n-\t      != SUBREG_PROMOTED_UNSIGNED_P (vfalse)))\n+\t  || (SUBREG_PROMOTED_GET (vtrue)\n+\t      != SUBREG_PROMOTED_GET (vfalse)))\n \treturn NULL_RTX;\n \n       promoted_target = gen_reg_rtx (GET_MODE (reg_vtrue));\n@@ -1462,7 +1462,7 @@ noce_emit_cmove (struct noce_if_info *if_info, rtx x, enum rtx_code code,\n \n       target = gen_rtx_SUBREG (GET_MODE (vtrue), promoted_target, byte_vtrue);\n       SUBREG_PROMOTED_VAR_P (target) = SUBREG_PROMOTED_VAR_P (vtrue);\n-      SUBREG_PROMOTED_UNSIGNED_SET (target, SUBREG_PROMOTED_UNSIGNED_P (vtrue));\n+      SUBREG_PROMOTED_SET (target, SUBREG_PROMOTED_GET (vtrue));\n       emit_move_insn (x, target);\n       return x;\n     }"}, {"sha": "4e0b964cfd17c6af9057760c3e0f1f773224f075", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/362d42dcc965c63977160984292b3429c2d15de7/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/362d42dcc965c63977160984292b3429c2d15de7/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=362d42dcc965c63977160984292b3429c2d15de7", "patch": "@@ -584,12 +584,12 @@ ubsan_expand_si_overflow_mul_check (gimple stmt)\n \t  if (GET_CODE (lopart0) == SUBREG)\n \t    {\n \t      SUBREG_PROMOTED_VAR_P (lopart0) = 1;\n-\t      SUBREG_PROMOTED_UNSIGNED_SET (lopart0, 0);\n+\t      SUBREG_PROMOTED_SET (lopart0, 0);\n \t    }\n \t  if (GET_CODE (lopart1) == SUBREG)\n \t    {\n \t      SUBREG_PROMOTED_VAR_P (lopart1) = 1;\n-\t      SUBREG_PROMOTED_UNSIGNED_SET (lopart1, 0);\n+\t      SUBREG_PROMOTED_SET (lopart1, 0);\n \t    }\n \t  tree halfstype = build_nonstandard_integer_type (hprec, 0);\n \t  ops.op0 = make_tree (halfstype, lopart0);"}, {"sha": "d6412ec42d7c4908a74d098e80d7038e068ca557", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/362d42dcc965c63977160984292b3429c2d15de7/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/362d42dcc965c63977160984292b3429c2d15de7/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=362d42dcc965c63977160984292b3429c2d15de7", "patch": "@@ -368,7 +368,7 @@ widen_operand (rtx op, enum machine_mode mode, enum machine_mode oldmode,\n      a promoted object differs from our extension.  */\n   if (! no_extend\n       || (GET_CODE (op) == SUBREG && SUBREG_PROMOTED_VAR_P (op)\n-\t  && SUBREG_PROMOTED_UNSIGNED_P (op) == unsignedp))\n+\t  && SUBREG_CHECK_PROMOTED_SIGN (op, unsignedp)))\n     return convert_modes (mode, oldmode, op, unsignedp);\n \n   /* If MODE is no wider than a single word, we return a lowpart or paradoxical"}, {"sha": "b6555ea97aab9e6a43172622e9d0bb8e1b6a9d26", "filename": "gcc/rtl.h", "status": "modified", "additions": 63, "deletions": 17, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/362d42dcc965c63977160984292b3429c2d15de7/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/362d42dcc965c63977160984292b3429c2d15de7/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=362d42dcc965c63977160984292b3429c2d15de7", "patch": "@@ -1585,29 +1585,75 @@ get_full_set_src_cost (rtx x, struct full_rtx_costs *c)\n #define SUBREG_PROMOTED_VAR_P(RTX)\t\t\t\t\t\\\n   (RTL_FLAG_CHECK1 (\"SUBREG_PROMOTED\", (RTX), SUBREG)->in_struct)\n \n-#define SUBREG_PROMOTED_UNSIGNED_SET(RTX, VAL)\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  rtx const _rtx = RTL_FLAG_CHECK1 (\"SUBREG_PROMOTED_UNSIGNED_SET\",\t\\\n-\t\t\t\t    (RTX), SUBREG);\t\t\t\\\n-  if ((VAL) < 0)\t\t\t\t\t\t\t\\\n-    _rtx->volatil = 1;\t\t\t\t\t\t\t\\\n-  else {\t\t\t\t\t\t\t\t\\\n-    _rtx->volatil = 0;\t\t\t\t\t\t\t\\\n-    _rtx->unchanging = (VAL);\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n-\n /* Valid for subregs which are SUBREG_PROMOTED_VAR_P().  In that case\n    this gives the necessary extensions:\n-   0  - signed\n-   1  - normal unsigned\n+   0  - signed (SPR_SIGNED)\n+   1  - normal unsigned (SPR_UNSIGNED)\n+   2  - value is both sign and unsign extended for mode\n+\t(SPR_SIGNED_AND_UNSIGNED).\n    -1 - pointer unsigned, which most often can be handled like unsigned\n         extension, except for generating instructions where we need to\n-\temit special code (ptr_extend insns) on some architectures.  */\n+\temit special code (ptr_extend insns) on some architectures\n+\t(SPR_POINTER). */\n+\n+const int SRP_POINTER = -1;\n+const int SRP_SIGNED = 0;\n+const int SRP_UNSIGNED = 1;\n+const int SRP_SIGNED_AND_UNSIGNED = 2;\n+\n+/* Sets promoted mode for SUBREG_PROMOTED_VAR_P().  */\n+#define SUBREG_PROMOTED_SET(RTX, VAL)\t\t                        \\\n+do {\t\t\t\t\t\t\t\t        \\\n+  rtx const _rtx = RTL_FLAG_CHECK1 (\"SUBREG_PROMOTED_SET\",\t\t\\\n+                                    (RTX), SUBREG);\t\t\t\\\n+  switch (VAL)\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    case SRP_POINTER:\t\t\t\t\t\t\t\\\n+      _rtx->volatil = 0;\t\t\t\t\t\t\\\n+      _rtx->unchanging = 0;\t\t\t\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    case SRP_SIGNED:\t\t\t\t\t\t\t\\\n+      _rtx->volatil = 0;\t\t\t\t\t\t\\\n+      _rtx->unchanging = 1;\t\t\t\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    case SRP_UNSIGNED:\t\t\t\t\t\t\t\\\n+      _rtx->volatil = 1;\t\t\t\t\t\t\\\n+      _rtx->unchanging = 0;\t\t\t\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    case SRP_SIGNED_AND_UNSIGNED:\t\t\t\t\t\\\n+      _rtx->volatil = 1;\t\t\t\t\t\t\\\n+      _rtx->unchanging = 1;\t\t\t\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n \n+/* Gets the value stored in promoted mode for SUBREG_PROMOTED_VAR_P(),\n+   including SRP_SIGNED_AND_UNSIGNED if promoted for\n+   both signed and unsigned.  */\n+#define SUBREG_PROMOTED_GET(RTX)\t\\\n+  (2 * (RTL_FLAG_CHECK1 (\"SUBREG_PROMOTED_GET\", (RTX), SUBREG)->volatil)\\\n+   + (RTX)->unchanging - 1)\n+\n+/* Returns sign of promoted mode for SUBREG_PROMOTED_VAR_P().  */\n+#define SUBREG_PROMOTED_SIGN(RTX)\t\\\n+  ((RTL_FLAG_CHECK1 (\"SUBREG_PROMOTED_SIGN\", (RTX), SUBREG)->volatil) ? 1\\\n+   : (RTX)->unchanging - 1)\n+\n+/* Predicate to check if RTX of SUBREG_PROMOTED_VAR_P() is promoted\n+   for SIGNED type.  */\n+#define SUBREG_PROMOTED_SIGNED_P(RTX)\t\\\n+  (RTL_FLAG_CHECK1 (\"SUBREG_PROMOTED_SIGNED_P\", (RTX), SUBREG)->unchanging)\n+\n+/* Predicate to check if RTX of SUBREG_PROMOTED_VAR_P() is promoted\n+   for UNSIGNED type.  */\n #define SUBREG_PROMOTED_UNSIGNED_P(RTX)\t\\\n-  ((RTL_FLAG_CHECK1 (\"SUBREG_PROMOTED_UNSIGNED_P\", (RTX), SUBREG)->volatil) \\\n-   ? -1 : (int) (RTX)->unchanging)\n+  (RTL_FLAG_CHECK1 (\"SUBREG_PROMOTED_UNSIGNED_P\", (RTX), SUBREG)->volatil)\n+\n+/* Checks if RTX of SUBREG_PROMOTED_VAR_P() is promoted for given SIGN.  */\n+#define SUBREG_CHECK_PROMOTED_SIGN(RTX, SIGN)\t\\\n+((SIGN) == SRP_POINTER ? SUBREG_PROMOTED_GET (RTX) == SRP_POINTER\t\\\n+ : (SIGN) == SRP_SIGNED ? SUBREG_PROMOTED_SIGNED_P (RTX)\t\t\\\n+ : SUBREG_PROMOTED_UNSIGNED_P (RTX))\n \n /* True if the subreg was generated by LRA for reload insns.  Such\n    subregs are valid only during LRA.  */"}, {"sha": "3196e55f17f4e4a77f364793b53999daed6d4279", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/362d42dcc965c63977160984292b3429c2d15de7/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/362d42dcc965c63977160984292b3429c2d15de7/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=362d42dcc965c63977160984292b3429c2d15de7", "patch": "@@ -670,7 +670,7 @@ unsigned_reg_p (rtx op)\n     return true;\n \n   if (GET_CODE (op) == SUBREG\n-      && SUBREG_PROMOTED_UNSIGNED_P (op))\n+      && SUBREG_PROMOTED_SIGN (op))\n     return true;\n \n   return false;\n@@ -4309,7 +4309,7 @@ nonzero_bits1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n \t been zero-extended, we know that at least the high-order bits\n \t are zero, though others might be too.  */\n \n-      if (SUBREG_PROMOTED_VAR_P (x) && SUBREG_PROMOTED_UNSIGNED_P (x) > 0)\n+      if (SUBREG_PROMOTED_VAR_P (x) && SUBREG_PROMOTED_UNSIGNED_P (x))\n \tnonzero = GET_MODE_MASK (GET_MODE (x))\n \t\t  & cached_nonzero_bits (SUBREG_REG (x), GET_MODE (x),\n \t\t\t\t\t known_x, known_mode, known_ret);\n@@ -4619,7 +4619,7 @@ num_sign_bit_copies1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n \t and we are looking at it in a wider mode, we know that at least the\n \t high-order bits are known to be sign bit copies.  */\n \n-      if (SUBREG_PROMOTED_VAR_P (x) && ! SUBREG_PROMOTED_UNSIGNED_P (x))\n+      if (SUBREG_PROMOTED_VAR_P (x) && SUBREG_PROMOTED_SIGNED_P (x))\n \t{\n \t  num0 = cached_num_sign_bit_copies (SUBREG_REG (x), mode,\n \t\t\t\t\t     known_x, known_mode, known_ret);"}, {"sha": "4b4c00483a773a40b2c2a33f8878f59975c40aac", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/362d42dcc965c63977160984292b3429c2d15de7/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/362d42dcc965c63977160984292b3429c2d15de7/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=362d42dcc965c63977160984292b3429c2d15de7", "patch": "@@ -1352,7 +1352,7 @@ simplify_unary_operation_1 (enum rtx_code code, enum machine_mode mode, rtx op)\n \t target mode is the same as the variable's promotion.  */\n       if (GET_CODE (op) == SUBREG\n \t  && SUBREG_PROMOTED_VAR_P (op)\n-\t  && ! SUBREG_PROMOTED_UNSIGNED_P (op)\n+\t  && SUBREG_PROMOTED_SIGNED_P (op)\n \t  && GET_MODE_SIZE (mode) <= GET_MODE_SIZE (GET_MODE (XEXP (op, 0))))\n \t{\n \t  temp = rtl_hooks.gen_lowpart_no_emit (mode, op);\n@@ -1419,7 +1419,7 @@ simplify_unary_operation_1 (enum rtx_code code, enum machine_mode mode, rtx op)\n \t target mode is the same as the variable's promotion.  */\n       if (GET_CODE (op) == SUBREG\n \t  && SUBREG_PROMOTED_VAR_P (op)\n-\t  && SUBREG_PROMOTED_UNSIGNED_P (op) > 0\n+\t  && SUBREG_PROMOTED_UNSIGNED_P (op)\n \t  && GET_MODE_SIZE (mode) <= GET_MODE_SIZE (GET_MODE (XEXP (op, 0))))\n \t{\n \t  temp = rtl_hooks.gen_lowpart_no_emit (mode, op);\n@@ -5633,16 +5633,15 @@ simplify_subreg (enum machine_mode outermode, rtx op,\n \t{\n \t  newx = gen_rtx_SUBREG (outermode, SUBREG_REG (op), final_offset);\n \t  if (SUBREG_PROMOTED_VAR_P (op)\n-\t      && SUBREG_PROMOTED_UNSIGNED_P (op) >= 0\n+\t      && SUBREG_PROMOTED_SIGN (op) >= 0\n \t      && GET_MODE_CLASS (outermode) == MODE_INT\n \t      && IN_RANGE (GET_MODE_SIZE (outermode),\n \t\t\t   GET_MODE_SIZE (innermode),\n \t\t\t   GET_MODE_SIZE (innermostmode))\n \t      && subreg_lowpart_p (newx))\n \t    {\n \t      SUBREG_PROMOTED_VAR_P (newx) = 1;\n-\t      SUBREG_PROMOTED_UNSIGNED_SET\n-\t\t(newx, SUBREG_PROMOTED_UNSIGNED_P (op));\n+\t      SUBREG_PROMOTED_SET (newx, SUBREG_PROMOTED_GET (op));\n \t    }\n \t  return newx;\n \t}"}]}