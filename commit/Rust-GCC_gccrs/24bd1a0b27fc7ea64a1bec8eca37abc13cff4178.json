{"sha": "24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjRiZDFhMGIyN2ZjN2VhNjRhMWJlYzhlY2EzN2FiYzEzY2ZmNDE3OA==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2005-12-17T13:40:27Z"}, "committer": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2005-12-17T13:40:27Z"}, "message": "basic-block.h: Changed basic block numbering so that the entry block is 0 and the exit block is 1.\n\n2005-12-17  Danny Berlin <dberlin@dberlin.org>\n\t    Kenneth Zadeck <zadeck@naturalbridge.com>\n\n\t* basic-block.h: Changed basic block numbering so that the entry\n\tblock is 0 and the exit block is 1.  Changed insn iterators so\n\tthat they are tolerant of blocks with no insns.\n\t* regrename.c (copyprop_hardreg_forward): Changed basic block\n\tnumbering so that the entry block is 0 and the exit block is 1.\n\t* sched-ebb.c (sehedule_ebbs): Ditto.\n\t* tracer.c (branch_ratio_cutoff): Ditto.\n\t* cfgloopmanip.c (fix_loop_structure): Ditto.\n\t* cfghooks.c (verify_flow_info): Ditto.\n\t* cfg.c (compact_blocks): Ditto.\n\t* reorg.c (dbr_schedule): Ditto.\n\t* flow.c (calculate_global_regs_live, libcall_dead_p): Ditto.\n\t* dominance.c (calc_dfs_tree_nonrec, calc_dfs_tree,\n\tcalculate_dominance_info): Ditto.\n\t* cfganal.c (create_edge_list, print_edge_list,\n\tflow_depth_first_order_compute, flow_dfs_compute_reverse_init,\n\tflow_dfs_compute_reverse_add_bb, flow_dfs_compute_reverse_execute,\n\tdfs_enumerate_from): Ditto.\n\t* global.c (global_alloc, set_up_bb_rts_numbers): Ditto.\n\t* ifcvt.c (find_if_case_2): Ditto.\n\t* cfgbuild.c (control_flow_insn_p, count_basic_blocks,\n\tfind_basic_blocks): Ditto.\n\t* predict.c (predict_loops, tree_bb_level_predictions,\n\tpredict_paths_leading_to, propagate_freq): Ditto.\n\t* lcm.c (compute_antinout_edge, compute_laterin,\n\tcompute_available): Ditto.\n\t* function.c (thread_prologue_and_epilogue_insns): Ditto.\n\t* gcse.c (gcse_main, bypass_jumps): Ditto.\n\t* profile.c (compute_branch_probabilities,\n\tcompute_value_histograms, branch_prob): Ditto.\n\t* tree-flow-inline.h (bsi_start, bsi_after_labels,\n\tbsi_last): Ditto.\n\t* tree-ssa-phiopt.c (tree_ssa_phiopt,\n\tblocks_in_phiopt_order): Ditto.\n\t* bt-load.c (compute_defs_uses_and_gen, compute_kill,\n\tcompute_out, link_btr_uses, migrate_btr_defs): Ditto.\n\t* tree-dfa.c (collect_dfa_stats): Ditto.\n\t* cfgcleanup.c (try_forward_edges, try_optimize_cfg): Ditto.\n\t* cfglayout.c (fixup_reorder_chain): Ditto.\n\t* bb-reorder.c (reorder_basic_blocks, duplicate_computed_gotos,\n\tpartition_hot_cold_basic_blocks): Ditto.\n\t* var-tracking.c (vt_find_locations): Ditto.\n\t* cfgloop.c (flow_loops_cfg_dump, flow_loops_find, get_loop_body): Ditto.\n\t* sched-rgn.c (compute_trg_info, init_regions, schedule_insns): Ditto.\n\t* tree-cfg.c (init_empty_tree_cfg, build_tree_cfg, make_edges\n\tlabel_to_block_fn, print_loop_ir, tree_flow_call_edges_add): Ditto.\n\t* tree-ssa-reassoc.c (init_reassoc): Ditto.\n\t* cfgrtl.c (entry_of_function, rtl_verify_flow_info,\n\trtl_flow_call_edges_add, rtl_flow_call_edges_add): Ditto.\n\t* df.c (df_analyze_1, hybrid_search, iterative_dataflow): Ditto\n\tand removed unused reverse orders.\n\t* df.h (): Ditto.\n\t* combine.c: Fix document typo.\n\n\n\nCo-Authored-By: Kenneth Zadeck <zadeck@naturalbridge.com>\n\nFrom-SVN: r108713", "tree": {"sha": "9df368d8d09a4cf8e6f2a79bb6e4864ceb6a4907", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9df368d8d09a4cf8e6f2a79bb6e4864ceb6a4907"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "86051306a1a4da9a1fb5da12325cac62cd4ca883", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86051306a1a4da9a1fb5da12325cac62cd4ca883", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86051306a1a4da9a1fb5da12325cac62cd4ca883"}], "stats": {"total": 438, "additions": 236, "deletions": 202}, "files": [{"sha": "33e247e1dec1fd89bada235818db34f60ceea23e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -1,3 +1,60 @@\n+2005-12-17  Danny Berlin <dberlin@dberlin.org>\n+\t    Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+\t* basic-block.h: Changed basic block numbering so that the entry\n+\tblock is 0 and the exit block is 1.  Changed insn iterators so\n+\tthat they are tolerant of blocks with no insns.\n+\t* regrename.c (copyprop_hardreg_forward): Changed basic block\n+\tnumbering so that the entry block is 0 and the exit block is 1.\n+\t* sched-ebb.c (sehedule_ebbs): Ditto.\n+\t* tracer.c (branch_ratio_cutoff): Ditto.\n+\t* cfgloopmanip.c (fix_loop_structure): Ditto.\n+\t* cfghooks.c (verify_flow_info): Ditto.\n+\t* cfg.c (compact_blocks): Ditto.\n+\t* reorg.c (dbr_schedule): Ditto.\n+\t* flow.c (calculate_global_regs_live, libcall_dead_p): Ditto.\n+\t* dominance.c (calc_dfs_tree_nonrec, calc_dfs_tree,\n+\tcalculate_dominance_info): Ditto.\n+\t* cfganal.c (create_edge_list, print_edge_list,\n+\tflow_depth_first_order_compute, flow_dfs_compute_reverse_init,\n+\tflow_dfs_compute_reverse_add_bb, flow_dfs_compute_reverse_execute,\n+\tdfs_enumerate_from): Ditto.\n+\t* global.c (global_alloc, set_up_bb_rts_numbers): Ditto.\n+\t* ifcvt.c (find_if_case_2): Ditto.\n+\t* cfgbuild.c (control_flow_insn_p, count_basic_blocks,\n+\tfind_basic_blocks): Ditto.\n+\t* predict.c (predict_loops, tree_bb_level_predictions,\n+\tpredict_paths_leading_to, propagate_freq): Ditto.\n+\t* lcm.c (compute_antinout_edge, compute_laterin,\n+\tcompute_available): Ditto.\n+\t* function.c (thread_prologue_and_epilogue_insns): Ditto.\n+\t* gcse.c (gcse_main, bypass_jumps): Ditto.\n+\t* profile.c (compute_branch_probabilities,\n+\tcompute_value_histograms, branch_prob): Ditto.\n+\t* tree-flow-inline.h (bsi_start, bsi_after_labels,\n+\tbsi_last): Ditto.\n+\t* tree-ssa-phiopt.c (tree_ssa_phiopt,\n+\tblocks_in_phiopt_order): Ditto.\n+\t* bt-load.c (compute_defs_uses_and_gen, compute_kill,\n+\tcompute_out, link_btr_uses, migrate_btr_defs): Ditto.\n+\t* tree-dfa.c (collect_dfa_stats): Ditto.\n+\t* cfgcleanup.c (try_forward_edges, try_optimize_cfg): Ditto.\n+\t* cfglayout.c (fixup_reorder_chain): Ditto.\n+\t* bb-reorder.c (reorder_basic_blocks, duplicate_computed_gotos,\n+\tpartition_hot_cold_basic_blocks): Ditto.\n+\t* var-tracking.c (vt_find_locations): Ditto.\n+\t* cfgloop.c (flow_loops_cfg_dump, flow_loops_find, get_loop_body): Ditto.\n+\t* sched-rgn.c (compute_trg_info, init_regions, schedule_insns): Ditto.\n+\t* tree-cfg.c (init_empty_tree_cfg, build_tree_cfg, make_edges\n+\tlabel_to_block_fn, print_loop_ir, tree_flow_call_edges_add): Ditto.\n+\t* tree-ssa-reassoc.c (init_reassoc): Ditto.\n+\t* cfgrtl.c (entry_of_function, rtl_verify_flow_info,\n+\trtl_flow_call_edges_add, rtl_flow_call_edges_add): Ditto.\n+\t* df.c (df_analyze_1, hybrid_search, iterative_dataflow): Ditto\n+\tand removed unused reverse orders.\n+\t* df.h (): Ditto.\n+\t* combine.c: Fix document typo.\n+\n 2005-12-17  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-flow-inline.h (set_default_def, default_def): Kill."}, {"sha": "8407f3a7e3c94182ced8577720338f588ec5140f", "filename": "gcc/basic-block.h", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -430,12 +430,12 @@ extern bool rediscover_loops_after_threading;\n /* For iterating over insns in basic block.  */\n #define FOR_BB_INSNS(BB, INSN)\t\t\t\\\n   for ((INSN) = BB_HEAD (BB);\t\t\t\\\n-       (INSN) != NEXT_INSN (BB_END (BB));\t\\\n+       (INSN) && (INSN) != NEXT_INSN (BB_END (BB));\t\\\n        (INSN) = NEXT_INSN (INSN))\n \n #define FOR_BB_INSNS_REVERSE(BB, INSN)\t\t\\\n   for ((INSN) = BB_END (BB);\t\t\t\\\n-       (INSN) != PREV_INSN (BB_HEAD (BB));\t\\\n+       (INSN) && (INSN) != PREV_INSN (BB_HEAD (BB));\t\\\n        (INSN) = PREV_INSN (INSN))\n \n /* Cycles through _all_ basic blocks, even the fake ones (entry and\n@@ -467,11 +467,12 @@ extern bitmap_obstack reg_obstack;\n #define BB_END(B)       (B)->il.rtl->end_\n \n /* Special block numbers [markers] for entry and exit.  */\n-#define ENTRY_BLOCK (-1)\n-#define EXIT_BLOCK (-2)\n+#define ENTRY_BLOCK (0)\n+#define EXIT_BLOCK (1)\n+\n+/* The two blocks that are always in the cfg.  */\n+#define NUM_FIXED_BLOCKS (2)\n \n-/* Special block number not valid for any block.  */\n-#define INVALID_BLOCK (-3)\n \n #define BLOCK_NUM(INSN)\t      (BLOCK_FOR_INSN (INSN)->index + 0)\n #define set_block_for_insn(INSN, BB)  (BLOCK_FOR_INSN (INSN) = BB)"}, {"sha": "f46b2cf871ecdca2ccef583a9695d1d4276ef271", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -1894,7 +1894,7 @@ reorder_basic_blocks (unsigned int flags)\n   int i;\n   struct trace *traces;\n \n-  if (n_basic_blocks <= 1)\n+  if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1)\n     return;\n \n   if (targetm.cannot_modify_jumps_p ())\n@@ -1986,7 +1986,7 @@ duplicate_computed_gotos (void)\n   bitmap candidates;\n   int max_size;\n \n-  if (n_basic_blocks <= 1)\n+  if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1)\n     return;\n \n   if (targetm.cannot_modify_jumps_p ())\n@@ -2169,16 +2169,16 @@ partition_hot_cold_basic_blocks (void)\n   int n_crossing_edges;\n   int max_edges = 2 * last_basic_block;\n   \n-  if (n_basic_blocks <= 1)\n+  if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1)\n     return;\n   \n   crossing_edges = xcalloc (max_edges, sizeof (edge));\n \n   cfg_layout_initialize (0);\n   \n   FOR_EACH_BB (cur_bb)\n-    if (cur_bb->index >= 0\n- \t&& cur_bb->next_bb->index >= 0)\n+    if (cur_bb->index >= NUM_FIXED_BLOCKS\n+ \t&& cur_bb->next_bb->index >= NUM_FIXED_BLOCKS)\n       cur_bb->aux = cur_bb->next_bb;\n   \n   find_rarely_executed_basic_blocks_and_crossing_edges (crossing_edges, "}, {"sha": "c39c5b5aaaad93b249cca0e77cc801e9cd15f6e2", "filename": "gcc/bt-load.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -461,7 +461,7 @@ compute_defs_uses_and_gen (fibheap_t all_btr_defs, btr_def *def_array,\n   defs_uses_info info;\n \n   sbitmap_vector_zero (bb_gen, n_basic_blocks);\n-  for (i = 0; i < n_basic_blocks; i++)\n+  for (i = NUM_FIXED_BLOCKS; i < n_basic_blocks; i++)\n     {\n       basic_block bb = BASIC_BLOCK (i);\n       int reg;\n@@ -622,7 +622,7 @@ compute_kill (sbitmap *bb_kill, sbitmap *btr_defset,\n   /* For each basic block, form the set BB_KILL - the set\n      of definitions that the block kills.  */\n   sbitmap_vector_zero (bb_kill, n_basic_blocks);\n-  for (i = 0; i < n_basic_blocks; i++)\n+  for (i = NUM_FIXED_BLOCKS; i < n_basic_blocks; i++)\n     {\n       for (regno = first_btr; regno <= last_btr; regno++)\n \tif (TEST_HARD_REG_BIT (all_btrs, regno)\n@@ -645,14 +645,14 @@ compute_out (sbitmap *bb_out, sbitmap *bb_gen, sbitmap *bb_kill, int max_uid)\n   int changed;\n   sbitmap bb_in = sbitmap_alloc (max_uid);\n \n-  for (i = 0; i < n_basic_blocks; i++)\n+  for (i = NUM_FIXED_BLOCKS; i < n_basic_blocks; i++)\n     sbitmap_copy (bb_out[i], bb_gen[i]);\n \n   changed = 1;\n   while (changed)\n     {\n       changed = 0;\n-      for (i = 0; i < n_basic_blocks; i++)\n+      for (i = NUM_FIXED_BLOCKS; i < n_basic_blocks; i++)\n \t{\n \t  sbitmap_union_of_preds (bb_in, bb_out, i);\n \t  changed |= sbitmap_union_of_diff_cg (bb_out[i], bb_gen[i],\n@@ -671,7 +671,7 @@ link_btr_uses (btr_def *def_array, btr_user *use_array, sbitmap *bb_out,\n \n   /* Link uses to the uses lists of all of their reaching defs.\n      Count up the number of reaching defs of each use.  */\n-  for (i = 0; i < n_basic_blocks; i++)\n+  for (i = NUM_FIXED_BLOCKS; i < n_basic_blocks; i++)\n     {\n       basic_block bb = BASIC_BLOCK (i);\n       rtx insn;\n@@ -1397,7 +1397,7 @@ migrate_btr_defs (enum reg_class btr_class, int allow_callee_save)\n     {\n       int i;\n \n-      for (i = 0; i < n_basic_blocks; i++)\n+      for (i = NUM_FIXED_BLOCKS; i < n_basic_blocks; i++)\n \t{\n \t  basic_block bb = BASIC_BLOCK (i);\n \t  fprintf(dump_file,"}, {"sha": "8f8593e24202b7dcce81d2de69df795f24ee8365", "filename": "gcc/cfg.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -163,8 +163,11 @@ compact_blocks (void)\n   int i;\n   basic_block bb;\n \n-  i = 0;\n-  FOR_EACH_BB (bb)\n+  BASIC_BLOCK (ENTRY_BLOCK) = ENTRY_BLOCK_PTR;\n+  BASIC_BLOCK (EXIT_BLOCK) = EXIT_BLOCK_PTR;\n+\n+  i = NUM_FIXED_BLOCKS;\n+  FOR_EACH_BB (bb) \n     {\n       BASIC_BLOCK (i) = bb;\n       bb->index = i;"}, {"sha": "e005388d4a33045e2597e6bc1699a9cceb444877", "filename": "gcc/cfganal.c", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -345,7 +345,7 @@ create_edge_list (void)\n   basic_block bb;\n   edge_iterator ei;\n \n-  block_count = n_basic_blocks + 2;   /* Include the entry and exit blocks.  */\n+  block_count = n_basic_blocks; /* Include the entry and exit blocks.  */\n \n   num_edges = 0;\n \n@@ -391,7 +391,7 @@ print_edge_list (FILE *f, struct edge_list *elist)\n   int x;\n \n   fprintf (f, \"Compressed edge list, %d BBs + entry & exit, and %d edges\\n\",\n-\t   elist->num_blocks - 2, elist->num_edges);\n+\t   elist->num_blocks, elist->num_edges);\n \n   for (x = 0; x < elist->num_edges; x++)\n     {\n@@ -721,7 +721,7 @@ flow_depth_first_order_compute (int *dfs_order, int *rc_order)\n   edge_iterator *stack;\n   int sp;\n   int dfsnum = 0;\n-  int rcnum = n_basic_blocks - 1;\n+  int rcnum = n_basic_blocks - 1 - NUM_FIXED_BLOCKS;\n   sbitmap visited;\n \n   /* Allocate stack for back-tracking up CFG.  */\n@@ -786,8 +786,9 @@ flow_depth_first_order_compute (int *dfs_order, int *rc_order)\n   free (stack);\n   sbitmap_free (visited);\n \n-  /* The number of nodes visited should be the number of blocks.  */\n-  gcc_assert (dfsnum == n_basic_blocks);\n+  /* The number of nodes visited should be the number of blocks minus\n+     the entry and exit blocks which are not visited here.  */\n+  gcc_assert (dfsnum == n_basic_blocks - NUM_FIXED_BLOCKS);\n \n   return dfsnum;\n }\n@@ -826,12 +827,11 @@ static void\n flow_dfs_compute_reverse_init (depth_first_search_ds data)\n {\n   /* Allocate stack for back-tracking up CFG.  */\n-  data->stack = xmalloc ((n_basic_blocks - (INVALID_BLOCK + 1))\n-\t\t\t * sizeof (basic_block));\n+  data->stack = xmalloc (n_basic_blocks * sizeof (basic_block));\n   data->sp = 0;\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n-  data->visited_blocks = sbitmap_alloc (last_basic_block - (INVALID_BLOCK + 1));\n+  data->visited_blocks = sbitmap_alloc (last_basic_block);\n \n   /* None of the nodes in the CFG have been visited yet.  */\n   sbitmap_zero (data->visited_blocks);\n@@ -847,7 +847,7 @@ static void\n flow_dfs_compute_reverse_add_bb (depth_first_search_ds data, basic_block bb)\n {\n   data->stack[data->sp++] = bb;\n-  SET_BIT (data->visited_blocks, bb->index - (INVALID_BLOCK + 1));\n+  SET_BIT (data->visited_blocks, bb->index);\n }\n \n /* Continue the depth-first search through the reverse graph starting with the\n@@ -869,14 +869,13 @@ flow_dfs_compute_reverse_execute (depth_first_search_ds data,\n \n       /* Perform depth-first search on adjacent vertices.  */\n       FOR_EACH_EDGE (e, ei, bb->preds)\n-\tif (!TEST_BIT (data->visited_blocks,\n-\t\t       e->src->index - (INVALID_BLOCK + 1)))\n+\tif (!TEST_BIT (data->visited_blocks, e->src->index))\n \t  flow_dfs_compute_reverse_add_bb (data, e->src);\n     }\n \n   /* Determine if there are unvisited basic blocks.  */\n   FOR_BB_BETWEEN (bb, last_unvisited, NULL, prev_bb)\n-    if (!TEST_BIT (data->visited_blocks, bb->index - (INVALID_BLOCK + 1)))\n+    if (!TEST_BIT (data->visited_blocks, bb->index))\n       return bb;\n \n   return NULL;\n@@ -912,12 +911,12 @@ dfs_enumerate_from (basic_block bb, int reverse,\n   static sbitmap visited;\n   static unsigned v_size;\n \n-#define MARK_VISITED(BB) (SET_BIT (visited, (BB)->index + 2))\n-#define UNMARK_VISITED(BB) (RESET_BIT (visited, (BB)->index + 2))\n-#define VISITED_P(BB) (TEST_BIT (visited, (BB)->index + 2))\n+#define MARK_VISITED(BB) (SET_BIT (visited, (BB)->index)) \n+#define UNMARK_VISITED(BB) (RESET_BIT (visited, (BB)->index)) \n+#define VISITED_P(BB) (TEST_BIT (visited, (BB)->index)) \n \n   /* Resize the VISITED sbitmap if necessary.  */\n-  size = last_basic_block + 2;\n+  size = last_basic_block; \n   if (size < 10)\n     size = 10;\n "}, {"sha": "834119dbc0c8f9bdde536bec7f2c3e2d6355f35a", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -138,7 +138,7 @@ control_flow_insn_p (rtx insn)\n static int\n count_basic_blocks (rtx f)\n {\n-  int count = 0;\n+  int count = NUM_FIXED_BLOCKS;\n   bool saw_insn = false;\n   rtx insn;\n \n@@ -164,10 +164,10 @@ count_basic_blocks (rtx f)\n \n   /* The rest of the compiler works a bit smoother when we don't have to\n      check for the edge case of do-nothing functions with no basic blocks.  */\n-  if (count == 0)\n+  if (count == NUM_FIXED_BLOCKS)\n     {\n       emit_insn (gen_rtx_USE (VOIDmode, const0_rtx));\n-      count = 1;\n+      count = NUM_FIXED_BLOCKS + 1;\n     }\n \n   return count;\n@@ -529,10 +529,11 @@ find_basic_blocks (rtx f)\n     }\n \n   n_basic_blocks = count_basic_blocks (f);\n-  last_basic_block = 0;\n+  last_basic_block = NUM_FIXED_BLOCKS;\n   ENTRY_BLOCK_PTR->next_bb = EXIT_BLOCK_PTR;\n   EXIT_BLOCK_PTR->prev_bb = ENTRY_BLOCK_PTR;\n \n+\n   /* Size the basic block table.  The actual structures will be allocated\n      by find_basic_blocks_1, since we want to keep the structure pointers\n      stable across calls to find_basic_blocks.  */\n@@ -542,6 +543,8 @@ find_basic_blocks (rtx f)\n      actually lay them out.  */\n \n   VARRAY_BB_INIT (basic_block_info, n_basic_blocks, \"basic_block_info\");\n+  BASIC_BLOCK (ENTRY_BLOCK) = ENTRY_BLOCK_PTR;\n+  BASIC_BLOCK (EXIT_BLOCK) = EXIT_BLOCK_PTR;\n \n   find_basic_blocks_1 (f);\n "}, {"sha": "8443451a42f6299841394fb244aa36cae3b5207b", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -441,7 +441,7 @@ try_forward_edges (int mode, basic_block b)\n \t}\n \n       target = first = e->dest;\n-      counter = 0;\n+      counter = NUM_FIXED_BLOCKS;\n \n       /* If we are partitioning hot/cold basic_blocks, we don't want to mess\n \t up jumps that cross between hot/cold sections.\n@@ -503,7 +503,7 @@ try_forward_edges (int mode, basic_block b)\n \t\t  if (t->dest == b)\n \t\t    break;\n \n-\t\t  gcc_assert (nthreaded_edges < n_basic_blocks);\n+\t\t  gcc_assert (nthreaded_edges < n_basic_blocks - NUM_FIXED_BLOCKS);\n \t\t  threaded_edges[nthreaded_edges++] = t;\n \n \t\t  new_target = t->dest;\n@@ -1676,7 +1676,7 @@ try_optimize_cfg (int mode)\n \t\t  /* Note that forwarder_block_p true ensures that\n \t\t     there is a successor for this block.  */\n \t\t  && (single_succ_edge (b)->flags & EDGE_FALLTHRU)\n-\t\t  && n_basic_blocks > 1)\n+\t\t  && n_basic_blocks > NUM_FIXED_BLOCKS + 1)\n \t\t{\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file,"}, {"sha": "a42e4d74b7bfa23da9542ce157cc21c73935a1f4", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -77,8 +77,8 @@ verify_flow_info (void)\n   basic_block *last_visited;\n \n   timevar_push (TV_CFG_VERIFY);\n-  last_visited = xcalloc (last_basic_block + 2, sizeof (basic_block));\n-  edge_checksum = xcalloc (last_basic_block + 2, sizeof (size_t));\n+  last_visited = xcalloc (last_basic_block, sizeof (basic_block));\n+  edge_checksum = xcalloc (last_basic_block, sizeof (size_t));\n \n   /* Check bb chain & numbers.  */\n   last_bb_seen = ENTRY_BLOCK_PTR;\n@@ -122,7 +122,7 @@ verify_flow_info (void)\n \t}\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n-\t  if (last_visited [e->dest->index + 2] == bb)\n+\t  if (last_visited [e->dest->index] == bb)\n \t    {\n \t      error (\"verify_flow_info: Duplicate edge %i->%i\",\n \t\t     e->src->index, e->dest->index);\n@@ -141,7 +141,7 @@ verify_flow_info (void)\n \t      err = 1;\n \t    }\n \n-\t  last_visited [e->dest->index + 2] = bb;\n+\t  last_visited [e->dest->index] = bb;\n \n \t  if (e->flags & EDGE_FALLTHRU)\n \t    n_fallthru++;\n@@ -158,7 +158,7 @@ verify_flow_info (void)\n \t      err = 1;\n \t    }\n \n-\t  edge_checksum[e->dest->index + 2] += (size_t) e;\n+\t  edge_checksum[e->dest->index] += (size_t) e;\n \t}\n       if (n_fallthru > 1)\n \t{\n@@ -192,7 +192,7 @@ verify_flow_info (void)\n \t      err = 1;\n \t    }\n \n-\t  edge_checksum[e->dest->index + 2] -= (size_t) e;\n+\t  edge_checksum[e->dest->index] -= (size_t) e;\n \t}\n     }\n \n@@ -202,14 +202,14 @@ verify_flow_info (void)\n     edge_iterator ei;\n \n     FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n-      edge_checksum[e->dest->index + 2] += (size_t) e;\n+      edge_checksum[e->dest->index] += (size_t) e;\n \n     FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n-      edge_checksum[e->dest->index + 2] -= (size_t) e;\n+      edge_checksum[e->dest->index] -= (size_t) e;\n   }\n \n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n-    if (edge_checksum[bb->index + 2])\n+    if (edge_checksum[bb->index])\n       {\n \terror (\"basic block %i edge lists are corrupted\", bb->index);\n \terr = 1;"}, {"sha": "d2580b4e19ff75daae66ac9fa383c2a24598adfb", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -601,7 +601,7 @@ fixup_reorder_chain (void)\n   /* First do the bulk reordering -- rechain the blocks without regard to\n      the needed changes to jumps and labels.  */\n \n-  for (bb = ENTRY_BLOCK_PTR->next_bb, index = 0;\n+  for (bb = ENTRY_BLOCK_PTR->next_bb, index = NUM_FIXED_BLOCKS;\n        bb != 0;\n        bb = bb->aux, index++)\n     {\n@@ -818,7 +818,7 @@ fixup_reorder_chain (void)\n   if (dump_file)\n     {\n       fprintf (dump_file, \"Reordered sequence:\\n\");\n-      for (bb = ENTRY_BLOCK_PTR->next_bb, index = 0;\n+      for (bb = ENTRY_BLOCK_PTR->next_bb, index = NUM_FIXED_BLOCKS;\n \t   bb;\n \t   bb = bb->aux, index++)\n \t{\n@@ -837,7 +837,7 @@ fixup_reorder_chain (void)\n \n   prev_bb = ENTRY_BLOCK_PTR;\n   bb = ENTRY_BLOCK_PTR->next_bb;\n-  index = 0;\n+  index = NUM_FIXED_BLOCKS;\n \n   for (; bb; prev_bb = bb, bb = bb->aux, index ++)\n     {"}, {"sha": "dabeacf214ed4fa02f055f2be9b96fe9262e69b9", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -73,7 +73,7 @@ flow_loops_cfg_dump (const struct loops *loops, FILE *file)\n   if (loops->cfg.dfs_order)\n     {\n       fputs (\";; DFS order: \", file);\n-      for (i = 0; i < n_basic_blocks; i++)\n+      for (i = NUM_FIXED_BLOCKS; i < n_basic_blocks; i++)\n \tfprintf (file, \"%d \", loops->cfg.dfs_order[i]);\n \n       fputs (\"\\n\", file);\n@@ -83,7 +83,7 @@ flow_loops_cfg_dump (const struct loops *loops, FILE *file)\n   if (loops->cfg.rc_order)\n     {\n       fputs (\";; RC order: \", file);\n-      for (i = 0; i < n_basic_blocks; i++)\n+      for (i = NUM_FIXED_BLOCKS; i < n_basic_blocks; i++)\n \tfprintf (file, \"%d \", loops->cfg.rc_order[i]);\n \n       fputs (\"\\n\", file);\n@@ -610,7 +610,7 @@ flow_loops_find (struct loops *loops)\n \n   /* Taking care of this degenerate case makes the rest of\n      this code simpler.  */\n-  if (n_basic_blocks == 0)\n+  if (n_basic_blocks == NUM_FIXED_BLOCKS)\n     return 0;\n \n   dfs_order = NULL;\n@@ -676,7 +676,7 @@ flow_loops_find (struct loops *loops)\n   loops->parray[0]->outer = NULL;\n   loops->parray[0]->depth = 0;\n   loops->parray[0]->pred = NULL;\n-  loops->parray[0]->num_nodes = n_basic_blocks + 2;\n+  loops->parray[0]->num_nodes = n_basic_blocks;\n   loops->parray[0]->latch = EXIT_BLOCK_PTR;\n   loops->parray[0]->header = ENTRY_BLOCK_PTR;\n   ENTRY_BLOCK_PTR->loop_father = loops->parray[0];\n@@ -704,7 +704,7 @@ flow_loops_find (struct loops *loops)\n \n       num_loops = 1;\n \n-      for (b = 0; b < n_basic_blocks; b++)\n+      for (b = 0; b < n_basic_blocks - NUM_FIXED_BLOCKS; b++)\n \t{\n \t  struct loop *loop;\n \t  edge_iterator ei;\n@@ -804,7 +804,7 @@ get_loop_body (const struct loop *loop)\n   if (loop->latch == EXIT_BLOCK_PTR)\n     {\n       /* There may be blocks unreachable from EXIT_BLOCK.  */\n-      gcc_assert (loop->num_nodes == (unsigned) n_basic_blocks + 2);\n+      gcc_assert (loop->num_nodes == (unsigned) n_basic_blocks);\n       FOR_EACH_BB (bb)\n \ttovisit[tv++] = bb;\n       tovisit[tv++] = EXIT_BLOCK_PTR;"}, {"sha": "cfc11e0f62e6f3e7e10a1e3e2a68873582725611", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -1563,7 +1563,7 @@ fix_loop_structure (struct loops *loops, bitmap changed_bbs)\n     }\n \n   /* Remove the dead loops from structures.  */\n-  loops->tree_root->num_nodes = n_basic_blocks + 2;\n+  loops->tree_root->num_nodes = n_basic_blocks; \n   for (i = 1; i < loops->num; i++)\n     {\n       loop = loops->parray[i];"}, {"sha": "fcf359070b71873a7f30ad4ced46de20bf0117df", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -440,7 +440,8 @@ struct tree_opt_pass pass_free_cfg =\n rtx\n entry_of_function (void)\n {\n-  return (n_basic_blocks ? BB_HEAD (ENTRY_BLOCK_PTR->next_bb) : get_insns ());\n+  return (n_basic_blocks > NUM_FIXED_BLOCKS ? \n+\t  BB_HEAD (ENTRY_BLOCK_PTR->next_bb) : get_insns ());\n }\n \n /* Update insns block within BB.  */\n@@ -2258,7 +2259,7 @@ rtl_verify_flow_info (void)\n \tcurr_bb = NULL;\n     }\n \n-  if (num_bb_notes != n_basic_blocks)\n+  if (num_bb_notes != n_basic_blocks - NUM_FIXED_BLOCKS)\n     internal_error\n       (\"number of bb notes in insn chain (%d) != n_basic_blocks (%d)\",\n        num_bb_notes, n_basic_blocks);\n@@ -2913,7 +2914,7 @@ rtl_flow_call_edges_add (sbitmap blocks)\n   int last_bb = last_basic_block;\n   bool check_last_block = false;\n \n-  if (n_basic_blocks == 0)\n+  if (n_basic_blocks == NUM_FIXED_BLOCKS)\n     return 0;\n \n   if (! blocks)\n@@ -2960,7 +2961,7 @@ rtl_flow_call_edges_add (sbitmap blocks)\n      calls since there is no way that we can determine if they will\n      return or not...  */\n \n-  for (i = 0; i < last_bb; i++)\n+  for (i = NUM_FIXED_BLOCKS; i < last_bb; i++)\n     {\n       basic_block bb = BASIC_BLOCK (i);\n       rtx insn;"}, {"sha": "f21a17cd4d597938e5f7f0060c7abb1bb063b1fb", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -55,7 +55,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    - reg_live_length is not updated\n    - reg_n_refs is not adjusted in the rare case when a register is\n      no longer required in a computation\n-   - there are extremely rare cases (see distribute_regnotes) when a\n+   - there are extremely rare cases (see distribute_notes) when a\n      REG_DEAD note is lost\n    - a LOG_LINKS entry that refers to an insn with multiple SETs may be\n      removed because there is no way to know which register it was"}, {"sha": "bae8e578cbd7fda3f613fc4786618948bdeb7cb6", "filename": "gcc/df.c", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -1926,7 +1926,6 @@ df_analyze_1 (struct df *df, bitmap blocks, int flags, int update)\n {\n   int aflags;\n   int dflags;\n-  int i;\n   basic_block bb;\n   struct dataflow dflow;\n \n@@ -1996,18 +1995,9 @@ df_analyze_1 (struct df *df, bitmap blocks, int flags, int update)\n   df->dfs_order = xmalloc (sizeof (int) * n_basic_blocks);\n   df->rc_order = xmalloc (sizeof (int) * n_basic_blocks);\n   df->rts_order = xmalloc (sizeof (int) * n_basic_blocks);\n-  df->inverse_dfs_map = xmalloc (sizeof (int) * last_basic_block);\n-  df->inverse_rc_map = xmalloc (sizeof (int) * last_basic_block);\n-  df->inverse_rts_map = xmalloc (sizeof (int) * last_basic_block);\n \n   flow_depth_first_order_compute (df->dfs_order, df->rc_order);\n   flow_reverse_top_sort_order_compute (df->rts_order);\n-  for (i = 0; i < n_basic_blocks; i++)\n-    {\n-      df->inverse_dfs_map[df->dfs_order[i]] = i;\n-      df->inverse_rc_map[df->rc_order[i]] = i;\n-      df->inverse_rts_map[df->rts_order[i]] = i;\n-    }\n   if (aflags & DF_RD)\n     {\n       /* Compute the sets of gens and kills for the defs of each bb.  */\n@@ -2137,9 +2127,6 @@ df_analyze_1 (struct df *df, bitmap blocks, int flags, int update)\n   free (df->dfs_order);\n   free (df->rc_order);\n   free (df->rts_order);\n-  free (df->inverse_rc_map);\n-  free (df->inverse_dfs_map);\n-  free (df->inverse_rts_map);\n }\n \n \n@@ -3923,8 +3910,7 @@ hybrid_search (basic_block bb, struct dataflow *dataflow,\n    DATAFLOW, producing the in and out sets.  Only the part of the cfg\n    induced by blocks in DATAFLOW->order is taken into account.\n \n-   For forward problems, you probably want to pass in a mapping of\n-   block number to rc_order (like df->inverse_rc_map).  */\n+   For forward problems, you probably want to pass in rc_order.  */\n \n void\n iterative_dataflow (struct dataflow *dataflow)\n@@ -3939,7 +3925,7 @@ iterative_dataflow (struct dataflow *dataflow)\n   sbitmap_zero (visited);\n   sbitmap_zero (considered);\n \n-  for (i = 0; i < dataflow->n_blocks; i++)\n+  for (i = 0; i < dataflow->n_blocks - NUM_FIXED_BLOCKS; i++)\n     {\n       idx = dataflow->order[i];\n       SET_BIT (pending, idx);\n@@ -3954,7 +3940,7 @@ iterative_dataflow (struct dataflow *dataflow)\n \n   while (1)\n     {\n-      for (i = 0; i < dataflow->n_blocks; i++)\n+      for (i = 0; i < dataflow->n_blocks - NUM_FIXED_BLOCKS ; i++)\n \t{\n \t  idx = dataflow->order[i];\n "}, {"sha": "65d6b1c095688dc9e18c6ddcb84861ceca4a5a4f", "filename": "gcc/df.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -155,9 +155,6 @@ struct df\n   int *dfs_order;\t\t/* DFS order -> block number.  */\n   int *rc_order;\t\t/* Reverse completion order -> block number.  */\n   int *rts_order;\t\t/* Reverse top sort order -> block number.  */\n-  int *inverse_rc_map;\t\t/* Block number -> reverse completion order.  */\n-  int *inverse_dfs_map;\t\t/* Block number -> DFS order.  */\n-  int *inverse_rts_map;\t\t/* Block number -> reverse top-sort order.  */\n };\n \n "}, {"sha": "f89b6f618871559ccb066b5b994c749997c0b1fe", "filename": "gcc/dominance.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -51,8 +51,7 @@ enum dom_state dom_computed[2];\n    'undefined' or 'end of list'.  The name of each node is given by the dfs\n    number of the corresponding basic block.  Please note, that we include the\n    artificial ENTRY_BLOCK (or EXIT_BLOCK in the post-dom case) in our lists to\n-   support multiple entry points.  As it has no real basic block index we use\n-   'last_basic_block' for that.  Its dfs number is of course 1.  */\n+   support multiple entry points.  Its dfs number is of course 1.  */\n \n /* Type of Basic Block aka. TBB */\n typedef unsigned int TBB;\n@@ -149,9 +148,7 @@ static unsigned n_bbs_in_dom_tree[2];\n static void\n init_dom_info (struct dom_info *di, enum cdi_direction dir)\n {\n-  /* We need memory for n_basic_blocks nodes and the ENTRY_BLOCK or\n-     EXIT_BLOCK.  */\n-  unsigned int num = n_basic_blocks + 1 + 1;\n+  unsigned int num = n_basic_blocks;\n   init_ar (di->dfs_parent, TBB, num, 0);\n   init_ar (di->path_min, TBB, num, i);\n   init_ar (di->key, TBB, num, i);\n@@ -216,7 +213,7 @@ calc_dfs_tree_nonrec (struct dom_info *di, basic_block bb,\n   /* Ending block.  */\n   basic_block ex_block;\n \n-  stack = xmalloc ((n_basic_blocks + 3) * sizeof (edge_iterator));\n+  stack = xmalloc ((n_basic_blocks + 1) * sizeof (edge_iterator));\n   sp = 0;\n \n   /* Initialize our border blocks, and the first edge.  */\n@@ -372,8 +369,8 @@ calc_dfs_tree (struct dom_info *di, enum cdi_direction reverse)\n \n   di->nodes = di->dfsnum - 1;\n \n-  /* Make sure there is a path from ENTRY to EXIT at all.  */\n-  gcc_assert (di->nodes == (unsigned int) n_basic_blocks + 1);\n+  /* This aborts e.g. when there is _no_ path from ENTRY to EXIT at all.  */\n+  gcc_assert (di->nodes == (unsigned int) n_basic_blocks - 1);\n }\n \n /* Compress the path from V to the root of its set and update path_min at the\n@@ -627,7 +624,7 @@ calculate_dominance_info (enum cdi_direction dir)\n \t{\n \t  b->dom[dir] = et_new_tree (b);\n \t}\n-      n_bbs_in_dom_tree[dir] = n_basic_blocks + 2;\n+      n_bbs_in_dom_tree[dir] = n_basic_blocks;\n \n       init_dom_info (&di, dir);\n       calc_dfs_tree (&di, dir);"}, {"sha": "436bfd7b29bcdaaaad1394a7894894c988ac9485", "filename": "gcc/flow.c", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -1054,17 +1054,14 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n       SET_REGNO_REG_SET (invalidated_by_call, i);\n \n   /* Allocate space for the sets of local properties.  */\n-  local_sets = xcalloc (last_basic_block - (INVALID_BLOCK + 1),\n-\t\t\tsizeof (regset));\n-  cond_local_sets = xcalloc (last_basic_block - (INVALID_BLOCK + 1),\n-\t\t\t     sizeof (regset));\n-\n-  /* Create a worklist.  Allocate an extra slot for ENTRY_BLOCK, and one\n-     because the `head == tail' style test for an empty queue doesn't\n-     work with a full queue.  */\n-  queue = xmalloc ((n_basic_blocks - (INVALID_BLOCK + 1)) * sizeof (*queue));\n+  local_sets = xcalloc (last_basic_block, sizeof (regset));\n+  cond_local_sets = xcalloc (last_basic_block, sizeof (regset));\n+\n+  /* Create a worklist.  Allocate an extra slot for the `head == tail'\n+     style test for an empty queue doesn't work with a full queue.  */\n+  queue = xmalloc ((n_basic_blocks + 1) * sizeof (*queue));\n   qtail = queue;\n-  qhead = qend = queue + n_basic_blocks - (INVALID_BLOCK + 1);\n+  qhead = qend = queue + n_basic_blocks;\n \n   /* Queue the blocks set in the initial mask.  Do this in reverse block\n      number order so that we are more likely for the first round to do\n@@ -1245,12 +1242,10 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n          basic block.  On subsequent passes, we get to skip out early if\n \t live_at_end wouldn't have changed.  */\n \n-      if (local_sets[bb->index - (INVALID_BLOCK + 1)] == NULL)\n+      if (local_sets[bb->index] == NULL)\n \t{\n-\t  local_sets[bb->index - (INVALID_BLOCK + 1)]\n-\t    = ALLOC_REG_SET (&reg_obstack);\n-\t  cond_local_sets[bb->index - (INVALID_BLOCK + 1)]\n-\t    = ALLOC_REG_SET (&reg_obstack);\n+\t  local_sets[bb->index] = ALLOC_REG_SET (&reg_obstack);\n+\t  cond_local_sets[bb->index] = ALLOC_REG_SET (&reg_obstack);\n \t  rescan = 1;\n \t}\n       else\n@@ -1274,7 +1269,7 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n \t\t  successor block.  We can miss changes in those sets if\n \t\t  we only compare the new live_at_end against the\n \t\t  previous one.  */\n-\t      cond_local_set = cond_local_sets[bb->index - (INVALID_BLOCK + 1)];\n+\t      cond_local_set = cond_local_sets[bb->index];\n \t      rescan = bitmap_intersect_p (new_live_at_end, cond_local_set);\n \t    }\n \n@@ -1290,7 +1285,7 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n   \n \t      /* If any of the changed bits overlap with local_sets[bb],\n  \t\t we'll have to rescan the block.  */\n-\t      local_set = local_sets[bb->index - (INVALID_BLOCK + 1)];\n+\t      local_set = local_sets[bb->index];\n \t      rescan = bitmap_intersect_p (tmp, local_set);\n \t    }\n \t}\n@@ -1319,8 +1314,8 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n \t  /* Rescan the block insn by insn to turn (a copy of) live_at_end\n \t     into live_at_start.  */\n \t  propagate_block (bb, new_live_at_end,\n-\t\t\t   local_sets[bb->index - (INVALID_BLOCK + 1)],\n-\t\t\t   cond_local_sets[bb->index - (INVALID_BLOCK + 1)],\n+\t\t\t   local_sets[bb->index],\n+\t\t\t   cond_local_sets[bb->index],\n \t\t\t   flags);\n \n \t  /* If live_at start didn't change, no need to go farther.  */\n@@ -1366,11 +1361,11 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n \t\t\tSET_BIT (blocks_out, pbb->index);\n \n \t\t      /* Makes sure to really rescan the block.  */\n-\t\t      if (local_sets[pbb->index - (INVALID_BLOCK + 1)])\n+\t\t      if (local_sets[pbb->index])\n \t\t\t{\n-\t\t\t  FREE_REG_SET (local_sets[pbb->index - (INVALID_BLOCK + 1)]);\n-\t\t\t  FREE_REG_SET (cond_local_sets[pbb->index - (INVALID_BLOCK + 1)]);\n-\t\t\t  local_sets[pbb->index - (INVALID_BLOCK + 1)] = 0;\n+\t\t\t  FREE_REG_SET (local_sets[pbb->index]);\n+\t\t\t  FREE_REG_SET (cond_local_sets[pbb->index]);\n+\t\t\t  local_sets[pbb->index] = 0;\n \t\t\t}\n \n \t\t      /* Add it to the queue.  */\n@@ -1416,16 +1411,16 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n       EXECUTE_IF_SET_IN_SBITMAP (blocks_out, 0, i, sbi)\n \t{\n \t  basic_block bb = BASIC_BLOCK (i);\n-\t  FREE_REG_SET (local_sets[bb->index - (INVALID_BLOCK + 1)]);\n-\t  FREE_REG_SET (cond_local_sets[bb->index - (INVALID_BLOCK + 1)]);\n+ \t  FREE_REG_SET (local_sets[bb->index]);\n+ \t  FREE_REG_SET (cond_local_sets[bb->index]);\n \t};\n     }\n   else\n     {\n       FOR_EACH_BB (bb)\n \t{\n-\t  FREE_REG_SET (local_sets[bb->index - (INVALID_BLOCK + 1)]);\n-\t  FREE_REG_SET (cond_local_sets[bb->index - (INVALID_BLOCK + 1)]);\n+ \t  FREE_REG_SET (local_sets[bb->index]);\n+ \t  FREE_REG_SET (cond_local_sets[bb->index]);\n \t}\n     }\n \n@@ -2472,7 +2467,7 @@ libcall_dead_p (struct propagate_block_info *pbi, rtx note, rtx insn)\n int\n regno_clobbered_at_setjmp (int regno)\n {\n-  if (n_basic_blocks == 0)\n+  if (n_basic_blocks == NUM_FIXED_BLOCKS)\n     return 0;\n \n   return ((REG_N_SETS (regno) > 1"}, {"sha": "0ece698f859fc5c1309c1cedeb752abd215b7fb3", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -5256,7 +5256,8 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n \tfixup_fallthru_exit_predecessor.  */\n       cfg_layout_initialize (0);\n       FOR_EACH_BB (cur_bb)\n-\tif (cur_bb->index >= 0 && cur_bb->next_bb->index >= 0)\n+\tif (cur_bb->index >= NUM_FIXED_BLOCKS\n+\t    && cur_bb->next_bb->index >= NUM_FIXED_BLOCKS)\n \t  cur_bb->aux = cur_bb->next_bb;\n       cfg_layout_finalize ();\n     }"}, {"sha": "af7444e850485c76067c5d0d52636006d1aec0dc", "filename": "gcc/gcse.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -691,7 +691,7 @@ gcse_main (rtx f ATTRIBUTE_UNUSED, FILE *file)\n     dump_flow_info (file);\n \n   /* Return if there's nothing to do, or it is too expensive.  */\n-  if (n_basic_blocks <= 1 || is_too_expensive (_(\"GCSE disabled\")))\n+  if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1 || is_too_expensive (_(\"GCSE disabled\")))\n     return 0;\n \n   gcc_obstack_init (&gcse_obstack);\n@@ -6519,7 +6519,8 @@ bypass_jumps (FILE *file)\n     dump_flow_info (file);\n \n   /* Return if there's nothing to do, or it is too expensive.  */\n-  if (n_basic_blocks <= 1 || is_too_expensive (_ (\"jump bypassing disabled\")))\n+  if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1 || \n+      is_too_expensive (_ (\"jump bypassing disabled\")))\n     return 0;\n \n   gcc_obstack_init (&gcse_obstack);"}, {"sha": "e5ecd3266ef3df8def30708a2275a0dcfbbac8bb", "filename": "gcc/global.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -621,7 +621,7 @@ global_alloc (FILE *file)\n \n #if 0 /* We need to eliminate regs even if there is no rtl code,\n \t for the sake of debugging information.  */\n-  if (n_basic_blocks > 0)\n+  if (n_basic_blocks > NUM_FIXED_BLOCKS)\n #endif\n     {\n       build_insn_chain (get_insns ());\n@@ -2281,9 +2281,9 @@ set_up_bb_rts_numbers (void)\n   int i;\n   int *rts_order;\n   \n-  rts_order = xmalloc (sizeof (int) * n_basic_blocks);\n+  rts_order = xmalloc (sizeof (int) * (n_basic_blocks - NUM_FIXED_BLOCKS));\n   flow_reverse_top_sort_order_compute (rts_order);\n-  for (i = 0; i < n_basic_blocks; i++)\n+  for (i = 0; i < n_basic_blocks - NUM_FIXED_BLOCKS; i++)\n     BB_INFO_BY_INDEX (rts_order [i])->rts_number = i;\n   free (rts_order);\n }"}, {"sha": "d89253573edb252dca1547ded3b5c5679a1aaa12", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -3194,14 +3194,14 @@ find_if_case_2 (basic_block test_bb, edge then_edge, edge else_edge)\n     return FALSE;\n \n   /* THEN is not EXIT.  */\n-  if (then_bb->index < 0)\n+  if (then_bb->index < NUM_FIXED_BLOCKS)\n     return FALSE;\n \n   /* ELSE is predicted or SUCC(ELSE) postdominates THEN.  */\n   note = find_reg_note (BB_END (test_bb), REG_BR_PROB, NULL_RTX);\n   if (note && INTVAL (XEXP (note, 0)) >= REG_BR_PROB_BASE / 2)\n     ;\n-  else if (else_succ->dest->index < 0\n+  else if (else_succ->dest->index < NUM_FIXED_BLOCKS\n \t   || dominated_by_p (CDI_POST_DOMINATORS, then_bb,\n \t\t\t      else_succ->dest))\n     ;"}, {"sha": "63910050df001fd9357353e0e41cb7a8ef9c2e55", "filename": "gcc/lcm.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -122,8 +122,8 @@ compute_antinout_edge (sbitmap *antloc, sbitmap *transp, sbitmap *antin,\n     }\n \n   qin = worklist;\n-  qend = &worklist[n_basic_blocks];\n-  qlen = n_basic_blocks;\n+  qend = &worklist[n_basic_blocks - NUM_FIXED_BLOCKS];\n+  qlen = n_basic_blocks - NUM_FIXED_BLOCKS;\n \n   /* Mark blocks which are predecessors of the exit block so that we\n      can easily identify them below.  */\n@@ -260,7 +260,7 @@ compute_laterin (struct edge_list *edge_list, sbitmap *earliest,\n      list if they were not already on the list.  So the size is\n      bounded by the number of basic blocks.  */\n   qin = qout = worklist\n-    = xmalloc (sizeof (basic_block) * (n_basic_blocks + 1));\n+    = xmalloc (sizeof (basic_block) * n_basic_blocks);\n \n   /* Initialize a mapping from each edge to its index.  */\n   for (i = 0; i < num_edges; i++)\n@@ -294,11 +294,10 @@ compute_laterin (struct edge_list *edge_list, sbitmap *earliest,\n     }\n \n   /* Note that we do not use the last allocated element for our queue,\n-     as EXIT_BLOCK is never inserted into it. In fact the above allocation\n-     of n_basic_blocks + 1 elements is not necessary.  */\n+     as EXIT_BLOCK is never inserted into it. */\n   qin = worklist;\n-  qend = &worklist[n_basic_blocks];\n-  qlen = n_basic_blocks;\n+  qend = &worklist[n_basic_blocks - NUM_FIXED_BLOCKS];\n+  qlen = n_basic_blocks - NUM_FIXED_BLOCKS;\n \n   /* Iterate until the worklist is empty.  */\n   while (qlen)\n@@ -485,7 +484,8 @@ compute_available (sbitmap *avloc, sbitmap *kill, sbitmap *avout,\n   /* Allocate a worklist array/queue.  Entries are only added to the\n      list if they were not already on the list.  So the size is\n      bounded by the number of basic blocks.  */\n-  qin = qout = worklist = xmalloc (sizeof (basic_block) * n_basic_blocks);\n+  qin = qout = worklist = \n+    xmalloc (sizeof (basic_block) * (n_basic_blocks - NUM_FIXED_BLOCKS));\n \n   /* We want a maximal solution.  */\n   sbitmap_vector_ones (avout, last_basic_block);\n@@ -499,8 +499,8 @@ compute_available (sbitmap *avloc, sbitmap *kill, sbitmap *avout,\n     }\n \n   qin = worklist;\n-  qend = &worklist[n_basic_blocks];\n-  qlen = n_basic_blocks;\n+  qend = &worklist[n_basic_blocks - NUM_FIXED_BLOCKS];\n+  qlen = n_basic_blocks - NUM_FIXED_BLOCKS;\n \n   /* Mark blocks which are successors of the entry block so that we\n      can easily identify them below.  */"}, {"sha": "2081efad81da07ae916ff0bc0a7efe4aeb654cea", "filename": "gcc/predict.c", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -707,7 +707,7 @@ predict_loops (struct loops *loops_info, bool rtlsimpleloops)\n \t     conditional has no loop header successors as not taken.  */\n \t  if (!header_found)\n \t    FOR_EACH_EDGE (e, ei, bb->succs)\n-\t      if (e->dest->index < 0\n+\t      if (e->dest->index < NUM_FIXED_BLOCKS\n \t\t  || !flow_bb_inside_loop_p (loop, e->dest))\n \t\tpredict_edge\n \t\t  (e, PRED_LOOP_EXIT,\n@@ -1271,7 +1271,7 @@ tree_bb_level_predictions (void)\n   int *heads;\n \n   heads = xmalloc (sizeof (int) * last_basic_block);\n-  memset (heads, -1, sizeof (int) * last_basic_block);\n+  memset (heads, ENTRY_BLOCK, sizeof (int) * last_basic_block);\n   heads[ENTRY_BLOCK_PTR->next_bb->index] = last_basic_block;\n \n   apply_return_prediction (heads);\n@@ -1500,7 +1500,7 @@ predict_paths_leading_to (basic_block bb, int *heads, enum br_predictor pred,\n   edge_iterator ei;\n   int y;\n \n-  if (heads[bb->index] < 0)\n+  if (heads[bb->index] == ENTRY_BLOCK)\n     {\n       /* This is first time we need this field in heads array; so\n          find first dominator that we do not post-dominate (we are\n@@ -1509,7 +1509,7 @@ predict_paths_leading_to (basic_block bb, int *heads, enum br_predictor pred,\n       basic_block next_ai = get_immediate_dominator (CDI_DOMINATORS, bb);\n       int head;\n \n-      while (heads[next_ai->index] < 0)\n+      while (heads[next_ai->index] == ENTRY_BLOCK)\n \t{\n \t  if (!dominated_by_p (CDI_POST_DOMINATORS, next_ai, bb))\n \t    break;\n@@ -1524,10 +1524,7 @@ predict_paths_leading_to (basic_block bb, int *heads, enum br_predictor pred,\n       while (next_ai != bb)\n \t{\n \t  next_ai = ai;\n-\t  if (heads[ai->index] == ENTRY_BLOCK)\n-\t    ai = ENTRY_BLOCK_PTR;\n-\t  else\n-\t    ai = BASIC_BLOCK (heads[ai->index]);\n+\t  ai = BASIC_BLOCK (heads[ai->index]);\n \t  heads[next_ai->index] = head;\n \t}\n     }\n@@ -1538,7 +1535,7 @@ predict_paths_leading_to (basic_block bb, int *heads, enum br_predictor pred,\n   if (y == last_basic_block)\n     return;\n   FOR_EACH_EDGE (e, ei, BASIC_BLOCK (y)->succs)\n-    if (e->dest->index >= 0\n+    if (e->dest->index >= NUM_FIXED_BLOCKS\n \t&& dominated_by_p (CDI_POST_DOMINATORS, e->dest, bb))\n       predict_edge_def (e, pred, taken);\n }\n@@ -1596,12 +1593,7 @@ propagate_freq (struct loop *loop, bitmap tovisit)\n        /* The outermost \"loop\" includes the exit block, which we can not\n \t  look up via BASIC_BLOCK.  Detect this and use EXIT_BLOCK_PTR\n \t  directly.  Do the same for the entry block.  */\n-     if (i == (unsigned)ENTRY_BLOCK)\n-       bb = ENTRY_BLOCK_PTR;\n-     else if (i == (unsigned)EXIT_BLOCK)\n-       bb = EXIT_BLOCK_PTR;\n-     else\n-       bb = BASIC_BLOCK (i);\n+      bb = BASIC_BLOCK (i);\n \n       FOR_EACH_EDGE (e, ei, bb->preds)\n \t{"}, {"sha": "45abbc40926fc357707e5a046d15e8af3c3ce579", "filename": "gcc/profile.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -531,7 +531,7 @@ compute_branch_probabilities (void)\n \t{\n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    e->probability = (e->count * REG_BR_PROB_BASE + bb->count / 2) / bb->count;\n-\t  if (bb->index >= 0\n+\t  if (bb->index >= NUM_FIXED_BLOCKS\n \t      && block_ends_with_condjump_p (bb)\n \t      && EDGE_COUNT (bb->succs) >= 2)\n \t    {\n@@ -609,7 +609,7 @@ compute_branch_probabilities (void)\n \t      FOR_EACH_EDGE (e, ei, bb->succs)\n \t\te->probability = REG_BR_PROB_BASE / total;\n \t    }\n-\t  if (bb->index >= 0\n+\t  if (bb->index >= NUM_FIXED_BLOCKS\n \t      && block_ends_with_condjump_p (bb)\n \t      && EDGE_COUNT (bb->succs) >= 2)\n \t    num_branches++, num_never_executed;\n@@ -704,7 +704,9 @@ compute_value_histograms (histogram_values values)\n       free (histogram_counts[t]);\n }\n \n-#define BB_TO_GCOV_INDEX(bb)  ((bb)->index + 1)\n+/* The entry basic block will be moved around so that it has index=1,\n+   there is nothing at index 0 and the exit is at n_basic_block.  */\n+#define BB_TO_GCOV_INDEX(bb)  ((bb)->index - 1)\n /* When passed NULL as file_name, initialize.\n    When passed something else, output the necessary commands to change\n    line to LINE and offset to FILE_NAME.  */\n@@ -917,7 +919,7 @@ branch_prob (void)\n \tnum_instrumented++;\n     }\n \n-  total_num_blocks += n_basic_blocks + 2;\n+  total_num_blocks += n_basic_blocks;\n   if (dump_file)\n     fprintf (dump_file, \"%d basic blocks\\n\", n_basic_blocks);\n \n@@ -938,15 +940,15 @@ branch_prob (void)\n       gcov_position_t offset;\n \n       offset = gcov_write_tag (GCOV_TAG_BLOCKS);\n-      for (i = 0; i != (unsigned) (n_basic_blocks + 2); i++)\n+      for (i = 0; i != (unsigned) (n_basic_blocks); i++)\n \tgcov_write_unsigned (0);\n       gcov_write_length (offset);\n     }\n \n    /* Keep all basic block indexes nonnegative in the gcov output.\n       Index 0 is used for entry block, last index is for exit block.\n       */\n-  ENTRY_BLOCK_PTR->index = -1;\n+  ENTRY_BLOCK_PTR->index = 1;\n   EXIT_BLOCK_PTR->index = last_basic_block;\n \n   /* Arcs */"}, {"sha": "c9e1ac51406972cc91ecbfe64bf320947a7cd42c", "filename": "gcc/regrename.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -1776,20 +1776,19 @@ copyprop_hardreg_forward (void)\n \n   all_vd = xmalloc (sizeof (struct value_data) * last_basic_block);\n \n-  visited = sbitmap_alloc (last_basic_block - (INVALID_BLOCK + 1));\n+  visited = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (visited);\n \n   FOR_EACH_BB (bb)\n     {\n-      SET_BIT (visited, bb->index - (INVALID_BLOCK + 1));\n+      SET_BIT (visited, bb->index);\n \n       /* If a block has a single predecessor, that we've already\n \t processed, begin with the value data that was live at\n \t the end of the predecessor block.  */\n       /* ??? Ought to use more intelligent queuing of blocks.  */\n-      if (single_pred_p (bb)\n-\t  && TEST_BIT (visited,\n-\t\t       single_pred (bb)->index - (INVALID_BLOCK + 1))\n+      if (single_pred_p (bb) \n+\t  && TEST_BIT (visited, single_pred (bb)->index)\n \t  && ! (single_pred_edge (bb)->flags & (EDGE_ABNORMAL_CALL | EDGE_EH)))\n \tall_vd[bb->index] = all_vd[single_pred (bb)->index];\n       else"}, {"sha": "9b06bb239240dc65f417f495fb60be76afd7b09b", "filename": "gcc/reorg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -3539,7 +3539,7 @@ dbr_schedule (rtx first, FILE *file)\n \n   /* If the current function has no insns other than the prologue and\n      epilogue, then do not try to fill any delay slots.  */\n-  if (n_basic_blocks == 0)\n+  if (n_basic_blocks == NUM_FIXED_BLOCKS)\n     return;\n \n   /* Find the highest INSN_UID and allocate and initialize our map from"}, {"sha": "a9a7cacecd0dee08e04445fa73135c776cb493d9", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -568,7 +568,7 @@ schedule_ebbs (FILE *dump_file)\n \n   /* Taking care of this degenerate case makes the rest of\n      this code simpler.  */\n-  if (n_basic_blocks == 0)\n+  if (n_basic_blocks == NUM_FIXED_BLOCKS)\n     return;\n \n   sched_init (dump_file);"}, {"sha": "f66966d6adf2b2febaaa5940a6619ad4e5e200f1", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -999,7 +999,7 @@ compute_trg_info (int trg)\n   sp->is_speculative = 0;\n   sp->src_prob = 100;\n \n-  visited = sbitmap_alloc (last_basic_block - (INVALID_BLOCK + 1));\n+  visited = sbitmap_alloc (last_basic_block);\n \n   for (i = trg + 1; i < current_nr_blocks; i++)\n     {\n@@ -1044,8 +1044,7 @@ compute_trg_info (int trg)\n \t      block = el.first_member[j]->src;\n \t      FOR_EACH_EDGE (e, ei, block->succs)\n \t\t{\n-\t\t  if (!TEST_BIT (visited,\n-\t\t\t\t e->dest->index - (INVALID_BLOCK + 1)))\n+\t\t  if (!TEST_BIT (visited, e->dest->index))\n \t\t    {\n \t\t      for (k = 0; k < el.nr_members; k++)\n \t\t\tif (e == el.first_member[k])\n@@ -1054,8 +1053,7 @@ compute_trg_info (int trg)\n \t\t      if (k >= el.nr_members)\n \t\t\t{\n \t\t\t  bblst_table[bblst_last++] = e->dest;\n-\t\t\t  SET_BIT (visited,\n-\t\t\t\t   e->dest->index - (INVALID_BLOCK + 1));\n+\t\t\t  SET_BIT (visited, e->dest->index);\n \t\t\t  update_idx++;\n \t\t\t}\n \t\t    }\n@@ -2469,7 +2467,7 @@ init_regions (void)\n \n   /* Compute regions for scheduling.  */\n   if (reload_completed\n-      || n_basic_blocks == 1\n+      || n_basic_blocks == NUM_FIXED_BLOCKS + 1\n       || !flag_schedule_interblock\n       || is_cfg_nonregular ())\n     {\n@@ -2526,18 +2524,16 @@ schedule_insns (FILE *dump_file)\n \n   /* Taking care of this degenerate case makes the rest of\n      this code simpler.  */\n-  if (n_basic_blocks == 0)\n+  if (n_basic_blocks == NUM_FIXED_BLOCKS)\n     return;\n \n   nr_inter = 0;\n   nr_spec = 0;\n-\n   sched_init (dump_file);\n \n   init_regions ();\n \n   current_sched_info = &region_sched_info;\n-\n   /* Schedule every region in the subroutine.  */\n   for (rgn = 0; rgn < nr_regions; rgn++)\n     schedule_region (rgn);"}, {"sha": "b65c316e9fd45787cea734a0da0fb70a000ec973", "filename": "gcc/tracer.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -72,7 +72,7 @@ static int branch_ratio_cutoff;\n static bool\n ignore_bb_p (basic_block bb)\n {\n-  if (bb->index < 0)\n+  if (bb->index < NUM_FIXED_BLOCKS)\n     return true;\n   if (!maybe_hot_bb_p (bb))\n     return true;\n@@ -363,7 +363,7 @@ layout_superblocks (void)\n void\n tracer (unsigned int flags)\n {\n-  if (n_basic_blocks <= 1)\n+  if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1)\n     return;\n \n   cfg_layout_initialize (flags);"}, {"sha": "6c0d1c0754ba4fa8d3727f39e9e372d907185e9a", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -129,14 +129,16 @@ init_empty_tree_cfg (void)\n   /* Initialize the basic block array.  */\n   init_flow ();\n   profile_status = PROFILE_ABSENT;\n-  n_basic_blocks = 0;\n-  last_basic_block = 0;\n+  n_basic_blocks = NUM_FIXED_BLOCKS;\n+  last_basic_block = NUM_FIXED_BLOCKS;\n   VARRAY_BB_INIT (basic_block_info, initial_cfg_capacity, \"basic_block_info\");\n \n   /* Build a mapping of labels to their associated blocks.  */\n   VARRAY_BB_INIT (label_to_block_map, initial_cfg_capacity,\n \t\t  \"label to block map\");\n \n+  BASIC_BLOCK (ENTRY_BLOCK) = ENTRY_BLOCK_PTR;\n+  BASIC_BLOCK (EXIT_BLOCK) = EXIT_BLOCK_PTR;\n   ENTRY_BLOCK_PTR->next_bb = EXIT_BLOCK_PTR;\n   EXIT_BLOCK_PTR->prev_bb = ENTRY_BLOCK_PTR;\n }\n@@ -170,7 +172,7 @@ build_tree_cfg (tree *tp)\n     factor_computed_gotos ();\n \n   /* Make sure there is always at least one block, even if it's empty.  */\n-  if (n_basic_blocks == 0)\n+  if (n_basic_blocks == NUM_FIXED_BLOCKS)\n     create_empty_bb (ENTRY_BLOCK_PTR);\n \n   /* Adjust the size of the array.  */\n@@ -430,7 +432,7 @@ make_edges (void)\n \n   /* Create an edge from entry to the first block with executable\n      statements in it.  */\n-  make_edge (ENTRY_BLOCK_PTR, BASIC_BLOCK (0), EDGE_FALLTHRU);\n+  make_edge (ENTRY_BLOCK_PTR, BASIC_BLOCK (NUM_FIXED_BLOCKS), EDGE_FALLTHRU);\n \n   /* Traverse the basic block array placing edges.  */\n   FOR_EACH_BB (bb)\n@@ -794,7 +796,8 @@ label_to_block_fn (struct function *ifun, tree dest)\n      and undefined variable warnings quite right.  */\n   if ((errorcount || sorrycount) && uid < 0)\n     {\n-      block_stmt_iterator bsi = bsi_start (BASIC_BLOCK (0));\n+      block_stmt_iterator bsi = \n+\tbsi_start (BASIC_BLOCK (NUM_FIXED_BLOCKS));\n       tree stmt;\n \n       stmt = build1 (LABEL_EXPR, void_type_node, dest);\n@@ -4656,7 +4659,7 @@ print_loop_ir (FILE *file)\n {\n   basic_block bb;\n   \n-  bb = BASIC_BLOCK (0);\n+  bb = BASIC_BLOCK (NUM_FIXED_BLOCKS);\n   if (bb && bb->loop_father)\n     print_loop (file, bb->loop_father, 0);\n }\n@@ -4738,7 +4741,7 @@ tree_flow_call_edges_add (sbitmap blocks)\n   int last_bb = last_basic_block;\n   bool check_last_block = false;\n \n-  if (n_basic_blocks == 0)\n+  if (n_basic_blocks == NUM_FIXED_BLOCKS)\n     return 0;\n \n   if (! blocks)"}, {"sha": "6b52fa76083df512583d0c63eccf66e2493f35e4", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -484,10 +484,11 @@ collect_dfa_stats (struct dfa_stats_d *dfa_stats_p)\n   memset ((void *)dfa_stats_p, 0, sizeof (struct dfa_stats_d));\n \n   /* Walk all the trees in the function counting references.  Start at\n-     basic block 0, but don't stop at block boundaries.  */\n+     basic block NUM_FIXED_BLOCKS, but don't stop at block boundaries.  */\n   pset = pointer_set_create ();\n \n-  for (i = bsi_start (BASIC_BLOCK (0)); !bsi_end_p (i); bsi_next (&i))\n+  for (i = bsi_start (BASIC_BLOCK (NUM_FIXED_BLOCKS));\n+       !bsi_end_p (i); bsi_next (&i))\n     walk_tree (bsi_stmt_ptr (i), collect_dfa_stats_r, (void *) dfa_stats_p,\n \t       pset);\n "}, {"sha": "56104b1b7007e6e3f897b2f8c87189fa9819cd1a", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -702,7 +702,7 @@ bsi_start (basic_block bb)\n     bsi.tsi = tsi_start (bb->stmt_list);\n   else\n     {\n-      gcc_assert (bb->index < 0);\n+      gcc_assert (bb->index < NUM_FIXED_BLOCKS);\n       bsi.tsi.ptr = NULL;\n       bsi.tsi.container = NULL;\n     }\n@@ -723,7 +723,7 @@ bsi_after_labels (basic_block bb)\n \n   if (!bb->stmt_list)\n     {\n-      gcc_assert (bb->index < 0);\n+      gcc_assert (bb->index < NUM_FIXED_BLOCKS);\n       bsi.tsi.ptr = NULL;\n       bsi.tsi.container = NULL;\n       return bsi;\n@@ -756,7 +756,7 @@ bsi_last (basic_block bb)\n     bsi.tsi = tsi_last (bb->stmt_list);\n   else\n     {\n-      gcc_assert (bb->index < 0);\n+      gcc_assert (bb->index < NUM_FIXED_BLOCKS);\n       bsi.tsi.ptr = NULL;\n       bsi.tsi.container = NULL;\n     }"}, {"sha": "43938d7bbe22020a4c35960f4025840783a8a5dc", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -148,9 +148,9 @@ tree_ssa_phiopt (void)\n      outer ones, and also that we do not try to visit a removed\n      block.  */\n   bb_order = blocks_in_phiopt_order ();\n-  n = n_basic_blocks;\n+  n = n_basic_blocks - NUM_FIXED_BLOCKS;\n \n-  for (i = 0; i < n; i++)\n+  for (i = 0; i < n; i++) \n     {\n       tree cond_expr;\n       tree phi;\n@@ -248,11 +248,12 @@ blocks_in_phiopt_order (void)\n {\n   basic_block x, y;\n   basic_block *order = xmalloc (sizeof (basic_block) * n_basic_blocks);\n-  unsigned n = n_basic_blocks, np, i;\n-  sbitmap visited = sbitmap_alloc (last_basic_block + 2);\n+  unsigned n = n_basic_blocks - NUM_FIXED_BLOCKS; \n+  unsigned np, i;\n+  sbitmap visited = sbitmap_alloc (last_basic_block); \n \n-#define MARK_VISITED(BB) (SET_BIT (visited, (BB)->index + 2))\n-#define VISITED_P(BB) (TEST_BIT (visited, (BB)->index + 2))\n+#define MARK_VISITED(BB) (SET_BIT (visited, (BB)->index)) \n+#define VISITED_P(BB) (TEST_BIT (visited, (BB)->index)) \n \n   sbitmap_zero (visited);\n "}, {"sha": "b8dfbfc694672257cd718f88d1b4c2db844c1507", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -234,7 +234,6 @@ operand_entry_eq (const void *p1, const void *p2)\n   return vr1->op == vr2->op;\n }\n \n-\n /* Given an expression E, return the rank of the expression.  */\n \n static unsigned int\n@@ -1452,7 +1451,7 @@ init_reassoc (void)\n     }\n \n   /* Set up rank for each BB  */\n-  for (i = 0; i < n_basic_blocks; i++)\n+  for (i = 0; i < n_basic_blocks - NUM_FIXED_BLOCKS; i++)\n     bb_rank[bbs[i]] = ++rank  << 16;\n \n   free (bbs);"}, {"sha": "766f6ef3aa1a080c823812b2bbc2a9a41d85865c", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bd1a0b27fc7ea64a1bec8eca37abc13cff4178/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=24bd1a0b27fc7ea64a1bec8eca37abc13cff4178", "patch": "@@ -1638,10 +1638,10 @@ vt_find_locations (void)\n \n   /* Compute reverse completion order of depth first search of the CFG\n      so that the data-flow runs faster.  */\n-  rc_order = xmalloc (n_basic_blocks * sizeof (int));\n+  rc_order = xmalloc ((n_basic_blocks - NUM_FIXED_BLOCKS) * sizeof (int));\n   bb_order = xmalloc (last_basic_block * sizeof (int));\n   flow_depth_first_order_compute (NULL, rc_order);\n-  for (i = 0; i < n_basic_blocks; i++)\n+  for (i = 0; i < n_basic_blocks - NUM_FIXED_BLOCKS; i++)\n     bb_order[rc_order[i]] = i;\n   free (rc_order);\n "}]}