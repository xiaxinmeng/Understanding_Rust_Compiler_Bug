{"sha": "604407070be6a945b7ccfe3fa89e51cfe112614f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjA0NDA3MDcwYmU2YTk0NWI3Y2NmZTNmYTg5ZTUxY2ZlMTEyNjE0Zg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2001-11-18T23:04:28Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-11-18T23:04:28Z"}, "message": "verify.cc: Include StringBuffer.h.\n\n\t* verify.cc: Include StringBuffer.h.\n\t(verify_fail): Added pc argument.  Use StringBuffer to construct\n\texception message.\n\t(_Jv_BytecodeVerifier::verify_instructions_0): Put PC into error\n\tmessage.\n\t(_Jv_BytecodeVerifier::check_return_type): Likewise.\n\t(_Jv_BytecodeVerifier::handle_field_or_method): Likewise.\n\t(_Jv_BytecodeVerifier::check_constant): Likewise.\n\t(_Jv_BytecodeVerifier::check_class_constant): Likewise.\n\t(_Jv_BytecodeVerifier::check_pool_index): Likewise.\n\t(_Jv_BytecodeVerifier::get_variable): Likewise.\n\t(_Jv_BytecodeVerifier::branch_prepass): Likewise.  Also, correctly\n\tcheck exception handler endpoint.\n\t(_Jv_BytecodeVerifier::verify_instructions_0): Correctly handle\n\twide arguments to current method.\n\t(_Jv_BytecodeVerifier::check_wide_constant): New method.\n\t(_Jv_BytecodeVerifier::verify_instructions_0) [op_ldc2_w]: Use\n\tit.\n\nFrom-SVN: r47155", "tree": {"sha": "1f211b5ce7ff2e548850c7b42594abc98a322b07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f211b5ce7ff2e548850c7b42594abc98a322b07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/604407070be6a945b7ccfe3fa89e51cfe112614f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/604407070be6a945b7ccfe3fa89e51cfe112614f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/604407070be6a945b7ccfe3fa89e51cfe112614f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/604407070be6a945b7ccfe3fa89e51cfe112614f/comments", "author": null, "committer": null, "parents": [{"sha": "20266bb1219d9bfda7327fe029cf3fb6a9bc1967", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20266bb1219d9bfda7327fe029cf3fb6a9bc1967", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20266bb1219d9bfda7327fe029cf3fb6a9bc1967"}], "stats": {"total": 142, "additions": 101, "deletions": 41}, "files": [{"sha": "ac1a38ec981afe978d19cc33584264dca255288e", "filename": "libjava/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604407070be6a945b7ccfe3fa89e51cfe112614f/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604407070be6a945b7ccfe3fa89e51cfe112614f/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=604407070be6a945b7ccfe3fa89e51cfe112614f", "patch": "@@ -1,3 +1,24 @@\n+2001-11-18  Tom Tromey  <tromey@redhat.com>\n+\n+\t* verify.cc: Include StringBuffer.h.\n+\t(verify_fail): Added pc argument.  Use StringBuffer to construct\n+\texception message.\n+\t(_Jv_BytecodeVerifier::verify_instructions_0): Put PC into error\n+\tmessage.\n+\t(_Jv_BytecodeVerifier::check_return_type): Likewise.\n+\t(_Jv_BytecodeVerifier::handle_field_or_method): Likewise.\n+\t(_Jv_BytecodeVerifier::check_constant): Likewise.\n+\t(_Jv_BytecodeVerifier::check_class_constant): Likewise.\n+\t(_Jv_BytecodeVerifier::check_pool_index): Likewise.\n+\t(_Jv_BytecodeVerifier::get_variable): Likewise.\n+\t(_Jv_BytecodeVerifier::branch_prepass): Likewise.  Also, correctly\n+\tcheck exception handler endpoint.\n+\t(_Jv_BytecodeVerifier::verify_instructions_0): Correctly handle\n+\twide arguments to current method.\n+\t(_Jv_BytecodeVerifier::check_wide_constant): New method.\n+\t(_Jv_BytecodeVerifier::verify_instructions_0) [op_ldc2_w]: Use\n+\tit.\n+\n 2001-11-17  Anthony Green  <green@redhat.com>\n \n \t* jni.cc (unwrap): Fix test for wrapped objects."}, {"sha": "9917d0ccbf3b5bb597cdc5250c350fa2839920e5", "filename": "libjava/verify.cc", "status": "modified", "additions": 80, "deletions": 41, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604407070be6a945b7ccfe3fa89e51cfe112614f/libjava%2Fverify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604407070be6a945b7ccfe3fa89e51cfe112614f/libjava%2Fverify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fverify.cc?ref=604407070be6a945b7ccfe3fa89e51cfe112614f", "patch": "@@ -23,6 +23,7 @@ details.  */\n #include <java/lang/VerifyError.h>\n #include <java/lang/Throwable.h>\n #include <java/lang/reflect/Modifier.h>\n+#include <java/lang/StringBuffer.h>\n \n \n // TO DO\n@@ -36,7 +37,8 @@ details.  */\n \n // This is global because __attribute__ doesn't seem to work on static\n // methods.\n-static void verify_fail (char *s) __attribute__ ((__noreturn__));\n+static void verify_fail (char *msg, jint pc = -1)\n+  __attribute__ ((__noreturn__));\n \n class _Jv_BytecodeVerifier\n {\n@@ -903,14 +905,14 @@ class _Jv_BytecodeVerifier\n   {\n     int depth = t.depth ();\n     if (index > current_method->max_locals - depth)\n-      verify_fail (\"invalid local variable\");\n+      verify_fail (\"invalid local variable\", start_PC);\n     if (! t.compatible (current_state->locals[index]))\n-      verify_fail (\"incompatible type in local variable\");\n+      verify_fail (\"incompatible type in local variable\", start_PC);\n     if (depth == 2)\n       {\n \ttype t (continuation_type);\n \tif (! current_state->locals[index + 1].compatible (t))\n-\t  verify_fail (\"invalid local variable\");\n+\t  verify_fail (\"invalid local variable\", start_PC);\n       }\n     current_state->note_variable (index);\n     return current_state->locals[index];\n@@ -1407,7 +1409,7 @@ class _Jv_BytecodeVerifier\n \t      jint low = get_int ();\n \t      jint hi = get_int ();\n \t      if (low > hi)\n-\t\tverify_fail (\"invalid tableswitch\");\n+\t\tverify_fail (\"invalid tableswitch\", start_PC);\n \t      for (int i = low; i <= hi; ++i)\n \t\tnote_branch_target (compute_jump (get_int ()));\n \t    }\n@@ -1419,7 +1421,7 @@ class _Jv_BytecodeVerifier\n \t      note_branch_target (compute_jump (get_int ()));\n \t      int npairs = get_int ();\n \t      if (npairs < 0)\n-\t\tverify_fail (\"too few pairs in lookupswitch\");\n+\t\tverify_fail (\"too few pairs in lookupswitch\", start_PC);\n \t      while (npairs-- > 0)\n \t\t{\n \t\t  get_int ();\n@@ -1451,28 +1453,33 @@ class _Jv_BytecodeVerifier\n \t    break;\n \n \t  default:\n-\t    verify_fail (\"unrecognized instruction in branch_prepass\");\n+\t    verify_fail (\"unrecognized instruction in branch_prepass\",\n+\t\t\t start_PC);\n \t  }\n \n \t// See if any previous branch tried to branch to the middle of\n \t// this instruction.\n \tfor (int pc = start_PC + 1; pc < PC; ++pc)\n \t  {\n \t    if ((flags[pc] & FLAG_BRANCH_TARGET))\n-\t      verify_fail (\"branch not to instruction start\");\n+\t      verify_fail (\"branch to middle of instruction\", pc);\n \t  }\n       }\n \n     // Verify exception handlers.\n     for (int i = 0; i < current_method->exc_count; ++i)\n       {\n \tif (! (flags[exception[i].handler_pc] & FLAG_INSN_START))\n-\t  verify_fail (\"exception handler not at instruction start\");\n+\t  verify_fail (\"exception handler not at instruction start\",\n+\t\t       exception[i].handler_pc);\n \tif (exception[i].start_pc > exception[i].end_pc)\n \t  verify_fail (\"exception range inverted\");\n-\tif (! (flags[exception[i].start_pc] & FLAG_INSN_START)\n-\t    || ! (flags[exception[i].start_pc] & FLAG_INSN_START))\n-\t  verify_fail (\"exception endpoint not at instruction start\");\n+\tif (! (flags[exception[i].start_pc] & FLAG_INSN_START))\n+\t  verify_fail (\"exception start not at instruction start\",\n+\t\t       exception[i].start_pc);\n+\telse if (! (flags[exception[i].end_pc] & FLAG_INSN_START))\n+\t  verify_fail (\"exception end not at instruction start\",\n+\t\t       exception[i].end_pc);\n \n \tflags[exception[i].handler_pc] |= FLAG_BRANCH_TARGET;\n       }\n@@ -1481,7 +1488,7 @@ class _Jv_BytecodeVerifier\n   void check_pool_index (int index)\n   {\n     if (index < 0 || index >= current_class->constants.size)\n-      verify_fail (\"constant pool index out of range\");\n+      verify_fail (\"constant pool index out of range\", start_PC);\n   }\n \n   type check_class_constant (int index)\n@@ -1492,7 +1499,7 @@ class _Jv_BytecodeVerifier\n       return type (pool->data[index].clazz);\n     else if (pool->tags[index] == JV_CONSTANT_Class)\n       return type (pool->data[index].utf8);\n-    verify_fail (\"expected class constant\");\n+    verify_fail (\"expected class constant\", start_PC);\n   }\n \n   type check_constant (int index)\n@@ -1506,7 +1513,18 @@ class _Jv_BytecodeVerifier\n       return type (int_type);\n     else if (pool->tags[index] == JV_CONSTANT_Float)\n       return type (float_type);\n-    verify_fail (\"String, int, or float constant expected\");\n+    verify_fail (\"String, int, or float constant expected\", start_PC);\n+  }\n+\n+  type check_wide_constant (int index)\n+  {\n+    check_pool_index (index);\n+    _Jv_Constants *pool = &current_class->constants;\n+    if (pool->tags[index] == JV_CONSTANT_Long)\n+      return type (long_type);\n+    else if (pool->tags[index] == JV_CONSTANT_Double)\n+      return type (double_type);\n+    verify_fail (\"long or double constant expected\", start_PC);\n   }\n \n   // Helper for both field and method.  These are laid out the same in\n@@ -1518,7 +1536,7 @@ class _Jv_BytecodeVerifier\n     check_pool_index (index);\n     _Jv_Constants *pool = &current_class->constants;\n     if (pool->tags[index] != expected)\n-      verify_fail (\"didn't see expected constant\");\n+      verify_fail (\"didn't see expected constant\", start_PC);\n     // Once we know we have a Fieldref or Methodref we assume that it\n     // is correctly laid out in the constant pool.  I think the code\n     // in defineclass.cc guarantees this.\n@@ -1626,7 +1644,7 @@ class _Jv_BytecodeVerifier\n   {\n     type rt = compute_return_type (current_method->self->signature);\n     if (! expected.compatible (rt))\n-      verify_fail (\"incompatible return type\");\n+      verify_fail (\"incompatible return type\", start_PC);\n   }\n \n   void verify_instructions_0 ()\n@@ -1635,6 +1653,7 @@ class _Jv_BytecodeVerifier\n \t\t\t       current_method->max_locals);\n \n     PC = 0;\n+    start_PC = 0;\n \n     {\n       int var = 0;\n@@ -1649,11 +1668,17 @@ class _Jv_BytecodeVerifier\n \t  ++var;\n \t}\n \n-      if (var + _Jv_count_arguments (current_method->self->signature)\n-\t  > current_method->max_locals)\n-\tverify_fail (\"too many arguments\");\n-      compute_argument_types (current_method->self->signature,\n-\t\t\t      &current_state->locals[var]);\n+      // We have to handle wide arguments specially here.\n+      int arg_count = _Jv_count_arguments (current_method->self->signature);\n+      type arg_types[arg_count];\n+      compute_argument_types (current_method->self->signature, arg_types);\n+      for (int i = 0; i < arg_count; ++i)\n+\t{\n+\t  set_variable (var, arg_types[i]);\n+\t  ++var;\n+\t  if (arg_types[i].iswide ())\n+\t    ++var;\n+\t}\n     }\n \n     states = (state **) _Jv_Malloc (sizeof (state *)\n@@ -1670,7 +1695,7 @@ class _Jv_BytecodeVerifier\n \t  {\n \t    PC = pop_jump ();\n \t    if (PC == state::INVALID)\n-\t      verify_fail (\"saw state::INVALID\");\n+\t      verify_fail (\"saw state::INVALID\", start_PC);\n \t    if (PC == state::NO_NEXT)\n \t      break;\n \t    // Set up the current state.\n@@ -1771,7 +1796,7 @@ class _Jv_BytecodeVerifier\n \t    push_type (check_constant (get_ushort ()));\n \t    break;\n \t  case op_ldc2_w:\n-\t    push_type (check_constant (get_ushort ()));\n+\t    push_type (check_wide_constant (get_ushort ()));\n \t    break;\n \n \t  case op_iload:\n@@ -2253,7 +2278,7 @@ class _Jv_BytecodeVerifier\n \t\t{\n \t\t  jint key = get_int ();\n \t\t  if (i > 0 && key <= lastkey)\n-\t\t    verify_fail (\"lookupswitch pairs unsorted\");\n+\t\t    verify_fail (\"lookupswitch pairs unsorted\", start_PC);\n \t\t  lastkey = key;\n \t\t  push_jump (get_int ());\n \t\t}\n@@ -2323,22 +2348,26 @@ class _Jv_BytecodeVerifier\n \t\t{\n \t\t  int nargs = get_byte ();\n \t\t  if (nargs == 0)\n-\t\t    verify_fail (\"too few arguments to invokeinterface\");\n+\t\t    verify_fail (\"too few arguments to invokeinterface\",\n+\t\t\t\t start_PC);\n \t\t  if (get_byte () != 0)\n-\t\t    verify_fail (\"invokeinterface dummy byte is wrong\");\n+\t\t    verify_fail (\"invokeinterface dummy byte is wrong\",\n+\t\t\t\t start_PC);\n \t\t  if (nargs - 1 != arg_count)\n-\t\t    verify_fail (\"wrong argument count for invokeinterface\");\n+\t\t    verify_fail (\"wrong argument count for invokeinterface\",\n+\t\t\t\t start_PC);\n \t\t}\n \n \t      bool is_init = false;\n \t      if (_Jv_equalUtf8Consts (method_name, gcj::init_name))\n \t\t{\n \t\t  is_init = true;\n \t\t  if (opcode != (unsigned char) op_invokespecial)\n-\t\t    verify_fail (\"can't invoke <init>\");\n+\t\t    verify_fail (\"can't invoke <init>\", start_PC);\n \t\t}\n \t      else if (method_name->data[0] == '<')\n-\t\tverify_fail (\"can't invoke method starting with `<'\");\n+\t\tverify_fail (\"can't invoke method starting with `<'\",\n+\t\t\t     start_PC);\n \n \t      // Pop arguments and check types.\n \t      type arg_types[arg_count];\n@@ -2370,7 +2399,8 @@ class _Jv_BytecodeVerifier\n \t    {\n \t      type t = check_class_constant (get_ushort ());\n \t      if (t.isarray () || t.isinterface () || t.isabstract ())\n-\t\tverify_fail (\"type is array, interface, or abstract\");\n+\t\tverify_fail (\"type is array, interface, or abstract\",\n+\t\t\t     start_PC);\n \t      t.set_uninitialized (start_PC);\n \t      push_type (t);\n \t    }\n@@ -2382,7 +2412,7 @@ class _Jv_BytecodeVerifier\n \t      // We intentionally have chosen constants to make this\n \t      // valid.\n \t      if (atype < boolean_type || atype > long_type)\n-\t\tverify_fail (\"type not primitive\");\n+\t\tverify_fail (\"type not primitive\", start_PC);\n \t      pop_type (int_type);\n \t      push_type (construct_primitive_array_type (type_val (atype)));\n \t    }\n@@ -2395,7 +2425,7 @@ class _Jv_BytecodeVerifier\n \t    {\n \t      type t = pop_type (reference_type);\n \t      if (! t.isarray ())\n-\t\tverify_fail (\"array type expected\");\n+\t\tverify_fail (\"array type expected\", start_PC);\n \t      push_type (int_type);\n \t    }\n \t    break;\n@@ -2460,7 +2490,7 @@ class _Jv_BytecodeVerifier\n \t\t  get_short ();\n \t\t  break;\n \t\tdefault:\n-\t\t  verify_fail (\"unrecognized wide instruction\");\n+\t\t  verify_fail (\"unrecognized wide instruction\", start_PC);\n \t\t}\n \t    }\n \t    break;\n@@ -2469,7 +2499,7 @@ class _Jv_BytecodeVerifier\n \t      type atype = check_class_constant (get_ushort ());\n \t      int dim = get_byte ();\n \t      if (dim < 1)\n-\t\tverify_fail (\"too few dimensions to multianewarray\");\n+\t\tverify_fail (\"too few dimensions to multianewarray\", start_PC);\n \t      atype.verify_dimensions (dim);\n \t      for (int i = 0; i < dim; ++i)\n \t\tpop_type (int_type);\n@@ -2491,7 +2521,8 @@ class _Jv_BytecodeVerifier\n \n \t  default:\n \t    // Unrecognized opcode.\n-\t    verify_fail (\"unrecognized instruction in verify_instructions_0\");\n+\t    verify_fail (\"unrecognized instruction in verify_instructions_0\",\n+\t\t\t start_PC);\n \t  }\n       }\n   }\n@@ -2536,12 +2567,20 @@ _Jv_VerifyMethod (_Jv_InterpMethod *meth)\n \n // FIXME: add more info, like PC, when required.\n static void\n-verify_fail (char *s)\n+verify_fail (char *s, jint pc)\n {\n-  char buf[1024];\n-  strcpy (buf, \"verification failed: \");\n-  strcat (buf, s);\n-  throw new java::lang::VerifyError (JvNewStringLatin1 (buf));\n+  using namespace java::lang;\n+  StringBuffer *buf = new StringBuffer ();\n+\n+  buf->append (JvNewStringLatin1 (\"verification failed\"));\n+  if (pc != -1)\n+    {\n+      buf->append (JvNewStringLatin1 (\" at PC \"));\n+      buf->append (pc);\n+    }\n+  buf->append (JvNewStringLatin1 (\": \"));\n+  buf->append (JvNewStringLatin1 (s));\n+  throw new java::lang::VerifyError (buf->toString ());\n }\n \n #endif\t/* INTERPRETER */"}]}