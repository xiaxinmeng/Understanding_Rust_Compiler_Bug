{"sha": "79325812b80ccd6d30dafc110cb404c16dc5e43e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzkzMjU4MTJiODBjY2Q2ZDMwZGFmYzExMGNiNDA0YzE2ZGM1ZTQzZQ==", "commit": {"author": {"name": "Ulrich Drepper", "email": "drepper@cygnus.com", "date": "1998-07-06T23:42:47Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-07-06T23:42:47Z"}, "message": "* i386.c: Remove random whitespace at end of lines.\n\nFrom-SVN: r20980", "tree": {"sha": "f7c056e6843635493ec5c2296522d5dac7086f27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7c056e6843635493ec5c2296522d5dac7086f27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79325812b80ccd6d30dafc110cb404c16dc5e43e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79325812b80ccd6d30dafc110cb404c16dc5e43e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79325812b80ccd6d30dafc110cb404c16dc5e43e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79325812b80ccd6d30dafc110cb404c16dc5e43e/comments", "author": null, "committer": null, "parents": [{"sha": "3403c6ca8f7d0abdb9c9907d7100136f3d2ae061", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3403c6ca8f7d0abdb9c9907d7100136f3d2ae061", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3403c6ca8f7d0abdb9c9907d7100136f3d2ae061"}], "stats": {"total": 108, "additions": 55, "deletions": 53}, "files": [{"sha": "3a1d6f9d019ef4f6cbfe4f765b2cfdba38e7c54f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79325812b80ccd6d30dafc110cb404c16dc5e43e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79325812b80ccd6d30dafc110cb404c16dc5e43e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=79325812b80ccd6d30dafc110cb404c16dc5e43e", "patch": "@@ -1,5 +1,7 @@\n Tue Jul  7 00:36:41 1998  Ulrich Drepper <drepper@cygnus.com>\n \n+\t* i386.c: Remove random whitespace at end of lines.\n+\n \t* i386.c (ix86_epilogue): For pentium processors, try to deallocate\n \t4 or 8 byte stacks with pop instructions instead of an add instruction.\n "}, {"sha": "76f5370f410edcf430622dedcad7f0325e825d7b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79325812b80ccd6d30dafc110cb404c16dc5e43e/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79325812b80ccd6d30dafc110cb404c16dc5e43e/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=79325812b80ccd6d30dafc110cb404c16dc5e43e", "patch": "@@ -129,7 +129,7 @@ enum reg_class regclass_map[FIRST_PSEUDO_REGISTER] =\n   SIREG, DIREG, INDEX_REGS, GENERAL_REGS,\n   /* FP registers */\n   FP_TOP_REG, FP_SECOND_REG, FLOAT_REGS, FLOAT_REGS,\n-  FLOAT_REGS, FLOAT_REGS, FLOAT_REGS, FLOAT_REGS,       \n+  FLOAT_REGS, FLOAT_REGS, FLOAT_REGS, FLOAT_REGS,\n   /* arg pointer */\n   INDEX_REGS\n };\n@@ -227,7 +227,7 @@ override_options ()\n       for (i = 0; (ch = i386_reg_alloc_order[i]) != '\\0'; i++)\n \t{\n \t  int regno = 0;\n-\t  \n+\n \t  switch (ch)\n \t    {\n \t    case 'a':\tregno = 0;\tbreak;\n@@ -254,7 +254,7 @@ override_options ()\n       if (ix86_cpu_string == 0)\n \tix86_cpu_string = PROCESSOR_DEFAULT_STRING;\n     }\n-  \n+\n   for (i = 0; i < ptt_size; i++)\n     if (! strcmp (ix86_arch_string, processor_target_table[i].name))\n       {\n@@ -392,7 +392,7 @@ order_regs_for_local_alloc ()\n       for (i = order = 0; (ch = i386_reg_alloc_order[i]) != '\\0'; i++)\n \t{\n \t  int regno = 0;\n-\t  \n+\n \t  switch (ch)\n \t    {\n \t    case 'a':\tregno = 0;\tbreak;\n@@ -502,7 +502,7 @@ i386_aligned_p (op)\n \n     case REG:\n       return i386_aligned_reg_p (REGNO (op));\n-    \n+\n     default:\n       break;\n     }\n@@ -620,27 +620,27 @@ i386_return_pops_args (fundecl, funtype, size)\n      tree fundecl;\n      tree funtype;\n      int size;\n-{ \n+{\n   int rtd = TARGET_RTD && (!fundecl || TREE_CODE (fundecl) != IDENTIFIER_NODE);\n \n     /* Cdecl functions override -mrtd, and never pop the stack. */\n   if (! lookup_attribute (\"cdecl\", TYPE_ATTRIBUTES (funtype))) {\n-  \n+\n     /* Stdcall functions will pop the stack if not variable args. */\n     if (lookup_attribute (\"stdcall\", TYPE_ATTRIBUTES (funtype)))\n       rtd = 1;\n-  \n+\n     if (rtd\n         && (TYPE_ARG_TYPES (funtype) == NULL_TREE\n \t    || (TREE_VALUE (tree_last (TYPE_ARG_TYPES (funtype)))\n \t\t== void_type_node)))\n       return size;\n   }\n-  \n+\n   /* Lose any fake structure return argument.  */\n   if (aggregate_value_p (TREE_TYPE (funtype)))\n     return GET_MODE_SIZE (Pmode);\n-  \n+\n     return 0;\n }\n \n@@ -927,7 +927,7 @@ output_to_reg (dest, dies, scratch_mem)\n \toutput_asm_insn (AS1 (pop%L0,%0), &dest);\n       else\n \t{\n-\t  xops[0] = adj_offsettable_operand (xops[0], 4);\t      \n+\t  xops[0] = adj_offsettable_operand (xops[0], 4);\n \t  xops[3] = dest;\n \t  output_asm_insn (AS2 (mov%L0,%0,%3), xops);\n \t}\n@@ -939,7 +939,7 @@ output_to_reg (dest, dies, scratch_mem)\n \t    output_asm_insn (AS1 (pop%L0,%0), &dest);\n \t  else\n \t    {\n-\t      xops[0] = adj_offsettable_operand (xops[0], 4);\t      \n+\t      xops[0] = adj_offsettable_operand (xops[0], 4);\n \t      output_asm_insn (AS2 (mov%L0,%0,%3), xops);\n \t    }\n \t}\n@@ -1145,7 +1145,7 @@ output_move_double (operands)\n          middlehalf[0] = operands[0];\n          latehalf[0] = operands[0];\n \t}\n-    \n+\n       if (optype1 == REGOP)\n \t{\n           middlehalf[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n@@ -1365,7 +1365,7 @@ output_move_pushmem (operands, insn, length, tmp_start, n_operands)\n       char *push;\n       rtx   xops[2];\n     } tmp_info[MAX_TMPS];\n-  \n+\n   rtx src = operands[1];\n   int max_tmps = 0;\n   int offset = 0;\n@@ -1777,7 +1777,7 @@ ix86_expand_binary_operator (code, mode, operands)\n \t  emit_move_insn (temp, operands[1]);\n \t  operands[1] = temp;\n \t  return TRUE;\n-\t}\t  \n+\t}\n     }\n \n   if (!ix86_binary_operator_ok (code, mode, operands))\n@@ -1810,7 +1810,7 @@ ix86_expand_binary_operator (code, mode, operands)\n \t      emit_move_insn (temp, operands[1]);\n \t      operands[1] = temp;\n \t      return TRUE;\n-\t    }\t  \n+\t    }\n \n \t  if (modified && ! ix86_binary_operator_ok (code, mode, operands))\n \t    return FALSE;\n@@ -1943,7 +1943,7 @@ function_prologue (file, size)\n       pic_label_rtx = 0;\n       return;\n     }\n-  \n+\n   ix86_prologue (0);\n }\n \n@@ -1954,7 +1954,7 @@ ix86_expand_prologue ()\n {\n   if (! TARGET_SCHEDULE_PROLOGUE)\n       return;\n- \n+\n   ix86_prologue (1);\n }\n \n@@ -1981,9 +1981,9 @@ load_pic_register (do_rtl)\n       if (do_rtl)\n \t{\n \t  emit_insn (gen_prologue_get_pc (xops[0], xops[1]));\n-\t  emit_insn (gen_prologue_set_got (xops[0], \n+\t  emit_insn (gen_prologue_set_got (xops[0],\n \t\t\t\t\t   gen_rtx (SYMBOL_REF, Pmode,\n-\t\t\t\t\t\t    \"$_GLOBAL_OFFSET_TABLE_\"), \n+\t\t\t\t\t\t    \"$_GLOBAL_OFFSET_TABLE_\"),\n \t\t\t\t\t   xops[1]));\n \t}\n       else\n@@ -1998,7 +1998,7 @@ load_pic_register (do_rtl)\n     {\n       xops[0] = pic_offset_table_rtx;\n       xops[1] = gen_label_rtx ();\n- \n+\n       if (do_rtl)\n \t{\n \t  /* We can't put a raw CODE_LABEL into the RTL, and we can't emit\n@@ -2009,12 +2009,12 @@ load_pic_register (do_rtl)\n       else\n \t{\n \t  output_asm_insn (AS1 (call,%P1), xops);\n-\t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\", \n+\t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",\n \t\t\t\t     CODE_LABEL_NUMBER (xops[1]));\n \t  output_asm_insn (AS1 (pop%L0,%0), xops);\n \t  output_asm_insn (\"addl $_GLOBAL_OFFSET_TABLE_+[.-%P1],%0\", xops);\n \t}\n-    } \n+    }\n \n   /* When -fpic, we must emit a scheduling barrier, so that the instruction\n      that restores %ebx (which is PIC_OFFSET_TABLE_REGNUM), does not get\n@@ -2036,7 +2036,7 @@ ix86_prologue (do_rtl)\n   long tsize = get_frame_size ();\n   rtx insn;\n   int cfa_offset = INCOMING_FRAME_SP_OFFSET, cfa_store_offset = cfa_offset;\n-  \n+\n   xops[0] = stack_pointer_rtx;\n   xops[1] = frame_pointer_rtx;\n   xops[2] = GEN_INT (tsize);\n@@ -2058,7 +2058,7 @@ ix86_prologue (do_rtl)\n \n       else\n \t{\n-\t  output_asm_insn (\"push%L1 %1\", xops); \n+\t  output_asm_insn (\"push%L1 %1\", xops);\n #ifdef INCOMING_RETURN_ADDR_RTX\n  \t  if (dwarf2out_do_frame ())\n  \t    {\n@@ -2071,7 +2071,7 @@ ix86_prologue (do_rtl)\n  \t    }\n #endif\n \n-\t  output_asm_insn (AS2 (mov%L0,%0,%1), xops); \n+\t  output_asm_insn (AS2 (mov%L0,%0,%1), xops);\n #ifdef INCOMING_RETURN_ADDR_RTX\n  \t  if (dwarf2out_do_frame ())\n  \t    dwarf2out_def_cfa (\"\", FRAME_POINTER_REGNUM, cfa_offset);\n@@ -2088,7 +2088,7 @@ ix86_prologue (do_rtl)\n \t  insn = emit_insn (gen_prologue_set_stack_ptr (xops[2]));\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n-      else \n+      else\n \t{\n \t  output_asm_insn (AS2 (sub%L0,%2,%0), xops);\n #ifdef INCOMING_RETURN_ADDR_RTX\n@@ -2104,7 +2104,7 @@ ix86_prologue (do_rtl)\n #endif\n \t}\n     }\n-  else \n+  else\n     {\n       xops[3] = gen_rtx_REG (SImode, 0);\n       if (do_rtl)\n@@ -2182,7 +2182,7 @@ ix86_prologue (do_rtl)\n /* Return 1 if it is appropriate to emit `ret' instructions in the\n    body of a function.  Do this only if the epilogue is simple, needing a\n    couple of insns.  Prior to reloading, we can't tell how many registers\n-   must be saved, so return 0 then.  Return 0 if there is no frame \n+   must be saved, so return 0 then.  Return 0 if there is no frame\n    marker to de-allocate.\n \n    If NON_SAVING_SETJMP is defined and true, then it is not possible\n@@ -2229,7 +2229,7 @@ function_epilogue (file, size)\n     return;\n }\n \n-/* Restore function stack, frame, and registers. */ \n+/* Restore function stack, frame, and registers. */\n \n void\n ix86_expand_epilogue ()\n@@ -2440,7 +2440,7 @@ ix86_epilogue (do_rtl)\n \t      output_asm_insn (\"jmp %*%0\", xops);\n \t    }\n \t}\n-      else \n+      else\n \t{\n \t  if (do_rtl)\n \t    emit_jump_insn (gen_return_pop_internal (xops[1]));\n@@ -3119,7 +3119,7 @@ put_condition_code (code, reverse_cc, mode, file)\n   if (mode == MODE_INT)\n     switch (code)\n       {\n-      case NE: \n+      case NE:\n \tif (cc_prev_status.flags & CC_Z_IN_NOT_C)\n \t  fputs (\"b\", file);\n \telse\n@@ -3178,34 +3178,34 @@ put_condition_code (code, reverse_cc, mode, file)\n   else if (mode == MODE_FLOAT)\n     switch (code)\n       {\n-      case NE: \n+      case NE:\n \tfputs (ieee ? (reverse_cc ? \"ne\" : \"e\") : \"ne\", file);\n \treturn;\n-      case EQ: \n+      case EQ:\n \tfputs (ieee ? (reverse_cc ? \"ne\" : \"e\") : \"e\", file);\n \treturn;\n-      case GE: \n+      case GE:\n \tfputs (ieee ? (reverse_cc ? \"ne\" : \"e\") : \"nb\", file);\n \treturn;\n-      case GT: \n+      case GT:\n \tfputs (ieee ? (reverse_cc ? \"ne\" : \"e\") : \"nbe\", file);\n \treturn;\n-      case LE: \n+      case LE:\n \tfputs (ieee ? (reverse_cc ? \"nb\" : \"b\") : \"be\", file);\n \treturn;\n-      case LT: \n+      case LT:\n \tfputs (ieee ? (reverse_cc ? \"ne\" : \"e\") : \"b\", file);\n \treturn;\n-      case GEU: \n+      case GEU:\n \tfputs (ieee ? (reverse_cc ? \"ne\" : \"e\") : \"nb\", file);\n \treturn;\n-      case GTU: \n+      case GTU:\n \tfputs (ieee ? (reverse_cc ? \"ne\" : \"e\") : \"nbe\", file);\n \treturn;\n-      case LEU: \n+      case LEU:\n \tfputs (ieee ? (reverse_cc ? \"nb\" : \"b\") : \"be\", file);\n \treturn;\n-      case LTU: \n+      case LTU:\n \tfputs (ieee ? (reverse_cc ? \"ne\" : \"e\") : \"b\", file);\n \treturn;\n       default:\n@@ -3345,9 +3345,9 @@ print_operand (file, x, code)\n \t    case GTU: fputs (\"jne\",  file); return;\n \t    case LEU: fputs (\"je\", file); return;\n \t    case LTU: fputs (\"#branch never\",  file); return;\n-\t    \n+\n \t    /* no matching branches for GT nor LE */\n-\t    \n+\n \t    default:\n \t      abort ();\n \t    }\n@@ -3439,7 +3439,7 @@ print_operand (file, x, code)\n       REAL_VALUE_TO_DECIMAL (r, \"%.22e\", dstr);\n       fprintf (file, \"%s\", dstr);\n     }\n-  else \n+  else\n     {\n       if (code != 'P')\n \t{\n@@ -4080,7 +4080,7 @@ output_float_compare (insn, operands)\n       operands[1] = tmp;\n       cc_status.flags |= CC_REVERSED;\n     }\n-    \n+\n   if (! STACK_TOP_P (operands[0]))\n     abort ();\n \n@@ -4139,7 +4139,7 @@ output_float_compare (insn, operands)\n \n       if (NON_STACK_REG_P (operands[1]))\n \toutput_op_from_reg (operands[1], strcat (buf, AS1 (%z0,%1)));\n-      else if (cc_status.flags & CC_FCOMI) \n+      else if (cc_status.flags & CC_FCOMI)\n \t{\n \t  output_asm_insn (strcat (buf, AS2 (%z1,%y1,%0)), operands);\n \t  return \"\";\n@@ -4174,7 +4174,7 @@ output_fp_cc0_set (insn)\n       if (!(cc_status.flags & CC_REVERSED))\n         {\n           next = next_cc0_user (insn);\n-        \n+\n           if (GET_CODE (next) == JUMP_INSN\n               && GET_CODE (PATTERN (next)) == SET\n               && SET_DEST (PATTERN (next)) == pc_rtx\n@@ -4437,7 +4437,7 @@ copy_all_rtx (orig)\n   copy->integrated = orig->integrated;\n   /* intel1 */\n   copy->is_spill_rtx = orig->is_spill_rtx;\n-  \n+\n   format_ptr = GET_RTX_FORMAT (GET_CODE (copy));\n \n   for (i = 0; i < GET_RTX_LENGTH (GET_CODE (copy)); i++)\n@@ -4489,7 +4489,7 @@ copy_all_rtx (orig)\n \f\n /* Try to rewrite a memory address to make it valid */\n \n-void \n+void\n rewrite_address (mem_rtx)\n      rtx mem_rtx;\n {\n@@ -4526,7 +4526,7 @@ rewrite_address (mem_rtx)\n       obfree (storage);\n     }\n \n-  /* This part is utilized by loop.c.  \n+  /* This part is utilized by loop.c.\n      If the address contains PLUS (reg,const) and this pattern is invalid\n      in this case - try to rewrite the address to make it valid. */\n   storage = oballoc (0);\n@@ -5159,7 +5159,7 @@ output_strlen_unroll (operands)\n   /* Check third byte. */\n   output_asm_insn (AS2 (test%L1,%16,%1), xops);\n   output_asm_insn (AS1 (je,%l10), xops);\n-  \n+\n   /* Check fourth byte and increment address. */\n   output_asm_insn (AS2 (add%L0,%5,%0), xops);\n   output_asm_insn (AS2 (test%L1,%17,%1), xops);\n@@ -5190,7 +5190,7 @@ output_fp_conditional_move (which_alternative, operands)\n       /* r <- cond ? arg : r */\n       output_asm_insn (AS2 (fcmov%F1,%2,%0), operands);\n       break;\n-  \n+\n     case 1:\n       /* r <- cond ? r : arg */\n       output_asm_insn (AS2 (fcmov%f1,%3,%0), operands);"}]}