{"sha": "db04bcf2622ba8641487f1bfc9cf928a3f4ca7ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGIwNGJjZjI2MjJiYTg2NDE0ODdmMWJmYzljZjkyOGEzZjRjYTdhZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-09-06T13:26:54Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-09-06T13:26:54Z"}, "message": "tree-ssa-pre.c (NECESSARY): Remove.\n\n2017-09-06  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-pre.c (NECESSARY): Remove.\n\t(create_expression_by_pieces): Do not touch pass-local flags.\n\t(insert_into_preds_of_block): Likewise.\n\t(do_pre_regular_insertion): Likewise.\n\t(eliminate_insert): Likewise.\n\t(eliminate_dom_walker::before_dom_children): Likewise.\n\t(fini_eliminate): Do not look at inserted_exprs.\n\t(mark_operand_necessary): Remove.\n\t(remove_dead_inserted_code): Replace with simple work-list\n\talgorithm based on inserted_exprs and SSA uses.\n\t(pass_pre::execute): Re-order fini_eliminate and\n\tremove_dead_inserted_code.\n\nFrom-SVN: r251798", "tree": {"sha": "638923d8746e47d400e4d77ee7318a21cde2e06a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/638923d8746e47d400e4d77ee7318a21cde2e06a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db04bcf2622ba8641487f1bfc9cf928a3f4ca7ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db04bcf2622ba8641487f1bfc9cf928a3f4ca7ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db04bcf2622ba8641487f1bfc9cf928a3f4ca7ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db04bcf2622ba8641487f1bfc9cf928a3f4ca7ae/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c48e0f27232aa6604b80e0d15b6ecb50604400a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c48e0f27232aa6604b80e0d15b6ecb50604400a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c48e0f27232aa6604b80e0d15b6ecb50604400a7"}], "stats": {"total": 203, "additions": 51, "deletions": 152}, "files": [{"sha": "5df398caea7fd9e05059bbd456309506166d2264", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db04bcf2622ba8641487f1bfc9cf928a3f4ca7ae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db04bcf2622ba8641487f1bfc9cf928a3f4ca7ae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=db04bcf2622ba8641487f1bfc9cf928a3f4ca7ae", "patch": "@@ -1,3 +1,18 @@\n+2017-09-06  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-ssa-pre.c (NECESSARY): Remove.\n+\t(create_expression_by_pieces): Do not touch pass-local flags.\n+\t(insert_into_preds_of_block): Likewise.\n+\t(do_pre_regular_insertion): Likewise.\n+\t(eliminate_insert): Likewise.\n+\t(eliminate_dom_walker::before_dom_children): Likewise.\n+\t(fini_eliminate): Do not look at inserted_exprs.\n+\t(mark_operand_necessary): Remove.\n+\t(remove_dead_inserted_code): Replace with simple work-list\n+\talgorithm based on inserted_exprs and SSA uses.\n+\t(pass_pre::execute): Re-order fini_eliminate and\n+\tremove_dead_inserted_code.\n+\n 2017-09-06  Olivier Hainque  <hainque@adacore.com>\n \n \t* config/powerpcspe/vxworks.h (VXCPU_FOR_8548): Correct definition"}, {"sha": "1ca68d44d22374eec714a7f5d3e583cc3c67f361", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 36, "deletions": 152, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db04bcf2622ba8641487f1bfc9cf928a3f4ca7ae/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db04bcf2622ba8641487f1bfc9cf928a3f4ca7ae/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=db04bcf2622ba8641487f1bfc9cf928a3f4ca7ae", "patch": "@@ -2753,8 +2753,6 @@ find_or_generate_expression (basic_block block, tree op, gimple_seq *stmts)\n   return NULL_TREE;\n }\n \n-#define NECESSARY GF_PLF_1\n-\n /* Create an expression in pieces, so that we can handle very complex\n    expressions that may be ANTIC, but not necessary GIMPLE.\n    BLOCK is the basic block the expression will be inserted into,\n@@ -2972,7 +2970,6 @@ create_expression_by_pieces (basic_block block, pre_expr expr,\n \t    }\n \n \t  bitmap_set_bit (inserted_exprs, SSA_NAME_VERSION (forcedname));\n-\t  gimple_set_plf (stmt, NECESSARY, false);\n \t}\n       gimple_seq_add_seq (stmts, forced_stmts);\n     }\n@@ -3095,7 +3092,6 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n   temp = make_temp_ssa_name (type, NULL, \"prephitmp\");\n   phi = create_phi_node (temp, block);\n \n-  gimple_set_plf (phi, NECESSARY, false);\n   VN_INFO_GET (temp)->value_id = val;\n   VN_INFO (temp)->valnum = sccvn_valnum_from_value_id (val);\n   if (VN_INFO (temp)->valnum == NULL_TREE)\n@@ -3342,7 +3338,6 @@ do_pre_regular_insertion (basic_block block, basic_block dom)\n \t      gimple_stmt_iterator gsi = gsi_after_labels (block);\n \t      gsi_insert_before (&gsi, assign, GSI_NEW_STMT);\n \n-\t      gimple_set_plf (assign, NECESSARY, false);\n \t      VN_INFO_GET (temp)->value_id = val;\n \t      VN_INFO (temp)->valnum = sccvn_valnum_from_value_id (val);\n \t      if (VN_INFO (temp)->valnum == NULL_TREE)\n@@ -4204,9 +4199,6 @@ eliminate_insert (gimple_stmt_iterator *gsi, tree val)\n     {\n       gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n       VN_INFO_GET (res)->valnum = val;\n-\n-      if (TREE_CODE (leader) == SSA_NAME)\n-\tgimple_set_plf (SSA_NAME_DEF_STMT (leader), NECESSARY, true);\n     }\n \n   pre_stats.insertions++;\n@@ -4291,17 +4283,9 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \n \t  remove_phi_node (&gsi, false);\n \n-\t  if (inserted_exprs\n-\t      && !bitmap_bit_p (inserted_exprs, SSA_NAME_VERSION (res))\n-\t      && TREE_CODE (sprime) == SSA_NAME)\n-\t    gimple_set_plf (SSA_NAME_DEF_STMT (sprime), NECESSARY, true);\n-\n \t  if (!useless_type_conversion_p (TREE_TYPE (res), TREE_TYPE (sprime)))\n \t    sprime = fold_convert (TREE_TYPE (res), sprime);\n \t  gimple *stmt = gimple_build_assign (res, sprime);\n-\t  /* ???  It cannot yet be necessary (DOM walk).  */\n-\t  gimple_set_plf (stmt, NECESSARY, gimple_plf (phi, NECESSARY));\n-\n \t  gimple_stmt_iterator gsi2 = gsi_after_labels (b);\n \t  gsi_insert_before (&gsi2, stmt, GSI_NEW_STMT);\n \t  continue;\n@@ -4478,10 +4462,6 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \t\t  print_gimple_stmt (dump_file, stmt, 0);\n \t\t}\n \n-\t      if (TREE_CODE (sprime) == SSA_NAME)\n-\t\tgimple_set_plf (SSA_NAME_DEF_STMT (sprime),\n-\t\t\t\tNECESSARY, true);\n-\n \t      pre_stats.eliminations++;\n \t      gimple *orig_stmt = stmt;\n \t      if (!useless_type_conversion_p (TREE_TYPE (lhs),\n@@ -4615,10 +4595,6 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \t    {\n \t      propagate_value (use_p, sprime);\n \t      modified = true;\n-\t      if (TREE_CODE (sprime) == SSA_NAME\n-\t\t  && !is_gimple_debug (stmt))\n-\t\tgimple_set_plf (SSA_NAME_DEF_STMT (sprime),\n-\t\t\t\tNECESSARY, true);\n \t    }\n \t}\n \n@@ -4787,11 +4763,7 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \t    continue;\n \t  tree sprime = eliminate_avail (arg);\n \t  if (sprime && may_propagate_copy (arg, sprime))\n-\t    {\n-\t      propagate_value (use_p, sprime);\n-\t      if (TREE_CODE (sprime) == SSA_NAME)\n-\t\tgimple_set_plf (SSA_NAME_DEF_STMT (sprime), NECESSARY, true);\n-\t    }\n+\t    propagate_value (use_p, sprime);\n \t}\n   return NULL;\n }\n@@ -4853,18 +4825,6 @@ fini_eliminate (void)\n     {\n       stmt = el_to_remove.pop ();\n \n-      tree lhs;\n-      if (gimple_code (stmt) == GIMPLE_PHI)\n-\tlhs = gimple_phi_result (stmt);\n-      else\n-\tlhs = gimple_get_lhs (stmt);\n-\n-      if (inserted_exprs\n-\t  && lhs\n-\t  && TREE_CODE (lhs) == SSA_NAME\n-\t  && bitmap_bit_p (inserted_exprs, SSA_NAME_VERSION (lhs)))\n-\tcontinue;\n-\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"Removing dead stmt \");\n@@ -4926,136 +4886,60 @@ fini_eliminate (void)\n   return todo;\n }\n \n-/* Borrow a bit of tree-ssa-dce.c for the moment.\n-   XXX: In 4.1, we should be able to just run a DCE pass after PRE, though\n-   this may be a bit faster, and we may want critical edges kept split.  */\n-\n-/* If OP's defining statement has not already been determined to be necessary,\n-   mark that statement necessary. Return the stmt, if it is newly\n-   necessary.  */\n-\n-static inline gimple *\n-mark_operand_necessary (tree op)\n-{\n-  gimple *stmt;\n-\n-  gcc_assert (op);\n-\n-  if (TREE_CODE (op) != SSA_NAME)\n-    return NULL;\n+/* Cheap DCE of a known set of possibly dead stmts.\n \n-  stmt = SSA_NAME_DEF_STMT (op);\n-  gcc_assert (stmt);\n-\n-  if (gimple_plf (stmt, NECESSARY)\n-      || gimple_nop_p (stmt))\n-    return NULL;\n-\n-  gimple_set_plf (stmt, NECESSARY, true);\n-  return stmt;\n-}\n-\n-/* Because we don't follow exactly the standard PRE algorithm, and decide not\n+   Because we don't follow exactly the standard PRE algorithm, and decide not\n    to insert PHI nodes sometimes, and because value numbering of casts isn't\n    perfect, we sometimes end up inserting dead code.   This simple DCE-like\n    pass removes any insertions we made that weren't actually used.  */\n \n static void\n remove_dead_inserted_code (void)\n {\n-  unsigned i;\n-  bitmap_iterator bi;\n-  gimple *t;\n-\n-  auto_bitmap worklist;\n-  EXECUTE_IF_SET_IN_BITMAP (inserted_exprs, 0, i, bi)\n+  /* ???  Re-use inserted_exprs as worklist not only as initial set.\n+     This may end up removing non-inserted code as well.  If we\n+     keep inserted_exprs unchanged we could restrict new worklist\n+     elements to members of inserted_exprs.  */\n+  bitmap worklist = inserted_exprs;\n+  while (! bitmap_empty_p (worklist))\n     {\n-      t = SSA_NAME_DEF_STMT (ssa_name (i));\n-      if (gimple_plf (t, NECESSARY))\n-\tbitmap_set_bit (worklist, i);\n-    }\n-  while (!bitmap_empty_p (worklist))\n-    {\n-      i = bitmap_first_set_bit (worklist);\n+      /* Pop item.  */\n+      unsigned i = bitmap_first_set_bit (worklist);\n       bitmap_clear_bit (worklist, i);\n-      t = SSA_NAME_DEF_STMT (ssa_name (i));\n-\n-      /* PHI nodes are somewhat special in that each PHI alternative has\n-\t data and control dependencies.  All the statements feeding the\n-\t PHI node's arguments are always necessary. */\n-      if (gimple_code (t) == GIMPLE_PHI)\n-\t{\n-\t  unsigned k;\n \n-\t  for (k = 0; k < gimple_phi_num_args (t); k++)\n-\t    {\n-\t      tree arg = PHI_ARG_DEF (t, k);\n-\t      if (TREE_CODE (arg) == SSA_NAME)\n-\t\t{\n-\t\t  gimple *n = mark_operand_necessary (arg);\n-\t\t  if (n)\n-\t\t    bitmap_set_bit (worklist, SSA_NAME_VERSION (arg));\n-\t\t}\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* Propagate through the operands.  Examine all the USE, VUSE and\n-\t     VDEF operands in this statement.  Mark all the statements\n-\t     which feed this statement's uses as necessary.  */\n-\t  ssa_op_iter iter;\n-\t  tree use;\n+      tree def = ssa_name (i);\n+      /* Removed by somebody else or still in use.  */\n+      if (! def || ! has_zero_uses (def))\n+\tcontinue;\n \n-\t  /* The operands of VDEF expressions are also needed as they\n-\t     represent potential definitions that may reach this\n-\t     statement (VDEF operands allow us to follow def-def\n-\t     links).  */\n+      gimple *t = SSA_NAME_DEF_STMT (def);\n \n-\t  FOR_EACH_SSA_TREE_OPERAND (use, t, iter, SSA_OP_ALL_USES)\n-\t    {\n-\t      gimple *n = mark_operand_necessary (use);\n-\t      if (n)\n-\t\tbitmap_set_bit (worklist, SSA_NAME_VERSION (use));\n-\t    }\n+      /* Add uses to the worklist.  */\n+      ssa_op_iter iter;\n+      use_operand_p use_p;\n+      FOR_EACH_PHI_OR_STMT_USE (use_p, t, iter, SSA_OP_USE)\n+\t{\n+\t  tree use = USE_FROM_PTR (use_p);\n+\t  if (TREE_CODE (use) == SSA_NAME\n+\t      && ! SSA_NAME_IS_DEFAULT_DEF (use))\n+\t    bitmap_set_bit (worklist, SSA_NAME_VERSION (use));\n \t}\n-    }\n \n-  unsigned int to_clear = -1U;\n-  EXECUTE_IF_SET_IN_BITMAP (inserted_exprs, 0, i, bi)\n-    {\n-      if (to_clear != -1U)\n+      /* Remove stmt.  */\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n-\t  bitmap_clear_bit (inserted_exprs, to_clear);\n-\t  to_clear = -1U;\n+\t  fprintf (dump_file, \"Removing unnecessary insertion:\");\n+\t  print_gimple_stmt (dump_file, t, 0);\n \t}\n-      t = SSA_NAME_DEF_STMT (ssa_name (i));\n-      if (!gimple_plf (t, NECESSARY))\n+      gimple_stmt_iterator gsi = gsi_for_stmt (t);\n+      if (gimple_code (t) == GIMPLE_PHI)\n+\tremove_phi_node (&gsi, true);\n+      else\n \t{\n-\t  gimple_stmt_iterator gsi;\n-\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"Removing unnecessary insertion:\");\n-\t      print_gimple_stmt (dump_file, t, 0);\n-\t    }\n-\n-\t  gsi = gsi_for_stmt (t);\n-\t  if (gimple_code (t) == GIMPLE_PHI)\n-\t    remove_phi_node (&gsi, true);\n-\t  else\n-\t    {\n-\t      gsi_remove (&gsi, true);\n-\t      release_defs (t);\n-\t    }\n+\t  gsi_remove (&gsi, true);\n+\t  release_defs (t);\n \t}\n-      else\n-\t/* eliminate_fini will skip stmts marked for removal if we\n-\t   already removed it and uses inserted_exprs for this, so\n-\t   clear those we didn't end up removing.  */\n-\tto_clear = i;\n     }\n-  if (to_clear != -1U)\n-    bitmap_clear_bit (inserted_exprs, to_clear);\n }\n \n \n@@ -5196,10 +5080,10 @@ pass_pre::execute (function *fun)\n   statistics_counter_event (fun, \"Eliminated\", pre_stats.eliminations);\n \n   clear_expression_ids ();\n-  remove_dead_inserted_code ();\n \n   scev_finalize ();\n   todo |= fini_eliminate ();\n+  remove_dead_inserted_code ();\n   fini_pre ();\n   loop_optimizer_finalize ();\n "}]}