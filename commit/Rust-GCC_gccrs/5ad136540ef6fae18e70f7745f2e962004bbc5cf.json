{"sha": "5ad136540ef6fae18e70f7745f2e962004bbc5cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFkMTM2NTQwZWY2ZmFlMThlNzBmNzc0NWYyZTk2MjAwNGJiYzVjZg==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2004-02-05T16:34:30Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2004-02-05T16:34:30Z"}, "message": "Thread.java: Reordered fields...\n\n2004-02-05  Michael Koch  <konqueror@gmx.de>\n\n\t* java/lang/Thread.java: Reordered fields, reformated much code,\n\tno functional changes, some variables renamed, javadoc comments\n\tmerged.\n\nFrom-SVN: r77322", "tree": {"sha": "4ecb83ce613571dc95fbe5a9814c0a0b7df85579", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ecb83ce613571dc95fbe5a9814c0a0b7df85579"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ad136540ef6fae18e70f7745f2e962004bbc5cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ad136540ef6fae18e70f7745f2e962004bbc5cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ad136540ef6fae18e70f7745f2e962004bbc5cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ad136540ef6fae18e70f7745f2e962004bbc5cf/comments", "author": null, "committer": null, "parents": [{"sha": "6d0c7d7b6a48ecb2ae899f066d4bdd175f360a8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d0c7d7b6a48ecb2ae899f066d4bdd175f360a8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d0c7d7b6a48ecb2ae899f066d4bdd175f360a8a"}], "stats": {"total": 193, "additions": 107, "deletions": 86}, "files": [{"sha": "99ab504757caf71e9b9c596c1d0fcc2ef7b4ed55", "filename": "libjava/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad136540ef6fae18e70f7745f2e962004bbc5cf/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad136540ef6fae18e70f7745f2e962004bbc5cf/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=5ad136540ef6fae18e70f7745f2e962004bbc5cf", "patch": "@@ -1,3 +1,9 @@\n+2004-02-05  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/lang/Thread.java: Reordered fields, reformated much code,\n+\tno functional changes, some variables renamed, javadoc comments\n+\tmerged.\n+\n 2004-02-05  Michael Koch  <konqueror@gmx.de>\n \n \t* java/util/zip/Deflater.java,"}, {"sha": "46d74f180fd8ac3424453bfa1f8d66d5af95cfd0", "filename": "libjava/java/lang/Thread.java", "status": "modified", "additions": 101, "deletions": 86, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad136540ef6fae18e70f7745f2e962004bbc5cf/libjava%2Fjava%2Flang%2FThread.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad136540ef6fae18e70f7745f2e962004bbc5cf/libjava%2Fjava%2Flang%2FThread.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FThread.java?ref=5ad136540ef6fae18e70f7745f2e962004bbc5cf", "patch": "@@ -89,14 +89,42 @@\n  */\n public class Thread implements Runnable\n {\n-  /** The maximum priority for a Thread. */\n-  public final static int MAX_PRIORITY = 10;\n-\n   /** The minimum priority for a Thread. */\n-  public final static int MIN_PRIORITY = 1;\n+  public static final int MIN_PRIORITY = 1;\n \n   /** The priority a Thread gets by default. */\n-  public final static int NORM_PRIORITY = 5;\n+  public static final int NORM_PRIORITY = 5;\n+\n+  /** The maximum priority for a Thread. */\n+  public static final int MAX_PRIORITY = 10;\n+\n+  /**\n+   * The group this thread belongs to. This is set to null by\n+   * ThreadGroup.removeThread when the thread dies.\n+   */\n+  ThreadGroup group;\n+\n+  /** The thread name, non-null. */\n+  String name;\n+\n+  /** The object to run(), null if this is the target. */\n+  private Runnable runnable;\n+\n+  /** The thread priority, 1 to 10. */\n+  private int priority;\n+\n+  private boolean daemon_flag;\n+  boolean interrupt_flag;\n+  private boolean alive_flag;\n+  private boolean startable_flag;\n+  private ClassLoader context_class_loader;\n+\n+  // This describes the top-most interpreter frame for this thread.\n+  RawData interp_frame;\n+\n+  // Our native data - points to an instance of struct natThread.\n+  private Object data;\n+\n \n   /**\n    * Get the number of active threads in the current Thread's ThreadGroup.\n@@ -106,7 +134,7 @@ public class Thread implements Runnable\n    * @return the number of active threads in the current ThreadGroup\n    * @see ThreadGroup#activeCount()\n    */\n-  public static int activeCount ()\n+  public static int activeCount()\n   {\n     return currentThread().getThreadGroup().activeCount();\n   }\n@@ -118,11 +146,11 @@ public static int activeCount ()\n    * @throws SecurityException if the current Thread cannot modify this Thread\n    * @see SecurityManager#checkAccess(Thread)\n    */\n-  public final void checkAccess ()\n+  public final void checkAccess()\n   {\n-    SecurityManager s = System.getSecurityManager();\n-    if (s != null)\n-      s.checkAccess(this);\n+    SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      sm.checkAccess(this);\n   }\n \n   /**\n@@ -133,30 +161,30 @@ public final void checkAccess ()\n    * @throws IllegalThreadStateException if this Thread is not suspended\n    * @deprecated pointless, since suspend is deprecated\n    */\n-  public native int countStackFrames ();\n+  public native int countStackFrames();\n \n   /**\n    * Get the currently executing Thread.\n    *\n    * @return the currently executing Thread\n    */\n-  public static native Thread currentThread ();\n+  public static native Thread currentThread();\n \n   /**\n    * Originally intended to destroy this thread, this method was never\n    * implemented by Sun, and is hence a no-op.\n    */\n-  public native void destroy ();\n+  public native void destroy();\n   \n   /**\n    * Print a stack trace of the current thread to stderr using the same\n    * format as Throwable's printStackTrace() method.\n    *\n    * @see Throwable#printStackTrace()\n    */\n-  public static void dumpStack ()\n+  public static void dumpStack()\n   {\n-    (new Exception (\"Stack trace\")).printStackTrace ();\n+    (new Exception(\"Stack trace\")).printStackTrace();\n   }\n \n   /**\n@@ -173,17 +201,17 @@ public static void dumpStack ()\n    * @see #activeCount()\n    * @see SecurityManager#checkAccess(ThreadGroup)\n    */\n-  public static int enumerate (Thread[] threads)\n+  public static int enumerate(Thread[] array)\n   {\n-    return currentThread().group.enumerate(threads);\n+    return currentThread().group.enumerate(array);\n   }\n   \n   /**\n    * Get this Thread's name.\n    *\n    * @return this Thread's name\n    */\n-  public final String getName ()\n+  public final String getName()\n   {\n     return name;\n   }\n@@ -193,7 +221,7 @@ public final String getName ()\n    *\n    * @return the Thread's priority\n    */\n-  public final int getPriority ()\n+  public final int getPriority()\n   {\n     return priority;\n   }\n@@ -204,7 +232,7 @@ public final int getPriority ()\n    *\n    * @return this Thread's ThreadGroup\n    */\n-  public final ThreadGroup getThreadGroup ()\n+  public final ThreadGroup getThreadGroup()\n   {\n     return group;\n   }\n@@ -213,10 +241,11 @@ public final ThreadGroup getThreadGroup ()\n    * Return true if this Thread holds the object's lock, false otherwise.\n    *\n    * @param obj the object to test lock ownership on.\n+   * @return true if the current thread is currently synchronized on obj\n    * @throws NullPointerException if obj is null.\n    * @since 1.4\n    */\n-  public static native boolean holdsLock (Object obj);\n+  public static native boolean holdsLock(Object obj);\n \n   /**\n    * Interrupt this Thread. First, there is a security check,\n@@ -240,7 +269,7 @@ public final ThreadGroup getThreadGroup ()\n    *\n    * @throws SecurityException if you cannot modify this Thread\n    */\n-  public native void interrupt ();\n+  public native void interrupt();\n \n   /**\n    * Determine whether the current Thread has been interrupted, and clear\n@@ -249,19 +278,19 @@ public final ThreadGroup getThreadGroup ()\n    * @return whether the current Thread has been interrupted\n    * @see #isInterrupted()\n    */\n-  public static boolean interrupted ()\n+  public static boolean interrupted()\n   {\n-    return currentThread().isInterrupted (true);\n+    return currentThread().isInterrupted(true);\n   }\n \n   /**\n    * Determine whether the given Thread has been interrupted, but leave\n    * the <i>interrupted status</i> alone in the process.\n    *\n-   * @return whether the current Thread has been interrupted\n+   * @return whether the Thread has been interrupted\n    * @see #interrupted()\n    */\n-  public boolean isInterrupted ()\n+  public boolean isInterrupted()\n   {\n     return interrupt_flag;\n   }\n@@ -272,7 +301,7 @@ public boolean isInterrupted ()\n    *\n    * @return whether this Thread is alive\n    */\n-  public final boolean isAlive ()\n+  public final boolean isAlive()\n   {\n     return alive_flag;\n   }\n@@ -283,7 +312,7 @@ public final boolean isAlive ()\n    * @return whether this is a daemon Thread or not\n    * @see #setDaemon(boolean)\n    */\n-  public final boolean isDaemon ()\n+  public final boolean isDaemon()\n   {\n     return daemon_flag;\n   }\n@@ -294,9 +323,9 @@ public final boolean isDaemon ()\n    * @throws InterruptedException if the Thread is interrupted; it's\n    *         <i>interrupted status</i> will be cleared\n    */\n-  public final void join () throws InterruptedException\n+  public final void join() throws InterruptedException\n   {\n-    join (0, 0);\n+    join(0, 0);\n   }\n \n   /**\n@@ -306,9 +335,9 @@ public final void join () throws InterruptedException\n    * @throws InterruptedException if the Thread is interrupted; it's\n    *         <i>interrupted status</i> will be cleared\n    */\n-  public final void join (long timeout) throws InterruptedException\n+  public final void join(long ms) throws InterruptedException\n   {\n-    join (timeout, 0);\n+    join(ms, 0);\n   }\n \n   /**\n@@ -327,18 +356,20 @@ public final void join (long timeout) throws InterruptedException\n    * @throws IllegalArgumentException if ns is invalid\n    * @XXX A ThreadListener would be nice, to make this efficient.\n    */\n-  public final native void join (long timeout, int nanos)\n+  public final native void join(long ms, int ns)\n     throws InterruptedException;\n \n   /**\n    * Resume a suspended thread.\n    *\n-   * @see #resume()\n+   * @throws SecurityException if you cannot resume the Thread\n+   * @see #checkAccess()\n+   * @see #suspend()\n    * @deprecated pointless, since suspend is deprecated\n    */\n-  public final native void resume ();\n+  public final native void resume();\n \n-  private final native void finish_ ();\n+  private final native void finish_();\n \n   /**\n    * Determine whether the given Thread has been interrupted, but leave\n@@ -347,7 +378,7 @@ public final native void join (long timeout, int nanos)\n    * @return whether the current Thread has been interrupted\n    * @see #interrupted()\n    */\n-  private boolean isInterrupted (boolean clear_flag)\n+  private boolean isInterrupted(boolean clear_flag)\n   {\n     boolean r = interrupt_flag;\n     if (clear_flag && r)\n@@ -367,7 +398,7 @@ private boolean isInterrupted (boolean clear_flag)\n    * @see #start()\n    * @see #Thread(ThreadGroup, Runnable, String)\n    */\n-  public void run ()\n+  public void run()\n   {\n     if (runnable != null)\n       runnable.run();\n@@ -385,11 +416,11 @@ public void run ()\n    * @see #isDaemon()\n    * @see #checkAccess()\n    */\n-  public final void setDaemon (boolean status)\n+  public final void setDaemon(boolean status)\n   {\n-    checkAccess ();\n+    checkAccess();\n     if (!startable_flag)\n-      throw new IllegalThreadStateException ();\n+      throw new IllegalThreadStateException();\n     daemon_flag = status;\n   }\n \n@@ -410,24 +441,24 @@ public final void setDaemon (boolean status)\n   public synchronized ClassLoader getContextClassLoader()\n   {\n     if (context_class_loader == null)\n-      context_class_loader = ClassLoader.getSystemClassLoader ();\n+      context_class_loader = ClassLoader.getSystemClassLoader();\n \n-    SecurityManager s = System.getSecurityManager();\n+    SecurityManager sm = System.getSecurityManager();\n     // FIXME: we can't currently find the caller's class loader.\n     ClassLoader callers = null;\n-    if (s != null && callers != null)\n+    if (sm != null && callers != null)\n       {\n \t// See if the caller's class loader is the same as or an\n \t// ancestor of this thread's class loader.\n \twhile (callers != null && callers != context_class_loader)\n \t  {\n \t    // FIXME: should use some internal version of getParent\n \t    // that avoids security checks.\n-\t    callers = callers.getParent ();\n+\t    callers = callers.getParent();\n \t  }\n \n \tif (callers != context_class_loader)\n-\t  s.checkPermission (new RuntimePermission (\"getClassLoader\"));\n+\t  sm.checkPermission(new RuntimePermission(\"getClassLoader\"));\n       }\n \n     return context_class_loader;\n@@ -442,17 +473,17 @@ public synchronized ClassLoader getContextClassLoader()\n    * class loader is not null or an ancestor of this thread's context class\n    * loader.\n    *\n-   * @return the context class loader\n+   * @param classloader the new context class loader\n    * @throws SecurityException when permission is denied\n-   * @see setContextClassLoader(ClassLoader)\n+   * @see getContextClassLoader()\n    * @since 1.2\n    */\n-  public synchronized void setContextClassLoader(ClassLoader cl)\n+  public synchronized void setContextClassLoader(ClassLoader classloader)\n   {\n-    SecurityManager s = System.getSecurityManager ();\n-    if (s != null)\n-      s.checkPermission (new RuntimePermission (\"setContextClassLoader\"));\n-    context_class_loader = cl;\n+    SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      sm.checkPermission(new RuntimePermission(\"setContextClassLoader\"));\n+    context_class_loader = classloader;\n   }\n \n   /**\n@@ -463,14 +494,14 @@ public synchronized void setContextClassLoader(ClassLoader cl)\n    * @throws NullPointerException if name is null\n    * @throws SecurityException if you cannot modify this Thread\n    */\n-  public final void setName (String n)\n+  public final void setName(String name)\n   {\n-    checkAccess ();\n+    checkAccess();\n     // The Class Libraries book says ``threadName cannot be null''.  I\n     // take this to mean NullPointerException.\n-    if (n == null)\n-      throw new NullPointerException ();\n-    name = n;\n+    if (name == null)\n+      throw new NullPointerException();\n+    this.name = name;\n   }\n \n   /**\n@@ -502,9 +533,9 @@ public final void setName (String n)\n    * @see #notify()\n    * @see #wait(long)\n    */\n-  public static void sleep (long timeout) throws InterruptedException\n+  public static void sleep(long ms) throws InterruptedException\n   {\n-    sleep (timeout, 0);\n+    sleep(ms, 0);\n   }\n \n   /**\n@@ -527,7 +558,7 @@ public static void sleep (long timeout) throws InterruptedException\n    * @see #notify()\n    * @see #wait(long, int)\n    */\n-  public static native void sleep (long timeout, int nanos)\n+  public static native void sleep(long timeout, int nanos)\n     throws InterruptedException;\n \n   /**\n@@ -540,7 +571,7 @@ public static native void sleep (long timeout, int nanos)\n    * @throws IllegalThreadStateException if the thread has already started\n    * @see #run()\n    */\n-  public native void start ();\n+  public native void start();\n \n   /**\n    * Cause this Thread to stop abnormally because of the throw of a ThreadDeath\n@@ -565,11 +596,11 @@ public static native void sleep (long timeout, int nanos)\n    * @see SecurityManager#checkPermission(Permission)\n    * @deprecated unsafe operation, try not to use\n    */\n-  public final void stop ()\n+  public final void stop()\n   {\n     // Argument doesn't matter, because this is no longer\n     // supported.\n-    stop (null);\n+    stop(null);\n   }\n \n   /**\n@@ -599,7 +630,7 @@ public final void stop ()\n    * @see SecurityManager#checkPermission(Permission)\n    * @deprecated unsafe operation, try not to use\n    */\n-  public final native void stop (Throwable e);\n+  public final native void stop(Throwable e);\n \n   /**\n    * Suspend this Thread.  It will not come back, ever, unless it is resumed.\n@@ -613,7 +644,7 @@ public final void stop ()\n    * @see #resume()\n    * @deprecated unsafe operation, try not to use\n    */\n-  public final native void suspend ();\n+  public final native void suspend();\n \n   private final native void initialize_native ();\n \n@@ -861,12 +892,12 @@ public Thread (Runnable r, String n)\n    * Returns a string representation of this thread, including the\n    * thread's name, priority, and thread group.\n    *\n-   * @return  a string representation of this thread.\n+   * @return a human-readable String representing this Thread\n    */\n-  public String toString ()\n+  public String toString()\n   {\n-    return \"Thread[\" + name + \",\" + priority + \",\" + \n-      (group == null ? \"\" : group.getName()) + \"]\";\n+    return (\"Thread[\" + name + \",\" + priority + \",\"\n+\t    + (group == null ? \"\" : group.getName()) + \"]\");\n   }\n \n   /**\n@@ -875,20 +906,4 @@ public String toString ()\n    */\n   public static native void yield ();\n \n-  // Private data.\n-  ThreadGroup group;\n-  String name;\n-  private Runnable runnable;\n-  private int priority;\n-  private boolean daemon_flag;\n-  boolean interrupt_flag;\n-  private boolean alive_flag;\n-  private boolean startable_flag;\n-  private ClassLoader context_class_loader;\n-\n-  // This describes the top-most interpreter frame for this thread.\n-  RawData interp_frame;\n-\n-  // Our native data - points to an instance of struct natThread.\n-  private Object data;\n }"}]}