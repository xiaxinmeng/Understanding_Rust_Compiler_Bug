{"sha": "92d417175b9f7b41d5ebe3ceb723f808917ed964", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTJkNDE3MTc1YjlmN2I0MWQ1ZWJlM2NlYjcyM2Y4MDg5MTdlZDk2NA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2019-06-10T07:38:59Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-06-10T07:38:59Z"}, "message": "Implement N disk counters for single value and indirect call counters.\n\n2019-06-10  Martin Liska  <mliska@suse.cz>\n\n\t* gcov-io.h (GCOV_DISK_SINGLE_VALUES): New.\n\t(GCOV_SINGLE_VALUE_COUNTERS): Likewise.\n\t* ipa-profile.c (ipa_profile_generate_summary):\n\tUse get_most_common_single_value.\n\t* tree-profile.c (gimple_init_gcov_profiler):\n\tInstrument with __gcov_one_value_profiler_v2\n\tand __gcov_indirect_call_profiler_v4.\n\t* value-prof.c (dump_histogram_value):\n\tPrint all values for HIST_TYPE_SINGLE_VALUE.\n\t(stream_out_histogram_value): Update assert for\n\tN values.\n\t(stream_in_histogram_value): Set number of\n\tcounters for HIST_TYPE_SINGLE_VALUE.\n\t(get_most_common_single_value): New.\n\t(gimple_divmod_fixed_value_transform):\n\tUse get_most_common_single_value.\n\t(gimple_ic_transform): Likewise.\n\t(gimple_stringops_transform): Likewise.\n\t(gimple_find_values_to_profile): Set number\n\tof counters for HIST_TYPE_SINGLE_VALUE.\n\t* value-prof.h (get_most_common_single_value):\n\tNew.\n2019-06-10  Martin Liska  <mliska@suse.cz>\n\n\t* Makefile.in: Add __gcov_one_value_profiler_v2,\n\t__gcov_one_value_profiler_v2_atomic and\n\t__gcov_indirect_call_profiler_v4.\n\t* libgcov-merge.c (__gcov_merge_single): Change\n\tfunction signature.\n\t(merge_single_value_set): New.\n\t* libgcov-profiler.c (__gcov_one_value_profiler_body):\n\tUpdate functionality.\n\t(__gcov_one_value_profiler): Remove.\n\t(__gcov_one_value_profiler_v2): ... this.\n\t(__gcov_one_value_profiler_atomic): Rename to ...\n\t(__gcov_one_value_profiler_v2_atomic): this.\n\t(__gcov_indirect_call_profiler_v3): Rename to ...\n\t(__gcov_indirect_call_profiler_v4): ... this.\n\t* libgcov.h (__gcov_one_value_profiler): Remove.\n\t(__gcov_one_value_profiler_atomic): Remove.\n\t(__gcov_one_value_profiler_v2_atomic): New.\n\t(__gcov_indirect_call_profiler_v3): Remove.\n\t(__gcov_one_value_profiler_v2): New.\n\t(__gcov_indirect_call_profiler_v4): New.\n\t(gcov_get_counter_ignore_scaling): New function.\n\nFrom-SVN: r272106", "tree": {"sha": "68db0aeb3fb07bf5bb068e205d5a3cb895a45a01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68db0aeb3fb07bf5bb068e205d5a3cb895a45a01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92d417175b9f7b41d5ebe3ceb723f808917ed964", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92d417175b9f7b41d5ebe3ceb723f808917ed964", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92d417175b9f7b41d5ebe3ceb723f808917ed964", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92d417175b9f7b41d5ebe3ceb723f808917ed964/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b076a52602320955ca7f4b8b54a5451f9f3c7658", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b076a52602320955ca7f4b8b54a5451f9f3c7658", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b076a52602320955ca7f4b8b54a5451f9f3c7658"}], "stats": {"total": 365, "additions": 249, "deletions": 116}, "files": [{"sha": "9f1a365ed2ed9c506e47c95fde1824004a261176", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d417175b9f7b41d5ebe3ceb723f808917ed964/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d417175b9f7b41d5ebe3ceb723f808917ed964/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=92d417175b9f7b41d5ebe3ceb723f808917ed964", "patch": "@@ -1,3 +1,28 @@\n+2019-06-10  Martin Liska  <mliska@suse.cz>\n+\n+\t* gcov-io.h (GCOV_DISK_SINGLE_VALUES): New.\n+\t(GCOV_SINGLE_VALUE_COUNTERS): Likewise.\n+\t* ipa-profile.c (ipa_profile_generate_summary):\n+\tUse get_most_common_single_value.\n+\t* tree-profile.c (gimple_init_gcov_profiler):\n+\tInstrument with __gcov_one_value_profiler_v2\n+\tand __gcov_indirect_call_profiler_v4.\n+\t* value-prof.c (dump_histogram_value):\n+\tPrint all values for HIST_TYPE_SINGLE_VALUE.\n+\t(stream_out_histogram_value): Update assert for\n+\tN values.\n+\t(stream_in_histogram_value): Set number of\n+\tcounters for HIST_TYPE_SINGLE_VALUE.\n+\t(get_most_common_single_value): New.\n+\t(gimple_divmod_fixed_value_transform):\n+\tUse get_most_common_single_value.\n+\t(gimple_ic_transform): Likewise.\n+\t(gimple_stringops_transform): Likewise.\n+\t(gimple_find_values_to_profile): Set number\n+\tof counters for HIST_TYPE_SINGLE_VALUE.\n+\t* value-prof.h (get_most_common_single_value):\n+\tNew.\n+\n 2019-06-10  Martin Liska  <mliska@suse.cz>\n \n \t* hash-map.h: Pass default value to hash_table ctor."}, {"sha": "0f2905c17ec1bc1472e44b7c02a0dc46b32c66c4", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d417175b9f7b41d5ebe3ceb723f808917ed964/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d417175b9f7b41d5ebe3ceb723f808917ed964/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=92d417175b9f7b41d5ebe3ceb723f808917ed964", "patch": "@@ -266,6 +266,13 @@ GCOV_COUNTERS\n #define GCOV_N_VALUE_COUNTERS \\\n   (GCOV_LAST_VALUE_COUNTER - GCOV_FIRST_VALUE_COUNTER + 1)\n \n+/* Number of single value histogram values that live\n+   on disk representation.  */\n+#define GCOV_DISK_SINGLE_VALUES 4\n+\n+/* Total number of single value counters.  */\n+#define GCOV_SINGLE_VALUE_COUNTERS (2 * GCOV_DISK_SINGLE_VALUES + 1)\n+\n /* Convert a counter index to a tag.  */\n #define GCOV_TAG_FOR_COUNTER(COUNT)\t\t\t\t\\\n \t(GCOV_TAG_COUNTER_BASE + ((gcov_unsigned_t)(COUNT) << 17))"}, {"sha": "c80ea7a9b954ad6eb86684b9d1a207beef540f73", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d417175b9f7b41d5ebe3ceb723f808917ed964/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d417175b9f7b41d5ebe3ceb723f808917ed964/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=92d417175b9f7b41d5ebe3ceb723f808917ed964", "patch": "@@ -191,17 +191,17 @@ ipa_profile_generate_summary (void)\n \t\t     takes away bad histograms.  */\n \t\t  if (h)\n \t\t    {\n-\t\t      /* counter 0 is target, counter 1 is number of execution we called target,\n-\t\t\t counter 2 is total number of executions.  */\n-\t\t      if (h->hvalue.counters[2])\n+\t\t      gcov_type val, count, all;\n+\t\t      if (get_most_common_single_value (NULL, \"indirect call\",\n+\t\t\t\t\t\t\th, &val, &count, &all))\n \t\t\t{\n \t\t\t  struct cgraph_edge * e = node->get_edge (stmt);\n \t\t\t  if (e && !e->indirect_unknown_callee)\n \t\t\t    continue;\n-\t\t\t  e->indirect_info->common_target_id\n-\t\t\t    = h->hvalue.counters [0];\n+\n+\t\t\t  e->indirect_info->common_target_id = val;\n \t\t\t  e->indirect_info->common_target_probability\n-\t\t\t    = GCOV_COMPUTE_SCALE (h->hvalue.counters [1], h->hvalue.counters [2]);\n+\t\t\t    = GCOV_COMPUTE_SCALE (count, all);\n \t\t\t  if (e->indirect_info->common_target_probability > REG_BR_PROB_BASE)\n \t\t\t    {\n \t\t\t      if (dump_file)"}, {"sha": "5ca4c3e80b66c829a11e48743664459b8c4b0b9b", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d417175b9f7b41d5ebe3ceb723f808917ed964/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d417175b9f7b41d5ebe3ceb723f808917ed964/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=92d417175b9f7b41d5ebe3ceb723f808917ed964", "patch": "@@ -165,10 +165,10 @@ gimple_init_gcov_profiler (void)\n \t      = build_function_type_list (void_type_node,\n \t\t\t\t\t  gcov_type_ptr, gcov_type_node,\n \t\t\t\t\t  NULL_TREE);\n-      fn_name = concat (\"__gcov_one_value_profiler\", fn_suffix, NULL);\n+      fn_name = concat (\"__gcov_one_value_profiler_v2\", fn_suffix, NULL);\n       tree_one_value_profiler_fn = build_fn_decl (fn_name,\n \t\t\t\t\t\t  one_value_profiler_fn_type);\n-      free (CONST_CAST (char *, fn_name));\n+\n       TREE_NOTHROW (tree_one_value_profiler_fn) = 1;\n       DECL_ATTRIBUTES (tree_one_value_profiler_fn)\n \t= tree_cons (get_identifier (\"leaf\"), NULL,\n@@ -182,7 +182,7 @@ gimple_init_gcov_profiler (void)\n \t\t\t\t\t  gcov_type_node,\n \t\t\t\t\t  ptr_type_node,\n \t\t\t\t\t  NULL_TREE);\n-      profiler_fn_name = \"__gcov_indirect_call_profiler_v3\";\n+      profiler_fn_name = \"__gcov_indirect_call_profiler_v4\";\n \n       tree_indirect_call_profiler_fn\n \t      = build_fn_decl (profiler_fn_name, ic_profiler_fn_type);"}, {"sha": "b95bf85270bbbd0b57ef4045fd5f7d1b448bed6d", "filename": "gcc/value-prof.c", "status": "modified", "additions": 78, "deletions": 58, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d417175b9f7b41d5ebe3ceb723f808917ed964/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d417175b9f7b41d5ebe3ceb723f808917ed964/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=92d417175b9f7b41d5ebe3ceb723f808917ed964", "patch": "@@ -259,15 +259,22 @@ dump_histogram_value (FILE *dump_file, histogram_value hist)\n       break;\n \n     case HIST_TYPE_SINGLE_VALUE:\n-      fprintf (dump_file, \"Single value \");\n+    case HIST_TYPE_INDIR_CALL:\n+      fprintf (dump_file,\n+\t       (hist->type == HIST_TYPE_SINGLE_VALUE\n+\t\t? \"Single value counter \" : \"Indirect call counter\"));\n       if (hist->hvalue.counters)\n \t{\n-\t   fprintf (dump_file, \"value:%\" PRId64\n-\t\t    \" match:%\" PRId64\n-\t\t    \" wrong:%\" PRId64,\n-\t\t    (int64_t) hist->hvalue.counters[0],\n-\t\t    (int64_t) hist->hvalue.counters[1],\n-\t\t    (int64_t) hist->hvalue.counters[2]);\n+\t  fprintf (dump_file, \"all: %\" PRId64 \", values: \",\n+\t\t   (int64_t) hist->hvalue.counters[0]);\n+\t  for (unsigned i = 0; i < GCOV_DISK_SINGLE_VALUES; i++)\n+\t    {\n+\t      fprintf (dump_file, \"[%\" PRId64 \":%\" PRId64 \"]\",\n+\t\t       (int64_t) hist->hvalue.counters[2 * i + 1],\n+\t\t       (int64_t) hist->hvalue.counters[2 * i + 2]);\n+\t      if (i != GCOV_DISK_SINGLE_VALUES - 1)\n+\t\tfprintf (dump_file, \", \");\n+\t    }\n \t}\n       fprintf (dump_file, \".\\n\");\n       break;\n@@ -294,19 +301,6 @@ dump_histogram_value (FILE *dump_file, histogram_value hist)\n       fprintf (dump_file, \".\\n\");\n       break;\n \n-    case HIST_TYPE_INDIR_CALL:\n-      fprintf (dump_file, \"Indirect call \");\n-      if (hist->hvalue.counters)\n-\t{\n-\t   fprintf (dump_file, \"value:%\" PRId64\n-\t\t    \" match:%\" PRId64\n-\t\t    \" all:%\" PRId64,\n-\t\t    (int64_t) hist->hvalue.counters[0],\n-\t\t    (int64_t) hist->hvalue.counters[1],\n-\t\t    (int64_t) hist->hvalue.counters[2]);\n-\t}\n-      fprintf (dump_file, \".\\n\");\n-      break;\n     case HIST_TYPE_TIME_PROFILE:\n       fprintf (dump_file, \"Time profile \");\n       if (hist->hvalue.counters)\n@@ -347,7 +341,7 @@ stream_out_histogram_value (struct output_block *ob, histogram_value hist)\n       /* When user uses an unsigned type with a big value, constant converted\n \t to gcov_type (a signed type) can be negative.  */\n       gcov_type value = hist->hvalue.counters[i];\n-      if (hist->type == HIST_TYPE_SINGLE_VALUE && i == 0)\n+      if (hist->type == HIST_TYPE_SINGLE_VALUE && (i > 0 && ((i - 1) % 2) == 0))\n \t;\n       else\n \tgcc_assert (value >= 0);\n@@ -392,7 +386,7 @@ stream_in_histogram_value (struct lto_input_block *ib, gimple *stmt)\n \n \tcase HIST_TYPE_SINGLE_VALUE:\n \tcase HIST_TYPE_INDIR_CALL:\n-\t  ncounters = 3;\n+\t  ncounters = GCOV_SINGLE_VALUE_COUNTERS;\n \t  break;\n \n \tcase HIST_TYPE_IOR:\n@@ -729,6 +723,48 @@ gimple_divmod_fixed_value (gassign *stmt, tree value, profile_probability prob,\n   return tmp2;\n }\n \n+/* Return most common value of SINGLE_VALUE histogram.  If\n+   there's a unique value, return true and set VALUE and COUNT\n+   arguments.  */\n+\n+bool\n+get_most_common_single_value (gimple *stmt, const char *counter_type,\n+\t\t\t      histogram_value hist,\n+\t\t\t      gcov_type *value, gcov_type *count,\n+\t\t\t      gcov_type *all)\n+{\n+  if (hist->hvalue.counters[2] == -1)\n+    return false;\n+\n+  *count = 0;\n+  *value = 0;\n+\n+  gcov_type read_all = hist->hvalue.counters[0];\n+\n+  for (unsigned i = 0; i < GCOV_DISK_SINGLE_VALUES; i++)\n+    {\n+      gcov_type v = hist->hvalue.counters[2 * i + 1];\n+      gcov_type c = hist->hvalue.counters[2 * i + 2];\n+\n+      /* Indirect calls can't be vereified.  */\n+      if (stmt && check_counter (stmt, counter_type, &c, &read_all,\n+\t\t\t\t gimple_bb (stmt)->count))\n+\treturn false;\n+\n+      *all = read_all;\n+\n+      if (c > *count)\n+\t{\n+\t  *value = v;\n+\t  *count = c;\n+\t}\n+      else if (c == *count && v > *value)\n+\t*value = v;\n+    }\n+\n+  return true;\n+}\n+\n /* Do transform 1) on INSN if applicable.  */\n \n static bool\n@@ -758,23 +794,19 @@ gimple_divmod_fixed_value_transform (gimple_stmt_iterator *si)\n   if (!histogram)\n     return false;\n \n+  if (!get_most_common_single_value (stmt, \"divmod\", histogram, &val, &count,\n+\t\t\t\t     &all))\n+    return false;\n+\n   value = histogram->hvalue.value;\n-  val = histogram->hvalue.counters[0];\n-  count = histogram->hvalue.counters[1];\n-  all = histogram->hvalue.counters[2];\n   gimple_remove_histogram_value (cfun, stmt, histogram);\n \n-  /* We require that count is at least half of all; this means\n-     that for the transformation to fire the value must be constant\n-     at least 50% of time (and 75% gives the guarantee of usage).  */\n+  /* We require that count is at least half of all.  */\n   if (simple_cst_equal (gimple_assign_rhs2 (stmt), value) != 1\n       || 2 * count < all\n       || optimize_bb_for_size_p (gimple_bb (stmt)))\n     return false;\n \n-  if (check_counter (stmt, \"value\", &count, &all, gimple_bb (stmt)->count))\n-    return false;\n-\n   /* Compute probability of taking the optimal path.  */\n   if (all > 0)\n     prob = profile_probability::probability_in_gcov_type (count, all);\n@@ -1401,7 +1433,7 @@ gimple_ic_transform (gimple_stmt_iterator *gsi)\n {\n   gcall *stmt;\n   histogram_value histogram;\n-  gcov_type val, count, all, bb_all;\n+  gcov_type val, count, all;\n   struct cgraph_node *direct_call;\n \n   stmt = dyn_cast <gcall *> (gsi_stmt (*gsi));\n@@ -1418,21 +1450,9 @@ gimple_ic_transform (gimple_stmt_iterator *gsi)\n   if (!histogram)\n     return false;\n \n-  val = histogram->hvalue.counters [0];\n-  count = histogram->hvalue.counters [1];\n-  all = histogram->hvalue.counters [2];\n-\n-  bb_all = gimple_bb (stmt)->count.ipa ().to_gcov_type ();\n-  /* The order of CHECK_COUNTER calls is important -\n-     since check_counter can correct the third parameter\n-     and we want to make count <= all <= bb_all. */\n-  if (check_counter (stmt, \"ic\", &all, &bb_all, gimple_bb (stmt)->count)\n-      || check_counter (stmt, \"ic\", &count, &all,\n-\t\t        profile_count::from_gcov_type (all)))\n-    {\n-      gimple_remove_histogram_value (cfun, stmt, histogram);\n-      return false;\n-    }\n+  if (!get_most_common_single_value (NULL, \"indirect call\", histogram, &val,\n+\t\t\t\t     &count, &all))\n+    return false;\n \n   if (4 * count <= 3 * all)\n     return false;\n@@ -1644,19 +1664,19 @@ gimple_stringops_transform (gimple_stmt_iterator *gsi)\n   if (TREE_CODE (blck_size) == INTEGER_CST)\n     return false;\n \n-  histogram = gimple_histogram_value_of_type (cfun, stmt, HIST_TYPE_SINGLE_VALUE);\n+  histogram = gimple_histogram_value_of_type (cfun, stmt,\n+\t\t\t\t\t      HIST_TYPE_SINGLE_VALUE);\n   if (!histogram)\n     return false;\n \n-  val = histogram->hvalue.counters[0];\n-  count = histogram->hvalue.counters[1];\n-  all = histogram->hvalue.counters[2];\n+  if (!get_most_common_single_value (stmt, \"stringops\", histogram, &val,\n+\t\t\t\t     &count, &all))\n+    return false;\n+\n   gimple_remove_histogram_value (cfun, stmt, histogram);\n \n-  /* We require that count is at least half of all; this means\n-     that for the transformation to fire the value must be constant\n-     at least 80% of time.  */\n-  if ((6 * count / 5) < all || optimize_bb_for_size_p (gimple_bb (stmt)))\n+  /* We require that count is at least half of all.  */\n+  if (2 * count < all || optimize_bb_for_size_p (gimple_bb (stmt)))\n     return false;\n   if (check_counter (stmt, \"value\", &count, &all, gimple_bb (stmt)->count))\n     return false;\n@@ -1928,11 +1948,11 @@ gimple_find_values_to_profile (histogram_values *values)\n \t  break;\n \n \tcase HIST_TYPE_SINGLE_VALUE:\n-\t  hist->n_counters = 3;\n+\t  hist->n_counters = GCOV_SINGLE_VALUE_COUNTERS;\n \t  break;\n \n- \tcase HIST_TYPE_INDIR_CALL:\n- \t  hist->n_counters = 3;\n+\tcase HIST_TYPE_INDIR_CALL:\n+\t  hist->n_counters = GCOV_SINGLE_VALUE_COUNTERS;\n \t  break;\n \n         case HIST_TYPE_TIME_PROFILE:"}, {"sha": "25b03f7591ad2eb7d214b86064389338738de01d", "filename": "gcc/value-prof.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d417175b9f7b41d5ebe3ceb723f808917ed964/gcc%2Fvalue-prof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d417175b9f7b41d5ebe3ceb723f808917ed964/gcc%2Fvalue-prof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.h?ref=92d417175b9f7b41d5ebe3ceb723f808917ed964", "patch": "@@ -90,6 +90,10 @@ void free_histograms (function *);\n void stringop_block_profile (gimple *, unsigned int *, HOST_WIDE_INT *);\n gcall *gimple_ic (gcall *, struct cgraph_node *, profile_probability);\n bool check_ic_target (gcall *, struct cgraph_node *);\n+bool get_most_common_single_value (gimple *stmt, const char *counter_type,\n+\t\t\t\t   histogram_value hist,\n+\t\t\t\t   gcov_type *value, gcov_type *count,\n+\t\t\t\t   gcov_type *all);\n \n \n /* In tree-profile.c.  */"}, {"sha": "669041e505f5c7ef3bc0f9d79668744f616a0bd4", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d417175b9f7b41d5ebe3ceb723f808917ed964/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d417175b9f7b41d5ebe3ceb723f808917ed964/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=92d417175b9f7b41d5ebe3ceb723f808917ed964", "patch": "@@ -1,3 +1,27 @@\n+2019-06-10  Martin Liska  <mliska@suse.cz>\n+\n+\t* Makefile.in: Add __gcov_one_value_profiler_v2,\n+\t__gcov_one_value_profiler_v2_atomic and\n+\t__gcov_indirect_call_profiler_v4.\n+\t* libgcov-merge.c (__gcov_merge_single): Change\n+\tfunction signature.\n+\t(merge_single_value_set): New.\n+\t* libgcov-profiler.c (__gcov_one_value_profiler_body):\n+\tUpdate functionality.\n+\t(__gcov_one_value_profiler): Remove.\n+\t(__gcov_one_value_profiler_v2): ... this.\n+\t(__gcov_one_value_profiler_atomic): Rename to ...\n+\t(__gcov_one_value_profiler_v2_atomic): this.\n+\t(__gcov_indirect_call_profiler_v3): Rename to ...\n+\t(__gcov_indirect_call_profiler_v4): ... this.\n+\t* libgcov.h (__gcov_one_value_profiler): Remove.\n+\t(__gcov_one_value_profiler_atomic): Remove.\n+\t(__gcov_one_value_profiler_v2_atomic): New.\n+\t(__gcov_indirect_call_profiler_v3): Remove.\n+\t(__gcov_one_value_profiler_v2): New.\n+\t(__gcov_indirect_call_profiler_v4): New.\n+\t(gcov_get_counter_ignore_scaling): New function.\n+\n 2019-06-07  Martin Liska  <mliska@suse.cz>\n \n \t* Makefile.in: Remove usage of"}, {"sha": "33b83809cfc001440a8867a90da48f37b453d08c", "filename": "libgcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d417175b9f7b41d5ebe3ceb723f808917ed964/libgcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d417175b9f7b41d5ebe3ceb723f808917ed964/libgcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FMakefile.in?ref=92d417175b9f7b41d5ebe3ceb723f808917ed964", "patch": "@@ -893,13 +893,13 @@ LIBGCOV_PROFILER = _gcov_interval_profiler\t\t\t\t\\\n \t_gcov_interval_profiler_atomic\t\t\t\t\t\\\n \t_gcov_pow2_profiler\t\t\t\t\t\t\\\n \t_gcov_pow2_profiler_atomic\t\t\t\t\t\\\n-\t_gcov_one_value_profiler\t\t\t\t\t\\\n-\t_gcov_one_value_profiler_atomic\t\t\t\t\t\\\n+\t_gcov_one_value_profiler_v2\t\t\t\t\t\\\n+\t_gcov_one_value_profiler_v2_atomic\t\t\t\t\t\\\n \t_gcov_average_profiler\t\t\t\t\t\t\\\n \t_gcov_average_profiler_atomic\t\t\t\t\t\\\n \t_gcov_ior_profiler\t\t\t\t\t\t\\\n \t_gcov_ior_profiler_atomic\t\t\t\t\t\\\n-\t_gcov_indirect_call_profiler_v3\t\t\t\t\t\\\n+\t_gcov_indirect_call_profiler_v4\t\t\t\t\t\\\n \t_gcov_time_profiler\n LIBGCOV_INTERFACE = _gcov_dump _gcov_flush _gcov_fork\t\t\t\\\n \t_gcov_execl _gcov_execlp\t\t\t\t\t\\"}, {"sha": "42416341b4d971fd60015673c1f9556765e4590f", "filename": "libgcc/libgcov-merge.c", "status": "modified", "additions": 58, "deletions": 25, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d417175b9f7b41d5ebe3ceb723f808917ed964/libgcc%2Flibgcov-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d417175b9f7b41d5ebe3ceb723f808917ed964/libgcc%2Flibgcov-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-merge.c?ref=92d417175b9f7b41d5ebe3ceb723f808917ed964", "patch": "@@ -34,8 +34,9 @@ void __gcov_merge_add (gcov_type *counters  __attribute__ ((unused)),\n #endif\n \n #ifdef L_gcov_merge_single\n-void __gcov_merge_single (gcov_type *counters  __attribute__ ((unused)),\n-                          unsigned n_counters __attribute__ ((unused))) {}\n+void __gcov_merge_single (gcov_type *counters  __attribute__ ((unused)))\n+{\n+}\n #endif\n \n #else\n@@ -85,40 +86,72 @@ __gcov_merge_time_profile (gcov_type *counters, unsigned n_counters)\n #endif /* L_gcov_merge_time_profile */\n \n #ifdef L_gcov_merge_single\n+\n+static void\n+merge_single_value_set (gcov_type *counters)\n+{\n+  unsigned j;\n+  gcov_type value, counter;\n+\n+  /* First value is number of total executions of the profiler.  */\n+  gcov_type all = gcov_get_counter_ignore_scaling (-1);\n+  counters[0] += all;\n+  ++counters;\n+\n+  for (unsigned i = 0; i < GCOV_DISK_SINGLE_VALUES; i++)\n+    {\n+      value = gcov_get_counter_target ();\n+      counter = gcov_get_counter_ignore_scaling (-1);\n+\n+      if (counter == -1)\n+\t{\n+\t  counters[1] = -1;\n+\t  /* We can't return as we need to read all counters.  */\n+\t  continue;\n+\t}\n+      else if (counter == 0 || counters[1] == -1)\n+\t{\n+\t  /* We can't return as we need to read all counters.  */\n+\t  continue;\n+\t}\n+\n+      for (j = 0; j < GCOV_DISK_SINGLE_VALUES; j++)\n+\t{\n+\t  if (counters[2 * j] == value)\n+\t    {\n+\t      counters[2 * j + 1] += counter;\n+\t      break;\n+\t    }\n+\t  else if (counters[2 * j + 1] == 0)\n+\t    {\n+\t      counters[2 * j] = value;\n+\t      counters[2 * j + 1] = counter;\n+\t      break;\n+\t    }\n+\t}\n+\n+      /* We haven't found a free slot for the value, mark overflow.  */\n+      if (j == GCOV_DISK_SINGLE_VALUES)\n+\tcounters[1] = -1;\n+    }\n+}\n+\n /* The profile merging function for choosing the most common value.\n    It is given an array COUNTERS of N_COUNTERS old counters and it\n    reads the same number of counters from the gcov file.  The counters\n-   are split into 3-tuples where the members of the tuple have\n+   are split into pairs where the members of the tuple have\n    meanings:\n \n    -- the stored candidate on the most common value of the measured entity\n    -- counter\n-   -- total number of evaluations of the value  */\n+   */\n void\n __gcov_merge_single (gcov_type *counters, unsigned n_counters)\n {\n-  unsigned i, n_measures;\n-  gcov_type value, counter, all;\n+  gcc_assert (!(n_counters % GCOV_SINGLE_VALUE_COUNTERS));\n \n-  gcc_assert (!(n_counters % 3));\n-  n_measures = n_counters / 3;\n-  for (i = 0; i < n_measures; i++, counters += 3)\n-    {\n-      value = gcov_get_counter_target ();\n-      counter = gcov_get_counter ();\n-      all = gcov_get_counter ();\n-\n-      if (counters[0] == value)\n-        counters[1] += counter;\n-      else if (counter > counters[1])\n-        {\n-          counters[0] = value;\n-          counters[1] = counter - counters[1];\n-        }\n-      else\n-        counters[1] -= counter;\n-      counters[2] += all;\n-    }\n+  for (unsigned i = 0; i < (n_counters / GCOV_SINGLE_VALUE_COUNTERS); i++)\n+    merge_single_value_set (counters + (i * GCOV_SINGLE_VALUE_COUNTERS));\n }\n #endif /* L_gcov_merge_single */\n "}, {"sha": "9ba65b90df399ecd833dfb905837507749037025", "filename": "libgcc/libgcov-profiler.c", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d417175b9f7b41d5ebe3ceb723f808917ed964/libgcc%2Flibgcov-profiler.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d417175b9f7b41d5ebe3ceb723f808917ed964/libgcc%2Flibgcov-profiler.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-profiler.c?ref=92d417175b9f7b41d5ebe3ceb723f808917ed964", "patch": "@@ -112,40 +112,37 @@ __gcov_pow2_profiler_atomic (gcov_type *counters, gcov_type value)\n    COUNTERS[1] is decremented.  Otherwise COUNTERS[1] is set to one and\n    VALUE is stored to COUNTERS[0].  This algorithm guarantees that if this\n    function is called more than 50% of the time with one value, this value\n-   will be in COUNTERS[0] in the end.\n-\n-   In any case, COUNTERS[2] is incremented.  If USE_ATOMIC is set to 1,\n-   COUNTERS[2] is updated with an atomic instruction.  */\n+   will be in COUNTERS[0] in the end.  */\n \n static inline void\n __gcov_one_value_profiler_body (gcov_type *counters, gcov_type value,\n \t\t\t\tint use_atomic)\n {\n-  if (value == counters[0])\n-    counters[1]++;\n-  else if (counters[1] == 0)\n+  if (value == counters[1])\n+    counters[2]++;\n+  else if (counters[2] == 0)\n     {\n-      counters[1] = 1;\n-      counters[0] = value;\n+      counters[2] = 1;\n+      counters[1] = value;\n     }\n   else\n-    counters[1]--;\n+    counters[2]--;\n \n   if (use_atomic)\n-    __atomic_fetch_add (&counters[2], 1, __ATOMIC_RELAXED);\n+    __atomic_fetch_add (&counters[0], 1, __ATOMIC_RELAXED);\n   else\n-    counters[2]++;\n+    counters[0]++;\n }\n \n-#ifdef L_gcov_one_value_profiler\n+#ifdef L_gcov_one_value_profiler_v2\n void\n-__gcov_one_value_profiler (gcov_type *counters, gcov_type value)\n+__gcov_one_value_profiler_v2 (gcov_type *counters, gcov_type value)\n {\n   __gcov_one_value_profiler_body (counters, value, 0);\n }\n #endif\n \n-#if defined(L_gcov_one_value_profiler_atomic) && GCOV_SUPPORTS_ATOMIC\n+#if defined(L_gcov_one_value_profiler_v2_atomic) && GCOV_SUPPORTS_ATOMIC\n \n /* Update one value profilers (COUNTERS) for a given VALUE.\n \n@@ -157,13 +154,13 @@ __gcov_one_value_profiler (gcov_type *counters, gcov_type value)\n    https://gcc.gnu.org/ml/gcc-patches/2016-08/msg00024.html.  */\n \n void\n-__gcov_one_value_profiler_atomic (gcov_type *counters, gcov_type value)\n+__gcov_one_value_profiler_v2_atomic (gcov_type *counters, gcov_type value)\n {\n   __gcov_one_value_profiler_body (counters, value, 1);\n }\n #endif\n \n-#ifdef L_gcov_indirect_call_profiler_v3\n+#ifdef L_gcov_indirect_call_profiler_v4\n \n /* These two variables are used to actually track caller and callee.  Keep\n    them in TLS memory so races are not common (they are written to often).\n@@ -185,7 +182,7 @@ struct indirect_call_tuple __gcov_indirect_call;\n \n /* Tries to determine the most common value among its inputs. */\n void\n-__gcov_indirect_call_profiler_v3 (gcov_type value, void* cur_func)\n+__gcov_indirect_call_profiler_v4 (gcov_type value, void* cur_func)\n {\n   /* If the C++ virtual tables contain function descriptors then one\n      function may have multiple descriptors and we need to dereference"}, {"sha": "144b4817a371bb382f834c58e731c5f5845cfb0d", "filename": "libgcc/libgcov.h", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d417175b9f7b41d5ebe3ceb723f808917ed964/libgcc%2Flibgcov.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d417175b9f7b41d5ebe3ceb723f808917ed964/libgcc%2Flibgcov.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov.h?ref=92d417175b9f7b41d5ebe3ceb723f808917ed964", "patch": "@@ -271,9 +271,9 @@ extern void __gcov_interval_profiler_atomic (gcov_type *, gcov_type, int,\n \t\t\t\t\t     unsigned);\n extern void __gcov_pow2_profiler (gcov_type *, gcov_type);\n extern void __gcov_pow2_profiler_atomic (gcov_type *, gcov_type);\n-extern void __gcov_one_value_profiler (gcov_type *, gcov_type);\n-extern void __gcov_one_value_profiler_atomic (gcov_type *, gcov_type);\n-extern void __gcov_indirect_call_profiler_v3 (gcov_type, void *);\n+extern void __gcov_one_value_profiler_v2 (gcov_type *, gcov_type);\n+extern void __gcov_one_value_profiler_v2_atomic (gcov_type *, gcov_type);\n+extern void __gcov_indirect_call_profiler_v4 (gcov_type, void *);\n extern void __gcov_time_profiler (gcov_type *);\n extern void __gcov_time_profiler_atomic (gcov_type *);\n extern void __gcov_average_profiler (gcov_type *, gcov_type);\n@@ -324,6 +324,29 @@ gcov_get_counter (void)\n #endif\n }\n \n+/* Similar function as gcov_get_counter(), but do not scale\n+   when read value is equal to IGNORE_SCALING.  */\n+\n+static inline gcov_type\n+gcov_get_counter_ignore_scaling (gcov_type ignore_scaling)\n+{\n+#ifndef IN_GCOV_TOOL\n+  /* This version is for reading count values in libgcov runtime:\n+     we read from gcda files.  */\n+\n+  return gcov_read_counter ();\n+#else\n+  /* This version is for gcov-tool. We read the value from memory and\n+     multiply it by the merge weight.  */\n+\n+  gcov_type v = gcov_read_counter_mem ();\n+  if (v != ignore_scaling)\n+    v *= gcov_get_merge_weight ();\n+\n+  return v;\n+#endif\n+}\n+\n /* Similar function as gcov_get_counter(), but handles target address\n    counters.  */\n "}]}