{"sha": "5a0aad3165fd85695548dfebc3d4901b7027cf3d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWEwYWFkMzE2NWZkODU2OTU1NDhkZmViYzNkNDkwMWI3MDI3Y2YzZA==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "coudert@clipper.ens.fr", "date": "2006-10-22T07:41:48Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2006-10-22T07:41:48Z"}, "message": "re PR fortran/26025 (Optionally use BLAS for matmul)\n\n\tPR fortran/26025\n\n\t* lang.opt: Add -fexternal-blas and -fblas-matmul-limit options.\n\t* options.c (gfc_init_options): Initialize new flags.\n\t(gfc_handle_option): Handle new flags.\n\t* gfortran.h (gfc_option): Add flag_external_blas and\n\tblas_matmul_limit flags.\n\t* trans-expr.c (gfc_conv_function_call): Use new argument\n\tappend_args, appending it at the end of the argument list\n\tbuilt for a function call.\n\t* trans-stmt.c (gfc_trans_call): Use NULL_TREE for the new\n\tappend_args argument to gfc_trans_call.\n\t* trans.h (gfc_conv_function_call): Update prototype.\n\t* trans-decl.c (gfc_build_intrinsic_function_decls): Add\n\tprototypes for BLAS ?gemm routines.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_funcall): Generate the\n\textra arguments given to the library matmul function, and give\n\tthem to gfc_conv_function_call.\n\t* invoke.texi: Add documentation for -fexternal-blas and\n\t-fblas-matmul-limit.\n\n\t* m4/matmul.m4: Add possible call to gemm routine.\n\t* generated/matmul_r8.c: Regenerate.\n\t* generated/matmul_r16.c: Regenerate.\n\t* generated/matmul_c8.c: Regenerate.\n\t* generated/matmul_i8.c: Regenerate.\n\t* generated/matmul_c16.c: Regenerate.\n\t* generated/matmul_r10.c: Regenerate.\n\t* generated/matmul_r4.c: Regenerate.\n\t* generated/matmul_c10.c: Regenerate.\n\t* generated/matmul_c4.c: Regenerate.\n\t* generated/matmul_i4.c: Regenerate.\n\t* generated/matmul_i16.c: Regenerate.\n\nFrom-SVN: r117948", "tree": {"sha": "06dcf4cc8adb7c0677545a92f9a81873ed2e8051", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06dcf4cc8adb7c0677545a92f9a81873ed2e8051"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a0aad3165fd85695548dfebc3d4901b7027cf3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a0aad3165fd85695548dfebc3d4901b7027cf3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a0aad3165fd85695548dfebc3d4901b7027cf3d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a0aad3165fd85695548dfebc3d4901b7027cf3d/comments", "author": null, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4f6a8099d7b944ec7cb570e0e8fcb06b9bc6a59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4f6a8099d7b944ec7cb570e0e8fcb06b9bc6a59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4f6a8099d7b944ec7cb570e0e8fcb06b9bc6a59"}], "stats": {"total": 769, "additions": 726, "deletions": 43}, "files": [{"sha": "53b7b300764a7a1117b590a9f5ed5ed7f6119691", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aad3165fd85695548dfebc3d4901b7027cf3d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aad3165fd85695548dfebc3d4901b7027cf3d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5a0aad3165fd85695548dfebc3d4901b7027cf3d", "patch": "@@ -1,3 +1,25 @@\n+2006-10-22  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n+\n+\tPR fortran/26025\n+\t* lang.opt: Add -fexternal-blas and -fblas-matmul-limit options.\n+\t* options.c (gfc_init_options): Initialize new flags.\n+\t(gfc_handle_option): Handle new flags.\n+\t* gfortran.h (gfc_option): Add flag_external_blas and\n+\tblas_matmul_limit flags.\n+\t* trans-expr.c (gfc_conv_function_call): Use new argument\n+\tappend_args, appending it at the end of the argument list\n+\tbuilt for a function call.\n+\t* trans-stmt.c (gfc_trans_call): Use NULL_TREE for the new\n+\tappend_args argument to gfc_trans_call.\n+\t* trans.h (gfc_conv_function_call): Update prototype.\n+\t* trans-decl.c (gfc_build_intrinsic_function_decls): Add\n+\tprototypes for BLAS ?gemm routines.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_funcall): Generate the\n+\textra arguments given to the library matmul function, and give\n+\tthem to gfc_conv_function_call.\n+\t* invoke.texi: Add documentation for -fexternal-blas and\n+\t-fblas-matmul-limit.\n+\n 2006-10-21  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* Make-lang.in (F95_LIBS): Delete."}, {"sha": "b34d1c28dcbfca80c762d63c4676eaebe26e9577", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aad3165fd85695548dfebc3d4901b7027cf3d/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aad3165fd85695548dfebc3d4901b7027cf3d/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=5a0aad3165fd85695548dfebc3d4901b7027cf3d", "patch": "@@ -1652,6 +1652,8 @@ typedef struct\n   int flag_f2c;\n   int flag_automatic;\n   int flag_backslash;\n+  int flag_external_blas;\n+  int blas_matmul_limit;\n   int flag_cray_pointer;\n   int flag_d_lines;\n   int flag_openmp;"}, {"sha": "8c6aadd6153a8ce9454780789774d87bd24d35c0", "filename": "gcc/fortran/invoke.texi", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aad3165fd85695548dfebc3d4901b7027cf3d/gcc%2Ffortran%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aad3165fd85695548dfebc3d4901b7027cf3d/gcc%2Ffortran%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finvoke.texi?ref=5a0aad3165fd85695548dfebc3d4901b7027cf3d", "patch": "@@ -152,7 +152,8 @@ by type.  Explanations are in the following sections.\n @gccoptlist{\n -fno-automatic -ff2c -fno-underscoring  -fsecond-underscore @gol\n -fbounds-check  -fmax-stack-var-size=@var{n} @gol\n--fpack-derived  -frepack-arrays  -fshort-enums}\n+-fpack-derived  -frepack-arrays  -fshort-enums -fexternal-blas\n+-fblas-matmul-limit=@var{n}}\n @end table\n \n @menu\n@@ -859,6 +860,27 @@ This option is provided for interoperability with C code that was\n compiled with the @command{-fshort-enums} option.  It will make\n GNU Fortran choose the smallest @code{INTEGER} kind a given\n enumerator set will fit in, and give all its enumerators this kind.\n+\n+@cindex -fexternal-blas\n+@item -fexternal-blas\n+This option will make gfortran generate calls to BLAS functions for some\n+matrix operations like @code{MATMUL}, instead of using our own\n+algorithms, if the size of the matrices involved is larger than a given\n+limit (see @command{-fblas-matmul-limit}).  This may be profitable if an\n+optimized vendor BLAS library is available.  The BLAS library will have\n+to be specified at link time.\n+\n+@cindex -fblas-matmul-limit\n+@item -fblas-matmul-limit=@var{n}\n+Only significant when @command{-fexternal-blas} is in effect.\n+Matrix multiplication of matrices with size larger than (or equal to) @var{n}\n+will be performed by calls to BLAS functions, while others will be\n+handled by @command{gfortran} internal algorithms. If the matrices\n+involved are not square, the size comparison is performed using the\n+geometric mean of the dimensions of the argument and result matrices.\n+\n+The default value for @var{n} is 30.\n+\n @end table\n \n @xref{Code Gen Options,,Options for Code Generation Conventions,"}, {"sha": "cbef46a040d72830ea2ca20c3f89fbb4565c7bd4", "filename": "gcc/fortran/lang.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aad3165fd85695548dfebc3d4901b7027cf3d/gcc%2Ffortran%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aad3165fd85695548dfebc3d4901b7027cf3d/gcc%2Ffortran%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flang.opt?ref=5a0aad3165fd85695548dfebc3d4901b7027cf3d", "patch": "@@ -85,6 +85,14 @@ fbackslash\n Fortran\n Specify that backslash in string introduces an escape character\n \n+fexternal-blas\n+Fortran\n+Specify that an external BLAS library should be used for matmul calls on large-size arrays\n+\n+fblas-matmul-limit=\n+Fortran RejectNegative Joined UInteger\n+-fblas-matmul-limit=<n>        Size of the smallest matrix for which matmul will use BLAS\n+\n fdefault-double-8\n Fortran\n Set the default double precision kind to an 8 byte wide type"}, {"sha": "f821d3e2695eb875143457c94226d2a106b34a2c", "filename": "gcc/fortran/options.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aad3165fd85695548dfebc3d4901b7027cf3d/gcc%2Ffortran%2Foptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aad3165fd85695548dfebc3d4901b7027cf3d/gcc%2Ffortran%2Foptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Foptions.c?ref=5a0aad3165fd85695548dfebc3d4901b7027cf3d", "patch": "@@ -80,6 +80,8 @@ gfc_init_options (unsigned int argc ATTRIBUTE_UNUSED,\n   gfc_option.flag_preprocessed = 0;\n   gfc_option.flag_automatic = 1;\n   gfc_option.flag_backslash = 1;\n+  gfc_option.flag_external_blas = 0;\n+  gfc_option.blas_matmul_limit = 30;\n   gfc_option.flag_cray_pointer = 0;\n   gfc_option.flag_d_lines = -1;\n   gfc_option.flag_openmp = 0;\n@@ -450,6 +452,14 @@ gfc_handle_option (size_t scode, const char *arg, int value)\n       gfc_option.flag_dollar_ok = value;\n       break;\n \n+    case OPT_fexternal_blas:\n+      gfc_option.flag_external_blas = value;\n+      break;\n+\n+    case OPT_fblas_matmul_limit_:\n+      gfc_option.blas_matmul_limit = value;\n+      break;\n+\n     case OPT_fd_lines_as_code:\n       gfc_option.flag_d_lines = 1;\n       break;"}, {"sha": "82315b708fcd7101bb31ab1ead5970e880b23c81", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aad3165fd85695548dfebc3d4901b7027cf3d/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aad3165fd85695548dfebc3d4901b7027cf3d/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=5a0aad3165fd85695548dfebc3d4901b7027cf3d", "patch": "@@ -143,6 +143,12 @@ tree gfor_fndecl_iargc;\n tree gfor_fndecl_si_kind;\n tree gfor_fndecl_sr_kind;\n \n+/* BLAS gemm functions.  */\n+tree gfor_fndecl_sgemm;\n+tree gfor_fndecl_dgemm;\n+tree gfor_fndecl_cgemm;\n+tree gfor_fndecl_zgemm;\n+\n \n static void\n gfc_add_decl_to_parent_function (tree decl)\n@@ -2186,6 +2192,49 @@ gfc_build_intrinsic_function_decls (void)\n \t\t\t\t       gfc_int4_type_node, 1,\n \t\t\t\t       gfc_real16_type_node);\n \n+  /* BLAS functions.  */\n+  {\n+    tree pint = build_pointer_type (gfc_c_int_type_node);\n+    tree ps = build_pointer_type (gfc_get_real_type (gfc_default_real_kind));\n+    tree pd = build_pointer_type (gfc_get_real_type (gfc_default_double_kind));\n+    tree pc = build_pointer_type (gfc_get_complex_type (gfc_default_real_kind));\n+    tree pz = build_pointer_type\n+\t\t(gfc_get_complex_type (gfc_default_double_kind));\n+\n+    gfor_fndecl_sgemm = gfc_build_library_function_decl\n+\t\t\t  (get_identifier\n+\t\t\t     (gfc_option.flag_underscoring ? \"sgemm_\"\n+\t\t\t\t\t\t\t   : \"sgemm\"),\n+\t\t\t   void_type_node, 15, pchar_type_node,\n+\t\t\t   pchar_type_node, pint, pint, pint, ps, ps, pint,\n+\t\t\t   ps, pint, ps, ps, pint, gfc_c_int_type_node,\n+\t\t\t   gfc_c_int_type_node);\n+    gfor_fndecl_dgemm = gfc_build_library_function_decl\n+\t\t\t  (get_identifier\n+\t\t\t     (gfc_option.flag_underscoring ? \"dgemm_\"\n+\t\t\t\t\t\t\t   : \"dgemm\"),\n+\t\t\t   void_type_node, 15, pchar_type_node,\n+\t\t\t   pchar_type_node, pint, pint, pint, pd, pd, pint,\n+\t\t\t   pd, pint, pd, pd, pint, gfc_c_int_type_node,\n+\t\t\t   gfc_c_int_type_node);\n+    gfor_fndecl_cgemm = gfc_build_library_function_decl\n+\t\t\t  (get_identifier\n+\t\t\t     (gfc_option.flag_underscoring ? \"cgemm_\"\n+\t\t\t\t\t\t\t   : \"cgemm\"),\n+\t\t\t   void_type_node, 15, pchar_type_node,\n+\t\t\t   pchar_type_node, pint, pint, pint, pc, pc, pint,\n+\t\t\t   pc, pint, pc, pc, pint, gfc_c_int_type_node,\n+\t\t\t   gfc_c_int_type_node);\n+    gfor_fndecl_zgemm = gfc_build_library_function_decl\n+\t\t\t  (get_identifier\n+\t\t\t     (gfc_option.flag_underscoring ? \"zgemm_\"\n+\t\t\t\t\t\t\t   : \"zgemm\"),\n+\t\t\t   void_type_node, 15, pchar_type_node,\n+\t\t\t   pchar_type_node, pint, pint, pint, pz, pz, pint,\n+\t\t\t   pz, pint, pz, pz, pint, gfc_c_int_type_node,\n+\t\t\t   gfc_c_int_type_node);\n+  }\n+\n   /* Other functions.  */\n   gfor_fndecl_size0 =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"size0\")),"}, {"sha": "e5c9f2486bd680dbad5dafcdfdeb661a2642c6f5", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aad3165fd85695548dfebc3d4901b7027cf3d/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aad3165fd85695548dfebc3d4901b7027cf3d/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=5a0aad3165fd85695548dfebc3d4901b7027cf3d", "patch": "@@ -1853,7 +1853,7 @@ is_aliased_array (gfc_expr * e)\n \n int\n gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n-\t\t\tgfc_actual_arglist * arg)\n+\t\t\tgfc_actual_arglist * arg, tree append_args)\n {\n   gfc_interface_mapping mapping;\n   tree arglist;\n@@ -2226,6 +2226,11 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n   /* Add the hidden string length parameters to the arguments.  */\n   arglist = chainon (arglist, stringargs);\n \n+  /* We may want to append extra arguments here.  This is used e.g. for\n+     calls to libgfortran_matmul_??, which need extra information.  */\n+  if (append_args != NULL_TREE)\n+    arglist = chainon (arglist, append_args);\n+\n   /* Generate the actual call.  */\n   gfc_conv_function_val (se, sym);\n   /* If there are alternate return labels, function type should be\n@@ -2545,7 +2550,7 @@ gfc_conv_function_expr (gfc_se * se, gfc_expr * expr)\n   sym = expr->value.function.esym;\n   if (!sym)\n     sym = expr->symtree->n.sym;\n-  gfc_conv_function_call (se, sym, expr->value.function.actual);\n+  gfc_conv_function_call (se, sym, expr->value.function.actual, NULL_TREE);\n }\n \n "}, {"sha": "7dbd60e8096726aca2825a3a14dacb8e74683d80", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aad3165fd85695548dfebc3d4901b7027cf3d/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aad3165fd85695548dfebc3d4901b7027cf3d/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=5a0aad3165fd85695548dfebc3d4901b7027cf3d", "patch": "@@ -1378,6 +1378,7 @@ static void\n gfc_conv_intrinsic_funcall (gfc_se * se, gfc_expr * expr)\n {\n   gfc_symbol *sym;\n+  tree append_args;\n \n   gcc_assert (!se->ss || se->ss->expr == expr);\n \n@@ -1387,7 +1388,54 @@ gfc_conv_intrinsic_funcall (gfc_se * se, gfc_expr * expr)\n     gcc_assert (expr->rank == 0);\n \n   sym = gfc_get_symbol_for_expr (expr);\n-  gfc_conv_function_call (se, sym, expr->value.function.actual);\n+\n+  /* Calls to libgfortran_matmul need to be appended special arguments,\n+     to be able to call the BLAS ?gemm functions if required and possible.  */\n+  append_args = NULL_TREE;\n+  if (expr->value.function.isym->generic_id == GFC_ISYM_MATMUL\n+      && sym->ts.type != BT_LOGICAL)\n+    {\n+      tree cint = gfc_get_int_type (gfc_c_int_kind);\n+\n+      if (gfc_option.flag_external_blas\n+\t  && (sym->ts.type == BT_REAL || sym->ts.type == BT_COMPLEX)\n+\t  && (sym->ts.kind == gfc_default_real_kind\n+\t      || sym->ts.kind == gfc_default_double_kind))\n+\t{\n+\t  tree gemm_fndecl;\n+\n+\t  if (sym->ts.type == BT_REAL)\n+\t    {\n+\t      if (sym->ts.kind == gfc_default_real_kind)\n+\t\tgemm_fndecl = gfor_fndecl_sgemm;\n+\t      else\n+\t\tgemm_fndecl = gfor_fndecl_dgemm;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (sym->ts.kind == gfc_default_real_kind)\n+\t\tgemm_fndecl = gfor_fndecl_cgemm;\n+\t      else\n+\t\tgemm_fndecl = gfor_fndecl_zgemm;\n+\t    }\n+\n+\t  append_args = gfc_chainon_list (NULL_TREE, build_int_cst (cint, 1));\n+\t  append_args = gfc_chainon_list\n+\t\t\t  (append_args, build_int_cst\n+\t\t\t\t\t  (cint, gfc_option.blas_matmul_limit));\n+\t  append_args = gfc_chainon_list (append_args,\n+\t\t\t\t\t  gfc_build_addr_expr (NULL_TREE,\n+\t\t\t\t\t\t\t       gemm_fndecl));\n+\t}\n+      else\n+\t{\n+\t  append_args = gfc_chainon_list (NULL_TREE, build_int_cst (cint, 0));\n+\t  append_args = gfc_chainon_list (append_args, build_int_cst (cint, 0));\n+\t  append_args = gfc_chainon_list (append_args, null_pointer_node);\n+\t}\n+    }\n+\n+  gfc_conv_function_call (se, sym, expr->value.function.actual, append_args);\n   gfc_free (sym);\n }\n "}, {"sha": "03ff0fee92bd88ef43223ecf408a6320074cde26", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aad3165fd85695548dfebc3d4901b7027cf3d/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aad3165fd85695548dfebc3d4901b7027cf3d/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=5a0aad3165fd85695548dfebc3d4901b7027cf3d", "patch": "@@ -334,7 +334,8 @@ gfc_trans_call (gfc_code * code, bool dependency_check)\n \n       /* Translate the call.  */\n       has_alternate_specifier\n-\t= gfc_conv_function_call (&se, code->resolved_sym, code->ext.actual);\n+\t= gfc_conv_function_call (&se, code->resolved_sym, code->ext.actual,\n+\t\t\t\t  NULL_TREE);\n \n       /* A subroutine without side-effect, by definition, does nothing!  */\n       TREE_SIDE_EFFECTS (se.expr) = 1;\n@@ -399,7 +400,8 @@ gfc_trans_call (gfc_code * code, bool dependency_check)\n       gfc_init_block (&block);\n \n       /* Add the subroutine call to the block.  */\n-      gfc_conv_function_call (&loopse, code->resolved_sym, code->ext.actual);\n+      gfc_conv_function_call (&loopse, code->resolved_sym, code->ext.actual,\n+\t\t\t      NULL_TREE);\n       gfc_add_expr_to_block (&loopse.pre, loopse.expr);\n \n       gfc_add_block_to_block (&block, &loopse.pre);"}, {"sha": "e8bb1d5d6aad4d946cdd412976188af6cef66c19", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aad3165fd85695548dfebc3d4901b7027cf3d/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aad3165fd85695548dfebc3d4901b7027cf3d/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=5a0aad3165fd85695548dfebc3d4901b7027cf3d", "patch": "@@ -303,7 +303,8 @@ void gfc_conv_intrinsic_function (gfc_se *, gfc_expr *);\n int gfc_is_intrinsic_libcall (gfc_expr *);\n \n /* Also used to CALL subroutines.  */\n-int gfc_conv_function_call (gfc_se *, gfc_symbol *, gfc_actual_arglist *);\n+int gfc_conv_function_call (gfc_se *, gfc_symbol *, gfc_actual_arglist *,\n+\t\t\t    tree);\n /* gfc_trans_* shouldn't call push/poplevel, use gfc_push/pop_scope */\n \n /* Generate code for a scalar assignment.  */\n@@ -507,6 +508,12 @@ extern GTY(()) tree gfor_fndecl_math_exponent8;\n extern GTY(()) tree gfor_fndecl_math_exponent10;\n extern GTY(()) tree gfor_fndecl_math_exponent16;\n \n+/* BLAS functions.  */\n+extern GTY(()) tree gfor_fndecl_sgemm;\n+extern GTY(()) tree gfor_fndecl_dgemm;\n+extern GTY(()) tree gfor_fndecl_cgemm;\n+extern GTY(()) tree gfor_fndecl_zgemm;\n+\n /* String functions.  */\n extern GTY(()) tree gfor_fndecl_compare_string;\n extern GTY(()) tree gfor_fndecl_concat_string;"}, {"sha": "063c62519d361481753a4c085f2d837f8e0f2259", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aad3165fd85695548dfebc3d4901b7027cf3d/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aad3165fd85695548dfebc3d4901b7027cf3d/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=5a0aad3165fd85695548dfebc3d4901b7027cf3d", "patch": "@@ -1,3 +1,19 @@\n+2006-10-22  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n+\n+\tPR fortran/26025\n+\t* m4/matmul.m4: Add possible call to gemm routine.\n+\t* generated/matmul_r8.c: Regenerate.\n+\t* generated/matmul_r16.c: Regenerate.\n+\t* generated/matmul_c8.c: Regenerate.\n+\t* generated/matmul_i8.c: Regenerate.\n+\t* generated/matmul_c16.c: Regenerate.\n+\t* generated/matmul_r10.c: Regenerate.\n+\t* generated/matmul_r4.c: Regenerate.\n+\t* generated/matmul_c10.c: Regenerate.\n+\t* generated/matmul_c4.c: Regenerate.\n+\t* generated/matmul_i4.c: Regenerate.\n+\t* generated/matmul_i16.c: Regenerate.\n+\n 2006-10-21  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \t* runtime/error.c: Add errno.h"}, {"sha": "5e3b281245c5d358a1326452bf1e13becdfd90be", "filename": "libgfortran/generated/matmul_c10.c", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aad3165fd85695548dfebc3d4901b7027cf3d/libgfortran%2Fgenerated%2Fmatmul_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aad3165fd85695548dfebc3d4901b7027cf3d/libgfortran%2Fgenerated%2Fmatmul_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c10.c?ref=5a0aad3165fd85695548dfebc3d4901b7027cf3d", "patch": "@@ -36,6 +36,16 @@ Boston, MA 02110-1301, USA.  */\n \n #if defined (HAVE_GFC_COMPLEX_10)\n \n+/* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n+   passed to us by the front-end, in which case we'll call it for large\n+   matrices.  */\n+\n+typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n+                          const int *, const GFC_COMPLEX_10 *, const GFC_COMPLEX_10 *,\n+                          const int *, const GFC_COMPLEX_10 *, const int *,\n+                          const GFC_COMPLEX_10 *, GFC_COMPLEX_10 *, const int *,\n+                          int, int);\n+\n /* The order of loops is different in the case of plain matrix\n    multiplication C=MATMUL(A,B), and in the frequent special case where\n    the argument A is the temporary result of a TRANSPOSE intrinsic:\n@@ -56,18 +66,24 @@ Boston, MA 02110-1301, USA.  */\n        DO I=1,M\n          S = 0\n          DO K=1,COUNT\n-           S = S+A(I,K)+B(K,J)\n+           S = S+A(I,K)*B(K,J)\n          C(I,J) = S\n    ENDIF\n */\n \n+/* If try_blas is set to a nonzero value, then the matmul function will\n+   see if there is a way to perform the matrix multiplication by a call\n+   to the BLAS gemm function.  */\n+\n extern void matmul_c10 (gfc_array_c10 * const restrict retarray, \n-\tgfc_array_c10 * const restrict a, gfc_array_c10 * const restrict b);\n+\tgfc_array_c10 * const restrict a, gfc_array_c10 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm);\n export_proto(matmul_c10);\n \n void\n matmul_c10 (gfc_array_c10 * const restrict retarray, \n-\tgfc_array_c10 * const restrict a, gfc_array_c10 * const restrict b)\n+\tgfc_array_c10 * const restrict a, gfc_array_c10 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n {\n   const GFC_COMPLEX_10 * restrict abase;\n   const GFC_COMPLEX_10 * restrict bbase;\n@@ -177,6 +193,31 @@ matmul_c10 (gfc_array_c10 * const restrict retarray,\n   bbase = b->data;\n   dest = retarray->data;\n \n+\n+  /* Now that everything is set up, we're performing the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+  {\n+    const int m = xcount, n = ycount, k = count, ldc = rystride;\n+    const GFC_COMPLEX_10 one = 1, zero = 0;\n+    const int lda = (axstride == 1) ? aystride : axstride,\n+              ldb = (bxstride == 1) ? bystride : bxstride;\n+\n+    if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+      {\n+        assert (gemm != NULL);\n+        gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m, &n, &k,\n+              &one, abase, &lda, bbase, &ldb, &zero, dest, &ldc, 1, 1);\n+        return;\n+      }\n+  }\n+\n   if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n       const GFC_COMPLEX_10 * restrict bbase_y;"}, {"sha": "f7301114b377e6d1914275b54c130ce9335fcdf0", "filename": "libgfortran/generated/matmul_c16.c", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aad3165fd85695548dfebc3d4901b7027cf3d/libgfortran%2Fgenerated%2Fmatmul_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aad3165fd85695548dfebc3d4901b7027cf3d/libgfortran%2Fgenerated%2Fmatmul_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c16.c?ref=5a0aad3165fd85695548dfebc3d4901b7027cf3d", "patch": "@@ -36,6 +36,16 @@ Boston, MA 02110-1301, USA.  */\n \n #if defined (HAVE_GFC_COMPLEX_16)\n \n+/* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n+   passed to us by the front-end, in which case we'll call it for large\n+   matrices.  */\n+\n+typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n+                          const int *, const GFC_COMPLEX_16 *, const GFC_COMPLEX_16 *,\n+                          const int *, const GFC_COMPLEX_16 *, const int *,\n+                          const GFC_COMPLEX_16 *, GFC_COMPLEX_16 *, const int *,\n+                          int, int);\n+\n /* The order of loops is different in the case of plain matrix\n    multiplication C=MATMUL(A,B), and in the frequent special case where\n    the argument A is the temporary result of a TRANSPOSE intrinsic:\n@@ -56,18 +66,24 @@ Boston, MA 02110-1301, USA.  */\n        DO I=1,M\n          S = 0\n          DO K=1,COUNT\n-           S = S+A(I,K)+B(K,J)\n+           S = S+A(I,K)*B(K,J)\n          C(I,J) = S\n    ENDIF\n */\n \n+/* If try_blas is set to a nonzero value, then the matmul function will\n+   see if there is a way to perform the matrix multiplication by a call\n+   to the BLAS gemm function.  */\n+\n extern void matmul_c16 (gfc_array_c16 * const restrict retarray, \n-\tgfc_array_c16 * const restrict a, gfc_array_c16 * const restrict b);\n+\tgfc_array_c16 * const restrict a, gfc_array_c16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm);\n export_proto(matmul_c16);\n \n void\n matmul_c16 (gfc_array_c16 * const restrict retarray, \n-\tgfc_array_c16 * const restrict a, gfc_array_c16 * const restrict b)\n+\tgfc_array_c16 * const restrict a, gfc_array_c16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n {\n   const GFC_COMPLEX_16 * restrict abase;\n   const GFC_COMPLEX_16 * restrict bbase;\n@@ -177,6 +193,31 @@ matmul_c16 (gfc_array_c16 * const restrict retarray,\n   bbase = b->data;\n   dest = retarray->data;\n \n+\n+  /* Now that everything is set up, we're performing the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+  {\n+    const int m = xcount, n = ycount, k = count, ldc = rystride;\n+    const GFC_COMPLEX_16 one = 1, zero = 0;\n+    const int lda = (axstride == 1) ? aystride : axstride,\n+              ldb = (bxstride == 1) ? bystride : bxstride;\n+\n+    if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+      {\n+        assert (gemm != NULL);\n+        gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m, &n, &k,\n+              &one, abase, &lda, bbase, &ldb, &zero, dest, &ldc, 1, 1);\n+        return;\n+      }\n+  }\n+\n   if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n       const GFC_COMPLEX_16 * restrict bbase_y;"}, {"sha": "f2984ab48abdf219e6fa31fb960b348f96b30636", "filename": "libgfortran/generated/matmul_c4.c", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aad3165fd85695548dfebc3d4901b7027cf3d/libgfortran%2Fgenerated%2Fmatmul_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aad3165fd85695548dfebc3d4901b7027cf3d/libgfortran%2Fgenerated%2Fmatmul_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c4.c?ref=5a0aad3165fd85695548dfebc3d4901b7027cf3d", "patch": "@@ -36,6 +36,16 @@ Boston, MA 02110-1301, USA.  */\n \n #if defined (HAVE_GFC_COMPLEX_4)\n \n+/* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n+   passed to us by the front-end, in which case we'll call it for large\n+   matrices.  */\n+\n+typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n+                          const int *, const GFC_COMPLEX_4 *, const GFC_COMPLEX_4 *,\n+                          const int *, const GFC_COMPLEX_4 *, const int *,\n+                          const GFC_COMPLEX_4 *, GFC_COMPLEX_4 *, const int *,\n+                          int, int);\n+\n /* The order of loops is different in the case of plain matrix\n    multiplication C=MATMUL(A,B), and in the frequent special case where\n    the argument A is the temporary result of a TRANSPOSE intrinsic:\n@@ -56,18 +66,24 @@ Boston, MA 02110-1301, USA.  */\n        DO I=1,M\n          S = 0\n          DO K=1,COUNT\n-           S = S+A(I,K)+B(K,J)\n+           S = S+A(I,K)*B(K,J)\n          C(I,J) = S\n    ENDIF\n */\n \n+/* If try_blas is set to a nonzero value, then the matmul function will\n+   see if there is a way to perform the matrix multiplication by a call\n+   to the BLAS gemm function.  */\n+\n extern void matmul_c4 (gfc_array_c4 * const restrict retarray, \n-\tgfc_array_c4 * const restrict a, gfc_array_c4 * const restrict b);\n+\tgfc_array_c4 * const restrict a, gfc_array_c4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm);\n export_proto(matmul_c4);\n \n void\n matmul_c4 (gfc_array_c4 * const restrict retarray, \n-\tgfc_array_c4 * const restrict a, gfc_array_c4 * const restrict b)\n+\tgfc_array_c4 * const restrict a, gfc_array_c4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n {\n   const GFC_COMPLEX_4 * restrict abase;\n   const GFC_COMPLEX_4 * restrict bbase;\n@@ -177,6 +193,31 @@ matmul_c4 (gfc_array_c4 * const restrict retarray,\n   bbase = b->data;\n   dest = retarray->data;\n \n+\n+  /* Now that everything is set up, we're performing the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+  {\n+    const int m = xcount, n = ycount, k = count, ldc = rystride;\n+    const GFC_COMPLEX_4 one = 1, zero = 0;\n+    const int lda = (axstride == 1) ? aystride : axstride,\n+              ldb = (bxstride == 1) ? bystride : bxstride;\n+\n+    if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+      {\n+        assert (gemm != NULL);\n+        gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m, &n, &k,\n+              &one, abase, &lda, bbase, &ldb, &zero, dest, &ldc, 1, 1);\n+        return;\n+      }\n+  }\n+\n   if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n       const GFC_COMPLEX_4 * restrict bbase_y;"}, {"sha": "65cc0a52c4b49736e8cf5bcf667d3d5a8f7683a3", "filename": "libgfortran/generated/matmul_c8.c", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aad3165fd85695548dfebc3d4901b7027cf3d/libgfortran%2Fgenerated%2Fmatmul_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aad3165fd85695548dfebc3d4901b7027cf3d/libgfortran%2Fgenerated%2Fmatmul_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c8.c?ref=5a0aad3165fd85695548dfebc3d4901b7027cf3d", "patch": "@@ -36,6 +36,16 @@ Boston, MA 02110-1301, USA.  */\n \n #if defined (HAVE_GFC_COMPLEX_8)\n \n+/* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n+   passed to us by the front-end, in which case we'll call it for large\n+   matrices.  */\n+\n+typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n+                          const int *, const GFC_COMPLEX_8 *, const GFC_COMPLEX_8 *,\n+                          const int *, const GFC_COMPLEX_8 *, const int *,\n+                          const GFC_COMPLEX_8 *, GFC_COMPLEX_8 *, const int *,\n+                          int, int);\n+\n /* The order of loops is different in the case of plain matrix\n    multiplication C=MATMUL(A,B), and in the frequent special case where\n    the argument A is the temporary result of a TRANSPOSE intrinsic:\n@@ -56,18 +66,24 @@ Boston, MA 02110-1301, USA.  */\n        DO I=1,M\n          S = 0\n          DO K=1,COUNT\n-           S = S+A(I,K)+B(K,J)\n+           S = S+A(I,K)*B(K,J)\n          C(I,J) = S\n    ENDIF\n */\n \n+/* If try_blas is set to a nonzero value, then the matmul function will\n+   see if there is a way to perform the matrix multiplication by a call\n+   to the BLAS gemm function.  */\n+\n extern void matmul_c8 (gfc_array_c8 * const restrict retarray, \n-\tgfc_array_c8 * const restrict a, gfc_array_c8 * const restrict b);\n+\tgfc_array_c8 * const restrict a, gfc_array_c8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm);\n export_proto(matmul_c8);\n \n void\n matmul_c8 (gfc_array_c8 * const restrict retarray, \n-\tgfc_array_c8 * const restrict a, gfc_array_c8 * const restrict b)\n+\tgfc_array_c8 * const restrict a, gfc_array_c8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n {\n   const GFC_COMPLEX_8 * restrict abase;\n   const GFC_COMPLEX_8 * restrict bbase;\n@@ -177,6 +193,31 @@ matmul_c8 (gfc_array_c8 * const restrict retarray,\n   bbase = b->data;\n   dest = retarray->data;\n \n+\n+  /* Now that everything is set up, we're performing the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+  {\n+    const int m = xcount, n = ycount, k = count, ldc = rystride;\n+    const GFC_COMPLEX_8 one = 1, zero = 0;\n+    const int lda = (axstride == 1) ? aystride : axstride,\n+              ldb = (bxstride == 1) ? bystride : bxstride;\n+\n+    if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+      {\n+        assert (gemm != NULL);\n+        gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m, &n, &k,\n+              &one, abase, &lda, bbase, &ldb, &zero, dest, &ldc, 1, 1);\n+        return;\n+      }\n+  }\n+\n   if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n       const GFC_COMPLEX_8 * restrict bbase_y;"}, {"sha": "a193669d1081b1c769379ce4ffa46709759ecf5e", "filename": "libgfortran/generated/matmul_i16.c", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aad3165fd85695548dfebc3d4901b7027cf3d/libgfortran%2Fgenerated%2Fmatmul_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aad3165fd85695548dfebc3d4901b7027cf3d/libgfortran%2Fgenerated%2Fmatmul_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i16.c?ref=5a0aad3165fd85695548dfebc3d4901b7027cf3d", "patch": "@@ -36,6 +36,16 @@ Boston, MA 02110-1301, USA.  */\n \n #if defined (HAVE_GFC_INTEGER_16)\n \n+/* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n+   passed to us by the front-end, in which case we'll call it for large\n+   matrices.  */\n+\n+typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n+                          const int *, const GFC_INTEGER_16 *, const GFC_INTEGER_16 *,\n+                          const int *, const GFC_INTEGER_16 *, const int *,\n+                          const GFC_INTEGER_16 *, GFC_INTEGER_16 *, const int *,\n+                          int, int);\n+\n /* The order of loops is different in the case of plain matrix\n    multiplication C=MATMUL(A,B), and in the frequent special case where\n    the argument A is the temporary result of a TRANSPOSE intrinsic:\n@@ -56,18 +66,24 @@ Boston, MA 02110-1301, USA.  */\n        DO I=1,M\n          S = 0\n          DO K=1,COUNT\n-           S = S+A(I,K)+B(K,J)\n+           S = S+A(I,K)*B(K,J)\n          C(I,J) = S\n    ENDIF\n */\n \n+/* If try_blas is set to a nonzero value, then the matmul function will\n+   see if there is a way to perform the matrix multiplication by a call\n+   to the BLAS gemm function.  */\n+\n extern void matmul_i16 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_i16 * const restrict a, gfc_array_i16 * const restrict b);\n+\tgfc_array_i16 * const restrict a, gfc_array_i16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm);\n export_proto(matmul_i16);\n \n void\n matmul_i16 (gfc_array_i16 * const restrict retarray, \n-\tgfc_array_i16 * const restrict a, gfc_array_i16 * const restrict b)\n+\tgfc_array_i16 * const restrict a, gfc_array_i16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n {\n   const GFC_INTEGER_16 * restrict abase;\n   const GFC_INTEGER_16 * restrict bbase;\n@@ -177,6 +193,31 @@ matmul_i16 (gfc_array_i16 * const restrict retarray,\n   bbase = b->data;\n   dest = retarray->data;\n \n+\n+  /* Now that everything is set up, we're performing the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+  {\n+    const int m = xcount, n = ycount, k = count, ldc = rystride;\n+    const GFC_INTEGER_16 one = 1, zero = 0;\n+    const int lda = (axstride == 1) ? aystride : axstride,\n+              ldb = (bxstride == 1) ? bystride : bxstride;\n+\n+    if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+      {\n+        assert (gemm != NULL);\n+        gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m, &n, &k,\n+              &one, abase, &lda, bbase, &ldb, &zero, dest, &ldc, 1, 1);\n+        return;\n+      }\n+  }\n+\n   if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n       const GFC_INTEGER_16 * restrict bbase_y;"}, {"sha": "69b9b487a8195dc8de7167f10f86f2640024311a", "filename": "libgfortran/generated/matmul_i4.c", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aad3165fd85695548dfebc3d4901b7027cf3d/libgfortran%2Fgenerated%2Fmatmul_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aad3165fd85695548dfebc3d4901b7027cf3d/libgfortran%2Fgenerated%2Fmatmul_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i4.c?ref=5a0aad3165fd85695548dfebc3d4901b7027cf3d", "patch": "@@ -36,6 +36,16 @@ Boston, MA 02110-1301, USA.  */\n \n #if defined (HAVE_GFC_INTEGER_4)\n \n+/* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n+   passed to us by the front-end, in which case we'll call it for large\n+   matrices.  */\n+\n+typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n+                          const int *, const GFC_INTEGER_4 *, const GFC_INTEGER_4 *,\n+                          const int *, const GFC_INTEGER_4 *, const int *,\n+                          const GFC_INTEGER_4 *, GFC_INTEGER_4 *, const int *,\n+                          int, int);\n+\n /* The order of loops is different in the case of plain matrix\n    multiplication C=MATMUL(A,B), and in the frequent special case where\n    the argument A is the temporary result of a TRANSPOSE intrinsic:\n@@ -56,18 +66,24 @@ Boston, MA 02110-1301, USA.  */\n        DO I=1,M\n          S = 0\n          DO K=1,COUNT\n-           S = S+A(I,K)+B(K,J)\n+           S = S+A(I,K)*B(K,J)\n          C(I,J) = S\n    ENDIF\n */\n \n+/* If try_blas is set to a nonzero value, then the matmul function will\n+   see if there is a way to perform the matrix multiplication by a call\n+   to the BLAS gemm function.  */\n+\n extern void matmul_i4 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_i4 * const restrict a, gfc_array_i4 * const restrict b);\n+\tgfc_array_i4 * const restrict a, gfc_array_i4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm);\n export_proto(matmul_i4);\n \n void\n matmul_i4 (gfc_array_i4 * const restrict retarray, \n-\tgfc_array_i4 * const restrict a, gfc_array_i4 * const restrict b)\n+\tgfc_array_i4 * const restrict a, gfc_array_i4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n {\n   const GFC_INTEGER_4 * restrict abase;\n   const GFC_INTEGER_4 * restrict bbase;\n@@ -177,6 +193,31 @@ matmul_i4 (gfc_array_i4 * const restrict retarray,\n   bbase = b->data;\n   dest = retarray->data;\n \n+\n+  /* Now that everything is set up, we're performing the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+  {\n+    const int m = xcount, n = ycount, k = count, ldc = rystride;\n+    const GFC_INTEGER_4 one = 1, zero = 0;\n+    const int lda = (axstride == 1) ? aystride : axstride,\n+              ldb = (bxstride == 1) ? bystride : bxstride;\n+\n+    if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+      {\n+        assert (gemm != NULL);\n+        gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m, &n, &k,\n+              &one, abase, &lda, bbase, &ldb, &zero, dest, &ldc, 1, 1);\n+        return;\n+      }\n+  }\n+\n   if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n       const GFC_INTEGER_4 * restrict bbase_y;"}, {"sha": "23a87a904f7b97eb6513f203bd6d6ca3954585c5", "filename": "libgfortran/generated/matmul_i8.c", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aad3165fd85695548dfebc3d4901b7027cf3d/libgfortran%2Fgenerated%2Fmatmul_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aad3165fd85695548dfebc3d4901b7027cf3d/libgfortran%2Fgenerated%2Fmatmul_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i8.c?ref=5a0aad3165fd85695548dfebc3d4901b7027cf3d", "patch": "@@ -36,6 +36,16 @@ Boston, MA 02110-1301, USA.  */\n \n #if defined (HAVE_GFC_INTEGER_8)\n \n+/* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n+   passed to us by the front-end, in which case we'll call it for large\n+   matrices.  */\n+\n+typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n+                          const int *, const GFC_INTEGER_8 *, const GFC_INTEGER_8 *,\n+                          const int *, const GFC_INTEGER_8 *, const int *,\n+                          const GFC_INTEGER_8 *, GFC_INTEGER_8 *, const int *,\n+                          int, int);\n+\n /* The order of loops is different in the case of plain matrix\n    multiplication C=MATMUL(A,B), and in the frequent special case where\n    the argument A is the temporary result of a TRANSPOSE intrinsic:\n@@ -56,18 +66,24 @@ Boston, MA 02110-1301, USA.  */\n        DO I=1,M\n          S = 0\n          DO K=1,COUNT\n-           S = S+A(I,K)+B(K,J)\n+           S = S+A(I,K)*B(K,J)\n          C(I,J) = S\n    ENDIF\n */\n \n+/* If try_blas is set to a nonzero value, then the matmul function will\n+   see if there is a way to perform the matrix multiplication by a call\n+   to the BLAS gemm function.  */\n+\n extern void matmul_i8 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_i8 * const restrict a, gfc_array_i8 * const restrict b);\n+\tgfc_array_i8 * const restrict a, gfc_array_i8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm);\n export_proto(matmul_i8);\n \n void\n matmul_i8 (gfc_array_i8 * const restrict retarray, \n-\tgfc_array_i8 * const restrict a, gfc_array_i8 * const restrict b)\n+\tgfc_array_i8 * const restrict a, gfc_array_i8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n {\n   const GFC_INTEGER_8 * restrict abase;\n   const GFC_INTEGER_8 * restrict bbase;\n@@ -177,6 +193,31 @@ matmul_i8 (gfc_array_i8 * const restrict retarray,\n   bbase = b->data;\n   dest = retarray->data;\n \n+\n+  /* Now that everything is set up, we're performing the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+  {\n+    const int m = xcount, n = ycount, k = count, ldc = rystride;\n+    const GFC_INTEGER_8 one = 1, zero = 0;\n+    const int lda = (axstride == 1) ? aystride : axstride,\n+              ldb = (bxstride == 1) ? bystride : bxstride;\n+\n+    if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+      {\n+        assert (gemm != NULL);\n+        gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m, &n, &k,\n+              &one, abase, &lda, bbase, &ldb, &zero, dest, &ldc, 1, 1);\n+        return;\n+      }\n+  }\n+\n   if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n       const GFC_INTEGER_8 * restrict bbase_y;"}, {"sha": "e4dfd74ef03eb6a1e5c584ba5130072b1c602a83", "filename": "libgfortran/generated/matmul_r10.c", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aad3165fd85695548dfebc3d4901b7027cf3d/libgfortran%2Fgenerated%2Fmatmul_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aad3165fd85695548dfebc3d4901b7027cf3d/libgfortran%2Fgenerated%2Fmatmul_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r10.c?ref=5a0aad3165fd85695548dfebc3d4901b7027cf3d", "patch": "@@ -36,6 +36,16 @@ Boston, MA 02110-1301, USA.  */\n \n #if defined (HAVE_GFC_REAL_10)\n \n+/* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n+   passed to us by the front-end, in which case we'll call it for large\n+   matrices.  */\n+\n+typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n+                          const int *, const GFC_REAL_10 *, const GFC_REAL_10 *,\n+                          const int *, const GFC_REAL_10 *, const int *,\n+                          const GFC_REAL_10 *, GFC_REAL_10 *, const int *,\n+                          int, int);\n+\n /* The order of loops is different in the case of plain matrix\n    multiplication C=MATMUL(A,B), and in the frequent special case where\n    the argument A is the temporary result of a TRANSPOSE intrinsic:\n@@ -56,18 +66,24 @@ Boston, MA 02110-1301, USA.  */\n        DO I=1,M\n          S = 0\n          DO K=1,COUNT\n-           S = S+A(I,K)+B(K,J)\n+           S = S+A(I,K)*B(K,J)\n          C(I,J) = S\n    ENDIF\n */\n \n+/* If try_blas is set to a nonzero value, then the matmul function will\n+   see if there is a way to perform the matrix multiplication by a call\n+   to the BLAS gemm function.  */\n+\n extern void matmul_r10 (gfc_array_r10 * const restrict retarray, \n-\tgfc_array_r10 * const restrict a, gfc_array_r10 * const restrict b);\n+\tgfc_array_r10 * const restrict a, gfc_array_r10 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm);\n export_proto(matmul_r10);\n \n void\n matmul_r10 (gfc_array_r10 * const restrict retarray, \n-\tgfc_array_r10 * const restrict a, gfc_array_r10 * const restrict b)\n+\tgfc_array_r10 * const restrict a, gfc_array_r10 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n {\n   const GFC_REAL_10 * restrict abase;\n   const GFC_REAL_10 * restrict bbase;\n@@ -177,6 +193,31 @@ matmul_r10 (gfc_array_r10 * const restrict retarray,\n   bbase = b->data;\n   dest = retarray->data;\n \n+\n+  /* Now that everything is set up, we're performing the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+  {\n+    const int m = xcount, n = ycount, k = count, ldc = rystride;\n+    const GFC_REAL_10 one = 1, zero = 0;\n+    const int lda = (axstride == 1) ? aystride : axstride,\n+              ldb = (bxstride == 1) ? bystride : bxstride;\n+\n+    if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+      {\n+        assert (gemm != NULL);\n+        gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m, &n, &k,\n+              &one, abase, &lda, bbase, &ldb, &zero, dest, &ldc, 1, 1);\n+        return;\n+      }\n+  }\n+\n   if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n       const GFC_REAL_10 * restrict bbase_y;"}, {"sha": "ec760f2d3d8ce2268c310ea8de51b1c3d51a5d36", "filename": "libgfortran/generated/matmul_r16.c", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aad3165fd85695548dfebc3d4901b7027cf3d/libgfortran%2Fgenerated%2Fmatmul_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aad3165fd85695548dfebc3d4901b7027cf3d/libgfortran%2Fgenerated%2Fmatmul_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r16.c?ref=5a0aad3165fd85695548dfebc3d4901b7027cf3d", "patch": "@@ -36,6 +36,16 @@ Boston, MA 02110-1301, USA.  */\n \n #if defined (HAVE_GFC_REAL_16)\n \n+/* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n+   passed to us by the front-end, in which case we'll call it for large\n+   matrices.  */\n+\n+typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n+                          const int *, const GFC_REAL_16 *, const GFC_REAL_16 *,\n+                          const int *, const GFC_REAL_16 *, const int *,\n+                          const GFC_REAL_16 *, GFC_REAL_16 *, const int *,\n+                          int, int);\n+\n /* The order of loops is different in the case of plain matrix\n    multiplication C=MATMUL(A,B), and in the frequent special case where\n    the argument A is the temporary result of a TRANSPOSE intrinsic:\n@@ -56,18 +66,24 @@ Boston, MA 02110-1301, USA.  */\n        DO I=1,M\n          S = 0\n          DO K=1,COUNT\n-           S = S+A(I,K)+B(K,J)\n+           S = S+A(I,K)*B(K,J)\n          C(I,J) = S\n    ENDIF\n */\n \n+/* If try_blas is set to a nonzero value, then the matmul function will\n+   see if there is a way to perform the matrix multiplication by a call\n+   to the BLAS gemm function.  */\n+\n extern void matmul_r16 (gfc_array_r16 * const restrict retarray, \n-\tgfc_array_r16 * const restrict a, gfc_array_r16 * const restrict b);\n+\tgfc_array_r16 * const restrict a, gfc_array_r16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm);\n export_proto(matmul_r16);\n \n void\n matmul_r16 (gfc_array_r16 * const restrict retarray, \n-\tgfc_array_r16 * const restrict a, gfc_array_r16 * const restrict b)\n+\tgfc_array_r16 * const restrict a, gfc_array_r16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n {\n   const GFC_REAL_16 * restrict abase;\n   const GFC_REAL_16 * restrict bbase;\n@@ -177,6 +193,31 @@ matmul_r16 (gfc_array_r16 * const restrict retarray,\n   bbase = b->data;\n   dest = retarray->data;\n \n+\n+  /* Now that everything is set up, we're performing the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+  {\n+    const int m = xcount, n = ycount, k = count, ldc = rystride;\n+    const GFC_REAL_16 one = 1, zero = 0;\n+    const int lda = (axstride == 1) ? aystride : axstride,\n+              ldb = (bxstride == 1) ? bystride : bxstride;\n+\n+    if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+      {\n+        assert (gemm != NULL);\n+        gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m, &n, &k,\n+              &one, abase, &lda, bbase, &ldb, &zero, dest, &ldc, 1, 1);\n+        return;\n+      }\n+  }\n+\n   if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n       const GFC_REAL_16 * restrict bbase_y;"}, {"sha": "cf2f45fb12563a9b9f1ed907938685192ec15c4e", "filename": "libgfortran/generated/matmul_r4.c", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aad3165fd85695548dfebc3d4901b7027cf3d/libgfortran%2Fgenerated%2Fmatmul_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aad3165fd85695548dfebc3d4901b7027cf3d/libgfortran%2Fgenerated%2Fmatmul_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r4.c?ref=5a0aad3165fd85695548dfebc3d4901b7027cf3d", "patch": "@@ -36,6 +36,16 @@ Boston, MA 02110-1301, USA.  */\n \n #if defined (HAVE_GFC_REAL_4)\n \n+/* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n+   passed to us by the front-end, in which case we'll call it for large\n+   matrices.  */\n+\n+typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n+                          const int *, const GFC_REAL_4 *, const GFC_REAL_4 *,\n+                          const int *, const GFC_REAL_4 *, const int *,\n+                          const GFC_REAL_4 *, GFC_REAL_4 *, const int *,\n+                          int, int);\n+\n /* The order of loops is different in the case of plain matrix\n    multiplication C=MATMUL(A,B), and in the frequent special case where\n    the argument A is the temporary result of a TRANSPOSE intrinsic:\n@@ -56,18 +66,24 @@ Boston, MA 02110-1301, USA.  */\n        DO I=1,M\n          S = 0\n          DO K=1,COUNT\n-           S = S+A(I,K)+B(K,J)\n+           S = S+A(I,K)*B(K,J)\n          C(I,J) = S\n    ENDIF\n */\n \n+/* If try_blas is set to a nonzero value, then the matmul function will\n+   see if there is a way to perform the matrix multiplication by a call\n+   to the BLAS gemm function.  */\n+\n extern void matmul_r4 (gfc_array_r4 * const restrict retarray, \n-\tgfc_array_r4 * const restrict a, gfc_array_r4 * const restrict b);\n+\tgfc_array_r4 * const restrict a, gfc_array_r4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm);\n export_proto(matmul_r4);\n \n void\n matmul_r4 (gfc_array_r4 * const restrict retarray, \n-\tgfc_array_r4 * const restrict a, gfc_array_r4 * const restrict b)\n+\tgfc_array_r4 * const restrict a, gfc_array_r4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n {\n   const GFC_REAL_4 * restrict abase;\n   const GFC_REAL_4 * restrict bbase;\n@@ -177,6 +193,31 @@ matmul_r4 (gfc_array_r4 * const restrict retarray,\n   bbase = b->data;\n   dest = retarray->data;\n \n+\n+  /* Now that everything is set up, we're performing the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+  {\n+    const int m = xcount, n = ycount, k = count, ldc = rystride;\n+    const GFC_REAL_4 one = 1, zero = 0;\n+    const int lda = (axstride == 1) ? aystride : axstride,\n+              ldb = (bxstride == 1) ? bystride : bxstride;\n+\n+    if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+      {\n+        assert (gemm != NULL);\n+        gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m, &n, &k,\n+              &one, abase, &lda, bbase, &ldb, &zero, dest, &ldc, 1, 1);\n+        return;\n+      }\n+  }\n+\n   if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n       const GFC_REAL_4 * restrict bbase_y;"}, {"sha": "c746f6c351985f111db51fff88fa40d1bbdc0a99", "filename": "libgfortran/generated/matmul_r8.c", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aad3165fd85695548dfebc3d4901b7027cf3d/libgfortran%2Fgenerated%2Fmatmul_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aad3165fd85695548dfebc3d4901b7027cf3d/libgfortran%2Fgenerated%2Fmatmul_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r8.c?ref=5a0aad3165fd85695548dfebc3d4901b7027cf3d", "patch": "@@ -36,6 +36,16 @@ Boston, MA 02110-1301, USA.  */\n \n #if defined (HAVE_GFC_REAL_8)\n \n+/* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n+   passed to us by the front-end, in which case we'll call it for large\n+   matrices.  */\n+\n+typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n+                          const int *, const GFC_REAL_8 *, const GFC_REAL_8 *,\n+                          const int *, const GFC_REAL_8 *, const int *,\n+                          const GFC_REAL_8 *, GFC_REAL_8 *, const int *,\n+                          int, int);\n+\n /* The order of loops is different in the case of plain matrix\n    multiplication C=MATMUL(A,B), and in the frequent special case where\n    the argument A is the temporary result of a TRANSPOSE intrinsic:\n@@ -56,18 +66,24 @@ Boston, MA 02110-1301, USA.  */\n        DO I=1,M\n          S = 0\n          DO K=1,COUNT\n-           S = S+A(I,K)+B(K,J)\n+           S = S+A(I,K)*B(K,J)\n          C(I,J) = S\n    ENDIF\n */\n \n+/* If try_blas is set to a nonzero value, then the matmul function will\n+   see if there is a way to perform the matrix multiplication by a call\n+   to the BLAS gemm function.  */\n+\n extern void matmul_r8 (gfc_array_r8 * const restrict retarray, \n-\tgfc_array_r8 * const restrict a, gfc_array_r8 * const restrict b);\n+\tgfc_array_r8 * const restrict a, gfc_array_r8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm);\n export_proto(matmul_r8);\n \n void\n matmul_r8 (gfc_array_r8 * const restrict retarray, \n-\tgfc_array_r8 * const restrict a, gfc_array_r8 * const restrict b)\n+\tgfc_array_r8 * const restrict a, gfc_array_r8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n {\n   const GFC_REAL_8 * restrict abase;\n   const GFC_REAL_8 * restrict bbase;\n@@ -177,6 +193,31 @@ matmul_r8 (gfc_array_r8 * const restrict retarray,\n   bbase = b->data;\n   dest = retarray->data;\n \n+\n+  /* Now that everything is set up, we're performing the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+  {\n+    const int m = xcount, n = ycount, k = count, ldc = rystride;\n+    const GFC_REAL_8 one = 1, zero = 0;\n+    const int lda = (axstride == 1) ? aystride : axstride,\n+              ldb = (bxstride == 1) ? bystride : bxstride;\n+\n+    if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+      {\n+        assert (gemm != NULL);\n+        gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m, &n, &k,\n+              &one, abase, &lda, bbase, &ldb, &zero, dest, &ldc, 1, 1);\n+        return;\n+      }\n+  }\n+\n   if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n       const GFC_REAL_8 * restrict bbase_y;"}, {"sha": "ef2f0fb88dc3ffc528e367e2864924380dfa69b8", "filename": "libgfortran/m4/matmul.m4", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0aad3165fd85695548dfebc3d4901b7027cf3d/libgfortran%2Fm4%2Fmatmul.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0aad3165fd85695548dfebc3d4901b7027cf3d/libgfortran%2Fm4%2Fmatmul.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmatmul.m4?ref=5a0aad3165fd85695548dfebc3d4901b7027cf3d", "patch": "@@ -37,6 +37,16 @@ include(iparm.m4)dnl\n \n `#if defined (HAVE_'rtype_name`)'\n \n+/* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n+   passed to us by the front-end, in which case we'll call it for large\n+   matrices.  */\n+\n+typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n+                          const int *, const rtype_name *, const rtype_name *,\n+                          const int *, const rtype_name *, const int *,\n+                          const rtype_name *, rtype_name *, const int *,\n+                          int, int);\n+\n /* The order of loops is different in the case of plain matrix\n    multiplication C=MATMUL(A,B), and in the frequent special case where\n    the argument A is the temporary result of a TRANSPOSE intrinsic:\n@@ -57,18 +67,24 @@ include(iparm.m4)dnl\n        DO I=1,M\n          S = 0\n          DO K=1,COUNT\n-           S = S+A(I,K)+B(K,J)\n+           S = S+A(I,K)*B(K,J)\n          C(I,J) = S\n    ENDIF\n */\n \n+/* If try_blas is set to a nonzero value, then the matmul function will\n+   see if there is a way to perform the matrix multiplication by a call\n+   to the BLAS gemm function.  */\n+\n extern void matmul_`'rtype_code (rtype * const restrict retarray, \n-\trtype * const restrict a, rtype * const restrict b);\n+\trtype * const restrict a, rtype * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm);\n export_proto(matmul_`'rtype_code);\n \n void\n matmul_`'rtype_code (rtype * const restrict retarray, \n-\trtype * const restrict a, rtype * const restrict b)\n+\trtype * const restrict a, rtype * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n {\n   const rtype_name * restrict abase;\n   const rtype_name * restrict bbase;\n@@ -179,6 +195,31 @@ sinclude(`matmul_asm_'rtype_code`.m4')dnl\n   bbase = b->data;\n   dest = retarray->data;\n \n+\n+  /* Now that everything is set up, we're performing the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+  {\n+    const int m = xcount, n = ycount, k = count, ldc = rystride;\n+    const rtype_name one = 1, zero = 0;\n+    const int lda = (axstride == 1) ? aystride : axstride,\n+              ldb = (bxstride == 1) ? bystride : bxstride;\n+\n+    if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+      {\n+        assert (gemm != NULL);\n+        gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m, &n, &k,\n+              &one, abase, &lda, bbase, &ldb, &zero, dest, &ldc, 1, 1);\n+        return;\n+      }\n+  }\n+\n   if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n       const rtype_name * restrict bbase_y;"}]}