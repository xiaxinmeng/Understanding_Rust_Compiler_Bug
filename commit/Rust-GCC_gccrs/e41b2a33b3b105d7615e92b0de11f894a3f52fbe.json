{"sha": "e41b2a33b3b105d7615e92b0de11f894a3f52fbe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQxYjJhMzNiM2IxMDVkNzYxNWU5MmIwZGUxMWY4OTRhM2Y1MmZiZQ==", "commit": {"author": {"name": "Peter Bergner", "email": "bergner@vnet.ibm.com", "date": "2008-01-26T17:18:35Z"}, "committer": {"name": "Peter Bergner", "email": "bergner@gcc.gnu.org", "date": "2008-01-26T17:18:35Z"}, "message": "re PR target/34814 (SDmode function args not passed according to ABI specification)\n\n\tPR target/34814\n\t* doc/tm.texi (TARGET_EXPAND_TO_RTL_HOOK): Document.\n\t(TARGET_INSTANTIATE_DECLS): Likewise.\n\t* target.h (expand_to_rtl_hook): New target hook.\n\t(instantiate_decls): Likewise.\n\t* function.c (instantiate_decl): Make non-static.  Rename to...\n\t(instantiate_decl_rtl): ... this.\n\t(instantiate_expr): Use instantiate_decl_rtl.\n\t(instantiate_decls_1): Likewise.\n\t(instantiate_decls): Likewise.\n\t(instantiate_virtual_regs: Call new instantiate_decls taget hook.\n\t* function.h (instantiate_decl_rtl): Add prototype.\n\t* cfgexpand.c (target.h): New include.\n\t(tree_expand_cfg): Call new expand_to_rtl_hook target hook.\n\t* target-def.h (TARGET_EXPAND_TO_RTL_HOOK): New define.\n\t(TARGET_INSTANTIATE_DECLS): Likewise.\n\t(TARGET_INITIALIZER): New target hooks added.\n\t* config/rs6000/rs6000-protos.h (rs6000_secondary_memory_needed_rtx):\n\tNew prototype.\n\t* config/rs6000/rs6000.c (tree-flow.h): New include.\n\t(machine_function): Add sdmode_stack_slot field.\n\t(rs6000_alloc_sdmode_stack_slot): New function.\n\t(rs6000_instantiate_decls): Likewise.\n\t(rs6000_secondary_memory_needed_rtx): Likewise.\n\t(rs6000_check_sdmode): Likewise.\n\t(TARGET_EXPAND_TO_RTL_HOOK): Target macro defined.\n\t(TARGET_INSTANTIATE_DECLS): Likewise.\n\t(rs6000_hard_regno_mode_ok): Allow SDmode.\n\t(num_insns_constant): Likewise.  Handle _Decimal32 constants.\n\t(rs6000_emit_move): Handle SDmode.\n\t(function_arg_advance): Likewise.\n\t(function_arg): Likewise.\n\t(rs6000_gimplify_va_arg): Likewise.  Add special handling of\n\tSDmode var args for 32-bit compiles.\n\t(rs6000_secondary_reload_class): Handle SDmode.\n\t(rs6000_output_function_epilogue): Likewise.\n\t(rs6000_function_value): Simplify if statement.\n\t(rs6000_libcall_value): Likewise.\n\t* config/rs6000/rs6000.h (SLOW_UNALIGNED_ACCESS): Handle SDmode.\n\t(SECONDARY_MEMORY_NEEDED_RTX): Add define.\n\t* config/rs6000/dfp.md (movsd): New define_expand and splitter.\n\t(movsd_hardfloat): New define_insn.\n\t(movsd_softfloat): Likewise.\n\t(movsd_store): Likewise.\n\t(movsd_load): Likewise.\n\t(extendsddd2): Likewise.\n\t(extendsdtd2): Likewise.\n\t(truncddsd2): Likewise.\n\t(movdd_hardfloat64): Fixup comment.\n\t(UNSPEC_MOVSD_LOAD): New constant.\n\t(UNSPEC_MOVSD_STORE): Likewise.\n\nCo-Authored-By: Janis Johnson <janis187@us.ibm.com>\n\nFrom-SVN: r131869", "tree": {"sha": "de5ed68bd1dcac2783d01a32de9bf0a342283a72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de5ed68bd1dcac2783d01a32de9bf0a342283a72"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e41b2a33b3b105d7615e92b0de11f894a3f52fbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e41b2a33b3b105d7615e92b0de11f894a3f52fbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e41b2a33b3b105d7615e92b0de11f894a3f52fbe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e41b2a33b3b105d7615e92b0de11f894a3f52fbe/comments", "author": {"login": "peter-bergner", "id": 17504345, "node_id": "MDQ6VXNlcjE3NTA0MzQ1", "avatar_url": "https://avatars.githubusercontent.com/u/17504345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peter-bergner", "html_url": "https://github.com/peter-bergner", "followers_url": "https://api.github.com/users/peter-bergner/followers", "following_url": "https://api.github.com/users/peter-bergner/following{/other_user}", "gists_url": "https://api.github.com/users/peter-bergner/gists{/gist_id}", "starred_url": "https://api.github.com/users/peter-bergner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peter-bergner/subscriptions", "organizations_url": "https://api.github.com/users/peter-bergner/orgs", "repos_url": "https://api.github.com/users/peter-bergner/repos", "events_url": "https://api.github.com/users/peter-bergner/events{/privacy}", "received_events_url": "https://api.github.com/users/peter-bergner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6f536f74ed2ea25a598bda90599202712e5fe632", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f536f74ed2ea25a598bda90599202712e5fe632", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f536f74ed2ea25a598bda90599202712e5fe632"}], "stats": {"total": 494, "additions": 429, "deletions": 65}, "files": [{"sha": "6a6e9fc6e4a81089b044cda23e9244c3dd1b7964", "filename": "gcc/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e41b2a33b3b105d7615e92b0de11f894a3f52fbe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e41b2a33b3b105d7615e92b0de11f894a3f52fbe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e41b2a33b3b105d7615e92b0de11f894a3f52fbe", "patch": "@@ -1,3 +1,58 @@\n+2007-01-26  Peter Bergner  <bergner@vnet.ibm.com>\n+\t    Janis Johnson  <janis187@us.ibm.com>\n+\n+\tPR target/34814\n+\t* doc/tm.texi (TARGET_EXPAND_TO_RTL_HOOK): Document.\n+\t(TARGET_INSTANTIATE_DECLS): Likewise.\n+\t* target.h (expand_to_rtl_hook): New target hook.\n+\t(instantiate_decls): Likewise.\n+\t* function.c (instantiate_decl): Make non-static.  Rename to...\n+\t(instantiate_decl_rtl): ... this.\n+\t(instantiate_expr): Use instantiate_decl_rtl.\n+\t(instantiate_decls_1): Likewise.\n+\t(instantiate_decls): Likewise.\n+\t(instantiate_virtual_regs: Call new instantiate_decls taget hook.\n+\t* function.h (instantiate_decl_rtl): Add prototype.\n+\t* cfgexpand.c (target.h): New include.\n+\t(tree_expand_cfg): Call new expand_to_rtl_hook target hook.\n+\t* target-def.h (TARGET_EXPAND_TO_RTL_HOOK): New define.\n+\t(TARGET_INSTANTIATE_DECLS): Likewise.\n+\t(TARGET_INITIALIZER): New target hooks added.\n+\t* config/rs6000/rs6000-protos.h (rs6000_secondary_memory_needed_rtx):\n+\tNew prototype.\n+\t* config/rs6000/rs6000.c (tree-flow.h): New include.\n+\t(machine_function): Add sdmode_stack_slot field.\n+\t(rs6000_alloc_sdmode_stack_slot): New function.\n+\t(rs6000_instantiate_decls): Likewise.\n+\t(rs6000_secondary_memory_needed_rtx): Likewise.\n+\t(rs6000_check_sdmode): Likewise.\n+\t(TARGET_EXPAND_TO_RTL_HOOK): Target macro defined.\n+\t(TARGET_INSTANTIATE_DECLS): Likewise.\n+\t(rs6000_hard_regno_mode_ok): Allow SDmode.\n+\t(num_insns_constant): Likewise.  Handle _Decimal32 constants.\n+\t(rs6000_emit_move): Handle SDmode.\n+\t(function_arg_advance): Likewise.\n+\t(function_arg): Likewise.\n+\t(rs6000_gimplify_va_arg): Likewise.  Add special handling of\n+\tSDmode var args for 32-bit compiles.\n+\t(rs6000_secondary_reload_class): Handle SDmode.\n+\t(rs6000_output_function_epilogue): Likewise.\n+\t(rs6000_function_value): Simplify if statement.\n+\t(rs6000_libcall_value): Likewise.\n+\t* config/rs6000/rs6000.h (SLOW_UNALIGNED_ACCESS): Handle SDmode.\n+\t(SECONDARY_MEMORY_NEEDED_RTX): Add define.\n+\t* config/rs6000/dfp.md (movsd): New define_expand and splitter.\n+\t(movsd_hardfloat): New define_insn.\n+\t(movsd_softfloat): Likewise.\n+\t(movsd_store): Likewise.\n+\t(movsd_load): Likewise.\n+\t(extendsddd2): Likewise.\n+\t(extendsdtd2): Likewise.\n+\t(truncddsd2): Likewise.\n+\t(movdd_hardfloat64): Fixup comment.\n+\t(UNSPEC_MOVSD_LOAD): New constant.\n+\t(UNSPEC_MOVSD_STORE): Likewise.\n+\n 2008-01-26  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/34965"}, {"sha": "d22facbabe3139c4432bdfd4daba0f81b2871904", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e41b2a33b3b105d7615e92b0de11f894a3f52fbe/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e41b2a33b3b105d7615e92b0de11f894a3f52fbe/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=e41b2a33b3b105d7615e92b0de11f894a3f52fbe", "patch": "@@ -40,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"tree-inline.h\"\n #include \"value-prof.h\"\n+#include \"target.h\"\n \n /* Verify that there is exactly single jump instruction since last and attach\n    REG_BR_PROB note specifying probability.\n@@ -1873,6 +1874,8 @@ tree_expand_cfg (void)\n   /* Mark arrays indexed with non-constant indices with TREE_ADDRESSABLE.  */\n   discover_nonconstant_array_refs ();\n \n+  targetm.expand_to_rtl_hook ();\n+\n   /* Expand the variables recorded during gimple lowering.  */\n   expand_used_vars ();\n "}, {"sha": "2d111b8df648825bd812de558689e5c5191cd3fa", "filename": "gcc/config/rs6000/dfp.md", "status": "modified", "additions": 133, "deletions": 1, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e41b2a33b3b105d7615e92b0de11f894a3f52fbe/gcc%2Fconfig%2Frs6000%2Fdfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e41b2a33b3b105d7615e92b0de11f894a3f52fbe/gcc%2Fconfig%2Frs6000%2Fdfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdfp.md?ref=e41b2a33b3b105d7615e92b0de11f894a3f52fbe", "patch": "@@ -20,6 +20,138 @@\n ;; along with GCC; see the file COPYING3.  If not see\n ;; <http://www.gnu.org/licenses/>.\n \n+;;\n+;; UNSPEC usage\n+;;\n+\n+(define_constants\n+  [(UNSPEC_MOVSD_LOAD\t\t400)\n+   (UNSPEC_MOVSD_STORE\t\t401)\n+  ])\n+\n+\n+(define_expand \"movsd\"\n+  [(set (match_operand:SD 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:SD 1 \"any_operand\" \"\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS\"\n+  \"{ rs6000_emit_move (operands[0], operands[1], SDmode); DONE; }\")\n+\n+(define_split\n+  [(set (match_operand:SD 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:SD 1 \"const_double_operand\" \"\"))]\n+  \"reload_completed\n+   && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n+       || (GET_CODE (operands[0]) == SUBREG\n+\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n+\t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n+  [(set (match_dup 2) (match_dup 3))]\n+  \"\n+{\n+  long l;\n+  REAL_VALUE_TYPE rv;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n+  REAL_VALUE_TO_TARGET_DECIMAL32 (rv, l);\n+\n+  if (! TARGET_POWERPC64)\n+    operands[2] = operand_subword (operands[0], 0, 0, SDmode);\n+  else\n+    operands[2] = gen_lowpart (SImode, operands[0]);\n+\n+  operands[3] = gen_int_mode (l, SImode);\n+}\")\n+\n+(define_insn \"movsd_hardfloat\"\n+  [(set (match_operand:SD 0 \"nonimmediate_operand\" \"=r,r,m,f,*c*l,*q,!r,*h,!r,!r\")\n+\t(match_operand:SD 1 \"input_operand\"        \"r,m,r,f,r,r,h,0,G,Fn\"))]\n+  \"(gpc_reg_operand (operands[0], SDmode)\n+   || gpc_reg_operand (operands[1], SDmode))\n+   && (TARGET_HARD_FLOAT && TARGET_FPRS)\"\n+  \"@\n+   mr %0,%1\n+   {l%U1%X1|lwz%U1%X1} %0,%1\n+   {st%U0%X0|stw%U0%X0} %1,%0\n+   fmr %0,%1\n+   mt%0 %1\n+   mt%0 %1\n+   mf%1 %0\n+   {cror 0,0,0|nop}\n+   #\n+   #\"\n+  [(set_attr \"type\" \"*,load,store,fp,mtjmpr,*,mfjmpr,*,*,*\")\n+   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,8\")])\n+\n+(define_insn \"movsd_softfloat\"\n+  [(set (match_operand:SD 0 \"nonimmediate_operand\" \"=r,cl,q,r,r,m,r,r,r,r,r,*h\")\n+\t(match_operand:SD 1 \"input_operand\" \"r,r,r,h,m,r,I,L,R,G,Fn,0\"))]\n+  \"(gpc_reg_operand (operands[0], SDmode)\n+   || gpc_reg_operand (operands[1], SDmode))\n+   && (TARGET_SOFT_FLOAT || !TARGET_FPRS)\"\n+  \"@\n+   mr %0,%1\n+   mt%0 %1\n+   mt%0 %1\n+   mf%1 %0\n+   {l%U1%X1|lwz%U1%X1} %0,%1\n+   {st%U0%X0|stw%U0%X0} %1,%0\n+   {lil|li} %0,%1\n+   {liu|lis} %0,%v1\n+   {cal|la} %0,%a1\n+   #\n+   #\n+   {cror 0,0,0|nop}\"\n+  [(set_attr \"type\" \"*,mtjmpr,*,mfjmpr,load,store,*,*,*,*,*,*\")\n+   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,4,8,4\")])\n+\n+(define_insn \"movsd_store\"\n+  [(set (match_operand:DD 0 \"nonimmediate_operand\" \"=m\")\n+\t(unspec:DD [(match_operand:SD 1 \"input_operand\" \"f\")]\n+\t\t   UNSPEC_MOVSD_STORE))]\n+  \"(gpc_reg_operand (operands[0], DDmode)\n+   || gpc_reg_operand (operands[1], SDmode))\n+   && TARGET_HARD_FLOAT && TARGET_FPRS\"\n+  \"stfd%U0%X0 %1,%0\"\n+  [(set_attr \"type\" \"fpstore\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"movsd_load\"\n+  [(set (match_operand:SD 0 \"nonimmediate_operand\" \"=f\")\n+\t(unspec:SD [(match_operand:DD 1 \"input_operand\" \"m\")]\n+\t\t   UNSPEC_MOVSD_LOAD))]\n+  \"(gpc_reg_operand (operands[0], SDmode)\n+   || gpc_reg_operand (operands[1], DDmode))\n+   && TARGET_HARD_FLOAT && TARGET_FPRS\"\n+  \"lfd%U1%X1 %0,%1\"\n+  [(set_attr \"type\" \"fpload\")\n+   (set_attr \"length\" \"4\")])\n+\n+;; Hardware support for decimal floating point operations.\n+\n+(define_insn \"extendsddd2\"\n+  [(set (match_operand:DD 0 \"gpc_reg_operand\" \"=f\")\n+\t(float_extend:DD (match_operand:SD 1 \"gpc_reg_operand\" \"f\")))]\n+  \"TARGET_DFP\"\n+  \"dctdp %0,%1\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_expand \"extendsdtd2\"\n+  [(set (match_operand:TD 0 \"gpc_reg_operand\" \"=f\")\n+\t(float_extend:TD (match_operand:SD 1 \"gpc_reg_operand\" \"f\")))]\n+  \"TARGET_DFP\"\n+{\n+  rtx tmp = gen_reg_rtx (DDmode);\n+  emit_insn (gen_extendsddd2 (tmp, operands[1]));\n+  emit_insn (gen_extendddtd2 (operands[0], tmp));\n+  DONE;\n+})\n+\n+(define_insn \"truncddsd2\"\n+  [(set (match_operand:SD 0 \"gpc_reg_operand\" \"=f\")\n+\t(float_truncate:SD (match_operand:DD 1 \"gpc_reg_operand\" \"f\")))]\n+  \"TARGET_DFP\"\n+  \"drsp %0,%1\"\n+  [(set_attr \"type\" \"fp\")])\n+\n (define_expand \"negdd2\"\n   [(set (match_operand:DD 0 \"gpc_reg_operand\" \"\")\n \t(neg:DD (match_operand:DD 1 \"gpc_reg_operand\" \"\")))]\n@@ -309,7 +441,7 @@\n    (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,8,12,16,4,4\")])\n \n ; ld/std require word-aligned displacements -> 'Y' constraint.\n-; List Y->r and r->Y before r->r for reload.(define_insn \"*movdd_hardfloat64\"\n+; List Y->r and r->Y before r->r for reload.\n (define_insn \"*movdd_hardfloat64\"\n   [(set (match_operand:DD 0 \"nonimmediate_operand\" \"=Y,r,!r,f,f,m,*c*l,!r,*h,!r,!r,!r\")\n \t(match_operand:DD 1 \"input_operand\" \"r,Y,r,f,m,f,r,h,0,G,H,F\"))]"}, {"sha": "762f784ed698fb296a48cafbc40a1e7ff6083cc7", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e41b2a33b3b105d7615e92b0de11f894a3f52fbe/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e41b2a33b3b105d7615e92b0de11f894a3f52fbe/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=e41b2a33b3b105d7615e92b0de11f894a3f52fbe", "patch": "@@ -103,6 +103,7 @@ extern void rs6000_fatal_bad_address (rtx);\n extern rtx create_TOC_reference (rtx);\n extern void rs6000_split_multireg_move (rtx, rtx);\n extern void rs6000_emit_move (rtx, rtx, enum machine_mode);\n+extern rtx rs6000_secondary_memory_needed_rtx (enum machine_mode);\n extern rtx rs6000_legitimize_address (rtx, rtx, enum machine_mode);\n extern rtx rs6000_legitimize_reload_address (rtx, enum machine_mode,\n \t\t\t\t\t     int, int, int, int *);"}, {"sha": "586c48146684a9dcc468eb9aa5ac818b61f0acf9", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 185, "deletions": 55, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e41b2a33b3b105d7615e92b0de11f894a3f52fbe/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e41b2a33b3b105d7615e92b0de11f894a3f52fbe/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=e41b2a33b3b105d7615e92b0de11f894a3f52fbe", "patch": "@@ -53,6 +53,7 @@\n #include \"cfglayout.h\"\n #include \"sched-int.h\"\n #include \"tree-gimple.h\"\n+#include \"tree-flow.h\"\n #include \"intl.h\"\n #include \"params.h\"\n #include \"tm-constrs.h\"\n@@ -125,6 +126,10 @@ typedef struct machine_function GTY(())\n   /* Offset from virtual_stack_vars_rtx to the start of the ABI_V4\n      varargs save area.  */\n   HOST_WIDE_INT varargs_save_offset;\n+  /* Temporary stack slot to use for SDmode copies.  This slot is\n+     64-bits wide and is allocated early enough so that the offset\n+     does not overflow the 16-bit load/store offset field.  */\n+  rtx sdmode_stack_slot;\n } machine_function;\n \n /* Target cpu type */\n@@ -754,6 +759,8 @@ static void rs6000_elf_encode_section_info (tree, rtx, int)\n      ATTRIBUTE_UNUSED;\n #endif\n static bool rs6000_use_blocks_for_constant_p (enum machine_mode, const_rtx);\n+static void rs6000_alloc_sdmode_stack_slot (void);\n+static void rs6000_instantiate_decls (void);\n #if TARGET_XCOFF\n static void rs6000_xcoff_asm_output_anchor (rtx);\n static void rs6000_xcoff_asm_globalize_label (FILE *, const char *);\n@@ -1221,6 +1228,12 @@ static const char alt_reg_names[][8] =\n #undef TARGET_BUILTIN_RECIPROCAL\n #define TARGET_BUILTIN_RECIPROCAL rs6000_builtin_reciprocal\n \n+#undef TARGET_EXPAND_TO_RTL_HOOK\n+#define TARGET_EXPAND_TO_RTL_HOOK rs6000_alloc_sdmode_stack_slot\n+\n+#undef TARGET_INSTANTIATE_DECLS\n+#define TARGET_INSTANTIATE_DECLS rs6000_instantiate_decls\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n \n@@ -1240,7 +1253,6 @@ rs6000_hard_regno_mode_ok (int regno, enum machine_mode mode)\n     return\n       ((SCALAR_FLOAT_MODE_P (mode)\n        && (mode != TDmode || (regno % 2) == 0)\n-       && mode != SDmode\n        && FP_REGNO_P (regno + HARD_REGNO_NREGS (regno, mode) - 1))\n       || (GET_MODE_CLASS (mode) == MODE_INT\n \t  && GET_MODE_SIZE (mode) == UNITS_PER_FP_WORD)\n@@ -2460,13 +2472,16 @@ num_insns_constant (rtx op, enum machine_mode mode)\n \treturn num_insns_constant_wide (INTVAL (op));\n \n       case CONST_DOUBLE:\n-\tif (mode == SFmode)\n+\tif (mode == SFmode || mode == SDmode)\n \t  {\n \t    long l;\n \t    REAL_VALUE_TYPE rv;\n \n \t    REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n-\t    REAL_VALUE_TO_TARGET_SINGLE (rv, l);\n+\t    if (DECIMAL_FLOAT_MODE_P (mode))\n+\t      REAL_VALUE_TO_TARGET_DECIMAL32 (rv, l);\n+\t    else\n+\t      REAL_VALUE_TO_TARGET_SINGLE (rv, l);\n \t    return num_insns_constant_wide ((HOST_WIDE_INT) l);\n \t  }\n \n@@ -4697,6 +4712,55 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n       return;\n     }\n \n+  if (reload_in_progress && cfun->machine->sdmode_stack_slot != NULL_RTX)\n+    cfun->machine->sdmode_stack_slot =\n+      eliminate_regs (cfun->machine->sdmode_stack_slot, VOIDmode, NULL_RTX);\n+\n+  if (reload_in_progress\n+      && mode == SDmode\n+      && MEM_P (operands[0])\n+      && rtx_equal_p (operands[0], cfun->machine->sdmode_stack_slot)\n+      && REG_P (operands[1]))\n+    {\n+      if (FP_REGNO_P (REGNO (operands[1])))\n+\t{\n+\t  rtx mem = adjust_address_nv (operands[0], DDmode, 0);\n+\t  mem = eliminate_regs (mem, VOIDmode, NULL_RTX);\n+\t  emit_insn (gen_movsd_store (mem, operands[1]));\n+\t}\n+      else if (INT_REGNO_P (REGNO (operands[1])))\n+\t{\n+\t  rtx mem = adjust_address_nv (operands[0], mode, 4);\n+\t  mem = eliminate_regs (mem, VOIDmode, NULL_RTX);\n+\t  emit_insn (gen_movsd_hardfloat (mem, operands[1]));\n+\t}\n+      else\n+\tgcc_unreachable();\n+      return;\n+    }\n+  if (reload_in_progress\n+      && mode == SDmode\n+      && REG_P (operands[0])\n+      && MEM_P (operands[1])\n+      && rtx_equal_p (operands[1], cfun->machine->sdmode_stack_slot))\n+    {\n+      if (FP_REGNO_P (REGNO (operands[0])))\n+\t{\n+\t  rtx mem = adjust_address_nv (operands[1], DDmode, 0);\n+\t  mem = eliminate_regs (mem, VOIDmode, NULL_RTX);\n+\t  emit_insn (gen_movsd_load (operands[0], mem));\n+\t}\n+      else if (INT_REGNO_P (REGNO (operands[0])))\n+\t{\n+\t  rtx mem = adjust_address_nv (operands[1], mode, 4);\n+\t  mem = eliminate_regs (mem, VOIDmode, NULL_RTX);\n+\t  emit_insn (gen_movsd_hardfloat (operands[0], mem));\n+\t}\n+      else\n+\tgcc_unreachable();\n+      return;\n+    }\n+\n   /* FIXME:  In the long term, this switch statement should go away\n      and be replaced by a sequence of tests based on things like\n      mode == Pmode.  */\n@@ -4717,6 +4781,7 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n     case DFmode:\n     case DDmode:\n     case SFmode:\n+    case SDmode:\n       if (CONSTANT_P (operands[1])\n \t  && ! easy_fp_constant (operands[1], mode))\n \toperands[1] = force_const_mem (mode, operands[1]);\n@@ -4929,7 +4994,6 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n /* Nonzero if we can use a floating-point register to pass this arg.  */\n #define USE_FP_FOR_ARG_P(CUM,MODE,TYPE)\t\t\\\n   (SCALAR_FLOAT_MODE_P (MODE)\t\t\t\\\n-   && (MODE) != SDmode\t\t\t\t\\\n    && (CUM)->fregno <= FP_ARG_MAX_REG\t\t\\\n    && TARGET_HARD_FLOAT && TARGET_FPRS)\n \n@@ -5409,7 +5473,7 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n     {\n       if (TARGET_HARD_FLOAT && TARGET_FPRS\n \t  && (mode == SFmode || mode == DFmode\n-\t      || mode == DDmode || mode == TDmode\n+\t      || mode == SDmode || mode == DDmode || mode == TDmode\n \t      || (mode == TFmode && !TARGET_IEEEQUAD)))\n \t{\n \t  /* _Decimal128 must use an even/odd register pair.  This assumes\n@@ -5476,7 +5540,6 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       cum->words = align_words + n_words;\n \n       if (SCALAR_FLOAT_MODE_P (mode)\n-\t  && mode != SDmode\n \t  && TARGET_HARD_FLOAT && TARGET_FPRS)\n \t{\n \t  /* _Decimal128 must be passed in an even/odd float register pair.\n@@ -5978,7 +6041,7 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       if (TARGET_HARD_FLOAT && TARGET_FPRS\n \t  && (mode == SFmode || mode == DFmode\n \t      || (mode == TFmode && !TARGET_IEEEQUAD)\n-\t      || mode == DDmode || mode == TDmode))\n+\t      || mode == SDmode || mode == DDmode || mode == TDmode))\n \t{\n \t  /* _Decimal128 must use an even/odd register pair.  This assumes\n \t     that the register number is odd when fregno is odd.  */\n@@ -6652,6 +6715,7 @@ rs6000_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n       && (TYPE_MODE (type) == SFmode\n \t  || TYPE_MODE (type) == DFmode\n \t  || TYPE_MODE (type) == TFmode\n+\t  || TYPE_MODE (type) == SDmode\n \t  || TYPE_MODE (type) == DDmode\n \t  || TYPE_MODE (type) == TDmode))\n     {\n@@ -6660,7 +6724,7 @@ rs6000_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n       n_reg = (size + 7) / 8;\n       sav_ofs = 8*4;\n       sav_scale = 8;\n-      if (TYPE_MODE (type) != SFmode)\n+      if (TYPE_MODE (type) != SFmode && TYPE_MODE (type) != SDmode)\n \talign = 8;\n     }\n   else\n@@ -6724,6 +6788,11 @@ rs6000_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n       u = build2 (MULT_EXPR, sizetype, u, size_int (sav_scale));\n       t = build2 (POINTER_PLUS_EXPR, ptr_type_node, t, u);\n \n+      /* _Decimal32 varargs are located in the second word of the 64-bit\n+\t FP register for 32-bit binaries.  */\n+      if (!TARGET_POWERPC64 && TYPE_MODE (type) == SDmode)\n+\tt = build2 (POINTER_PLUS_EXPR, TREE_TYPE (t), t, size_int (size));\n+\n       t = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, t);\n       gimplify_and_add (t, pre_p);\n \n@@ -11055,6 +11124,106 @@ mems_ok_for_quad_peep (rtx mem1, rtx mem2)\n   return 1;\n }\n \f\n+\n+rtx\n+rs6000_secondary_memory_needed_rtx (enum machine_mode mode)\n+{\n+  static bool eliminated = false;\n+  if (mode != SDmode)\n+    return assign_stack_local (mode, GET_MODE_SIZE (mode), 0);\n+  else\n+    {\n+      rtx mem = cfun->machine->sdmode_stack_slot;\n+      gcc_assert (mem != NULL_RTX);\n+\n+      if (!eliminated)\n+\t{\n+\t  mem = eliminate_regs (mem, VOIDmode, NULL_RTX);\n+\t  cfun->machine->sdmode_stack_slot = mem;\n+\t  eliminated = true;\n+\t}\n+      return mem;\n+    }\n+}\n+\n+static tree\n+rs6000_check_sdmode (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n+{\n+  /* Don't walk into types.  */\n+  if (*tp == NULL_TREE || *tp == error_mark_node || TYPE_P (*tp))\n+    {\n+      *walk_subtrees = 0;\n+      return NULL_TREE;\n+    }\n+\n+  switch (TREE_CODE (*tp))\n+    {\n+    case VAR_DECL:\n+    case PARM_DECL:\n+    case FIELD_DECL:\n+    case RESULT_DECL:\n+    case REAL_CST:\n+      if (TYPE_MODE (TREE_TYPE (*tp)) == SDmode)\n+\treturn *tp;\n+      break;\n+    default:\n+      break;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+\n+/* Allocate a 64-bit stack slot to be used for copying SDmode\n+   values through if this function has any SDmode references.  */\n+\n+static void\n+rs6000_alloc_sdmode_stack_slot (void)\n+{\n+  tree t;\n+  basic_block bb;\n+  block_stmt_iterator bsi;\n+\n+  gcc_assert (cfun->machine->sdmode_stack_slot == NULL_RTX);\n+\n+  FOR_EACH_BB (bb)\n+    for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+      {\n+\ttree ret = walk_tree_without_duplicates (bsi_stmt_ptr (bsi),\n+\t\t\t\t\t\t rs6000_check_sdmode, NULL);\n+\tif (ret)\n+\t  {\n+\t    rtx stack = assign_stack_local (DDmode, GET_MODE_SIZE (DDmode), 0);\n+\t    cfun->machine->sdmode_stack_slot = adjust_address_nv (stack,\n+\t\t\t\t\t\t\t\t  SDmode, 0);\n+\t    return;\n+\t  }\n+      }\n+\n+  /* Check for any SDmode parameters of the function.  */\n+  for (t = DECL_ARGUMENTS (cfun->decl); t; t = TREE_CHAIN (t))\n+    {\n+      if (TREE_TYPE (t) == error_mark_node)\n+\tcontinue;\n+\n+      if (TYPE_MODE (TREE_TYPE (t)) == SDmode\n+\t  || TYPE_MODE (DECL_ARG_TYPE (t)) == SDmode)\n+\t{\n+\t  rtx stack = assign_stack_local (DDmode, GET_MODE_SIZE (DDmode), 0);\n+\t  cfun->machine->sdmode_stack_slot = adjust_address_nv (stack,\n+\t\t\t\t\t\t\t\tSDmode, 0);\n+\t  return;\n+\t}\n+    }\n+}\n+\n+static void\n+rs6000_instantiate_decls (void)\n+{\n+  if (cfun->machine->sdmode_stack_slot != NULL_RTX)\n+    instantiate_decl_rtl (cfun->machine->sdmode_stack_slot);\n+}\n+\n /* Return the register class of a scratch register needed to copy IN into\n    or out of a register in CLASS in MODE.  If it can be done directly,\n    NO_REGS is returned.  */\n@@ -11115,7 +11284,7 @@ rs6000_secondary_reload_class (enum reg_class class,\n   /* Constants, memory, and FP registers can go into FP registers.  */\n   if ((regno == -1 || FP_REGNO_P (regno))\n       && (class == FLOAT_REGS || class == NON_SPECIAL_REGS))\n-    return NO_REGS;\n+    return (mode != SDmode) ? NO_REGS : GENERAL_REGS;\n \n   /* Memory, and AltiVec registers can go into AltiVec registers.  */\n   if ((regno == -1 || ALTIVEC_REGNO_P (regno))\n@@ -16727,6 +16896,7 @@ rs6000_output_function_epilogue (FILE *file,\n \t\t      switch (mode)\n \t\t\t{\n \t\t\tcase SFmode:\n+\t\t\tcase SDmode:\n \t\t\t  bits = 0x2;\n \t\t\t  break;\n \n@@ -21513,29 +21683,9 @@ rs6000_function_value (const_tree valtype, const_tree func ATTRIBUTE_UNUSED)\n       || POINTER_TYPE_P (valtype))\n     mode = TARGET_32BIT ? SImode : DImode;\n \n-  if (DECIMAL_FLOAT_MODE_P (mode))\n-    {\n-      if (TARGET_HARD_FLOAT && TARGET_FPRS)\n-\t{\n-\t  switch (mode)\n-\t    {\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    case SDmode:\n-\t      regno = GP_ARG_RETURN;\n-\t      break;\n-\t    case DDmode:\n-\t      regno = FP_ARG_RETURN;\n-\t      break;\n-\t    case TDmode:\n-\t      /* Use f2:f3 specified by the ABI.  */\n-\t      regno = FP_ARG_RETURN + 1;\n-\t      break;\n-\t    }\n-\t}\n-      else\n-\tregno = GP_ARG_RETURN;\n-    }\n+  if (DECIMAL_FLOAT_MODE_P (mode) && TARGET_HARD_FLOAT && TARGET_FPRS)\n+    /* _Decimal128 must use an even/odd register pair.  */\n+    regno = (mode == TDmode) ? FP_ARG_RETURN + 1 : FP_ARG_RETURN;\n   else if (SCALAR_FLOAT_TYPE_P (valtype) && TARGET_HARD_FLOAT && TARGET_FPRS)\n     regno = FP_ARG_RETURN;\n   else if (TREE_CODE (valtype) == COMPLEX_TYPE\n@@ -21576,29 +21726,9 @@ rs6000_libcall_value (enum machine_mode mode)\n \t\t\t\t      GEN_INT (4))));\n     }\n \n-  if (DECIMAL_FLOAT_MODE_P (mode))\n-    {\n-      if (TARGET_HARD_FLOAT && TARGET_FPRS)\n-\t{\n-\t  switch (mode)\n-\t    {\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    case SDmode:\n-\t      regno = GP_ARG_RETURN;\n-\t      break;\n-\t    case DDmode:\n-\t      regno = FP_ARG_RETURN;\n-\t      break;\n-\t    case TDmode:\n-\t      /* Use f2:f3 specified by the ABI.  */\n-\t      regno = FP_ARG_RETURN + 1;\n-\t      break;\n-\t    }\n-\t}\n-      else\n-\tregno = GP_ARG_RETURN;\n-    }\n+  if (DECIMAL_FLOAT_MODE_P (mode) && TARGET_HARD_FLOAT && TARGET_FPRS)\n+    /* _Decimal128 must use an even/odd register pair.  */\n+    regno = (mode == TDmode) ? FP_ARG_RETURN + 1 : FP_ARG_RETURN;\n   else if (SCALAR_FLOAT_MODE_P (mode)\n \t   && TARGET_HARD_FLOAT && TARGET_FPRS)\n     regno = FP_ARG_RETURN;"}, {"sha": "6a64eae3dd90502c056ecc1b4eca1ca45f180dd1", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e41b2a33b3b105d7615e92b0de11f894a3f52fbe/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e41b2a33b3b105d7615e92b0de11f894a3f52fbe/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=e41b2a33b3b105d7615e92b0de11f894a3f52fbe", "patch": "@@ -622,7 +622,7 @@ extern enum rs6000_nop_insertion rs6000_sched_insert_nops;\n #define SLOW_UNALIGNED_ACCESS(MODE, ALIGN)\t\t\t\t\\\n   (STRICT_ALIGNMENT\t\t\t\t\t\t\t\\\n    || (((MODE) == SFmode || (MODE) == DFmode || (MODE) == TFmode\t\\\n-\t|| (MODE) == DDmode || (MODE) == TDmode\t\t\t\t\\\n+\t|| (MODE) == SDmode || (MODE) == DDmode || (MODE) == TDmode\t\\\n \t|| (MODE) == DImode)\t\t\t\t\t\t\\\n        && (ALIGN) < 32))\n \f\n@@ -1173,6 +1173,13 @@ enum reg_class\n \t\t\t   || (CLASS1) == ALTIVEC_REGS\t\t\t\\\n \t\t\t   || (CLASS2) == ALTIVEC_REGS))\n \n+/* For cpus that cannot load/store SDmode values from the 64-bit\n+   FP registers without using a full 64-bit load/store, we need\n+   to allocate a full 64-bit stack slot for them.  */\n+\n+#define SECONDARY_MEMORY_NEEDED_RTX(MODE) \\\n+  rs6000_secondary_memory_needed_rtx (MODE)\n+\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.\n "}, {"sha": "74aa90c251f5f1138e1f6e8b4f1d9e6ddd005261", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e41b2a33b3b105d7615e92b0de11f894a3f52fbe/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e41b2a33b3b105d7615e92b0de11f894a3f52fbe/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=e41b2a33b3b105d7615e92b0de11f894a3f52fbe", "patch": "@@ -1502,6 +1502,20 @@ Returns true if the target supports decimal floating point.\n Returns true if the target supports fixed-point arithmetic.\n @end deftypefn\n \n+@deftypefn {Target Hook} void TARGET_EXPAND_TO_RTL_HOOK (void)\n+This hook is called just before expansion into rtl, allowing the target\n+to perform additional initializations or analysis before the expansion.\n+For example, the rs6000 port uses it to allocate a scratch stack slot\n+for use in copying SDmode values between memory and floating point\n+registers whenever the function being expanded has any SDmode\n+usage.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_INSTANTIATE_DECLS (void)\n+This hook allows the backend to perform additional instantiations on rtl\n+that are not actually in any insns yet, but will be later.\n+@end deftypefn\n+\n @deftypefn {Target Hook} {const char *} TARGET_MANGLE_TYPE (tree @var{type})\n If your target defines any fundamental types, or any types your target\n uses should be mangled differently from the default, define this hook"}, {"sha": "401bb21bac672a5e89f955c59c992ed6b2fbe05a", "filename": "gcc/function.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e41b2a33b3b105d7615e92b0de11f894a3f52fbe/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e41b2a33b3b105d7615e92b0de11f894a3f52fbe/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=e41b2a33b3b105d7615e92b0de11f894a3f52fbe", "patch": "@@ -1568,8 +1568,8 @@ instantiate_virtual_regs_in_insn (rtx insn)\n /* Subroutine of instantiate_decls.  Given RTL representing a decl,\n    do any instantiation required.  */\n \n-static void\n-instantiate_decl (rtx x)\n+void\n+instantiate_decl_rtl (rtx x)\n {\n   rtx addr;\n \n@@ -1579,8 +1579,8 @@ instantiate_decl (rtx x)\n   /* If this is a CONCAT, recurse for the pieces.  */\n   if (GET_CODE (x) == CONCAT)\n     {\n-      instantiate_decl (XEXP (x, 0));\n-      instantiate_decl (XEXP (x, 1));\n+      instantiate_decl_rtl (XEXP (x, 0));\n+      instantiate_decl_rtl (XEXP (x, 1));\n       return;\n     }\n \n@@ -1610,7 +1610,7 @@ instantiate_expr (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n     {\n       *walk_subtrees = 0;\n       if (DECL_P (t) && DECL_RTL_SET_P (t))\n-\tinstantiate_decl (DECL_RTL (t));\n+\tinstantiate_decl_rtl (DECL_RTL (t));\n     }\n   return NULL;\n }\n@@ -1626,7 +1626,7 @@ instantiate_decls_1 (tree let)\n   for (t = BLOCK_VARS (let); t; t = TREE_CHAIN (t))\n     {\n       if (DECL_RTL_SET_P (t))\n-\tinstantiate_decl (DECL_RTL (t));\n+\tinstantiate_decl_rtl (DECL_RTL (t));\n       if (TREE_CODE (t) == VAR_DECL && DECL_HAS_VALUE_EXPR_P (t))\n \t{\n \t  tree v = DECL_VALUE_EXPR (t);\n@@ -1650,8 +1650,8 @@ instantiate_decls (tree fndecl)\n   /* Process all parameters of the function.  */\n   for (decl = DECL_ARGUMENTS (fndecl); decl; decl = TREE_CHAIN (decl))\n     {\n-      instantiate_decl (DECL_RTL (decl));\n-      instantiate_decl (DECL_INCOMING_RTL (decl));\n+      instantiate_decl_rtl (DECL_RTL (decl));\n+      instantiate_decl_rtl (DECL_INCOMING_RTL (decl));\n       if (DECL_HAS_VALUE_EXPR_P (decl))\n \t{\n \t  tree v = DECL_VALUE_EXPR (decl);\n@@ -1715,6 +1715,8 @@ instantiate_virtual_regs (void)\n   /* Instantiate the virtual registers in the DECLs for debugging purposes.  */\n   instantiate_decls (current_function_decl);\n \n+  targetm.instantiate_decls ();\n+\n   /* Indicate that, from now on, assign_stack_local should use\n      frame_pointer_rtx.  */\n   virtuals_instantiated = 1;"}, {"sha": "fbaa17d0d478284c8989a85f69ad2bfe67e89532", "filename": "gcc/function.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e41b2a33b3b105d7615e92b0de11f894a3f52fbe/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e41b2a33b3b105d7615e92b0de11f894a3f52fbe/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=e41b2a33b3b105d7615e92b0de11f894a3f52fbe", "patch": "@@ -491,6 +491,7 @@ extern int trampolines_created;\n extern void set_cfun (struct function *new_cfun);\n extern void push_cfun (struct function *new_cfun);\n extern void pop_cfun (void);\n+extern void instantiate_decl_rtl (rtx x);\n \n /* For backward compatibility... eventually these should all go away.  */\n #define current_function_pops_args (cfun->pops_args)"}, {"sha": "118e9791b195e8fd7335acc838e6d2db022a5550", "filename": "gcc/target-def.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e41b2a33b3b105d7615e92b0de11f894a3f52fbe/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e41b2a33b3b105d7615e92b0de11f894a3f52fbe/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=e41b2a33b3b105d7615e92b0de11f894a3f52fbe", "patch": "@@ -604,6 +604,14 @@\n #define TARGET_SECONDARY_RELOAD default_secondary_reload\n #endif\n \n+#ifndef TARGET_EXPAND_TO_RTL_HOOK\n+#define TARGET_EXPAND_TO_RTL_HOOK hook_void_void\n+#endif\n+\n+#ifndef TARGET_INSTANTIATE_DECLS\n+#define TARGET_INSTANTIATE_DECLS hook_void_void\n+#endif\n+\n /* C specific.  */\n #ifndef TARGET_C_MODE_FOR_SUFFIX\n #define TARGET_C_MODE_FOR_SUFFIX default_mode_for_suffix\n@@ -771,6 +779,8 @@\n   TARGET_INVALID_UNARY_OP,\t\t\t\\\n   TARGET_INVALID_BINARY_OP,\t\t\t\\\n   TARGET_SECONDARY_RELOAD,\t\t\t\\\n+  TARGET_EXPAND_TO_RTL_HOOK,\t\t\t\\\n+  TARGET_INSTANTIATE_DECLS,\t\t\t\\\n   TARGET_C,\t\t\t\t\t\\\n   TARGET_CXX,\t\t\t\t\t\\\n   TARGET_EXTRA_LIVE_ON_ENTRY,\t\t\t\\"}, {"sha": "128a0292a15a0fa67b40d7a7d61dcd87c09b2bf6", "filename": "gcc/target.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e41b2a33b3b105d7615e92b0de11f894a3f52fbe/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e41b2a33b3b105d7615e92b0de11f894a3f52fbe/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=e41b2a33b3b105d7615e92b0de11f894a3f52fbe", "patch": "@@ -849,6 +849,15 @@ struct gcc_target\n \t\t\t\t      enum machine_mode,\n \t\t\t\t      struct secondary_reload_info *);\n \n+  /* This target hook allows the backend to perform additional\n+     processing while initializing for variable expansion.  */\n+  void (* expand_to_rtl_hook) (void);\n+\n+  /* This target hook allows the backend to perform additional\n+     instantiations on rtx that are not actually in insns yet,\n+     but will be later.  */\n+  void (* instantiate_decls) (void);\n+\n   /* Functions specific to the C family of frontends.  */\n   struct c {\n     /* Return machine mode for non-standard suffix"}]}