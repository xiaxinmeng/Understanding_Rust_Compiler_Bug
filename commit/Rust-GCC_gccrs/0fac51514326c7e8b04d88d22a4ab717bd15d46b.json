{"sha": "0fac51514326c7e8b04d88d22a4ab717bd15d46b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZhYzUxNTE0MzI2YzdlOGIwNGQ4OGQyMmE0YWI3MTdiZDE1ZDQ2Yg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2009-11-26T02:39:42Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2009-11-26T02:39:42Z"}, "message": "i386-builtin-types.awk (DEF_VECTOR_TYPE): Allow an optional 3rd argument to define the mode.\n\n\t* config/i386/i386-builtin-types.awk (DEF_VECTOR_TYPE): Allow an\n\toptional 3rd argument to define the mode.\n\t* config/i386/i386-builtin-types.def (UQI, UHI, USI, UDI): New.\n\t(V2UDI, V4USI, V8UHI, V16UQI): New.\n\t(V4SF_FTYPE_V4SF_V4SF_V4SI, V2UDI_FTYPE_V2UDI_V2UDI_V2UDI,\n\tV4USI_FTYPE_V4USI_V4USI_V4USI, V8UHI_FTYPE_V8UHI_V8UHI_V8UHI,\n\tV16UQI_FTYPE_V16UQI_V16UQI_V16UQI): New.\n\t* config/i386/i386-modes.def: Rearrange for double-wide AVX.\n\t* config/i386/i386-protos.h (ix86_expand_vec_extract_even_odd): New.\n\t* config/i386/i386.c (IX86_BUILTIN_VEC_PERM_*): New.\n\t(bdesc_args): Add the builtin definitions to match.\n\t(ix86_expand_builtin): Expand them.\n\t(ix86_builtin_vectorization_cost): Rename from\n\tx86_builtin_vectorization_cost.\n\t(ix86_vectorize_builtin_vec_perm, struct expand_vec_perm_d,\n\tdoublesize_vector_mode, expand_vselect, expand_vselect_vconcat,\n\texpand_vec_perm_blend, expand_vec_perm_vpermil,\n\texpand_vec_perm_pshufb, expand_vec_perm_1,\n\texpand_vec_perm_pshuflw_pshufhw, expand_vec_perm_palignr,\n\texpand_vec_perm_interleave2, expand_vec_perm_pshufb2,\n\texpand_vec_perm_even_odd_1, expand_vec_perm_even_odd,\n\tix86_expand_vec_perm_builtin_1, extract_vec_perm_cst,\n\tix86_expand_vec_perm_builtin, ix86_vectorize_builtin_vec_perm_ok,\n\tix86_expand_vec_extract_even_odd, TARGET_VECTORIZE_BUILTIN_VEC_PERM,\n\tTARGET_VECTORIZE_BUILTIN_VEC_PERM_OK): New.\n\t* sse.md (SSEMODE_EO): New.\n\t(vec_extract_even<mode>): Use SSEMODE_EO and\n\tix86_expand_vec_extract_even_odd.\n\t(vec_extract_odd<mode>): Likewise.\n\t(mulv16qi3, vec_pack_trunc_v8hi, vec_pack_trunc_v4si,\n\tvec_pack_trunc_v2di): Use ix86_expand_vec_extract_even_odd.\n\ntestsuite/\n\t* gcc.dg/vect/slp-21.c: Succeed with vect_extract_even_odd too.\n\n\t* lib/target-supports.exp\n\t(check_effective_target_vect_extract_even_odd): Add x86.\n\n\t* gcc.target/i386/isa-check.h: New.\n\t* gcc.target/i386/vperm-2-2.inc, gcc.target/i386/vperm-4-1.inc,\n\tgcc.target/i386/vperm-4-2.inc, gcc.target/i386/vperm-v2df.c,\n\tgcc.target/i386/vperm-v2di.c, gcc.target/i386/vperm-v4sf-1.c,\n\tgcc.target/i386/vperm-v4sf-2.c, gcc.target/i386/vperm-v4si-1.c,\n\tgcc.target/i386/vperm-v4si-2.c, gcc.target/i386/vperm-v4si-2x.c,\n\tgcc.target/i386/vperm.pl: New files.\n\nFrom-SVN: r154667", "tree": {"sha": "18af8f6ccd41df4d0b36a54e7ef14f7def7b2c94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18af8f6ccd41df4d0b36a54e7ef14f7def7b2c94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fac51514326c7e8b04d88d22a4ab717bd15d46b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fac51514326c7e8b04d88d22a4ab717bd15d46b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fac51514326c7e8b04d88d22a4ab717bd15d46b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fac51514326c7e8b04d88d22a4ab717bd15d46b/comments", "author": null, "committer": null, "parents": [{"sha": "dac9d53aef4ce1173e00cfbfee0bb5dcb04f05d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dac9d53aef4ce1173e00cfbfee0bb5dcb04f05d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dac9d53aef4ce1173e00cfbfee0bb5dcb04f05d0"}], "stats": {"total": 6369, "additions": 6204, "deletions": 165}, "files": [{"sha": "e57f78780372da642d4e14b9cdca1a9b53a4392d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0fac51514326c7e8b04d88d22a4ab717bd15d46b", "patch": "@@ -1,3 +1,37 @@\n+2009-11-25  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/i386/i386-builtin-types.awk (DEF_VECTOR_TYPE): Allow an\n+\toptional 3rd argument to define the mode.\n+\t* config/i386/i386-builtin-types.def (UQI, UHI, USI, UDI): New.\n+\t(V2UDI, V4USI, V8UHI, V16UQI): New.\n+\t(V4SF_FTYPE_V4SF_V4SF_V4SI, V2UDI_FTYPE_V2UDI_V2UDI_V2UDI,\n+\tV4USI_FTYPE_V4USI_V4USI_V4USI, V8UHI_FTYPE_V8UHI_V8UHI_V8UHI,\n+\tV16UQI_FTYPE_V16UQI_V16UQI_V16UQI): New.\n+\t* config/i386/i386-modes.def: Rearrange for double-wide AVX.\n+\t* config/i386/i386-protos.h (ix86_expand_vec_extract_even_odd): New.\n+\t* config/i386/i386.c (IX86_BUILTIN_VEC_PERM_*): New.\n+\t(bdesc_args): Add the builtin definitions to match.\n+\t(ix86_expand_builtin): Expand them.\n+\t(ix86_builtin_vectorization_cost): Rename from\n+\tx86_builtin_vectorization_cost.\n+\t(ix86_vectorize_builtin_vec_perm, struct expand_vec_perm_d,\n+\tdoublesize_vector_mode, expand_vselect, expand_vselect_vconcat,\n+\texpand_vec_perm_blend, expand_vec_perm_vpermil,\n+\texpand_vec_perm_pshufb, expand_vec_perm_1,\n+\texpand_vec_perm_pshuflw_pshufhw, expand_vec_perm_palignr,\n+\texpand_vec_perm_interleave2, expand_vec_perm_pshufb2,\n+\texpand_vec_perm_even_odd_1, expand_vec_perm_even_odd,\n+\tix86_expand_vec_perm_builtin_1, extract_vec_perm_cst,\n+\tix86_expand_vec_perm_builtin, ix86_vectorize_builtin_vec_perm_ok,\n+\tix86_expand_vec_extract_even_odd, TARGET_VECTORIZE_BUILTIN_VEC_PERM,\n+\tTARGET_VECTORIZE_BUILTIN_VEC_PERM_OK): New.\n+\t* sse.md (SSEMODE_EO): New.\n+\t(vec_extract_even<mode>): Use SSEMODE_EO and\n+\tix86_expand_vec_extract_even_odd.\n+\t(vec_extract_odd<mode>): Likewise.\n+\t(mulv16qi3, vec_pack_trunc_v8hi, vec_pack_trunc_v4si,\n+\tvec_pack_trunc_v2di): Use ix86_expand_vec_extract_even_odd.\n+\n 2009-11-25  Richard Henderson  <rth@redhat.com>\n \n \t* target.h (targetm.vectorize.builtin_vec_perm_ok): New."}, {"sha": "7b016f44c21c3fdb04efb1e1e109e9b84064acc3", "filename": "gcc/config/i386/i386-builtin-types.awk", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.awk?ref=0fac51514326c7e8b04d88d22a4ab717bd15d46b", "patch": "@@ -69,11 +69,12 @@ $1 == \"DEF_PRIMITIVE_TYPE\" {\n }\n \n $1 == \"DEF_VECTOR_TYPE\" {\n-    if (NF == 4) {\n+    if (NF == 4 || NF == 5) {\n \tcheck_type($3)\n \ttype_hash[$2] = 1\n-\tvect_mode[vect_defs] = $2\n+\tvect_name[vect_defs] = $2\n \tvect_base[vect_defs] = $3\n+\tvect_mode[vect_defs] = (NF == 5 ? $4 : $2)\n \tvect_defs++\n     } else\n \tdo_error(\"DEF_VECTOR_TYPE expected 2 arguments\")\n@@ -152,8 +153,8 @@ END {\n \tprint \"  IX86_BT_\" prim_name[i] \",\"\n     print \"  IX86_BT_LAST_PRIM = IX86_BT_\" prim_name[i-1] \",\"\n     for (i = 0; i < vect_defs; ++i)\n-\tprint \"  IX86_BT_\" vect_mode[i] \",\"\n-    print \"  IX86_BT_LAST_VECT = IX86_BT_\" vect_mode[i-1] \",\"\n+\tprint \"  IX86_BT_\" vect_name[i] \",\"\n+    print \"  IX86_BT_LAST_VECT = IX86_BT_\" vect_name[i-1] \",\"\n     for (i = 0; i < ptr_defs; ++i)\n \tprint \"  IX86_BT_\" ptr_name[i] \",\"\n     print \"  IX86_BT_LAST_PTR = IX86_BT_\" ptr_name[i-1] \",\""}, {"sha": "9f45a13cc315355f118dafd9dd1422a513173424", "filename": "gcc/config/i386/i386-builtin-types.def", "status": "modified", "additions": 43, "deletions": 15, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.def?ref=0fac51514326c7e8b04d88d22a4ab717bd15d46b", "patch": "@@ -10,12 +10,12 @@\n #   At present, that's all that's required; revisit if it turns out\n #   that we need more than that.\n #\n-# DEF_VECTOR_TYPE (ENUM, TYPE)\n+# DEF_VECTOR_TYPE (ENUM, TYPE [, MODE])\n #\n-#  This describes a vector type.  ENUM doubles as both the identifier\n-#  to define in the enumeration as well as the mode of the vector; TYPE is\n-#  the enumeral for the inner type which should of course name a type of\n-#  the proper inner mode.\n+#  This describes a vector type.  ENUM is an identifier as above.\n+#  TYPE is the enumeral for the inner type which should of course\n+#  name a type of the proper inner mode.  If present, MODE is the\n+#  machine mode, else the machine mode should be the same as ENUM.\n #\n # DEF_POINTER_TYPE (ENUM, TYPE [, CONST])\n #\n@@ -40,10 +40,22 @@\n DEF_PRIMITIVE_TYPE (VOID, void_type_node)\n DEF_PRIMITIVE_TYPE (CHAR, char_type_node)\n DEF_PRIMITIVE_TYPE (UCHAR, unsigned_char_type_node)\n-DEF_PRIMITIVE_TYPE (QI, intQI_type_node)\n+# ??? Logically this should be intQI_type_node, but that maps to \"signed char\"\n+# which is a different type than \"char\" even if \"char\" is signed.  This must\n+# match the usage in emmintrin.h and changing this would change name mangling\n+# and so is not advisable.\n+DEF_PRIMITIVE_TYPE (QI, char_type_node)\n DEF_PRIMITIVE_TYPE (HI, intHI_type_node)\n DEF_PRIMITIVE_TYPE (SI, intSI_type_node)\n+# ??? Logically this should be intDI_type_node, but that maps to \"long\"\n+# with 64-bit, and that's not how the emmintrin.h is written.  Again, \n+# changing this would change name mangling.\n DEF_PRIMITIVE_TYPE (DI, long_long_integer_type_node)\n+DEF_PRIMITIVE_TYPE (UQI, unsigned_intQI_type_node)\n+DEF_PRIMITIVE_TYPE (UHI, unsigned_intHI_type_node)\n+DEF_PRIMITIVE_TYPE (USI, unsigned_intSI_type_node)\n+DEF_PRIMITIVE_TYPE (UDI, long_long_unsigned_type_node)\n+# ??? Some of the types below should use the mode types above.\n DEF_PRIMITIVE_TYPE (USHORT, short_unsigned_type_node)\n DEF_PRIMITIVE_TYPE (INT, integer_type_node)\n DEF_PRIMITIVE_TYPE (UINT, unsigned_type_node)\n@@ -59,23 +71,33 @@ DEF_PRIMITIVE_TYPE (DOUBLE, double_type_node)\n DEF_PRIMITIVE_TYPE (FLOAT80, float80_type_node)\n DEF_PRIMITIVE_TYPE (FLOAT128, float128_type_node)\n \n-DEF_VECTOR_TYPE (V16HI, HI)\n-DEF_VECTOR_TYPE (V16QI, CHAR)\n-DEF_VECTOR_TYPE (V1DI, DI)\n-DEF_VECTOR_TYPE (V2DF, DOUBLE)\n-DEF_VECTOR_TYPE (V2DI, DI)\n+# MMX vectors\n DEF_VECTOR_TYPE (V2SF, FLOAT)\n+DEF_VECTOR_TYPE (V1DI, DI)\n DEF_VECTOR_TYPE (V2SI, SI)\n-DEF_VECTOR_TYPE (V32QI, CHAR)\n-DEF_VECTOR_TYPE (V4DF, DOUBLE)\n-DEF_VECTOR_TYPE (V4DI, DI)\n DEF_VECTOR_TYPE (V4HI, HI)\n+DEF_VECTOR_TYPE (V8QI, QI)\n+\n+# SSE vectors\n+DEF_VECTOR_TYPE (V2DF, DOUBLE)\n DEF_VECTOR_TYPE (V4SF, FLOAT)\n+DEF_VECTOR_TYPE (V2DI, DI)\n DEF_VECTOR_TYPE (V4SI, SI)\n DEF_VECTOR_TYPE (V8HI, HI)\n-DEF_VECTOR_TYPE (V8QI, CHAR)\n+DEF_VECTOR_TYPE (V16QI, QI)\n+DEF_VECTOR_TYPE (V2UDI, UDI, V2DI)\n+DEF_VECTOR_TYPE (V4USI, USI, V4SI)\n+DEF_VECTOR_TYPE (V8UHI, UHI, V8HI)\n+DEF_VECTOR_TYPE (V16UQI, UQI, V16QI)\n+\n+# AVX vectors\n+DEF_VECTOR_TYPE (V4DF, DOUBLE)\n DEF_VECTOR_TYPE (V8SF, FLOAT)\n+DEF_VECTOR_TYPE (V4DI, DI)\n DEF_VECTOR_TYPE (V8SI, SI)\n+DEF_VECTOR_TYPE (V16HI, HI)\n+DEF_VECTOR_TYPE (V32QI, QI)\n+\n \n DEF_POINTER_TYPE (PCCHAR, CHAR, CONST)\n DEF_POINTER_TYPE (PCDOUBLE, DOUBLE, CONST)\n@@ -323,6 +345,12 @@ DEF_FUNCTION_TYPE (VOID, UINT64, UINT, UINT)\n DEF_FUNCTION_TYPE (VOID, USHORT, UINT, USHORT)\n DEF_FUNCTION_TYPE (VOID, V16QI, V16QI, PCHAR)\n DEF_FUNCTION_TYPE (VOID, V8QI, V8QI, PCHAR)\n+DEF_FUNCTION_TYPE (V2DF, V2DF, V2DF, V2DI)\n+DEF_FUNCTION_TYPE (V4SF, V4SF, V4SF, V4SI)\n+DEF_FUNCTION_TYPE (V2UDI, V2UDI, V2UDI, V2UDI)\n+DEF_FUNCTION_TYPE (V4USI, V4USI, V4USI, V4USI)\n+DEF_FUNCTION_TYPE (V8UHI, V8UHI, V8UHI, V8UHI)\n+DEF_FUNCTION_TYPE (V16UQI, V16UQI, V16UQI, V16UQI)\n \n DEF_FUNCTION_TYPE (V2DI, V2DI, V2DI, UINT, UINT)\n DEF_FUNCTION_TYPE (V4HI, HI, HI, HI, HI)"}, {"sha": "f2e06ee248f921b9c0a7639d7f92ad84eed0990d", "filename": "gcc/config/i386/i386-modes.def", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Fconfig%2Fi386%2Fi386-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Fconfig%2Fi386%2Fi386-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-modes.def?ref=0fac51514326c7e8b04d88d22a4ab717bd15d46b", "patch": "@@ -69,22 +69,20 @@ CC_MODE (CCZ);\n CC_MODE (CCFP);\n CC_MODE (CCFPU);\n \n-/* Vector modes.  */\n-VECTOR_MODES (INT, 4);        /*            V4QI V2HI */\n-VECTOR_MODES (INT, 8);        /*       V8QI V4HI V2SI */\n-VECTOR_MODES (INT, 16);       /* V16QI V8HI V4SI V2DI */\n-VECTOR_MODES (INT, 32);       /* V32QI V16HI V8SI V4DI */\n-VECTOR_MODES (FLOAT, 8);      /*            V4HF V2SF */\n-VECTOR_MODES (FLOAT, 16);     /*       V8HF V4SF V2DF */\n-VECTOR_MODES (FLOAT, 32);     /*      V16HF V8SF V4DF */\n-VECTOR_MODE (INT, DI, 1);     /*                 V1DI */\n-VECTOR_MODE (INT, SI, 1);     /*                 V1SI */\n-VECTOR_MODE (INT, QI, 2);     /*                 V2QI */\n-VECTOR_MODE (INT, DI, 8);     /*                 V8DI */\n-VECTOR_MODE (INT, HI, 32);    /*                V32HI */\n-VECTOR_MODE (INT, QI, 64);    /*                V64QI */\n-VECTOR_MODE (FLOAT, DF, 8);   /*                 V8DF */\n-VECTOR_MODE (FLOAT, SF, 16);  /*                V16SF */\n+/* Vector modes.  Note that VEC_CONCAT patterns require vector\n+   sizes twice as big as implemented in hardware.  */\n+VECTOR_MODES (INT, 4);        /*              V4QI V2HI */\n+VECTOR_MODES (INT, 8);        /*         V8QI V4HI V2SI */\n+VECTOR_MODES (INT, 16);       /*   V16QI V8HI V4SI V2DI */\n+VECTOR_MODES (INT, 32);       /*  V32QI V16HI V8SI V4DI */\n+VECTOR_MODES (INT, 64);       /* V64QI V32HI V16SI V8DI */\n+VECTOR_MODES (FLOAT, 8);      /*              V4HF V2SF */\n+VECTOR_MODES (FLOAT, 16);     /*         V8HF V4SF V2DF */\n+VECTOR_MODES (FLOAT, 32);     /*        V16HF V8SF V4DF */\n+VECTOR_MODES (FLOAT, 64);     /*       V32HF V16SF V8DF */\n+VECTOR_MODE (INT, DI, 1);     /*                   V1DI */\n+VECTOR_MODE (INT, SI, 1);     /*                   V1SI */\n+VECTOR_MODE (INT, QI, 2);     /*                   V2QI */\n \n INT_MODE (OI, 32);\n "}, {"sha": "88acc1f82a6f81a69ee8cc9ccf34c998e3f43d4b", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=0fac51514326c7e8b04d88d22a4ab717bd15d46b", "patch": "@@ -219,6 +219,8 @@ extern void ix86_expand_reduc_v4sf (rtx (*)(rtx, rtx, rtx), rtx, rtx);\n extern bool ix86_fma4_valid_op_p (rtx [], rtx, int, bool, int, bool);\n extern void ix86_expand_fma4_multiple_memory (rtx [], int, enum machine_mode);\n \n+extern void ix86_expand_vec_extract_even_odd (rtx, rtx, rtx, unsigned);\n+\n /* In i386-c.c  */\n extern void ix86_target_macros (void);\n extern void ix86_register_pragmas (void);\n@@ -277,4 +279,3 @@ extern int asm_preferred_eh_data_format (int, int);\n #ifdef HAVE_ATTR_cpu\n extern enum attr_cpu ix86_schedule;\n #endif\n-"}, {"sha": "4d5e8a31df2b76de15916c1c6b02d326805576c8", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1129, "deletions": 3, "changes": 1132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=0fac51514326c7e8b04d88d22a4ab717bd15d46b", "patch": "@@ -54,7 +54,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"cselib.h\"\n \n-static int x86_builtin_vectorization_cost (bool);\n static rtx legitimize_dllimport_symbol (rtx, bool);\n \n #ifndef CHECK_STACK_LIMIT\n@@ -1885,6 +1884,7 @@ static void ix86_compute_frame_layout (struct ix86_frame *);\n static bool ix86_expand_vector_init_one_nonzero (bool, enum machine_mode,\n \t\t\t\t\t\t rtx, rtx, int);\n static void ix86_add_new_builtins (int);\n+static rtx ix86_expand_vec_perm_builtin (tree);\n \n enum ix86_function_specific_strings\n {\n@@ -21037,6 +21037,17 @@ enum ix86_builtins\n \n   IX86_BUILTIN_CVTUDQ2PS,\n \n+  IX86_BUILTIN_VEC_PERM_V2DF,\n+  IX86_BUILTIN_VEC_PERM_V4SF,\n+  IX86_BUILTIN_VEC_PERM_V2DI,\n+  IX86_BUILTIN_VEC_PERM_V4SI,\n+  IX86_BUILTIN_VEC_PERM_V8HI,\n+  IX86_BUILTIN_VEC_PERM_V16QI,\n+  IX86_BUILTIN_VEC_PERM_V2DI_U,\n+  IX86_BUILTIN_VEC_PERM_V4SI_U,\n+  IX86_BUILTIN_VEC_PERM_V8HI_U,\n+  IX86_BUILTIN_VEC_PERM_V16QI_U,\n+\n   /* FMA4 and XOP instructions.  */\n   IX86_BUILTIN_VFMADDSS,\n   IX86_BUILTIN_VFMADDSD,\n@@ -21710,6 +21721,17 @@ static const struct builtin_description bdesc_args[] =\n   /* SSE2 */\n   { OPTION_MASK_ISA_SSE2, CODE_FOR_sse2_shufpd, \"__builtin_ia32_shufpd\", IX86_BUILTIN_SHUFPD, UNKNOWN, (int) V2DF_FTYPE_V2DF_V2DF_INT },\n \n+  { OPTION_MASK_ISA_SSE2, CODE_FOR_nothing, \"__builtin_ia32_vec_perm_v2df\", IX86_BUILTIN_VEC_PERM_V2DF, UNKNOWN, (int) V2DF_FTYPE_V2DF_V2DF_V2DI },\n+  { OPTION_MASK_ISA_SSE2, CODE_FOR_nothing, \"__builtin_ia32_vec_perm_v4sf\", IX86_BUILTIN_VEC_PERM_V4SF, UNKNOWN, (int) V4SF_FTYPE_V4SF_V4SF_V4SI },\n+  { OPTION_MASK_ISA_SSE2, CODE_FOR_nothing, \"__builtin_ia32_vec_perm_v2di\", IX86_BUILTIN_VEC_PERM_V2DI, UNKNOWN, (int) V2DI_FTYPE_V2DI_V2DI_V2DI },\n+  { OPTION_MASK_ISA_SSE2, CODE_FOR_nothing, \"__builtin_ia32_vec_perm_v4si\", IX86_BUILTIN_VEC_PERM_V4SI, UNKNOWN, (int) V4SI_FTYPE_V4SI_V4SI_V4SI },\n+  { OPTION_MASK_ISA_SSE2, CODE_FOR_nothing, \"__builtin_ia32_vec_perm_v8hi\", IX86_BUILTIN_VEC_PERM_V8HI, UNKNOWN, (int) V8HI_FTYPE_V8HI_V8HI_V8HI },\n+  { OPTION_MASK_ISA_SSE2, CODE_FOR_nothing, \"__builtin_ia32_vec_perm_v16qi\", IX86_BUILTIN_VEC_PERM_V16QI, UNKNOWN, (int) V16QI_FTYPE_V16QI_V16QI_V16QI },\n+  { OPTION_MASK_ISA_SSE2, CODE_FOR_nothing, \"__builtin_ia32_vec_perm_v2di_u\", IX86_BUILTIN_VEC_PERM_V2DI_U, UNKNOWN, (int) V2UDI_FTYPE_V2UDI_V2UDI_V2UDI },\n+  { OPTION_MASK_ISA_SSE2, CODE_FOR_nothing, \"__builtin_ia32_vec_perm_v4si_u\", IX86_BUILTIN_VEC_PERM_V4SI_U, UNKNOWN, (int) V4USI_FTYPE_V4USI_V4USI_V4USI },\n+  { OPTION_MASK_ISA_SSE2, CODE_FOR_nothing, \"__builtin_ia32_vec_perm_v8hi_u\", IX86_BUILTIN_VEC_PERM_V8HI_U, UNKNOWN, (int) V8UHI_FTYPE_V8UHI_V8UHI_V8UHI },\n+  { OPTION_MASK_ISA_SSE2, CODE_FOR_nothing, \"__builtin_ia32_vec_perm_v16qi_u\", IX86_BUILTIN_VEC_PERM_V16QI_U, UNKNOWN, (int) V16UQI_FTYPE_V16UQI_V16UQI_V16UQI },\n+\n   { OPTION_MASK_ISA_SSE2, CODE_FOR_sse2_movmskpd, \"__builtin_ia32_movmskpd\", IX86_BUILTIN_MOVMSKPD, UNKNOWN, (int) INT_FTYPE_V2DF  },\n   { OPTION_MASK_ISA_SSE2, CODE_FOR_sse2_pmovmskb, \"__builtin_ia32_pmovmskb128\", IX86_BUILTIN_PMOVMSKB128, UNKNOWN, (int) INT_FTYPE_V16QI },\n   { OPTION_MASK_ISA_SSE2, CODE_FOR_sqrtv2df2, \"__builtin_ia32_sqrtpd\", IX86_BUILTIN_SQRTPD, UNKNOWN, (int) V2DF_FTYPE_V2DF },\n@@ -24119,6 +24141,18 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     case IX86_BUILTIN_VEC_SET_V16QI:\n       return ix86_expand_vec_set_builtin (exp);\n \n+    case IX86_BUILTIN_VEC_PERM_V2DF:\n+    case IX86_BUILTIN_VEC_PERM_V4SF:\n+    case IX86_BUILTIN_VEC_PERM_V2DI:\n+    case IX86_BUILTIN_VEC_PERM_V4SI:\n+    case IX86_BUILTIN_VEC_PERM_V8HI:\n+    case IX86_BUILTIN_VEC_PERM_V16QI:\n+    case IX86_BUILTIN_VEC_PERM_V2DI_U:\n+    case IX86_BUILTIN_VEC_PERM_V4SI_U:\n+    case IX86_BUILTIN_VEC_PERM_V8HI_U:\n+    case IX86_BUILTIN_VEC_PERM_V16QI_U:\n+      return ix86_expand_vec_perm_builtin (exp);\n+\n     case IX86_BUILTIN_INFQ:\n     case IX86_BUILTIN_HUGE_VALQ:\n       {\n@@ -28904,7 +28938,7 @@ static const struct attribute_spec ix86_attribute_table[] =\n \n /* Implement targetm.vectorize.builtin_vectorization_cost.  */\n static int\n-x86_builtin_vectorization_cost (bool runtime_test)\n+ix86_builtin_vectorization_cost (bool runtime_test)\n {\n   /* If the branch of the runtime test is taken - i.e. - the vectorized\n      version is skipped - this incurs a misprediction cost (because the\n@@ -28926,6 +28960,1091 @@ x86_builtin_vectorization_cost (bool runtime_test)\n     return 0;\n }\n \n+/* Implement targetm.vectorize.builtin_vec_perm.  */\n+\n+static tree\n+ix86_vectorize_builtin_vec_perm (tree vec_type, tree *mask_type)\n+{\n+  tree itype = TREE_TYPE (vec_type);\n+  bool u = TYPE_UNSIGNED (itype);\n+  enum ix86_builtins fcode;\n+\n+  if (!TARGET_SSE2)\n+    return NULL_TREE;\n+\n+  switch (TYPE_MODE (vec_type))\n+    {\n+    case V2DFmode:\n+      itype = ix86_get_builtin_type (IX86_BT_DI);\n+      fcode = IX86_BUILTIN_VEC_PERM_V2DF;\n+      break;\n+    case V4SFmode:\n+      itype = ix86_get_builtin_type (IX86_BT_SI);\n+      fcode = IX86_BUILTIN_VEC_PERM_V4SF;\n+      break;\n+    case V2DImode:\n+      fcode = u ? IX86_BUILTIN_VEC_PERM_V2DI_U : IX86_BUILTIN_VEC_PERM_V2DI;\n+      break;\n+    case V4SImode:\n+      fcode = u ? IX86_BUILTIN_VEC_PERM_V4SI_U : IX86_BUILTIN_VEC_PERM_V4SI;\n+      break;\n+    case V8HImode:\n+      fcode = u ? IX86_BUILTIN_VEC_PERM_V8HI_U : IX86_BUILTIN_VEC_PERM_V8HI;\n+      break;\n+    case V16QImode:\n+      fcode = u ? IX86_BUILTIN_VEC_PERM_V16QI_U : IX86_BUILTIN_VEC_PERM_V16QI;\n+      break;\n+    default:\n+      return NULL_TREE;\n+    }\n+\n+  *mask_type = itype;\n+  return ix86_builtins[(int) fcode];\n+}\n+\n+/* AVX does not support 32-byte integer vector operations,\n+   thus the longest vector we are faced with is V16QImode.  */\n+#define MAX_VECT_LEN\t16\n+\n+struct expand_vec_perm_d\n+{\n+  rtx target, op0, op1;\n+  unsigned char perm[MAX_VECT_LEN];\n+  enum machine_mode vmode;\n+  unsigned char nelt;\n+  bool testing_p;\n+};\n+\n+/* Return a vector mode with twice as many elements as VMODE.  */\n+/* ??? Consider moving this to a table generated by genmodes.c.  */\n+\n+static enum machine_mode\n+doublesize_vector_mode (enum machine_mode vmode)\n+{\n+  switch (vmode)\n+    {\n+    case V2SFmode:\treturn V4SFmode;\n+    case V1DImode:\treturn V2DImode;\n+    case V2SImode:\treturn V4SImode;\n+    case V4HImode:\treturn V8HImode;\n+    case V8QImode:\treturn V16QImode;\n+\n+    case V2DFmode:\treturn V4DFmode;\n+    case V4SFmode:\treturn V8SFmode;\n+    case V2DImode:\treturn V4DImode;\n+    case V4SImode:\treturn V8SImode;\n+    case V8HImode:\treturn V16HImode;\n+    case V16QImode:\treturn V32QImode;\n+\n+    case V4DFmode:\treturn V8DFmode;\n+    case V8SFmode:\treturn V16SFmode;\n+    case V4DImode:\treturn V8DImode;\n+    case V8SImode:\treturn V16SImode;\n+    case V16HImode:\treturn V32HImode;\n+    case V32QImode:\treturn V64QImode;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Construct (set target (vec_select op0 (parallel perm))) and\n+   return true if that's a valid instruction in the active ISA.  */\n+\n+static bool\n+expand_vselect (rtx target, rtx op0, const unsigned char *perm, unsigned nelt)\n+{\n+  rtx rperm[MAX_VECT_LEN], x;\n+  unsigned i;\n+\n+  for (i = 0; i < nelt; ++i)\n+    rperm[i] = GEN_INT (perm[i]);\n+\n+  x = gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (nelt, rperm));\n+  x = gen_rtx_VEC_SELECT (GET_MODE (target), op0, x);\n+  x = gen_rtx_SET (VOIDmode, target, x);\n+\n+  x = emit_insn (x);\n+  if (recog_memoized (x) < 0)\n+    {\n+      remove_insn (x);\n+      return false;\n+    }\n+  return true;\n+}\n+\n+/* Similar, but generate a vec_concat from op0 and op1 as well.  */\n+\n+static bool\n+expand_vselect_vconcat (rtx target, rtx op0, rtx op1,\n+\t\t\tconst unsigned char *perm, unsigned nelt)\n+{\n+  enum machine_mode v2mode;\n+  rtx x;\n+\n+  v2mode = doublesize_vector_mode (GET_MODE (op0));\n+  x = gen_rtx_VEC_CONCAT (v2mode, op0, op1);\n+  return expand_vselect (target, x, perm, nelt);\n+}\n+\n+/* A subroutine of ix86_expand_vec_perm_builtin_1.  Try to implement D\n+   in terms of blendp[sd] / pblendw / pblendvb.  */\n+\n+static bool\n+expand_vec_perm_blend (struct expand_vec_perm_d *d)\n+{\n+  enum machine_mode vmode = d->vmode;\n+  unsigned i, mask, nelt = d->nelt;\n+  rtx target, op0, op1, x;\n+\n+  if (!TARGET_SSE4_1 || d->op0 == d->op1)\n+    return false;\n+  if (!(GET_MODE_SIZE (vmode) == 16 || vmode == V4DFmode || vmode == V8SFmode))\n+    return false;\n+\n+  /* This is a blend, not a permute.  Elements must stay in their\n+     respective lanes.  */\n+  for (i = 0; i < nelt; ++i)\n+    {\n+      unsigned e = d->perm[i];\n+      if (!(e == i || e == i + nelt))\n+\treturn false;\n+    }\n+\n+  if (d->testing_p)\n+    return true;\n+\n+  /* ??? Without SSE4.1, we could implement this with and/andn/or.  This\n+     decision should be extracted elsewhere, so that we only try that\n+     sequence once all budget==3 options have been tried.  */\n+\n+  /* For bytes, see if bytes move in pairs so we can use pblendw with\n+     an immediate argument, rather than pblendvb with a vector argument.  */\n+  if (vmode == V16QImode)\n+    {\n+      bool pblendw_ok = true;\n+      for (i = 0; i < 16 && pblendw_ok; i += 2)\n+\tpblendw_ok = (d->perm[i] + 1 == d->perm[i + 1]);\n+\n+      if (!pblendw_ok)\n+\t{\n+\t  rtx rperm[16], vperm;\n+\n+\t  for (i = 0; i < nelt; ++i)\n+\t    rperm[i] = (d->perm[i] < nelt ? const0_rtx : constm1_rtx);\n+\n+\t  vperm = gen_rtx_CONST_VECTOR (V16QImode, gen_rtvec_v (16, rperm));\n+\t  vperm = force_reg (V16QImode, vperm);\n+\n+\t  emit_insn (gen_sse4_1_pblendvb (d->target, d->op0, d->op1, vperm));\n+\t  return true;\n+\t}\n+    }\n+\n+  target = d->target;\n+  op0 = d->op0;\n+  op1 = d->op1;\n+  mask = 0;\n+\n+  switch (vmode)\n+    {\n+    case V4DFmode:\n+    case V8SFmode:\n+    case V2DFmode:\n+    case V4SFmode:\n+    case V8HImode:\n+      for (i = 0; i < nelt; ++i)\n+\tmask |= (d->perm[i] >= nelt) << i;\n+      break;\n+\n+    case V2DImode:\n+      for (i = 0; i < 2; ++i)\n+\tmask |= (d->perm[i] >= 2 ? 15 : 0) << (i * 4);\n+      goto do_subreg;\n+\n+    case V4SImode:\n+      for (i = 0; i < 4; ++i)\n+\tmask |= (d->perm[i] >= 4 ? 3 : 0) << (i * 2);\n+      goto do_subreg;\n+\n+    case V16QImode:\n+      for (i = 0; i < 8; ++i)\n+\tmask |= (d->perm[i * 2] >= 16) << i;\n+\n+    do_subreg:\n+      vmode = V8HImode;\n+      target = gen_lowpart (vmode, target);\n+      op0 = gen_lowpart (vmode, target);\n+      op1 = gen_lowpart (vmode, target);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  /* This matches five different patterns with the different modes.  */\n+  x = gen_rtx_VEC_MERGE (vmode, op0, op1, GEN_INT (mask));\n+  x = gen_rtx_SET (VOIDmode, target, x);\n+  emit_insn (x);\n+\n+  return true;\n+}\n+\n+/* A subroutine of ix86_expand_vec_perm_builtin_1.  Try to implement D\n+   in terms of the variable form of vpermilps.\n+\n+   Note that we will have already failed the immediate input vpermilps,\n+   which requires that the high and low part shuffle be identical; the\n+   variable form doesn't require that.  */\n+\n+static bool\n+expand_vec_perm_vpermil (struct expand_vec_perm_d *d)\n+{\n+  rtx rperm[8], vperm;\n+  unsigned i;\n+\n+  if (!TARGET_AVX || d->vmode != V8SFmode || d->op0 != d->op1)\n+    return false;\n+\n+  /* We can only permute within the 128-bit lane.  */\n+  for (i = 0; i < 8; ++i)\n+    {\n+      unsigned e = d->perm[i];\n+      if (i < 4 ? e >= 4 : e < 4)\n+\treturn false;\n+    }\n+\n+  if (d->testing_p)\n+    return true;\n+\n+  for (i = 0; i < 8; ++i)\n+    {\n+      unsigned e = d->perm[i];\n+\n+      /* Within each 128-bit lane, the elements of op0 are numbered\n+\t from 0 and the elements of op1 are numbered from 4.  */\n+      if (e >= 8 + 4)\n+\te -= 8;\n+      else if (e >= 4)\n+\te -= 4;\n+\n+      rperm[i] = GEN_INT (e);\n+    }\n+\n+  vperm = gen_rtx_CONST_VECTOR (V8SImode, gen_rtvec_v (8, rperm));\n+  vperm = force_reg (V8SImode, vperm);\n+  emit_insn (gen_avx_vpermilvarv8sf3 (d->target, d->op0, vperm));\n+\n+  return true;\n+}\n+\n+/* A subroutine of ix86_expand_vec_perm_builtin_1.  Try to implement D\n+   in terms of pshufb or vpperm.  */\n+\n+static bool\n+expand_vec_perm_pshufb (struct expand_vec_perm_d *d)\n+{\n+  unsigned i, nelt, eltsz;\n+  rtx rperm[16], vperm, target, op0, op1;\n+\n+  if (!(d->op0 == d->op1 ? TARGET_SSSE3 : TARGET_XOP))\n+    return false;\n+  if (GET_MODE_SIZE (d->vmode) != 16)\n+    return false;\n+\n+  if (d->testing_p)\n+    return true;\n+\n+  nelt = d->nelt;\n+  eltsz = GET_MODE_SIZE (GET_MODE_INNER (d->vmode));\n+\n+  for (i = 0; i < nelt; ++i)\n+    {\n+      unsigned j, e = d->perm[i];\n+      for (j = 0; j < eltsz; ++j)\n+\trperm[i * eltsz + j] = GEN_INT (e * eltsz + j);\n+    }\n+\n+  vperm = gen_rtx_CONST_VECTOR (V16QImode, gen_rtvec_v (16, rperm));\n+  vperm = force_reg (V16QImode, vperm);\n+\n+  target = gen_lowpart (V16QImode, d->target);\n+  op0 = gen_lowpart (V16QImode, d->op0);\n+  if (d->op0 == d->op1)\n+    emit_insn (gen_ssse3_pshufbv16qi3 (target, op0, vperm));\n+  else\n+    {\n+      op1 = gen_lowpart (V16QImode, d->op1);\n+      emit_insn (gen_xop_pperm (target, op0, op1, vperm));\n+    }\n+\n+  return true;\n+}\n+\n+/* A subroutine of ix86_expand_vec_perm_builtin_1.  Try to instantiate D\n+   in a single instruction.  */\n+\n+static bool\n+expand_vec_perm_1 (struct expand_vec_perm_d *d)\n+{\n+  unsigned i, nelt = d->nelt;\n+  unsigned char perm2[MAX_VECT_LEN];\n+\n+  /* Check plain VEC_SELECT first, because AVX has instructions that could\n+     match both SEL and SEL+CONCAT, but the plain SEL will allow a memory\n+     input where SEL+CONCAT may not.  */\n+  if (d->op0 == d->op1)\n+    {\n+      if (expand_vselect (d->target, d->op0, d->perm, nelt))\n+\treturn true;\n+\n+      /* There are plenty of patterns in sse.md that are written for\n+\t SEL+CONCAT and are not replicated for a single op.  Perhaps\n+\t that should be changed, to avoid the nastiness here.  */\n+\n+      /* Recognize interleave style patterns, which means incrementing\n+\t every other permutation operand.  */\n+      for (i = 0; i < nelt; i += 2)\n+\t{\n+\t  perm2[i] = d->perm[i];\n+\t  perm2[i+1] = d->perm[i+1] + nelt;\n+\t}\n+      if (expand_vselect_vconcat (d->target, d->op0, d->op0, perm2, nelt))\n+\treturn true;\n+\n+      /* Recognize shufps, which means adding {0, 0, nelt, nelt}.  */\n+      if (nelt >= 4)\n+\t{\n+\t  memcpy (perm2, d->perm, nelt);\n+\t  for (i = 2; i < nelt; i += 4)\n+\t    {\n+\t      perm2[i+0] += nelt;\n+\t      perm2[i+1] += nelt;\n+\t    }\n+\n+\t  if (expand_vselect_vconcat (d->target, d->op0, d->op0, perm2, nelt))\n+\t    return true;\n+\t}\n+    }\n+\n+  /* Finally, try the fully general two operand permute.  */\n+  if (expand_vselect_vconcat (d->target, d->op0, d->op1, d->perm, nelt))\n+    return true;\n+\n+  /* Recognize interleave style patterns with reversed operands.  */\n+  if (d->op0 != d->op1)\n+    {\n+      for (i = 0; i < nelt; ++i)\n+\t{\n+\t  unsigned e = d->perm[i];\n+\t  if (e >= nelt)\n+\t    e -= nelt;\n+\t  else\n+\t    e += nelt;\n+\t  perm2[i] = e;\n+\t}\n+\n+      if (expand_vselect_vconcat (d->target, d->op1, d->op0, perm2, nelt))\n+\treturn true;\n+    }\n+\n+  /* Try the SSE4.1 blend variable merge instructions.  */\n+  if (expand_vec_perm_blend (d))\n+    return true;\n+\n+  /* Try one of the AVX vpermil variable permutations.  */\n+  if (expand_vec_perm_vpermil (d))\n+    return true;\n+\n+  /* Try the SSSE3 pshufb or XOP vpperm variable permutation.  */\n+  if (expand_vec_perm_pshufb (d))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* A subroutine of ix86_expand_vec_perm_builtin_1.  Try to implement D\n+   in terms of a pair of pshuflw + pshufhw instructions.  */\n+\n+static bool\n+expand_vec_perm_pshuflw_pshufhw (struct expand_vec_perm_d *d)\n+{\n+  unsigned char perm2[MAX_VECT_LEN];\n+  unsigned i;\n+  bool ok;\n+\n+  if (d->vmode != V8HImode || d->op0 != d->op1)\n+    return false;\n+\n+  /* The two permutations only operate in 64-bit lanes.  */\n+  for (i = 0; i < 4; ++i)\n+    if (d->perm[i] >= 4)\n+      return false;\n+  for (i = 4; i < 8; ++i)\n+    if (d->perm[i] < 4)\n+      return false;\n+\n+  if (d->testing_p)\n+    return true;\n+\n+  /* Emit the pshuflw.  */\n+  memcpy (perm2, d->perm, 4);\n+  for (i = 4; i < 8; ++i)\n+    perm2[i] = i;\n+  ok = expand_vselect (d->target, d->op0, perm2, 8);\n+  gcc_assert (ok);\n+\n+  /* Emit the pshufhw.  */\n+  memcpy (perm2 + 4, d->perm + 4, 4);\n+  for (i = 0; i < 4; ++i)\n+    perm2[i] = i;\n+  ok = expand_vselect (d->target, d->target, perm2, 8);\n+  gcc_assert (ok);\n+\n+  return true;\n+}\n+\n+/* A subroutine of ix86_expand_vec_perm_builtin_1.  Try to simplify\n+   the permutation using the SSSE3 palignr instruction.  This succeeds\n+   when all of the elements in PERM fit within one vector and we merely\n+   need to shift them down so that a single vector permutation has a\n+   chance to succeed.  */\n+\n+static bool\n+expand_vec_perm_palignr (struct expand_vec_perm_d *d)\n+{\n+  unsigned i, nelt = d->nelt;\n+  unsigned min, max;\n+  bool in_order, ok;\n+  rtx shift;\n+\n+  /* Even with AVX, palignr only operates on 128-bit vectors.  */\n+  if (!TARGET_SSSE3 || GET_MODE_SIZE (d->vmode) != 16)\n+    return false;\n+\n+  min = nelt, max = 0;\n+  for (i = 0; i < nelt; ++i)\n+    {\n+      unsigned e = d->perm[i];\n+      if (e < min)\n+\tmin = e;\n+      if (e > max)\n+\tmax = e;\n+    }\n+  if (min == 0 || max - min >= nelt)\n+    return false;\n+\n+  /* Given that we have SSSE3, we know we'll be able to implement the\n+     single operand permutation after the palignr with pshufb.  */\n+  if (d->testing_p)\n+    return true;\n+\n+  shift = GEN_INT (min * GET_MODE_BITSIZE (GET_MODE_INNER (d->vmode)));\n+  emit_insn (gen_ssse3_palignrti (gen_lowpart (TImode, d->target),\n+\t\t\t\t  gen_lowpart (TImode, d->op1),\n+\t\t\t\t  gen_lowpart (TImode, d->op0), shift));\n+\n+  d->op0 = d->op1 = d->target;\n+\n+  in_order = true;\n+  for (i = 0; i < nelt; ++i)\n+    {\n+      unsigned e = d->perm[i] - min;\n+      if (e != i)\n+\tin_order = false;\n+      d->perm[i] = e;\n+    }\n+\n+  /* Test for the degenerate case where the alignment by itself\n+     produces the desired permutation.  */\n+  if (in_order)\n+    return true;\n+\n+  ok = expand_vec_perm_1 (d);\n+  gcc_assert (ok);\n+\n+  return ok;\n+}\n+\n+/* A subroutine of ix86_expand_vec_perm_builtin_1.  Try to simplify\n+   a two vector permutation into a single vector permutation by using\n+   an interleave operation to merge the vectors.  */\n+\n+static bool\n+expand_vec_perm_interleave2 (struct expand_vec_perm_d *d)\n+{\n+  struct expand_vec_perm_d dremap, dfinal;\n+  unsigned i, nelt = d->nelt, nelt2 = nelt / 2;\n+  unsigned contents, h1, h2, h3, h4;\n+  unsigned char remap[2 * MAX_VECT_LEN];\n+  rtx seq;\n+  bool ok;\n+\n+  if (d->op0 == d->op1)\n+    return false;\n+\n+  /* The 256-bit unpck[lh]p[sd] instructions only operate within the 128-bit\n+     lanes.  We can use similar techniques with the vperm2f128 instruction,\n+     but it requires slightly different logic.  */\n+  if (GET_MODE_SIZE (d->vmode) != 16)\n+    return false;\n+\n+  /* Examine from whence the elements come.  */\n+  contents = 0;\n+  for (i = 0; i < nelt; ++i)\n+    contents |= 1u << d->perm[i];\n+\n+  /* Split the two input vectors into 4 halves.  */\n+  h1 = (1u << nelt2) - 1;\n+  h2 = h1 << nelt2;\n+  h3 = h2 << nelt2;\n+  h4 = h3 << nelt2;\n+\n+  memset (remap, 0xff, sizeof (remap));\n+  dremap = *d;\n+\n+  /* If the elements from the low halves use interleave low, and similarly\n+     for interleave high.  If the elements are from mis-matched halves, we\n+     can use shufps for V4SF/V4SI or do a DImode shuffle.  */\n+  if ((contents & (h1 | h3)) == contents)\n+    {\n+      for (i = 0; i < nelt2; ++i)\n+\t{\n+\t  remap[i] = i * 2;\n+\t  remap[i + nelt] = i * 2 + 1;\n+\t  dremap.perm[i * 2] = i;\n+\t  dremap.perm[i * 2 + 1] = i + nelt;\n+\t}\n+    }\n+  else if ((contents & (h2 | h4)) == contents)\n+    {\n+      for (i = 0; i < nelt2; ++i)\n+\t{\n+\t  remap[i + nelt2] = i * 2;\n+\t  remap[i + nelt + nelt2] = i * 2 + 1;\n+\t  dremap.perm[i * 2] = i + nelt2;\n+\t  dremap.perm[i * 2 + 1] = i + nelt + nelt2;\n+\t}\n+    }\n+  else if ((contents & (h1 | h4)) == contents)\n+    {\n+      for (i = 0; i < nelt2; ++i)\n+\t{\n+\t  remap[i] = i;\n+\t  remap[i + nelt + nelt2] = i + nelt2;\n+\t  dremap.perm[i] = i;\n+\t  dremap.perm[i + nelt2] = i + nelt + nelt2;\n+\t}\n+      if (nelt != 4)\n+\t{\n+\t  dremap.vmode = V2DImode;\n+\t  dremap.nelt = 2;\n+\t  dremap.perm[0] = 0;\n+\t  dremap.perm[1] = 3;\n+\t}\n+    }\n+  else if ((contents & (h2 | h3)) == contents)\n+    {\n+      for (i = 0; i < nelt2; ++i)\n+\t{\n+\t  remap[i + nelt2] = i;\n+\t  remap[i + nelt] = i + nelt2;\n+\t  dremap.perm[i] = i + nelt2;\n+\t  dremap.perm[i + nelt2] = i + nelt;\n+\t}\n+      if (nelt != 4)\n+\t{\n+\t  dremap.vmode = V2DImode;\n+\t  dremap.nelt = 2;\n+\t  dremap.perm[0] = 1;\n+\t  dremap.perm[1] = 2;\n+\t}\n+    }\n+  else\n+    return false;\n+\n+  /* Use the remapping array set up above to move the elements from their\n+     swizzled locations into their final destinations.  */\n+  dfinal = *d;\n+  for (i = 0; i < nelt; ++i)\n+    {\n+      unsigned e = remap[d->perm[i]];\n+      gcc_assert (e < nelt);\n+      dfinal.perm[i] = e;\n+    }\n+  dfinal.op0 = gen_reg_rtx (dfinal.vmode);\n+  dfinal.op1 = dfinal.op0;\n+  dremap.target = dfinal.op0;\n+\n+  /* Test if the final remap can be done with a single insn.  For V4SFmode or\n+     V4SImode this *will* succeed.  For V8HImode or V16QImode it may not.  */\n+  start_sequence ();\n+  ok = expand_vec_perm_1 (&dfinal);\n+  seq = get_insns ();\n+  end_sequence ();\n+\n+  if (!ok)\n+    return false;\n+\n+  if (dremap.vmode != dfinal.vmode)\n+    {\n+      dremap.target = gen_lowpart (dremap.vmode, dremap.target);\n+      dremap.op0 = gen_lowpart (dremap.vmode, dremap.op0);\n+      dremap.op1 = gen_lowpart (dremap.vmode, dremap.op1);\n+    }\n+\n+  ok = expand_vec_perm_1 (&dremap);\n+  gcc_assert (ok);\n+\n+  emit_insn (seq);\n+  return true;\n+}\n+\n+/* A subroutine of expand_vec_perm_even_odd_1.  Implement the double-word\n+   permutation with two pshufb insns and an ior.  We should have already\n+   failed all two instruction sequences.  */\n+\n+static bool\n+expand_vec_perm_pshufb2 (struct expand_vec_perm_d *d)\n+{\n+  rtx rperm[2][16], vperm, l, h, op, m128;\n+  unsigned int i, nelt, eltsz;\n+\n+  if (!TARGET_SSSE3)\n+    return false;\n+\n+  nelt = d->nelt;\n+  eltsz = GET_MODE_SIZE (GET_MODE_INNER (d->vmode));\n+  \n+  /* Generate two permutation masks.  If the required element is within\n+     the given vector it is shuffled into the proper lane.  If the required\n+     element is in the other vector, force a zero into the lane by setting\n+     bit 7 in the permutation mask.  */\n+  m128 = GEN_INT (-128);\n+  for (i = 0; i < nelt; ++i)\n+    {\n+      unsigned j, e = d->perm[i];\n+      unsigned which = (e >= nelt);\n+      if (e >= nelt)\n+\te -= nelt;\n+\n+      for (j = 0; j < eltsz; ++j)\n+\t{\n+\t  rperm[which][i*eltsz + j] = GEN_INT (e*eltsz + j);\n+\t  rperm[1-which][i*eltsz + j] = m128;\n+\t}\n+    }\n+\n+  vperm = gen_rtx_CONST_VECTOR (V16QImode, gen_rtvec_v (16, rperm[0]));\n+  vperm = force_reg (V16QImode, vperm);\n+\n+  l = gen_reg_rtx (V16QImode);\n+  op = gen_lowpart (V16QImode, d->op0);\n+  emit_insn (gen_ssse3_pshufbv16qi3 (l, op, vperm));\n+\n+  vperm = gen_rtx_CONST_VECTOR (V16QImode, gen_rtvec_v (16, rperm[1]));\n+  vperm = force_reg (V16QImode, vperm);\n+\n+  h = gen_reg_rtx (V16QImode);\n+  op = gen_lowpart (V16QImode, d->op1);\n+  emit_insn (gen_ssse3_pshufbv16qi3 (h, op, vperm));\n+\n+  op = gen_lowpart (V16QImode, d->target);\n+  emit_insn (gen_iorv16qi3 (op, l, h));\n+\n+  return true;\n+}\n+\n+/* A subroutine of ix86_expand_vec_perm_builtin_1.  Pattern match\n+   extract-even and extract-odd permutations.  */\n+\n+static bool\n+expand_vec_perm_even_odd_1 (struct expand_vec_perm_d *d, unsigned odd)\n+{\n+  rtx t1, t2, t3, t4;\n+\n+  switch (d->vmode)\n+    {\n+    case V4DFmode:\n+      t1 = gen_reg_rtx (V4DFmode);\n+      t2 = gen_reg_rtx (V4DFmode);\n+\n+      /* Shuffle the lanes around into { 0 1 4 5 } and { 2 3 6 7 }.  */\n+      emit_insn (gen_avx_vperm2f128v4df3 (t1, d->op0, d->op1, GEN_INT (0x20)));\n+      emit_insn (gen_avx_vperm2f128v4df3 (t2, d->op0, d->op1, GEN_INT (0x31)));\n+\n+      /* Now an unpck[lh]pd will produce the result required.  */\n+      if (odd)\n+\tt3 = gen_avx_unpckhpd256 (d->target, t1, t2);\n+      else\n+\tt3 = gen_avx_unpcklpd256 (d->target, t1, t2);\n+      emit_insn (t3);\n+      break;\n+\n+    case V8SFmode:\n+      {\n+\tstatic const unsigned char perm1[8] = { 0, 2, 1, 3, 5, 6, 5, 7 };\n+\tstatic const unsigned char perme[8] = { 0, 1,  8,  9, 4, 5, 12, 13 };\n+\tstatic const unsigned char permo[8] = { 2, 3, 10, 11, 6, 7, 14, 15 };\n+\n+\tt1 = gen_reg_rtx (V8SFmode);\n+\tt2 = gen_reg_rtx (V8SFmode);\n+\tt3 = gen_reg_rtx (V8SFmode);\n+\tt4 = gen_reg_rtx (V8SFmode);\n+\n+\t/* Shuffle within the 128-bit lanes to produce:\n+\t   { 0 2 1 3 4 6 5 7 } and { 8 a 9 b c e d f }.  */\n+\texpand_vselect (t1, d->op0, perm1, 8);\n+\texpand_vselect (t2, d->op1, perm1, 8);\n+\n+\t/* Shuffle the lanes around to produce:\n+\t   { 0 2 1 3 8 a 9 b } and { 4 6 5 7 c e d f }.  */\n+\temit_insn (gen_avx_vperm2f128v8sf3 (t3, t1, t2, GEN_INT (0x20)));\n+\temit_insn (gen_avx_vperm2f128v8sf3 (t4, t1, t2, GEN_INT (0x31)));\n+\n+\t/* Now a vpermil2p will produce the result required.  */\n+\t/* ??? The vpermil2p requires a vector constant.  Another option\n+\t   is a unpck[lh]ps to merge the two vectors to produce\n+\t   { 0 4 2 6 8 c a e } or { 1 5 3 7 9 d b f }.  Then use another\n+\t   vpermilps to get the elements into the final order.  */\n+\td->op0 = t3;\n+\td->op1 = t4;\n+\tmemcpy (d->perm, odd ? permo: perme, 8);\n+\texpand_vec_perm_vpermil (d);\n+      }\n+      break;\n+\n+    case V2DFmode:\n+    case V4SFmode:\n+    case V2DImode:\n+    case V4SImode:\n+      /* These are always directly implementable by expand_vec_perm_1.  */\n+      gcc_unreachable ();\n+\n+    case V8HImode:\n+      if (TARGET_SSSE3)\n+\treturn expand_vec_perm_pshufb2 (d);\n+      else\n+\t{\n+\t  /* We need 2*log2(N)-1 operations to achieve odd/even\n+\t     with interleave. */\n+\t  t1 = gen_reg_rtx (V8HImode);\n+\t  t2 = gen_reg_rtx (V8HImode);\n+\t  emit_insn (gen_sse2_punpckhwd (t1, d->op0, d->op1));\n+\t  emit_insn (gen_sse2_punpcklwd (d->target, d->op0, d->op1));\n+\t  emit_insn (gen_sse2_punpckhwd (t2, d->target, t1));\n+\t  emit_insn (gen_sse2_punpcklwd (d->target, d->target, t1));\n+\t  if (odd)\n+\t    emit_insn (gen_sse2_punpckhwd (d->target, d->target, t2));\n+\t  else\n+\t    emit_insn (gen_sse2_punpcklwd (d->target, d->target, t2));\n+\t}\n+      break;\n+\n+    case V16QImode:\n+      if (TARGET_SSSE3)\n+\treturn expand_vec_perm_pshufb2 (d);\n+      else\n+\t{\n+\t  t1 = gen_reg_rtx (V16QImode);\n+\t  t2 = gen_reg_rtx (V16QImode);\n+\t  t3 = gen_reg_rtx (V16QImode);\n+\t  emit_insn (gen_sse2_punpckhbw (t1, d->op0, d->op1));\n+\t  emit_insn (gen_sse2_punpcklbw (d->target, d->op0, d->op1));\n+\t  emit_insn (gen_sse2_punpckhbw (t2, d->target, t1));\n+\t  emit_insn (gen_sse2_punpcklbw (d->target, d->target, t1));\n+\t  emit_insn (gen_sse2_punpckhbw (t3, d->target, t2));\n+\t  emit_insn (gen_sse2_punpcklbw (d->target, d->target, t2));\n+\t  if (odd)\n+\t    emit_insn (gen_sse2_punpckhbw (d->target, d->target, t3));\n+\t  else\n+\t    emit_insn (gen_sse2_punpcklbw (d->target, d->target, t3));\n+\t}\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return true;\n+}\n+\n+static bool\n+expand_vec_perm_even_odd (struct expand_vec_perm_d *d)\n+{\n+  unsigned i, odd, nelt = d->nelt;\n+\n+  odd = d->perm[0];\n+  if (odd != 0 && odd != 1)\n+    return false;\n+\n+  for (i = 1; i < nelt; ++i)\n+    if (d->perm[i] != 2 * i + odd)\n+      return false;\n+\n+  return expand_vec_perm_even_odd_1 (d, odd);\n+}\n+\n+/* The guts of ix86_expand_vec_perm_builtin, also used by the ok hook.\n+   With all of the interface bits taken care of, perform the expansion\n+   in D and return true on success.  */\n+\n+static bool\n+ix86_expand_vec_perm_builtin_1 (struct expand_vec_perm_d *d)\n+{\n+  /* First things first -- check if the instruction is implementable\n+     with a single instruction.  */\n+  if (expand_vec_perm_1 (d))\n+    return true;\n+\n+  /* Try sequences of two instructions.  */\n+\n+  if (expand_vec_perm_pshuflw_pshufhw (d))\n+    return true;\n+\n+  if (expand_vec_perm_palignr (d))\n+    return true;\n+\n+  if (expand_vec_perm_interleave2 (d))\n+    return true;\n+\n+  /* Try sequences of three instructions.  */\n+\n+  if (expand_vec_perm_pshufb2 (d))\n+    return true;\n+\n+  /* ??? Look for narrow permutations whose element orderings would\n+     allow the promition to a wider mode.  */\n+\n+  /* ??? Look for sequences of interleave or a wider permute that place\n+     the data into the correct lanes for a half-vector shuffle like\n+     pshuf[lh]w or vpermilps.  */\n+\n+  /* ??? Look for sequences of interleave that produce the desired results.\n+     The combinatorics of punpck[lh] get pretty ugly... */\n+\n+  if (expand_vec_perm_even_odd (d))\n+    return true;\n+\n+  /* ??? Pattern match broadcast.  */\n+\n+  return false;\n+}\n+\n+/* Extract the values from the vector CST into the permutation array in D.\n+   Return 0 on error, 1 if all values from the permutation come from the\n+   first vector, 2 if all values from the second vector, and 3 otherwise.  */\n+\n+static int\n+extract_vec_perm_cst (struct expand_vec_perm_d *d, tree cst)\n+{\n+  tree list = TREE_VECTOR_CST_ELTS (cst);\n+  unsigned i, nelt = d->nelt;\n+  int ret = 0;\n+\n+  for (i = 0; i < nelt; ++i, list = TREE_CHAIN (list))\n+    {\n+      unsigned HOST_WIDE_INT e;\n+\n+      if (!host_integerp (TREE_VALUE (list), 1))\n+\treturn 0;\n+      e = tree_low_cst (TREE_VALUE (list), 1);\n+      if (e >= 2 * nelt)\n+\treturn 0;\n+\n+      ret |= (e < nelt ? 1 : 2);\n+      d->perm[i] = e;\n+    }\n+  gcc_assert (list == NULL);\n+\n+  /* For all elements from second vector, fold the elements to first.  */\n+  if (ret == 2)\n+    for (i = 0; i < nelt; ++i)\n+      d->perm[i] -= nelt;\n+\n+  return ret;\n+}\n+\n+static rtx\n+ix86_expand_vec_perm_builtin (tree exp)\n+{\n+  struct expand_vec_perm_d d;\n+  tree arg0, arg1, arg2;\n+\n+  arg0 = CALL_EXPR_ARG (exp, 0);\n+  arg1 = CALL_EXPR_ARG (exp, 1);\n+  arg2 = CALL_EXPR_ARG (exp, 2);\n+\n+  d.vmode = TYPE_MODE (TREE_TYPE (arg0));\n+  d.nelt = GET_MODE_NUNITS (d.vmode);\n+  d.testing_p = false;\n+  gcc_assert (VECTOR_MODE_P (d.vmode));\n+\n+  if (TREE_CODE (arg2) != VECTOR_CST)\n+    {\n+      error_at (EXPR_LOCATION (exp),\n+\t\t\"vector permutation requires vector constant\");\n+      goto exit_error;\n+    }\n+\n+  switch (extract_vec_perm_cst (&d, arg2))\n+    {\n+    default:\n+      gcc_unreachable();\n+\n+    case 0:\n+      error_at (EXPR_LOCATION (exp), \"invalid vector permutation constant\");\n+      goto exit_error;\n+\n+    case 3:\n+      if (!operand_equal_p (arg0, arg1, 0))\n+\t{\n+\t  d.op0 = expand_expr (arg0, NULL_RTX, d.vmode, EXPAND_NORMAL);\n+\t  d.op0 = force_reg (d.vmode, d.op0);\n+\t  d.op1 = expand_expr (arg1, NULL_RTX, d.vmode, EXPAND_NORMAL);\n+\t  d.op1 = force_reg (d.vmode, d.op1);\n+\t  break;\n+\t}\n+\n+      /* The elements of PERM do not suggest that only the first operand\n+\t is used, but both operands are identical.  Allow easier matching\n+\t of the permutation by folding the permutation into the single\n+\t input vector.  */\n+      {\n+\tunsigned i, nelt = d.nelt;\n+\tfor (i = 0; i < nelt; ++i)\n+\t  if (d.perm[i] >= nelt)\n+\t    d.perm[i] -= nelt;\n+      }\n+      /* FALLTHRU */\n+\n+    case 1:\n+      d.op0 = expand_expr (arg0, NULL_RTX, d.vmode, EXPAND_NORMAL);\n+      d.op0 = force_reg (d.vmode, d.op0);\n+      d.op1 = d.op0;\n+      break;\n+\n+    case 2:\n+      d.op0 = expand_expr (arg1, NULL_RTX, d.vmode, EXPAND_NORMAL);\n+      d.op0 = force_reg (d.vmode, d.op0);\n+      d.op1 = d.op0;\n+      break;\n+    }\n+ \n+  d.target = gen_reg_rtx (d.vmode);\n+  if (ix86_expand_vec_perm_builtin_1 (&d))\n+    return d.target;\n+\n+  /* For compiler generated permutations, we should never got here, because\n+     the compiler should also be checking the ok hook.  But since this is a\n+     builtin the user has access too, so don't abort.  */\n+  switch (d.nelt)\n+    {\n+    case 2:\n+      sorry (\"vector permutation (%d %d)\", d.perm[0], d.perm[1]);\n+      break;\n+    case 4:\n+      sorry (\"vector permutation (%d %d %d %d)\",\n+\t     d.perm[0], d.perm[1], d.perm[2], d.perm[3]);\n+      break;\n+    case 8:\n+      sorry (\"vector permutation (%d %d %d %d %d %d %d %d)\",\n+\t     d.perm[0], d.perm[1], d.perm[2], d.perm[3],\n+\t     d.perm[4], d.perm[5], d.perm[6], d.perm[7]);\n+      break;\n+    case 16:\n+      sorry (\"vector permutation \"\n+\t     \"(%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d)\",\n+\t     d.perm[0], d.perm[1], d.perm[2], d.perm[3],\n+\t     d.perm[4], d.perm[5], d.perm[6], d.perm[7],\n+\t     d.perm[8], d.perm[9], d.perm[10], d.perm[11],\n+\t     d.perm[12], d.perm[13], d.perm[14], d.perm[15]);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+ exit_error:\n+  return CONST0_RTX (d.vmode);\n+}\n+\n+/* Implement targetm.vectorize.builtin_vec_perm_ok.  */\n+\n+static bool\n+ix86_vectorize_builtin_vec_perm_ok (tree vec_type, tree mask)\n+{\n+  struct expand_vec_perm_d d;\n+  int vec_mask;\n+  bool ret, one_vec;\n+\n+  d.vmode = TYPE_MODE (vec_type);\n+  d.nelt = GET_MODE_NUNITS (d.vmode);\n+  d.testing_p = true;\n+\n+  /* Given sufficient ISA support we can just return true here\n+     for selected vector modes.  */\n+  if (GET_MODE_SIZE (d.vmode) == 16)\n+    {\n+      /* All implementable with a single vpperm insn.  */\n+      if (TARGET_XOP)\n+\treturn true;\n+      /* All implementable with 2 pshufb + 1 ior.  */\n+      if (TARGET_SSSE3)\n+\treturn true;\n+      /* All implementable with shufpd or unpck[lh]pd.  */\n+      if (d.nelt == 2)\n+\treturn true;\n+    }\n+\n+  vec_mask = extract_vec_perm_cst (&d, mask);\n+\n+  /* This hook is cannot be called in response to something that the\n+     user does (unlike the builtin expander) so we shouldn't ever see\n+     an error generated from the extract.  */\n+  gcc_assert (vec_mask > 0 && vec_mask <= 3);\n+  one_vec = (vec_mask != 3);\n+  \n+  /* Implementable with shufps or pshufd.  */\n+  if (one_vec && (d.vmode == V4SFmode || d.vmode == V4SImode))\n+    return true;\n+\n+  /* Otherwise we have to go through the motions and see if we can\n+     figure out how to generate the requested permutation.  */\n+  d.target = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 1);\n+  d.op1 = d.op0 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 2);\n+  if (!one_vec)\n+    d.op1 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 3);\n+\n+  start_sequence ();\n+  ret = ix86_expand_vec_perm_builtin_1 (&d);\n+  end_sequence ();\n+\n+  return ret;\n+}\n+\n+void\n+ix86_expand_vec_extract_even_odd (rtx targ, rtx op0, rtx op1, unsigned odd)\n+{\n+  struct expand_vec_perm_d d;\n+  unsigned i, nelt;\n+\n+  d.target = targ;\n+  d.op0 = op0;\n+  d.op1 = op1;\n+  d.vmode = GET_MODE (targ);\n+  d.nelt = nelt = GET_MODE_NUNITS (d.vmode);\n+  d.testing_p = false;\n+\n+  for (i = 0; i < nelt; ++i)\n+    d.perm[i] = i * 2 + odd;\n+\n+  /* We'll either be able to implement the permutation directly...  */\n+  if (expand_vec_perm_1 (&d))\n+    return;\n+\n+  /* ... or we use the special-case patterns.  */\n+  expand_vec_perm_even_odd_1 (&d, odd);\n+}\n+\f\n /* This function returns the calling abi specific va_list type node.\n    It returns  the FNDECL specific va_list type.  */\n \n@@ -29254,7 +30373,14 @@ ix86_enum_va_list (int idx, const char **pname, tree *ptree)\n #define TARGET_SECONDARY_RELOAD ix86_secondary_reload\n \n #undef TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST\n-#define TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST x86_builtin_vectorization_cost\n+#define TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST \\\n+  ix86_builtin_vectorization_cost\n+#undef TARGET_VECTORIZE_BUILTIN_VEC_PERM\n+#define TARGET_VECTORIZE_BUILTIN_VEC_PERM \\\n+  ix86_vectorize_builtin_vec_perm\n+#undef TARGET_VECTORIZE_BUILTIN_VEC_PERM_OK\n+#define TARGET_VECTORIZE_BUILTIN_VEC_PERM_OK \\\n+  ix86_vectorize_builtin_vec_perm_ok\n \n #undef TARGET_SET_CURRENT_FUNCTION\n #define TARGET_SET_CURRENT_FUNCTION ix86_set_current_function"}, {"sha": "b4bcc5f673a4d2aec4c715b01fa38b7ed3e054e3", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 39, "deletions": 123, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=0fac51514326c7e8b04d88d22a4ab717bd15d46b", "patch": "@@ -71,6 +71,14 @@\n (define_mode_iterator SSEMODE124C8 [V16QI V8HI V4SI\n \t\t\t\t    (V2DI \"TARGET_SSE4_2\")])\n \n+;; Modes handled by vec_extract_even/odd pattern.\n+(define_mode_iterator SSEMODE_EO\n+  [(V4SF \"TARGET_SSE\")\n+   (V2DF \"TARGET_SSE2\")\n+   (V2DI \"TARGET_SSE2\") (V4SI \"TARGET_SSE2\")\n+   (V8HI \"TARGET_SSE2\") (V16QI \"TARGET_SSE2\")\n+   (V4DF \"TARGET_AVX\") (V8SF \"TARGET_AVX\")])\n+\n ;; Mapping from float mode to required SSE level\n (define_mode_attr sse [(SF \"sse\") (DF \"sse2\") (V4SF \"sse\") (V2DF \"sse2\")])\n \n@@ -4693,48 +4701,24 @@\n })\n \n (define_expand \"vec_extract_even<mode>\"\n-  [(set (match_operand:SSEMODE4S 0 \"register_operand\" \"\")\n-\t(vec_select:SSEMODE4S\n-\t  (vec_concat:<ssedoublesizemode>\n-\t    (match_operand:SSEMODE4S 1 \"register_operand\" \"\")\n-\t    (match_operand:SSEMODE4S 2 \"nonimmediate_operand\" \"\"))\n-\t  (parallel [(const_int 0)\n-\t\t     (const_int 2)\n-\t\t     (const_int 4)\n-\t\t     (const_int 6)])))]\n-  \"TARGET_SSE\")\n-\n-(define_expand \"vec_extract_odd<mode>\"\n-  [(set (match_operand:SSEMODE4S 0 \"register_operand\" \"\")\n-\t(vec_select:SSEMODE4S\n-\t  (vec_concat:<ssedoublesizemode>\n-\t    (match_operand:SSEMODE4S 1 \"register_operand\" \"\")\n-\t    (match_operand:SSEMODE4S 2 \"nonimmediate_operand\" \"\"))\n-\t  (parallel [(const_int 1)\n-\t\t     (const_int 3)\n-\t\t     (const_int 5)\n-\t\t     (const_int 7)])))]\n-  \"TARGET_SSE\")\n-\n-(define_expand \"vec_extract_even<mode>\"\n-  [(set (match_operand:SSEMODE2D 0 \"register_operand\" \"\")\n-\t(vec_select:SSEMODE2D\n-\t  (vec_concat:<ssedoublesizemode>\n-\t    (match_operand:SSEMODE2D 1 \"register_operand\" \"\")\n-\t    (match_operand:SSEMODE2D 2 \"nonimmediate_operand\" \"\"))\n-\t  (parallel [(const_int 0)\n-\t  \t     (const_int 2)])))]\n-  \"TARGET_SSE2\")\n+  [(match_operand:SSEMODE_EO 0 \"register_operand\" \"\")\n+   (match_operand:SSEMODE_EO 1 \"register_operand\" \"\")\n+   (match_operand:SSEMODE_EO 2 \"register_operand\" \"\")]\n+  \"\"\n+{\n+  ix86_expand_vec_extract_even_odd (operands[0], operands[1], operands[2], 0);\n+  DONE;\n+})\n \n (define_expand \"vec_extract_odd<mode>\"\n-  [(set (match_operand:SSEMODE2D 0 \"register_operand\" \"\")\n-\t(vec_select:SSEMODE2D\n-\t  (vec_concat:<ssedoublesizemode>\n-\t    (match_operand:SSEMODE2D 1 \"register_operand\" \"\")\n-\t    (match_operand:SSEMODE2D 2 \"nonimmediate_operand\" \"\"))\n-\t  (parallel [(const_int 1)\n-\t  \t     (const_int 3)])))]\n-  \"TARGET_SSE2\")\n+  [(match_operand:SSEMODE_EO 0 \"register_operand\" \"\")\n+   (match_operand:SSEMODE_EO 1 \"register_operand\" \"\")\n+   (match_operand:SSEMODE_EO 2 \"register_operand\" \"\")]\n+  \"\"\n+{\n+  ix86_expand_vec_extract_even_odd (operands[0], operands[1], operands[2], 1);\n+  DONE;\n+})\n \n ;; punpcklqdq and punpckhqdq are shorter than shufpd.\n (define_insn \"*avx_punpckhqdq\"\n@@ -5243,20 +5227,16 @@\n    (set_attr \"prefix_data16\" \"1\")\n    (set_attr \"mode\" \"TI\")])\n \n-(define_insn_and_split \"mulv16qi3\"\n+(define_expand \"mulv16qi3\"\n   [(set (match_operand:V16QI 0 \"register_operand\" \"\")\n \t(mult:V16QI (match_operand:V16QI 1 \"register_operand\" \"\")\n \t\t    (match_operand:V16QI 2 \"register_operand\" \"\")))]\n-  \"TARGET_SSE2\n-   && can_create_pseudo_p ()\"\n-  \"#\"\n-  \"&& 1\"\n-  [(const_int 0)]\n+  \"TARGET_SSE2\"\n {\n-  rtx t[12];\n+  rtx t[6];\n   int i;\n \n-  for (i = 0; i < 12; ++i)\n+  for (i = 0; i < 6; ++i)\n     t[i] = gen_reg_rtx (V16QImode);\n \n   /* Unpack data such that we've got a source byte in each low byte of\n@@ -5278,15 +5258,8 @@\n \t\t\t   gen_lowpart (V8HImode, t[2]),\n \t\t\t   gen_lowpart (V8HImode, t[3])));\n \n-  /* Extract the relevant bytes and merge them back together.  */\n-  emit_insn (gen_sse2_punpckhbw (t[6], t[5], t[4]));\t/* ..AI..BJ..CK..DL */\n-  emit_insn (gen_sse2_punpcklbw (t[7], t[5], t[4]));\t/* ..EM..FN..GO..HP */\n-  emit_insn (gen_sse2_punpckhbw (t[8], t[7], t[6]));\t/* ....AEIM....BFJN */\n-  emit_insn (gen_sse2_punpcklbw (t[9], t[7], t[6]));\t/* ....CGKO....DHLP */\n-  emit_insn (gen_sse2_punpckhbw (t[10], t[9], t[8]));\t/* ........ACEGIKMO */\n-  emit_insn (gen_sse2_punpcklbw (t[11], t[9], t[8]));\t/* ........BDFHJLNP */\n-\n-  emit_insn (gen_sse2_punpcklbw (operands[0], t[11], t[10]));\t/* ABCDEFGHIJKLMNOP */\n+  /* Extract the even bytes and merge them back together.  */\n+  ix86_expand_vec_extract_even_odd (operands[0], t[5], t[4], 0);\n   DONE;\n })\n \n@@ -6578,96 +6551,39 @@\n ;;\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n \n-;; Reduce:\n-;;      op1 = abcdefghijklmnop\n-;;      op2 = qrstuvwxyz012345\n-;;       h1 = aqbrcsdteufvgwhx\n-;;       l1 = iyjzk0l1m2n3o4p5\n-;;       h2 = aiqybjrzcks0dlt1\n-;;       l2 = emu2fnv3gow4hpx5\n-;;       h3 = aeimquy2bfjnrvz3\n-;;       l3 = cgkosw04dhlptx15\n-;;   result = bdfhjlnprtvxz135\n (define_expand \"vec_pack_trunc_v8hi\"\n   [(match_operand:V16QI 0 \"register_operand\" \"\")\n    (match_operand:V8HI 1 \"register_operand\" \"\")\n    (match_operand:V8HI 2 \"register_operand\" \"\")]\n   \"TARGET_SSE2\"\n {\n-  rtx op1, op2, h1, l1, h2, l2, h3, l3;\n-\n-  op1 = gen_lowpart (V16QImode, operands[1]);\n-  op2 = gen_lowpart (V16QImode, operands[2]);\n-  h1 = gen_reg_rtx (V16QImode);\n-  l1 = gen_reg_rtx (V16QImode);\n-  h2 = gen_reg_rtx (V16QImode);\n-  l2 = gen_reg_rtx (V16QImode);\n-  h3 = gen_reg_rtx (V16QImode);\n-  l3 = gen_reg_rtx (V16QImode);\n-\n-  emit_insn (gen_vec_interleave_highv16qi (h1, op1, op2));\n-  emit_insn (gen_vec_interleave_lowv16qi (l1, op1, op2));\n-  emit_insn (gen_vec_interleave_highv16qi (h2, l1, h1));\n-  emit_insn (gen_vec_interleave_lowv16qi (l2, l1, h1));\n-  emit_insn (gen_vec_interleave_highv16qi (h3, l2, h2));\n-  emit_insn (gen_vec_interleave_lowv16qi (l3, l2, h2));\n-  emit_insn (gen_vec_interleave_lowv16qi (operands[0], l3, h3));\n+  rtx op1 = gen_lowpart (V16QImode, operands[1]);\n+  rtx op2 = gen_lowpart (V16QImode, operands[2]);\n+  ix86_expand_vec_extract_even_odd (operands[0], op1, op2, 0);\n   DONE;\n })\n \n-;; Reduce:\n-;;      op1 = abcdefgh\n-;;      op2 = ijklmnop\n-;;       h1 = aibjckdl\n-;;       l1 = emfngohp\n-;;       h2 = aeimbfjn\n-;;       l2 = cgkodhlp\n-;;   result = bdfhjlnp\n (define_expand \"vec_pack_trunc_v4si\"\n   [(match_operand:V8HI 0 \"register_operand\" \"\")\n    (match_operand:V4SI 1 \"register_operand\" \"\")\n    (match_operand:V4SI 2 \"register_operand\" \"\")]\n   \"TARGET_SSE2\"\n {\n-  rtx op1, op2, h1, l1, h2, l2;\n-\n-  op1 = gen_lowpart (V8HImode, operands[1]);\n-  op2 = gen_lowpart (V8HImode, operands[2]);\n-  h1 = gen_reg_rtx (V8HImode);\n-  l1 = gen_reg_rtx (V8HImode);\n-  h2 = gen_reg_rtx (V8HImode);\n-  l2 = gen_reg_rtx (V8HImode);\n-\n-  emit_insn (gen_vec_interleave_highv8hi (h1, op1, op2));\n-  emit_insn (gen_vec_interleave_lowv8hi (l1, op1, op2));\n-  emit_insn (gen_vec_interleave_highv8hi (h2, l1, h1));\n-  emit_insn (gen_vec_interleave_lowv8hi (l2, l1, h1));\n-  emit_insn (gen_vec_interleave_lowv8hi (operands[0], l2, h2));\n+  rtx op1 = gen_lowpart (V8HImode, operands[1]);\n+  rtx op2 = gen_lowpart (V8HImode, operands[2]);\n+  ix86_expand_vec_extract_even_odd (operands[0], op1, op2, 0);\n   DONE;\n })\n \n-;; Reduce:\n-;;     op1 = abcd\n-;;     op2 = efgh\n-;;      h1 = aebf\n-;;      l1 = cgdh\n-;;  result = bdfh\n (define_expand \"vec_pack_trunc_v2di\"\n   [(match_operand:V4SI 0 \"register_operand\" \"\")\n    (match_operand:V2DI 1 \"register_operand\" \"\")\n    (match_operand:V2DI 2 \"register_operand\" \"\")]\n   \"TARGET_SSE2\"\n {\n-  rtx op1, op2, h1, l1;\n-\n-  op1 = gen_lowpart (V4SImode, operands[1]);\n-  op2 = gen_lowpart (V4SImode, operands[2]);\n-  h1 = gen_reg_rtx (V4SImode);\n-  l1 = gen_reg_rtx (V4SImode);\n-\n-  emit_insn (gen_vec_interleave_highv4si (h1, op1, op2));\n-  emit_insn (gen_vec_interleave_lowv4si (l1, op1, op2));\n-  emit_insn (gen_vec_interleave_lowv4si (operands[0], l1, h1));\n+  rtx op1 = gen_lowpart (V4SImode, operands[1]);\n+  rtx op2 = gen_lowpart (V4SImode, operands[2]);\n+  ix86_expand_vec_extract_even_odd (operands[0], op1, op2, 0);\n   DONE;\n })\n "}, {"sha": "965327c3f93819425799c8c034ea67e0cf6fe6bd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0fac51514326c7e8b04d88d22a4ab717bd15d46b", "patch": "@@ -1,3 +1,18 @@\n+2009-11-25  Richard Henderson  <rth@redhat.com>\n+\n+\t* gcc.dg/vect/slp-21.c: Succeed with vect_extract_even_odd too.\n+\n+\t* lib/target-supports.exp\n+\t(check_effective_target_vect_extract_even_odd): Add x86.\n+\n+\t* gcc.target/i386/isa-check.h: New.\n+\t* gcc.target/i386/vperm-2-2.inc, gcc.target/i386/vperm-4-1.inc,\n+\tgcc.target/i386/vperm-4-2.inc, gcc.target/i386/vperm-v2df.c,\n+\tgcc.target/i386/vperm-v2di.c, gcc.target/i386/vperm-v4sf-1.c,\n+\tgcc.target/i386/vperm-v4sf-2.c, gcc.target/i386/vperm-v4si-1.c,\n+\tgcc.target/i386/vperm-v4si-2.c, gcc.target/i386/vperm-v4si-2x.c,\n+\tgcc.target/i386/vperm.pl: New files.\n+\n 2009-11-25  Richard Henderson  <rth@redhat.com>\n \n \t* gcc.dg/vect/pr36493.c: Call check_vect."}, {"sha": "182ad49939e41999eae3c612e34919aafb1a37b2", "filename": "gcc/testsuite/gcc.dg/vect/slp-21.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-21.c?ref=0fac51514326c7e8b04d88d22a4ab717bd15d46b", "patch": "@@ -200,8 +200,8 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 4 loops\" 1 \"vect\"  { target vect_strided } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target  { ! { vect_strided } } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 4 loops\" 1 \"vect\"  { target { vect_strided || vect_extract_even_odd } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target  { ! { vect_strided || vect_extract_even_odd } } } } } */\n /* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { target vect_strided }  } } */\n /* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\"  { target { ! { vect_strided } } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "8ddbf4dfc2b87805ac06d3ffcd74b7063717b1d1", "filename": "gcc/testsuite/gcc.target/i386/isa-check.h", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fisa-check.h?ref=0fac51514326c7e8b04d88d22a4ab717bd15d46b", "patch": "@@ -0,0 +1,85 @@\n+#include \"cpuid.h\"\n+\n+extern void exit (int) __attribute__((noreturn));\n+\n+/* Determine what instruction set we've been compiled for,\n+   and detect that we're running with it.  */\n+static void __attribute__((constructor))\n+check_isa (void)\n+{\n+  int a, b, c, d;\n+  int c1, d1, c1e, d1e;\n+\n+  c1 = d1 = c1e = d1e = 0;\n+\n+#ifdef __MMX__\n+  d1 |= bit_MMX;\n+#endif\n+#ifdef __3dNOW__\n+  d1e |= bit_3DNOW;\n+#endif\n+#ifdef __3dNOW_A__\n+  d1e |= bit_3DNOWP;\n+#endif\n+#ifdef __SSE__\n+  d1 |= bit_SSE;\n+#endif\n+#ifdef __SSE2__\n+  d1 |= bit_SSE2;\n+#endif\n+#ifdef __SSE3__\n+  c1 |= bit_SSE3;\n+#endif\n+#ifdef __SSSE3__\n+  c1 |= bit_SSSE3;\n+#endif\n+#ifdef __SSE4_1__\n+  c1 |= bit_SSE4_1;\n+#endif\n+#ifdef __SSE4_2__\n+  c1 |= bit_SSE4_2;\n+#endif\n+#ifdef __AES__\n+  c1 |= bit_AES;\n+#endif\n+#ifdef __PCLMUL__\n+  c1 |= bit_PCLMUL;\n+#endif\n+#ifdef __AVX__\n+  c1 |= bit_AVX;\n+#endif\n+#ifdef __FMA__\n+  c1 |= bit_FMA;\n+#endif\n+#ifdef __SSE4A__\n+  c1e |= bit_SSE4a;\n+#endif\n+#ifdef __FMA4__\n+  c1e |= bit_FMA4;\n+#endif\n+#ifdef __XOP__\n+  c1e |= bit_XOP;\n+#endif\n+#ifdef __LWP__\n+  c1e |= bit_LWP;\n+#endif\n+\n+  if (c1 | d1)\n+    {\n+      if (!__get_cpuid (1, &a, &b, &c, &d))\n+\tgoto fail;\n+      if ((c & c1) != c1 || (d & d1) != d1)\n+\tgoto fail;\n+    }\n+  if (c1e | d1e)\n+    {\n+      if (!__get_cpuid (0x80000001, &a, &b, &c, &d))\n+\tgoto fail;\n+      if ((c & c1e) != c1e || (d & d1e) != d1e)\n+\tgoto fail;\n+    }\n+  return;\n+\n+ fail:\n+  exit (0);\n+}"}, {"sha": "ef66f68089f430a3e73f1c60a918797efda97b0e", "filename": "gcc/testsuite/gcc.target/i386/vperm-2-2.inc", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-2-2.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-2-2.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-2-2.inc?ref=0fac51514326c7e8b04d88d22a4ab717bd15d46b", "patch": "@@ -0,0 +1,27 @@\n+/* This file auto-generated with ./vperm.pl 2 2.  */\n+\n+void check0(void)\n+{\n+  TEST (0, 0)\n+  TEST (1, 0)\n+  TEST (2, 0)\n+  TEST (3, 0)\n+  TEST (0, 1)\n+  TEST (1, 1)\n+  TEST (2, 1)\n+  TEST (3, 1)\n+  TEST (0, 2)\n+  TEST (1, 2)\n+  TEST (2, 2)\n+  TEST (3, 2)\n+  TEST (0, 3)\n+  TEST (1, 3)\n+  TEST (2, 3)\n+  TEST (3, 3)\n+}\n+\n+void check(void)\n+{\n+  check0 ();\n+}\n+"}, {"sha": "c04f1856fb48c5c7bc5ceb1a997c2323cc3e0fa5", "filename": "gcc/testsuite/gcc.target/i386/vperm-4-1.inc", "status": "added", "additions": 272, "deletions": 0, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-4-1.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-4-1.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-4-1.inc?ref=0fac51514326c7e8b04d88d22a4ab717bd15d46b", "patch": "@@ -0,0 +1,272 @@\n+/* This file auto-generated with ./vperm.pl 4 1.  */\n+\n+void check0(void)\n+{\n+  TEST (0, 0, 0, 0)\n+  TEST (1, 0, 0, 0)\n+  TEST (2, 0, 0, 0)\n+  TEST (3, 0, 0, 0)\n+  TEST (0, 1, 0, 0)\n+  TEST (1, 1, 0, 0)\n+  TEST (2, 1, 0, 0)\n+  TEST (3, 1, 0, 0)\n+  TEST (0, 2, 0, 0)\n+  TEST (1, 2, 0, 0)\n+  TEST (2, 2, 0, 0)\n+  TEST (3, 2, 0, 0)\n+  TEST (0, 3, 0, 0)\n+  TEST (1, 3, 0, 0)\n+  TEST (2, 3, 0, 0)\n+  TEST (3, 3, 0, 0)\n+  TEST (0, 0, 1, 0)\n+  TEST (1, 0, 1, 0)\n+  TEST (2, 0, 1, 0)\n+  TEST (3, 0, 1, 0)\n+  TEST (0, 1, 1, 0)\n+  TEST (1, 1, 1, 0)\n+  TEST (2, 1, 1, 0)\n+  TEST (3, 1, 1, 0)\n+  TEST (0, 2, 1, 0)\n+  TEST (1, 2, 1, 0)\n+  TEST (2, 2, 1, 0)\n+  TEST (3, 2, 1, 0)\n+  TEST (0, 3, 1, 0)\n+  TEST (1, 3, 1, 0)\n+  TEST (2, 3, 1, 0)\n+  TEST (3, 3, 1, 0)\n+  TEST (0, 0, 2, 0)\n+  TEST (1, 0, 2, 0)\n+  TEST (2, 0, 2, 0)\n+  TEST (3, 0, 2, 0)\n+  TEST (0, 1, 2, 0)\n+  TEST (1, 1, 2, 0)\n+  TEST (2, 1, 2, 0)\n+  TEST (3, 1, 2, 0)\n+  TEST (0, 2, 2, 0)\n+  TEST (1, 2, 2, 0)\n+  TEST (2, 2, 2, 0)\n+  TEST (3, 2, 2, 0)\n+  TEST (0, 3, 2, 0)\n+  TEST (1, 3, 2, 0)\n+  TEST (2, 3, 2, 0)\n+  TEST (3, 3, 2, 0)\n+  TEST (0, 0, 3, 0)\n+  TEST (1, 0, 3, 0)\n+  TEST (2, 0, 3, 0)\n+  TEST (3, 0, 3, 0)\n+  TEST (0, 1, 3, 0)\n+  TEST (1, 1, 3, 0)\n+  TEST (2, 1, 3, 0)\n+  TEST (3, 1, 3, 0)\n+  TEST (0, 2, 3, 0)\n+  TEST (1, 2, 3, 0)\n+  TEST (2, 2, 3, 0)\n+  TEST (3, 2, 3, 0)\n+  TEST (0, 3, 3, 0)\n+  TEST (1, 3, 3, 0)\n+  TEST (2, 3, 3, 0)\n+  TEST (3, 3, 3, 0)\n+  TEST (0, 0, 0, 1)\n+  TEST (1, 0, 0, 1)\n+  TEST (2, 0, 0, 1)\n+  TEST (3, 0, 0, 1)\n+  TEST (0, 1, 0, 1)\n+  TEST (1, 1, 0, 1)\n+  TEST (2, 1, 0, 1)\n+  TEST (3, 1, 0, 1)\n+  TEST (0, 2, 0, 1)\n+  TEST (1, 2, 0, 1)\n+  TEST (2, 2, 0, 1)\n+  TEST (3, 2, 0, 1)\n+  TEST (0, 3, 0, 1)\n+  TEST (1, 3, 0, 1)\n+  TEST (2, 3, 0, 1)\n+  TEST (3, 3, 0, 1)\n+  TEST (0, 0, 1, 1)\n+  TEST (1, 0, 1, 1)\n+  TEST (2, 0, 1, 1)\n+  TEST (3, 0, 1, 1)\n+  TEST (0, 1, 1, 1)\n+  TEST (1, 1, 1, 1)\n+  TEST (2, 1, 1, 1)\n+  TEST (3, 1, 1, 1)\n+  TEST (0, 2, 1, 1)\n+  TEST (1, 2, 1, 1)\n+  TEST (2, 2, 1, 1)\n+  TEST (3, 2, 1, 1)\n+  TEST (0, 3, 1, 1)\n+  TEST (1, 3, 1, 1)\n+  TEST (2, 3, 1, 1)\n+  TEST (3, 3, 1, 1)\n+  TEST (0, 0, 2, 1)\n+  TEST (1, 0, 2, 1)\n+  TEST (2, 0, 2, 1)\n+  TEST (3, 0, 2, 1)\n+  TEST (0, 1, 2, 1)\n+  TEST (1, 1, 2, 1)\n+  TEST (2, 1, 2, 1)\n+  TEST (3, 1, 2, 1)\n+  TEST (0, 2, 2, 1)\n+  TEST (1, 2, 2, 1)\n+  TEST (2, 2, 2, 1)\n+  TEST (3, 2, 2, 1)\n+  TEST (0, 3, 2, 1)\n+  TEST (1, 3, 2, 1)\n+  TEST (2, 3, 2, 1)\n+  TEST (3, 3, 2, 1)\n+  TEST (0, 0, 3, 1)\n+  TEST (1, 0, 3, 1)\n+  TEST (2, 0, 3, 1)\n+  TEST (3, 0, 3, 1)\n+  TEST (0, 1, 3, 1)\n+  TEST (1, 1, 3, 1)\n+  TEST (2, 1, 3, 1)\n+  TEST (3, 1, 3, 1)\n+  TEST (0, 2, 3, 1)\n+  TEST (1, 2, 3, 1)\n+  TEST (2, 2, 3, 1)\n+  TEST (3, 2, 3, 1)\n+  TEST (0, 3, 3, 1)\n+  TEST (1, 3, 3, 1)\n+  TEST (2, 3, 3, 1)\n+  TEST (3, 3, 3, 1)\n+}\n+\n+void check1(void)\n+{\n+  TEST (0, 0, 0, 2)\n+  TEST (1, 0, 0, 2)\n+  TEST (2, 0, 0, 2)\n+  TEST (3, 0, 0, 2)\n+  TEST (0, 1, 0, 2)\n+  TEST (1, 1, 0, 2)\n+  TEST (2, 1, 0, 2)\n+  TEST (3, 1, 0, 2)\n+  TEST (0, 2, 0, 2)\n+  TEST (1, 2, 0, 2)\n+  TEST (2, 2, 0, 2)\n+  TEST (3, 2, 0, 2)\n+  TEST (0, 3, 0, 2)\n+  TEST (1, 3, 0, 2)\n+  TEST (2, 3, 0, 2)\n+  TEST (3, 3, 0, 2)\n+  TEST (0, 0, 1, 2)\n+  TEST (1, 0, 1, 2)\n+  TEST (2, 0, 1, 2)\n+  TEST (3, 0, 1, 2)\n+  TEST (0, 1, 1, 2)\n+  TEST (1, 1, 1, 2)\n+  TEST (2, 1, 1, 2)\n+  TEST (3, 1, 1, 2)\n+  TEST (0, 2, 1, 2)\n+  TEST (1, 2, 1, 2)\n+  TEST (2, 2, 1, 2)\n+  TEST (3, 2, 1, 2)\n+  TEST (0, 3, 1, 2)\n+  TEST (1, 3, 1, 2)\n+  TEST (2, 3, 1, 2)\n+  TEST (3, 3, 1, 2)\n+  TEST (0, 0, 2, 2)\n+  TEST (1, 0, 2, 2)\n+  TEST (2, 0, 2, 2)\n+  TEST (3, 0, 2, 2)\n+  TEST (0, 1, 2, 2)\n+  TEST (1, 1, 2, 2)\n+  TEST (2, 1, 2, 2)\n+  TEST (3, 1, 2, 2)\n+  TEST (0, 2, 2, 2)\n+  TEST (1, 2, 2, 2)\n+  TEST (2, 2, 2, 2)\n+  TEST (3, 2, 2, 2)\n+  TEST (0, 3, 2, 2)\n+  TEST (1, 3, 2, 2)\n+  TEST (2, 3, 2, 2)\n+  TEST (3, 3, 2, 2)\n+  TEST (0, 0, 3, 2)\n+  TEST (1, 0, 3, 2)\n+  TEST (2, 0, 3, 2)\n+  TEST (3, 0, 3, 2)\n+  TEST (0, 1, 3, 2)\n+  TEST (1, 1, 3, 2)\n+  TEST (2, 1, 3, 2)\n+  TEST (3, 1, 3, 2)\n+  TEST (0, 2, 3, 2)\n+  TEST (1, 2, 3, 2)\n+  TEST (2, 2, 3, 2)\n+  TEST (3, 2, 3, 2)\n+  TEST (0, 3, 3, 2)\n+  TEST (1, 3, 3, 2)\n+  TEST (2, 3, 3, 2)\n+  TEST (3, 3, 3, 2)\n+  TEST (0, 0, 0, 3)\n+  TEST (1, 0, 0, 3)\n+  TEST (2, 0, 0, 3)\n+  TEST (3, 0, 0, 3)\n+  TEST (0, 1, 0, 3)\n+  TEST (1, 1, 0, 3)\n+  TEST (2, 1, 0, 3)\n+  TEST (3, 1, 0, 3)\n+  TEST (0, 2, 0, 3)\n+  TEST (1, 2, 0, 3)\n+  TEST (2, 2, 0, 3)\n+  TEST (3, 2, 0, 3)\n+  TEST (0, 3, 0, 3)\n+  TEST (1, 3, 0, 3)\n+  TEST (2, 3, 0, 3)\n+  TEST (3, 3, 0, 3)\n+  TEST (0, 0, 1, 3)\n+  TEST (1, 0, 1, 3)\n+  TEST (2, 0, 1, 3)\n+  TEST (3, 0, 1, 3)\n+  TEST (0, 1, 1, 3)\n+  TEST (1, 1, 1, 3)\n+  TEST (2, 1, 1, 3)\n+  TEST (3, 1, 1, 3)\n+  TEST (0, 2, 1, 3)\n+  TEST (1, 2, 1, 3)\n+  TEST (2, 2, 1, 3)\n+  TEST (3, 2, 1, 3)\n+  TEST (0, 3, 1, 3)\n+  TEST (1, 3, 1, 3)\n+  TEST (2, 3, 1, 3)\n+  TEST (3, 3, 1, 3)\n+  TEST (0, 0, 2, 3)\n+  TEST (1, 0, 2, 3)\n+  TEST (2, 0, 2, 3)\n+  TEST (3, 0, 2, 3)\n+  TEST (0, 1, 2, 3)\n+  TEST (1, 1, 2, 3)\n+  TEST (2, 1, 2, 3)\n+  TEST (3, 1, 2, 3)\n+  TEST (0, 2, 2, 3)\n+  TEST (1, 2, 2, 3)\n+  TEST (2, 2, 2, 3)\n+  TEST (3, 2, 2, 3)\n+  TEST (0, 3, 2, 3)\n+  TEST (1, 3, 2, 3)\n+  TEST (2, 3, 2, 3)\n+  TEST (3, 3, 2, 3)\n+  TEST (0, 0, 3, 3)\n+  TEST (1, 0, 3, 3)\n+  TEST (2, 0, 3, 3)\n+  TEST (3, 0, 3, 3)\n+  TEST (0, 1, 3, 3)\n+  TEST (1, 1, 3, 3)\n+  TEST (2, 1, 3, 3)\n+  TEST (3, 1, 3, 3)\n+  TEST (0, 2, 3, 3)\n+  TEST (1, 2, 3, 3)\n+  TEST (2, 2, 3, 3)\n+  TEST (3, 2, 3, 3)\n+  TEST (0, 3, 3, 3)\n+  TEST (1, 3, 3, 3)\n+  TEST (2, 3, 3, 3)\n+  TEST (3, 3, 3, 3)\n+}\n+\n+void check(void)\n+{\n+  check0 ();\n+  check1 ();\n+}\n+"}, {"sha": "2f7baa0ed08495fcd3057b807e1dd67230a2d072", "filename": "gcc/testsuite/gcc.target/i386/vperm-4-2.inc", "status": "added", "additions": 4262, "deletions": 0, "changes": 4262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-4-2.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-4-2.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-4-2.inc?ref=0fac51514326c7e8b04d88d22a4ab717bd15d46b"}, {"sha": "f17e065e328bdcaa16df189ecdc9c386f69fb174", "filename": "gcc/testsuite/gcc.target/i386/vperm-v2df.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v2df.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v2df.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v2df.c?ref=0fac51514326c7e8b04d88d22a4ab717bd15d46b", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O -msse2\" } */\n+\n+#include \"isa-check.h\"\n+\n+typedef double S;\n+typedef double V __attribute__((vector_size(16)));\n+typedef long long IV __attribute__((vector_size(16)));\n+typedef union { S s[2]; V v; } U;\n+\n+static U i[2], b, c;\n+\n+extern int memcmp (const void *, const void *, __SIZE_TYPE__);\n+#define assert(T) ((T) || (__builtin_trap (), 0))\n+\n+#define TEST(E0, E1) \\\n+  b.v = __builtin_ia32_vec_perm_v2df (i[0].v, i[1].v, (IV){E0, E1}); \\\n+  c.s[0] = i[0].s[E0]; \\\n+  c.s[1] = i[0].s[E1]; \\\n+  __asm__(\"\" : : : \"memory\"); \\\n+  assert (memcmp (&b, &c, sizeof(c)) == 0);\n+\n+#include \"vperm-2-2.inc\"\n+\n+int main()\n+{\n+  i[0].s[0] = 0;\n+  i[0].s[1] = 1;\n+  i[0].s[2] = 2;\n+  i[0].s[3] = 3;\n+\n+  check();\n+  return 0;\n+}"}, {"sha": "c6fe5611f66df2334cddc1fb73a077aee2f6823b", "filename": "gcc/testsuite/gcc.target/i386/vperm-v2di.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v2di.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v2di.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v2di.c?ref=0fac51514326c7e8b04d88d22a4ab717bd15d46b", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O -msse2\" } */\n+\n+#include \"isa-check.h\"\n+\n+typedef long long S;\n+typedef long long V __attribute__((vector_size(16)));\n+typedef long long IV __attribute__((vector_size(16)));\n+typedef union { S s[2]; V v; } U;\n+\n+static U i[2], b, c;\n+\n+extern int memcmp (const void *, const void *, __SIZE_TYPE__);\n+#define assert(T) ((T) || (__builtin_trap (), 0))\n+\n+#define TEST(E0, E1) \\\n+  b.v = __builtin_ia32_vec_perm_v2di (i[0].v, i[1].v, (IV){E0, E1}); \\\n+  c.s[0] = i[0].s[E0]; \\\n+  c.s[1] = i[0].s[E1]; \\\n+  __asm__(\"\" : : : \"memory\"); \\\n+  assert (memcmp (&b, &c, sizeof(c)) == 0);\n+\n+#include \"vperm-2-2.inc\"\n+\n+int main()\n+{\n+  i[0].s[0] = 0;\n+  i[0].s[1] = 1;\n+  i[0].s[2] = 2;\n+  i[0].s[3] = 3;\n+\n+  check();\n+  return 0;\n+}"}, {"sha": "b9fc9b172fef644d0b25fe484cd25628f3c19724", "filename": "gcc/testsuite/gcc.target/i386/vperm-v4sf-1.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v4sf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v4sf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v4sf-1.c?ref=0fac51514326c7e8b04d88d22a4ab717bd15d46b", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O -msse\" } */\n+\n+#include \"isa-check.h\"\n+\n+typedef float S;\n+typedef float V __attribute__((vector_size(16)));\n+typedef int IV __attribute__((vector_size(16)));\n+typedef union { S s[4]; V v; } U;\n+\n+static U i[2], b, c;\n+\n+extern int memcmp (const void *, const void *, __SIZE_TYPE__);\n+#define assert(T) ((T) || (__builtin_trap (), 0))\n+\n+#define TEST(E0, E1, E2, E3) \\\n+  b.v = __builtin_ia32_vec_perm_v4sf (i[0].v, i[1].v, (IV){E0, E1, E2, E3}); \\\n+  c.s[0] = i[0].s[E0]; \\\n+  c.s[1] = i[0].s[E1]; \\\n+  c.s[2] = i[0].s[E2]; \\\n+  c.s[3] = i[0].s[E3]; \\\n+  __asm__(\"\" : : : \"memory\"); \\\n+  assert (memcmp (&b, &c, sizeof(c)) == 0);\n+\n+#include \"vperm-4-1.inc\"\n+\n+int main()\n+{\n+  i[0].s[0] = 0;\n+  i[0].s[1] = 1;\n+  i[0].s[2] = 2;\n+  i[0].s[3] = 3;\n+  i[0].s[4] = 4;\n+  i[0].s[5] = 5;\n+  i[0].s[6] = 6;\n+  i[0].s[7] = 7;\n+\n+  check();\n+  return 0;\n+}"}, {"sha": "f81d24141f7b067f97c2effed3a7e5c630612556", "filename": "gcc/testsuite/gcc.target/i386/vperm-v4sf-2.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v4sf-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v4sf-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v4sf-2.c?ref=0fac51514326c7e8b04d88d22a4ab717bd15d46b", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O -mssse3\" } */\n+\n+#include \"isa-check.h\"\n+\n+typedef float S;\n+typedef float V __attribute__((vector_size(16)));\n+typedef int IV __attribute__((vector_size(16)));\n+typedef union { S s[4]; V v; } U;\n+\n+static U i[2], b, c;\n+\n+extern int memcmp (const void *, const void *, __SIZE_TYPE__);\n+#define assert(T) ((T) || (__builtin_trap (), 0))\n+\n+#define TEST(E0, E1, E2, E3) \\\n+  b.v = __builtin_ia32_vec_perm_v4sf (i[0].v, i[1].v, (IV){E0, E1, E2, E3}); \\\n+  c.s[0] = i[0].s[E0]; \\\n+  c.s[1] = i[0].s[E1]; \\\n+  c.s[2] = i[0].s[E2]; \\\n+  c.s[3] = i[0].s[E3]; \\\n+  __asm__(\"\" : : : \"memory\"); \\\n+  assert (memcmp (&b, &c, sizeof(c)) == 0);\n+\n+#include \"vperm-4-2.inc\"\n+\n+int main()\n+{\n+  i[0].s[0] = 0;\n+  i[0].s[1] = 1;\n+  i[0].s[2] = 2;\n+  i[0].s[3] = 3;\n+  i[0].s[4] = 4;\n+  i[0].s[5] = 5;\n+  i[0].s[6] = 6;\n+  i[0].s[7] = 7;\n+\n+  check();\n+  return 0;\n+}"}, {"sha": "663feb3f4880add3baaa4ecaee715f569b28320a", "filename": "gcc/testsuite/gcc.target/i386/vperm-v4si-1.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v4si-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v4si-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v4si-1.c?ref=0fac51514326c7e8b04d88d22a4ab717bd15d46b", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O -msse2\" } */\n+\n+#include \"isa-check.h\"\n+\n+typedef int S;\n+typedef int V __attribute__((vector_size(16)));\n+typedef int IV __attribute__((vector_size(16)));\n+typedef union { S s[4]; V v; } U;\n+\n+static U i[2], b, c;\n+\n+extern int memcmp (const void *, const void *, __SIZE_TYPE__);\n+#define assert(T) ((T) || (__builtin_trap (), 0))\n+\n+#define TEST(E0, E1, E2, E3) \\\n+  b.v = __builtin_ia32_vec_perm_v4si (i[0].v, i[1].v, (IV){E0, E1, E2, E3}); \\\n+  c.s[0] = i[0].s[E0]; \\\n+  c.s[1] = i[0].s[E1]; \\\n+  c.s[2] = i[0].s[E2]; \\\n+  c.s[3] = i[0].s[E3]; \\\n+  __asm__(\"\" : : : \"memory\"); \\\n+  assert (memcmp (&b, &c, sizeof(c)) == 0);\n+\n+#include \"vperm-4-1.inc\"\n+\n+int main()\n+{\n+  i[0].s[0] = 0;\n+  i[0].s[1] = 1;\n+  i[0].s[2] = 2;\n+  i[0].s[3] = 3;\n+  i[0].s[4] = 4;\n+  i[0].s[5] = 5;\n+  i[0].s[6] = 6;\n+  i[0].s[7] = 7;\n+\n+  check();\n+  return 0;\n+}"}, {"sha": "0da953bdd525be7ab16e70778f5a4c951ab5dbc7", "filename": "gcc/testsuite/gcc.target/i386/vperm-v4si-2.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v4si-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v4si-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v4si-2.c?ref=0fac51514326c7e8b04d88d22a4ab717bd15d46b", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O -mssse3\" } */\n+\n+#include \"isa-check.h\"\n+\n+typedef int S;\n+typedef int V __attribute__((vector_size(16)));\n+typedef int IV __attribute__((vector_size(16)));\n+typedef union { S s[4]; V v; } U;\n+\n+static U i[2], b, c;\n+\n+extern int memcmp (const void *, const void *, __SIZE_TYPE__);\n+#define assert(T) ((T) || (__builtin_trap (), 0))\n+\n+#define TEST(E0, E1, E2, E3) \\\n+  b.v = __builtin_ia32_vec_perm_v4si (i[0].v, i[1].v, (IV){E0, E1, E2, E3}); \\\n+  c.s[0] = i[0].s[E0]; \\\n+  c.s[1] = i[0].s[E1]; \\\n+  c.s[2] = i[0].s[E2]; \\\n+  c.s[3] = i[0].s[E3]; \\\n+  __asm__(\"\" : : : \"memory\"); \\\n+  assert (memcmp (&b, &c, sizeof(c)) == 0);\n+\n+#include \"vperm-4-2.inc\"\n+\n+int main()\n+{\n+  i[0].s[0] = 0;\n+  i[0].s[1] = 1;\n+  i[0].s[2] = 2;\n+  i[0].s[3] = 3;\n+  i[0].s[4] = 4;\n+  i[0].s[5] = 5;\n+  i[0].s[6] = 6;\n+  i[0].s[7] = 7;\n+\n+  check();\n+  return 0;\n+}"}, {"sha": "4410d93a6545cb15fc487b5371a5823a35179a87", "filename": "gcc/testsuite/gcc.target/i386/vperm-v4si-2x.c", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v4si-2x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v4si-2x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm-v4si-2x.c?ref=0fac51514326c7e8b04d88d22a4ab717bd15d46b", "patch": "@@ -0,0 +1,3 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O -mxop\" } */\n+#include \"vperm-v4si-2.c\""}, {"sha": "80fae9daa4fc0e51b55b3e8f583d49f4017939d5", "filename": "gcc/testsuite/gcc.target/i386/vperm.pl", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm.pl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm.pl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvperm.pl?ref=0fac51514326c7e8b04d88d22a4ab717bd15d46b", "patch": "@@ -0,0 +1,41 @@\n+#!/usr/bin/perl\n+\n+$nelt = int($ARGV[0]);\n+$leng = int($ARGV[1]);\n+\n+print \"/* This file auto-generated with ./vperm.pl $nelt $leng.  */\\n\\n\";\n+\n+for ($i = 0; $i < $nelt; ++$i) { $perm[$i] = 0; }\n+$ncheck = 0;\n+\n+for ($i = 0; $i < ($leng * $nelt) ** $nelt; ++$i)\n+{\n+  if ($i % 128 == 0)\n+  {\n+    print \"}\\n\\n\" if $ncheck > 0;\n+    print \"void check$ncheck(void)\\n{\\n\";\n+    ++$ncheck;\n+  }\n+\n+  print \"  TEST (\";\n+  for ($j = 0; $j < $nelt; ++$j)\n+  {\n+    print $perm[$j];\n+    print \", \" if $j < $nelt - 1;\n+  }\n+  print \")\\n\";\n+\n+  INCR: for ($j = 0; $j < $nelt; ++$j)\n+  {\n+    last INCR if ++$perm[$j] < $leng * $nelt;\n+    $perm[$j] = 0;\n+  }\n+}\n+print \"}\\n\\n\";\n+\n+print \"void check(void)\\n{\\n\";\n+for ($i = 0; $i < $ncheck; ++$i)\n+{\n+  print \"  check$i ();\\n\";\n+}\n+print \"}\\n\\n\";"}, {"sha": "5155cba65ee17ef9a7b880ea2e3b4159ac465797", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fac51514326c7e8b04d88d22a4ab717bd15d46b/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=0fac51514326c7e8b04d88d22a4ab717bd15d46b", "patch": "@@ -2562,7 +2562,9 @@ proc check_effective_target_vect_extract_even_odd { } {\n         verbose \"check_effective_target_vect_extract_even_odd: using cached result\" 2\n     } else {\n         set et_vect_extract_even_odd_saved 0 \n-        if { [istarget powerpc*-*-*]\n+        if { [istarget powerpc*-*-*] \n+             || [istarget i?86-*-*]\n+             || [istarget x86_64-*-*]\n              || [istarget spu-*-*] } {\n            set et_vect_extract_even_odd_saved 1\n         }"}]}