{"sha": "7fa96708480ddcc02a9e4995bd0dac85678124eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ZhOTY3MDg0ODBkZGNjMDJhOWU0OTk1YmQwZGFjODU2NzgxMjRlYg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-03-30T22:17:51Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-03-30T22:17:51Z"}, "message": "expr.c (store_constructor): Properly compute displacement and alignment when offset is variable.\n\n\t* expr.c (store_constructor): Properly compute displacement and\n\talignment when offset is variable.\n\nFrom-SVN: r32837", "tree": {"sha": "518fb401e070b0e836893395de180122a5622ad4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/518fb401e070b0e836893395de180122a5622ad4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7fa96708480ddcc02a9e4995bd0dac85678124eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fa96708480ddcc02a9e4995bd0dac85678124eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fa96708480ddcc02a9e4995bd0dac85678124eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fa96708480ddcc02a9e4995bd0dac85678124eb/comments", "author": null, "committer": null, "parents": [{"sha": "0e805f815e91234061a8e8380f60f479dcbb9cdf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e805f815e91234061a8e8380f60f479dcbb9cdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e805f815e91234061a8e8380f60f479dcbb9cdf"}], "stats": {"total": 14, "additions": 6, "deletions": 8}, "files": [{"sha": "a9e54e22d8271af82edba8534f11619514b0ee5a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fa96708480ddcc02a9e4995bd0dac85678124eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fa96708480ddcc02a9e4995bd0dac85678124eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7fa96708480ddcc02a9e4995bd0dac85678124eb", "patch": "@@ -1,5 +1,8 @@\n Thu Mar 30 06:32:51 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* expr.c (store_constructor): Properly compute displacement and\n+\talignment when offset is variable.\n+\n \t* expmed.c (store_bit_field, store_fixed_bit_field): Fix more\n \tcases of alignment in bytes.\n "}, {"sha": "c1866a5556c7fc5ea1936c28a950ea891a5944b7", "filename": "gcc/expr.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fa96708480ddcc02a9e4995bd0dac85678124eb/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fa96708480ddcc02a9e4995bd0dac85678124eb/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=7fa96708480ddcc02a9e4995bd0dac85678124eb", "patch": "@@ -4244,12 +4244,9 @@ store_constructor (exp, target, align, cleared, size)\n \t      rtx offset_rtx;\n \n \t      if (contains_placeholder_p (offset))\n-\t\toffset = build (WITH_RECORD_EXPR, bitsizetype,\n+\t\toffset = build (WITH_RECORD_EXPR, sizetype,\n \t\t\t\toffset, make_tree (TREE_TYPE (exp), target));\n \n-\t      offset = size_binop (EXACT_DIV_EXPR, offset, bitsize_unit_node);\n-\t      offset = convert (sizetype, offset);\n-\n \t      offset_rtx = expand_expr (offset, NULL_RTX, VOIDmode, 0);\n \t      if (GET_CODE (to_rtx) != MEM)\n \t\tabort ();\n@@ -4268,6 +4265,7 @@ store_constructor (exp, target, align, cleared, size)\n \t\t\t\t  gen_rtx_PLUS (ptr_mode, XEXP (to_rtx, 0),\n \t\t\t\t\t\tforce_reg (ptr_mode,\n \t\t\t\t\t\t\t   offset_rtx)));\n+\t      align = DECL_OFFSET_ALIGN (field);\n \t    }\n \n \t  if (TREE_READONLY (field))\n@@ -4306,10 +4304,7 @@ store_constructor (exp, target, align, cleared, size)\n \t    }\n #endif\n \t  store_constructor_field (to_rtx, bitsize, bitpos, mode,\n-\t\t\t\t   TREE_VALUE (elt), type, \n-\t\t\t\t   MIN (align,\n-\t\t\t\t\tDECL_ALIGN (TREE_PURPOSE (elt))),\n-\t\t\t\t   cleared);\n+\t\t\t\t   TREE_VALUE (elt), type, align, cleared);\n \t}\n     }\n   else if (TREE_CODE (type) == ARRAY_TYPE)"}]}