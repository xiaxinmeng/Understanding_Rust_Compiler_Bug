{"sha": "8704d4b30e3eace58fc9506cf3533b15835c784a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODcwNGQ0YjMwZTNlYWNlNThmYzk1MDZjZjM1MzNiMTU4MzVjNzg0YQ==", "commit": {"author": {"name": "Matthew Heaney", "email": "heaney@adacore.com", "date": "2005-06-16T08:56:24Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-06-16T08:56:24Z"}, "message": "a-swunha.ads, [...]: Removed.\n\n2005-06-14  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-swunha.ads, a-swunha.adb: Removed. Replaced by a-swuwha.ad[sb]\n\t* a-swuwha.ads, a-swuwha.adb: New files\n\n\t* a-szunha.ads, a-szunha.adb: Removed, replaced by a-szuzha.ad[sb]\n\t* a-szuzha.ads, a-szuzha.adb: New files.\n\n\t* a-rbtgso.adb, a-crbtgo.ads, a-crbtgo.adb, a-crbtgk.ads,\n\ta-crbtgk.adb, a-crbltr.ads, a-coorse.ads, a-coorse.adb, a-convec.ads,\n\ta-convec.adb, a-coinve.ads, a-coinve.adb, a-cohata.ads, a-cohama.ads,\n\ta-cohama.adb, a-ciorse.ads, a-ciorse.adb, a-cihama.ads, a-cihama.adb,\n\ta-cidlli.ads, a-cidlli.adb, a-chtgop.ads, a-chtgop.adb, a-cdlili.ads,\n\ta-cdlili.adb, a-coormu.adb, a-ciormu.adb, a-cihase.adb, a-cohase.adb,\n\ta-cohase.ads, a-ciorma.ads, a-coorma.ads, a-ciormu.ads, a-coormu.ads,\n\ta-swunha.adb, a-stunha.adb, a-ciorma.adb, a-coorma.adb, a-shcain.ads,\n\ta-shcain.adb, a-chtgke.ads, a-chtgke.adb, a-stwiha.ads, a-stwiha.adb,\n\ta-strhas.adb, a-stzhas.adb: synchronized to the latest version of the\n\tAda 2005 RM.\n\nFrom-SVN: r101069", "tree": {"sha": "60bbc3a40631ce4a825ff74330cd04720cf0d624", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60bbc3a40631ce4a825ff74330cd04720cf0d624"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8704d4b30e3eace58fc9506cf3533b15835c784a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8704d4b30e3eace58fc9506cf3533b15835c784a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8704d4b30e3eace58fc9506cf3533b15835c784a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8704d4b30e3eace58fc9506cf3533b15835c784a/comments", "author": null, "committer": null, "parents": [{"sha": "dc8f57914cb54a209cf2d52bb04d21502990842b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc8f57914cb54a209cf2d52bb04d21502990842b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc8f57914cb54a209cf2d52bb04d21502990842b"}], "stats": {"total": 17608, "additions": 10457, "deletions": 7151}, "files": [{"sha": "a9801e22c3c07423b560e1443f57aad5a10032a2", "filename": "gcc/ada/a-cdlili.adb", "status": "modified", "additions": 872, "deletions": 279, "changes": 1151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-cdlili.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-cdlili.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cdlili.adb?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---                    ADA.CONTAINERS.DOUBLY_LINKED_LISTS                    --\n+--   A D A . C O N T A I N E R S . D O U B L Y _ L I N K E D _ L I S T S    --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -45,10 +45,6 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    -- Local Subprograms --\n    -----------------------\n \n-   procedure Delete_Node\n-     (Container : in out List;\n-      Node      : in out Node_Access);\n-\n    procedure Insert_Internal\n      (Container : in out List;\n       Before    : Node_Access;\n@@ -88,38 +84,42 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    ------------\n \n    procedure Adjust (Container : in out List) is\n-      Src    : Node_Access := Container.First;\n-      Length : constant Count_Type := Container.Length;\n+      Src : Node_Access := Container.First;\n \n    begin\n       if Src = null then\n          pragma Assert (Container.Last = null);\n-         pragma Assert (Length = 0);\n+         pragma Assert (Container.Length = 0);\n+         pragma Assert (Container.Busy = 0);\n+         pragma Assert (Container.Lock = 0);\n          return;\n       end if;\n \n       pragma Assert (Container.First.Prev = null);\n       pragma Assert (Container.Last.Next = null);\n-      pragma Assert (Length > 0);\n+      pragma Assert (Container.Length > 0);\n \n       Container.First := null;\n       Container.Last := null;\n       Container.Length := 0;\n+      Container.Busy := 0;\n+      Container.Lock := 0;\n \n       Container.First := new Node_Type'(Src.Element, null, null);\n-\n       Container.Last := Container.First;\n-      loop\n-         Container.Length := Container.Length + 1;\n-         Src := Src.Next;\n-         exit when Src = null;\n+      Container.Length := 1;\n+\n+      Src := Src.Next;\n+\n+      while Src /= null loop\n          Container.Last.Next := new Node_Type'(Element => Src.Element,\n                                                Prev    => Container.Last,\n                                                Next    => null);\n          Container.Last := Container.Last.Next;\n-      end loop;\n+         Container.Length := Container.Length + 1;\n \n-      pragma Assert (Container.Length = Length);\n+         Src := Src.Next;\n+      end loop;\n    end Adjust;\n \n    ------------\n@@ -129,8 +129,7 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    procedure Append\n      (Container : in out List;\n       New_Item  : Element_Type;\n-      Count     : Count_Type := 1)\n-   is\n+      Count     : Count_Type := 1) is\n    begin\n       Insert (Container, No_Element, New_Item, Count);\n    end Append;\n@@ -140,8 +139,45 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    -----------\n \n    procedure Clear (Container : in out List) is\n+      X : Node_Access;\n+\n    begin\n-      Delete_Last (Container, Count => Container.Length);\n+      if Container.Length = 0 then\n+         pragma Assert (Container.First = null);\n+         pragma Assert (Container.Last = null);\n+         pragma Assert (Container.Busy = 0);\n+         pragma Assert (Container.Lock = 0);\n+         return;\n+      end if;\n+\n+      pragma Assert (Container.First.Prev = null);\n+      pragma Assert (Container.Last.Next = null);\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n+\n+      while Container.Length > 1 loop\n+         X := Container.First;\n+         pragma Assert (X.Next.Prev = Container.First);\n+\n+         Container.First := X.Next;\n+         X.Next := null;  --  prevent mischief\n+\n+         Container.First.Prev := null;\n+         Container.Length := Container.Length - 1;\n+\n+         Free (X);\n+      end loop;\n+\n+      X := Container.First;\n+      pragma Assert (X = Container.Last);\n+\n+      Container.First := null;\n+      Container.Last := null;\n+      Container.Length := 0;\n+\n+      Free (X);\n    end Clear;\n \n    --------------\n@@ -150,8 +186,7 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n    function Contains\n      (Container : List;\n-      Item      : Element_Type) return Boolean\n-   is\n+      Item      : Element_Type) return Boolean is\n    begin\n       return Find (Container, Item) /= No_Element;\n    end Contains;\n@@ -165,22 +200,68 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       Position  : in out Cursor;\n       Count     : Count_Type := 1)\n    is\n+      X : Node_Access;\n+\n    begin\n-      if Position = No_Element then\n-         return;\n+      if Position.Node = null then\n+         pragma Assert (Position.Container = null);\n+         raise Constraint_Error;\n       end if;\n \n       if Position.Container /= List_Access'(Container'Unchecked_Access) then\n          raise Program_Error;\n       end if;\n \n+      pragma Assert (Container.Length > 0);\n+      pragma Assert (Container.First.Prev = null);\n+      pragma Assert (Container.Last.Next = null);\n+\n+      pragma Assert (Position.Node.Prev = null\n+                       or else Position.Node.Prev.Next = Position.Node);\n+      pragma Assert (Position.Node.Next = null\n+                       or else Position.Node.Next.Prev = Position.Node);\n+      pragma Assert (Position.Node.Prev /= null\n+                       or else Position.Node = Container.First);\n+      pragma Assert (Position.Node.Next /= null\n+                       or else Position.Node = Container.Last);\n+\n+      if Position.Node = Container.First then\n+         Delete_First (Container, Count);\n+         Position := First (Container);\n+         return;\n+      end if;\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n+\n       for Index in 1 .. Count loop\n-         Delete_Node (Container, Position.Node);\n+         X := Position.Node;\n+         Container.Length := Container.Length - 1;\n \n-         if Position.Node = null then\n-            Position.Container := null;\n+         if X = Container.Last then\n+            Position := No_Element;\n+\n+            Container.Last := X.Prev;\n+            Container.Last.Next := null;\n+\n+            X.Prev := null;  --  prevent mischief\n+            Free (X);\n             return;\n          end if;\n+\n+         Position.Node := X.Next;\n+\n+         X.Next.Prev := X.Prev;\n+         X.Prev.Next := X.Next;\n+\n+         X.Next := null;\n+         X.Prev := null;\n+         Free (X);\n       end loop;\n    end Delete;\n \n@@ -192,10 +273,33 @@ package body Ada.Containers.Doubly_Linked_Lists is\n      (Container : in out List;\n       Count     : Count_Type := 1)\n    is\n-      Node : Node_Access := Container.First;\n+      X : Node_Access;\n+\n    begin\n-      for J in 1 .. Count_Type'Min (Count, Container.Length) loop\n-         Delete_Node (Container, Node);\n+      if Count >= Container.Length then\n+         Clear (Container);\n+         return;\n+      end if;\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n+\n+      for I in 1 .. Count loop\n+         X := Container.First;\n+         pragma Assert (X.Next.Prev = Container.First);\n+\n+         Container.First := X.Next;\n+         Container.First.Prev := null;\n+\n+         Container.Length := Container.Length - 1;\n+\n+         X.Next := null;  --  prevent mischief\n+         Free (X);\n       end loop;\n    end Delete_First;\n \n@@ -207,62 +311,57 @@ package body Ada.Containers.Doubly_Linked_Lists is\n      (Container : in out List;\n       Count     : Count_Type := 1)\n    is\n-      Node : Node_Access;\n-   begin\n-      for J in 1 .. Count_Type'Min (Count, Container.Length) loop\n-         Node := Container.Last;\n-         Delete_Node (Container, Node);\n-      end loop;\n-   end Delete_Last;\n-\n-   -----------------\n-   -- Delete_Node --\n-   -----------------\n-\n-   procedure Delete_Node\n-     (Container : in out List;\n-      Node      : in out Node_Access)\n-   is\n-      X : Node_Access := Node;\n+      X : Node_Access;\n \n    begin\n-      Node := X.Next;\n-      Container.Length := Container.Length - 1;\n+      if Count >= Container.Length then\n+         Clear (Container);\n+         return;\n+      end if;\n \n-      if X = Container.First then\n-         Container.First := X.Next;\n+      if Count = 0 then\n+         return;\n+      end if;\n \n-         if X = Container.Last then\n-            pragma Assert (Container.First = null);\n-            pragma Assert (Container.Length = 0);\n-            Container.Last := null;\n-         else\n-            pragma Assert (Container.Length > 0);\n-            Container.First.Prev := null;\n-         end if;\n+      if Container.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n \n-      elsif X = Container.Last then\n-         pragma Assert (Container.Length > 0);\n+      for I in 1 .. Count loop\n+         X := Container.Last;\n+         pragma Assert (X.Prev.Next = Container.Last);\n \n          Container.Last := X.Prev;\n          Container.Last.Next := null;\n \n-      else\n-         pragma Assert (Container.Length > 0);\n+         Container.Length := Container.Length - 1;\n \n-         X.Next.Prev := X.Prev;\n-         X.Prev.Next := X.Next;\n-      end if;\n-\n-      Free (X);\n-   end Delete_Node;\n+         X.Prev := null;  --  prevent mischief\n+         Free (X);\n+      end loop;\n+   end Delete_Last;\n \n    -------------\n    -- Element --\n    -------------\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n+      pragma Assert (Position.Container /= null);\n+      pragma Assert (Position.Container.Length > 0);\n+      pragma Assert (Position.Container.First.Prev = null);\n+      pragma Assert (Position.Container.Last.Next = null);\n+\n+      pragma Assert (Position.Node /= null);\n+      pragma Assert (Position.Node.Prev = null\n+                       or else Position.Node.Prev.Next = Position.Node);\n+      pragma Assert (Position.Node.Next = null\n+                       or else Position.Node.Next.Prev = Position.Node);\n+      pragma Assert (Position.Node.Prev /= null\n+                       or else Position.Node = Position.Container.First);\n+      pragma Assert (Position.Node.Next /= null\n+                       or else Position.Node = Position.Container.Last);\n+\n       return Position.Node.Element;\n    end Element;\n \n@@ -280,8 +379,23 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    begin\n       if Node = null then\n          Node := Container.First;\n-      elsif Position.Container /= List_Access'(Container'Unchecked_Access) then\n-         raise Program_Error;\n+      else\n+         if Position.Container /= List_Access'(Container'Unchecked_Access) then\n+            raise Program_Error;\n+         end if;\n+\n+         pragma Assert (Container.Length > 0);\n+         pragma Assert (Container.First.Prev = null);\n+         pragma Assert (Container.Last.Next = null);\n+\n+         pragma Assert (Position.Node.Prev = null\n+                          or else Position.Node.Prev.Next = Position.Node);\n+         pragma Assert (Position.Node.Next = null\n+                          or else Position.Node.Next.Prev = Position.Node);\n+         pragma Assert (Position.Node.Prev /= null\n+                          or else Position.Node = Container.First);\n+         pragma Assert (Position.Node.Next /= null\n+                          or else Position.Node = Container.Last);\n       end if;\n \n       while Node /= null loop\n@@ -317,139 +431,200 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       return Container.First.Element;\n    end First_Element;\n \n-   -------------------\n-   -- Generic_Merge --\n-   -------------------\n+   ---------------------\n+   -- Generic_Sorting --\n+   ---------------------\n \n-   procedure Generic_Merge\n-     (Target : in out List;\n-      Source : in out List)\n-   is\n-      LI : Cursor := First (Target);\n-      RI : Cursor := First (Source);\n+   package body Generic_Sorting is\n \n-   begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n+      ---------------\n+      -- Is_Sorted --\n+      ---------------\n \n-      while RI.Node /= null loop\n-         if LI.Node = null then\n-            Splice (Target, No_Element, Source);\n+      function Is_Sorted (Container : List) return Boolean is\n+         Node : Node_Access := Container.First;\n+\n+      begin\n+         for I in 2 .. Container.Length loop\n+            if Node.Next.Element < Node.Element then\n+               return False;\n+            end if;\n+\n+            Node := Node.Next;\n+         end loop;\n+\n+         return True;\n+      end Is_Sorted;\n+\n+      -----------\n+      -- Merge --\n+      -----------\n+\n+      procedure Merge\n+        (Target : in out List;\n+         Source : in out List)\n+      is\n+         LI : Cursor := First (Target);\n+         RI : Cursor := First (Source);\n+\n+      begin\n+         if Target'Address = Source'Address then\n             return;\n          end if;\n \n-         if RI.Node.Element < LI.Node.Element then\n-            declare\n-               RJ : constant Cursor := RI;\n-            begin\n-               RI.Node := RI.Node.Next;\n-               Splice (Target, LI, Source, RJ);\n-            end;\n-\n-         else\n-            LI.Node := LI.Node.Next;\n+         if Target.Busy > 0\n+           or else Source.Busy > 0\n+         then\n+            raise Program_Error;\n          end if;\n-      end loop;\n-   end Generic_Merge;\n \n-   ------------------\n-   -- Generic_Sort --\n-   ------------------\n+         while RI.Node /= null loop\n+            if LI.Node = null then\n+               Splice (Target, No_Element, Source);\n+               return;\n+            end if;\n+\n+            if RI.Node.Element < LI.Node.Element then\n+               declare\n+                  RJ : Cursor := RI;\n+               begin\n+                  RI.Node := RI.Node.Next;\n+                  Splice (Target, LI, Source, RJ);\n+               end;\n+\n+            else\n+               LI.Node := LI.Node.Next;\n+            end if;\n+         end loop;\n+      end Merge;\n \n-   procedure Generic_Sort (Container : in out List) is\n+      ----------\n+      -- Sort --\n+      ----------\n \n-      procedure Partition\n-        (Pivot : in Node_Access;\n-         Back  : in Node_Access);\n+      procedure Sort (Container : in out List) is\n \n-      procedure Sort (Front, Back : Node_Access);\n+         procedure Partition\n+           (Pivot : in Node_Access;\n+            Back  : in Node_Access);\n \n-      ---------------\n-      -- Partition --\n-      ---------------\n+         procedure Sort (Front, Back : Node_Access);\n \n-      procedure Partition\n-        (Pivot : Node_Access;\n-         Back  : Node_Access)\n-      is\n-         Node : Node_Access := Pivot.Next;\n+         ---------------\n+         -- Partition --\n+         ---------------\n \n-      begin\n-         while Node /= Back loop\n-            if Node.Element < Pivot.Element then\n-               declare\n-                  Prev : constant Node_Access := Node.Prev;\n-                  Next : constant Node_Access := Node.Next;\n+         procedure Partition\n+           (Pivot : Node_Access;\n+            Back  : Node_Access)\n+         is\n+            Node : Node_Access := Pivot.Next;\n \n-               begin\n-                  Prev.Next := Next;\n+         begin\n+            while Node /= Back loop\n+               if Node.Element < Pivot.Element then\n+                  declare\n+                     Prev : constant Node_Access := Node.Prev;\n+                     Next : constant Node_Access := Node.Next;\n \n-                  if Next = null then\n-                     Container.Last := Prev;\n-                  else\n-                     Next.Prev := Prev;\n-                  end if;\n+                  begin\n+                     Prev.Next := Next;\n \n-                  Node.Next := Pivot;\n-                  Node.Prev := Pivot.Prev;\n+                     if Next = null then\n+                        Container.Last := Prev;\n+                     else\n+                        Next.Prev := Prev;\n+                     end if;\n \n-                  Pivot.Prev := Node;\n+                     Node.Next := Pivot;\n+                     Node.Prev := Pivot.Prev;\n \n-                  if Node.Prev = null then\n-                     Container.First := Node;\n-                  else\n-                     Node.Prev.Next := Node;\n-                  end if;\n+                     Pivot.Prev := Node;\n \n-                  Node := Next;\n-               end;\n+                     if Node.Prev = null then\n+                        Container.First := Node;\n+                     else\n+                        Node.Prev.Next := Node;\n+                     end if;\n+\n+                     Node := Next;\n+                  end;\n \n+               else\n+                  Node := Node.Next;\n+               end if;\n+            end loop;\n+         end Partition;\n+\n+         ----------\n+         -- Sort --\n+         ----------\n+\n+         procedure Sort (Front, Back : Node_Access) is\n+            Pivot : Node_Access;\n+\n+         begin\n+            if Front = null then\n+               Pivot := Container.First;\n             else\n-               Node := Node.Next;\n+               Pivot := Front.Next;\n             end if;\n-         end loop;\n-      end Partition;\n \n-      ----------\n-      -- Sort --\n-      ----------\n+            if Pivot /= Back then\n+               Partition (Pivot, Back);\n+               Sort (Front, Pivot);\n+               Sort (Pivot, Back);\n+            end if;\n+         end Sort;\n \n-      procedure Sort (Front, Back : Node_Access) is\n-         Pivot : Node_Access;\n+      --  Start of processing for Sort\n \n       begin\n-         if Front = null then\n-            Pivot := Container.First;\n-         else\n-            Pivot := Front.Next;\n+         if Container.Length <= 1 then\n+            return;\n          end if;\n \n-         if Pivot /= Back then\n-            Partition (Pivot, Back);\n-            Sort (Front, Pivot);\n-            Sort (Pivot, Back);\n+         pragma Assert (Container.First.Prev = null);\n+         pragma Assert (Container.Last.Next = null);\n+\n+         if Container.Busy > 0 then\n+            raise Program_Error;\n          end if;\n-      end Sort;\n \n-   --  Start of processing for Generic_Sort\n+         Sort (Front => null, Back => null);\n \n-   begin\n-      Sort (Front => null, Back => null);\n+         pragma Assert (Container.First.Prev = null);\n+         pragma Assert (Container.Last.Next = null);\n+      end Sort;\n \n-      pragma Assert (Container.Length = 0\n-                       or else\n-                         (Container.First.Prev = null\n-                            and then Container.Last.Next = null));\n-   end Generic_Sort;\n+   end Generic_Sorting;\n \n    -----------------\n    -- Has_Element --\n    -----------------\n \n    function Has_Element (Position : Cursor) return Boolean is\n    begin\n-      return Position.Container /= null and then Position.Node /= null;\n+      if Position.Node = null then\n+         pragma Assert (Position.Container = null);\n+         return False;\n+      end if;\n+\n+      pragma Assert (Position.Container /= null);\n+      pragma Assert (Position.Container.Length > 0);\n+      pragma Assert (Position.Container.First.Prev = null);\n+      pragma Assert (Position.Container.Last.Next = null);\n+\n+      pragma Assert (Position.Node.Prev = null\n+                       or else Position.Node.Prev.Next = Position.Node);\n+      pragma Assert (Position.Node.Next = null\n+                       or else Position.Node.Next.Prev = Position.Node);\n+      pragma Assert (Position.Node.Prev /= null\n+                       or else Position.Node = Position.Container.First);\n+      pragma Assert (Position.Node.Next /= null\n+                       or else Position.Node = Position.Container.Last);\n+\n+      return True;\n    end Has_Element;\n \n    ------------\n@@ -466,21 +641,42 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       New_Node : Node_Access;\n \n    begin\n-      if Before.Container /= null\n-        and then Before.Container /= List_Access'(Container'Unchecked_Access)\n-      then\n-         raise Program_Error;\n+      if Before.Node /= null then\n+         if Before.Container /= List_Access'(Container'Unchecked_Access) then\n+            raise Program_Error;\n+         end if;\n+\n+         pragma Assert (Container.Length > 0);\n+         pragma Assert (Container.First.Prev = null);\n+         pragma Assert (Container.Last.Next = null);\n+\n+         pragma Assert (Before.Node.Prev = null\n+                          or else Before.Node.Prev.Next = Before.Node);\n+         pragma Assert (Before.Node.Next = null\n+                          or else Before.Node.Next.Prev = Before.Node);\n+         pragma Assert (Before.Node.Prev /= null\n+                          or else Before.Node = Container.First);\n+         pragma Assert (Before.Node.Next /= null\n+                          or else Before.Node = Container.Last);\n       end if;\n \n       if Count = 0 then\n          Position := Before;\n          return;\n       end if;\n \n+      if Container.Length > Count_Type'Last - Count then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n+\n       New_Node := new Node_Type'(New_Item, null, null);\n       Insert_Internal (Container, Before.Node, New_Node);\n \n-      Position := Cursor'(Before.Container, New_Node);\n+      Position := Cursor'(Container'Unchecked_Access, New_Node);\n \n       for J in Count_Type'(2) .. Count loop\n          New_Node := new Node_Type'(New_Item, null, null);\n@@ -508,21 +704,42 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       New_Node : Node_Access;\n \n    begin\n-      if Before.Container /= null\n-        and then Before.Container /= List_Access'(Container'Unchecked_Access)\n-      then\n-         raise Program_Error;\n+      if Before.Node /= null then\n+         if Before.Container /= List_Access'(Container'Unchecked_Access) then\n+            raise Program_Error;\n+         end if;\n+\n+         pragma Assert (Container.Length > 0);\n+         pragma Assert (Container.First.Prev = null);\n+         pragma Assert (Container.Last.Next = null);\n+\n+         pragma Assert (Before.Node.Prev = null\n+                          or else Before.Node.Prev.Next = Before.Node);\n+         pragma Assert (Before.Node.Next = null\n+                          or else Before.Node.Next.Prev = Before.Node);\n+         pragma Assert (Before.Node.Prev /= null\n+                          or else Before.Node = Container.First);\n+         pragma Assert (Before.Node.Next /= null\n+                          or else Before.Node = Container.Last);\n       end if;\n \n       if Count = 0 then\n          Position := Before;\n          return;\n       end if;\n \n+      if Container.Length > Count_Type'Last - Count then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n+\n       New_Node := new Node_Type;\n       Insert_Internal (Container, Before.Node, New_Node);\n \n-      Position := Cursor'(Before.Container, New_Node);\n+      Position := Cursor'(Container'Unchecked_Access, New_Node);\n \n       for J in Count_Type'(2) .. Count loop\n          New_Node := new Node_Type;\n@@ -595,12 +812,26 @@ package body Ada.Containers.Doubly_Linked_Lists is\n      (Container : List;\n       Process   : not null access procedure (Position : Cursor))\n    is\n+      C : List renames Container'Unrestricted_Access.all;\n+      B : Natural renames C.Busy;\n+\n       Node : Node_Access := Container.First;\n+\n    begin\n-      while Node /= null loop\n-         Process (Cursor'(Container'Unchecked_Access, Node));\n-         Node := Node.Next;\n-      end loop;\n+      B := B + 1;\n+\n+      begin\n+         while Node /= null loop\n+            Process (Cursor'(Container'Unchecked_Access, Node));\n+            Node := Node.Next;\n+         end loop;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n    end Iterate;\n \n    ----------\n@@ -647,10 +878,12 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      if Target.Length > 0 then\n-         raise Constraint_Error;\n+      if Source.Busy > 0 then\n+         raise Program_Error;\n       end if;\n \n+      Clear (Target);\n+\n       Target.First := Source.First;\n       Source.First := null;\n \n@@ -668,9 +901,24 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    procedure Next (Position : in out Cursor) is\n    begin\n       if Position.Node = null then\n+         pragma Assert (Position.Container = null);\n          return;\n       end if;\n \n+      pragma Assert (Position.Container /= null);\n+      pragma Assert (Position.Container.Length > 0);\n+      pragma Assert (Position.Container.First.Prev = null);\n+      pragma Assert (Position.Container.Last.Next = null);\n+\n+      pragma Assert (Position.Node.Prev = null\n+                       or else Position.Node.Prev.Next = Position.Node);\n+      pragma Assert (Position.Node.Next = null\n+                       or else Position.Node.Next.Prev = Position.Node);\n+      pragma Assert (Position.Node.Prev /= null\n+                       or else Position.Node = Position.Container.First);\n+      pragma Assert (Position.Node.Next /= null\n+                       or else Position.Node = Position.Container.Last);\n+\n       Position.Node := Position.Node.Next;\n \n       if Position.Node = null then\n@@ -681,9 +929,24 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    function Next (Position : Cursor) return Cursor is\n    begin\n       if Position.Node = null then\n+         pragma Assert (Position.Container = null);\n          return No_Element;\n       end if;\n \n+      pragma Assert (Position.Container /= null);\n+      pragma Assert (Position.Container.Length > 0);\n+      pragma Assert (Position.Container.First.Prev = null);\n+      pragma Assert (Position.Container.Last.Next = null);\n+\n+      pragma Assert (Position.Node.Prev = null\n+                       or else Position.Node.Prev.Next = Position.Node);\n+      pragma Assert (Position.Node.Next = null\n+                       or else Position.Node.Next.Prev = Position.Node);\n+      pragma Assert (Position.Node.Prev /= null\n+                       or else Position.Node = Position.Container.First);\n+      pragma Assert (Position.Node.Next /= null\n+                       or else Position.Node = Position.Container.Last);\n+\n       declare\n          Next_Node : constant Node_Access := Position.Node.Next;\n       begin\n@@ -715,9 +978,24 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    procedure Previous (Position : in out Cursor) is\n    begin\n       if Position.Node = null then\n+         pragma Assert (Position.Container = null);\n          return;\n       end if;\n \n+      pragma Assert (Position.Container /= null);\n+      pragma Assert (Position.Container.Length > 0);\n+      pragma Assert (Position.Container.First.Prev = null);\n+      pragma Assert (Position.Container.Last.Next = null);\n+\n+      pragma Assert (Position.Node.Prev = null\n+                       or else Position.Node.Prev.Next = Position.Node);\n+      pragma Assert (Position.Node.Next = null\n+                       or else Position.Node.Next.Prev = Position.Node);\n+      pragma Assert (Position.Node.Prev /= null\n+                       or else Position.Node = Position.Container.First);\n+      pragma Assert (Position.Node.Next /= null\n+                       or else Position.Node = Position.Container.Last);\n+\n       Position.Node := Position.Node.Prev;\n \n       if Position.Node = null then\n@@ -728,9 +1006,24 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    function Previous (Position : Cursor) return Cursor is\n    begin\n       if Position.Node = null then\n+         pragma Assert (Position.Container = null);\n          return No_Element;\n       end if;\n \n+      pragma Assert (Position.Container /= null);\n+      pragma Assert (Position.Container.Length > 0);\n+      pragma Assert (Position.Container.First.Prev = null);\n+      pragma Assert (Position.Container.Last.Next = null);\n+\n+      pragma Assert (Position.Node.Prev = null\n+                       or else Position.Node.Prev.Next = Position.Node);\n+      pragma Assert (Position.Node.Next = null\n+                       or else Position.Node.Next.Prev = Position.Node);\n+      pragma Assert (Position.Node.Prev /= null\n+                       or else Position.Node = Position.Container.First);\n+      pragma Assert (Position.Node.Next /= null\n+                       or else Position.Node = Position.Container.Last);\n+\n       declare\n          Prev_Node : constant Node_Access := Position.Node.Prev;\n       begin\n@@ -750,8 +1043,42 @@ package body Ada.Containers.Doubly_Linked_Lists is\n      (Position : Cursor;\n       Process  : not null access procedure (Element : in Element_Type))\n    is\n+      pragma Assert (Position.Container /= null);\n+      pragma Assert (Position.Container.Length > 0);\n+      pragma Assert (Position.Container.First.Prev = null);\n+      pragma Assert (Position.Container.Last.Next = null);\n+\n+      pragma Assert (Position.Node /= null);\n+      pragma Assert (Position.Node.Prev = null\n+                       or else Position.Node.Prev.Next = Position.Node);\n+      pragma Assert (Position.Node.Next = null\n+                       or else Position.Node.Next.Prev = Position.Node);\n+      pragma Assert (Position.Node.Prev /= null\n+                       or else Position.Node = Position.Container.First);\n+      pragma Assert (Position.Node.Next /= null\n+                       or else Position.Node = Position.Container.Last);\n+\n+      E : Element_Type renames Position.Node.Element;\n+\n+      C : List renames Position.Container.all'Unrestricted_Access.all;\n+      B : Natural renames C.Busy;\n+      L : Natural renames C.Lock;\n+\n    begin\n-      Process (Position.Node.Element);\n+      B := B + 1;\n+      L := L + 1;\n+\n+      begin\n+         Process (E);\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      L := L - 1;\n+      B := B - 1;\n    end Query_Element;\n \n    ----------\n@@ -766,7 +1093,7 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       X : Node_Access;\n \n    begin\n-      Clear (Item);  --  ???\n+      Clear (Item);\n       Count_Type'Base'Read (Stream, N);\n \n       if N = 0 then\n@@ -814,8 +1141,29 @@ package body Ada.Containers.Doubly_Linked_Lists is\n      (Position : Cursor;\n       By       : Element_Type)\n    is\n+      pragma Assert (Position.Container /= null);\n+      pragma Assert (Position.Container.Length > 0);\n+      pragma Assert (Position.Container.First.Prev = null);\n+      pragma Assert (Position.Container.Last.Next = null);\n+\n+      pragma Assert (Position.Node /= null);\n+      pragma Assert (Position.Node.Prev = null\n+                       or else Position.Node.Prev.Next = Position.Node);\n+      pragma Assert (Position.Node.Next = null\n+                       or else Position.Node.Next.Prev = Position.Node);\n+      pragma Assert (Position.Node.Prev /= null\n+                       or else Position.Node = Position.Container.First);\n+      pragma Assert (Position.Node.Next /= null\n+                       or else Position.Node = Position.Container.Last);\n+\n+      E : Element_Type renames Position.Node.Element;\n+\n    begin\n-      Position.Node.Element := By;\n+      if Position.Container.Lock > 0 then\n+         raise Program_Error;\n+      end if;\n+\n+      E := By;\n    end Replace_Element;\n \n    ------------------\n@@ -832,8 +1180,23 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    begin\n       if Node = null then\n          Node := Container.Last;\n-      elsif Position.Container /= List_Access'(Container'Unchecked_Access) then\n-         raise Program_Error;\n+      else\n+         if Position.Container /= List_Access'(Container'Unchecked_Access) then\n+            raise Program_Error;\n+         end if;\n+\n+         pragma Assert (Container.Length > 0);\n+         pragma Assert (Container.First.Prev = null);\n+         pragma Assert (Container.Last.Next = null);\n+\n+         pragma Assert (Position.Node.Prev = null\n+                          or else Position.Node.Prev.Next = Position.Node);\n+         pragma Assert (Position.Node.Next = null\n+                          or else Position.Node.Next.Prev = Position.Node);\n+         pragma Assert (Position.Node.Prev /= null\n+                          or else Position.Node = Container.First);\n+         pragma Assert (Position.Node.Next /= null\n+                          or else Position.Node = Container.Last);\n       end if;\n \n       while Node /= null loop\n@@ -855,12 +1218,26 @@ package body Ada.Containers.Doubly_Linked_Lists is\n      (Container : List;\n       Process   : not null access procedure (Position : Cursor))\n    is\n+      C : List renames Container'Unrestricted_Access.all;\n+      B : Natural renames C.Busy;\n+\n       Node : Node_Access := Container.Last;\n+\n    begin\n-      while Node /= null loop\n-         Process (Cursor'(Container'Unchecked_Access, Node));\n-         Node := Node.Prev;\n-      end loop;\n+      B := B + 1;\n+\n+      begin\n+         while Node /= null loop\n+            Process (Cursor'(Container'Unchecked_Access, Node));\n+            Node := Node.Prev;\n+         end loop;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n    end Reverse_Iterate;\n \n    ------------------\n@@ -918,6 +1295,13 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          return;\n       end if;\n \n+      pragma Assert (Container.First.Prev = null);\n+      pragma Assert (Container.Last.Next = null);\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n+\n       Container.First := J;\n       Container.Last := I;\n       loop\n@@ -952,10 +1336,23 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       Source : in out List)\n    is\n    begin\n-      if Before.Container /= null\n-        and then Before.Container /= List_Access'(Target'Unchecked_Access)\n-      then\n-         raise Program_Error;\n+      if Before.Node /= null then\n+         if Before.Container /= List_Access'(Target'Unchecked_Access) then\n+            raise Program_Error;\n+         end if;\n+\n+         pragma Assert (Target.Length >= 1);\n+         pragma Assert (Target.First.Prev = null);\n+         pragma Assert (Target.Last.Next = null);\n+\n+         pragma Assert (Before.Node.Prev = null\n+                          or else Before.Node.Prev.Next = Before.Node);\n+         pragma Assert (Before.Node.Next = null\n+                          or else Before.Node.Next.Prev = Before.Node);\n+         pragma Assert (Before.Node.Prev /= null\n+                          or else Before.Node = Target.First);\n+         pragma Assert (Before.Node.Next /= null\n+                          or else Before.Node = Target.Last);\n       end if;\n \n       if Target'Address = Source'Address\n@@ -964,7 +1361,22 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          return;\n       end if;\n \n+      pragma Assert (Source.First.Prev = null);\n+      pragma Assert (Source.Last.Next = null);\n+\n+      if Target.Length > Count_Type'Last - Source.Length then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Target.Busy > 0\n+        or else Source.Busy > 0\n+      then\n+         raise Program_Error;\n+      end if;\n+\n       if Target.Length = 0 then\n+         pragma Assert (Target.First = null);\n+         pragma Assert (Target.Last = null);\n          pragma Assert (Before = No_Element);\n \n          Target.First := Source.First;\n@@ -987,6 +1399,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          Target.First := Source.First;\n \n       else\n+         pragma Assert (Target.Length >= 2);\n+\n          Before.Node.Prev.Next := Source.First;\n          Source.First.Prev := Before.Node.Prev;\n \n@@ -1006,189 +1420,309 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       Before   : Cursor;\n       Position : Cursor)\n    is\n-      X : Node_Access := Position.Node;\n-\n    begin\n-      if Before.Container /= null\n-        and then Before.Container /= List_Access'(Target'Unchecked_Access)\n-      then\n-         raise Program_Error;\n+      if Before.Node /= null then\n+         if Before.Container /= List_Access'(Target'Unchecked_Access) then\n+            raise Program_Error;\n+         end if;\n+\n+         pragma Assert (Target.Length >= 1);\n+         pragma Assert (Target.First.Prev = null);\n+         pragma Assert (Target.Last.Next = null);\n+\n+         pragma Assert (Before.Node.Prev = null\n+                          or else Before.Node.Prev.Next = Before.Node);\n+         pragma Assert (Before.Node.Next = null\n+                          or else Before.Node.Next.Prev = Before.Node);\n+         pragma Assert (Before.Node.Prev /= null\n+                          or else Before.Node = Target.First);\n+         pragma Assert (Before.Node.Next /= null\n+                          or else Before.Node = Target.Last);\n       end if;\n \n-      if Position.Container /= null\n-        and then Position.Container /= List_Access'(Target'Unchecked_Access)\n-      then\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Position.Container /= List_Access'(Target'Unchecked_Access) then\n          raise Program_Error;\n       end if;\n \n-      if X = null\n-        or else X = Before.Node\n-        or else X.Next = Before.Node\n+      pragma Assert (Target.Length >= 1);\n+      pragma Assert (Target.First.Prev = null);\n+      pragma Assert (Target.Last.Next = null);\n+\n+      pragma Assert (Position.Node.Prev = null\n+                       or else Position.Node.Prev.Next = Position.Node);\n+      pragma Assert (Position.Node.Next = null\n+                       or else Position.Node.Next.Prev = Position.Node);\n+      pragma Assert (Position.Node.Prev /= null\n+                       or else Position.Node = Target.First);\n+      pragma Assert (Position.Node.Next /= null\n+                       or else Position.Node = Target.Last);\n+\n+      if Position.Node = Before.Node\n+        or else Position.Node.Next = Before.Node\n       then\n          return;\n       end if;\n \n-      pragma Assert (Target.Length > 0);\n+      pragma Assert (Target.Length >= 2);\n+\n+      if Target.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n \n       if Before.Node = null then\n-         pragma Assert (X /= Target.Last);\n+         pragma Assert (Position.Node /= Target.Last);\n \n-         if X = Target.First then\n-            Target.First := X.Next;\n+         if Position.Node = Target.First then\n+            Target.First := Position.Node.Next;\n             Target.First.Prev := null;\n          else\n-            X.Prev.Next := X.Next;\n-            X.Next.Prev := X.Prev;\n+            Position.Node.Prev.Next := Position.Node.Next;\n+            Position.Node.Next.Prev := Position.Node.Prev;\n          end if;\n \n-         Target.Last.Next := X;\n-         X.Prev := Target.Last;\n+         Target.Last.Next := Position.Node;\n+         Position.Node.Prev := Target.Last;\n \n-         Target.Last := X;\n+         Target.Last := Position.Node;\n          Target.Last.Next := null;\n \n          return;\n       end if;\n \n       if Before.Node = Target.First then\n-         pragma Assert (X /= Target.First);\n+         pragma Assert (Position.Node /= Target.First);\n \n-         if X = Target.Last then\n-            Target.Last := X.Prev;\n+         if Position.Node = Target.Last then\n+            Target.Last := Position.Node.Prev;\n             Target.Last.Next := null;\n          else\n-            X.Prev.Next := X.Next;\n-            X.Next.Prev := X.Prev;\n+            Position.Node.Prev.Next := Position.Node.Next;\n+            Position.Node.Next.Prev := Position.Node.Prev;\n          end if;\n \n-         Target.First.Prev := X;\n-         X.Next := Target.First;\n+         Target.First.Prev := Position.Node;\n+         Position.Node.Next := Target.First;\n \n-         Target.First := X;\n+         Target.First := Position.Node;\n          Target.First.Prev := null;\n \n          return;\n       end if;\n \n-      if X = Target.First then\n-         Target.First := X.Next;\n+      if Position.Node = Target.First then\n+         Target.First := Position.Node.Next;\n          Target.First.Prev := null;\n \n-      elsif X = Target.Last then\n-         Target.Last := X.Prev;\n+      elsif Position.Node = Target.Last then\n+         Target.Last := Position.Node.Prev;\n          Target.Last.Next := null;\n \n       else\n-         X.Prev.Next := X.Next;\n-         X.Next.Prev := X.Prev;\n+         Position.Node.Prev.Next := Position.Node.Next;\n+         Position.Node.Next.Prev := Position.Node.Prev;\n       end if;\n \n-      Before.Node.Prev.Next := X;\n-      X.Prev := Before.Node.Prev;\n+      Before.Node.Prev.Next := Position.Node;\n+      Position.Node.Prev := Before.Node.Prev;\n+\n+      Before.Node.Prev := Position.Node;\n+      Position.Node.Next := Before.Node;\n \n-      Before.Node.Prev := X;\n-      X.Next := Before.Node;\n+      pragma Assert (Target.First.Prev = null);\n+      pragma Assert (Target.Last.Next = null);\n    end Splice;\n \n    procedure Splice\n      (Target   : in out List;\n       Before   : Cursor;\n       Source   : in out List;\n-      Position : Cursor)\n+      Position : in out Cursor)\n    is\n-      X : Node_Access := Position.Node;\n-\n    begin\n       if Target'Address = Source'Address then\n          Splice (Target, Before, Position);\n          return;\n       end if;\n \n-      if Before.Container /= null\n-        and then Before.Container /= List_Access'(Target'Unchecked_Access)\n-      then\n-         raise Program_Error;\n+      if Before.Node /= null then\n+         if Before.Container /= List_Access'(Target'Unchecked_Access) then\n+            raise Program_Error;\n+         end if;\n+\n+         pragma Assert (Target.Length >= 1);\n+         pragma Assert (Target.First.Prev = null);\n+         pragma Assert (Target.Last.Next = null);\n+\n+         pragma Assert (Before.Node.Prev = null\n+                          or else Before.Node.Prev.Next = Before.Node);\n+         pragma Assert (Before.Node.Next = null\n+                          or else Before.Node.Next.Prev = Before.Node);\n+         pragma Assert (Before.Node.Prev /= null\n+                          or else Before.Node = Target.First);\n+         pragma Assert (Before.Node.Next /= null\n+                          or else Before.Node = Target.Last);\n       end if;\n \n-      if Position.Container /= null\n-        and then Position.Container /= List_Access'(Source'Unchecked_Access)\n-      then\n-         raise Program_Error;\n+      if Position.Node = null then\n+         raise Constraint_Error;\n       end if;\n \n-      if X = null then\n-         return;\n+      if Position.Container /= List_Access'(Source'Unchecked_Access) then\n+         raise Program_Error;\n       end if;\n \n-      pragma Assert (Source.Length > 0);\n+      pragma Assert (Source.Length >= 1);\n       pragma Assert (Source.First.Prev = null);\n       pragma Assert (Source.Last.Next = null);\n \n-      if X = Source.First then\n-         Source.First := X.Next;\n+      pragma Assert (Position.Node.Prev = null\n+                       or else Position.Node.Prev.Next = Position.Node);\n+      pragma Assert (Position.Node.Next = null\n+                       or else Position.Node.Next.Prev = Position.Node);\n+      pragma Assert (Position.Node.Prev /= null\n+                       or else Position.Node = Source.First);\n+      pragma Assert (Position.Node.Next /= null\n+                       or else Position.Node = Source.Last);\n+\n+      if Target.Length = Count_Type'Last then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Target.Busy > 0\n+        or else Source.Busy > 0\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      if Position.Node = Source.First then\n+         Source.First := Position.Node.Next;\n          Source.First.Prev := null;\n \n-         if X = Source.Last then\n+         if Position.Node = Source.Last then\n             pragma Assert (Source.First = null);\n             pragma Assert (Source.Length = 1);\n             Source.Last := null;\n          end if;\n \n-      elsif X = Source.Last then\n-         Source.Last := X.Prev;\n+      elsif Position.Node = Source.Last then\n+         pragma Assert (Source.Length >= 2);\n+         Source.Last := Position.Node.Prev;\n          Source.Last.Next := null;\n \n       else\n-         X.Prev.Next := X.Next;\n-         X.Next.Prev := X.Prev;\n+         pragma Assert (Source.Length >= 3);\n+         Position.Node.Prev.Next := Position.Node.Next;\n+         Position.Node.Next.Prev := Position.Node.Prev;\n       end if;\n \n       if Target.Length = 0 then\n-         pragma Assert (Before = No_Element);\n          pragma Assert (Target.First = null);\n          pragma Assert (Target.Last = null);\n+         pragma Assert (Before = No_Element);\n \n-         Target.First := X;\n-         Target.Last := X;\n+         Target.First := Position.Node;\n+         Target.Last := Position.Node;\n+\n+         Target.First.Prev := null;\n+         Target.Last.Next := null;\n \n       elsif Before.Node = null then\n-         Target.Last.Next := X;\n-         X.Next := Target.Last;\n+         pragma Assert (Target.Last.Next = null);\n+         Target.Last.Next := Position.Node;\n+         Position.Node.Prev := Target.Last;\n \n-         Target.Last := X;\n+         Target.Last := Position.Node;\n          Target.Last.Next := null;\n \n       elsif Before.Node = Target.First then\n-         Target.First.Prev := X;\n-         X.Next := Target.First;\n+         pragma Assert (Target.First.Prev = null);\n+         Target.First.Prev := Position.Node;\n+         Position.Node.Next := Target.First;\n \n-         Target.First := X;\n+         Target.First := Position.Node;\n          Target.First.Prev := null;\n \n       else\n-         Before.Node.Prev.Next := X;\n-         X.Prev := Before.Node.Prev;\n+         pragma Assert (Target.Length >= 2);\n+         Before.Node.Prev.Next := Position.Node;\n+         Position.Node.Prev := Before.Node.Prev;\n \n-         Before.Node.Prev := X;\n-         X.Next := Before.Node;\n+         Before.Node.Prev := Position.Node;\n+         Position.Node.Next := Before.Node;\n       end if;\n \n       Target.Length := Target.Length + 1;\n       Source.Length := Source.Length - 1;\n+\n+      Position.Container := Target'Unchecked_Access;\n    end Splice;\n \n    ----------\n    -- Swap --\n    ----------\n \n-   --  Is this defined when I and J designate elements in different containers,\n-   --  or should it raise an exception (Program_Error)???\n-\n-   procedure Swap (I, J : in Cursor) is\n-      EI : constant Element_Type := I.Node.Element;\n+   procedure Swap (I, J : Cursor) is\n    begin\n-      I.Node.Element := J.Node.Element;\n-      J.Node.Element := EI;\n+      if I.Container = null\n+        or else J.Container = null\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if I.Container /= J.Container then\n+         raise Program_Error;\n+      end if;\n+\n+      declare\n+         C : List renames I.Container.all;\n+      begin\n+         pragma Assert (C.Length >= 1);\n+         pragma Assert (C.First.Prev = null);\n+         pragma Assert (C.Last.Next = null);\n+\n+         pragma Assert (I.Node /= null);\n+         pragma Assert (I.Node.Prev = null\n+                          or else I.Node.Prev.Next = I.Node);\n+         pragma Assert (I.Node.Next = null\n+                          or else I.Node.Next.Prev = I.Node);\n+         pragma Assert (I.Node.Prev /= null\n+                          or else I.Node = C.First);\n+         pragma Assert (I.Node.Next /= null\n+                          or else I.Node = C.Last);\n+\n+         if I.Node = J.Node then\n+            return;\n+         end if;\n+\n+         pragma Assert (C.Length >= 2);\n+         pragma Assert (J.Node /= null);\n+         pragma Assert (J.Node.Prev = null\n+                          or else J.Node.Prev.Next = J.Node);\n+         pragma Assert (J.Node.Next = null\n+                          or else J.Node.Next.Prev = J.Node);\n+         pragma Assert (J.Node.Prev /= null\n+                          or else J.Node = C.First);\n+         pragma Assert (J.Node.Next /= null\n+                          or else J.Node = C.Last);\n+\n+         if C.Lock > 0 then\n+            raise Program_Error;\n+         end if;\n+\n+         declare\n+            EI : Element_Type renames I.Node.Element;\n+            EJ : Element_Type renames J.Node.Element;\n+\n+            EI_Copy : constant Element_Type := EI;\n+         begin\n+            EI := EJ;\n+            EJ := EI_Copy;\n+         end;\n+      end;\n    end Swap;\n \n    ----------------\n@@ -1197,11 +1731,10 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n    procedure Swap_Links\n      (Container : in out List;\n-      I, J      : Cursor)\n-   is\n+      I, J      : Cursor) is\n    begin\n-      if I = No_Element\n-        or else J = No_Element\n+      if I.Container = null\n+        or else J.Container = null\n       then\n          raise Constraint_Error;\n       end if;\n@@ -1215,13 +1748,39 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       end if;\n \n       pragma Assert (Container.Length >= 1);\n+      pragma Assert (Container.First.Prev = null);\n+      pragma Assert (Container.Last.Next = null);\n+\n+      pragma Assert (I.Node /= null);\n+      pragma Assert (I.Node.Prev = null\n+                       or else I.Node.Prev.Next = I.Node);\n+      pragma Assert (I.Node.Next = null\n+                       or else I.Node.Next.Prev = I.Node);\n+      pragma Assert (I.Node.Prev /= null\n+                       or else I.Node = Container.First);\n+      pragma Assert (I.Node.Next /= null\n+                       or else I.Node = Container.Last);\n \n       if I.Node = J.Node then\n          return;\n       end if;\n \n       pragma Assert (Container.Length >= 2);\n \n+      pragma Assert (J.Node /= null);\n+      pragma Assert (J.Node.Prev = null\n+                       or else J.Node.Prev.Next = J.Node);\n+      pragma Assert (J.Node.Next = null\n+                       or else J.Node.Next.Prev = J.Node);\n+      pragma Assert (J.Node.Prev /= null\n+                       or else J.Node = Container.First);\n+      pragma Assert (J.Node.Next /= null\n+                       or else J.Node = Container.Last);\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n+\n       declare\n          I_Next : constant Cursor := Next (I);\n \n@@ -1255,8 +1814,43 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    procedure Update_Element\n      (Position : Cursor;\n       Process  : not null access procedure (Element : in out Element_Type)) is\n+\n+      pragma Assert (Position.Container /= null);\n+      pragma Assert (Position.Container.Length >= 1);\n+      pragma Assert (Position.Container.First.Prev = null);\n+      pragma Assert (Position.Container.Last.Next = null);\n+\n+      pragma Assert (Position.Node /= null);\n+      pragma Assert (Position.Node.Prev = null\n+                       or else Position.Node.Prev.Next = Position.Node);\n+      pragma Assert (Position.Node.Next = null\n+                       or else Position.Node.Next.Prev = Position.Node);\n+      pragma Assert (Position.Node.Prev /= null\n+                       or else Position.Node = Position.Container.First);\n+      pragma Assert (Position.Node.Next /= null\n+                       or else Position.Node = Position.Container.Last);\n+\n+      E : Element_Type renames Position.Node.Element;\n+\n+      C : List renames Position.Container.all'Unrestricted_Access.all;\n+      B : Natural renames C.Busy;\n+      L : Natural renames C.Lock;\n+\n    begin\n-      Process (Position.Node.Element);\n+      B := B + 1;\n+      L := L + 1;\n+\n+      begin\n+         Process (E);\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      L := L - 1;\n+      B := B - 1;\n    end Update_Element;\n \n    -----------\n@@ -1279,4 +1873,3 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    end Write;\n \n end Ada.Containers.Doubly_Linked_Lists;\n-"}, {"sha": "32f8d7749e7686b465ebe3dff27aa55f5372c504", "filename": "gcc/ada/a-cdlili.ads", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-cdlili.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-cdlili.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cdlili.ads?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---                    ADA.CONTAINERS.DOUBLY_LINKED_LISTS                    --\n+--   A D A . C O N T A I N E R S . D O U B L Y _ L I N K E D _ L I S T S    --\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -122,18 +122,20 @@ package Ada.Containers.Doubly_Linked_Lists is\n       Count     : Count_Type := 1);\n \n    generic\n-      with function \"<\" (Left, Right : Element_Type)\n-         return Boolean is <>;\n-   procedure Generic_Sort (Container : in out List);\n+      with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n+   package Generic_Sorting is\n \n-   generic\n-      with function \"<\" (Left, Right : Element_Type)\n-         return Boolean is <>;\n-   procedure Generic_Merge (Target : in out List; Source : in out List);\n+      function Is_Sorted (Container : List) return Boolean;\n+\n+      procedure Sort (Container : in out List);\n+\n+      procedure Merge (Target, Source : in out List);\n+\n+   end Generic_Sorting;\n \n    procedure Reverse_List (Container : in out List);\n \n-   procedure Swap (I, J : in Cursor);\n+   procedure Swap (I, J : Cursor);\n \n    procedure Swap_Links\n      (Container : in out List;\n@@ -153,7 +155,7 @@ package Ada.Containers.Doubly_Linked_Lists is\n      (Target   : in out List;\n       Before   : Cursor;\n       Source   : in out List;\n-      Position : Cursor);\n+      Position : in out Cursor);\n \n    function First (Container : List) return Cursor;\n \n@@ -200,21 +202,21 @@ private\n    type Node_Access is access Node_Type;\n \n    type Node_Type is\n-      record\n+      limited record\n          Element : Element_Type;\n          Next    : Node_Access;\n          Prev    : Node_Access;\n       end record;\n \n-   function \"=\" (L, R : Node_Type) return Boolean is abstract;\n-\n    use Ada.Finalization;\n \n    type List is\n      new Controlled with record\n         First  : Node_Access;\n         Last   : Node_Access;\n         Length : Count_Type := 0;\n+        Busy   : Natural := 0;\n+        Lock   : Natural := 0;\n      end record;\n \n    procedure Adjust (Container : in out List);\n@@ -235,7 +237,7 @@ private\n \n    for List'Write use Write;\n \n-   Empty_List : constant List := List'(Controlled with null, null, 0);\n+   Empty_List : constant List := (Controlled with null, null, 0, 0, 0);\n \n    type List_Access is access constant List;\n    for List_Access'Storage_Size use 0;\n@@ -249,4 +251,3 @@ private\n    No_Element : constant Cursor := Cursor'(null, null);\n \n end Ada.Containers.Doubly_Linked_Lists;\n-"}, {"sha": "010d557de82d989f53b3816b8f21b2930b7e0c27", "filename": "gcc/ada/a-chtgke.adb", "status": "modified", "additions": 36, "deletions": 21, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-chtgke.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-chtgke.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgke.adb?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "patch": "@@ -2,11 +2,12 @@\n --                                                                          --\n --                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---                 ADA.CONTAINERS.HASH_TABLES.GENERIC_KEYS                  --\n+--                      A D A . C O N T A I N E R S .                       --\n+--             H A S H _ T A B L E S . G E N E R I C _ K E Y S              --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -40,7 +41,7 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n    --------------------------\n \n    procedure Delete_Key_Sans_Free\n-     (HT   : in out HT_Type;\n+     (HT   : in out Hash_Table_Type;\n       Key  : Key_Type;\n       X    : out Node_Access)\n    is\n@@ -49,18 +50,21 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n \n    begin\n       if HT.Length = 0 then\n-         X := Null_Node;\n+         X := null;\n          return;\n       end if;\n \n       Indx := Index (HT, Key);\n       X := HT.Buckets (Indx);\n \n-      if X = Null_Node then\n+      if X = null then\n          return;\n       end if;\n \n       if Equivalent_Keys (Key, X) then\n+         if HT.Busy > 0 then\n+            raise Program_Error;\n+         end if;\n          HT.Buckets (Indx) := Next (X);\n          HT.Length := HT.Length - 1;\n          return;\n@@ -70,11 +74,14 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n          Prev := X;\n          X := Next (Prev);\n \n-         if X = Null_Node then\n+         if X = null then\n             return;\n          end if;\n \n          if Equivalent_Keys (Key, X) then\n+            if HT.Busy > 0 then\n+               raise Program_Error;\n+            end if;\n             Set_Next (Node => Prev, Next => Next (X));\n             HT.Length := HT.Length - 1;\n             return;\n@@ -87,52 +94,56 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n    ----------\n \n    function Find\n-     (HT  : HT_Type;\n+     (HT  : Hash_Table_Type;\n       Key : Key_Type) return Node_Access is\n \n       Indx : Hash_Type;\n       Node : Node_Access;\n \n    begin\n       if HT.Length = 0 then\n-         return Null_Node;\n+         return null;\n       end if;\n \n       Indx := Index (HT, Key);\n \n       Node := HT.Buckets (Indx);\n-      while Node /= Null_Node loop\n+      while Node /= null loop\n          if Equivalent_Keys (Key, Node) then\n             return Node;\n          end if;\n          Node := Next (Node);\n       end loop;\n \n-      return Null_Node;\n+      return null;\n    end Find;\n \n    --------------------------------\n    -- Generic_Conditional_Insert --\n    --------------------------------\n \n    procedure Generic_Conditional_Insert\n-     (HT      : in out HT_Type;\n-      Key     : Key_Type;\n-      Node    : out Node_Access;\n-      Success : out Boolean)\n+     (HT       : in out Hash_Table_Type;\n+      Key      : Key_Type;\n+      Node     : out Node_Access;\n+      Inserted : out Boolean)\n    is\n       Indx : constant Hash_Type := Index (HT, Key);\n       B    : Node_Access renames HT.Buckets (Indx);\n \n       subtype Length_Subtype is Count_Type range 0 .. Count_Type'Last - 1;\n \n    begin\n-      if B = Null_Node then\n+      if B = null then\n+         if HT.Busy > 0 then\n+            raise Program_Error;\n+         end if;\n+\n          declare\n             Length : constant Length_Subtype := HT.Length;\n          begin\n-            Node := New_Node (Next => Null_Node);\n-            Success := True;\n+            Node := New_Node (Next => null);\n+            Inserted := True;\n \n             B := Node;\n             HT.Length := Length + 1;\n@@ -144,20 +155,24 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n       Node := B;\n       loop\n          if Equivalent_Keys (Key, Node) then\n-            Success := False;\n+            Inserted := False;\n             return;\n          end if;\n \n          Node := Next (Node);\n \n-         exit when Node = Null_Node;\n+         exit when Node = null;\n       end loop;\n \n+      if HT.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n+\n       declare\n          Length : constant Length_Subtype := HT.Length;\n       begin\n          Node := New_Node (Next => B);\n-         Success := True;\n+         Inserted := True;\n \n          B := Node;\n          HT.Length := Length + 1;\n@@ -169,7 +184,7 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n    -----------\n \n    function Index\n-     (HT  : HT_Type;\n+     (HT  : Hash_Table_Type;\n       Key : Key_Type) return Hash_Type is\n    begin\n       return Hash (Key) mod HT.Buckets'Length;"}, {"sha": "a0812ba612ba6072a97f4bb350b12cd86f06277a", "filename": "gcc/ada/a-chtgke.ads", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-chtgke.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-chtgke.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgke.ads?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "patch": "@@ -2,27 +2,44 @@\n --                                                                          --\n --                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---                 ADA.CONTAINERS.HASH_TABLES.GENERIC_KEYS                  --\n+--                      A D A . C O N T A I N E R S .                       --\n+--             H A S H _ T A B L E S . G E N E R I C _ K E Y S              --\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n--- This specification is adapted from the Ada Reference Manual for use with --\n--- GNAT.  In accordance with the copyright of that document, you can freely --\n--- copy and modify this specification,  provided that if you redistribute a --\n--- modified version,  any changes that you have made are clearly indicated. --\n+--          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n generic\n    with package HT_Types is\n      new Generic_Hash_Table_Types (<>);\n \n-   type HT_Type is new HT_Types.Hash_Table_Type with private;\n-\n    use HT_Types;\n \n-   Null_Node : Node_Access;\n-\n    with function Next (Node : Node_Access) return Node_Access;\n \n    with procedure Set_Next\n@@ -41,24 +58,24 @@ package Ada.Containers.Hash_Tables.Generic_Keys is\n    pragma Preelaborate;\n \n    function Index\n-     (HT  : HT_Type;\n+     (HT  : Hash_Table_Type;\n       Key : Key_Type) return Hash_Type;\n    pragma Inline (Index);\n \n    procedure Delete_Key_Sans_Free\n-     (HT   : in out HT_Type;\n+     (HT   : in out Hash_Table_Type;\n       Key  : Key_Type;\n       X    : out Node_Access);\n \n-   function Find (HT  : HT_Type; Key : Key_Type) return Node_Access;\n+   function Find (HT  : Hash_Table_Type; Key : Key_Type) return Node_Access;\n \n    generic\n       with function New_Node\n         (Next : Node_Access) return Node_Access;\n    procedure Generic_Conditional_Insert\n-     (HT      : in out HT_Type;\n-      Key     : Key_Type;\n-      Node    : out Node_Access;\n-      Success : out Boolean);\n+     (HT       : in out Hash_Table_Type;\n+      Key      : Key_Type;\n+      Node     : out Node_Access;\n+      Inserted : out Boolean);\n \n end Ada.Containers.Hash_Tables.Generic_Keys;"}, {"sha": "39879b64aa8037b82fc391400c7faf14277dd170", "filename": "gcc/ada/a-chtgop.adb", "status": "modified", "additions": 176, "deletions": 118, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-chtgop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-chtgop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgop.adb?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "patch": "@@ -2,11 +2,12 @@\n --                                                                          --\n --                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---              ADA.CONTAINERS.HASH_TABLES.GENERIC_OPERATIONS               --\n+--                       A D A . C O N T A I N E R S .                      --\n+--       H A S H _ T A B L E S . G E N E R I C _ O P E R A T I O N S        --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -68,7 +69,9 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n       end if;\n \n       HT.Buckets := new Buckets_Type (Src_Buckets'Range);\n+      --  TODO: allocate minimum size req'd.  (See note below.)\n \n+      --  NOTE: see note below about these comments.\n       --  Probably we have to duplicate the Size (Src), too, in order\n       --  to guarantee that\n \n@@ -80,11 +83,30 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n       --  If we relax the requirement that the hash value must be the\n       --  same, then of course we can't guarantee that following\n       --  assignment that Dst = Src is true ???\n+      --\n+      --  NOTE: 17 Apr 2005\n+      --  What I said above is no longer true.  The semantics of (map) equality\n+      --  changed, such that we use key in the left map to look up the\n+      --  equivalent key in the right map, and then compare the elements (using\n+      --  normal equality) of the equivalent keys.  So it doesn't matter that\n+      --  the maps have different capacities (i.e. the hash tables have\n+      --  different lengths), since we just look up the key, irrespective of\n+      --  its map's hash table length.  All the RM says we're required to do\n+      --  it arrange for the target map to \"=\" the source map following an\n+      --  assignment (that is, following an Adjust), so it doesn't matter\n+      --  what the capacity of the target map is.  What I'll probably do is\n+      --  allocate a new hash table that has the minimum size necessary,\n+      --  instead of allocating a new hash table whose size exactly matches\n+      --  that of the source.  (See the assignment that immediately precedes\n+      --  these comments.)  What we really need is a special Assign operation\n+      --  (not unlike what we have already for Vector) that allows the user to\n+      --  choose the capacity of the target.\n+      --  END NOTE.\n \n       for Src_Index in Src_Buckets'Range loop\n          Src_Node := Src_Buckets (Src_Index);\n \n-         if Src_Node /= Null_Node then\n+         if Src_Node /= null then\n             declare\n                Dst_Node : constant Node_Access := Copy_Node (Src_Node);\n \n@@ -100,7 +122,7 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n             end;\n \n             Src_Node := Next (Src_Node);\n-            while Src_Node /= Null_Node loop\n+            while Src_Node /= null loop\n                declare\n                   Dst_Node : constant Node_Access := Copy_Node (Src_Node);\n \n@@ -145,8 +167,12 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n       Node  : Node_Access;\n \n    begin\n+      if HT.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n+\n       while HT.Length > 0 loop\n-         while HT.Buckets (Index) = Null_Node loop\n+         while HT.Buckets (Index) = null loop\n             Index := Index + 1;\n          end loop;\n \n@@ -158,7 +184,7 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n                Bucket := Next (Bucket);\n                HT.Length := HT.Length - 1;\n                Free (Node);\n-               exit when Bucket = Null_Node;\n+               exit when Bucket = null;\n             end loop;\n          end;\n       end loop;\n@@ -172,7 +198,7 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n      (HT : in out Hash_Table_Type;\n       X  : Node_Access)\n    is\n-      pragma Assert (X /= Null_Node);\n+      pragma Assert (X /= null);\n \n       Indx : Hash_Type;\n       Prev : Node_Access;\n@@ -186,7 +212,7 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n       Indx := Index (HT, X);\n       Prev := HT.Buckets (Indx);\n \n-      if Prev = Null_Node then\n+      if Prev = null then\n          raise Program_Error;\n       end if;\n \n@@ -203,7 +229,7 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n       loop\n          Curr := Next (Prev);\n \n-         if Curr = Null_Node then\n+         if Curr = null then\n             raise Program_Error;\n          end if;\n \n@@ -217,75 +243,6 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n       end loop;\n    end Delete_Node_Sans_Free;\n \n-   ---------------------\n-   -- Ensure_Capacity --\n-   ---------------------\n-\n-   procedure Ensure_Capacity\n-     (HT : in out Hash_Table_Type;\n-      N  : Count_Type)\n-   is\n-      NN : Hash_Type;\n-\n-   begin\n-      if N = 0 then\n-         if HT.Length = 0 then\n-            Free (HT.Buckets);\n-\n-         elsif HT.Length < HT.Buckets'Length then\n-            NN := Prime_Numbers.To_Prime (HT.Length);\n-\n-            --  ASSERT: NN >= HT.Length\n-\n-            if NN < HT.Buckets'Length then\n-               Rehash (HT, Size => NN);\n-            end if;\n-         end if;\n-\n-         return;\n-      end if;\n-\n-      if HT.Buckets = null then\n-         NN := Prime_Numbers.To_Prime (N);\n-\n-         --  ASSERT: NN >= N\n-\n-         Rehash (HT, Size => NN);\n-         return;\n-      end if;\n-\n-      if N <= HT.Length then\n-         if HT.Length >= HT.Buckets'Length then\n-            return;\n-         end if;\n-\n-         NN := Prime_Numbers.To_Prime (HT.Length);\n-\n-         --  ASSERT: NN >= HT.Length\n-\n-         if NN < HT.Buckets'Length then\n-            Rehash (HT, Size => NN);\n-         end if;\n-\n-         return;\n-      end if;\n-\n-      --  ASSERT: N > HT.Length\n-\n-      if N = HT.Buckets'Length then\n-         return;\n-      end if;\n-\n-      NN := Prime_Numbers.To_Prime (N);\n-\n-      --  ASSERT: NN >= N\n-      --  ASSERT: NN > HT.Length\n-\n-      if NN /= HT.Buckets'Length then\n-         Rehash (HT, Size => NN);\n-      end if;\n-   end Ensure_Capacity;\n-\n    --------------\n    -- Finalize --\n    --------------\n@@ -305,12 +262,12 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n \n    begin\n       if HT.Length = 0 then\n-         return Null_Node;\n+         return null;\n       end if;\n \n       Indx := HT.Buckets'First;\n       loop\n-         if HT.Buckets (Indx) /= Null_Node then\n+         if HT.Buckets (Indx) /= null then\n             return HT.Buckets (Indx);\n          end if;\n \n@@ -331,7 +288,7 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n       end if;\n \n       for J in Buckets'Range loop\n-         while Buckets (J) /= Null_Node loop\n+         while Buckets (J) /= null loop\n             Node := Buckets (J);\n             Buckets (J) := Next (Node);\n             Free (Node);\n@@ -370,7 +327,7 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n \n       loop\n          L_Node := L.Buckets (L_Index);\n-         exit when L_Node /= Null_Node;\n+         exit when L_Node /= null;\n          L_Index := L_Index + 1;\n       end loop;\n \n@@ -385,15 +342,15 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n \n          L_Node := Next (L_Node);\n \n-         if L_Node = Null_Node then\n+         if L_Node = null then\n             if N = 0 then\n                return True;\n             end if;\n \n             loop\n                L_Index := L_Index + 1;\n                L_Node := L.Buckets (L_Index);\n-               exit when L_Node /= Null_Node;\n+               exit when L_Node /= null;\n             end loop;\n          end if;\n       end loop;\n@@ -404,22 +361,32 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n    -----------------------\n \n    procedure Generic_Iteration (HT : Hash_Table_Type) is\n-      Node : Node_Access;\n+      Busy : Natural renames HT'Unrestricted_Access.all.Busy;\n \n    begin\n-      if HT.Buckets = null\n-        or else HT.Length = 0\n-      then\n+      if HT.Length = 0 then\n          return;\n       end if;\n \n-      for Indx in HT.Buckets'Range loop\n-         Node := HT.Buckets (Indx);\n-         while Node /= Null_Node loop\n-            Process (Node);\n-            Node := Next (Node);\n+      Busy := Busy + 1;\n+\n+      declare\n+         Node : Node_Access;\n+      begin\n+         for Indx in HT.Buckets'Range loop\n+            Node := HT.Buckets (Indx);\n+            while Node /= null loop\n+               Process (Node);\n+               Node := Next (Node);\n+            end loop;\n          end loop;\n-      end loop;\n+      exception\n+         when others =>\n+            Busy := Busy - 1;\n+            raise;\n+      end;\n+\n+      Busy := Busy - 1;\n    end Generic_Iteration;\n \n    ------------------\n@@ -436,10 +403,6 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n       N, M    : Count_Type'Base;\n \n    begin\n-      --  As with the sorted set, it's not clear whether read is allowed to\n-      --  have side effect if it fails. For now, we assume side effects are\n-      --  allowed since it simplifies the algorithm ???\n-      --\n       Clear (HT);\n \n       declare\n@@ -452,6 +415,10 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n \n       Hash_Type'Read (Stream, Last);\n \n+      --  TODO: don't immediately deallocate the buckets array we\n+      --  already have. Instead, allocate a new buckets array only\n+      --  if it needs to expanded because of the value of Last.\n+\n       if Last /= 0 then\n          HT.Buckets := new Buckets_Type (0 .. Last);\n       end if;\n@@ -461,24 +428,24 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n       while N > 0 loop\n          Hash_Type'Read (Stream, I);\n          pragma Assert (I in HT.Buckets'Range);\n-         pragma Assert (HT.Buckets (I) = Null_Node);\n+         pragma Assert (HT.Buckets (I) = null);\n \n          Count_Type'Base'Read (Stream, M);\n          pragma Assert (M >= 1);\n          pragma Assert (M <= N);\n \n          HT.Buckets (I) := New_Node (Stream);\n-         pragma Assert (HT.Buckets (I) /= Null_Node);\n-         pragma Assert (Next (HT.Buckets (I)) = Null_Node);\n+         pragma Assert (HT.Buckets (I) /= null);\n+         pragma Assert (Next (HT.Buckets (I)) = null);\n \n          Y := HT.Buckets (I);\n \n          HT.Length := HT.Length + 1;\n \n          for J in Count_Type range 2 .. M loop\n             X := New_Node (Stream);\n-            pragma Assert (X /= Null_Node);\n-            pragma Assert (Next (X) = Null_Node);\n+            pragma Assert (X /= null);\n+            pragma Assert (Next (X) = null);\n \n             Set_Next (Node => Y, Next => X);\n             Y := X;\n@@ -517,11 +484,11 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n       for Indx in HT.Buckets'Range loop\n          X := HT.Buckets (Indx);\n \n-         if X /= Null_Node then\n+         if X /= null then\n             M := 1;\n             loop\n                X := Next (X);\n-               exit when X = Null_Node;\n+               exit when X = null;\n                M := M + 1;\n             end loop;\n \n@@ -534,7 +501,7 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n                X := Next (X);\n             end loop;\n \n-            pragma Assert (X = Null_Node);\n+            pragma Assert (X = null);\n          end if;\n       end loop;\n    end Generic_Write;\n@@ -567,14 +534,18 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n          return;\n       end if;\n \n-      if Target.Length > 0 then\n-         raise Constraint_Error;\n+      if Source.Busy > 0 then\n+         raise Program_Error;\n       end if;\n \n-      Free (Target.Buckets);\n+      Clear (Target);\n \n-      Target.Buckets := Source.Buckets;\n-      Source.Buckets := null;\n+      declare\n+         Buckets : constant Buckets_Access := Target.Buckets;\n+      begin\n+         Target.Buckets := Source.Buckets;\n+         Source.Buckets := Buckets;\n+      end;\n \n       Target.Length := Source.Length;\n       Source.Length := 0;\n@@ -591,19 +562,19 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n       Result : Node_Access := Next (Node);\n \n    begin\n-      if Result /= Null_Node then\n+      if Result /= null then\n          return Result;\n       end if;\n \n       for Indx in Index (HT, Node) + 1 .. HT.Buckets'Last loop\n          Result := HT.Buckets (Indx);\n \n-         if Result /= Null_Node then\n+         if Result /= null then\n             return Result;\n          end if;\n       end loop;\n \n-      return Null_Node;\n+      return null;\n    end Next;\n \n    ------------\n@@ -642,7 +613,7 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n          declare\n             Src_Bucket : Node_Access renames Src_Buckets (Src_Index);\n          begin\n-            while Src_Bucket /= Null_Node loop\n+            while Src_Bucket /= null loop\n                declare\n                   Src_Node   : constant Node_Access := Src_Bucket;\n                   Dst_Index  : constant Hash_Type :=\n@@ -662,6 +633,7 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n          exception\n             when others =>\n \n+               --  NOTE: see todo below.\n                --  Not clear that we can deallocate the nodes,\n                --  because they may be designated by outstanding\n                --  iterators.  Which means they're now lost... ???\n@@ -671,17 +643,23 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n                --                       Dst : Node_Access renames NB (J);\n                --                       X   : Node_Access;\n                --                    begin\n-               --                       while Dst /= Null_Node loop\n+               --                       while Dst /= null loop\n                --                          X := Dst;\n                --                          Dst := Succ (Dst);\n                --                          Free (X);\n                --                       end loop;\n                --                    end;\n                --                 end loop;\n \n+               --  TODO: 17 Apr 2005\n+               --  What I should do instead is go ahead and deallocate the\n+               --  nodes, since when assertions are enabled, we vet the\n+               --  cursors, and we modify the state of a node enough when\n+               --  it is deallocated in order to detect mischief.\n+               --  END TODO.\n \n                Free (Dst_Buckets);\n-               raise;\n+               raise;  --  TODO: raise Program_Error instead\n          end;\n \n          --  exit when L = 0;\n@@ -697,5 +675,85 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n       Free (Src_Buckets);\n    end Rehash;\n \n-end Ada.Containers.Hash_Tables.Generic_Operations;\n+   ----------------------\n+   -- Reserve_Capacity --\n+   ----------------------\n+\n+   procedure Reserve_Capacity\n+     (HT : in out Hash_Table_Type;\n+      N  : Count_Type)\n+   is\n+      NN : Hash_Type;\n+\n+   begin\n+      if N = 0 then\n+         if HT.Length = 0 then\n+            Free (HT.Buckets);\n+\n+         elsif HT.Length < HT.Buckets'Length then\n+            NN := Prime_Numbers.To_Prime (HT.Length);\n+\n+            --  ASSERT: NN >= HT.Length\n+\n+            if NN < HT.Buckets'Length then\n+               if HT.Busy > 0 then\n+                  raise Program_Error;\n+               end if;\n+\n+               Rehash (HT, Size => NN);\n+            end if;\n+         end if;\n+\n+         return;\n+      end if;\n+\n+      if HT.Buckets = null then\n+         NN := Prime_Numbers.To_Prime (N);\n+\n+         --  ASSERT: NN >= N\n+\n+         Rehash (HT, Size => NN);\n+         return;\n+      end if;\n+\n+      if N <= HT.Length then\n+         if HT.Length >= HT.Buckets'Length then\n+            return;\n+         end if;\n+\n+         NN := Prime_Numbers.To_Prime (HT.Length);\n+\n+         --  ASSERT: NN >= HT.Length\n+\n+         if NN < HT.Buckets'Length then\n+            if HT.Busy > 0 then\n+               raise Program_Error;\n+            end if;\n+\n+            Rehash (HT, Size => NN);\n+         end if;\n+\n+         return;\n+      end if;\n \n+      --  ASSERT: N > HT.Length\n+\n+      if N = HT.Buckets'Length then\n+         return;\n+      end if;\n+\n+      NN := Prime_Numbers.To_Prime (N);\n+\n+      --  ASSERT: NN >= N\n+      --  ASSERT: NN > HT.Length\n+\n+      if NN /= HT.Buckets'Length then\n+         if HT.Busy > 0 then\n+            raise Program_Error;\n+         end if;\n+\n+         Rehash (HT, Size => NN);\n+      end if;\n+   end Reserve_Capacity;\n+\n+end Ada.Containers.Hash_Tables.Generic_Operations;"}, {"sha": "7d6e545e27196e46d88f73fc0391b887bcb89cd1", "filename": "gcc/ada/a-chtgop.ads", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-chtgop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-chtgop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgop.ads?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "patch": "@@ -2,12 +2,11 @@\n --                                                                          --\n --                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---              ADA.CONTAINERS.HASH_TABLES.GENERIC_OPERATIONS               --\n+--                       A D A . C O N T A I N E R S .                      --\n+--       H A S H _ T A B L E S . G E N E R I C _ O P E R A T I O N S        --\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2004 Free Software Foundation, Inc.            --\n---                                                                          --\n -- This specification is adapted from the Ada Reference Manual for use with --\n -- GNAT.  In accordance with the copyright of that document, you can freely --\n -- copy and modify this specification,  provided that if you redistribute a --\n@@ -22,12 +21,8 @@ generic\n    with package HT_Types is\n      new Generic_Hash_Table_Types (<>);\n \n-   type Hash_Table_Type is new HT_Types.Hash_Table_Type with private;\n-\n    use HT_Types;\n \n-   Null_Node : in Node_Access;\n-\n    with function Hash_Node (Node : Node_Access) return Hash_Type;\n \n    with function Next (Node : Node_Access) return Node_Access;\n@@ -72,7 +67,7 @@ package Ada.Containers.Hash_Tables.Generic_Operations is\n \n    function Capacity (HT : Hash_Table_Type) return Count_Type;\n \n-   procedure Ensure_Capacity\n+   procedure Reserve_Capacity\n      (HT : in out Hash_Table_Type;\n       N  : Count_Type);\n \n@@ -108,4 +103,3 @@ package Ada.Containers.Hash_Tables.Generic_Operations is\n       HT     : out Hash_Table_Type);\n \n end Ada.Containers.Hash_Tables.Generic_Operations;\n-"}, {"sha": "6fb6d9e0f820b337c869c802f1928c4df610feef", "filename": "gcc/ada/a-cidlli.adb", "status": "modified", "additions": 941, "deletions": 318, "changes": 1259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-cidlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-cidlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cidlli.adb?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "patch": "@@ -2,11 +2,12 @@\n --                                                                          --\n --                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---              ADA.CONTAINERS.INDEFINITE_DOUBLY_LINKED_LISTS               --\n+--                      A D A . C O N T A I N E R S .                       --\n+--        I N D E F I N I T E _ D O U B L Y _ L I N K E D _ L I S T S       --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -48,10 +49,6 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    -- Local Subprograms --\n    -----------------------\n \n-   procedure Delete_Node\n-     (Container : in out List;\n-      Node      : in out Node_Access);\n-\n    procedure Insert_Internal\n      (Container : in out List;\n       Before    : Node_Access;\n@@ -77,15 +74,7 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       L := Left.First;\n       R := Right.First;\n       for J in 1 .. Left.Length loop\n-         if L.Element = null then\n-            if R.Element /= null then\n-               return False;\n-            end if;\n-\n-         elsif R.Element = null then\n-            return False;\n-\n-         elsif L.Element.all /= R.Element.all then\n+         if L.Element.all /= R.Element.all then\n             return False;\n          end if;\n \n@@ -108,6 +97,8 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       if Src = null then\n          pragma Assert (Container.Last = null);\n          pragma Assert (Container.Length = 0);\n+         pragma Assert (Container.Busy = 0);\n+         pragma Assert (Container.Lock = 0);\n          return;\n       end if;\n \n@@ -118,41 +109,40 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       Container.First := null;\n       Container.Last := null;\n       Container.Length := 0;\n+      Container.Busy := 0;\n+      Container.Lock := 0;\n \n-      Dst := new Node_Type'(null, null, null);\n+      declare\n+         Element : Element_Access := new Element_Type'(Src.Element.all);\n+      begin\n+         Dst := new Node_Type'(Element, null, null);\n+      exception\n+         when others =>\n+            Free (Element);\n+            raise;\n+      end;\n \n-      if Src.Element /= null then\n+      Container.First := Dst;\n+      Container.Last := Dst;\n+      Container.Length := 1;\n+\n+      Src := Src.Next;\n+      while Src /= null loop\n+         declare\n+            Element : Element_Access := new Element_Type'(Src.Element.all);\n          begin\n-            Dst.Element := new Element_Type'(Src.Element.all);\n+            Dst := new Node_Type'(Element, null, Prev => Container.Last);\n          exception\n             when others =>\n-               Free (Dst);\n+               Free (Element);\n                raise;\n          end;\n-      end if;\n-\n-      Container.First := Dst;\n-\n-      Container.Last := Dst;\n-      loop\n-         Container.Length := Container.Length + 1;\n-         Src := Src.Next;\n-         exit when Src = null;\n-\n-         Dst := new Node_Type'(null, Prev => Container.Last, Next => null);\n-\n-         if Src.Element /= null then\n-            begin\n-               Dst.Element := new Element_Type'(Src.Element.all);\n-            exception\n-               when others =>\n-                  Free (Dst);\n-                  raise;\n-            end;\n-         end if;\n \n          Container.Last.Next := Dst;\n          Container.Last := Dst;\n+         Container.Length := Container.Length + 1;\n+\n+         Src := Src.Next;\n       end loop;\n    end Adjust;\n \n@@ -174,8 +164,63 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    -----------\n \n    procedure Clear (Container : in out List) is\n+      X : Node_Access;\n+\n    begin\n-      Delete_Last (Container, Count => Container.Length);\n+      if Container.Length = 0 then\n+         pragma Assert (Container.First = null);\n+         pragma Assert (Container.Last = null);\n+         pragma Assert (Container.Busy = 0);\n+         pragma Assert (Container.Lock = 0);\n+         return;\n+      end if;\n+\n+      pragma Assert (Container.First.Prev = null);\n+      pragma Assert (Container.Last.Next = null);\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n+\n+      while Container.Length > 1 loop\n+         X := Container.First;\n+         pragma Assert (X.Next.Prev = Container.First);\n+\n+         Container.First := X.Next;\n+         Container.First.Prev := null;\n+         Container.Length := Container.Length - 1;\n+\n+         X.Next := null;  --  prevent mischief\n+\n+         begin\n+            Free (X.Element);\n+         exception\n+            when others =>\n+               X.Element := null;\n+               Free (X);\n+               raise;\n+         end;\n+\n+         Free (X);\n+      end loop;\n+\n+      X := Container.First;\n+      pragma Assert (X = Container.Last);\n+\n+      Container.First := null;\n+      Container.Last := null;\n+      Container.Length := 0;\n+\n+      begin\n+         Free (X.Element);\n+      exception\n+         when others =>\n+            X.Element := null;\n+            Free (X);\n+            raise;\n+      end;\n+\n+      Free (X);\n    end Clear;\n \n    --------------\n@@ -198,22 +243,88 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       Position  : in out Cursor;\n       Count     : Count_Type := 1)\n    is\n+      X : Node_Access;\n+\n    begin\n-      if Position = No_Element then\n-         return;\n+      if Position.Node = null then\n+         raise Constraint_Error;\n       end if;\n \n       if Position.Container /= List_Access'(Container'Unchecked_Access) then\n          raise Program_Error;\n       end if;\n \n+      pragma Assert (Container.Length > 0);\n+      pragma Assert (Container.First.Prev = null);\n+      pragma Assert (Container.Last.Next = null);\n+\n+      pragma Assert (Position.Node.Element /= null);\n+      pragma Assert (Position.Node.Prev = null\n+                       or else Position.Node.Prev.Next = Position.Node);\n+      pragma Assert (Position.Node.Next = null\n+                       or else Position.Node.Next.Prev = Position.Node);\n+      pragma Assert (Position.Node.Prev /= null\n+                       or else Position.Node = Container.First);\n+      pragma Assert (Position.Node.Next /= null\n+                       or else Position.Node = Container.Last);\n+\n+      if Position.Node = Container.First then\n+         Delete_First (Container, Count);\n+         Position := First (Container);\n+         return;\n+      end if;\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n+\n       for Index in 1 .. Count loop\n-         Delete_Node (Container, Position.Node);\n+         X := Position.Node;\n+         Container.Length := Container.Length - 1;\n+\n+         if X = Container.Last then\n+            Position := No_Element;\n \n-         if Position.Node = null then\n-            Position.Container := null;\n+            Container.Last := X.Prev;\n+            Container.Last.Next := null;\n+\n+            X.Prev := null;  --  prevent mischief\n+\n+            begin\n+               Free (X.Element);\n+            exception\n+               when others =>\n+                  X.Element := null;\n+                  Free (X);\n+                  raise;\n+            end;\n+\n+            Free (X);\n             return;\n          end if;\n+\n+         Position.Node := X.Next;\n+\n+         X.Next.Prev := X.Prev;\n+         X.Prev.Next := X.Next;\n+\n+         X.Prev := null;\n+         X.Next := null;\n+\n+         begin\n+            Free (X.Element);\n+         exception\n+            when others =>\n+               X.Element := null;\n+               Free (X);\n+               raise;\n+         end;\n+\n+         Free (X);\n       end loop;\n    end Delete;\n \n@@ -225,10 +336,43 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n      (Container : in out List;\n       Count     : Count_Type := 1)\n    is\n-      Node : Node_Access := Container.First;\n+      X : Node_Access;\n+\n    begin\n-      for J in 1 .. Count_Type'Min (Count, Container.Length) loop\n-         Delete_Node (Container, Node);\n+      if Count >= Container.Length then\n+         Clear (Container);\n+         return;\n+      end if;\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n+\n+      for I in 1 .. Count loop\n+         X := Container.First;\n+         pragma Assert (X.Next.Prev = Container.First);\n+\n+         Container.First := X.Next;\n+         Container.First.Prev := null;\n+\n+         Container.Length := Container.Length - 1;\n+\n+         X.Next := null;  --  prevent mischief\n+\n+         begin\n+            Free (X.Element);\n+         exception\n+            when others =>\n+               X.Element := null;\n+               Free (X);\n+               raise;\n+         end;\n+\n+         Free (X);\n       end loop;\n    end Delete_First;\n \n@@ -240,64 +384,68 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n      (Container : in out List;\n       Count     : Count_Type := 1)\n    is\n-      Node : Node_Access;\n-   begin\n-      for J in 1 .. Count_Type'Min (Count, Container.Length) loop\n-         Node := Container.Last;\n-         Delete_Node (Container, Node);\n-      end loop;\n-   end Delete_Last;\n-\n-   -----------------\n-   -- Delete_Node --\n-   -----------------\n-\n-   procedure Delete_Node\n-     (Container : in out List;\n-      Node      : in out Node_Access)\n-   is\n-      X : Node_Access := Node;\n+      X : Node_Access;\n \n    begin\n-      Node := X.Next;\n-      Container.Length := Container.Length - 1;\n+      if Count >= Container.Length then\n+         Clear (Container);\n+         return;\n+      end if;\n \n-      if X = Container.First then\n-         Container.First := X.Next;\n+      if Count = 0 then\n+         return;\n+      end if;\n \n-         if X = Container.Last then\n-            pragma Assert (Container.First = null);\n-            pragma Assert (Container.Length = 0);\n-            Container.Last := null;\n-         else\n-            pragma Assert (Container.Length > 0);\n-            Container.First.Prev := null;\n-         end if;\n+      if Container.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n \n-      elsif X = Container.Last then\n-         pragma Assert (Container.Length > 0);\n+      for I in 1 .. Count loop\n+         X := Container.Last;\n+         pragma Assert (X.Prev.Next = Container.Last);\n \n          Container.Last := X.Prev;\n          Container.Last.Next := null;\n \n-      else\n-         pragma Assert (Container.Length > 0);\n+         Container.Length := Container.Length - 1;\n \n-         X.Next.Prev := X.Prev;\n-         X.Prev.Next := X.Next;\n+         X.Prev := null;  --  prevent mischief\n \n-      end if;\n+         begin\n+            Free (X.Element);\n+         exception\n+            when others =>\n+               X.Element := null;\n+               Free (X);\n+               raise;\n+         end;\n \n-      Free (X.Element);\n-      Free (X);\n-   end Delete_Node;\n+         Free (X);\n+      end loop;\n+   end Delete_Last;\n \n    -------------\n    -- Element --\n    -------------\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n+      pragma Assert (Position.Container /= null);\n+      pragma Assert (Position.Container.Length > 0);\n+      pragma Assert (Position.Container.First.Prev = null);\n+      pragma Assert (Position.Container.Last.Next = null);\n+\n+      pragma Assert (Position.Node /= null);\n+      pragma Assert (Position.Node.Element /= null);\n+      pragma Assert (Position.Node.Prev = null\n+                       or else Position.Node.Prev.Next = Position.Node);\n+      pragma Assert (Position.Node.Next = null\n+                       or else Position.Node.Next.Prev = Position.Node);\n+      pragma Assert (Position.Node.Prev /= null\n+                       or else Position.Node = Position.Container.First);\n+      pragma Assert (Position.Node.Next /= null\n+                       or else Position.Node = Position.Container.Last);\n+\n       return Position.Node.Element.all;\n    end Element;\n \n@@ -315,14 +463,29 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    begin\n       if Node = null then\n          Node := Container.First;\n-      elsif Position.Container /= List_Access'(Container'Unchecked_Access) then\n-         raise Program_Error;\n+\n+      else\n+         if Position.Container /= List_Access'(Container'Unchecked_Access) then\n+            raise Program_Error;\n+         end if;\n+\n+         pragma Assert (Container.Length > 0);\n+         pragma Assert (Container.First.Prev = null);\n+         pragma Assert (Container.Last.Next = null);\n+\n+         pragma Assert (Position.Node.Element /= null);\n+         pragma Assert (Position.Node.Prev = null\n+                          or else Position.Node.Prev.Next = Position.Node);\n+         pragma Assert (Position.Node.Next = null\n+                          or else Position.Node.Next.Prev = Position.Node);\n+         pragma Assert (Position.Node.Prev /= null\n+                          or else Position.Node = Container.First);\n+         pragma Assert (Position.Node.Next /= null\n+                          or else Position.Node = Container.Last);\n       end if;\n \n       while Node /= null loop\n-         if Node.Element /= null\n-           and then Node.Element.all = Item\n-         then\n+         if Node.Element.all = Item then\n             return Cursor'(Container'Unchecked_Access, Node);\n          end if;\n \n@@ -354,143 +517,196 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       return Container.First.Element.all;\n    end First_Element;\n \n-   -------------------\n-   -- Generic_Merge --\n-   -------------------\n+   ---------------------\n+   -- Generic_Sorting --\n+   ---------------------\n \n-   procedure Generic_Merge\n-     (Target : in out List;\n-      Source : in out List)\n-   is\n-      LI : Cursor;\n-      RI : Cursor;\n+   package body Generic_Sorting is\n \n-   begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n+      ---------------\n+      -- Is_Sorted --\n+      ---------------\n+\n+      function Is_Sorted (Container : List) return Boolean is\n+         Node : Node_Access := Container.First;\n+\n+      begin\n+         for I in 2 .. Container.Length loop\n+            if Node.Next.Element.all < Node.Element.all then\n+               return False;\n+            end if;\n+\n+            Node := Node.Next;\n+         end loop;\n+\n+         return True;\n+      end Is_Sorted;\n+\n+      -----------\n+      -- Merge --\n+      -----------\n \n-      LI := First (Target);\n-      RI := First (Source);\n-      while RI.Node /= null loop\n-         if LI.Node = null then\n-            Splice (Target, No_Element, Source);\n+      procedure Merge\n+        (Target : in out List;\n+         Source : in out List)\n+      is\n+         LI : Cursor;\n+         RI : Cursor;\n+\n+      begin\n+         if Target'Address = Source'Address then\n             return;\n          end if;\n \n-         if LI.Node.Element = null then\n-            LI.Node := LI.Node.Next;\n-\n-         elsif RI.Node.Element = null\n-           or else RI.Node.Element.all < LI.Node.Element.all\n+         if Target.Busy > 0\n+           or else Source.Busy > 0\n          then\n-            declare\n-               RJ : constant Cursor := RI;\n-            begin\n-               RI.Node := RI.Node.Next;\n-               Splice (Target, LI, Source, RJ);\n-            end;\n-\n-         else\n-            LI.Node := LI.Node.Next;\n+            raise Program_Error;\n          end if;\n-      end loop;\n-   end Generic_Merge;\n \n-   ------------------\n-   -- Generic_Sort --\n-   ------------------\n+         LI := First (Target);\n+         RI := First (Source);\n+         while RI.Node /= null loop\n+            if LI.Node = null then\n+               Splice (Target, No_Element, Source);\n+               return;\n+            end if;\n \n-   procedure Generic_Sort (Container : in out List) is\n-      procedure Partition (Pivot : Node_Access; Back  : Node_Access);\n+            if RI.Node.Element.all < LI.Node.Element.all then\n+               declare\n+                  RJ : Cursor := RI;\n+               begin\n+                  RI.Node := RI.Node.Next;\n+                  Splice (Target, LI, Source, RJ);\n+               end;\n \n-      procedure Sort (Front, Back : Node_Access);\n+            else\n+               LI.Node := LI.Node.Next;\n+            end if;\n+         end loop;\n+      end Merge;\n \n-      ---------------\n-      -- Partition --\n-      ---------------\n+      ----------\n+      -- Sort --\n+      ----------\n \n-      procedure Partition (Pivot : Node_Access; Back  : Node_Access) is\n-         Node : Node_Access := Pivot.Next;\n+      procedure Sort (Container : in out List) is\n+         procedure Partition (Pivot : Node_Access; Back  : Node_Access);\n \n-      begin\n-         while Node /= Back loop\n-            if Pivot.Element = null then\n-               Node := Node.Next;\n+         procedure Sort (Front, Back : Node_Access);\n \n-            elsif Node.Element = null\n-              or else Node.Element.all < Pivot.Element.all\n-            then\n-               declare\n-                  Prev : constant Node_Access := Node.Prev;\n-                  Next : constant Node_Access := Node.Next;\n-               begin\n-                  Prev.Next := Next;\n+         ---------------\n+         -- Partition --\n+         ---------------\n \n-                  if Next = null then\n-                     Container.Last := Prev;\n-                  else\n-                     Next.Prev := Prev;\n-                  end if;\n+         procedure Partition (Pivot : Node_Access; Back : Node_Access) is\n+            Node : Node_Access := Pivot.Next;\n \n-                  Node.Next := Pivot;\n-                  Node.Prev := Pivot.Prev;\n+         begin\n+            while Node /= Back loop\n+               if Node.Element.all < Pivot.Element.all then\n+                  declare\n+                     Prev : constant Node_Access := Node.Prev;\n+                     Next : constant Node_Access := Node.Next;\n+                  begin\n+                     Prev.Next := Next;\n+\n+                     if Next = null then\n+                        Container.Last := Prev;\n+                     else\n+                        Next.Prev := Prev;\n+                     end if;\n+\n+                     Node.Next := Pivot;\n+                     Node.Prev := Pivot.Prev;\n+\n+                     Pivot.Prev := Node;\n+\n+                     if Node.Prev = null then\n+                        Container.First := Node;\n+                     else\n+                        Node.Prev.Next := Node;\n+                     end if;\n+\n+                     Node := Next;\n+                  end;\n \n-                  Pivot.Prev := Node;\n+               else\n+                  Node := Node.Next;\n+               end if;\n+            end loop;\n+         end Partition;\n \n-                  if Node.Prev = null then\n-                     Container.First := Node;\n-                  else\n-                     Node.Prev.Next := Node;\n-                  end if;\n+         ----------\n+         -- Sort --\n+         ----------\n \n-                  Node := Next;\n-               end;\n+         procedure Sort (Front, Back : Node_Access) is\n+            Pivot : Node_Access;\n \n+         begin\n+            if Front = null then\n+               Pivot := Container.First;\n             else\n-               Node := Node.Next;\n+               Pivot := Front.Next;\n             end if;\n-         end loop;\n-      end Partition;\n \n-      ----------\n-      -- Sort --\n-      ----------\n+            if Pivot /= Back then\n+               Partition (Pivot, Back);\n+               Sort (Front, Pivot);\n+               Sort (Pivot, Back);\n+            end if;\n+         end Sort;\n \n-      procedure Sort (Front, Back : Node_Access) is\n-         Pivot : Node_Access;\n+      --  Start of processing for Sort\n \n       begin\n-         if Front = null then\n-            Pivot := Container.First;\n-         else\n-            Pivot := Front.Next;\n+         if Container.Length <= 1 then\n+            return;\n          end if;\n \n-         if Pivot /= Back then\n-            Partition (Pivot, Back);\n-            Sort (Front, Pivot);\n-            Sort (Pivot, Back);\n+         pragma Assert (Container.First.Prev = null);\n+         pragma Assert (Container.Last.Next = null);\n+\n+         if Container.Busy > 0 then\n+            raise Program_Error;\n          end if;\n-      end Sort;\n \n-   --  Start of processing for Generic_Sort\n+         Sort (Front => null, Back => null);\n \n-   begin\n-      Sort (Front => null, Back => null);\n+         pragma Assert (Container.First.Prev = null);\n+         pragma Assert (Container.Last.Next = null);\n+      end Sort;\n \n-      pragma Assert (Container.Length = 0\n-                       or else (Container.First.Prev = null\n-                                  and Container.Last.Next = null));\n-   end Generic_Sort;\n+   end Generic_Sorting;\n \n    -----------------\n    -- Has_Element --\n    -----------------\n \n    function Has_Element (Position : Cursor) return Boolean is\n    begin\n-      return Position.Container /= null and then Position.Node /= null;\n+      if Position.Node = null then\n+         pragma Assert (Position.Container = null);\n+         return False;\n+      end if;\n+\n+      pragma Assert (Position.Container /= null);\n+      pragma Assert (Position.Container.Length > 0);\n+      pragma Assert (Position.Container.First.Prev = null);\n+      pragma Assert (Position.Container.Last.Next = null);\n+\n+      pragma Assert (Position.Node.Element /= null);\n+      pragma Assert (Position.Node.Prev = null\n+                       or else Position.Node.Prev.Next = Position.Node);\n+      pragma Assert (Position.Node.Next = null\n+                       or else Position.Node.Next.Prev = Position.Node);\n+      pragma Assert (Position.Node.Prev /= null\n+                       or else Position.Node = Position.Container.First);\n+      pragma Assert (Position.Node.Next /= null\n+                       or else Position.Node = Position.Container.Last);\n+\n+      return True;\n    end Has_Element;\n \n    ------------\n@@ -507,17 +723,39 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       New_Node : Node_Access;\n \n    begin\n-      if Before.Container /= null\n-        and then Before.Container /= List_Access'(Container'Unchecked_Access)\n-      then\n-         raise Program_Error;\n+      if Before.Node /= null then\n+         if Before.Container /= List_Access'(Container'Unchecked_Access) then\n+            raise Program_Error;\n+         end if;\n+\n+         pragma Assert (Container.Length > 0);\n+         pragma Assert (Container.First.Prev = null);\n+         pragma Assert (Container.Last.Next = null);\n+\n+         pragma Assert (Before.Node.Element /= null);\n+         pragma Assert (Before.Node.Prev = null\n+                          or else Before.Node.Prev.Next = Before.Node);\n+         pragma Assert (Before.Node.Next = null\n+                          or else Before.Node.Next.Prev = Before.Node);\n+         pragma Assert (Before.Node.Prev /= null\n+                          or else Before.Node = Container.First);\n+         pragma Assert (Before.Node.Next /= null\n+                          or else Before.Node = Container.Last);\n       end if;\n \n       if Count = 0 then\n          Position := Before;\n          return;\n       end if;\n \n+      if Container.Length > Count_Type'Last - Count then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n+\n       declare\n          Element : Element_Access := new Element_Type'(New_Item);\n       begin\n@@ -529,7 +767,7 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       end;\n \n       Insert_Internal (Container, Before.Node, New_Node);\n-      Position := Cursor'(Before.Container, New_Node);\n+      Position := Cursor'(Container'Unchecked_Access, New_Node);\n \n       for J in Count_Type'(2) .. Count loop\n \n@@ -623,12 +861,26 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n      (Container : List;\n       Process   : not null access procedure (Position : in Cursor))\n    is\n+      C : List renames Container'Unrestricted_Access.all;\n+      B : Natural renames C.Busy;\n+\n       Node : Node_Access := Container.First;\n+\n    begin\n-      while Node /= null loop\n-         Process (Cursor'(Container'Unchecked_Access, Node));\n-         Node := Node.Next;\n-      end loop;\n+      B := B + 1;\n+\n+      begin\n+         while Node /= null loop\n+            Process (Cursor'(Container'Unchecked_Access, Node));\n+            Node := Node.Next;\n+         end loop;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n    end Iterate;\n \n    ----------\n@@ -641,10 +893,12 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      if Target.Length > 0 then\n-         raise Constraint_Error;\n+      if Source.Busy > 0 then\n+         raise Program_Error;\n       end if;\n \n+      Clear (Target);\n+\n       Target.First := Source.First;\n       Source.First := null;\n \n@@ -693,9 +947,25 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    procedure Next (Position : in out Cursor) is\n    begin\n       if Position.Node = null then\n+         pragma Assert (Position.Container = null);\n          return;\n       end if;\n \n+      pragma Assert (Position.Container /= null);\n+      pragma Assert (Position.Container.Length > 0);\n+      pragma Assert (Position.Container.First.Prev = null);\n+      pragma Assert (Position.Container.Last.Next = null);\n+\n+      pragma Assert (Position.Node.Element /= null);\n+      pragma Assert (Position.Node.Prev = null\n+                       or else Position.Node.Prev.Next = Position.Node);\n+      pragma Assert (Position.Node.Next = null\n+                       or else Position.Node.Next.Prev = Position.Node);\n+      pragma Assert (Position.Node.Prev /= null\n+                       or else Position.Node = Position.Container.First);\n+      pragma Assert (Position.Node.Next /= null\n+                       or else Position.Node = Position.Container.Last);\n+\n       Position.Node := Position.Node.Next;\n \n       if Position.Node = null then\n@@ -706,9 +976,25 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    function Next (Position : Cursor) return Cursor is\n    begin\n       if Position.Node = null then\n+         pragma Assert (Position.Container = null);\n          return No_Element;\n       end if;\n \n+      pragma Assert (Position.Container /= null);\n+      pragma Assert (Position.Container.Length > 0);\n+      pragma Assert (Position.Container.First.Prev = null);\n+      pragma Assert (Position.Container.Last.Next = null);\n+\n+      pragma Assert (Position.Node.Element /= null);\n+      pragma Assert (Position.Node.Prev = null\n+                       or else Position.Node.Prev.Next = Position.Node);\n+      pragma Assert (Position.Node.Next = null\n+                       or else Position.Node.Next.Prev = Position.Node);\n+      pragma Assert (Position.Node.Prev /= null\n+                       or else Position.Node = Position.Container.First);\n+      pragma Assert (Position.Node.Next /= null\n+                       or else Position.Node = Position.Container.Last);\n+\n       declare\n          Next_Node : constant Node_Access := Position.Node.Next;\n       begin\n@@ -740,9 +1026,25 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    procedure Previous (Position : in out Cursor) is\n    begin\n       if Position.Node = null then\n+         pragma Assert (Position.Container = null);\n          return;\n       end if;\n \n+      pragma Assert (Position.Container /= null);\n+      pragma Assert (Position.Container.Length > 0);\n+      pragma Assert (Position.Container.First.Prev = null);\n+      pragma Assert (Position.Container.Last.Next = null);\n+\n+      pragma Assert (Position.Node.Element /= null);\n+      pragma Assert (Position.Node.Prev = null\n+                       or else Position.Node.Prev.Next = Position.Node);\n+      pragma Assert (Position.Node.Next = null\n+                       or else Position.Node.Next.Prev = Position.Node);\n+      pragma Assert (Position.Node.Prev /= null\n+                       or else Position.Node = Position.Container.First);\n+      pragma Assert (Position.Node.Next /= null\n+                       or else Position.Node = Position.Container.Last);\n+\n       Position.Node := Position.Node.Prev;\n \n       if Position.Node = null then\n@@ -753,9 +1055,25 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    function Previous (Position : Cursor) return Cursor is\n    begin\n       if Position.Node = null then\n+         pragma Assert (Position.Container = null);\n          return No_Element;\n       end if;\n \n+      pragma Assert (Position.Container /= null);\n+      pragma Assert (Position.Container.Length > 0);\n+      pragma Assert (Position.Container.First.Prev = null);\n+      pragma Assert (Position.Container.Last.Next = null);\n+\n+      pragma Assert (Position.Node.Element /= null);\n+      pragma Assert (Position.Node.Prev = null\n+                       or else Position.Node.Prev.Next = Position.Node);\n+      pragma Assert (Position.Node.Next = null\n+                       or else Position.Node.Next.Prev = Position.Node);\n+      pragma Assert (Position.Node.Prev /= null\n+                       or else Position.Node = Position.Container.First);\n+      pragma Assert (Position.Node.Next /= null\n+                       or else Position.Node = Position.Container.Last);\n+\n       declare\n          Prev_Node : constant Node_Access := Position.Node.Prev;\n       begin\n@@ -775,8 +1093,43 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n      (Position : Cursor;\n       Process  : not null access procedure (Element : in Element_Type))\n    is\n+      pragma Assert (Position.Container /= null);\n+      pragma Assert (Position.Container.Length > 0);\n+      pragma Assert (Position.Container.First.Prev = null);\n+      pragma Assert (Position.Container.Last.Next = null);\n+\n+      pragma Assert (Position.Node /= null);\n+      pragma Assert (Position.Node.Element /= null);\n+      pragma Assert (Position.Node.Prev = null\n+                       or else Position.Node.Prev.Next = Position.Node);\n+      pragma Assert (Position.Node.Next = null\n+                       or else Position.Node.Next.Prev = Position.Node);\n+      pragma Assert (Position.Node.Prev /= null\n+                       or else Position.Node = Position.Container.First);\n+      pragma Assert (Position.Node.Next /= null\n+                       or else Position.Node = Position.Container.Last);\n+\n+      E : Element_Type renames Position.Node.Element.all;\n+\n+      C : List renames Position.Container.all'Unrestricted_Access.all;\n+      B : Natural renames C.Busy;\n+      L : Natural renames C.Lock;\n+\n    begin\n-      Process (Position.Node.Element.all);\n+      B := B + 1;\n+      L := L + 1;\n+\n+      begin\n+         Process (E);\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      L := L - 1;\n+      B := B - 1;\n    end Query_Element;\n \n    ----------\n@@ -787,48 +1140,48 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n      (Stream : access Root_Stream_Type'Class;\n       Item   : out List)\n    is\n-      N : Count_Type'Base;\n-      X : Node_Access;\n+      N   : Count_Type'Base;\n+      Dst : Node_Access;\n \n    begin\n-      Clear (Item);  --  ???\n+      Clear (Item);\n \n       Count_Type'Base'Read (Stream, N);\n \n       if N = 0 then\n          return;\n       end if;\n \n-      X := new Node_Type;\n-\n+      declare\n+         Element : Element_Access :=\n+                     new Element_Type'(Element_Type'Input (Stream));\n       begin\n-         X.Element := new Element_Type'(Element_Type'Input (Stream));\n+         Dst := new Node_Type'(Element, null, null);\n       exception\n          when others =>\n-            Free (X);\n+            Free (Element);\n             raise;\n       end;\n \n-      Item.First := X;\n-\n-      Item.Last := X;\n-      loop\n-         Item.Length := Item.Length + 1;\n-         exit when Item.Length = N;\n-\n-         X := new Node_Type;\n+      Item.First := Dst;\n+      Item.Last := Dst;\n+      Item.Length := 1;\n \n+      while Item.Length < N loop\n+         declare\n+            Element : Element_Access :=\n+                        new Element_Type'(Element_Type'Input (Stream));\n          begin\n-            X.Element := new Element_Type'(Element_Type'Input (Stream));\n+            Dst := new Node_Type'(Element, Next => null, Prev => Item.Last);\n          exception\n             when others =>\n-               Free (X);\n+               Free (Element);\n                raise;\n          end;\n \n-         X.Prev := Item.Last;\n-         Item.Last.Next := X;\n-         Item.Last := X;\n+         Item.Last.Next := Dst;\n+         Item.Last := Dst;\n+         Item.Length := Item.Length + 1;\n       end loop;\n    end Read;\n \n@@ -840,8 +1193,29 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n      (Position : Cursor;\n       By       : Element_Type)\n    is\n+      pragma Assert (Position.Container /= null);\n+      pragma Assert (Position.Container.Length > 0);\n+      pragma Assert (Position.Container.First.Prev = null);\n+      pragma Assert (Position.Container.Last.Next = null);\n+\n+      pragma Assert (Position.Node /= null);\n+      pragma Assert (Position.Node.Element /= null);\n+      pragma Assert (Position.Node.Prev = null\n+                       or else Position.Node.Prev.Next = Position.Node);\n+      pragma Assert (Position.Node.Next = null\n+                       or else Position.Node.Next.Prev = Position.Node);\n+      pragma Assert (Position.Node.Prev /= null\n+                       or else Position.Node = Position.Container.First);\n+      pragma Assert (Position.Node.Next /= null\n+                       or else Position.Node = Position.Container.Last);\n+\n       X : Element_Access := Position.Node.Element;\n+\n    begin\n+      if Position.Container.Lock > 0 then\n+         raise Program_Error;\n+      end if;\n+\n       Position.Node.Element := new Element_Type'(By);\n       Free (X);\n    end Replace_Element;\n@@ -860,14 +1234,29 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    begin\n       if Node = null then\n          Node := Container.Last;\n-      elsif Position.Container /= List_Access'(Container'Unchecked_Access) then\n-         raise Program_Error;\n+\n+      else\n+         if Position.Container /= List_Access'(Container'Unchecked_Access) then\n+            raise Program_Error;\n+         end if;\n+\n+         pragma Assert (Container.Length > 0);\n+         pragma Assert (Container.First.Prev = null);\n+         pragma Assert (Container.Last.Next = null);\n+\n+         pragma Assert (Position.Node.Element /= null);\n+         pragma Assert (Position.Node.Prev = null\n+                          or else Position.Node.Prev.Next = Position.Node);\n+         pragma Assert (Position.Node.Next = null\n+                          or else Position.Node.Next.Prev = Position.Node);\n+         pragma Assert (Position.Node.Prev /= null\n+                          or else Position.Node = Container.First);\n+         pragma Assert (Position.Node.Next /= null\n+                          or else Position.Node = Container.Last);\n       end if;\n \n       while Node /= null loop\n-         if Node.Element /= null\n-           and then Node.Element.all = Item\n-         then\n+         if Node.Element.all = Item then\n             return Cursor'(Container'Unchecked_Access, Node);\n          end if;\n \n@@ -885,13 +1274,26 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n      (Container : List;\n       Process   : not null access procedure (Position : in Cursor))\n    is\n+      C : List renames Container'Unrestricted_Access.all;\n+      B : Natural renames C.Busy;\n+\n       Node : Node_Access := Container.Last;\n \n    begin\n-      while Node /= null loop\n-         Process (Cursor'(Container'Unchecked_Access, Node));\n-         Node := Node.Prev;\n-      end loop;\n+      B := B + 1;\n+\n+      begin\n+         while Node /= null loop\n+            Process (Cursor'(Container'Unchecked_Access, Node));\n+            Node := Node.Prev;\n+         end loop;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n    end Reverse_Iterate;\n \n    ------------------\n@@ -949,6 +1351,13 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          return;\n       end if;\n \n+      pragma Assert (Container.First.Prev = null);\n+      pragma Assert (Container.Last.Next = null);\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n+\n       Container.First := J;\n       Container.Last := I;\n       loop\n@@ -983,10 +1392,24 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       Source : in out List)\n    is\n    begin\n-      if Before.Container /= null\n-        and then Before.Container /= List_Access'(Target'Unchecked_Access)\n-      then\n-         raise Program_Error;\n+      if Before.Node /= null then\n+         if Before.Container /= List_Access'(Target'Unchecked_Access) then\n+            raise Program_Error;\n+         end if;\n+\n+         pragma Assert (Target.Length >= 1);\n+         pragma Assert (Target.First.Prev = null);\n+         pragma Assert (Target.Last.Next = null);\n+\n+         pragma Assert (Before.Node.Element /= null);\n+         pragma Assert (Before.Node.Prev = null\n+                          or else Before.Node.Prev.Next = Before.Node);\n+         pragma Assert (Before.Node.Next = null\n+                          or else Before.Node.Next.Prev = Before.Node);\n+         pragma Assert (Before.Node.Prev /= null\n+                          or else Before.Node = Target.First);\n+         pragma Assert (Before.Node.Next /= null\n+                          or else Before.Node = Target.Last);\n       end if;\n \n       if Target'Address = Source'Address\n@@ -995,8 +1418,23 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          return;\n       end if;\n \n+      pragma Assert (Source.First.Prev = null);\n+      pragma Assert (Source.Last.Next = null);\n+\n+      if Target.Length > Count_Type'Last - Source.Length then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Target.Busy > 0\n+        or else Source.Busy > 0\n+      then\n+         raise Program_Error;\n+      end if;\n+\n       if Target.Length = 0 then\n          pragma Assert (Before = No_Element);\n+         pragma Assert (Target.First = null);\n+         pragma Assert (Target.Last = null);\n \n          Target.First := Source.First;\n          Target.Last := Source.Last;\n@@ -1018,6 +1456,7 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          Target.First := Source.First;\n \n       else\n+         pragma Assert (Target.Length >= 2);\n          Before.Node.Prev.Next := Source.First;\n          Source.First.Prev := Before.Node.Prev;\n \n@@ -1037,191 +1476,312 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       Before   : Cursor;\n       Position : Cursor)\n    is\n-      X : Node_Access := Position.Node;\n-\n    begin\n-      if Before.Container /= null\n-        and then Before.Container /= List_Access'(Target'Unchecked_Access)\n-      then\n-         raise Program_Error;\n+      if Before.Node /= null then\n+         if Before.Container /= List_Access'(Target'Unchecked_Access) then\n+            raise Program_Error;\n+         end if;\n+\n+         pragma Assert (Target.Length >= 1);\n+         pragma Assert (Target.First.Prev = null);\n+         pragma Assert (Target.Last.Next = null);\n+\n+         pragma Assert (Before.Node.Element /= null);\n+         pragma Assert (Before.Node.Prev = null\n+                          or else Before.Node.Prev.Next = Before.Node);\n+         pragma Assert (Before.Node.Next = null\n+                          or else Before.Node.Next.Prev = Before.Node);\n+         pragma Assert (Before.Node.Prev /= null\n+                          or else Before.Node = Target.First);\n+         pragma Assert (Before.Node.Next /= null\n+                          or else Before.Node = Target.Last);\n       end if;\n \n-      if Position.Container /= null\n-        and then Position.Container /= List_Access'(Target'Unchecked_Access)\n-      then\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Position.Container /= List_Access'(Target'Unchecked_Access) then\n          raise Program_Error;\n       end if;\n \n-      if X = null\n-        or else X = Before.Node\n-        or else X.Next = Before.Node\n+      pragma Assert (Target.Length >= 1);\n+      pragma Assert (Target.First.Prev = null);\n+      pragma Assert (Target.Last.Next = null);\n+\n+      pragma Assert (Position.Node.Element /= null);\n+      pragma Assert (Position.Node.Prev = null\n+                       or else Position.Node.Prev.Next = Position.Node);\n+      pragma Assert (Position.Node.Next = null\n+                       or else Position.Node.Next.Prev = Position.Node);\n+      pragma Assert (Position.Node.Prev /= null\n+                       or else Position.Node = Target.First);\n+      pragma Assert (Position.Node.Next /= null\n+                       or else Position.Node = Target.Last);\n+\n+      if Position.Node = Before.Node\n+        or else Position.Node.Next = Before.Node\n       then\n          return;\n       end if;\n \n-      pragma Assert (Target.Length > 0);\n+      pragma Assert (Target.Length >= 2);\n+\n+      if Target.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n \n       if Before.Node = null then\n-         pragma Assert (X /= Target.Last);\n+         pragma Assert (Position.Node /= Target.Last);\n \n-         if X = Target.First then\n-            Target.First := X.Next;\n+         if Position.Node = Target.First then\n+            Target.First := Position.Node.Next;\n             Target.First.Prev := null;\n          else\n-            X.Prev.Next := X.Next;\n-            X.Next.Prev := X.Prev;\n+            Position.Node.Prev.Next := Position.Node.Next;\n+            Position.Node.Next.Prev := Position.Node.Prev;\n          end if;\n \n-         Target.Last.Next := X;\n-         X.Prev := Target.Last;\n+         Target.Last.Next := Position.Node;\n+         Position.Node.Prev := Target.Last;\n \n-         Target.Last := X;\n+         Target.Last := Position.Node;\n          Target.Last.Next := null;\n \n          return;\n       end if;\n \n       if Before.Node = Target.First then\n-         pragma Assert (X /= Target.First);\n+         pragma Assert (Position.Node /= Target.First);\n \n-         if X = Target.Last then\n-            Target.Last := X.Prev;\n+         if Position.Node = Target.Last then\n+            Target.Last := Position.Node.Prev;\n             Target.Last.Next := null;\n          else\n-            X.Prev.Next := X.Next;\n-            X.Next.Prev := X.Prev;\n+            Position.Node.Prev.Next := Position.Node.Next;\n+            Position.Node.Next.Prev := Position.Node.Prev;\n          end if;\n \n-         Target.First.Prev := X;\n-         X.Next := Target.First;\n+         Target.First.Prev := Position.Node;\n+         Position.Node.Next := Target.First;\n \n-         Target.First := X;\n+         Target.First := Position.Node;\n          Target.First.Prev := null;\n \n          return;\n       end if;\n \n-      if X = Target.First then\n-         Target.First := X.Next;\n+      if Position.Node = Target.First then\n+         Target.First := Position.Node.Next;\n          Target.First.Prev := null;\n \n-      elsif X = Target.Last then\n-         Target.Last := X.Prev;\n+      elsif Position.Node = Target.Last then\n+         Target.Last := Position.Node.Prev;\n          Target.Last.Next := null;\n \n       else\n-         X.Prev.Next := X.Next;\n-         X.Next.Prev := X.Prev;\n+         Position.Node.Prev.Next := Position.Node.Next;\n+         Position.Node.Next.Prev := Position.Node.Prev;\n       end if;\n \n-      Before.Node.Prev.Next := X;\n-      X.Prev := Before.Node.Prev;\n+      Before.Node.Prev.Next := Position.Node;\n+      Position.Node.Prev := Before.Node.Prev;\n+\n+      Before.Node.Prev := Position.Node;\n+      Position.Node.Next := Before.Node;\n \n-      Before.Node.Prev := X;\n-      X.Next := Before.Node;\n+      pragma Assert (Target.First.Prev = null);\n+      pragma Assert (Target.Last.Next = null);\n    end Splice;\n \n    procedure Splice\n      (Target   : in out List;\n       Before   : Cursor;\n       Source   : in out List;\n-      Position : Cursor)\n+      Position : in out Cursor)\n    is\n-      X : Node_Access := Position.Node;\n-\n    begin\n       if Target'Address = Source'Address then\n          Splice (Target, Before, Position);\n          return;\n       end if;\n \n-      if Before.Container /= null\n-        and then Before.Container /= List_Access'(Target'Unchecked_Access)\n-      then\n-         raise Program_Error;\n+      if Before.Node /= null then\n+         if Before.Container /= List_Access'(Target'Unchecked_Access) then\n+            raise Program_Error;\n+         end if;\n+\n+         pragma Assert (Target.Length >= 1);\n+         pragma Assert (Target.First.Prev = null);\n+         pragma Assert (Target.Last.Next = null);\n+\n+         pragma Assert (Before.Node.Element /= null);\n+         pragma Assert (Before.Node.Prev = null\n+                          or else Before.Node.Prev.Next = Before.Node);\n+         pragma Assert (Before.Node.Next = null\n+                          or else Before.Node.Next.Prev = Before.Node);\n+         pragma Assert (Before.Node.Prev /= null\n+                          or else Before.Node = Target.First);\n+         pragma Assert (Before.Node.Next /= null\n+                          or else Before.Node = Target.Last);\n       end if;\n \n-      if Position.Container /= null\n-        and then Position.Container /= List_Access'(Source'Unchecked_Access)\n-      then\n-         raise Program_Error;\n+      if Position.Node = null then\n+         raise Constraint_Error;\n       end if;\n \n-      if X = null then\n-         return;\n+      if Position.Container /= List_Access'(Source'Unchecked_Access) then\n+         raise Program_Error;\n       end if;\n \n-      pragma Assert (Source.Length > 0);\n+      pragma Assert (Source.Length >= 1);\n       pragma Assert (Source.First.Prev = null);\n       pragma Assert (Source.Last.Next = null);\n \n-      if X = Source.First then\n-         Source.First := X.Next;\n+      pragma Assert (Position.Node.Element /= null);\n+      pragma Assert (Position.Node.Prev = null\n+                       or else Position.Node.Prev.Next = Position.Node);\n+      pragma Assert (Position.Node.Next = null\n+                       or else Position.Node.Next.Prev = Position.Node);\n+      pragma Assert (Position.Node.Prev /= null\n+                       or else Position.Node = Source.First);\n+      pragma Assert (Position.Node.Next /= null\n+                       or else Position.Node = Source.Last);\n+\n+      if Target.Length = Count_Type'Last then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Target.Busy > 0\n+        or else Source.Busy > 0\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      if Position.Node = Source.First then\n+         Source.First := Position.Node.Next;\n          Source.First.Prev := null;\n \n-         if X = Source.Last then\n+         if Position.Node = Source.Last then\n             pragma Assert (Source.First = null);\n             pragma Assert (Source.Length = 1);\n             Source.Last := null;\n          end if;\n \n-      elsif X = Source.Last then\n-         Source.Last := X.Prev;\n+      elsif Position.Node = Source.Last then\n+         pragma Assert (Source.Length >= 2);\n+         Source.Last := Position.Node.Prev;\n          Source.Last.Next := null;\n \n       else\n-         X.Prev.Next := X.Next;\n-         X.Next.Prev := X.Prev;\n+         pragma Assert (Source.Length >= 3);\n+         Position.Node.Prev.Next := Position.Node.Next;\n+         Position.Node.Next.Prev := Position.Node.Prev;\n       end if;\n \n       if Target.Length = 0 then\n          pragma Assert (Before = No_Element);\n          pragma Assert (Target.First = null);\n          pragma Assert (Target.Last = null);\n \n-         Target.First := X;\n-         Target.Last := X;\n+         Target.First := Position.Node;\n+         Target.Last := Position.Node;\n+\n+         Target.First.Prev := null;\n+         Target.Last.Next := null;\n \n       elsif Before.Node = null then\n-         Target.Last.Next := X;\n-         X.Next := Target.Last;\n+         pragma Assert (Target.Last.Next = null);\n+         Target.Last.Next := Position.Node;\n+         Position.Node.Prev := Target.Last;\n \n-         Target.Last := X;\n+         Target.Last := Position.Node;\n          Target.Last.Next := null;\n \n       elsif Before.Node = Target.First then\n-         Target.First.Prev := X;\n-         X.Next := Target.First;\n+         pragma Assert (Target.First.Prev = null);\n+         Target.First.Prev := Position.Node;\n+         Position.Node.Next := Target.First;\n \n-         Target.First := X;\n+         Target.First := Position.Node;\n          Target.First.Prev := null;\n \n       else\n-         Before.Node.Prev.Next := X;\n-         X.Prev := Before.Node.Prev;\n+         pragma Assert (Target.Length >= 2);\n+         Before.Node.Prev.Next := Position.Node;\n+         Position.Node.Prev := Before.Node.Prev;\n \n-         Before.Node.Prev := X;\n-         X.Next := Before.Node;\n+         Before.Node.Prev := Position.Node;\n+         Position.Node.Next := Before.Node;\n       end if;\n \n       Target.Length := Target.Length + 1;\n       Source.Length := Source.Length - 1;\n+\n+      Position.Container := Target'Unchecked_Access;\n    end Splice;\n \n    ----------\n    -- Swap --\n    ----------\n \n    procedure Swap (I, J : Cursor) is\n+   begin\n+      if I.Container = null\n+        or else J.Container = null\n+      then\n+         raise Constraint_Error;\n+      end if;\n \n-      --  Is this op legal when I and J designate elements in different\n-      --  containers, or should it raise an exception (e.g. Program_Error).\n+      if I.Container /= J.Container then\n+         raise Program_Error;\n+      end if;\n \n-      EI : constant Element_Access := I.Node.Element;\n+      declare\n+         C : List renames I.Container.all;\n+      begin\n+         pragma Assert (C.Length > 0);\n+         pragma Assert (C.First.Prev = null);\n+         pragma Assert (C.Last.Next = null);\n+\n+         pragma Assert (I.Node /= null);\n+         pragma Assert (I.Node.Element /= null);\n+         pragma Assert (I.Node.Prev = null\n+                          or else I.Node.Prev.Next = I.Node);\n+         pragma Assert (I.Node.Next = null\n+                          or else I.Node.Next.Prev = I.Node);\n+         pragma Assert (I.Node.Prev /= null\n+                          or else I.Node = C.First);\n+         pragma Assert (I.Node.Next /= null\n+                          or else I.Node = C.Last);\n+\n+         if I.Node = J.Node then\n+            return;\n+         end if;\n \n-   begin\n-      I.Node.Element := J.Node.Element;\n-      J.Node.Element := EI;\n+         pragma Assert (C.Length > 1);\n+         pragma Assert (J.Node /= null);\n+         pragma Assert (J.Node.Element /= null);\n+         pragma Assert (J.Node.Prev = null\n+                          or else J.Node.Prev.Next = J.Node);\n+         pragma Assert (J.Node.Next = null\n+                          or else J.Node.Next.Prev = J.Node);\n+         pragma Assert (J.Node.Prev /= null\n+                          or else J.Node = C.First);\n+         pragma Assert (J.Node.Next /= null\n+                          or else J.Node = C.Last);\n+\n+         if C.Lock > 0 then\n+            raise Program_Error;\n+         end if;\n+\n+         declare\n+            EI_Copy : constant Element_Access := I.Node.Element;\n+         begin\n+            I.Node.Element := J.Node.Element;\n+            J.Node.Element := EI_Copy;\n+         end;\n+      end;\n    end Swap;\n \n    ----------------\n@@ -1233,8 +1793,8 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       I, J      : Cursor)\n    is\n    begin\n-      if I = No_Element\n-        or else J = No_Element\n+      if I.Container = null\n+        or else J.Container = null\n       then\n          raise Constraint_Error;\n       end if;\n@@ -1248,12 +1808,39 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       end if;\n \n       pragma Assert (Container.Length >= 1);\n+      pragma Assert (Container.First.Prev = null);\n+      pragma Assert (Container.Last.Next = null);\n+\n+      pragma Assert (I.Node /= null);\n+      pragma Assert (I.Node.Element /= null);\n+      pragma Assert (I.Node.Prev = null\n+                       or else I.Node.Prev.Next = I.Node);\n+      pragma Assert (I.Node.Next = null\n+                       or else I.Node.Next.Prev = I.Node);\n+      pragma Assert (I.Node.Prev /= null\n+                       or else I.Node = Container.First);\n+      pragma Assert (I.Node.Next /= null\n+                       or else I.Node = Container.Last);\n \n       if I.Node = J.Node then\n          return;\n       end if;\n \n       pragma Assert (Container.Length >= 2);\n+      pragma Assert (J.Node /= null);\n+      pragma Assert (J.Node.Element /= null);\n+      pragma Assert (J.Node.Prev = null\n+                       or else J.Node.Prev.Next = J.Node);\n+      pragma Assert (J.Node.Next = null\n+                       or else J.Node.Next.Prev = J.Node);\n+      pragma Assert (J.Node.Prev /= null\n+                       or else J.Node = Container.First);\n+      pragma Assert (J.Node.Next /= null\n+                       or else J.Node = Container.Last);\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n \n       declare\n          I_Next : constant Cursor := Next (I);\n@@ -1278,6 +1865,9 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n             end;\n          end if;\n       end;\n+\n+      pragma Assert (Container.First.Prev = null);\n+      pragma Assert (Container.Last.Next = null);\n    end Swap_Links;\n \n    --------------------\n@@ -1288,8 +1878,43 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n      (Position : Cursor;\n       Process  : not null access procedure (Element : in out Element_Type))\n    is\n+      pragma Assert (Position.Container /= null);\n+      pragma Assert (Position.Container.Length > 0);\n+      pragma Assert (Position.Container.First.Prev = null);\n+      pragma Assert (Position.Container.Last.Next = null);\n+\n+      pragma Assert (Position.Node /= null);\n+      pragma Assert (Position.Node.Element /= null);\n+      pragma Assert (Position.Node.Prev = null\n+                       or else Position.Node.Prev.Next = Position.Node);\n+      pragma Assert (Position.Node.Next = null\n+                       or else Position.Node.Next.Prev = Position.Node);\n+      pragma Assert (Position.Node.Prev /= null\n+                       or else Position.Node = Position.Container.First);\n+      pragma Assert (Position.Node.Next /= null\n+                       or else Position.Node = Position.Container.Last);\n+\n+      E : Element_Type renames Position.Node.Element.all;\n+\n+      C : List renames Position.Container.all'Unrestricted_Access.all;\n+      B : Natural renames C.Busy;\n+      L : Natural renames C.Lock;\n+\n    begin\n-      Process (Position.Node.Element.all);\n+      B := B + 1;\n+      L := L + 1;\n+\n+      begin\n+         Process (E);\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      L := L - 1;\n+      B := B - 1;\n    end Update_Element;\n \n    -----------\n@@ -1310,5 +1935,3 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    end Write;\n \n end Ada.Containers.Indefinite_Doubly_Linked_Lists;\n-\n-"}, {"sha": "07341a835564d920bdbbc4345b17fae012f6065e", "filename": "gcc/ada/a-cidlli.ads", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-cidlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-cidlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cidlli.ads?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "patch": "@@ -2,11 +2,12 @@\n --                                                                          --\n --                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---              ADA.CONTAINERS.INDEFINITE_DOUBLY_LINKED_LISTS               --\n+--                      A D A . C O N T A I N E R S .                       --\n+--        I N D E F I N I T E _ D O U B L Y _ L I N K E D _ L I S T S       --\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -118,16 +119,16 @@ package Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       Count     : Count_Type := 1);\n \n    generic\n-      with function \"<\" (Left, Right : Element_Type)\n-         return Boolean is <>;\n-   procedure Generic_Sort (Container : in out List);\n+      with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n+   package Generic_Sorting is\n \n-   generic\n-      with function \"<\" (Left, Right : Element_Type)\n-         return Boolean is <>;\n-   procedure Generic_Merge\n-     (Target : in out List;\n-      Source : in out List);\n+      function Is_Sorted (Container : List) return Boolean;\n+\n+      procedure Sort (Container : in out List);\n+\n+      procedure Merge (Target, Source : in out List);\n+\n+   end Generic_Sorting;\n \n    procedure Reverse_List (Container : in out List);\n \n@@ -149,7 +150,7 @@ package Ada.Containers.Indefinite_Doubly_Linked_Lists is\n      (Target   : in out List;\n       Before   : Cursor;\n       Source   : in out List;\n-      Position : Cursor);\n+      Position : in out Cursor);\n \n    function First (Container : List) return Cursor;\n \n@@ -198,21 +199,21 @@ private\n    type Element_Access is access Element_Type;\n \n    type Node_Type is\n-      record\n+      limited record\n          Element : Element_Access;\n          Next    : Node_Access;\n          Prev    : Node_Access;\n       end record;\n \n-   function \"=\" (L, R : Node_Type) return Boolean is abstract;\n-\n    use Ada.Finalization;\n \n    type List is\n      new Controlled with record\n         First  : Node_Access;\n         Last   : Node_Access;\n         Length : Count_Type := 0;\n+        Busy   : Natural := 0;\n+        Lock   : Natural := 0;\n      end record;\n \n    procedure Adjust (Container : in out List);\n@@ -233,7 +234,7 @@ private\n \n    for List'Write use Write;\n \n-   Empty_List : constant List := List'(Controlled with null, null, 0);\n+   Empty_List : constant List := List'(Controlled with null, null, 0, 0, 0);\n \n    type List_Access is access constant List;\n    for List_Access'Storage_Size use 0;\n@@ -247,5 +248,3 @@ private\n    No_Element : constant Cursor := Cursor'(null, null);\n \n end Ada.Containers.Indefinite_Doubly_Linked_Lists;\n-\n-"}, {"sha": "8467800584e65f098f0a3bdb8e6f1c5f8a2d6d63", "filename": "gcc/ada/a-cihama.adb", "status": "modified", "additions": 279, "deletions": 65, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-cihama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-cihama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihama.adb?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "patch": "@@ -2,11 +2,12 @@\n --                                                                          --\n --                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---                  ADA.CONTAINERS.INDEFINITE_HASHED_MAPS                   --\n+--                      A D A . C O N T A I N E R S .                       --\n+--               I N D E F I N I T E _ H A S H E D _ M A P S                --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -43,15 +44,6 @@ with Ada.Unchecked_Deallocation;\n \n package body Ada.Containers.Indefinite_Hashed_Maps is\n \n-   type Key_Access is access Key_Type;\n-   type Element_Access is access Element_Type;\n-\n-   type Node_Type is limited record\n-      Key     : Key_Access;\n-      Element : Element_Access;\n-      Next    : Node_Access;\n-   end record;\n-\n    procedure Free_Key is\n       new Ada.Unchecked_Deallocation (Key_Type, Key_Access);\n \n@@ -65,17 +57,17 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n    function Copy_Node (Node : Node_Access) return Node_Access;\n    pragma Inline (Copy_Node);\n \n-   function Equivalent_Keys\n+   function Equivalent_Key_Node\n      (Key  : Key_Type;\n       Node : Node_Access) return Boolean;\n-   pragma Inline (Equivalent_Keys);\n+   pragma Inline (Equivalent_Key_Node);\n \n    function Find_Equal_Key\n-     (R_Map  : Map;\n+     (R_HT   : Hash_Table_Type;\n       L_Node : Node_Access) return Boolean;\n \n    procedure Free (X : in out Node_Access);\n-   pragma Inline (Free);\n+   --  pragma Inline (Free);\n \n    function Hash_Node (Node : Node_Access) return Hash_Type;\n    pragma Inline (Hash_Node);\n@@ -89,6 +81,8 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n    procedure Set_Next (Node : Node_Access; Next : Node_Access);\n    pragma Inline (Set_Next);\n \n+   function Vet (Position : Cursor) return Boolean;\n+\n    procedure Write_Node\n      (Stream : access Root_Stream_Type'Class;\n       Node   : Node_Access);\n@@ -100,8 +94,6 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n    package HT_Ops is\n       new Ada.Containers.Hash_Tables.Generic_Operations\n         (HT_Types          => HT_Types,\n-         Hash_Table_Type   => Map,\n-         Null_Node         => null,\n          Hash_Node         => Hash_Node,\n          Next              => Next,\n          Set_Next          => Set_Next,\n@@ -111,40 +103,49 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n    package Key_Ops is\n       new Hash_Tables.Generic_Keys\n        (HT_Types  => HT_Types,\n-        HT_Type   => Map,\n-        Null_Node => null,\n         Next      => Next,\n         Set_Next  => Set_Next,\n         Key_Type  => Key_Type,\n         Hash      => Hash,\n-        Equivalent_Keys => Equivalent_Keys);\n+        Equivalent_Keys => Equivalent_Key_Node);\n \n    ---------\n    -- \"=\" --\n    ---------\n \n    function Is_Equal is new HT_Ops.Generic_Equal (Find_Equal_Key);\n \n-   function \"=\" (Left, Right : Map) return Boolean renames Is_Equal;\n+   function \"=\" (Left, Right : Map) return Boolean is\n+   begin\n+      return Is_Equal (Left.HT, Right.HT);\n+   end \"=\";\n \n    ------------\n    -- Adjust --\n    ------------\n \n-   procedure Adjust (Container : in out Map) renames HT_Ops.Adjust;\n+   procedure Adjust (Container : in out Map) is\n+   begin\n+      HT_Ops.Adjust (Container.HT);\n+   end Adjust;\n \n    --------------\n    -- Capacity --\n    --------------\n \n-   function Capacity (Container : Map)\n-     return Count_Type renames HT_Ops.Capacity;\n+   function Capacity (Container : Map) return Count_Type is\n+   begin\n+      return HT_Ops.Capacity (Container.HT);\n+   end Capacity;\n \n    -----------\n    -- Clear --\n    -----------\n \n-   procedure Clear (Container : in out Map) renames HT_Ops.Clear;\n+   procedure Clear (Container : in out Map) is\n+   begin\n+      HT_Ops.Clear (Container.HT);\n+   end Clear;\n \n    --------------\n    -- Contains --\n@@ -182,7 +183,7 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       X : Node_Access;\n \n    begin\n-      Key_Ops.Delete_Key_Sans_Free (Container, Key, X);\n+      Key_Ops.Delete_Key_Sans_Free (Container.HT, Key, X);\n \n       if X = null then\n          raise Constraint_Error;\n@@ -193,17 +194,26 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n    procedure Delete (Container : in out Map; Position : in out Cursor) is\n    begin\n-      if Position = No_Element then\n+      if Position.Node = null then\n+         raise Constraint_Error;\n          return;\n       end if;\n \n       if Position.Container /= Map_Access'(Container'Unchecked_Access) then\n          raise Program_Error;\n       end if;\n \n-      HT_Ops.Delete_Node_Sans_Free (Container, Position.Node);\n-      Free (Position.Node);\n+      pragma Assert (Position.Node.Next /= Position.Node);\n+      pragma Assert (Position.Node.Key /= null);\n+      pragma Assert (Position.Node.Element /= null);\n+\n+      if Container.HT.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n+\n+      HT_Ops.Delete_Node_Sans_Free (Container.HT, Position.Node);\n \n+      Free (Position.Node);\n       Position.Container := null;\n    end Delete;\n \n@@ -219,23 +229,30 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n+      pragma Assert (Vet (Position));\n       return Position.Node.Element.all;\n    end Element;\n \n-   ---------------------\n-   -- Equivalent_Keys --\n-   ---------------------\n+   -------------------------\n+   -- Equivalent_Key_Node --\n+   -------------------------\n \n-   function Equivalent_Keys\n+   function Equivalent_Key_Node\n      (Key  : Key_Type;\n       Node : Node_Access) return Boolean\n    is\n    begin\n       return Equivalent_Keys (Key, Node.Key.all);\n-   end Equivalent_Keys;\n+   end Equivalent_Key_Node;\n+\n+   ---------------------\n+   -- Equivalent_Keys --\n+   ---------------------\n \n    function Equivalent_Keys (Left, Right : Cursor) return Boolean is\n    begin\n+      pragma Assert (Vet (Left));\n+      pragma Assert (Vet (Right));\n       return Equivalent_Keys (Left.Node.Key.all, Right.Node.Key.all);\n    end Equivalent_Keys;\n \n@@ -244,6 +261,7 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       Right : Key_Type) return Boolean\n    is\n    begin\n+      pragma Assert (Vet (Left));\n       return Equivalent_Keys (Left.Node.Key.all, Right);\n    end Equivalent_Keys;\n \n@@ -252,6 +270,7 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       Right : Cursor) return Boolean\n    is\n    begin\n+      pragma Assert (Vet (Right));\n       return Equivalent_Keys (Left, Right.Node.Key.all);\n    end Equivalent_Keys;\n \n@@ -262,22 +281,25 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n    procedure Exclude (Container : in out Map; Key : Key_Type) is\n       X : Node_Access;\n    begin\n-      Key_Ops.Delete_Key_Sans_Free (Container, Key, X);\n+      Key_Ops.Delete_Key_Sans_Free (Container.HT, Key, X);\n       Free (X);\n    end Exclude;\n \n    --------------\n    -- Finalize --\n    --------------\n \n-   procedure Finalize (Container : in out Map) renames HT_Ops.Finalize;\n+   procedure Finalize (Container : in out Map) is\n+   begin\n+      HT_Ops.Finalize (Container.HT);\n+   end Finalize;\n \n    ----------\n    -- Find --\n    ----------\n \n    function Find (Container : Map; Key : Key_Type) return Cursor is\n-      Node : constant Node_Access := Key_Ops.Find (Container, Key);\n+      Node : constant Node_Access := Key_Ops.Find (Container.HT, Key);\n \n    begin\n       if Node = null then\n@@ -292,11 +314,11 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n    --------------------\n \n    function Find_Equal_Key\n-     (R_Map  : Map;\n+     (R_HT   : Hash_Table_Type;\n       L_Node : Node_Access) return Boolean\n    is\n-      R_Index : constant Hash_Type := Key_Ops.Index (R_Map, L_Node.Key.all);\n-      R_Node  : Node_Access := R_Map.Buckets (R_Index);\n+      R_Index : constant Hash_Type := Key_Ops.Index (R_HT, L_Node.Key.all);\n+      R_Node  : Node_Access := R_HT.Buckets (R_Index);\n \n    begin\n       while R_Node /= null loop\n@@ -315,7 +337,7 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n    -----------\n \n    function First (Container : Map) return Cursor is\n-      Node : constant Node_Access := HT_Ops.First (Container);\n+      Node : constant Node_Access := HT_Ops.First (Container.HT);\n    begin\n       if Node = null then\n          return No_Element;\n@@ -332,11 +354,40 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       procedure Deallocate is\n          new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n    begin\n-      if X /= null then\n+      if X = null then\n+         return;\n+      end if;\n+\n+      X.Next := X;  --  detect mischief (in Vet)\n+\n+      begin\n          Free_Key (X.Key);\n+      exception\n+         when others =>\n+            X.Key := null;\n+\n+            begin\n+               Free_Element (X.Element);\n+            exception\n+               when others =>\n+                  X.Element := null;\n+            end;\n+\n+            Deallocate (X);\n+            raise;\n+      end;\n+\n+      begin\n          Free_Element (X.Element);\n-         Deallocate (X);\n-      end if;\n+      exception\n+         when others =>\n+            X.Element := null;\n+\n+            Deallocate (X);\n+            raise;\n+      end;\n+\n+      Deallocate (X);\n    end Free;\n \n    -----------------\n@@ -345,7 +396,13 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n    function Has_Element (Position : Cursor) return Boolean is\n    begin\n-      return Position /= No_Element;\n+      if Position.Node = null then\n+         pragma Assert (Position.Container = null);\n+         return False;\n+      end if;\n+\n+      pragma Assert (Vet (Position));\n+      return True;\n    end Has_Element;\n \n    ---------------\n@@ -376,11 +433,22 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       Insert (Container, Key, New_Item, Position, Inserted);\n \n       if not Inserted then\n+         if Container.HT.Lock > 0 then\n+            raise Program_Error;\n+         end if;\n+\n          K := Position.Node.Key;\n          E := Position.Node.Element;\n \n          Position.Node.Key := new Key_Type'(Key);\n-         Position.Node.Element := new Element_Type'(New_Item);\n+\n+         begin\n+            Position.Node.Element := new Element_Type'(New_Item);\n+         exception\n+            when others =>\n+               Free_Key (K);\n+               raise;\n+         end;\n \n          Free_Key (K);\n          Free_Element (E);\n@@ -420,11 +488,17 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n             raise;\n       end New_Node;\n \n+      HT : Hash_Table_Type renames Container.HT;\n+\n    --  Start of processing for Insert\n \n    begin\n-      HT_Ops.Ensure_Capacity (Container, Container.Length + 1);\n-      Insert (Container, Key, Position.Node, Inserted);\n+      if HT.Length >= HT_Ops.Capacity (HT) then\n+         --  TODO: see note in a-cohama.adb.\n+         HT_Ops.Reserve_Capacity (HT, HT.Length + 1);\n+      end if;\n+\n+      Insert (HT, Key, Position.Node, Inserted);\n       Position.Container := Container'Unchecked_Access;\n    end Insert;\n \n@@ -450,7 +524,7 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n    function Is_Empty (Container : Map) return Boolean is\n    begin\n-      return Container.Length = 0;\n+      return Container.HT.Length = 0;\n    end Is_Empty;\n \n    -------------\n@@ -479,7 +553,7 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n    --  Start of processing Iterate\n \n    begin\n-      Iterate (Container);\n+      Iterate (Container.HT);\n    end Iterate;\n \n    ---------\n@@ -488,6 +562,7 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n    function Key (Position : Cursor) return Key_Type is\n    begin\n+      pragma Assert (Vet (Position));\n       return Position.Node.Key.all;\n    end Key;\n \n@@ -497,7 +572,7 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n    function Length (Container : Map) return Count_Type is\n    begin\n-      return Container.Length;\n+      return Container.HT.Length;\n    end Length;\n \n    ----------\n@@ -506,7 +581,11 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n    procedure Move\n      (Target : in out Map;\n-      Source : in out Map) renames HT_Ops.Move;\n+      Source : in out Map)\n+   is\n+   begin\n+      HT_Ops.Move (Target => Target.HT, Source => Source.HT);\n+   end Move;\n \n    ----------\n    -- Next --\n@@ -524,13 +603,15 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n    function Next (Position : Cursor) return Cursor is\n    begin\n-      if Position = No_Element then\n+      if Position.Node = null then\n+         pragma Assert (Position.Container = null);\n          return No_Element;\n       end if;\n \n       declare\n-         M    : Map renames Position.Container.all;\n-         Node : constant Node_Access := HT_Ops.Next (M, Position.Node);\n+         pragma Assert (Vet (Position));\n+         HT   : Hash_Table_Type renames Position.Container.HT;\n+         Node : constant Node_Access := HT_Ops.Next (HT, Position.Node);\n \n       begin\n          if Node = null then\n@@ -547,10 +628,35 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n    procedure Query_Element\n      (Position : Cursor;\n-      Process  : not null access procedure (Element : Element_Type))\n+      Process  : not null access procedure (Key     : Key_Type;\n+                                            Element : Element_Type))\n    is\n+      pragma Assert (Vet (Position));\n+\n+      K : Key_Type renames Position.Node.Key.all;\n+      E : Element_Type renames Position.Node.Element.all;\n+\n+      M  : Map renames Position.Container.all;\n+      HT : Hash_Table_Type renames M.HT'Unrestricted_Access.all;\n+\n+      B : Natural renames HT.Busy;\n+      L : Natural renames HT.Lock;\n+\n    begin\n-      Process (Position.Node.Key.all, Position.Node.Element.all);\n+      B := B + 1;\n+      L := L + 1;\n+\n+      begin\n+         Process (K, E);\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      L := L - 1;\n+      B := B - 1;\n    end Query_Element;\n \n    ----------\n@@ -561,7 +667,11 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n    procedure Read\n      (Stream    : access Root_Stream_Type'Class;\n-      Container : out Map) renames Read_Nodes;\n+      Container : out Map)\n+   is\n+   begin\n+      Read_Nodes (Stream, Container.HT);\n+   end Read;\n \n    ---------------\n    -- Read_Node --\n@@ -602,7 +712,7 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       Key       : Key_Type;\n       New_Item  : Element_Type)\n    is\n-      Node : constant Node_Access := Key_Ops.Find (Container, Key);\n+      Node : constant Node_Access := Key_Ops.Find (Container.HT, Key);\n \n       K : Key_Access;\n       E : Element_Access;\n@@ -612,11 +722,22 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n          raise Constraint_Error;\n       end if;\n \n+      if Container.HT.Lock > 0 then\n+         raise Program_Error;\n+      end if;\n+\n       K := Node.Key;\n       E := Node.Element;\n \n       Node.Key := new Key_Type'(Key);\n-      Node.Element := new Element_Type'(New_Item);\n+\n+      begin\n+         Node.Element := new Element_Type'(New_Item);\n+      exception\n+         when others =>\n+            Free_Key (K);\n+            raise;\n+      end;\n \n       Free_Key (K);\n       Free_Element (E);\n@@ -627,8 +748,13 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n    ---------------------\n \n    procedure Replace_Element (Position : Cursor; By : Element_Type) is\n+      pragma Assert (Vet (Position));\n       X : Element_Access := Position.Node.Element;\n    begin\n+      if Position.Container.HT.Lock > 0 then\n+         raise Program_Error;\n+      end if;\n+\n       Position.Node.Element := new Element_Type'(By);\n       Free_Element (X);\n    end Replace_Element;\n@@ -639,7 +765,11 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n    procedure Reserve_Capacity\n      (Container : in out Map;\n-      Capacity  : Count_Type) renames HT_Ops.Ensure_Capacity;\n+      Capacity  : Count_Type)\n+   is\n+   begin\n+      HT_Ops.Reserve_Capacity (Container.HT, Capacity);\n+   end Reserve_Capacity;\n \n    --------------\n    -- Set_Next --\n@@ -656,12 +786,93 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n    procedure Update_Element\n      (Position : Cursor;\n-      Process  : not null access procedure (Element : in out Element_Type))\n+      Process  : not null access procedure (Key     : Key_Type;\n+                                            Element : in out Element_Type))\n    is\n+      pragma Assert (Vet (Position));\n+\n+      K : Key_Type renames Position.Node.Key.all;\n+      E : Element_Type renames Position.Node.Element.all;\n+\n+      M  : Map renames Position.Container.all;\n+      HT : Hash_Table_Type renames M.HT'Unrestricted_Access.all;\n+\n+      B : Natural renames HT.Busy;\n+      L : Natural renames HT.Lock;\n+\n    begin\n-      Process (Position.Node.Key.all, Position.Node.Element.all);\n+      B := B + 1;\n+      L := L + 1;\n+\n+      begin\n+         Process (K, E);\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      L := L - 1;\n+      B := B - 1;\n    end Update_Element;\n \n+   ---------\n+   -- Vet --\n+   ---------\n+\n+   function Vet (Position : Cursor) return Boolean is\n+   begin\n+      if Position.Node = null then\n+         return False;\n+      end if;\n+\n+      if Position.Node.Next = Position.Node then\n+         return False;\n+      end if;\n+\n+      if Position.Node.Key = null then\n+         return False;\n+      end if;\n+\n+      if Position.Node.Element = null then\n+         return False;\n+      end if;\n+\n+      declare\n+         HT : Hash_Table_Type renames Position.Container.HT;\n+         X  : Node_Access;\n+      begin\n+         if HT.Length = 0 then\n+            return False;\n+         end if;\n+\n+         if HT.Buckets = null then\n+            return False;\n+         end if;\n+\n+         X := HT.Buckets (Key_Ops.Index (HT, Position.Node.Key.all));\n+\n+         for J in 1 .. HT.Length loop\n+            if X = Position.Node then\n+               return True;\n+            end if;\n+\n+            if X = null then\n+               return False;\n+            end if;\n+\n+            if X = X.Next then -- weird\n+               return False;\n+            end if;\n+\n+            X := X.Next;\n+         end loop;\n+\n+         return False;\n+      end;\n+   end Vet;\n+\n    -----------\n    -- Write --\n    -----------\n@@ -670,7 +881,11 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n    procedure Write\n      (Stream    : access Root_Stream_Type'Class;\n-      Container : Map) renames Write_Nodes;\n+      Container : Map)\n+   is\n+   begin\n+      Write_Nodes (Stream, Container.HT);\n+   end Write;\n \n    ----------------\n    -- Write_Node --\n@@ -686,4 +901,3 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n    end Write_Node;\n \n end Ada.Containers.Indefinite_Hashed_Maps;\n-"}, {"sha": "1f15c585db67815e3efa83e0561b1c4299d11328", "filename": "gcc/ada/a-cihama.ads", "status": "modified", "additions": 47, "deletions": 22, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-cihama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-cihama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihama.ads?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "patch": "@@ -2,11 +2,12 @@\n --                                                                          --\n --                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---                  ADA.CONTAINERS.INDEFINITE_HASHED_MAPS                   --\n+--                      A D A . C O N T A I N E R S .                       --\n+--               I N D E F I N I T E _ H A S H E D _ M A P S                --\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -35,6 +36,7 @@\n \n with Ada.Containers.Hash_Tables;\n with Ada.Streams;\n+with Ada.Finalization;\n \n generic\n    type Key_Type (<>) is private;\n@@ -61,6 +63,8 @@ package Ada.Containers.Indefinite_Hashed_Maps is\n \n    procedure Clear (Container : in out Map);\n \n+   function Key (Position : Cursor) return Key_Type;\n+\n    function Element (Position : Cursor) return Element_Type;\n \n    procedure Query_Element\n@@ -105,14 +109,14 @@ package Ada.Containers.Indefinite_Hashed_Maps is\n      (Container : in out Map;\n       Key       : Key_Type);\n \n-   procedure Exclude\n-     (Container : in out Map;\n-      Key       : Key_Type);\n-\n    procedure Delete\n      (Container : in out Map;\n       Position  : in out Cursor);\n \n+   procedure Exclude\n+     (Container : in out Map;\n+      Key       : Key_Type);\n+\n    function Contains\n      (Container : Map;\n       Key       : Key_Type) return Boolean;\n@@ -125,12 +129,6 @@ package Ada.Containers.Indefinite_Hashed_Maps is\n      (Container : Map;\n       Key       : Key_Type) return Element_Type;\n \n-   function Capacity (Container : Map) return Count_Type;\n-\n-   procedure Reserve_Capacity\n-     (Container : in out Map;\n-      Capacity  : Count_Type);\n-\n    function First (Container : Map) return Cursor;\n \n    function Next (Position : Cursor) return Cursor;\n@@ -139,8 +137,6 @@ package Ada.Containers.Indefinite_Hashed_Maps is\n \n    function Has_Element (Position : Cursor) return Boolean;\n \n-   function Key (Position : Cursor) return Key_Type;\n-\n    function Equivalent_Keys (Left, Right : Cursor)\n      return Boolean;\n \n@@ -156,16 +152,48 @@ package Ada.Containers.Indefinite_Hashed_Maps is\n      (Container : Map;\n       Process   : not null access procedure (Position : Cursor));\n \n+   function Capacity (Container : Map) return Count_Type;\n+\n+   procedure Reserve_Capacity\n+     (Container : in out Map;\n+      Capacity  : Count_Type);\n+\n private\n+   pragma Inline (\"=\");\n+   pragma Inline (Length);\n+   pragma Inline (Is_Empty);\n+   pragma Inline (Clear);\n+   pragma Inline (Key);\n+   pragma Inline (Element);\n+   pragma Inline (Move);\n+   pragma Inline (Contains);\n+   pragma Inline (Capacity);\n+   pragma Inline (Reserve_Capacity);\n+   pragma Inline (Has_Element);\n+   pragma Inline (Equivalent_Keys);\n+\n    type Node_Type;\n    type Node_Access is access Node_Type;\n \n-   package HT_Types is\n-      new Hash_Tables.Generic_Hash_Table_Types (Node_Access);\n+   type Key_Access is access Key_Type;\n+   type Element_Access is access Element_Type;\n \n-   use HT_Types;\n+   type Node_Type is limited record\n+      Key     : Key_Access;\n+      Element : Element_Access;\n+      Next    : Node_Access;\n+   end record;\n+\n+   package HT_Types is new Hash_Tables.Generic_Hash_Table_Types\n+     (Node_Type,\n+      Node_Access);\n+\n+   type Map is new Ada.Finalization.Controlled with record\n+      HT : HT_Types.Hash_Table_Type;\n+   end record;\n \n-   type Map is new Hash_Table_Type with null record;\n+   use HT_Types;\n+   use Ada.Finalization;\n \n    procedure Adjust (Container : in out Map);\n \n@@ -198,9 +226,6 @@ private\n \n    for Map'Read use Read;\n \n-   Empty_Map : constant Map := (Hash_Table_Type with null record);\n+   Empty_Map : constant Map := (Controlled with HT => (null, 0, 0, 0));\n \n end Ada.Containers.Indefinite_Hashed_Maps;\n-\n-\n-"}, {"sha": "f47d9a6c157d7de1b4243c56c2d89dad4503fcf9", "filename": "gcc/ada/a-cihase.adb", "status": "modified", "additions": 1213, "deletions": 885, "changes": 2098, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-cihase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-cihase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihase.adb?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "patch": "@@ -2,11 +2,12 @@\n --                                                                          --\n --                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---                  ADA.CONTAINERS.INDEFINITE_HASHED_SETS                   --\n+--                      A D A . C O N T A I N E R S .                       --\n+--               I N D E F I N I T E _ H A S H E D _ S E T S                --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -45,849 +46,1184 @@ with System;  use type System.Address;\n \n with Ada.Containers.Prime_Numbers;\n \n-with Ada.Finalization;  use Ada.Finalization;\n-\n package body Ada.Containers.Indefinite_Hashed_Sets is\n \n-   type Element_Access is access Element_Type;\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n \n-   type Node_Type is\n-      limited record\n-         Element : Element_Access;\n-         Next    : Node_Access;\n-      end record;\n+   function Copy_Node (Source : Node_Access) return Node_Access;\n+   pragma Inline (Copy_Node);\n \n-   function Hash_Node\n-     (Node : Node_Access) return Hash_Type;\n-   pragma Inline (Hash_Node);\n+   function Equivalent_Keys\n+     (Key  : Element_Type;\n+      Node : Node_Access) return Boolean;\n+   pragma Inline (Equivalent_Keys);\n \n-   function Hash_Node\n-     (Node : Node_Access) return Hash_Type is\n-   begin\n-      return Hash (Node.Element.all);\n-   end Hash_Node;\n+   function Find_Equal_Key\n+     (R_HT   : Hash_Table_Type;\n+      L_Node : Node_Access) return Boolean;\n \n-   function Next\n-     (Node : Node_Access) return Node_Access;\n-   pragma Inline (Next);\n+   function Find_Equivalent_Key\n+     (R_HT   : Hash_Table_Type;\n+      L_Node : Node_Access) return Boolean;\n \n-   function Next\n-     (Node : Node_Access) return Node_Access is\n-   begin\n-      return Node.Next;\n-   end Next;\n+   procedure Free (X : in out Node_Access);\n \n-   procedure Set_Next\n-     (Node : Node_Access;\n-      Next : Node_Access);\n-   pragma Inline (Set_Next);\n+   function Hash_Node (Node : Node_Access) return Hash_Type;\n+   pragma Inline (Hash_Node);\n \n-   procedure Set_Next\n-     (Node : Node_Access;\n-      Next : Node_Access) is\n-   begin\n-      Node.Next := Next;\n-   end Set_Next;\n+   function Is_In (HT  : Hash_Table_Type; Key : Node_Access) return Boolean;\n+   pragma Inline (Is_In);\n \n-   function Equivalent_Keys\n-     (Key  : Element_Type;\n-      Node : Node_Access) return Boolean;\n-   pragma Inline (Equivalent_Keys);\n+   function Next (Node : Node_Access) return Node_Access;\n+   pragma Inline (Next);\n \n-   function Equivalent_Keys\n-     (Key  : Element_Type;\n-      Node : Node_Access) return Boolean is\n-   begin\n-      return Equivalent_Keys (Key, Node.Element.all);\n-   end Equivalent_Keys;\n+   function Read_Node (Stream : access Root_Stream_Type'Class)\n+     return Node_Access;\n+   pragma Inline (Read_Node);\n \n-   function Copy_Node\n-     (Source : Node_Access) return Node_Access;\n-   pragma Inline (Copy_Node);\n+   procedure Replace_Element\n+     (HT      : in out Hash_Table_Type;\n+      Node    : Node_Access;\n+      Element : Element_Type);\n \n-   function Copy_Node\n-     (Source : Node_Access) return Node_Access is\n+   procedure Set_Next (Node : Node_Access; Next : Node_Access);\n+   pragma Inline (Set_Next);\n \n-      Target : constant Node_Access :=\n-        new Node_Type'(Element => Source.Element,\n-                       Next    => null);\n-   begin\n-      return Target;\n-   end Copy_Node;\n+   procedure Write_Node\n+     (Stream : access Root_Stream_Type'Class;\n+      Node   : Node_Access);\n+   pragma Inline (Write_Node);\n \n+   --------------------------\n+   -- Local Instantiations --\n+   --------------------------\n \n    procedure Free_Element is\n       new Ada.Unchecked_Deallocation (Element_Type, Element_Access);\n \n-   procedure Free (X : in out Node_Access);\n-\n-   procedure Free (X : in out Node_Access) is\n-      procedure Deallocate is\n-         new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n-   begin\n-      if X /= null then\n-         Free_Element (X.Element);\n-         Deallocate (X);\n-      end if;\n-   end Free;\n-\n    package HT_Ops is\n       new Hash_Tables.Generic_Operations\n-       (HT_Types          => HT_Types,\n-        Hash_Table_Type   => Set,\n-        Null_Node         => null,\n-        Hash_Node         => Hash_Node,\n-        Next              => Next,\n-        Set_Next          => Set_Next,\n-        Copy_Node         => Copy_Node,\n-        Free              => Free);\n+       (HT_Types  => HT_Types,\n+        Hash_Node => Hash_Node,\n+        Next      => Next,\n+        Set_Next  => Set_Next,\n+        Copy_Node => Copy_Node,\n+        Free      => Free);\n \n    package Element_Keys is\n       new Hash_Tables.Generic_Keys\n        (HT_Types  => HT_Types,\n-        HT_Type   => Set,\n-        Null_Node => null,\n         Next      => Next,\n         Set_Next  => Set_Next,\n         Key_Type  => Element_Type,\n         Hash      => Hash,\n         Equivalent_Keys => Equivalent_Keys);\n \n+   function Is_Equal is\n+      new HT_Ops.Generic_Equal (Find_Equal_Key);\n \n-   procedure Adjust (Container : in out Set) renames HT_Ops.Adjust;\n-\n-   procedure Finalize (Container : in out Set) renames HT_Ops.Finalize;\n-\n-\n-   function Find_Equal_Key\n-     (R_Set  : Set;\n-      L_Node : Node_Access) return Boolean;\n+   function Is_Equivalent is\n+      new HT_Ops.Generic_Equal (Find_Equivalent_Key);\n \n-   function Find_Equal_Key\n-     (R_Set  : Set;\n-      L_Node : Node_Access) return Boolean is\n+   procedure Read_Nodes is\n+      new HT_Ops.Generic_Read (Read_Node);\n \n-      R_Index : constant Hash_Type :=\n-        Element_Keys.Index (R_Set, L_Node.Element.all);\n+   procedure Write_Nodes is\n+     new HT_Ops.Generic_Write (Write_Node);\n \n-      R_Node  : Node_Access := R_Set.Buckets (R_Index);\n+   ---------\n+   -- \"=\" --\n+   ---------\n \n+   function \"=\" (Left, Right : Set) return Boolean is\n    begin\n+      return Is_Equal (Left.HT, Right.HT);\n+   end \"=\";\n \n-      loop\n-\n-         if R_Node = null then\n-            return False;\n-         end if;\n-\n-         if L_Node.Element.all = R_Node.Element.all then\n-            return True;\n-         end if;\n-\n-         R_Node := Next (R_Node);\n-\n-      end loop;\n-\n-   end Find_Equal_Key;\n-\n-   function Is_Equal is\n-      new HT_Ops.Generic_Equal (Find_Equal_Key);\n+   ------------\n+   -- Adjust --\n+   ------------\n \n-   function \"=\" (Left, Right : Set) return Boolean renames Is_Equal;\n+   procedure Adjust (Container : in out Set) is\n+   begin\n+      HT_Ops.Adjust (Container.HT);\n+   end Adjust;\n \n+   --------------\n+   -- Capacity --\n+   --------------\n \n-   function Length (Container : Set) return Count_Type is\n+   function Capacity (Container : Set) return Count_Type is\n    begin\n-      return Container.Length;\n-   end Length;\n+      return HT_Ops.Capacity (Container.HT);\n+   end Capacity;\n \n+   -----------\n+   -- Clear --\n+   -----------\n \n-   function Is_Empty (Container : Set) return Boolean is\n+   procedure Clear (Container : in out Set) is\n    begin\n-      return Container.Length = 0;\n-   end Is_Empty;\n+      HT_Ops.Clear (Container.HT);\n+   end Clear;\n \n+   --------------\n+   -- Contains --\n+   --------------\n \n-   procedure Clear (Container : in out Set) renames HT_Ops.Clear;\n+   function Contains (Container : Set; Item : Element_Type) return Boolean is\n+   begin\n+      return Find (Container, Item) /= No_Element;\n+   end Contains;\n \n+   ---------------\n+   -- Copy_Node --\n+   ---------------\n \n-   function Element (Position : Cursor) return Element_Type is\n+   function Copy_Node (Source : Node_Access) return Node_Access is\n+      E : Element_Access := new Element_Type'(Source.Element.all);\n    begin\n-      return Position.Node.Element.all;\n-   end Element;\n+      return new Node_Type'(Element => E, Next => null);\n+   exception\n+      when others =>\n+         Free_Element (E);\n+         raise;\n+   end Copy_Node;\n \n+   ------------\n+   -- Delete --\n+   ------------\n \n-   procedure Query_Element\n-     (Position : in Cursor;\n-      Process  : not null access procedure (Element : in Element_Type)) is\n-   begin\n-      Process (Position.Node.Element.all);\n-   end Query_Element;\n+   procedure Delete\n+     (Container : in out Set;\n+      Item      : Element_Type)\n+   is\n+      X : Node_Access;\n \n+   begin\n+      Element_Keys.Delete_Key_Sans_Free (Container.HT, Item, X);\n \n---  TODO:\n---     procedure Replace_Element (Container : in out Set;\n---                                Position  : in     Node_Access;\n---                                By        : in     Element_Type);\n+      if X = null then\n+         raise Constraint_Error;\n+      end if;\n \n---     procedure Replace_Element (Container : in out Set;\n---                                Position  : in     Node_Access;\n---                                By        : in     Element_Type) is\n+      Free (X);\n+   end Delete;\n \n---        Node : Node_Access := Position;\n+   procedure Delete\n+     (Container : in out Set;\n+      Position  : in out Cursor)\n+   is\n+   begin\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n \n---     begin\n+      if Position.Container /= Set_Access'(Container'Unchecked_Access) then\n+         raise Program_Error;\n+      end if;\n \n---        if Equivalent_Keys (Node.Element.all, By) then\n+      if Container.HT.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n \n---           declare\n---              X : Element_Access := Node.Element;\n---           begin\n---              Node.Element := new Element_Type'(By);\n---              --\n---              --  NOTE: If there's an exception here, then just\n---              --  let it propagate.  We haven't modified the\n---              --  state of the container, so there's nothing else\n---              --  we need to do.\n+      HT_Ops.Delete_Node_Sans_Free (Container.HT, Position.Node);\n \n---              Free_Element (X);\n---           end;\n+      Free (Position.Node);\n \n---           return;\n+      Position.Container := null;\n+   end Delete;\n \n---        end if;\n+   ----------------\n+   -- Difference --\n+   ----------------\n \n---        HT_Ops.Delete_Node_Sans_Free (Container, Node);\n+   procedure Difference\n+     (Target : in out Set;\n+      Source : Set)\n+   is\n+      Tgt_Node : Node_Access;\n \n---        begin\n---           Free_Element (Node.Element);\n---        exception\n---           when others =>\n---              Node.Element := null;  --  don't attempt to dealloc X.E again\n---              Free (Node);\n---              raise;\n---        end;\n+   begin\n+      if Target'Address = Source'Address then\n+         Clear (Target);\n+         return;\n+      end if;\n \n---        begin\n---           Node.Element := new Element_Type'(By);\n---        exception\n---           when others =>\n---              Free (Node);\n---              raise;\n---        end;\n+      if Source.Length = 0 then\n+         return;\n+      end if;\n \n---        declare\n---           function New_Node (Next : Node_Access) return Node_Access;\n---           pragma Inline (New_Node);\n+      if Target.HT.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n \n---           function New_Node (Next : Node_Access) return Node_Access is\n---           begin\n---              Node.Next := Next;\n---              return Node;\n---           end New_Node;\n+      --  TODO: This can be written in terms of a loop instead as\n+      --  active-iterator style, sort of like a passive iterator.\n \n---           procedure Insert is\n---              new Element_Keys.Generic_Conditional_Insert (New_Node);\n+      Tgt_Node := HT_Ops.First (Target.HT);\n+      while Tgt_Node /= null loop\n+         if Is_In (Source.HT, Tgt_Node) then\n+            declare\n+               X : Node_Access := Tgt_Node;\n+            begin\n+               Tgt_Node := HT_Ops.Next (Target.HT, Tgt_Node);\n+               HT_Ops.Delete_Node_Sans_Free (Target.HT, X);\n+               Free (X);\n+            end;\n \n---           Result  : Node_Access;\n---           Success : Boolean;\n---        begin\n---           Insert\n---             (HT      => Container,\n---              Key     => Node.Element.all,\n---              Node    => Result,\n---              Success => Success);\n+         else\n+            Tgt_Node := HT_Ops.Next (Target.HT, Tgt_Node);\n+         end if;\n+      end loop;\n+   end Difference;\n \n---           if not Success then\n---              Free (Node);\n---              raise Program_Error;\n---           end if;\n+   function Difference (Left, Right : Set) return Set is\n+      Buckets : HT_Types.Buckets_Access;\n+      Length  : Count_Type;\n \n---           pragma Assert (Result = Node);\n---        end;\n+   begin\n+      if Left'Address = Right'Address then\n+         return Empty_Set;\n+      end if;\n \n---     end Replace_Element;\n+      if Left.Length = 0 then\n+         return Empty_Set;\n+      end if;\n \n+      if Right.Length = 0 then\n+         return Left;\n+      end if;\n \n---     procedure Replace_Element (Container : in out Set;\n---                                Position  : in     Cursor;\n---                                By        : in     Element_Type) is\n---     begin\n+      declare\n+         Size : constant Hash_Type := Prime_Numbers.To_Prime (Left.Length);\n+      begin\n+         Buckets := new Buckets_Type (0 .. Size - 1);\n+      end;\n \n---        if Position.Container = null then\n---           raise Constraint_Error;\n---        end if;\n+      Length := 0;\n \n---        if Position.Container /= Set_Access'(Container'Unchecked_Access) then\n---           raise Program_Error;\n---        end if;\n+      Iterate_Left : declare\n+         procedure Process (L_Node : Node_Access);\n \n---        Replace_Element (Container, Position.Node, By);\n+         procedure Iterate is\n+            new HT_Ops.Generic_Iteration (Process);\n \n---     end Replace_Element;\n+         -------------\n+         -- Process --\n+         -------------\n \n+         procedure Process (L_Node : Node_Access) is\n+         begin\n+            if not Is_In (Right.HT, L_Node) then\n+               declare\n+                  Indx : constant Hash_Type :=\n+                           Hash (L_Node.Element.all) mod Buckets'Length;\n \n-   procedure Move (Target : in out Set;\n-                   Source : in out Set) renames HT_Ops.Move;\n+                  Bucket : Node_Access renames Buckets (Indx);\n \n+               begin\n+                  Bucket := new Node_Type'(L_Node.Element, Bucket);\n+               end;\n \n-   procedure Insert (Container : in out Set;\n-                     New_Item  : in     Element_Type;\n-                     Position  :    out Cursor;\n-                     Inserted  :    out Boolean) is\n+               Length := Length + 1;\n+            end if;\n+         end Process;\n \n-      function New_Node (Next : Node_Access) return Node_Access;\n-      pragma Inline (New_Node);\n+      --  Start of processing for Iterate_Left\n \n-      function New_Node (Next : Node_Access) return Node_Access is\n-         Element : Element_Access := new Element_Type'(New_Item);\n       begin\n-         return new Node_Type'(Element, Next);\n+         Iterate (Left.HT);\n       exception\n          when others =>\n-            Free_Element (Element);\n+            HT_Ops.Free_Hash_Table (Buckets);\n             raise;\n-      end New_Node;\n+      end Iterate_Left;\n \n-      procedure Insert is\n-        new Element_Keys.Generic_Conditional_Insert (New_Node);\n+      return (Controlled with HT => (Buckets, Length, 0, 0));\n+   end Difference;\n+\n+   -------------\n+   -- Element --\n+   -------------\n \n+   function Element (Position : Cursor) return Element_Type is\n    begin\n+      return Position.Node.Element.all;\n+   end Element;\n \n-      HT_Ops.Ensure_Capacity (Container, Container.Length + 1);\n-      Insert (Container, New_Item, Position.Node, Inserted);\n-      Position.Container := Container'Unchecked_Access;\n+   ---------------------\n+   -- Equivalent_Sets --\n+   ---------------------\n \n-   end Insert;\n+   function Equivalent_Sets (Left, Right : Set) return Boolean is\n+   begin\n+      return Is_Equivalent (Left.HT, Right.HT);\n+   end Equivalent_Sets;\n \n+   -------------------------\n+   -- Equivalent_Elements --\n+   -------------------------\n \n-   procedure Insert (Container : in out Set;\n-                     New_Item  : in     Element_Type) is\n+   function Equivalent_Elements (Left, Right : Cursor)\n+     return Boolean is\n+   begin\n+      return Equivalent_Elements\n+               (Left.Node.Element.all,\n+                Right.Node.Element.all);\n+   end Equivalent_Elements;\n \n-      Position : Cursor;\n-      Inserted : Boolean;\n+   function Equivalent_Elements (Left : Cursor; Right : Element_Type)\n+     return Boolean is\n+   begin\n+      return Equivalent_Elements (Left.Node.Element.all, Right);\n+   end Equivalent_Elements;\n \n+   function Equivalent_Elements (Left : Element_Type; Right : Cursor)\n+     return Boolean is\n    begin\n+      return Equivalent_Elements (Left, Right.Node.Element.all);\n+   end Equivalent_Elements;\n \n-      Insert (Container, New_Item, Position, Inserted);\n+   ---------------------\n+   -- Equivalent_Keys --\n+   ---------------------\n \n-      if not Inserted then\n-         raise Constraint_Error;\n-      end if;\n+   function Equivalent_Keys (Key : Element_Type; Node : Node_Access)\n+     return Boolean is\n+   begin\n+      return Equivalent_Elements (Key, Node.Element.all);\n+   end Equivalent_Keys;\n \n-   end Insert;\n+   -------------\n+   -- Exclude --\n+   -------------\n \n+   procedure Exclude\n+     (Container : in out Set;\n+      Item      : Element_Type)\n+   is\n+      X : Node_Access;\n+   begin\n+      Element_Keys.Delete_Key_Sans_Free (Container.HT, Item, X);\n+      Free (X);\n+   end Exclude;\n \n-   procedure Replace (Container : in out Set;\n-                      New_Item  : in     Element_Type) is\n+   --------------\n+   -- Finalize --\n+   --------------\n \n-      Node : constant Node_Access :=\n-        Element_Keys.Find (Container, New_Item);\n+   procedure Finalize (Container : in out Set) is\n+   begin\n+      HT_Ops.Finalize (Container.HT);\n+   end Finalize;\n \n-      X : Element_Access;\n+   ----------\n+   -- Find --\n+   ----------\n \n-   begin\n+   function Find\n+     (Container : Set;\n+      Item      : Element_Type) return Cursor\n+   is\n+      Node : constant Node_Access := Element_Keys.Find (Container.HT, Item);\n \n+   begin\n       if Node = null then\n-         raise Constraint_Error;\n+         return No_Element;\n       end if;\n \n-      X := Node.Element;\n+      return Cursor'(Container'Unrestricted_Access, Node);\n+   end Find;\n \n-      Node.Element := new Element_Type'(New_Item);\n+   --------------------\n+   -- Find_Equal_Key --\n+   --------------------\n \n-      Free_Element (X);\n+   function Find_Equal_Key\n+     (R_HT   : Hash_Table_Type;\n+      L_Node : Node_Access) return Boolean\n+   is\n+      R_Index : constant Hash_Type :=\n+                  Element_Keys.Index (R_HT, L_Node.Element.all);\n \n-   end Replace;\n+      R_Node  : Node_Access := R_HT.Buckets (R_Index);\n \n+   begin\n+      loop\n+         if R_Node = null then\n+            return False;\n+         end if;\n \n-   procedure Include (Container : in out Set;\n-                      New_Item  : in     Element_Type) is\n+         if L_Node.Element.all = R_Node.Element.all then\n+            return True;\n+         end if;\n \n-      Position : Cursor;\n-      Inserted : Boolean;\n+         R_Node := Next (R_Node);\n+      end loop;\n+   end Find_Equal_Key;\n \n-      X : Element_Access;\n+   -------------------------\n+   -- Find_Equivalent_Key --\n+   -------------------------\n+\n+   function Find_Equivalent_Key\n+     (R_HT   : Hash_Table_Type;\n+      L_Node : Node_Access) return Boolean\n+   is\n+      R_Index : constant Hash_Type :=\n+                  Element_Keys.Index (R_HT, L_Node.Element.all);\n+\n+      R_Node  : Node_Access := R_HT.Buckets (R_Index);\n \n    begin\n+      loop\n+         if R_Node = null then\n+            return False;\n+         end if;\n \n-      Insert (Container, New_Item, Position, Inserted);\n+         if Equivalent_Elements (L_Node.Element.all, R_Node.Element.all) then\n+            return True;\n+         end if;\n \n-      if not Inserted then\n+         R_Node := Next (R_Node);\n+      end loop;\n+   end Find_Equivalent_Key;\n \n-         X := Position.Node.Element;\n+   -----------\n+   -- First --\n+   -----------\n \n-         Position.Node.Element := new Element_Type'(New_Item);\n-\n-         Free_Element (X);\n+   function First (Container : Set) return Cursor is\n+      Node : constant Node_Access := HT_Ops.First (Container.HT);\n \n+   begin\n+      if Node = null then\n+         return No_Element;\n       end if;\n \n-   end Include;\n-\n+      return Cursor'(Container'Unrestricted_Access, Node);\n+   end First;\n \n-   procedure Delete (Container : in out Set;\n-                     Item      : in     Element_Type) is\n+   ----------\n+   -- Free --\n+   ----------\n \n-      X : Node_Access;\n+   procedure Free (X : in out Node_Access) is\n+      procedure Deallocate is\n+         new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n \n    begin\n-\n-      Element_Keys.Delete_Key_Sans_Free (Container, Item, X);\n-\n       if X = null then\n-         raise Constraint_Error;\n+         return;\n       end if;\n \n-      Free (X);\n+      begin\n+         Free_Element (X.Element);\n+      exception\n+         when others =>\n+            X.Element := null;\n+            Deallocate (X);\n+            raise;\n+      end;\n \n-   end Delete;\n+      Deallocate (X);\n+   end Free;\n \n+   -----------------\n+   -- Has_Element --\n+   -----------------\n \n-   procedure Exclude (Container : in out Set;\n-                      Item      : in     Element_Type) is\n+   function Has_Element (Position : Cursor) return Boolean is\n+   begin\n+      if Position.Node = null then\n+         pragma Assert (Position.Container = null);\n+         return False;\n+      end if;\n \n-      X : Node_Access;\n+      return True;\n+   end Has_Element;\n \n+   ---------------\n+   -- Hash_Node --\n+   ---------------\n+\n+   function Hash_Node (Node : Node_Access) return Hash_Type is\n    begin\n+      return Hash (Node.Element.all);\n+   end Hash_Node;\n \n-      Element_Keys.Delete_Key_Sans_Free (Container, Item, X);\n-      Free (X);\n+   -------------\n+   -- Include --\n+   -------------\n \n-   end Exclude;\n+   procedure Include\n+     (Container : in out Set;\n+      New_Item  : Element_Type)\n+   is\n+      Position : Cursor;\n+      Inserted : Boolean;\n \n+      X : Element_Access;\n \n-   procedure Delete (Container : in out Set;\n-                     Position  : in out Cursor) is\n    begin\n+      Insert (Container, New_Item, Position, Inserted);\n \n-      if Position = No_Element then\n-         return;\n-      end if;\n+      if not Inserted then\n+         if Container.HT.Lock > 0 then\n+            raise Program_Error;\n+         end if;\n \n-      if Position.Container /= Set_Access'(Container'Unchecked_Access) then\n-         raise Program_Error;\n-      end if;\n+         X := Position.Node.Element;\n \n-      HT_Ops.Delete_Node_Sans_Free (Container, Position.Node);\n-      Free (Position.Node);\n+         Position.Node.Element := new Element_Type'(New_Item);\n \n-      Position.Container := null;\n+         Free_Element (X);\n+      end if;\n+   end Include;\n \n-   end Delete;\n+   ------------\n+   -- Insert --\n+   ------------\n \n+   procedure Insert\n+     (Container : in out Set;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean)\n+   is\n+      function New_Node (Next : Node_Access) return Node_Access;\n+      pragma Inline (New_Node);\n \n+      procedure Insert is\n+         new Element_Keys.Generic_Conditional_Insert (New_Node);\n \n-   procedure Union (Target : in out Set;\n-                    Source : in     Set) is\n+      --------------\n+      -- New_Node --\n+      --------------\n \n-      procedure Process (Src_Node : in Node_Access);\n+      function New_Node (Next : Node_Access) return Node_Access is\n+         Element : Element_Access := new Element_Type'(New_Item);\n \n-      procedure Process (Src_Node : in Node_Access) is\n+      begin\n+         return new Node_Type'(Element, Next);\n+      exception\n+         when others =>\n+            Free_Element (Element);\n+            raise;\n+      end New_Node;\n \n-         Src : Element_Type renames Src_Node.Element.all;\n+      HT : Hash_Table_Type renames Container.HT;\n \n-         function New_Node (Next : Node_Access) return Node_Access;\n-         pragma Inline (New_Node);\n+   --  Start of processing for Insert\n \n-         function New_Node (Next : Node_Access) return Node_Access is\n-            Tgt : Element_Access := new Element_Type'(Src);\n-         begin\n-            return new Node_Type'(Tgt, Next);\n-         exception\n-            when others =>\n-               Free_Element (Tgt);\n-               raise;\n-         end New_Node;\n+   begin\n+      if HT.Length >= HT_Ops.Capacity (HT) then\n+         --  TODO: optimize this (see a-cohase.adb)\n+         HT_Ops.Reserve_Capacity (HT, HT.Length + 1);\n+      end if;\n \n-         procedure Insert is\n-            new Element_Keys.Generic_Conditional_Insert (New_Node);\n+      Insert (HT, New_Item, Position.Node, Inserted);\n+      Position.Container := Container'Unchecked_Access;\n+   end Insert;\n \n-         Tgt_Node : Node_Access;\n-         Success  : Boolean;\n+   procedure Insert\n+     (Container : in out Set;\n+      New_Item  : Element_Type)\n+   is\n+      Position : Cursor;\n+      Inserted : Boolean;\n \n-      begin\n+   begin\n+      Insert (Container, New_Item, Position, Inserted);\n \n-         Insert (Target, Src, Tgt_Node, Success);\n+      if not Inserted then\n+         raise Constraint_Error;\n+      end if;\n+   end Insert;\n \n-      end Process;\n+   ------------------\n+   -- Intersection --\n+   ------------------\n \n-      procedure Iterate is\n-         new HT_Ops.Generic_Iteration (Process);\n+   procedure Intersection\n+     (Target : in out Set;\n+      Source : Set)\n+   is\n+      Tgt_Node : Node_Access;\n \n    begin\n-\n       if Target'Address = Source'Address then\n          return;\n       end if;\n \n-      HT_Ops.Ensure_Capacity (Target, Target.Length + Source.Length);\n-\n-      Iterate (Source);\n+      if Source.Length = 0 then\n+         Clear (Target);\n+         return;\n+      end if;\n \n-   end Union;\n+      if Target.HT.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n \n+      --  TODO: optimize this to use an explicit\n+      --  loop instead of an active iterator\n+      --  (similar to how a passive iterator is\n+      --  implemented).\n+      --\n+      --  Another possibility is to test which\n+      --  set is smaller, and iterate over the\n+      --  smaller set.\n \n+      Tgt_Node := HT_Ops.First (Target.HT);\n+      while Tgt_Node /= null loop\n+         if Is_In (Source.HT, Tgt_Node) then\n+            Tgt_Node := HT_Ops.Next (Target.HT, Tgt_Node);\n \n-   function Union (Left, Right : Set) return Set is\n+         else\n+            declare\n+               X : Node_Access := Tgt_Node;\n+            begin\n+               Tgt_Node := HT_Ops.Next (Target.HT, Tgt_Node);\n+               HT_Ops.Delete_Node_Sans_Free (Target.HT, X);\n+               Free (X);\n+            end;\n+         end if;\n+      end loop;\n+   end Intersection;\n \n+   function Intersection (Left, Right : Set) return Set is\n       Buckets : HT_Types.Buckets_Access;\n       Length  : Count_Type;\n \n    begin\n-\n       if Left'Address = Right'Address then\n          return Left;\n       end if;\n \n-      if Right.Length = 0 then\n-         return Left;\n-      end if;\n+      Length := Count_Type'Min (Left.Length, Right.Length);\n \n-      if Left.Length = 0 then\n-         return Right;\n+      if Length = 0 then\n+         return Empty_Set;\n       end if;\n \n       declare\n-         Size : constant Hash_Type :=\n-           Prime_Numbers.To_Prime (Left.Length + Right.Length);\n+         Size : constant Hash_Type := Prime_Numbers.To_Prime (Length);\n       begin\n          Buckets := new Buckets_Type (0 .. Size - 1);\n       end;\n \n-      declare\n+      Length := 0;\n+\n+      Iterate_Left : declare\n          procedure Process (L_Node : Node_Access);\n \n+         procedure Iterate is\n+            new HT_Ops.Generic_Iteration (Process);\n+\n+         -------------\n+         -- Process --\n+         -------------\n+\n          procedure Process (L_Node : Node_Access) is\n-            I : constant Hash_Type :=\n-              Hash (L_Node.Element.all) mod Buckets'Length;\n          begin\n-            Buckets (I) := new Node_Type'(L_Node.Element, Buckets (I));\n+            if Is_In (Right.HT, L_Node) then\n+               declare\n+                  Indx : constant Hash_Type :=\n+                           Hash (L_Node.Element.all) mod Buckets'Length;\n+\n+                  Bucket : Node_Access renames Buckets (Indx);\n+\n+               begin\n+                  Bucket := new Node_Type'(L_Node.Element, Bucket);\n+               end;\n+\n+               Length := Length + 1;\n+            end if;\n          end Process;\n \n-         procedure Iterate is\n-            new HT_Ops.Generic_Iteration (Process);\n+      --  Start of processing for Iterate_Left\n+\n       begin\n-         Iterate (Left);\n+         Iterate (Left.HT);\n       exception\n          when others =>\n             HT_Ops.Free_Hash_Table (Buckets);\n             raise;\n-      end;\n+      end Iterate_Left;\n \n-      Length := Left.Length;\n+      return (Controlled with HT => (Buckets, Length, 0, 0));\n+   end Intersection;\n \n-      declare\n-         procedure Process (Src_Node : Node_Access);\n+   --------------\n+   -- Is_Empty --\n+   --------------\n \n-         procedure Process (Src_Node : Node_Access) is\n+   function Is_Empty (Container : Set) return Boolean is\n+   begin\n+      return Container.Length = 0;\n+   end Is_Empty;\n \n-            Src : Element_Type renames Src_Node.Element.all;\n+   -----------\n+   -- Is_In --\n+   -----------\n \n-            I : constant Hash_Type :=\n-              Hash (Src) mod Buckets'Length;\n+   function Is_In (HT  : Hash_Table_Type; Key : Node_Access) return Boolean is\n+   begin\n+      return Element_Keys.Find (HT, Key.Element.all) /= null;\n+   end Is_In;\n \n-            Tgt_Node : Node_Access := Buckets (I);\n+   ---------------\n+   -- Is_Subset --\n+   ---------------\n \n-         begin\n+   function Is_Subset\n+     (Subset : Set;\n+      Of_Set : Set) return Boolean\n+   is\n+      Subset_Node : Node_Access;\n \n-            while Tgt_Node /= null loop\n+   begin\n+      if Subset'Address = Of_Set'Address then\n+         return True;\n+      end if;\n \n-               if Equivalent_Keys (Src, Tgt_Node.Element.all) then\n-                  return;\n-               end if;\n+      if Subset.Length > Of_Set.Length then\n+         return False;\n+      end if;\n \n-               Tgt_Node := Next (Tgt_Node);\n+      --  TODO: rewrite this to loop in the\n+      --  style of a passive iterator.\n \n-            end loop;\n+      Subset_Node := HT_Ops.First (Subset.HT);\n+      while Subset_Node /= null loop\n+         if not Is_In (Of_Set.HT, Subset_Node) then\n+            return False;\n+         end if;\n \n-            declare\n-               Tgt : Element_Access := new Element_Type'(Src);\n-            begin\n-               Buckets (I) := new Node_Type'(Tgt, Buckets (I));\n-            exception\n-               when others =>\n-                  Free_Element (Tgt);\n-                  raise;\n-            end;\n+         Subset_Node := HT_Ops.Next (Subset.HT, Subset_Node);\n+      end loop;\n \n-            Length := Length + 1;\n+      return True;\n+   end Is_Subset;\n \n-         end Process;\n+   -------------\n+   -- Iterate --\n+   -------------\n \n-         procedure Iterate is\n-            new HT_Ops.Generic_Iteration (Process);\n-      begin\n-         Iterate (Right);\n-      exception\n-         when others =>\n-            HT_Ops.Free_Hash_Table (Buckets);\n-            raise;\n-      end;\n+   procedure Iterate\n+     (Container : Set;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+      procedure Process_Node (Node : Node_Access);\n+      pragma Inline (Process_Node);\n \n-      return (Controlled with Buckets, Length);\n+      procedure Iterate is\n+         new HT_Ops.Generic_Iteration (Process_Node);\n \n-   end Union;\n+      ------------------\n+      -- Process_Node --\n+      ------------------\n \n+      procedure Process_Node (Node : Node_Access) is\n+      begin\n+         Process (Cursor'(Container'Unrestricted_Access, Node));\n+      end Process_Node;\n \n-   function Is_In\n-     (HT  : Set;\n-      Key : Node_Access) return Boolean;\n-   pragma Inline (Is_In);\n+      HT : Hash_Table_Type renames Container'Unrestricted_Access.all.HT;\n+      B  : Natural renames HT.Busy;\n+\n+   --  Start of processing for Iterate\n \n-   function Is_In\n-     (HT  : Set;\n-      Key : Node_Access) return Boolean is\n    begin\n-      return Element_Keys.Find (HT, Key.Element.all) /= null;\n-   end Is_In;\n+      B := B + 1;\n \n+      begin\n+         Iterate (HT);\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n \n-   procedure Intersection (Target : in out Set;\n-                           Source : in     Set) is\n+      B := B - 1;\n+   end Iterate;\n \n-      Tgt_Node : Node_Access;\n+   ------------\n+   -- Length --\n+   ------------\n \n+   function Length (Container : Set) return Count_Type is\n    begin\n+      return Container.HT.Length;\n+   end Length;\n \n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n-      if Source.Length = 0 then\n-         Clear (Target);\n-         return;\n-      end if;\n-\n-      --  TODO: optimize this to use an explicit\n-      --  loop instead of an active iterator\n-      --  (similar to how a passive iterator is\n-      --  implemented).\n-      --\n-      --  Another possibility is to test which\n-      --  set is smaller, and iterate over the\n-      --  smaller set.\n-\n-      Tgt_Node := HT_Ops.First (Target);\n+   ----------\n+   -- Move --\n+   ----------\n \n-      while Tgt_Node /= null loop\n+   procedure Move (Target : in out Set; Source : in out Set) is\n+   begin\n+      HT_Ops.Move (Target => Target.HT, Source => Source.HT);\n+   end Move;\n \n-         if Is_In (Source, Tgt_Node) then\n+   ----------\n+   -- Next --\n+   ----------\n \n-            Tgt_Node := HT_Ops.Next (Target, Tgt_Node);\n+   function Next (Node : Node_Access) return Node_Access is\n+   begin\n+      return Node.Next;\n+   end Next;\n \n-         else\n+   function Next (Position : Cursor) return Cursor is\n+   begin\n+      if Position.Node = null then\n+         pragma Assert (Position.Container = null);\n+         return No_Element;\n+      end if;\n \n-            declare\n-               X : Node_Access := Tgt_Node;\n-            begin\n-               Tgt_Node := HT_Ops.Next (Target, Tgt_Node);\n-               HT_Ops.Delete_Node_Sans_Free (Target, X);\n-               Free (X);\n-            end;\n+      declare\n+         HT   : Hash_Table_Type renames Position.Container.HT;\n+         Node : constant Node_Access := HT_Ops.Next (HT, Position.Node);\n \n+      begin\n+         if Node = null then\n+            return No_Element;\n          end if;\n \n-      end loop;\n-\n-   end Intersection;\n+         return Cursor'(Position.Container, Node);\n+      end;\n+   end Next;\n \n+   procedure Next (Position : in out Cursor) is\n+   begin\n+      Position := Next (Position);\n+   end Next;\n \n-   function Intersection (Left, Right : Set) return Set is\n+   -------------\n+   -- Overlap --\n+   -------------\n \n-      Buckets : HT_Types.Buckets_Access;\n-      Length  : Count_Type;\n+   function Overlap (Left, Right : Set) return Boolean is\n+      Left_Node : Node_Access;\n \n    begin\n+      if Right.Length = 0 then\n+         return False;\n+      end if;\n \n       if Left'Address = Right'Address then\n-         return Left;\n+         return True;\n       end if;\n \n-      Length := Count_Type'Min (Left.Length, Right.Length);\n-\n-      if Length = 0 then\n-         return Empty_Set;\n-      end if;\n+      Left_Node := HT_Ops.First (Left.HT);\n+      while Left_Node /= null loop\n+         if Is_In (Right.HT, Left_Node) then\n+            return True;\n+         end if;\n \n-      declare\n-         Size : constant Hash_Type := Prime_Numbers.To_Prime (Length);\n-      begin\n-         Buckets := new Buckets_Type (0 .. Size - 1);\n-      end;\n+         Left_Node := HT_Ops.Next (Left.HT, Left_Node);\n+      end loop;\n \n-      Length := 0;\n+      return False;\n+   end Overlap;\n \n-      declare\n-         procedure Process (L_Node : Node_Access);\n+   -------------------\n+   -- Query_Element --\n+   -------------------\n \n-         procedure Process (L_Node : Node_Access) is\n-         begin\n-            if Is_In (Right, L_Node) then\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : Element_Type))\n+   is\n+      E : Element_Type renames Position.Node.Element.all;\n \n-               declare\n-                  I : constant Hash_Type :=\n-                    Hash (L_Node.Element.all) mod Buckets'Length;\n-               begin\n-                  Buckets (I) := new Node_Type'(L_Node.Element, Buckets (I));\n-               end;\n+      HT : Hash_Table_Type renames\n+             Position.Container'Unrestricted_Access.all.HT;\n \n-               Length := Length + 1;\n+      B : Natural renames HT.Busy;\n+      L : Natural renames HT.Lock;\n \n-            end if;\n-         end Process;\n+   begin\n+      B := B + 1;\n+      L := L + 1;\n \n-         procedure Iterate is\n-            new HT_Ops.Generic_Iteration (Process);\n       begin\n-         Iterate (Left);\n+         Process (E);\n       exception\n          when others =>\n-            HT_Ops.Free_Hash_Table (Buckets);\n+            L := L - 1;\n+            B := B - 1;\n             raise;\n       end;\n \n-      return (Controlled with Buckets, Length);\n-\n-   end Intersection;\n+      L := L - 1;\n+      B := B - 1;\n+   end Query_Element;\n \n+   ----------\n+   -- Read --\n+   ----------\n \n-   procedure Difference (Target : in out Set;\n-                         Source : in     Set) is\n+   procedure Read\n+     (Stream    : access Root_Stream_Type'Class;\n+      Container : out Set)\n+   is\n+   begin\n+      Read_Nodes (Stream, Container.HT);\n+   end Read;\n \n+   ---------------\n+   -- Read_Node --\n+   ---------------\n \n-      Tgt_Node : Node_Access;\n+   function Read_Node\n+     (Stream : access Root_Stream_Type'Class) return Node_Access\n+   is\n+      X : Element_Access := new Element_Type'(Element_Type'Input (Stream));\n \n    begin\n+      return new Node_Type'(X, null);\n+   exception\n+      when others =>\n+         Free_Element (X);\n+         raise;\n+   end Read_Node;\n \n-      if Target'Address = Source'Address then\n-         Clear (Target);\n-         return;\n-      end if;\n+   -------------\n+   -- Replace --\n+   -------------\n \n-      if Source.Length = 0 then\n-         return;\n-      end if;\n+   procedure Replace\n+     (Container : in out Set;\n+      New_Item  : Element_Type)\n+   is\n+      Node : constant Node_Access :=\n+               Element_Keys.Find (Container.HT, New_Item);\n \n-      --  TODO: As I noted above, this can be\n-      --  written in terms of a loop instead as\n-      --  active-iterator style, sort of like a\n-      --  passive iterator.\n+      X : Element_Access;\n \n-      Tgt_Node := HT_Ops.First (Target);\n+   begin\n+      if Node = null then\n+         raise Constraint_Error;\n+      end if;\n \n-      while Tgt_Node /= null loop\n+      if Container.HT.Lock > 0 then\n+         raise Program_Error;\n+      end if;\n \n-         if Is_In (Source, Tgt_Node) then\n+      X := Node.Element;\n \n-            declare\n-               X : Node_Access := Tgt_Node;\n-            begin\n-               Tgt_Node := HT_Ops.Next (Target, Tgt_Node);\n-               HT_Ops.Delete_Node_Sans_Free (Target, X);\n-               Free (X);\n-            end;\n+      Node.Element := new Element_Type'(New_Item);\n \n-         else\n+      Free_Element (X);\n+   end Replace;\n \n-            Tgt_Node := HT_Ops.Next (Target, Tgt_Node);\n+   ---------------------\n+   -- Replace_Element --\n+   ---------------------\n+\n+   procedure Replace_Element\n+     (HT      : in out Hash_Table_Type;\n+      Node    : Node_Access;\n+      Element : Element_Type)\n+   is\n+   begin\n+      if Equivalent_Elements (Node.Element.all, Element) then\n+         pragma Assert (Hash (Node.Element.all) = Hash (Element));\n \n+         if HT.Lock > 0 then\n+            raise Program_Error;\n          end if;\n \n-      end loop;\n+         declare\n+            X : Element_Access := Node.Element;\n+         begin\n+            Node.Element := new Element_Type'(Element);  --  OK if fails\n+            Free_Element (X);\n+         end;\n \n-   end Difference;\n+         return;\n+      end if;\n \n+      if HT.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n \n+      HT_Ops.Delete_Node_Sans_Free (HT, Node);\n \n-   function Difference (Left, Right : Set) return Set is\n+      Insert_New_Element : declare\n+         function New_Node (Next : Node_Access) return Node_Access;\n+         pragma Inline (New_Node);\n \n-      Buckets : HT_Types.Buckets_Access;\n-      Length  : Count_Type;\n+         procedure Insert is\n+            new Element_Keys.Generic_Conditional_Insert (New_Node);\n \n-   begin\n+         ------------------------\n+         -- Insert_New_Element --\n+         ------------------------\n \n-      if Left'Address = Right'Address then\n-         return Empty_Set;\n-      end if;\n+         function New_Node (Next : Node_Access) return Node_Access is\n+         begin\n+            Node.Element := new Element_Type'(Element);  -- OK if fails\n+            Node.Next := Next;\n+            return Node;\n+         end New_Node;\n \n-      if Left.Length = 0 then\n-         return Empty_Set;\n-      end if;\n+         Result   : Node_Access;\n+         Inserted : Boolean;\n \n-      if Right.Length = 0 then\n-         return Left;\n-      end if;\n+         X : Element_Access := Node.Element;\n+\n+      --  Start of processing for Insert_New_Element\n \n-      declare\n-         Size : constant Hash_Type := Prime_Numbers.To_Prime (Left.Length);\n       begin\n-         Buckets := new Buckets_Type (0 .. Size - 1);\n-      end;\n+         Attempt_Insert : begin\n+            Insert\n+              (HT       => HT,\n+               Key      => Element,\n+               Node     => Result,\n+               Inserted => Inserted);\n+         exception\n+            when others =>\n+               Inserted := False;  -- Assignment failed\n+         end Attempt_Insert;\n \n-      Length := 0;\n+         if Inserted then\n+            pragma Assert (Result = Node);\n+            Free_Element (X);  -- Just propagate if fails\n+            return;\n+         end if;\n+      end Insert_New_Element;\n \n+      Reinsert_Old_Element :\n       declare\n-         procedure Process (L_Node : Node_Access);\n+         function New_Node (Next : Node_Access) return Node_Access;\n+         pragma Inline (New_Node);\n \n-         procedure Process (L_Node : Node_Access) is\n-         begin\n-            if not Is_In (Right, L_Node) then\n+         procedure Insert is\n+            new Element_Keys.Generic_Conditional_Insert (New_Node);\n \n-               declare\n-                  I : constant Hash_Type :=\n-                    Hash (L_Node.Element.all) mod Buckets'Length;\n-               begin\n-                  Buckets (I) := new Node_Type'(L_Node.Element, Buckets (I));\n-               end;\n+         --------------\n+         -- New_Node --\n+         --------------\n \n-               Length := Length + 1;\n+         function New_Node (Next : Node_Access) return Node_Access is\n+         begin\n+            Node.Next := Next;\n+            return Node;\n+         end New_Node;\n \n-            end if;\n-         end Process;\n+         Result   : Node_Access;\n+         Inserted : Boolean;\n+\n+      --  Start of processing for Reinsert_Old_Element\n \n-         procedure Iterate is\n-            new HT_Ops.Generic_Iteration (Process);\n       begin\n-         Iterate (Left);\n+         Insert\n+           (HT       => HT,\n+            Key      => Node.Element.all,\n+            Node     => Result,\n+            Inserted => Inserted);\n       exception\n          when others =>\n-            HT_Ops.Free_Hash_Table (Buckets);\n-            raise;\n-      end;\n+            null;\n+      end Reinsert_Old_Element;\n \n-      return (Controlled with Buckets, Length);\n+      raise Program_Error;\n+   end Replace_Element;\n \n-   end Difference;\n+   procedure Replace_Element\n+     (Container : Set;\n+      Position  : Cursor;\n+      By        : Element_Type)\n+   is\n+      HT : Hash_Table_Type renames Container'Unrestricted_Access.all.HT;\n+\n+   begin\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n \n+      if Position.Container /= Set_Access'(Container'Unrestricted_Access) then\n+         raise Program_Error;\n+      end if;\n+\n+      Replace_Element (HT, Position.Node, By);\n+   end Replace_Element;\n+\n+   ----------------------\n+   -- Reserve_Capacity --\n+   ----------------------\n+\n+   procedure Reserve_Capacity\n+     (Container : in out Set;\n+      Capacity  : Count_Type)\n+   is\n+   begin\n+      HT_Ops.Reserve_Capacity (Container.HT, Capacity);\n+   end Reserve_Capacity;\n \n+   --------------\n+   -- Set_Next --\n+   --------------\n \n-   procedure Symmetric_Difference (Target : in out Set;\n-                                   Source : in     Set) is\n+   procedure Set_Next (Node : Node_Access; Next : Node_Access) is\n    begin\n+      Node.Next := Next;\n+   end Set_Next;\n \n+   --------------------------\n+   -- Symmetric_Difference --\n+   --------------------------\n+\n+   procedure Symmetric_Difference\n+     (Target : in out Set;\n+      Source : Set)\n+   is\n+   begin\n       if Target'Address = Source'Address then\n          Clear (Target);\n          return;\n       end if;\n \n-      HT_Ops.Ensure_Capacity (Target, Target.Length + Source.Length);\n+      if Target.HT.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n \n-      if Target.Length = 0 then\n+      declare\n+         N : constant Count_Type := Target.Length + Source.Length;\n+      begin\n+         if N > HT_Ops.Capacity (Target.HT) then\n+            HT_Ops.Reserve_Capacity (Target.HT, N);\n+         end if;\n+      end;\n \n-         declare\n+      if Target.Length = 0 then\n+         Iterate_Source_When_Empty_Target : declare\n             procedure Process (Src_Node : Node_Access);\n \n+            procedure Iterate is\n+               new HT_Ops.Generic_Iteration (Process);\n+\n+            -------------\n+            -- Process --\n+            -------------\n+\n             procedure Process (Src_Node : Node_Access) is\n                E : Element_Type renames Src_Node.Element.all;\n-               B : Buckets_Type renames Target.Buckets.all;\n-               I : constant Hash_Type := Hash (E) mod B'Length;\n-               N : Count_Type renames Target.Length;\n+               B : Buckets_Type renames Target.HT.Buckets.all;\n+               J : constant Hash_Type := Hash (E) mod B'Length;\n+               N : Count_Type renames Target.HT.Length;\n+\n             begin\n                declare\n                   X : Element_Access := new Element_Type'(E);\n                begin\n-                  B (I) := new Node_Type'(X, B (I));\n+                  B (J) := new Node_Type'(X, B (J));\n                exception\n                   when others =>\n                      Free_Element (X);\n@@ -897,29 +1233,35 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n                N := N + 1;\n             end Process;\n \n-            procedure Iterate is\n-               new HT_Ops.Generic_Iteration (Process);\n+         --  Start of processing for Iterate_Source_When_Empty_Target\n+\n          begin\n-            Iterate (Source);\n-         end;\n+            Iterate (Source.HT);\n+         end Iterate_Source_When_Empty_Target;\n \n       else\n-\n-         declare\n+         Iterate_Source : declare\n             procedure Process (Src_Node : Node_Access);\n \n+            procedure Iterate is\n+               new HT_Ops.Generic_Iteration (Process);\n+\n+            -------------\n+            -- Process --\n+            -------------\n+\n             procedure Process (Src_Node : Node_Access) is\n                E : Element_Type renames Src_Node.Element.all;\n-               B : Buckets_Type renames Target.Buckets.all;\n-               I : constant Hash_Type := Hash (E) mod B'Length;\n-               N : Count_Type renames Target.Length;\n-            begin\n-               if B (I) = null then\n+               B : Buckets_Type renames Target.HT.Buckets.all;\n+               J : constant Hash_Type := Hash (E) mod B'Length;\n+               N : Count_Type renames Target.HT.Length;\n \n+            begin\n+               if B (J) = null then\n                   declare\n                      X : Element_Access := new Element_Type'(E);\n                   begin\n-                     B (I) := new Node_Type'(X, null);\n+                     B (J) := new Node_Type'(X, null);\n                   exception\n                      when others =>\n                         Free_Element (X);\n@@ -928,24 +1270,23 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n                   N := N + 1;\n \n-               elsif Equivalent_Keys (E, B (I).Element.all) then\n-\n+               elsif Equivalent_Elements (E, B (J).Element.all) then\n                   declare\n-                     X : Node_Access := B (I);\n+                     X : Node_Access := B (J);\n                   begin\n-                     B (I) := B (I).Next;\n+                     B (J) := B (J).Next;\n                      N := N - 1;\n                      Free (X);\n                   end;\n \n                else\n-\n                   declare\n-                     Prev : Node_Access := B (I);\n+                     Prev : Node_Access := B (J);\n                      Curr : Node_Access := Prev.Next;\n+\n                   begin\n                      while Curr /= null loop\n-                        if Equivalent_Keys (E, Curr.Element.all) then\n+                        if Equivalent_Elements (E, Curr.Element.all) then\n                            Prev.Next := Curr.Next;\n                            N := N - 1;\n                            Free (Curr);\n@@ -959,7 +1300,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n                      declare\n                         X : Element_Access := new Element_Type'(E);\n                      begin\n-                        B (I) := new Node_Type'(X, B (I));\n+                        B (J) := new Node_Type'(X, B (J));\n                      exception\n                         when others =>\n                            Free_Element (X);\n@@ -968,28 +1309,22 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n                      N := N + 1;\n                   end;\n-\n                end if;\n             end Process;\n \n-            procedure Iterate is\n-               new HT_Ops.Generic_Iteration (Process);\n-         begin\n-            Iterate (Source);\n-         end;\n+         --  Start of processing for Iterate_Source\n \n+         begin\n+            Iterate (Source.HT);\n+         end Iterate_Source;\n       end if;\n-\n    end Symmetric_Difference;\n \n-\n    function Symmetric_Difference (Left, Right : Set) return Set is\n-\n       Buckets : HT_Types.Buckets_Access;\n       Length  : Count_Type;\n \n    begin\n-\n       if Left'Address = Right'Address then\n          return Empty_Set;\n       end if;\n@@ -1004,28 +1339,35 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n       declare\n          Size : constant Hash_Type :=\n-           Prime_Numbers.To_Prime (Left.Length + Right.Length);\n+                  Prime_Numbers.To_Prime (Left.Length + Right.Length);\n       begin\n          Buckets := new Buckets_Type (0 .. Size - 1);\n       end;\n \n       Length := 0;\n \n-      declare\n+      Iterate_Left : declare\n          procedure Process (L_Node : Node_Access);\n \n+         procedure Iterate is\n+            new HT_Ops.Generic_Iteration (Process);\n+\n+         -------------\n+         -- Process --\n+         -------------\n+\n          procedure Process (L_Node : Node_Access) is\n          begin\n-            if not Is_In (Right, L_Node) then\n+            if not Is_In (Right.HT, L_Node) then\n                declare\n                   E : Element_Type renames L_Node.Element.all;\n-                  I : constant Hash_Type := Hash (E) mod Buckets'Length;\n-               begin\n+                  J : constant Hash_Type := Hash (E) mod Buckets'Length;\n \n+               begin\n                   declare\n                      X : Element_Access := new Element_Type'(E);\n                   begin\n-                     Buckets (I) := new Node_Type'(X, Buckets (I));\n+                     Buckets (J) := new Node_Type'(X, Buckets (J));\n                   exception\n                      when others =>\n                         Free_Element (X);\n@@ -1037,438 +1379,435 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n             end if;\n          end Process;\n \n-         procedure Iterate is\n-            new HT_Ops.Generic_Iteration (Process);\n+      --  Start of processing for Iterate_Left\n+\n       begin\n-         Iterate (Left);\n+         Iterate (Left.HT);\n       exception\n          when others =>\n             HT_Ops.Free_Hash_Table (Buckets);\n             raise;\n-      end;\n+      end Iterate_Left;\n \n-      declare\n+      Iterate_Right : declare\n          procedure Process (R_Node : Node_Access);\n \n+         procedure Iterate is\n+            new HT_Ops.Generic_Iteration (Process);\n+\n+         -------------\n+         -- Process --\n+         -------------\n+\n          procedure Process (R_Node : Node_Access) is\n          begin\n-            if not Is_In (Left, R_Node) then\n+            if not Is_In (Left.HT, R_Node) then\n                declare\n                   E : Element_Type renames R_Node.Element.all;\n-                  I : constant Hash_Type := Hash (E) mod Buckets'Length;\n-               begin\n+                  J : constant Hash_Type := Hash (E) mod Buckets'Length;\n \n+               begin\n                   declare\n                      X : Element_Access := new Element_Type'(E);\n                   begin\n-                     Buckets (I) := new Node_Type'(X, Buckets (I));\n+                     Buckets (J) := new Node_Type'(X, Buckets (J));\n                   exception\n                      when others =>\n                         Free_Element (X);\n                         raise;\n                   end;\n \n                   Length := Length + 1;\n-\n                end;\n             end if;\n          end Process;\n \n-         procedure Iterate is\n-            new HT_Ops.Generic_Iteration (Process);\n+      --  Start of processing for Iterate_Right\n+\n       begin\n-         Iterate (Right);\n+         Iterate (Right.HT);\n       exception\n          when others =>\n             HT_Ops.Free_Hash_Table (Buckets);\n             raise;\n-      end;\n-\n-      return (Controlled with Buckets, Length);\n+      end Iterate_Right;\n \n+      return (Controlled with HT => (Buckets, Length, 0, 0));\n    end Symmetric_Difference;\n \n+   -----------\n+   -- Union --\n+   -----------\n \n-   function Is_Subset (Subset : Set;\n-                       Of_Set : Set) return Boolean is\n-\n-      Subset_Node : Node_Access;\n-\n-   begin\n-\n-      if Subset'Address = Of_Set'Address then\n-         return True;\n-      end if;\n-\n-      if Subset.Length > Of_Set.Length then\n-         return False;\n-      end if;\n-\n-      --  TODO: rewrite this to loop in the\n-      --  style of a passive iterator.\n-\n-      Subset_Node := HT_Ops.First (Subset);\n-\n-      while Subset_Node /= null loop\n-         if not Is_In (Of_Set, Subset_Node) then\n-            return False;\n-         end if;\n-\n-         Subset_Node := HT_Ops.Next (Subset, Subset_Node);\n-      end loop;\n-\n-      return True;\n-\n-   end Is_Subset;\n-\n-\n-   function Overlap (Left, Right : Set) return Boolean is\n-\n-      Left_Node : Node_Access;\n-\n-   begin\n-\n-      if Right.Length = 0 then\n-         return False;\n-      end if;\n-\n-      if Left'Address = Right'Address then\n-         return True;\n-      end if;\n-\n-      Left_Node := HT_Ops.First (Left);\n-\n-      while Left_Node /= null loop\n-         if Is_In (Right, Left_Node) then\n-            return True;\n-         end if;\n-\n-         Left_Node := HT_Ops.Next (Left, Left_Node);\n-      end loop;\n-\n-      return False;\n-\n-   end Overlap;\n-\n-\n-   function Find (Container : Set;\n-                  Item      : Element_Type) return Cursor is\n-\n-      Node : constant Node_Access := Element_Keys.Find (Container, Item);\n-\n-   begin\n+   procedure Union\n+     (Target : in out Set;\n+      Source : Set)\n+   is\n+      procedure Process (Src_Node : Node_Access);\n \n-      if Node = null then\n-         return No_Element;\n-      end if;\n+      procedure Iterate is\n+         new HT_Ops.Generic_Iteration (Process);\n \n-      return Cursor'(Container'Unchecked_Access, Node);\n+      -------------\n+      -- Process --\n+      -------------\n \n-   end Find;\n+      procedure Process (Src_Node : Node_Access) is\n+         Src : Element_Type renames Src_Node.Element.all;\n \n+         function New_Node (Next : Node_Access) return Node_Access;\n+         pragma Inline (New_Node);\n \n-   function Contains (Container : Set;\n-                      Item      : Element_Type) return Boolean is\n-   begin\n-      return Find (Container, Item) /= No_Element;\n-   end Contains;\n+         procedure Insert is\n+            new Element_Keys.Generic_Conditional_Insert (New_Node);\n \n+         --------------\n+         -- New_Node --\n+         --------------\n \n+         function New_Node (Next : Node_Access) return Node_Access is\n+            Tgt : Element_Access := new Element_Type'(Src);\n \n-   function First (Container : Set) return Cursor is\n-      Node : constant Node_Access := HT_Ops.First (Container);\n-   begin\n-      if Node = null then\n-         return No_Element;\n-      end if;\n+         begin\n+            return new Node_Type'(Tgt, Next);\n+         exception\n+            when others =>\n+               Free_Element (Tgt);\n+               raise;\n+         end New_Node;\n \n-      return Cursor'(Container'Unchecked_Access, Node);\n-   end First;\n+         Tgt_Node : Node_Access;\n+         Success  : Boolean;\n \n+      --  Start of processing for Process\n \n---     function First_Element (Container : Set) return Element_Type is\n---        Node : constant Node_Access := HT_Ops.First (Container);\n---     begin\n---        return Node.Element;\n---     end First_Element;\n+      begin\n+         Insert (Target.HT, Src, Tgt_Node, Success);\n+      end Process;\n \n+   --  Start of processing for Union\n \n-   function Next (Position : Cursor) return Cursor is\n    begin\n-      if Position.Container = null\n-        or else Position.Node = null\n-      then\n-         return No_Element;\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Target.HT.Busy > 0 then\n+         raise Program_Error;\n       end if;\n \n       declare\n-         S : Set renames Position.Container.all;\n-         Node : constant Node_Access := HT_Ops.Next (S, Position.Node);\n+         N : constant Count_Type := Target.Length + Source.Length;\n       begin\n-         if Node = null then\n-            return No_Element;\n+         if N > HT_Ops.Capacity (Target.HT) then\n+            HT_Ops.Reserve_Capacity (Target.HT, N);\n          end if;\n-\n-         return Cursor'(Position.Container, Node);\n       end;\n-   end Next;\n-\n \n-   procedure Next (Position : in out Cursor) is\n-   begin\n-      Position := Next (Position);\n-   end Next;\n+      Iterate (Source.HT);\n+   end Union;\n \n+   function Union (Left, Right : Set) return Set is\n+      Buckets : HT_Types.Buckets_Access;\n+      Length  : Count_Type;\n \n-   function Has_Element (Position : Cursor) return Boolean is\n    begin\n-      if Position.Container = null then\n-         return False;\n+      if Left'Address = Right'Address then\n+         return Left;\n       end if;\n \n-      if Position.Node = null then\n-         return False;\n+      if Right.Length = 0 then\n+         return Left;\n       end if;\n \n-      return True;\n-   end Has_Element;\n-\n+      if Left.Length = 0 then\n+         return Right;\n+      end if;\n \n-   function Equivalent_Keys (Left, Right : Cursor)\n-     return Boolean is\n-   begin\n-      return Equivalent_Keys (Left.Node.Element.all, Right.Node.Element.all);\n-   end Equivalent_Keys;\n+      declare\n+         Size : constant Hash_Type :=\n+                  Prime_Numbers.To_Prime (Left.Length + Right.Length);\n+      begin\n+         Buckets := new Buckets_Type (0 .. Size - 1);\n+      end;\n \n+      Iterate_Left : declare\n+         procedure Process (L_Node : Node_Access);\n \n-   function Equivalent_Keys (Left  : Cursor;\n-                             Right : Element_Type)\n-    return Boolean is\n-   begin\n-      return Equivalent_Keys (Left.Node.Element.all, Right);\n-   end Equivalent_Keys;\n+         procedure Iterate is\n+            new HT_Ops.Generic_Iteration (Process);\n \n+         -------------\n+         -- Process --\n+         -------------\n \n-   function Equivalent_Keys (Left  : Element_Type;\n-                             Right : Cursor)\n-    return Boolean is\n-   begin\n-      return Equivalent_Keys (Left, Right.Node.Element.all);\n-   end Equivalent_Keys;\n+         procedure Process (L_Node : Node_Access) is\n+            J : constant Hash_Type :=\n+                  Hash (L_Node.Element.all) mod Buckets'Length;\n \n+            Bucket : Node_Access renames Buckets (J);\n \n-   procedure Iterate\n-     (Container : in Set;\n-      Process   : not null access procedure (Position : in Cursor)) is\n+         begin\n+            Bucket := new Node_Type'(L_Node.Element, Bucket);\n+         end Process;\n \n-      procedure Process_Node (Node : in Node_Access);\n-      pragma Inline (Process_Node);\n+      --  Start of processing for Process\n \n-      procedure Process_Node (Node : in Node_Access) is\n       begin\n-         Process (Cursor'(Container'Unchecked_Access, Node));\n-      end Process_Node;\n-\n-      procedure Iterate is\n-         new HT_Ops.Generic_Iteration (Process_Node);\n-   begin\n-      Iterate (Container);\n-   end Iterate;\n+         Iterate (Left.HT);\n+      exception\n+         when others =>\n+            HT_Ops.Free_Hash_Table (Buckets);\n+            raise;\n+      end Iterate_Left;\n \n+      Length := Left.Length;\n \n-   function Capacity (Container : Set) return Count_Type\n-     renames HT_Ops.Capacity;\n+      Iterate_Right : declare\n+         procedure Process (Src_Node : Node_Access);\n \n-   procedure Reserve_Capacity\n-     (Container : in out Set;\n-      Capacity  : in     Count_Type)\n-     renames HT_Ops.Ensure_Capacity;\n+         procedure Iterate is\n+            new HT_Ops.Generic_Iteration (Process);\n \n+         -------------\n+         -- Process --\n+         -------------\n \n-   procedure Write_Node\n-     (Stream : access Root_Stream_Type'Class;\n-      Node   : in     Node_Access);\n-   pragma Inline (Write_Node);\n+         procedure Process (Src_Node : Node_Access) is\n+            Src : Element_Type renames Src_Node.Element.all;\n+            Idx : constant Hash_Type := Hash (Src) mod Buckets'Length;\n \n-   procedure Write_Node\n-     (Stream : access Root_Stream_Type'Class;\n-      Node   : in     Node_Access) is\n-   begin\n-      Element_Type'Output (Stream, Node.Element.all);\n-   end Write_Node;\n+            Tgt_Node : Node_Access := Buckets (Idx);\n \n-   procedure Write_Nodes is\n-      new HT_Ops.Generic_Write (Write_Node);\n+         begin\n+            while Tgt_Node /= null loop\n+               if Equivalent_Elements (Src, Tgt_Node.Element.all) then\n+                  return;\n+               end if;\n+               Tgt_Node := Next (Tgt_Node);\n+            end loop;\n \n-   procedure Write\n-     (Stream    : access Root_Stream_Type'Class;\n-      Container : in     Set) renames Write_Nodes;\n+            declare\n+               Tgt : Element_Access := new Element_Type'(Src);\n+            begin\n+               Buckets (Idx) := new Node_Type'(Tgt, Buckets (Idx));\n+            exception\n+               when others =>\n+                  Free_Element (Tgt);\n+                  raise;\n+            end;\n \n+            Length := Length + 1;\n+         end Process;\n \n-   function Read_Node (Stream : access Root_Stream_Type'Class)\n-     return Node_Access;\n-   pragma Inline (Read_Node);\n+      --  Start of processing for Iterate_Right\n \n-   function Read_Node (Stream : access Root_Stream_Type'Class)\n-     return Node_Access is\n+      begin\n+         Iterate (Right.HT);\n+      exception\n+         when others =>\n+            HT_Ops.Free_Hash_Table (Buckets);\n+            raise;\n+      end Iterate_Right;\n \n-      X : Element_Access := new Element_Type'(Element_Type'Input (Stream));\n-   begin\n-      return new Node_Type'(X, null);\n-   exception\n-      when others =>\n-         Free_Element (X);\n-         raise;\n-   end Read_Node;\n+      return (Controlled with HT => (Buckets, Length, 0, 0));\n+   end Union;\n \n-   procedure Read_Nodes is\n-      new HT_Ops.Generic_Read (Read_Node);\n+   -----------\n+   -- Write --\n+   -----------\n \n-   procedure Read\n+   procedure Write\n      (Stream    : access Root_Stream_Type'Class;\n-      Container :    out Set) renames Read_Nodes;\n+      Container : Set)\n+   is\n+   begin\n+      Write_Nodes (Stream, Container.HT);\n+   end Write;\n \n+   ----------------\n+   -- Write_Node --\n+   ----------------\n \n-   package body Generic_Keys is\n+   procedure Write_Node\n+     (Stream : access Root_Stream_Type'Class;\n+      Node   : Node_Access)\n+   is\n+   begin\n+      Element_Type'Output (Stream, Node.Element.all);\n+   end Write_Node;\n \n-      function Equivalent_Keys (Left  : Cursor;\n-                                Right : Key_Type)\n-        return Boolean is\n-      begin\n-         return Equivalent_Keys (Right, Left.Node.Element.all);\n-      end Equivalent_Keys;\n+   package body Generic_Keys is\n \n-      function Equivalent_Keys (Left  : Key_Type;\n-                                Right : Cursor)\n-        return Boolean is\n-      begin\n-         return Equivalent_Keys (Left, Right.Node.Element.all);\n-      end Equivalent_Keys;\n+      -----------------------\n+      -- Local Subprograms --\n+      -----------------------\n \n-      function Equivalent_Keys\n+      function Equivalent_Key_Node\n         (Key  : Key_Type;\n          Node : Node_Access) return Boolean;\n-      pragma Inline (Equivalent_Keys);\n+      pragma Inline (Equivalent_Key_Node);\n \n-      function Equivalent_Keys\n-        (Key  : Key_Type;\n-         Node : Node_Access) return Boolean is\n-      begin\n-         return Equivalent_Keys (Key, Node.Element.all);\n-      end Equivalent_Keys;\n+      --------------------------\n+      -- Local Instantiations --\n+      --------------------------\n \n       package Key_Keys is\n          new Hash_Tables.Generic_Keys\n           (HT_Types  => HT_Types,\n-           HT_Type   => Set,\n-           Null_Node => null,\n            Next      => Next,\n            Set_Next  => Set_Next,\n            Key_Type  => Key_Type,\n            Hash      => Hash,\n-           Equivalent_Keys => Equivalent_Keys);\n+           Equivalent_Keys => Equivalent_Key_Node);\n \n+      --------------\n+      -- Contains --\n+      --------------\n \n-      function Find (Container : Set;\n-                     Key       : Key_Type)\n-         return Cursor is\n-\n-         Node : constant Node_Access :=\n-           Key_Keys.Find (Container, Key);\n-\n+      function Contains\n+        (Container : Set;\n+         Key       : Key_Type) return Boolean\n+      is\n       begin\n+         return Find (Container, Key) /= No_Element;\n+      end Contains;\n \n-         if Node = null then\n-            return No_Element;\n-         end if;\n-\n-         return Cursor'(Container'Unchecked_Access, Node);\n-\n-      end Find;\n+      ------------\n+      -- Delete --\n+      ------------\n \n+      procedure Delete\n+        (Container : in out Set;\n+         Key       : Key_Type)\n+      is\n+         X : Node_Access;\n \n-      function Contains (Container : Set;\n-                         Key       : Key_Type) return Boolean is\n       begin\n-         return Find (Container, Key) /= No_Element;\n-      end Contains;\n+         Key_Keys.Delete_Key_Sans_Free (Container.HT, Key, X);\n+\n+         if X = null then\n+            raise Constraint_Error;\n+         end if;\n \n+         Free (X);\n+      end Delete;\n \n-      function Element (Container : Set;\n-                        Key       : Key_Type)\n-        return Element_Type is\n+      -------------\n+      -- Element --\n+      -------------\n \n-         Node : constant Node_Access := Key_Keys.Find (Container, Key);\n+      function Element\n+        (Container : Set;\n+         Key       : Key_Type) return Element_Type\n+      is\n+         Node : constant Node_Access := Key_Keys.Find (Container.HT, Key);\n       begin\n          return Node.Element.all;\n       end Element;\n \n+      -------------------------\n+      -- Equivalent_Key_Node --\n+      -------------------------\n \n-      function Key (Position : Cursor) return Key_Type is\n+      function Equivalent_Key_Node\n+        (Key  : Key_Type;\n+         Node : Node_Access) return Boolean is\n       begin\n-         return Key (Position.Node.Element.all);\n-      end Key;\n-\n-\n---  TODO:\n---        procedure Replace (Container : in out Set;\n---                           Key       : in     Key_Type;\n---                           New_Item  : in     Element_Type) is\n-\n---           Node : constant Node_Access :=\n---             Key_Keys.Find (Container, Key);\n-\n---        begin\n-\n---           if Node = null then\n---              raise Constraint_Error;\n---           end if;\n+         return Equivalent_Keys (Key, Node.Element.all);\n+      end Equivalent_Key_Node;\n \n---           Replace_Element (Container, Node, New_Item);\n+      ---------------------\n+      -- Equivalent_Keys --\n+      ---------------------\n \n---        end Replace;\n+      function Equivalent_Keys\n+        (Left  : Cursor;\n+         Right : Key_Type) return Boolean\n+      is\n+      begin\n+         return Equivalent_Keys (Right, Left.Node.Element.all);\n+      end Equivalent_Keys;\n \n+      function Equivalent_Keys\n+        (Left  : Key_Type;\n+         Right : Cursor) return Boolean\n+      is\n+      begin\n+         return Equivalent_Keys (Left, Right.Node.Element.all);\n+      end Equivalent_Keys;\n \n-      procedure Delete (Container : in out Set;\n-                        Key       : in     Key_Type) is\n+      -------------\n+      -- Exclude --\n+      -------------\n \n+      procedure Exclude\n+        (Container : in out Set;\n+         Key       : Key_Type)\n+      is\n          X : Node_Access;\n-\n       begin\n+         Key_Keys.Delete_Key_Sans_Free (Container.HT, Key, X);\n+         Free (X);\n+      end Exclude;\n \n-         Key_Keys.Delete_Key_Sans_Free (Container, Key, X);\n+      ----------\n+      -- Find --\n+      ----------\n \n-         if X = null then\n-            raise Constraint_Error;\n+      function Find\n+        (Container : Set;\n+         Key       : Key_Type) return Cursor\n+      is\n+         Node : constant Node_Access := Key_Keys.Find (Container.HT, Key);\n+\n+      begin\n+         if Node = null then\n+            return No_Element;\n          end if;\n \n-         Free (X);\n+         return Cursor'(Container'Unrestricted_Access, Node);\n+      end Find;\n \n-      end Delete;\n+      ---------\n+      -- Key --\n+      ---------\n \n+      function Key (Position : Cursor) return Key_Type is\n+      begin\n+         return Key (Position.Node.Element.all);\n+      end Key;\n \n-      procedure Exclude (Container : in out Set;\n-                         Key       : in     Key_Type) is\n+      -------------\n+      -- Replace --\n+      -------------\n \n-         X : Node_Access;\n+      procedure Replace\n+        (Container : in out Set;\n+         Key       : Key_Type;\n+         New_Item  : Element_Type)\n+      is\n+         Node : constant Node_Access :=\n+                  Key_Keys.Find (Container.HT, Key);\n \n       begin\n+         if Node = null then\n+            raise Constraint_Error;\n+         end if;\n \n-         Key_Keys.Delete_Key_Sans_Free (Container, Key, X);\n-         Free (X);\n-\n-      end Exclude;\n-\n+         Replace_Element (Container.HT, Node, New_Item);\n+      end Replace;\n \n-      procedure Checked_Update_Element\n+      procedure Update_Element_Preserving_Key\n         (Container : in out Set;\n          Position  : in     Cursor;\n          Process   : not null access\n-           procedure (Element : in out Element_Type)) is\n+           procedure (Element : in out Element_Type))\n+      is\n+         HT : Hash_Table_Type renames Container.HT;\n \n       begin\n-\n-         if Position.Container = null then\n+         if Position.Node = null then\n             raise Constraint_Error;\n          end if;\n \n@@ -1477,55 +1816,44 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          end if;\n \n          declare\n-            Old_Key : Key_Type renames Key (Position.Node.Element.all);\n-         begin\n-            Process (Position.Node.Element.all);\n-\n-            if Equivalent_Keys (Old_Key, Position.Node.Element.all) then\n-               return;\n-            end if;\n-         end;\n-\n-         declare\n-            function New_Node (Next : Node_Access) return Node_Access;\n-            pragma Inline (New_Node);\n-\n-            function New_Node (Next : Node_Access) return Node_Access is\n-            begin\n-               Position.Node.Next := Next;\n-               return Position.Node;\n-            end New_Node;\n+            E : Element_Type renames Position.Node.Element.all;\n+            K : Key_Type renames Key (E);\n \n-            procedure Insert is\n-               new Key_Keys.Generic_Conditional_Insert (New_Node);\n+            B : Natural renames HT.Busy;\n+            L : Natural renames HT.Lock;\n \n-            Result  : Node_Access;\n-            Success : Boolean;\n          begin\n-            HT_Ops.Delete_Node_Sans_Free (Container, Position.Node);\n+            B := B + 1;\n+            L := L + 1;\n \n-            Insert\n-              (HT      => Container,\n-               Key     => Key (Position.Node.Element.all),\n-               Node    => Result,\n-               Success => Success);\n+            begin\n+               Process (E);\n+            exception\n+               when others =>\n+                  L := L - 1;\n+                  B := B - 1;\n+                  raise;\n+            end;\n \n-            if not Success then\n-               declare\n-                  X : Node_Access := Position.Node;\n-               begin\n-                  Free (X);\n-               end;\n+            L := L - 1;\n+            B := B - 1;\n \n-               raise Program_Error;\n+            if Equivalent_Keys (K, E) then\n+               pragma Assert (Hash (K) = Hash (E));\n+               return;\n             end if;\n+         end;\n \n-            pragma Assert (Result = Position.Node);\n+         declare\n+            X : Node_Access := Position.Node;\n+         begin\n+            HT_Ops.Delete_Node_Sans_Free (HT, X);\n+            Free (X);\n          end;\n \n-      end Checked_Update_Element;\n+         raise Program_Error;\n+      end Update_Element_Preserving_Key;\n \n    end Generic_Keys;\n \n end Ada.Containers.Indefinite_Hashed_Sets;\n-"}, {"sha": "a145bd048a5c245e68e6d3dd2cba3b7247a6314f", "filename": "gcc/ada/a-ciorma.adb", "status": "modified", "additions": 229, "deletions": 183, "changes": 412, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-ciorma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-ciorma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorma.adb?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "patch": "@@ -2,11 +2,12 @@\n --                                                                          --\n --                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---                  ADA.CONTAINERS.INDEFINITE_ORDERED_MAPS                  --\n+--                      A D A . C O N T A I N E R S .                       --\n+--             I N D E F I N I T E _ O R D E R E D _ M A P S                --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -41,24 +42,8 @@ pragma Elaborate_All (Ada.Containers.Red_Black_Trees.Generic_Operations);\n with Ada.Containers.Red_Black_Trees.Generic_Keys;\n pragma Elaborate_All (Ada.Containers.Red_Black_Trees.Generic_Keys);\n \n-with System;  use type System.Address;\n-\n package body Ada.Containers.Indefinite_Ordered_Maps is\n \n-   use Red_Black_Trees;\n-\n-   type Key_Access is access Key_Type;\n-   type Element_Access is access Element_Type;\n-\n-   type Node_Type is limited record\n-      Parent  : Node_Access;\n-      Left    : Node_Access;\n-      Right   : Node_Access;\n-      Color   : Red_Black_Trees.Color_Type := Red;\n-      Key     : Key_Access;\n-      Element : Element_Access;\n-   end record;\n-\n    -----------------------------\n    -- Node Access Subprograms --\n    -----------------------------\n@@ -97,10 +82,6 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    function Copy_Node (Source : Node_Access) return Node_Access;\n    pragma Inline (Copy_Node);\n \n-   function Copy_Tree (Source_Root : Node_Access) return Node_Access;\n-\n-   procedure Delete_Tree (X : in out Node_Access);\n-\n    procedure Free (X : in out Node_Access);\n \n    function Is_Equal_Node_Node\n@@ -122,9 +103,13 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    --------------------------\n \n    package Tree_Operations is\n-     new Red_Black_Trees.Generic_Operations\n-       (Tree_Types => Tree_Types,\n-        Null_Node  => Node_Access'(null));\n+     new Red_Black_Trees.Generic_Operations (Tree_Types);\n+\n+   procedure Delete_Tree is\n+      new Tree_Operations.Generic_Delete_Tree (Free);\n+\n+   function Copy_Tree is\n+      new Tree_Operations.Generic_Copy_Tree (Copy_Node, Delete_Tree);\n \n    use Tree_Operations;\n \n@@ -169,10 +154,6 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    function \"=\" (Left, Right : Map) return Boolean is\n    begin\n-      if Left'Address = Right'Address then\n-         return True;\n-      end if;\n-\n       return Is_Equal (Left.Tree, Right.Tree);\n    end \"=\";\n \n@@ -199,24 +180,12 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    -- Adjust --\n    ------------\n \n-   procedure Adjust (Container : in out Map) is\n-      Tree : Tree_Type renames Container.Tree;\n-\n-      N : constant Count_Type := Tree.Length;\n-      X : constant Node_Access := Tree.Root;\n+   procedure Adjust is\n+      new Tree_Operations.Generic_Adjust (Copy_Tree);\n \n+   procedure Adjust (Container : in out Map) is\n    begin\n-      if N = 0 then\n-         pragma Assert (X = null);\n-         return;\n-      end if;\n-\n-      Tree := (Length => 0, others => null);\n-\n-      Tree.Root := Copy_Tree (X);\n-      Tree.First := Min (Tree.Root);\n-      Tree.Last := Max (Tree.Root);\n-      Tree.Length := N;\n+      Adjust (Container.Tree);\n    end Adjust;\n \n    -------------\n@@ -229,20 +198,20 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       if Node = null then\n          return No_Element;\n       else\n-         return Cursor'(Container'Unchecked_Access, Node);\n+         return Cursor'(Container'Unrestricted_Access, Node);\n       end if;\n    end Ceiling;\n \n    -----------\n    -- Clear --\n    -----------\n \n+   procedure Clear is\n+      new Tree_Operations.Generic_Clear (Delete_Tree);\n+\n    procedure Clear (Container : in out Map) is\n-      Tree : Tree_Type renames Container.Tree;\n-      Root : Node_Access := Tree.Root;\n    begin\n-      Tree := (Length => 0, others => null);\n-      Delete_Tree (Root);\n+      Clear (Container.Tree);\n    end Clear;\n \n    -----------\n@@ -268,59 +237,23 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    ---------------\n \n    function Copy_Node (Source : Node_Access) return Node_Access is\n-      Target : constant Node_Access :=\n-         new Node_Type'(Parent  => null,\n-                        Left    => null,\n-                        Right   => null,\n-                        Color   => Source.Color,\n-                        Key     => Source.Key,\n-                        Element => Source.Element);\n-   begin\n-      return Target;\n-   end Copy_Node;\n-\n-   ---------------\n-   -- Copy_Tree --\n-   ---------------\n-\n-   function Copy_Tree (Source_Root : Node_Access) return Node_Access is\n-      Target_Root : Node_Access := Copy_Node (Source_Root);\n-\n-      P, X : Node_Access;\n-\n+      K : Key_Access := new Key_Type'(Source.Key.all);\n+      E : Element_Access;\n    begin\n-      if Source_Root.Right /= null then\n-         Target_Root.Right := Copy_Tree (Source_Root.Right);\n-         Target_Root.Right.Parent := Target_Root;\n-      end if;\n-\n-      P := Target_Root;\n-      X := Source_Root.Left;\n-      while X /= null loop\n-         declare\n-            Y : Node_Access := Copy_Node (X);\n-\n-         begin\n-            P.Left := Y;\n-            Y.Parent := P;\n-\n-            if X.Right /= null then\n-               Y.Right := Copy_Tree (X.Right);\n-               Y.Right.Parent := Y;\n-            end if;\n-\n-            P := Y;\n-            X := X.Left;\n-         end;\n-      end loop;\n-\n-      return Target_Root;\n-\n+      E := new Element_Type'(Source.Element.all);\n+\n+      return new Node_Type'(Parent  => null,\n+                            Left    => null,\n+                            Right   => null,\n+                            Color   => Source.Color,\n+                            Key     => K,\n+                            Element => E);\n    exception\n       when others =>\n-         Delete_Tree (Target_Root);\n+         Free_Key (K);\n+         Free_Element (E);\n          raise;\n-   end Copy_Tree;\n+   end Copy_Node;\n \n    ------------\n    -- Delete --\n@@ -331,11 +264,11 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       Position  : in out Cursor)\n    is\n    begin\n-      if Position = No_Element then\n-         return;\n+      if Position.Node = null then\n+         raise Constraint_Error;\n       end if;\n \n-      if Position.Container /= Map_Access'(Container'Unchecked_Access) then\n+      if Position.Container /= Map_Access'(Container'Unrestricted_Access) then\n          raise Program_Error;\n       end if;\n \n@@ -361,36 +294,26 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    ------------------\n \n    procedure Delete_First (Container : in out Map) is\n-      Position : Cursor := First (Container);\n+      X : Node_Access := Container.Tree.First;\n    begin\n-      Delete (Container, Position);\n+      if X /= null then\n+         Tree_Operations.Delete_Node_Sans_Free (Container.Tree, X);\n+         Free (X);\n+      end if;\n    end Delete_First;\n \n    -----------------\n    -- Delete_Last --\n    -----------------\n \n    procedure Delete_Last (Container : in out Map) is\n-      Position : Cursor := Last (Container);\n-   begin\n-      Delete (Container, Position);\n-   end Delete_Last;\n-\n-   -----------------\n-   -- Delete_Tree --\n-   -----------------\n-\n-   procedure Delete_Tree (X : in out Node_Access) is\n-      Y : Node_Access;\n+      X : Node_Access := Container.Tree.Last;\n    begin\n-      while X /= null loop\n-         Y := X.Right;\n-         Delete_Tree (Y);\n-         Y := X.Left;\n+      if X /= null then\n+         Tree_Operations.Delete_Node_Sans_Free (Container.Tree, X);\n          Free (X);\n-         X := Y;\n-      end loop;\n-   end Delete_Tree;\n+      end if;\n+   end Delete_Last;\n \n    -------------\n    -- Element --\n@@ -431,7 +354,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       if Node = null then\n          return No_Element;\n       else\n-         return Cursor'(Container'Unchecked_Access, Node);\n+         return Cursor'(Container'Unrestricted_Access, Node);\n       end if;\n    end Find;\n \n@@ -444,7 +367,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       if Container.Tree.First = null then\n          return No_Element;\n       else\n-         return Cursor'(Container'Unchecked_Access, Container.Tree.First);\n+         return Cursor'(Container'Unrestricted_Access, Container.Tree.First);\n       end if;\n    end First;\n \n@@ -476,7 +399,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       if Node = null then\n          return No_Element;\n       else\n-         return Cursor'(Container'Unchecked_Access, Node);\n+         return Cursor'(Container'Unrestricted_Access, Node);\n       end if;\n    end Floor;\n \n@@ -488,11 +411,38 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       procedure Deallocate is\n         new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n    begin\n-      if X /= null then\n+      if X = null then\n+         return;\n+      end if;\n+\n+      begin\n          Free_Key (X.Key);\n+      exception\n+         when others =>\n+            X.Key := null;\n+\n+            begin\n+               Free_Element (X.Element);\n+            exception\n+               when others =>\n+                  X.Element := null;\n+            end;\n+\n+            Deallocate (X);\n+            raise;\n+      end;\n+\n+      begin\n          Free_Element (X.Element);\n-         Deallocate (X);\n-      end if;\n+      exception\n+         when others =>\n+            X.Element := null;\n+\n+            Deallocate (X);\n+            raise;\n+      end;\n+\n+      Deallocate (X);\n    end Free;\n \n    -----------------\n@@ -523,11 +473,22 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       Insert (Container, Key, New_Item, Position, Inserted);\n \n       if not Inserted then\n+         if Container.Tree.Lock > 0 then\n+            raise Program_Error;\n+         end if;\n+\n          K := Position.Node.Key;\n          E := Position.Node.Element;\n \n          Position.Node.Key := new Key_Type'(Key);\n-         Position.Node.Element := new Element_Type'(New_Item);\n+\n+         begin\n+            Position.Node.Element := new Element_Type'(New_Item);\n+         exception\n+            when others =>\n+               Free_Key (K);\n+               raise;\n+         end;\n \n          Free_Key (K);\n          Free_Element (E);\n@@ -571,7 +532,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n             --  On exception, deallocate key and elem\n \n-            Free (Node);\n+            Free (Node);  --  Note that Free deallocates key and elem too\n             raise;\n       end New_Node;\n \n@@ -584,7 +545,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n          Position.Node,\n          Inserted);\n \n-      Position.Container := Container'Unchecked_Access;\n+      Position.Container := Container'Unrestricted_Access;\n    end Insert;\n \n    procedure Insert\n@@ -620,7 +581,15 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    function Is_Equal_Node_Node\n      (L, R : Node_Access) return Boolean is\n    begin\n-      return L.Element.all = R.Element.all;\n+      if L.Key.all < R.Key.all then\n+         return False;\n+\n+      elsif R.Key.all < L.Key.all then\n+         return False;\n+\n+      else\n+         return L.Element.all = R.Element.all;\n+      end if;\n    end Is_Equal_Node_Node;\n \n    -------------------------\n@@ -668,13 +637,25 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n       procedure Process_Node (Node : Node_Access) is\n       begin\n-         Process (Cursor'(Container'Unchecked_Access, Node));\n+         Process (Cursor'(Container'Unrestricted_Access, Node));\n       end Process_Node;\n \n+      B : Natural renames Container.Tree'Unrestricted_Access.all.Busy;\n+\n    --  Start of processing for Iterate\n \n    begin\n-      Local_Iterate (Container.Tree);\n+      B := B + 1;\n+\n+      begin\n+         Local_Iterate (Container.Tree);\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n    end Iterate;\n \n    ---------\n@@ -695,7 +676,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       if Container.Tree.Last = null then\n          return No_Element;\n       else\n-         return Cursor'(Container'Unchecked_Access, Container.Tree.Last);\n+         return Cursor'(Container'Unrestricted_Access, Container.Tree.Last);\n       end if;\n    end Last;\n \n@@ -739,12 +720,11 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    -- Move --\n    ----------\n \n+   procedure Move is\n+      new Tree_Operations.Generic_Move (Clear);\n+\n    procedure Move (Target : in out Map; Source : in out Map) is\n    begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n       Move (Target => Target.Tree, Source => Source.Tree);\n    end Move;\n \n@@ -816,10 +796,32 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    procedure Query_Element\n      (Position : Cursor;\n-      Process  : not null access procedure (Element : Element_Type))\n+      Process  : not null access procedure (Key     : Key_Type;\n+                                            Element : Element_Type))\n    is\n+      K : Key_Type renames Position.Node.Key.all;\n+      E : Element_Type renames Position.Node.Element.all;\n+\n+      T : Tree_Type renames Position.Container.Tree;\n+\n+      B : Natural renames T.Busy;\n+      L : Natural renames T.Lock;\n+\n    begin\n-      Process (Position.Node.Key.all, Position.Node.Element.all);\n+      B := B + 1;\n+      L := L + 1;\n+\n+      begin\n+         Process (K, E);\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      L := L - 1;\n+      B := B - 1;\n    end Query_Element;\n \n    ----------\n@@ -830,43 +832,35 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n      (Stream    : access Root_Stream_Type'Class;\n       Container : out Map)\n    is\n-      N : Count_Type'Base;\n+      function Read_Node\n+        (Stream : access Root_Stream_Type'Class) return Node_Access;\n+      pragma Inline (Read_Node);\n \n-      function New_Node return Node_Access;\n-      pragma Inline (New_Node);\n+      procedure Read is\n+         new Tree_Operations.Generic_Read (Clear, Read_Node);\n \n-      procedure Local_Read is new Tree_Operations.Generic_Read (New_Node);\n+      ---------------\n+      -- Read_Node --\n+      ---------------\n \n-      --------------\n-      -- New_Node --\n-      --------------\n-\n-      function New_Node return Node_Access is\n+      function Read_Node\n+        (Stream : access Root_Stream_Type'Class) return Node_Access\n+      is\n          Node : Node_Access := new Node_Type;\n-\n       begin\n          Node.Key := new Key_Type'(Key_Type'Input (Stream));\n          Node.Element := new Element_Type'(Element_Type'Input (Stream));\n          return Node;\n-\n       exception\n          when others =>\n-\n-            --  Deallocate key and elem too on exception\n-\n-            Free (Node);\n+            Free (Node);  --  Note that Free deallocates key and elem too\n             raise;\n-      end New_Node;\n+      end Read_Node;\n \n    --  Start of processing for Read\n \n    begin\n-      Clear (Container);\n-\n-      Count_Type'Base'Read (Stream, N);\n-      pragma Assert (N >= 0);\n-\n-      Local_Read (Container.Tree, N);\n+      Read (Stream, Container.Tree);\n    end Read;\n \n    -------------\n@@ -889,11 +883,22 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n          raise Constraint_Error;\n       end if;\n \n+      if Container.Tree.Lock > 0 then\n+         raise Program_Error;\n+      end if;\n+\n       K := Node.Key;\n       E := Node.Element;\n \n       Node.Key := new Key_Type'(Key);\n-      Node.Element := new Element_Type'(New_Item);\n+\n+      begin\n+         Node.Element := new Element_Type'(New_Item);\n+      exception\n+         when others =>\n+            Free_Key (K);\n+            raise;\n+      end;\n \n       Free_Key (K);\n       Free_Element (E);\n@@ -906,6 +911,10 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    procedure Replace_Element (Position : Cursor; By : Element_Type) is\n       X : Element_Access := Position.Node.Element;\n    begin\n+      if Position.Container.Tree.Lock > 0 then\n+         raise Program_Error;\n+      end if;\n+\n       Position.Node.Element := new Element_Type'(By);\n       Free_Element (X);\n    end Replace_Element;\n@@ -930,13 +939,25 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n       procedure Process_Node (Node : Node_Access) is\n       begin\n-         Process (Cursor'(Container'Unchecked_Access, Node));\n+         Process (Cursor'(Container'Unrestricted_Access, Node));\n       end Process_Node;\n \n+      B : Natural renames Container.Tree'Unrestricted_Access.all.Busy;\n+\n    --  Start of processing for Reverse_Iterate\n \n    begin\n-      Local_Reverse_Iterate (Container.Tree);\n+      B := B + 1;\n+\n+      begin\n+         Local_Reverse_Iterate (Container.Tree);\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n    end Reverse_Iterate;\n \n    -----------\n@@ -990,10 +1011,32 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    procedure Update_Element\n      (Position : Cursor;\n-      Process  : not null access procedure (Element : in out Element_Type))\n+      Process  : not null access procedure (Key     : Key_Type;\n+                                            Element : in out Element_Type))\n    is\n+      K : Key_Type renames Position.Node.Key.all;\n+      E : Element_Type renames Position.Node.Element.all;\n+\n+      T : Tree_Type renames Position.Container.Tree;\n+\n+      B : Natural renames T.Busy;\n+      L : Natural renames T.Lock;\n+\n    begin\n-      Process (Position.Node.Key.all, Position.Node.Element.all);\n+      B := B + 1;\n+      L := L + 1;\n+\n+      begin\n+         Process (K, E);\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      L := L - 1;\n+      B := B - 1;\n    end Update_Element;\n \n    -----------\n@@ -1004,28 +1047,31 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n      (Stream    : access Root_Stream_Type'Class;\n       Container : Map)\n    is\n-      procedure Process (Node : Node_Access);\n-      pragma Inline (Process);\n-\n-      procedure Iterate is\n-        new Tree_Operations.Generic_Iteration (Process);\n-\n-      -------------\n-      -- Process --\n-      -------------\n-\n-      procedure Process (Node : Node_Access) is\n+      procedure Write_Node\n+        (Stream : access Root_Stream_Type'Class;\n+         Node   : Node_Access);\n+      pragma Inline (Write_Node);\n+\n+      procedure Write is\n+         new Tree_Operations.Generic_Write (Write_Node);\n+\n+      ----------------\n+      -- Write_Node --\n+      ----------------\n+\n+      procedure Write_Node\n+        (Stream : access Root_Stream_Type'Class;\n+         Node   : Node_Access)\n+      is\n       begin\n          Key_Type'Output (Stream, Node.Key.all);\n          Element_Type'Output (Stream, Node.Element.all);\n-      end Process;\n+      end Write_Node;\n \n    --  Start of processing for Write\n \n    begin\n-      Count_Type'Base'Write (Stream, Container.Tree.Length);\n-      Iterate (Container.Tree);\n+      Write (Stream, Container.Tree);\n    end Write;\n \n end Ada.Containers.Indefinite_Ordered_Maps;\n-"}, {"sha": "f6ae76fa33441f2ea55342420be426c1d6fa48ea", "filename": "gcc/ada/a-ciorma.ads", "status": "modified", "additions": 36, "deletions": 17, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-ciorma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-ciorma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorma.ads?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "patch": "@@ -2,11 +2,12 @@\n --                                                                          --\n --                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---                  ADA.CONTAINERS.INDEFINITE_ORDERED_MAPS                  --\n+--                      A D A . C O N T A I N E R S .                       --\n+--             I N D E F I N I T E _ O R D E R E D _ M A P S                --\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -110,10 +111,6 @@ pragma Preelaborate (Indefinite_Ordered_Maps);\n      (Container : in out Map;\n       Key       : Key_Type);\n \n-   procedure Exclude\n-     (Container : in out Map;\n-      Key       : Key_Type);\n-\n    procedure Delete\n      (Container : in out Map;\n       Position  : in out Cursor);\n@@ -122,6 +119,10 @@ pragma Preelaborate (Indefinite_Ordered_Maps);\n \n    procedure Delete_Last (Container : in out Map);\n \n+   procedure Exclude\n+     (Container : in out Map;\n+      Key       : Key_Type);\n+\n    function Contains\n      (Container : Map;\n       Key       : Key_Type) return Boolean;\n@@ -156,10 +157,10 @@ pragma Preelaborate (Indefinite_Ordered_Maps);\n \n    function Next (Position : Cursor) return Cursor;\n \n-   function Previous (Position : Cursor) return Cursor;\n-\n    procedure Next (Position : in out Cursor);\n \n+   function Previous (Position : Cursor) return Cursor;\n+\n    procedure Previous (Position : in out Cursor);\n \n    function Has_Element (Position : Cursor) return Boolean;\n@@ -189,21 +190,35 @@ private\n    type Node_Type;\n    type Node_Access is access Node_Type;\n \n-   package Tree_Types is\n-     new Red_Black_Trees.Generic_Tree_Types (Node_Access);\n+   type Key_Access is access Key_Type;\n+   type Element_Access is access Element_Type;\n \n-   use Tree_Types;\n-   use Ada.Finalization;\n+   type Node_Type is limited record\n+      Parent  : Node_Access;\n+      Left    : Node_Access;\n+      Right   : Node_Access;\n+      Color   : Red_Black_Trees.Color_Type := Red_Black_Trees.Red;\n+      Key     : Key_Access;\n+      Element : Element_Access;\n+   end record;\n \n-   type Map is new Controlled with record\n-      Tree : Tree_Type := (Length => 0, others => null);\n+   package Tree_Types is new Red_Black_Trees.Generic_Tree_Types\n+     (Node_Type,\n+      Node_Access);\n+\n+   type Map is new Ada.Finalization.Controlled with record\n+      Tree : Tree_Types.Tree_Type;\n    end record;\n \n    procedure Adjust (Container : in out Map);\n \n    procedure Finalize (Container : in out Map) renames Clear;\n \n-   type Map_Access is access constant Map;\n+   use Red_Black_Trees;\n+   use Tree_Types;\n+   use Ada.Finalization;\n+\n+   type Map_Access is access Map;\n    for Map_Access'Storage_Size use 0;\n \n    type Cursor is record\n@@ -228,7 +243,11 @@ private\n    for Map'Read use Read;\n \n    Empty_Map : constant Map :=\n-     (Controlled with Tree => (Length => 0, others => null));\n+                 (Controlled with Tree => (First  => null,\n+                                           Last   => null,\n+                                           Root   => null,\n+                                           Length => 0,\n+                                           Busy   => 0,\n+                                           Lock   => 0));\n \n end Ada.Containers.Indefinite_Ordered_Maps;\n-"}, {"sha": "c836913e9a55d32db9ad5e09a1e07649366e019c", "filename": "gcc/ada/a-ciormu.adb", "status": "modified", "additions": 387, "deletions": 430, "changes": 817, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-ciormu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-ciormu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciormu.adb?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "patch": "@@ -2,11 +2,12 @@\n --                                                                          --\n --                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---               ADA.CONTAINERS.INDEFINITE_ORDERED_MULTISETS                --\n+--                      A D A . C O N T A I N E R S .                       --\n+--         I N D E F I N I T E _ O R D E R E D _ M U L T I S E T S          --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -44,22 +45,8 @@ pragma Elaborate_All (Ada.Containers.Red_Black_Trees.Generic_Keys);\n with Ada.Containers.Red_Black_Trees.Generic_Set_Operations;\n pragma Elaborate_All (Ada.Containers.Red_Black_Trees.Generic_Set_Operations);\n \n-with System;  use type System.Address;\n-\n package body Ada.Containers.Indefinite_Ordered_Multisets is\n \n-   use Red_Black_Trees;\n-\n-   type Element_Access is access Element_Type;\n-\n-   type Node_Type is limited record\n-      Parent  : Node_Access;\n-      Left    : Node_Access;\n-      Right   : Node_Access;\n-      Color   : Red_Black_Trees.Color_Type := Red;\n-      Element : Element_Access;\n-   end record;\n-\n    -----------------------------\n    -- Node Access Subprograms --\n    -----------------------------\n@@ -98,10 +85,6 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n    function Copy_Node (Source : Node_Access) return Node_Access;\n    pragma Inline (Copy_Node);\n \n-   function Copy_Tree (Source_Root : Node_Access) return Node_Access;\n-\n-   procedure Delete_Tree (X : in out Node_Access);\n-\n    procedure Free (X : in out Node_Access);\n \n    procedure Insert_With_Hint\n@@ -126,14 +109,23 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n    function Is_Less_Node_Node (L, R : Node_Access) return Boolean;\n    pragma Inline (Is_Less_Node_Node);\n \n+   procedure Replace_Element\n+     (Tree : in out Tree_Type;\n+      Node : Node_Access;\n+      Item : Element_Type);\n+\n    --------------------------\n    -- Local Instantiations --\n    --------------------------\n \n    package Tree_Operations is\n-     new Red_Black_Trees.Generic_Operations\n-       (Tree_Types => Tree_Types,\n-        Null_Node  => Node_Access'(null));\n+     new Red_Black_Trees.Generic_Operations (Tree_Types);\n+\n+   procedure Delete_Tree is\n+     new Tree_Operations.Generic_Delete_Tree (Free);\n+\n+   function Copy_Tree is\n+     new Tree_Operations.Generic_Copy_Tree (Copy_Node, Delete_Tree);\n \n    use Tree_Operations;\n \n@@ -182,11 +174,8 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n    -- \"=\" --\n    ---------\n \n-   function \"=\" (Left, Right : Set) return Boolean is begin\n-      if Left'Address = Right'Address then\n-         return True;\n-      end if;\n-\n+   function \"=\" (Left, Right : Set) return Boolean is\n+   begin\n       return Is_Equal (Left.Tree, Right.Tree);\n    end \"=\";\n \n@@ -215,24 +204,12 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n    -- Adjust --\n    ------------\n \n-   procedure Adjust (Container : in out Set) is\n-      Tree : Tree_Type renames Container.Tree;\n-\n-      N : constant Count_Type := Tree.Length;\n-      X : constant Node_Access := Tree.Root;\n+   procedure Adjust is\n+      new Tree_Operations.Generic_Adjust (Copy_Tree);\n \n+   procedure Adjust (Container : in out Set) is\n    begin\n-      if N = 0 then\n-         pragma Assert (X = null);\n-         return;\n-      end if;\n-\n-      Tree := (Length => 0, others => null);\n-\n-      Tree.Root := Copy_Tree (X);\n-      Tree.First := Min (Tree.Root);\n-      Tree.Last := Max (Tree.Root);\n-      Tree.Length := N;\n+      Adjust (Container.Tree);\n    end Adjust;\n \n    -------------\n@@ -248,19 +225,19 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n          return No_Element;\n       end if;\n \n-      return Cursor'(Container'Unchecked_Access, Node);\n+      return Cursor'(Container'Unrestricted_Access, Node);\n    end Ceiling;\n \n    -----------\n    -- Clear --\n    -----------\n \n+   procedure Clear is\n+      new Tree_Operations.Generic_Clear (Delete_Tree);\n+\n    procedure Clear (Container : in out Set) is\n-      Tree : Tree_Type renames Container.Tree;\n-      Root : Node_Access := Tree.Root;\n    begin\n-      Tree := (Length => 0, others => null);\n-      Delete_Tree (Root);\n+      Clear (Container.Tree);\n    end Clear;\n \n    -----------\n@@ -301,49 +278,6 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n          raise;\n    end Copy_Node;\n \n-   ---------------\n-   -- Copy_Tree --\n-   ---------------\n-\n-   function Copy_Tree (Source_Root : Node_Access) return Node_Access is\n-      Target_Root : Node_Access := Copy_Node (Source_Root);\n-\n-      P, X : Node_Access;\n-\n-   begin\n-      if Source_Root.Right /= null then\n-         Target_Root.Right := Copy_Tree (Source_Root.Right);\n-         Target_Root.Right.Parent := Target_Root;\n-      end if;\n-\n-      P := Target_Root;\n-      X := Source_Root.Left;\n-      while X /= null loop\n-         declare\n-            Y : Node_Access := Copy_Node (X);\n-\n-         begin\n-            P.Left := Y;\n-            Y.Parent := P;\n-\n-            if X.Right /= null then\n-               Y.Right := Copy_Tree (X.Right);\n-               Y.Right.Parent := Y;\n-            end if;\n-\n-            P := Y;\n-            X := X.Left;\n-         end;\n-      end loop;\n-\n-      return Target_Root;\n-\n-   exception\n-      when others =>\n-         Delete_Tree (Target_Root);\n-         raise;\n-   end Copy_Tree;\n-\n    ------------\n    -- Delete --\n    ------------\n@@ -371,15 +305,15 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n \n    procedure Delete (Container : in out Set; Position : in out Cursor) is\n    begin\n-      if Position = No_Element then\n-         return;\n+      if Position.Node = null then\n+         raise Constraint_Error;\n       end if;\n \n-      if Position.Container /= Set_Access'(Container'Unchecked_Access) then\n+      if Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error;\n       end if;\n \n-      Delete_Node_Sans_Free (Container.Tree, Position.Node);\n+      Tree_Operations.Delete_Node_Sans_Free (Container.Tree, Position.Node);\n       Free (Position.Node);\n \n       Position.Container := null;\n@@ -419,48 +353,20 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n       Free (X);\n    end Delete_Last;\n \n-   -----------------\n-   -- Delete_Tree --\n-   -----------------\n-\n-   procedure Delete_Tree (X : in out Node_Access) is\n-      Y : Node_Access;\n-   begin\n-      while X /= null loop\n-         Y := X.Right;\n-         Delete_Tree (Y);\n-         Y := X.Left;\n-         Free (X);\n-         X := Y;\n-      end loop;\n-   end Delete_Tree;\n-\n    ----------------\n    -- Difference --\n    ----------------\n \n    procedure Difference (Target : in out Set; Source : Set) is\n    begin\n-      if Target'Address = Source'Address then\n-         Clear (Target);\n-         return;\n-      end if;\n-\n       Set_Ops.Difference (Target.Tree, Source.Tree);\n    end Difference;\n \n    function Difference (Left, Right : Set) return Set is\n+      Tree : constant Tree_Type :=\n+               Set_Ops.Difference (Left.Tree, Right.Tree);\n    begin\n-      if Left'Address = Right'Address then\n-         return Empty_Set;\n-      end if;\n-\n-      declare\n-         Tree : constant Tree_Type :=\n-                  Set_Ops.Difference (Left.Tree, Right.Tree);\n-      begin\n-         return (Controlled with Tree);\n-      end;\n+      return Set'(Controlled with Tree);\n    end Difference;\n \n    -------------\n@@ -472,6 +378,39 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n       return Position.Node.Element.all;\n    end Element;\n \n+   ---------------------\n+   -- Equivalent_Sets --\n+   ---------------------\n+\n+   function Equivalent_Sets (Left, Right : Set) return Boolean is\n+\n+      function Is_Equivalent_Node_Node (L, R : Node_Access) return Boolean;\n+      pragma Inline (Is_Equivalent_Node_Node);\n+\n+      function Is_Equivalent is\n+         new Tree_Operations.Generic_Equal (Is_Equivalent_Node_Node);\n+\n+      -----------------------------\n+      -- Is_Equivalent_Node_Node --\n+      -----------------------------\n+\n+      function Is_Equivalent_Node_Node (L, R : Node_Access) return Boolean is\n+      begin\n+         if L.Element.all < R.Element.all then\n+            return False;\n+         elsif R.Element.all < L.Element.all then\n+            return False;\n+         else\n+            return True;\n+         end if;\n+      end Is_Equivalent_Node_Node;\n+\n+   --  Start of processing for Equivalent_Sets\n+\n+   begin\n+      return Is_Equivalent (Left.Tree, Right.Tree);\n+   end Equivalent_Sets;\n+\n    -------------\n    -- Exclude --\n    -------------\n@@ -503,7 +442,7 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n          return No_Element;\n       end if;\n \n-      return Cursor'(Container'Unchecked_Access, Node);\n+      return Cursor'(Container'Unrestricted_Access, Node);\n    end Find;\n \n    -----------\n@@ -516,7 +455,7 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n          return No_Element;\n       end if;\n \n-      return Cursor'(Container'Unchecked_Access, Container.Tree.First);\n+      return Cursor'(Container'Unrestricted_Access, Container.Tree.First);\n    end First;\n \n    -------------------\n@@ -541,7 +480,7 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n          return No_Element;\n       end if;\n \n-      return Cursor'(Container'Unchecked_Access, Node);\n+      return Cursor'(Container'Unrestricted_Access, Node);\n    end Floor;\n \n    ----------\n@@ -552,10 +491,20 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n       procedure Deallocate is\n         new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n    begin\n-      if X /= null then\n-         Free_Element (X.Element);\n-         Deallocate (X);\n+      if X = null then\n+         return;\n       end if;\n+\n+      begin\n+         Free_Element (X.Element);\n+      exception\n+         when others =>\n+            X.Element := null;\n+            Deallocate (X);\n+            raise;\n+      end;\n+\n+      Deallocate (X);\n    end Free;\n \n    ------------------\n@@ -630,77 +579,9 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n             return No_Element;\n          end if;\n \n-         return Cursor'(Container'Unchecked_Access, Node);\n+         return Cursor'(Container'Unrestricted_Access, Node);\n       end Ceiling;\n \n-      ----------------------------\n-      -- Checked_Update_Element --\n-      ----------------------------\n-\n-      procedure Checked_Update_Element\n-        (Container : in out Set;\n-         Position  : Cursor;\n-         Process   : not null access procedure (Element : in out Element_Type))\n-      is\n-      begin\n-         if Position.Container = null then\n-            raise Constraint_Error;\n-         end if;\n-\n-         if Position.Container /= Set_Access'(Container'Unchecked_Access) then\n-            raise Program_Error;\n-         end if;\n-\n-         declare\n-            Old_Key : Key_Type renames Key (Position.Node.Element.all);\n-\n-         begin\n-            Process (Position.Node.Element.all);\n-\n-            if Old_Key < Position.Node.Element.all\n-              or else Old_Key > Position.Node.Element.all\n-            then\n-               null;\n-            else\n-               return;\n-            end if;\n-         end;\n-\n-         Delete_Node_Sans_Free (Container.Tree, Position.Node);\n-\n-         Do_Insert : declare\n-            Result : Node_Access;\n-\n-            function New_Node return Node_Access;\n-            pragma Inline (New_Node);\n-\n-            procedure Insert_Post is\n-              new Key_Keys.Generic_Insert_Post (New_Node);\n-\n-            procedure Insert is\n-              new Key_Keys.Generic_Unconditional_Insert (Insert_Post);\n-\n-            --------------\n-            -- New_Node --\n-            --------------\n-\n-            function New_Node return Node_Access is\n-            begin\n-               return Position.Node;\n-            end New_Node;\n-\n-         --  Start of processing for Do_Insert\n-\n-         begin\n-            Insert\n-              (Tree    => Container.Tree,\n-               Key     => Key (Position.Node.Element.all),\n-               Node    => Result);\n-\n-            pragma Assert (Result = Position.Node);\n-         end Do_Insert;\n-      end Checked_Update_Element;\n-\n       --------------\n       -- Contains --\n       --------------\n@@ -776,7 +657,7 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n             return No_Element;\n          end if;\n \n-         return Cursor'(Container'Unchecked_Access, Node);\n+         return Cursor'(Container'Unrestricted_Access, Node);\n       end Find;\n \n       -----------\n@@ -791,7 +672,7 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n             return No_Element;\n          end if;\n \n-         return Cursor'(Container'Unchecked_Access, Node);\n+         return Cursor'(Container'Unrestricted_Access, Node);\n       end Floor;\n \n       -------------------------\n@@ -837,13 +718,26 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n \n          procedure Process_Node (Node : Node_Access) is\n          begin\n-            Process (Cursor'(Container'Unchecked_Access, Node));\n+            Process (Cursor'(Container'Unrestricted_Access, Node));\n          end Process_Node;\n \n+         T : Tree_Type renames Container.Tree'Unrestricted_Access.all;\n+         B : Natural renames T.Busy;\n+\n       --  Start of processing for Iterate\n \n       begin\n-         Local_Iterate (Container.Tree, Key);\n+         B := B + 1;\n+\n+         begin\n+            Local_Iterate (T, Key);\n+         exception\n+            when others =>\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         B := B - 1;\n       end Iterate;\n \n       ---------\n@@ -855,27 +749,6 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n          return Key (Position.Node.Element.all);\n       end Key;\n \n-      -------------\n-      -- Replace --\n-      -------------\n-\n-      --  In post-madision api: ???\n-\n---     procedure Replace\n---       (Container : in out Set;\n---        Key       : Key_Type;\n---        New_Item  : Element_Type)\n---     is\n---           Node : Node_Access := Key_Keys.Find (Container.Tree, Key);\n-\n---        begin\n---           if Node = null then\n---              raise Constraint_Error;\n---           end if;\n-\n---           Replace_Node (Container, Node, New_Item);\n---        end Replace;\n-\n       ---------------------\n       -- Reverse_Iterate --\n       ---------------------\n@@ -901,15 +774,90 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n \n          procedure Process_Node (Node : Node_Access) is\n          begin\n-            Process (Cursor'(Container'Unchecked_Access, Node));\n+            Process (Cursor'(Container'Unrestricted_Access, Node));\n          end Process_Node;\n \n+         T : Tree_Type renames Container.Tree'Unrestricted_Access.all;\n+         B : Natural renames T.Busy;\n+\n       --  Start of processing for Reverse_Iterate\n \n       begin\n-         Local_Reverse_Iterate (Container.Tree, Key);\n+         B := B + 1;\n+\n+         begin\n+            Local_Reverse_Iterate (T, Key);\n+         exception\n+            when others =>\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         B := B - 1;\n       end Reverse_Iterate;\n \n+      -----------------------------------\n+      -- Update_Element_Preserving_Key --\n+      -----------------------------------\n+\n+      procedure Update_Element_Preserving_Key\n+        (Container : in out Set;\n+         Position  : Cursor;\n+         Process   : not null access procedure (Element : in out Element_Type))\n+      is\n+         Tree : Tree_Type renames Container.Tree;\n+\n+      begin\n+         if Position.Node = null then\n+            raise Constraint_Error;\n+         end if;\n+\n+         if Position.Container /= Container'Unrestricted_Access then\n+            raise Program_Error;\n+         end if;\n+\n+         declare\n+            E : Element_Type renames Position.Node.Element.all;\n+            K : Key_Type renames Key (E);\n+\n+            B : Natural renames Tree.Busy;\n+            L : Natural renames Tree.Lock;\n+\n+         begin\n+            B := B + 1;\n+            L := L + 1;\n+\n+            begin\n+               Process (E);\n+            exception\n+               when others =>\n+                  L := L - 1;\n+                  B := B - 1;\n+                  raise;\n+            end;\n+\n+            L := L - 1;\n+            B := B - 1;\n+\n+            if K < E\n+              or else K > E\n+            then\n+               null;\n+            else\n+               return;\n+            end if;\n+         end;\n+\n+         declare\n+            X : Node_Access := Position.Node;\n+         begin\n+            Tree_Operations.Delete_Node_Sans_Free (Tree, X);\n+            Free (X);\n+         end;\n+\n+         raise Program_Error;\n+      end Update_Element_Preserving_Key;\n+\n    end Generic_Keys;\n \n    -----------------\n@@ -973,7 +921,7 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n          New_Item,\n          Position.Node);\n \n-      Position.Container := Container'Unchecked_Access;\n+      Position.Container := Container'Unrestricted_Access;\n    end Insert;\n \n    ----------------------\n@@ -1036,25 +984,14 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n \n    procedure Intersection (Target : in out Set; Source : Set) is\n    begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n       Set_Ops.Intersection (Target.Tree, Source.Tree);\n    end Intersection;\n \n    function Intersection (Left, Right : Set) return Set is\n+      Tree : constant Tree_Type :=\n+               Set_Ops.Intersection (Left.Tree, Right.Tree);\n    begin\n-      if Left'Address = Right'Address then\n-         return Left;\n-      end if;\n-\n-      declare\n-         Tree : constant Tree_Type :=\n-                  Set_Ops.Intersection (Left.Tree, Right.Tree);\n-      begin\n-         return (Controlled with Tree);\n-      end;\n+      return Set'(Controlled with Tree);\n    end Intersection;\n \n    --------------\n@@ -1116,10 +1053,6 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n \n    function Is_Subset (Subset : Set; Of_Set : Set) return Boolean is\n    begin\n-      if Subset'Address = Of_Set'Address then\n-         return True;\n-      end if;\n-\n       return Set_Ops.Is_Subset (Subset => Subset.Tree, Of_Set => Of_Set.Tree);\n    end Is_Subset;\n \n@@ -1144,13 +1077,26 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n \n       procedure Process_Node (Node : Node_Access) is\n       begin\n-         Process (Cursor'(Container'Unchecked_Access, Node));\n+         Process (Cursor'(Container'Unrestricted_Access, Node));\n       end Process_Node;\n \n+      T : Tree_Type renames Container.Tree'Unrestricted_Access.all;\n+      B : Natural renames T.Busy;\n+\n    --  Start of processing for Iterate\n \n    begin\n-      Local_Iterate (Container.Tree, Item);\n+      B := B + 1;\n+\n+      begin\n+         Local_Iterate (T, Item);\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n    end Iterate;\n \n    procedure Iterate\n@@ -1169,13 +1115,26 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n \n       procedure Process_Node (Node : Node_Access) is\n       begin\n-         Process (Cursor'(Container'Unchecked_Access, Node));\n+         Process (Cursor'(Container'Unrestricted_Access, Node));\n       end Process_Node;\n \n+      T : Tree_Type renames Container.Tree'Unrestricted_Access.all;\n+      B : Natural renames T.Busy;\n+\n    --  Start of processing for Iterate\n \n    begin\n-      Local_Iterate (Container.Tree);\n+      B := B + 1;\n+\n+      begin\n+         Local_Iterate (T);\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n    end Iterate;\n \n    ----------\n@@ -1188,7 +1147,7 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n          return No_Element;\n       end if;\n \n-      return Cursor'(Container'Unchecked_Access, Container.Tree.Last);\n+      return Cursor'(Container'Unrestricted_Access, Container.Tree.Last);\n    end Last;\n \n    ------------------\n@@ -1222,12 +1181,11 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n    -- Move --\n    ----------\n \n+   procedure Move is\n+      new Tree_Operations.Generic_Move (Clear);\n+\n    procedure Move (Target : in out Set; Source : in out Set) is\n    begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n       Move (Target => Target.Tree, Source => Source.Tree);\n    end Move;\n \n@@ -1265,10 +1223,6 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n \n    function Overlap (Left, Right : Set) return Boolean is\n    begin\n-      if Left'Address = Right'Address then\n-         return Left.Tree.Length /= 0;\n-      end if;\n-\n       return Set_Ops.Overlap (Left.Tree, Right.Tree);\n    end Overlap;\n \n@@ -1317,8 +1271,29 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type))\n    is\n+      E : Element_Type renames Position.Node.Element.all;\n+\n+      S : Set renames Position.Container.all;\n+      T : Tree_Type renames S.Tree'Unrestricted_Access.all;\n+\n+      B : Natural renames T.Busy;\n+      L : Natural renames T.Lock;\n+\n    begin\n-      Process (Position.Node.Element.all);\n+      B := B + 1;\n+      L := L + 1;\n+\n+      begin\n+         Process (E);\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      L := L - 1;\n+      B := B - 1;\n    end Query_Element;\n \n    ----------\n@@ -1329,150 +1304,122 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n      (Stream    : access Root_Stream_Type'Class;\n       Container : out Set)\n    is\n-      N : Count_Type'Base;\n+      function Read_Node\n+        (Stream : access Root_Stream_Type'Class) return Node_Access;\n+      pragma Inline (Read_Node);\n \n-      function New_Node return Node_Access;\n-      pragma Inline (New_Node);\n+      procedure Read is\n+         new Tree_Operations.Generic_Read (Clear, Read_Node);\n \n-      procedure Local_Read is new Tree_Operations.Generic_Read (New_Node);\n+      ---------------\n+      -- Read_Node --\n+      ---------------\n \n-      --------------\n-      -- New_Node --\n-      --------------\n-\n-      function New_Node return Node_Access is\n+      function Read_Node\n+        (Stream : access Root_Stream_Type'Class) return Node_Access\n+      is\n          Node : Node_Access := new Node_Type;\n-\n       begin\n-         begin\n-            Node.Element := new Element_Type'(Element_Type'Input (Stream));\n-         exception\n-            when others =>\n-               Free (Node);\n-               raise;\n-         end;\n-\n+         Node.Element := new Element_Type'(Element_Type'Input (Stream));\n          return Node;\n-      end New_Node;\n+      exception\n+         when others =>\n+            Free (Node);  --  Note that Free deallocates elem too\n+            raise;\n+      end Read_Node;\n \n    --  Start of processing for Read\n \n    begin\n-      Clear (Container);\n+      Read (Stream, Container.Tree);\n+   end Read;\n \n-      Count_Type'Base'Read (Stream, N);\n-      pragma Assert (N >= 0);\n+   ---------------------\n+   -- Replace_Element --\n+   ---------------------\n \n-      Local_Read (Container.Tree, N);\n-   end Read;\n+   procedure Replace_Element\n+     (Tree : in out Tree_Type;\n+      Node : Node_Access;\n+      Item : Element_Type)\n+   is\n+   begin\n+      if Item < Node.Element.all\n+        or else Node.Element.all < Item\n+      then\n+         null;\n+      else\n+         if Tree.Lock > 0 then\n+            raise Program_Error;\n+         end if;\n \n-   -------------\n-   -- Replace --\n-   -------------\n+         declare\n+            X : Element_Access := Node.Element;\n+         begin\n+            Node.Element := new Element_Type'(Item);\n+            Free_Element (X);\n+         end;\n \n-   --  NOTE: from post-madison api???\n+         return;\n+      end if;\n \n---   procedure Replace\n---     (Container : in out Set;\n---      Position  : Cursor;\n---      By        : Element_Type)\n---   is\n---   begin\n---      if Position.Container = null then\n---         raise Constraint_Error;\n---      end if;\n+      Tree_Operations.Delete_Node_Sans_Free (Tree, Node);  -- Checks busy-bit\n \n---      if Position.Container /= Set_Access'(Container'Unchecked_Access) then\n---         raise Program_Error;\n---      end if;\n+      Insert_New_Item : declare\n+         function New_Node return Node_Access;\n+         pragma Inline (New_Node);\n \n---      Replace_Node (Container, Position.Node, By);\n---   end Replace;\n+         procedure Insert_Post is\n+            new Element_Keys.Generic_Insert_Post (New_Node);\n \n-   ------------------\n-   -- Replace_Node --\n-   ------------------\n+         procedure Unconditional_Insert is\n+            new Element_Keys.Generic_Unconditional_Insert (Insert_Post);\n+\n+         --------------\n+         -- New_Node --\n+         --------------\n+\n+         function New_Node return Node_Access is\n+         begin\n+            Node.Element := new Element_Type'(Item);  -- OK if fails\n+            return Node;\n+         end New_Node;\n+\n+         Result : Node_Access;\n+\n+         X : Element_Access := Node.Element;\n \n-   --  NOTE: from post-madison api???\n-\n---   procedure Replace_Node\n---     (Container : in out Set;\n---      Position  : Node_Access;\n---      By        : Element_Type);\n---   is\n---      Tree : Tree_Type renames Container.Tree;\n---      Node : Node_Access := Position;\n-\n---   begin\n---      if By < Node.Element\n---        or else Node.Element < By\n---      then\n---         null;\n-\n---      else\n---         begin\n---            Node.Element := By;\n-\n---         exception\n---            when others =>\n---               Tree_Operations.Delete_Node_Sans_Free (Tree, Node);\n---               Free (Node);\n---               raise;\n---         end;\n-\n---         return;\n---      end if;\n-\n---      Tree_Operations.Delete_Node_Sans_Free (Tree, Node);\n-\n---      begin\n---         Node.Element := By;\n-\n---      exception\n---         when others =>\n---            Free (Node);\n---            raise;\n---      end;\n-\n---      declare\n---         Result  : Node_Access;\n---         Success : Boolean;\n-\n---         function New_Node return Node_Access;\n---         pragma Inline (New_Node);\n-\n---         procedure Insert_Post is\n---           new Element_Keys.Generic_Insert_Post (New_Node);\n-\n---         procedure Insert is\n---           new Element_Keys.Generic_Conditional_Insert (Insert_Post);\n-\n---         --------------\n---         -- New_Node --\n---         --------------\n---\n---         function New_Node return Node_Access is\n---         begin\n---            return Node;\n---         end New_Node;\n-\n---      --  Start of processing for Replace_Node\n-\n---      begin\n---         Insert\n---           (Tree    => Tree,\n---            Key     => Node.Element,\n---            Node    => Result,\n---            Success => Success);\n-\n---         if not Success then\n---            Free (Node);\n---            raise Program_Error;\n---         end if;\n-\n---         pragma Assert (Result = Node);\n---      end;\n---   end Replace_Node;\n+      --  Start of processing for Insert_New_Item\n+\n+      begin\n+         Unconditional_Insert\n+           (Tree => Tree,\n+            Key  => Item,\n+            Node => Result);\n+         pragma Assert (Result = Node);\n+\n+         Free_Element (X);  -- OK if fails\n+      end Insert_New_Item;\n+   end Replace_Element;\n+\n+   procedure Replace_Element\n+    (Container : Set;\n+     Position  : Cursor;\n+     By        : Element_Type)\n+   is\n+      Tree : Tree_Type renames Position.Container.Tree'Unrestricted_Access.all;\n+\n+   begin\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error;\n+      end if;\n+\n+      Replace_Element (Tree, Position.Node, By);\n+   end Replace_Element;\n \n    ---------------------\n    -- Reverse_Iterate --\n@@ -1495,13 +1442,26 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n \n       procedure Process_Node (Node : Node_Access) is\n       begin\n-         Process (Cursor'(Container'Unchecked_Access, Node));\n+         Process (Cursor'(Container'Unrestricted_Access, Node));\n       end Process_Node;\n \n+      T : Tree_Type renames Container.Tree'Unrestricted_Access.all;\n+      B : Natural renames T.Busy;\n+\n    --  Start of processing for Reverse_Iterate\n \n    begin\n-      Local_Reverse_Iterate (Container.Tree, Item);\n+      B := B + 1;\n+\n+      begin\n+         Local_Reverse_Iterate (T, Item);\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n    end Reverse_Iterate;\n \n    procedure Reverse_Iterate\n@@ -1520,13 +1480,26 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n \n       procedure Process_Node (Node : Node_Access) is\n       begin\n-         Process (Cursor'(Container'Unchecked_Access, Node));\n+         Process (Cursor'(Container'Unrestricted_Access, Node));\n       end Process_Node;\n \n+      T : Tree_Type renames Container.Tree'Unrestricted_Access.all;\n+      B : Natural renames T.Busy;\n+\n    --  Start of processing for Reverse_Iterate\n \n    begin\n-      Local_Reverse_Iterate (Container.Tree);\n+      B := B + 1;\n+\n+      begin\n+         Local_Reverse_Iterate (T);\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n    end Reverse_Iterate;\n \n    -----------\n@@ -1580,26 +1553,14 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n \n    procedure Symmetric_Difference (Target : in out Set; Source : Set) is\n    begin\n-      if Target'Address = Source'Address then\n-         Clear (Target);\n-         return;\n-      end if;\n-\n       Set_Ops.Symmetric_Difference (Target.Tree, Source.Tree);\n    end Symmetric_Difference;\n \n    function Symmetric_Difference (Left, Right : Set) return Set is\n+      Tree : constant Tree_Type :=\n+               Set_Ops.Symmetric_Difference (Left.Tree, Right.Tree);\n    begin\n-      if Left'Address = Right'Address then\n-         return Empty_Set;\n-      end if;\n-\n-      declare\n-         Tree : constant Tree_Type :=\n-                  Set_Ops.Symmetric_Difference (Left.Tree, Right.Tree);\n-      begin\n-         return (Controlled with Tree);\n-      end;\n+      return Set'(Controlled with Tree);\n    end Symmetric_Difference;\n \n    -----------\n@@ -1608,23 +1569,14 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n \n    procedure Union (Target : in out Set; Source : Set) is\n    begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n       Set_Ops.Union (Target.Tree, Source.Tree);\n    end Union;\n \n-   function Union (Left, Right : Set) return Set is begin\n-      if Left'Address = Right'Address then\n-         return Left;\n-      end if;\n-\n-      declare\n-         Tree : constant Tree_Type := Set_Ops.Union (Left.Tree, Right.Tree);\n-      begin\n-         return (Controlled with Tree);\n-      end;\n+   function Union (Left, Right : Set) return Set is\n+      Tree : constant Tree_Type :=\n+               Set_Ops.Union (Left.Tree, Right.Tree);\n+   begin\n+      return Set'(Controlled with Tree);\n    end Union;\n \n    -----------\n@@ -1635,25 +1587,30 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n      (Stream    : access Root_Stream_Type'Class;\n       Container : Set)\n    is\n-      procedure Process (Node : Node_Access);\n-      pragma Inline (Process);\n+      procedure Write_Node\n+        (Stream : access Root_Stream_Type'Class;\n+         Node   : Node_Access);\n+      pragma Inline (Write_Node);\n \n-      procedure Iterate is new Tree_Operations.Generic_Iteration (Process);\n+      procedure Write is\n+         new Tree_Operations.Generic_Write (Write_Node);\n \n-      -------------\n-      -- Process --\n-      -------------\n+      ----------------\n+      -- Write_Node --\n+      ----------------\n \n-      procedure Process (Node : Node_Access) is\n+      procedure Write_Node\n+        (Stream : access Root_Stream_Type'Class;\n+         Node   : Node_Access)\n+      is\n       begin\n          Element_Type'Output (Stream, Node.Element.all);\n-      end Process;\n+      end Write_Node;\n \n    --  Start of processing for Write\n \n    begin\n-      Count_Type'Base'Write (Stream, Container.Tree.Length);\n-      Iterate (Container.Tree);\n+      Write (Stream, Container.Tree);\n    end Write;\n \n end Ada.Containers.Indefinite_Ordered_Multisets;"}, {"sha": "4bf4857e26c1feceaf89649f0cd98edc3f86140f", "filename": "gcc/ada/a-ciormu.ads", "status": "modified", "additions": 39, "deletions": 29, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-ciormu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-ciormu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciormu.ads?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "patch": "@@ -2,11 +2,12 @@\n --                                                                          --\n --                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---               ADA.CONTAINERS.INDEFINITE_ORDERED_MULTISETS                --\n+--                      A D A . C O N T A I N E R S .                       --\n+--         I N D E F I N I T E _ O R D E R E D _ M U L T I S E T S          --\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -56,6 +57,8 @@ pragma Preelaborate (Indefinite_Ordered_Multisets);\n \n    function \"=\" (Left, Right : Set) return Boolean;\n \n+   function Equivalent_Sets (Left, Right : Set) return Boolean;\n+\n    function Length (Container : Set) return Count_Type;\n \n    function Is_Empty (Container : Set) return Boolean;\n@@ -68,6 +71,11 @@ pragma Preelaborate (Indefinite_Ordered_Multisets);\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type));\n \n+   procedure Replace_Element\n+     (Container : Set;\n+      Position  : Cursor;\n+      By        : Element_Type);\n+\n    procedure Move (Target : in out Set; Source : in out Set);\n \n    procedure Insert\n@@ -79,22 +87,13 @@ pragma Preelaborate (Indefinite_Ordered_Multisets);\n \n    procedure Delete (Container : in out Set; Item : Element_Type);\n \n-   procedure Exclude (Container : in out Set; Item : Element_Type);\n-\n    procedure Delete (Container : in out Set; Position : in out Cursor);\n \n    procedure Delete_First (Container : in out Set);\n \n    procedure Delete_Last (Container : in out Set);\n \n-\n-   --  NOTE: The following operation is named Replace in the Madison API.\n-   --  However, it should be named Replace_Element ???\n-   --\n-   --   procedure Replace\n-   --     (Container : in out Set;\n-   --      Position  : Cursor;\n-   --      By        : Element_Type);\n+   procedure Exclude (Container : in out Set; Item : Element_Type);\n \n    procedure Union (Target : in out Set;\n                     Source : Set);\n@@ -143,10 +142,10 @@ pragma Preelaborate (Indefinite_Ordered_Multisets);\n \n    function Next (Position : Cursor) return Cursor;\n \n-   function Previous (Position : Cursor) return Cursor;\n-\n    procedure Next (Position : in out Cursor);\n \n+   function Previous (Position : Cursor) return Cursor;\n+\n    procedure Previous (Position : in out Cursor);\n \n    function Has_Element (Position : Cursor) return Boolean;\n@@ -207,12 +206,6 @@ pragma Preelaborate (Indefinite_Ordered_Multisets);\n \n       function Element (Container : Set; Key : Key_Type) return Element_Type;\n \n-      --  NOTE: in post-madison api ???\n-      --      procedure Replace\n-      --        (Container : in out Set;\n-      --         Key       : Key_Type;\n-      --         New_Item  : Element_Type);\n-\n       procedure Delete (Container : in out Set; Key : Key_Type);\n \n       procedure Exclude (Container : in out Set; Key : Key_Type);\n@@ -225,7 +218,7 @@ pragma Preelaborate (Indefinite_Ordered_Multisets);\n \n       function \">\" (Left : Key_Type; Right : Cursor) return Boolean;\n \n-      procedure Checked_Update_Element\n+      procedure Update_Element_Preserving_Key\n         (Container : in out Set;\n          Position  : Cursor;\n          Process   : not null access\n@@ -248,21 +241,33 @@ private\n    type Node_Type;\n    type Node_Access is access Node_Type;\n \n-   package Tree_Types is\n-      new Red_Black_Trees.Generic_Tree_Types (Node_Access);\n+   type Element_Access is access Element_Type;\n \n-   use Tree_Types;\n-   use Ada.Finalization;\n+   type Node_Type is limited record\n+      Parent  : Node_Access;\n+      Left    : Node_Access;\n+      Right   : Node_Access;\n+      Color   : Red_Black_Trees.Color_Type := Red_Black_Trees.Red;\n+      Element : Element_Access;\n+   end record;\n \n-   type Set is new Controlled with record\n-      Tree : Tree_Type := (Length => 0, others => null);\n+   package Tree_Types is new Red_Black_Trees.Generic_Tree_Types\n+     (Node_Type,\n+      Node_Access);\n+\n+   type Set is new Ada.Finalization.Controlled with record\n+      Tree : Tree_Types.Tree_Type;\n    end record;\n \n    procedure Adjust (Container : in out Set);\n \n    procedure Finalize (Container : in out Set) renames Clear;\n \n-   type Set_Access is access constant Set;\n+   use Red_Black_Trees;\n+   use Tree_Types;\n+   use Ada.Finalization;\n+\n+   type Set_Access is access all Set;\n    for Set_Access'Storage_Size use 0;\n \n    type Cursor is record\n@@ -285,6 +290,11 @@ private\n    for Set'Read use Read;\n \n    Empty_Set : constant Set :=\n-                 (Controlled with Tree => (Length => 0, others => null));\n+                 (Controlled with Tree => (First  => null,\n+                                           Last   => null,\n+                                           Root   => null,\n+                                           Length => 0,\n+                                           Busy   => 0,\n+                                           Lock   => 0));\n \n end Ada.Containers.Indefinite_Ordered_Multisets;"}, {"sha": "0f9615cc0286371fd05c60ad1adf79386d9da99b", "filename": "gcc/ada/a-ciorse.adb", "status": "modified", "additions": 424, "deletions": 442, "changes": 866, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-ciorse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-ciorse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorse.adb?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "patch": "@@ -2,11 +2,12 @@\n --                                                                          --\n --                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---                  ADA.CONTAINERS.INDEFINITE_ORDERED_SETS                  --\n+--                      A D A . C O N T A I N E R S .                       --\n+--              I N D E F I N I T E _ O R D E R E D _ S E T S               --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -44,22 +45,8 @@ pragma Elaborate_All (Ada.Containers.Red_Black_Trees.Generic_Set_Operations);\n \n with Ada.Unchecked_Deallocation;\n \n-with System;  use type System.Address;\n-\n package body Ada.Containers.Indefinite_Ordered_Sets is\n \n-   type Element_Access is access Element_Type;\n-\n-   use Red_Black_Trees;\n-\n-   type Node_Type is limited record\n-      Parent  : Node_Access;\n-      Left    : Node_Access;\n-      Right   : Node_Access;\n-      Color   : Red_Black_Trees.Color_Type := Red;\n-      Element : Element_Access;\n-   end record;\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -70,10 +57,6 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n    function Copy_Node (Source : Node_Access) return Node_Access;\n    pragma Inline (Copy_Node);\n \n-   function Copy_Tree (Source_Root : Node_Access) return Node_Access;\n-\n-   procedure Delete_Tree (X : in out Node_Access);\n-\n    procedure Free (X : in out Node_Access);\n \n    procedure Insert_With_Hint\n@@ -101,6 +84,11 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n    function Parent (Node : Node_Access) return Node_Access;\n    pragma Inline (Parent);\n \n+   procedure Replace_Element\n+     (Tree : in out Tree_Type;\n+      Node : Node_Access;\n+      Item : Element_Type);\n+\n    function Right (Node : Node_Access) return Node_Access;\n    pragma Inline (Right);\n \n@@ -124,9 +112,13 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n      new Ada.Unchecked_Deallocation (Element_Type, Element_Access);\n \n    package Tree_Operations is\n-     new Red_Black_Trees.Generic_Operations\n-       (Tree_Types => Tree_Types,\n-        Null_Node  => Node_Access'(null));\n+     new Red_Black_Trees.Generic_Operations (Tree_Types);\n+\n+   procedure Delete_Tree is\n+     new Tree_Operations.Generic_Delete_Tree (Free);\n+\n+   function Copy_Tree is\n+     new Tree_Operations.Generic_Copy_Tree (Copy_Node, Delete_Tree);\n \n    use Tree_Operations;\n \n@@ -189,14 +181,9 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n    --  Start of processing for \"=\"\n \n    begin\n-      if Left'Address = Right'Address then\n-         return True;\n-      end if;\n-\n       return Is_Equal (Left.Tree, Right.Tree);\n    end \"=\";\n \n-\n    ---------\n    -- \">\" --\n    ---------\n@@ -222,25 +209,12 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n    -- Adjust --\n    ------------\n \n-   procedure Adjust (Container : in out Set) is\n-      Tree : Tree_Type renames Container.Tree;\n+   procedure Adjust is\n+      new Tree_Operations.Generic_Adjust (Copy_Tree);\n \n+   procedure Adjust (Container : in out Set) is\n    begin\n-      if Tree.Length = 0 then\n-         pragma Assert (Tree.Root = null);\n-         return;\n-      end if;\n-\n-      begin\n-         Tree.Root := Copy_Tree (Tree.Root);\n-      exception\n-         when others =>\n-            Tree := (Length => 0, others => null);\n-            raise;\n-      end;\n-\n-      Tree.First := Min (Tree.Root);\n-      Tree.Last := Max (Tree.Root);\n+      Adjust (Container.Tree);\n    end Adjust;\n \n    -------------\n@@ -256,19 +230,19 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          return No_Element;\n       end if;\n \n-      return Cursor'(Container'Unchecked_Access, Node);\n+      return Cursor'(Container'Unrestricted_Access, Node);\n    end Ceiling;\n \n    -----------\n    -- Clear --\n    -----------\n \n+   procedure Clear is\n+      new Tree_Operations.Generic_Clear (Delete_Tree);\n+\n    procedure Clear (Container : in out Set) is\n-      Tree : Tree_Type renames Container.Tree;\n-      Root : Node_Access := Tree.Root;\n    begin\n-      Tree := (Length => 0, others => null);\n-      Delete_Tree (Root);\n+      Clear (Container.Tree);\n    end Clear;\n \n    -----------\n@@ -295,6 +269,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    function Copy_Node (Source : Node_Access) return Node_Access is\n       Element : Element_Access := new Element_Type'(Source.Element.all);\n+\n    begin\n       return new Node_Type'(Parent  => null,\n                             Left    => null,\n@@ -307,66 +282,22 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          raise;\n    end Copy_Node;\n \n-   ---------------\n-   -- Copy_Tree --\n-   ---------------\n-\n-   function Copy_Tree (Source_Root : Node_Access) return Node_Access is\n-      Target_Root : Node_Access := Copy_Node (Source_Root);\n-      P, X        : Node_Access;\n-\n-   begin\n-      if Source_Root.Right /= null then\n-         Target_Root.Right := Copy_Tree (Source_Root.Right);\n-         Target_Root.Right.Parent := Target_Root;\n-      end if;\n-\n-      P := Target_Root;\n-      X := Source_Root.Left;\n-\n-      while X /= null loop\n-         declare\n-            Y : Node_Access := Copy_Node (X);\n-\n-         begin\n-            P.Left := Y;\n-            Y.Parent := P;\n-\n-            if X.Right /= null then\n-               Y.Right := Copy_Tree (X.Right);\n-               Y.Right.Parent := Y;\n-            end if;\n-\n-            P := Y;\n-            X := X.Left;\n-         end;\n-      end loop;\n-\n-      return Target_Root;\n-\n-   exception\n-      when others =>\n-         Delete_Tree (Target_Root);\n-         raise;\n-   end Copy_Tree;\n-\n    ------------\n    -- Delete --\n    ------------\n \n    procedure Delete (Container : in out Set; Position  : in out Cursor) is\n    begin\n-      if Position = No_Element then\n-         return;\n+      if Position.Node = null then\n+         raise Constraint_Error;\n       end if;\n \n-      if Position.Container /= Set_Access'(Container'Unchecked_Access) then\n+      if Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error;\n       end if;\n \n-      Delete_Node_Sans_Free (Container.Tree, Position.Node);\n+      Tree_Operations.Delete_Node_Sans_Free (Container.Tree, Position.Node);\n       Free (Position.Node);\n-\n       Position.Container := null;\n    end Delete;\n \n@@ -388,63 +319,45 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n    ------------------\n \n    procedure Delete_First (Container : in out Set) is\n-      C : Cursor := First (Container);\n+      Tree : Tree_Type renames Container.Tree;\n+      X    : Node_Access := Tree.First;\n+\n    begin\n-      Delete (Container, C);\n+      if X /= null then\n+         Tree_Operations.Delete_Node_Sans_Free (Tree, X);\n+         Free (X);\n+      end if;\n    end Delete_First;\n \n    -----------------\n    -- Delete_Last --\n    -----------------\n \n    procedure Delete_Last (Container : in out Set) is\n-      C : Cursor := Last (Container);\n-   begin\n-      Delete (Container, C);\n-   end Delete_Last;\n-\n-   -----------------\n-   -- Delete_Tree --\n-   -----------------\n+      Tree : Tree_Type renames Container.Tree;\n+      X    : Node_Access := Tree.Last;\n \n-   procedure Delete_Tree (X : in out Node_Access) is\n-      Y : Node_Access;\n    begin\n-      while X /= null loop\n-         Y := X.Right;\n-         Delete_Tree (Y);\n-         Y := X.Left;\n+      if X /= null then\n+         Tree_Operations.Delete_Node_Sans_Free (Tree, X);\n          Free (X);\n-         X := Y;\n-      end loop;\n-   end Delete_Tree;\n+      end if;\n+   end Delete_Last;\n \n    ----------------\n    -- Difference --\n    ----------------\n \n    procedure Difference (Target : in out Set; Source : Set) is\n    begin\n-      if Target'Address = Source'Address then\n-         Clear (Target);\n-         return;\n-      end if;\n-\n       Set_Ops.Difference (Target.Tree, Source.Tree);\n    end Difference;\n \n    function Difference (Left, Right : Set) return Set is\n+      Tree : constant Tree_Type :=\n+               Set_Ops.Difference (Left.Tree, Right.Tree);\n    begin\n-      if Left'Address = Right'Address then\n-         return Empty_Set;\n-      end if;\n-\n-      declare\n-         Tree : constant Tree_Type :=\n-           Set_Ops.Difference (Left.Tree, Right.Tree);\n-      begin\n-         return (Controlled with Tree);\n-      end;\n+      return Set'(Controlled with Tree);\n    end Difference;\n \n    -------------\n@@ -456,16 +369,50 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       return Position.Node.Element.all;\n    end Element;\n \n+   ---------------------\n+   -- Equivalent_Sets --\n+   ---------------------\n+\n+   function Equivalent_Sets (Left, Right : Set) return Boolean is\n+\n+      function Is_Equivalent_Node_Node (L, R : Node_Access) return Boolean;\n+      pragma Inline (Is_Equivalent_Node_Node);\n+\n+      function Is_Equivalent is\n+         new Tree_Operations.Generic_Equal (Is_Equivalent_Node_Node);\n+\n+      -----------------------------\n+      -- Is_Equivalent_Node_Node --\n+      -----------------------------\n+\n+      function Is_Equivalent_Node_Node (L, R : Node_Access) return Boolean is\n+      begin\n+         if L.Element.all < R.Element.all then\n+            return False;\n+         elsif R.Element.all < L.Element.all then\n+            return False;\n+         else\n+            return True;\n+         end if;\n+      end Is_Equivalent_Node_Node;\n+\n+   --  Start of processing for Equivalent_Sets\n+\n+   begin\n+      return Is_Equivalent (Left.Tree, Right.Tree);\n+   end Equivalent_Sets;\n+\n    -------------\n    -- Exclude --\n    -------------\n \n    procedure Exclude (Container : in out Set; Item : Element_Type) is\n       X : Node_Access :=\n             Element_Keys.Find (Container.Tree, Item);\n+\n    begin\n       if X /= null then\n-         Delete_Node_Sans_Free (Container.Tree, X);\n+         Tree_Operations.Delete_Node_Sans_Free (Container.Tree, X);\n          Free (X);\n       end if;\n    end Exclude;\n@@ -483,7 +430,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          return No_Element;\n       end if;\n \n-      return Cursor'(Container'Unchecked_Access, Node);\n+      return Cursor'(Container'Unrestricted_Access, Node);\n    end Find;\n \n    -----------\n@@ -496,7 +443,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          return No_Element;\n       end if;\n \n-      return Cursor'(Container'Unchecked_Access, Container.Tree.First);\n+      return Cursor'(Container'Unrestricted_Access, Container.Tree.First);\n    end First;\n \n    -------------------\n@@ -521,21 +468,33 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          return No_Element;\n       end if;\n \n-      return Cursor'(Container'Unchecked_Access, Node);\n+      return Cursor'(Container'Unrestricted_Access, Node);\n    end Floor;\n \n    ----------\n    -- Free --\n    ----------\n \n    procedure Free (X : in out Node_Access) is\n+\n       procedure Deallocate is\n         new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n+\n    begin\n-      if X /= null then\n-         Free_Element (X.Element);\n-         Deallocate (X);\n+      if X = null then\n+         return;\n       end if;\n+\n+      begin\n+         Free_Element (X.Element);\n+      exception\n+         when others =>\n+            X.Element := null;\n+            Deallocate (X);\n+            raise;\n+      end;\n+\n+      Deallocate (X);\n    end Free;\n \n    ------------------\n@@ -610,90 +569,9 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n             return No_Element;\n          end if;\n \n-         return Cursor'(Container'Unchecked_Access, Node);\n+         return Cursor'(Container'Unrestricted_Access, Node);\n       end Ceiling;\n \n-      ----------------------------\n-      -- Checked_Update_Element --\n-      ----------------------------\n-\n-      procedure Checked_Update_Element\n-        (Container : in out Set;\n-         Position  : Cursor;\n-         Process   : not null access\n-                        procedure (Element : in out Element_Type))\n-      is\n-      begin\n-         if Position.Container = null then\n-            raise Constraint_Error;\n-         end if;\n-\n-         if Position.Container /= Set_Access'(Container'Unchecked_Access) then\n-            raise Program_Error;\n-         end if;\n-\n-         declare\n-            Old_Key : Key_Type renames Key (Position.Node.Element.all);\n-\n-         begin\n-            Process (Position.Node.Element.all);\n-\n-            if Old_Key < Position.Node.Element.all\n-              or else Old_Key > Position.Node.Element.all\n-            then\n-               null;\n-            else\n-               return;\n-            end if;\n-         end;\n-\n-         declare\n-            Result  : Node_Access;\n-            Success : Boolean;\n-\n-            function New_Node return Node_Access;\n-            pragma Inline (New_Node);\n-\n-            procedure Insert_Post is\n-              new Key_Keys.Generic_Insert_Post (New_Node);\n-\n-            procedure Insert is\n-              new Key_Keys.Generic_Conditional_Insert (Insert_Post);\n-\n-            --------------\n-            -- New_Node --\n-            --------------\n-\n-            function New_Node return Node_Access is\n-            begin\n-               return Position.Node;\n-            end New_Node;\n-\n-         --  Start of processing for Checked_Update_Element\n-\n-         begin\n-            Delete_Node_Sans_Free (Container.Tree, Position.Node);\n-\n-            Insert\n-              (Tree    => Container.Tree,\n-               Key     => Key (Position.Node.Element.all),\n-               Node    => Result,\n-               Success => Success);\n-\n-            if not Success then\n-               declare\n-                  X : Node_Access := Position.Node;\n-               begin\n-                  Free (X);\n-               end;\n-\n-               raise Program_Error;\n-            end if;\n-\n-            pragma Assert (Result = Position.Node);\n-         end;\n-      end Checked_Update_Element;\n-\n       --------------\n       -- Contains --\n       --------------\n@@ -715,7 +593,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n             raise Constraint_Error;\n          end if;\n \n-         Delete_Node_Sans_Free (Container.Tree, X);\n+         Tree_Operations.Delete_Node_Sans_Free (Container.Tree, X);\n          Free (X);\n       end Delete;\n \n@@ -724,9 +602,11 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       -------------\n \n       function Element (Container : Set; Key : Key_Type) return Element_Type is\n-         C : constant Cursor := Find (Container, Key);\n+         Node : constant Node_Access :=\n+                  Key_Keys.Find (Container.Tree, Key);\n+\n       begin\n-         return C.Node.Element.all;\n+         return Node.Element.all;\n       end Element;\n \n       -------------\n@@ -738,7 +618,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n       begin\n          if X /= null then\n-            Delete_Node_Sans_Free (Container.Tree, X);\n+            Tree_Operations.Delete_Node_Sans_Free (Container.Tree, X);\n             Free (X);\n          end if;\n       end Exclude;\n@@ -756,7 +636,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n             return No_Element;\n          end if;\n \n-         return Cursor'(Container'Unchecked_Access, Node);\n+         return Cursor'(Container'Unrestricted_Access, Node);\n       end Find;\n \n       -----------\n@@ -772,7 +652,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n             return No_Element;\n          end if;\n \n-         return Cursor'(Container'Unchecked_Access, Node);\n+         return Cursor'(Container'Unrestricted_Access, Node);\n       end Floor;\n \n       -------------------------\n@@ -806,6 +686,88 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          return Key (Position.Node.Element.all);\n       end Key;\n \n+      -------------\n+      -- Replace --\n+      -------------\n+\n+      procedure Replace\n+        (Container : in out Set;\n+         Key       : Key_Type;\n+         New_Item  : Element_Type)\n+      is\n+         Node : constant Node_Access := Key_Keys.Find (Container.Tree, Key);\n+\n+      begin\n+         if Node = null then\n+            raise Constraint_Error;\n+         end if;\n+\n+         Replace_Element (Container.Tree, Node, New_Item);\n+      end Replace;\n+\n+      -----------------------------------\n+      -- Update_Element_Preserving_Key --\n+      -----------------------------------\n+\n+      procedure Update_Element_Preserving_Key\n+        (Container : in out Set;\n+         Position  : Cursor;\n+         Process   : not null access\n+                        procedure (Element : in out Element_Type))\n+      is\n+         Tree : Tree_Type renames Container.Tree;\n+\n+      begin\n+         if Position.Node = null then\n+            raise Constraint_Error;\n+         end if;\n+\n+         if Position.Container /= Container'Unrestricted_Access then\n+            raise Program_Error;\n+         end if;\n+\n+         declare\n+            E : Element_Type renames Position.Node.Element.all;\n+            K : Key_Type renames Key (E);\n+\n+            B : Natural renames Tree.Busy;\n+            L : Natural renames Tree.Lock;\n+\n+         begin\n+            B := B + 1;\n+            L := L + 1;\n+\n+            begin\n+               Process (E);\n+            exception\n+               when others =>\n+                  L := L - 1;\n+                  B := B - 1;\n+                  raise;\n+            end;\n+\n+            L := L - 1;\n+            B := B - 1;\n+\n+            if K < E\n+              or else K > E\n+            then\n+               null;\n+            else\n+               return;\n+            end if;\n+         end;\n+\n+         declare\n+            X : Node_Access := Position.Node;\n+         begin\n+            Tree_Operations.Delete_Node_Sans_Free (Tree, X);\n+            Free (X);\n+         end;\n+\n+         raise Program_Error;\n+      end Update_Element_Preserving_Key;\n+\n    end Generic_Keys;\n \n    -----------------\n@@ -831,6 +793,10 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       Insert (Container, New_Item, Position, Inserted);\n \n       if not Inserted then\n+         if Container.Tree.Lock > 0 then\n+            raise Program_Error;\n+         end if;\n+\n          X := Position.Node.Element;\n          Position.Node.Element := new Element_Type'(New_Item);\n          Free_Element (X);\n@@ -883,7 +849,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          Position.Node,\n          Inserted);\n \n-      Position.Container := Container'Unchecked_Access;\n+      Position.Container := Container'Unrestricted_Access;\n    end Insert;\n \n    procedure Insert (Container : in out Set; New_Item  : Element_Type) is\n@@ -961,25 +927,14 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    procedure Intersection (Target : in out Set; Source : Set) is\n    begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n       Set_Ops.Intersection (Target.Tree, Source.Tree);\n    end Intersection;\n \n    function Intersection (Left, Right : Set) return Set is\n+      Tree : constant Tree_Type :=\n+               Set_Ops.Intersection (Left.Tree, Right.Tree);\n    begin\n-      if Left'Address = Right'Address then\n-         return Left;\n-      end if;\n-\n-      declare\n-         Tree : constant Tree_Type :=\n-                  Set_Ops.Intersection (Left.Tree, Right.Tree);\n-      begin\n-         return (Controlled with Tree);\n-      end;\n+      return Set'(Controlled with Tree);\n    end Intersection;\n \n    --------------\n@@ -988,7 +943,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    function Is_Empty (Container : Set) return Boolean is\n    begin\n-      return Length (Container) = 0;\n+      return Container.Tree.Length = 0;\n    end Is_Empty;\n \n    -----------------------------\n@@ -1004,7 +959,6 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       return Right.Element.all < Left;\n    end Is_Greater_Element_Node;\n \n-\n    --------------------------\n    -- Is_Less_Element_Node --\n    --------------------------\n@@ -1031,10 +985,6 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    function Is_Subset (Subset : Set; Of_Set : Set) return Boolean is\n    begin\n-      if Subset'Address = Of_Set'Address then\n-         return True;\n-      end if;\n-\n       return Set_Ops.Is_Subset (Subset => Subset.Tree, Of_Set => Of_Set.Tree);\n    end Is_Subset;\n \n@@ -1058,13 +1008,26 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n       procedure Process_Node (Node : Node_Access) is\n       begin\n-         Process (Cursor'(Container'Unchecked_Access, Node));\n+         Process (Cursor'(Container'Unrestricted_Access, Node));\n       end Process_Node;\n \n-   --  Start of processing for Iterate\n+      T : Tree_Type renames Container.Tree'Unrestricted_Access.all;\n+      B : Natural renames T.Busy;\n+\n+   --  Start of prccessing for Iterate\n \n    begin\n-      Local_Iterate (Container.Tree);\n+      B := B + 1;\n+\n+      begin\n+         Local_Iterate (T);\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n    end Iterate;\n \n    ----------\n@@ -1077,7 +1040,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          return No_Element;\n       end if;\n \n-      return Cursor'(Container'Unchecked_Access, Container.Tree.Last);\n+      return Cursor'(Container'Unrestricted_Access, Container.Tree.Last);\n    end Last;\n \n    ------------------\n@@ -1111,12 +1074,11 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n    -- Move --\n    ----------\n \n+   procedure Move is\n+      new Tree_Operations.Generic_Move (Clear);\n+\n    procedure Move (Target : in out Set; Source : in out Set) is\n    begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n       Move (Target => Target.Tree, Source => Source.Tree);\n    end Move;\n \n@@ -1137,7 +1099,8 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n       declare\n          Node : constant Node_Access :=\n-           Tree_Operations.Next (Position.Node);\n+                  Tree_Operations.Next (Position.Node);\n+\n       begin\n          if Node = null then\n             return No_Element;\n@@ -1153,10 +1116,6 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    function Overlap (Left, Right : Set) return Boolean is\n    begin\n-      if Left'Address = Right'Address then\n-         return Left.Tree.Length /= 0;\n-      end if;\n-\n       return Set_Ops.Overlap (Left.Tree, Right.Tree);\n    end Overlap;\n \n@@ -1186,7 +1145,8 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n       declare\n          Node : constant Node_Access :=\n-           Tree_Operations.Previous (Position.Node);\n+                  Tree_Operations.Previous (Position.Node);\n+\n       begin\n          if Node = null then\n             return No_Element;\n@@ -1204,30 +1164,53 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n      (Position  : Cursor;\n       Process   : not null access procedure (Element : Element_Type))\n    is\n+      E : Element_Type renames Position.Node.Element.all;\n+\n+      S : Set renames Position.Container.all;\n+      T : Tree_Type renames S.Tree'Unrestricted_Access.all;\n+\n+      B : Natural renames T.Busy;\n+      L : Natural renames T.Lock;\n+\n    begin\n-      Process (Position.Node.Element.all);\n+      B := B + 1;\n+      L := L + 1;\n+\n+      begin\n+         Process (E);\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      L := L - 1;\n+      B := B - 1;\n    end Query_Element;\n \n    ----------\n    -- Read --\n    ----------\n \n    procedure Read\n-     (Stream    : access Ada.Streams.Root_Stream_Type'Class;\n+     (Stream    : access Root_Stream_Type'Class;\n       Container : out Set)\n    is\n-      N : Count_Type'Base;\n-\n-      function New_Node return Node_Access;\n+      function Read_Node\n+        (Stream : access Root_Stream_Type'Class) return Node_Access;\n+      pragma Inline (Read_Node);\n \n       procedure Read is\n-        new Tree_Operations.Generic_Read (New_Node);\n+         new Tree_Operations.Generic_Read (Clear, Read_Node);\n \n-      --------------\n-      -- New_Node --\n-      --------------\n+      ---------------\n+      -- Read_Node --\n+      ---------------\n \n-      function New_Node return Node_Access is\n+      function Read_Node\n+        (Stream : access Root_Stream_Type'Class) return Node_Access\n+      is\n          Node : Node_Access := new Node_Type;\n \n       begin\n@@ -1236,17 +1219,14 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n       exception\n          when others =>\n-            Free (Node);\n+            Free (Node);  --  Note that Free deallocates elem too\n             raise;\n-      end New_Node;\n+      end Read_Node;\n \n    --  Start of processing for Read\n \n    begin\n-      Clear (Container);\n-      Count_Type'Base'Read (Stream, N);\n-      pragma Assert (N >= 0);\n-      Read (Container.Tree, N);\n+      Read (Stream, Container.Tree);\n    end Read;\n \n    -------------\n@@ -1269,129 +1249,139 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       Free_Element (X);\n    end Replace;\n \n---  TODO ???\n---        procedure Replace\n---          (Container : in out Set;\n---           Key       : Key_Type;\n---           New_Item  : Element_Type)\n---        is\n---           Node : Node_Access := Key_Keys.Find (Container.Tree, Key);\n-\n---        begin\n---           if Node = null then\n---              raise Constraint_Error;\n---           end if;\n-\n---           Replace_Element (Container, Node, New_Item);\n---        end Replace;\n-\n    ---------------------\n    -- Replace_Element --\n    ---------------------\n \n---  TODO: ???\n---     procedure Replace_Element\n---       (Container : in out Set;\n---        Position  : Node_Access;\n---        By        : Element_Type)\n---   is\n-\n---        Node : Node_Access := Position;\n-\n---     begin\n---        if By < Node.Element.all\n---          or else Node.Element.all < By\n---        then\n---           null;\n-\n---        else\n---           declare\n---              X : Element_Access := Node.Element;\n-\n---           begin\n---              Node.Element := new Element_Type'(By);\n-\n---              --  NOTE: If there's an exception here, then just\n---              --  let it propagate.  We haven't modified the\n---              --  state of the container, so there's nothing else\n---              --  we need to do.\n-\n---              Free_Element (X);\n---           end;\n-\n---           return;\n---        end if;\n-\n---        Delete_Node_Sans_Free (Container.Tree, Node);\n-\n---        begin\n---           Free_Element (Node.Element);\n---        exception\n---           when others =>\n---              Node.Element := null;  --  don't attempt to dealloc X.E again\n---              Free (Node);\n---              raise;\n---        end;\n-\n---        begin\n---           Node.Element := new Element_Type'(By);\n---        exception\n---           when others =>\n---              Free (Node);\n---              raise;\n---        end;\n-\n---        declare\n---           function New_Node return Node_Access;\n---           pragma Inline (New_Node);\n-\n---           function New_Node return Node_Access is\n---           begin\n---              return Node;\n---           end New_Node;\n-\n---           procedure Insert_Post is\n---             new Element_Keys.Generic_Insert_Post (New_Node);\n-\n---           procedure Insert is\n---             new Element_Keys.Generic_Conditional_Insert (Insert_Post);\n-\n---           Result  : Node_Access;\n---           Success : Boolean;\n-\n---        begin\n---           Insert\n---             (Tree    => Container.Tree,\n---              Key     => Node.Element.all,\n---              Node    => Result,\n---              Success => Success);\n-\n---           if not Success then\n---              Free (Node);\n---              raise Program_Error;\n---           end if;\n-\n---           pragma Assert (Result = Node);\n---        end;\n---     end Replace_Element;\n-\n-\n---     procedure Replace_Element\n---      (Container : in out Set;\n---       Position  : Cursor;\n---       By        : Element_Type)\n---     is\n---     begin\n---        if Position.Container = null then\n---           raise Constraint_Error;\n---        end if;\n-\n---        if Position.Container /= Set_Access'(Container'Unchecked_Access) then\n---           raise Program_Error;\n---        end if;\n-\n---        Replace_Element (Container, Position.Node, By);\n---     end Replace_Element;\n+   procedure Replace_Element\n+     (Tree : in out Tree_Type;\n+      Node : Node_Access;\n+      Item : Element_Type)\n+   is\n+   begin\n+      if Item < Node.Element.all\n+        or else Node.Element.all < Item\n+      then\n+         null;\n+      else\n+         if Tree.Lock > 0 then\n+            raise Program_Error;\n+         end if;\n+\n+         declare\n+            X : Element_Access := Node.Element;\n+         begin\n+            Node.Element := new Element_Type'(Item);\n+            Free_Element (X);\n+         end;\n+\n+         return;\n+      end if;\n+\n+      Tree_Operations.Delete_Node_Sans_Free (Tree, Node);  -- Checks busy-bit\n+\n+      Insert_New_Item : declare\n+         function New_Node return Node_Access;\n+         pragma Inline (New_Node);\n+\n+         procedure Insert_Post is\n+            new Element_Keys.Generic_Insert_Post (New_Node);\n+\n+         procedure Insert is\n+            new Element_Keys.Generic_Conditional_Insert (Insert_Post);\n+\n+         --------------\n+         -- New_Node --\n+         --------------\n+\n+         function New_Node return Node_Access is\n+         begin\n+            Node.Element := new Element_Type'(Item);  -- OK if fails\n+            return Node;\n+         end New_Node;\n+\n+         Result   : Node_Access;\n+         Inserted : Boolean;\n+\n+         X : Element_Access := Node.Element;\n+\n+      --  Start of processing for Insert_New_Item\n+\n+      begin\n+         Attempt_Insert : begin\n+            Insert\n+              (Tree    => Tree,\n+               Key     => Item,\n+               Node    => Result,\n+               Success => Inserted);  --  TODO: change name of formal param\n+         exception\n+            when others =>\n+               Inserted := False;\n+         end Attempt_Insert;\n+\n+         if Inserted then\n+            pragma Assert (Result = Node);\n+            Free_Element (X);  -- OK if fails\n+            return;\n+         end if;\n+      end Insert_New_Item;\n+\n+      Reinsert_Old_Element : declare\n+         function New_Node return Node_Access;\n+         pragma Inline (New_Node);\n+\n+         procedure Insert_Post is\n+            new Element_Keys.Generic_Insert_Post (New_Node);\n+\n+         procedure Insert is\n+            new Element_Keys.Generic_Conditional_Insert (Insert_Post);\n+\n+         --------------\n+         -- New_Node --\n+         --------------\n+\n+         function New_Node return Node_Access is\n+         begin\n+            return Node;\n+         end New_Node;\n+\n+         Result   : Node_Access;\n+         Inserted : Boolean;\n+\n+      --  Start of processing for Reinsert_Old_Element\n+\n+      begin\n+         Insert\n+           (Tree    => Tree,\n+            Key     => Node.Element.all,\n+            Node    => Result,\n+            Success => Inserted);  --  TODO: change name of formal param\n+      exception\n+         when others =>\n+            null;\n+      end Reinsert_Old_Element;\n+\n+      raise Program_Error;\n+   end Replace_Element;\n+\n+   procedure Replace_Element\n+    (Container : Set;\n+     Position  : Cursor;\n+     By        : Element_Type)\n+   is\n+      Tree : Tree_Type renames Position.Container.Tree'Unrestricted_Access.all;\n+\n+   begin\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error;\n+      end if;\n+\n+      Replace_Element (Tree, Position.Node, By);\n+   end Replace_Element;\n \n    ---------------------\n    -- Reverse_Iterate --\n@@ -1413,13 +1403,26 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n       procedure Process_Node (Node : Node_Access) is\n       begin\n-         Process (Cursor'(Container'Unchecked_Access, Node));\n+         Process (Cursor'(Container'Unrestricted_Access, Node));\n       end Process_Node;\n \n+      T : Tree_Type renames Container.Tree'Unrestricted_Access.all;\n+      B : Natural renames T.Busy;\n+\n    --  Start of processing for Reverse_Iterate\n \n    begin\n-      Local_Reverse_Iterate (Container.Tree);\n+      B := B + 1;\n+\n+      begin\n+         Local_Reverse_Iterate (T);\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n    end Reverse_Iterate;\n \n    -----------\n@@ -1473,26 +1476,14 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    procedure Symmetric_Difference (Target : in out Set; Source : Set) is\n    begin\n-      if Target'Address = Source'Address then\n-         Clear (Target);\n-         return;\n-      end if;\n-\n       Set_Ops.Symmetric_Difference (Target.Tree, Source.Tree);\n    end Symmetric_Difference;\n \n    function Symmetric_Difference (Left, Right : Set) return Set is\n+      Tree : constant Tree_Type :=\n+               Set_Ops.Symmetric_Difference (Left.Tree, Right.Tree);\n    begin\n-      if Left'Address = Right'Address then\n-         return Empty_Set;\n-      end if;\n-\n-      declare\n-         Tree : constant Tree_Type :=\n-                  Set_Ops.Symmetric_Difference (Left.Tree, Right.Tree);\n-      begin\n-         return (Controlled with Tree);\n-      end;\n+      return Set'(Controlled with Tree);\n    end Symmetric_Difference;\n \n    -----------\n@@ -1501,57 +1492,48 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    procedure Union (Target : in out Set; Source : Set) is\n    begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n       Set_Ops.Union (Target.Tree, Source.Tree);\n    end Union;\n \n    function Union (Left, Right : Set) return Set is\n+      Tree : constant Tree_Type :=\n+               Set_Ops.Union (Left.Tree, Right.Tree);\n    begin\n-      if Left'Address = Right'Address then\n-         return Left;\n-      end if;\n-\n-      declare\n-         Tree : constant Tree_Type :=\n-                  Set_Ops.Union (Left.Tree, Right.Tree);\n-      begin\n-         return (Controlled with Tree);\n-      end;\n+      return Set'(Controlled with Tree);\n    end Union;\n \n    -----------\n    -- Write --\n    -----------\n \n    procedure Write\n-     (Stream    : access Ada.Streams.Root_Stream_Type'Class;\n+     (Stream    : access Root_Stream_Type'Class;\n       Container : Set)\n    is\n-      procedure Process (Node : Node_Access);\n-      pragma Inline (Process);\n+      procedure Write_Node\n+        (Stream : access Root_Stream_Type'Class;\n+         Node   : Node_Access);\n+      pragma Inline (Write_Node);\n \n-      procedure Iterate is\n-        new Tree_Operations.Generic_Iteration (Process);\n+      procedure Write is\n+         new Tree_Operations.Generic_Write (Write_Node);\n \n-      -------------\n-      -- Process --\n-      -------------\n+      ----------------\n+      -- Write_Node --\n+      ----------------\n \n-      procedure Process (Node : Node_Access) is\n+      procedure Write_Node\n+        (Stream : access Root_Stream_Type'Class;\n+         Node   : Node_Access)\n+      is\n       begin\n          Element_Type'Output (Stream, Node.Element.all);\n-      end Process;\n+      end Write_Node;\n \n    --  Start of processing for Write\n \n    begin\n-      Count_Type'Base'Write (Stream, Container.Tree.Length);\n-      Iterate (Container.Tree);\n+      Write (Stream, Container.Tree);\n    end Write;\n \n end Ada.Containers.Indefinite_Ordered_Sets;\n-\n-"}, {"sha": "0841bc74560ee7fa6f2f80417dec2dc892abe9a5", "filename": "gcc/ada/a-ciorse.ads", "status": "modified", "additions": 45, "deletions": 28, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-ciorse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-ciorse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorse.ads?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "patch": "@@ -2,11 +2,12 @@\n --                                                                          --\n --                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---                  ADA.CONTAINERS.INDEFINITE_ORDERED_SETS                  --\n+--                      A D A . C O N T A I N E R S .                       --\n+--              I N D E F I N I T E _ O R D E R E D _ S E T S               --\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -56,6 +57,8 @@ pragma Preelaborate (Indefinite_Ordered_Sets);\n \n    function \"=\" (Left, Right : Set) return Boolean;\n \n+   function Equivalent_Sets (Left, Right : Set) return Boolean;\n+\n    function Length (Container : Set) return Count_Type;\n \n    function Is_Empty (Container : Set) return Boolean;\n@@ -68,11 +71,10 @@ pragma Preelaborate (Indefinite_Ordered_Sets);\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type));\n \n-   --  TODO: resolve in Atlanta???\n-   --   procedure Replace_Element\n-   --     (Container : in out Set;\n-   --      Position  : Cursor;\n-   --      By        : Element_Type);\n+   procedure Replace_Element\n+     (Container : Set;   --  TODO: need ruling from ARG\n+      Position  : Cursor;\n+      By        : Element_Type);\n \n    procedure Move (Target : in out Set; Source : in out Set);\n \n@@ -98,10 +100,6 @@ pragma Preelaborate (Indefinite_Ordered_Sets);\n      (Container : in out Set;\n       Item      : Element_Type);\n \n-   procedure Exclude\n-     (Container : in out Set;\n-      Item      : Element_Type);\n-\n    procedure Delete\n      (Container : in out Set;\n       Position  : in out Cursor);\n@@ -110,6 +108,10 @@ pragma Preelaborate (Indefinite_Ordered_Sets);\n \n    procedure Delete_Last (Container : in out Set);\n \n+   procedure Exclude\n+     (Container : in out Set;\n+      Item      : Element_Type);\n+\n    procedure Union (Target : in out Set; Source : Set);\n \n    function Union (Left, Right : Set) return Set;\n@@ -157,10 +159,10 @@ pragma Preelaborate (Indefinite_Ordered_Sets);\n \n    function Next (Position : Cursor) return Cursor;\n \n-   function Previous (Position : Cursor) return Cursor;\n-\n    procedure Next (Position : in out Cursor);\n \n+   function Previous (Position : Cursor) return Cursor;\n+\n    procedure Previous (Position : in out Cursor);\n \n    function Has_Element (Position : Cursor) return Boolean;\n@@ -220,11 +222,10 @@ pragma Preelaborate (Indefinite_Ordered_Sets);\n         (Container : Set;\n          Key       : Key_Type) return Element_Type;\n \n-      --  TODO: resolve in Atlanta???\n-      --      procedure Replace\n-      --        (Container : in out Set;\n-      --         Key       : Key_Type;\n-      --         New_Item  : Element_Type);\n+      procedure Replace\n+        (Container : in out Set;  --  TODO: need ruling from ARG\n+         Key       : Key_Type;\n+         New_Item  : Element_Type);\n \n       procedure Delete (Container : in out Set; Key : Key_Type);\n \n@@ -238,8 +239,7 @@ pragma Preelaborate (Indefinite_Ordered_Sets);\n \n       function \">\" (Left : Key_Type; Right : Cursor) return Boolean;\n \n-      --  TODO: resolve name in Atlanta???\n-      procedure Checked_Update_Element\n+      procedure Update_Element_Preserving_Key\n         (Container : in out Set;\n          Position  : Cursor;\n          Process   : not null access\n@@ -252,21 +252,33 @@ private\n    type Node_Type;\n    type Node_Access is access Node_Type;\n \n-   package Tree_Types is\n-     new Red_Black_Trees.Generic_Tree_Types (Node_Access);\n+   type Element_Access is access Element_Type;\n \n-   use Tree_Types;\n-   use Ada.Finalization;\n+   type Node_Type is limited record\n+      Parent  : Node_Access;\n+      Left    : Node_Access;\n+      Right   : Node_Access;\n+      Color   : Red_Black_Trees.Color_Type := Red_Black_Trees.Red;\n+      Element : Element_Access;\n+   end record;\n+\n+   package Tree_Types is new Red_Black_Trees.Generic_Tree_Types\n+     (Node_Type,\n+      Node_Access);\n \n-   type Set is new Controlled with record\n-      Tree : Tree_Type := (Length => 0, others => null);\n+   type Set is new Ada.Finalization.Controlled with record\n+      Tree : Tree_Types.Tree_Type;\n    end record;\n \n    procedure Adjust (Container : in out Set);\n \n    procedure Finalize (Container : in out Set) renames Clear;\n \n-   type Set_Access is access constant Set;\n+   use Red_Black_Trees;\n+   use Tree_Types;\n+   use Ada.Finalization;\n+\n+   type Set_Access is access all Set;\n    for Set_Access'Storage_Size use 0;\n \n    type Cursor is record\n@@ -291,6 +303,11 @@ private\n    for Set'Read use Read;\n \n    Empty_Set : constant Set :=\n-                 (Controlled with Tree => (Length => 0, others => null));\n+                 (Controlled with Tree => (First  => null,\n+                                           Last   => null,\n+                                           Root   => null,\n+                                           Length => 0,\n+                                           Busy   => 0,\n+                                           Lock   => 0));\n \n end Ada.Containers.Indefinite_Ordered_Sets;"}, {"sha": "97d2723e3362e1317042655486af9ef9b947a19d", "filename": "gcc/ada/a-cohama.adb", "status": "modified", "additions": 265, "deletions": 62, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-cohama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-cohama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohama.adb?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---                        ADA.CONTAINERS.HASHED_MAPS                        --\n+--            A D A . C O N T A I N E R S . H A S H E D _ M A P S           --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -43,12 +43,6 @@ pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Keys);\n \n package body Ada.Containers.Hashed_Maps is\n \n-   type Node_Type is limited record\n-      Key     : Key_Type;\n-      Element : Element_Type;\n-      Next    : Node_Access;\n-   end record;\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -57,13 +51,15 @@ package body Ada.Containers.Hashed_Maps is\n      (Source : Node_Access) return Node_Access;\n    pragma Inline (Copy_Node);\n \n-   function Equivalent_Keys\n+   function Equivalent_Key_Node\n      (Key  : Key_Type;\n       Node : Node_Access) return Boolean;\n-   pragma Inline (Equivalent_Keys);\n+   pragma Inline (Equivalent_Key_Node);\n+\n+   procedure Free (X : in out Node_Access);\n \n    function Find_Equal_Key\n-     (R_Map  : Map;\n+     (R_HT   : Hash_Table_Type;\n       L_Node : Node_Access) return Boolean;\n \n    function Hash_Node (Node : Node_Access) return Hash_Type;\n@@ -79,6 +75,8 @@ package body Ada.Containers.Hashed_Maps is\n    procedure Set_Next (Node : Node_Access; Next : Node_Access);\n    pragma Inline (Set_Next);\n \n+   function Vet (Position : Cursor) return Boolean;\n+\n    procedure Write_Node\n      (Stream : access Root_Stream_Type'Class;\n       Node   : Node_Access);\n@@ -88,14 +86,9 @@ package body Ada.Containers.Hashed_Maps is\n    -- Local Instantiations --\n    --------------------------\n \n-   procedure Free is\n-     new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n-\n    package HT_Ops is\n       new Hash_Tables.Generic_Operations\n        (HT_Types          => HT_Types,\n-        Hash_Table_Type   => Map,\n-        Null_Node         => null,\n         Hash_Node         => Hash_Node,\n         Next              => Next,\n         Set_Next          => Set_Next,\n@@ -105,13 +98,11 @@ package body Ada.Containers.Hashed_Maps is\n    package Key_Ops is\n       new Hash_Tables.Generic_Keys\n        (HT_Types  => HT_Types,\n-        HT_Type   => Map,\n-        Null_Node => null,\n         Next      => Next,\n         Set_Next  => Set_Next,\n         Key_Type  => Key_Type,\n         Hash      => Hash,\n-        Equivalent_Keys => Equivalent_Keys);\n+        Equivalent_Keys => Equivalent_Key_Node);\n \n    function Is_Equal is new HT_Ops.Generic_Equal (Find_Equal_Key);\n \n@@ -122,26 +113,37 @@ package body Ada.Containers.Hashed_Maps is\n    -- \"=\" --\n    ---------\n \n-   function \"=\" (Left, Right : Map) return Boolean renames Is_Equal;\n+   function \"=\" (Left, Right : Map) return Boolean is\n+   begin\n+      return Is_Equal (Left.HT, Right.HT);\n+   end \"=\";\n \n    ------------\n    -- Adjust --\n    ------------\n \n-   procedure Adjust (Container : in out Map) renames HT_Ops.Adjust;\n+   procedure Adjust (Container : in out Map) is\n+   begin\n+      HT_Ops.Adjust (Container.HT);\n+   end Adjust;\n \n    --------------\n    -- Capacity --\n    --------------\n \n-   function Capacity (Container : Map) return Count_Type\n-     renames HT_Ops.Capacity;\n+   function Capacity (Container : Map) return Count_Type is\n+   begin\n+      return HT_Ops.Capacity (Container.HT);\n+   end Capacity;\n \n    -----------\n    -- Clear --\n    -----------\n \n-   procedure Clear (Container : in out Map) renames HT_Ops.Clear;\n+   procedure Clear (Container : in out Map) is\n+   begin\n+      HT_Ops.Clear (Container.HT);\n+   end Clear;\n \n    --------------\n    -- Contains --\n@@ -175,7 +177,7 @@ package body Ada.Containers.Hashed_Maps is\n       X : Node_Access;\n \n    begin\n-      Key_Ops.Delete_Key_Sans_Free (Container, Key, X);\n+      Key_Ops.Delete_Key_Sans_Free (Container.HT, Key, X);\n \n       if X = null then\n          raise Constraint_Error;\n@@ -186,17 +188,23 @@ package body Ada.Containers.Hashed_Maps is\n \n    procedure Delete (Container : in out Map; Position : in out Cursor) is\n    begin\n-      if Position = No_Element then\n-         return;\n+      if Position.Node = null then\n+         raise Constraint_Error;\n       end if;\n \n       if Position.Container /= Map_Access'(Container'Unchecked_Access) then\n          raise Program_Error;\n       end if;\n \n-      HT_Ops.Delete_Node_Sans_Free (Container, Position.Node);\n-      Free (Position.Node);\n+      pragma Assert (Position.Node.Next /= Position.Node);\n+\n+      if Container.HT.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n \n+      HT_Ops.Delete_Node_Sans_Free (Container.HT, Position.Node);\n+\n+      Free (Position.Node);\n       Position.Container := null;\n    end Delete;\n \n@@ -212,19 +220,20 @@ package body Ada.Containers.Hashed_Maps is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n+      pragma Assert (Vet (Position));\n       return Position.Node.Element;\n    end Element;\n \n-   ---------------------\n-   -- Equivalent_Keys --\n-   ---------------------\n+   -------------------------\n+   -- Equivalent_Key_Node --\n+   -------------------------\n \n-   function Equivalent_Keys\n+   function Equivalent_Key_Node\n      (Key  : Key_Type;\n       Node : Node_Access) return Boolean is\n    begin\n       return Equivalent_Keys (Key, Node.Key);\n-   end Equivalent_Keys;\n+   end Equivalent_Key_Node;\n \n    ---------------------\n    -- Equivalent_Keys --\n@@ -233,16 +242,20 @@ package body Ada.Containers.Hashed_Maps is\n    function Equivalent_Keys (Left, Right : Cursor)\n      return Boolean is\n    begin\n+      pragma Assert (Vet (Left));\n+      pragma Assert (Vet (Right));\n       return Equivalent_Keys (Left.Node.Key, Right.Node.Key);\n    end Equivalent_Keys;\n \n    function Equivalent_Keys (Left : Cursor; Right : Key_Type) return Boolean is\n    begin\n+      pragma Assert (Vet (Left));\n       return Equivalent_Keys (Left.Node.Key, Right);\n    end Equivalent_Keys;\n \n    function Equivalent_Keys (Left : Key_Type; Right : Cursor) return Boolean is\n    begin\n+      pragma Assert (Vet (Right));\n       return Equivalent_Keys (Left, Right.Node.Key);\n    end Equivalent_Keys;\n \n@@ -253,22 +266,25 @@ package body Ada.Containers.Hashed_Maps is\n    procedure Exclude (Container : in out Map; Key : Key_Type) is\n       X : Node_Access;\n    begin\n-      Key_Ops.Delete_Key_Sans_Free (Container, Key, X);\n+      Key_Ops.Delete_Key_Sans_Free (Container.HT, Key, X);\n       Free (X);\n    end Exclude;\n \n    --------------\n    -- Finalize --\n    --------------\n \n-   procedure Finalize (Container : in out Map) renames HT_Ops.Finalize;\n+   procedure Finalize (Container : in out Map) is\n+   begin\n+      HT_Ops.Finalize (Container.HT);\n+   end Finalize;\n \n    ----------\n    -- Find --\n    ----------\n \n    function Find (Container : Map; Key : Key_Type) return Cursor is\n-      Node : constant Node_Access := Key_Ops.Find (Container, Key);\n+      Node : constant Node_Access := Key_Ops.Find (Container.HT, Key);\n \n    begin\n       if Node = null then\n@@ -283,11 +299,11 @@ package body Ada.Containers.Hashed_Maps is\n    --------------------\n \n    function Find_Equal_Key\n-     (R_Map  : Map;\n+     (R_HT   : Hash_Table_Type;\n       L_Node : Node_Access) return Boolean\n    is\n-      R_Index : constant Hash_Type := Key_Ops.Index (R_Map, L_Node.Key);\n-      R_Node  : Node_Access := R_Map.Buckets (R_Index);\n+      R_Index : constant Hash_Type := Key_Ops.Index (R_HT, L_Node.Key);\n+      R_Node  : Node_Access := R_HT.Buckets (R_Index);\n \n    begin\n       while R_Node /= null loop\n@@ -306,7 +322,7 @@ package body Ada.Containers.Hashed_Maps is\n    -----------\n \n    function First (Container : Map) return Cursor is\n-      Node : constant Node_Access := HT_Ops.First (Container);\n+      Node : constant Node_Access := HT_Ops.First (Container.HT);\n \n    begin\n       if Node = null then\n@@ -316,13 +332,33 @@ package body Ada.Containers.Hashed_Maps is\n       return Cursor'(Container'Unchecked_Access, Node);\n    end First;\n \n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free (X : in out Node_Access) is\n+      procedure Deallocate is\n+         new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n+   begin\n+      if X /= null then\n+         X.Next := X;     --  detect mischief (in Vet)\n+         Deallocate (X);\n+      end if;\n+   end Free;\n+\n    -----------------\n    -- Has_Element --\n    -----------------\n \n    function Has_Element (Position : Cursor) return Boolean is\n    begin\n-      return Position /= No_Element;\n+      if Position.Node = null then\n+         pragma Assert (Position.Container = null);\n+         return False;\n+      end if;\n+\n+      pragma Assert (Vet (Position));\n+      return True;\n    end Has_Element;\n \n    ---------------\n@@ -350,6 +386,10 @@ package body Ada.Containers.Hashed_Maps is\n       Insert (Container, Key, New_Item, Position, Inserted);\n \n       if not Inserted then\n+         if Container.HT.Lock > 0 then\n+            raise Program_Error;\n+         end if;\n+\n          Position.Node.Key := Key;\n          Position.Node.Element := New_Item;\n       end if;\n@@ -390,11 +430,30 @@ package body Ada.Containers.Hashed_Maps is\n             raise;\n       end New_Node;\n \n+      HT : Hash_Table_Type renames Container.HT;\n+\n    --  Start of processing for Insert\n \n    begin\n-      HT_Ops.Ensure_Capacity (Container, Container.Length + 1);\n-      Local_Insert (Container, Key, Position.Node, Inserted);\n+      if HT.Length >= HT_Ops.Capacity (HT) then\n+\n+         --  TODO: 17 Apr 2005\n+         --  We should defer the expansion until we're sure that the\n+         --  element was successfully inserted.  We can do that by\n+         --  first performing the insertion attempt, and allowing the\n+         --  invariant len <= cap to be violated temporarily.  After\n+         --  the insertion we can restore the invariant.  The\n+         --  worst that can happen is that the insertion succeeds\n+         --  (new element is added to the map), but the\n+         --  invariant is broken (len > cap).  But it's only\n+         --  broken by a little (since len = cap + 1), so the\n+         --  effect is benign.\n+         --  END TODO.\n+\n+         HT_Ops.Reserve_Capacity (HT, HT.Length + 1);\n+      end if;\n+\n+      Local_Insert (HT, Key, Position.Node, Inserted);\n       Position.Container := Container'Unchecked_Access;\n    end Insert;\n \n@@ -421,11 +480,17 @@ package body Ada.Containers.Hashed_Maps is\n          return Node;\n       end New_Node;\n \n+      HT : Hash_Table_Type renames Container.HT;\n+\n    --  Start of processing for Insert\n \n    begin\n-      HT_Ops.Ensure_Capacity (Container, Container.Length + 1);\n-      Local_Insert (Container, Key, Position.Node, Inserted);\n+      if HT.Length >= HT_Ops.Capacity (HT) then\n+         --  TODO: see note above.\n+         HT_Ops.Reserve_Capacity (HT, HT.Length + 1);\n+      end if;\n+\n+      Local_Insert (HT, Key, Position.Node, Inserted);\n       Position.Container := Container'Unchecked_Access;\n    end Insert;\n \n@@ -451,7 +516,7 @@ package body Ada.Containers.Hashed_Maps is\n \n    function Is_Empty (Container : Map) return Boolean is\n    begin\n-      return Container.Length = 0;\n+      return Container.HT.Length = 0;\n    end Is_Empty;\n \n    -------------\n@@ -479,7 +544,7 @@ package body Ada.Containers.Hashed_Maps is\n    --  Start of processing for Iterate\n \n    begin\n-      Local_Iterate (Container);\n+      Local_Iterate (Container.HT);\n    end Iterate;\n \n    ---------\n@@ -488,6 +553,7 @@ package body Ada.Containers.Hashed_Maps is\n \n    function Key (Position : Cursor) return Key_Type is\n    begin\n+      pragma Assert (Vet (Position));\n       return Position.Node.Key;\n    end Key;\n \n@@ -497,7 +563,7 @@ package body Ada.Containers.Hashed_Maps is\n \n    function Length (Container : Map) return Count_Type is\n    begin\n-      return Container.Length;\n+      return Container.HT.Length;\n    end Length;\n \n    ----------\n@@ -506,7 +572,11 @@ package body Ada.Containers.Hashed_Maps is\n \n    procedure Move\n      (Target : in out Map;\n-      Source : in out Map) renames HT_Ops.Move;\n+      Source : in out Map)\n+   is\n+   begin\n+      HT_Ops.Move (Target => Target.HT, Source => Source.HT);\n+   end Move;\n \n    ----------\n    -- Next --\n@@ -519,13 +589,15 @@ package body Ada.Containers.Hashed_Maps is\n \n    function Next (Position : Cursor) return Cursor is\n    begin\n-      if Position = No_Element then\n+      if Position.Node = null then\n+         pragma Assert (Position.Container = null);\n          return No_Element;\n       end if;\n \n       declare\n-         M    : Map renames Position.Container.all;\n-         Node : constant Node_Access := HT_Ops.Next (M, Position.Node);\n+         pragma Assert (Vet (Position));\n+         HT   : Hash_Table_Type renames Position.Container.HT;\n+         Node : constant Node_Access := HT_Ops.Next (HT, Position.Node);\n \n       begin\n          if Node = null then\n@@ -547,10 +619,36 @@ package body Ada.Containers.Hashed_Maps is\n \n    procedure Query_Element\n      (Position : Cursor;\n-      Process  : not null access procedure (Element : Element_Type))\n+      Process  : not null access\n+                   procedure (Key : Key_Type; Element : Element_Type))\n+\n    is\n+      pragma Assert (Vet (Position));\n+\n+      K : Key_Type renames Position.Node.Key;\n+      E : Element_Type renames Position.Node.Element;\n+\n+      M  : Map renames Position.Container.all;\n+      HT : Hash_Table_Type renames M.HT'Unrestricted_Access.all;\n+\n+      B : Natural renames HT.Busy;\n+      L : Natural renames HT.Lock;\n+\n    begin\n-      Process (Position.Node.Key, Position.Node.Element);\n+      B := B + 1;\n+      L := L + 1;\n+\n+      begin\n+         Process (K, E);\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      L := L - 1;\n+      B := B - 1;\n    end Query_Element;\n \n    ----------\n@@ -559,7 +657,11 @@ package body Ada.Containers.Hashed_Maps is\n \n    procedure Read\n      (Stream    : access Root_Stream_Type'Class;\n-      Container : out Map) renames Read_Nodes;\n+      Container : out Map)\n+   is\n+   begin\n+      Read_Nodes (Stream, Container.HT);\n+   end Read;\n \n    ---------------\n    -- Read_Node --\n@@ -590,13 +692,17 @@ package body Ada.Containers.Hashed_Maps is\n       Key       : Key_Type;\n       New_Item  : Element_Type)\n    is\n-      Node : constant Node_Access := Key_Ops.Find (Container, Key);\n+      Node : constant Node_Access := Key_Ops.Find (Container.HT, Key);\n \n    begin\n       if Node = null then\n          raise Constraint_Error;\n       end if;\n \n+      if Container.HT.Lock > 0 then\n+         raise Program_Error;\n+      end if;\n+\n       Node.Key := Key;\n       Node.Element := New_Item;\n    end Replace;\n@@ -606,8 +712,15 @@ package body Ada.Containers.Hashed_Maps is\n    ---------------------\n \n    procedure Replace_Element (Position : Cursor; By : Element_Type) is\n+      pragma Assert (Vet (Position));\n+      E : Element_Type renames Position.Node.Element;\n+\n    begin\n-      Position.Node.Element := By;\n+      if Position.Container.HT.Lock > 0 then\n+         raise Program_Error;\n+      end if;\n+\n+      E := By;\n    end Replace_Element;\n \n    ----------------------\n@@ -616,7 +729,11 @@ package body Ada.Containers.Hashed_Maps is\n \n    procedure Reserve_Capacity\n      (Container : in out Map;\n-      Capacity  : Count_Type) renames HT_Ops.Ensure_Capacity;\n+      Capacity  : Count_Type)\n+   is\n+   begin\n+      HT_Ops.Reserve_Capacity (Container.HT, Capacity);\n+   end Reserve_Capacity;\n \n    --------------\n    -- Set_Next --\n@@ -633,19 +750,105 @@ package body Ada.Containers.Hashed_Maps is\n \n    procedure Update_Element\n      (Position : Cursor;\n-      Process  : not null access procedure (Element : in out Element_Type))\n+      Process  : not null access procedure (Key     : Key_Type;\n+                                            Element : in out Element_Type))\n    is\n+      pragma Assert (Vet (Position));\n+\n+      K : Key_Type renames Position.Node.Key;\n+      E : Element_Type renames Position.Node.Element;\n+\n+      M  : Map renames Position.Container.all;\n+      HT : Hash_Table_Type renames M.HT'Unrestricted_Access.all;\n+\n+      B : Natural renames HT.Busy;\n+      L : Natural renames HT.Lock;\n+\n    begin\n-      Process (Position.Node.Key, Position.Node.Element);\n+      B := B + 1;\n+      L := L + 1;\n+\n+      begin\n+         Process (K, E);\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      L := L - 1;\n+      B := B - 1;\n    end Update_Element;\n \n+   ---------\n+   -- Vet --\n+   ---------\n+\n+   function Vet (Position : Cursor) return Boolean is\n+   begin\n+      if Position.Node = null then\n+         return False;\n+      end if;\n+\n+      if Position.Node.Next = Position.Node then\n+         return False;\n+      end if;\n+\n+      if Position.Container = null then\n+         return False;\n+      end if;\n+\n+      declare\n+         HT : Hash_Table_Type renames Position.Container.HT;\n+         X  : Node_Access;\n+      begin\n+         if HT.Length = 0 then\n+            return False;\n+         end if;\n+\n+         if HT.Buckets = null then\n+            return False;\n+         end if;\n+\n+--       NOTE: see notes in Insert.\n+--       if HT.Length > HT.Buckets'Length then\n+--          return False;\n+--       end if;\n+\n+         X := HT.Buckets (Key_Ops.Index (HT, Position.Node.Key));\n+\n+         for J in 1 .. HT.Length loop\n+            if X = Position.Node then\n+               return True;\n+            end if;\n+\n+            if X = null then\n+               return False;\n+            end if;\n+\n+            if X = X.Next then  --  weird\n+               return False;\n+            end if;\n+\n+            X := X.Next;\n+         end loop;\n+\n+         return False;\n+      end;\n+   end Vet;\n+\n    -----------\n    -- Write --\n    -----------\n \n    procedure Write\n      (Stream    : access Root_Stream_Type'Class;\n-      Container : Map) renames Write_Nodes;\n+      Container : Map)\n+   is\n+   begin\n+      Write_Nodes (Stream, Container.HT);\n+   end Write;\n \n    ----------------\n    -- Write_Node --"}, {"sha": "ceb845b2fbbf5b2df697e36519b027c636e18fbc", "filename": "gcc/ada/a-cohama.ads", "status": "modified", "additions": 46, "deletions": 23, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-cohama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-cohama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohama.ads?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---                        ADA.CONTAINERS.HASHED_MAPS                        --\n+--            A D A . C O N T A I N E R S . H A S H E D _ M A P S           --\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -35,6 +35,7 @@\n \n with Ada.Containers.Hash_Tables;\n with Ada.Streams;\n+with Ada.Finalization;\n \n generic\n    type Key_Type is private;\n@@ -66,8 +67,9 @@ pragma Preelaborate (Hashed_Maps);\n \n    procedure Clear (Container : in out Map);\n \n-   function Element (Position : Cursor)\n-      return Element_Type;\n+   function Key (Position : Cursor) return Key_Type;\n+\n+   function Element (Position : Cursor) return Element_Type;\n \n    procedure Query_Element\n      (Position : Cursor;\n@@ -93,41 +95,36 @@ pragma Preelaborate (Hashed_Maps);\n    procedure Insert\n      (Container : in out Map;\n       Key       : Key_Type;\n-      New_Item  : Element_Type);\n+      Position  : out Cursor;\n+      Inserted  : out Boolean);\n \n-   procedure Include\n+   procedure Insert\n      (Container : in out Map;\n       Key       : Key_Type;\n       New_Item  : Element_Type);\n \n-   procedure Replace\n+   procedure Include\n      (Container : in out Map;\n       Key       : Key_Type;\n       New_Item  : Element_Type);\n \n-   procedure Insert\n+   procedure Replace\n      (Container : in out Map;\n       Key       : Key_Type;\n-      Position  : out Cursor;\n-      Inserted  : out Boolean);\n+      New_Item  : Element_Type);\n \n    procedure Delete (Container : in out Map; Key : Key_Type);\n \n-   procedure Exclude (Container : in out Map; Key : Key_Type);\n-\n    procedure Delete (Container : in out Map; Position : in out Cursor);\n \n+   procedure Exclude (Container : in out Map; Key : Key_Type);\n+\n    function Contains (Container : Map; Key : Key_Type) return Boolean;\n \n    function Find (Container : Map; Key : Key_Type) return Cursor;\n \n    function Element (Container : Map; Key : Key_Type) return Element_Type;\n \n-   function Capacity (Container : Map) return Count_Type;\n-\n-   procedure Reserve_Capacity (Container : in out Map;\n-                               Capacity  : Count_Type);\n-\n    function First (Container : Map) return Cursor;\n \n    function Next (Position : Cursor) return Cursor;\n@@ -136,8 +133,6 @@ pragma Preelaborate (Hashed_Maps);\n \n    function Has_Element (Position : Cursor) return Boolean;\n \n-   function Key (Position : Cursor) return Key_Type;\n-\n    function Equivalent_Keys (Left, Right : Cursor) return Boolean;\n \n    function Equivalent_Keys (Left : Cursor; Right : Key_Type) return Boolean;\n@@ -148,16 +143,44 @@ pragma Preelaborate (Hashed_Maps);\n      (Container : Map;\n       Process   : not null access procedure (Position : Cursor));\n \n+   function Capacity (Container : Map) return Count_Type;\n+\n+   procedure Reserve_Capacity (Container : in out Map;\n+                               Capacity  : Count_Type);\n+\n private\n+   pragma Inline (\"=\");\n+   pragma Inline (Length);\n+   pragma Inline (Is_Empty);\n+   pragma Inline (Clear);\n+   pragma Inline (Key);\n+   pragma Inline (Element);\n+   pragma Inline (Move);\n+   pragma Inline (Contains);\n+   pragma Inline (Capacity);\n+   pragma Inline (Reserve_Capacity);\n+   pragma Inline (Has_Element);\n+   pragma Inline (Equivalent_Keys);\n \n    type Node_Type;\n    type Node_Access is access Node_Type;\n \n-   package HT_Types is new Hash_Tables.Generic_Hash_Table_Types (Node_Access);\n+   type Node_Type is limited record\n+      Key     : Key_Type;\n+      Element : Element_Type;\n+      Next    : Node_Access;\n+   end record;\n \n-   use HT_Types;\n+   package HT_Types is new Hash_Tables.Generic_Hash_Table_Types\n+     (Node_Type,\n+      Node_Access);\n \n-   type Map is new Hash_Table_Type with null record;\n+   type Map is new Ada.Finalization.Controlled with record\n+      HT : HT_Types.Hash_Table_Type;\n+   end record;\n+\n+   use HT_Types;\n+   use Ada.Finalization;\n \n    procedure Adjust (Container : in out Map);\n \n@@ -177,7 +200,7 @@ private\n \n    for Map'Read use Read;\n \n-   Empty_Map : constant Map := (Hash_Table_Type with null record);\n+   Empty_Map : constant Map := (Controlled with HT => (null, 0, 0, 0));\n \n    type Map_Access is access constant Map;\n    for Map_Access'Storage_Size use 0;"}, {"sha": "7684ace45460526f25af602b6d5984acf74d371e", "filename": "gcc/ada/a-cohase.adb", "status": "modified", "additions": 1168, "deletions": 844, "changes": 2012, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-cohase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-cohase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohase.adb?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---                        ADA.CONTAINERS.HASHED_SETS                        --\n+--           A D A . C O N T A I N E R S . H A S H E D _ S E T S            --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -41,828 +41,1173 @@ pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Operations);\n with Ada.Containers.Hash_Tables.Generic_Keys;\n pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Keys);\n \n-with System;  use type System.Address;\n-\n with Ada.Containers.Prime_Numbers;\n \n-with Ada.Finalization;  use Ada.Finalization;\n+with System; use type System.Address;\n \n package body Ada.Containers.Hashed_Sets is\n \n-   type Node_Type is\n-      limited record\n-         Element : Element_Type;\n-         Next    : Node_Access;\n-      end record;\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n \n-   function Hash_Node\n-     (Node : Node_Access) return Hash_Type;\n-   pragma Inline (Hash_Node);\n+   function Copy_Node (Source : Node_Access) return Node_Access;\n+   pragma Inline (Copy_Node);\n \n-   function Hash_Node\n-     (Node : Node_Access) return Hash_Type is\n-   begin\n-      return Hash (Node.Element);\n-   end Hash_Node;\n+   function Equivalent_Keys\n+     (Key  : Element_Type;\n+      Node : Node_Access) return Boolean;\n+   pragma Inline (Equivalent_Keys);\n \n-   function Next\n-     (Node : Node_Access) return Node_Access;\n-   pragma Inline (Next);\n+   function Find_Equal_Key\n+     (R_HT   : Hash_Table_Type;\n+      L_Node : Node_Access) return Boolean;\n \n-   function Next\n-     (Node : Node_Access) return Node_Access is\n-   begin\n-      return Node.Next;\n-   end Next;\n+   function Find_Equivalent_Key\n+     (R_HT   : Hash_Table_Type;\n+      L_Node : Node_Access) return Boolean;\n \n-   procedure Set_Next\n-     (Node : Node_Access;\n-      Next : Node_Access);\n-   pragma Inline (Set_Next);\n+   function Hash_Node (Node : Node_Access) return Hash_Type;\n+   pragma Inline (Hash_Node);\n \n-   procedure Set_Next\n-     (Node : Node_Access;\n-      Next : Node_Access) is\n-   begin\n-      Node.Next := Next;\n-   end Set_Next;\n+   function Is_In\n+     (HT  : Hash_Table_Type;\n+      Key : Node_Access) return Boolean;\n+   pragma Inline (Is_In);\n \n-   function Equivalent_Keys\n-     (Key  : Element_Type;\n-      Node : Node_Access) return Boolean;\n-   pragma Inline (Equivalent_Keys);\n+   function Next (Node : Node_Access) return Node_Access;\n+   pragma Inline (Next);\n \n-   function Equivalent_Keys\n-     (Key  : Element_Type;\n-      Node : Node_Access) return Boolean is\n-   begin\n-      return Equivalent_Keys (Key, Node.Element);\n-   end Equivalent_Keys;\n+   function Read_Node (Stream : access Root_Stream_Type'Class)\n+     return Node_Access;\n+   pragma Inline (Read_Node);\n \n-   function Copy_Node\n-     (Source : Node_Access) return Node_Access;\n-   pragma Inline (Copy_Node);\n+   procedure Replace_Element\n+     (HT      : in out Hash_Table_Type;\n+      Node    : Node_Access;\n+      Element : Element_Type);\n \n-   function Copy_Node\n-     (Source : Node_Access) return Node_Access is\n+   procedure Set_Next (Node : Node_Access; Next : Node_Access);\n+   pragma Inline (Set_Next);\n \n-      Target : constant Node_Access :=\n-        new Node_Type'(Element => Source.Element,\n-                       Next    => null);\n-   begin\n-      return Target;\n-   end Copy_Node;\n+   procedure Write_Node\n+     (Stream : access Root_Stream_Type'Class;\n+      Node   : Node_Access);\n+   pragma Inline (Write_Node);\n \n+   --------------------------\n+   -- Local Instantiations --\n+   --------------------------\n \n    procedure Free is\n       new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n \n    package HT_Ops is\n       new Hash_Tables.Generic_Operations\n-       (HT_Types          => HT_Types,\n-        Hash_Table_Type   => Set,\n-        Null_Node         => null,\n-        Hash_Node         => Hash_Node,\n-        Next              => Next,\n-        Set_Next          => Set_Next,\n-        Copy_Node         => Copy_Node,\n-        Free              => Free);\n+       (HT_Types  => HT_Types,\n+        Hash_Node => Hash_Node,\n+        Next      => Next,\n+        Set_Next  => Set_Next,\n+        Copy_Node => Copy_Node,\n+        Free      => Free);\n \n    package Element_Keys is\n       new Hash_Tables.Generic_Keys\n        (HT_Types  => HT_Types,\n-        HT_Type   => Set,\n-        Null_Node => null,\n         Next      => Next,\n         Set_Next  => Set_Next,\n         Key_Type  => Element_Type,\n         Hash      => Hash,\n         Equivalent_Keys => Equivalent_Keys);\n \n+   function Is_Equal is\n+      new HT_Ops.Generic_Equal (Find_Equal_Key);\n \n-   procedure Adjust (Container : in out Set) renames HT_Ops.Adjust;\n-\n-   procedure Finalize (Container : in out Set) renames HT_Ops.Finalize;\n-\n-\n-   function Find_Equal_Key\n-     (R_Set  : Set;\n-      L_Node : Node_Access) return Boolean;\n+   function Is_Equivalent is\n+      new HT_Ops.Generic_Equal (Find_Equivalent_Key);\n \n-   function Find_Equal_Key\n-     (R_Set  : Set;\n-      L_Node : Node_Access) return Boolean is\n+   procedure Read_Nodes is\n+      new HT_Ops.Generic_Read (Read_Node);\n \n-      R_Index : constant Hash_Type :=\n-        Element_Keys.Index (R_Set, L_Node.Element);\n+   procedure Write_Nodes is\n+      new HT_Ops.Generic_Write (Write_Node);\n \n-      R_Node  : Node_Access := R_Set.Buckets (R_Index);\n+   ---------\n+   -- \"=\" --\n+   ---------\n \n+   function \"=\" (Left, Right : Set) return Boolean is\n    begin\n+      return Is_Equal (Left.HT, Right.HT);\n+   end \"=\";\n \n-      loop\n+   ------------\n+   -- Adjust --\n+   ------------\n \n-         if R_Node = null then\n-            return False;\n-         end if;\n+   procedure Adjust (Container : in out Set) is\n+   begin\n+      HT_Ops.Adjust (Container.HT);\n+   end Adjust;\n \n-         if L_Node.Element = R_Node.Element then\n-            --  pragma Assert (Is_Equal_Key (L_Node.Element, R_Node.Element));\n-            return True;\n-         end if;\n+   --------------\n+   -- Capacity --\n+   --------------\n \n-         R_Node := Next (R_Node);\n+   function Capacity (Container : Set) return Count_Type is\n+   begin\n+      return HT_Ops.Capacity (Container.HT);\n+   end Capacity;\n \n-      end loop;\n+   -----------\n+   -- Clear --\n+   -----------\n \n-   end Find_Equal_Key;\n+   procedure Clear (Container : in out Set) is\n+   begin\n+      HT_Ops.Clear (Container.HT);\n+   end Clear;\n \n-   function Is_Equal is\n-      new HT_Ops.Generic_Equal (Find_Equal_Key);\n+   --------------\n+   -- Contains --\n+   --------------\n \n-   function \"=\" (Left, Right : Set) return Boolean renames Is_Equal;\n+   function Contains (Container : Set; Item : Element_Type) return Boolean is\n+   begin\n+      return Find (Container, Item) /= No_Element;\n+   end Contains;\n \n+   ---------------\n+   -- Copy_Node --\n+   ---------------\n \n-   function Length (Container : Set) return Count_Type is\n+   function Copy_Node (Source : Node_Access) return Node_Access is\n    begin\n-      return Container.Length;\n-   end Length;\n+      return new Node_Type'(Element => Source.Element, Next => null);\n+   end Copy_Node;\n \n+   ------------\n+   -- Delete --\n+   ------------\n \n-   function Is_Empty (Container : Set) return Boolean is\n-   begin\n-      return Container.Length = 0;\n-   end Is_Empty;\n+   procedure Delete\n+     (Container : in out Set;\n+      Item      : Element_Type)\n+   is\n+      X : Node_Access;\n \n+   begin\n+      Element_Keys.Delete_Key_Sans_Free (Container.HT, Item, X);\n \n-   procedure Clear (Container : in out Set) renames HT_Ops.Clear;\n+      if X = null then\n+         raise Constraint_Error;\n+      end if;\n \n+      Free (X);\n+   end Delete;\n \n-   function Element (Position : Cursor) return Element_Type is\n+   procedure Delete\n+     (Container : in out Set;\n+      Position  : in out Cursor)\n+   is\n    begin\n-      return Position.Node.Element;\n-   end Element;\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n \n+      if Position.Container /= Set_Access'(Container'Unchecked_Access) then\n+         raise Program_Error;\n+      end if;\n \n-   procedure Query_Element\n-     (Position : in Cursor;\n-      Process  : not null access procedure (Element : in Element_Type)) is\n-   begin\n-      Process (Position.Node.Element);\n-   end Query_Element;\n+      if Container.HT.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n \n+      HT_Ops.Delete_Node_Sans_Free (Container.HT, Position.Node);\n \n---  TODO:\n---     procedure Replace_Element (Container : in out Set;\n---                                Position  : in     Node_Access;\n---                                By        : in     Element_Type) is\n+      Free (Position.Node);\n \n---        Node : Node_Access := Position;\n+      Position.Container := null;\n+   end Delete;\n \n---     begin\n+   ----------------\n+   -- Difference --\n+   ----------------\n \n---        if Equivalent_Keys (Node.Element, By) then\n+   procedure Difference\n+     (Target : in out Set;\n+      Source : Set)\n+   is\n+      Tgt_Node : Node_Access;\n \n---           begin\n---              Node.Element := By;\n---           exception\n---              when others =>\n---                 HT_Ops.Delete_Node_Sans_Free (Container, Node);\n---                 Free (Node);\n---                 raise;\n---           end;\n+   begin\n+      if Target'Address = Source'Address then\n+         Clear (Target);\n+         return;\n+      end if;\n \n---           return;\n+      if Source.Length = 0 then\n+         return;\n+      end if;\n \n---        end if;\n+      if Target.HT.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n \n---        HT_Ops.Delete_Node_Sans_Free (Container, Node);\n+      --  TODO: This can be written in terms of a loop instead as\n+      --  active-iterator style, sort of like a passive iterator.\n \n---        begin\n---           Node.Element := By;\n---        exception\n---           when others =>\n---              Free (Node);\n---              raise;\n---        end;\n+      Tgt_Node := HT_Ops.First (Target.HT);\n+      while Tgt_Node /= null loop\n+         if Is_In (Source.HT, Tgt_Node) then\n+            declare\n+               X : Node_Access := Tgt_Node;\n+            begin\n+               Tgt_Node := HT_Ops.Next (Target.HT, Tgt_Node);\n+               HT_Ops.Delete_Node_Sans_Free (Target.HT, X);\n+               Free (X);\n+            end;\n \n---        declare\n---           function New_Node (Next : Node_Access) return Node_Access;\n---           pragma Inline (New_Node);\n+         else\n+            Tgt_Node := HT_Ops.Next (Target.HT, Tgt_Node);\n+         end if;\n+      end loop;\n+   end Difference;\n \n---           function New_Node (Next : Node_Access) return Node_Access is\n---           begin\n---              Node.Next := Next;\n---              return Node;\n---           end New_Node;\n+   function Difference (Left, Right : Set) return Set is\n+      Buckets : HT_Types.Buckets_Access;\n+      Length  : Count_Type;\n \n---           procedure Insert is\n---              new Element_Keys.Generic_Conditional_Insert (New_Node);\n+   begin\n+      if Left'Address = Right'Address then\n+         return Empty_Set;\n+      end if;\n \n---           Result  : Node_Access;\n---           Success : Boolean;\n---        begin\n---           Insert\n---             (HT      => Container,\n---              Key     => Node.Element,\n---              Node    => Result,\n---              Success => Success);\n+      if Left.Length = 0 then\n+         return Empty_Set;\n+      end if;\n \n---           if not Success then\n---              Free (Node);\n---              raise Program_Error;\n---           end if;\n+      if Right.Length = 0 then\n+         return Left;\n+      end if;\n \n---           pragma Assert (Result = Node);\n---        end;\n+      declare\n+         Size : constant Hash_Type := Prime_Numbers.To_Prime (Left.Length);\n+      begin\n+         Buckets := new Buckets_Type (0 .. Size - 1);\n+      end;\n \n---     end Replace_Element;\n+      Length := 0;\n \n+      Iterate_Left : declare\n+         procedure Process (L_Node : Node_Access);\n \n---     procedure Replace_Element (Container : in out Set;\n---                                Position  : in     Cursor;\n---                                By        : in     Element_Type) is\n---     begin\n+         procedure Iterate is\n+            new HT_Ops.Generic_Iteration (Process);\n \n---        if Position.Container = null then\n---           raise Constraint_Error;\n---        end if;\n+         -------------\n+         -- Process --\n+         -------------\n \n---        if Position.Container /= Set_Access'(Container'Unchecked_Access) then\n---           raise Program_Error;\n---        end if;\n+         procedure Process (L_Node : Node_Access) is\n+         begin\n+            if not Is_In (Right.HT, L_Node) then\n+               declare\n+                  J : constant Hash_Type :=\n+                        Hash (L_Node.Element) mod Buckets'Length;\n \n---        Replace_Element (Container, Position.Node, By);\n+                  Bucket : Node_Access renames Buckets (J);\n \n---     end Replace_Element;\n+               begin\n+                  Bucket := new Node_Type'(L_Node.Element, Bucket);\n+               end;\n \n+               Length := Length + 1;\n+            end if;\n+         end Process;\n \n-   procedure Move (Target : in out Set;\n-                   Source : in out Set) renames HT_Ops.Move;\n+      --  Start of processing for Iterate_Left\n \n+      begin\n+         Iterate (Left.HT);\n+      exception\n+         when others =>\n+            HT_Ops.Free_Hash_Table (Buckets);\n+            raise;\n+      end Iterate_Left;\n \n-   procedure Insert (Container : in out Set;\n-                     New_Item  : in     Element_Type;\n-                     Position  :    out Cursor;\n-                     Inserted  :    out Boolean) is\n+      return (Controlled with HT => (Buckets, Length, 0, 0));\n+   end Difference;\n \n-      function New_Node (Next : Node_Access) return Node_Access;\n-      pragma Inline (New_Node);\n+   -------------\n+   -- Element --\n+   -------------\n \n-      function New_Node (Next : Node_Access) return Node_Access is\n-         Node : constant Node_Access := new Node_Type'(New_Item, Next);\n-      begin\n-         return Node;\n-      end New_Node;\n+   function Element (Position : Cursor) return Element_Type is\n+   begin\n+      return Position.Node.Element;\n+   end Element;\n \n-      procedure Insert is\n-        new Element_Keys.Generic_Conditional_Insert (New_Node);\n+   ---------------------\n+   -- Equivalent_Sets --\n+   ---------------------\n \n+   function Equivalent_Sets (Left, Right : Set) return Boolean is\n    begin\n+      return Is_Equivalent (Left.HT, Right.HT);\n+   end Equivalent_Sets;\n \n-      HT_Ops.Ensure_Capacity (Container, Container.Length + 1);\n-      Insert (Container, New_Item, Position.Node, Inserted);\n-      Position.Container := Container'Unchecked_Access;\n+   -------------------------\n+   -- Equivalent_Elements --\n+   -------------------------\n \n-   end Insert;\n+   function Equivalent_Elements (Left, Right : Cursor)\n+     return Boolean is\n+   begin\n+      return Equivalent_Elements (Left.Node.Element, Right.Node.Element);\n+   end Equivalent_Elements;\n \n+   function Equivalent_Elements (Left : Cursor; Right : Element_Type)\n+     return Boolean is\n+   begin\n+      return Equivalent_Elements (Left.Node.Element, Right);\n+   end Equivalent_Elements;\n \n-   procedure Insert (Container : in out Set;\n-                     New_Item  : in     Element_Type) is\n+   function Equivalent_Elements (Left : Element_Type; Right : Cursor)\n+     return Boolean is\n+   begin\n+      return Equivalent_Elements (Left, Right.Node.Element);\n+   end Equivalent_Elements;\n \n-      Position : Cursor;\n-      Inserted : Boolean;\n+   ---------------------\n+   -- Equivalent_Keys --\n+   ---------------------\n \n+   function Equivalent_Keys (Key : Element_Type; Node : Node_Access)\n+     return Boolean is\n    begin\n+      return Equivalent_Elements (Key, Node.Element);\n+   end Equivalent_Keys;\n \n-      Insert (Container, New_Item, Position, Inserted);\n+   -------------\n+   -- Exclude --\n+   -------------\n \n-      if not Inserted then\n-         raise Constraint_Error;\n-      end if;\n+   procedure Exclude\n+     (Container : in out Set;\n+      Item      : Element_Type)\n+   is\n+      X : Node_Access;\n+   begin\n+      Element_Keys.Delete_Key_Sans_Free (Container.HT, Item, X);\n+      Free (X);\n+   end Exclude;\n \n-   end Insert;\n+   --------------\n+   -- Finalize --\n+   --------------\n \n+   procedure Finalize (Container : in out Set) is\n+   begin\n+      HT_Ops.Finalize (Container.HT);\n+   end Finalize;\n \n-   procedure Replace (Container : in out Set;\n-                      New_Item  : in     Element_Type) is\n+   ----------\n+   -- Find --\n+   ----------\n \n-      X : Node_Access := Element_Keys.Find (Container, New_Item);\n+   function Find\n+     (Container : Set;\n+      Item      : Element_Type) return Cursor\n+   is\n+      Node : constant Node_Access := Element_Keys.Find (Container.HT, Item);\n \n    begin\n-\n-      if X = null then\n-         raise Constraint_Error;\n+      if Node = null then\n+         return No_Element;\n       end if;\n \n-      X.Element := New_Item;\n-\n-   end Replace;\n+      return Cursor'(Container'Unrestricted_Access, Node);\n+   end Find;\n \n+   --------------------\n+   -- Find_Equal_Key --\n+   --------------------\n \n-   procedure Include (Container : in out Set;\n-                      New_Item  : in     Element_Type) is\n+   function Find_Equal_Key\n+     (R_HT   : Hash_Table_Type;\n+      L_Node : Node_Access) return Boolean\n+   is\n+      R_Index : constant Hash_Type :=\n+                  Element_Keys.Index (R_HT, L_Node.Element);\n \n-      Position : Cursor;\n-      Inserted : Boolean;\n+      R_Node  : Node_Access := R_HT.Buckets (R_Index);\n \n    begin\n+      loop\n+         if R_Node = null then\n+            return False;\n+         end if;\n \n-      Insert (Container, New_Item, Position, Inserted);\n-\n-      if not Inserted then\n-         Position.Node.Element := New_Item;\n-      end if;\n+         if L_Node.Element = R_Node.Element then\n+            return True;\n+         end if;\n \n-   end Include;\n+         R_Node := Next (R_Node);\n+      end loop;\n+   end Find_Equal_Key;\n \n+   -------------------------\n+   -- Find_Equivalent_Key --\n+   -------------------------\n \n-   procedure Delete (Container : in out Set;\n-                     Item      : in     Element_Type) is\n+   function Find_Equivalent_Key\n+     (R_HT   : Hash_Table_Type;\n+      L_Node : Node_Access) return Boolean\n+   is\n+      R_Index : constant Hash_Type :=\n+                  Element_Keys.Index (R_HT, L_Node.Element);\n \n-      X : Node_Access;\n+      R_Node  : Node_Access := R_HT.Buckets (R_Index);\n \n    begin\n+      loop\n+         if R_Node = null then\n+            return False;\n+         end if;\n \n-      Element_Keys.Delete_Key_Sans_Free (Container, Item, X);\n+         if Equivalent_Elements (L_Node.Element, R_Node.Element) then\n+            return True;\n+         end if;\n \n-      if X = null then\n-         raise Constraint_Error;\n-      end if;\n+         R_Node := Next (R_Node);\n+      end loop;\n+   end Find_Equivalent_Key;\n \n-      Free (X);\n+   -----------\n+   -- First --\n+   -----------\n \n-   end Delete;\n+   function First (Container : Set) return Cursor is\n+      Node : constant Node_Access := HT_Ops.First (Container.HT);\n \n+   begin\n+      if Node = null then\n+         return No_Element;\n+      end if;\n \n-   procedure Exclude (Container : in out Set;\n-                      Item      : in     Element_Type) is\n+      return Cursor'(Container'Unrestricted_Access, Node);\n+   end First;\n \n-      X : Node_Access;\n+   -----------------\n+   -- Has_Element --\n+   -----------------\n \n+   function Has_Element (Position : Cursor) return Boolean is\n    begin\n+      if Position.Node = null then\n+         pragma Assert (Position.Container = null);\n+         return False;\n+      end if;\n \n-      Element_Keys.Delete_Key_Sans_Free (Container, Item, X);\n-      Free (X);\n-\n-   end Exclude;\n+      return True;\n+   end Has_Element;\n \n+   ---------------\n+   -- Hash_Node --\n+   ---------------\n \n-   procedure Delete (Container : in out Set;\n-                     Position  : in out Cursor) is\n+   function Hash_Node (Node : Node_Access) return Hash_Type is\n    begin\n+      return Hash (Node.Element);\n+   end Hash_Node;\n \n-      if Position = No_Element then\n-         return;\n-      end if;\n+   -------------\n+   -- Include --\n+   -------------\n \n-      if Position.Container /= Set_Access'(Container'Unchecked_Access) then\n-         raise Program_Error;\n+   procedure Include\n+     (Container : in out Set;\n+      New_Item  : Element_Type)\n+   is\n+      Position : Cursor;\n+      Inserted : Boolean;\n+\n+   begin\n+      Insert (Container, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+         if Container.HT.Lock > 0 then\n+            raise Program_Error;\n+         end if;\n+\n+         Position.Node.Element := New_Item;\n       end if;\n+   end Include;\n \n-      HT_Ops.Delete_Node_Sans_Free (Container, Position.Node);\n-      Free (Position.Node);\n+   ------------\n+   -- Insert --\n+   ------------\n \n-      Position.Container := null;\n+   procedure Insert\n+     (Container : in out Set;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean)\n+   is\n+      function New_Node (Next : Node_Access) return Node_Access;\n+      pragma Inline (New_Node);\n \n-   end Delete;\n+      procedure Local_Insert is\n+        new Element_Keys.Generic_Conditional_Insert (New_Node);\n \n+      --------------\n+      -- New_Node --\n+      --------------\n \n+      function New_Node (Next : Node_Access) return Node_Access is\n+         Node : constant Node_Access := new Node_Type'(New_Item, Next);\n+      begin\n+         return Node;\n+      end New_Node;\n \n-   procedure Union (Target : in out Set;\n-                    Source : in     Set) is\n+      HT : Hash_Table_Type renames Container.HT;\n \n-      procedure Process (Src_Node : in Node_Access);\n+   --  Start of processing for Insert\n \n-      procedure Process (Src_Node : in Node_Access) is\n+   begin\n+      if HT.Length >= HT_Ops.Capacity (HT) then\n \n-         function New_Node (Next : Node_Access) return Node_Access;\n-         pragma Inline (New_Node);\n+         --  TODO:\n+         --  Perform the insertion first, and then reserve\n+         --  capacity, but only if the insertion succeeds and\n+         --  the (new) length is greater then current capacity.\n+         --  END TODO.\n \n-         function New_Node (Next : Node_Access) return Node_Access is\n-            Node : constant Node_Access :=\n-              new Node_Type'(Src_Node.Element, Next);\n-         begin\n-            return Node;\n-         end New_Node;\n+         HT_Ops.Reserve_Capacity (HT, HT.Length + 1);\n+      end if;\n \n-         procedure Insert is\n-            new Element_Keys.Generic_Conditional_Insert (New_Node);\n+      Local_Insert (HT, New_Item, Position.Node, Inserted);\n+      Position.Container := Container'Unchecked_Access;\n+   end Insert;\n \n-         Tgt_Node : Node_Access;\n-         Success  : Boolean;\n+   procedure Insert\n+     (Container : in out Set;\n+      New_Item  : Element_Type)\n+   is\n+      Position : Cursor;\n+      Inserted : Boolean;\n \n-      begin\n+   begin\n+      Insert (Container, New_Item, Position, Inserted);\n \n-         Insert (Target, Src_Node.Element, Tgt_Node, Success);\n+      if not Inserted then\n+         raise Constraint_Error;\n+      end if;\n+   end Insert;\n \n-      end Process;\n+   ------------------\n+   -- Intersection --\n+   ------------------\n \n-      procedure Iterate is\n-         new HT_Ops.Generic_Iteration (Process);\n+   procedure Intersection\n+     (Target : in out Set;\n+      Source : Set)\n+   is\n+      Tgt_Node : Node_Access;\n \n    begin\n-\n       if Target'Address = Source'Address then\n          return;\n       end if;\n \n-      HT_Ops.Ensure_Capacity (Target, Target.Length + Source.Length);\n-\n-      Iterate (Source);\n+      if Source.Length = 0 then\n+         Clear (Target);\n+         return;\n+      end if;\n \n-   end Union;\n+      if Target.HT.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n \n+      --  TODO: optimize this to use an explicit\n+      --  loop instead of an active iterator\n+      --  (similar to how a passive iterator is\n+      --  implemented).\n+      --\n+      --  Another possibility is to test which\n+      --  set is smaller, and iterate over the\n+      --  smaller set.\n \n+      Tgt_Node := HT_Ops.First (Target.HT);\n+      while Tgt_Node /= null loop\n+         if Is_In (Source.HT, Tgt_Node) then\n+            Tgt_Node := HT_Ops.Next (Target.HT, Tgt_Node);\n \n-   function Union (Left, Right : Set) return Set is\n+         else\n+            declare\n+               X : Node_Access := Tgt_Node;\n+            begin\n+               Tgt_Node := HT_Ops.Next (Target.HT, Tgt_Node);\n+               HT_Ops.Delete_Node_Sans_Free (Target.HT, X);\n+               Free (X);\n+            end;\n+         end if;\n+      end loop;\n+   end Intersection;\n \n+   function Intersection (Left, Right : Set) return Set is\n       Buckets : HT_Types.Buckets_Access;\n       Length  : Count_Type;\n \n    begin\n-\n       if Left'Address = Right'Address then\n          return Left;\n       end if;\n \n-      if Right.Length = 0 then\n-         return Left;\n-      end if;\n+      Length := Count_Type'Min (Left.Length, Right.Length);\n \n-      if Left.Length = 0 then\n-         return Right;\n+      if Length = 0 then\n+         return Empty_Set;\n       end if;\n \n       declare\n-         Size : constant Hash_Type :=\n-           Prime_Numbers.To_Prime (Left.Length + Right.Length);\n+         Size : constant Hash_Type := Prime_Numbers.To_Prime (Length);\n       begin\n          Buckets := new Buckets_Type (0 .. Size - 1);\n       end;\n \n-      declare\n-         procedure Process (L_Node : Node_Access);\n+      Length := 0;\n \n-         procedure Process (L_Node : Node_Access) is\n-            I : constant Hash_Type :=\n-              Hash (L_Node.Element) mod Buckets'Length;\n-         begin\n-            Buckets (I) := new Node_Type'(L_Node.Element, Buckets (I));\n-         end Process;\n+      Iterate_Left : declare\n+         procedure Process (L_Node : Node_Access);\n \n          procedure Iterate is\n             new HT_Ops.Generic_Iteration (Process);\n-      begin\n-         Iterate (Left);\n-      exception\n-         when others =>\n-            HT_Ops.Free_Hash_Table (Buckets);\n-            raise;\n-      end;\n-\n-      Length := Left.Length;\n-\n-      declare\n-         procedure Process (Src_Node : Node_Access);\n-\n-         procedure Process (Src_Node : Node_Access) is\n-\n-            I : constant Hash_Type :=\n-              Hash (Src_Node.Element) mod Buckets'Length;\n \n-            Tgt_Node : Node_Access := Buckets (I);\n+         -------------\n+         -- Process --\n+         -------------\n \n+         procedure Process (L_Node : Node_Access) is\n          begin\n+            if Is_In (Right.HT, L_Node) then\n+               declare\n+                  J : constant Hash_Type :=\n+                        Hash (L_Node.Element) mod Buckets'Length;\n \n-            while Tgt_Node /= null loop\n-\n-               if Equivalent_Keys (Src_Node.Element, Tgt_Node.Element) then\n-                  return;\n-               end if;\n-\n-               Tgt_Node := Next (Tgt_Node);\n+                  Bucket : Node_Access renames Buckets (J);\n \n-            end loop;\n-\n-            Buckets (I) := new Node_Type'(Src_Node.Element, Buckets (I));\n-            Length := Length + 1;\n+               begin\n+                  Bucket := new Node_Type'(L_Node.Element, Bucket);\n+               end;\n \n+               Length := Length + 1;\n+            end if;\n          end Process;\n \n-         procedure Iterate is\n-            new HT_Ops.Generic_Iteration (Process);\n+      --  Start of processing for Iterate_Left\n+\n       begin\n-         Iterate (Right);\n+         Iterate (Left.HT);\n       exception\n          when others =>\n             HT_Ops.Free_Hash_Table (Buckets);\n             raise;\n-      end;\n+      end Iterate_Left;\n \n-      return (Controlled with Buckets, Length);\n+      return (Controlled with HT => (Buckets, Length, 0, 0));\n+   end Intersection;\n \n-   end Union;\n+   --------------\n+   -- Is_Empty --\n+   --------------\n \n+   function Is_Empty (Container : Set) return Boolean is\n+   begin\n+      return Container.Length = 0;\n+   end Is_Empty;\n \n-   function Is_In\n-     (HT  : Set;\n-      Key : Node_Access) return Boolean;\n-   pragma Inline (Is_In);\n+   -----------\n+   -- Is_In --\n+   -----------\n \n-   function Is_In\n-     (HT  : Set;\n-      Key : Node_Access) return Boolean is\n+   function Is_In (HT : Hash_Table_Type; Key : Node_Access) return Boolean is\n    begin\n       return Element_Keys.Find (HT, Key.Element) /= null;\n    end Is_In;\n \n+   ---------------\n+   -- Is_Subset --\n+   ---------------\n \n-   procedure Intersection (Target : in out Set;\n-                           Source : in     Set) is\n-\n-      Tgt_Node : Node_Access;\n+   function Is_Subset (Subset : Set; Of_Set : Set) return Boolean is\n+      Subset_Node : Node_Access;\n \n    begin\n-\n-      if Target'Address = Source'Address then\n-         return;\n+      if Subset'Address = Of_Set'Address then\n+         return True;\n       end if;\n \n-      if Source.Length = 0 then\n-         Clear (Target);\n-         return;\n+      if Subset.Length > Of_Set.Length then\n+         return False;\n       end if;\n \n-      --  TODO: optimize this to use an explicit\n-      --  loop instead of an active iterator\n-      --  (similar to how a passive iterator is\n-      --  implemented).\n-      --\n-      --  Another possibility is to test which\n-      --  set is smaller, and iterate over the\n-      --  smaller set.\n+      --  TODO: rewrite this to loop in the\n+      --  style of a passive iterator.\n \n-      Tgt_Node := HT_Ops.First (Target);\n+      Subset_Node := HT_Ops.First (Subset.HT);\n+      while Subset_Node /= null loop\n+         if not Is_In (Of_Set.HT, Subset_Node) then\n+            return False;\n+         end if;\n+         Subset_Node := HT_Ops.Next (Subset.HT, Subset_Node);\n+      end loop;\n \n-      while Tgt_Node /= null loop\n+      return True;\n+   end Is_Subset;\n \n-         if Is_In (Source, Tgt_Node) then\n+   -------------\n+   -- Iterate --\n+   -------------\n \n-            Tgt_Node := HT_Ops.Next (Target, Tgt_Node);\n+   procedure Iterate\n+     (Container : Set;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+      procedure Process_Node (Node : Node_Access);\n+      pragma Inline (Process_Node);\n \n-         else\n+      procedure Iterate is\n+         new HT_Ops.Generic_Iteration (Process_Node);\n \n-            declare\n-               X : Node_Access := Tgt_Node;\n-            begin\n-               Tgt_Node := HT_Ops.Next (Target, Tgt_Node);\n-               HT_Ops.Delete_Node_Sans_Free (Target, X);\n-               Free (X);\n-            end;\n+      ------------------\n+      -- Process_Node --\n+      ------------------\n \n-         end if;\n+      procedure Process_Node (Node : Node_Access) is\n+      begin\n+         Process (Cursor'(Container'Unrestricted_Access, Node));\n+      end Process_Node;\n \n-      end loop;\n+      HT : Hash_Table_Type renames Container'Unrestricted_Access.all.HT;\n+      B  : Natural renames HT.Busy;\n \n-   end Intersection;\n+   --  Start of processing for Iterate\n \n+   begin\n+      B := B + 1;\n \n-   function Intersection (Left, Right : Set) return Set is\n+      begin\n+         Iterate (HT);\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n \n-      Buckets : HT_Types.Buckets_Access;\n-      Length  : Count_Type;\n+      B := B - 1;\n+   end Iterate;\n+\n+   ------------\n+   -- Length --\n+   ------------\n \n+   function Length (Container : Set) return Count_Type is\n    begin\n+      return Container.HT.Length;\n+   end Length;\n \n-      if Left'Address = Right'Address then\n-         return Left;\n-      end if;\n+   ----------\n+   -- Move --\n+   ----------\n \n-      Length := Count_Type'Min (Left.Length, Right.Length);\n+   procedure Move (Target : in out Set; Source : in out Set) is\n+   begin\n+      HT_Ops.Move (Target => Target.HT, Source => Source.HT);\n+   end Move;\n \n-      if Length = 0 then\n-         return Empty_Set;\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   function Next (Node : Node_Access) return Node_Access is\n+   begin\n+      return Node.Next;\n+   end Next;\n+\n+   function Next (Position : Cursor) return Cursor is\n+   begin\n+      if Position.Node = null then\n+         pragma Assert (Position.Container = null);\n+         return No_Element;\n       end if;\n \n       declare\n-         Size : constant Hash_Type := Prime_Numbers.To_Prime (Length);\n+         HT   : Hash_Table_Type renames Position.Container.HT;\n+         Node : constant Node_Access := HT_Ops.Next (HT, Position.Node);\n+\n       begin\n-         Buckets := new Buckets_Type (0 .. Size - 1);\n+         if Node = null then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Position.Container, Node);\n       end;\n+   end Next;\n+\n+   procedure Next (Position : in out Cursor) is\n+   begin\n+      Position := Next (Position);\n+   end Next;\n+\n+   -------------\n+   -- Overlap --\n+   -------------\n+\n+   function Overlap (Left, Right : Set) return Boolean is\n+      Left_Node : Node_Access;\n+\n+   begin\n+      if Right.Length = 0 then\n+         return False;\n+      end if;\n+\n+      if Left'Address = Right'Address then\n+         return True;\n+      end if;\n+\n+      Left_Node := HT_Ops.First (Left.HT);\n+      while Left_Node /= null loop\n+         if Is_In (Right.HT, Left_Node) then\n+            return True;\n+         end if;\n+         Left_Node := HT_Ops.Next (Left.HT, Left_Node);\n+      end loop;\n \n-      Length := 0;\n+      return False;\n+   end Overlap;\n \n-      declare\n-         procedure Process (L_Node : Node_Access);\n+   -------------------\n+   -- Query_Element --\n+   -------------------\n \n-         procedure Process (L_Node : Node_Access) is\n-         begin\n-            if Is_In (Right, L_Node) then\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : Element_Type))\n+   is\n+      E : Element_Type renames Position.Node.Element;\n \n-               declare\n-                  I : constant Hash_Type :=\n-                    Hash (L_Node.Element) mod Buckets'Length;\n-               begin\n-                  Buckets (I) := new Node_Type'(L_Node.Element, Buckets (I));\n-               end;\n+      HT : Hash_Table_Type renames Position.Container.HT;\n \n-               Length := Length + 1;\n+      B : Natural renames HT.Busy;\n+      L : Natural renames HT.Lock;\n \n-            end if;\n-         end Process;\n+   begin\n+      B := B + 1;\n+      L := L + 1;\n \n-         procedure Iterate is\n-            new HT_Ops.Generic_Iteration (Process);\n       begin\n-         Iterate (Left);\n+         Process (E);\n       exception\n          when others =>\n-            HT_Ops.Free_Hash_Table (Buckets);\n+            L := L - 1;\n+            B := B - 1;\n             raise;\n       end;\n \n-      return (Controlled with Buckets, Length);\n-\n-   end Intersection;\n+      L := L - 1;\n+      B := B - 1;\n+   end Query_Element;\n \n+   ----------\n+   -- Read --\n+   ----------\n \n-   procedure Difference (Target : in out Set;\n-                         Source : in     Set) is\n+   procedure Read\n+     (Stream    : access Root_Stream_Type'Class;\n+      Container :    out Set)\n+   is\n+   begin\n+      Read_Nodes (Stream, Container.HT);\n+   end Read;\n \n+   ---------------\n+   -- Read_Node --\n+   ---------------\n \n-      Tgt_Node : Node_Access;\n+   function Read_Node (Stream : access Root_Stream_Type'Class)\n+     return Node_Access\n+   is\n+      Node : Node_Access := new Node_Type;\n \n    begin\n+      Element_Type'Read (Stream, Node.Element);\n+      return Node;\n+   exception\n+      when others =>\n+         Free (Node);\n+         raise;\n+   end Read_Node;\n \n-      if Target'Address = Source'Address then\n-         Clear (Target);\n-         return;\n-      end if;\n-\n-      if Source.Length = 0 then\n-         return;\n-      end if;\n-\n-      --  TODO: As I noted above, this can be\n-      --  written in terms of a loop instead as\n-      --  active-iterator style, sort of like a\n-      --  passive iterator.\n+   -------------\n+   -- Replace --\n+   -------------\n \n-      Tgt_Node := HT_Ops.First (Target);\n+   procedure Replace\n+     (Container : in out Set;    --  TODO: need ruling from ARG\n+      New_Item  : Element_Type)\n+   is\n+      Node : constant Node_Access :=\n+               Element_Keys.Find (Container.HT, New_Item);\n \n-      while Tgt_Node /= null loop\n+   begin\n+      if Node = null then\n+         raise Constraint_Error;\n+      end if;\n \n-         if Is_In (Source, Tgt_Node) then\n+      if Container.HT.Lock > 0 then\n+         raise Program_Error;\n+      end if;\n \n-            declare\n-               X : Node_Access := Tgt_Node;\n-            begin\n-               Tgt_Node := HT_Ops.Next (Target, Tgt_Node);\n-               HT_Ops.Delete_Node_Sans_Free (Target, X);\n-               Free (X);\n-            end;\n+      Node.Element := New_Item;\n+   end Replace;\n \n-         else\n+   ---------------------\n+   -- Replace_Element --\n+   ---------------------\n \n-            Tgt_Node := HT_Ops.Next (Target, Tgt_Node);\n+   procedure Replace_Element\n+     (HT      : in out Hash_Table_Type;\n+      Node    : Node_Access;\n+      Element : Element_Type)\n+   is\n+   begin\n+      if Equivalent_Elements (Node.Element, Element) then\n+         pragma Assert (Hash (Node.Element) = Hash (Element));\n \n+         if HT.Lock > 0 then\n+            raise Program_Error;\n          end if;\n \n-      end loop;\n-\n-   end Difference;\n+         Node.Element := Element;  --  Note that this assignment can fail\n+         return;\n+      end if;\n \n+      if HT.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n \n+      HT_Ops.Delete_Node_Sans_Free (HT, Node);\n \n-   function Difference (Left, Right : Set) return Set is\n+      Insert_New_Element : declare\n+         function New_Node (Next : Node_Access) return Node_Access;\n+         pragma Inline (New_Node);\n \n-      Buckets : HT_Types.Buckets_Access;\n-      Length  : Count_Type;\n+         procedure Local_Insert is\n+            new Element_Keys.Generic_Conditional_Insert (New_Node);\n \n-   begin\n+         --------------\n+         -- New_Node --\n+         --------------\n \n-      if Left'Address = Right'Address then\n-         return Empty_Set;\n-      end if;\n+         function New_Node (Next : Node_Access) return Node_Access is\n+         begin\n+            Node.Element := Element;  -- Note that this assignment can fail\n+            Node.Next := Next;\n+            return Node;\n+         end New_Node;\n \n-      if Left.Length = 0 then\n-         return Empty_Set;\n-      end if;\n+         Result   : Node_Access;\n+         Inserted : Boolean;\n \n-      if Right.Length = 0 then\n-         return Left;\n-      end if;\n+      --  Start of processing for Insert_New_Element\n \n-      declare\n-         Size : constant Hash_Type := Prime_Numbers.To_Prime (Left.Length);\n       begin\n-         Buckets := new Buckets_Type (0 .. Size - 1);\n-      end;\n+         Local_Insert\n+           (HT       => HT,\n+            Key      => Element,\n+            Node     => Result,\n+            Inserted => Inserted);\n+\n+         if Inserted then\n+            pragma Assert (Result = Node);\n+            return;\n+         end if;\n+      exception\n+         when others =>\n+            null;   --  Assignment must have failed\n+      end Insert_New_Element;\n \n-      Length := 0;\n+      Reinsert_Old_Element : declare\n+         function New_Node (Next : Node_Access) return Node_Access;\n+         pragma Inline (New_Node);\n \n-      declare\n-         procedure Process (L_Node : Node_Access);\n+         procedure Local_Insert is\n+            new Element_Keys.Generic_Conditional_Insert (New_Node);\n \n-         procedure Process (L_Node : Node_Access) is\n-         begin\n-            if not Is_In (Right, L_Node) then\n+         --------------\n+         -- New_Node --\n+         --------------\n \n-               declare\n-                  I : constant Hash_Type :=\n-                    Hash (L_Node.Element) mod Buckets'Length;\n-               begin\n-                  Buckets (I) := new Node_Type'(L_Node.Element, Buckets (I));\n-               end;\n+         function New_Node (Next : Node_Access) return Node_Access is\n+         begin\n+            Node.Next := Next;\n+            return Node;\n+         end New_Node;\n \n-               Length := Length + 1;\n+         Result   : Node_Access;\n+         Inserted : Boolean;\n \n-            end if;\n-         end Process;\n+      --  Start of processing for Reinsert_Old_Element\n \n-         procedure Iterate is\n-            new HT_Ops.Generic_Iteration (Process);\n       begin\n-         Iterate (Left);\n+         Local_Insert\n+           (HT       => HT,\n+            Key      => Node.Element,\n+            Node     => Result,\n+            Inserted => Inserted);\n       exception\n          when others =>\n-            HT_Ops.Free_Hash_Table (Buckets);\n-            raise;\n-      end;\n+            null;\n+      end Reinsert_Old_Element;\n \n-      return (Controlled with Buckets, Length);\n+      raise Program_Error;\n+   end Replace_Element;\n \n-   end Difference;\n+   procedure Replace_Element\n+     (Container : Set;\n+      Position  : Cursor;\n+      By        : Element_Type)\n+   is\n+      HT : Hash_Table_Type renames Container'Unrestricted_Access.all.HT;\n+\n+   begin\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Position.Container /= Set_Access'(Container'Unrestricted_Access) then\n+         raise Program_Error;\n+      end if;\n+\n+      Replace_Element (HT, Position.Node, By);\n+   end Replace_Element;\n \n+   ----------------------\n+   -- Reserve_Capacity --\n+   ----------------------\n+\n+   procedure Reserve_Capacity\n+     (Container : in out Set;\n+      Capacity  : Count_Type)\n+   is\n+   begin\n+      HT_Ops.Reserve_Capacity (Container.HT, Capacity);\n+   end Reserve_Capacity;\n \n+   --------------\n+   -- Set_Next --\n+   --------------\n \n-   procedure Symmetric_Difference (Target : in out Set;\n-                                   Source : in     Set) is\n+   procedure Set_Next (Node : Node_Access; Next : Node_Access) is\n    begin\n+      Node.Next := Next;\n+   end Set_Next;\n \n+   --------------------------\n+   -- Symmetric_Difference --\n+   --------------------------\n+\n+   procedure Symmetric_Difference\n+     (Target : in out Set;\n+      Source : Set)\n+   is\n+   begin\n       if Target'Address = Source'Address then\n          Clear (Target);\n          return;\n       end if;\n \n-      HT_Ops.Ensure_Capacity (Target, Target.Length + Source.Length);\n+      if Target.HT.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n+\n+      declare\n+         N : constant Count_Type := Target.Length + Source.Length;\n+      begin\n+         if N > HT_Ops.Capacity (Target.HT) then\n+            HT_Ops.Reserve_Capacity (Target.HT, N);\n+         end if;\n+      end;\n \n       if Target.Length = 0 then\n-\n-         declare\n+         Iterate_Source_When_Empty_Target : declare\n             procedure Process (Src_Node : Node_Access);\n \n+            procedure Iterate is\n+               new HT_Ops.Generic_Iteration (Process);\n+\n+            -------------\n+            -- Process --\n+            -------------\n+\n             procedure Process (Src_Node : Node_Access) is\n                E : Element_Type renames Src_Node.Element;\n-               B : Buckets_Type renames Target.Buckets.all;\n-               I : constant Hash_Type := Hash (E) mod B'Length;\n-               N : Count_Type renames Target.Length;\n+               B : Buckets_Type renames Target.HT.Buckets.all;\n+               J : constant Hash_Type := Hash (E) mod B'Length;\n+               N : Count_Type renames Target.HT.Length;\n+\n             begin\n-               B (I) := new Node_Type'(E, B (I));\n+               B (J) := new Node_Type'(E, B (J));\n                N := N + 1;\n             end Process;\n \n-            procedure Iterate is\n-               new HT_Ops.Generic_Iteration (Process);\n+         --  Start of processing for Iterate_Source_When_Empty_Target\n+\n          begin\n-            Iterate (Source);\n-         end;\n+            Iterate (Source.HT);\n+         end Iterate_Source_When_Empty_Target;\n \n       else\n-\n-         declare\n+         Iterate_Source : declare\n             procedure Process (Src_Node : Node_Access);\n \n+            procedure Iterate is\n+               new HT_Ops.Generic_Iteration (Process);\n+\n+            -------------\n+            -- Process --\n+            -------------\n+\n             procedure Process (Src_Node : Node_Access) is\n                E : Element_Type renames Src_Node.Element;\n-               B : Buckets_Type renames Target.Buckets.all;\n-               I : constant Hash_Type := Hash (E) mod B'Length;\n-               N : Count_Type renames Target.Length;\n-            begin\n-               if B (I) = null then\n+               B : Buckets_Type renames Target.HT.Buckets.all;\n+               J : constant Hash_Type := Hash (E) mod B'Length;\n+               N : Count_Type renames Target.HT.Length;\n \n-                  B (I) := new Node_Type'(E, null);\n+            begin\n+               if B (J) = null then\n+                  B (J) := new Node_Type'(E, null);\n                   N := N + 1;\n \n-               elsif Equivalent_Keys (E, B (I).Element) then\n-\n+               elsif Equivalent_Elements (E, B (J).Element) then\n                   declare\n-                     X : Node_Access := B (I);\n+                     X : Node_Access := B (J);\n                   begin\n-                     B (I) := B (I).Next;\n+                     B (J) := B (J).Next;\n                      N := N - 1;\n                      Free (X);\n                   end;\n \n                else\n-\n                   declare\n-                     Prev : Node_Access := B (I);\n+                     Prev : Node_Access := B (J);\n                      Curr : Node_Access := Prev.Next;\n+\n                   begin\n                      while Curr /= null loop\n-                        if Equivalent_Keys (E, Curr.Element) then\n+                        if Equivalent_Elements (E, Curr.Element) then\n                            Prev.Next := Curr.Next;\n                            N := N - 1;\n                            Free (Curr);\n@@ -873,31 +1218,25 @@ package body Ada.Containers.Hashed_Sets is\n                         Curr := Prev.Next;\n                      end loop;\n \n-                     B (I) := new Node_Type'(E, B (I));\n+                     B (J) := new Node_Type'(E, B (J));\n                      N := N + 1;\n                   end;\n-\n                end if;\n             end Process;\n \n-            procedure Iterate is\n-               new HT_Ops.Generic_Iteration (Process);\n-         begin\n-            Iterate (Source);\n-         end;\n+         --  Start of processing for Iterate_Source\n \n+         begin\n+            Iterate (Source.HT);\n+         end Iterate_Source;\n       end if;\n-\n    end Symmetric_Difference;\n \n-\n    function Symmetric_Difference (Left, Right : Set) return Set is\n-\n       Buckets : HT_Types.Buckets_Access;\n       Length  : Count_Type;\n \n    begin\n-\n       if Left'Address = Right'Address then\n          return Empty_Set;\n       end if;\n@@ -912,451 +1251,446 @@ package body Ada.Containers.Hashed_Sets is\n \n       declare\n          Size : constant Hash_Type :=\n-           Prime_Numbers.To_Prime (Left.Length + Right.Length);\n+                  Prime_Numbers.To_Prime (Left.Length + Right.Length);\n       begin\n          Buckets := new Buckets_Type (0 .. Size - 1);\n       end;\n \n       Length := 0;\n \n-      declare\n+      Iterate_Left : declare\n          procedure Process (L_Node : Node_Access);\n \n+         procedure Iterate is\n+            new HT_Ops.Generic_Iteration (Process);\n+\n+         -------------\n+         -- Process --\n+         -------------\n+\n          procedure Process (L_Node : Node_Access) is\n          begin\n-            if not Is_In (Right, L_Node) then\n+            if not Is_In (Right.HT, L_Node) then\n                declare\n                   E : Element_Type renames L_Node.Element;\n-                  I : constant Hash_Type := Hash (E) mod Buckets'Length;\n+                  J : constant Hash_Type := Hash (E) mod Buckets'Length;\n+\n                begin\n-                  Buckets (I) := new Node_Type'(E, Buckets (I));\n+                  Buckets (J) := new Node_Type'(E, Buckets (J));\n                   Length := Length + 1;\n                end;\n             end if;\n          end Process;\n \n-         procedure Iterate is\n-            new HT_Ops.Generic_Iteration (Process);\n+      --  Start of processing for Iterate_Left\n+\n       begin\n-         Iterate (Left);\n+         Iterate (Left.HT);\n       exception\n          when others =>\n             HT_Ops.Free_Hash_Table (Buckets);\n             raise;\n-      end;\n+      end Iterate_Left;\n \n-      declare\n+      Iterate_Right : declare\n          procedure Process (R_Node : Node_Access);\n \n+         procedure Iterate is\n+            new HT_Ops.Generic_Iteration (Process);\n+\n+         -------------\n+         -- Process --\n+         -------------\n+\n          procedure Process (R_Node : Node_Access) is\n          begin\n-            if not Is_In (Left, R_Node) then\n+            if not Is_In (Left.HT, R_Node) then\n                declare\n                   E : Element_Type renames R_Node.Element;\n-                  I : constant Hash_Type := Hash (E) mod Buckets'Length;\n+                  J : constant Hash_Type := Hash (E) mod Buckets'Length;\n+\n                begin\n-                  Buckets (I) := new Node_Type'(E, Buckets (I));\n+                  Buckets (J) := new Node_Type'(E, Buckets (J));\n                   Length := Length + 1;\n                end;\n             end if;\n          end Process;\n \n-         procedure Iterate is\n-            new HT_Ops.Generic_Iteration (Process);\n-      begin\n-         Iterate (Right);\n-      exception\n-         when others =>\n-            HT_Ops.Free_Hash_Table (Buckets);\n-            raise;\n-      end;\n-\n-      return (Controlled with Buckets, Length);\n-\n-   end Symmetric_Difference;\n-\n-\n-   function Is_Subset (Subset : Set;\n-                       Of_Set : Set) return Boolean is\n-\n-      Subset_Node : Node_Access;\n-\n-   begin\n-\n-      if Subset'Address = Of_Set'Address then\n-         return True;\n-      end if;\n-\n-      if Subset.Length > Of_Set.Length then\n-         return False;\n-      end if;\n-\n-      --  TODO: rewrite this to loop in the\n-      --  style of a passive iterator.\n-\n-      Subset_Node := HT_Ops.First (Subset);\n-\n-      while Subset_Node /= null loop\n-         if not Is_In (Of_Set, Subset_Node) then\n-            return False;\n-         end if;\n-\n-         Subset_Node := HT_Ops.Next (Subset, Subset_Node);\n-      end loop;\n-\n-      return True;\n-\n-   end Is_Subset;\n-\n-\n-   function Overlap (Left, Right : Set) return Boolean is\n-\n-      Left_Node : Node_Access;\n-\n-   begin\n-\n-      if Right.Length = 0 then\n-         return False;\n-      end if;\n-\n-      if Left'Address = Right'Address then\n-         return True;\n-      end if;\n-\n-      Left_Node := HT_Ops.First (Left);\n-\n-      while Left_Node /= null loop\n-         if Is_In (Right, Left_Node) then\n-            return True;\n-         end if;\n-\n-         Left_Node := HT_Ops.Next (Left, Left_Node);\n-      end loop;\n-\n-      return False;\n-\n-   end Overlap;\n-\n-\n-   function Find (Container : Set;\n-                  Item      : Element_Type) return Cursor is\n+      --  Start of processing for Iterate_Right\n \n-      Node : constant Node_Access := Element_Keys.Find (Container, Item);\n+      begin\n+         Iterate (Right.HT);\n+      exception\n+         when others =>\n+            HT_Ops.Free_Hash_Table (Buckets);\n+            raise;\n+      end Iterate_Right;\n \n-   begin\n+      return (Controlled with HT => (Buckets, Length, 0, 0));\n+   end Symmetric_Difference;\n \n-      if Node = null then\n-         return No_Element;\n-      end if;\n+   -----------\n+   -- Union --\n+   -----------\n \n-      return Cursor'(Container'Unchecked_Access, Node);\n+   procedure Union\n+     (Target : in out Set;\n+      Source : Set)\n+   is\n+      procedure Process (Src_Node : Node_Access);\n \n-   end Find;\n+      procedure Iterate is\n+         new HT_Ops.Generic_Iteration (Process);\n \n+      -------------\n+      -- Process --\n+      -------------\n \n-   function Contains (Container : Set;\n-                      Item      : Element_Type) return Boolean is\n-   begin\n-      return Find (Container, Item) /= No_Element;\n-   end Contains;\n+      procedure Process (Src_Node : Node_Access) is\n+         function New_Node (Next : Node_Access) return Node_Access;\n+         pragma Inline (New_Node);\n \n+         procedure Insert is\n+            new Element_Keys.Generic_Conditional_Insert (New_Node);\n \n+         --------------\n+         -- New_Node --\n+         --------------\n \n-   function First (Container : Set) return Cursor is\n-      Node : constant Node_Access := HT_Ops.First (Container);\n-   begin\n-      if Node = null then\n-         return No_Element;\n-      end if;\n+         function New_Node (Next : Node_Access) return Node_Access is\n+            Node : constant Node_Access :=\n+                     new Node_Type'(Src_Node.Element, Next);\n+         begin\n+            return Node;\n+         end New_Node;\n \n-      return Cursor'(Container'Unchecked_Access, Node);\n-   end First;\n+         Tgt_Node : Node_Access;\n+         Success  : Boolean;\n \n+      --  Start of processing for Process\n \n---     function First_Element (Container : Set) return Element_Type is\n---        Node : constant Node_Access := HT_Ops.First (Container);\n---     begin\n---        return Node.Element;\n---     end First_Element;\n+      begin\n+         Insert (Target.HT, Src_Node.Element, Tgt_Node, Success);\n+      end Process;\n \n+   --  Start of processing for Union\n \n-   function Next (Position : Cursor) return Cursor is\n    begin\n-      if Position.Container = null\n-        or else Position.Node = null\n-      then\n-         return No_Element;\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Target.HT.Busy > 0 then\n+         raise Program_Error;\n       end if;\n \n       declare\n-         S : Set renames Position.Container.all;\n-         Node : constant Node_Access := HT_Ops.Next (S, Position.Node);\n+         N : constant Count_Type := Target.Length + Source.Length;\n       begin\n-         if Node = null then\n-            return No_Element;\n+         if N > HT_Ops.Capacity (Target.HT) then\n+            HT_Ops.Reserve_Capacity (Target.HT, N);\n          end if;\n-\n-         return Cursor'(Position.Container, Node);\n       end;\n-   end Next;\n-\n \n-   procedure Next (Position : in out Cursor) is\n-   begin\n-      Position := Next (Position);\n-   end Next;\n+      Iterate (Source.HT);\n+   end Union;\n \n+   function Union (Left, Right : Set) return Set is\n+      Buckets : HT_Types.Buckets_Access;\n+      Length  : Count_Type;\n \n-   function Has_Element (Position : Cursor) return Boolean is\n    begin\n-      if Position.Container = null then\n-         return False;\n+      if Left'Address = Right'Address then\n+         return Left;\n       end if;\n \n-      if Position.Node = null then\n-         return False;\n+      if Right.Length = 0 then\n+         return Left;\n       end if;\n \n-      return True;\n-   end Has_Element;\n-\n-\n-   function Equivalent_Keys (Left, Right : Cursor)\n-     return Boolean is\n-   begin\n-      return Equivalent_Keys (Left.Node.Element, Right.Node.Element);\n-   end Equivalent_Keys;\n+      if Left.Length = 0 then\n+         return Right;\n+      end if;\n \n+      declare\n+         Size : constant Hash_Type :=\n+                  Prime_Numbers.To_Prime (Left.Length + Right.Length);\n+      begin\n+         Buckets := new Buckets_Type (0 .. Size - 1);\n+      end;\n \n-   function Equivalent_Keys (Left  : Cursor;\n-                             Right : Element_Type)\n-    return Boolean is\n-   begin\n-      return Equivalent_Keys (Left.Node.Element, Right);\n-   end Equivalent_Keys;\n+      Iterate_Left : declare\n+         procedure Process (L_Node : Node_Access);\n \n+         procedure Iterate is\n+            new HT_Ops.Generic_Iteration (Process);\n \n-   function Equivalent_Keys (Left  : Element_Type;\n-                             Right : Cursor)\n-    return Boolean is\n-   begin\n-      return Equivalent_Keys (Left, Right.Node.Element);\n-   end Equivalent_Keys;\n+         -------------\n+         -- Process --\n+         -------------\n \n+         procedure Process (L_Node : Node_Access) is\n+            J : constant Hash_Type :=\n+                  Hash (L_Node.Element) mod Buckets'Length;\n \n-   procedure Iterate\n-     (Container : in Set;\n-      Process   : not null access procedure (Position : in Cursor)) is\n+         begin\n+            Buckets (J) := new Node_Type'(L_Node.Element, Buckets (J));\n+         end Process;\n \n-      procedure Process_Node (Node : in Node_Access);\n-      pragma Inline (Process_Node);\n+      --  Start of processing for Iterate_Left\n \n-      procedure Process_Node (Node : in Node_Access) is\n       begin\n-         Process (Cursor'(Container'Unchecked_Access, Node));\n-      end Process_Node;\n-\n-      procedure Iterate is\n-         new HT_Ops.Generic_Iteration (Process_Node);\n-   begin\n-      Iterate (Container);\n-   end Iterate;\n+         Iterate (Left.HT);\n+      exception\n+         when others =>\n+            HT_Ops.Free_Hash_Table (Buckets);\n+            raise;\n+      end Iterate_Left;\n \n+      Length := Left.Length;\n \n-   function Capacity (Container : Set) return Count_Type\n-     renames HT_Ops.Capacity;\n+      Iterate_Right : declare\n+         procedure Process (Src_Node : Node_Access);\n \n-   procedure Reserve_Capacity\n-     (Container : in out Set;\n-      Capacity  : in     Count_Type)\n-     renames HT_Ops.Ensure_Capacity;\n+         procedure Iterate is\n+            new HT_Ops.Generic_Iteration (Process);\n \n+         -------------\n+         -- Process --\n+         -------------\n \n-   procedure Write_Node\n-     (Stream : access Root_Stream_Type'Class;\n-      Node   : in     Node_Access);\n-   pragma Inline (Write_Node);\n+         procedure Process (Src_Node : Node_Access) is\n+            J : constant Hash_Type :=\n+                  Hash (Src_Node.Element) mod Buckets'Length;\n \n-   procedure Write_Node\n-     (Stream : access Root_Stream_Type'Class;\n-      Node   : in     Node_Access) is\n-   begin\n-      Element_Type'Write (Stream, Node.Element);\n-   end Write_Node;\n+            Tgt_Node : Node_Access := Buckets (J);\n \n-   procedure Write_Nodes is\n-      new HT_Ops.Generic_Write (Write_Node);\n+         begin\n+            while Tgt_Node /= null loop\n+               if Equivalent_Elements (Src_Node.Element, Tgt_Node.Element) then\n+                  return;\n+               end if;\n \n-   procedure Write\n-     (Stream    : access Root_Stream_Type'Class;\n-      Container : in     Set) renames Write_Nodes;\n+               Tgt_Node := Next (Tgt_Node);\n+            end loop;\n \n+            Buckets (J) := new Node_Type'(Src_Node.Element, Buckets (J));\n+            Length := Length + 1;\n+         end Process;\n \n-   function Read_Node (Stream : access Root_Stream_Type'Class)\n-     return Node_Access;\n-   pragma Inline (Read_Node);\n+      --  Start of processing for Iterate_Right\n \n-   function Read_Node (Stream : access Root_Stream_Type'Class)\n-     return Node_Access is\n+      begin\n+         Iterate (Right.HT);\n+      exception\n+         when others =>\n+            HT_Ops.Free_Hash_Table (Buckets);\n+            raise;\n+      end Iterate_Right;\n \n-      Node : Node_Access := new Node_Type;\n-   begin\n-      Element_Type'Read (Stream, Node.Element);\n-      return Node;\n-   exception\n-      when others =>\n-         Free (Node);\n-         raise;\n-   end Read_Node;\n+      return (Controlled with HT => (Buckets, Length, 0, 0));\n+   end Union;\n \n-   procedure Read_Nodes is\n-      new HT_Ops.Generic_Read (Read_Node);\n+   -----------\n+   -- Write --\n+   -----------\n \n-   procedure Read\n+   procedure Write\n      (Stream    : access Root_Stream_Type'Class;\n-      Container :    out Set) renames Read_Nodes;\n+      Container : Set)\n+   is\n+   begin\n+      Write_Nodes (Stream, Container.HT);\n+   end Write;\n \n+   ----------------\n+   -- Write_Node --\n+   ----------------\n \n-   package body Generic_Keys is\n+   procedure Write_Node\n+     (Stream : access Root_Stream_Type'Class;\n+      Node   : Node_Access)\n+   is\n+   begin\n+      Element_Type'Write (Stream, Node.Element);\n+   end Write_Node;\n \n-      function Equivalent_Keys (Left  : Cursor;\n-                                Right : Key_Type)\n-        return Boolean is\n-      begin\n-         return Equivalent_Keys (Right, Left.Node.Element);\n-      end Equivalent_Keys;\n+   package body Generic_Keys is\n \n-      function Equivalent_Keys (Left  : Key_Type;\n-                                Right : Cursor)\n-        return Boolean is\n-      begin\n-         return Equivalent_Keys (Left, Right.Node.Element);\n-      end Equivalent_Keys;\n+      -----------------------\n+      -- Local Subprograms --\n+      -----------------------\n \n-      function Equivalent_Keys\n+      function Equivalent_Key_Node\n         (Key  : Key_Type;\n          Node : Node_Access) return Boolean;\n-      pragma Inline (Equivalent_Keys);\n+      pragma Inline (Equivalent_Key_Node);\n \n-      function Equivalent_Keys\n-        (Key  : Key_Type;\n-         Node : Node_Access) return Boolean is\n-      begin\n-         return Equivalent_Keys (Key, Node.Element);\n-      end Equivalent_Keys;\n+      --------------------------\n+      -- Local Instantiations --\n+      --------------------------\n \n       package Key_Keys is\n          new Hash_Tables.Generic_Keys\n           (HT_Types  => HT_Types,\n-           HT_Type   => Set,\n-           Null_Node => null,\n            Next      => Next,\n            Set_Next  => Set_Next,\n            Key_Type  => Key_Type,\n            Hash      => Hash,\n-           Equivalent_Keys => Equivalent_Keys);\n-\n+           Equivalent_Keys => Equivalent_Key_Node);\n \n-      function Find (Container : Set;\n-                     Key       : Key_Type)\n-         return Cursor is\n-\n-         Node : constant Node_Access :=\n-           Key_Keys.Find (Container, Key);\n+      --------------\n+      -- Contains --\n+      --------------\n \n+      function Contains\n+        (Container : Set;\n+         Key       : Key_Type) return Boolean\n+      is\n       begin\n+         return Find (Container, Key) /= No_Element;\n+      end Contains;\n \n-         if Node = null then\n-            return No_Element;\n-         end if;\n+      ------------\n+      -- Delete --\n+      ------------\n \n-         return Cursor'(Container'Unchecked_Access, Node);\n+      procedure Delete\n+        (Container : in out Set;\n+         Key       : Key_Type)\n+      is\n+         X : Node_Access;\n \n-      end Find;\n+      begin\n+         Key_Keys.Delete_Key_Sans_Free (Container.HT, Key, X);\n \n+         if X = null then\n+            raise Constraint_Error;\n+         end if;\n \n-      function Contains (Container : Set;\n-                         Key       : Key_Type) return Boolean is\n-      begin\n-         return Find (Container, Key) /= No_Element;\n-      end Contains;\n+         Free (X);\n+      end Delete;\n \n+      -------------\n+      -- Element --\n+      -------------\n \n-      function Element (Container : Set;\n-                        Key       : Key_Type)\n-        return Element_Type is\n+      function Element\n+        (Container : Set;\n+         Key       : Key_Type) return Element_Type\n+      is\n+         Node : constant Node_Access := Key_Keys.Find (Container.HT, Key);\n \n-         Node : constant Node_Access := Key_Keys.Find (Container, Key);\n       begin\n          return Node.Element;\n       end Element;\n \n+      -------------------------\n+      -- Equivalent_Key_Node --\n+      -------------------------\n \n-      function Key (Position : Cursor) return Key_Type is\n+      function Equivalent_Key_Node\n+        (Key  : Key_Type;\n+         Node : Node_Access) return Boolean\n+      is\n       begin\n-         return Key (Position.Node.Element);\n-      end Key;\n-\n-\n---  TODO:\n---        procedure Replace (Container : in out Set;\n---                           Key       : in     Key_Type;\n---                           New_Item  : in     Element_Type) is\n-\n---           Node : constant Node_Access :=\n---             Key_Keys.Find (Container, Key);\n-\n---        begin\n-\n---           if Node = null then\n---              raise Constraint_Error;\n---           end if;\n+         return Equivalent_Keys (Key, Node.Element);\n+      end Equivalent_Key_Node;\n \n---           Replace_Element (Container, Node, New_Item);\n+      ---------------------\n+      -- Equivalent_Keys --\n+      ---------------------\n \n---        end Replace;\n+      function Equivalent_Keys\n+        (Left  : Cursor;\n+         Right : Key_Type) return Boolean is\n+      begin\n+         return Equivalent_Keys (Right, Left.Node.Element);\n+      end Equivalent_Keys;\n \n+      function Equivalent_Keys\n+        (Left  : Key_Type;\n+         Right : Cursor) return Boolean is\n+      begin\n+         return Equivalent_Keys (Left, Right.Node.Element);\n+      end Equivalent_Keys;\n \n-      procedure Delete (Container : in out Set;\n-                        Key       : in     Key_Type) is\n+      -------------\n+      -- Exclude --\n+      -------------\n \n+      procedure Exclude\n+        (Container : in out Set;\n+         Key       : Key_Type)\n+      is\n          X : Node_Access;\n-\n       begin\n+         Key_Keys.Delete_Key_Sans_Free (Container.HT, Key, X);\n+         Free (X);\n+      end Exclude;\n \n-         Key_Keys.Delete_Key_Sans_Free (Container, Key, X);\n+      ----------\n+      -- Find --\n+      ----------\n \n-         if X = null then\n-            raise Constraint_Error;\n+      function Find\n+        (Container : Set;\n+         Key       : Key_Type) return Cursor\n+      is\n+         Node : constant Node_Access :=\n+                  Key_Keys.Find (Container.HT, Key);\n+\n+      begin\n+         if Node = null then\n+            return No_Element;\n          end if;\n \n-         Free (X);\n+         return Cursor'(Container'Unrestricted_Access, Node);\n+      end Find;\n \n-      end Delete;\n+      ---------\n+      -- Key --\n+      ---------\n \n+      function Key (Position : Cursor) return Key_Type is\n+      begin\n+         return Key (Position.Node.Element);\n+      end Key;\n \n-      procedure Exclude (Container : in out Set;\n-                         Key       : in     Key_Type) is\n+      -------------\n+      -- Replace --\n+      -------------\n \n-         X : Node_Access;\n+      procedure Replace\n+        (Container : in out Set;\n+         Key       : Key_Type;\n+         New_Item  : Element_Type)\n+      is\n+         Node : constant Node_Access :=\n+                  Key_Keys.Find (Container.HT, Key);\n \n       begin\n+         if Node = null then\n+            raise Constraint_Error;\n+         end if;\n \n-         Key_Keys.Delete_Key_Sans_Free (Container, Key, X);\n-         Free (X);\n-\n-      end Exclude;\n+         Replace_Element (Container.HT, Node, New_Item);\n+      end Replace;\n \n+      -----------------------------------\n+      -- Update_Element_Preserving_Key --\n+      -----------------------------------\n \n-      procedure Checked_Update_Element\n+      procedure Update_Element_Preserving_Key\n         (Container : in out Set;\n-         Position  : in     Cursor;\n+         Position  : Cursor;\n          Process   : not null access\n-           procedure (Element : in out Element_Type)) is\n+                       procedure (Element : in out Element_Type))\n+      is\n+         HT : Hash_Table_Type renames Container.HT;\n \n       begin\n-\n-         if Position.Container = null then\n+         if Position.Node = null then\n             raise Constraint_Error;\n          end if;\n \n@@ -1365,53 +1699,43 @@ package body Ada.Containers.Hashed_Sets is\n          end if;\n \n          declare\n-            Old_Key : Key_Type renames Key (Position.Node.Element);\n-         begin\n-            Process (Position.Node.Element);\n-\n-            if Equivalent_Keys (Old_Key, Position.Node.Element) then\n-               return;\n-            end if;\n-         end;\n-\n-         declare\n-            function New_Node (Next : Node_Access) return Node_Access;\n-            pragma Inline (New_Node);\n+            E : Element_Type renames Position.Node.Element;\n+            K : Key_Type renames Key (E);\n \n-            function New_Node (Next : Node_Access) return Node_Access is\n-            begin\n-               Position.Node.Next := Next;\n-               return Position.Node;\n-            end New_Node;\n-\n-            procedure Insert is\n-               new Key_Keys.Generic_Conditional_Insert (New_Node);\n+            B : Natural renames HT.Busy;\n+            L : Natural renames HT.Lock;\n \n-            Result  : Node_Access;\n-            Success : Boolean;\n          begin\n-            HT_Ops.Delete_Node_Sans_Free (Container, Position.Node);\n+            B := B + 1;\n+            L := L + 1;\n \n-            Insert\n-              (HT      => Container,\n-               Key     => Key (Position.Node.Element),\n-               Node    => Result,\n-               Success => Success);\n+            begin\n+               Process (E);\n+            exception\n+               when others =>\n+                  L := L - 1;\n+                  B := B - 1;\n+                  raise;\n+            end;\n \n-            if not Success then\n-               declare\n-                  X : Node_Access := Position.Node;\n-               begin\n-                  Free (X);\n-               end;\n+            L := L - 1;\n+            B := B - 1;\n \n-               raise Program_Error;\n+            if Equivalent_Keys (K, E) then\n+               pragma Assert (Hash (K) = Hash (E));\n+               return;\n             end if;\n+         end;\n \n-            pragma Assert (Result = Position.Node);\n+         declare\n+            X : Node_Access := Position.Node;\n+         begin\n+            HT_Ops.Delete_Node_Sans_Free (HT, X);\n+            Free (X);\n          end;\n \n-      end Checked_Update_Element;\n+         raise Program_Error;\n+      end Update_Element_Preserving_Key;\n \n    end Generic_Keys;\n "}, {"sha": "16aaf5dc36045cc962b5357a600c6a28e6eb0e1f", "filename": "gcc/ada/a-cohase.ads", "status": "modified", "additions": 66, "deletions": 57, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-cohase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-cohase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohase.ads?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---                        ADA.CONTAINERS.HASHED_SETS                        --\n+--           A D A . C O N T A I N E R S . H A S H E D _ S E T S            --\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -35,16 +35,15 @@\n \n with Ada.Containers.Hash_Tables;\n with Ada.Streams;\n+with Ada.Finalization;\n \n generic\n    type Element_Type is private;\n \n    with function Hash (Element : Element_Type) return Hash_Type;\n \n-   --  TODO: get a ruling from ARG in Atlanta re the name and\n-   --  order of these declarations. ???\n-   --\n-   with function Equivalent_Keys (Left, Right : Element_Type) return Boolean;\n+   with function Equivalent_Elements (Left, Right : Element_Type)\n+                                     return Boolean;\n \n    with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n \n@@ -61,6 +60,8 @@ pragma Preelaborate (Hashed_Sets);\n \n    function \"=\" (Left, Right : Set) return Boolean;\n \n+   function Equivalent_Sets (Left, Right : Set) return Boolean;\n+\n    function Length (Container : Set) return Count_Type;\n \n    function Is_Empty (Container : Set) return Boolean;\n@@ -73,11 +74,10 @@ pragma Preelaborate (Hashed_Sets);\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type));\n \n-   --  TODO: resolve in atlanta\n-   --   procedure Replace_Element\n-   --     (Container : in out Set;\n-   --      Position  : Cursor;\n-   --      By        : Element_Type);\n+   procedure Replace_Element\n+     (Container : Set;\n+      Position  : Cursor;\n+      By        : Element_Type);\n \n    procedure Move (Target : in out Set; Source : in out Set);\n \n@@ -95,9 +95,37 @@ pragma Preelaborate (Hashed_Sets);\n \n    procedure Delete  (Container : in out Set; Item     : Element_Type);\n \n+   procedure Delete (Container : in out Set; Position  : in out Cursor);\n+\n    procedure Exclude (Container : in out Set; Item     : Element_Type);\n \n-   procedure Delete (Container : in out Set; Position  : in out Cursor);\n+   function Contains (Container : Set; Item : Element_Type) return Boolean;\n+\n+   function Find\n+     (Container : Set;\n+      Item      : Element_Type) return Cursor;\n+\n+   function First (Container : Set) return Cursor;\n+\n+   function Next (Position : Cursor) return Cursor;\n+\n+   procedure Next (Position : in out Cursor);\n+\n+   function Has_Element (Position : Cursor) return Boolean;\n+\n+   function Equivalent_Elements (Left, Right : Cursor) return Boolean;\n+\n+   function Equivalent_Elements\n+     (Left  : Cursor;\n+      Right : Element_Type) return Boolean;\n+\n+   function Equivalent_Elements\n+     (Left  : Element_Type;\n+      Right : Cursor) return Boolean;\n+\n+   procedure Iterate\n+     (Container : Set;\n+      Process   : not null access procedure (Position : Cursor));\n \n    procedure Union (Target : in out Set; Source : Set);\n \n@@ -128,40 +156,12 @@ pragma Preelaborate (Hashed_Sets);\n \n    function Is_Subset (Subset : Set; Of_Set : Set) return Boolean;\n \n-   function Contains (Container : Set; Item : Element_Type) return Boolean;\n-\n-   function Find\n-     (Container : Set;\n-      Item      : Element_Type) return Cursor;\n-\n    function Capacity (Container : Set) return Count_Type;\n \n    procedure Reserve_Capacity\n      (Container : in out Set;\n       Capacity  : Count_Type);\n \n-   function First (Container : Set) return Cursor;\n-\n-   function Next (Position : Cursor) return Cursor;\n-\n-   procedure Next (Position : in out Cursor);\n-\n-   function Has_Element (Position : Cursor) return Boolean;\n-\n-   function Equivalent_Keys (Left, Right : Cursor) return Boolean;\n-\n-   function Equivalent_Keys\n-     (Left  : Cursor;\n-      Right : Element_Type) return Boolean;\n-\n-   function Equivalent_Keys\n-     (Left  : Element_Type;\n-      Right : Cursor) return Boolean;\n-\n-   procedure Iterate\n-     (Container : Set;\n-      Process   : not null access procedure (Position : Cursor));\n-\n    generic\n       type Key_Type (<>) is limited private;\n \n@@ -183,18 +183,16 @@ pragma Preelaborate (Hashed_Sets);\n \n       function Element (Container : Set; Key : Key_Type) return Element_Type;\n \n-      --  TODO: resolve in atlanta\n-      --      procedure Replace\n-      --        (Container : in out Set;\n-      --         Key       : Key_Type;\n-      --         New_Item  : Element_Type);\n+      procedure Replace\n+        (Container : in out Set;\n+         Key       : Key_Type;\n+         New_Item  : Element_Type);\n \n       procedure Delete (Container : in out Set; Key : Key_Type);\n \n       procedure Exclude (Container : in out Set; Key : Key_Type);\n \n-      --  TODO: resolve name in atlanta: ???\n-      procedure Checked_Update_Element\n+      procedure Update_Element_Preserving_Key\n         (Container : in out Set;\n          Position  : Cursor;\n          Process   : not null access\n@@ -215,24 +213,35 @@ private\n    type Node_Type;\n    type Node_Access is access Node_Type;\n \n-   package HT_Types is\n-     new Hash_Tables.Generic_Hash_Table_Types (Node_Access);\n+   type Node_Type is\n+      limited record\n+         Element : Element_Type;\n+         Next    : Node_Access;\n+      end record;\n \n-   use HT_Types;\n+   package HT_Types is new Hash_Tables.Generic_Hash_Table_Types\n+     (Node_Type,\n+      Node_Access);\n \n-   type Set is new Hash_Table_Type with null record;\n+   type Set is new Ada.Finalization.Controlled with record\n+      HT : HT_Types.Hash_Table_Type;\n+   end record;\n \n    procedure Adjust (Container : in out Set);\n \n    procedure Finalize (Container : in out Set);\n \n-   type Set_Access is access constant Set;\n+   use HT_Types;\n+   use Ada.Finalization;\n+\n+   type Set_Access is access all Set;\n    for Set_Access'Storage_Size use 0;\n \n-   type Cursor is record\n-      Container : Set_Access;\n-      Node      : Node_Access;\n-   end record;\n+   type Cursor is\n+      record\n+         Container : Set_Access;\n+         Node      : Node_Access;\n+      end record;\n \n    No_Element : constant Cursor := (Container => null, Node => null);\n \n@@ -250,6 +259,6 @@ private\n \n    for Set'Read use Read;\n \n-   Empty_Set : constant Set := (Hash_Table_Type with null record);\n+   Empty_Set : constant Set := (Controlled with HT => (null, 0, 0, 0));\n \n end Ada.Containers.Hashed_Sets;"}, {"sha": "08d0532ca7efd1b2c7409a5c7283c67802ae9f4e", "filename": "gcc/ada/a-cohata.ads", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-cohata.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-cohata.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohata.ads?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "patch": "@@ -2,33 +2,55 @@\n --                                                                          --\n --                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---                        ADA.CONTAINERS.HASH_TABLES                        --\n+--            A D A . C O N T A I N E R S . H A S H _ T A B L E S           --\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n--- This specification is adapted from the Ada Reference Manual for use with --\n--- GNAT.  In accordance with the copyright of that document, you can freely --\n--- copy and modify this specification,  provided that if you redistribute a --\n--- modified version,  any changes that you have made are clearly indicated. --\n+--          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n-with Ada.Finalization;\n-\n package Ada.Containers.Hash_Tables is\n pragma Preelaborate;\n \n    generic\n-      type Node_Access is private;\n+      type Node_Type (<>) is limited private;\n+\n+      type Node_Access is access Node_Type;\n \n    package Generic_Hash_Table_Types is\n       type Buckets_Type is array (Hash_Type range <>) of Node_Access;\n \n       type Buckets_Access is access Buckets_Type;\n \n-      type Hash_Table_Type is new Ada.Finalization.Controlled with record\n+      type Hash_Table_Type is tagged record\n          Buckets : Buckets_Access;\n          Length  : Count_Type := 0;\n+         Busy    : Natural := 0;\n+         Lock    : Natural := 0;\n       end record;\n    end Generic_Hash_Table_Types;\n "}, {"sha": "39ef4e5f190d39ec10be31adb80a1e9bb55c9782", "filename": "gcc/ada/a-coinve.adb", "status": "modified", "additions": 1656, "deletions": 1483, "changes": 3139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-coinve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-coinve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinve.adb?ref=8704d4b30e3eace58fc9506cf3533b15835c784a"}, {"sha": "964247e9c65702a83abc9c7d5cef2114cae183d7", "filename": "gcc/ada/a-coinve.ads", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-coinve.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-coinve.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinve.ads?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---                    ADA.CONTAINERS.INDEFINITE_VECTORS                     --\n+--    A D A . C O N T A I N E R S . I N D E F I N I T E _ V E C T O R S     --\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -204,7 +204,7 @@ pragma Preelaborate (Indefinite_Vectors);\n \n    procedure Delete\n      (Container : in out Vector;\n-      Index     : Extended_Index;  --  TODO: verify\n+      Index     : Extended_Index;\n       Count     : Count_Type := 1);\n \n    procedure Delete\n@@ -238,7 +238,15 @@ pragma Preelaborate (Indefinite_Vectors);\n \n    generic\n       with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n-   procedure Generic_Sort (Container : Vector);\n+   package Generic_Sorting is\n+\n+      function Is_Sorted (Container : Vector) return Boolean;\n+\n+      procedure Sort (Container : in out Vector);\n+\n+      procedure Merge (Target, Source : in out Vector);\n+\n+   end Generic_Sorting;\n \n    function Find_Index\n      (Container : Vector;\n@@ -307,6 +315,8 @@ private\n    type Vector is new Controlled with record\n       Elements : Elements_Access;\n       Last     : Extended_Index := No_Index;\n+      Busy     : Natural := 0;\n+      Lock     : Natural := 0;\n    end record;\n \n    procedure Adjust (Container : in out Vector);\n@@ -327,7 +337,7 @@ private\n \n    for Vector'Read use Read;\n \n-   Empty_Vector : constant Vector := Vector'(Controlled with null, No_Index);\n+   Empty_Vector : constant Vector := (Controlled with null, No_Index, 0, 0);\n \n    type Vector_Access is access constant Vector;\n    for Vector_Access'Storage_Size use 0;\n@@ -340,4 +350,3 @@ private\n    No_Element : constant Cursor := Cursor'(null, Index_Type'First);\n \n end Ada.Containers.Indefinite_Vectors;\n-"}, {"sha": "77d11243d1c9f8d5a1ec1bd0c0f3c3b4f39c0d31", "filename": "gcc/ada/a-convec.adb", "status": "modified", "additions": 723, "deletions": 347, "changes": 1070, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-convec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-convec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.adb?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---                          ADA.CONTAINERS.VECTORS                          --\n+--                A D A . C O N T A I N E R S . V E C T O R S               --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -67,7 +67,7 @@ package body Ada.Containers.Vectors is\n                          new Elements_Type'(RE);\n \n          begin\n-            return (Controlled with Elements, Right.Last);\n+            return (Controlled with Elements, Right.Last, 0, 0);\n          end;\n       end if;\n \n@@ -80,28 +80,35 @@ package body Ada.Containers.Vectors is\n                          new Elements_Type'(LE);\n \n          begin\n-            return (Controlled with Elements, Left.Last);\n+            return (Controlled with Elements, Left.Last, 0, 0);\n          end;\n \n       end if;\n \n       declare\n-         Last_As_Int : constant Int'Base :=\n+         Last_As_Int : constant Int'Base :=  -- TODO: handle overflow\n                          Int (Index_Type'First) + Int (LN) + Int (RN) - 1;\n \n-         Last : constant Index_Type := Index_Type (Last_As_Int);\n+      begin\n+         if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n+            raise Constraint_Error;\n+         end if;\n \n-         LE : Elements_Type renames\n-                Left.Elements (Index_Type'First .. Left.Last);\n+         declare\n+            Last : constant Index_Type := Index_Type (Last_As_Int);\n \n-         RE : Elements_Type renames\n-                Right.Elements (Index_Type'First .. Right.Last);\n+            LE : Elements_Type renames\n+                   Left.Elements (Index_Type'First .. Left.Last);\n \n-         Elements : constant Elements_Access :=\n+            RE : Elements_Type renames\n+                   Right.Elements (Index_Type'First .. Right.Last);\n+\n+            Elements : constant Elements_Access :=\n                          new Elements_Type'(LE & RE);\n \n-      begin\n-         return (Controlled with Elements, Last);\n+         begin\n+            return (Controlled with Elements, Last, 0, 0);\n+         end;\n       end;\n    end \"&\";\n \n@@ -118,25 +125,32 @@ package body Ada.Containers.Vectors is\n                          new Elements_Subtype'(others => Right);\n \n          begin\n-            return (Controlled with Elements, Index_Type'First);\n+            return (Controlled with Elements, Index_Type'First, 0, 0);\n          end;\n       end if;\n \n       declare\n-         Last_As_Int : constant Int'Base :=\n+         Last_As_Int : constant Int'Base :=  -- TODO: handle overflow\n                          Int (Index_Type'First) + Int (LN);\n \n-         Last : constant Index_Type := Index_Type (Last_As_Int);\n+      begin\n+         if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n+            raise Constraint_Error;\n+         end if;\n \n-         LE : Elements_Type renames\n-                Left.Elements (Index_Type'First .. Left.Last);\n+         declare\n+            Last : constant Index_Type := Index_Type (Last_As_Int);\n \n-         subtype ET is Elements_Type (Index_Type'First .. Last);\n+            LE : Elements_Type renames\n+                   Left.Elements (Index_Type'First .. Left.Last);\n \n-         Elements : constant Elements_Access := new ET'(LE & Right);\n+            subtype ET is Elements_Type (Index_Type'First .. Last);\n \n-      begin\n-         return (Controlled with Elements, Last);\n+            Elements : constant Elements_Access := new ET'(LE & Right);\n+\n+         begin\n+            return (Controlled with Elements, Last, 0, 0);\n+         end;\n       end;\n    end \"&\";\n \n@@ -153,38 +167,51 @@ package body Ada.Containers.Vectors is\n                          new Elements_Subtype'(others => Left);\n \n          begin\n-            return (Controlled with Elements, Index_Type'First);\n+            return (Controlled with Elements, Index_Type'First, 0, 0);\n          end;\n       end if;\n \n       declare\n-         Last_As_Int : constant Int'Base :=\n+         Last_As_Int : constant Int'Base :=  -- TODO: handle overflow\n                          Int (Index_Type'First) + Int (RN);\n \n-         Last : constant Index_Type := Index_Type (Last_As_Int);\n+      begin\n+         if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n+            raise Constraint_Error;\n+         end if;\n \n-         RE : Elements_Type renames\n-                Right.Elements (Index_Type'First .. Right.Last);\n+         declare\n+            Last : constant Index_Type := Index_Type (Last_As_Int);\n \n-         subtype ET is Elements_Type (Index_Type'First .. Last);\n+            RE : Elements_Type renames\n+                   Right.Elements (Index_Type'First .. Right.Last);\n \n-         Elements : constant Elements_Access := new ET'(Left & RE);\n+            subtype ET is Elements_Type (Index_Type'First .. Last);\n \n-      begin\n-         return (Controlled with Elements, Last);\n+            Elements : constant Elements_Access := new ET'(Left & RE);\n+\n+         begin\n+            return (Controlled with Elements, Last, 0, 0);\n+         end;\n       end;\n    end \"&\";\n \n    function \"&\" (Left, Right  : Element_Type) return Vector is\n-      subtype IT is Index_Type'Base range\n-        Index_Type'First .. Index_Type'Succ (Index_Type'First);\n+   begin\n+      if Index_Type'First >= Index_Type'Last then\n+         raise Constraint_Error;\n+      end if;\n \n-      subtype ET is Elements_Type (IT);\n+      declare\n+         Last : constant Index_Type := Index_Type'First + 1;\n \n-      Elements : constant Elements_Access := new ET'(Left, Right);\n+         subtype ET is Elements_Type (Index_Type'First .. Last);\n \n-   begin\n-      return Vector'(Controlled with Elements, Elements'Last);\n+         Elements : constant Elements_Access := new ET'(Left, Right);\n+\n+      begin\n+         return (Controlled with Elements, Last, 0, 0);\n+      end;\n    end \"&\";\n \n    ---------\n@@ -216,25 +243,21 @@ package body Ada.Containers.Vectors is\n \n    procedure Adjust (Container : in out Vector) is\n    begin\n-      if Container.Elements = null then\n-         return;\n-      end if;\n-\n-      if Container.Elements'Length = 0\n-        or else Container.Last < Index_Type'First\n-      then\n+      if Container.Last = No_Index then\n          Container.Elements := null;\n          return;\n       end if;\n \n       declare\n-         X : constant Elements_Access := Container.Elements;\n-         L : constant Index_Type'Base := Container.Last;\n-         E : Elements_Type renames X (Index_Type'First .. L);\n+         E : constant Elements_Access := Container.Elements;\n+         L : constant Index_Type := Container.Last;\n+\n       begin\n          Container.Elements := null;\n-         Container.Last := Index_Type'Pred (Index_Type'First);\n-         Container.Elements := new Elements_Type'(E);\n+         Container.Last := No_Index;\n+         Container.Busy := 0;\n+         Container.Lock := 0;\n+         Container.Elements := new Elements_Type'(E (Index_Type'First .. L));\n          Container.Last := L;\n       end;\n    end Adjust;\n@@ -249,9 +272,13 @@ package body Ada.Containers.Vectors is\n          return;\n       end if;\n \n+      if Container.Last = Index_Type'Last then\n+         raise Constraint_Error;\n+      end if;\n+\n       Insert\n         (Container,\n-         Index_Type'Succ (Container.Last),\n+         Container.Last + 1,\n          New_Item);\n    end Append;\n \n@@ -265,9 +292,13 @@ package body Ada.Containers.Vectors is\n          return;\n       end if;\n \n+      if Container.Last = Index_Type'Last then\n+         raise Constraint_Error;\n+      end if;\n+\n       Insert\n         (Container,\n-         Index_Type'Succ (Container.Last),\n+         Container.Last + 1,\n          New_Item,\n          Count);\n    end Append;\n@@ -322,7 +353,11 @@ package body Ada.Containers.Vectors is\n \n    procedure Clear (Container : in out Vector) is\n    begin\n-      Container.Last := Index_Type'Pred (Index_Type'First);\n+      if Container.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n+\n+      Container.Last := No_Index;\n    end Clear;\n \n    --------------\n@@ -347,39 +382,54 @@ package body Ada.Containers.Vectors is\n       Count     : Count_Type := 1)\n    is\n    begin\n-      if Count = 0 then\n-         return;\n+      if Index < Index_Type'First then\n+         raise Constraint_Error;\n       end if;\n \n-      declare\n-         subtype I_Subtype is Index_Type'Base range\n-           Index_Type'First .. Container.Last;\n+      if Index > Container.Last then\n+         if Index > Container.Last + 1 then\n+            raise Constraint_Error;\n+         end if;\n \n-         I : constant I_Subtype := Index;\n-         --  TODO: not sure whether to relax this check ???\n+         return;\n+      end if;\n \n-         I_As_Int : constant Int := Int (I);\n+      if Count = 0 then\n+         return;\n+      end if;\n \n+      if Container.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n+\n+      declare\n+         I_As_Int        : constant Int := Int (Index);\n          Old_Last_As_Int : constant Int := Index_Type'Pos (Container.Last);\n \n          Count1 : constant Int'Base := Count_Type'Pos (Count);\n          Count2 : constant Int'Base := Old_Last_As_Int - I_As_Int + 1;\n-\n-         N : constant Int'Base := Int'Min (Count1, Count2);\n+         N      : constant Int'Base := Int'Min (Count1, Count2);\n \n          J_As_Int : constant Int'Base := I_As_Int + N;\n-         J        : constant Index_Type'Base := Index_Type'Base (J_As_Int);\n \n-         E : Elements_Type renames Container.Elements.all;\n+      begin\n+         if J_As_Int > Old_Last_As_Int then\n+            Container.Last := Index - 1;\n \n-         New_Last_As_Int : constant Int'Base := Old_Last_As_Int - N;\n+         else\n+            declare\n+               J : constant Index_Type := Index_Type (J_As_Int);\n+               E : Elements_Type renames Container.Elements.all;\n \n-         New_Last : constant Extended_Index :=\n-                      Extended_Index (New_Last_As_Int);\n+               New_Last_As_Int : constant Int'Base := Old_Last_As_Int - N;\n+               New_Last        : constant Index_Type :=\n+                                   Index_Type (New_Last_As_Int);\n \n-      begin\n-         E (I .. New_Last) := E (J .. Container.Last);\n-         Container.Last := New_Last;\n+            begin\n+               E (Index .. New_Last) := E (J .. Container.Last);\n+               Container.Last := New_Last;\n+            end;\n+         end if;\n       end;\n    end Delete;\n \n@@ -389,19 +439,15 @@ package body Ada.Containers.Vectors is\n       Count     : Count_Type := 1)\n    is\n    begin\n-\n-      if Position.Container /= null\n-        and then Position.Container /=\n-                   Vector_Access'(Container'Unchecked_Access)\n-      then\n-         raise Program_Error;\n+      if Position.Container = null then\n+         raise Constraint_Error;\n       end if;\n \n-      if Position.Container = null\n+      if Position.Container /=\n+           Vector_Access'(Container'Unchecked_Access)\n         or else Position.Index > Container.Last\n       then\n-         Position := No_Element;\n-         return;\n+         raise Program_Error;\n       end if;\n \n       Delete (Container, Position.Index, Count);\n@@ -449,14 +495,17 @@ package body Ada.Containers.Vectors is\n          return;\n       end if;\n \n-      if Count >= Length (Container) then\n-         Clear (Container);\n-         return;\n+      if Container.Busy > 0 then\n+         raise Program_Error;\n       end if;\n \n-      Index := Int'Base (Container.Last) - Int'Base (Count) + 1;\n+      Index := Int'Base (Container.Last) - Int'Base (Count);\n \n-      Delete (Container, Index_Type'Base (Index), Count);\n+      if Index < Index_Type'Pos (Index_Type'First) then\n+         Container.Last := No_Index;\n+      else\n+         Container.Last := Index_Type (Index);\n+      end if;\n    end Delete_Last;\n \n    -------------\n@@ -467,14 +516,20 @@ package body Ada.Containers.Vectors is\n      (Container : Vector;\n       Index     : Index_Type) return Element_Type\n    is\n-      subtype T is Index_Type'Base range\n-        Index_Type'First .. Container.Last;\n    begin\n-      return Container.Elements (T'(Index));\n+      if Index > Container.Last then\n+         raise Constraint_Error;\n+      end if;\n+\n+      return Container.Elements (Index);\n    end Element;\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n+      if Position.Container = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       return Element (Position.Container.all, Position.Index);\n    end Element;\n \n@@ -485,8 +540,12 @@ package body Ada.Containers.Vectors is\n    procedure Finalize (Container : in out Vector) is\n       X : Elements_Access := Container.Elements;\n    begin\n+      if Container.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n+\n       Container.Elements := null;\n-      Container.Last := Index_Type'Pred (Index_Type'First);\n+      Container.Last := No_Index;\n       Free (X);\n    end Finalize;\n \n@@ -501,8 +560,9 @@ package body Ada.Containers.Vectors is\n \n    begin\n       if Position.Container /= null\n-        and then Position.Container /=\n-                   Vector_Access'(Container'Unchecked_Access)\n+        and then (Position.Container /=\n+                    Vector_Access'(Container'Unchecked_Access)\n+                  or else Position.Index > Container.Last)\n       then\n          raise Program_Error;\n       end if;\n@@ -566,26 +626,112 @@ package body Ada.Containers.Vectors is\n       return Index_Type'First;\n    end First_Index;\n \n-   ------------------\n-   -- Generic_Sort --\n-   ------------------\n+   ---------------------\n+   -- Generic_Sorting --\n+   ---------------------\n \n-   procedure Generic_Sort (Container : Vector)\n-   is\n-      procedure Sort is\n-         new Generic_Array_Sort\n-          (Index_Type   => Index_Type,\n-           Element_Type => Element_Type,\n-           Array_Type   => Elements_Type,\n-           \"<\"          => \"<\");\n+   package body Generic_Sorting is\n \n-   begin\n-      if Container.Elements = null then\n-         return;\n-      end if;\n+      ---------------\n+      -- Is_Sorted --\n+      ---------------\n+\n+      function Is_Sorted (Container : Vector) return Boolean is\n+      begin\n+         if Container.Last <= Index_Type'First then\n+            return True;\n+         end if;\n+\n+         declare\n+            E : Elements_Type renames Container.Elements.all;\n+         begin\n+            for I in Index_Type'First .. Container.Last - 1 loop\n+               if E (I + 1) < E (I) then\n+                  return False;\n+               end if;\n+            end loop;\n+         end;\n+\n+         return True;\n+      end Is_Sorted;\n+\n+      -----------\n+      -- Merge --\n+      -----------\n \n-      Sort (Container.Elements (Index_Type'First .. Container.Last));\n-   end Generic_Sort;\n+      procedure Merge (Target, Source : in out Vector) is\n+         I : Index_Type'Base := Target.Last;\n+         J : Index_Type'Base;\n+\n+      begin\n+         if Target.Last < Index_Type'First then\n+            Move (Target => Target, Source => Source);\n+            return;\n+         end if;\n+\n+         if Target'Address = Source'Address then\n+            return;\n+         end if;\n+\n+         if Source.Last < Index_Type'First then\n+            return;\n+         end if;\n+\n+         if Source.Busy > 0 then\n+            raise Program_Error;\n+         end if;\n+\n+         Target.Set_Length (Length (Target) + Length (Source));\n+\n+         J := Target.Last;\n+         while Source.Last >= Index_Type'First loop\n+            if I < Index_Type'First then\n+               Target.Elements (Index_Type'First .. J) :=\n+                 Source.Elements (Index_Type'First .. Source.Last);\n+\n+               Source.Last := No_Index;\n+               return;\n+            end if;\n+\n+            if Source.Elements (Source.Last) < Target.Elements (I) then\n+               Target.Elements (J) := Target.Elements (I);\n+               I := I - 1;\n+\n+            else\n+               Target.Elements (J) := Source.Elements (Source.Last);\n+               Source.Last := Source.Last - 1;\n+            end if;\n+\n+            J := J - 1;\n+         end loop;\n+      end Merge;\n+\n+      ----------\n+      -- Sort --\n+      ----------\n+\n+      procedure Sort (Container : in out Vector)\n+      is\n+         procedure Sort is\n+            new Generic_Array_Sort\n+             (Index_Type   => Index_Type,\n+              Element_Type => Element_Type,\n+              Array_Type   => Elements_Type,\n+              \"<\"          => \"<\");\n+\n+      begin\n+         if Container.Last <= Index_Type'First then\n+            return;\n+         end if;\n+\n+         if Container.Lock > 0 then\n+            raise Program_Error;\n+         end if;\n+\n+         Sort (Container.Elements (Index_Type'First .. Container.Last));\n+      end Sort;\n+\n+   end Generic_Sorting;\n \n    -----------------\n    -- Has_Element --\n@@ -610,40 +756,47 @@ package body Ada.Containers.Vectors is\n       New_Item  : Element_Type;\n       Count     : Count_Type := 1)\n    is\n-      Old_Last : constant Extended_Index := Container.Last;\n-\n-      Old_Last_As_Int : constant Int := Index_Type'Pos (Old_Last);\n-\n       N : constant Int := Count_Type'Pos (Count);\n \n-      New_Last_As_Int : constant Int'Base := Old_Last_As_Int + N;\n+      New_Last_As_Int : Int'Base;\n+      New_Last        : Index_Type;\n \n-      New_Last : constant Extended_Index := Extended_Index (New_Last_As_Int);\n+      Dst : Elements_Access;\n \n-      Index : Index_Type;\n+   begin\n+      if Before < Index_Type'First then\n+         raise Constraint_Error;\n+      end if;\n \n-      Dst_Last : Index_Type;\n-      Dst      : Elements_Access;\n+      if Before > Container.Last\n+        and then Before > Container.Last + 1\n+      then\n+         raise Constraint_Error;\n+      end if;\n \n-   begin\n       if Count = 0 then\n          return;\n       end if;\n \n       declare\n-         subtype Before_Subtype is Index_Type'Base range\n-           Index_Type'First .. Index_Type'Succ (Container.Last);\n+         Old_Last : constant Extended_Index := Container.Last;\n \n-         Old_First : constant Before_Subtype := Before;\n+         Old_Last_As_Int : constant Int := Index_Type'Pos (Old_Last);\n \n-         Old_First_As_Int : constant Int := Index_Type'Pos (Old_First);\n+      begin\n+         New_Last_As_Int := Old_Last_As_Int + N;\n \n-         New_First_As_Int : constant Int'Base := Old_First_As_Int + N;\n+         if New_Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n+            raise Constraint_Error;\n+         end if;\n \n-      begin\n-         Index := Index_Type (New_First_As_Int);\n+         New_Last := Index_Type (New_Last_As_Int);\n       end;\n \n+      if Container.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n+\n       if Container.Elements = null then\n          declare\n             subtype Elements_Subtype is\n@@ -660,57 +813,86 @@ package body Ada.Containers.Vectors is\n          declare\n             E : Elements_Type renames Container.Elements.all;\n          begin\n-            E (Index .. New_Last) := E (Before .. Container.Last);\n-            E (Before .. Index_Type'Pred (Index)) := (others => New_Item);\n+            if Before <= Container.Last then\n+               declare\n+                  Index_As_Int : constant Int'Base :=\n+                                   Index_Type'Pos (Before) + N;\n+\n+                  Index : constant Index_Type := Index_Type (Index_As_Int);\n+\n+               begin\n+                  E (Index .. New_Last) := E (Before .. Container.Last);\n+\n+                  E (Before .. Index_Type'Pred (Index)) :=\n+                      (others => New_Item);\n+               end;\n+\n+            else\n+               E (Before .. New_Last) := (others => New_Item);\n+            end if;\n          end;\n \n          Container.Last := New_Last;\n          return;\n       end if;\n \n       declare\n-         First : constant Int := Int (Index_Type'First);\n-\n+         First    : constant Int := Int (Index_Type'First);\n          New_Size : constant Int'Base := New_Last_As_Int - First + 1;\n-         Max_Size : constant Int'Base := Int (Index_Type'Last) - First + 1;\n-\n-         Size, Dst_Last_As_Int : Int'Base;\n+         Size     : Int'Base := Int'Max (1, Container.Elements'Length);\n \n       begin\n-         if New_Size >= Max_Size / 2 then\n-            Dst_Last := Index_Type'Last;\n+         while Size < New_Size loop\n+            if Size > Int'Last / 2 then\n+               Size := Int'Last;\n+               exit;\n+            end if;\n \n-         else\n-            Size := Container.Elements'Length;\n+            Size := 2 * Size;\n+         end loop;\n \n-            if Size = 0 then\n-               Size := 1;\n-            end if;\n+         --  TODO: The following calculations aren't quite right, since\n+         --  there will be overflow if Index_Type'Range is very large\n+         --  (e.g. this package is instantiated with a 64-bit integer).\n+         --  END TODO.\n \n-            while Size < New_Size loop\n-               Size := 2 * Size;\n-            end loop;\n+         declare\n+            Max_Size : constant Int'Base := Int (Index_Type'Last) - First + 1;\n+         begin\n+            if Size > Max_Size then\n+               Size := Max_Size;\n+            end if;\n+         end;\n \n-            Dst_Last_As_Int := First + Size - 1;\n-            Dst_Last := Index_Type (Dst_Last_As_Int);\n-         end if;\n+         declare\n+            Dst_Last : constant Index_Type := Index_Type (First + Size - 1);\n+         begin\n+            Dst := new Elements_Type (Index_Type'First .. Dst_Last);\n+         end;\n       end;\n \n-      Dst := new Elements_Type (Index_Type'First .. Dst_Last);\n-\n       declare\n          Src : Elements_Type renames Container.Elements.all;\n \n       begin\n          Dst (Index_Type'First .. Index_Type'Pred (Before)) :=\n            Src (Index_Type'First .. Index_Type'Pred (Before));\n \n-         Dst (Before .. Index_Type'Pred (Index)) :=\n-           (others => New_Item);\n+         if Before <= Container.Last then\n+            declare\n+               Index_As_Int : constant Int'Base :=\n+                                Index_Type'Pos (Before) + N;\n \n-         Dst (Index .. New_Last) :=\n-           Src (Before .. Container.Last);\n+               Index : constant Index_Type := Index_Type (Index_As_Int);\n \n+            begin\n+               Dst (Before .. Index_Type'Pred (Index)) := (others => New_Item);\n+               Dst (Index .. New_Last) := Src (Before .. Container.Last);\n+            end;\n+\n+         else\n+            Dst (Before .. New_Last) := (others => New_Item);\n+         end if;\n       exception\n          when others =>\n             Free (Dst);\n@@ -734,6 +916,16 @@ package body Ada.Containers.Vectors is\n       N : constant Count_Type := Length (New_Item);\n \n    begin\n+      if Before < Index_Type'First then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Before > Container.Last\n+        and then Before > Container.Last + 1\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n       if N = 0 then\n          return;\n       end if;\n@@ -747,51 +939,56 @@ package body Ada.Containers.Vectors is\n          Dst_Last : constant Index_Type := Index_Type (Dst_Last_As_Int);\n \n       begin\n-         if Container'Address = New_Item'Address then\n-            declare\n-               subtype Src_Index_Subtype is Index_Type'Base range\n-                 Index_Type'First .. Index_Type'Pred (Before);\n+         if Container'Address /= New_Item'Address then\n+            Container.Elements (Before .. Dst_Last) :=\n+              New_Item.Elements (Index_Type'First .. New_Item.Last);\n \n-               Src : Elements_Type renames\n-                       Container.Elements (Src_Index_Subtype);\n+            return;\n+         end if;\n \n-               Index_As_Int : constant Int'Base :=\n-                                Int (Before) + Src'Length - 1;\n+         declare\n+            subtype Src_Index_Subtype is Index_Type'Base range\n+              Index_Type'First .. Before - 1;\n \n-               Index : constant Index_Type'Base :=\n-                         Index_Type'Base (Index_As_Int);\n+            Src : Elements_Type renames\n+                    Container.Elements (Src_Index_Subtype);\n \n-               Dst : Elements_Type renames\n-                       Container.Elements (Before .. Index);\n+            Index_As_Int : constant Int'Base :=\n+                             Int (Before) + Src'Length - 1;\n \n-            begin\n-               Dst := Src;\n-            end;\n+            Index : constant Index_Type'Base :=\n+                      Index_Type'Base (Index_As_Int);\n \n-            declare\n-               subtype Src_Index_Subtype is Index_Type'Base range\n-                 Index_Type'Succ (Dst_Last) .. Container.Last;\n+            Dst : Elements_Type renames\n+                    Container.Elements (Before .. Index);\n \n-               Src : Elements_Type renames\n-                       Container.Elements (Src_Index_Subtype);\n+         begin\n+            Dst := Src;\n+         end;\n \n-               Index_As_Int : constant Int'Base :=\n-                                Dst_Last_As_Int - Src'Length + 1;\n+         if Dst_Last = Container.Last then\n+            return;\n+         end if;\n \n-               Index : constant Index_Type'Base :=\n-                         Index_Type'Base (Index_As_Int);\n+         declare\n+            subtype Src_Index_Subtype is Index_Type'Base range\n+              Dst_Last + 1 .. Container.Last;\n \n-               Dst : Elements_Type renames\n-                       Container.Elements (Index .. Dst_Last);\n+            Src : Elements_Type renames\n+                    Container.Elements (Src_Index_Subtype);\n \n-            begin\n-               Dst := Src;\n-            end;\n+            Index_As_Int : constant Int'Base :=\n+                             Dst_Last_As_Int - Src'Length + 1;\n \n-         else\n-            Container.Elements (Before .. Dst_Last) :=\n-              New_Item.Elements (Index_Type'First .. New_Item.Last);\n-         end if;\n+            Index : constant Index_Type :=\n+                      Index_Type (Index_As_Int);\n+\n+            Dst : Elements_Type renames\n+                    Container.Elements (Index .. Dst_Last);\n+\n+         begin\n+            Dst := Src;\n+         end;\n       end;\n    end Insert;\n \n@@ -816,7 +1013,12 @@ package body Ada.Containers.Vectors is\n       if Before.Container = null\n         or else Before.Index > Container.Last\n       then\n-         Index := Index_Type'Succ (Container.Last);\n+         if Container.Last = Index_Type'Last then\n+            raise Constraint_Error;\n+         end if;\n+\n+         Index := Container.Last + 1;\n+\n       else\n          Index := Before.Index;\n       end if;\n@@ -854,7 +1056,12 @@ package body Ada.Containers.Vectors is\n       if Before.Container = null\n         or else Before.Index > Container.Last\n       then\n-         Index := Index_Type'Succ (Container.Last);\n+         if Container.Last = Index_Type'Last then\n+            raise Constraint_Error;\n+         end if;\n+\n+         Index := Container.Last + 1;\n+\n       else\n          Index := Before.Index;\n       end if;\n@@ -886,7 +1093,12 @@ package body Ada.Containers.Vectors is\n       if Before.Container = null\n         or else Before.Index > Container.Last\n       then\n-         Index := Index_Type'Succ (Container.Last);\n+         if Container.Last = Index_Type'Last then\n+            raise Constraint_Error;\n+         end if;\n+\n+         Index := Container.Last + 1;\n+\n       else\n          Index := Before.Index;\n       end if;\n@@ -925,7 +1137,12 @@ package body Ada.Containers.Vectors is\n       if Before.Container = null\n         or else Before.Index > Container.Last\n       then\n-         Index := Index_Type'Succ (Container.Last);\n+         if Container.Last = Index_Type'Last then\n+            raise Constraint_Error;\n+         end if;\n+\n+         Index := Container.Last + 1;\n+\n       else\n          Index := Before.Index;\n       end if;\n@@ -944,40 +1161,47 @@ package body Ada.Containers.Vectors is\n       Before    : Extended_Index;\n       Count     : Count_Type := 1)\n    is\n-      Old_Last : constant Extended_Index := Container.Last;\n-\n-      Old_Last_As_Int : constant Int := Index_Type'Pos (Old_Last);\n-\n       N : constant Int := Count_Type'Pos (Count);\n \n-      New_Last_As_Int : constant Int'Base := Old_Last_As_Int + N;\n+      New_Last_As_Int : Int'Base;\n+      New_Last        : Index_Type;\n \n-      New_Last : constant Extended_Index := Extended_Index (New_Last_As_Int);\n+      Dst : Elements_Access;\n \n-      Index : Index_Type;\n+   begin\n+      if Before < Index_Type'First then\n+         raise Constraint_Error;\n+      end if;\n \n-      Dst_Last : Index_Type;\n-      Dst      : Elements_Access;\n+      if Before > Container.Last\n+        and then Before > Container.Last + 1\n+      then\n+         raise Constraint_Error;\n+      end if;\n \n-   begin\n       if Count = 0 then\n          return;\n       end if;\n \n       declare\n-         subtype Before_Subtype is Index_Type'Base range\n-           Index_Type'First .. Index_Type'Succ (Container.Last);\n+         Old_Last : constant Extended_Index := Container.Last;\n \n-         Old_First : constant Before_Subtype := Before;\n+         Old_Last_As_Int : constant Int := Index_Type'Pos (Old_Last);\n \n-         Old_First_As_Int : constant Int := Index_Type'Pos (Old_First);\n+      begin\n+         New_Last_As_Int := Old_Last_As_Int + N;\n \n-         New_First_As_Int : constant Int'Base := Old_First_As_Int + N;\n+         if New_Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n+            raise Constraint_Error;\n+         end if;\n \n-      begin\n-         Index := Index_Type (New_First_As_Int);\n+         New_Last := Index_Type (New_Last_As_Int);\n       end;\n \n+      if Container.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n+\n       if Container.Elements = null then\n          Container.Elements :=\n            new Elements_Type (Index_Type'First .. New_Last);\n@@ -990,53 +1214,76 @@ package body Ada.Containers.Vectors is\n          declare\n             E : Elements_Type renames Container.Elements.all;\n          begin\n-            E (Index .. New_Last) := E (Before .. Container.Last);\n+            if Before <= Container.Last then\n+               declare\n+                  Index_As_Int : constant Int'Base :=\n+                                   Index_Type'Pos (Before) + N;\n+\n+                  Index : constant Index_Type := Index_Type (Index_As_Int);\n+\n+               begin\n+                  E (Index .. New_Last) := E (Before .. Container.Last);\n+               end;\n+            end if;\n          end;\n \n          Container.Last := New_Last;\n          return;\n       end if;\n \n       declare\n-         First : constant Int := Int (Index_Type'First);\n-\n+         First    : constant Int := Int (Index_Type'First);\n          New_Size : constant Int'Base := New_Last_As_Int - First + 1;\n-         Max_Size : constant Int'Base := Int (Index_Type'Last) - First + 1;\n-\n-         Size, Dst_Last_As_Int : Int'Base;\n+         Size     : Int'Base := Int'Max (1, Container.Elements'Length);\n \n       begin\n-         if New_Size >= Max_Size / 2 then\n-            Dst_Last := Index_Type'Last;\n+         while Size < New_Size loop\n+            if Size > Int'Last / 2 then\n+               Size := Int'Last;\n+               exit;\n+            end if;\n \n-         else\n-            Size := Container.Elements'Length;\n+            Size := 2 * Size;\n+         end loop;\n \n-            if Size = 0 then\n-               Size := 1;\n-            end if;\n+         --  TODO: The following calculations aren't quite right, since\n+         --  there will be overflow if Index_Type'Range is very large\n+         --  (e.g. this package is instantiated with a 64-bit integer).\n+         --  END TODO.\n \n-            while Size < New_Size loop\n-               Size := 2 * Size;\n-            end loop;\n+         declare\n+            Max_Size : constant Int'Base := Int (Index_Type'Last) - First + 1;\n+         begin\n+            if Size > Max_Size then\n+               Size := Max_Size;\n+            end if;\n+         end;\n \n-            Dst_Last_As_Int := First + Size - 1;\n-            Dst_Last := Index_Type (Dst_Last_As_Int);\n-         end if;\n+         declare\n+            Dst_Last : constant Index_Type := Index_Type (First + Size - 1);\n+         begin\n+            Dst := new Elements_Type (Index_Type'First .. Dst_Last);\n+         end;\n       end;\n \n-      Dst := new Elements_Type (Index_Type'First .. Dst_Last);\n-\n       declare\n          Src : Elements_Type renames Container.Elements.all;\n \n       begin\n          Dst (Index_Type'First .. Index_Type'Pred (Before)) :=\n            Src (Index_Type'First .. Index_Type'Pred (Before));\n \n-         Dst (Index .. New_Last) :=\n-           Src (Before .. Container.Last);\n+         if Before <= Container.Last then\n+            declare\n+               Index_As_Int : constant Int'Base :=\n+                                Index_Type'Pos (Before) + N;\n \n+               Index : constant Index_Type := Index_Type (Index_As_Int);\n+\n+            begin\n+               Dst (Index .. New_Last) := Src (Before .. Container.Last);\n+            end;\n+         end if;\n       exception\n          when others =>\n             Free (Dst);\n@@ -1048,7 +1295,6 @@ package body Ada.Containers.Vectors is\n       begin\n          Container.Elements := Dst;\n          Container.Last := New_Last;\n-\n          Free (X);\n       end;\n    end Insert_Space;\n@@ -1083,7 +1329,12 @@ package body Ada.Containers.Vectors is\n       if Before.Container = null\n         or else Before.Index > Container.Last\n       then\n-         Index := Index_Type'Succ (Container.Last);\n+         if Container.Last = Index_Type'Last then\n+            raise Constraint_Error;\n+         end if;\n+\n+         Index := Container.Last + 1;\n+\n       else\n          Index := Before.Index;\n       end if;\n@@ -1110,10 +1361,25 @@ package body Ada.Containers.Vectors is\n      (Container : Vector;\n       Process   : not null access procedure (Position : Cursor))\n    is\n+      V : Vector renames Container'Unrestricted_Access.all;\n+      B : Natural renames V.Busy;\n+\n    begin\n-      for Indx in Index_Type'First .. Container.Last loop\n-         Process (Cursor'(Container'Unchecked_Access, Indx));\n-      end loop;\n+\n+      B := B + 1;\n+\n+      begin\n+         for Indx in Index_Type'First .. Container.Last loop\n+            Process (Cursor'(Container'Unchecked_Access, Indx));\n+         end loop;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n+\n    end Iterate;\n \n    ----------\n@@ -1155,7 +1421,12 @@ package body Ada.Containers.Vectors is\n       L : constant Int := Int (Container.Last);\n       F : constant Int := Int (Index_Type'First);\n       N : constant Int'Base := L - F + 1;\n+\n    begin\n+      if N > Count_Type'Pos (Count_Type'Last) then\n+         raise Constraint_Error;\n+      end if;\n+\n       return Count_Type (N);\n    end Length;\n \n@@ -1167,25 +1438,28 @@ package body Ada.Containers.Vectors is\n      (Target : in out Vector;\n       Source : in out Vector)\n    is\n-      X : Elements_Access := Target.Elements;\n-\n    begin\n       if Target'Address = Source'Address then\n          return;\n       end if;\n \n-      if Target.Last >= Index_Type'First then\n-         raise Constraint_Error;\n+      if Target.Busy > 0 then\n+         raise Program_Error;\n       end if;\n \n-      Target.Elements := null;\n-      Free (X);\n+      if Source.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n \n-      Target.Elements := Source.Elements;\n-      Target.Last := Source.Last;\n+      declare\n+         Target_Elements : constant Elements_Access := Target.Elements;\n+      begin\n+         Target.Elements := Source.Elements;\n+         Source.Elements := Target_Elements;\n+      end;\n \n-      Source.Elements := null;\n-      Source.Last := Index_Type'Pred (Index_Type'First);\n+      Target.Last := Source.Last;\n+      Source.Last := No_Index;\n    end Move;\n \n    ----------\n@@ -1199,7 +1473,7 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       if Position.Index < Position.Container.Last then\n-         return (Position.Container, Index_Type'Succ (Position.Index));\n+         return (Position.Container, Position.Index + 1);\n       end if;\n \n       return No_Element;\n@@ -1216,7 +1490,7 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       if Position.Index < Position.Container.Last then\n-         Position.Index := Index_Type'Succ (Position.Index);\n+         Position.Index := Position.Index + 1;\n       else\n          Position := No_Element;\n       end if;\n@@ -1254,7 +1528,7 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       if Position.Index > Index_Type'First then\n-         Position.Index := Index_Type'Pred (Position.Index);\n+         Position.Index := Position.Index - 1;\n       else\n          Position := No_Element;\n       end if;\n@@ -1267,7 +1541,7 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       if Position.Index > Index_Type'First then\n-         return (Position.Container, Index_Type'Pred (Position.Index));\n+         return (Position.Container, Position.Index - 1);\n       end if;\n \n       return No_Element;\n@@ -1282,23 +1556,41 @@ package body Ada.Containers.Vectors is\n       Index     : Index_Type;\n       Process   : not null access procedure (Element : Element_Type))\n    is\n-      subtype T is Index_Type'Base range\n-        Index_Type'First .. Container.Last;\n+      V : Vector renames Container'Unrestricted_Access.all;\n+      B : Natural renames V.Busy;\n+      L : Natural renames V.Lock;\n+\n    begin\n-      Process (Container.Elements (T'(Index)));\n+      if Index > Container.Last then\n+         raise Constraint_Error;\n+      end if;\n+\n+      B := B + 1;\n+      L := L + 1;\n+\n+      begin\n+         Process (V.Elements (Index));\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      L := L - 1;\n+      B := B - 1;\n    end Query_Element;\n \n    procedure Query_Element\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type))\n    is\n-      Container : Vector renames Position.Container.all;\n-\n-      subtype T is Index_Type'Base range\n-        Index_Type'First .. Container.Last;\n-\n    begin\n-      Process (Container.Elements (T'(Position.Index)));\n+      if Position.Container = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      Query_Element (Position.Container.all, Position.Index, Process);\n    end Query_Element;\n \n    ----------\n@@ -1310,7 +1602,7 @@ package body Ada.Containers.Vectors is\n       Container : out Vector)\n    is\n       Length : Count_Type'Base;\n-      Last   : Index_Type'Base := Index_Type'Pred (Index_Type'First);\n+      Last   : Index_Type'Base := No_Index;\n \n    begin\n       Clear (Container);\n@@ -1322,7 +1614,7 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       for J in Count_Type range 1 .. Length loop\n-         Last := Index_Type'Succ (Last);\n+         Last := Last + 1;\n          Element_Type'Read (Stream, Container.Elements (Last));\n          Container.Last := Last;\n       end loop;\n@@ -1337,17 +1629,25 @@ package body Ada.Containers.Vectors is\n       Index     : Index_Type;\n       By        : Element_Type)\n    is\n-      subtype T is Index_Type'Base range\n-        Index_Type'First .. Container.Last;\n    begin\n-      Container.Elements (T'(Index)) := By;\n+      if Index > Container.Last then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Container.Lock > 0 then\n+         raise Program_Error;\n+      end if;\n+\n+      Container.Elements (Index) := By;\n    end Replace_Element;\n \n    procedure Replace_Element (Position : Cursor; By : Element_Type) is\n-      subtype T is Index_Type'Base range\n-        Index_Type'First .. Position.Container.Last;\n    begin\n-      Position.Container.Elements (T'(Position.Index)) := By;\n+      if Position.Container = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      Replace_Element (Position.Container.all, Position.Index, By);\n    end Replace_Element;\n \n    ----------------------\n@@ -1371,6 +1671,10 @@ package body Ada.Containers.Vectors is\n             end;\n \n          elsif N < Container.Elements'Length then\n+            if Container.Busy > 0 then\n+               raise Program_Error;\n+            end if;\n+\n             declare\n                subtype Array_Index_Subtype is Index_Type'Base range\n                  Index_Type'First .. Container.Last;\n@@ -1397,20 +1701,30 @@ package body Ada.Containers.Vectors is\n             Last_As_Int : constant Int'Base :=\n                             Int (Index_Type'First) + Int (Capacity) - 1;\n \n-            Last : constant Index_Type := Index_Type (Last_As_Int);\n+         begin\n+            if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n+               raise Constraint_Error;\n+            end if;\n \n-            subtype Array_Subtype is\n-              Elements_Type (Index_Type'First .. Last);\n+            declare\n+               Last : constant Index_Type := Index_Type (Last_As_Int);\n \n-         begin\n-            Container.Elements := new Array_Subtype;\n+               subtype Array_Subtype is\n+                 Elements_Type (Index_Type'First .. Last);\n+            begin\n+               Container.Elements := new Array_Subtype;\n+            end;\n          end;\n \n          return;\n       end if;\n \n       if Capacity <= N then\n          if N < Container.Elements'Length then\n+            if Container.Busy > 0 then\n+               raise Program_Error;\n+            end if;\n+\n             declare\n                subtype Array_Index_Subtype is Index_Type'Base range\n                  Index_Type'First .. Container.Last;\n@@ -1437,39 +1751,50 @@ package body Ada.Containers.Vectors is\n          return;\n       end if;\n \n+      if Container.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n+\n       declare\n          Last_As_Int : constant Int'Base :=\n                          Int (Index_Type'First) + Int (Capacity) - 1;\n \n-         Last : constant Index_Type := Index_Type (Last_As_Int);\n-\n-         subtype Array_Subtype is\n-           Elements_Type (Index_Type'First .. Last);\n-\n-         E : Elements_Access := new Array_Subtype;\n-\n       begin\n+         if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n+            raise Constraint_Error;\n+         end if;\n+\n          declare\n-            Src : Elements_Type renames\n-                    Container.Elements (Index_Type'First .. Container.Last);\n+            Last : constant Index_Type := Index_Type (Last_As_Int);\n+\n+            subtype Array_Subtype is\n+              Elements_Type (Index_Type'First .. Last);\n \n-            Tgt : Elements_Type renames\n-                    E (Index_Type'First .. Container.Last);\n+            E : Elements_Access := new Array_Subtype;\n \n          begin\n-            Tgt := Src;\n+            declare\n+               Src : Elements_Type renames\n+                       Container.Elements (Index_Type'First .. Container.Last);\n \n-         exception\n-            when others =>\n-               Free (E);\n-               raise;\n-         end;\n+               Tgt : Elements_Type renames\n+                       E (Index_Type'First .. Container.Last);\n \n-         declare\n-            X : Elements_Access := Container.Elements;\n-         begin\n-            Container.Elements := E;\n-            Free (X);\n+            begin\n+               Tgt := Src;\n+\n+            exception\n+               when others =>\n+                  Free (E);\n+                  raise;\n+            end;\n+\n+            declare\n+               X : Elements_Access := Container.Elements;\n+            begin\n+               Container.Elements := E;\n+               Free (X);\n+            end;\n          end;\n       end;\n    end Reserve_Capacity;\n@@ -1545,10 +1870,25 @@ package body Ada.Containers.Vectors is\n      (Container : Vector;\n       Process   : not null access procedure (Position : Cursor))\n    is\n+      V : Vector renames Container'Unrestricted_Access.all;\n+      B : Natural renames V.Busy;\n+\n    begin\n-      for Indx in reverse Index_Type'First .. Container.Last loop\n-         Process (Cursor'(Container'Unchecked_Access, Indx));\n-      end loop;\n+\n+      B := B + 1;\n+\n+      begin\n+         for Indx in reverse Index_Type'First .. Container.Last loop\n+            Process (Cursor'(Container'Unchecked_Access, Indx));\n+         end loop;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n+\n    end Reverse_Iterate;\n \n    ----------------\n@@ -1557,68 +1897,71 @@ package body Ada.Containers.Vectors is\n \n    procedure Set_Length (Container : in out Vector; Length : Count_Type) is\n    begin\n-      if Length = 0 then\n-         Clear (Container);\n+      if Length = Vectors.Length (Container) then\n          return;\n       end if;\n \n+      if Container.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n+\n+      if Length > Capacity (Container) then\n+         Reserve_Capacity (Container, Capacity => Length);\n+      end if;\n+\n       declare\n          Last_As_Int : constant Int'Base :=\n                          Int (Index_Type'First) + Int (Length) - 1;\n-\n-         Last        : constant Index_Type := Index_Type (Last_As_Int);\n-\n       begin\n-         if Length > Capacity (Container) then\n-            Reserve_Capacity (Container, Capacity => Length);\n-         end if;\n-\n-         Container.Last := Last;\n+         Container.Last := Index_Type'Base (Last_As_Int);\n       end;\n    end Set_Length;\n \n    ----------\n    -- Swap --\n    ----------\n \n-   procedure Swap\n-     (Container : Vector;\n-      I, J      : Index_Type)\n-   is\n+   procedure Swap (Container : Vector; I, J : Index_Type) is\n+   begin\n+      if I > Container.Last\n+        or else J > Container.Last\n+      then\n+         raise Constraint_Error;\n+      end if;\n \n-      subtype T is Index_Type'Base range\n-        Index_Type'First .. Container.Last;\n+      if I = J then\n+         return;\n+      end if;\n \n-      EI : constant Element_Type := Container.Elements (T'(I));\n+      if Container.Lock > 0 then\n+         raise Program_Error;\n+      end if;\n \n-   begin\n+      declare\n+         EI : Element_Type renames Container.Elements (I);\n+         EJ : Element_Type renames Container.Elements (J);\n \n-      Container.Elements (T'(I)) := Container.Elements (T'(J));\n-      Container.Elements (T'(J)) := EI;\n+         EI_Copy : constant Element_Type := EI;\n \n+      begin\n+         EI := EJ;\n+         EJ := EI_Copy;\n+      end;\n    end Swap;\n \n    procedure Swap (I, J : Cursor) is\n+   begin\n+      if I.Container = null\n+        or else J.Container = null\n+      then\n+         raise Constraint_Error;\n+      end if;\n \n-      --  NOTE: The behavior has been liberalized here to\n-      --  allow I and J to designate different containers.\n-      --  TODO: Probably this is supposed to raise P_E ???\n-\n-      subtype TI is Index_Type'Base range\n-        Index_Type'First .. I.Container.Last;\n-\n-      EI : Element_Type renames I.Container.Elements (TI'(I.Index));\n-\n-      EI_Copy : constant Element_Type := EI;\n-\n-      subtype TJ is Index_Type'Base range\n-        Index_Type'First .. J.Container.Last;\n-\n-      EJ : Element_Type renames J.Container.Elements (TJ'(J.Index));\n+      if I.Container /= J.Container then\n+         raise Program_Error;\n+      end if;\n \n-   begin\n-      EI := EJ;\n-      EJ := EI_Copy;\n+      Swap (I.Container.all, I.Index, J.Index);\n    end Swap;\n \n    ---------------\n@@ -1667,11 +2010,18 @@ package body Ada.Containers.Vectors is\n       declare\n          First       : constant Int := Int (Index_Type'First);\n          Last_As_Int : constant Int'Base := First + Int (Length) - 1;\n-         Last        : constant Index_Type := Index_Type (Last_As_Int);\n-         Elements    : constant Elements_Access :=\n-                         new Elements_Type (Index_Type'First .. Last);\n+         Last        : Index_Type;\n+         Elements    : Elements_Access;\n+\n       begin\n-         return (Controlled with Elements, Last);\n+         if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n+            raise Constraint_Error;\n+         end if;\n+\n+         Last := Index_Type (Last_As_Int);\n+         Elements := new Elements_Type (Index_Type'First .. Last);\n+\n+         return (Controlled with Elements, Last, 0, 0);\n       end;\n    end To_Vector;\n \n@@ -1687,12 +2037,18 @@ package body Ada.Containers.Vectors is\n       declare\n          First       : constant Int := Int (Index_Type'First);\n          Last_As_Int : constant Int'Base := First + Int (Length) - 1;\n-         Last        : constant Index_Type := Index_Type (Last_As_Int);\n-         Elements    : constant Elements_Access :=\n-                         new Elements_Type'\n-                                   (Index_Type'First .. Last => New_Item);\n+         Last        : Index_Type;\n+         Elements    : Elements_Access;\n+\n       begin\n-         return (Controlled with Elements, Last);\n+         if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n+            raise Constraint_Error;\n+         end if;\n+\n+         Last := Index_Type (Last_As_Int);\n+         Elements := new Elements_Type'(Index_Type'First .. Last => New_Item);\n+\n+         return (Controlled with Elements, Last, 0, 0);\n       end;\n    end To_Vector;\n \n@@ -1705,20 +2061,41 @@ package body Ada.Containers.Vectors is\n       Index     : Index_Type;\n       Process   : not null access procedure (Element : in out Element_Type))\n    is\n-      subtype T is Index_Type'Base range\n-        Index_Type'First .. Container.Last;\n+      V : Vector renames Container'Unrestricted_Access.all;\n+      B : Natural renames V.Busy;\n+      L : Natural renames V.Lock;\n+\n    begin\n-      Process (Container.Elements (T'(Index)));\n+      if Index > Container.Last then\n+         raise Constraint_Error;\n+      end if;\n+\n+      B := B + 1;\n+      L := L + 1;\n+\n+      begin\n+         Process (V.Elements (Index));\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      L := L - 1;\n+      B := B - 1;\n    end Update_Element;\n \n    procedure Update_Element\n      (Position : Cursor;\n       Process  : not null access procedure (Element : in out Element_Type))\n    is\n-      subtype T is Index_Type'Base range\n-        Index_Type'First .. Position.Container.Last;\n    begin\n-      Process (Position.Container.Elements (T'(Position.Index)));\n+      if Position.Container = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      Update_Element (Position.Container.all, Position.Index, Process);\n    end Update_Element;\n \n    -----------\n@@ -1738,4 +2115,3 @@ package body Ada.Containers.Vectors is\n    end Write;\n \n end Ada.Containers.Vectors;\n-"}, {"sha": "638c8ddd6cd14a32ea74591c0b2d2631469060d8", "filename": "gcc/ada/a-convec.ads", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-convec.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-convec.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.ads?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---                          ADA.CONTAINERS.VECTORS                          --\n+--                A D A . C O N T A I N E R S . V E C T O R S               --\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -200,7 +200,7 @@ pragma Preelaborate (Vectors);\n \n    procedure Delete\n      (Container : in out Vector;\n-      Index     : Extended_Index;  --  TODO: verify\n+      Index     : Extended_Index;\n       Count     : Count_Type := 1);\n \n    procedure Delete\n@@ -234,7 +234,15 @@ pragma Preelaborate (Vectors);\n \n    generic\n       with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n-   procedure Generic_Sort (Container : Vector);\n+   package Generic_Sorting is\n+\n+      function Is_Sorted (Container : Vector) return Boolean;\n+\n+      procedure Sort (Container : in out Vector);\n+\n+      procedure Merge (Target, Source : in out Vector);\n+\n+   end Generic_Sorting;\n \n    function Find_Index\n      (Container : Vector;\n@@ -301,6 +309,8 @@ private\n    type Vector is new Controlled with record\n       Elements : Elements_Access;\n       Last     : Extended_Index := No_Index;\n+      Busy     : Natural := 0;\n+      Lock     : Natural := 0;\n    end record;\n \n    procedure Adjust (Container : in out Vector);\n@@ -321,7 +331,7 @@ private\n \n    for Vector'Read use Read;\n \n-   Empty_Vector : constant Vector := (Controlled with null, No_Index);\n+   Empty_Vector : constant Vector := (Controlled with null, No_Index, 0, 0);\n \n    type Vector_Access is access constant Vector;\n    for Vector_Access'Storage_Size use 0;"}, {"sha": "8b2af9c100be5c2ee4a8263a54955fdf86ae976a", "filename": "gcc/ada/a-coorma.adb", "status": "modified", "additions": 178, "deletions": 174, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-coorma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-coorma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorma.adb?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---                       ADA.CONTAINERS.ORDERED_MAPS                        --\n+--           A D A . C O N T A I N E R S . O R D E R E D _ M A P S          --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -41,21 +41,8 @@ pragma Elaborate_All (Ada.Containers.Red_Black_Trees.Generic_Operations);\n with Ada.Containers.Red_Black_Trees.Generic_Keys;\n pragma Elaborate_All (Ada.Containers.Red_Black_Trees.Generic_Keys);\n \n-with System;  use type System.Address;\n-\n package body Ada.Containers.Ordered_Maps is\n \n-   use Red_Black_Trees;\n-\n-   type Node_Type is limited record\n-      Parent  : Node_Access;\n-      Left    : Node_Access;\n-      Right   : Node_Access;\n-      Color   : Red_Black_Trees.Color_Type := Red;\n-      Key     : Key_Type;\n-      Element : Element_Type;\n-   end record;\n-\n    -----------------------------\n    -- Node Access Subprograms --\n    -----------------------------\n@@ -94,10 +81,6 @@ package body Ada.Containers.Ordered_Maps is\n    function Copy_Node (Source : Node_Access) return Node_Access;\n    pragma Inline (Copy_Node);\n \n-   function Copy_Tree (Source_Root : Node_Access) return Node_Access;\n-\n-   procedure Delete_Tree (X : in out Node_Access);\n-\n    function Is_Equal_Node_Node (L, R : Node_Access) return Boolean;\n    pragma Inline (Is_Equal_Node_Node);\n \n@@ -118,9 +101,13 @@ package body Ada.Containers.Ordered_Maps is\n    procedure Free is new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n \n    package Tree_Operations is\n-     new Red_Black_Trees.Generic_Operations\n-       (Tree_Types => Tree_Types,\n-        Null_Node  => Node_Access'(null));\n+      new Red_Black_Trees.Generic_Operations (Tree_Types);\n+\n+   procedure Delete_Tree is\n+      new Tree_Operations.Generic_Delete_Tree (Free);\n+\n+   function Copy_Tree is\n+      new Tree_Operations.Generic_Copy_Tree (Copy_Node, Delete_Tree);\n \n    use Tree_Operations;\n \n@@ -159,10 +146,6 @@ package body Ada.Containers.Ordered_Maps is\n \n    function \"=\" (Left, Right : Map) return Boolean is\n    begin\n-      if Left'Address = Right'Address then\n-         return True;\n-      end if;\n-\n       return Is_Equal (Left.Tree, Right.Tree);\n    end \"=\";\n \n@@ -189,24 +172,12 @@ package body Ada.Containers.Ordered_Maps is\n    -- Adjust --\n    ------------\n \n-   procedure Adjust (Container : in out Map) is\n-      Tree : Tree_Type renames Container.Tree;\n-\n-      N : constant Count_Type := Tree.Length;\n-      X : constant Node_Access := Tree.Root;\n+   procedure Adjust is\n+      new Tree_Operations.Generic_Adjust (Copy_Tree);\n \n+   procedure Adjust (Container : in out Map) is\n    begin\n-      if N = 0 then\n-         pragma Assert (X = null);\n-         return;\n-      end if;\n-\n-      Tree := (Length => 0, others => null);\n-\n-      Tree.Root := Copy_Tree (X);\n-      Tree.First := Min (Tree.Root);\n-      Tree.Last := Max (Tree.Root);\n-      Tree.Length := N;\n+      Adjust (Container.Tree);\n    end Adjust;\n \n    -------------\n@@ -221,19 +192,19 @@ package body Ada.Containers.Ordered_Maps is\n          return No_Element;\n       end if;\n \n-      return Cursor'(Container'Unchecked_Access, Node);\n+      return Cursor'(Container'Unrestricted_Access, Node);\n    end Ceiling;\n \n    -----------\n    -- Clear --\n    -----------\n \n+   procedure Clear is\n+      new Tree_Operations.Generic_Clear (Delete_Tree);\n+\n    procedure Clear (Container : in out Map) is\n-      Tree : Tree_Type renames Container.Tree;\n-      Root : Node_Access := Tree.Root;\n    begin\n-      Tree := (Length => 0, others => null);\n-      Delete_Tree (Root);\n+      Clear (Container.Tree);\n    end Clear;\n \n    -----------\n@@ -270,64 +241,21 @@ package body Ada.Containers.Ordered_Maps is\n       return Target;\n    end Copy_Node;\n \n-   ---------------\n-   -- Copy_Tree --\n-   ---------------\n-\n-   function Copy_Tree (Source_Root : Node_Access) return Node_Access is\n-      Target_Root : Node_Access := Copy_Node (Source_Root);\n-      P, X : Node_Access;\n-\n-   begin\n-      if Source_Root.Right /= null then\n-         Target_Root.Right := Copy_Tree (Source_Root.Right);\n-         Target_Root.Right.Parent := Target_Root;\n-      end if;\n-\n-      P := Target_Root;\n-      X := Source_Root.Left;\n-\n-      while X /= null loop\n-         declare\n-            Y : Node_Access := Copy_Node (X);\n-\n-         begin\n-            P.Left := Y;\n-            Y.Parent := P;\n-\n-            if X.Right /= null then\n-               Y.Right := Copy_Tree (X.Right);\n-               Y.Right.Parent := Y;\n-            end if;\n-\n-            P := Y;\n-            X := X.Left;\n-         end;\n-      end loop;\n-\n-      return Target_Root;\n-\n-   exception\n-      when others =>\n-         Delete_Tree (Target_Root);\n-         raise;\n-   end Copy_Tree;\n-\n    ------------\n    -- Delete --\n    ------------\n \n    procedure Delete (Container : in out Map; Position : in out Cursor) is\n    begin\n-      if Position = No_Element then\n-         return;\n+      if Position.Node = null then\n+         raise Constraint_Error;\n       end if;\n \n-      if Position.Container /= Map_Access'(Container'Unchecked_Access) then\n+      if Position.Container /= Map_Access'(Container'Unrestricted_Access) then\n          raise Program_Error;\n       end if;\n \n-      Delete_Node_Sans_Free (Container.Tree, Position.Node);\n+      Tree_Operations.Delete_Node_Sans_Free (Container.Tree, Position.Node);\n       Free (Position.Node);\n \n       Position.Container := null;\n@@ -350,37 +278,26 @@ package body Ada.Containers.Ordered_Maps is\n    ------------------\n \n    procedure Delete_First (Container : in out Map) is\n-      Position : Cursor := First (Container);\n+      X : Node_Access := Container.Tree.First;\n    begin\n-      Delete (Container, Position);\n+      if X /= null then\n+         Tree_Operations.Delete_Node_Sans_Free (Container.Tree, X);\n+         Free (X);\n+      end if;\n    end Delete_First;\n \n    -----------------\n    -- Delete_Last --\n    -----------------\n \n    procedure Delete_Last (Container : in out Map) is\n-      Position : Cursor := Last (Container);\n+      X : Node_Access := Container.Tree.Last;\n    begin\n-      Delete (Container, Position);\n-   end Delete_Last;\n-\n-\n-   -----------------\n-   -- Delete_Tree --\n-   -----------------\n-\n-   procedure Delete_Tree (X : in out Node_Access) is\n-      Y : Node_Access;\n-   begin\n-      while X /= null loop\n-         Y := X.Right;\n-         Delete_Tree (Y);\n-         Y := X.Left;\n+      if X /= null then\n+         Tree_Operations.Delete_Node_Sans_Free (Container.Tree, X);\n          Free (X);\n-         X := Y;\n-      end loop;\n-   end Delete_Tree;\n+      end if;\n+   end Delete_Last;\n \n    -------------\n    -- Element --\n@@ -423,7 +340,7 @@ package body Ada.Containers.Ordered_Maps is\n          return No_Element;\n       end if;\n \n-      return Cursor'(Container'Unchecked_Access, Node);\n+      return Cursor'(Container'Unrestricted_Access, Node);\n    end Find;\n \n    -----------\n@@ -436,7 +353,7 @@ package body Ada.Containers.Ordered_Maps is\n          return No_Element;\n       end if;\n \n-      return Cursor'(Container'Unchecked_Access, Container.Tree.First);\n+      return Cursor'(Container'Unrestricted_Access, Container.Tree.First);\n    end First;\n \n    -------------------\n@@ -469,7 +386,7 @@ package body Ada.Containers.Ordered_Maps is\n          return No_Element;\n       end if;\n \n-      return Cursor'(Container'Unchecked_Access, Node);\n+      return Cursor'(Container'Unrestricted_Access, Node);\n    end Floor;\n \n    -----------------\n@@ -497,6 +414,10 @@ package body Ada.Containers.Ordered_Maps is\n       Insert (Container, Key, New_Item, Position, Inserted);\n \n       if not Inserted then\n+         if Container.Tree.Lock > 0 then\n+            raise Program_Error;\n+         end if;\n+\n          Position.Node.Key := Key;\n          Position.Node.Element := New_Item;\n       end if;\n@@ -543,7 +464,7 @@ package body Ada.Containers.Ordered_Maps is\n          Position.Node,\n          Inserted);\n \n-      Position.Container := Container'Unchecked_Access;\n+      Position.Container := Container'Unrestricted_Access;\n    end Insert;\n \n    procedure Insert\n@@ -609,7 +530,7 @@ package body Ada.Containers.Ordered_Maps is\n          Position.Node,\n          Inserted);\n \n-      Position.Container := Container'Unchecked_Access;\n+      Position.Container := Container'Unrestricted_Access;\n    end Insert;\n \n    --------------\n@@ -628,7 +549,15 @@ package body Ada.Containers.Ordered_Maps is\n    function Is_Equal_Node_Node\n      (L, R : Node_Access) return Boolean is\n    begin\n-      return L.Element = R.Element;\n+      if L.Key < R.Key then\n+         return False;\n+\n+      elsif R.Key < L.Key then\n+         return False;\n+\n+      else\n+         return L.Element = R.Element;\n+      end if;\n    end Is_Equal_Node_Node;\n \n    -------------------------\n@@ -677,13 +606,25 @@ package body Ada.Containers.Ordered_Maps is\n \n       procedure Process_Node (Node : Node_Access) is\n       begin\n-         Process (Cursor'(Container'Unchecked_Access, Node));\n+         Process (Cursor'(Container'Unrestricted_Access, Node));\n       end Process_Node;\n \n+      B : Natural renames Container.Tree'Unrestricted_Access.all.Busy;\n+\n    --  Start of processing for Iterate\n \n    begin\n-      Local_Iterate (Container.Tree);\n+      B := B + 1;\n+\n+      begin\n+         Local_Iterate (Container.Tree);\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n    end Iterate;\n \n    ---------\n@@ -705,7 +646,7 @@ package body Ada.Containers.Ordered_Maps is\n          return No_Element;\n       end if;\n \n-      return Cursor'(Container'Unchecked_Access, Container.Tree.Last);\n+      return Cursor'(Container'Unrestricted_Access, Container.Tree.Last);\n    end Last;\n \n    ------------------\n@@ -748,12 +689,11 @@ package body Ada.Containers.Ordered_Maps is\n    -- Move --\n    ----------\n \n+   procedure Move is\n+      new Tree_Operations.Generic_Move (Clear);\n+\n    procedure Move (Target : in out Map; Source : in out Map) is\n    begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n       Move (Target => Target.Tree, Source => Source.Tree);\n    end Move;\n \n@@ -828,10 +768,32 @@ package body Ada.Containers.Ordered_Maps is\n \n    procedure Query_Element\n      (Position : Cursor;\n-      Process  : not null access procedure (Element : Element_Type))\n+      Process  : not null access procedure (Key     : Key_Type;\n+                                            Element : Element_Type))\n    is\n+      K : Key_Type renames Position.Node.Key;\n+      E : Element_Type renames Position.Node.Element;\n+\n+      T : Tree_Type renames Position.Container.Tree;\n+\n+      B : Natural renames T.Busy;\n+      L : Natural renames T.Lock;\n+\n    begin\n-      Process (Position.Node.Key, Position.Node.Element);\n+      B := B + 1;\n+      L := L + 1;\n+\n+      begin\n+         Process (K, E);\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      L := L - 1;\n+      B := B - 1;\n    end Query_Element;\n \n    ----------\n@@ -842,41 +804,35 @@ package body Ada.Containers.Ordered_Maps is\n      (Stream    : access Root_Stream_Type'Class;\n       Container : out Map)\n    is\n-      N : Count_Type'Base;\n+      function Read_Node\n+        (Stream : access Root_Stream_Type'Class) return Node_Access;\n+      pragma Inline (Read_Node);\n \n-      function New_Node return Node_Access;\n-      pragma Inline (New_Node);\n+      procedure Read is\n+         new Tree_Operations.Generic_Read (Clear, Read_Node);\n \n-      procedure Local_Read is new Tree_Operations.Generic_Read (New_Node);\n+      ---------------\n+      -- Read_Node --\n+      ---------------\n \n-      --------------\n-      -- New_Node --\n-      --------------\n-\n-      function New_Node return Node_Access is\n+      function Read_Node\n+        (Stream : access Root_Stream_Type'Class) return Node_Access\n+      is\n          Node : Node_Access := new Node_Type;\n-\n       begin\n-         begin\n-            Key_Type'Read (Stream, Node.Key);\n-            Element_Type'Read (Stream, Node.Element);\n-         exception\n-            when others =>\n-               Free (Node);\n-               raise;\n-         end;\n-\n+         Key_Type'Read (Stream, Node.Key);\n+         Element_Type'Read (Stream, Node.Element);\n          return Node;\n-      end New_Node;\n+      exception\n+         when others =>\n+            Free (Node);\n+            raise;\n+      end Read_Node;\n \n    --  Start of processing for Read\n \n    begin\n-      Clear (Container);\n-      Count_Type'Base'Read (Stream, N);\n-      pragma Assert (N >= 0);\n-\n-      Local_Read (Container.Tree, N);\n+      Read (Stream, Container.Tree);\n    end Read;\n \n    -------------\n@@ -895,6 +851,10 @@ package body Ada.Containers.Ordered_Maps is\n          raise Constraint_Error;\n       end if;\n \n+      if Container.Tree.Lock > 0 then\n+         raise Program_Error;\n+      end if;\n+\n       Node.Key := Key;\n       Node.Element := New_Item;\n    end Replace;\n@@ -904,8 +864,14 @@ package body Ada.Containers.Ordered_Maps is\n    ---------------------\n \n    procedure Replace_Element (Position : Cursor; By : Element_Type) is\n+      E : Element_Type renames Position.Node.Element;\n+\n    begin\n-      Position.Node.Element := By;\n+      if Position.Container.Tree.Lock > 0 then\n+         raise Program_Error;\n+      end if;\n+\n+      E := By;\n    end Replace_Element;\n \n    ---------------------\n@@ -928,13 +894,25 @@ package body Ada.Containers.Ordered_Maps is\n \n       procedure Process_Node (Node : Node_Access) is\n       begin\n-         Process (Cursor'(Container'Unchecked_Access, Node));\n+         Process (Cursor'(Container'Unrestricted_Access, Node));\n       end Process_Node;\n \n+      B : Natural renames Container.Tree'Unrestricted_Access.all.Busy;\n+\n       --  Start of processing for Reverse_Iterate\n \n    begin\n-      Local_Reverse_Iterate (Container.Tree);\n+      B := B + 1;\n+\n+      begin\n+         Local_Reverse_Iterate (Container.Tree);\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n    end Reverse_Iterate;\n \n    -----------\n@@ -976,7 +954,6 @@ package body Ada.Containers.Ordered_Maps is\n       Node.Parent := Parent;\n    end Set_Parent;\n \n-\n    ---------------\n    -- Set_Right --\n    ---------------\n@@ -992,10 +969,32 @@ package body Ada.Containers.Ordered_Maps is\n \n    procedure Update_Element\n      (Position : Cursor;\n-      Process  : not null access procedure (Element : in out Element_Type))\n+      Process  : not null access procedure (Key     : Key_Type;\n+                                            Element : in out Element_Type))\n    is\n+      K : Key_Type renames Position.Node.Key;\n+      E : Element_Type renames Position.Node.Element;\n+\n+      T : Tree_Type renames Position.Container.Tree;\n+\n+      B : Natural renames T.Busy;\n+      L : Natural renames T.Lock;\n+\n    begin\n-      Process (Position.Node.Key, Position.Node.Element);\n+      B := B + 1;\n+      L := L + 1;\n+\n+      begin\n+         Process (K, E);\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      L := L - 1;\n+      B := B - 1;\n    end Update_Element;\n \n    -----------\n@@ -1006,26 +1005,31 @@ package body Ada.Containers.Ordered_Maps is\n      (Stream    : access Root_Stream_Type'Class;\n       Container : Map)\n    is\n-      procedure Process (Node : Node_Access);\n-      pragma Inline (Process);\n-\n-      procedure Iterate is new Tree_Operations.Generic_Iteration (Process);\n-\n-      -------------\n-      -- Process --\n-      -------------\n-\n-      procedure Process (Node : Node_Access) is\n+      procedure Write_Node\n+        (Stream : access Root_Stream_Type'Class;\n+         Node   : Node_Access);\n+      pragma Inline (Write_Node);\n+\n+      procedure Write is\n+         new Tree_Operations.Generic_Write (Write_Node);\n+\n+      ----------------\n+      -- Write_Node --\n+      ----------------\n+\n+      procedure Write_Node\n+        (Stream : access Root_Stream_Type'Class;\n+         Node   : Node_Access)\n+      is\n       begin\n          Key_Type'Write (Stream, Node.Key);\n          Element_Type'Write (Stream, Node.Element);\n-      end Process;\n+      end Write_Node;\n \n    --  Start of processing for Write\n \n    begin\n-      Count_Type'Base'Write (Stream, Container.Tree.Length);\n-      Iterate (Container.Tree);\n+      Write (Stream, Container.Tree);\n    end Write;\n \n end Ada.Containers.Ordered_Maps;"}, {"sha": "c31a7f02ec19ee4addd7b24c319a62c3238f2e39", "filename": "gcc/ada/a-coorma.ads", "status": "modified", "additions": 36, "deletions": 21, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-coorma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-coorma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorma.ads?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---                       ADA.CONTAINERS.ORDERED_MAPS                        --\n+--           A D A . C O N T A I N E R S . O R D E R E D _ M A P S          --\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -93,34 +93,34 @@ pragma Preelaborate (Ordered_Maps);\n    procedure Insert\n      (Container : in out Map;\n       Key       : Key_Type;\n-      New_Item  : Element_Type);\n+      Position  : out Cursor;\n+      Inserted  : out Boolean);\n \n-   procedure Include\n+   procedure Insert\n      (Container : in out Map;\n       Key       : Key_Type;\n       New_Item  : Element_Type);\n \n-   procedure Replace\n+   procedure Include\n      (Container : in out Map;\n       Key       : Key_Type;\n       New_Item  : Element_Type);\n \n-   procedure Insert\n+   procedure Replace\n      (Container : in out Map;\n       Key       : Key_Type;\n-      Position  : out Cursor;\n-      Inserted  : out Boolean);\n+      New_Item  : Element_Type);\n \n    procedure Delete (Container : in out Map; Key : Key_Type);\n \n-   procedure Exclude (Container : in out Map; Key : Key_Type);\n-\n    procedure Delete (Container : in out Map; Position : in out Cursor);\n \n    procedure Delete_First (Container : in out Map);\n \n    procedure Delete_Last (Container : in out Map);\n \n+   procedure Exclude (Container : in out Map; Key : Key_Type);\n+\n    function Contains (Container : Map; Key : Key_Type) return Boolean;\n \n    function Find (Container : Map; Key : Key_Type) return Cursor;\n@@ -145,10 +145,10 @@ pragma Preelaborate (Ordered_Maps);\n \n    function Next (Position : Cursor) return Cursor;\n \n-   function Previous (Position : Cursor) return Cursor;\n-\n    procedure Next (Position : in out Cursor);\n \n+   function Previous (Position : Cursor) return Cursor;\n+\n    procedure Previous (Position : in out Cursor);\n \n    function Has_Element (Position : Cursor) return Boolean;\n@@ -178,21 +178,32 @@ private\n    type Node_Type;\n    type Node_Access is access Node_Type;\n \n-   package Tree_Types is\n-     new Red_Black_Trees.Generic_Tree_Types (Node_Access);\n+   type Node_Type is limited record\n+      Parent  : Node_Access;\n+      Left    : Node_Access;\n+      Right   : Node_Access;\n+      Color   : Red_Black_Trees.Color_Type := Red_Black_Trees.Red;\n+      Key     : Key_Type;\n+      Element : Element_Type;\n+   end record;\n \n-   use Tree_Types;\n-   use Ada.Finalization;\n+   package Tree_Types is new Red_Black_Trees.Generic_Tree_Types\n+     (Node_Type,\n+      Node_Access);\n \n-   type Map is new Controlled with record\n-      Tree : Tree_Type := (Length => 0, others => null);\n+   type Map is new Ada.Finalization.Controlled with record\n+      Tree : Tree_Types.Tree_Type;\n    end record;\n \n    procedure Adjust (Container : in out Map);\n \n    procedure Finalize (Container : in out Map) renames Clear;\n \n-   type Map_Access is access constant Map;\n+   use Red_Black_Trees;\n+   use Tree_Types;\n+   use Ada.Finalization;\n+\n+   type Map_Access is access Map;\n    for Map_Access'Storage_Size use 0;\n \n    type Cursor is record\n@@ -210,14 +221,18 @@ private\n \n    for Map'Write use Write;\n \n-\n    procedure Read\n      (Stream    : access Root_Stream_Type'Class;\n       Container : out Map);\n \n    for Map'Read use Read;\n \n    Empty_Map : constant Map :=\n-                 (Controlled with Tree => (Length => 0, others => null));\n+                 (Controlled with Tree => (First  => null,\n+                                           Last   => null,\n+                                           Root   => null,\n+                                           Length => 0,\n+                                           Busy   => 0,\n+                                           Lock   => 0));\n \n end Ada.Containers.Ordered_Maps;"}, {"sha": "387abfb7ff29af011475bed434a3afcd254a72ee", "filename": "gcc/ada/a-coormu.adb", "status": "modified", "additions": 364, "deletions": 432, "changes": 796, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-coormu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-coormu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coormu.adb?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---                     ADA.CONTAINERS.ORDERED_MULTISETS                     --\n+--     A D A . C O N T A I N E R S . O R D E R E D _ M U L T I S E T S      --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -44,20 +44,8 @@ pragma Elaborate_All (Ada.Containers.Red_Black_Trees.Generic_Keys);\n with Ada.Containers.Red_Black_Trees.Generic_Set_Operations;\n pragma Elaborate_All (Ada.Containers.Red_Black_Trees.Generic_Set_Operations);\n \n-with System;  use type System.Address;\n-\n package body Ada.Containers.Ordered_Multisets is\n \n-   use Red_Black_Trees;\n-\n-   type Node_Type is limited record\n-      Parent  : Node_Access;\n-      Left    : Node_Access;\n-      Right   : Node_Access;\n-      Color   : Red_Black_Trees.Color_Type := Red;\n-      Element : Element_Type;\n-   end record;\n-\n    -----------------------------\n    -- Node Access Subprograms --\n    -----------------------------\n@@ -96,10 +84,6 @@ package body Ada.Containers.Ordered_Multisets is\n    function Copy_Node (Source : Node_Access) return Node_Access;\n    pragma Inline (Copy_Node);\n \n-   function Copy_Tree (Source_Root : Node_Access) return Node_Access;\n-\n-   procedure Delete_Tree (X : in out Node_Access);\n-\n    procedure Insert_With_Hint\n      (Dst_Tree : in out Tree_Type;\n       Dst_Hint : Node_Access;\n@@ -122,19 +106,28 @@ package body Ada.Containers.Ordered_Multisets is\n    function Is_Less_Node_Node (L, R : Node_Access) return Boolean;\n    pragma Inline (Is_Less_Node_Node);\n \n+   procedure Replace_Element\n+     (Tree : in out Tree_Type;\n+      Node : Node_Access;\n+      Item : Element_Type);\n+\n    --------------------------\n    -- Local Instantiations --\n    --------------------------\n \n+   procedure Free is\n+     new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n+\n    package Tree_Operations is\n-     new Red_Black_Trees.Generic_Operations\n-       (Tree_Types => Tree_Types,\n-        Null_Node  => Node_Access'(null));\n+     new Red_Black_Trees.Generic_Operations (Tree_Types);\n \n-   use Tree_Operations;\n+   procedure Delete_Tree is\n+     new Tree_Operations.Generic_Delete_Tree (Free);\n \n-   procedure Free is\n-     new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n+   function Copy_Tree is\n+     new Tree_Operations.Generic_Copy_Tree (Copy_Node, Delete_Tree);\n+\n+   use Tree_Operations;\n \n    function Is_Equal is\n      new Tree_Operations.Generic_Equal (Is_Equal_Node_Node);\n@@ -182,10 +175,6 @@ package body Ada.Containers.Ordered_Multisets is\n \n    function \"=\" (Left, Right : Set) return Boolean is\n    begin\n-      if Left'Address = Right'Address then\n-         return True;\n-      end if;\n-\n       return Is_Equal (Left.Tree, Right.Tree);\n    end \"=\";\n \n@@ -216,24 +205,12 @@ package body Ada.Containers.Ordered_Multisets is\n    -- Adjust --\n    ------------\n \n-   procedure Adjust (Container : in out Set) is\n-      Tree : Tree_Type renames Container.Tree;\n-\n-      N : constant Count_Type := Tree.Length;\n-      X : constant Node_Access := Tree.Root;\n+   procedure Adjust is\n+      new Tree_Operations.Generic_Adjust (Copy_Tree);\n \n+   procedure Adjust (Container : in out Set) is\n    begin\n-      if N = 0 then\n-         pragma Assert (X = null);\n-         return;\n-      end if;\n-\n-      Tree := (Length => 0, others => null);\n-\n-      Tree.Root := Copy_Tree (X);\n-      Tree.First := Min (Tree.Root);\n-      Tree.Last := Max (Tree.Root);\n-      Tree.Length := N;\n+      Adjust (Container.Tree);\n    end Adjust;\n \n    -------------\n@@ -249,19 +226,19 @@ package body Ada.Containers.Ordered_Multisets is\n          return No_Element;\n       end if;\n \n-      return Cursor'(Container'Unchecked_Access, Node);\n+      return Cursor'(Container'Unrestricted_Access, Node);\n    end Ceiling;\n \n    -----------\n    -- Clear --\n    -----------\n \n+   procedure Clear is\n+      new Tree_Operations.Generic_Clear (Delete_Tree);\n+\n    procedure Clear (Container : in out Set) is\n-      Tree : Tree_Type renames Container.Tree;\n-      Root : Node_Access := Tree.Root;\n    begin\n-      Tree := (Length => 0, others => null);\n-      Delete_Tree (Root);\n+      Clear (Container.Tree);\n    end Clear;\n \n    -----------\n@@ -297,49 +274,6 @@ package body Ada.Containers.Ordered_Multisets is\n       return Target;\n    end Copy_Node;\n \n-   ---------------\n-   -- Copy_Tree --\n-   ---------------\n-\n-   function Copy_Tree (Source_Root : Node_Access) return Node_Access is\n-      Target_Root : Node_Access := Copy_Node (Source_Root);\n-\n-      P, X : Node_Access;\n-\n-   begin\n-      if Source_Root.Right /= null then\n-         Target_Root.Right := Copy_Tree (Source_Root.Right);\n-         Target_Root.Right.Parent := Target_Root;\n-      end if;\n-\n-      P := Target_Root;\n-      X := Source_Root.Left;\n-      while X /= null loop\n-         declare\n-            Y : Node_Access := Copy_Node (X);\n-\n-         begin\n-            P.Left := Y;\n-            Y.Parent := P;\n-\n-            if X.Right /= null then\n-               Y.Right := Copy_Tree (X.Right);\n-               Y.Right.Parent := Y;\n-            end if;\n-\n-            P := Y;\n-            X := X.Left;\n-         end;\n-      end loop;\n-\n-      return Target_Root;\n-\n-   exception\n-      when others =>\n-         Delete_Tree (Target_Root);\n-         raise;\n-   end Copy_Tree;\n-\n    ------------\n    -- Delete --\n    ------------\n@@ -367,11 +301,11 @@ package body Ada.Containers.Ordered_Multisets is\n \n    procedure Delete (Container : in out Set; Position  : in out Cursor) is\n    begin\n-      if Position = No_Element then\n-         return;\n+      if Position.Node = null then\n+         raise Constraint_Error;\n       end if;\n \n-      if Position.Container /= Set_Access'(Container'Unchecked_Access) then\n+      if Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error;\n       end if;\n \n@@ -415,48 +349,20 @@ package body Ada.Containers.Ordered_Multisets is\n       Free (X);\n    end Delete_Last;\n \n-   -----------------\n-   -- Delete_Tree --\n-   -----------------\n-\n-   procedure Delete_Tree (X : in out Node_Access) is\n-      Y : Node_Access;\n-   begin\n-      while X /= null loop\n-         Y := X.Right;\n-         Delete_Tree (Y);\n-         Y := X.Left;\n-         Free (X);\n-         X := Y;\n-      end loop;\n-   end Delete_Tree;\n-\n    ----------------\n    -- Difference --\n    ----------------\n \n    procedure Difference (Target : in out Set; Source : Set) is\n    begin\n-      if Target'Address = Source'Address then\n-         Clear (Target);\n-         return;\n-      end if;\n-\n       Set_Ops.Difference (Target.Tree, Source.Tree);\n    end Difference;\n \n    function Difference (Left, Right : Set) return Set is\n+      Tree : constant Tree_Type :=\n+               Set_Ops.Difference (Left.Tree, Right.Tree);\n    begin\n-      if Left'Address = Right'Address then\n-         return Empty_Set;\n-      end if;\n-\n-      declare\n-         Tree : constant Tree_Type :=\n-                  Set_Ops.Difference (Left.Tree, Right.Tree);\n-      begin\n-         return (Controlled with Tree);\n-      end;\n+      return Set'(Controlled with Tree);\n    end Difference;\n \n    -------------\n@@ -468,6 +374,39 @@ package body Ada.Containers.Ordered_Multisets is\n       return Position.Node.Element;\n    end Element;\n \n+   ---------------------\n+   -- Equivalent_Sets --\n+   ---------------------\n+\n+   function Equivalent_Sets (Left, Right : Set) return Boolean is\n+\n+      function Is_Equivalent_Node_Node (L, R : Node_Access) return Boolean;\n+      pragma Inline (Is_Equivalent_Node_Node);\n+\n+      function Is_Equivalent is\n+        new Tree_Operations.Generic_Equal (Is_Equivalent_Node_Node);\n+\n+      -----------------------------\n+      -- Is_Equivalent_Node_Node --\n+      -----------------------------\n+\n+      function Is_Equivalent_Node_Node (L, R : Node_Access) return Boolean is\n+      begin\n+         if L.Element < R.Element then\n+            return False;\n+         elsif R.Element < L.Element then\n+            return False;\n+         else\n+            return True;\n+         end if;\n+      end Is_Equivalent_Node_Node;\n+\n+   --  Start of processing for Equivalent_Sets\n+\n+   begin\n+      return Is_Equivalent (Left.Tree, Right.Tree);\n+   end Equivalent_Sets;\n+\n    -------------\n    -- Exclude --\n    -------------\n@@ -499,7 +438,7 @@ package body Ada.Containers.Ordered_Multisets is\n          return No_Element;\n       end if;\n \n-      return Cursor'(Container'Unchecked_Access, Node);\n+      return Cursor'(Container'Unrestricted_Access, Node);\n    end Find;\n \n    -----------\n@@ -512,7 +451,7 @@ package body Ada.Containers.Ordered_Multisets is\n          return No_Element;\n       end if;\n \n-      return Cursor'(Container'Unchecked_Access, Container.Tree.First);\n+      return Cursor'(Container'Unrestricted_Access, Container.Tree.First);\n    end First;\n \n    -------------------\n@@ -537,7 +476,7 @@ package body Ada.Containers.Ordered_Multisets is\n          return No_Element;\n       end if;\n \n-      return Cursor'(Container'Unchecked_Access, Node);\n+      return Cursor'(Container'Unrestricted_Access, Node);\n    end Floor;\n \n    ------------------\n@@ -612,77 +551,9 @@ package body Ada.Containers.Ordered_Multisets is\n             return No_Element;\n          end if;\n \n-         return Cursor'(Container'Unchecked_Access, Node);\n+         return Cursor'(Container'Unrestricted_Access, Node);\n       end Ceiling;\n \n-      ----------------------------\n-      -- Checked_Update_Element --\n-      ----------------------------\n-\n-      procedure Checked_Update_Element\n-        (Container : in out Set;\n-         Position  : Cursor;\n-         Process   : not null access procedure (Element : in out Element_Type))\n-      is\n-      begin\n-         if Position.Container = null then\n-            raise Constraint_Error;\n-         end if;\n-\n-         if Position.Container /= Set_Access'(Container'Unchecked_Access) then\n-            raise Program_Error;\n-         end if;\n-\n-         declare\n-            Old_Key : Key_Type renames Key (Position.Node.Element);\n-\n-         begin\n-            Process (Position.Node.Element);\n-\n-            if Old_Key < Position.Node.Element\n-              or else Old_Key > Position.Node.Element\n-            then\n-               null;\n-            else\n-               return;\n-            end if;\n-         end;\n-\n-         Delete_Node_Sans_Free (Container.Tree, Position.Node);\n-\n-         Do_Insert : declare\n-            Result  : Node_Access;\n-\n-            function New_Node return Node_Access;\n-            pragma Inline (New_Node);\n-\n-            procedure Insert_Post is\n-              new Key_Keys.Generic_Insert_Post (New_Node);\n-\n-            procedure Insert is\n-              new Key_Keys.Generic_Unconditional_Insert (Insert_Post);\n-\n-            --------------\n-            -- New_Node --\n-            --------------\n-\n-            function New_Node return Node_Access is\n-            begin\n-               return Position.Node;\n-            end New_Node;\n-\n-         --  Start of processing for Do_Insert\n-\n-         begin\n-            Insert\n-              (Tree    => Container.Tree,\n-               Key     => Key (Position.Node.Element),\n-               Node    => Result);\n-\n-            pragma Assert (Result = Position.Node);\n-         end Do_Insert;\n-      end Checked_Update_Element;\n-\n       --------------\n       -- Contains --\n       --------------\n@@ -759,7 +630,7 @@ package body Ada.Containers.Ordered_Multisets is\n             return No_Element;\n          end if;\n \n-         return Cursor'(Container'Unchecked_Access, Node);\n+         return Cursor'(Container'Unrestricted_Access, Node);\n       end Find;\n \n       -----------\n@@ -775,7 +646,7 @@ package body Ada.Containers.Ordered_Multisets is\n             return No_Element;\n          end if;\n \n-         return Cursor'(Container'Unchecked_Access, Node);\n+         return Cursor'(Container'Unrestricted_Access, Node);\n       end Floor;\n \n       -------------------------\n@@ -821,13 +692,26 @@ package body Ada.Containers.Ordered_Multisets is\n \n          procedure Process_Node (Node : Node_Access) is\n          begin\n-            Process (Cursor'(Container'Unchecked_Access, Node));\n+            Process (Cursor'(Container'Unrestricted_Access, Node));\n          end Process_Node;\n \n+         T : Tree_Type renames Container.Tree'Unrestricted_Access.all;\n+         B : Natural renames T.Busy;\n+\n       --  Start of processing for Iterate\n \n       begin\n-         Local_Iterate (Container.Tree, Key);\n+         B := B + 1;\n+\n+         begin\n+            Local_Iterate (T, Key);\n+         exception\n+            when others =>\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         B := B - 1;\n       end Iterate;\n \n       ---------\n@@ -839,27 +723,6 @@ package body Ada.Containers.Ordered_Multisets is\n          return Key (Position.Node.Element);\n       end Key;\n \n-      -------------\n-      -- Replace --\n-      -------------\n-\n-      --  In post-madision api:???\n-\n---    procedure Replace\n---      (Container : in out Set;\n---       Key       : Key_Type;\n---       New_Item  : Element_Type)\n---    is\n---       Node : Node_Access := Key_Keys.Find (Container.Tree, Key);\n-\n---    begin\n---       if Node = null then\n---          raise Constraint_Error;\n---       end if;\n-\n---       Replace_Node (Container, Node, New_Item);\n---    end Replace;\n-\n       ---------------------\n       -- Reverse_Iterate --\n       ---------------------\n@@ -881,15 +744,90 @@ package body Ada.Containers.Ordered_Multisets is\n \n          procedure Process_Node (Node : Node_Access) is\n          begin\n-            Process (Cursor'(Container'Unchecked_Access, Node));\n+            Process (Cursor'(Container'Unrestricted_Access, Node));\n          end Process_Node;\n \n+         T : Tree_Type renames Container.Tree'Unrestricted_Access.all;\n+         B : Natural renames T.Busy;\n+\n       --  Start of processing for Reverse_Iterate\n \n       begin\n-         Local_Reverse_Iterate (Container.Tree, Key);\n+         B := B + 1;\n+\n+         begin\n+            Local_Reverse_Iterate (T, Key);\n+         exception\n+            when others =>\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         B := B - 1;\n       end Reverse_Iterate;\n \n+      -----------------------------------\n+      -- Update_Element_Preserving_Key --\n+      -----------------------------------\n+\n+      procedure Update_Element_Preserving_Key\n+        (Container : in out Set;\n+         Position  : Cursor;\n+         Process   : not null access procedure (Element : in out Element_Type))\n+      is\n+         Tree : Tree_Type renames Container.Tree;\n+\n+      begin\n+         if Position.Node = null then\n+            raise Constraint_Error;\n+         end if;\n+\n+         if Position.Container /= Container'Unrestricted_Access then\n+            raise Program_Error;\n+         end if;\n+\n+         declare\n+            E : Element_Type renames Position.Node.Element;\n+            K : Key_Type renames Key (E);\n+\n+            B : Natural renames Tree.Busy;\n+            L : Natural renames Tree.Lock;\n+\n+         begin\n+            B := B + 1;\n+            L := L + 1;\n+\n+            begin\n+               Process (E);\n+            exception\n+               when others =>\n+                  L := L - 1;\n+                  B := B - 1;\n+                  raise;\n+            end;\n+\n+            L := L - 1;\n+            B := B - 1;\n+\n+            if K < E\n+              or else K > E\n+            then\n+               null;\n+            else\n+               return;\n+            end if;\n+         end;\n+\n+         declare\n+            X : Node_Access := Position.Node;\n+         begin\n+            Tree_Operations.Delete_Node_Sans_Free (Tree, X);\n+            Free (X);\n+         end;\n+\n+         raise Program_Error;\n+      end Update_Element_Preserving_Key;\n+\n    end Generic_Keys;\n \n    -----------------\n@@ -948,7 +886,7 @@ package body Ada.Containers.Ordered_Multisets is\n          New_Item,\n          Position.Node);\n \n-      Position.Container := Container'Unchecked_Access;\n+      Position.Container := Container'Unrestricted_Access;\n    end Insert;\n \n    ----------------------\n@@ -1006,25 +944,14 @@ package body Ada.Containers.Ordered_Multisets is\n \n    procedure Intersection (Target : in out Set; Source : Set) is\n    begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n       Set_Ops.Intersection (Target.Tree, Source.Tree);\n    end Intersection;\n \n    function Intersection (Left, Right : Set) return Set is\n+      Tree : constant Tree_Type :=\n+               Set_Ops.Intersection (Left.Tree, Right.Tree);\n    begin\n-      if Left'Address = Right'Address then\n-         return Left;\n-      end if;\n-\n-      declare\n-         Tree : constant Tree_Type :=\n-                  Set_Ops.Intersection (Left.Tree, Right.Tree);\n-      begin\n-         return (Controlled with Tree);\n-      end;\n+      return Set'(Controlled with Tree);\n    end Intersection;\n \n    --------------\n@@ -1086,10 +1013,6 @@ package body Ada.Containers.Ordered_Multisets is\n \n    function Is_Subset (Subset : Set; Of_Set : Set) return Boolean is\n    begin\n-      if Subset'Address = Of_Set'Address then\n-         return True;\n-      end if;\n-\n       return Set_Ops.Is_Subset (Subset => Subset.Tree, Of_Set => Of_Set.Tree);\n    end Is_Subset;\n \n@@ -1113,13 +1036,26 @@ package body Ada.Containers.Ordered_Multisets is\n \n       procedure Process_Node (Node : Node_Access) is\n       begin\n-         Process (Cursor'(Container'Unchecked_Access, Node));\n+         Process (Cursor'(Container'Unrestricted_Access, Node));\n       end Process_Node;\n \n+      T : Tree_Type renames Container.Tree'Unrestricted_Access.all;\n+      B : Natural renames T.Busy;\n+\n    --  Start of processing for Iterate\n \n    begin\n-      Local_Iterate (Container.Tree);\n+      B := B + 1;\n+\n+      begin\n+         Local_Iterate (T);\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n    end Iterate;\n \n    procedure Iterate\n@@ -1139,13 +1075,26 @@ package body Ada.Containers.Ordered_Multisets is\n \n       procedure Process_Node (Node : Node_Access) is\n       begin\n-         Process (Cursor'(Container'Unchecked_Access, Node));\n+         Process (Cursor'(Container'Unrestricted_Access, Node));\n       end Process_Node;\n \n+      T : Tree_Type renames Container.Tree'Unrestricted_Access.all;\n+      B : Natural renames T.Busy;\n+\n    --  Start of processing for Iterate\n \n    begin\n-      Local_Iterate (Container.Tree, Item);\n+      B := B + 1;\n+\n+      begin\n+         Local_Iterate (T, Item);\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n    end Iterate;\n \n    ----------\n@@ -1158,7 +1107,7 @@ package body Ada.Containers.Ordered_Multisets is\n          return No_Element;\n       end if;\n \n-      return Cursor'(Container'Unchecked_Access, Container.Tree.Last);\n+      return Cursor'(Container'Unrestricted_Access, Container.Tree.Last);\n    end Last;\n \n    ------------------\n@@ -1192,12 +1141,11 @@ package body Ada.Containers.Ordered_Multisets is\n    -- Move --\n    ----------\n \n+   procedure Move is\n+      new Tree_Operations.Generic_Move (Clear);\n+\n    procedure Move (Target : in out Set; Source : in out Set) is\n    begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n       Move (Target => Target.Tree, Source => Source.Tree);\n    end Move;\n \n@@ -1219,7 +1167,7 @@ package body Ada.Containers.Ordered_Multisets is\n \n       declare\n          Node : constant Node_Access :=\n-           Tree_Operations.Next (Position.Node);\n+                  Tree_Operations.Next (Position.Node);\n       begin\n          if Node = null then\n             return No_Element;\n@@ -1235,10 +1183,6 @@ package body Ada.Containers.Ordered_Multisets is\n \n    function Overlap (Left, Right : Set) return Boolean is\n    begin\n-      if Left'Address = Right'Address then\n-         return Left.Tree.Length /= 0;\n-      end if;\n-\n       return Set_Ops.Overlap (Left.Tree, Right.Tree);\n    end Overlap;\n \n@@ -1269,7 +1213,7 @@ package body Ada.Containers.Ordered_Multisets is\n \n       declare\n          Node : constant Node_Access :=\n-           Tree_Operations.Previous (Position.Node);\n+                  Tree_Operations.Previous (Position.Node);\n       begin\n          if Node = null then\n             return No_Element;\n@@ -1287,8 +1231,29 @@ package body Ada.Containers.Ordered_Multisets is\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type))\n    is\n+      E : Element_Type renames Position.Node.Element;\n+\n+      S : Set renames Position.Container.all;\n+      T : Tree_Type renames S.Tree'Unrestricted_Access.all;\n+\n+      B : Natural renames T.Busy;\n+      L : Natural renames T.Lock;\n+\n    begin\n-      Process (Position.Node.Element);\n+      B := B + 1;\n+      L := L + 1;\n+\n+      begin\n+         Process (E);\n+      exception\n+         when others =>\n+            L := L - 1;\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      L := L - 1;\n+      B := B - 1;\n    end Query_Element;\n \n    ----------\n@@ -1299,151 +1264,113 @@ package body Ada.Containers.Ordered_Multisets is\n      (Stream    : access Root_Stream_Type'Class;\n       Container : out Set)\n    is\n-      N : Count_Type'Base;\n+      function Read_Node\n+        (Stream : access Root_Stream_Type'Class) return Node_Access;\n+      pragma Inline (Read_Node);\n \n-      function New_Node return Node_Access;\n-      pragma Inline (New_Node);\n-\n-      procedure Local_Read is new Tree_Operations.Generic_Read (New_Node);\n+      procedure Read is\n+         new Tree_Operations.Generic_Read (Clear, Read_Node);\n \n-      --------------\n-      -- New_Node --\n-      --------------\n+      ---------------\n+      -- Read_Node --\n+      ---------------\n \n-      function New_Node return Node_Access is\n+      function Read_Node\n+        (Stream : access Root_Stream_Type'Class) return Node_Access\n+      is\n          Node : Node_Access := new Node_Type;\n-\n       begin\n-         begin\n-            Element_Type'Read (Stream, Node.Element);\n-\n-         exception\n-            when others =>\n-               Free (Node);\n-               raise;\n-         end;\n-\n+         Element_Type'Read (Stream, Node.Element);\n          return Node;\n-      end New_Node;\n+      exception\n+         when others =>\n+            Free (Node);  --  Note that Free deallocates elem too\n+            raise;\n+      end Read_Node;\n \n    --  Start of processing for Read\n \n    begin\n-      Clear (Container);\n+      Read (Stream, Container.Tree);\n+   end Read;\n \n-      Count_Type'Base'Read (Stream, N);\n-      pragma Assert (N >= 0);\n+   ---------------------\n+   -- Replace_Element --\n+   ---------------------\n \n-      Local_Read (Container.Tree, N);\n-   end Read;\n+   procedure Replace_Element\n+     (Tree : in out Tree_Type;\n+      Node : Node_Access;\n+      Item : Element_Type)\n+   is\n+   begin\n+      if Item < Node.Element\n+        or else Node.Element < Item\n+      then\n+         null;\n+      else\n+         if Tree.Lock > 0 then\n+            raise Program_Error;\n+         end if;\n \n-   -------------\n-   -- Replace --\n-   -------------\n+         Node.Element := Item;\n+         return;\n+      end if;\n \n-   --  NOTE: from post-madison api ???\n+      Tree_Operations.Delete_Node_Sans_Free (Tree, Node);  -- Checks busy-bit\n \n---   procedure Replace\n---     (Container : in out Set;\n---      Position  : Cursor;\n---      By        : Element_Type)\n---   is\n---   begin\n---      if Position.Container = null then\n---         raise Constraint_Error;\n---      end if;\n+      Insert_New_Item : declare\n+         function New_Node return Node_Access;\n+         pragma Inline (New_Node);\n \n---      if Position.Container /= Set_Access'(Container'Unchecked_Access) then\n---         raise Program_Error;\n---      end if;\n+         procedure Insert_Post is\n+            new Element_Keys.Generic_Insert_Post (New_Node);\n \n---      Replace_Node (Container, Position.Node, By);\n---   end Replace;\n+         procedure Unconditional_Insert is\n+            new Element_Keys.Generic_Unconditional_Insert (Insert_Post);\n \n-   ------------------\n-   -- Replace_Node --\n-   ------------------\n+         --------------\n+         -- New_Node --\n+         --------------\n+\n+         function New_Node return Node_Access is\n+         begin\n+            Node.Element := Item;\n+            return Node;\n+         end New_Node;\n+\n+         Result : Node_Access;\n+\n+      --  Start of processing for Insert_New_Item\n+\n+      begin\n+         Unconditional_Insert\n+           (Tree => Tree,\n+            Key  => Item,\n+            Node => Result);\n+\n+         pragma Assert (Result = Node);\n+      end Insert_New_Item;\n+   end Replace_Element;\n+\n+   procedure Replace_Element\n+     (Container : Set;\n+      Position  : Cursor;\n+      By        : Element_Type)\n+   is\n+      Tree : Tree_Type renames Container.Tree'Unrestricted_Access.all;\n+\n+   begin\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n \n-   --  NOTE: from post-madison api ???\n-\n---   procedure Replace_Node\n---     (Container : in out Set;\n---      Position  : Node_Access;\n---      By        : Element_Type)\n---   is\n---      Tree : Tree_Type renames Container.Tree;\n---      Node : Node_Access := Position;\n-\n---   begin\n---      if By < Node.Element\n---        or else Node.Element < By\n---      then\n---         null;\n-\n---      else\n---         begin\n---            Node.Element := By;\n-\n---         exception\n---            when others =>\n---               Tree_Operations.Delete_Node_Sans_Free (Tree, Node);\n---               Free (Node);\n---               raise;\n---         end;\n-\n---         return;\n---      end if;\n-\n---      Tree_Operations.Delete_Node_Sans_Free (Tree, Node);\n-\n---      begin\n---         Node.Element := By;\n-\n---      exception\n---         when others =>\n---            Free (Node);\n---            raise;\n---      end;\n---\n---      Do_Insert : declare\n---         Result  : Node_Access;\n---         Success : Boolean;\n-\n---         function New_Node return Node_Access;\n---         pragma Inline (New_Node);\n-\n---         procedure Insert_Post is\n---           new Element_Keys.Generic_Insert_Post (New_Node);\n---\n---         procedure Insert is\n---           new Element_Keys.Generic_Conditional_Insert (Insert_Post);\n-\n---         --------------\n---         -- New_Node --\n---         --------------\n-\n---         function New_Node return Node_Access is\n---         begin\n---            return Node;\n---         end New_Node;\n-\n---      --  Start of processing for Do_Insert\n-\n---      begin\n---         Insert\n---           (Tree    => Tree,\n---            Key     => Node.Element,\n---            Node    => Result,\n---            Success => Success);\n---\n---         if not Success then\n---            Free (Node);\n---            raise Program_Error;\n---         end if;\n---\n---         pragma Assert (Result = Node);\n---      end Do_Insert;\n---   end Replace_Node;\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error;\n+      end if;\n+\n+      Replace_Element (Tree, Position.Node, By);\n+   end Replace_Element;\n \n    ---------------------\n    -- Reverse_Iterate --\n@@ -1465,13 +1392,26 @@ package body Ada.Containers.Ordered_Multisets is\n \n       procedure Process_Node (Node : Node_Access) is\n       begin\n-         Process (Cursor'(Container'Unchecked_Access, Node));\n+         Process (Cursor'(Container'Unrestricted_Access, Node));\n       end Process_Node;\n \n+      T : Tree_Type renames Container.Tree'Unrestricted_Access.all;\n+      B : Natural renames T.Busy;\n+\n    --  Start of processing for Reverse_Iterate\n \n    begin\n-      Local_Reverse_Iterate (Container.Tree);\n+      B := B + 1;\n+\n+      begin\n+         Local_Reverse_Iterate (T);\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n    end Reverse_Iterate;\n \n    procedure Reverse_Iterate\n@@ -1491,13 +1431,26 @@ package body Ada.Containers.Ordered_Multisets is\n \n       procedure Process_Node (Node : Node_Access) is\n       begin\n-         Process (Cursor'(Container'Unchecked_Access, Node));\n+         Process (Cursor'(Container'Unrestricted_Access, Node));\n       end Process_Node;\n \n+      T : Tree_Type renames Container.Tree'Unrestricted_Access.all;\n+      B : Natural renames T.Busy;\n+\n    --  Start of processing for Reverse_Iterate\n \n    begin\n-      Local_Reverse_Iterate (Container.Tree, Item);\n+      B := B + 1;\n+\n+      begin\n+         Local_Reverse_Iterate (T, Item);\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n    end Reverse_Iterate;\n \n    -----------\n@@ -1551,26 +1504,14 @@ package body Ada.Containers.Ordered_Multisets is\n \n    procedure Symmetric_Difference (Target : in out Set; Source : Set) is\n    begin\n-      if Target'Address = Source'Address then\n-         Clear (Target);\n-         return;\n-      end if;\n-\n       Set_Ops.Symmetric_Difference (Target.Tree, Source.Tree);\n    end Symmetric_Difference;\n \n    function Symmetric_Difference (Left, Right : Set) return Set is\n+      Tree : constant Tree_Type :=\n+               Set_Ops.Symmetric_Difference (Left.Tree, Right.Tree);\n    begin\n-      if Left'Address = Right'Address then\n-         return Empty_Set;\n-      end if;\n-\n-      declare\n-         Tree : constant Tree_Type :=\n-                  Set_Ops.Symmetric_Difference (Left.Tree, Right.Tree);\n-      begin\n-         return (Controlled with Tree);\n-      end;\n+      return Set'(Controlled with Tree);\n    end Symmetric_Difference;\n \n    -----------\n@@ -1579,25 +1520,14 @@ package body Ada.Containers.Ordered_Multisets is\n \n    procedure Union (Target : in out Set; Source : Set) is\n    begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n       Set_Ops.Union (Target.Tree, Source.Tree);\n    end Union;\n \n    function Union (Left, Right : Set) return Set is\n+      Tree : constant Tree_Type :=\n+               Set_Ops.Union (Left.Tree, Right.Tree);\n    begin\n-      if Left'Address = Right'Address then\n-         return Left;\n-      end if;\n-\n-      declare\n-         Tree : constant Tree_Type :=\n-                  Set_Ops.Union (Left.Tree, Right.Tree);\n-      begin\n-         return (Controlled with Tree);\n-      end;\n+      return Set'(Controlled with Tree);\n    end Union;\n \n    -----------\n@@ -1608,28 +1538,30 @@ package body Ada.Containers.Ordered_Multisets is\n      (Stream    : access Root_Stream_Type'Class;\n       Container : Set)\n    is\n-      procedure Process (Node : Node_Access);\n-      pragma Inline (Process);\n+      procedure Write_Node\n+        (Stream : access Root_Stream_Type'Class;\n+         Node   : Node_Access);\n+      pragma Inline (Write_Node);\n \n-      procedure Iterate is\n-        new Tree_Operations.Generic_Iteration (Process);\n+      procedure Write is\n+         new Tree_Operations.Generic_Write (Write_Node);\n \n-      -------------\n-      -- Process --\n-      -------------\n+      ----------------\n+      -- Write_Node --\n+      ----------------\n \n-      procedure Process (Node : Node_Access) is\n+      procedure Write_Node\n+        (Stream : access Root_Stream_Type'Class;\n+         Node   : Node_Access)\n+      is\n       begin\n          Element_Type'Write (Stream, Node.Element);\n-      end Process;\n+      end Write_Node;\n \n    --  Start of processing for Write\n \n    begin\n-      Count_Type'Base'Write (Stream, Container.Tree.Length);\n-      Iterate (Container.Tree);\n+      Write (Stream, Container.Tree);\n    end Write;\n \n end Ada.Containers.Ordered_Multisets;\n-\n-"}, {"sha": "4fbb653725d85337be0f6258c1486e7e219d9fb3", "filename": "gcc/ada/a-coormu.ads", "status": "modified", "additions": 38, "deletions": 32, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-coormu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-coormu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coormu.ads?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n---                     ADA.CONTAINERS.ORDERED_MULTISETS                     --\n+--     A D A . C O N T A I N E R S . O R D E R E D _ M U L T I S E T S      --\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -56,6 +56,8 @@ pragma Preelaborate (Ordered_Multisets);\n \n    function \"=\" (Left, Right : Set) return Boolean;\n \n+   function Equivalent_Sets (Left, Right : Set) return Boolean;\n+\n    function Length (Container : Set) return Count_Type;\n \n    function Is_Empty (Container : Set) return Boolean;\n@@ -68,6 +70,11 @@ pragma Preelaborate (Ordered_Multisets);\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type));\n \n+   procedure Replace_Element\n+     (Container : Set;\n+      Position  : Cursor;\n+      By        : Element_Type);\n+\n    procedure Move\n      (Target : in out Set;\n       Source : in out Set);\n@@ -85,10 +92,6 @@ pragma Preelaborate (Ordered_Multisets);\n      (Container : in out Set;\n       Item      : Element_Type);\n \n-   procedure Exclude\n-     (Container : in out Set;\n-      Item      : Element_Type);\n-\n    procedure Delete\n      (Container : in out Set;\n       Position  : in out Cursor);\n@@ -97,13 +100,9 @@ pragma Preelaborate (Ordered_Multisets);\n \n    procedure Delete_Last (Container : in out Set);\n \n-   --  NOTE: The following operation is named Replace in the Madison API.\n-   --  However, it should be named Replace_Element. ???\n-   --\n-   --   procedure Replace\n-   --     (Container : in out Set;\n-   --      Position  : Cursor;\n-   --      By        : Element_Type);\n+   procedure Exclude\n+     (Container : in out Set;\n+      Item      : Element_Type);\n \n    procedure Union (Target : in out Set; Source : Set);\n \n@@ -151,10 +150,10 @@ pragma Preelaborate (Ordered_Multisets);\n \n    function Next (Position : Cursor) return Cursor;\n \n-   function Previous (Position : Cursor) return Cursor;\n-\n    procedure Next (Position : in out Cursor);\n \n+   function Previous (Position : Cursor) return Cursor;\n+\n    procedure Previous (Position : in out Cursor);\n \n    function Has_Element (Position : Cursor) return Boolean;\n@@ -214,12 +213,6 @@ pragma Preelaborate (Ordered_Multisets);\n \n       function Element (Container : Set; Key : Key_Type) return Element_Type;\n \n-      --  NOTE: in post-madison api ???\n-      --      procedure Replace\n-      --        (Container : in out Set;\n-      --         Key       : Key_Type;\n-      --         New_Item  : Element_Type);\n-\n       procedure Delete (Container : in out Set; Key : Key_Type);\n \n       procedure Exclude (Container : in out Set; Key : Key_Type);\n@@ -232,9 +225,7 @@ pragma Preelaborate (Ordered_Multisets);\n \n       function \">\" (Left : Key_Type; Right : Cursor) return Boolean;\n \n-      --  Should name of following be \"Update_Element\" ???\n-\n-      procedure Checked_Update_Element\n+      procedure Update_Element_Preserving_Key\n         (Container : in out Set;\n          Position  : Cursor;\n          Process   : not null access\n@@ -257,21 +248,31 @@ private\n    type Node_Type;\n    type Node_Access is access Node_Type;\n \n-   package Tree_Types is\n-     new Red_Black_Trees.Generic_Tree_Types (Node_Access);\n+   type Node_Type is limited record\n+      Parent  : Node_Access;\n+      Left    : Node_Access;\n+      Right   : Node_Access;\n+      Color   : Red_Black_Trees.Color_Type := Red_Black_Trees.Red;\n+      Element : Element_Type;\n+   end record;\n \n-   use Tree_Types;\n-   use Ada.Finalization;\n+   package Tree_Types is new Red_Black_Trees.Generic_Tree_Types\n+     (Node_Type,\n+      Node_Access);\n \n-   type Set is new Controlled with record\n-      Tree : Tree_Type := (Length => 0, others => null);\n+   type Set is new Ada.Finalization.Controlled with record\n+      Tree : Tree_Types.Tree_Type;\n    end record;\n \n    procedure Adjust (Container : in out Set);\n \n    procedure Finalize (Container : in out Set) renames Clear;\n \n-   type Set_Access is access constant Set;\n+   use Red_Black_Trees;\n+   use Tree_Types;\n+   use Ada.Finalization;\n+\n+   type Set_Access is access all Set;\n    for Set_Access'Storage_Size use 0;\n \n    type Cursor is record\n@@ -296,6 +297,11 @@ private\n    for Set'Read use Read;\n \n    Empty_Set : constant Set :=\n-                 (Controlled with Tree => (Length => 0, others => null));\n+                 (Controlled with Tree => (First  => null,\n+                                           Last   => null,\n+                                           Root   => null,\n+                                           Length => 0,\n+                                           Busy   => 0,\n+                                           Lock   => 0));\n \n end Ada.Containers.Ordered_Multisets;"}, {"sha": "6e803984c7bae53d2f12c1307822591c5e0b0536", "filename": "gcc/ada/a-coorse.adb", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-coorse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-coorse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorse.adb?ref=8704d4b30e3eace58fc9506cf3533b15835c784a"}, {"sha": "179949517134b072be554bad0c94ba45e6f1f07a", "filename": "gcc/ada/a-coorse.ads", "status": "modified", "additions": 44, "deletions": 29, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-coorse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-coorse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorse.ads?ref=8704d4b30e3eace58fc9506cf3533b15835c784a"}, {"sha": "abf9fa680eac7df75a70b0ce3730eeaa4e4e256c", "filename": "gcc/ada/a-crbltr.ads", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-crbltr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-crbltr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-crbltr.ads?ref=8704d4b30e3eace58fc9506cf3533b15835c784a"}, {"sha": "5efd4cdbb101550c0e1a1e913edf897ee0644f0a", "filename": "gcc/ada/a-crbtgk.adb", "status": "modified", "additions": 45, "deletions": 42, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-crbtgk.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-crbtgk.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-crbtgk.adb?ref=8704d4b30e3eace58fc9506cf3533b15835c784a"}, {"sha": "d20d7004da9005d05dfb691c4b0803e45aed23ed", "filename": "gcc/ada/a-crbtgk.ads", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-crbtgk.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-crbtgk.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-crbtgk.ads?ref=8704d4b30e3eace58fc9506cf3533b15835c784a"}, {"sha": "dc82e55b02a8931d80e36b8c509db5c48788f065", "filename": "gcc/ada/a-crbtgo.adb", "status": "modified", "additions": 270, "deletions": 97, "changes": 367, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-crbtgo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-crbtgo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-crbtgo.adb?ref=8704d4b30e3eace58fc9506cf3533b15835c784a"}, {"sha": "84ab26041456dd70e4aab269d235ccec7f61af85", "filename": "gcc/ada/a-crbtgo.ads", "status": "modified", "additions": 63, "deletions": 11, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-crbtgo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-crbtgo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-crbtgo.ads?ref=8704d4b30e3eace58fc9506cf3533b15835c784a"}, {"sha": "2c0b39fd245a7af622d1e6cccca24f2894646db7", "filename": "gcc/ada/a-rbtgso.adb", "status": "modified", "additions": 181, "deletions": 88, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-rbtgso.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-rbtgso.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-rbtgso.adb?ref=8704d4b30e3eace58fc9506cf3533b15835c784a"}, {"sha": "95d893648e24420fd66b8185e4d0a99aa5c27230", "filename": "gcc/ada/a-shcain.adb", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-shcain.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-shcain.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-shcain.adb?ref=8704d4b30e3eace58fc9506cf3533b15835c784a"}, {"sha": "a6e083c1e472c6539ac5e0edad7266d3ebaa4077", "filename": "gcc/ada/a-shcain.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-shcain.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-shcain.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-shcain.ads?ref=8704d4b30e3eace58fc9506cf3533b15835c784a"}, {"sha": "62c4610b93cec55b4b0fcb145d3f805577cf8737", "filename": "gcc/ada/a-strhas.adb", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-strhas.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-strhas.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-strhas.adb?ref=8704d4b30e3eace58fc9506cf3533b15835c784a"}, {"sha": "1f8d6bcf3e5d6f161b1bc09064fb8d0b77c6d5b0", "filename": "gcc/ada/a-stunha.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-stunha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-stunha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stunha.adb?ref=8704d4b30e3eace58fc9506cf3533b15835c784a"}, {"sha": "17ccfb8e5bb1f94a39d263ef2f28bd197cbf0c5f", "filename": "gcc/ada/a-stwiha.adb", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-stwiha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-stwiha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwiha.adb?ref=8704d4b30e3eace58fc9506cf3533b15835c784a"}, {"sha": "3b0af1fc751ade8f1a655d84ea07e2658bc6319e", "filename": "gcc/ada/a-stwiha.ads", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-stwiha.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-stwiha.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwiha.ads?ref=8704d4b30e3eace58fc9506cf3533b15835c784a"}, {"sha": "9c1b752c4182f34ad9e32b94f1ef37359b2c2960", "filename": "gcc/ada/a-stzhas.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-stzhas.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-stzhas.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stzhas.adb?ref=8704d4b30e3eace58fc9506cf3533b15835c784a"}, {"sha": "77912e707183c025e1c78893332f42b54c757566", "filename": "gcc/ada/a-swuwha.adb", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-swuwha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-swuwha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-swuwha.adb?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "previous_filename": "gcc/ada/a-swunha.adb"}, {"sha": "078094a802526ceed165ad93268f94447b0d33a6", "filename": "gcc/ada/a-swuwha.ads", "status": "renamed", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-swuwha.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-swuwha.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-swuwha.ads?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "previous_filename": "gcc/ada/a-swunha.ads"}, {"sha": "2f3df5eae465bac8bc94576732143fa236e1fbcd", "filename": "gcc/ada/a-szuzha.adb", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-szuzha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-szuzha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-szuzha.adb?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "previous_filename": "gcc/ada/a-szunha.adb"}, {"sha": "2aaf66bd485260ceea163d2fffd49336aa88e1c0", "filename": "gcc/ada/a-szuzha.ads", "status": "renamed", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-szuzha.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8704d4b30e3eace58fc9506cf3533b15835c784a/gcc%2Fada%2Fa-szuzha.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-szuzha.ads?ref=8704d4b30e3eace58fc9506cf3533b15835c784a", "previous_filename": "gcc/ada/a-szunha.ads"}]}