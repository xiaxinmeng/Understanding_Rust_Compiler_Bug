{"sha": "83d5977e2f4747bbd33cc00a807e239d0b740895", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODNkNTk3N2UyZjQ3NDdiYmQzM2NjMDBhODA3ZTIzOWQwYjc0MDg5NQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-08-10T09:20:29Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-08-10T09:20:29Z"}, "message": "tree-ssa-pre.c (pretemp, [...]): Remove.\n\n2012-08-10  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-pre.c (pretemp, storetemp, prephitemp): Remove.\n\t(need_creation): Remove.\n\t(get_representative_for): Use anonymous named SSA names.\n\t(create_expression_by_pieces): Likewise.\n\t(insert_into_preds_of_block): Likewise.\n\t(init_pre): Do not init removed vars.\n\t(fini_pre): Do not free need_creation.\n\t* tree-ssa-forwprop.c (simplify_bitwise_binary): Use anonymous\n\tSSA names.\n\t* tree-ssa-loop-manip.c (create_iv): Likewise.\n\t* value-prof.c (gimple_divmod_fixed_value): Likewise.\n\t(gimple_mod_pow2): Likewise.\n\t(gimple_mod_subtract): Likewise.\n\t(gimple_ic): Likewise.\n\t(gimple_stringop_fixed_value): Likewise.\n\t* tree-ssa-phiopt.c (condstoretemp): Remove.\n\t(tree_ssa_phiopt_worker): Use anonymous named SSA names.\n\t(conditional_replacement): Likewise.\n\t(abs_replacement): Likewise.\n\t(cond_store_replacement): Likewise.\n\t(cond_if_else_store_replacement_1): Likewise.\n\t* tree-ssa-loop-im.c (rewrite_reciprocal): Likewise.\n\t(rewrite_bittest): Likewise.\n\t* tree-ssa-reassoc.c (build_and_add_sum): Get type from callers\n\tand build anonymous SSA names.\n\t(undistribute_ops_list): Adjust.\n\t(eliminate_redundant_comparison): Use anonymous SSA names.\n\t(rewrite_expr_tree_parallel): Likewise.\n\t(get_reassoc_pow_ssa_name): Remove.\n\t(attempt_builtin_powi): Adjust.\n\t(reassociate_bb): Likewise.\n\t* tree-ssa-strlen.c (get_string_length): Use anonymous SSA names.\n\t* tree-switch-conversion.c (emit_case_bit_tests): Likewise.\n\t(build_arrays): Likewise.\n\t* tree-tailcall.c (adjust_return_value_with_ops): Likewise.\n\t(create_tailcall_accumulator): Likewise.\n\t* tree-vect-generic.c (expand_vector_divmod): Likewise.\n\t* tree-profile.c (gcov_type_tmp_var): Remove.\n\t(gimple_init_edge_profiler): Do not initialize it and use anonymous\n\tSSA names.\n\t(gimple_gen_ic_profiler): Likewise.\n\t(tree_profiling): Adjust.\n\t* tree-sra.c (build_ref_for_offset): Use anonymous SSA names.\n\t* tree-ssa-math-opts.c (execute_cse_sincos_1): Likewise.\n\t(powi_as_mults_1): Likewise.\n\t(powi_as_mults): Likewise.\n\t(build_and_insert_call): Adjust.\n\t(build_and_insert_binop): Likewise.\n\t(build_and_insert_ref): Likewise.\n\t(build_and_insert_cast): Likewise.\n\t(gimple_expand_builtin_pow): Likewise.\n\t(gimple_expand_builtin_cabs): Likewise.\n\t(execute_optimize_bswap): Use anonymous SSA names.\n\t(convert_mult_to_widen): Likewise.\n\t(convert_plusminus_to_widen): Likewise.\n\t* tree-ssa-phiprop.c (phiprop_insert_phi): Likewise.\n\t* tree-ssa-propagate.c (update_call_from_tree): Likewise.\n\t* tree-if-conv.c (ifc_temp_var): Likewise.\n\t* tree-loop-distribution.c (generate_memset_builtin): Likewise.\n\t* tree-parloops.c (take_address_of): Likewise.\n\t* tree-vect-data-refs.c (vect_permute_store_chain): Likewise.\n\t(vect_permute_load_chain): Likewise.\n\t* tree-vect-loop-manip.c (vect_create_cond_for_align_checks): Likewise.\n\t* tree-vect-patterns.c (vect_recog_temp_ssa_var): Likewise.\n\t(vect_handle_widen_op_by_const): Likewise.\n\t(vect_operation_fits_smaller_type): Likewise.\n\t(vect_recog_over_widening_pattern): Likewise.\n\t* tree-vect-stmts.c (vect_init_vector): Likewise.\n\t* tree-vrp.c (simplify_truth_ops_using_ranges): Likewise.\n\t(simplify_float_conversion_using_ranges): Likewise.\n\nFrom-SVN: r190288", "tree": {"sha": "538c53782d228ed64003ea7683f91c231d7ad532", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/538c53782d228ed64003ea7683f91c231d7ad532"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83d5977e2f4747bbd33cc00a807e239d0b740895", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83d5977e2f4747bbd33cc00a807e239d0b740895", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83d5977e2f4747bbd33cc00a807e239d0b740895", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83d5977e2f4747bbd33cc00a807e239d0b740895/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7b5e682ae51f6f131daf276afca59961066ab4aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b5e682ae51f6f131daf276afca59961066ab4aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b5e682ae51f6f131daf276afca59961066ab4aa"}], "stats": {"total": 703, "additions": 287, "deletions": 416}, "files": [{"sha": "d7f463e534f256dd38aa930d0810e0283b16675e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=83d5977e2f4747bbd33cc00a807e239d0b740895", "patch": "@@ -1,3 +1,76 @@\n+2012-08-10  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-pre.c (pretemp, storetemp, prephitemp): Remove.\n+\t(need_creation): Remove.\n+\t(get_representative_for): Use anonymous named SSA names.\n+\t(create_expression_by_pieces): Likewise.\n+\t(insert_into_preds_of_block): Likewise.\n+\t(init_pre): Do not init removed vars.\n+\t(fini_pre): Do not free need_creation.\n+\t* tree-ssa-forwprop.c (simplify_bitwise_binary): Use anonymous\n+\tSSA names.\n+\t* tree-ssa-loop-manip.c (create_iv): Likewise.\n+\t* value-prof.c (gimple_divmod_fixed_value): Likewise.\n+\t(gimple_mod_pow2): Likewise.\n+\t(gimple_mod_subtract): Likewise.\n+\t(gimple_ic): Likewise.\n+\t(gimple_stringop_fixed_value): Likewise.\n+\t* tree-ssa-phiopt.c (condstoretemp): Remove.\n+\t(tree_ssa_phiopt_worker): Use anonymous named SSA names.\n+\t(conditional_replacement): Likewise.\n+\t(abs_replacement): Likewise.\n+\t(cond_store_replacement): Likewise.\n+\t(cond_if_else_store_replacement_1): Likewise.\n+\t* tree-ssa-loop-im.c (rewrite_reciprocal): Likewise.\n+\t(rewrite_bittest): Likewise.\n+\t* tree-ssa-reassoc.c (build_and_add_sum): Get type from callers\n+\tand build anonymous SSA names.\n+\t(undistribute_ops_list): Adjust.\n+\t(eliminate_redundant_comparison): Use anonymous SSA names.\n+\t(rewrite_expr_tree_parallel): Likewise.\n+\t(get_reassoc_pow_ssa_name): Remove.\n+\t(attempt_builtin_powi): Adjust.\n+\t(reassociate_bb): Likewise.\n+\t* tree-ssa-strlen.c (get_string_length): Use anonymous SSA names.\n+\t* tree-switch-conversion.c (emit_case_bit_tests): Likewise.\n+\t(build_arrays): Likewise.\n+\t* tree-tailcall.c (adjust_return_value_with_ops): Likewise.\n+\t(create_tailcall_accumulator): Likewise.\n+\t* tree-vect-generic.c (expand_vector_divmod): Likewise.\n+\t* tree-profile.c (gcov_type_tmp_var): Remove.\n+\t(gimple_init_edge_profiler): Do not initialize it and use anonymous\n+\tSSA names.\n+\t(gimple_gen_ic_profiler): Likewise.\n+\t(tree_profiling): Adjust.\n+\t* tree-sra.c (build_ref_for_offset): Use anonymous SSA names.\n+\t* tree-ssa-math-opts.c (execute_cse_sincos_1): Likewise.\n+\t(powi_as_mults_1): Likewise.\n+\t(powi_as_mults): Likewise.\n+\t(build_and_insert_call): Adjust.\n+\t(build_and_insert_binop): Likewise.\n+\t(build_and_insert_ref): Likewise.\n+\t(build_and_insert_cast): Likewise.\n+\t(gimple_expand_builtin_pow): Likewise.\n+\t(gimple_expand_builtin_cabs): Likewise.\n+\t(execute_optimize_bswap): Use anonymous SSA names.\n+\t(convert_mult_to_widen): Likewise.\n+\t(convert_plusminus_to_widen): Likewise.\n+\t* tree-ssa-phiprop.c (phiprop_insert_phi): Likewise.\n+\t* tree-ssa-propagate.c (update_call_from_tree): Likewise.\n+\t* tree-if-conv.c (ifc_temp_var): Likewise.\n+\t* tree-loop-distribution.c (generate_memset_builtin): Likewise.\n+\t* tree-parloops.c (take_address_of): Likewise.\n+\t* tree-vect-data-refs.c (vect_permute_store_chain): Likewise.\n+\t(vect_permute_load_chain): Likewise.\n+\t* tree-vect-loop-manip.c (vect_create_cond_for_align_checks): Likewise.\n+\t* tree-vect-patterns.c (vect_recog_temp_ssa_var): Likewise.\n+\t(vect_handle_widen_op_by_const): Likewise.\n+\t(vect_operation_fits_smaller_type): Likewise.\n+\t(vect_recog_over_widening_pattern): Likewise.\n+\t* tree-vect-stmts.c (vect_init_vector): Likewise.\n+\t* tree-vrp.c (simplify_truth_ops_using_ranges): Likewise.\n+\t(simplify_float_conversion_using_ranges): Likewise.\n+\n 2012-08-10  Michael Zolotukhin  <michael.v.zolotukhin@intel.com>\n \n \t* config/i386/i386.c (ix86_init_mmx_sse_builtins): Fix builtin"}, {"sha": "828969103a3329697a9b99320e8f5d75c5af9014", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=83d5977e2f4747bbd33cc00a807e239d0b740895", "patch": "@@ -221,25 +221,10 @@ reset_bb_predicate (basic_block bb)\n static tree\n ifc_temp_var (tree type, tree expr, gimple_stmt_iterator *gsi)\n {\n-  const char *name = \"_ifc_\";\n-  tree var, new_name;\n-  gimple stmt;\n-\n-  /* Create new temporary variable.  */\n-  var = create_tmp_var (type, name);\n-\n-  /* Build new statement to assign EXPR to new variable.  */\n-  stmt = gimple_build_assign (var, expr);\n-\n-  /* Get SSA name for the new variable and set make new statement\n-     its definition statement.  */\n-  new_name = make_ssa_name (var, stmt);\n-  gimple_assign_set_lhs (stmt, new_name);\n-  SSA_NAME_DEF_STMT (new_name) = stmt;\n-  update_stmt (stmt);\n-\n+  tree new_name = make_temp_ssa_name (type, NULL, \"_ifc_\");\n+  gimple stmt = gimple_build_assign (new_name, expr);\n   gsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n-  return gimple_assign_lhs (stmt);\n+  return new_name;\n }\n \n /* Return true when COND is a true predicate.  */"}, {"sha": "377b544b40db27aa2be8e0a451b8acfe4a23ba04", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=83d5977e2f4747bbd33cc00a807e239d0b740895", "patch": "@@ -391,8 +391,7 @@ generate_memset_builtin (struct loop *loop, partition_t partition)\n       else if (!useless_type_conversion_p (integer_type_node, TREE_TYPE (val)))\n \t{\n \t  gimple cstmt;\n-\t  tree tem = create_tmp_reg (integer_type_node, NULL);\n-\t  tem = make_ssa_name (tem, NULL);\n+\t  tree tem = make_ssa_name (integer_type_node, NULL);\n \t  cstmt = gimple_build_assign_with_ops (NOP_EXPR, tem, val, NULL_TREE);\n \t  gsi_insert_after (&gsi, cstmt, GSI_CONTINUE_LINKING);\n \t  val = tem;"}, {"sha": "224d546b7551dc7014108972ac5f39698a15eba1", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=83d5977e2f4747bbd33cc00a807e239d0b740895", "patch": "@@ -452,7 +452,7 @@ take_address_of (tree obj, tree type, edge entry, htab_t decl_address,\n   int uid;\n   void **dslot;\n   struct int_tree_map ielt, *nielt;\n-  tree *var_p, name, bvar, addr;\n+  tree *var_p, name, addr;\n   gimple stmt;\n   gimple_seq stmts;\n \n@@ -479,12 +479,10 @@ take_address_of (tree obj, tree type, edge entry, htab_t decl_address,\n       if (gsi == NULL)\n \treturn NULL;\n       addr = TREE_OPERAND (*var_p, 0);\n-      bvar = create_tmp_var (TREE_TYPE (addr),\n-\t\t\t     get_name (TREE_OPERAND\n-\t\t\t\t         (TREE_OPERAND (*var_p, 0), 0)));\n-      stmt = gimple_build_assign (bvar, addr);\n-      name = make_ssa_name (bvar, stmt);\n-      gimple_assign_set_lhs (stmt, name);\n+      name = make_temp_ssa_name (TREE_TYPE (addr), NULL,\n+\t\t\t\t get_name (TREE_OPERAND\n+\t\t\t\t\t   (TREE_OPERAND (*var_p, 0), 0)));\n+      stmt = gimple_build_assign (name, addr);\n       gsi_insert_on_edge_immediate (entry, stmt);\n \n       nielt = XNEW (struct int_tree_map);"}, {"sha": "a5b6bc80281c977550f0126d881661e18e88fd14", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=83d5977e2f4747bbd33cc00a807e239d0b740895", "patch": "@@ -44,7 +44,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n \n static GTY(()) tree gcov_type_node;\n-static GTY(()) tree gcov_type_tmp_var;\n static GTY(()) tree tree_interval_profiler_fn;\n static GTY(()) tree tree_pow2_profiler_fn;\n static GTY(()) tree tree_one_value_profiler_fn;\n@@ -209,20 +208,18 @@ gimple_init_edge_profiler (void)\n void\n gimple_gen_edge_profiler (int edgeno, edge e)\n {\n-  tree ref, one;\n+  tree ref, one, gcov_type_tmp_var;\n   gimple stmt1, stmt2, stmt3;\n \n-  /* We share one temporary variable declaration per function.  This\n-     gets re-set in tree_profiling.  */\n-  if (gcov_type_tmp_var == NULL_TREE)\n-    gcov_type_tmp_var = create_tmp_reg (gcov_type_node, \"PROF_edge_counter\");\n   ref = tree_coverage_counter_ref (GCOV_COUNTER_ARCS, edgeno);\n   one = build_int_cst (gcov_type_node, 1);\n+  gcov_type_tmp_var = make_temp_ssa_name (gcov_type_node,\n+\t\t\t\t\t  NULL, \"PROF_edge_counter\");\n   stmt1 = gimple_build_assign (gcov_type_tmp_var, ref);\n-  gimple_assign_set_lhs (stmt1, make_ssa_name (gcov_type_tmp_var, stmt1));\n+  gcov_type_tmp_var = make_temp_ssa_name (gcov_type_node,\n+\t\t\t\t\t  NULL, \"PROF_edge_counter\");\n   stmt2 = gimple_build_assign_with_ops (PLUS_EXPR, gcov_type_tmp_var,\n \t\t\t\t\tgimple_assign_lhs (stmt1), one);\n-  gimple_assign_set_lhs (stmt2, make_ssa_name (gcov_type_tmp_var, stmt2));\n   stmt3 = gimple_build_assign (unshare_expr (ref), gimple_assign_lhs (stmt2));\n   gsi_insert_on_edge (e, stmt1);\n   gsi_insert_on_edge (e, stmt2);\n@@ -335,10 +332,9 @@ gimple_gen_ic_profiler (histogram_value value, unsigned tag, unsigned base)\n     stmt3: __gcov_indirect_call_callee = tmp1;\n    */\n \n-  tmp1 = create_tmp_reg (ptr_void, \"PROF\");\n   stmt1 = gimple_build_assign (ic_gcov_type_ptr_var, ref_ptr);\n+  tmp1 = make_temp_ssa_name (ptr_void, NULL, \"PROF\");\n   stmt2 = gimple_build_assign (tmp1, unshare_expr (value->hvalue.value));\n-  gimple_assign_set_lhs (stmt2, make_ssa_name (tmp1, stmt2));\n   stmt3 = gimple_build_assign (ic_void_ptr_var, gimple_assign_lhs (stmt2));\n \n   gsi_insert_before (&gsi, stmt1, GSI_SAME_STMT);\n@@ -481,9 +477,6 @@ tree_profiling (void)\n       push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n       current_function_decl = node->symbol.decl;\n \n-      /* Re-set global shared temporary variable for edge-counters.  */\n-      gcov_type_tmp_var = NULL_TREE;\n-\n       /* Local pure-const may imply need to fixup the cfg.  */\n       if (execute_fixup_cfg () & TODO_cleanup_cfg)\n \tcleanup_tree_cfg ();"}, {"sha": "3c94b79dfef76294be7d7c358c7d89ba119b0e0d", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=83d5977e2f4747bbd33cc00a807e239d0b740895", "patch": "@@ -1448,18 +1448,15 @@ build_ref_for_offset (location_t loc, tree base, HOST_WIDE_INT offset,\n       tree tmp, addr;\n \n       gcc_checking_assert (gsi);\n-      tmp = create_tmp_reg (build_pointer_type (TREE_TYPE (prev_base)), NULL);\n-      tmp = make_ssa_name (tmp, NULL);\n+      tmp = make_ssa_name (build_pointer_type (TREE_TYPE (prev_base)), NULL);\n       addr = build_fold_addr_expr (unshare_expr (prev_base));\n       STRIP_USELESS_TYPE_CONVERSION (addr);\n       stmt = gimple_build_assign (tmp, addr);\n       gimple_set_location (stmt, loc);\n-      SSA_NAME_DEF_STMT (tmp) = stmt;\n       if (insert_after)\n \tgsi_insert_after (gsi, stmt, GSI_NEW_STMT);\n       else\n \tgsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n-      update_stmt (stmt);\n \n       off = build_int_cst (reference_alias_ptr_type (prev_base),\n \t\t\t   offset / BITS_PER_UNIT);"}, {"sha": "649182ba7e2f99c2cd8a4c91720256be2fb2ade6", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=83d5977e2f4747bbd33cc00a807e239d0b740895", "patch": "@@ -1941,14 +1941,12 @@ simplify_bitwise_binary (gimple_stmt_iterator *gsi)\n       && int_fits_type_p (arg2, TREE_TYPE (def1_arg1)))\n     {\n       gimple newop;\n-      tree tem = create_tmp_reg (TREE_TYPE (def1_arg1), NULL);\n+      tree tem = make_ssa_name (TREE_TYPE (def1_arg1), NULL);\n       newop =\n         gimple_build_assign_with_ops (code, tem, def1_arg1,\n \t\t\t\t      fold_convert_loc (gimple_location (stmt),\n \t\t\t\t\t\t\tTREE_TYPE (def1_arg1),\n \t\t\t\t\t\t\targ2));\n-      tem = make_ssa_name (tem, newop);\n-      gimple_assign_set_lhs (newop, tem);\n       gimple_set_location (newop, gimple_location (stmt));\n       gsi_insert_before (gsi, newop, GSI_SAME_STMT);\n       gimple_assign_set_rhs_with_ops_1 (gsi, NOP_EXPR,\n@@ -1974,11 +1972,8 @@ simplify_bitwise_binary (gimple_stmt_iterator *gsi)\n \t      != GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (arg1))))))\n     {\n       gimple newop;\n-      tree tem = create_tmp_reg (TREE_TYPE (def1_arg1),\n-\t\t\t\t NULL);\n+      tree tem = make_ssa_name (TREE_TYPE (def1_arg1), NULL);\n       newop = gimple_build_assign_with_ops (code, tem, def1_arg1, def2_arg1);\n-      tem = make_ssa_name (tem, newop);\n-      gimple_assign_set_lhs (newop, tem);\n       gimple_set_location (newop, gimple_location (stmt));\n       gsi_insert_before (gsi, newop, GSI_SAME_STMT);\n       gimple_assign_set_rhs_with_ops_1 (gsi, NOP_EXPR,\n@@ -2020,10 +2015,8 @@ simplify_bitwise_binary (gimple_stmt_iterator *gsi)\n \t{\n \t  gimple newop;\n \t  tree tem;\n-\t  tem = create_tmp_reg (TREE_TYPE (arg2), NULL);\n+\t  tem = make_ssa_name (TREE_TYPE (arg2), NULL);\n \t  newop = gimple_build_assign_with_ops (code, tem, a, c);\n-\t  tem = make_ssa_name (tem, newop);\n-\t  gimple_assign_set_lhs (newop, tem);\n \t  gimple_set_location (newop, gimple_location (stmt));\n \t  /* Make sure to re-process the new stmt as it's walking upwards.  */\n \t  gsi_insert_before (gsi, newop, GSI_NEW_STMT);\n@@ -2051,11 +2044,9 @@ simplify_bitwise_binary (gimple_stmt_iterator *gsi)\n \t  update_stmt (stmt);\n \t  return true;\n \t}\n-      tem = create_tmp_reg (TREE_TYPE (arg2), NULL);\n+      tem = make_ssa_name (TREE_TYPE (arg2), NULL);\n       newop = gimple_build_assign_with_ops (BIT_AND_EXPR,\n \t\t\t\t\t    tem, def1_arg1, arg2);\n-      tem = make_ssa_name (tem, newop);\n-      gimple_assign_set_lhs (newop, tem);\n       gimple_set_location (newop, gimple_location (stmt));\n       /* Make sure to re-process the new stmt as it's walking upwards.  */\n       gsi_insert_before (gsi, newop, GSI_NEW_STMT);"}, {"sha": "618233aa3bae60704a0af8cf3ebdc031afb89aa0", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=83d5977e2f4747bbd33cc00a807e239d0b740895", "patch": "@@ -934,22 +934,19 @@ static gimple\n rewrite_reciprocal (gimple_stmt_iterator *bsi)\n {\n   gimple stmt, stmt1, stmt2;\n-  tree var, name, lhs, type;\n+  tree name, lhs, type;\n   tree real_one;\n   gimple_stmt_iterator gsi;\n \n   stmt = gsi_stmt (*bsi);\n   lhs = gimple_assign_lhs (stmt);\n   type = TREE_TYPE (lhs);\n \n-  var = create_tmp_reg (type, \"reciptmp\");\n-\n   real_one = build_one_cst (type);\n \n-  stmt1 = gimple_build_assign_with_ops (RDIV_EXPR,\n-\t\tvar, real_one, gimple_assign_rhs2 (stmt));\n-  name = make_ssa_name (var, stmt1);\n-  gimple_assign_set_lhs (stmt1, name);\n+  name = make_temp_ssa_name (type, NULL, \"reciptmp\");\n+  stmt1 = gimple_build_assign_with_ops (RDIV_EXPR, name, real_one,\n+\t\t\t\t\tgimple_assign_rhs2 (stmt));\n \n   stmt2 = gimple_build_assign_with_ops (MULT_EXPR, lhs, name,\n \t\t\t\t\tgimple_assign_rhs1 (stmt));\n@@ -972,7 +969,7 @@ static gimple\n rewrite_bittest (gimple_stmt_iterator *bsi)\n {\n   gimple stmt, use_stmt, stmt1, stmt2;\n-  tree lhs, var, name, t, a, b;\n+  tree lhs, name, t, a, b;\n   use_operand_p use;\n \n   stmt = gsi_stmt (*bsi);\n@@ -1021,18 +1018,15 @@ rewrite_bittest (gimple_stmt_iterator *bsi)\n       gimple_stmt_iterator rsi;\n \n       /* 1 << B */\n-      var = create_tmp_var (TREE_TYPE (a), \"shifttmp\");\n       t = fold_build2 (LSHIFT_EXPR, TREE_TYPE (a),\n \t\t       build_int_cst (TREE_TYPE (a), 1), b);\n-      stmt1 = gimple_build_assign (var, t);\n-      name = make_ssa_name (var, stmt1);\n-      gimple_assign_set_lhs (stmt1, name);\n+      name = make_temp_ssa_name (TREE_TYPE (a), NULL, \"shifttmp\");\n+      stmt1 = gimple_build_assign (name, t);\n \n       /* A & (1 << B) */\n       t = fold_build2 (BIT_AND_EXPR, TREE_TYPE (a), a, name);\n-      stmt2 = gimple_build_assign (var, t);\n-      name = make_ssa_name (var, stmt2);\n-      gimple_assign_set_lhs (stmt2, name);\n+      name = make_temp_ssa_name (TREE_TYPE (a), NULL, \"shifttmp\");\n+      stmt2 = gimple_build_assign (name, t);\n \n       /* Replace the SSA_NAME we compare against zero.  Adjust\n \t the type of zero accordingly.  */"}, {"sha": "5aa8c7d3c3f0fea65bb09bcaf7ec4867d8522f5f", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=83d5977e2f4747bbd33cc00a807e239d0b740895", "patch": "@@ -55,13 +55,18 @@ create_iv (tree base, tree step, tree var, struct loop *loop,\n   enum tree_code incr_op = PLUS_EXPR;\n   edge pe = loop_preheader_edge (loop);\n \n-  if (!var)\n-    var = create_tmp_var (TREE_TYPE (base), \"ivtmp\");\n-\n-  vb = make_ssa_name (var, NULL);\n+  if (var != NULL_TREE)\n+    {\n+      vb = make_ssa_name (var, NULL);\n+      va = make_ssa_name (var, NULL);\n+    }\n+  else\n+    {\n+      vb = make_temp_ssa_name (TREE_TYPE (base), NULL, \"ivtmp\");\n+      va = make_temp_ssa_name (TREE_TYPE (base), NULL, \"ivtmp\");\n+    }\n   if (var_before)\n     *var_before = vb;\n-  va = make_ssa_name (var, NULL);\n   if (var_after)\n     *var_after = va;\n "}, {"sha": "2eed792da018c26d8ddc74e5b09e6aee21d4ce88", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 74, "deletions": 97, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=83d5977e2f4747bbd33cc00a807e239d0b740895", "patch": "@@ -740,9 +740,8 @@ execute_cse_sincos_1 (tree name)\n   fndecl = mathfn_built_in (type, BUILT_IN_CEXPI);\n   if (!fndecl)\n     return false;\n-  res = create_tmp_reg (TREE_TYPE (TREE_TYPE (fndecl)), \"sincostmp\");\n   stmt = gimple_build_call (fndecl, 1, name);\n-  res = make_ssa_name (res, stmt);\n+  res = make_temp_ssa_name (TREE_TYPE (TREE_TYPE (fndecl)), stmt, \"sincostmp\");\n   gimple_call_set_lhs (stmt, res);\n \n   def_stmt = SSA_NAME_DEF_STMT (name);\n@@ -758,7 +757,6 @@ execute_cse_sincos_1 (tree name)\n       gsi = gsi_after_labels (top_bb);\n       gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n     }\n-  update_stmt (stmt);\n   sincos_stats.inserted++;\n \n   /* And adjust the recorded old call sites.  */\n@@ -939,7 +937,7 @@ powi_cost (HOST_WIDE_INT n)\n \n static tree\n powi_as_mults_1 (gimple_stmt_iterator *gsi, location_t loc, tree type,\n-\t\t HOST_WIDE_INT n, tree *cache, tree target)\n+\t\t HOST_WIDE_INT n, tree *cache)\n {\n   tree op0, op1, ssa_target;\n   unsigned HOST_WIDE_INT digit;\n@@ -948,23 +946,23 @@ powi_as_mults_1 (gimple_stmt_iterator *gsi, location_t loc, tree type,\n   if (n < POWI_TABLE_SIZE && cache[n])\n     return cache[n];\n \n-  ssa_target = make_ssa_name (target, NULL);\n+  ssa_target = make_temp_ssa_name (type, NULL, \"powmult\");\n \n   if (n < POWI_TABLE_SIZE)\n     {\n       cache[n] = ssa_target;\n-      op0 = powi_as_mults_1 (gsi, loc, type, n - powi_table[n], cache, target);\n-      op1 = powi_as_mults_1 (gsi, loc, type, powi_table[n], cache, target);\n+      op0 = powi_as_mults_1 (gsi, loc, type, n - powi_table[n], cache);\n+      op1 = powi_as_mults_1 (gsi, loc, type, powi_table[n], cache);\n     }\n   else if (n & 1)\n     {\n       digit = n & ((1 << POWI_WINDOW_SIZE) - 1);\n-      op0 = powi_as_mults_1 (gsi, loc, type, n - digit, cache, target);\n-      op1 = powi_as_mults_1 (gsi, loc, type, digit, cache, target);\n+      op0 = powi_as_mults_1 (gsi, loc, type, n - digit, cache);\n+      op1 = powi_as_mults_1 (gsi, loc, type, digit, cache);\n     }\n   else\n     {\n-      op0 = powi_as_mults_1 (gsi, loc, type, n >> 1, cache, target);\n+      op0 = powi_as_mults_1 (gsi, loc, type, n >> 1, cache);\n       op1 = op0;\n     }\n \n@@ -982,23 +980,22 @@ static tree\n powi_as_mults (gimple_stmt_iterator *gsi, location_t loc,\n \t       tree arg0, HOST_WIDE_INT n)\n {\n-  tree cache[POWI_TABLE_SIZE], result, type = TREE_TYPE (arg0), target;\n+  tree cache[POWI_TABLE_SIZE], result, type = TREE_TYPE (arg0);\n   gimple div_stmt;\n+  tree target;\n \n   if (n == 0)\n     return build_real (type, dconst1);\n \n   memset (cache, 0,  sizeof (cache));\n   cache[1] = arg0;\n \n-  target = create_tmp_reg (type, \"powmult\");\n-  result = powi_as_mults_1 (gsi, loc, type, (n < 0) ? -n : n, cache, target);\n-\n+  result = powi_as_mults_1 (gsi, loc, type, (n < 0) ? -n : n, cache);\n   if (n >= 0)\n     return result;\n \n   /* If the original exponent was negative, reciprocate the result.  */\n-  target = make_ssa_name (target, NULL);\n+  target = make_temp_ssa_name (type, NULL, \"powmult\");\n   div_stmt = gimple_build_assign_with_ops (RDIV_EXPR, target, \n \t\t\t\t\t   build_real (type, dconst1),\n \t\t\t\t\t   result);\n@@ -1029,23 +1026,19 @@ gimple_expand_builtin_powi (gimple_stmt_iterator *gsi, location_t loc,\n }\n \n /* Build a gimple call statement that calls FN with argument ARG.\n-   Set the lhs of the call statement to a fresh SSA name for\n-   variable VAR.  If VAR is NULL, first allocate it.  Insert the\n+   Set the lhs of the call statement to a fresh SSA name.  Insert the\n    statement prior to GSI's current position, and return the fresh\n    SSA name.  */\n \n static tree\n build_and_insert_call (gimple_stmt_iterator *gsi, location_t loc,\n-\t\t       tree *var, tree fn, tree arg)\n+\t\t       tree fn, tree arg)\n {\n   gimple call_stmt;\n   tree ssa_target;\n \n-  if (!*var)\n-    *var = create_tmp_reg (TREE_TYPE (arg), \"powroot\");\n-\n   call_stmt = gimple_build_call (fn, 1, arg);\n-  ssa_target = make_ssa_name (*var, NULL);\n+  ssa_target = make_temp_ssa_name (TREE_TYPE (arg), NULL, \"powroot\");\n   gimple_set_lhs (call_stmt, ssa_target);\n   gimple_set_location (call_stmt, loc);\n   gsi_insert_before (gsi, call_stmt, GSI_SAME_STMT);\n@@ -1060,39 +1053,44 @@ build_and_insert_call (gimple_stmt_iterator *gsi, location_t loc,\n \n static tree\n build_and_insert_binop (gimple_stmt_iterator *gsi, location_t loc,\n-\t\t\ttree target, enum tree_code code, tree arg0, tree arg1)\n+\t\t\tconst char *name, enum tree_code code,\n+\t\t\ttree arg0, tree arg1)\n {\n-  tree result = make_ssa_name (target, NULL);\n+  tree result = make_temp_ssa_name (TREE_TYPE (arg0), NULL, name);\n   gimple stmt = gimple_build_assign_with_ops (code, result, arg0, arg1);\n   gimple_set_location (stmt, loc);\n   gsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n   return result;\n }\n \n /* Build a gimple reference operation with the given CODE and argument\n-   ARG, assigning the result to a new SSA name for variable TARGET.  \n+   ARG, assigning the result to a new SSA name of TYPE with NAME.\n    Insert the statement prior to GSI's current position, and return\n    the fresh SSA name.  */\n \n static inline tree\n build_and_insert_ref (gimple_stmt_iterator *gsi, location_t loc, tree type,\n-\t\t      tree target, enum tree_code code, tree arg0)\n+\t\t      const char *name, enum tree_code code, tree arg0)\n {\n-  tree result = make_ssa_name (target, NULL);\n+  tree result = make_temp_ssa_name (type, NULL, name);\n   gimple stmt = gimple_build_assign (result, build1 (code, type, arg0));\n   gimple_set_location (stmt, loc);\n   gsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n   return result;\n }\n \n-/* Build a gimple assignment to cast VAL to TARGET.  Insert the statement\n+/* Build a gimple assignment to cast VAL to TYPE.  Insert the statement\n    prior to GSI's current position, and return the fresh SSA name.  */\n \n static tree\n build_and_insert_cast (gimple_stmt_iterator *gsi, location_t loc,\n-\t\t       tree target, tree val)\n+\t\t       tree type, tree val)\n {\n-  return build_and_insert_binop (gsi, loc, target, CONVERT_EXPR, val, NULL);\n+  tree result = make_ssa_name (type, NULL);\n+  gimple stmt = gimple_build_assign_with_ops (NOP_EXPR, result, val, NULL_TREE);\n+  gimple_set_location (stmt, loc);\n+  gsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n+  return result;\n }\n \n /* ARG0 and ARG1 are the two arguments to a pow builtin call in GSI\n@@ -1108,7 +1106,6 @@ gimple_expand_builtin_pow (gimple_stmt_iterator *gsi, location_t loc,\n   REAL_VALUE_TYPE c2, dconst3;\n   HOST_WIDE_INT n;\n   tree type, sqrtfn, cbrtfn, sqrt_arg0, sqrt_sqrt, result, cbrt_x, powi_cbrt_x;\n-  tree target = NULL_TREE;\n   enum machine_mode mode;\n   bool hw_sqrt_exists;\n \n@@ -1141,7 +1138,7 @@ gimple_expand_builtin_pow (gimple_stmt_iterator *gsi, location_t loc,\n   if (sqrtfn\n       && REAL_VALUES_EQUAL (c, dconsthalf)\n       && !HONOR_SIGNED_ZEROS (mode))\n-    return build_and_insert_call (gsi, loc, &target, sqrtfn, arg0);\n+    return build_and_insert_call (gsi, loc, sqrtfn, arg0);\n \n   /* Optimize pow(x,0.25) = sqrt(sqrt(x)).  Assume on most machines that\n      a builtin sqrt instruction is smaller than a call to pow with 0.25,\n@@ -1157,10 +1154,10 @@ gimple_expand_builtin_pow (gimple_stmt_iterator *gsi, location_t loc,\n       && hw_sqrt_exists)\n     {\n       /* sqrt(x)  */\n-      sqrt_arg0 = build_and_insert_call (gsi, loc, &target, sqrtfn, arg0);\n+      sqrt_arg0 = build_and_insert_call (gsi, loc, sqrtfn, arg0);\n \n       /* sqrt(sqrt(x))  */\n-      return build_and_insert_call (gsi, loc, &target, sqrtfn, sqrt_arg0);\n+      return build_and_insert_call (gsi, loc, sqrtfn, sqrt_arg0);\n     }\n       \n   /* Optimize pow(x,0.75) = sqrt(x) * sqrt(sqrt(x)) unless we are\n@@ -1176,13 +1173,13 @@ gimple_expand_builtin_pow (gimple_stmt_iterator *gsi, location_t loc,\n       && hw_sqrt_exists)\n     {\n       /* sqrt(x)  */\n-      sqrt_arg0 = build_and_insert_call (gsi, loc, &target, sqrtfn, arg0);\n+      sqrt_arg0 = build_and_insert_call (gsi, loc, sqrtfn, arg0);\n \n       /* sqrt(sqrt(x))  */\n-      sqrt_sqrt = build_and_insert_call (gsi, loc, &target, sqrtfn, sqrt_arg0);\n+      sqrt_sqrt = build_and_insert_call (gsi, loc, sqrtfn, sqrt_arg0);\n \n       /* sqrt(x) * sqrt(sqrt(x))  */\n-      return build_and_insert_binop (gsi, loc, target, MULT_EXPR,\n+      return build_and_insert_binop (gsi, loc, \"powroot\", MULT_EXPR,\n \t\t\t\t     sqrt_arg0, sqrt_sqrt);\n     }\n \n@@ -1199,7 +1196,7 @@ gimple_expand_builtin_pow (gimple_stmt_iterator *gsi, location_t loc,\n       && cbrtfn\n       && (gimple_val_nonnegative_real_p (arg0) || !HONOR_NANS (mode))\n       && REAL_VALUES_EQUAL (c, dconst1_3))\n-    return build_and_insert_call (gsi, loc, &target, cbrtfn, arg0);\n+    return build_and_insert_call (gsi, loc, cbrtfn, arg0);\n   \n   /* Optimize pow(x,1./6.) = cbrt(sqrt(x)).  Don't do this optimization\n      if we don't have a hardware sqrt insn.  */\n@@ -1215,10 +1212,10 @@ gimple_expand_builtin_pow (gimple_stmt_iterator *gsi, location_t loc,\n       && REAL_VALUES_EQUAL (c, dconst1_6))\n     {\n       /* sqrt(x)  */\n-      sqrt_arg0 = build_and_insert_call (gsi, loc, &target, sqrtfn, arg0);\n+      sqrt_arg0 = build_and_insert_call (gsi, loc, sqrtfn, arg0);\n \n       /* cbrt(sqrt(x))  */\n-      return build_and_insert_call (gsi, loc, &target, cbrtfn, sqrt_arg0);\n+      return build_and_insert_call (gsi, loc, cbrtfn, sqrt_arg0);\n     }\n \n   /* Optimize pow(x,c), where n = 2c for some nonzero integer n, into\n@@ -1250,17 +1247,17 @@ gimple_expand_builtin_pow (gimple_stmt_iterator *gsi, location_t loc,\n \n       /* Calculate sqrt(x).  When n is not 1 or -1, multiply it by the\n \t result of the optimal multiply sequence just calculated.  */\n-      sqrt_arg0 = build_and_insert_call (gsi, loc, &target, sqrtfn, arg0);\n+      sqrt_arg0 = build_and_insert_call (gsi, loc, sqrtfn, arg0);\n \n       if (absu_hwi (n) == 1)\n \tresult = sqrt_arg0;\n       else\n-\tresult = build_and_insert_binop (gsi, loc, target, MULT_EXPR,\n+\tresult = build_and_insert_binop (gsi, loc, \"powroot\", MULT_EXPR,\n \t\t\t\t\t sqrt_arg0, powi_x_ndiv2);\n \n       /* If n is negative, reciprocate the result.  */\n       if (n < 0)\n-\tresult = build_and_insert_binop (gsi, loc, target, RDIV_EXPR,\n+\tresult = build_and_insert_binop (gsi, loc, \"powroot\", RDIV_EXPR,\n \t\t\t\t\t build_real (type, dconst1), result);\n       return result;\n     }\n@@ -1305,24 +1302,24 @@ gimple_expand_builtin_pow (gimple_stmt_iterator *gsi, location_t loc,\n       /* Calculate powi(cbrt(x), n%3).  Don't use gimple_expand_builtin_powi\n          as that creates an unnecessary variable.  Instead, just produce\n          either cbrt(x) or cbrt(x) * cbrt(x).  */\n-      cbrt_x = build_and_insert_call (gsi, loc, &target, cbrtfn, arg0);\n+      cbrt_x = build_and_insert_call (gsi, loc, cbrtfn, arg0);\n \n       if (absu_hwi (n) % 3 == 1)\n \tpowi_cbrt_x = cbrt_x;\n       else\n-\tpowi_cbrt_x = build_and_insert_binop (gsi, loc, target, MULT_EXPR,\n+\tpowi_cbrt_x = build_and_insert_binop (gsi, loc, \"powroot\", MULT_EXPR,\n \t\t\t\t\t      cbrt_x, cbrt_x);\n \n       /* Multiply the two subexpressions, unless powi(x,abs(n)/3) = 1.  */\n       if (absu_hwi (n) < 3)\n \tresult = powi_cbrt_x;\n       else\n-\tresult = build_and_insert_binop (gsi, loc, target, MULT_EXPR,\n+\tresult = build_and_insert_binop (gsi, loc, \"powroot\", MULT_EXPR,\n \t\t\t\t\t powi_x_ndiv3, powi_cbrt_x);\n \n       /* If n is negative, reciprocate the result.  */\n       if (n < 0)\n-\tresult = build_and_insert_binop (gsi, loc, target, RDIV_EXPR, \n+\tresult = build_and_insert_binop (gsi, loc, \"powroot\", RDIV_EXPR,\n \t\t\t\t\t build_real (type, dconst1), result);\n \n       return result;\n@@ -1340,7 +1337,7 @@ gimple_expand_builtin_pow (gimple_stmt_iterator *gsi, location_t loc,\n static tree\n gimple_expand_builtin_cabs (gimple_stmt_iterator *gsi, location_t loc, tree arg)\n {\n-  tree target, real_part, imag_part, addend1, addend2, sum, result;\n+  tree real_part, imag_part, addend1, addend2, sum, result;\n   tree type = TREE_TYPE (TREE_TYPE (arg));\n   tree sqrtfn = mathfn_built_in (type, BUILT_IN_SQRT);\n   enum machine_mode mode = TYPE_MODE (type);\n@@ -1351,17 +1348,16 @@ gimple_expand_builtin_cabs (gimple_stmt_iterator *gsi, location_t loc, tree arg)\n       || optab_handler (sqrt_optab, mode) == CODE_FOR_nothing)\n     return NULL_TREE;\n \n-  target = create_tmp_reg (type, \"cabs\");\n-  real_part = build_and_insert_ref (gsi, loc, type, target,\n+  real_part = build_and_insert_ref (gsi, loc, type, \"cabs\",\n \t\t\t\t    REALPART_EXPR, arg);\n-  addend1 = build_and_insert_binop (gsi, loc, target, MULT_EXPR,\n+  addend1 = build_and_insert_binop (gsi, loc, \"cabs\", MULT_EXPR,\n \t\t\t\t    real_part, real_part);\n-  imag_part = build_and_insert_ref (gsi, loc, type, target, \n+  imag_part = build_and_insert_ref (gsi, loc, type, \"cabs\",\n \t\t\t\t    IMAGPART_EXPR, arg);\n-  addend2 = build_and_insert_binop (gsi, loc, target, MULT_EXPR,\n+  addend2 = build_and_insert_binop (gsi, loc, \"cabs\", MULT_EXPR,\n \t\t\t\t    imag_part, imag_part);\n-  sum = build_and_insert_binop (gsi, loc, target, PLUS_EXPR, addend1, addend2);\n-  result = build_and_insert_call (gsi, loc, &target, sqrtfn, sum);\n+  sum = build_and_insert_binop (gsi, loc, \"cabs\", PLUS_EXPR, addend1, addend2);\n+  result = build_and_insert_call (gsi, loc, sqrtfn, sum);\n \n   return result;\n }\n@@ -1894,12 +1890,9 @@ execute_optimize_bswap (void)\n \t  if (!useless_type_conversion_p (TREE_TYPE (bswap_tmp), bswap_type))\n \t    {\n \t      gimple convert_stmt;\n-\n-\t      bswap_tmp = create_tmp_var (bswap_type, \"bswapsrc\");\n-\t      bswap_tmp = make_ssa_name (bswap_tmp, NULL);\n-\n-\t      convert_stmt = gimple_build_assign_with_ops (\n-\t\t\t       CONVERT_EXPR, bswap_tmp, bswap_src, NULL);\n+\t      bswap_tmp = make_temp_ssa_name (bswap_type, NULL, \"bswapsrc\");\n+\t      convert_stmt = gimple_build_assign_with_ops\n+\t\t  \t\t(NOP_EXPR, bswap_tmp, bswap_src, NULL);\n \t      gsi_insert_before (&gsi, convert_stmt, GSI_SAME_STMT);\n \t    }\n \n@@ -1911,11 +1904,9 @@ execute_optimize_bswap (void)\n \t  if (!useless_type_conversion_p (TREE_TYPE (bswap_tmp), bswap_type))\n \t    {\n \t      gimple convert_stmt;\n-\n-\t      bswap_tmp = create_tmp_var (bswap_type, \"bswapdst\");\n-\t      bswap_tmp = make_ssa_name (bswap_tmp, NULL);\n-\t      convert_stmt = gimple_build_assign_with_ops (\n-\t\t               CONVERT_EXPR, gimple_assign_lhs (stmt), bswap_tmp, NULL);\n+\t      bswap_tmp = make_temp_ssa_name (bswap_type, NULL, \"bswapdst\");\n+\t      convert_stmt = gimple_build_assign_with_ops\n+\t\t\t(NOP_EXPR, gimple_assign_lhs (stmt), bswap_tmp, NULL);\n \t      gsi_insert_after (&gsi, convert_stmt, GSI_SAME_STMT);\n \t    }\n \n@@ -2092,7 +2083,7 @@ is_widening_mult_p (gimple stmt,\n static bool\n convert_mult_to_widen (gimple stmt, gimple_stmt_iterator *gsi)\n {\n-  tree lhs, rhs1, rhs2, type, type1, type2, tmp = NULL;\n+  tree lhs, rhs1, rhs2, type, type1, type2;\n   enum insn_code handler;\n   enum machine_mode to_mode, from_mode, actual_mode;\n   optab op;\n@@ -2161,22 +2152,14 @@ convert_mult_to_widen (gimple stmt, gimple_stmt_iterator *gsi)\n     return false;\n   if (actual_precision != TYPE_PRECISION (type1)\n       || from_unsigned1 != TYPE_UNSIGNED (type1))\n-    {\n-      tmp = create_tmp_var (build_nonstandard_integer_type\n-\t\t\t\t(actual_precision, from_unsigned1),\n-\t\t\t    NULL);\n-      rhs1 = build_and_insert_cast (gsi, loc, tmp, rhs1);\n-    }\n+    rhs1 = build_and_insert_cast (gsi, loc,\n+\t\t\t\t  build_nonstandard_integer_type\n+\t\t\t\t    (actual_precision, from_unsigned1), rhs1);\n   if (actual_precision != TYPE_PRECISION (type2)\n       || from_unsigned2 != TYPE_UNSIGNED (type2))\n-    {\n-      /* Reuse the same type info, if possible.  */\n-      if (!tmp || from_unsigned1 != from_unsigned2)\n-\ttmp = create_tmp_var (build_nonstandard_integer_type\n-\t\t\t\t(actual_precision, from_unsigned2),\n-\t\t\t      NULL);\n-      rhs2 = build_and_insert_cast (gsi, loc, tmp, rhs2);\n-    }\n+    rhs2 = build_and_insert_cast (gsi, loc,\n+\t\t\t\t  build_nonstandard_integer_type\n+\t\t\t\t    (actual_precision, from_unsigned2), rhs2);\n \n   /* Handle constants.  */\n   if (TREE_CODE (rhs1) == INTEGER_CST)\n@@ -2204,7 +2187,7 @@ convert_plusminus_to_widen (gimple_stmt_iterator *gsi, gimple stmt,\n {\n   gimple rhs1_stmt = NULL, rhs2_stmt = NULL;\n   gimple conv1_stmt = NULL, conv2_stmt = NULL, conv_stmt;\n-  tree type, type1, type2, optype, tmp = NULL;\n+  tree type, type1, type2, optype;\n   tree lhs, rhs1, rhs2, mult_rhs1, mult_rhs2, add_rhs;\n   enum tree_code rhs1_code = ERROR_MARK, rhs2_code = ERROR_MARK;\n   optab this_optab;\n@@ -2373,25 +2356,19 @@ convert_plusminus_to_widen (gimple_stmt_iterator *gsi, gimple stmt,\n   actual_precision = GET_MODE_PRECISION (actual_mode);\n   if (actual_precision != TYPE_PRECISION (type1)\n       || from_unsigned1 != TYPE_UNSIGNED (type1))\n-    {\n-      tmp = create_tmp_var (build_nonstandard_integer_type\n-\t\t\t\t(actual_precision, from_unsigned1),\n-\t\t\t    NULL);\n-      mult_rhs1 = build_and_insert_cast (gsi, loc, tmp, mult_rhs1);\n-    }\n+    mult_rhs1 = build_and_insert_cast (gsi, loc,\n+\t\t\t\t       build_nonstandard_integer_type\n+\t\t\t\t         (actual_precision, from_unsigned1),\n+\t\t\t\t       mult_rhs1);\n   if (actual_precision != TYPE_PRECISION (type2)\n       || from_unsigned2 != TYPE_UNSIGNED (type2))\n-    {\n-      if (!tmp || from_unsigned1 != from_unsigned2)\n-\ttmp = create_tmp_var (build_nonstandard_integer_type\n-\t\t\t\t(actual_precision, from_unsigned2),\n-\t\t\t      NULL);\n-      mult_rhs2 = build_and_insert_cast (gsi, loc, tmp, mult_rhs2);\n-    }\n+    mult_rhs2 = build_and_insert_cast (gsi, loc,\n+\t\t\t\t       build_nonstandard_integer_type\n+\t\t\t\t\t (actual_precision, from_unsigned2),\n+\t\t\t\t       mult_rhs2);\n \n   if (!useless_type_conversion_p (type, TREE_TYPE (add_rhs)))\n-    add_rhs = build_and_insert_cast (gsi, loc, create_tmp_var (type, NULL),\n-\t\t\t\t     add_rhs);\n+    add_rhs = build_and_insert_cast (gsi, loc, type, add_rhs);\n \n   /* Handle constants.  */\n   if (TREE_CODE (mult_rhs1) == INTEGER_CST)"}, {"sha": "05166eb8c902a34254b279d17e571b2465ec48a6", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 17, "deletions": 38, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=83d5977e2f4747bbd33cc00a807e239d0b740895", "patch": "@@ -272,10 +272,6 @@ single_non_singleton_phi_for_edges (gimple_seq seq, edge e0, edge e1)\n   return phi;\n }\n \n-/* For conditional store replacement we need a temporary to\n-   put the old contents of the memory in.  */\n-static tree condstoretemp;\n-\n /* The core routine of conditional store replacement and normal\n    phi optimizations.  Both share much of the infrastructure in how\n    to match applicable basic block patterns.  DO_STORE_ELIM is true\n@@ -292,11 +288,8 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads)\n   struct pointer_set_t *nontrap = 0;\n \n   if (do_store_elim)\n-    {\n-      condstoretemp = NULL_TREE;\n-      /* Calculate the set of non-trapping memory accesses.  */\n-      nontrap = get_non_trapping ();\n-    }\n+    /* Calculate the set of non-trapping memory accesses.  */\n+    nontrap = get_non_trapping ();\n \n   /* Search every basic block for COND_EXPR we may be able to optimize.\n \n@@ -690,11 +683,9 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n     {\n       source_location locus_0, locus_1;\n \n-      new_var2 = create_tmp_var (TREE_TYPE (result), NULL);\n+      new_var2 = make_ssa_name (TREE_TYPE (result), NULL);\n       new_stmt = gimple_build_assign_with_ops (CONVERT_EXPR, new_var2,\n \t\t\t\t\t       new_var, NULL);\n-      new_var2 = make_ssa_name (new_var2, new_stmt);\n-      gimple_assign_set_lhs (new_stmt, new_var2);\n       gsi_insert_before (&gsi, new_stmt, GSI_SAME_STMT);\n       new_var = new_var2;\n \n@@ -1212,10 +1203,7 @@ abs_replacement (basic_block cond_bb, basic_block middle_bb,\n   result = duplicate_ssa_name (result, NULL);\n \n   if (negate)\n-    {\n-      tree tmp = create_tmp_var (TREE_TYPE (result), NULL);\n-      lhs = make_ssa_name (tmp, NULL);\n-    }\n+    lhs = make_ssa_name (TREE_TYPE (result), NULL);\n   else\n     lhs = result;\n \n@@ -1445,7 +1433,7 @@ cond_store_replacement (basic_block middle_bb, basic_block join_bb,\n \t\t\tedge e0, edge e1, struct pointer_set_t *nontrap)\n {\n   gimple assign = last_and_only_stmt (middle_bb);\n-  tree lhs, rhs, name;\n+  tree lhs, rhs, name, name2;\n   gimple newphi, new_stmt;\n   gimple_stmt_iterator gsi;\n   source_location locus;\n@@ -1476,31 +1464,26 @@ cond_store_replacement (basic_block middle_bb, basic_block join_bb,\n   gsi_remove (&gsi, true);\n   release_defs (assign);\n \n-  /* 2) Create a temporary where we can store the old content\n-        of the memory touched by the store, if we need to.  */\n-  if (!condstoretemp || TREE_TYPE (lhs) != TREE_TYPE (condstoretemp))\n-    condstoretemp = create_tmp_reg (TREE_TYPE (lhs), \"cstore\");\n-\n-  /* 3) Insert a load from the memory of the store to the temporary\n+  /* 2) Insert a load from the memory of the store to the temporary\n         on the edge which did not contain the store.  */\n   lhs = unshare_expr (lhs);\n-  new_stmt = gimple_build_assign (condstoretemp, lhs);\n-  name = make_ssa_name (condstoretemp, new_stmt);\n-  gimple_assign_set_lhs (new_stmt, name);\n+  name = make_temp_ssa_name (TREE_TYPE (lhs), NULL, \"cstore\");\n+  new_stmt = gimple_build_assign (name, lhs);\n   gimple_set_location (new_stmt, locus);\n   gsi_insert_on_edge (e1, new_stmt);\n \n-  /* 4) Create a PHI node at the join block, with one argument\n+  /* 3) Create a PHI node at the join block, with one argument\n         holding the old RHS, and the other holding the temporary\n         where we stored the old memory contents.  */\n-  newphi = create_phi_node (condstoretemp, join_bb);\n+  name2 = make_temp_ssa_name (TREE_TYPE (lhs), NULL, \"cstore\");\n+  newphi = create_phi_node (name2, join_bb);\n   add_phi_arg (newphi, rhs, e0, locus);\n   add_phi_arg (newphi, name, e1, locus);\n \n   lhs = unshare_expr (lhs);\n   new_stmt = gimple_build_assign (lhs, PHI_RESULT (newphi));\n \n-  /* 5) Insert that PHI node.  */\n+  /* 4) Insert that PHI node.  */\n   gsi = gsi_after_labels (join_bb);\n   if (gsi_end_p (gsi))\n     {\n@@ -1520,7 +1503,7 @@ cond_if_else_store_replacement_1 (basic_block then_bb, basic_block else_bb,\n \t\t\t\t  basic_block join_bb, gimple then_assign,\n \t\t\t\t  gimple else_assign)\n {\n-  tree lhs_base, lhs, then_rhs, else_rhs;\n+  tree lhs_base, lhs, then_rhs, else_rhs, name;\n   source_location then_locus, else_locus;\n   gimple_stmt_iterator gsi;\n   gimple newphi, new_stmt;\n@@ -1560,21 +1543,17 @@ cond_if_else_store_replacement_1 (basic_block then_bb, basic_block else_bb,\n   gsi_remove (&gsi, true);\n   release_defs (else_assign);\n \n-  /* 2) Create a temporary where we can store the old content\n-\tof the memory touched by the store, if we need to.  */\n-  if (!condstoretemp || TREE_TYPE (lhs) != TREE_TYPE (condstoretemp))\n-    condstoretemp = create_tmp_reg (TREE_TYPE (lhs), \"cstore\");\n-\n-  /* 3) Create a PHI node at the join block, with one argument\n+  /* 2) Create a PHI node at the join block, with one argument\n \tholding the old RHS, and the other holding the temporary\n \twhere we stored the old memory contents.  */\n-  newphi = create_phi_node (condstoretemp, join_bb);\n+  name = make_temp_ssa_name (TREE_TYPE (lhs), NULL, \"cstore\");\n+  newphi = create_phi_node (name, join_bb);\n   add_phi_arg (newphi, then_rhs, EDGE_SUCC (then_bb, 0), then_locus);\n   add_phi_arg (newphi, else_rhs, EDGE_SUCC (else_bb, 0), else_locus);\n \n   new_stmt = gimple_build_assign (lhs, PHI_RESULT (newphi));\n \n-  /* 4) Insert that PHI node.  */\n+  /* 3) Insert that PHI node.  */\n   gsi = gsi_after_labels (join_bb);\n   if (gsi_end_p (gsi))\n     {"}, {"sha": "2f0b3bb9b83e2113c22c3913ffa55f3f5287a58e", "filename": "gcc/tree-ssa-phiprop.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-ssa-phiprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-ssa-phiprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiprop.c?ref=83d5977e2f4747bbd33cc00a807e239d0b740895", "patch": "@@ -186,7 +186,7 @@ phiprop_insert_phi (basic_block bb, gimple phi, gimple use_stmt,\n \t{\n \t  tree rhs = gimple_assign_rhs1 (use_stmt);\n \t  gcc_assert (TREE_CODE (old_arg) == ADDR_EXPR);\n-\t  new_var = create_tmp_reg (TREE_TYPE (rhs), NULL);\n+\t  new_var = make_ssa_name (TREE_TYPE (rhs), NULL);\n \t  if (!is_gimple_min_invariant (old_arg))\n \t    old_arg = PHI_ARG_DEF_FROM_EDGE (phi, e);\n \t  else\n@@ -195,9 +195,6 @@ phiprop_insert_phi (basic_block bb, gimple phi, gimple use_stmt,\n \t\t\t\t     fold_build2 (MEM_REF, TREE_TYPE (rhs),\n \t\t\t\t\t\t  old_arg,\n \t\t\t\t\t\t  TREE_OPERAND (rhs, 1)));\n-\t  gcc_assert (is_gimple_reg (new_var));\n-\t  new_var = make_ssa_name (new_var, tmp);\n-\t  gimple_assign_set_lhs (tmp, new_var);\n \t  gimple_set_location (tmp, locus);\n \n \t  gsi_insert_on_edge (e, tmp);"}, {"sha": "6264b54eebd5eda705c039469dbe78d3eaefa09d", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 5, "deletions": 44, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=83d5977e2f4747bbd33cc00a807e239d0b740895", "patch": "@@ -472,14 +472,6 @@ static unsigned int get_expr_value_id (pre_expr);\n static alloc_pool bitmap_set_pool;\n static bitmap_obstack grand_bitmap_obstack;\n \n-/* To avoid adding 300 temporary variables when we only need one, we\n-   only create one temporary variable, on demand, and build ssa names\n-   off that.  We do have to change the variable if the types don't\n-   match the current variable's type.  */\n-static tree pretemp;\n-static tree storetemp;\n-static tree prephitemp;\n-\n /* Set of blocks with statements that have had their EH properties changed.  */\n static bitmap need_eh_cleanup;\n \n@@ -1366,7 +1358,6 @@ get_expr_type (const pre_expr e)\n static tree\n get_representative_for (const pre_expr e)\n {\n-  tree exprtype;\n   tree name;\n   unsigned int value_id = get_expr_value_id (e);\n \n@@ -1406,14 +1397,9 @@ get_representative_for (const pre_expr e)\n       fprintf (dump_file, \"\\n\");\n     }\n \n-  exprtype = get_expr_type (e);\n-\n   /* Build and insert the assignment of the end result to the temporary\n      that we will return.  */\n-  if (!pretemp || exprtype != TREE_TYPE (pretemp))\n-    pretemp = create_tmp_reg (exprtype, \"pretmp\");\n-\n-  name = make_ssa_name (pretemp, gimple_build_nop ());\n+  name = make_temp_ssa_name (get_expr_type (e), gimple_build_nop (), \"pretmp\");\n   VN_INFO_GET (name)->value_id = value_id;\n   if (e->kind == CONSTANT)\n     VN_INFO (name)->valnum = PRE_EXPR_CONSTANT (e);\n@@ -2602,11 +2588,6 @@ can_PRE_operation (tree op)\n    that didn't turn out to be necessary.   */\n static bitmap inserted_exprs;\n \n-/* Pool allocated fake store expressions are placed onto this\n-   worklist, which, after performing dead code elimination, is walked\n-   to see which expressions need to be put into GC'able memory  */\n-static VEC(gimple, heap) *need_creation;\n-\n /* The actual worker for create_component_ref_by_pieces.  */\n \n static tree\n@@ -2983,7 +2964,7 @@ static tree\n create_expression_by_pieces (basic_block block, pre_expr expr,\n \t\t\t     gimple_seq *stmts, gimple domstmt, tree type)\n {\n-  tree temp, name;\n+  tree name;\n   tree folded;\n   gimple_seq forced_stmts = NULL;\n   unsigned int value_id;\n@@ -3101,16 +3082,8 @@ create_expression_by_pieces (basic_block block, pre_expr expr,\n       gimple_seq_add_seq (stmts, forced_stmts);\n     }\n \n-  /* Build and insert the assignment of the end result to the temporary\n-     that we will return.  */\n-  if (!pretemp || exprtype != TREE_TYPE (pretemp))\n-    pretemp = create_tmp_reg (exprtype, \"pretmp\");\n-\n-  temp = pretemp;\n-\n-  newstmt = gimple_build_assign (temp, folded);\n-  name = make_ssa_name (temp, newstmt);\n-  gimple_assign_set_lhs (newstmt, name);\n+  name = make_temp_ssa_name (exprtype, NULL, \"pretmp\");\n+  newstmt = gimple_build_assign (name, folded);\n   gimple_set_plf (newstmt, NECESSARY, false);\n \n   gimple_seq_add_stmt (stmts, newstmt);\n@@ -3361,14 +3334,7 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n     return false;\n \n   /* Now build a phi for the new variable.  */\n-  if (!prephitemp || TREE_TYPE (prephitemp) != type)\n-    prephitemp = create_tmp_var (type, \"prephitmp\");\n-\n-  temp = prephitemp;\n-\n-  if (TREE_CODE (type) == COMPLEX_TYPE\n-      || TREE_CODE (type) == VECTOR_TYPE)\n-    DECL_GIMPLE_REG_P (temp) = 1;\n+  temp = make_temp_ssa_name (type, NULL, \"prephitmp\");\n   phi = create_phi_node (temp, block);\n \n   gimple_set_plf (phi, NECESSARY, false);\n@@ -4809,10 +4775,6 @@ init_pre (bool do_fre)\n   in_fre = do_fre;\n \n   inserted_exprs = BITMAP_ALLOC (NULL);\n-  need_creation = NULL;\n-  pretemp = NULL_TREE;\n-  storetemp = NULL_TREE;\n-  prephitemp = NULL_TREE;\n \n   connect_infinite_loops_to_exit ();\n   memset (&pre_stats, 0, sizeof (pre_stats));\n@@ -4860,7 +4822,6 @@ fini_pre (bool do_fre)\n   free (postorder);\n   VEC_free (bitmap_set_t, heap, value_expressions);\n   BITMAP_FREE (inserted_exprs);\n-  VEC_free (gimple, heap, need_creation);\n   bitmap_obstack_release (&grand_bitmap_obstack);\n   free_alloc_pool (bitmap_set_pool);\n   free_alloc_pool (pre_expr_pool);"}, {"sha": "f5643b619a988748ae1b3c63e1db0fa442848552", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=83d5977e2f4747bbd33cc00a807e239d0b740895", "patch": "@@ -791,11 +791,11 @@ update_call_from_tree (gimple_stmt_iterator *si_p, tree expr)\n              variable.  Create an assignment statement\n              with a dummy (unused) lhs variable.  */\n           STRIP_USELESS_TYPE_CONVERSION (expr);\n-          lhs = create_tmp_var (TREE_TYPE (expr), NULL);\n-          new_stmt = gimple_build_assign (lhs, expr);\n \t  if (gimple_in_ssa_p (cfun))\n-\t    lhs = make_ssa_name (lhs, new_stmt);\n-          gimple_assign_set_lhs (new_stmt, lhs);\n+\t    lhs = make_ssa_name (TREE_TYPE (expr), NULL);\n+\t  else\n+\t    lhs = create_tmp_var (TREE_TYPE (expr), NULL);\n+          new_stmt = gimple_build_assign (lhs, expr);\n \t  gimple_set_vuse (new_stmt, gimple_vuse (stmt));\n \t  gimple_set_vdef (new_stmt, gimple_vdef (stmt));\n           move_ssa_defining_stmt_for_defs (new_stmt, stmt);"}, {"sha": "233ecce59bd2a6b9653b6ed360aee52f16c2b955", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 17, "deletions": 38, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=83d5977e2f4747bbd33cc00a807e239d0b740895", "patch": "@@ -1147,17 +1147,16 @@ zero_one_operation (tree *def, enum tree_code opcode, tree op)\n    OP1 or OP2.  Returns the new statement.  */\n \n static gimple\n-build_and_add_sum (tree tmpvar, tree op1, tree op2, enum tree_code opcode)\n+build_and_add_sum (tree type, tree op1, tree op2, enum tree_code opcode)\n {\n   gimple op1def = NULL, op2def = NULL;\n   gimple_stmt_iterator gsi;\n   tree op;\n   gimple sum;\n \n   /* Create the addition statement.  */\n-  sum = gimple_build_assign_with_ops (opcode, tmpvar, op1, op2);\n-  op = make_ssa_name (tmpvar, sum);\n-  gimple_assign_set_lhs (sum, op);\n+  op = make_ssa_name (type, NULL);\n+  sum = gimple_build_assign_with_ops (opcode, op, op1, op2);\n \n   /* Find an insertion place and insert.  */\n   if (TREE_CODE (op1) == SSA_NAME)\n@@ -1421,7 +1420,6 @@ undistribute_ops_list (enum tree_code opcode,\n       if (nr_candidates2 >= 2)\n \t{\n \t  operand_entry_t oe1, oe2;\n-\t  tree tmpvar;\n \t  gimple prod;\n \t  int first = sbitmap_first_set_bit (candidates2);\n \n@@ -1432,7 +1430,6 @@ undistribute_ops_list (enum tree_code opcode,\n \t      fprintf (dump_file, \"Building (\");\n \t      print_generic_expr (dump_file, oe1->op, 0);\n \t    }\n-\t  tmpvar = create_tmp_reg (TREE_TYPE (oe1->op), NULL);\n \t  zero_one_operation (&oe1->op, c->oecode, c->op);\n \t  EXECUTE_IF_SET_IN_SBITMAP (candidates2, first+1, i, sbi0)\n \t    {\n@@ -1444,14 +1441,16 @@ undistribute_ops_list (enum tree_code opcode,\n \t\t  print_generic_expr (dump_file, oe2->op, 0);\n \t\t}\n \t      zero_one_operation (&oe2->op, c->oecode, c->op);\n-\t      sum = build_and_add_sum (tmpvar, oe1->op, oe2->op, opcode);\n+\t      sum = build_and_add_sum (TREE_TYPE (oe1->op),\n+\t\t\t\t       oe1->op, oe2->op, opcode);\n \t      oe2->op = build_zero_cst (TREE_TYPE (oe2->op));\n \t      oe2->rank = 0;\n \t      oe1->op = gimple_get_lhs (sum);\n \t    }\n \n \t  /* Apply the multiplication/division.  */\n-\t  prod = build_and_add_sum (tmpvar, oe1->op, c->op, c->oecode);\n+\t  prod = build_and_add_sum (TREE_TYPE (oe1->op),\n+\t\t\t\t    oe1->op, c->op, c->oecode);\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n \t      fprintf (dump_file, \") %s \", c->oecode == MULT_EXPR ? \"*\" : \"/\");\n@@ -1590,19 +1589,17 @@ eliminate_redundant_comparison (enum tree_code opcode,\n \t}\n       else if (!operand_equal_p (t, curr->op, 0))\n \t{\n-\t  tree tmpvar;\n \t  gimple sum;\n \t  enum tree_code subcode;\n \t  tree newop1;\n \t  tree newop2;\n \t  gcc_assert (COMPARISON_CLASS_P (t));\n-\t  tmpvar = create_tmp_var (TREE_TYPE (t), NULL);\n \t  extract_ops_from_tree (t, &subcode, &newop1, &newop2);\n \t  STRIP_USELESS_TYPE_CONVERSION (newop1);\n \t  STRIP_USELESS_TYPE_CONVERSION (newop2);\n \t  gcc_checking_assert (is_gimple_val (newop1)\n \t\t\t       && is_gimple_val (newop2));\n-\t  sum = build_and_add_sum (tmpvar, newop1, newop2, subcode);\n+\t  sum = build_and_add_sum (TREE_TYPE (t), newop1, newop2, subcode);\n \t  curr->op = gimple_get_lhs (sum);\n \t}\n       return true;\n@@ -2442,7 +2439,6 @@ rewrite_expr_tree_parallel (gimple stmt, int width,\n   int ready_stmts_end = 0;\n   int i = 0;\n   tree last_rhs1 = gimple_assign_rhs1 (stmt);\n-  tree lhs_var;\n \n   /* We start expression rewriting from the top statements.\n      So, in this loop we create a full list of statements\n@@ -2451,8 +2447,6 @@ rewrite_expr_tree_parallel (gimple stmt, int width,\n   for (i = stmt_num - 2; i >= 0; i--)\n     stmts[i] = SSA_NAME_DEF_STMT (gimple_assign_rhs1 (stmts[i+1]));\n \n-  lhs_var = create_tmp_reg (TREE_TYPE (last_rhs1), NULL);\n-\n   for (i = 0; i < stmt_num; i++)\n     {\n       tree op1, op2;\n@@ -2511,7 +2505,7 @@ rewrite_expr_tree_parallel (gimple stmt, int width,\n \t  update_stmt (stmts[i]);\n \t}\n       else\n-\tstmts[i] = build_and_add_sum (lhs_var, op1, op2, opcode);\n+\tstmts[i] = build_and_add_sum (TREE_TYPE (last_rhs1), op1, op2, opcode);\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n@@ -3075,27 +3069,13 @@ compare_repeat_factors (const void *x1, const void *x2)\n   return rf2->rank - rf1->rank;\n }\n \n-/* Get a new SSA name for register variable *TARGET of type TYPE.\n-   If *TARGET is null or incompatible with TYPE, create the variable\n-   first.  */\n-\n-static tree\n-get_reassoc_pow_ssa_name (tree *target, tree type)\n-{\n-  if (!*target || !types_compatible_p (type, TREE_TYPE (*target)))\n-    *target = create_tmp_reg (type, \"reassocpow\");\n-\n-  return make_ssa_name (*target, NULL);\n-}\n-\n /* Look for repeated operands in OPS in the multiply tree rooted at\n    STMT.  Replace them with an optimal sequence of multiplies and powi\n    builtin calls, and remove the used operands from OPS.  Return an\n    SSA name representing the value of the replacement sequence.  */\n \n static tree\n-attempt_builtin_powi (gimple stmt, VEC(operand_entry_t, heap) **ops,\n-\t\t      tree *target)\n+attempt_builtin_powi (gimple stmt, VEC(operand_entry_t, heap) **ops)\n {\n   unsigned i, j, vec_len;\n   int ii;\n@@ -3220,7 +3200,7 @@ attempt_builtin_powi (gimple stmt, VEC(operand_entry_t, heap) **ops,\n \t    }\n \t  else\n \t    {\n-\t      iter_result = get_reassoc_pow_ssa_name (target, type);\n+\t      iter_result = make_temp_ssa_name (type, NULL, \"reassocpow\");\n \t      pow_stmt = gimple_build_call (powi_fndecl, 2, rf1->repr, \n \t\t\t\t\t    build_int_cst (integer_type_node,\n \t\t\t\t\t\t\t   power));\n@@ -3305,7 +3285,7 @@ attempt_builtin_powi (gimple stmt, VEC(operand_entry_t, heap) **ops,\n \t\t  op1 = rf1->factor;\n \t\t  op2 = rf2->repr;\n \n-\t\t  target_ssa = get_reassoc_pow_ssa_name (target, type);\n+\t\t  target_ssa = make_temp_ssa_name (type, NULL, \"reassocpow\");\n \t\t  mul_stmt = gimple_build_assign_with_ops (MULT_EXPR,\n \t\t\t\t\t\t\t   target_ssa,\n \t\t\t\t\t\t\t   op1, op2);\n@@ -3321,7 +3301,7 @@ attempt_builtin_powi (gimple stmt, VEC(operand_entry_t, heap) **ops,\n \t  /* Form a call to __builtin_powi for the maximum product\n \t     just formed, raised to the power obtained earlier.  */\n \t  rf1 = VEC_index (repeat_factor, repeat_factor_vec, j);\n-\t  iter_result = get_reassoc_pow_ssa_name (target, type);\n+\t  iter_result = make_temp_ssa_name (type, NULL, \"reassocpow\");\n \t  pow_stmt = gimple_build_call (powi_fndecl, 2, rf1->repr, \n \t\t\t\t\tbuild_int_cst (integer_type_node,\n \t\t\t\t\t\t       power));\n@@ -3334,7 +3314,7 @@ attempt_builtin_powi (gimple stmt, VEC(operand_entry_t, heap) **ops,\n \t form the product of this one and those others.  */\n       if (result)\n \t{\n-\t  tree new_result = get_reassoc_pow_ssa_name (target, type);\n+\t  tree new_result = make_temp_ssa_name (type, NULL, \"reassocpow\");\n \t  mul_stmt = gimple_build_assign_with_ops (MULT_EXPR, new_result,\n \t\t\t\t\t\t   result, iter_result);\n \t  gimple_set_location (mul_stmt, gimple_location (stmt));\n@@ -3447,7 +3427,6 @@ reassociate_bb (basic_block bb)\n {\n   gimple_stmt_iterator gsi;\n   basic_block son;\n-  tree target = NULL_TREE;\n \n   for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi); gsi_prev (&gsi))\n     {\n@@ -3533,7 +3512,7 @@ reassociate_bb (basic_block bb)\n \t      if (first_pass_instance\n \t\t  && rhs_code == MULT_EXPR\n \t\t  && flag_unsafe_math_optimizations)\n-\t\tpowi_result = attempt_builtin_powi (stmt, &ops, &target);\n+\t\tpowi_result = attempt_builtin_powi (stmt, &ops);\n \n \t      /* If the operand vector is now empty, all operands were \n \t\t consumed by the __builtin_powi optimization.  */\n@@ -3572,8 +3551,8 @@ reassociate_bb (basic_block bb)\n \t\t    {\n \t\t      gimple mul_stmt;\n \t\t      tree type = TREE_TYPE (gimple_get_lhs (stmt));\n-\t\t      tree target_ssa = get_reassoc_pow_ssa_name (&target,\n-\t\t\t\t\t\t\t\t  type);\n+\t\t      tree target_ssa = make_temp_ssa_name (type, NULL,\n+\t\t\t\t\t\t\t    \"reassocpow\");\n \t\t      gimple_set_lhs (stmt, target_ssa);\n \t\t      update_stmt (stmt);\n \t\t      mul_stmt = gimple_build_assign_with_ops (MULT_EXPR, lhs,"}, {"sha": "3a60a0a1ba0e0059943b1c0d862ebfc18f9f7044", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=83d5977e2f4747bbd33cc00a807e239d0b740895", "patch": "@@ -393,7 +393,7 @@ get_string_length (strinfo si)\n   if (si->stmt)\n     {\n       gimple stmt = si->stmt, lenstmt;\n-      tree callee, lhs, lhs_var, fn, tem;\n+      tree callee, lhs, fn, tem;\n       location_t loc;\n       gimple_stmt_iterator gsi;\n \n@@ -415,15 +415,12 @@ get_string_length (strinfo si)\n \t  gsi = gsi_for_stmt (stmt);\n \t  fn = builtin_decl_implicit (BUILT_IN_STRLEN);\n \t  gcc_assert (lhs == NULL_TREE);\n-\t  lhs_var = create_tmp_var (TREE_TYPE (TREE_TYPE (fn)), NULL);\n \t  tem = unshare_expr (gimple_call_arg (stmt, 0));\n \t  lenstmt = gimple_build_call (fn, 1, tem);\n-\t  lhs = make_ssa_name (lhs_var, lenstmt);\n+\t  lhs = make_ssa_name (TREE_TYPE (TREE_TYPE (fn)), lenstmt);\n \t  gimple_call_set_lhs (lenstmt, lhs);\n \t  gimple_set_vuse (lenstmt, gimple_vuse (stmt));\n \t  gsi_insert_before (&gsi, lenstmt, GSI_SAME_STMT);\n-\t  lhs_var = create_tmp_var (TREE_TYPE (gimple_call_arg (stmt, 0)),\n-\t\t\t\t    NULL);\n \t  tem = gimple_call_arg (stmt, 0);\n           if (!ptrofftype_p (TREE_TYPE (lhs)))\n             {\n@@ -432,9 +429,10 @@ get_string_length (strinfo si)\n                                               true, GSI_SAME_STMT);\n             }\n \t  lenstmt\n-\t    = gimple_build_assign_with_ops (POINTER_PLUS_EXPR,\n-\t\t\t\t\t    make_ssa_name (lhs_var, NULL),\n-\t\t\t\t\t    tem, lhs);\n+\t    = gimple_build_assign_with_ops\n+\t        (POINTER_PLUS_EXPR,\n+\t\t make_ssa_name (TREE_TYPE (gimple_call_arg (stmt, 0)), NULL),\n+\t\t tem, lhs);\n \t  gsi_insert_before (&gsi, lenstmt, GSI_SAME_STMT);\n \t  gimple_call_set_arg (stmt, 0, gimple_assign_lhs (lenstmt));\n \t  lhs = NULL_TREE;\n@@ -452,8 +450,7 @@ get_string_length (strinfo si)\n \t      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n \t    }\n \t  gimple_call_set_fndecl (stmt, fn);\n-\t  lhs_var = create_tmp_var (TREE_TYPE (TREE_TYPE (fn)), NULL);\n-\t  lhs = make_ssa_name (lhs_var, stmt);\n+\t  lhs = make_ssa_name (TREE_TYPE (TREE_TYPE (fn)), stmt);\n \t  gimple_call_set_lhs (stmt, lhs);\n \t  update_stmt (stmt);\n \t  if (dump_file && (dump_flags & TDF_DETAILS) != 0)"}, {"sha": "df88ddf77e80f9c56db5b684df3424410902b577", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=83d5977e2f4747bbd33cc00a807e239d0b740895", "patch": "@@ -424,15 +424,13 @@ emit_case_bit_tests (gimple swtch, tree index_expr,\n     }\n \n   /* csui = (1 << (word_mode) idx) */\n-  tmp = create_tmp_var (word_type_node, \"csui\");\n-  csui = make_ssa_name (tmp, NULL);\n+  csui = make_ssa_name (word_type_node, NULL);\n   tmp = fold_build2 (LSHIFT_EXPR, word_type_node, word_mode_one,\n \t\t     fold_convert (word_type_node, idx));\n   tmp = force_gimple_operand_gsi (&gsi, tmp,\n \t\t\t\t  /*simple=*/false, NULL_TREE,\n \t\t\t\t  /*before=*/true, GSI_SAME_STMT);\n   shift_stmt = gimple_build_assign (csui, tmp);\n-  SSA_NAME_DEF_STMT (csui) = shift_stmt;\n   gsi_insert_before (&gsi, shift_stmt, GSI_SAME_STMT);\n   update_stmt (shift_stmt);\n \n@@ -1090,7 +1088,7 @@ static void\n build_arrays (gimple swtch, struct switch_conv_info *info)\n {\n   tree arr_index_type;\n-  tree tidx, sub, tmp, utype;\n+  tree tidx, sub, utype;\n   gimple stmt;\n   gimple_stmt_iterator gsi;\n   int i;\n@@ -1106,15 +1104,13 @@ build_arrays (gimple swtch, struct switch_conv_info *info)\n     utype = lang_hooks.types.type_for_mode (TYPE_MODE (utype), 1);\n \n   arr_index_type = build_index_type (info->range_size);\n-  tmp = create_tmp_var (utype, \"csui\");\n-  tidx = make_ssa_name (tmp, NULL);\n+  tidx = make_ssa_name (utype, NULL);\n   sub = fold_build2_loc (loc, MINUS_EXPR, utype,\n \t\t\t fold_convert_loc (loc, utype, info->index_expr),\n \t\t\t fold_convert_loc (loc, utype, info->range_min));\n   sub = force_gimple_operand_gsi (&gsi, sub,\n \t\t\t\t  false, NULL, true, GSI_SAME_STMT);\n   stmt = gimple_build_assign (tidx, sub);\n-  SSA_NAME_DEF_STMT (tidx) = stmt;\n \n   gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n   update_stmt (stmt);"}, {"sha": "7ee00a2a319ba310267b0e4a30767d00458964a1", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=83d5977e2f4747bbd33cc00a807e239d0b740895", "patch": "@@ -609,12 +609,11 @@ adjust_return_value_with_ops (enum tree_code code, const char *label,\n {\n \n   tree ret_type = TREE_TYPE (DECL_RESULT (current_function_decl));\n-  tree tmp = create_tmp_reg (ret_type, label);\n+  tree result = make_temp_ssa_name (ret_type, NULL, label);\n   gimple stmt;\n-  tree result;\n \n   if (types_compatible_p (TREE_TYPE (acc), TREE_TYPE (op1)))\n-    stmt = gimple_build_assign_with_ops (code, tmp, acc, op1);\n+    stmt = gimple_build_assign_with_ops (code, result, acc, op1);\n   else\n     {\n       tree rhs = fold_convert (TREE_TYPE (acc),\n@@ -624,12 +623,9 @@ adjust_return_value_with_ops (enum tree_code code, const char *label,\n \t\t\t\t\t    op1));\n       rhs = force_gimple_operand_gsi (&gsi, rhs,\n \t\t\t\t      false, NULL, true, GSI_CONTINUE_LINKING);\n-      stmt = gimple_build_assign (NULL_TREE, rhs);\n+      stmt = gimple_build_assign (result, rhs);\n     }\n \n-  result = make_ssa_name (tmp, stmt);\n-  gimple_assign_set_lhs (stmt, result);\n-  update_stmt (stmt);\n   gsi_insert_before (&gsi, stmt, GSI_NEW_STMT);\n   return result;\n }\n@@ -904,7 +900,7 @@ static tree\n create_tailcall_accumulator (const char *label, basic_block bb, tree init)\n {\n   tree ret_type = TREE_TYPE (DECL_RESULT (current_function_decl));\n-  tree tmp = create_tmp_reg (ret_type, label);\n+  tree tmp = make_temp_ssa_name (ret_type, NULL, label);\n   gimple phi;\n \n   phi = create_phi_node (tmp, bb);"}, {"sha": "6a02986cc80069a79a0a6bb3deae17f0c7436727", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=83d5977e2f4747bbd33cc00a807e239d0b740895", "patch": "@@ -4129,7 +4129,7 @@ vect_permute_store_chain (VEC(tree,heap) *dr_chain,\n \t\t\t  gimple_stmt_iterator *gsi,\n \t\t\t  VEC(tree,heap) **result_chain)\n {\n-  tree perm_dest, vect1, vect2, high, low;\n+  tree vect1, vect2, high, low;\n   gimple perm_stmt;\n   tree vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt));\n   tree perm_mask_low, perm_mask_high;\n@@ -4161,8 +4161,7 @@ vect_permute_store_chain (VEC(tree,heap) *dr_chain,\n \n \t  /* Create interleaving stmt:\n \t     high = VEC_PERM_EXPR <vect1, vect2, {0, nelt, 1, nelt+1, ...}>  */\n-\t  perm_dest = create_tmp_reg (vectype, \"vect_inter_high\");\n-\t  high = make_ssa_name (perm_dest, NULL);\n+\t  high = make_temp_ssa_name (vectype, NULL, \"vect_inter_high\");\n \t  perm_stmt\n \t    = gimple_build_assign_with_ops3 (VEC_PERM_EXPR, high,\n \t\t\t\t\t     vect1, vect2, perm_mask_high);\n@@ -4172,8 +4171,7 @@ vect_permute_store_chain (VEC(tree,heap) *dr_chain,\n \t  /* Create interleaving stmt:\n \t     low = VEC_PERM_EXPR <vect1, vect2, {nelt/2, nelt*3/2, nelt/2+1,\n \t\t\t\t\t\t nelt*3/2+1, ...}>  */\n-\t  perm_dest = create_tmp_reg (vectype, \"vect_inter_low\");\n-\t  low = make_ssa_name (perm_dest, NULL);\n+\t  low = make_temp_ssa_name (vectype, NULL, \"vect_inter_low\");\n \t  perm_stmt\n \t    = gimple_build_assign_with_ops3 (VEC_PERM_EXPR, low,\n \t\t\t\t\t     vect1, vect2, perm_mask_low);\n@@ -4584,7 +4582,7 @@ vect_permute_load_chain (VEC(tree,heap) *dr_chain,\n \t\t\t gimple_stmt_iterator *gsi,\n \t\t\t VEC(tree,heap) **result_chain)\n {\n-  tree perm_dest, data_ref, first_vect, second_vect;\n+  tree data_ref, first_vect, second_vect;\n   tree perm_mask_even, perm_mask_odd;\n   gimple perm_stmt;\n   tree vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt));\n@@ -4612,29 +4610,19 @@ vect_permute_load_chain (VEC(tree,heap) *dr_chain,\n \t  second_vect = VEC_index (tree, dr_chain, j+1);\n \n \t  /* data_ref = permute_even (first_data_ref, second_data_ref);  */\n-\t  perm_dest = create_tmp_reg (vectype, \"vect_perm_even\");\n-\n-\t  perm_stmt = gimple_build_assign_with_ops3 (VEC_PERM_EXPR, perm_dest,\n+\t  data_ref = make_temp_ssa_name (vectype, NULL, \"vect_perm_even\");\n+\t  perm_stmt = gimple_build_assign_with_ops3 (VEC_PERM_EXPR, data_ref,\n \t\t\t\t\t\t     first_vect, second_vect,\n \t\t\t\t\t\t     perm_mask_even);\n-\n-\t  data_ref = make_ssa_name (perm_dest, perm_stmt);\n-\t  gimple_assign_set_lhs (perm_stmt, data_ref);\n \t  vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n-\n \t  VEC_replace (tree, *result_chain, j/2, data_ref);\n \n \t  /* data_ref = permute_odd (first_data_ref, second_data_ref);  */\n-\t  perm_dest = create_tmp_reg (vectype, \"vect_perm_odd\");\n-\n-\t  perm_stmt = gimple_build_assign_with_ops3 (VEC_PERM_EXPR, perm_dest,\n+\t  data_ref = make_temp_ssa_name (vectype, NULL, \"vect_perm_odd\");\n+\t  perm_stmt = gimple_build_assign_with_ops3 (VEC_PERM_EXPR, data_ref,\n \t\t\t\t\t\t     first_vect, second_vect,\n \t\t\t\t\t\t     perm_mask_odd);\n-\n-\t  data_ref = make_ssa_name (perm_dest, perm_stmt);\n-\t  gimple_assign_set_lhs (perm_stmt, data_ref);\n \t  vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n-\n \t  VEC_replace (tree, *result_chain, j/2+length/2, data_ref);\n \t}\n       dr_chain = VEC_copy (tree, heap, *result_chain);"}, {"sha": "5b583124cab2c0a6d34670626f9536f99fe00aea", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=83d5977e2f4747bbd33cc00a807e239d0b740895", "patch": "@@ -667,8 +667,7 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n \t\t\t\t\t((unsigned HOST_WIDE_INT) 1\n \t\t\t\t\t << shifts[i]) - 1);\n \t      cst = build_vector (type, vec);\n-\t      addend = create_tmp_reg (type, NULL);\n-\t      addend = make_ssa_name (addend, NULL);\n+\t      addend = make_ssa_name (type, NULL);\n \t      stmt = gimple_build_assign_with_ops3 (VEC_COND_EXPR, addend,\n \t\t\t\t\t\t    cond, cst, zero);\n \t      gsi_insert_before (gsi, stmt, GSI_SAME_STMT);"}, {"sha": "e0b68c71cfadf0fb0ad7738293ab713ed702120f", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=83d5977e2f4747bbd33cc00a807e239d0b740895", "patch": "@@ -2207,7 +2207,7 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n   tree int_ptrsize_type;\n   char tmp_name[20];\n   tree or_tmp_name = NULL_TREE;\n-  tree and_tmp, and_tmp_name;\n+  tree and_tmp_name;\n   gimple and_stmt;\n   tree ptrsize_zero;\n   tree part_cond_expr;\n@@ -2225,8 +2225,8 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n     {\n       gimple_seq new_stmt_list = NULL;\n       tree addr_base;\n-      tree addr_tmp, addr_tmp_name;\n-      tree or_tmp, new_or_tmp_name;\n+      tree addr_tmp_name;\n+      tree new_or_tmp_name;\n       gimple addr_stmt, or_stmt;\n       stmt_vec_info stmt_vinfo = vinfo_for_stmt (ref_stmt);\n       tree vectype = STMT_VINFO_VECTYPE (stmt_vinfo);\n@@ -2242,26 +2242,22 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n       if (new_stmt_list != NULL)\n \tgimple_seq_add_seq (cond_expr_stmt_list, new_stmt_list);\n \n-      sprintf (tmp_name, \"%s%d\", \"addr2int\", i);\n-      addr_tmp = create_tmp_reg (int_ptrsize_type, tmp_name);\n-      addr_tmp_name = make_ssa_name (addr_tmp, NULL);\n+      sprintf (tmp_name, \"addr2int%d\", i);\n+      addr_tmp_name = make_temp_ssa_name (int_ptrsize_type, NULL, tmp_name);\n       addr_stmt = gimple_build_assign_with_ops (NOP_EXPR, addr_tmp_name,\n \t\t\t\t\t\taddr_base, NULL_TREE);\n-      SSA_NAME_DEF_STMT (addr_tmp_name) = addr_stmt;\n       gimple_seq_add_stmt (cond_expr_stmt_list, addr_stmt);\n \n       /* The addresses are OR together.  */\n \n       if (or_tmp_name != NULL_TREE)\n         {\n           /* create: or_tmp = or_tmp | addr_tmp */\n-          sprintf (tmp_name, \"%s%d\", \"orptrs\", i);\n-          or_tmp = create_tmp_reg (int_ptrsize_type, tmp_name);\n-\t  new_or_tmp_name = make_ssa_name (or_tmp, NULL);\n+          sprintf (tmp_name, \"orptrs%d\", i);\n+\t  new_or_tmp_name = make_temp_ssa_name (int_ptrsize_type, NULL, tmp_name);\n \t  or_stmt = gimple_build_assign_with_ops (BIT_IOR_EXPR,\n \t\t\t\t\t\t  new_or_tmp_name,\n \t\t\t\t\t\t  or_tmp_name, addr_tmp_name);\n-          SSA_NAME_DEF_STMT (new_or_tmp_name) = or_stmt;\n \t  gimple_seq_add_stmt (cond_expr_stmt_list, or_stmt);\n           or_tmp_name = new_or_tmp_name;\n         }\n@@ -2273,12 +2269,10 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n   mask_cst = build_int_cst (int_ptrsize_type, mask);\n \n   /* create: and_tmp = or_tmp & mask  */\n-  and_tmp = create_tmp_reg (int_ptrsize_type, \"andmask\" );\n-  and_tmp_name = make_ssa_name (and_tmp, NULL);\n+  and_tmp_name = make_temp_ssa_name (int_ptrsize_type, NULL, \"andmask\");\n \n   and_stmt = gimple_build_assign_with_ops (BIT_AND_EXPR, and_tmp_name,\n \t\t\t\t\t   or_tmp_name, mask_cst);\n-  SSA_NAME_DEF_STMT (and_tmp_name) = and_stmt;\n   gimple_seq_add_stmt (cond_expr_stmt_list, and_stmt);\n \n   /* Make and_tmp the left operand of the conditional test against zero."}, {"sha": "1b78a54c42e952ab9bc526e06d1bffca918b40af", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=83d5977e2f4747bbd33cc00a807e239d0b740895", "patch": "@@ -206,9 +206,7 @@ type_conversion_p (tree name, gimple use_stmt, bool check_sign,\n static tree\n vect_recog_temp_ssa_var (tree type, gimple stmt)\n {\n-  tree var = create_tmp_reg (type, \"patt\");\n-  var = make_ssa_name (var, stmt);\n-  return var;\n+  return make_temp_ssa_name (type, stmt, \"patt\");\n }\n \n /* Function vect_recog_dot_prod_pattern\n@@ -450,7 +448,7 @@ vect_handle_widen_op_by_const (gimple stmt, enum tree_code code,\n    \t\t               VEC (gimple, heap) **stmts, tree type,\n \t\t\t       tree *half_type, gimple def_stmt)\n {\n-  tree new_type, new_oprnd, tmp;\n+  tree new_type, new_oprnd;\n   gimple new_stmt;\n \n   if (code != MULT_EXPR && code != LSHIFT_EXPR)\n@@ -499,8 +497,7 @@ vect_handle_widen_op_by_const (gimple stmt, enum tree_code code,\n     {\n       /* Create a_T = (NEW_TYPE) a_t;  */\n       *oprnd = gimple_assign_rhs1 (def_stmt);\n-      tmp = create_tmp_reg (new_type, NULL);\n-      new_oprnd = make_ssa_name (tmp, NULL);\n+      new_oprnd = make_ssa_name (new_type, NULL);\n       new_stmt = gimple_build_assign_with_ops (NOP_EXPR, new_oprnd, *oprnd,\n \t\t\t\t\t       NULL_TREE);\n       STMT_VINFO_RELATED_STMT (vinfo_for_stmt (def_stmt)) = new_stmt;\n@@ -962,7 +959,7 @@ vect_operation_fits_smaller_type (gimple stmt, tree def, tree *new_type,\n {\n   enum tree_code code;\n   tree const_oprnd, oprnd;\n-  tree interm_type = NULL_TREE, half_type, tmp, new_oprnd, type;\n+  tree interm_type = NULL_TREE, half_type, new_oprnd, type;\n   gimple def_stmt, new_stmt;\n   bool first = false;\n   bool promotion;\n@@ -1103,8 +1100,7 @@ vect_operation_fits_smaller_type (gimple stmt, tree def, tree *new_type,\n             {\n               /* Create NEW_OPRND = (INTERM_TYPE) OPRND.  */\n               oprnd = gimple_assign_rhs1 (def_stmt);\n-              tmp = create_tmp_reg (interm_type, NULL);\n-              new_oprnd = make_ssa_name (tmp, NULL);\n+              new_oprnd = make_ssa_name (interm_type, NULL);\n               new_stmt = gimple_build_assign_with_ops (NOP_EXPR, new_oprnd,\n                                                        oprnd, NULL_TREE);\n               STMT_VINFO_RELATED_STMT (vinfo_for_stmt (def_stmt)) = new_stmt;\n@@ -1123,8 +1119,7 @@ vect_operation_fits_smaller_type (gimple stmt, tree def, tree *new_type,\n       if (interm_type)\n         {\n           /* Create a type conversion HALF_TYPE->INTERM_TYPE.  */\n-          tmp = create_tmp_reg (interm_type, NULL);\n-          new_oprnd = make_ssa_name (tmp, NULL);\n+          new_oprnd = make_ssa_name (interm_type, NULL);\n           new_stmt = gimple_build_assign_with_ops (NOP_EXPR, new_oprnd,\n                                                    oprnd, NULL_TREE);\n           oprnd = new_oprnd;\n@@ -1171,7 +1166,7 @@ vect_recog_over_widening_pattern (VEC (gimple, heap) **stmts,\n   gimple stmt = VEC_pop (gimple, *stmts);\n   gimple pattern_stmt = NULL, new_def_stmt, prev_stmt = NULL, use_stmt = NULL;\n   tree op0, op1, vectype = NULL_TREE, use_lhs, use_type;\n-  tree var = NULL_TREE, new_type = NULL_TREE, tmp, new_oprnd;\n+  tree var = NULL_TREE, new_type = NULL_TREE, new_oprnd;\n   bool first;\n   tree type = NULL;\n \n@@ -1254,8 +1249,7 @@ vect_recog_over_widening_pattern (VEC (gimple, heap) **stmts,\n           || TYPE_PRECISION (new_type) != TYPE_PRECISION (use_type))\n         {\n           /* Create NEW_TYPE->USE_TYPE conversion.  */\n-          tmp = create_tmp_reg (use_type, NULL);\n-          new_oprnd = make_ssa_name (tmp, NULL);\n+          new_oprnd = make_ssa_name (use_type, NULL);\n           pattern_stmt = gimple_build_assign_with_ops (NOP_EXPR, new_oprnd,\n                                                        var, NULL_TREE);\n           STMT_VINFO_RELATED_STMT (vinfo_for_stmt (use_stmt)) = pattern_stmt;"}, {"sha": "491b2391f88265dea9c930d2c60dc36ab2bcf173", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=83d5977e2f4747bbd33cc00a807e239d0b740895", "patch": "@@ -1270,12 +1270,10 @@ vect_init_vector (gimple stmt, tree val, tree type, gimple_stmt_iterator *gsi)\n \t    val = fold_unary (VIEW_CONVERT_EXPR, TREE_TYPE (type), val);\n \t  else\n \t    {\n-\t      new_var = create_tmp_reg (TREE_TYPE (type), NULL);\n+\t      new_temp = make_ssa_name (TREE_TYPE (type), NULL);\n \t      init_stmt = gimple_build_assign_with_ops (NOP_EXPR,\n-\t\t\t\t\t\t\tnew_var, val,\n+\t\t\t\t\t\t\tnew_temp, val,\n \t\t\t\t\t\t\tNULL_TREE);\n-\t      new_temp = make_ssa_name (new_var, init_stmt);\n-\t      gimple_assign_set_lhs (init_stmt, new_temp);\n \t      vect_init_vector_1 (stmt, init_stmt, gsi);\n \t      val = new_temp;\n \t    }"}, {"sha": "eb6402bd281d2b15ff12a0b0bbe85f197d6c54c2", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=83d5977e2f4747bbd33cc00a807e239d0b740895", "patch": "@@ -8042,13 +8042,9 @@ simplify_truth_ops_using_ranges (gimple_stmt_iterator *gsi, gimple stmt)\n   /* For A != B we substitute A ^ B.  Either with conversion.  */\n   else if (need_conversion)\n     {\n-      gimple newop;\n-      tree tem = create_tmp_reg (TREE_TYPE (op0), NULL);\n-      newop = gimple_build_assign_with_ops (BIT_XOR_EXPR, tem, op0, op1);\n-      tem = make_ssa_name (tem, newop);\n-      gimple_assign_set_lhs (newop, tem);\n+      tree tem = make_ssa_name (TREE_TYPE (op0), NULL);\n+      gimple newop = gimple_build_assign_with_ops (BIT_XOR_EXPR, tem, op0, op1);\n       gsi_insert_before (gsi, newop, GSI_SAME_STMT);\n-      update_stmt (newop);\n       gimple_assign_set_rhs_with_ops (gsi, NOP_EXPR, tem, NULL_TREE);\n     }\n   /* Or without.  */\n@@ -8707,11 +8703,9 @@ simplify_float_conversion_using_ranges (gimple_stmt_iterator *gsi, gimple stmt)\n \n   /* It works, insert a truncation or sign-change before the\n      float conversion.  */\n-  tem = create_tmp_var (build_nonstandard_integer_type\n+  tem = make_ssa_name (build_nonstandard_integer_type\n \t\t\t  (GET_MODE_PRECISION (mode), 0), NULL);\n   conv = gimple_build_assign_with_ops (NOP_EXPR, tem, rhs1, NULL_TREE);\n-  tem = make_ssa_name (tem, conv);\n-  gimple_assign_set_lhs (conv, tem);\n   gsi_insert_before (gsi, conv, GSI_SAME_STMT);\n   gimple_assign_set_rhs1 (stmt, tem);\n   update_stmt (stmt);"}, {"sha": "e210881289e043f13f03da98fc83d9b7424921fc", "filename": "gcc/value-prof.c", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d5977e2f4747bbd33cc00a807e239d0b740895/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=83d5977e2f4747bbd33cc00a807e239d0b740895", "patch": "@@ -592,7 +592,7 @@ gimple_divmod_fixed_value (gimple stmt, tree value, int prob, gcov_type count,\n \t\t\t   gcov_type all)\n {\n   gimple stmt1, stmt2, stmt3;\n-  tree tmp0, tmp1, tmp2, tmpv;\n+  tree tmp0, tmp1, tmp2;\n   gimple bb1end, bb2end, bb3end;\n   basic_block bb, bb2, bb3, bb4;\n   tree optype, op1, op2;\n@@ -610,13 +610,10 @@ gimple_divmod_fixed_value (gimple stmt, tree value, int prob, gcov_type count,\n   bb = gimple_bb (stmt);\n   gsi = gsi_for_stmt (stmt);\n \n-  tmpv = create_tmp_reg (optype, \"PROF\");\n-  tmp0 = make_ssa_name (tmpv, NULL);\n-  tmp1 = make_ssa_name (tmpv, NULL);\n+  tmp0 = make_temp_ssa_name (optype, NULL, \"PROF\");\n+  tmp1 = make_temp_ssa_name (optype, NULL, \"PROF\");\n   stmt1 = gimple_build_assign (tmp0, fold_convert (optype, value));\n-  SSA_NAME_DEF_STMT (tmp0) = stmt1;\n   stmt2 = gimple_build_assign (tmp1, op2);\n-  SSA_NAME_DEF_STMT (tmp1) = stmt2;\n   stmt3 = gimple_build_cond (NE_EXPR, tmp1, tmp0, NULL_TREE, NULL_TREE);\n   gsi_insert_before (&gsi, stmt1, GSI_SAME_STMT);\n   gsi_insert_before (&gsi, stmt2, GSI_SAME_STMT);\n@@ -749,7 +746,7 @@ static tree\n gimple_mod_pow2 (gimple stmt, int prob, gcov_type count, gcov_type all)\n {\n   gimple stmt1, stmt2, stmt3, stmt4;\n-  tree tmp2, tmp3, tmpv;\n+  tree tmp2, tmp3;\n   gimple bb1end, bb2end, bb3end;\n   basic_block bb, bb2, bb3, bb4;\n   tree optype, op1, op2;\n@@ -768,14 +765,11 @@ gimple_mod_pow2 (gimple stmt, int prob, gcov_type count, gcov_type all)\n   gsi = gsi_for_stmt (stmt);\n \n   result = create_tmp_reg (optype, \"PROF\");\n-  tmpv = create_tmp_var (optype, \"PROF\");\n-  tmp2 = make_ssa_name (tmpv, NULL);\n-  tmp3 = make_ssa_name (tmpv, NULL);\n+  tmp2 = make_temp_ssa_name (optype, NULL, \"PROF\");\n+  tmp3 = make_temp_ssa_name (optype, NULL, \"PROF\");\n   stmt2 = gimple_build_assign_with_ops (PLUS_EXPR, tmp2, op2,\n \t\t\t\t\tbuild_int_cst (optype, -1));\n-  SSA_NAME_DEF_STMT (tmp2) = stmt2;\n   stmt3 = gimple_build_assign_with_ops (BIT_AND_EXPR, tmp3, tmp2, op2);\n-  SSA_NAME_DEF_STMT (tmp3) = stmt3;\n   stmt4 = gimple_build_cond (NE_EXPR, tmp3, build_int_cst (optype, 0),\n \t\t\t     NULL_TREE, NULL_TREE);\n   gsi_insert_before (&gsi, stmt2, GSI_SAME_STMT);\n@@ -924,10 +918,9 @@ gimple_mod_subtract (gimple stmt, int prob1, int prob2, int ncounts,\n   gsi = gsi_for_stmt (stmt);\n \n   result = create_tmp_reg (optype, \"PROF\");\n-  tmp1 = make_ssa_name (create_tmp_var (optype, \"PROF\"), NULL);\n+  tmp1 = make_temp_ssa_name (optype, NULL, \"PROF\");\n   stmt1 = gimple_build_assign (result, op1);\n   stmt2 = gimple_build_assign (tmp1, op2);\n-  SSA_NAME_DEF_STMT (tmp1) = stmt2;\n   stmt3 = gimple_build_cond (LT_EXPR, result, tmp1, NULL_TREE, NULL_TREE);\n   gsi_insert_before (&gsi, stmt1, GSI_SAME_STMT);\n   gsi_insert_before (&gsi, stmt2, GSI_SAME_STMT);\n@@ -1176,7 +1169,7 @@ gimple_ic (gimple icall_stmt, struct cgraph_node *direct_call,\n \t   int prob, gcov_type count, gcov_type all)\n {\n   gimple dcall_stmt, load_stmt, cond_stmt;\n-  tree tmp0, tmp1, tmpv, tmp;\n+  tree tmp0, tmp1, tmp;\n   basic_block cond_bb, dcall_bb, icall_bb, join_bb = NULL;\n   tree optype = build_pointer_type (void_type_node);\n   edge e_cd, e_ci, e_di, e_dj = NULL, e_ij;\n@@ -1186,18 +1179,15 @@ gimple_ic (gimple icall_stmt, struct cgraph_node *direct_call,\n   cond_bb = gimple_bb (icall_stmt);\n   gsi = gsi_for_stmt (icall_stmt);\n \n-  tmpv = create_tmp_reg (optype, \"PROF\");\n-  tmp0 = make_ssa_name (tmpv, NULL);\n-  tmp1 = make_ssa_name (tmpv, NULL);\n+  tmp0 = make_temp_ssa_name (optype, NULL, \"PROF\");\n+  tmp1 = make_temp_ssa_name (optype, NULL, \"PROF\");\n   tmp = unshare_expr (gimple_call_fn (icall_stmt));\n   load_stmt = gimple_build_assign (tmp0, tmp);\n-  SSA_NAME_DEF_STMT (tmp0) = load_stmt;\n   gsi_insert_before (&gsi, load_stmt, GSI_SAME_STMT);\n \n   tmp = fold_convert (optype, build_addr (direct_call->symbol.decl,\n \t\t\t\t\t  current_function_decl));\n   load_stmt = gimple_build_assign (tmp1, tmp);\n-  SSA_NAME_DEF_STMT (tmp1) = load_stmt;\n   gsi_insert_before (&gsi, load_stmt, GSI_SAME_STMT);\n \n   cond_stmt = gimple_build_cond (EQ_EXPR, tmp1, tmp0, NULL_TREE, NULL_TREE);\n@@ -1431,7 +1421,7 @@ gimple_stringop_fixed_value (gimple vcall_stmt, tree icall_size, int prob,\n \t\t\t     gcov_type count, gcov_type all)\n {\n   gimple tmp_stmt, cond_stmt, icall_stmt;\n-  tree tmp0, tmp1, tmpv, vcall_size, optype;\n+  tree tmp0, tmp1, vcall_size, optype;\n   basic_block cond_bb, icall_bb, vcall_bb, join_bb;\n   edge e_ci, e_cv, e_iv, e_ij, e_vj;\n   gimple_stmt_iterator gsi;\n@@ -1448,15 +1438,12 @@ gimple_stringop_fixed_value (gimple vcall_stmt, tree icall_size, int prob,\n   vcall_size = gimple_call_arg (vcall_stmt, size_arg);\n   optype = TREE_TYPE (vcall_size);\n \n-  tmpv = create_tmp_var (optype, \"PROF\");\n-  tmp0 = make_ssa_name (tmpv, NULL);\n-  tmp1 = make_ssa_name (tmpv, NULL);\n+  tmp0 = make_temp_ssa_name (optype, NULL, \"PROF\");\n+  tmp1 = make_temp_ssa_name (optype, NULL, \"PROF\");\n   tmp_stmt = gimple_build_assign (tmp0, fold_convert (optype, icall_size));\n-  SSA_NAME_DEF_STMT (tmp0) = tmp_stmt;\n   gsi_insert_before (&gsi, tmp_stmt, GSI_SAME_STMT);\n \n   tmp_stmt = gimple_build_assign (tmp1, vcall_size);\n-  SSA_NAME_DEF_STMT (tmp1) = tmp_stmt;\n   gsi_insert_before (&gsi, tmp_stmt, GSI_SAME_STMT);\n \n   cond_stmt = gimple_build_cond (EQ_EXPR, tmp1, tmp0, NULL_TREE, NULL_TREE);"}]}