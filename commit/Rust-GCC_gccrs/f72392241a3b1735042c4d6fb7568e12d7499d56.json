{"sha": "f72392241a3b1735042c4d6fb7568e12d7499d56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjcyMzkyMjQxYTNiMTczNTA0MmM0ZDZmYjc1NjhlMTJkNzQ5OWQ1Ng==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2005-05-07T19:05:33Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2005-05-07T19:05:33Z"}, "message": "integrate.c (get_func_hard_reg_initial_val): Delete.\n\n\t* integrate.c (get_func_hard_reg_initial_val): Delete.\n\t(has_func_hard_reg_initial_val): Delete.\n\t(get_hard_reg_initial_val): Inline the old implementation of\n\tget_func_hard_reg_initial_val.  Use has_hard_reg_initial_val\n\tinstead of has_func_hard_reg_initial_val to test for an existing\n\tpseudo.  Only create an rtx if a new initial value entry is needed.\n\t(has_hard_reg_initial_val): Scan the initial value list directly.\n\tDon't create an rtx.\n\nFrom-SVN: r99358", "tree": {"sha": "4df2128d211b7cc40648dfe699517223c78bf880", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4df2128d211b7cc40648dfe699517223c78bf880"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f72392241a3b1735042c4d6fb7568e12d7499d56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f72392241a3b1735042c4d6fb7568e12d7499d56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f72392241a3b1735042c4d6fb7568e12d7499d56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f72392241a3b1735042c4d6fb7568e12d7499d56/comments", "author": null, "committer": null, "parents": [{"sha": "c1630cc5dc135d34a91cf62fc7ee57fb68295556", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1630cc5dc135d34a91cf62fc7ee57fb68295556", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1630cc5dc135d34a91cf62fc7ee57fb68295556"}], "stats": {"total": 68, "additions": 38, "deletions": 30}, "files": [{"sha": "98daa946567508dfe95d534b2b6e85931adae532", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72392241a3b1735042c4d6fb7568e12d7499d56/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72392241a3b1735042c4d6fb7568e12d7499d56/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f72392241a3b1735042c4d6fb7568e12d7499d56", "patch": "@@ -1,3 +1,14 @@\n+2005-05-07  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* integrate.c (get_func_hard_reg_initial_val): Delete.\n+\t(has_func_hard_reg_initial_val): Delete.\n+\t(get_hard_reg_initial_val): Inline the old implementation of\n+\tget_func_hard_reg_initial_val.  Use has_hard_reg_initial_val\n+\tinstead of has_func_hard_reg_initial_val to test for an existing\n+\tpseudo.  Only create an rtx if a new initial value entry is needed.\n+\t(has_hard_reg_initial_val): Scan the initial value list directly.\n+\tDon't create an rtx.\n+\n 2005-05-07  David Edelsohn  <edelsohn@gnu.org>\n \n \t* config.gcc ({powerpc,rs6000}-ibm-aix*): Remove rs6000/aix.opt"}, {"sha": "6987fcccec2cd4c9df1948539030df45da47bfcf", "filename": "gcc/integrate.c", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72392241a3b1735042c4d6fb7568e12d7499d56/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72392241a3b1735042c4d6fb7568e12d7499d56/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=f72392241a3b1735042c4d6fb7568e12d7499d56", "patch": "@@ -50,7 +50,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define CEIL_ROUND(VALUE,ALIGN)\t(((VALUE) + (ALIGN) - 1) & ~((ALIGN)- 1))\n \f\n \n-/* Private type used by {get/has}_func_hard_reg_initial_val.  */\n+/* Private type used by {get/has}_hard_reg_initial_val.  */\n typedef struct initial_value_pair GTY(()) {\n   rtx hard_reg;\n   rtx pseudo;\n@@ -293,38 +293,27 @@ get_hard_reg_initial_reg (struct function *fun, rtx reg)\n   return NULL_RTX;\n }\n \n-static rtx\n-has_func_hard_reg_initial_val (struct function *fun, rtx reg)\n-{\n-  struct initial_value_struct *ivs = fun->hard_reg_initial_vals;\n-  int i;\n-\n-  if (ivs == 0)\n-    return NULL_RTX;\n-\n-  for (i = 0; i < ivs->num_entries; i++)\n-    if (rtx_equal_p (ivs->entries[i].hard_reg, reg))\n-      return ivs->entries[i].pseudo;\n-\n-  return NULL_RTX;\n-}\n+/* Make sure that there's a pseudo register of mode MODE that stores the\n+   initial value of hard register REGNO.  Return an rtx for such a pseudo.  */\n \n-static rtx\n-get_func_hard_reg_initial_val (struct function *fun, rtx reg)\n+rtx\n+get_hard_reg_initial_val (enum machine_mode mode, int regno)\n {\n-  struct initial_value_struct *ivs = fun->hard_reg_initial_vals;\n-  rtx rv = has_func_hard_reg_initial_val (fun, reg);\n+  struct initial_value_struct *ivs;\n+  rtx rv;\n \n+  rv = has_hard_reg_initial_val (mode, regno);\n   if (rv)\n     return rv;\n \n+  ivs = cfun->hard_reg_initial_vals;\n   if (ivs == 0)\n     {\n-      fun->hard_reg_initial_vals = ggc_alloc (sizeof (initial_value_struct));\n-      ivs = fun->hard_reg_initial_vals;\n+      ivs = ggc_alloc (sizeof (initial_value_struct));\n       ivs->num_entries = 0;\n       ivs->max_entries = 5;\n       ivs->entries = ggc_alloc (5 * sizeof (initial_value_pair));\n+      cfun->hard_reg_initial_vals = ivs;\n     }\n \n   if (ivs->num_entries >= ivs->max_entries)\n@@ -335,22 +324,30 @@ get_func_hard_reg_initial_val (struct function *fun, rtx reg)\n \t\t\t\t  * sizeof (initial_value_pair));\n     }\n \n-  ivs->entries[ivs->num_entries].hard_reg = reg;\n-  ivs->entries[ivs->num_entries].pseudo = gen_reg_rtx (GET_MODE (reg));\n+  ivs->entries[ivs->num_entries].hard_reg = gen_rtx_REG (mode, regno);\n+  ivs->entries[ivs->num_entries].pseudo = gen_reg_rtx (mode);\n \n   return ivs->entries[ivs->num_entries++].pseudo;\n }\n \n-rtx\n-get_hard_reg_initial_val (enum machine_mode mode, int regno)\n-{\n-  return get_func_hard_reg_initial_val (cfun, gen_rtx_REG (mode, regno));\n-}\n+/* See if get_hard_reg_initial_val has been used to create a pseudo\n+   for the initial value of hard register REGNO in mode MODE.  Return\n+   the associated pseudo if so, otherwise return NULL.  */\n \n rtx\n has_hard_reg_initial_val (enum machine_mode mode, int regno)\n {\n-  return has_func_hard_reg_initial_val (cfun, gen_rtx_REG (mode, regno));\n+  struct initial_value_struct *ivs;\n+  int i;\n+\n+  ivs = cfun->hard_reg_initial_vals;\n+  if (ivs != 0)\n+    for (i = 0; i < ivs->num_entries; i++)\n+      if (GET_MODE (ivs->entries[i].hard_reg) == mode\n+\t  && REGNO (ivs->entries[i].hard_reg) == (unsigned int) regno)\n+\treturn ivs->entries[i].pseudo;\n+\n+  return NULL_RTX;\n }\n \n void"}]}