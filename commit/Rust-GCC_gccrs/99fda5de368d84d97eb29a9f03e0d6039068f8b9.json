{"sha": "99fda5de368d84d97eb29a9f03e0d6039068f8b9", "node_id": "C_kwDOANBUbNoAKDk5ZmRhNWRlMzY4ZDg0ZDk3ZWIyOWE5ZjAzZTBkNjAzOTA2OGY4Yjk", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2023-01-25T21:26:39Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2023-01-31T14:56:27Z"}, "message": "Properly set GORI relation trios.\n\nWhen relation trios were added to GORI, there was only one use.  As they are\nutilized more by range-ops, it is apparent that the implelemtation was\nnot complete.  This patch fleshes it out completely so that every GORI\noperation has a complete relation trio.\n\n\t* gimple-range-gori.cc (gori_compute::compute_operand_range): Do\n\tnot abort calculations if there is a valid relation available.\n\t(gori_compute::refine_using_relation): Pass correct relation trio.\n\t(gori_compute::compute_operand1_range): Create trio and use it.\n\t(gori_compute::compute_operand2_range): Ditto.\n\t* range-op.cc (operator_plus::op1_range): Use correct trio member.\n\t(operator_minus::op1_range): Use correct trio member.\n\t* value-relation.cc (value_relation::create_trio): New.\n\t* value-relation.h (value_relation::create_trio): New prototype.", "tree": {"sha": "8cd99fab7a800094f52a5d860454b126779c9549", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8cd99fab7a800094f52a5d860454b126779c9549"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99fda5de368d84d97eb29a9f03e0d6039068f8b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99fda5de368d84d97eb29a9f03e0d6039068f8b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99fda5de368d84d97eb29a9f03e0d6039068f8b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99fda5de368d84d97eb29a9f03e0d6039068f8b9/comments", "author": null, "committer": null, "parents": [{"sha": "7f583a335769591d016caa51490e3e5dd50354fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f583a335769591d016caa51490e3e5dd50354fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f583a335769591d016caa51490e3e5dd50354fe"}], "stats": {"total": 109, "additions": 62, "deletions": 47}, "files": [{"sha": "3dc4576ff13a4561d16c023c65bee65090b3bfd6", "filename": "gcc/gimple-range-gori.cc", "status": "modified", "additions": 25, "deletions": 45, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fda5de368d84d97eb29a9f03e0d6039068f8b9/gcc%2Fgimple-range-gori.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fda5de368d84d97eb29a9f03e0d6039068f8b9/gcc%2Fgimple-range-gori.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.cc?ref=99fda5de368d84d97eb29a9f03e0d6039068f8b9", "patch": "@@ -632,6 +632,9 @@ gori_compute::compute_operand_range (vrange &r, gimple *stmt,\n   if (op1 && op2)\n     {\n       relation_kind k = handler.op1_op2_relation (lhs);\n+      // If there is no relation, and op1 == op2, create a relation.\n+      if (!vrel_ptr && k == VREL_VARYING && op1 == op2)\n+\tk = VREL_EQ;\n       if (k != VREL_VARYING)\n        {\n \t vrel.set_relation (k, op1, op2);\n@@ -952,7 +955,9 @@ gori_compute::refine_using_relation (tree op1, vrange &op1_range,\n {\n   gcc_checking_assert (TREE_CODE (op1) == SSA_NAME);\n   gcc_checking_assert (TREE_CODE (op2) == SSA_NAME);\n-  gcc_checking_assert (k != VREL_VARYING && k != VREL_UNDEFINED);\n+\n+  if (k == VREL_VARYING || k == VREL_EQ || k == VREL_UNDEFINED)\n+    return false;\n \n   bool change = false;\n   bool op1_def_p = in_chain_p (op2, op1);\n@@ -991,7 +996,7 @@ gori_compute::refine_using_relation (tree op1, vrange &op1_range,\n       Value_Range new_result (type);\n       if (!op_handler.op1_range (new_result, type,\n \t\t\t\t op1_def_p ? op1_range : op2_range,\n-\t\t\t\t other_op, relation_trio::lhs_op2 (k)))\n+\t\t\t\t other_op, relation_trio::lhs_op1 (k)))\n \treturn false;\n       if (op1_def_p)\n \t{\n@@ -1023,7 +1028,7 @@ gori_compute::refine_using_relation (tree op1, vrange &op1_range,\n       Value_Range new_result (type);\n       if (!op_handler.op2_range (new_result, type,\n \t\t\t\t op1_def_p ? op1_range : op2_range,\n-\t\t\t\t other_op, relation_trio::lhs_op1 (k)))\n+\t\t\t\t other_op, relation_trio::lhs_op2 (k)))\n \treturn false;\n       if (op1_def_p)\n \t{\n@@ -1062,6 +1067,10 @@ gori_compute::compute_operand1_range (vrange &r,\n   tree op2 = handler.operand2 ();\n   tree lhs_name = gimple_get_lhs (stmt);\n \n+  relation_trio trio;\n+  if (rel)\n+    trio = rel->create_trio (lhs_name, op1, op2);\n+\n   Value_Range op1_range (TREE_TYPE (op1));\n   Value_Range tmp (TREE_TYPE (op1));\n   Value_Range op2_range (op2 ? TREE_TYPE (op2) : TREE_TYPE (op1));\n@@ -1073,35 +1082,19 @@ gori_compute::compute_operand1_range (vrange &r,\n   if (op2)\n     {\n       src.get_operand (op2_range, op2);\n-      relation_kind k = VREL_VARYING;\n-      relation_kind op_op = (op1 == op2) ? VREL_EQ : VREL_VARYING;\n-      if (rel)\n-\t{\n-\t if (lhs_name == rel->op1 () && op1 == rel->op2 ())\n-\t   k = rel->kind ();\n-\t else if (lhs_name == rel->op2 () && op1 == rel->op1 ())\n-\t   k = relation_swap (rel->kind ());\n-\t else if (op1 == rel->op1 () && op2 == rel->op2 ())\n-\t   {\n-\t     op_op = rel->kind ();\n-\t     refine_using_relation (op1, op1_range, op2, op2_range, src, op_op);\n-\t   }\n-\t else if (op1 == rel->op2 () && op2 == rel->op1 ())\n-\t   {\n-\t     op_op = relation_swap (rel->kind ());\n-\t     refine_using_relation (op1, op1_range, op2, op2_range, src, op_op);\n-\t   }\n-       }\n-      if (!handler.calc_op1 (tmp, lhs, op2_range, relation_trio (VREL_VARYING,\n-\t\t\t\t\t\t\t\t k, op_op)))\n+      relation_kind op_op = trio.op1_op2 ();\n+      if (op_op != VREL_VARYING)\n+\trefine_using_relation (op1, op1_range, op2, op2_range, src, op_op);\n+\n+      if (!handler.calc_op1 (tmp, lhs, op2_range, trio))\n \treturn false;\n     }\n   else\n     {\n       // We pass op1_range to the unary operation.  Nomally it's a\n       // hidden range_for_type parameter, but sometimes having the\n       // actual range can result in better information.\n-      if (!handler.calc_op1 (tmp, lhs, op1_range, TRIO_VARYING))\n+      if (!handler.calc_op1 (tmp, lhs, op1_range, trio))\n \treturn false;\n     }\n \n@@ -1172,29 +1165,16 @@ gori_compute::compute_operand2_range (vrange &r,\n \n   src.get_operand (op1_range, op1);\n   src.get_operand (op2_range, op2);\n-  relation_kind k = VREL_VARYING;\n-  relation_kind op_op = (op1 == op2) ? VREL_EQ : VREL_VARYING;\n+\n+  relation_trio trio;\n   if (rel)\n-    {\n-      if (lhs_name == rel->op1 () && op2 == rel->op2 ())\n-\tk = rel->kind ();\n-      else if (lhs_name == rel->op2 () && op2 == rel->op1 ())\n-\tk = relation_swap (rel->kind ());\n-      else if (op1 == rel->op1 () && op2 == rel->op2 ())\n-\t{\n-\t  op_op = rel->kind ();\n-\t  refine_using_relation (op1, op1_range, op2, op2_range, src, op_op);\n-\t}\n-      else if (op1 == rel->op2 () && op2 == rel->op1 ())\n-\t{\n-\t  op_op = relation_swap (rel->kind ());\n-\t  refine_using_relation (op1, op1_range, op2, op2_range, src, op_op);\n-\t}\n-    }\n+    trio = rel->create_trio (lhs_name, op1, op2);\n+  relation_kind op_op = trio.op1_op2 ();\n+  if (op_op != VREL_VARYING)\n+    refine_using_relation (op1, op1_range, op2, op2_range, src, op_op);\n \n   // Intersect with range for op2 based on lhs and op1.\n-  if (!handler.calc_op2 (tmp, lhs, op1_range, relation_trio (k, VREL_VARYING,\n-\t\t\t\t\t\t\t     op_op)))\n+  if (!handler.calc_op2 (tmp, lhs, op1_range, trio))\n     return false;\n \n   unsigned idx;"}, {"sha": "ed2dd1eb99c8d04fb0d71ee73ba7c14a25f5d7c8", "filename": "gcc/range-op.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fda5de368d84d97eb29a9f03e0d6039068f8b9/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fda5de368d84d97eb29a9f03e0d6039068f8b9/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=99fda5de368d84d97eb29a9f03e0d6039068f8b9", "patch": "@@ -1460,7 +1460,7 @@ operator_plus::op1_range (irange &r, tree type,\n   if (!minus)\n     return false;\n   bool res = minus.fold_range (r, type, lhs, op2);\n-  relation_kind rel = trio.lhs_op2 ();\n+  relation_kind rel = trio.lhs_op1 ();\n   // Check for a relation refinement.\n   if (res)\n     adjust_op1_for_overflow (r, op2, rel, true /* PLUS_EXPR */);\n@@ -1632,7 +1632,7 @@ operator_minus::op1_range (irange &r, tree type,\n   if (!minus)\n     return false;\n   bool res = minus.fold_range (r, type, lhs, op2);\n-  relation_kind rel = trio.lhs_op2 ();\n+  relation_kind rel = trio.lhs_op1 ();\n   if (res)\n     adjust_op1_for_overflow (r, op2, rel, false /* PLUS_EXPR */);\n   return res;"}, {"sha": "f5b1e67e420fd687e13591a2da15e71d213bf0bc", "filename": "gcc/value-relation.cc", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fda5de368d84d97eb29a9f03e0d6039068f8b9/gcc%2Fvalue-relation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fda5de368d84d97eb29a9f03e0d6039068f8b9/gcc%2Fvalue-relation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-relation.cc?ref=99fda5de368d84d97eb29a9f03e0d6039068f8b9", "patch": "@@ -883,6 +883,40 @@ value_relation::apply_transitive (const value_relation &rel)\n   return false;\n }\n \n+// Create a trio from this value relation given LHS, OP1 and OP2.\n+\n+relation_trio\n+value_relation::create_trio (tree lhs, tree op1, tree op2)\n+{\n+  relation_kind lhs_1;\n+  if (lhs == name1 && op1 == name2)\n+    lhs_1 = related;\n+  else if (lhs == name2 && op1 == name1)\n+    lhs_1 = relation_swap (related);\n+  else\n+    lhs_1 = VREL_VARYING;\n+\n+  relation_kind lhs_2;\n+  if (lhs == name1 && op2 == name2)\n+    lhs_2 = related;\n+  else if (lhs == name2 && op2 == name1)\n+    lhs_2 = relation_swap (related);\n+  else\n+    lhs_2 = VREL_VARYING;\n+\n+  relation_kind op_op;\n+  if (op1 == name1 && op2 == name2)\n+    op_op = related;\n+  else if (op1 == name2 && op2 == name1)\n+    op_op = relation_swap (related);\n+  else if  (op1 == op2)\n+    op_op = VREL_EQ;\n+  else\n+    op_op = VREL_VARYING;\n+\n+  return relation_trio (lhs_1, lhs_2, op_op);\n+}\n+\n // Dump the relation to file F.\n \n void"}, {"sha": "340f9c42554098fbf044450b8e7f1797f7936ac9", "filename": "gcc/value-relation.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fda5de368d84d97eb29a9f03e0d6039068f8b9/gcc%2Fvalue-relation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fda5de368d84d97eb29a9f03e0d6039068f8b9/gcc%2Fvalue-relation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-relation.h?ref=99fda5de368d84d97eb29a9f03e0d6039068f8b9", "patch": "@@ -426,6 +426,7 @@ class value_relation\n   inline tree op1 () const { return name1; }\n   inline tree op2 () const { return name2; }\n \n+  relation_trio create_trio (tree lhs, tree op1, tree op2);\n   bool union_ (value_relation &p);\n   bool intersect (value_relation &p);\n   void negate ();"}]}