{"sha": "1526ecd739fc6a13329abdcbdbf7c2df57c22177", "node_id": "C_kwDOANBUbNoAKDE1MjZlY2Q3MzlmYzZhMTMzMjlhYmRjYmRiZjdjMmRmNTdjMjIxNzc", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2023-03-14T17:53:16Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2023-03-14T17:56:23Z"}, "message": "ipa-cp: Improve updating behavior when profile counts have gone bad\n\nLooking into the behavior of profile count updating in PR 107925, I\nnoticed that an option not considered possible was actually happening,\nand - with the guesswork in place to distribute unexplained counts -\nit simply can happen.  Currently it is handled by dropping the counts\nto local estimated zero, whereas it is probably better to leave the\ncount as they are but drop the category to GUESSED_GLOBAL0 - which is\nwhat profile_count::combine_with_ipa_count in a similar case (or so I\nhope :-)\n\ngcc/ChangeLog:\n\n2023-02-20  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/107925\n\t* ipa-cp.cc (update_profiling_info): Drop counts of orig_node to\n\tglobal0 instead of zeroing when it does not have as many counts as\n\tit should.", "tree": {"sha": "3d5f65303e9ef24bd281af3f6dd5937c2397a7c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d5f65303e9ef24bd281af3f6dd5937c2397a7c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1526ecd739fc6a13329abdcbdbf7c2df57c22177", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE5elVTFt/d09Vsoczv2PBvD+kNUAFAmQQtUcACgkQv2PBvD+k\nNUBzCQ//WjtN/U69Qv4qKdBSxiylTnnombNQ37TwuCkKJgIR9+RhcoGwK0FhFpJ3\n7XvhLttXCi8h3oESbMqBo+/89K4VIaem1qZxSzcsB2XfxKAOycHc5FVYNhPe+obA\n4Enh5R+qb0Cqq5rcbZ7pUiuR6F1uJO3jJwtxnIB/5mpoh6VokcFWBtmpC04k5wBc\nu5dgSYOaSZ5+S9tBWdjn5+8Ab/+t1Wwe5525kVqCepjPFeV+CPgoncvsXlflaIS2\nAFHlisHU4CwaeLMwWUM8lscIZ0dukcXJ2Chy/Y2arWNSkFCIjz25aFrIS8cKh7hK\ntgVjjpswwnFyTnfbb+vE8FbGAqWIJ1ZxToG2uxB8Jkp0hX6cwFnMeIz4BoQvwqoo\nSzEvTRy82kVE0qi+QKjjsuIQTOZwsDOoby7qQcOyb6pIu+ItKFDG36HDdxCvl/9j\nN/VC2tRSg9rj3d4K6/KqUigKOtZ+9vPdHT/ev68aSZbxFjS6lbDKotWDKlwZUD8P\naMXe6jFcr+hwc/PjXZUL7MQM5xkJ6tnq/xHhnl6zDEFbC2BJqlmpRTanP48VPNYr\nuhpZW4njq87Oq7rxJhG2r5TlOuBlmuFnw8fiv+ddsKzBh4BZo5+l/vmmAV7qPQfq\nxAYHgL9r+eT4LbNHq/YKTMYt9dhiF5VZZ0nfbOCAG9hTGGJ3zfU=\n=DhC8\n-----END PGP SIGNATURE-----", "payload": "tree 3d5f65303e9ef24bd281af3f6dd5937c2397a7c2\nparent 68ba253bda74d6c6e77726d98184a6faee5e7337\nauthor Martin Jambor <mjambor@suse.cz> 1678816396 +0100\ncommitter Martin Jambor <mjambor@suse.cz> 1678816583 +0100\n\nipa-cp: Improve updating behavior when profile counts have gone bad\n\nLooking into the behavior of profile count updating in PR 107925, I\nnoticed that an option not considered possible was actually happening,\nand - with the guesswork in place to distribute unexplained counts -\nit simply can happen.  Currently it is handled by dropping the counts\nto local estimated zero, whereas it is probably better to leave the\ncount as they are but drop the category to GUESSED_GLOBAL0 - which is\nwhat profile_count::combine_with_ipa_count in a similar case (or so I\nhope :-)\n\ngcc/ChangeLog:\n\n2023-02-20  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/107925\n\t* ipa-cp.cc (update_profiling_info): Drop counts of orig_node to\n\tglobal0 instead of zeroing when it does not have as many counts as\n\tit should.\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1526ecd739fc6a13329abdcbdbf7c2df57c22177", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1526ecd739fc6a13329abdcbdbf7c2df57c22177", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1526ecd739fc6a13329abdcbdbf7c2df57c22177/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68ba253bda74d6c6e77726d98184a6faee5e7337", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68ba253bda74d6c6e77726d98184a6faee5e7337", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68ba253bda74d6c6e77726d98184a6faee5e7337"}], "stats": {"total": 29, "additions": 22, "deletions": 7}, "files": [{"sha": "6477bb840e5936fc9632f4695c53c3ba3461bd32", "filename": "gcc/ipa-cp.cc", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1526ecd739fc6a13329abdcbdbf7c2df57c22177/gcc%2Fipa-cp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1526ecd739fc6a13329abdcbdbf7c2df57c22177/gcc%2Fipa-cp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.cc?ref=1526ecd739fc6a13329abdcbdbf7c2df57c22177", "patch": "@@ -4969,10 +4969,20 @@ update_profiling_info (struct cgraph_node *orig_node,\n \t\t\t\t\t      false);\n   new_sum = stats.count_sum;\n \n+  bool orig_edges_processed = false;\n   if (new_sum > orig_node_count)\n     {\n-      /* TODO: Perhaps this should be gcc_unreachable ()?  */\n-      remainder = profile_count::zero ().guessed_local ();\n+      /* TODO: Profile has alreay gone astray, keep what we have but lower it\n+\t to global0 category.  */\n+      remainder = orig_node->count.global0 ();\n+\n+      for (cgraph_edge *cs = orig_node->callees; cs; cs = cs->next_callee)\n+\tcs->count = cs->count.global0 ();\n+      for (cgraph_edge *cs = orig_node->indirect_calls;\n+\t   cs;\n+\t   cs = cs->next_callee)\n+\tcs->count = cs->count.global0 ();\n+      orig_edges_processed = true;\n     }\n   else if (stats.rec_count_sum.nonzero_p ())\n     {\n@@ -5070,11 +5080,16 @@ update_profiling_info (struct cgraph_node *orig_node,\n   for (cgraph_edge *cs = new_node->indirect_calls; cs; cs = cs->next_callee)\n     cs->count = cs->count.apply_scale (new_sum, orig_new_node_count);\n \n-  profile_count::adjust_for_ipa_scaling (&remainder, &orig_node_count);\n-  for (cgraph_edge *cs = orig_node->callees; cs; cs = cs->next_callee)\n-    cs->count = cs->count.apply_scale (remainder, orig_node_count);\n-  for (cgraph_edge *cs = orig_node->indirect_calls; cs; cs = cs->next_callee)\n-    cs->count = cs->count.apply_scale (remainder, orig_node_count);\n+  if (!orig_edges_processed)\n+    {\n+      profile_count::adjust_for_ipa_scaling (&remainder, &orig_node_count);\n+      for (cgraph_edge *cs = orig_node->callees; cs; cs = cs->next_callee)\n+\tcs->count = cs->count.apply_scale (remainder, orig_node_count);\n+      for (cgraph_edge *cs = orig_node->indirect_calls;\n+\t   cs;\n+\t   cs = cs->next_callee)\n+\tcs->count = cs->count.apply_scale (remainder, orig_node_count);\n+    }\n \n   if (dump_file)\n     {"}]}