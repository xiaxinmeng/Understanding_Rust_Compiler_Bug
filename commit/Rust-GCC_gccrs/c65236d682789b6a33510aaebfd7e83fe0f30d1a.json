{"sha": "c65236d682789b6a33510aaebfd7e83fe0f30d1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzY1MjM2ZDY4Mjc4OWI2YTMzNTEwYWFlYmZkN2U4M2ZlMGYzMGQxYQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2016-09-02T18:00:57Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2016-09-02T18:00:57Z"}, "message": "Introduce class edit_context\n\ngcc/ChangeLog:\n\t* Makefile.in (OBJS-libcommon): Add edit-context.o.\n\t* diagnostic-color.c (color_dict): Add \"diff-filename\",\n\t\"diff-hunk\", \"diff-delete\", and \"diff-insert\".\n\t(parse_gcc_colors): Update default value of GCC_COLORS in comment\n\tto reflect above changes.\n\t* doc/invoke.texi (-fdiagnostics-color): Update description of\n\tdefault GCC_COLORS, and of the supported capabilities.\n\t* edit-context.c: New file.\n\t* edit-context.h: New file.\n\t* input.c (struct fcache): Add field \"missing_trailing_newline\".\n\t(diagnostics_file_cache_forcibly_evict_file): Initialize it to\n\ttrue.\n\t(add_file_to_cache_tab): Likewise.\n\t(fcache::fcache): Likewise.\n\t(get_next_line): Update c->missing_trailing_newline.\n\t(location_missing_trailing_newline): New function.\n\t* input.h (location_missing_trailing_newline): New decl.\n\t* selftest-run-tests.c (selftest::run_tests): Call\n\tedit_context_c_tests.\n\t* selftest.h (edit_context_c_tests): New decl.\n\nlibcpp/ChangeLog:\n\t* include/line-map.h (rich_location::seen_impossible_fixit_p): New\n\taccessor.\n\nFrom-SVN: r239963", "tree": {"sha": "796b73d02c02186aeafa76ffa1d0047c651425fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/796b73d02c02186aeafa76ffa1d0047c651425fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c65236d682789b6a33510aaebfd7e83fe0f30d1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c65236d682789b6a33510aaebfd7e83fe0f30d1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c65236d682789b6a33510aaebfd7e83fe0f30d1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c65236d682789b6a33510aaebfd7e83fe0f30d1a/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bad9b2889af54110857416e4f9e65f4032f2f5f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bad9b2889af54110857416e4f9e65f4032f2f5f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bad9b2889af54110857416e4f9e65f4032f2f5f4"}], "stats": {"total": 1686, "additions": 1675, "deletions": 11}, "files": [{"sha": "19101c478f39c47aa3f69891d7c1bf59d607f387", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65236d682789b6a33510aaebfd7e83fe0f30d1a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65236d682789b6a33510aaebfd7e83fe0f30d1a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c65236d682789b6a33510aaebfd7e83fe0f30d1a", "patch": "@@ -1,3 +1,26 @@\n+2016-09-02  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* Makefile.in (OBJS-libcommon): Add edit-context.o.\n+\t* diagnostic-color.c (color_dict): Add \"diff-filename\",\n+\t\"diff-hunk\", \"diff-delete\", and \"diff-insert\".\n+\t(parse_gcc_colors): Update default value of GCC_COLORS in comment\n+\tto reflect above changes.\n+\t* doc/invoke.texi (-fdiagnostics-color): Update description of\n+\tdefault GCC_COLORS, and of the supported capabilities.\n+\t* edit-context.c: New file.\n+\t* edit-context.h: New file.\n+\t* input.c (struct fcache): Add field \"missing_trailing_newline\".\n+\t(diagnostics_file_cache_forcibly_evict_file): Initialize it to\n+\ttrue.\n+\t(add_file_to_cache_tab): Likewise.\n+\t(fcache::fcache): Likewise.\n+\t(get_next_line): Update c->missing_trailing_newline.\n+\t(location_missing_trailing_newline): New function.\n+\t* input.h (location_missing_trailing_newline): New decl.\n+\t* selftest-run-tests.c (selftest::run_tests): Call\n+\tedit_context_c_tests.\n+\t* selftest.h (edit_context_c_tests): New decl.\n+\n 2016-09-02  Jakub Jelinek  <jakub@redhat.com>\n \t    Richard Biener  <rguenth@suse.de>\n "}, {"sha": "7c1828599988412688c5e5894aeedf3b979f3b86", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65236d682789b6a33510aaebfd7e83fe0f30d1a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65236d682789b6a33510aaebfd7e83fe0f30d1a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c65236d682789b6a33510aaebfd7e83fe0f30d1a", "patch": "@@ -1561,6 +1561,7 @@ OBJS = \\\n # Objects in libcommon.a, potentially used by all host binaries and with\n # no target dependencies.\n OBJS-libcommon = diagnostic.o diagnostic-color.o diagnostic-show-locus.o \\\n+\tedit-context.o \\\n \tpretty-print.o intl.o \\\n \tvec.o input.o version.o hash-table.o ggc-none.o memory-block.o \\\n \tselftest.o"}, {"sha": "0bd8170253d108d03b358dd1b1719a210c9357e9", "filename": "gcc/diagnostic-color.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65236d682789b6a33510aaebfd7e83fe0f30d1a/gcc%2Fdiagnostic-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65236d682789b6a33510aaebfd7e83fe0f30d1a/gcc%2Fdiagnostic-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-color.c?ref=c65236d682789b6a33510aaebfd7e83fe0f30d1a", "patch": "@@ -170,6 +170,10 @@ static struct color_cap color_dict[] =\n   { \"quote\", SGR_SEQ (COLOR_BOLD), 5, false },\n   { \"fixit-insert\", SGR_SEQ (COLOR_FG_GREEN), 12, false },\n   { \"fixit-delete\", SGR_SEQ (COLOR_FG_RED), 12, false },\n+  { \"diff-filename\", SGR_SEQ (COLOR_BOLD), 13, false },\n+  { \"diff-hunk\", SGR_SEQ (COLOR_FG_CYAN), 9, false },\n+  { \"diff-delete\", SGR_SEQ (COLOR_FG_RED), 11, false },\n+  { \"diff-insert\", SGR_SEQ (COLOR_FG_GREEN), 11, false },\n   { NULL, NULL, 0, false }\n };\n \n@@ -200,7 +204,8 @@ colorize_stop (bool show_color)\n /* Parse GCC_COLORS.  The default would look like:\n    GCC_COLORS='error=01;31:warning=01;35:note=01;36:\\\n    range1=32:range2=34:locus=01:quote=01:\\\n-   fixit-insert=32:fixit-delete=31'\n+   fixit-insert=32:fixit-delete=31'\\\n+   diff-filename=01:diff-hunk=32:diff-delete=31:diff-insert=32'\n    No character escaping is needed or supported.  */\n static bool\n parse_gcc_colors (void)"}, {"sha": "986ab436018abe7b5f194a760599aee36a17f585", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65236d682789b6a33510aaebfd7e83fe0f30d1a/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65236d682789b6a33510aaebfd7e83fe0f30d1a/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c65236d682789b6a33510aaebfd7e83fe0f30d1a", "patch": "@@ -3343,7 +3343,9 @@ for 88-color and 256-color modes background colors.\n \n The default @env{GCC_COLORS} is\n @smallexample\n-error=01;31:warning=01;35:note=01;36:range1=32:range2=34:locus=01:quote=01:fixit-insert=32:fixit-delete=31\n+error=01;31:warning=01;35:note=01;36:range1=32:range2=34:locus=01:quote=01:\\\n+fixit-insert=32:fixit-delete=31:\\\n+diff-filename=01:diff-hunk=32:diff-delete=31:diff-insert=32\n @end smallexample\n @noindent\n where @samp{01;31} is bold red, @samp{01;35} is bold magenta,\n@@ -3391,6 +3393,22 @@ be inserted or replaced.\n @vindex fixit-delete GCC_COLORS @r{capability}\n SGR substring for fix-it hints suggesting text to\n be deleted.\n+\n+@item diff-filename=\n+@vindex diff-filename GCC_COLORS @r{capability}\n+SGR substring for filename headers within generated patches.\n+\n+@item diff-hunk=\n+@vindex diff-hunk GCC_COLORS @r{capability}\n+SGR substring for the starts of hunks within generated patches.\n+\n+@item diff-delete=\n+@vindex diff-delete GCC_COLORS @r{capability}\n+SGR substring for deleted lines within generated patches.\n+\n+@item diff-insert=\n+@vindex diff-insert GCC_COLORS @r{capability}\n+SGR substring for inserted lines within generated patches.\n @end table\n \n @item -fno-diagnostics-show-option"}, {"sha": "515833c1af3fd2bb3ba496fbfb346de04b7ed647", "filename": "gcc/edit-context.c", "status": "added", "additions": 1511, "deletions": 0, "changes": 1511, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65236d682789b6a33510aaebfd7e83fe0f30d1a/gcc%2Fedit-context.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65236d682789b6a33510aaebfd7e83fe0f30d1a/gcc%2Fedit-context.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fedit-context.c?ref=c65236d682789b6a33510aaebfd7e83fe0f30d1a", "patch": "@@ -0,0 +1,1511 @@\n+/* Determining the results of applying fix-it hints.\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"line-map.h\"\n+#include \"edit-context.h\"\n+#include \"pretty-print.h\"\n+#include \"diagnostic-color.h\"\n+#include \"selftest.h\"\n+\n+/* This file implements a way to track the effect of fix-its,\n+   via a class edit_context; the other classes are support classes for\n+   edit_context.\n+\n+   A complication here is that fix-its are expressed relative to coordinates\n+   in the file when it was parsed, before any changes have been made, and\n+   so if there's more that one fix-it to be applied, we have to adjust\n+   later fix-its to allow for the changes made by earlier ones.  This\n+   is done by the various \"get_effective_column\" methods.\n+\n+   The \"filename\" params are required to outlive the edit_context (no\n+   copy of the underlying str is taken, just the ptr).  */\n+\n+/* Forward decls.  class edit_context is declared within edit-context.h.\n+   The other types are declared here.  */\n+class edit_context;\n+class edited_file;\n+class edited_line;\n+class line_event;\n+  class insert_event;\n+  class replace_event;\n+\n+/* A struct to hold the params of a print_diff call.  */\n+\n+struct diff\n+{\n+  diff (pretty_printer *pp, bool show_filenames)\n+  : m_pp (pp), m_show_filenames (show_filenames) {}\n+\n+  pretty_printer *m_pp;\n+  bool m_show_filenames;\n+};\n+\n+/* The state of one named file within an edit_context: the filename,\n+   and the lines that have been edited so far.  */\n+\n+class edited_file\n+{\n+ public:\n+  edited_file (const char *filename);\n+  static void delete_cb (edited_file *file);\n+\n+  const char *get_filename () const { return m_filename; }\n+  char *get_content ();\n+\n+  bool apply_insert (int line, int column, const char *str, int len);\n+  bool apply_replace (int line, int start_column,\n+\t\t      int finish_column,\n+\t\t      const char *replacement_str,\n+\t\t      int replacement_len);\n+  int get_effective_column (int line, int column);\n+\n+  static int call_print_diff (const char *, edited_file *file,\n+\t\t\t      void *user_data)\n+  {\n+    diff *d = (diff *)user_data;\n+    file->print_diff (d->m_pp, d->m_show_filenames);\n+    return 0;\n+  }\n+\n+ private:\n+  bool print_content (pretty_printer *pp);\n+  void print_diff (pretty_printer *pp, bool show_filenames);\n+  edited_line *get_line (int line);\n+  edited_line *get_or_insert_line (int line);\n+  int get_num_lines (bool *missing_trailing_newline);\n+\n+  const char *m_filename;\n+  typed_splay_tree<int, edited_line *> m_edited_lines;\n+  int m_num_lines;\n+};\n+\n+/* The state of one edited line within an edited_file.\n+   As well as the current content of the line, it contains a record of\n+   the changes, so that further changes can be applied in the correct\n+   place.  */\n+\n+class edited_line\n+{\n+ public:\n+  edited_line (const char *filename, int line_num);\n+  ~edited_line ();\n+  static void delete_cb (edited_line *el);\n+\n+  int get_line_num () const { return m_line_num; }\n+  const char *get_content () const { return m_content; }\n+\n+  int get_effective_column (int orig_column) const;\n+  bool apply_insert (int column, const char *str, int len);\n+  bool apply_replace (int start_column,\n+\t\t      int finish_column,\n+\t\t      const char *replacement_str,\n+\t\t      int replacement_len);\n+\n+ private:\n+  void ensure_capacity (int len);\n+  void ensure_terminated ();\n+  void print_content (pretty_printer *pp) const;\n+\n+  int m_line_num;\n+  char *m_content;\n+  int m_len;\n+  int m_alloc_sz;\n+  auto_vec <line_event *> m_line_events;\n+};\n+\n+/* Abstract base class for representing events that have occurred\n+   on one line of one file.  */\n+\n+class line_event\n+{\n+ public:\n+  virtual ~line_event () {}\n+  virtual int get_effective_column (int orig_column) const = 0;\n+};\n+\n+/* Concrete subclass of line_event: an insertion of some text\n+   at some column on the line.\n+\n+   Subsequent events will need their columns adjusting if they're\n+   are on this line and their column is >= the insertion point.  */\n+\n+class insert_event : public line_event\n+{\n+ public:\n+  insert_event (int column, int len) : m_column (column), m_len (len) {}\n+  int get_effective_column (int orig_column) const FINAL OVERRIDE\n+  {\n+    if (orig_column >= m_column)\n+      return orig_column + m_len;\n+    else\n+      return orig_column;\n+  }\n+\n+ private:\n+  int m_column;\n+  int m_len;\n+};\n+\n+/* Concrete subclass of line_event: the replacement of some text\n+   betweeen some columns on the line.\n+\n+   Subsequent events will need their columns adjusting if they're\n+   are on this line and their column is >= the finish point.  */\n+\n+class replace_event : public line_event\n+{\n+ public:\n+  replace_event (int start, int finish, int len) : m_start (start),\n+    m_finish (finish), m_delta (len - (finish + 1 - start)) {}\n+\n+  int get_effective_column (int orig_column) const FINAL OVERRIDE\n+  {\n+    if (orig_column >= m_start)\n+      return orig_column += m_delta;\n+    else\n+      return orig_column;\n+  }\n+\n+ private:\n+  int m_start;\n+  int m_finish;\n+  int m_delta;\n+};\n+\n+/* Implementation of class edit_context.  */\n+\n+/* edit_context's ctor.  */\n+\n+edit_context::edit_context ()\n+: m_valid (true),\n+  m_files (strcmp, NULL, edited_file::delete_cb)\n+{}\n+\n+/* Add any fixits within RICHLOC to this context, recording the\n+   changes that they make.  */\n+\n+void\n+edit_context::add_fixits (rich_location *richloc)\n+{\n+  if (!m_valid)\n+    return;\n+  if (richloc->seen_impossible_fixit_p ())\n+    {\n+      m_valid = false;\n+      return;\n+    }\n+  for (unsigned i = 0; i < richloc->get_num_fixit_hints (); i++)\n+    {\n+      const fixit_hint *hint = richloc->get_fixit_hint (i);\n+      switch (hint->get_kind ())\n+\t{\n+\tcase fixit_hint::INSERT:\n+\t  if (!apply_insert ((const fixit_insert *)hint))\n+\t    {\n+\t      /* Failure.  */\n+\t      m_valid = false;\n+\t      return;\n+\t    }\n+\t  break;\n+\tcase fixit_hint::REPLACE:\n+\t  if (!apply_replace ((const fixit_replace *)hint))\n+\t    {\n+\t      /* Failure.  */\n+\t      m_valid = false;\n+\t      return;\n+\t    }\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+}\n+\n+/* Get the content of the given file, with fix-its applied.\n+   If any errors occurred in this edit_context, return NULL.\n+   The ptr should be freed by the caller.  */\n+\n+char *\n+edit_context::get_content (const char *filename)\n+{\n+  if (!m_valid)\n+    return NULL;\n+  edited_file &file = get_or_insert_file (filename);\n+  return file.get_content ();\n+}\n+\n+/* Map a location before the edits to a column number after the edits.\n+   This method is for the selftests.  */\n+\n+int\n+edit_context::get_effective_column (const char *filename, int line,\n+\t\t\t\t    int column)\n+{\n+  edited_file *file = get_file (filename);\n+  if (!file)\n+    return column;\n+  return file->get_effective_column (line, column);\n+}\n+\n+/* Generate a unified diff.  The resulting string should be freed by the\n+   caller.  Primarily for selftests.\n+   If any errors occurred in this edit_context, return NULL.  */\n+\n+char *\n+edit_context::generate_diff (bool show_filenames)\n+{\n+  if (!m_valid)\n+    return NULL;\n+\n+  pretty_printer pp;\n+  print_diff (&pp, show_filenames);\n+  return xstrdup (pp_formatted_text (&pp));\n+}\n+\n+/* Print a unified diff to PP, showing the changes made within the\n+   context.  */\n+\n+void\n+edit_context::print_diff (pretty_printer *pp, bool show_filenames)\n+{\n+  if (!m_valid)\n+    return;\n+  diff d (pp, show_filenames);\n+  m_files.foreach (edited_file::call_print_diff, &d);\n+}\n+\n+/* Attempt to apply the given fixit.  Return true if it can be\n+   applied, or false otherwise.  */\n+\n+bool\n+edit_context::apply_insert (const fixit_insert *insert)\n+{\n+  expanded_location exploc = expand_location (insert->get_location ());\n+\n+  if (exploc.column == 0)\n+    return false;\n+\n+  edited_file &file = get_or_insert_file (exploc.file);\n+  if (!m_valid)\n+    return false;\n+  return file.apply_insert (exploc.line, exploc.column, insert->get_string (),\n+\t\t\t    insert->get_length ());\n+}\n+\n+/* Attempt to apply the given fixit.  Return true if it can be\n+   applied, or false otherwise.  */\n+\n+bool\n+edit_context::apply_replace (const fixit_replace *replace)\n+{\n+  source_range range = replace->get_range ();\n+\n+  expanded_location start = expand_location (range.m_start);\n+  expanded_location finish = expand_location (range.m_finish);\n+  if (start.file != finish.file)\n+    return false;\n+  if (start.line != finish.line)\n+    return false;\n+  if (start.column == 0)\n+    return false;\n+  if (finish.column == 0)\n+    return false;\n+\n+  edited_file &file = get_or_insert_file (start.file);\n+  if (!m_valid)\n+    return false;\n+  return file.apply_replace (start.line, start.column, finish.column,\n+\t\t\t     replace->get_string (),\n+\t\t\t     replace->get_length ());\n+}\n+\n+/* Locate the edited_file * for FILENAME, if any\n+   Return NULL if there isn't one.  */\n+\n+edited_file *\n+edit_context::get_file (const char *filename)\n+{\n+  gcc_assert (filename);\n+  return m_files.lookup (filename);\n+}\n+\n+/* Locate the edited_file for FILENAME, adding one if there isn't one.  */\n+\n+edited_file &\n+edit_context::get_or_insert_file (const char *filename)\n+{\n+  gcc_assert (filename);\n+\n+  edited_file *file = get_file (filename);\n+  if (file)\n+    return *file;\n+\n+  /* Not found.  */\n+  file = new edited_file (filename);\n+  m_files.insert (filename, file);\n+  return *file;\n+}\n+\n+/* Implementation of class edited_file.  */\n+\n+/* Callback for m_edited_lines, for comparing line numbers.  */\n+\n+static int line_comparator (int a, int b)\n+{\n+  return a - b;\n+}\n+\n+/* edited_file's constructor.  */\n+\n+edited_file::edited_file (const char *filename)\n+: m_filename (filename),\n+  m_edited_lines (line_comparator, NULL, edited_line::delete_cb),\n+  m_num_lines (-1)\n+{\n+}\n+\n+/* A callback for deleting edited_file *, for use as a\n+   delete_value_fn for edit_context::m_files.  */\n+\n+void\n+edited_file::delete_cb (edited_file *file)\n+{\n+  delete file;\n+}\n+\n+/* Get the content of the file, with fix-its applied.\n+   The ptr should be freed by the caller.  */\n+\n+char *\n+edited_file::get_content ()\n+{\n+  pretty_printer pp;\n+  if (!print_content (&pp))\n+    return NULL;\n+  return xstrdup (pp_formatted_text (&pp));\n+}\n+\n+/* Attempt to insert the string INSERT_STR with length INSERT_LEN\n+   at LINE and COLUMN, updating the in-memory copy of the line, and\n+   the record of edits to the line.  */\n+\n+bool\n+edited_file::apply_insert (int line, int column,\n+\t\t\t   const char *insert_str,\n+\t\t\t   int insert_len)\n+{\n+  edited_line *el = get_or_insert_line (line);\n+  if (!el)\n+    return false;\n+  return el->apply_insert (column, insert_str, insert_len);\n+}\n+\n+/* Attempt to replace columns START_COLUMN through FINISH_COLUMN of LINE\n+   with the string REPLACEMENT_STR of length REPLACEMENT_LEN,\n+   updating the in-memory copy of the line, and the record of edits to\n+   the line.  */\n+\n+bool\n+edited_file::apply_replace (int line, int start_column,\n+\t\t\t    int finish_column,\n+\t\t\t    const char *replacement_str,\n+\t\t\t    int replacement_len)\n+{\n+  edited_line *el = get_or_insert_line (line);\n+  if (!el)\n+    return false;\n+  return el->apply_replace (start_column, finish_column, replacement_str,\n+\t\t\t    replacement_len);\n+}\n+\n+/* Given line LINE, map from COLUMN in the input file to its current\n+   column after edits have been applied.  */\n+\n+int\n+edited_file::get_effective_column (int line, int column)\n+{\n+  const edited_line *el = get_line (line);\n+  if (!el)\n+    return column;\n+  return el->get_effective_column (column);\n+}\n+\n+/* Attempt to print the content of the file to PP, with edits applied.\n+   Return true if successful, false otherwise.  */\n+\n+bool\n+edited_file::print_content (pretty_printer *pp)\n+{\n+  bool missing_trailing_newline;\n+  int line_count = get_num_lines (&missing_trailing_newline);\n+  for (int line_num = 1; line_num <= line_count; line_num++)\n+    {\n+      edited_line *el = get_line (line_num);\n+      if (el)\n+\tpp_string (pp, el->get_content ());\n+      else\n+\t{\n+\t  int len;\n+\t  const char *line\n+\t    = location_get_source_line (m_filename, line_num, &len);\n+\t  if (!line)\n+\t    return false;\n+\t  for (int i = 0; i < len; i++)\n+\t    pp_character (pp, line[i]);\n+\t}\n+      if (line_num < line_count)\n+\tpp_character (pp, '\\n');\n+    }\n+\n+  if (!missing_trailing_newline)\n+    pp_character (pp, '\\n');\n+\n+  return true;\n+}\n+\n+/* Print a unified diff to PP, showing any changes that have occurred\n+   to this file.  */\n+\n+void\n+edited_file::print_diff (pretty_printer *pp, bool show_filenames)\n+{\n+  if (show_filenames)\n+    {\n+      pp_string (pp, colorize_start (pp_show_color (pp), \"diff-filename\"));\n+      pp_printf (pp, \"--- %s\\n\", m_filename);\n+      pp_printf (pp, \"+++ %s\\n\", m_filename);\n+      pp_string (pp, colorize_stop (pp_show_color (pp)));\n+    }\n+\n+  edited_line *el = m_edited_lines.min ();\n+\n+  bool missing_trailing_newline;\n+  int line_count = get_num_lines (&missing_trailing_newline);\n+\n+  const int context_lines = 3;\n+\n+  while (el)\n+    {\n+      int start_of_hunk = el->get_line_num ();\n+      start_of_hunk -= context_lines;\n+      if (start_of_hunk < 1)\n+\tstart_of_hunk = 1;\n+\n+      /* Locate end of hunk, merging in changed lines\n+\t that are sufficiently close.  */\n+      while (true)\n+\t{\n+\t  edited_line *next_el\n+\t    = m_edited_lines.successor (el->get_line_num ());\n+\t  if (!next_el)\n+\t    break;\n+\t  if (el->get_line_num () + context_lines\n+\t      >= next_el->get_line_num () - context_lines)\n+\t    el = next_el;\n+\t  else\n+\t    break;\n+\t}\n+      int end_of_hunk = el->get_line_num ();\n+      end_of_hunk += context_lines;\n+      if (end_of_hunk > line_count)\n+\tend_of_hunk = line_count;\n+\n+      int num_lines = end_of_hunk - start_of_hunk + 1;\n+\n+      pp_string (pp, colorize_start (pp_show_color (pp), \"diff-hunk\"));\n+      pp_printf (pp, \"@@ -%i,%i +%i,%i @@\\n\", start_of_hunk, num_lines,\n+\t\t start_of_hunk, num_lines);\n+      pp_string (pp, colorize_stop (pp_show_color (pp)));\n+\n+      int line_num = start_of_hunk;\n+      while (line_num <= end_of_hunk)\n+\t{\n+\t  edited_line *el = get_line (line_num);\n+\t  if (el)\n+\t    {\n+\t      /* We have an edited line.\n+\t\t Consolidate into runs of changed lines.  */\n+\t      const int first_changed_line_in_run = line_num;\n+\t      while (get_line (line_num))\n+\t\tline_num++;\n+\t      const int last_changed_line_in_run = line_num - 1;\n+\n+\t      pp_string (pp, colorize_start (pp_show_color (pp),\n+\t\t\t\t\t     \"diff-delete\"));\n+\n+\t      /* Show old version of lines.  */\n+\t      for (line_num = first_changed_line_in_run;\n+\t\t   line_num <= last_changed_line_in_run;\n+\t\t   line_num++)\n+\t\t{\n+\t\t  int line_size;\n+\t\t  const char *old_line\n+\t\t    = location_get_source_line (m_filename, line_num,\n+\t\t\t\t\t\t&line_size);\n+\t\t  pp_character (pp, '-');\n+\t\t  for (int i = 0; i < line_size; i++)\n+\t\t    pp_character (pp, old_line[i]);\n+\t\t  pp_character (pp, '\\n');\n+\t\t}\n+\n+\t      pp_string (pp, colorize_stop (pp_show_color (pp)));\n+\n+\t      pp_string (pp, colorize_start (pp_show_color (pp),\n+\t\t\t\t\t     \"diff-insert\"));\n+\n+\t      /* Show new version of lines.  */\n+\t      for (line_num = first_changed_line_in_run;\n+\t\t   line_num <= last_changed_line_in_run;\n+\t\t   line_num++)\n+\t\t{\n+\t\t  edited_line *el_in_run = get_line (line_num);\n+\t\t  gcc_assert (el_in_run);\n+\t\t  pp_character (pp, '+');\n+\t\t  pp_string (pp, el_in_run->get_content ());\n+\t\t  pp_character (pp, '\\n');\n+\t\t}\n+\n+\t      pp_string (pp, colorize_stop (pp_show_color (pp)));\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Unchanged line.  */\n+\t      int line_size;\n+\t      const char *old_line\n+\t\t= location_get_source_line (m_filename, line_num,\n+\t\t\t\t\t    &line_size);\n+\t      pp_character (pp, ' ');\n+\t      for (int i = 0; i < line_size; i++)\n+\t\tpp_character (pp, old_line[i]);\n+\t      pp_character (pp, '\\n');\n+\t      line_num++;\n+\t    }\n+\t}\n+\n+      el = m_edited_lines.successor (el->get_line_num ());\n+    }\n+}\n+\n+/* Get the state of LINE within the file, or NULL if it is untouched.  */\n+\n+edited_line *\n+edited_file::get_line (int line)\n+{\n+  return m_edited_lines.lookup (line);\n+}\n+\n+/* Get the state of LINE within the file, creating a state for it\n+   if necessary.  Return NULL if an error occurs.  */\n+\n+edited_line *\n+edited_file::get_or_insert_line (int line)\n+{\n+  edited_line *el = get_line (line);\n+  if (el)\n+    return el;\n+  el = new edited_line (m_filename, line);\n+  if (el->get_content () == NULL)\n+    {\n+      delete el;\n+      return NULL;\n+    }\n+  m_edited_lines.insert (line, el);\n+  return el;\n+}\n+\n+/* Get the total number of lines in m_content, writing\n+   true to *MISSING_TRAILING_NEWLINE if the final line\n+   if missing a newline, false otherwise.  */\n+\n+int\n+edited_file::get_num_lines (bool *missing_trailing_newline)\n+{\n+  gcc_assert (missing_trailing_newline);\n+  if (m_num_lines == -1)\n+    {\n+      m_num_lines = 0;\n+      while (true)\n+\t{\n+\t  int line_size;\n+\t  const char *line\n+\t    = location_get_source_line (m_filename, m_num_lines + 1,\n+\t\t\t\t\t&line_size);\n+\t  if (line)\n+\t    m_num_lines++;\n+\t  else\n+\t    break;\n+\t}\n+    }\n+  *missing_trailing_newline = location_missing_trailing_newline (m_filename);\n+  return m_num_lines;\n+}\n+\n+/* Implementation of class edited_line.  */\n+\n+/* edited_line's ctor.  */\n+\n+edited_line::edited_line (const char *filename, int line_num)\n+: m_line_num (line_num),\n+  m_content (NULL), m_len (0), m_alloc_sz (0),\n+  m_line_events ()\n+{\n+  const char *line = location_get_source_line (filename, line_num,\n+\t\t\t\t\t       &m_len);\n+  if (!line)\n+    return;\n+  ensure_capacity (m_len);\n+  memcpy (m_content, line, m_len);\n+  ensure_terminated ();\n+}\n+\n+/* edited_line's dtor.  */\n+\n+edited_line::~edited_line ()\n+{\n+  free (m_content);\n+\n+  int i;\n+  line_event *event;\n+  FOR_EACH_VEC_ELT (m_line_events, i, event)\n+    delete event;\n+}\n+\n+/* A callback for deleting edited_line *, for use as a\n+   delete_value_fn for edited_file::m_edited_lines.  */\n+\n+void\n+edited_line::delete_cb (edited_line *el)\n+{\n+  delete el;\n+}\n+\n+/* Map a location before the edits to a column number after the edits,\n+   within a specific line.  */\n+\n+int\n+edited_line::get_effective_column (int orig_column) const\n+{\n+  int i;\n+  line_event *event;\n+  FOR_EACH_VEC_ELT (m_line_events, i, event)\n+    orig_column = event->get_effective_column (orig_column);\n+  return orig_column;\n+}\n+\n+/* Attempt to insert the string INSERT_STR with length INSERT_LEN at COLUMN\n+   of this line, updating the in-memory copy of the line, and the record\n+   of edits to it.\n+   Return true if successful; false if an error occurred.  */\n+\n+bool\n+edited_line::apply_insert (int column, const char *insert_str,\n+\t\t\t   int insert_len)\n+{\n+  column = get_effective_column (column);\n+\n+  int start_offset = column - 1;\n+  gcc_assert (start_offset >= 0);\n+  if (start_offset > m_len)\n+    return false;\n+\n+  /* Ensure buffer is big enough.  */\n+  size_t new_len = m_len + insert_len;\n+  ensure_capacity (new_len);\n+\n+  char *suffix = m_content + start_offset;\n+  gcc_assert (suffix <= m_content + m_len);\n+  size_t len_suffix = (m_content + m_len) - suffix;\n+\n+  /* Move successor content into position.  They overlap, so use memmove.  */\n+  memmove (m_content + start_offset + insert_len,\n+\t   suffix, len_suffix);\n+\n+  /* Replace target content.  They don't overlap, so use memcpy.  */\n+  memcpy (m_content + start_offset,\n+\t  insert_str,\n+\t  insert_len);\n+\n+  m_len = new_len;\n+\n+  ensure_terminated ();\n+\n+  /* Record the insertion, so that future changes to the line can have\n+     their column information adjusted accordingly.  */\n+  m_line_events.safe_push (new insert_event (column, insert_len));\n+\n+  return true;\n+}\n+\n+/* Attempt to replace columns START_COLUMN through FINISH_COLUMN of the line\n+   with the string REPLACEMENT_STR of length REPLACEMENT_LEN,\n+   updating the in-memory copy of the line, and the record of edits to\n+   the line.\n+   Return true if successful; false if an error occurred.  */\n+\n+bool\n+edited_line::apply_replace (int start_column,\n+\t\t\t    int finish_column,\n+\t\t\t    const char *replacement_str,\n+\t\t\t    int replacement_len)\n+{\n+  start_column = get_effective_column (start_column);\n+  finish_column = get_effective_column (finish_column);\n+\n+  int start_offset = start_column - 1;\n+  int end_offset = finish_column - 1;\n+\n+  gcc_assert (start_offset >= 0);\n+  gcc_assert (end_offset >= 0);\n+\n+  if (start_column > finish_column)\n+    return false;\n+  if (start_offset >= m_len)\n+    return false;\n+  if (end_offset >= m_len)\n+    return false;\n+\n+  size_t victim_len = end_offset - start_offset + 1;\n+\n+  /* Ensure buffer is big enough.  */\n+  size_t new_len = m_len + replacement_len - victim_len;\n+  ensure_capacity (new_len);\n+\n+  char *suffix = m_content + end_offset + 1;\n+  gcc_assert (suffix <= m_content + m_len);\n+  size_t len_suffix = (m_content + m_len) - suffix;\n+\n+  /* Move successor content into position.  They overlap, so use memmove.  */\n+  memmove (m_content + start_offset + replacement_len,\n+\t   suffix, len_suffix);\n+\n+  /* Replace target content.  They don't overlap, so use memcpy.  */\n+  memcpy (m_content + start_offset,\n+\t  replacement_str,\n+\t  replacement_len);\n+\n+  m_len = new_len;\n+\n+  ensure_terminated ();\n+\n+  /* Record the replacement, so that future changes to the line can have\n+     their column information adjusted accordingly.  */\n+  m_line_events.safe_push (new replace_event (start_column, finish_column,\n+\t\t\t\t\t      replacement_len));\n+  return true;\n+}\n+\n+/* Ensure that the buffer for m_content is at least large enough to hold\n+   a string of length LEN and its 0-terminator, doubling on repeated\n+   allocations.  */\n+\n+void\n+edited_line::ensure_capacity (int len)\n+{\n+  /* Allow 1 extra byte for 0-termination.  */\n+  if (m_alloc_sz < (len + 1))\n+    {\n+      size_t new_alloc_sz = (len + 1) * 2;\n+      m_content = (char *)xrealloc (m_content, new_alloc_sz);\n+      m_alloc_sz = new_alloc_sz;\n+    }\n+}\n+\n+/* Ensure that m_content is 0-terminated.  */\n+\n+void\n+edited_line::ensure_terminated ()\n+{\n+  /* 0-terminate the buffer.  */\n+  gcc_assert (m_len < m_alloc_sz);\n+  m_content[m_len] = '\\0';\n+}\n+\n+#if CHECKING_P\n+\n+/* Selftests of code-editing.  */\n+\n+namespace selftest {\n+\n+/* A wrapper class for ensuring that the underlying pointer is freed.  */\n+\n+template <typename POINTER_T>\n+class auto_free\n+{\n+ public:\n+  auto_free (POINTER_T p) : m_ptr (p) {}\n+  ~auto_free () { free (m_ptr); }\n+\n+  operator POINTER_T () { return m_ptr; }\n+\n+ private:\n+  POINTER_T m_ptr;\n+};\n+\n+/* Verify that edit_context::get_content works for unedited files.  */\n+\n+static void\n+test_get_content ()\n+{\n+  /* Test of empty file.  */\n+  {\n+    const char *content = (\"\");\n+    temp_source_file tmp (SELFTEST_LOCATION, \".c\", content);\n+    edit_context edit;\n+    auto_free <char *> result = edit.get_content (tmp.get_filename ());\n+    ASSERT_STREQ (\"\", result);\n+  }\n+\n+  /* Test of simple content.  */\n+  {\n+    const char *content = (\"/* before */\\n\"\n+\t\t\t   \"foo = bar.field;\\n\"\n+\t\t\t   \"/* after */\\n\");\n+    temp_source_file tmp (SELFTEST_LOCATION, \".c\", content);\n+    edit_context edit;\n+    auto_free <char *> result = edit.get_content (tmp.get_filename ());\n+    ASSERT_STREQ (\"/* before */\\n\"\n+\t\t  \"foo = bar.field;\\n\"\n+\t\t  \"/* after */\\n\", result);\n+  }\n+\n+  /* Test of omitting the trailing newline on the final line.  */\n+  {\n+    const char *content = (\"/* before */\\n\"\n+\t\t\t   \"foo = bar.field;\\n\"\n+\t\t\t   \"/* after */\");\n+    temp_source_file tmp (SELFTEST_LOCATION, \".c\", content);\n+    edit_context edit;\n+    auto_free <char *> result = edit.get_content (tmp.get_filename ());\n+    /* We should respect the omitted trailing newline.  */\n+    ASSERT_STREQ (\"/* before */\\n\"\n+\t\t  \"foo = bar.field;\\n\"\n+\t\t  \"/* after */\", result);\n+  }\n+}\n+\n+/* Test applying an \"insert\" fixit.  */\n+\n+static void\n+test_applying_fixits_insert (const line_table_case &case_)\n+{\n+  /* Create a tempfile and write some text to it.\n+     .........................0000000001111111.\n+     .........................1234567890123456.  */\n+  const char *old_content = (\"/* before */\\n\"\n+\t\t\t     \"foo = bar.field;\\n\"\n+\t\t\t     \"/* after */\\n\");\n+  temp_source_file tmp (SELFTEST_LOCATION, \".c\", old_content);\n+  const char *filename = tmp.get_filename ();\n+  line_table_test ltt (case_);\n+  linemap_add (line_table, LC_ENTER, false, tmp.get_filename (), 2);\n+\n+  /* Add a comment in front of \"bar.field\".  */\n+  location_t start = linemap_position_for_column (line_table, 7);\n+  rich_location richloc (line_table, start);\n+  richloc.add_fixit_insert (\"/* inserted */\");\n+\n+  if (start > LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    return;\n+\n+  edit_context edit;\n+  edit.add_fixits (&richloc);\n+  auto_free <char *> new_content = edit.get_content (filename);\n+  if (start <= LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    ASSERT_STREQ (\"/* before */\\n\"\n+\t\t  \"foo = /* inserted */bar.field;\\n\"\n+\t\t  \"/* after */\\n\", new_content);\n+\n+  /* Verify that locations on other lines aren't affected by the change.  */\n+  ASSERT_EQ (100, edit.get_effective_column (filename, 1, 100));\n+  ASSERT_EQ (100, edit.get_effective_column (filename, 3, 100));\n+\n+  /* Verify locations on the line before the change.  */\n+  ASSERT_EQ (1, edit.get_effective_column (filename, 2, 1));\n+  ASSERT_EQ (6, edit.get_effective_column (filename, 2, 6));\n+\n+  /* Verify locations on the line at and after the change.  */\n+  ASSERT_EQ (21, edit.get_effective_column (filename, 2, 7));\n+  ASSERT_EQ (22, edit.get_effective_column (filename, 2, 8));\n+\n+  /* Verify diff.  */\n+  auto_free <char *> diff = edit.generate_diff (false);\n+  ASSERT_STREQ (\"@@ -1,3 +1,3 @@\\n\"\n+\t\t\" /* before */\\n\"\n+\t\t\"-foo = bar.field;\\n\"\n+\t\t\"+foo = /* inserted */bar.field;\\n\"\n+\t\t\" /* after */\\n\", diff);\n+}\n+\n+/* Test applying a \"replace\" fixit that grows the affected line.  */\n+\n+static void\n+test_applying_fixits_growing_replace (const line_table_case &case_)\n+{\n+  /* Create a tempfile and write some text to it.\n+     .........................0000000001111111.\n+     .........................1234567890123456.  */\n+  const char *old_content = (\"/* before */\\n\"\n+\t\t\t     \"foo = bar.field;\\n\"\n+\t\t\t     \"/* after */\\n\");\n+  temp_source_file tmp (SELFTEST_LOCATION, \".c\", old_content);\n+  const char *filename = tmp.get_filename ();\n+  line_table_test ltt (case_);\n+  linemap_add (line_table, LC_ENTER, false, filename, 2);\n+\n+  /* Replace \"field\" with \"m_field\".  */\n+  location_t start = linemap_position_for_column (line_table, 11);\n+  location_t finish = linemap_position_for_column (line_table, 15);\n+  location_t field = make_location (start, start, finish);\n+  rich_location richloc (line_table, field);\n+  richloc.add_fixit_replace (\"m_field\");\n+\n+  edit_context edit;\n+  edit.add_fixits (&richloc);\n+  auto_free <char *> new_content = edit.get_content (filename);\n+  if (finish <= LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    {\n+      ASSERT_STREQ (\"/* before */\\n\"\n+\t\t    \"foo = bar.m_field;\\n\"\n+\t\t    \"/* after */\\n\", new_content);\n+\n+      /* Verify location of \";\" after the change.  */\n+      ASSERT_EQ (18, edit.get_effective_column (filename, 2, 16));\n+\n+      /* Verify diff.  */\n+      auto_free <char *> diff = edit.generate_diff (false);\n+      ASSERT_STREQ (\"@@ -1,3 +1,3 @@\\n\"\n+\t\t    \" /* before */\\n\"\n+\t\t    \"-foo = bar.field;\\n\"\n+\t\t    \"+foo = bar.m_field;\\n\"\n+\t\t    \" /* after */\\n\", diff);\n+    }\n+}\n+\n+/* Test applying a \"replace\" fixit that shrinks the affected line.  */\n+\n+static void\n+test_applying_fixits_shrinking_replace (const line_table_case &case_)\n+{\n+  /* Create a tempfile and write some text to it.\n+     .........................000000000111111111.\n+     .........................123456789012345678.  */\n+  const char *old_content = (\"/* before */\\n\"\n+\t\t\t     \"foo = bar.m_field;\\n\"\n+\t\t\t     \"/* after */\\n\");\n+  temp_source_file tmp (SELFTEST_LOCATION, \".c\", old_content);\n+  const char *filename = tmp.get_filename ();\n+  line_table_test ltt (case_);\n+  linemap_add (line_table, LC_ENTER, false, filename, 2);\n+\n+  /* Replace \"field\" with \"m_field\".  */\n+  location_t start = linemap_position_for_column (line_table, 11);\n+  location_t finish = linemap_position_for_column (line_table, 17);\n+  location_t m_field = make_location (start, start, finish);\n+  rich_location richloc (line_table, m_field);\n+  richloc.add_fixit_replace (\"field\");\n+\n+  edit_context edit;\n+  edit.add_fixits (&richloc);\n+  auto_free <char *> new_content = edit.get_content (filename);\n+  if (finish <= LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    {\n+      ASSERT_STREQ (\"/* before */\\n\"\n+\t\t    \"foo = bar.field;\\n\"\n+\t\t    \"/* after */\\n\", new_content);\n+\n+      /* Verify location of \";\" after the change.  */\n+      ASSERT_EQ (16, edit.get_effective_column (filename, 2, 18));\n+\n+      /* Verify diff.  */\n+      auto_free <char *> diff = edit.generate_diff (false);\n+      ASSERT_STREQ (\"@@ -1,3 +1,3 @@\\n\"\n+\t\t    \" /* before */\\n\"\n+\t\t    \"-foo = bar.m_field;\\n\"\n+\t\t    \"+foo = bar.field;\\n\"\n+\t\t    \" /* after */\\n\", diff);\n+    }\n+}\n+\n+/* Test applying a \"remove\" fixit.  */\n+\n+static void\n+test_applying_fixits_remove (const line_table_case &case_)\n+{\n+  /* Create a tempfile and write some text to it.\n+     .........................000000000111111111.\n+     .........................123456789012345678.  */\n+  const char *old_content = (\"/* before */\\n\"\n+\t\t\t     \"foo = bar.m_field;\\n\"\n+\t\t\t     \"/* after */\\n\");\n+  temp_source_file tmp (SELFTEST_LOCATION, \".c\", old_content);\n+  const char *filename = tmp.get_filename ();\n+  line_table_test ltt (case_);\n+  linemap_add (line_table, LC_ENTER, false, filename, 2);\n+\n+  /* Remove \".m_field\".  */\n+  location_t start = linemap_position_for_column (line_table, 10);\n+  location_t finish = linemap_position_for_column (line_table, 17);\n+  rich_location richloc (line_table, start);\n+  source_range range;\n+  range.m_start = start;\n+  range.m_finish = finish;\n+  richloc.add_fixit_remove (range);\n+\n+  edit_context edit;\n+  edit.add_fixits (&richloc);\n+  auto_free <char *> new_content = edit.get_content (filename);\n+  if (finish <= LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    {\n+      ASSERT_STREQ (\"/* before */\\n\"\n+\t\t    \"foo = bar;\\n\"\n+\t\t    \"/* after */\\n\", new_content);\n+\n+      /* Verify location of \";\" after the change.  */\n+      ASSERT_EQ (10, edit.get_effective_column (filename, 2, 18));\n+\n+      /* Verify diff.  */\n+      auto_free <char *> diff = edit.generate_diff (false);\n+      ASSERT_STREQ (\"@@ -1,3 +1,3 @@\\n\"\n+\t\t    \" /* before */\\n\"\n+\t\t    \"-foo = bar.m_field;\\n\"\n+\t\t    \"+foo = bar;\\n\"\n+\t\t    \" /* after */\\n\", diff);\n+    }\n+}\n+\n+/* Test applying multiple fixits to one line.  */\n+\n+static void\n+test_applying_fixits_multiple (const line_table_case &case_)\n+{\n+  /* Create a tempfile and write some text to it.\n+     .........................00000000011111111.\n+     .........................12345678901234567.  */\n+  const char *old_content = (\"/* before */\\n\"\n+\t\t\t     \"foo = bar.field;\\n\"\n+\t\t\t     \"/* after */\\n\");\n+  temp_source_file tmp (SELFTEST_LOCATION, \".c\", old_content);\n+  const char *filename = tmp.get_filename ();\n+  line_table_test ltt (case_);\n+  linemap_add (line_table, LC_ENTER, false, filename, 2);\n+\n+  location_t c7 = linemap_position_for_column (line_table, 7);\n+  location_t c9 = linemap_position_for_column (line_table, 9);\n+  location_t c11 = linemap_position_for_column (line_table, 11);\n+  location_t c15 = linemap_position_for_column (line_table, 15);\n+  location_t c17 = linemap_position_for_column (line_table, 17);\n+\n+  if (c17 > LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    return;\n+\n+  /* Add a comment in front of \"bar.field\".  */\n+  rich_location insert_a (line_table, c7);\n+  insert_a.add_fixit_insert (c7, \"/* alpha */\");\n+\n+  /* Add a comment after \"bar.field;\".  */\n+  rich_location insert_b (line_table, c17);\n+  insert_b.add_fixit_insert (c17, \"/* beta */\");\n+\n+  /* Replace \"bar\" with \"pub\".   */\n+  rich_location replace_a (line_table, c7);\n+  replace_a.add_fixit_replace (source_range::from_locations (c7, c9),\n+\t\t\t       \"pub\");\n+\n+  /* Replace \"field\" with \"meadow\".   */\n+  rich_location replace_b (line_table, c7);\n+  replace_b.add_fixit_replace (source_range::from_locations (c11, c15),\n+\t\t\t       \"meadow\");\n+\n+  edit_context edit;\n+  edit.add_fixits (&insert_a);\n+  ASSERT_EQ (100, edit.get_effective_column (filename, 1, 100));\n+  ASSERT_EQ (1, edit.get_effective_column (filename, 2, 1));\n+  ASSERT_EQ (6, edit.get_effective_column (filename, 2, 6));\n+  ASSERT_EQ (18, edit.get_effective_column (filename, 2, 7));\n+  ASSERT_EQ (27, edit.get_effective_column (filename, 2, 16));\n+  ASSERT_EQ (100, edit.get_effective_column (filename, 3, 100));\n+\n+  edit.add_fixits (&insert_b);\n+  edit.add_fixits (&replace_a);\n+  edit.add_fixits (&replace_b);\n+\n+  if (c17 <= LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    {\n+      auto_free <char *> new_content = edit.get_content (tmp.get_filename ());\n+      ASSERT_STREQ (\"/* before */\\n\"\n+\t\t     \"foo = /* alpha */pub.meadow;/* beta */\\n\"\n+\t\t     \"/* after */\\n\",\n+\t\t    new_content);\n+\n+      /* Verify diff.  */\n+      auto_free <char *> diff = edit.generate_diff (false);\n+      ASSERT_STREQ (\"@@ -1,3 +1,3 @@\\n\"\n+\t\t    \" /* before */\\n\"\n+\t\t    \"-foo = bar.field;\\n\"\n+\t\t    \"+foo = /* alpha */pub.meadow;/* beta */\\n\"\n+\t\t    \" /* after */\\n\", diff);\n+    }\n+}\n+\n+/* Subroutine of test_applying_fixits_multiple_lines.\n+   Add the text \"CHANGED: \" to the front of the given line.  */\n+\n+static location_t\n+change_line (edit_context &edit, int line_num)\n+{\n+  const line_map_ordinary *ord_map\n+    = LINEMAPS_LAST_ORDINARY_MAP (line_table);\n+  const int column = 1;\n+  location_t loc =\n+    linemap_position_for_line_and_column (line_table, ord_map,\n+\t\t\t\t\t  line_num, column);\n+\n+  expanded_location exploc = expand_location (loc);\n+  if (loc <= LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    {\n+      ASSERT_EQ (line_num, exploc.line);\n+      ASSERT_EQ (column, exploc.column);\n+    }\n+\n+  rich_location insert (line_table, loc);\n+  insert.add_fixit_insert (\"CHANGED: \");\n+  edit.add_fixits (&insert);\n+  return loc;\n+}\n+\n+/* Test of editing multiple lines within a long file,\n+   to ensure that diffs are generated as expected.  */\n+\n+static void\n+test_applying_fixits_multiple_lines (const line_table_case &case_)\n+{\n+  /* Create a tempfile and write many lines of text to it.  */\n+  named_temp_file tmp (\".txt\");\n+  const char *filename = tmp.get_filename ();\n+  FILE *f = fopen (filename, \"w\");\n+  ASSERT_NE (f, NULL);\n+  for (int i = 1; i <= 1000; i++)\n+    fprintf (f, \"line %i\\n\", i);\n+  fclose (f);\n+\n+  line_table_test ltt (case_);\n+  linemap_add (line_table, LC_ENTER, false, filename, 1);\n+  linemap_position_for_column (line_table, 127);\n+\n+  edit_context edit;\n+\n+  /* A run of consecutive lines.  */\n+  change_line (edit, 2);\n+  change_line (edit, 3);\n+  change_line (edit, 4);\n+\n+  /* A run of nearby lines, within the contextual limit.  */\n+  change_line (edit, 150);\n+  change_line (edit, 151);\n+  location_t last_loc = change_line (edit, 153);\n+\n+  if (last_loc > LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    return;\n+\n+  /* Verify diff.  */\n+  auto_free <char *> diff = edit.generate_diff (false);\n+  ASSERT_STREQ (\"@@ -1,7 +1,7 @@\\n\"\n+\t\t\" line 1\\n\"\n+\t\t\"-line 2\\n\"\n+\t\t\"-line 3\\n\"\n+\t\t\"-line 4\\n\"\n+\t\t\"+CHANGED: line 2\\n\"\n+\t\t\"+CHANGED: line 3\\n\"\n+\t\t\"+CHANGED: line 4\\n\"\n+\t\t\" line 5\\n\"\n+\t\t\" line 6\\n\"\n+\t\t\" line 7\\n\"\n+\t\t\"@@ -147,10 +147,10 @@\\n\"\n+\t\t\" line 147\\n\"\n+\t\t\" line 148\\n\"\n+\t\t\" line 149\\n\"\n+\t\t\"-line 150\\n\"\n+\t\t\"-line 151\\n\"\n+\t\t\"+CHANGED: line 150\\n\"\n+\t\t\"+CHANGED: line 151\\n\"\n+\t\t\" line 152\\n\"\n+\t\t\"-line 153\\n\"\n+\t\t\"+CHANGED: line 153\\n\"\n+\t\t\" line 154\\n\"\n+\t\t\" line 155\\n\"\n+\t\t\" line 156\\n\", diff);\n+\n+  /* Ensure tmp stays alive until this point, so that the tempfile\n+     persists until after the generate_diff call.  */\n+  tmp.get_filename ();\n+}\n+\n+/* Test of converting an initializer for a named field from\n+   the old GCC extension to C99 syntax.\n+   Exercises a shrinking replacement followed by a growing\n+   replacement on the same line.  */\n+\n+static void\n+test_applying_fixits_modernize_named_init (const line_table_case &case_)\n+{\n+  /* Create a tempfile and write some text to it.\n+     .........................00000000011111111.\n+     .........................12345678901234567.  */\n+  const char *old_content = (\"/* before */\\n\"\n+\t\t\t     \"bar    : 1,\\n\"\n+\t\t\t     \"/* after */\\n\");\n+  temp_source_file tmp (SELFTEST_LOCATION, \".c\", old_content);\n+  const char *filename = tmp.get_filename ();\n+  line_table_test ltt (case_);\n+  linemap_add (line_table, LC_ENTER, false, filename, 2);\n+\n+  location_t c1 = linemap_position_for_column (line_table, 1);\n+  location_t c3 = linemap_position_for_column (line_table, 3);\n+  location_t c8 = linemap_position_for_column (line_table, 8);\n+\n+  if (c8 > LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    return;\n+\n+  /* Replace \"bar\" with \".\".  */\n+  rich_location r1 (line_table, c8);\n+  r1.add_fixit_replace (source_range::from_locations (c1, c3),\n+\t\t\t\".\");\n+\n+  /* Replace \":\" with \"bar =\".   */\n+  rich_location r2 (line_table, c8);\n+  r2.add_fixit_replace (source_range::from_locations (c8, c8),\n+\t\t\t\"bar =\");\n+\n+  /* The order should not matter.  Do r1 then r2. */\n+  {\n+    edit_context edit;\n+    edit.add_fixits (&r1);\n+\n+    /* Verify state after first replacement.  */\n+    {\n+      auto_free <char *> new_content = edit.get_content (tmp.get_filename ());\n+      /* We should now have:\n+\t ............00000000011.\n+\t ............12345678901.  */\n+      ASSERT_STREQ (\"/* before */\\n\"\n+\t\t    \".    : 1,\\n\"\n+\t\t    \"/* after */\\n\",\n+\t\t    new_content);\n+      /* Location of the \"1\".  */\n+      ASSERT_EQ (6, edit.get_effective_column (filename, 2, 8));\n+      /* Location of the \",\".  */\n+      ASSERT_EQ (9, edit.get_effective_column (filename, 2, 11));\n+    }\n+\n+    edit.add_fixits (&r2);\n+\n+    auto_free <char *> new_content = edit.get_content (tmp.get_filename ());\n+    /* Verify state after second replacement.\n+       ............00000000011111111.\n+       ............12345678901234567.  */\n+    ASSERT_STREQ (\"/* before */\\n\"\n+\t\t  \".    bar = 1,\\n\"\n+\t\t  \"/* after */\\n\",\n+\t\t  new_content);\n+  }\n+\n+  /* Try again, doing r2 then r1; the new_content should be the same.  */\n+  {\n+    edit_context edit;\n+    edit.add_fixits (&r2);\n+    edit.add_fixits (&r1);\n+    auto_free <char *> new_content = edit.get_content (tmp.get_filename ());\n+    /*.............00000000011111111.\n+      .............12345678901234567.  */\n+    ASSERT_STREQ (\"/* before */\\n\"\n+\t\t  \".    bar = 1,\\n\"\n+\t\t  \"/* after */\\n\",\n+\t\t  new_content);\n+  }\n+}\n+\n+/* Test of a fixit affecting a file that can't be read.  */\n+\n+static void\n+test_applying_fixits_unreadable_file ()\n+{\n+  const char *filename = \"this-does-not-exist.txt\";\n+  line_table_test ltt ();\n+  linemap_add (line_table, LC_ENTER, false, filename, 1);\n+\n+  location_t loc = linemap_position_for_column (line_table, 1);\n+\n+  rich_location insert (line_table, loc);\n+  insert.add_fixit_insert (\"change 1\");\n+  insert.add_fixit_insert (\"change 2\");\n+\n+  edit_context edit;\n+  /* Attempting to add the fixits affecting the unreadable file\n+     should transition the edit from valid to invalid.  */\n+  ASSERT_TRUE (edit.valid_p ());\n+  edit.add_fixits (&insert);\n+  ASSERT_FALSE (edit.valid_p ());\n+  ASSERT_EQ (NULL, edit.get_content (filename));\n+  ASSERT_EQ (NULL, edit.generate_diff (false));\n+}\n+\n+/* Verify that we gracefully handle an attempt to edit a line\n+   that's beyond the end of the file.  */\n+\n+static void\n+test_applying_fixits_line_out_of_range ()\n+{\n+  /* Create a tempfile and write some text to it.\n+     ........................00000000011111111.\n+     ........................12345678901234567.  */\n+  const char *old_content = \"One-liner file\\n\";\n+  temp_source_file tmp (SELFTEST_LOCATION, \".txt\", old_content);\n+  const char *filename = tmp.get_filename ();\n+  line_table_test ltt ();\n+  linemap_add (line_table, LC_ENTER, false, filename, 2);\n+\n+  /* Try to insert a string in line 2.  */\n+  location_t loc = linemap_position_for_column (line_table, 1);\n+\n+  rich_location insert (line_table, loc);\n+  insert.add_fixit_insert (\"change\");\n+\n+  /* Verify that attempting the insertion puts an edit_context\n+     into an invalid state.  */\n+  edit_context edit;\n+  ASSERT_TRUE (edit.valid_p ());\n+  edit.add_fixits (&insert);\n+  ASSERT_FALSE (edit.valid_p ());\n+  ASSERT_EQ (NULL, edit.get_content (filename));\n+  ASSERT_EQ (NULL, edit.generate_diff (false));\n+}\n+\n+/* Verify the boundary conditions of column values in fix-it\n+   hints applied to edit_context instances.  */\n+\n+static void\n+test_applying_fixits_column_validation (const line_table_case &case_)\n+{\n+  /* Create a tempfile and write some text to it.\n+     ........................00000000011111111.\n+     ........................12345678901234567.  */\n+  const char *old_content = \"One-liner file\\n\";\n+  temp_source_file tmp (SELFTEST_LOCATION, \".txt\", old_content);\n+  const char *filename = tmp.get_filename ();\n+  line_table_test ltt (case_);\n+  linemap_add (line_table, LC_ENTER, false, filename, 1);\n+\n+  location_t c11 = linemap_position_for_column (line_table, 11);\n+  location_t c14 = linemap_position_for_column (line_table, 14);\n+  location_t c15 = linemap_position_for_column (line_table, 15);\n+  location_t c16 = linemap_position_for_column (line_table, 16);\n+\n+  /* Verify limits of valid columns in insertion fixits.  */\n+\n+  /* Verify inserting at the end of the line.  */\n+  {\n+    rich_location richloc (line_table, c11);\n+    richloc.add_fixit_insert (c15, \" change\");\n+\n+    /* Col 15 is at the end of the line, so the insertion\n+       should succeed.  */\n+    edit_context edit;\n+    edit.add_fixits (&richloc);\n+    auto_free <char *> new_content = edit.get_content (tmp.get_filename ());\n+    if (c15 <= LINE_MAP_MAX_LOCATION_WITH_COLS)\n+      ASSERT_STREQ (\"One-liner file change\\n\", new_content);\n+    else\n+      ASSERT_EQ (NULL, new_content);\n+  }\n+\n+  /* Verify inserting beyond the end of the line.  */\n+  {\n+    rich_location richloc (line_table, c11);\n+    richloc.add_fixit_insert (c16, \" change\");\n+\n+    /* Col 16 is beyond the end of the line, so the insertion\n+       should fail gracefully.  */\n+    edit_context edit;\n+    ASSERT_TRUE (edit.valid_p ());\n+    edit.add_fixits (&richloc);\n+    ASSERT_FALSE (edit.valid_p ());\n+    ASSERT_EQ (NULL, edit.get_content (filename));\n+    ASSERT_EQ (NULL, edit.generate_diff (false));\n+  }\n+\n+  /* Verify limits of valid columns in replacement fixits.  */\n+\n+  /* Verify replacing the end of the line.  */\n+  {\n+    rich_location richloc (line_table, c11);\n+    source_range range = source_range::from_locations (c11, c14);\n+    richloc.add_fixit_replace (range, \"change\");\n+\n+    /* Col 14 is at the end of the line, so the replacement\n+       should succeed.  */\n+    edit_context edit;\n+    edit.add_fixits (&richloc);\n+    auto_free <char *> new_content = edit.get_content (tmp.get_filename ());\n+    if (c14 <= LINE_MAP_MAX_LOCATION_WITH_COLS)\n+      ASSERT_STREQ (\"One-liner change\\n\", new_content);\n+    else\n+      ASSERT_EQ (NULL, new_content);\n+  }\n+\n+  /* Verify going beyond the end of the line.  */\n+  {\n+    rich_location richloc (line_table, c11);\n+    source_range range = source_range::from_locations (c11, c15);\n+    richloc.add_fixit_replace (range, \"change\");\n+\n+    /* Col 15 is after the end of the line, so the replacement\n+       should fail; verify that the attempt fails gracefully.  */\n+    edit_context edit;\n+    ASSERT_TRUE (edit.valid_p ());\n+    edit.add_fixits (&richloc);\n+    ASSERT_FALSE (edit.valid_p ());\n+    ASSERT_EQ (NULL, edit.get_content (filename));\n+    ASSERT_EQ (NULL, edit.generate_diff (false));\n+  }\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+edit_context_c_tests ()\n+{\n+  test_get_content ();\n+  for_each_line_table_case (test_applying_fixits_insert);\n+  for_each_line_table_case (test_applying_fixits_growing_replace);\n+  for_each_line_table_case (test_applying_fixits_shrinking_replace);\n+  for_each_line_table_case (test_applying_fixits_remove);\n+  for_each_line_table_case (test_applying_fixits_multiple);\n+  for_each_line_table_case (test_applying_fixits_multiple_lines);\n+  for_each_line_table_case (test_applying_fixits_modernize_named_init);\n+  test_applying_fixits_unreadable_file ();\n+  test_applying_fixits_line_out_of_range ();\n+  for_each_line_table_case (test_applying_fixits_column_validation);\n+}\n+\n+} // namespace selftest\n+\n+#endif /* CHECKING_P */"}, {"sha": "842da561991dedc2632a8515e392f4a014add618", "filename": "gcc/edit-context.h", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65236d682789b6a33510aaebfd7e83fe0f30d1a/gcc%2Fedit-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65236d682789b6a33510aaebfd7e83fe0f30d1a/gcc%2Fedit-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fedit-context.h?ref=c65236d682789b6a33510aaebfd7e83fe0f30d1a", "patch": "@@ -0,0 +1,68 @@\n+/* Determining the results of applying fix-it hints.\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_EDIT_CONTEXT_H\n+#define GCC_EDIT_CONTEXT_H\n+\n+#include \"typed-splay-tree.h\"\n+\n+class edit_context;\n+class edited_file;\n+\n+/* A set of changes to the source code.\n+\n+   The changes are \"atomic\" - if any changes can't be applied,\n+   none of them can be (tracked by the m_valid flag).\n+   Similarly, attempts to add the changes from a rich_location flagged\n+   as containing invalid changes mean that the whole of the edit_context\n+   is flagged as invalid.\n+\n+   A complication here is that fix-its are expressed relative to coordinates\n+   in the files when they were parsed, before any changes have been made, and\n+   so if there's more that one fix-it to be applied, we have to adjust\n+   later fix-its to allow for the changes made by earlier ones.  This\n+   is done by the various \"get_effective_column\" methods.  */\n+\n+class edit_context\n+{\n+ public:\n+  edit_context ();\n+\n+  bool valid_p () const { return m_valid; }\n+\n+  void add_fixits (rich_location *richloc);\n+\n+  char *get_content (const char *filename);\n+\n+  int get_effective_column (const char *filename, int line, int column);\n+\n+  char *generate_diff (bool show_filenames);\n+  void print_diff (pretty_printer *pp, bool show_filenames);\n+\n+ private:\n+  bool apply_insert (const fixit_insert *insert);\n+  bool apply_replace (const fixit_replace *replace);\n+  edited_file *get_file (const char *filename);\n+  edited_file &get_or_insert_file (const char *filename);\n+\n+  bool m_valid;\n+  typed_splay_tree<const char *, edited_file *> m_files;\n+};\n+\n+#endif /* GCC_EDIT_CONTEXT_H.  */"}, {"sha": "55bff4891ef279e78858c5a3a093823f1ac330d2", "filename": "gcc/input.c", "status": "modified", "additions": 38, "deletions": 9, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65236d682789b6a33510aaebfd7e83fe0f30d1a/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65236d682789b6a33510aaebfd7e83fe0f30d1a/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=c65236d682789b6a33510aaebfd7e83fe0f30d1a", "patch": "@@ -95,6 +95,11 @@ struct fcache\n      before the line map has seen the end of the file.  */\n   size_t total_lines;\n \n+  /* Could this file be missing a trailing newline on its final line?\n+     Initially true (to cope with empty files), set to true/false\n+     as each line is read.  */\n+  bool missing_trailing_newline;\n+\n   /* This is a record of the beginning and end of the lines we've seen\n      while reading the file.  This is useful to avoid walking the data\n      from the beginning when we are asked to read a line that is\n@@ -280,6 +285,7 @@ diagnostics_file_cache_forcibly_evict_file (const char *file_path)\n   r->line_record.truncate (0);\n   r->use_count = 0;\n   r->total_lines = 0;\n+  r->missing_trailing_newline = true;\n }\n \n /* Return the file cache that has been less used, recently, or the\n@@ -348,6 +354,7 @@ add_file_to_cache_tab (const char *file_path)\n      add_file_to_cache_tab is called.  */\n   r->use_count = ++highest_use_count;\n   r->total_lines = total_lines_num (file_path);\n+  r->missing_trailing_newline = true;\n \n   return r;\n }\n@@ -372,7 +379,7 @@ lookup_or_add_file_to_cache_tab (const char *file_path)\n fcache::fcache ()\n : use_count (0), file_path (NULL), fp (NULL), data (0),\n   size (0), nb_read (0), line_start_idx (0), line_num (0),\n-  total_lines (0)\n+  total_lines (0), missing_trailing_newline (true)\n {\n   line_record.create (0);\n }\n@@ -507,16 +514,24 @@ get_next_line (fcache *c, char **line, ssize_t *line_len)\n \t    }\n \t}\n       if (line_end == NULL)\n-\t/* We've loadded all the file into the cache and still no\n-\t   '\\n'.  Let's say the line ends up at one byte passed the\n-\t   end of the file.  This is to stay consistent with the case\n-\t   of when the line ends up with a '\\n' and line_end points to\n-\t   that terminal '\\n'.  That consistency is useful below in\n-\t   the len calculation.  */\n-\tline_end = c->data + c->nb_read ;\n+\t{\n+\t  /* We've loadded all the file into the cache and still no\n+\t     '\\n'.  Let's say the line ends up at one byte passed the\n+\t     end of the file.  This is to stay consistent with the case\n+\t     of when the line ends up with a '\\n' and line_end points to\n+\t     that terminal '\\n'.  That consistency is useful below in\n+\t     the len calculation.  */\n+\t  line_end = c->data + c->nb_read ;\n+\t  c->missing_trailing_newline = true;\n+\t}\n+      else\n+\tc->missing_trailing_newline = false;\n     }\n   else\n-    next_line_start = line_end + 1;\n+    {\n+      next_line_start = line_end + 1;\n+      c->missing_trailing_newline = false;\n+    }\n \n   if (ferror (c->fp))\n     return -1;\n@@ -751,6 +766,20 @@ location_get_source_line (const char *file_path, int line,\n   return read ? buffer : NULL;\n }\n \n+/* Determine if FILE_PATH missing a trailing newline on its final line.\n+   Only valid to call once all of the file has been loaded, by\n+   requesting a line number beyond the end of the file.  */\n+\n+bool\n+location_missing_trailing_newline (const char *file_path)\n+{\n+  fcache *c = lookup_or_add_file_to_cache_tab (file_path);\n+  if (c == NULL)\n+    return false;\n+\n+  return c->missing_trailing_newline;\n+}\n+\n /* Test if the location originates from the spelling location of a\n    builtin-tokens.  That is, return TRUE if LOC is a (possibly\n    virtual) location of a built-in token that appears in the expansion"}, {"sha": "e95bd3cb1a9641e783af213c270dea3ff5d728a1", "filename": "gcc/input.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65236d682789b6a33510aaebfd7e83fe0f30d1a/gcc%2Finput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65236d682789b6a33510aaebfd7e83fe0f30d1a/gcc%2Finput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.h?ref=c65236d682789b6a33510aaebfd7e83fe0f30d1a", "patch": "@@ -41,6 +41,7 @@ extern bool is_location_from_builtin_token (source_location);\n extern expanded_location expand_location (source_location);\n extern const char *location_get_source_line (const char *file_path, int line,\n \t\t\t\t\t     int *line_size);\n+extern bool location_missing_trailing_newline (const char *file_path);\n extern expanded_location expand_location_to_spelling_point (source_location);\n extern source_location expansion_point_location_if_in_system_header (source_location);\n extern source_location expansion_point_location (source_location);"}, {"sha": "d9d3ea13ab63d4e8c7f45f502bd895f4fa7a7154", "filename": "gcc/selftest-run-tests.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65236d682789b6a33510aaebfd7e83fe0f30d1a/gcc%2Fselftest-run-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65236d682789b6a33510aaebfd7e83fe0f30d1a/gcc%2Fselftest-run-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest-run-tests.c?ref=c65236d682789b6a33510aaebfd7e83fe0f30d1a", "patch": "@@ -68,6 +68,7 @@ selftest::run_tests ()\n      rely on.  */\n   diagnostic_show_locus_c_tests ();\n   diagnostic_c_tests ();\n+  edit_context_c_tests ();\n   fold_const_c_tests ();\n   spellcheck_c_tests ();\n   spellcheck_tree_c_tests ();"}, {"sha": "9b6fa952f6bc6635fd24fd1c0d6462da018dc018", "filename": "gcc/selftest.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65236d682789b6a33510aaebfd7e83fe0f30d1a/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65236d682789b6a33510aaebfd7e83fe0f30d1a/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=c65236d682789b6a33510aaebfd7e83fe0f30d1a", "patch": "@@ -151,6 +151,7 @@ for_each_line_table_case (void (*testcase) (const line_table_case &));\n extern void bitmap_c_tests ();\n extern void diagnostic_c_tests ();\n extern void diagnostic_show_locus_c_tests ();\n+extern void edit_context_c_tests ();\n extern void et_forest_c_tests ();\n extern void fold_const_c_tests ();\n extern void fibonacci_heap_c_tests ();"}, {"sha": "792f76ae3b5ec03cb1afc585d5c6b42ed07e3d7b", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65236d682789b6a33510aaebfd7e83fe0f30d1a/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65236d682789b6a33510aaebfd7e83fe0f30d1a/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=c65236d682789b6a33510aaebfd7e83fe0f30d1a", "patch": "@@ -1,3 +1,8 @@\n+2016-09-02  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* include/line-map.h (rich_location::seen_impossible_fixit_p): New\n+\taccessor.\n+\n 2016-08-31  David Malcolm  <dmalcolm@redhat.com>\n \n \t* include/line-map.h (class fixit_remove): Remove stray decl."}, {"sha": "6b3c474a0de9246a6a19e44c9e2412135f2439b1", "filename": "libcpp/include/line-map.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c65236d682789b6a33510aaebfd7e83fe0f30d1a/libcpp%2Finclude%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c65236d682789b6a33510aaebfd7e83fe0f30d1a/libcpp%2Finclude%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fline-map.h?ref=c65236d682789b6a33510aaebfd7e83fe0f30d1a", "patch": "@@ -1567,6 +1567,7 @@ class rich_location\n   unsigned int get_num_fixit_hints () const { return m_fixit_hints.count (); }\n   fixit_hint *get_fixit_hint (int idx) const { return m_fixit_hints[idx]; }\n   fixit_hint *get_last_fixit_hint () const;\n+  bool seen_impossible_fixit_p () const { return m_seen_impossible_fixit; }\n \n private:\n   bool reject_impossible_fixit (source_location where);"}]}