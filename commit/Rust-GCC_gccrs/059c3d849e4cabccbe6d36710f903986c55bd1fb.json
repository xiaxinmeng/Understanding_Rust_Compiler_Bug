{"sha": "059c3d849e4cabccbe6d36710f903986c55bd1fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU5YzNkODQ5ZTRjYWJjY2JlNmQzNjcxMGY5MDM5ODZjNTViZDFmYg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-10-23T20:27:44Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-10-23T20:27:44Z"}, "message": "(expand_call): In target code, move PARALLEL case above\ntarget != case.\n\nFrom-SVN: r13010", "tree": {"sha": "574236e4335c133ca437f8a443f4681406cdb7f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/574236e4335c133ca437f8a443f4681406cdb7f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/059c3d849e4cabccbe6d36710f903986c55bd1fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/059c3d849e4cabccbe6d36710f903986c55bd1fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/059c3d849e4cabccbe6d36710f903986c55bd1fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/059c3d849e4cabccbe6d36710f903986c55bd1fb/comments", "author": null, "committer": null, "parents": [{"sha": "dd98f85c9a6430e028f6e9dc91a1531fb04c843c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd98f85c9a6430e028f6e9dc91a1531fb04c843c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd98f85c9a6430e028f6e9dc91a1531fb04c843c"}], "stats": {"total": 18, "additions": 9, "deletions": 9}, "files": [{"sha": "9f9d65909f432d0871301def36c1601e3b4825c3", "filename": "gcc/calls.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/059c3d849e4cabccbe6d36710f903986c55bd1fb/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/059c3d849e4cabccbe6d36710f903986c55bd1fb/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=059c3d849e4cabccbe6d36710f903986c55bd1fb", "patch": "@@ -2022,15 +2022,6 @@ expand_call (exp, target, ignore)\n \t\t\t expr_size (exp),\n \t\t\t TYPE_ALIGN (TREE_TYPE (exp)) / BITS_PER_UNIT);\n     }\n-  else if (target && GET_MODE (target) == TYPE_MODE (TREE_TYPE (exp))\n-\t   && GET_MODE (target) == GET_MODE (valreg))\n-    /* TARGET and VALREG cannot be equal at this point because the latter\n-       would not have REG_FUNCTION_VALUE_P true, while the former would if\n-       it were referring to the same register.\n-\n-       If they refer to the same register, this move will be a no-op, except\n-       when function inlining is being done.  */\n-    emit_move_insn (target, valreg);\n   /* Handle calls that return values in multiple non-contiguous locations.\n      The Irix 6 ABI has examples of this.  */\n   else if (GET_CODE (valreg) == PARALLEL)\n@@ -2045,6 +2036,15 @@ expand_call (exp, target, ignore)\n \n       emit_group_store (target, valreg);\n     }\n+  else if (target && GET_MODE (target) == TYPE_MODE (TREE_TYPE (exp))\n+\t   && GET_MODE (target) == GET_MODE (valreg))\n+    /* TARGET and VALREG cannot be equal at this point because the latter\n+       would not have REG_FUNCTION_VALUE_P true, while the former would if\n+       it were referring to the same register.\n+\n+       If they refer to the same register, this move will be a no-op, except\n+       when function inlining is being done.  */\n+    emit_move_insn (target, valreg);\n   else if (TYPE_MODE (TREE_TYPE (exp)) == BLKmode)\n     {\n       /* Some machines (the PA for example) want to return all small"}]}