{"sha": "5e19c0539080471ad7097fa5c441031334f12bdd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWUxOWMwNTM5MDgwNDcxYWQ3MDk3ZmE1YzQ0MTAzMTMzNGYxMmJkZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-01-31T21:00:01Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-01-31T21:00:01Z"}, "message": "cp-tree.h (BINFO_VIRTUALS): Tweak documentation.\n\n\t* cp-tree.h (BINFO_VIRTUALS): Tweak documentation.\n\t(CLASSTYPE_PRIMARY_BINFO): Use BINFO_PRIMARY_BINFO.\n\t(BINFO_PRIMARY_BINFO): New macro.\n\t(BF_DELTA): Rename to ...\n\t(BV_DELTA): ... this.\n\t(BF_VCALL_INDEX): Rename to ...\n\t(BV_VCALL_INDEX): ... this.\n\t(BF_FN): Rename to ...\n\t(BV_FN): ... this.\n\t* class.c (build_vbase_path): Adjust for changes to reverse_path.\n\t(set_rtti_entry): Rename BF_ macros to BV_ variants.\n\t(modify_vtable_entry): Simplify.\n\t(add_virtual_function): Rename BF_ macros to BV_ variants.\n\t(build_vtable_initializer): Likewise.\n\t(get_class_offset_1): Remove.\n\t(dfs_get_class_offset): Likewise.\n\t(get_class_offset): Likewise.\n\t(dfs_find_final_overrider): New function.\n\t(find_final_overrider): Likewise.\n\t(modify_one_vtable): Remove.\n\t(dfs_find_base): New function.\n\t(dfs_modify_vtables): Fold modify_one_vtable in here.  Use\n\tfind_final_overrider.\n\t(modify_all_vtables): Adjust.  Set BV_VCALL_INDEX on new\n\tvirtuals.\n\t(dfs_fixup_vtable_deltas): Remove.\n\t(override_one_vtable): Remove.\n\t(merge_overrides): Likewise.\n\t(layout_virtual_bases): Make sure BINFO_OFFSET is set right for\n\tunreal chilren of virtual bases.\n\t(finish_struct_1): Don't use merge_overrides.  Don't use\n\tdfs_fixup_vtable_deltas.\n\t* tree.c (reverse_path): Return a TREE_LIST, not a chain of\n\tBINFOs.\n\nFrom-SVN: r31724", "tree": {"sha": "9d11b66fb3519c817dc45d1c1ad7fdca554ed8ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d11b66fb3519c817dc45d1c1ad7fdca554ed8ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e19c0539080471ad7097fa5c441031334f12bdd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e19c0539080471ad7097fa5c441031334f12bdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e19c0539080471ad7097fa5c441031334f12bdd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e19c0539080471ad7097fa5c441031334f12bdd/comments", "author": null, "committer": null, "parents": [{"sha": "d4cf5733ee1a1e5efded2df9800e6edd64a944bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4cf5733ee1a1e5efded2df9800e6edd64a944bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4cf5733ee1a1e5efded2df9800e6edd64a944bd"}], "stats": {"total": 784, "additions": 311, "deletions": 473}, "files": [{"sha": "50848be67693b7ac1fd6c523eb630594e755c656", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e19c0539080471ad7097fa5c441031334f12bdd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e19c0539080471ad7097fa5c441031334f12bdd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5e19c0539080471ad7097fa5c441031334f12bdd", "patch": "@@ -1,3 +1,40 @@\n+2000-01-31  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (BINFO_VIRTUALS): Tweak documentation.\n+\t(CLASSTYPE_PRIMARY_BINFO): Use BINFO_PRIMARY_BINFO.\n+\t(BINFO_PRIMARY_BINFO): New macro.\n+\t(BF_DELTA): Rename to ...\n+\t(BV_DELTA): ... this.\n+\t(BF_VCALL_INDEX): Rename to ...\n+\t(BV_VCALL_INDEX): ... this.\n+\t(BF_FN): Rename to ...\n+\t(BV_FN): ... this.\n+\t* class.c (build_vbase_path): Adjust for changes to reverse_path.\n+\t(set_rtti_entry): Rename BF_ macros to BV_ variants.\n+\t(modify_vtable_entry): Simplify.\n+\t(add_virtual_function): Rename BF_ macros to BV_ variants.\n+\t(build_vtable_initializer): Likewise.\n+\t(get_class_offset_1): Remove.\n+\t(dfs_get_class_offset): Likewise.\n+\t(get_class_offset): Likewise.\n+\t(dfs_find_final_overrider): New function.\n+\t(find_final_overrider): Likewise.\n+\t(modify_one_vtable): Remove.\n+\t(dfs_find_base): New function.\n+\t(dfs_modify_vtables): Fold modify_one_vtable in here.  Use\n+\tfind_final_overrider.\n+\t(modify_all_vtables): Adjust.  Set BV_VCALL_INDEX on new\n+\tvirtuals.\n+\t(dfs_fixup_vtable_deltas): Remove.\n+\t(override_one_vtable): Remove.\n+\t(merge_overrides): Likewise.\n+\t(layout_virtual_bases): Make sure BINFO_OFFSET is set right for\n+\tunreal chilren of virtual bases.\n+\t(finish_struct_1): Don't use merge_overrides.  Don't use\n+\tdfs_fixup_vtable_deltas.\n+\t* tree.c (reverse_path): Return a TREE_LIST, not a chain of \n+\tBINFOs.\n+\t\n 2000-01-31  Herman A.J. ten Brugge <Haj.Ten.Brugge@net.HCC.nl>\n \t    Jason Merrill  <jason@yorick.cygnus.com>\n "}, {"sha": "40f8383141cf3e07c81e84f8b9f83d56f038615f", "filename": "gcc/cp/class.c", "status": "modified", "additions": 238, "deletions": 450, "changes": 688, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e19c0539080471ad7097fa5c441031334f12bdd/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e19c0539080471ad7097fa5c441031334f12bdd/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=5e19c0539080471ad7097fa5c441031334f12bdd", "patch": "@@ -82,10 +82,9 @@ static tree get_basefndecls PARAMS ((tree, tree));\n static void set_rtti_entry PARAMS ((tree, tree, tree));\n static int build_primary_vtable PARAMS ((tree, tree));\n static int build_secondary_vtable PARAMS ((tree, tree));\n-static tree dfs_fixup_vtable_deltas PARAMS ((tree, void *));\n static tree dfs_finish_vtbls PARAMS ((tree, void *));\n static void finish_vtbls PARAMS ((tree));\n-static void modify_vtable_entry PARAMS ((tree, tree, tree, tree *));\n+static void modify_vtable_entry PARAMS ((tree, tree, tree, tree, tree *));\n static void add_virtual_function PARAMS ((tree *, tree *, int *, tree, tree));\n static tree delete_duplicate_fields_1 PARAMS ((tree, tree));\n static void delete_duplicate_fields PARAMS ((tree));\n@@ -94,13 +93,8 @@ static int alter_access PARAMS ((tree, tree, tree, tree));\n static void handle_using_decl PARAMS ((tree, tree));\n static int overrides PARAMS ((tree, tree));\n static int strictly_overrides PARAMS ((tree, tree));\n-static void merge_overrides PARAMS ((tree, tree, int, tree));\n-static void override_one_vtable PARAMS ((tree, tree, tree));\n static void mark_overriders PARAMS ((tree, tree));\n static void check_for_override PARAMS ((tree, tree));\n-static tree dfs_get_class_offset PARAMS ((tree, void *));\n-static tree get_class_offset PARAMS ((tree, tree, tree, tree));\n-static void modify_one_vtable PARAMS ((tree, tree, tree));\n static tree dfs_modify_vtables PARAMS ((tree, void *));\n static tree modify_all_vtables PARAMS ((tree, int *, tree));\n static void determine_primary_base PARAMS ((tree, int *));\n@@ -151,6 +145,9 @@ static tree dfs_count_virtuals PARAMS ((tree, void *));\n static void start_vtable PARAMS ((tree, int *));\n static void layout_vtable_decl PARAMS ((tree, int));\n static int num_vfun_entries PARAMS ((tree));\n+static tree dfs_find_final_overrider PARAMS ((tree, void *));\n+static tree find_final_overrider PARAMS ((tree, tree, tree));\n+static tree dfs_find_base PARAMS ((tree, void *));\n static int make_new_vtable PARAMS ((tree, tree));\n \n /* Variables shared between class.c and call.c.  */\n@@ -558,16 +555,15 @@ build_vbase_path (code, type, expr, path, nonnull)\n     expr = save_expr (expr);\n   nonnull_expr = expr;\n \n-  if (BINFO_INHERITANCE_CHAIN (path))\n-    path = reverse_path (path);\n+  path = reverse_path (path);\n \n   basetype = BINFO_TYPE (path);\n \n   while (path)\n     {\n-      if (TREE_VIA_VIRTUAL (path))\n+      if (TREE_VIA_VIRTUAL (TREE_VALUE (path)))\n \t{\n-\t  last_virtual = BINFO_TYPE (path);\n+\t  last_virtual = BINFO_TYPE (TREE_VALUE (path));\n \t  if (code == PLUS_EXPR)\n \t    {\n \t      changed = ! fixed_type_p;\n@@ -609,8 +605,8 @@ build_vbase_path (code, type, expr, path, nonnull)\n \t      return error_mark_node;\n \t    }\n \t}\n-      last = path;\n-      path = BINFO_INHERITANCE_CHAIN (path);\n+      last = TREE_VALUE (path);\n+      path = TREE_CHAIN (path);\n     }\n   /* LAST is now the last basetype assoc on the path.  */\n \n@@ -981,18 +977,18 @@ set_rtti_entry (virtuals, offset, type)\n   if (flag_vtable_thunks)\n     {\n       /* The first slot holds the offset.  */\n-      BF_DELTA (virtuals) = offset;\n-      BF_VCALL_INDEX (virtuals) = integer_zero_node;\n+      BV_DELTA (virtuals) = offset;\n+      BV_VCALL_INDEX (virtuals) = integer_zero_node;\n \n       /* The next node holds the decl.  */\n       virtuals = TREE_CHAIN (virtuals);\n       offset = integer_zero_node;\n     }\n \n   /* This slot holds the function to call.  */\n-  BF_DELTA (virtuals) = offset;\n-  BF_VCALL_INDEX (virtuals) = integer_zero_node;\n-  BF_FN (virtuals) = decl;\n+  BV_DELTA (virtuals) = offset;\n+  BV_VCALL_INDEX (virtuals) = integer_zero_node;\n+  BV_FN (virtuals) = decl;\n }\n \n /* Get the VAR_DECL of the vtable for TYPE. TYPE need not be polymorphic,\n@@ -1289,44 +1285,27 @@ make_new_vtable (t, binfo)\n \n /* Make *VIRTUALS, an entry on the BINFO_VIRTUALS list for BINFO\n    (which is in the hierarchy dominated by T) list FNDECL as its\n-   BF_FN.  */\n+   BV_FN.  DELTA is the required adjustment from the `this' pointer\n+   where the vtable entry appears to the `this' required when the\n+   function is actually called.  */\n \n static void\n-modify_vtable_entry (t, binfo, fndecl, virtuals)\n+modify_vtable_entry (t, binfo, fndecl, delta, virtuals)\n      tree t;\n      tree binfo;\n      tree fndecl;\n+     tree delta;\n      tree *virtuals;\n {\n-  tree base_offset;\n-  tree offset;\n-  tree context;\n-  tree this_offset;\n   tree vcall_index;\n   tree v;\n \n   v = *virtuals;\n-  context = DECL_CLASS_CONTEXT (fndecl);\n-  offset = get_class_offset (context, t, binfo, fndecl);\n-\n-  /* Find the right offset for ythe this pointer based on the\n-     base class we just found.  We have to take into\n-     consideration the virtual base class pointers that we\n-     stick in before the virtual function table pointer.\n-\n-     Also, we want just the delta between the most base class\n-     that we derived this vfield from and us.  */\n-  base_offset \n-    = size_binop (PLUS_EXPR,\n-\t\t  get_derived_offset (binfo, \n-\t\t\t\t      DECL_VIRTUAL_CONTEXT (BF_FN (v))),\n-\t\t  BINFO_OFFSET (binfo));\n-  this_offset = ssize_binop (MINUS_EXPR, offset, base_offset);\n   vcall_index = integer_zero_node;\n \n-  if (fndecl != BF_FN (v)\n-      || !tree_int_cst_equal (this_offset, BF_DELTA (v))\n-      || !tree_int_cst_equal (vcall_index, BF_VCALL_INDEX (v)))\n+  if (fndecl != BV_FN (v)\n+      || !tree_int_cst_equal (delta, BV_DELTA (v))\n+      || !tree_int_cst_equal (vcall_index, BV_VCALL_INDEX (v)))\n     {\n       tree base_fndecl;\n \n@@ -1337,15 +1316,15 @@ modify_vtable_entry (t, binfo, fndecl, virtuals)\n \t     of the BINFO_VIRTUALS list.  Now, we have to find the\n \t     corresponding entry in that list.  */\n \t  *virtuals = BINFO_VIRTUALS (binfo);\n-\t  while (BF_FN (*virtuals) != BF_FN (v))\n+\t  while (BV_FN (*virtuals) != BV_FN (v))\n \t    *virtuals = TREE_CHAIN (*virtuals);\n \t  v = *virtuals;\n \t}\n \n-      base_fndecl = BF_FN (v);\n-      BF_DELTA (v) = this_offset;\n-      BF_VCALL_INDEX (v) = vcall_index;\n-      BF_FN (v) = fndecl;\n+      base_fndecl = BV_FN (v);\n+      BV_DELTA (v) = delta;\n+      BV_VCALL_INDEX (v) = vcall_index;\n+      BV_FN (v) = fndecl;\n \n       /* Now assign virtual dispatch information, if unset.  We can\n \t dispatch this, through any overridden base function.  */\n@@ -1407,7 +1386,7 @@ add_virtual_function (new_virtuals_p, overridden_virtuals_p,\n     return;\n \n   new_virtual = build_tree_list (integer_zero_node, fndecl);\n-  BF_VCALL_INDEX (new_virtual) = integer_zero_node;\n+  BV_VCALL_INDEX (new_virtual) = integer_zero_node;\n \n   if (DECL_VINDEX (fndecl) == error_mark_node)\n     {\n@@ -2713,9 +2692,9 @@ build_vtbl_initializer (binfo, t)\n \n       /* Pull the offset for `this', and the function to call, out of\n \t the list.  */\n-      delta = BF_DELTA (v);\n-      vcall_index = BF_VCALL_INDEX (v);\n-      fn = BF_FN (v);\n+      delta = BV_DELTA (v);\n+      vcall_index = BV_VCALL_INDEX (v);\n+      fn = BV_FN (v);\n       my_friendly_assert (TREE_CODE (delta) == INTEGER_CST, 19990727);\n       my_friendly_assert (TREE_CODE (fn) == FUNCTION_DECL, 19990727);\n \n@@ -2812,127 +2791,151 @@ overrides (fndecl, base_fndecl)\n   return 0;\n }\n \n-/* Returns the BINFO_OFFSET for the base of BINFO that has the same\n-   type as CONTEXT.  */\n+typedef struct find_final_overrider_data_s {\n+  /* The function for which we are trying to find a final overrider.  */\n+  tree fn;\n+  /* The base class in which the function was declared.  */\n+  tree declaring_base;\n+  /* The most derived class in the hierarchy.  */\n+  tree most_derived_type;\n+  /* The final overriding function.  */\n+  tree overriding_fn;\n+  /* The BINFO for the class in which the final overriding function\n+     appears.  */\n+  tree overriding_base;\n+} find_final_overrider_data;\n+\n+/* Called from find_final_overrider via dfs_walk.  */\n \n static tree\n-get_class_offset_1 (parent, binfo, context, t, fndecl)\n-     tree parent, binfo, context, t, fndecl;\n+dfs_find_final_overrider (binfo, data)\n+     tree binfo;\n+     void *data;\n {\n-  tree binfos = BINFO_BASETYPES (binfo);\n-  int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-  tree rval = NULL_TREE;\n-\n-  if (binfo == parent)\n-    return error_mark_node;\n+  find_final_overrider_data *ffod = (find_final_overrider_data *) data;\n \n-  for (i = 0; i < n_baselinks; i++)\n+  if (same_type_p (BINFO_TYPE (binfo), \n+\t\t   BINFO_TYPE (ffod->declaring_base))\n+      && tree_int_cst_equal (BINFO_OFFSET (binfo),\n+\t\t\t     BINFO_OFFSET (ffod->declaring_base)))\n     {\n-      tree base_binfo = TREE_VEC_ELT (binfos, i);\n-      tree nrval;\n+      tree path;\n+      tree method;\n \n-      if (TREE_VIA_VIRTUAL (base_binfo))\n-\tbase_binfo = BINFO_FOR_VBASE (BINFO_TYPE (base_binfo), t);\n-      nrval = get_class_offset_1 (parent, base_binfo, context, t, fndecl);\n-      /* See if we have a new value */\n-      if (nrval && (nrval != error_mark_node || rval==0))\n+      /* We've found a path to the declaring base.  Walk down the path\n+\t looking for an overrider for FN.  */\n+      for (path = reverse_path (binfo); \n+\t   path; \n+\t   path = TREE_CHAIN (path))\n \t{\n-\t  /* Only compare if we have two offsets */\n-\t  if (rval && rval != error_mark_node\n-\t      && ! tree_int_cst_equal (nrval, rval))\n-\t    {\n-\t      /* Only give error if the two offsets are different */\n-\t      error (\"every virtual function must have a unique final overrider\");\n-\t      cp_error (\"  found two (or more) `%T' class subobjects in `%T'\", context, t);\n-\t      cp_error (\"  with virtual `%D' from virtual base class\", fndecl);\n-\t      return rval;\n-\t    }\n-\t  rval = nrval;\n+\t  for (method = TYPE_METHODS (BINFO_TYPE (TREE_VALUE (path)));\n+\t       method;\n+\t       method = TREE_CHAIN (method))\n+\t    if (DECL_VIRTUAL_P (method) && overrides (method, ffod->fn))\n+\t      break;\n+\n+\t  if (method)\n+\t    break;\n \t}\n-\t\n-      if (rval && BINFO_TYPE (binfo) == context)\n+\n+      /* If we found an overrider, record the overriding function, and\n+\t the base from which it came.  */\n+      if (path)\n \t{\n-\t  my_friendly_assert (rval == error_mark_node\n-\t\t\t      || tree_int_cst_equal (rval, BINFO_OFFSET (binfo)), 999);\n-\t  rval = BINFO_OFFSET (binfo);\n+\t  if (ffod->overriding_fn && ffod->overriding_fn != method)\n+\t    {\n+\t      /* We've found a different overrider along a different\n+\t\t path.  That can be OK if the new one overrides the\n+\t\t old one.  Consider:\n+\t      \n+\t           struct S { virtual void f(); };\n+\t           struct T : public virtual S { virtual void f(); };\n+\t           struct U : public virtual S, public virtual T {};\n+\t      \n+\t         Here `T::f' is the final overrider for `S::f'.  */\n+\t      if (strictly_overrides (method, ffod->overriding_fn))\n+\t\t{\n+\t\t  ffod->overriding_fn = method;\n+\t\t  ffod->overriding_base = TREE_VALUE (path);\n+\t\t}\n+\t      else if (!strictly_overrides (ffod->overriding_fn, method))\n+\t\t{\n+\t\t  cp_error (\"no unique final overrider for `%D' in `%T'\", \n+\t\t\t    ffod->most_derived_type,\n+\t\t\t    ffod->fn);\n+\t\t  cp_error (\"candidates are: `%#D'\", ffod->overriding_fn);\n+\t\t  cp_error (\"                `%#D'\", method);\n+\t\t  return error_mark_node;\n+\t\t}\n+\t    }\n+\t  else if (ffod->overriding_base\n+\t\t   && (!tree_int_cst_equal \n+\t\t       (BINFO_OFFSET (TREE_VALUE (path)),\n+\t\t\tBINFO_OFFSET (ffod->overriding_base))))\n+\t    {\n+\t      /* We've found two instances of the same base that\n+\t\t provide overriders.  */\n+\t      cp_error (\"no unique final overrider for `%D' since there two instances of `%T' in `%T'\", \n+\t\t\tffod->fn,\n+\t\t\tBINFO_TYPE (ffod->overriding_base),\n+\t\t\tffod->most_derived_type);\n+\t      return error_mark_node;\n+\t    }\n+\t  else\n+\t    {\n+\t      ffod->overriding_fn = method;\n+\t      ffod->overriding_base = TREE_VALUE (path);\n+\t    }\n \t}\n     }\n-  return rval;\n-}\n-\n-/* Called from get_class_offset via dfs_walk.  */\n-\n-static tree\n-dfs_get_class_offset (binfo, data)\n-     tree binfo;\n-     void *data;\n-{\n-  tree list = (tree) data;\n-  tree context = TREE_TYPE (list);\n-\n-  if (same_type_p (BINFO_TYPE (binfo), context))\n-    {\n-      if (TREE_VALUE (list))\n-\treturn error_mark_node;\n-      else\n-\tTREE_VALUE (list) = BINFO_OFFSET (binfo);\n-    }\n-  \n-  SET_BINFO_MARKED (binfo);\n \n   return NULL_TREE;\n }\n \n-/* Returns the BINFO_OFFSET for the subobject of BINFO that has the\n-   type given by CONTEXT.  */\n+/* Returns a TREE_LIST whose TREE_PURPOSE is the final overrider for\n+   FN and whose TREE_VALUE is the binfo for the base where the\n+   overriding occurs.  BINFO (in the hierarchy dominated by T) is the\n+   base object in which FN is declared.  */\n \n static tree\n-get_class_offset (context, t, binfo, fndecl)\n-     tree context, t, binfo, fndecl;\n+find_final_overrider (t, binfo, fn)\n+     tree t;\n+     tree binfo;\n+     tree fn;\n {\n-  tree list;\n-  tree offset;\n-  int i;\n+  find_final_overrider_data ffod;\n \n-  if (context == t)\n-    return integer_zero_node;\n+  /* Getting this right is a little tricky.  This is legal:\n \n-  if (BINFO_TYPE (binfo) == context)\n-    return BINFO_OFFSET (binfo);\n+       struct S { virtual void f (); };\n+       struct T { virtual void f (); };\n+       struct U : public S, public T { };\n \n-  /* Check less derived binfos first.  */\n-  while (BINFO_BASETYPES (binfo)\n-\t && (i=CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo))) != -1)\n-    {\n-      tree binfos = BINFO_BASETYPES (binfo);\n-      binfo = TREE_VEC_ELT (binfos, i);\n-      if (BINFO_TYPE (binfo) == context)\n-\treturn BINFO_OFFSET (binfo);\n-    }\n+     even though calling `f' in `U' is ambiguous.  But, \n \n-  list = build_tree_list (t, NULL_TREE);\n-  TREE_TYPE (list) = context;\n-  offset = dfs_walk (TYPE_BINFO (t),\n-\t\t     dfs_get_class_offset,\n-\t\t     dfs_unmarked_real_bases_queue_p,\n-\t\t     list);\n-  dfs_walk (TYPE_BINFO (t), dfs_unmark, dfs_marked_real_bases_queue_p, t);\n-\n-  if (offset == error_mark_node)\n-    {\n-      error (\"every virtual function must have a unique final overrider\");\n-      cp_error (\"  found two (or more) `%T' class subobjects in `%T'\", \n-\t\tcontext, t);\n-      cp_error (\"  with virtual `%D' from virtual base class\", fndecl);\n-      offset = integer_zero_node;\n-    }\n-  else\n-    offset = TREE_VALUE (list);\n+       struct R { virtual void f(); };\n+       struct S : virtual public R { virtual void f (); };\n+       struct T : virtual public R { virtual void f (); };\n+       struct U : public S, public T { };\n \n-  my_friendly_assert (offset != NULL_TREE, 999);\n-  my_friendly_assert (TREE_CODE (offset) == INTEGER_CST, 999);\n+     is not -- there's no way  to decide whether to put `S::f' or\n+     `T::f' in the vtable for `R'.  \n+     \n+     The solution is to look at all paths to BINFO.  If we find\n+     different overriders along any two, then there is a problem.  */\n+  ffod.fn = fn;\n+  ffod.declaring_base = binfo;\n+  ffod.most_derived_type = t;\n+  ffod.overriding_fn = NULL_TREE;\n+  ffod.overriding_base = NULL_TREE;\n+\n+  if (dfs_walk (TYPE_BINFO (t),\n+\t\tdfs_find_final_overrider,\n+\t\tNULL,\n+\t\t&ffod))\n+    return error_mark_node;\n \n-  return offset;\n+  return build_tree_list (ffod.overriding_fn, ffod.overriding_base);\n }\n \n /* Return the BINFO_VIRTUALS list for BINFO, without the RTTI stuff at\n@@ -2972,37 +2975,16 @@ skip_rtti_stuff (binfo, t, n)\n   return virtuals;\n }\n \n-static void\n-modify_one_vtable (binfo, t, fndecl)\n-     tree binfo, t, fndecl;\n-{\n-  tree virtuals;\n-  \n-  /* If we're support RTTI then we always need a new vtable to point\n-     to the RTTI information.  Under the new ABI we may need a new\n-     vtable to contain vcall and vbase offsets.  */\n-  if (flag_rtti || flag_new_abi)\n-    make_new_vtable (t, binfo);\n-\n-  if (fndecl == NULL_TREE)\n-    return;\n-\n-  for (virtuals = skip_rtti_stuff (binfo, BINFO_TYPE (binfo), NULL);\n-       virtuals;\n-       virtuals = TREE_CHAIN (virtuals))\n-    {\n-      tree current_fndecl = BF_FN (virtuals);\n+/* Called via dfs_walk.  Returns BINFO if BINFO has the same type as\n+   DATA (which is really an _TYPE node).  */\n \n-      /* We should never have an instance of __pure_virtual on the\n-\t BINFO_VIRTUALS list.  If we do, then we will never notice\n-\t that the function that should have been there instead has\n-\t been overridden.  */\n-      my_friendly_assert (current_fndecl != abort_fndecl,\n-\t\t\t  19990727);\n-\n-      if (current_fndecl && overrides (fndecl, current_fndecl))\n-\tmodify_vtable_entry (t, binfo, fndecl, &virtuals);\n-    }\n+static tree\n+dfs_find_base (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  return (same_type_p (BINFO_TYPE (binfo), (tree) data)\n+\t  ? binfo : NULL_TREE);\n }\n \n /* Called from modify_all_vtables via dfs_walk.  */\n@@ -3018,8 +3000,70 @@ dfs_modify_vtables (binfo, data)\n       /* Similarly, a base without a vtable needs no modification.  */\n       && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo)))\n     {\n-      tree list = (tree) data;\n-      modify_one_vtable (binfo, TREE_PURPOSE (list), TREE_VALUE (list)); \n+      tree t;\n+      tree virtuals;\n+      tree old_virtuals;\n+\n+      t = (tree) data;\n+\n+      /* If we're support RTTI then we always need a new vtable to point\n+\t to the RTTI information.  Under the new ABI we may need a new\n+\t vtable to contain vcall and vbase offsets.  */\n+      if (flag_rtti || flag_new_abi)\n+\tmake_new_vtable (t, binfo);\n+      \n+      /* Now, go through each of the virtual functions in the virtual\n+\t function table for BINFO.  Find the final overrider, and\n+\t update the BINFO_VIRTUALS list appropriately.  */\n+      for (virtuals = skip_rtti_stuff (binfo, BINFO_TYPE (binfo), NULL),\n+\t     old_virtuals = skip_rtti_stuff (TYPE_BINFO (BINFO_TYPE (binfo)),\n+\t\t\t\t\t     BINFO_TYPE (binfo),\n+\t\t\t\t\t     NULL);\n+\t   virtuals;\n+\t   virtuals = TREE_CHAIN (virtuals),\n+\t     old_virtuals = TREE_CHAIN (old_virtuals))\n+\t{\n+\t  tree b;\n+\t  tree fn;\n+\t  tree overrider;\n+\t  tree vindex;\n+\t  tree delta;\n+\n+\t  /* Find the function which originally caused this vtable\n+\t     entry to be present.  */\n+\t  fn = BV_FN (old_virtuals);\n+\t  vindex = DECL_VINDEX (fn);\n+\t  b = dfs_walk (binfo, dfs_find_base, NULL, DECL_VIRTUAL_CONTEXT (fn));\n+\t  fn = skip_rtti_stuff (TYPE_BINFO (BINFO_TYPE (b)),\n+\t\t\t\tBINFO_TYPE (b),\n+\t\t\t\tNULL);\n+\t  while (!tree_int_cst_equal (DECL_VINDEX (BV_FN (fn)), vindex))\n+\t    fn = TREE_CHAIN (fn);\n+\t  fn = BV_FN (fn);\n+\n+\t  /* Handle the case of a virtual function defined in BINFO\n+\t     itself.  */\n+\t  overrider = find_final_overrider (t, b, fn);\n+\t  if (overrider == error_mark_node)\n+\t    continue;\n+\n+\t  /* The `this' pointer needs to be adjusted from pointing to\n+\t     BINFO to pointing at the base where the final overrider\n+\t     appears.  */\n+\t  delta = size_binop (PLUS_EXPR,\n+\t\t\t      get_derived_offset (binfo,\n+\t\t\t\t\t\t  DECL_VIRTUAL_CONTEXT (fn)),\n+\t\t\t      BINFO_OFFSET (binfo));\n+\t  delta = ssize_binop (MINUS_EXPR,\n+\t\t\t       BINFO_OFFSET (TREE_VALUE (overrider)),\n+\t\t\t       delta);\n+\n+\t  modify_vtable_entry (t, \n+\t\t\t       binfo, \n+\t\t\t       TREE_PURPOSE (overrider),\n+\t\t\t       delta,\n+\t\t\t       &virtuals);\n+\t}\n     }\n \n   SET_BINFO_MARKED (binfo);\n@@ -3042,26 +3086,16 @@ modify_all_vtables (t, has_virtual_p, overridden_virtuals)\n      int *has_virtual_p;\n      tree overridden_virtuals;\n {\n-  tree fns;\n   tree binfo;\n \n   binfo = TYPE_BINFO (t);\n \n-  /* Even if there are no overridden virtuals, we want to go through\n-     the hierarchy updating RTTI information.  */\n-  if (!overridden_virtuals && TYPE_CONTAINS_VPTR_P (t) && flag_rtti)\n-    overridden_virtuals = build_tree_list (NULL_TREE, NULL_TREE);\n-\n-  /* Iterate through each of the overriding functions, updating the\n-     base vtables.  */\n-  for (fns = overridden_virtuals; fns; fns = TREE_CHAIN (fns))\n-    {\n-      tree list;\n-      list = build_tree_list (t, TREE_VALUE (fns));\n-      dfs_walk (binfo, dfs_modify_vtables, \n-\t\tdfs_unmarked_real_bases_queue_p, list);\n-      dfs_walk (binfo, dfs_unmark, dfs_marked_real_bases_queue_p, t);\n-    }\n+  /* Update all of the vtables.  */\n+  dfs_walk (binfo, \n+\t    dfs_modify_vtables, \n+\t    dfs_unmarked_real_bases_queue_p,\n+\t    t);\n+  dfs_walk (binfo, dfs_unmark, dfs_marked_real_bases_queue_p, t);\n \n   /* If we should include overriding functions for secondary vtables\n      in our primary vtable, add them now.  */\n@@ -3086,7 +3120,8 @@ modify_all_vtables (t, has_virtual_p, overridden_virtuals)\n \t      DECL_VIRTUAL_CONTEXT (fn) = t;\n \t      /* We don't need to adjust the `this' pointer when\n \t\t calling this function.  */\n-\t      TREE_PURPOSE (*fnsp) = integer_zero_node;\n+\t      BV_DELTA (*fnsp) = integer_zero_node;\n+\t      BV_VCALL_INDEX (*fnsp) = integer_zero_node;\n \n \t      /* This is an overridden function not already in our\n \t\t vtable.  Keep it.  */\n@@ -3104,37 +3139,6 @@ modify_all_vtables (t, has_virtual_p, overridden_virtuals)\n   return overridden_virtuals;\n }\n \n-/* Fixup all the delta entries in this one vtable that need updating.  */\n-\n-static tree\n-dfs_fixup_vtable_deltas (binfo, data)\n-     tree binfo;\n-     void *data;\n-{\n-  tree virtuals;\n-  tree t = (tree) data;\n-\n-  while (BINFO_PRIMARY_MARKED_P (binfo))\n-    {\n-      binfo = BINFO_INHERITANCE_CHAIN (binfo);\n-      /* If BINFO is virtual then we'll handle this base later.  */\n-      if (TREE_VIA_VIRTUAL (binfo))\n-\treturn NULL_TREE;\n-    }\n-\n-  for (virtuals = skip_rtti_stuff (binfo, BINFO_TYPE (binfo), NULL);\n-       virtuals;\n-       virtuals = TREE_CHAIN (virtuals))\n-    {\n-      tree fndecl = BF_FN (virtuals);\n-\n-      if (fndecl)\n-\tmodify_vtable_entry (t, binfo, fndecl, &virtuals);\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n /* Here, we already know that they match in every respect.\n    All we have to check is where they had their declarations.  */\n \n@@ -3150,169 +3154,6 @@ strictly_overrides (fndecl1, fndecl2)\n   return 0;\n }\n \n-/* Merge overrides for one vtable.\n-   If we want to merge in same function, we are fine.\n-   else\n-     if one has a DECL_CLASS_CONTEXT that is a parent of the\n-       other, than choose the more derived one\n-     else\n-       potentially ill-formed (see 10.3 [class.virtual])\n-       we have to check later to see if there was an\n-       override in this class.  If there was ok, if not\n-       then it is ill-formed.  (mrs)\n-\n-   We take special care to reuse a vtable, if we can.  */\n-\n-static void\n-override_one_vtable (binfo, old, t)\n-     tree binfo, old, t;\n-{\n-  tree virtuals;\n-  tree old_virtuals;\n-  tree orig_binfo;\n-  tree orig_virtuals;\n-  enum { REUSE_NEW, REUSE_OLD, UNDECIDED, NEITHER } choose = UNDECIDED;\n-\n-  /* Either or both of BINFO or OLD might be primary base classes\n-     because merge_overrides is called with a vbase from the class we\n-     are definining and the corresponding vbase from one of its direct\n-     bases.  */\n-  orig_binfo = binfo;\n-  while (BINFO_PRIMARY_MARKED_P (binfo))\n-    {\n-      binfo = BINFO_INHERITANCE_CHAIN (binfo);\n-      /* If BINFO is virtual, then we'll handle this virtual base when\n-\t later.  */\n-      if (TREE_VIA_VIRTUAL (binfo))\n-\treturn;\n-    }\n-  while (BINFO_PRIMARY_MARKED_P (old))\n-    old = BINFO_INHERITANCE_CHAIN (old);\n-\n-  /* If we have already committed to modifying it, then don't try and\n-     reuse another vtable.  */\n-  if (BINFO_NEW_VTABLE_MARKED (binfo))\n-    choose = NEITHER;\n-\n-  virtuals = skip_rtti_stuff (binfo, BINFO_TYPE (binfo), NULL);\n-  old_virtuals = skip_rtti_stuff (old, BINFO_TYPE (binfo), NULL);\n-  orig_virtuals = skip_rtti_stuff (orig_binfo, BINFO_TYPE (binfo), NULL);\n-\n-  while (orig_virtuals)\n-    {\n-      tree fndecl = BF_FN (virtuals);\n-      tree old_fndecl = BF_FN (old_virtuals);\n-\n-      /* First check to see if they are the same.  */\n-      if (DECL_ASSEMBLER_NAME (fndecl) == DECL_ASSEMBLER_NAME (old_fndecl))\n-\t{\n-\t  /* No need to do anything.  */\n-\t}\n-      else if (strictly_overrides (fndecl, old_fndecl))\n-\t{\n-\t  if (choose == UNDECIDED)\n-\t    choose = REUSE_NEW;\n-\t  else if (choose == REUSE_OLD)\n-\t    {\n-\t      choose = NEITHER;\n-\t      if (! BINFO_NEW_VTABLE_MARKED (binfo))\n-\t\t{\n-\t\t  build_secondary_vtable (binfo, t);\n-\t\t  override_one_vtable (binfo, old, t);\n-\t\t  return;\n-\t\t}\n-\t    }\n-\t}\n-      else if (strictly_overrides (old_fndecl, fndecl))\n-\t{\n-\t  if (choose == UNDECIDED)\n-\t    choose = REUSE_OLD;\n-\t  else if (choose == REUSE_NEW)\n-\t    {\n-\t      choose = NEITHER;\n-\t      if (! BINFO_NEW_VTABLE_MARKED (binfo))\n-\t\t{\n-\t\t  build_secondary_vtable (binfo, t);\n-\t\t  override_one_vtable (binfo, old, t);\n-\t\t  return;\n-\t\t}\n-\t      TREE_VALUE (virtuals) = TREE_VALUE (old_virtuals);\n-\t    }\n-\t  else if (choose == NEITHER)\n-\t    {\n-\t      TREE_VALUE (virtuals) = TREE_VALUE (old_virtuals);\n-\t    }  \n-\t}\n-      else\n-\t{\n-\t  choose = NEITHER;\n-\t  if (! BINFO_NEW_VTABLE_MARKED (binfo))\n-\t    {\n-\t      build_secondary_vtable (binfo, t);\n-\t      override_one_vtable (binfo, old, t);\n-\t      return;\n-\t    }\n-\t  {\n-\t    /* This MUST be overridden, or the class is ill-formed.  */\n-\t    tree fndecl = BF_FN (virtuals);\n-\n-\t    fndecl = copy_node (fndecl);\n-\t    copy_lang_decl (fndecl);\n-\t    DECL_NEEDS_FINAL_OVERRIDER_P (fndecl) = 1;\n-\t    /* Make sure we search for it later.  */\n-\t    if (! CLASSTYPE_PURE_VIRTUALS (t))\n-\t      CLASSTYPE_PURE_VIRTUALS (t) = error_mark_node;\n-\n-\t    /* We can use integer_zero_node, as we will core dump\n-\t       if this is used anyway.  */\n-\t    BF_DELTA (virtuals) = integer_zero_node;\n-\t    BF_FN (virtuals) = fndecl;\n-\t  }\n-\t}\n-      virtuals = TREE_CHAIN (virtuals);\n-      old_virtuals = TREE_CHAIN (old_virtuals);\n-      orig_virtuals = TREE_CHAIN (orig_virtuals);\n-    }\n-\n-  /* Let's reuse the old vtable.  */\n-  if (choose == REUSE_OLD)\n-    {\n-      BINFO_VTABLE (binfo) = BINFO_VTABLE (old);\n-      BINFO_VIRTUALS (binfo) = BINFO_VIRTUALS (old);\n-    }\n-}\n-\n-/* Merge in overrides for virtual bases.\n-   BINFO is the hierarchy we want to modify, and OLD has the potential\n-   overrides.  */\n-\n-static void\n-merge_overrides (binfo, old, do_self, t)\n-     tree binfo, old;\n-     int do_self;\n-     tree t;\n-{\n-  tree binfos = BINFO_BASETYPES (binfo);\n-  tree old_binfos = BINFO_BASETYPES (old);\n-  int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-\n-  /* Should we use something besides CLASSTYPE_VFIELDS? */\n-  if (do_self && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo)))\n-    {\n-      override_one_vtable (binfo, old, t);\n-    }\n-\n-  for (i = 0; i < n_baselinks; i++)\n-    {\n-      tree base_binfo = TREE_VEC_ELT (binfos, i);\n-      tree old_base_binfo = TREE_VEC_ELT (old_binfos, i);\n-      int is_not_base_vtable \n-\t= !BINFO_PRIMARY_MARKED_P (base_binfo);\n-      if (! TREE_VIA_VIRTUAL (base_binfo))\n-\tmerge_overrides (base_binfo, old_base_binfo, is_not_base_vtable, t);\n-    }\n-}\n-\n /* Get the base virtual function declarations in T that are either\n    overridden or hidden by FNDECL as a list.  We set TREE_PURPOSE with\n    the overrider/hider.  */\n@@ -4842,6 +4683,10 @@ layout_virtual_bases (t)\n      in get_base_distance depend on the BINFO_OFFSETs being set\n      correctly.  */\n   dfs_walk (TYPE_BINFO (t), dfs_set_offset_for_unshared_vbases, NULL, t);\n+  for (vbase = CLASSTYPE_VBASECLASSES (t);\n+       vbase;\n+       vbase = TREE_CHAIN (vbase))\n+    dfs_walk (vbase, dfs_set_offset_for_unshared_vbases, NULL, t);\n \n   /* Now, make sure that the total size of the type is a multiple of\n      its alignment.  */\n@@ -5065,42 +4910,6 @@ finish_struct_1 (t)\n   layout_class_type (t, &empty, &has_virtual,\n \t\t     &new_virtuals, &overridden_virtuals);\n \n-  if (TYPE_USES_VIRTUAL_BASECLASSES (t))\n-    {\n-      tree vbases;\n-\n-      vbases = CLASSTYPE_VBASECLASSES (t);\n-\n-      {\n-\t/* Now fixup overrides of all functions in vtables from all\n-\t   direct or indirect virtual base classes.  */\n-\ttree binfos = BINFO_BASETYPES (TYPE_BINFO (t));\n-\tint i, n_baseclasses = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-\n-\tfor (i = 0; i < n_baseclasses; i++)\n-\t  {\n-\t    tree base_binfo = TREE_VEC_ELT (binfos, i);\n-\t    tree basetype = BINFO_TYPE (base_binfo);\n-\t    tree vbases;\n-\n-\t    vbases = CLASSTYPE_VBASECLASSES (basetype);\n-\t    while (vbases)\n-\t      {\n-\t\ttree vbase;\n-\t\ttree basetype_vbase;\n-\n-\t\tvbase \n-\t\t  = find_vbase_instance (BINFO_TYPE (vbases), t);\n-\t\tbasetype_vbase \n-\t\t  = find_vbase_instance (BINFO_TYPE (vbases), basetype);\n-\n-\t\tmerge_overrides (vbase, basetype_vbase, 1, t);\n-\t\tvbases = TREE_CHAIN (vbases);\n-\t      }\n-\t  }\n-\t}\n-    }\n-\n   /* Set up the DECL_FIELD_BITPOS of the vfield if we need to, as we\n      might need to know it for setting up the offsets in the vtable\n      (or in thunks) below.  */\n@@ -5126,28 +4935,7 @@ finish_struct_1 (t)\n   overridden_virtuals \n     = modify_all_vtables (t, &has_virtual, nreverse (overridden_virtuals));\n \n-  if (TYPE_USES_VIRTUAL_BASECLASSES (t))\n-    {\n-      tree vbases;\n-      /* Now fixup any virtual function entries from virtual bases\n-\t that have different deltas.  This has to come after we do the\n-\t overridden virtuals.  */\n-      vbases = CLASSTYPE_VBASECLASSES (t);\n-      while (vbases)\n-\t{\n-\t  tree vbase;\n-\n-\t  /* We might be able to shorten the amount of work we do by\n-\t     only doing this for vtables that come from virtual bases\n-\t     that have differing offsets, but don't want to miss any\n-\t     entries.  */\n-\t  vbase = find_vbase_instance (BINFO_TYPE (vbases), t);\n-\t  dfs_walk (vbase, dfs_fixup_vtable_deltas, dfs_skip_vbases, t);\n-\t  vbases = TREE_CHAIN (vbases);\n-\t}\n-    }\n-\n-  /* If necessary, create the vtable for this class.  */\n+  /* If necessary, create the primary vtable for this class.  */\n   if (new_virtuals\n       || overridden_virtuals\n       || (TYPE_CONTAINS_VPTR_P (t) && vptrs_present_everywhere_p ()))"}, {"sha": "72d4b187c77a5b456ea67e39eaa4aadae1c8e32d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e19c0539080471ad7097fa5c441031334f12bdd/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e19c0539080471ad7097fa5c441031334f12bdd/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=5e19c0539080471ad7097fa5c441031334f12bdd", "patch": "@@ -115,18 +115,22 @@ Boston, MA 02111-1307, USA.  */\n      For a static VAR_DECL, this is DECL_INIT_PRIORITY.\n \n    BINFO_VIRTUALS\n-     For a binfo, this is a TREE_LIST.  The BF_DELTA of each node\n+     For a binfo, this is a TREE_LIST.  The BV_DELTA of each node\n      gives the amount by which to adjust the `this' pointer when\n      calling the function.  If the method is an overriden version of a\n      base class method, then it is assumed that, prior to adjustment,\n      the this pointer points to an object of the base class.\n \n-     The BF_VCALL_INDEX of each node, if non-NULL, gives the vtable\n+     The BV_VCALL_INDEX of each node, if non-NULL, gives the vtable\n      index of the vcall offset for this entry.\n \n-     The BF_FN is the declaration for the virtual function itself.\n+     The BV_FN is the declaration for the virtual function itself.\n      When CLASSTYPE_COM_INTERFACE_P does not hold, the first entry\n-     does not have a BF_FN; it is just an offset.\n+     does not have a BV_FN; it is just an offset.\n+\n+     The BV_OVERRIDING_BASE is the binfo for the final overrider for\n+     this function.  (This binfo's BINFO_TYPE will always be the same\n+     as the DECL_CLASS_CONTEXT for the function.)\n \n    DECL_ARGUMENTS\n      For a VAR_DECL this is DECL_ANON_UNION_ELEMS.  \n@@ -1500,10 +1504,14 @@ struct lang_type\n /* If non-NULL, this is the binfo for the primary base class, i.e.,\n    the base class which contains the virtual function table pointer\n    for this class.  */\n-#define CLASSTYPE_PRIMARY_BINFO(NODE) \t\t\t\\\n-  (CLASSTYPE_HAS_PRIMARY_BASE_P (NODE)\t\t\t\\\n-   ? TREE_VEC_ELT (TYPE_BINFO_BASETYPES (NODE),\t\t\\\n-\t\t   CLASSTYPE_VFIELD_PARENT (NODE))\t\\\n+#define CLASSTYPE_PRIMARY_BINFO(NODE) \\\n+  (BINFO_PRIMARY_BINFO (TYPE_BINFO (NODE)))\n+\n+/* If non-NULL, this is the binfo for the primary base of BINFO.  */\n+#define BINFO_PRIMARY_BINFO(NODE)\t\t\t\t\t\\\n+  (CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (NODE))\t\t\t\\\n+   ? BINFO_BASETYPE (NODE, \t\t\t\t\t\t\\\n+\t\t     CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (NODE)))\t\\\n    : NULL_TREE)\n \n /* The number of virtual functions defined for this\n@@ -1726,14 +1734,16 @@ struct lang_type\n \n /* The number of bytes by which to adjust the `this' pointer when\n    calling this virtual function.  */\n-#define BF_DELTA(NODE) (TREE_PURPOSE (NODE))\n+#define BV_DELTA(NODE) (TREE_PURPOSE (NODE))\n \n /* If non-NULL, the vtable index at which to find the vcall offset\n    when calling this virtual function.  */\n-#define BF_VCALL_INDEX(NODE) (TREE_TYPE (NODE))\n+#define BV_VCALL_INDEX(NODE) (TREE_TYPE (NODE))\n \n /* The function to call.  */\n-#define BF_FN(NODE) (TREE_VALUE (NODE))\n+#define BV_FN(NODE) (TREE_VALUE (NODE))\n+\n+/* The most derived class.  */\n \n \f\n /* Nonzero for TREE_LIST node means that this list of things"}, {"sha": "a66a634230aa02a0b8fcf000d3e6f84d22d13539", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e19c0539080471ad7097fa5c441031334f12bdd/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e19c0539080471ad7097fa5c441031334f12bdd/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=5e19c0539080471ad7097fa5c441031334f12bdd", "patch": "@@ -883,23 +883,26 @@ binfo_value (elem, type)\n   return get_binfo (elem, type, 0);\n }\n \n-/* Return a reversed copy of the BINFO-chain given by PATH.  (If the \n-   BINFO_INHERITANCE_CHAIN points from base classes to derived\n-   classes, it will instead point from derived classes to base\n-   classes.)  Returns the first node in the reversed chain.  */\n+/* Return a TREE_LIST whose TREE_VALUE nodes along the\n+   BINFO_INHERITANCE_CHAIN for BINFO, but in the opposite order.  In\n+   other words, while the BINFO_INHERITANCE_CHAIN goes from base\n+   classes to derived classes, the reversed path goes from derived\n+   classes to base classes.  */\n \n tree\n-reverse_path (path)\n-     tree path;\n+reverse_path (binfo)\n+     tree binfo;\n {\n-  register tree prev = NULL_TREE, cur;\n-  for (cur = path; cur; cur = BINFO_INHERITANCE_CHAIN (cur))\n+  tree reversed_path;\n+\n+  reversed_path = NULL_TREE;\n+  while (binfo) \n     {\n-      tree r = copy_node (cur);\n-      BINFO_INHERITANCE_CHAIN (r) = prev;\n-      prev = r;\n+      reversed_path = tree_cons (NULL_TREE, binfo, reversed_path);\n+      binfo = BINFO_INHERITANCE_CHAIN (binfo);\n     }\n-  return prev;\n+\n+  return reversed_path;\n }\n \n void"}]}