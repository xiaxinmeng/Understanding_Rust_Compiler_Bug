{"sha": "da7d70aae388ceeefd8b829865ba6ea55d4171c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE3ZDcwYWFlMzg4Y2VlZWZkOGI4Mjk4NjViYTZlYTU1ZDQxNzFjOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-07T12:37:10Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-07T12:37:10Z"}, "message": "[multiple changes]\n\n2010-10-07  Robert Dewar  <dewar@adacore.com>\n\n\t* par-ch6.adb: Fix error in handling of parametrized expressions.\n\t* par-ch4.adb (P_Name): Allow qualified expression as name in Ada 2012\n\tmode.\n\t(P_Simple_Expression): Better message for qualified expression prefix\n\t* s-crc32.adb: Minor reformatting.\n\t* exp_intr.adb (Expand_Unc_Deallocation): Remove test for empty\n\tstorage pool (this test is moved to Sem_Intr).\n\t* sem_intr.adb (Check_Intrinsic_Call): Add check for deallocation from\n\tempty storage pool, moved here from Exp_Intr and made into error.\n\t(Check_Intrinsic_Call): Remove assumption in generating not-null free\n\twarning that the name of the instantiation is Free.\n\t* sinput.adb (Tree_Read): Document use of illegal free call allowed in\n\tGNAT mode.\n\t* types.ads: Remove storage size clauses from big types (since we may\n\tneed to do deallocations, which are now illegal for empty pools).\n\n2010-10-07  Sergey Rybin  <rybin@adacore.com>\n\n\t* gnat_ugn.texi: Add missing word.\n\nFrom-SVN: r165099", "tree": {"sha": "9938e6b83fa49b9e8d2ffa23b29a00aadd3f6372", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9938e6b83fa49b9e8d2ffa23b29a00aadd3f6372"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da7d70aae388ceeefd8b829865ba6ea55d4171c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da7d70aae388ceeefd8b829865ba6ea55d4171c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da7d70aae388ceeefd8b829865ba6ea55d4171c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da7d70aae388ceeefd8b829865ba6ea55d4171c9/comments", "author": null, "committer": null, "parents": [{"sha": "ad110ee8874446d1993a66fee67b9a7c6fd44a7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad110ee8874446d1993a66fee67b9a7c6fd44a7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad110ee8874446d1993a66fee67b9a7c6fd44a7a"}], "stats": {"total": 180, "additions": 131, "deletions": 49}, "files": [{"sha": "300a861d59a8bd33d101c7975c50ae35656db56e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d70aae388ceeefd8b829865ba6ea55d4171c9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d70aae388ceeefd8b829865ba6ea55d4171c9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=da7d70aae388ceeefd8b829865ba6ea55d4171c9", "patch": "@@ -1,3 +1,25 @@\n+2010-10-07  Robert Dewar  <dewar@adacore.com>\n+\n+\t* par-ch6.adb: Fix error in handling of parametrized expressions.\n+\t* par-ch4.adb (P_Name): Allow qualified expression as name in Ada 2012\n+\tmode.\n+\t(P_Simple_Expression): Better message for qualified expression prefix\n+\t* s-crc32.adb: Minor reformatting.\n+\t* exp_intr.adb (Expand_Unc_Deallocation): Remove test for empty\n+\tstorage pool (this test is moved to Sem_Intr).\n+\t* sem_intr.adb (Check_Intrinsic_Call): Add check for deallocation from\n+\tempty storage pool, moved here from Exp_Intr and made into error.\n+\t(Check_Intrinsic_Call): Remove assumption in generating not-null free\n+\twarning that the name of the instantiation is Free.\n+\t* sinput.adb (Tree_Read): Document use of illegal free call allowed in\n+\tGNAT mode.\n+\t* types.ads: Remove storage size clauses from big types (since we may\n+\tneed to do deallocations, which are now illegal for empty pools).\n+\n+2010-10-07  Sergey Rybin  <rybin@adacore.com>\n+\n+\t* gnat_ugn.texi: Add missing word.\n+\n 2010-10-07  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_util.adb (Insert_Actions): Add handling of"}, {"sha": "89920ebf42e41553a2443a8b4d757799f2bdb589", "filename": "gcc/ada/exp_intr.adb", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d70aae388ceeefd8b829865ba6ea55d4171c9/gcc%2Fada%2Fexp_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d70aae388ceeefd8b829865ba6ea55d4171c9/gcc%2Fada%2Fexp_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.adb?ref=da7d70aae388ceeefd8b829865ba6ea55d4171c9", "patch": "@@ -851,7 +851,7 @@ package body Exp_Intr is\n       Rtyp  : constant Entity_Id  := Underlying_Type (Root_Type (Typ));\n       Pool  : constant Entity_Id  := Associated_Storage_Pool (Rtyp);\n \n-      Desig_T   : constant Entity_Id  := Designated_Type (Typ);\n+      Desig_T   : constant Entity_Id := Designated_Type (Typ);\n       Gen_Code  : Node_Id;\n       Free_Node : Node_Id;\n       Deref     : Node_Id;\n@@ -866,10 +866,6 @@ package body Exp_Intr is\n       --  them to the tree, and that can disturb current value settings.\n \n    begin\n-      if No_Pool_Assigned (Rtyp) then\n-         Error_Msg_N (\"?deallocation from empty storage pool!\", N);\n-      end if;\n-\n       --  Nothing to do if we know the argument is null\n \n       if Known_Null (N) then"}, {"sha": "f04971c38922eea02ca0001f08fac346cc7dc282", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d70aae388ceeefd8b829865ba6ea55d4171c9/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d70aae388ceeefd8b829865ba6ea55d4171c9/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=da7d70aae388ceeefd8b829865ba6ea55d4171c9", "patch": "@@ -17324,7 +17324,7 @@ sources and applied rules (coding standard);\n @item list of exempted coding standard violations;\n @item list of non-exempted coding standard violations;\n @item list of problems in the definition of exemption sections;\n-@item of language violations (compile-time errors) detected in processed sources;\n+@item list of language violations (compile-time errors) detected in processed sources;\n @end itemize\n \n @node General gnatcheck Switches"}, {"sha": "10ea58f77c8d3d3a87f4e04c93debe9bbdd66e27", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 34, "deletions": 9, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d70aae388ceeefd8b829865ba6ea55d4171c9/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d70aae388ceeefd8b829865ba6ea55d4171c9/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=da7d70aae388ceeefd8b829865ba6ea55d4171c9", "patch": "@@ -233,13 +233,18 @@ package body Ch4 is\n          Save_Scan_State (Scan_State); -- at apostrophe\n          Scan; -- past apostrophe\n \n-         --  If left paren, then this might be a qualified expression, but we\n-         --  are only in the business of scanning out names, so return with\n-         --  Token backed up to point to the apostrophe. The treatment for\n-         --  the range attribute is similar (we do not consider x'range to\n-         --  be a name in this grammar).\n+         --  Qualified expression in Ada 2012 mode (treated as a name)\n \n-         if Token = Tok_Left_Paren or else Token = Tok_Range then\n+         if Ada_Version >= Ada_12 and then Token = Tok_Left_Paren then\n+            goto Scan_Name_Extension_Apostrophe;\n+\n+         --  If left paren not in Ada 2012, then it is not part of the name,\n+         --  since qualified expressions are not names in prior versions of\n+         --  Ada, so return with Token backed up to point to the apostrophe.\n+         --  The treatment for the range attribute is similar (we do not\n+         --  consider x'range to be a name in this grammar).\n+\n+         elsif Token = Tok_Left_Paren or else Token = Tok_Range then\n             Restore_Scan_State (Scan_State); -- to apostrophe\n             Expr_Form := EF_Simple_Name;\n             return Name_Node;\n@@ -363,6 +368,10 @@ package body Ch4 is\n             --  the current token to Tok_Semicolon, and returns True.\n             --  Otherwise returns False.\n \n+            ------------------------------------\n+            -- Apostrophe_Should_Be_Semicolon --\n+            ------------------------------------\n+\n             function Apostrophe_Should_Be_Semicolon return Boolean is\n             begin\n                if Token_Is_At_Start_Of_Line then\n@@ -378,14 +387,20 @@ package body Ch4 is\n          --  Start of processing for Scan_Apostrophe\n \n          begin\n+            --  Check for qualified expression case in Ada 2012 mode\n+\n+            if Ada_Version >= Ada_12 and then Token = Tok_Left_Paren then\n+               Name_Node := P_Qualified_Expression (Name_Node);\n+               goto Scan_Name_Extension;\n+\n             --  If range attribute after apostrophe, then return with Token\n             --  pointing to the apostrophe. Note that in this case the prefix\n             --  need not be a simple name (cases like A.all'range). Similarly\n             --  if there is a left paren after the apostrophe, then we also\n             --  return with Token pointing to the apostrophe (this is the\n-            --  qualified expression case).\n+            --  aggregate case, or some error case).\n \n-            if Token = Tok_Range or else Token = Tok_Left_Paren then\n+            elsif Token = Tok_Range or else Token = Tok_Left_Paren then\n                Restore_Scan_State (Scan_State); -- to apostrophe\n                Expr_Form := EF_Name;\n                return Name_Node;\n@@ -2054,7 +2069,17 @@ package body Ch4 is\n \n       if Token = Tok_Dot then\n          Error_Msg_SC (\"prefix for selection is not a name\");\n-         raise Error_Resync;\n+\n+         --  If qualified expression, comment and continue, otherwise something\n+         --  is pretty nasty so do an Error_Resync call.\n+\n+         if Ada_Version < Ada_12\n+           and then Nkind (Node1) = N_Qualified_Expression\n+         then\n+            Error_Msg_SC (\"\\would be legal in Ada 2012 mode\");\n+         else\n+            raise Error_Resync;\n+         end if;\n       end if;\n \n       --  Special test to improve error recovery: If the current token is"}, {"sha": "994e166c2593ad1e02561628ef44afe82526540b", "filename": "gcc/ada/par-ch6.adb", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d70aae388ceeefd8b829865ba6ea55d4171c9/gcc%2Fada%2Fpar-ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d70aae388ceeefd8b829865ba6ea55d4171c9/gcc%2Fada%2Fpar-ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch6.adb?ref=da7d70aae388ceeefd8b829865ba6ea55d4171c9", "patch": "@@ -632,26 +632,36 @@ package body Ch6 is\n                      return False;\n \n                   --  If currently pointing to BEGIN or a declaration keyword\n-                  --  or a pragma then we definitely do not have a parametrized\n-                  --  expression.\n+                  --  or a pragma, then we definitely have a subprogram body.\n+                  --  This is a common case, so worth testing first.\n \n-                  elsif Token in Token_Class_Declk\n-                    or else Token = Tok_Begin\n+                  elsif Token = Tok_Begin\n+                    or else Token in Token_Class_Declk\n                     or else Token = Tok_Pragma\n                   then\n                      return False;\n \n-                  --  A common error case, missing BEGIN before RETURN\n+                  --  Test for tokens which could only start an expression and\n+                  --  thus signal the case of a parametrized expression.\n \n-                  elsif Token = Tok_Return then\n-                     return False;\n+                  elsif Token in Token_Class_Literal\n+                    or else Token in Token_Class_Unary_Addop\n+                    or else Token = Tok_Left_Paren\n+                    or else Token = Tok_Abs\n+                    or else Token = Tok_Null\n+                    or else Token = Tok_New\n+                    or else Token = Tok_Not\n+                  then\n+                     return True;\n \n-                  --  Anything other than an identifier must be a parametrized\n-                  --  expression at this stage. Probably we could do a little\n-                  --  better job of distingushing some more error cases.\n+                  --  Anything other than an identifier must be a body at\n+                  --  this stage. Probably we could do a little better job of\n+                  --  distingushing some more error cases, but it seems right\n+                  --  to err on the side of favoring a body over the\n+                  --  new-fangled parametrized expression.\n \n                   elsif Token /= Tok_Identifier then\n-                     return True;\n+                     return False;\n \n                   --  For identifier we have to scan ahead if identifier is\n                   --  followed by a colon or a comma, it is a declaration and\n@@ -740,7 +750,6 @@ package body Ch6 is\n \n          Pop_Scope_Stack;\n          return Decl_Node;\n-\n    end P_Subprogram;\n \n    ---------------------------------"}, {"sha": "b133780a97b1a50a1fef5066119dc926d5ff63f2", "filename": "gcc/ada/s-crc32.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d70aae388ceeefd8b829865ba6ea55d4171c9/gcc%2Fada%2Fs-crc32.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d70aae388ceeefd8b829865ba6ea55d4171c9/gcc%2Fada%2Fs-crc32.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-crc32.adb?ref=da7d70aae388ceeefd8b829865ba6ea55d4171c9", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2009, Free Software Foundation, Inc.          --\n+--          Copyright (C) 2001-2010, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -130,7 +130,6 @@ package body System.CRC32 is\n \n    procedure Update (C : in out CRC32; Value : Character) is\n       V : constant CRC32 := CRC32 (Character'Pos (Value));\n-\n    begin\n       C := Shift_Right (C, 8) xor Table (V xor (C and 16#0000_00FF#));\n    end Update;"}, {"sha": "f1d86058a469b3d6a51548418219915dd2a46251", "filename": "gcc/ada/sem_intr.adb", "status": "modified", "additions": 44, "deletions": 12, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d70aae388ceeefd8b829865ba6ea55d4171c9/gcc%2Fada%2Fsem_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d70aae388ceeefd8b829865ba6ea55d4171c9/gcc%2Fada%2Fsem_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_intr.adb?ref=da7d70aae388ceeefd8b829865ba6ea55d4171c9", "patch": "@@ -31,6 +31,7 @@ with Errout;   use Errout;\n with Fname;    use Fname;\n with Lib;      use Lib;\n with Namet;    use Namet;\n+with Sem_Aux;  use Sem_Aux;\n with Sem_Eval; use Sem_Eval;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n@@ -96,10 +97,32 @@ package body Sem_Intr is\n \n    procedure Check_Intrinsic_Call (N : Node_Id) is\n       Nam  : constant Entity_Id := Entity (Name (N));\n-      Cnam : constant Name_Id   := Chars (Nam);\n       Arg1 : constant Node_Id   := First_Actual (N);\n+      Typ  : Entity_Id;\n+      Rtyp : Entity_Id;\n+      Cnam : Name_Id;\n+      Unam : Node_Id;\n \n    begin\n+      --  Set argument type if argument present\n+\n+      if Present (Arg1) then\n+         Typ := Etype (Arg1);\n+         Rtyp := Underlying_Type (Root_Type (Typ));\n+      end if;\n+\n+      --  Set intrinsic name (getting original name in the generic case)\n+\n+      Unam := Ultimate_Alias (Nam);\n+\n+      if Present (Parent (Unam))\n+        and then Present (Generic_Parent (Parent (Unam)))\n+      then\n+         Cnam := Chars (Generic_Parent (Parent (Unam)));\n+      else\n+         Cnam := Chars (Nam);\n+      end if;\n+\n       --  For Import_xxx calls, argument must be static string. A string\n       --  literal is legal even in Ada83 mode, where such literals are\n       --  not static.\n@@ -136,12 +159,23 @@ package body Sem_Intr is\n       --  Check for the case of freeing a non-null object which will raise\n       --  Constraint_Error. Issue warning here, do the expansion in Exp_Intr.\n \n-      elsif Cnam = Name_Free\n+      elsif Cnam = Name_Unchecked_Deallocation\n         and then Can_Never_Be_Null (Etype (Arg1))\n       then\n          Error_Msg_N\n            (\"freeing `NOT NULL` object will raise Constraint_Error?\", N);\n \n+      --  For unchecked deallocation, error to deallocate from empty pool.\n+      --  Note: this test used to be in Exp_Intr as a warning, but AI 157\n+      --  issues a binding intepretation that this should be an error, and\n+      --  consequently it needs to be done in the semantic analysis so that\n+      --  the error is issued even in semantics only mode.\n+\n+      elsif Cnam = Name_Unchecked_Deallocation\n+        and then No_Pool_Assigned (Rtyp)\n+      then\n+         Error_Msg_N (\"deallocation from empty storage pool!\", N);\n+\n       --  For now, no other special checks are required\n \n       else\n@@ -188,29 +222,29 @@ package body Sem_Intr is\n             then\n                T2 := T1;\n \n-            else\n-               --  Previous error in declaration\n+            --  Previous error in declaration\n \n+            else\n                return;\n             end if;\n \n          else\n             T2 := Etype (Next_Formal (First_Formal (E)));\n          end if;\n \n+         --  Same types, predefined operator will apply\n+\n          if Root_Type (T1) = Root_Type (T2)\n            or else Root_Type (T1) = Root_Type (Ret)\n          then\n-            --  Same types, predefined operator will apply\n-\n             null;\n \n+         --  Expansion will introduce conversions if sizes are not equal\n+\n          elsif Is_Integer_Type (Underlying_Type (T1))\n            and then Is_Integer_Type (Underlying_Type (T2))\n            and then Is_Integer_Type (Underlying_Type (Ret))\n          then\n-            --  Expansion will introduce conversions if sizes are not equal\n-\n             null;\n \n          else\n@@ -234,12 +268,10 @@ package body Sem_Intr is\n       then\n          T1 := Etype (First_Formal (E));\n \n-         if No (Next_Formal (First_Formal (E))) then\n-\n-            --  Previous error in declaration\n+         --  Return if previous error in declaration, otherwise get T2 type\n \n+         if No (Next_Formal (First_Formal (E))) then\n             return;\n-\n          else\n             T2 := Etype (Next_Formal (First_Formal (E)));\n          end if;"}, {"sha": "10f188c609a4cf7c546f7ae13f54b8e8582ca538", "filename": "gcc/ada/sinput.adb", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d70aae388ceeefd8b829865ba6ea55d4171c9/gcc%2Fada%2Fsinput.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d70aae388ceeefd8b829865ba6ea55d4171c9/gcc%2Fada%2Fsinput.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput.adb?ref=da7d70aae388ceeefd8b829865ba6ea55d4171c9", "patch": "@@ -792,18 +792,15 @@ package body Sinput is\n                else\n                   --  Free the buffer, we use Free here, because we used malloc\n                   --  or realloc directly to allocate the tables. That is\n-                  --  because we were playing the big array trick. We need to\n-                  --  suppress the warning for freeing from an empty pool!\n+                  --  because we were playing the big array trick.\n \n                   --  We have to recreate a proper pointer to the actual array\n                   --  from the zero origin pointer stored in the source table.\n \n                   Tmp1 :=\n                     To_Source_Buffer_Ptr\n                       (S.Source_Text (S.Source_First)'Address);\n-                  pragma Warnings (Off);\n                   Free_Ptr (Tmp1);\n-                  pragma Warnings (On);\n \n                   if S.Lines_Table /= null then\n                      Memory.Free (To_Address (S.Lines_Table));"}, {"sha": "5fcba82f5a87511d306a748197c6c1b0b17672b3", "filename": "gcc/ada/types.ads", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da7d70aae388ceeefd8b829865ba6ea55d4171c9/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da7d70aae388ceeefd8b829865ba6ea55d4171c9/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=da7d70aae388ceeefd8b829865ba6ea55d4171c9", "patch": "@@ -122,8 +122,9 @@ package Types is\n \n    subtype Big_String is String (Positive);\n    type Big_String_Ptr is access all Big_String;\n-   for Big_String_Ptr'Storage_Size use 0;\n-   --  Virtual type for handling imported big strings\n+   --  Virtual type for handling imported big strings. Note that we should\n+   --  never have any allocators for this type, but we don't give a storage\n+   --  size of zero, since there are legitimate deallocations going on.\n \n    function To_Big_String_Ptr is\n      new Unchecked_Conversion (System.Address, Big_String_Ptr);\n@@ -197,13 +198,14 @@ package Types is\n    --  Source_Buffer_Ptr, see Osint.Read_Source_File for details.\n \n    type Source_Buffer_Ptr is access all Big_Source_Buffer;\n-   for Source_Buffer_Ptr'Storage_Size use 0;\n    --  Pointer to source buffer. We use virtual origin addressing for source\n    --  buffers, with thin pointers. The pointer points to a virtual instance\n    --  of type Big_Source_Buffer, where the actual type is in fact of type\n    --  Source_Buffer. The address is adjusted so that the virtual origin\n    --  addressing works correctly. See Osint.Read_Source_Buffer for further\n-   --  details.\n+   --  details. Again, as for Big_String_Ptr, we should never allocate using\n+   --  this type, but we don't give a storage size clause of zero, since we\n+   --  may end up doing deallocations of instances allocated manually.\n \n    subtype Source_Ptr is Text_Ptr;\n    --  Type used to represent a source location, which is a subscript of a"}]}