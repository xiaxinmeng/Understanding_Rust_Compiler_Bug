{"sha": "6cdb2c6e80a9c6300ae56a260c617d6e72b52f19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNkYjJjNmU4MGE5YzYzMDBhZTU2YTI2MGM2MTdkNmU3MmI1MmYxOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-09-01T11:51:54Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-09-01T11:51:54Z"}, "message": "[multiple changes]\n\n2004-08-31  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n\t* misc.c (gnat_print_type): Use TYPE_RM_SIZE_NUM.\n\n\t* trans.c (struct stmt_group): Delete field GLOBAL.\n\t(gnat_init_stmt_group): Do not initialize it.\n\t(call_to_gnu): Use save_expr, not protect_multiple_eval.\n\t(Exception_Handler_to_gnu_sjlj): Call build_int_cst, not build_int_2\n\t(gnat_to_gnu, case N_Character_Literal, N_String_Literal): Likewise.\n\t(gnat_to_gnu, case N_Compilation_Unit): Do not set GLOBAL in stmt group.\n\t(start_stmt_group): Likewise.\n\t(add_stmt, add_decl_expr): Rework handling of global DECL_EXPRs.\n\n\t* utils2.c (ggc.h): Include.\n\t(build_call_raise): Call build_int_cst, not build_int_2.\n\n\t* utils.c (gnat_init_decl_processing): Fix arg to\n\tbuild_common_tree_nodes.\n\t(create_subprog_type): Do not use SET_TYPE_CI_CO_LIST.\n\t(gnat_define_builtin): Set built_in_decls.\n\t(init_gigi_decls): Call build_int_cst, not build_int_2.\n\n\t* ada-tree.h (struct lang_decl, struct lang_type): Field is type tree.\n\t(GET_TYPE_LANG_SPECIFIC, SET_TYPE_LANG_SPECIFIC): New macros.\n\t(GET_DECL_LANG_SPECIFIC, SET_DECL_LANG_SPECIFIC): Likewise.\n\t(TYPE_CI_CO_LIST, SET_TYPE_CI_CO_LIST, TYPE_MODULE,\n\tSET_TYPE_MODULE): Use them.\n\t(TYPE_INDEX_TYPE, SET_TYPE_INDEX_TYPE, TYPE_DIGITS_VALUE): Likewise.\n\t(SET_TYPE_DIGITS_VALUE, TYPE_UNCONSTRAINED_ARRAY): Likewise.\n\t(SET_TYPE_UNCONSTRAINED_ARRAY, TYPE_ADA_SIZE,\n\tSET_TYPE_ADA_SIZE): Likewise.\n\t(TYPE_ACTUAL_BOUNDS, SET_TYPE_ACTUAL_BOUNDS): Likewise.\n\t(DECL_CONST_CORRESPONDING_VAR,\n\tSET_DECL_CONST_CORRESPONDING_VAR): Likewise.\n\t(DECL_ORIGINAL_FIELD, SET_DECL_ORIGINAL_FIELD): Likewise.\n\t(TYPE_RM_SIZE_INT, TYPE_RM_SIZE_ENUM, SET_TYPE_RM_SIZE_ENUM): Deleted.\n\t(TYPE_RM_SIZE_NUM): New macro.\n\t(TYPE_RM_SIZE): Modified to use above.\n\n\t* cuintp.c: (build_cst_from_int): New function.\n\t(UI_To_gnu): Use it.\n\n\t* decl.c (gnat_to_gnu_entity): Use TYPE_RM_SIZE_NUM.\n\t(make_type_from_size): Avoid changing TYPE_UNSIGNED of a type.\n\t(gnat_substitute_in_type, case ARRAY_TYPE): If old had a\n\tMIN_EXPR for the size, copy it into new.\n\n2004-08-31  Robert Dewar  <dewar@gnat.com>\n\n\t* exp_ch6.adb (Expand_Call): Properly handle validity checks for\n\tpacked indexed component where array is an IN OUT formal. This\n\tgenerated garbage code previously.\n\n\t* gnat_ugn.texi: Document -fverbose-asm\n\n\t* gnat-style.texi: Minor updates (note that boolean constants and\n\tvariables are joined with AND/OR rather than short circuit forms).\n\n2004-08-31  Ed Schonberg  <schonberg@gnat.com>\n\n\t* exp_util.adb (Safe_Unchecked_Type_Conversion): Conversion is safe if\n\tit is an upward conversion of an untagged type with no representation\n\tchange.\n\n2004-08-31  Thomas Quinot  <quinot@act-europe.fr>\n\n\t* rtsfind.ads: Move RCI_Subp_Info and RCI_Subp_Info_Array to\n\tSystem.Partition_Interface.\n\n\t* checks.adb (Apply_Access_Checks): Do not generate checks when\n\texpander is not active (but check for unset reference to prefix of\n\tdereference).\n\n\t* sem_prag.adb (Analyze_Pragma, case Pragma_Debug): Uniformly rewrite\n\tpragma Debug as an if statement with a constant condition, for\n\tconsistent treatment of entity references contained within the\n\tenclosed procedure call.\n\n2004-08-31  Vincent Celier  <celier@gnat.com>\n\n\t* bindgen.adb: (Set_EA_Last): New procedure\n\t(Gen_Exception_Table_Ada, Gen_Exception_Table_C): Use new procedure\n\tSet_EA_Last.\n\t(Gen_Adafinal_Ada): If no finalization, adafinal does nothing\n\t(Gen_Output_File_Ada): Always call Gen_Adafinal_Ada, so that SAL can be\n\tlinked without errors.\n\t(Gen_Exception_Table_Ada): Correct bugs when generating code for arrays\n\tST and EA.\n\t(Gen_Exception_Table_C): Correct same bugs\n\n\t* vms_data.ads: Add new qualifier /VERBOSE_ASM to GCC_Switches\n\n\t* g-os_lib.adb (Normalize_Pathname.Get_Directory): When Dir is empty,\n\ton Windows, make sure that the drive letter is in upper case.\n\n\t* g-os_lib.ads (Normalize_Pathname): Add a comment to indicate that on\n\tWindows, when the drive letter is added and Case_Sensitive is True, the\n\tdrive letter is forced to upper case.\n\n\t* mlib-tgt-irix.adb (Build_Dynamic_Library): Transfer all -lxxx options\n\tto Options_2 for the call to MLib.Utl.Gcc.\n\n\t* bld.adb (Put_Include_Project): Use '/', not '\\' on Windows as\n\tdirectory separator when defining BASE_DIR.\n\n2004-08-19  Pascal Obry  <obry@gnat.com>\n\n\t* gprcmd.adb (Extend): Do not output trailing directory separator. This\n\tis not needed and it confuses Windows GNU/make which does not report\n\tdirectory terminated by a slash as a directory.\n\t(gprcmd): Idem for \"pwd\" internal command.\n\n\t* Makefile.generic: Use __GPRCOLON__ instead of pipe character in\n\ttarget names rewrite to fix regressions with recent version of\n\tGNU/make. Starting with GNU/make 3.80 the pipe character was not\n\thandled properly anymore.\n\nFrom-SVN: r86883", "tree": {"sha": "9dd290825d6a2ee12dbbf7d949cc7b983baac8bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9dd290825d6a2ee12dbbf7d949cc7b983baac8bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/comments", "author": null, "committer": null, "parents": [{"sha": "0a1aa86740647f0f4c5092a7f8cdea7c01807827", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a1aa86740647f0f4c5092a7f8cdea7c01807827", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a1aa86740647f0f4c5092a7f8cdea7c01807827"}], "stats": {"total": 699, "additions": 477, "deletions": 222}, "files": [{"sha": "2a782da126ac01f68893a21101c305404ee125c2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6cdb2c6e80a9c6300ae56a260c617d6e72b52f19", "patch": "@@ -1,3 +1,120 @@\n+2004-08-31  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* misc.c (gnat_print_type): Use TYPE_RM_SIZE_NUM.\n+\n+\t* trans.c (struct stmt_group): Delete field GLOBAL.\n+\t(gnat_init_stmt_group): Do not initialize it.\n+\t(call_to_gnu): Use save_expr, not protect_multiple_eval.\n+\t(Exception_Handler_to_gnu_sjlj): Call build_int_cst, not build_int_2\n+\t(gnat_to_gnu, case N_Character_Literal, N_String_Literal): Likewise.\n+\t(gnat_to_gnu, case N_Compilation_Unit): Do not set GLOBAL in stmt group.\n+\t(start_stmt_group): Likewise.\n+\t(add_stmt, add_decl_expr): Rework handling of global DECL_EXPRs.\n+\n+\t* utils2.c (ggc.h): Include.\n+\t(build_call_raise): Call build_int_cst, not build_int_2.\n+\n+\t* utils.c (gnat_init_decl_processing): Fix arg to\n+\tbuild_common_tree_nodes.\n+\t(create_subprog_type): Do not use SET_TYPE_CI_CO_LIST.\n+\t(gnat_define_builtin): Set built_in_decls.\n+\t(init_gigi_decls): Call build_int_cst, not build_int_2.\n+\n+\t* ada-tree.h (struct lang_decl, struct lang_type): Field is type tree.\n+\t(GET_TYPE_LANG_SPECIFIC, SET_TYPE_LANG_SPECIFIC): New macros.\n+\t(GET_DECL_LANG_SPECIFIC, SET_DECL_LANG_SPECIFIC): Likewise.\n+\t(TYPE_CI_CO_LIST, SET_TYPE_CI_CO_LIST, TYPE_MODULE,\n+\tSET_TYPE_MODULE): Use them.\n+\t(TYPE_INDEX_TYPE, SET_TYPE_INDEX_TYPE, TYPE_DIGITS_VALUE): Likewise.\n+\t(SET_TYPE_DIGITS_VALUE, TYPE_UNCONSTRAINED_ARRAY): Likewise.\n+\t(SET_TYPE_UNCONSTRAINED_ARRAY, TYPE_ADA_SIZE,\n+\tSET_TYPE_ADA_SIZE): Likewise.\n+\t(TYPE_ACTUAL_BOUNDS, SET_TYPE_ACTUAL_BOUNDS): Likewise.\n+\t(DECL_CONST_CORRESPONDING_VAR,\n+\tSET_DECL_CONST_CORRESPONDING_VAR): Likewise.\n+\t(DECL_ORIGINAL_FIELD, SET_DECL_ORIGINAL_FIELD): Likewise.\n+\t(TYPE_RM_SIZE_INT, TYPE_RM_SIZE_ENUM, SET_TYPE_RM_SIZE_ENUM): Deleted.\n+\t(TYPE_RM_SIZE_NUM): New macro.\n+\t(TYPE_RM_SIZE): Modified to use above.\n+\n+\t* cuintp.c: (build_cst_from_int): New function.\n+\t(UI_To_gnu): Use it.\n+\n+\t* decl.c (gnat_to_gnu_entity): Use TYPE_RM_SIZE_NUM.\n+\t(make_type_from_size): Avoid changing TYPE_UNSIGNED of a type.\n+\t(gnat_substitute_in_type, case ARRAY_TYPE): If old had a\n+\tMIN_EXPR for the size, copy it into new.\n+\n+2004-08-31  Robert Dewar  <dewar@gnat.com>\n+\n+\t* exp_ch6.adb (Expand_Call): Properly handle validity checks for\n+\tpacked indexed component where array is an IN OUT formal. This\n+\tgenerated garbage code previously.\n+\n+\t* gnat_ugn.texi: Document -fverbose-asm\n+\n+\t* gnat-style.texi: Minor updates (note that boolean constants and\n+\tvariables are joined with AND/OR rather than short circuit forms).\n+\n+2004-08-31  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* exp_util.adb (Safe_Unchecked_Type_Conversion): Conversion is safe if\n+\tit is an upward conversion of an untagged type with no representation\n+\tchange.\n+\n+2004-08-31  Thomas Quinot  <quinot@act-europe.fr>\n+\n+\t* rtsfind.ads: Move RCI_Subp_Info and RCI_Subp_Info_Array to\n+\tSystem.Partition_Interface.\n+\n+\t* checks.adb (Apply_Access_Checks): Do not generate checks when\n+\texpander is not active (but check for unset reference to prefix of\n+\tdereference).\n+\n+\t* sem_prag.adb (Analyze_Pragma, case Pragma_Debug): Uniformly rewrite\n+\tpragma Debug as an if statement with a constant condition, for\n+\tconsistent treatment of entity references contained within the\n+\tenclosed procedure call.\n+\n+2004-08-31  Vincent Celier  <celier@gnat.com>\n+\n+\t* bindgen.adb: (Set_EA_Last): New procedure\n+\t(Gen_Exception_Table_Ada, Gen_Exception_Table_C): Use new procedure\n+\tSet_EA_Last.\n+\t(Gen_Adafinal_Ada): If no finalization, adafinal does nothing\n+\t(Gen_Output_File_Ada): Always call Gen_Adafinal_Ada, so that SAL can be\n+\tlinked without errors.\n+\t(Gen_Exception_Table_Ada): Correct bugs when generating code for arrays\n+\tST and EA.\n+\t(Gen_Exception_Table_C): Correct same bugs\n+\n+\t* vms_data.ads: Add new qualifier /VERBOSE_ASM to GCC_Switches\n+\n+\t* g-os_lib.adb (Normalize_Pathname.Get_Directory): When Dir is empty,\n+\ton Windows, make sure that the drive letter is in upper case.\n+\n+\t* g-os_lib.ads (Normalize_Pathname): Add a comment to indicate that on\n+\tWindows, when the drive letter is added and Case_Sensitive is True, the\n+\tdrive letter is forced to upper case.\n+\n+\t* mlib-tgt-irix.adb (Build_Dynamic_Library): Transfer all -lxxx options\n+\tto Options_2 for the call to MLib.Utl.Gcc.\n+\n+\t* bld.adb (Put_Include_Project): Use '/', not '\\' on Windows as\n+\tdirectory separator when defining BASE_DIR.\n+\n+2004-08-19  Pascal Obry  <obry@gnat.com>\n+\n+\t* gprcmd.adb (Extend): Do not output trailing directory separator. This\n+\tis not needed and it confuses Windows GNU/make which does not report\n+\tdirectory terminated by a slash as a directory.\n+\t(gprcmd): Idem for \"pwd\" internal command.\n+\n+\t* Makefile.generic: Use __GPRCOLON__ instead of pipe character in\n+\ttarget names rewrite to fix regressions with recent version of\n+\tGNU/make. Starting with GNU/make 3.80 the pipe character was not\n+\thandled properly anymore.\n+\n 2004-09-01  Andreas Schwab  <schwab@suse.de>\n \n \t* Make-lang.in (EXTRA_GNATBIND_OBJS): Revert last change."}, {"sha": "e18511f89f644e27d97bfa9f9db215e691d6b1ca", "filename": "gcc/ada/Makefile.generic", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2FMakefile.generic", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2FMakefile.generic", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.generic?ref=6cdb2c6e80a9c6300ae56a260c617d6e72b52f19", "patch": "@@ -181,12 +181,12 @@ vpath %$(AR_EXT) $(OBJ_DIR)\n # character be part of a pathname on UNIX and this character can't be used in\n # a pathname on Windows.\n \n-clean_deps = $(subst :,|,$(DEPS_PROJECTS:%=clean_%))\n-compile_deps = $(subst :,|,$(DEPS_PROJECTS:%=compile_%))\n-object_deps = $(subst :,|,$(DEPS_PROJECTS:%=object_%))\n-ada_deps = $(subst :,|,$(DEPS_PROJECTS:%=ada_%))\n-c_deps = $(subst :,|,$(DEPS_PROJECTS:%=c_%))\n-c++_deps = $(subst :,|,$(DEPS_PROJECTS:%=c++_%))\n+clean_deps = $(subst :,__GPRCOLON__,$(DEPS_PROJECTS:%=clean_%))\n+compile_deps = $(subst :,__GPRCOLON__,$(DEPS_PROJECTS:%=compile_%))\n+object_deps = $(subst :,__GPRCOLON__,$(DEPS_PROJECTS:%=object_%))\n+ada_deps = $(subst :,__GPRCOLON__,$(DEPS_PROJECTS:%=ada_%))\n+c_deps = $(subst :,__GPRCOLON__,$(DEPS_PROJECTS:%=c_%))\n+c++_deps = $(subst :,__GPRCOLON__,$(DEPS_PROJECTS:%=c++_%))\n \n # Default target is to build (compile/bind/link)\n all: build\n@@ -200,22 +200,22 @@ c: $(c_deps) internal-c\n c++: $(c++deps) internal-c++\n \n $(clean_deps): force\n-\t@$(MAKE) -C $(dir $(subst |,:,$(@:clean_%=%))) -f Makefile.$(notdir $@) internal-clean\n+\t@$(MAKE) -C $(dir $(subst __GPRCOLON__,:,$(@:clean_%=%))) -f Makefile.$(notdir $@) internal-clean\n \n $(compile_deps): force\n-\t@$(MAKE) -C $(dir $(subst |,:,$(@:compile_%=%))) -f Makefile.$(notdir $@) internal-compile\n+\t@$(MAKE) -C $(dir $(subst __GPRCOLON__,:,$(@:compile_%=%))) -f Makefile.$(notdir $@) internal-compile\n \n $(object_deps): force\n-\t@$(MAKE) -C $(dir $(subst |,:,$(@:object_%=%))) -f Makefile.$(notdir $@) internal-archive-objects ARCHIVE=$(ARCHIVE)\n+\t@$(MAKE) -C $(dir $(subst __GPRCOLON__,:,$(@:object_%=%))) -f Makefile.$(notdir $@) internal-archive-objects ARCHIVE=$(ARCHIVE)\n \n $(ada_deps): force\n-\t@$(MAKE) -C $(dir $(subst |,:,$(@:ada_%=%))) -f Makefile.$(notdir $@) internal-ada\n+\t@$(MAKE) -C $(dir $(subst __GPRCOLON__,:,$(@:ada_%=%))) -f Makefile.$(notdir $@) internal-ada\n \n $(c_deps): force\n-\t@$(MAKE) -C $(dir $(subst |,:,$(@:c_%=%))) -f Makefile.$(notdir $@) internal-c\n+\t@$(MAKE) -C $(dir $(subst __GPRCOLON__,:,$(@:c_%=%))) -f Makefile.$(notdir $@) internal-c\n \n $(c++_deps): force\n-\t@$(MAKE) -C $(dir $(subst |,:,$(@:c++_%=%))) -f Makefile.$(notdir $@) internal-c++\n+\t@$(MAKE) -C $(dir $(subst __GPRCOLON__,:,$(@:c++_%=%))) -f Makefile.$(notdir $@) internal-c++\n \n ifneq ($(EXEC),)\n    EXEC_RULE=-o $(EXEC)"}, {"sha": "7cbbac1d3f5fb97bc9ee489431710fb8cef3461c", "filename": "gcc/ada/ada-tree.h", "status": "modified", "additions": 45, "deletions": 37, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.h?ref=6cdb2c6e80a9c6300ae56a260c617d6e72b52f19", "patch": "@@ -33,10 +33,27 @@ enum gnat_tree_code {\n };\n #undef DEFTREECODE\n \n-/* Ada uses the lang_decl and lang_type fields to hold more trees.  */\n+/* Ada uses the lang_decl and lang_type fields to hold a tree.  */\n union lang_tree_node GTY((desc (\"0\"))) {union tree_node GTY((tag (\"0\"))) t; };\n-struct lang_decl GTY(()) {union lang_tree_node t; };\n-struct lang_type GTY(()) {union lang_tree_node t; };\n+struct lang_decl GTY(()) {tree t; };\n+struct lang_type GTY(()) {tree t; };\n+\n+/* Define macros to get and set the tree in TYPE_ and DECL_LANG_SPECIFIC.  */\n+#define GET_TYPE_LANG_SPECIFIC(NODE) \\\n+  (TYPE_LANG_SPECIFIC (NODE) ? TYPE_LANG_SPECIFIC (NODE)->t : NULL_TREE)\n+#define SET_TYPE_LANG_SPECIFIC(NODE, X)\t\\\n+ (TYPE_LANG_SPECIFIC (NODE)\t\t\t\\\n+  = (TYPE_LANG_SPECIFIC (NODE)\t\t\t\\\n+     ? TYPE_LANG_SPECIFIC (NODE) : ggc_alloc (sizeof (struct lang_type))))   \\\n+ ->t = X;\n+\n+#define GET_DECL_LANG_SPECIFIC(NODE) \\\n+  (DECL_LANG_SPECIFIC (NODE) ? DECL_LANG_SPECIFIC (NODE)->t : NULL_TREE)\n+#define SET_DECL_LANG_SPECIFIC(NODE, VALUE)\t\\\n+ (DECL_LANG_SPECIFIC (NODE)\t\t\t\\\n+  = (DECL_LANG_SPECIFIC (NODE)\t\t\t\\\n+     ? DECL_LANG_SPECIFIC (NODE) : ggc_alloc (sizeof (struct lang_decl))))   \\\n+ ->t = VALUE;\n \n /* Flags added to GCC type nodes.  */\n \n@@ -138,67 +155,58 @@ struct lang_type GTY(()) {union lang_tree_node t; };\n    return values of the out (or in out) parameters that qualify to be passed\n    by copy in copy out.  It is a CONSTRUCTOR.  For a full description of the\n    cico parameter passing mechanism refer to the routine gnat_to_gnu_entity. */\n-#define TYPE_CI_CO_LIST(NODE)   \\\n-  (&TYPE_LANG_SPECIFIC (FUNCTION_TYPE_CHECK (NODE))->t.t)\n-#define SET_TYPE_CI_CO_LIST(NODE, X)   \\\n-  (TYPE_LANG_SPECIFIC (FUNCTION_TYPE_CHECK (NODE)) = (struct lang_type *)(X))\n+#define TYPE_CI_CO_LIST(NODE)  TYPE_LANG_SLOT_1 (FUNCTION_TYPE_CHECK (NODE))\n \n /* For an INTEGER_TYPE with TYPE_MODULAR_P, this is the value of the\n    modulus. */\n-#define TYPE_MODULUS(NODE)  \\\n-  (&TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))->t.t)\n+#define TYPE_MODULUS(NODE) GET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))\n #define SET_TYPE_MODULUS(NODE, X)  \\\n-  (TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE)) = (struct lang_type *)(X))\n+  SET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE), X)\n \n /* For an INTEGER_TYPE that is the TYPE_DOMAIN of some ARRAY_TYPE, points to\n    the type corresponding to the Ada index type.  */\n-#define TYPE_INDEX_TYPE(NODE)\t\\\n-  (&TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))->t.t)\n-#define SET_TYPE_INDEX_TYPE(NODE, X)\t\\\n-  (TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE)) = (struct lang_type *) (X))\n+#define TYPE_INDEX_TYPE(NODE) \\\n+  GET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))\n+#define SET_TYPE_INDEX_TYPE(NODE, X) \\\n+  SET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE), X)\n \n /* For an INTEGER_TYPE with TYPE_VAX_FLOATING_POINT_P, stores the\n    Digits_Value.  */\n #define TYPE_DIGITS_VALUE(NODE) \\\n-  (&TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))->t.t)\n+  GET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))\n #define SET_TYPE_DIGITS_VALUE(NODE, X)  \\\n-  (TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE)) = (struct lang_type *) (X))\n+  SET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE), X)\n \n-/* For INTEGER_TYPE, stores the RM_Size of the type.  */\n-#define TYPE_RM_SIZE_INT(NODE)\tTYPE_LANG_SLOT_1 (INTEGER_TYPE_CHECK (NODE))\n-\n-/* Likewise for ENUMERAL_TYPE.  */\n-#define TYPE_RM_SIZE_ENUM(NODE)\t\\\n-  (&TYPE_LANG_SPECIFIC (ENUMERAL_TYPE_CHECK (NODE))->t.t)\n-#define SET_TYPE_RM_SIZE_ENUM(NODE, X)\t\\\n-  (TYPE_LANG_SPECIFIC (ENUMERAL_TYPE_CHECK (NODE)) = (struct lang_type *)(X))\n+/* For numeric types, stores the RM_Size of the type.  */\n+#define TYPE_RM_SIZE_NUM(NODE)\tTYPE_LANG_SLOT_1 (NUMERICAL_TYPE_CHECK (NODE))\n \n #define TYPE_RM_SIZE(NODE)\t\t\t\t\t\\\n-  (TREE_CODE (NODE) == ENUMERAL_TYPE ? TYPE_RM_SIZE_ENUM (NODE)\t\\\n-   : TREE_CODE (NODE) == INTEGER_TYPE ? TYPE_RM_SIZE_INT (NODE)\t\\\n-   : 0)\n+  (INTEGRAL_TYPE_P (NODE) || TREE_CODE (NODE) == REAL_TYPE\t\\\n+   ? TYPE_RM_SIZE_NUM (NODE) : 0)\n \n /* For a RECORD_TYPE that is a fat pointer, point to the type for the\n    unconstrained object.  Likewise for a RECORD_TYPE that is pointed\n    to by a thin pointer.  */\n #define TYPE_UNCONSTRAINED_ARRAY(NODE)  \\\n-  (&TYPE_LANG_SPECIFIC (RECORD_TYPE_CHECK (NODE))->t.t)\n+  GET_TYPE_LANG_SPECIFIC (RECORD_TYPE_CHECK (NODE))\n #define SET_TYPE_UNCONSTRAINED_ARRAY(NODE, X)  \\\n-  (TYPE_LANG_SPECIFIC (RECORD_TYPE_CHECK (NODE)) = (struct lang_type *)(X))\n+  SET_TYPE_LANG_SPECIFIC (RECORD_TYPE_CHECK (NODE), X)\n \n /* For other RECORD_TYPEs and all UNION_TYPEs and QUAL_UNION_TYPEs, the Ada\n    size of the object.  This differs from the GCC size in that it does not\n    include any rounding up to the alignment of the type.  */\n-#define TYPE_ADA_SIZE(NODE)\t(&TYPE_LANG_SPECIFIC (NODE)->t.t)\n+#define TYPE_ADA_SIZE(NODE)   \\\n+  GET_TYPE_LANG_SPECIFIC (RECORD_OR_UNION_CHECK (NODE))\n #define SET_TYPE_ADA_SIZE(NODE, X) \\\n-  (TYPE_LANG_SPECIFIC (NODE) = (struct lang_type *)(X))\n+  SET_TYPE_LANG_SPECIFIC (RECORD_OR_UNION_CHECK (NODE), X)\n \n /* For an INTEGER_TYPE with TYPE_HAS_ACTUAL_BOUNDS_P or an ARRAY_TYPE, this is\n    the index type that should be used when the actual bounds are required for\n    a template.  This is used in the case of packed arrays.  */\n-#define TYPE_ACTUAL_BOUNDS(NODE)   (&TYPE_LANG_SPECIFIC (NODE)->t.t)\n+#define TYPE_ACTUAL_BOUNDS(NODE)   \\\n+  GET_TYPE_LANG_SPECIFIC (TREE_CHECK2 (NODE, INTEGER_TYPE, ARRAY_TYPE))\n #define SET_TYPE_ACTUAL_BOUNDS(NODE, X) \\\n-  (TYPE_LANG_SPECIFIC (NODE) = (struct lang_type *)(X))\n+  SET_TYPE_LANG_SPECIFIC (TREE_CHECK2 (NODE, INTEGER_TYPE, ARRAY_TYPE), X)\n \n /* In an UNCONSTRAINED_ARRAY_TYPE, points to the record containing both\n    the template and object.\n@@ -242,16 +250,16 @@ struct lang_type GTY(()) {union lang_tree_node t; };\n    memory.  Used when a scalar constant is aliased or has its\n    address taken.  */\n #define DECL_CONST_CORRESPONDING_VAR(NODE) \\\n-  (&DECL_LANG_SPECIFIC (CONST_DECL_CHECK (NODE))->t.t)\n+  GET_DECL_LANG_SPECIFIC (CONST_DECL_CHECK (NODE))\n #define SET_DECL_CONST_CORRESPONDING_VAR(NODE, X) \\\n-  (DECL_LANG_SPECIFIC (CONST_DECL_CHECK (NODE)) = (struct lang_decl *)(X))\n+  SET_DECL_LANG_SPECIFIC (CONST_DECL_CHECK (NODE), X)\n \n /* In a FIELD_DECL, points to the FIELD_DECL that was the ultimate\n    source of the decl.  */\n #define DECL_ORIGINAL_FIELD(NODE) \\\n-  (&DECL_LANG_SPECIFIC (FIELD_DECL_CHECK (NODE))->t.t)\n+  GET_DECL_LANG_SPECIFIC (FIELD_DECL_CHECK (NODE))\n #define SET_DECL_ORIGINAL_FIELD(NODE, X) \\\n-  (DECL_LANG_SPECIFIC (FIELD_DECL_CHECK (NODE)) = (struct lang_decl *)(X))\n+  SET_DECL_LANG_SPECIFIC (FIELD_DECL_CHECK (NODE), X)\n \n /* In a FIELD_DECL corresponding to a discriminant, contains the\n    discriminant number.  */"}, {"sha": "fe9192a251e4e743e6f5151844d2586e144f501c", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 64, "deletions": 39, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=6cdb2c6e80a9c6300ae56a260c617d6e72b52f19", "patch": "@@ -274,6 +274,9 @@ package body Bindgen is\n    --  Set given character in Statement_Buffer at the Last + 1 position\n    --  and increment Last by one to reflect the stored character.\n \n+   procedure Set_EA_Last;\n+   --  Output the number of elements in array EA\n+\n    procedure Set_Int (N : Int);\n    --  Set given value in decimal in Statement_Buffer with no spaces\n    --  starting at the Last + 1 position, and updating Last past the value.\n@@ -334,6 +337,11 @@ package body Bindgen is\n \n       if Hostparm.Java_VM then\n          WBI (\"      System.Standard_Library.Adafinal;\");\n+\n+      --  If there is no finalization, there is nothing to do\n+\n+      elsif Cumulative_Restrictions.Set (No_Finalization) then\n+         WBI (\"      null;\");\n       else\n          WBI (\"      Do_Finalize;\");\n       end if;\n@@ -1262,45 +1270,51 @@ package body Bindgen is\n       Set_String (\") of System.Address := (\");\n \n       if Num = 1 then\n-         Set_String (\"1 => A1);\");\n-         Write_Statement_Buffer;\n+         Set_String (\"1 => \");\n \n       else\n          Write_Statement_Buffer;\n+      end if;\n \n-         for A in ALIs.First .. ALIs.Last loop\n-            if not ALIs.Table (A).Interface\n-              and then ALIs.Table (A).Unit_Exception_Table\n-            then\n-               Get_Decoded_Name_String_With_Brackets\n-                 (Units.Table (ALIs.Table (A).First_Unit).Uname);\n-               Set_Casing (Mixed_Case);\n+      for A in ALIs.First .. ALIs.Last loop\n+         if not ALIs.Table (A).Interface\n+           and then ALIs.Table (A).Unit_Exception_Table\n+         then\n+            Get_Decoded_Name_String_With_Brackets\n+              (Units.Table (ALIs.Table (A).First_Unit).Uname);\n+            Set_Casing (Mixed_Case);\n+\n+            if Num /= 1 then\n                Set_String (\"        \");\n-               Set_String (Name_Buffer (1 .. Name_Len - 2));\n-               Set_String (\"'UET_Address\");\n+            end if;\n \n-               if A = Last then\n-                  Set_String (\");\");\n-               else\n-                  Set_Char (',');\n-               end if;\n+            Set_String (Name_Buffer (1 .. Name_Len - 2));\n+            Set_String (\"'UET_Address\");\n \n-               Write_Statement_Buffer;\n+            if A = Last then\n+               Set_String (\");\");\n+            else\n+               Set_Char (',');\n             end if;\n-         end loop;\n-      end if;\n+\n+            Write_Statement_Buffer;\n+         end if;\n+      end loop;\n \n       WBI (\" \");\n       Set_String (\"      EA : aliased constant array (1 .. \");\n-      Set_Int (Num_Elab_Calls + 2);\n+      Set_EA_Last;\n       Set_String (\") of System.Address := (\");\n       Write_Statement_Buffer;\n-      WBI (\"        \" & Ada_Init_Name.all & \"'Code_Address,\");\n+      Set_String (\"        \" & Ada_Init_Name.all & \"'Code_Address\");\n \n       --  If compiling for the JVM, we directly reference Adafinal because\n       --  we don't import it via Do_Finalize (see Gen_Output_File_Ada).\n \n       if not Cumulative_Restrictions.Set (No_Finalization) then\n+         Set_Char (',');\n+         Write_Statement_Buffer;\n+\n          if Hostparm.Java_VM then\n             Set_String\n               (\"        System.Standard_Library.Adafinal'Code_Address\");\n@@ -1345,7 +1359,7 @@ package body Bindgen is\n       Set_String (\"      SDP_Table_Build (ST'Address, \");\n       Set_Int (Num);\n       Set_String (\", EA'Address, \");\n-      Set_Int (Num_Elab_Calls + 2);\n+      Set_EA_Last;\n       Set_String (\");\");\n       Write_Statement_Buffer;\n    end Gen_Exception_Table_Ada;\n@@ -1460,13 +1474,15 @@ package body Bindgen is\n \n       WBI (\"\");\n       Set_String (\"   void (*ea[\");\n-      Set_Int (Num_Elab_Calls + 2);\n+      Set_EA_Last;\n       Set_String (\"]) () = {\");\n       Write_Statement_Buffer;\n \n-      WBI (\"     \" & Ada_Init_Name.all & \",\");\n+      Set_String (\"     \" & Ada_Init_Name.all);\n \n       if not Cumulative_Restrictions.Set (No_Finalization) then\n+         Set_Char (',');\n+         Write_Statement_Buffer;\n          Set_String (\"     system__standard_library__adafinal\");\n       end if;\n \n@@ -1494,7 +1510,7 @@ package body Bindgen is\n       Set_String (\"   __gnat_SDP_Table_Build (&st, \");\n       Set_Int (Num);\n       Set_String (\", ea, \");\n-      Set_Int (Num_Elab_Calls + 2);\n+      Set_EA_Last;\n       Set_String (\");\");\n       Write_Statement_Buffer;\n    end Gen_Exception_Table_C;\n@@ -2244,15 +2260,10 @@ package body Bindgen is\n             \"\"\"__gnat_ada_main_program_name\"\");\");\n       end if;\n \n-      --  No need to generate a finalization routine if finalization\n-      --  is restricted, since there is nothing to do in this case.\n-\n-      if not Cumulative_Restrictions.Set (No_Finalization) then\n-         WBI (\"\");\n-         WBI (\"   procedure \" & Ada_Final_Name.all & \";\");\n-         WBI (\"   pragma Export (C, \" & Ada_Final_Name.all & \", \"\"\" &\n-              Ada_Final_Name.all & \"\"\");\");\n-      end if;\n+      WBI (\"\");\n+      WBI (\"   procedure \" & Ada_Final_Name.all & \";\");\n+      WBI (\"   pragma Export (C, \" & Ada_Final_Name.all & \", \"\"\" &\n+           Ada_Final_Name.all & \"\"\");\");\n \n       WBI (\"\");\n       WBI (\"   procedure \" & Ada_Init_Name.all & \";\");\n@@ -2371,11 +2382,7 @@ package body Bindgen is\n \n       Gen_Adainit_Ada;\n \n-      --  No need to generate a finalization routine if no finalization\n-\n-      if not Cumulative_Restrictions.Set (No_Finalization) then\n-         Gen_Adafinal_Ada;\n-      end if;\n+      Gen_Adafinal_Ada;\n \n       if Bind_Main_Program then\n \n@@ -3023,6 +3030,24 @@ package body Bindgen is\n       Statement_Buffer (Last) := C;\n    end Set_Char;\n \n+   -----------------\n+   -- Set_EA_Last --\n+   -----------------\n+\n+   procedure Set_EA_Last is\n+   begin\n+      --  When there is no finalization, only adainit is added\n+\n+      if Cumulative_Restrictions.Set (No_Finalization) then\n+         Set_Int (Num_Elab_Calls + 1);\n+\n+      --  When there is finalization, both adainit and adafinal are added\n+\n+      else\n+         Set_Int (Num_Elab_Calls + 2);\n+      end if;\n+   end Set_EA_Last;\n+\n    -------------\n    -- Set_Int --\n    -------------"}, {"sha": "e8b5c89eb82d633f28ed34ff46c75259d4db495a", "filename": "gcc/ada/bld.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fbld.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fbld.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbld.adb?ref=6cdb2c6e80a9c6300ae56a260c617d6e72b52f19", "patch": "@@ -2384,12 +2384,12 @@ package body Bld is\n             Last : Natural := Included_Directory_Path'Last;\n \n          begin\n-            --  Remove a possible directory separator at the end of the\n-            --  directory.\n+            --  Remove possible directory separator at end of the directory\n \n             if Last >= Included_Directory_Path'First\n               and then (Included_Directory_Path (Last) = Directory_Separator\n-                          or else Included_Directory_Path (Last) = '/')\n+                          or else\n+                        Included_Directory_Path (Last) = '/')\n             then\n                Last := Last - 1;\n             end if;\n@@ -2402,7 +2402,7 @@ package body Bld is\n             if not Is_Absolute_Path (Included_Directory_Path) then\n                Put (\"$(\");\n                Put (Including_Project_Name);\n-               Put (\".base_dir)\" & Directory_Separator);\n+               Put (\".base_dir)/\");\n             end if;\n \n             Put (Included_Directory_Path"}, {"sha": "3c7839754e4299f0aaf313dde5b7f0c372af6e1f", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=6cdb2c6e80a9c6300ae56a260c617d6e72b52f19", "patch": "@@ -369,15 +369,23 @@ package body Checks is\n          Check_Unset_Reference (P);\n       end if;\n \n-      --  Don't need access check if prefix is known to be non-null\n+      --  We do not need access checks if prefix is known to be non-null\n \n       if Known_Non_Null (P) then\n          return;\n \n-      --  Don't need access checks if they are suppressed on the type\n+      --  We do not need access checks if they are suppressed on the type\n \n       elsif Access_Checks_Suppressed (Etype (P)) then\n          return;\n+\n+         --  We do not need checks if we are not generating code (i.e. the\n+         --  expander is not active). This is not just an optimization, there\n+         --  are cases (e.g. with pragma Debug) where generating the checks\n+         --  can cause real trouble).\n+\n+      elsif not Expander_Active then\n+         return;\n       end if;\n \n       --  Case where P is an entity name\n@@ -569,8 +577,8 @@ package body Checks is\n       --  flag is not set anyway, or we are not doing code expansion.\n \n       if Backend_Overflow_Checks_On_Target\n-        or not Do_Overflow_Check (N)\n-        or not Expander_Active\n+        or else not Do_Overflow_Check (N)\n+        or else not Expander_Active\n       then\n          return;\n       end if;\n@@ -1364,7 +1372,6 @@ package body Checks is\n          --  part of the test is not controlled by the -gnato switch.\n \n          if Do_Division_Check (N) then\n-\n             if (not ROK) or else (Rlo <= 0 and then 0 <= Rhi) then\n                Insert_Action (N,\n                  Make_Raise_Constraint_Error (Loc,"}, {"sha": "a6ce488f374809adb51cbf8e09687f811af227b7", "filename": "gcc/ada/cuintp.c", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fcuintp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fcuintp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcuintp.c?ref=6cdb2c6e80a9c6300ae56a260c617d6e72b52f19", "patch": "@@ -50,52 +50,63 @@\n    For efficiency, this method is used only for integer values larger than the\n    constant Uint_Bias.  If a Uint is less than this constant, then it contains\n    the integer value itself.  The origin of the Uints_Ptr table is adjusted so\n-   that a Uint value of Uint_Bias indexes the first element.  */\n+   that a Uint value of Uint_Bias indexes the first element.\n \n-/* Similarly to UI_To_Int, but return a GCC INTEGER_CST.  Overflow is tested\n-   by the constant-folding used to build the node.  TYPE is the GCC type of the\n-   resulting node.  */\n+   First define a utility function that operates like build_int_cst for\n+   integral types and does a conversion to floating-point for real types.  */\n+\n+static tree\n+build_cst_from_int (tree type, HOST_WIDE_INT low)\n+{\n+  if (TREE_CODE (type) == REAL_TYPE)\n+    return convert (type, build_int_cst (NULL_TREE, low));\n+  else\n+    return force_fit_type (build_int_cst (type, low), false, false, false);\n+}\n+\n+/* Similar to UI_To_Int, but return a GCC INTEGER_CST or REAL_CST node,\n+   depending on whether TYPE is an integral or real type.  Overflow is tested\n+   by the constant-folding used to build the node.  TYPE is the GCC type of\n+   the resulting node.  */\n \n tree\n UI_To_gnu (Uint Input, tree type)\n {\n   tree gnu_ret;\n \n   if (Input <= Uint_Direct_Last)\n-    gnu_ret = convert (type, build_int_cst (NULL_TREE,\n-\t\t\t\t\t    Input - Uint_Direct_Bias));\n+    gnu_ret = build_cst_from_int (type, Input - Uint_Direct_Bias);\n   else\n     {\n-      Int Idx =    Uints_Ptr[Input].Loc;\n+      Int Idx = Uints_Ptr[Input].Loc;\n       Pos Length = Uints_Ptr[Input].Length;\n       Int First = Udigits_Ptr[Idx];\n       /* Do computations in integer type or TYPE whichever is wider, then\n \t convert later.  This avoid overflow if type is short integer.  */\n       tree comp_type\n-\t= (TYPE_PRECISION (type) >= TYPE_PRECISION (integer_type_node)\n+\t= ((TREE_CODE (type) == REAL_TYPE\n+\t    || TYPE_PRECISION (type) >= TYPE_PRECISION (integer_type_node))\n \t   ? type : integer_type_node);\n-      tree gnu_base = convert (comp_type, build_int_cst (NULL_TREE, Base));\n+      tree gnu_base = build_cst_from_int (comp_type, Base);\n \n       if (Length <= 0)\n \tabort ();\n \n-      gnu_ret = convert (comp_type, build_int_cst (NULL_TREE, First));\n+      gnu_ret = build_cst_from_int (comp_type, First);\n       if (First < 0)\n \tfor (Idx++, Length--; Length; Idx++, Length--)\n \t  gnu_ret = fold (build (MINUS_EXPR, comp_type,\n \t\t\t\t fold (build (MULT_EXPR, comp_type,\n \t\t\t\t\t      gnu_ret, gnu_base)),\n-\t\t\t\t convert (comp_type,\n-\t\t\t\t\t  build_int_cst (NULL_TREE,\n-\t\t\t\t\t\t\t Udigits_Ptr[Idx]))));\n+\t\t\t\t build_cst_from_int (comp_type,\n+\t\t\t\t\t\t     Udigits_Ptr[Idx])));\n       else\n \tfor (Idx++, Length--; Length; Idx++, Length--)\n \t  gnu_ret = fold (build (PLUS_EXPR, comp_type,\n \t\t\t\t fold (build (MULT_EXPR, comp_type,\n \t\t\t\t\t      gnu_ret, gnu_base)),\n-\t\t\t\t convert (comp_type,\n-\t\t\t\t\t  build_int_cst (NULL_TREE,\n-\t\t\t\t\t\t\t Udigits_Ptr[Idx]))));\n+\t\t\t\t build_cst_from_int (comp_type,\n+\t\t\t\t\t\t     Udigits_Ptr[Idx])));\n     }\n \n   gnu_ret = convert (type, gnu_ret);"}, {"sha": "33bbbb1dd6148663249d366ff6f3c026f6904d65", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=6cdb2c6e80a9c6300ae56a260c617d6e72b52f19", "patch": "@@ -1350,7 +1350,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  tree gnu_field_type = gnu_type;\n \t  tree gnu_field;\n \n-\t  TYPE_RM_SIZE_INT (gnu_field_type)\n+\t  TYPE_RM_SIZE_NUM (gnu_field_type)\n \t    = UI_To_gnu (RM_Size (gnat_entity), bitsizetype);\n \t  gnu_type = make_node (RECORD_TYPE);\n \t  TYPE_NAME (gnu_type) = create_concat_name (gnat_entity, \"LJM\");\n@@ -5978,9 +5978,9 @@ set_rm_size (Uint uint_size, tree gnu_type, Entity_Id gnat_entity)\n   /* Otherwise, set the RM_Size.  */\n   if (TREE_CODE (gnu_type) == INTEGER_TYPE\n       && Is_Discrete_Or_Fixed_Point_Type (gnat_entity))\n-    TYPE_RM_SIZE_INT (gnu_type) = size;\n+    TYPE_RM_SIZE_NUM (gnu_type) = size;\n   else if (TREE_CODE (gnu_type) == ENUMERAL_TYPE)\n-    SET_TYPE_RM_SIZE_ENUM (gnu_type, size);\n+    TYPE_RM_SIZE_NUM (gnu_type) = size;\n   else if ((TREE_CODE (gnu_type) == RECORD_TYPE\n \t    || TREE_CODE (gnu_type) == UNION_TYPE\n \t    || TREE_CODE (gnu_type) == QUAL_UNION_TYPE)\n@@ -5998,6 +5998,7 @@ make_type_from_size (tree type, tree size_tree, bool biased_p)\n {\n   tree new_type;\n   unsigned HOST_WIDE_INT size;\n+  bool unsigned_p;\n \n   /* If size indicates an error, just return TYPE to avoid propagating the\n      error.  Likewise if it's too large to represent.  */\n@@ -6017,20 +6018,20 @@ make_type_from_size (tree type, tree size_tree, bool biased_p)\n \t\t\t      && TYPE_BIASED_REPRESENTATION_P (type))))\n \tbreak;\n \n+      biased_p |= (TREE_CODE (type) == INTEGER_TYPE\n+\t\t   && TYPE_BIASED_REPRESENTATION_P (type));\n+      unsigned_p = TYPE_UNSIGNED (type) || biased_p;\n+\n       size = MIN (size, LONG_LONG_TYPE_SIZE);\n-      new_type = make_signed_type (size);\n+      new_type\n+\t= unsigned_p ? make_unsigned_type (size) : make_signed_type (size);\n       TREE_TYPE (new_type) = TREE_TYPE (type) ? TREE_TYPE (type) : type;\n       TYPE_MIN_VALUE (new_type)\n \t= convert (TREE_TYPE (new_type), TYPE_MIN_VALUE (type));\n       TYPE_MAX_VALUE (new_type)\n \t= convert (TREE_TYPE (new_type), TYPE_MAX_VALUE (type));\n-      TYPE_BIASED_REPRESENTATION_P (new_type)\n-\t= ((TREE_CODE (type) == INTEGER_TYPE\n-\t    && TYPE_BIASED_REPRESENTATION_P (type))\n-\t   || biased_p);\n-      TYPE_UNSIGNED (new_type)\n-\t= TYPE_UNSIGNED (type) | TYPE_BIASED_REPRESENTATION_P (new_type);\n-      TYPE_RM_SIZE_INT (new_type) = bitsize_int (size);\n+      TYPE_BIASED_REPRESENTATION_P (new_type) = biased_p;\n+      TYPE_RM_SIZE_NUM (new_type) = bitsize_int (size);\n       return new_type;\n \n     case RECORD_TYPE:\n@@ -6262,6 +6263,17 @@ gnat_substitute_in_type (tree t, tree f, tree r)\n \tTYPE_CONVENTION_FORTRAN_P (new) = TYPE_CONVENTION_FORTRAN_P (t);\n \tlayout_type (new);\n \tTYPE_ALIGN (new) = TYPE_ALIGN (t);\n+\n+\t/* If we had bounded the sizes of T by a constant, bound the sizes of\n+\t   NEW by the same constant.  */\n+\tif (TREE_CODE (TYPE_SIZE (t)) == MIN_EXPR)\n+\t  TYPE_SIZE (new)\n+\t    = size_binop (MIN_EXPR, TREE_OPERAND (TYPE_SIZE (t), 1),\n+\t\t\t  TYPE_SIZE (new));\n+\tif (TREE_CODE (TYPE_SIZE_UNIT (t)) == MIN_EXPR)\n+\t  TYPE_SIZE_UNIT (new)\n+\t    = size_binop (MIN_EXPR, TREE_OPERAND (TYPE_SIZE_UNIT (t), 1),\n+\t\t\t  TYPE_SIZE_UNIT (new));\n \treturn new;\n       }\n "}, {"sha": "0dd84eaf22c10192578e9348035687a927ad2035", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=6cdb2c6e80a9c6300ae56a260c617d6e72b52f19", "patch": "@@ -1572,8 +1572,11 @@ package body Exp_Ch6 is\n          --  are entities.\n \n          if Validity_Checks_On then\n-            if Ekind (Formal) = E_In_Parameter\n-              and then Validity_Check_In_Params\n+            if  (Ekind (Formal) = E_In_Parameter\n+                   and then Validity_Check_In_Params)\n+              or else\n+                (Ekind (Formal) = E_In_Out_Parameter\n+                   and then Validity_Check_In_Out_Params)\n             then\n                --  If the actual is an indexed component of a packed\n                --  type, it has not been expanded yet. It will be\n@@ -1585,11 +1588,6 @@ package body Exp_Ch6 is\n                end if;\n \n                Ensure_Valid (Actual);\n-\n-            elsif Ekind (Formal) = E_In_Out_Parameter\n-              and then Validity_Check_In_Out_Params\n-            then\n-               Ensure_Valid (Actual);\n             end if;\n          end if;\n "}, {"sha": "5d5103785ead5189d3e04983c59c754c2fdbc692", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=6cdb2c6e80a9c6300ae56a260c617d6e72b52f19", "patch": "@@ -1327,7 +1327,7 @@ package body Exp_Util is\n \n    begin\n       --  Loop to determine whether there is a component reference in\n-      --  the left hand side if this appears on the left side of an\n+      --  the left hand side if Exp appears on the left side of an\n       --  assignment statement. Needed to determine if form of result\n       --  must be a variable.\n \n@@ -3844,6 +3844,16 @@ package body Exp_Util is\n       if Implementation_Base_Type (Otyp) = Implementation_Base_Type (Ityp) then\n          return True;\n \n+      --  Same if this is an upwards conversion of an untagged type, and there\n+      --  are no constraints involved (could be more general???)\n+\n+      elsif Etype (Ityp) = Otyp\n+        and then not Is_Tagged_Type (Ityp)\n+        and then not Has_Discriminants (Ityp)\n+        and then No (First_Rep_Item (Base_Type (Ityp)))\n+      then\n+         return True;\n+\n       --  If the size of output type is known at compile time, there is\n       --  never a problem.  Note that unconstrained records are considered\n       --  to be of known size, but we can't consider them that way here,"}, {"sha": "75c82e53e76474fa26b4a2d9484c9b9f8664dc3e", "filename": "gcc/ada/g-os_lib.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fg-os_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fg-os_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-os_lib.adb?ref=6cdb2c6e80a9c6300ae56a260c617d6e72b52f19", "patch": "@@ -1541,6 +1541,14 @@ package body GNAT.OS_Lib is\n                   Buffer (Path_Len) := Directory_Separator;\n                end if;\n \n+               --  By default, the drive letter on Windows is in upper case\n+\n+               if On_Windows and then Path_Len >= 2 and then\n+                 Buffer (2) = ':'\n+               then\n+                  System.Case_Util.To_Upper (Buffer (1 .. 1));\n+               end if;\n+\n                return Buffer (1 .. Path_Len);\n             end;\n          end if;"}, {"sha": "d88682517ec04a2b39620b4136399fa718371528", "filename": "gcc/ada/g-os_lib.ads", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fg-os_lib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fg-os_lib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-os_lib.ads?ref=6cdb2c6e80a9c6300ae56a260c617d6e72b52f19", "patch": "@@ -398,6 +398,14 @@ pragma Elaborate_Body (OS_Lib);\n    --  not true; for example, this is not true in Unix for two hard links\n    --  designating the same file.\n    --\n+   --  On Windows, the returned path will start with a drive letter except\n+   --  when Directory is not empty and does not include a drive letter.\n+   --  If Directory is empty (the default) and Name is a relative path\n+   --  or an absolute path without drive letter, the letter of the current\n+   --  drive will start the returned path. If Case_Sensitive is True\n+   --  (the default), then this drive letter will be forced to upper case\n+   --  (\"C:\\...\").\n+   --\n    --  If Resolve_Links is set to True, then the symbolic links, on systems\n    --  that support them, will be fully converted to the name of the file\n    --  or directory pointed to. This is slightly less efficient, since it"}, {"sha": "a3adc652ecda9bba9ab6a2500a867db70305a03b", "filename": "gcc/ada/gnat-style.texi", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fgnat-style.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fgnat-style.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat-style.texi?ref=6cdb2c6e80a9c6300ae56a260c617d6e72b52f19", "patch": "@@ -490,7 +490,8 @@ following is allowed:\n \n @item\n Conditions should use short-circuit forms (@code{and then},\n-@code{or else}).\n+@code{or else}), except when the operands are boolean variables\n+or boolean constants.\n @cindex Short-circuit forms\n \n @item\n@@ -508,6 +509,23 @@ Complex conditions in @code{if} statements are indented two characters:\n @end group\n @end smallexample\n \n+@noindent\n+There are some cases where complex conditionals can be laid out\n+in manners that do not follow these rules to preserve better\n+parallelism between branches, e.g.\n+\n+@smallexample @c adanocomment\n+@group\n+      if xyz.abc (gef) = 'c'\n+           or else\n+         xyz.abc (gef) = 'x'\n+      then\n+         ...\n+      end if;\n+@end group\n+@end smallexample\n+\n+\n @item\n Every @code{if} block is preceded and followed by a blank line, except\n where it begins or ends a @syntax{sequence_of_statements}."}, {"sha": "b9617b4a1f61000f5130bec9246c31931efc2d56", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=6cdb2c6e80a9c6300ae56a260c617d6e72b52f19", "patch": "@@ -4084,6 +4084,12 @@ generated, using @file{^.s^.S^} as the extension,\n instead of the object file.\n This may be useful if you need to examine the generated assembly code.\n \n+@item ^-fverbose-asm^/VERBOSE_ASM^\n+@cindex @option{^-fverbose-asm^/VERBOSE_ASM^} (@code{gcc})\n+^Used in conjunction with @option{-S}^Used in place of @option{/ASM}^\n+to cause the generated assembly code file to be annotated with variable\n+names, making it significantly easier to follow.\n+\n @item ^-v^/VERBOSE^\n @cindex @option{^-v^/VERBOSE^} (@code{gcc})\n Show commands generated by the @code{gcc} driver. Normally used only for"}, {"sha": "64bc74fd61d63d5a9d38db51f89586e6550ce7a7", "filename": "gcc/ada/gprcmd.adb", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fgprcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fgprcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgprcmd.adb?ref=6cdb2c6e80a9c6300ae56a260c617d6e72b52f19", "patch": "@@ -299,21 +299,19 @@ procedure Gprcmd is\n \n          loop\n             Read (Iter, Buffer, Last);\n-\n             exit when Last = 0;\n \n             if Buffer (1 .. Last) /= \".\"\n               and then Buffer (1 .. Last) /= \"..\"\n             then\n                declare\n-                  Abs_Dir : constant String := D & Buffer (1 .. Last);\n-\n+                  Abs_Dir : constant String := D & \"/\" & Buffer (1 .. Last);\n                begin\n                   if Is_Directory (Abs_Dir)\n                     and then not Is_Symbolic_Link (Abs_Dir)\n                   then\n                      Put (' ' & Abs_Dir);\n-                     Recursive_Extend (Abs_Dir & '/');\n+                     Recursive_Extend (Abs_Dir);\n                   end if;\n                end;\n             end if;\n@@ -339,7 +337,7 @@ procedure Gprcmd is\n       end if;\n \n       declare\n-         D : constant String := Dir (Dir'First .. Dir'Last - 2);\n+         D : constant String := Dir (Dir'First .. Dir'Last - 3);\n       begin\n          Put (D);\n          Recursive_Extend (D);\n@@ -406,7 +404,11 @@ begin\n          Usage;\n \n       elsif Cmd = \"pwd\" then\n-         Put (Format_Pathname (Get_Current_Dir, UNIX));\n+         declare\n+            CD : constant String := Get_Current_Dir;\n+         begin\n+            Put (Format_Pathname (CD (CD'First .. CD'Last - 1), UNIX));\n+         end;\n \n       elsif Cmd = \"cat\" then\n          Check_Args (Argument_Count = 2);"}, {"sha": "cdaa862bd75b3db99b571d6201d09707de4ea9b9", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=6cdb2c6e80a9c6300ae56a260c617d6e72b52f19", "patch": "@@ -518,7 +518,7 @@ gnat_print_type (FILE *file, tree node, int indent)\n       break;\n \n     case ENUMERAL_TYPE:\n-      print_node (file, \"RM size\", TYPE_RM_SIZE_ENUM (node), indent + 4);\n+      print_node (file, \"RM size\", TYPE_RM_SIZE_NUM (node), indent + 4);\n       break;\n \n     case INTEGER_TYPE:\n@@ -532,7 +532,7 @@ gnat_print_type (FILE *file, tree node, int indent)\n       else\n \tprint_node (file, \"index type\", TYPE_INDEX_TYPE (node), indent + 4);\n \n-      print_node (file, \"RM size\", TYPE_RM_SIZE_INT (node), indent + 4);\n+      print_node (file, \"RM size\", TYPE_RM_SIZE_NUM (node), indent + 4);\n       break;\n \n     case ARRAY_TYPE:"}, {"sha": "6429eae4e1540c4d6b747752e9caee1127677f91", "filename": "gcc/ada/mlib-tgt-irix.adb", "status": "modified", "additions": 47, "deletions": 6, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fmlib-tgt-irix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fmlib-tgt-irix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-irix.adb?ref=6cdb2c6e80a9c6300ae56a260c617d6e72b52f19", "patch": "@@ -122,6 +122,16 @@ package body MLib.Tgt is\n \n       Init_Fini : Argument_List_Access := Empty_Argument_List;\n \n+      N_Options    : Argument_List := Options;\n+      Options_Last : Natural := N_Options'Last;\n+      --  After moving -lxxx to Options_2, N_Options up to index Options_Last\n+      --  will contain the Options to pass to MLib.Utl.Gcc.\n+\n+      Options_2      : Argument_List (Options'Range);\n+      Options_2_Last : Natural := Options_2'First - 1;\n+      --  Options_2 up to index Options_2_Last will contain the Options_2 to\n+      --  pass to MLib.Utl.Gcc.\n+\n    begin\n       if Opt.Verbose_Mode then\n          Write_Str (\"building relocatable shared library \");\n@@ -136,12 +146,39 @@ package body MLib.Tgt is\n          Init_Fini (4) := new String'(\"-Wl,\" & Lib_Filename & \"final\");\n       end if;\n \n+      --  Move all -lxxx to Options_2\n+\n+      declare\n+         Index : Natural := N_Options'First;\n+         Arg   : String_Access;\n+\n+      begin\n+         while Index <= Options_Last loop\n+            Arg := N_Options (Index);\n+\n+            if Arg'Length > 2\n+              and then Arg (Arg'First .. Arg'First + 1) = \"-l\"\n+            then\n+               Options_2_Last := Options_2_Last + 1;\n+               Options_2 (Options_2_Last) := Arg;\n+               N_Options (Index .. Options_Last - 1) :=\n+                 N_Options (Index + 1 .. Options_Last);\n+               Options_Last := Options_Last - 1;\n+\n+            else\n+               Index := Index + 1;\n+            end if;\n+         end loop;\n+      end;\n+\n       if Lib_Version = \"\" then\n          MLib.Utl.Gcc\n            (Output_File => Lib_File,\n             Objects     => Ofiles,\n-            Options     => Options & Init_Fini.all,\n-            Driver_Name => Driver_Name);\n+            Options     => N_Options (N_Options'First .. Options_Last) &\n+                           Init_Fini.all,\n+            Driver_Name => Driver_Name,\n+            Options_2   => Options_2 (Options_2'First .. Options_2_Last));\n \n       else\n          Version_Arg := new String'(\"-Wl,-soname,\" & Lib_Version);\n@@ -150,16 +187,20 @@ package body MLib.Tgt is\n             MLib.Utl.Gcc\n               (Output_File => Lib_Version,\n                Objects     => Ofiles,\n-               Options     => Options & Version_Arg & Init_Fini.all,\n-               Driver_Name => Driver_Name);\n+               Options     => N_Options (N_Options'First .. Options_Last) &\n+                              Version_Arg & Init_Fini.all,\n+               Driver_Name => Driver_Name,\n+               Options_2   => Options_2 (Options_2'First .. Options_2_Last));\n             Symbolic_Link_Needed := Lib_Version /= Lib_File;\n \n          else\n             MLib.Utl.Gcc\n               (Output_File => Lib_Dir & Directory_Separator & Lib_Version,\n                Objects     => Ofiles,\n-               Options     => Options & Version_Arg & Init_Fini.all,\n-               Driver_Name => Driver_Name);\n+               Options     => N_Options (N_Options'First .. Options_Last) &\n+                              Version_Arg & Init_Fini.all,\n+               Driver_Name => Driver_Name,\n+               Options_2   => Options_2 (Options_2'First .. Options_2_Last));\n             Symbolic_Link_Needed :=\n               Lib_Dir & Directory_Separator & Lib_Version /= Lib_File;\n          end if;"}, {"sha": "ce8368422e18bbc68a8067561ff267c18a8900c5", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=6cdb2c6e80a9c6300ae56a260c617d6e72b52f19", "patch": "@@ -1018,7 +1018,10 @@ package Rtsfind is\n      RE_Register_Passive_Package,        -- System.Partition_Interface\n      RE_Register_Receiving_Stub,         -- System.Partition_Interface\n      RE_RCI_Info,                        -- System.Partition_Interface\n+     RE_RCI_Subp_Info,                   -- System.Partition_Interface\n+     RE_RCI_Subp_Info_Array,             -- System.Partition_Interface\n      RE_Subprogram_Id,                   -- System.Partition_Interface\n+     RE_Get_RAS_Info,                    -- System.Partition_Interface\n \n      RE_Global_Pool_Object,              -- System.Pool_Global\n \n@@ -1075,9 +1078,6 @@ package Rtsfind is\n      RE_Get_Reference,                   -- System.PolyORB_Interface\n      RE_Local_Oid_To_Address,            -- System.PolyORB_Interface\n      RE_RCI_Locator,                     -- System.PolyORB_Interface\n-     RE_RCI_Subp_Info,                   -- System.PolyORB_Interface\n-     RE_RCI_Subp_Info_Array,             -- System.PolyORB_Interface\n-     RE_Get_RAS_Ref,                     -- System.PolyORB_Interface\n      RE_Asynchronous_P_To_Sync_Scope,    -- System.PolyORB_Interface\n      RE_Buffer_Stream_Type,              -- System.PolyORB_Interface\n      RE_Allocate_Buffer,                 -- System.PolyORB_Interface\n@@ -2100,7 +2100,10 @@ package Rtsfind is\n      RE_Register_Passive_Package         => System_Partition_Interface,\n      RE_Register_Receiving_Stub          => System_Partition_Interface,\n      RE_RCI_Info                         => System_Partition_Interface,\n+     RE_RCI_Subp_Info                    => System_Partition_Interface,\n+     RE_RCI_Subp_Info_Array              => System_Partition_Interface,\n      RE_Subprogram_Id                    => System_Partition_Interface,\n+     RE_Get_RAS_Info                     => System_Partition_Interface,\n \n      RE_To_PolyORB_String                => System_PolyORB_Interface,\n      RE_To_Standard_String               => System_PolyORB_Interface,\n@@ -2145,9 +2148,6 @@ package Rtsfind is\n      RE_Get_Reference                    => System_PolyORB_Interface,\n      RE_Local_Oid_To_Address             => System_PolyORB_Interface,\n      RE_RCI_Locator                      => System_PolyORB_Interface,\n-     RE_RCI_Subp_Info                    => System_PolyORB_Interface,\n-     RE_RCI_Subp_Info_Array              => System_PolyORB_Interface,\n-     RE_Get_RAS_Ref                      => System_PolyORB_Interface,\n      RE_Asynchronous_P_To_Sync_Scope     => System_PolyORB_Interface,\n      RE_Buffer_Stream_Type               => System_PolyORB_Interface,\n      RE_Allocate_Buffer                  => System_PolyORB_Interface,"}, {"sha": "02b194739624585f68c908ecf61c3f1c8a90c6e0", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=6cdb2c6e80a9c6300ae56a260c617d6e72b52f19", "patch": "@@ -37,7 +37,6 @@ with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n-with Expander; use Expander;\n with Exp_Dist; use Exp_Dist;\n with Fname;    use Fname;\n with Hostparm; use Hostparm;\n@@ -5366,29 +5365,14 @@ package body Sem_Prag is\n          when Pragma_Debug => Debug : begin\n             GNAT_Pragma;\n \n-            --  If assertions are enabled, and we are expanding code, then\n-            --  we rewrite the pragma with its corresponding procedure call\n-            --  and then analyze the call.\n+            --  Rewrite into a conditional with a static condition\n \n-            if Assertions_Enabled and Expander_Active then\n-               Rewrite (N, Relocate_Node (Debug_Statement (N)));\n-               Analyze (N);\n-\n-            --  Otherwise we work a bit to get a tree that makes sense\n-            --  for ASIS purposes, namely a pragma with an analyzed\n-            --  argument that looks like a procedure call.\n-\n-            else\n-               Expander_Mode_Save_And_Set (False);\n-               Rewrite (N, Relocate_Node (Debug_Statement (N)));\n-               Analyze (N);\n-               Rewrite (N,\n-                 Make_Pragma (Loc,\n-                   Chars => Name_Debug,\n-                   Pragma_Argument_Associations =>\n-                     New_List (Relocate_Node (N))));\n-               Expander_Mode_Restore;\n-            end if;\n+            Rewrite (N, Make_Implicit_If_Statement (N,\n+              Condition => New_Occurrence_Of (Boolean_Literals (\n+                Assertions_Enabled and Expander_Active), Loc),\n+              Then_Statements => New_List (\n+                Relocate_Node (Debug_Statement (N)))));\n+            Analyze (N);\n          end Debug;\n \n          ---------------------"}, {"sha": "c22c192da08279f291290e24ffef617d98e9dc47", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 31, "deletions": 42, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=6cdb2c6e80a9c6300ae56a260c617d6e72b52f19", "patch": "@@ -82,7 +82,6 @@ bool type_annotate_only;\n \n struct stmt_group GTY((chain_next (\"%h.previous\"))) {\n   struct stmt_group *previous;\t/* Previous code group.  */\n-  struct stmt_group *global;\t/* Global code group from the level.  */\n   tree stmt_list;\t\t/* List of statements for this code group. */\n   tree block;\t\t\t/* BLOCK for this code group, if any. */\n   tree cleanups;\t\t/* Cleanups for this code group, if any.  */\n@@ -286,8 +285,6 @@ gnat_init_stmt_group ()\n   init_code_table ();\n   start_stmt_group ();\n \n-  current_stmt_group->global = current_stmt_group;\n-\n   /* Enable GNAT stack checking method if needed */\n   if (!Stack_Check_Probes_On_Target)\n     set_stack_check_libfunc (gen_rtx_SYMBOL_REF (Pmode, \"_gnat_stack_check\"));\n@@ -1862,7 +1859,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t{\n \t  tree gnu_name;\n \n-\t  gnu_subprog_call = protect_multiple_eval (gnu_subprog_call);\n+\t  gnu_subprog_call = save_expr (gnu_subprog_call);\n \t  gnu_name_list = nreverse (gnu_name_list);\n \n \t  /* If any of the names had side-effects, ensure they are all\n@@ -2217,8 +2214,7 @@ Exception_Handler_to_gnu_sjlj (Node_Id gnat_node)\n \t\t= build_binary_op\n \t\t  (TRUTH_ORIF_EXPR, integer_type_node,\n \t\t   build_binary_op (EQ_EXPR, integer_type_node, gnu_comp,\n-\t\t\t\t    convert (TREE_TYPE (gnu_comp),\n-\t\t\t\t\t     build_int_cst (NULL_TREE, 'V'))),\n+\t\t\t\t    build_int_cst (TREE_TYPE (gnu_comp), 'V')),\n \t\t   this_choice);\n \t    }\n \t}\n@@ -2504,9 +2500,10 @@ gnat_to_gnu (Node_Id gnat_node)\n       if (Present (Entity (gnat_node)))\n \tgnu_result = DECL_INITIAL (get_gnu_tree (Entity (gnat_node)));\n       else\n-\tgnu_result = convert (gnu_result_type,\n-\t\t\t      build_int_cst (NULL_TREE,\n-\t\t\t\t\t     Char_Literal_Value (gnat_node)));\n+\tgnu_result\n+\t  = force_fit_type\n+\t    (build_int_cst (gnu_result_type, Char_Literal_Value (gnat_node)),\n+\t     false, false, false);\n       break;\n \n     case N_Real_Literal:\n@@ -2619,11 +2616,10 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    {\n \t      gnu_list\n \t\t= tree_cons (gnu_idx,\n-\t\t\t     convert (TREE_TYPE (gnu_result_type),\n-\t\t\t\t      build_int_cst\n-\t\t\t\t      (NULL_TREE,\n-\t\t\t\t       Get_String_Char (gnat_string, i + 1))),\n-\t\t\t   gnu_list);\n+\t\t\t     build_int_cst (TREE_TYPE (gnu_result_type),\n+\t\t\t\t\t    Get_String_Char (gnat_string,\n+\t\t\t\t\t\t\t     i + 1)),\n+\t\t\t     gnu_list);\n \n \t      gnu_idx = int_const_binop (PLUS_EXPR, gnu_idx, integer_one_node,\n \t\t\t\t\t 0);\n@@ -3657,7 +3653,6 @@ gnat_to_gnu (Node_Id gnat_node)\n       /* This is not called for the main unit, which is handled in function\n \t gigi above.  */\n       start_stmt_group ();\n-      current_stmt_group->global = current_stmt_group;\n       gnat_pushlevel ();\n \n       Compilation_Unit_to_gnu (gnat_node);\n@@ -4114,7 +4109,6 @@ start_stmt_group ()\n \n   group->previous = current_stmt_group;\n   group->stmt_list = group->block = group->cleanups = NULL_TREE;\n-  group->global = current_stmt_group ? current_stmt_group->global : NULL;\n   current_stmt_group = group;\n }\n \n@@ -4126,25 +4120,10 @@ add_stmt (tree gnu_stmt)\n   append_to_statement_list (gnu_stmt, &current_stmt_group->stmt_list);\n \n   /* If we're at top level, show everything in here is in use in case\n-     any of it is shared by a subprogram.\n-\n-     ??? If this is a DECL_EXPR for a VAR_DECL or CONST_DECL, we must\n-     walk the sizes and DECL_INITIAL since we won't be walking the\n-     BIND_EXPR here.  This whole thing is a mess!  */\n+     any of it is shared by a subprogram.  */\n   if (global_bindings_p ())\n-    {\n-      walk_tree (&gnu_stmt, mark_visited, NULL, NULL);\n-      if (TREE_CODE (gnu_stmt) == DECL_EXPR\n-\t  && (TREE_CODE (DECL_EXPR_DECL (gnu_stmt)) == VAR_DECL\n-\t      || TREE_CODE (DECL_EXPR_DECL (gnu_stmt)) == CONST_DECL))\n-\t{\n-\t  tree gnu_decl = DECL_EXPR_DECL (gnu_stmt);\n+    walk_tree (&gnu_stmt, mark_visited, NULL, NULL);\n \n-\t  walk_tree (&DECL_SIZE (gnu_decl), mark_visited, NULL, NULL);\n-\t  walk_tree (&DECL_SIZE_UNIT (gnu_decl), mark_visited, NULL, NULL);\n-\t  walk_tree (&DECL_INITIAL (gnu_decl), mark_visited, NULL, NULL);\n-\t}\n-    }\n }\n \n /* Similar, but set the location of GNU_STMT to that of GNAT_NODE.  */\n@@ -4163,7 +4142,7 @@ add_stmt_with_node (tree gnu_stmt, Node_Id gnat_node)\n void\n add_decl_expr (tree gnu_decl, Entity_Id gnat_entity)\n {\n-  struct stmt_group *save_stmt_group = current_stmt_group;\n+  tree gnu_stmt;\n \n   /* If this is a variable that Gigi is to ignore, we may have been given\n      an ERROR_MARK.  So test for it.  We also might have been given a\n@@ -4174,14 +4153,24 @@ add_decl_expr (tree gnu_decl, Entity_Id gnat_entity)\n \t  && TREE_CODE (TREE_TYPE (gnu_decl)) == UNCONSTRAINED_ARRAY_TYPE))\n     return;\n \n-  if (global_bindings_p ())\n-    current_stmt_group = current_stmt_group->global;\n-\n-  add_stmt_with_node (build (DECL_EXPR, void_type_node, gnu_decl),\n-\t\t      gnat_entity);\n-\n-  if (global_bindings_p ())\n-    current_stmt_group = save_stmt_group;\n+  /* If we are global, we don't want to actually output the DECL_EXPR for\n+     this decl since we already have evaluated the expressions in the\n+     sizes and positions as globals and doing it again would be wrong.\n+     But we do have to mark everything as used.  */\n+  gnu_stmt = build (DECL_EXPR, void_type_node, gnu_decl);\n+  if (!global_bindings_p ())\n+    add_stmt_with_node (gnu_stmt, gnat_entity);\n+  else\n+    {\n+      walk_tree (&gnu_stmt, mark_visited, NULL, NULL);\n+      if (TREE_CODE (gnu_decl) == VAR_DECL\n+\t  || TREE_CODE (gnu_decl) == CONST_DECL)\n+\t{\n+\t  walk_tree (&DECL_SIZE (gnu_decl), mark_visited, NULL, NULL);\n+\t  walk_tree (&DECL_SIZE_UNIT (gnu_decl), mark_visited, NULL, NULL);\n+\t  walk_tree (&DECL_INITIAL (gnu_decl), mark_visited, NULL, NULL);\n+\t}\n+    }\n \n   /* If this is a DECL_EXPR for a variable with DECL_INITIAl set,\n      there are two cases we need to handle here.  */"}, {"sha": "9e8485786902d0d778251448b5c959c19fff85f0", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=6cdb2c6e80a9c6300ae56a260c617d6e72b52f19", "patch": "@@ -381,7 +381,7 @@ gnat_init_decl_processing (void)\n   free_binding_level = 0;\n   gnat_pushlevel ();\n \n-  build_common_tree_nodes (false, true);\n+  build_common_tree_nodes (true, true);\n \n   /* In Ada, we use a signed type for SIZETYPE.  Use the signed type\n      corresponding to the size of Pmode.  In most cases when ptr_mode and\n@@ -411,7 +411,7 @@ gnat_init_decl_processing (void)\n }\n \n /* Define a builtin function.  This is temporary and is just being done\n-   to initialize implicit_built_in_decls for the middle-end.  We'll want\n+   to initialize *_built_in_decls for the middle-end.  We'll want\n    to do full builtin processing soon.  */\n \n static void\n@@ -431,6 +431,7 @@ gnat_define_builtin (const char *name, tree type,\n   TREE_READONLY (decl) = const_p;\n \n   implicit_built_in_decls[function_code] = decl;\n+  built_in_decls[function_code] = decl;\n }\n \n /* Install the builtin functions the middle-end needs.  */\n@@ -513,7 +514,6 @@ gnat_install_builtins ()\n   ftype = build_function_type (ptr_void_type_node, tmp);\n   gnat_define_builtin (\"__builtin_alloca\", ftype, BUILT_IN_ALLOCA,\n \t\t       \"alloca\", false);\n-\n }\n \n /* Create the predefined scalar types such as `integer_type_node' needed\n@@ -1196,7 +1196,7 @@ create_subprog_type (tree return_type, tree param_decl_list, tree cico_list,\n       || TYPE_RETURNS_BY_REF_P (type) != returns_by_ref)\n     type = copy_type (type);\n \n-  SET_TYPE_CI_CO_LIST (type, cico_list);\n+  TYPE_CI_CO_LIST (type) = cico_list;\n   TYPE_RETURNS_UNCONSTRAINED_P (type) = returns_unconstrained;\n   TYPE_RETURNS_STACK_DEPRESSED (type) = returns_with_dsp;\n   TYPE_RETURNS_BY_REF_P (type) = returns_by_ref;"}, {"sha": "016356399c4f49e9be39628fc9887594d5d2b566", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=6cdb2c6e80a9c6300ae56a260c617d6e72b52f19", "patch": "@@ -30,6 +30,7 @@\n #include \"tm.h\"\n #include \"tree.h\"\n #include \"rtl.h\"\n+#include \"ggc.h\"\n #include \"flags.h\"\n #include \"output.h\"\n #include \"ada.h\""}, {"sha": "256aadcd96b2841820d3bcdf263d56e01a84489d", "filename": "gcc/ada/vms_data.ads", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fvms_data.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdb2c6e80a9c6300ae56a260c617d6e72b52f19/gcc%2Fada%2Fvms_data.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_data.ads?ref=6cdb2c6e80a9c6300ae56a260c617d6e72b52f19", "patch": "@@ -2321,6 +2321,15 @@ package VMS_Data is\n    --   debugging purposes or if you need to be sure what version of the\n    --   compiler you are executing.\n \n+   S_GCC_Verb_Asm : aliased constant S := \"/VERBOSE_ASM \" &\n+                                          \"-S,-verbose_asm,!-c\";\n+   --        /NOASM (D)\n+   --        /ASM\n+   --\n+   --   Use to cause the assembler source file to be generated, using S as the\n+   --   filetype, instead of the object file. This may be useful if you need\n+   --   to examine the generated assembly code.\n+\n    S_GCC_Warn    : aliased constant S := \"/WARNINGS=\"                      &\n                                             \"DEFAULT \"                     &\n                                                \"!-gnatws,!-gnatwe \"        &\n@@ -2866,6 +2875,7 @@ package VMS_Data is\n       S_GCC_Upcase  'Access,\n       S_GCC_Valid   'Access,\n       S_GCC_Verbose 'Access,\n+      S_GCC_Verb_Asm'Access,\n       S_GCC_Warn    'Access,\n       S_GCC_WarnX   'Access,\n       S_GCC_Wide    'Access,"}]}