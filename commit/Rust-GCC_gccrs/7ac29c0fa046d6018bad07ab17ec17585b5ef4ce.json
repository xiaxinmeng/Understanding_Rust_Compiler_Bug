{"sha": "7ac29c0fa046d6018bad07ab17ec17585b5ef4ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2FjMjljMGZhMDQ2ZDYwMThiYWQwN2FiMTdlYzE3NTg1YjVlZjRjZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-11-06T20:02:10Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-11-06T20:02:10Z"}, "message": "[AArch64] Add an endian_lane_rtx helper routine\n\nLater patches turn the number of vector units into a poly_int.\nWe deliberately don't support applying GEN_INT to those (except\nin target code that doesn't distinguish between poly_ints and normal\nconstants); gen_int_mode needs to be used instead.\n\nThis patch therefore replaces instances of:\n\n  GEN_INT (ENDIAN_LANE_N (builtin_mode, INTVAL (op[opc])))\n\nwith uses of a new endian_lane_rtx function.\n\n2017-11-06  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* config/aarch64/aarch64-protos.h (aarch64_endian_lane_rtx): Declare.\n\t* config/aarch64/aarch64.c (aarch64_endian_lane_rtx): New function.\n\t* config/aarch64/aarch64.h (ENDIAN_LANE_N): Take the number\n\tof units rather than the mode.\n\t* config/aarch64/iterators.md (nunits): New mode attribute.\n\t* config/aarch64/aarch64-builtins.c (aarch64_simd_expand_args):\n\tUse aarch64_endian_lane_rtx instead of GEN_INT (ENDIAN_LANE_N ...).\n\t* config/aarch64/aarch64-simd.md (aarch64_dup_lane<mode>)\n\t(aarch64_dup_lane_<vswap_width_name><mode>, *aarch64_mul3_elt<mode>)\n\t(*aarch64_mul3_elt_<vswap_width_name><mode>): Likewise.\n\t(*aarch64_mul3_elt_to_64v2df, *aarch64_mla_elt<mode>): Likewise.\n\t(*aarch64_mla_elt_<vswap_width_name><mode>, *aarch64_mls_elt<mode>)\n\t(*aarch64_mls_elt_<vswap_width_name><mode>, *aarch64_fma4_elt<mode>)\n\t(*aarch64_fma4_elt_<vswap_width_name><mode>):: Likewise.\n\t(*aarch64_fma4_elt_to_64v2df, *aarch64_fnma4_elt<mode>): Likewise.\n\t(*aarch64_fnma4_elt_<vswap_width_name><mode>): Likewise.\n\t(*aarch64_fnma4_elt_to_64v2df, reduc_plus_scal_<mode>): Likewise.\n\t(reduc_plus_scal_v4sf, reduc_<maxmin_uns>_scal_<mode>): Likewise.\n\t(reduc_<maxmin_uns>_scal_<mode>): Likewise.\n\t(*aarch64_get_lane_extend<GPI:mode><VDQQH:mode>): Likewise.\n\t(*aarch64_get_lane_zero_extendsi<mode>): Likewise.\n\t(aarch64_get_lane<mode>, *aarch64_mulx_elt_<vswap_width_name><mode>)\n\t(*aarch64_mulx_elt<mode>, *aarch64_vgetfmulx<mode>): Likewise.\n\t(aarch64_sq<r>dmulh_lane<mode>, aarch64_sq<r>dmulh_laneq<mode>)\n\t(aarch64_sqrdml<SQRDMLH_AS:rdma_as>h_lane<mode>): Likewise.\n\t(aarch64_sqrdml<SQRDMLH_AS:rdma_as>h_laneq<mode>): Likewise.\n\t(aarch64_sqdml<SBINQOPS:as>l_lane<mode>): Likewise.\n\t(aarch64_sqdml<SBINQOPS:as>l_laneq<mode>): Likewise.\n\t(aarch64_sqdml<SBINQOPS:as>l2_lane<mode>_internal): Likewise.\n\t(aarch64_sqdml<SBINQOPS:as>l2_laneq<mode>_internal): Likewise.\n\t(aarch64_sqdmull_lane<mode>, aarch64_sqdmull_laneq<mode>): Likewise.\n\t(aarch64_sqdmull2_lane<mode>_internal): Likewise.\n\t(aarch64_sqdmull2_laneq<mode>_internal): Likewise.\n\t(aarch64_vec_load_lanesoi_lane<mode>): Likewise.\n\t(aarch64_vec_store_lanesoi_lane<mode>): Likewise.\n\t(aarch64_vec_load_lanesci_lane<mode>): Likewise.\n\t(aarch64_vec_store_lanesci_lane<mode>): Likewise.\n\t(aarch64_vec_load_lanesxi_lane<mode>): Likewise.\n\t(aarch64_vec_store_lanesxi_lane<mode>): Likewise.\n\t(aarch64_simd_vec_set<mode>): Update use of ENDIAN_LANE_N.\n\t(aarch64_simd_vec_setv2di): Likewise.\n\nReviewed-by: James Greenhalgh <james.greenhalgh@arm.com>\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r254466", "tree": {"sha": "60361d1dfcf632b8f66d3272c2f3f9234e59d95b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60361d1dfcf632b8f66d3272c2f3f9234e59d95b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ac29c0fa046d6018bad07ab17ec17585b5ef4ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ac29c0fa046d6018bad07ab17ec17585b5ef4ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ac29c0fa046d6018bad07ab17ec17585b5ef4ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ac29c0fa046d6018bad07ab17ec17585b5ef4ce/comments", "author": null, "committer": null, "parents": [{"sha": "6e601f26f2b4a43a31c8e8f818baeee27875195d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e601f26f2b4a43a31c8e8f818baeee27875195d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e601f26f2b4a43a31c8e8f818baeee27875195d"}], "stats": {"total": 192, "additions": 126, "deletions": 66}, "files": [{"sha": "04f4d13d2714450e945bbf7fadd8d774e2a035a4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac29c0fa046d6018bad07ab17ec17585b5ef4ce/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac29c0fa046d6018bad07ab17ec17585b5ef4ce/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7ac29c0fa046d6018bad07ab17ec17585b5ef4ce", "patch": "@@ -1,3 +1,49 @@\n+2017-11-06  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* config/aarch64/aarch64-protos.h (aarch64_endian_lane_rtx): Declare.\n+\t* config/aarch64/aarch64.c (aarch64_endian_lane_rtx): New function.\n+\t* config/aarch64/aarch64.h (ENDIAN_LANE_N): Take the number\n+\tof units rather than the mode.\n+\t* config/aarch64/iterators.md (nunits): New mode attribute.\n+\t* config/aarch64/aarch64-builtins.c (aarch64_simd_expand_args):\n+\tUse aarch64_endian_lane_rtx instead of GEN_INT (ENDIAN_LANE_N ...).\n+\t* config/aarch64/aarch64-simd.md (aarch64_dup_lane<mode>)\n+\t(aarch64_dup_lane_<vswap_width_name><mode>, *aarch64_mul3_elt<mode>)\n+\t(*aarch64_mul3_elt_<vswap_width_name><mode>): Likewise.\n+\t(*aarch64_mul3_elt_to_64v2df, *aarch64_mla_elt<mode>): Likewise.\n+\t(*aarch64_mla_elt_<vswap_width_name><mode>, *aarch64_mls_elt<mode>)\n+\t(*aarch64_mls_elt_<vswap_width_name><mode>, *aarch64_fma4_elt<mode>)\n+\t(*aarch64_fma4_elt_<vswap_width_name><mode>):: Likewise.\n+\t(*aarch64_fma4_elt_to_64v2df, *aarch64_fnma4_elt<mode>): Likewise.\n+\t(*aarch64_fnma4_elt_<vswap_width_name><mode>): Likewise.\n+\t(*aarch64_fnma4_elt_to_64v2df, reduc_plus_scal_<mode>): Likewise.\n+\t(reduc_plus_scal_v4sf, reduc_<maxmin_uns>_scal_<mode>): Likewise.\n+\t(reduc_<maxmin_uns>_scal_<mode>): Likewise.\n+\t(*aarch64_get_lane_extend<GPI:mode><VDQQH:mode>): Likewise.\n+\t(*aarch64_get_lane_zero_extendsi<mode>): Likewise.\n+\t(aarch64_get_lane<mode>, *aarch64_mulx_elt_<vswap_width_name><mode>)\n+\t(*aarch64_mulx_elt<mode>, *aarch64_vgetfmulx<mode>): Likewise.\n+\t(aarch64_sq<r>dmulh_lane<mode>, aarch64_sq<r>dmulh_laneq<mode>)\n+\t(aarch64_sqrdml<SQRDMLH_AS:rdma_as>h_lane<mode>): Likewise.\n+\t(aarch64_sqrdml<SQRDMLH_AS:rdma_as>h_laneq<mode>): Likewise.\n+\t(aarch64_sqdml<SBINQOPS:as>l_lane<mode>): Likewise.\n+\t(aarch64_sqdml<SBINQOPS:as>l_laneq<mode>): Likewise.\n+\t(aarch64_sqdml<SBINQOPS:as>l2_lane<mode>_internal): Likewise.\n+\t(aarch64_sqdml<SBINQOPS:as>l2_laneq<mode>_internal): Likewise.\n+\t(aarch64_sqdmull_lane<mode>, aarch64_sqdmull_laneq<mode>): Likewise.\n+\t(aarch64_sqdmull2_lane<mode>_internal): Likewise.\n+\t(aarch64_sqdmull2_laneq<mode>_internal): Likewise.\n+\t(aarch64_vec_load_lanesoi_lane<mode>): Likewise.\n+\t(aarch64_vec_store_lanesoi_lane<mode>): Likewise.\n+\t(aarch64_vec_load_lanesci_lane<mode>): Likewise.\n+\t(aarch64_vec_store_lanesci_lane<mode>): Likewise.\n+\t(aarch64_vec_load_lanesxi_lane<mode>): Likewise.\n+\t(aarch64_vec_store_lanesxi_lane<mode>): Likewise.\n+\t(aarch64_simd_vec_set<mode>): Update use of ENDIAN_LANE_N.\n+\t(aarch64_simd_vec_setv2di): Likewise.\n+\n 2017-11-06  Carl Love  <cel@us.ibm.com>\n \n \t* config/rs6000/rs6000-c.c (P8V_BUILTIN_VEC_REVB): Add power 8"}, {"sha": "ff4ab60e1ff594df993079621f1002b99ca99ed0", "filename": "gcc/config/aarch64/aarch64-builtins.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac29c0fa046d6018bad07ab17ec17585b5ef4ce/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac29c0fa046d6018bad07ab17ec17585b5ef4ce/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c?ref=7ac29c0fa046d6018bad07ab17ec17585b5ef4ce", "patch": "@@ -1067,8 +1067,8 @@ aarch64_simd_expand_args (rtx target, int icode, int have_retval,\n \t\t\t\t\t    GET_MODE_NUNITS (builtin_mode),\n \t\t\t\t\t    exp);\n \t\t  /* Keep to GCC-vector-extension lane indices in the RTL.  */\n-\t\t  op[opc] =\n-\t\t    GEN_INT (ENDIAN_LANE_N (builtin_mode, INTVAL (op[opc])));\n+\t\t  op[opc] = aarch64_endian_lane_rtx (builtin_mode,\n+\t\t\t\t\t\t     INTVAL (op[opc]));\n \t\t}\n \t      goto constant_arg;\n \n@@ -1081,7 +1081,7 @@ aarch64_simd_expand_args (rtx target, int icode, int have_retval,\n \t\t  aarch64_simd_lane_bounds (op[opc],\n \t\t\t\t\t    0, GET_MODE_NUNITS (vmode), exp);\n \t\t  /* Keep to GCC-vector-extension lane indices in the RTL.  */\n-\t\t  op[opc] = GEN_INT (ENDIAN_LANE_N (vmode, INTVAL (op[opc])));\n+\t\t  op[opc] = aarch64_endian_lane_rtx (vmode, INTVAL (op[opc]));\n \t\t}\n \t      /* Fall through - if the lane index isn't a constant then\n \t\t the next case will error.  */"}, {"sha": "4df2ee00f8f76450e0694ff4ec3683c215dc67a0", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac29c0fa046d6018bad07ab17ec17585b5ef4ce/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac29c0fa046d6018bad07ab17ec17585b5ef4ce/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=7ac29c0fa046d6018bad07ab17ec17585b5ef4ce", "patch": "@@ -425,6 +425,7 @@ void aarch64_simd_emit_reg_reg_move (rtx *, machine_mode, unsigned int);\n rtx aarch64_simd_expand_builtin (int, tree, rtx);\n \n void aarch64_simd_lane_bounds (rtx, HOST_WIDE_INT, HOST_WIDE_INT, const_tree);\n+rtx aarch64_endian_lane_rtx (machine_mode, unsigned int);\n \n void aarch64_split_128bit_move (rtx, rtx);\n "}, {"sha": "445503d8449954a84e45682f8b81b6a22f0cfb5d", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 54, "deletions": 61, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac29c0fa046d6018bad07ab17ec17585b5ef4ce/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac29c0fa046d6018bad07ab17ec17585b5ef4ce/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=7ac29c0fa046d6018bad07ab17ec17585b5ef4ce", "patch": "@@ -80,7 +80,7 @@\n           )))]\n   \"TARGET_SIMD\"\n   {\n-    operands[2] = GEN_INT (ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[2])));\n+    operands[2] = aarch64_endian_lane_rtx (<MODE>mode, INTVAL (operands[2]));\n     return \"dup\\\\t%0.<Vtype>, %1.<Vetype>[%2]\";\n   }\n   [(set_attr \"type\" \"neon_dup<q>\")]\n@@ -95,8 +95,7 @@\n           )))]\n   \"TARGET_SIMD\"\n   {\n-    operands[2] = GEN_INT (ENDIAN_LANE_N (<VSWAP_WIDTH>mode,\n-\t\t\t\t\t  INTVAL (operands[2])));\n+    operands[2] = aarch64_endian_lane_rtx (<VSWAP_WIDTH>mode, INTVAL (operands[2]));\n     return \"dup\\\\t%0.<Vtype>, %1.<Vetype>[%2]\";\n   }\n   [(set_attr \"type\" \"neon_dup<q>\")]\n@@ -502,7 +501,7 @@\n       (match_operand:VMUL 3 \"register_operand\" \"w\")))]\n   \"TARGET_SIMD\"\n   {\n-    operands[2] = GEN_INT (ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[2])));\n+    operands[2] = aarch64_endian_lane_rtx (<MODE>mode, INTVAL (operands[2]));\n     return \"<f>mul\\\\t%0.<Vtype>, %3.<Vtype>, %1.<Vetype>[%2]\";\n   }\n   [(set_attr \"type\" \"neon<fp>_mul_<stype>_scalar<q>\")]\n@@ -518,8 +517,7 @@\n       (match_operand:VMUL_CHANGE_NLANES 3 \"register_operand\" \"w\")))]\n   \"TARGET_SIMD\"\n   {\n-    operands[2] = GEN_INT (ENDIAN_LANE_N (<VSWAP_WIDTH>mode,\n-\t\t\t\t\t  INTVAL (operands[2])));\n+    operands[2] = aarch64_endian_lane_rtx (<VSWAP_WIDTH>mode, INTVAL (operands[2]));\n     return \"<f>mul\\\\t%0.<Vtype>, %3.<Vtype>, %1.<Vetype>[%2]\";\n   }\n   [(set_attr \"type\" \"neon<fp>_mul_<Vetype>_scalar<q>\")]\n@@ -572,7 +570,7 @@\n        (match_operand:DF 3 \"register_operand\" \"w\")))]\n   \"TARGET_SIMD\"\n   {\n-    operands[2] = GEN_INT (ENDIAN_LANE_N (V2DFmode, INTVAL (operands[2])));\n+    operands[2] = aarch64_endian_lane_rtx (V2DFmode, INTVAL (operands[2]));\n     return \"fmul\\\\t%0.2d, %3.2d, %1.d[%2]\";\n   }\n   [(set_attr \"type\" \"neon_fp_mul_d_scalar_q\")]\n@@ -707,7 +705,7 @@\n \t    (match_operand:SI 2 \"immediate_operand\" \"i,i,i\")))]\n   \"TARGET_SIMD\"\n   {\n-   int elt = ENDIAN_LANE_N (<MODE>mode, exact_log2 (INTVAL (operands[2])));\n+   int elt = ENDIAN_LANE_N (<nunits>, exact_log2 (INTVAL (operands[2])));\n    operands[2] = GEN_INT ((HOST_WIDE_INT) 1 << elt);\n    switch (which_alternative)\n      {\n@@ -1073,7 +1071,7 @@\n \t    (match_operand:SI 2 \"immediate_operand\" \"i,i\")))]\n   \"TARGET_SIMD\"\n   {\n-    int elt = ENDIAN_LANE_N (V2DImode, exact_log2 (INTVAL (operands[2])));\n+    int elt = ENDIAN_LANE_N (2, exact_log2 (INTVAL (operands[2])));\n     operands[2] = GEN_INT ((HOST_WIDE_INT) 1 << elt);\n     switch (which_alternative)\n       {\n@@ -1110,7 +1108,7 @@\n \t    (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n   \"TARGET_SIMD\"\n   {\n-    int elt = ENDIAN_LANE_N (<MODE>mode, exact_log2 (INTVAL (operands[2])));\n+    int elt = ENDIAN_LANE_N (<nunits>, exact_log2 (INTVAL (operands[2])));\n \n     operands[2] = GEN_INT ((HOST_WIDE_INT)1 << elt);\n     return \"ins\\t%0.<Vetype>[%p2], %1.<Vetype>[0]\";\n@@ -1155,7 +1153,7 @@\n \t (match_operand:VDQHS 4 \"register_operand\" \"0\")))]\n  \"TARGET_SIMD\"\n   {\n-    operands[2] = GEN_INT (ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[2])));\n+    operands[2] = aarch64_endian_lane_rtx (<MODE>mode, INTVAL (operands[2]));\n     return \"mla\\t%0.<Vtype>, %3.<Vtype>, %1.<Vtype>[%2]\";\n   }\n   [(set_attr \"type\" \"neon_mla_<Vetype>_scalar<q>\")]\n@@ -1173,8 +1171,7 @@\n \t (match_operand:VDQHS 4 \"register_operand\" \"0\")))]\n  \"TARGET_SIMD\"\n   {\n-    operands[2] = GEN_INT (ENDIAN_LANE_N (<VSWAP_WIDTH>mode,\n-\t\t\t\t\t  INTVAL (operands[2])));\n+    operands[2] = aarch64_endian_lane_rtx (<VSWAP_WIDTH>mode, INTVAL (operands[2]));\n     return \"mla\\t%0.<Vtype>, %3.<Vtype>, %1.<Vtype>[%2]\";\n   }\n   [(set_attr \"type\" \"neon_mla_<Vetype>_scalar<q>\")]\n@@ -1214,7 +1211,7 @@\n \t   (match_operand:VDQHS 3 \"register_operand\" \"w\"))))]\n  \"TARGET_SIMD\"\n   {\n-    operands[2] = GEN_INT (ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[2])));\n+    operands[2] = aarch64_endian_lane_rtx (<MODE>mode, INTVAL (operands[2]));\n     return \"mls\\t%0.<Vtype>, %3.<Vtype>, %1.<Vtype>[%2]\";\n   }\n   [(set_attr \"type\" \"neon_mla_<Vetype>_scalar<q>\")]\n@@ -1232,8 +1229,7 @@\n \t   (match_operand:VDQHS 3 \"register_operand\" \"w\"))))]\n  \"TARGET_SIMD\"\n   {\n-    operands[2] = GEN_INT (ENDIAN_LANE_N (<VSWAP_WIDTH>mode,\n-\t\t\t\t\t  INTVAL (operands[2])));\n+    operands[2] = aarch64_endian_lane_rtx (<VSWAP_WIDTH>mode, INTVAL (operands[2]));\n     return \"mls\\t%0.<Vtype>, %3.<Vtype>, %1.<Vtype>[%2]\";\n   }\n   [(set_attr \"type\" \"neon_mla_<Vetype>_scalar<q>\")]\n@@ -1803,7 +1799,7 @@\n       (match_operand:VDQF 4 \"register_operand\" \"0\")))]\n   \"TARGET_SIMD\"\n   {\n-    operands[2] = GEN_INT (ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[2])));\n+    operands[2] = aarch64_endian_lane_rtx (<MODE>mode, INTVAL (operands[2]));\n     return \"fmla\\\\t%0.<Vtype>, %3.<Vtype>, %1.<Vtype>[%2]\";\n   }\n   [(set_attr \"type\" \"neon_fp_mla_<Vetype>_scalar<q>\")]\n@@ -1820,8 +1816,7 @@\n       (match_operand:VDQSF 4 \"register_operand\" \"0\")))]\n   \"TARGET_SIMD\"\n   {\n-    operands[2] = GEN_INT (ENDIAN_LANE_N (<VSWAP_WIDTH>mode,\n-\t\t\t\t\t  INTVAL (operands[2])));\n+    operands[2] = aarch64_endian_lane_rtx (<VSWAP_WIDTH>mode, INTVAL (operands[2]));\n     return \"fmla\\\\t%0.<Vtype>, %3.<Vtype>, %1.<Vtype>[%2]\";\n   }\n   [(set_attr \"type\" \"neon_fp_mla_<Vetype>_scalar<q>\")]\n@@ -1849,7 +1844,7 @@\n       (match_operand:DF 4 \"register_operand\" \"0\")))]\n   \"TARGET_SIMD\"\n   {\n-    operands[2] = GEN_INT (ENDIAN_LANE_N (V2DFmode, INTVAL (operands[2])));\n+    operands[2] = aarch64_endian_lane_rtx (V2DFmode, INTVAL (operands[2]));\n     return \"fmla\\\\t%0.2d, %3.2d, %1.2d[%2]\";\n   }\n   [(set_attr \"type\" \"neon_fp_mla_d_scalar_q\")]\n@@ -1879,7 +1874,7 @@\n       (match_operand:VDQF 4 \"register_operand\" \"0\")))]\n   \"TARGET_SIMD\"\n   {\n-    operands[2] = GEN_INT (ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[2])));\n+    operands[2] = aarch64_endian_lane_rtx (<MODE>mode, INTVAL (operands[2]));\n     return \"fmls\\\\t%0.<Vtype>, %3.<Vtype>, %1.<Vtype>[%2]\";\n   }\n   [(set_attr \"type\" \"neon_fp_mla_<Vetype>_scalar<q>\")]\n@@ -1897,8 +1892,7 @@\n       (match_operand:VDQSF 4 \"register_operand\" \"0\")))]\n   \"TARGET_SIMD\"\n   {\n-    operands[2] = GEN_INT (ENDIAN_LANE_N (<VSWAP_WIDTH>mode,\n-\t\t\t\t\t  INTVAL (operands[2])));\n+    operands[2] = aarch64_endian_lane_rtx (<VSWAP_WIDTH>mode, INTVAL (operands[2]));\n     return \"fmls\\\\t%0.<Vtype>, %3.<Vtype>, %1.<Vtype>[%2]\";\n   }\n   [(set_attr \"type\" \"neon_fp_mla_<Vetype>_scalar<q>\")]\n@@ -1928,7 +1922,7 @@\n       (match_operand:DF 4 \"register_operand\" \"0\")))]\n   \"TARGET_SIMD\"\n   {\n-    operands[2] = GEN_INT (ENDIAN_LANE_N (V2DFmode, INTVAL (operands[2])));\n+    operands[2] = aarch64_endian_lane_rtx (V2DFmode, INTVAL (operands[2]));\n     return \"fmls\\\\t%0.2d, %3.2d, %1.2d[%2]\";\n   }\n   [(set_attr \"type\" \"neon_fp_mla_d_scalar_q\")]\n@@ -2261,7 +2255,7 @@\n \t       UNSPEC_ADDV)]\n   \"TARGET_SIMD\"\n   {\n-    rtx elt = GEN_INT (ENDIAN_LANE_N (<MODE>mode, 0));\n+    rtx elt = aarch64_endian_lane_rtx (<MODE>mode, 0);\n     rtx scratch = gen_reg_rtx (<MODE>mode);\n     emit_insn (gen_aarch64_reduc_plus_internal<mode> (scratch, operands[1]));\n     emit_insn (gen_aarch64_get_lane<mode> (operands[0], scratch, elt));\n@@ -2312,7 +2306,7 @@\n \t\t    UNSPEC_FADDV))]\n  \"TARGET_SIMD\"\n {\n-  rtx elt = GEN_INT (ENDIAN_LANE_N (V4SFmode, 0));\n+  rtx elt = aarch64_endian_lane_rtx (V4SFmode, 0);\n   rtx scratch = gen_reg_rtx (V4SFmode);\n   emit_insn (gen_aarch64_faddpv4sf (scratch, operands[1], operands[1]));\n   emit_insn (gen_aarch64_faddpv4sf (scratch, scratch, scratch));\n@@ -2354,7 +2348,7 @@\n \t\t  FMAXMINV)]\n   \"TARGET_SIMD\"\n   {\n-    rtx elt = GEN_INT (ENDIAN_LANE_N (<MODE>mode, 0));\n+    rtx elt = aarch64_endian_lane_rtx (<MODE>mode, 0);\n     rtx scratch = gen_reg_rtx (<MODE>mode);\n     emit_insn (gen_aarch64_reduc_<maxmin_uns>_internal<mode> (scratch,\n \t\t\t\t\t\t\t      operands[1]));\n@@ -2370,7 +2364,7 @@\n \t\t    MAXMINV)]\n   \"TARGET_SIMD\"\n   {\n-    rtx elt = GEN_INT (ENDIAN_LANE_N (<MODE>mode, 0));\n+    rtx elt = aarch64_endian_lane_rtx (<MODE>mode, 0);\n     rtx scratch = gen_reg_rtx (<MODE>mode);\n     emit_insn (gen_aarch64_reduc_<maxmin_uns>_internal<mode> (scratch,\n \t\t\t\t\t\t\t      operands[1]));\n@@ -2895,7 +2889,7 @@\n \t    (parallel [(match_operand:SI 2 \"immediate_operand\" \"i\")]))))]\n   \"TARGET_SIMD\"\n   {\n-    operands[2] = GEN_INT (ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[2])));\n+    operands[2] = aarch64_endian_lane_rtx (<MODE>mode, INTVAL (operands[2]));\n     return \"smov\\\\t%<GPI:w>0, %1.<VDQQH:Vetype>[%2]\";\n   }\n   [(set_attr \"type\" \"neon_to_gp<q>\")]\n@@ -2909,7 +2903,7 @@\n \t    (parallel [(match_operand:SI 2 \"immediate_operand\" \"i\")]))))]\n   \"TARGET_SIMD\"\n   {\n-    operands[2] = GEN_INT (ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[2])));\n+    operands[2] = aarch64_endian_lane_rtx (<MODE>mode, INTVAL (operands[2]));\n     return \"umov\\\\t%w0, %1.<Vetype>[%2]\";\n   }\n   [(set_attr \"type\" \"neon_to_gp<q>\")]\n@@ -2925,7 +2919,7 @@\n \t  (parallel [(match_operand:SI 2 \"immediate_operand\" \"i, i, i\")])))]\n   \"TARGET_SIMD\"\n   {\n-    operands[2] = GEN_INT (ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[2])));\n+    operands[2] = aarch64_endian_lane_rtx (<MODE>mode, INTVAL (operands[2]));\n     switch (which_alternative)\n       {\n \tcase 0:\n@@ -3301,8 +3295,7 @@\n \t UNSPEC_FMULX))]\n   \"TARGET_SIMD\"\n   {\n-    operands[3] = GEN_INT (ENDIAN_LANE_N (<VSWAP_WIDTH>mode,\n-\t\t\t\t\t  INTVAL (operands[3])));\n+    operands[3] = aarch64_endian_lane_rtx (<VSWAP_WIDTH>mode, INTVAL (operands[3]));\n     return \"fmulx\\t%<v>0<Vmtype>, %<v>1<Vmtype>, %2.<Vetype>[%3]\";\n   }\n   [(set_attr \"type\" \"neon_fp_mul_<Vetype>_scalar<q>\")]\n@@ -3321,7 +3314,7 @@\n \t UNSPEC_FMULX))]\n   \"TARGET_SIMD\"\n   {\n-    operands[3] = GEN_INT (ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[3])));\n+    operands[3] = aarch64_endian_lane_rtx (<MODE>mode, INTVAL (operands[3]));\n     return \"fmulx\\t%<v>0<Vmtype>, %<v>1<Vmtype>, %2.<Vetype>[%3]\";\n   }\n   [(set_attr \"type\" \"neon_fp_mul_<Vetype><q>\")]\n@@ -3355,7 +3348,7 @@\n \t UNSPEC_FMULX))]\n   \"TARGET_SIMD\"\n   {\n-    operands[3] = GEN_INT (ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[3])));\n+    operands[3] = aarch64_endian_lane_rtx (<MODE>mode, INTVAL (operands[3]));\n     return \"fmulx\\t%<Vetype>0, %<Vetype>1, %2.<Vetype>[%3]\";\n   }\n   [(set_attr \"type\" \"fmul<Vetype>\")]\n@@ -3441,7 +3434,7 @@\n \t VQDMULH))]\n   \"TARGET_SIMD\"\n   \"*\n-   operands[3] = GEN_INT (ENDIAN_LANE_N (<VCOND>mode, INTVAL (operands[3])));\n+   operands[3] = aarch64_endian_lane_rtx (<VCOND>mode, INTVAL (operands[3]));\n    return \\\"sq<r>dmulh\\\\t%0.<Vtype>, %1.<Vtype>, %2.<Vetype>[%3]\\\";\"\n   [(set_attr \"type\" \"neon_sat_mul_<Vetype>_scalar<q>\")]\n )\n@@ -3456,7 +3449,7 @@\n \t VQDMULH))]\n   \"TARGET_SIMD\"\n   \"*\n-   operands[3] = GEN_INT (ENDIAN_LANE_N (<VCONQ>mode, INTVAL (operands[3])));\n+   operands[3] = aarch64_endian_lane_rtx (<VCONQ>mode, INTVAL (operands[3]));\n    return \\\"sq<r>dmulh\\\\t%0.<Vtype>, %1.<Vtype>, %2.<Vetype>[%3]\\\";\"\n   [(set_attr \"type\" \"neon_sat_mul_<Vetype>_scalar<q>\")]\n )\n@@ -3471,7 +3464,7 @@\n \t VQDMULH))]\n   \"TARGET_SIMD\"\n   \"*\n-   operands[3] = GEN_INT (ENDIAN_LANE_N (<VCOND>mode, INTVAL (operands[3])));\n+   operands[3] = aarch64_endian_lane_rtx (<VCOND>mode, INTVAL (operands[3]));\n    return \\\"sq<r>dmulh\\\\t%<v>0, %<v>1, %2.<v>[%3]\\\";\"\n   [(set_attr \"type\" \"neon_sat_mul_<Vetype>_scalar<q>\")]\n )\n@@ -3486,7 +3479,7 @@\n \t VQDMULH))]\n   \"TARGET_SIMD\"\n   \"*\n-   operands[3] = GEN_INT (ENDIAN_LANE_N (<VCONQ>mode, INTVAL (operands[3])));\n+   operands[3] = aarch64_endian_lane_rtx (<VCONQ>mode, INTVAL (operands[3]));\n    return \\\"sq<r>dmulh\\\\t%<v>0, %<v>1, %2.<v>[%3]\\\";\"\n   [(set_attr \"type\" \"neon_sat_mul_<Vetype>_scalar<q>\")]\n )\n@@ -3518,7 +3511,7 @@\n \t  SQRDMLH_AS))]\n    \"TARGET_SIMD_RDMA\"\n    {\n-     operands[4] = GEN_INT (ENDIAN_LANE_N (<VCOND>mode, INTVAL (operands[4])));\n+     operands[4] = aarch64_endian_lane_rtx (<VCOND>mode, INTVAL (operands[4]));\n      return\n       \"sqrdml<SQRDMLH_AS:rdma_as>h\\\\t%0.<Vtype>, %2.<Vtype>, %3.<Vetype>[%4]\";\n    }\n@@ -3536,7 +3529,7 @@\n \t  SQRDMLH_AS))]\n    \"TARGET_SIMD_RDMA\"\n    {\n-     operands[4] = GEN_INT (ENDIAN_LANE_N (<VCOND>mode, INTVAL (operands[4])));\n+     operands[4] = aarch64_endian_lane_rtx (<VCOND>mode, INTVAL (operands[4]));\n      return\n       \"sqrdml<SQRDMLH_AS:rdma_as>h\\\\t%<v>0, %<v>2, %3.<Vetype>[%4]\";\n    }\n@@ -3556,7 +3549,7 @@\n \t  SQRDMLH_AS))]\n    \"TARGET_SIMD_RDMA\"\n    {\n-     operands[4] = GEN_INT (ENDIAN_LANE_N (<VCONQ>mode, INTVAL (operands[4])));\n+     operands[4] = aarch64_endian_lane_rtx (<VCONQ>mode, INTVAL (operands[4]));\n      return\n       \"sqrdml<SQRDMLH_AS:rdma_as>h\\\\t%0.<Vtype>, %2.<Vtype>, %3.<Vetype>[%4]\";\n    }\n@@ -3574,7 +3567,7 @@\n \t  SQRDMLH_AS))]\n    \"TARGET_SIMD_RDMA\"\n    {\n-     operands[4] = GEN_INT (ENDIAN_LANE_N (<VCONQ>mode, INTVAL (operands[4])));\n+     operands[4] = aarch64_endian_lane_rtx (<VCONQ>mode, INTVAL (operands[4]));\n      return\n       \"sqrdml<SQRDMLH_AS:rdma_as>h\\\\t%<v>0, %<v>2, %3.<v>[%4]\";\n    }\n@@ -3618,7 +3611,7 @@\n \t    (const_int 1))))]\n   \"TARGET_SIMD\"\n   {\n-    operands[4] = GEN_INT (ENDIAN_LANE_N (<VCOND>mode, INTVAL (operands[4])));\n+    operands[4] = aarch64_endian_lane_rtx (<VCOND>mode, INTVAL (operands[4]));\n     return\n       \"sqdml<SBINQOPS:as>l\\\\t%<vw2>0<Vmwtype>, %<v>2<Vmtype>, %3.<Vetype>[%4]\";\n   }\n@@ -3642,7 +3635,7 @@\n \t    (const_int 1))))]\n   \"TARGET_SIMD\"\n   {\n-    operands[4] = GEN_INT (ENDIAN_LANE_N (<VCONQ>mode, INTVAL (operands[4])));\n+    operands[4] = aarch64_endian_lane_rtx (<VCONQ>mode, INTVAL (operands[4]));\n     return\n       \"sqdml<SBINQOPS:as>l\\\\t%<vw2>0<Vmwtype>, %<v>2<Vmtype>, %3.<Vetype>[%4]\";\n   }\n@@ -3665,7 +3658,7 @@\n \t    (const_int 1))))]\n   \"TARGET_SIMD\"\n   {\n-    operands[4] = GEN_INT (ENDIAN_LANE_N (<VCOND>mode, INTVAL (operands[4])));\n+    operands[4] = aarch64_endian_lane_rtx (<VCOND>mode, INTVAL (operands[4]));\n     return\n       \"sqdml<SBINQOPS:as>l\\\\t%<vw2>0<Vmwtype>, %<v>2<Vmtype>, %3.<Vetype>[%4]\";\n   }\n@@ -3688,7 +3681,7 @@\n \t    (const_int 1))))]\n   \"TARGET_SIMD\"\n   {\n-    operands[4] = GEN_INT (ENDIAN_LANE_N (<VCONQ>mode, INTVAL (operands[4])));\n+    operands[4] = aarch64_endian_lane_rtx (<VCONQ>mode, INTVAL (operands[4]));\n     return\n       \"sqdml<SBINQOPS:as>l\\\\t%<vw2>0<Vmwtype>, %<v>2<Vmtype>, %3.<Vetype>[%4]\";\n   }\n@@ -3783,7 +3776,7 @@\n \t      (const_int 1))))]\n   \"TARGET_SIMD\"\n   {\n-    operands[4] = GEN_INT (ENDIAN_LANE_N (<VCOND>mode, INTVAL (operands[4])));\n+    operands[4] = aarch64_endian_lane_rtx (<VCOND>mode, INTVAL (operands[4]));\n     return\n      \"sqdml<SBINQOPS:as>l2\\\\t%<vw2>0<Vmwtype>, %<v>2<Vmtype>, %3.<Vetype>[%4]\";\n   }\n@@ -3809,7 +3802,7 @@\n \t      (const_int 1))))]\n   \"TARGET_SIMD\"\n   {\n-    operands[4] = GEN_INT (ENDIAN_LANE_N (<VCONQ>mode, INTVAL (operands[4])));\n+    operands[4] = aarch64_endian_lane_rtx (<VCONQ>mode, INTVAL (operands[4]));\n     return\n      \"sqdml<SBINQOPS:as>l2\\\\t%<vw2>0<Vmwtype>, %<v>2<Vmtype>, %3.<Vetype>[%4]\";\n   }\n@@ -3956,7 +3949,7 @@\n \t     (const_int 1)))]\n   \"TARGET_SIMD\"\n   {\n-    operands[3] = GEN_INT (ENDIAN_LANE_N (<VCOND>mode, INTVAL (operands[3])));\n+    operands[3] = aarch64_endian_lane_rtx (<VCOND>mode, INTVAL (operands[3]));\n     return \"sqdmull\\\\t%<vw2>0<Vmwtype>, %<v>1<Vmtype>, %2.<Vetype>[%3]\";\n   }\n   [(set_attr \"type\" \"neon_sat_mul_<Vetype>_scalar_long\")]\n@@ -3977,7 +3970,7 @@\n \t     (const_int 1)))]\n   \"TARGET_SIMD\"\n   {\n-    operands[3] = GEN_INT (ENDIAN_LANE_N (<VCONQ>mode, INTVAL (operands[3])));\n+    operands[3] = aarch64_endian_lane_rtx (<VCONQ>mode, INTVAL (operands[3]));\n     return \"sqdmull\\\\t%<vw2>0<Vmwtype>, %<v>1<Vmtype>, %2.<Vetype>[%3]\";\n   }\n   [(set_attr \"type\" \"neon_sat_mul_<Vetype>_scalar_long\")]\n@@ -3997,7 +3990,7 @@\n \t     (const_int 1)))]\n   \"TARGET_SIMD\"\n   {\n-    operands[3] = GEN_INT (ENDIAN_LANE_N (<VCOND>mode, INTVAL (operands[3])));\n+    operands[3] = aarch64_endian_lane_rtx (<VCOND>mode, INTVAL (operands[3]));\n     return \"sqdmull\\\\t%<vw2>0<Vmwtype>, %<v>1<Vmtype>, %2.<Vetype>[%3]\";\n   }\n   [(set_attr \"type\" \"neon_sat_mul_<Vetype>_scalar_long\")]\n@@ -4017,7 +4010,7 @@\n \t     (const_int 1)))]\n   \"TARGET_SIMD\"\n   {\n-    operands[3] = GEN_INT (ENDIAN_LANE_N (<VCONQ>mode, INTVAL (operands[3])));\n+    operands[3] = aarch64_endian_lane_rtx (<VCONQ>mode, INTVAL (operands[3]));\n     return \"sqdmull\\\\t%<vw2>0<Vmwtype>, %<v>1<Vmtype>, %2.<Vetype>[%3]\";\n   }\n   [(set_attr \"type\" \"neon_sat_mul_<Vetype>_scalar_long\")]\n@@ -4095,7 +4088,7 @@\n \t     (const_int 1)))]\n   \"TARGET_SIMD\"\n   {\n-    operands[3] = GEN_INT (ENDIAN_LANE_N (<VCOND>mode, INTVAL (operands[3])));\n+    operands[3] = aarch64_endian_lane_rtx (<VCOND>mode, INTVAL (operands[3]));\n     return \"sqdmull2\\\\t%<vw2>0<Vmwtype>, %<v>1<Vmtype>, %2.<Vetype>[%3]\";\n   }\n   [(set_attr \"type\" \"neon_sat_mul_<Vetype>_scalar_long\")]\n@@ -4118,7 +4111,7 @@\n \t     (const_int 1)))]\n   \"TARGET_SIMD\"\n   {\n-    operands[3] = GEN_INT (ENDIAN_LANE_N (<VCONQ>mode, INTVAL (operands[3])));\n+    operands[3] = aarch64_endian_lane_rtx (<VCONQ>mode, INTVAL (operands[3]));\n     return \"sqdmull2\\\\t%<vw2>0<Vmwtype>, %<v>1<Vmtype>, %2.<Vetype>[%3]\";\n   }\n   [(set_attr \"type\" \"neon_sat_mul_<Vetype>_scalar_long\")]\n@@ -4624,7 +4617,7 @@\n \t\t   UNSPEC_LD2_LANE))]\n   \"TARGET_SIMD\"\n   {\n-    operands[3] = GEN_INT (ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[3])));\n+    operands[3] = aarch64_endian_lane_rtx (<MODE>mode, INTVAL (operands[3]));\n     return \"ld2\\\\t{%S0.<Vetype> - %T0.<Vetype>}[%3], %1\";\n   }\n   [(set_attr \"type\" \"neon_load2_one_lane\")]\n@@ -4668,7 +4661,7 @@\n \t\t   UNSPEC_ST2_LANE))]\n   \"TARGET_SIMD\"\n   {\n-    operands[2] = GEN_INT (ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[2])));\n+    operands[2] = aarch64_endian_lane_rtx (<MODE>mode, INTVAL (operands[2]));\n     return \"st2\\\\t{%S1.<Vetype> - %T1.<Vetype>}[%2], %0\";\n   }\n   [(set_attr \"type\" \"neon_store2_one_lane<q>\")]\n@@ -4722,7 +4715,7 @@\n \t\t   UNSPEC_LD3_LANE))]\n   \"TARGET_SIMD\"\n {\n-    operands[3] = GEN_INT (ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[3])));\n+    operands[3] = aarch64_endian_lane_rtx (<MODE>mode, INTVAL (operands[3]));\n     return \"ld3\\\\t{%S0.<Vetype> - %U0.<Vetype>}[%3], %1\";\n }\n   [(set_attr \"type\" \"neon_load3_one_lane\")]\n@@ -4766,7 +4759,7 @@\n \t\t    UNSPEC_ST3_LANE))]\n   \"TARGET_SIMD\"\n   {\n-    operands[2] = GEN_INT (ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[2])));\n+    operands[2] = aarch64_endian_lane_rtx (<MODE>mode, INTVAL (operands[2]));\n     return \"st3\\\\t{%S1.<Vetype> - %U1.<Vetype>}[%2], %0\";\n   }\n   [(set_attr \"type\" \"neon_store3_one_lane<q>\")]\n@@ -4820,7 +4813,7 @@\n \t\t   UNSPEC_LD4_LANE))]\n   \"TARGET_SIMD\"\n {\n-    operands[3] = GEN_INT (ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[3])));\n+    operands[3] = aarch64_endian_lane_rtx (<MODE>mode, INTVAL (operands[3]));\n     return \"ld4\\\\t{%S0.<Vetype> - %V0.<Vetype>}[%3], %1\";\n }\n   [(set_attr \"type\" \"neon_load4_one_lane\")]\n@@ -4864,7 +4857,7 @@\n \t\t    UNSPEC_ST4_LANE))]\n   \"TARGET_SIMD\"\n   {\n-    operands[2] = GEN_INT (ENDIAN_LANE_N (<MODE>mode, INTVAL (operands[2])));\n+    operands[2] = aarch64_endian_lane_rtx (<MODE>mode, INTVAL (operands[2]));\n     return \"st4\\\\t{%S1.<Vetype> - %V1.<Vetype>}[%2], %0\";\n   }\n   [(set_attr \"type\" \"neon_store4_one_lane<q>\")]"}, {"sha": "ffcca32cd3c5f05222fff15528b50d1d2d0f544d", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac29c0fa046d6018bad07ab17ec17585b5ef4ce/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac29c0fa046d6018bad07ab17ec17585b5ef4ce/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=7ac29c0fa046d6018bad07ab17ec17585b5ef4ce", "patch": "@@ -11833,6 +11833,15 @@ aarch64_simd_lane_bounds (rtx operand, HOST_WIDE_INT low, HOST_WIDE_INT high,\n   }\n }\n \n+/* Peform endian correction on lane number N, which indexes a vector\n+   of mode MODE, and return the result as an SImode rtx.  */\n+\n+rtx\n+aarch64_endian_lane_rtx (machine_mode mode, unsigned int n)\n+{\n+  return gen_int_mode (ENDIAN_LANE_N (GET_MODE_NUNITS (mode), n), SImode);\n+}\n+\n /* Return TRUE if OP is a valid vector addressing mode.  */\n bool\n aarch64_simd_mem_operand_p (rtx op)"}, {"sha": "93d29b84d47b7017661a2129d61e7d740bbf7c93", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac29c0fa046d6018bad07ab17ec17585b5ef4ce/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac29c0fa046d6018bad07ab17ec17585b5ef4ce/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=7ac29c0fa046d6018bad07ab17ec17585b5ef4ce", "patch": "@@ -913,8 +913,8 @@ extern enum aarch64_code_model aarch64_cmodel;\n    || (MODE) == V4SFmode || (MODE) == V8HFmode || (MODE) == V2DImode \\\n    || (MODE) == V2DFmode)\n \n-#define ENDIAN_LANE_N(mode, n)  \\\n-  (BYTES_BIG_ENDIAN ? GET_MODE_NUNITS (mode) - 1 - n : n)\n+#define ENDIAN_LANE_N(NUNITS, N) \\\n+  (BYTES_BIG_ENDIAN ? NUNITS - 1 - N : N)\n \n /* Support for a configure-time default CPU, etc.  We currently support\n    --with-arch and --with-cpu.  Both are ignored if either is specified"}, {"sha": "5d7b0f3540f01ba2e29fbae2eb419db6e26c76c2", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac29c0fa046d6018bad07ab17ec17585b5ef4ce/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac29c0fa046d6018bad07ab17ec17585b5ef4ce/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=7ac29c0fa046d6018bad07ab17ec17585b5ef4ce", "patch": "@@ -450,6 +450,17 @@\n (define_mode_attr rtn [(DI \"d\") (SI \"\")])\n (define_mode_attr vas [(DI \"\") (SI \".2s\")])\n \n+;; Map a vector to the number of units in it, if the size of the mode\n+;; is constant.\n+(define_mode_attr nunits [(V8QI \"8\") (V16QI \"16\")\n+\t\t\t  (V4HI \"4\") (V8HI \"8\")\n+\t\t\t  (V2SI \"2\") (V4SI \"4\")\n+\t\t\t\t     (V2DI \"2\")\n+\t\t\t  (V4HF \"4\") (V8HF \"8\")\n+\t\t\t  (V2SF \"2\") (V4SF \"4\")\n+\t\t\t  (V1DF \"1\") (V2DF \"2\")\n+\t\t\t  (DI \"1\") (DF \"1\")])\n+\n ;; Map a floating point or integer mode to the appropriate register name prefix\n (define_mode_attr s [(HF \"h\") (SF \"s\") (DF \"d\") (SI \"s\") (DI \"d\")])\n "}]}