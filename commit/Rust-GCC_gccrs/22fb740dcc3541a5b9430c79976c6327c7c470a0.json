{"sha": "22fb740dcc3541a5b9430c79976c6327c7c470a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJmYjc0MGRjYzM1NDFhNWI5NDMwYzc5OTc2YzYzMjdjN2M0NzBhMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-07-15T16:59:06Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-07-15T16:59:06Z"}, "message": "toplev.c (rest_of_compilation): Fix register_life_up_to_date handling...\n\n\t* toplev.c (rest_of_compilation): Fix register_life_up_to_date\n\thandling; move unconditional splitting before mode switching.\n\n\t* i386.md (type): Add fistp type.\n\t(i387, length_attr, scheduling definitions): Handle this type.\n\t(fix_trunc?f?i2): Revamp to use mode switching.\n\t(fix_trunct?f?i_nonmemory, fix_trunc?f?i_memory): New patterns.\n\t* i386.h (fp_cw_mode): New enum\n\t(OPTIMIZE_MODE_SWITCHING, NUM_MODES_FOR_MODE_SWITCHING, MODE_NEEDED,\n\tMODE_PRIORITY_TO_MODE, ENUM_MODE_SET): New macros.\n\nFrom-SVN: r44027", "tree": {"sha": "dd53511e79ae0e7f9c00238719bce809718f79c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd53511e79ae0e7f9c00238719bce809718f79c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22fb740dcc3541a5b9430c79976c6327c7c470a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22fb740dcc3541a5b9430c79976c6327c7c470a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22fb740dcc3541a5b9430c79976c6327c7c470a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22fb740dcc3541a5b9430c79976c6327c7c470a0/comments", "author": null, "committer": null, "parents": [{"sha": "135d50f10fe27b77c879038d7adff5724ece1988", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/135d50f10fe27b77c879038d7adff5724ece1988", "html_url": "https://github.com/Rust-GCC/gccrs/commit/135d50f10fe27b77c879038d7adff5724ece1988"}], "stats": {"total": 456, "additions": 297, "deletions": 159}, "files": [{"sha": "b39e15e67be1bc0ab739bd15fcb7e15cd58a9e4c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fb740dcc3541a5b9430c79976c6327c7c470a0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fb740dcc3541a5b9430c79976c6327c7c470a0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=22fb740dcc3541a5b9430c79976c6327c7c470a0", "patch": "@@ -1,3 +1,16 @@\n+Sun Jul 15 14:07:36 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* toplev.c (rest_of_compilation): Fix register_life_up_to_date\n+\thandling; move unconditional splitting before mode switching.\n+\n+\t* i386.md (type): Add fistp type.\n+\t(i387, length_attr, scheduling definitions): Handle this type.\n+\t(fix_trunc?f?i2): Revamp to use mode switching.\n+\t(fix_trunct?f?i_nonmemory, fix_trunc?f?i_memory): New patterns.\n+\t* i386.h (fp_cw_mode): New enum\n+\t(OPTIMIZE_MODE_SWITCHING, NUM_MODES_FOR_MODE_SWITCHING, MODE_NEEDED,\n+\tMODE_PRIORITY_TO_MODE, ENUM_MODE_SET): New macros.\n+\n Sun Jul 15 12:53:51 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* Makefile.in (integrate.o): Add debug.h."}, {"sha": "408ea2bac120dddb4782a392b13406b703c91b60", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fb740dcc3541a5b9430c79976c6327c7c470a0/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fb740dcc3541a5b9430c79976c6327c7c470a0/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=22fb740dcc3541a5b9430c79976c6327c7c470a0", "patch": "@@ -3117,6 +3117,69 @@ extern const char * const qi_high_reg_name[];\t/* names for 8 bit regs (high) */\n extern enum reg_class const regclass_map[];\t/* smalled class containing REGNO */\n extern struct rtx_def *ix86_compare_op0;\t/* operand 0 for comparisons */\n extern struct rtx_def *ix86_compare_op1;\t/* operand 1 for comparisons */\n+\f\n+/* To properly truncate FP values into integers, we need to set i387 control\n+   word.  We can't emit proper mode switching code before reload, as spills\n+   generated by reload may truncate values incorrectly, but we still can avoid\n+   redundant computation of new control word by the mode switching pass.\n+   The fldcw instructions are still emitted redundantly, but this is probably\n+   not going to be noticeable problem, as most CPUs do have fast path for\n+   the sequence.  \n+\n+   The machinery is to emit simple truncation instructions and split them\n+   before reload to instructions having USEs of two memory locations that\n+   are filled by this code to old and new control word.\n+ \n+   Post-reload pass may be later used to eliminate the redundant fildcw if\n+   needed.  */\n+\n+enum fp_cw_mode {FP_CW_STORED, FP_CW_UNINITIALIZED, FP_CW_ANY};\n+\n+/* Define this macro if the port needs extra instructions inserted\n+   for mode switching in an optimizing compilation.  */\n+\n+#define OPTIMIZE_MODE_SWITCHING(ENTITY) 1\n+\n+/* If you define `OPTIMIZE_MODE_SWITCHING', you have to define this as\n+   initializer for an array of integers.  Each initializer element N\n+   refers to an entity that needs mode switching, and specifies the\n+   number of different modes that might need to be set for this\n+   entity.  The position of the initializer in the initializer -\n+   starting counting at zero - determines the integer that is used to\n+   refer to the mode-switched entity in question.  */\n+\n+#define NUM_MODES_FOR_MODE_SWITCHING { FP_CW_ANY }\n+\n+/* ENTITY is an integer specifying a mode-switched entity.  If\n+   `OPTIMIZE_MODE_SWITCHING' is defined, you must define this macro to\n+   return an integer value not larger than the corresponding element\n+   in `NUM_MODES_FOR_MODE_SWITCHING', to denote the mode that ENTITY\n+   must be switched into prior to the execution of INSN.  */\n+\n+#define MODE_NEEDED(ENTITY, I)\t\t\t\t\t\t\\\n+  (GET_CODE (I) == CALL_INSN\t\t\t\t\t\t\\\n+   || (GET_CODE (I) == INSN && (asm_noperands (PATTERN (I)) >= 0 \t\\\n+\t\t\t\t|| GET_CODE (PATTERN (I)) == ASM_INPUT))\\\n+   ? FP_CW_UNINITIALIZED\t\t\t\t\t\t\\\n+   : recog_memoized (I) < 0 || get_attr_type (I) != TYPE_FISTP\t\t\\\n+   ? FP_CW_ANY\t\t\t\t\t\t\t\t\\\n+   : FP_CW_STORED)\n+\n+/* This macro specifies the order in which modes for ENTITY are\n+   processed.  0 is the highest priority.  */\n+\n+#define MODE_PRIORITY_TO_MODE(ENTITY, N) N\n+\n+/* Generate one or more insns to set ENTITY to MODE.  HARD_REG_LIVE\n+   is the set of hard registers live at the point where the insn(s)\n+   are to be inserted.  */\n+\n+#define EMIT_MODE_SET(ENTITY, MODE, HARD_REGS_LIVE) \t\t\t\\\n+  (MODE == FP_CW_STORED\t\t\t\t\t\t\t\\\n+   ? emit_i387_cw_initialization (assign_386_stack_local (HImode, 1),\t\\\n+\t\t\t\t  assign_386_stack_local (HImode, 2)), 0\\\n+   : 0)\n+\n \f\n /*\n Local variables:"}, {"sha": "56158b9b22eab3b84b6de0b5067d1c469f2d185a", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 214, "deletions": 152, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fb740dcc3541a5b9430c79976c6327c7c470a0/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fb740dcc3541a5b9430c79976c6327c7c470a0/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=22fb740dcc3541a5b9430c79976c6327c7c470a0", "patch": "@@ -105,7 +105,7 @@\n ;; A basic instruction type.  Refinements due to arguments to be\n ;; provided in other attributes.\n (define_attr \"type\"\n-  \"other,multi,alu1,negnot,alu,icmp,test,imov,imovx,lea,incdec,ishift,imul,idiv,ibr,setcc,push,pop,call,callv,icmov,fmov,fop,fop1,fsgn,fmul,fdiv,fpspc,fcmov,fcmp,fxch,str,cld,sse,mmx\"\n+  \"other,multi,alu1,negnot,alu,icmp,test,imov,imovx,lea,incdec,ishift,imul,idiv,ibr,setcc,push,pop,call,callv,icmov,fmov,fop,fop1,fsgn,fmul,fdiv,fpspc,fcmov,fcmp,fxch,str,cld,sse,mmx,fistp\"\n   (const_string \"other\"))\n \n ;; Main data type used by the insn\n@@ -114,7 +114,7 @@\n \n ;; Set for i387 operations.\n (define_attr \"i387\" \"\"\n-  (if_then_else (eq_attr \"type\" \"fmov,fop,fop1,fsgn,fmul,fdiv,fpspc,fcmov,fcmp,fxch\")\n+  (if_then_else (eq_attr \"type\" \"fmov,fop,fop1,fsgn,fmul,fdiv,fpspc,fcmov,fcmp,fxch,fistp\")\n     (const_int 1)\n     (const_int 0)))\n \n@@ -198,8 +198,10 @@\n \t (const_int 1)))\n \n ;; The (bounding maximum) length of an instruction in bytes.\n+;; ??? fistp is in fact fldcw/fistp/fldcw sequence.  Later we may want\n+;; to split it and compute proper length as for other insns.\n (define_attr \"length\" \"\"\n-  (cond [(eq_attr \"type\" \"other,multi\")\n+  (cond [(eq_attr \"type\" \"other,multi,fistp\")\n \t   (const_int 16)\n \t ]\n \t (plus (plus (attr \"modrm\")\n@@ -220,6 +222,8 @@\n \t   (const_string \"unknown\")\n \t (eq_attr \"type\" \"lea,fcmov,fpspc,cld\")\n \t   (const_string \"none\")\n+\t (eq_attr \"type\" \"fistp\")\n+\t   (const_string \"both\")\n \t (eq_attr \"type\" \"push\")\n \t   (if_then_else (match_operand 1 \"memory_operand\" \"\")\n \t     (const_string \"both\")\n@@ -503,9 +507,9 @@\n ; integer instructions, because of the inpaired fxch instruction.\n (define_function_unit \"pent_np\" 1 0\n   (and (eq_attr \"cpu\" \"pentium\")\n-       (eq_attr \"type\" \"fmov,fop,fop1,fsgn,fmul,fpspc,fcmov,fcmp\"))\n+       (eq_attr \"type\" \"fmov,fop,fop1,fsgn,fmul,fpspc,fcmov,fcmp,fistp\"))\n   2 2\n-  [(eq_attr \"type\" \"!fmov,fop,fop1,fsgn,fmul,fpspc,fcmov,fcmp\")])\n+  [(eq_attr \"type\" \"!fmov,fop,fop1,fsgn,fmul,fpspc,fcmov,fcmp,fistp\")])\n \n (define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"cpu\" \"pentium\")\n@@ -516,7 +520,7 @@\n ; ??? Trivial fp operations such as fabs or fchs takes only one cycle.\n (define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"cpu\" \"pentium\")\n-       (eq_attr \"type\" \"fop,fop1\"))\n+       (eq_attr \"type\" \"fop,fop1,fistp\"))\n   3 1)\n \n ; Multiplication takes 3 cycles and is only half pipelined.\n@@ -614,7 +618,7 @@\n \n (define_function_unit \"ppro_p0\" 1 0\n   (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (eq_attr \"type\" \"fop,fop1,fsgn\"))\n+       (eq_attr \"type\" \"fop,fop1,fsgn,fistp\"))\n   3 1)\n \n (define_function_unit \"ppro_p0\" 1 0\n@@ -667,7 +671,7 @@\n \n (define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (eq_attr \"type\" \"fop,fop1,fsgn,fmov,fcmp,fcmov\"))\n+       (eq_attr \"type\" \"fop,fop1,fsgn,fmov,fcmp,fcmov,fistp\"))\n   1 1)\n \n (define_function_unit \"fpu\" 1 0\n@@ -770,7 +774,7 @@\n \n (define_function_unit \"k6_fpu\" 1 1\n   (and (eq_attr \"cpu\" \"k6\")\n-       (eq_attr \"type\" \"fop,fop1,fmov,fcmp\"))\n+       (eq_attr \"type\" \"fop,fop1,fmov,fcmp,fistp\"))\n   2 2)\n \n (define_function_unit \"k6_fpu\" 1 1\n@@ -882,7 +886,7 @@\n   42 42)\n \n (define_attr \"athlon_fpunits\" \"none,store,mul,add,muladd,any\"\n-  (cond [(eq_attr \"type\" \"fop,fop1,fcmp\")\n+  (cond [(eq_attr \"type\" \"fop,fop1,fcmp,fistp\")\n \t   (const_string \"add\")\n          (eq_attr \"type\" \"fmul,fdiv,fpspc,fsgn,fcmov\")\n \t   (const_string \"mul\")\n@@ -917,7 +921,7 @@\n \n (define_function_unit \"athlon_fp\" 3 0\n   (and (eq_attr \"cpu\" \"athlon\")\n-       (eq_attr \"type\" \"fop,fop1,fmul\"))\n+       (eq_attr \"type\" \"fop,fop1,fmul,fistp\"))\n   4 1)\n \n ;; XFmode loads are slow.\n@@ -4620,38 +4624,20 @@\n ;; Signed conversion to DImode.\n \n (define_expand \"fix_truncxfdi2\"\n-  [(parallel [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n-\t\t   (fix:DI (match_operand:XF 1 \"register_operand\" \"\")))\n-\t      (use (match_dup 2))\n-\t      (use (match_dup 3))\n-\t      (clobber (match_dup 4))\n-\t      (clobber (match_scratch:XF 5 \"\"))])]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+        (fix:DI (match_operand:XF 1 \"register_operand\" \"\")))]\n   \"TARGET_80387 && !TARGET_64BIT\"\n-  \"operands[2] = assign_386_stack_local (HImode, 1);\n-   operands[3] = assign_386_stack_local (HImode, 2);\n-   emit_i387_cw_initialization (operands[2], operands[3]);\n-   operands[4] = assign_386_stack_local (DImode, 0);\")\n+  \"\")\n \n (define_expand \"fix_trunctfdi2\"\n-  [(parallel [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n-\t\t   (fix:DI (match_operand:TF 1 \"register_operand\" \"\")))\n-\t      (use (match_dup 2))\n-\t      (use (match_dup 3))\n-\t      (clobber (match_dup 4))\n-\t      (clobber (match_scratch:XF 5 \"\"))])]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t(fix:DI (match_operand:TF 1 \"register_operand\" \"\")))]\n   \"TARGET_80387\"\n-  \"operands[2] = assign_386_stack_local (HImode, 1);\n-   operands[3] = assign_386_stack_local (HImode, 2);\n-   emit_i387_cw_initialization (operands[2], operands[3]);\n-   operands[4] = assign_386_stack_local (DImode, 0);\")\n+  \"\")\n \n (define_expand \"fix_truncdfdi2\"\n-  [(parallel [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n-\t\t   (fix:DI (match_operand:DF 1 \"register_operand\" \"\")))\n-\t      (use (match_dup 2))\n-\t      (use (match_dup 3))\n-\t      (clobber (match_dup 4))\n-\t      (clobber (match_scratch:XF 5 \"\"))])]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+        (fix:DI (match_operand:DF 1 \"register_operand\" \"\")))]\n   \"TARGET_80387 || (TARGET_SSE2 && TARGET_64BIT)\"\n {\n   if (TARGET_SSE2 && TARGET_64BIT)\n@@ -4662,53 +4648,73 @@\n \temit_move_insn (operands[0], out);\n      DONE;\n    }\n-  else\n-   {\n-     operands[2] = assign_386_stack_local (HImode, 1);\n-     operands[3] = assign_386_stack_local (HImode, 2);\n-     emit_i387_cw_initialization (operands[2], operands[3]);\n-     operands[4] = assign_386_stack_local (DImode, 0);\n-   }\n })\n \n (define_expand \"fix_truncsfdi2\"\n-  [(parallel [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n-\t\t   (fix:DI (match_operand:SF 1 \"register_operand\" \"\")))\n-\t      (use (match_dup 2))\n-\t      (use (match_dup 3))\n-\t      (clobber (match_dup 4))\n-\t      (clobber (match_scratch:XF 5 \"\"))])]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t(fix:DI (match_operand:SF 1 \"register_operand\" \"\")))]\n   \"TARGET_80387 || (TARGET_SSE && TARGET_64BIT)\"\n {\n-  if (TARGET_SSE2 && TARGET_64BIT)\n+  if (TARGET_SSE && TARGET_64BIT)\n    {\n      rtx out = REG_P (operands[0]) ? operands[0] : gen_reg_rtx (DImode);\n      emit_insn (gen_fix_truncsfdi_sse (out, operands[1]));\n      if (out != operands[0])\n \temit_move_insn (operands[0], out);\n      DONE;\n    }\n-  else\n-   {\n-     operands[2] = assign_386_stack_local (HImode, 1);\n-     operands[3] = assign_386_stack_local (HImode, 2);\n-     emit_i387_cw_initialization (operands[2], operands[3]);\n-     operands[4] = assign_386_stack_local (DImode, 0);\n-   }\n })\n \n-(define_insn \"*fix_truncdi_1\"\n+;; See the comments in i386.h near OPTIMIZE_MODE_SWITCHING for the description\n+;; of the machinery.\n+(define_insn_and_split \"*fix_truncdi_1\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=m,?r\")\n+\t(fix:DI (match_operand 1 \"register_operand\" \"f,f\")))]\n+  \"TARGET_80387 && FLOAT_MODE_P (GET_MODE (operands[1]))\n+   && !reload_completed && !reload_in_progress\n+   && (!SSE_FLOAT_MODE_P (GET_MODE (operands[1])) || !TARGET_64BIT)\"\n+  \"#\"\n+  \"\"\n+  [(const_int 0)]\n+{\n+  operands[2] = assign_386_stack_local (HImode, 1);\n+  operands[3] = assign_386_stack_local (HImode, 2);\n+  if (memory_operand (operands[0], VOIDmode))\n+    emit_insn (gen_fix_truncdi_memory (operands[0], operands[1],\n+\t\t\t\t       operands[2], operands[3]));\n+  else\n+    {\n+      operands[4] = assign_386_stack_local (DImode, 0);\n+      emit_insn (gen_fix_truncdi_nomemory (operands[0], operands[1],\n+\t\t\t\t\t   operands[2], operands[3],\n+\t\t\t\t\t   operands[4]));\n+    }\n+  DONE;\n+}\n+  [(set_attr \"type\" \"fistp\")])\n+\n+(define_insn \"fix_truncdi_nomemory\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=m,?r\")\n \t(fix:DI (match_operand 1 \"register_operand\" \"f,f\")))\n    (use (match_operand:HI 2 \"memory_operand\" \"m,m\"))\n    (use (match_operand:HI 3 \"memory_operand\" \"m,m\"))\n    (clobber (match_operand:DI 4 \"memory_operand\" \"=m,m\"))\n-   (clobber (match_scratch 5 \"=&1f,&1f\"))]\n+   (clobber (match_scratch:DF 5 \"=&1f,&1f\"))]\n   \"TARGET_80387 && FLOAT_MODE_P (GET_MODE (operands[1]))\n-   && (!TARGET_SSE2 || !TARGET_64BIT\n-       || !SSE_FLOAT_MODE_P (GET_MODE (operands[1])))\"\n-  \"* return output_fix_trunc (insn, operands);\"\n-  [(set_attr \"type\" \"multi\")])\n+   && (!SSE_FLOAT_MODE_P (GET_MODE (operands[1])) || !TARGET_64BIT)\"\n+  \"#\"\n+  [(set_attr \"type\" \"fistp\")])\n+\n+(define_insn \"fix_truncdi_memory\"\n+  [(set (match_operand:DI 0 \"memory_operand\" \"=m\")\n+\t(fix:DI (match_operand 1 \"register_operand\" \"f\")))\n+   (use (match_operand:HI 2 \"memory_operand\" \"m\"))\n+   (use (match_operand:HI 3 \"memory_operand\" \"m\"))\n+   (clobber (match_scratch:DF 4 \"=&1f\"))]\n+  \"TARGET_80387 && FLOAT_MODE_P (GET_MODE (operands[1]))\n+   && (!SSE_FLOAT_MODE_P (GET_MODE (operands[1])) || !TARGET_64BIT)\"\n+  \"* operands[5] = operands[4]; return output_fix_trunc (insn, operands);\"\n+  [(set_attr \"type\" \"fistp\")])\n \n (define_split \n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -4721,11 +4727,24 @@\n   [(parallel [(set (match_dup 4) (fix:DI (match_dup 1)))\n \t      (use (match_dup 2))\n \t      (use (match_dup 3))\n-\t      (clobber (match_dup 4))\n \t      (clobber (match_dup 5))])\n    (set (match_dup 0) (match_dup 4))]\n   \"\")\n \n+(define_split \n+  [(set (match_operand:DI 0 \"memory_operand\" \"\")\n+\t(fix:DI (match_operand 1 \"register_operand\" \"\")))\n+   (use (match_operand:HI 2 \"memory_operand\" \"\"))\n+   (use (match_operand:HI 3 \"memory_operand\" \"\"))\n+   (clobber (match_operand:DI 4 \"memory_operand\" \"\"))\n+   (clobber (match_scratch 5 \"\"))]\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (fix:DI (match_dup 1)))\n+\t      (use (match_dup 2))\n+\t      (use (match_dup 3))\n+\t      (clobber (match_dup 5))])]\n+  \"\")\n+\n ;; When SSE available, it is always faster to use it!\n (define_insn \"fix_truncsfdi_sse\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -4744,35 +4763,20 @@\n ;; Signed conversion to SImode.\n \n (define_expand \"fix_truncxfsi2\"\n-  [(parallel [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n-\t\t   (fix:SI (match_operand:XF 1 \"register_operand\" \"\")))\n-\t      (use (match_dup 2))\n-\t      (use (match_dup 3))\n-\t      (clobber (match_dup 4))])]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+\t(fix:SI (match_operand:XF 1 \"register_operand\" \"\")))]\n   \"TARGET_80387 && !TARGET_64BIT\"\n-  \"operands[2] = assign_386_stack_local (HImode, 1);\n-   operands[3] = assign_386_stack_local (HImode, 2);\n-   emit_i387_cw_initialization (operands[2], operands[3]);\n-   operands[4] = assign_386_stack_local (SImode, 0);\")\n+  \"\")\n \n (define_expand \"fix_trunctfsi2\"\n-  [(parallel [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n-\t\t   (fix:SI (match_operand:TF 1 \"register_operand\" \"\")))\n-\t      (use (match_dup 2))\n-\t      (use (match_dup 3))\n-\t      (clobber (match_dup 4))])]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+\t(fix:SI (match_operand:TF 1 \"register_operand\" \"\")))]\n   \"TARGET_80387\"\n-  \"operands[2] = assign_386_stack_local (HImode, 1);\n-   operands[3] = assign_386_stack_local (HImode, 2);\n-   emit_i387_cw_initialization (operands[2], operands[3]);\n-   operands[4] = assign_386_stack_local (SImode, 0);\")\n+  \"\")\n \n (define_expand \"fix_truncdfsi2\"\n-  [(parallel [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n-\t\t   (fix:SI (match_operand:DF 1 \"register_operand\" \"\")))\n-\t      (use (match_dup 2))\n-\t      (use (match_dup 3))\n-\t      (clobber (match_dup 4))])]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+\t(fix:SI (match_operand:DF 1 \"register_operand\" \"\")))]\n   \"TARGET_80387 || TARGET_SSE2\"\n {\n   if (TARGET_SSE2)\n@@ -4783,50 +4787,71 @@\n \temit_move_insn (operands[0], out);\n      DONE;\n    }\n-  else\n-   {\n-     operands[2] = assign_386_stack_local (HImode, 1);\n-     operands[3] = assign_386_stack_local (HImode, 2);\n-     emit_i387_cw_initialization (operands[2], operands[3]);\n-     operands[4] = assign_386_stack_local (SImode, 0);\n-   }\n })\n \n (define_expand \"fix_truncsfsi2\"\n-  [(parallel [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n-\t\t   (fix:SI (match_operand:SF 1 \"register_operand\" \"\")))\n-\t      (use (match_dup 2))\n-\t      (use (match_dup 3))\n-\t      (clobber (match_dup 4))])]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+\t(fix:SI (match_operand:SF 1 \"register_operand\" \"\")))]\n   \"TARGET_80387 || TARGET_SSE\"\n {\n-  if (TARGET_SSE2)\n+  if (TARGET_SSE)\n    {\n      rtx out = REG_P (operands[0]) ? operands[0] : gen_reg_rtx (SImode);\n      emit_insn (gen_fix_truncsfsi_sse (out, operands[1]));\n      if (out != operands[0])\n \temit_move_insn (operands[0], out);\n      DONE;\n    }\n-  else\n-   {\n-     operands[2] = assign_386_stack_local (HImode, 1);\n-     operands[3] = assign_386_stack_local (HImode, 2);\n-     emit_i387_cw_initialization (operands[2], operands[3]);\n-     operands[4] = assign_386_stack_local (SImode, 0);\n-   }\n })\n \n-(define_insn \"*fix_truncsi_1\"\n+;; See the comments in i386.h near OPTIMIZE_MODE_SWITCHING for the description\n+;; of the machinery.\n+(define_insn_and_split \"*fix_truncsi_1\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=m,?r\")\n+\t(fix:SI (match_operand 1 \"register_operand\" \"f,f\")))]\n+  \"TARGET_80387 && FLOAT_MODE_P (GET_MODE (operands[1]))\n+   && !reload_completed && !reload_in_progress\n+   && !SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\"\n+  \"#\"\n+  \"\"\n+  [(const_int 0)]\n+{\n+  operands[2] = assign_386_stack_local (HImode, 1);\n+  operands[3] = assign_386_stack_local (HImode, 2);\n+  if (memory_operand (operands[0], VOIDmode))\n+    emit_insn (gen_fix_truncsi_memory (operands[0], operands[1],\n+\t\t\t\t       operands[2], operands[3]));\n+  else\n+    {\n+      operands[4] = assign_386_stack_local (SImode, 0);\n+      emit_insn (gen_fix_truncsi_nomemory (operands[0], operands[1],\n+\t\t\t\t\t   operands[2], operands[3],\n+\t\t\t\t\t   operands[4]));\n+    }\n+  DONE;\n+}\n+  [(set_attr \"type\" \"fistp\")])\n+\n+(define_insn \"fix_truncsi_nomemory\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=m,?r\")\n \t(fix:SI (match_operand 1 \"register_operand\" \"f,f\")))\n    (use (match_operand:HI 2 \"memory_operand\" \"m,m\"))\n    (use (match_operand:HI 3 \"memory_operand\" \"m,m\"))\n    (clobber (match_operand:SI 4 \"memory_operand\" \"=m,m\"))]\n   \"TARGET_80387 && FLOAT_MODE_P (GET_MODE (operands[1]))\n-   && (!TARGET_SSE2 || !SSE_FLOAT_MODE_P (GET_MODE (operands[1])))\"\n+   && !SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\"\n+  \"#\"\n+  [(set_attr \"type\" \"fistp\")])\n+\n+(define_insn \"fix_truncsi_memory\"\n+  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n+\t(fix:SI (match_operand 1 \"register_operand\" \"f\")))\n+   (use (match_operand:HI 2 \"memory_operand\" \"m\"))\n+   (use (match_operand:HI 3 \"memory_operand\" \"m\"))]\n+  \"TARGET_80387 && FLOAT_MODE_P (GET_MODE (operands[1]))\n+   && !SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\"\n   \"* return output_fix_trunc (insn, operands);\"\n-  [(set_attr \"type\" \"multi\")])\n+  [(set_attr \"type\" \"fistp\")])\n \n ;; When SSE available, it is always faster to use it!\n (define_insn \"fix_truncsfsi_sse\"\n@@ -4852,71 +4877,108 @@\n   \"reload_completed\"\n   [(parallel [(set (match_dup 4) (fix:SI (match_dup 1)))\n \t      (use (match_dup 2))\n-\t      (use (match_dup 3))\n-\t      (clobber (match_dup 4))])\n+\t      (use (match_dup 3))])\n    (set (match_dup 0) (match_dup 4))]\n   \"\")\n \n+(define_split \n+  [(set (match_operand:SI 0 \"memory_operand\" \"\")\n+\t(fix:SI (match_operand 1 \"register_operand\" \"\")))\n+   (use (match_operand:HI 2 \"memory_operand\" \"\"))\n+   (use (match_operand:HI 3 \"memory_operand\" \"\"))\n+   (clobber (match_operand:SI 4 \"memory_operand\" \"\"))]\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (fix:SI (match_dup 1)))\n+\t      (use (match_dup 2))\n+\t      (use (match_dup 3))])]\n+  \"\")\n+\n ;; Signed conversion to HImode.\n \n (define_expand \"fix_truncxfhi2\"\n-  [(parallel [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n-\t\t   (fix:HI (match_operand:XF 1 \"register_operand\" \"\")))\n-\t      (use (match_dup 2))\n-\t      (use (match_dup 3))\n-\t      (clobber (match_dup 4))])]\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n+        (fix:HI (match_operand:XF 1 \"register_operand\" \"\")))]\n   \"TARGET_80387 && !TARGET_64BIT\"\n-  \"operands[2] = assign_386_stack_local (HImode, 1);\n-   operands[3] = assign_386_stack_local (HImode, 2);\n-   emit_i387_cw_initialization (operands[2], operands[3]);\n-   operands[4] = assign_386_stack_local (HImode, 0);\")\n+  \"\")\n \n (define_expand \"fix_trunctfhi2\"\n-  [(parallel [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n-\t\t   (fix:HI (match_operand:TF 1 \"register_operand\" \"\")))\n-\t      (use (match_dup 2))\n-\t      (use (match_dup 3))\n-\t      (clobber (match_dup 4))])]\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n+\t(fix:HI (match_operand:TF 1 \"register_operand\" \"\")))]\n   \"TARGET_80387\"\n-  \"operands[2] = assign_386_stack_local (HImode, 1);\n-   operands[3] = assign_386_stack_local (HImode, 2);\n-   emit_i387_cw_initialization (operands[2], operands[3]);\n-   operands[4] = assign_386_stack_local (HImode, 0);\")\n+  \"\")\n \n (define_expand \"fix_truncdfhi2\"\n-  [(parallel [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n-\t\t   (fix:HI (match_operand:DF 1 \"register_operand\" \"\")))\n-\t      (use (match_dup 2))\n-\t      (use (match_dup 3))\n-\t      (clobber (match_dup 4))])]\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n+\t(fix:HI (match_operand:DF 1 \"register_operand\" \"\")))]\n   \"TARGET_80387 && !TARGET_SSE2\"\n-  \"operands[2] = assign_386_stack_local (HImode, 1);\n-   operands[3] = assign_386_stack_local (HImode, 2);\n-   emit_i387_cw_initialization (operands[2], operands[3]);\n-   operands[4] = assign_386_stack_local (HImode, 0);\")\n+  \"\")\n \n (define_expand \"fix_truncsfhi2\"\n-  [(parallel [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n-\t\t   (fix:HI (match_operand:SF 1 \"register_operand\" \"\")))\n-\t      (use (match_dup 2))\n-\t      (use (match_dup 3))\n-\t      (clobber (match_dup 4))])]\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n+\t(fix:HI (match_operand:SF 1 \"register_operand\" \"\")))]\n   \"TARGET_80387 && !TARGET_SSE\"\n-  \"operands[2] = assign_386_stack_local (HImode, 1);\n-   operands[3] = assign_386_stack_local (HImode, 2);\n-   emit_i387_cw_initialization (operands[2], operands[3]);\n-   operands[4] = assign_386_stack_local (HImode, 0);\")\n+  \"\")\n \n-(define_insn \"*fix_trunchi_1\"\n+;; See the comments in i386.h near OPTIMIZE_MODE_SWITCHING for the description\n+;; of the machinery.\n+(define_insn_and_split \"*fix_trunchi_1\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=m,?r\")\n+\t(fix:HI (match_operand 1 \"register_operand\" \"f,f\")))]\n+  \"TARGET_80387 && FLOAT_MODE_P (GET_MODE (operands[1]))\n+   && !reload_completed && !reload_in_progress\n+   && !SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\"\n+  \"#\"\n+  \"\"\n+  [(const_int 0)]\n+{\n+  operands[2] = assign_386_stack_local (HImode, 1);\n+  operands[3] = assign_386_stack_local (HImode, 2);\n+  if (memory_operand (operands[0], VOIDmode))\n+    emit_insn (gen_fix_trunchi_memory (operands[0], operands[1],\n+\t\t\t\t       operands[2], operands[3]));\n+  else\n+    {\n+      operands[4] = assign_386_stack_local (HImode, 0);\n+      emit_insn (gen_fix_trunchi_nomemory (operands[0], operands[1],\n+\t\t\t\t\t   operands[2], operands[3],\n+\t\t\t\t\t   operands[4]));\n+    }\n+  DONE;\n+}\n+  [(set_attr \"type\" \"fistp\")])\n+\n+(define_insn \"fix_trunchi_nomemory\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=m,?r\")\n \t(fix:HI (match_operand 1 \"register_operand\" \"f,f\")))\n    (use (match_operand:HI 2 \"memory_operand\" \"m,m\"))\n    (use (match_operand:HI 3 \"memory_operand\" \"m,m\"))\n    (clobber (match_operand:HI 4 \"memory_operand\" \"=m,m\"))]\n   \"TARGET_80387 && FLOAT_MODE_P (GET_MODE (operands[1]))\n-   && (TARGET_SSE2 || !SSE_FLOAT_MODE_P (GET_MODE (operands[1])))\"\n+   && !SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\"\n+  \"#\"\n+  [(set_attr \"type\" \"fistp\")])\n+\n+(define_insn \"fix_trunchi_memory\"\n+  [(set (match_operand:HI 0 \"memory_operand\" \"=m\")\n+\t(fix:HI (match_operand 1 \"register_operand\" \"f\")))\n+   (use (match_operand:HI 2 \"memory_operand\" \"m\"))\n+   (use (match_operand:HI 3 \"memory_operand\" \"m\"))]\n+  \"TARGET_80387 && FLOAT_MODE_P (GET_MODE (operands[1]))\n+   && !SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\"\n   \"* return output_fix_trunc (insn, operands);\"\n-  [(set_attr \"type\" \"multi\")])\n+  [(set_attr \"type\" \"fistp\")])\n+\n+(define_split \n+  [(set (match_operand:HI 0 \"memory_operand\" \"\")\n+\t(fix:HI (match_operand 1 \"register_operand\" \"\")))\n+   (use (match_operand:HI 2 \"memory_operand\" \"\"))\n+   (use (match_operand:HI 3 \"memory_operand\" \"\"))\n+   (clobber (match_operand:HI 4 \"memory_operand\" \"\"))]\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (fix:HI (match_dup 1)))\n+\t      (use (match_dup 2))\n+\t      (use (match_dup 3))])]\n+  \"\")\n \n (define_split \n   [(set (match_operand:HI 0 \"register_operand\" \"\")"}, {"sha": "746ea908afa368888fd3d371716afaa15c789c30", "filename": "gcc/toplev.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22fb740dcc3541a5b9430c79976c6327c7c470a0/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22fb740dcc3541a5b9430c79976c6327c7c470a0/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=22fb740dcc3541a5b9430c79976c6327c7c470a0", "patch": "@@ -3327,7 +3327,6 @@ rest_of_compilation (decl)\n   life_analysis (insns, rtl_dump_file, PROP_FINAL);\n   timevar_pop (TV_FLOW);\n \n-  register_life_up_to_date = 1;\n   no_new_pseudos = 1;\n \n   if (warn_uninitialized || extra_warnings)\n@@ -3415,31 +3414,32 @@ rest_of_compilation (decl)\n       ggc_collect ();\n     }\n \n+  /* Do unconditional splitting before register allocation to allow machine\n+     description to add extra information not needed previously.  */\n+  split_all_insns (1);\n+\n   /* Any of the several passes since flow1 will have munged register\n      lifetime data a bit.  */\n-  if (optimize > 0)\n-    register_life_up_to_date = 0;\n+  register_life_up_to_date = 0;\n \n #ifdef OPTIMIZE_MODE_SWITCHING\n   timevar_push (TV_GCSE);\n \n-  no_new_pseudos = 1;\n+  no_new_pseudos = 0;\n   if (optimize_mode_switching (NULL))\n     {\n       /* We did work, and so had to regenerate global life information.\n \t Take advantage of this and don't re-recompute register life\n \t information below.  */\n       register_life_up_to_date = 1;\n     }\n-  no_new_pseudos = 0;\n+  no_new_pseudos = 1;\n \n   timevar_pop (TV_GCSE);\n #endif\n \n   timevar_push (TV_SCHED);\n \n-  split_all_insns (1);\n-\n #ifdef INSN_SCHEDULING\n \n   /* Print function header into sched dump now"}]}