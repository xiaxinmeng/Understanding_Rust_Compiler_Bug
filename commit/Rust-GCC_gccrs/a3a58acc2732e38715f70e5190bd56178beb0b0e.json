{"sha": "a3a58acc2732e38715f70e5190bd56178beb0b0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTNhNThhY2MyNzMyZTM4NzE1ZjcwZTUxOTBiZDU2MTc4YmViMGIwZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-08-12T05:52:13Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-08-12T05:52:13Z"}, "message": "(store_expr): Handle COND_EXPR cleanups like expand_expr.\n\nFrom-SVN: r12620", "tree": {"sha": "04da7b424421837c34218102bff222a3633c0413", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04da7b424421837c34218102bff222a3633c0413"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3a58acc2732e38715f70e5190bd56178beb0b0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3a58acc2732e38715f70e5190bd56178beb0b0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3a58acc2732e38715f70e5190bd56178beb0b0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3a58acc2732e38715f70e5190bd56178beb0b0e/comments", "author": null, "committer": null, "parents": [{"sha": "5c0bf7476e6547500e2492ef67be94589078cb67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c0bf7476e6547500e2492ef67be94589078cb67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c0bf7476e6547500e2492ef67be94589078cb67"}], "stats": {"total": 73, "additions": 73, "deletions": 0}, "files": [{"sha": "7905fa965c611187c9803be83ac842f0ff32739a", "filename": "gcc/expr.c", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a58acc2732e38715f70e5190bd56178beb0b0e/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a58acc2732e38715f70e5190bd56178beb0b0e/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=a3a58acc2732e38715f70e5190bd56178beb0b0e", "patch": "@@ -3056,6 +3056,17 @@ store_expr (exp, target, want_value)\n \t For non-BLKmode, it is more efficient not to do this.  */\n \n       rtx lab1 = gen_label_rtx (), lab2 = gen_label_rtx ();\n+      rtx flag = NULL_RTX;\n+      tree left_cleanups = NULL_TREE;\n+      tree right_cleanups = NULL_TREE;\n+      tree old_cleanups = cleanups_this_call;\n+\n+      /* Used to save a pointer to the place to put the setting of\n+\t the flag that indicates if this side of the conditional was\n+\t taken.  We backpatch the code, if we find out later that we\n+\t have any conditional cleanups that need to be performed.  */\n+      rtx dest_right_flag = NULL_RTX;\n+      rtx dest_left_flag = NULL_RTX;\n \n       emit_queue ();\n       target = protect_from_queue (target, 1);\n@@ -3064,14 +3075,74 @@ store_expr (exp, target, want_value)\n       NO_DEFER_POP;\n       jumpifnot (TREE_OPERAND (exp, 0), lab1);\n       store_expr (TREE_OPERAND (exp, 1), target, 0);\n+      dest_left_flag = get_last_insn ();\n+      /* Handle conditional cleanups, if any.  */\n+      left_cleanups = defer_cleanups_to (old_cleanups);\n       emit_queue ();\n       emit_jump_insn (gen_jump (lab2));\n       emit_barrier ();\n       emit_label (lab1);\n       store_expr (TREE_OPERAND (exp, 2), target, 0);\n+      dest_right_flag = get_last_insn ();\n+      /* Handle conditional cleanups, if any.  */\n+      right_cleanups = defer_cleanups_to (old_cleanups);\n       emit_queue ();\n       emit_label (lab2);\n       OK_DEFER_POP;\n+\n+      /* Add back in any conditional cleanups.  */\n+      if (left_cleanups || right_cleanups)\n+\t{\n+\t  tree new_cleanups;\n+\t  tree cond;\n+\t  rtx last;\n+\n+\t  /* Now that we know that a flag is needed, go back and add in the\n+\t     setting of the flag.  */\n+\n+\t  flag = gen_reg_rtx (word_mode);\n+\n+\t  /* Do the left side flag.  */\n+\t  last = get_last_insn ();\n+\t  /* Flag left cleanups as needed.  */\n+\t  emit_move_insn (flag, const1_rtx);\n+\t  /* ??? deprecated, use sequences instead.  */\n+\t  reorder_insns (NEXT_INSN (last), get_last_insn (), dest_left_flag);\n+\n+\t  /* Do the right side flag.  */\n+\t  last = get_last_insn ();\n+\t  /* Flag left cleanups as needed.  */\n+\t  emit_move_insn (flag, const0_rtx);\n+\t  /* ??? deprecated, use sequences instead.  */\n+\t  reorder_insns (NEXT_INSN (last), get_last_insn (), dest_right_flag);\n+\n+\t  /* All cleanups must be on the function_obstack.  */\n+\t  push_obstacks_nochange ();\n+\t  resume_temporary_allocation ();\n+\n+\t  /* convert flag, which is an rtx, into a tree.  */\n+\t  cond = make_node (RTL_EXPR);\n+\t  TREE_TYPE (cond) = integer_type_node;\n+\t  RTL_EXPR_RTL (cond) = flag;\n+\t  RTL_EXPR_SEQUENCE (cond) = NULL_RTX;\n+\t  cond = save_expr (cond);\n+\n+\t  if (! left_cleanups)\n+\t    left_cleanups = integer_zero_node;\n+\t  if (! right_cleanups)\n+\t    right_cleanups = integer_zero_node;\n+\t  new_cleanups = build (COND_EXPR, void_type_node,\n+\t\t\t\ttruthvalue_conversion (cond),\n+\t\t\t\tleft_cleanups, right_cleanups);\n+\t  new_cleanups = fold (new_cleanups);\n+\n+\t  pop_obstacks ();\n+\n+\t  /* Now add in the conditionalized cleanups.  */\n+\t  cleanups_this_call\n+\t    = tree_cons (NULL_TREE, new_cleanups, cleanups_this_call);\n+\t  expand_eh_region_start ();\n+\t}\n       return want_value ? target : NULL_RTX;\n     }\n   else if (want_value && GET_CODE (target) == MEM && ! MEM_VOLATILE_P (target)\n@@ -6444,6 +6515,8 @@ expand_expr (exp, target, tmode, modifier)\n \t\t && ! (GET_CODE (original_target) == MEM\n \t\t       && MEM_VOLATILE_P (original_target)))\n \t  temp = original_target;\n+\telse if (TREE_ADDRESSABLE (type))\n+\t  abort ();\n \telse\n \t  temp = assign_temp (type, 0, 0, 1);\n "}]}