{"sha": "f22735ae61051e2a1ec90c4df81ca64d032b313b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjIyNzM1YWU2MTA1MWUyYTFlYzkwYzRkZjgxY2E2NGQwMzJiMzEzYg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2016-09-26T16:39:15Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2016-09-26T16:39:15Z"}, "message": "read-rtl.c: split out read_rtx_operand from read_rtx_code\n\ngcc/ChangeLog:\n\t* read-rtl.c (read_rtx_code): Rename local \"i\" to \"idx\", and use\n\t\"c\" instead when parsing characters.  Move operand parsing into...\n\t(read_rtx_operand): ...this new function, renaming \"i\" to \"idx\",\n\tand tightening the scope of various locals.\n\nFrom-SVN: r240502", "tree": {"sha": "b3c6738c290699739e7156546ac1eacace64ec2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3c6738c290699739e7156546ac1eacace64ec2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f22735ae61051e2a1ec90c4df81ca64d032b313b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f22735ae61051e2a1ec90c4df81ca64d032b313b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f22735ae61051e2a1ec90c4df81ca64d032b313b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f22735ae61051e2a1ec90c4df81ca64d032b313b/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2fd88f4ff255ace8607d661a1b1bcd290f55428f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fd88f4ff255ace8607d661a1b1bcd290f55428f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fd88f4ff255ace8607d661a1b1bcd290f55428f"}], "stats": {"total": 411, "additions": 218, "deletions": 193}, "files": [{"sha": "e88c6641d55065d2734ccebc786b84f543a8c3a7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f22735ae61051e2a1ec90c4df81ca64d032b313b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f22735ae61051e2a1ec90c4df81ca64d032b313b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f22735ae61051e2a1ec90c4df81ca64d032b313b", "patch": "@@ -1,3 +1,10 @@\n+2016-09-26  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* read-rtl.c (read_rtx_code): Rename local \"i\" to \"idx\", and use\n+\t\"c\" instead when parsing characters.  Move operand parsing into...\n+\t(read_rtx_operand): ...this new function, renaming \"i\" to \"idx\",\n+\tand tightening the scope of various locals.\n+\n 2016-09-26  LH Mouse  <lh_mouse@126.com>\n \n \t* config/i386/cygming.h (ASM_OUTPUT_DWARF_OFFSET): Fix typo."}, {"sha": "925ea451c9d0591a1b01079ccda752f2a5286a71", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 211, "deletions": 193, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f22735ae61051e2a1ec90c4df81ca64d032b313b/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f22735ae61051e2a1ec90c4df81ca64d032b313b/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=f22735ae61051e2a1ec90c4df81ca64d032b313b", "patch": "@@ -107,6 +107,7 @@ const char *current_iterator_name;\n \n static void validate_const_int (const char *);\n static rtx read_rtx_code (const char *);\n+static void read_rtx_operand (rtx, int);\n static rtx read_nested_rtx (void);\n static rtx read_rtx_variadic (rtx);\n \n@@ -1089,17 +1090,12 @@ read_rtx (const char *rtx_name, vec<rtx> *rtxen)\n static rtx\n read_rtx_code (const char *code_name)\n {\n-  int i;\n   RTX_CODE code;\n-  struct mapping *iterator, *m;\n+  struct mapping *iterator;\n   const char *format_ptr;\n   struct md_name name;\n   rtx return_rtx;\n   int c;\n-  HOST_WIDE_INT tmp_wide;\n-  char *str;\n-  char *start, *end, *ptr;\n-  char tmpstr[256];\n \n   /* Linked list structure for making RTXs: */\n   struct rtx_list\n@@ -1128,199 +1124,17 @@ read_rtx_code (const char *code_name)\n   /* If what follows is `: mode ', read it and\n      store the mode in the rtx.  */\n \n-  i = read_skip_spaces ();\n-  if (i == ':')\n+  c = read_skip_spaces ();\n+  if (c == ':')\n     {\n       read_name (&name);\n       record_potential_iterator_use (&modes, return_rtx, name.string);\n     }\n   else\n-    unread_char (i);\n-\n-  for (i = 0; format_ptr[i] != 0; i++)\n-    switch (format_ptr[i])\n-      {\n-\t/* 0 means a field for internal use only.\n-\t   Don't expect it to be present in the input.  */\n-      case '0':\n-\tif (code == REG)\n-\t  ORIGINAL_REGNO (return_rtx) = REGNO (return_rtx);\n-\tbreak;\n-\n-      case 'e':\n-      case 'u':\n-\tXEXP (return_rtx, i) = read_nested_rtx ();\n-\tbreak;\n-\n-      case 'V':\n-\t/* 'V' is an optional vector: if a closeparen follows,\n-\t   just store NULL for this element.  */\n-\tc = read_skip_spaces ();\n-\tunread_char (c);\n-\tif (c == ')')\n-\t  {\n-\t    XVEC (return_rtx, i) = 0;\n-\t    break;\n-\t  }\n-\t/* Now process the vector.  */\n-\t/* FALLTHRU */\n-\n-      case 'E':\n-\t{\n-\t  /* Obstack to store scratch vector in.  */\n-\t  struct obstack vector_stack;\n-\t  int list_counter = 0;\n-\t  rtvec return_vec = NULL_RTVEC;\n-\n-\t  require_char_ws ('[');\n-\n-\t  /* Add expressions to a list, while keeping a count.  */\n-\t  obstack_init (&vector_stack);\n-\t  while ((c = read_skip_spaces ()) && c != ']')\n-\t    {\n-\t      if (c == EOF)\n-\t\tfatal_expected_char (']', c);\n-\t      unread_char (c);\n-\t      list_counter++;\n-\t      obstack_ptr_grow (&vector_stack, read_nested_rtx ());\n-\t    }\n-\t  if (list_counter > 0)\n-\t    {\n-\t      return_vec = rtvec_alloc (list_counter);\n-\t      memcpy (&return_vec->elem[0], obstack_finish (&vector_stack),\n-\t\t      list_counter * sizeof (rtx));\n-\t    }\n-\t  else if (format_ptr[i] == 'E')\n-\t    fatal_with_file_and_line (\"vector must have at least one element\");\n-\t  XVEC (return_rtx, i) = return_vec;\n-\t  obstack_free (&vector_stack, NULL);\n-\t  /* close bracket gotten */\n-\t}\n-\tbreak;\n-\n-      case 'S':\n-      case 'T':\n-      case 's':\n-\t{\n-\t  char *stringbuf;\n-\t  int star_if_braced;\n-\n-\t  c = read_skip_spaces ();\n-\t  unread_char (c);\n-\t  if (c == ')')\n-\t    {\n-\t      /* 'S' fields are optional and should be NULL if no string\n-\t\t was given.  Also allow normal 's' and 'T' strings to be\n-\t\t omitted, treating them in the same way as empty strings.  */\n-\t      XSTR (return_rtx, i) = (format_ptr[i] == 'S' ? NULL : \"\");\n-\t      break;\n-\t    }\n-\n-\t  /* The output template slot of a DEFINE_INSN,\n-\t     DEFINE_INSN_AND_SPLIT, or DEFINE_PEEPHOLE automatically\n-\t     gets a star inserted as its first character, if it is\n-\t     written with a brace block instead of a string constant.  */\n-\t  star_if_braced = (format_ptr[i] == 'T');\n-\n-\t  stringbuf = read_string (star_if_braced);\n-\n-\t  /* For insn patterns, we want to provide a default name\n-\t     based on the file and line, like \"*foo.md:12\", if the\n-\t     given name is blank.  These are only for define_insn and\n-\t     define_insn_and_split, to aid debugging.  */\n-\t  if (*stringbuf == '\\0'\n-\t      && i == 0\n-\t      && (GET_CODE (return_rtx) == DEFINE_INSN\n-\t\t  || GET_CODE (return_rtx) == DEFINE_INSN_AND_SPLIT))\n-\t    {\n-\t      char line_name[20];\n-\t      const char *read_md_filename = rtx_reader_ptr->get_filename ();\n-\t      const char *fn = (read_md_filename ? read_md_filename : \"rtx\");\n-\t      const char *slash;\n-\t      for (slash = fn; *slash; slash ++)\n-\t\tif (*slash == '/' || *slash == '\\\\' || *slash == ':')\n-\t\t  fn = slash + 1;\n-\t      obstack_1grow (&string_obstack, '*');\n-\t      obstack_grow (&string_obstack, fn, strlen (fn));\n-\t      sprintf (line_name, \":%d\", rtx_reader_ptr->get_lineno ());\n-\t      obstack_grow (&string_obstack, line_name, strlen (line_name)+1);\n-\t      stringbuf = XOBFINISH (&string_obstack, char *);\n-\t    }\n-\n-\t  /* Find attr-names in the string.  */\n-\t  ptr = &tmpstr[0];\n-\t  end = stringbuf;\n-\t  while ((start = strchr (end, '<')) && (end  = strchr (start, '>')))\n-\t    {\n-\t      if ((end - start - 1 > 0)\n-\t\t  && (end - start - 1 < (int)sizeof (tmpstr)))\n-\t\t{\n-\t\t  strncpy (tmpstr, start+1, end-start-1);\n-\t\t  tmpstr[end-start-1] = 0;\n-\t\t  end++;\n-\t\t}\n-\t      else\n-\t\tbreak;\n-\t      m = (struct mapping *) htab_find (substs.attrs, &ptr);\n-\t      if (m != 0)\n-\t\t{\n-\t\t  /* Here we should find linked subst-iter.  */\n-\t\t  str = find_subst_iter_by_attr (ptr);\n-\t\t  if (str)\n-\t\t    m = (struct mapping *) htab_find (substs.iterators, &str);\n-\t\t  else\n-\t\t    m = 0;\n-\t\t}\n-\t      if (m != 0)\n-\t\trecord_iterator_use (m, return_rtx);\n-\t    }\n-\n-\t  if (star_if_braced)\n-\t    XTMPL (return_rtx, i) = stringbuf;\n-\t  else\n-\t    XSTR (return_rtx, i) = stringbuf;\n-\t}\n-\tbreak;\n+    unread_char (c);\n \n-      case 'w':\n-\tread_name (&name);\n-\tvalidate_const_int (name.string);\n-#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n-\ttmp_wide = atoi (name.string);\n-#else\n-#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG\n-\ttmp_wide = atol (name.string);\n-#else\n-\t/* Prefer atoll over atoq, since the former is in the ISO C99 standard.\n-\t   But prefer not to use our hand-rolled function above either.  */\n-#if HAVE_DECL_ATOLL || !defined(HAVE_ATOQ)\n-\ttmp_wide = atoll (name.string);\n-#else\n-\ttmp_wide = atoq (name.string);\n-#endif\n-#endif\n-#endif\n-\tXWINT (return_rtx, i) = tmp_wide;\n-\tbreak;\n-\n-      case 'i':\n-      case 'n':\n-\t/* Can be an iterator or an integer constant.  */\n-\tread_name (&name);\n-\trecord_potential_iterator_use (&ints, &XINT (return_rtx, i),\n-\t\t\t\t       name.string);\n-\tbreak;\n-\n-      case 'r':\n-\tread_name (&name);\n-\tvalidate_const_int (name.string);\n-\tset_regno_raw (return_rtx, atoi (name.string), 1);\n-\tREG_ATTRS (return_rtx) = NULL;\n-\tbreak;\n-\n-      default:\n-\tgcc_unreachable ();\n-      }\n+  for (int idx = 0; format_ptr[idx] != 0; idx++)\n+    read_rtx_operand (return_rtx, idx);\n \n   if (CONST_WIDE_INT_P (return_rtx))\n     {\n@@ -1382,6 +1196,210 @@ read_rtx_code (const char *code_name)\n   return return_rtx;\n }\n \n+/* Subroutine of read_rtx_code.  Parse operand IDX within RETURN_RTX,\n+   based on the corresponding format character within GET_RTX_FORMAT\n+   for the GET_CODE (RETURN_RTX).  */\n+\n+static void\n+read_rtx_operand (rtx return_rtx, int idx)\n+{\n+  RTX_CODE code = GET_CODE (return_rtx);\n+  const char *format_ptr = GET_RTX_FORMAT (code);\n+  int c;\n+  struct md_name name;\n+\n+  switch (format_ptr[idx])\n+    {\n+      /* 0 means a field for internal use only.\n+\t Don't expect it to be present in the input.  */\n+    case '0':\n+      if (code == REG)\n+\tORIGINAL_REGNO (return_rtx) = REGNO (return_rtx);\n+      break;\n+\n+    case 'e':\n+    case 'u':\n+      XEXP (return_rtx, idx) = read_nested_rtx ();\n+      break;\n+\n+    case 'V':\n+      /* 'V' is an optional vector: if a closeparen follows,\n+\t just store NULL for this element.  */\n+      c = read_skip_spaces ();\n+      unread_char (c);\n+      if (c == ')')\n+\t{\n+\t  XVEC (return_rtx, idx) = 0;\n+\t  break;\n+\t}\n+      /* Now process the vector.  */\n+      /* FALLTHRU */\n+\n+    case 'E':\n+      {\n+\t/* Obstack to store scratch vector in.  */\n+\tstruct obstack vector_stack;\n+\tint list_counter = 0;\n+\trtvec return_vec = NULL_RTVEC;\n+\n+\trequire_char_ws ('[');\n+\n+\t/* Add expressions to a list, while keeping a count.  */\n+\tobstack_init (&vector_stack);\n+\twhile ((c = read_skip_spaces ()) && c != ']')\n+\t  {\n+\t    if (c == EOF)\n+\t      fatal_expected_char (']', c);\n+\t    unread_char (c);\n+\t    list_counter++;\n+\t    obstack_ptr_grow (&vector_stack, read_nested_rtx ());\n+\t  }\n+\tif (list_counter > 0)\n+\t  {\n+\t    return_vec = rtvec_alloc (list_counter);\n+\t    memcpy (&return_vec->elem[0], obstack_finish (&vector_stack),\n+\t\t    list_counter * sizeof (rtx));\n+\t  }\n+\telse if (format_ptr[idx] == 'E')\n+\t  fatal_with_file_and_line (\"vector must have at least one element\");\n+\tXVEC (return_rtx, idx) = return_vec;\n+\tobstack_free (&vector_stack, NULL);\n+\t/* close bracket gotten */\n+      }\n+      break;\n+\n+    case 'S':\n+    case 'T':\n+    case 's':\n+      {\n+\tchar *stringbuf;\n+\tint star_if_braced;\n+\n+\tc = read_skip_spaces ();\n+\tunread_char (c);\n+\tif (c == ')')\n+\t  {\n+\t    /* 'S' fields are optional and should be NULL if no string\n+\t       was given.  Also allow normal 's' and 'T' strings to be\n+\t       omitted, treating them in the same way as empty strings.  */\n+\t    XSTR (return_rtx, idx) = (format_ptr[idx] == 'S' ? NULL : \"\");\n+\t    break;\n+\t  }\n+\n+\t/* The output template slot of a DEFINE_INSN,\n+\t   DEFINE_INSN_AND_SPLIT, or DEFINE_PEEPHOLE automatically\n+\t   gets a star inserted as its first character, if it is\n+\t   written with a brace block instead of a string constant.  */\n+\tstar_if_braced = (format_ptr[idx] == 'T');\n+\n+\tstringbuf = read_string (star_if_braced);\n+\n+\t/* For insn patterns, we want to provide a default name\n+\t   based on the file and line, like \"*foo.md:12\", if the\n+\t   given name is blank.  These are only for define_insn and\n+\t   define_insn_and_split, to aid debugging.  */\n+\tif (*stringbuf == '\\0'\n+\t    && idx == 0\n+\t    && (GET_CODE (return_rtx) == DEFINE_INSN\n+\t\t|| GET_CODE (return_rtx) == DEFINE_INSN_AND_SPLIT))\n+\t  {\n+\t    char line_name[20];\n+\t    const char *read_md_filename = rtx_reader_ptr->get_filename ();\n+\t    const char *fn = (read_md_filename ? read_md_filename : \"rtx\");\n+\t    const char *slash;\n+\t    for (slash = fn; *slash; slash ++)\n+\t      if (*slash == '/' || *slash == '\\\\' || *slash == ':')\n+\t\tfn = slash + 1;\n+\t    obstack_1grow (&string_obstack, '*');\n+\t    obstack_grow (&string_obstack, fn, strlen (fn));\n+\t    sprintf (line_name, \":%d\", rtx_reader_ptr->get_lineno ());\n+\t    obstack_grow (&string_obstack, line_name, strlen (line_name)+1);\n+\t    stringbuf = XOBFINISH (&string_obstack, char *);\n+\t  }\n+\n+\t/* Find attr-names in the string.  */\n+\tchar *str;\n+\tchar *start, *end, *ptr;\n+\tchar tmpstr[256];\n+\tptr = &tmpstr[0];\n+\tend = stringbuf;\n+\twhile ((start = strchr (end, '<')) && (end  = strchr (start, '>')))\n+\t  {\n+\t    if ((end - start - 1 > 0)\n+\t\t&& (end - start - 1 < (int)sizeof (tmpstr)))\n+\t      {\n+\t\tstrncpy (tmpstr, start+1, end-start-1);\n+\t\ttmpstr[end-start-1] = 0;\n+\t\tend++;\n+\t      }\n+\t    else\n+\t      break;\n+\t    struct mapping *m\n+\t      = (struct mapping *) htab_find (substs.attrs, &ptr);\n+\t    if (m != 0)\n+\t      {\n+\t\t/* Here we should find linked subst-iter.  */\n+\t\tstr = find_subst_iter_by_attr (ptr);\n+\t\tif (str)\n+\t\t  m = (struct mapping *) htab_find (substs.iterators, &str);\n+\t\telse\n+\t\t  m = 0;\n+\t      }\n+\t    if (m != 0)\n+\t      record_iterator_use (m, return_rtx);\n+\t  }\n+\n+\tif (star_if_braced)\n+\t  XTMPL (return_rtx, idx) = stringbuf;\n+\telse\n+\t  XSTR (return_rtx, idx) = stringbuf;\n+      }\n+      break;\n+\n+    case 'w':\n+      {\n+\tHOST_WIDE_INT tmp_wide;\n+\tread_name (&name);\n+\tvalidate_const_int (name.string);\n+#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n+\ttmp_wide = atoi (name.string);\n+#else\n+#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG\n+\ttmp_wide = atol (name.string);\n+#else\n+\t/* Prefer atoll over atoq, since the former is in the ISO C99 standard.\n+\t   But prefer not to use our hand-rolled function above either.  */\n+#if HAVE_DECL_ATOLL || !defined(HAVE_ATOQ)\n+\ttmp_wide = atoll (name.string);\n+#else\n+\ttmp_wide = atoq (name.string);\n+#endif\n+#endif\n+#endif\n+\tXWINT (return_rtx, idx) = tmp_wide;\n+      }\n+      break;\n+\n+    case 'i':\n+    case 'n':\n+      /* Can be an iterator or an integer constant.  */\n+      read_name (&name);\n+      record_potential_iterator_use (&ints, &XINT (return_rtx, idx),\n+\t\t\t\t     name.string);\n+      break;\n+\n+    case 'r':\n+      read_name (&name);\n+      validate_const_int (name.string);\n+      set_regno_raw (return_rtx, atoi (name.string), 1);\n+      REG_ATTRS (return_rtx) = NULL;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* Read a nested rtx construct from the MD file and return it.  */\n \n static rtx"}]}