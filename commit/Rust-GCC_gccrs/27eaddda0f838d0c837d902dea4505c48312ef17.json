{"sha": "27eaddda0f838d0c837d902dea4505c48312ef17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjdlYWRkZGEwZjgzOGQwYzgzN2Q5MDJkZWE0NTA1YzQ4MzEyZWYxNw==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2017-04-27T10:58:25Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-27T10:58:25Z"}, "message": "exp_util.adb, [...]: Minor reformatting and code cleanups.\n\n2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_util.adb, a-cfdlli.adb, a-cfdlli.ads, exp_ch9.adb, g-dyntab.adb,\n\tsem_dim.adb, a-cfinve.adb, a-cfinve.ads, a-cofove.adb, a-cofove.ads:\n\tMinor reformatting and code cleanups.\n\nFrom-SVN: r247319", "tree": {"sha": "8bcab49cd835e8cc60abf1758dd12a86529e6d9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8bcab49cd835e8cc60abf1758dd12a86529e6d9a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27eaddda0f838d0c837d902dea4505c48312ef17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27eaddda0f838d0c837d902dea4505c48312ef17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27eaddda0f838d0c837d902dea4505c48312ef17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27eaddda0f838d0c837d902dea4505c48312ef17/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a"}], "stats": {"total": 1117, "additions": 544, "deletions": 573}, "files": [{"sha": "d8863a2f816c2fdf1bcb3fda72b65834e0dee5e1", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27eaddda0f838d0c837d902dea4505c48312ef17/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27eaddda0f838d0c837d902dea4505c48312ef17/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=27eaddda0f838d0c837d902dea4505c48312ef17", "patch": "@@ -1,3 +1,9 @@\n+2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_util.adb, a-cfdlli.adb, a-cfdlli.ads, exp_ch9.adb, g-dyntab.adb,\n+\tsem_dim.adb, a-cfinve.adb, a-cfinve.ads, a-cofove.adb, a-cofove.ads:\n+\tMinor reformatting and code cleanups.\n+\n 2017-04-27  Ed Schonberg  <schonberg@adacore.com>\n \n \t* freeze.adb (Build_Inherited_Condition_Pragmas): New procedure,"}, {"sha": "7e641339ecbd31abbf863a70380f81c4e1b61122", "filename": "gcc/ada/a-cfdlli.adb", "status": "modified", "additions": 27, "deletions": 57, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27eaddda0f838d0c837d902dea4505c48312ef17/gcc%2Fada%2Fa-cfdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27eaddda0f838d0c837d902dea4505c48312ef17/gcc%2Fada%2Fa-cfdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.adb?ref=27eaddda0f838d0c837d902dea4505c48312ef17", "patch": "@@ -39,9 +39,7 @@ is\n       New_Item  : Element_Type;\n       New_Node  : out Count_Type);\n \n-   procedure Free\n-     (Container : in out List;\n-      X         : Count_Type);\n+   procedure Free (Container : in out List; X : Count_Type);\n \n    procedure Insert_Internal\n      (Container : in out List;\n@@ -109,10 +107,7 @@ is\n    -- Append --\n    ------------\n \n-   procedure Append\n-     (Container : in out List;\n-      New_Item  : Element_Type)\n-   is\n+   procedure Append (Container : in out List; New_Item : Element_Type) is\n    begin\n       Insert (Container, No_Element, New_Item, 1);\n    end Append;\n@@ -164,14 +159,14 @@ is\n    begin\n       if Container.Length = 0 then\n          pragma Assert (Container.First = 0);\n-         pragma Assert (Container.Last = 0);\n+         pragma Assert (Container.Last  = 0);\n          return;\n       end if;\n \n       pragma Assert (Container.First >= 1);\n-      pragma Assert (Container.Last >= 1);\n+      pragma Assert (Container.Last  >= 1);\n       pragma Assert (N (Container.First).Prev = 0);\n-      pragma Assert (N (Container.Last).Next = 0);\n+      pragma Assert (N (Container.Last).Next  = 0);\n \n       while Container.Length > 1 loop\n          X := Container.First;\n@@ -275,9 +270,9 @@ is\n \n       pragma Assert (Vet (Container, Position), \"bad cursor in Delete\");\n       pragma Assert (Container.First >= 1);\n-      pragma Assert (Container.Last >= 1);\n+      pragma Assert (Container.Last  >= 1);\n       pragma Assert (N (Container.First).Prev = 0);\n-      pragma Assert (N (Container.Last).Next = 0);\n+      pragma Assert (N (Container.Last).Next  = 0);\n \n       if Position.Node = Container.First then\n          Delete_First (Container, Count);\n@@ -430,9 +425,7 @@ is\n          From := Container.First;\n       end if;\n \n-      if Position.Node /= 0 and then\n-        not Has_Element (Container, Position)\n-      then\n+      if Position.Node /= 0 and then not Has_Element (Container, Position) then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n@@ -496,33 +489,17 @@ is\n          Left      : M.Sequence;\n          Right     : M.Sequence) return Boolean\n       is\n-      begin\n-         for I in 1 .. M.Length (Container) loop\n-            declare\n-               Found : Boolean := False;\n-               J     : Count_Type := 0;\n-\n-            begin\n-               while not Found and J < M.Length (Left) loop\n-                  J := J + 1;\n-                  if Element (Container, I) = Element (Left, J) then\n-                     Found := True;\n-                  end if;\n-               end loop;\n-\n-               J := 0;\n+         Elem : Element_Type;\n \n-               while not Found and J < M.Length (Right) loop\n-                  J := J + 1;\n-                  if Element (Container, I) = Element (Right, J) then\n-                     Found := True;\n-                  end if;\n-               end loop;\n+      begin\n+         for Index in 1 .. M.Length (Container) loop\n+            Elem := Element (Container, Index);\n \n-               if not Found then\n-                  return False;\n-               end if;\n-            end;\n+            if not M.Contains (Left, 1, M.Length (Left), Elem)\n+               and then not M.Contains (Right, 1, M.Length (Right), Elem)\n+            then\n+               return False;\n+            end if;\n          end loop;\n \n          return True;\n@@ -579,8 +556,7 @@ is\n          end if;\n \n          for I in 1 .. L loop\n-            if Element (Left, I) /= Element (Right, L - I + 1)\n-            then\n+            if Element (Left, I) /= Element (Right, L - I + 1) then\n                return False;\n             end if;\n          end loop;\n@@ -638,7 +614,7 @@ is\n       end Model;\n \n       -----------------------\n-      -- Mapping_preserved --\n+      -- Mapping_Preserved --\n       -----------------------\n \n       function Mapping_Preserved\n@@ -748,7 +724,8 @@ is\n \n          for C of Right loop\n             if not P.Has_Key (Left, C)\n-              or else (C /= X and C /= Y\n+              or else (C /= X\n+                        and C /= Y\n                         and P.Get (Left, C) /= P.Get (Right, C))\n             then\n                return False;\n@@ -933,8 +910,7 @@ is\n \n       begin\n          if Target'Address = Source'Address then\n-            raise Program_Error with\n-              \"Target and Source denote same container\";\n+            raise Program_Error with \"Target and Source denote same container\";\n          end if;\n \n          LI := First (Target);\n@@ -1540,16 +1516,15 @@ is\n \n    begin\n       if Target'Address = Source'Address then\n-         raise Program_Error with\n-           \"Target and Source denote same container\";\n+         raise Program_Error with \"Target and Source denote same container\";\n       end if;\n \n       if Before.Node /= 0 then\n          pragma Assert (Vet (Target, Before), \"bad cursor in Splice\");\n       end if;\n \n       pragma Assert (SN (Source.First).Prev = 0);\n-      pragma Assert (SN (Source.Last).Next = 0);\n+      pragma Assert (SN (Source.Last).Next  = 0);\n \n       if Target.Length > Count_Type'Base'Last - Source.Length then\n          raise Constraint_Error with \"new length exceeds maximum\";\n@@ -1576,8 +1551,7 @@ is\n \n    begin\n       if Target'Address = Source'Address then\n-         raise Program_Error with\n-           \"Target and Source denote same container\";\n+         raise Program_Error with \"Target and Source denote same container\";\n       end if;\n \n       if Position.Node = 0 then\n@@ -1820,15 +1794,11 @@ is\n          return False;\n       end if;\n \n-      if N (Position.Node).Prev = 0\n-        and then Position.Node /= L.First\n-      then\n+      if N (Position.Node).Prev = 0 and then Position.Node /= L.First then\n          return False;\n       end if;\n \n-      if N (Position.Node).Next = 0\n-        and then Position.Node /= L.Last\n-      then\n+      if N (Position.Node).Next = 0 and then Position.Node /= L.Last then\n          return False;\n       end if;\n "}, {"sha": "1a83b609499f704a10062153bb80ea9ba471a5b5", "filename": "gcc/ada/a-cfdlli.ads", "status": "modified", "additions": 75, "deletions": 61, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27eaddda0f838d0c837d902dea4505c48312ef17/gcc%2Fada%2Fa-cfdlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27eaddda0f838d0c837d902dea4505c48312ef17/gcc%2Fada%2Fa-cfdlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.ads?ref=27eaddda0f838d0c837d902dea4505c48312ef17", "patch": "@@ -93,8 +93,8 @@ is\n             (for all I in 1 .. M.Length (Container) =>\n               (for some J in 1 .. M.Length (Left) =>\n                 Element (Container, I) = Element (Left, J))\n-              or (for some J in 1 .. M.Length (Right) =>\n-                    Element (Container, I) = Element (Right, J)));\n+                  or (for some J in 1 .. M.Length (Right) =>\n+                       Element (Container, I) = Element (Right, J)));\n       pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_In_Union);\n \n       function M_Elements_Included\n@@ -126,11 +126,11 @@ is\n           M_Elements_Reversed'Result =\n             (M.Length (Left) = M.Length (Right)\n               and (for all I in 1 .. M.Length (Left) =>\n-                     Element (Left, I) =\n-                     Element (Right, M.Length (Left) - I + 1))\n+                    Element (Left, I) =\n+                      Element (Right, M.Length (Left) - I + 1))\n               and (for all I in 1 .. M.Length (Left) =>\n-                     Element (Right, I) =\n-                     Element (Left, M.Length (Left) - I + 1)));\n+                    Element (Right, I) =\n+                      Element (Left, M.Length (Left) - I + 1)));\n       pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Reversed);\n \n       function M_Elements_Swapped\n@@ -482,11 +482,11 @@ is\n             --  Container contains Count times New_Item at the end\n \n             and (if Count > 0 then\n-                   M.Constant_Range\n-                     (Container => Model (Container),\n-                      Fst       => Length (Container)'Old + 1,\n-                      Lst       => Length (Container),\n-                      Item      => New_Item))\n+                    M.Constant_Range\n+                      (Container => Model (Container),\n+                       Fst       => Length (Container)'Old + 1,\n+                       Lst       => Length (Container),\n+                       Item      => New_Item))\n \n             --  Container contains Count times New_Item at the end\n \n@@ -611,9 +611,9 @@ is\n      Post           => Length (Container) = Length (Container)'Old + Count,\n      Contract_Cases =>\n        (Count = 0 =>\n-          Position = Before\n-            and Model (Container) = Model (Container)'Old\n-            and Positions (Container) = Positions (Container)'Old,\n+         Position = Before\n+           and Model (Container) = Model (Container)'Old\n+           and Positions (Container) = Positions (Container)'Old,\n \n         others =>\n \n@@ -772,11 +772,11 @@ is\n          --  Container contains Count times New_Item at the end\n \n          and (if Count > 0 then\n-                M.Constant_Range\n-                  (Container => Model (Container),\n-                    Fst       => Length (Container)'Old + 1,\n-                    Lst       => Length (Container),\n-                    Item      => New_Item))\n+                 M.Constant_Range\n+                   (Container => Model (Container),\n+                     Fst       => Length (Container)'Old + 1,\n+                     Lst       => Length (Container),\n+                     Item      => New_Item))\n \n          --  Count cursors have been inserted at the end of Container\n \n@@ -947,9 +947,9 @@ is\n          --  Other cursors are still valid\n \n          and P.Keys_Included_Except\n-                (Left    => Positions (Container)'Old,\n-                 Right   => Positions (Container)'Old,\n-                 New_Key => Last (Container)'Old)\n+               (Left    => Positions (Container)'Old,\n+                Right   => Positions (Container)'Old,\n+                New_Key => Last (Container)'Old)\n \n          --  The positions of other cursors are preserved\n \n@@ -992,7 +992,8 @@ is\n      Pre    => Has_Element (Container, I) and then Has_Element (Container, J),\n      Post   =>\n        M_Elements_Swapped\n-         (Model (Container)'Old, Model (Container),\n+         (Model (Container)'Old,\n+          Model (Container),\n           X => P.Get (Positions (Container)'Old, I),\n           Y => P.Get (Positions (Container)'Old, J))\n \n@@ -1001,13 +1002,14 @@ is\n    procedure Swap_Links\n      (Container : in out List;\n       I         : Cursor;\n-      J        : Cursor)\n+      J         : Cursor)\n    with\n      Global => null,\n      Pre    => Has_Element (Container, I) and then Has_Element (Container, J),\n      Post   =>\n        M_Elements_Swapped\n-         (Model (Container'Old), Model (Container),\n+         (Model (Container'Old),\n+          Model (Container),\n           X => P.Get (Positions (Container)'Old, I),\n           Y => P.Get (Positions (Container)'Old, J))\n          and P_Positions_Swapped\n@@ -1088,7 +1090,8 @@ is\n             and M_Elements_Included\n                   (Left   => Model (Target),\n                    L_Fst  => P.Get (Positions (Target)'Old, Before),\n-                   L_Lst  => P.Get (Positions (Target)'Old, Before) - 1 +\n+                   L_Lst  =>\n+                     P.Get (Positions (Target)'Old, Before) - 1 +\n                        Length (Source)'Old,\n                    Right  => Model (Source)'Old,\n                    R_Lst  => Length (Source)'Old)\n@@ -1179,9 +1182,10 @@ is\n \n          --  The element located at Position in Source is moved to Target\n \n-         and Element (Model (Target), P.Get (Positions (Target), Position)) =\n-               Element (Model (Source)'Old,\n-                        P.Get (Positions (Source)'Old, Position'Old))\n+         and Element (Model (Target),\n+                      P.Get (Positions (Target), Position)) =\n+             Element (Model (Source)'Old,\n+                      P.Get (Positions (Source)'Old, Position'Old))\n \n          --  A new cursor has been inserted at position Position in Target\n \n@@ -1227,9 +1231,10 @@ is\n           --  The last element of Container is the one that was previously at\n           --  Position.\n \n-          and Element (Model (Container), Length (Container)) =\n-                Element (Model (Container)'Old,\n-                         P.Get (Positions (Container)'Old, Position))\n+          and Element (Model (Container),\n+                       Length (Container)) =\n+              Element (Model (Container)'Old,\n+                       P.Get (Positions (Container)'Old, Position))\n \n           --  Cursors from Container continue designating the same elements\n \n@@ -1285,10 +1290,12 @@ is\n \n             --  The element previously at Position is now before Before\n \n-            and Element (Model (Container),\n-                         P.Get (Positions (Container)'Old, Before)) =\n-                  Element (Model (Container)'Old,\n-                           P.Get (Positions (Container)'Old, Position))\n+            and Element\n+                  (Model (Container),\n+                   P.Get (Positions (Container)'Old, Before)) =\n+                Element\n+                  (Model (Container)'Old,\n+                   P.Get (Positions (Container)'Old, Position))\n \n             --  Cursors from Container continue designating the same elements\n \n@@ -1422,8 +1429,9 @@ is\n \n             --  The element designated by the result of Find is Item\n \n-            and Element (Model (Container),\n-                         P.Get (Positions (Container), Find'Result)) = Item\n+            and Element\n+                  (Model (Container),\n+                   P.Get (Positions (Container), Find'Result)) = Item\n \n             --  The result of Find is located after Position\n \n@@ -1476,9 +1484,9 @@ is\n \n             --  The element designated by the result of Find is Item\n \n-            and Element (Model (Container),\n-                         P.Get (Positions (Container),\n-                                Reverse_Find'Result)) = Item\n+            and Element\n+                  (Model (Container),\n+                   P.Get (Positions (Container), Reverse_Find'Result)) = Item\n \n             --  The result of Find is located before Position\n \n@@ -1544,14 +1552,16 @@ is\n         Post   =>\n           Length (Container) = Length (Container)'Old\n             and M_Elements_Sorted (Model (Container))\n-            and M_Elements_Included (Left  => Model (Container)'Old,\n-                                     L_Lst => Length (Container),\n-                                     Right => Model (Container),\n-                                     R_Lst => Length (Container))\n-            and M_Elements_Included (Left  => Model (Container),\n-                                     L_Lst => Length (Container),\n-                                     Right => Model (Container)'Old,\n-                                     R_Lst => Length (Container));\n+            and M_Elements_Included\n+                  (Left  => Model (Container)'Old,\n+                   L_Lst => Length (Container),\n+                   Right => Model (Container),\n+                   R_Lst => Length (Container))\n+            and M_Elements_Included\n+                  (Left  => Model (Container),\n+                   L_Lst => Length (Container),\n+                   Right => Model (Container)'Old,\n+                   R_Lst => Length (Container));\n \n       procedure Merge (Target : in out List; Source : in out List) with\n       --  Target and Source should not be aliased\n@@ -1562,18 +1572,22 @@ is\n             and Length (Source) = 0\n             and (if M_Elements_Sorted (Model (Target)'Old)\n                    and M_Elements_Sorted (Model (Source)'Old)\n-                 then M_Elements_Sorted (Model (Target)))\n-            and M_Elements_Included (Left  => Model (Target)'Old,\n-                                     L_Lst => Length (Target)'Old,\n-                                     Right => Model (Target),\n-                                     R_Lst => Length (Target))\n-            and M_Elements_Included (Left  => Model (Source)'Old,\n-                                     L_Lst => Length (Source)'Old,\n-                                     Right => Model (Target),\n-                                     R_Lst => Length (Target))\n-            and M_Elements_In_Union (Model (Target),\n-                                     Model (Source)'Old,\n-                                     Model (Target)'Old);\n+                 then\n+                    M_Elements_Sorted (Model (Target)))\n+            and M_Elements_Included\n+                  (Left  => Model (Target)'Old,\n+                   L_Lst => Length (Target)'Old,\n+                   Right => Model (Target),\n+                   R_Lst => Length (Target))\n+            and M_Elements_Included\n+                  (Left  => Model (Source)'Old,\n+                   L_Lst => Length (Source)'Old,\n+                   Right => Model (Target),\n+                   R_Lst => Length (Target))\n+            and M_Elements_In_Union\n+                  (Model (Target),\n+                   Model (Source)'Old,\n+                   Model (Target)'Old);\n    end Generic_Sorting;\n \n private"}, {"sha": "e1a979d2edff1fdc9fa559087556f719f5ecb480", "filename": "gcc/ada/a-cfinve.adb", "status": "modified", "additions": 95, "deletions": 100, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27eaddda0f838d0c837d902dea4505c48312ef17/gcc%2Fada%2Fa-cfinve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27eaddda0f838d0c837d902dea4505c48312ef17/gcc%2Fada%2Fa-cfinve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfinve.adb?ref=27eaddda0f838d0c837d902dea4505c48312ef17", "patch": "@@ -33,7 +33,6 @@ with System; use type System.Address;\n package body Ada.Containers.Formal_Indefinite_Vectors with\n   SPARK_Mode => Off\n is\n-\n    function H (New_Item : Element_Type) return Holder renames To_Holder;\n    function E (Container : Holder) return Element_Type renames Get;\n \n@@ -44,12 +43,12 @@ is\n    type Int is range System.Min_Int .. System.Max_Int;\n \n    procedure Free is\n-      new Ada.Unchecked_Deallocation (Elements_Array, Elements_Array_Ptr);\n+     new Ada.Unchecked_Deallocation (Elements_Array, Elements_Array_Ptr);\n \n    type Maximal_Array_Ptr is access all Elements_Array (Array_Index)\n      with Storage_Size => 0;\n    type Maximal_Array_Ptr_Const is access constant Elements_Array (Array_Index)\n-       with Storage_Size => 0;\n+     with Storage_Size => 0;\n \n    function Elems (Container : in out Vector) return Maximal_Array_Ptr;\n    function Elemsc\n@@ -81,7 +80,7 @@ is\n    -- \"=\" --\n    ---------\n \n-   function \"=\" (Left, Right : Vector) return Boolean is\n+   function \"=\" (Left : Vector; Right : Vector) return Boolean is\n    begin\n       if Left'Address = Right'Address then\n          return True;\n@@ -117,10 +116,7 @@ is\n       Insert (Container, Container.Last + 1, New_Item);\n    end Append;\n \n-   procedure Append\n-     (Container : in out Vector;\n-      New_Item  : Element_Type)\n-   is\n+   procedure Append (Container : in out Vector; New_Item : Element_Type) is\n    begin\n       Append (Container, New_Item, 1);\n    end Append;\n@@ -168,8 +164,11 @@ is\n \n    function Capacity (Container : Vector) return Capacity_Range is\n    begin\n-      return (if Bounded then Container.Capacity\n-              else Capacity_Range'Last);\n+      return\n+        (if Bounded then\n+            Container.Capacity\n+         else\n+            Capacity_Range'Last);\n    end Capacity;\n \n    -----------\n@@ -229,19 +228,18 @@ is\n \n    function Current_Capacity (Container : Vector) return Capacity_Range is\n    begin\n-      return (if Container.Elements_Ptr = null\n-              then Container.Elements'Length\n-              else Container.Elements_Ptr.all'Length);\n+      return\n+        (if Container.Elements_Ptr = null then\n+            Container.Elements'Length\n+         else\n+            Container.Elements_Ptr.all'Length);\n    end Current_Capacity;\n \n    ------------\n    -- Delete --\n    ------------\n \n-   procedure Delete\n-     (Container : in out Vector;\n-      Index     : Extended_Index)\n-   is\n+   procedure Delete (Container : in out Vector; Index : Extended_Index) is\n    begin\n       Delete (Container, Index, 1);\n    end Delete;\n@@ -339,6 +337,7 @@ is\n       declare\n          EA  : Maximal_Array_Ptr renames Elems (Container);\n          Idx : constant Count_Type := EA'First + Off;\n+\n       begin\n          EA (Idx .. Old_Len - Count) := EA (Idx + Count .. Old_Len);\n          Container.Last := New_Last;\n@@ -349,17 +348,12 @@ is\n    -- Delete_First --\n    ------------------\n \n-   procedure Delete_First\n-     (Container : in out Vector)\n-   is\n+   procedure Delete_First (Container : in out Vector) is\n    begin\n       Delete_First (Container, 1);\n    end Delete_First;\n \n-   procedure Delete_First\n-     (Container : in out Vector;\n-      Count     : Count_Type)\n-   is\n+   procedure Delete_First (Container : in out Vector; Count : Count_Type) is\n    begin\n       if Count = 0 then\n          return;\n@@ -377,17 +371,12 @@ is\n    -- Delete_Last --\n    -----------------\n \n-   procedure Delete_Last\n-     (Container : in out Vector)\n-   is\n+   procedure Delete_Last (Container : in out Vector) is\n    begin\n       Delete_Last (Container, 1);\n    end Delete_Last;\n \n-   procedure Delete_Last\n-     (Container : in out Vector;\n-      Count     : Count_Type)\n-   is\n+   procedure Delete_Last (Container : in out Vector; Count : Count_Type) is\n    begin\n       if Count = 0 then\n          return;\n@@ -431,6 +420,7 @@ is\n       declare\n          II : constant Int'Base := Int (Index) - Int (No_Index);\n          I  : constant Capacity_Range := Capacity_Range (II);\n+\n       begin\n          return Get_Element (Container, I);\n       end;\n@@ -442,17 +432,20 @@ is\n \n    function Elems (Container : in out Vector) return Maximal_Array_Ptr is\n    begin\n-      return (if Container.Elements_Ptr = null\n-              then Container.Elements'Unrestricted_Access\n-              else Container.Elements_Ptr.all'Unrestricted_Access);\n+      return\n+        (if Container.Elements_Ptr = null then\n+            Container.Elements'Unrestricted_Access\n+         else\n+            Container.Elements_Ptr.all'Unrestricted_Access);\n    end Elems;\n \n-   function Elemsc\n-     (Container : Vector) return Maximal_Array_Ptr_Const is\n+   function Elemsc (Container : Vector) return Maximal_Array_Ptr_Const is\n    begin\n-      return (if Container.Elements_Ptr = null\n-              then Container.Elements'Unrestricted_Access\n-              else Container.Elements_Ptr.all'Unrestricted_Access);\n+      return\n+        (if Container.Elements_Ptr = null then\n+            Container.Elements'Unrestricted_Access\n+         else\n+            Container.Elements_Ptr.all'Unrestricted_Access);\n    end Elemsc;\n \n    ----------------\n@@ -519,29 +512,15 @@ is\n          Right     : M.Sequence) return Boolean\n       is\n       begin\n-         for I in Index_Type'First .. M.Last (Container) loop\n+         for Index in Index_Type'First .. M.Last (Container) loop\n             declare\n-               Found : Boolean := False;\n-               J     : Extended_Index := Extended_Index'First;\n-\n+               Elem : constant Element_Type := Element (Container, Index);\n             begin\n-               while not Found and J < M.Last (Left) loop\n-                  J := J + 1;\n-                  if Element (Container, I) = Element (Left, J) then\n-                     Found := True;\n-                  end if;\n-               end loop;\n-\n-               J := Extended_Index'First;\n-\n-               while not Found and J < M.Last (Right) loop\n-                  J := J + 1;\n-                  if Element (Container, I) = Element (Right, J) then\n-                     Found := True;\n-                  end if;\n-               end loop;\n-\n-               if not Found then\n+               if not M.Contains (Left, Index_Type'First, M.Last (Left), Elem)\n+                 and then\n+                   not M.Contains\n+                     (Right, Index_Type'First, M.Last (Right), Elem)\n+               then\n                   return False;\n                end if;\n             end;\n@@ -589,8 +568,12 @@ is\n       -- M_Elements_Reversed --\n       -------------------------\n \n-      function M_Elements_Reversed (Left, Right : M.Sequence) return Boolean is\n+      function M_Elements_Reversed\n+        (Left  : M.Sequence;\n+         Right : M.Sequence) return Boolean\n+      is\n          L : constant Index_Type := M.Last (Left);\n+\n       begin\n          if L /= M.Last (Right) then\n             return False;\n@@ -613,7 +596,8 @@ is\n       function M_Elements_Swapped\n         (Left  : M.Sequence;\n          Right : M.Sequence;\n-         X, Y  : Index_Type) return Boolean\n+         X     : Index_Type;\n+         Y     : Index_Type) return Boolean\n       is\n       begin\n          if M.Length (Left) /= M.Length (Right)\n@@ -640,10 +624,12 @@ is\n \n       function Model (Container : Vector) return M.Sequence is\n          R : M.Sequence;\n+\n       begin\n          for Position in 1 .. Length (Container) loop\n             R := M.Add (R, E (Elemsc (Container) (Position)));\n          end loop;\n+\n          return R;\n       end Model;\n \n@@ -661,11 +647,10 @@ is\n \n       function Is_Sorted (Container : Vector) return Boolean is\n          L : constant Capacity_Range := Length (Container);\n+\n       begin\n          for J in 1 .. L - 1 loop\n-            if Get_Element (Container, J + 1) <\n-               Get_Element (Container, J)\n-            then\n+            if Get_Element (Container, J + 1) < Get_Element (Container, J) then\n                return False;\n             end if;\n          end loop;\n@@ -708,19 +693,19 @@ is\n       -- Sort --\n       ----------\n \n-      procedure Sort (Container : in out Vector)\n-      is\n+      procedure Sort (Container : in out Vector) is\n          function \"<\" (Left : Holder; Right : Holder) return Boolean is\n            (E (Left) < E (Right));\n \n          procedure Sort is\n            new Generic_Array_Sort\n-             (Index_Type   => Array_Index,\n-              Element_Type => Holder,\n-              Array_Type   => Elements_Array,\n-              \"<\"          => \"<\");\n+                 (Index_Type   => Array_Index,\n+                  Element_Type => Holder,\n+                  Array_Type   => Elements_Array,\n+                  \"<\"          => \"<\");\n \n          Len : constant Capacity_Range := Length (Container);\n+\n       begin\n          if Container.Last <= Index_Type'First then\n             return;\n@@ -733,13 +718,13 @@ is\n       -- Merge --\n       -----------\n \n-      procedure Merge (Target, Source : in out Vector) is\n-         I, J : Count_Type;\n+      procedure Merge (Target : in out Vector; Source : in out Vector) is\n+         I : Count_Type;\n+         J : Count_Type;\n \n       begin\n          if Target'Address = Source'Address then\n-            raise Program_Error with\n-              \"Target and Source denote same container\";\n+            raise Program_Error with \"Target and Source denote same container\";\n          end if;\n \n          if Length (Source) = 0 then\n@@ -755,15 +740,16 @@ is\n \n          declare\n             New_Length : constant Count_Type := I + Length (Source);\n+\n          begin\n-            if not Bounded and then\n-              Current_Capacity (Target) < Capacity_Range (New_Length)\n+            if not Bounded\n+              and then Current_Capacity (Target) < Capacity_Range (New_Length)\n             then\n                Reserve_Capacity\n                  (Target,\n                   Capacity_Range'Max\n                     (Current_Capacity (Target) * Growth_Factor,\n-                    Capacity_Range (New_Length)));\n+                     Capacity_Range (New_Length)));\n             end if;\n \n             if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n@@ -778,6 +764,7 @@ is\n          declare\n             TA : Maximal_Array_Ptr renames Elems (Target);\n             SA : Maximal_Array_Ptr renames Elems (Source);\n+\n          begin\n             J := Length (Target);\n             while Length (Source) /= 0 loop\n@@ -820,7 +807,9 @@ is\n    -----------------\n \n    function Has_Element\n-     (Container : Vector; Position : Extended_Index) return Boolean is\n+     (Container : Vector;\n+      Position  : Extended_Index) return Boolean\n+   is\n    begin\n       return Position in First_Index (Container) .. Last_Index (Container);\n    end Has_Element;\n@@ -997,8 +986,7 @@ is\n             --  worry about if No_Index were less than 0, but that case is\n             --  handled above).\n \n-            if Index_Type'Last - No_Index >=\n-                 Count_Type'Pos (Count_Type'Last)\n+            if Index_Type'Last - No_Index >= Count_Type'Pos (Count_Type'Last)\n             then\n                --  We have determined that range of Index_Type has at least as\n                --  many values as in Count_Type, so Count_Type'Last is the\n@@ -1064,17 +1052,18 @@ is\n \n       --  Increase the capacity of container if needed\n \n-      if not Bounded and then\n-        Current_Capacity (Container) < Capacity_Range (New_Length)\n+      if not Bounded\n+        and then Current_Capacity (Container) < Capacity_Range (New_Length)\n       then\n          Reserve_Capacity\n            (Container,\n             Capacity_Range'Max (Current_Capacity (Container) * Growth_Factor,\n-              Capacity_Range (New_Length)));\n+                                Capacity_Range (New_Length)));\n       end if;\n \n       declare\n          EA : Maximal_Array_Ptr renames Elems (Container);\n+\n       begin\n          if Before <= Container.Last then\n \n@@ -1134,6 +1123,7 @@ is\n       L : constant Int := Int (Container.Last);\n       F : constant Int := Int (Index_Type'First);\n       N : constant Int'Base := L - F + 1;\n+\n    begin\n       return Capacity_Range (N);\n    end Length;\n@@ -1142,11 +1132,9 @@ is\n    -- Move --\n    ----------\n \n-   procedure Move\n-     (Target : in out Vector;\n-      Source : in out Vector)\n-   is\n+   procedure Move (Target : in out Vector; Source : in out Vector) is\n       LS : constant Capacity_Range := Length (Source);\n+\n    begin\n       if Target'Address = Source'Address then\n          return;\n@@ -1170,10 +1158,7 @@ is\n       Insert (Container, Index_Type'First, New_Item);\n    end Prepend;\n \n-   procedure Prepend\n-     (Container : in out Vector;\n-      New_Item  : Element_Type)\n-   is\n+   procedure Prepend (Container : in out Vector; New_Item : Element_Type) is\n    begin\n       Prepend (Container, New_Item, 1);\n    end Prepend;\n@@ -1204,6 +1189,7 @@ is\n       declare\n          II : constant Int'Base := Int (Index) - Int (No_Index);\n          I  : constant Capacity_Range := Capacity_Range (II);\n+\n       begin\n          Elems (Container) (I) := H (New_Item);\n       end;\n@@ -1222,12 +1208,14 @@ is\n          if Capacity > Container.Capacity then\n             raise Constraint_Error with \"Capacity is out of range\";\n          end if;\n+\n       else\n          if Capacity > Current_Capacity (Container) then\n             declare\n                New_Elements : constant Elements_Array_Ptr :=\n                                 new Elements_Array (1 .. Capacity);\n                L            : constant Capacity_Range := Length (Container);\n+\n             begin\n                New_Elements (1 .. L) := Elemsc (Container) (1 .. L);\n                Free (Container.Elements_Ptr);\n@@ -1248,16 +1236,18 @@ is\n       end if;\n \n       declare\n-         I, J : Capacity_Range;\n-         E    : Elements_Array renames\n-                  Elems (Container) (1 .. Length (Container));\n+         I : Capacity_Range;\n+         J : Capacity_Range;\n+         E : Elements_Array renames\n+               Elems (Container) (1 .. Length (Container));\n \n       begin\n          I := 1;\n          J := Length (Container);\n          while I < J loop\n             declare\n                EI : constant Holder := E (I);\n+\n             begin\n                E (I) := E (J);\n                E (J) := EI;\n@@ -1304,7 +1294,11 @@ is\n    -- Swap --\n    ----------\n \n-   procedure Swap (Container : in out Vector; I, J : Index_Type) is\n+   procedure Swap\n+     (Container : in out Vector;\n+      I         : Index_Type;\n+      J         : Index_Type)\n+   is\n    begin\n       if I > Container.Last then\n          raise Constraint_Error with \"I index is out of range\";\n@@ -1391,10 +1385,11 @@ is\n \n          Last := Index_Type (Last_As_Int);\n \n-         return (Capacity     => Length,\n-                 Last         => Last,\n-                 Elements_Ptr => <>,\n-                 Elements     => (others => H (New_Item)));\n+         return\n+           (Capacity     => Length,\n+            Last         => Last,\n+            Elements_Ptr => <>,\n+            Elements     => (others => H (New_Item)));\n       end;\n    end To_Vector;\n "}, {"sha": "9836c5ff960e3f8092bb6a7dd2cc7927a57241ef", "filename": "gcc/ada/a-cfinve.ads", "status": "modified", "additions": 110, "deletions": 111, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27eaddda0f838d0c837d902dea4505c48312ef17/gcc%2Fada%2Fa-cfinve.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27eaddda0f838d0c837d902dea4505c48312ef17/gcc%2Fada%2Fa-cfinve.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfinve.ads?ref=27eaddda0f838d0c837d902dea4505c48312ef17", "patch": "@@ -124,8 +124,8 @@ is\n             (for all I in Index_Type'First .. M.Last (Container) =>\n               (for some J in Index_Type'First .. M.Last (Left) =>\n                 Element (Container, I) = Element (Left, J))\n-              or (for some J in Index_Type'First .. M.Last (Right) =>\n-                    Element (Container, I) = Element (Right, J)));\n+                  or (for some J in Index_Type'First .. M.Last (Right) =>\n+                       Element (Container, I) = Element (Right, J)));\n       pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_In_Union);\n \n       function M_Elements_Included\n@@ -157,11 +157,11 @@ is\n           M_Elements_Reversed'Result =\n             (M.Length (Left) = M.Length (Right)\n               and (for all I in Index_Type'First .. M.Last (Left) =>\n-                     Element (Left, I) =\n-                     Element (Right, M.Last (Left) - I + 1))\n+                    Element (Left, I) =\n+                      Element (Right, M.Last (Left) - I + 1))\n               and (for all I in Index_Type'First .. M.Last (Right) =>\n-                     Element (Right, I) =\n-                     Element (Left, M.Last (Left) - I + 1)));\n+                    Element (Right, I) =\n+                      Element (Left, M.Last (Left) - I + 1)));\n       pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Reversed);\n \n       function M_Elements_Swapped\n@@ -195,6 +195,7 @@ is\n          I : Index_Type) return Element_Type renames M.Get;\n       --  To improve readability of contracts, we rename the function used to\n       --  access an element in the model to Element.\n+\n    end Formal_Model;\n    use Formal_Model;\n \n@@ -213,16 +214,20 @@ is\n      Global => null,\n      Post   =>\n        Formal_Indefinite_Vectors.Length (To_Vector'Result) = Length\n-         and M.Constant_Range (Container => Model (To_Vector'Result),\n-                               Fst       => Index_Type'First,\n-                               Lst       => Last_Index (To_Vector'Result),\n-                               Item      => New_Item);\n+         and M.Constant_Range\n+               (Container => Model (To_Vector'Result),\n+                Fst       => Index_Type'First,\n+                Lst       => Last_Index (To_Vector'Result),\n+                Item      => New_Item);\n \n    function Capacity (Container : Vector) return Capacity_Range with\n      Global => null,\n      Post   =>\n-       Capacity'Result = (if Bounded then Container.Capacity\n-                          else Capacity_Range'Last);\n+       Capacity'Result =\n+         (if Bounded then\n+             Container.Capacity\n+          else\n+             Capacity_Range'Last);\n    pragma Annotate (GNATprove, Inline_For_Proof, Capacity);\n \n    procedure Reserve_Capacity\n@@ -257,8 +262,10 @@ is\n      Pre    => (if Bounded then (Capacity = 0 or Length (Source) <= Capacity)),\n      Post   =>\n        Model (Copy'Result) = Model (Source)\n-         and (if Capacity = 0 then Copy'Result.Capacity = Length (Source)\n-              else Copy'Result.Capacity = Capacity);\n+         and (if Capacity = 0 then\n+                 Copy'Result.Capacity = Length (Source)\n+              else\n+                 Copy'Result.Capacity = Capacity);\n \n    procedure Move (Target : in out Vector; Source : in out Vector)\n    with\n@@ -305,7 +312,7 @@ is\n      Pre    =>\n        Length (Container) <= Capacity (Container) - Length (New_Item)\n          and (Before in Index_Type'First .. Last_Index (Container)\n-              or (Before /= No_Index\n+               or (Before /= No_Index\n                     and then Before - 1 = Last_Index (Container))),\n      Post   =>\n        Length (Container) = Length (Container)'Old + Length (New_Item)\n@@ -321,12 +328,12 @@ is\n          --  Elements of New_Item are inserted at position Before\n \n          and (if Length (New_Item) > 0 then\n-                M.Range_Shifted\n-                  (Left   => Model (New_Item),\n-                    Right  => Model (Container),\n-                    Fst    => Index_Type'First,\n-                    Lst    => Last_Index (New_Item),\n-                    Offset => Count_Type (Before - Index_Type'First)))\n+                 M.Range_Shifted\n+                   (Left   => Model (New_Item),\n+                     Right  => Model (Container),\n+                     Fst    => Index_Type'First,\n+                     Lst    => Last_Index (New_Item),\n+                     Offset => Count_Type (Before - Index_Type'First)))\n \n          --  Elements located after Before in Container are shifted\n \n@@ -380,7 +387,7 @@ is\n      Pre    =>\n        Length (Container) <= Capacity (Container) - Count\n          and (Before in Index_Type'First .. Last_Index (Container)\n-              or (Before /= No_Index\n+               or (Before /= No_Index\n                     and then Before - 1 = Last_Index (Container))),\n      Post   =>\n        Length (Container) = Length (Container)'Old + Count\n@@ -396,11 +403,11 @@ is\n          --  New_Item is inserted Count times at position Before\n \n          and (if Count > 0 then\n-                M.Constant_Range\n-                  (Container => Model (Container),\n-                    Fst       => Before,\n-                    Lst       => Before + Index_Type'Base (Count - 1),\n-                    Item      => New_Item))\n+                 M.Constant_Range\n+                   (Container => Model (Container),\n+                     Fst       => Before,\n+                     Lst       => Before + Index_Type'Base (Count - 1),\n+                     Item      => New_Item))\n \n          --  Elements located after Before in Container are shifted\n \n@@ -411,10 +418,7 @@ is\n                 Lst    => Last_Index (Container)'Old,\n                 Offset => Count);\n \n-   procedure Prepend\n-     (Container : in out Vector;\n-      New_Item  : Vector)\n-   with\n+   procedure Prepend (Container : in out Vector; New_Item : Vector) with\n      Global => null,\n      Pre    => Length (Container) <= Capacity (Container) - Length (New_Item),\n      Post   =>\n@@ -437,10 +441,7 @@ is\n                 Lst    => Last_Index (Container)'Old,\n                 Offset => Length (New_Item));\n \n-   procedure Prepend\n-     (Container : in out Vector;\n-      New_Item  : Element_Type)\n-   with\n+   procedure Prepend (Container : in out Vector; New_Item : Element_Type) with\n      Global => null,\n      Pre    => Length (Container) < Capacity (Container),\n      Post   =>\n@@ -486,10 +487,7 @@ is\n                 Lst    => Last_Index (Container)'Old,\n                 Offset => Count);\n \n-   procedure Append\n-     (Container : in out Vector;\n-      New_Item  : Vector)\n-   with\n+   procedure Append (Container : in out Vector; New_Item : Vector) with\n      Global         => null,\n      Pre            =>\n        Length (Container) <= Capacity (Container) - Length (New_Item),\n@@ -503,19 +501,16 @@ is\n          --  Elements of New_Item are inserted at the end of Container\n \n          and (if Length (New_Item) > 0 then\n-                M.Range_Shifted\n-                 (Left   => Model (New_Item),\n-                   Right  => Model (Container),\n-                   Fst    => Index_Type'First,\n-                   Lst    => Last_Index (New_Item),\n-                   Offset =>\n-                     Count_Type\n-                       (Last_Index (Container)'Old - Index_Type'First + 1)));\n+                 M.Range_Shifted\n+                   (Left   => Model (New_Item),\n+                    Right  => Model (Container),\n+                    Fst    => Index_Type'First,\n+                    Lst    => Last_Index (New_Item),\n+                    Offset =>\n+                      Count_Type\n+                        (Last_Index (Container)'Old - Index_Type'First + 1)));\n \n-   procedure Append\n-     (Container : in out Vector;\n-      New_Item  : Element_Type)\n-   with\n+   procedure Append (Container : in out Vector; New_Item : Element_Type) with\n      Global => null,\n      Pre    => Length (Container) < Capacity (Container),\n      Post   =>\n@@ -547,17 +542,14 @@ is\n          --  New_Item is inserted Count times at the end of Container\n \n          and (if Count > 0 then\n-                M.Constant_Range\n-                  (Container => Model (Container),\n-                    Fst       => Last_Index (Container)'Old + 1,\n-                    Lst       =>\n-                      Last_Index (Container)'Old + Index_Type'Base (Count),\n-                    Item      => New_Item));\n+                 M.Constant_Range\n+                   (Container => Model (Container),\n+                     Fst       => Last_Index (Container)'Old + 1,\n+                     Lst       =>\n+                       Last_Index (Container)'Old + Index_Type'Base (Count),\n+                     Item      => New_Item));\n \n-   procedure Delete\n-     (Container : in out Vector;\n-      Index     : Extended_Index)\n-   with\n+   procedure Delete (Container : in out Vector; Index : Extended_Index) with\n      Global => null,\n      Pre    => Index in First_Index (Container) .. Last_Index (Container),\n      Post   =>\n@@ -619,9 +611,7 @@ is\n                    Lst    => Last_Index (Container),\n                    Offset => Count));\n \n-   procedure Delete_First\n-     (Container : in out Vector)\n-   with\n+   procedure Delete_First (Container : in out Vector) with\n      Global => null,\n      Pre    => Length (Container) > 0,\n      Post   =>\n@@ -636,10 +626,7 @@ is\n                 Lst    => Last_Index (Container),\n                 Offset => 1);\n \n-   procedure Delete_First\n-     (Container : in out Vector;\n-      Count     : Count_Type)\n-   with\n+   procedure Delete_First (Container : in out Vector; Count : Count_Type) with\n      Global         => null,\n      Contract_Cases =>\n \n@@ -659,9 +646,7 @@ is\n                    Lst    => Last_Index (Container),\n                    Offset => Count));\n \n-   procedure Delete_Last\n-     (Container : in out Vector)\n-   with\n+   procedure Delete_Last (Container : in out Vector) with\n      Global => null,\n      Pre    => Length (Container) > 0,\n      Post   =>\n@@ -671,10 +656,7 @@ is\n \n          and Model (Container) < Model (Container)'Old;\n \n-   procedure Delete_Last\n-     (Container : in out Vector;\n-      Count     : Count_Type)\n-   with\n+   procedure Delete_Last (Container : in out Vector; Count : Count_Type) with\n      Global         => null,\n      Contract_Cases =>\n \n@@ -693,10 +675,15 @@ is\n      Global => null,\n      Post   => M_Elements_Reversed (Model (Container)'Old, Model (Container));\n \n-   procedure Swap (Container : in out Vector; I, J : Index_Type) with\n+   procedure Swap\n+     (Container : in out Vector;\n+      I         : Index_Type;\n+      J         : Index_Type)\n+   with\n      Global => null,\n-     Pre    => I in First_Index (Container) .. Last_Index (Container)\n-      and then J in First_Index (Container) .. Last_Index (Container),\n+     Pre    =>\n+       I in First_Index (Container) .. Last_Index (Container)\n+         and then J in First_Index (Container) .. Last_Index (Container),\n      Post   =>\n        M_Elements_Swapped (Model (Container)'Old, Model (Container), I, J);\n \n@@ -737,11 +724,11 @@ is\n        --  returns No_Index.\n \n        (Index > Last_Index (Container)\n-        or else not M.Contains\n-                     (Container => Model (Container),\n-                      Fst       => Index,\n-                      Lst       => Last_Index (Container),\n-                      Item      => Item)\n+         or else not M.Contains\n+                       (Container => Model (Container),\n+                        Fst       => Index,\n+                        Lst       => Last_Index (Container),\n+                        Item      => Item)\n         =>\n           Find_Index'Result = No_Index,\n \n@@ -799,8 +786,10 @@ is\n                       (Container => Model (Container),\n                        Fst       => Reverse_Find_Index'Result + 1,\n                        Lst       =>\n-                         (if Index <= Last_Index (Container) then Index\n-                          else Last_Index (Container)),\n+                         (if Index <= Last_Index (Container) then\n+                             Index\n+                          else\n+                             Last_Index (Container)),\n                        Item      => Item));\n \n    function Contains\n@@ -809,10 +798,12 @@ is\n    with\n      Global => null,\n      Post   =>\n-       Contains'Result = M.Contains (Container => Model (Container),\n-                                     Fst       => Index_Type'First,\n-                                     Lst       => Last_Index (Container),\n-                                     Item      => Item);\n+       Contains'Result =\n+         M.Contains\n+           (Container => Model (Container),\n+            Fst       => Index_Type'First,\n+            Lst       => Last_Index (Container),\n+            Item      => Item);\n \n    function Has_Element\n      (Container : Vector;\n@@ -834,8 +825,8 @@ is\n           M_Elements_Sorted'Result =\n             (for all I in Index_Type'First .. M.Last (Container) =>\n               (for all J in I .. M.Last (Container) =>\n-                 Element (Container, I) = Element (Container, J)\n-                   or Element (Container, I) < Element (Container, J)));\n+                Element (Container, I) = Element (Container, J)\n+                  or Element (Container, I) < Element (Container, J)));\n       pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Sorted);\n \n       function Is_Sorted (Container : Vector) return Boolean with\n@@ -847,14 +838,16 @@ is\n         Post   =>\n           Length (Container) = Length (Container)'Old\n             and M_Elements_Sorted (Model (Container))\n-            and M_Elements_Included (Left  => Model (Container)'Old,\n-                                     L_Lst => Last_Index (Container),\n-                                     Right => Model (Container),\n-                                     R_Lst => Last_Index (Container))\n-            and M_Elements_Included (Left  => Model (Container),\n-                                     L_Lst => Last_Index (Container),\n-                                     Right => Model (Container)'Old,\n-                                     R_Lst => Last_Index (Container));\n+            and M_Elements_Included\n+                  (Left  => Model (Container)'Old,\n+                   L_Lst => Last_Index (Container),\n+                   Right => Model (Container),\n+                   R_Lst => Last_Index (Container))\n+            and M_Elements_Included\n+                  (Left  => Model (Container),\n+                   L_Lst => Last_Index (Container),\n+                   Right => Model (Container)'Old,\n+                   R_Lst => Last_Index (Container));\n \n       procedure Merge (Target : in out Vector; Source : in out Vector) with\n       --  Target and Source should not be aliased\n@@ -865,18 +858,22 @@ is\n             and Length (Source) = 0\n             and (if M_Elements_Sorted (Model (Target)'Old)\n                    and M_Elements_Sorted (Model (Source)'Old)\n-                 then M_Elements_Sorted (Model (Target)))\n-            and M_Elements_Included (Left  => Model (Target)'Old,\n-                                     L_Lst => Last_Index (Target)'Old,\n-                                     Right => Model (Target),\n-                                     R_Lst => Last_Index (Target))\n-            and M_Elements_Included (Left  => Model (Source)'Old,\n-                                     L_Lst => Last_Index (Source)'Old,\n-                                     Right => Model (Target),\n-                                     R_Lst => Last_Index (Target))\n-            and M_Elements_In_Union (Model (Target),\n-                                     Model (Source)'Old,\n-                                     Model (Target)'Old);\n+                 then\n+                    M_Elements_Sorted (Model (Target)))\n+            and M_Elements_Included\n+                  (Left  => Model (Target)'Old,\n+                   L_Lst => Last_Index (Target)'Old,\n+                   Right => Model (Target),\n+                   R_Lst => Last_Index (Target))\n+            and M_Elements_Included\n+                  (Left  => Model (Source)'Old,\n+                   L_Lst => Last_Index (Source)'Old,\n+                   Right => Model (Target),\n+                   R_Lst => Last_Index (Target))\n+            and M_Elements_In_Union\n+                  (Model (Target),\n+                   Model (Source)'Old,\n+                   Model (Target)'Old);\n    end Generic_Sorting;\n \n private\n@@ -904,9 +901,11 @@ private\n    type Elements_Array_Ptr is access all Elements_Array;\n \n    type Vector (Capacity : Capacity_Range) is limited record\n+\n       --  In the bounded case, the elements are stored in Elements. In the\n       --  unbounded case, the elements are initially stored in Elements, until\n       --  we run out of room, then we switch to Elements_Ptr.\n+\n       Last         : Extended_Index := No_Index;\n       Elements_Ptr : Elements_Array_Ptr := null;\n       Elements     : aliased Elements_Array (1 .. Capacity);"}, {"sha": "87c1d3d59cb10aa10682e3cdab4ce3331b5c04eb", "filename": "gcc/ada/a-cofove.adb", "status": "modified", "additions": 103, "deletions": 108, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27eaddda0f838d0c837d902dea4505c48312ef17/gcc%2Fada%2Fa-cofove.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27eaddda0f838d0c837d902dea4505c48312ef17/gcc%2Fada%2Fa-cofove.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.adb?ref=27eaddda0f838d0c837d902dea4505c48312ef17", "patch": "@@ -41,12 +41,12 @@ is\n    type Int is range System.Min_Int .. System.Max_Int;\n \n    procedure Free is\n-      new Ada.Unchecked_Deallocation (Elements_Array, Elements_Array_Ptr);\n+     new Ada.Unchecked_Deallocation (Elements_Array, Elements_Array_Ptr);\n \n    type Maximal_Array_Ptr is access all Elements_Array (Array_Index)\n      with Storage_Size => 0;\n    type Maximal_Array_Ptr_Const is access constant Elements_Array (Array_Index)\n-       with Storage_Size => 0;\n+     with Storage_Size => 0;\n \n    function Elems (Container : in out Vector) return Maximal_Array_Ptr;\n    function Elemsc\n@@ -78,7 +78,7 @@ is\n    -- \"=\" --\n    ---------\n \n-   function \"=\" (Left, Right : Vector) return Boolean is\n+   function \"=\" (Left : Vector; Right : Vector) return Boolean is\n    begin\n       if Left'Address = Right'Address then\n          return True;\n@@ -114,10 +114,7 @@ is\n       Insert (Container, Container.Last + 1, New_Item);\n    end Append;\n \n-   procedure Append\n-     (Container : in out Vector;\n-      New_Item  : Element_Type)\n-   is\n+   procedure Append (Container : in out Vector; New_Item : Element_Type) is\n    begin\n       Append (Container, New_Item, 1);\n    end Append;\n@@ -165,8 +162,11 @@ is\n \n    function Capacity (Container : Vector) return Capacity_Range is\n    begin\n-      return (if Bounded then Container.Capacity\n-              else Capacity_Range'Last);\n+      return\n+        (if Bounded then\n+            Container.Capacity\n+         else\n+            Capacity_Range'Last);\n    end Capacity;\n \n    -----------\n@@ -226,19 +226,18 @@ is\n \n    function Current_Capacity (Container : Vector) return Capacity_Range is\n    begin\n-      return (if Container.Elements_Ptr = null\n-              then Container.Elements'Length\n-              else Container.Elements_Ptr.all'Length);\n+      return\n+        (if Container.Elements_Ptr = null then\n+            Container.Elements'Length\n+         else\n+            Container.Elements_Ptr.all'Length);\n    end Current_Capacity;\n \n    ------------\n    -- Delete --\n    ------------\n \n-   procedure Delete\n-     (Container : in out Vector;\n-      Index     : Extended_Index)\n-   is\n+   procedure Delete (Container : in out Vector; Index : Extended_Index) is\n    begin\n       Delete (Container, Index, 1);\n    end Delete;\n@@ -317,10 +316,10 @@ is\n       end if;\n \n       --  There are some elements aren't being deleted (the requested count was\n-      --  less than the available count), so we must slide them down to\n-      --  Index. We first calculate the index values of the respective array\n-      --  slices, using the wider of Index_Type'Base and Count_Type'Base as the\n-      --  type for intermediate calculations.\n+      --  less than the available count), so we must slide them down to Index.\n+      --  We first calculate the index values of the respective array slices,\n+      --  using the wider of Index_Type'Base and Count_Type'Base as the type\n+      --  for intermediate calculations.\n \n       if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n          Off := Count_Type'Base (Index - Index_Type'First);\n@@ -346,17 +345,12 @@ is\n    -- Delete_First --\n    ------------------\n \n-   procedure Delete_First\n-     (Container : in out Vector)\n-   is\n+   procedure Delete_First (Container : in out Vector) is\n    begin\n       Delete_First (Container, 1);\n    end Delete_First;\n \n-   procedure Delete_First\n-     (Container : in out Vector;\n-      Count     : Count_Type)\n-   is\n+   procedure Delete_First (Container : in out Vector; Count : Count_Type) is\n    begin\n       if Count = 0 then\n          return;\n@@ -374,17 +368,12 @@ is\n    -- Delete_Last --\n    -----------------\n \n-   procedure Delete_Last\n-     (Container : in out Vector)\n-   is\n+   procedure Delete_Last (Container : in out Vector) is\n    begin\n       Delete_Last (Container, 1);\n    end Delete_Last;\n \n-   procedure Delete_Last\n-     (Container : in out Vector;\n-      Count     : Count_Type)\n-   is\n+   procedure Delete_Last (Container : in out Vector; Count : Count_Type) is\n    begin\n       if Count = 0 then\n          return;\n@@ -439,17 +428,20 @@ is\n \n    function Elems (Container : in out Vector) return Maximal_Array_Ptr is\n    begin\n-      return (if Container.Elements_Ptr = null\n-              then Container.Elements'Unrestricted_Access\n-              else Container.Elements_Ptr.all'Unrestricted_Access);\n+      return\n+        (if Container.Elements_Ptr = null then\n+            Container.Elements'Unrestricted_Access\n+         else\n+            Container.Elements_Ptr.all'Unrestricted_Access);\n    end Elems;\n \n-   function Elemsc\n-     (Container : Vector) return Maximal_Array_Ptr_Const is\n+   function Elemsc (Container : Vector) return Maximal_Array_Ptr_Const is\n    begin\n-      return (if Container.Elements_Ptr = null\n-              then Container.Elements'Unrestricted_Access\n-              else Container.Elements_Ptr.all'Unrestricted_Access);\n+      return\n+        (if Container.Elements_Ptr = null then\n+            Container.Elements'Unrestricted_Access\n+         else\n+            Container.Elements_Ptr.all'Unrestricted_Access);\n    end Elemsc;\n \n    ----------------\n@@ -515,33 +507,18 @@ is\n          Left      : M.Sequence;\n          Right     : M.Sequence) return Boolean\n       is\n-      begin\n-         for I in Index_Type'First .. M.Last (Container) loop\n-            declare\n-               Found : Boolean := False;\n-               J     : Extended_Index := Extended_Index'First;\n-\n-            begin\n-               while not Found and J < M.Last (Left) loop\n-                  J := J + 1;\n-                  if Element (Container, I) = Element (Left, J) then\n-                     Found := True;\n-                  end if;\n-               end loop;\n+         Elem : Element_Type;\n \n-               J := Extended_Index'First;\n-\n-               while not Found and J < M.Last (Right) loop\n-                  J := J + 1;\n-                  if Element (Container, I) = Element (Right, J) then\n-                     Found := True;\n-                  end if;\n-               end loop;\n+      begin\n+         for Index in Index_Type'First .. M.Last (Container) loop\n+            Elem := Element (Container, Index);\n \n-               if not Found then\n-                  return False;\n-               end if;\n-            end;\n+            if not M.Contains (Left, Index_Type'First, M.Last (Left), Elem)\n+              and then\n+                not M.Contains (Right, Index_Type'First, M.Last (Right), Elem)\n+            then\n+               return False;\n+            end if;\n          end loop;\n \n          return True;\n@@ -586,8 +563,12 @@ is\n       -- M_Elements_Reversed --\n       -------------------------\n \n-      function M_Elements_Reversed (Left, Right : M.Sequence) return Boolean is\n+      function M_Elements_Reversed\n+        (Left  : M.Sequence;\n+         Right : M.Sequence) return Boolean\n+      is\n          L : constant Index_Type := M.Last (Left);\n+\n       begin\n          if L /= M.Last (Right) then\n             return False;\n@@ -610,7 +591,8 @@ is\n       function M_Elements_Swapped\n         (Left  : M.Sequence;\n          Right : M.Sequence;\n-         X, Y  : Index_Type) return Boolean\n+         X     : Index_Type;\n+         Y     : Index_Type) return Boolean\n       is\n       begin\n          if M.Length (Left) /= M.Length (Right)\n@@ -637,10 +619,12 @@ is\n \n       function Model (Container : Vector) return M.Sequence is\n          R : M.Sequence;\n+\n       begin\n          for Position in 1 .. Length (Container) loop\n             R := M.Add (R, Elemsc (Container) (Position));\n          end loop;\n+\n          return R;\n       end Model;\n \n@@ -658,6 +642,7 @@ is\n \n       function Is_Sorted (Container : Vector) return Boolean is\n          L : constant Capacity_Range := Length (Container);\n+\n       begin\n          for J in 1 .. L - 1 loop\n             if Get_Element (Container, J + 1) <\n@@ -705,16 +690,16 @@ is\n       -- Sort --\n       ----------\n \n-      procedure Sort (Container : in out Vector)\n-      is\n+      procedure Sort (Container : in out Vector) is\n          procedure Sort is\n            new Generic_Array_Sort\n-             (Index_Type   => Array_Index,\n-              Element_Type => Element_Type,\n-              Array_Type   => Elements_Array,\n-              \"<\"          => \"<\");\n+                 (Index_Type   => Array_Index,\n+                  Element_Type => Element_Type,\n+                  Array_Type   => Elements_Array,\n+                  \"<\"          => \"<\");\n \n          Len : constant Capacity_Range := Length (Container);\n+\n       begin\n          if Container.Last <= Index_Type'First then\n             return;\n@@ -727,13 +712,13 @@ is\n       -- Merge --\n       -----------\n \n-      procedure Merge (Target, Source : in out Vector) is\n-         I, J : Count_Type;\n+      procedure Merge (Target : in out Vector; Source : in out Vector) is\n+         I : Count_Type;\n+         J : Count_Type;\n \n       begin\n          if Target'Address = Source'Address then\n-            raise Program_Error with\n-              \"Target and Source denote same container\";\n+            raise Program_Error with \"Target and Source denote same container\";\n          end if;\n \n          if Length (Source) = 0 then\n@@ -749,15 +734,16 @@ is\n \n          declare\n             New_Length : constant Count_Type := I + Length (Source);\n+\n          begin\n-            if not Bounded and then\n-              Current_Capacity (Target) < Capacity_Range (New_Length)\n+            if not Bounded\n+              and then Current_Capacity (Target) < Capacity_Range (New_Length)\n             then\n                Reserve_Capacity\n                  (Target,\n                   Capacity_Range'Max\n                     (Current_Capacity (Target) * Growth_Factor,\n-                    Capacity_Range (New_Length)));\n+                     Capacity_Range (New_Length)));\n             end if;\n \n             if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n@@ -772,6 +758,7 @@ is\n          declare\n             TA : Maximal_Array_Ptr renames Elems (Target);\n             SA : Maximal_Array_Ptr renames Elems (Source);\n+\n          begin\n             J := Length (Target);\n             while Length (Source) /= 0 loop\n@@ -814,7 +801,9 @@ is\n    -----------------\n \n    function Has_Element\n-     (Container : Vector; Position : Extended_Index) return Boolean is\n+     (Container : Vector;\n+      Position  : Extended_Index) return Boolean\n+   is\n    begin\n       return Position in First_Index (Container) .. Last_Index (Container);\n    end Has_Element;\n@@ -870,6 +859,7 @@ is\n       Insert_Space (Container, Before, Count => N);\n \n       if N = 0 then\n+\n          --  There's nothing else to do here (vetting of parameters was\n          --  performed already in Insert_Space), so we simply return.\n \n@@ -937,9 +927,9 @@ is\n \n       --  There are two constraints we need to satisfy. The first constraint is\n       --  that a container cannot have more than Count_Type'Last elements, so\n-      --  we must check the sum of the current length and the insertion\n-      --  count. Note that we cannot simply add these values, because of the\n-      --  possibility of overflow.\n+      --  we must check the sum of the current length and the insertion count.\n+      --  Note that the value cannot be simply added because the result may\n+      --  overflow.\n \n       if Old_Length > Count_Type'Last - Count then\n          raise Constraint_Error with \"Count is out of range\";\n@@ -991,8 +981,7 @@ is\n             --  worry about if No_Index were less than 0, but that case is\n             --  handled above).\n \n-            if Index_Type'Last - No_Index >=\n-                 Count_Type'Pos (Count_Type'Last)\n+            if Index_Type'Last - No_Index >= Count_Type'Pos (Count_Type'Last)\n             then\n                --  We have determined that range of Index_Type has at least as\n                --  many values as in Count_Type, so Count_Type'Last is the\n@@ -1058,17 +1047,18 @@ is\n \n       --  Increase the capacity of container if needed\n \n-      if not Bounded and then\n-        Current_Capacity (Container) < Capacity_Range (New_Length)\n+      if not Bounded\n+        and then Current_Capacity (Container) < Capacity_Range (New_Length)\n       then\n          Reserve_Capacity\n            (Container,\n             Capacity_Range'Max (Current_Capacity (Container) * Growth_Factor,\n-              Capacity_Range (New_Length)));\n+                                Capacity_Range (New_Length)));\n       end if;\n \n       declare\n          EA : Maximal_Array_Ptr renames Elems (Container);\n+\n       begin\n          if Before <= Container.Last then\n \n@@ -1128,6 +1118,7 @@ is\n       L : constant Int := Int (Container.Last);\n       F : constant Int := Int (Index_Type'First);\n       N : constant Int'Base := L - F + 1;\n+\n    begin\n       return Capacity_Range (N);\n    end Length;\n@@ -1136,11 +1127,9 @@ is\n    -- Move --\n    ----------\n \n-   procedure Move\n-     (Target : in out Vector;\n-      Source : in out Vector)\n-   is\n+   procedure Move (Target : in out Vector; Source : in out Vector) is\n       LS : constant Capacity_Range := Length (Source);\n+\n    begin\n       if Target'Address = Source'Address then\n          return;\n@@ -1164,10 +1153,7 @@ is\n       Insert (Container, Index_Type'First, New_Item);\n    end Prepend;\n \n-   procedure Prepend\n-     (Container : in out Vector;\n-      New_Item  : Element_Type)\n-   is\n+   procedure Prepend (Container : in out Vector; New_Item : Element_Type) is\n    begin\n       Prepend (Container, New_Item, 1);\n    end Prepend;\n@@ -1198,6 +1184,7 @@ is\n       declare\n          II : constant Int'Base := Int (Index) - Int (No_Index);\n          I  : constant Capacity_Range := Capacity_Range (II);\n+\n       begin\n          Elems (Container) (I) := New_Item;\n       end;\n@@ -1216,12 +1203,14 @@ is\n          if Capacity > Container.Capacity then\n             raise Constraint_Error with \"Capacity is out of range\";\n          end if;\n+\n       else\n          if Capacity > Formal_Vectors.Current_Capacity (Container) then\n             declare\n                New_Elements : constant Elements_Array_Ptr :=\n                                 new Elements_Array (1 .. Capacity);\n                L            : constant Capacity_Range := Length (Container);\n+\n             begin\n                New_Elements (1 .. L) := Elemsc (Container) (1 .. L);\n                Free (Container.Elements_Ptr);\n@@ -1252,6 +1241,7 @@ is\n          while I < J loop\n             declare\n                EI : constant Element_Type := E (I);\n+\n             begin\n                E (I) := E (J);\n                E (J) := EI;\n@@ -1298,7 +1288,11 @@ is\n    -- Swap --\n    ----------\n \n-   procedure Swap (Container : in out Vector; I, J : Index_Type) is\n+   procedure Swap\n+     (Container : in out Vector;\n+      I         : Index_Type;\n+      J         : Index_Type)\n+   is\n    begin\n       if I > Container.Last then\n          raise Constraint_Error with \"I index is out of range\";\n@@ -1350,12 +1344,12 @@ is\n          Offset := Count_Type'Base (Index - Index_Type'First);\n \n       else\n-         Offset := Count_Type'Base (Index) -\n-                     Count_Type'Base (Index_Type'First);\n+         Offset :=\n+           Count_Type'Base (Index) - Count_Type'Base (Index_Type'First);\n       end if;\n \n-      --  The array index subtype for all container element arrays\n-      --  always starts with 1.\n+      --  The array index subtype for all container element arrays always\n+      --  starts with 1.\n \n       return 1 + Offset;\n    end To_Array_Index;\n@@ -1385,10 +1379,11 @@ is\n \n          Last := Index_Type (Last_As_Int);\n \n-         return (Capacity     => Length,\n-                 Last         => Last,\n-                 Elements_Ptr => <>,\n-                 Elements     => (others => New_Item));\n+         return\n+           (Capacity     => Length,\n+            Last         => Last,\n+            Elements_Ptr => <>,\n+            Elements     => (others => New_Item));\n       end;\n    end To_Vector;\n "}, {"sha": "efa5e9eaea9747a4d959a17aa137d110d3a63fe0", "filename": "gcc/ada/a-cofove.ads", "status": "modified", "additions": 111, "deletions": 112, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27eaddda0f838d0c837d902dea4505c48312ef17/gcc%2Fada%2Fa-cofove.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27eaddda0f838d0c837d902dea4505c48312ef17/gcc%2Fada%2Fa-cofove.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.ads?ref=27eaddda0f838d0c837d902dea4505c48312ef17", "patch": "@@ -118,8 +118,8 @@ is\n             (for all I in Index_Type'First .. M.Last (Container) =>\n               (for some J in Index_Type'First .. M.Last (Left) =>\n                 Element (Container, I) = Element (Left, J))\n-              or (for some J in Index_Type'First .. M.Last (Right) =>\n-                    Element (Container, I) = Element (Right, J)));\n+                  or (for some J in Index_Type'First .. M.Last (Right) =>\n+                       Element (Container, I) = Element (Right, J)));\n       pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_In_Union);\n \n       function M_Elements_Included\n@@ -151,11 +151,11 @@ is\n           M_Elements_Reversed'Result =\n             (M.Length (Left) = M.Length (Right)\n               and (for all I in Index_Type'First .. M.Last (Left) =>\n-                     Element (Left, I) =\n-                     Element (Right, M.Last (Left) - I + 1))\n+                    Element (Left, I) =\n+                      Element (Right, M.Last (Left) - I + 1))\n               and (for all I in Index_Type'First .. M.Last (Right) =>\n-                     Element (Right, I) =\n-                     Element (Left, M.Last (Left) - I + 1)));\n+                    Element (Right, I) =\n+                      Element (Left, M.Last (Left) - I + 1)));\n       pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Reversed);\n \n       function M_Elements_Swapped\n@@ -189,6 +189,7 @@ is\n          I : Index_Type) return Element_Type renames M.Get;\n       --  To improve readability of contracts, we rename the function used to\n       --  access an element in the model to Element.\n+\n    end Formal_Model;\n    use Formal_Model;\n \n@@ -207,16 +208,20 @@ is\n      Global => null,\n      Post   =>\n        Formal_Vectors.Length (To_Vector'Result) = Length\n-         and M.Constant_Range (Container => Model (To_Vector'Result),\n-                               Fst       => Index_Type'First,\n-                               Lst       => Last_Index (To_Vector'Result),\n-                               Item      => New_Item);\n+         and M.Constant_Range\n+               (Container => Model (To_Vector'Result),\n+                Fst       => Index_Type'First,\n+                Lst       => Last_Index (To_Vector'Result),\n+                Item      => New_Item);\n \n    function Capacity (Container : Vector) return Capacity_Range with\n      Global => null,\n      Post   =>\n-       Capacity'Result = (if Bounded then Container.Capacity\n-                          else Capacity_Range'Last);\n+       Capacity'Result =\n+         (if Bounded then\n+             Container.Capacity\n+          else\n+             Capacity_Range'Last);\n    pragma Annotate (GNATprove, Inline_For_Proof, Capacity);\n \n    procedure Reserve_Capacity\n@@ -251,8 +256,10 @@ is\n      Pre    => (if Bounded then (Capacity = 0 or Length (Source) <= Capacity)),\n      Post   =>\n        Model (Copy'Result) = Model (Source)\n-         and (if Capacity = 0 then Copy'Result.Capacity = Length (Source)\n-              else Copy'Result.Capacity = Capacity);\n+         and (if Capacity = 0 then\n+                 Copy'Result.Capacity = Length (Source)\n+              else\n+                 Copy'Result.Capacity = Capacity);\n \n    procedure Move (Target : in out Vector; Source : in out Vector)\n    with\n@@ -299,7 +306,7 @@ is\n      Pre    =>\n        Length (Container) <= Capacity (Container) - Length (New_Item)\n          and (Before in Index_Type'First .. Last_Index (Container)\n-              or (Before /= No_Index\n+               or (Before /= No_Index\n                     and then Before - 1 = Last_Index (Container))),\n      Post   =>\n        Length (Container) = Length (Container)'Old + Length (New_Item)\n@@ -315,12 +322,12 @@ is\n          --  Elements of New_Item are inserted at position Before\n \n          and (if Length (New_Item) > 0 then\n-                M.Range_Shifted\n-                  (Left   => Model (New_Item),\n-                    Right  => Model (Container),\n-                    Fst    => Index_Type'First,\n-                    Lst    => Last_Index (New_Item),\n-                    Offset => Count_Type (Before - Index_Type'First)))\n+                 M.Range_Shifted\n+                   (Left   => Model (New_Item),\n+                     Right  => Model (Container),\n+                     Fst    => Index_Type'First,\n+                     Lst    => Last_Index (New_Item),\n+                     Offset => Count_Type (Before - Index_Type'First)))\n \n          --  Elements located after Before in Container are shifted\n \n@@ -374,7 +381,7 @@ is\n      Pre    =>\n        Length (Container) <= Capacity (Container) - Count\n          and (Before in Index_Type'First .. Last_Index (Container)\n-              or (Before /= No_Index\n+               or (Before /= No_Index\n                     and then Before - 1 = Last_Index (Container))),\n      Post   =>\n        Length (Container) = Length (Container)'Old + Count\n@@ -390,11 +397,11 @@ is\n          --  New_Item is inserted Count times at position Before\n \n          and (if Count > 0 then\n-                M.Constant_Range\n-                  (Container => Model (Container),\n-                    Fst       => Before,\n-                    Lst       => Before + Index_Type'Base (Count - 1),\n-                    Item      => New_Item))\n+                 M.Constant_Range\n+                   (Container => Model (Container),\n+                     Fst       => Before,\n+                     Lst       => Before + Index_Type'Base (Count - 1),\n+                     Item      => New_Item))\n \n          --  Elements located after Before in Container are shifted\n \n@@ -405,10 +412,7 @@ is\n                 Lst    => Last_Index (Container)'Old,\n                 Offset => Count);\n \n-   procedure Prepend\n-     (Container : in out Vector;\n-      New_Item  : Vector)\n-   with\n+   procedure Prepend (Container : in out Vector; New_Item : Vector) with\n      Global => null,\n      Pre    => Length (Container) <= Capacity (Container) - Length (New_Item),\n      Post   =>\n@@ -431,10 +435,7 @@ is\n                 Lst    => Last_Index (Container)'Old,\n                 Offset => Length (New_Item));\n \n-   procedure Prepend\n-     (Container : in out Vector;\n-      New_Item  : Element_Type)\n-   with\n+   procedure Prepend (Container : in out Vector; New_Item : Element_Type) with\n      Global => null,\n      Pre    => Length (Container) < Capacity (Container),\n      Post   =>\n@@ -480,10 +481,7 @@ is\n                 Lst    => Last_Index (Container)'Old,\n                 Offset => Count);\n \n-   procedure Append\n-     (Container : in out Vector;\n-      New_Item  : Vector)\n-   with\n+   procedure Append (Container : in out Vector; New_Item : Vector) with\n      Global         => null,\n      Pre            =>\n        Length (Container) <= Capacity (Container) - Length (New_Item),\n@@ -497,19 +495,16 @@ is\n          --  Elements of New_Item are inserted at the end of Container\n \n          and (if Length (New_Item) > 0 then\n-                M.Range_Shifted\n-                 (Left   => Model (New_Item),\n-                   Right  => Model (Container),\n-                   Fst    => Index_Type'First,\n-                   Lst    => Last_Index (New_Item),\n-                   Offset =>\n-                     Count_Type\n-                       (Last_Index (Container)'Old - Index_Type'First + 1)));\n+                 M.Range_Shifted\n+                  (Left   => Model (New_Item),\n+                    Right  => Model (Container),\n+                    Fst    => Index_Type'First,\n+                    Lst    => Last_Index (New_Item),\n+                    Offset =>\n+                      Count_Type\n+                        (Last_Index (Container)'Old - Index_Type'First + 1)));\n \n-   procedure Append\n-     (Container : in out Vector;\n-      New_Item  : Element_Type)\n-   with\n+   procedure Append (Container : in out Vector; New_Item : Element_Type) with\n      Global => null,\n      Pre    => Length (Container) < Capacity (Container),\n      Post   =>\n@@ -541,17 +536,14 @@ is\n          --  New_Item is inserted Count times at the end of Container\n \n          and (if Count > 0 then\n-                M.Constant_Range\n-                  (Container => Model (Container),\n-                    Fst       => Last_Index (Container)'Old + 1,\n-                    Lst       =>\n-                      Last_Index (Container)'Old + Index_Type'Base (Count),\n-                    Item      => New_Item));\n+                 M.Constant_Range\n+                   (Container => Model (Container),\n+                     Fst       => Last_Index (Container)'Old + 1,\n+                     Lst       =>\n+                       Last_Index (Container)'Old + Index_Type'Base (Count),\n+                     Item      => New_Item));\n \n-   procedure Delete\n-     (Container : in out Vector;\n-      Index     : Extended_Index)\n-   with\n+   procedure Delete (Container : in out Vector; Index : Extended_Index) with\n      Global => null,\n      Pre    => Index in First_Index (Container) .. Last_Index (Container),\n      Post   =>\n@@ -613,9 +605,7 @@ is\n                    Lst    => Last_Index (Container),\n                    Offset => Count));\n \n-   procedure Delete_First\n-     (Container : in out Vector)\n-   with\n+   procedure Delete_First (Container : in out Vector) with\n      Global => null,\n      Pre    => Length (Container) > 0,\n      Post   =>\n@@ -630,10 +620,7 @@ is\n                 Lst    => Last_Index (Container),\n                 Offset => 1);\n \n-   procedure Delete_First\n-     (Container : in out Vector;\n-      Count     : Count_Type)\n-   with\n+   procedure Delete_First (Container : in out Vector; Count : Count_Type) with\n      Global         => null,\n      Contract_Cases =>\n \n@@ -653,9 +640,7 @@ is\n                    Lst    => Last_Index (Container),\n                    Offset => Count));\n \n-   procedure Delete_Last\n-     (Container : in out Vector)\n-   with\n+   procedure Delete_Last (Container : in out Vector) with\n      Global => null,\n      Pre    => Length (Container) > 0,\n      Post   =>\n@@ -665,10 +650,7 @@ is\n \n          and Model (Container) < Model (Container)'Old;\n \n-   procedure Delete_Last\n-     (Container : in out Vector;\n-      Count     : Count_Type)\n-   with\n+   procedure Delete_Last (Container : in out Vector; Count : Count_Type) with\n      Global         => null,\n      Contract_Cases =>\n \n@@ -687,10 +669,15 @@ is\n      Global => null,\n      Post   => M_Elements_Reversed (Model (Container)'Old, Model (Container));\n \n-   procedure Swap (Container : in out Vector; I, J : Index_Type) with\n+   procedure Swap\n+     (Container : in out Vector;\n+      I         : Index_Type;\n+      J         : Index_Type)\n+   with\n      Global => null,\n-     Pre    => I in First_Index (Container) .. Last_Index (Container)\n-      and then J in First_Index (Container) .. Last_Index (Container),\n+     Pre    =>\n+       I in First_Index (Container) .. Last_Index (Container)\n+         and then J in First_Index (Container) .. Last_Index (Container),\n      Post   =>\n        M_Elements_Swapped (Model (Container)'Old, Model (Container), I, J);\n \n@@ -731,11 +718,11 @@ is\n        --  returns No_Index.\n \n        (Index > Last_Index (Container)\n-        or else not M.Contains\n-                     (Container => Model (Container),\n-                      Fst       => Index,\n-                      Lst       => Last_Index (Container),\n-                      Item      => Item)\n+         or else not M.Contains\n+                       (Container => Model (Container),\n+                        Fst       => Index,\n+                        Lst       => Last_Index (Container),\n+                        Item      => Item)\n         =>\n           Find_Index'Result = No_Index,\n \n@@ -780,7 +767,7 @@ is\n         --  Index\n \n         others =>\n-           Reverse_Find_Index'Result in Index_Type'First .. Index\n+          Reverse_Find_Index'Result in Index_Type'First .. Index\n             and Reverse_Find_Index'Result <= Last_Index (Container)\n \n             --  The element at this index in Container is Item\n@@ -793,8 +780,10 @@ is\n                       (Container => Model (Container),\n                        Fst       => Reverse_Find_Index'Result + 1,\n                        Lst       =>\n-                         (if Index <= Last_Index (Container) then Index\n-                          else Last_Index (Container)),\n+                         (if Index <= Last_Index (Container) then\n+                             Index\n+                          else\n+                             Last_Index (Container)),\n                        Item      => Item));\n \n    function Contains\n@@ -803,10 +792,12 @@ is\n    with\n      Global => null,\n      Post   =>\n-       Contains'Result = M.Contains (Container => Model (Container),\n-                                     Fst       => Index_Type'First,\n-                                     Lst       => Last_Index (Container),\n-                                     Item      => Item);\n+       Contains'Result =\n+         M.Contains\n+           (Container => Model (Container),\n+            Fst       => Index_Type'First,\n+            Lst       => Last_Index (Container),\n+            Item      => Item);\n \n    function Has_Element\n      (Container : Vector;\n@@ -828,8 +819,8 @@ is\n           M_Elements_Sorted'Result =\n             (for all I in Index_Type'First .. M.Last (Container) =>\n               (for all J in I .. M.Last (Container) =>\n-                 Element (Container, I) = Element (Container, J)\n-                   or Element (Container, I) < Element (Container, J)));\n+                Element (Container, I) = Element (Container, J)\n+                  or Element (Container, I) < Element (Container, J)));\n       pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Sorted);\n \n       function Is_Sorted (Container : Vector) return Boolean with\n@@ -841,14 +832,16 @@ is\n         Post   =>\n           Length (Container) = Length (Container)'Old\n             and M_Elements_Sorted (Model (Container))\n-            and M_Elements_Included (Left  => Model (Container)'Old,\n-                                     L_Lst => Last_Index (Container),\n-                                     Right => Model (Container),\n-                                     R_Lst => Last_Index (Container))\n-            and M_Elements_Included (Left  => Model (Container),\n-                                     L_Lst => Last_Index (Container),\n-                                     Right => Model (Container)'Old,\n-                                     R_Lst => Last_Index (Container));\n+            and M_Elements_Included\n+                  (Left  => Model (Container)'Old,\n+                   L_Lst => Last_Index (Container),\n+                   Right => Model (Container),\n+                   R_Lst => Last_Index (Container))\n+            and M_Elements_Included\n+                  (Left  => Model (Container),\n+                   L_Lst => Last_Index (Container),\n+                   Right => Model (Container)'Old,\n+                   R_Lst => Last_Index (Container));\n \n       procedure Merge (Target : in out Vector; Source : in out Vector) with\n       --  Target and Source should not be aliased\n@@ -859,18 +852,22 @@ is\n             and Length (Source) = 0\n             and (if M_Elements_Sorted (Model (Target)'Old)\n                    and M_Elements_Sorted (Model (Source)'Old)\n-                 then M_Elements_Sorted (Model (Target)))\n-            and M_Elements_Included (Left  => Model (Target)'Old,\n-                                     L_Lst => Last_Index (Target)'Old,\n-                                     Right => Model (Target),\n-                                     R_Lst => Last_Index (Target))\n-            and M_Elements_Included (Left  => Model (Source)'Old,\n-                                     L_Lst => Last_Index (Source)'Old,\n-                                     Right => Model (Target),\n-                                     R_Lst => Last_Index (Target))\n-            and M_Elements_In_Union (Model (Target),\n-                                     Model (Source)'Old,\n-                                     Model (Target)'Old);\n+                 then\n+                    M_Elements_Sorted (Model (Target)))\n+            and M_Elements_Included\n+                  (Left  => Model (Target)'Old,\n+                   L_Lst => Last_Index (Target)'Old,\n+                   Right => Model (Target),\n+                   R_Lst => Last_Index (Target))\n+            and M_Elements_Included\n+                  (Left  => Model (Source)'Old,\n+                   L_Lst => Last_Index (Source)'Old,\n+                   Right => Model (Target),\n+                   R_Lst => Last_Index (Target))\n+            and M_Elements_In_Union\n+                  (Model (Target),\n+                   Model (Source)'Old,\n+                   Model (Target)'Old);\n    end Generic_Sorting;\n \n private\n@@ -891,9 +888,11 @@ private\n    type Elements_Array_Ptr is access all Elements_Array;\n \n    type Vector (Capacity : Capacity_Range) is limited record\n+\n       --  In the bounded case, the elements are stored in Elements. In the\n       --  unbounded case, the elements are initially stored in Elements, until\n       --  we run out of room, then we switch to Elements_Ptr.\n+\n       Last         : Extended_Index := No_Index;\n       Elements_Ptr : Elements_Array_Ptr := null;\n       Elements     : aliased Elements_Array (1 .. Capacity);"}, {"sha": "81327c4312a275c682de82c5132afceb058553aa", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27eaddda0f838d0c837d902dea4505c48312ef17/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27eaddda0f838d0c837d902dea4505c48312ef17/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=27eaddda0f838d0c837d902dea4505c48312ef17", "patch": "@@ -7509,21 +7509,16 @@ package body Exp_Ch9 is\n \n          Cancel_Param := Make_Defining_Identifier (Loc, Name_uC);\n \n-         --  Insert declaration of C in declarations of existing block\n+         --  Insert the declaration of C in the declarations of the existing\n+         --  block. The variable is initialized to something (True or False,\n+         --  does not matter) to prevent CodePeer from complaining about a\n+         --  possible read of an uninitialized variable.\n \n          Prepend_To (Decls,\n            Make_Object_Declaration (Loc,\n              Defining_Identifier => Cancel_Param,\n-             Object_Definition   =>\n-               New_Occurrence_Of (Standard_Boolean, Loc),\n-             Expression          =>\n-               New_Occurrence_Of (Standard_False, Loc),\n-               --  True would work equally well here. This initialization\n-               --  should be dead, but only because of things (e.g.,\n-               --  abortion deferral) that CodePeer doesn't know about.\n-               --  We want to avoid CodePeer complaints about a possible read\n-               --  of an uninitialized variable when this variable is read,\n-               --  so we initialize it here.\n+             Object_Definition   => New_Occurrence_Of (Standard_Boolean, Loc),\n+             Expression          => New_Occurrence_Of (Standard_False, Loc),\n              Has_Init_Expression => True));\n \n          --  Remove and save the call to Call_Simple"}, {"sha": "4d923a098419a2ea3561a75393e5f6300069c3ef", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27eaddda0f838d0c837d902dea4505c48312ef17/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27eaddda0f838d0c837d902dea4505c48312ef17/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=27eaddda0f838d0c837d902dea4505c48312ef17", "patch": "@@ -1114,13 +1114,11 @@ package body Exp_Util is\n             if Present (New_E) then\n                Rewrite (N, New_Occurrence_Of (New_E, Sloc (N)));\n \n-               --  If the entity is an overridden primitive and we are not\n-               --  in proof mode, we must build a wrapper for the current\n+               --  If the entity is an overridden primitive and we are not in\n+               --  GNATprove mode, we must build a wrapper for the current\n                --  inherited operation.\n \n-               if Is_Subprogram (New_E)\n-                 and then not GNATprove_Mode\n-               then\n+               if Is_Subprogram (New_E) and then not GNATprove_Mode then\n                   Needs_Wrapper := True;\n                end if;\n             end if;"}, {"sha": "8210419844c27ed99017a2afe400dca1708a12b9", "filename": "gcc/ada/g-dyntab.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27eaddda0f838d0c837d902dea4505c48312ef17/gcc%2Fada%2Fg-dyntab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27eaddda0f838d0c837d902dea4505c48312ef17/gcc%2Fada%2Fg-dyntab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-dyntab.adb?ref=27eaddda0f838d0c837d902dea4505c48312ef17", "patch": "@@ -280,7 +280,7 @@ package body GNAT.Dynamic_Tables is\n \n             Old_Table : Old_Alloc_Ptr := To_Old_Alloc_Ptr (T.Table);\n             New_Table : constant Alloc_Ptr :=\n-              new Alloc_Type'(Old_Table (Alloc_Type'Range));\n+                          new Alloc_Type'(Old_Table (Alloc_Type'Range));\n          begin\n             T.P.Last_Allocated := T.P.Last;\n             Free (Old_Table);"}, {"sha": "1dd8410b000b5f22f4d35d4f24a45d6e96890c2d", "filename": "gcc/ada/sem_dim.adb", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27eaddda0f838d0c837d902dea4505c48312ef17/gcc%2Fada%2Fsem_dim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27eaddda0f838d0c837d902dea4505c48312ef17/gcc%2Fada%2Fsem_dim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.adb?ref=27eaddda0f838d0c837d902dea4505c48312ef17", "patch": "@@ -2154,9 +2154,9 @@ package body Sem_Dim is\n \n          if Dim_Of_Expr /= Dim_Of_Etyp then\n \n-            --  Numeric literal case. Issue a warning if the object type is not\n-            --  dimensionless to indicate the literal is treated as if its\n-            --  dimension matches the type dimension.\n+            --  Numeric literal case. Issue a warning if the object type is\n+            --  not dimensionless to indicate the literal is treated as if\n+            --  its dimension matches the type dimension.\n \n             if Nkind_In (Original_Node (Expr), N_Real_Literal,\n                                                N_Integer_Literal)\n@@ -2171,8 +2171,8 @@ package body Sem_Dim is\n \n                Set_Dimensions (Id, Dim_Of_Expr);\n \n-            --  Expression may have been constant-folded. If nominal type\n-            --  has dimensions, verify that expression has same type.\n+            --  Expression may have been constant-folded. If nominal type has\n+            --  dimensions, verify that expression has same type.\n \n             elsif Exists (Dim_Of_Etyp) and then Etype (Expr) = Etyp then\n                null;\n@@ -2184,8 +2184,8 @@ package body Sem_Dim is\n             end if;\n          end if;\n \n-         --  Remove dimensions in expression after checking consistency\n-         --  with given type.\n+         --  Remove dimensions in expression after checking consistency with\n+         --  given type.\n \n          Remove_Dimensions (Expr);\n       end if;"}]}