{"sha": "3100e48f7cdb3af1709b00d9d71a7932d92dcbba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzEwMGU0OGY3Y2RiM2FmMTcwOWIwMGQ5ZDcxYTc5MzJkOTJkY2JiYQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2006-10-31T18:08:46Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T18:08:46Z"}, "message": "sem_ch9.adb (Analyze_Protected_Definition): Remove call to Check_Overriding_Indicator.\n\n2006-10-31  Hristian Kirtchev  <kirtchev@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch9.adb (Analyze_Protected_Definition): Remove call to\n\tCheck_Overriding_Indicator.\n\t(Analyze_Task_Definition): Ditto.\n\t(Analyze_Protected_Type, Analyze_Task_Type): Code cleanup.\n\t(Check_Overriding_Indicator): To find overridden interface operation,\n\texamine only homonyms that have an explicit subprogram declaration, not\n\tinherited operations created by an unrelated type derivation.\n\t(Check_Overriding_Indicator): When checking for the presence of \"null\"\n\tin a procedure, ensure that the queried node is a procedure\n\tspecification.\n\t(Matches_Prefixed_View_Profile): Add mechanism to retrieve the parameter\n\ttype when the formal is an access to variable.\n\t(Analyze_Protected_Type): Add check for Preelaborable_Initialization\n\t(Analyze_Task_Type): Same addition\n\t(Analyze_Entry_Declaration): Call Generate_Reference_To_Formals, to\n\tprovide navigation capabilities for entries.\n\nFrom-SVN: r118307", "tree": {"sha": "183256438dc934dcfc6b9ac0b14ad66d4e5c5332", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/183256438dc934dcfc6b9ac0b14ad66d4e5c5332"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3100e48f7cdb3af1709b00d9d71a7932d92dcbba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3100e48f7cdb3af1709b00d9d71a7932d92dcbba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3100e48f7cdb3af1709b00d9d71a7932d92dcbba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3100e48f7cdb3af1709b00d9d71a7932d92dcbba/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "923fa078d5602c3440c77a4e001e6163d3afd03c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/923fa078d5602c3440c77a4e001e6163d3afd03c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/923fa078d5602c3440c77a4e001e6163d3afd03c"}], "stats": {"total": 333, "additions": 50, "deletions": 283}, "files": [{"sha": "e42dbe9d8d984e8d53a7fe624808a1eccd2ce6f7", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 50, "deletions": 283, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3100e48f7cdb3af1709b00d9d71a7932d92dcbba/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3100e48f7cdb3af1709b00d9d71a7932d92dcbba/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=3100e48f7cdb3af1709b00d9d71a7932d92dcbba", "patch": "@@ -68,11 +68,6 @@ package body Sem_Ch9 is\n    --  count the entries (checking the static requirement), and compare with\n    --  the given maximum.\n \n-   procedure Check_Overriding_Indicator (Def : Node_Id);\n-   --  Ada 2005 (AI-397): Check the overriding indicator of entries and\n-   --  subprograms of protected or task types. Def is the definition of the\n-   --  protected or task type.\n-\n    function Find_Concurrent_Spec (Body_Id : Entity_Id) return Entity_Id;\n    --  Find entity in corresponding task or protected declaration. Use full\n    --  view if first declaration was for an incomplete type.\n@@ -404,9 +399,8 @@ package body Sem_Ch9 is\n \n       --  Set Never_Set_In_Source and clear Is_True_Constant/Current_Value\n       --  fields on all entry formals (this loop ignores all other entities).\n-      --  Reset Set_Referenced and Has_Pragma_Unreferenced as well, so that we\n-      --  can post accurate warnings on each accept statement for the same\n-      --  entry.\n+      --  Reset Referenced and Has_Pragma_Unreferenced as well, so that we can\n+      --  post accurate warnings on each accept statement for the same entry.\n \n       E := First_Entity (Entry_Nam);\n       while Present (E) loop\n@@ -927,6 +921,8 @@ package body Sem_Ch9 is\n       if Ekind (Id) = E_Entry then\n          New_Overloaded_Entity (Id);\n       end if;\n+\n+      Generate_Reference_To_Formals (Id);\n    end Analyze_Entry_Declaration;\n \n    ---------------------------------------\n@@ -1096,7 +1092,6 @@ package body Sem_Ch9 is\n \n       Check_Max_Entries (N, Max_Protected_Entries);\n       Process_End_Label (N, 'e', Current_Scope);\n-      Check_Overriding_Indicator (N);\n    end Analyze_Protected_Definition;\n \n    ----------------------------\n@@ -1108,7 +1103,6 @@ package body Sem_Ch9 is\n       T         : Entity_Id;\n       Def_Id    : constant Entity_Id := Defining_Identifier (N);\n       Iface     : Node_Id;\n-      Iface_Def : Node_Id;\n       Iface_Typ : Entity_Id;\n \n    begin\n@@ -1143,7 +1137,6 @@ package body Sem_Ch9 is\n          Iface := First (Interface_List (N));\n          while Present (Iface) loop\n             Iface_Typ := Find_Type_Of_Subtype_Indic (Iface);\n-            Iface_Def := Type_Definition (Parent (Iface_Typ));\n \n             if not Is_Interface (Iface_Typ) then\n                Error_Msg_NE (\"(Ada 2005) & must be an interface\",\n@@ -1158,13 +1151,13 @@ package body Sem_Ch9 is\n                --  Ada 2005 (AI-345): Protected types can only implement\n                --  limited, synchronized or protected interfaces.\n \n-               if Limited_Present (Iface_Def)\n-                 or else Synchronized_Present (Iface_Def)\n-                 or else Protected_Present (Iface_Def)\n+               if Is_Limited_Interface (Iface_Typ)\n+                 or else Is_Protected_Interface (Iface_Typ)\n+                 or else Is_Synchronized_Interface (Iface_Typ)\n                then\n                   null;\n \n-               elsif Task_Present (Iface_Def) then\n+               elsif Is_Task_Interface (Iface_Typ) then\n                   Error_Msg_N (\"(Ada 2005) protected type cannot implement a \"\n                     & \"task interface\", Iface);\n \n@@ -1253,13 +1246,28 @@ package body Sem_Ch9 is\n \n       End_Scope;\n \n+      --  Case of a completion of a private declaration\n+\n       if T /= Def_Id\n         and then Is_Private_Type (Def_Id)\n-        and then Has_Discriminants (Def_Id)\n-        and then Expander_Active\n       then\n-         Exp_Ch9.Expand_N_Protected_Type_Declaration (N);\n-         Process_Full_View (N, T, Def_Id);\n+         --  Deal with preelaborable initialization. Note that this processing\n+         --  is done by Process_Full_View, but as can be seen below, in this\n+         --  case the call to Process_Full_View is skipped if any serious\n+         --  errors have occurred, and we don't want to lose this check.\n+\n+         if Known_To_Have_Preelab_Init (Def_Id) then\n+            Set_Must_Have_Preelab_Init (T);\n+         end if;\n+\n+         --  Create corresponding record now, because some private dependents\n+         --  may be subtypes of the partial view. Skip if errors are present,\n+         --  to prevent cascaded messages.\n+\n+         if Serious_Errors_Detected = 0 then\n+            Exp_Ch9.Expand_N_Protected_Type_Declaration (N);\n+            Process_Full_View (N, T, Def_Id);\n+         end if;\n       end if;\n    end Analyze_Protected_Type;\n \n@@ -1849,7 +1857,6 @@ package body Sem_Ch9 is\n \n       Check_Max_Entries (N, Max_Task_Entries);\n       Process_End_Label (N, 'e', Current_Scope);\n-      Check_Overriding_Indicator (N);\n    end Analyze_Task_Definition;\n \n    -----------------------\n@@ -1860,7 +1867,6 @@ package body Sem_Ch9 is\n       T         : Entity_Id;\n       Def_Id    : constant Entity_Id := Defining_Identifier (N);\n       Iface     : Node_Id;\n-      Iface_Def : Node_Id;\n       Iface_Typ : Entity_Id;\n \n    begin\n@@ -1891,7 +1897,6 @@ package body Sem_Ch9 is\n          Iface := First (Interface_List (N));\n          while Present (Iface) loop\n             Iface_Typ := Find_Type_Of_Subtype_Indic (Iface);\n-            Iface_Def := Type_Definition (Parent (Iface_Typ));\n \n             if not Is_Interface (Iface_Typ) then\n                Error_Msg_NE (\"(Ada 2005) & must be an interface\",\n@@ -1906,13 +1911,13 @@ package body Sem_Ch9 is\n                --  Ada 2005 (AI-345): Task types can only implement limited,\n                --  synchronized or task interfaces.\n \n-               if Limited_Present (Iface_Def)\n-                 or else Synchronized_Present (Iface_Def)\n-                 or else Task_Present (Iface_Def)\n+               if Is_Limited_Interface (Iface_Typ)\n+                 or else Is_Synchronized_Interface (Iface_Typ)\n+                 or else Is_Task_Interface (Iface_Typ)\n                then\n                   null;\n \n-               elsif Protected_Present (Iface_Def) then\n+               elsif Is_Protected_Interface (Iface_Typ) then\n                   Error_Msg_N (\"(Ada 2005) task type cannot implement a \" &\n                     \"protected interface\", Iface);\n \n@@ -1983,13 +1988,28 @@ package body Sem_Ch9 is\n \n       End_Scope;\n \n+      --  Case of a completion of a private declaration\n+\n       if T /= Def_Id\n         and then Is_Private_Type (Def_Id)\n-        and then Has_Discriminants (Def_Id)\n-        and then Expander_Active\n       then\n-         Exp_Ch9.Expand_N_Task_Type_Declaration (N);\n-         Process_Full_View (N, T, Def_Id);\n+         --  Deal with preelaborable initialization. Note that this processing\n+         --  is done by Process_Full_View, but as can be seen below, in this\n+         --  case the call to Process_Full_View is skipped if any serious\n+         --  errors have occurred, and we don't want to lose this check.\n+\n+         if Known_To_Have_Preelab_Init (Def_Id) then\n+            Set_Must_Have_Preelab_Init (T);\n+         end if;\n+\n+         --  Create corresponding record now, because some private dependents\n+         --  may be subtypes of the partial view. Skip if errors are present,\n+         --  to prevent cascaded messages.\n+\n+         if Serious_Errors_Detected = 0 then\n+            Exp_Ch9.Expand_N_Task_Type_Declaration (N);\n+            Process_Full_View (N, T, Def_Id);\n+         end if;\n       end if;\n    end Analyze_Task_Type;\n \n@@ -2154,259 +2174,6 @@ package body Sem_Ch9 is\n       end if;\n    end Check_Max_Entries;\n \n-   --------------------------------\n-   -- Check_Overriding_Indicator --\n-   --------------------------------\n-\n-   procedure Check_Overriding_Indicator (Def : Node_Id) is\n-      Aliased_Hom : Entity_Id;\n-      Decl        : Node_Id;\n-      Def_Id      : Entity_Id;\n-      Hom         : Entity_Id;\n-      Ifaces      : constant List_Id := Interface_List (Parent (Def));\n-      Overrides   : Boolean;\n-      Spec        : Node_Id;\n-      Vis_Decls   : constant List_Id := Visible_Declarations (Def);\n-\n-      function Matches_Prefixed_View_Profile\n-        (Ifaces       : List_Id;\n-         Entry_Params : List_Id;\n-         Proc_Params  : List_Id) return Boolean;\n-      --  Ada 2005 (AI-397): Determine if an entry parameter profile matches\n-      --  the prefixed view profile of an abstract procedure. Also determine\n-      --  whether the abstract procedure belongs to an implemented interface.\n-\n-      -----------------------------------\n-      -- Matches_Prefixed_View_Profile --\n-      -----------------------------------\n-\n-      function Matches_Prefixed_View_Profile\n-        (Ifaces       : List_Id;\n-         Entry_Params : List_Id;\n-         Proc_Params  : List_Id) return Boolean\n-      is\n-         Entry_Param    : Node_Id;\n-         Proc_Param     : Node_Id;\n-         Proc_Param_Typ : Entity_Id;\n-\n-         function Includes_Interface\n-           (Iface  : Entity_Id;\n-            Ifaces : List_Id) return Boolean;\n-         --  Determine if an interface is contained in a list of interfaces\n-\n-         ------------------------\n-         -- Includes_Interface --\n-         ------------------------\n-\n-         function Includes_Interface\n-           (Iface  : Entity_Id;\n-            Ifaces : List_Id) return Boolean\n-         is\n-            Ent : Entity_Id;\n-\n-         begin\n-            Ent := First (Ifaces);\n-            while Present (Ent) loop\n-               if Etype (Ent) = Iface then\n-                  return True;\n-               end if;\n-\n-               Next (Ent);\n-            end loop;\n-\n-            return False;\n-         end Includes_Interface;\n-\n-      --  Start of processing for Matches_Prefixed_View_Profile\n-\n-      begin\n-         Proc_Param := First (Proc_Params);\n-         Proc_Param_Typ := Etype (Parameter_Type (Proc_Param));\n-\n-         --  The first parameter of the abstract procedure must be of an\n-         --  interface type. The task or protected type must also implement\n-         --  that interface.\n-\n-         if not Is_Interface (Proc_Param_Typ)\n-           or else not Includes_Interface (Proc_Param_Typ, Ifaces)\n-         then\n-            return False;\n-         end if;\n-\n-         Entry_Param := First (Entry_Params);\n-         Proc_Param  := Next (Proc_Param);\n-         while Present (Entry_Param) and then Present (Proc_Param) loop\n-\n-            --  The two parameters must be mode conformant and have the exact\n-            --  same types.\n-\n-            if Ekind (Defining_Identifier (Entry_Param)) /=\n-               Ekind (Defining_Identifier (Proc_Param))\n-              or else Etype (Parameter_Type (Entry_Param)) /=\n-                      Etype (Parameter_Type (Proc_Param))\n-            then\n-               return False;\n-            end if;\n-\n-            Next (Entry_Param);\n-            Next (Proc_Param);\n-         end loop;\n-\n-         --  One of the lists is longer than the other\n-\n-         if Present (Entry_Param) or else Present (Proc_Param) then\n-            return False;\n-         end if;\n-\n-         return True;\n-      end Matches_Prefixed_View_Profile;\n-\n-   --  Start of processing for Check_Overriding_Indicator\n-\n-   begin\n-      if Present (Ifaces) then\n-         Decl := First (Vis_Decls);\n-         while Present (Decl) loop\n-\n-            --  Consider entries with either \"overriding\" or \"not overriding\"\n-            --  indicator present.\n-\n-            if Nkind (Decl) = N_Entry_Declaration\n-              and then (Must_Override (Decl)\n-                          or else\n-                        Must_Not_Override (Decl))\n-            then\n-               Def_Id := Defining_Identifier (Decl);\n-\n-               Overrides := False;\n-\n-               Hom := Homonym (Def_Id);\n-               while Present (Hom) loop\n-\n-                  --  The current entry may override a procedure from an\n-                  --  implemented interface.\n-\n-                  if Ekind (Hom) = E_Procedure\n-                    and then (Is_Abstract (Hom)\n-                                or else\n-                              Null_Present (Parent (Hom)))\n-                  then\n-                     Aliased_Hom := Hom;\n-                     while Present (Alias (Aliased_Hom)) loop\n-                        Aliased_Hom := Alias (Aliased_Hom);\n-                     end loop;\n-\n-                     if Matches_Prefixed_View_Profile (Ifaces,\n-                          Parameter_Specifications (Decl),\n-                          Parameter_Specifications (Parent (Aliased_Hom)))\n-                     then\n-                        Overrides := True;\n-                        exit;\n-                     end if;\n-                  end if;\n-\n-                  Hom := Homonym (Hom);\n-               end loop;\n-\n-               if Overrides then\n-                  if Must_Not_Override (Decl) then\n-                     Error_Msg_NE (\"entry& is overriding\", Def_Id, Def_Id);\n-                  end if;\n-               else\n-                  if Must_Override (Decl) then\n-                     Error_Msg_NE (\"entry& is not overriding\", Def_Id, Def_Id);\n-                  end if;\n-               end if;\n-\n-            --  Consider subprograms with either \"overriding\" or \"not\n-            --  overriding\" indicator present.\n-\n-            elsif Nkind (Decl) = N_Subprogram_Declaration\n-              and then (Must_Override (Specification (Decl))\n-                          or else\n-                        Must_Not_Override (Specification (Decl)))\n-            then\n-               Spec := Specification (Decl);\n-               Def_Id := Defining_Unit_Name (Spec);\n-\n-               Overrides := False;\n-\n-               Hom := Homonym (Def_Id);\n-               while Present (Hom) loop\n-\n-                  --  Function\n-\n-                  if Ekind (Def_Id) = E_Function\n-                    and then Ekind (Hom) = E_Function\n-                    and then Is_Abstract (Hom)\n-                    and then Matches_Prefixed_View_Profile (Ifaces,\n-                               Parameter_Specifications (Spec),\n-                               Parameter_Specifications (Parent (Hom)))\n-                    and then Etype (Result_Definition (Spec)) =\n-                             Etype (Result_Definition (Parent (Hom)))\n-                  then\n-                     Overrides := True;\n-                     exit;\n-\n-                  --  Procedure\n-\n-                  elsif Ekind (Def_Id) = E_Procedure\n-                    and then Ekind (Hom) = E_Procedure\n-                    and then (Is_Abstract (Hom)\n-                                or else\n-                              Null_Present (Parent (Hom)))\n-                    and then Matches_Prefixed_View_Profile (Ifaces,\n-                               Parameter_Specifications (Spec),\n-                               Parameter_Specifications (Parent (Hom)))\n-                  then\n-                     Overrides := True;\n-                     exit;\n-                  end if;\n-\n-                  Hom := Homonym (Hom);\n-               end loop;\n-\n-               if Overrides then\n-                  if Must_Not_Override (Spec) then\n-                     Error_Msg_NE\n-                       (\"subprogram& is overriding\", Def_Id, Def_Id);\n-                  end if;\n-               else\n-                  if Must_Override (Spec) then\n-                     Error_Msg_NE\n-                       (\"subprogram& is not overriding\", Def_Id, Def_Id);\n-                  end if;\n-               end if;\n-            end if;\n-\n-            Next (Decl);\n-         end loop;\n-\n-      --  The protected or task type is not implementing an interface, we need\n-      --  to check for the presence of \"overriding\" entries or subprograms and\n-      --  flag them as erroneous.\n-\n-      else\n-         Decl := First (Vis_Decls);\n-         while Present (Decl) loop\n-            if Nkind (Decl) = N_Entry_Declaration\n-              and then Must_Override (Decl)\n-            then\n-               Def_Id := Defining_Identifier (Decl);\n-               Error_Msg_NE (\"entry& is not overriding\", Def_Id, Def_Id);\n-\n-            elsif Nkind (Decl) = N_Subprogram_Declaration\n-              and then Must_Override (Specification (Decl))\n-            then\n-               Def_Id := Defining_Identifier (Specification (Decl));\n-               Error_Msg_NE (\"subprogram& is not overriding\", Def_Id, Def_Id);\n-            end if;\n-\n-            Next (Decl);\n-         end loop;\n-      end if;\n-   end Check_Overriding_Indicator;\n-\n    --------------------------\n    -- Find_Concurrent_Spec --\n    --------------------------"}]}