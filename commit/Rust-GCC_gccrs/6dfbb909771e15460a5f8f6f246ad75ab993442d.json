{"sha": "6dfbb909771e15460a5f8f6f246ad75ab993442d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRmYmI5MDk3NzFlMTU0NjBhNWY4ZjZmMjQ2YWQ3NWFiOTkzNDQyZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-04-24T06:41:16Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-04-24T06:41:16Z"}, "message": "cp-tree.h (lang_decl): Remove pretty_function_p.\n\n\t* cp-tree.h (lang_decl): Remove pretty_function_p.\n\t(DECL_PRETTY_FUNCTION_P): Use TREE_LANG_FLAG_0, not a bit in the\n\tlanguage-specific node.\n\t* decl.c (cp_make_fname_decl): Use build_decl, not\n\tbuild_lang_decl, to build the variables.\n\t(grokvardecl): Don't call build_lang_decl for local variables in\n\ttemplates.\n\t(grokdeclarator): Don't call build_lang_decl for local type\n\tdeclarations in templates.\n\t* lex.c (retrofit_lang_decl): Use ggc_alloc_obj to allocated\n\tzero'd memory, rather than calling memset.\n\t* pt.c: Include hashtab.h.\n\t(local_specializations): New variable.\n\t(retrieve_local_specialization): Use it.\n\t(register_local_specialization): Likewise.\n\t(tsubst_decl): Don't assume local variables have\n\tDECL_LANG_SPECIFIC.\n\t(instantiate_decl): Set up local_specializations.\n\t* Makefile.in (HTAB_H): New variable.\n\nFrom-SVN: r33369", "tree": {"sha": "09b22923010b7e795199c2b498f3194f07f79486", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09b22923010b7e795199c2b498f3194f07f79486"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6dfbb909771e15460a5f8f6f246ad75ab993442d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dfbb909771e15460a5f8f6f246ad75ab993442d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dfbb909771e15460a5f8f6f246ad75ab993442d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dfbb909771e15460a5f8f6f246ad75ab993442d/comments", "author": null, "committer": null, "parents": [{"sha": "b51024fc8996b47f30f3bf277cf1338a24c49953", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b51024fc8996b47f30f3bf277cf1338a24c49953", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b51024fc8996b47f30f3bf277cf1338a24c49953"}], "stats": {"total": 157, "additions": 95, "deletions": 62}, "files": [{"sha": "3469de86aff321e67b453f991dc790c94b3649b2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dfbb909771e15460a5f8f6f246ad75ab993442d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dfbb909771e15460a5f8f6f246ad75ab993442d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6dfbb909771e15460a5f8f6f246ad75ab993442d", "patch": "@@ -1,3 +1,25 @@\n+2000-04-23  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (lang_decl): Remove pretty_function_p.\n+\t(DECL_PRETTY_FUNCTION_P): Use TREE_LANG_FLAG_0, not a bit in the\n+\tlanguage-specific node.\n+\t* decl.c (cp_make_fname_decl): Use build_decl, not\n+\tbuild_lang_decl, to build the variables.\n+\t(grokvardecl): Don't call build_lang_decl for local variables in\n+\ttemplates.\n+\t(grokdeclarator): Don't call build_lang_decl for local type\n+\tdeclarations in templates.\n+\t* lex.c (retrofit_lang_decl): Use ggc_alloc_obj to allocated\n+\tzero'd memory, rather than calling memset.\n+\t* pt.c: Include hashtab.h.\n+\t(local_specializations): New variable.\n+\t(retrieve_local_specialization): Use it.\n+\t(register_local_specialization): Likewise.\n+\t(tsubst_decl): Don't assume local variables have\n+\tDECL_LANG_SPECIFIC.\n+\t(instantiate_decl): Set up local_specializations.\n+\t* Makefile.in (HTAB_H): New variable.\n+\n 2000-04-23  Richard Henderson  <rth@cygnus.com>\n \n \t* typeck.c (c_expand_asm_operands): Restore the original"}, {"sha": "e8a43fa10d03cff114f518e63d100ca53b3ee868", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dfbb909771e15460a5f8f6f246ad75ab993442d/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dfbb909771e15460a5f8f6f246ad75ab993442d/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=6dfbb909771e15460a5f8f6f246ad75ab993442d", "patch": "@@ -210,6 +210,7 @@ PARSE_H = $(srcdir)/parse.h\n PARSE_C = $(srcdir)/parse.c\n EXPR_H = $(srcdir)/../expr.h ../insn-codes.h\n GGC_H = $(srcdir)/../ggc.h $(srcdir)/../varray.h\n+HTAB_H = $(srcdir)/../../include/hashtab.h\n \n parse.o : $(PARSE_C) $(CXX_TREE_H) $(srcdir)/../flags.h lex.h \\\n \t$(srcdir)/../except.h $(srcdir)/../output.h $(srcdir)/../system.h \\\n@@ -295,7 +296,7 @@ xref.o : xref.c $(CXX_TREE_H) $(srcdir)/../input.h \\\n   $(srcdir)/../toplev.h\n pt.o : pt.c $(CXX_TREE_H) decl.h $(PARSE_H) lex.h \\\n   $(srcdir)/../toplev.h $(GGC_H) $(RTL_H) \\\n-  $(srcdir)/../except.h\n+  $(srcdir)/../except.h $(HTAB_H)\n error.o : error.c $(CXX_TREE_H) \\\n   $(srcdir)/../toplev.h\n errfn.o : errfn.c $(CXX_TREE_H) \\"}, {"sha": "be683b23123c5012b57872bfd10909d4717db1c7", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dfbb909771e15460a5f8f6f246ad75ab993442d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dfbb909771e15460a5f8f6f246ad75ab993442d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6dfbb909771e15460a5f8f6f246ad75ab993442d", "patch": "@@ -43,6 +43,7 @@ Boston, MA 02111-1307, USA.  */\n       AGGR_INIT_VIA_CTOR_P (in AGGR_INIT_EXPR)\n       SCOPE_BEGIN_P (in SCOPE_STMT)\n       CTOR_BEGIN_P (in CTOR_STMT)\n+      DECL_PRETTY_FUNCTION_P (in VAR_DECL)\n    1: IDENTIFIER_VIRTUAL_P.\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n@@ -1866,7 +1867,7 @@ struct lang_decl_flags\n   unsigned static_function : 1;\n   unsigned pure_virtual : 1;\n   unsigned has_in_charge_parm_p : 1;\n-  unsigned pretty_function_p : 1;\n+  unsigned bitfield : 1;\n \n   unsigned mutable_flag : 1;\n   unsigned deferred : 1;\n@@ -1876,12 +1877,11 @@ struct lang_decl_flags\n   unsigned not_really_extern : 1;\n   unsigned needs_final_overrider : 1;\n \n-  unsigned bitfield : 1;\n   unsigned defined_in_class : 1;\n   unsigned pending_inline_p : 1;\n   unsigned global_ctor_p : 1;\n   unsigned global_dtor_p : 1;\n-  unsigned dummy : 3;\n+  unsigned dummy : 4;\n \n   tree context;\n \n@@ -2106,7 +2106,7 @@ struct lang_decl\n /* Nonzero if this DECL is the __PRETTY_FUNCTION__ variable in a\n    template function.  */\n #define DECL_PRETTY_FUNCTION_P(NODE) \\\n-  (DECL_LANG_SPECIFIC(NODE)->decl_flags.pretty_function_p)\n+  (TREE_LANG_FLAG_0 (NODE))\n \n /* The _TYPE context in which this _DECL appears.  This field holds the\n    class where a virtual function instance is actually defined. */"}, {"sha": "8a618b5662ca55e9712368f497b073b11b1fe4b7", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dfbb909771e15460a5f8f6f246ad75ab993442d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dfbb909771e15460a5f8f6f246ad75ab993442d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=6dfbb909771e15460a5f8f6f246ad75ab993442d", "patch": "@@ -6550,7 +6550,7 @@ cp_make_fname_decl (id, name, type_dep)\n           (build_qualified_type (char_type_node, TYPE_QUAL_CONST),\n \t   domain);\n \n-  decl = build_lang_decl (VAR_DECL, id, type);\n+  decl = build_decl (VAR_DECL, id, type);\n   TREE_STATIC (decl) = 1;\n   TREE_READONLY (decl) = 1;\n   DECL_SOURCE_LINE (decl) = 0;\n@@ -8924,9 +8924,9 @@ grokvardecl (type, declarator, specbits_in, initialized, constp, in_namespace)\n       else\n \tcontext = NULL_TREE;\n \n-      if (processing_template_decl)\n-\t/* If we're in a template, we need DECL_LANG_SPECIFIC so that\n-\t   we can call push_template_decl.  */\n+      if (processing_template_decl && context)\n+\t/* For global variables, declared in a template, we need the\n+\t   full lang_decl.  */\n \tdecl = build_lang_decl (VAR_DECL, declarator, type);\n       else\n \tdecl = build_decl (VAR_DECL, declarator, type);\n@@ -10917,14 +10917,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t  decl = build_lang_decl (TYPE_DECL, declarator, type);\n \t}\n       else\n-\t{\n-\t  /* Make sure this typedef lives as long as its type,\n-\t     since it might be used as a template parameter. */\n-\t  if (processing_template_decl)\n-\t    decl = build_lang_decl (TYPE_DECL, declarator, type);\n-\t  else\n-\t    decl = build_decl (TYPE_DECL, declarator, type);\n-\t}\n+\tdecl = build_decl (TYPE_DECL, declarator, type);\n \n       /* If the user declares \"typedef struct {...} foo\" then the\n \t struct will have an anonymous name.  Fill that name in now."}, {"sha": "7dc6d308422efd0e9bbdcdbf87a58348aaf1981b", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dfbb909771e15460a5f8f6f246ad75ab993442d/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dfbb909771e15460a5f8f6f246ad75ab993442d/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=6dfbb909771e15460a5f8f6f246ad75ab993442d", "patch": "@@ -4977,8 +4977,7 @@ retrofit_lang_decl (t)\n   else\n     size = sizeof (struct lang_decl_flags);\n \n-  ld = (struct lang_decl *) ggc_alloc (size);\n-  memset (ld, 0, size);\n+  ld = (struct lang_decl *) ggc_alloc_obj (size, 1);\n \n   DECL_LANG_SPECIFIC (t) = ld;\n   if (current_lang_name == lang_name_cplusplus)"}, {"sha": "bfad70f9611c0fc23f8bf5b35f583cabeb0cd633", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 61, "deletions": 43, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dfbb909771e15460a5f8f6f246ad75ab993442d/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dfbb909771e15460a5f8f6f246ad75ab993442d/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6dfbb909771e15460a5f8f6f246ad75ab993442d", "patch": "@@ -43,6 +43,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"rtl.h\"\n #include \"defaults.h\"\n #include \"ggc.h\"\n+#include \"hashtab.h\"\n \n /* The type of functions taking a tree, and some additional data, and\n    returning an int.  */\n@@ -73,6 +74,11 @@ static tree saved_trees;\n static varray_type inline_parm_levels;\n static size_t inline_parm_levels_used;\n \n+/* A map from local variable declarations in the body of the template\n+   presently being instantiated to the corresponding instantiated\n+   local variables.  */\n+static htab_t local_specializations;\n+\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n@@ -119,9 +125,9 @@ static tree build_template_parm_index PARAMS ((int, int, int, tree, tree));\n static int inline_needs_template_parms PARAMS ((tree));\n static void push_inline_template_parms_recursive PARAMS ((tree, int));\n static tree retrieve_specialization PARAMS ((tree, tree));\n-static tree retrieve_local_specialization PARAMS ((tree, tree));\n+static tree retrieve_local_specialization PARAMS ((tree));\n static tree register_specialization PARAMS ((tree, tree, tree));\n-static tree register_local_specialization PARAMS ((tree, tree, tree));\n+static tree register_local_specialization PARAMS ((tree, tree));\n static int unregister_specialization PARAMS ((tree, tree));\n static tree reduce_template_parm_level PARAMS ((tree, tree, int));\n static tree build_template_decl PARAMS ((tree, tree));\n@@ -709,16 +715,13 @@ retrieve_specialization (tmpl, args)\n   return NULL_TREE;\n }\n \n-/* Like retrieve_speciailization, but for local declarations.  FN is\n-   the function in which we are looking for an instantiation.  */\n+/* Like retrieve_speciailization, but for local declarations.  */\n \n static tree\n-retrieve_local_specialization (tmpl, fn)\n+retrieve_local_specialization (tmpl)\n      tree tmpl;\n-     tree fn;\n {\n-  tree s = purpose_member (fn, DECL_TEMPLATE_SPECIALIZATIONS (tmpl));\n-  return s ? TREE_VALUE (s) : NULL_TREE;\n+  return (tree) htab_find (local_specializations, tmpl);\n }\n \n /* Returns non-zero iff DECL is a specialization of TMPL.  */\n@@ -885,18 +888,18 @@ unregister_specialization (spec, tmpl)\n   return 0;\n }\n \n-/* Like register_specialization, but for local declarations.  FN is\n-   the function in which we are registering SPEC, an instantiation of\n-   TMPL.  */\n+/* Like register_specialization, but for local declarations.  We are\n+   registering SPEC, an instantiation of TMPL.  */\n \n static tree\n-register_local_specialization (spec, tmpl, fn)\n+register_local_specialization (spec, tmpl)\n      tree spec;\n      tree tmpl;\n-     tree fn;\n {\n-  DECL_TEMPLATE_SPECIALIZATIONS (tmpl)\n-     = tree_cons (fn, spec, DECL_TEMPLATE_SPECIALIZATIONS (tmpl));\n+  void **slot;\n+\n+  slot = htab_find_slot (local_specializations, tmpl, INSERT);\n+  *slot = spec;\n \n   return spec;\n }\n@@ -3307,10 +3310,7 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n    If REQUIRE_ALL_ARGUMENTS is non-zero, all arguments must be\n    provided in ARGLIST, or else trailing parameters must have default\n    values.  If REQUIRE_ALL_ARGUMENTS is zero, we will attempt argument\n-   deduction for any unspecified trailing arguments.  \n-\n-   The resulting TREE_VEC is allocated on a temporary obstack, and\n-   must be explicitly copied if it will be permanent.  */\n+   deduction for any unspecified trailing arguments.  */\n    \n static tree\n coerce_template_parms (parms, args, in_decl,\n@@ -5857,7 +5857,8 @@ tsubst_decl (t, args, type, in_decl)\n \t  r = TYPE_NAME (type);\n \t  break;\n \t}\n-      else if (!DECL_LANG_SPECIFIC (t))\n+      else if (TREE_CODE (type) == TEMPLATE_TYPE_PARM\n+\t       || TREE_CODE (type) == TEMPLATE_TEMPLATE_PARM)\n \t{\n \t  /* For a template type parameter, we don't have to do\n \t     anything special.  */\n@@ -5874,28 +5875,33 @@ tsubst_decl (t, args, type, in_decl)\n \ttree spec;\n \ttree tmpl;\n \ttree ctx;\n+\tint local_p;\n \n-\t/* Nobody should be tsubst'ing into non-template variables.  */\n-\tmy_friendly_assert (DECL_LANG_SPECIFIC (t) \n-\t\t\t    && DECL_TEMPLATE_INFO (t) != NULL_TREE, 0);\n+\t/* Assume this is a non-local variable.  */\n+\tlocal_p = 0;\n \n \tif (TYPE_P (CP_DECL_CONTEXT (t)))\n \t  ctx = tsubst_aggr_type (DECL_CONTEXT (t), args, \n \t\t\t\t  /*complain=*/1,\n \t\t\t\t  in_decl, /*entering_scope=*/1);\n \telse\n-\t  /* Subsequent calls to pushdecl will fill this in.  */\n-\t  ctx = NULL_TREE;\n+\t  {\n+\t    /* Subsequent calls to pushdecl will fill this in.  */\n+\t    ctx = NULL_TREE;\n+\t    if (!DECL_NAMESPACE_SCOPE_P (t))\n+\t      local_p = 1;\n+\t  }\n \n \t/* Check to see if we already have this specialization.  */\n-\ttmpl = DECL_TI_TEMPLATE (t);\n-\tgen_tmpl = most_general_template (tmpl);\n-\targvec = tsubst (DECL_TI_ARGS (t), args, /*complain=*/1, in_decl);\n-\tif (ctx)\n-\t  spec = retrieve_specialization (gen_tmpl, argvec);\n+\tif (!local_p)\n+\t  {\n+\t    tmpl = DECL_TI_TEMPLATE (t);\n+\t    gen_tmpl = most_general_template (tmpl);\n+\t    argvec = tsubst (DECL_TI_ARGS (t), args, /*complain=*/1, in_decl);\n+\t    spec = retrieve_specialization (gen_tmpl, argvec);\n+\t  }\n \telse\n-\t  spec = retrieve_local_specialization (gen_tmpl,\n-\t\t\t\t\t\tcurrent_function_decl);\n+\t  spec = retrieve_local_specialization (t);\n \n \tif (spec)\n \t  {\n@@ -5929,19 +5935,20 @@ tsubst_decl (t, args, type, in_decl)\n \tif (TREE_CODE (r) == VAR_DECL)\n \t  DECL_DEAD_FOR_LOCAL (r) = 0;\n \n-\t/* A static data member declaration is always marked external\n-\t   when it is declared in-class, even if an initializer is\n-\t   present.  We mimic the non-template processing here.  */\n-\tif (ctx)\n-\t  DECL_EXTERNAL (r) = 1;\n+\tif (!local_p)\n+\t  {\n+\t    /* A static data member declaration is always marked\n+\t       external when it is declared in-class, even if an\n+\t       initializer is present.  We mimic the non-template\n+\t       processing here.  */\n+\t    DECL_EXTERNAL (r) = 1;\n \n-\tDECL_TEMPLATE_INFO (r) = tree_cons (tmpl, argvec, NULL_TREE);\n-\tSET_DECL_IMPLICIT_INSTANTIATION (r);\n-\tif (ctx)\n-\t  register_specialization (r, gen_tmpl, argvec);\n+\t    register_specialization (r, gen_tmpl, argvec);\n+\t    DECL_TEMPLATE_INFO (r) = tree_cons (tmpl, argvec, NULL_TREE);\n+\t    SET_DECL_IMPLICIT_INSTANTIATION (r);\n+\t  }\n \telse\n-\t  register_local_specialization (r, gen_tmpl,\n-\t\t\t\t\t current_function_decl);\n+\t  register_local_specialization (r, t);\n \n \tTREE_CHAIN (r) = NULL_TREE;\n \tif (TREE_CODE (r) == VAR_DECL && TREE_CODE (type) == VOID_TYPE)\n@@ -9616,6 +9623,13 @@ instantiate_decl (d, defer_ok)\n     }\n   else if (TREE_CODE (d) == FUNCTION_DECL)\n     {\n+      /* Set up the list of local specializations.  */\n+      my_friendly_assert (local_specializations == NULL, 20000422);\n+      local_specializations = htab_create (37, \n+\t\t\t\t\t   htab_hash_pointer,\n+\t\t\t\t\t   htab_eq_pointer,\n+\t\t\t\t\t   NULL);\n+\n       /* Set up context.  */\n       start_function (NULL_TREE, d, NULL_TREE, SF_PRE_PARSED);\n       store_parm_decls ();\n@@ -9628,6 +9642,10 @@ instantiate_decl (d, defer_ok)\n       tsubst_expr (DECL_SAVED_TREE (code_pattern), args,\n \t\t   /*complain=*/1, tmpl);\n \n+      /* We don't need the local specializations any more.  */\n+      htab_delete (local_specializations);\n+      local_specializations = NULL;\n+\n       /* Finish the function.  */\n       expand_body (finish_function (0));\n     }"}]}