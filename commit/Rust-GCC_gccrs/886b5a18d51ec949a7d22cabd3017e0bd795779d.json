{"sha": "886b5a18d51ec949a7d22cabd3017e0bd795779d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODg2YjVhMThkNTFlYzk0OWE3ZDIyY2FiZDMwMTdlMGJkNzk1Nzc5ZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-09-06T09:02:44Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-09-06T09:02:44Z"}, "message": "[multiple changes]\n\n2011-09-06  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch6.adb: Fix minor typo.\n\n2011-09-06  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch7.adb: Remove with and use clauses for Get_Targ.\n\t(Alignment_Of): Moved to the body of Nearest_Multiple_Rounded_Up.\n\t(Double_Size_Of): Alphabetized. Update the comment on usage.\n\t(Make_Finalize_Address_Stmts): Update comments and reformat code.\n\t(Nearest_Multiple_Rounded_Up): New routine.\n\t(Size_Of): Update comment on usage. The generated expression now\n\taccounts for alignment gaps by rounding the size of the type to the\n\tnearest multiple rounded up of the type's alignment.\n\nFrom-SVN: r178572", "tree": {"sha": "a6caccd6303fc6811faee64668072278560f5844", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6caccd6303fc6811faee64668072278560f5844"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/886b5a18d51ec949a7d22cabd3017e0bd795779d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/886b5a18d51ec949a7d22cabd3017e0bd795779d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/886b5a18d51ec949a7d22cabd3017e0bd795779d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/886b5a18d51ec949a7d22cabd3017e0bd795779d/comments", "author": null, "committer": null, "parents": [{"sha": "57a3fca931cc9e6d2e993d86f6366d875dfb9ebd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57a3fca931cc9e6d2e993d86f6366d875dfb9ebd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57a3fca931cc9e6d2e993d86f6366d875dfb9ebd"}], "stats": {"total": 351, "additions": 186, "deletions": 165}, "files": [{"sha": "455ecc11740e03d7163f8232bb57f22c32ede73d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/886b5a18d51ec949a7d22cabd3017e0bd795779d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/886b5a18d51ec949a7d22cabd3017e0bd795779d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=886b5a18d51ec949a7d22cabd3017e0bd795779d", "patch": "@@ -1,3 +1,18 @@\n+2011-09-06  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch6.adb: Fix minor typo.\n+\n+2011-09-06  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch7.adb: Remove with and use clauses for Get_Targ.\n+\t(Alignment_Of): Moved to the body of Nearest_Multiple_Rounded_Up.\n+\t(Double_Size_Of): Alphabetized. Update the comment on usage.\n+\t(Make_Finalize_Address_Stmts): Update comments and reformat code.\n+\t(Nearest_Multiple_Rounded_Up): New routine.\n+\t(Size_Of): Update comment on usage. The generated expression now\n+\taccounts for alignment gaps by rounding the size of the type to the\n+\tnearest multiple rounded up of the type's alignment.\n+\n 2011-09-06  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_ch7.adb, g-comlin.adb: Minor reformatting."}, {"sha": "23558e0a787755652885ba443004961bfc97c5d9", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/886b5a18d51ec949a7d22cabd3017e0bd795779d/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/886b5a18d51ec949a7d22cabd3017e0bd795779d/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=886b5a18d51ec949a7d22cabd3017e0bd795779d", "patch": "@@ -2849,10 +2849,10 @@ package body Exp_Ch6 is\n \n                   --  The \"innermost master that evaluates the function call\".\n \n-                  --  ??? -  Shpuld we use Integer'Last here instead\n-                  --  in order to deal with (some of) the problems\n-                  --  associated with calls to subps whose enclosing\n-                  --  scope is unknown (e.g., Anon_Access_To_Subp_Param.all)?\n+                  --  ??? - Should we use Integer'Last here instead in order\n+                  --  to deal with (some of) the problems associated with\n+                  --  calls to subps whose enclosing scope is unknown (e.g.,\n+                  --  Anon_Access_To_Subp_Param.all)?\n \n                   Level := Make_Integer_Literal (Loc,\n                              Scope_Depth (Current_Scope) + 1);"}, {"sha": "5ba3bc4fa801892990bd6c01553afc8526eb672a", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 167, "deletions": 161, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/886b5a18d51ec949a7d22cabd3017e0bd795779d/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/886b5a18d51ec949a7d22cabd3017e0bd795779d/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=886b5a18d51ec949a7d22cabd3017e0bd795779d", "patch": "@@ -80,18 +80,18 @@ package body Exp_Ch7 is\n    --  unconstrained or tagged values) may appear in 3 different contexts which\n    --  lead to 3 different kinds of transient scope expansion:\n \n-   --   1. In a simple statement (procedure call, assignment, ...). In\n-   --      this case the instruction is wrapped into a transient block.\n-   --      (See Wrap_Transient_Statement for details)\n+   --   1. In a simple statement (procedure call, assignment, ...). In this\n+   --      case the instruction is wrapped into a transient block. See\n+   --      Wrap_Transient_Statement for details.\n \n    --   2. In an expression of a control structure (test in a IF statement,\n-   --      expression in a CASE statement, ...).\n-   --      (See Wrap_Transient_Expression for details)\n+   --      expression in a CASE statement, ...). See Wrap_Transient_Expression\n+   --      for details.\n \n    --   3. In a expression of an object_declaration. No wrapping is possible\n    --      here, so the finalization actions, if any, are done right after the\n    --      declaration and the secondary stack deallocation is done in the\n-   --      proper enclosing scope (see Wrap_Transient_Declaration for details)\n+   --      proper enclosing scope. See Wrap_Transient_Declaration for details.\n \n    --  Note about functions returning tagged types: it has been decided to\n    --  always allocate their result in the secondary stack, even though is not\n@@ -185,11 +185,10 @@ package body Exp_Ch7 is\n    --  access type definition otherwise, this is the chain of the current\n    --  scope.\n \n-   --  Adjust Calls: They are generated on 2 occasions: (1) for\n-   --  declarations or dynamic allocations of Controlled objects with an\n-   --  initial value. (2) after an assignment. In the first case they are\n-   --  followed by an attachment to the final chain, in the second case\n-   --  they are not.\n+   --  Adjust Calls: They are generated on 2 occasions: (1) for declarations\n+   --  or dynamic allocations of Controlled objects with an initial value.\n+   --  (2) after an assignment. In the first case they are followed by an\n+   --  attachment to the final chain, in the second case they are not.\n \n    --  Finalization Calls: They are generated on (1) scope exit, (2)\n    --  assignments, (3) unchecked deallocations. In case (3) they have to\n@@ -226,6 +225,7 @@ package body Exp_Ch7 is\n    --       end record;\n    --       W : R;\n    --       Z : R := (C => X);\n+\n    --    begin\n    --       X := Y;\n    --       W := Z;\n@@ -499,7 +499,7 @@ package body Exp_Ch7 is\n       --  has entries, call the entry service routine.\n \n       --  NOTE: The generated code references _object, a parameter to the\n-      --        procedure.\n+      --  procedure.\n \n       elsif Is_Protected_Body then\n          declare\n@@ -1060,7 +1060,6 @@ package body Exp_Ch7 is\n       Components_Built : Boolean := False;\n       --  A flag used to avoid double initialization of entities and lists. If\n       --  the flag is set then the following variables have been initialized:\n-      --\n       --    Counter_Id\n       --    Finalizer_Decls\n       --    Finalizer_Stmts\n@@ -1080,8 +1079,7 @@ package body Exp_Ch7 is\n       Finalizer_Decls : List_Id := No_List;\n       --  Local variable declarations. This list holds the label declarations\n       --  of all jump block alternatives as well as the declaration of the\n-      --  local exception occurence and the raised flag.\n-      --\n+      --  local exception occurence and the raised flag:\n       --     E : Exception_Occurrence;\n       --     Raised : Boolean := False;\n       --     L<counter value> : label;\n@@ -1537,12 +1535,10 @@ package body Exp_Ch7 is\n \n          Fin_Body :=\n            Make_Subprogram_Body (Loc,\n-             Specification =>\n+             Specification              =>\n                Make_Procedure_Specification (Loc,\n                  Defining_Unit_Name => Body_Id),\n-\n-             Declarations => Finalizer_Decls,\n-\n+             Declarations               => Finalizer_Decls,\n              Handled_Statement_Sequence =>\n                Make_Handled_Sequence_Of_Statements (Loc, Finalizer_Stmts));\n \n@@ -1775,15 +1771,15 @@ package body Exp_Ch7 is\n                   null;\n \n                --  Transient variables are treated separately in order to\n-               --  minimize the size of the generated code. See Process_\n-               --  Transient_Objects.\n+               --  minimize the size of the generated code. For details, see\n+               --  Process_Transient_Objects.\n \n                elsif Is_Processed_Transient (Obj_Id) then\n                   null;\n \n                --  The object is of the form:\n                --    Obj : Typ [:= Expr];\n-               --\n+\n                --  Do not process the incomplete view of a deferred constant.\n                --  Do not consider tag-to-class-wide conversions.\n \n@@ -1797,7 +1793,7 @@ package body Exp_Ch7 is\n \n                --  The object is of the form:\n                --    Obj : Access_Typ := Non_BIP_Function_Call'reference;\n-               --\n+\n                --    Obj : Access_Typ :=\n                --            BIP_Function_Call\n                --              (..., BIPaccess => null, ...)'reference;\n@@ -1841,11 +1837,11 @@ package body Exp_Ch7 is\n                --        protected Prot is\n                --           procedure Do_Something (Obj : in out Ctrl);\n                --        end Prot;\n-               --\n+\n                --        protected body Prot is\n                --           procedure Do_Something (Obj : in out Ctrl) is ...\n                --        end Prot;\n-               --\n+\n                --        procedure Finalize (Obj : in out Ctrl) is\n                --        begin\n                --           Prot.Do_Something (Obj);\n@@ -2056,7 +2052,6 @@ package body Exp_Ch7 is\n          --          type Ptr_Typ is access Obj_Typ;\n          --          for Ptr_Typ'Storage_Pool\n          --            use Base_Pool (BIPfinalizationmaster);\n-         --\n          --       begin\n          --          Free (Ptr_Typ (Temp));\n          --       end;\n@@ -2273,11 +2268,9 @@ package body Exp_Ch7 is\n                      end if;\n \n                      return\n-                         (Present (Deep_Init)\n-                           and then Call_Ent = Deep_Init)\n-                       or else\n-                         (Present (Init)\n-                           and then Call_Ent = Init);\n+                       (Present (Deep_Init) and then Call_Ent = Deep_Init)\n+                         or else\n+                       (Present (Init)      and then Call_Ent = Init);\n                   end;\n                end if;\n \n@@ -2446,8 +2439,8 @@ package body Exp_Ch7 is\n \n          Label_Id :=\n            Make_Identifier (Loc, New_External_Name ('L', Counter_Val));\n-         Set_Entity (Label_Id,\n-                     Make_Defining_Identifier (Loc, Chars (Label_Id)));\n+         Set_Entity\n+           (Label_Id, Make_Defining_Identifier (Loc, Chars (Label_Id)));\n          Label := Make_Label (Loc, Label_Id);\n \n          Prepend_To (Finalizer_Decls,\n@@ -2482,14 +2475,14 @@ package body Exp_Ch7 is\n \n             if Is_Simple_Protected_Type (Obj_Typ) then\n                Fin_Call := Cleanup_Protected_Object (Decl, Obj_Ref);\n+\n                if Present (Fin_Call) then\n                   Fin_Stmts := New_List (Fin_Call);\n                end if;\n \n             elsif Has_Simple_Protected_Object (Obj_Typ) then\n                if Is_Record_Type (Obj_Typ) then\n                   Fin_Stmts := Cleanup_Record (Decl, Obj_Ref, Obj_Typ);\n-\n                elsif Is_Array_Type (Obj_Typ) then\n                   Fin_Stmts := Cleanup_Array (Decl, Obj_Ref, Obj_Typ);\n                end if;\n@@ -2499,7 +2492,7 @@ package body Exp_Ch7 is\n             --    begin\n             --       System.Tasking.Protected_Objects.Finalize_Protection\n             --         (Obj._object);\n-            --\n+\n             --    exception\n             --       when others =>\n             --          null;\n@@ -2529,7 +2522,7 @@ package body Exp_Ch7 is\n \n             --    begin                   --  Exception handlers allowed\n             --       [Deep_]Finalize (Obj);\n-            --\n+\n             --    exception\n             --       when Id : others =>\n             --          if not Raised then\n@@ -2565,15 +2558,14 @@ package body Exp_Ch7 is\n \n             --  If we are dealing with a return object of a build-in-place\n             --  function, generate the following cleanup statements:\n-            --\n+\n             --    if BIPallocfrom > Secondary_Stack'Pos\n             --      and then BIPfinalizationmaster /= null\n             --    then\n             --       declare\n             --          type Ptr_Typ is access Obj_Typ;\n             --          for Ptr_Typ'Storage_Pool use\n             --                Base_Pool (BIPfinalizationmaster.all).all;\n-            --\n             --       begin\n             --          Free (Ptr_Typ (Temp));\n             --       end;\n@@ -2601,7 +2593,7 @@ package body Exp_Ch7 is\n                --  Return objects use a flag to aid their potential\n                --  finalization when the enclosing function fails to return\n                --  properly. Generate:\n-               --\n+\n                --    if not Flag then\n                --       <object finalization statements>\n                --    end if;\n@@ -2684,7 +2676,7 @@ package body Exp_Ch7 is\n \n          Append_To (Tagged_Type_Stmts,\n            Make_Procedure_Call_Statement (Loc,\n-             Name =>\n+             Name                   =>\n                New_Reference_To (RTE (RE_Unregister_Tag), Loc),\n              Parameter_Associations => New_List (\n                New_Reference_To (DT_Ptr, Loc))));\n@@ -2872,14 +2864,14 @@ package body Exp_Ch7 is\n       --  finalizer call needs to be associated with the block which wraps the\n       --  unprotected version of the subprogram. The following illustrates this\n       --  scenario:\n-      --\n+\n       --     procedure Prot_SubpP is\n       --        procedure finalizer is\n       --        begin\n       --           Service_Entries (Prot_Obj);\n       --           Abort_Undefer;\n       --        end finalizer;\n-      --\n+\n       --     begin\n       --        . . .\n       --        begin\n@@ -3988,10 +3980,9 @@ package body Exp_Ch7 is\n             when N_Pragma =>\n                return The_Parent;\n \n-            --  Usually assignments are good candidate for wrapping\n-            --  except when they have been generated as part of a\n-            --  controlled aggregate where the wrapping should take\n-            --  place more globally.\n+            --  Usually assignments are good candidate for wrapping except\n+            --  when they have been generated as part of a controlled aggregate\n+            --  where the wrapping should take place more globally.\n \n             when N_Assignment_Statement =>\n                if No_Ctrl_Actions (The_Parent) then\n@@ -4000,9 +3991,9 @@ package body Exp_Ch7 is\n                   return The_Parent;\n                end if;\n \n-            --  An entry call statement is a special case if it occurs in\n-            --  the context of a Timed_Entry_Call. In this case we wrap\n-            --  the entire timed entry call.\n+            --  An entry call statement is a special case if it occurs in the\n+            --  context of a Timed_Entry_Call. In this case we wrap the entire\n+            --  timed entry call.\n \n             when N_Entry_Call_Statement     |\n                  N_Procedure_Call_Statement =>\n@@ -4017,8 +4008,8 @@ package body Exp_Ch7 is\n                end if;\n \n             --  Object declarations are also a boundary for the transient scope\n-            --  even if they are not really wrapped\n-            --  (see Wrap_Transient_Declaration)\n+            --  even if they are not really wrapped. For further details, see\n+            --  Wrap_Transient_Declaration.\n \n             when N_Object_Declaration          |\n                  N_Object_Renaming_Declaration |\n@@ -4067,8 +4058,8 @@ package body Exp_Ch7 is\n             when N_Loop_Parameter_Specification =>\n                return Parent (The_Parent);\n \n-            --  The following nodes contains \"dummy calls\" which don't\n-            --  need to be wrapped.\n+            --  The following nodes contains \"dummy calls\" which don't need to\n+            --  be wrapped.\n \n             when N_Parameter_Specification     |\n                  N_Discriminant_Specification  |\n@@ -4103,7 +4094,7 @@ package body Exp_Ch7 is\n                  N_Block_Statement     =>\n                return Empty;\n \n-            --  otherwise continue the search\n+            --  Otherwise continue the search\n \n             when others =>\n                null;\n@@ -4117,11 +4108,11 @@ package body Exp_Ch7 is\n \n    function Get_Global_Pool_For_Access_Type (T : Entity_Id) return Entity_Id is\n    begin\n-      --  Access types whose size is smaller than System.Address size can\n-      --  exist only on VMS. We can't use the usual global pool which returns\n-      --  an object of type Address as truncation will make it invalid.\n-      --  To handle this case, VMS has a dedicated global pool that returns\n-      --  addresses that fit into 32 bit accesses.\n+      --  Access types whose size is smaller than System.Address size can exist\n+      --  only on VMS. We can't use the usual global pool which returns an\n+      --  object of type Address as truncation will make it invalid. To handle\n+      --  this case, VMS has a dedicated global pool that returns addresses\n+      --  that fit into 32 bit accesses.\n \n       if Opt.True_VMS_Target and then Esize (T) = 32 then\n          return RTE (RE_Global_Pool_32_Object);\n@@ -4386,9 +4377,7 @@ package body Exp_Ch7 is\n                end if;\n \n                Append_To (Stmts,\n-                 Make_Final_Call\n-                   (Obj_Ref => Obj_Ref,\n-                    Typ     => Desig_Typ));\n+                 Make_Final_Call (Obj_Ref => Obj_Ref, Typ => Desig_Typ));\n \n                --  Generate:\n                --    [Temp := null;]\n@@ -4426,8 +4415,9 @@ package body Exp_Ch7 is\n             --  the loop.\n \n             elsif Nkind (Related_Node) = N_Object_Declaration\n-              and then Is_Array_Type (Base_Type\n-                         (Etype (Defining_Identifier (Related_Node))))\n+              and then Is_Array_Type\n+                         (Base_Type\n+                           (Etype (Defining_Identifier (Related_Node))))\n               and then Nkind (Stmt) = N_Loop_Statement\n             then\n                declare\n@@ -4841,11 +4831,11 @@ package body Exp_Ch7 is\n       --                         ...\n       --                      end loop;\n       --                   end;\n-\n+      --\n       --                   if Raised and then not Abort then\n       --                      Raise_From_Controlled_Operation (E);\n       --                   end if;\n-\n+      --\n       --                   raise;\n       --             end;\n       --          end loop;\n@@ -5911,27 +5901,27 @@ package body Exp_Ch7 is\n \n          --  A derived record type must adjust all inherited components. This\n          --  action poses the following problem:\n-         --\n+\n          --    procedure Deep_Adjust (Obj : in out Parent_Typ) is\n          --    begin\n          --       Adjust (Obj);\n          --       ...\n-         --\n+\n          --    procedure Deep_Adjust (Obj : in out Derived_Typ) is\n          --    begin\n          --       Deep_Adjust (Obj._parent);\n          --       ...\n          --       Adjust (Obj);\n          --       ...\n-         --\n+\n          --  Adjusting the derived type will invoke Adjust of the parent and\n          --  then that of the derived type. This is undesirable because both\n          --  routines may modify shared components. Only the Adjust of the\n          --  derived type should be invoked.\n-         --\n+\n          --  To prevent this double adjustment of shared components,\n          --  Deep_Adjust uses a flag to control the invocation of Adjust:\n-         --\n+\n          --    procedure Deep_Adjust\n          --      (Obj  : in out Some_Type;\n          --       Flag : Boolean := True)\n@@ -5941,10 +5931,10 @@ package body Exp_Ch7 is\n          --          Adjust (Obj);\n          --       end if;\n          --       ...\n-         --\n+\n          --  When Deep_Adjust is invokes for field _parent, a value of False is\n          --  provided for the flag:\n-         --\n+\n          --    Deep_Adjust (Obj._parent, False);\n \n          if Is_Tagged_Type (Typ) and then Is_Derived_Type (Typ) then\n@@ -5989,8 +5979,7 @@ package body Exp_Ch7 is\n                               Make_Handled_Sequence_Of_Statements (Loc,\n                                 Statements         => New_List (Adj_Stmt),\n                                 Exception_Handlers => New_List (\n-                                  Build_Exception_Handler\n-                                    (Finalizer_Data))));\n+                                  Build_Exception_Handler (Finalizer_Data))));\n                      end if;\n \n                      Prepend_To (Bod_Stmts, Adj_Stmt);\n@@ -6489,27 +6478,27 @@ package body Exp_Ch7 is\n \n          --  A derived record type must finalize all inherited components. This\n          --  action poses the following problem:\n-         --\n+\n          --    procedure Deep_Finalize (Obj : in out Parent_Typ) is\n          --    begin\n          --       Finalize (Obj);\n          --       ...\n-         --\n+\n          --    procedure Deep_Finalize (Obj : in out Derived_Typ) is\n          --    begin\n          --       Deep_Finalize (Obj._parent);\n          --       ...\n          --       Finalize (Obj);\n          --       ...\n-         --\n+\n          --  Finalizing the derived type will invoke Finalize of the parent and\n          --  then that of the derived type. This is undesirable because both\n          --  routines may modify shared components. Only the Finalize of the\n          --  derived type should be invoked.\n-         --\n+\n          --  To prevent this double adjustment of shared components,\n          --  Deep_Finalize uses a flag to control the invocation of Finalize:\n-         --\n+\n          --    procedure Deep_Finalize\n          --      (Obj  : in out Some_Type;\n          --       Flag : Boolean := True)\n@@ -6519,10 +6508,10 @@ package body Exp_Ch7 is\n          --          Finalize (Obj);\n          --       end if;\n          --       ...\n-         --\n+\n          --  When Deep_Finalize is invokes for field _parent, a value of False\n          --  is provided for the flag:\n-         --\n+\n          --    Deep_Finalize (Obj._parent, False);\n \n          if Is_Tagged_Type (Typ)\n@@ -6537,7 +6526,7 @@ package body Exp_Ch7 is\n                if Needs_Finalization (Par_Typ) then\n                   Call :=\n                     Make_Final_Call\n-                      (Obj_Ref =>\n+                      (Obj_Ref    =>\n                          Make_Selected_Component (Loc,\n                            Prefix        => Make_Identifier (Loc, Name_V),\n                            Selector_Name =>\n@@ -6858,7 +6847,7 @@ package body Exp_Ch7 is\n          Set_Assignment_OK (Ref);\n       end if;\n \n-      --  Select the appropriate version of finalize\n+      --  Select the appropriate version of Finalize\n \n       if For_Parent then\n          if Has_Controlled_Component (Utyp) then\n@@ -6971,8 +6960,8 @@ package body Exp_Ch7 is\n         or else Present (TSS (Typ, TSS_Finalize_Address))\n         or else\n           (Is_Class_Wide_Type (Typ)\n-             and then Ekind (Root_Type (Typ)) = E_Record_Subtype\n-             and then not Comes_From_Source (Root_Type (Typ)))\n+            and then Ekind (Root_Type (Typ)) = E_Record_Subtype\n+            and then not Comes_From_Source (Root_Type (Typ)))\n       then\n          return;\n       end if;\n@@ -6982,10 +6971,11 @@ package body Exp_Ch7 is\n           Make_TSS_Name (Typ, TSS_Finalize_Address));\n \n       --  Generate:\n+\n       --    procedure <Typ>FD (V : System.Address) is\n       --    begin\n       --       null;                            --  for tasks\n-      --\n+\n       --       declare                          --  for all other types\n       --          type Pnn is access all Typ;\n       --          for Pnn'Storage_Size use 0;\n@@ -7033,29 +7023,77 @@ package body Exp_Ch7 is\n       Desg_Typ : Entity_Id;\n       Obj_Expr : Node_Id;\n \n-      function Alignment_Of (Typ : Entity_Id) return Node_Id;\n-      --  Subsidiary routine, generate the following attribute reference:\n-      --    Typ'Alignment\n+      function Double_Size_Of (Typ : Entity_Id) return Node_Id;\n+      --  Subsidiary routine, produces an expression which calculates double\n+      --  the size of Typ as the nearest multiple of its alignment rounded up.\n+\n+      function Nearest_Multiple_Rounded_Up\n+        (Size_Expr : Node_Id;\n+         Typ       : Entity_Id) return Node_Id;\n+      --  Subsidiary routine, generate the following expression:\n+      --    ((Size_Expr + Typ'Alignment - 1) / Typ'Alignment) * Typ'Alignment\n \n       function Size_Of (Typ : Entity_Id) return Node_Id;\n-      --  Subsidiary routine, generate the following attribute reference:\n-      --    Typ'Size / Storage_Unit\n+      --  Subsidiary routine, produces an expression which calculates the size\n+      --  of Typ as the nearest multiple of its alignment rounded up.\n \n-      function Double_Size_Of (Typ : Entity_Id) return Node_Id;\n-      --  Subsidiary routine, generate the following expression:\n-      --    2 * Typ'Size / Storage_Unit\n+      --------------------\n+      -- Double_Size_Of --\n+      --------------------\n+\n+      function Double_Size_Of (Typ : Entity_Id) return Node_Id is\n+      begin\n+         return\n+           Make_Op_Multiply (Loc,\n+             Left_Opnd  => Make_Integer_Literal (Loc, 2),\n+             Right_Opnd => Size_Of (Typ));\n+      end Double_Size_Of;\n+\n+      ---------------------------------\n+      -- Nearest_Multiple_Rounded_Up --\n+      ---------------------------------\n+\n+      function Nearest_Multiple_Rounded_Up\n+        (Size_Expr : Node_Id;\n+         Typ       : Entity_Id) return Node_Id\n+      is\n+         function Alignment_Of (Typ : Entity_Id) return Node_Id;\n+         --  Subsidiary routine, generate the following attribute reference:\n+         --    Typ'Alignment\n+\n+         ------------------\n+         -- Alignment_Of --\n+         ------------------\n+\n+         function Alignment_Of (Typ : Entity_Id) return Node_Id is\n+         begin\n+            return\n+              Make_Attribute_Reference (Loc,\n+                Prefix         => New_Reference_To (Typ, Loc),\n+                Attribute_Name => Name_Alignment);\n+         end Alignment_Of;\n \n-      ------------------\n-      -- Alignment_Of --\n-      ------------------\n+      --  Start of processing for Nearest_Multiple_Rounded_Up\n \n-      function Alignment_Of (Typ : Entity_Id) return Node_Id is\n       begin\n+         --  Generate:\n+         --    ((Size_Expr + Typ'Alignment - 1) / Typ'Alignment) *\n+         --                                           Typ'Alignment\n+\n          return\n-           Make_Attribute_Reference (Loc,\n-             Prefix         => New_Reference_To (Typ, Loc),\n-             Attribute_Name => Name_Alignment);\n-      end Alignment_Of;\n+           Make_Op_Multiply (Loc,\n+             Left_Opnd  =>\n+               Make_Op_Divide (Loc,\n+                 Left_Opnd  =>\n+                   Make_Op_Add (Loc,\n+                     Left_Opnd  => Size_Expr,\n+                     Right_Opnd =>\n+                       Make_Op_Subtract (Loc,\n+                         Left_Opnd  => Alignment_Of (Typ),\n+                         Right_Opnd => Make_Integer_Literal (Loc, 1))),\n+                 Right_Opnd => Alignment_Of (Typ)),\n+             Right_Opnd => Alignment_Of (Typ));\n+      end Nearest_Multiple_Rounded_Up;\n \n       -------------\n       -- Size_Of --\n@@ -7064,27 +7102,18 @@ package body Exp_Ch7 is\n       function Size_Of (Typ : Entity_Id) return Node_Id is\n       begin\n          return\n-           Make_Op_Divide (Loc,\n-             Left_Opnd  =>\n-               Make_Attribute_Reference (Loc,\n-                 Prefix         => New_Reference_To (Typ, Loc),\n-                 Attribute_Name => Name_Size),\n-             Right_Opnd =>\n-               Make_Integer_Literal (Loc, System_Storage_Unit));\n+           Nearest_Multiple_Rounded_Up\n+             (Size_Expr =>\n+                Make_Op_Divide (Loc,\n+                  Left_Opnd  =>\n+                    Make_Attribute_Reference (Loc,\n+                      Prefix         => New_Reference_To (Typ, Loc),\n+                      Attribute_Name => Name_Size),\n+                  Right_Opnd =>\n+                    Make_Integer_Literal (Loc, System_Storage_Unit)),\n+              Typ => Typ);\n       end Size_Of;\n \n-      --------------------\n-      -- Double_Size_Of --\n-      --------------------\n-\n-      function Double_Size_Of (Typ : Entity_Id) return Node_Id is\n-      begin\n-         return\n-           Make_Op_Multiply (Loc,\n-             Left_Opnd  => Make_Integer_Literal (Loc, 2),\n-             Right_Opnd => Size_Of (Typ));\n-      end Double_Size_Of;\n-\n    --  Start of processing for Make_Finalize_Address_Stmts\n \n    begin\n@@ -7103,11 +7132,12 @@ package body Exp_Ch7 is\n           Is_Empty_Elmt_List (Discriminant_Constraint (Root_Type (Typ)))\n       then\n          declare\n-            Parent_Typ : Entity_Id := Root_Type (Typ);\n+            Parent_Typ : Entity_Id;\n \n          begin\n             --  Climb the parent type chain looking for a non-constrained type\n \n+            Parent_Typ := Root_Type (Typ);\n             while Parent_Typ /= Etype (Parent_Typ)\n               and then Has_Discriminants (Parent_Typ)\n               and then not\n@@ -7168,7 +7198,6 @@ package body Exp_Ch7 is\n \n          begin\n             --  Ensure that Ptr_Typ a thin pointer, generate:\n-            --\n             --    for Ptr_Typ'Size use System.Address'Size;\n \n             Append_To (Decls,\n@@ -7190,16 +7219,9 @@ package body Exp_Ch7 is\n \n                if For_First then\n                   For_First := False;\n-\n-                  --  Generate:\n-                  --    2 * Index_Typ'Size / Storage_Unit\n-\n                   Dope_Expr := Double_Size_Of (Index_Typ);\n \n                else\n-                  --  Generate:\n-                  --    Dope_Expr + 2 * Index_Typ'Size / Storage_Unit\n-\n                   Dope_Expr :=\n                     Make_Op_Add (Loc,\n                       Left_Opnd  => Dope_Expr,\n@@ -7209,28 +7231,13 @@ package body Exp_Ch7 is\n                Next_Index (Index);\n             end loop;\n \n-            --  Dope_Expr calculates the optimum size of the dope, as if the\n-            --  dope was \"packed\". Since the alignment of the component type\n-            --  dictates the underlying layout of the array, round the size\n-            --  of the dope to the next higher multiple of the component\n-            --  alignment. Generate:\n-\n-            --    ((Dope_Expr + Typ'Alignment - 1) / Typ'Alignment) *\n-            --        Typ'Alignment\n-\n-            Dope_Expr :=\n-              Make_Op_Multiply (Loc,\n-                Left_Opnd  =>\n-                  Make_Op_Divide (Loc,\n-                    Left_Opnd  =>\n-                      Make_Op_Add (Loc,\n-                        Left_Opnd  => Dope_Expr,\n-                        Right_Opnd =>\n-                          Make_Op_Subtract (Loc,\n-                            Left_Opnd  => Alignment_Of (Typ),\n-                            Right_Opnd => Make_Integer_Literal (Loc, 1))),\n-                    Right_Opnd => Alignment_Of (Typ)),\n-                Right_Opnd => Alignment_Of (Typ));\n+            --  Dope_Expr calculates the size of the dope, acounting for\n+            --  individual alignment holes on the index type level. Since the\n+            --  alignment of the component type dictates the underlying layout\n+            --  of the array, round the size of the dope to the next higher\n+            --  multiple of the component alignment.\n+\n+            Dope_Expr := Nearest_Multiple_Rounded_Up (Dope_Expr, Typ);\n \n             --  Generate:\n             --    Dnn : Storage_Offset := Dope_Expr;\n@@ -7592,10 +7599,9 @@ package body Exp_Ch7 is\n                   Set_Uses_Sec_Stack (Current_Scope, False);\n                   exit;\n \n-               --  In a function, only release the sec stack if the\n-               --  function does not return on the sec stack otherwise\n-               --  the result may be lost. The caller is responsible for\n-               --  releasing.\n+               --  In a function, only release the sec stack if the function\n+               --  does not return on the sec stack otherwise the result may\n+               --  be lost. The caller is responsible for releasing.\n \n                elsif Ekind (S) = E_Function then\n                   Set_Uses_Sec_Stack (Current_Scope, False);\n@@ -7652,10 +7658,10 @@ package body Exp_Ch7 is\n          Freeze_All (First_Entity (Current_Scope), Insert);\n       end if;\n \n-      --  When the transient scope was established, we pushed the entry for\n-      --  the transient scope onto the scope stack, so that the scope was\n-      --  active for the installation of finalizable entities etc. Now we\n-      --  must remove this entry, since we have constructed a proper block.\n+      --  When the transient scope was established, we pushed the entry for the\n+      --  transient scope onto the scope stack, so that the scope was active\n+      --  for the installation of finalizable entities etc. Now we must remove\n+      --  this entry, since we have constructed a proper block.\n \n       Pop_Scope;\n "}]}