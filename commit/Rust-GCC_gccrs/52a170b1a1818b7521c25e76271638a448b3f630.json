{"sha": "52a170b1a1818b7521c25e76271638a448b3f630", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJhMTcwYjFhMTgxOGI3NTIxYzI1ZTc2MjcxNjM4YTQ0OGIzZjYzMA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-01-12T10:17:33Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-01-12T14:17:24Z"}, "message": "tree-optimization/98550 - fix BB vect unrolling check\n\nThis fixes the check that disqualifies BB vectorization because of\nrequired unrolling to match up with the later exact_div we do.  To\nnot disable the ability to split groups that do not match up\nexactly with a choosen vector type this also introduces a soft-fail\nmechanism to vect_build_slp_tree_1 which delays failing to after\nthe matches[] array is populated from other checks and only then\ndetermines the split point according to the vector type.\n\n2021-01-12  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/98550\n\t* tree-vect-slp.c (vect_record_max_nunits): Check whether\n\tthe group size is a multiple of the vector element count.\n\t(vect_build_slp_tree_1): When we need to fail because\n\tthe vector type choosen causes unrolling do so lazily\n\twithout affecting matches only at the end to guide group splitting.\n\n\t* g++.dg/opt/pr98550.C: New testcase.", "tree": {"sha": "38a14497f302dc2adf2990fc71c6c4f77a8673ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38a14497f302dc2adf2990fc71c6c4f77a8673ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52a170b1a1818b7521c25e76271638a448b3f630", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52a170b1a1818b7521c25e76271638a448b3f630", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52a170b1a1818b7521c25e76271638a448b3f630", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52a170b1a1818b7521c25e76271638a448b3f630/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e91910d3576eeac714c93ec25ea3b15012007903", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e91910d3576eeac714c93ec25ea3b15012007903", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e91910d3576eeac714c93ec25ea3b15012007903"}], "stats": {"total": 136, "additions": 128, "deletions": 8}, "files": [{"sha": "49102e6c1a19a71982a726347d5b423abc6a84d0", "filename": "gcc/testsuite/g++.dg/opt/pr98550.C", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a170b1a1818b7521c25e76271638a448b3f630/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr98550.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a170b1a1818b7521c25e76271638a448b3f630/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr98550.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr98550.C?ref=52a170b1a1818b7521c25e76271638a448b3f630", "patch": "@@ -0,0 +1,96 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target c++11 } */\n+/* { dg-additional-options \"-O3\" } */\n+/* { dg-additional-options \"-march=z13\" { target s390x-*-* } } */\n+\n+template <int a> struct k { static constexpr int c = a; };\n+template <bool, bool, typename...> struct o;\n+template <typename f, typename... g> struct o<false, false, f, g...> {\n+  typedef decltype(0) h;\n+};\n+template <typename... g> struct p : o<k<false>::c, k<false>::c, g...> {};\n+class q;\n+class r {\n+public:\n+  void ap(q);\n+};\n+template <typename, typename aw> void ax(aw ay) { ay(); }\n+template <typename az> void ba(az bb) {\n+  using bc = p<az>;\n+  using bd = typename bc::h;\n+  ax<bd>(bb);\n+}\n+template <unsigned> class s;\n+class t {\n+public:\n+  s<8> br();\n+  template <typename...> void operator()() { ba(br()); }\n+};\n+class q {\n+public:\n+  template <typename az> q(az) { H(); }\n+  struct H {\n+    t cc;\n+    H() { cc(); }\n+  };\n+};\n+template <unsigned long> struct I {};\n+template <unsigned long cl, typename j> void cm(j cn, I<cl>) {\n+  cm(cn, I<cl - 1>());\n+  cn(cl);\n+}\n+template <typename j> void cm(j, I<0>) {}\n+template <unsigned co> struct u {\n+  long cp[co];\n+  void cq(const u &);\n+  void cs(int);\n+  void operator<(u);\n+};\n+template <unsigned co> void u<co>::cq(const u &l) {\n+  cm([&](int i) { cp[i] &= l.cp[i]; }, I<co>());\n+}\n+template <unsigned co> void u<co>::cs(int m) {\n+  cm([&](int i) { cp[i] >>= m; }, I<co - 2>());\n+}\n+template <unsigned> class K;\n+template <unsigned co> class v {\n+  int cv;\n+  friend K<co>;\n+\n+public:\n+  void cx(int, unsigned char *, unsigned long long);\n+};\n+template <unsigned co> class K {\n+public:\n+  static void cx(v<co> &);\n+};\n+template <unsigned co>\n+void v<co>::cx(int, unsigned char *, unsigned long long) {\n+  K<co>::cx(*this);\n+}\n+template <unsigned co> void K<co>::cx(v<co> &cz) {\n+  u<co> a, b, d;\n+  int e, n = cz.cv;\n+  for (; e;)\n+    if (cz.cv)\n+      a.cs(cz.cv);\n+  a.cq(d);\n+  a < b;\n+}\n+template <unsigned co> class s {\n+  v<co> *dh;\n+\n+public:\n+  void operator()();\n+};\n+template <unsigned co> void s<co>::operator()() {\n+  int f;\n+  unsigned char g;\n+  long h;\n+  dh->cx(f, &g, h);\n+}\n+void d() {\n+  r i;\n+  t j;\n+  i.ap(j);\n+}"}, {"sha": "65b7a27e1e889dbcbfbf33fd9017c6398c753d7b", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a170b1a1818b7521c25e76271638a448b3f630/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a170b1a1818b7521c25e76271638a448b3f630/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=52a170b1a1818b7521c25e76271638a448b3f630", "patch": "@@ -873,11 +873,8 @@ vect_record_max_nunits (vec_info *vinfo, stmt_vec_info stmt_info,\n \n   /* If populating the vector type requires unrolling then fail\n      before adjusting *max_nunits for basic-block vectorization.  */\n-  poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-  unsigned HOST_WIDE_INT const_nunits;\n   if (is_a <bb_vec_info> (vinfo)\n-      && (!nunits.is_constant (&const_nunits)\n-\t  || const_nunits > group_size))\n+      && !multiple_p (group_size, TYPE_VECTOR_SUBPARTS (vectype)))\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -928,6 +925,8 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n   stmt_vec_info first_load = NULL, prev_first_load = NULL;\n   bool first_stmt_load_p = false, load_p = false;\n   bool first_stmt_phi_p = false, phi_p = false;\n+  bool maybe_soft_fail = false;\n+  tree soft_fail_nunits_vectype = NULL_TREE;\n \n   /* For every stmt in NODE find its def stmt/s.  */\n   stmt_vec_info stmt_info;\n@@ -977,17 +976,25 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \n       tree nunits_vectype;\n       if (!vect_get_vector_types_for_stmt (vinfo, stmt_info, &vectype,\n-\t\t\t\t\t   &nunits_vectype, group_size)\n-\t  || (nunits_vectype\n-\t      && !vect_record_max_nunits (vinfo, stmt_info, group_size,\n-\t\t\t\t\t  nunits_vectype, max_nunits)))\n+\t\t\t\t\t   &nunits_vectype, group_size))\n \t{\n \t  if (is_a <bb_vec_info> (vinfo) && i != 0)\n \t    continue;\n \t  /* Fatal mismatch.  */\n \t  matches[0] = false;\n \t  return false;\n \t}\n+      /* Record nunits required but continue analysis, producing matches[]\n+\t as if nunits was not an issue.  This allows splitting of groups\n+\t to happen.  */\n+      if (nunits_vectype\n+\t  && !vect_record_max_nunits (vinfo, stmt_info, group_size,\n+\t\t\t\t      nunits_vectype, max_nunits))\n+\t{\n+\t  gcc_assert (is_a <bb_vec_info> (vinfo));\n+\t  maybe_soft_fail = true;\n+\t  soft_fail_nunits_vectype = nunits_vectype;\n+\t}\n \n       gcc_assert (vectype);\n \n@@ -1340,6 +1347,23 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n       *two_operators = true;\n     }\n \n+  if (maybe_soft_fail)\n+    {\n+      unsigned HOST_WIDE_INT const_nunits;\n+      if (!TYPE_VECTOR_SUBPARTS\n+\t    (soft_fail_nunits_vectype).is_constant (&const_nunits)\n+\t  || const_nunits > group_size)\n+\tmatches[0] = false;\n+      else\n+\t{\n+\t  /* With constant vector elements simulate a mismatch at the\n+\t     point we need to split.  */\n+\t  unsigned tail = group_size & (const_nunits - 1);\n+\t  memset (&matches[group_size - tail], 0, sizeof (bool) * tail);\n+\t}\n+      return false;\n+    }\n+\n   return true;\n }\n "}]}