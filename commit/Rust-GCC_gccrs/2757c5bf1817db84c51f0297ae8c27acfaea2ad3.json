{"sha": "2757c5bf1817db84c51f0297ae8c27acfaea2ad3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc1N2M1YmYxODE3ZGI4NGM1MWYwMjk3YWU4YzI3YWNmYWVhMmFkMw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-27T16:49:44Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-27T16:49:44Z"}, "message": "[multiple changes]\n\n2014-01-27  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* einfo.adb (Has_Option): Reimplemented.\n\t* sem_prag.adb (Analyze_Refinement_Clause): Add global\n\tvariables AR_Constit, AW_Constit, ER_Constit, EW_Constit,\n\tExternal_Constit_Seen and State. Add local variables Body_Ref,\n\tBody_Ref_Elmt and Extra_State. Reimplement part of the logic to\n\tavoid a cumbersome while pool. Verify the legality of an external\n\tstate and relevant properties.\n\t(Check_External_Property): New routine.\n\t(Check_Matching_State): Remove parameter profile\n\tand update comment on usage.\n\t(Collect_Constituent): Store the\n\trelevant external property of a constituent.\n\t* sem_util.adb (Async_Readers_Enabled): Update the call to\n\tHas_Enabled_Property.\n\t(Async_Writers_Enabled): Update the call to Has_Enabled_Property.\n\t(Effective_Reads_Enabled): Update the call to Has_Enabled_Property.\n\t(Effective_Writes_Enabled): Update the call to Has_Enabled_Property.\n\t(Has_Enabled_Property): Rename formal parameter Extern to State_Id.\n\tUpdate comment on usage. Reimplement the logic to recognize the various\n\tformats of properties.\n\n2014-01-27  Ed Schonberg  <schonberg@adacore.com>\n\n\t* par-ch5.adb: Minor reformatting.\n\n2014-01-27  Tristan Gingold  <gingold@adacore.com>\n\n\t* s-tposen.ads: Harmonize style and comments.\n\n2014-01-27  Vincent Celier  <celier@adacore.com>\n\n\t* projects.texi: Document that shared library projects, by\n\tdefault, cannot import projects that are not shared library\n\tprojects.\n\n2014-01-27  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch8.adb (Find_Selected_Component): Use Replace instead\n\tof Rewrite.\n\n2014-01-27  Ed Schonberg  <schonberg@adacore.com>\n\n\t* a-suenco.adb, a-suenst.adb (Decode): Raise encoding error if\n\tany other exception is raised.\n\t(Convert): If both Input_Scheme and Output_Scheme are UTF_8 it is\n\tstill necessary to perform a conversion in order to remove overlong\n\tencodings.\n\nFrom-SVN: r207142", "tree": {"sha": "23ccdddac0e9ac7aaa07cea606460acc2a741f6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23ccdddac0e9ac7aaa07cea606460acc2a741f6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2757c5bf1817db84c51f0297ae8c27acfaea2ad3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2757c5bf1817db84c51f0297ae8c27acfaea2ad3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2757c5bf1817db84c51f0297ae8c27acfaea2ad3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2757c5bf1817db84c51f0297ae8c27acfaea2ad3/comments", "author": null, "committer": null, "parents": [{"sha": "00ba7be81367fd082166105ab3e8b8f43d04051c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00ba7be81367fd082166105ab3e8b8f43d04051c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00ba7be81367fd082166105ab3e8b8f43d04051c"}], "stats": {"total": 615, "additions": 422, "deletions": 193}, "files": [{"sha": "4ef6ddae443b9e8476326c8ee4d456f789a86f84", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2757c5bf1817db84c51f0297ae8c27acfaea2ad3/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2757c5bf1817db84c51f0297ae8c27acfaea2ad3/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2757c5bf1817db84c51f0297ae8c27acfaea2ad3", "patch": "@@ -1,3 +1,53 @@\n+2014-01-27  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* einfo.adb (Has_Option): Reimplemented.\n+\t* sem_prag.adb (Analyze_Refinement_Clause): Add global\n+\tvariables AR_Constit, AW_Constit, ER_Constit, EW_Constit,\n+\tExternal_Constit_Seen and State. Add local variables Body_Ref,\n+\tBody_Ref_Elmt and Extra_State. Reimplement part of the logic to\n+\tavoid a cumbersome while pool. Verify the legality of an external\n+\tstate and relevant properties.\n+\t(Check_External_Property): New routine.\n+\t(Check_Matching_State): Remove parameter profile\n+\tand update comment on usage.\n+\t(Collect_Constituent): Store the\n+\trelevant external property of a constituent.\n+\t* sem_util.adb (Async_Readers_Enabled): Update the call to\n+\tHas_Enabled_Property.\n+\t(Async_Writers_Enabled): Update the call to Has_Enabled_Property.\n+\t(Effective_Reads_Enabled): Update the call to Has_Enabled_Property.\n+\t(Effective_Writes_Enabled): Update the call to Has_Enabled_Property.\n+\t(Has_Enabled_Property): Rename formal parameter Extern to State_Id.\n+\tUpdate comment on usage. Reimplement the logic to recognize the various\n+\tformats of properties.\n+\n+2014-01-27  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* par-ch5.adb: Minor reformatting.\n+\n+2014-01-27  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* s-tposen.ads: Harmonize style and comments.\n+\n+2014-01-27  Vincent Celier  <celier@adacore.com>\n+\n+\t* projects.texi: Document that shared library projects, by\n+\tdefault, cannot import projects that are not shared library\n+\tprojects.\n+\n+2014-01-27  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch8.adb (Find_Selected_Component): Use Replace instead\n+\tof Rewrite.\n+\n+2014-01-27  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* a-suenco.adb, a-suenst.adb (Decode): Raise encoding error if\n+\tany other exception is raised.\n+\t(Convert): If both Input_Scheme and Output_Scheme are UTF_8 it is\n+\tstill necessary to perform a conversion in order to remove overlong\n+\tencodings.\n+\n 2014-01-27  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_smem.adb: Minor reformatting."}, {"sha": "ea83123878bcf0a1e7ee9c3a74ffa44850b466f1", "filename": "gcc/ada/a-suenco.adb", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2757c5bf1817db84c51f0297ae8c27acfaea2ad3/gcc%2Fada%2Fa-suenco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2757c5bf1817db84c51f0297ae8c27acfaea2ad3/gcc%2Fada%2Fa-suenco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-suenco.adb?ref=2757c5bf1817db84c51f0297ae8c27acfaea2ad3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2010-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2010-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -41,9 +41,12 @@ package body Ada.Strings.UTF_Encoding.Conversions is\n       Output_BOM    : Boolean := False) return UTF_String\n    is\n    begin\n-      --  Nothing to do if identical schemes\n+      --  Nothing to do if identical schemes, but for UTF_8 we need to\n+      --  exclude overlong encodings, so need to do the full conversion.\n \n-      if Input_Scheme = Output_Scheme then\n+      if Input_Scheme = Output_Scheme\n+        and then Input_Scheme /= UTF_8\n+      then\n          return Item;\n \n       --  For remaining cases, one or other of the operands is UTF-16BE/LE"}, {"sha": "87e5893f16b22c42ed86f1d3082f4b6db668e64c", "filename": "gcc/ada/a-suenst.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2757c5bf1817db84c51f0297ae8c27acfaea2ad3/gcc%2Fada%2Fa-suenst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2757c5bf1817db84c51f0297ae8c27acfaea2ad3/gcc%2Fada%2Fa-suenst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-suenst.adb?ref=2757c5bf1817db84c51f0297ae8c27acfaea2ad3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2010-2012, Free Software Foundation, Inc.      --\n+--          Copyright (C) 2010-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -158,6 +158,12 @@ package body Ada.Strings.UTF_Encoding.Strings is\n       end loop;\n \n       return Result (1 .. Len);\n+\n+   exception\n+      --  'Val may have been out of range\n+\n+      when others =>\n+         Raise_Encoding_Error (Iptr - 1);\n    end Decode;\n \n    --  Decode UTF-16 input to String"}, {"sha": "8d81ce8ff26bbe6547794e4166aa159cdcd91925", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 45, "deletions": 22, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2757c5bf1817db84c51f0297ae8c27acfaea2ad3/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2757c5bf1817db84c51f0297ae8c27acfaea2ad3/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=2757c5bf1817db84c51f0297ae8c27acfaea2ad3", "patch": "@@ -589,10 +589,10 @@ package body Einfo is\n    -----------------------\n \n    function Has_Option\n-     (State   : Entity_Id;\n-      Opt_Nam : Name_Id) return Boolean;\n-   --  Determine whether abstract state State has a particular option denoted\n-   --  by the name Opt_Nam.\n+     (State_Id   : Entity_Id;\n+      Option_Nam : Name_Id) return Boolean;\n+   --  Determine whether abstract state State_Id has particular option denoted\n+   --  by the name Option_Nam.\n \n    ---------------\n    -- Float_Rep --\n@@ -609,32 +609,55 @@ package body Einfo is\n    ----------------\n \n    function Has_Option\n-     (State   : Entity_Id;\n-      Opt_Nam : Name_Id) return Boolean\n+     (State_Id   : Entity_Id;\n+      Option_Nam : Name_Id) return Boolean\n    is\n-      Par : constant Node_Id := Parent (State);\n-      Opt : Node_Id;\n+      Decl    : constant Node_Id := Parent (State_Id);\n+      Opt     : Node_Id;\n+      Opt_Nam : Node_Id;\n \n    begin\n-      pragma Assert (Ekind (State) = E_Abstract_State);\n+      pragma Assert (Ekind (State_Id) = E_Abstract_State);\n \n-      --  States with options appear as extension aggregates in the tree\n+      --  The declaration of abstract states with options appear as an\n+      --  extension aggregate. If this is not the case, the option is not\n+      --  available.\n \n-      if Nkind (Par) = N_Extension_Aggregate then\n-         if Opt_Nam = Name_Part_Of then\n-            return Present (Component_Associations (Par));\n+      if Nkind (Decl) /= N_Extension_Aggregate then\n+         return False;\n+      end if;\n \n-         else\n-            Opt := First (Expressions (Par));\n-            while Present (Opt) loop\n-               if Chars (Opt) = Opt_Nam then\n-                  return True;\n-               end if;\n+      --  Simple options\n \n-               Next (Opt);\n-            end loop;\n+      Opt := First (Expressions (Decl));\n+      while Present (Opt) loop\n+\n+         --  Currently the only simple option allowed is External\n+\n+         if Nkind (Opt) = N_Identifier\n+           and then Chars (Opt) = Name_External\n+           and then Chars (Opt) = Option_Nam\n+         then\n+            return True;\n          end if;\n-      end if;\n+\n+         Next (Opt);\n+      end loop;\n+\n+      --  Complex options with various specifiers\n+\n+      Opt := First (Component_Associations (Decl));\n+      while Present (Opt) loop\n+         Opt_Nam := First (Choices (Opt));\n+\n+         if Nkind (Opt_Nam) = N_Identifier\n+           and then Chars (Opt_Nam) = Option_Nam\n+         then\n+            return True;\n+         end if;\n+\n+         Next (Opt);\n+      end loop;\n \n       return False;\n    end Has_Option;"}, {"sha": "779acc34ae932d6bd91468c057151e93c4c04e56", "filename": "gcc/ada/par-ch5.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2757c5bf1817db84c51f0297ae8c27acfaea2ad3/gcc%2Fada%2Fpar-ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2757c5bf1817db84c51f0297ae8c27acfaea2ad3/gcc%2Fada%2Fpar-ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch5.adb?ref=2757c5bf1817db84c51f0297ae8c27acfaea2ad3", "patch": "@@ -1739,14 +1739,13 @@ package body Ch5 is\n       elsif Prev_Token = Tok_In\n         and then Present (Subtype_Indication (Node1))\n       then\n-\n          --  Simplest recovery is to transform it into an element iterator.\n          --  Error message on 'in\" has already been emitted when parsing the\n          --  optional constraint.\n \n          Set_Of_Present (Node1);\n          Error_Msg_N\n-           (\"subtype indication is only legal on on element iterator\",\n+           (\"subtype indication is only legal on an element iterator\",\n               Subtype_Indication (Node1));\n \n       else"}, {"sha": "af3387492cc2bcaca363d43231e2196dc2a4243c", "filename": "gcc/ada/projects.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2757c5bf1817db84c51f0297ae8c27acfaea2ad3/gcc%2Fada%2Fprojects.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2757c5bf1817db84c51f0297ae8c27acfaea2ad3/gcc%2Fada%2Fprojects.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprojects.texi?ref=2757c5bf1817db84c51f0297ae8c27acfaea2ad3", "patch": "@@ -1616,6 +1616,10 @@ implementation part of the library implies minimal post-compilation actions on\n the complete system and potentially no action at all for the rest of the\n system in the case of dynamic SALs.\n \n+There is a restriction on shared library projects: by default, they are only\n+allowed to import other shared library projects. They are not allowed to\n+import non library projects or static library projects.\n+\n The GNAT Project Manager takes complete care of the library build, rebuild and\n installation tasks, including recompilation of the source files for which\n objects do not exist or are not up to date, assembly of the library archive, and"}, {"sha": "c5b832ce214bf8f4b157afa2d921a7d96a764eea", "filename": "gcc/ada/s-tposen.ads", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2757c5bf1817db84c51f0297ae8c27acfaea2ad3/gcc%2Fada%2Fs-tposen.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2757c5bf1817db84c51f0297ae8c27acfaea2ad3/gcc%2Fada%2Fs-tposen.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tposen.ads?ref=2757c5bf1817db84c51f0297ae8c27acfaea2ad3", "patch": "@@ -1,14 +1,14 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                  --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n --                                                                          --\n---             SYSTEM.TASKING.PROTECTED_OBJECTS.SINGLE_ENTRY                --\n+--               SYSTEM.TASKING.PROTECTED_OBJECTS.SINGLE_ENTRY              --\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n -- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n -- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n@@ -31,25 +31,25 @@\n \n --  This package provides an optimized version of Protected_Objects.Operations\n --  and Protected_Objects.Entries making the following assumptions:\n---\n+\n --    PO have only one entry\n --    There is only one caller at a time (No_Entry_Queue)\n --    There is no dynamic priority support (No_Dynamic_Priorities)\n --    No Abort Statements\n --      (No_Abort_Statements, Max_Asynchronous_Select_Nesting => 0)\n --    PO are at library level\n --    None of the tasks will terminate (no need for finalization)\n---\n---  This interface is intended to be used in the ravenscar profile, the\n+\n+--  This interface is intended to be used in the Ravenscar profile, the\n --  compiler is responsible for ensuring that the conditions mentioned above\n --  are respected, except for the No_Entry_Queue restriction that is checked\n --  dynamically in this package, since the check cannot be performed at compile\n --  time, and is relatively cheap (see body).\n---\n+\n --  This package is part of the high level tasking interface used by the\n --  compiler to expand Ada 95 tasking constructs into simpler run time calls\n --  (aka GNARLI, GNU Ada Run-time Library Interface)\n---\n+\n --  Note: the compiler generates direct calls to this interface, via Rtsfind.\n --  Any changes to this interface may require corresponding compiler changes\n --  in exp_ch9.adb and possibly exp_ch7.adb\n@@ -191,34 +191,34 @@ package System.Tasking.Protected_Objects.Single_Entry is\n    --  to keep track of the runtime state of a protected object.\n \n    procedure Lock_Entry (Object : Protection_Entry_Access);\n-   --  Lock a protected object for write access. Upon return, the caller\n-   --  owns the lock to this object, and no other call to Lock or\n-   --  Lock_Read_Only with the same argument will return until the\n-   --  corresponding call to Unlock has been made by the caller.\n+   --  Lock a protected object for write access. Upon return, the caller owns\n+   --  the lock to this object, and no other call to Lock or Lock_Read_Only\n+   --  with the same argument will return until the corresponding call to\n+   --  Unlock has been made by the caller.\n \n    procedure Lock_Read_Only_Entry\n      (Object : Protection_Entry_Access);\n-   --  Lock a protected object for read access.  Upon return, the caller\n-   --  owns the lock for read access, and no other calls to Lock\n-   --  with the same argument will return until the corresponding call\n-   --  to Unlock has been made by the caller.  Other calls to Lock_Read_Only\n-   --  may (but need not) return before the call to Unlock, and the\n-   --  corresponding callers will also own the lock for read access.\n+   --  Lock a protected object for read access. Upon return, the caller owns\n+   --  the lock for read access, and no other calls to Lock with the same\n+   --  argument will return until the corresponding call to Unlock has been\n+   --  made by the caller. Other calls to Lock_Read_Only may (but need not)\n+   --  return before the call to Unlock, and the corresponding callers will\n+   --  also own the lock for read access.\n \n    procedure Unlock_Entry (Object : Protection_Entry_Access);\n-   --  Relinquish ownership of the lock for the object represented by\n-   --  the Object parameter.  If this ownership was for write access, or\n-   --  if it was for read access where there are no other read access\n-   --  locks outstanding, one (or more, in the case of Lock_Read_Only)\n-   --  of the tasks waiting on this lock (if any) will be given the\n-   --  lock and allowed to return from the Lock or Lock_Read_Only call.\n+   --  Relinquish ownership of the lock for the object represented by the\n+   --  Object parameter. If this ownership was for write access, or if it was\n+   --  for read access where there are no other read access locks outstanding,\n+   --  one (or more, in the case of Lock_Read_Only) of the tasks waiting on\n+   --  this lock (if any) will be given the lock and allowed to return from\n+   --  the Lock or Lock_Read_Only call.\n \n    procedure Service_Entry (Object : Protection_Entry_Access);\n    --  Service the entry queue of the specified object, executing the\n    --  corresponding body of any queued entry call that is waiting on True\n    --  barrier. This is used when the state of a protected object may have\n-   --  changed, in particular after the execution of the statement sequence of\n-   --  a protected procedure.\n+   --  changed, in particular after the execution of the statement sequence\n+   --  of a protected procedure.\n    --\n    --  This must be called with abort deferred and with the corresponding\n    --  object locked. Object is unlocked on return.\n@@ -227,9 +227,10 @@ package System.Tasking.Protected_Objects.Single_Entry is\n      (Object              : Protection_Entry_Access;\n       Uninterpreted_Data  : System.Address;\n       Mode                : Call_Modes);\n-   --  Make a protected entry call to the specified object.\n-   --  Pend a protected entry call on the protected object represented\n-   --  by Object. A pended call is not queued; it may be executed immediately\n+   --  Make a protected entry call to the specified object\n+   --\n+   --  Pend a protected entry call on the protected object represented by\n+   --  Object. A pended call is not queued; it may be executed immediately\n    --  or queued, depending on the state of the entry barrier.\n    --\n    --    Uninterpreted_Data\n@@ -258,19 +259,18 @@ package System.Tasking.Protected_Objects.Single_Entry is\n    procedure Exceptional_Complete_Single_Entry_Body\n      (Object : Protection_Entry_Access;\n       Ex     : Ada.Exceptions.Exception_Id);\n-   --  Perform all of the functions of Complete_Entry_Body. In addition,\n-   --  report in Ex the exception whose propagation terminated the entry\n-   --  body to the runtime system.\n+   --  Perform all of the functions of Complete_Entry_Body. In addition, report\n+   --  in Ex the exception whose propagation terminated the entry body to the\n+   --  runtime system.\n \n-   function Protected_Count_Entry (Object : Protection_Entry)\n-     return Natural;\n+   function Protected_Count_Entry (Object : Protection_Entry) return Natural;\n    --  Return the number of entry calls on Object (0 or 1)\n \n-   function Protected_Single_Entry_Caller (Object : Protection_Entry)\n-     return Task_Id;\n-   --  Return value of E'Caller, where E is the protected entry currently\n-   --  being handled. This will only work if called from within an\n-   --  entry body, as required by the LRM (C.7.1(14)).\n+   function Protected_Single_Entry_Caller\n+     (Object : Protection_Entry) return Task_Id;\n+   --  Return value of E'Caller, where E is the protected entry currently being\n+   --  handled. This will only work if called from within an entry body, as\n+   --  required by the LRM (C.7.1(14)).\n \n private\n    type Protection_Entry is record"}, {"sha": "aea2a4d2d0567cba68f4a3207c6161e840298bca", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2757c5bf1817db84c51f0297ae8c27acfaea2ad3/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2757c5bf1817db84c51f0297ae8c27acfaea2ad3/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=2757c5bf1817db84c51f0297ae8c27acfaea2ad3", "patch": "@@ -6296,8 +6296,9 @@ package body Sem_Ch8 is\n                --  If no interpretation as an expanded name is possible, it\n                --  must be a selected component of a record returned by a\n                --  function call. Reformat prefix as a function call, the rest\n-               --  is done by type resolution. If the prefix is procedure or\n-               --  entry, as is P.X; this is an error.\n+               --  is done by type resolution.\n+\n+               --  Error if the prefix is procedure or entry, as is P.X\n \n                if Ekind (P_Name) /= E_Function\n                  and then\n@@ -6309,7 +6310,6 @@ package body Sem_Ch8 is\n                   --  chain, the candidate package may be anywhere on it.\n \n                   if Present (Homonym (Current_Entity (P_Name))) then\n-\n                      P_Name := Current_Entity (P_Name);\n \n                      while Present (P_Name) loop\n@@ -6327,6 +6327,7 @@ package body Sem_Ch8 is\n                         Set_Entity (Prefix (N), P_Name);\n                         Find_Expanded_Name (N);\n                         return;\n+\n                      else\n                         P_Name := Entity (Prefix (N));\n                      end if;\n@@ -6338,11 +6339,27 @@ package body Sem_Ch8 is\n                   Set_Entity (N, Any_Id);\n                   Set_Etype (N, Any_Type);\n \n+               --  Here we have a function call, so do the reformatting\n+\n                else\n                   Nam := New_Copy (P);\n                   Save_Interps (P, Nam);\n-                  Rewrite (P,\n+\n+                  --  We use Replace here because this is one of those cases\n+                  --  where the parser has missclassified the node, and we\n+                  --  fix things up and then do the semantic analysis on the\n+                  --  fixed up node. Normally we do this using one of the\n+                  --  Sinfo.CN routines, but this is too tricky for that.\n+\n+                  --  Note that using Rewrite would be wrong, because we\n+                  --  would have a tree where the original node is unanalyzed,\n+                  --  and this violates the required interface for ASIS.\n+\n+                  Replace (P,\n                     Make_Function_Call (Sloc (P), Name => Nam));\n+\n+                  --  Now analyze the reformatted node\n+\n                   Analyze_Call (P);\n                   Analyze_Selected_Component (N);\n                end if;"}, {"sha": "3ddaed2773cf67384aa789427c53e734eb12da48", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 185, "deletions": 63, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2757c5bf1817db84c51f0297ae8c27acfaea2ad3/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2757c5bf1817db84c51f0297ae8c27acfaea2ad3/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=2757c5bf1817db84c51f0297ae8c27acfaea2ad3", "patch": "@@ -22214,24 +22214,44 @@ package body Sem_Prag is\n       -------------------------------\n \n       procedure Analyze_Refinement_Clause (Clause : Node_Id) is\n-         State_Id : Entity_Id := Empty;\n-         --  The entity of the state being refined in the current clause\n+         AR_Constit : Entity_Id := Empty;\n+         AW_Constit : Entity_Id := Empty;\n+         ER_Constit : Entity_Id := Empty;\n+         EW_Constit : Entity_Id := Empty;\n+         --  The entities of external constituents that contain one of the\n+         --  following enabled properties: Async_Readers, Async_Writers,\n+         --  Effective_Reads and Effective_Writes.\n+\n+         External_Constit_Seen : Boolean := False;\n+         --  Flag used to mark when at least one external constituent is part\n+         --  of the state refinement.\n \n          Non_Null_Seen : Boolean := False;\n          Null_Seen     : Boolean := False;\n          --  Flags used to detect multiple uses of null in a single clause or a\n          --  mixture of null and non-null constituents.\n \n+         State    : Node_Id;\n+         State_Id : Entity_Id;\n+         --  The state being refined in the current clause\n+\n          procedure Analyze_Constituent (Constit : Node_Id);\n          --  Perform full analysis of a single constituent\n \n-         procedure Check_Matching_State\n-           (State    : Node_Id;\n-            State_Id : Entity_Id);\n-         --  Determine whether state State denoted by its name State_Id appears\n-         --  in Abstr_States. Emit an error when attempting to re-refine the\n-         --  state or when the state is not defined in the package declaration.\n-         --  Otherwise remove the state from Abstr_States.\n+         procedure Check_External_Property\n+           (Prop_Nam : Name_Id;\n+            Enabled  : Boolean;\n+            Constit  : Entity_Id);\n+         --  Determine whether a property denoted by name Prop_Nam is present\n+         --  in both the refined state and constituent Constit. Flag Enabled\n+         --  should be set when the property applies to the refined state. If\n+         --  this is not the case, emit an error message.\n+\n+         procedure Check_Matching_State;\n+         --  Determine whether the state being refined appears in Abstr_States.\n+         --  Emit an error when attempting to re-refine the state or when the\n+         --  state is not defined in the package declaration. Otherwise remove\n+         --  the state from Abstr_States.\n \n          -------------------------\n          -- Analyze_Constituent --\n@@ -22276,6 +22296,29 @@ package body Sem_Prag is\n                   --  body declarations end (see routine Analyze_Declarations).\n \n                   Set_Has_Visible_Refinement (State_Id);\n+\n+                  --  When the constituent is external, save its relevant\n+                  --  property for further checks.\n+\n+                  if Async_Readers_Enabled (Constit_Id) then\n+                     AR_Constit := Constit_Id;\n+                     External_Constit_Seen := True;\n+                  end if;\n+\n+                  if Async_Writers_Enabled (Constit_Id) then\n+                     AW_Constit := Constit_Id;\n+                     External_Constit_Seen := True;\n+                  end if;\n+\n+                  if Effective_Reads_Enabled (Constit_Id) then\n+                     ER_Constit := Constit_Id;\n+                     External_Constit_Seen := True;\n+                  end if;\n+\n+                  if Effective_Writes_Enabled (Constit_Id) then\n+                     EW_Constit := Constit_Id;\n+                     External_Constit_Seen := True;\n+                  end if;\n                end Collect_Constituent;\n \n                --  Local variables\n@@ -22426,14 +22469,44 @@ package body Sem_Prag is\n             end if;\n          end Analyze_Constituent;\n \n+         -----------------------------\n+         -- Check_External_Property --\n+         -----------------------------\n+\n+         procedure Check_External_Property\n+           (Prop_Nam : Name_Id;\n+            Enabled  : Boolean;\n+            Constit  : Entity_Id)\n+         is\n+         begin\n+            Error_Msg_Name_1 := Prop_Nam;\n+\n+            --  The property is enabled in the related Abstract_State pragma\n+            --  that defines the state.\n+\n+            if Enabled then\n+               if No (Constit) then\n+                  Error_Msg_NE\n+                    (\"external state & requires at least one constituent with \"\n+                     & \"property % (SPARK RM 7.2.8(3))\", State, State_Id);\n+               end if;\n+\n+            --  The property is missing in the declaration of the state, but a\n+            --  constituent is introducing it in the state refinement.\n+\n+            elsif Present (Constit) then\n+               Error_Msg_Name_2 := Chars (Constit);\n+               Error_Msg_NE\n+                 (\"external state & lacks property % set by constituent % \"\n+                  & \"(SPARK RM 7.2.8(3))\", State, State_Id);\n+            end if;\n+         end Check_External_Property;\n+\n          --------------------------\n          -- Check_Matching_State --\n          --------------------------\n \n-         procedure Check_Matching_State\n-           (State    : Node_Id;\n-            State_Id : Entity_Id)\n-         is\n+         procedure Check_Matching_State is\n             State_Elmt : Elmt_Id;\n \n          begin\n@@ -22478,76 +22551,71 @@ package body Sem_Prag is\n \n          --  Local declarations\n \n-         Constit : Node_Id;\n-         State   : Node_Id;\n+         Body_Ref      : Node_Id;\n+         Body_Ref_Elmt : Elmt_Id;\n+         Constit       : Node_Id;\n+         Extra_State   : Node_Id;\n \n       --  Start of processing for Analyze_Refinement_Clause\n \n       begin\n          --  Analyze the state name of a refinement clause\n \n          State := First (Choices (Clause));\n-         while Present (State) loop\n-            if Present (State_Id) then\n-               Error_Msg_N\n-                 (\"refinement clause cannot cover multiple states\", State);\n \n-            else\n-               Analyze       (State);\n-               Resolve_State (State);\n+         Analyze       (State);\n+         Resolve_State (State);\n \n-               --  Ensure that the state name denotes a valid abstract state\n-               --  that is defined in the spec of the related package.\n+         --  Ensure that the state name denotes a valid abstract state that is\n+         --  defined in the spec of the related package.\n \n-               if Is_Entity_Name (State) then\n-                  State_Id := Entity_Of (State);\n+         if Is_Entity_Name (State) then\n+            State_Id := Entity_Of (State);\n \n-                  --  Catch any attempts to re-refine a state or refine a\n-                  --  state that is not defined in the package declaration.\n+            --  Catch any attempts to re-refine a state or refine a state that\n+            --  is not defined in the package declaration.\n \n-                  if Ekind (State_Id) = E_Abstract_State then\n-                     Check_Matching_State (State, State_Id);\n-                  else\n-                     Error_Msg_NE\n-                       (\"& must denote an abstract state\", State, State_Id);\n-                  end if;\n+            if Ekind (State_Id) = E_Abstract_State then\n+               Check_Matching_State;\n+            else\n+               Error_Msg_NE\n+                 (\"& must denote an abstract state\", State, State_Id);\n+            end if;\n \n-                  --  A global item cannot denote a state abstraction whose\n-                  --  refinement is visible, in other words a state abstraction\n-                  --  cannot be named within its enclosing package's body other\n-                  --  than in its refinement.\n+            --  A global item cannot denote a state abstraction whose\n+            --  refinement is visible, in other words a state abstraction\n+            --  cannot be named within its enclosing package's body other than\n+            --  in its refinement.\n \n-                  if Has_Body_References (State_Id) then\n-                     declare\n-                        Ref      : Node_Id;\n-                        Ref_Elmt : Elmt_Id;\n+            if Has_Body_References (State_Id) then\n+               Body_Ref_Elmt := First_Elmt (Body_References (State_Id));\n+               while Present (Body_Ref_Elmt) loop\n+                  Body_Ref := Node (Body_Ref_Elmt);\n \n-                     begin\n-                        Ref_Elmt := First_Elmt (Body_References (State_Id));\n-                        while Present (Ref_Elmt) loop\n-                           Ref := Node (Ref_Elmt);\n+                  Error_Msg_N\n+                    (\"global reference to & not allowed (SPARK RM 6.1.4(8))\",\n+                     Body_Ref);\n+                  Error_Msg_Sloc := Sloc (State);\n+                  Error_Msg_N (\"\\refinement of & is visible#\", Body_Ref);\n \n-                           Error_Msg_N\n-                             (\"global reference to & not allowed (SPARK RM \"\n-                              & \"6.1.4(8))\", Ref);\n-                           Error_Msg_Sloc := Sloc (State);\n-                           Error_Msg_N (\"\\refinement of & is visible#\", Ref);\n+                  Next_Elmt (Body_Ref_Elmt);\n+               end loop;\n+            end if;\n \n-                           Next_Elmt (Ref_Elmt);\n-                        end loop;\n-                     end;\n-                  end if;\n+            --  The state name is illegal\n \n-               --  The state name is illegal\n+         else\n+            Error_Msg_N (\"malformed state name in refinement clause\", State);\n+         end if;\n \n-               else\n-                  Error_Msg_N\n-                    (\"malformed state name in refinement clause\", State);\n-               end if;\n-            end if;\n+         --  A refinement clause may only refine one state at a time\n \n-            Next (State);\n-         end loop;\n+         Extra_State := Next (State);\n+\n+         if Present (Extra_State) then\n+            Error_Msg_N\n+              (\"refinement clause cannot cover multiple states\", Extra_State);\n+         end if;\n \n          --  Analyze all constituents of the refinement. Multiple constituents\n          --  appear as an aggregate.\n@@ -22575,6 +22643,60 @@ package body Sem_Prag is\n          else\n             Analyze_Constituent (Constit);\n          end if;\n+\n+         --  A refined external state is subject to special rules with respect\n+         --  to its properties and constituents.\n+\n+         if Is_External_State (State_Id) then\n+\n+            --  The set of properties that all external constituents yield must\n+            --  match that of the refined state. There are two cases to detect:\n+            --  the refined state lacks a property or has an extra property.\n+\n+            if External_Constit_Seen then\n+               Check_External_Property\n+                 (Prop_Nam => Name_Async_Readers,\n+                  Enabled  => Async_Readers_Enabled (State_Id),\n+                  Constit  => AR_Constit);\n+\n+               Check_External_Property\n+                 (Prop_Nam => Name_Async_Writers,\n+                  Enabled  => Async_Writers_Enabled (State_Id),\n+                  Constit  => AW_Constit);\n+\n+               Check_External_Property\n+                 (Prop_Nam => Name_Effective_Reads,\n+                  Enabled  => Effective_Reads_Enabled (State_Id),\n+                  Constit  => ER_Constit);\n+\n+               Check_External_Property\n+                 (Prop_Nam => Name_Effective_Writes,\n+                  Enabled  => Effective_Writes_Enabled (State_Id),\n+                  Constit  => EW_Constit);\n+\n+            --  An external state may be refined to null (SPARK RM 7.2.8(2))\n+\n+            elsif Null_Seen then\n+               null;\n+\n+            --  The external state has constituents, but none of them are\n+            --  external.\n+\n+            else\n+               Error_Msg_NE\n+                 (\"external state & requires at least one external \"\n+                  & \"constituent or null refinement (SPARK RM 7.2.8(2))\",\n+                  State, State_Id);\n+            end if;\n+\n+         --  When a refined state is not external, it should not have external\n+         --  constituents.\n+\n+         elsif External_Constit_Seen then\n+            Error_Msg_NE\n+              (\"non-external state & cannot contain external constituents in \"\n+               & \"refinement (SPARK RM 7.2.8(1))\", State, State_Id);\n+         end if;\n       end Analyze_Refinement_Clause;\n \n       ---------------------------"}, {"sha": "8fc28ef4be814a038b86d6352f8403674b10f0f6", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 63, "deletions": 58, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2757c5bf1817db84c51f0297ae8c27acfaea2ad3/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2757c5bf1817db84c51f0297ae8c27acfaea2ad3/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=2757c5bf1817db84c51f0297ae8c27acfaea2ad3", "patch": "@@ -114,11 +114,11 @@ package body Sem_Util is\n    --  have a default.\n \n    function Has_Enabled_Property\n-     (Extern   : Node_Id;\n+     (State_Id : Node_Id;\n       Prop_Nam : Name_Id) return Boolean;\n    --  Subsidiary to routines Async_xxx_Enabled and Effective_xxx_Enabled.\n-   --  Given pragma External, determine whether it contains a property denoted\n-   --  by its name Prop_Nam and if it does, whether its expression is True.\n+   --  Determine whether an abstract state denoted by its entity State_Id has\n+   --  enabled property Prop_Name.\n \n    function Has_Null_Extension (T : Entity_Id) return Boolean;\n    --  T is a derived tagged type. Check whether the type extension is null.\n@@ -560,10 +560,7 @@ package body Sem_Util is\n    function Async_Readers_Enabled (Id : Entity_Id) return Boolean is\n    begin\n       if Ekind (Id) = E_Abstract_State then\n-         return\n-           Has_Enabled_Property\n-             (Extern   => Get_Pragma (Id, Pragma_External),\n-              Prop_Nam => Name_Async_Readers);\n+         return Has_Enabled_Property (Id, Name_Async_Readers);\n \n       else pragma Assert (Ekind (Id) = E_Variable);\n          return Present (Get_Pragma (Id, Pragma_Async_Readers));\n@@ -577,10 +574,7 @@ package body Sem_Util is\n    function Async_Writers_Enabled (Id : Entity_Id) return Boolean is\n    begin\n       if Ekind (Id) = E_Abstract_State then\n-         return\n-           Has_Enabled_Property\n-             (Extern   => Get_Pragma (Id, Pragma_External),\n-              Prop_Nam => Name_Async_Writers);\n+         return Has_Enabled_Property (Id, Name_Async_Writers);\n \n       else pragma Assert (Ekind (Id) = E_Variable);\n          return Present (Get_Pragma (Id, Pragma_Async_Writers));\n@@ -4818,10 +4812,7 @@ package body Sem_Util is\n    function Effective_Reads_Enabled (Id : Entity_Id) return Boolean is\n    begin\n       if Ekind (Id) = E_Abstract_State then\n-         return\n-           Has_Enabled_Property\n-             (Extern   => Get_Pragma (Id, Pragma_External),\n-              Prop_Nam => Name_Effective_Reads);\n+         return Has_Enabled_Property (Id, Name_Effective_Reads);\n \n       else pragma Assert (Ekind (Id) = E_Variable);\n          return Present (Get_Pragma (Id, Pragma_Effective_Reads));\n@@ -4835,10 +4826,7 @@ package body Sem_Util is\n    function Effective_Writes_Enabled (Id : Entity_Id) return Boolean is\n    begin\n       if Ekind (Id) = E_Abstract_State then\n-         return\n-           Has_Enabled_Property\n-             (Extern   => Get_Pragma (Id, Pragma_External),\n-              Prop_Nam => Name_Effective_Writes);\n+         return Has_Enabled_Property (Id, Name_Effective_Writes);\n \n       else pragma Assert (Ekind (Id) = E_Variable);\n          return Present (Get_Pragma (Id, Pragma_Effective_Writes));\n@@ -7182,69 +7170,86 @@ package body Sem_Util is\n    --------------------------\n \n    function Has_Enabled_Property\n-     (Extern   : Node_Id;\n+     (State_Id : Node_Id;\n       Prop_Nam : Name_Id) return Boolean\n    is\n-      Prop  : Node_Id;\n-      Props : Node_Id := Empty;\n+      Decl    : constant Node_Id := Parent (State_Id);\n+      Opt     : Node_Id;\n+      Opt_Nam : Node_Id;\n+      Prop    : Node_Id;\n+      Props   : Node_Id;\n \n    begin\n-      --  The related abstract state or variable do not have an Extern pragma,\n-      --  the property in question cannot be set.\n+      --  The declaration of an external abstract state appears as an extension\n+      --  aggregate. If this is not the case, properties can never be set.\n \n-      if No (Extern) then\n+      if Nkind (Decl) /= N_Extension_Aggregate then\n          return False;\n-\n-      elsif Nkind (Extern) = N_Component_Association then\n-         Props := Expression (Extern);\n       end if;\n \n-      --  External state with properties\n+      --  When External appears as a simple option, it automatically enables\n+      --  all properties.\n \n-      if Present (Props) then\n+      Opt := First (Expressions (Decl));\n+      while Present (Opt) loop\n+         if Nkind (Opt) = N_Identifier\n+           and then Chars (Opt) = Name_External\n+         then\n+            return True;\n+         end if;\n \n-         --  Multiple properties appear as an aggregate\n+         Next (Opt);\n+      end loop;\n \n-         if Nkind (Props) = N_Aggregate then\n+      --  When External specifies particular properties, inspect those and\n+      --  find the desired one (if any).\n \n-            --  Simple property form\n+      Opt := First (Component_Associations (Decl));\n+      while Present (Opt) loop\n+         Opt_Nam := First (Choices (Opt));\n \n-            Prop := First (Expressions (Props));\n-            while Present (Prop) loop\n-               if Chars (Prop) = Prop_Nam then\n-                  return True;\n-               end if;\n+         if Nkind (Opt_Nam) = N_Identifier\n+           and then Chars (Opt_Nam) = Name_External\n+         then\n+            Props := Expression (Opt);\n \n-               Next (Prop);\n-            end loop;\n+            --  Multiple properties appear as an aggregate\n \n-            --  Property with expression form\n+            if Nkind (Props) = N_Aggregate then\n \n-            Prop := First (Component_Associations (Props));\n-            while Present (Prop) loop\n-               if Chars (Prop) = Prop_Nam then\n-                  return Is_True (Expr_Value (Expression (Prop)));\n-               end if;\n+               --  Simple property form\n \n-               Next (Prop);\n-            end loop;\n+               Prop := First (Expressions (Props));\n+               while Present (Prop) loop\n+                  if Chars (Prop) = Prop_Nam then\n+                     return True;\n+                  end if;\n+\n+                  Next (Prop);\n+               end loop;\n \n-            --  Pragma Extern contains properties, but not the one we want\n+               --  Property with expression form\n \n-            return False;\n+               Prop := First (Component_Associations (Props));\n+               while Present (Prop) loop\n+                  if Chars (Prop) = Prop_Nam then\n+                     return Is_True (Expr_Value (Expression (Prop)));\n+                  end if;\n+\n+                  Next (Prop);\n+               end loop;\n \n-         --  Single property\n+            --  Single property\n \n-         else\n-            return Chars (Prop) = Prop_Nam;\n+            else\n+               return Chars (Prop) = Prop_Nam;\n+            end if;\n          end if;\n \n-      --  An external state defined without any properties defaults all\n-      --  properties to True;\n+         Next (Opt);\n+      end loop;\n \n-      else\n-         return True;\n-      end if;\n+      return False;\n    end Has_Enabled_Property;\n \n    --------------------"}]}