{"sha": "e47e21c129bdb0cf5066944faf503f761b6023e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQ3ZTIxYzEyOWJkYjBjZjUwNjY5NDRmYWY1MDNmNzYxYjYwMjNlMA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-12-02T14:36:31Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-12-02T14:36:31Z"}, "message": "[multiple changes]\n\n2011-12-02  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-coormu.ads, a-ciormu.ads: Declare iterator factory function.\n\t* a-ciormu.adb, a-ciormu.adb (Iterator): Declare concrete\n\tIterator type.\n\t(Finalize): Decrement busy counter.\n\t(First, Last): Cursor return value depends on iterator node value.\n\t(Iterate): Use start position as iterator node value.\n\t(Next, Previous): Forward to corresponding cursor-based operation.\n\n2011-12-02  Robert Dewar  <dewar@adacore.com>\n\n\t* a-cborma.adb, a-cbhama.adb, a-cbdlli.adb, a-cbmutr.adb,\n\ta-cbhase.adb, a-cdlili.adb, a-cihama.adb, a-ciorse.adb, a-cidlli.adb,\n\ta-cimutr.adb, a-cihase.adb, a-cohama.adb, a-cborse.adb,\n\ta-ciorma.adb, a-cobove.adb: Minor reformatting.\n\nFrom-SVN: r181912", "tree": {"sha": "452ea8a651cc68cbc0204b035b9961cbe4a75820", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/452ea8a651cc68cbc0204b035b9961cbe4a75820"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e47e21c129bdb0cf5066944faf503f761b6023e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e47e21c129bdb0cf5066944faf503f761b6023e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e47e21c129bdb0cf5066944faf503f761b6023e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e47e21c129bdb0cf5066944faf503f761b6023e0/comments", "author": null, "committer": null, "parents": [{"sha": "3e44f600c333e30f361110f36a55dde7ad30209d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e44f600c333e30f361110f36a55dde7ad30209d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e44f600c333e30f361110f36a55dde7ad30209d"}], "stats": {"total": 583, "additions": 485, "deletions": 98}, "files": [{"sha": "67733a538982bd39b81fd6e025e30a1978947f99", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e47e21c129bdb0cf5066944faf503f761b6023e0", "patch": "@@ -1,3 +1,20 @@\n+2011-12-02  Matthew Heaney  <heaney@adacore.com>\n+\n+\t* a-coormu.ads, a-ciormu.ads: Declare iterator factory function.\n+\t* a-ciormu.adb, a-ciormu.adb (Iterator): Declare concrete\n+\tIterator type.\n+\t(Finalize): Decrement busy counter.\n+\t(First, Last): Cursor return value depends on iterator node value.\n+\t(Iterate): Use start position as iterator node value.\n+\t(Next, Previous): Forward to corresponding cursor-based operation.\n+\n+2011-12-02  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-cborma.adb, a-cbhama.adb, a-cbdlli.adb, a-cbmutr.adb,\n+\ta-cbhase.adb, a-cdlili.adb, a-cihama.adb, a-ciorse.adb, a-cidlli.adb,\n+\ta-cimutr.adb, a-cihase.adb, a-cohama.adb, a-cborse.adb,\n+\ta-ciorma.adb, a-cobove.adb: Minor reformatting.\n+\n 2011-12-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR bootstrap/51201"}, {"sha": "5e4248a8d9148fc75e7716d5a826c9ac262f920d", "filename": "gcc/ada/a-cbdlli.adb", "status": "modified", "additions": 38, "deletions": 34, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-cbdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-cbdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbdlli.adb?ref=e47e21c129bdb0cf5066944faf503f761b6023e0", "patch": "@@ -28,6 +28,7 @@\n ------------------------------------------------------------------------------\n \n with Ada.Finalization; use Ada.Finalization;\n+\n with System; use type System.Address;\n \n package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n@@ -129,24 +130,23 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       if Container.Free >= 0 then\n          New_Node := Container.Free;\n \n-         --  We always perform the assignment first, before we\n-         --  change container state, in order to defend against\n-         --  exceptions duration assignment.\n+         --  We always perform the assignment first, before we change container\n+         --  state, in order to defend against exceptions duration assignment.\n \n          N (New_Node).Element := New_Item;\n          Container.Free := N (New_Node).Next;\n \n       else\n-         --  A negative free store value means that the links of the nodes\n-         --  in the free store have not been initialized. In this case, the\n-         --  nodes are physically contiguous in the array, starting at the\n-         --  index that is the absolute value of the Container.Free, and\n-         --  continuing until the end of the array (Nodes'Last).\n+         --  A negative free store value means that the links of the nodes in\n+         --  the free store have not been initialized. In this case, the nodes\n+         --  are physically contiguous in the array, starting at the index that\n+         --  is the absolute value of the Container.Free, and continuing until\n+         --  the end of the array (Nodes'Last).\n \n          New_Node := abs Container.Free;\n \n-         --  As above, we perform this assignment first, before modifying\n-         --  any container state.\n+         --  As above, we perform this assignment first, before modifying any\n+         --  container state.\n \n          N (New_Node).Element := New_Item;\n          Container.Free := Container.Free - 1;\n@@ -164,24 +164,23 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       if Container.Free >= 0 then\n          New_Node := Container.Free;\n \n-         --  We always perform the assignment first, before we\n-         --  change container state, in order to defend against\n-         --  exceptions duration assignment.\n+         --  We always perform the assignment first, before we change container\n+         --  state, in order to defend against exceptions duration assignment.\n \n          Element_Type'Read (Stream, N (New_Node).Element);\n          Container.Free := N (New_Node).Next;\n \n       else\n-         --  A negative free store value means that the links of the nodes\n-         --  in the free store have not been initialized. In this case, the\n-         --  nodes are physically contiguous in the array, starting at the\n-         --  index that is the absolute value of the Container.Free, and\n-         --  continuing until the end of the array (Nodes'Last).\n+         --  A negative free store value means that the links of the nodes in\n+         --  the free store have not been initialized. In this case, the nodes\n+         --  are physically contiguous in the array, starting at the index that\n+         --  is the absolute value of the Container.Free, and continuing until\n+         --  the end of the array (Nodes'Last).\n \n          New_Node := abs Container.Free;\n \n-         --  As above, we perform this assignment first, before modifying\n-         --  any container state.\n+         --  As above, we perform this assignment first, before modifying any\n+         --  container state.\n \n          Element_Type'Read (Stream, N (New_Node).Element);\n          Container.Free := Container.Free - 1;\n@@ -674,7 +673,10 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          --  inactive immediately precedes the start of the free store. All\n          --  we need to do is move the start of the free store back by one.\n \n-         N (X).Next := 0;  -- not strictly necessary, but marginally safer\n+         --  Note: initializing Next to zero is not strictly necessary but\n+         --  seems cleaner and marginally safer.\n+\n+         N (X).Next := 0;\n          Container.Free := Container.Free + 1;\n \n       else\n@@ -794,7 +796,6 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n             if RN (RI.Node).Element < LN (LI.Node).Element then\n                declare\n                   RJ : Cursor := RI;\n-                  pragma Warnings (Off, RJ);\n                begin\n                   RI.Node := RN (RI.Node).Next;\n                   Splice (Target, LI, Source, RJ);\n@@ -1035,7 +1036,9 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          Container.Last := New_Node;\n          N (Container.Last).Next := 0;\n \n-      elsif Before = 0 then  -- means append\n+      --  Before = zero means append\n+\n+      elsif Before = 0 then\n          pragma Assert (N (Container.Last).Next = 0);\n \n          N (Container.Last).Next := New_Node;\n@@ -1044,7 +1047,9 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          Container.Last := New_Node;\n          N (Container.Last).Next := 0;\n \n-      elsif Before = Container.First then  -- means prepend\n+      --  Before = Container.First means prepend\n+\n+      elsif Before = Container.First then\n          pragma Assert (N (Container.First).Prev = 0);\n \n          N (Container.First).Prev := New_Node;\n@@ -2129,20 +2134,17 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       declare\n          L : List renames Position.Container.all;\n          N : Node_Array renames L.Nodes;\n+\n       begin\n          if L.Length = 0 then\n             return False;\n          end if;\n \n-         if L.First = 0\n-           or L.First > L.Capacity\n-         then\n+         if L.First = 0 or L.First > L.Capacity then\n             return False;\n          end if;\n \n-         if L.Last = 0\n-           or L.Last > L.Capacity\n-         then\n+         if L.Last = 0 or L.Last > L.Capacity then\n             return False;\n          end if;\n \n@@ -2182,6 +2184,7 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n \n          --  If we get here, we know that this disjunction is true:\n          --  N (Position.Node).Prev /= 0 or else Position.Node = L.First\n+         --  Why not do this with an assertion???\n \n          if N (Position.Node).Next = 0\n            and then Position.Node /= L.Last\n@@ -2191,6 +2194,7 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n \n          --  If we get here, we know that this disjunction is true:\n          --  N (Position.Node).Next /= 0 or else Position.Node = L.Last\n+         --  Why not do this with an assertion???\n \n          if L.Length = 1 then\n             return L.First = L.Last;\n@@ -2242,15 +2246,15 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n             return True;\n          end if;\n \n-         --  If we get here, we know (disjunctive syllogism) that this\n-         --  predicate is true: N (Position.Node).Prev /= 0\n+         --  If we get to this point, we know that this predicate is true:\n+         --  N (Position.Node).Prev /= 0\n \n          if Position.Node = L.Last then  -- eliminates earlier disjunct\n             return True;\n          end if;\n \n-         --  If we get here, we know (disjunctive syllogism) that this\n-         --  predicate is true: N (Position.Node).Next /= 0\n+         --  If we get to this point, we know that this predicate is true:\n+         --  N (Position.Node).Next /= 0\n \n          if N (N (Position.Node).Next).Prev /= Position.Node then\n             return False;"}, {"sha": "d52aea053767321ca134c62c7bb5f00d3eeba042", "filename": "gcc/ada/a-cbhama.adb", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-cbhama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-cbhama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbhama.adb?ref=e47e21c129bdb0cf5066944faf503f761b6023e0", "patch": "@@ -35,6 +35,7 @@ pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Bounded_Keys);\n \n with Ada.Containers.Prime_Numbers;  use Ada.Containers.Prime_Numbers;\n with Ada.Finalization;              use Ada.Finalization;\n+\n with System;  use type System.Address;\n \n package body Ada.Containers.Bounded_Hashed_Maps is\n@@ -405,7 +406,6 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n       if Object.Container /= null then\n          declare\n             B : Natural renames Object.Container.all.Busy;\n-\n          begin\n             B := B - 1;\n          end;\n@@ -418,13 +418,12 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n \n    function Find (Container : Map; Key : Key_Type) return Cursor is\n       Node : constant Count_Type := Key_Ops.Find (Container, Key);\n-\n    begin\n       if Node = 0 then\n          return No_Element;\n+      else\n+         return Cursor'(Container'Unrestricted_Access, Node);\n       end if;\n-\n-      return Cursor'(Container'Unrestricted_Access, Node);\n    end Find;\n \n    -----------\n@@ -433,13 +432,12 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n \n    function First (Container : Map) return Cursor is\n       Node : constant Count_Type := HT_Ops.First (Container);\n-\n    begin\n       if Node = 0 then\n          return No_Element;\n+      else\n+         return Cursor'(Container'Unrestricted_Access, Node);\n       end if;\n-\n-      return Cursor'(Container'Unrestricted_Access, Node);\n    end First;\n \n    function First (Object : Iterator) return Cursor is\n@@ -489,7 +487,6 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n \n          declare\n             N : Node_Type renames Container.Nodes (Position.Node);\n-\n          begin\n             N.Key := Key;\n             N.Element := New_Item;\n@@ -532,6 +529,7 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n          --  parameter.\n \n          --  Node.Element := New_Item;\n+         --  What is this deleted code about???\n       end Assign_Key;\n \n       --------------\n@@ -768,13 +766,12 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n       declare\n          M    : Map renames Position.Container.all;\n          Node : constant Count_Type := HT_Ops.Next (M, Position.Node);\n-\n       begin\n          if Node = 0 then\n             return No_Element;\n+         else\n+            return Cursor'(Position.Container, Node);\n          end if;\n-\n-         return Cursor'(Position.Container, Node);\n       end;\n    end Next;\n "}, {"sha": "b52d7fffa7e394517a7f26b8733f67ce38fd14d0", "filename": "gcc/ada/a-cbhase.adb", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-cbhase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-cbhase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbhase.adb?ref=e47e21c129bdb0cf5066944faf503f761b6023e0", "patch": "@@ -583,7 +583,6 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       if Object.Container /= null then\n          declare\n             B : Natural renames Object.Container.all.Busy;\n-\n          begin\n             B := B - 1;\n          end;\n@@ -930,10 +929,8 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n      return Set_Iterator_Interfaces.Forward_Iterator'Class\n    is\n       B : Natural renames Container'Unrestricted_Access.all.Busy;\n-\n    begin\n       B := B + 1;\n-\n       return It : constant Iterator :=\n                     Iterator'(Limited_Controlled with\n                                 Container => Container'Unrestricted_Access);"}, {"sha": "46a68c8bc45809eb0d79f682ce54d3dddb907022", "filename": "gcc/ada/a-cbmutr.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-cbmutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-cbmutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbmutr.adb?ref=e47e21c129bdb0cf5066944faf503f761b6023e0", "patch": "@@ -28,6 +28,7 @@\n ------------------------------------------------------------------------------\n \n with Ada.Finalization; use Ada.Finalization;\n+\n with System; use type System.Address;\n \n package body Ada.Containers.Bounded_Multiway_Trees is\n@@ -1246,7 +1247,6 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       if Object.Container /= null then\n          declare\n             B : Natural renames Object.Container.all.Busy;\n-\n          begin\n             B := B - 1;\n          end;\n@@ -1258,7 +1258,6 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       if Object.Container /= null then\n          declare\n             B : Natural renames Object.Container.all.Busy;\n-\n          begin\n             B := B - 1;\n          end;"}, {"sha": "3e140efbdf5a4b90aaf4811a49e9fdf28e9c0c6a", "filename": "gcc/ada/a-cborma.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-cborma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-cborma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cborma.adb?ref=e47e21c129bdb0cf5066944faf503f761b6023e0", "patch": "@@ -36,6 +36,7 @@ pragma Elaborate_All\n   (Ada.Containers.Red_Black_Trees.Generic_Bounded_Keys);\n \n with Ada.Finalization; use Ada.Finalization;\n+\n with System; use type System.Address;\n \n package body Ada.Containers.Bounded_Ordered_Maps is\n@@ -563,7 +564,6 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n       if Object.Container /= null then\n          declare\n             B : Natural renames Object.Container.all.Busy;\n-\n          begin\n             B := B - 1;\n          end;"}, {"sha": "557983d04c2d1d6f0b6ae98152c9e4cea3209e27", "filename": "gcc/ada/a-cborse.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-cborse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-cborse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cborse.adb?ref=e47e21c129bdb0cf5066944faf503f761b6023e0", "patch": "@@ -39,6 +39,7 @@ pragma Elaborate_All\n   (Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations);\n \n with Ada.Finalization; use Ada.Finalization;\n+\n with System; use type System.Address;\n \n package body Ada.Containers.Bounded_Ordered_Sets is\n@@ -580,7 +581,6 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n       if Object.Container /= null then\n          declare\n             B : Natural renames Object.Container.all.Busy;\n-\n          begin\n             B := B - 1;\n          end;"}, {"sha": "67df3093f7a2ea1359f30149358f935d2ec976c5", "filename": "gcc/ada/a-cdlili.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-cdlili.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-cdlili.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cdlili.adb?ref=e47e21c129bdb0cf5066944faf503f761b6023e0", "patch": "@@ -28,6 +28,7 @@\n ------------------------------------------------------------------------------\n \n with Ada.Unchecked_Deallocation;\n+\n with System; use type System.Address;\n \n package body Ada.Containers.Doubly_Linked_Lists is\n@@ -407,7 +408,6 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       if Object.Container /= null then\n          declare\n             B : Natural renames Object.Container.all.Busy;\n-\n          begin\n             B := B - 1;\n          end;\n@@ -504,7 +504,6 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    procedure Free (X : in out Node_Access) is\n       procedure Deallocate is\n          new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n-\n    begin\n       X.Prev := X;\n       X.Next := X;"}, {"sha": "bad5a896455e3e538d20f7b932a370240fa7d2ef", "filename": "gcc/ada/a-cidlli.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-cidlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-cidlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cidlli.adb?ref=e47e21c129bdb0cf5066944faf503f761b6023e0", "patch": "@@ -28,6 +28,7 @@\n ------------------------------------------------------------------------------\n \n with Ada.Unchecked_Deallocation;\n+\n with System; use type System.Address;\n \n package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n@@ -440,7 +441,6 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       if Object.Container /= null then\n          declare\n             B : Natural renames Object.Container.all.Busy;\n-\n          begin\n             B := B - 1;\n          end;"}, {"sha": "ebfaf27d2ffc58805c8c303f519cd2fead6735aa", "filename": "gcc/ada/a-cihama.adb", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-cihama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-cihama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihama.adb?ref=e47e21c129bdb0cf5066944faf503f761b6023e0", "patch": "@@ -34,6 +34,7 @@ with Ada.Containers.Hash_Tables.Generic_Keys;\n pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Keys);\n \n with Ada.Unchecked_Deallocation;\n+\n with System; use type System.Address;\n \n package body Ada.Containers.Indefinite_Hashed_Maps is\n@@ -428,7 +429,6 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       if Object.Container /= null then\n          declare\n             B : Natural renames Object.Container.all.HT.Busy;\n-\n          begin\n             B := B - 1;\n          end;\n@@ -479,13 +479,12 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n    function First (Container : Map) return Cursor is\n       Node : constant Node_Access := HT_Ops.First (Container.HT);\n-\n    begin\n       if Node = null then\n          return No_Element;\n+      else\n+         return Cursor'(Container'Unrestricted_Access, Node);\n       end if;\n-\n-      return Cursor'(Container'Unrestricted_Access, Node);\n    end First;\n \n    function First (Object : Iterator) return Cursor is\n@@ -726,7 +725,6 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n      (Container : Map) return Map_Iterator_Interfaces.Forward_Iterator'Class\n    is\n       B  : Natural renames Container'Unrestricted_Access.all.HT.Busy;\n-\n    begin\n       return It : constant Iterator :=\n                     (Limited_Controlled with\n@@ -809,13 +807,12 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       declare\n          HT   : Hash_Table_Type renames Position.Container.HT;\n          Node : constant Node_Access := HT_Ops.Next (HT, Position.Node);\n-\n       begin\n          if Node = null then\n             return No_Element;\n+         else\n+            return Cursor'(Position.Container, Node);\n          end if;\n-\n-         return Cursor'(Position.Container, Node);\n       end;\n    end Next;\n "}, {"sha": "e6899e8622e2d78a645a5f2514dd5d9672a4a466", "filename": "gcc/ada/a-cihase.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-cihase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-cihase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihase.adb?ref=e47e21c129bdb0cf5066944faf503f761b6023e0", "patch": "@@ -36,6 +36,7 @@ with Ada.Containers.Hash_Tables.Generic_Keys;\n pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Keys);\n \n with Ada.Containers.Prime_Numbers;\n+\n with System; use type System.Address;\n \n package body Ada.Containers.Indefinite_Hashed_Sets is\n@@ -576,7 +577,6 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       if Object.Container /= null then\n          declare\n             B : Natural renames Object.Container.all.HT.Busy;\n-\n          begin\n             B := B - 1;\n          end;\n@@ -1024,7 +1024,6 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n      return Set_Iterator_Interfaces.Forward_Iterator'Class\n    is\n       B : Natural renames Container'Unrestricted_Access.all.HT.Busy;\n-\n    begin\n       return It : constant Iterator :=\n                     Iterator'(Limited_Controlled with"}, {"sha": "08bfbaebaa46cbd69510afce33f965f13fc7feb0", "filename": "gcc/ada/a-cimutr.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-cimutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-cimutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cimutr.adb?ref=e47e21c129bdb0cf5066944faf503f761b6023e0", "patch": "@@ -28,6 +28,7 @@\n ------------------------------------------------------------------------------\n \n with Ada.Unchecked_Deallocation;\n+\n with System; use type System.Address;\n \n package body Ada.Containers.Indefinite_Multiway_Trees is\n@@ -940,7 +941,6 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       if Object.Container /= null then\n          declare\n             B : Natural renames Object.Container.all.Busy;\n-\n          begin\n             B := B - 1;\n          end;\n@@ -952,7 +952,6 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       if Object.Container /= null then\n          declare\n             B : Natural renames Object.Container.all.Busy;\n-\n          begin\n             B := B - 1;\n          end;\n@@ -1362,7 +1361,6 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       B  : Natural renames Container'Unrestricted_Access.all.Busy;\n       RC : constant Cursor :=\n              (Container'Unrestricted_Access, Root_Node (Container));\n-\n    begin\n       return It : constant Iterator :=\n                     Iterator'(Limited_Controlled with"}, {"sha": "d775b27fc1f96dcfa2d844a0a384cd033a6c9b8d", "filename": "gcc/ada/a-ciorma.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-ciorma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-ciorma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorma.adb?ref=e47e21c129bdb0cf5066944faf503f761b6023e0", "patch": "@@ -546,7 +546,6 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       if Object.Container /= null then\n          declare\n             B : Natural renames Object.Container.all.Tree.Busy;\n-\n          begin\n             B := B - 1;\n          end;"}, {"sha": "928ba9924c44e2a3c7ba4caa63fa026f9932186a", "filename": "gcc/ada/a-ciormu.adb", "status": "modified", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-ciormu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-ciormu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciormu.adb?ref=e47e21c129bdb0cf5066944faf503f761b6023e0", "patch": "@@ -42,6 +42,26 @@ with System; use type System.Address;\n \n package body Ada.Containers.Indefinite_Ordered_Multisets is\n \n+   type Iterator is new Limited_Controlled and\n+     Set_Iterator_Interfaces.Reversible_Iterator with\n+   record\n+      Container : Set_Access;\n+      Node      : Node_Access;\n+   end record;\n+\n+   overriding procedure Finalize (Object : in out Iterator);\n+\n+   overriding function First (Object : Iterator) return Cursor;\n+   overriding function Last  (Object : Iterator) return Cursor;\n+\n+   overriding function Next\n+     (Object   : Iterator;\n+      Position : Cursor) return Cursor;\n+\n+   overriding function Previous\n+     (Object   : Iterator;\n+      Position : Cursor) return Cursor;\n+\n    -----------------------------\n    -- Node Access Subprograms --\n    -----------------------------\n@@ -592,6 +612,17 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n       return Cursor'(Container'Unrestricted_Access, Node);\n    end Find;\n \n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (Object : in out Iterator) is\n+      B : Natural renames Object.Container.Tree.Busy;\n+      pragma Assert (B > 0);\n+   begin\n+      B := B - 1;\n+   end Finalize;\n+\n    -----------\n    -- First --\n    -----------\n@@ -605,6 +636,28 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n       return Cursor'(Container'Unrestricted_Access, Container.Tree.First);\n    end First;\n \n+   function First (Object : Iterator) return Cursor is\n+   begin\n+      --  The value of the iterator object's Node component influences the\n+      --  behavior of the First (and Last) selector function.\n+\n+      --  When the Node component is null, this means the iterator object was\n+      --  constructed without a start expression, in which case the (forward)\n+      --  iteration starts from the (logical) beginning of the entire sequence\n+      --  of items (corresponding to Container.First, for a forward iterator).\n+\n+      --  Otherwise, this is iteration over a partial sequence of items. When\n+      --  the Node component is non-null, the iterator object was constructed\n+      --  with a start expression, that specifies the position from which the\n+      --  (forward) partial iteration begins.\n+\n+      if Object.Node = null then\n+         return Object.Container.First;\n+      else\n+         return Cursor'(Object.Container, Object.Node);\n+      end if;\n+   end First;\n+\n    -------------------\n    -- First_Element --\n    -------------------\n@@ -1347,6 +1400,75 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n       B := B - 1;\n    end Iterate;\n \n+   function Iterate (Container : Set)\n+     return Set_Iterator_Interfaces.Reversible_Iterator'Class\n+   is\n+      S : constant Set_Access := Container'Unrestricted_Access;\n+      B : Natural renames S.Tree.Busy;\n+\n+   begin\n+      --  The value of the Node component influences the behavior of the First\n+      --  and Last selector functions of the iterator object. When the Node\n+      --  component is null (as is the case here), this means the iterator\n+      --  object was constructed without a start expression. This is a complete\n+      --  iterator, meaning that the iteration starts from the (logical)\n+      --  beginning of the sequence of items.\n+\n+      --  Note: For a forward iterator, Container.First is the beginning, and\n+      --  for a reverse iterator, Container.Last is the beginning.\n+\n+      return It : constant Iterator := (Limited_Controlled with S, null) do\n+         B := B + 1;\n+      end return;\n+   end Iterate;\n+\n+   function Iterate (Container : Set; Start : Cursor)\n+     return Set_Iterator_Interfaces.Reversible_Iterator'Class\n+   is\n+      S : constant Set_Access := Container'Unrestricted_Access;\n+      B : Natural renames S.Tree.Busy;\n+\n+   begin\n+      --  It was formerly the case that when Start = No_Element, the partial\n+      --  iterator was defined to behave the same as for a complete iterator,\n+      --  and iterate over the entire sequence of items. However, those\n+      --  semantics were unintuitive and arguably error-prone (it is too easy\n+      --  to accidentally create an endless loop), and so they were changed,\n+      --  per the ARG meeting in Denver on 2011/11. However, there was no\n+      --  consensus about what positive meaning this corner case should have,\n+      --  and so it was decided to simply raise an exception. This does imply,\n+      --  however, that it is not possible to use a partial iterator to specify\n+      --  an empty sequence of items.\n+\n+      if Start = No_Element then\n+         raise Constraint_Error with\n+           \"Start position for iterator equals No_Element\";\n+      end if;\n+\n+      if Start.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Start cursor of Iterate designates wrong set\";\n+      end if;\n+\n+      pragma Assert (Vet (Container.Tree, Start.Node),\n+                     \"Start cursor of Iterate is bad\");\n+\n+      --  The value of the Node component influences the behavior of the First\n+      --  and Last selector functions of the iterator object. When the Node\n+      --  component is non-null (as is the case here), it means that this is a\n+      --  partial iteration, over a subset of the complete sequence of\n+      --  items. The iterator object was constructed with a start expression,\n+      --  indicating the position from which the iteration begins. Note that\n+      --  the start position has the same value irrespective of whether this is\n+      --  a forward or reverse iteration.\n+\n+      return It : constant Iterator :=\n+                    (Limited_Controlled with S, Start.Node)\n+      do\n+         B := B + 1;\n+      end return;\n+   end Iterate;\n+\n    ----------\n    -- Last --\n    ----------\n@@ -1360,6 +1482,28 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n       return Cursor'(Container'Unrestricted_Access, Container.Tree.Last);\n    end Last;\n \n+   function Last (Object : Iterator) return Cursor is\n+   begin\n+      --  The value of the iterator object's Node component influences the\n+      --  behavior of the Last (and First) selector function.\n+\n+      --  When the Node component is null, this means the iterator object was\n+      --  constructed without a start expression, in which case the (reverse)\n+      --  iteration starts from the (logical) beginning of the entire sequence\n+      --  (corresponding to Container.Last, for a reverse iterator).\n+\n+      --  Otherwise, this is iteration over a partial sequence of items. When\n+      --  the Node component is non-null, the iterator object was constructed\n+      --  with a start expression, that specifies the position from which the\n+      --  (reverse) partial iteration begins.\n+\n+      if Object.Node = null then\n+         return Object.Container.Last;\n+      else\n+         return Cursor'(Object.Container, Object.Node);\n+      end if;\n+   end Last;\n+\n    ------------------\n    -- Last_Element --\n    ------------------\n@@ -1435,6 +1579,20 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n       Position := Next (Position);\n    end Next;\n \n+   function Next (Object : Iterator; Position : Cursor) return Cursor is\n+   begin\n+      if Position.Container = null then\n+         return No_Element;\n+      end if;\n+\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Next designates wrong set\";\n+      end if;\n+\n+      return Next (Position);\n+   end Next;\n+\n    -------------\n    -- Overlap --\n    -------------\n@@ -1484,6 +1642,20 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n       Position := Previous (Position);\n    end Previous;\n \n+   function Previous (Object : Iterator; Position : Cursor) return Cursor is\n+   begin\n+      if Position.Container = null then\n+         return No_Element;\n+      end if;\n+\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Previous designates wrong set\";\n+      end if;\n+\n+      return Previous (Position);\n+   end Previous;\n+\n    -------------------\n    -- Query_Element --\n    -------------------"}, {"sha": "cfd1676aa5f07e8be4a1484fb5306f74de913e13", "filename": "gcc/ada/a-ciormu.ads", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-ciormu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-ciormu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciormu.ads?ref=e47e21c129bdb0cf5066944faf503f761b6023e0", "patch": "@@ -35,6 +35,7 @@\n private with Ada.Containers.Red_Black_Trees;\n private with Ada.Finalization;\n private with Ada.Streams;\n+with Ada.Iterator_Interfaces;\n \n generic\n    type Element_Type (<>) is private;\n@@ -50,7 +51,10 @@ package Ada.Containers.Indefinite_Ordered_Multisets is\n    --  Returns False if Left is less than Right, or Right is less than Left;\n    --  otherwise, it returns True.\n \n-   type Set is tagged private;\n+   type Set is tagged private\n+   with Default_Iterator => Iterate,\n+        Iterator_Element => Element_Type;\n+\n    pragma Preelaborable_Initialization (Set);\n \n    type Cursor is private;\n@@ -64,6 +68,12 @@ package Ada.Containers.Indefinite_Ordered_Multisets is\n    --  The default value for cursor objects declared without an explicit\n    --  initialization expression.\n \n+   function Has_Element (Position : Cursor) return Boolean;\n+   --  Equivalent to Position /= No_Element\n+\n+   package Set_Iterator_Interfaces is new\n+     Ada.Iterator_Interfaces (Cursor, Has_Element);\n+\n    function \"=\" (Left, Right : Set) return Boolean;\n    --  If Left denotes the same set object as Right, then equality returns\n    --  True. If the length of Left is different from the length of Right, then\n@@ -286,9 +296,6 @@ package Ada.Containers.Indefinite_Ordered_Multisets is\n    function Contains (Container : Set; Item : Element_Type) return Boolean;\n    --  Equivalent to Container.Find (Item) /= No_Element\n \n-   function Has_Element (Position : Cursor) return Boolean;\n-   --  Equivalent to Position /= No_Element\n-\n    function \"<\" (Left, Right : Cursor) return Boolean;\n    --  Equivalent to Element (Left) < Element (Right)\n \n@@ -333,6 +340,15 @@ package Ada.Containers.Indefinite_Ordered_Multisets is\n    --  Call Process with a cursor designating each element equivalent to Item,\n    --  in order from Container.Ceiling (Item) to Container.Floor (Item).\n \n+   function Iterate\n+     (Container : Set)\n+      return Set_Iterator_Interfaces.Reversible_Iterator'class;\n+\n+   function Iterate\n+     (Container : Set;\n+      Start     : Cursor)\n+      return Set_Iterator_Interfaces.Reversible_Iterator'class;\n+\n    generic\n       type Key_Type (<>) is private;\n "}, {"sha": "0a99a82a7a9fd1f9784a94085933fdce66a05a8e", "filename": "gcc/ada/a-ciorse.adb", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-ciorse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-ciorse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorse.adb?ref=e47e21c129bdb0cf5066944faf503f761b6023e0", "patch": "@@ -37,6 +37,7 @@ with Ada.Containers.Red_Black_Trees.Generic_Set_Operations;\n pragma Elaborate_All (Ada.Containers.Red_Black_Trees.Generic_Set_Operations);\n \n with Ada.Unchecked_Deallocation;\n+\n with System; use type System.Address;\n \n package body Ada.Containers.Indefinite_Ordered_Sets is\n@@ -581,7 +582,6 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       if Object.Container /= null then\n          declare\n             B : Natural renames Object.Container.all.Tree.Busy;\n-\n          begin\n             B := B - 1;\n          end;\n@@ -595,13 +595,12 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n    function Find (Container : Set; Item : Element_Type) return Cursor is\n       Node : constant Node_Access :=\n                Element_Keys.Find (Container.Tree, Item);\n-\n    begin\n       if Node = null then\n          return No_Element;\n+      else\n+         return Cursor'(Container'Unrestricted_Access, Node);\n       end if;\n-\n-      return Cursor'(Container'Unrestricted_Access, Node);\n    end Find;\n \n    -----------\n@@ -766,13 +765,12 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       function Element (Container : Set; Key : Key_Type) return Element_Type is\n          Node : constant Node_Access :=\n                   Key_Keys.Find (Container.Tree, Key);\n-\n       begin\n          if Node = null then\n             raise Constraint_Error with \"key not in set\";\n+         else\n+            return Node.Element.all;\n          end if;\n-\n-         return Node.Element.all;\n       end Element;\n \n       ---------------------"}, {"sha": "e9c879d47a5798074a8108c57400c5ac69fde965", "filename": "gcc/ada/a-cobove.adb", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-cobove.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-cobove.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cobove.adb?ref=e47e21c129bdb0cf5066944faf503f761b6023e0", "patch": "@@ -29,6 +29,7 @@\n \n with Ada.Containers.Generic_Array_Sort;\n with Ada.Finalization; use Ada.Finalization;\n+\n with System; use type System.Address;\n \n package body Ada.Containers.Bounded_Vectors is\n@@ -670,7 +671,6 @@ package body Ada.Containers.Bounded_Vectors is\n       if Object.Container /= null then\n          declare\n             B : Natural renames Object.Container.all.Busy;\n-\n          begin\n             B := B - 1;\n          end;\n@@ -1649,7 +1649,6 @@ package body Ada.Containers.Bounded_Vectors is\n       return Vector_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n       B : Natural renames Container'Unrestricted_Access.all.Busy;\n-\n    begin\n       return It : constant Iterator :=\n                     Iterator'(Limited_Controlled with\n@@ -1666,7 +1665,6 @@ package body Ada.Containers.Bounded_Vectors is\n       return Vector_Iterator_Interfaces.Reversible_Iterator'class\n    is\n       B : Natural renames Container'Unrestricted_Access.all.Busy;\n-\n    begin\n       return It : constant Iterator :=\n                     Iterator'(Limited_Controlled with\n@@ -1783,7 +1781,8 @@ package body Ada.Containers.Bounded_Vectors is\n            \"attempt to tamper with cursors (Source is busy)\";\n       end if;\n \n-      --  Clear Target now, in case element assignment fails.\n+      --  Clear Target now, in case element assignment fails\n+\n       Target.Last := No_Index;\n \n       Target.Elements (1 .. Source.Length) :=\n@@ -1992,8 +1991,10 @@ package body Ada.Containers.Bounded_Vectors is\n    ---------------\n \n    function Constant_Reference\n-     (Container : Vector; Position : Cursor)    --  SHOULD BE ALIASED\n-   return Constant_Reference_Type is\n+     (Container : Vector;\n+      Position  : Cursor)    --  SHOULD BE ALIASED\n+      return Constant_Reference_Type\n+   is\n    begin\n       pragma Unreferenced (Container);\n \n@@ -2012,8 +2013,10 @@ package body Ada.Containers.Bounded_Vectors is\n    end Constant_Reference;\n \n    function Constant_Reference\n-     (Container : Vector; Position : Index_Type)\n-   return Constant_Reference_Type is\n+     (Container : Vector;\n+      Position  : Index_Type)\n+      return Constant_Reference_Type\n+   is\n    begin\n       if (Position) > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n@@ -2023,8 +2026,11 @@ package body Ada.Containers.Bounded_Vectors is\n                 Container.Elements (To_Array_Index (Position))'Access);\n    end Constant_Reference;\n \n-   function Reference (Container : Vector; Position : Cursor)\n-   return Reference_Type is\n+   function Reference\n+     (Container : Vector;\n+      Position  : Cursor)\n+      return Reference_Type\n+   is\n    begin\n       pragma Unreferenced (Container);\n \n@@ -2042,8 +2048,11 @@ package body Ada.Containers.Bounded_Vectors is\n              (To_Array_Index (Position.Index))'Access);\n    end Reference;\n \n-   function Reference (Container : Vector; Position : Index_Type)\n-   return Reference_Type is\n+   function Reference\n+     (Container : Vector;\n+      Position  : Index_Type)\n+      return Reference_Type\n+   is\n    begin\n       if Position > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";"}, {"sha": "2bc2ca956f9c67aca81ffb20b22b0c3c3f6ed48a", "filename": "gcc/ada/a-cohama.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-cohama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-cohama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohama.adb?ref=e47e21c129bdb0cf5066944faf503f761b6023e0", "patch": "@@ -393,7 +393,6 @@ package body Ada.Containers.Hashed_Maps is\n       if Object.Container /= null then\n          declare\n             B : Natural renames Object.Container.all.HT.Busy;\n-\n          begin\n             B := B - 1;\n          end;\n@@ -678,7 +677,6 @@ package body Ada.Containers.Hashed_Maps is\n      (Container : Map) return Map_Iterator_Interfaces.Forward_Iterator'Class\n    is\n       B  : Natural renames Container'Unrestricted_Access.all.HT.Busy;\n-\n    begin\n       return It : constant Iterator :=\n                     (Limited_Controlled with"}, {"sha": "d969c757875239ab695b2a458b45a112ceafebc4", "filename": "gcc/ada/a-coormu.adb", "status": "modified", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-coormu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-coormu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coormu.adb?ref=e47e21c129bdb0cf5066944faf503f761b6023e0", "patch": "@@ -42,6 +42,26 @@ with System; use type System.Address;\n \n package body Ada.Containers.Ordered_Multisets is\n \n+   type Iterator is new Limited_Controlled and\n+     Set_Iterator_Interfaces.Reversible_Iterator with\n+   record\n+      Container : Set_Access;\n+      Node      : Node_Access;\n+   end record;\n+\n+   overriding procedure Finalize (Object : in out Iterator);\n+\n+   overriding function First (Object : Iterator) return Cursor;\n+   overriding function Last  (Object : Iterator) return Cursor;\n+\n+   overriding function Next\n+     (Object   : Iterator;\n+      Position : Cursor) return Cursor;\n+\n+   overriding function Previous\n+     (Object   : Iterator;\n+      Position : Cursor) return Cursor;\n+\n    -----------------------------\n    -- Node Access Subprograms --\n    -----------------------------\n@@ -531,6 +551,17 @@ package body Ada.Containers.Ordered_Multisets is\n       end loop;\n    end Exclude;\n \n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (Object : in out Iterator) is\n+      B : Natural renames Object.Container.Tree.Busy;\n+      pragma Assert (B > 0);\n+   begin\n+      B := B - 1;\n+   end Finalize;\n+\n    ----------\n    -- Find --\n    ----------\n@@ -560,6 +591,28 @@ package body Ada.Containers.Ordered_Multisets is\n       return Cursor'(Container'Unrestricted_Access, Container.Tree.First);\n    end First;\n \n+   function First (Object : Iterator) return Cursor is\n+   begin\n+      --  The value of the iterator object's Node component influences the\n+      --  behavior of the First (and Last) selector function.\n+\n+      --  When the Node component is null, this means the iterator object was\n+      --  constructed without a start expression, in which case the (forward)\n+      --  iteration starts from the (logical) beginning of the entire sequence\n+      --  of items (corresponding to Container.First, for a forward iterator).\n+\n+      --  Otherwise, this is iteration over a partial sequence of items. When\n+      --  the Node component is non-null, the iterator object was constructed\n+      --  with a start expression, that specifies the position from which the\n+      --  (forward) partial iteration begins.\n+\n+      if Object.Node = null then\n+         return Object.Container.First;\n+      else\n+         return Cursor'(Object.Container, Object.Node);\n+      end if;\n+   end First;\n+\n    -------------------\n    -- First_Element --\n    -------------------\n@@ -1269,6 +1322,75 @@ package body Ada.Containers.Ordered_Multisets is\n       B := B - 1;\n    end Iterate;\n \n+   function Iterate (Container : Set)\n+     return Set_Iterator_Interfaces.Reversible_Iterator'Class\n+   is\n+      S : constant Set_Access := Container'Unrestricted_Access;\n+      B : Natural renames S.Tree.Busy;\n+\n+   begin\n+      --  The value of the Node component influences the behavior of the First\n+      --  and Last selector functions of the iterator object. When the Node\n+      --  component is null (as is the case here), this means the iterator\n+      --  object was constructed without a start expression. This is a complete\n+      --  iterator, meaning that the iteration starts from the (logical)\n+      --  beginning of the sequence of items.\n+\n+      --  Note: For a forward iterator, Container.First is the beginning, and\n+      --  for a reverse iterator, Container.Last is the beginning.\n+\n+      return It : constant Iterator := (Limited_Controlled with S, null) do\n+         B := B + 1;\n+      end return;\n+   end Iterate;\n+\n+   function Iterate (Container : Set; Start : Cursor)\n+     return Set_Iterator_Interfaces.Reversible_Iterator'Class\n+   is\n+      S : constant Set_Access := Container'Unrestricted_Access;\n+      B : Natural renames S.Tree.Busy;\n+\n+   begin\n+      --  It was formerly the case that when Start = No_Element, the partial\n+      --  iterator was defined to behave the same as for a complete iterator,\n+      --  and iterate over the entire sequence of items. However, those\n+      --  semantics were unintuitive and arguably error-prone (it is too easy\n+      --  to accidentally create an endless loop), and so they were changed,\n+      --  per the ARG meeting in Denver on 2011/11. However, there was no\n+      --  consensus about what positive meaning this corner case should have,\n+      --  and so it was decided to simply raise an exception. This does imply,\n+      --  however, that it is not possible to use a partial iterator to specify\n+      --  an empty sequence of items.\n+\n+      if Start = No_Element then\n+         raise Constraint_Error with\n+           \"Start position for iterator equals No_Element\";\n+      end if;\n+\n+      if Start.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Start cursor of Iterate designates wrong set\";\n+      end if;\n+\n+      pragma Assert (Vet (Container.Tree, Start.Node),\n+                     \"Start cursor of Iterate is bad\");\n+\n+      --  The value of the Node component influences the behavior of the First\n+      --  and Last selector functions of the iterator object. When the Node\n+      --  component is non-null (as is the case here), it means that this is a\n+      --  partial iteration, over a subset of the complete sequence of\n+      --  items. The iterator object was constructed with a start expression,\n+      --  indicating the position from which the iteration begins. Note that\n+      --  the start position has the same value irrespective of whether this is\n+      --  a forward or reverse iteration.\n+\n+      return It : constant Iterator :=\n+                    (Limited_Controlled with S, Start.Node)\n+      do\n+         B := B + 1;\n+      end return;\n+   end Iterate;\n+\n    ----------\n    -- Last --\n    ----------\n@@ -1282,6 +1404,28 @@ package body Ada.Containers.Ordered_Multisets is\n       return Cursor'(Container'Unrestricted_Access, Container.Tree.Last);\n    end Last;\n \n+   function Last (Object : Iterator) return Cursor is\n+   begin\n+      --  The value of the iterator object's Node component influences the\n+      --  behavior of the Last (and First) selector function.\n+\n+      --  When the Node component is null, this means the iterator object was\n+      --  constructed without a start expression, in which case the (reverse)\n+      --  iteration starts from the (logical) beginning of the entire sequence\n+      --  (corresponding to Container.Last, for a reverse iterator).\n+\n+      --  Otherwise, this is iteration over a partial sequence of items. When\n+      --  the Node component is non-null, the iterator object was constructed\n+      --  with a start expression, that specifies the position from which the\n+      --  (reverse) partial iteration begins.\n+\n+      if Object.Node = null then\n+         return Object.Container.Last;\n+      else\n+         return Cursor'(Object.Container, Object.Node);\n+      end if;\n+   end Last;\n+\n    ------------------\n    -- Last_Element --\n    ------------------\n@@ -1356,6 +1500,20 @@ package body Ada.Containers.Ordered_Multisets is\n       end;\n    end Next;\n \n+   function Next (Object : Iterator; Position : Cursor) return Cursor is\n+   begin\n+      if Position.Container = null then\n+         return No_Element;\n+      end if;\n+\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Next designates wrong set\";\n+      end if;\n+\n+      return Next (Position);\n+   end Next;\n+\n    -------------\n    -- Overlap --\n    -------------\n@@ -1405,6 +1563,20 @@ package body Ada.Containers.Ordered_Multisets is\n       end;\n    end Previous;\n \n+   function Previous (Object : Iterator; Position : Cursor) return Cursor is\n+   begin\n+      if Position.Container = null then\n+         return No_Element;\n+      end if;\n+\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Previous designates wrong set\";\n+      end if;\n+\n+      return Previous (Position);\n+   end Previous;\n+\n    -------------------\n    -- Query_Element --\n    -------------------"}, {"sha": "a832cac77f076dc792a6eba75778de7fd1804e88", "filename": "gcc/ada/a-coormu.ads", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-coormu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e47e21c129bdb0cf5066944faf503f761b6023e0/gcc%2Fada%2Fa-coormu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coormu.ads?ref=e47e21c129bdb0cf5066944faf503f761b6023e0", "patch": "@@ -34,6 +34,7 @@\n private with Ada.Containers.Red_Black_Trees;\n private with Ada.Finalization;\n private with Ada.Streams;\n+with Ada.Iterator_Interfaces;\n \n generic\n    type Element_Type is private;\n@@ -49,7 +50,10 @@ package Ada.Containers.Ordered_Multisets is\n    --  Returns False if Left is less than Right, or Right is less than Left;\n    --  otherwise, it returns True.\n \n-   type Set is tagged private;\n+   type Set is tagged private\n+   with Default_Iterator => Iterate,\n+        Iterator_Element => Element_Type;\n+\n    pragma Preelaborable_Initialization (Set);\n \n    type Cursor is private;\n@@ -63,6 +67,12 @@ package Ada.Containers.Ordered_Multisets is\n    --  The default value for cursor objects declared without an explicit\n    --  initialization expression.\n \n+   function Has_Element (Position : Cursor) return Boolean;\n+   --  Equivalent to Position /= No_Element\n+\n+   package Set_Iterator_Interfaces is new\n+     Ada.Iterator_Interfaces (Cursor, Has_Element);\n+\n    function \"=\" (Left, Right : Set) return Boolean;\n    --  If Left denotes the same set object as Right, then equality returns\n    --  True. If the length of Left is different from the length of Right, then\n@@ -293,9 +303,6 @@ package Ada.Containers.Ordered_Multisets is\n    function Contains (Container : Set; Item : Element_Type) return Boolean;\n    --  Equivalent to Container.Find (Item) /= No_Element\n \n-   function Has_Element (Position : Cursor) return Boolean;\n-   --  Equivalent to Position /= No_Element\n-\n    function \"<\" (Left, Right : Cursor) return Boolean;\n    --  Equivalent to Element (Left) < Element (Right)\n \n@@ -340,6 +347,15 @@ package Ada.Containers.Ordered_Multisets is\n    --  Call Process with a cursor designating each element equivalent to Item,\n    --  in order from Container.Ceiling (Item) to Container.Floor (Item).\n \n+   function Iterate\n+     (Container : Set)\n+      return Set_Iterator_Interfaces.Reversible_Iterator'class;\n+\n+   function Iterate\n+     (Container : Set;\n+      Start     : Cursor)\n+      return Set_Iterator_Interfaces.Reversible_Iterator'class;\n+\n    generic\n       type Key_Type (<>) is private;\n "}]}