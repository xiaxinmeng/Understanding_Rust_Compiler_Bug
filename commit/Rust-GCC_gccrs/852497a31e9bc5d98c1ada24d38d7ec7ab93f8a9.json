{"sha": "852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODUyNDk3YTMxZTliYzVkOThjMWFkYTI0ZDM4ZDdlYzdhYjkzZjhhOQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2012-03-24T20:56:08Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2012-03-24T20:56:08Z"}, "message": "Implement return type deduction for normal functions with -std=c++1y.\n\n\t* cp-tree.h (FNDECL_USED_AUTO): New macro.\n\t(LAMBDA_EXPR_DEDUCE_RETURN_TYPE_P): Remove.\n\t(dependent_lambda_return_type_node): Remove.\n\t(CPTI_DEPENDENT_LAMBDA_RETURN_TYPE): Remove.\n\t(struct language_function): Add x_auto_return_pattern field.\n\t(current_function_auto_return_pattern): New.\n\t(enum tsubst_flags): Add tf_partial.\n\t* decl.c (decls_match): Handle auto return comparison.\n\t(duplicate_decls): Adjust error message for auto return.\n\t(cxx_init_decl_processing): Remove dependent_lambda_return_type_node.\n\t(cp_finish_decl): Don't do auto deduction for functions.\n\t(grokdeclarator): Allow auto return without trailing return type in\n\tC++1y mode.\n\t(check_function_type): Defer checking of deduced return type.\n\t(start_preparsed_function): Set current_function_auto_return_pattern.\n\t(finish_function): Set deduced return type to void if not previously\n\tdeduced.\n\t* decl2.c (change_return_type): Handle error_mark_node.\n\t(mark_used): Always instantiate functions with deduced return type.\n\tComplain about use if deduction isn't done.\n\t* parser.c (cp_parser_lambda_declarator_opt): Use 'auto' for\n\tinitial return type.\n\t(cp_parser_lambda_body): Don't deduce return type in a template.\n\t(cp_parser_conversion_type_id): Allow auto in C++1y.\n\t* pt.c (instantiate_class_template_1): Don't mess with\n\tLAMBDA_EXPR_DEDUCE_RETURN_TYPE_P.\n\t(tsubst_copy_and_build): Likewise.\n\t(fn_type_unification, tsubst): Don't reduce the template parm level\n\tof 'auto' during deduction.\n\t(unify): Compare 'auto' specially.\n\t(get_bindings): Change test.\n\t(always_instantiate_p): Always instantiate functions with deduced\n\treturn type.\n\t(do_auto_deduction): Handle error_mark_node and lambda context.\n\tDon't check for use in initializer.\n\t(contains_auto_r): Remove.\n\t* search.c (lookup_conversions_r): Handle auto conversion function.\n\t* semantics.c (lambda_return_type): Handle null return.  Don't mess\n\twith dependent_lambda_return_type_node.\n\t(apply_deduced_return_type): Rename from apply_lambda_return_type.\n\t* typeck.c (merge_types): Handle auto.\n\t(check_return_expr): Do auto deduction.\n\t* typeck2.c (add_exception_specifier): Fix complain check.\n\nFrom-SVN: r185768", "tree": {"sha": "f4083b8417d9f0e518dd8e9e301138cb94c4b2a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4083b8417d9f0e518dd8e9e301138cb94c4b2a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8c5f2327427996b4b25ad6a4e0ce69832d025ea2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c5f2327427996b4b25ad6a4e0ce69832d025ea2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c5f2327427996b4b25ad6a4e0ce69832d025ea2"}], "stats": {"total": 553, "additions": 405, "deletions": 148}, "files": [{"sha": "9cd2711e0a979de8372082783a86efb8a32d4627", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "patch": "@@ -1,3 +1,50 @@\n+2012-03-21  Jason Merrill  <jason@redhat.com>\n+\n+\tImplement return type deduction for normal functions with -std=c++1y.\n+\t* cp-tree.h (FNDECL_USED_AUTO): New macro.\n+\t(LAMBDA_EXPR_DEDUCE_RETURN_TYPE_P): Remove.\n+\t(dependent_lambda_return_type_node): Remove.\n+\t(CPTI_DEPENDENT_LAMBDA_RETURN_TYPE): Remove.\n+\t(struct language_function): Add x_auto_return_pattern field.\n+\t(current_function_auto_return_pattern): New.\n+\t(enum tsubst_flags): Add tf_partial.\n+\t* decl.c (decls_match): Handle auto return comparison.\n+\t(duplicate_decls): Adjust error message for auto return.\n+\t(cxx_init_decl_processing): Remove dependent_lambda_return_type_node.\n+\t(cp_finish_decl): Don't do auto deduction for functions.\n+\t(grokdeclarator): Allow auto return without trailing return type in\n+\tC++1y mode.\n+\t(check_function_type): Defer checking of deduced return type.\n+\t(start_preparsed_function): Set current_function_auto_return_pattern.\n+\t(finish_function): Set deduced return type to void if not previously\n+\tdeduced.\n+\t* decl2.c (change_return_type): Handle error_mark_node.\n+\t(mark_used): Always instantiate functions with deduced return type.\n+\tComplain about use if deduction isn't done.\n+\t* parser.c (cp_parser_lambda_declarator_opt): Use 'auto' for\n+\tinitial return type.\n+\t(cp_parser_lambda_body): Don't deduce return type in a template.\n+\t(cp_parser_conversion_type_id): Allow auto in C++1y.\n+\t* pt.c (instantiate_class_template_1): Don't mess with\n+\tLAMBDA_EXPR_DEDUCE_RETURN_TYPE_P.\n+\t(tsubst_copy_and_build): Likewise.\n+\t(fn_type_unification, tsubst): Don't reduce the template parm level\n+\tof 'auto' during deduction.\n+\t(unify): Compare 'auto' specially.\n+\t(get_bindings): Change test.\n+\t(always_instantiate_p): Always instantiate functions with deduced\n+\treturn type.\n+\t(do_auto_deduction): Handle error_mark_node and lambda context.\n+\tDon't check for use in initializer.\n+\t(contains_auto_r): Remove.\n+\t* search.c (lookup_conversions_r): Handle auto conversion function.\n+\t* semantics.c (lambda_return_type): Handle null return.  Don't mess\n+\twith dependent_lambda_return_type_node.\n+\t(apply_deduced_return_type): Rename from apply_lambda_return_type.\n+\t* typeck.c (merge_types): Handle auto.\n+\t(check_return_expr): Do auto deduction.\n+\t* typeck2.c (add_exception_specifier): Fix complain check.\n+\n 2012-03-22  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/52487"}, {"sha": "7d986a8cf735131a5f8c3620ad37921008124580", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "patch": "@@ -96,8 +96,8 @@ c-common.h, not after.\n       DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (in VAR_DECL)\n       STATEMENT_LIST_TRY_BLOCK (in STATEMENT_LIST)\n       TYPENAME_IS_RESOLVING_P (in TYPE_NAME_TYPE)\n-      LAMBDA_EXPR_DEDUCE_RETURN_TYPE_P (in LAMBDA_EXPR)\n       TARGET_EXPR_DIRECT_INIT_P (in TARGET_EXPR)\n+      FNDECL_USED_AUTO (in FUNCTION_DECL)\n    3: (TREE_REFERENCE_EXPR) (in NON_LVALUE_EXPR) (commented-out).\n       ICS_BAD_FLAG (in _CONV)\n       FN_TRY_BLOCK_P (in TRY_BLOCK)\n@@ -660,11 +660,6 @@ enum cp_lambda_default_capture_mode_type {\n #define LAMBDA_EXPR_MUTABLE_P(NODE) \\\n   TREE_LANG_FLAG_1 (LAMBDA_EXPR_CHECK (NODE))\n \n-/* True iff we should try to deduce the lambda return type from any return\n-   statement.  */\n-#define LAMBDA_EXPR_DEDUCE_RETURN_TYPE_P(NODE) \\\n-  TREE_LANG_FLAG_2 (LAMBDA_EXPR_CHECK (NODE))\n-\n /* The return type in the expression.\n  * NULL_TREE indicates that none was specified.  */\n #define LAMBDA_EXPR_RETURN_TYPE(NODE) \\\n@@ -804,7 +799,6 @@ enum cp_tree_index\n     CPTI_CLASS_TYPE,\n     CPTI_UNKNOWN_TYPE,\n     CPTI_INIT_LIST_TYPE,\n-    CPTI_DEPENDENT_LAMBDA_RETURN_TYPE,\n     CPTI_VTBL_TYPE,\n     CPTI_VTBL_PTR_TYPE,\n     CPTI_STD,\n@@ -876,7 +870,6 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n #define class_type_node\t\t\tcp_global_trees[CPTI_CLASS_TYPE]\n #define unknown_type_node\t\tcp_global_trees[CPTI_UNKNOWN_TYPE]\n #define init_list_type_node\t\tcp_global_trees[CPTI_INIT_LIST_TYPE]\n-#define dependent_lambda_return_type_node cp_global_trees[CPTI_DEPENDENT_LAMBDA_RETURN_TYPE]\n #define vtbl_type_node\t\t\tcp_global_trees[CPTI_VTBL_TYPE]\n #define vtbl_ptr_type_node\t\tcp_global_trees[CPTI_VTBL_PTR_TYPE]\n #define std_node\t\t\tcp_global_trees[CPTI_STD]\n@@ -1076,6 +1069,7 @@ struct GTY(()) language_function {\n   tree x_in_charge_parm;\n   tree x_vtt_parm;\n   tree x_return_value;\n+  tree x_auto_return_pattern;\n \n   BOOL_BITFIELD returns_value : 1;\n   BOOL_BITFIELD returns_null : 1;\n@@ -1158,6 +1152,11 @@ struct GTY(()) language_function {\n #define current_function_return_value \\\n   (cp_function_chain->x_return_value)\n \n+/* A type involving 'auto' to be used for return type deduction.  */\n+\n+#define current_function_auto_return_pattern \\\n+  (cp_function_chain->x_auto_return_pattern)\n+\n /* True if NAME is the IDENTIFIER_NODE for an overloaded \"operator\n    new\" or \"operator delete\".  */\n #define NEW_DELETE_OPNAME_P(NAME)\t\t\\\n@@ -3085,6 +3084,13 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define DECL_LOCAL_FUNCTION_P(NODE) \\\n   DECL_LANG_FLAG_0 (FUNCTION_DECL_CHECK (NODE))\n \n+/* True if NODE was declared with auto in its return type, but it has\n+   started compilation and so the return type might have been changed by\n+   return type deduction; its declared return type should be found in\n+   DECL_STRUCT_FUNCTION(NODE)->language->x_auto_return_pattern.  */\n+#define FNDECL_USED_AUTO(NODE) \\\n+  TREE_LANG_FLAG_2 (FUNCTION_DECL_CHECK (NODE))\n+\n /* Nonzero if NODE is a DECL which we know about but which has not\n    been explicitly declared, such as a built-in function or a friend\n    declared inside a class.  In the latter case DECL_HIDDEN_FRIEND_P\n@@ -4144,6 +4150,8 @@ enum tsubst_flags {\n \t\t\t\t    conversion.  */\n   tf_no_access_control = 1 << 7, /* Do not perform access checks, even\n \t\t\t\t    when issuing other errors.   */\n+  tf_partial = 1 << 8,\t\t /* Doing initial explicit argument\n+\t\t\t\t    substitution in fn_type_unification.  */\n   /* Convenient substitution flags combinations.  */\n   tf_warning_or_error = tf_warning | tf_error\n };\n@@ -5619,7 +5627,7 @@ extern tree lambda_capture_field_type\t\t(tree);\n extern tree lambda_return_type\t\t\t(tree);\n extern tree lambda_proxy_type\t\t\t(tree);\n extern tree lambda_function\t\t\t(tree);\n-extern void apply_lambda_return_type            (tree, tree);\n+extern void apply_deduced_return_type           (tree, tree);\n extern tree add_capture                         (tree, tree, tree, bool, bool);\n extern tree add_default_capture                 (tree, tree, tree);\n extern tree build_capture_proxy\t\t\t(tree);"}, {"sha": "f021edf36e5829e5c8f8944a90df956ce578b097", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 51, "deletions": 13, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "patch": "@@ -960,6 +960,7 @@ decls_match (tree newdecl, tree olddecl)\n       tree f2 = TREE_TYPE (olddecl);\n       tree p1 = TYPE_ARG_TYPES (f1);\n       tree p2 = TYPE_ARG_TYPES (f2);\n+      tree r2;\n \n       /* Specializations of different templates are different functions\n \t even if they have the same type.  */\n@@ -988,7 +989,14 @@ decls_match (tree newdecl, tree olddecl)\n       if (TREE_CODE (f1) != TREE_CODE (f2))\n \treturn 0;\n \n-      if (same_type_p (TREE_TYPE (f1), TREE_TYPE (f2)))\n+      /* A declaration with deduced return type should use its pre-deduction\n+\t type for declaration matching.  */\n+      if (FNDECL_USED_AUTO (olddecl))\n+\tr2 = DECL_STRUCT_FUNCTION (olddecl)->language->x_auto_return_pattern;\n+      else\n+\tr2 = TREE_TYPE (f2);\n+\n+      if (same_type_p (TREE_TYPE (f1), r2))\n \t{\n \t  if (!prototype_p (f2) && DECL_EXTERN_C_P (olddecl)\n \t      && (DECL_BUILT_IN (olddecl)\n@@ -1486,7 +1494,11 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t\t\t      TYPE_ARG_TYPES (TREE_TYPE (olddecl))))\n \t    {\n \t      error (\"new declaration %q#D\", newdecl);\n-\t      error (\"ambiguates old declaration %q+#D\", olddecl);\n+\t      if (FNDECL_USED_AUTO (olddecl))\n+\t\terror_at (DECL_SOURCE_LOCATION (olddecl), \"ambiguates old \"\n+\t\t\t  \"declaration with deduced return type\");\n+\t      else\n+\t\terror (\"ambiguates old declaration %q+#D\", olddecl);\n               return error_mark_node;\n \t    }\n \t  else\n@@ -3644,10 +3656,6 @@ cxx_init_decl_processing (void)\n   init_list_type_node = make_node (LANG_TYPE);\n   record_unknown_type (init_list_type_node, \"init list\");\n \n-  dependent_lambda_return_type_node = make_node (LANG_TYPE);\n-  record_unknown_type (dependent_lambda_return_type_node,\n-\t\t       \"undeduced lambda return type\");\n-\n   {\n     /* Make sure we get a unique function type, so we can give\n        its pointer type a name.  (This wins for gdb.) */\n@@ -6008,8 +6016,8 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n       && (DECL_INITIAL (decl) || init))\n     DECL_INITIALIZED_IN_CLASS_P (decl) = 1;\n \n-  auto_node = type_uses_auto (type);\n-  if (auto_node)\n+  if (TREE_CODE (decl) != FUNCTION_DECL\n+      && (auto_node = type_uses_auto (type)))\n     {\n       tree d_init;\n       if (init == NULL_TREE)\n@@ -9188,9 +9196,13 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t  {\n \t\t    if (!declarator->u.function.late_return_type)\n \t\t      {\n-\t\t\terror (\"%qs function uses %<auto%> type specifier without\"\n-\t\t\t       \" trailing return type\", name);\n-\t\t\treturn error_mark_node;\n+\t\t\tif (current_class_type\n+\t\t\t    && LAMBDA_TYPE_P (current_class_type))\n+\t\t\t  /* OK for C++11 lambdas.  */;\n+\t\t\telse if (cxx_dialect < cxx1y)\n+\t\t\t  pedwarn (input_location, 0, \"%qs function uses \"\n+\t\t\t\t   \"%<auto%> type specifier without trailing \"\n+\t\t\t\t   \"return type\", name);\n \t\t      }\n \t\t    else if (!is_auto (type))\n \t\t      {\n@@ -10029,7 +10041,8 @@ grokdeclarator (const cp_declarator *declarator,\n       }\n     else if (decl_context == FIELD)\n       {\n-\tif (!staticp && type_uses_auto (type))\n+\tif (!staticp && TREE_CODE (type) != METHOD_TYPE\n+\t    && type_uses_auto (type))\n \t  {\n \t    error (\"non-static data member declared %<auto%>\");\n \t    type = error_mark_node;\n@@ -12570,7 +12583,8 @@ check_function_type (tree decl, tree current_function_parms)\n   /* In a function definition, arg types must be complete.  */\n   require_complete_types_for_parms (current_function_parms);\n \n-  if (dependent_type_p (return_type))\n+  if (dependent_type_p (return_type)\n+      || type_uses_auto (return_type))\n     return;\n   if (!COMPLETE_OR_VOID_TYPE_P (return_type)\n       || (TYPE_FOR_JAVA (return_type) && MAYBE_CLASS_TYPE_P (return_type)))\n@@ -12741,6 +12755,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n \n   /* Build the return declaration for the function.  */\n   restype = TREE_TYPE (fntype);\n+\n   if (DECL_RESULT (decl1) == NULL_TREE)\n     {\n       tree resdecl;\n@@ -12849,6 +12864,12 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n   current_stmt_tree ()->stmts_are_full_exprs_p = 1;\n   current_binding_level = bl;\n \n+  if (!processing_template_decl && type_uses_auto (restype))\n+    {\n+      FNDECL_USED_AUTO (decl1) = true;\n+      current_function_auto_return_pattern = restype;\n+    }\n+\n   /* Start the statement-tree, start the tree now.  */\n   DECL_SAVED_TREE (decl1) = push_stmt_list ();\n \n@@ -13463,6 +13484,23 @@ finish_function (int flags)\n      of curly braces for a function.  */\n   gcc_assert (stmts_are_full_exprs_p ());\n \n+  /* If there are no return statements in a function with auto return type,\n+     the return type is void.  But if the declared type is something like\n+     auto*, this is an error.  */\n+  if (!processing_template_decl && FNDECL_USED_AUTO (fndecl)\n+      && TREE_TYPE (fntype) == current_function_auto_return_pattern)\n+    {\n+      if (!is_auto (current_function_auto_return_pattern)\n+\t  && !current_function_returns_value && !current_function_returns_null)\n+\t{\n+\t  error (\"no return statements in function returning %qT\",\n+\t\t current_function_auto_return_pattern);\n+\t  inform (input_location, \"only plain %<auto%> return type can be \"\n+\t\t  \"deduced to %<void%>\");\n+\t}\n+      apply_deduced_return_type (fndecl, void_type_node);\n+    }\n+\n   /* Save constexpr function body before it gets munged by\n      the NRV transformation.   */\n   maybe_save_function_definition (fndecl);"}, {"sha": "b048ac7b3cd569c1478526f7a565360e9bb4ce0d", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "patch": "@@ -151,6 +151,9 @@ change_return_type (tree new_ret, tree fntype)\n   tree raises = TYPE_RAISES_EXCEPTIONS (fntype);\n   tree attrs = TYPE_ATTRIBUTES (fntype);\n \n+  if (new_ret == error_mark_node)\n+    return fntype;\n+\n   if (same_type_p (new_ret, TREE_TYPE (fntype)))\n     return fntype;\n \n@@ -4281,7 +4284,11 @@ mark_used (tree decl)\n   if ((TREE_CODE (decl) != VAR_DECL && TREE_CODE (decl) != FUNCTION_DECL)\n       || DECL_LANG_SPECIFIC (decl) == NULL\n       || DECL_THUNK_P (decl))\n-    return true;\n+    {\n+      if (!processing_template_decl && type_uses_auto (TREE_TYPE (decl)))\n+\terror (\"use of %qD before deduction of %<auto%>\", decl);\n+      return true;\n+    }\n \n   /* We only want to do this processing once.  We don't need to keep trying\n      to instantiate inline templates, because unit-at-a-time will make sure\n@@ -4303,10 +4310,13 @@ mark_used (tree decl)\n   /* Normally, we can wait until instantiation-time to synthesize DECL.\n      However, if DECL is a static data member initialized with a constant\n      or a constexpr function, we need it right now because a reference to\n-     such a data member or a call to such function is not value-dependent.  */\n+     such a data member or a call to such function is not value-dependent.\n+     For a function that uses auto in the return type, we need to instantiate\n+     it to find out its type.  */\n   if ((decl_maybe_constant_var_p (decl)\n        || (TREE_CODE (decl) == FUNCTION_DECL\n-\t   && DECL_DECLARED_CONSTEXPR_P (decl)))\n+\t   && (DECL_DECLARED_CONSTEXPR_P (decl)\n+\t       || type_uses_auto (TREE_TYPE (TREE_TYPE (decl))))))\n       && DECL_LANG_SPECIFIC (decl)\n       && DECL_TEMPLATE_INFO (decl)\n       && !uses_template_parms (DECL_TI_ARGS (decl)))\n@@ -4321,6 +4331,9 @@ mark_used (tree decl)\n       --function_depth;\n     }\n \n+  if (type_uses_auto (TREE_TYPE (decl)))\n+    error (\"use of %qD before deduction of %<auto%>\", decl);\n+\n   /* If we don't need a value, then we don't need to synthesize DECL.  */\n   if (cp_unevaluated_operand != 0)\n     return true;"}, {"sha": "eac60f13572821e25d5d1b77b3a457fb3210da0c", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "patch": "@@ -8416,9 +8416,8 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n     if (LAMBDA_EXPR_RETURN_TYPE (lambda_expr))\n       return_type_specs.type = LAMBDA_EXPR_RETURN_TYPE (lambda_expr);\n     else\n-      /* Maybe we will deduce the return type later, but we can use void\n-\t as a placeholder return type anyways.  */\n-      return_type_specs.type = void_type_node;\n+      /* Maybe we will deduce the return type later.  */\n+      return_type_specs.type = make_auto ();\n \n     p = obstack_alloc (&declarator_obstack, 0);\n \n@@ -8539,7 +8538,8 @@ cp_parser_lambda_body (cp_parser* parser, tree lambda_expr)\n \n \tif (cp_parser_parse_definitely (parser))\n \t  {\n-\t    apply_lambda_return_type (lambda_expr, lambda_return_type (expr));\n+\t    if (!processing_template_decl)\n+\t      apply_deduced_return_type (fco, lambda_return_type (expr));\n \n \t    /* Will get error here if type not deduced yet.  */\n \t    finish_return_stmt (expr);\n@@ -8550,13 +8550,10 @@ cp_parser_lambda_body (cp_parser* parser, tree lambda_expr)\n \n     if (!done)\n       {\n-\tif (!LAMBDA_EXPR_RETURN_TYPE (lambda_expr))\n-\t  LAMBDA_EXPR_DEDUCE_RETURN_TYPE_P (lambda_expr) = true;\n \twhile (cp_lexer_next_token_is_keyword (parser->lexer, RID_LABEL))\n \t  cp_parser_label_declaration (parser);\n \tcp_parser_statement_seq_opt (parser, NULL_TREE);\n \tcp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n-\tLAMBDA_EXPR_DEDUCE_RETURN_TYPE_P (lambda_expr) = false;\n       }\n \n     finish_compound_stmt (compound_stmt);\n@@ -11275,8 +11272,14 @@ cp_parser_conversion_type_id (cp_parser* parser)\n   if (! cp_parser_uncommitted_to_tentative_parse_p (parser)\n       && type_uses_auto (type_specified))\n     {\n-      error (\"invalid use of %<auto%> in conversion operator\");\n-      return error_mark_node;\n+      if (cxx_dialect < cxx1y)\n+\t{\n+\t  error (\"invalid use of %<auto%> in conversion operator\");\n+\t  return error_mark_node;\n+\t}\n+      else if (template_parm_scope_p ())\n+\twarning (0, \"use of %<auto%> in member template \"\n+\t\t \"conversion operator can never be deduced\");\n     }\n \n   return type_specified;"}, {"sha": "f128947ead867ef12d2c11f53874a4759b8fb2b0", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 32, "deletions": 46, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "patch": "@@ -9112,12 +9112,6 @@ instantiate_class_template_1 (tree type)\n       tree decl = lambda_function (type);\n       if (decl)\n \t{\n-\t  tree lambda = CLASSTYPE_LAMBDA_EXPR (type);\n-\t  if (LAMBDA_EXPR_DEDUCE_RETURN_TYPE_P (lambda))\n-\t    {\n-\t      apply_lambda_return_type (lambda, void_type_node);\n-\t      LAMBDA_EXPR_RETURN_TYPE (lambda) = NULL_TREE;\n-\t    }\n \t  instantiate_decl (decl, false, false);\n \t  maybe_add_lambda_conv_op (type);\n \t}\n@@ -11331,6 +11325,12 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t     about the template parameter in question.  */\n \t  return t;\n \n+\t/* Early in template argument deduction substitution, we don't\n+\t   want to reduce the level of 'auto', or it will be confused\n+\t   with a normal template parm in subsequent deduction.  */\n+\tif (is_auto (t) && (complain & tf_partial))\n+\t  return t;\n+\n \t/* If we get here, we must have been looking at a parm for a\n \t   more deeply nested template.  Make a new version of this\n \t   template parameter, but with a lower level.  */\n@@ -14334,14 +14334,8 @@ tsubst_copy_and_build (tree t,\n \t  = (LAMBDA_EXPR_DISCRIMINATOR (t));\n \tLAMBDA_EXPR_EXTRA_SCOPE (r)\n \t  = RECUR (LAMBDA_EXPR_EXTRA_SCOPE (t));\n-\tif (LAMBDA_EXPR_RETURN_TYPE (t) == dependent_lambda_return_type_node)\n-\t  {\n-\t    LAMBDA_EXPR_RETURN_TYPE (r) = dependent_lambda_return_type_node;\n-\t    LAMBDA_EXPR_DEDUCE_RETURN_TYPE_P (r) = true;\n-\t  }\n-\telse\n-\t  LAMBDA_EXPR_RETURN_TYPE (r)\n-\t    = tsubst (LAMBDA_EXPR_RETURN_TYPE (t), args, complain, in_decl);\n+\tLAMBDA_EXPR_RETURN_TYPE (r)\n+\t  = tsubst (LAMBDA_EXPR_RETURN_TYPE (t), args, complain, in_decl);\n \n \tgcc_assert (LAMBDA_EXPR_THIS_CAPTURE (t) == NULL_TREE\n \t\t    && LAMBDA_EXPR_PENDING_PROXIES (t) == NULL);\n@@ -14860,7 +14854,7 @@ fn_type_unification (tree fn,\n       fntype = deduction_tsubst_fntype (fn, converted_args,\n \t\t\t\t\t(explain_p\n \t\t\t\t\t ? tf_warning_or_error\n-\t\t\t\t\t : tf_none));\n+\t\t\t\t\t : tf_none) | tf_partial);\n       processing_template_decl -= incomplete;\n \n       if (fntype == error_mark_node)\n@@ -16275,7 +16269,8 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n \t   to see if it matches ARG.  */\n \t{\n \t  if (TREE_CODE (arg) == TREE_CODE (parm)\n-\t      && same_type_p (parm, arg))\n+\t      && (is_auto (parm) ? is_auto (arg)\n+\t\t  : same_type_p (parm, arg)))\n \t    return unify_success (explain_p);\n \t  else\n \t    return unify_type_mismatch (explain_p, parm, arg);\n@@ -17408,7 +17403,7 @@ get_bindings (tree fn, tree decl, tree explicit_args, bool check_rettype)\n      The call to fn_type_unification will handle substitution into the\n      FN.  */\n   decl_type = TREE_TYPE (decl);\n-  if (explicit_args && uses_template_parms (decl_type))\n+  if (explicit_args && decl == DECL_TEMPLATE_RESULT (fn))\n     {\n       tree tmpl;\n       tree converted_args;\n@@ -18315,7 +18310,8 @@ always_instantiate_p (tree decl)\n      that for \"extern template\" functions.  Therefore, we check\n      DECL_DECLARED_INLINE_P, rather than possibly_inlined_p.  */\n   return ((TREE_CODE (decl) == FUNCTION_DECL\n-\t   && DECL_DECLARED_INLINE_P (decl))\n+\t   && (DECL_DECLARED_INLINE_P (decl)\n+\t       || type_uses_auto (TREE_TYPE (TREE_TYPE (decl)))))\n \t  /* And we need to instantiate static data members so that\n \t     their initializers are available in integral constant\n \t     expressions.  */\n@@ -20269,20 +20265,6 @@ listify_autos (tree type, tree auto_node)\n   return tsubst (type, argvec, tf_warning_or_error, NULL_TREE);\n }\n \n-/* walk_tree helper for do_auto_deduction.  */\n-\n-static tree\n-contains_auto_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n-\t\t void *type)\n-{\n-  /* Is this a variable with the type we're looking for?  */\n-  if (DECL_P (*tp)\n-      && TREE_TYPE (*tp) == type)\n-    return *tp;\n-  else\n-    return NULL_TREE;\n-}\n-\n /* Replace occurrences of 'auto' in TYPE with the appropriate type deduced\n    from INIT.  AUTO_NODE is the TEMPLATE_TYPE_PARM used for 'auto' in TYPE.  */\n \n@@ -20291,25 +20273,17 @@ do_auto_deduction (tree type, tree init, tree auto_node)\n {\n   tree parms, tparms, targs;\n   tree args[1];\n-  tree decl;\n   int val;\n \n+  if (init == error_mark_node)\n+    return error_mark_node;\n+\n   if (processing_template_decl\n       && (TREE_TYPE (init) == NULL_TREE\n \t  || BRACE_ENCLOSED_INITIALIZER_P (init)))\n     /* Not enough information to try this yet.  */\n     return type;\n \n-  /* The name of the object being declared shall not appear in the\n-     initializer expression.  */\n-  decl = cp_walk_tree_without_duplicates (&init, contains_auto_r, type);\n-  if (decl)\n-    {\n-      error (\"variable %q#D with %<auto%> type used in its own \"\n-\t     \"initializer\", decl);\n-      return error_mark_node;\n-    }\n-\n   /* [dcl.spec.auto]: Obtain P from T by replacing the occurrences of auto\n      with either a new invented type template parameter U or, if the\n      initializer is a braced-init-list (8.5.4), with\n@@ -20337,7 +20311,13 @@ do_auto_deduction (tree type, tree init, tree auto_node)\n \t/* If type is error_mark_node a diagnostic must have been\n \t   emitted by now.  Also, having a mention to '<type error>'\n \t   in the diagnostic is not really useful to the user.  */\n-\terror (\"unable to deduce %qT from %qE\", type, init);\n+\t{\n+\t  if (cfun && auto_node == current_function_auto_return_pattern\n+\t      && LAMBDA_FUNCTION_P (current_function_decl))\n+\t    error (\"unable to deduce lambda return type from %qE\", init);\n+\t  else\n+\t    error (\"unable to deduce %qT from %qE\", type, init);\n+\t}\n       return error_mark_node;\n     }\n \n@@ -20348,8 +20328,14 @@ do_auto_deduction (tree type, tree init, tree auto_node)\n   if (TREE_TYPE (auto_node)\n       && !same_type_p (TREE_TYPE (auto_node), TREE_VEC_ELT (targs, 0)))\n     {\n-      error (\"inconsistent deduction for %qT: %qT and then %qT\",\n-\t     auto_node, TREE_TYPE (auto_node), TREE_VEC_ELT (targs, 0));\n+      if (cfun && auto_node == current_function_auto_return_pattern\n+\t  && LAMBDA_FUNCTION_P (current_function_decl))\n+\terror (\"inconsistent types %qT and %qT deduced for \"\n+\t       \"lambda return type\", TREE_TYPE (auto_node),\n+\t       TREE_VEC_ELT (targs, 0));\n+      else\n+\terror (\"inconsistent deduction for %qT: %qT and then %qT\",\n+\t       auto_node, TREE_TYPE (auto_node), TREE_VEC_ELT (targs, 0));\n       return error_mark_node;\n     }\n   TREE_TYPE (auto_node) = TREE_VEC_ELT (targs, 0);"}, {"sha": "14d272e10e86e12457e413894b4edf3dab68232a", "filename": "gcc/cp/search.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "patch": "@@ -2430,6 +2430,11 @@ lookup_conversions_r (tree binfo,\n \t  if (!IDENTIFIER_MARKED (name))\n \t    {\n \t      tree type = DECL_CONV_FN_TYPE (cur);\n+\t      if (type_uses_auto (type))\n+\t\t{\n+\t\t  mark_used (cur);\n+\t\t  type = DECL_CONV_FN_TYPE (cur);\n+\t\t}\n \n \t      if (check_hidden_convs (binfo, virtual_depth, virtualness,\n \t\t\t\t      type, parent_convs, other_convs))"}, {"sha": "6294e19af607aa6e45597f950079f5a89b28207d", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "patch": "@@ -8691,18 +8691,16 @@ begin_lambda_type (tree lambda)\n tree\n lambda_return_type (tree expr)\n {\n-  tree type;\n+  if (expr == NULL_TREE)\n+    return void_type_node;\n   if (type_unknown_p (expr)\n       || BRACE_ENCLOSED_INITIALIZER_P (expr))\n     {\n       cxx_incomplete_type_error (expr, TREE_TYPE (expr));\n       return void_type_node;\n     }\n-  if (type_dependent_expression_p (expr))\n-    type = dependent_lambda_return_type_node;\n-  else\n-    type = cv_unqualified (type_decays_to (unlowered_expr_type (expr)));\n-  return type;\n+  gcc_checking_assert (!type_dependent_expression_p (expr));\n+  return cv_unqualified (type_decays_to (unlowered_expr_type (expr)));\n }\n \n /* Given a LAMBDA_EXPR or closure type LAMBDA, return the op() of the\n@@ -8749,29 +8747,32 @@ lambda_capture_field_type (tree expr)\n   return type;\n }\n \n-/* Recompute the return type for LAMBDA with body of the form:\n-     { return EXPR ; }  */\n+/* Insert the deduced return type for an auto function.  */\n \n void\n-apply_lambda_return_type (tree lambda, tree return_type)\n+apply_deduced_return_type (tree fco, tree return_type)\n {\n-  tree fco = lambda_function (lambda);\n   tree result;\n \n-  LAMBDA_EXPR_RETURN_TYPE (lambda) = return_type;\n-\n   if (return_type == error_mark_node)\n     return;\n-  if (TREE_TYPE (TREE_TYPE (fco)) == return_type)\n-    return;\n \n-  /* TREE_TYPE (FUNCTION_DECL) == METHOD_TYPE\n-     TREE_TYPE (METHOD_TYPE)   == return-type  */\n+  if (LAMBDA_FUNCTION_P (fco))\n+    {\n+      tree lambda = CLASSTYPE_LAMBDA_EXPR (current_class_type);\n+      LAMBDA_EXPR_RETURN_TYPE (lambda) = return_type;\n+    }\n+\n+  if (DECL_CONV_FN_P (fco))\n+    DECL_NAME (fco) = mangle_conv_op_name_for_type (return_type);\n+\n   TREE_TYPE (fco) = change_return_type (return_type, TREE_TYPE (fco));\n \n   result = DECL_RESULT (fco);\n   if (result == NULL_TREE)\n     return;\n+  if (TREE_TYPE (result) == return_type)\n+    return;\n \n   /* We already have a DECL_RESULT from start_preparsed_function.\n      Now we need to redo the work it and allocate_struct_function\n@@ -8786,12 +8787,13 @@ apply_lambda_return_type (tree lambda, tree return_type)\n \n   DECL_RESULT (fco) = result;\n \n-  if (!processing_template_decl && aggregate_value_p (result, fco))\n+  if (!processing_template_decl)\n     {\n+      bool aggr = aggregate_value_p (result, fco);\n #ifdef PCC_STATIC_STRUCT_RETURN\n-      cfun->returns_pcc_struct = 1;\n+      cfun->returns_pcc_struct = aggr;\n #endif\n-      cfun->returns_struct = 1;\n+      cfun->returns_struct = aggr;\n     }\n \n }"}, {"sha": "b68de52a13e04f3f4123e1bfad0a195a59c1e6f3", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 54, "deletions": 41, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "patch": "@@ -733,6 +733,11 @@ merge_types (tree t1, tree t2)\n   if (t2 == error_mark_node)\n     return t1;\n \n+  /* Handle merging an auto redeclaration with a previous deduced\n+     return type.  */\n+  if (is_auto (t1))\n+    return t2;\n+\n   /* Merge the attributes.  */\n   attributes = (*targetm.merge_type_attributes) (t1, t2);\n \n@@ -7779,9 +7784,11 @@ tree\n check_return_expr (tree retval, bool *no_warning)\n {\n   tree result;\n-  /* The type actually returned by the function, after any\n-     promotions.  */\n+  /* The type actually returned by the function.  */\n   tree valtype;\n+  /* The type the function is declared to return, or void if\n+     the declared type is incomplete.  */\n+  tree functype;\n   int fn_returns_value_p;\n   bool named_return_value_okay_p;\n \n@@ -7812,30 +7819,6 @@ check_return_expr (tree retval, bool *no_warning)\n       return NULL_TREE;\n     }\n \n-  /* As an extension, deduce lambda return type from a return statement\n-     anywhere in the body.  */\n-  if (retval && LAMBDA_FUNCTION_P (current_function_decl))\n-    {\n-      tree lambda = CLASSTYPE_LAMBDA_EXPR (current_class_type);\n-      if (LAMBDA_EXPR_DEDUCE_RETURN_TYPE_P (lambda))\n-\t{\n-\t  tree type = lambda_return_type (retval);\n-\t  tree oldtype = LAMBDA_EXPR_RETURN_TYPE (lambda);\n-\n-\t  if (oldtype == NULL_TREE)\n-\t    apply_lambda_return_type (lambda, type);\n-\t  /* If one of the answers is type-dependent, we can't do any\n-\t     better until instantiation time.  */\n-\t  else if (oldtype == dependent_lambda_return_type_node)\n-\t    /* Leave it.  */;\n-\t  else if (type == dependent_lambda_return_type_node)\n-\t    apply_lambda_return_type (lambda, type);\n-\t  else if (!same_type_p (type, oldtype))\n-\t    error (\"inconsistent types %qT and %qT deduced for \"\n-\t\t   \"lambda return type\", type, oldtype);\n-\t}\n-    }\n-\n   if (processing_template_decl)\n     {\n       current_function_returns_value = 1;\n@@ -7844,6 +7827,42 @@ check_return_expr (tree retval, bool *no_warning)\n       return retval;\n     }\n \n+  functype = TREE_TYPE (TREE_TYPE (current_function_decl));\n+\n+  /* Deduce auto return type from a return statement.  */\n+  if (current_function_auto_return_pattern)\n+    {\n+      tree auto_node;\n+      tree type;\n+\n+      if (!retval && !is_auto (current_function_auto_return_pattern))\n+\t{\n+\t  /* Give a helpful error message.  */\n+\t  error (\"return-statement with no value, in function returning %qT\",\n+\t\t current_function_auto_return_pattern);\n+\t  inform (input_location, \"only plain %<auto%> return type can be \"\n+\t\t  \"deduced to %<void%>\");\n+\t  type = error_mark_node;\n+\t}\n+      else\n+\t{\n+\t  if (!retval)\n+\t    retval = void_zero_node;\n+\t  auto_node = type_uses_auto (current_function_auto_return_pattern);\n+\t  type = do_auto_deduction (current_function_auto_return_pattern,\n+\t\t\t\t    retval, auto_node);\n+\t}\n+\n+      if (type == error_mark_node)\n+\t/* Leave it.  */;\n+      else if (functype == current_function_auto_return_pattern)\n+\tapply_deduced_return_type (current_function_decl, type);\n+      else\n+\t/* A mismatch should have been diagnosed in do_auto_deduction.  */\n+\tgcc_assert (same_type_p (type, functype));\n+      functype = type;\n+    }\n+\n   /* When no explicit return-value is given in a function with a named\n      return value, the named return value is used.  */\n   result = DECL_RESULT (current_function_decl);\n@@ -7857,12 +7876,11 @@ check_return_expr (tree retval, bool *no_warning)\n      that's supposed to return a value.  */\n   if (!retval && fn_returns_value_p)\n     {\n-      permerror (input_location, \"return-statement with no value, in function returning %qT\",\n-\t         valtype);\n-      /* Clear this, so finish_function won't say that we reach the\n-\t end of a non-void function (which we don't, we gave a\n-\t return!).  */\n-      current_function_returns_null = 0;\n+      if (functype != error_mark_node)\n+\tpermerror (input_location, \"return-statement with no value, in \"\n+\t\t   \"function returning %qT\", valtype);\n+      /* Remember that this function did return.  */\n+      current_function_returns_value = 1;\n       /* And signal caller that TREE_NO_WARNING should be set on the\n \t RETURN_EXPR to avoid control reaches end of non-void function\n \t warnings in tree-cfg.c.  */\n@@ -7963,14 +7981,12 @@ check_return_expr (tree retval, bool *no_warning)\n      && DECL_CONTEXT (retval) == current_function_decl\n      && ! TREE_STATIC (retval)\n      && ! DECL_ANON_UNION_VAR_P (retval)\n-     && (DECL_ALIGN (retval)\n-         >= DECL_ALIGN (DECL_RESULT (current_function_decl)))\n+     && (DECL_ALIGN (retval) >= DECL_ALIGN (result))\n      /* The cv-unqualified type of the returned value must be the\n         same as the cv-unqualified return type of the\n         function.  */\n      && same_type_p ((TYPE_MAIN_VARIANT (TREE_TYPE (retval))),\n-                     (TYPE_MAIN_VARIANT\n-                      (TREE_TYPE (TREE_TYPE (current_function_decl)))))\n+                     (TYPE_MAIN_VARIANT (functype)))\n      /* And the returned value must be non-volatile.  */\n      && ! TYPE_VOLATILE (TREE_TYPE (retval)));\n      \n@@ -7995,8 +8011,6 @@ check_return_expr (tree retval, bool *no_warning)\n     ;\n   else\n     {\n-      /* The type the function is declared to return.  */\n-      tree functype = TREE_TYPE (TREE_TYPE (current_function_decl));\n       int flags = LOOKUP_NORMAL | LOOKUP_ONLYCONVERTING;\n \n       /* The functype's return type will have been set to void, if it\n@@ -8016,10 +8030,9 @@ check_return_expr (tree retval, bool *no_warning)\n \t  && DECL_CONTEXT (retval) == current_function_decl\n \t  && !TREE_STATIC (retval)\n \t  && same_type_p ((TYPE_MAIN_VARIANT (TREE_TYPE (retval))),\n-\t\t\t  (TYPE_MAIN_VARIANT\n-\t\t\t   (TREE_TYPE (TREE_TYPE (current_function_decl)))))\n+\t\t\t  (TYPE_MAIN_VARIANT (functype)))\n \t  /* This is only interesting for class type.  */\n-\t  && CLASS_TYPE_P (TREE_TYPE (TREE_TYPE (current_function_decl))))\n+\t  && CLASS_TYPE_P (functype))\n \tflags = flags | LOOKUP_PREFER_RVALUE;\n \n       /* First convert the value to the function's return type, then"}, {"sha": "80a1d0462ceb5bb8fe9457f29e538663f3f02690", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "patch": "@@ -1818,7 +1818,8 @@ add_exception_specifier (tree list, tree spec, int complain)\n   else\n     diag_type = DK_ERROR; /* error */\n \n-  if (diag_type != DK_UNSPECIFIED && complain)\n+  if (diag_type != DK_UNSPECIFIED\n+      && (complain & tf_warning_or_error))\n     cxx_incomplete_type_diagnostic (NULL_TREE, core, diag_type);\n \n   return list;"}, {"sha": "94120525c342bc34fd9b39deca322a79fac74a00", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "patch": "@@ -1,3 +1,20 @@\n+2012-03-21  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/cpp0x/auto3.C: Compile with -pedantic-errors.\n+\t* g++.dg/cpp0x/trailing2.C: Likewise.\n+\t* g++.dg/warn/pr23075.C: Change dg-warning to dg-bogus.\n+\t* g++.dg/cpp1y/auto-fn1.C: New.\n+\t* g++.dg/cpp1y/auto-fn2.C: New.\n+\t* g++.dg/cpp1y/auto-fn3.C: New.\n+\t* g++.dg/cpp1y/auto-fn4.C: New.\n+\t* g++.dg/cpp1y/auto-fn5.C: New.\n+\t* g++.dg/cpp1y/auto-fn6.C: New.\n+\t* g++.dg/cpp1y/auto-fn7.C: New.\n+\t* g++.dg/cpp1y/auto-fn8.C: New.\n+\t* g++.dg/cpp1y/auto-fn9.C: New.\n+\t* g++.dg/cpp1y/auto-fn10.C: New.\n+\t* g++.dg/cpp1y/auto-fn11.C: New.\n+\n 2012-03-23  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/52678"}, {"sha": "0a59242ab29c44f39c233a3ab131c14b73e2a1ab", "filename": "gcc/testsuite/g++.dg/cpp0x/auto18.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto18.C?ref=852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "patch": "@@ -2,5 +2,5 @@\n \n void f()\n {\n-  auto val = val;  // { dg-error \"auto. type used in its own initializer\" }\n+  auto val = val;  // { dg-error \"auto\" }\n }"}, {"sha": "2b51d3191d1f6cb111261c833bc148de4b026d4b", "filename": "gcc/testsuite/g++.dg/cpp0x/auto3.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto3.C?ref=852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "patch": "@@ -1,5 +1,5 @@\n // Negative test for auto\n-// { dg-options \"-std=c++0x\" }\n+// { dg-do compile { target c++11 } }\n \n #include <initializer_list>\n \n@@ -10,7 +10,7 @@ auto x;\t\t\t\t// { dg-error \"auto\" }\n auto i = 42, j = 42.0;\t\t// { dg-error \"auto\" }\n \n // New CWG issue\n-auto a[2] = { 1, 2 };\t\t// { dg-error \"initializer_list\" }\n+auto a[2] = { 1, 2 };\t\t// { dg-error \"auto|initializer_list\" }\n \n template<class T>\n struct A { };"}, {"sha": "91e55578d9bad17adc9a96485911da3bf7d77be6", "filename": "gcc/testsuite/g++.dg/cpp0x/trailing2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ftrailing2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ftrailing2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ftrailing2.C?ref=852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "patch": "@@ -1,6 +1,6 @@\n // PR c++/37967\n // Negative test for auto\n-// { dg-options \"-std=c++0x\" }\n+// { dg-do compile { target c++11 } }\n \n auto f1 () -> int;\n auto f2 ();\t\t// { dg-error \"without trailing return type\" }"}, {"sha": "eb541490bb33be4a8d364af784b9cb70bea96b64", "filename": "gcc/testsuite/g++.dg/cpp1y/auto-fn1.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn1.C?ref=852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "patch": "@@ -0,0 +1,5 @@\n+// { dg-options -std=c++1y }\n+\n+constexpr auto f() { return (char)42; }\n+#define SA(X) static_assert ((X),#X)\n+SA (f() == 42);"}, {"sha": "e3ed3a93352efd3739b267abd6b38c2de5e6fc1e", "filename": "gcc/testsuite/g++.dg/cpp1y/auto-fn10.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn10.C?ref=852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "patch": "@@ -0,0 +1,16 @@\n+// A template declared with auto should be declared with auto in an\n+// explicit instantiation or explicit specialization, too.\n+// { dg-options -std=c++1y }\n+\n+template <class T>\n+auto f(T t) { return t; }\n+\n+template<> auto f<int>(int);\n+template auto f<float>(float);\n+template<> auto f(int*);\n+template auto f(float*);\n+\n+template<> short f<short>(short); // { dg-error \"does not match\" }\n+template char f<char>(char);\t  // { dg-error \"does not match\" }\n+template<> short f(short*);\t  // { dg-error \"does not match\" }\n+template char f(char*);\t\t  // { dg-error \"does not match\" }"}, {"sha": "a9984aa54a18ef83550c3c1e9584af544e04549e", "filename": "gcc/testsuite/g++.dg/cpp1y/auto-fn11.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn11.C?ref=852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "patch": "@@ -0,0 +1,5 @@\n+// { dg-options -std=c++1y }\n+\n+auto f() { return; } \t\t// OK, return type is void\n+auto* g() { return; }\t\t// { dg-error \"no value\" }\n+auto* h() { }\t\t\t// { dg-error \"no return statements\" }"}, {"sha": "e4e58e8999a622c5d5e7dc247122f61edeb79468", "filename": "gcc/testsuite/g++.dg/cpp1y/auto-fn12.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn12.C?ref=852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "patch": "@@ -0,0 +1,14 @@\n+// { dg-options -std=c++1y }\n+// { dg-final { scan-assembler \"_ZN1AIiEcviEv\" } }\n+\n+template <class T>\n+struct A {\n+  T t;\n+  operator auto() { return t+1; }\n+};\n+\n+int main()\n+{\n+  int i = A<int>{42};\n+  return (i != 43);\n+}"}, {"sha": "34a61ae20e3888f760c20a9a7e9aeb30bcc2cfb5", "filename": "gcc/testsuite/g++.dg/cpp1y/auto-fn13.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn13.C?ref=852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "patch": "@@ -0,0 +1,6 @@\n+// { dg-options -std=c++1y }\n+\n+struct A {\n+  template <class T>\n+  operator auto() { return T(); } // { dg-warning \"auto.*template\" }\n+};"}, {"sha": "4c2cee7d285478b41711da0c2940696b081b9172", "filename": "gcc/testsuite/g++.dg/cpp1y/auto-fn2.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn2.C?ref=852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "patch": "@@ -0,0 +1,3 @@\n+// { dg-options -std=c++1y }\n+\n+auto f() { return f(); }\t// { dg-error \"auto\" }"}, {"sha": "107c37f915d7abb943cdf3eef0d57a9328dafd38", "filename": "gcc/testsuite/g++.dg/cpp1y/auto-fn3.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn3.C?ref=852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "patch": "@@ -0,0 +1,10 @@\n+// { dg-options -std=c++1y }\n+\n+bool b;\n+auto f()\n+{\n+  if (b)\n+    return 42;\n+  else\n+    return f();\n+}"}, {"sha": "0b76bfce03a2b1e473c50d7f280c1cf1c8e5cf1e", "filename": "gcc/testsuite/g++.dg/cpp1y/auto-fn4.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn4.C?ref=852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "patch": "@@ -0,0 +1,7 @@\n+// { dg-options -std=c++1y }\n+\n+template <class T>\n+constexpr auto f(T t) { return t+1; }\n+\n+#define SA(X) static_assert((X),#X)\n+SA(f(1)==2);"}, {"sha": "f9af6c2fee0d61fe8bbfcf140a14f9db946b2d5f", "filename": "gcc/testsuite/g++.dg/cpp1y/auto-fn5.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn5.C?ref=852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "patch": "@@ -0,0 +1,11 @@\n+// { dg-options -std=c++1y }\n+// { dg-do run }\n+\n+int i;\n+auto& f() { return i; }\n+\n+int main()\n+{\n+  f() = 42;\n+  return i != 42;\n+}"}, {"sha": "03ff537b23935636b367d9106fde5fd0b90edce3", "filename": "gcc/testsuite/g++.dg/cpp1y/auto-fn6.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn6.C?ref=852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "patch": "@@ -0,0 +1,18 @@\n+// { dg-options -std=c++1y }\n+\n+template <class T, class U> struct ST;\n+template <class T> struct ST<T,T> {};\n+\n+int g(int);\n+char& g(char);\n+double&& g(double);\n+\n+template <class T> auto&& f(T t)\n+{ return g(t); }\t\t// { dg-warning \"reference to temporary\" }\n+\n+int main()\n+{\n+  ST<decltype(f(1)),int&&>();\n+  ST<decltype(f('\\0')),char&>();\n+  ST<decltype(f(1.0)),double&&>();\n+}"}, {"sha": "b915352a41c48098a7300e8c6ba70165158477b5", "filename": "gcc/testsuite/g++.dg/cpp1y/auto-fn7.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn7.C?ref=852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "patch": "@@ -0,0 +1,5 @@\n+// { dg-options \"-std=c++1y -pedantic-errors\" }\n+\n+auto f();\n+\n+template <class T> auto f(T);"}, {"sha": "dcec899379b6300f1a8e4f6ab32acfcb84bcee47", "filename": "gcc/testsuite/g++.dg/cpp1y/auto-fn8.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn8.C?ref=852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "patch": "@@ -0,0 +1,13 @@\n+// { dg-options \"-std=c++1y -pedantic-errors\" }\n+\n+auto f() { return 42; }\t\t// { dg-error \"deduced return type\" }\n+auto f();\t\t\t// OK\n+int f();\t\t\t// { dg-error \"new declaration\" }\n+\n+template <class T> auto f(T t) { return t; }\n+template <class T> T f(T t);\n+\n+int main()\n+{\n+  f(42);\t\t\t// { dg-error \"ambiguous\" }\n+}"}, {"sha": "1fa747942cd671315bb5fd1cfb42fa25ea5dd29e", "filename": "gcc/testsuite/g++.dg/cpp1y/auto-fn9.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn9.C?ref=852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "patch": "@@ -0,0 +1,11 @@\n+// { dg-options -std=c++1y }\n+// { dg-final { scan-assembler \"_Z1fIiERDaRKT_S1_\" } }\n+\n+template <class T>\n+auto& f(const T& t, T u) { return t; }\n+\n+int main()\n+{\n+  int i;\n+  f(i,i);\n+}"}, {"sha": "481583e80e3daa2f5d3239cdb3a99ae2bf202860", "filename": "gcc/testsuite/g++.dg/gomp/pr38639.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr38639.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr38639.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr38639.C?ref=852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "patch": "@@ -6,7 +6,7 @@ template<int> void\n foo ()\n {\n #pragma omp parallel for\n-  for (auto i = i = 0; i<4; ++i)\t// { dg-error \"incomplete|unable|invalid\" }\n+  for (auto i = i = 0; i<4; ++i)\t// { dg-error \"incomplete|unable|invalid|auto\" }\n     ;\n }\n "}, {"sha": "59e93be48f84fc0d3a240685979e035658d2bb3b", "filename": "gcc/testsuite/g++.dg/warn/pr23075.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr23075.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr23075.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr23075.C?ref=852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "patch": "@@ -6,4 +6,4 @@ int\n foo (void)\n {\n   return;\t// { dg-error \"with no value\" }\n-}\t\t// { dg-warning \"no return statement\" }\n+}\t\t// { dg-bogus \"no return statement\" }"}, {"sha": "94bffdbecaa6fa86438bf9fd1a2670f6545b9aa6", "filename": "gcc/testsuite/g++.old-deja/g++.pt/spec22.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec22.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec22.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec22.C?ref=852497a31e9bc5d98c1ada24d38d7ec7ab93f8a9", "patch": "@@ -10,6 +10,6 @@ struct S\n \n template <class T> \n template <> // { dg-error \"enclosing class templates|invalid explicit specialization\" }\n-void S<T>::f<int> ()  // { dg-error \"does not match|invalid function declaration\" }\n+void S<T>::f<int> ()\n {\n }"}]}