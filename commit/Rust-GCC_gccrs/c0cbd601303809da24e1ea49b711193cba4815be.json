{"sha": "c0cbd601303809da24e1ea49b711193cba4815be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBjYmQ2MDEzMDM4MDlkYTI0ZTFlYTQ5YjcxMTE5M2NiYTQ4MTViZQ==", "commit": {"author": {"name": "Bryce McKinlay", "email": "mckinlay@redhat.com", "date": "2005-03-11T04:30:20Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2005-03-11T04:30:20Z"}, "message": "exception.cc: Remove stray MethodRef.h include.\n\n2005-03-10  Bryce McKinlay  <mckinlay@redhat.com>\n\n        * exception.cc: Remove stray MethodRef.h include.\n        * java/lang/natClass.cc: Likewise.\n        * gnu/gcj/runtime/MethodRef.java: Removed.\n        * gnu/gcj/runtime/StackTrace.java, gnu/gcj/runtime/natNameFinder.cc,\n        gnu/gcj/runtime/natStackTrace.cc: Really removed.\n        * java/lang/natRuntime.cc (_load): Remove unsed variable.\n        * Makefile.am (ordinary_java_source_files): Remove MethodRef.java.\n        * Makefile.in: Rebuilt.\n\nFrom-SVN: r96288", "tree": {"sha": "326f8dfb57ca2a9f8fd10534252c07396695e0c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/326f8dfb57ca2a9f8fd10534252c07396695e0c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0cbd601303809da24e1ea49b711193cba4815be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0cbd601303809da24e1ea49b711193cba4815be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0cbd601303809da24e1ea49b711193cba4815be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0cbd601303809da24e1ea49b711193cba4815be/comments", "author": null, "committer": null, "parents": [{"sha": "694d73e1659c7db09d415c8ba0ebeb441c0782a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/694d73e1659c7db09d415c8ba0ebeb441c0782a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/694d73e1659c7db09d415c8ba0ebeb441c0782a8"}], "stats": {"total": 618, "additions": 14, "deletions": 604}, "files": [{"sha": "76c7a43ce2aa60bf81b48341202315d880c8956e", "filename": "libjava/ChangeLog", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0cbd601303809da24e1ea49b711193cba4815be/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0cbd601303809da24e1ea49b711193cba4815be/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=c0cbd601303809da24e1ea49b711193cba4815be", "patch": "@@ -1,3 +1,14 @@\n+2005-03-10  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\t* exception.cc: Remove stray MethodRef.h include.\n+\t* java/lang/natClass.cc: Likewise.\n+\t* gnu/gcj/runtime/MethodRef.java: Removed.\n+\t* gnu/gcj/runtime/StackTrace.java, gnu/gcj/runtime/natNameFinder.cc,\n+\tgnu/gcj/runtime/natStackTrace.cc: Really removed.\n+\t* java/lang/natRuntime.cc (_load): Remove unsed variable.\n+\t* Makefile.am (ordinary_java_source_files): Remove MethodRef.java.\n+\t* Makefile.in: Rebuilt.\n+\n 2005-03-10  Tom Tromey  <tromey@redhat.com>\n \n \t* Makefile.in: Rebuilt.\n@@ -12,7 +23,7 @@\n \n \tNew Stack Trace infrastructure.\n \t* Makefile.am (libgcj0_convenience_la_SOURCES): Add stacktrace.cc.\n-\t(gnu/gcj/runtime/StackTrace.lo): Removed.\n+\t(gnu/gcj/runtime/StackTrace.java): Removed.\n \t(ordinary_java_source_files): Remove obsolete files.\n \t(nat_source_files): Remove obsolete files. Add natVMThrowable.cc.\n \t* configure.host (fallback_backtrace_h): Set backtrace header"}, {"sha": "920b05bd9af2eb8234b9c0d85f78293cfa986aa6", "filename": "libjava/Makefile.am", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0cbd601303809da24e1ea49b711193cba4815be/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0cbd601303809da24e1ea49b711193cba4815be/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=c0cbd601303809da24e1ea49b711193cba4815be", "patch": "@@ -2903,7 +2903,6 @@ gnu/gcj/io/SimpleSHSStream.java\t\\\n gnu/gcj/runtime/FileDeleter.java \\\n gnu/gcj/runtime/FinalizerThread.java \\\n gnu/gcj/runtime/JNIWeakRef.java \\\n-gnu/gcj/runtime/MethodRef.java \\\n gnu/gcj/runtime/NameFinder.java \\\n gnu/gcj/runtime/PersistentByteMap.java \\\n gnu/gcj/runtime/SharedLibHelper.java \\"}, {"sha": "4be41130c88a2ce71a4c38f56b817696b5d94cd6", "filename": "libjava/Makefile.in", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0cbd601303809da24e1ea49b711193cba4815be/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0cbd601303809da24e1ea49b711193cba4815be/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=c0cbd601303809da24e1ea49b711193cba4815be", "patch": "@@ -554,7 +554,7 @@ am__libgcj0_convenience_la_SOURCES_DIST = prims.cc jni.cc exception.cc \\\n \tgnu/gcj/io/MimeTypes.java gnu/gcj/io/SimpleSHSStream.java \\\n \tgnu/gcj/runtime/FileDeleter.java \\\n \tgnu/gcj/runtime/FinalizerThread.java \\\n-\tgnu/gcj/runtime/JNIWeakRef.java gnu/gcj/runtime/MethodRef.java \\\n+\tgnu/gcj/runtime/JNIWeakRef.java \\\n \tgnu/gcj/runtime/NameFinder.java \\\n \tgnu/gcj/runtime/PersistentByteMap.java \\\n \tgnu/gcj/runtime/SharedLibHelper.java \\\n@@ -3992,8 +3992,7 @@ am__objects_15 = $(am__objects_9) gnu/classpath/ServiceFactory.lo \\\n \tgnu/gcj/io/DefaultMimeTypes.lo gnu/gcj/io/MimeTypes.lo \\\n \tgnu/gcj/io/SimpleSHSStream.lo gnu/gcj/runtime/FileDeleter.lo \\\n \tgnu/gcj/runtime/FinalizerThread.lo \\\n-\tgnu/gcj/runtime/JNIWeakRef.lo gnu/gcj/runtime/MethodRef.lo \\\n-\tgnu/gcj/runtime/NameFinder.lo \\\n+\tgnu/gcj/runtime/JNIWeakRef.lo gnu/gcj/runtime/NameFinder.lo \\\n \tgnu/gcj/runtime/PersistentByteMap.lo \\\n \tgnu/gcj/runtime/SharedLibHelper.lo \\\n \tgnu/gcj/runtime/SharedLibLoader.lo \\\n@@ -7302,7 +7301,6 @@ gnu/gcj/io/SimpleSHSStream.java\t\\\n gnu/gcj/runtime/FileDeleter.java \\\n gnu/gcj/runtime/FinalizerThread.java \\\n gnu/gcj/runtime/JNIWeakRef.java \\\n-gnu/gcj/runtime/MethodRef.java \\\n gnu/gcj/runtime/NameFinder.java \\\n gnu/gcj/runtime/PersistentByteMap.java \\\n gnu/gcj/runtime/SharedLibHelper.java \\\n@@ -9604,8 +9602,6 @@ gnu/gcj/runtime/FinalizerThread.lo: gnu/gcj/runtime/$(am__dirstamp) \\\n \tgnu/gcj/runtime/$(DEPDIR)/$(am__dirstamp)\n gnu/gcj/runtime/JNIWeakRef.lo: gnu/gcj/runtime/$(am__dirstamp) \\\n \tgnu/gcj/runtime/$(DEPDIR)/$(am__dirstamp)\n-gnu/gcj/runtime/MethodRef.lo: gnu/gcj/runtime/$(am__dirstamp) \\\n-\tgnu/gcj/runtime/$(DEPDIR)/$(am__dirstamp)\n gnu/gcj/runtime/NameFinder.lo: gnu/gcj/runtime/$(am__dirstamp) \\\n \tgnu/gcj/runtime/$(DEPDIR)/$(am__dirstamp)\n gnu/gcj/runtime/PersistentByteMap.lo: gnu/gcj/runtime/$(am__dirstamp) \\\n@@ -16353,8 +16349,6 @@ mostlyclean-compile:\n \t-rm -f gnu/gcj/runtime/FinalizerThread.lo\n \t-rm -f gnu/gcj/runtime/JNIWeakRef.$(OBJEXT)\n \t-rm -f gnu/gcj/runtime/JNIWeakRef.lo\n-\t-rm -f gnu/gcj/runtime/MethodRef.$(OBJEXT)\n-\t-rm -f gnu/gcj/runtime/MethodRef.lo\n \t-rm -f gnu/gcj/runtime/NameFinder.$(OBJEXT)\n \t-rm -f gnu/gcj/runtime/NameFinder.lo\n \t-rm -f gnu/gcj/runtime/PersistentByteMap.$(OBJEXT)\n@@ -21979,7 +21973,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/FileDeleter.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/FinalizerThread.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/JNIWeakRef.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/MethodRef.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/NameFinder.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/PersistentByteMap.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/SharedLibHelper.Plo@am__quote@"}, {"sha": "367df3618b90f62a119405259add71df898e3d13", "filename": "libjava/exception.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0cbd601303809da24e1ea49b711193cba4815be/libjava%2Fexception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0cbd601303809da24e1ea49b711193cba4815be/libjava%2Fexception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fexception.cc?ref=c0cbd601303809da24e1ea49b711193cba4815be", "patch": "@@ -15,7 +15,6 @@ details.  */\n \n #include <java/lang/Class.h>\n #include <java/lang/NullPointerException.h>\n-#include <gnu/gcj/runtime/MethodRef.h> \n #include <gnu/gcj/RawData.h> \n #include <gcj/cni.h>\n #include <jvm.h>"}, {"sha": "f15746164a6b5568571e9b06afec0e205e95a9d7", "filename": "libjava/gnu/gcj/runtime/MethodRef.java", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/694d73e1659c7db09d415c8ba0ebeb441c0782a8/libjava%2Fgnu%2Fgcj%2Fruntime%2FMethodRef.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/694d73e1659c7db09d415c8ba0ebeb441c0782a8/libjava%2Fgnu%2Fgcj%2Fruntime%2FMethodRef.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FMethodRef.java?ref=694d73e1659c7db09d415c8ba0ebeb441c0782a8", "patch": "@@ -1,25 +0,0 @@\n-// gnu.gcj.runtime.MethodRef -- used by StackTrace.\n-\n-/* Copyright (C) 2002  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-package gnu.gcj.runtime;\n-\n-import gnu.gcj.RawData;\n-\n-class MethodRef\n-{\n-  MethodRef(RawData /* Actually _Jv_Method */ m, Class k)\n-  {\n-    klass = k;\n-    method = m;\n-  }\n-\n-  public RawData method; // Actually a raw pointer to _Jv_Method\n-  public Class klass;\n-}"}, {"sha": "c9f5a1a26e80439a94cf2900d9fe3c166290cb04", "filename": "libjava/gnu/gcj/runtime/StackTrace.java", "status": "removed", "additions": 0, "deletions": 167, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/694d73e1659c7db09d415c8ba0ebeb441c0782a8/libjava%2Fgnu%2Fgcj%2Fruntime%2FStackTrace.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/694d73e1659c7db09d415c8ba0ebeb441c0782a8/libjava%2Fgnu%2Fgcj%2Fruntime%2FStackTrace.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FStackTrace.java?ref=694d73e1659c7db09d415c8ba0ebeb441c0782a8", "patch": "@@ -1,167 +0,0 @@\n-/* gnu.gcj.runtime.StackTrace -- VM support methods for walking the\n-   stack.\n-   Copyright (C) 1998, 1999, 2002 Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n-02111-1307 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-package gnu.gcj.runtime;\n-\n-import gnu.gcj.RawData;\n-import java.util.TreeMap;\n-import java.util.IdentityHashMap;\n-import java.util.SortedMap;\n-import gnu.gcj.runtime.NameFinder;\n-import java.util.NoSuchElementException;\n-\n-/**\n- * VM dependent state and support methods for walking the stack.\n- * <p>\n- * This is the version used by libgcj (http://gcc.gnu.org/java/).\n- *\n- * @author Mark Wielaard (mark@klomp.org)\n- * @author Andrew Haley (aph@redhat.com)\n- */\n-public final class StackTrace\n-{\n-  /**\n-   * Fill in the stack trace with the top n frames on current\n-   * execution stack.  Can return null if the VM does not support\n-   * capturing the VM execution state.\n-   *\n-   * @see Throwable#fillInStackTrace()\n-   */\n-  public StackTrace(int n)\n-  {\n-    fillInStackTrace(n, 1);\n-  }\n-\n-  /**\n-   * Fill in the stack trace with state of the entire execution stack,\n-   * starting from frame <code>offset</code>.  Can return null if the\n-   * VM does not support capturing the VM execution state.\n-   *\n-   * This can be very expensive.  If you only want part of the stack,\n-   * see <code>Throwable.fillInStackTrace(int)</code>\n-   *\n-   * @see Throwable#fillInStackTrace()\n-   */\n-  public StackTrace()\n-  {\n-    int n = 64;\n-    \n-    do\n-      {\n-\tn *= 4;\n-\tfillInStackTrace(n, 1);\n-      }\n-    while (len >= n);\n-  }\n-\n-  /**\n-   * Return the class containing the execution point represented by\n-   * the Nth frame down the stack.  The zeroth frame represents the\n-   * top of the stack, which is the method that called classAt().\n-   *\n-   * If the Nth frame down the stack was not create by a method\n-   * invocation, return null.\n-   *\n-   * It is not necessary to call <code>fillInStackTrace()</code> with\n-   * a size greater than N before calling this method; if the current\n-   * stack trace is insufficiently large, it will be expanded as\n-   * required.  This requires some caution if\n-   * <code>fillInStackTrace()</code> is called from a different\n-   * invocation to the one that calls <code>classAt()</code>.\n-   * classAt() will not call <code>fillInStackTrace()</code> unless N\n-   * is greater than the current length.\n-   *\n-   */\n-  public native Class classAt(int n);\n-\n-  /**\n-   * Return the name of the method containing the execution point\n-   * represented by the Nth frame down the stack.  The zeroth frame\n-   * represents the top of the stack, which is the method that called\n-   * classAt().\n-   *\n-   * If the Nth frame down the stack was not create by a method\n-   * invocation, return null.\n-   *\n-   * It is not necessary to call <code>fillInStackTrace()</code> with\n-   * a size greater than N before calling this method; if the current\n-   * stack trace is insufficiently large, it will be expanded as\n-   * required.  This requires some caution if\n-   * <code>fillInStackTrace()</code> is called from a different\n-   * invocation to the one that calls <code>classAt()</code>.\n-   * classAt() will not call <code>fillInStackTrace()</code> unless N\n-   * is greater than the current length.\n-   *\n-   */\n-  public native String methodAt(int n);\n-\n-  /**\n-   * Return the length of this stack trace.\n-   *\n-   */\n-  public int length ()\n-  {\n-    return len;\n-  }\n-\n-  public static native Class getClass(RawData ip);\n-\n-  private static native void update();\n-  private static MethodRef methodAtAddress(RawData addr)\n-  {\n-    update();\n-    synchronized (map)\n-      {\n-\treturn (MethodRef) map.get (addr);\n-      }\n-  }\n-\n-  gnu.gcj.RawData stackTraceAddrs()\n-  {\n-    return addrs;\n-  }\n-  \n-  private native void fillInStackTrace(int n, int offset);\n-  protected native void finalize();\n-\n-  private static native MethodRef getCompiledMethodRef(RawData addr);\n-  private static IdentityHashMap map = new IdentityHashMap();\n-\n-  private gnu.gcj.RawData addrs;\n-  private int len;\n-}"}, {"sha": "d688884ca366bec9048f98cc5018175042aa59e0", "filename": "libjava/gnu/gcj/runtime/natNameFinder.cc", "status": "removed", "additions": 0, "deletions": 157, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/694d73e1659c7db09d415c8ba0ebeb441c0782a8/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatNameFinder.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/694d73e1659c7db09d415c8ba0ebeb441c0782a8/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatNameFinder.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatNameFinder.cc?ref=694d73e1659c7db09d415c8ba0ebeb441c0782a8", "patch": "@@ -1,157 +0,0 @@\n-// natNameFinder.cc - native helper methods for NameFinder.java\n-\n-/* Copyright (C) 2002, 2003, 2004  Free Software Foundation, Inc\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-/**\n- * @author Mark Wielaard (mark@klomp.org)\n- * Based on the old name-finder.cc by Andrew Haley <aph@cygnus.com>.\n- */\n-\n-#include <config.h>\n-\n-#include <string.h>\n-\n-#include <gcj/cni.h>\n-#include <jvm.h>\n-#include <java/lang/String.h>\n-#include <java/lang/StackTraceElement.h>\n-#include <java/lang/StringBuffer.h>\n-#include <java-interp.h>\n-\n-#include <gnu/gcj/runtime/NameFinder.h>\n-\n-#ifdef HAVE_DLFCN_H\n-#include <dlfcn.h>\n-#endif\n-\n-// On some systems, a prefix is attached to a method name before\n-// it is exported as a label. The GCC preprocessor predefines \n-// this prefix as the macro __USER_LABEL_PREFIX__ which expands to\n-// a string (not string constant) representing the prefix, if any.\n-#undef LABEL_PREFIX\n-#ifdef __USER_LABEL_PREFIX__\n-\n-#define USER_LABEL_PREFIX_STRING_0(s) #s\n-#define USER_LABEL_PREFIX_STRING(s) USER_LABEL_PREFIX_STRING_0(s)\n-\n-#define LABEL_PREFIX USER_LABEL_PREFIX_STRING(__USER_LABEL_PREFIX__)\n-\n-#else /* __USER_LABEL_PREFIX__ */\n-\n-#define LABEL_PREFIX \"\"\n-\n-#endif /* ! __USER_LABEL_PREFIX__ */\n-\n-java::lang::StackTraceElement*\n-gnu::gcj::runtime::NameFinder::newElement (java::lang::String* fileName,\n-                                           jint lineNumber,\n-                                           java::lang::String* className,\n-                                           java::lang::String* methName,\n-                                           jboolean isNative)\n-{\n-  return new java::lang::StackTraceElement( fileName, lineNumber,\n-                                            className, methName, isNative);\n-}\n-                                          \n-java::lang::String*\n-gnu::gcj::runtime::NameFinder::getExternalLabel (java::lang::String* name)\n-{\n-  jsize nameLen = JvGetStringUTFLength (name);\n-  jsize pfxLen = strlen (LABEL_PREFIX);\n-  char *newName = (char *) JvMalloc (pfxLen + nameLen + 1);\n-  *(newName + 0) = '\\0';\n-  strcpy (newName, LABEL_PREFIX);\n-  JvGetStringUTFRegion (name, 0, name->length(), newName + pfxLen);\n-  *(newName + pfxLen + nameLen) = '\\0';\n-  return JvNewStringLatin1 (newName);\n-}\n-\n-java::lang::String*\n-gnu::gcj::runtime::NameFinder::getExecutable (void)\n-{\n-  return JvNewStringLatin1 (_Jv_ThisExecutable ());\n-}\n-\n-java::lang::String*\n-gnu::gcj::runtime::NameFinder::getAddrAsString(RawData* addrs, jint n)\n-{\n-  _Jv_frame_info *p = (_Jv_frame_info *) addrs;\n-  typedef unsigned word_t __attribute ((mode (word)));\n-  word_t w = (word_t) p[n].addr;\n-  int digits = sizeof (void *) * 2;\n-  char hex[digits+5];\n-\n-  strcpy (hex, \"0x\");\n-  for (int i = digits - 1; i >= 0; i--)\n-    {\n-      int digit = w % 16;\n-\n-      w /= 16;\n-      hex[i+2] = digit > 9 ? 'a' + digit - 10 : '0' + digit;\n-    }\n-  hex [digits+2] = 0;\n-\n-  return JvNewStringLatin1(hex);\n-}\n-\n-java::lang::StackTraceElement*\n-gnu::gcj::runtime::NameFinder::dladdrLookup(RawData* addrs, jint n)\n-{\n-#if defined (HAVE_DLFCN_H) && defined (HAVE_DLADDR)\n-  extern char **_Jv_argv;\n-  char name[1024];\n-  char file_name[1024];\n-  _Jv_frame_info *stack = (_Jv_frame_info *) addrs;\n-  void* p = stack[n].addr;\n-  Dl_info dl_info;\n-   \n-  if (dladdr (p, &dl_info))\n-    {\n-      if (dl_info.dli_fname)\n-        strncpy (file_name, dl_info.dli_fname, sizeof file_name);\n-      if (dl_info.dli_sname)\n-        strncpy (name, dl_info.dli_sname, sizeof name);\n-     \n-     /* Don't trust dladdr() if the address is from the main program. */\n-     if (dl_info.dli_fname != NULL\n-         && dl_info.dli_sname != NULL\n-         && (_Jv_argv == NULL || strcmp (file_name, _Jv_argv[0]) != 0))\n-       return createStackTraceElement (JvNewStringLatin1 (name),\n-\t\t\t\t       JvNewStringLatin1 (file_name));\n-    }\n-#endif\n-  return NULL;\n-}\n-\n-java::lang::StackTraceElement *\n-gnu::gcj::runtime::NameFinder::lookupInterp(RawData* addrs, jint n)\n-{\n-#ifdef INTERPRETER\n-  _Jv_frame_info *stack = (_Jv_frame_info *) addrs;\n-  if (stack[n].interp == NULL)\n-    return NULL;\n-\n-  _Jv_InterpMethod *meth\n-    = reinterpret_cast<_Jv_InterpMethod *> (stack[n].interp);\n-  java::lang::StringBuffer *sb = new java::lang::StringBuffer();\n-  sb->append(_Jv_NewStringUtf8Const(meth->self->name));\n-  sb->append(_Jv_NewStringUtf8Const(meth->self->signature));\n-  // FIXME: source file name and line number can be found from\n-  // bytecode debug information.  But currently we don't keep that\n-  // around.\n-  // FIXME: is using the defining class correct here?\n-  java::lang::String *className = meth->defining_class->getName();\n-  java::lang::String *methodName\n-\t  = demangleInterpreterMethod(sb->toString(), className);\n-  return new java::lang::StackTraceElement(NULL, -1,\n-\t\t\t\t\t   className, methodName, false);\n-#else // INTERPRETER\n-  return NULL;\n-#endif // INTERPRETER\n-}"}, {"sha": "d9f3355c04600c89255c1e93ad2e3a1fd10c320c", "filename": "libjava/gnu/gcj/runtime/natStackTrace.cc", "status": "removed", "additions": 0, "deletions": 241, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/694d73e1659c7db09d415c8ba0ebeb441c0782a8/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatStackTrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/694d73e1659c7db09d415c8ba0ebeb441c0782a8/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatStackTrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatStackTrace.cc?ref=694d73e1659c7db09d415c8ba0ebeb441c0782a8", "patch": "@@ -1,241 +0,0 @@\n-// natStackTrace.cc - native helper methods for Throwable\n-\n-/* Copyright (C) 2000, 2002, 2003  Free Software Foundation, Inc\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-/**\n- * @author Andrew Haley <aph@cygnus.com>\n- * @author Mark Wielaard <mark@klomp.org>\n- *\n- * Native helper methods for VM specific Throwable support.\n- */\n-\n-#include <config.h>\n-#include <platform.h>\n-\n-#include <string.h>\n-\n-#include <jvm.h>\n-#include <gcj/cni.h>\n-#include <gnu/gcj/RawData.h>\n-#include <java/lang/Object.h>\n-#include <java-threads.h>\n-#include <gnu/gcj/runtime/MethodRef.h>\n-#include <gnu/gcj/runtime/StackTrace.h>\n-#include <java/lang/Thread.h>\n-#include <java-interp.h>\n-#include <java/util/IdentityHashMap.h>\n-#include <java/lang/ArrayIndexOutOfBoundsException.h>\n-\n-#include <sys/types.h>\n-\n-#include <stdlib.h>\n-\n-#include <unistd.h>\n-\n-#ifdef HAVE_EXECINFO_H\n-#include <execinfo.h>\n-#endif\n-\n-#include <unwind.h>\n-\n-\n-#ifdef INTERPRETER\n-extern \"C\" void *_Unwind_FindEnclosingFunction (void *pc)\n-  __attribute__((pure));\n-#endif // INTERPRETER\n-\n-// Fill in this stack trace with MAXLEN elements starting at offset.\n-void\n-gnu::gcj::runtime::StackTrace::fillInStackTrace (jint maxlen, jint offset)\n-{\n-#ifdef HAVE_BACKTRACE\n-  offset += 1;\n-  void *_p[maxlen + offset];\n-  len = backtrace (_p, maxlen + offset) - offset;\n-  void **p = _p + offset;\n-  _Jv_frame_info *frame;\n-  if (len > 0)\n-    {\n-#ifdef INTERPRETER\n-      extern void *const _Jv_StartOfInterpreter;\n-      extern void * _Jv_EndOfInterpreter;\n-\n-      java::lang::Thread *thread = java::lang::Thread::currentThread();\n-      _Jv_MethodChain *interp_frame\n-\t= (thread ? reinterpret_cast<_Jv_MethodChain *> (thread->interp_frame)\n-\t   : NULL);\n-#endif // INTERPRETER\n-\n-      frame = (_Jv_frame_info *) _Jv_Malloc (len * sizeof (_Jv_frame_info));\n-      for (int n = 0; n < len; n++)\n-\t{\n-\t  void *pc = p[n];\n-\t  frame[n].addr = pc;\n-\n-#ifdef INTERPRETER\n-\t  frame[n].interp = 0;\n-\n-\t  // If _Jv_StartOfInterpreter is NULL either we've never\n-\t  // entered the intepreter or _Unwind_FindEnclosingFunction\n-\t  // is broken.\n-\t  if (__builtin_expect (_Jv_StartOfInterpreter != NULL, false))\n-\t    {\n-\t      // _Jv_StartOfInterpreter marks the very first\n-\t      // instruction in the interpreter, but\n-\t      // _Jv_EndOfInterpreter is an upper bound.  If PC is\n-\t      // less than _Jv_EndOfInterpreter it might be in the\n-\t      // interpreter: we call _Unwind_FindEnclosingFunction to\n-\t      // find out.\n-\t      if (pc >= _Jv_StartOfInterpreter\n-\t\t  && (pc < _Jv_EndOfInterpreter\n-\t\t      || _Jv_EndOfInterpreter == NULL))\n-\t\t{\n-\t\t  if (_Unwind_FindEnclosingFunction (pc) \n-\t\t      == _Jv_StartOfInterpreter)\n-\t\t    {\n-\t\t      frame[n].interp = (void *) interp_frame->self;\n-\t\t      interp_frame = interp_frame->next;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      // We've found an address that we know is not within\n-\t\t      // the interpreter.  We use that to refine our upper\n-\t\t      // bound on where the interpreter ends.\n-\t\t      _Jv_EndOfInterpreter = pc;\n-\t\t    }\n-\t\t}\n-\t    }\n-#endif // INTERPRETER\n-\n-\t}\n-    }\n-  else\n-    frame = NULL;\n-\n-  addrs = reinterpret_cast<gnu::gcj::RawData *> (frame);\n-#else // HAVE_BACKTRACE\n-  (void)maxlen;\n-  (void)offset;\n-#endif // HAVE_BACKTRACE\n-}\n-\n-/* Obtain the next power-of-2 of some integer.  */\n-static inline jint\n-nextpowerof2 (jint n)\n-{\n-  n |= (n >> 1);\n-  n |= (n >> 2);\n-  n |= (n >> 4);\n-  n |= (n >> 8);\n-  n |= (n >> 16);\n-  return n+1;\n-}\n-\n-#define GET_FRAME(N)\t\t\t\t\t\t\\\n-({\t\t\t\t\t\t\t\t\\\n-  if ((N) >= len)\t\t\t\t\t\t\\\n-    fillInStackTrace (nextpowerof2 (N), 1);\t\t\t\\\n-  if ((N) < 0 || (N) >= len)\t\t\t\t\t\\\n-    throw new ::java::lang::ArrayIndexOutOfBoundsException ();\t\\\n-\t\t\t\t\t\t\t\t\\\n-  _Jv_frame_info *frame = (_Jv_frame_info *)addrs;\t\t\\\n-  &frame[N];\t\t\t\t\t\t\t\\\n-})\n-\n-gnu::gcj::runtime::MethodRef *\n-gnu::gcj::runtime::StackTrace::getCompiledMethodRef (gnu::gcj::RawData *addr)\n-{\n-  void *p = _Unwind_FindEnclosingFunction (addr);\n-  return gnu::gcj::runtime::StackTrace\n-    ::methodAtAddress ((gnu::gcj::RawData *)p);\n-}\n-\n-java::lang::Class *\n-gnu::gcj::runtime::StackTrace::getClass (gnu::gcj::RawData *p)\n-{\n-  gnu::gcj::runtime::MethodRef *ref = getCompiledMethodRef (p);\n-  if (ref)\n-    return ref->klass;\n-  else\n-    return NULL;\n-}\n-\n-java::lang::Class *\n-gnu::gcj::runtime::StackTrace::classAt (jint n)\n-{\n-  _Jv_frame_info *frame = GET_FRAME (n);\n-\n-#ifdef INTERPRETER\n-  if (frame->interp)\n-    {\n-      _Jv_InterpMethod *meth\n-\t= reinterpret_cast<_Jv_InterpMethod *> (frame->interp);\n-      return meth->defining_class;\n-    }\n-#endif // INTERPRETER\n-  \n-  return getClass ((gnu::gcj::RawData *)frame->addr);\n-}\n-\n-java::lang::String*\n-gnu::gcj::runtime::StackTrace::methodAt (jint n)\n-{\n-  _Jv_frame_info *frame = GET_FRAME (n);\n-  _Jv_Method *meth = NULL;\n-\n-#ifdef INTERPRETER\n-  if (frame->interp)\n-    {\n-      meth\n-\t= reinterpret_cast<_Jv_InterpMethod *> (frame->interp)\n-\t->get_method();\n-    }\n-#endif // INTERPRETER\n-  \n-  if (! meth)\n-    {\n-      gnu::gcj::runtime::MethodRef *ref\n-\t= getCompiledMethodRef ((gnu::gcj::RawData *)frame->addr);\n-      if (ref)\n-\tmeth = (_Jv_Method *)ref->method;\n-    }\n-\n-  return meth \n-    ? _Jv_NewStringUtf8Const (meth->name)\n-    : NULL ;\n-}\n-\n-void\n-gnu::gcj::runtime::StackTrace::update(void)\n-{\n-  jclass klass;\n-\n-  while ((klass = _Jv_PopClass ()))\n-    {\n-      for (int i=0; i<klass->method_count; i++)\n-\t{\n-\t  JvSynchronize sync (map);\n-\t  _Jv_Method *meth = &(klass->methods[i]);\n-\t  if (meth->ncode) // i.e. if p is not abstract\n-\t    {\n-\t      gnu::gcj::runtime::MethodRef *ref\n-\t\t= new gnu::gcj::runtime::MethodRef \n-\t\t((gnu::gcj::RawData *)meth, klass);\n-\t      map->put ((java::lang::Object*)(meth->ncode), ref);\n-\t    }\n-\t}\n-    }\n-}\n-\n-void\n-gnu::gcj::runtime::StackTrace::finalize(void)\n-{\n-  if (addrs != NULL)\n-    _Jv_Free (addrs);\n-}"}, {"sha": "f48a6fd77ed160f20a62b4798e6b7ab0008c0a34", "filename": "libjava/java/lang/natClass.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0cbd601303809da24e1ea49b711193cba4815be/libjava%2Fjava%2Flang%2FnatClass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0cbd601303809da24e1ea49b711193cba4815be/libjava%2Fjava%2Flang%2FnatClass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClass.cc?ref=c0cbd601303809da24e1ea49b711193cba4815be", "patch": "@@ -54,7 +54,6 @@ details.  */\n #include <java/lang/StringBuffer.h>\n #include <java/lang/VMClassLoader.h>\n #include <gcj/method.h>\n-#include <gnu/gcj/runtime/MethodRef.h>\n #include <gnu/gcj/RawData.h>\n #include <java/lang/VerifyError.h>\n "}, {"sha": "f8e05ada84c656a7648a4bc7b080dd81ba08eb78", "filename": "libjava/java/lang/natRuntime.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0cbd601303809da24e1ea49b711193cba4815be/libjava%2Fjava%2Flang%2FnatRuntime.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0cbd601303809da24e1ea49b711193cba4815be/libjava%2Fjava%2Flang%2FnatRuntime.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatRuntime.cc?ref=c0cbd601303809da24e1ea49b711193cba4815be", "patch": "@@ -162,7 +162,6 @@ java::lang::Runtime::_load (jstring path, jboolean do_search)\n \n   if (do_search)\n     {\n-      ClassLoader *sys = ClassLoader::systemClassLoader;\n       ClassLoader *look = _Jv_StackTrace::GetFirstNonSystemClassLoader ();\n \n       if (look != NULL)"}]}