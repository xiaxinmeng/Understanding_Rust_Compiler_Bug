{"sha": "e6d369bbdb4eb5f03eec233ef9905013a735fd71", "node_id": "C_kwDOANBUbNoAKGU2ZDM2OWJiZGI0ZWI1ZjAzZWVjMjMzZWY5OTA1MDEzYTczNWZkNzE", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-06-09T15:14:31Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-06-10T19:32:22Z"}, "message": "c++: Add a late-writing step for modules\n\nTo add a module initializer optimization, we need to defer finishing writing\nout the module file until the end of determining the dynamic initializers.\nThis is achieved by passing some saved-state from the main module writing\nto a new function that completes it.\n\nThis patch merely adds the skeleton of that state and move things around,\nallowing the finalization of the ELF file to be postponed.  None of the\ncontents writing is moved, or the init optimization added.\n\n\tgcc/cp/\n\t* cp-tree.h (fini_modules): Add some parameters.\n\t(finish_module_processing): Return an opaque pointer.\n\t* decl2.cc (c_parse_final_cleanups): Propagate a cookie from\n\tfinish_module_processing to fini_modules.\n\t* module.cc (struct module_processing_cookie): New.\n\t(finish_module_processing): Return a heap-allocated cookie.\n\t(late_finish_module): New.  Finish out the module writing.\n\t(fini_modules): Adjust.", "tree": {"sha": "ae76fb667433af3f913283f40d041fe763026afe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae76fb667433af3f913283f40d041fe763026afe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6d369bbdb4eb5f03eec233ef9905013a735fd71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6d369bbdb4eb5f03eec233ef9905013a735fd71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6d369bbdb4eb5f03eec233ef9905013a735fd71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6d369bbdb4eb5f03eec233ef9905013a735fd71/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1eff4872d2e57c481f7218d25eecbfba647504e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eff4872d2e57c481f7218d25eecbfba647504e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1eff4872d2e57c481f7218d25eecbfba647504e1"}], "stats": {"total": 153, "additions": 98, "deletions": 55}, "files": [{"sha": "60d7b20159538362dd305992e2d4390a66b17dff", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d369bbdb4eb5f03eec233ef9905013a735fd71/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d369bbdb4eb5f03eec233ef9905013a735fd71/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e6d369bbdb4eb5f03eec233ef9905013a735fd71", "patch": "@@ -7209,9 +7209,9 @@ extern void import_module (module_state *, location_t, bool export_p,\n extern void declare_module (module_state *, location_t, bool export_p,\n \t\t\t    tree attr, cpp_reader *);\n extern void init_modules (cpp_reader *);\n-extern void fini_modules ();\n+extern void fini_modules (cpp_reader *, void *cookie);\n extern void maybe_check_all_macros (cpp_reader *);\n-extern void finish_module_processing (cpp_reader *);\n+extern void *finish_module_processing (cpp_reader *);\n extern char const *module_name (unsigned, bool header_ok);\n extern bitmap get_import_bitmap ();\n extern bitmap visible_instantiation_path (bitmap *);"}, {"sha": "cc0b41324b3a1b5027f9dcbbb81bd57e2155306f", "filename": "gcc/cp/decl2.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d369bbdb4eb5f03eec233ef9905013a735fd71/gcc%2Fcp%2Fdecl2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d369bbdb4eb5f03eec233ef9905013a735fd71/gcc%2Fcp%2Fdecl2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.cc?ref=e6d369bbdb4eb5f03eec233ef9905013a735fd71", "patch": "@@ -5154,7 +5154,7 @@ c_parse_final_cleanups (void)\n \treconsider = true;\n     }\n \n-  finish_module_processing (parse_in);\n+  void *module_cookie = finish_module_processing (parse_in);\n \n   lower_var_init ();\n \n@@ -5238,7 +5238,7 @@ c_parse_final_cleanups (void)\n       }\n   pop_lang_context ();\n \n-  fini_modules ();\n+  fini_modules (parse_in, module_cookie);\n \n   /* Generate any missing aliases.  */\n   maybe_apply_pending_pragma_weaks ();"}, {"sha": "51d774ae608c9d5f3b8142ff65d6b7da2b7e86f5", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 94, "deletions": 51, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d369bbdb4eb5f03eec233ef9905013a735fd71/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d369bbdb4eb5f03eec233ef9905013a735fd71/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=e6d369bbdb4eb5f03eec233ef9905013a735fd71", "patch": "@@ -19854,11 +19854,32 @@ maybe_check_all_macros (cpp_reader *reader)\n   dump.pop (n);\n }\n \n+// State propagated from finish_module_processing to fini_modules\n+struct module_processing_cookie\n+{\n+  elf_out out;\n+  char *cmi_name;\n+  char *tmp_name;\n+  bool began;\n+\n+  module_processing_cookie (char *cmi, char *tmp, int fd, int e)\n+    : out (fd, e), cmi_name (cmi), tmp_name (tmp), began (false)\n+  {\n+  }\n+  ~module_processing_cookie ()\n+  {\n+    XDELETEVEC (tmp_name);\n+    XDELETEVEC (cmi_name);\n+  }\n+};\n+\n /* Write the CMI, if we're a module interface.  */\n \n-void\n+void *\n finish_module_processing (cpp_reader *reader)\n {\n+  module_processing_cookie *cookie = nullptr;\n+\n   if (header_module_p ())\n     module_kind &= ~MK_EXPORTING;\n \n@@ -19870,7 +19891,7 @@ finish_module_processing (cpp_reader *reader)\n   else if (!flag_syntax_only)\n     {\n       int fd = -1;\n-      int e = ENOENT;\n+      int e = -1;\n \n       timevar_start (TV_MODULE_EXPORT);\n \n@@ -19879,7 +19900,7 @@ finish_module_processing (cpp_reader *reader)\n       linemap_add (line_table, LC_ENTER, false, \"\", 0);\n \n       /* We write to a tmpname, and then atomically rename.  */\n-      const char *path = NULL;\n+      char *cmi_name = NULL;\n       char *tmp_name = NULL;\n       module_state *state = (*modules)[0];\n \n@@ -19888,9 +19909,9 @@ finish_module_processing (cpp_reader *reader)\n       if (state->filename)\n \t{\n \t  size_t len = 0;\n-\t  path = maybe_add_cmi_prefix (state->filename, &len);\n+\t  cmi_name = xstrdup (maybe_add_cmi_prefix (state->filename, &len));\n \t  tmp_name = XNEWVEC (char, len + 3);\n-\t  memcpy (tmp_name, path, len);\n+\t  memcpy (tmp_name, cmi_name, len);\n \t  strcpy (&tmp_name[len], \"~\");\n \n \t  if (!errorcount)\n@@ -19905,57 +19926,23 @@ finish_module_processing (cpp_reader *reader)\n \t\tcreate_dirs (tmp_name);\n \t      }\n \t  if (note_module_cmi_yes || state->inform_cmi_p)\n-\t    inform (state->loc, \"writing CMI %qs\", path);\n-\t  dump () && dump (\"CMI is %s\", path);\n+\t    inform (state->loc, \"writing CMI %qs\", cmi_name);\n+\t  dump () && dump (\"CMI is %s\", cmi_name);\n \t}\n \n+      cookie = new module_processing_cookie (cmi_name, tmp_name, fd, e);\n+\n       if (errorcount)\n \twarning_at (state->loc, 0, \"not writing module %qs due to errors\",\n \t\t    state->get_flatname ());\n-      else\n+      else if (cookie->out.begin ())\n \t{\n-\t  elf_out to (fd, e);\n-\t  if (to.begin ())\n-\t    {\n-\t      auto loc = input_location;\n-\t      /* So crashes finger-point the module decl.  */\n-\t      input_location = state->loc;\n-\t      state->write (&to, reader);\n-\t      input_location = loc;\n-\t    }\n-\t  if (to.end ())\n-\t    {\n-\t      /* Some OS's do not replace NEWNAME if it already\n-\t\t exists.  This'll have a race condition in erroneous\n-\t\t concurrent builds.  */\n-\t      unlink (path);\n-\t      if (rename (tmp_name, path))\n-\t\t{\n-\t\t  dump () && dump (\"Rename ('%s','%s') errno=%u\", errno);\n-\t\t  to.set_error (errno);\n-\t\t}\n-\t    }\n-\n-\t  if (to.get_error ())\n-\t    {\n-\t      error_at (state->loc, \"failed to write compiled module: %s\",\n-\t\t\tto.get_error (state->filename));\n-\t      state->note_cmi_name ();\n-\t    }\n-\t}\n-\n-      if (!errorcount)\n-\t{\n-\t  auto *mapper = get_mapper (cpp_main_loc (reader));\n-\n-\t  mapper->ModuleCompiled (state->get_flatname ());\n-\t}\n-      else if (path)\n-\t{\n-\t  /* We failed, attempt to erase all evidence we even tried.  */\n-\t  unlink (tmp_name);\n-\t  unlink (path);\n-\t  XDELETEVEC (tmp_name);\n+\t  cookie->began = true;\n+\t  auto loc = input_location;\n+\t  /* So crashes finger-point the module decl.  */\n+\t  input_location = state->loc;\n+\t  state->write (&cookie->out, reader);\n+\t  input_location = loc;\n \t}\n \n       dump.pop (n);\n@@ -19974,11 +19961,67 @@ finish_module_processing (cpp_reader *reader)\n \t\t       (available_clusters + !available_clusters));\n       dump.pop (n);\n     }\n+\n+  return cookie;\n+}\n+\n+// Do the final emission of a module.  At this point we know whether\n+// the module static initializer is a NOP or not.\n+\n+static void\n+late_finish_module (cpp_reader *reader, module_processing_cookie *cookie)\n+{\n+  timevar_start (TV_MODULE_EXPORT);\n+\n+  module_state *state = (*modules)[0];\n+  unsigned n = dump.push (state);\n+  state->announce (\"finishing\");\n+\n+  if (cookie->out.end () && cookie->cmi_name)\n+    {\n+      /* Some OS's do not replace NEWNAME if it already exists.\n+\t This'll have a race condition in erroneous concurrent\n+\t builds.  */\n+      unlink (cookie->cmi_name);\n+      if (rename (cookie->tmp_name, cookie->cmi_name))\n+\t{\n+\t  dump () && dump (\"Rename ('%s','%s') errno=%u\",\n+\t\t\t   cookie->tmp_name, cookie->cmi_name, errno);\n+\t  cookie->out.set_error (errno);\n+\t}\n+    }\n+\n+  if (cookie->out.get_error () && cookie->began)\n+    {\n+      error_at (state->loc, \"failed to write compiled module: %s\",\n+\t\tcookie->out.get_error (state->filename));\n+      state->note_cmi_name ();\n+    }\n+\n+  if (!errorcount)\n+    {\n+      auto *mapper = get_mapper (cpp_main_loc (reader));\n+      mapper->ModuleCompiled (state->get_flatname ());\n+    }\n+  else if (cookie->cmi_name)\n+    {\n+      /* We failed, attempt to erase all evidence we even tried.  */\n+      unlink (cookie->tmp_name);\n+      unlink (cookie->cmi_name);\n+    }\n+\n+  delete cookie;\n+  dump.pop (n);\n+  timevar_stop (TV_MODULE_EXPORT);\n }\n \n void\n-fini_modules ()\n+fini_modules (cpp_reader *reader, void *cookie)\n {\n+  if (cookie)\n+    late_finish_module (reader,\n+\t\t\tstatic_cast<module_processing_cookie *> (cookie));\n+\n   /* We're done with the macro tables now.  */\n   vec_free (macro_exports);\n   vec_free (macro_imports);"}]}