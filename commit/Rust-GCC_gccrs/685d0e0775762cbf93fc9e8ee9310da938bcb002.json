{"sha": "685d0e0775762cbf93fc9e8ee9310da938bcb002", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njg1ZDBlMDc3NTc2MmNiZjkzZmM5ZThlZTkzMTBkYTkzOGJjYjAwMg==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2003-03-19T04:41:48Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2003-03-19T04:41:48Z"}, "message": "re PR target/10062 (internal compiler error: in output_cbranch, at config/pa/pa.c: 5515)\n\n\tPR 10062\n\t* config/pa/pa-hpux.h (TARGET_HPUX_UNWIND_LIBRARY): Redefine.\n\t* pa-protos.h (output_lbranch): New prototype.\n\t* pa.c (compute_frame_size): Change size of the frame marker on the\n\t64-bit ports to 48 bytes.\n\t(pa_output_function_prologue): Document why SAVE_SP is set.\n\t(hppa_expand_prologue): Save previous stack pointer into frame marker\n\ton targets which use the hpux unwind library.\n\t(output_cbranch): Use output_lbranch.\n\t(output_lbranch): New function to output long unconditional branches.\n\t* pa.h (TARGET_HPUX_UNWIND_LIBRARY): Define.\n\t(STACK_POINTER_OFFSET): Update offset for 48-byte frame marker on\n\t64-bit ports.\n\t* pa.md (jump): Use output_lbranch.\n\t(allocate_stack): New expander for dynamic stack allocation.\n\nFrom-SVN: r64570", "tree": {"sha": "8cab564fd46594fddefc2c1e4e53ef844b33310a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8cab564fd46594fddefc2c1e4e53ef844b33310a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/685d0e0775762cbf93fc9e8ee9310da938bcb002", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/685d0e0775762cbf93fc9e8ee9310da938bcb002", "html_url": "https://github.com/Rust-GCC/gccrs/commit/685d0e0775762cbf93fc9e8ee9310da938bcb002", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/685d0e0775762cbf93fc9e8ee9310da938bcb002/comments", "author": null, "committer": null, "parents": [{"sha": "6788f5ca12b792117998e35270093704fa257857", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6788f5ca12b792117998e35270093704fa257857", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6788f5ca12b792117998e35270093704fa257857"}], "stats": {"total": 411, "additions": 271, "deletions": 140}, "files": [{"sha": "c6d7f903f94ea82dfff17d1c3d354f319a2ca05f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/685d0e0775762cbf93fc9e8ee9310da938bcb002/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/685d0e0775762cbf93fc9e8ee9310da938bcb002/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=685d0e0775762cbf93fc9e8ee9310da938bcb002", "patch": "@@ -1,3 +1,21 @@\n+2003-03-18  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\tPR 10062\n+\t* config/pa/pa-hpux.h (TARGET_HPUX_UNWIND_LIBRARY): Redefine.\n+\t* pa-protos.h (output_lbranch): New prototype.\n+\t* pa.c (compute_frame_size): Change size of the frame marker on the\n+\t64-bit ports to 48 bytes.\n+\t(pa_output_function_prologue): Document why SAVE_SP is set.\n+\t(hppa_expand_prologue): Save previous stack pointer into frame marker\n+\ton targets which use the hpux unwind library.\n+\t(output_cbranch): Use output_lbranch.\n+\t(output_lbranch): New function to output long unconditional branches.\n+\t* pa.h (TARGET_HPUX_UNWIND_LIBRARY): Define.\n+\t(STACK_POINTER_OFFSET): Update offset for 48-byte frame marker on\n+\t64-bit ports.\n+\t* pa.md (jump): Use output_lbranch.\n+\t(allocate_stack): New expander for dynamic stack allocation.\n+\n 2003-03-19  Alan Modra  <amodra@bigpond.net.au>\n \n \t* config/rs6000/rs6000.c (rs6000_stack_info): Only require a frame"}, {"sha": "d6e1516401395dba542a2311f04f66b7aeeb4d04", "filename": "gcc/config/pa/pa-hpux.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/685d0e0775762cbf93fc9e8ee9310da938bcb002/gcc%2Fconfig%2Fpa%2Fpa-hpux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/685d0e0775762cbf93fc9e8ee9310da938bcb002/gcc%2Fconfig%2Fpa%2Fpa-hpux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-hpux.h?ref=685d0e0775762cbf93fc9e8ee9310da938bcb002", "patch": "@@ -100,3 +100,8 @@ Boston, MA 02111-1307, USA.  */\n /* hpux11 and earlier don't have fputc_unlocked, so we must inhibit the\n    transformation of fputs_unlocked and fprintf_unlocked to fputc_unlocked.  */\n #define DONT_HAVE_FPUTC_UNLOCKED\n+\n+/* We want the entry value of SP saved in the frame marker for\n+   compatibility with the HP-UX unwind library.  */\n+#undef TARGET_HPUX_UNWIND_LIBRARY\n+#define TARGET_HPUX_UNWIND_LIBRARY 1"}, {"sha": "16c9fbf079ae71ad90ee3a18b7abe493536a551b", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/685d0e0775762cbf93fc9e8ee9310da938bcb002/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/685d0e0775762cbf93fc9e8ee9310da938bcb002/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=685d0e0775762cbf93fc9e8ee9310da938bcb002", "patch": "@@ -44,6 +44,7 @@ extern const char *output_move_double PARAMS ((rtx *));\n extern const char *output_fp_move_double PARAMS ((rtx *));\n extern const char *output_block_move PARAMS ((rtx *, int));\n extern const char *output_cbranch PARAMS ((rtx *, int, int, int, rtx));\n+extern const char *output_lbranch PARAMS ((rtx, rtx));\n extern const char *output_bb PARAMS ((rtx *, int, int, int, rtx, int));\n extern const char *output_bvb PARAMS ((rtx *, int, int, int, rtx, int));\n extern const char *output_dbra PARAMS ((rtx *, rtx, int));"}, {"sha": "83205ba2568ef26ab84ed783eaf4da5caaad653c", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 196, "deletions": 81, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/685d0e0775762cbf93fc9e8ee9310da938bcb002/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/685d0e0775762cbf93fc9e8ee9310da938bcb002/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=685d0e0775762cbf93fc9e8ee9310da938bcb002", "patch": "@@ -3270,10 +3270,10 @@ compute_frame_size (size, fregs_live)\n   size += current_function_outgoing_args_size;\n \n   /* Allocate space for the fixed frame marker.  This space must be\n-     allocated for any function that makes calls or otherwise allocates\n+     allocated for any function that makes calls or allocates\n      stack space.  */\n   if (!current_function_is_leaf || size)\n-    size += TARGET_64BIT ? 16 : 32;\n+    size += TARGET_64BIT ? 48 : 32;\n \n   /* Finally, round to the preferred stack boundary.  */\n   return ((size + PREFERRED_STACK_BOUNDARY / 8 - 1)\n@@ -3317,6 +3317,15 @@ pa_output_function_prologue (file, size)\n   else\n     fputs (\",NO_CALLS\", file);\n \n+  /* The SAVE_SP flag is used to indicate that register %r3 is stored\n+     at the beginning of the frame and that it is used as the frame\n+     pointer for the frame.  We do this because our current frame\n+     layout doesn't conform to that specified in the the HP runtime\n+     documentation and we need a way to indicate to programs such as\n+     GDB where %r3 is saved.  The SAVE_SP flag was chosen because it\n+     isn't used by HP compilers but is supported by the assembler.\n+     However, SAVE_SP is supposed to indicate that the previous stack\n+     pointer has been saved in the frame marker.  */\n   if (frame_pointer_needed)\n     fputs (\",SAVE_SP\", file);\n \n@@ -3416,11 +3425,32 @@ hppa_expand_prologue ()\n \t\t\t      adjust2, 1);\n \t    }\n \n-\t  /* Prevent register spills from being scheduled before the\n-\t     stack pointer is raised.  Necessary as we will be storing\n-\t     registers using the frame pointer as a base register, and\n-\t     we happen to set fp before raising sp.  */\n-\t  emit_insn (gen_blockage ());\n+\t  /* We set SAVE_SP in frames that need a frame pointer.  Thus,\n+\t     we need to store the previous stack pointer (frame pointer)\n+\t     into the frame marker on targets that use the HP unwind\n+\t     library.  This allows the HP unwind library to be used to\n+\t     unwind GCC frames.  However, we are not fully compatible\n+\t     with the HP library because our frame layout differs from\n+\t     that specified in the HP runtime specification.\n+\n+\t     We don't want a frame note on this instruction as the frame\n+\t     marker moves during dynamic stack allocation.\n+\n+\t     This instruction also serves as a blockage to prevent\n+\t     register spills from being scheduled before the stack\n+\t     pointer is raised.  This is necessary as we store\n+\t     registers using the frame pointer as a base register,\n+\t     and the frame pointer is set before sp is raised.  */\n+\t  if (TARGET_HPUX_UNWIND_LIBRARY)\n+\t    {\n+\t      rtx addr = gen_rtx_PLUS (word_mode, stack_pointer_rtx,\n+\t\t\t\t       GEN_INT (TARGET_64BIT ? -8 : -4));\n+\n+\t      emit_move_insn (gen_rtx_MEM (word_mode, addr),\n+\t\t\t      frame_pointer_rtx);\n+\t    }\n+\t  else\n+\t    emit_insn (gen_blockage ());\n \t}\n       /* no frame pointer needed.  */\n       else\n@@ -5517,6 +5547,7 @@ output_cbranch (operands, nullify, length, negated, insn)\n {\n   static char buf[100];\n   int useskip = 0;\n+  rtx xoperands[5];\n \n   /* A conditional branch to the following instruction (eg the delay slot) is\n      asking for a disaster.  This can happen when not optimizing.\n@@ -5622,98 +5653,182 @@ output_cbranch (operands, nullify, length, negated, insn)\n \tbreak;\n \n       case 20:\n-\t/* Very long branch.  Right now we only handle these when not\n-\t   optimizing.  See \"jump\" pattern in pa.md for details.  */\n-\tif (optimize)\n-\t  abort ();\n+      case 28:\n+\txoperands[0] = operands[0];\n+\txoperands[1] = operands[1];\n+\txoperands[2] = operands[2];\n+\txoperands[3] = operands[3];\n+\n+\t/* The reversed conditional branch must branch over one additional\n+\t   instruction if the delay slot is filled.  If the delay slot\n+\t   is empty, the instruction after the reversed condition branch\n+\t   must be nullified.  */\n+\tnullify = dbr_sequence_length () == 0;\n+\txoperands[4] = nullify ? GEN_INT (length) : GEN_INT (length + 4);\n \n \t/* Create a reversed conditional branch which branches around\n \t   the following insns.  */\n-\tif (negated)\n-\t  strcpy (buf, \"{com%I2b,%S3,n %2,%r1,.+20|cmp%I2b,%S3,n %2,%r1,.+20}\");\n+\tif (GET_MODE (operands[1]) != DImode)\n+\t  {\n+\t    if (nullify)\n+\t      {\n+\t\tif (negated)\n+\t\t  strcpy (buf,\n+\t\t    \"{com%I2b,%S3,n %2,%r1,.+%4|cmp%I2b,%S3,n %2,%r1,.+%4}\");\n+\t\telse\n+\t\t  strcpy (buf,\n+\t\t    \"{com%I2b,%B3,n %2,%r1,.+%4|cmp%I2b,%B3,n %2,%r1,.+%4}\");\n+\t      }\n+\t    else\n+\t      {\n+\t\tif (negated)\n+\t\t  strcpy (buf,\n+\t\t    \"{com%I2b,%S3 %2,%r1,.+%4|cmp%I2b,%S3 %2,%r1,.+%4}\");\n+\t\telse\n+\t\t  strcpy (buf,\n+\t\t    \"{com%I2b,%B3 %2,%r1,.+%4|cmp%I2b,%B3 %2,%r1,.+%4}\");\n+\t      }\n+\t  }\n \telse\n-\t  strcpy (buf, \"{com%I2b,%B3,n %2,%r1,.+20|cmp%I2b,%B3,n %2,%r1,.+20}\");\n-\tif (GET_MODE (operands[1]) == DImode)\n \t  {\n-\t    if (negated)\n-\t      strcpy (buf,\n-\t\t      \"{com%I2b,*%S3,n %2,%r1,.+20|cmp%I2b,*%S3,n %2,%r1,.+20}\");\n+\t    if (nullify)\n+\t      {\n+\t\tif (negated)\n+\t\t  strcpy (buf,\n+\t\t    \"{com%I2b,*%S3,n %2,%r1,.+%4|cmp%I2b,*%S3,n %2,%r1,.+%4}\");\n+\t\telse\n+\t\t  strcpy (buf,\n+\t\t    \"{com%I2b,*%B3,n %2,%r1,.+%4|cmp%I2b,*%B3,n %2,%r1,.+%4}\");\n+\t      }\n \t    else\n-\t      strcpy (buf,\n-\t\t      \"{com%I2b,*%B3,n %2,%r1,.+20|cmp%I2b,*%B3,n %2,%r1,.+20}\");\n+\t      {\n+\t\tif (negated)\n+\t\t  strcpy (buf,\n+\t\t    \"{com%I2b,*%S3 %2,%r1,.+%4|cmp%I2b,*%S3 %2,%r1,.+%4}\");\n+\t\telse\n+\t\t  strcpy (buf,\n+\t\t    \"{com%I2b,*%B3 %2,%r1,.+%4|cmp%I2b,*%B3 %2,%r1,.+%4}\");\n+\t      }\n \t  }\n-\toutput_asm_insn (buf, operands);\n \n-\t/* Output an insn to save %r1.  */\n-\toutput_asm_insn (\"stw %%r1,-16(%%r30)\", operands);\n+\toutput_asm_insn (buf, xoperands);\n+\treturn output_lbranch (operands[0], insn);\n \n-\t/* Now output a very long branch to the original target.  */\n-\toutput_asm_insn (\"ldil L'%l0,%%r1\\n\\tbe R'%l0(%%sr4,%%r1)\", operands);\n+      default:\n+\tabort ();\n+    }\n+  return buf;\n+}\n \n-\t/* Now restore the value of %r1 in the delay slot.  We're not\n-\t   optimizing so we know nothing else can be in the delay slot.  */\n-\treturn \"ldw -16(%%r30),%%r1\";\n+/* This routine handles long unconditional branches that exceed the\n+   maximum range of a simple branch instruction.  */\n \n-      case 28:\n-\t/* Very long branch when generating PIC code.  Right now we only\n-\t   handle these when not optimizing.  See \"jump\" pattern in pa.md\n-\t   for details.  */\n-\tif (optimize)\n-\t  abort ();\n+const char *\n+output_lbranch (dest, insn)\n+     rtx dest, insn;\n+{\n+  rtx xoperands[2];\n+ \n+  xoperands[0] = dest;\n \n-\t/* Create a reversed conditional branch which branches around\n-\t   the following insns.  */\n-\tif (negated)\n-\t  strcpy (buf, \"{com%I2b,%S3,n %2,%r1,.+28|cmp%I2b,%S3,n %2,%r1,.+28}\");\n-\telse\n-\t  strcpy (buf, \"{com%I2b,%B3,n %2,%r1,.+28|cmp%I2b,%B3,n %2,%r1,.+28}\");\n-\tif (GET_MODE (operands[1]) == DImode)\n-\t  {\n-\t    if (negated)\n-\t      strcpy (buf, \"{com%I2b,*%S3,n %2,%r1,.+28|cmp%I2b,*%S3,n %2,%r1,.+28}\");\n-\t    else\n-\t      strcpy (buf, \"{com%I2b,*%B3,n %2,%r1,.+28|cmp%I2b,*%B3,n %2,%r1,.+28}\");\n-\t  }\n-\toutput_asm_insn (buf, operands);\n+  /* First, free up the delay slot.  */\n+  if (dbr_sequence_length () != 0)\n+    {\n+      /* We can't handle a jump in the delay slot.  */\n+      if (GET_CODE (NEXT_INSN (insn)) == JUMP_INSN)\n+\tabort ();\n \n-\t/* Output an insn to save %r1.  */\n-\toutput_asm_insn (\"stw %%r1,-16(%%r30)\", operands);\n+      final_scan_insn (NEXT_INSN (insn), asm_out_file,\n+\t\t       optimize, 0, 0);\n+\n+      /* Now delete the delay insn.  */\n+      PUT_CODE (NEXT_INSN (insn), NOTE);\n+      NOTE_LINE_NUMBER (NEXT_INSN (insn)) = NOTE_INSN_DELETED;\n+      NOTE_SOURCE_FILE (NEXT_INSN (insn)) = 0;\n+    }\n+\n+  /* Output an insn to save %r1.  The runtime documentation doesn't\n+     specify whether the \"Clean Up\" slot in the callers frame can\n+     be clobbered by the callee.  It isn't copied by HP's builtin\n+     alloca, so this suggests that it can be clobbered if necessary.\n+     The \"Static Link\" location is copied by HP builtin alloca, so\n+     we avoid using it.  Using the cleanup slot might be a problem\n+     if we have to interoperate with languages that pass cleanup\n+     information.  However, it should be possible to handle these\n+     situations with GCC's asm feature.\n+\n+     The \"Current RP\" slot is reserved for the called procedure, so\n+     we try to use it when we don't have a frame of our own.  It's\n+     rather unlikely that we won't have a frame when we need to emit\n+     a very long branch.\n+\n+     Really the way to go long term is a register scavenger; goto\n+     the target of the jump and find a register which we can use\n+     as a scratch to hold the value in %r1.  Then, we wouldn't have\n+     to free up the delay slot or clobber a slot that may be needed\n+     for other purposes.  */\n+  if (TARGET_64BIT)\n+    {\n+      if (actual_fsize == 0 && !regs_ever_live[2])\n+\t/* Use the return pointer slot in the frame marker.  */\n+\toutput_asm_insn (\"std %%r1,-16(%%r30)\", xoperands);\n+      else\n+\t/* Use the slot at -40 in the frame marker since HP builtin\n+\t   alloca doesn't copy it.  */\n+\toutput_asm_insn (\"std %%r1,-40(%%r30)\", xoperands);\n+    }\n+  else\n+    {\n+      if (actual_fsize == 0 && !regs_ever_live[2])\n+\t/* Use the return pointer slot in the frame marker.  */\n+\toutput_asm_insn (\"stw %%r1,-20(%%r30)\", xoperands);\n+      else\n+\t/* Use the \"Clean Up\" slot in the frame marker.  In GCC,\n+\t   the only other use of this location is for copying a\n+\t   floating point double argument from a floating-point\n+\t   register to two general registers.  The copy is done\n+\t   as an \"atomic\" operation when outputing a call, so it\n+\t   won't interfere with our using the location here.  */\n+\toutput_asm_insn (\"stw %%r1,-12(%%r30)\", xoperands);\n+    }\n \n-\t/* Now output a very long PIC branch to the original target.  */\n+  if (flag_pic)\n+    {\n+      output_asm_insn (\"{bl|b,l} .+8,%%r1\", xoperands);\n+      if (TARGET_SOM || !TARGET_GAS)\n \t{\n-\t  rtx xoperands[5];\n-\n-\t  xoperands[0] = operands[0];\n-\t  xoperands[1] = operands[1];\n-\t  xoperands[2] = operands[2];\n-\t  xoperands[3] = operands[3];\n-\n-\t  output_asm_insn (\"{bl|b,l} .+8,%%r1\", xoperands);\n-\t  if (TARGET_SOM || !TARGET_GAS)\n-\t    {\n-\t      xoperands[4] = gen_label_rtx ();\n-\t      output_asm_insn (\"addil L'%l0-%l4,%%r1\", xoperands);\n-\t      (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n-\t\t\t\t\t CODE_LABEL_NUMBER (xoperands[4]));\n-\t      output_asm_insn (\"ldo R'%l0-%l4(%%r1),%%r1\", xoperands);\n-\t    }\n-\t  else\n-\t    {\n-\t      output_asm_insn (\"addil L'%l0-$PIC_pcrel$0+4,%%r1\", xoperands);\n-\t      output_asm_insn (\"ldo R'%l0-$PIC_pcrel$0+8(%%r1),%%r1\",\n-\t\t\t       xoperands);\n-\t    }\n-\t  output_asm_insn (\"bv %%r0(%%r1)\", xoperands);\n+\t  xoperands[1] = gen_label_rtx ();\n+\t  output_asm_insn (\"addil L'%l0-%l1,%%r1\", xoperands);\n+\t  (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n+\t\t\t\t\t     CODE_LABEL_NUMBER (xoperands[1]));\n+\t  output_asm_insn (\"ldo R'%l0-%l1(%%r1),%%r1\", xoperands);\n \t}\n+      else\n+\t{\n+\t  output_asm_insn (\"addil L'%l0-$PIC_pcrel$0+4,%%r1\", xoperands);\n+\t  output_asm_insn (\"ldo R'%l0-$PIC_pcrel$0+8(%%r1),%%r1\", xoperands);\n+\t}\n+      output_asm_insn (\"bv %%r0(%%r1)\", xoperands);\n+    }\n+  else\n+    /* Now output a very long branch to the original target.  */\n+    output_asm_insn (\"ldil L'%l0,%%r1\\n\\tbe R'%l0(%%sr4,%%r1)\", xoperands);\n \n-\t/* Now restore the value of %r1 in the delay slot.  We're not\n-\t   optimizing so we know nothing else can be in the delay slot.  */\n-\treturn \"ldw -16(%%r30),%%r1\";\n-\n-      default:\n-\tabort ();\n+  /* Now restore the value of %r1 in the delay slot.  */\n+  if (TARGET_64BIT)\n+    {\n+      if (actual_fsize == 0 && !regs_ever_live[2])\n+\treturn \"ldd -16(%%r30),%%r1\";\n+      else\n+\treturn \"ldd -40(%%r30),%%r1\";\n+    }\n+  else\n+    {\n+      if (actual_fsize == 0 && !regs_ever_live[2])\n+\treturn \"ldw -20(%%r30),%%r1\";\n+      else\n+\treturn \"ldw -12(%%r30),%%r1\";\n     }\n-  return buf;\n }\n \n /* This routine handles all the branch-on-bit conditional branch sequences we"}, {"sha": "177cae33ddc4ee7bf0ae6e2962b35e09e2ae7255", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/685d0e0775762cbf93fc9e8ee9310da938bcb002/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/685d0e0775762cbf93fc9e8ee9310da938bcb002/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=685d0e0775762cbf93fc9e8ee9310da938bcb002", "patch": "@@ -211,6 +211,15 @@ extern int target_flags;\n    definition symbols is buggy prior to HP-UX 11.X.  */\n #define TARGET_SOM_SDEF 0\n \n+/* Define to a C expression evaluating to true to save the entry value\n+   of SP in the current frame marker.  This is normally unnecessary.\n+   However, the HP-UX unwind library looks at the SAVE_SP callinfo flag.\n+   HP compilers don't use this flag but it is supported by the assembler.\n+   We set this flag to indicate that register %r3 has been saved at the\n+   start of the frame.  Thus, when the HP unwind library is used, we\n+   need to generate additional code to save SP into the frame marker.  */\n+#define TARGET_HPUX_UNWIND_LIBRARY 0\n+\n /* Macro to define tables used to set the flags.  This is a\n    list in braces of target switches with each switch being\n    { \"NAME\", VALUE, \"HELP_STRING\" }.  VALUE is the bits to set,\n@@ -714,9 +723,13 @@ extern struct rtx_def *hppa_pic_save_rtx PARAMS ((void));\n /* The weird HPPA calling conventions require a minimum of 48 bytes on\n    the stack: 16 bytes for register saves, and 32 bytes for magic.\n    This is the difference between the logical top of stack and the\n-   actual sp.  */\n+   actual sp.\n+\n+   On the 64-bit port, the HP C compiler allocates a 48-byte frame\n+   marker, although the runtime documentation only describes a 16\n+   byte marker.  For compatibility, we allocate 48 bytes.  */\n #define STACK_POINTER_OFFSET \\\n-  (TARGET_64BIT ? -(current_function_outgoing_args_size + 16): -32)\n+  (TARGET_64BIT ? -(current_function_outgoing_args_size + 48): -32)\n \n #define STACK_DYNAMIC_OFFSET(FNDECL)\t\\\n   (TARGET_64BIT\t\t\t\t\\"}, {"sha": "0f50c8ff71d99221b7e053f317ffd1c315738364", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 36, "deletions": 57, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/685d0e0775762cbf93fc9e8ee9310da938bcb002/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/685d0e0775762cbf93fc9e8ee9310da938bcb002/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=685d0e0775762cbf93fc9e8ee9310da938bcb002", "patch": "@@ -5721,8 +5721,6 @@\n   \"\"\n   \"*\n {\n-  extern int optimize;\n-\n   if (GET_MODE (insn) == SImode)\n     return \\\"b %l0%#\\\";\n \n@@ -5731,61 +5729,7 @@\n       && get_attr_length (insn) != 16)\n     return \\\"b%* %l0\\\";\n \n-  /* An unconditional branch which can not reach its target.\n-\n-     We need to be able to use %r1 as a scratch register; however,\n-     we can never be sure whether or not it's got a live value in\n-     it.  Therefore, we must restore its original value after the\n-     jump.\n-\n-     To make matters worse, we don't have a stack slot which we\n-     can always clobber.  sp-12/sp-16 shouldn't ever have a live\n-     value during a non-optimizing compilation, so we use those\n-     slots for now.  We don't support very long branches when\n-     optimizing -- they should be quite rare when optimizing.\n-\n-     Really the way to go long term is a register scavenger; goto\n-     the target of the jump and find a register which we can use\n-     as a scratch to hold the value in %r1.  */\n-\n-  /* We don't know how to register scavenge yet.  */\n-  if (optimize)\n-    abort ();\n-\n-  /* First store %r1 into the stack.  */\n-  output_asm_insn (\\\"stw %%r1,-16(%%r30)\\\", operands);\n-\n-  /* Now load the target address into %r1 and do an indirect jump\n-     to the value specified in %r1.  Be careful to generate PIC\n-     code as needed.  */\n-  if (flag_pic)\n-    {\n-      rtx xoperands[2];\n-      xoperands[0] = operands[0];\n-      if (TARGET_SOM || ! TARGET_GAS)\n-\t{\n-\t  xoperands[1] = gen_label_rtx ();\n-\n-\t  output_asm_insn (\\\"{bl|b,l} .+8,%%r1\\\\n\\\\taddil L'%l0-%l1,%%r1\\\",\n-\t\t\t   xoperands);\n-\t  (*targetm.asm_out.internal_label) (asm_out_file, \\\"L\\\",\n-\t\t\t\t     CODE_LABEL_NUMBER (xoperands[1]));\n-\t  output_asm_insn (\\\"ldo R'%l0-%l1(%%r1),%%r1\\\", xoperands);\n-\t}\n-      else\n-\t{\n-\t  output_asm_insn (\\\"{bl|b,l} .+8,%%r1\\\", xoperands);\n-\t  output_asm_insn (\\\"addil L'%l0-$PIC_pcrel$0+4,%%r1\\\", xoperands);\n-\t  output_asm_insn (\\\"ldo R'%l0-$PIC_pcrel$0+8(%%r1),%%r1\\\", xoperands);\n-\t}\n-      output_asm_insn (\\\"bv %%r0(%%r1)\\\", xoperands);\n-    }\n-  else\n-    output_asm_insn (\\\"ldil L'%l0,%%r1\\\\n\\\\tbe R'%l0(%%sr4,%%r1)\\\", operands);;\n-\n-  /* And restore the value of %r1 in the delay slot.  We're not optimizing,\n-     so we know nothing else can be in the delay slot.  */\n-  return \\\"ldw -16(%%r30),%%r1\\\";\n+  return output_lbranch (operands[0], insn);\n }\"\n   [(set_attr \"type\" \"uncond_branch\")\n    (set_attr \"pa_combine_type\" \"uncond_branch\")\n@@ -8053,3 +7997,38 @@\n   emit_insn (gen_blockage ());\n   DONE;\n }\")\n+\n+;; Allocate new stack space and update the saved stack pointer in the\n+;; frame marker.  The HP C compilers also copy additional words in the\n+;; frame marker.  The 64-bit compiler copies words at -48, -32 and -24.\n+;; The 32-bit compiler copies the word at -16 (Static Link).  We\n+;; currently don't copy these values.\n+;;\n+;; Since the copy of the frame marker can't be done atomically, I\n+;; suspect that using it for unwind purposes may be somewhat unreliable.\n+;; The HP compilers appear to raise the stack and copy the frame\n+;; marker in a strict instruction sequence.  This suggests that the\n+;; unwind library may check for an alloca sequence when ALLOCA_FRAME\n+;; is set in the callinfo data.  We currently don't set ALLOCA_FRAME\n+;; as GAS doesn't support it, or try to keep the instructions emitted\n+;; here in strict sequence.\n+(define_expand \"allocate_stack\"\n+  [(match_operand 0 \"\" \"\")\n+   (match_operand 1 \"\" \"\")]\n+  \"\"\n+  \"\n+{\n+  /* Since the stack grows upward, we need to store virtual_stack_dynamic_rtx\n+     in operand 0 before adjusting the stack.  */\n+  emit_move_insn (operands[0], virtual_stack_dynamic_rtx);\n+  anti_adjust_stack (operands[1]);\n+  if (TARGET_HPUX_UNWIND_LIBRARY)\n+    {\n+      rtx dst = gen_rtx_MEM (word_mode,\n+  \t\t\t     gen_rtx_PLUS (word_mode, stack_pointer_rtx,\n+\t\t\t  \t\t   GEN_INT (TARGET_64BIT ? -8 : -4)));\n+\n+      emit_move_insn (dst, frame_pointer_rtx);\n+    }\n+  DONE;\n+}\")"}]}