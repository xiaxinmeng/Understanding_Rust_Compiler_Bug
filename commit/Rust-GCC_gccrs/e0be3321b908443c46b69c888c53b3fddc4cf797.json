{"sha": "e0be3321b908443c46b69c888c53b3fddc4cf797", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBiZTMzMjFiOTA4NDQzYzQ2YjY5Yzg4OGM1M2IzZmRkYzRjZjc5Nw==", "commit": {"author": {"name": "Claudiu Zissulescu", "email": "claziss@synopsys.com", "date": "2018-04-30T13:16:09Z"}, "committer": {"name": "Claudiu Zissulescu", "email": "claziss@gcc.gnu.org", "date": "2018-04-30T13:16:09Z"}, "message": "[ARC] Cleanup sdata handling.\n\nClean up how we handle small data load/store operations.\n\ngcc/\n2018-01-18  Claudiu Zissulescu  <claziss@synopsys.com>\n\n\t* config/arc/arc-protos.h (prepare_extend_operands): Remove.\n\t(small_data_pattern): Likewise.\n\t(arc_rewrite_small_data): Likewise.\n\t* config/arc/arc.c (LEGITIMATE_SMALL_DATA_OFFSET_P): Remove.\n\t(LEGITIMATE_SMALL_DATA_ADDRESS_P): Likewise.\n\t(get_symbol_alignment): New function.\n\t(legitimate_small_data_address_p): Likewise.\n\t(legitimate_scaled_address): Update, call\n\tlegitimate_small_data_address_p.\n\t(output_sdata): New static variable.\n\t(arc_print_operand): Update how we handle small data operands.\n\t(arc_print_operand_address): Likewise.\n\t(arc_legitimate_address_p): Update, use\n\tlegitimate_small_data_address_p.\n\t(arc_rewrite_small_data_p): Remove.\n\t(arc_rewrite_small_data_1): Likewise.\n\t(arc_rewrite_small_data): Likewise.\n\t(small_data_pattern): Likewise.\n\t(compact_sda_memory_operand): Update to use\n\tlegitimate_small_data_address_p and get_symbol_alignment.\n\t(prepare_move_operands): Don't rewite sdata pattern.\n\t(prepare_extend_operands): Remove.\n\t* config/arc/arc.md (zero_extendqihi2): Don't rewrite sdata\n\tpattern.\n\t(zero_extendqisi2): Likewise.\n\t(zero_extendhisi2): Likewise.\n\t(extendqihi2): Likewise.\n\t(extendqisi2): Likewise.\n\t(extendhisi2): Likewise.\n\t(addsi3): Likewise.\n\t(subsi3): Likewise.\n\t(andsi3): Likewise.\n\t* config/arc/constraints.md (Usd): Change it to memory constraint.\n\ngcc/testsuite\n2018-01-18  Claudiu Zissulescu  <claziss@synopsys.com>\n\n\t* gcc.target/arc/interrupt-8.c: Update test.\n\t* gcc.target/arc/loop-4.c: Likewise.\n\t* gcc.target/arc/loop-hazard-1.c: Likewise.\n\t* gcc.target/arc/sdata-3.c: Likewise.\n\nFrom-SVN: r259763", "tree": {"sha": "efe97a809fcb332422a5d15837c252edd6b2f9b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/efe97a809fcb332422a5d15837c252edd6b2f9b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0be3321b908443c46b69c888c53b3fddc4cf797", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0be3321b908443c46b69c888c53b3fddc4cf797", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0be3321b908443c46b69c888c53b3fddc4cf797", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0be3321b908443c46b69c888c53b3fddc4cf797/comments", "author": {"login": "claziss", "id": 2761368, "node_id": "MDQ6VXNlcjI3NjEzNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/2761368?v=4", "gravatar_id": "", "url": "https://api.github.com/users/claziss", "html_url": "https://github.com/claziss", "followers_url": "https://api.github.com/users/claziss/followers", "following_url": "https://api.github.com/users/claziss/following{/other_user}", "gists_url": "https://api.github.com/users/claziss/gists{/gist_id}", "starred_url": "https://api.github.com/users/claziss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/claziss/subscriptions", "organizations_url": "https://api.github.com/users/claziss/orgs", "repos_url": "https://api.github.com/users/claziss/repos", "events_url": "https://api.github.com/users/claziss/events{/privacy}", "received_events_url": "https://api.github.com/users/claziss/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2295aa75224be0b765cf5c58865e97d094990579", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2295aa75224be0b765cf5c58865e97d094990579", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2295aa75224be0b765cf5c58865e97d094990579"}], "stats": {"total": 401, "additions": 153, "deletions": 248}, "files": [{"sha": "e2afb1f94737b14275e89914e1203c8279b8e935", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0be3321b908443c46b69c888c53b3fddc4cf797/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0be3321b908443c46b69c888c53b3fddc4cf797/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e0be3321b908443c46b69c888c53b3fddc4cf797", "patch": "@@ -1,3 +1,39 @@\n+2018-04-30  Claudiu Zissulescu  <claziss@synopsys.com>\n+\n+\t* config/arc/arc-protos.h (prepare_extend_operands): Remove.\n+\t(small_data_pattern): Likewise.\n+\t(arc_rewrite_small_data): Likewise.\n+\t* config/arc/arc.c (LEGITIMATE_SMALL_DATA_OFFSET_P): Remove.\n+\t(LEGITIMATE_SMALL_DATA_ADDRESS_P): Likewise.\n+\t(get_symbol_alignment): New function.\n+\t(legitimate_small_data_address_p): Likewise.\n+\t(legitimate_scaled_address): Update, call\n+\tlegitimate_small_data_address_p.\n+\t(output_sdata): New static variable.\n+\t(arc_print_operand): Update how we handle small data operands.\n+\t(arc_print_operand_address): Likewise.\n+\t(arc_legitimate_address_p): Update, use\n+\tlegitimate_small_data_address_p.\n+\t(arc_rewrite_small_data_p): Remove.\n+\t(arc_rewrite_small_data_1): Likewise.\n+\t(arc_rewrite_small_data): Likewise.\n+\t(small_data_pattern): Likewise.\n+\t(compact_sda_memory_operand): Update to use\n+\tlegitimate_small_data_address_p and get_symbol_alignment.\n+\t(prepare_move_operands): Don't rewite sdata pattern.\n+\t(prepare_extend_operands): Remove.\n+\t* config/arc/arc.md (zero_extendqihi2): Don't rewrite sdata\n+\tpattern.\n+\t(zero_extendqisi2): Likewise.\n+\t(zero_extendhisi2): Likewise.\n+\t(extendqihi2): Likewise.\n+\t(extendqisi2): Likewise.\n+\t(extendhisi2): Likewise.\n+\t(addsi3): Likewise.\n+\t(subsi3): Likewise.\n+\t(andsi3): Likewise.\n+\t* config/arc/constraints.md (Usd): Change it to memory constraint.\n+\n 2018-04-30  Claudiu Zissulescu  <claziss@synopsys.com>\n \n \t* config/arc/arc.c (arc_split_move): Allow signed 6-bit constants"}, {"sha": "67f3b4e3226be3424539185aa40c89444c8b7fb8", "filename": "gcc/config/arc/arc-protos.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0be3321b908443c46b69c888c53b3fddc4cf797/gcc%2Fconfig%2Farc%2Farc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0be3321b908443c46b69c888c53b3fddc4cf797/gcc%2Fconfig%2Farc%2Farc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc-protos.h?ref=e0be3321b908443c46b69c888c53b3fddc4cf797", "patch": "@@ -33,8 +33,6 @@ extern void arc_print_operand (FILE *, rtx, int);\n extern void arc_print_operand_address (FILE *, rtx);\n extern void arc_final_prescan_insn (rtx_insn *, rtx *, int);\n extern const char *arc_output_libcall (const char *);\n-extern bool prepare_extend_operands (rtx *operands, enum rtx_code code,\n-\t\t\t\t     machine_mode omode);\n extern int arc_output_addsi (rtx *operands, bool, bool);\n extern int arc_output_commutative_cond_exec (rtx *operands, bool);\n extern bool arc_expand_movmem (rtx *operands);\n@@ -65,8 +63,6 @@ extern bool arc_raw_symbolic_reference_mentioned_p (rtx, bool);\n extern bool arc_is_longcall_p (rtx);\n extern bool arc_is_shortcall_p (rtx);\n extern bool valid_brcc_with_delay_p (rtx *);\n-extern bool small_data_pattern (rtx , machine_mode);\n-extern rtx arc_rewrite_small_data (rtx);\n extern bool arc_ccfsm_cond_exec_p (void);\n struct secondary_reload_info;\n extern int arc_register_move_cost (machine_mode, enum reg_class,"}, {"sha": "2bedc9af37eaf3113629cdefa3aa13201f2896b6", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 93, "deletions": 216, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0be3321b908443c46b69c888c53b3fddc4cf797/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0be3321b908443c46b69c888c53b3fddc4cf797/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=e0be3321b908443c46b69c888c53b3fddc4cf797", "patch": "@@ -96,22 +96,6 @@ HARD_REG_SET overrideregs;\n \t\t      ? 0 \\\n \t\t      : -(-GET_MODE_SIZE (MODE) | -4) >> 1)))\n \n-#define LEGITIMATE_SMALL_DATA_OFFSET_P(X)\t\t\t\t\\\n-  (GET_CODE (X) == CONST\t\t\t\t\t\t\\\n-   && GET_CODE (XEXP ((X), 0)) == PLUS\t\t\t\t\t\\\n-   && GET_CODE (XEXP (XEXP ((X), 0), 0)) == SYMBOL_REF\t\t\t\\\n-   && SYMBOL_REF_SMALL_P (XEXP (XEXP ((X), 0), 0))\t\t\t\\\n-   && GET_CODE (XEXP(XEXP ((X), 0), 1)) == CONST_INT\t\t\t\\\n-   && INTVAL (XEXP (XEXP ((X), 0), 1)) <= g_switch_value)\n-\n-#define LEGITIMATE_SMALL_DATA_ADDRESS_P(X)\t\t\t\t\\\n-  (GET_CODE (X) == PLUS\t\t\t\t\t\t\t\\\n-     && REG_P (XEXP ((X), 0))\t\t\t\t\t\t\\\n-     && REGNO (XEXP ((X), 0)) == SDATA_BASE_REGNUM\t\t\t\\\n-     && ((GET_CODE (XEXP ((X), 1)) == SYMBOL_REF\t\t\t\\\n-\t    && SYMBOL_REF_SMALL_P (XEXP ((X), 1)))\t\t\t\\\n-\t || LEGITIMATE_SMALL_DATA_OFFSET_P (XEXP ((X), 1))))\n-\n /* Array of valid operand punctuation characters.  */\n char arc_punct_chars[256];\n \n@@ -308,6 +292,60 @@ static bool arc_use_by_pieces_infrastructure_p (unsigned HOST_WIDE_INT,\n /* Globally visible information about currently selected cpu.  */\n const arc_cpu_t *arc_selected_cpu;\n \n+/* Given a symbol RTX (const (symb <+ const_int>), returns its\n+   alignment.  */\n+\n+static int\n+get_symbol_alignment (rtx x)\n+{\n+  tree decl = NULL_TREE;\n+  int align = 0;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case SYMBOL_REF:\n+      decl = SYMBOL_REF_DECL (x);\n+      break;\n+    case CONST:\n+      return get_symbol_alignment (XEXP (x, 0));\n+    case PLUS:\n+      gcc_assert (CONST_INT_P (XEXP (x, 1)));\n+      return get_symbol_alignment (XEXP (x, 0));\n+    default:\n+      return 0;\n+    }\n+\n+  if (decl)\n+    align = DECL_ALIGN (decl);\n+  align = align / BITS_PER_UNIT;\n+  return align;\n+}\n+\n+/* Return true if x is ok to be used as a small data address.  */\n+\n+static bool\n+legitimate_small_data_address_p (rtx x)\n+{\n+  switch (GET_CODE (x))\n+    {\n+    case CONST:\n+      return legitimate_small_data_address_p (XEXP (x, 0));\n+    case SYMBOL_REF:\n+      return SYMBOL_REF_SMALL_P (x);\n+    case PLUS:\n+      {\n+\tbool p0 = (GET_CODE (XEXP (x, 0)) == SYMBOL_REF)\n+\t  && SYMBOL_REF_SMALL_P (XEXP (x, 0));\n+\tbool p1 = CONST_INT_P (XEXP (x, 1))\n+\t  && (INTVAL (XEXP (x, 1)) <= g_switch_value);\n+\treturn p0 && p1;\n+      }\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* TRUE if op is an scaled address.  */\n static bool\n legitimate_scaled_address_p (machine_mode mode, rtx op, bool strict)\n {\n@@ -352,14 +390,13 @@ legitimate_scaled_address_p (machine_mode mode, rtx op, bool strict)\n \treturn true;\n       return false;\n     }\n+\n+  /* Scalled addresses for sdata is done other places.  */\n+  if (legitimate_small_data_address_p (op))\n+    return false;\n+\n   if (CONSTANT_P (XEXP (op, 1)))\n-    {\n-      /* Scalled addresses for sdata is done other places.  */\n-      if (GET_CODE (XEXP (op, 1)) == SYMBOL_REF\n-\t  && SYMBOL_REF_SMALL_P (XEXP (op, 1)))\n-\treturn false;\n       return true;\n-    }\n \n   return false;\n }\n@@ -3762,6 +3799,9 @@ arc_add_jli_section (rtx pat)\n    reset when we output the scaled address.  */\n static int output_scaled = 0;\n \n+/* Set when we force sdata output.  */\n+static int output_sdata = 0;\n+\n /* Print operand X (an rtx) in assembler syntax to file FILE.\n    CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n    For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n@@ -4114,24 +4154,24 @@ arc_print_operand (FILE *file, rtx x, int code)\n \t\t  fputs (\".as\", file);\n \t\t  output_scaled = 1;\n \t\t}\n-\t      else if (LEGITIMATE_SMALL_DATA_ADDRESS_P (addr)\n-\t\t       && GET_MODE_SIZE (GET_MODE (x)) > 1)\n+\t      break;\n+\t    case SYMBOL_REF:\n+\t    case CONST:\n+\t      if (legitimate_small_data_address_p (addr)\n+\t\t  && GET_MODE_SIZE (GET_MODE (x)) > 1)\n \t\t{\n-\t\t  tree decl = NULL_TREE;\n-\t\t  int align = 0;\n-\t\t  if (GET_CODE (XEXP (addr, 1)) == SYMBOL_REF)\n-\t\t    decl = SYMBOL_REF_DECL (XEXP (addr, 1));\n-\t\t  else if (GET_CODE (XEXP (XEXP (XEXP (addr, 1), 0), 0))\n-\t\t\t   == SYMBOL_REF)\n-\t\t    decl = SYMBOL_REF_DECL (XEXP (XEXP (XEXP (addr, 1), 0), 0));\n-\t\t  if (decl)\n-\t\t    align = DECL_ALIGN (decl);\n-\t\t  align = align / BITS_PER_UNIT;\n-\t\t  if ((GET_MODE_SIZE (GET_MODE (x)) == 2)\n-\t\t      && align && ((align & 1) == 0))\n-\t\t    fputs (\".as\", file);\n-\t\t  if ((GET_MODE_SIZE (GET_MODE (x)) >= 4)\n-\t\t      && align && ((align & 3) == 0))\n+\t\t  int align = get_symbol_alignment (addr);\n+\t\t  int mask = 0;\n+\t\t  switch (GET_MODE (x))\n+\t\t    {\n+\t\t    case E_HImode:\n+\t\t      mask = 1;\n+\t\t      break;\n+\t\t    default:\n+\t\t      mask = 3;\n+\t\t      break;\n+\t\t    }\n+\t\t  if (align && ((align & mask) == 0))\n \t\t    fputs (\".as\", file);\n \t\t}\n \t      break;\n@@ -4250,6 +4290,9 @@ arc_print_operand (FILE *file, rtx x, int code)\n \trtx addr = XEXP (x, 0);\n \tint size = GET_MODE_SIZE (GET_MODE (x));\n \n+\tif (legitimate_small_data_address_p (addr))\n+\t  output_sdata = 1;\n+\n \tfputc ('[', file);\n \n \tswitch (GET_CODE (addr))\n@@ -4310,26 +4353,7 @@ arc_print_operand (FILE *file, rtx x, int code)\n \t\t  || XINT (XEXP (XEXP (x, 0), 0), 1) == UNSPEC_TLS_GD)))\n \tarc_output_pic_addr_const (file, x, code);\n       else\n-\t{\n-\t  /* FIXME: Dirty way to handle @var@sda+const. Shd be handled\n-\t     with asm_output_symbol_ref */\n-\t  if (GET_CODE (x) == CONST && GET_CODE (XEXP (x, 0)) == PLUS)\n-\t    {\n-\t      x = XEXP (x, 0);\n-\t      output_addr_const (file, XEXP (x, 0));\n-\t      if (GET_CODE (XEXP (x, 0)) == SYMBOL_REF && SYMBOL_REF_SMALL_P (XEXP (x, 0)))\n-\t\tfprintf (file, \"@sda\");\n-\n-\t      if (GET_CODE (XEXP (x, 1)) != CONST_INT\n-\t\t  || INTVAL (XEXP (x, 1)) >= 0)\n-\t\tfprintf (file, \"+\");\n-\t      output_addr_const (file, XEXP (x, 1));\n-\t    }\n-\t  else\n-\t    output_addr_const (file, x);\n-\t}\n-      if (GET_CODE (x) == SYMBOL_REF && SYMBOL_REF_SMALL_P (x))\n-\tfprintf (file, \"@sda\");\n+\toutput_addr_const (file, x);\n       break;\n     }\n }\n@@ -4346,10 +4370,13 @@ arc_print_operand_address (FILE *file , rtx addr)\n     case REG :\n       fputs (reg_names[REGNO (addr)], file);\n       break;\n-    case SYMBOL_REF :\n+    case SYMBOL_REF:\n+      if (output_sdata)\n+\tfputs (\"gp,\", file);\n       output_addr_const (file, addr);\n-      if (SYMBOL_REF_SMALL_P (addr))\n-\tfprintf (file, \"@sda\");\n+      if (output_sdata)\n+\tfputs (\"@sda\", file);\n+      output_sdata = 0;\n       break;\n     case PLUS :\n       if (GET_CODE (XEXP (addr, 0)) == MULT)\n@@ -6170,7 +6197,7 @@ arc_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n      return true;\n   if (legitimate_scaled_address_p (mode, x, strict))\n     return true;\n-  if (LEGITIMATE_SMALL_DATA_ADDRESS_P (x))\n+  if (legitimate_small_data_address_p (x))\n      return true;\n   if (GET_CODE (x) == CONST_INT && LARGE_INT (INTVAL (x)))\n      return true;\n@@ -7973,106 +8000,16 @@ arc_in_small_data_p (const_tree decl)\n   return false;\n }\n \n-/* Return true if X is a small data address that can be rewritten\n-   as a gp+symref.  */\n-\n-static bool\n-arc_rewrite_small_data_p (const_rtx x)\n-{\n-  if (GET_CODE (x) == CONST)\n-    x = XEXP (x, 0);\n-\n-  if (GET_CODE (x) == PLUS)\n-    {\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n-\tx = XEXP (x, 0);\n-    }\n-\n-  if (GET_CODE (x) == SYMBOL_REF && SYMBOL_REF_SMALL_P (x))\n-    {\n-      gcc_assert (SYMBOL_REF_TLS_MODEL (x) == 0);\n-      return true;\n-    }\n-  return false;\n-}\n-\n-/* If possible, rewrite OP so that it refers to small data using\n-   explicit relocations.  */\n-\n-static rtx\n-arc_rewrite_small_data_1 (rtx op)\n-{\n-  rtx rgp = gen_rtx_REG (Pmode, SDATA_BASE_REGNUM);\n-  op = copy_insn (op);\n-  subrtx_ptr_iterator::array_type array;\n-  FOR_EACH_SUBRTX_PTR (iter, array, &op, ALL)\n-    {\n-      rtx *loc = *iter;\n-      if (arc_rewrite_small_data_p (*loc))\n-\t{\n-\t  *loc = gen_rtx_PLUS (Pmode, rgp, *loc);\n-\t  iter.skip_subrtxes ();\n-\t}\n-      else if (GET_CODE (*loc) == PLUS\n-\t       && rtx_equal_p (XEXP (*loc, 0), rgp))\n-\titer.skip_subrtxes ();\n-    }\n-  return op;\n-}\n-\n-rtx\n-arc_rewrite_small_data (rtx op)\n-{\n-  op = arc_rewrite_small_data_1 (op);\n-\n-  /* Check if we fit small data constraints.  */\n-  if (MEM_P (op)\n-      && !LEGITIMATE_SMALL_DATA_ADDRESS_P (XEXP (op, 0)))\n-    {\n-      rtx addr = XEXP (op, 0);\n-      rtx tmp = gen_reg_rtx (Pmode);\n-      emit_move_insn (tmp, addr);\n-      op = replace_equiv_address_nv (op, tmp);\n-    }\n-  return op;\n-}\n-\n-/* Return true if OP refers to small data symbols directly, not through\n-   a PLUS.  */\n-\n-bool\n-small_data_pattern (rtx op, machine_mode)\n-{\n-  if (GET_CODE (op) == SEQUENCE)\n-    return false;\n-\n-  rtx rgp = gen_rtx_REG (Pmode, SDATA_BASE_REGNUM);\n-  subrtx_iterator::array_type array;\n-  FOR_EACH_SUBRTX (iter, array, op, ALL)\n-    {\n-      const_rtx x = *iter;\n-      if (GET_CODE (x) == PLUS\n-\t  && rtx_equal_p (XEXP (x, 0), rgp))\n-\titer.skip_subrtxes ();\n-      else if (arc_rewrite_small_data_p (x))\n-\treturn true;\n-    }\n-  return false;\n-}\n-\n /* Return true if OP is an acceptable memory operand for ARCompact\n    16-bit gp-relative load instructions.\n-   op shd look like : [r26, symref@sda]\n-   i.e. (mem (plus (reg 26) (symref with smalldata flag set))\n-  */\n+*/\n /* volatile cache option still to be handled.  */\n \n bool\n compact_sda_memory_operand (rtx op, machine_mode mode, bool short_p)\n {\n   rtx addr;\n   int size;\n-  tree decl = NULL_TREE;\n   int align = 0;\n   int mask = 0;\n \n@@ -8092,22 +8029,15 @@ compact_sda_memory_operand (rtx op, machine_mode mode, bool short_p)\n   /* Decode the address now.  */\n   addr = XEXP (op, 0);\n \n-  if (!LEGITIMATE_SMALL_DATA_ADDRESS_P (addr))\n+  if (!legitimate_small_data_address_p (addr))\n     return false;\n \n   if (!short_p || size == 1)\n     return true;\n \n   /* Now check for the alignment, the short loads using gp require the\n      addresses to be aligned.  */\n-  if (GET_CODE (XEXP (addr, 1)) == SYMBOL_REF)\n-    decl = SYMBOL_REF_DECL (XEXP (addr, 1));\n-  else if (GET_CODE (XEXP (XEXP (XEXP (addr, 1), 0), 0)) == SYMBOL_REF)\n-    decl = SYMBOL_REF_DECL (XEXP (XEXP (XEXP (addr, 1), 0), 0));\n-  if (decl)\n-    align = DECL_ALIGN (decl);\n-  align = align / BITS_PER_UNIT;\n-\n+  align = get_symbol_alignment (addr);\n   switch (mode)\n     {\n     case E_HImode:\n@@ -8581,11 +8511,6 @@ prepare_move_operands (rtx *operands, machine_mode mode)\n \t}\n     }\n \n-  /* We used to do this only for MODE_INT Modes, but addresses to floating\n-     point variables may well be in the small data section.  */\n-  if (!TARGET_NO_SDATA_SET && small_data_pattern (operands[0], Pmode))\n-    operands[0] = arc_rewrite_small_data (operands[0]);\n-\n   if (mode == SImode && SYMBOLIC_CONST (operands[1]))\n     {\n       prepare_pic_move (operands, SImode);\n@@ -8595,29 +8520,6 @@ prepare_move_operands (rtx *operands, machine_mode mode)\n \t here and references the variable directly.  */\n     }\n \n-  if (GET_CODE (operands[0]) != MEM\n-      && !TARGET_NO_SDATA_SET\n-      && small_data_pattern (operands[1], Pmode))\n-    {\n-      /* This is to take care of address calculations involving sdata\n-\t variables.  */\n-      operands[1] = arc_rewrite_small_data (operands[1]);\n-\n-      emit_insn (gen_rtx_SET (operands[0],operands[1]));\n-      /* ??? This note is useless, since it only restates the set itself.\n-\t We should rather use the original SYMBOL_REF.  However, there is\n-\t the problem that we are lying to the compiler about these\n-\t SYMBOL_REFs to start with.  symbol@sda should be encoded specially\n-\t so that we can tell it apart from an actual symbol.  */\n-      set_unique_reg_note (get_last_insn (), REG_EQUAL, operands[1]);\n-\n-      /* Take care of the REG_EQUAL note that will be attached to mark the\n-\t output reg equal to the initial symbol_ref after this code is\n-\t executed.  */\n-      emit_move_insn (operands[0], operands[0]);\n-      return true;\n-    }\n-\n   if (MEM_P (operands[0])\n       && !(reload_in_progress || reload_completed))\n     {\n@@ -8661,31 +8563,6 @@ prepare_move_operands (rtx *operands, machine_mode mode)\n   return false;\n }\n \n-/* Prepare OPERANDS for an extension using CODE to OMODE.\n-   Return true iff the move has been emitted.  */\n-\n-bool\n-prepare_extend_operands (rtx *operands, enum rtx_code code,\n-\t\t\t machine_mode omode)\n-{\n-  if (!TARGET_NO_SDATA_SET && small_data_pattern (operands[1], Pmode))\n-    {\n-      /* This is to take care of address calculations involving sdata\n-\t variables.  */\n-      operands[1]\n-\t= gen_rtx_fmt_e (code, omode, arc_rewrite_small_data (operands[1]));\n-      emit_insn (gen_rtx_SET (operands[0], operands[1]));\n-      set_unique_reg_note (get_last_insn (), REG_EQUAL, operands[1]);\n-\n-      /* Take care of the REG_EQUAL note that will be attached to mark the\n-\t output reg equal to the initial extension after this code is\n-\t executed.  */\n-      emit_move_insn (operands[0], operands[0]);\n-      return true;\n-    }\n-  return false;\n-}\n-\n /* Output a library call to a function called FNAME that has been arranged\n    to be local to any dso.  */\n "}, {"sha": "1a52e6f3859e3b4299e7ac583da3b45cb4b7b768", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0be3321b908443c46b69c888c53b3fddc4cf797/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0be3321b908443c46b69c888c53b3fddc4cf797/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=e0be3321b908443c46b69c888c53b3fddc4cf797", "patch": "@@ -1755,7 +1755,7 @@\n   [(set (match_operand:HI 0 \"dest_reg_operand\" \"\")\n \t(zero_extend:HI (match_operand:QI 1 \"nonvol_nonimm_operand\" \"\")))]\n   \"\"\n-  \"if (prepare_extend_operands (operands, ZERO_EXTEND, HImode)) DONE;\"\n+  \"\"\n )\n \n (define_insn \"*zero_extendqisi2_ac\"\n@@ -1779,7 +1779,7 @@\n   [(set (match_operand:SI 0 \"dest_reg_operand\" \"\")\n \t(zero_extend:SI (match_operand:QI 1 \"nonvol_nonimm_operand\" \"\")))]\n   \"\"\n-  \"if (prepare_extend_operands (operands, ZERO_EXTEND, SImode)) DONE;\"\n+  \"\"\n )\n \n (define_insn \"*zero_extendhisi2_i\"\n@@ -1804,7 +1804,7 @@\n   [(set (match_operand:SI 0 \"dest_reg_operand\" \"\")\n \t(zero_extend:SI (match_operand:HI 1 \"nonvol_nonimm_operand\" \"\")))]\n   \"\"\n-  \"if (prepare_extend_operands (operands, ZERO_EXTEND, SImode)) DONE;\"\n+  \"\"\n )\n \n ;; Sign extension instructions.\n@@ -1827,7 +1827,7 @@\n   [(set (match_operand:HI 0 \"dest_reg_operand\" \"\")\n \t(sign_extend:HI (match_operand:QI 1 \"nonvol_nonimm_operand\" \"\")))]\n   \"\"\n-  \"if (prepare_extend_operands (operands, SIGN_EXTEND, HImode)) DONE;\"\n+  \"\"\n )\n \n (define_insn \"*extendqisi2_ac\"\n@@ -1847,7 +1847,7 @@\n   [(set (match_operand:SI 0 \"dest_reg_operand\" \"\")\n \t(sign_extend:SI (match_operand:QI 1 \"nonvol_nonimm_operand\" \"\")))]\n   \"\"\n-  \"if (prepare_extend_operands (operands, SIGN_EXTEND, SImode)) DONE;\"\n+  \"\"\n )\n \n (define_insn \"*extendhisi2_i\"\n@@ -1868,7 +1868,7 @@\n   [(set (match_operand:SI 0 \"dest_reg_operand\" \"\")\n \t(sign_extend:SI (match_operand:HI 1 \"nonvol_nonimm_operand\" \"\")))]\n   \"\"\n-  \"if (prepare_extend_operands (operands, SIGN_EXTEND, SImode)) DONE;\"\n+  \"\"\n )\n \n ;; Unary arithmetic insns\n@@ -2761,11 +2761,6 @@\n      {\n        operands[2]=force_reg(SImode, operands[2]);\n      }\n-  else if (!TARGET_NO_SDATA_SET && small_data_pattern (operands[2], Pmode))\n-   {\n-      operands[2] = force_reg (SImode, arc_rewrite_small_data (operands[2]));\n-   }\n-\n   \")\n \n (define_expand \"adddi3\"\n@@ -2969,8 +2964,6 @@\n     }\n   if (flag_pic && arc_raw_symbolic_reference_mentioned_p (operands[c], false))\n     operands[c] = force_reg (SImode, operands[c]);\n-  else if (!TARGET_NO_SDATA_SET && small_data_pattern (operands[c], Pmode))\n-      operands[c] = force_reg (SImode, arc_rewrite_small_data (operands[c]));\n }\")\n \n ; the casesi expander might generate a sub of zero, so we have to recognize it.\n@@ -3326,8 +3319,7 @@\n   \"\"\n   \"if (!satisfies_constraint_Cux (operands[2]))\n      operands[1] = force_reg (SImode, operands[1]);\n-   else if (!TARGET_NO_SDATA_SET && small_data_pattern (operands[1], Pmode))\n-     operands[1] = arc_rewrite_small_data (operands[1]);\")\n+  \")\n \n (define_insn \"andsi3_i\"\n   [(set (match_operand:SI 0 \"dest_reg_operand\"          \"=Rcqq,Rcq,Rcqq,Rcqq,Rcqq,Rcw,Rcw,   Rcw,Rcw,Rcw,Rcw, w,     w,  w,  w,Rrq,w,Rcw,  w,W\")"}, {"sha": "90c736e1be48a0edce856bfa8d103044b8d824c0", "filename": "gcc/config/arc/constraints.md", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0be3321b908443c46b69c888c53b3fddc4cf797/gcc%2Fconfig%2Farc%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0be3321b908443c46b69c888c53b3fddc4cf797/gcc%2Fconfig%2Farc%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Fconstraints.md?ref=e0be3321b908443c46b69c888c53b3fddc4cf797", "patch": "@@ -347,11 +347,7 @@\n        (match_test \"!cmem_address (XEXP (op, 0), SImode)\")\n        (not (match_operand 0 \"long_immediate_loadstore_operand\"))))\n \n-; Don't use define_memory_constraint here as the relocation patching\n-; for small data symbols only works within a ld/st instruction and\n-; define_memory_constraint may result in the address being calculated\n-; into a register first.\n-(define_constraint \"Usd\"\n+(define_memory_constraint \"Usd\"\n    \"@internal\n     A valid _small-data_ memory operand for ARCompact instructions\"\n    (and (match_code \"mem\")"}, {"sha": "a274532f8158f34517677f3531292d75849dcccc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0be3321b908443c46b69c888c53b3fddc4cf797/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0be3321b908443c46b69c888c53b3fddc4cf797/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e0be3321b908443c46b69c888c53b3fddc4cf797", "patch": "@@ -1,3 +1,10 @@\n+2018-04-30  Claudiu Zissulescu  <claziss@synopsys.com>\n+\n+\t* gcc.target/arc/interrupt-8.c: Update test.\n+\t* gcc.target/arc/loop-4.c: Likewise.\n+\t* gcc.target/arc/loop-hazard-1.c: Likewise.\n+\t* gcc.target/arc/sdata-3.c: Likewise.\n+\n 2018-04-30  Claudiu Zissulescu  <claziss@synopsys.com>\n \n \t* gcc.target/arc/store-merge-1.c: New test."}, {"sha": "f2cc4c455696c8f9c49a6ee6486db8b78d0c0408", "filename": "gcc/testsuite/gcc.target/arc/interrupt-8.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0be3321b908443c46b69c888c53b3fddc4cf797/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0be3321b908443c46b69c888c53b3fddc4cf797/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-8.c?ref=e0be3321b908443c46b69c888c53b3fddc4cf797", "patch": "@@ -2,8 +2,7 @@\n /* { dg-skip-if \"Not available for ARCv1\" { arc700 || arc6xx } } */\n /* { dg-options \"-O2 -mirq-ctrl-saved=r0-r17\" } */\n \n-/* Check if the registers R0-R17 are automatically saved.  GP is saved\n-   by the compiler.  */\n+/* Check if the registers R0-R17 are automatically saved.  */\n \n int a;\n \n@@ -18,8 +17,6 @@ foo(void)\n /* { dg-final { scan-assembler-not \"st.*r14,\\\\\\[sp\" } } */\n /* { dg-final { scan-assembler-not \"st.*r15,\\\\\\[sp\" } } */\n /* { dg-final { scan-assembler-not \"st.*r16,\\\\\\[sp\" } } */\n-/* { dg-final { scan-assembler \"st.*gp,\\\\\\[sp,-4\\\\\\]\" } } */\n-/* { dg-final { scan-assembler \"ld.*gp,\\\\\\[sp\\\\\\]\" } } */\n /* { dg-final { scan-assembler-not \"st.*r0,\\\\\\[sp\" } } */\n /* { dg-final { scan-assembler-not \"st.*r1,\\\\\\[sp\" } } */\n /* { dg-final { scan-assembler-not \"st.*r2,\\\\\\[sp\" } } */"}, {"sha": "dbe5d3fe18fc53a24bd64c3e7d6a39797d2066dd", "filename": "gcc/testsuite/gcc.target/arc/loop-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0be3321b908443c46b69c888c53b3fddc4cf797/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Floop-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0be3321b908443c46b69c888c53b3fddc4cf797/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Floop-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Floop-4.c?ref=e0be3321b908443c46b69c888c53b3fddc4cf797", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do assemble } */\n /* { dg-do compile } */\n-/* { dg-options \"-Os\" } */\n+/* { dg-options \"-Os -fbranch-count-reg\" } */\n \n \n void fn1(void *p1, int p2, int p3)"}, {"sha": "83d5fd7e78d992cc03d91f76df24a5934a9b0732", "filename": "gcc/testsuite/gcc.target/arc/loop-hazard-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0be3321b908443c46b69c888c53b3fddc4cf797/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Floop-hazard-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0be3321b908443c46b69c888c53b3fddc4cf797/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Floop-hazard-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Floop-hazard-1.c?ref=e0be3321b908443c46b69c888c53b3fddc4cf797", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-Os\" } */\n+/* { dg-options \"-Os -fbranch-count-reg\" } */\n \n /* This caused an assertion within arc_loop_hazard.  */\n "}, {"sha": "4df707403fb1044c169a68db6e1a68157f7e92bc", "filename": "gcc/testsuite/gcc.target/arc/sdata-3.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0be3321b908443c46b69c888c53b3fddc4cf797/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fsdata-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0be3321b908443c46b69c888c53b3fddc4cf797/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fsdata-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fsdata-3.c?ref=e0be3321b908443c46b69c888c53b3fddc4cf797", "patch": "@@ -10,9 +10,13 @@ short g_c;\n char g_d;\n \n #define TEST(name, optype)\t\t\t\\\n-  void test_ ## name (optype x)\t\t\t\\\n+  optype testLD_ ## name (optype x)\t\t\\\n   {\t\t\t\t\t\t\\\n-    g_ ## name += x;\t\t\t\t\\\n+    return g_ ## name + x;\t\t\t\\\n+  }\t\t\t\t\t\t\\\n+  void testST_ ## name (optype x)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    g_ ## name = x;\t\t\t\t\\\n   }\n \n TEST (a, int)"}]}