{"sha": "37a893441ea2b3e8ac20cad5a1168ab0cd0d3c02", "node_id": "C_kwDOANBUbNoAKDM3YTg5MzQ0MWVhMmIzZThhYzIwY2FkNWExMTY4YWIwY2QwZDNjMDI", "commit": {"author": {"name": "Pierre-Emmanuel Patry", "email": "pierre-emmanuel.patry@embecosm.com", "date": "2023-05-10T09:34:45Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2023-05-17T16:13:45Z"}, "message": "libproc_macro: Change rust literal internals\n\nRust interface literal internals were taking a type and storing that\ntype. This lead to multiple problems such as various conversion from\nstring to int/float/other type as well as dead end on undetermined types\n(type checker runs at a later stage).\n\nChangeLog:\n\n\t* libgrust/libproc_macro/rust/bridge.rs: Add ffistring module.\n\t* libgrust/libproc_macro/rust/bridge/literal.rs: Rework type\n\tinternals.\n\t* libgrust/libproc_macro/rust/bridge/ffistring.rs: New file.\n\nSigned-off-by: Pierre-Emmanuel Patry <pierre-emmanuel.patry@embecosm.com>", "tree": {"sha": "e9247889df975266ef96bc0da4b298d41618d6c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9247889df975266ef96bc0da4b298d41618d6c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37a893441ea2b3e8ac20cad5a1168ab0cd0d3c02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37a893441ea2b3e8ac20cad5a1168ab0cd0d3c02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37a893441ea2b3e8ac20cad5a1168ab0cd0d3c02", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37a893441ea2b3e8ac20cad5a1168ab0cd0d3c02/comments", "author": {"login": "P-E-P", "id": 32375388, "node_id": "MDQ6VXNlcjMyMzc1Mzg4", "avatar_url": "https://avatars.githubusercontent.com/u/32375388?v=4", "gravatar_id": "", "url": "https://api.github.com/users/P-E-P", "html_url": "https://github.com/P-E-P", "followers_url": "https://api.github.com/users/P-E-P/followers", "following_url": "https://api.github.com/users/P-E-P/following{/other_user}", "gists_url": "https://api.github.com/users/P-E-P/gists{/gist_id}", "starred_url": "https://api.github.com/users/P-E-P/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/P-E-P/subscriptions", "organizations_url": "https://api.github.com/users/P-E-P/orgs", "repos_url": "https://api.github.com/users/P-E-P/repos", "events_url": "https://api.github.com/users/P-E-P/events{/privacy}", "received_events_url": "https://api.github.com/users/P-E-P/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cbcb74d71d402bfa20d1a7def6a0eea5e57d525", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cbcb74d71d402bfa20d1a7def6a0eea5e57d525", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cbcb74d71d402bfa20d1a7def6a0eea5e57d525"}], "stats": {"total": 532, "additions": 216, "deletions": 316}, "files": [{"sha": "3900ae1884b5dbd1a7afe68c921b0ab438cc7f18", "filename": "libgrust/libproc_macro/rust/bridge.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a893441ea2b3e8ac20cad5a1168ab0cd0d3c02/libgrust%2Flibproc_macro%2Frust%2Fbridge.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a893441ea2b3e8ac20cad5a1168ab0cd0d3c02/libgrust%2Flibproc_macro%2Frust%2Fbridge.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibproc_macro%2Frust%2Fbridge.rs?ref=37a893441ea2b3e8ac20cad5a1168ab0cd0d3c02", "patch": "@@ -1,3 +1,4 @@\n+pub mod ffistring;\n pub mod group;\n pub mod ident;\n pub mod literal;"}, {"sha": "0cdbf13851f70705beb45b758de10bcc9c4a59ae", "filename": "libgrust/libproc_macro/rust/bridge/ffistring.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a893441ea2b3e8ac20cad5a1168ab0cd0d3c02/libgrust%2Flibproc_macro%2Frust%2Fbridge%2Fffistring.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a893441ea2b3e8ac20cad5a1168ab0cd0d3c02/libgrust%2Flibproc_macro%2Frust%2Fbridge%2Fffistring.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibproc_macro%2Frust%2Fbridge%2Fffistring.rs?ref=37a893441ea2b3e8ac20cad5a1168ab0cd0d3c02", "patch": "@@ -0,0 +1,48 @@\n+use std::convert::TryInto;\n+use std::ffi::c_uchar;\n+use std::fmt;\n+use std::slice::from_raw_parts;\n+use std::str::from_utf8;\n+\n+extern \"C\" {\n+    fn FFIString__new(data: *const c_uchar, len: u64) -> FFIString;\n+    fn FFIString__drop(string: *mut FFIString);\n+}\n+\n+#[repr(C)]\n+#[derive(Debug)]\n+pub struct FFIString {\n+    data: *const c_uchar,\n+    len: u64,\n+}\n+\n+impl FFIString {\n+    pub fn new(string: &str) -> FFIString {\n+        unsafe { FFIString__new(string.as_ptr(), string.len() as u64) }\n+    }\n+}\n+\n+impl Clone for FFIString {\n+    fn clone(&self) -> Self {\n+        FFIString::new(&self.to_string())\n+    }\n+}\n+\n+impl Drop for FFIString {\n+    fn drop(&mut self) {\n+        unsafe {\n+            FFIString__drop(self as *mut FFIString);\n+        }\n+    }\n+}\n+\n+impl fmt::Display for FFIString {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(\n+            from_utf8(unsafe {\n+                from_raw_parts(self.data, self.len.try_into().map_err(|_| fmt::Error)?)\n+            })\n+            .map_err(|_| fmt::Error)?,\n+        )\n+    }\n+}"}, {"sha": "945311af88e515b586d5cd1ddc863d65a6d64529", "filename": "libgrust/libproc_macro/rust/bridge/literal.rs", "status": "modified", "additions": 167, "deletions": 316, "changes": 483, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a893441ea2b3e8ac20cad5a1168ab0cd0d3c02/libgrust%2Flibproc_macro%2Frust%2Fbridge%2Fliteral.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a893441ea2b3e8ac20cad5a1168ab0cd0d3c02/libgrust%2Flibproc_macro%2Frust%2Fbridge%2Fliteral.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibproc_macro%2Frust%2Fbridge%2Fliteral.rs?ref=37a893441ea2b3e8ac20cad5a1168ab0cd0d3c02", "patch": "@@ -1,220 +1,166 @@\n-use bridge::span::Span;\n-use std::convert::{TryFrom, TryInto};\n+use bridge::{ffistring::FFIString, span::Span};\n+use std::convert::TryInto;\n use std::ffi::c_uchar;\n use std::fmt;\n use std::str::FromStr;\n use LexError;\n \n extern \"C\" {\n-    fn Literal__drop(literal: *mut Literal);\n-    fn Literal__string(str: *const c_uchar, len: u64) -> Literal;\n-    fn Literal__byte_string(bytes: *const u8, len: u64) -> Literal;\n     fn Literal__from_string(str: *const c_uchar, len: u64, lit: *mut Literal) -> bool;\n }\n \n #[repr(C)]\n #[derive(Debug, Clone, Copy)]\n-pub enum Unsigned {\n-    Unsigned8(u8),\n-    Unsigned16(u16),\n-    Unsigned32(u32),\n-    Unsigned64(u64),\n-    // u128 is not ffi safe, hence this representation\n-    // https://github.com/rust-lang/rust/issues/54341\n-    Unsigned128(u64, u64),\n+pub enum LitKind {\n+    Byte,\n+    Char,\n+    Integer,\n+    Float,\n+    Str,\n+    StrRaw(u8),\n+    ByteStr,\n+    ByteStrRaw(u8),\n+    Err,\n }\n \n #[repr(C)]\n-#[derive(Debug, Clone, Copy)]\n-pub enum Signed {\n-    Signed8(i8),\n-    Signed16(i16),\n-    Signed32(i32),\n-    Signed64(i64),\n-    // i128 is not ffi safe, hence this representation\n-    // https://github.com/rust-lang/rust/issues/54341\n-    Signed128(u64, u64),\n+#[derive(Debug, Clone)]\n+pub struct Literal {\n+    kind: LitKind,\n+    text: FFIString,\n+    has_suffix: bool,\n+    suffix: FFIString,\n+    // FIXME: Add span, cannot add whilst Span remain an empty type\n }\n \n-#[repr(C)]\n-#[derive(Debug)]\n-pub enum Literal {\n-    /// String literal internal representation\n-    ///\n-    /// # Note\n-    /// This variant is constructed through FFI\n-    #[allow(dead_code)]\n-    String {\n-        data: *const c_uchar,\n-        len: u64,\n-    },\n-    /// Bytestring literal internal representation\n-    ///\n-    /// # Note\n-    /// This variant is constructed through FFI\n-    #[allow(dead_code)]\n-    ByteString {\n-        data: *const u8,\n-        size: u64,\n-    },\n-    Char(u32),\n-    Unsigned(Unsigned, bool),\n-    Signed(Signed, bool),\n-    Usize(u64, bool),\n-    ISize(i64, bool),\n-    Float32(f32, bool),\n-    Float64(f64, bool),\n+macro_rules! suffixed_int_literals {\n+    ($($name: ident => $kind: ident,)*) => ($(\n+        pub fn $name(n : $kind) -> Literal {\n+            Literal {\n+                kind : LitKind::Integer,\n+                text: FFIString::new(&n.to_string()),\n+                has_suffix : true,\n+                suffix: FFIString::new(stringify!($kind))\n+            }\n+        }\n+    )*)\n }\n \n-impl Literal {\n-    pub fn u8_suffixed(n: u8) -> Self {\n-        Literal::Unsigned(Unsigned::Unsigned8(n), true)\n-    }\n-\n-    pub fn u16_suffixed(n: u16) -> Self {\n-        Literal::Unsigned(Unsigned::Unsigned16(n), true)\n-    }\n-\n-    pub fn u32_suffixed(n: u32) -> Self {\n-        Literal::Unsigned(Unsigned::Unsigned32(n), true)\n-    }\n-\n-    pub fn u64_suffixed(n: u64) -> Self {\n-        Literal::Unsigned(Unsigned::Unsigned64(n), true)\n-    }\n-\n-    pub fn u128_suffixed(n: u128) -> Self {\n-        Literal::Unsigned(\n-            Unsigned::Unsigned128(\n-                (n >> 64).try_into().unwrap(),\n-                (n & 0xFFFFFFFFFFFFFFFF).try_into().unwrap(),\n-            ),\n-            true,\n-        )\n-    }\n-\n-    pub fn usize_suffixed(n: usize) -> Self {\n-        Literal::Usize(n.try_into().expect(\"Cannot convert usize to u64\"), true)\n-    }\n-\n-    pub fn i8_suffixed(n: i8) -> Self {\n-        Literal::Signed(Signed::Signed8(n), true)\n-    }\n-\n-    pub fn i16_suffixed(n: i16) -> Self {\n-        Literal::Signed(Signed::Signed16(n), true)\n-    }\n-\n-    pub fn i32_suffixed(n: i32) -> Self {\n-        Literal::Signed(Signed::Signed32(n), true)\n-    }\n-\n-    pub fn i64_suffixed(n: i64) -> Self {\n-        Literal::Signed(Signed::Signed64(n), true)\n-    }\n-\n-    pub fn i128_suffixed(n: i128) -> Self {\n-        Literal::Signed(\n-            Signed::Signed128(\n-                (n >> 64).try_into().unwrap(),\n-                (n & 0xFFFFFFFFFFFFFFFF).try_into().unwrap(),\n-            ),\n-            true,\n-        )\n-    }\n-\n-    pub fn isize_suffixed(n: isize) -> Self {\n-        Literal::ISize(n.try_into().expect(\"Cannot convert isize to i64\"), true)\n-    }\n-\n-    // Unsuffixed\n-\n-    pub fn u8_unsuffixed(n: u8) -> Self {\n-        Literal::Unsigned(Unsigned::Unsigned8(n), false)\n-    }\n-\n-    pub fn u16_unsuffixed(n: u16) -> Self {\n-        Literal::Unsigned(Unsigned::Unsigned16(n), false)\n-    }\n-\n-    pub fn u32_unsuffixed(n: u32) -> Self {\n-        Literal::Unsigned(Unsigned::Unsigned32(n), false)\n-    }\n-\n-    pub fn u64_unsuffixed(n: u64) -> Self {\n-        Literal::Unsigned(Unsigned::Unsigned64(n), false)\n-    }\n-\n-    pub fn u128_unsuffixed(n: u128) -> Self {\n-        Literal::Unsigned(\n-            Unsigned::Unsigned128(\n-                (n >> 64).try_into().unwrap(),\n-                (n & 0xFFFFFFFFFFFFFFFF).try_into().unwrap(),\n-            ),\n-            false,\n-        )\n-    }\n-\n-    pub fn usize_unsuffixed(n: usize) -> Self {\n-        Literal::Usize(n.try_into().expect(\"Cannot convert usize to u64\"), false)\n-    }\n-\n-    pub fn i8_unsuffixed(n: i8) -> Self {\n-        Literal::Signed(Signed::Signed8(n), false)\n-    }\n-\n-    pub fn i16_unsuffixed(n: i16) -> Self {\n-        Literal::Signed(Signed::Signed16(n), false)\n-    }\n-\n-    pub fn i32_unsuffixed(n: i32) -> Self {\n-        Literal::Signed(Signed::Signed32(n), false)\n-    }\n-\n-    pub fn i64_unsuffixed(n: i64) -> Self {\n-        Literal::Signed(Signed::Signed64(n), false)\n-    }\n-\n-    pub fn i128_unsuffixed(n: i128) -> Self {\n-        Literal::Signed(\n-            Signed::Signed128(\n-                (n >> 64).try_into().unwrap(),\n-                (n & 0xFFFFFFFFFFFFFFFF).try_into().unwrap(),\n-            ),\n-            false,\n-        )\n-    }\n+macro_rules! unsuffixed_int_literals {\n+    ($($name: ident => $kind: ident,)*) => ($(\n+        pub fn $name(n : $kind) -> Literal {\n+            Literal {\n+                kind : LitKind::Integer,\n+                text: FFIString::new(&n.to_string()),\n+                has_suffix : false,\n+                suffix: FFIString::new(\"\")\n+            }\n+        }\n+    )*)\n+}\n \n-    pub fn isize_unsuffixed(n: isize) -> Self {\n-        Literal::ISize(n.try_into().expect(\"Cannot convert isize to i64\"), false)\n+impl Literal {\n+    suffixed_int_literals! {\n+        u8_suffixed => u8,\n+        u16_suffixed => u16,\n+        u32_suffixed => u32,\n+        u64_suffixed => u64,\n+        u128_suffixed => u128,\n+        usize_suffixed => usize,\n+        i8_suffixed => i8,\n+        i16_suffixed => i16,\n+        i32_suffixed => i32,\n+        i64_suffixed => i64,\n+        i128_suffixed => i128,\n+        isize_suffixed => isize,\n+    }\n+\n+    unsuffixed_int_literals! {\n+        u8_unsuffixed => u8,\n+        u16_unsuffixed => u16,\n+        u32_unsuffixed => u32,\n+        u64_unsuffixed => u64,\n+        u128_unsuffixed => u128,\n+        usize_unsuffixed => usize,\n+        i8_unsuffixed => i8,\n+        i16_unsuffixed => i16,\n+        i32_unsuffixed => i32,\n+        i64_unsuffixed => i64,\n+        i128_unsuffixed => i128,\n+        isize_unsuffixed => isize,\n     }\n \n     pub fn f32_unsuffixed(n: f32) -> Self {\n-        Literal::Float32(n, false)\n+        let mut repr = n.to_string();\n+        if !repr.contains('.') {\n+            repr.push_str(\".0\");\n+        }\n+\n+        Literal {\n+            kind: LitKind::Float,\n+            text: FFIString::new(&repr),\n+            has_suffix: false,\n+            suffix: FFIString::new(\"\"),\n+        }\n     }\n \n     pub fn f32_suffixed(n: f32) -> Self {\n-        Literal::Float32(n, true)\n+        Literal {\n+            kind: LitKind::Float,\n+            text: FFIString::new(&n.to_string()),\n+            has_suffix: true,\n+            suffix: FFIString::new(\"f32\"),\n+        }\n     }\n \n     pub fn f64_unsuffixed(n: f64) -> Self {\n-        Literal::Float64(n, false)\n+        let mut repr = n.to_string();\n+        if !repr.contains('.') {\n+            repr.push_str(\".0\");\n+        }\n+\n+        Literal {\n+            kind: LitKind::Float,\n+            text: FFIString::new(&repr),\n+            has_suffix: false,\n+            suffix: FFIString::new(\"\"),\n+        }\n     }\n \n     pub fn f64_suffixed(n: f64) -> Self {\n-        Literal::Float64(n, true)\n+        Literal {\n+            kind: LitKind::Float,\n+            text: FFIString::new(&n.to_string()),\n+            has_suffix: true,\n+            suffix: FFIString::new(\"f64\"),\n+        }\n     }\n \n     pub fn string(string: &str) -> Self {\n-        unsafe { Literal__string(string.as_ptr(), string.len().try_into().unwrap()) }\n+        Literal {\n+            kind: LitKind::Str,\n+            text: FFIString::new(string),\n+            has_suffix: false,\n+            suffix: FFIString::new(\"\"),\n+        }\n     }\n \n     pub fn character(c: char) -> Self {\n-        Literal::Char(c.into())\n+        Literal {\n+            kind: LitKind::Char,\n+            text: FFIString::new(&c.to_string()),\n+            has_suffix: false,\n+            suffix: FFIString::new(\"\"),\n+        }\n     }\n \n     pub fn byte_string(bytes: &[u8]) -> Self {\n-        unsafe { Literal__byte_string(bytes.as_ptr(), bytes.len().try_into().unwrap()) }\n+        Literal {\n+            kind: LitKind::ByteStr,\n+            text: FFIString::new(&bytes.escape_ascii().to_string()),\n+            has_suffix: false,\n+            suffix: FFIString::new(\"\"),\n+        }\n     }\n \n     pub fn span(&self) -> Span {\n@@ -226,138 +172,53 @@ impl Literal {\n     }\n }\n \n-impl Drop for Literal {\n-    fn drop(&mut self) {\n-        match self {\n-            Literal::String { .. } | Literal::ByteString { .. } => unsafe {\n-                Literal__drop(self as *mut Literal)\n-            },\n-            _ => (),\n-        }\n-    }\n-}\n-\n impl fmt::Display for Literal {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            Literal::String { data, len } => {\n-                let slice =\n-                    unsafe { std::slice::from_raw_parts(*data, (*len).try_into().unwrap()) };\n-                f.write_str(\"\\\"\")?;\n-                f.write_str(std::str::from_utf8(slice).unwrap())?;\n-                f.write_str(\"\\\"\")?;\n+        let text = &self.text.to_string();\n+        match self.kind {\n+            LitKind::Byte => {\n+                f.write_str(\"b'\")?;\n+                f.write_str(text)?;\n+                f.write_str(\"'\")?;\n             }\n-            Literal::ByteString { data, size } => {\n-                f.write_str(\"b\\\"\")?;\n-                let slice =\n-                    unsafe { std::slice::from_raw_parts(*data, (*size).try_into().unwrap()) };\n-                for &byte in slice {\n-                    if byte != b'\"' && (b' '..=b'z').contains(&byte) {\n-                        char::try_from(byte).unwrap().fmt(f)?;\n-                    } else {\n-                        write!(f, \"\\\\x{:02x}\", byte)?;\n-                    }\n-                }\n-                f.write_str(\"b\\\"\")?;\n+            LitKind::Char => {\n+                f.write_str(\"'\")?;\n+                f.write_str(text)?;\n+                f.write_str(\"'\")?;\n             }\n-            Literal::Char(val) => {\n-                let ch: char = (*val).try_into().unwrap();\n-                match ch {\n-                    '\\'' => f.write_str(\"'\\\\''\")?,\n-                    '\\0' => f.write_str(\"'\\\\0'\")?,\n-                    '\\n' => f.write_str(\"'\\\\n'\")?,\n-                    ' '..='z' => write!(f, \"'{}'\", ch)?,\n-                    _ => write!(f, \"'\\\\u{:x}'\", val)?,\n-                }\n-            }\n-            Literal::Unsigned(val, suffixed) => match val {\n-                Unsigned::Unsigned8(val) => {\n-                    val.fmt(f)?;\n-                    if *suffixed {\n-                        f.write_str(\"u8\")?;\n-                    }\n-                }\n-                Unsigned::Unsigned16(val) => {\n-                    val.fmt(f)?;\n-                    if *suffixed {\n-                        f.write_str(\"u16\")?;\n-                    }\n-                }\n-                Unsigned::Unsigned32(val) => {\n-                    val.fmt(f)?;\n-                    if *suffixed {\n-                        f.write_str(\"u32\")?;\n-                    }\n-                }\n-                Unsigned::Unsigned64(val) => {\n-                    val.fmt(f)?;\n-                    if *suffixed {\n-                        f.write_str(\"u64\")?;\n-                    }\n-                }\n-                Unsigned::Unsigned128(h, l) => {\n-                    ((u128::from(*h) << 64) & u128::from(*l)).fmt(f)?;\n-                    if *suffixed {\n-                        f.write_str(\"u128\")?;\n-                    }\n-                }\n-            },\n-            Literal::Signed(val, suffixed) => match val {\n-                Signed::Signed8(val) => {\n-                    val.fmt(f)?;\n-                    if *suffixed {\n-                        f.write_str(\"i8\")?;\n-                    }\n-                }\n-                Signed::Signed16(val) => {\n-                    val.fmt(f)?;\n-                    if *suffixed {\n-                        f.write_str(\"i16\")?;\n-                    }\n-                }\n-                Signed::Signed32(val) => {\n-                    val.fmt(f)?;\n-                    if *suffixed {\n-                        f.write_str(\"i32\")?;\n-                    }\n-                }\n-                Signed::Signed64(val) => {\n-                    val.fmt(f)?;\n-                    if *suffixed {\n-                        f.write_str(\"i64\")?;\n-                    }\n-                }\n-                Signed::Signed128(h, l) => {\n-                    ((i128::from(*h) << 64) & i128::from(*l)).fmt(f)?;\n-                    if *suffixed {\n-                        f.write_str(\"i128\")?;\n-                    }\n-                }\n-            },\n-            Literal::Usize(val, suffixed) => {\n-                val.fmt(f)?;\n-                if *suffixed {\n-                    f.write_str(\"usize\")?;\n-                }\n+            LitKind::Str => {\n+                f.write_str(\"\\\"\")?;\n+                f.write_str(text)?;\n+                f.write_str(\"\\\"\")?;\n             }\n-            Literal::ISize(val, suffixed) => {\n-                val.fmt(f)?;\n-                if *suffixed {\n-                    f.write_str(\"isize\")?;\n+            LitKind::StrRaw(n) => {\n+                f.write_str(\"r\")?;\n+                for _ in 0..n {\n+                    f.write_str(\"#\")?;\n                 }\n+                f.write_str(\"\\\"\")?;\n+                f.write_str(text)?;\n+                f.write_str(\"\\\"\")?;\n             }\n-            Literal::Float32(val, suffixed) => {\n-                val.fmt(f)?;\n-                if *suffixed {\n-                    f.write_str(\"f32\")?;\n-                }\n+            LitKind::ByteStr => {\n+                f.write_str(\"b\\\"\")?;\n+                f.write_str(text)?;\n+                f.write_str(\"\\\"\")?;\n             }\n-            Literal::Float64(val, suffixed) => {\n-                val.fmt(f)?;\n-                if *suffixed {\n-                    f.write_str(\"f64\")?;\n+            LitKind::ByteStrRaw(n) => {\n+                f.write_str(\"br\")?;\n+                for _ in 0..n {\n+                    f.write_str(\"#\")?;\n                 }\n+                f.write_str(\"\\\"\")?;\n+                f.write_str(text)?;\n+                f.write_str(\"\\\"\")?;\n             }\n+            _ => f.write_str(text)?,\n+        }\n+\n+        if self.has_suffix {\n+            f.write_str(&self.suffix.to_string())?;\n         }\n         Ok(())\n     }\n@@ -367,7 +228,13 @@ impl FromStr for Literal {\n     type Err = LexError;\n \n     fn from_str(string: &str) -> Result<Self, LexError> {\n-        let mut lit = Literal::Char(0);\n+        // Structure that will be filled in by the cpp\n+        let mut lit = Literal {\n+            kind: LitKind::Err,\n+            text: FFIString::new(\"\"),\n+            has_suffix: false,\n+            suffix: FFIString::new(\"\"),\n+        };\n         // TODO: We might want to pass a LexError by reference to retrieve\n         // error information\n         if unsafe {\n@@ -383,19 +250,3 @@ impl FromStr for Literal {\n         }\n     }\n }\n-\n-impl Clone for Literal {\n-    fn clone(&self) -> Self {\n-        match self {\n-            Literal::String { data, len } => unsafe { Literal__string(*data, *len) },\n-            Literal::ByteString { data, size } => unsafe { Literal__byte_string(*data, *size) },\n-            Literal::Char(val) => Literal::Char(*val),\n-            Literal::Unsigned(val, suffixed) => Literal::Unsigned(*val, *suffixed),\n-            Literal::Signed(val, suffixed) => Literal::Signed(*val, *suffixed),\n-            Literal::Usize(val, suffixed) => Literal::Usize(*val, *suffixed),\n-            Literal::ISize(val, suffixed) => Literal::ISize(*val, *suffixed),\n-            Literal::Float32(val, suffixed) => Literal::Float32(*val, *suffixed),\n-            Literal::Float64(val, suffixed) => Literal::Float64(*val, *suffixed),\n-        }\n-    }\n-}"}]}