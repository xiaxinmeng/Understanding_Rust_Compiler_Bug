{"sha": "d5bf81b30f7d3faf58d52784013749ca0f9f980f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDViZjgxYjMwZjdkM2ZhZjU4ZDUyNzg0MDEzNzQ5Y2EwZjlmOTgwZg==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2017-08-08T16:48:46Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2017-08-08T16:48:46Z"}, "message": "re PR target/81708 (The x86 stack canary location should be customizable)\n\n\tPR target/81708\n\t* config/i386/i386.opt (mstack-protector-guard-reg=): New option\n\t(mstack-protector-guard-offset=): Ditto.\n\t* config/i386/i386.c (ix86_option_override): Handle\n\t-mstack-protector-guard-reg= and -mstack-protector-guard-offset=\n\toptions.\n\t(ix86_stack_protect_guard): Use ix86_stack_protect_guard_reg and\n\tix86_stack_protect_guard_offset variables.\n\t(TARGET_STACK_PROTECT_GUARD): Always define.\n\t* doc/invoke.texi (x86 Options): Document -mstack-protector-guard-reg=\n\tand -mstack-protector-guard-offset= options.\n\ntestsuite/ChangeLog:\n\n\tPR target/81708\n\t* gcc.target/i386/stack-prot-guard.c: New test.\n\nFrom-SVN: r250965", "tree": {"sha": "b5449885acc699eefc6d35b3d55189c4e773106b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5449885acc699eefc6d35b3d55189c4e773106b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5bf81b30f7d3faf58d52784013749ca0f9f980f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5bf81b30f7d3faf58d52784013749ca0f9f980f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5bf81b30f7d3faf58d52784013749ca0f9f980f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5bf81b30f7d3faf58d52784013749ca0f9f980f/comments", "author": null, "committer": null, "parents": [{"sha": "7d27b70bd861d6b83a6821e3fb4205e19a365310", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d27b70bd861d6b83a6821e3fb4205e19a365310", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d27b70bd861d6b83a6821e3fb4205e19a365310"}], "stats": {"total": 141, "additions": 123, "deletions": 18}, "files": [{"sha": "321861a6d8c633978b56f381b90c31abfff54c22", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5bf81b30f7d3faf58d52784013749ca0f9f980f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5bf81b30f7d3faf58d52784013749ca0f9f980f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d5bf81b30f7d3faf58d52784013749ca0f9f980f", "patch": "@@ -1,3 +1,17 @@\n+2017-08-08  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/81708\n+\t* config/i386/i386.opt (mstack-protector-guard-reg=): New option\n+\t(mstack-protector-guard-offset=): Ditto.\n+\t* config/i386/i386.c (ix86_option_override): Handle\n+\t-mstack-protector-guard-reg= and -mstack-protector-guard-offset=\n+\toptions.\n+\t(ix86_stack_protect_guard): Use ix86_stack_protect_guard_reg and\n+\tix86_stack_protect_guard_offset variables.\n+\t(TARGET_STACK_PROTECT_GUARD): Always define.\n+\t* doc/invoke.texi (x86 Options): Document -mstack-protector-guard-reg=\n+\tand -mstack-protector-guard-offset= options.\n+\n 2017-08-08  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-ssa-loop-ivopts.c (relate_compare_use_with_all_cands): Handle\n@@ -25,7 +39,8 @@\n \t* optabs.def (xorsign_optab): New.\n \t* tree-ssa-math-opts.c (is_copysign_call_with_1): New.\n \t(convert_expand_mult_copysign): New.\n-\t(pass_optimize_widening_mul::execute): Call convert_expand_mult_copysign.\n+\t(pass_optimize_widening_mul::execute): Call\n+\tconvert_expand_mult_copysign.\n \n 2017-08-08  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n@@ -212,7 +227,7 @@\n \t(vsx_set_<mode>, VSX_D): Rewrite vector set in terms of vector\n \tconcat to allow optimizing inserts from previous extracts.\n \n-2017-08-06  Uros Bizjak  <ubizjak@gmail.com>\n+2017-08-07  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.c (ix86_stack_protect_guard): Generate\n \tmemory reference to a SSP offset in TLS address space."}, {"sha": "3f8519777f7c5eb6e0daf61534efadc373fe711f", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 66, "deletions": 14, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5bf81b30f7d3faf58d52784013749ca0f9f980f/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5bf81b30f7d3faf58d52784013749ca0f9f980f/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d5bf81b30f7d3faf58d52784013749ca0f9f980f", "patch": "@@ -6662,6 +6662,69 @@ ix86_option_override_internal (bool main_args_p,\n     opts->x_ix86_stack_protector_guard\n       = TARGET_HAS_BIONIC ? SSP_GLOBAL : SSP_TLS;\n \n+#ifdef TARGET_THREAD_SSP_OFFSET\n+  ix86_stack_protector_guard_offset = TARGET_THREAD_SSP_OFFSET;\n+#endif\n+\n+  if (global_options_set.x_ix86_stack_protector_guard_offset_str)\n+    {\n+      char *endp;\n+      const char *str = ix86_stack_protector_guard_offset_str;\n+\n+      errno = 0;\n+      int64_t offset;\n+\n+#if defined(INT64_T_IS_LONG)\n+      offset = strtol (str, &endp, 0);\n+#else\n+      offset = strtoll (str, &endp, 0);\n+#endif\n+\n+      if (!*str || *endp || errno)\n+\terror (\"%qs is not a valid number \"\n+\t       \"in -mstack-protector-guard-offset=\", str);\n+\n+      if (!IN_RANGE (offset, HOST_WIDE_INT_C (-0x80000000),\n+\t\t     HOST_WIDE_INT_C (0x7fffffff)))\n+\terror (\"%qs is not a valid offset \"\n+\t       \"in -mstack-protector-guard-offset=\", str);\n+\n+      ix86_stack_protector_guard_offset = offset;\n+    }\n+\n+  ix86_stack_protector_guard_reg = DEFAULT_TLS_SEG_REG;\n+\n+  /* The kernel uses a different segment register for performance\n+     reasons; a system call would not have to trash the userspace\n+     segment register, which would be expensive.  */\n+  if (ix86_cmodel == CM_KERNEL)\n+    ix86_stack_protector_guard_reg = ADDR_SPACE_SEG_GS;\n+\n+  if (global_options_set.x_ix86_stack_protector_guard_reg_str)\n+    {\n+      const char *str = ix86_stack_protector_guard_reg_str;\n+      addr_space_t seg = ADDR_SPACE_GENERIC;\n+\n+      /* Discard optional register prefix.  */\n+      if (str[0] == '%')\n+\tstr++;\n+\n+      if (strlen (str) == 2 && str[1] == 's')\n+\t{\n+\t  if (str[0] == 'f')\n+\t    seg = ADDR_SPACE_SEG_FS;\n+\t  else if (str[0] == 'g')\n+\t    seg = ADDR_SPACE_SEG_GS;\n+\t}\n+\n+      if (seg == ADDR_SPACE_GENERIC)\n+\terror (\"%qs is not a valid base register \"\n+\t       \"in -mstack-protector-guard-reg=\",\n+\t       ix86_stack_protector_guard_reg_str);\n+\n+      ix86_stack_protector_guard_reg = seg;\n+    }\n+\n   /* Handle -mmemcpy-strategy= and -mmemset-strategy=  */\n   if (opts->x_ix86_tune_memcpy_strategy)\n     {\n@@ -45795,35 +45858,26 @@ ix86_mangle_type (const_tree type)\n     }\n }\n \n-#ifdef TARGET_THREAD_SSP_OFFSET\n static tree\n ix86_stack_protect_guard (void)\n {\n   if (TARGET_SSP_TLS_GUARD)\n     {\n       tree type_node = lang_hooks.types.type_for_mode (ptr_mode, 1);\n-      addr_space_t as = DEFAULT_TLS_SEG_REG;\n \n-      /* The kernel uses a different segment register for performance\n-\t reasons; a system call would not have to trash the userspace\n-\t segment register, which would be expensive.  */\n-      if (ix86_cmodel == CM_KERNEL)\n-\tas = ADDR_SPACE_SEG_GS;\n-\n-      int qual = ENCODE_QUAL_ADDR_SPACE (as);\n+      int qual = ENCODE_QUAL_ADDR_SPACE (ix86_stack_protector_guard_reg);\n \n       tree type = build_qualified_type (type_node, qual);\n       tree asptrtype = build_pointer_type (type);\n-      tree sspoff = build_int_cst (asptrtype, TARGET_THREAD_SSP_OFFSET);\n-\n+      tree sspoff = build_int_cst (asptrtype,\n+\t\t\t\t   ix86_stack_protector_guard_offset);\n       tree t = build2 (MEM_REF, asptrtype, sspoff,\n \t\t       build_int_cst (asptrtype, 0));\n       return t;\n     }\n \n   return default_stack_protect_guard ();\n }\n-#endif\n \n /* For 32-bit code we can save PIC register setup by using\n    __stack_chk_fail_local hidden function instead of calling\n@@ -52831,10 +52885,8 @@ ix86_run_selftests (void)\n #undef TARGET_MANGLE_TYPE\n #define TARGET_MANGLE_TYPE ix86_mangle_type\n \n-#ifdef TARGET_THREAD_SSP_OFFSET\n #undef TARGET_STACK_PROTECT_GUARD\n #define TARGET_STACK_PROTECT_GUARD ix86_stack_protect_guard\n-#endif\n \n #if !TARGET_MACHO\n #undef TARGET_STACK_PROTECT_FAIL"}, {"sha": "72f2422b6d075fc370ad7fca887c64dece64e9f2", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5bf81b30f7d3faf58d52784013749ca0f9f980f/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5bf81b30f7d3faf58d52784013749ca0f9f980f/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=d5bf81b30f7d3faf58d52784013749ca0f9f980f", "patch": "@@ -924,6 +924,20 @@ Enum(stack_protector_guard) String(tls) Value(SSP_TLS)\n EnumValue\n Enum(stack_protector_guard) String(global) Value(SSP_GLOBAL)\n \n+mstack-protector-guard-reg=\n+Target RejectNegative Joined Var(ix86_stack_protector_guard_reg_str)\n+Use the given base register for addressing the stack-protector guard.\n+\n+TargetVariable\n+addr_space_t ix86_stack_protector_guard_reg = ADDR_SPACE_GENERIC\n+\n+mstack-protector-guard-offset=\n+Target RejectNegative Joined Integer Var(ix86_stack_protector_guard_offset_str)\n+Use the given offset for addressing the stack-protector guard.\n+\n+TargetVariable\n+HOST_WIDE_INT ix86_stack_protector_guard_offset = 0\n+\n mmitigate-rop\n Target Var(flag_mitigate_rop) Init(0)\n Attempt to avoid generating instruction sequences containing ret bytes."}, {"sha": "cc0f5a00a4f25a43b11ef297a39554cfcf869c48", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5bf81b30f7d3faf58d52784013749ca0f9f980f/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5bf81b30f7d3faf58d52784013749ca0f9f980f/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d5bf81b30f7d3faf58d52784013749ca0f9f980f", "patch": "@@ -1215,7 +1215,9 @@ See RS/6000 and PowerPC Options.\n -msse2avx  -mfentry  -mrecord-mcount  -mnop-mcount  -m8bit-idiv @gol\n -mavx256-split-unaligned-load  -mavx256-split-unaligned-store @gol\n -malign-data=@var{type}  -mstack-protector-guard=@var{guard} @gol\n--mmitigate-rop  -mgeneral-regs-only  -mcall-ms2sysv-xlogues}\n+-mstack-protector-guard-reg=@var{reg} @gol\n+-mstack-protector-guard-offset=@var{offset}  -mmitigate-rop @gol\n+-mgeneral-regs-only  -mcall-ms2sysv-xlogues}\n \n @emph{x86 Windows Options}\n @gccoptlist{-mconsole  -mcygwin  -mno-cygwin  -mdll @gol\n@@ -26147,12 +26149,23 @@ to 255, 8-bit unsigned integer divide is used instead of\n Split 32-byte AVX unaligned load and store.\n \n @item -mstack-protector-guard=@var{guard}\n-@opindex mstack-protector-guard=@var{guard}\n+@itemx -mstack-protector-guard-reg=@var{reg}\n+@itemx -mstack-protector-guard-offset=@var{offset}\n+@opindex mstack-protector-guard\n+@opindex mstack-protector-guard-reg\n+@opindex mstack-protector-guard-offset\n Generate stack protection code using canary at @var{guard}.  Supported\n locations are @samp{global} for global canary or @samp{tls} for per-thread\n canary in the TLS block (the default).  This option has effect only when\n @option{-fstack-protector} or @option{-fstack-protector-all} is specified.\n \n+With the latter choice the options\n+@option{-mstack-protector-guard-reg=@var{reg}} and\n+@option{-mstack-protector-guard-offset=@var{offset}} furthermore specify\n+which segment register (@code{%fs} or @code{%gs}) to use as base register\n+for reading the canary, and from what offset from that base register.\n+The default for those is as specified in the relevant ABI.\n+\n @item -mmitigate-rop\n @opindex mmitigate-rop\n Try to avoid generating code sequences that contain unintended return"}, {"sha": "2ec22e8fdca4b4c525d36544c7ae305bd50db17b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5bf81b30f7d3faf58d52784013749ca0f9f980f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5bf81b30f7d3faf58d52784013749ca0f9f980f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d5bf81b30f7d3faf58d52784013749ca0f9f980f", "patch": "@@ -1,3 +1,8 @@\n+2017-08-08  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/81708\n+\t* gcc.target/i386/stack-prot-guard.c: New test.\n+\n 2017-08-08  Tamar Christina  <tamar.christina@arm.com>\n \n \t* gcc.target/aarch64/xorsign.c: New."}, {"sha": "120ef3cf5c189c715dffcc5fdfdb2ca2f071ba12", "filename": "gcc/testsuite/gcc.target/i386/stack-prot-guard.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5bf81b30f7d3faf58d52784013749ca0f9f980f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fstack-prot-guard.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5bf81b30f7d3faf58d52784013749ca0f9f980f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fstack-prot-guard.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fstack-prot-guard.c?ref=d5bf81b30f7d3faf58d52784013749ca0f9f980f", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-protector-all -mstack-protector-guard=tls -mstack-protector-guard-reg=gs -mstack-protector-guard-offset=0x3038\" } */\n+\n+void f(void) { }\n+\n+/* { dg-final { scan-assembler \"gs:12344\" } } */"}]}