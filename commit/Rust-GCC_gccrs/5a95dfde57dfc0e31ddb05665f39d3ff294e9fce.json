{"sha": "5a95dfde57dfc0e31ddb05665f39d3ff294e9fce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWE5NWRmZGU1N2RmYzBlMzFkZGIwNTY2NWYzOWQzZmYyOTRlOWZjZQ==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargls@comcast.net", "date": "2005-02-27T17:32:26Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2005-02-27T17:32:26Z"}, "message": "arith.c (gfc_check_real_range): Remove multiple returns\n\n* arith.c (gfc_check_real_range):  Remove multiple returns\n  (check_result): New function.\n  (gfc_arith_uminus,gfc_arith_plus,gfc_arith_times,\n  gfc_arith_divide,gfc_arith_power,gfc_arith_minus): Use it.\n\nFrom-SVN: r95624", "tree": {"sha": "6c09d914d9cba7f26679428c447183fd7d3355d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c09d914d9cba7f26679428c447183fd7d3355d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a95dfde57dfc0e31ddb05665f39d3ff294e9fce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a95dfde57dfc0e31ddb05665f39d3ff294e9fce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a95dfde57dfc0e31ddb05665f39d3ff294e9fce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a95dfde57dfc0e31ddb05665f39d3ff294e9fce/comments", "author": null, "committer": null, "parents": [{"sha": "5591e5f9af6f09455a1f11d8e822785e34647186", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5591e5f9af6f09455a1f11d8e822785e34647186", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5591e5f9af6f09455a1f11d8e822785e34647186"}], "stats": {"total": 167, "additions": 43, "deletions": 124}, "files": [{"sha": "f5c23a3903f8fc8b941e1e311321c841c59e0ca6", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a95dfde57dfc0e31ddb05665f39d3ff294e9fce/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a95dfde57dfc0e31ddb05665f39d3ff294e9fce/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5a95dfde57dfc0e31ddb05665f39d3ff294e9fce", "patch": "@@ -1,3 +1,11 @@\n+2005-02-27  Steven G. Kargl  <kargls@comcast.net>\n+\n+\t* arith.c (gfc_check_real_range):  Remove multiple returns\n+\t(check_result): New function.\n+\t(gfc_arith_uminus,gfc_arith_plus,gfc_arith_times,\n+\tgfc_arith_divide,gfc_arith_power,gfc_arith_minus): Use it.\n+\n+\n 2005-02-24  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \t* decl.c, resolve.c, trans-array.c, trans.h: Fix comment typo(s)."}, {"sha": "9bcfa0a007d0625a060bc66e5af5d7018d9e8241", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 35, "deletions": 124, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a95dfde57dfc0e31ddb05665f39d3ff294e9fce/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a95dfde57dfc0e31ddb05665f39d3ff294e9fce/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=5a95dfde57dfc0e31ddb05665f39d3ff294e9fce", "patch": "@@ -373,20 +373,15 @@ gfc_check_real_range (mpfr_t p, int kind)\n   mpfr_init (q);\n   mpfr_abs (q, p, GFC_RND_MODE);\n \n-  retval = ARITH_OK;\n   if (mpfr_sgn (q) == 0)\n-    goto done;\n-\n-  if (mpfr_cmp (q, gfc_real_kinds[i].huge) > 0)\n-    {\n+    retval = ARITH_OK;\n+  else if (mpfr_cmp (q, gfc_real_kinds[i].huge) > 0)\n       retval = ARITH_OVERFLOW;\n-      goto done;\n-    }\n-\n-  if (mpfr_cmp (q, gfc_real_kinds[i].tiny) < 0)\n+  else if (mpfr_cmp (q, gfc_real_kinds[i].tiny) < 0)\n     retval = ARITH_UNDERFLOW;\n+  else\n+    retval = ARITH_OK;\n \n-done:\n   mpfr_clear (q);\n \n   return retval;\n@@ -554,6 +549,30 @@ gfc_range_check (gfc_expr * e)\n }\n \n \n+/* Several of the following routines use the same set of statements to\n+   check the validity of the result.  Encapsulate the checking here.  */\n+\n+static arith\n+check_result (arith rc, gfc_expr * x, gfc_expr * r, gfc_expr ** rp)\n+{\n+  if (rc != ARITH_OK)\n+    gfc_free_expr (r);\n+  else\n+    {\n+      if (rc == ARITH_UNDERFLOW && gfc_option.warn_underflow)\n+        gfc_warning (\"%s at %L\", gfc_arith_error (rc), &x->where);\n+\n+      if (rc == ARITH_ASYMMETRIC)\n+\tgfc_warning (\"%s at %L\", gfc_arith_error (rc), &x->where);\n+\n+      rc = ARITH_OK;\n+      *rp = r;\n+    }\n+\n+  return rc;\n+}\n+\n+\n /* It may seem silly to have a subroutine that actually computes the\n    unary plus of a constant, but it prevents us from making exceptions\n    in the code elsewhere.  */\n@@ -595,25 +614,7 @@ gfc_arith_uminus (gfc_expr * op1, gfc_expr ** resultp)\n \n   rc = gfc_range_check (result);\n \n-  if (rc == ARITH_UNDERFLOW)\n-    {\n-      if (gfc_option.warn_underflow)\n-        gfc_warning (\"%s at %L\", gfc_arith_error (rc), &op1->where);\n-      rc = ARITH_OK;\n-      *resultp = result;\n-    }\n-  else if (rc == ARITH_ASYMMETRIC)\n-    {\n-      gfc_warning (\"%s at %L\", gfc_arith_error (rc), &op1->where);\n-      rc = ARITH_OK;\n-      *resultp = result;\n-    }\n-  else if (rc != ARITH_OK)\n-    gfc_free_expr (result);\n-  else\n-    *resultp = result;\n-\n-  return rc;\n+  return check_result (rc, op1, result, resultp);\n }\n \n \n@@ -650,25 +651,7 @@ gfc_arith_plus (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n \n   rc = gfc_range_check (result);\n \n-  if (rc == ARITH_UNDERFLOW)\n-    {\n-      if (gfc_option.warn_underflow)\n-        gfc_warning (\"%s at %L\", gfc_arith_error (rc), &op1->where);\n-      rc = ARITH_OK;\n-      *resultp = result;\n-    }\n-  else if (rc == ARITH_ASYMMETRIC)\n-    {\n-      gfc_warning (\"%s at %L\", gfc_arith_error (rc), &op1->where);\n-      rc = ARITH_OK;\n-      *resultp = result;\n-    }\n-  else if (rc != ARITH_OK)\n-    gfc_free_expr (result);\n-  else\n-    *resultp = result;\n-\n-  return rc;\n+  return check_result (rc, op1, result, resultp);\n }\n \n \n@@ -705,25 +688,7 @@ gfc_arith_minus (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n \n   rc = gfc_range_check (result);\n \n-  if (rc == ARITH_UNDERFLOW)\n-    {\n-      if (gfc_option.warn_underflow)\n-        gfc_warning (\"%s at %L\", gfc_arith_error (rc), &op1->where);\n-      rc = ARITH_OK;\n-      *resultp = result;\n-    }\n-  else if (rc == ARITH_ASYMMETRIC)\n-    {\n-      gfc_warning (\"%s at %L\", gfc_arith_error (rc), &op1->where);\n-      rc = ARITH_OK;\n-      *resultp = result;\n-    }\n-  else if (rc != ARITH_OK)\n-    gfc_free_expr (result);\n-  else\n-    *resultp = result;\n-\n-  return rc;\n+  return check_result (rc, op1, result, resultp);\n }\n \n \n@@ -774,25 +739,7 @@ gfc_arith_times (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n \n   rc = gfc_range_check (result);\n \n-  if (rc == ARITH_UNDERFLOW)\n-    {\n-      if (gfc_option.warn_underflow)\n-        gfc_warning (\"%s at %L\", gfc_arith_error (rc), &op1->where);\n-      rc = ARITH_OK;\n-      *resultp = result;\n-    }\n-  else if (rc == ARITH_ASYMMETRIC)\n-    {\n-      gfc_warning (\"%s at %L\", gfc_arith_error (rc), &op1->where);\n-      rc = ARITH_OK;\n-      *resultp = result;\n-    }\n-  else if (rc != ARITH_OK)\n-    gfc_free_expr (result);\n-  else\n-    *resultp = result;\n-\n-  return rc;\n+  return check_result (rc, op1, result, resultp);\n }\n \n \n@@ -876,25 +823,7 @@ gfc_arith_divide (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n   if (rc == ARITH_OK)\n     rc = gfc_range_check (result);\n \n-  if (rc == ARITH_UNDERFLOW)\n-    {\n-      if (gfc_option.warn_underflow)\n-        gfc_warning (\"%s at %L\", gfc_arith_error (rc), &op1->where);\n-      rc = ARITH_OK;\n-      *resultp = result;\n-    }\n-  else if (rc == ARITH_ASYMMETRIC)\n-    {\n-      gfc_warning (\"%s at %L\", gfc_arith_error (rc), &op1->where);\n-      rc = ARITH_OK;\n-      *resultp = result;\n-    }\n-  else if (rc != ARITH_OK)\n-    gfc_free_expr (result);\n-  else\n-    *resultp = result;\n-\n-  return rc;\n+  return check_result (rc, op1, result, resultp);\n }\n \n \n@@ -1072,25 +1001,7 @@ gfc_arith_power (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n   if (rc == ARITH_OK)\n     rc = gfc_range_check (result);\n \n-  if (rc == ARITH_UNDERFLOW)\n-    {\n-      if (gfc_option.warn_underflow)\n-        gfc_warning (\"%s at %L\", gfc_arith_error (rc), &op1->where);\n-      rc = ARITH_OK;\n-      *resultp = result;\n-    }\n-  else if (rc == ARITH_ASYMMETRIC)\n-    {\n-      gfc_warning (\"%s at %L\", gfc_arith_error (rc), &op1->where);\n-      rc = ARITH_OK;\n-      *resultp = result;\n-    }\n-  else if (rc != ARITH_OK)\n-    gfc_free_expr (result);\n-  else\n-    *resultp = result;\n-\n-  return rc;\n+  return check_result (rc, op1, result, resultp);\n }\n \n "}]}