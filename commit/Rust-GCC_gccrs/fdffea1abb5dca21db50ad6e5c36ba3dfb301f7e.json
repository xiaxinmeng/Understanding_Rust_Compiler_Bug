{"sha": "fdffea1abb5dca21db50ad6e5c36ba3dfb301f7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRmZmVhMWFiYjVkY2EyMWRiNTBhZDZlNWMzNmJhM2RmYjMwMWY3ZQ==", "commit": {"author": {"name": "Stephane Carrez", "email": "Stephane.Carrez@worldnet.fr", "date": "2002-03-15T21:54:58Z"}, "committer": {"name": "Stephane Carrez", "email": "ciceron@gcc.gnu.org", "date": "2002-03-15T21:54:58Z"}, "message": "m68hc11.c (m68hc11_small_indexed_indirect_p): Look for reg_equiv_memory_loc when the operand is a register that does not get...\n\n\t* config/m68hc11/m68hc11.c (m68hc11_small_indexed_indirect_p): Look\n\tfor reg_equiv_memory_loc when the operand is a register that does\n\tnot get a hard register (stack location).\n\t(tst_operand): After reload, accept all memory operand.\n\t(symbolic_memory_operand): Fix detection of symbolic references.\n\t* config/m68hc11/m68hc11.h (VALID_CONSTANT_OFFSET_P): For 68HC12\n\taccept symbols and any constant.\n\nFrom-SVN: r50839", "tree": {"sha": "3cb8c1eb2e01fed535dc48f0e6142f2aaaee1a3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3cb8c1eb2e01fed535dc48f0e6142f2aaaee1a3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fdffea1abb5dca21db50ad6e5c36ba3dfb301f7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdffea1abb5dca21db50ad6e5c36ba3dfb301f7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdffea1abb5dca21db50ad6e5c36ba3dfb301f7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdffea1abb5dca21db50ad6e5c36ba3dfb301f7e/comments", "author": null, "committer": null, "parents": [{"sha": "6272bc6859f211cf4cc9b8b02f56a87a0c381834", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6272bc6859f211cf4cc9b8b02f56a87a0c381834", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6272bc6859f211cf4cc9b8b02f56a87a0c381834"}], "stats": {"total": 42, "additions": 35, "deletions": 7}, "files": [{"sha": "a3619d8ce6d3839ffbd2be488c8a809abfae9d42", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdffea1abb5dca21db50ad6e5c36ba3dfb301f7e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdffea1abb5dca21db50ad6e5c36ba3dfb301f7e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fdffea1abb5dca21db50ad6e5c36ba3dfb301f7e", "patch": "@@ -1,3 +1,13 @@\n+2002-03-15  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n+\n+\t* config/m68hc11/m68hc11.c (m68hc11_small_indexed_indirect_p): Look\n+\tfor reg_equiv_memory_loc when the operand is a register that does\n+\tnot get a hard register (stack location).\n+\t(tst_operand): After reload, accept all memory operand.\n+\t(symbolic_memory_operand): Fix detection of symbolic references.\n+\t* config/m68hc11/m68hc11.h (VALID_CONSTANT_OFFSET_P): For 68HC12\n+\taccept symbols and any constant.\n+\n 2002-03-15  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n \n \t* config/m68hc11/m68hc11.c (emit_move_after_reload): Add a REG_INC"}, {"sha": "bcaeae6166457c9851ebd2ec9e3b35c711e29d9c", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdffea1abb5dca21db50ad6e5c36ba3dfb301f7e/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdffea1abb5dca21db50ad6e5c36ba3dfb301f7e/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=fdffea1abb5dca21db50ad6e5c36ba3dfb301f7e", "patch": "@@ -551,6 +551,14 @@ m68hc11_small_indexed_indirect_p (operand, mode)\n {\n   rtx base, offset;\n \n+  if (GET_CODE (operand) == REG && reload_in_progress\n+      && REGNO (operand) >= FIRST_PSEUDO_REGISTER\n+      && reg_equiv_memory_loc[REGNO (operand)])\n+    {\n+      operand = reg_equiv_memory_loc[REGNO (operand)];\n+      operand = eliminate_regs (operand, 0, NULL_RTX);\n+    }\n+\n   if (GET_CODE (operand) != MEM)\n     return 0;\n \n@@ -561,15 +569,20 @@ m68hc11_small_indexed_indirect_p (operand, mode)\n   if (PUSH_POP_ADDRESS_P (operand))\n     return 1;\n \n-  if (!register_indirect_p (operand, mode,\n-                            (reload_completed | reload_in_progress)))\n+  if (!register_indirect_p (operand, mode, reload_completed))\n     return 0;\n \n   if (TARGET_M6812 && GET_CODE (operand) == PLUS\n       && (reload_completed | reload_in_progress))\n     {\n       base = XEXP (operand, 0);\n       offset = XEXP (operand, 1);\n+\n+      /* The offset can be a symbol address and this is too big\n+         for the operand constraint.  */\n+      if (GET_CODE (base) != CONST_INT && GET_CODE (offset) != CONST_INT)\n+        return 0;\n+\n       if (GET_CODE (base) == CONST_INT)\n \toffset = base;\n \n@@ -853,7 +866,7 @@ tst_operand (operand, mode)\n      rtx operand;\n      enum machine_mode mode;\n {\n-  if (GET_CODE (operand) == MEM)\n+  if (GET_CODE (operand) == MEM && reload_completed == 0)\n     {\n       rtx addr = XEXP (operand, 0);\n       if (m68hc11_auto_inc_p (addr))\n@@ -1010,6 +1023,7 @@ symbolic_memory_operand (op, mode)\n       return 1;\n \n     case CONST:\n+      op = XEXP (op, 0);\n       return ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n \t       || GET_CODE (XEXP (op, 0)) == LABEL_REF)\n \t      && GET_CODE (XEXP (op, 1)) == CONST_INT);"}, {"sha": "ee2a805b2efc16f957d51d92af03f0f7918541a4", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdffea1abb5dca21db50ad6e5c36ba3dfb301f7e/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdffea1abb5dca21db50ad6e5c36ba3dfb301f7e/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=fdffea1abb5dca21db50ad6e5c36ba3dfb301f7e", "patch": "@@ -1275,10 +1275,14 @@ extern unsigned char m68hc11_reg_valid_for_index[FIRST_PSEUDO_REGISTER];\n    a mode offset to access the lowest part of the data.\n    (For example, for an SImode, the last valid offset is 252.) */\n #define VALID_CONSTANT_OFFSET_P(X,MODE)\t\t\\\n-((GET_CODE (X) == CONST_INT) &&\t\t\t\\\n- ((INTVAL (X) >= VALID_MIN_OFFSET)\t\t\\\n-    && ((INTVAL (X) <= VALID_MAX_OFFSET\t\t\\\n-\t\t- (HOST_WIDE_INT) (GET_MODE_SIZE (MODE) + 1)))))\n+(((GET_CODE (X) == CONST_INT) &&\t\t\t\\\n+  ((INTVAL (X) >= VALID_MIN_OFFSET)\t\t\\\n+     && ((INTVAL (X) <= VALID_MAX_OFFSET\t\t\\\n+\t\t- (HOST_WIDE_INT) (GET_MODE_SIZE (MODE) + 1))))) \\\n+|| (TARGET_M6812 \\\n+    && ((GET_CODE (X) == SYMBOL_REF) \\\n+        || GET_CODE (X) == LABEL_REF \\\n+        || GET_CODE (X) == CONST)))\n \n /* This is included to allow stack push/pop operations. Special hacks in the\n    md and m6811.c files exist to support this.  */"}]}