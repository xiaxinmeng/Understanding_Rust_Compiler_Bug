{"sha": "e45425ecf8afa3ce7cbae97f267538c7d1e5650c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQ1NDI1ZWNmOGFmYTNjZTdjYmFlOTdmMjY3NTM4YzdkMWU1NjUwYw==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2011-03-28T20:58:52Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2011-03-28T20:58:52Z"}, "message": "Makefile.in: New rule for cprop.o.\n\n\t* Makefile.in: New rule for cprop.o.\n\t* gcse.c: Move constant/copy propagation to cprop.c.\n\t(compute_local_properties): Only handle expression tables.\n\t(hash_scan_set, compute_hash_table_work, alloc_hash_table,): Likewise.\n\t(one_pre_gcse_pass, one_code_hoisting_pass): Likewise.\n\t(hash_set, insert_set_in_table, gcse_constant_p, lookup_set,\n\tnext_set, reset_opr_set_tables, oprs_not_set_p, mark_call, mark_set,\n\tmark_clobber, mark_oprs_set, alloc_cprop_mem, free_cprop_mem, \n\tcompute_cprop_data, find_used_regs, try_replace_reg,\n\tfind_avail_set, cprop_jump, constprop_register, cprop_insn,\n\tlocal_cprop_find_used_regs, do_local_cprop, local_cprop_pass,\n\tfis_get_condition, implicit_set_cond_p, find_implicit_sets,\n\tfind_bypass_set, reg_killed_on_edge, bypass_block,\n\tbypass_conditional_jumps, one_cprop_pass, gate_rtl_cprop,\n\texecute_rtl_cprop, pass_rtl_cprop): Move to...\n\t* cprop.c: ...here.  New file, constant/copy propagation for RTL\n\tmoved from gcse.c to here with minor cleanups in duplicated code.\n\nFrom-SVN: r171627", "tree": {"sha": "6f47c3387c97e980bc4b9066f2c80a5e5cff351e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f47c3387c97e980bc4b9066f2c80a5e5cff351e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e45425ecf8afa3ce7cbae97f267538c7d1e5650c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e45425ecf8afa3ce7cbae97f267538c7d1e5650c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e45425ecf8afa3ce7cbae97f267538c7d1e5650c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e45425ecf8afa3ce7cbae97f267538c7d1e5650c/comments", "author": null, "committer": null, "parents": [{"sha": "c09d54269fe4fb15dc24fc89690f7f180a374af5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c09d54269fe4fb15dc24fc89690f7f180a374af5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c09d54269fe4fb15dc24fc89690f7f180a374af5"}], "stats": {"total": 4084, "additions": 2335, "deletions": 1749}, "files": [{"sha": "23e3da5cc11b94c18f991432dd91908a68a48169", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e45425ecf8afa3ce7cbae97f267538c7d1e5650c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e45425ecf8afa3ce7cbae97f267538c7d1e5650c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e45425ecf8afa3ce7cbae97f267538c7d1e5650c", "patch": "@@ -1,3 +1,23 @@\n+2011-03-28  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* Makefile.in: New rule for cprop.o.\n+\t* gcse.c: Move constant/copy propagation to cprop.c.\n+\t(compute_local_properties): Only handle expression tables.\n+\t(hash_scan_set, compute_hash_table_work, alloc_hash_table,): Likewise.\n+\t(one_pre_gcse_pass, one_code_hoisting_pass): Likewise.\n+\t(hash_set, insert_set_in_table, gcse_constant_p, lookup_set,\n+\tnext_set, reset_opr_set_tables, oprs_not_set_p, mark_call, mark_set,\n+\tmark_clobber, mark_oprs_set, alloc_cprop_mem, free_cprop_mem, \n+\tcompute_cprop_data, find_used_regs, try_replace_reg,\n+\tfind_avail_set, cprop_jump, constprop_register, cprop_insn,\n+\tlocal_cprop_find_used_regs, do_local_cprop, local_cprop_pass,\n+\tfis_get_condition, implicit_set_cond_p, find_implicit_sets,\n+\tfind_bypass_set, reg_killed_on_edge, bypass_block,\n+\tbypass_conditional_jumps, one_cprop_pass, gate_rtl_cprop,\n+\texecute_rtl_cprop, pass_rtl_cprop): Move to...\n+\t* cprop.c: ...here.  New file, constant/copy propagation for RTL\n+\tmoved from gcse.c to here with minor cleanups in duplicated code.\n+\n 2011-03-28  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config/i386/i386.c (flag_opts): Fix a typo in"}, {"sha": "65e042a76b658c395e3dbb2319f8e009c92bf504", "filename": "gcc/Makefile.in", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e45425ecf8afa3ce7cbae97f267538c7d1e5650c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e45425ecf8afa3ce7cbae97f267538c7d1e5650c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=e45425ecf8afa3ce7cbae97f267538c7d1e5650c", "patch": "@@ -1206,6 +1206,7 @@ OBJS-common = \\\n \tcompare-elim.o \\\n \tconvert.o \\\n \tcoverage.o \\\n+\tcprop.o \\\n \tcse.o \\\n \tcselib.o \\\n \tdbxout.o \\\n@@ -3068,6 +3069,12 @@ implicit-zee.o : implicit-zee.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RT\n    $(DF_H) $(TIMEVAR_H) tree-pass.h $(RECOG_H) $(EXPR_H) \\\n    $(REGS_H) $(TREE_H) $(TM_P_H) insn-config.h $(INSN_ATTR_H) $(DIAGNOSTIC_CORE_H) \\\n    $(TARGET_H) $(OPTABS_H) insn-codes.h rtlhooks-def.h $(PARAMS_H) $(CGRAPH_H)\n+cprop.o : cprop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n+   $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h $(GGC_H) \\\n+   $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) $(FUNCTION_H) output.h toplev.h $(DIAGNOSTIC_CORE_H) \\\n+   $(TM_P_H) $(PARAMS_H) cselib.h $(EXCEPT_H) $(TREE_H) $(TIMEVAR_H) \\\n+   intl.h $(OBSTACK_H) $(TREE_PASS_H) $(DF_H) $(DBGCNT_H) $(TARGET_H) \\\n+   $(DF_H)\n gcse.o : gcse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h $(GGC_H) \\\n    $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) $(FUNCTION_H) output.h toplev.h $(DIAGNOSTIC_CORE_H) \\"}, {"sha": "7e035af86e27d444bfb5580ac4e03b05e73b3e79", "filename": "gcc/cprop.c", "status": "added", "additions": 2168, "deletions": 0, "changes": 2168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e45425ecf8afa3ce7cbae97f267538c7d1e5650c/gcc%2Fcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e45425ecf8afa3ce7cbae97f267538c7d1e5650c/gcc%2Fcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcprop.c?ref=e45425ecf8afa3ce7cbae97f267538c7d1e5650c", "patch": "@@ -0,0 +1,2168 @@\n+/* Global constant/copy propagation for RTL.\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,\n+   2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"diagnostic-core.h\"\n+#include \"toplev.h\"\n+\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"tm_p.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"flags.h\"\n+#include \"insn-config.h\"\n+#include \"recog.h\"\n+#include \"basic-block.h\"\n+#include \"output.h\"\n+#include \"function.h\"\n+#include \"expr.h\"\n+#include \"except.h\"\n+#include \"params.h\"\n+#include \"cselib.h\"\n+#include \"intl.h\"\n+#include \"obstack.h\"\n+#include \"timevar.h\"\n+#include \"tree-pass.h\"\n+#include \"hashtab.h\"\n+#include \"df.h\"\n+#include \"dbgcnt.h\"\n+#include \"target.h\"\n+\n+\f\n+/* An obstack for our working variables.  */\n+static struct obstack gcse_obstack;\n+\n+struct reg_use {rtx reg_rtx; };\n+\n+/* Hash table of expressions.  */\n+\n+struct expr\n+{\n+  /* The expression (SET_SRC for expressions, PATTERN for assignments).  */\n+  rtx expr;\n+  /* Index in the available expression bitmaps.  */\n+  int bitmap_index;\n+  /* Next entry with the same hash.  */\n+  struct expr *next_same_hash;\n+  /* List of available occurrence in basic blocks in the function.\n+     An \"available occurrence\" is one that is the last occurrence in the\n+     basic block and the operands are not modified by following statements in\n+     the basic block [including this insn].  */\n+  struct occr *avail_occr;\n+};\n+\n+/* Occurrence of an expression.\n+   There is one per basic block.  If a pattern appears more than once the\n+   last appearance is used.  */\n+\n+struct occr\n+{\n+  /* Next occurrence of this expression.  */\n+  struct occr *next;\n+  /* The insn that computes the expression.  */\n+  rtx insn;\n+};\n+\n+typedef struct occr *occr_t;\n+DEF_VEC_P (occr_t);\n+DEF_VEC_ALLOC_P (occr_t, heap);\n+\n+/* Expression and copy propagation hash tables.\n+   Each hash table is an array of buckets.\n+   ??? It is known that if it were an array of entries, structure elements\n+   `next_same_hash' and `bitmap_index' wouldn't be necessary.  However, it is\n+   not clear whether in the final analysis a sufficient amount of memory would\n+   be saved as the size of the available expression bitmaps would be larger\n+   [one could build a mapping table without holes afterwards though].\n+   Someday I'll perform the computation and figure it out.  */\n+\n+struct hash_table_d\n+{\n+  /* The table itself.\n+     This is an array of `set_hash_table_size' elements.  */\n+  struct expr **table;\n+\n+  /* Size of the hash table, in elements.  */\n+  unsigned int size;\n+\n+  /* Number of hash table elements.  */\n+  unsigned int n_elems;\n+};\n+\n+/* Copy propagation hash table.  */\n+static struct hash_table_d set_hash_table;\n+\n+/* Array of implicit set patterns indexed by basic block index.  */\n+static rtx *implicit_sets;\n+\n+/* Bitmap containing one bit for each register in the program.\n+   Used when performing GCSE to track which registers have been set since\n+   the start of the basic block.  */\n+static regset reg_set_bitmap;\n+\n+/* Various variables for statistics gathering.  */\n+\n+/* Memory used in a pass.\n+   This isn't intended to be absolutely precise.  Its intent is only\n+   to keep an eye on memory usage.  */\n+static int bytes_used;\n+\n+/* Number of local constants propagated.  */\n+static int local_const_prop_count;\n+/* Number of local copies propagated.  */\n+static int local_copy_prop_count;\n+/* Number of global constants propagated.  */\n+static int global_const_prop_count;\n+/* Number of global copies propagated.  */\n+static int global_copy_prop_count;\n+\f\n+\n+#define GNEW(T)\t\t\t((T *) gmalloc (sizeof (T)))\n+\n+#define GNEWVEC(T, N)\t\t((T *) gmalloc (sizeof (T) * (N)))\n+\n+#define GNEWVAR(T, S)\t\t((T *) gmalloc ((S)))\n+\n+#define GOBNEW(T)\t\t((T *) gcse_alloc (sizeof (T)))\n+#define GOBNEWVAR(T, S)\t\t((T *) gcse_alloc ((S)))\n+\f\n+/* Cover function to xmalloc to record bytes allocated.  */\n+\n+static void *\n+gmalloc (size_t size)\n+{\n+  bytes_used += size;\n+  return xmalloc (size);\n+}\n+\n+/* Cover function to obstack_alloc.  */\n+\n+static void *\n+gcse_alloc (unsigned long size)\n+{\n+  bytes_used += size;\n+  return obstack_alloc (&gcse_obstack, size);\n+}\n+\n+/* Allocate memory for the reg/memory set tracking tables.\n+   This is called at the start of each pass.  */\n+\n+static void\n+alloc_gcse_mem (void)\n+{\n+  /* Allocate vars to track sets of regs.  */\n+  reg_set_bitmap = ALLOC_REG_SET (NULL);\n+}\n+\n+/* Free memory allocated by alloc_gcse_mem.  */\n+\n+static void\n+free_gcse_mem (void)\n+{\n+  FREE_REG_SET (reg_set_bitmap);\n+}\n+\f\n+struct reg_avail_info\n+{\n+  basic_block last_bb;\n+  int last_set;\n+};\n+\n+static struct reg_avail_info *reg_avail_info;\n+static basic_block current_bb;\n+\n+/* Return nonzero if the operands of expression X are unchanged from\n+   INSN to the end of INSN's basic block.  */\n+\n+static int\n+oprs_available_p (const_rtx x, const_rtx insn)\n+{\n+  int i, j;\n+  enum rtx_code code;\n+  const char *fmt;\n+\n+  if (x == 0)\n+    return 1;\n+\n+  code = GET_CODE (x);\n+  switch (code)\n+    {\n+    case REG:\n+      {\n+\tstruct reg_avail_info *info = &reg_avail_info[REGNO (x)];\n+\n+\tif (info->last_bb != current_bb)\n+\t  return 1;\n+\treturn info->last_set < DF_INSN_LUID (insn);\n+      }\n+\n+    case PRE_DEC:\n+    case PRE_INC:\n+    case POST_DEC:\n+    case POST_INC:\n+    case PRE_MODIFY:\n+    case POST_MODIFY:\n+      return 0;\n+\n+    case PC:\n+    case CC0: /*FIXME*/\n+    case CONST:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case CONST_FIXED:\n+    case CONST_VECTOR:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+    case ADDR_VEC:\n+    case ADDR_DIFF_VEC:\n+      return 1;\n+\n+    default:\n+      break;\n+    }\n+\n+  for (i = GET_RTX_LENGTH (code) - 1, fmt = GET_RTX_FORMAT (code); i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  if (! oprs_available_p (XEXP (x, i), insn))\n+\t    return 0;\n+\t}\n+      else if (fmt[i] == 'E')\n+\tfor (j = 0; j < XVECLEN (x, i); j++)\n+\t  if (! oprs_available_p (XVECEXP (x, i, j), insn))\n+\t    return 0;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Hash a set of register REGNO.\n+\n+   Sets are hashed on the register that is set.  This simplifies the PRE copy\n+   propagation code.\n+\n+   ??? May need to make things more elaborate.  Later, as necessary.  */\n+\n+static unsigned int\n+hash_set (int regno, int hash_table_size)\n+{\n+  unsigned int hash;\n+\n+  hash = regno;\n+  return hash % hash_table_size;\n+}\n+\n+/* Return nonzero if exp1 is equivalent to exp2.  */\n+\n+static int\n+expr_equiv_p (const_rtx x, const_rtx y)\n+{\n+  return exp_equiv_p (x, y, 0, true);\n+}\n+\n+/* Insert pattern X in INSN in the hash table.\n+   X is a SET of a reg to either another reg or a constant.\n+   If it is already present, record it as the last occurrence in INSN's\n+   basic block.  */\n+\n+static void\n+insert_set_in_table (rtx x, rtx insn, struct hash_table_d *table)\n+{\n+  int found;\n+  unsigned int hash;\n+  struct expr *cur_expr, *last_expr = NULL;\n+  struct occr *cur_occr;\n+\n+  gcc_assert (GET_CODE (x) == SET && REG_P (SET_DEST (x)));\n+\n+  hash = hash_set (REGNO (SET_DEST (x)), table->size);\n+\n+  cur_expr = table->table[hash];\n+  found = 0;\n+\n+  while (cur_expr && 0 == (found = expr_equiv_p (cur_expr->expr, x)))\n+    {\n+      /* If the expression isn't found, save a pointer to the end of\n+\t the list.  */\n+      last_expr = cur_expr;\n+      cur_expr = cur_expr->next_same_hash;\n+    }\n+\n+  if (! found)\n+    {\n+      cur_expr = GOBNEW (struct expr);\n+      bytes_used += sizeof (struct expr);\n+      if (table->table[hash] == NULL)\n+\t/* This is the first pattern that hashed to this index.  */\n+\ttable->table[hash] = cur_expr;\n+      else\n+\t/* Add EXPR to end of this hash chain.  */\n+\tlast_expr->next_same_hash = cur_expr;\n+\n+      /* Set the fields of the expr element.\n+\t We must copy X because it can be modified when copy propagation is\n+\t performed on its operands.  */\n+      cur_expr->expr = copy_rtx (x);\n+      cur_expr->bitmap_index = table->n_elems++;\n+      cur_expr->next_same_hash = NULL;\n+      cur_expr->avail_occr = NULL;\n+    }\n+\n+  /* Now record the occurrence.  */\n+  cur_occr = cur_expr->avail_occr;\n+\n+  if (cur_occr\n+      && BLOCK_FOR_INSN (cur_occr->insn) == BLOCK_FOR_INSN (insn))\n+    {\n+      /* Found another instance of the expression in the same basic block.\n+\t Prefer this occurrence to the currently recorded one.  We want\n+\t the last one in the block and the block is scanned from start\n+\t to end.  */\n+      cur_occr->insn = insn;\n+    }\n+  else\n+    {\n+      /* First occurrence of this expression in this basic block.  */\n+      cur_occr = GOBNEW (struct occr);\n+      bytes_used += sizeof (struct occr);\n+      cur_occr->insn = insn;\n+      cur_occr->next = cur_expr->avail_occr;\n+      cur_expr->avail_occr = cur_occr;\n+    }\n+}\n+\n+/* Determine whether the rtx X should be treated as a constant for\n+   the purposes of GCSE's constant propagation.  */\n+\n+static bool\n+gcse_constant_p (const_rtx x)\n+{\n+  /* Consider a COMPARE of two integers constant.  */\n+  if (GET_CODE (x) == COMPARE\n+      && CONST_INT_P (XEXP (x, 0))\n+      && CONST_INT_P (XEXP (x, 1)))\n+    return true;\n+\n+  /* Consider a COMPARE of the same registers is a constant\n+     if they are not floating point registers.  */\n+  if (GET_CODE(x) == COMPARE\n+      && REG_P (XEXP (x, 0)) && REG_P (XEXP (x, 1))\n+      && REGNO (XEXP (x, 0)) == REGNO (XEXP (x, 1))\n+      && ! FLOAT_MODE_P (GET_MODE (XEXP (x, 0)))\n+      && ! FLOAT_MODE_P (GET_MODE (XEXP (x, 1))))\n+    return true;\n+\n+  /* Since X might be inserted more than once we have to take care that it\n+     is sharable.  */\n+  return CONSTANT_P (x) && (GET_CODE (x) != CONST || shared_const_p (x));\n+}\n+\n+/* Scan pattern PAT of INSN and add an entry to the hash TABLE (set or\n+   expression one).  */\n+\n+static void\n+hash_scan_set (rtx pat, rtx insn, struct hash_table_d *table)\n+{\n+  rtx src = SET_SRC (pat);\n+  rtx dest = SET_DEST (pat);\n+  rtx note;\n+\n+  if (REG_P (dest))\n+    {\n+      unsigned int regno = REGNO (dest);\n+      rtx tmp;\n+\n+      /* See if a REG_EQUAL note shows this equivalent to a simpler expression.\n+\n+\t This allows us to do a single GCSE pass and still eliminate\n+\t redundant constants, addresses or other expressions that are\n+\t constructed with multiple instructions.\n+\n+\t However, keep the original SRC if INSN is a simple reg-reg move.  In\n+\t In this case, there will almost always be a REG_EQUAL note on the\n+\t insn that sets SRC.  By recording the REG_EQUAL value here as SRC\n+\t for INSN, we miss copy propagation opportunities and we perform the\n+\t same PRE GCSE operation repeatedly on the same REG_EQUAL value if we\n+\t do more than one PRE GCSE pass.\n+\n+\t Note that this does not impede profitable constant propagations.  We\n+\t \"look through\" reg-reg sets in lookup_avail_set.  */\n+      note = find_reg_equal_equiv_note (insn);\n+      if (note != 0\n+\t  && REG_NOTE_KIND (note) == REG_EQUAL\n+\t  && !REG_P (src)\n+\t  && gcse_constant_p (XEXP (note, 0)))\n+\tsrc = XEXP (note, 0), pat = gen_rtx_SET (VOIDmode, dest, src);\n+\n+      /* Record sets for constant/copy propagation.  */\n+      if (regno >= FIRST_PSEUDO_REGISTER\n+\t  && ((REG_P (src)\n+\t       && REGNO (src) >= FIRST_PSEUDO_REGISTER\n+\t       && can_copy_p (GET_MODE (dest))\n+\t       && REGNO (src) != regno)\n+\t      || gcse_constant_p (src))\n+\t  /* A copy is not available if its src or dest is subsequently\n+\t     modified.  Here we want to search from INSN+1 on, but\n+\t     oprs_available_p searches from INSN on.  */\n+\t  && (insn == BB_END (BLOCK_FOR_INSN (insn))\n+\t      || (tmp = next_nonnote_nondebug_insn (insn)) == NULL_RTX\n+\t      || BLOCK_FOR_INSN (tmp) != BLOCK_FOR_INSN (insn)\n+\t      || oprs_available_p (pat, tmp)))\n+\tinsert_set_in_table (pat, insn, table);\n+    }\n+}\n+\n+/* Process INSN and add hash table entries as appropriate.\n+\n+   Only available expressions that set a single pseudo-reg are recorded.\n+\n+   Single sets in a PARALLEL could be handled, but it's an extra complication\n+   that isn't dealt with right now.  The trick is handling the CLOBBERs that\n+   are also in the PARALLEL.  Later.\n+\n+   If SET_P is nonzero, this is for the assignment hash table,\n+   otherwise it is for the expression hash table.  */\n+\n+static void\n+hash_scan_insn (rtx insn, struct hash_table_d *table)\n+{\n+  rtx pat = PATTERN (insn);\n+  int i;\n+\n+  /* Pick out the sets of INSN and for other forms of instructions record\n+     what's been modified.  */\n+\n+  if (GET_CODE (pat) == SET)\n+    hash_scan_set (pat, insn, table);\n+  else if (GET_CODE (pat) == PARALLEL)\n+    for (i = 0; i < XVECLEN (pat, 0); i++)\n+      {\n+\trtx x = XVECEXP (pat, 0, i);\n+\n+\tif (GET_CODE (x) == SET)\n+\t  hash_scan_set (x, insn, table);\n+      }\n+}\n+\n+static void\n+dump_hash_table (FILE *file, const char *name, struct hash_table_d *table)\n+{\n+  int i;\n+  /* Flattened out table, so it's printed in proper order.  */\n+  struct expr **flat_table;\n+  unsigned int *hash_val;\n+  struct expr *expr;\n+\n+  flat_table = XCNEWVEC (struct expr *, table->n_elems);\n+  hash_val = XNEWVEC (unsigned int, table->n_elems);\n+\n+  for (i = 0; i < (int) table->size; i++)\n+    for (expr = table->table[i]; expr != NULL; expr = expr->next_same_hash)\n+      {\n+\tflat_table[expr->bitmap_index] = expr;\n+\thash_val[expr->bitmap_index] = i;\n+      }\n+\n+  fprintf (file, \"%s hash table (%d buckets, %d entries)\\n\",\n+\t   name, table->size, table->n_elems);\n+\n+  for (i = 0; i < (int) table->n_elems; i++)\n+    if (flat_table[i] != 0)\n+      {\n+\texpr = flat_table[i];\n+\tfprintf (file, \"Index %d (hash value %d)\\n  \",\n+\t\t expr->bitmap_index, hash_val[i]);\n+\tprint_rtl (file, expr->expr);\n+\tfprintf (file, \"\\n\");\n+      }\n+\n+  fprintf (file, \"\\n\");\n+\n+  free (flat_table);\n+  free (hash_val);\n+}\n+\n+/* Record register first/last/block set information for REGNO in INSN.\n+\n+   last_set records the last place in the block where the register\n+   is set and is used to compute \"availability\".\n+\n+   last_bb records the block for which last_set is valid, as a quick\n+   test to invalidate it.  */\n+\n+static void\n+record_last_reg_set_info (rtx insn, int regno)\n+{\n+  struct reg_avail_info *info = &reg_avail_info[regno];\n+  int luid = DF_INSN_LUID (insn);\n+\n+  info->last_set = luid;\n+  if (info->last_bb != current_bb)\n+    info->last_bb = current_bb;\n+}\n+\n+/* Called from compute_hash_table via note_stores to handle one\n+   SET or CLOBBER in an insn.  DATA is really the instruction in which\n+   the SET is taking place.  */\n+\n+static void\n+record_last_set_info (rtx dest, const_rtx setter ATTRIBUTE_UNUSED, void *data)\n+{\n+  rtx last_set_insn = (rtx) data;\n+\n+  if (GET_CODE (dest) == SUBREG)\n+    dest = SUBREG_REG (dest);\n+\n+  if (REG_P (dest))\n+    record_last_reg_set_info (last_set_insn, REGNO (dest));\n+}\n+\n+/* Top level function to create an assignments hash table.\n+\n+   Assignment entries are placed in the hash table if\n+   - they are of the form (set (pseudo-reg) src),\n+   - src is something we want to perform const/copy propagation on,\n+   - none of the operands or target are subsequently modified in the block\n+\n+   Currently src must be a pseudo-reg or a const_int.\n+\n+   TABLE is the table computed.  */\n+\n+static void\n+compute_hash_table_work (struct hash_table_d *table)\n+{\n+  int i;\n+\n+  /* Some working arrays used to track first and last set in each block.  */\n+  reg_avail_info = GNEWVEC (struct reg_avail_info, max_reg_num ());\n+\n+  for (i = 0; i < max_reg_num (); ++i)\n+    reg_avail_info[i].last_bb = NULL;\n+\n+  FOR_EACH_BB (current_bb)\n+    {\n+      rtx insn;\n+      unsigned int regno;\n+\n+      /* First pass over the instructions records information used to\n+\t determine when registers and memory are first and last set.  */\n+      FOR_BB_INSNS (current_bb, insn)\n+\t{\n+\t  if (!NONDEBUG_INSN_P (insn))\n+\t    continue;\n+\n+\t  if (CALL_P (insn))\n+\t    {\n+\t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\t\tif (TEST_HARD_REG_BIT (regs_invalidated_by_call, regno))\n+\t\t  record_last_reg_set_info (insn, regno);\n+\t    }\n+\n+\t  note_stores (PATTERN (insn), record_last_set_info, insn);\n+\t}\n+\n+      /* Insert implicit sets in the hash table.  */\n+      if (implicit_sets[current_bb->index] != NULL_RTX)\n+\thash_scan_set (implicit_sets[current_bb->index],\n+\t\t       BB_HEAD (current_bb), table);\n+\n+      /* The next pass builds the hash table.  */\n+      FOR_BB_INSNS (current_bb, insn)\n+\tif (NONDEBUG_INSN_P (insn))\n+\t  hash_scan_insn (insn, table);\n+    }\n+\n+  free (reg_avail_info);\n+  reg_avail_info = NULL;\n+}\n+\n+/* Allocate space for the set/expr hash TABLE.\n+   It is used to determine the number of buckets to use.  */\n+\n+static void\n+alloc_hash_table (struct hash_table_d *table)\n+{\n+  int n;\n+\n+  n = get_max_insn_count ();\n+\n+  table->size = n / 4;\n+  if (table->size < 11)\n+    table->size = 11;\n+\n+  /* Attempt to maintain efficient use of hash table.\n+     Making it an odd number is simplest for now.\n+     ??? Later take some measurements.  */\n+  table->size |= 1;\n+  n = table->size * sizeof (struct expr *);\n+  table->table = GNEWVAR (struct expr *, n);\n+}\n+\n+/* Free things allocated by alloc_hash_table.  */\n+\n+static void\n+free_hash_table (struct hash_table_d *table)\n+{\n+  free (table->table);\n+}\n+\n+/* Compute the hash TABLE for doing copy/const propagation or\n+   expression hash table.  */\n+\n+static void\n+compute_hash_table (struct hash_table_d *table)\n+{\n+  /* Initialize count of number of entries in hash table.  */\n+  table->n_elems = 0;\n+  memset (table->table, 0, table->size * sizeof (struct expr *));\n+\n+  compute_hash_table_work (table);\n+}\n+\f\n+/* Expression tracking support.  */\n+\n+/* Lookup REGNO in the set TABLE.  The result is a pointer to the\n+   table entry, or NULL if not found.  */\n+\n+static struct expr *\n+lookup_set (unsigned int regno, struct hash_table_d *table)\n+{\n+  unsigned int hash = hash_set (regno, table->size);\n+  struct expr *expr;\n+\n+  expr = table->table[hash];\n+\n+  while (expr && REGNO (SET_DEST (expr->expr)) != regno)\n+    expr = expr->next_same_hash;\n+\n+  return expr;\n+}\n+\n+/* Return the next entry for REGNO in list EXPR.  */\n+\n+static struct expr *\n+next_set (unsigned int regno, struct expr *expr)\n+{\n+  do\n+    expr = expr->next_same_hash;\n+  while (expr && REGNO (SET_DEST (expr->expr)) != regno);\n+\n+  return expr;\n+}\n+\n+/* Reset tables used to keep track of what's still available [since the\n+   start of the block].  */\n+\n+static void\n+reset_opr_set_tables (void)\n+{\n+  /* Maintain a bitmap of which regs have been set since beginning of\n+     the block.  */\n+  CLEAR_REG_SET (reg_set_bitmap);\n+}\n+\n+/* Return nonzero if the operands of X are not set before INSN in\n+   INSN's basic block.  */\n+\n+static int\n+oprs_not_set_p (const_rtx x, const_rtx insn)\n+{\n+  int i, j;\n+  enum rtx_code code;\n+  const char *fmt;\n+\n+  if (x == 0)\n+    return 1;\n+\n+  code = GET_CODE (x);\n+  switch (code)\n+    {\n+    case PC:\n+    case CC0:\n+    case CONST:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case CONST_FIXED:\n+    case CONST_VECTOR:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+    case ADDR_VEC:\n+    case ADDR_DIFF_VEC:\n+      return 1;\n+\n+    case REG:\n+      return ! REGNO_REG_SET_P (reg_set_bitmap, REGNO (x));\n+\n+    default:\n+      break;\n+    }\n+\n+  for (i = GET_RTX_LENGTH (code) - 1, fmt = GET_RTX_FORMAT (code); i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  /* If we are about to do the last recursive call\n+\t     needed at this level, change it into iteration.\n+\t     This function is called enough to be worth it.  */\n+\t  if (i == 0)\n+\t    return oprs_not_set_p (XEXP (x, i), insn);\n+\n+\t  if (! oprs_not_set_p (XEXP (x, i), insn))\n+\t    return 0;\n+\t}\n+      else if (fmt[i] == 'E')\n+\tfor (j = 0; j < XVECLEN (x, i); j++)\n+\t  if (! oprs_not_set_p (XVECEXP (x, i, j), insn))\n+\t    return 0;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Mark things set by a SET.  */\n+\n+static void\n+mark_set (rtx pat, rtx insn ATTRIBUTE_UNUSED)\n+{\n+  rtx dest = SET_DEST (pat);\n+\n+  while (GET_CODE (dest) == SUBREG\n+\t || GET_CODE (dest) == ZERO_EXTRACT\n+\t || GET_CODE (dest) == STRICT_LOW_PART)\n+    dest = XEXP (dest, 0);\n+\n+  if (REG_P (dest))\n+    SET_REGNO_REG_SET (reg_set_bitmap, REGNO (dest));\n+}\n+\n+/* Record things set by a CLOBBER.  */\n+\n+static void\n+mark_clobber (rtx pat, rtx insn ATTRIBUTE_UNUSED)\n+{\n+  rtx clob = XEXP (pat, 0);\n+\n+  while (GET_CODE (clob) == SUBREG || GET_CODE (clob) == STRICT_LOW_PART)\n+    clob = XEXP (clob, 0);\n+\n+  if (REG_P (clob))\n+    SET_REGNO_REG_SET (reg_set_bitmap, REGNO (clob));\n+}\n+\n+/* Record things set by INSN.\n+   This data is used by oprs_not_set_p.  */\n+\n+static void\n+mark_oprs_set (rtx insn)\n+{\n+  rtx pat = PATTERN (insn);\n+  int i;\n+\n+  if (GET_CODE (pat) == SET)\n+    mark_set (pat, insn);\n+  else if (GET_CODE (pat) == PARALLEL)\n+    for (i = 0; i < XVECLEN (pat, 0); i++)\n+      {\n+\trtx x = XVECEXP (pat, 0, i);\n+\n+\tif (GET_CODE (x) == SET)\n+\t  mark_set (x, insn);\n+\telse if (GET_CODE (x) == CLOBBER)\n+\t  mark_clobber (x, insn);\n+      }\n+\n+  else if (GET_CODE (pat) == CLOBBER)\n+    mark_clobber (pat, insn);\n+}\n+\n+\f\n+/* Compute copy/constant propagation working variables.  */\n+\n+/* Local properties of assignments.  */\n+static sbitmap *cprop_pavloc;\n+static sbitmap *cprop_absaltered;\n+\n+/* Global properties of assignments (computed from the local properties).  */\n+static sbitmap *cprop_avin;\n+static sbitmap *cprop_avout;\n+\n+/* Allocate vars used for copy/const propagation.  N_BLOCKS is the number of\n+   basic blocks.  N_SETS is the number of sets.  */\n+\n+static void\n+alloc_cprop_mem (int n_blocks, int n_sets)\n+{\n+  cprop_pavloc = sbitmap_vector_alloc (n_blocks, n_sets);\n+  cprop_absaltered = sbitmap_vector_alloc (n_blocks, n_sets);\n+\n+  cprop_avin = sbitmap_vector_alloc (n_blocks, n_sets);\n+  cprop_avout = sbitmap_vector_alloc (n_blocks, n_sets);\n+}\n+\n+/* Free vars used by copy/const propagation.  */\n+\n+static void\n+free_cprop_mem (void)\n+{\n+  sbitmap_vector_free (cprop_pavloc);\n+  sbitmap_vector_free (cprop_absaltered);\n+  sbitmap_vector_free (cprop_avin);\n+  sbitmap_vector_free (cprop_avout);\n+}\n+\n+/* For each block, compute whether X is transparent.  X is either an\n+   expression or an assignment [though we don't care which, for this context\n+   an assignment is treated as an expression].  For each block where an\n+   element of X is modified, set the INDX bit in BMAP.  */\n+\n+static void\n+compute_transp (const_rtx x, int indx, sbitmap *bmap)\n+{\n+  int i, j;\n+  enum rtx_code code;\n+  const char *fmt;\n+\n+  /* repeat is used to turn tail-recursion into iteration since GCC\n+     can't do it when there's no return value.  */\n+ repeat:\n+\n+  if (x == 0)\n+    return;\n+\n+  code = GET_CODE (x);\n+  switch (code)\n+    {\n+    case REG:\n+\t{\n+\t  df_ref def;\n+\t  for (def = DF_REG_DEF_CHAIN (REGNO (x));\n+\t       def;\n+\t       def = DF_REF_NEXT_REG (def))\n+\t    SET_BIT (bmap[DF_REF_BB (def)->index], indx);\n+\t}\n+      return;\n+\n+    case PC:\n+    case CC0: /*FIXME*/\n+    case CONST:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case CONST_FIXED:\n+    case CONST_VECTOR:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+    case ADDR_VEC:\n+    case ADDR_DIFF_VEC:\n+      return;\n+\n+    default:\n+      break;\n+    }\n+\n+  for (i = GET_RTX_LENGTH (code) - 1, fmt = GET_RTX_FORMAT (code); i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  /* If we are about to do the last recursive call\n+\t     needed at this level, change it into iteration.\n+\t     This function is called enough to be worth it.  */\n+\t  if (i == 0)\n+\t    {\n+\t      x = XEXP (x, i);\n+\t      goto repeat;\n+\t    }\n+\n+\t  compute_transp (XEXP (x, i), indx, bmap);\n+\t}\n+      else if (fmt[i] == 'E')\n+\tfor (j = 0; j < XVECLEN (x, i); j++)\n+\t  compute_transp (XVECEXP (x, i, j), indx, bmap);\n+    }\n+}\n+\n+/* Compute the local properties of each recorded expression.\n+\n+   Local properties are those that are defined by the block, irrespective of\n+   other blocks.\n+\n+   An expression is transparent in a block if its operands are not modified\n+   in the block.\n+\n+   An expression is computed (locally available) in a block if it is computed\n+   at least once and expression would contain the same value if the\n+   computation was moved to the end of the block.\n+\n+   TRANSP and COMP are destination sbitmaps for recording local properties.\n+   If NULL, then it is not necessary to compute or record that particular\n+   property.\n+\n+   TRANSP is computed as ~TRANSP, since this is really cprop's ABSALTERED.  */\n+\n+static void\n+compute_local_properties (sbitmap *transp, sbitmap *comp,\n+\t\t\t  struct hash_table_d *table)\n+{\n+  unsigned int i;\n+\n+  /* Initialize any bitmaps that were passed in.  */\n+  if (transp)\n+    {\n+      sbitmap_vector_zero (transp, last_basic_block);\n+    }\n+\n+  if (comp)\n+    sbitmap_vector_zero (comp, last_basic_block);\n+\n+  for (i = 0; i < table->size; i++)\n+    {\n+      struct expr *expr;\n+\n+      for (expr = table->table[i]; expr != NULL; expr = expr->next_same_hash)\n+\t{\n+\t  int indx = expr->bitmap_index;\n+\t  struct occr *occr;\n+\n+\t  /* The expression is transparent in this block if it is not killed.\n+\t     We start by assuming all are transparent [none are killed], and\n+\t     then reset the bits for those that are.  */\n+\t  if (transp)\n+\t    compute_transp (expr->expr, indx, transp);\n+\n+\t  /* The occurrences recorded in avail_occr are exactly those that\n+\t     we want to set to nonzero in COMP.  */\n+\t  if (comp)\n+\t    for (occr = expr->avail_occr; occr != NULL; occr = occr->next)\n+\t      {\n+\t\tSET_BIT (comp[BLOCK_FOR_INSN (occr->insn)->index], indx);\n+\t      }\n+\t}\n+    }\n+}\n+\f\n+/* Hash table support.  */\n+\n+/* Top level routine to do the dataflow analysis needed by copy/const\n+   propagation.  */\n+\n+static void\n+compute_cprop_data (void)\n+{\n+  compute_local_properties (cprop_absaltered, cprop_pavloc, &set_hash_table);\n+  compute_available (cprop_pavloc, cprop_absaltered,\n+\t\t     cprop_avout, cprop_avin);\n+}\n+\f\n+/* Copy/constant propagation.  */\n+\n+/* Maximum number of register uses in an insn that we handle.  */\n+#define MAX_USES 8\n+\n+/* Table of uses found in an insn.\n+   Allocated statically to avoid alloc/free complexity and overhead.  */\n+static struct reg_use reg_use_table[MAX_USES];\n+\n+/* Index into `reg_use_table' while building it.  */\n+static int reg_use_count;\n+\n+/* Set up a list of register numbers used in INSN.  The found uses are stored\n+   in `reg_use_table'.  `reg_use_count' is initialized to zero before entry,\n+   and contains the number of uses in the table upon exit.\n+\n+   ??? If a register appears multiple times we will record it multiple times.\n+   This doesn't hurt anything but it will slow things down.  */\n+\n+static void\n+find_used_regs (rtx *xptr, void *data ATTRIBUTE_UNUSED)\n+{\n+  int i, j;\n+  enum rtx_code code;\n+  const char *fmt;\n+  rtx x = *xptr;\n+\n+  /* repeat is used to turn tail-recursion into iteration since GCC\n+     can't do it when there's no return value.  */\n+ repeat:\n+  if (x == 0)\n+    return;\n+\n+  code = GET_CODE (x);\n+  if (REG_P (x))\n+    {\n+      if (reg_use_count == MAX_USES)\n+\treturn;\n+\n+      reg_use_table[reg_use_count].reg_rtx = x;\n+      reg_use_count++;\n+    }\n+\n+  /* Recursively scan the operands of this expression.  */\n+\n+  for (i = GET_RTX_LENGTH (code) - 1, fmt = GET_RTX_FORMAT (code); i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  /* If we are about to do the last recursive call\n+\t     needed at this level, change it into iteration.\n+\t     This function is called enough to be worth it.  */\n+\t  if (i == 0)\n+\t    {\n+\t      x = XEXP (x, 0);\n+\t      goto repeat;\n+\t    }\n+\n+\t  find_used_regs (&XEXP (x, i), data);\n+\t}\n+      else if (fmt[i] == 'E')\n+\tfor (j = 0; j < XVECLEN (x, i); j++)\n+\t  find_used_regs (&XVECEXP (x, i, j), data);\n+    }\n+}\n+\n+/* Try to replace all non-SET_DEST occurrences of FROM in INSN with TO.\n+   Returns nonzero is successful.  */\n+\n+static int\n+try_replace_reg (rtx from, rtx to, rtx insn)\n+{\n+  rtx note = find_reg_equal_equiv_note (insn);\n+  rtx src = 0;\n+  int success = 0;\n+  rtx set = single_set (insn);\n+\n+  /* Usually we substitute easy stuff, so we won't copy everything.\n+     We however need to take care to not duplicate non-trivial CONST\n+     expressions.  */\n+  to = copy_rtx (to);\n+\n+  validate_replace_src_group (from, to, insn);\n+  if (num_changes_pending () && apply_change_group ())\n+    success = 1;\n+\n+  /* Try to simplify SET_SRC if we have substituted a constant.  */\n+  if (success && set && CONSTANT_P (to))\n+    {\n+      src = simplify_rtx (SET_SRC (set));\n+\n+      if (src)\n+\tvalidate_change (insn, &SET_SRC (set), src, 0);\n+    }\n+\n+  /* If there is already a REG_EQUAL note, update the expression in it\n+     with our replacement.  */\n+  if (note != 0 && REG_NOTE_KIND (note) == REG_EQUAL)\n+    set_unique_reg_note (insn, REG_EQUAL,\n+\t\t\t simplify_replace_rtx (XEXP (note, 0), from, to));\n+  if (!success && set && reg_mentioned_p (from, SET_SRC (set)))\n+    {\n+      /* If above failed and this is a single set, try to simplify the source of\n+\t the set given our substitution.  We could perhaps try this for multiple\n+\t SETs, but it probably won't buy us anything.  */\n+      src = simplify_replace_rtx (SET_SRC (set), from, to);\n+\n+      if (!rtx_equal_p (src, SET_SRC (set))\n+\t  && validate_change (insn, &SET_SRC (set), src, 0))\n+\tsuccess = 1;\n+\n+      /* If we've failed perform the replacement, have a single SET to\n+\t a REG destination and don't yet have a note, add a REG_EQUAL note\n+\t to not lose information.  */\n+      if (!success && note == 0 && set != 0 && REG_P (SET_DEST (set)))\n+\tnote = set_unique_reg_note (insn, REG_EQUAL, copy_rtx (src));\n+    }\n+\n+  /* REG_EQUAL may get simplified into register.\n+     We don't allow that. Remove that note. This code ought\n+     not to happen, because previous code ought to synthesize\n+     reg-reg move, but be on the safe side.  */\n+  if (note && REG_NOTE_KIND (note) == REG_EQUAL && REG_P (XEXP (note, 0)))\n+    remove_note (insn, note);\n+\n+  return success;\n+}\n+\n+/* Find a set of REGNOs that are available on entry to INSN's block.  Returns\n+   NULL no such set is found.  */\n+\n+static struct expr *\n+find_avail_set (int regno, rtx insn)\n+{\n+  /* SET1 contains the last set found that can be returned to the caller for\n+     use in a substitution.  */\n+  struct expr *set1 = 0;\n+\n+  /* Loops are not possible here.  To get a loop we would need two sets\n+     available at the start of the block containing INSN.  i.e. we would\n+     need two sets like this available at the start of the block:\n+\n+       (set (reg X) (reg Y))\n+       (set (reg Y) (reg X))\n+\n+     This can not happen since the set of (reg Y) would have killed the\n+     set of (reg X) making it unavailable at the start of this block.  */\n+  while (1)\n+    {\n+      rtx src;\n+      struct expr *set = lookup_set (regno, &set_hash_table);\n+\n+      /* Find a set that is available at the start of the block\n+\t which contains INSN.  */\n+      while (set)\n+\t{\n+\t  if (TEST_BIT (cprop_avin[BLOCK_FOR_INSN (insn)->index],\n+\t\t\tset->bitmap_index))\n+\t    break;\n+\t  set = next_set (regno, set);\n+\t}\n+\n+      /* If no available set was found we've reached the end of the\n+\t (possibly empty) copy chain.  */\n+      if (set == 0)\n+\tbreak;\n+\n+      gcc_assert (GET_CODE (set->expr) == SET);\n+\n+      src = SET_SRC (set->expr);\n+\n+      /* We know the set is available.\n+\t Now check that SRC is locally anticipatable (i.e. none of the\n+\t source operands have changed since the start of the block).\n+\n+         If the source operand changed, we may still use it for the next\n+         iteration of this loop, but we may not use it for substitutions.  */\n+\n+      if (gcse_constant_p (src) || oprs_not_set_p (src, insn))\n+\tset1 = set;\n+\n+      /* If the source of the set is anything except a register, then\n+\t we have reached the end of the copy chain.  */\n+      if (! REG_P (src))\n+\tbreak;\n+\n+      /* Follow the copy chain, i.e. start another iteration of the loop\n+\t and see if we have an available copy into SRC.  */\n+      regno = REGNO (src);\n+    }\n+\n+  /* SET1 holds the last set that was available and anticipatable at\n+     INSN.  */\n+  return set1;\n+}\n+\n+/* Subroutine of cprop_insn that tries to propagate constants into\n+   JUMP_INSNS.  JUMP must be a conditional jump.  If SETCC is non-NULL\n+   it is the instruction that immediately precedes JUMP, and must be a\n+   single SET of a register.  FROM is what we will try to replace,\n+   SRC is the constant we will try to substitute for it.  Returns nonzero\n+   if a change was made.  */\n+\n+static int\n+cprop_jump (basic_block bb, rtx setcc, rtx jump, rtx from, rtx src)\n+{\n+  rtx new_rtx, set_src, note_src;\n+  rtx set = pc_set (jump);\n+  rtx note = find_reg_equal_equiv_note (jump);\n+\n+  if (note)\n+    {\n+      note_src = XEXP (note, 0);\n+      if (GET_CODE (note_src) == EXPR_LIST)\n+\tnote_src = NULL_RTX;\n+    }\n+  else note_src = NULL_RTX;\n+\n+  /* Prefer REG_EQUAL notes except those containing EXPR_LISTs.  */\n+  set_src = note_src ? note_src : SET_SRC (set);\n+\n+  /* First substitute the SETCC condition into the JUMP instruction,\n+     then substitute that given values into this expanded JUMP.  */\n+  if (setcc != NULL_RTX\n+      && !modified_between_p (from, setcc, jump)\n+      && !modified_between_p (src, setcc, jump))\n+    {\n+      rtx setcc_src;\n+      rtx setcc_set = single_set (setcc);\n+      rtx setcc_note = find_reg_equal_equiv_note (setcc);\n+      setcc_src = (setcc_note && GET_CODE (XEXP (setcc_note, 0)) != EXPR_LIST)\n+\t\t? XEXP (setcc_note, 0) : SET_SRC (setcc_set);\n+      set_src = simplify_replace_rtx (set_src, SET_DEST (setcc_set),\n+\t\t\t\t      setcc_src);\n+    }\n+  else\n+    setcc = NULL_RTX;\n+\n+  new_rtx = simplify_replace_rtx (set_src, from, src);\n+\n+  /* If no simplification can be made, then try the next register.  */\n+  if (rtx_equal_p (new_rtx, SET_SRC (set)))\n+    return 0;\n+\n+  /* If this is now a no-op delete it, otherwise this must be a valid insn.  */\n+  if (new_rtx == pc_rtx)\n+    delete_insn (jump);\n+  else\n+    {\n+      /* Ensure the value computed inside the jump insn to be equivalent\n+         to one computed by setcc.  */\n+      if (setcc && modified_in_p (new_rtx, setcc))\n+\treturn 0;\n+      if (! validate_unshare_change (jump, &SET_SRC (set), new_rtx, 0))\n+\t{\n+\t  /* When (some) constants are not valid in a comparison, and there\n+\t     are two registers to be replaced by constants before the entire\n+\t     comparison can be folded into a constant, we need to keep\n+\t     intermediate information in REG_EQUAL notes.  For targets with\n+\t     separate compare insns, such notes are added by try_replace_reg.\n+\t     When we have a combined compare-and-branch instruction, however,\n+\t     we need to attach a note to the branch itself to make this\n+\t     optimization work.  */\n+\n+\t  if (!rtx_equal_p (new_rtx, note_src))\n+\t    set_unique_reg_note (jump, REG_EQUAL, copy_rtx (new_rtx));\n+\t  return 0;\n+\t}\n+\n+      /* Remove REG_EQUAL note after simplification.  */\n+      if (note_src)\n+\tremove_note (jump, note);\n+     }\n+\n+#ifdef HAVE_cc0\n+  /* Delete the cc0 setter.  */\n+  if (setcc != NULL && CC0_P (SET_DEST (single_set (setcc))))\n+    delete_insn (setcc);\n+#endif\n+\n+  global_const_prop_count++;\n+  if (dump_file != NULL)\n+    {\n+      fprintf (dump_file,\n+\t       \"GLOBAL CONST-PROP: Replacing reg %d in jump_insn %d with constant \",\n+\t       REGNO (from), INSN_UID (jump));\n+      print_rtl (dump_file, src);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+  purge_dead_edges (bb);\n+\n+  /* If a conditional jump has been changed into unconditional jump, remove\n+     the jump and make the edge fallthru - this is always called in\n+     cfglayout mode.  */\n+  if (new_rtx != pc_rtx && simplejump_p (jump))\n+    {\n+      edge e;\n+      edge_iterator ei;\n+\n+      for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); ei_next (&ei))\n+\tif (e->dest != EXIT_BLOCK_PTR\n+\t    && BB_HEAD (e->dest) == JUMP_LABEL (jump))\n+\t  {\n+\t    e->flags |= EDGE_FALLTHRU;\n+\t    break;\n+\t  }\n+      delete_insn (jump);\n+    }\n+\n+  return 1;\n+}\n+\n+static bool\n+constprop_register (rtx insn, rtx from, rtx to)\n+{\n+  rtx sset;\n+\n+  /* Check for reg or cc0 setting instructions followed by\n+     conditional branch instructions first.  */\n+  if ((sset = single_set (insn)) != NULL\n+      && NEXT_INSN (insn)\n+      && any_condjump_p (NEXT_INSN (insn)) && onlyjump_p (NEXT_INSN (insn)))\n+    {\n+      rtx dest = SET_DEST (sset);\n+      if ((REG_P (dest) || CC0_P (dest))\n+\t  && cprop_jump (BLOCK_FOR_INSN (insn), insn, NEXT_INSN (insn), from, to))\n+\treturn 1;\n+    }\n+\n+  /* Handle normal insns next.  */\n+  if (NONJUMP_INSN_P (insn)\n+      && try_replace_reg (from, to, insn))\n+    return 1;\n+\n+  /* Try to propagate a CONST_INT into a conditional jump.\n+     We're pretty specific about what we will handle in this\n+     code, we can extend this as necessary over time.\n+\n+     Right now the insn in question must look like\n+     (set (pc) (if_then_else ...))  */\n+  else if (any_condjump_p (insn) && onlyjump_p (insn))\n+    return cprop_jump (BLOCK_FOR_INSN (insn), NULL, insn, from, to);\n+  return 0;\n+}\n+\n+/* Perform constant and copy propagation on INSN.\n+   The result is nonzero if a change was made.  */\n+\n+static int\n+cprop_insn (rtx insn)\n+{\n+  struct reg_use *reg_used;\n+  int changed = 0;\n+  rtx note;\n+\n+  if (!INSN_P (insn))\n+    return 0;\n+\n+  reg_use_count = 0;\n+  note_uses (&PATTERN (insn), find_used_regs, NULL);\n+\n+  note = find_reg_equal_equiv_note (insn);\n+\n+  /* We may win even when propagating constants into notes.  */\n+  if (note)\n+    find_used_regs (&XEXP (note, 0), NULL);\n+\n+  for (reg_used = &reg_use_table[0]; reg_use_count > 0;\n+       reg_used++, reg_use_count--)\n+    {\n+      unsigned int regno = REGNO (reg_used->reg_rtx);\n+      rtx pat, src;\n+      struct expr *set;\n+\n+      /* If the register has already been set in this block, there's\n+\t nothing we can do.  */\n+      if (! oprs_not_set_p (reg_used->reg_rtx, insn))\n+\tcontinue;\n+\n+      /* Find an assignment that sets reg_used and is available\n+\t at the start of the block.  */\n+      set = find_avail_set (regno, insn);\n+      if (! set)\n+\tcontinue;\n+\n+      pat = set->expr;\n+      /* ??? We might be able to handle PARALLELs.  Later.  */\n+      gcc_assert (GET_CODE (pat) == SET);\n+\n+      src = SET_SRC (pat);\n+\n+      /* Constant propagation.  */\n+      if (gcse_constant_p (src))\n+\t{\n+          if (constprop_register (insn, reg_used->reg_rtx, src))\n+\t    {\n+\t      changed = 1;\n+\t      global_const_prop_count++;\n+\t      if (dump_file != NULL)\n+\t\t{\n+\t\t  fprintf (dump_file, \"GLOBAL CONST-PROP: Replacing reg %d in \", regno);\n+\t\t  fprintf (dump_file, \"insn %d with constant \", INSN_UID (insn));\n+\t\t  print_rtl (dump_file, src);\n+\t\t  fprintf (dump_file, \"\\n\");\n+\t\t}\n+\t      if (INSN_DELETED_P (insn))\n+\t\treturn 1;\n+\t    }\n+\t}\n+      else if (REG_P (src)\n+\t       && REGNO (src) >= FIRST_PSEUDO_REGISTER\n+\t       && REGNO (src) != regno)\n+\t{\n+\t  if (try_replace_reg (reg_used->reg_rtx, src, insn))\n+\t    {\n+\t      changed = 1;\n+\t      global_copy_prop_count++;\n+\t      if (dump_file != NULL)\n+\t\t{\n+\t\t  fprintf (dump_file, \"GLOBAL COPY-PROP: Replacing reg %d in insn %d\",\n+\t\t\t   regno, INSN_UID (insn));\n+\t\t  fprintf (dump_file, \" with reg %d\\n\", REGNO (src));\n+\t\t}\n+\n+\t      /* The original insn setting reg_used may or may not now be\n+\t\t deletable.  We leave the deletion to flow.  */\n+\t      /* FIXME: If it turns out that the insn isn't deletable,\n+\t\t then we may have unnecessarily extended register lifetimes\n+\t\t and made things worse.  */\n+\t    }\n+\t}\n+    }\n+\n+  if (changed && DEBUG_INSN_P (insn))\n+    return 0;\n+\n+  return changed;\n+}\n+\n+/* Like find_used_regs, but avoid recording uses that appear in\n+   input-output contexts such as zero_extract or pre_dec.  This\n+   restricts the cases we consider to those for which local cprop\n+   can legitimately make replacements.  */\n+\n+static void\n+local_cprop_find_used_regs (rtx *xptr, void *data)\n+{\n+  rtx x = *xptr;\n+\n+  if (x == 0)\n+    return;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case ZERO_EXTRACT:\n+    case SIGN_EXTRACT:\n+    case STRICT_LOW_PART:\n+      return;\n+\n+    case PRE_DEC:\n+    case PRE_INC:\n+    case POST_DEC:\n+    case POST_INC:\n+    case PRE_MODIFY:\n+    case POST_MODIFY:\n+      /* Can only legitimately appear this early in the context of\n+\t stack pushes for function arguments, but handle all of the\n+\t codes nonetheless.  */\n+      return;\n+\n+    case SUBREG:\n+      /* Setting a subreg of a register larger than word_mode leaves\n+\t the non-written words unchanged.  */\n+      if (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x))) > BITS_PER_WORD)\n+\treturn;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  find_used_regs (xptr, data);\n+}\n+\n+/* Try to perform local const/copy propagation on X in INSN.  */\n+\n+static bool\n+do_local_cprop (rtx x, rtx insn)\n+{\n+  rtx newreg = NULL, newcnst = NULL;\n+\n+  /* Rule out USE instructions and ASM statements as we don't want to\n+     change the hard registers mentioned.  */\n+  if (REG_P (x)\n+      && (REGNO (x) >= FIRST_PSEUDO_REGISTER\n+          || (GET_CODE (PATTERN (insn)) != USE\n+\t      && asm_noperands (PATTERN (insn)) < 0)))\n+    {\n+      cselib_val *val = cselib_lookup (x, GET_MODE (x), 0, VOIDmode);\n+      struct elt_loc_list *l;\n+\n+      if (!val)\n+\treturn false;\n+      for (l = val->locs; l; l = l->next)\n+\t{\n+\t  rtx this_rtx = l->loc;\n+\t  rtx note;\n+\n+\t  if (gcse_constant_p (this_rtx))\n+\t    newcnst = this_rtx;\n+\t  if (REG_P (this_rtx) && REGNO (this_rtx) >= FIRST_PSEUDO_REGISTER\n+\t      /* Don't copy propagate if it has attached REG_EQUIV note.\n+\t\t At this point this only function parameters should have\n+\t\t REG_EQUIV notes and if the argument slot is used somewhere\n+\t\t explicitly, it means address of parameter has been taken,\n+\t\t so we should not extend the lifetime of the pseudo.  */\n+\t      && (!(note = find_reg_note (l->setting_insn, REG_EQUIV, NULL_RTX))\n+\t\t  || ! MEM_P (XEXP (note, 0))))\n+\t    newreg = this_rtx;\n+\t}\n+      if (newcnst && constprop_register (insn, x, newcnst))\n+\t{\n+\t  if (dump_file != NULL)\n+\t    {\n+\t      fprintf (dump_file, \"LOCAL CONST-PROP: Replacing reg %d in \",\n+\t\t       REGNO (x));\n+\t      fprintf (dump_file, \"insn %d with constant \",\n+\t\t       INSN_UID (insn));\n+\t      print_rtl (dump_file, newcnst);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\t  local_const_prop_count++;\n+\t  return true;\n+\t}\n+      else if (newreg && newreg != x && try_replace_reg (x, newreg, insn))\n+\t{\n+\t  if (dump_file != NULL)\n+\t    {\n+\t      fprintf (dump_file,\n+\t\t       \"LOCAL COPY-PROP: Replacing reg %d in insn %d\",\n+\t\t       REGNO (x), INSN_UID (insn));\n+\t      fprintf (dump_file, \" with reg %d\\n\", REGNO (newreg));\n+\t    }\n+\t  local_copy_prop_count++;\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* Do local const/copy propagation (i.e. within each basic block).  */\n+\n+static int\n+local_cprop_pass (void)\n+{\n+  basic_block bb;\n+  rtx insn;\n+  struct reg_use *reg_used;\n+  bool changed = false;\n+\n+  cselib_init (0);\n+  FOR_EACH_BB (bb)\n+    {\n+      FOR_BB_INSNS (bb, insn)\n+\t{\n+\t  if (INSN_P (insn))\n+\t    {\n+\t      rtx note = find_reg_equal_equiv_note (insn);\n+\t      do\n+\t\t{\n+\t\t  reg_use_count = 0;\n+\t\t  note_uses (&PATTERN (insn), local_cprop_find_used_regs,\n+\t\t\t     NULL);\n+\t\t  if (note)\n+\t\t    local_cprop_find_used_regs (&XEXP (note, 0), NULL);\n+\n+\t\t  for (reg_used = &reg_use_table[0]; reg_use_count > 0;\n+\t\t       reg_used++, reg_use_count--)\n+\t\t    {\n+\t\t      if (do_local_cprop (reg_used->reg_rtx, insn))\n+\t\t\t{\n+\t\t\t  changed = true;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t    }\n+\t\t  if (INSN_DELETED_P (insn))\n+\t\t    break;\n+\t\t}\n+\t      while (reg_use_count);\n+\t    }\n+\t  cselib_process_insn (insn);\n+\t}\n+\n+      /* Forget everything at the end of a basic block.  */\n+      cselib_clear_table ();\n+    }\n+\n+  cselib_finish ();\n+\n+  return changed;\n+}\n+\n+/* Similar to get_condition, only the resulting condition must be\n+   valid at JUMP, instead of at EARLIEST.\n+\n+   This differs from noce_get_condition in ifcvt.c in that we prefer not to\n+   settle for the condition variable in the jump instruction being integral.\n+   We prefer to be able to record the value of a user variable, rather than\n+   the value of a temporary used in a condition.  This could be solved by\n+   recording the value of *every* register scanned by canonicalize_condition,\n+   but this would require some code reorganization.  */\n+\n+rtx\n+fis_get_condition (rtx jump)\n+{\n+  return get_condition (jump, NULL, false, true);\n+}\n+\n+/* Check the comparison COND to see if we can safely form an implicit set from\n+   it.  COND is either an EQ or NE comparison.  */\n+\n+static bool\n+implicit_set_cond_p (const_rtx cond)\n+{\n+  const enum machine_mode mode = GET_MODE (XEXP (cond, 0));\n+  const_rtx cst = XEXP (cond, 1);\n+\n+  /* We can't perform this optimization if either operand might be or might\n+     contain a signed zero.  */\n+  if (HONOR_SIGNED_ZEROS (mode))\n+    {\n+      /* It is sufficient to check if CST is or contains a zero.  We must\n+\t handle float, complex, and vector.  If any subpart is a zero, then\n+\t the optimization can't be performed.  */\n+      /* ??? The complex and vector checks are not implemented yet.  We just\n+\t always return zero for them.  */\n+      if (GET_CODE (cst) == CONST_DOUBLE)\n+\t{\n+\t  REAL_VALUE_TYPE d;\n+\t  REAL_VALUE_FROM_CONST_DOUBLE (d, cst);\n+\t  if (REAL_VALUES_EQUAL (d, dconst0))\n+\t    return 0;\n+\t}\n+      else\n+\treturn 0;\n+    }\n+\n+  return gcse_constant_p (cst);\n+}\n+\n+/* Find the implicit sets of a function.  An \"implicit set\" is a constraint\n+   on the value of a variable, implied by a conditional jump.  For example,\n+   following \"if (x == 2)\", the then branch may be optimized as though the\n+   conditional performed an \"explicit set\", in this example, \"x = 2\".  This\n+   function records the set patterns that are implicit at the start of each\n+   basic block.\n+\n+   FIXME: This would be more effective if critical edges are pre-split.  As\n+\t  it is now, we can't record implicit sets for blocks that have\n+\t  critical successor edges.  This results in missed optimizations\n+\t  and in more (unnecessary) work in cfgcleanup.c:thread_jump().  */\n+\n+static void\n+find_implicit_sets (void)\n+{\n+  basic_block bb, dest;\n+  unsigned int count;\n+  rtx cond, new_rtx;\n+\n+  count = 0;\n+  FOR_EACH_BB (bb)\n+    /* Check for more than one successor.  */\n+    if (EDGE_COUNT (bb->succs) > 1)\n+      {\n+\tcond = fis_get_condition (BB_END (bb));\n+\n+\tif (cond\n+\t    && (GET_CODE (cond) == EQ || GET_CODE (cond) == NE)\n+\t    && REG_P (XEXP (cond, 0))\n+\t    && REGNO (XEXP (cond, 0)) >= FIRST_PSEUDO_REGISTER\n+\t    && implicit_set_cond_p (cond))\n+\t  {\n+\t    dest = GET_CODE (cond) == EQ ? BRANCH_EDGE (bb)->dest\n+\t\t\t\t\t : FALLTHRU_EDGE (bb)->dest;\n+\n+\t    if (dest\n+\t\t/* Record nothing for a critical edge.  */\n+\t\t&& single_pred_p (dest)\n+\t\t&& dest != EXIT_BLOCK_PTR)\n+\t      {\n+\t\tnew_rtx = gen_rtx_SET (VOIDmode, XEXP (cond, 0),\n+\t\t\t\t\t     XEXP (cond, 1));\n+\t\timplicit_sets[dest->index] = new_rtx;\n+\t\tif (dump_file)\n+\t\t  {\n+\t\t    fprintf(dump_file, \"Implicit set of reg %d in \",\n+\t\t\t    REGNO (XEXP (cond, 0)));\n+\t\t    fprintf(dump_file, \"basic block %d\\n\", dest->index);\n+\t\t  }\n+\t\tcount++;\n+\t      }\n+\t  }\n+      }\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Found %d implicit sets\\n\", count);\n+}\n+\n+/* Bypass conditional jumps.  */\n+\n+/* The value of last_basic_block at the beginning of the jump_bypass\n+   pass.  The use of redirect_edge_and_branch_force may introduce new\n+   basic blocks, but the data flow analysis is only valid for basic\n+   block indices less than bypass_last_basic_block.  */\n+\n+static int bypass_last_basic_block;\n+\n+/* Find a set of REGNO to a constant that is available at the end of basic\n+   block BB.  Returns NULL if no such set is found.  Based heavily upon\n+   find_avail_set.  */\n+\n+static struct expr *\n+find_bypass_set (int regno, int bb)\n+{\n+  struct expr *result = 0;\n+\n+  for (;;)\n+    {\n+      rtx src;\n+      struct expr *set = lookup_set (regno, &set_hash_table);\n+\n+      while (set)\n+\t{\n+\t  if (TEST_BIT (cprop_avout[bb], set->bitmap_index))\n+\t    break;\n+\t  set = next_set (regno, set);\n+\t}\n+\n+      if (set == 0)\n+\tbreak;\n+\n+      gcc_assert (GET_CODE (set->expr) == SET);\n+\n+      src = SET_SRC (set->expr);\n+      if (gcse_constant_p (src))\n+\tresult = set;\n+\n+      if (! REG_P (src))\n+\tbreak;\n+\n+      regno = REGNO (src);\n+    }\n+  return result;\n+}\n+\n+\n+/* Subroutine of bypass_block that checks whether a pseudo is killed by\n+   any of the instructions inserted on an edge.  Jump bypassing places\n+   condition code setters on CFG edges using insert_insn_on_edge.  This\n+   function is required to check that our data flow analysis is still\n+   valid prior to commit_edge_insertions.  */\n+\n+static bool\n+reg_killed_on_edge (const_rtx reg, const_edge e)\n+{\n+  rtx insn;\n+\n+  for (insn = e->insns.r; insn; insn = NEXT_INSN (insn))\n+    if (INSN_P (insn) && reg_set_p (reg, insn))\n+      return true;\n+\n+  return false;\n+}\n+\n+/* Subroutine of bypass_conditional_jumps that attempts to bypass the given\n+   basic block BB which has more than one predecessor.  If not NULL, SETCC\n+   is the first instruction of BB, which is immediately followed by JUMP_INSN\n+   JUMP.  Otherwise, SETCC is NULL, and JUMP is the first insn of BB.\n+   Returns nonzero if a change was made.\n+\n+   During the jump bypassing pass, we may place copies of SETCC instructions\n+   on CFG edges.  The following routine must be careful to pay attention to\n+   these inserted insns when performing its transformations.  */\n+\n+static int\n+bypass_block (basic_block bb, rtx setcc, rtx jump)\n+{\n+  rtx insn, note;\n+  edge e, edest;\n+  int i, change;\n+  int may_be_loop_header;\n+  unsigned removed_p;\n+  edge_iterator ei;\n+\n+  insn = (setcc != NULL) ? setcc : jump;\n+\n+  /* Determine set of register uses in INSN.  */\n+  reg_use_count = 0;\n+  note_uses (&PATTERN (insn), find_used_regs, NULL);\n+  note = find_reg_equal_equiv_note (insn);\n+  if (note)\n+    find_used_regs (&XEXP (note, 0), NULL);\n+\n+  may_be_loop_header = false;\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    if (e->flags & EDGE_DFS_BACK)\n+      {\n+\tmay_be_loop_header = true;\n+\tbreak;\n+      }\n+\n+  change = 0;\n+  for (ei = ei_start (bb->preds); (e = ei_safe_edge (ei)); )\n+    {\n+      removed_p = 0;\n+\n+      if (e->flags & EDGE_COMPLEX)\n+\t{\n+\t  ei_next (&ei);\n+\t  continue;\n+\t}\n+\n+      /* We can't redirect edges from new basic blocks.  */\n+      if (e->src->index >= bypass_last_basic_block)\n+\t{\n+\t  ei_next (&ei);\n+\t  continue;\n+\t}\n+\n+      /* The irreducible loops created by redirecting of edges entering the\n+\t loop from outside would decrease effectiveness of some of the following\n+\t optimizations, so prevent this.  */\n+      if (may_be_loop_header\n+\t  && !(e->flags & EDGE_DFS_BACK))\n+\t{\n+\t  ei_next (&ei);\n+\t  continue;\n+\t}\n+\n+      for (i = 0; i < reg_use_count; i++)\n+\t{\n+\t  struct reg_use *reg_used = &reg_use_table[i];\n+\t  unsigned int regno = REGNO (reg_used->reg_rtx);\n+\t  basic_block dest, old_dest;\n+\t  struct expr *set;\n+\t  rtx src, new_rtx;\n+\n+\t  set = find_bypass_set (regno, e->src->index);\n+\n+\t  if (! set)\n+\t    continue;\n+\n+\t  /* Check the data flow is valid after edge insertions.  */\n+\t  if (e->insns.r && reg_killed_on_edge (reg_used->reg_rtx, e))\n+\t    continue;\n+\n+\t  src = SET_SRC (pc_set (jump));\n+\n+\t  if (setcc != NULL)\n+\t    src = simplify_replace_rtx (src,\n+\t\t\t\t\tSET_DEST (PATTERN (setcc)),\n+\t\t\t\t\tSET_SRC (PATTERN (setcc)));\n+\n+\t  new_rtx = simplify_replace_rtx (src, reg_used->reg_rtx,\n+\t\t\t\t\t  SET_SRC (set->expr));\n+\n+\t  /* Jump bypassing may have already placed instructions on\n+\t     edges of the CFG.  We can't bypass an outgoing edge that\n+\t     has instructions associated with it, as these insns won't\n+\t     get executed if the incoming edge is redirected.  */\n+\n+\t  if (new_rtx == pc_rtx)\n+\t    {\n+\t      edest = FALLTHRU_EDGE (bb);\n+\t      dest = edest->insns.r ? NULL : edest->dest;\n+\t    }\n+\t  else if (GET_CODE (new_rtx) == LABEL_REF)\n+\t    {\n+\t      dest = BLOCK_FOR_INSN (XEXP (new_rtx, 0));\n+\t      /* Don't bypass edges containing instructions.  */\n+\t      edest = find_edge (bb, dest);\n+\t      if (edest && edest->insns.r)\n+\t\tdest = NULL;\n+\t    }\n+\t  else\n+\t    dest = NULL;\n+\n+\t  /* Avoid unification of the edge with other edges from original\n+\t     branch.  We would end up emitting the instruction on \"both\"\n+\t     edges.  */\n+\n+\t  if (dest && setcc && !CC0_P (SET_DEST (PATTERN (setcc)))\n+\t      && find_edge (e->src, dest))\n+\t    dest = NULL;\n+\n+\t  old_dest = e->dest;\n+\t  if (dest != NULL\n+\t      && dest != old_dest\n+\t      && dest != EXIT_BLOCK_PTR)\n+            {\n+\t      redirect_edge_and_branch_force (e, dest);\n+\n+\t      /* Copy the register setter to the redirected edge.\n+\t\t Don't copy CC0 setters, as CC0 is dead after jump.  */\n+\t      if (setcc)\n+\t\t{\n+\t\t  rtx pat = PATTERN (setcc);\n+\t\t  if (!CC0_P (SET_DEST (pat)))\n+\t\t    insert_insn_on_edge (copy_insn (pat), e);\n+\t\t}\n+\n+\t      if (dump_file != NULL)\n+\t\t{\n+\t\t  fprintf (dump_file, \"JUMP-BYPASS: Proved reg %d \"\n+\t\t\t\t      \"in jump_insn %d equals constant \",\n+\t\t\t   regno, INSN_UID (jump));\n+\t\t  print_rtl (dump_file, SET_SRC (set->expr));\n+\t\t  fprintf (dump_file, \"\\nBypass edge from %d->%d to %d\\n\",\n+\t\t\t   e->src->index, old_dest->index, dest->index);\n+\t\t}\n+\t      change = 1;\n+\t      removed_p = 1;\n+\t      break;\n+\t    }\n+\t}\n+      if (!removed_p)\n+\tei_next (&ei);\n+    }\n+  return change;\n+}\n+\n+/* Find basic blocks with more than one predecessor that only contain a\n+   single conditional jump.  If the result of the comparison is known at\n+   compile-time from any incoming edge, redirect that edge to the\n+   appropriate target.  Returns nonzero if a change was made.\n+\n+   This function is now mis-named, because we also handle indirect jumps.  */\n+\n+static int\n+bypass_conditional_jumps (void)\n+{\n+  basic_block bb;\n+  int changed;\n+  rtx setcc;\n+  rtx insn;\n+  rtx dest;\n+\n+  /* Note we start at block 1.  */\n+  if (ENTRY_BLOCK_PTR->next_bb == EXIT_BLOCK_PTR)\n+    return 0;\n+\n+  bypass_last_basic_block = last_basic_block;\n+  mark_dfs_back_edges ();\n+\n+  changed = 0;\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR->next_bb->next_bb,\n+\t\t  EXIT_BLOCK_PTR, next_bb)\n+    {\n+      /* Check for more than one predecessor.  */\n+      if (!single_pred_p (bb))\n+\t{\n+\t  setcc = NULL_RTX;\n+\t  FOR_BB_INSNS (bb, insn)\n+\t    if (DEBUG_INSN_P (insn))\n+\t      continue;\n+\t    else if (NONJUMP_INSN_P (insn))\n+\t      {\n+\t\tif (setcc)\n+\t\t  break;\n+\t\tif (GET_CODE (PATTERN (insn)) != SET)\n+\t\t  break;\n+\n+\t\tdest = SET_DEST (PATTERN (insn));\n+\t\tif (REG_P (dest) || CC0_P (dest))\n+\t\t  setcc = insn;\n+\t\telse\n+\t\t  break;\n+\t      }\n+\t    else if (JUMP_P (insn))\n+\t      {\n+\t\tif ((any_condjump_p (insn) || computed_jump_p (insn))\n+\t\t    && onlyjump_p (insn))\n+\t\t  changed |= bypass_block (bb, setcc, insn);\n+\t\tbreak;\n+\t      }\n+\t    else if (INSN_P (insn))\n+\t      break;\n+\t}\n+    }\n+\n+  /* If we bypassed any register setting insns, we inserted a\n+     copy on the redirected edge.  These need to be committed.  */\n+  if (changed)\n+    commit_edge_insertions ();\n+\n+  return changed;\n+}\n+\f\n+/* Return true if the graph is too expensive to optimize. PASS is the\n+   optimization about to be performed.  */\n+\n+static bool\n+is_too_expensive (const char *pass)\n+{\n+  /* Trying to perform global optimizations on flow graphs which have\n+     a high connectivity will take a long time and is unlikely to be\n+     particularly useful.\n+\n+     In normal circumstances a cfg should have about twice as many\n+     edges as blocks.  But we do not want to punish small functions\n+     which have a couple switch statements.  Rather than simply\n+     threshold the number of blocks, uses something with a more\n+     graceful degradation.  */\n+  if (n_edges > 20000 + n_basic_blocks * 4)\n+    {\n+      warning (OPT_Wdisabled_optimization,\n+\t       \"%s: %d basic blocks and %d edges/basic block\",\n+\t       pass, n_basic_blocks, n_edges / n_basic_blocks);\n+\n+      return true;\n+    }\n+\n+  /* If allocating memory for the cprop bitmap would take up too much\n+     storage it's better just to disable the optimization.  */\n+  if ((n_basic_blocks\n+       * SBITMAP_SET_SIZE (max_reg_num ())\n+       * sizeof (SBITMAP_ELT_TYPE)) > MAX_GCSE_MEMORY)\n+    {\n+      warning (OPT_Wdisabled_optimization,\n+\t       \"%s: %d basic blocks and %d registers\",\n+\t       pass, n_basic_blocks, max_reg_num ());\n+\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+\f\n+/* Main function for the CPROP pass.  */\n+\n+static int\n+one_cprop_pass (void)\n+{\n+  int changed = 0;\n+\n+  /* Return if there's nothing to do, or it is too expensive.  */\n+  if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1\n+      || is_too_expensive (_ (\"const/copy propagation disabled\")))\n+    return 0;\n+\n+  global_const_prop_count = local_const_prop_count = 0;\n+  global_copy_prop_count = local_copy_prop_count = 0;\n+\n+  bytes_used = 0;\n+  gcc_obstack_init (&gcse_obstack);\n+  alloc_gcse_mem ();\n+\n+  /* Do a local const/copy propagation pass first.  The global pass\n+     only handles global opportunities.\n+     If the local pass changes something, remove any unreachable blocks\n+     because the CPROP global dataflow analysis may get into infinite\n+     loops for CFGs with unreachable blocks.\n+\n+     FIXME: This local pass should not be necessary after CSE (but for\n+\t    some reason it still is).  It is also (proven) not necessary\n+\t    to run the local pass right after FWPWOP.\n+\n+     FIXME: The global analysis would not get into infinite loops if it\n+\t    would use the DF solver (via df_simple_dataflow) instead of\n+\t    the solver implemented in this file.  */\n+  if (local_cprop_pass ())\n+    {\n+      delete_unreachable_blocks ();\n+      df_analyze ();\n+    }\n+\n+  /* Determine implicit sets.  */\n+  implicit_sets = XCNEWVEC (rtx, last_basic_block);\n+  find_implicit_sets ();\n+\n+  alloc_hash_table (&set_hash_table);\n+  compute_hash_table (&set_hash_table);\n+\n+  /* Free implicit_sets before peak usage.  */\n+  free (implicit_sets);\n+  implicit_sets = NULL;\n+\n+  if (dump_file)\n+    dump_hash_table (dump_file, \"SET\", &set_hash_table);\n+  if (set_hash_table.n_elems > 0)\n+    {\n+      basic_block bb;\n+      rtx insn;\n+\n+      alloc_cprop_mem (last_basic_block, set_hash_table.n_elems);\n+      compute_cprop_data ();\n+\n+      FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR->next_bb->next_bb, EXIT_BLOCK_PTR, next_bb)\n+\t{\n+\t  /* Reset tables used to keep track of what's still valid [since\n+\t     the start of the block].  */\n+\t  reset_opr_set_tables ();\n+\n+\t  FOR_BB_INSNS (bb, insn)\n+\t    if (INSN_P (insn))\n+\t      {\n+\t\tchanged |= cprop_insn (insn);\n+\n+\t\t/* Keep track of everything modified by this insn.  */\n+\t\t/* ??? Need to be careful w.r.t. mods done to INSN.\n+\t\t       Don't call mark_oprs_set if we turned the\n+\t\t       insn into a NOTE.  */\n+\t\tif (! NOTE_P (insn))\n+\t\t  mark_oprs_set (insn);\n+\t      }\n+\t}\n+\n+      changed |= bypass_conditional_jumps ();\n+      free_cprop_mem ();\n+    }\n+\n+  free_hash_table (&set_hash_table);\n+  free_gcse_mem ();\n+  obstack_free (&gcse_obstack, NULL);\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"CPROP of %s, %d basic blocks, %d bytes needed, \",\n+\t       current_function_name (), n_basic_blocks, bytes_used);\n+      fprintf (dump_file, \"%d local const props, %d local copy props, \",\n+\t       local_const_prop_count, local_copy_prop_count);\n+      fprintf (dump_file, \"%d global const props, %d global copy props\\n\\n\",\n+\t       global_const_prop_count, global_copy_prop_count);\n+    }\n+\n+  return changed;\n+}\n+\n+\f\n+/* All the passes implemented in this file.  Each pass has its\n+   own gate and execute function, and at the end of the file a\n+   pass definition for passes.c.\n+\n+   We do not construct an accurate cfg in functions which call\n+   setjmp, so none of these passes runs if the function calls\n+   setjmp.\n+   FIXME: Should just handle setjmp via REG_SETJMP notes.  */\n+\n+static bool\n+gate_rtl_cprop (void)\n+{\n+  return optimize > 0 && flag_gcse\n+    && !cfun->calls_setjmp\n+    && dbg_cnt (cprop);\n+}\n+\n+static unsigned int\n+execute_rtl_cprop (void)\n+{\n+  int changed;\n+  delete_unreachable_blocks ();\n+  df_set_flags (DF_LR_RUN_DCE);\n+  df_analyze ();\n+  changed = one_cprop_pass ();\n+  flag_rerun_cse_after_global_opts |= changed;\n+  if (changed)\n+    cleanup_cfg (0);\n+  return 0;\n+}\n+\n+struct rtl_opt_pass pass_rtl_cprop =\n+{\n+ {\n+  RTL_PASS,\n+  \"cprop\",                              /* name */\n+  gate_rtl_cprop,                       /* gate */\n+  execute_rtl_cprop,  \t\t\t/* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_CPROP,                             /* tv_id */\n+  PROP_cfglayout,                       /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_df_finish | TODO_verify_rtl_sharing |\n+  TODO_dump_func |\n+  TODO_verify_flow | TODO_ggc_collect   /* todo_flags_finish */\n+ }\n+};\n+"}, {"sha": "a1de61fd24c3cd79119094d13a0d6a64c251e1be", "filename": "gcc/gcse.c", "status": "modified", "additions": 140, "deletions": 1749, "changes": 1889, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e45425ecf8afa3ce7cbae97f267538c7d1e5650c/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e45425ecf8afa3ce7cbae97f267538c7d1e5650c/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=e45425ecf8afa3ce7cbae97f267538c7d1e5650c", "patch": "@@ -1,5 +1,4 @@\n-/* Global common subexpression elimination/Partial redundancy elimination\n-   and global constant/copy propagation for GNU compiler.\n+/* Partial redundancy elimination / Hoisting for RTL.\n    Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,\n    2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.\n \n@@ -175,25 +174,12 @@ along with GCC; see the file COPYING3.  If not see\n /* We support GCSE via Partial Redundancy Elimination.  PRE optimizations\n    are a superset of those done by classic GCSE.\n \n-   We perform the following steps:\n-\n-   1) Compute table of places where registers are set.\n-\n-   2) Perform copy/constant propagation.\n-\n-   3) Perform global cse using lazy code motion if not optimizing\n-      for size, or code hoisting if we are.\n-\n-   4) Perform another pass of copy/constant propagation.  Try to bypass\n-      conditional jumps if the condition can be computed from a value of\n-      an incoming edge.\n-\n-   Two passes of copy/constant propagation are done because the first one\n-   enables more GCSE and the second one helps to clean up the copies that\n-   GCSE creates.  This is needed more for PRE than for Classic because Classic\n-   GCSE will try to use an existing register containing the common\n-   subexpression rather than create a new one.  This is harder to do for PRE\n-   because of the code motion (which Classic GCSE doesn't do).\n+   Two passes of copy/constant propagation are done around PRE or hoisting\n+   because the first one enables more GCSE and the second one helps to clean\n+   up the copies that PRE and HOIST create.  This is needed more for PRE than\n+   for HOIST because code hoisting will try to use an existing register\n+   containing the common subexpression rather than create a new one.  This is\n+   harder to do for PRE because of the code motion (which HOIST doesn't do).\n \n    Expressions we are interested in GCSE-ing are of the form\n    (set (pseudo-reg) (expression)).\n@@ -333,7 +319,7 @@ typedef struct occr *occr_t;\n DEF_VEC_P (occr_t);\n DEF_VEC_ALLOC_P (occr_t, heap);\n \n-/* Expression and copy propagation hash tables.\n+/* Expression hash tables.\n    Each hash table is an array of buckets.\n    ??? It is known that if it were an array of entries, structure elements\n    `next_same_hash' and `bitmap_index' wouldn't be necessary.  However, it is\n@@ -353,17 +339,11 @@ struct hash_table_d\n \n   /* Number of hash table elements.  */\n   unsigned int n_elems;\n-\n-  /* Whether the table is expression of copy propagation one.  */\n-  int set_p;\n };\n \n /* Expression hash table.  */\n static struct hash_table_d expr_hash_table;\n \n-/* Copy propagation hash table.  */\n-static struct hash_table_d set_hash_table;\n-\n /* This is a list of expressions which are MEMs and will be used by load\n    or store motion.\n    Load motion tracks MEMs which aren't killed by\n@@ -389,9 +369,6 @@ struct ls_expr\n   rtx reaching_reg;\t\t/* Register to use when re-writing.  */\n };\n \n-/* Array of implicit set patterns indexed by basic block index.  */\n-static rtx *implicit_sets;\n-\n /* Head of the list of load/store memory refs.  */\n static struct ls_expr * pre_ldst_mems = NULL;\n \n@@ -426,14 +403,6 @@ static int bytes_used;\n static int gcse_subst_count;\n /* Number of copy instructions created.  */\n static int gcse_create_count;\n-/* Number of local constants propagated.  */\n-static int local_const_prop_count;\n-/* Number of local copies propagated.  */\n-static int local_copy_prop_count;\n-/* Number of global constants propagated.  */\n-static int global_const_prop_count;\n-/* Number of global copies propagated.  */\n-static int global_copy_prop_count;\n \f\n /* Doing code hoisting.  */\n static bool doing_code_hoisting_p = false;\n@@ -452,53 +421,27 @@ static void hash_scan_set (rtx, rtx, struct hash_table_d *);\n static void hash_scan_clobber (rtx, rtx, struct hash_table_d *);\n static void hash_scan_call (rtx, rtx, struct hash_table_d *);\n static int want_to_gcse_p (rtx, int *);\n-static bool gcse_constant_p (const_rtx);\n static int oprs_unchanged_p (const_rtx, const_rtx, int);\n static int oprs_anticipatable_p (const_rtx, const_rtx);\n static int oprs_available_p (const_rtx, const_rtx);\n static void insert_expr_in_table (rtx, enum machine_mode, rtx, int, int, int,\n \t\t\t\t  struct hash_table_d *);\n-static void insert_set_in_table (rtx, rtx, struct hash_table_d *);\n static unsigned int hash_expr (const_rtx, enum machine_mode, int *, int);\n-static unsigned int hash_set (int, int);\n static int expr_equiv_p (const_rtx, const_rtx);\n static void record_last_reg_set_info (rtx, int);\n static void record_last_mem_set_info (rtx);\n static void record_last_set_info (rtx, const_rtx, void *);\n static void compute_hash_table (struct hash_table_d *);\n-static void alloc_hash_table (struct hash_table_d *, int);\n+static void alloc_hash_table (struct hash_table_d *);\n static void free_hash_table (struct hash_table_d *);\n static void compute_hash_table_work (struct hash_table_d *);\n static void dump_hash_table (FILE *, const char *, struct hash_table_d *);\n-static struct expr *lookup_set (unsigned int, struct hash_table_d *);\n-static struct expr *next_set (unsigned int, struct expr *);\n-static void reset_opr_set_tables (void);\n-static int oprs_not_set_p (const_rtx, const_rtx);\n-static void mark_call (rtx);\n-static void mark_set (rtx, rtx);\n-static void mark_clobber (rtx, rtx);\n-static void mark_oprs_set (rtx);\n-static void alloc_cprop_mem (int, int);\n-static void free_cprop_mem (void);\n-static void compute_transp (const_rtx, int, sbitmap *, int);\n+static void compute_transp (const_rtx, int, sbitmap *);\n static void compute_local_properties (sbitmap *, sbitmap *, sbitmap *,\n \t\t\t\t      struct hash_table_d *);\n-static void compute_cprop_data (void);\n-static void find_used_regs (rtx *, void *);\n-static int try_replace_reg (rtx, rtx, rtx);\n-static struct expr *find_avail_set (int, rtx);\n-static int cprop_jump (basic_block, rtx, rtx, rtx, rtx);\n static void mems_conflict_for_gcse_p (rtx, const_rtx, void *);\n static int load_killed_in_block_p (const_basic_block, int, const_rtx, int);\n static void canon_list_insert (rtx, const_rtx, void *);\n-static int cprop_insn (rtx);\n-static void find_implicit_sets (void);\n-static int one_cprop_pass (void);\n-static bool constprop_register (rtx, rtx, rtx);\n-static struct expr *find_bypass_set (int, int);\n-static bool reg_killed_on_edge (const_rtx, const_edge);\n-static int bypass_block (basic_block, rtx, rtx);\n-static int bypass_conditional_jumps (void);\n static void alloc_pre_mem (int, int);\n static void free_pre_mem (void);\n static void compute_pre_data (void);\n@@ -539,9 +482,6 @@ static void free_insn_expr_list_list (rtx *);\n static void clear_modify_mem_tables (void);\n static void free_modify_mem_tables (void);\n static rtx gcse_emit_move_after (rtx, rtx, rtx);\n-static void local_cprop_find_used_regs (rtx *, void *);\n-static bool do_local_cprop (rtx, rtx);\n-static int local_cprop_pass (void);\n static bool is_too_expensive (const char *);\n \n #define GNEW(T)\t\t\t((T *) gmalloc (sizeof (T)))\n@@ -680,16 +620,14 @@ free_gcse_mem (void)\n    least once and expression would contain the same value if the computation\n    was moved to the beginning of the block.\n \n-   We call this routine for cprop, pre and code hoisting.  They all compute\n+   We call this routine for pre and code hoisting.  They all compute\n    basically the same information and thus can easily share this code.\n \n    TRANSP, COMP, and ANTLOC are destination sbitmaps for recording local\n    properties.  If NULL, then it is not necessary to compute or record that\n    particular property.\n \n-   TABLE controls which hash table to look at.  If it is  set hash table,\n-   additionally, TRANSP is computed as ~TRANSP, since this is really cprop's\n-   ABSALTERED.  */\n+   TABLE controls which hash table to look at.  */\n \n static void\n compute_local_properties (sbitmap *transp, sbitmap *comp, sbitmap *antloc,\n@@ -700,10 +638,7 @@ compute_local_properties (sbitmap *transp, sbitmap *comp, sbitmap *antloc,\n   /* Initialize any bitmaps that were passed in.  */\n   if (transp)\n     {\n-      if (table->set_p)\n-\tsbitmap_vector_zero (transp, last_basic_block);\n-      else\n-\tsbitmap_vector_ones (transp, last_basic_block);\n+      sbitmap_vector_ones (transp, last_basic_block);\n     }\n \n   if (comp)\n@@ -724,7 +659,7 @@ compute_local_properties (sbitmap *transp, sbitmap *comp, sbitmap *antloc,\n \t     We start by assuming all are transparent [none are killed], and\n \t     then reset the bits for those that are.  */\n \t  if (transp)\n-\t    compute_transp (expr->expr, indx, transp, table->set_p);\n+\t    compute_transp (expr->expr, indx, transp);\n \n \t  /* The occurrences recorded in antic_occr are exactly those that\n \t     we want to set to nonzero in ANTLOC.  */\n@@ -1126,22 +1061,6 @@ hash_expr (const_rtx x, enum machine_mode mode, int *do_not_record_p,\n   return hash % hash_table_size;\n }\n \n-/* Hash a set of register REGNO.\n-\n-   Sets are hashed on the register that is set.  This simplifies the PRE copy\n-   propagation code.\n-\n-   ??? May need to make things more elaborate.  Later, as necessary.  */\n-\n-static unsigned int\n-hash_set (int regno, int hash_table_size)\n-{\n-  unsigned int hash;\n-\n-  hash = regno;\n-  return hash % hash_table_size;\n-}\n-\n /* Return nonzero if exp1 is equivalent to exp2.  */\n \n static int\n@@ -1266,109 +1185,7 @@ insert_expr_in_table (rtx x, enum machine_mode mode, rtx insn, int antic_p,\n     }\n }\n \n-/* Insert pattern X in INSN in the hash table.\n-   X is a SET of a reg to either another reg or a constant.\n-   If it is already present, record it as the last occurrence in INSN's\n-   basic block.  */\n-\n-static void\n-insert_set_in_table (rtx x, rtx insn, struct hash_table_d *table)\n-{\n-  int found;\n-  unsigned int hash;\n-  struct expr *cur_expr, *last_expr = NULL;\n-  struct occr *cur_occr;\n-\n-  gcc_assert (GET_CODE (x) == SET && REG_P (SET_DEST (x)));\n-\n-  hash = hash_set (REGNO (SET_DEST (x)), table->size);\n-\n-  cur_expr = table->table[hash];\n-  found = 0;\n-\n-  while (cur_expr && 0 == (found = expr_equiv_p (cur_expr->expr, x)))\n-    {\n-      /* If the expression isn't found, save a pointer to the end of\n-\t the list.  */\n-      last_expr = cur_expr;\n-      cur_expr = cur_expr->next_same_hash;\n-    }\n-\n-  if (! found)\n-    {\n-      cur_expr = GOBNEW (struct expr);\n-      bytes_used += sizeof (struct expr);\n-      if (table->table[hash] == NULL)\n-\t/* This is the first pattern that hashed to this index.  */\n-\ttable->table[hash] = cur_expr;\n-      else\n-\t/* Add EXPR to end of this hash chain.  */\n-\tlast_expr->next_same_hash = cur_expr;\n-\n-      /* Set the fields of the expr element.\n-\t We must copy X because it can be modified when copy propagation is\n-\t performed on its operands.  */\n-      cur_expr->expr = copy_rtx (x);\n-      cur_expr->bitmap_index = table->n_elems++;\n-      cur_expr->next_same_hash = NULL;\n-      cur_expr->antic_occr = NULL;\n-      cur_expr->avail_occr = NULL;\n-      /* Not used for set_p tables.  */\n-      cur_expr->max_distance = 0;\n-    }\n-\n-  /* Now record the occurrence.  */\n-  cur_occr = cur_expr->avail_occr;\n-\n-  if (cur_occr\n-      && BLOCK_FOR_INSN (cur_occr->insn) == BLOCK_FOR_INSN (insn))\n-    {\n-      /* Found another instance of the expression in the same basic block.\n-\t Prefer this occurrence to the currently recorded one.  We want\n-\t the last one in the block and the block is scanned from start\n-\t to end.  */\n-      cur_occr->insn = insn;\n-    }\n-  else\n-    {\n-      /* First occurrence of this expression in this basic block.  */\n-      cur_occr = GOBNEW (struct occr);\n-      bytes_used += sizeof (struct occr);\n-      cur_occr->insn = insn;\n-      cur_occr->next = cur_expr->avail_occr;\n-      cur_occr->deleted_p = 0;\n-      cur_expr->avail_occr = cur_occr;\n-    }\n-}\n-\n-/* Determine whether the rtx X should be treated as a constant for\n-   the purposes of GCSE's constant propagation.  */\n-\n-static bool\n-gcse_constant_p (const_rtx x)\n-{\n-  /* Consider a COMPARE of two integers constant.  */\n-  if (GET_CODE (x) == COMPARE\n-      && CONST_INT_P (XEXP (x, 0))\n-      && CONST_INT_P (XEXP (x, 1)))\n-    return true;\n-\n-  /* Consider a COMPARE of the same registers is a constant\n-     if they are not floating point registers.  */\n-  if (GET_CODE(x) == COMPARE\n-      && REG_P (XEXP (x, 0)) && REG_P (XEXP (x, 1))\n-      && REGNO (XEXP (x, 0)) == REGNO (XEXP (x, 1))\n-      && ! FLOAT_MODE_P (GET_MODE (XEXP (x, 0)))\n-      && ! FLOAT_MODE_P (GET_MODE (XEXP (x, 1))))\n-    return true;\n-\n-  /* Since X might be inserted more than once we have to take care that it\n-     is sharable.  */\n-  return CONSTANT_P (x) && (GET_CODE (x) != CONST || shared_const_p (x));\n-}\n-\n-/* Scan pattern PAT of INSN and add an entry to the hash TABLE (set or\n-   expression one).  */\n+/* Scan pattern PAT of INSN and add an entry to the hash TABLE.  */\n \n static void\n hash_scan_set (rtx pat, rtx insn, struct hash_table_d *table)\n@@ -1383,7 +1200,6 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table_d *table)\n   else if (REG_P (dest))\n     {\n       unsigned int regno = REGNO (dest);\n-      rtx tmp;\n       int max_distance = 0;\n \n       /* See if a REG_EQUAL note shows this equivalent to a simpler expression.\n@@ -1392,7 +1208,7 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table_d *table)\n \t redundant constants, addresses or other expressions that are\n \t constructed with multiple instructions.\n \n-\t However, keep the original SRC if INSN is a simple reg-reg move.  In\n+\t However, keep the original SRC if INSN is a simple reg-reg move.\n \t In this case, there will almost always be a REG_EQUAL note on the\n \t insn that sets SRC.  By recording the REG_EQUAL value here as SRC\n \t for INSN, we miss copy propagation opportunities and we perform the\n@@ -1405,14 +1221,11 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table_d *table)\n       if (note != 0\n \t  && REG_NOTE_KIND (note) == REG_EQUAL\n \t  && !REG_P (src)\n-\t  && (table->set_p\n-\t      ? gcse_constant_p (XEXP (note, 0))\n-\t      : want_to_gcse_p (XEXP (note, 0), NULL)))\n+\t  && want_to_gcse_p (XEXP (note, 0), NULL))\n \tsrc = XEXP (note, 0), pat = gen_rtx_SET (VOIDmode, dest, src);\n \n       /* Only record sets of pseudo-regs in the hash table.  */\n-      if (! table->set_p\n-\t  && regno >= FIRST_PSEUDO_REGISTER\n+      if (regno >= FIRST_PSEUDO_REGISTER\n \t  /* Don't GCSE something if we can't do a reg/reg copy.  */\n \t  && can_copy_p (GET_MODE (dest))\n \t  /* GCSE commonly inserts instruction after the insn.  We can't\n@@ -1449,23 +1262,6 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table_d *table)\n \t  insert_expr_in_table (src, GET_MODE (dest), insn, antic_p, avail_p,\n \t\t\t\tmax_distance, table);\n \t}\n-\n-      /* Record sets for constant/copy propagation.  */\n-      else if (table->set_p\n-\t       && regno >= FIRST_PSEUDO_REGISTER\n-\t       && ((REG_P (src)\n-\t\t    && REGNO (src) >= FIRST_PSEUDO_REGISTER\n-\t\t    && can_copy_p (GET_MODE (dest))\n-\t\t    && REGNO (src) != regno)\n-\t\t   || gcse_constant_p (src))\n-\t       /* A copy is not available if its src or dest is subsequently\n-\t\t  modified.  Here we want to search from INSN+1 on, but\n-\t\t  oprs_available_p searches from INSN on.  */\n-\t       && (insn == BB_END (BLOCK_FOR_INSN (insn))\n-\t\t   || (tmp = next_nonnote_nondebug_insn (insn)) == NULL_RTX\n-\t\t   || BLOCK_FOR_INSN (tmp) != BLOCK_FOR_INSN (insn)\n-\t\t   || oprs_available_p (pat, tmp)))\n-\tinsert_set_in_table (pat, insn, table);\n     }\n   /* In case of store we want to consider the memory value as available in\n      the REG stored in that memory. This makes it possible to remove\n@@ -1475,10 +1271,8 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table_d *table)\n         unsigned int regno = REGNO (src);\n \tint max_distance = 0;\n \n-        /* Do not do this for constant/copy propagation.  */\n-        if (! table->set_p\n-            /* Only record sets of pseudo-regs in the hash table.  */\n-\t    && regno >= FIRST_PSEUDO_REGISTER\n+\t/* Only record sets of pseudo-regs in the hash table.  */\n+        if (regno >= FIRST_PSEUDO_REGISTER\n \t   /* Don't GCSE something if we can't do a reg/reg copy.  */\n \t   && can_copy_p (GET_MODE (src))\n \t   /* GCSE commonly inserts instruction after the insn.  We can't\n@@ -1712,18 +1506,13 @@ record_last_set_info (rtx dest, const_rtx setter ATTRIBUTE_UNUSED, void *data)\n     record_last_mem_set_info (last_set_insn);\n }\n \n-/* Top level function to create an expression or assignment hash table.\n+/* Top level function to create an expression hash table.\n \n    Expression entries are placed in the hash table if\n    - they are of the form (set (pseudo-reg) src),\n    - src is something we want to perform GCSE on,\n    - none of the operands are subsequently modified in the block\n \n-   Assignment entries are placed in the hash table if\n-   - they are of the form (set (pseudo-reg) src),\n-   - src is something we want to perform const/copy propagation on,\n-   - none of the operands or target are subsequently modified in the block\n-\n    Currently src must be a pseudo-reg or a const_int.\n \n    TABLE is the table computed.  */\n@@ -1759,18 +1548,13 @@ compute_hash_table_work (struct hash_table_d *table)\n \t\tif (TEST_HARD_REG_BIT (regs_invalidated_by_call, regno))\n \t\t  record_last_reg_set_info (insn, regno);\n \n-\t      mark_call (insn);\n+\t      if (! RTL_CONST_OR_PURE_CALL_P (insn))\n+\t\trecord_last_mem_set_info (insn);\n \t    }\n \n \t  note_stores (PATTERN (insn), record_last_set_info, insn);\n \t}\n \n-      /* Insert implicit sets in the hash table.  */\n-      if (table->set_p\n-\t  && implicit_sets[current_bb->index] != NULL_RTX)\n-\thash_scan_set (implicit_sets[current_bb->index],\n-\t\t       BB_HEAD (current_bb), table);\n-\n       /* The next pass builds the hash table.  */\n       FOR_BB_INSNS (current_bb, insn)\n \tif (NONDEBUG_INSN_P (insn))\n@@ -1782,12 +1566,10 @@ compute_hash_table_work (struct hash_table_d *table)\n }\n \n /* Allocate space for the set/expr hash TABLE.\n-   It is used to determine the number of buckets to use.\n-   SET_P determines whether set or expression table will\n-   be created.  */\n+   It is used to determine the number of buckets to use.  */\n \n static void\n-alloc_hash_table (struct hash_table_d *table, int set_p)\n+alloc_hash_table (struct hash_table_d *table)\n {\n   int n;\n \n@@ -1803,7 +1585,6 @@ alloc_hash_table (struct hash_table_d *table, int set_p)\n   table->size |= 1;\n   n = table->size * sizeof (struct expr *);\n   table->table = GNEWVAR (struct expr *, n);\n-  table->set_p = set_p;\n }\n \n /* Free things allocated by alloc_hash_table.  */\n@@ -1814,8 +1595,7 @@ free_hash_table (struct hash_table_d *table)\n   free (table->table);\n }\n \n-/* Compute the hash TABLE for doing copy/const propagation or\n-   expression hash table.  */\n+/* Compute the expression hash table TABLE.  */\n \n static void\n compute_hash_table (struct hash_table_d *table)\n@@ -1829,35 +1609,6 @@ compute_hash_table (struct hash_table_d *table)\n \f\n /* Expression tracking support.  */\n \n-/* Lookup REGNO in the set TABLE.  The result is a pointer to the\n-   table entry, or NULL if not found.  */\n-\n-static struct expr *\n-lookup_set (unsigned int regno, struct hash_table_d *table)\n-{\n-  unsigned int hash = hash_set (regno, table->size);\n-  struct expr *expr;\n-\n-  expr = table->table[hash];\n-\n-  while (expr && REGNO (SET_DEST (expr->expr)) != regno)\n-    expr = expr->next_same_hash;\n-\n-  return expr;\n-}\n-\n-/* Return the next entry for REGNO in list EXPR.  */\n-\n-static struct expr *\n-next_set (unsigned int regno, struct expr *expr)\n-{\n-  do\n-    expr = expr->next_same_hash;\n-  while (expr && REGNO (SET_DEST (expr->expr)) != regno);\n-\n-  return expr;\n-}\n-\n /* Like free_INSN_LIST_list or free_EXPR_LIST_list, except that the node\n    types may be mixed.  */\n \n@@ -1873,1372 +1624,156 @@ free_insn_expr_list_list (rtx *listp)\n \tfree_EXPR_LIST_node (list);\n       else\n \tfree_INSN_LIST_node (list);\n-    }\n-\n-  *listp = NULL;\n-}\n-\n-/* Clear canon_modify_mem_list and modify_mem_list tables.  */\n-static void\n-clear_modify_mem_tables (void)\n-{\n-  unsigned i;\n-  bitmap_iterator bi;\n-\n-  EXECUTE_IF_SET_IN_BITMAP (modify_mem_list_set, 0, i, bi)\n-    {\n-      free_INSN_LIST_list (modify_mem_list + i);\n-      free_insn_expr_list_list (canon_modify_mem_list + i);\n-    }\n-  bitmap_clear (modify_mem_list_set);\n-  bitmap_clear (blocks_with_calls);\n-}\n-\n-/* Release memory used by modify_mem_list_set.  */\n-\n-static void\n-free_modify_mem_tables (void)\n-{\n-  clear_modify_mem_tables ();\n-  free (modify_mem_list);\n-  free (canon_modify_mem_list);\n-  modify_mem_list = 0;\n-  canon_modify_mem_list = 0;\n-}\n-\n-/* Reset tables used to keep track of what's still available [since the\n-   start of the block].  */\n-\n-static void\n-reset_opr_set_tables (void)\n-{\n-  /* Maintain a bitmap of which regs have been set since beginning of\n-     the block.  */\n-  CLEAR_REG_SET (reg_set_bitmap);\n-\n-  /* Also keep a record of the last instruction to modify memory.\n-     For now this is very trivial, we only record whether any memory\n-     location has been modified.  */\n-  clear_modify_mem_tables ();\n-}\n-\n-/* Return nonzero if the operands of X are not set before INSN in\n-   INSN's basic block.  */\n-\n-static int\n-oprs_not_set_p (const_rtx x, const_rtx insn)\n-{\n-  int i, j;\n-  enum rtx_code code;\n-  const char *fmt;\n-\n-  if (x == 0)\n-    return 1;\n-\n-  code = GET_CODE (x);\n-  switch (code)\n-    {\n-    case PC:\n-    case CC0:\n-    case CONST:\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-    case CONST_FIXED:\n-    case CONST_VECTOR:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-    case ADDR_VEC:\n-    case ADDR_DIFF_VEC:\n-      return 1;\n-\n-    case MEM:\n-      if (load_killed_in_block_p (BLOCK_FOR_INSN (insn),\n-\t\t\t\t  DF_INSN_LUID (insn), x, 0))\n-\treturn 0;\n-      else\n-\treturn oprs_not_set_p (XEXP (x, 0), insn);\n-\n-    case REG:\n-      return ! REGNO_REG_SET_P (reg_set_bitmap, REGNO (x));\n-\n-    default:\n-      break;\n-    }\n-\n-  for (i = GET_RTX_LENGTH (code) - 1, fmt = GET_RTX_FORMAT (code); i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\t{\n-\t  /* If we are about to do the last recursive call\n-\t     needed at this level, change it into iteration.\n-\t     This function is called enough to be worth it.  */\n-\t  if (i == 0)\n-\t    return oprs_not_set_p (XEXP (x, i), insn);\n-\n-\t  if (! oprs_not_set_p (XEXP (x, i), insn))\n-\t    return 0;\n-\t}\n-      else if (fmt[i] == 'E')\n-\tfor (j = 0; j < XVECLEN (x, i); j++)\n-\t  if (! oprs_not_set_p (XVECEXP (x, i, j), insn))\n-\t    return 0;\n-    }\n-\n-  return 1;\n-}\n-\n-/* Mark things set by a CALL.  */\n-\n-static void\n-mark_call (rtx insn)\n-{\n-  if (! RTL_CONST_OR_PURE_CALL_P (insn))\n-    record_last_mem_set_info (insn);\n-}\n-\n-/* Mark things set by a SET.  */\n-\n-static void\n-mark_set (rtx pat, rtx insn)\n-{\n-  rtx dest = SET_DEST (pat);\n-\n-  while (GET_CODE (dest) == SUBREG\n-\t || GET_CODE (dest) == ZERO_EXTRACT\n-\t || GET_CODE (dest) == STRICT_LOW_PART)\n-    dest = XEXP (dest, 0);\n-\n-  if (REG_P (dest))\n-    SET_REGNO_REG_SET (reg_set_bitmap, REGNO (dest));\n-  else if (MEM_P (dest))\n-    record_last_mem_set_info (insn);\n-\n-  if (GET_CODE (SET_SRC (pat)) == CALL)\n-    mark_call (insn);\n-}\n-\n-/* Record things set by a CLOBBER.  */\n-\n-static void\n-mark_clobber (rtx pat, rtx insn)\n-{\n-  rtx clob = XEXP (pat, 0);\n-\n-  while (GET_CODE (clob) == SUBREG || GET_CODE (clob) == STRICT_LOW_PART)\n-    clob = XEXP (clob, 0);\n-\n-  if (REG_P (clob))\n-    SET_REGNO_REG_SET (reg_set_bitmap, REGNO (clob));\n-  else\n-    record_last_mem_set_info (insn);\n-}\n-\n-/* Record things set by INSN.\n-   This data is used by oprs_not_set_p.  */\n-\n-static void\n-mark_oprs_set (rtx insn)\n-{\n-  rtx pat = PATTERN (insn);\n-  int i;\n-\n-  if (GET_CODE (pat) == SET)\n-    mark_set (pat, insn);\n-  else if (GET_CODE (pat) == PARALLEL)\n-    for (i = 0; i < XVECLEN (pat, 0); i++)\n-      {\n-\trtx x = XVECEXP (pat, 0, i);\n-\n-\tif (GET_CODE (x) == SET)\n-\t  mark_set (x, insn);\n-\telse if (GET_CODE (x) == CLOBBER)\n-\t  mark_clobber (x, insn);\n-\telse if (GET_CODE (x) == CALL)\n-\t  mark_call (insn);\n-      }\n-\n-  else if (GET_CODE (pat) == CLOBBER)\n-    mark_clobber (pat, insn);\n-  else if (GET_CODE (pat) == CALL)\n-    mark_call (insn);\n-}\n-\n-\f\n-/* Compute copy/constant propagation working variables.  */\n-\n-/* Local properties of assignments.  */\n-static sbitmap *cprop_pavloc;\n-static sbitmap *cprop_absaltered;\n-\n-/* Global properties of assignments (computed from the local properties).  */\n-static sbitmap *cprop_avin;\n-static sbitmap *cprop_avout;\n-\n-/* Allocate vars used for copy/const propagation.  N_BLOCKS is the number of\n-   basic blocks.  N_SETS is the number of sets.  */\n-\n-static void\n-alloc_cprop_mem (int n_blocks, int n_sets)\n-{\n-  cprop_pavloc = sbitmap_vector_alloc (n_blocks, n_sets);\n-  cprop_absaltered = sbitmap_vector_alloc (n_blocks, n_sets);\n-\n-  cprop_avin = sbitmap_vector_alloc (n_blocks, n_sets);\n-  cprop_avout = sbitmap_vector_alloc (n_blocks, n_sets);\n-}\n-\n-/* Free vars used by copy/const propagation.  */\n-\n-static void\n-free_cprop_mem (void)\n-{\n-  sbitmap_vector_free (cprop_pavloc);\n-  sbitmap_vector_free (cprop_absaltered);\n-  sbitmap_vector_free (cprop_avin);\n-  sbitmap_vector_free (cprop_avout);\n-}\n-\n-/* For each block, compute whether X is transparent.  X is either an\n-   expression or an assignment [though we don't care which, for this context\n-   an assignment is treated as an expression].  For each block where an\n-   element of X is modified, set (SET_P == 1) or reset (SET_P == 0) the INDX\n-   bit in BMAP.  */\n-\n-static void\n-compute_transp (const_rtx x, int indx, sbitmap *bmap, int set_p)\n-{\n-  int i, j;\n-  enum rtx_code code;\n-  const char *fmt;\n-\n-  /* repeat is used to turn tail-recursion into iteration since GCC\n-     can't do it when there's no return value.  */\n- repeat:\n-\n-  if (x == 0)\n-    return;\n-\n-  code = GET_CODE (x);\n-  switch (code)\n-    {\n-    case REG:\n-      if (set_p)\n-\t{\n-\t  df_ref def;\n-\t  for (def = DF_REG_DEF_CHAIN (REGNO (x));\n-\t       def;\n-\t       def = DF_REF_NEXT_REG (def))\n-\t    SET_BIT (bmap[DF_REF_BB (def)->index], indx);\n-\t}\n-      else\n-\t{\n-\t  df_ref def;\n-\t  for (def = DF_REG_DEF_CHAIN (REGNO (x));\n-\t       def;\n-\t       def = DF_REF_NEXT_REG (def))\n-\t    RESET_BIT (bmap[DF_REF_BB (def)->index], indx);\n-\t}\n-\n-      return;\n-\n-    case MEM:\n-      if (! MEM_READONLY_P (x))\n-\t{\n-\t  bitmap_iterator bi;\n-\t  unsigned bb_index;\n-\n-\t  /* First handle all the blocks with calls.  We don't need to\n-\t     do any list walking for them.  */\n-\t  EXECUTE_IF_SET_IN_BITMAP (blocks_with_calls, 0, bb_index, bi)\n-\t    {\n-\t      if (set_p)\n-\t\tSET_BIT (bmap[bb_index], indx);\n-\t      else\n-\t\tRESET_BIT (bmap[bb_index], indx);\n-\t    }\n-\n-\t    /* Now iterate over the blocks which have memory modifications\n-\t       but which do not have any calls.  */\n-\t    EXECUTE_IF_AND_COMPL_IN_BITMAP (modify_mem_list_set,\n-\t\t\t\t\t    blocks_with_calls,\n-\t\t\t\t\t    0, bb_index, bi)\n-\t      {\n-\t\trtx list_entry = canon_modify_mem_list[bb_index];\n-\n-\t\twhile (list_entry)\n-\t\t  {\n-\t\t    rtx dest, dest_addr;\n-\n-\t\t    /* LIST_ENTRY must be an INSN of some kind that sets memory.\n-\t\t       Examine each hunk of memory that is modified.  */\n-\n-\t\t    dest = XEXP (list_entry, 0);\n-\t\t    list_entry = XEXP (list_entry, 1);\n-\t\t    dest_addr = XEXP (list_entry, 0);\n-\n-\t\t    if (canon_true_dependence (dest, GET_MODE (dest), dest_addr,\n-\t\t\t\t\t       x, NULL_RTX, rtx_addr_varies_p))\n-\t\t      {\n-\t\t\tif (set_p)\n-\t\t\t  SET_BIT (bmap[bb_index], indx);\n-\t\t\telse\n-\t\t\t  RESET_BIT (bmap[bb_index], indx);\n-\t\t\tbreak;\n-\t\t      }\n-\t\t    list_entry = XEXP (list_entry, 1);\n-\t          }\n-\t      }\n-\t}\n-\n-      x = XEXP (x, 0);\n-      goto repeat;\n-\n-    case PC:\n-    case CC0: /*FIXME*/\n-    case CONST:\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-    case CONST_FIXED:\n-    case CONST_VECTOR:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-    case ADDR_VEC:\n-    case ADDR_DIFF_VEC:\n-      return;\n-\n-    default:\n-      break;\n-    }\n-\n-  for (i = GET_RTX_LENGTH (code) - 1, fmt = GET_RTX_FORMAT (code); i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\t{\n-\t  /* If we are about to do the last recursive call\n-\t     needed at this level, change it into iteration.\n-\t     This function is called enough to be worth it.  */\n-\t  if (i == 0)\n-\t    {\n-\t      x = XEXP (x, i);\n-\t      goto repeat;\n-\t    }\n-\n-\t  compute_transp (XEXP (x, i), indx, bmap, set_p);\n-\t}\n-      else if (fmt[i] == 'E')\n-\tfor (j = 0; j < XVECLEN (x, i); j++)\n-\t  compute_transp (XVECEXP (x, i, j), indx, bmap, set_p);\n-    }\n-}\n-\n-/* Top level routine to do the dataflow analysis needed by copy/const\n-   propagation.  */\n-\n-static void\n-compute_cprop_data (void)\n-{\n-  compute_local_properties (cprop_absaltered, cprop_pavloc, NULL, &set_hash_table);\n-  compute_available (cprop_pavloc, cprop_absaltered,\n-\t\t     cprop_avout, cprop_avin);\n-}\n-\f\n-/* Copy/constant propagation.  */\n-\n-/* Maximum number of register uses in an insn that we handle.  */\n-#define MAX_USES 8\n-\n-/* Table of uses found in an insn.\n-   Allocated statically to avoid alloc/free complexity and overhead.  */\n-static struct reg_use reg_use_table[MAX_USES];\n-\n-/* Index into `reg_use_table' while building it.  */\n-static int reg_use_count;\n-\n-/* Set up a list of register numbers used in INSN.  The found uses are stored\n-   in `reg_use_table'.  `reg_use_count' is initialized to zero before entry,\n-   and contains the number of uses in the table upon exit.\n-\n-   ??? If a register appears multiple times we will record it multiple times.\n-   This doesn't hurt anything but it will slow things down.  */\n-\n-static void\n-find_used_regs (rtx *xptr, void *data ATTRIBUTE_UNUSED)\n-{\n-  int i, j;\n-  enum rtx_code code;\n-  const char *fmt;\n-  rtx x = *xptr;\n-\n-  /* repeat is used to turn tail-recursion into iteration since GCC\n-     can't do it when there's no return value.  */\n- repeat:\n-  if (x == 0)\n-    return;\n-\n-  code = GET_CODE (x);\n-  if (REG_P (x))\n-    {\n-      if (reg_use_count == MAX_USES)\n-\treturn;\n-\n-      reg_use_table[reg_use_count].reg_rtx = x;\n-      reg_use_count++;\n-    }\n-\n-  /* Recursively scan the operands of this expression.  */\n-\n-  for (i = GET_RTX_LENGTH (code) - 1, fmt = GET_RTX_FORMAT (code); i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\t{\n-\t  /* If we are about to do the last recursive call\n-\t     needed at this level, change it into iteration.\n-\t     This function is called enough to be worth it.  */\n-\t  if (i == 0)\n-\t    {\n-\t      x = XEXP (x, 0);\n-\t      goto repeat;\n-\t    }\n-\n-\t  find_used_regs (&XEXP (x, i), data);\n-\t}\n-      else if (fmt[i] == 'E')\n-\tfor (j = 0; j < XVECLEN (x, i); j++)\n-\t  find_used_regs (&XVECEXP (x, i, j), data);\n-    }\n-}\n-\n-/* Try to replace all non-SET_DEST occurrences of FROM in INSN with TO.\n-   Returns nonzero is successful.  */\n-\n-static int\n-try_replace_reg (rtx from, rtx to, rtx insn)\n-{\n-  rtx note = find_reg_equal_equiv_note (insn);\n-  rtx src = 0;\n-  int success = 0;\n-  rtx set = single_set (insn);\n-\n-  /* Usually we substitute easy stuff, so we won't copy everything.\n-     We however need to take care to not duplicate non-trivial CONST\n-     expressions.  */\n-  to = copy_rtx (to);\n-\n-  validate_replace_src_group (from, to, insn);\n-  if (num_changes_pending () && apply_change_group ())\n-    success = 1;\n-\n-  /* Try to simplify SET_SRC if we have substituted a constant.  */\n-  if (success && set && CONSTANT_P (to))\n-    {\n-      src = simplify_rtx (SET_SRC (set));\n-\n-      if (src)\n-\tvalidate_change (insn, &SET_SRC (set), src, 0);\n-    }\n-\n-  /* If there is already a REG_EQUAL note, update the expression in it\n-     with our replacement.  */\n-  if (note != 0 && REG_NOTE_KIND (note) == REG_EQUAL)\n-    set_unique_reg_note (insn, REG_EQUAL,\n-\t\t\t simplify_replace_rtx (XEXP (note, 0), from, to));\n-  if (!success && set && reg_mentioned_p (from, SET_SRC (set)))\n-    {\n-      /* If above failed and this is a single set, try to simplify the source of\n-\t the set given our substitution.  We could perhaps try this for multiple\n-\t SETs, but it probably won't buy us anything.  */\n-      src = simplify_replace_rtx (SET_SRC (set), from, to);\n-\n-      if (!rtx_equal_p (src, SET_SRC (set))\n-\t  && validate_change (insn, &SET_SRC (set), src, 0))\n-\tsuccess = 1;\n-\n-      /* If we've failed perform the replacement, have a single SET to\n-\t a REG destination and don't yet have a note, add a REG_EQUAL note\n-\t to not lose information.  */\n-      if (!success && note == 0 && set != 0 && REG_P (SET_DEST (set)))\n-\tnote = set_unique_reg_note (insn, REG_EQUAL, copy_rtx (src));\n-    }\n-\n-  /* REG_EQUAL may get simplified into register.\n-     We don't allow that. Remove that note. This code ought\n-     not to happen, because previous code ought to synthesize\n-     reg-reg move, but be on the safe side.  */\n-  if (note && REG_NOTE_KIND (note) == REG_EQUAL && REG_P (XEXP (note, 0)))\n-    remove_note (insn, note);\n-\n-  return success;\n-}\n-\n-/* Find a set of REGNOs that are available on entry to INSN's block.  Returns\n-   NULL no such set is found.  */\n-\n-static struct expr *\n-find_avail_set (int regno, rtx insn)\n-{\n-  /* SET1 contains the last set found that can be returned to the caller for\n-     use in a substitution.  */\n-  struct expr *set1 = 0;\n-\n-  /* Loops are not possible here.  To get a loop we would need two sets\n-     available at the start of the block containing INSN.  i.e. we would\n-     need two sets like this available at the start of the block:\n-\n-       (set (reg X) (reg Y))\n-       (set (reg Y) (reg X))\n-\n-     This can not happen since the set of (reg Y) would have killed the\n-     set of (reg X) making it unavailable at the start of this block.  */\n-  while (1)\n-    {\n-      rtx src;\n-      struct expr *set = lookup_set (regno, &set_hash_table);\n-\n-      /* Find a set that is available at the start of the block\n-\t which contains INSN.  */\n-      while (set)\n-\t{\n-\t  if (TEST_BIT (cprop_avin[BLOCK_FOR_INSN (insn)->index],\n-\t\t\tset->bitmap_index))\n-\t    break;\n-\t  set = next_set (regno, set);\n-\t}\n-\n-      /* If no available set was found we've reached the end of the\n-\t (possibly empty) copy chain.  */\n-      if (set == 0)\n-\tbreak;\n-\n-      gcc_assert (GET_CODE (set->expr) == SET);\n-\n-      src = SET_SRC (set->expr);\n-\n-      /* We know the set is available.\n-\t Now check that SRC is ANTLOC (i.e. none of the source operands\n-\t have changed since the start of the block).\n-\n-         If the source operand changed, we may still use it for the next\n-         iteration of this loop, but we may not use it for substitutions.  */\n-\n-      if (gcse_constant_p (src) || oprs_not_set_p (src, insn))\n-\tset1 = set;\n-\n-      /* If the source of the set is anything except a register, then\n-\t we have reached the end of the copy chain.  */\n-      if (! REG_P (src))\n-\tbreak;\n-\n-      /* Follow the copy chain, i.e. start another iteration of the loop\n-\t and see if we have an available copy into SRC.  */\n-      regno = REGNO (src);\n-    }\n-\n-  /* SET1 holds the last set that was available and anticipatable at\n-     INSN.  */\n-  return set1;\n-}\n-\n-/* Subroutine of cprop_insn that tries to propagate constants into\n-   JUMP_INSNS.  JUMP must be a conditional jump.  If SETCC is non-NULL\n-   it is the instruction that immediately precedes JUMP, and must be a\n-   single SET of a register.  FROM is what we will try to replace,\n-   SRC is the constant we will try to substitute for it.  Returns nonzero\n-   if a change was made.  */\n-\n-static int\n-cprop_jump (basic_block bb, rtx setcc, rtx jump, rtx from, rtx src)\n-{\n-  rtx new_rtx, set_src, note_src;\n-  rtx set = pc_set (jump);\n-  rtx note = find_reg_equal_equiv_note (jump);\n-\n-  if (note)\n-    {\n-      note_src = XEXP (note, 0);\n-      if (GET_CODE (note_src) == EXPR_LIST)\n-\tnote_src = NULL_RTX;\n-    }\n-  else note_src = NULL_RTX;\n-\n-  /* Prefer REG_EQUAL notes except those containing EXPR_LISTs.  */\n-  set_src = note_src ? note_src : SET_SRC (set);\n-\n-  /* First substitute the SETCC condition into the JUMP instruction,\n-     then substitute that given values into this expanded JUMP.  */\n-  if (setcc != NULL_RTX\n-      && !modified_between_p (from, setcc, jump)\n-      && !modified_between_p (src, setcc, jump))\n-    {\n-      rtx setcc_src;\n-      rtx setcc_set = single_set (setcc);\n-      rtx setcc_note = find_reg_equal_equiv_note (setcc);\n-      setcc_src = (setcc_note && GET_CODE (XEXP (setcc_note, 0)) != EXPR_LIST)\n-\t\t? XEXP (setcc_note, 0) : SET_SRC (setcc_set);\n-      set_src = simplify_replace_rtx (set_src, SET_DEST (setcc_set),\n-\t\t\t\t      setcc_src);\n-    }\n-  else\n-    setcc = NULL_RTX;\n-\n-  new_rtx = simplify_replace_rtx (set_src, from, src);\n-\n-  /* If no simplification can be made, then try the next register.  */\n-  if (rtx_equal_p (new_rtx, SET_SRC (set)))\n-    return 0;\n-\n-  /* If this is now a no-op delete it, otherwise this must be a valid insn.  */\n-  if (new_rtx == pc_rtx)\n-    delete_insn (jump);\n-  else\n-    {\n-      /* Ensure the value computed inside the jump insn to be equivalent\n-         to one computed by setcc.  */\n-      if (setcc && modified_in_p (new_rtx, setcc))\n-\treturn 0;\n-      if (! validate_unshare_change (jump, &SET_SRC (set), new_rtx, 0))\n-\t{\n-\t  /* When (some) constants are not valid in a comparison, and there\n-\t     are two registers to be replaced by constants before the entire\n-\t     comparison can be folded into a constant, we need to keep\n-\t     intermediate information in REG_EQUAL notes.  For targets with\n-\t     separate compare insns, such notes are added by try_replace_reg.\n-\t     When we have a combined compare-and-branch instruction, however,\n-\t     we need to attach a note to the branch itself to make this\n-\t     optimization work.  */\n-\n-\t  if (!rtx_equal_p (new_rtx, note_src))\n-\t    set_unique_reg_note (jump, REG_EQUAL, copy_rtx (new_rtx));\n-\t  return 0;\n-\t}\n-\n-      /* Remove REG_EQUAL note after simplification.  */\n-      if (note_src)\n-\tremove_note (jump, note);\n-     }\n-\n-#ifdef HAVE_cc0\n-  /* Delete the cc0 setter.  */\n-  if (setcc != NULL && CC0_P (SET_DEST (single_set (setcc))))\n-    delete_insn (setcc);\n-#endif\n-\n-  global_const_prop_count++;\n-  if (dump_file != NULL)\n-    {\n-      fprintf (dump_file,\n-\t       \"GLOBAL CONST-PROP: Replacing reg %d in jump_insn %d with constant \",\n-\t       REGNO (from), INSN_UID (jump));\n-      print_rtl (dump_file, src);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-  purge_dead_edges (bb);\n-\n-  /* If a conditional jump has been changed into unconditional jump, remove\n-     the jump and make the edge fallthru - this is always called in\n-     cfglayout mode.  */\n-  if (new_rtx != pc_rtx && simplejump_p (jump))\n-    {\n-      edge e;\n-      edge_iterator ei;\n-\n-      for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); ei_next (&ei))\n-\tif (e->dest != EXIT_BLOCK_PTR\n-\t    && BB_HEAD (e->dest) == JUMP_LABEL (jump))\n-\t  {\n-\t    e->flags |= EDGE_FALLTHRU;\n-\t    break;\n-\t  }\n-      delete_insn (jump);\n-    }\n-\n-  return 1;\n-}\n-\n-static bool\n-constprop_register (rtx insn, rtx from, rtx to)\n-{\n-  rtx sset;\n-\n-  /* Check for reg or cc0 setting instructions followed by\n-     conditional branch instructions first.  */\n-  if ((sset = single_set (insn)) != NULL\n-      && NEXT_INSN (insn)\n-      && any_condjump_p (NEXT_INSN (insn)) && onlyjump_p (NEXT_INSN (insn)))\n-    {\n-      rtx dest = SET_DEST (sset);\n-      if ((REG_P (dest) || CC0_P (dest))\n-\t  && cprop_jump (BLOCK_FOR_INSN (insn), insn, NEXT_INSN (insn), from, to))\n-\treturn 1;\n-    }\n-\n-  /* Handle normal insns next.  */\n-  if (NONJUMP_INSN_P (insn)\n-      && try_replace_reg (from, to, insn))\n-    return 1;\n-\n-  /* Try to propagate a CONST_INT into a conditional jump.\n-     We're pretty specific about what we will handle in this\n-     code, we can extend this as necessary over time.\n-\n-     Right now the insn in question must look like\n-     (set (pc) (if_then_else ...))  */\n-  else if (any_condjump_p (insn) && onlyjump_p (insn))\n-    return cprop_jump (BLOCK_FOR_INSN (insn), NULL, insn, from, to);\n-  return 0;\n-}\n-\n-/* Perform constant and copy propagation on INSN.\n-   The result is nonzero if a change was made.  */\n-\n-static int\n-cprop_insn (rtx insn)\n-{\n-  struct reg_use *reg_used;\n-  int changed = 0;\n-  rtx note;\n-\n-  if (!INSN_P (insn))\n-    return 0;\n-\n-  reg_use_count = 0;\n-  note_uses (&PATTERN (insn), find_used_regs, NULL);\n-\n-  note = find_reg_equal_equiv_note (insn);\n-\n-  /* We may win even when propagating constants into notes.  */\n-  if (note)\n-    find_used_regs (&XEXP (note, 0), NULL);\n-\n-  for (reg_used = &reg_use_table[0]; reg_use_count > 0;\n-       reg_used++, reg_use_count--)\n-    {\n-      unsigned int regno = REGNO (reg_used->reg_rtx);\n-      rtx pat, src;\n-      struct expr *set;\n-\n-      /* If the register has already been set in this block, there's\n-\t nothing we can do.  */\n-      if (! oprs_not_set_p (reg_used->reg_rtx, insn))\n-\tcontinue;\n-\n-      /* Find an assignment that sets reg_used and is available\n-\t at the start of the block.  */\n-      set = find_avail_set (regno, insn);\n-      if (! set)\n-\tcontinue;\n-\n-      pat = set->expr;\n-      /* ??? We might be able to handle PARALLELs.  Later.  */\n-      gcc_assert (GET_CODE (pat) == SET);\n-\n-      src = SET_SRC (pat);\n-\n-      /* Constant propagation.  */\n-      if (gcse_constant_p (src))\n-\t{\n-          if (constprop_register (insn, reg_used->reg_rtx, src))\n-\t    {\n-\t      changed = 1;\n-\t      global_const_prop_count++;\n-\t      if (dump_file != NULL)\n-\t\t{\n-\t\t  fprintf (dump_file, \"GLOBAL CONST-PROP: Replacing reg %d in \", regno);\n-\t\t  fprintf (dump_file, \"insn %d with constant \", INSN_UID (insn));\n-\t\t  print_rtl (dump_file, src);\n-\t\t  fprintf (dump_file, \"\\n\");\n-\t\t}\n-\t      if (INSN_DELETED_P (insn))\n-\t\treturn 1;\n-\t    }\n-\t}\n-      else if (REG_P (src)\n-\t       && REGNO (src) >= FIRST_PSEUDO_REGISTER\n-\t       && REGNO (src) != regno)\n-\t{\n-\t  if (try_replace_reg (reg_used->reg_rtx, src, insn))\n-\t    {\n-\t      changed = 1;\n-\t      global_copy_prop_count++;\n-\t      if (dump_file != NULL)\n-\t\t{\n-\t\t  fprintf (dump_file, \"GLOBAL COPY-PROP: Replacing reg %d in insn %d\",\n-\t\t\t   regno, INSN_UID (insn));\n-\t\t  fprintf (dump_file, \" with reg %d\\n\", REGNO (src));\n-\t\t}\n-\n-\t      /* The original insn setting reg_used may or may not now be\n-\t\t deletable.  We leave the deletion to flow.  */\n-\t      /* FIXME: If it turns out that the insn isn't deletable,\n-\t\t then we may have unnecessarily extended register lifetimes\n-\t\t and made things worse.  */\n-\t    }\n-\t}\n-    }\n-\n-  if (changed && DEBUG_INSN_P (insn))\n-    return 0;\n-\n-  return changed;\n-}\n-\n-/* Like find_used_regs, but avoid recording uses that appear in\n-   input-output contexts such as zero_extract or pre_dec.  This\n-   restricts the cases we consider to those for which local cprop\n-   can legitimately make replacements.  */\n-\n-static void\n-local_cprop_find_used_regs (rtx *xptr, void *data)\n-{\n-  rtx x = *xptr;\n-\n-  if (x == 0)\n-    return;\n-\n-  switch (GET_CODE (x))\n-    {\n-    case ZERO_EXTRACT:\n-    case SIGN_EXTRACT:\n-    case STRICT_LOW_PART:\n-      return;\n-\n-    case PRE_DEC:\n-    case PRE_INC:\n-    case POST_DEC:\n-    case POST_INC:\n-    case PRE_MODIFY:\n-    case POST_MODIFY:\n-      /* Can only legitimately appear this early in the context of\n-\t stack pushes for function arguments, but handle all of the\n-\t codes nonetheless.  */\n-      return;\n-\n-    case SUBREG:\n-      /* Setting a subreg of a register larger than word_mode leaves\n-\t the non-written words unchanged.  */\n-      if (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x))) > BITS_PER_WORD)\n-\treturn;\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  find_used_regs (xptr, data);\n-}\n-\n-/* Try to perform local const/copy propagation on X in INSN.  */\n-\n-static bool\n-do_local_cprop (rtx x, rtx insn)\n-{\n-  rtx newreg = NULL, newcnst = NULL;\n-\n-  /* Rule out USE instructions and ASM statements as we don't want to\n-     change the hard registers mentioned.  */\n-  if (REG_P (x)\n-      && (REGNO (x) >= FIRST_PSEUDO_REGISTER\n-          || (GET_CODE (PATTERN (insn)) != USE\n-\t      && asm_noperands (PATTERN (insn)) < 0)))\n-    {\n-      cselib_val *val = cselib_lookup (x, GET_MODE (x), 0, VOIDmode);\n-      struct elt_loc_list *l;\n-\n-      if (!val)\n-\treturn false;\n-      for (l = val->locs; l; l = l->next)\n-\t{\n-\t  rtx this_rtx = l->loc;\n-\t  rtx note;\n-\n-\t  if (gcse_constant_p (this_rtx))\n-\t    newcnst = this_rtx;\n-\t  if (REG_P (this_rtx) && REGNO (this_rtx) >= FIRST_PSEUDO_REGISTER\n-\t      /* Don't copy propagate if it has attached REG_EQUIV note.\n-\t\t At this point this only function parameters should have\n-\t\t REG_EQUIV notes and if the argument slot is used somewhere\n-\t\t explicitly, it means address of parameter has been taken,\n-\t\t so we should not extend the lifetime of the pseudo.  */\n-\t      && (!(note = find_reg_note (l->setting_insn, REG_EQUIV, NULL_RTX))\n-\t\t  || ! MEM_P (XEXP (note, 0))))\n-\t    newreg = this_rtx;\n-\t}\n-      if (newcnst && constprop_register (insn, x, newcnst))\n-\t{\n-\t  if (dump_file != NULL)\n-\t    {\n-\t      fprintf (dump_file, \"LOCAL CONST-PROP: Replacing reg %d in \",\n-\t\t       REGNO (x));\n-\t      fprintf (dump_file, \"insn %d with constant \",\n-\t\t       INSN_UID (insn));\n-\t      print_rtl (dump_file, newcnst);\n-\t      fprintf (dump_file, \"\\n\");\n-\t    }\n-\t  local_const_prop_count++;\n-\t  return true;\n-\t}\n-      else if (newreg && newreg != x && try_replace_reg (x, newreg, insn))\n-\t{\n-\t  if (dump_file != NULL)\n-\t    {\n-\t      fprintf (dump_file,\n-\t\t       \"LOCAL COPY-PROP: Replacing reg %d in insn %d\",\n-\t\t       REGNO (x), INSN_UID (insn));\n-\t      fprintf (dump_file, \" with reg %d\\n\", REGNO (newreg));\n-\t    }\n-\t  local_copy_prop_count++;\n-\t  return true;\n-\t}\n-    }\n-  return false;\n-}\n-\n-/* Do local const/copy propagation (i.e. within each basic block).  */\n-\n-static int\n-local_cprop_pass (void)\n-{\n-  basic_block bb;\n-  rtx insn;\n-  struct reg_use *reg_used;\n-  bool changed = false;\n-\n-  cselib_init (0);\n-  FOR_EACH_BB (bb)\n-    {\n-      FOR_BB_INSNS (bb, insn)\n-\t{\n-\t  if (INSN_P (insn))\n-\t    {\n-\t      rtx note = find_reg_equal_equiv_note (insn);\n-\t      do\n-\t\t{\n-\t\t  reg_use_count = 0;\n-\t\t  note_uses (&PATTERN (insn), local_cprop_find_used_regs,\n-\t\t\t     NULL);\n-\t\t  if (note)\n-\t\t    local_cprop_find_used_regs (&XEXP (note, 0), NULL);\n-\n-\t\t  for (reg_used = &reg_use_table[0]; reg_use_count > 0;\n-\t\t       reg_used++, reg_use_count--)\n-\t\t    {\n-\t\t      if (do_local_cprop (reg_used->reg_rtx, insn))\n-\t\t\t{\n-\t\t\t  changed = true;\n-\t\t\t  break;\n-\t\t\t}\n-\t\t    }\n-\t\t  if (INSN_DELETED_P (insn))\n-\t\t    break;\n-\t\t}\n-\t      while (reg_use_count);\n-\t    }\n-\t  cselib_process_insn (insn);\n-\t}\n-\n-      /* Forget everything at the end of a basic block.  */\n-      cselib_clear_table ();\n-    }\n-\n-  cselib_finish ();\n-\n-  return changed;\n-}\n-\n-/* Similar to get_condition, only the resulting condition must be\n-   valid at JUMP, instead of at EARLIEST.\n-\n-   This differs from noce_get_condition in ifcvt.c in that we prefer not to\n-   settle for the condition variable in the jump instruction being integral.\n-   We prefer to be able to record the value of a user variable, rather than\n-   the value of a temporary used in a condition.  This could be solved by\n-   recording the value of *every* register scanned by canonicalize_condition,\n-   but this would require some code reorganization.  */\n-\n-rtx\n-fis_get_condition (rtx jump)\n-{\n-  return get_condition (jump, NULL, false, true);\n-}\n-\n-/* Check the comparison COND to see if we can safely form an implicit set from\n-   it.  COND is either an EQ or NE comparison.  */\n-\n-static bool\n-implicit_set_cond_p (const_rtx cond)\n-{\n-  const enum machine_mode mode = GET_MODE (XEXP (cond, 0));\n-  const_rtx cst = XEXP (cond, 1);\n-\n-  /* We can't perform this optimization if either operand might be or might\n-     contain a signed zero.  */\n-  if (HONOR_SIGNED_ZEROS (mode))\n-    {\n-      /* It is sufficient to check if CST is or contains a zero.  We must\n-\t handle float, complex, and vector.  If any subpart is a zero, then\n-\t the optimization can't be performed.  */\n-      /* ??? The complex and vector checks are not implemented yet.  We just\n-\t always return zero for them.  */\n-      if (GET_CODE (cst) == CONST_DOUBLE)\n-\t{\n-\t  REAL_VALUE_TYPE d;\n-\t  REAL_VALUE_FROM_CONST_DOUBLE (d, cst);\n-\t  if (REAL_VALUES_EQUAL (d, dconst0))\n-\t    return 0;\n-\t}\n-      else\n-\treturn 0;\n-    }\n-\n-  return gcse_constant_p (cst);\n-}\n-\n-/* Find the implicit sets of a function.  An \"implicit set\" is a constraint\n-   on the value of a variable, implied by a conditional jump.  For example,\n-   following \"if (x == 2)\", the then branch may be optimized as though the\n-   conditional performed an \"explicit set\", in this example, \"x = 2\".  This\n-   function records the set patterns that are implicit at the start of each\n-   basic block.\n-\n-   FIXME: This would be more effective if critical edges are pre-split.  As\n-\t  it is now, we can't record implicit sets for blocks that have\n-\t  critical successor edges.  This results in missed optimizations\n-\t  and in more (unnecessary) work in cfgcleanup.c:thread_jump().  */\n-\n-static void\n-find_implicit_sets (void)\n-{\n-  basic_block bb, dest;\n-  unsigned int count;\n-  rtx cond, new_rtx;\n-\n-  count = 0;\n-  FOR_EACH_BB (bb)\n-    /* Check for more than one successor.  */\n-    if (EDGE_COUNT (bb->succs) > 1)\n-      {\n-\tcond = fis_get_condition (BB_END (bb));\n-\n-\tif (cond\n-\t    && (GET_CODE (cond) == EQ || GET_CODE (cond) == NE)\n-\t    && REG_P (XEXP (cond, 0))\n-\t    && REGNO (XEXP (cond, 0)) >= FIRST_PSEUDO_REGISTER\n-\t    && implicit_set_cond_p (cond))\n-\t  {\n-\t    dest = GET_CODE (cond) == EQ ? BRANCH_EDGE (bb)->dest\n-\t\t\t\t\t : FALLTHRU_EDGE (bb)->dest;\n-\n-\t    if (dest\n-\t\t/* Record nothing for a critical edge.  */\n-\t\t&& single_pred_p (dest)\n-\t\t&& dest != EXIT_BLOCK_PTR)\n-\t      {\n-\t\tnew_rtx = gen_rtx_SET (VOIDmode, XEXP (cond, 0),\n-\t\t\t\t\t     XEXP (cond, 1));\n-\t\timplicit_sets[dest->index] = new_rtx;\n-\t\tif (dump_file)\n-\t\t  {\n-\t\t    fprintf(dump_file, \"Implicit set of reg %d in \",\n-\t\t\t    REGNO (XEXP (cond, 0)));\n-\t\t    fprintf(dump_file, \"basic block %d\\n\", dest->index);\n-\t\t  }\n-\t\tcount++;\n-\t      }\n-\t  }\n-      }\n-\n-  if (dump_file)\n-    fprintf (dump_file, \"Found %d implicit sets\\n\", count);\n-}\n-\n-/* Bypass conditional jumps.  */\n-\n-/* The value of last_basic_block at the beginning of the jump_bypass\n-   pass.  The use of redirect_edge_and_branch_force may introduce new\n-   basic blocks, but the data flow analysis is only valid for basic\n-   block indices less than bypass_last_basic_block.  */\n-\n-static int bypass_last_basic_block;\n+    }\n \n-/* Find a set of REGNO to a constant that is available at the end of basic\n-   block BB.  Returns NULL if no such set is found.  Based heavily upon\n-   find_avail_set.  */\n+  *listp = NULL;\n+}\n \n-static struct expr *\n-find_bypass_set (int regno, int bb)\n+/* Clear canon_modify_mem_list and modify_mem_list tables.  */\n+static void\n+clear_modify_mem_tables (void)\n {\n-  struct expr *result = 0;\n+  unsigned i;\n+  bitmap_iterator bi;\n \n-  for (;;)\n+  EXECUTE_IF_SET_IN_BITMAP (modify_mem_list_set, 0, i, bi)\n     {\n-      rtx src;\n-      struct expr *set = lookup_set (regno, &set_hash_table);\n-\n-      while (set)\n-\t{\n-\t  if (TEST_BIT (cprop_avout[bb], set->bitmap_index))\n-\t    break;\n-\t  set = next_set (regno, set);\n-\t}\n-\n-      if (set == 0)\n-\tbreak;\n-\n-      gcc_assert (GET_CODE (set->expr) == SET);\n-\n-      src = SET_SRC (set->expr);\n-      if (gcse_constant_p (src))\n-\tresult = set;\n-\n-      if (! REG_P (src))\n-\tbreak;\n-\n-      regno = REGNO (src);\n+      free_INSN_LIST_list (modify_mem_list + i);\n+      free_insn_expr_list_list (canon_modify_mem_list + i);\n     }\n-  return result;\n+  bitmap_clear (modify_mem_list_set);\n+  bitmap_clear (blocks_with_calls);\n }\n \n+/* Release memory used by modify_mem_list_set.  */\n \n-/* Subroutine of bypass_block that checks whether a pseudo is killed by\n-   any of the instructions inserted on an edge.  Jump bypassing places\n-   condition code setters on CFG edges using insert_insn_on_edge.  This\n-   function is required to check that our data flow analysis is still\n-   valid prior to commit_edge_insertions.  */\n-\n-static bool\n-reg_killed_on_edge (const_rtx reg, const_edge e)\n+static void\n+free_modify_mem_tables (void)\n {\n-  rtx insn;\n-\n-  for (insn = e->insns.r; insn; insn = NEXT_INSN (insn))\n-    if (INSN_P (insn) && reg_set_p (reg, insn))\n-      return true;\n-\n-  return false;\n+  clear_modify_mem_tables ();\n+  free (modify_mem_list);\n+  free (canon_modify_mem_list);\n+  modify_mem_list = 0;\n+  canon_modify_mem_list = 0;\n }\n \n-/* Subroutine of bypass_conditional_jumps that attempts to bypass the given\n-   basic block BB which has more than one predecessor.  If not NULL, SETCC\n-   is the first instruction of BB, which is immediately followed by JUMP_INSN\n-   JUMP.  Otherwise, SETCC is NULL, and JUMP is the first insn of BB.\n-   Returns nonzero if a change was made.\n-\n-   During the jump bypassing pass, we may place copies of SETCC instructions\n-   on CFG edges.  The following routine must be careful to pay attention to\n-   these inserted insns when performing its transformations.  */\n+\f\n+/* For each block, compute whether X is transparent.  X is either an\n+   expression or an assignment [though we don't care which, for this context\n+   an assignment is treated as an expression].  For each block where an\n+   element of X is modified, reset the INDX bit in BMAP.  */\n \n-static int\n-bypass_block (basic_block bb, rtx setcc, rtx jump)\n+static void\n+compute_transp (const_rtx x, int indx, sbitmap *bmap)\n {\n-  rtx insn, note;\n-  edge e, edest;\n-  int i, change;\n-  int may_be_loop_header;\n-  unsigned removed_p;\n-  edge_iterator ei;\n-\n-  insn = (setcc != NULL) ? setcc : jump;\n+  int i, j;\n+  enum rtx_code code;\n+  const char *fmt;\n \n-  /* Determine set of register uses in INSN.  */\n-  reg_use_count = 0;\n-  note_uses (&PATTERN (insn), find_used_regs, NULL);\n-  note = find_reg_equal_equiv_note (insn);\n-  if (note)\n-    find_used_regs (&XEXP (note, 0), NULL);\n+  /* repeat is used to turn tail-recursion into iteration since GCC\n+     can't do it when there's no return value.  */\n+ repeat:\n \n-  may_be_loop_header = false;\n-  FOR_EACH_EDGE (e, ei, bb->preds)\n-    if (e->flags & EDGE_DFS_BACK)\n-      {\n-\tmay_be_loop_header = true;\n-\tbreak;\n-      }\n+  if (x == 0)\n+    return;\n \n-  change = 0;\n-  for (ei = ei_start (bb->preds); (e = ei_safe_edge (ei)); )\n+  code = GET_CODE (x);\n+  switch (code)\n     {\n-      removed_p = 0;\n-\n-      if (e->flags & EDGE_COMPLEX)\n-\t{\n-\t  ei_next (&ei);\n-\t  continue;\n-\t}\n-\n-      /* We can't redirect edges from new basic blocks.  */\n-      if (e->src->index >= bypass_last_basic_block)\n+    case REG:\n \t{\n-\t  ei_next (&ei);\n-\t  continue;\n+\t  df_ref def;\n+\t  for (def = DF_REG_DEF_CHAIN (REGNO (x));\n+\t       def;\n+\t       def = DF_REF_NEXT_REG (def))\n+\t    RESET_BIT (bmap[DF_REF_BB (def)->index], indx);\n \t}\n \n-      /* The irreducible loops created by redirecting of edges entering the\n-\t loop from outside would decrease effectiveness of some of the following\n-\t optimizations, so prevent this.  */\n-      if (may_be_loop_header\n-\t  && !(e->flags & EDGE_DFS_BACK))\n-\t{\n-\t  ei_next (&ei);\n-\t  continue;\n-\t}\n+      return;\n \n-      for (i = 0; i < reg_use_count; i++)\n+    case MEM:\n+      if (! MEM_READONLY_P (x))\n \t{\n-\t  struct reg_use *reg_used = &reg_use_table[i];\n-\t  unsigned int regno = REGNO (reg_used->reg_rtx);\n-\t  basic_block dest, old_dest;\n-\t  struct expr *set;\n-\t  rtx src, new_rtx;\n-\n-\t  set = find_bypass_set (regno, e->src->index);\n-\n-\t  if (! set)\n-\t    continue;\n-\n-\t  /* Check the data flow is valid after edge insertions.  */\n-\t  if (e->insns.r && reg_killed_on_edge (reg_used->reg_rtx, e))\n-\t    continue;\n+\t  bitmap_iterator bi;\n+\t  unsigned bb_index;\n \n-\t  src = SET_SRC (pc_set (jump));\n+\t  /* First handle all the blocks with calls.  We don't need to\n+\t     do any list walking for them.  */\n+\t  EXECUTE_IF_SET_IN_BITMAP (blocks_with_calls, 0, bb_index, bi)\n+\t    {\n+\t      RESET_BIT (bmap[bb_index], indx);\n+\t    }\n \n-\t  if (setcc != NULL)\n-\t    src = simplify_replace_rtx (src,\n-\t\t\t\t\tSET_DEST (PATTERN (setcc)),\n-\t\t\t\t\tSET_SRC (PATTERN (setcc)));\n+\t    /* Now iterate over the blocks which have memory modifications\n+\t       but which do not have any calls.  */\n+\t    EXECUTE_IF_AND_COMPL_IN_BITMAP (modify_mem_list_set,\n+\t\t\t\t\t    blocks_with_calls,\n+\t\t\t\t\t    0, bb_index, bi)\n+\t      {\n+\t\trtx list_entry = canon_modify_mem_list[bb_index];\n \n-\t  new_rtx = simplify_replace_rtx (src, reg_used->reg_rtx,\n-\t\t\t\t\t  SET_SRC (set->expr));\n+\t\twhile (list_entry)\n+\t\t  {\n+\t\t    rtx dest, dest_addr;\n \n-\t  /* Jump bypassing may have already placed instructions on\n-\t     edges of the CFG.  We can't bypass an outgoing edge that\n-\t     has instructions associated with it, as these insns won't\n-\t     get executed if the incoming edge is redirected.  */\n+\t\t    /* LIST_ENTRY must be an INSN of some kind that sets memory.\n+\t\t       Examine each hunk of memory that is modified.  */\n \n-\t  if (new_rtx == pc_rtx)\n-\t    {\n-\t      edest = FALLTHRU_EDGE (bb);\n-\t      dest = edest->insns.r ? NULL : edest->dest;\n-\t    }\n-\t  else if (GET_CODE (new_rtx) == LABEL_REF)\n-\t    {\n-\t      dest = BLOCK_FOR_INSN (XEXP (new_rtx, 0));\n-\t      /* Don't bypass edges containing instructions.  */\n-\t      edest = find_edge (bb, dest);\n-\t      if (edest && edest->insns.r)\n-\t\tdest = NULL;\n-\t    }\n-\t  else\n-\t    dest = NULL;\n-\n-\t  /* Avoid unification of the edge with other edges from original\n-\t     branch.  We would end up emitting the instruction on \"both\"\n-\t     edges.  */\n-\n-\t  if (dest && setcc && !CC0_P (SET_DEST (PATTERN (setcc)))\n-\t      && find_edge (e->src, dest))\n-\t    dest = NULL;\n-\n-\t  old_dest = e->dest;\n-\t  if (dest != NULL\n-\t      && dest != old_dest\n-\t      && dest != EXIT_BLOCK_PTR)\n-            {\n-\t      redirect_edge_and_branch_force (e, dest);\n-\n-\t      /* Copy the register setter to the redirected edge.\n-\t\t Don't copy CC0 setters, as CC0 is dead after jump.  */\n-\t      if (setcc)\n-\t\t{\n-\t\t  rtx pat = PATTERN (setcc);\n-\t\t  if (!CC0_P (SET_DEST (pat)))\n-\t\t    insert_insn_on_edge (copy_insn (pat), e);\n-\t\t}\n+\t\t    dest = XEXP (list_entry, 0);\n+\t\t    list_entry = XEXP (list_entry, 1);\n+\t\t    dest_addr = XEXP (list_entry, 0);\n \n-\t      if (dump_file != NULL)\n-\t\t{\n-\t\t  fprintf (dump_file, \"JUMP-BYPASS: Proved reg %d \"\n-\t\t\t\t      \"in jump_insn %d equals constant \",\n-\t\t\t   regno, INSN_UID (jump));\n-\t\t  print_rtl (dump_file, SET_SRC (set->expr));\n-\t\t  fprintf (dump_file, \"\\nBypass edge from %d->%d to %d\\n\",\n-\t\t\t   e->src->index, old_dest->index, dest->index);\n-\t\t}\n-\t      change = 1;\n-\t      removed_p = 1;\n-\t      break;\n-\t    }\n+\t\t    if (canon_true_dependence (dest, GET_MODE (dest), dest_addr,\n+\t\t\t\t\t       x, NULL_RTX, rtx_addr_varies_p))\n+\t\t      {\n+\t\t\tRESET_BIT (bmap[bb_index], indx);\n+\t\t      }\n+\t\t    list_entry = XEXP (list_entry, 1);\n+\t          }\n+\t      }\n \t}\n-      if (!removed_p)\n-\tei_next (&ei);\n-    }\n-  return change;\n-}\n-\n-/* Find basic blocks with more than one predecessor that only contain a\n-   single conditional jump.  If the result of the comparison is known at\n-   compile-time from any incoming edge, redirect that edge to the\n-   appropriate target.  Returns nonzero if a change was made.\n-\n-   This function is now mis-named, because we also handle indirect jumps.  */\n \n-static int\n-bypass_conditional_jumps (void)\n-{\n-  basic_block bb;\n-  int changed;\n-  rtx setcc;\n-  rtx insn;\n-  rtx dest;\n+      x = XEXP (x, 0);\n+      goto repeat;\n \n-  /* Note we start at block 1.  */\n-  if (ENTRY_BLOCK_PTR->next_bb == EXIT_BLOCK_PTR)\n-    return 0;\n+    case PC:\n+    case CC0: /*FIXME*/\n+    case CONST:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case CONST_FIXED:\n+    case CONST_VECTOR:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+    case ADDR_VEC:\n+    case ADDR_DIFF_VEC:\n+      return;\n \n-  bypass_last_basic_block = last_basic_block;\n-  mark_dfs_back_edges ();\n+    default:\n+      break;\n+    }\n \n-  changed = 0;\n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR->next_bb->next_bb,\n-\t\t  EXIT_BLOCK_PTR, next_bb)\n+  for (i = GET_RTX_LENGTH (code) - 1, fmt = GET_RTX_FORMAT (code); i >= 0; i--)\n     {\n-      /* Check for more than one predecessor.  */\n-      if (!single_pred_p (bb))\n+      if (fmt[i] == 'e')\n \t{\n-\t  setcc = NULL_RTX;\n-\t  FOR_BB_INSNS (bb, insn)\n-\t    if (DEBUG_INSN_P (insn))\n-\t      continue;\n-\t    else if (NONJUMP_INSN_P (insn))\n-\t      {\n-\t\tif (setcc)\n-\t\t  break;\n-\t\tif (GET_CODE (PATTERN (insn)) != SET)\n-\t\t  break;\n-\n-\t\tdest = SET_DEST (PATTERN (insn));\n-\t\tif (REG_P (dest) || CC0_P (dest))\n-\t\t  setcc = insn;\n-\t\telse\n-\t\t  break;\n-\t      }\n-\t    else if (JUMP_P (insn))\n-\t      {\n-\t\tif ((any_condjump_p (insn) || computed_jump_p (insn))\n-\t\t    && onlyjump_p (insn))\n-\t\t  changed |= bypass_block (bb, setcc, insn);\n-\t\tbreak;\n-\t      }\n-\t    else if (INSN_P (insn))\n-\t      break;\n+\t  /* If we are about to do the last recursive call\n+\t     needed at this level, change it into iteration.\n+\t     This function is called enough to be worth it.  */\n+\t  if (i == 0)\n+\t    {\n+\t      x = XEXP (x, i);\n+\t      goto repeat;\n+\t    }\n+\n+\t  compute_transp (XEXP (x, i), indx, bmap);\n \t}\n+      else if (fmt[i] == 'E')\n+\tfor (j = 0; j < XVECLEN (x, i); j++)\n+\t  compute_transp (XVECEXP (x, i, j), indx, bmap);\n     }\n-\n-  /* If we bypassed any register setting insns, we inserted a\n-     copy on the redirected edge.  These need to be committed.  */\n-  if (changed)\n-    commit_edge_insertions ();\n-\n-  return changed;\n }\n+\n \f\n /* Compute PRE+LCM working variables.  */\n \n@@ -4146,7 +2681,7 @@ one_pre_gcse_pass (void)\n   gcc_obstack_init (&gcse_obstack);\n   alloc_gcse_mem ();\n \n-  alloc_hash_table (&expr_hash_table, 0);\n+  alloc_hash_table (&expr_hash_table);\n   add_noreturn_fake_exit_edges ();\n   if (flag_gcse_lm)\n     compute_ld_motion_mems ();\n@@ -4693,7 +3228,7 @@ one_code_hoisting_pass (void)\n   gcc_obstack_init (&gcse_obstack);\n   alloc_gcse_mem ();\n \n-  alloc_hash_table (&expr_hash_table, 0);\n+  alloc_hash_table (&expr_hash_table);\n   compute_hash_table (&expr_hash_table);\n   if (dump_file)\n     dump_hash_table (dump_file, \"Code Hosting Expressions\", &expr_hash_table);\n@@ -5176,7 +3711,7 @@ is_too_expensive (const char *pass)\n       return true;\n     }\n \n-  /* If allocating memory for the cprop bitmap would take up too much\n+  /* If allocating memory for the dataflow bitmaps would take up too much\n      storage it's better just to disable the optimization.  */\n   if ((n_basic_blocks\n        * SBITMAP_SET_SIZE (max_reg_num ())\n@@ -5192,107 +3727,6 @@ is_too_expensive (const char *pass)\n   return false;\n }\n \n-\f\n-/* Main function for the CPROP pass.  */\n-\n-static int\n-one_cprop_pass (void)\n-{\n-  int changed = 0;\n-\n-  /* Return if there's nothing to do, or it is too expensive.  */\n-  if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1\n-      || is_too_expensive (_ (\"const/copy propagation disabled\")))\n-    return 0;\n-\n-  global_const_prop_count = local_const_prop_count = 0;\n-  global_copy_prop_count = local_copy_prop_count = 0;\n-\n-  bytes_used = 0;\n-  gcc_obstack_init (&gcse_obstack);\n-  alloc_gcse_mem ();\n-\n-  /* Do a local const/copy propagation pass first.  The global pass\n-     only handles global opportunities.\n-     If the local pass changes something, remove any unreachable blocks\n-     because the CPROP global dataflow analysis may get into infinite\n-     loops for CFGs with unreachable blocks.\n-\n-     FIXME: This local pass should not be necessary after CSE (but for\n-\t    some reason it still is).  It is also (proven) not necessary\n-\t    to run the local pass right after FWPWOP.\n-\n-     FIXME: The global analysis would not get into infinite loops if it\n-\t    would use the DF solver (via df_simple_dataflow) instead of\n-\t    the solver implemented in this file.  */\n-  if (local_cprop_pass ())\n-    {\n-      delete_unreachable_blocks ();\n-      df_analyze ();\n-    }\n-\n-  /* Determine implicit sets.  */\n-  implicit_sets = XCNEWVEC (rtx, last_basic_block);\n-  find_implicit_sets ();\n-\n-  alloc_hash_table (&set_hash_table, 1);\n-  compute_hash_table (&set_hash_table);\n-\n-  /* Free implicit_sets before peak usage.  */\n-  free (implicit_sets);\n-  implicit_sets = NULL;\n-\n-  if (dump_file)\n-    dump_hash_table (dump_file, \"SET\", &set_hash_table);\n-  if (set_hash_table.n_elems > 0)\n-    {\n-      basic_block bb;\n-      rtx insn;\n-\n-      alloc_cprop_mem (last_basic_block, set_hash_table.n_elems);\n-      compute_cprop_data ();\n-\n-      FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR->next_bb->next_bb, EXIT_BLOCK_PTR, next_bb)\n-\t{\n-\t  /* Reset tables used to keep track of what's still valid [since\n-\t     the start of the block].  */\n-\t  reset_opr_set_tables ();\n-\n-\t  FOR_BB_INSNS (bb, insn)\n-\t    if (INSN_P (insn))\n-\t      {\n-\t\tchanged |= cprop_insn (insn);\n-\n-\t\t/* Keep track of everything modified by this insn.  */\n-\t\t/* ??? Need to be careful w.r.t. mods done to INSN.\n-\t\t       Don't call mark_oprs_set if we turned the\n-\t\t       insn into a NOTE.  */\n-\t\tif (! NOTE_P (insn))\n-\t\t  mark_oprs_set (insn);\n-\t      }\n-\t}\n-\n-      changed |= bypass_conditional_jumps ();\n-      free_cprop_mem ();\n-    }\n-\n-  free_hash_table (&set_hash_table);\n-  free_gcse_mem ();\n-  obstack_free (&gcse_obstack, NULL);\n-\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"CPROP of %s, %d basic blocks, %d bytes needed, \",\n-\t       current_function_name (), n_basic_blocks, bytes_used);\n-      fprintf (dump_file, \"%d local const props, %d local copy props, \",\n-\t       local_const_prop_count, local_copy_prop_count);\n-      fprintf (dump_file, \"%d global const props, %d global copy props\\n\\n\",\n-\t       global_const_prop_count, global_copy_prop_count);\n-    }\n-\n-  return changed;\n-}\n-\n \f\n /* All the passes implemented in this file.  Each pass has its\n    own gate and execute function, and at the end of the file a\n@@ -5303,28 +3737,6 @@ one_cprop_pass (void)\n    setjmp.\n    FIXME: Should just handle setjmp via REG_SETJMP notes.  */\n \n-static bool\n-gate_rtl_cprop (void)\n-{\n-  return optimize > 0 && flag_gcse\n-    && !cfun->calls_setjmp\n-    && dbg_cnt (cprop);\n-}\n-\n-static unsigned int\n-execute_rtl_cprop (void)\n-{\n-  int changed;\n-  delete_unreachable_blocks ();\n-  df_set_flags (DF_LR_RUN_DCE);\n-  df_analyze ();\n-  changed = one_cprop_pass ();\n-  flag_rerun_cse_after_global_opts |= changed;\n-  if (changed)\n-    cleanup_cfg (0);\n-  return 0;\n-}\n-\n static bool\n gate_rtl_pre (void)\n {\n@@ -5372,27 +3784,6 @@ execute_rtl_hoist (void)\n   return 0;\n }\n \n-struct rtl_opt_pass pass_rtl_cprop =\n-{\n- {\n-  RTL_PASS,\n-  \"cprop\",                              /* name */\n-  gate_rtl_cprop,                       /* gate */\n-  execute_rtl_cprop,  \t\t\t/* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_CPROP,                             /* tv_id */\n-  PROP_cfglayout,                       /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_df_finish | TODO_verify_rtl_sharing |\n-  TODO_dump_func |\n-  TODO_verify_flow | TODO_ggc_collect   /* todo_flags_finish */\n- }\n-};\n-\n struct rtl_opt_pass pass_rtl_pre =\n {\n  {"}]}