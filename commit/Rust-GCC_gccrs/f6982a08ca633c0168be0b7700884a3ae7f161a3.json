{"sha": "f6982a08ca633c0168be0b7700884a3ae7f161a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjY5ODJhMDhjYTYzM2MwMTY4YmUwYjc3MDA4ODRhM2FlN2YxNjFhMw==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2014-05-03T09:42:52Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2014-05-03T09:42:52Z"}, "message": "sh.h (ROUND_ADVANCE): Delete macro.\n\n\t* config/sh/sh.h (ROUND_ADVANCE): Delete macro.\n\t(ROUND_REG, PASS_IN_REG_P): Move and rename macros to ...\n\t* config/sh/sh.c (sh_round_reg, sh_pass_in_reg_p): ... these new\n\tfunctions.\n\t(sh_arg_partial_bytes, sh_function_arg, sh_function_arg_advance,\n\tsh_setup_incoming_varargs): Replace usage of PASS_IN_REG_P with\n\tsh_pass_in_reg_p.\n\tReplace usage of ROUND_REG with sh_round_reg.\n\tUse CEIL instead of ROUND_ADVANCE.\n\nFrom-SVN: r210032", "tree": {"sha": "1b456e93876262373707f1e2e15e67d7197477cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b456e93876262373707f1e2e15e67d7197477cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6982a08ca633c0168be0b7700884a3ae7f161a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6982a08ca633c0168be0b7700884a3ae7f161a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6982a08ca633c0168be0b7700884a3ae7f161a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6982a08ca633c0168be0b7700884a3ae7f161a3/comments", "author": null, "committer": null, "parents": [{"sha": "3c922bcd25f3876ada4160e5109e27923f3828a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c922bcd25f3876ada4160e5109e27923f3828a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c922bcd25f3876ada4160e5109e27923f3828a2"}], "stats": {"total": 137, "additions": 79, "deletions": 58}, "files": [{"sha": "6464565bca202a284db7fa1d309ed383436c8105", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6982a08ca633c0168be0b7700884a3ae7f161a3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6982a08ca633c0168be0b7700884a3ae7f161a3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f6982a08ca633c0168be0b7700884a3ae7f161a3", "patch": "@@ -1,3 +1,15 @@\n+2014-05-03  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\t* config/sh/sh.h (ROUND_ADVANCE): Delete macro.\n+\t(ROUND_REG, PASS_IN_REG_P): Move and rename macros to ...\n+\t* config/sh/sh.c (sh_round_reg, sh_pass_in_reg_p): ... these new\n+\tfunctions.\n+\t(sh_arg_partial_bytes, sh_function_arg, sh_function_arg_advance,\n+\tsh_setup_incoming_varargs): Replace usage of PASS_IN_REG_P with\n+\tsh_pass_in_reg_p.\n+\tReplace usage of ROUND_REG with sh_round_reg.\n+\tUse CEIL instead of ROUND_ADVANCE.\n+\n 2014-05-03  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/61026"}, {"sha": "26a5d79f137baf3f1483bf9aafe9f5f8796b19dd", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 67, "deletions": 19, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6982a08ca633c0168be0b7700884a3ae7f161a3/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6982a08ca633c0168be0b7700884a3ae7f161a3/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=f6982a08ca633c0168be0b7700884a3ae7f161a3", "patch": "@@ -8809,6 +8809,54 @@ sh_callee_copies (cumulative_args_t cum, enum machine_mode mode,\n \t      % SH_MIN_ALIGN_FOR_CALLEE_COPY == 0));\n }\n \n+/* Round a register number up to a proper boundary for an arg of mode\n+   MODE.\n+   The SH doesn't care about double alignment, so we only\n+   round doubles to even regs when asked to explicitly.  */\n+static int\n+sh_round_reg (const CUMULATIVE_ARGS& cum, machine_mode mode)\n+{\n+  /* FIXME: This used to be a macro and has been copy pasted into this\n+     function as is.  Make this more readable.  */\n+  return\n+  (((TARGET_ALIGN_DOUBLE\n+      || ((TARGET_SH4 || TARGET_SH2A_DOUBLE)\n+\t  && (mode == DFmode || mode == DCmode)\n+\t  && cum.arg_count[(int) SH_ARG_FLOAT] < NPARM_REGS (mode)))\n+     && GET_MODE_UNIT_SIZE (mode) > UNITS_PER_WORD)\n+    ? (cum.arg_count[(int) GET_SH_ARG_CLASS (mode)]\n+       + (cum.arg_count[(int) GET_SH_ARG_CLASS (mode)] & 1))\n+    : cum.arg_count[(int) GET_SH_ARG_CLASS (mode)]);\n+}\n+\n+/* Return true if arg of the specified mode should be be passed in a register\n+   or false otherwise.  */\n+static bool\n+sh_pass_in_reg_p (const CUMULATIVE_ARGS& cum, machine_mode mode,\n+\t\t  const_tree type)\n+{\n+  /* FIXME: This used to be a macro and has been copy pasted into this\n+     function as is.  Make this more readable.  */\n+  return\n+  ((type == 0\n+    || (! TREE_ADDRESSABLE (type)\n+\t&& (! (TARGET_HITACHI || cum.renesas_abi)\n+\t    || ! (AGGREGATE_TYPE_P (type)\n+\t\t  || (!TARGET_FPU_ANY\n+\t\t      && (GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t\t\t  && GET_MODE_SIZE (mode) > GET_MODE_SIZE (SFmode)))))))\n+   && ! cum.force_mem\n+   && (TARGET_SH2E\n+       ? ((mode) == BLKmode\n+\t  ? ((cum.arg_count[(int) SH_ARG_INT] * UNITS_PER_WORD\n+\t      + int_size_in_bytes (type))\n+\t     <= NPARM_REGS (SImode) * UNITS_PER_WORD)\n+\t  : ((sh_round_reg (cum, mode)\n+\t      + HARD_REGNO_NREGS (BASE_ARG_REG (mode), mode))\n+\t     <= NPARM_REGS (mode)))\n+       : sh_round_reg (cum, mode) < NPARM_REGS (mode)));\n+}\n+\n static int\n sh_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,\n \t\t      tree type, bool named ATTRIBUTE_UNUSED)\n@@ -8817,14 +8865,14 @@ sh_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,\n   int words = 0;\n \n   if (!TARGET_SH5\n-      && PASS_IN_REG_P (*cum, mode, type)\n+      && sh_pass_in_reg_p (*cum, mode, type)\n       && !(TARGET_SH4 || TARGET_SH2A_DOUBLE)\n-      && (ROUND_REG (*cum, mode)\n+      && (sh_round_reg (*cum, mode)\n \t  + (mode != BLKmode\n-\t     ? ROUND_ADVANCE (GET_MODE_SIZE (mode))\n-\t     : ROUND_ADVANCE (int_size_in_bytes (type)))\n+\t     ? CEIL (GET_MODE_SIZE (mode), UNITS_PER_WORD)\n+\t     : CEIL (int_size_in_bytes (type), UNITS_PER_WORD))\n \t  > NPARM_REGS (mode)))\n-    words = NPARM_REGS (mode) - ROUND_REG (*cum, mode);\n+    words = NPARM_REGS (mode) - sh_round_reg (*cum, mode);\n \n   else if (!TARGET_SHCOMPACT\n \t   && SH5_WOULD_BE_PARTIAL_NREGS (*cum, mode, type, named))\n@@ -8861,23 +8909,23 @@ sh_function_arg (cumulative_args_t ca_v, enum machine_mode mode,\n     return GEN_INT (ca->renesas_abi ? 1 : 0);\n \n   if (! TARGET_SH5\n-      && PASS_IN_REG_P (*ca, mode, type)\n+      && sh_pass_in_reg_p (*ca, mode, type)\n       && (named || ! (TARGET_HITACHI || ca->renesas_abi)))\n     {\n       int regno;\n \n       if (mode == SCmode && TARGET_SH4 && TARGET_LITTLE_ENDIAN\n-\t  && (! FUNCTION_ARG_SCmode_WART || (ROUND_REG (*ca, mode) & 1)))\n+\t  && (! FUNCTION_ARG_SCmode_WART || (sh_round_reg (*ca, mode) & 1)))\n \t{\n \t  rtx r1 = gen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t\t      gen_rtx_REG (SFmode,\n \t\t\t\t\t\t   BASE_ARG_REG (mode)\n-\t\t\t\t\t\t   + (ROUND_REG (*ca, mode) ^ 1)),\n+\t\t\t\t\t\t   + (sh_round_reg (*ca, mode) ^ 1)),\n \t\t\t\t      const0_rtx);\n \t  rtx r2 = gen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t\t      gen_rtx_REG (SFmode,\n \t\t\t\t\t\t   BASE_ARG_REG (mode)\n-\t\t\t\t\t\t   + ((ROUND_REG (*ca, mode) + 1) ^ 1)),\n+\t\t\t\t\t\t   + ((sh_round_reg (*ca, mode) + 1) ^ 1)),\n \t\t\t\t      GEN_INT (4));\n \t  return gen_rtx_PARALLEL(SCmode, gen_rtvec(2, r1, r2));\n \t}\n@@ -8890,7 +8938,7 @@ sh_function_arg (cumulative_args_t ca_v, enum machine_mode mode,\n \t  && mode == SFmode)\n \treturn gen_rtx_REG (mode, ca->free_single_fp_reg);\n \n-      regno = (BASE_ARG_REG (mode) + ROUND_REG (*ca, mode))\n+      regno = (BASE_ARG_REG (mode) + sh_round_reg (*ca, mode))\n \t       ^ (mode == SFmode && TARGET_SH4\n \t\t  && TARGET_LITTLE_ENDIAN\n \t\t  && ! TARGET_HITACHI && ! ca->renesas_abi);\n@@ -9070,20 +9118,20 @@ sh_function_arg_advance (cumulative_args_t ca_v, enum machine_mode mode,\n \t register, because the next SF value will use it, and not the\n \t SF that follows the DF.  */\n       if (mode == DFmode\n-\t  && ROUND_REG (*ca, DFmode) != ROUND_REG (*ca, SFmode))\n+\t  && sh_round_reg (*ca, DFmode) != sh_round_reg (*ca, SFmode))\n \t{\n-\t  ca->free_single_fp_reg = (ROUND_REG (*ca, SFmode)\n+\t  ca->free_single_fp_reg = (sh_round_reg (*ca, SFmode)\n \t\t\t\t    + BASE_ARG_REG (mode));\n \t}\n     }\n \n   if (! ((TARGET_SH4 || TARGET_SH2A) || ca->renesas_abi)\n-      || PASS_IN_REG_P (*ca, mode, type))\n+      || sh_pass_in_reg_p (*ca, mode, type))\n     (ca->arg_count[(int) GET_SH_ARG_CLASS (mode)]\n-     = (ROUND_REG (*ca, mode)\n+     = (sh_round_reg (*ca, mode)\n \t+ (mode == BLKmode\n-\t   ? ROUND_ADVANCE (int_size_in_bytes (type))\n-\t   : ROUND_ADVANCE (GET_MODE_SIZE (mode)))));\n+\t   ? CEIL (int_size_in_bytes (type), UNITS_PER_WORD)\n+\t   : CEIL (GET_MODE_SIZE (mode), UNITS_PER_WORD))));\n }\n \n /* The Renesas calling convention doesn't quite fit into this scheme since\n@@ -9178,10 +9226,10 @@ sh_setup_incoming_varargs (cumulative_args_t ca,\n     {\n       int named_parm_regs, anon_parm_regs;\n \n-      named_parm_regs = (ROUND_REG (*get_cumulative_args (ca), mode)\n+      named_parm_regs = (sh_round_reg (*get_cumulative_args (ca), mode)\n \t\t\t + (mode == BLKmode\n-\t\t\t    ? ROUND_ADVANCE (int_size_in_bytes (type))\n-\t\t\t    : ROUND_ADVANCE (GET_MODE_SIZE (mode))));\n+\t\t\t    ? CEIL (int_size_in_bytes (type), UNITS_PER_WORD)\n+\t\t\t    : CEIL (GET_MODE_SIZE (mode), UNITS_PER_WORD)));\n       anon_parm_regs = NPARM_REGS (SImode) - named_parm_regs;\n       if (anon_parm_regs > 0)\n \t*pretend_arg_size = anon_parm_regs * 4;"}, {"sha": "0b6bd1bc94a69c0c13093c40fefc3ba81cb50055", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6982a08ca633c0168be0b7700884a3ae7f161a3/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6982a08ca633c0168be0b7700884a3ae7f161a3/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=f6982a08ca633c0168be0b7700884a3ae7f161a3", "patch": "@@ -1361,24 +1361,6 @@ struct sh_args {\n \t\t\t   || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT) \\\n    ? SH_ARG_FLOAT : SH_ARG_INT)\n \n-#define ROUND_ADVANCE(SIZE) \\\n-  (((SIZE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n-/* Round a register number up to a proper boundary for an arg of mode\n-   MODE.\n-\n-   The SH doesn't care about double alignment, so we only\n-   round doubles to even regs when asked to explicitly.  */\n-#define ROUND_REG(CUM, MODE) \\\n-   (((TARGET_ALIGN_DOUBLE\t\t\t\t\t\t\\\n-      || ((TARGET_SH4 || TARGET_SH2A_DOUBLE) \t\t\t\t\\\n-\t  && ((MODE) == DFmode || (MODE) == DCmode)\t\t\t\\\n-\t  && (CUM).arg_count[(int) SH_ARG_FLOAT] < NPARM_REGS (MODE)))\t\\\n-     && GET_MODE_UNIT_SIZE ((MODE)) > UNITS_PER_WORD)\t\t\t\\\n-    ? ((CUM).arg_count[(int) GET_SH_ARG_CLASS (MODE)]\t\t\t\\\n-       + ((CUM).arg_count[(int) GET_SH_ARG_CLASS (MODE)] & 1))\t\t\\\n-    : (CUM).arg_count[(int) GET_SH_ARG_CLASS (MODE)])\n-\n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n    For a library call, FNTYPE is 0.\n@@ -1394,27 +1376,6 @@ struct sh_args {\n #define INIT_CUMULATIVE_LIBCALL_ARGS(CUM, MODE, LIBNAME) \\\n   sh_init_cumulative_args (& (CUM), NULL_TREE, (LIBNAME), NULL_TREE, 0, (MODE))\n \n-/* Return boolean indicating arg of mode MODE will be passed in a reg.\n-   This macro is only used in this file.  */\n-#define PASS_IN_REG_P(CUM, MODE, TYPE) \\\n-  (((TYPE) == 0 \\\n-    || (! TREE_ADDRESSABLE ((TYPE)) \\\n-\t&& (! (TARGET_HITACHI || (CUM).renesas_abi) \\\n-\t    || ! (AGGREGATE_TYPE_P (TYPE) \\\n-\t\t  || (!TARGET_FPU_ANY \\\n-\t\t      && (GET_MODE_CLASS (MODE) == MODE_FLOAT \\\n-\t\t\t  && GET_MODE_SIZE (MODE) > GET_MODE_SIZE (SFmode))))))) \\\n-   && ! (CUM).force_mem \\\n-   && (TARGET_SH2E \\\n-       ? ((MODE) == BLKmode \\\n-\t  ? (((CUM).arg_count[(int) SH_ARG_INT] * UNITS_PER_WORD \\\n-\t      + int_size_in_bytes (TYPE)) \\\n-\t     <= NPARM_REGS (SImode) * UNITS_PER_WORD) \\\n-\t  : ((ROUND_REG((CUM), (MODE)) \\\n-\t      + HARD_REGNO_NREGS (BASE_ARG_REG (MODE), (MODE))) \\\n-\t     <= NPARM_REGS (MODE))) \\\n-       : ROUND_REG ((CUM), (MODE)) < NPARM_REGS (MODE)))\n-\n /* By accident we got stuck with passing SCmode on SH4 little endian\n    in two registers that are nominally successive - which is different from\n    two single SFmode values, where we take endianness translation into"}]}