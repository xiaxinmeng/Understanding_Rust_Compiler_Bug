{"sha": "ae25dbda33696aa6a15840ec31b48f84d6bf8be0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWUyNWRiZGEzMzY5NmFhNmExNTg0MGVjMzFiNDhmODRkNmJmOGJlMA==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2006-03-30T14:31:13Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2006-03-30T14:31:13Z"}, "message": "re PR tree-optimization/26830 (Repeated SSA update during loop header copying)\n\n2006-03-30  Paolo Bonzini  <bonzini@gnu.org>\n\n\tPR tree-optimization/26830\n\n\t* tree-ssa-copy.c (copy_prop_visit_assignment): Do not check loop depth.\n\t(copy_prop_visit_stmt): Remove write-only variable ann.\n\t(init_copy_prop): Check variable loop depth here.  Do not simulate\n\tmemory-tag and virtual operand PHIs except for store copy prop.\n\nFrom-SVN: r112534", "tree": {"sha": "5ebedfdba154701e2ff0a85ac4fcab11a7da64c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ebedfdba154701e2ff0a85ac4fcab11a7da64c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae25dbda33696aa6a15840ec31b48f84d6bf8be0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae25dbda33696aa6a15840ec31b48f84d6bf8be0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae25dbda33696aa6a15840ec31b48f84d6bf8be0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae25dbda33696aa6a15840ec31b48f84d6bf8be0/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7d3a3b01c3f43635a798a0e03765aef9fdf17e9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d3a3b01c3f43635a798a0e03765aef9fdf17e9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d3a3b01c3f43635a798a0e03765aef9fdf17e9e"}], "stats": {"total": 69, "additions": 42, "deletions": 27}, "files": [{"sha": "1c968013ddfe989d01623e12859fa4d53d0b01e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae25dbda33696aa6a15840ec31b48f84d6bf8be0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae25dbda33696aa6a15840ec31b48f84d6bf8be0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ae25dbda33696aa6a15840ec31b48f84d6bf8be0", "patch": "@@ -1,3 +1,12 @@\n+2006-03-30  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\tPR tree-optimization/26830\n+\n+\t* tree-ssa-copy.c (copy_prop_visit_assignment): Do not check loop depth.\n+\t(copy_prop_visit_stmt): Remove write-only variable ann.\n+\t(init_copy_prop): Check variable loop depth here.  Do not simulate\n+\tmemory-tag and virtual operand PHIs except for store copy prop.\n+\n 2006-03-30  Richard Guenther  <rguenther@suse.de>\n \n \t* config/i386/i386.c: Remove builtins for SSE2 ABI intrinsic"}, {"sha": "d3bc53364fdce805d9c3c18ba8b8e5f93f76d303", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 33, "deletions": 27, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae25dbda33696aa6a15840ec31b48f84d6bf8be0/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae25dbda33696aa6a15840ec31b48f84d6bf8be0/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=ae25dbda33696aa6a15840ec31b48f84d6bf8be0", "patch": "@@ -550,14 +550,6 @@ copy_prop_visit_assignment (tree stmt, tree *result_p)\n       if (!may_propagate_copy (lhs, rhs))\n \treturn SSA_PROP_VARYING;\n \n-      /* Avoid copy propagation from an inner into an outer loop.\n-\t Otherwise, this may move loop variant variables outside of\n-\t their loops and prevent coalescing opportunities.  If the\n-\t value was loop invariant, it will be hoisted by LICM and\n-\t exposed for copy propagation.  */\n-      if (loop_depth_of_name (rhs) > loop_depth_of_name (lhs))\n-\treturn SSA_PROP_VARYING;\n-\n       /* Notice that in the case of assignments, we make the LHS be a\n \t copy of RHS's value, not of RHS itself.  This avoids keeping\n \t unnecessary copy-of chains (assignments cannot be in a cycle\n@@ -671,7 +663,6 @@ copy_prop_visit_cond_stmt (tree stmt, edge *taken_edge_p)\n static enum ssa_prop_result\n copy_prop_visit_stmt (tree stmt, edge *taken_edge_p, tree *result_p)\n {\n-  stmt_ann_t ann;\n   enum ssa_prop_result retval;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -681,8 +672,6 @@ copy_prop_visit_stmt (tree stmt, edge *taken_edge_p, tree *result_p)\n       fprintf (dump_file, \"\\n\");\n     }\n \n-  ann = stmt_ann (stmt);\n-\n   if (TREE_CODE (stmt) == MODIFY_EXPR\n       && TREE_CODE (TREE_OPERAND (stmt, 1)) == SSA_NAME\n       && (do_store_copy_prop\n@@ -856,37 +845,54 @@ init_copy_prop (void)\n   FOR_EACH_BB (bb)\n     {\n       block_stmt_iterator si;\n-      tree phi;\n+      tree phi, def;\n+      int depth = bb->loop_depth;\n \n       for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n \t{\n \t  tree stmt = bsi_stmt (si);\n+\t  ssa_op_iter iter;\n \n \t  /* The only statements that we care about are those that may\n \t     generate useful copies.  We also need to mark conditional\n \t     jumps so that their outgoing edges are added to the work\n-\t     lists of the propagator.  */\n+\t     lists of the propagator.\n+\n+\t     Avoid copy propagation from an inner into an outer loop.\n+\t     Otherwise, this may move loop variant variables outside of\n+\t     their loops and prevent coalescing opportunities.  If the\n+\t     value was loop invariant, it will be hoisted by LICM and\n+\t     exposed for copy propagation.  */\n \t  if (stmt_ends_bb_p (stmt))\n \t    DONT_SIMULATE_AGAIN (stmt) = false;\n-\t  else if (stmt_may_generate_copy (stmt))\n+\t  else if (stmt_may_generate_copy (stmt)\n+\t\t   && loop_depth_of_name (TREE_OPERAND (stmt, 1)) <= depth)\n \t    DONT_SIMULATE_AGAIN (stmt) = false;\n \t  else\n-\t    {\n-\t      tree def;\n-\t      ssa_op_iter iter;\n-\n-\t      /* No need to simulate this statement anymore.  */\n-\t      DONT_SIMULATE_AGAIN (stmt) = true;\n-\n-\t      /* Mark all the outputs of this statement as not being\n-\t\t the copy of anything.  */\n-\t      FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_ALL_DEFS)\n-\t\tset_copy_of_val (def, def, NULL_TREE);\n-\t    }\n+\t    DONT_SIMULATE_AGAIN (stmt) = true;\n+\n+\t  /* Mark all the outputs of this statement as not being\n+\t     the copy of anything.  */\n+\t  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_ALL_DEFS)\n+\t    if (DONT_SIMULATE_AGAIN (stmt))\n+\t      set_copy_of_val (def, def, NULL_TREE);\n+\t    else\n+\t      cached_last_copy_of[SSA_NAME_VERSION (def)] = def;\n \t}\n \n       for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-\tDONT_SIMULATE_AGAIN (phi) = false;\n+\t{\n+\t  def = PHI_RESULT (phi);\n+\t  if (!do_store_copy_prop && !is_gimple_reg (def))\n+\t    DONT_SIMULATE_AGAIN (phi) = true;\n+\t  else\n+\t    DONT_SIMULATE_AGAIN (phi) = false;\n+\n+\t  if (DONT_SIMULATE_AGAIN (phi))\n+\t    set_copy_of_val (def, def, NULL_TREE);\n+\t  else\n+\t    cached_last_copy_of[SSA_NAME_VERSION (def)] = def;\n+\t}\n     }\n }\n "}]}