{"sha": "2ba4f1fb6ecf07b7779910035d0ff75982d383fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJhNGYxZmI2ZWNmMDdiNzc3OTkxMDAzNWQwZmY3NTk4MmQzODNmYg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-26T11:11:10Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-26T11:11:10Z"}, "message": "[multiple changes]\n\n2015-10-26  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb: Handle subprogram bodies without previous specs.\n\n2015-10-26  Claire Dross  <dross@adacore.com>\n\n\t* a-nudira.ads: Specify appropriate SPARK_Mode so that the unit\n\tcan be used in SPARK code.\n\n2015-10-26  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* contracts.adb (Analyze_Subprogram_Body_Contract): Do not analyze\n\tpragmas Refined_Global and Refined_Depends because these pragmas\n\tare now fully analyzed when encountered.\n\t(Inherit_Pragma): Update the call to attribute Is_Inherited.\n\t* sem_prag.adb (Analyze_Contract_Cases_In_Decl_Part): Add a guard\n\tto prevent reanalysis. Mark the pragma as analyzed at the end of\n\tthe processing.\n\t(Analyze_Depends_Global): New parameter profile\n\tand comment on usage. Do not fully analyze the pragma, this is\n\tnow done at the outer level.\n\t(Analyze_Depends_In_Decl_Part): Add a guard to prevent reanalysis.\n\tMark the pragma as analyzed at the end of the processing.\n\t(Analyze_External_Property_In_Decl_Part): Add a guard to prevent\n\treanalysis.  Mark the pragma as analyzed at the end of the processing.\n\t(Analyze_Global_In_Decl_Part): Add a guard to prevent reanalysis. Mark\n\tthe pragma as analyzed at the end of the processing.\n\t(Analyze_Initial_Condition_In_Decl_Part): Add a guard to prevent\n\treanalysis.  Mark the pragma as analyzed at the end of the processing.\n\t(Analyze_Initializes_In_Decl_Part): Add a guard to prevent reanalysis.\n\tMark the pragma as analyzed at the end of the processing.\n\t(Analyze_Pragma): Reset the Analyzed flag on various pragmas that\n\trequire delayed full analysis. Contract_Cases is now analyzed\n\timmediately when it applies to a subprogram body stub. Pragmas Depends,\n\tGlobal, Refined_Depends and Refined_Global are now analyzed\n\tin pairs when they appear in a subprogram body [stub].\n\t(Analyze_Pre_Post_Condition_In_Decl_Part): Add a guard to\n\tprevent reanalysis.  Mark the pragma as analyzed at the end of\n\tthe processing.\n\t(Analyze_Refined_Depends_Global_Post): Update the comment on usage.\n\t(Analyze_Refined_Depends_In_Decl_Part): Add a guard to prevent\n\treanalysis. Mark the pragma as analyzed at the end of the processing.\n\t(Analyze_Refined_Global_In_Decl_Part): Add a guard to prevent\n\treanalysis. Mark the pragma as analyzed at the end of the processing.\n\t(Analyze_Refined_State_In_Decl_Part): Add a guard to prevent\n\treanalysis. Mark the pragma as analyzed at the end of the processing.\n\t(Analyze_Test_Case_In_Decl_Part): Add a guard to prevent reanalysis.\n\tMark the pragma as analyzed at the end of the processing.\n\t(Is_Followed_By_Pragma): New routine.\n\t* sinfo.adb (Is_Analyzed_Pragma): New routine.\n\t(Is_Inherited): Renamed to Is_Inherited_Pragma.\n\t(Set_Is_Analyzed_Pragma): New routine.\n\t(Set_Is_Inherited): Renamed to Set_Is_Inherited_Pragma.\n\t* sinfo.ads Rename attribute Is_Inherited to Is_Inherited_Pragma\n\tand update occurrences in nodes.\n\t(Is_Analyzed_Pragma): New routine along with pragma Inline.\n\t(Is_Inherited): Renamed to Is_Inherited_Pragma along with pragma Inline.\n\t(Set_Is_Analyzed_Pragma): New routine along with pragma Inline.\n\t(Set_Is_Inherited): Renamed to Set_Is_Inherited_Pragma along\n\twith pragma Inline.\n\n2015-10-26  Ed Schonberg  <schonberg@adacore.com>\n\n\t* par-ch3.adb (P_Component_Items): When style checks are enabled,\n\tapply them to component declarations in a record type declaration\n\tor extension.\n\nFrom-SVN: r229330", "tree": {"sha": "663091dba858d839d1757e513d32128240109ff1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/663091dba858d839d1757e513d32128240109ff1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ba4f1fb6ecf07b7779910035d0ff75982d383fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ba4f1fb6ecf07b7779910035d0ff75982d383fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ba4f1fb6ecf07b7779910035d0ff75982d383fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ba4f1fb6ecf07b7779910035d0ff75982d383fb/comments", "author": null, "committer": null, "parents": [{"sha": "ed962eda60df47f3b03e1a41a419c48e6fce1bb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed962eda60df47f3b03e1a41a419c48e6fce1bb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed962eda60df47f3b03e1a41a419c48e6fce1bb3"}], "stats": {"total": 693, "additions": 559, "deletions": 134}, "files": [{"sha": "38232d6f17103b5e7f27b6a22cdfc55960de33c7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba4f1fb6ecf07b7779910035d0ff75982d383fb/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba4f1fb6ecf07b7779910035d0ff75982d383fb/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2ba4f1fb6ecf07b7779910035d0ff75982d383fb", "patch": "@@ -1,3 +1,70 @@\n+2015-10-26  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb: Handle subprogram bodies without previous specs.\n+\n+2015-10-26  Claire Dross  <dross@adacore.com>\n+\n+\t* a-nudira.ads: Specify appropriate SPARK_Mode so that the unit\n+\tcan be used in SPARK code.\n+\n+2015-10-26  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* contracts.adb (Analyze_Subprogram_Body_Contract): Do not analyze\n+\tpragmas Refined_Global and Refined_Depends because these pragmas\n+\tare now fully analyzed when encountered.\n+\t(Inherit_Pragma): Update the call to attribute Is_Inherited.\n+\t* sem_prag.adb (Analyze_Contract_Cases_In_Decl_Part): Add a guard\n+\tto prevent reanalysis. Mark the pragma as analyzed at the end of\n+\tthe processing.\n+\t(Analyze_Depends_Global): New parameter profile\n+\tand comment on usage. Do not fully analyze the pragma, this is\n+\tnow done at the outer level.\n+\t(Analyze_Depends_In_Decl_Part): Add a guard to prevent reanalysis.\n+\tMark the pragma as analyzed at the end of the processing.\n+\t(Analyze_External_Property_In_Decl_Part): Add a guard to prevent\n+\treanalysis.  Mark the pragma as analyzed at the end of the processing.\n+\t(Analyze_Global_In_Decl_Part): Add a guard to prevent reanalysis. Mark\n+\tthe pragma as analyzed at the end of the processing.\n+\t(Analyze_Initial_Condition_In_Decl_Part): Add a guard to prevent\n+\treanalysis.  Mark the pragma as analyzed at the end of the processing.\n+\t(Analyze_Initializes_In_Decl_Part): Add a guard to prevent reanalysis.\n+\tMark the pragma as analyzed at the end of the processing.\n+\t(Analyze_Pragma): Reset the Analyzed flag on various pragmas that\n+\trequire delayed full analysis. Contract_Cases is now analyzed\n+\timmediately when it applies to a subprogram body stub. Pragmas Depends,\n+\tGlobal, Refined_Depends and Refined_Global are now analyzed\n+\tin pairs when they appear in a subprogram body [stub].\n+\t(Analyze_Pre_Post_Condition_In_Decl_Part): Add a guard to\n+\tprevent reanalysis.  Mark the pragma as analyzed at the end of\n+\tthe processing.\n+\t(Analyze_Refined_Depends_Global_Post): Update the comment on usage.\n+\t(Analyze_Refined_Depends_In_Decl_Part): Add a guard to prevent\n+\treanalysis. Mark the pragma as analyzed at the end of the processing.\n+\t(Analyze_Refined_Global_In_Decl_Part): Add a guard to prevent\n+\treanalysis. Mark the pragma as analyzed at the end of the processing.\n+\t(Analyze_Refined_State_In_Decl_Part): Add a guard to prevent\n+\treanalysis. Mark the pragma as analyzed at the end of the processing.\n+\t(Analyze_Test_Case_In_Decl_Part): Add a guard to prevent reanalysis.\n+\tMark the pragma as analyzed at the end of the processing.\n+\t(Is_Followed_By_Pragma): New routine.\n+\t* sinfo.adb (Is_Analyzed_Pragma): New routine.\n+\t(Is_Inherited): Renamed to Is_Inherited_Pragma.\n+\t(Set_Is_Analyzed_Pragma): New routine.\n+\t(Set_Is_Inherited): Renamed to Set_Is_Inherited_Pragma.\n+\t* sinfo.ads Rename attribute Is_Inherited to Is_Inherited_Pragma\n+\tand update occurrences in nodes.\n+\t(Is_Analyzed_Pragma): New routine along with pragma Inline.\n+\t(Is_Inherited): Renamed to Is_Inherited_Pragma along with pragma Inline.\n+\t(Set_Is_Analyzed_Pragma): New routine along with pragma Inline.\n+\t(Set_Is_Inherited): Renamed to Set_Is_Inherited_Pragma along\n+\twith pragma Inline.\n+\n+2015-10-26  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* par-ch3.adb (P_Component_Items): When style checks are enabled,\n+\tapply them to component declarations in a record type declaration\n+\tor extension.\n+\n 2015-10-26  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_util.adb (Is_Suspension_Object): Ensure that the scope of \"Ada\""}, {"sha": "156d018a1f3a3f302b7d92632bdaae3a944036da", "filename": "gcc/ada/a-nudira.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba4f1fb6ecf07b7779910035d0ff75982d383fb/gcc%2Fada%2Fa-nudira.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba4f1fb6ecf07b7779910035d0ff75982d383fb/gcc%2Fada%2Fa-nudira.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nudira.adb?ref=2ba4f1fb6ecf07b7779910035d0ff75982d383fb", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,7 +29,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-package body Ada.Numerics.Discrete_Random is\n+package body Ada.Numerics.Discrete_Random with SPARK_Mode => Off is\n \n    package SRN renames System.Random_Numbers;\n    use SRN;"}, {"sha": "7234a39729e01239ccf199206fb8057c7c13136a", "filename": "gcc/ada/a-nudira.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba4f1fb6ecf07b7779910035d0ff75982d383fb/gcc%2Fada%2Fa-nudira.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba4f1fb6ecf07b7779910035d0ff75982d383fb/gcc%2Fada%2Fa-nudira.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-nudira.ads?ref=2ba4f1fb6ecf07b7779910035d0ff75982d383fb", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -41,7 +41,7 @@ with System.Random_Numbers;\n generic\n    type Result_Subtype is (<>);\n \n-package Ada.Numerics.Discrete_Random is\n+package Ada.Numerics.Discrete_Random with SPARK_Mode is\n \n    --  Basic facilities\n \n@@ -65,6 +65,7 @@ package Ada.Numerics.Discrete_Random is\n    function Value (Coded_State : String) return State;\n \n private\n+   pragma SPARK_Mode (Off);\n \n    type Generator is new System.Random_Numbers.Generator;\n "}, {"sha": "e41ae2054d053330975d6b3f004dc4325b0f7143", "filename": "gcc/ada/contracts.adb", "status": "modified", "additions": 5, "deletions": 53, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba4f1fb6ecf07b7779910035d0ff75982d383fb/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba4f1fb6ecf07b7779910035d0ff75982d383fb/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=2ba4f1fb6ecf07b7779910035d0ff75982d383fb", "patch": "@@ -622,14 +622,10 @@ package body Contracts is\n    --------------------------------------\n \n    procedure Analyze_Subprogram_Body_Contract (Body_Id : Entity_Id) is\n-      Body_Decl   : constant Node_Id   := Unit_Declaration_Node (Body_Id);\n-      Items       : constant Node_Id   := Contract (Body_Id);\n-      Spec_Id     : constant Entity_Id := Unique_Defining_Entity (Body_Decl);\n-      Mode        : SPARK_Mode_Type;\n-      Prag        : Node_Id;\n-      Prag_Nam    : Name_Id;\n-      Ref_Depends : Node_Id   := Empty;\n-      Ref_Global  : Node_Id   := Empty;\n+      Body_Decl : constant Node_Id   := Unit_Declaration_Node (Body_Id);\n+      Items     : constant Node_Id   := Contract (Body_Id);\n+      Spec_Id   : constant Entity_Id := Unique_Defining_Entity (Body_Decl);\n+      Mode      : SPARK_Mode_Type;\n \n    begin\n       --  When a subprogram body declaration is illegal, its defining entity is\n@@ -656,50 +652,6 @@ package body Contracts is\n \n       Save_SPARK_Mode_And_Set (Body_Id, Mode);\n \n-      --  All subprograms carry a contract, but for some it is not significant\n-      --  and should not be processed.\n-\n-      if not Has_Significant_Contract (Body_Id) then\n-         null;\n-\n-      --  The subprogram body is a completion, analyze all delayed pragmas that\n-      --  apply. Note that when the body is stand-alone, the pragmas are always\n-      --  analyzed on the spot.\n-\n-      elsif Present (Items) then\n-\n-         --  Locate and store pragmas Refined_Depends and Refined_Global, since\n-         --  their order of analysis matters.\n-\n-         Prag := Classifications (Items);\n-         while Present (Prag) loop\n-            Prag_Nam := Pragma_Name (Prag);\n-\n-            if Prag_Nam = Name_Refined_Depends then\n-               Ref_Depends := Prag;\n-\n-            elsif Prag_Nam = Name_Refined_Global then\n-               Ref_Global := Prag;\n-            end if;\n-\n-            Prag := Next_Pragma (Prag);\n-         end loop;\n-\n-         --  Analyze Refined_Global first, as Refined_Depends may mention items\n-         --  classified in the global refinement.\n-\n-         if Present (Ref_Global) then\n-            Analyze_Refined_Global_In_Decl_Part (Ref_Global);\n-         end if;\n-\n-         --  Refined_Depends must be analyzed after Refined_Global in order to\n-         --  see the modes of all global refinements.\n-\n-         if Present (Ref_Depends) then\n-            Analyze_Refined_Depends_In_Decl_Part (Ref_Depends);\n-         end if;\n-      end if;\n-\n       --  Ensure that the contract cases or postconditions mention 'Result or\n       --  define a post-state.\n \n@@ -2327,7 +2279,7 @@ package body Contracts is\n \n          if Present (Prag) then\n             New_Prag := New_Copy_Tree (Prag);\n-            Set_Is_Inherited (New_Prag);\n+            Set_Is_Inherited_Pragma (New_Prag);\n \n             Add_Contract_Item (New_Prag, Subp);\n          end if;"}, {"sha": "82c33fe6c9feb6e2366f3b158f9c31292867256d", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba4f1fb6ecf07b7779910035d0ff75982d383fb/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba4f1fb6ecf07b7779910035d0ff75982d383fb/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=2ba4f1fb6ecf07b7779910035d0ff75982d383fb", "patch": "@@ -3510,6 +3510,7 @@ package body Ch3 is\n       end if;\n \n       Ident_Sloc := Token_Ptr;\n+      Check_Bad_Layout;\n       Idents (1) := P_Defining_Identifier (C_Comma_Colon);\n       Num_Idents := 1;\n "}, {"sha": "98eafd761c8486b59c3e388272cfd4a099d3f7fc", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba4f1fb6ecf07b7779910035d0ff75982d383fb/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba4f1fb6ecf07b7779910035d0ff75982d383fb/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=2ba4f1fb6ecf07b7779910035d0ff75982d383fb", "patch": "@@ -3148,6 +3148,18 @@ package body Sem_Ch6 is\n                  and then not Inside_A_Generic\n                then\n                   Build_Subprogram_Declaration;\n+\n+               --  If this is a function that returns a constrained array, and\n+               --  we are generating SPARK_For_C, create subprogram declaration\n+               --  to simplify subsequent C generation.\n+\n+               elsif No (Spec_Id)\n+                 and then Modify_Tree_For_C\n+                 and then Nkind (Body_Spec) = N_Function_Specification\n+                 and then Is_Array_Type (Etype (Body_Id))\n+                 and then Is_Constrained (Etype (Body_Id))\n+               then\n+                  Build_Subprogram_Declaration;\n                end if;\n             end if;\n "}, {"sha": "ca66fe2d906224f9e60ad3ab6eaa89a7ca433eab", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 426, "deletions": 66, "changes": 492, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba4f1fb6ecf07b7779910035d0ff75982d383fb/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba4f1fb6ecf07b7779910035d0ff75982d383fb/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=2ba4f1fb6ecf07b7779910035d0ff75982d383fb", "patch": "@@ -398,13 +398,18 @@ package body Sem_Prag is\n    --  Start of processing for Analyze_Contract_Cases_In_Decl_Part\n \n    begin\n+      --  Do not analyze the pragma multiple times\n+\n+      if Is_Analyzed_Pragma (N) then\n+         return;\n+      end if;\n+\n       --  Set the Ghost mode in effect from the pragma. Due to the delayed\n       --  analysis of the pragma, the Ghost mode at point of declaration and\n       --  point of analysis may not necessarely be the same. Use the mode in\n       --  effect at the point of declaration.\n \n       Set_Ghost_Mode (N);\n-      Set_Analyzed (N);\n \n       --  Single and multiple contract cases must appear in aggregate form. If\n       --  this is not the case, then either the parser of the analysis of the\n@@ -451,6 +456,7 @@ package body Sem_Prag is\n       end if;\n \n       Ghost_Mode := Save_Ghost_Mode;\n+      Set_Is_Analyzed_Pragma (N);\n    end Analyze_Contract_Cases_In_Decl_Part;\n \n    ----------------------------------\n@@ -1573,7 +1579,11 @@ package body Sem_Prag is\n    --  Start of processing for Analyze_Depends_In_Decl_Part\n \n    begin\n-      Set_Analyzed (N);\n+      --  Do not analyze the pragma multiple times\n+\n+      if Is_Analyzed_Pragma (N) then\n+         return;\n+      end if;\n \n       --  Empty dependency list\n \n@@ -1688,7 +1698,7 @@ package body Sem_Prag is\n \n       else\n          Error_Msg_N (\"malformed dependency relation\", Deps);\n-         return;\n+         goto Leave;\n       end if;\n \n       --  Ensure that a state and a corresponding constituent do not appear\n@@ -1698,6 +1708,9 @@ package body Sem_Prag is\n         (States   => States_Seen,\n          Constits => Constits_Seen,\n          Context  => N);\n+\n+      <<Leave>>\n+      Set_Is_Analyzed_Pragma (N);\n    end Analyze_Depends_In_Decl_Part;\n \n    --------------------------------------------\n@@ -1714,6 +1727,14 @@ package body Sem_Prag is\n       Expr     : Node_Id;\n \n    begin\n+      Expr_Val := False;\n+\n+      --  Do not analyze the pragma multiple times\n+\n+      if Is_Analyzed_Pragma (N) then\n+         return;\n+      end if;\n+\n       Error_Msg_Name_1 := Pragma_Name (N);\n \n       --  An external property pragma must apply to an effectively volatile\n@@ -1742,6 +1763,8 @@ package body Sem_Prag is\n             Expr_Val := Is_True (Expr_Value (Expr));\n          end if;\n       end if;\n+\n+      Set_Is_Analyzed_Pragma (N);\n    end Analyze_External_Property_In_Decl_Part;\n \n    ---------------------------------\n@@ -2210,7 +2233,11 @@ package body Sem_Prag is\n    --  Start of processing for Analyze_Global_In_Decl_Part\n \n    begin\n-      Set_Analyzed (N);\n+      --  Do not analyze the pragma multiple times\n+\n+      if Is_Analyzed_Pragma (N) then\n+         return;\n+      end if;\n \n       --  There is nothing to be done for a null global list\n \n@@ -2251,6 +2278,8 @@ package body Sem_Prag is\n         (States   => States_Seen,\n          Constits => Constits_Seen,\n          Context  => N);\n+\n+      Set_Is_Analyzed_Pragma (N);\n    end Analyze_Global_In_Decl_Part;\n \n    --------------------------------------------\n@@ -2265,20 +2294,27 @@ package body Sem_Prag is\n       Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n \n    begin\n+      --  Do not analyze the pragma multiple times\n+\n+      if Is_Analyzed_Pragma (N) then\n+         return;\n+      end if;\n+\n       --  Set the Ghost mode in effect from the pragma. Due to the delayed\n       --  analysis of the pragma, the Ghost mode at point of declaration and\n       --  point of analysis may not necessarely be the same. Use the mode in\n       --  effect at the point of declaration.\n \n       Set_Ghost_Mode (N);\n-      Set_Analyzed (N);\n \n       --  The expression is preanalyzed because it has not been moved to its\n       --  final place yet. A direct analysis may generate side effects and this\n       --  is not desired at this point.\n \n       Preanalyze_Assert_Expression (Expr, Standard_Boolean);\n       Ghost_Mode := Save_Ghost_Mode;\n+\n+      Set_Is_Analyzed_Pragma (N);\n    end Analyze_Initial_Condition_In_Decl_Part;\n \n    --------------------------------------\n@@ -2613,7 +2649,11 @@ package body Sem_Prag is\n    --  Start of processing for Analyze_Initializes_In_Decl_Part\n \n    begin\n-      Set_Analyzed (N);\n+      --  Do not analyze the pragma multiple times\n+\n+      if Is_Analyzed_Pragma (N) then\n+         return;\n+      end if;\n \n       --  Nothing to do when the initialization list is empty\n \n@@ -2654,6 +2694,8 @@ package body Sem_Prag is\n         (States   => States_Seen,\n          Constits => Constits_Seen,\n          Context  => N);\n+\n+      Set_Is_Analyzed_Pragma (N);\n    end Analyze_Initializes_In_Decl_Part;\n \n    --------------------\n@@ -2709,8 +2751,14 @@ package body Sem_Prag is\n       --  In Ada 95 or 05 mode, these are implementation defined pragmas, so\n       --  should be caught by the No_Implementation_Pragmas restriction.\n \n-      procedure Analyze_Depends_Global;\n-      --  Subsidiary to the analysis of pragma Depends and Global\n+      procedure Analyze_Depends_Global\n+        (Spec_Id   : out Entity_Id;\n+         Subp_Decl : out Node_Id;\n+         Legal     : out Boolean);\n+      --  Subsidiary to the analysis of pragmas Depends and Global. Verify the\n+      --  legality of the placement and related context of the pragma. Spec_Id\n+      --  is the entity of the related subprogram. Subp_Decl is the declaration\n+      --  of the related subprogram. Sets flag Legal when the pragma is legal.\n \n       procedure Analyze_Part_Of\n         (Item_Id : Entity_Id;\n@@ -2731,10 +2779,10 @@ package body Sem_Prag is\n          Body_Id : out Entity_Id;\n          Legal   : out Boolean);\n       --  Subsidiary routine to the analysis of body pragmas Refined_Depends,\n-      --  Refined_Global and Refined_Post. Check the placement and related\n-      --  context of the pragma. Spec_Id is the entity of the related\n-      --  subprogram. Body_Id is the entity of the subprogram body. Flag\n-      --  Legal is set when the pragma is properly placed.\n+      --  Refined_Global and Refined_Post. Verify the legality of the placement\n+      --  and related context of the pragma. Spec_Id is the entity of the\n+      --  related subprogram. Body_Id is the entity of the subprogram body.\n+      --  Flag Legal is set when the pragma is legal.\n \n       procedure Check_Ada_83_Warning;\n       --  Issues a warning message for the current pragma if operating in Ada\n@@ -3077,6 +3125,10 @@ package body Sem_Prag is\n       --  Determines if the placement of the current pragma is appropriate\n       --  for a configuration pragma.\n \n+      function Is_Followed_By_Pragma (Prag_Nam : Name_Id) return Boolean;\n+      --  Determine whether pragma N is followed by another pragma denoted by\n+      --  its name Prag_Nam. It is assumed that N is a list member.\n+\n       function Is_In_Context_Clause return Boolean;\n       --  Returns True if pragma appears within the context clause of a unit,\n       --  and False for any other placement (does not generate any messages).\n@@ -3285,11 +3337,23 @@ package body Sem_Prag is\n       -- Analyze_Depends_Global --\n       ----------------------------\n \n-      procedure Analyze_Depends_Global is\n-         Spec_Id   : Entity_Id;\n-         Subp_Decl : Node_Id;\n-\n+      procedure Analyze_Depends_Global\n+        (Spec_Id   : out Entity_Id;\n+         Subp_Decl : out Node_Id;\n+         Legal     : out Boolean)\n+      is\n       begin\n+         --  Assume that the pragma is illegal\n+\n+         Spec_Id   := Empty;\n+         Subp_Decl := Empty;\n+         Legal     := False;\n+\n+         --  Reset the Analyzed flag because the pragma requires further\n+         --  analysis.\n+\n+         Set_Analyzed (N, False);\n+\n          GNAT_Pragma;\n          Check_Arg_Count (1);\n \n@@ -3328,30 +3392,16 @@ package body Sem_Prag is\n             return;\n          end if;\n \n+         --  If we get here, then the pragma is legal\n+\n+         Legal   := True;\n          Spec_Id := Unique_Defining_Entity (Subp_Decl);\n \n          --  A pragma that applies to a Ghost entity becomes Ghost for the\n          --  purposes of legality checks and removal of ignored Ghost code.\n \n          Mark_Pragma_As_Ghost (N, Spec_Id);\n          Ensure_Aggregate_Form (Get_Argument (N, Spec_Id));\n-\n-         --  Fully analyze the pragma when it appears inside a subprogram body\n-         --  because it cannot benefit from forward references.\n-\n-         if Nkind (Subp_Decl) = N_Subprogram_Body then\n-            if Pragma_Name (N) = Name_Depends then\n-               Analyze_Depends_In_Decl_Part (N);\n-\n-            else pragma Assert (Pname = Name_Global);\n-               Analyze_Global_In_Decl_Part (N);\n-            end if;\n-         end if;\n-\n-         --  Chain the pragma on the contract for further processing by\n-         --  Analyze_Depends_In_Decl_Part/Analyze_Global_In_Decl_Part.\n-\n-         Add_Contract_Item (N, Defining_Entity (Subp_Decl));\n       end Analyze_Depends_Global;\n \n       ---------------------\n@@ -3553,6 +3603,11 @@ package body Sem_Prag is\n          --  Post_Class.\n \n       begin\n+         --  Reset the Analyzed flag because the pragma requires further\n+         --  analysis.\n+\n+         Set_Analyzed (N, False);\n+\n          --  Change the name of pragmas Pre, Pre_Class, Post and Post_Class to\n          --  offer uniformity among the various kinds of pre/postconditions by\n          --  rewriting the pragma identifier. This allows the retrieval of the\n@@ -3717,6 +3772,11 @@ package body Sem_Prag is\n          Body_Id := Empty;\n          Legal   := False;\n \n+         --  Reset the Analyzed flag because the pragma requires further\n+         --  analysis.\n+\n+         Set_Analyzed (N, False);\n+\n          GNAT_Pragma;\n          Check_Arg_Count (1);\n          Check_No_Identifiers;\n@@ -3769,21 +3829,21 @@ package body Sem_Prag is\n             return;\n          end if;\n \n+         --  If we get here, then the pragma is legal\n+\n+         Legal := True;\n+\n          --  A pragma that applies to a Ghost entity becomes Ghost for the\n          --  purposes of legality checks and removal of ignored Ghost code.\n \n          Mark_Pragma_As_Ghost (N, Spec_Id);\n \n-         --  If we get here, then the pragma is legal\n-\n          if Nam_In (Pname, Name_Refined_Depends,\n                            Name_Refined_Global,\n                            Name_Refined_State)\n          then\n             Ensure_Aggregate_Form (Get_Argument (N, Spec_Id));\n          end if;\n-\n-         Legal := True;\n       end Analyze_Refined_Depends_Global_Post;\n \n       --------------------------\n@@ -5830,6 +5890,39 @@ package body Sem_Prag is\n          end if;\n       end Is_Configuration_Pragma;\n \n+      ---------------------------\n+      -- Is_Followed_By_Pragma --\n+      ---------------------------\n+\n+      function Is_Followed_By_Pragma (Prag_Nam : Name_Id) return Boolean is\n+         Stmt : Node_Id;\n+\n+      begin\n+         pragma Assert (Is_List_Member (N));\n+\n+         --  Inspect the declarations or statements following pragma N looking\n+         --  for another pragma whose name matches the caller's request.\n+\n+         Stmt := Next (N);\n+         while Present (Stmt) loop\n+            if Nkind (Stmt) = N_Pragma\n+              and then Pragma_Name (Stmt) = Prag_Nam\n+            then\n+               return True;\n+\n+            --  The first source declaration or statement immediately following\n+            --  N ends the region where a pragma may appear.\n+\n+            elsif Comes_From_Source (Stmt) then\n+               exit;\n+            end if;\n+\n+            Next (Stmt);\n+         end loop;\n+\n+         return False;\n+      end Is_Followed_By_Pragma;\n+\n       --------------------------\n       -- Is_In_Context_Clause --\n       --------------------------\n@@ -9483,13 +9576,13 @@ package body Sem_Prag is\n \n    begin\n       --  The following code is a defense against recursion. Not clear that\n-      --  this can happen legitimately, but perhaps some error situations\n-      --  can cause it, and we did see this recursion during testing.\n+      --  this can happen legitimately, but perhaps some error situations can\n+      --  cause it, and we did see this recursion during testing.\n \n       if Analyzed (N) then\n          return;\n       else\n-         Set_Analyzed (N, True);\n+         Set_Analyzed (N);\n       end if;\n \n       --  Deal with unrecognized pragma\n@@ -11120,6 +11213,11 @@ package body Sem_Prag is\n             Obj_Id   : Entity_Id;\n \n          begin\n+            --  Reset the Analyzed flag because the pragma requires further\n+            --  analysis.\n+\n+            Set_Analyzed (N, False);\n+\n             GNAT_Pragma;\n             Check_No_Identifiers;\n             Check_At_Most_N_Arguments  (1);\n@@ -12338,7 +12436,9 @@ package body Sem_Prag is\n             --  Fully analyze the pragma when it appears inside a subprogram\n             --  body because it cannot benefit from forward references.\n \n-            if Nkind (Subp_Decl) = N_Subprogram_Body then\n+            if Nkind_In (Subp_Decl, N_Subprogram_Body,\n+                                    N_Subprogram_Body_Stub)\n+            then\n                Analyze_Contract_Cases_In_Decl_Part (N);\n             end if;\n \n@@ -13044,8 +13144,59 @@ package body Sem_Prag is\n          --    the \"pragma on subprogram declaration\" case. In that scenario\n          --    the annotation must instantiate itself.\n \n-         when Pragma_Depends =>\n-            Analyze_Depends_Global;\n+         when Pragma_Depends => Depends : declare\n+            Global    : Node_Id;\n+            Legal     : Boolean;\n+            Spec_Id   : Entity_Id;\n+            Subp_Decl : Node_Id;\n+\n+         begin\n+            Analyze_Depends_Global (Spec_Id, Subp_Decl, Legal);\n+\n+            if Legal then\n+\n+               --  Chain the pragma on the contract for further processing by\n+               --  Analyze_Depends_In_Decl_Part.\n+\n+               Add_Contract_Item (N, Spec_Id);\n+\n+               --  Fully analyze the pragma when it appears inside a subprogram\n+               --  body because it cannot benefit from forward references.\n+\n+               if Nkind_In (Subp_Decl, N_Subprogram_Body,\n+                                       N_Subprogram_Body_Stub)\n+               then\n+                  --  Pragmas Global and Depends must be analyzed in a specific\n+                  --  order, as the latter depends on the former. When the two\n+                  --  pragmas appear out of order, their analyis is triggered\n+                  --  by pragma Global.\n+\n+                  --    pragma Depends ...;\n+                  --    pragma Global  ...;  <analyze both pragmas here>\n+\n+                  --  Wait until pragma Global is encountered\n+\n+                  if Is_Followed_By_Pragma (Name_Global) then\n+                     null;\n+\n+                  --  Otherwise pragma Depends is the last of the pair. Analyze\n+                  --  both pragmas when they appear in order.\n+\n+                  --    pragma Global  ...;\n+                  --    pragma Depends ...;  <analyze both pragmas here>\n+\n+                  else\n+                     Global := Get_Pragma (Spec_Id, Pragma_Global);\n+\n+                     if Present (Global) then\n+                        Analyze_Global_In_Decl_Part (Global);\n+                     end if;\n+\n+                     Analyze_Depends_In_Decl_Part (N);\n+                  end if;\n+               end if;\n+            end if;\n+         end Depends;\n \n          ---------------------\n          -- Detect_Blocking --\n@@ -14521,8 +14672,59 @@ package body Sem_Prag is\n          --    the \"pragma on subprogram declaration\" case. In that scenario\n          --    the annotation must instantiate itself.\n \n-         when Pragma_Global =>\n-            Analyze_Depends_Global;\n+         when Pragma_Global => Global : declare\n+            Depends   : Node_Id;\n+            Legal     : Boolean;\n+            Spec_Id   : Entity_Id;\n+            Subp_Decl : Node_Id;\n+\n+         begin\n+            Analyze_Depends_Global (Spec_Id, Subp_Decl, Legal);\n+\n+            if Legal then\n+\n+               --  Chain the pragma on the contract for further processing by\n+               --  Analyze_Global_In_Decl_Part.\n+\n+               Add_Contract_Item (N, Spec_Id);\n+\n+               --  Fully analyze the pragma when it appears inside a subprogram\n+               --  body because it cannot benefit from forward references.\n+\n+               if Nkind_In (Subp_Decl, N_Subprogram_Body,\n+                                       N_Subprogram_Body_Stub)\n+               then\n+                  --  Pragmas Global and Depends must be analyzed in a specific\n+                  --  order, as the latter depends on the former. When the two\n+                  --  pragmas appear in order, their analysis is triggered by\n+                  --  pragma Depends.\n+\n+                  --    pragma Global  ...;\n+                  --    pragma Depends ...;  <analyze both pragmas here>\n+\n+                  --  Wait until pragma Global is encountered\n+\n+                  if Is_Followed_By_Pragma (Name_Depends) then\n+                     null;\n+\n+                  --  Otherwise pragma Global is the last of the pair. Analyze\n+                  --  both pragmas when they are out of order.\n+\n+                  --    pragma Depends ...;\n+                  --    pragma Global  ...;  <analyze both pragmas here>\n+\n+                  else\n+                     Analyze_Global_In_Decl_Part (N);\n+\n+                     Depends := Get_Pragma (Spec_Id, Pragma_Depends);\n+\n+                     if Present (Depends) then\n+                        Analyze_Depends_In_Decl_Part (Depends);\n+                     end if;\n+                  end if;\n+               end if;\n+            end if;\n+         end Global;\n \n          -----------\n          -- Ident --\n@@ -15113,6 +15315,11 @@ package body Sem_Prag is\n             Pack_Id   : Entity_Id;\n \n          begin\n+            --  Reset the Analyzed flag because the pragma requires further\n+            --  analysis.\n+\n+            Set_Analyzed (N, False);\n+\n             GNAT_Pragma;\n             Check_No_Identifiers;\n             Check_Arg_Count (1);\n@@ -15234,6 +15441,11 @@ package body Sem_Prag is\n             Pack_Id   : Entity_Id;\n \n          begin\n+            --  Reset the Analyzed flag because the pragma requires further\n+            --  analysis.\n+\n+            Set_Analyzed (N, False);\n+\n             GNAT_Pragma;\n             Check_No_Identifiers;\n             Check_Arg_Count (1);\n@@ -18717,9 +18929,9 @@ package body Sem_Prag is\n          when Pragma_Rational =>\n             Set_Rational_Profile;\n \n-         ------------------------------------\n-         -- Refined_Depends/Refined_Global --\n-         ------------------------------------\n+         ---------------------\n+         -- Refined_Depends --\n+         ---------------------\n \n          --  pragma Refined_Depends (DEPENDENCY_RELATION);\n \n@@ -18742,6 +18954,76 @@ package body Sem_Prag is\n \n          --  where FUNCTION_RESULT is a function Result attribute_reference\n \n+         --  Characteristics:\n+\n+         --    * Analysis - The annotation undergoes initial checks to verify\n+         --    the legal placement and context. Secondary checks fully analyze\n+         --    the dependency clauses/global list in:\n+\n+         --       Analyze_Refined_Depends_In_Decl_Part\n+\n+         --    * Expansion - None.\n+\n+         --    * Template - The annotation utilizes the generic template of the\n+         --    related subprogram body.\n+\n+         --    * Globals - Capture of global references must occur after full\n+         --    analysis.\n+\n+         --    * Instance - The annotation is instantiated automatically when\n+         --    the related generic subprogram body is instantiated.\n+\n+         when Pragma_Refined_Depends => Refined_Depends : declare\n+            Body_Id    : Entity_Id;\n+            Legal      : Boolean;\n+            Ref_Global : Node_Id;\n+            Spec_Id    : Entity_Id;\n+\n+         begin\n+            Analyze_Refined_Depends_Global_Post (Spec_Id, Body_Id, Legal);\n+\n+            if Legal then\n+\n+               --  Chain the pragma on the contract for further processing by\n+               --  Analyze_Refined_Depends_In_Decl_Part.\n+\n+               Add_Contract_Item (N, Body_Id);\n+\n+               --  Pragmas Refined_Global and Refined_Depends must be analyzed\n+               --  in a specific order, as the latter depends on the former.\n+               --  When the two pragmas appear out of order, their analysis is\n+               --  triggered by pragma Refined_Global.\n+\n+               --    pragma Refined_Depends ...;\n+               --    pragma Refined_Global  ...;  <analyze both pragmas here>\n+\n+               --  Wait until pragma Refined_Global is enountered\n+\n+               if Is_Followed_By_Pragma (Name_Refined_Global) then\n+                  null;\n+\n+               --  Otherwise pragma Refined_Depends is the last of the pair.\n+               --  Analyze both pragmas when they appear in order.\n+\n+               --    pragma Refined_Global  ...;\n+               --    pragma Refined_Depends ...;  <analyze both pragmas here>\n+\n+               else\n+                  Ref_Global := Get_Pragma (Body_Id, Pragma_Refined_Global);\n+\n+                  if Present (Ref_Global) then\n+                     Analyze_Refined_Global_In_Decl_Part (Ref_Global);\n+                  end if;\n+\n+                  Analyze_Refined_Depends_In_Decl_Part (N);\n+               end if;\n+            end if;\n+         end Refined_Depends;\n+\n+         --------------------\n+         -- Refined_Global --\n+         --------------------\n+\n          --  pragma Refined_Global (GLOBAL_SPECIFICATION);\n \n          --  GLOBAL_SPECIFICATION ::=\n@@ -18761,7 +19043,6 @@ package body Sem_Prag is\n          --    the legal placement and context. Secondary checks fully analyze\n          --    the dependency clauses/global list in:\n \n-         --       Analyze_Refined_Depends_In_Decl_Part\n          --       Analyze_Refined_Global_In_Decl_Part\n \n          --    * Expansion - None.\n@@ -18775,23 +19056,52 @@ package body Sem_Prag is\n          --    * Instance - The annotation is instantiated automatically when\n          --    the related generic subprogram body is instantiated.\n \n-         when Pragma_Refined_Depends |\n-              Pragma_Refined_Global  => Refined_Depends_Global :\n-         declare\n-            Body_Id : Entity_Id;\n-            Legal   : Boolean;\n-            Spec_Id : Entity_Id;\n+         when Pragma_Refined_Global => Refined_Global : declare\n+            Body_Id     : Entity_Id;\n+            Legal       : Boolean;\n+            Ref_Depends : Node_Id;\n+            Spec_Id     : Entity_Id;\n \n          begin\n             Analyze_Refined_Depends_Global_Post (Spec_Id, Body_Id, Legal);\n \n-            --  Chain the pragma on the contract for further processing by\n-            --  Analyze_Refined_[Depends|Global]_In_Decl_Part.\n-\n             if Legal then\n+\n+               --  Chain the pragma on the contract for further processing by\n+               --  Analyze_Refined_Global_In_Decl_Part.\n+\n                Add_Contract_Item (N, Body_Id);\n+\n+               --  Pragmas Refined_Global and Refined_Depends must be analyzed\n+               --  in a specific order, as the latter depends on the former.\n+               --  When the two pragmas are in order, their analysis must be\n+               --  triggered by pragma Refined_Depends.\n+\n+               --    pragma Refined_Global  ...;\n+               --    pragma Refined_Depends ...;  <analyze both pragmas here>\n+\n+               --  Wait until pragma Refined_Depends is encountered\n+\n+               if Is_Followed_By_Pragma (Name_Refined_Depends) then\n+                  null;\n+\n+               --  Otherwise pragma Refined_Global is the last of the pair.\n+               --  Analyze both pragmas when they are out of order.\n+\n+               --    pragma Refined_Depends ...;\n+               --    pragma Refined_Global  ...;  <analyze both pragmas here>\n+\n+               else\n+                  Analyze_Refined_Global_In_Decl_Part (N);\n+\n+                  Ref_Depends := Get_Pragma (Body_Id, Pragma_Refined_Depends);\n+\n+                  if Present (Ref_Depends) then\n+                     Analyze_Refined_Depends_In_Decl_Part (Ref_Depends);\n+                  end if;\n+               end if;\n             end if;\n-         end Refined_Depends_Global;\n+         end Refined_Global;\n \n          ------------------\n          -- Refined_Post --\n@@ -18886,6 +19196,11 @@ package body Sem_Prag is\n             Spec_Id   : Entity_Id;\n \n          begin\n+            --  Reset the Analyzed flag because the pragma requires further\n+            --  analysis.\n+\n+            Set_Analyzed (N, False);\n+\n             GNAT_Pragma;\n             Check_No_Identifiers;\n             Check_Arg_Count (1);\n@@ -20800,6 +21115,11 @@ package body Sem_Prag is\n          --  Start of processing for Test_Case\n \n          begin\n+            --  Reset the Analyzed flag because the pragma requires further\n+            --  analysis.\n+\n+            Set_Analyzed (N, False);\n+\n             GNAT_Pragma;\n             Check_At_Least_N_Arguments (2);\n             Check_At_Most_N_Arguments (4);\n@@ -22423,6 +22743,12 @@ package body Sem_Prag is\n    --  Start of processing for Analyze_Pre_Post_Condition_In_Decl_Part\n \n    begin\n+      --  Do not analyze the pragma multiple times\n+\n+      if Is_Analyzed_Pragma (N) then\n+         return;\n+      end if;\n+\n       --  Set the Ghost mode in effect from the pragma. Due to the delayed\n       --  analysis of the pragma, the Ghost mode at point of declaration and\n       --  point of analysis may not necessarely be the same. Use the mode in\n@@ -22468,6 +22794,8 @@ package body Sem_Prag is\n \n       Check_Postcondition_Use_In_Inlined_Subprogram (N, Spec_Id);\n       Ghost_Mode := Save_Ghost_Mode;\n+\n+      Set_Is_Analyzed_Pragma (N);\n    end Analyze_Pre_Post_Condition_In_Decl_Part;\n \n    ------------------------------------------\n@@ -23217,6 +23545,12 @@ package body Sem_Prag is\n    --  Start of processing for Analyze_Refined_Depends_In_Decl_Part\n \n    begin\n+      --  Do not analyze the pragma multiple times\n+\n+      if Is_Analyzed_Pragma (N) then\n+         return;\n+      end if;\n+\n       if Nkind (Body_Decl) = N_Subprogram_Body_Stub then\n          Spec_Id := Corresponding_Spec_Of_Stub (Body_Decl);\n       else\n@@ -23232,7 +23566,7 @@ package body Sem_Prag is\n          SPARK_Msg_NE\n            (\"useless refinement, declaration of subprogram & lacks aspect or \"\n             & \"pragma Depends\", N, Spec_Id);\n-         return;\n+         goto Leave;\n       end if;\n \n       Deps := Expression (Get_Argument (Depends, Spec_Id));\n@@ -23246,7 +23580,7 @@ package body Sem_Prag is\n          SPARK_Msg_NE\n            (\"useless refinement, subprogram & does not depend on abstract \"\n             & \"state with visible refinement\", N, Spec_Id);\n-         return;\n+         goto Leave;\n       end if;\n \n       --  Analyze Refined_Depends as if it behaved as a regular pragma Depends.\n@@ -23291,7 +23625,7 @@ package body Sem_Prag is\n          --  this is a tree altering activity similar to expansion.\n \n          if ASIS_Mode then\n-            return;\n+            goto Leave;\n          end if;\n \n          --  Multiple dependency clauses appear as component associations of an\n@@ -23331,6 +23665,9 @@ package body Sem_Prag is\n             Report_Extra_Clauses;\n          end if;\n       end if;\n+\n+      <<Leave>>\n+      Set_Is_Analyzed_Pragma (N);\n    end Analyze_Refined_Depends_In_Decl_Part;\n \n    -----------------------------------------\n@@ -24182,6 +24519,12 @@ package body Sem_Prag is\n    --  Start of processing for Analyze_Refined_Global_In_Decl_Part\n \n    begin\n+      --  Do not analyze the pragma multiple times\n+\n+      if Is_Analyzed_Pragma (N) then\n+         return;\n+      end if;\n+\n       if Nkind (Body_Decl) = N_Subprogram_Body_Stub then\n          Spec_Id := Corresponding_Spec_Of_Stub (Body_Decl);\n       else\n@@ -24198,7 +24541,7 @@ package body Sem_Prag is\n          SPARK_Msg_NE\n            (\"useless refinement, declaration of subprogram & lacks aspect or \"\n             & \"pragma Global\", N, Spec_Id);\n-         return;\n+         goto Leave;\n       end if;\n \n       --  Extract all relevant items from the corresponding Global pragma\n@@ -24231,7 +24574,7 @@ package body Sem_Prag is\n             SPARK_Msg_NE\n               (\"useless refinement, subprogram & does not depend on abstract \"\n                & \"state with visible refinement\", N, Spec_Id);\n-            return;\n+            goto Leave;\n \n          --  The global refinement of inputs and outputs cannot be null when\n          --  the corresponding Global pragma contains at least one item except\n@@ -24248,7 +24591,7 @@ package body Sem_Prag is\n             SPARK_Msg_NE\n               (\"refinement cannot be null, subprogram & has global items\",\n                N, Spec_Id);\n-            return;\n+            goto Leave;\n          end if;\n       end if;\n \n@@ -24299,6 +24642,9 @@ package body Sem_Prag is\n       if Serious_Errors_Detected = Errors then\n          Report_Extra_Constituents;\n       end if;\n+\n+      <<Leave>>\n+      Set_Is_Analyzed_Pragma (N);\n    end Analyze_Refined_Global_In_Decl_Part;\n \n    ----------------------------------------\n@@ -25039,7 +25385,11 @@ package body Sem_Prag is\n    --  Start of processing for Analyze_Refined_State_In_Decl_Part\n \n    begin\n-      Set_Analyzed (N);\n+      --  Do not analyze the pragma multiple times\n+\n+      if Is_Analyzed_Pragma (N) then\n+         return;\n+      end if;\n \n       --  Replicate the abstract states declared by the package because the\n       --  matching algorithm will consume states.\n@@ -25083,6 +25433,8 @@ package body Sem_Prag is\n       --  state space of the related package are utilized as constituents.\n \n       Report_Unused_Body_States (Body_Id, Body_States);\n+\n+      Set_Is_Analyzed_Pragma (N);\n    end Analyze_Refined_State_In_Decl_Part;\n \n    ------------------------------------\n@@ -25135,6 +25487,12 @@ package body Sem_Prag is\n    --  Start of processing for Analyze_Test_Case_In_Decl_Part\n \n    begin\n+      --  Do not analyze the pragma multiple times\n+\n+      if Is_Analyzed_Pragma (N) then\n+         return;\n+      end if;\n+\n       --  Ensure that the formal parameters are visible when analyzing all\n       --  clauses. This falls out of the general rule of aspects pertaining\n       --  to subprogram declarations.\n@@ -25161,6 +25519,8 @@ package body Sem_Prag is\n       --  subprogram subject to pragma Inline_Always.\n \n       Check_Postcondition_Use_In_Inlined_Subprogram (N, Spec_Id);\n+\n+      Set_Is_Analyzed_Pragma (N);\n    end Analyze_Test_Case_In_Decl_Part;\n \n    ----------------"}, {"sha": "5f57e8c2f7503a2d4cb795b429a46e367afb5444", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba4f1fb6ecf07b7779910035d0ff75982d383fb/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba4f1fb6ecf07b7779910035d0ff75982d383fb/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=2ba4f1fb6ecf07b7779910035d0ff75982d383fb", "patch": "@@ -1760,6 +1760,14 @@ package body Sinfo is\n       return Flag13 (N);\n    end Is_Accessibility_Actual;\n \n+   function Is_Analyzed_Pragma\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Pragma);\n+      return Flag5 (N);\n+   end Is_Analyzed_Pragma;\n+\n    function Is_Asynchronous_Call_Block\n       (N : Node_Id) return Boolean is\n    begin\n@@ -1918,13 +1926,13 @@ package body Sinfo is\n       return Flag11 (N);\n    end Is_In_Discriminant_Check;\n \n-   function Is_Inherited\n+   function Is_Inherited_Pragma\n       (N : Node_Id) return Boolean is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_Pragma);\n       return Flag4 (N);\n-   end Is_Inherited;\n+   end Is_Inherited_Pragma;\n \n    function Is_Machine_Number\n       (N : Node_Id) return Boolean is\n@@ -4991,6 +4999,14 @@ package body Sinfo is\n       Set_Flag13 (N, Val);\n    end Set_Is_Accessibility_Actual;\n \n+   procedure Set_Is_Analyzed_Pragma\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Pragma);\n+      Set_Flag5 (N, Val);\n+   end Set_Is_Analyzed_Pragma;\n+\n    procedure Set_Is_Asynchronous_Call_Block\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n@@ -5149,13 +5165,13 @@ package body Sinfo is\n       Set_Flag11 (N, Val);\n    end Set_Is_In_Discriminant_Check;\n \n-   procedure Set_Is_Inherited\n+   procedure Set_Is_Inherited_Pragma\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_Pragma);\n       Set_Flag4 (N, Val);\n-   end Set_Is_Inherited;\n+   end Set_Is_Inherited_Pragma;\n \n    procedure Set_Is_Machine_Number\n       (N : Node_Id; Val : Boolean := True) is"}, {"sha": "8a3e51b8366ae46eaf4a981699984e5f690e7867", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba4f1fb6ecf07b7779910035d0ff75982d383fb/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba4f1fb6ecf07b7779910035d0ff75982d383fb/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=2ba4f1fb6ecf07b7779910035d0ff75982d383fb", "patch": "@@ -1542,6 +1542,13 @@ package Sinfo is\n    --    is called in a dispatching context. Used to prevent a formal/actual\n    --    mismatch when the call is rewritten as a dispatching call.\n \n+   --  Is_Analyzed_Pragma (Flag5-Sem)\n+   --    Present in N_Pragma nodes. Set for delayed pragmas that require a two\n+   --    step analysis. The initial step is peformed by routine Analyze_Pragma\n+   --    and verifies the overall legality of the pragma. The second step takes\n+   --    place in the various Analyze_xxx_In_Decl_Part routines which perform\n+   --    full analysis. The flag prevents the reanalysis of a delayed pragma.\n+\n    --  Is_Expanded_Contract (Flag1-Sem)\n    --    Present in N_Contract nodes. Set if the contract has already undergone\n    --    expansion activities.\n@@ -1660,7 +1667,7 @@ package Sinfo is\n    --    discriminant check has a correct value cannot be performed in this\n    --    case (or the discriminant check may be optimized away).\n \n-   --  Is_Inherited (Flag4-Sem)\n+   --  Is_Inherited_Pragma (Flag4-Sem)\n    --    This flag is set in an N_Pragma node that appears in a N_Contract node\n    --    to indicate that the pragma has been inherited from a parent context.\n \n@@ -2480,13 +2487,14 @@ package Sinfo is\n       --  Class_Present (Flag6) set if from Aspect with 'Class\n       --  From_Aspect_Specification (Flag13-Sem)\n       --  Import_Interface_Present (Flag16-Sem)\n+      --  Is_Analyzed_Pragma (Flag5-Sem)\n       --  Is_Checked (Flag11-Sem)\n       --  Is_Delayed_Aspect (Flag14-Sem)\n       --  Is_Disabled (Flag15-Sem)\n       --  Is_Generic_Contract_Pragma (Flag2-Sem)\n-      --  Is_Ghost_Pragma (Flag3-Sem);\n+      --  Is_Ghost_Pragma (Flag3-Sem)\n       --  Is_Ignored (Flag9-Sem)\n-      --  Is_Inherited (Flag4-Sem)\n+      --  Is_Inherited_Pragma (Flag4-Sem)\n       --  Split_PPC (Flag17) set if corresponding aspect had Split_PPC set\n       --  Uneval_Old_Accept (Flag7-Sem)\n       --  Uneval_Old_Warn (Flag18-Sem)\n@@ -9301,6 +9309,9 @@ package Sinfo is\n    function Is_Accessibility_Actual\n      (N : Node_Id) return Boolean;    -- Flag13\n \n+   function Is_Analyzed_Pragma\n+     (N : Node_Id) return Boolean;    -- Flag5\n+\n    function Is_Asynchronous_Call_Block\n      (N : Node_Id) return Boolean;    -- Flag7\n \n@@ -9358,7 +9369,7 @@ package Sinfo is\n    function Is_In_Discriminant_Check\n      (N : Node_Id) return Boolean;    -- Flag11\n \n-   function Is_Inherited\n+   function Is_Inherited_Pragma\n      (N : Node_Id) return Boolean;    -- Flag4\n \n    function Is_Machine_Number\n@@ -10333,6 +10344,9 @@ package Sinfo is\n    procedure Set_Is_Accessibility_Actual\n      (N : Node_Id; Val : Boolean := True);    -- Flag13\n \n+   procedure Set_Is_Analyzed_Pragma\n+     (N : Node_Id; Val : Boolean := True);    -- Flag5\n+\n    procedure Set_Is_Asynchronous_Call_Block\n      (N : Node_Id; Val : Boolean := True);    -- Flag7\n \n@@ -10390,7 +10404,7 @@ package Sinfo is\n    procedure Set_Is_In_Discriminant_Check\n      (N : Node_Id; Val : Boolean := True);    -- Flag11\n \n-   procedure Set_Is_Inherited\n+   procedure Set_Is_Inherited_Pragma\n      (N : Node_Id; Val : Boolean := True);    -- Flag4\n \n    procedure Set_Is_Machine_Number\n@@ -12763,6 +12777,7 @@ package Sinfo is\n    pragma Inline (Intval);\n    pragma Inline (Iterator_Specification);\n    pragma Inline (Is_Accessibility_Actual);\n+   pragma Inline (Is_Analyzed_Pragma);\n    pragma Inline (Is_Asynchronous_Call_Block);\n    pragma Inline (Is_Boolean_Aspect);\n    pragma Inline (Is_Checked);\n@@ -12782,7 +12797,7 @@ package Sinfo is\n    pragma Inline (Is_Ghost_Pragma);\n    pragma Inline (Is_Ignored);\n    pragma Inline (Is_In_Discriminant_Check);\n-   pragma Inline (Is_Inherited);\n+   pragma Inline (Is_Inherited_Pragma);\n    pragma Inline (Is_Machine_Number);\n    pragma Inline (Is_Null_Loop);\n    pragma Inline (Is_Overloaded);\n@@ -13102,6 +13117,7 @@ package Sinfo is\n    pragma Inline (Set_Interface_Present);\n    pragma Inline (Set_Intval);\n    pragma Inline (Set_Is_Accessibility_Actual);\n+   pragma Inline (Set_Is_Analyzed_Pragma);\n    pragma Inline (Set_Is_Asynchronous_Call_Block);\n    pragma Inline (Set_Is_Boolean_Aspect);\n    pragma Inline (Set_Is_Checked);\n@@ -13121,7 +13137,7 @@ package Sinfo is\n    pragma Inline (Set_Is_Ghost_Pragma);\n    pragma Inline (Set_Is_Ignored);\n    pragma Inline (Set_Is_In_Discriminant_Check);\n-   pragma Inline (Set_Is_Inherited);\n+   pragma Inline (Set_Is_Inherited_Pragma);\n    pragma Inline (Set_Is_Machine_Number);\n    pragma Inline (Set_Is_Null_Loop);\n    pragma Inline (Set_Is_Overloaded);"}]}