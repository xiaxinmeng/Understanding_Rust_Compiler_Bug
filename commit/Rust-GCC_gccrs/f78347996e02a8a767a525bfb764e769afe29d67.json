{"sha": "f78347996e02a8a767a525bfb764e769afe29d67", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc4MzQ3OTk2ZTAyYThhNzY3YTUyNWJmYjc2NGU3NjlhZmUyOWQ2Nw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-10-09T07:02:22Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-10-09T07:02:22Z"}, "message": "tree-vectorizer.h (_stmt_vec_info::reduc_vectype_in): New.\n\n2019-10-08  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (_stmt_vec_info::reduc_vectype_in): New.\n\t(_stmt_vec_info::force_single_cycle): Likewise.\n\t(STMT_VINFO_FORCE_SINGLE_CYCLE): New.\n\t(STMT_VINFO_REDUC_VECTYPE_IN): Likewise.\n\t* tree-vect-loop.c (vectorizable_reduction): Set\n\tSTMT_VINFO_REDUC_VECTYPE_IN and STMT_VINFO_FORCE_SINGLE_CYCLE.\n\t(vect_transform_reduction): Use them to remove redundant code.\n\t(vect_transform_cycle_phi): Likewise.\n\nFrom-SVN: r276752", "tree": {"sha": "d291e0e3a7047776a920faaae0b725332154a5a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d291e0e3a7047776a920faaae0b725332154a5a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f78347996e02a8a767a525bfb764e769afe29d67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f78347996e02a8a767a525bfb764e769afe29d67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f78347996e02a8a767a525bfb764e769afe29d67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f78347996e02a8a767a525bfb764e769afe29d67/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4e78c6883f97bf45eeb1ad3041dcf2e2de01912c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e78c6883f97bf45eeb1ad3041dcf2e2de01912c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e78c6883f97bf45eeb1ad3041dcf2e2de01912c"}], "stats": {"total": 207, "additions": 49, "deletions": 158}, "files": [{"sha": "021431072113ea3e49addffb1fb8d400391e5312", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f78347996e02a8a767a525bfb764e769afe29d67/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f78347996e02a8a767a525bfb764e769afe29d67/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f78347996e02a8a767a525bfb764e769afe29d67", "patch": "@@ -1,3 +1,14 @@\n+2019-10-08  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (_stmt_vec_info::reduc_vectype_in): New.\n+\t(_stmt_vec_info::force_single_cycle): Likewise.\n+\t(STMT_VINFO_FORCE_SINGLE_CYCLE): New.\n+\t(STMT_VINFO_REDUC_VECTYPE_IN): Likewise.\n+\t* tree-vect-loop.c (vectorizable_reduction): Set\n+\tSTMT_VINFO_REDUC_VECTYPE_IN and STMT_VINFO_FORCE_SINGLE_CYCLE.\n+\t(vect_transform_reduction): Use them to remove redundant code.\n+\t(vect_transform_cycle_phi): Likewise.\n+\n 2019-10-08  Dmitrij Pochepko <dmitrij.pochepko@bell-sw.com>\n \n \tPR tree-optimization/90836"}, {"sha": "a9ea0caf218e31e6d00feac1ce150c14127fef97", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 30, "deletions": 158, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f78347996e02a8a767a525bfb764e769afe29d67/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f78347996e02a8a767a525bfb764e769afe29d67/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=f78347996e02a8a767a525bfb764e769afe29d67", "patch": "@@ -5983,9 +5983,13 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n \t    }\n \t}\n     }\n-\n   if (!vectype_in)\n     vectype_in = vectype_out;\n+  STMT_VINFO_REDUC_VECTYPE_IN (reduc_info) = vectype_in;\n+  /* For the SSA cycle we store on each participating stmt the operand index\n+     where the cycle continues.  Store the one relevant for the actual\n+     operation in the reduction meta.  */\n+  STMT_VINFO_REDUC_IDX (reduc_info) = reduc_index;\n \n   /* When vectorizing a reduction chain w/o SLP the reduction PHI is not\n      directy used in stmt.  */\n@@ -6457,7 +6461,7 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n       && (!STMT_VINFO_IN_PATTERN_P (use_stmt_info)\n \t  || !STMT_VINFO_PATTERN_DEF_SEQ (use_stmt_info))\n       && vect_stmt_to_vectorize (use_stmt_info) == stmt_info)\n-    single_defuse_cycle = true;\n+    STMT_VINFO_FORCE_SINGLE_CYCLE (reduc_info) = single_defuse_cycle = true;\n \n   if (single_defuse_cycle\n       || code == DOT_PROD_EXPR\n@@ -6584,17 +6588,11 @@ vect_transform_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t\t  stmt_vec_info *vec_stmt, slp_tree slp_node)\n {\n   tree vectype_out = STMT_VINFO_VECTYPE (stmt_info);\n-  tree vectype_in = NULL_TREE;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  enum tree_code code;\n-  int op_type;\n-  bool is_simple_use;\n   int i;\n   int ncopies;\n-  bool single_defuse_cycle = false;\n   int j;\n-  tree ops[3];\n   int vec_num;\n \n   stmt_vec_info reduc_info = info_for_reduction (stmt_info);\n@@ -6607,30 +6605,20 @@ vect_transform_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n     }\n \n   gassign *stmt = as_a <gassign *> (stmt_info->stmt);\n+  enum tree_code code = gimple_assign_rhs_code (stmt);\n+  int op_type = TREE_CODE_LENGTH (code);\n \n   /* Flatten RHS.  */\n-  switch (get_gimple_rhs_class (gimple_assign_rhs_code (stmt)))\n+  tree ops[3];\n+  switch (get_gimple_rhs_class (code))\n     {\n-    case GIMPLE_BINARY_RHS:\n-      code = gimple_assign_rhs_code (stmt);\n-      op_type = TREE_CODE_LENGTH (code);\n-      gcc_assert (op_type == binary_op);\n-      ops[0] = gimple_assign_rhs1 (stmt);\n-      ops[1] = gimple_assign_rhs2 (stmt);\n-      break;\n-\n     case GIMPLE_TERNARY_RHS:\n-      code = gimple_assign_rhs_code (stmt);\n-      op_type = TREE_CODE_LENGTH (code);\n-      gcc_assert (op_type == ternary_op);\n+      ops[2] = gimple_assign_rhs3 (stmt);\n+      /* Fall thru.  */\n+    case GIMPLE_BINARY_RHS:\n       ops[0] = gimple_assign_rhs1 (stmt);\n       ops[1] = gimple_assign_rhs2 (stmt);\n-      ops[2] = gimple_assign_rhs3 (stmt);\n       break;\n-\n-    case GIMPLE_UNARY_RHS:\n-      return false;\n-\n     default:\n       gcc_unreachable ();\n     }\n@@ -6641,110 +6629,19 @@ vect_transform_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n      reduction variable.  */\n   stmt_vec_info phi_info = STMT_VINFO_REDUC_DEF (vect_orig_stmt (stmt_info));\n   gphi *reduc_def_phi = as_a <gphi *> (phi_info->stmt);\n-  tree reduc_def = PHI_RESULT (reduc_def_phi);\n-  int reduc_index = -1;\n-  for (i = 0; i < op_type; i++)\n-    {\n-      /* The condition of COND_EXPR is checked in vectorizable_condition().  */\n-      if (i == 0 && code == COND_EXPR)\n-        continue;\n-\n-      stmt_vec_info def_stmt_info;\n-      enum vect_def_type dt;\n-      tree tem;\n-      is_simple_use = vect_is_simple_use (ops[i], loop_vinfo, &dt, &tem,\n-\t\t\t\t\t  &def_stmt_info);\n-      gcc_assert (is_simple_use);\n-      if (dt == vect_reduction_def\n-\t  && ops[i] == reduc_def)\n-\t{\n-\t  reduc_index = i;\n-\t  continue;\n-\t}\n-      else if (tem)\n-\t{\n-\t  /* To properly compute ncopies we are interested in the widest\n-\t     input type in case we're looking at a widening accumulation.  */\n-\t  if (!vectype_in\n-\t      || (GET_MODE_SIZE (SCALAR_TYPE_MODE (TREE_TYPE (vectype_in)))\n-\t\t  < GET_MODE_SIZE (SCALAR_TYPE_MODE (TREE_TYPE (tem)))))\n-\t    vectype_in = tem;\n-\t}\n-\n-      if (dt == vect_nested_cycle\n-\t  && ops[i] == reduc_def)\n-\t{\n-\t  reduc_index = i;\n-\t}\n-    }\n-\n-  if (!vectype_in)\n-    vectype_in = vectype_out;\n+  int reduc_index = STMT_VINFO_REDUC_IDX (reduc_info);\n+  tree vectype_in = STMT_VINFO_REDUC_VECTYPE_IN (reduc_info);\n \n   if (slp_node)\n-    ncopies = 1;\n-  else\n-    ncopies = vect_get_num_copies (loop_vinfo, vectype_in);\n-\n-  vect_reduction_type reduction_type = STMT_VINFO_REDUC_TYPE (reduc_info);\n-\n-  /* In case of widenning multiplication by a constant, we update the type\n-     of the constant to be the type of the other operand.  We check that the\n-     constant fits the type in the pattern recognition pass.  */\n-  if (code == DOT_PROD_EXPR\n-      && !types_compatible_p (TREE_TYPE (ops[0]), TREE_TYPE (ops[1])))\n     {\n-      gcc_unreachable ();\n-      /* No testcase for this.  PR49478.  */\n-      if (TREE_CODE (ops[0]) == INTEGER_CST)\n-        ops[0] = fold_convert (TREE_TYPE (ops[1]), ops[0]);\n-      else if (TREE_CODE (ops[1]) == INTEGER_CST)\n-        ops[1] = fold_convert (TREE_TYPE (ops[0]), ops[1]);\n+      ncopies = 1;\n+      vec_num = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n     }\n-\n-  /* In case the vectorization factor (VF) is bigger than the number\n-     of elements that we can fit in a vectype (nunits), we have to generate\n-     more than one vector stmt - i.e - we need to \"unroll\" the\n-     vector stmt by a factor VF/nunits.  For more details see documentation\n-     in vectorizable_operation.  */\n-\n-  /* If the reduction is used in an outer loop we need to generate\n-     VF intermediate results, like so (e.g. for ncopies=2):\n-\tr0 = phi (init, r0)\n-\tr1 = phi (init, r1)\n-\tr0 = x0 + r0;\n-        r1 = x1 + r1;\n-    (i.e. we generate VF results in 2 registers).\n-    In this case we have a separate def-use cycle for each copy, and therefore\n-    for each copy we get the vector def for the reduction variable from the\n-    respective phi node created for this copy.\n-\n-    Otherwise (the reduction is unused in the loop nest), we can combine\n-    together intermediate results, like so (e.g. for ncopies=2):\n-\tr = phi (init, r)\n-\tr = x0 + r;\n-\tr = x1 + r;\n-   (i.e. we generate VF/2 results in a single register).\n-   In this case for each copy we get the vector def for the reduction variable\n-   from the vectorized reduction operation generated in the previous iteration.\n-\n-   This only works when we see both the reduction PHI and its only consumer\n-   in vectorizable_reduction and there are no intermediate stmts\n-   participating.  */\n-  stmt_vec_info use_stmt_info;\n-  tree reduc_phi_result = gimple_phi_result (reduc_def_phi);\n-  if (ncopies > 1\n-      && (STMT_VINFO_RELEVANT (stmt_info) <= vect_used_only_live)\n-      && (use_stmt_info = loop_vinfo->lookup_single_use (reduc_phi_result))\n-      && (!STMT_VINFO_IN_PATTERN_P (use_stmt_info)\n-\t  || !STMT_VINFO_PATTERN_DEF_SEQ (use_stmt_info))\n-      && vect_stmt_to_vectorize (use_stmt_info) == stmt_info)\n-    single_defuse_cycle = true;\n-\n-  if (slp_node)\n-    vec_num = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n   else\n-    vec_num = 1;\n+    {\n+      ncopies = vect_get_num_copies (loop_vinfo, vectype_in);\n+      vec_num = 1;\n+    }\n \n   internal_fn cond_fn = get_conditional_internal_fn (code);\n   vec_loop_masks *masks = &LOOP_VINFO_MASKS (loop_vinfo);\n@@ -6768,6 +6665,7 @@ vect_transform_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \n   bool masked_loop_p = LOOP_VINFO_FULLY_MASKED_P (loop_vinfo);\n \n+  vect_reduction_type reduction_type = STMT_VINFO_REDUC_TYPE (reduc_info);\n   if (reduction_type == FOLD_LEFT_REDUCTION)\n     {\n       internal_fn reduc_fn = STMT_VINFO_REDUC_FN (reduc_info);\n@@ -6776,6 +6674,7 @@ vect_transform_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t   reduc_fn, ops, vectype_in, reduc_index, masks);\n     }\n \n+  bool single_defuse_cycle = STMT_VINFO_FORCE_SINGLE_CYCLE (reduc_info);\n   gcc_assert (single_defuse_cycle\n \t      || code == DOT_PROD_EXPR\n \t      || code == WIDEN_SUM_EXPR\n@@ -6935,10 +6834,8 @@ vect_transform_cycle_phi (stmt_vec_info stmt_info, stmt_vec_info *vec_stmt,\n \t\t\t  slp_tree slp_node, slp_instance slp_node_instance)\n {\n   tree vectype_out = STMT_VINFO_VECTYPE (stmt_info);\n-  tree vectype_in = NULL_TREE;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  enum vect_def_type dt;\n   int i;\n   int ncopies;\n   stmt_vec_info prev_phi_info;\n@@ -6952,9 +6849,6 @@ vect_transform_cycle_phi (stmt_vec_info stmt_info, stmt_vec_info *vec_stmt,\n       nested_cycle = true;\n     }\n \n-  gphi *phi = as_a <gphi *> (stmt_info->stmt);\n-  tree phi_result = gimple_phi_result (phi);\n-\n   stmt_vec_info reduc_stmt_info = STMT_VINFO_REDUC_DEF (stmt_info);\n   reduc_stmt_info = vect_stmt_to_vectorize (reduc_stmt_info);\n   stmt_vec_info reduc_info = info_for_reduction (stmt_info);\n@@ -6965,26 +6859,8 @@ vect_transform_cycle_phi (stmt_vec_info stmt_info, stmt_vec_info *vec_stmt,\n     /* Leave the scalar phi in place.  */\n     return true;\n \n-  if (gassign *reduc_stmt = dyn_cast <gassign *> (reduc_stmt_info->stmt))\n-    for (unsigned k = 1; k < gimple_num_ops (reduc_stmt); ++k)\n-      {\n-\ttree op = gimple_op (reduc_stmt, k);\n-\tif (op == phi_result)\n-\t  continue;\n-\tif (k == 1 && gimple_assign_rhs_code (reduc_stmt) == COND_EXPR)\n-\t  continue;\n-\tbool is_simple_use = vect_is_simple_use (op, loop_vinfo, &dt);\n-\tgcc_assert (is_simple_use);\n-\tif (dt == vect_constant_def || dt == vect_external_def)\n-\t  continue;\n-\tif (!vectype_in\n-\t    || (GET_MODE_SIZE (SCALAR_TYPE_MODE (TREE_TYPE (vectype_in)))\n-\t\t< GET_MODE_SIZE (SCALAR_TYPE_MODE (TREE_TYPE (op)))))\n-\t  vectype_in = get_vectype_for_scalar_type (TREE_TYPE (op));\n-\tbreak;\n-      }\n-  /* For a nested cycle we might end up with an operation like\n-     phi_result * phi_result.  */\n+  tree vectype_in = STMT_VINFO_REDUC_VECTYPE_IN (reduc_info);\n+  /* For a nested cycle we do not fill the above.  */\n   if (!vectype_in)\n     vectype_in = STMT_VINFO_VECTYPE (stmt_info);\n   gcc_assert (vectype_in);\n@@ -7003,19 +6879,15 @@ vect_transform_cycle_phi (stmt_vec_info stmt_info, stmt_vec_info *vec_stmt,\n       ncopies = vect_get_num_copies (loop_vinfo, vectype_in);\n     }\n \n-  /* Check whether we can use a single PHI node and accumulate\n+  /* Check whether we should use a single PHI node and accumulate\n      vectors to one before the backedge.  */\n-  stmt_vec_info use_stmt_info;\n-  if (ncopies > 1\n-      && STMT_VINFO_RELEVANT (reduc_stmt_info) <= vect_used_only_live\n-      && (use_stmt_info = loop_vinfo->lookup_single_use (phi_result))\n-      && (!STMT_VINFO_IN_PATTERN_P (use_stmt_info)\n-\t  || !STMT_VINFO_PATTERN_DEF_SEQ (use_stmt_info))\n-      && vect_stmt_to_vectorize (use_stmt_info) == reduc_stmt_info)\n+  if (STMT_VINFO_FORCE_SINGLE_CYCLE (reduc_info))\n     ncopies = 1;\n \n   /* Create the destination vector  */\n-  tree vec_dest = vect_create_destination_var (phi_result, vectype_out);\n+  gphi *phi = as_a <gphi *> (stmt_info->stmt);\n+  tree vec_dest = vect_create_destination_var (gimple_phi_result (phi),\n+\t\t\t\t\t       vectype_out);\n \n   /* Get the loop-entry arguments.  */\n   tree vec_initial_def;"}, {"sha": "484de4f6e11e7bda3301febe41dbc1787cbc1f22", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f78347996e02a8a767a525bfb764e769afe29d67/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f78347996e02a8a767a525bfb764e769afe29d67/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=f78347996e02a8a767a525bfb764e769afe29d67", "patch": "@@ -961,6 +961,12 @@ class _stmt_vec_info {\n      corresponding PHI.  */\n   stmt_vec_info reduc_def;\n \n+  /* The vector input type relevant for reduction vectorization.  */\n+  tree reduc_vectype_in;\n+\n+  /* Whether we force a single cycle PHI during reduction vectorization.  */\n+  bool force_single_cycle;\n+\n   /* Whether on this stmt reduction meta is recorded.  */\n   bool is_reduc_info;\n \n@@ -1050,6 +1056,7 @@ STMT_VINFO_BB_VINFO (stmt_vec_info stmt_vinfo)\n #define STMT_VINFO_VEC_INDUC_COND_INITIAL_VAL(S) (S)->induc_cond_initial_val\n #define STMT_VINFO_REDUC_EPILOGUE_ADJUSTMENT(S) (S)->reduc_epilogue_adjustment\n #define STMT_VINFO_REDUC_IDX(S)\t\t   (S)->reduc_idx\n+#define STMT_VINFO_FORCE_SINGLE_CYCLE(S)   (S)->force_single_cycle\n \n #define STMT_VINFO_DR_WRT_VEC_LOOP(S)      (S)->dr_wrt_vec_loop\n #define STMT_VINFO_DR_BASE_ADDRESS(S)      (S)->dr_wrt_vec_loop.base_address\n@@ -1083,6 +1090,7 @@ STMT_VINFO_BB_VINFO (stmt_vec_info stmt_vinfo)\n #define STMT_VINFO_REDUC_CODE(S)\t(S)->reduc_code\n #define STMT_VINFO_REDUC_FN(S)\t\t(S)->reduc_fn\n #define STMT_VINFO_REDUC_DEF(S)\t\t(S)->reduc_def\n+#define STMT_VINFO_REDUC_VECTYPE_IN(S)  (S)->reduc_vectype_in\n #define STMT_VINFO_SLP_VECT_ONLY(S)     (S)->slp_vect_only_p\n \n #define DR_GROUP_FIRST_ELEMENT(S) \\"}]}