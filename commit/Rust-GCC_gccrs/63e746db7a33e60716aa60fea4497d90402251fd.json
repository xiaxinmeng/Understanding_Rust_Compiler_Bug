{"sha": "63e746db7a33e60716aa60fea4497d90402251fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjNlNzQ2ZGI3YTMzZTYwNzE2YWE2MGZlYTQ0OTdkOTA0MDIyNTFmZA==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2005-09-05T08:03:33Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-09-05T08:03:33Z"}, "message": "sem_type.adb (Add_One_Interp): If a candidate operation is an inherited interface operation that has an...\n\n2005-09-01  Ed Schonberg  <schonberg@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\n\t* sem_type.adb (Add_One_Interp): If a candidate operation is an\n\tinherited interface operation that has an implementation, use the\n\timplementation to avoid spurious ambiguities.\n\t(Interface_Present_In_Ancestor): In case of concurrent types we can't\n\tuse the Corresponding_Record_Typ attribute to look for the interface\n\tbecause it is set by the expander (and hence it is not always\n\tavailable). For this reason we traverse the list of interfaces\n\t(available in the parent of the concurrent type).\n\t(Interface_Present_In_Ancestor): Handle entities from the limited view\n\nFrom-SVN: r103887", "tree": {"sha": "ee8640d90b0bcd185a714d5122830e8d823d1fd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee8640d90b0bcd185a714d5122830e8d823d1fd9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63e746db7a33e60716aa60fea4497d90402251fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63e746db7a33e60716aa60fea4497d90402251fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63e746db7a33e60716aa60fea4497d90402251fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63e746db7a33e60716aa60fea4497d90402251fd/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1420b484a811ceb52d51dea8ac553872f61f77d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1420b484a811ceb52d51dea8ac553872f61f77d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1420b484a811ceb52d51dea8ac553872f61f77d2"}], "stats": {"total": 150, "additions": 101, "deletions": 49}, "files": [{"sha": "eca91e59820c093d49da7111d64d4bde9dfa00e6", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 101, "deletions": 49, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63e746db7a33e60716aa60fea4497d90402251fd/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63e746db7a33e60716aa60fea4497d90402251fd/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=63e746db7a33e60716aa60fea4497d90402251fd", "patch": "@@ -29,6 +29,7 @@ with Alloc;\n with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n+with Nlists;   use Nlists;\n with Errout;   use Errout;\n with Lib;      use Lib;\n with Opt;      use Opt;\n@@ -160,7 +161,7 @@ package body Sem_Type is\n    procedure New_Interps (N : Node_Id);\n    --  Initialize collection of interpretations for the given node, which is\n    --  either an overloaded entity, or an operation whose arguments have\n-   --  multiple intepretations. Interpretations can be added to only one\n+   --  multiple interpretations. Interpretations can be added to only one\n    --  node at a time.\n \n    function Specific_Type (T1, T2 : Entity_Id) return Entity_Id;\n@@ -375,6 +376,17 @@ package body Sem_Type is\n         and then not Is_Dispatching_Operation (E)\n       then\n          return;\n+\n+      --  An inherited interface operation that is implemented by some\n+      --  derived type does not participate in overload resolution, only\n+      --  the implementation operation does.\n+\n+      elsif Is_Hidden (E)\n+        and then Is_Subprogram (E)\n+        and then Present (Abstract_Interface_Alias (E))\n+      then\n+         Add_One_Interp (N, Abstract_Interface_Alias (E), T);\n+         return;\n       end if;\n \n       --  If this is the first interpretation of N, N has type Any_Type.\n@@ -422,7 +434,7 @@ package body Sem_Type is\n \n          else\n             --  Overloaded prefix in indexed or selected component,\n-            --  or call whose name is an expresion or another call.\n+            --  or call whose name is an expression or another call.\n \n             Add_Entry (Etype (N), Etype (N));\n          end if;\n@@ -634,7 +646,7 @@ package body Sem_Type is\n       --  actuals  belong to their class but are not compatible with other\n       --  types of their class, and in particular with other generic actuals.\n       --  They are however compatible with their own subtypes, and itypes\n-      --  with the same base are compatible as well. Similary, constrained\n+      --  with the same base are compatible as well. Similarly, constrained\n       --  subtypes obtained from expressions of an unconstrained nominal type\n       --  are compatible with the base type (may lead to spurious ambiguities\n       --  in obscure cases ???)\n@@ -694,9 +706,9 @@ package body Sem_Type is\n         and then Is_Class_Wide_Type (T1)\n         and then Is_Interface (Etype (T1))\n         and then Is_Concurrent_Type (T2)\n-        and then Interface_Present_In_Ancestor (\n-                   Typ   => Corresponding_Record_Type (Base_Type (T2)),\n-                   Iface => Etype (T1))\n+        and then Interface_Present_In_Ancestor\n+                   (Typ   => Base_Type (T2),\n+                    Iface => Etype (T1))\n       then\n          return True;\n \n@@ -1709,6 +1721,8 @@ package body Sem_Type is\n \n               or else\n                 (Is_Concurrent_Type (It.Typ)\n+                  and then Present (Corresponding_Record_Type\n+                                                             (Etype (It.Typ)))\n                   and then Covers (Typ, Corresponding_Record_Type\n                                                              (Etype (It.Typ))))\n \n@@ -1772,62 +1786,102 @@ package body Sem_Type is\n      (Typ   : Entity_Id;\n       Iface : Entity_Id) return Boolean\n    is\n-      AI    : Entity_Id;\n-      E     : Entity_Id;\n-      Elmt  : Elmt_Id;\n+      Target_Typ : Entity_Id;\n+\n+      function Iface_Present_In_Ancestor (Typ : Entity_Id) return Boolean;\n+      --  Returns True if Typ or some ancestor of Typ implements Iface\n+\n+      function Iface_Present_In_Ancestor (Typ : Entity_Id) return Boolean is\n+         E    : Entity_Id;\n+         AI   : Entity_Id;\n+         Elmt : Elmt_Id;\n+\n+      begin\n+         if Typ = Iface then\n+            return True;\n+         end if;\n \n-   begin\n-      if Is_Access_Type (Typ) then\n-         E := Etype (Directly_Designated_Type (Typ));\n-      else\n          E := Typ;\n-      end if;\n+         loop\n+            if Present (Abstract_Interfaces (E))\n+              and then Present (Abstract_Interfaces (E))\n+              and then not Is_Empty_Elmt_List (Abstract_Interfaces (E))\n+            then\n+               Elmt := First_Elmt (Abstract_Interfaces (E));\n+               while Present (Elmt) loop\n+                  AI := Node (Elmt);\n \n-      if Is_Concurrent_Type (E) then\n-         E := Corresponding_Record_Type (E);\n-      end if;\n+                  if AI = Iface or else Is_Ancestor (Iface, AI) then\n+                     return True;\n+                  end if;\n \n-      if Is_Class_Wide_Type (E) then\n-         E := Etype (E);\n-      end if;\n+                  Next_Elmt (Elmt);\n+               end loop;\n+            end if;\n \n-      if E = Iface then\n-         return True;\n-      end if;\n+            exit when Etype (E) = E;\n \n-      loop\n-         if Present (Abstract_Interfaces (E))\n-           and then Abstract_Interfaces (E) /= Empty_List_Or_Node --  ????\n-           and then not Is_Empty_Elmt_List (Abstract_Interfaces (E))\n-         then\n-            Elmt := First_Elmt (Abstract_Interfaces (E));\n+            --  Check if the current type is a direct derivation of the\n+            --  interface\n \n-            while Present (Elmt) loop\n-               AI := Node (Elmt);\n+            if Etype (E) = Iface then\n+               return True;\n+            end if;\n \n-               if AI = Iface or else Is_Ancestor (Iface, AI) then\n-                  return True;\n-               end if;\n+            --  Climb to the immediate ancestor\n \n-               Next_Elmt (Elmt);\n-            end loop;\n-         end if;\n+            E := Etype (E);\n+         end loop;\n+\n+         return False;\n+      end Iface_Present_In_Ancestor;\n+\n+   begin\n+      if Is_Access_Type (Typ) then\n+         Target_Typ := Etype (Directly_Designated_Type (Typ));\n+      else\n+         Target_Typ := Typ;\n+      end if;\n \n-         exit when Etype (E) = E;\n+      --  In case of concurrent types we can't use the Corresponding Record_Typ\n+      --  to look for the interface because it is built by the expander (and\n+      --  hence it is not always available). For this reason we traverse the\n+      --  list of interfaces (available in the parent of the concurrent type)\n \n-         --  Check if the current type is a direct derivation of the\n-         --  interface\n+      if Is_Concurrent_Type (Target_Typ) then\n+         if Present (Interface_List (Parent (Target_Typ))) then\n+            declare\n+               AI : Node_Id;\n+            begin\n+               AI := First (Interface_List (Parent (Target_Typ)));\n+               while Present (AI) loop\n+                  if Etype (AI) = Iface then\n+                     return True;\n \n-         if Etype (E) = Iface then\n-            return True;\n+                  elsif Present (Abstract_Interfaces (Etype (AI)))\n+                     and then Iface_Present_In_Ancestor (Etype (AI))\n+                  then\n+                     return True;\n+                  end if;\n+\n+                  Next (AI);\n+               end loop;\n+            end;\n          end if;\n \n-         --  Climb to the immediate ancestor\n+         return False;\n+      end if;\n \n-         E := Etype (E);\n-      end loop;\n+      if Is_Class_Wide_Type (Target_Typ) then\n+         Target_Typ := Etype (Target_Typ);\n+      end if;\n \n-      return False;\n+      if Ekind (Target_Typ) = E_Incomplete_Type then\n+         pragma Assert (Present (Non_Limited_View (Target_Typ)));\n+         Target_Typ := Non_Limited_View (Target_Typ);\n+      end if;\n+\n+      return Iface_Present_In_Ancestor (Target_Typ);\n    end Interface_Present_In_Ancestor;\n \n    ---------------------\n@@ -1907,9 +1961,7 @@ package body Sem_Type is\n          elsif Is_Class_Wide_Type (Etype (R))\n              and then Is_Interface (Etype (Class_Wide_Type (Etype (R))))\n          then\n-            Error_Msg_Name_1 := Chars (L);\n-            Error_Msg_Name_2 := Chars (Etype (Class_Wide_Type (Etype (R))));\n-            Error_Msg_NE (\"(Ada 2005) % does not implement interface %\",\n+            Error_Msg_NE (\"(Ada 2005) does not implement interface }\",\n                           L, Etype (Class_Wide_Type (Etype (R))));\n \n          else"}]}