{"sha": "6f6278ad2a2a1110541134bf08fac6db5255853c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY2Mjc4YWQyYTJhMTExMDU0MTEzNGJmMDhmYWM2ZGI1MjU1ODUzYw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2009-01-09T17:12:40Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2009-01-09T17:12:40Z"}, "message": "re PR target/38686 (Bootstrap fails on i686-pc-linux-gnu with --with-arch=pentium-m)\n\n\tPR target/38686\n\tPR target/38708\n\t* config/i386/i386.c (override_options): Reject\n\t-mstringop-strategy=rep_8byte with -m32.\n\t(ix86_expand_movmem): For size_needed == 1 set epilogue_size_needed\n\tto 1.  Do count comparison against epilogue_size_needed at compile\n\ttime even when count_exp was constant forced into register.  For\n\tsize_needed don't jump to epilogue, instead just avoid aligning\n\tand invoke the body algorithm.  If need_zero_guard, add zero guard\n\teven if count is non-zero, but smaller than size_needed + number of\n\tbytes that could be stored for alignment.\n\t(ix86_expand_setmem): For size_needed == 1 set epilogue_size_needed\n\tto 1.  If need_zero_guard, add zero guard even if count is non-zero,\n\tbut smaller than size_needed + number of bytes that could be stored\n\tfor alignment.  Compare size_needed with epilogue_size_needed instead\n\tof desired_align - align, don't adjust size_needed, pass\n\tepilogue_size_needed to the epilogue expanders.\n\nFrom-SVN: r143211", "tree": {"sha": "3f1ee33a0f07fae244970cf4d2b76b3e332008dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f1ee33a0f07fae244970cf4d2b76b3e332008dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f6278ad2a2a1110541134bf08fac6db5255853c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f6278ad2a2a1110541134bf08fac6db5255853c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f6278ad2a2a1110541134bf08fac6db5255853c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f6278ad2a2a1110541134bf08fac6db5255853c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "aee5c3ed8c2421a8a65c2728afcfdf58ded4330b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aee5c3ed8c2421a8a65c2728afcfdf58ded4330b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aee5c3ed8c2421a8a65c2728afcfdf58ded4330b"}], "stats": {"total": 99, "additions": 80, "deletions": 19}, "files": [{"sha": "48af2664df229ffcdd158932e9f9502167ba3861", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f6278ad2a2a1110541134bf08fac6db5255853c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f6278ad2a2a1110541134bf08fac6db5255853c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6f6278ad2a2a1110541134bf08fac6db5255853c", "patch": "@@ -1,5 +1,23 @@\n 2009-01-09  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR target/38686\n+\tPR target/38708\n+\t* config/i386/i386.c (override_options): Reject\n+\t-mstringop-strategy=rep_8byte with -m32.\n+\t(ix86_expand_movmem): For size_needed == 1 set epilogue_size_needed\n+\tto 1.  Do count comparison against epilogue_size_needed at compile\n+\ttime even when count_exp was constant forced into register.  For\n+\tsize_needed don't jump to epilogue, instead just avoid aligning\n+\tand invoke the body algorithm.  If need_zero_guard, add zero guard\n+\teven if count is non-zero, but smaller than size_needed + number of\n+\tbytes that could be stored for alignment.\n+\t(ix86_expand_setmem): For size_needed == 1 set epilogue_size_needed\n+\tto 1.  If need_zero_guard, add zero guard even if count is non-zero,\n+\tbut smaller than size_needed + number of bytes that could be stored\n+\tfor alignment.  Compare size_needed with epilogue_size_needed instead\n+\tof desired_align - align, don't adjust size_needed, pass\n+\tepilogue_size_needed to the epilogue expanders.\n+\n \tPR c/35742\n \t* c-pretty-print.c (pp_c_expression): Handle GOTO_EXPR like\n \tBIND_EXPR."}, {"sha": "f44667fffc294a6cb90da2d9d40f6a34a8ae98da", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 62, "deletions": 19, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f6278ad2a2a1110541134bf08fac6db5255853c/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f6278ad2a2a1110541134bf08fac6db5255853c/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=6f6278ad2a2a1110541134bf08fac6db5255853c", "patch": "@@ -2690,7 +2690,9 @@ override_options (bool main_args_p)\n \tstringop_alg = libcall;\n       else if (!strcmp (ix86_stringop_string, \"rep_4byte\"))\n \tstringop_alg = rep_prefix_4_byte;\n-      else if (!strcmp (ix86_stringop_string, \"rep_8byte\"))\n+      else if (!strcmp (ix86_stringop_string, \"rep_8byte\")\n+\t       && TARGET_64BIT)\n+\t/* rep; movq isn't available in 32-bit code.  */\n \tstringop_alg = rep_prefix_8_byte;\n       else if (!strcmp (ix86_stringop_string, \"byte_loop\"))\n \tstringop_alg = loop_1_byte;\n@@ -17642,10 +17644,17 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n \t Make sure it is power of 2.  */\n       epilogue_size_needed = smallest_pow2_greater_than (epilogue_size_needed);\n \n-      if (CONST_INT_P (count_exp))\n+      if (count)\n \t{\n-\t  if (UINTVAL (count_exp) < (unsigned HOST_WIDE_INT)epilogue_size_needed)\n-\t    goto epilogue;\n+\t  if (count < (unsigned HOST_WIDE_INT)epilogue_size_needed)\n+\t    {\n+\t      /* If main algorithm works on QImode, no epilogue is needed.\n+\t\t For small sizes just don't align anything.  */\n+\t      if (size_needed == 1)\n+\t\tdesired_align = align;\n+\t      else\n+\t\tgoto epilogue;\n+\t    }\n \t}\n       else\n \t{\n@@ -17710,10 +17719,17 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n \t  count_exp = plus_constant (count_exp, -align_bytes);\n \t  count -= align_bytes;\n \t}\n-      if (need_zero_guard && !count)\n+      if (need_zero_guard\n+\t  && (!count\n+\t      || (align_bytes == 0\n+\t\t  && count < ((unsigned HOST_WIDE_INT) size_needed\n+\t\t\t      + desired_align - align))))\n \t{\n \t  /* It is possible that we copied enough so the main loop will not\n \t     execute.  */\n+\t  gcc_assert (size_needed > 1);\n+\t  if (label == NULL_RTX)\n+\t    label = gen_label_rtx ();\n \t  emit_cmp_and_jump_insns (count_exp,\n \t\t\t\t   GEN_INT (size_needed),\n \t\t\t\t   LTU, 0, counter_mode (count_exp), 1, label);\n@@ -17729,7 +17745,10 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n       emit_label (label);\n       LABEL_NUSES (label) = 1;\n       label = NULL;\n+      epilogue_size_needed = 1;\n     }\n+  else if (label == NULL_RTX)\n+    epilogue_size_needed = size_needed;\n \n   /* Step 3: Main loop.  */\n \n@@ -18027,16 +18046,29 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n \t loop variant.  */\n       if (epilogue_size_needed > 2 && !promoted_val)\n         force_loopy_epilogue = true;\n-      label = gen_label_rtx ();\n-      emit_cmp_and_jump_insns (count_exp,\n-\t\t\t       GEN_INT (epilogue_size_needed),\n-\t\t\t       LTU, 0, counter_mode (count_exp), 1, label);\n-      if (GET_CODE (count_exp) == CONST_INT)\n-\t;\n-      else if (expected_size == -1 || expected_size <= epilogue_size_needed)\n-\tpredict_jump (REG_BR_PROB_BASE * 60 / 100);\n+      if (count)\n+\t{\n+\t  if (count < (unsigned HOST_WIDE_INT)epilogue_size_needed)\n+\t    {\n+\t      /* If main algorithm works on QImode, no epilogue is needed.\n+\t\t For small sizes just don't align anything.  */\n+\t      if (size_needed == 1)\n+\t\tdesired_align = align;\n+\t      else\n+\t\tgoto epilogue;\n+\t    }\n+\t}\n       else\n-\tpredict_jump (REG_BR_PROB_BASE * 20 / 100);\n+\t{\n+\t  label = gen_label_rtx ();\n+\t  emit_cmp_and_jump_insns (count_exp,\n+\t\t\t\t   GEN_INT (epilogue_size_needed),\n+\t\t\t\t   LTU, 0, counter_mode (count_exp), 1, label);\n+\t  if (expected_size == -1 || expected_size <= epilogue_size_needed)\n+\t    predict_jump (REG_BR_PROB_BASE * 60 / 100);\n+\t  else\n+\t    predict_jump (REG_BR_PROB_BASE * 20 / 100);\n+\t}\n     }\n   if (dynamic_check != -1)\n     {\n@@ -18079,10 +18111,17 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n \t  count_exp = plus_constant (count_exp, -align_bytes);\n \t  count -= align_bytes;\n \t}\n-      if (need_zero_guard && !count)\n+      if (need_zero_guard\n+\t  && (!count\n+\t      || (align_bytes == 0\n+\t\t  && count < ((unsigned HOST_WIDE_INT) size_needed\n+\t\t\t      + desired_align - align))))\n \t{\n \t  /* It is possible that we copied enough so the main loop will not\n \t     execute.  */\n+\t  gcc_assert (size_needed > 1);\n+\t  if (label == NULL_RTX)\n+\t    label = gen_label_rtx ();\n \t  emit_cmp_and_jump_insns (count_exp,\n \t\t\t\t   GEN_INT (size_needed),\n \t\t\t\t   LTU, 0, counter_mode (count_exp), 1, label);\n@@ -18098,7 +18137,11 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n       emit_label (label);\n       LABEL_NUSES (label) = 1;\n       label = NULL;\n+      promoted_val = val_exp;\n+      epilogue_size_needed = 1;\n     }\n+  else if (label == NULL_RTX)\n+    epilogue_size_needed = size_needed;\n \n   /* Step 3: Main loop.  */\n \n@@ -18148,27 +18191,27 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n \t Epilogue code will actually copy COUNT_EXP & EPILOGUE_SIZE_NEEDED\n \t bytes. Compensate if needed.  */\n \n-      if (size_needed < desired_align - align)\n+      if (size_needed < epilogue_size_needed)\n \t{\n \t  tmp =\n \t    expand_simple_binop (counter_mode (count_exp), AND, count_exp,\n \t\t\t\t GEN_INT (size_needed - 1), count_exp, 1,\n \t\t\t\t OPTAB_DIRECT);\n-\t  size_needed = desired_align - align + 1;\n \t  if (tmp != count_exp)\n \t    emit_move_insn (count_exp, tmp);\n \t}\n       emit_label (label);\n       LABEL_NUSES (label) = 1;\n     }\n+ epilogue:\n   if (count_exp != const0_rtx && epilogue_size_needed > 1)\n     {\n       if (force_loopy_epilogue)\n \texpand_setmem_epilogue_via_loop (dst, destreg, val_exp, count_exp,\n-\t\t\t\t\t size_needed);\n+\t\t\t\t\t epilogue_size_needed);\n       else\n \texpand_setmem_epilogue (dst, destreg, promoted_val, count_exp,\n-\t\t\t\tsize_needed);\n+\t\t\t\tepilogue_size_needed);\n     }\n   if (jump_around_label)\n     emit_label (jump_around_label);"}]}