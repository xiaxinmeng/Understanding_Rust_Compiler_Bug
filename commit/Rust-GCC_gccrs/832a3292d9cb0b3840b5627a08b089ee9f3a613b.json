{"sha": "832a3292d9cb0b3840b5627a08b089ee9f3a613b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODMyYTMyOTJkOWNiMGIzODQwYjU2MjdhMDhiMDg5ZWU5ZjNhNjEzYg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-02-29T02:53:51Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-02-29T02:53:51Z"}, "message": "* config/sh/sh.c: Fix formatting.\n\nFrom-SVN: r78646", "tree": {"sha": "c59f6a2286cf771bcf1f3410d231c34caccef697", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c59f6a2286cf771bcf1f3410d231c34caccef697"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/832a3292d9cb0b3840b5627a08b089ee9f3a613b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/832a3292d9cb0b3840b5627a08b089ee9f3a613b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/832a3292d9cb0b3840b5627a08b089ee9f3a613b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/832a3292d9cb0b3840b5627a08b089ee9f3a613b/comments", "author": null, "committer": null, "parents": [{"sha": "508ea1c5fa89201f83778d1052fa1cd79ced176b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/508ea1c5fa89201f83778d1052fa1cd79ced176b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/508ea1c5fa89201f83778d1052fa1cd79ced176b"}], "stats": {"total": 446, "additions": 227, "deletions": 219}, "files": [{"sha": "56158b56b18493cb0059a0601fa64f7c71692eea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/832a3292d9cb0b3840b5627a08b089ee9f3a613b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/832a3292d9cb0b3840b5627a08b089ee9f3a613b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=832a3292d9cb0b3840b5627a08b089ee9f3a613b", "patch": "@@ -1,3 +1,7 @@\n+2004-02-28  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/sh/sh.c: Fix formatting.\n+\n 2004-02-28  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/sh/sh.c: Convert to ISO-C."}, {"sha": "425ab4c1e131691e676b9b73a53de0be385b91fa", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 223, "deletions": 219, "changes": 442, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/832a3292d9cb0b3840b5627a08b089ee9f3a613b/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/832a3292d9cb0b3840b5627a08b089ee9f3a613b/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=832a3292d9cb0b3840b5627a08b089ee9f3a613b", "patch": "@@ -1324,7 +1324,7 @@ output_branch (int logic, rtx insn, rtx *operands)\n     \n \t  output_asm_insn (\"bra\\t%l0\", &op0);\n \t  fprintf (asm_out_file, \"\\tnop\\n\");\n-\t  (*targetm.asm_out.internal_label)(asm_out_file, \"LF\", label);\n+\t  (*targetm.asm_out.internal_label) (asm_out_file, \"LF\", label);\n     \n \t  return \"\";\n \t}\n@@ -1567,7 +1567,7 @@ shift_insns_rtx (rtx insn)\n     case ASHIFT:\n       return shift_insns[shift_count];\n     default:\n-      abort();\n+      abort ();\n     }\n }\n \n@@ -1682,7 +1682,7 @@ addsubcosts (rtx x)\n \n \t/* Fall through.  */\n       default:\n-\t  return 5;\n+\treturn 5;\n       }\n \n   /* Any other constant requires a 2 cycle pc-relative load plus an\n@@ -2089,7 +2089,7 @@ shl_and_kind (rtx left_rtx, rtx mask_rtx, int *attrp)\n     mask = (unsigned HOST_WIDE_INT) INTVAL (mask_rtx) >> left;\n   else\n     mask = (unsigned HOST_WIDE_INT) GET_MODE_MASK (SImode) >> left;\n-  /* Can this be expressed as a right shift / left shift pair ? */\n+  /* Can this be expressed as a right shift / left shift pair?  */\n   lsb = ((mask ^ (mask - 1)) >> 1) + 1;\n   right = exact_log2 (lsb);\n   mask2 = ~(mask + lsb - 1);\n@@ -2103,15 +2103,15 @@ shl_and_kind (rtx left_rtx, rtx mask_rtx, int *attrp)\n       int late_right = exact_log2 (lsb2);\n       best_cost = shift_insns[left + late_right] + shift_insns[late_right];\n     }\n-  /* Try to use zero extend */\n+  /* Try to use zero extend.  */\n   if (mask2 == ~(lsb2 - 1))\n     {\n       int width, first;\n \n       for (width = 8; width <= 16; width += 8)\n \t{\n-\t  /* Can we zero-extend right away? */\n-\t  if (lsb2 == (unsigned HOST_WIDE_INT)1 << width)\n+\t  /* Can we zero-extend right away?  */\n+\t  if (lsb2 == (unsigned HOST_WIDE_INT) 1 << width)\n \t    {\n \t      cost\n \t\t= 1 + ext_shift_insns[right] + ext_shift_insns[left + right];\n@@ -2143,7 +2143,7 @@ shl_and_kind (rtx left_rtx, rtx mask_rtx, int *attrp)\n \t\t  best_len = cost;\n \t\t  if (attrp)\n \t\t    attrp[2] = first;\n-\t\t  }\n+\t\t}\n \t    }\n \t}\n     }\n@@ -2164,7 +2164,7 @@ shl_and_kind (rtx left_rtx, rtx mask_rtx, int *attrp)\n \t}\n     }\n   /* Try to use a scratch register to hold the AND operand.  */\n-  can_ext = ((mask << left) & ((unsigned HOST_WIDE_INT)3 << 30)) == 0;\n+  can_ext = ((mask << left) & ((unsigned HOST_WIDE_INT) 3 << 30)) == 0;\n   for (i = 0; i <= 2; i++)\n     {\n       if (i > right)\n@@ -2229,7 +2229,7 @@ gen_shl_and (rtx dest, rtx left_rtx, rtx mask_rtx, rtx source)\n   unsigned HOST_WIDE_INT mask;\n   int kind = shl_and_kind (left_rtx, mask_rtx, attributes);\n   int right, total_shift;\n-  void (*shift_gen_fun) (int, rtx*) = gen_shifty_hi_op;\n+  void (*shift_gen_fun) (int, rtx *) = gen_shifty_hi_op;\n \n   right = attributes[0];\n   total_shift = INTVAL (left_rtx) + right;\n@@ -2246,10 +2246,10 @@ gen_shl_and (rtx dest, rtx left_rtx, rtx mask_rtx, rtx source)\n \tif (first < 0)\n \t  {\n \t    emit_insn ((mask << right) <= 0xff\n-\t\t       ? gen_zero_extendqisi2(dest,\n-\t\t\t\t\t      gen_lowpart (QImode, source))\n-\t\t       : gen_zero_extendhisi2(dest,\n-\t\t\t\t\t      gen_lowpart (HImode, source)));\n+\t\t       ? gen_zero_extendqisi2 (dest,\n+\t\t\t\t\t       gen_lowpart (QImode, source))\n+\t\t       : gen_zero_extendhisi2 (dest,\n+\t\t\t\t\t       gen_lowpart (HImode, source)));\n \t    source = dest;\n \t  }\n \tif (source != dest)\n@@ -2269,8 +2269,8 @@ gen_shl_and (rtx dest, rtx left_rtx, rtx mask_rtx, rtx source)\n \t  }\n \tif (first >= 0)\n \t  emit_insn (mask <= 0xff\n-\t\t     ? gen_zero_extendqisi2(dest, gen_lowpart (QImode, dest))\n-\t\t     : gen_zero_extendhisi2(dest, gen_lowpart (HImode, dest)));\n+\t\t     ? gen_zero_extendqisi2 (dest, gen_lowpart (QImode, dest))\n+\t\t     : gen_zero_extendhisi2 (dest, gen_lowpart (HImode, dest)));\n \tif (total_shift > 0)\n \t  {\n \t    operands[2] = GEN_INT (total_shift);\n@@ -2284,8 +2284,8 @@ gen_shl_and (rtx dest, rtx left_rtx, rtx mask_rtx, rtx source)\n       /* If the topmost bit that matters is set, set the topmost bits\n \t that don't matter.  This way, we might be able to get a shorter\n \t signed constant.  */\n-      if (mask & ((HOST_WIDE_INT)1 << (31 - total_shift)))\n-\tmask |= (HOST_WIDE_INT)~0 << (31 - total_shift);\n+      if (mask & ((HOST_WIDE_INT) 1 << (31 - total_shift)))\n+\tmask |= (HOST_WIDE_INT) ~0 << (31 - total_shift);\n     case 2:\n       /* Don't expand fine-grained when combining, because that will\n          make the pattern fail.  */\n@@ -2502,8 +2502,8 @@ gen_shl_sext (rtx dest, rtx left_rtx, rtx size_rtx, rtx source)\n \t    gen_shifty_hi_op (ASHIFT, operands);\n \t  }\n \temit_insn (kind & 1\n-\t\t   ? gen_extendqisi2(dest, gen_lowpart (QImode, dest))\n-\t\t   : gen_extendhisi2(dest, gen_lowpart (HImode, dest)));\n+\t\t   ? gen_extendqisi2 (dest, gen_lowpart (QImode, dest))\n+\t\t   : gen_extendhisi2 (dest, gen_lowpart (HImode, dest)));\n \tif (kind <= 2)\n \t  {\n \t    if (shift2)\n@@ -2824,7 +2824,7 @@ dump_table (rtx scan)\n \t\t    {\n \t\t      lab = XEXP (ref, 0);\n \t\t      emit_insn_before (gen_consttable_window_end (lab),\n-\t\t\t\t       align_insn);\n+\t\t\t\t\talign_insn);\n \t\t    }\n \t\t  delete_insn (align_insn);\n \t\t  align_insn = NULL_RTX;\n@@ -3722,7 +3722,7 @@ barrier_align (rtx barrier_or_label)\n \t the table to the minimum for proper code alignment.  */\n       return ((TARGET_SMALLCODE\n \t       || ((unsigned) XVECLEN (pat, 1) * GET_MODE_SIZE (GET_MODE (pat))\n-\t\t   <= (unsigned)1 << (CACHE_LOG - 2)))\n+\t\t   <= (unsigned) 1 << (CACHE_LOG - 2)))\n \t      ? 1 << TARGET_SHMEDIA : align_jumps_log);\n     }\n \n@@ -4813,7 +4813,7 @@ push_regs (HARD_REG_SET *mask, int interrupt_handler)\n \t  HARD_REG_SET unsaved;\n \n \t  push (FPSCR_REG);\n-\t  COMPL_HARD_REG_SET(unsaved, *mask);\n+\t  COMPL_HARD_REG_SET (unsaved, *mask);\n \t  fpscr_set_from_mem (NORMAL_MODE (FP_MODE), unsaved);\n \t  skip_fpscr = 1;\n \t}\n@@ -5103,8 +5103,8 @@ sh5_schedule_saves (HARD_REG_SET *live_regs_mask, save_schedule *schedule,\n \t  && ! (current_function_needs_context && i == STATIC_CHAIN_REGNUM)\n \t  && ! (current_function_calls_eh_return\n \t\t&& (i == EH_RETURN_STACKADJ_REGNO\n-\t\t    || ((unsigned)i <= EH_RETURN_DATA_REGNO (0)\n-\t\t\t&& (unsigned)i >= EH_RETURN_DATA_REGNO (3)))))\n+\t\t    || ((unsigned) i <= EH_RETURN_DATA_REGNO (0)\n+\t\t\t&& (unsigned) i >= EH_RETURN_DATA_REGNO (3)))))\n \tschedule->temps[tmpx++] = i;\n   entry->reg = -1;\n   entry->mode = VOIDmode;\n@@ -6003,7 +6003,7 @@ sh_builtin_saveregs (void)\n       regno = first_floatreg;\n       if (regno & 1)\n \t{\n-\t  emit_insn (gen_addsi3 (fpregs, fpregs, GEN_INT (- UNITS_PER_WORD)));\n+\t  emit_insn (gen_addsi3 (fpregs, fpregs, GEN_INT (-UNITS_PER_WORD)));\n \t  mem = gen_rtx_MEM (SFmode, fpregs);\n \t  set_mem_alias_set (mem, alias_set);\n \t  emit_move_insn (mem,\n@@ -6016,7 +6016,7 @@ sh_builtin_saveregs (void)\n       {\n         rtx mem;\n \n-\temit_insn (gen_addsi3 (fpregs, fpregs, GEN_INT (- UNITS_PER_WORD)));\n+\temit_insn (gen_addsi3 (fpregs, fpregs, GEN_INT (-UNITS_PER_WORD)));\n \tmem = gen_rtx_MEM (SFmode, fpregs);\n \tset_mem_alias_set (mem, alias_set);\n \temit_move_insn (mem,\n@@ -6402,11 +6402,11 @@ sh_function_arg (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n \t\t\t\t\t\t   BASE_ARG_REG (mode)\n \t\t\t\t\t\t   + (ROUND_REG (*ca, mode) ^ 1)),\n \t\t\t\t      const0_rtx);\n-\t  rtx r2 = gen_rtx_EXPR_LIST(VOIDmode,\n-\t\t\t\t     gen_rtx_REG (SFmode,\n-\t\t\t\t\t\t  BASE_ARG_REG (mode)\n-\t\t\t\t\t\t  + ((ROUND_REG (*ca, mode) + 1) ^ 1)),\n-\t\t\t\t     GEN_INT (4));\n+\t  rtx r2 = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t      gen_rtx_REG (SFmode,\n+\t\t\t\t\t\t   BASE_ARG_REG (mode)\n+\t\t\t\t\t\t   + ((ROUND_REG (*ca, mode) + 1) ^ 1)),\n+\t\t\t\t      GEN_INT (4));\n \t  return gen_rtx_PARALLEL(SCmode, gen_rtvec(2, r1, r2));\n \t}\n \n@@ -6473,144 +6473,144 @@ void\n sh_function_arg_advance (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n \t\t\t tree type, int named)\n {\n- if (ca->force_mem)\n-   ca->force_mem = 0;\n- else if (TARGET_SH5)\n-   {\n-     tree type2 = (ca->byref && type\n-\t\t   ? TREE_TYPE (type)\n- \t\t   : type);\n-     enum machine_mode mode2 = (ca->byref && type\n-\t\t\t\t? TYPE_MODE (type2)\n-\t\t\t\t: mode);\n-     int dwords = ((ca->byref\n-\t\t    ? ca->byref\n-\t\t    : mode2 == BLKmode\n-\t\t    ? int_size_in_bytes (type2)\n-\t\t    : GET_MODE_SIZE (mode2)) + 7) / 8;\n-     int numregs = MIN (dwords, NPARM_REGS (SImode)\n-\t\t\t- ca->arg_count[(int) SH_ARG_INT]);\n-\n-     if (numregs)\n-       {\n-\t ca->arg_count[(int) SH_ARG_INT] += numregs;\n-\t if (TARGET_SHCOMPACT\n-\t     && SHCOMPACT_FORCE_ON_STACK (mode2, type2))\n-\t   {\n-\t     ca->call_cookie\n-\t       |= CALL_COOKIE_INT_REG (ca->arg_count[(int) SH_ARG_INT]\n-\t\t\t\t       - numregs, 1);\n-\t     /* N.B. We want this also for outgoing.  */\n-\t     ca->stack_regs += numregs;\n-\t   }\n-\t else if (ca->byref)\n-\t   {\n-\t     if (! ca->outgoing)\n-\t       ca->stack_regs += numregs;\n-\t     ca->byref_regs += numregs;\n-\t     ca->byref = 0;\n-\t     do\n-\t       ca->call_cookie\n-\t\t |= CALL_COOKIE_INT_REG (ca->arg_count[(int) SH_ARG_INT]\n-\t\t\t\t\t - numregs, 2);\n-\t     while (--numregs);\n-\t     ca->call_cookie\n-\t       |= CALL_COOKIE_INT_REG (ca->arg_count[(int) SH_ARG_INT]\n-\t\t\t\t       - 1, 1);\n-\t   }\n-\t else if (dwords > numregs)\n-\t   {\n-\t     int pushregs = numregs;\n-\n-\t     if (TARGET_SHCOMPACT)\n-\t       ca->stack_regs += numregs;\n-\t     while (pushregs < NPARM_REGS (SImode) - 1\n-\t\t    && (CALL_COOKIE_INT_REG_GET\n-\t\t\t(ca->call_cookie,\n-\t\t\tNPARM_REGS (SImode) - pushregs)\n-\t\t\t== 1))\n-\t       {\n-\t\t ca->call_cookie\n-\t\t   &= ~ CALL_COOKIE_INT_REG (NPARM_REGS (SImode)\n-\t\t\t\t\t     - pushregs, 1);\n-\t\t pushregs++;\n-\t       }\n-\t     if (numregs == NPARM_REGS (SImode))\n-\t       ca->call_cookie\n-\t\t |= CALL_COOKIE_INT_REG (0, 1)\n-\t\t    | CALL_COOKIE_STACKSEQ (numregs - 1);\n-\t     else\n-\t       ca->call_cookie\n-\t\t |= CALL_COOKIE_STACKSEQ (numregs);\n-\t   }\n-       }\n-     if (GET_SH_ARG_CLASS (mode2) == SH_ARG_FLOAT\n-\t && (named || ! ca->prototype_p))\n-       {\n-\t if (mode2 == SFmode && ca->free_single_fp_reg)\n-\t   ca->free_single_fp_reg = 0;\n-\t else if (ca->arg_count[(int) SH_ARG_FLOAT]\n- \t\t  < NPARM_REGS (SFmode))\n-\t   {\n-\t     int numfpregs\n-\t       = MIN ((GET_MODE_SIZE (mode2) + 7) / 8 * 2,\n-\t\t      NPARM_REGS (SFmode)\n-\t\t      - ca->arg_count[(int) SH_ARG_FLOAT]);\n-\n-\t     ca->arg_count[(int) SH_ARG_FLOAT] += numfpregs;\n-\n-\t     if (TARGET_SHCOMPACT && ! ca->prototype_p)\n-\t       {\n-\t\t if (ca->outgoing && numregs > 0)\n-\t\t   do\n-\t\t     {\n-\t\t       ca->call_cookie\n-\t\t\t |= (CALL_COOKIE_INT_REG\n-\t\t\t     (ca->arg_count[(int) SH_ARG_INT]\n-\t\t\t      - numregs + ((numfpregs - 2) / 2),\n-\t\t\t      4 + (ca->arg_count[(int) SH_ARG_FLOAT]\n-\t\t\t\t   - numfpregs) / 2));\n-\t\t     }\n-\t\t   while (numfpregs -= 2);\n-\t       }\n-\t     else if (mode2 == SFmode && (named)\n-\t\t      && (ca->arg_count[(int) SH_ARG_FLOAT]\n-\t\t\t  < NPARM_REGS (SFmode)))\n-\t       ca->free_single_fp_reg\n-\t\t = FIRST_FP_PARM_REG - numfpregs\n-\t\t + ca->arg_count[(int) SH_ARG_FLOAT] + 1;\n-\t   }\n-       }\n-     return;\n-   }\n-\n- if ((TARGET_HITACHI || ca->renesas_abi) && TARGET_FPU_DOUBLE)\n-   {\n-     /* Note that we've used the skipped register.  */\n-     if (mode == SFmode && ca->free_single_fp_reg)\n-       {\n-\t ca->free_single_fp_reg = 0;\n-\t return;\n-       }\n-     /* When we have a DF after an SF, there's an SF register that get\n-\tskipped in order to align the DF value.  We note this skipped\n-\tregister, because the next SF value will use it, and not the\n-\tSF that follows the DF.  */\n-     if (mode == DFmode\n-\t && ROUND_REG (*ca, DFmode) != ROUND_REG (*ca, SFmode))\n-       {\n-\t ca->free_single_fp_reg = (ROUND_REG (*ca, SFmode)\n-\t\t\t\t     + BASE_ARG_REG (mode));\n-       }\n-   }\n-\n- if (! (TARGET_SH4 || ca->renesas_abi)\n-     || PASS_IN_REG_P (*ca, mode, type))\n-   (ca->arg_count[(int) GET_SH_ARG_CLASS (mode)]\n-    = (ROUND_REG (*ca, mode)\n-       + (mode == BLKmode\n-\t  ? ROUND_ADVANCE (int_size_in_bytes (type))\n-\t  : ROUND_ADVANCE (GET_MODE_SIZE (mode)))));\n+  if (ca->force_mem)\n+    ca->force_mem = 0;\n+  else if (TARGET_SH5)\n+    {\n+      tree type2 = (ca->byref && type\n+\t\t    ? TREE_TYPE (type)\n+\t\t    : type);\n+      enum machine_mode mode2 = (ca->byref && type\n+\t\t\t\t ? TYPE_MODE (type2)\n+\t\t\t\t : mode);\n+      int dwords = ((ca->byref\n+\t\t     ? ca->byref\n+\t\t     : mode2 == BLKmode\n+\t\t     ? int_size_in_bytes (type2)\n+\t\t     : GET_MODE_SIZE (mode2)) + 7) / 8;\n+      int numregs = MIN (dwords, NPARM_REGS (SImode)\n+\t\t\t - ca->arg_count[(int) SH_ARG_INT]);\n+\n+      if (numregs)\n+\t{\n+\t  ca->arg_count[(int) SH_ARG_INT] += numregs;\n+\t  if (TARGET_SHCOMPACT\n+\t      && SHCOMPACT_FORCE_ON_STACK (mode2, type2))\n+\t    {\n+\t      ca->call_cookie\n+\t\t|= CALL_COOKIE_INT_REG (ca->arg_count[(int) SH_ARG_INT]\n+\t\t\t\t\t- numregs, 1);\n+\t      /* N.B. We want this also for outgoing.  */\n+\t      ca->stack_regs += numregs;\n+\t    }\n+\t  else if (ca->byref)\n+\t    {\n+\t      if (! ca->outgoing)\n+\t\tca->stack_regs += numregs;\n+\t      ca->byref_regs += numregs;\n+\t      ca->byref = 0;\n+\t      do\n+\t\tca->call_cookie\n+\t\t  |= CALL_COOKIE_INT_REG (ca->arg_count[(int) SH_ARG_INT]\n+\t\t\t\t\t  - numregs, 2);\n+\t      while (--numregs);\n+\t      ca->call_cookie\n+\t\t|= CALL_COOKIE_INT_REG (ca->arg_count[(int) SH_ARG_INT]\n+\t\t\t\t\t- 1, 1);\n+\t    }\n+\t  else if (dwords > numregs)\n+\t    {\n+\t      int pushregs = numregs;\n+\n+\t      if (TARGET_SHCOMPACT)\n+\t\tca->stack_regs += numregs;\n+\t      while (pushregs < NPARM_REGS (SImode) - 1\n+\t\t     && (CALL_COOKIE_INT_REG_GET\n+\t\t\t (ca->call_cookie,\n+\t\t\t  NPARM_REGS (SImode) - pushregs)\n+\t\t\t == 1))\n+\t\t{\n+\t\t  ca->call_cookie\n+\t\t    &= ~ CALL_COOKIE_INT_REG (NPARM_REGS (SImode)\n+\t\t\t\t\t      - pushregs, 1);\n+\t\t  pushregs++;\n+\t\t}\n+\t      if (numregs == NPARM_REGS (SImode))\n+\t\tca->call_cookie\n+\t\t  |= CALL_COOKIE_INT_REG (0, 1)\n+\t\t  | CALL_COOKIE_STACKSEQ (numregs - 1);\n+\t      else\n+\t\tca->call_cookie\n+\t\t  |= CALL_COOKIE_STACKSEQ (numregs);\n+\t    }\n+\t}\n+      if (GET_SH_ARG_CLASS (mode2) == SH_ARG_FLOAT\n+\t  && (named || ! ca->prototype_p))\n+\t{\n+\t  if (mode2 == SFmode && ca->free_single_fp_reg)\n+\t    ca->free_single_fp_reg = 0;\n+\t  else if (ca->arg_count[(int) SH_ARG_FLOAT]\n+\t\t   < NPARM_REGS (SFmode))\n+\t    {\n+\t      int numfpregs\n+\t\t= MIN ((GET_MODE_SIZE (mode2) + 7) / 8 * 2,\n+\t\t       NPARM_REGS (SFmode)\n+\t\t       - ca->arg_count[(int) SH_ARG_FLOAT]);\n+\n+\t      ca->arg_count[(int) SH_ARG_FLOAT] += numfpregs;\n+\n+\t      if (TARGET_SHCOMPACT && ! ca->prototype_p)\n+\t\t{\n+\t\t  if (ca->outgoing && numregs > 0)\n+\t\t    do\n+\t\t      {\n+\t\t\tca->call_cookie\n+\t\t\t  |= (CALL_COOKIE_INT_REG\n+\t\t\t      (ca->arg_count[(int) SH_ARG_INT]\n+\t\t\t       - numregs + ((numfpregs - 2) / 2),\n+\t\t\t       4 + (ca->arg_count[(int) SH_ARG_FLOAT]\n+\t\t\t\t    - numfpregs) / 2));\n+\t\t      }\n+\t\t    while (numfpregs -= 2);\n+\t\t}\n+\t      else if (mode2 == SFmode && (named)\n+\t\t       && (ca->arg_count[(int) SH_ARG_FLOAT]\n+\t\t\t   < NPARM_REGS (SFmode)))\n+\t\tca->free_single_fp_reg\n+\t\t  = FIRST_FP_PARM_REG - numfpregs\n+\t\t  + ca->arg_count[(int) SH_ARG_FLOAT] + 1;\n+\t    }\n+\t}\n+      return;\n+    }\n+\n+  if ((TARGET_HITACHI || ca->renesas_abi) && TARGET_FPU_DOUBLE)\n+    {\n+      /* Note that we've used the skipped register.  */\n+      if (mode == SFmode && ca->free_single_fp_reg)\n+\t{\n+\t  ca->free_single_fp_reg = 0;\n+\t  return;\n+\t}\n+      /* When we have a DF after an SF, there's an SF register that get\n+\t skipped in order to align the DF value.  We note this skipped\n+\t register, because the next SF value will use it, and not the\n+\t SF that follows the DF.  */\n+      if (mode == DFmode\n+\t  && ROUND_REG (*ca, DFmode) != ROUND_REG (*ca, SFmode))\n+\t{\n+\t  ca->free_single_fp_reg = (ROUND_REG (*ca, SFmode)\n+\t\t\t\t    + BASE_ARG_REG (mode));\n+\t}\n+    }\n+\n+  if (! (TARGET_SH4 || ca->renesas_abi)\n+      || PASS_IN_REG_P (*ca, mode, type))\n+    (ca->arg_count[(int) GET_SH_ARG_CLASS (mode)]\n+     = (ROUND_REG (*ca, mode)\n+\t+ (mode == BLKmode\n+\t   ? ROUND_ADVANCE (int_size_in_bytes (type))\n+\t   : ROUND_ADVANCE (GET_MODE_SIZE (mode)))));\n }\n \n /* The Renesas calling convention doesn't quite fit into this scheme since\n@@ -7252,7 +7252,7 @@ and_operand (rtx op, enum machine_mode mode)\n       && mode == DImode\n       && GET_CODE (op) == CONST_INT\n       && CONST_OK_FOR_J16 (INTVAL (op)))\n-\treturn 1;\n+    return 1;\n \n   return 0;\n }\n@@ -7429,7 +7429,8 @@ equality_comparison_operator (rtx op, enum machine_mode mode)\n \t  && (GET_CODE (op) == EQ || GET_CODE (op) == NE));\n }\n \n-int greater_comparison_operator (rtx op, enum machine_mode mode)\n+int\n+greater_comparison_operator (rtx op, enum machine_mode mode)\n {\n   if (mode != VOIDmode && GET_MODE (op) == mode)\n     return 0;\n@@ -7445,7 +7446,8 @@ int greater_comparison_operator (rtx op, enum machine_mode mode)\n     }\n }\n \n-int less_comparison_operator (rtx op, enum machine_mode mode)\n+int\n+less_comparison_operator (rtx op, enum machine_mode mode)\n {\n   if (mode != VOIDmode && GET_MODE (op) == mode)\n     return 0;\n@@ -7508,7 +7510,7 @@ mextr_bit_offset (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n   if (GET_CODE (op) != CONST_INT)\n     return 0;\n   i = INTVAL (op);\n-  return i >= 1*8 && i <= 7*8 && (i & 7) == 0;\n+  return i >= 1 * 8 && i <= 7 * 8 && (i & 7) == 0;\n }\n \n int\n@@ -7571,7 +7573,7 @@ sh_rep_vec (rtx v, enum machine_mode mode)\n   if (GET_MODE_UNIT_SIZE (mode) == 1)\n     {\n       y = XVECEXP (v, 0, i);\n-      for (i -= 2 ; i >= 0; i -= 2)\n+      for (i -= 2; i >= 0; i -= 2)\n \tif (! rtx_equal_p (XVECEXP (v, 0, i + 1), x)\n \t    || ! rtx_equal_p (XVECEXP (v, 0, i), y))\n \t  return 0;\n@@ -7791,7 +7793,7 @@ void\n expand_df_binop (rtx (*fun) (rtx, rtx, rtx, rtx), rtx *operands)\n {\n   emit_df_insn ((*fun) (operands[0], operands[1], operands[2],\n-\t\t\t get_fpscr_rtx ()));\n+\t\t\tget_fpscr_rtx ()));\n }\n \f\n /* ??? gcc does flow analysis strictly after common subexpression\n@@ -8029,7 +8031,7 @@ nonpic_symbol_mentioned_p (rtx x)\n \t  || XINT (x, 1) == UNSPEC_GOTTPOFF\n \t  || XINT (x, 1) == UNSPEC_DTPOFF\n \t  || XINT (x, 1) == UNSPEC_PLT))\n-      return 0;\n+    return 0;\n \n   fmt = GET_RTX_FORMAT (GET_CODE (x));\n   for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n@@ -8182,15 +8184,14 @@ int\n sh_hard_regno_rename_ok (unsigned int old_reg ATTRIBUTE_UNUSED,\n \t\t\t unsigned int new_reg)\n {\n-\n-/* Interrupt functions can only use registers that have already been\n-   saved by the prologue, even if they would normally be\n-   call-clobbered.  */\n+  /* Interrupt functions can only use registers that have already been\n+     saved by the prologue, even if they would normally be\n+     call-clobbered.  */\n \n   if (sh_cfun_interrupt_handler_p () && !regs_ever_live[new_reg])\n-     return 0;\n+    return 0;\n \n-   return 1;\n+  return 1;\n }\n \n /* Function to update the integer COST\n@@ -8266,7 +8267,7 @@ sh_adjust_cost (rtx insn, rtx link ATTRIBUTE_UNUSED, rtx dep_insn, int cost)\n \t       && get_attr_type (insn) == TYPE_DYN_SHIFT\n \t       && get_attr_any_int_load (dep_insn) == ANY_INT_LOAD_YES\n \t       && reg_overlap_mentioned_p (SET_DEST (PATTERN (dep_insn)),\n-\t\t\t\t\t   XEXP (SET_SRC (single_set(insn)),\n+\t\t\t\t\t   XEXP (SET_SRC (single_set (insn)),\n \t\t\t\t\t\t 1)))\n \tcost++;\n       /* When an LS group instruction with a latency of less than\n@@ -8338,7 +8339,7 @@ sh_pr_n_sets (void)\n /* This Function returns nonzero if the DFA based scheduler interface\n    is to be used.  At present this is supported for the SH4 only.  */\n static int\n-sh_use_dfa_interface(void)\n+sh_use_dfa_interface (void)\n {\n   if (TARGET_HARD_SH4)\n     return 1;\n@@ -8349,7 +8350,7 @@ sh_use_dfa_interface(void)\n /* This function returns \"2\" to indicate dual issue for the SH4\n    processor.  To be used by the DFA pipeline description.  */\n static int\n-sh_issue_rate(void)\n+sh_issue_rate (void)\n {\n   if (TARGET_SUPERSCALAR)\n     return 2;\n@@ -8467,12 +8468,15 @@ swap_reorder (rtx *a, int n)\n   a[i + 1] = insn;\n }\n \n-#define SCHED_REORDER(READY, N_READY)                                \\\n-do { if ((N_READY) == 2)                                             \\\n-       swap_reorder (READY, N_READY);                                \\\n-     else if ((N_READY) > 2)                                         \\\n-       qsort (READY, N_READY, sizeof (rtx), rank_for_reorder); }     \\\n-while (0)\n+#define SCHED_REORDER(READY, N_READY)                                \t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if ((N_READY) == 2)\t\t\t\t\t\t\\\n+\tswap_reorder (READY, N_READY);\t\t\t\t\t\\\n+      else if ((N_READY) > 2)\t\t\t\t\t\t\\\n+\tqsort (READY, N_READY, sizeof (rtx), rank_for_reorder);\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* Sort the ready list READY by ascending priority, using the SCHED_REORDER\n    macro.  */\n@@ -8631,22 +8635,22 @@ sh_dfa_new_cycle (FILE *sched_dump ATTRIBUTE_UNUSED,\n \t\t  int *sort_p)\n {\n   if (reload_completed)\n-\t  return 0;\n+    return 0;\n \n   if (skip_cycles) \n-  {\n-    if ((clock_var - last_clock_var) < MAX_SKIPS)\n     {\n-      *sort_p = 0;\n-      return 1;\n-    }\n-    /* If this is the last cycle we are skipping, allow reordering of R.  */\n-    if ((clock_var - last_clock_var) == MAX_SKIPS)\n-    {\n-      *sort_p = 1;\n-      return 1;\n+      if ((clock_var - last_clock_var) < MAX_SKIPS)\n+\t{\n+\t  *sort_p = 0;\n+\t  return 1;\n+\t}\n+      /* If this is the last cycle we are skipping, allow reordering of R.  */\n+      if ((clock_var - last_clock_var) == MAX_SKIPS)\n+\t{\n+\t  *sort_p = 1;\n+\t  return 1;\n+\t}\n     }\n-  }\n \n   skip_cycles = 0;\n \n@@ -9195,16 +9199,16 @@ sh_cannot_change_mode_class (enum machine_mode from, enum machine_mode to,\n {\n   if (GET_MODE_SIZE (from) != GET_MODE_SIZE (to))\n     {\n-       if (TARGET_LITTLE_ENDIAN)\n-         {\n-\t   if (GET_MODE_SIZE (to) < 8 || GET_MODE_SIZE (from) < 8)\n-\t     return reg_classes_intersect_p (DF_REGS, class);\n-\t }\n-       else\n-\t {\n-\t   if (GET_MODE_SIZE (from) < 8)\n-\t     return reg_classes_intersect_p (DF_HI_REGS, class);\n-\t }\n+      if (TARGET_LITTLE_ENDIAN)\n+\t{\n+\t  if (GET_MODE_SIZE (to) < 8 || GET_MODE_SIZE (from) < 8)\n+\t    return reg_classes_intersect_p (DF_REGS, class);\n+\t}\n+      else\n+\t{\n+\t  if (GET_MODE_SIZE (from) < 8)\n+\t    return reg_classes_intersect_p (DF_HI_REGS, class);\n+\t}\n     }\n   return 0;\n }\n@@ -9252,15 +9256,15 @@ sh_register_move_cost (enum machine_mode mode,\n     return 4;\n \n   if ((REGCLASS_HAS_FP_REG (dstclass) && srcclass == MAC_REGS)\n-      || (dstclass== MAC_REGS && REGCLASS_HAS_FP_REG (srcclass)))\n+      || (dstclass == MAC_REGS && REGCLASS_HAS_FP_REG (srcclass)))\n     return 9;\n \n   if ((REGCLASS_HAS_FP_REG (dstclass)\n        && REGCLASS_HAS_GENERAL_REG (srcclass))\n       || (REGCLASS_HAS_GENERAL_REG (dstclass)\n \t  && REGCLASS_HAS_FP_REG (srcclass)))\n-   return ((TARGET_SHMEDIA ? 4 : TARGET_FMOVD ? 8 : 12)\n-\t   * ((GET_MODE_SIZE (mode) + 7) / 8U));\n+    return ((TARGET_SHMEDIA ? 4 : TARGET_FMOVD ? 8 : 12)\n+\t    * ((GET_MODE_SIZE (mode) + 7) / 8U));\n \n   if ((dstclass == FPUL_REGS\n        && REGCLASS_HAS_GENERAL_REG (srcclass))\n@@ -9430,7 +9434,7 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \tabort (); /* FIXME */\n       emit_load_ptr (scratch0, offset_addr);\n \n-     if (Pmode != ptr_mode)\n+      if (Pmode != ptr_mode)\n \tscratch0 = gen_rtx_TRUNCATE (ptr_mode, scratch0);\n       emit_insn (gen_add2_insn (this, scratch0));\n     }\n@@ -9469,7 +9473,7 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   sh_reorg ();\n \n   if (optimize > 0 && flag_delayed_branch)\n-      dbr_schedule (insns, dump_file);\n+    dbr_schedule (insns, dump_file);\n   shorten_branches (insns);\n   final_start_function (insns, file, 1);\n   final (insns, file, 1, 0);"}]}