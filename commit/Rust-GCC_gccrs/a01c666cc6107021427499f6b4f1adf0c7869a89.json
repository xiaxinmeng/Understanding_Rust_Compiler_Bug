{"sha": "a01c666cc6107021427499f6b4f1adf0c7869a89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTAxYzY2NmNjNjEwNzAyMTQyNzQ5OWY2YjRmMWFkZjBjNzg2OWE4OQ==", "commit": {"author": {"name": "Paul Koning", "email": "pkoning@equallogic.com", "date": "2010-10-29T14:32:59Z"}, "committer": {"name": "Paul Koning", "email": "pkoning@gcc.gnu.org", "date": "2010-10-29T14:32:59Z"}, "message": "pdp11-protos.h (pdp11_cannot_change_mode_class, [...]): Declare.\n\n* config/pdp11/pdp11-protos.h (pdp11_cannot_change_mode_class,\npdp11_secondary_memory_needed): Declare.\n* config/pdp11/predicates.md (float_operand): New predicate.\n* config/pdp11/pdp11.md (RETVAL_REGNUM): New constant.\n(cbranchdf4, movdf): Change predicate.\n(movsf): Handle FPU register case.\n(truncdfsf2, extendsfdf2): Add FPU register case.\n* config/pdp11/pdp11.c (TARGET_SECONDARY_RELOAD,\nTARGET_REGISTER_MOVE_COST, TARGET_PREFERRED_RELOAD_CLASS,\nTARGET_PREFERRED_OUTPUT_RELOAD_CLASS): Define.\n(pdp11_register_move_cost): Update cost matrix.\n(pdp11_cannot_change_mode_class, pdp11_preferred_reload_class,\npdp11_preferred_output_reload_class, pdp11_secondary_reload,\npdp11_secondary_memory_needed): New function.\n(pdp11_return_in_memory): Add other float types.\n* config/pdp11/pdp11.h (HARD_REGNO_MODE_OK): Add other float\ntypes. \n(SECONDARY_MEMORY_NEEDED, CANNOT_CHANGE_MODE_CLASS): Define.\n(PREFERRED_RELOAD_CLASS, SECONDARY_RELOAD_CLASS,\nREGISTER_MOVE_COST): Delete.\n(BASE_RETURN_VALUE_REG): Add other float types.\n\nFrom-SVN: r166060", "tree": {"sha": "fa622f7d10decd8d5a2aa8ade580484ad84cf417", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa622f7d10decd8d5a2aa8ade580484ad84cf417"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a01c666cc6107021427499f6b4f1adf0c7869a89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a01c666cc6107021427499f6b4f1adf0c7869a89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a01c666cc6107021427499f6b4f1adf0c7869a89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a01c666cc6107021427499f6b4f1adf0c7869a89/comments", "author": null, "committer": null, "parents": [{"sha": "1e4bf85b80166e3315532ba50608fd5e19411f32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e4bf85b80166e3315532ba50608fd5e19411f32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e4bf85b80166e3315532ba50608fd5e19411f32"}], "stats": {"total": 255, "additions": 201, "deletions": 54}, "files": [{"sha": "68af1080d13dfa5ac9f6d761754c77223fc0fd42", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01c666cc6107021427499f6b4f1adf0c7869a89/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01c666cc6107021427499f6b4f1adf0c7869a89/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a01c666cc6107021427499f6b4f1adf0c7869a89", "patch": "@@ -1,3 +1,27 @@\n+2010-10-29  Paul Koning  <pkoning@equallogic.com>\n+\n+\t* config/pdp11/pdp11-protos.h (pdp11_cannot_change_mode_class,\n+\tpdp11_secondary_memory_needed): Declare.\n+\t* config/pdp11/predicates.md (float_operand): New predicate.\n+\t* config/pdp11/pdp11.md (RETVAL_REGNUM): New constant.\n+\t(cbranchdf4, movdf): Change predicate.\n+\t(movsf): Handle FPU register case.\n+\t(truncdfsf2, extendsfdf2): Add FPU register case.\n+\t* config/pdp11/pdp11.c (TARGET_SECONDARY_RELOAD,\n+\tTARGET_REGISTER_MOVE_COST, TARGET_PREFERRED_RELOAD_CLASS,\n+\tTARGET_PREFERRED_OUTPUT_RELOAD_CLASS): Define.\n+\t(pdp11_register_move_cost): Update cost matrix.\n+\t(pdp11_cannot_change_mode_class, pdp11_preferred_reload_class,\n+\tpdp11_preferred_output_reload_class, pdp11_secondary_reload,\n+\tpdp11_secondary_memory_needed): New function.\n+\t(pdp11_return_in_memory): Add other float types.\n+\t* config/pdp11/pdp11.h (HARD_REGNO_MODE_OK): Add other float\n+\ttypes. \n+\t(SECONDARY_MEMORY_NEEDED, CANNOT_CHANGE_MODE_CLASS): Define.\n+\t(PREFERRED_RELOAD_CLASS, SECONDARY_RELOAD_CLASS,\n+\tREGISTER_MOVE_COST): Delete.\n+\t(BASE_RETURN_VALUE_REG): Add other float types.\n+\n 2010-10-29  Nick Clifton<nickc@redhat.com>\n \n \t* doc/invoke.texi: Document -mam34 and -mtune options."}, {"sha": "a8da5a666bfde96aa6313b3825501da28ff60920", "filename": "gcc/config/pdp11/pdp11-protos.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01c666cc6107021427499f6b4f1adf0c7869a89/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01c666cc6107021427499f6b4f1adf0c7869a89/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h?ref=a01c666cc6107021427499f6b4f1adf0c7869a89", "patch": "@@ -31,7 +31,11 @@ extern const char *output_move_quad (rtx *);\n extern const char *output_block_move (rtx *);\n extern const char *output_jump (enum rtx_code, int, int);\n extern void print_operand_address (FILE *, rtx);\n-extern int pdp11_register_move_cost (enum reg_class, enum reg_class);\n+extern bool pdp11_cannot_change_mode_class (enum machine_mode,\n+                                            enum machine_mode, enum reg_class);\n+extern bool pdp11_secondary_memory_needed (reg_class_t, reg_class_t, \n+\t\t\t\t\t   enum machine_mode);\n+\n #endif /* RTX_CODE */\n \n extern void output_ascii (FILE *, const char *, int);"}, {"sha": "c586b9ccf6dc28d3bee289a0485e0b865e7f1ca4", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 127, "deletions": 12, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01c666cc6107021427499f6b4f1adf0c7869a89/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01c666cc6107021427499f6b4f1adf0c7869a89/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=a01c666cc6107021427499f6b4f1adf0c7869a89", "patch": "@@ -216,7 +216,17 @@ static const struct default_options pdp11_option_optimization_table[] =\n #undef TARGET_TRAMPOLINE_INIT\n #define TARGET_TRAMPOLINE_INIT pdp11_trampoline_init\n \n-struct gcc_target targetm = TARGET_INITIALIZER;\n+#undef  TARGET_SECONDARY_RELOAD\n+#define TARGET_SECONDARY_RELOAD pdp11_secondary_reload\n+\n+#undef  TARGET_REGISTER_MOVE_COST \n+#define TARGET_REGISTER_MOVE_COST pdp11_register_move_cost\n+\n+#undef  TARGET_PREFERRED_RELOAD_CLASS\n+#define TARGET_PREFERRED_RELOAD_CLASS pdp11_preferred_reload_class\n+\n+#undef  TARGET_PREFERRED_OUTPUT_RELOAD_CLASS\n+#define TARGET_PREFERRED_OUTPUT_RELOAD_CLASS pdp11_preferred_output_reload_class\n \f\n /* Implement TARGET_HANDLE_OPTION.  */\n \n@@ -417,7 +427,7 @@ pdp11_output_function_epilogue (FILE *stream, HOST_WIDE_INT size)\n \t\n \t/* get ACs */\n \tfor (i = AC5_REGNUM; i >= AC0_REGNUM; i--)\n-\t  if (df_regs_ever_live_p (i) && call_used_regs[i])\n+\t  if (df_regs_ever_live_p (i) && ! call_used_regs[i])\n \t\tvia_ac = i;\n \t\n \tfor (i = AC5_REGNUM; i >= AC0_REGNUM; i--)\n@@ -1054,22 +1064,23 @@ static const int move_costs[N_REG_CLASSES][N_REG_CLASSES] =\n              /* NO  MUL  GEN  LFPU  NLFPU FPU ALL */\n \n /* NO */     {  0,   0,   0,    0,    0,    0,   0},\n-/* MUL */    {  0,   2,   2,   10,   22,   22,  22},\n-/* GEN */    {  0,   2,   2,   10,   22,   22,  22},\n-/* LFPU */   {  0,  10,  10,    2,    2,    2,  10},\n-/* NLFPU */  {  0,  22,  22,    2,    2,    2,  22},\n-/* FPU */    {  0,  22,  22,    2,    2,    2,  22},\n-/* ALL */    {  0,  22,  22,   10,   22,   22,  22}\n+/* MUL */    {  0,   2,   2,   22,   22,   22,  22},\n+/* GEN */    {  0,   2,   2,   22,   22,   22,  22},\n+/* LFPU */   {  0,  22,  22,    2,    2,    2,  22},\n+/* NLFPU */  {  0,  22,  22,    2,   10,   10,  22},\n+/* FPU */    {  0,  22,  22,    2,   10,   10,  22},\n+/* ALL */    {  0,  22,  22,   22,   22,   22,  22}\n }  ;\n \n \n /* -- note that some moves are tremendously expensive, \n    because they require lots of tricks! do we have to \n    charge the costs incurred by secondary reload class \n-   -- as we do here with 22 -- or not ? */\n+   -- as we do here with 10 -- or not ? */\n \n-int \n-pdp11_register_move_cost (enum reg_class c1, enum reg_class c2)\n+static int \n+pdp11_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t  reg_class_t c1, reg_class_t c2)\n {\n     return move_costs[(int)c1][(int)c2];\n }\n@@ -1634,6 +1645,108 @@ legitimate_const_double_p (rtx address)\n   return 0;\n }\n \n+/* Implement CANNOT_CHANGE_MODE_CLASS.  */\n+bool\n+pdp11_cannot_change_mode_class (enum machine_mode from,\n+\t\t\t\tenum machine_mode to,\n+\t\t\t\tenum reg_class rclass)\n+{\n+  /* Also, FPU registers contain a whole float value and the parts of\n+     it are not separately accessible.\n+\n+     So we disallow all mode changes involving FPRs.  */\n+  if (FLOAT_MODE_P (from) != FLOAT_MODE_P (to))\n+    return true;\n+  \n+  return reg_classes_intersect_p (FPU_REGS, rclass);\n+}\n+\n+/* TARGET_PREFERRED_RELOAD_CLASS\n+\n+   Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.  \n+\n+loading is easier into LOAD_FPU_REGS than FPU_REGS! */\n+\n+static reg_class_t\n+pdp11_preferred_reload_class (rtx x, reg_class_t class)\n+{\n+  if (class == FPU_REGS)\n+    return LOAD_FPU_REGS;\n+  if (class == ALL_REGS)\n+    {\n+      if (FLOAT_MODE_P (GET_MODE (x)))\n+\treturn LOAD_FPU_REGS;\n+      else\n+\treturn GENERAL_REGS;\n+    }\n+  return class;\n+}\n+\n+/* TARGET_PREFERRED_OUTPUT_RELOAD_CLASS\n+\n+   Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.  \n+\n+loading is easier into LOAD_FPU_REGS than FPU_REGS! */\n+\n+static reg_class_t\n+pdp11_preferred_output_reload_class (rtx x, reg_class_t class)\n+{\n+  if (class == FPU_REGS)\n+    return LOAD_FPU_REGS;\n+  if (class == ALL_REGS)\n+    {\n+      if (FLOAT_MODE_P (GET_MODE (x)))\n+\treturn LOAD_FPU_REGS;\n+      else\n+\treturn GENERAL_REGS;\n+    }\n+  return class;\n+}\n+\n+\n+/* TARGET_SECONDARY_RELOAD.\n+\n+   FPU registers AC4 and AC5 (class NO_LOAD_FPU_REGS) require an \n+   intermediate register (AC0-AC3: LOAD_FPU_REGS).  Everything else\n+   can be loade/stored directly.  */\n+reg_class_t \n+pdp11_secondary_reload (bool in_p ATTRIBUTE_UNUSED,\n+\t\t\trtx x,\n+\t\t\treg_class_t reload_class,\n+\t\t\tenum machine_mode reload_mode ATTRIBUTE_UNUSED,\n+\t\t\tsecondary_reload_info *sri ATTRIBUTE_UNUSED)\n+{\n+  if (reload_class != NO_LOAD_FPU_REGS || GET_CODE (x) != REG ||\n+      REGNO_REG_CLASS (REGNO (x)) == LOAD_FPU_REGS)\n+    return NO_REGS;\n+  \n+  return LOAD_FPU_REGS;\n+}\n+\n+/* Target routine to check if register to register move requires memory.\n+\n+   The answer is yes if we're going between general register and FPU \n+   registers.  The mode doesn't matter in making this check.\n+*/\n+bool \n+pdp11_secondary_memory_needed (reg_class_t c1, reg_class_t c2, \n+\t\t\t       enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  int fromfloat = (c1 == LOAD_FPU_REGS || c1 == NO_LOAD_FPU_REGS || \n+\t\t   c1 == FPU_REGS);\n+  int tofloat = (c2 == LOAD_FPU_REGS || c2 == NO_LOAD_FPU_REGS || \n+\t\t c2 == FPU_REGS);\n+  \n+  return (fromfloat != tofloat);\n+}\n+\n+\n /* A copy of output_addr_const modified for pdp11 expression syntax.\n    output_addr_const also gets called for %cDIGIT and %nDIGIT, which we don't\n    use, and for debugging output, which we don't support with this port either.\n@@ -1751,7 +1864,7 @@ pdp11_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n      ac0 if DFmode and FPU present - compatibility problem with\n      libraries for non-floating point....  */\n   return (TYPE_MODE (type) == DImode\n-\t  || (TYPE_MODE (type) == DFmode && ! TARGET_AC0));\n+\t  || (FLOAT_MODE_P (TYPE_MODE (type)) && ! TARGET_AC0));\n }\n \n /* Worker function for TARGET_FUNCTION_VALUE.\n@@ -1854,3 +1967,5 @@ pdp11_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t   ? GET_MODE_SIZE (mode)\n \t   : int_size_in_bytes (type));\n }\n+\n+struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "08b9d675cdea0af18ca54f7b1d147de054b0de0d", "filename": "gcc/config/pdp11/pdp11.h", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01c666cc6107021427499f6b4f1adf0c7869a89/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01c666cc6107021427499f6b4f1adf0c7869a89/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=a01c666cc6107021427499f6b4f1adf0c7869a89", "patch": "@@ -215,15 +215,19 @@ extern const struct real_format pdp11_d_format;\n     \n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-   On the pdp, the cpu registers can hold any mode - check alignment\n+   On the pdp, the cpu registers can hold any mode other than float\n+   (because otherwise we may end up being asked to move from CPU to FPU\n+   register, which isn't a valid operation on the PDP11).\n+   For CPU registers, check alignment.\n \n-   FPU can only hold DF - simplifies life!\n+   FPU accepts SF and DF but actually holds a DF - simplifies life!\n */\n #define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n (((REGNO) <= PC_REGNUM)?\t\t\t\t\\\n   ((GET_MODE_BITSIZE(MODE) <= 16) \t\t\t\\\n-   || (GET_MODE_BITSIZE(MODE) >= 32 && !((REGNO) & 1)))\t\\\n-  :(MODE) == DFmode)\n+   || (GET_MODE_BITSIZE(MODE) >= 32 &&      \t\t\\\n+       !((REGNO) & 1) && !FLOAT_MODE_P (MODE)))\t\t\\\n+  :FLOAT_MODE_P (MODE))\n     \n \n /* Value is 1 if it is a good idea to tie two pseudo registers\n@@ -322,18 +326,9 @@ enum reg_class { NO_REGS, MUL_REGS, GENERAL_REGS, LOAD_FPU_REGS, NO_LOAD_FPU_REG\n \n #define IRA_COVER_CLASSES { GENERAL_REGS, FPU_REGS, LIM_REG_CLASSES }\n \n-/* Given an rtx X being reloaded into a reg required to be\n-   in class CLASS, return the class of reg to actually use.\n-   In general this is just CLASS; but on some machines\n-   in some cases it is preferable to use a more restrictive class.  \n-\n-loading is easier into LOAD_FPU_REGS than FPU_REGS! */\n-\n-#define PREFERRED_RELOAD_CLASS(X,CLASS) \t\\\n-(((CLASS) != FPU_REGS)?(CLASS):LOAD_FPU_REGS)\n-\n-#define SECONDARY_RELOAD_CLASS(CLASS,MODE,x)\t\\\n-(((CLASS) == NO_LOAD_FPU_REGS && !(REG_P(x) && LOAD_FPU_REG_P(REGNO(x))))?LOAD_FPU_REGS:NO_REGS)\n+/* Hook for testing if memory is needed for moving between registers.  */\n+#define SECONDARY_MEMORY_NEEDED(class1, class2, m) \\\n+  pdp11_secondary_memory_needed (class1, class2, m)\n \n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n@@ -343,6 +338,8 @@ loading is easier into LOAD_FPU_REGS than FPU_REGS! */\n   1\t\t\t\t\t\t\t\t\t\\\n )\n \n+#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS) \\\n+  pdp11_cannot_change_mode_class (FROM, TO, CLASS)\n \f\n /* Stack layout; function entry, exit and calling.  */\n \n@@ -386,7 +383,7 @@ extern int current_first_parm_offset;\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;\n    otherwise, FUNC is 0.  */\n #define BASE_RETURN_VALUE_REG(MODE) \\\n- ((MODE) == DFmode ? 8 : 0) \n+ (FLOAT_MODE_P (MODE) ? AC0_REGNUM : RETVAL_REGNUM) \n \n /* 1 if N is a possible register number for function argument passing.\n    - not used on pdp */\n@@ -674,10 +671,6 @@ extern int may_call_alloca;\n /* #define NO_FUNCTION_CSE */\n \n \f\n-/* cost of moving one register class to another */\n-#define REGISTER_MOVE_COST(MODE, CLASS1, CLASS2) \\\n-  pdp11_register_move_cost (CLASS1, CLASS2)\n-\n /* Tell emit-rtl.c how to initialize special values on a per-function base.  */\n extern struct rtx_def *cc0_reg_rtx;\n "}, {"sha": "ebedf60c566e9741b5188de2f78424955dfb2d32", "filename": "gcc/config/pdp11/pdp11.md", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01c666cc6107021427499f6b4f1adf0c7869a89/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01c666cc6107021427499f6b4f1adf0c7869a89/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.md?ref=a01c666cc6107021427499f6b4f1adf0c7869a89", "patch": "@@ -25,6 +25,7 @@\n (define_constants\n   [\n    ;; Register numbers\n+   (RETVAL_REGNUM     \t  0)\n    (FRAME_POINTER_REGNUM  5)\n    (STACK_POINTER_REGNUM  6)\n    (PC_REGNUM             7)\n@@ -196,7 +197,7 @@\n (define_expand \"cbranchdf4\"\n   [(set (cc0)\n         (compare (match_operand:DF 1 \"general_operand\")\n-\t\t (match_operand:DF 2 \"general_operand\")))\n+\t\t (match_operand:DF 2 \"register_or_const0_operand\")))\n    (set (pc)\n \t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n \t\t       [(cc0) (const_int 0)])\n@@ -318,11 +319,9 @@\n }\"\n   [(set_attr \"length\" \"2,4,4,6\")])\n \n-;; do we have to supply all these moves? e.g. to \n-;; NO_LOAD_FPU_REGs ? \n (define_insn \"movdf\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=a,fR,a,Q,g\")\n-        (match_operand:DF 1 \"general_operand\" \"fFR,a,Q,a,g\"))]\n+  [(set (match_operand:DF 0 \"float_operand\" \"=a,fR,a,Q,g\")\n+        (match_operand:DF 1 \"float_operand\" \"fFR,a,Q,a,g\"))]\n   \"TARGET_FPU\"\n   \"* if (which_alternative ==0 || which_alternative == 2)\n        return \\\"ldd %1, %0\\\";\n@@ -334,11 +333,17 @@\n   [(set_attr \"length\" \"2,2,10,10,32\")])\n \n (define_insn \"movsf\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=g,r,g\")\n-        (match_operand:SF 1 \"general_operand\" \"r,rmF,g\"))]\n+  [(set (match_operand:SF 0 \"float_operand\" \"=a,fR,a,Q,g\")\n+        (match_operand:SF 1 \"float_operand\" \"fFR,a,Q,a,g\"))]\n   \"TARGET_FPU\"\n-  \"* return output_move_double (operands);\"\n-  [(set_attr \"length\" \"16,16,16\")])\n+  \"* if (which_alternative ==0 || which_alternative == 2)\n+       return \\\"{ldcfd|movof} %1, %0\\\";\n+     else if (which_alternative == 1 || which_alternative == 3)\n+       return \\\"{stcdf|movfo} %1, %0\\\";\n+     else \n+       return output_move_double (operands); \"\n+;; just a guess..\n+  [(set_attr \"length\" \"2,2,10,10,16\")])\n \n ;; maybe fiddle a bit with move_ratio, then \n ;; let constraints only accept a register ...\n@@ -386,23 +391,19 @@\n ;;- truncation instructions\n \n (define_insn  \"truncdfsf2\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=r,R,Q\")\n-\t(float_truncate:SF (match_operand:DF 1 \"register_operand\" \"a,a,a\")))]\n+  [(set (match_operand:SF 0 \"general_operand\" \"=f,R,Q\")\n+\t(float_truncate:SF (match_operand:DF 1 \"register_operand\" \"f,a,a\")))]\n   \"TARGET_FPU\"\n   \"* if (which_alternative ==0)\n      {\n-       output_asm_insn(\\\"{stcdf|movfo} %1, -(sp)\\\", operands);\n-       output_asm_insn(\\\"mov (sp)+, %0\\\", operands);\n-       operands[0] = gen_rtx_REG (HImode, REGNO (operands[0])+1);\n-       output_asm_insn(\\\"mov (sp)+, %0\\\", operands);\n        return \\\"\\\";\n      }\n      else if (which_alternative == 1)\n        return \\\"{stcdf|movfo} %1, %0\\\";\n      else \n        return \\\"{stcdf|movfo} %1, %0\\\";\n   \"\n-  [(set_attr \"length\" \"6,2,4\")])\n+  [(set_attr \"length\" \"0,2,4\")])\n \n \n (define_expand \"truncsihi2\"\n@@ -439,14 +440,14 @@\n ;;- sign extension instructions\n \n (define_insn \"extendsfdf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=a,a,a\")\n-\t(float_extend:DF (match_operand:SF 1 \"general_operand\" \"r,R,Q\")))]\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f,a,a\")\n+\t(float_extend:DF (match_operand:SF 1 \"general_operand\" \"f,R,Q\")))]\n   \"TARGET_FPU\"\n   \"@\n-   mov %1, -(sp)\\;{ldcfd|movof} (sp)+,%0\n+   /* nothing */\n    {ldcfd|movof} %1, %0\n    {ldcfd|movof} %1, %0\"\n-  [(set_attr \"length\" \"4,2,4\")])\n+  [(set_attr \"length\" \"0,2,4\")])\n \n ;; does movb sign extend in register-to-register move?\n (define_insn \"extendqihi2\"\n@@ -856,6 +857,7 @@\n }\"\n   [(set_attr \"length\" \"4,8,8,12,4,4,8,6,6,12\")])\n \n+;; FIXME This definition is wrong, PR/41822\n (define_insn \"andhi3\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=rR,rR,Q,Q\")\n \t(and:HI (match_operand:HI 1 \"general_operand\" \"0,0,0,0\")"}, {"sha": "3cdf833a5a14684bdd7ae52c66178ca38c068231", "filename": "gcc/config/pdp11/predicates.md", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01c666cc6107021427499f6b4f1adf0c7869a89/gcc%2Fconfig%2Fpdp11%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01c666cc6107021427499f6b4f1adf0c7869a89/gcc%2Fconfig%2Fpdp11%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpredicates.md?ref=a01c666cc6107021427499f6b4f1adf0c7869a89", "patch": "@@ -35,3 +35,12 @@\n   sh = INTVAL (op);\n   return (abs (sh) > 1 && abs (sh) <= 4);\n })\n+\n+;; Accept anything general-operand accepts, except that registers must\n+;; be FPU registers.\n+(define_predicate \"float_operand\"\n+  (if_then_else (match_code \"reg\")\n+\t\t(ior \n+\t\t (match_test \"REGNO_REG_CLASS (REGNO (op)) == LOAD_FPU_REGS\")\n+\t\t (match_test \"REGNO_REG_CLASS (REGNO (op)) == NO_LOAD_FPU_REGS\"))\n+\t\t(match_test \"general_operand (op, mode)\")))"}]}