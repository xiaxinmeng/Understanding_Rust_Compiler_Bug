{"sha": "e0d514da7ba05dabd279fee99a1ef8f40f098ab0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBkNTE0ZGE3YmEwNWRhYmQyNzlmZWU5OWExZWY4ZjQwZjA5OGFiMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-03-09T04:53:54Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-03-09T04:53:54Z"}, "message": "ipa-inline-analysis.c (check_callers): Check node->can_remove_if_no_direct_calls_and_refs_p.\n\n\n\t* ipa-inline-analysis.c (check_callers): Check\n\tnode->can_remove_if_no_direct_calls_and_refs_p.\n\t(growth_likely_positive): Reorganize to call\n\tcan_remove_if_no_direct_calls_p later.\n\t* cgraph.h (will_be_removed_from_program_if_no_direct_calls_p,\n\twill_be_removed_from_program_if_no_direct_calls_p): Add \n\twill_inline parameter.\n\t* cgraph.c (cgraph_node::can_remove_if_no_direct_calls_p,\n\tcgraph_node::will_be_removed_from_program_if_no_direct_calls_p):\n\tHandle inliner case correctly.\n\nFrom-SVN: r221277", "tree": {"sha": "4d0fa49deb182f96c355f84d405543db33394f5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d0fa49deb182f96c355f84d405543db33394f5d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0d514da7ba05dabd279fee99a1ef8f40f098ab0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0d514da7ba05dabd279fee99a1ef8f40f098ab0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0d514da7ba05dabd279fee99a1ef8f40f098ab0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0d514da7ba05dabd279fee99a1ef8f40f098ab0/comments", "author": null, "committer": null, "parents": [{"sha": "68ca4ac90b7413e7007ae6b08d372205e42bdb7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68ca4ac90b7413e7007ae6b08d372205e42bdb7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68ca4ac90b7413e7007ae6b08d372205e42bdb7d"}], "stats": {"total": 100, "additions": 68, "deletions": 32}, "files": [{"sha": "62b299f0d00fe6e9eaf1eb76c8e6ac27fc969bb7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d514da7ba05dabd279fee99a1ef8f40f098ab0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d514da7ba05dabd279fee99a1ef8f40f098ab0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e0d514da7ba05dabd279fee99a1ef8f40f098ab0", "patch": "@@ -1,3 +1,16 @@\n+2015-03-08  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-inline-analysis.c (check_callers): Check\n+\tnode->can_remove_if_no_direct_calls_and_refs_p.\n+\t(growth_likely_positive): Reorganize to call\n+\tcan_remove_if_no_direct_calls_p later.\n+\t* cgraph.h (will_be_removed_from_program_if_no_direct_calls_p,\n+\twill_be_removed_from_program_if_no_direct_calls_p): Add \n+\twill_inline parameter.\n+\t* cgraph.c (cgraph_node::can_remove_if_no_direct_calls_p,\n+\tcgraph_node::will_be_removed_from_program_if_no_direct_calls_p):\n+\tHandle inliner case correctly.\n+\n 2015-03-09  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n \n \tPR tree-optimization/63743"}, {"sha": "e4d5505d697a57b5862c8172be5eafcc9626eeb8", "filename": "gcc/cgraph.c", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d514da7ba05dabd279fee99a1ef8f40f098ab0/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d514da7ba05dabd279fee99a1ef8f40f098ab0/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=e0d514da7ba05dabd279fee99a1ef8f40f098ab0", "patch": "@@ -2415,7 +2415,7 @@ nonremovable_p (cgraph_node *node, void *)\n    calls to THIS.  */\n \n bool\n-cgraph_node::can_remove_if_no_direct_calls_p (void)\n+cgraph_node::can_remove_if_no_direct_calls_p (bool will_inline)\n {\n   struct ipa_ref *ref;\n \n@@ -2430,6 +2430,9 @@ cgraph_node::can_remove_if_no_direct_calls_p (void)\n       return !call_for_symbol_and_aliases (nonremovable_p, NULL, true);\n     }\n \n+  if (will_inline && address_taken)\n+    return false;\n+\n   /* Otheriwse check if we can remove the symbol itself and then verify\n      that only uses of the comdat groups are direct call to THIS\n      or its aliases.   */\n@@ -2454,12 +2457,16 @@ cgraph_node::can_remove_if_no_direct_calls_p (void)\n       /* If we see different symbol than THIS, be sure to check calls.  */\n       if (next->ultimate_alias_target () != target)\n \tfor (cgraph_edge *e = next->callers; e; e = e->next_caller)\n-\t  if (e->caller->get_comdat_group () != get_comdat_group ())\n+\t  if (e->caller->get_comdat_group () != get_comdat_group ()\n+\t      || will_inline)\n \t    return false;\n \n-      for (int i = 0; next->iterate_referring (i, ref); i++)\n-\tif (ref->referring->get_comdat_group () != get_comdat_group ())\n-\t  return false;\n+      /* If function is not being inlined, we care only about\n+\t references outside of the comdat group.  */\n+      if (!will_inline)\n+        for (int i = 0; next->iterate_referring (i, ref); i++)\n+\t  if (ref->referring->get_comdat_group () != get_comdat_group ())\n+\t    return false;\n     }\n   return true;\n }\n@@ -2479,9 +2486,9 @@ cgraph_node::can_remove_if_no_direct_calls_p (void)\n    linkonce section.  */\n \n bool\n-cgraph_node::will_be_removed_from_program_if_no_direct_calls_p (void)\n+cgraph_node::will_be_removed_from_program_if_no_direct_calls_p\n+\t (bool will_inline)\n {\n-  struct ipa_ref *ref;\n   gcc_assert (!global.inlined_to);\n   if (DECL_EXTERNAL (decl))\n     return true;\n@@ -2496,6 +2503,9 @@ cgraph_node::will_be_removed_from_program_if_no_direct_calls_p (void)\n       if (same_comdat_group && externally_visible)\n \t{\n \t  struct cgraph_node *target = ultimate_alias_target ();\n+\n+\t  if (will_inline && address_taken)\n+\t    return true;\n \t  for (cgraph_node *next = dyn_cast<cgraph_node *> (same_comdat_group);\n \t       next != this;\n \t       next = dyn_cast<cgraph_node *> (next->same_comdat_group))\n@@ -2510,18 +2520,15 @@ cgraph_node::will_be_removed_from_program_if_no_direct_calls_p (void)\n \t\t be sure to check calls.  */\n \t      if (next->ultimate_alias_target () != target)\n \t\tfor (cgraph_edge *e = next->callers; e; e = e->next_caller)\n-\t\t  if (e->caller->get_comdat_group () != get_comdat_group ())\n+\t\t  if (e->caller->get_comdat_group () != get_comdat_group ()\n+\t\t      || will_inline)\n \t\t    return false;\n-\n-\t      for (int i = 0; next->iterate_referring (i, ref); i++)\n-\t\tif (ref->referring->get_comdat_group () != get_comdat_group ())\n-\t\t  return false;\n \t    }\n \t}\n       return true;\n     }\n   else\n-    return can_remove_if_no_direct_calls_p ();\n+    return can_remove_if_no_direct_calls_p (will_inline);\n }\n \n "}, {"sha": "2b96b6bcd06c94e5c9fbc4b153e84c61871cdc3a", "filename": "gcc/cgraph.h", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d514da7ba05dabd279fee99a1ef8f40f098ab0/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d514da7ba05dabd279fee99a1ef8f40f098ab0/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=e0d514da7ba05dabd279fee99a1ef8f40f098ab0", "patch": "@@ -1110,16 +1110,23 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n      all uses of COMDAT function does not make it necessarily disappear from\n      the program unless we are compiling whole program or we do LTO.  In this\n      case we know we win since dynamic linking will not really discard the\n-     linkonce section.  */\n-  bool will_be_removed_from_program_if_no_direct_calls_p (void);\n+     linkonce section.  \n+\n+     If WILL_INLINE is true, assume that function will be inlined into all the\n+     direct calls.  */\n+  bool will_be_removed_from_program_if_no_direct_calls_p\n+\t (bool will_inline = false);\n \n   /* Return true when function can be removed from callgraph\n-     if all direct calls are eliminated.  */\n+     if all direct calls and references are eliminated.  The function does\n+     not take into account comdat groups.  */\n   bool can_remove_if_no_direct_calls_and_refs_p (void);\n \n   /* Return true when function cgraph_node and its aliases can be removed from\n-     callgraph if all direct calls are eliminated.  */\n-  bool can_remove_if_no_direct_calls_p (void);\n+     callgraph if all direct calls are eliminated. \n+     If WILL_INLINE is true, assume that function will be inlined into all the\n+     direct calls.  */\n+  bool can_remove_if_no_direct_calls_p (bool will_inline = false);\n \n   /* Return true when callgraph node is a function with Gimple body defined\n      in current unit.  Functions can also be define externally or they"}, {"sha": "5707f6c9603ea021ac8871eb4e7ace7420489de9", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d514da7ba05dabd279fee99a1ef8f40f098ab0/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d514da7ba05dabd279fee99a1ef8f40f098ab0/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=e0d514da7ba05dabd279fee99a1ef8f40f098ab0", "patch": "@@ -3978,6 +3978,9 @@ check_callers (cgraph_node *node, int *max_callers)\n {\n   ipa_ref *ref;\n \n+  if (!node->can_remove_if_no_direct_calls_and_refs_p ())\n+    return true;\n+\n   for (cgraph_edge *e = node->callers; e; e = e->next_caller)\n     {\n       (*max_callers)--;\n@@ -4007,23 +4010,13 @@ growth_likely_positive (struct cgraph_node *node,\n   struct cgraph_edge *e;\n   gcc_checking_assert (edge_growth > 0);\n \n+  /* First quickly check if NODE is removable at all.  */\n   if (DECL_EXTERNAL (node->decl))\n     return true;\n-  /* Unlike for functions called once, we play unsafe with\n-     COMDATs.  We can allow that since we know functions\n-     in consideration are small (and thus risk is small) and\n-     moreover grow estimates already accounts that COMDAT\n-     functions may or may not disappear when eliminated from\n-     current unit. With good probability making aggressive\n-     choice in all units is going to make overall program\n-     smaller.  */\n-  if (DECL_COMDAT (node->decl))\n-    {\n-      if (!node->can_remove_if_no_direct_calls_p ())\n-\treturn true;\n-    }\n-  else if (!node->will_be_removed_from_program_if_no_direct_calls_p ())\n+  if (!node->can_remove_if_no_direct_calls_and_refs_p ()\n+      || node->address_taken)\n     return true;\n+\n   max_callers = inline_summaries->get (node)->size * 4 / edge_growth + 2;\n \n   for (e = node->callers; e; e = e->next_caller)\n@@ -4039,6 +4032,22 @@ growth_likely_positive (struct cgraph_node *node,\n     if (check_callers (dyn_cast <cgraph_node *> (ref->referring), &max_callers))\n       return true;\n \n+  /* Unlike for functions called once, we play unsafe with\n+     COMDATs.  We can allow that since we know functions\n+     in consideration are small (and thus risk is small) and\n+     moreover grow estimates already accounts that COMDAT\n+     functions may or may not disappear when eliminated from\n+     current unit. With good probability making aggressive\n+     choice in all units is going to make overall program\n+     smaller.  */\n+  if (DECL_COMDAT (node->decl))\n+    {\n+      if (!node->can_remove_if_no_direct_calls_p ())\n+\treturn true;\n+    }\n+  else if (!node->will_be_removed_from_program_if_no_direct_calls_p ())\n+    return true;\n+\n   return estimate_growth (node) > 0;\n }\n "}]}