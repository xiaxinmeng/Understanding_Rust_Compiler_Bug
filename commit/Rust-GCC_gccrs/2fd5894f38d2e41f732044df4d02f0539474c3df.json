{"sha": "2fd5894f38d2e41f732044df4d02f0539474c3df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmZkNTg5NGYzOGQyZTQxZjczMjA0NGRmNGQwMmYwNTM5NDc0YzNkZg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-09-13T10:58:35Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-09-13T10:58:35Z"}, "message": "tree-data-ref.h (known_dependences_p): Move here ...\n\n2013-09-13  Richard Biener  <rguenther@suse.de>\n\n\t* tree-data-ref.h (known_dependences_p): Move here ...\n\t* tree-loop-distribution.c (known_dependences_p): ... from here.\n\t(dump_rdg_component, debug_rdg_component): Remove.\n\t(dump_rdg): Adjust.\n\t(generate_loops_for_partition): Use gimple_uid instead of\n\trelying on matching stmt visit order.\n\t(rdg_build_partitions): Take starting stmt vector.\n\t(ldist_gen): Merge into ...\n\t(distribute_loop): ... this function.  Do not compute starting\n\tvertices vector.\n\t* tree-cfg.c (gimple_duplicate_bb): Copy UID for PHIs.\n\nFrom-SVN: r202561", "tree": {"sha": "5a59db3fcae147aa0e40fd67c31137bb09d6c261", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a59db3fcae147aa0e40fd67c31137bb09d6c261"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2fd5894f38d2e41f732044df4d02f0539474c3df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fd5894f38d2e41f732044df4d02f0539474c3df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fd5894f38d2e41f732044df4d02f0539474c3df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fd5894f38d2e41f732044df4d02f0539474c3df/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "86eb4bd7266d96a6eee4776cab54da2f045a82d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86eb4bd7266d96a6eee4776cab54da2f045a82d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86eb4bd7266d96a6eee4776cab54da2f045a82d8"}], "stats": {"total": 243, "additions": 96, "deletions": 147}, "files": [{"sha": "a219a1a6759583553f077ae1f1fd91e4a6f8bd1d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd5894f38d2e41f732044df4d02f0539474c3df/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd5894f38d2e41f732044df4d02f0539474c3df/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2fd5894f38d2e41f732044df4d02f0539474c3df", "patch": "@@ -1,3 +1,17 @@\n+2013-09-13  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-data-ref.h (known_dependences_p): Move here ...\n+\t* tree-loop-distribution.c (known_dependences_p): ... from here.\n+\t(dump_rdg_component, debug_rdg_component): Remove.\n+\t(dump_rdg): Adjust.\n+\t(generate_loops_for_partition): Use gimple_uid instead of\n+\trelying on matching stmt visit order.\n+\t(rdg_build_partitions): Take starting stmt vector.\n+\t(ldist_gen): Merge into ...\n+\t(distribute_loop): ... this function.  Do not compute starting\n+\tvertices vector.\n+\t* tree-cfg.c (gimple_duplicate_bb): Copy UID for PHIs.\n+\n 2013-09-13  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/arm/arm.md (arm_cmpsi_insn): Split rI alternative."}, {"sha": "42f42a645cc73a22eff671c7b465f9f65f83f762", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd5894f38d2e41f732044df4d02f0539474c3df/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd5894f38d2e41f732044df4d02f0539474c3df/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=2fd5894f38d2e41f732044df4d02f0539474c3df", "patch": "@@ -5563,6 +5563,7 @@ gimple_duplicate_bb (basic_block bb)\n       copy = create_phi_node (NULL_TREE, new_bb);\n       create_new_def_for (gimple_phi_result (phi), copy,\n \t\t\t  gimple_phi_result_ptr (copy));\n+      gimple_set_uid (copy, gimple_uid (phi));\n     }\n \n   gsi_tgt = gsi_start_bb (new_bb);"}, {"sha": "0763382bf8c7f94b8a6221d0548a896a21247696", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd5894f38d2e41f732044df4d02f0539474c3df/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd5894f38d2e41f732044df4d02f0539474c3df/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=2fd5894f38d2e41f732044df4d02f0539474c3df", "patch": "@@ -482,6 +482,21 @@ ddrs_have_anti_deps (vec<ddr_p> dependence_relations)\n   return false;\n }\n \n+/* Returns true when all the dependences are computable.  */\n+\n+inline bool\n+known_dependences_p (vec<ddr_p> dependence_relations)\n+{\n+  ddr_p ddr;\n+  unsigned int i;\n+\n+  FOR_EACH_VEC_ELT (dependence_relations, i, ddr)\n+    if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n+      return false;\n+\n+  return true;\n+}\n+\n /* Returns the dependence level for a vector DIST of size LENGTH.\n    LEVEL = 0 means a lexicographic dependence, i.e. a dependence due\n    to the sequence of statements, not carried by any loop.  */"}, {"sha": "ca3d2ed40f8c3f1558acd3de2cc8707007a6168f", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 66, "deletions": 147, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd5894f38d2e41f732044df4d02f0539474c3df/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd5894f38d2e41f732044df4d02f0539474c3df/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=2fd5894f38d2e41f732044df4d02f0539474c3df", "patch": "@@ -150,52 +150,15 @@ debug_rdg_vertex (struct graph *rdg, int i)\n   dump_rdg_vertex (stderr, rdg, i);\n }\n \n-/* Dump component C of RDG to FILE.  If DUMPED is non-null, set the\n-   dumped vertices to that bitmap.  */\n-\n-static void\n-dump_rdg_component (FILE *file, struct graph *rdg, int c, bitmap dumped)\n-{\n-  int i;\n-\n-  fprintf (file, \"(%d\\n\", c);\n-\n-  for (i = 0; i < rdg->n_vertices; i++)\n-    if (rdg->vertices[i].component == c)\n-      {\n-\tif (dumped)\n-\t  bitmap_set_bit (dumped, i);\n-\n-\tdump_rdg_vertex (file, rdg, i);\n-      }\n-\n-  fprintf (file, \")\\n\");\n-}\n-\n-/* Call dump_rdg_vertex on stderr.  */\n-\n-DEBUG_FUNCTION void\n-debug_rdg_component (struct graph *rdg, int c)\n-{\n-  dump_rdg_component (stderr, rdg, c, NULL);\n-}\n-\n /* Dump the reduced dependence graph RDG to FILE.  */\n \n static void\n dump_rdg (FILE *file, struct graph *rdg)\n {\n-  int i;\n-  bitmap dumped = BITMAP_ALLOC (NULL);\n-\n   fprintf (file, \"(rdg\\n\");\n-\n-  for (i = 0; i < rdg->n_vertices; i++)\n-    if (!bitmap_bit_p (dumped, i))\n-      dump_rdg_component (file, rdg, rdg->vertices[i].component, dumped);\n-\n+  for (int i = 0; i < rdg->n_vertices; i++)\n+    dump_rdg_vertex (file, rdg, i);\n   fprintf (file, \")\\n\");\n-  BITMAP_FREE (dumped);\n }\n \n /* Call dump_rdg on stderr.  */\n@@ -425,11 +388,10 @@ create_rdg_vertices (struct graph *rdg, vec<gimple> stmts, loop_p loop,\n   return true;\n }\n \n-/* Initialize STMTS with all the statements of LOOP.  When\n-   INCLUDE_PHIS is true, include also the PHI nodes.  The order in\n+/* Initialize STMTS with all the statements of LOOP.  The order in\n    which we discover statements is important as\n    generate_loops_for_partition is using the same traversal for\n-   identifying statements. */\n+   identifying statements in loop copies.  */\n \n static void\n stmts_from_loop (struct loop *loop, vec<gimple> *stmts)\n@@ -458,21 +420,6 @@ stmts_from_loop (struct loop *loop, vec<gimple> *stmts)\n   free (bbs);\n }\n \n-/* Returns true when all the dependences are computable.  */\n-\n-static bool\n-known_dependences_p (vec<ddr_p> dependence_relations)\n-{\n-  ddr_p ddr;\n-  unsigned int i;\n-\n-  FOR_EACH_VEC_ELT (dependence_relations, i, ddr)\n-    if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n-      return false;\n-\n-  return true;\n-}\n-\n /* Build the Reduced Dependence Graph (RDG) with one vertex per\n    statement of the loop nest, and one edge per data dependence or\n    scalar dependence.  */\n@@ -693,7 +640,7 @@ static void\n generate_loops_for_partition (struct loop *loop, partition_t partition,\n \t\t\t      bool copy_p)\n {\n-  unsigned i, x;\n+  unsigned i;\n   gimple_stmt_iterator bsi;\n   basic_block *bbs;\n \n@@ -705,53 +652,52 @@ generate_loops_for_partition (struct loop *loop, partition_t partition,\n       create_bb_after_loop (loop);\n     }\n \n-  /* Remove stmts not in the PARTITION bitmap.  The order in which we\n-     visit the phi nodes and the statements is exactly as in\n-     stmts_from_loop.  */\n+  /* Remove stmts not in the PARTITION bitmap.  */\n   bbs = get_loop_body_in_dom_order (loop);\n \n   if (MAY_HAVE_DEBUG_STMTS)\n-    for (x = 0, i = 0; i < loop->num_nodes; i++)\n+    for (i = 0; i < loop->num_nodes; i++)\n       {\n \tbasic_block bb = bbs[i];\n \n \tfor (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n-\t  if (!virtual_operand_p (gimple_phi_result (gsi_stmt (bsi)))\n-\t      && !bitmap_bit_p (partition->stmts, x++))\n-\t    reset_debug_uses (gsi_stmt (bsi));\n+\t  {\n+\t    gimple phi = gsi_stmt (bsi);\n+\t    if (!virtual_operand_p (gimple_phi_result (phi))\n+\t\t&& !bitmap_bit_p (partition->stmts, gimple_uid (phi)))\n+\t      reset_debug_uses (phi);\n+\t  }\n \n \tfor (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n \t  {\n \t    gimple stmt = gsi_stmt (bsi);\n \t    if (gimple_code (stmt) != GIMPLE_LABEL\n \t\t&& !is_gimple_debug (stmt)\n-\t\t&& !bitmap_bit_p (partition->stmts, x++))\n+\t\t&& !bitmap_bit_p (partition->stmts, gimple_uid (stmt)))\n \t      reset_debug_uses (stmt);\n \t  }\n       }\n \n-  for (x = 0, i = 0; i < loop->num_nodes; i++)\n+  for (i = 0; i < loop->num_nodes; i++)\n     {\n       basic_block bb = bbs[i];\n \n       for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi);)\n-\tif (!virtual_operand_p (gimple_phi_result (gsi_stmt (bsi)))\n-\t    && !bitmap_bit_p (partition->stmts, x++))\n-\t  {\n-\t    gimple phi = gsi_stmt (bsi);\n-\t    if (virtual_operand_p (gimple_phi_result (phi)))\n-\t      mark_virtual_phi_result_for_renaming (phi);\n+\t{\n+\t  gimple phi = gsi_stmt (bsi);\n+\t  if (!virtual_operand_p (gimple_phi_result (phi))\n+\t      && !bitmap_bit_p (partition->stmts, gimple_uid (phi)))\n \t    remove_phi_node (&bsi, true);\n-\t  }\n-\telse\n-\t  gsi_next (&bsi);\n+\t  else\n+\t    gsi_next (&bsi);\n+\t}\n \n       for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi);)\n \t{\n \t  gimple stmt = gsi_stmt (bsi);\n \t  if (gimple_code (stmt) != GIMPLE_LABEL\n \t      && !is_gimple_debug (stmt)\n-\t      && !bitmap_bit_p (partition->stmts, x++))\n+\t      && !bitmap_bit_p (partition->stmts, gimple_uid (stmt)))\n \t    {\n \t      unlink_stmt_vdef (stmt);\n \t      gsi_remove (&bsi, true);\n@@ -1372,16 +1318,22 @@ similar_memory_accesses (struct graph *rdg, partition_t partition1,\n \n static void\n rdg_build_partitions (struct graph *rdg,\n-\t\t      vec<int> starting_vertices,\n+\t\t      vec<gimple> starting_stmts,\n \t\t      vec<partition_t> *partitions)\n {\n   bitmap processed = BITMAP_ALLOC (NULL);\n-  int i, v;\n+  int i;\n+  gimple stmt;\n   partition_t partition = partition_alloc (NULL, NULL);\n \n-  FOR_EACH_VEC_ELT (starting_vertices, i, v)\n+  FOR_EACH_VEC_ELT (starting_stmts, i, stmt)\n     {\n       partition_t np;\n+      int v = rdg_vertex_for_stmt (rdg, stmt);\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"ldist asked to generate code for vertex %d\\n\", v);\n \n       if (bitmap_bit_p (processed, v))\n \tcontinue;\n@@ -1504,20 +1456,46 @@ partition_contains_all_rw (struct graph *rdg,\n   return false;\n }\n \n-/* Generate code from STARTING_VERTICES in RDG.  Returns the number of\n-   distributed loops.  */\n+\n+/* Distributes the code from LOOP in such a way that producer\n+   statements are placed before consumer statements.  Tries to separate\n+   only the statements from STMTS into separate loops.\n+   Returns the number of distributed loops.  */\n \n static int\n-ldist_gen (struct loop *loop, struct graph *rdg,\n-\t   vec<int> starting_vertices)\n+distribute_loop (struct loop *loop, vec<gimple> stmts)\n {\n-  int i, nbp;\n+  struct graph *rdg;\n+  vec<loop_p> loop_nest;\n   vec<partition_t> partitions;\n-  partitions.create (3);\n   partition_t partition;\n   bool any_builtin;\n+  int i, nbp;\n \n-  rdg_build_partitions (rdg, starting_vertices, &partitions);\n+  loop_nest.create (3);\n+  if (!find_loop_nest (loop, &loop_nest))\n+    {\n+      loop_nest.release ();\n+      return 0;\n+    }\n+\n+  rdg = build_rdg (loop_nest);\n+  if (!rdg)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"Loop %d not distributed: failed to build the RDG.\\n\",\n+\t\t loop->num);\n+\n+      loop_nest.release ();\n+      return 0;\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    dump_rdg (dump_file, rdg);\n+\n+  partitions.create (3);\n+  rdg_build_partitions (rdg, stmts, &partitions);\n \n   any_builtin = false;\n   FOR_EACH_VEC_ELT (partitions, i, partition)\n@@ -1637,70 +1615,11 @@ ldist_gen (struct loop *loop, struct graph *rdg,\n \n   FOR_EACH_VEC_ELT (partitions, i, partition)\n     partition_free (partition);\n-\n   partitions.release ();\n-  return nbp;\n-}\n-\n-/* Distributes the code from LOOP in such a way that producer\n-   statements are placed before consumer statements.  When STMTS is\n-   NULL, performs the maximal distribution, if STMTS is not NULL,\n-   tries to separate only these statements from the LOOP's body.\n-   Returns the number of distributed loops.  */\n-\n-static int\n-distribute_loop (struct loop *loop, vec<gimple> stmts)\n-{\n-  int res = 0;\n-  struct graph *rdg;\n-  gimple s;\n-  unsigned i;\n-  vec<int> vertices;\n-  vec<loop_p> loop_nest;\n \n-  loop_nest.create (3);\n-  if (!find_loop_nest (loop, &loop_nest))\n-    {\n-      loop_nest.release ();\n-      return 0;\n-    }\n-\n-  rdg = build_rdg (loop_nest);\n-  if (!rdg)\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file,\n-\t\t \"Loop %d not distributed: failed to build the RDG.\\n\",\n-\t\t loop->num);\n-\n-      loop_nest.release ();\n-      return res;\n-    }\n-\n-  vertices.create (3);\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    dump_rdg (dump_file, rdg);\n-\n-  FOR_EACH_VEC_ELT (stmts, i, s)\n-    {\n-      int v = rdg_vertex_for_stmt (rdg, s);\n-\n-      if (v >= 0)\n-\t{\n-\t  vertices.safe_push (v);\n-\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file,\n-\t\t     \"ldist asked to generate code for vertex %d\\n\", v);\n-\t}\n-    }\n-\n-  res = ldist_gen (loop, rdg, vertices);\n-  vertices.release ();\n   free_rdg (rdg);\n   loop_nest.release ();\n-  return res;\n+  return nbp;\n }\n \n /* Distribute all loops in the current function.  */"}]}