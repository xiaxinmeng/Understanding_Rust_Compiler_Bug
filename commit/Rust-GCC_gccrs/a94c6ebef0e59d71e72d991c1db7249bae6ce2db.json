{"sha": "a94c6ebef0e59d71e72d991c1db7249bae6ce2db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTk0YzZlYmVmMGU1OWQ3MWU3MmQ5OTFjMWRiNzI0OWJhZTZjZTJkYg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-04-29T16:42:41Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-04-29T16:42:41Z"}, "message": "Initial revision\n\nFrom-SVN: r19498", "tree": {"sha": "7a3d09ddcb0948c1e4bf1751342ea5dde1643ad7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a3d09ddcb0948c1e4bf1751342ea5dde1643ad7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a94c6ebef0e59d71e72d991c1db7249bae6ce2db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a94c6ebef0e59d71e72d991c1db7249bae6ce2db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a94c6ebef0e59d71e72d991c1db7249bae6ce2db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a94c6ebef0e59d71e72d991c1db7249bae6ce2db/comments", "author": null, "committer": null, "parents": [{"sha": "78acf2e9873a270591794fee027ba8f460dfea08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78acf2e9873a270591794fee027ba8f460dfea08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78acf2e9873a270591794fee027ba8f460dfea08"}], "stats": {"total": 424, "additions": 424, "deletions": 0}, "files": [{"sha": "bca555a610fd1957108b6e6efbb7eb853a250d9d", "filename": "gcc/intl/localealias.c", "status": "added", "additions": 424, "deletions": 0, "changes": 424, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a94c6ebef0e59d71e72d991c1db7249bae6ce2db/gcc%2Fintl%2Flocalealias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a94c6ebef0e59d71e72d991c1db7249bae6ce2db/gcc%2Fintl%2Flocalealias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintl%2Flocalealias.c?ref=a94c6ebef0e59d71e72d991c1db7249bae6ce2db", "patch": "@@ -0,0 +1,424 @@\n+/* Handle aliases for locale names.\n+   Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.\n+   Written by Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1995.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software Foundation,\n+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n+\n+#ifdef HAVE_CONFIG_H\n+# include <config.h>\n+#endif\n+\n+#include <ctype.h>\n+#include <stdio.h>\n+#include <sys/types.h>\n+\n+#ifdef __GNUC__\n+# define alloca __builtin_alloca\n+# define HAVE_ALLOCA 1\n+#else\n+# if defined HAVE_ALLOCA_H || defined _LIBC\n+#  include <alloca.h>\n+# else\n+#  ifdef _AIX\n+ #pragma alloca\n+#  else\n+#   ifndef alloca\n+char *alloca ();\n+#   endif\n+#  endif\n+# endif\n+#endif\n+\n+#if defined STDC_HEADERS || defined _LIBC\n+# include <stdlib.h>\n+#else\n+char *getenv ();\n+# ifdef HAVE_MALLOC_H\n+#  include <malloc.h>\n+# else\n+void free ();\n+# endif\n+#endif\n+\n+#if defined HAVE_STRING_H || defined _LIBC\n+# ifndef _GNU_SOURCE\n+#  define _GNU_SOURCE\t1\n+# endif\n+# include <string.h>\n+#else\n+# include <strings.h>\n+# ifndef memcpy\n+#  define memcpy(Dst, Src, Num) bcopy (Src, Dst, Num)\n+# endif\n+#endif\n+#if !HAVE_STRCHR && !defined _LIBC\n+# ifndef strchr\n+#  define strchr index\n+# endif\n+#endif\n+\n+#include \"gettext.h\"\n+#include \"gettextP.h\"\n+\n+/* @@ end of prolog @@ */\n+\n+#ifdef _LIBC\n+/* Rename the non ANSI C functions.  This is required by the standard\n+   because some ANSI C functions will require linking with this object\n+   file and the name space must not be polluted.  */\n+# define strcasecmp __strcasecmp\n+\n+# define mempcpy __mempcpy\n+# define HAVE_MEMPCPY\t1\n+\n+/* We need locking here since we can be called from different places.  */\n+# include <bits/libc-lock.h>\n+\n+__libc_lock_define_initialized (static, lock);\n+#endif\n+\n+\n+/* For those loosing systems which don't have `alloca' we have to add\n+   some additional code emulating it.  */\n+#ifdef HAVE_ALLOCA\n+/* Nothing has to be done.  */\n+# define ADD_BLOCK(list, address) /* nothing */\n+# define FREE_BLOCKS(list) /* nothing */\n+#else\n+struct block_list\n+{\n+  void *address;\n+  struct block_list *next;\n+};\n+# define ADD_BLOCK(list, addr)\t\t\t\t\t\t      \\\n+  do {\t\t\t\t\t\t\t\t\t      \\\n+    struct block_list *newp = (struct block_list *) malloc (sizeof (*newp));  \\\n+    /* If we cannot get a free block we cannot add the new element to\t      \\\n+       the list.  */\t\t\t\t\t\t\t      \\\n+    if (newp != NULL) {\t\t\t\t\t\t\t      \\\n+      newp->address = (addr);\t\t\t\t\t\t      \\\n+      newp->next = (list);\t\t\t\t\t\t      \\\n+      (list) = newp;\t\t\t\t\t\t\t      \\\n+    }\t\t\t\t\t\t\t\t\t      \\\n+  } while (0)\n+# define FREE_BLOCKS(list)\t\t\t\t\t\t      \\\n+  do {\t\t\t\t\t\t\t\t\t      \\\n+    while (list != NULL) {\t\t\t\t\t\t      \\\n+      struct block_list *old = list;\t\t\t\t\t      \\\n+      list = list->next;\t\t\t\t\t\t      \\\n+      free (old);\t\t\t\t\t\t\t      \\\n+    }\t\t\t\t\t\t\t\t\t      \\\n+  } while (0)\n+# undef alloca\n+# define alloca(size) (malloc (size))\n+#endif\t/* have alloca */\n+\n+\n+struct alias_map\n+{\n+  const char *alias;\n+  const char *value;\n+};\n+\n+\n+static char *string_space = NULL;\n+static size_t string_space_act = 0;\n+static size_t string_space_max = 0;\n+static struct alias_map *map;\n+static size_t nmap = 0;\n+static size_t maxmap = 0;\n+\n+\n+/* Prototypes for local functions.  */\n+static size_t read_alias_file PARAMS ((const char *fname, int fname_len))\n+     internal_function;\n+static void extend_alias_table PARAMS ((void));\n+static int alias_compare PARAMS ((const struct alias_map *map1,\n+\t\t\t\t  const struct alias_map *map2));\n+\n+\n+const char *\n+_nl_expand_alias (name)\n+    const char *name;\n+{\n+  static const char *locale_alias_path = LOCALE_ALIAS_PATH;\n+  struct alias_map *retval;\n+  const char *result = NULL;\n+  size_t added;\n+\n+#ifdef _LIBC\n+  __libc_lock_lock (lock);\n+#endif\n+\n+  do\n+    {\n+      struct alias_map item;\n+\n+      item.alias = name;\n+\n+      if (nmap > 0)\n+\tretval = (struct alias_map *) bsearch (&item, map, nmap,\n+\t\t\t\t\t       sizeof (struct alias_map),\n+\t\t\t\t\t       (int (*) PARAMS ((const void *,\n+\t\t\t\t\t\t\t\t const void *))\n+\t\t\t\t\t\t) alias_compare);\n+      else\n+\tretval = NULL;\n+\n+      /* We really found an alias.  Return the value.  */\n+      if (retval != NULL)\n+\t{\n+\t  result = retval->value;\n+\t  break;\n+\t}\n+\n+      /* Perhaps we can find another alias file.  */\n+      added = 0;\n+      while (added == 0 && locale_alias_path[0] != '\\0')\n+\t{\n+\t  const char *start;\n+\n+\t  while (locale_alias_path[0] == ':')\n+\t    ++locale_alias_path;\n+\t  start = locale_alias_path;\n+\n+\t  while (locale_alias_path[0] != '\\0' && locale_alias_path[0] != ':')\n+\t    ++locale_alias_path;\n+\n+\t  if (start < locale_alias_path)\n+\t    added = read_alias_file (start, locale_alias_path - start);\n+\t}\n+    }\n+  while (added != 0);\n+\n+#ifdef _LIBC\n+  __libc_lock_unlock (lock);\n+#endif\n+\n+  return result;\n+}\n+\n+\n+static size_t\n+internal_function\n+read_alias_file (fname, fname_len)\n+     const char *fname;\n+     int fname_len;\n+{\n+#ifndef HAVE_ALLOCA\n+  struct block_list *block_list = NULL;\n+#endif\n+  FILE *fp;\n+  char *full_fname;\n+  size_t added;\n+  static const char aliasfile[] = \"/locale.alias\";\n+\n+  full_fname = (char *) alloca (fname_len + sizeof aliasfile);\n+  ADD_BLOCK (block_list, full_fname);\n+#ifdef HAVE_MEMPCPY\n+  mempcpy (mempcpy (full_fname, fname, fname_len),\n+\t   aliasfile, sizeof aliasfile);\n+#else\n+  memcpy (full_fname, fname, fname_len);\n+  memcpy (&full_fname[fname_len], aliasfile, sizeof aliasfile);\n+#endif\n+\n+  fp = fopen (full_fname, \"r\");\n+  if (fp == NULL)\n+    {\n+      FREE_BLOCKS (block_list);\n+      return 0;\n+    }\n+\n+  added = 0;\n+  while (!feof (fp))\n+    {\n+      /* It is a reasonable approach to use a fix buffer here because\n+\t a) we are only interested in the first two fields\n+\t b) these fields must be usable as file names and so must not\n+\t    be that long\n+       */\n+      unsigned char buf[BUFSIZ];\n+      unsigned char *alias;\n+      unsigned char *value;\n+      unsigned char *cp;\n+\n+      if (fgets (buf, sizeof buf, fp) == NULL)\n+\t/* EOF reached.  */\n+\tbreak;\n+\n+      /* Possibly not the whole line fits into the buffer.  Ignore\n+\t the rest of the line.  */\n+      if (strchr (buf, '\\n') == NULL)\n+\t{\n+\t  char altbuf[BUFSIZ];\n+\t  do\n+\t    if (fgets (altbuf, sizeof altbuf, fp) == NULL)\n+\t      /* Make sure the inner loop will be left.  The outer loop\n+\t\t will exit at the `feof' test.  */\n+\t      break;\n+\t  while (strchr (altbuf, '\\n') == NULL);\n+\t}\n+\n+      cp = buf;\n+      /* Ignore leading white space.  */\n+      while (isspace (cp[0]))\n+\t++cp;\n+\n+      /* A leading '#' signals a comment line.  */\n+      if (cp[0] != '\\0' && cp[0] != '#')\n+\t{\n+\t  alias = cp++;\n+\t  while (cp[0] != '\\0' && !isspace (cp[0]))\n+\t    ++cp;\n+\t  /* Terminate alias name.  */\n+\t  if (cp[0] != '\\0')\n+\t    *cp++ = '\\0';\n+\n+\t  /* Now look for the beginning of the value.  */\n+\t  while (isspace (cp[0]))\n+\t    ++cp;\n+\n+\t  if (cp[0] != '\\0')\n+\t    {\n+\t      size_t alias_len;\n+\t      size_t value_len;\n+\n+\t      value = cp++;\n+\t      while (cp[0] != '\\0' && !isspace (cp[0]))\n+\t\t++cp;\n+\t      /* Terminate value.  */\n+\t      if (cp[0] == '\\n')\n+\t\t{\n+\t\t  /* This has to be done to make the following test\n+\t\t     for the end of line possible.  We are looking for\n+\t\t     the terminating '\\n' which do not overwrite here.  */\n+\t\t  *cp++ = '\\0';\n+\t\t  *cp = '\\n';\n+\t\t}\n+\t      else if (cp[0] != '\\0')\n+\t\t*cp++ = '\\0';\n+\n+\t      if (nmap >= maxmap)\n+\t\textend_alias_table ();\n+\n+\t      alias_len = strlen (alias) + 1;\n+\t      value_len = strlen (value) + 1;\n+\n+\t      if (string_space_act + alias_len + value_len > string_space_max)\n+\t\t{\n+\t\t  /* Increase size of memory pool.  */\n+\t\t  size_t new_size = (string_space_max\n+\t\t\t\t     + (alias_len + value_len > 1024\n+\t\t\t\t\t? alias_len + value_len : 1024));\n+\t\t  char *new_pool = (char *) realloc (string_space, new_size);\n+\t\t  if (new_pool == NULL)\n+\t\t    {\n+\t\t      FREE_BLOCKS (block_list);\n+\t\t      return added;\n+\t\t    }\n+\t\t  string_space = new_pool;\n+\t\t  string_space_max = new_size;\n+\t\t}\n+\n+\t      map[nmap].alias = memcpy (&string_space[string_space_act],\n+\t\t\t\t\talias, alias_len);\n+\t      string_space_act += alias_len;\n+\n+\t      map[nmap].value = memcpy (&string_space[string_space_act],\n+\t\t\t\t\tvalue, value_len);\n+\t      string_space_act += value_len;\n+\n+\t      ++nmap;\n+\t      ++added;\n+\t    }\n+\t}\n+    }\n+\n+  /* Should we test for ferror()?  I think we have to silently ignore\n+     errors.  --drepper  */\n+  fclose (fp);\n+\n+  if (added > 0)\n+    qsort (map, nmap, sizeof (struct alias_map),\n+\t   (int (*) PARAMS ((const void *, const void *))) alias_compare);\n+\n+  FREE_BLOCKS (block_list);\n+  return added;\n+}\n+\n+\n+static void\n+extend_alias_table ()\n+{\n+  size_t new_size;\n+  struct alias_map *new_map;\n+\n+  new_size = maxmap == 0 ? 100 : 2 * maxmap;\n+  new_map = (struct alias_map *) realloc (map, (new_size\n+\t\t\t\t\t\t* sizeof (struct alias_map)));\n+  if (new_map == NULL)\n+    /* Simply don't extend: we don't have any more core.  */\n+    return;\n+\n+  map = new_map;\n+  maxmap = new_size;\n+}\n+\n+\n+#ifdef _LIBC\n+static void __attribute__ ((unused))\n+free_mem (void)\n+{\n+  if (string_space != NULL)\n+    free (string_space);\n+  if (map != NULL)\n+    free (map);\n+}\n+text_set_element (__libc_subfreeres, free_mem);\n+#endif\n+\n+\n+static int\n+alias_compare (map1, map2)\n+     const struct alias_map *map1;\n+     const struct alias_map *map2;\n+{\n+#if defined _LIBC || defined HAVE_STRCASECMP\n+  return strcasecmp (map1->alias, map2->alias);\n+#else\n+  const unsigned char *p1 = (const unsigned char *) map1->alias;\n+  const unsigned char *p2 = (const unsigned char *) map2->alias;\n+  unsigned char c1, c2;\n+\n+  if (p1 == p2)\n+    return 0;\n+\n+  do\n+    {\n+      /* I know this seems to be odd but the tolower() function in\n+\t some systems libc cannot handle nonalpha characters.  */\n+      c1 = isupper (*p1) ? tolower (*p1) : *p1;\n+      c2 = isupper (*p2) ? tolower (*p2) : *p2;\n+      if (c1 == '\\0')\n+\tbreak;\n+      ++p1;\n+      ++p2;\n+    }\n+  while (c1 == c2);\n+\n+  return c1 - c2;\n+#endif\n+}"}]}