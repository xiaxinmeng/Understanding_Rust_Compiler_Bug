{"sha": "541f7d56299fdc8028f38413dce2fd70bc5a3709", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQxZjdkNTYyOTlmZGM4MDI4ZjM4NDEzZGNlMmZkNzBiYzVhMzcwOQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.co.uk", "date": "2000-10-27T20:58:57Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-10-27T20:58:57Z"}, "message": "regrename.c: Rewrite to handle multi-register modes and cond_exec instructions.\n\n        * regrename.c: Rewrite to handle multi-register modes and\n        cond_exec instructions.\n        * Makefile.in (regrename.o): Update dependancies.\n        * recog.h (struct operand_alternative): Add is_address.\n        * recog.c (preprocess_constraints) [case 'p']: Set it.\n\nCo-Authored-By: Richard Henderson <rth@redhat.com>\n\nFrom-SVN: r37089", "tree": {"sha": "8a907a9f427742d19f91e7123d2688bf3860545d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a907a9f427742d19f91e7123d2688bf3860545d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/541f7d56299fdc8028f38413dce2fd70bc5a3709", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/541f7d56299fdc8028f38413dce2fd70bc5a3709", "html_url": "https://github.com/Rust-GCC/gccrs/commit/541f7d56299fdc8028f38413dce2fd70bc5a3709", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/541f7d56299fdc8028f38413dce2fd70bc5a3709/comments", "author": null, "committer": null, "parents": [{"sha": "b8dad04b688e9cb9c34b0c0beba09fd0dc626389", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8dad04b688e9cb9c34b0c0beba09fd0dc626389", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8dad04b688e9cb9c34b0c0beba09fd0dc626389"}], "stats": {"total": 1569, "additions": 659, "deletions": 910}, "files": [{"sha": "fbb52e6772febbf45381273e548f6f5758704d0e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/541f7d56299fdc8028f38413dce2fd70bc5a3709/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/541f7d56299fdc8028f38413dce2fd70bc5a3709/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=541f7d56299fdc8028f38413dce2fd70bc5a3709", "patch": "@@ -1,3 +1,12 @@\n+2000-10-27  Bernd Schmidt  <bernds@redhat.co.uk>\n+\t    Richard Henderson  <rth@redhat.com>\n+\n+        * regrename.c: Rewrite to handle multi-register modes and\n+        cond_exec instructions.\n+        * Makefile.in (regrename.o): Update dependancies.\n+        * recog.h (struct operand_alternative): Add is_address.\n+        * recog.c (preprocess_constraints) [case 'p']: Set it.\n+\n 2000-10-27  Zack Weinberg  <zack@wolery.stanford.edu>\n \n \t* configure.in: If not NO_MINUS_C_MINUS_O, substitute"}, {"sha": "2ea2ef9b69c50c8b57e1f4a454fc2d595f4c667f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/541f7d56299fdc8028f38413dce2fd70bc5a3709/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/541f7d56299fdc8028f38413dce2fd70bc5a3709/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=541f7d56299fdc8028f38413dce2fd70bc5a3709", "patch": "@@ -1452,9 +1452,9 @@ bb-reorder.o : bb-reorder.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n    insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h \\\n    $(RECOG_H) insn-flags.h function.h except.h $(EXPR_H)\n timevar.o : timevar.c $(CONFIG_H) system.h $(TIMEVAR_H) flags.h intl.h\n-regrename.o : regrename.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n-   insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h \\\n-   $(RECOG_H) function.h resource.h\n+regrename.o : regrename.c $(CONFIG_H) system.h $(RTL_H) insn-config.h \\\n+   $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h $(RECOG_H) function.h \\\n+   resource.h $(OBSTACK_H) flags.h\n ifcvt.o : ifcvt.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) \\\n    flags.h insn-config.h function.h $(RECOG_H) $(BASIC_BLOCK_H) $(EXPR_H) \\\n    output.h"}, {"sha": "9492180ba59cfbf09c4602b000ab341f636321b2", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/541f7d56299fdc8028f38413dce2fd70bc5a3709/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/541f7d56299fdc8028f38413dce2fd70bc5a3709/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=541f7d56299fdc8028f38413dce2fd70bc5a3709", "patch": "@@ -2272,6 +2272,7 @@ preprocess_constraints ()\n \t\t  break;\n \n \t\tcase 'p':\n+\t\t  op_alt[j].is_address = 1;\n \t\t  op_alt[j].class = reg_class_subunion[(int) op_alt[j].class][(int) BASE_REG_CLASS];\n \t\t  break;\n "}, {"sha": "f591da6b3b4673cfe6e8d94e2e59054889202f40", "filename": "gcc/recog.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/541f7d56299fdc8028f38413dce2fd70bc5a3709/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/541f7d56299fdc8028f38413dce2fd70bc5a3709/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=541f7d56299fdc8028f38413dce2fd70bc5a3709", "patch": "@@ -63,6 +63,8 @@ struct operand_alternative\n   unsigned int decmem_ok:1;\n   /* Nonzero if '>' was found in the constraint string.  */\n   unsigned int incmem_ok:1;\n+  /* Nonzero if 'p' was found in the constraint string.  */\n+  unsigned int is_address:1;\n   /* Nonzero if 'X' was found in the constraint string, or if the constraint\n      string for this alternative was empty.  */\n   unsigned int anything_ok:1;"}, {"sha": "0832f0951cd56dc36349cb50c30aac9ae1d3faad", "filename": "gcc/regrename.c", "status": "modified", "additions": 644, "deletions": 907, "changes": 1551, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/541f7d56299fdc8028f38413dce2fd70bc5a3709/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/541f7d56299fdc8028f38413dce2fd70bc5a3709/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=541f7d56299fdc8028f38413dce2fd70bc5a3709", "patch": "@@ -18,1050 +18,787 @@\n    the Free Software Foundation, 59 Temple Place - Suite 330,\n    Boston, MA 02111-1307, USA.  */\n \n+#define REG_OK_STRICT\n+\n #include \"config.h\"\n #include \"system.h\"\n-#include \"tree.h\"\n #include \"rtl.h\"\n-#include \"hard-reg-set.h\"\n-#include \"basic-block.h\"\n+#include \"tm_p.h\"\n #include \"insn-config.h\"\n #include \"regs.h\"\n-#include \"flags.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"reload.h\"\n #include \"output.h\"\n #include \"function.h\"\n #include \"recog.h\"\n-#include \"resource.h\"\n+#include \"flags.h\"\n+#include \"obstack.h\"\n+\n+#define obstack_chunk_alloc xmalloc\n+#define obstack_chunk_free free\n+\n+#ifndef REGNO_MODE_OK_FOR_BASE_P\n+#define REGNO_MODE_OK_FOR_BASE_P(REGNO, MODE) REGNO_OK_FOR_BASE_P (REGNO)\n+#endif\n+\n+#ifndef REG_MODE_OK_FOR_BASE_P\n+#define REG_MODE_OK_FOR_BASE_P(REGNO, MODE) REG_OK_FOR_BASE_P (REGNO)\n+#endif\n \n static const char *const reg_class_names[] = REG_CLASS_NAMES;\n \n-/* ??? Consider a more sparse data structure? */\n-typedef struct def_uses\n-  {\n-    /* high bound of defs and uses */\n-    int high_bound;\n-\n-    /* 1 if insn y defines a reg whose use crosses a call \n-       y is the ordinal position of the insn within the block */\n-    sbitmap require_call_save_reg;\n-\n-    /* REGNO x INSN y  1 if insn y sets reg x */\n-    sbitmap *defs;\n-\n-    /* REGNO x INSN y  The register class for this def */\n-    enum reg_class *def_class;\n-\n-    /* REGNO x INSN y  1 if insn y uses reg x */\n-    sbitmap *uses;\n-\n-    /* REGNO x INSN y  The register class for this use */\n-    enum reg_class *use_class;\n-  }\n-def_uses;\n-\n-#define DU_REG_CLASS(rc,r,high_bound,i) (rc[r * high_bound + i])\n-\n-typedef struct ext_basic_blocks\n-  {\n-    /* n_basic_blocks x n_basic_blocks y  1 if bb y is in extended bb\n-       having entry x */\n-    sbitmap *basic_block;\n-\n-    /* n_basic_blocks x n_basic_blocks y  1 if bb y is an exit block */\n-    sbitmap *exit;\n-  }\n-ext_basic_blocks;\n-\n-#define UID_RUID_HIGH_BOUND 64\n-#define DESTINATION 1\n-#define SOURCE 2\n-\n-static void build_def_use\t\tPARAMS ((int, ext_basic_blocks *,\n-\t\t\t\t\t\t HARD_REG_SET *, def_uses *,\n-\t\t\t\t\t\t sbitmap *));\n-static int replace_reg_in_block\t\tPARAMS ((def_uses *, varray_type *,\n-\t\t\t\t\t\t int, rtx, unsigned int));\n-static int consider_def\t\t\tPARAMS ((rtx, int, def_uses *, int));\n-static int consider_available\t\tPARAMS ((rtx, int, HARD_REG_SET *,\n-\t\t\t\t\t\t int, def_uses *, int));\n-static void rr_replace_reg\t\tPARAMS ((rtx, rtx, int, rtx, int *));\n-static int consider_use\t\t\tPARAMS ((rtx, int, int, int));\n-static int condmove_p\t\t\tPARAMS ((rtx));\n-static void dump_def_use_chain\t\tPARAMS ((HARD_REG_SET *, def_uses *,\n-\t\t\t\t\t\t varray_type *));\n-static void dump_ext_bb_info\t\tPARAMS ((int, ext_basic_blocks *));\n-static void find_ext_basic_blocks\tPARAMS ((ext_basic_blocks *));\n-static void find_one_ext_basic_block\tPARAMS ((int, basic_block, sbitmap *,\n-\t\t\t\t\t\t ext_basic_blocks *));\n-static enum reg_class get_reg_class\tPARAMS ((rtx, rtx, int,\n-\t\t\t\t\t\t enum reg_class));\n-static rtx regno_first_use_in\t\tPARAMS ((unsigned int, rtx));\n-\f\n-void\n-regrename_optimize ()\n+struct du_chain\n {\n-  int b, eb, i, inum, r, rc, replace_ok;\n-  rtx insn;\n-  def_uses du;\n-  ext_basic_blocks ebb;\n+  struct du_chain *next_chain;\n+  struct du_chain *next_use;\n \n-  /* Registers used in a given class */\n-  HARD_REG_SET class_regs;\n-\n-  /* Registers available for use as renaming registers */\n-  HARD_REG_SET avail_regs;\n+  rtx insn;\n+  rtx *loc;\n+  enum reg_class class;\n+  unsigned int need_caller_save_reg:1;\n+};\n \n-  /* Registers used in the block */\n-  HARD_REG_SET regs_used;\n+enum scan_actions\n+{\n+  note_reference,\n+  terminate_all_read,\n+  terminate_overlapping_read,\n+  terminate_write,\n+  terminate_dead,\n+  mark_read,\n+  mark_write\n+};\n+\n+static const char * const scan_actions_name[] =\n+{\n+  \"note_reference\",\n+  \"terminate_all_read\",\n+  \"terminate_overlapping_read\",\n+  \"terminate_write\",\n+  \"terminate_dead\",\n+  \"mark_read\",\n+  \"mark_write\"\n+};\n+\n+static struct obstack rename_obstack;\n+\n+static void do_replace PARAMS ((struct du_chain *, int));\n+static void scan_rtx_reg PARAMS ((rtx, rtx *, enum reg_class,\n+\t\t\t\t  enum scan_actions, enum op_type));\n+static void scan_rtx_address PARAMS ((rtx, rtx *, enum reg_class,\n+\t\t\t\t      enum scan_actions));\n+static void scan_rtx PARAMS ((rtx, rtx *, enum reg_class,\n+\t\t\t      enum scan_actions, enum op_type));\n+static struct du_chain *build_def_use PARAMS ((basic_block, HARD_REG_SET *));\n+static void dump_def_use_chain PARAMS ((struct du_chain *));\n \n-  /* Registers which have been used as renaming registers */\n-  HARD_REG_SET renamed_regs;\n+void\n+regrename_optimize ()\n+{\n+  int b;\n+  char *first_obj;\n \n-  HARD_REG_SET global_live_at_end, global_live_at_start;\n+  gcc_obstack_init (&rename_obstack);\n+  first_obj = (char *) obstack_alloc (&rename_obstack, 0);\n \n-  HARD_REG_SET null_bitmap, tmp_bitmap;\n+  for (b = 0; b < n_basic_blocks; b++)\n+    {\n+      basic_block bb = BASIC_BLOCK (b);\n+      struct du_chain *all_chains = 0;\n+      HARD_REG_SET regs_used;\n+      HARD_REG_SET unavailable;\n+      HARD_REG_SET regs_seen;\n \n-  /* 1 if insn y sets a register which is live at the end of the block */\n-  sbitmap defs_live_exit;\n+      CLEAR_HARD_REG_SET (regs_used);\n+      CLEAR_HARD_REG_SET (unavailable);\n \n-  /* Mapping from insn y (ordinal position in block) to INSN_UID */\n-  varray_type uid_ruid;\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \"\\nBasic block %d:\\n\", b);\n \n-  /* Mapping from insn y (ordinal position in block) to block id */\n-  varray_type uid_rbid;\n+      all_chains = build_def_use (bb, &regs_used);\n \n-  /* Ordinal position in block of defining insn */\n-  int *def_idx;\n+      if (rtl_dump_file)\n+\tdump_def_use_chain (all_chains);\n \n-  VARRAY_RTX_INIT (uid_ruid, UID_RUID_HIGH_BOUND + 1, \"uid_ruid\");\n-  VARRAY_LONG_INIT (uid_rbid, UID_RUID_HIGH_BOUND + 1, \"uid_rbid\");\n+      /* Available registers are not: used in the block, live at the start\n+\t live at the end, a register we've renamed to. */\n+      REG_SET_TO_HARD_REG_SET (unavailable, bb->global_live_at_start);\n+      REG_SET_TO_HARD_REG_SET (regs_seen, bb->global_live_at_end);\n+      IOR_HARD_REG_SET (unavailable, regs_seen);\n+      IOR_HARD_REG_SET (unavailable, regs_used);\n \n-  ebb.basic_block\n-    = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n-  sbitmap_vector_zero (ebb.basic_block, n_basic_blocks);\n-  ebb.exit\n-    = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n-  sbitmap_vector_zero (ebb.exit, n_basic_blocks);\n+      /* Don't clobber traceback for noreturn functions.  */\n+      if (frame_pointer_needed)\n+\t{\n+\t  SET_HARD_REG_BIT (unavailable, FRAME_POINTER_REGNUM);\n+#if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n+\t  SET_HARD_REG_BIT (unavailable, HARD_FRAME_POINTER_REGNUM);\n+#endif\n+\t}\n \n-  find_ext_basic_blocks (&ebb);\n+      CLEAR_HARD_REG_SET (regs_seen);\n+      while (all_chains)\n+\t{\n+\t  int n_uses;\n+\t  struct du_chain *this = all_chains;\n+\t  struct du_chain *tmp, *last;\n+\t  HARD_REG_SET this_unavailable;\n+\t  int reg = REGNO (*this->loc), treg;\n \n-  du.def_class = du.use_class = 0;\n+\t  all_chains = this->next_chain;\n \n-  /* Build uid_ruid and uid_rbid for this extended basic block */\n-  for (b = 0; b < n_basic_blocks; b++)\n-    if (TEST_BIT (ebb.basic_block[b], b))\n-      {\n-\tfor (eb = du.high_bound = 0; eb < n_basic_blocks; eb++)\n-\t  if (TEST_BIT (ebb.basic_block[b], eb))\n+\t  /* Only rename once we've seen the reg more than once.  */\n+\t  if (! TEST_HARD_REG_BIT (regs_seen, reg))\n \t    {\n-\t      basic_block bb = BASIC_BLOCK (eb);\n+\t      SET_HARD_REG_BIT (regs_seen, reg);\n+\t      continue;\n+\t    }\n \n-\t      /* Calculate high bound for uid_ruid and allocate if necessary */\n-\t      for (insn = bb->head;\n-\t\t   insn != NEXT_INSN (bb->end);\n-\t\t   du.high_bound++, insn = NEXT_INSN (insn))\n-\t\t{\n-\t\t  int uid_ruid_high_bound = VARRAY_SIZE (uid_ruid);\n+\t  if (fixed_regs[reg] || global_regs[reg])\n+\t    continue;\n \n-\t\t  if (du.high_bound + 4 >= uid_ruid_high_bound)\n-\t\t    {\n-\t\t      VARRAY_GROW (uid_ruid, uid_ruid_high_bound * 2);\n-\t\t      VARRAY_GROW (uid_rbid, uid_ruid_high_bound * 2);\n-\t\t    }\n+\t  COPY_HARD_REG_SET (this_unavailable, unavailable);\n \n-\t\t  VARRAY_RTX (uid_ruid, du.high_bound) = insn;\n-\t\t  VARRAY_LONG (uid_rbid, du.high_bound) = eb;\n-\t\t}\n+\t  /* Find last entry on chain (which has the need_caller_save bit),\n+\t     count number of uses, and narrow the set of registers we can\n+\t     use for renaming.  */\n+\t  n_uses = 0;\n+\t  for (last = this; last->next_use; last = last->next_use)\n+\t    {\n+\t      n_uses++;\n+\t      IOR_COMPL_HARD_REG_SET (this_unavailable,\n+\t\t\t\t      reg_class_contents[last->class]);\n \t    }\n+\t  if (n_uses < 1)\n+\t    continue;\n \n-\tCLEAR_HARD_REG_SET (null_bitmap);\n-\tCLEAR_HARD_REG_SET (class_regs);\n-\tCLEAR_HARD_REG_SET (regs_used);\n-\tCLEAR_HARD_REG_SET (avail_regs);\n-\tCLEAR_HARD_REG_SET (tmp_bitmap);\n-\tCLEAR_HARD_REG_SET (renamed_regs);\n-\n-\tdu.defs\n-\t  = sbitmap_vector_alloc (FIRST_PSEUDO_REGISTER, du.high_bound + 1);\n-\tsbitmap_vector_zero (du.defs, FIRST_PSEUDO_REGISTER);\n-\tdu.uses\n-\t  = sbitmap_vector_alloc (FIRST_PSEUDO_REGISTER, du.high_bound + 1);\n-\tsbitmap_vector_zero (du.uses, FIRST_PSEUDO_REGISTER);\n-\tdu.require_call_save_reg = sbitmap_alloc (du.high_bound + 1);\n-\tsbitmap_zero (du.require_call_save_reg);\n-\tdefs_live_exit = sbitmap_alloc (du.high_bound + 1);\n-\tsbitmap_zero (defs_live_exit);\n-\n-\tdu.def_class\n-\t  = xrealloc (du.def_class,\n-\t\t      (sizeof (enum reg_class) * FIRST_PSEUDO_REGISTER\n-\t\t       * du.high_bound));\n-\n-\tdu.use_class\n-\t  = xrealloc (du.use_class,\n-\t\t      (sizeof (enum reg_class) * FIRST_PSEUDO_REGISTER\n-\t\t       * du.high_bound));\n-\n-\tbuild_def_use (b, &ebb, &regs_used, &du, &defs_live_exit);\n-\n-\tif (rtl_dump_file)\n-\t  {\n-\t    dump_ext_bb_info (b, &ebb);\n-\t    dump_def_use_chain (&global_live_at_end, &du, &uid_ruid);\n-\t  }\n+\t  IOR_COMPL_HARD_REG_SET (this_unavailable,\n+\t\t\t\t  reg_class_contents[last->class]);\n \n-\t/* Available registers are not: used in the block, live at the start,\n-\t   live at the end, a register we've renamed to. */\n-\t/* ??? The current algorithm is pessimistic for extended basic blocks\n-\t   as it just treats them as a big basic block. */\n-\n-\tCOPY_HARD_REG_SET (tmp_bitmap, regs_used);\n-\tREG_SET_TO_HARD_REG_SET (global_live_at_start,\n-\t\t\t\t BASIC_BLOCK (b)->global_live_at_start);\n-\tIOR_HARD_REG_SET (tmp_bitmap, global_live_at_start);\n-\tfor (eb = 0; eb < n_basic_blocks; eb++)\n-\t  if (TEST_BIT (ebb.basic_block[b], eb))\n+\t  if (last->need_caller_save_reg)\n+\t    IOR_HARD_REG_SET (this_unavailable, call_used_reg_set);\n+\n+\t  /* Now potential_regs is a reasonable approximation, let's\n+\t     have a closer look at each register still in there.  */\n+\t  for (treg = 0; treg < FIRST_PSEUDO_REGISTER; treg++)\n \t    {\n-\t      basic_block bb = BASIC_BLOCK (eb);\n+\t      if (TEST_HARD_REG_BIT (this_unavailable, treg)\n+\t\t  || fixed_regs[treg]\n+\t\t  || global_regs[treg]\n+\t\t  /* Can't use regs which aren't saved by the prologue.  */\n+\t\t  || (! regs_ever_live[treg]\n+\t\t      && ! call_used_regs[treg])\n+#ifdef HARD_REGNO_RENAME_OK\n+\t\t  || ! HARD_REGNO_RENAME_OK (reg, treg)\n+#endif\n+\t\t  )\n+\t\tcontinue;\n \n-\t      REG_SET_TO_HARD_REG_SET (global_live_at_end,\n-\t\t\t\t       bb->global_live_at_end);\n-\t      IOR_HARD_REG_SET (tmp_bitmap, global_live_at_end);\n+\t\t/* See whether it accepts all modes that occur in\n+\t\t   definition and uses.  */\n+\t      for (tmp = this; tmp; tmp = tmp->next_use)\n+\t\tif (! HARD_REGNO_MODE_OK (treg, GET_MODE (*tmp->loc)))\n+\t\t  break;\n+\t      if (! tmp)\n+\t\tbreak;\n \t    }\n \n-\tdef_idx = xcalloc (du.high_bound, sizeof (int));\n-\n-\t/* Only consider registers in this extended block and in this class\n-\t   that are defined more than once.  Replace them if permissible. */\n-\tfor (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n-\t  {\n-\t    int avail_reg, ar_idx, def, def_cnt = 0, use_idx, call_idx;\n-\n-\t    if (!TEST_HARD_REG_BIT (regs_used, r)\n-\t\t|| fixed_regs[r]\n-\t\t|| r == FRAME_POINTER_REGNUM)\n-\t      continue;\n-\n-\t    /* Find def_idx[N] where hbound of N is the number of \n-\t       definitions of this register in this block. and def_idx\n-\t       is the ordinal position of this insn in the block. */\n-\t    for (i = 0, def_idx[def_cnt] = 0; i < du.high_bound; i++)\n-\t      if (TEST_BIT (du.defs[r], i)\n-\t\t  && consider_def (VARRAY_RTX (uid_ruid, i), r, &du, i))\n-\t\t{\n-\t\t  int first_use = 1;\n-\t\t  def_idx[def_cnt] = i;\n-\n-\t\t  /* Only consider definitions that have a use. */\n-\t\t  for (use_idx = i + 1; use_idx < du.high_bound; use_idx++)\n-\t\t    {\n-\t\t      if (TEST_BIT (du.uses[r], use_idx))\n-\t\t\t{\n-\t\t\t  if (consider_use (VARRAY_RTX (uid_ruid, use_idx), r,\n-\t\t\t\t\t    VARRAY_LONG (uid_rbid, i),\n-\t\t\t\t\t    VARRAY_LONG (uid_rbid, use_idx)))\n-\t\t\t    {\n-\t\t\t      if (first_use)\n-\t\t\t\t{\n-\t\t\t\t  first_use = 0;\n-\t\t\t\t  def_cnt++;\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t  else\n-\t\t\t    {\n-\t\t\t      /* Don't consider def if we don't want this\n-\t\t\t\t use.  */\n-\t\t\t      if (!first_use)\n-\t\t\t\tdef_cnt--;\n-\n-\t\t\t      break;\n-\t\t\t    }\n-\t\t\t}\n-\n-\t\t      if (TEST_BIT (du.defs[r], use_idx))\n-\t\t\tbreak;\n-\t\t    }\n-\n-\t\t  /* Scan until the next def to avoid renaming\n-\t\t     parameter registers. */\n-\t\t  /* ??? consider using CALL_INSN_FUNCTION_USAGE */\n-\t\t  for (call_idx = i; call_idx <= use_idx; call_idx++)\n-\t\t    if (VARRAY_RTX (uid_ruid, call_idx)\n-\t\t\t&& (GET_CODE (VARRAY_RTX (uid_ruid, call_idx))\n-\t\t\t    == CALL_INSN))\n-\t\t      SET_BIT (du.require_call_save_reg, i);\n-\t\t}\n+\t  if (rtl_dump_file)\n+\t    {\n+\t      fprintf (rtl_dump_file, \"Register %s in insn %d\",\n+\t\t       reg_names[reg], INSN_UID (last->insn));\n+\t      if (last->need_caller_save_reg)\n+\t\tfprintf (rtl_dump_file, \" crosses a call\");\n+\t      }\n \n-\t    if (def_cnt < 2)\n+\t  if (treg == FIRST_PSEUDO_REGISTER)\n+\t    {\n+\t      if (rtl_dump_file)\n+\t\tfprintf (rtl_dump_file, \"; no available registers\\n\");\n \t      continue;\n+\t    }\n \n-\t    /* We have more than one def so rename until we exhaust\n-\t       renaming registers. */\n-\t    /* ??? Should we continue renaming round robin when we exhaust\n-\t       renaming registers? */\n-\t    for (def = 0; def < def_cnt - 1; def++)\n-\t      {\n-\t\tif (!TEST_BIT (defs_live_exit, def_idx[def])\n-\t\t    && (GET_RTX_CLASS\n-\t\t\t(GET_CODE (VARRAY_RTX (uid_ruid,\n-\t\t\t\t\t       def_idx[def]))) == 'i'))\n-\t\t  {\n-\t\t    rtx reg_use\n-\t\t      = regno_first_use_in\n-\t\t\t(r, PATTERN (VARRAY_RTX (uid_ruid, def_idx[def])));\n-\n-\t\t    if (!reg_use)\n-\t\t      break;\n-#ifdef STACK_REGS\n-\t\t    /* Don't bother with stacked float registers */\n-\t\t    if (GET_MODE_CLASS (GET_MODE (reg_use)) == MODE_FLOAT)\n-\t\t      break;\n-#endif\n-\t\t    rc = (int) DU_REG_CLASS (du.def_class,\n-\t\t\t\t\t     r, du.high_bound, def_idx[def]);\n-\t\t    COPY_HARD_REG_SET (avail_regs,\n-\t\t\t\t   reg_class_contents[(enum reg_class) rc]);\n-\t\t    AND_COMPL_HARD_REG_SET (avail_regs, tmp_bitmap);\n-\t\t    AND_COMPL_HARD_REG_SET (avail_regs, renamed_regs);\n-\n-\t\t    /* No available registers in this class */\n-\t\t    GO_IF_HARD_REG_EQUAL (avail_regs, null_bitmap,\n-\t\t\t\t\t  no_available_regs);\n-\n-\t\t    for (ar_idx = 0; ar_idx < FIRST_PSEUDO_REGISTER\n-\t\t\t && TEST_HARD_REG_BIT (avail_regs, ar_idx); ar_idx++)\n-\t\t      ;\n-\n-\t\t    if (ar_idx == FIRST_PSEUDO_REGISTER)\n-\t\t      goto no_available_regs;\n-\n-\t\t    /* Only try register renaming if there is an available\n-\t\t       register in this class. */\n-\t\t    for (ar_idx = 0; ar_idx < FIRST_PSEUDO_REGISTER; ar_idx++)\n-\t\t      {\n-#ifdef REG_ALLOC_ORDER\n-\t\t\tavail_reg = reg_alloc_order[ar_idx];\n-#else\n-\t\t\tavail_reg = ar_idx;\n-#endif\n-\t\t\tif (consider_available (reg_use, avail_reg,\n-\t\t\t\t\t\t&avail_regs, rc, &du,\n-\t\t\t\t\t\tdef_idx[def]))\n-\t\t\t  goto found_avail_reg;\n-\t\t      }\n-\n-\t\t    if (rtl_dump_file)\n-\t\t      {\n-\t\t\tfprintf (rtl_dump_file, \"Register %s in class %s\",\n-\t\t\t\t reg_names[r], reg_class_names[rc]);\n-\t\t\tfprintf (rtl_dump_file, \" in insn %d\",\n-\t\t\t\t INSN_UID (VARRAY_RTX (uid_ruid,\n-\t\t\t\t\t\t       def_idx[def])));\n-\n-\t\t\tif (TEST_BIT (du.require_call_save_reg,\n-\t\t\t\t      def_idx[def]))\n-\t\t\t  fprintf (rtl_dump_file, \" crosses a call\");\n-\n-\t\t\tfprintf (rtl_dump_file, \". No available registers\\n\");\n-\t\t      }\n-\t\t    goto try_next_def;\n-\n-\t\t  found_avail_reg:\n-\t\t    SET_HARD_REG_BIT (renamed_regs, avail_reg);\n-\t\t    CLEAR_HARD_REG_BIT (avail_regs, avail_reg);\n-\n-\t\t    /* Replace in destination.  Replace in source for\n-\t\t       remainder of block until new register is defined\n-\t\t       again */\n-\t\t    replace_ok\n-\t\t      = replace_reg_in_block (&du, &uid_ruid, def_idx[def],\n-\t\t\t\t\t      reg_use, avail_reg);\n-\n-\t\t    /* Replace failed, so restore previous register */\n-\t\t    if (!replace_ok)\n-\t\t      {\n-\t\t\treplace_reg_in_block (&du, &uid_ruid, def_idx[def],\n-\t\t\t\t\t      gen_rtx_REG (GET_MODE (reg_use),\n-\t\t\t\t\t\t\t   avail_reg),\n-\t\t\t\t\t      REGNO (reg_use));\n-\n-\t\t\tif (rtl_dump_file)\n-\t\t\t  {\n-\t\t\t    fprintf (rtl_dump_file,\n-\t\t\t\t     \"Register %s in class %s Renaming as %s \",\n-\t\t\t\t     reg_names[r], reg_class_names[rc],\n-\t\t\t\t     reg_names[avail_reg]);\n-\t\t\t    fprintf (rtl_dump_file,\n-\t\t\t\t     \"would not satisfy constraints\\n\");\n-\t\t\t  }\n-\t\t      }\n-\n-\t\t    else if (rtl_dump_file)\n-\t\t      {\n-\t\t\tfprintf (rtl_dump_file,\n-\t\t\t\t \"Register %s in class %s Renamed as %s \",\n-\t\t\t\t reg_names[r], reg_class_names[rc],\n-\t\t\t\t reg_names[avail_reg]);\n-\t\t\tfprintf (rtl_dump_file, \"at insn %d\\n\",\n-\t\t\t\t INSN_UID (VARRAY_RTX (uid_ruid,\n-\t\t\t\t\t\t       def_idx[def])));\n-\t\t      }\n-\t\t  }\n-\n-\t      try_next_def:\n-\t\tcontinue;\n-\t      }\n+\t  SET_HARD_REG_BIT (unavailable, treg);\n+\t  do_replace (this, treg);\n \n-\t    sbitmap_zero (du.defs[r]);\n+\t  if (rtl_dump_file)\n+\t    fprintf (rtl_dump_file, \", renamed as %s\\n\", reg_names[treg]);\n+\t}\n \n-\t  no_available_regs:\n-\t    continue;\n-\t  }\n+      obstack_free (&rename_obstack, first_obj);\n+    }\n \n-\tfree (def_idx);\n-\tsbitmap_vector_free (du.defs);\n-\tsbitmap_vector_free (du.uses);\n-\tsbitmap_free (du.require_call_save_reg);\n-\tsbitmap_free (defs_live_exit);\n-\tCLEAR_HARD_REG_SET (regs_used);\n-\tCLEAR_HARD_REG_SET (renamed_regs);\n+  obstack_free (&rename_obstack, NULL);\n \n-\tfor (inum = 0; inum < (int) VARRAY_SIZE (uid_ruid); inum++)\n-\t  VARRAY_RTX (uid_ruid, inum) = (rtx) 0;\n-      }\n+  if (rtl_dump_file)\n+    fputc ('\\n', rtl_dump_file);\n \n-  sbitmap_vector_free (ebb.basic_block);\n-  sbitmap_vector_free (ebb.exit);\n+  count_or_remove_death_notes (NULL, 1);\n+  update_life_info (NULL, UPDATE_LIFE_LOCAL,\n+\t\t    PROP_REG_INFO | PROP_DEATH_NOTES);\n }\n \n-/* Build def/use chain DU for extended basic block EBB having root B.\n-   Also determine which regs are used, REGS_USED, and which insns define\n-   a live at exit def, DEFS_LIVE_EXIT */\n-\n static void\n-build_def_use (b, ebb, regs_used, du, defs_live_exit)\n-     int b;\n-     ext_basic_blocks *ebb;\n-     HARD_REG_SET *regs_used;\n-     def_uses *du;\n-     sbitmap *defs_live_exit;\n+do_replace (chain, reg)\n+     struct du_chain *chain;\n+     int reg;\n {\n-  rtx insn;\n-  int eb, inum;\n-  unsigned int r;\n-\n-  inum = 0;\n-  for (eb = 0; eb < n_basic_blocks; eb++)\n+  while (chain)\n     {\n-      basic_block bb = BASIC_BLOCK (eb);\n-\n-      if (!TEST_BIT (ebb->basic_block[b], eb))\n-\tcontinue;\n-\n-      for (insn = bb->head;\n-\t   insn != NEXT_INSN (bb->end);\n-\t   inum++, insn = NEXT_INSN (insn))\n-\t{\n-\t  struct resources insn_res;\n-\t  struct resources insn_sets;\n-\n-\t  if (! INSN_P (insn))\n-\t    continue;\n-\n-\t  CLEAR_RESOURCE (&insn_sets);\n-\t  mark_set_resources (insn, &insn_sets, 0, MARK_DEST);\n-\n-\t  for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n-\t    {\n-\t      if (!TEST_HARD_REG_BIT (insn_sets.regs, r))\n-\t\tcontinue;\n-\n-\t      SET_HARD_REG_BIT (*regs_used, r);\n-\t      if (REGNO_REG_SET_P (bb->global_live_at_end, r))\n-\t\tSET_BIT (*defs_live_exit, inum);\n-\n-\t      if (!insn_sets.memory)\n-\t\tSET_BIT (du->defs[r], inum);\n-\n-\t      DU_REG_CLASS (du->def_class, r, du->high_bound, inum)\n-\t\t= get_reg_class (insn, regno_first_use_in (r, PATTERN (insn)),\n-\t\t\t\t DESTINATION, NO_REGS);\n-\t    }\n-\n-\t  CLEAR_RESOURCE (&insn_res);\n-\t  mark_referenced_resources (insn, &insn_res, 0);\n-\n-\t  for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n-\t    {\n-\t      if (!TEST_HARD_REG_BIT (insn_res.regs, r))\n-\t\tcontinue;\n-\n-\t      SET_HARD_REG_BIT (*regs_used, r);\n-\t      SET_BIT (du->uses[r], inum);\n-\t      DU_REG_CLASS (du->use_class, r, du->high_bound, inum)\n-\t\t= get_reg_class (insn, regno_use_in (r, PATTERN (insn)),\n-\t\t\t\t SOURCE, NO_REGS);\n-\t    }\n-\t}\n+      *chain->loc = gen_rtx_REG (GET_MODE (*chain->loc), reg);\n+      chain = chain->next_use;\n     }\n-\n-  free_resource_info ();\n }\n \n-/* Return nonzero if regno AVAIL_REG can replace REG_DEF for insns in UID_RUID\n-   starting at insn DEF in def/use chain DU. */\n \n-static int\n-replace_reg_in_block (du, uid_ruid, def, reg_def, avail_reg)\n-     def_uses *du;\n-     varray_type *uid_ruid;\n-     int def;\n-     rtx reg_def;\n-     unsigned int avail_reg;\n+static HARD_REG_SET *referenced_regs;\n+static struct du_chain *open_chains;\n+static struct du_chain *closed_chains;\n+\n+static void\n+scan_rtx_reg (insn, loc, class, action, type)\n+     rtx insn;\n+     rtx *loc;\n+     enum reg_class class;\n+     enum scan_actions action;\n+     enum op_type type;\n {\n-  int du_idx, status = 1;\n-  int last_replaced_insn;\n-  unsigned int r = REGNO (reg_def);\n-  rtx death_note;\n-  rtx reg_notes;\n-  rtx reg_use = 0;\n-  rtx new_reg = gen_rtx_REG (GET_MODE (reg_def), avail_reg);\n-\n-  rr_replace_reg (reg_def, new_reg, DESTINATION,\n-\t\t  VARRAY_RTX (*uid_ruid, def), &status);\n-\n-  if (!status)\n-    return status;\n-\n-  death_note = 0;\n-  /* This typically happens if a constraint check failed and the register\n-     changes are being reversed. */\n-  for (reg_notes = REG_NOTES (VARRAY_RTX (*uid_ruid, def));\n-       reg_notes; reg_notes = XEXP (reg_notes, 1))\n+  struct du_chain **p;\n+  rtx x = *loc;\n+  enum machine_mode mode = GET_MODE (x);\n+  int this_regno = REGNO (x);\n+  int this_nregs = HARD_REGNO_NREGS (this_regno, mode);\n+\n+  if (action == note_reference)\n     {\n-      if (REG_NOTE_KIND (reg_notes) == REG_DEAD\n-\t  && REGNO (XEXP (reg_notes, 0)) == avail_reg)\n-\tdeath_note = reg_notes;\n+      while (this_nregs-- > 0)\n+\tSET_HARD_REG_BIT (*referenced_regs, this_regno + this_nregs);\n+      return;\n     }\n \n-  if (death_note)\n-    remove_note (VARRAY_RTX (*uid_ruid, def), death_note);\n-  \n-  /* The old destination is now dead if it is also a source. */\n-  if (regno_use_in (r, PATTERN (VARRAY_RTX (*uid_ruid, def))))\n-    REG_NOTES (VARRAY_RTX (*uid_ruid, def))\n-      = gen_rtx_EXPR_LIST (REG_DEAD, reg_def,\n-\t\t\t   REG_NOTES (VARRAY_RTX (*uid_ruid,\n-\t\t\t\t\t\t  def)));\n-\n-  last_replaced_insn = 0;\n-\n-  /* Now replace in the uses. */\n-  for (du_idx = def + 1; du_idx < du->high_bound; du_idx++)\n+  if (action == mark_write)\n     {\n-      if (! INSN_P (VARRAY_RTX (*uid_ruid, du_idx)))\n-\tcontinue;\n-\n-      reg_use = regno_use_in (r, PATTERN (VARRAY_RTX (*uid_ruid, du_idx)));\n-\n-      if (reg_use && TEST_BIT (du->uses[r], du_idx))\n+      if (type == OP_OUT)\n \t{\n-\t  new_reg = gen_rtx_REG (GET_MODE (reg_use), avail_reg);\n-\t  \n-\t  rr_replace_reg (reg_use, new_reg, SOURCE,\n-\t\t\t  VARRAY_RTX (*uid_ruid, du_idx), &status);\n-\t  death_note = find_reg_note (VARRAY_RTX (*uid_ruid, du_idx),\n-\t\t\t\t      REG_DEAD, reg_use);\n-\t  if (death_note)\n-\t    {\n-\t      REG_NOTES (VARRAY_RTX (*uid_ruid, du_idx))\n-\t\t= gen_rtx_EXPR_LIST (REG_DEAD, new_reg,\n-\t\t\t\t     REG_NOTES (VARRAY_RTX (*uid_ruid,\n-\t\t\t\t\t\t\t    du_idx)));\n-\t      remove_note (VARRAY_RTX (*uid_ruid, du_idx),\n-\t\t\t   find_reg_note (VARRAY_RTX (*uid_ruid, du_idx),\n-\t\t\t\t\t  REG_DEAD, reg_use));\n-\t    }\n-\t}\n-\n-      /* This insn may contain shared rtl replaced in the previous iteration.\n-\t Treat this equivalent to the rr_replace_reg case. */\n-      if (TEST_BIT (du->uses[r], du_idx))\n-\t{\n-\t  last_replaced_insn = du_idx;\n-\t  \n-\t  SET_BIT (du->uses[avail_reg], du_idx);\n-\t  RESET_BIT (du->uses[r], du_idx);\n-\t  if (!status)\n-\t    return status;\n+\t  struct du_chain *this = (struct du_chain *)\n+\t    obstack_alloc (&rename_obstack, sizeof (struct du_chain));\n+\t  this->next_use = 0;\n+\t  this->next_chain = open_chains;\n+\t  this->loc = loc;\n+\t  this->insn = insn;\n+\t  this->class = class;\n+\t  this->need_caller_save_reg = 0;\n+\t  open_chains = this;\n \t}\n-\n-      if (TEST_BIT (du->defs[r], du_idx))\n-\tbreak;\n+      return;\n     }\n \n-  /* Add REG_DEAD note for replaced register at last use. */\n+  if ((type == OP_OUT && action != terminate_write)\n+      || (type != OP_OUT && action == terminate_write))\n+    return;\n \n-  if (last_replaced_insn)\n+  for (p = &open_chains; *p;)\n     {\n-      new_reg = regno_use_in (avail_reg,\n-\t\t\t      PATTERN (VARRAY_RTX (*uid_ruid,\n-\t\t\t\t\t\t   last_replaced_insn)));\n-      if (new_reg\n-\t  && ! find_reg_note (VARRAY_RTX (*uid_ruid, last_replaced_insn),\n-\t\t\t\t      REG_DEAD, new_reg))\n+      struct du_chain *this = *p;\n+      int regno = REGNO (*this->loc);\n+      int nregs = HARD_REGNO_NREGS (regno, GET_MODE (*this->loc));\n+      int exact_match = (regno == this_regno && nregs == this_nregs);\n+\n+      if (regno + nregs <= this_regno\n+\t  || this_regno + this_nregs <= regno)\n+\tp = &this->next_chain;\n+      else if (action == mark_read)\n \t{\n-\t  REG_NOTES (VARRAY_RTX (*uid_ruid, last_replaced_insn))\n-\t    = gen_rtx_EXPR_LIST (REG_DEAD, new_reg,\n-\t\t\t\t REG_NOTES (VARRAY_RTX (*uid_ruid,\n-\t\t\t\t\t\t\tlast_replaced_insn)));\n-\t  remove_note (VARRAY_RTX (*uid_ruid, last_replaced_insn),\n-\t\t       find_reg_note (VARRAY_RTX (*uid_ruid, last_replaced_insn),\n-\t\t\t\t\t    REG_DEAD, reg_use));\n+\t  if (! exact_match)\n+\t    abort ();\n+\t  if (class == NO_REGS)\n+\t    abort ();\n+\n+\t  this = (struct du_chain *)\n+\t    obstack_alloc (&rename_obstack, sizeof (struct du_chain));\n+\t  this->next_use = *p;\n+\t  this->next_chain = (*p)->next_chain;\n+\t  this->loc = loc;\n+\t  this->insn = insn;\n+\t  this->class = class;\n+\t  this->need_caller_save_reg = 0;\n+\t  *p = this;\n+\t  return;\n \t}\n-    }\n+      else if (action != terminate_overlapping_read || ! exact_match)\n+\t{\n+\t  struct du_chain *next = this->next_chain;\n+\n+\t  /* Whether the terminated chain can be used for renaming\n+\t     depends on the action and this being an exact match.\n+\t     In either case, we remove this element from open_chains.  */\n \n-  return status;\n+\t  if ((action == terminate_dead || action == terminate_write)\n+\t      && exact_match)\n+\t    {\n+\t      this->next_chain = closed_chains;\n+\t      closed_chains = this;\n+\t      if (rtl_dump_file)\n+\t\tfprintf (rtl_dump_file,\n+\t\t\t \"Closing chain %s at insn %d (%s)\\n\",\n+\t\t\t reg_names[REGNO (*this->loc)], INSN_UID (insn),\n+\t\t\t scan_actions_name[(int) action]);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (rtl_dump_file)\n+\t\tfprintf (rtl_dump_file,\n+\t\t\t \"Discarding chain %s at insn %d (%s)\\n\",\n+\t\t\t reg_names[REGNO (*this->loc)], INSN_UID (insn),\n+\t\t\t scan_actions_name[(int) action]);\n+\t    }\n+\t  *p = next;\n+\t}\n+      else\n+\tp = &this->next_chain;\n+    }\n }\n \n-/* Try to replace REG_USE in X with REG_SUB if INSN has a REPLACE_TYPE.\n-   STATUS is zero if the resulting pattern is not valid. */\n+/* Adapted from find_reloads_address_1.  CLASS is INDEX_REG_CLASS or\n+   BASE_REG_CLASS depending on how the register is being considered.  */\n \n static void\n-rr_replace_reg (reg_use, reg_sub, replace_type, insn, status)\n-     rtx reg_use;\n-     rtx reg_sub;\n-     int replace_type;\n+scan_rtx_address (insn, loc, class, action)\n      rtx insn;\n-     int *status;\n+     rtx *loc;\n+     enum reg_class class;\n+     enum scan_actions action;\n {\n-  int i;\n-  int changed = 0;\n+  rtx x = *loc;\n+  RTX_CODE code = GET_CODE (x);\n+  const char *fmt;\n+  int i, j;\n \n-  /* We only perform replacements on operands, since everything else\n-     is by definition hard-coded.  Begin by extracting insn information\n-     so that we know where the operands and dups exist.  */\n-  extract_insn (insn);\n+  if (action == mark_write)\n+    return;\n \n-  for (i = recog_data.n_operands - 1; i >= 0; --i)\n+  switch (code)\n     {\n-      rtx op;\n-\n-      /* Match replace_type with operand_type and skip those we aren't\n-\t supposed to touch.  Note that OP_INOUT does _not_ match either\n-\t replace_type.  */\n-      if (replace_type == DESTINATION && recog_data.operand_type[i] != OP_OUT)\n-\tcontinue;\n-      if (replace_type == SOURCE && recog_data.operand_type[i] != OP_IN)\n-\tcontinue;\n+    case PLUS:\n+      {\n+\trtx orig_op0 = XEXP (x, 0);\n+\trtx orig_op1 = XEXP (x, 1);\n+\tRTX_CODE code0 = GET_CODE (orig_op0);\n+\tRTX_CODE code1 = GET_CODE (orig_op1);\n+\trtx op0 = orig_op0;\n+\trtx op1 = orig_op1;\n+\trtx *locI = NULL;\n+\trtx *locB = NULL;\n+\n+\tif (GET_CODE (op0) == SUBREG)\n+\t  {\n+\t    op0 = SUBREG_REG (op0);\n+\t    code0 = GET_CODE (op0);\n+\t  }\n \n-      op = recog_data.operand[i];\n-      if (GET_CODE (op) != REG)\n-\tcontinue;\n+\tif (GET_CODE (op1) == SUBREG)\n+\t  {\n+\t    op1 = SUBREG_REG (op1);\n+\t    code1 = GET_CODE (op1);\n+\t  }\n \n-      if (REGNO (op) == REGNO (reg_use))\n-\t{\n-\t  rtx new = reg_sub;\n-\t  if (GET_MODE (op) != GET_MODE (reg_use))\n-\t    new = gen_rtx_REG (GET_MODE (op), REGNO (reg_sub));\n+\tif (code0 == MULT || code0 == SIGN_EXTEND || code0 == TRUNCATE\n+\t    || code0 == ZERO_EXTEND || code1 == MEM)\n+\t  {\n+\t    locI = &XEXP (x, 0);\n+\t    locB = &XEXP (x, 1);\n+\t  }\n+\telse if (code1 == MULT || code1 == SIGN_EXTEND || code1 == TRUNCATE\n+\t\t || code1 == ZERO_EXTEND || code0 == MEM)\n+\t  {\n+\t    locI = &XEXP (x, 1);\n+\t    locB = &XEXP (x, 0);\n+\t  }\n+\telse if (code0 == CONST_INT || code0 == CONST\n+\t\t || code0 == SYMBOL_REF || code0 == LABEL_REF)\n+\t  locB = &XEXP (x, 1);\n+\telse if (code1 == CONST_INT || code1 == CONST\n+\t\t || code1 == SYMBOL_REF || code1 == LABEL_REF)\n+\t  locB = &XEXP (x, 0);\n+\telse if (code0 == REG && code1 == REG)\n+\t  {\n+\t    int index_op;\n+\n+\t    if (REG_OK_FOR_INDEX_P (op0)\n+\t\t&& REG_MODE_OK_FOR_BASE_P (op1, mode))\n+\t      index_op = 0;\n+\t    else if (REG_OK_FOR_INDEX_P (op1)\n+\t\t     && REG_MODE_OK_FOR_BASE_P (op0, mode))\n+\t      index_op = 1;\n+\t    else if (REG_MODE_OK_FOR_BASE_P (op1, mode))\n+\t      index_op = 0;\n+\t    else if (REG_MODE_OK_FOR_BASE_P (op0, mode))\n+\t      index_op = 1;\n+\t    else if (REG_OK_FOR_INDEX_P (op1))\n+\t      index_op = 1;\n+\t    else\n+\t      index_op = 0;\n+\n+\t    locI = &XEXP (x, index_op);\n+\t    locB = &XEXP (x, !index_op);\n+\t  }\n+\telse if (code0 == REG)\n+\t  {\n+\t    locI = &XEXP (x, 0);\n+\t    locB = &XEXP (x, 1);\n+\t  }\n+\telse if (code1 == REG)\n+\t  {\n+\t    locI = &XEXP (x, 1);\n+\t    locB = &XEXP (x, 0);\n+\t  }\n \n-\t  validate_change (insn, recog_data.operand_loc[i], new, 1);\n-\t  recog_data.operand[i] = new;\n+\tif (locI)\n+\t  scan_rtx_address (insn, locI, INDEX_REG_CLASS, action);\n+\tif (locB)\n+\t  scan_rtx_address (insn, locB, BASE_REG_CLASS, action);\n+\treturn;\n+      }\n \n-\t  changed |= 1 << i;\n-\t}\n-    }\n+    case POST_INC:\n+    case POST_DEC:\n+    case POST_MODIFY:\n+    case PRE_INC:\n+    case PRE_DEC:\n+    case PRE_MODIFY:\n+#ifndef AUTO_INC_DEC\n+      class = NO_REGS;\n+#endif\n+      break;\n \n-  /* Any MATCH_DUP's for changed operands must also be changed.  */\n-  /* ??? This more or less assumes that operand_type is correct, in\n-     that the dup will be of the appropriate replace_type.  */\n-  for (i = recog_data.n_dups - 1; i >= 0; i--)\n-    {\n-      int opno = recog_data.dup_num[i];\n-      if ((changed >> opno) & 1)\n-\tvalidate_change (insn, recog_data.dup_loc[i],\n-\t\t\t recog_data.operand[i], 1);\n-    }\n+    case MEM:\n+      scan_rtx_address (insn, &XEXP (x, 0), BASE_REG_CLASS, action);\n+      return;\n \n-  /* Verify that the changes applied so far result in a recognizable insn.  */\n-  if (! apply_change_group ())\n-    {\n-      *status = 0;\n+    case REG:\n+      scan_rtx_reg (insn, loc, class, action, OP_IN);\n       return;\n-    }\n \n-  /* Verify that there are no other references of the given type to the\n-     register in question.  That is, there are no hard-coded references\n-     to this hard register left in the insn.  */\n-  if (replace_type == DESTINATION)\n-    {\n-      if (reg_set_p (reg_use, insn))\n-\t*status = 0;\n+    default:\n+      break;\n     }\n-  else\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n-      if (reg_referenced_p (reg_use, PATTERN (insn)))\n-\t*status = 0;\n+      if (fmt[i] == 'e')\n+\tscan_rtx_address (insn, &XEXP (x, i), class, action);\n+      else if (fmt[i] == 'E')\n+\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t  scan_rtx_address (insn, &XVECEXP (x, i, j), class, action);\n     }\n }\n \n-/* Can REGNO in INSN be considered for renaming, given def INUM in d/u\n-   chain DU? */\n-\n-static int\n-consider_def (insn, regno, du, inum)\n+static void\n+scan_rtx (insn, loc, class, action, type)\n      rtx insn;\n-     int regno;\n-     def_uses *du ATTRIBUTE_UNUSED;\n-     int inum ATTRIBUTE_UNUSED;\n+     rtx *loc;\n+     enum reg_class class;\n+     enum scan_actions action;\n+     enum op_type type;\n {\n-  /* Don't rename windowed registers across a call */\n-#ifdef INCOMING_REGNO\n-  if (TEST_BIT (du->require_call_save_reg, inum)\n-      && INCOMING_REGNO (regno) != regno)\n-    return 0;\n-#endif\n-\n-  /* Don't consider conditional moves.  Predicate architectures may\n-     use two complementary conditional moves and the regno shouldn't change */\n-  if (condmove_p (insn))\n-    return 0;\n-\n-  /* Don't rename call used registers across a call */\n-  if (!(GET_CODE (insn) == CALL_INSN\n-\t&& TEST_HARD_REG_BIT (call_used_reg_set, regno)))\n-    return 1;\n-  else\n-    return 0;\n-}\n-\n-/* Can the use of REGNO in INSN of block USE_BLOCK be considered for renaming\n-   for a def in def_block? */\n+  const char *fmt;\n+  rtx x = *loc;\n+  enum rtx_code code = GET_CODE (x);\n+  int i, j;\n \n-static int\n-consider_use (insn, regno, def_block, use_block)\n-     rtx insn;\n-     int regno;\n-     int def_block;\n-     int use_block;\n-{\n-  rtx reg_use;\n-  edge e;\n-  basic_block ub = BASIC_BLOCK (use_block);\n-\n-  if (! INSN_P (insn))\n-    return 0;\n-\n-  /* If a use's basic block is different than the def's basic block, \n-     then insure another predecessor does not also define this register */\n-  if (def_block != use_block)\n-    for (e = ub->pred; e; e = e->pred_next)\n-      if (e->src->index != def_block\n-\t  && e->src->index != -1\n-\t  && REGNO_REG_SET_P (BASIC_BLOCK (e->src->index)->global_live_at_end,\n-\t\t\t      regno))\n-\treturn 0;\n-\n-  /* Don't consider conditional moves.  Predicate architectures may\n-     use two complementary conditional moves and the regno shouldn't change */\n-\n-  if (condmove_p (insn))\n-    return 0;\n-\n-  reg_use = regno_first_use_in (regno, PATTERN (insn));\n-  if (reg_use)\n+  code = GET_CODE (x);\n+  switch (code)\n     {\n-      /* Don't consider multi-reg values. */\n-      if (HARD_REGNO_NREGS (regno, GET_MODE (reg_use)) != 1\n-\t  && GET_MODE (reg_use) != CCmode)\n-\treturn 0;\n-\n-      /* Don't consider register if the only use is in a USE */\n-      return ! reg_mentioned_p (gen_rtx_USE (VOIDmode, reg_use),\n-\t\t\t\tPATTERN (insn));\n-    }\n-  else\n-    return 0;\n-}\n-\n-/* Can REG_USE be replaced by regno AVAIL_REG if it is in AVAIL_REGS\n-   and it is in regclass RC, given insn INUM of def/use chain DU? */\n-\n-static int\n-consider_available (reg_use, avail_reg, avail_regs, rc, du, inum)\n-     rtx reg_use;\n-     int avail_reg;\n-     HARD_REG_SET *avail_regs;\n-     int rc;\n-     def_uses *du;\n-     int inum;\n-{\n-  if (!TEST_HARD_REG_BIT (*avail_regs, avail_reg))\n-    return 0;\n-\n-  if (fixed_regs[avail_reg])\n-    return 0;\n+    case CONST:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+    case CC0:\n+    case PC:\n+      return;\n \n-#ifdef HARD_REGNO_RENAME_OK\n-  if (!HARD_REGNO_RENAME_OK (REGNO (reg_use), avail_reg))\n-    return 0;\n-#endif\n+    case REG:\n+      scan_rtx_reg (insn, loc, class, action, type);\n+      return;\n \n-  /* Don't consider windowed leaf registers which will be renamed by\n-     leaf_renumber_regs */\n-#ifdef LEAF_REG_REMAP\n-  if (current_function_uses_only_leaf_regs)\n-    if (LEAF_REG_REMAP (avail_reg) < 0)\n-      return 0;\n-#endif\n+    case MEM:\n+      scan_rtx_address (insn, &XEXP (x, 0), BASE_REG_CLASS, action);\n+      return;\n \n-  /* A register is considered available if it is available at the beginning of\n-     the basic block.  We may want to refine this to when a register becomes\n-     available within the block.  We don't consider multi-reg values. */\n-  /* ??? Consider a representation that would allow multi-reg support? */\n-  if (!TEST_HARD_REG_BIT (reg_class_contents[(enum reg_class) rc], avail_reg)\n-      || !HARD_REGNO_MODE_OK (avail_reg, GET_MODE (reg_use))\n-      || (HARD_REGNO_NREGS (avail_reg, GET_MODE (reg_use)) != 1\n-\t  && GET_MODE (reg_use) != CCmode)\n-      || (call_fixed_regs[avail_reg]\n-#ifdef HARD_REGNO_RENAME_OK\n-\t  && !HARD_REGNO_RENAME_OK (REGNO (reg_use), avail_reg)\n-#endif\n-      )\n-      || (TEST_BIT (du->require_call_save_reg, inum)\n-\t  && (call_used_regs[avail_reg] || call_used_regs[REGNO (reg_use)])))\n-    return 0;\n-\n-  /* If register is a callee-saved register it must be saved in the frame. \n-     call saved registers can not be added to regs_ever_live after reload,\n-     as it would invalidate most elimination offsets */\n-  return regs_ever_live[avail_reg] || call_used_regs[avail_reg];\n-}\n+    case SET:\n+      scan_rtx (insn, &SET_SRC (x), class, action, OP_IN);\n+      scan_rtx (insn, &SET_DEST (x), class, action, OP_OUT);\n+      return;\n \n-/* Return 1 if INSN is a conditional move */\n+    case STRICT_LOW_PART:\n+      scan_rtx (insn, &XEXP (x, 0), class, action, OP_INOUT);\n+      return;\n \n-static int\n-condmove_p (insn)\n-     rtx insn;\n-{\n-  return (GET_CODE (insn) == INSN\n-\t  && GET_CODE (PATTERN (insn)) == SET\n-\t  && GET_CODE (SET_SRC (PATTERN (insn))) == IF_THEN_ELSE);\n-}\n+    case ZERO_EXTRACT:\n+    case SIGN_EXTRACT: \n+      scan_rtx (insn, &XEXP (x, 0), class, action,\n+\t\ttype == OP_IN ? OP_IN : OP_INOUT);\n+      scan_rtx (insn, &XEXP (x, 1), class, action, OP_IN);\n+      scan_rtx (insn, &XEXP (x, 2), class, action, OP_IN);\n+      return;\n \n-/* Searches X for the first reference to REGNO, returning the rtx of the\n-   reference found if any.  Otherwise, returns NULL_RTX.  */\n+    case POST_INC:\n+    case PRE_INC:\n+    case POST_DEC:\n+    case PRE_DEC:\n+    case POST_MODIFY:\n+    case PRE_MODIFY:\n+      /* Should only happen inside MEM.  */\n+      abort ();\n+\n+    case CLOBBER:\n+      scan_rtx (insn, &SET_DEST (x), class, action, OP_OUT);\n+      return;\n \n-static rtx\n-regno_first_use_in (regno, x)\n-     unsigned int regno;\n-     rtx x;\n-{\n-  register const char *fmt;\n-  int i, j;\n-  rtx tem;\n+    case EXPR_LIST:\n+      scan_rtx (insn, &XEXP (x, 0), class, action, type);\n+      if (XEXP (x, 1))\n+\tscan_rtx (insn, &XEXP (x, 1), class, action, type);\n+      return;\n \n-  if (GET_CODE (x) == REG && REGNO (x) == regno)\n-    return x;\n+    default:\n+      break;\n+    }\n \n-  fmt = GET_RTX_FORMAT (GET_CODE (x));\n-  for (i = 0; i <= GET_RTX_LENGTH (GET_CODE (x)) - 1; i++)\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\t{\n-\t  if ((tem = regno_first_use_in (regno, XEXP (x, i))))\n-\t    return tem;\n-\t}\n-\n+\tscan_rtx (insn, &XEXP (x, i), class, action, type);\n       else if (fmt[i] == 'E')\n \tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t  if ((tem = regno_first_use_in (regno, XVECEXP (x, i, j))))\n-\t    return tem;\n+\t  scan_rtx (insn, &XVECEXP (x, i, j), class, action, type);\n     }\n-\n-  return 0;\n }\n \n-/* Dump def/use chain DU to RTL_DUMP_FILE, given insns in UID_RUID and\n-   which regs are live at end, GLOBAL_LIVE_AT_END */\n+/* Build def/use chain */\n \n-static void\n-dump_def_use_chain (global_live_at_end, du, uid_ruid)\n-     HARD_REG_SET *global_live_at_end;\n-     def_uses *du;\n-     varray_type *uid_ruid;\n+static struct du_chain *\n+build_def_use (bb, regs_used)\n+     basic_block bb;\n+     HARD_REG_SET *regs_used;\n {\n-  unsigned int r;\n-  int inum;\n-  \n-  for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n-    {\n-      int set = 0;\n+  rtx insn;\n \n-      for (inum = 0; inum <= du->high_bound; inum++)\n-\t{\n-\t  rtx insn = VARRAY_RTX (*uid_ruid, inum);\n-#if 0\n-\t  if (!insn\n-\t      || GET_RTX_CLASS (GET_CODE\n-\t\t\t\t(insn)) != 'i')\n-\t    continue;\n+  open_chains = closed_chains = NULL;\n+  referenced_regs = regs_used;\n \n-\t  reg_use = regno_first_use_in (r, PATTERN (insn));\n-\t  if (!reg_use)\n-\t    continue;\n-#endif\n-\t  if (!set && (TEST_BIT (du->defs[r], inum)\n-\t\t       || TEST_BIT (du->uses[r], inum)))\n+  for (insn = bb->head; ; insn = NEXT_INSN (insn))\n+    {\n+      if (INSN_P (insn))\n+\t{\n+\t  int n_ops;\n+\t  rtx note;\n+\t  rtx old_operands[MAX_RECOG_OPERANDS];\n+\t  rtx old_dups[MAX_DUP_OPERANDS];\n+\t  int i;\n+\t  int alt;\n+\t  int predicated;\n+\n+\t  /* Record all mentioned registers in regs_used.  */\n+\t  scan_rtx (insn, &PATTERN (insn), NO_REGS, note_reference, OP_IN);\n+\n+\t  /* Process the insn, determining its effect on the def-use\n+\t     chains.  We perform the following steps with the register\n+\t     references in the insn:\n+\t     (1) Any read that overlaps an open chain, but doesn't exactly\n+\t         match, causes that chain to be closed.  We can't deal\n+\t         with overlaps yet.\n+\t     (2) Any read outside an operand causes any chain it overlaps\n+\t         with to be closed, since we can't replace it.\n+\t     (3) Any read inside an operand is added if there's already\n+\t         an open chain for it.\n+\t     (4) For any REG_DEAD note we find, close open chains that\n+\t         overlap it.\n+\t     (5) For any write we find, close open chains that overlap it.\n+\t     (6) For any write we find in an operand, make a new chain.\n+\t     (7) For any REG_UNUSED, close any chains we just opened.  */\n+\n+\t  extract_insn (insn);\n+\t  constrain_operands (1);\n+\t  preprocess_constraints ();\n+\t  alt = which_alternative;\n+\t  n_ops = recog_data.n_operands;\n+\n+\t  /* Simplify the code below by rewriting things to reflect\n+\t     matching constraints.  Also promote OP_OUT to OP_INOUT\n+\t     in predicated instructions.  */\n+\n+\t  predicated = GET_CODE (PATTERN (insn)) == COND_EXEC;\n+\t  for (i = 0; i < n_ops; ++i)\n \t    {\n-\t      fprintf (rtl_dump_file, \"Register %s: \", reg_names[r]);\n-\t      if (fixed_regs[r])\n-\t\tfprintf (rtl_dump_file, \"Fixed \");\n-\t      else if (call_fixed_regs[r])\n-\t\tfprintf (rtl_dump_file, \"Call Fixed \");\n-\t      if (TEST_HARD_REG_BIT (*global_live_at_end, r))\n-\t\tfprintf (rtl_dump_file, \"Live at Exit \");\n-\t      set = 1;\n+\t      int matches = recog_op_alt[i][alt].matches;\n+\t      if (matches >= 0)\n+\t\trecog_op_alt[i][alt].class = recog_op_alt[matches][alt].class;\n+\t      if (matches >= 0 || recog_op_alt[i][alt].matched >= 0\n+\t          || (predicated && recog_data.operand_type[i] == OP_OUT))\n+\t\trecog_data.operand_type[i] = OP_INOUT;\n \t    }\n \n-\t  if (TEST_BIT (du->defs[r], inum))\n-\t    fprintf (rtl_dump_file, \"=%d \", INSN_UID (insn));\n-\t  if (TEST_BIT (du->uses[r], inum))\n-\t    fprintf (rtl_dump_file, \"%d \", INSN_UID (insn));\n-\t}\n+\t  /* Step 1: Close chains for which we have overlapping reads.  */\n+\t  for (i = 0; i < n_ops; i++)\n+\t    scan_rtx (insn, recog_data.operand_loc[i],\n+\t\t      NO_REGS, terminate_overlapping_read,\n+\t\t      recog_data.operand_type[i]);\n \n-      if (set)\n-\tfprintf (rtl_dump_file, \"\\n\");\n-    }\n-}\n-\n-/* Dump info for extended basic block EBB having root EB */\n+\t  /* Step 2: Close chains for which we have reads outside operands.\n+\t     We do this by munging all operands into CC0, and closing \n+\t     everything remaining.  */\n \n-static void\n-dump_ext_bb_info (eb, ebb)\n-     int eb;\n-     ext_basic_blocks *ebb;\n-{\n-  int b;\n-  int have_ebb = 0;\n-\n-  for (b = 0; b < n_basic_blocks; b++)\n-    {\n-      if (TEST_BIT (ebb->basic_block[eb], b))\n-\t{\n-\t  if (!have_ebb)\n+\t  for (i = 0; i < n_ops; i++)\n \t    {\n-#ifndef RENAME_EXTENDED_BLOCKS\n-\t      fprintf (rtl_dump_file, \"\\nBasic block %d: \", b);\n-#else\n-\t      fprintf (rtl_dump_file, \"\\nExtended basic block %d: \", b);\n-#endif\n-\t      have_ebb = 1;\n+\t      old_operands[i] = recog_data.operand[i];\n+\t      /* Don't squash match_operator or match_parallel here, since\n+\t\t we don't know that all of the contained registers are \n+\t\t reachable by proper operands.  */\n+\t      if (recog_data.constraints[i][0] == '\\0')\n+\t\tcontinue;\n+\t      *recog_data.operand_loc[i] = cc0_rtx;\n+\t    }\n+\t  for (i = 0; i < recog_data.n_dups; i++)\n+\t    {\n+\t      old_dups[i] = *recog_data.dup_loc[i];\n+\t      *recog_data.dup_loc[i] = cc0_rtx;\n \t    }\n-\t  fprintf (rtl_dump_file, \"%d \", b);\n-\t}\n \n-      if (TEST_BIT (ebb->exit[eb], b))\n-\tfprintf (rtl_dump_file, \"(exit) \");\n-    }\n+\t  scan_rtx (insn, &PATTERN (insn), NO_REGS, terminate_all_read, OP_IN);\n \n-  if (have_ebb)\n-    fprintf (rtl_dump_file, \"\\n\");\n-}\n+\t  for (i = 0; i < recog_data.n_dups; i++)\n+\t    *recog_data.dup_loc[i] = old_dups[i];\n+\t  for (i = 0; i < n_ops; i++)\n+\t    *recog_data.operand_loc[i] = old_operands[i];\n \n-/* Initialize EBB with extended basic block info if RENAME_EXTENDED_BLOCKS is\n-   defined.  Otherwise just use basic blocks */\n+\t  /* Step 2B: Can't rename function call argument registers.  */\n+\t  if (GET_CODE (insn) == CALL_INSN && CALL_INSN_FUNCTION_USAGE (insn))\n+\t    scan_rtx (insn, &CALL_INSN_FUNCTION_USAGE (insn),\n+\t\t      NO_REGS, terminate_all_read, OP_IN);\n \n-static void\n-find_ext_basic_blocks (ebb)\n-     ext_basic_blocks *ebb;\n-{\n-  sbitmap bb_processed;\n-  int b;\n+\t  /* Step 3: Append to chains for reads inside operands.  */\n+\t  for (i = 0; i < n_ops + recog_data.n_dups; i++)\n+\t    {\n+\t      int opn = i < n_ops ? i : recog_data.dup_num[i - n_ops];\n+\t      rtx *loc = (i < n_ops\n+\t\t\t  ? recog_data.operand_loc[opn]\n+\t\t\t  : recog_data.dup_loc[i - n_ops]);\n+\t      enum reg_class class = recog_op_alt[opn][alt].class;\n+\t      enum op_type type = recog_data.operand_type[opn];\n+\n+\t      /* Don't scan match_operand here, since we've no reg class\n+\t\t information to pass down.  Any operands that we could\n+\t\t substitute in will be represented elsewhere.  */\n+\t      if (recog_data.constraints[opn][0] == '\\0')\n+\t\tcontinue;\n \n-  bb_processed = sbitmap_alloc (n_basic_blocks);\n-  sbitmap_zero (bb_processed);\n+\t      if (recog_op_alt[opn][alt].is_address)\n+\t\tscan_rtx_address (insn, loc, class, mark_read);\n+\t      else\n+\t\tscan_rtx (insn, loc, class, mark_read, type);\n+\t    }\n \n-#ifndef RENAME_EXTENDED_BLOCKS\n-  for (b = 0; b < n_basic_blocks; b++)\n-    {\n-      basic_block bb = BASIC_BLOCK (b);\n-      SET_BIT (ebb->basic_block[bb->index], bb->index);\n-    }\n-#else\n-  for (b = 0; b < n_basic_blocks; b++)\n-    {\n+\t  /* Step 4: Close chains for registers that die here.  */\n+\t  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+\t    if (REG_NOTE_KIND (note) == REG_DEAD)\n+\t      scan_rtx (insn, &XEXP (note, 0), NO_REGS, terminate_dead, OP_IN);\n \n-      basic_block bb = BASIC_BLOCK (b);\n-      if (!TEST_BIT (bb_processed, b))\n-\t{\n-\t  find_one_ext_basic_block (bb->index, bb, &bb_processed, ebb);\n-\t}\n-    }\n-#endif\n-  sbitmap_free (bb_processed);\n-}\n+\t  /* Step 4B: If this is a call, any chain live at this point\n+\t     requires a caller-saved reg.  */\n+\t  if (GET_CODE (insn) == CALL_INSN)\n+\t    {\n+\t      struct du_chain *p;\n+\t      for (p = open_chains; p; p = p->next_chain)\n+\t\t{\n+\t\t  struct du_chain *p2;\n+\t\t  for (p2 = p; p2->next_use; p2 = p2->next_use)\n+\t\t    /* nothing */;\n+\t\t  p2->need_caller_save_reg = 1;\n+\t\t}\n+\t    }\n \n-/* Find one extended basic block EBB having root ENTRY containing block\n-   BB */\n+\t  /* Step 5: Close open chains that overlap writes.  Similar to\n+\t     step 2, we hide in-out operands, since we do not want to\n+\t     close these chains.  */\n \n-static void\n-find_one_ext_basic_block (entry, bb, bb_processed, ebb)\n-     int entry;\n-     basic_block bb;\n-     sbitmap *bb_processed;\n-     ext_basic_blocks *ebb;\n-{\n-  edge e;\n+\t  for (i = 0; i < n_ops; i++)\n+\t    {\n+\t      old_operands[i] = recog_data.operand[i];\n+\t      if (recog_data.operand_type[i] == OP_INOUT)\n+\t\t*recog_data.operand_loc[i] = cc0_rtx;\n+\t    }\n+\t  for (i = 0; i < recog_data.n_dups; i++)\n+\t    {\n+\t      int opn = recog_data.dup_num[i];\n+\t      old_dups[i] = *recog_data.dup_loc[i];\n+\t      if (recog_data.operand_type[opn] == OP_INOUT)\n+\t\t*recog_data.dup_loc[i] = cc0_rtx;\n+\t    }\n \n-  if (!TEST_BIT (*bb_processed, bb->index))\n-    {\n-      SET_BIT (ebb->basic_block[entry], bb->index);\n-      SET_BIT (*bb_processed, bb->index);\n-    }\n+\t  scan_rtx (insn, &PATTERN (insn), NO_REGS, terminate_write, OP_IN);\n \n-  for (e = bb->succ; e; e = e->succ_next)\n-    if (!TEST_BIT (*bb_processed, e->dest->index))\n-      {\n-\tif (!e->dest->pred->pred_next\n-\t    && (!TEST_BIT (*bb_processed, e->dest->index)))\n-\t  find_one_ext_basic_block (entry, e->dest, bb_processed, ebb);\n-\telse\n-\t  SET_BIT (ebb->exit[entry], bb->index);\n-      }\n-}\n+\t  for (i = 0; i < recog_data.n_dups; i++)\n+\t    *recog_data.dup_loc[i] = old_dups[i];\n+\t  for (i = 0; i < n_ops; i++)\n+\t    *recog_data.operand_loc[i] = old_operands[i];\n \n-/* Find the register class for register REG_USE having TYPE (DESTINATION or\n-   SOURCE) in INSN.  Use DEFAULT_CLASS if we cannot determine a class. */\n+\t  /* Step 6: Begin new chains for writes inside operands.  */\n+\t  /* ??? Many targets have output constraints on the SET_DEST\n+\t     of a call insn, which is stupid, since these are certainly\n+\t     ABI defined hard registers.  Don't change calls at all.  */\n+\t  if (GET_CODE (insn) != CALL_INSN)\n+\t    for (i = 0; i < n_ops + recog_data.n_dups; i++)\n+\t      {\n+\t\tint opn = i < n_ops ? i : recog_data.dup_num[i - n_ops];\n+\t\trtx *loc = (i < n_ops\n+\t\t\t    ? recog_data.operand_loc[opn]\n+\t\t\t    : recog_data.dup_loc[i - n_ops]);\n+\t\tenum reg_class class = recog_op_alt[opn][alt].class;\n+\n+\t\tif (recog_data.operand_type[opn] == OP_OUT)\n+\t\t  scan_rtx (insn, loc, class, mark_write, OP_OUT);\n+\t      }\n \n-static enum reg_class\n-get_reg_class (insn, reg_use, type, default_class)\n-     rtx insn;\n-     rtx reg_use;\n-     int type;\n-     enum reg_class default_class;\n-{\n-  int alt, id = 0;\n+\t  /* Step 7: Close chains for registers that were never\n+\t     really used here.  */\n+\t  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+\t    if (REG_NOTE_KIND (note) == REG_UNUSED)\n+\t      scan_rtx (insn, &XEXP (note, 0), NO_REGS, terminate_dead, OP_IN);\n+\t}\n+      if (insn == bb->end)\n+\tbreak;\n+    }\n \n-  extract_insn (insn);\n-  constrain_operands (1);\n-  alt = which_alternative;\n+  /* Since we close every chain when we find a REG_DEAD note, anything that\n+     is still open lives past the basic block, so it can't be renamed.  */\n+  return closed_chains;\n+}\n \n-  preprocess_constraints ();\n+/* Dump all def/use chains in CHAINS to RTL_DUMP_FILE.  They are\n+   printed in reverse order as that's how we build them.  */\n \n-  if (type == DESTINATION)\n+static void\n+dump_def_use_chain (chains)\n+     struct du_chain *chains;\n+{\n+  while (chains)\n     {\n-      for (id = 0; id < recog_data.n_operands; id++)\n-\tif (rtx_equal_p (recog_data.operand[id], reg_use))\n-\t  break;\n+      struct du_chain *this = chains;\n+      int r = REGNO (*this->loc);\n+      int nregs = HARD_REGNO_NREGS (r, GET_MODE (*this->loc));\n+      fprintf (rtl_dump_file, \"Register %s (%d):\", reg_names[r], nregs);\n+      while (this)\n+\t{\n+\t  fprintf (rtl_dump_file, \" %d [%s]\", INSN_UID (this->insn),\n+\t\t   reg_class_names[this->class]);\n+\t  this = this->next_use;\n+\t}\n+      fprintf (rtl_dump_file, \"\\n\");\n+      chains = chains->next_chain;\n     }\n-\n-  else if (type == SOURCE)\n-    for (id = recog_data.n_operands - 1; id >= 0; id--)\n-      if (rtx_equal_p (recog_data.operand[id], reg_use))\n-\tbreak;\n-\n-  if (id == -1 || id == recog_data.n_operands)\n-    return default_class;\n-\n-  return recog_op_alt[id][alt].class;\n }"}]}