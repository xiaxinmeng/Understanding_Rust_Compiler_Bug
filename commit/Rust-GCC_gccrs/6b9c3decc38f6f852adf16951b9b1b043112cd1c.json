{"sha": "6b9c3decc38f6f852adf16951b9b1b043112cd1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI5YzNkZWNjMzhmNmY4NTJhZGYxNjk1MWI5YjFiMDQzMTEyY2QxYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:11:42Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:11:42Z"}, "message": "[26/77] Use is_a <scalar_int_mode> in subreg/extract simplifications\n\nThis patch adds is_a <scalar_int_mode> checks to various places that\nwere optimising subregs or extractions in ways that only made sense\nfor scalar integers.  Often the subreg transformations were looking\nfor extends, truncates or shifts and trying to remove the subreg, which\nwouldn't be correct if the SUBREG_REG was a vector rather than a scalar.\n\nThe simplify_binary_operation_1 part also removes a redundant:\n\n  GET_MODE (opleft) == GET_MODE (XEXP (opright, 0))\n\nsince this must be true for:\n\n  (ior A (lshifrt B ...))  A == opleft, B == XEXP (opright, 0)\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* combine.c (find_split_point): Add is_a <scalar_int_mode> checks.\n\t(make_compound_operation_int): Likewise.\n\t(change_zero_ext): Likewise.\n\t* expr.c (convert_move): Likewise.\n\t(convert_modes): Likewise.\n\t* fwprop.c (forward_propagate_subreg): Likewise.\n\t* loop-iv.c (get_biv_step_1): Likewise.\n\t* optabs.c (widen_operand): Likewise.\n\t* postreload.c (move2add_valid_value_p): Likewise.\n\t* recog.c (simplify_while_replacing): Likewise.\n\t* simplify-rtx.c (simplify_unary_operation_1): Likewise.\n\t(simplify_binary_operation_1): Likewise.  Remove redundant\n\tmode equality check.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251478", "tree": {"sha": "e5f94df609e868850d97acfc272b72bc5ed4ed4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5f94df609e868850d97acfc272b72bc5ed4ed4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b9c3decc38f6f852adf16951b9b1b043112cd1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b9c3decc38f6f852adf16951b9b1b043112cd1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b9c3decc38f6f852adf16951b9b1b043112cd1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b9c3decc38f6f852adf16951b9b1b043112cd1c/comments", "author": null, "committer": null, "parents": [{"sha": "7c61657f68cc45bdbbfcfd762dbfd7021f3acb3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c61657f68cc45bdbbfcfd762dbfd7021f3acb3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c61657f68cc45bdbbfcfd762dbfd7021f3acb3f"}], "stats": {"total": 133, "additions": 84, "deletions": 49}, "files": [{"sha": "54a4cf995c42278e803216bf4aa626bab0aaeaba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b9c3decc38f6f852adf16951b9b1b043112cd1c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b9c3decc38f6f852adf16951b9b1b043112cd1c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6b9c3decc38f6f852adf16951b9b1b043112cd1c", "patch": "@@ -1,3 +1,21 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* combine.c (find_split_point): Add is_a <scalar_int_mode> checks.\n+\t(make_compound_operation_int): Likewise.\n+\t(change_zero_ext): Likewise.\n+\t* expr.c (convert_move): Likewise.\n+\t(convert_modes): Likewise.\n+\t* fwprop.c (forward_propagate_subreg): Likewise.\n+\t* loop-iv.c (get_biv_step_1): Likewise.\n+\t* optabs.c (widen_operand): Likewise.\n+\t* postreload.c (move2add_valid_value_p): Likewise.\n+\t* recog.c (simplify_while_replacing): Likewise.\n+\t* simplify-rtx.c (simplify_unary_operation_1): Likewise.\n+\t(simplify_binary_operation_1): Likewise.  Remove redundant\n+\tmode equality check.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "accd2540881ed575c938a5d4405294dfe79b1d98", "filename": "gcc/combine.c", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b9c3decc38f6f852adf16951b9b1b043112cd1c/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b9c3decc38f6f852adf16951b9b1b043112cd1c/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=6b9c3decc38f6f852adf16951b9b1b043112cd1c", "patch": "@@ -4793,7 +4793,7 @@ find_split_point (rtx *loc, rtx_insn *insn, bool set_src)\n   HOST_WIDE_INT pos = 0;\n   int unsignedp = 0;\n   rtx inner = NULL_RTX;\n-  scalar_int_mode inner_mode;\n+  scalar_int_mode mode, inner_mode;\n \n   /* First special-case some codes.  */\n   switch (code)\n@@ -5047,15 +5047,17 @@ find_split_point (rtx *loc, rtx_insn *insn, bool set_src)\n \n \tcase SIGN_EXTRACT:\n \tcase ZERO_EXTRACT:\n-\t  if (CONST_INT_P (XEXP (SET_SRC (x), 1))\n+\t  if (is_a <scalar_int_mode> (GET_MODE (XEXP (SET_SRC (x), 0)),\n+\t\t\t\t      &inner_mode)\n+\t      && CONST_INT_P (XEXP (SET_SRC (x), 1))\n \t      && CONST_INT_P (XEXP (SET_SRC (x), 2)))\n \t    {\n \t      inner = XEXP (SET_SRC (x), 0);\n \t      len = INTVAL (XEXP (SET_SRC (x), 1));\n \t      pos = INTVAL (XEXP (SET_SRC (x), 2));\n \n \t      if (BITS_BIG_ENDIAN)\n-\t\tpos = GET_MODE_PRECISION (GET_MODE (inner)) - len - pos;\n+\t\tpos = GET_MODE_PRECISION (inner_mode) - len - pos;\n \t      unsignedp = (code == ZERO_EXTRACT);\n \t    }\n \t  break;\n@@ -5065,10 +5067,9 @@ find_split_point (rtx *loc, rtx_insn *insn, bool set_src)\n \t}\n \n       if (len && pos >= 0\n-\t  && pos + len <= GET_MODE_PRECISION (GET_MODE (inner)))\n+\t  && pos + len <= GET_MODE_PRECISION (GET_MODE (inner))\n+\t  && is_a <scalar_int_mode> (GET_MODE (SET_SRC (x)), &mode))\n \t{\n-\t  machine_mode mode = GET_MODE (SET_SRC (x));\n-\n \t  /* For unsigned, we have a choice of a shift followed by an\n \t     AND or two shifts.  Use two shifts for field sizes where the\n \t     constant might be too large.  We assume here that we can\n@@ -7846,6 +7847,7 @@ make_compound_operation_int (machine_mode mode, rtx *x_ptr,\n   rtx new_rtx = 0;\n   int i;\n   rtx tem;\n+  scalar_int_mode inner_mode;\n   bool equality_comparison = false;\n \n   if (in_code == EQ)\n@@ -7954,11 +7956,12 @@ make_compound_operation_int (machine_mode mode, rtx *x_ptr,\n       /* Same as previous, but for (subreg (lshiftrt ...)) in first op.  */\n       else if (GET_CODE (XEXP (x, 0)) == SUBREG\n \t       && subreg_lowpart_p (XEXP (x, 0))\n+\t       && is_a <scalar_int_mode> (GET_MODE (SUBREG_REG (XEXP (x, 0))),\n+\t\t\t\t\t  &inner_mode)\n \t       && GET_CODE (SUBREG_REG (XEXP (x, 0))) == LSHIFTRT\n \t       && (i = exact_log2 (UINTVAL (XEXP (x, 1)) + 1)) >= 0)\n \t{\n \t  rtx inner_x0 = SUBREG_REG (XEXP (x, 0));\n-\t  machine_mode inner_mode = GET_MODE (inner_x0);\n \t  new_rtx = make_compound_operation (XEXP (inner_x0, 0), next_code);\n \t  new_rtx = make_extraction (inner_mode, new_rtx, 0,\n \t\t\t\t     XEXP (inner_x0, 1),\n@@ -8148,14 +8151,14 @@ make_compound_operation_int (machine_mode mode, rtx *x_ptr,\n \t/* If the SUBREG is masking of a logical right shift,\n \t   make an extraction.  */\n \tif (GET_CODE (inner) == LSHIFTRT\n+\t    && is_a <scalar_int_mode> (GET_MODE (inner), &inner_mode)\n+\t    && GET_MODE_SIZE (mode) < GET_MODE_SIZE (inner_mode)\n \t    && CONST_INT_P (XEXP (inner, 1))\n-\t    && GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (inner))\n-\t    && (UINTVAL (XEXP (inner, 1))\n-\t\t< GET_MODE_PRECISION (GET_MODE (inner)))\n+\t    && UINTVAL (XEXP (inner, 1)) < GET_MODE_PRECISION (inner_mode)\n \t    && subreg_lowpart_p (x))\n \t  {\n \t    new_rtx = make_compound_operation (XEXP (inner, 0), next_code);\n-\t    int width = GET_MODE_PRECISION (GET_MODE (inner))\n+\t    int width = GET_MODE_PRECISION (inner_mode)\n \t\t\t- INTVAL (XEXP (inner, 1));\n \t    if (width > mode_width)\n \t      width = mode_width;\n@@ -11358,15 +11361,16 @@ change_zero_ext (rtx pat)\n       maybe_swap_commutative_operands (**iter);\n \n   rtx *dst = &SET_DEST (pat);\n+  scalar_int_mode mode;\n   if (GET_CODE (*dst) == ZERO_EXTRACT\n       && REG_P (XEXP (*dst, 0))\n+      && is_a <scalar_int_mode> (GET_MODE (XEXP (*dst, 0)), &mode)\n       && CONST_INT_P (XEXP (*dst, 1))\n       && CONST_INT_P (XEXP (*dst, 2)))\n     {\n       rtx reg = XEXP (*dst, 0);\n       int width = INTVAL (XEXP (*dst, 1));\n       int offset = INTVAL (XEXP (*dst, 2));\n-      machine_mode mode = GET_MODE (reg);\n       int reg_width = GET_MODE_PRECISION (mode);\n       if (BITS_BIG_ENDIAN)\n \toffset = reg_width - width - offset;"}, {"sha": "ce5f42e0ea6f4770f3cfdc864046e2d4a6d3b907", "filename": "gcc/expr.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b9c3decc38f6f852adf16951b9b1b043112cd1c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b9c3decc38f6f852adf16951b9b1b043112cd1c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6b9c3decc38f6f852adf16951b9b1b043112cd1c", "patch": "@@ -239,11 +239,14 @@ convert_move (rtx to, rtx from, int unsignedp)\n      the required extension, strip it.  We don't handle such SUBREGs as\n      TO here.  */\n \n-  if (GET_CODE (from) == SUBREG && SUBREG_PROMOTED_VAR_P (from)\n+  scalar_int_mode to_int_mode;\n+  if (GET_CODE (from) == SUBREG\n+      && SUBREG_PROMOTED_VAR_P (from)\n+      && is_a <scalar_int_mode> (to_mode, &to_int_mode)\n       && (GET_MODE_PRECISION (GET_MODE (SUBREG_REG (from)))\n-\t  >= GET_MODE_PRECISION (to_mode))\n+\t  >= GET_MODE_PRECISION (to_int_mode))\n       && SUBREG_CHECK_PROMOTED_SIGN (from, unsignedp))\n-    from = gen_lowpart (to_mode, from), from_mode = to_mode;\n+    from = gen_lowpart (to_int_mode, from), from_mode = to_int_mode;\n \n   gcc_assert (GET_CODE (to) != SUBREG || !SUBREG_PROMOTED_VAR_P (to));\n \n@@ -635,10 +638,12 @@ convert_modes (machine_mode mode, machine_mode oldmode, rtx x, int unsignedp)\n   /* If FROM is a SUBREG that indicates that we have already done at least\n      the required extension, strip it.  */\n \n-  if (GET_CODE (x) == SUBREG && SUBREG_PROMOTED_VAR_P (x)\n-      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))) >= GET_MODE_SIZE (mode)\n+  if (GET_CODE (x) == SUBREG\n+      && SUBREG_PROMOTED_VAR_P (x)\n+      && is_a <scalar_int_mode> (mode, &int_mode)\n+      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))) >= GET_MODE_SIZE (int_mode)\n       && SUBREG_CHECK_PROMOTED_SIGN (x, unsignedp))\n-    x = gen_lowpart (mode, SUBREG_REG (x));\n+    x = gen_lowpart (int_mode, SUBREG_REG (x));\n \n   if (GET_MODE (x) != VOIDmode)\n     oldmode = GET_MODE (x);"}, {"sha": "ca997490cf164b25936e32324485d2b37d31e463", "filename": "gcc/fwprop.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b9c3decc38f6f852adf16951b9b1b043112cd1c/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b9c3decc38f6f852adf16951b9b1b043112cd1c/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=6b9c3decc38f6f852adf16951b9b1b043112cd1c", "patch": "@@ -1095,6 +1095,7 @@ forward_propagate_subreg (df_ref use, rtx_insn *def_insn, rtx def_set)\n   rtx use_reg = DF_REF_REG (use);\n   rtx_insn *use_insn;\n   rtx src;\n+  scalar_int_mode int_use_mode, src_mode;\n \n   /* Only consider subregs... */\n   machine_mode use_mode = GET_MODE (use_reg);\n@@ -1136,17 +1137,19 @@ forward_propagate_subreg (df_ref use, rtx_insn *def_insn, rtx def_set)\n      definition of Y or, failing that, allow A to be deleted after\n      reload through register tying.  Introducing more uses of Y\n      prevents both optimisations.  */\n-  else if (subreg_lowpart_p (use_reg))\n+  else if (is_a <scalar_int_mode> (use_mode, &int_use_mode)\n+\t   && subreg_lowpart_p (use_reg))\n     {\n       use_insn = DF_REF_INSN (use);\n       src = SET_SRC (def_set);\n       if ((GET_CODE (src) == ZERO_EXTEND\n \t   || GET_CODE (src) == SIGN_EXTEND)\n+\t  && is_a <scalar_int_mode> (GET_MODE (src), &src_mode)\n \t  && REG_P (XEXP (src, 0))\n \t  && REGNO (XEXP (src, 0)) >= FIRST_PSEUDO_REGISTER\n \t  && GET_MODE (XEXP (src, 0)) == use_mode\n \t  && !free_load_extend (src, def_insn)\n-\t  && (targetm.mode_rep_extended (use_mode, GET_MODE (src))\n+\t  && (targetm.mode_rep_extended (int_use_mode, src_mode)\n \t      != (int) GET_CODE (src))\n \t  && all_uses_available_at (def_insn, use_insn))\n \treturn try_fwprop_subst (use, DF_REF_LOC (use), XEXP (src, 0),"}, {"sha": "61074e3fb1a0b8beba16f805d03d47741bf3d66d", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b9c3decc38f6f852adf16951b9b1b043112cd1c/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b9c3decc38f6f852adf16951b9b1b043112cd1c/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=6b9c3decc38f6f852adf16951b9b1b043112cd1c", "patch": "@@ -739,9 +739,9 @@ get_biv_step_1 (df_ref def, rtx reg,\n \n   if (GET_CODE (next) == SUBREG)\n     {\n-      machine_mode amode = GET_MODE (next);\n-\n-      if (GET_MODE_SIZE (amode) > GET_MODE_SIZE (*inner_mode))\n+      scalar_int_mode amode;\n+      if (!is_a <scalar_int_mode> (GET_MODE (next), &amode)\n+\t  || GET_MODE_SIZE (amode) > GET_MODE_SIZE (*inner_mode))\n \treturn false;\n \n       *inner_mode = amode;"}, {"sha": "1dfb545d251e5bbb26cc2a753de26d7477c8b441", "filename": "gcc/optabs.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b9c3decc38f6f852adf16951b9b1b043112cd1c/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b9c3decc38f6f852adf16951b9b1b043112cd1c/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=6b9c3decc38f6f852adf16951b9b1b043112cd1c", "patch": "@@ -195,6 +195,7 @@ widen_operand (rtx op, machine_mode mode, machine_mode oldmode,\n \t       int unsignedp, int no_extend)\n {\n   rtx result;\n+  scalar_int_mode int_mode;\n \n   /* If we don't have to extend and this is a constant, return it.  */\n   if (no_extend && GET_MODE (op) == VOIDmode)\n@@ -204,19 +205,20 @@ widen_operand (rtx op, machine_mode mode, machine_mode oldmode,\n      extend since it will be more efficient to do so unless the signedness of\n      a promoted object differs from our extension.  */\n   if (! no_extend\n+      || !is_a <scalar_int_mode> (mode, &int_mode)\n       || (GET_CODE (op) == SUBREG && SUBREG_PROMOTED_VAR_P (op)\n \t  && SUBREG_CHECK_PROMOTED_SIGN (op, unsignedp)))\n     return convert_modes (mode, oldmode, op, unsignedp);\n \n   /* If MODE is no wider than a single word, we return a lowpart or paradoxical\n      SUBREG.  */\n-  if (GET_MODE_SIZE (mode) <= UNITS_PER_WORD)\n-    return gen_lowpart (mode, force_reg (GET_MODE (op), op));\n+  if (GET_MODE_SIZE (int_mode) <= UNITS_PER_WORD)\n+    return gen_lowpart (int_mode, force_reg (GET_MODE (op), op));\n \n   /* Otherwise, get an object of MODE, clobber it, and set the low-order\n      part to OP.  */\n \n-  result = gen_reg_rtx (mode);\n+  result = gen_reg_rtx (int_mode);\n   emit_clobber (result);\n   emit_move_insn (gen_lowpart (GET_MODE (op), result), op);\n   return result;"}, {"sha": "38948dcf9c5b4a35a09df1a8fd8d9e790929d5fd", "filename": "gcc/postreload.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b9c3decc38f6f852adf16951b9b1b043112cd1c/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b9c3decc38f6f852adf16951b9b1b043112cd1c/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=6b9c3decc38f6f852adf16951b9b1b043112cd1c", "patch": "@@ -1699,14 +1699,16 @@ move2add_valid_value_p (int regno, machine_mode mode)\n \n   if (mode != reg_mode[regno])\n     {\n-      if (!MODES_OK_FOR_MOVE2ADD (mode, reg_mode[regno]))\n+      scalar_int_mode old_mode;\n+      if (!is_a <scalar_int_mode> (reg_mode[regno], &old_mode)\n+\t  || !MODES_OK_FOR_MOVE2ADD (mode, old_mode))\n \treturn false;\n       /* The value loaded into regno in reg_mode[regno] is also valid in\n \t mode after truncation only if (REG:mode regno) is the lowpart of\n \t (REG:reg_mode[regno] regno).  Now, for big endian, the starting\n \t regno of the lowpart might be different.  */\n-      int s_off = subreg_lowpart_offset (mode, reg_mode[regno]);\n-      s_off = subreg_regno_offset (regno, reg_mode[regno], s_off, mode);\n+      int s_off = subreg_lowpart_offset (mode, old_mode);\n+      s_off = subreg_regno_offset (regno, old_mode, s_off, mode);\n       if (s_off != 0)\n \t/* We could in principle adjust regno, check reg_mode[regno] to be\n \t   BLKmode, and return s_off to the caller (vs. -1 for failure),"}, {"sha": "15476db87d15e2d82daaa2b8298793fdd023d56b", "filename": "gcc/recog.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b9c3decc38f6f852adf16951b9b1b043112cd1c/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b9c3decc38f6f852adf16951b9b1b043112cd1c/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=6b9c3decc38f6f852adf16951b9b1b043112cd1c", "patch": "@@ -560,6 +560,7 @@ simplify_while_replacing (rtx *loc, rtx to, rtx_insn *object,\n   rtx x = *loc;\n   enum rtx_code code = GET_CODE (x);\n   rtx new_rtx = NULL_RTX;\n+  scalar_int_mode is_mode;\n \n   if (SWAPPABLE_OPERANDS_P (x)\n       && swap_commutative_operands_p (XEXP (x, 0), XEXP (x, 1)))\n@@ -655,14 +656,14 @@ simplify_while_replacing (rtx *loc, rtx to, rtx_insn *object,\n          happen, we might just fail in some cases).  */\n \n       if (MEM_P (XEXP (x, 0))\n+\t  && is_a <scalar_int_mode> (GET_MODE (XEXP (x, 0)), &is_mode)\n \t  && CONST_INT_P (XEXP (x, 1))\n \t  && CONST_INT_P (XEXP (x, 2))\n \t  && !mode_dependent_address_p (XEXP (XEXP (x, 0), 0),\n \t\t\t\t\tMEM_ADDR_SPACE (XEXP (x, 0)))\n \t  && !MEM_VOLATILE_P (XEXP (x, 0)))\n \t{\n \t  machine_mode wanted_mode = VOIDmode;\n-\t  machine_mode is_mode = GET_MODE (XEXP (x, 0));\n \t  int pos = INTVAL (XEXP (x, 2));\n \n \t  if (GET_CODE (x) == ZERO_EXTRACT && targetm.have_extzv ())"}, {"sha": "8473190b7a046ea7af3f5a2459501b94b149e614", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b9c3decc38f6f852adf16951b9b1b043112cd1c/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b9c3decc38f6f852adf16951b9b1b043112cd1c/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=6b9c3decc38f6f852adf16951b9b1b043112cd1c", "patch": "@@ -925,7 +925,7 @@ simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)\n {\n   enum rtx_code reversed;\n   rtx temp;\n-  scalar_int_mode inner, int_mode;\n+  scalar_int_mode inner, int_mode, op0_mode;\n \n   switch (code)\n     {\n@@ -1637,21 +1637,19 @@ simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)\n \t (zero_extend:SI (subreg:QI (and:SI (reg:SI) (const_int 63)) 0)) is\n \t (and:SI (reg:SI) (const_int 63)).  */\n       if (GET_CODE (op) == SUBREG\n-\t  && GET_MODE_PRECISION (GET_MODE (op))\n-\t     < GET_MODE_PRECISION (GET_MODE (SUBREG_REG (op)))\n-\t  && GET_MODE_PRECISION (GET_MODE (SUBREG_REG (op)))\n-\t     <= HOST_BITS_PER_WIDE_INT\n-\t  && GET_MODE_PRECISION (mode)\n-\t     >= GET_MODE_PRECISION (GET_MODE (SUBREG_REG (op)))\n+\t  && is_a <scalar_int_mode> (mode, &int_mode)\n+\t  && is_a <scalar_int_mode> (GET_MODE (SUBREG_REG (op)), &op0_mode)\n+\t  && GET_MODE_PRECISION (GET_MODE (op)) < GET_MODE_PRECISION (op0_mode)\n+\t  && GET_MODE_PRECISION (op0_mode) <= HOST_BITS_PER_WIDE_INT\n+\t  && GET_MODE_PRECISION (int_mode) >= GET_MODE_PRECISION (op0_mode)\n \t  && subreg_lowpart_p (op)\n-\t  && (nonzero_bits (SUBREG_REG (op), GET_MODE (SUBREG_REG (op)))\n+\t  && (nonzero_bits (SUBREG_REG (op), op0_mode)\n \t      & ~GET_MODE_MASK (GET_MODE (op))) == 0)\n \t{\n-\t  if (GET_MODE_PRECISION (mode)\n-\t      == GET_MODE_PRECISION (GET_MODE (SUBREG_REG (op))))\n+\t  if (GET_MODE_PRECISION (int_mode) == GET_MODE_PRECISION (op0_mode))\n \t    return SUBREG_REG (op);\n-\t  return simplify_gen_unary (ZERO_EXTEND, mode, SUBREG_REG (op),\n-\t\t\t\t     GET_MODE (SUBREG_REG (op)));\n+\t  return simplify_gen_unary (ZERO_EXTEND, int_mode, SUBREG_REG (op),\n+\t\t\t\t     op0_mode);\n \t}\n \n #if defined(POINTERS_EXTEND_UNSIGNED)\n@@ -2716,21 +2714,23 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n         by simplify_shift_const.  */\n \n       if (GET_CODE (opleft) == SUBREG\n+\t  && is_a <scalar_int_mode> (mode, &int_mode)\n+\t  && is_a <scalar_int_mode> (GET_MODE (SUBREG_REG (opleft)),\n+\t\t\t\t     &inner_mode)\n           && GET_CODE (SUBREG_REG (opleft)) == ASHIFT\n           && GET_CODE (opright) == LSHIFTRT\n           && GET_CODE (XEXP (opright, 0)) == SUBREG\n-          && GET_MODE (opleft) == GET_MODE (XEXP (opright, 0))\n           && SUBREG_BYTE (opleft) == SUBREG_BYTE (XEXP (opright, 0))\n-          && (GET_MODE_SIZE (GET_MODE (opleft))\n-              < GET_MODE_SIZE (GET_MODE (SUBREG_REG (opleft))))\n+\t  && GET_MODE_SIZE (int_mode) < GET_MODE_SIZE (inner_mode)\n           && rtx_equal_p (XEXP (SUBREG_REG (opleft), 0),\n                           SUBREG_REG (XEXP (opright, 0)))\n           && CONST_INT_P (XEXP (SUBREG_REG (opleft), 1))\n           && CONST_INT_P (XEXP (opright, 1))\n-          && (INTVAL (XEXP (SUBREG_REG (opleft), 1)) + INTVAL (XEXP (opright, 1))\n-              == GET_MODE_PRECISION (mode)))\n-        return gen_rtx_ROTATE (mode, XEXP (opright, 0),\n-                               XEXP (SUBREG_REG (opleft), 1));\n+\t  && (INTVAL (XEXP (SUBREG_REG (opleft), 1))\n+\t      + INTVAL (XEXP (opright, 1))\n+\t      == GET_MODE_PRECISION (int_mode)))\n+\treturn gen_rtx_ROTATE (int_mode, XEXP (opright, 0),\n+\t\t\t       XEXP (SUBREG_REG (opleft), 1));\n \n       /* If we have (ior (and (X C1) C2)), simplify this by making\n \t C1 as small as possible if C1 actually changes.  */"}]}