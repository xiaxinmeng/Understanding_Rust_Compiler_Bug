{"sha": "63bb4268049d7a6a1944c3a15b374bca8ccf2b45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjNiYjQyNjgwNDlkN2E2YTE5NDRjM2ExNWIzNzRiY2E4Y2NmMmI0NQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-14T13:40:56Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-14T13:40:56Z"}, "message": "[multiple changes]\n\n2013-10-14  Arnaud Charlet  <charlet@adacore.com>\n\n\t* exp_ch11.adb: Fix typo.\n\n2013-10-14  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_util.ads: Minor reformatting.\n\n2013-10-14  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Build_Derived_Record_Type): Reject full views\n\twith no explicit discriminant constraints, when the parents of\n\tthe partial view and the full view are constrained subtypes with\n\tdifferent constraints.\n\n2013-10-14  Robert Dewar  <dewar@adacore.com>\n\n\t* freeze.adb (Freeze_Array_Type): New procedure, abstracts out\n\tthis code from Freeze.\n\t(Freeze_Array_Type): Detect pragma Pack overriding foreign convention\n\t(Freeze_Record_Type): Ditto.\n\nFrom-SVN: r203553", "tree": {"sha": "938b63e5a4cb6035695a3246f0d1fae3bb5cf88d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/938b63e5a4cb6035695a3246f0d1fae3bb5cf88d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63bb4268049d7a6a1944c3a15b374bca8ccf2b45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63bb4268049d7a6a1944c3a15b374bca8ccf2b45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63bb4268049d7a6a1944c3a15b374bca8ccf2b45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63bb4268049d7a6a1944c3a15b374bca8ccf2b45/comments", "author": null, "committer": null, "parents": [{"sha": "e74d643a35af630dde8a5fd9582b1c391fd022c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e74d643a35af630dde8a5fd9582b1c391fd022c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e74d643a35af630dde8a5fd9582b1c391fd022c4"}], "stats": {"total": 1164, "additions": 632, "deletions": 532}, "files": [{"sha": "dee974fe992f805fb52ecc6d08c36a8de2f08b43", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63bb4268049d7a6a1944c3a15b374bca8ccf2b45/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63bb4268049d7a6a1944c3a15b374bca8ccf2b45/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=63bb4268049d7a6a1944c3a15b374bca8ccf2b45", "patch": "@@ -1,3 +1,25 @@\n+2013-10-14  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* exp_ch11.adb: Fix typo.\n+\n+2013-10-14  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_util.ads: Minor reformatting.\n+\n+2013-10-14  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Build_Derived_Record_Type): Reject full views\n+\twith no explicit discriminant constraints, when the parents of\n+\tthe partial view and the full view are constrained subtypes with\n+\tdifferent constraints.\n+\n+2013-10-14  Robert Dewar  <dewar@adacore.com>\n+\n+\t* freeze.adb (Freeze_Array_Type): New procedure, abstracts out\n+\tthis code from Freeze.\n+\t(Freeze_Array_Type): Detect pragma Pack overriding foreign convention\n+\t(Freeze_Record_Type): Ditto.\n+\n 2013-10-14  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_prag.adb (Analyze_Dependency_Clause): Add new local variable"}, {"sha": "ba6a85278dcc19c9f80332ac1b7b156cea2c7ba8", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63bb4268049d7a6a1944c3a15b374bca8ccf2b45/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63bb4268049d7a6a1944c3a15b374bca8ccf2b45/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=63bb4268049d7a6a1944c3a15b374bca8ccf2b45", "patch": "@@ -1026,7 +1026,7 @@ package body Exp_Ch11 is\n                --     end;\n \n                --  This expansion is not performed when using GCC ZCX. Gigi\n-               --  will insert a call to intialize the choice parameter.\n+               --  will insert a call to initialize the choice parameter.\n \n                if Present (Choice_Parameter (Handler))\n                  and then Exception_Mechanism /= Back_End_Exceptions"}, {"sha": "60a21324ce2fcc87c29a76bc2fd527544f1fa22f", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63bb4268049d7a6a1944c3a15b374bca8ccf2b45/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63bb4268049d7a6a1944c3a15b374bca8ccf2b45/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=63bb4268049d7a6a1944c3a15b374bca8ccf2b45", "patch": "@@ -359,9 +359,9 @@ package Exp_Util is\n    --  by the compiler and used by GDB.\n \n    procedure Evaluate_Name (Nam : Node_Id);\n-   --  Remove the all side effects from a name which appears as part of an\n-   --  object renaming declaration. More comments are needed here that explain\n-   --  how this differs from Force_Evaluation and Remove_Side_Effects ???\n+   --  Remove all side effects from a name which appears as part of an object\n+   --  renaming declaration. More comments are needed here that explain how\n+   --  this differs from Force_Evaluation and Remove_Side_Effects ???\n \n    procedure Evolve_And_Then (Cond : in out Node_Id; Cond1 : Node_Id);\n    --  Rewrites Cond with the expression: Cond and then Cond1. If Cond is"}, {"sha": "2844ebfa3289a5105eb934024465b67741dd0826", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 554, "deletions": 499, "changes": 1053, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63bb4268049d7a6a1944c3a15b374bca8ccf2b45/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63bb4268049d7a6a1944c3a15b374bca8ccf2b45/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=63bb4268049d7a6a1944c3a15b374bca8ccf2b45", "patch": "@@ -1698,12 +1698,15 @@ package body Freeze is\n       --  integer literal without an explicit corresponding size clause. The\n       --  caller has checked that Utype is a modular integer type.\n \n+      procedure Freeze_Array_Type (Arr : Entity_Id);\n+      --  Freeze array type, including freezing index and component types\n+\n       function Freeze_Generic_Entities (Pack : Entity_Id) return List_Id;\n       --  Create Freeze_Generic_Entity nodes for types declared in a generic\n       --  package. Recurse on inner generic packages.\n \n       procedure Freeze_Record_Type (Rec : Entity_Id);\n-      --  Freeze each component, handle some representation clauses, and freeze\n+      --  Freeze record type, including freezing component types, and freezing\n       --  primitive operations if this is a tagged type.\n \n       -------------------\n@@ -1948,6 +1951,529 @@ package body Freeze is\n          end if;\n       end Check_Suspicious_Modulus;\n \n+      -----------------------\n+      -- Freeze_Array_Type --\n+      -----------------------\n+\n+      procedure Freeze_Array_Type (Arr : Entity_Id) is\n+         FS     : constant Entity_Id := First_Subtype (Arr);\n+         Ctyp   : constant Entity_Id := Component_Type (Arr);\n+         Clause : Entity_Id;\n+\n+         Non_Standard_Enum : Boolean := False;\n+         --  Set true if any of the index types is an enumeration type with a\n+         --  non-standard representation.\n+\n+      begin\n+         Freeze_And_Append (Ctyp, N, Result);\n+\n+         Indx := First_Index (Arr);\n+         while Present (Indx) loop\n+            Freeze_And_Append (Etype (Indx), N, Result);\n+\n+            if Is_Enumeration_Type (Etype (Indx))\n+              and then Has_Non_Standard_Rep (Etype (Indx))\n+            then\n+               Non_Standard_Enum := True;\n+            end if;\n+\n+            Next_Index (Indx);\n+         end loop;\n+\n+         --  Processing that is done only for base types\n+\n+         if Ekind (Arr) = E_Array_Type then\n+\n+            --  Propagate flags for component type\n+\n+            if Is_Controlled (Component_Type (Arr))\n+              or else Has_Controlled_Component (Ctyp)\n+            then\n+               Set_Has_Controlled_Component (Arr);\n+            end if;\n+\n+            if Has_Unchecked_Union (Component_Type (Arr)) then\n+               Set_Has_Unchecked_Union (Arr);\n+            end if;\n+\n+            --  Warn for pragma Pack overriding foreign convention\n+\n+            if Has_Foreign_Convention (Ctyp)\n+              and then Has_Pragma_Pack (Arr)\n+            then\n+               declare\n+                  CN : constant Name_Id :=\n+                         Get_Convention_Name (Convention (Ctyp));\n+                  PP : constant Node_Id :=\n+                         Get_Pragma (First_Subtype (Arr), Pragma_Pack);\n+               begin\n+                  if Present (PP) then\n+                     Error_Msg_Name_1 := CN;\n+                     Error_Msg_Sloc := Sloc (Arr);\n+                     Error_Msg_N\n+                       (\"pragma Pack affects convention % components #??\",\n+                        PP);\n+                     Error_Msg_Name_1 := CN;\n+                     Error_Msg_N\n+                       (\"\\array components may not have % compatible \"\n+                        & \"representation??\", PP);\n+                  end if;\n+               end;\n+            end if;\n+\n+            --  If packing was requested or if the component size was\n+            --  set explicitly, then see if bit packing is required. This\n+            --  processing is only done for base types, since all of the\n+            --  representation aspects involved are type-related. This is not\n+            --  just an optimization, if we start processing the subtypes, they\n+            --  interfere with the settings on the base type (this is because\n+            --  Is_Packed has a slightly different meaning before and after\n+            --  freezing).\n+\n+            declare\n+               Csiz : Uint;\n+               Esiz : Uint;\n+\n+            begin\n+               if (Is_Packed (Arr) or else Has_Pragma_Pack (Arr))\n+                 and then Known_Static_RM_Size (Ctyp)\n+                 and then not Has_Component_Size_Clause (Arr)\n+               then\n+                  Csiz := UI_Max (RM_Size (Ctyp), 1);\n+\n+               elsif Known_Component_Size (Arr) then\n+                  Csiz := Component_Size (Arr);\n+\n+               elsif not Known_Static_Esize (Ctyp) then\n+                  Csiz := Uint_0;\n+\n+               else\n+                  Esiz := Esize (Ctyp);\n+\n+                  --  We can set the component size if it is less than 16,\n+                  --  rounding it up to the next storage unit size.\n+\n+                  if Esiz <= 8 then\n+                     Csiz := Uint_8;\n+                  elsif Esiz <= 16 then\n+                     Csiz := Uint_16;\n+                  else\n+                     Csiz := Uint_0;\n+                  end if;\n+\n+                  --  Set component size up to match alignment if it would\n+                  --  otherwise be less than the alignment. This deals with\n+                  --  cases of types whose alignment exceeds their size (the\n+                  --  padded type cases).\n+\n+                  if Csiz /= 0 then\n+                     declare\n+                        A : constant Uint := Alignment_In_Bits (Ctyp);\n+                     begin\n+                        if Csiz < A then\n+                           Csiz := A;\n+                        end if;\n+                     end;\n+                  end if;\n+               end if;\n+\n+               --  Case of component size that may result in packing\n+\n+               if 1 <= Csiz and then Csiz <= 64 then\n+                  declare\n+                     Ent         : constant Entity_Id :=\n+                                     First_Subtype (Arr);\n+                     Pack_Pragma : constant Node_Id :=\n+                                     Get_Rep_Pragma (Ent, Name_Pack);\n+                     Comp_Size_C : constant Node_Id :=\n+                                     Get_Attribute_Definition_Clause\n+                                       (Ent, Attribute_Component_Size);\n+                  begin\n+                     --  Warn if we have pack and component size so that the\n+                     --  pack is ignored.\n+\n+                     --  Note: here we must check for the presence of a\n+                     --  component size before checking for a Pack pragma to\n+                     --  deal with the case where the array type is a derived\n+                     --  type whose parent is currently private.\n+\n+                     if Present (Comp_Size_C)\n+                       and then Has_Pragma_Pack (Ent)\n+                       and then Warn_On_Redundant_Constructs\n+                     then\n+                        Error_Msg_Sloc := Sloc (Comp_Size_C);\n+                        Error_Msg_NE\n+                          (\"?r?pragma Pack for& ignored!\",\n+                           Pack_Pragma, Ent);\n+                        Error_Msg_N\n+                          (\"\\?r?explicit component size given#!\",\n+                           Pack_Pragma);\n+                        Set_Is_Packed (Base_Type (Ent), False);\n+                        Set_Is_Bit_Packed_Array (Base_Type (Ent), False);\n+                     end if;\n+\n+                     --  Set component size if not already set by a component\n+                     --  size clause.\n+\n+                     if not Present (Comp_Size_C) then\n+                        Set_Component_Size (Arr, Csiz);\n+                     end if;\n+\n+                     --  Check for base type of 8, 16, 32 bits, where an\n+                     --  unsigned subtype has a length one less than the\n+                     --  base type (e.g. Natural subtype of Integer).\n+\n+                     --  In such cases, if a component size was not set\n+                     --  explicitly, then generate a warning.\n+\n+                     if Has_Pragma_Pack (Arr)\n+                       and then not Present (Comp_Size_C)\n+                       and then\n+                         (Csiz = 7 or else Csiz = 15 or else Csiz = 31)\n+                       and then Esize (Base_Type (Ctyp)) = Csiz + 1\n+                     then\n+                        Error_Msg_Uint_1 := Csiz;\n+\n+                        if Present (Pack_Pragma) then\n+                           Error_Msg_N\n+                             (\"??pragma Pack causes component size \"\n+                              & \"to be ^!\", Pack_Pragma);\n+                           Error_Msg_N\n+                             (\"\\??use Component_Size to set \"\n+                              & \"desired value!\", Pack_Pragma);\n+                        end if;\n+                     end if;\n+\n+                     --  Actual packing is not needed for 8, 16, 32, 64. Also\n+                     --  not needed for 24 if alignment is 1.\n+\n+                     if        Csiz = 8\n+                       or else Csiz = 16\n+                       or else Csiz = 32\n+                       or else Csiz = 64\n+                       or else (Csiz = 24 and then Alignment (Ctyp) = 1)\n+                     then\n+                        --  Here the array was requested to be packed, but\n+                        --  the packing request had no effect, so Is_Packed\n+                        --  is reset.\n+\n+                        --  Note: semantically this means that we lose track\n+                        --  of the fact that a derived type inherited a pragma\n+                        --  Pack that was non- effective, but that seems fine.\n+\n+                        --  We regard a Pack pragma as a request to set a\n+                        --  representation characteristic, and this request\n+                        --  may be ignored.\n+\n+                        Set_Is_Packed           (Base_Type (Arr), False);\n+                        Set_Is_Bit_Packed_Array (Base_Type (Arr), False);\n+\n+                        if Known_Static_Esize (Component_Type (Arr))\n+                          and then Esize (Component_Type (Arr)) = Csiz\n+                        then\n+                           Set_Has_Non_Standard_Rep\n+                             (Base_Type (Arr), False);\n+                        end if;\n+\n+                        --  In all other cases, packing is indeed needed\n+\n+                     else\n+                        Set_Has_Non_Standard_Rep (Base_Type (Arr), True);\n+                        Set_Is_Bit_Packed_Array  (Base_Type (Arr), True);\n+                        Set_Is_Packed            (Base_Type (Arr), True);\n+                     end if;\n+                  end;\n+               end if;\n+            end;\n+\n+            --  Check for Atomic_Components or Aliased with unsuitable packing\n+            --  or explicit component size clause given.\n+\n+            if (Has_Atomic_Components (Arr)\n+                 or else Has_Aliased_Components (Arr))\n+              and then (Has_Component_Size_Clause (Arr)\n+                         or else Is_Packed (Arr))\n+            then\n+               Alias_Atomic_Check : declare\n+\n+                  procedure Complain_CS (T : String);\n+                  --  Outputs error messages for incorrect CS clause or pragma\n+                  --  Pack for aliased or atomic components (T is \"aliased\" or\n+                  --  \"atomic\");\n+\n+                  -----------------\n+                  -- Complain_CS --\n+                  -----------------\n+\n+                  procedure Complain_CS (T : String) is\n+                  begin\n+                     if Has_Component_Size_Clause (Arr) then\n+                        Clause :=\n+                          Get_Attribute_Definition_Clause\n+                            (FS, Attribute_Component_Size);\n+\n+                        if Known_Static_Esize (Ctyp) then\n+                           Error_Msg_N\n+                             (\"incorrect component size for \"\n+                              & T & \" components\", Clause);\n+                           Error_Msg_Uint_1 := Esize (Ctyp);\n+                           Error_Msg_N\n+                             (\"\\only allowed value is^\", Clause);\n+\n+                        else\n+                           Error_Msg_N\n+                             (\"component size cannot be given for \"\n+                              & T & \" components\", Clause);\n+                        end if;\n+\n+                     else\n+                        Error_Msg_N\n+                          (\"cannot pack \" & T & \" components\",\n+                           Get_Rep_Pragma (FS, Name_Pack));\n+                     end if;\n+\n+                     return;\n+                  end Complain_CS;\n+\n+                  --  Start of processing for Alias_Atomic_Check\n+\n+               begin\n+\n+                  --  If object size of component type isn't known, we cannot\n+                  --  be sure so we defer to the back end.\n+\n+                  if not Known_Static_Esize (Ctyp) then\n+                     null;\n+\n+                  --  Case where component size has no effect. First check for\n+                  --  object size of component type multiple of the storage\n+                  --  unit size.\n+\n+                  elsif Esize (Ctyp) mod System_Storage_Unit = 0\n+\n+                    --  OK in both packing case and component size case if RM\n+                    --  size is known and static and same as the object size.\n+\n+                    and then\n+                      ((Known_Static_RM_Size (Ctyp)\n+                         and then Esize (Ctyp) = RM_Size (Ctyp))\n+\n+                        --  Or if we have an explicit component size clause and\n+                        --  the component size and object size are equal.\n+\n+                        or else\n+                          (Has_Component_Size_Clause (Arr)\n+                            and then Component_Size (Arr) = Esize (Ctyp)))\n+                  then\n+                     null;\n+\n+                  elsif Has_Aliased_Components (Arr)\n+                    or else Is_Aliased (Ctyp)\n+                  then\n+                     Complain_CS (\"aliased\");\n+\n+                  elsif Has_Atomic_Components (Arr)\n+                    or else Is_Atomic (Ctyp)\n+                  then\n+                     Complain_CS (\"atomic\");\n+                  end if;\n+               end Alias_Atomic_Check;\n+            end if;\n+\n+            --  Warn for case of atomic type\n+\n+            Clause := Get_Rep_Pragma (FS, Name_Atomic);\n+\n+            if Present (Clause)\n+              and then not Addressable (Component_Size (FS))\n+            then\n+               Error_Msg_NE\n+                 (\"non-atomic components of type& may not be \"\n+                  & \"accessible by separate tasks??\", Clause, Arr);\n+\n+               if Has_Component_Size_Clause (Arr) then\n+                  Error_Msg_Sloc :=\n+                    Sloc\n+                      (Get_Attribute_Definition_Clause\n+                           (FS, Attribute_Component_Size));\n+                  Error_Msg_N\n+                    (\"\\because of component size clause#??\",\n+                     Clause);\n+\n+               elsif Has_Pragma_Pack (Arr) then\n+                  Error_Msg_Sloc :=\n+                    Sloc (Get_Rep_Pragma (FS, Name_Pack));\n+                  Error_Msg_N\n+                    (\"\\because of pragma Pack#??\", Clause);\n+               end if;\n+            end if;\n+\n+            --  Check for scalar storage order\n+\n+            if Present (Get_Attribute_Definition_Clause\n+                        (Arr, Attribute_Scalar_Storage_Order))\n+            then\n+               Check_Component_Storage_Order (Arr, Empty);\n+            end if;\n+\n+            --  Processing that is done only for subtypes\n+\n+         else\n+            --  Acquire alignment from base type\n+\n+            if Unknown_Alignment (Arr) then\n+               Set_Alignment (Arr, Alignment (Base_Type (Arr)));\n+               Adjust_Esize_Alignment (Arr);\n+            end if;\n+         end if;\n+\n+         --  Specific checks for bit-packed arrays\n+\n+         if Is_Bit_Packed_Array (Arr) then\n+\n+            --  Check number of elements for bit packed arrays that come from\n+            --  source and have compile time known ranges. The bit-packed\n+            --  arrays circuitry does not support arrays with more than\n+            --  Integer'Last + 1 elements, and when this restriction is\n+            --  violated, causes incorrect data access.\n+\n+            --  For the case where this is not compile time known, a run-time\n+            --  check should be generated???\n+\n+            if Comes_From_Source (Arr) and then Is_Constrained (Arr) then\n+               declare\n+                  Elmts : Uint;\n+                  Index : Node_Id;\n+                  Ilen  : Node_Id;\n+                  Ityp  : Entity_Id;\n+\n+               begin\n+                  Elmts := Uint_1;\n+                  Index := First_Index (Arr);\n+                  while Present (Index) loop\n+                     Ityp := Etype (Index);\n+\n+                     --  Never generate an error if any index is of a generic\n+                     --  type. We will check this in instances.\n+\n+                     if Is_Generic_Type (Ityp) then\n+                        Elmts := Uint_0;\n+                        exit;\n+                     end if;\n+\n+                     Ilen :=\n+                       Make_Attribute_Reference (Loc,\n+                         Prefix         =>\n+                           New_Occurrence_Of (Ityp, Loc),\n+                         Attribute_Name => Name_Range_Length);\n+                     Analyze_And_Resolve (Ilen);\n+\n+                     --  No attempt is made to check number of elements\n+                     --  if not compile time known.\n+\n+                     if Nkind (Ilen) /= N_Integer_Literal then\n+                        Elmts := Uint_0;\n+                        exit;\n+                     end if;\n+\n+                     Elmts := Elmts * Intval (Ilen);\n+                     Next_Index (Index);\n+                  end loop;\n+\n+                  if Elmts > Intval (High_Bound\n+                                     (Scalar_Range\n+                                        (Standard_Integer))) + 1\n+                  then\n+                     Error_Msg_N\n+                       (\"bit packed array type may not have \"\n+                        & \"more than Integer''Last+1 elements\", Arr);\n+                  end if;\n+               end;\n+            end if;\n+\n+            --  Check size\n+\n+            if Known_RM_Size (Arr) then\n+               declare\n+                  SizC : constant Node_Id := Size_Clause (Arr);\n+\n+                  Discard : Boolean;\n+                  pragma Warnings (Off, Discard);\n+\n+               begin\n+                  --  It is not clear if it is possible to have no size clause\n+                  --  at this stage, but it is not worth worrying about. Post\n+                  --  error on the entity name in the size clause if present,\n+                  --  else on the type entity itself.\n+\n+                  if Present (SizC) then\n+                     Check_Size (Name (SizC), Arr, RM_Size (Arr), Discard);\n+                  else\n+                     Check_Size (Arr, Arr, RM_Size (Arr), Discard);\n+                  end if;\n+               end;\n+            end if;\n+         end if;\n+\n+         --  If any of the index types was an enumeration type with a\n+         --  non-standard rep clause, then we indicate that the array type\n+         --  is always packed (even if it is not bit packed).\n+\n+         if Non_Standard_Enum then\n+            Set_Has_Non_Standard_Rep (Base_Type (Arr));\n+            Set_Is_Packed            (Base_Type (Arr));\n+         end if;\n+\n+         Set_Component_Alignment_If_Not_Set (Arr);\n+\n+         --  If the array is packed, we must create the packed array type to be\n+         --  used to actually implement the type. This is only needed for real\n+         --  array types (not for string literal types, since they are present\n+         --  only for the front end).\n+\n+         if Is_Packed (Arr)\n+           and then Ekind (Arr) /= E_String_Literal_Subtype\n+         then\n+            Create_Packed_Array_Type (Arr);\n+            Freeze_And_Append (Packed_Array_Type (Arr), N, Result);\n+\n+            --  Size information of packed array type is copied to the array\n+            --  type, since this is really the representation. But do not\n+            --  override explicit existing size values. If the ancestor subtype\n+            --  is constrained the packed_array_type will be inherited from it,\n+            --  but the size may have been provided already, and must not be\n+            --  overridden either.\n+\n+            if not Has_Size_Clause (Arr)\n+              and then\n+                (No (Ancestor_Subtype (Arr))\n+                  or else not Has_Size_Clause (Ancestor_Subtype (Arr)))\n+            then\n+               Set_Esize     (Arr, Esize     (Packed_Array_Type (Arr)));\n+               Set_RM_Size   (Arr, RM_Size   (Packed_Array_Type (Arr)));\n+            end if;\n+\n+            if not Has_Alignment_Clause (Arr) then\n+               Set_Alignment (Arr, Alignment (Packed_Array_Type (Arr)));\n+            end if;\n+         end if;\n+\n+         --  For non-packed arrays set the alignment of the array to the\n+         --  alignment of the component type if it is unknown. Skip this\n+         --  in atomic case (atomic arrays may need larger alignments).\n+\n+         if not Is_Packed (Arr)\n+           and then Unknown_Alignment (Arr)\n+           and then Known_Alignment (Ctyp)\n+           and then Known_Static_Component_Size (Arr)\n+           and then Known_Static_Esize (Ctyp)\n+           and then Esize (Ctyp) = Component_Size (Arr)\n+           and then not Is_Atomic (Arr)\n+         then\n+            Set_Alignment (Arr, Alignment (Component_Type (Arr)));\n+         end if;\n+      end Freeze_Array_Type;\n+\n       -----------------------------\n       -- Freeze_Generic_Entities --\n       -----------------------------\n@@ -2201,6 +2727,31 @@ package body Freeze is\n \n                   Freeze_And_Append (Etype (Comp), N, Result);\n \n+                  --  Warn for pragma Pack overriding foreign convention\n+\n+                  if Has_Foreign_Convention (Etype (Comp))\n+                    and then Has_Pragma_Pack (Rec)\n+                  then\n+                     declare\n+                        CN : constant Name_Id :=\n+                               Get_Convention_Name (Convention (Etype (Comp)));\n+                        PP : constant Node_Id :=\n+                               Get_Pragma (Rec, Pragma_Pack);\n+                     begin\n+                        if Present (PP) then\n+                           Error_Msg_Name_1 := CN;\n+                           Error_Msg_Sloc := Sloc (Comp);\n+                           Error_Msg_N\n+                             (\"pragma Pack affects convention % component#??\",\n+                              PP);\n+                           Error_Msg_Name_1 := CN;\n+                           Error_Msg_NE\n+                             (\"\\component & may not have % compatible \"\n+                              & \"representation??\", PP, Comp);\n+                        end if;\n+                     end;\n+                  end if;\n+\n                   --  Check for error of component clause given for variable\n                   --  sized type. We have to delay this test till this point,\n                   --  since the component type has to be frozen for us to know\n@@ -3749,506 +4300,10 @@ package body Freeze is\n             Inherit_Aspects_At_Freeze_Point (E);\n          end if;\n \n-         --  For array type, freeze index types and component type first\n-         --  before freezing the array (RM 13.14(15)).\n+         --  Array type\n \n          if Is_Array_Type (E) then\n-            declare\n-               FS     : constant Entity_Id := First_Subtype (E);\n-               Ctyp   : constant Entity_Id := Component_Type (E);\n-               Clause : Entity_Id;\n-\n-               Non_Standard_Enum : Boolean := False;\n-               --  Set true if any of the index types is an enumeration type\n-               --  with a non-standard representation.\n-\n-            begin\n-               Freeze_And_Append (Ctyp, N, Result);\n-\n-               Indx := First_Index (E);\n-               while Present (Indx) loop\n-                  Freeze_And_Append (Etype (Indx), N, Result);\n-\n-                  if Is_Enumeration_Type (Etype (Indx))\n-                    and then Has_Non_Standard_Rep (Etype (Indx))\n-                  then\n-                     Non_Standard_Enum := True;\n-                  end if;\n-\n-                  Next_Index (Indx);\n-               end loop;\n-\n-               --  Processing that is done only for base types\n-\n-               if Ekind (E) = E_Array_Type then\n-\n-                  --  Propagate flags for component type\n-\n-                  if Is_Controlled (Component_Type (E))\n-                    or else Has_Controlled_Component (Ctyp)\n-                  then\n-                     Set_Has_Controlled_Component (E);\n-                  end if;\n-\n-                  if Has_Unchecked_Union (Component_Type (E)) then\n-                     Set_Has_Unchecked_Union (E);\n-                  end if;\n-\n-                  --  If packing was requested or if the component size was set\n-                  --  explicitly, then see if bit packing is required. This\n-                  --  processing is only done for base types, since all the\n-                  --  representation aspects involved are type-related. This\n-                  --  is not just an optimization, if we start processing the\n-                  --  subtypes, they interfere with the settings on the base\n-                  --  type (this is because Is_Packed has a slightly different\n-                  --  meaning before and after freezing).\n-\n-                  declare\n-                     Csiz : Uint;\n-                     Esiz : Uint;\n-\n-                  begin\n-                     if (Is_Packed (E) or else Has_Pragma_Pack (E))\n-                       and then Known_Static_RM_Size (Ctyp)\n-                       and then not Has_Component_Size_Clause (E)\n-                     then\n-                        Csiz := UI_Max (RM_Size (Ctyp), 1);\n-\n-                     elsif Known_Component_Size (E) then\n-                        Csiz := Component_Size (E);\n-\n-                     elsif not Known_Static_Esize (Ctyp) then\n-                        Csiz := Uint_0;\n-\n-                     else\n-                        Esiz := Esize (Ctyp);\n-\n-                        --  We can set the component size if it is less than\n-                        --  16, rounding it up to the next storage unit size.\n-\n-                        if Esiz <= 8 then\n-                           Csiz := Uint_8;\n-                        elsif Esiz <= 16 then\n-                           Csiz := Uint_16;\n-                        else\n-                           Csiz := Uint_0;\n-                        end if;\n-\n-                        --  Set component size up to match alignment if it\n-                        --  would otherwise be less than the alignment. This\n-                        --  deals with cases of types whose alignment exceeds\n-                        --  their size (padded types).\n-\n-                        if Csiz /= 0 then\n-                           declare\n-                              A : constant Uint := Alignment_In_Bits (Ctyp);\n-                           begin\n-                              if Csiz < A then\n-                                 Csiz := A;\n-                              end if;\n-                           end;\n-                        end if;\n-                     end if;\n-\n-                     --  Case of component size that may result in packing\n-\n-                     if 1 <= Csiz and then Csiz <= 64 then\n-                        declare\n-                           Ent         : constant Entity_Id :=\n-                                           First_Subtype (E);\n-                           Pack_Pragma : constant Node_Id :=\n-                                           Get_Rep_Pragma (Ent, Name_Pack);\n-                           Comp_Size_C : constant Node_Id :=\n-                                           Get_Attribute_Definition_Clause\n-                                             (Ent, Attribute_Component_Size);\n-                        begin\n-                           --  Warn if we have pack and component size so that\n-                           --  the pack is ignored.\n-\n-                           --  Note: here we must check for the presence of a\n-                           --  component size before checking for a Pack pragma\n-                           --  to deal with the case where the array type is a\n-                           --  derived type whose parent is currently private.\n-\n-                           if Present (Comp_Size_C)\n-                             and then Has_Pragma_Pack (Ent)\n-                             and then Warn_On_Redundant_Constructs\n-                           then\n-                              Error_Msg_Sloc := Sloc (Comp_Size_C);\n-                              Error_Msg_NE\n-                                (\"?r?pragma Pack for& ignored!\",\n-                                 Pack_Pragma, Ent);\n-                              Error_Msg_N\n-                                (\"\\?r?explicit component size given#!\",\n-                                 Pack_Pragma);\n-                              Set_Is_Packed (Base_Type (Ent), False);\n-                              Set_Is_Bit_Packed_Array (Base_Type (Ent), False);\n-                           end if;\n-\n-                           --  Set component size if not already set by a\n-                           --  component size clause.\n-\n-                           if not Present (Comp_Size_C) then\n-                              Set_Component_Size (E, Csiz);\n-                           end if;\n-\n-                           --  Check for base type of 8, 16, 32 bits, where an\n-                           --  unsigned subtype has a length one less than the\n-                           --  base type (e.g. Natural subtype of Integer).\n-\n-                           --  In such cases, if a component size was not set\n-                           --  explicitly, then generate a warning.\n-\n-                           if Has_Pragma_Pack (E)\n-                             and then not Present (Comp_Size_C)\n-                             and then\n-                               (Csiz = 7 or else Csiz = 15 or else Csiz = 31)\n-                             and then Esize (Base_Type (Ctyp)) = Csiz + 1\n-                           then\n-                              Error_Msg_Uint_1 := Csiz;\n-\n-                              if Present (Pack_Pragma) then\n-                                 Error_Msg_N\n-                                   (\"??pragma Pack causes component size \"\n-                                    & \"to be ^!\", Pack_Pragma);\n-                                 Error_Msg_N\n-                                   (\"\\??use Component_Size to set \"\n-                                    & \"desired value!\", Pack_Pragma);\n-                              end if;\n-                           end if;\n-\n-                           --  Actual packing is not needed for 8, 16, 32, 64.\n-                           --  Also not needed for 24 if alignment is 1.\n-\n-                           if        Csiz = 8\n-                             or else Csiz = 16\n-                             or else Csiz = 32\n-                             or else Csiz = 64\n-                             or else (Csiz = 24 and then Alignment (Ctyp) = 1)\n-                           then\n-                              --  Here the array was requested to be packed,\n-                              --  but the packing request had no effect, so\n-                              --  Is_Packed is reset.\n-\n-                              --  Note: semantically this means that we lose\n-                              --  track of the fact that a derived type\n-                              --  inherited a pragma Pack that was non-\n-                              --  effective, but that seems fine.\n-\n-                              --  We regard a Pack pragma as a request to set\n-                              --  a representation characteristic, and this\n-                              --  request may be ignored.\n-\n-                              Set_Is_Packed           (Base_Type (E), False);\n-                              Set_Is_Bit_Packed_Array (Base_Type (E), False);\n-\n-                              if Known_Static_Esize (Component_Type (E))\n-                                and then Esize (Component_Type (E)) = Csiz\n-                              then\n-                                 Set_Has_Non_Standard_Rep\n-                                   (Base_Type (E), False);\n-                              end if;\n-\n-                           --  In all other cases, packing is indeed needed\n-\n-                           else\n-                              Set_Has_Non_Standard_Rep (Base_Type (E), True);\n-                              Set_Is_Bit_Packed_Array  (Base_Type (E), True);\n-                              Set_Is_Packed            (Base_Type (E), True);\n-                           end if;\n-                        end;\n-                     end if;\n-                  end;\n-\n-                  --  Check for Atomic_Components or Aliased with unsuitable\n-                  --  packing or explicit component size clause given.\n-\n-                  if (Has_Atomic_Components (E)\n-                       or else Has_Aliased_Components (E))\n-                    and then (Has_Component_Size_Clause (E)\n-                               or else Is_Packed (E))\n-                  then\n-                     Alias_Atomic_Check : declare\n-\n-                        procedure Complain_CS (T : String);\n-                        --  Outputs error messages for incorrect CS clause or\n-                        --  pragma Pack for aliased or atomic components (T is\n-                        --  \"aliased\" or \"atomic\");\n-\n-                        -----------------\n-                        -- Complain_CS --\n-                        -----------------\n-\n-                        procedure Complain_CS (T : String) is\n-                        begin\n-                           if Has_Component_Size_Clause (E) then\n-                              Clause :=\n-                                Get_Attribute_Definition_Clause\n-                                  (FS, Attribute_Component_Size);\n-\n-                              if Known_Static_Esize (Ctyp) then\n-                                 Error_Msg_N\n-                                   (\"incorrect component size for \"\n-                                    & T & \" components\", Clause);\n-                                 Error_Msg_Uint_1 := Esize (Ctyp);\n-                                 Error_Msg_N\n-                                   (\"\\only allowed value is^\", Clause);\n-\n-                              else\n-                                 Error_Msg_N\n-                                   (\"component size cannot be given for \"\n-                                    & T & \" components\", Clause);\n-                              end if;\n-\n-                           else\n-                              Error_Msg_N\n-                                (\"cannot pack \" & T & \" components\",\n-                                 Get_Rep_Pragma (FS, Name_Pack));\n-                           end if;\n-\n-                           return;\n-                        end Complain_CS;\n-\n-                     --  Start of processing for Alias_Atomic_Check\n-\n-                     begin\n-\n-                        --  If object size of component type isn't known, we\n-                        --  cannot be sure so we defer to the back end.\n-\n-                        if not Known_Static_Esize (Ctyp) then\n-                           null;\n-\n-                        --  Case where component size has no effect. First\n-                        --  check for object size of component type multiple\n-                        --  of the storage unit size.\n-\n-                        elsif Esize (Ctyp) mod System_Storage_Unit = 0\n-\n-                          --  OK in both packing case and component size case\n-                          --  if RM size is known and static and the same as\n-                          --  the object size.\n-\n-                          and then\n-                            ((Known_Static_RM_Size (Ctyp)\n-                               and then Esize (Ctyp) = RM_Size (Ctyp))\n-\n-                             --  Or if we have an explicit component size\n-                             --  clause and the component size and object size\n-                             --  are equal.\n-\n-                             or else\n-                                 (Has_Component_Size_Clause (E)\n-                                 and then Component_Size (E) = Esize (Ctyp)))\n-                        then\n-                           null;\n-\n-                        elsif Has_Aliased_Components (E)\n-                          or else Is_Aliased (Ctyp)\n-                        then\n-                           Complain_CS (\"aliased\");\n-\n-                        elsif Has_Atomic_Components (E)\n-                          or else Is_Atomic (Ctyp)\n-                        then\n-                           Complain_CS (\"atomic\");\n-                        end if;\n-                     end Alias_Atomic_Check;\n-                  end if;\n-\n-                  --  Warn for case of atomic type\n-\n-                  Clause := Get_Rep_Pragma (FS, Name_Atomic);\n-\n-                  if Present (Clause)\n-                    and then not Addressable (Component_Size (FS))\n-                  then\n-                     Error_Msg_NE\n-                       (\"non-atomic components of type& may not be \"\n-                        & \"accessible by separate tasks??\", Clause, E);\n-\n-                     if Has_Component_Size_Clause (E) then\n-                        Error_Msg_Sloc :=\n-                          Sloc\n-                            (Get_Attribute_Definition_Clause\n-                                 (FS, Attribute_Component_Size));\n-                        Error_Msg_N\n-                          (\"\\because of component size clause#??\",\n-                           Clause);\n-\n-                     elsif Has_Pragma_Pack (E) then\n-                        Error_Msg_Sloc :=\n-                          Sloc (Get_Rep_Pragma (FS, Name_Pack));\n-                        Error_Msg_N\n-                          (\"\\because of pragma Pack#??\", Clause);\n-                     end if;\n-                  end if;\n-\n-                  --  Check for scalar storage order\n-\n-                  if Present (Get_Attribute_Definition_Clause\n-                                (E, Attribute_Scalar_Storage_Order))\n-                  then\n-                     Check_Component_Storage_Order (E, Empty);\n-                  end if;\n-\n-               --  Processing that is done only for subtypes\n-\n-               else\n-                  --  Acquire alignment from base type\n-\n-                  if Unknown_Alignment (E) then\n-                     Set_Alignment (E, Alignment (Base_Type (E)));\n-                     Adjust_Esize_Alignment (E);\n-                  end if;\n-               end if;\n-\n-               --  Specific checks for bit-packed arrays\n-\n-               if Is_Bit_Packed_Array (E) then\n-\n-                  --  Check number of elements for bit packed arrays that come\n-                  --  from source and have compile time known ranges. The\n-                  --  bit-packed arrays circuitry does not support arrays\n-                  --  with more than Integer'Last + 1 elements, and when this\n-                  --  restriction is violated, causes incorrect data access.\n-\n-                  --  For the case where this is not compile time known, a\n-                  --  run-time check should be generated???\n-\n-                  if Comes_From_Source (E) and then Is_Constrained (E) then\n-                     declare\n-                        Elmts : Uint;\n-                        Index : Node_Id;\n-                        Ilen  : Node_Id;\n-                        Ityp  : Entity_Id;\n-\n-                     begin\n-                        Elmts := Uint_1;\n-                        Index := First_Index (E);\n-                        while Present (Index) loop\n-                           Ityp := Etype (Index);\n-\n-                           --  Never generate an error if any index is of a\n-                           --  generic type. We will check this in instances.\n-\n-                           if Is_Generic_Type (Ityp) then\n-                              Elmts := Uint_0;\n-                              exit;\n-                           end if;\n-\n-                           Ilen :=\n-                             Make_Attribute_Reference (Loc,\n-                               Prefix         =>\n-                                 New_Occurrence_Of (Ityp, Loc),\n-                               Attribute_Name => Name_Range_Length);\n-                           Analyze_And_Resolve (Ilen);\n-\n-                           --  No attempt is made to check number of elements\n-                           --  if not compile time known.\n-\n-                           if Nkind (Ilen) /= N_Integer_Literal then\n-                              Elmts := Uint_0;\n-                              exit;\n-                           end if;\n-\n-                           Elmts := Elmts * Intval (Ilen);\n-                           Next_Index (Index);\n-                        end loop;\n-\n-                        if Elmts > Intval (High_Bound\n-                                             (Scalar_Range\n-                                                (Standard_Integer))) + 1\n-                        then\n-                           Error_Msg_N\n-                             (\"bit packed array type may not have \"\n-                              & \"more than Integer''Last+1 elements\", E);\n-                        end if;\n-                     end;\n-                  end if;\n-\n-                  --  Check size\n-\n-                  if Known_RM_Size (E) then\n-                     declare\n-                        SizC : constant Node_Id := Size_Clause (E);\n-\n-                        Discard : Boolean;\n-                        pragma Warnings (Off, Discard);\n-\n-                     begin\n-                        --  It is not clear if it is possible to have no size\n-                        --  clause at this stage, but it is not worth worrying\n-                        --  about. Post error on the entity name in the size\n-                        --  clause if present, else on the type entity itself.\n-\n-                        if Present (SizC) then\n-                           Check_Size (Name (SizC), E, RM_Size (E), Discard);\n-                        else\n-                           Check_Size (E, E, RM_Size (E), Discard);\n-                        end if;\n-                     end;\n-                  end if;\n-               end if;\n-\n-               --  If any of the index types was an enumeration type with a\n-               --  non-standard rep clause, then we indicate that the array\n-               --  type is always packed (even if it is not bit packed).\n-\n-               if Non_Standard_Enum then\n-                  Set_Has_Non_Standard_Rep (Base_Type (E));\n-                  Set_Is_Packed            (Base_Type (E));\n-               end if;\n-\n-               Set_Component_Alignment_If_Not_Set (E);\n-\n-               --  If the array is packed, we must create the packed array\n-               --  type to be used to actually implement the type. This is\n-               --  only needed for real array types (not for string literal\n-               --  types, since they are present only for the front end).\n-\n-               if Is_Packed (E)\n-                 and then Ekind (E) /= E_String_Literal_Subtype\n-               then\n-                  Create_Packed_Array_Type (E);\n-                  Freeze_And_Append (Packed_Array_Type (E), N, Result);\n-\n-                  --  Size information of packed array type is copied to the\n-                  --  array type, since this is really the representation. But\n-                  --  do not override explicit existing size values. If the\n-                  --  ancestor subtype is constrained the packed_array_type\n-                  --  will be inherited from it, but the size may have been\n-                  --  provided already, and must not be overridden either.\n-\n-                  if not Has_Size_Clause (E)\n-                    and then\n-                      (No (Ancestor_Subtype (E))\n-                        or else not Has_Size_Clause (Ancestor_Subtype (E)))\n-                  then\n-                     Set_Esize     (E, Esize     (Packed_Array_Type (E)));\n-                     Set_RM_Size   (E, RM_Size   (Packed_Array_Type (E)));\n-                  end if;\n-\n-                  if not Has_Alignment_Clause (E) then\n-                     Set_Alignment (E, Alignment (Packed_Array_Type (E)));\n-                  end if;\n-               end if;\n-\n-               --  For non-packed arrays set the alignment of the array to the\n-               --  alignment of the component type if it is unknown. Skip this\n-               --  in atomic case (atomic arrays may need larger alignments).\n-\n-               if not Is_Packed (E)\n-                 and then Unknown_Alignment (E)\n-                 and then Known_Alignment (Ctyp)\n-                 and then Known_Static_Component_Size (E)\n-                 and then Known_Static_Esize (Ctyp)\n-                 and then Esize (Ctyp) = Component_Size (E)\n-                 and then not Is_Atomic (E)\n-               then\n-                  Set_Alignment (E, Alignment (Component_Type (E)));\n-               end if;\n-            end;\n+            Freeze_Array_Type (E);\n \n          --  For a class-wide type, the corresponding specific type is\n          --  frozen as well (RM 13.14(15))"}, {"sha": "9ef25f73c8553db0b477c145a1ad3e1738bdd4c4", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 52, "deletions": 29, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63bb4268049d7a6a1944c3a15b374bca8ccf2b45/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63bb4268049d7a6a1944c3a15b374bca8ccf2b45/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=63bb4268049d7a6a1944c3a15b374bca8ccf2b45", "patch": "@@ -1001,7 +1001,7 @@ package body Sem_Ch3 is\n          if Nkind (Def) in N_Has_Etype then\n             if Etype (Def) = T_Name then\n                Error_Msg_N\n-                 (\"type& cannot be used before end of its declaration\", Def);\n+                 (\"typer cannot be used before end of its declaration\", Def);\n             end if;\n \n          --  If this is not a subtype, then this is an access_definition\n@@ -7337,45 +7337,68 @@ package body Sem_Ch3 is\n         and then (Is_Constrained (Parent_Type) or else Constraint_Present)\n       then\n          --  First, we must analyze the constraint (see comment in point 5.)\n+         --  The constraint may come from the subtype indication of the full\n+         --  declaration.\n \n          if Constraint_Present then\n-            New_Discrs := Build_Discriminant_Constraints (Parent_Type, Indic);\n+            New_Discrs :=\n+              Build_Discriminant_Constraints (Parent_Type, Indic);\n \n-            if Has_Discriminants (Derived_Type)\n-              and then Has_Private_Declaration (Derived_Type)\n-              and then Present (Discriminant_Constraint (Derived_Type))\n-            then\n-               --  Verify that constraints of the full view statically match\n-               --  those given in the partial view.\n+         --  If there is no explicit constraint, there might be one that is\n+         --  inherited from a constrained parent type. In that case verify that\n+         --  it conforms to the constraint in the partial view. In perverse\n+         --  cases the parent subtypes of the partial and full view can have\n+         --  different constraints.\n \n-               declare\n-                  C1, C2 : Elmt_Id;\n+         elsif Present (Stored_Constraint (Parent_Type)) then\n+            New_Discrs := Stored_Constraint (Parent_Type);\n \n-               begin\n-                  C1 := First_Elmt (New_Discrs);\n-                  C2 := First_Elmt (Discriminant_Constraint (Derived_Type));\n-                  while Present (C1) and then Present (C2) loop\n-                     if Fully_Conformant_Expressions (Node (C1), Node (C2))\n-                       or else\n-                         (Is_OK_Static_Expression (Node (C1))\n-                            and then\n-                          Is_OK_Static_Expression (Node (C2))\n-                            and then\n-                          Expr_Value (Node (C1)) = Expr_Value (Node (C2)))\n-                     then\n-                        null;\n+         else\n+            New_Discrs := No_Elist;\n+         end if;\n \n-                     else\n+         if Has_Discriminants (Derived_Type)\n+           and then Has_Private_Declaration (Derived_Type)\n+           and then Present (Discriminant_Constraint (Derived_Type))\n+           and then Present (New_Discrs)\n+         then\n+            --  Verify that constraints of the full view statically match\n+            --  those given in the partial view.\n+\n+            declare\n+               C1, C2     : Elmt_Id;\n+               Error_Node : Node_Id;\n+\n+            begin\n+               C1 := First_Elmt (New_Discrs);\n+               C2 := First_Elmt (Discriminant_Constraint (Derived_Type));\n+               while Present (C1) and then Present (C2) loop\n+                  if Fully_Conformant_Expressions (Node (C1), Node (C2))\n+                    or else\n+                      (Is_OK_Static_Expression (Node (C1))\n+                         and then\n+                       Is_OK_Static_Expression (Node (C2))\n+                         and then\n+                       Expr_Value (Node (C1)) = Expr_Value (Node (C2)))\n+                  then\n+                     null;\n+\n+                  else\n+                     if Constraint_Present then\n                         Error_Msg_N (\n                           \"constraint not conformant to previous declaration\",\n                              Node (C1));\n+                     else\n+                        Error_Msg_N (\n+                          \"constraint of full view is incompatible \" &\n+                           \"with partial view\", N);\n                      end if;\n+                  end if;\n \n-                     Next_Elmt (C1);\n-                     Next_Elmt (C2);\n-                  end loop;\n-               end;\n-            end if;\n+                  Next_Elmt (C1);\n+                  Next_Elmt (C2);\n+               end loop;\n+            end;\n          end if;\n \n          --  Insert and analyze the declaration for the unconstrained base type"}]}