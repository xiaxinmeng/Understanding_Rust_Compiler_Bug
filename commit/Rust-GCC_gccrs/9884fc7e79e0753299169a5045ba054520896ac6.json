{"sha": "9884fc7e79e0753299169a5045ba054520896ac6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTg4NGZjN2U3OWUwNzUzMjk5MTY5YTUwNDViYTA1NDUyMDg5NmFjNg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-11-04T16:27:17Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-11-27T09:15:58Z"}, "message": "[Ada] Do not use 128-bit division for 64-bit fixed-point types\n\ngcc/ada/\n\n\t* exp_fixd.adb (Build_Double_Divide): Only use a 128-bit\n\tdivision if one of the operands is larger than 64 bits.\n\t(Build_Double_Divide_Code): Likewise.\n\t(Build_Scaled_Divide): Likewise.\n\t(Build_Scaled_Divide_Code): Likewise.", "tree": {"sha": "700ea05e06eb8c75aac2379d41aa6f0d4b61eeb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/700ea05e06eb8c75aac2379d41aa6f0d4b61eeb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9884fc7e79e0753299169a5045ba054520896ac6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9884fc7e79e0753299169a5045ba054520896ac6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9884fc7e79e0753299169a5045ba054520896ac6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9884fc7e79e0753299169a5045ba054520896ac6/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d4ee5f8e2ab894fdeaa67824eb32103cda947f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d4ee5f8e2ab894fdeaa67824eb32103cda947f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d4ee5f8e2ab894fdeaa67824eb32103cda947f8"}], "stats": {"total": 60, "additions": 38, "deletions": 22}, "files": [{"sha": "a85b6e7433e61f92e602f2ae81dbd8173e29c830", "filename": "gcc/ada/exp_fixd.adb", "status": "modified", "additions": 38, "deletions": 22, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9884fc7e79e0753299169a5045ba054520896ac6/gcc%2Fada%2Fexp_fixd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9884fc7e79e0753299169a5045ba054520896ac6/gcc%2Fada%2Fexp_fixd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_fixd.adb?ref=9884fc7e79e0753299169a5045ba054520896ac6", "patch": "@@ -447,15 +447,22 @@ package body Exp_Fixd is\n      (N       : Node_Id;\n       X, Y, Z : Node_Id) return Node_Id\n    is\n+      X_Size : constant Nat := UI_To_Int (RM_Size (Etype (X)));\n       Y_Size : constant Nat := UI_To_Int (RM_Size (Etype (Y)));\n       Z_Size : constant Nat := UI_To_Int (RM_Size (Etype (Z)));\n+      D_Size : constant Nat := Y_Size + Z_Size;\n+      M_Size : constant Nat := Nat'Max (X_Size, Nat'Max (Y_Size, Z_Size));\n       Expr   : Node_Id;\n \n    begin\n       --  If the denominator fits in Max_Integer_Size bits, we can build the\n-      --  operations directly without causing any intermediate overflow.\n+      --  operations directly without causing any intermediate overflow. But\n+      --  for backward compatibility reasons, we use a 128-bit divide only\n+      --  if one of the operands is already larger than 64 bits.\n \n-      if Y_Size + Z_Size <= System_Max_Integer_Size then\n+      if D_Size <= System_Max_Integer_Size\n+        and then (D_Size <= 64 or else M_Size > 64)\n+      then\n          return Build_Divide (N, X, Build_Multiply (N, Y, Z));\n \n       --  Otherwise we use the runtime routine\n@@ -518,6 +525,7 @@ package body Exp_Fixd is\n       X_Size : constant Nat := UI_To_Int (RM_Size (Etype (X)));\n       Y_Size : constant Nat := UI_To_Int (RM_Size (Etype (Y)));\n       Z_Size : constant Nat := UI_To_Int (RM_Size (Etype (Z)));\n+      M_Size : constant Nat := Nat'Max (X_Size, Nat'Max (Y_Size, Z_Size));\n \n       QR_Id  : RE_Id;\n       QR_Siz : Nat;\n@@ -546,17 +554,17 @@ package body Exp_Fixd is\n          QR_Typ := Standard_Integer_64;\n          QR_Id  := RE_Null;\n \n-      elsif QR_Siz <= 128 and then System_Max_Integer_Size = 128 then\n-         QR_Typ := Standard_Integer_128;\n-         QR_Id  := RE_Null;\n-\n-      --  For more than Max_Integer_Size bits, we use the integer defined in\n-      --  Interfaces, so that it can be handled by the runtime routine.\n+      --  For backward compatibility reasons, we use a 128-bit divide only\n+      --  if one of the operands is already larger than 64 bits.\n \n-      elsif System_Max_Integer_Size < 128 then\n+      elsif System_Max_Integer_Size < 128 or else M_Size <= 64 then\n          QR_Typ := RTE (RE_Integer_64);\n          QR_Id  := RE_Double_Divide64;\n \n+      elsif QR_Siz <= 128 then\n+         QR_Typ := Standard_Integer_128;\n+         QR_Id  := RE_Null;\n+\n       else\n          QR_Typ := RTE (RE_Integer_128);\n          QR_Id  := RE_Double_Divide128;\n@@ -571,9 +579,9 @@ package body Exp_Fixd is\n       Set_Etype (Qnn, QR_Typ);\n       Set_Etype (Rnn, QR_Typ);\n \n-      --  Case that we can compute the denominator in Max_Integer_Size bits\n+      --  Case where we can compute the denominator in Max_Integer_Size bits\n \n-      if QR_Siz <= System_Max_Integer_Size then\n+      if QR_Id = RE_Null then\n \n          --  Create temporaries for numerator and denominator and set Etypes,\n          --  so that New_Occurrence_Of picks them up for Build_xxx calls.\n@@ -829,13 +837,20 @@ package body Exp_Fixd is\n    is\n       X_Size : constant Nat := UI_To_Int (RM_Size (Etype (X)));\n       Y_Size : constant Nat := UI_To_Int (RM_Size (Etype (Y)));\n+      Z_Size : constant Nat := UI_To_Int (RM_Size (Etype (Z)));\n+      N_Size : constant Nat := X_Size + Y_Size;\n+      M_Size : constant Nat := Nat'Max (X_Size, Nat'Max (Y_Size, Z_Size));\n       Expr   : Node_Id;\n \n    begin\n       --  If the numerator fits in Max_Integer_Size bits, we can build the\n-      --  operations directly without causing any intermediate overflow.\n+      --  operations directly without causing any intermediate overflow. But\n+      --  for backward compatibility reasons, we use a 128-bit divide only\n+      --  if one of the operands is already larger than 64 bits.\n \n-      if X_Size + Y_Size <= System_Max_Integer_Size then\n+      if N_Size <= System_Max_Integer_Size\n+        and then (N_Size <= 64 or else M_Size > 64)\n+      then\n          return Build_Divide (N, Build_Multiply (N, X, Y), Z);\n \n       --  Otherwise we use the runtime routine\n@@ -895,6 +910,7 @@ package body Exp_Fixd is\n       X_Size : constant Nat := UI_To_Int (RM_Size (Etype (X)));\n       Y_Size : constant Nat := UI_To_Int (RM_Size (Etype (Y)));\n       Z_Size : constant Nat := UI_To_Int (RM_Size (Etype (Z)));\n+      M_Size : constant Nat := Nat'Max (X_Size, Nat'Max (Y_Size, Z_Size));\n \n       QR_Id  : RE_Id;\n       QR_Siz : Nat;\n@@ -923,17 +939,17 @@ package body Exp_Fixd is\n          QR_Typ := Standard_Integer_64;\n          QR_Id  := RE_Null;\n \n-      elsif QR_Siz <= 128 and then System_Max_Integer_Size = 128 then\n-         QR_Typ := Standard_Integer_128;\n-         QR_Id  := RE_Null;\n-\n-      --  For more than Max_Integer_Size bits, we use the integer defined in\n-      --  Interfaces, so that it can be handled by the runtime routine.\n+      --  For backward compatibility reasons, we use a 128-bit divide only\n+      --  if one of the operands is already larger than 64 bits.\n \n-      elsif System_Max_Integer_Size < 128 then\n+      elsif System_Max_Integer_Size < 128 or else M_Size <= 64 then\n          QR_Typ := RTE (RE_Integer_64);\n          QR_Id  := RE_Scaled_Divide64;\n \n+      elsif QR_Siz <= 128 then\n+         QR_Typ := Standard_Integer_128;\n+         QR_Id  := RE_Null;\n+\n       else\n          QR_Typ := RTE (RE_Integer_128);\n          QR_Id  := RE_Scaled_Divide128;\n@@ -948,9 +964,9 @@ package body Exp_Fixd is\n       Set_Etype (Qnn, QR_Typ);\n       Set_Etype (Rnn, QR_Typ);\n \n-      --  Case that we can compute the numerator in Max_Integer_Size bits\n+      --  Case where we can compute the numerator in Max_Integer_Size bits\n \n-      if QR_Siz <= System_Max_Integer_Size then\n+      if QR_Id = RE_Null then\n          Nnn := Make_Temporary (Loc, 'N');\n          Dnn := Make_Temporary (Loc, 'D');\n "}]}