{"sha": "0a7394bc1ac70f2a16ee15731457af04fb0b6e48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGE3Mzk0YmMxYWM3MGYyYTE2ZWUxNTczMTQ1N2FmMDRmYjBiNmU0OA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-11-10T04:29:45Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-11-10T04:29:45Z"}, "message": "Makefile.in (C_AND_OBJC_OBJS): Add c-dump.o.\n\n\t* Makefile.in (C_AND_OBJC_OBJS): Add c-dump.o.\n\t(c-dump.o): New target.\n\t* c-common.h (flag_dump_translation_unit): New variable.\n\t(C_TYPE_QUALS): New macro.\n\t(strip_array_types): New function.\n\t(DECL_C_BIT_FIELD): New macro.\n\t(SET_DECL_C_BIT_FIELD): Likewise.\n\t(CLEAR_DECL_C_BIT_FIELD): Likewise.\n\t(dump_info_p): New typedef.\n\t(dump_tree_fn): Likewise.\n\t(lang_dump_tree): New variable.\n\t(dump_node_to_file): New function.\n\t* c-common.c (flag_dump_translation_unit): Define it.\n\t(strip_array_types): New function.\n\t* c-decl.c (c_decode_option): Handle -fdump-translation-unit.\n\t* c-lang.c (finish_file): Call dump_node_to_file if\n\tflag_dump_translation_unit.\n\t* c-semantics.c (mark_rtl_for_local_static): Fix typo in comment.\n\t* c-tree.h (DECL_C_BIT_FIELD): Remove declaration.\n\t* c-dump.c: New file.\n\n\t* Make-lang.in (CXX_C_OBJS): Add c-dump.o.\n\t(dump.o): Update dependency list.\n\t* cp-tree.h (DECL_MAYBE_TEMPLATE): Remove.\n\t(flag_dump_translation_unit): Likewise.\n\t(CP_TYPE_QUALS): Adjust definition.\n\t(DECL_C_BIT_FIELD): Remove.\n\t(SET_DECL_C_BIT_FIELD): Likewise.\n\t(CLEAR_DECL_C_BIT_FIELD): Likewise.\n\t(add_maybe_template): Likewise.\n\t(strip_array_types): Likewise.\n\t(dump_node_to_file): Likewise.\n\t(cp_dump_tree): New function.\n\t* decl.c (init_decl_processing): Set lang_dump_tree.\n\t* decl2.c (flag_dump_translation_unit): Remove.\n\t* dump.c: Move most of it to ../c-dump.c.\n\t(cp_dump_tree): New function.\n\t* pt.c (add_maybe_template): Remove.\n\t* typeck.c (strip_array_types): Likewise.\n\nFrom-SVN: r37358", "tree": {"sha": "6fdac42a5241d2f4e1527d266faf70cae27bb05d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6fdac42a5241d2f4e1527d266faf70cae27bb05d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a7394bc1ac70f2a16ee15731457af04fb0b6e48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a7394bc1ac70f2a16ee15731457af04fb0b6e48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a7394bc1ac70f2a16ee15731457af04fb0b6e48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/comments", "author": null, "committer": null, "parents": [{"sha": "abffe289db68ad3968cd592dc33a00500a07aaba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abffe289db68ad3968cd592dc33a00500a07aaba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abffe289db68ad3968cd592dc33a00500a07aaba"}], "stats": {"total": 1781, "additions": 933, "deletions": 848}, "files": [{"sha": "52dd9cefe969eb1dc77eaabb0be619f3457842e3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0a7394bc1ac70f2a16ee15731457af04fb0b6e48", "patch": "@@ -1,3 +1,26 @@\n+2000-11-09  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* Makefile.in (C_AND_OBJC_OBJS): Add c-dump.o.\n+\t(c-dump.o): New target.\n+\t* c-common.h (flag_dump_translation_unit): New variable.\n+\t(C_TYPE_QUALS): New macro.\n+\t(strip_array_types): New function.\n+\t(DECL_C_BIT_FIELD): New macro.\n+\t(SET_DECL_C_BIT_FIELD): Likewise.\n+\t(CLEAR_DECL_C_BIT_FIELD): Likewise.\n+\t(dump_info_p): New typedef.\n+\t(dump_tree_fn): Likewise.\n+\t(lang_dump_tree): New variable.\n+\t(dump_node_to_file): New function.\n+\t* c-common.c (flag_dump_translation_unit): Define it.\n+\t(strip_array_types): New function.\n+\t* c-decl.c (c_decode_option): Handle -fdump-translation-unit.\n+\t* c-lang.c (finish_file): Call dump_node_to_file if \n+\tflag_dump_translation_unit.\n+\t* c-semantics.c (mark_rtl_for_local_static): Fix typo in comment.\n+\t* c-tree.h (DECL_C_BIT_FIELD): Remove declaration.\n+\t* c-dump.c: New file.\n+\t\n 2000-11-09  Christopher Faylor <cgf@cygnus.com>\n \n \t* config/i386/cygwin.h: Add mingw startfile prefix."}, {"sha": "2ee1d5c5498921636861f1c71cebb3216366edc5", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0a7394bc1ac70f2a16ee15731457af04fb0b6e48", "patch": "@@ -723,7 +723,7 @@ SUBDIR_FLAGS_TO_PASS = $(ORDINARY_FLAGS_TO_PASS) \\\n \n # Language-specific object files for C and Objective C.\n C_AND_OBJC_OBJS = c-errors.o c-lex.o c-pragma.o c-decl.o c-typeck.o \\\n-  c-convert.o c-aux-info.o c-common.o c-semantics.o $(MAYBE_CPPLIB)\n+  c-convert.o c-aux-info.o c-common.o c-semantics.o c-dump.o $(MAYBE_CPPLIB)\n \n # Language-specific object files for C.\n C_OBJS = c-parse.o c-lang.o $(C_AND_OBJC_OBJS)\n@@ -1224,6 +1224,10 @@ c-semantics.o : c-semantics.c $(CONFIG_H) system.h $(TREE_H) $(C_TREE_H) \\\n \tc-lex.h flags.h toplev.h output.h c-pragma.h $(RTL_H) $(GGC_H) \\\n \t$(EXPR_H)\n \n+c-dump.o: c-dump.c $(CONFIG_H) system.h $(TREE_H) $(C_TREE_H) \\\n+\tc-lex.h flags.h toplev.h output.h c-pragma.h $(RTL_H) $(GGC_H) \\\n+\t$(EXPR_H) $(SPLAY_TREE_H) c-dump.h\n+\n # Language-independent files.\n \n DRIVER_DEFINES = \\"}, {"sha": "c8e9c123c1bfbe35cd7b69b102c456a443e22518", "filename": "gcc/c-common.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=0a7394bc1ac70f2a16ee15731457af04fb0b6e48", "patch": "@@ -149,6 +149,11 @@ int flag_no_builtin;\n \n int flag_no_nonansi_builtin;\n \n+/* If non-NULL, dump the tree structure for the entire translation\n+   unit to this file.  */\n+\n+const char *flag_dump_translation_unit;\n+\n /* Nonzero means warn about possible violations of sequence point rules.  */\n \n int warn_sequence_point;\n@@ -5398,6 +5403,19 @@ self_promoting_args_p (parms)\n   return 1;\n }\n \n+/* Recursively examines the array elements of TYPE, until a non-array\n+   element type is found.  */\n+\n+tree\n+strip_array_types (type)\n+     tree type;\n+{\n+  while (TREE_CODE (type) == ARRAY_TYPE)\n+    type = TREE_TYPE (type);\n+\n+  return type;\n+}\n+\n /* Recognize certain built-in functions so we can make tree-codes\n    other than CALL_EXPR.  We do this when it enables fold-const.c\n    to do something useful.  */"}, {"sha": "41e771cf7800d47ea43e155a052276510f9a06ca", "filename": "gcc/c-common.h", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=0a7394bc1ac70f2a16ee15731457af04fb0b6e48", "patch": "@@ -379,6 +379,11 @@ extern int flag_no_builtin;\n \n extern int flag_no_nonansi_builtin;\n \n+/* If non-NULL, dump the tree structure for the entire translation\n+   unit to this file.  */\n+\n+extern const char *flag_dump_translation_unit;\n+\n /* Nonzero means warn about suggesting putting in ()'s.  */\n \n extern int warn_parentheses;\n@@ -398,6 +403,14 @@ extern int warn_conversion;\n #define C_TYPE_FUNCTION_P(type) \\\n   (TREE_CODE (type) == FUNCTION_TYPE)\n \n+/* Return the qualifiers that apply to this type.  In C++, that means\n+   descending through array types.  Note that this macro evaluates its\n+   arguments mor than once.  */\n+#define C_TYPE_QUALS(TYPE)\t\t\t\t\\\n+  (TYPE_QUALS ((TREE_CODE (TYPE) == ARRAY_TYPE \t\t\\\n+\t\t&& c_language == clk_cplusplus)\t\t\\\n+\t       ? strip_array_types (TYPE) : TYPE))\n+\n /* For convenience we define a single macro to identify the class of\n    object or incomplete types.  */\n #define C_TYPE_OBJECT_OR_INCOMPLETE_P(type) \\\n@@ -480,6 +493,7 @@ extern tree build_va_arg\t\t\tPARAMS ((tree, tree));\n \n extern int self_promoting_args_p\t\tPARAMS ((tree));\n extern tree simple_type_promotes_to\t\tPARAMS ((tree));\n+extern tree strip_array_types                   PARAMS ((tree));\n \n /* These macros provide convenient access to the various _STMT nodes.  */\n \n@@ -657,6 +671,14 @@ extern int anon_aggr_type_p                     PARAMS ((tree));\n    sub-variables that make up the anonymous union.  */\n #define DECL_ANON_UNION_ELEMS(NODE) DECL_ARGUMENTS ((NODE))\n \n+/* In a FIELD_DECL, nonzero if the decl was originally a bitfield.  */\n+#define DECL_C_BIT_FIELD(NODE) \\\n+  (DECL_LANG_FLAG_4 (FIELD_DECL_CHECK (NODE)) == 1)\n+#define SET_DECL_C_BIT_FIELD(NODE) \\\n+  (DECL_LANG_FLAG_4 (FIELD_DECL_CHECK (NODE)) = 1)\n+#define CLEAR_DECL_C_BIT_FIELD(NODE) \\\n+  (DECL_LANG_FLAG_4 (FIELD_DECL_CHECK (NODE)) = 0)\n+\n extern void emit_local_var                      PARAMS ((tree));\n extern void make_rtl_for_local_static           PARAMS ((tree));\n extern tree expand_cond                         PARAMS ((tree));\n@@ -722,6 +744,20 @@ extern int c_safe_from_p                        PARAMS ((rtx, tree));\n \n #endif\n \n+/* In dump.c */\n+\n+typedef struct dump_info *dump_info_p;\n+\n+/* A callback function used dump language-specific parts of tree\n+   nodes.  Returns non-zero if it does not want the usual dumping of\n+   the second argument.  */\n+\n+typedef int (*dump_tree_fn) PARAMS ((dump_info_p, tree));\n+\n+extern dump_tree_fn lang_dump_tree;\n+\n+extern void dump_node_to_file                   PARAMS ((tree, const char *));\n+\n /* Information recorded about each file examined during compilation.  */\n \n struct c_fileinfo"}, {"sha": "45dbb2c4d83682075dd6a0b91583431d77cf579f", "filename": "gcc/c-decl.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=0a7394bc1ac70f2a16ee15731457af04fb0b6e48", "patch": "@@ -510,6 +510,7 @@ c_decode_option (argc, argv)\n      char **argv;\n {\n   int strings_processed;\n+  const char *option_value = NULL;\n   char *p = argv[0];\n #if USE_CPPLIB\n   strings_processed = cpp_handle_option (&parse_in, argc, argv);\n@@ -667,6 +668,14 @@ c_decode_option (argc, argv)\n     flag_no_builtin = 0;\n   else if (!strcmp (p, \"-fno-builtin\"))\n     flag_no_builtin = 1;\n+  else if ((option_value\n+\t    = skip_leading_substring (p, \"-fdump-translation-unit-\")))\n+    {\n+      if (p[22] == '\\0')\n+\terror (\"no file specified with -fdump-translation-unit\");\n+      else\n+\tflag_dump_translation_unit = option_value;\n+    }\n   else if (!strcmp (p, \"-ansi\"))\n     goto iso_1990;\n   else if (!strcmp (p, \"-Werror-implicit-function-declaration\"))\n@@ -5464,7 +5473,8 @@ finish_struct (t, fieldlist, attributes)\n \t\t\t\t   \"`%s' is narrower than values of its type\");\n \n \t      DECL_SIZE (x) = bitsize_int (width);\n-\t      DECL_BIT_FIELD (x) = DECL_C_BIT_FIELD (x) = 1;\n+\t      DECL_BIT_FIELD (x) = 1;\n+\t      SET_DECL_C_BIT_FIELD (x);\n \n \t      if (width == 0)\n \t\t{"}, {"sha": "30b0816fe7fcb7b641e0da148fdbae90f7f91f30", "filename": "gcc/c-dump.c", "status": "added", "additions": 768, "deletions": 0, "changes": 768, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2Fc-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2Fc-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-dump.c?ref=0a7394bc1ac70f2a16ee15731457af04fb0b6e48", "patch": "@@ -0,0 +1,768 @@\n+/* Tree-dumping functionality for intermediate representation.\n+   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+   Written by Mark Mitchell <mark@codesourcery.com>\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"tree.h\"\n+#include \"c-common.h\"\n+#include \"splay-tree.h\"\n+#include \"diagnostic.h\"\n+#include \"toplev.h\"\n+#include \"c-dump.h\"\n+\n+/* A callback function used dump language-specific parts of tree\n+   nodes.  Returns non-zero if it does not want the usual dumping of\n+   the second argument.  */\n+\n+dump_tree_fn lang_dump_tree;\n+\n+static unsigned int queue PARAMS ((dump_info_p, tree, int));\n+static void dump_index PARAMS ((dump_info_p, unsigned int));\n+static void dequeue_and_dump PARAMS ((dump_info_p));\n+static void dump_new_line PARAMS ((dump_info_p));\n+static void dump_maybe_newline PARAMS ((dump_info_p));\n+static void dump_string_field PARAMS ((dump_info_p, const char *, const char *));\n+static void dump_node PARAMS ((tree, FILE *));\n+\n+/* Add T to the end of the queue of nodes to dump.  Returns the index\n+   assigned to T.  */\n+\n+static unsigned int\n+queue (di, t, flags)\n+     dump_info_p di;\n+     tree t;\n+     int flags;\n+{\n+  dump_queue_p dq;\n+  dump_node_info_p dni;\n+  unsigned int index;\n+\n+  /* Assign the next available index to T.  */\n+  index = ++di->index;\n+\n+  /* Obtain a new queue node.  */\n+  if (di->free_list)\n+    {\n+      dq = di->free_list;\n+      di->free_list = dq->next;\n+    }\n+  else\n+    dq = (dump_queue_p) xmalloc (sizeof (struct dump_queue));\n+\n+  /* Create a new entry in the splay-tree.  */\n+  dni = (dump_node_info_p) xmalloc (sizeof (struct dump_node_info));\n+  dni->index = index;\n+  dni->binfo_p = ((flags & DUMP_BINFO) != 0);\n+  dq->node = splay_tree_insert (di->nodes, (splay_tree_key) t, \n+\t\t\t\t(splay_tree_value) dni);\n+\n+  /* Add it to the end of the queue.  */\n+  dq->next = 0;\n+  if (!di->queue_end)\n+    di->queue = dq;\n+  else\n+    di->queue_end->next = dq;\n+  di->queue_end = dq;\n+\n+  /* Return the index.  */\n+  return index;\n+}\n+\n+static void\n+dump_index (di, index)\n+     dump_info_p di;\n+     unsigned int index;\n+{\n+  fprintf (di->stream, \"@%-6u \", index);\n+  di->column += 8;\n+}\n+\n+/* If T has not already been output, queue it for subsequent output.\n+   FIELD is a string to print before printing the index.  Then, the\n+   index of T is printed.  */\n+\n+void\n+queue_and_dump_index (di, field, t, flags)\n+     dump_info_p di;\n+     const char *field;\n+     tree t;\n+     int flags;\n+{\n+  unsigned int index;\n+  splay_tree_node n;\n+\n+  /* If there's no node, just return.  This makes for fewer checks in\n+     our callers.  */\n+  if (!t)\n+    return;\n+\n+  /* See if we've already queued or dumped this node.  */\n+  n = splay_tree_lookup (di->nodes, (splay_tree_key) t);\n+  if (n)\n+    index = ((dump_node_info_p) n->value)->index;\n+  else\n+    /* If we haven't, add it to the queue.  */\n+    index = queue (di, t, flags);\n+\n+  /* Print the index of the node.  */\n+  dump_maybe_newline (di);\n+  fprintf (di->stream, \"%-4s: \", field);\n+  di->column += 6;\n+  dump_index (di, index);\n+}\n+\n+/* Dump the type of T.  */\n+\n+void\n+queue_and_dump_type (di, t)\n+     dump_info_p di;\n+     tree t;\n+{\n+  queue_and_dump_index (di, \"type\", TREE_TYPE (t), DUMP_NONE);\n+}\n+\n+/* Insert a new line in the dump output, and indent to an appropriate\n+   place to start printing more fields.  */\n+\n+static void\n+dump_new_line (di)\n+     dump_info_p di;\n+{\n+  fprintf (di->stream, \"\\n%25s\", \"\");\n+  di->column = 25;\n+}\n+\n+/* If necessary, insert a new line.  */\n+\n+static void\n+dump_maybe_newline (di)\n+     dump_info_p di;\n+{\n+  /* See if we need a new line.  */\n+  if (di->column > 53)\n+    dump_new_line (di);\n+  /* See if we need any padding.  */\n+  else if ((di->column - 25) % 14 != 0)\n+    {\n+      fprintf (di->stream, \"%*s\", 14 - ((di->column - 25) % 14), \"\");\n+      di->column += 14 - (di->column - 25) % 14;\n+    }\n+}\n+\n+/* Dump I using FIELD to identity it.  */\n+\n+void\n+dump_int (di, field, i)\n+     dump_info_p di;\n+     const char *field;\n+     int i;\n+{\n+  dump_maybe_newline (di);\n+  fprintf (di->stream, \"%-4s: %-7d \", field, i);\n+  di->column += 14;\n+}\n+\n+/* Dump the string S.  */\n+\n+void\n+dump_string (di, string)\n+     dump_info_p di;\n+     const char *string;\n+{\n+  dump_maybe_newline (di);\n+  fprintf (di->stream, \"%-13s \", string);\n+  if (strlen (string) > 13)\n+    di->column += strlen (string) + 1;\n+  else\n+    di->column += 14;\n+}\n+\n+/* Dump the string field S.  */\n+\n+static void\n+dump_string_field (di, field, string)\n+     dump_info_p di;\n+     const char *field;\n+     const char *string;\n+{\n+  dump_maybe_newline (di);\n+  fprintf (di->stream, \"%-4s: %-7s \", field, string);\n+  if (strlen (string) > 7)\n+    di->column += 6 + strlen (string) + 1;\n+  else\n+    di->column += 14;\n+}\n+\n+/* Dump information common to statements from STMT.  */\n+\n+void\n+dump_stmt (di, t)\n+     dump_info_p di;\n+     tree t;\n+{\n+  dump_int (di, \"line\", STMT_LINENO (t));\n+}\n+\n+/* Dump the next statement after STMT.  */\n+\n+void\n+dump_next_stmt (di, t)\n+     dump_info_p di;\n+     tree t;\n+{\n+  dump_child (\"next\", TREE_CHAIN (t));\n+}\n+\n+/* Dump the next node in the queue.  */\n+\n+static void \n+dequeue_and_dump (di)\n+     dump_info_p di;\n+{\n+  dump_queue_p dq;\n+  splay_tree_node stn;\n+  dump_node_info_p dni;\n+  tree t;\n+  unsigned int index;\n+  enum tree_code code;\n+  char code_class;\n+  const char* code_name;\n+\n+  /* Get the next node from the queue.  */\n+  dq = di->queue;\n+  stn = dq->node;\n+  t = (tree) stn->key;\n+  dni = (dump_node_info_p) stn->value;\n+  index = dni->index;\n+\n+  /* Remove the node from the queue, and put it on the free list.  */\n+  di->queue = dq->next;\n+  if (!di->queue)\n+    di->queue_end = 0;\n+  dq->next = di->free_list;\n+  di->free_list = dq;\n+\n+  /* Print the node index.  */\n+  dump_index (di, index);\n+  /* And the type of node this is.  */\n+  if (dni->binfo_p)\n+    code_name = \"binfo\";\n+  else\n+    code_name = tree_code_name[(int) TREE_CODE (t)];\n+  fprintf (di->stream, \"%-16s \", code_name);\n+  di->column = 25;\n+\n+  /* Figure out what kind of node this is.  */\n+  code = TREE_CODE (t);\n+  code_class = TREE_CODE_CLASS (code);\n+\n+  /* Although BINFOs are TREE_VECs, we dump them specially so as to be\n+     more informative.  */\n+  if (dni->binfo_p)\n+    {\n+      if (TREE_VIA_PUBLIC (t))\n+\tdump_string (di, \"pub\");\n+      else if (TREE_VIA_PROTECTED (t))\n+\tdump_string (di, \"prot\");\n+      else if (TREE_VIA_PRIVATE (t))\n+\tdump_string (di, \"priv\");\n+      if (TREE_VIA_VIRTUAL (t))\n+\tdump_string (di, \"virt\");\n+\t    \n+      dump_child (\"type\", BINFO_TYPE (t));\n+      dump_child (\"base\", BINFO_BASETYPES (t));\n+\n+      goto done;\n+    }\n+\n+  /* We can knock off a bunch of expression nodes in exactly the same\n+     way.  */\n+  if (IS_EXPR_CODE_CLASS (code_class))\n+    {\n+      /* If we're dumping children, dump them now.  */\n+      queue_and_dump_type (di, t);\n+\n+      switch (code_class)\n+\t{\n+\tcase '1':\n+\t  dump_child (\"op 0\", TREE_OPERAND (t, 0));\n+\t  break;\n+\t      \n+\tcase '2':\n+\tcase '<':\n+\t  dump_child (\"op 0\", TREE_OPERAND (t, 0));\n+\t  dump_child (\"op 1\", TREE_OPERAND (t, 1));\n+\t  break;\n+\t      \n+\tcase 'e':\n+\t  /* These nodes are handled explicitly below.  */\n+\t  break;\n+\t      \n+\tdefault:\n+\t  abort();\n+\t}\n+    }\n+  else if (DECL_P (t))\n+    {\n+      /* All declarations have names.  */\n+      if (DECL_NAME (t))\n+\tdump_child (\"name\", DECL_NAME (t));\n+      if (DECL_ASSEMBLER_NAME (t) \n+\t  && DECL_ASSEMBLER_NAME (t) != DECL_NAME (t))\n+\tdump_child (\"mngl\", DECL_ASSEMBLER_NAME (t));\n+      /* And types.  */\n+      queue_and_dump_type (di, t);\n+      dump_child (\"scpe\", DECL_CONTEXT (t));\n+      /* And a source position.  */\n+      if (DECL_SOURCE_FILE (t))\n+\t{\n+\t  const char *filename = strrchr (DECL_SOURCE_FILE (t), '/');\n+\t  if (!filename)\n+\t    filename = DECL_SOURCE_FILE (t);\n+\t  else\n+\t    /* Skip the slash.  */\n+\t    ++filename;\n+\n+\t  dump_maybe_newline (di);\n+\t  fprintf (di->stream, \"srcp: %s:%-6d \", filename, \n+\t\t   DECL_SOURCE_LINE (t));\n+\t  di->column += 6 + strlen (filename) + 8;\n+\t}\n+      /* And any declaration can be compiler-generated.  */\n+      if (DECL_ARTIFICIAL (t))\n+\tdump_string (di, \"artificial\");\n+      if (TREE_CHAIN (t))\n+\tdump_child (\"chan\", TREE_CHAIN (t));\n+    }\n+  else if (code_class == 't')\n+    {\n+      /* All types have qualifiers.  */\n+      int quals = C_TYPE_QUALS (t);\n+      if (quals != TYPE_UNQUALIFIED)\n+\t{\n+\t  fprintf (di->stream, \"qual: %c%c%c     \",\n+\t\t   (quals & TYPE_QUAL_CONST) ? 'c' : ' ',\n+\t\t   (quals & TYPE_QUAL_VOLATILE) ? 'v' : ' ',\n+\t\t   (quals & TYPE_QUAL_RESTRICT) ? 'r' : ' ');\n+\t  di->column += 14;\n+\t}\n+\n+      /* All types have associated declarations.  */\n+      dump_child (\"name\", TYPE_NAME (t));\n+\n+      /* All types have a main variant.  */\n+      if (TYPE_MAIN_VARIANT (t) != t)\n+\tdump_child (\"unql\", TYPE_MAIN_VARIANT (t));\n+      \n+      /* And sizes.  */\n+      dump_child (\"size\", TYPE_SIZE (t));\n+\n+      /* All types have alignments.  */\n+      dump_int (di, \"algn\", TYPE_ALIGN (t));\n+    }\n+  else if (code_class == 'c')\n+    /* All constants can have types.  */\n+    queue_and_dump_type (di, t);\n+\n+  /* Give the language-specific code a chance to print something.  If\n+     it's completely taken care of things, don't bother printing\n+     anything more ourselves.  */\n+  if (lang_dump_tree && (*lang_dump_tree) (di, t))\n+    goto done;\n+\n+  /* Now handle the various kinds of nodes.  */\n+  switch (code)\n+    {\n+      int i;\n+\n+    case IDENTIFIER_NODE:\n+      dump_string_field (di, \"strg\", IDENTIFIER_POINTER (t));\n+      dump_int (di, \"lngt\", IDENTIFIER_LENGTH (t));\n+      break;\n+\n+    case TREE_LIST:\n+      dump_child (\"purp\", TREE_PURPOSE (t));\n+      dump_child (\"valu\", TREE_VALUE (t));\n+      dump_child (\"chan\", TREE_CHAIN (t));\n+      break;\n+\n+    case TREE_VEC:\n+      dump_int (di, \"lngt\", TREE_VEC_LENGTH (t));\n+      for (i = 0; i < TREE_VEC_LENGTH (t); ++i)\n+\t{\n+\t  char buffer[32];\n+\t  sprintf (buffer, \"%u\", i);\n+\t  dump_child (buffer, TREE_VEC_ELT (t, i));\n+\t}\n+      break;\n+\n+    case INTEGER_TYPE:\n+    case ENUMERAL_TYPE:\n+      dump_int (di, \"prec\", TYPE_PRECISION (t));\n+      if (TREE_UNSIGNED (t))\n+\tdump_string (di, \"unsigned\");\n+      dump_child (\"min\", TYPE_MIN_VALUE (t));\n+      dump_child (\"max\", TYPE_MAX_VALUE (t));\n+\n+      if (code == ENUMERAL_TYPE)\n+\tdump_child (\"csts\", TYPE_VALUES (t));\n+      break;\n+\n+    case REAL_TYPE:\n+      dump_int (di, \"prec\", TYPE_PRECISION (t));\n+      break;\n+\n+    case POINTER_TYPE:\n+      dump_child (\"ptd\", TREE_TYPE (t));\n+      break;\n+\n+    case REFERENCE_TYPE:\n+      dump_child (\"refd\", TREE_TYPE (t));\n+      break;\n+\n+    case METHOD_TYPE:\n+      dump_child (\"clas\", TYPE_METHOD_BASETYPE (t));\n+      /* Fall through.  */\n+\n+    case FUNCTION_TYPE:\n+      dump_child (\"retn\", TREE_TYPE (t));\n+      dump_child (\"prms\", TYPE_ARG_TYPES (t));\n+      break;\n+\n+    case ARRAY_TYPE:\n+      dump_child (\"elts\", TREE_TYPE (t));\n+      dump_child (\"domn\", TYPE_DOMAIN (t));\n+      break;\n+\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+      if (TREE_CODE (t) == RECORD_TYPE)\n+\tdump_string (di, \"struct\");\n+      else\n+\tdump_string (di, \"union\");\n+      \n+      dump_child (\"flds\", TYPE_FIELDS (t));\n+      dump_child (\"fncs\", TYPE_METHODS (t));\n+      queue_and_dump_index (di, \"binf\", TYPE_BINFO (t), \n+\t\t\t    DUMP_BINFO);\n+      break;\n+\n+    case CONST_DECL:\n+      dump_child (\"cnst\", DECL_INITIAL (t));\n+      break;\n+\n+    case VAR_DECL:\n+    case PARM_DECL:\n+    case FIELD_DECL:\n+    case RESULT_DECL:\n+      if (TREE_CODE (t) == PARM_DECL)\n+\tdump_child (\"argt\", DECL_ARG_TYPE (t));\n+      else\n+\tdump_child (\"init\", DECL_INITIAL (t));\n+      dump_child (\"size\", DECL_SIZE (t));\n+      dump_int (di, \"algn\", DECL_ALIGN (t));\n+\n+      if (TREE_CODE (t) == FIELD_DECL)\n+\t{\n+\t  if (DECL_C_BIT_FIELD (t))\n+\t    dump_string (di, \"bitfield\");\n+\t  if (DECL_FIELD_OFFSET (t))\n+\t    dump_child (\"bpos\", bit_position (t));\n+\t}\n+      else if (TREE_CODE (t) == VAR_DECL \n+\t       || TREE_CODE (t) == PARM_DECL)\n+\t{\n+\t  dump_int (di, \"used\", TREE_USED (t));\n+\t  if (DECL_REGISTER (t))\n+\t    dump_string (di, \"register\");\n+\t}\n+      break;\n+\n+    case FUNCTION_DECL:\n+      dump_child (\"args\", DECL_ARGUMENTS (t));\n+      if (DECL_EXTERNAL (t))\n+\tdump_string (di, \"undefined\");\n+      if (TREE_PUBLIC (t))\n+\tdump_string (di, \"extern\");\n+      else\n+\tdump_string (di, \"static\");\n+      break;\n+\n+    case ASM_STMT:\n+      dump_stmt (di, t);\n+      if (ASM_VOLATILE_P (t))\n+\tdump_string (di, \"volatile\");\n+      dump_child (\"strg\", ASM_STRING (t));\n+      dump_child (\"outs\", ASM_OUTPUTS (t));\n+      dump_child (\"ins\", ASM_INPUTS (t));\n+      dump_child (\"clbr\", ASM_CLOBBERS (t));\n+      dump_next_stmt (di, t);\n+      break;\n+\n+    case BREAK_STMT:\n+    case CONTINUE_STMT:\n+      dump_stmt (di, t);\n+      dump_next_stmt (di, t);\n+      break;\n+\n+    case CASE_LABEL:\n+      /* Note that a case label is not like other statments; there is\n+\t no way to get the line-number of a case label.  */\n+      dump_child (\"low\", CASE_LOW (t));\n+      dump_child (\"high\", CASE_HIGH (t));\n+      dump_next_stmt (di, t);\n+      break;\n+\n+    case COMPOUND_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"body\", COMPOUND_BODY (t));\n+      dump_next_stmt (di, t);\n+      break;\n+\n+    case DECL_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"decl\", DECL_STMT_DECL (t));\n+      dump_next_stmt (di, t);\n+      break;\n+      \n+    case DO_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"body\", DO_BODY (t));\n+      dump_child (\"cond\", DO_COND (t));\n+      dump_next_stmt (di, t);\n+      break;\n+\n+    case EXPR_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"expr\", EXPR_STMT_EXPR (t));\n+      dump_next_stmt (di, t);\n+      break;\n+\n+    case FOR_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"init\", FOR_INIT_STMT (t));\n+      dump_child (\"cond\", FOR_COND (t));\n+      dump_child (\"expr\", FOR_EXPR (t));\n+      dump_child (\"body\", FOR_BODY (t));\n+      dump_next_stmt (di, t);\n+      break;\n+\n+    case GOTO_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"dest\", GOTO_DESTINATION (t));\n+      dump_next_stmt (di, t);\n+      break;\n+\n+    case IF_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"cond\", IF_COND (t));\n+      dump_child (\"then\", THEN_CLAUSE (t));\n+      dump_child (\"else\", ELSE_CLAUSE (t));\n+      dump_next_stmt (di, t);\n+      break;\n+\n+    case LABEL_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"labl\", LABEL_STMT_LABEL (t));\n+      dump_next_stmt (di, t);\n+      break;\n+\n+    case RETURN_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"expr\", RETURN_EXPR (t));\n+      dump_next_stmt (di, t);\n+      break;\n+\n+    case SWITCH_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"cond\", SWITCH_COND (t));\n+      dump_child (\"body\", SWITCH_BODY (t));\n+      dump_next_stmt (di, t);\n+      break;\n+\n+    case WHILE_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"cond\", WHILE_COND (t));\n+      dump_child (\"body\", WHILE_BODY (t));\n+      dump_next_stmt (di, t);\n+      break;\n+\n+    case SCOPE_STMT:\n+      dump_stmt (di, t);\n+      if (SCOPE_BEGIN_P (t))\n+\tdump_string (di, \"begn\");\n+      else\n+\tdump_string (di, \"end\");\n+      if (SCOPE_NULLIFIED_P (t))\n+\tdump_string (di, \"null\");\n+      if (!SCOPE_NO_CLEANUPS_P (t))\n+\tdump_string (di, \"clnp\");\n+      dump_next_stmt (di, t);\n+      break;\n+\n+    case INTEGER_CST:\n+      if (TREE_INT_CST_HIGH (t))\n+\tdump_int (di, \"high\", TREE_INT_CST_HIGH (t));\n+      dump_int (di, \"low\", TREE_INT_CST_LOW (t));\n+      break;\n+\n+    case STRING_CST:\n+      fprintf (di->stream, \"strg: %-7s \", TREE_STRING_POINTER (t));\n+      dump_int (di, \"lngt\", TREE_STRING_LENGTH (t));\n+      break;\n+\n+    case TRUTH_NOT_EXPR:\n+    case ADDR_EXPR:\n+    case INDIRECT_REF:\n+    case CLEANUP_POINT_EXPR:\n+    case SAVE_EXPR:\n+      /* These nodes are unary, but do not have code class `1'.  */\n+      dump_child (\"op 0\", TREE_OPERAND (t, 0));\n+      break;\n+\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+    case INIT_EXPR:\n+    case MODIFY_EXPR:\n+    case COMPONENT_REF:\n+    case COMPOUND_EXPR:\n+    case ARRAY_REF:\n+    case PREDECREMENT_EXPR:\n+    case PREINCREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+      /* These nodes are binary, but do not have code class `2'.  */\n+      dump_child (\"op 0\", TREE_OPERAND (t, 0));\n+      dump_child (\"op 1\", TREE_OPERAND (t, 1));\n+      break;\n+\n+    case COND_EXPR:\n+      dump_child (\"op 0\", TREE_OPERAND (t, 0));\n+      dump_child (\"op 1\", TREE_OPERAND (t, 1));\n+      dump_child (\"op 2\", TREE_OPERAND (t, 2));\n+      break;\n+\n+    case CALL_EXPR:\n+      dump_child (\"fn\", TREE_OPERAND (t, 0));\n+      dump_child (\"args\", TREE_OPERAND (t, 1));\n+      break;\n+\n+    case CONSTRUCTOR:\n+      dump_child (\"elts\", TREE_OPERAND (t, 1));\n+      break;\n+\n+    case STMT_EXPR:\n+      dump_child (\"stmt\", STMT_EXPR_STMT (t));\n+      break;\n+\n+    case BIND_EXPR:\n+      dump_child (\"vars\", TREE_OPERAND (t, 0));\n+      dump_child (\"body\", TREE_OPERAND (t, 1));\n+      break;\n+\n+    case LOOP_EXPR:\n+      dump_child (\"body\", TREE_OPERAND (t, 0));\n+      break;\n+\n+    case EXIT_EXPR:\n+      dump_child (\"cond\", TREE_OPERAND (t, 0));\n+      break;\n+\n+    case TARGET_EXPR:\n+      dump_child (\"decl\", TREE_OPERAND (t, 0));\n+      dump_child (\"init\", TREE_OPERAND (t, 1));\n+      dump_child (\"clnp\", TREE_OPERAND (t, 2));\n+      /* There really are two possible places the initializer can be.\n+\t After RTL expansion, the second operand is moved to the\n+\t position of the fourth operand, and the second operand\n+\t becomes NULL.  */\n+      dump_child (\"init\", TREE_OPERAND (t, 3));\n+      break;\n+      \n+    case EXPR_WITH_FILE_LOCATION:\n+      dump_child (\"expr\", EXPR_WFL_NODE (t));\n+      break;\n+\n+    default:\n+      /* There are no additional fields to print.  */\n+      break;\n+    }\n+\n+ done:\n+  /* Terminate the line.  */\n+  fprintf (di->stream, \"\\n\");\n+}\n+\n+/* Dump T, and all its children, on STREAM.  */\n+\n+static void\n+dump_node (t, stream)\n+     tree t;\n+     FILE *stream;\n+{\n+  struct dump_info di;\n+  dump_queue_p dq;\n+  dump_queue_p next_dq;\n+\n+  /* Initialize the dump-information structure.  */\n+  di.stream = stream;\n+  di.index = 0;\n+  di.column = 0;\n+  di.queue = 0;\n+  di.queue_end = 0;\n+  di.free_list = 0;\n+  di.nodes = splay_tree_new (splay_tree_compare_pointers, 0, \n+\t\t\t     (splay_tree_delete_value_fn) &free);\n+\n+  /* Queue up the first node.  */\n+  queue (&di, t, DUMP_NONE);\n+\n+  /* Until the queue is empty, keep dumping nodes.  */\n+  while (di.queue)\n+    dequeue_and_dump (&di);\n+\n+  /* Now, clean up.  */\n+  for (dq = di.free_list; dq; dq = next_dq)\n+    {\n+      next_dq = dq->next;\n+      free (dq);\n+    }\n+  splay_tree_delete (di.nodes);\n+}\n+\n+/* Dump T, and all its children, to FILE.  */\n+\n+void\n+dump_node_to_file (t, file)\n+     tree t;\n+     const char *file;\n+{\n+  FILE *f;\n+\n+  f = fopen (file, \"w\");\n+  if (!f)\n+    error (\"could not open dump file `%s'\", file);\n+  else\n+    {\n+      dump_node (t, f);\n+      fclose (f);\n+    }\n+}"}, {"sha": "7259429b10a631a334aa72f2f0f51a3207c19c04", "filename": "gcc/c-lang.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2Fc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2Fc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lang.c?ref=0a7394bc1ac70f2a16ee15731457af04fb0b6e48", "patch": "@@ -268,6 +268,9 @@ finish_file ()\n   \n   if (back_end_hook)\n     (*back_end_hook) (getdecls ());\n+\n+  if (flag_dump_translation_unit)\n+    dump_node_to_file (getdecls (), flag_dump_translation_unit);\n }\n \n /* Called during diagnostic message formatting process to print a"}, {"sha": "8988680415e04448ef68e4ed99589d2bb20d3d99", "filename": "gcc/c-semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-semantics.c?ref=0a7394bc1ac70f2a16ee15731457af04fb0b6e48", "patch": "@@ -283,7 +283,7 @@ make_rtl_for_local_static (decl)\n \n   /* If the DECL_ASSEMBLER_NAME is not the same as the DECL_NAME, then\n      either we already created RTL for this DECL (and since it was a\n-     local variable, its DECL_ASSMEMBLER_NAME got hacked up to prevent\n+     local variable, its DECL_ASSEMBLER_NAME got hacked up to prevent\n      clashes with other local statics with the same name by a previous\n      call to make_decl_rtl), or the user explicitly requested a\n      particular assembly name for this variable, using the GNU"}, {"sha": "efd5083e7ebbf064790543351868327e75367a3a", "filename": "gcc/c-tree.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=0a7394bc1ac70f2a16ee15731457af04fb0b6e48", "patch": "@@ -140,9 +140,6 @@ struct lang_type\n    without prototypes.  */\n #define TYPE_ACTUAL_ARG_TYPES(NODE) TYPE_NONCOPIED_PARTS (NODE)\n \n-/* In a FIELD_DECL, nonzero if the decl was originally a bitfield.  */\n-#define DECL_C_BIT_FIELD(NODE) DECL_LANG_FLAG_4 (NODE)\n-\n \f\n /* in c-lang.c and objc-act.c */\n extern tree lookup_interface\t\t\tPARAMS ((tree));"}, {"sha": "9d79a4cdd39195cc6339d07e4834bfae31ef2c65", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0a7394bc1ac70f2a16ee15731457af04fb0b6e48", "patch": "@@ -1,3 +1,24 @@\n+2000-11-09  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* Make-lang.in (CXX_C_OBJS): Add c-dump.o.\n+\t(dump.o): Update dependency list.\n+\t* cp-tree.h (DECL_MAYBE_TEMPLATE): Remove.\n+\t(flag_dump_translation_unit): Likewise.\n+\t(CP_TYPE_QUALS): Adjust definition.\n+\t(DECL_C_BIT_FIELD): Remove.\n+\t(SET_DECL_C_BIT_FIELD): Likewise.\n+\t(CLEAR_DECL_C_BIT_FIELD): Likewise.\n+\t(add_maybe_template): Likewise.\n+\t(strip_array_types): Likewise.\n+\t(dump_node_to_file): Likewise.\n+\t(cp_dump_tree): New function.\n+\t* decl.c (init_decl_processing): Set lang_dump_tree.\n+\t* decl2.c (flag_dump_translation_unit): Remove.\n+\t* dump.c: Move most of it to ../c-dump.c.\n+\t(cp_dump_tree): New function.\n+\t* pt.c (add_maybe_template): Remove.\n+\t* typeck.c (strip_array_types): Likewise.\n+\t\n 2000-11-07  Eric Christopher  <echristo@redhat.com>\n \n         * decl.c (init_decl_processing): Change definition of"}, {"sha": "e8091f55807e49a3a5e541f8df4ac8f54404dee5", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=0a7394bc1ac70f2a16ee15731457af04fb0b6e48", "patch": "@@ -90,7 +90,7 @@ $(DEMANGLER_PROG): cxxmain.o underscore.o $(LIBDEPS)\n \n # The compiler itself.\n # Shared with C front end:\n-CXX_C_OBJS = c-common.o c-pragma.o c-semantics.o c-lex.o\n+CXX_C_OBJS = c-common.o c-pragma.o c-semantics.o c-lex.o c-dump.o\n \n # Language-specific object files.\n CXX_OBJS = cp/call.o cp/decl.o cp/errfn.o cp/expr.o cp/pt.o cp/typeck2.o \\\n@@ -264,7 +264,7 @@ cp/errfn.o: cp/errfn.c $(CXX_TREE_H) toplev.h\n cp/repo.o: cp/repo.c $(CXX_TREE_H) toplev.h $(GGC_H)\n cp/semantics.o: cp/semantics.c $(CXX_TREE_H) cp/lex.h except.h toplev.h \\\n   flags.h $(GGC_H) output.h $(RTL_H) $(TIMEVAR_H)\n-cp/dump.o: cp/dump.c $(CXX_TREE_H)\n+cp/dump.o: cp/dump.c $(CXX_TREE_H) c-dump.h\n cp/optimize.o: cp/optimize.c $(CXX_TREE_H) rtl.h integrate.h insn-config.h \\\n   input.h\n cp/mangle.o: cp/mangle.c $(CXX_TREE_H) toplev.h"}, {"sha": "67e4c239c1e358fd2924e8a19275154703742e2a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=0a7394bc1ac70f2a16ee15731457af04fb0b6e48", "patch": "@@ -95,7 +95,7 @@ Boston, MA 02111-1307, USA.  */\n    2: DECL_THIS_EXTERN (in VAR_DECL or FUNCTION_DECL).\n       DECL_IMPLICIT_TYPEDEF_P (in a TYPE_DECL)\n    3: DECL_IN_AGGR_P.\n-   4: DECL_MAYBE_TEMPLATE.\n+   4: DECL_C_BIT_FIELD\n    5: DECL_INTERFACE_KNOWN.\n    6: DECL_THIS_STATIC (in VAR_DECL or FUNCTION_DECL).\n    7: DECL_DEAD_FOR_LOCAL (in VAR_DECL).\n@@ -1031,11 +1031,6 @@ extern int warn_ctor_dtor_privacy;\n \n extern int warn_return_type;\n \n-/* If non-NULL, dump the tree structure for the entire translation\n-   unit to this file.  */\n-\n-extern const char *flag_dump_translation_unit;\n-\n /* Nonzero means warn about deprecated conversion from string constant to\n    `char *'.  */\n \n@@ -1237,9 +1232,7 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n \n /* The type qualifiers for this type, including the qualifiers on the\n    elements for an array type.  */\n-#define CP_TYPE_QUALS(NODE)\t\t\t\\\n-  ((TREE_CODE (NODE) != ARRAY_TYPE)\t\t\\\n-   ? TYPE_QUALS (NODE) : cp_type_quals (NODE))\n+#define CP_TYPE_QUALS(NODE) C_TYPE_QUALS (NODE)\n \n /* Nonzero if this type is const-qualified.  */\n #define CP_TYPE_CONST_P(NODE)\t\t\t\t\\\n@@ -2486,14 +2479,6 @@ extern int flag_new_for_scope;\n /* Record whether a typedef for type `int' was actually `signed int'.  */\n #define C_TYPEDEF_EXPLICITLY_SIGNED(exp) DECL_LANG_FLAG_1 ((exp))\n \n-/* In a FIELD_DECL, nonzero if the decl was originally a bitfield.  */\n-#define DECL_C_BIT_FIELD(NODE) \\\n-  (DECL_LANG_FLAG_1 (FIELD_DECL_CHECK (NODE)) == 1)\n-#define SET_DECL_C_BIT_FIELD(NODE) \\\n-  (DECL_LANG_FLAG_1 (FIELD_DECL_CHECK (NODE)) = 1)\n-#define CLEAR_DECL_C_BIT_FIELD(NODE) \\\n-  (DECL_LANG_FLAG_1 (FIELD_DECL_CHECK (NODE)) = 0)\n-\n /* In a FUNCTION_DECL, nonzero if the function cannot be inlined.  */\n #define DECL_UNINLINABLE(NODE) \\\n   (DECL_LANG_SPECIFIC (NODE)->decl_flags.uninlinable)\n@@ -4213,7 +4198,6 @@ extern void do_decl_instantiation\t\tPARAMS ((tree, tree, tree));\n extern void do_type_instantiation\t\tPARAMS ((tree, tree, int));\n extern tree instantiate_decl\t\t\tPARAMS ((tree, int));\n extern tree get_bindings\t\t\tPARAMS ((tree, tree, tree));\n-extern void add_maybe_template\t\t\tPARAMS ((tree, tree));\n extern void pop_tinst_level\t\t\tPARAMS ((void));\n extern int more_specialized_class\t\tPARAMS ((tree, tree));\n extern int is_member_template                   PARAMS ((tree));\n@@ -4546,7 +4530,6 @@ extern tree convert_for_initialization\t\tPARAMS ((tree, tree, tree, int, const ch\n extern int comp_ptr_ttypes\t\t\tPARAMS ((tree, tree));\n extern int ptr_reasonably_similar\t\tPARAMS ((tree, tree));\n extern tree build_ptrmemfunc\t\t\tPARAMS ((tree, tree, int));\n-extern tree strip_array_types                   PARAMS ((tree));\n extern int cp_type_quals                        PARAMS ((tree));\n extern int cp_has_mutable_p                     PARAMS ((tree));\n extern int at_least_as_qualified_p              PARAMS ((tree, tree));\n@@ -4600,9 +4583,6 @@ extern void GNU_xref_assign\t\t\tPARAMS ((tree));\n extern void GNU_xref_hier\t\t\tPARAMS ((tree, tree, int, int, int));\n extern void GNU_xref_member\t\t\tPARAMS ((tree, tree));\n \n-/* in dump.c */\n-extern void dump_node_to_file                   PARAMS ((tree, const char *));\n-\n /* in mangle.c */\n extern void init_mangle                         PARAMS ((void));\n extern tree mangle_decl                         PARAMS ((tree));\n@@ -4617,6 +4597,9 @@ extern tree mangle_thunk                        PARAMS ((tree, tree, tree));\n extern tree mangle_conv_op_name_for_type        PARAMS ((tree));\n extern tree mangle_guard_variable               PARAMS ((tree));\n \n+/* in dump.c */\n+extern int cp_dump_tree                         PARAMS ((dump_info_p, tree));\n+\n /* -- end of C++ */\n \n #endif /* not _CP_TREE_H */"}, {"sha": "a66500f9dcf93e57bfdbafc28ad66964343f635e", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=0a7394bc1ac70f2a16ee15731457af04fb0b6e48", "patch": "@@ -6331,6 +6331,7 @@ init_decl_processing ()\n   free_lang_status = &pop_cp_function_context;\n   mark_lang_status = &mark_cp_function_context;\n   lang_safe_from_p = &c_safe_from_p;\n+  lang_dump_tree = &cp_dump_tree;\n \n   cp_parse_init ();\n   init_decl2 ();"}, {"sha": "43874fb63c02fe1ae07ce8fbd27150c864bf2f78", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=0a7394bc1ac70f2a16ee15731457af04fb0b6e48", "patch": "@@ -236,11 +236,6 @@ int flag_optional_diags = 1;\n \n int flag_const_strings = 1;\n \n-/* If non-NULL, dump the tree structure for the entire translation\n-   unit to this file.  */\n-\n-const char *flag_dump_translation_unit = 0;\n-\n /* Nonzero means warn about deprecated conversion from string constant to\n    `char *'.  */\n "}, {"sha": "077b333135022fc405a73f0729fabe1ddb2a9c8e", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 38, "deletions": 771, "changes": 809, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=0a7394bc1ac70f2a16ee15731457af04fb0b6e48", "patch": "@@ -23,489 +23,52 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #include \"tree.h\"\n #include \"cp-tree.h\"\n+#include \"c-dump.h\"\n \n-/* Flags used with queue functions.  */\n-#define DUMP_NONE     0\n-#define DUMP_BINFO    1\n-\n-/* Information about a node to be dumped.  */\n-\n-typedef struct dump_node_info\n-{\n-  /* The index for the node.  */\n-  unsigned int index;\n-  /* Nonzero if the node is a binfo.  */\n-  unsigned int binfo_p : 1;\n-} *dump_node_info_p;\n-\n-/* A dump_queue is a link in the queue of things to be dumped.  */\n-\n-typedef struct dump_queue\n-{\n-  /* The queued tree node.  */\n-  splay_tree_node node;\n-  /* The next node in the queue.  */\n-  struct dump_queue *next;\n-} *dump_queue_p;\n-\n-/* A dump_info gives information about how we should perform the dump \n-   and about the current state of the dump.  */\n-\n-typedef struct dump_info\n-{\n-  /* The stream on which to dump the information.  */\n-  FILE *stream;\n-  /* The next unused node index.  */\n-  unsigned int index;\n-  /* The next column.  */\n-  unsigned int column;\n-  /* The first node in the queue of nodes to be written out.  */\n-  dump_queue_p queue;\n-  /* The last node in the queue.  */\n-  dump_queue_p queue_end;\n-  /* Free queue nodes.  */\n-  dump_queue_p free_list;\n-  /* The tree nodes which we have already written out.  The \n-     keys are the addresses of the nodes; the values are the integer\n-     indices we assigned them.  */\n-  splay_tree nodes;\n-} *dump_info_p;\n-\n-static unsigned int queue PARAMS ((dump_info_p, tree, int));\n-static void dump_index PARAMS ((dump_info_p, unsigned int));\n-static void queue_and_dump_index PARAMS ((dump_info_p, const char *, tree, int));\n-static void queue_and_dump_type PARAMS ((dump_info_p, tree));\n-static void dequeue_and_dump PARAMS ((dump_info_p));\n-static void dump_new_line PARAMS ((dump_info_p));\n-static void dump_maybe_newline PARAMS ((dump_info_p));\n-static void dump_int PARAMS ((dump_info_p, const char *, int));\n-static void dump_string PARAMS ((dump_info_p, const char *));\n-static void dump_string_field PARAMS ((dump_info_p, const char *, const char *));\n-static void dump_node PARAMS ((tree, FILE *));\n-static void dump_stmt PARAMS ((dump_info_p, tree));\n-static void dump_next_stmt PARAMS ((dump_info_p, tree));\n-\n-/* Add T to the end of the queue of nodes to dump.  Returns the index\n-   assigned to T.  */\n-\n-static unsigned int\n-queue (di, t, flags)\n-     dump_info_p di;\n-     tree t;\n-     int flags;\n-{\n-  dump_queue_p dq;\n-  dump_node_info_p dni;\n-  unsigned int index;\n-\n-  /* Assign the next available index to T.  */\n-  index = ++di->index;\n-\n-  /* Obtain a new queue node.  */\n-  if (di->free_list)\n-    {\n-      dq = di->free_list;\n-      di->free_list = dq->next;\n-    }\n-  else\n-    dq = (dump_queue_p) xmalloc (sizeof (struct dump_queue));\n-\n-  /* Create a new entry in the splay-tree.  */\n-  dni = (dump_node_info_p) xmalloc (sizeof (struct dump_node_info));\n-  dni->index = index;\n-  dni->binfo_p = ((flags & DUMP_BINFO) != 0);\n-  dq->node = splay_tree_insert (di->nodes, (splay_tree_key) t, \n-\t\t\t\t(splay_tree_value) dni);\n-\n-  /* Add it to the end of the queue.  */\n-  dq->next = 0;\n-  if (!di->queue_end)\n-    di->queue = dq;\n-  else\n-    di->queue_end->next = dq;\n-  di->queue_end = dq;\n-\n-  /* Return the index.  */\n-  return index;\n-}\n-\n-static void\n-dump_index (di, index)\n-     dump_info_p di;\n-     unsigned int index;\n-{\n-  fprintf (di->stream, \"@%-6u \", index);\n-  di->column += 8;\n-}\n-\n-/* If T has not already been output, queue it for subsequent output.\n-   FIELD is a string to print before printing the index.  Then, the\n-   index of T is printed.  */\n-\n-static void\n-queue_and_dump_index (di, field, t, flags)\n-     dump_info_p di;\n-     const char *field;\n-     tree t;\n-     int flags;\n-{\n-  unsigned int index;\n-  splay_tree_node n;\n-\n-  /* If there's no node, just return.  This makes for fewer checks in\n-     our callers.  */\n-  if (!t)\n-    return;\n-\n-  /* See if we've already queued or dumped this node.  */\n-  n = splay_tree_lookup (di->nodes, (splay_tree_key) t);\n-  if (n)\n-    index = ((dump_node_info_p) n->value)->index;\n-  else\n-    /* If we haven't, add it to the queue.  */\n-    index = queue (di, t, flags);\n-\n-  /* Print the index of the node.  */\n-  dump_maybe_newline (di);\n-  fprintf (di->stream, \"%-4s: \", field);\n-  di->column += 6;\n-  dump_index (di, index);\n-}\n-\n-/* Dump the type of T.  */\n-\n-static void\n-queue_and_dump_type (di, t)\n+int\n+cp_dump_tree (di, t)\n      dump_info_p di;\n      tree t;\n {\n-  queue_and_dump_index (di, \"type\", TREE_TYPE (t), DUMP_NONE);\n-}\n-\n-/* Insert a new line in the dump output, and indent to an appropriate\n-   place to start printing more fields.  */\n-\n-static void\n-dump_new_line (di)\n-     dump_info_p di;\n-{\n-  fprintf (di->stream, \"\\n%25s\", \"\");\n-  di->column = 25;\n-}\n-\n-/* If necessary, insert a new line.  */\n-\n-static void\n-dump_maybe_newline (di)\n-     dump_info_p di;\n-{\n-  /* See if we need a new line.  */\n-  if (di->column > 53)\n-    dump_new_line (di);\n-  /* See if we need any padding.  */\n-  else if ((di->column - 25) % 14 != 0)\n-    {\n-      fprintf (di->stream, \"%*s\", 14 - ((di->column - 25) % 14), \"\");\n-      di->column += 14 - (di->column - 25) % 14;\n-    }\n-}\n-\n-/* Dump I using FIELD to identity it.  */\n-\n-static void\n-dump_int (di, field, i)\n-     dump_info_p di;\n-     const char *field;\n-     int i;\n-{\n-  dump_maybe_newline (di);\n-  fprintf (di->stream, \"%-4s: %-7d \", field, i);\n-  di->column += 14;\n-}\n-\n-/* Dump the string S.  */\n-\n-static void\n-dump_string (di, string)\n-     dump_info_p di;\n-     const char *string;\n-{\n-  dump_maybe_newline (di);\n-  fprintf (di->stream, \"%-13s \", string);\n-  if (strlen (string) > 13)\n-    di->column += strlen (string) + 1;\n-  else\n-    di->column += 14;\n-}\n-\n-/* Dump the string field S.  */\n-\n-static void\n-dump_string_field (di, field, string)\n-     dump_info_p di;\n-     const char *field;\n-     const char *string;\n-{\n-  dump_maybe_newline (di);\n-  fprintf (di->stream, \"%-4s: %-7s \", field, string);\n-  if (strlen (string) > 7)\n-    di->column += 6 + strlen (string) + 1;\n-  else\n-    di->column += 14;\n-}\n-\n-/* Dump information common to statements from STMT.  */\n-\n-static void\n-dump_stmt (di, t)\n-     dump_info_p di;\n-     tree t;\n-{\n-  dump_int (di, \"line\", STMT_LINENO (t));\n-}\n-\n-/* Dump the CHILD and its children.  */\n-#define dump_child(field, child) \\\n-  queue_and_dump_index (di, field, child, DUMP_NONE)\n-\n-/* Dump the next statement after STMT.  */\n-\n-static void\n-dump_next_stmt (di, t)\n-     dump_info_p di;\n-     tree t;\n-{\n-  dump_child (\"next\", TREE_CHAIN (t));\n-}\n-\n-/* Dump the next node in the queue.  */\n-\n-static void \n-dequeue_and_dump (di)\n-     dump_info_p di;\n-{\n-  dump_queue_p dq;\n-  splay_tree_node stn;\n-  dump_node_info_p dni;\n-  tree t;\n-  unsigned int index;\n   enum tree_code code;\n-  char code_class;\n-  const char* code_name;\n-\n-  /* Get the next node from the queue.  */\n-  dq = di->queue;\n-  stn = dq->node;\n-  t = (tree) stn->key;\n-  dni = (dump_node_info_p) stn->value;\n-  index = dni->index;\n-\n-  /* Remove the node from the queue, and put it on the free list.  */\n-  di->queue = dq->next;\n-  if (!di->queue)\n-    di->queue_end = 0;\n-  dq->next = di->free_list;\n-  di->free_list = dq;\n-\n-  /* Print the node index.  */\n-  dump_index (di, index);\n-  /* And the type of node this is.  */\n-  if (dni->binfo_p)\n-    code_name = \"binfo\";\n-  else\n-    code_name = tree_code_name[(int) TREE_CODE (t)];\n-  fprintf (di->stream, \"%-16s \", code_name);\n-  di->column = 25;\n \n   /* Figure out what kind of node this is.  */\n   code = TREE_CODE (t);\n-  code_class = TREE_CODE_CLASS (code);\n \n-  /* Although BINFOs are TREE_VECs, we dump them specially so as to be\n-     more informative.  */\n-  if (dni->binfo_p)\n+  if (DECL_P (t))\n     {\n-      if (TREE_VIA_PUBLIC (t))\n-\tdump_string (di, \"pub\");\n-      else if (TREE_VIA_PROTECTED (t))\n-\tdump_string (di, \"prot\");\n-      else if (TREE_VIA_PRIVATE (t))\n-\tdump_string (di, \"priv\");\n-      if (TREE_VIA_VIRTUAL (t))\n-\tdump_string (di, \"virt\");\n-\t    \n-      dump_child (\"type\", BINFO_TYPE (t));\n-      dump_child (\"base\", BINFO_BASETYPES (t));\n-\n-      goto done;\n-    }\n-\n-  /* We can knock off a bunch of expression nodes in exactly the same\n-     way.  */\n-  if (IS_EXPR_CODE_CLASS (code_class))\n-    {\n-      /* If we're dumping children, dump them now.  */\n-      queue_and_dump_type (di, t);\n-\n-      switch (code_class)\n-\t{\n-\tcase '1':\n-\t  dump_child (\"op 0\", TREE_OPERAND (t, 0));\n-\t  break;\n-\t      \n-\tcase '2':\n-\tcase '<':\n-\t  dump_child (\"op 0\", TREE_OPERAND (t, 0));\n-\t  dump_child (\"op 1\", TREE_OPERAND (t, 1));\n-\t  break;\n-\t      \n-\tcase 'e':\n-\t  /* These nodes are handled explicitly below.  */\n-\t  break;\n-\t      \n-\tdefault:\n-\t  my_friendly_abort (19990726);\n-\t}\n-    }\n-  else if (code_class == 'd')\n-    {\n-      /* All declarations have names.  */\n-      if (DECL_NAME (t))\n-\tdump_child (\"name\", DECL_NAME (t));\n-      /* And types.  */\n-      queue_and_dump_type (di, t);\n-      dump_child (\"scpe\", DECL_CONTEXT (t));\n-      /* And a source position.  */\n-      if (DECL_SOURCE_FILE (t))\n-\t{\n-\t  const char *filename = strrchr (DECL_SOURCE_FILE (t), '/');\n-\t  if (!filename)\n-\t    filename = DECL_SOURCE_FILE (t);\n-\t  else\n-\t    /* Skip the slash.  */\n-\t    ++filename;\n-\n-\t  dump_maybe_newline (di);\n-\t  fprintf (di->stream, \"srcp: %s:%-6d \", filename, \n-\t\t   DECL_SOURCE_LINE (t));\n-\t  di->column += 6 + strlen (filename) + 8;\n-\t}\n-      /* And any declaration can be compiler-generated.  */\n-      if (DECL_ARTIFICIAL (t))\n-\tdump_string (di, \"artificial\");\n-      if (TREE_CHAIN (t))\n-\tdump_child (\"chan\", TREE_CHAIN (t));\n       if (DECL_LANG_SPECIFIC (t) && DECL_LANGUAGE (t) != lang_cplusplus)\n \tdump_string (di, language_to_string (DECL_LANGUAGE (t), 0));\n     }\n-  else if (code_class == 't')\n-    {\n-      /* All types have qualifiers.  */\n-      int quals = CP_TYPE_QUALS (t);\n-      if (quals != TYPE_UNQUALIFIED)\n-\t{\n-\t  fprintf (di->stream, \"qual: %c%c%c     \",\n-\t\t   (quals & TYPE_QUAL_CONST) ? 'c' : ' ',\n-\t\t   (quals & TYPE_QUAL_VOLATILE) ? 'v' : ' ',\n-\t\t   (quals & TYPE_QUAL_RESTRICT) ? 'r' : ' ');\n-\t  di->column += 14;\n-\t}\n-\n-      /* All types have associated declarations.  */\n-      dump_child (\"name\", TYPE_NAME (t));\n-\n-      /* All types have a main variant.  */\n-      if (TYPE_MAIN_VARIANT (t) != t)\n-\tdump_child (\"unql\", TYPE_MAIN_VARIANT (t));\n-      \n-      /* And sizes.  */\n-      dump_child (\"size\", TYPE_SIZE (t));\n-\n-      /* All types have alignments.  */\n-      dump_int (di, \"algn\", TYPE_ALIGN (t));\n-    }\n-  else if (code_class == 'c')\n-    /* All constants can have types.  */\n-    queue_and_dump_type (di, t);\n \n-  /* Now handle the various kinds of nodes.  */\n   switch (code)\n     {\n-      int i;\n-\n     case IDENTIFIER_NODE:\n       if (IDENTIFIER_OPNAME_P (t))\n-\tdump_string (di, \"operator\");\n+\t{\n+\t  dump_string (di, \"operator\");\n+\t  return 1;\n+\t}\n       else if (IDENTIFIER_TYPENAME_P (t))\n-\tdump_child (\"tynm\", TREE_TYPE (t));\n-      else if (t == anonymous_namespace_name)\n-\tdump_string (di, \"unnamed\");\n-      else\n \t{\n-\t  dump_string_field (di, \"strg\", IDENTIFIER_POINTER (t));\n-\t  dump_int (di, \"lngt\", IDENTIFIER_LENGTH (t));\n+\t  dump_child (\"tynm\", TREE_TYPE (t));\n+\t  return 1;\n \t}\n-      break;\n-\n-    case TREE_LIST:\n-      dump_child (\"purp\", TREE_PURPOSE (t));\n-      dump_child (\"valu\", TREE_VALUE (t));\n-      dump_child (\"chan\", TREE_CHAIN (t));\n-      break;\n-\n-    case TREE_VEC:\n-      dump_int (di, \"lngt\", TREE_VEC_LENGTH (t));\n-      for (i = 0; i < TREE_VEC_LENGTH (t); ++i)\n+      else if (t == anonymous_namespace_name)\n \t{\n-\t  char buffer[32];\n-\t  sprintf (buffer, \"%u\", i);\n-\t  dump_child (buffer, TREE_VEC_ELT (t, i));\n+\t  dump_string (di, \"unnamed\");\n+\t  return 1;\n \t}\n       break;\n \n-    case INTEGER_TYPE:\n-    case ENUMERAL_TYPE:\n-      dump_int (di, \"prec\", TYPE_PRECISION (t));\n-      if (TREE_UNSIGNED (t))\n-\tdump_string (di, \"unsigned\");\n-      dump_child (\"min\", TYPE_MIN_VALUE (t));\n-      dump_child (\"max\", TYPE_MAX_VALUE (t));\n-\n-      if (code == ENUMERAL_TYPE)\n-\tdump_child (\"csts\", TYPE_VALUES (t));\n-      break;\n-\n-    case REAL_TYPE:\n-      dump_int (di, \"prec\", TYPE_PRECISION (t));\n-      break;\n-\n     case POINTER_TYPE:\n       if (TYPE_PTRMEM_P (t))\n \t{\n \t  dump_string (di, \"ptrmem\");\n \t  dump_child (\"ptd\", TYPE_PTRMEM_POINTED_TO_TYPE (t));\n \t  dump_child (\"cls\", TYPE_PTRMEM_CLASS_TYPE (t));\n+\t  return 1;\n \t}\n-      else\n-\tdump_child (\"ptd\", TREE_TYPE (t));\n-      break;\n-\n-    case REFERENCE_TYPE:\n-      dump_child (\"refd\", TREE_TYPE (t));\n-      break;\n-\n-    case METHOD_TYPE:\n-      dump_child (\"clas\", TYPE_METHOD_BASETYPE (t));\n-      /* Fall through.  */\n-\n-    case FUNCTION_TYPE:\n-      dump_child (\"retn\", TREE_TYPE (t));\n-      dump_child (\"prms\", TYPE_ARG_TYPES (t));\n-      break;\n-\n-    case ARRAY_TYPE:\n-      dump_child (\"elts\", TREE_TYPE (t));\n-      dump_child (\"domn\", TYPE_DOMAIN (t));\n       break;\n \n     case RECORD_TYPE:\n@@ -515,60 +78,13 @@ dequeue_and_dump (di)\n \t  dump_string (di, \"ptrmem\");\n \t  dump_child (\"ptd\", TYPE_PTRMEM_POINTED_TO_TYPE (t));\n \t  dump_child (\"cls\", TYPE_PTRMEM_CLASS_TYPE (t));\n+\t  return 1;\n \t}\n-      else\n-\t{\n-\t  if (CLASSTYPE_DECLARED_CLASS (t))\n-\t    dump_string (di, \"class\");\n-\t  else if (TREE_CODE (t) == RECORD_TYPE)\n-\t    dump_string (di, \"struct\");\n-\t  else\n-\t    dump_string (di, \"union\");\n-\n-\t  dump_child (\"flds\", TYPE_FIELDS (t));\n-\t  dump_child (\"fncs\", TYPE_METHODS (t));\n-\t  dump_child (\"vfld\", TYPE_VFIELD (t));\n-\t  queue_and_dump_index (di, \"binf\", TYPE_BINFO (t), \n-\t\t\t\tDUMP_BINFO);\n-\t}\n-      break;\n-\n-    case CONST_DECL:\n-      dump_child (\"cnst\", DECL_INITIAL (t));\n-      break;\n \n-    case VAR_DECL:\n-    case PARM_DECL:\n-    case FIELD_DECL:\n-    case RESULT_DECL:\n-      if (TREE_CODE (t) == PARM_DECL)\n-\tdump_child (\"argt\", DECL_ARG_TYPE (t));\n-      else\n-\tdump_child (\"init\", DECL_INITIAL (t));\n-      dump_child (\"size\", DECL_SIZE (t));\n-      dump_int (di, \"algn\", DECL_ALIGN (t));\n-\n-      if (TREE_CODE (t) == FIELD_DECL)\n-\t{\n-\t  if (DECL_C_BIT_FIELD (t))\n-\t    dump_string (di, \"bitfield\");\n-\t  if (DECL_FIELD_OFFSET (t))\n-\t    dump_child (\"bpos\", bit_position (t));\n-\t}\n-      else if (TREE_CODE (t) == VAR_DECL \n-\t       || TREE_CODE (t) == PARM_DECL)\n-\tdump_int (di, \"used\", TREE_USED (t));\n+      dump_child (\"vfld\", TYPE_VFIELD (t));\n       break;\n \n     case FUNCTION_DECL:\n-      dump_child (\"mngl\", DECL_ASSEMBLER_NAME (t));\n-      dump_child (\"args\", DECL_ARGUMENTS (t));\n-      if (DECL_EXTERNAL (t))\n-\tdump_string (di, \"undefined\");\n-      if (TREE_PUBLIC (t))\n-\tdump_string(di, \"extern\");\n-      else\n-\tdump_string (di, \"static\");\n       if (!DECL_THUNK_P (t))\n \t{\n \t  if (DECL_FUNCTION_MEMBER_P (t))\n@@ -625,34 +141,36 @@ dequeue_and_dump (di)\n       dump_child (\"chan\", OVL_CHAIN (t));\n       break;\n \n-    case ASM_STMT:\n+    case TRY_BLOCK:\n       dump_stmt (di, t);\n-      if (ASM_VOLATILE_P (t))\n-\tdump_string (di, \"volatile\");\n-      dump_child (\"strg\", ASM_STRING (t));\n-      dump_child (\"outs\", ASM_OUTPUTS (t));\n-      dump_child (\"ins\", ASM_INPUTS (t));\n-      dump_child (\"clbr\", ASM_CLOBBERS (t));\n+      if (CLEANUP_P (t))\n+\tdump_string (di, \"cleanup\");\n+      dump_child (\"body\", TRY_STMTS (t));\n+      dump_child (\"hdlr\", TRY_HANDLERS (t));\n       dump_next_stmt (di, t);\n       break;\n \n-    case BREAK_STMT:\n-    case CONTINUE_STMT:\n-      dump_stmt (di, t);\n-      dump_next_stmt (di, t);\n+    case PTRMEM_CST:\n+      dump_child (\"clas\", PTRMEM_CST_CLASS (t));\n+      dump_child (\"mbr\", PTRMEM_CST_MEMBER (t));\n       break;\n \n-    case CASE_LABEL:\n-      /* Note that a case label is not like other statments; there is\n-\t no way to get the line-number of a case label.  */\n-      dump_child (\"low\", CASE_LOW (t));\n-      dump_child (\"high\", CASE_HIGH (t));\n-      dump_next_stmt (di, t);\n+    case THROW_EXPR:\n+      /* These nodes are unary, but do not have code class `1'.  */\n+      dump_child (\"op 0\", TREE_OPERAND (t, 0));\n       break;\n \n-    case COMPOUND_STMT:\n+    case AGGR_INIT_EXPR:\n+      dump_int (di, \"ctor\", AGGR_INIT_VIA_CTOR_P (t));\n+      dump_child (\"fn\", TREE_OPERAND (t, 0));\n+      dump_child (\"args\", TREE_OPERAND (t, 1));\n+      dump_child (\"decl\", TREE_OPERAND (t, 2));\n+      break;\n+      \n+    case CLEANUP_STMT:\n       dump_stmt (di, t);\n-      dump_child (\"body\", COMPOUND_BODY (t));\n+      dump_child (\"decl\", CLEANUP_DECL (t));\n+      dump_child (\"expr\", CLEANUP_EXPR (t));\n       dump_next_stmt (di, t);\n       break;\n \n@@ -665,89 +183,12 @@ dequeue_and_dump (di)\n       dump_next_stmt (di, t);\n       break;\n \n-    case DECL_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"decl\", DECL_STMT_DECL (t));\n-      dump_next_stmt (di, t);\n-      break;\n-      \n-    case DO_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"body\", DO_BODY (t));\n-      dump_child (\"cond\", DO_COND (t));\n-      dump_next_stmt (di, t);\n-      break;\n-\n-    case EXPR_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"expr\", EXPR_STMT_EXPR (t));\n-      dump_next_stmt (di, t);\n-      break;\n-\n-    case FOR_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"init\", FOR_INIT_STMT (t));\n-      dump_child (\"cond\", FOR_COND (t));\n-      dump_child (\"expr\", FOR_EXPR (t));\n-      dump_child (\"body\", FOR_BODY (t));\n-      dump_next_stmt (di, t);\n-      break;\n-\n-    case GOTO_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"dest\", GOTO_DESTINATION (t));\n-      dump_next_stmt (di, t);\n-      break;\n-\n     case HANDLER:\n       dump_stmt (di, t);\n       dump_child (\"body\", HANDLER_BODY (t));\n       dump_next_stmt (di, t);\n       break;\n \n-    case IF_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"cond\", IF_COND (t));\n-      dump_child (\"then\", THEN_CLAUSE (t));\n-      dump_child (\"else\", ELSE_CLAUSE (t));\n-      dump_next_stmt (di, t);\n-      break;\n-\n-    case LABEL_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"labl\", LABEL_STMT_LABEL (t));\n-      dump_next_stmt (di, t);\n-      break;\n-\n-    case RETURN_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"expr\", RETURN_EXPR (t));\n-      dump_next_stmt (di, t);\n-      break;\n-\n-    case SWITCH_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"cond\", SWITCH_COND (t));\n-      dump_child (\"body\", SWITCH_BODY (t));\n-      dump_next_stmt (di, t);\n-      break;\n-\n-    case TRY_BLOCK:\n-      dump_stmt (di, t);\n-      if (CLEANUP_P (t))\n-\tdump_string (di, \"cleanup\");\n-      dump_child (\"body\", TRY_STMTS (t));\n-      dump_child (\"hdlr\", TRY_HANDLERS (t));\n-      dump_next_stmt (di, t);\n-      break;\n-\n-    case WHILE_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"cond\", WHILE_COND (t));\n-      dump_child (\"body\", WHILE_BODY (t));\n-      dump_next_stmt (di, t);\n-      break;\n-\n     case SUBOBJECT:\n       dump_stmt (di, t);\n       dump_child (\"clnp\", TREE_OPERAND (t, 0));\n@@ -760,184 +201,10 @@ dequeue_and_dump (di)\n       dump_next_stmt (di, t);\n       break;\n \n-    case CLEANUP_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"decl\", CLEANUP_DECL (t));\n-      dump_child (\"expr\", CLEANUP_EXPR (t));\n-      dump_next_stmt (di, t);\n-      break;\n-\n-    case SCOPE_STMT:\n-      dump_stmt (di, t);\n-      if (SCOPE_BEGIN_P (t))\n-\tdump_string (di, \"begn\");\n-      else\n-\tdump_string (di, \"end\");\n-      if (SCOPE_NULLIFIED_P (t))\n-\tdump_string (di, \"null\");\n-      if (!SCOPE_NO_CLEANUPS_P (t))\n-\tdump_string (di, \"clnp\");\n-      dump_next_stmt (di, t);\n-      break;\n-\n-    case INTEGER_CST:\n-      if (TREE_INT_CST_HIGH (t))\n-\tdump_int (di, \"high\", TREE_INT_CST_HIGH (t));\n-      dump_int (di, \"low\", TREE_INT_CST_LOW (t));\n-      break;\n-\n-    case STRING_CST:\n-      fprintf (di->stream, \"strg: %-7s \", TREE_STRING_POINTER (t));\n-      dump_int (di, \"lngt\", TREE_STRING_LENGTH (t));\n-      break;\n-\n-    case PTRMEM_CST:\n-      dump_child (\"clas\", PTRMEM_CST_CLASS (t));\n-      dump_child (\"mbr\", PTRMEM_CST_MEMBER (t));\n-      break;\n-\n-    case TRUTH_NOT_EXPR:\n-    case ADDR_EXPR:\n-    case INDIRECT_REF:\n-    case THROW_EXPR:\n-    case CLEANUP_POINT_EXPR:\n-    case SAVE_EXPR:\n-      /* These nodes are unary, but do not have code class `1'.  */\n-      dump_child (\"op 0\", TREE_OPERAND (t, 0));\n-      break;\n-\n-    case TRUTH_ANDIF_EXPR:\n-    case TRUTH_ORIF_EXPR:\n-    case INIT_EXPR:\n-    case MODIFY_EXPR:\n-    case COMPONENT_REF:\n-    case COMPOUND_EXPR:\n-    case ARRAY_REF:\n-    case PREDECREMENT_EXPR:\n-    case PREINCREMENT_EXPR:\n-    case POSTDECREMENT_EXPR:\n-    case POSTINCREMENT_EXPR:\n-      /* These nodes are binary, but do not have code class `2'.  */\n-      dump_child (\"op 0\", TREE_OPERAND (t, 0));\n-      dump_child (\"op 1\", TREE_OPERAND (t, 1));\n-      break;\n-\n-    case COND_EXPR:\n-      dump_child (\"op 0\", TREE_OPERAND (t, 0));\n-      dump_child (\"op 1\", TREE_OPERAND (t, 1));\n-      dump_child (\"op 2\", TREE_OPERAND (t, 2));\n-      break;\n-\n-    case CALL_EXPR:\n-      dump_child (\"fn\", TREE_OPERAND (t, 0));\n-      dump_child (\"args\", TREE_OPERAND (t, 1));\n-      break;\n-\n-    case CONSTRUCTOR:\n-      dump_child (\"elts\", TREE_OPERAND (t, 1));\n-      break;\n-\n-    case STMT_EXPR:\n-      dump_child (\"stmt\", STMT_EXPR_STMT (t));\n-      break;\n-\n-    case BIND_EXPR:\n-      dump_child (\"vars\", TREE_OPERAND (t, 0));\n-      dump_child (\"body\", TREE_OPERAND (t, 1));\n-      break;\n-\n-    case LOOP_EXPR:\n-      dump_child (\"body\", TREE_OPERAND (t, 0));\n-      break;\n-\n-    case EXIT_EXPR:\n-      dump_child (\"cond\", TREE_OPERAND (t, 0));\n-      break;\n-\n-    case TARGET_EXPR:\n-      dump_child (\"decl\", TREE_OPERAND (t, 0));\n-      dump_child (\"init\", TREE_OPERAND (t, 1));\n-      dump_child (\"clnp\", TREE_OPERAND (t, 2));\n-      /* There really are two possible places the initializer can be.\n-\t After RTL expansion, the second operand is moved to the\n-\t position of the fourth operand, and the second operand\n-\t becomes NULL.  */\n-      dump_child (\"init\", TREE_OPERAND (t, 3));\n-      break;\n-      \n-    case AGGR_INIT_EXPR:\n-      dump_int (di, \"ctor\", AGGR_INIT_VIA_CTOR_P (t));\n-      dump_child (\"fn\", TREE_OPERAND (t, 0));\n-      dump_child (\"args\", TREE_OPERAND (t, 1));\n-      dump_child (\"decl\", TREE_OPERAND (t, 2));\n-      break;\n-      \n-    case EXPR_WITH_FILE_LOCATION:\n-      dump_child (\"expr\", EXPR_WFL_NODE (t));\n-      break;\n-\n     default:\n-      /* There are no additional fields to print.  */\n       break;\n     }\n \n- done:\n-  /* Terminate the line.  */\n-  fprintf (di->stream, \"\\n\");\n+  return 0;\n }\n \n-/* Dump T, and all its children, on STREAM.  */\n-\n-static void\n-dump_node (t, stream)\n-     tree t;\n-     FILE *stream;\n-{\n-  struct dump_info di;\n-  dump_queue_p dq;\n-  dump_queue_p next_dq;\n-\n-  /* Initialize the dump-information structure.  */\n-  di.stream = stream;\n-  di.index = 0;\n-  di.column = 0;\n-  di.queue = 0;\n-  di.queue_end = 0;\n-  di.free_list = 0;\n-  di.nodes = splay_tree_new (splay_tree_compare_pointers, 0, \n-\t\t\t     (splay_tree_delete_value_fn) &free);\n-\n-  /* Queue up the first node.  */\n-  queue (&di, t, DUMP_NONE);\n-\n-  /* Until the queue is empty, keep dumping nodes.  */\n-  while (di.queue)\n-    dequeue_and_dump (&di);\n-\n-  /* Now, clean up.  */\n-  for (dq = di.free_list; dq; dq = next_dq)\n-    {\n-      next_dq = dq->next;\n-      free (dq);\n-    }\n-  splay_tree_delete (di.nodes);\n-}\n-\n-/* Dump T, and all its children, to FILE.  */\n-\n-void\n-dump_node_to_file (t, file)\n-     tree t;\n-     const char *file;\n-{\n-  FILE *f;\n-\n-  f = fopen (file, \"w\");\n-  if (!f)\n-    cp_error (\"could not open `%s'\", file);\n-  else\n-    {\n-      dump_node (t, f);\n-      fclose (f);\n-    }\n-}"}, {"sha": "dd190ea4bbe8f8627ba1e8f110b2c58abf3743c4", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 29, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=0a7394bc1ac70f2a16ee15731457af04fb0b6e48", "patch": "@@ -5654,7 +5654,7 @@ tsubst_decl (t, args, type, in_decl)\n \t/* We do NOT check for matching decls pushed separately at this\n            point, as they may not represent instantiations of this\n            template, and in any case are considered separate under the\n-           discrete model.  Instead, see add_maybe_template.  */\n+           discrete model.  */\n \tr = copy_decl (t);\n \tDECL_USE_TEMPLATE (r) = 0;\n \tTREE_TYPE (r) = type;\n@@ -9871,34 +9871,6 @@ tsubst_initializer_list (t, argvec)\n   return first;\n }\n \n-/* D is an undefined function declaration in the presence of templates with\n-   the same name, listed in FNS.  If one of them can produce D as an\n-   instantiation, remember this so we can instantiate it at EOF if D has\n-   not been defined by that time.  */\n-\n-void\n-add_maybe_template (d, fns)\n-     tree d, fns;\n-{\n-  tree t;\n-\n-  if (DECL_MAYBE_TEMPLATE (d))\n-    return;\n-\n-  t = most_specialized (fns, d, NULL_TREE);\n-  if (! t)\n-    return;\n-  if (t == error_mark_node)\n-    {\n-      cp_error (\"ambiguous template instantiation for `%D'\", d);\n-      return;\n-    }\n-\n-  *maybe_template_tail = tree_cons (t, d, NULL_TREE);\n-  maybe_template_tail = &TREE_CHAIN (*maybe_template_tail);\n-  DECL_MAYBE_TEMPLATE (d) = 1;\n-}\n-\n /* Set CURRENT_ACCESS_SPECIFIER based on the protection of DECL.  */\n \n static void"}, {"sha": "84b648c148a3fe2462651f0f97b4c58376cadadc", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7394bc1ac70f2a16ee15731457af04fb0b6e48/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=0a7394bc1ac70f2a16ee15731457af04fb0b6e48", "patch": "@@ -6967,19 +6967,6 @@ comp_ptr_ttypes_reinterpret (to, from)\n     }\n }\n \n-/* Recursively examines the array elements of TYPE, until a non-array\n-   element type is found.  */\n-\n-tree\n-strip_array_types (type)\n-     tree type;\n-{\n-  while (TREE_CODE (type) == ARRAY_TYPE)\n-    type = TREE_TYPE (type);\n-\n-  return type;\n-}\n-\n /* Returns the type-qualifier set corresponding to TYPE.  */\n \n int"}]}