{"sha": "9a1e784ae82f0ebff6d018631d3fe3730359f3c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWExZTc4NGFlODJmMGViZmY2ZDAxODYzMWQzZmUzNzMwMzU5ZjNjMQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2014-12-22T09:33:05Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2014-12-22T09:33:05Z"}, "message": "symbol_summary is used for inline_summary.\n\n\t* lto-partition.c (add_symbol_to_partition_1): New inline_summaries\n\tis used.\n\t(undo_partition): Likewise.\n\t(lto_balanced_map): Likewise.\n\t* cgraphunit.c (symbol_table::process_new_functions): New inline_summaries\n\tis used.\n\t* ipa-cp.c (ipcp_cloning_candidate_p): Likewise.\n\t(devirtualization_time_bonus): Likewise.\n\t(estimate_local_effects): Likewise.\n\t(ipcp_propagate_stage): Likewise.\n\t* ipa-inline-analysis.c (evaluate_conditions_for_known_args): Likewise.\n\t(evaluate_properties_for_edge): Likewise.\n\t(inline_summary_alloc): Likewise.\n\t(reset_inline_summary): New inline_summary argument is introduced.\n\t(inline_summary_t::remove): New function.\n\t(inline_summary_t::duplicate): Likewise.\n\t(dump_inline_edge_summary): New inline_summaries is used.\n\t(dump_inline_summary): Likewise.\n\t(estimate_function_body_sizes): Likewise.\n\t(compute_inline_parameters): Likewise.\n\t(estimate_edge_devirt_benefit): Likewise.\n\t(estimate_node_size_and_time): Likewise.\n\t(inline_update_callee_summaries): Likewise.\n\t(inline_merge_summary): Likewise.\n\t(inline_update_overall_summary): Likewise.\n\t(simple_edge_hints): Likewise.\n\t(do_estimate_edge_time): Likewise.\n\t(estimate_time_after_inlining): Likewise.\n\t(estimate_size_after_inlining): Likewise.\n\t(do_estimate_growth): Likewise.\n\t(growth_likely_positive): Likewise.\n\t(inline_generate_summary): Likewise.\n\t(inline_read_section): Likewise.\n\t(inline_read_summary): Likewise.\n\t(inline_write_summary): Likewise.\n\t(inline_free_summary): Likewise.\n\t* ipa-inline-transform.c (clone_inlined_nodes): Likewise.\n\t(inline_call): Likewise.\n\t* ipa-inline.c (caller_growth_limits): Likewise.\n\t(can_inline_edge_p): Likewise.\n\t(want_early_inline_function_p): Likewise.\n\t(compute_uninlined_call_time): Likewise.\n\t(compute_inlined_call_time): Likewise.\n\t(big_speedup_p): Likewise.\n\t(want_inline_small_function_p): Likewise.\n\t(edge_badness): Likewise.\n\t(update_caller_keys): Likewise.\n\t(update_callee_keys): Likewise.\n\t(recursive_inlining): Likewise.\n\t(inline_small_functions): Likewise.\n\t(inline_to_all_callers): Likewise.\n\t(dump_overall_stats): Likewise.\n\t(early_inline_small_functions): Likewise.\n\t* ipa-inline.h: New class inline_summary_t replaces\n\tvec<inline_summary_t>.\n\t* ipa-split.c (execute_split_functions): New inline_summaries is used.\n\t* ipa.c (walk_polymorphic_call_targets): Likewise.\n\t* tree-sra.c (ipa_sra_preliminary_function_checks): Likewise.\n\nFrom-SVN: r219006", "tree": {"sha": "b8e0ce83d590d0efa7b87b19dae00bd2d2a422a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8e0ce83d590d0efa7b87b19dae00bd2d2a422a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a1e784ae82f0ebff6d018631d3fe3730359f3c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a1e784ae82f0ebff6d018631d3fe3730359f3c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a1e784ae82f0ebff6d018631d3fe3730359f3c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a1e784ae82f0ebff6d018631d3fe3730359f3c1/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dd912cb89c4e5dfda4a2710ae3082f5cb12a1d04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd912cb89c4e5dfda4a2710ae3082f5cb12a1d04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd912cb89c4e5dfda4a2710ae3082f5cb12a1d04"}], "stats": {"total": 335, "additions": 193, "deletions": 142}, "files": [{"sha": "c5e878b883a412510f6f6a505664645d2f654713", "filename": "gcc/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a1e784ae82f0ebff6d018631d3fe3730359f3c1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a1e784ae82f0ebff6d018631d3fe3730359f3c1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9a1e784ae82f0ebff6d018631d3fe3730359f3c1", "patch": "@@ -1,3 +1,60 @@\n+2014-12-22  Martin Liska  <mliska@suse.cz>\n+\n+\t* cgraphunit.c (symbol_table::process_new_functions): New inline_summaries\n+\tis used.\n+\t* ipa-cp.c (ipcp_cloning_candidate_p): Likewise.\n+\t(devirtualization_time_bonus): Likewise.\n+\t(estimate_local_effects): Likewise.\n+\t(ipcp_propagate_stage): Likewise.\n+\t* ipa-inline-analysis.c (evaluate_conditions_for_known_args): Likewise.\n+\t(evaluate_properties_for_edge): Likewise.\n+\t(inline_summary_alloc): Likewise.\n+\t(reset_inline_summary): New inline_summary argument is introduced.\n+\t(inline_summary_t::remove): New function.\n+\t(inline_summary_t::duplicate): Likewise.\n+\t(dump_inline_edge_summary): New inline_summaries is used.\n+\t(dump_inline_summary): Likewise.\n+\t(estimate_function_body_sizes): Likewise.\n+\t(compute_inline_parameters): Likewise.\n+\t(estimate_edge_devirt_benefit): Likewise.\n+\t(estimate_node_size_and_time): Likewise.\n+\t(inline_update_callee_summaries): Likewise.\n+\t(inline_merge_summary): Likewise.\n+\t(inline_update_overall_summary): Likewise.\n+\t(simple_edge_hints): Likewise.\n+\t(do_estimate_edge_time): Likewise.\n+\t(estimate_time_after_inlining): Likewise.\n+\t(estimate_size_after_inlining): Likewise.\n+\t(do_estimate_growth): Likewise.\n+\t(growth_likely_positive): Likewise.\n+\t(inline_generate_summary): Likewise.\n+\t(inline_read_section): Likewise.\n+\t(inline_read_summary): Likewise.\n+\t(inline_write_summary): Likewise.\n+\t(inline_free_summary): Likewise.\n+\t* ipa-inline-transform.c (clone_inlined_nodes): Likewise.\n+\t(inline_call): Likewise.\n+\t* ipa-inline.c (caller_growth_limits): Likewise.\n+\t(can_inline_edge_p): Likewise.\n+\t(want_early_inline_function_p): Likewise.\n+\t(compute_uninlined_call_time): Likewise.\n+\t(compute_inlined_call_time): Likewise.\n+\t(big_speedup_p): Likewise.\n+\t(want_inline_small_function_p): Likewise.\n+\t(edge_badness): Likewise.\n+\t(update_caller_keys): Likewise.\n+\t(update_callee_keys): Likewise.\n+\t(recursive_inlining): Likewise.\n+\t(inline_small_functions): Likewise.\n+\t(inline_to_all_callers): Likewise.\n+\t(dump_overall_stats): Likewise.\n+\t(early_inline_small_functions): Likewise.\n+\t* ipa-inline.h: New class inline_summary_t replaces\n+\tvec<inline_summary_t>.\n+\t* ipa-split.c (execute_split_functions): New inline_summaries is used.\n+\t* ipa.c (walk_polymorphic_call_targets): Likewise.\n+\t* tree-sra.c (ipa_sra_preliminary_function_checks): Likewise.\n+\n 2014-12-22  Martin Liska  <mliska@suse.cz>\n \n \t* auto-profile.c: Include of symbol-summary.h is added."}, {"sha": "a1295d1f4fec92315c58a6e528a8747f155742bb", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a1e784ae82f0ebff6d018631d3fe3730359f3c1/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a1e784ae82f0ebff6d018631d3fe3730359f3c1/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=9a1e784ae82f0ebff6d018631d3fe3730359f3c1", "patch": "@@ -341,7 +341,7 @@ symbol_table::process_new_functions (void)\n \t  if ((state == IPA_SSA || state == IPA_SSA_AFTER_INLINING)\n \t      && !gimple_in_ssa_p (DECL_STRUCT_FUNCTION (fndecl)))\n \t    g->get_passes ()->execute_early_local_passes ();\n-\t  else if (inline_summary_vec != NULL)\n+\t  else if (inline_summaries != NULL)\n \t    compute_inline_parameters (node, true);\n \t  free_dominance_info (CDI_POST_DOMINATORS);\n \t  free_dominance_info (CDI_DOMINATORS);"}, {"sha": "ba434ba16ad64617230c7e74cd6528b2f11a575e", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a1e784ae82f0ebff6d018631d3fe3730359f3c1/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a1e784ae82f0ebff6d018631d3fe3730359f3c1/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=9a1e784ae82f0ebff6d018631d3fe3730359f3c1", "patch": "@@ -598,7 +598,7 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n   init_caller_stats (&stats);\n   node->call_for_symbol_thunks_and_aliases (gather_caller_stats, &stats, false);\n \n-  if (inline_summary (node)->self_size < stats.n_calls)\n+  if (inline_summaries->get (node)->self_size < stats.n_calls)\n     {\n       if (dump_file)\n         fprintf (dump_file, \"Considering %s for cloning; code might shrink.\\n\",\n@@ -2064,7 +2064,7 @@ devirtualization_time_bonus (struct cgraph_node *node,\n       callee = callee->function_symbol (&avail);\n       if (avail < AVAIL_AVAILABLE)\n \tcontinue;\n-      isummary = inline_summary (callee);\n+      isummary = inline_summaries->get (callee);\n       if (!isummary->inlinable)\n \tcontinue;\n \n@@ -2311,7 +2311,7 @@ estimate_local_effects (struct cgraph_node *node)\n   vec<ipa_agg_jump_function> known_aggs;\n   vec<ipa_agg_jump_function_p> known_aggs_ptrs;\n   bool always_const;\n-  int base_time = inline_summary (node)->time;\n+  int base_time = inline_summaries->get (node)->time;\n   int removable_params_cost;\n \n   if (!count || !ipcp_versionable_function_p (node))\n@@ -2728,7 +2728,7 @@ ipcp_propagate_stage (struct ipa_topo_info *topo)\n \tinitialize_node_lattices (node);\n       }\n     if (node->definition && !node->alias)\n-      overall_size += inline_summary (node)->self_size;\n+      overall_size += inline_summaries->get (node)->self_size;\n     if (node->count > max_count)\n       max_count = node->count;\n   }"}, {"sha": "7da373ec3b6752f9044ecb8379a5d4264b915bb7", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 65, "deletions": 90, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a1e784ae82f0ebff6d018631d3fe3730359f3c1/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a1e784ae82f0ebff6d018631d3fe3730359f3c1/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=9a1e784ae82f0ebff6d018631d3fe3730359f3c1", "patch": "@@ -148,21 +148,15 @@ enum predicate_conditions\n #define CHANGED IDENTIFIER_NODE\n \n /* Holders of ipa cgraph hooks: */\n-static struct cgraph_node_hook_list *function_insertion_hook_holder;\n-static struct cgraph_node_hook_list *node_removal_hook_holder;\n-static struct cgraph_2node_hook_list *node_duplication_hook_holder;\n static struct cgraph_2edge_hook_list *edge_duplication_hook_holder;\n static struct cgraph_edge_hook_list *edge_removal_hook_holder;\n-static void inline_node_removal_hook (struct cgraph_node *, void *);\n-static void inline_node_duplication_hook (struct cgraph_node *,\n-\t\t\t\t\t  struct cgraph_node *, void *);\n static void inline_edge_removal_hook (struct cgraph_edge *, void *);\n static void inline_edge_duplication_hook (struct cgraph_edge *,\n \t\t\t\t\t  struct cgraph_edge *, void *);\n \n /* VECtor holding inline summaries.  \n    In GGC memory because conditions might point to constant trees.  */\n-vec<inline_summary_t, va_gc> *inline_summary_vec;\n+function_summary <inline_summary *> *inline_summaries;\n vec<inline_edge_summary_t> inline_edge_summary_vec;\n \n /* Cached node/edge growths.  */\n@@ -828,7 +822,7 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n \t\t\t\t    known_aggs)\n {\n   clause_t clause = inline_p ? 0 : 1 << predicate_not_inlined_condition;\n-  struct inline_summary *info = inline_summary (node);\n+  struct inline_summary *info = inline_summaries->get (node);\n   int i;\n   struct condition *c;\n \n@@ -910,7 +904,7 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n \t\t\t      vec<ipa_agg_jump_function_p> *known_aggs_ptr)\n {\n   struct cgraph_node *callee = e->callee->ultimate_alias_target ();\n-  struct inline_summary *info = inline_summary (callee);\n+  struct inline_summary *info = inline_summaries->get (callee);\n   vec<tree> known_vals = vNULL;\n   vec<ipa_agg_jump_function_p> known_aggs = vNULL;\n \n@@ -986,21 +980,16 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n static void\n inline_summary_alloc (void)\n {\n-  if (!node_removal_hook_holder)\n-    node_removal_hook_holder =\n-      symtab->add_cgraph_removal_hook (&inline_node_removal_hook, NULL);\n   if (!edge_removal_hook_holder)\n     edge_removal_hook_holder =\n       symtab->add_edge_removal_hook (&inline_edge_removal_hook, NULL);\n-  if (!node_duplication_hook_holder)\n-    node_duplication_hook_holder =\n-      symtab->add_cgraph_duplication_hook (&inline_node_duplication_hook, NULL);\n   if (!edge_duplication_hook_holder)\n     edge_duplication_hook_holder =\n       symtab->add_edge_duplication_hook (&inline_edge_duplication_hook, NULL);\n \n-  if (vec_safe_length (inline_summary_vec) <= (unsigned) symtab->cgraph_max_uid)\n-    vec_safe_grow_cleared (inline_summary_vec, symtab->cgraph_max_uid + 1);\n+  if (!inline_summaries)\n+    inline_summaries = (inline_summary_t*) inline_summary_t::create_ggc (symtab);\n+\n   if (inline_edge_summary_vec.length () <= (unsigned) symtab->edges_max_uid)\n     inline_edge_summary_vec.safe_grow_cleared (symtab->edges_max_uid + 1);\n   if (!edge_predicate_pool)\n@@ -1030,9 +1019,9 @@ reset_inline_edge_summary (struct cgraph_edge *e)\n    data from previous run so they are not cumulated.  */\n \n static void\n-reset_inline_summary (struct cgraph_node *node)\n+reset_inline_summary (struct cgraph_node *node,\n+\t\t      inline_summary *info)\n {\n-  struct inline_summary *info = inline_summary (node);\n   struct cgraph_edge *e;\n \n   info->self_size = info->self_time = 0;\n@@ -1068,16 +1057,10 @@ reset_inline_summary (struct cgraph_node *node)\n \n /* Hook that is called by cgraph.c when a node is removed.  */\n \n-static void\n-inline_node_removal_hook (struct cgraph_node *node,\n-\t\t\t  void *data ATTRIBUTE_UNUSED)\n+void\n+inline_summary_t::remove (cgraph_node *node, inline_summary *info)\n {\n-  struct inline_summary *info;\n-  if (vec_safe_length (inline_summary_vec) <= (unsigned) node->uid)\n-    return;\n-  info = inline_summary (node);\n-  reset_inline_summary (node);\n-  memset (info, 0, sizeof (inline_summary_t));\n+  reset_inline_summary (node, info);\n }\n \n /* Remap predicate P of former function to be predicate of duplicated function.\n@@ -1127,16 +1110,14 @@ remap_hint_predicate_after_duplication (struct predicate **p,\n \n \n /* Hook that is called by cgraph.c when a node is duplicated.  */\n-\n-static void\n-inline_node_duplication_hook (struct cgraph_node *src,\n-\t\t\t      struct cgraph_node *dst,\n-\t\t\t      ATTRIBUTE_UNUSED void *data)\n+void\n+inline_summary_t::duplicate (cgraph_node *src,\n+\t\t\t     cgraph_node *dst,\n+\t\t\t     inline_summary *,\n+\t\t\t     inline_summary *info)\n {\n-  struct inline_summary *info;\n   inline_summary_alloc ();\n-  info = inline_summary (dst);\n-  memcpy (info, inline_summary (src), sizeof (struct inline_summary));\n+  memcpy (info, inline_summaries->get (src), sizeof (inline_summary));\n   /* TODO: as an optimization, we may avoid copying conditions\n      that are known to be false or true.  */\n   info->conds = vec_safe_copy (info->conds);\n@@ -1357,8 +1338,8 @@ dump_inline_edge_summary (FILE *f, int indent, struct cgraph_node *node,\n \t       ? \"inlined\" : cgraph_inline_failed_string (edge-> inline_failed),\n \t       indent, \"\", es->loop_depth, edge->frequency,\n \t       es->call_stmt_size, es->call_stmt_time,\n-\t       (int) inline_summary (callee)->size / INLINE_SIZE_SCALE,\n-\t       (int) inline_summary (callee)->estimated_stack_size);\n+\t       (int) inline_summaries->get (callee)->size / INLINE_SIZE_SCALE,\n+\t       (int) inline_summaries->get (callee)->estimated_stack_size);\n \n       if (es->predicate)\n \t{\n@@ -1384,9 +1365,9 @@ dump_inline_edge_summary (FILE *f, int indent, struct cgraph_node *node,\n \t  fprintf (f, \"%*sStack frame offset %i, callee self size %i,\"\n \t\t   \" callee size %i\\n\",\n \t\t   indent + 2, \"\",\n-\t\t   (int) inline_summary (callee)->stack_frame_offset,\n-\t\t   (int) inline_summary (callee)->estimated_self_stack_size,\n-\t\t   (int) inline_summary (callee)->estimated_stack_size);\n+\t\t   (int) inline_summaries->get (callee)->stack_frame_offset,\n+\t\t   (int) inline_summaries->get (callee)->estimated_self_stack_size,\n+\t\t   (int) inline_summaries->get (callee)->estimated_stack_size);\n \t  dump_inline_edge_summary (f, indent + 2, callee, info);\n \t}\n     }\n@@ -1414,7 +1395,7 @@ dump_inline_summary (FILE *f, struct cgraph_node *node)\n {\n   if (node->definition)\n     {\n-      struct inline_summary *s = inline_summary (node);\n+      struct inline_summary *s = inline_summaries->get (node);\n       size_time_entry *e;\n       int i;\n       fprintf (f, \"Inline summary for %s/%i\", node->name (),\n@@ -2227,7 +2208,7 @@ param_change_prob (gimple stmt, int i)\n \n static bool\n phi_result_unknown_predicate (struct ipa_node_params *info,\n-\t\t\t      struct inline_summary *summary, basic_block bb,\n+\t\t\t      inline_summary *summary, basic_block bb,\n \t\t\t      struct predicate *p,\n \t\t\t      vec<predicate_t> nonconstant_names)\n {\n@@ -2316,7 +2297,7 @@ predicate_for_phi_result (struct inline_summary *summary, gphi *phi,\n /* Return predicate specifying when array index in access OP becomes non-constant.  */\n \n static struct predicate\n-array_index_predicate (struct inline_summary *info,\n+array_index_predicate (inline_summary *info,\n \t\t       vec< predicate_t> nonconstant_names, tree op)\n {\n   struct predicate p = false_predicate ();\n@@ -2471,7 +2452,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n   basic_block bb;\n   struct function *my_function = DECL_STRUCT_FUNCTION (node->decl);\n   int freq;\n-  struct inline_summary *info = inline_summary (node);\n+  struct inline_summary *info = inline_summaries->get (node);\n   struct predicate bb_predicate;\n   struct ipa_node_params *parms_info = NULL;\n   vec<predicate_t> nonconstant_names = vNULL;\n@@ -2717,7 +2698,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t    }\n \t}\n     }\n-  set_hint_predicate (&inline_summary (node)->array_index, array_index);\n+  set_hint_predicate (&inline_summaries->get (node)->array_index, array_index);\n   time = (time + CGRAPH_FREQ_BASE / 2) / CGRAPH_FREQ_BASE;\n   if (time > MAX_TIME)\n     time = MAX_TIME;\n@@ -2805,9 +2786,9 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t    }\n \t  free (body);\n \t}\n-      set_hint_predicate (&inline_summary (node)->loop_iterations,\n+      set_hint_predicate (&inline_summaries->get (node)->loop_iterations,\n \t\t\t  loop_iterations);\n-      set_hint_predicate (&inline_summary (node)->loop_stride, loop_stride);\n+      set_hint_predicate (&inline_summaries->get (node)->loop_stride, loop_stride);\n       scev_finalize ();\n     }\n   FOR_ALL_BB_FN (bb, my_function)\n@@ -2825,8 +2806,8 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t  e->aux = NULL;\n \t}\n     }\n-  inline_summary (node)->self_time = time;\n-  inline_summary (node)->self_size = size;\n+  inline_summaries->get (node)->self_time = time;\n+  inline_summaries->get (node)->self_size = size;\n   nonconstant_names.release ();\n   if (opt_for_fn (node->decl, optimize) && !early)\n     {\n@@ -2855,8 +2836,8 @@ compute_inline_parameters (struct cgraph_node *node, bool early)\n \n   inline_summary_alloc ();\n \n-  info = inline_summary (node);\n-  reset_inline_summary (node);\n+  info = inline_summaries->get (node);\n+  reset_inline_summary (node, info);\n \n   /* FIXME: Thunks are inlinable, but tree-inline don't know how to do that.\n      Once this happen, we will need to more curefully predict call\n@@ -3024,7 +3005,7 @@ estimate_edge_devirt_benefit (struct cgraph_edge *ie,\n   callee = callee->function_symbol (&avail);\n   if (avail < AVAIL_AVAILABLE)\n     return false;\n-  isummary = inline_summary (callee);\n+  isummary = inline_summaries->get (callee);\n   return isummary->inlinable;\n }\n \n@@ -3136,7 +3117,7 @@ estimate_node_size_and_time (struct cgraph_node *node,\n \t\t\t     vec<inline_param_summary>\n \t\t\t     inline_param_summary)\n {\n-  struct inline_summary *info = inline_summary (node);\n+  struct inline_summary *info = inline_summaries->get (node);\n   size_time_entry *e;\n   int size = 0;\n   int time = 0;\n@@ -3353,17 +3334,17 @@ static void\n inline_update_callee_summaries (struct cgraph_node *node, int depth)\n {\n   struct cgraph_edge *e;\n-  struct inline_summary *callee_info = inline_summary (node);\n-  struct inline_summary *caller_info = inline_summary (node->callers->caller);\n+  struct inline_summary *callee_info = inline_summaries->get (node);\n+  struct inline_summary *caller_info = inline_summaries->get (node->callers->caller);\n   HOST_WIDE_INT peak;\n \n   callee_info->stack_frame_offset\n     = caller_info->stack_frame_offset\n     + caller_info->estimated_self_stack_size;\n   peak = callee_info->stack_frame_offset\n     + callee_info->estimated_self_stack_size;\n-  if (inline_summary (node->global.inlined_to)->estimated_stack_size < peak)\n-      inline_summary (node->global.inlined_to)->estimated_stack_size = peak;\n+  if (inline_summaries->get (node->global.inlined_to)->estimated_stack_size < peak)\n+      inline_summaries->get (node->global.inlined_to)->estimated_stack_size = peak;\n   ipa_propagate_frequency (node);\n   for (e = node->callees; e; e = e->next_callee)\n     {\n@@ -3523,10 +3504,10 @@ remap_hint_predicate (struct inline_summary *info,\n void\n inline_merge_summary (struct cgraph_edge *edge)\n {\n-  struct inline_summary *callee_info = inline_summary (edge->callee);\n+  struct inline_summary *callee_info = inline_summaries->get (edge->callee);\n   struct cgraph_node *to = (edge->caller->global.inlined_to\n \t\t\t    ? edge->caller->global.inlined_to : edge->caller);\n-  struct inline_summary *info = inline_summary (to);\n+  struct inline_summary *info = inline_summaries->get (to);\n   clause_t clause = 0;\t\t/* not_inline is known to be false.  */\n   size_time_entry *e;\n   vec<int> operand_map = vNULL;\n@@ -3635,7 +3616,7 @@ inline_merge_summary (struct cgraph_edge *edge)\n void\n inline_update_overall_summary (struct cgraph_node *node)\n {\n-  struct inline_summary *info = inline_summary (node);\n+  struct inline_summary *info = inline_summaries->get (node);\n   size_time_entry *e;\n   int i;\n \n@@ -3662,8 +3643,8 @@ simple_edge_hints (struct cgraph_edge *edge)\n   int hints = 0;\n   struct cgraph_node *to = (edge->caller->global.inlined_to\n \t\t\t    ? edge->caller->global.inlined_to : edge->caller);\n-  if (inline_summary (to)->scc_no\n-      && inline_summary (to)->scc_no == inline_summary (edge->callee)->scc_no\n+  if (inline_summaries->get (to)->scc_no\n+      && inline_summaries->get (to)->scc_no == inline_summaries->get (edge->callee)->scc_no\n       && !edge->recursive_p ())\n     hints |= INLINE_HINT_same_scc;\n \n@@ -3723,7 +3704,7 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n   /* When caching, update the cache entry.  */\n   if (edge_growth_cache.exists ())\n     {\n-      inline_summary (edge->callee)->min_size = min_size;\n+      inline_summaries->get (edge->callee)->min_size = min_size;\n       if ((int) edge_growth_cache.length () <= edge->uid)\n \tedge_growth_cache.safe_grow_cleared (symtab->edges_max_uid);\n       edge_growth_cache[edge->uid].time = time + (time >= 0);\n@@ -3825,14 +3806,14 @@ estimate_time_after_inlining (struct cgraph_node *node,\n   if (!es->predicate || !false_predicate_p (es->predicate))\n     {\n       gcov_type time =\n-\tinline_summary (node)->time + estimate_edge_time (edge);\n+\tinline_summaries->get (node)->time + estimate_edge_time (edge);\n       if (time < 0)\n \ttime = 0;\n       if (time > MAX_TIME)\n \ttime = MAX_TIME;\n       return time;\n     }\n-  return inline_summary (node)->time;\n+  return inline_summaries->get (node)->time;\n }\n \n \n@@ -3846,11 +3827,11 @@ estimate_size_after_inlining (struct cgraph_node *node,\n   struct inline_edge_summary *es = inline_edge_summary (edge);\n   if (!es->predicate || !false_predicate_p (es->predicate))\n     {\n-      int size = inline_summary (node)->size + estimate_edge_growth (edge);\n+      int size = inline_summaries->get (node)->size + estimate_edge_growth (edge);\n       gcc_assert (size >= 0);\n       return size;\n     }\n-  return inline_summary (node)->size;\n+  return inline_summaries->get (node)->size;\n }\n \n \n@@ -3890,7 +3871,7 @@ int\n do_estimate_growth (struct cgraph_node *node)\n {\n   struct growth_data d = { node, 0, false };\n-  struct inline_summary *info = inline_summary (node);\n+  struct inline_summary *info = inline_summaries->get (node);\n \n   node->call_for_symbol_thunks_and_aliases (do_estimate_growth_1, &d, true);\n \n@@ -3963,7 +3944,7 @@ growth_likely_positive (struct cgraph_node *node, int edge_growth ATTRIBUTE_UNUS\n       && (!DECL_COMDAT (node->decl)\n \t  || !node->can_remove_if_no_direct_calls_p ()))\n     return true;\n-  max_callers = inline_summary (node)->size * 4 / edge_growth + 2;\n+  max_callers = inline_summaries->get (node)->size * 4 / edge_growth + 2;\n \n   for (e = node->callers; e; e = e->next_caller)\n     {\n@@ -4026,13 +4007,12 @@ inline_analyze_function (struct cgraph_node *node)\n \n /* Called when new function is inserted to callgraph late.  */\n \n-static void\n-add_new_function (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n+void\n+inline_summary_t::insert (struct cgraph_node *node, inline_summary *)\n {\n   inline_analyze_function (node);\n }\n \n-\n /* Note function body size.  */\n \n void\n@@ -4045,8 +4025,10 @@ inline_generate_summary (void)\n   if (!optimize && !flag_generate_lto && !flag_generate_offload && !flag_wpa)\n     return;\n \n-  function_insertion_hook_holder =\n-    symtab->add_cgraph_insertion_hook (&add_new_function, NULL);\n+  if (!inline_summaries)\n+    inline_summaries = (inline_summary_t*) inline_summary_t::create_ggc (symtab);\n+\n+  inline_summaries->enable_insertion_hook ();\n \n   ipa_register_cgraph_hooks ();\n   inline_free_summary ();\n@@ -4140,7 +4122,7 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n       encoder = file_data->symtab_node_encoder;\n       node = dyn_cast<cgraph_node *> (lto_symtab_encoder_deref (encoder,\n \t\t\t\t\t\t\t\tindex));\n-      info = inline_summary (node);\n+      info = inline_summaries->get (node);\n \n       info->estimated_stack_size\n \t= info->estimated_self_stack_size = streamer_read_uhwi (&ib);\n@@ -4229,8 +4211,9 @@ inline_read_summary (void)\n       if (!flag_ipa_cp)\n \tipa_prop_read_jump_functions ();\n     }\n-  function_insertion_hook_holder =\n-    symtab->add_cgraph_insertion_hook (&add_new_function, NULL);\n+\n+  gcc_assert (inline_summaries);\n+  inline_summaries->enable_insertion_hook ();\n }\n \n \n@@ -4296,7 +4279,7 @@ inline_write_summary (void)\n       cgraph_node *cnode = dyn_cast <cgraph_node *> (snode);\n       if (cnode && (node = cnode)->definition && !node->alias)\n \t{\n-\t  struct inline_summary *info = inline_summary (node);\n+\t  struct inline_summary *info = inline_summaries->get (node);\n \t  struct bitpack_d bp;\n \t  struct cgraph_edge *edge;\n \t  int i;\n@@ -4357,27 +4340,19 @@ void\n inline_free_summary (void)\n {\n   struct cgraph_node *node;\n-  if (function_insertion_hook_holder)\n-    symtab->remove_cgraph_insertion_hook (function_insertion_hook_holder);\n-  function_insertion_hook_holder = NULL;\n-  if (node_removal_hook_holder)\n-    symtab->remove_cgraph_removal_hook (node_removal_hook_holder);\n-  node_removal_hook_holder = NULL;\n   if (edge_removal_hook_holder)\n     symtab->remove_edge_removal_hook (edge_removal_hook_holder);\n   edge_removal_hook_holder = NULL;\n-  if (node_duplication_hook_holder)\n-    symtab->remove_cgraph_duplication_hook (node_duplication_hook_holder);\n-  node_duplication_hook_holder = NULL;\n   if (edge_duplication_hook_holder)\n     symtab->remove_edge_duplication_hook (edge_duplication_hook_holder);\n   edge_duplication_hook_holder = NULL;\n   if (!inline_edge_summary_vec.exists ())\n     return;\n   FOR_EACH_DEFINED_FUNCTION (node)\n     if (!node->alias)\n-      reset_inline_summary (node);\n-  vec_free (inline_summary_vec);\n+      reset_inline_summary (node, inline_summaries->get (node));\n+  inline_summaries->release ();\n+  inline_summaries = NULL;\n   inline_edge_summary_vec.release ();\n   if (edge_predicate_pool)\n     free_alloc_pool (edge_predicate_pool);"}, {"sha": "c521f642147ab5787056e3ee61d2c092f15e8703", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a1e784ae82f0ebff6d018631d3fe3730359f3c1/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a1e784ae82f0ebff6d018631d3fe3730359f3c1/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=9a1e784ae82f0ebff6d018631d3fe3730359f3c1", "patch": "@@ -212,7 +212,7 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t  if (e->callee->definition && !DECL_EXTERNAL (e->callee->decl))\n \t    {\n \t      if (overall_size)\n-\t        *overall_size -= inline_summary (e->callee)->size;\n+\t        *overall_size -= inline_summaries->get (e->callee)->size;\n \t      nfunctions_inlined++;\n \t    }\n \t  duplicate = false;\n@@ -322,13 +322,13 @@ inline_call (struct cgraph_edge *e, bool update_original,\n \n   gcc_assert (curr->callee->global.inlined_to == to);\n \n-  old_size = inline_summary (to)->size;\n+  old_size = inline_summaries->get (to)->size;\n   inline_merge_summary (e);\n   if (optimize)\n     new_edges_found = ipa_propagate_indirect_call_infos (curr, new_edges);\n   if (update_overall_summary)\n    inline_update_overall_summary (to);\n-  new_size = inline_summary (to)->size;\n+  new_size = inline_summaries->get (to)->size;\n \n   if (callee->calls_comdat_local)\n     to->calls_comdat_local = true;"}, {"sha": "24ca66e0b38a0bc43f21c5b52c3d9c97d6541f40", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a1e784ae82f0ebff6d018631d3fe3730359f3c1/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a1e784ae82f0ebff6d018631d3fe3730359f3c1/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=9a1e784ae82f0ebff6d018631d3fe3730359f3c1", "patch": "@@ -170,7 +170,7 @@ caller_growth_limits (struct cgraph_edge *e)\n   int newsize;\n   int limit = 0;\n   HOST_WIDE_INT stack_size_limit = 0, inlined_stack;\n-  struct inline_summary *info, *what_info, *outer_info = inline_summary (to);\n+  inline_summary *info, *what_info, *outer_info = inline_summaries->get (to);\n \n   /* Look for function e->caller is inlined to.  While doing\n      so work out the largest function body on the way.  As\n@@ -182,7 +182,7 @@ caller_growth_limits (struct cgraph_edge *e)\n      too much in order to prevent compiler from exploding\".  */\n   while (true)\n     {\n-      info = inline_summary (to);\n+      info = inline_summaries->get (to);\n       if (limit < info->self_size)\n \tlimit = info->self_size;\n       if (stack_size_limit < info->estimated_self_stack_size)\n@@ -193,7 +193,7 @@ caller_growth_limits (struct cgraph_edge *e)\n \tbreak;\n     }\n \n-  what_info = inline_summary (what);\n+  what_info = inline_summaries->get (what);\n \n   if (limit < what_info->self_size)\n     limit = what_info->self_size;\n@@ -307,7 +307,7 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n       e->inline_failed = CIF_USES_COMDAT_LOCAL;\n       inlinable = false;\n     }\n-  else if (!inline_summary (callee)->inlinable \n+  else if (!inline_summaries->get (callee)->inlinable\n \t   || (caller_fun && fn_contains_cilk_spawn_p (caller_fun)))\n     {\n       e->inline_failed = CIF_FUNCTION_NOT_INLINABLE;\n@@ -453,7 +453,7 @@ want_early_inline_function_p (struct cgraph_edge *e)\n \n   if (DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n     ;\n-  /* For AutoFDO, we need to make sure that before profile annotation, all\n+  /* For AutoFDO, we need to make sure that before profile summary, all\n      hot paths' IR look exactly the same as profiled binary. As a result,\n      in einliner, we will disregard size limit and inline those callsites\n      that are:\n@@ -525,7 +525,7 @@ compute_uninlined_call_time (struct inline_summary *callee_info,\n   gcov_type uninlined_call_time =\n     RDIV ((gcov_type)callee_info->time * MAX (edge->frequency, 1),\n \t  CGRAPH_FREQ_BASE);\n-  gcov_type caller_time = inline_summary (edge->caller->global.inlined_to\n+  gcov_type caller_time = inline_summaries->get (edge->caller->global.inlined_to\n \t\t\t\t          ? edge->caller->global.inlined_to\n \t\t\t\t          : edge->caller)->time;\n   return uninlined_call_time + caller_time;\n@@ -538,7 +538,7 @@ inline gcov_type\n compute_inlined_call_time (struct cgraph_edge *edge,\n \t\t\t   int edge_time)\n {\n-  gcov_type caller_time = inline_summary (edge->caller->global.inlined_to\n+  gcov_type caller_time = inline_summaries->get (edge->caller->global.inlined_to\n \t\t\t\t\t  ? edge->caller->global.inlined_to\n \t\t\t\t\t  : edge->caller)->time;\n   gcov_type time = (caller_time\n@@ -558,7 +558,7 @@ compute_inlined_call_time (struct cgraph_edge *edge,\n static bool\n big_speedup_p (struct cgraph_edge *e)\n {\n-  gcov_type time = compute_uninlined_call_time (inline_summary (e->callee),\n+  gcov_type time = compute_uninlined_call_time (inline_summaries->get (e->callee),\n \t\t\t\t\t  \te);\n   gcov_type inlined_time = compute_inlined_call_time (e,\n \t\t\t\t\t              estimate_edge_time (e));\n@@ -591,15 +591,15 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n      MAX_INLINE_INSNS_SINGLE 16-fold for inline functions.  */\n   else if ((!DECL_DECLARED_INLINE_P (callee->decl)\n \t   && (!e->count || !e->maybe_hot_p ()))\n-\t   && inline_summary (callee)->min_size\n+\t   && inline_summaries->get (callee)->min_size\n \t\t- inline_edge_summary (e)->call_stmt_size\n \t      > MAX (MAX_INLINE_INSNS_SINGLE, MAX_INLINE_INSNS_AUTO))\n     {\n       e->inline_failed = CIF_MAX_INLINE_INSNS_AUTO_LIMIT;\n       want_inline = false;\n     }\n   else if ((DECL_DECLARED_INLINE_P (callee->decl) || e->count)\n-\t   && inline_summary (callee)->min_size\n+\t   && inline_summaries->get (callee)->min_size\n \t\t- inline_edge_summary (e)->call_stmt_size\n \t      > 16 * MAX_INLINE_INSNS_SINGLE)\n     {\n@@ -910,7 +910,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n   sreal badness;\n   int growth, edge_time;\n   struct cgraph_node *callee = edge->callee->ultimate_alias_target ();\n-  struct inline_summary *callee_info = inline_summary (callee);\n+  struct inline_summary *callee_info = inline_summaries->get (callee);\n   inline_hints hints;\n \n   if (DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n@@ -1188,7 +1188,7 @@ update_caller_keys (edge_heap_t *heap, struct cgraph_node *node,\n   struct cgraph_edge *edge;\n   struct ipa_ref *ref;\n \n-  if ((!node->alias && !inline_summary (node)->inlinable)\n+  if ((!node->alias && !inline_summaries->get (node)->inlinable)\n       || node->global.inlined_to)\n     return;\n   if (!bitmap_set_bit (updated_nodes, node->uid))\n@@ -1246,7 +1246,7 @@ update_callee_keys (edge_heap_t *heap, struct cgraph_node *node,\n            don't need updating.  */\n \tif (e->inline_failed\n \t    && (callee = e->callee->ultimate_alias_target (&avail))\n-\t    && inline_summary (callee)->inlinable\n+\t    && inline_summaries->get (callee)->inlinable\n \t    && avail >= AVAIL_AVAILABLE\n \t    && !bitmap_bit_p (updated_nodes, callee->uid))\n \t  {\n@@ -1417,8 +1417,8 @@ recursive_inlining (struct cgraph_edge *edge,\n     fprintf (dump_file,\n \t     \"\\n   Inlined %i times, \"\n \t     \"body grown from size %i to %i, time %i to %i\\n\", n,\n-\t     inline_summary (master_clone)->size, inline_summary (node)->size,\n-\t     inline_summary (master_clone)->time, inline_summary (node)->time);\n+\t     inline_summaries->get (master_clone)->size, inline_summaries->get (node)->size,\n+\t     inline_summaries->get (master_clone)->time, inline_summaries->get (node)->time);\n \n   /* Remove master clone we used for inlining.  We rely that clones inlined\n      into master clone gets queued just before master clone so we don't\n@@ -1591,7 +1591,7 @@ inline_small_functions (void)\n \tif (node->has_gimple_body_p ()\n \t    || node->thunk.thunk_p)\n \t  {\n-\t    struct inline_summary *info = inline_summary (node);\n+\t    struct inline_summary *info = inline_summaries->get (node);\n \t    struct ipa_dfs_info *dfs = (struct ipa_dfs_info *) node->aux;\n \n \t    /* Do not account external functions, they will be optimized out\n@@ -1607,7 +1607,7 @@ inline_small_functions (void)\n \t\tfor (n2 = node; n2;\n \t\t     n2 = ((struct ipa_dfs_info *) node->aux)->next_cycle)\n \t\t  {\n-\t\t    struct inline_summary *info2 = inline_summary (n2);\n+\t\t    struct inline_summary *info2 = inline_summaries->get (n2);\n \t\t    if (info2->scc_no)\n \t\t      break;\n \t\t    info2->scc_no = id;\n@@ -1727,7 +1727,7 @@ inline_small_functions (void)\n \t  fprintf (dump_file,\n \t\t   \"\\nConsidering %s/%i with %i size\\n\",\n \t\t   callee->name (), callee->order,\n-\t\t   inline_summary (callee)->size);\n+\t\t   inline_summaries->get (callee)->size);\n \t  fprintf (dump_file,\n \t\t   \" to be inlined into %s/%i in %s:%i\\n\"\n \t\t   \" Estimated badness is %\"PRId64\", frequency %.2f.\\n\",\n@@ -1845,8 +1845,8 @@ inline_small_functions (void)\n \t\t   \" Inlined into %s which now has time %i and size %i,\"\n \t\t   \"net change of %+i.\\n\",\n \t\t   edge->caller->name (),\n-\t\t   inline_summary (edge->caller)->time,\n-\t\t   inline_summary (edge->caller)->size,\n+\t\t   inline_summaries->get (edge->caller)->time,\n+\t\t   inline_summaries->get (edge->caller)->size,\n \t\t   overall_size - old_size);\n \t}\n       if (min_size > overall_size)\n@@ -1983,19 +1983,19 @@ inline_to_all_callers (struct cgraph_node *node, void *data)\n \t  fprintf (dump_file,\n \t\t   \"\\nInlining %s size %i.\\n\",\n \t\t   node->name (),\n-\t\t   inline_summary (node)->size);\n+\t\t   inline_summaries->get (node)->size);\n \t  fprintf (dump_file,\n \t\t   \" Called once from %s %i insns.\\n\",\n \t\t   node->callers->caller->name (),\n-\t\t   inline_summary (node->callers->caller)->size);\n+\t\t   inline_summaries->get (node->callers->caller)->size);\n \t}\n \n       inline_call (node->callers, true, NULL, NULL, true, &callee_removed);\n       if (dump_file)\n \tfprintf (dump_file,\n \t\t \" Inlined into %s which now has %i size\\n\",\n \t\t caller->name (),\n-\t\t inline_summary (caller)->size);\n+\t\t inline_summaries->get (caller)->size);\n       if (!(*num_calls)--)\n \t{\n \t  if (dump_file)\n@@ -2019,7 +2019,7 @@ dump_overall_stats (void)\n     if (!node->global.inlined_to\n \t&& !node->alias)\n       {\n-\tint time = inline_summary (node)->time;\n+\tint time = inline_summaries->get (node)->time;\n \tsum += time;\n \tsum_weighted += time * node->count;\n       }\n@@ -2339,7 +2339,7 @@ early_inline_small_functions (struct cgraph_node *node)\n   for (e = node->callees; e; e = e->next_callee)\n     {\n       struct cgraph_node *callee = e->callee->ultimate_alias_target ();\n-      if (!inline_summary (callee)->inlinable\n+      if (!inline_summaries->get (callee)->inlinable\n \t  || !e->inline_failed)\n \tcontinue;\n "}, {"sha": "8d33c3c18d7fd7951cb54954205e7298e1155a85", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a1e784ae82f0ebff6d018631d3fe3730359f3c1/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a1e784ae82f0ebff6d018631d3fe3730359f3c1/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=9a1e784ae82f0ebff6d018631d3fe3730359f3c1", "patch": "@@ -162,10 +162,28 @@ struct GTY(()) inline_summary\n   int scc_no;\n };\n \n-/* Need a typedef for inline_summary because of inline function\n-   'inline_summary' below.  */\n-typedef struct inline_summary inline_summary_t;\n-extern GTY(()) vec<inline_summary_t, va_gc> *inline_summary_vec;\n+class GTY((user)) inline_summary_t: public function_summary <inline_summary *>\n+{\n+public:\n+  inline_summary_t (symbol_table *symtab, bool ggc):\n+    function_summary <inline_summary *> (symtab, ggc) {}\n+\n+  static inline_summary_t *create_ggc (symbol_table *symtab)\n+  {\n+    struct inline_summary_t *summary = new (ggc_cleared_alloc <inline_summary_t> ())\n+      inline_summary_t(symtab, true);\n+    summary->disable_insertion_hook ();\n+    return summary;\n+  }\n+\n+\n+  virtual void insert (cgraph_node *, inline_summary *);\n+  virtual void remove (cgraph_node *node, inline_summary *);\n+  virtual void duplicate (cgraph_node *src, cgraph_node *dst,\n+\t\t\t  inline_summary *src_data, inline_summary *dst_data);\n+};\n+\n+extern GTY(()) function_summary <inline_summary *> *inline_summaries;\n \n /* Information kept about parameter of call site.  */\n struct inline_param_summary\n@@ -250,12 +268,6 @@ void clone_inlined_nodes (struct cgraph_edge *e, bool, bool, int *,\n extern int ncalls_inlined;\n extern int nfunctions_inlined;\n \n-static inline struct inline_summary *\n-inline_summary (struct cgraph_node *node)\n-{\n-  return &(*inline_summary_vec)[node->uid];\n-}\n-\n static inline struct inline_edge_summary *\n inline_edge_summary (struct cgraph_edge *edge)\n {"}, {"sha": "b16b151ed467761f04cb922b7a5df220d46b9ad1", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a1e784ae82f0ebff6d018631d3fe3730359f3c1/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a1e784ae82f0ebff6d018631d3fe3730359f3c1/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=9a1e784ae82f0ebff6d018631d3fe3730359f3c1", "patch": "@@ -471,7 +471,7 @@ ipa_get_ith_polymorhic_call_context (struct ipa_edge_args *args, int i)\n   return &(*args->polymorphic_call_contexts)[i];\n }\n \n-/* Callgraph summary for ipa_node_params.  */\n+/* Function summary for ipa_node_params.  */\n class ipa_node_params_t: public function_summary <ipa_node_params *>\n {\n public:"}, {"sha": "f03ceaada64a33a7f9a588ddbb802a8733e4358f", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a1e784ae82f0ebff6d018631d3fe3730359f3c1/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a1e784ae82f0ebff6d018631d3fe3730359f3c1/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=9a1e784ae82f0ebff6d018631d3fe3730359f3c1", "patch": "@@ -1678,7 +1678,7 @@ execute_split_functions (void)\n   /* This can be relaxed; function might become inlinable after splitting\n      away the uninlinable part.  */\n   if (inline_edge_summary_vec.exists ()\n-      && !inline_summary (node)->inlinable)\n+      && !inline_summaries->get (node)->inlinable)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Not splitting: not inlinable.\\n\");"}, {"sha": "49a3d82c85b3b3d5e51c9f50bc97f93a39dedd56", "filename": "gcc/ipa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a1e784ae82f0ebff6d018631d3fe3730359f3c1/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a1e784ae82f0ebff6d018631d3fe3730359f3c1/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=9a1e784ae82f0ebff6d018631d3fe3730359f3c1", "patch": "@@ -246,7 +246,7 @@ walk_polymorphic_call_targets (hash_set<void *> *reachable_call_targets,\n                                target->order);\n \t    }\n \t  edge = edge->make_direct (target);\n-\t  if (inline_summary_vec)\n+\t  if (inline_summaries)\n \t    inline_update_overall_summary (node);\n \t  else if (edge->call_stmt)\n \t    {"}, {"sha": "40cdb4ef206c21fbb9ad74d332430608bcf1092f", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a1e784ae82f0ebff6d018631d3fe3730359f3c1/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a1e784ae82f0ebff6d018631d3fe3730359f3c1/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=9a1e784ae82f0ebff6d018631d3fe3730359f3c1", "patch": "@@ -1,3 +1,10 @@\n+2014-12-22  Martin Liska  <mliska@suse.cz>\n+\n+\t* lto-partition.c (add_symbol_to_partition_1): New inline_summaries\n+\tis used.\n+\t(undo_partition): Likewise.\n+\t(lto_balanced_map): Likewise.\n+\n 2014-12-22  Martin Liska  <mliska@suse.cz>\n \n \t* lto-partition.c: Include of symbol-summary.h is added."}, {"sha": "160b910c31a956faa0803acca093aa00d936314d", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a1e784ae82f0ebff6d018631d3fe3730359f3c1/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a1e784ae82f0ebff6d018631d3fe3730359f3c1/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=9a1e784ae82f0ebff6d018631d3fe3730359f3c1", "patch": "@@ -165,7 +165,7 @@ add_symbol_to_partition_1 (ltrans_partition part, symtab_node *node)\n     {\n       struct cgraph_edge *e;\n       if (!node->alias)\n-        part->insns += inline_summary (cnode)->self_size;\n+        part->insns += inline_summaries->get (cnode)->self_size;\n \n       /* Add all inline clones and callees that are duplicated.  */\n       for (e = cnode->callees; e; e = e->next_callee)\n@@ -274,7 +274,7 @@ undo_partition (ltrans_partition partition, unsigned int n_nodes)\n       partition->initializers_visited = NULL;\n \n       if (!node->alias && (cnode = dyn_cast <cgraph_node *> (node)))\n-        partition->insns -= inline_summary (cnode)->self_size;\n+        partition->insns -= inline_summaries->get (cnode)->self_size;\n       lto_symtab_encoder_delete_node (partition->encoder, node);\n       node->aux = (void *)((size_t)node->aux - 1);\n     }\n@@ -477,7 +477,7 @@ lto_balanced_map (int n_lto_partitions)\n \telse\n \t  order[n_nodes++] = node;\n \tif (!node->alias)\n-\t  total_size += inline_summary (node)->size;\n+\t  total_size += inline_summaries->get (node)->size;\n       }\n \n   /* Streaming works best when the source units do not cross partition\n@@ -534,14 +534,14 @@ lto_balanced_map (int n_lto_partitions)\n \t     && noreorder[noreorder_pos]->order < current_order)\n \t{\n \t  if (!noreorder[noreorder_pos]->alias)\n-\t    total_size -= inline_summary (noreorder[noreorder_pos])->size;\n+\t    total_size -= inline_summaries->get (noreorder[noreorder_pos])->size;\n \t  next_nodes.safe_push (noreorder[noreorder_pos++]);\n \t}\n       add_sorted_nodes (next_nodes, partition);\n \n       add_symbol_to_partition (partition, order[i]);\n       if (!order[i]->alias)\n-        total_size -= inline_summary (order[i])->size;\n+        total_size -= inline_summaries->get (order[i])->size;\n \t  \n \n       /* Once we added a new node to the partition, we also want to add"}, {"sha": "f80a8c43a7d0f6df2e54d7e7fcc556e906b9b839", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a1e784ae82f0ebff6d018631d3fe3730359f3c1/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a1e784ae82f0ebff6d018631d3fe3730359f3c1/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=9a1e784ae82f0ebff6d018631d3fe3730359f3c1", "patch": "@@ -5032,7 +5032,7 @@ ipa_sra_preliminary_function_checks (struct cgraph_node *node)\n     }\n \n   if ((DECL_COMDAT (node->decl) || DECL_EXTERNAL (node->decl))\n-      && inline_summary (node)->size >= MAX_INLINE_INSNS_AUTO)\n+      && inline_summaries->get (node)->size >= MAX_INLINE_INSNS_AUTO)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Function too big to be made truly local.\\n\");"}]}