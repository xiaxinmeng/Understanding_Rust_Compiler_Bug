{"sha": "ece3bca2bd08bd02028f9ac6b0a2b6b8fa111305", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWNlM2JjYTJiZDA4YmQwMjAyOGY5YWM2YjBhMmI2YjhmYTExMTMwNQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2018-11-29T04:47:51Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2018-11-29T04:47:51Z"}, "message": "[RS6000] Use standard call patterns for __tls_get_addr calls\n\nThe current code handling __tls_get_addr calls for powerpc*-linux\ngenerates a call then overwrites the call insn with a special\ntls_{gd,ld}_{aix,sysv} pattern.  It's done that way to support\n!TARGET_TLS_MARKERS, where the arg setup insns need to be emitted\nimmediately before the branch and link.  When TARGET_TLS_MARKERS, the\narg setup insns are split from the actual call, but we then have a\nnon-standard call pattern that needs to be carried through to output.\n\nThis patch changes that scheme, to instead use the standard call\npatterns for __tls_get_addr calls, except for the now rare\n!TARGET_TLS_MARKERS case.  Doing it this way should be better for\nmaintenance as the !TARGET_TLS_MARKERS code can eventually disappear.\nIt also makes it possible to support longcalls (and in following\npatches, inline plt calls) for __tls_get_addr without introducing yet\nmore special call patterns.\n\n__tls_get_addr calls do however need to be different to standard\ncalls, because when TARGET_TLS_MARKERS the calls are decorated with an\nargument specifier, eg. \"bl __tls_get_addr(thread_var@tlsgd)\" that\ncauses a reloc to be emitted by the assembler tying the call to its\narg setup insns.  I chose to smuggle the arg in the currently unused\nstack size rtl.\n\nI've also introduced rs6000_call_sysv to generate rtl for sysv calls,\nas rs6000_call_aix does for aix and elfv2 calls.  This allows\nrs6000_longcall_ref to be local to rs6000.c since the calls in the\nexpanders never did anything for darwin.\n\n\t* config/rs6000/predicates.md (unspec_tls): New.\n\t* config/rs6000/rs6000-protos.h (rs6000_call_template),\n\t(rs6000_sibcall_template): Update prototype.\n\t(rs6000_longcall_ref): Delete.\n\t(rs6000_call_sysv): Declare.\n\t* config/rs6000/rs6000.c (edit_tls_call_insn): New function.\n\t(global_tlsarg): New variable.\n\t(rs6000_legitimize_tls_address): Rewrite __tls_get_addr call\n\thandling.\n\t(print_operand): Extract UNSPEC_TLSGD address operand.\n\t(rs6000_call_template, rs6000_sibcall_template): Remove arg\n\tparameter, extract from second call operand instead.\n\t(rs6000_longcall_ref): Make static, localize vars.\n\t(rs6000_call_aix): Rename parameter to reflect new usage.  Take\n\ttlsarg from global_tlsarg.  Don't create unused rtl or nop insns.\n\t(rs6000_sibcall_aix): Rename parameter to reflect new usage.  Take\n\ttlsarg from global_tlsarg.\n\t(rs6000_call_sysv): New function.\n\t* config/rs6000/rs6000.md: Adjust rs6000_call_template and\n\trs6000_sibcall_template throughout.\n\t(tls_gd_aix, tls_gd_sysv, tls_gd_call_aix, tls_gd_call_sysv): Delete.\n\t(tls_ld_aix, tls_ld_sysv, tls_ld_call_aix, tls_ld_call_sysv): Delete.\n\t(tls_gdld_nomark): New insn.\n\t(tls_gd): Swap operand order.  Simplify mode selection.\n\t(tls_gd_high, tls_gd_low): Swap operand order.\n\t(tls_ld): Remove const_int 0 vector element from UNSPEC_TLSLD.\n\tSimplify mode selection.\n\t(tls_ld_high, tls_ld_low): Similarly adjust UNSPEC_TLSLD.\n\t(call, call_value): Don't assert for second call operand.\n\tUse rs6000_call_sysv.\n\nFrom-SVN: r266604", "tree": {"sha": "04fa524ca73637833e033031b264e7c37c53c227", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04fa524ca73637833e033031b264e7c37c53c227"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ece3bca2bd08bd02028f9ac6b0a2b6b8fa111305", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ece3bca2bd08bd02028f9ac6b0a2b6b8fa111305", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ece3bca2bd08bd02028f9ac6b0a2b6b8fa111305", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ece3bca2bd08bd02028f9ac6b0a2b6b8fa111305/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7a24893b2eb79af5785a7334126a82618a549c1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a24893b2eb79af5785a7334126a82618a549c1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a24893b2eb79af5785a7334126a82618a549c1e"}], "stats": {"total": 565, "additions": 263, "deletions": 302}, "files": [{"sha": "50148302f1914ba2164d26bf4ea7122f1d7bc8cd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ece3bca2bd08bd02028f9ac6b0a2b6b8fa111305/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ece3bca2bd08bd02028f9ac6b0a2b6b8fa111305/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ece3bca2bd08bd02028f9ac6b0a2b6b8fa111305", "patch": "@@ -1,3 +1,36 @@\n+2018-11-29  Alan Modra  <amodra@gmail.com>\n+\n+\t* config/rs6000/predicates.md (unspec_tls): New.\n+\t* config/rs6000/rs6000-protos.h (rs6000_call_template),\n+\t(rs6000_sibcall_template): Update prototype.\n+\t(rs6000_longcall_ref): Delete.\n+\t(rs6000_call_sysv): Declare.\n+\t* config/rs6000/rs6000.c (edit_tls_call_insn): New function.\n+\t(global_tlsarg): New variable.\n+\t(rs6000_legitimize_tls_address): Rewrite __tls_get_addr call\n+\thandling.\n+\t(print_operand): Extract UNSPEC_TLSGD address operand.\n+\t(rs6000_call_template, rs6000_sibcall_template): Remove arg\n+\tparameter, extract from second call operand instead.\n+\t(rs6000_longcall_ref): Make static, localize vars.\n+\t(rs6000_call_aix): Rename parameter to reflect new usage.  Take\n+\ttlsarg from global_tlsarg.  Don't create unused rtl or nop insns.\n+\t(rs6000_sibcall_aix): Rename parameter to reflect new usage.  Take\n+\ttlsarg from global_tlsarg.\n+\t(rs6000_call_sysv): New function.\n+\t* config/rs6000/rs6000.md: Adjust rs6000_call_template and\n+\trs6000_sibcall_template throughout.\n+\t(tls_gd_aix, tls_gd_sysv, tls_gd_call_aix, tls_gd_call_sysv): Delete.\n+\t(tls_ld_aix, tls_ld_sysv, tls_ld_call_aix, tls_ld_call_sysv): Delete.\n+\t(tls_gdld_nomark): New insn.\n+\t(tls_gd): Swap operand order.  Simplify mode selection.\n+\t(tls_gd_high, tls_gd_low): Swap operand order.\n+\t(tls_ld): Remove const_int 0 vector element from UNSPEC_TLSLD.\n+\tSimplify mode selection.\n+\t(tls_ld_high, tls_ld_low): Similarly adjust UNSPEC_TLSLD.\n+\t(call, call_value): Don't assert for second call operand.\n+\tUse rs6000_call_sysv.\n+\n 2018-11-29  Alan Modra  <amodra@gmail.com>\n \n \t* config/rs6000/darwin.md (call_indirect_nonlocal_darwin64),"}, {"sha": "2c297fc45e82198cc1ab691a01d2e6d296081d2a", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ece3bca2bd08bd02028f9ac6b0a2b6b8fa111305/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ece3bca2bd08bd02028f9ac6b0a2b6b8fa111305/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=ece3bca2bd08bd02028f9ac6b0a2b6b8fa111305", "patch": "@@ -997,6 +997,13 @@\n   (and (match_code \"symbol_ref\")\n        (match_test \"RS6000_SYMBOL_REF_TLS_P (op)\")))\n \n+;; Return 1 for the UNSPEC used in TLS call operands\n+(define_predicate \"unspec_tls\"\n+  (match_code \"unspec\")\n+{\n+  return XINT (op, 1) == UNSPEC_TLSGD || XINT (op, 1) == UNSPEC_TLSLD;\n+})\n+\n ;; Return 1 if the operand, used inside a MEM, is a valid first argument\n ;; to CALL.  This is a SYMBOL_REF, a pseudo-register, LR or CTR.\n (define_predicate \"call_operand\""}, {"sha": "dd930bb2da6adf1ebfb84406b48152f79a784344", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ece3bca2bd08bd02028f9ac6b0a2b6b8fa111305/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ece3bca2bd08bd02028f9ac6b0a2b6b8fa111305/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=ece3bca2bd08bd02028f9ac6b0a2b6b8fa111305", "patch": "@@ -105,8 +105,8 @@ extern int ccr_bit (rtx, int);\n extern void rs6000_output_function_entry (FILE *, const char *);\n extern void print_operand (FILE *, rtx, int);\n extern void print_operand_address (FILE *, rtx);\n-extern const char *rs6000_call_template (rtx *, unsigned int, const char *);\n-extern const char *rs6000_sibcall_template (rtx *, unsigned int, const char *);\n+extern const char *rs6000_call_template (rtx *, unsigned int);\n+extern const char *rs6000_sibcall_template (rtx *, unsigned int);\n extern const char *rs6000_indirect_call_template (rtx *, unsigned int);\n extern const char *rs6000_indirect_sibcall_template (rtx *, unsigned int);\n extern enum rtx_code rs6000_reverse_condition (machine_mode,\n@@ -130,7 +130,6 @@ extern void rs6000_expand_atomic_op (enum rtx_code, rtx, rtx, rtx, rtx, rtx);\n extern void rs6000_emit_swdiv (rtx, rtx, rtx, bool);\n extern void rs6000_emit_swsqrt (rtx, rtx, bool);\n extern void output_toc (FILE *, rtx, int, machine_mode);\n-extern rtx rs6000_longcall_ref (rtx);\n extern void rs6000_fatal_bad_address (rtx);\n extern rtx create_TOC_reference (rtx, rtx);\n extern void rs6000_split_multireg_move (rtx, rtx);\n@@ -198,6 +197,7 @@ extern void rs6000_split_stack_space_check (rtx, rtx);\n extern void rs6000_emit_eh_reg_restore (rtx, rtx);\n extern void rs6000_call_aix (rtx, rtx, rtx, rtx);\n extern void rs6000_sibcall_aix (rtx, rtx, rtx, rtx);\n+extern void rs6000_call_sysv (rtx, rtx, rtx, rtx);\n extern void rs6000_aix_asm_output_dwarf_table_ref (char *);\n extern void get_ppc476_thunk_name (char name[32]);\n extern bool rs6000_overloaded_builtin_p (enum rs6000_builtins);"}, {"sha": "f3376065ee1f1752b54bde061240f1fc8c81ad1c", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 150, "deletions": 74, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ece3bca2bd08bd02028f9ac6b0a2b6b8fa111305/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ece3bca2bd08bd02028f9ac6b0a2b6b8fa111305/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=ece3bca2bd08bd02028f9ac6b0a2b6b8fa111305", "patch": "@@ -8566,6 +8566,43 @@ rs6000_legitimize_tls_address_aix (rtx addr, enum tls_model model)\n   return dest;\n }\n \n+/* Mess with a call, to make it look like the tls_gdld insns when\n+   !TARGET_TLS_MARKERS.  These insns have an extra unspec to\n+   differentiate them from standard calls, because they need to emit\n+   the arg setup insns as well as the actual call.  That keeps the\n+   arg setup insns immediately adjacent to the branch and link.  */\n+\n+static void\n+edit_tls_call_insn (rtx arg)\n+{\n+  rtx call_insn = last_call_insn ();\n+  if (!TARGET_TLS_MARKERS)\n+    {\n+      rtx patt = PATTERN (call_insn);\n+      gcc_assert (GET_CODE (patt) == PARALLEL);\n+      rtvec orig = XVEC (patt, 0);\n+      rtvec v = rtvec_alloc (GET_NUM_ELEM (orig) + 1);\n+      gcc_assert (GET_NUM_ELEM (orig) > 0);\n+      /* The (set (..) (call (mem ..))).  */\n+      RTVEC_ELT (v, 0) = RTVEC_ELT (orig, 0);\n+      /* The extra unspec.  */\n+      RTVEC_ELT (v, 1) = arg;\n+      /* All other assorted call pattern pieces.  */\n+      for (int i = 1; i < GET_NUM_ELEM (orig); i++)\n+\tRTVEC_ELT (v, i + 1) = RTVEC_ELT (orig, i);\n+      XVEC (patt, 0) = v;\n+    }\n+  if (DEFAULT_ABI == ABI_V4 && TARGET_SECURE_PLT && flag_pic)\n+    use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn),\n+\t     pic_offset_table_rtx);\n+}\n+\n+/* Passes the tls arg value for global dynamic and local dynamic\n+   emit_library_call_value in rs6000_legitimize_tls_address to\n+   rs6000_call_aix and rs6000_call_sysv.  This is used to emit the\n+   marker relocs put on __tls_get_addr calls.  */\n+static rtx global_tlsarg;\n+\n /* ADDR contains a thread-local SYMBOL_REF.  Generate code to compute\n    this (thread-local) address.  */\n \n@@ -8618,7 +8655,7 @@ rs6000_legitimize_tls_address (rtx addr, enum tls_model model)\n     }\n   else\n     {\n-      rtx r3, got, tga, tmp1, tmp2, call_insn;\n+      rtx got, tga, tmp1, tmp2;\n \n       /* We currently use relocations like @got@tlsgd for tls, which\n \t means the linker will handle allocation of tls entries, placing\n@@ -8658,52 +8695,42 @@ rs6000_legitimize_tls_address (rtx addr, enum tls_model model)\n \n       if (model == TLS_MODEL_GLOBAL_DYNAMIC)\n \t{\n+\t  rtx arg = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, addr, got),\n+\t\t\t\t    UNSPEC_TLSGD);\n+\t  global_tlsarg = arg;\n+\t  rtx argreg = const0_rtx;\n+\t  if (TARGET_TLS_MARKERS)\n+\t    {\n+\t      argreg = gen_rtx_REG (Pmode, 3);\n+\t      emit_insn (gen_rtx_SET (argreg, arg));\n+\t    }\n+\n \t  tga = rs6000_tls_get_addr ();\n \t  emit_library_call_value (tga, dest, LCT_CONST, Pmode,\n-\t\t\t\t   const0_rtx, Pmode);\n+\t\t\t\t   argreg, Pmode);\n+\t  global_tlsarg = NULL_RTX;\n \n-\t  r3 = gen_rtx_REG (Pmode, 3);\n-\t  if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n-\t    {\n-\t      if (TARGET_64BIT)\n-\t\tinsn = gen_tls_gd_aix64 (r3, got, addr, tga, const0_rtx);\n-\t      else\n-\t\tinsn = gen_tls_gd_aix32 (r3, got, addr, tga, const0_rtx);\n-\t    }\n-\t  else if (DEFAULT_ABI == ABI_V4)\n-\t    insn = gen_tls_gd_sysvsi (r3, got, addr, tga, const0_rtx);\n-\t  else\n-\t    gcc_unreachable ();\n-\t  call_insn = last_call_insn ();\n-\t  PATTERN (call_insn) = insn;\n-\t  if (DEFAULT_ABI == ABI_V4 && TARGET_SECURE_PLT && flag_pic)\n-\t    use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn),\n-\t\t     pic_offset_table_rtx);\n+\t  edit_tls_call_insn (arg);\n \t}\n       else if (model == TLS_MODEL_LOCAL_DYNAMIC)\n \t{\n+\t  rtx arg = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, got),\n+\t\t\t\t    UNSPEC_TLSLD);\n+\t  global_tlsarg = arg;\n+\t  rtx argreg = const0_rtx;\n+\t  if (TARGET_TLS_MARKERS)\n+\t    {\n+\t      argreg = gen_rtx_REG (Pmode, 3);\n+\t      emit_insn (gen_rtx_SET (argreg, arg));\n+\t    }\n+\n \t  tga = rs6000_tls_get_addr ();\n \t  tmp1 = gen_reg_rtx (Pmode);\n \t  emit_library_call_value (tga, tmp1, LCT_CONST, Pmode,\n-\t\t\t\t   const0_rtx, Pmode);\n+\t\t\t\t   argreg, Pmode);\n+\t  global_tlsarg = NULL_RTX;\n \n-\t  r3 = gen_rtx_REG (Pmode, 3);\n-\t  if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n-\t    {\n-\t      if (TARGET_64BIT)\n-\t\tinsn = gen_tls_ld_aix64 (r3, got, tga, const0_rtx);\n-\t      else\n-\t\tinsn = gen_tls_ld_aix32 (r3, got, tga, const0_rtx);\n-\t    }\n-\t  else if (DEFAULT_ABI == ABI_V4)\n-\t    insn = gen_tls_ld_sysvsi (r3, got, tga, const0_rtx);\n-\t  else\n-\t    gcc_unreachable ();\n-\t  call_insn = last_call_insn ();\n-\t  PATTERN (call_insn) = insn;\n-\t  if (DEFAULT_ABI == ABI_V4 && TARGET_SECURE_PLT && flag_pic)\n-\t    use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn),\n-\t\t     pic_offset_table_rtx);\n+\t  edit_tls_call_insn (arg);\n \n \t  if (rs6000_tls_size == 16)\n \t    {\n@@ -21170,19 +21197,19 @@ print_operand (FILE *file, rtx x, int code)\n \t  else\n \t    output_address (GET_MODE (x), XEXP (x, 0));\n \t}\n+      else if (toc_relative_expr_p (x, false,\n+\t\t\t\t    &tocrel_base_oac, &tocrel_offset_oac))\n+\t/* This hack along with a corresponding hack in\n+\t   rs6000_output_addr_const_extra arranges to output addends\n+\t   where the assembler expects to find them.  eg.\n+\t   (plus (unspec [(symbol_ref (\"x\")) (reg 2)] tocrel) 4)\n+\t   without this hack would be output as \"x@toc+4\".  We\n+\t   want \"x+4@toc\".  */\n+\toutput_addr_const (file, CONST_CAST_RTX (tocrel_base_oac));\n+      else if (GET_CODE (x) == UNSPEC && XINT (x, 1) == UNSPEC_TLSGD)\n+\toutput_addr_const (file, XVECEXP (x, 0, 0));\n       else\n-\t{\n-\t  if (toc_relative_expr_p (x, false, &tocrel_base_oac, &tocrel_offset_oac))\n-\t    /* This hack along with a corresponding hack in\n-\t       rs6000_output_addr_const_extra arranges to output addends\n-\t       where the assembler expects to find them.  eg.\n-\t       (plus (unspec [(symbol_ref (\"x\")) (reg 2)] tocrel) 4)\n-\t       without this hack would be output as \"x@toc+4\".  We\n-\t       want \"x+4@toc\".  */\n-\t    output_addr_const (file, CONST_CAST_RTX (tocrel_base_oac));\n-\t  else\n-\t    output_addr_const (file, x);\n-\t}\n+\toutput_addr_const (file, x);\n       return;\n \n     case '&':\n@@ -21368,26 +21395,35 @@ rs6000_assemble_integer (rtx x, unsigned int size, int aligned_p)\n }\n \n /* Return a template string for assembly to emit when making an\n-   external call.  FUNOP is the call mem argument operand number,\n-   ARG is either NULL or a @TLSGD or @TLSLD __tls_get_addr argument\n-   specifier.  */\n+   external call.  FUNOP is the call mem argument operand number.  */\n \n static const char *\n-rs6000_call_template_1 (rtx *operands ATTRIBUTE_UNUSED, unsigned int funop,\n-\t\t\tbool sibcall, const char *arg)\n+rs6000_call_template_1 (rtx *operands, unsigned int funop, bool sibcall)\n {\n   /* -Wformat-overflow workaround, without which gcc thinks that %u\n       might produce 10 digits.  */\n   gcc_assert (funop <= MAX_RECOG_OPERANDS);\n \n+  char arg[12];\n+  arg[0] = 0;\n+  if (TARGET_TLS_MARKERS && GET_CODE (operands[funop + 1]) == UNSPEC)\n+    {\n+      if (XINT (operands[funop + 1], 1) == UNSPEC_TLSGD)\n+\tsprintf (arg, \"(%%%u@tlsgd)\", funop + 1);\n+      else if (XINT (operands[funop + 1], 1) == UNSPEC_TLSLD)\n+\tsprintf (arg, \"(%%&@tlsld)\");\n+      else\n+\tgcc_unreachable ();\n+    }\n+\n   /* The magic 32768 offset here corresponds to the offset of\n      r30 in .got2, as given by LCTOC1.  See sysv4.h:toc_section.  */\n   char z[11];\n   sprintf (z, \"%%z%u%s\", funop,\n \t   (DEFAULT_ABI == ABI_V4 && TARGET_SECURE_PLT && flag_pic == 2\n \t    ? \"+32768\" : \"\"));\n \n-  static char str[32];  /* 4 spare */\n+  static char str[32];  /* 2 spare */\n   if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n     sprintf (str, \"b%s %s%s%s\", sibcall ? \"\" : \"l\", z, arg,\n \t     sibcall ? \"\" : \"\\n\\tnop\");\n@@ -21400,15 +21436,15 @@ rs6000_call_template_1 (rtx *operands ATTRIBUTE_UNUSED, unsigned int funop,\n }\n \n const char *\n-rs6000_call_template (rtx *operands, unsigned int funop, const char *arg)\n+rs6000_call_template (rtx *operands, unsigned int funop)\n {\n-  return rs6000_call_template_1 (operands, funop, false, arg);\n+  return rs6000_call_template_1 (operands, funop, false);\n }\n \n const char *\n-rs6000_sibcall_template (rtx *operands, unsigned int funop, const char *arg)\n+rs6000_sibcall_template (rtx *operands, unsigned int funop)\n {\n-  return rs6000_call_template_1 (operands, funop, true, arg);\n+  return rs6000_call_template_1 (operands, funop, true);\n }\n \n /* As above, for indirect calls.  */\n@@ -32498,23 +32534,20 @@ rs6000_set_default_type_attributes (tree type)\n /* Return a reference suitable for calling a function with the\n    longcall attribute.  */\n \n-rtx\n+static rtx\n rs6000_longcall_ref (rtx call_ref)\n {\n-  const char *call_name;\n-  tree node;\n-\n   if (GET_CODE (call_ref) != SYMBOL_REF)\n     return call_ref;\n \n   /* System V adds '.' to the internal name, so skip them.  */\n-  call_name = XSTR (call_ref, 0);\n+  const char *call_name = XSTR (call_ref, 0);\n   if (*call_name == '.')\n     {\n       while (*call_name == '.')\n \tcall_name++;\n \n-      node = get_identifier (call_name);\n+      tree node = get_identifier (call_name);\n       call_ref = gen_rtx_SYMBOL_REF (VOIDmode, IDENTIFIER_POINTER (node));\n     }\n \n@@ -37485,7 +37518,7 @@ chain_already_loaded (rtx_insn *last)\n /* Expand code to perform a call under the AIX or ELFv2 ABI.  */\n \n void\n-rs6000_call_aix (rtx value, rtx func_desc, rtx flag, rtx cookie)\n+rs6000_call_aix (rtx value, rtx func_desc, rtx tlsarg, rtx cookie)\n {\n   const bool direct_call_p\n     = GET_CODE (func_desc) == SYMBOL_REF && SYMBOL_REF_FUNCTION_P (func_desc);\n@@ -37498,6 +37531,9 @@ rs6000_call_aix (rtx value, rtx func_desc, rtx flag, rtx cookie)\n   int n_call;\n   rtx insn;\n \n+  if (global_tlsarg)\n+    tlsarg = global_tlsarg;\n+\n   /* Handle longcall attributes.  */\n   if (INTVAL (cookie) & CALL_LONG)\n     func_desc = rs6000_longcall_ref (func_desc);\n@@ -37508,11 +37544,7 @@ rs6000_call_aix (rtx value, rtx func_desc, rtx flag, rtx cookie)\n     {\n       /* Save the TOC into its reserved slot before the call,\n \t and prepare to restore it after the call.  */\n-      rtx stack_ptr = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n       rtx stack_toc_offset = GEN_INT (RS6000_TOC_SAVE_SLOT);\n-      rtx stack_toc_mem = gen_frame_mem (Pmode,\n-\t\t\t\t\t gen_rtx_PLUS (Pmode, stack_ptr,\n-\t\t\t\t\t\t       stack_toc_offset));\n       rtx stack_toc_unspec = gen_rtx_UNSPEC (Pmode,\n \t\t\t\t\t     gen_rtvec (1, stack_toc_offset),\n \t\t\t\t\t     UNSPEC_TOCSLOT);\n@@ -37524,6 +37556,10 @@ rs6000_call_aix (rtx value, rtx func_desc, rtx flag, rtx cookie)\n \tcfun->machine->save_toc_in_prologue = true;\n       else\n \t{\n+\t  rtx stack_ptr = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n+\t  rtx stack_toc_mem = gen_frame_mem (Pmode,\n+\t\t\t\t\t     gen_rtx_PLUS (Pmode, stack_ptr,\n+\t\t\t\t\t\t\t   stack_toc_offset));\n \t  MEM_VOLATILE_P (stack_toc_mem) = 1;\n \t  emit_move_insn (stack_toc_mem, toc_reg);\n \t}\n@@ -37533,7 +37569,8 @@ rs6000_call_aix (rtx value, rtx func_desc, rtx flag, rtx cookie)\n \t  /* A function pointer in the ELFv2 ABI is just a plain address, but\n \t     the ABI requires it to be loaded into r12 before the call.  */\n \t  func_addr = gen_rtx_REG (Pmode, 12);\n-\t  emit_move_insn (func_addr, func_desc);\n+\t  if (!rtx_equal_p (func_addr, func_desc))\n+\t    emit_move_insn (func_addr, func_desc);\n \t  abi_reg = func_addr;\n \t}\n       else\n@@ -37588,7 +37625,7 @@ rs6000_call_aix (rtx value, rtx func_desc, rtx flag, rtx cookie)\n     }\n \n   /* Create the call.  */\n-  call[0] = gen_rtx_CALL (VOIDmode, gen_rtx_MEM (SImode, func_addr), flag);\n+  call[0] = gen_rtx_CALL (VOIDmode, gen_rtx_MEM (SImode, func_addr), tlsarg);\n   if (value != NULL_RTX)\n     call[0] = gen_rtx_SET (value, call[0]);\n   n_call = 1;\n@@ -37612,15 +37649,18 @@ rs6000_call_aix (rtx value, rtx func_desc, rtx flag, rtx cookie)\n /* Expand code to perform a sibling call under the AIX or ELFv2 ABI.  */\n \n void\n-rs6000_sibcall_aix (rtx value, rtx func_desc, rtx flag, rtx cookie)\n+rs6000_sibcall_aix (rtx value, rtx func_desc, rtx tlsarg, rtx cookie)\n {\n   rtx call[2];\n   rtx insn;\n \n   gcc_assert (INTVAL (cookie) == 0);\n \n+  if (global_tlsarg)\n+    tlsarg = global_tlsarg;\n+\n   /* Create the call.  */\n-  call[0] = gen_rtx_CALL (VOIDmode, gen_rtx_MEM (SImode, func_desc), flag);\n+  call[0] = gen_rtx_CALL (VOIDmode, gen_rtx_MEM (SImode, func_desc), tlsarg);\n   if (value != NULL_RTX)\n     call[0] = gen_rtx_SET (value, call[0]);\n \n@@ -37633,6 +37673,42 @@ rs6000_sibcall_aix (rtx value, rtx func_desc, rtx flag, rtx cookie)\n   use_reg (&CALL_INSN_FUNCTION_USAGE (insn), gen_rtx_REG (Pmode, TOC_REGNUM));\n }\n \n+/* Expand code to perform a call under the SYSV4 ABI.  */\n+\n+void\n+rs6000_call_sysv (rtx value, rtx func, rtx tlsarg, rtx cookie)\n+{\n+  rtx func_addr;\n+  rtx call[3];\n+  rtx insn;\n+\n+  if (global_tlsarg)\n+    tlsarg = global_tlsarg;\n+\n+  /* Handle longcall attributes.  */\n+  if (INTVAL (cookie) & CALL_LONG)\n+    func = rs6000_longcall_ref (func);\n+\n+  /* Handle indirect calls.  */\n+  if (GET_CODE (func) != SYMBOL_REF)\n+    func_addr = force_reg (Pmode, func);\n+  else\n+    func_addr = func;\n+\n+  /* Create the call.  */\n+  call[0] = gen_rtx_CALL (VOIDmode, gen_rtx_MEM (SImode, func_addr), tlsarg);\n+  if (value != NULL_RTX)\n+    call[0] = gen_rtx_SET (value, call[0]);\n+\n+  unsigned int mask = CALL_V4_SET_FP_ARGS | CALL_V4_CLEAR_FP_ARGS;\n+  call[1] = gen_rtx_USE (VOIDmode, GEN_INT (INTVAL (cookie) & mask));\n+\n+  call[2] = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, LR_REGNO));\n+\n+  insn = gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (3, call));\n+  insn = emit_call_insn (insn);\n+}\n+\n /* Return whether we need to always update the saved TOC pointer when we update\n    the stack pointer.  */\n "}, {"sha": "ac87bb964364d391d71bd94506ddcc55177c98f5", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 70, "deletions": 225, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ece3bca2bd08bd02028f9ac6b0a2b6b8fa111305/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ece3bca2bd08bd02028f9ac6b0a2b6b8fa111305/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=ece3bca2bd08bd02028f9ac6b0a2b6b8fa111305", "patch": "@@ -9422,74 +9422,51 @@\n \f\n ;; TLS support.\n \n-(define_insn_and_split \"tls_gd_aix<bits>\"\n-  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=b\")\n-        (call (mem:SI (match_operand:P 3 \"symbol_ref_operand\" \"s\"))\n-\t      (match_operand 4)))\n-   (unspec:P [(match_operand:P 1 \"gpc_reg_operand\" \"b\")\n-\t      (match_operand:P 2 \"rs6000_tls_symbol_ref\" \"\")]\n-\t     UNSPEC_TLSGD)\n-   (clobber (reg:SI LR_REGNO))]\n-  \"HAVE_AS_TLS && (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\"\n-{\n-  if (TARGET_CMODEL != CMODEL_SMALL)\n-    output_asm_insn (\"addis %0,%1,%2@got@tlsgd@ha\\;\"\n-\t\t     \"addi %0,%0,%2@got@tlsgd@l\", operands);\n+(define_insn \"*tls_gdld_nomark<bits>\"\n+  [(match_parallel 3 \"\"\n+    [(set (match_operand:P 0 \"gpc_reg_operand\" \"=b\")\n+\t  (call (mem:SI (match_operand:P 1))\n+\t\t(match_operand:P 2 \"unspec_tls\")))\n+     (match_dup 2)])]\n+  \"HAVE_AS_TLS && !TARGET_TLS_MARKERS && DEFAULT_ABI != ABI_DARWIN\"\n+{\n+  rtx op[3];\n+  op[0] = operands[0];\n+  op[1] = XVECEXP (operands[2], 0, 0);\n+  if (XINT (operands[2], 1) == UNSPEC_TLSGD)\n+    {\n+      op[2] = XVECEXP (operands[2], 0, 1);\n+      if (TARGET_CMODEL != CMODEL_SMALL)\n+\toutput_asm_insn (\"addis %0,%2,%1@got@tlsgd@ha\\;\"\n+\t\t\t \"addi %0,%0,%1@got@tlsgd@l\", op);\n+      else\n+\toutput_asm_insn (\"addi %0,%2,%1@got@tlsgd\", op);\n+    }\n   else\n-    output_asm_insn (\"addi %0,%1,%2@got@tlsgd\", operands);\n-  return rs6000_call_template (operands, 3, \"\");\n+    {\n+      if (TARGET_CMODEL != CMODEL_SMALL)\n+\toutput_asm_insn (\"addis %0,%1,%&@got@tlsld@ha\\;\"\n+\t\t\t \"addi %0,%0,%&@got@tlsld@l\", op);\n+      else\n+\toutput_asm_insn (\"addi %0,%1,%&@got@tlsld\", op);\n+    }\n+  return rs6000_call_template (operands, 1);\n }\n-  \"&& TARGET_TLS_MARKERS\"\n-  [(set (match_dup 0)\n-\t(unspec:P [(match_dup 1)\n-\t\t   (match_dup 2)]\n-\t\t  UNSPEC_TLSGD))\n-   (parallel [(set (match_dup 0)\n-\t\t   (call (mem:SI (match_dup 3))\n-\t\t\t (match_dup 4)))\n-\t      (unspec:P [(match_dup 2)] UNSPEC_TLSGD)\n-\t      (clobber (reg:SI LR_REGNO))])]\n-  \"\"\n   [(set_attr \"type\" \"two\")\n    (set (attr \"length\")\n-     (if_then_else (ne (symbol_ref \"TARGET_CMODEL\") (symbol_ref \"CMODEL_SMALL\"))\n-\t\t   (const_int 16)\n-\t\t   (const_int 12)))])\n-\n-(define_insn_and_split \"tls_gd_sysv<mode>\"\n-  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=b\")\n-        (call (mem:SI (match_operand:P 3 \"symbol_ref_operand\" \"s\"))\n-\t      (match_operand 4)))\n-   (unspec:P [(match_operand:P 1 \"gpc_reg_operand\" \"b\")\n-\t      (match_operand:P 2 \"rs6000_tls_symbol_ref\" \"\")]\n-\t     UNSPEC_TLSGD)\n-   (clobber (reg:SI LR_REGNO))]\n-  \"HAVE_AS_TLS && DEFAULT_ABI == ABI_V4\"\n-{\n-  output_asm_insn (\"addi %0,%1,%2@got@tlsgd\", operands);\n-  return rs6000_call_template (operands, 3, \"\");\n-}\n-  \"&& TARGET_TLS_MARKERS\"\n-  [(set (match_dup 0)\n-\t(unspec:P [(match_dup 1)\n-\t\t   (match_dup 2)]\n-\t\t  UNSPEC_TLSGD))\n-   (parallel [(set (match_dup 0)\n-\t\t   (call (mem:SI (match_dup 3))\n-\t\t\t (match_dup 4)))\n-\t      (unspec:P [(match_dup 2)] UNSPEC_TLSGD)\n-\t      (clobber (reg:SI LR_REGNO))])]\n-  \"\"\n-  [(set_attr \"type\" \"two\")\n-   (set_attr \"length\" \"8\")])\n+     (cond [(match_test \"TARGET_CMODEL != CMODEL_SMALL\")\n+\t\t(const_int 16)\n+\t    (match_test \"DEFAULT_ABI != ABI_V4\")\n+\t\t(const_int 12)]\n+\t(const_int 8)))])\n \n (define_insn_and_split \"*tls_gd<bits>\"\n   [(set (match_operand:P 0 \"gpc_reg_operand\" \"=b\")\n-\t(unspec:P [(match_operand:P 1 \"gpc_reg_operand\" \"b\")\n-\t\t   (match_operand:P 2 \"rs6000_tls_symbol_ref\" \"\")]\n+\t(unspec:P [(match_operand:P 1 \"rs6000_tls_symbol_ref\" \"\")\n+\t\t   (match_operand:P 2 \"gpc_reg_operand\" \"b\")]\n \t\t  UNSPEC_TLSGD))]\n   \"HAVE_AS_TLS && TARGET_TLS_MARKERS\"\n-  \"addi %0,%1,%2@got@tlsgd\"\n+  \"addi %0,%2,%1@got@tlsgd\"\n   \"&& TARGET_CMODEL != CMODEL_SMALL\"\n   [(set (match_dup 3)\n \t(high:P\n@@ -9498,7 +9475,7 @@\n \t(lo_sum:P (match_dup 3)\n \t    (unspec:P [(match_dup 1) (match_dup 2)] UNSPEC_TLSGD)))]\n {\n-  operands[3] = gen_reg_rtx (TARGET_64BIT ? DImode : SImode);\n+  operands[3] = gen_reg_rtx (<MODE>mode);\n }\n   [(set (attr \"length\")\n      (if_then_else (ne (symbol_ref \"TARGET_CMODEL\") (symbol_ref \"CMODEL_SMALL\"))\n@@ -9508,105 +9485,21 @@\n (define_insn \"*tls_gd_high<bits>\"\n   [(set (match_operand:P 0 \"gpc_reg_operand\" \"=b\")\n      (high:P\n-       (unspec:P [(match_operand:P 1 \"gpc_reg_operand\" \"b\")\n-\t\t  (match_operand:P 2 \"rs6000_tls_symbol_ref\" \"\")]\n+       (unspec:P [(match_operand:P 1 \"rs6000_tls_symbol_ref\" \"\")\n+\t\t  (match_operand:P 2 \"gpc_reg_operand\" \"b\")]\n \t\t UNSPEC_TLSGD)))]\n   \"HAVE_AS_TLS && TARGET_TLS_MARKERS && TARGET_CMODEL != CMODEL_SMALL\"\n-  \"addis %0,%1,%2@got@tlsgd@ha\")\n+  \"addis %0,%2,%1@got@tlsgd@ha\")\n \n (define_insn \"*tls_gd_low<bits>\"\n   [(set (match_operand:P 0 \"gpc_reg_operand\" \"=b\")\n      (lo_sum:P (match_operand:P 1 \"gpc_reg_operand\" \"b\")\n-       (unspec:P [(match_operand:P 3 \"gpc_reg_operand\" \"b\")\n-\t\t  (match_operand:P 2 \"rs6000_tls_symbol_ref\" \"\")]\n+       (unspec:P [(match_operand:P 2 \"rs6000_tls_symbol_ref\" \"\")\n+\t\t  (match_operand:P 3 \"gpc_reg_operand\" \"b\")]\n \t\t UNSPEC_TLSGD)))]\n   \"HAVE_AS_TLS && TARGET_TLS_MARKERS && TARGET_CMODEL != CMODEL_SMALL\"\n   \"addi %0,%1,%2@got@tlsgd@l\")\n \n-(define_insn \"*tls_gd_call_aix<bits>\"\n-  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=b\")\n-        (call (mem:SI (match_operand:P 1 \"symbol_ref_operand\" \"s\"))\n-\t      (match_operand 2)))\n-   (unspec:P [(match_operand:P 3 \"rs6000_tls_symbol_ref\" \"\")]\n-\t     UNSPEC_TLSGD)\n-   (clobber (reg:SI LR_REGNO))]\n-  \"HAVE_AS_TLS && TARGET_TLS_MARKERS\n-   && (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\"\n-{\n-  return rs6000_call_template (operands, 1, \"(%3@tlsgd)\");\n-}\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"8\")])\n-\n-(define_insn \"*tls_gd_call_sysv<bits>\"\n-  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=b\")\n-        (call (mem:SI (match_operand:P 1 \"symbol_ref_operand\" \"s\"))\n-\t      (match_operand 2)))\n-   (unspec:P [(match_operand:P 3 \"rs6000_tls_symbol_ref\" \"\")]\n-\t     UNSPEC_TLSGD)\n-   (clobber (reg:SI LR_REGNO))]\n-  \"HAVE_AS_TLS && DEFAULT_ABI == ABI_V4 && TARGET_TLS_MARKERS\"\n-{\n-  return rs6000_call_template (operands, 1, \"(%3@tlsgd)\");\n-}\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn_and_split \"tls_ld_aix<bits>\"\n-  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=b\")\n-        (call (mem:SI (match_operand:P 2 \"symbol_ref_operand\" \"s\"))\n-\t      (match_operand 3)))\n-   (unspec:P [(match_operand:P 1 \"gpc_reg_operand\" \"b\")]\n-\t     UNSPEC_TLSLD)\n-   (clobber (reg:SI LR_REGNO))]\n-  \"HAVE_AS_TLS && (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\"\n-{\n-  if (TARGET_CMODEL != CMODEL_SMALL)\n-    output_asm_insn (\"addis %0,%1,%&@got@tlsld@ha\\;\"\n-\t\t     \"addi %0,%0,%&@got@tlsld@l\", operands);\n-  else\n-    output_asm_insn (\"addi %0,%1,%&@got@tlsld\", operands);\n-  return rs6000_call_template (operands, 2, \"\");\n-}\n-  \"&& TARGET_TLS_MARKERS\"\n-  [(set (match_dup 0)\n-\t(unspec:P [(match_dup 1)]\n-\t\t  UNSPEC_TLSLD))\n-   (parallel [(set (match_dup 0)\n-\t\t   (call (mem:SI (match_dup 2))\n-\t\t\t (match_dup 3)))\n-\t      (unspec:P [(const_int 0)] UNSPEC_TLSLD)\n-\t      (clobber (reg:SI LR_REGNO))])]\n-  \"\"\n-  [(set_attr \"type\" \"two\")\n-   (set (attr \"length\")\n-     (if_then_else (ne (symbol_ref \"TARGET_CMODEL\") (symbol_ref \"CMODEL_SMALL\"))\n-\t\t   (const_int 16)\n-\t\t   (const_int 12)))])\n-\n-(define_insn_and_split \"tls_ld_sysv<mode>\"\n-  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=b\")\n-        (call (mem:SI (match_operand:P 2 \"symbol_ref_operand\" \"s\"))\n-\t      (match_operand 3)))\n-   (unspec:P [(match_operand:P 1 \"gpc_reg_operand\" \"b\")]\n-\t     UNSPEC_TLSLD)\n-   (clobber (reg:SI LR_REGNO))]\n-  \"HAVE_AS_TLS && DEFAULT_ABI == ABI_V4\"\n-{\n-  output_asm_insn (\"addi %0,%1,%&@got@tlsld\", operands);\n-  return rs6000_call_template (operands, 2, \"\");\n-}\n-  \"&& TARGET_TLS_MARKERS\"\n-  [(set (match_dup 0)\n-\t(unspec:P [(match_dup 1)]\n-\t\t  UNSPEC_TLSLD))\n-   (parallel [(set (match_dup 0)\n-\t\t   (call (mem:SI (match_dup 2))\n-\t\t\t (match_dup 3)))\n-\t      (unspec:P [(const_int 0)] UNSPEC_TLSLD)\n-\t      (clobber (reg:SI LR_REGNO))])]\n-  \"\"\n-  [(set_attr \"length\" \"8\")])\n-\n (define_insn_and_split \"*tls_ld<bits>\"\n   [(set (match_operand:P 0 \"gpc_reg_operand\" \"=b\")\n \t(unspec:P [(match_operand:P 1 \"gpc_reg_operand\" \"b\")]\n@@ -9616,12 +9509,12 @@\n   \"&& TARGET_CMODEL != CMODEL_SMALL\"\n   [(set (match_dup 2)\n \t(high:P\n-\t    (unspec:P [(const_int 0) (match_dup 1)] UNSPEC_TLSLD)))\n+\t    (unspec:P [(match_dup 1)] UNSPEC_TLSLD)))\n    (set (match_dup 0)\n \t(lo_sum:P (match_dup 2)\n-\t    (unspec:P [(const_int 0) (match_dup 1)] UNSPEC_TLSLD)))]\n+\t    (unspec:P [(match_dup 1)] UNSPEC_TLSLD)))]\n {\n-  operands[2] = gen_reg_rtx (TARGET_64BIT ? DImode : SImode);\n+  operands[2] = gen_reg_rtx (<MODE>mode);\n }\n   [(set (attr \"length\")\n      (if_then_else (ne (symbol_ref \"TARGET_CMODEL\") (symbol_ref \"CMODEL_SMALL\"))\n@@ -9631,47 +9524,19 @@\n (define_insn \"*tls_ld_high<bits>\"\n   [(set (match_operand:P 0 \"gpc_reg_operand\" \"=b\")\n      (high:P\n-       (unspec:P [(const_int 0)\n-\t\t  (match_operand:P 1 \"gpc_reg_operand\" \"b\")]\n+       (unspec:P [(match_operand:P 1 \"gpc_reg_operand\" \"b\")]\n \t\t UNSPEC_TLSLD)))]\n   \"HAVE_AS_TLS && TARGET_TLS_MARKERS && TARGET_CMODEL != CMODEL_SMALL\"\n   \"addis %0,%1,%&@got@tlsld@ha\")\n \n (define_insn \"*tls_ld_low<bits>\"\n   [(set (match_operand:P 0 \"gpc_reg_operand\" \"=b\")\n      (lo_sum:P (match_operand:P 1 \"gpc_reg_operand\" \"b\")\n-       (unspec:P [(const_int 0)\n-\t\t  (match_operand:P 2 \"gpc_reg_operand\" \"b\")]\n+       (unspec:P [(match_operand:P 2 \"gpc_reg_operand\" \"b\")]\n \t\t UNSPEC_TLSLD)))]\n   \"HAVE_AS_TLS && TARGET_TLS_MARKERS && TARGET_CMODEL != CMODEL_SMALL\"\n   \"addi %0,%1,%&@got@tlsld@l\")\n \n-(define_insn \"*tls_ld_call_aix<bits>\"\n-  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=b\")\n-        (call (mem:SI (match_operand:P 1 \"symbol_ref_operand\" \"s\"))\n-\t      (match_operand 2)))\n-   (unspec:P [(const_int 0)] UNSPEC_TLSLD)\n-   (clobber (reg:SI LR_REGNO))]\n-  \"HAVE_AS_TLS && TARGET_TLS_MARKERS\n-   && (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\"\n-{\n-  return rs6000_call_template (operands, 1, \"(%&@tlsld)\");\n-}\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"8\")])\n-\n-(define_insn \"*tls_ld_call_sysv<bits>\"\n-  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=b\")\n-        (call (mem:SI (match_operand:P 1 \"symbol_ref_operand\" \"s\"))\n-\t      (match_operand 2)))\n-   (unspec:P [(const_int 0)] UNSPEC_TLSLD)\n-   (clobber (reg:SI LR_REGNO))]\n-  \"HAVE_AS_TLS && DEFAULT_ABI == ABI_V4 && TARGET_TLS_MARKERS\"\n-{\n-  return rs6000_call_template (operands, 1, \"(%&@tlsld)\");\n-}\n-  [(set_attr \"type\" \"branch\")])\n-\n (define_insn \"tls_dtprel_<bits>\"\n   [(set (match_operand:P 0 \"gpc_reg_operand\" \"=r\")\n \t(unspec:P [(match_operand:P 1 \"gpc_reg_operand\" \"b\")\n@@ -10345,7 +10210,6 @@\n #endif\n \n   gcc_assert (GET_CODE (operands[0]) == MEM);\n-  gcc_assert (GET_CODE (operands[1]) == CONST_INT);\n \n   operands[0] = XEXP (operands[0], 0);\n \n@@ -10355,23 +10219,14 @@\n       DONE;\n     }\n \n-  if (GET_CODE (operands[0]) != SYMBOL_REF\n-      || (DEFAULT_ABI != ABI_DARWIN && (INTVAL (operands[2]) & CALL_LONG) != 0))\n+  if (DEFAULT_ABI == ABI_V4)\n     {\n-      if (INTVAL (operands[2]) & CALL_LONG)\n-\toperands[0] = rs6000_longcall_ref (operands[0]);\n-\n-      switch (DEFAULT_ABI)\n-        {\n-\tcase ABI_V4:\n-\tcase ABI_DARWIN:\n-\t  operands[0] = force_reg (Pmode, operands[0]);\n-\t  break;\n-\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n+      rs6000_call_sysv (NULL_RTX, operands[0], operands[1], operands[2]);\n+      DONE;\n     }\n+\n+  if (GET_CODE (operands[0]) != SYMBOL_REF)\n+    operands[0] = force_reg (Pmode, operands[0]);\n })\n \n (define_expand \"call_value\"\n@@ -10388,7 +10243,6 @@\n #endif\n \n   gcc_assert (GET_CODE (operands[1]) == MEM);\n-  gcc_assert (GET_CODE (operands[2]) == CONST_INT);\n \n   operands[1] = XEXP (operands[1], 0);\n \n@@ -10398,23 +10252,14 @@\n       DONE;\n     }\n \n-  if (GET_CODE (operands[1]) != SYMBOL_REF\n-      || (DEFAULT_ABI != ABI_DARWIN && (INTVAL (operands[3]) & CALL_LONG) != 0))\n+  if (DEFAULT_ABI == ABI_V4)\n     {\n-      if (INTVAL (operands[3]) & CALL_LONG)\n-\toperands[1] = rs6000_longcall_ref (operands[1]);\n-\n-      switch (DEFAULT_ABI)\n-        {\n-\tcase ABI_V4:\n-\tcase ABI_DARWIN:\n-\t  operands[1] = force_reg (Pmode, operands[1]);\n-\t  break;\n-\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n+      rs6000_call_sysv (operands[0], operands[1], operands[2], operands[3]);\n+      DONE;\n     }\n+\n+  if (GET_CODE (operands[1]) != SYMBOL_REF)\n+    operands[1] = force_reg (Pmode, operands[1]);\n })\n \n ;; Call to function in current module.  No TOC pointer reload needed.\n@@ -10501,7 +10346,7 @@\n \n ;; A function pointer under System V is just a normal pointer\n ;; operands[0] is the function pointer\n-;; operands[1] is the stack size to clean up\n+;; operands[1] is the tls call arg\n ;; operands[2] is the value FUNCTION_ARG returns for the VOID argument\n ;; which indicates how to set cr1\n \n@@ -10552,7 +10397,7 @@\n #if TARGET_MACHO\n   return macho_call_template (insn, operands, 0, 2);\n #else\n-  return rs6000_call_template (operands, 0, \"\");\n+  return rs6000_call_template (operands, 0);\n #endif\n }\n   \"DEFAULT_ABI == ABI_V4\n@@ -10585,7 +10430,7 @@\n   else if (INTVAL (operands[2]) & CALL_V4_CLEAR_FP_ARGS)\n     output_asm_insn (\"creqv 6,6,6\", operands);\n \n-  return rs6000_call_template (operands, 0, \"\");\n+  return rs6000_call_template (operands, 0);\n }\n   [(set_attr \"type\" \"branch,branch\")\n    (set_attr \"length\" \"4,8\")])\n@@ -10639,7 +10484,7 @@\n #if TARGET_MACHO\n   return macho_call_template (insn, operands, 1, 3);\n #else\n-  return rs6000_call_template (operands, 1, \"\");\n+  return rs6000_call_template (operands, 1);\n #endif\n }\n   \"DEFAULT_ABI == ABI_V4\n@@ -10674,7 +10519,7 @@\n   else if (INTVAL (operands[3]) & CALL_V4_CLEAR_FP_ARGS)\n     output_asm_insn (\"creqv 6,6,6\", operands);\n \n-  return rs6000_call_template (operands, 1, \"\");\n+  return rs6000_call_template (operands, 1);\n }\n   [(set_attr \"type\" \"branch,branch\")\n    (set_attr \"length\" \"4,8\")])\n@@ -10708,7 +10553,7 @@\n    (clobber (reg:P LR_REGNO))]\n   \"DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2\"\n {\n-  return rs6000_call_template (operands, 0, \"\");\n+  return rs6000_call_template (operands, 0);\n }\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"8\")])\n@@ -10720,7 +10565,7 @@\n    (clobber (reg:P LR_REGNO))]\n   \"DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2\"\n {\n-  return rs6000_call_template (operands, 1, \"\");\n+  return rs6000_call_template (operands, 1);\n }\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"8\")])\n@@ -10971,7 +10816,7 @@\n   if (which_alternative >= 2)\n     return rs6000_indirect_sibcall_template (operands, 0);\n   else\n-    return rs6000_sibcall_template (operands, 0, \"\");\n+    return rs6000_sibcall_template (operands, 0);\n }\n   [(set_attr \"type\" \"branch\")\n    (set_attr_alternative \"length\"\n@@ -11011,7 +10856,7 @@\n \treturn \"crset 2\\;beq%T1-\\;b $\";\n     }\n   else\n-    return rs6000_sibcall_template (operands, 1, \"\");\n+    return rs6000_sibcall_template (operands, 1);\n }\n   [(set_attr \"type\" \"branch\")\n    (set_attr_alternative \"length\"\n@@ -11035,7 +10880,7 @@\n   \"DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2\"\n {\n   if (which_alternative == 0)\n-    return rs6000_sibcall_template (operands, 0, \"\");\n+    return rs6000_sibcall_template (operands, 0);\n   else\n     return \"b%T0\";\n }\n@@ -11049,7 +10894,7 @@\n   \"DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2\"\n {\n   if (which_alternative == 0)\n-    return rs6000_sibcall_template (operands, 1, \"\");\n+    return rs6000_sibcall_template (operands, 1);\n   else\n     return \"b%T1\";\n }"}]}