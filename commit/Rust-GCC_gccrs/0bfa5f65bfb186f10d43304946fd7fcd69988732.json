{"sha": "0bfa5f65bfb186f10d43304946fd7fcd69988732", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJmYTVmNjViZmIxODZmMTBkNDMzMDQ5NDZmZDdmY2Q2OTk4ODczMg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2003-06-04T17:06:00Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-06-04T17:06:00Z"}, "message": "c-common.c (handle_cleanup_attribute): New.\n\n        * c-common.c (handle_cleanup_attribute): New.\n        (c_common_attributes): Add it.\n        * c-decl.c (finish_decl): Honor the cleanup attribute.\n        * doc/extend.texi (Variable Attributes): Document it.\n\n        * unwind-c.c: New file.\n        * Makefile.in (LIB2ADDEH): Add it.\n        * config/t-darwin, config/t-linux, config/t-linux-gnulibc1,\n        config/ia64/t-ia64: Likewise.\n\n        * gcc.dg/cleanup-1.c: New.\n        * gcc.dg/cleanup-2.c: New.\n        * gcc.dg/cleanup-3.c: New.\n        * gcc.dg/cleanup-4.c: New.\n        * gcc.dg/cleanup-5.c: New.\n        * gcc.dg/cleanup-6.c: New.\n        * gcc.dg/cleanup-7.c: New.\n\nFrom-SVN: r67449", "tree": {"sha": "d3d591092d6a64dfc049785317e9f17e96cf7276", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3d591092d6a64dfc049785317e9f17e96cf7276"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0bfa5f65bfb186f10d43304946fd7fcd69988732", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bfa5f65bfb186f10d43304946fd7fcd69988732", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bfa5f65bfb186f10d43304946fd7fcd69988732", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bfa5f65bfb186f10d43304946fd7fcd69988732/comments", "author": null, "committer": null, "parents": [{"sha": "3edc56a9e5499b79239967350162066d99eaf95a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3edc56a9e5499b79239967350162066d99eaf95a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3edc56a9e5499b79239967350162066d99eaf95a"}], "stats": {"total": 560, "additions": 552, "deletions": 8}, "files": [{"sha": "548ba28ea86c8d0d3a94a3ea16d1d6656933dc67", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0bfa5f65bfb186f10d43304946fd7fcd69988732", "patch": "@@ -1,3 +1,15 @@\n+2003-06-04  Richard Henderson  <rth@redhat.com>\n+\n+        * c-common.c (handle_cleanup_attribute): New.\n+        (c_common_attributes): Add it.\n+        * c-decl.c (finish_decl): Honor the cleanup attribute.\n+        * doc/extend.texi (Variable Attributes): Document it.\n+\n+        * unwind-c.c: New file.\n+        * Makefile.in (LIB2ADDEH): Add it.\n+        * config/t-darwin, config/t-linux, config/t-linux-gnulibc1,\n+        config/ia64/t-ia64: Likewise.\n+\n 2003-06-04  Jakub Jelinek  <jakub@redhat.com>\n \n \t* function.c (trampolines_created): New variable."}, {"sha": "6755643d7425c108bffe2f2845a32644b85ec7d4", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0bfa5f65bfb186f10d43304946fd7fcd69988732", "patch": "@@ -472,7 +472,7 @@ CRTSTUFF_CFLAGS = -O2 $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -g0 \\\n \n # Additional sources to handle exceptions; overridden by targets as needed.\n LIB2ADDEH = $(srcdir)/unwind-dw2.c $(srcdir)/unwind-dw2-fde.c \\\n-   $(srcdir)/unwind-sjlj.c $(srcdir)/gthr-gnat.c\n+   $(srcdir)/unwind-sjlj.c $(srcdir)/gthr-gnat.c $(srcdir)/unwind-c.c\n LIB2ADDEHDEP = unwind.inc unwind-dw2-fde.h\n \n # nm flags to list global symbols in libgcc object files.\n@@ -1261,7 +1261,7 @@ c-incpath.o: c-incpath.c c-incpath.h $(CONFIG_H) $(SYSTEM_H) $(CPPLIB_H) \\\n c-decl.o : c-decl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n     $(RTL_H) $(C_TREE_H) $(GGC_H) $(TARGET_H) flags.h function.h output.h \\\n     $(EXPR_H) debug.h toplev.h intl.h $(TM_P_H) tree-inline.h $(TIMEVAR_H) \\\n-    c-pragma.h gt-c-decl.h cgraph.h $(HASHTAB_H)\n+    c-pragma.h gt-c-decl.h cgraph.h $(HASHTAB_H) libfuncs.h except.h\n c-typeck.o : c-typeck.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(C_TREE_H) \\\n     $(TARGET_H) flags.h intl.h output.h $(EXPR_H) $(RTL_H) toplev.h $(TM_P_H)\n c-lang.o : c-lang.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(C_TREE_H) \\\n@@ -1310,7 +1310,8 @@ tlink.o: tlink.c $(DEMANGLE_H) $(HASHTAB_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h\n c-common.o : c-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n \t$(OBSTACK_H) $(C_COMMON_H) flags.h toplev.h output.h c-pragma.h intl.h \\\n \t$(GGC_H) $(EXPR_H) $(TM_P_H) builtin-types.def builtin-attrs.def \\\n-\tdiagnostic.h gt-c-common.h langhooks.h varray.h $(RTL_H) $(TARGET_H)\n+\tdiagnostic.h gt-c-common.h langhooks.h varray.h $(RTL_H) $(TARGET_H) \\\n+\tc-tree.h\n c-pretty-print.o : c-pretty-print.c c-pretty-print.h pretty-print.h \\\n \t$(C_COMMON_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) real.h\n "}, {"sha": "d194012e9560cb5b29b1da9c620860d6831ad98a", "filename": "gcc/c-common.c", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=0bfa5f65bfb186f10d43304946fd7fcd69988732", "patch": "@@ -41,7 +41,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"target.h\"\n #include \"langhooks.h\"\n #include \"tree-inline.h\"\n-\n+#include \"c-tree.h\"\n \n cpp_reader *parse_in;\t\t/* Declared in c-pragma.h.  */\n \n@@ -792,6 +792,8 @@ static tree handle_nonnull_attribute\tPARAMS ((tree *, tree, tree, int,\n \t\t\t\t\t\t bool *));\n static tree handle_nothrow_attribute\tPARAMS ((tree *, tree, tree, int,\n \t\t\t\t\t\t bool *));\n+static tree handle_cleanup_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n static tree vector_size_helper PARAMS ((tree, tree));\n \n static void check_function_nonnull\tPARAMS ((tree, tree));\n@@ -868,6 +870,8 @@ const struct attribute_spec c_common_attribute_table[] =\n   { \"nothrow\",                0, 0, true,  false, false,\n \t\t\t      handle_nothrow_attribute },\n   { \"may_alias\",\t      0, 0, false, true, false, NULL },\n+  { \"cleanup\",\t\t      1, 1, true, false, false,\n+\t\t\t      handle_cleanup_attribute },\n   { NULL,                     0, 0, false, false, false, NULL }\n };\n \n@@ -6093,6 +6097,55 @@ handle_nothrow_attribute (node, name, args, flags, no_add_attrs)\n \n   return NULL_TREE;\n }\n+\n+/* Handle a \"cleanup\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_cleanup_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree decl = *node;\n+  tree cleanup_id, cleanup_decl;\n+\n+  /* ??? Could perhaps support cleanups on TREE_STATIC, much like we do\n+     for global destructors in C++.  This requires infrastructure that\n+     we don't have generically at the moment.  It's also not a feature\n+     we'd be missing too much, since we do have attribute constructor.  */\n+  if (TREE_CODE (decl) != VAR_DECL || TREE_STATIC (decl))\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n+\n+  /* Verify that the argument is a function in scope.  */\n+  /* ??? We could support pointers to functions here as well, if\n+     that was considered desirable.  */\n+  cleanup_id = TREE_VALUE (args);\n+  if (TREE_CODE (cleanup_id) != IDENTIFIER_NODE)\n+    {\n+      error (\"cleanup arg not an identifier\");\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n+  cleanup_decl = lookup_name (cleanup_id);\n+  if (!cleanup_decl || TREE_CODE (cleanup_decl) != FUNCTION_DECL)\n+    {\n+      error (\"cleanup arg not a function\");\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n+\n+  /* That the function has proper type is checked with the \n+     eventual call to build_function_call.  */\n+\n+  return NULL_TREE;\n+}\n \f\n /* Check for valid arguments being passed to a function.  */\n void"}, {"sha": "f9124e4a976222fde308add0fb95babedc6b9492", "filename": "gcc/c-decl.c", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=0bfa5f65bfb186f10d43304946fd7fcd69988732", "patch": "@@ -50,6 +50,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"c-pragma.h\"\n #include \"cgraph.h\"\n #include \"hashtab.h\"\n+#include \"libfuncs.h\"\n+#include \"except.h\"\n \n /* In grokdeclarator, distinguish syntactic contexts of declarators.  */\n enum decl_context\n@@ -2985,6 +2987,41 @@ finish_decl (decl, init, asmspec_tree)\n      computing them in the following function definition.  */\n   if (current_binding_level == global_binding_level)\n     get_pending_sizes ();\n+\n+  /* Install a cleanup (aka destructor) if one was given.  */\n+  if (TREE_CODE (decl) == VAR_DECL && !TREE_STATIC (decl))\n+    {\n+      tree attr = lookup_attribute (\"cleanup\", DECL_ATTRIBUTES (decl));\n+      if (attr)\n+\t{\n+\t  static bool eh_initialized_p;\n+\n+\t  tree cleanup_id = TREE_VALUE (TREE_VALUE (attr));\n+\t  tree cleanup_decl = lookup_name (cleanup_id);\n+\t  tree cleanup;\n+\n+\t  /* Build \"cleanup(&decl)\" for the destructor.  */\n+\t  cleanup = build_unary_op (ADDR_EXPR, decl, 0);\n+\t  cleanup = build_tree_list (NULL_TREE, cleanup);\n+\t  cleanup = build_function_call (cleanup_decl, cleanup);\n+\n+\t  /* Don't warn about decl unused; the cleanup uses it.  */\n+\t  TREE_USED (decl) = 1;\n+\n+\t  /* Initialize EH, if we've been told to do so.  */\n+\t  if (flag_exceptions && !eh_initialized_p)\n+\t    {\n+\t      eh_initialized_p = true;\n+\t      eh_personality_libfunc\n+\t\t= init_one_libfunc (USING_SJLJ_EXCEPTIONS\n+\t\t\t\t    ? \"__gcc_personality_sj0\"\n+\t\t\t\t    : \"__gcc_personality_v0\");\n+\t      using_eh_for_cleanups ();\n+\t    }\n+\n+\t  add_stmt (build_stmt (CLEANUP_STMT, decl, cleanup));\n+\t}\n+    }\n }\n \n /* Given a parsed parameter declaration,"}, {"sha": "0b8ab156b60ff26b161b212abd6064b97964ab43", "filename": "gcc/config/ia64/t-ia64", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Fconfig%2Fia64%2Ft-ia64", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Fconfig%2Fia64%2Ft-ia64", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Ft-ia64?ref=0bfa5f65bfb186f10d43304946fd7fcd69988732", "patch": "@@ -40,7 +40,8 @@ crtfastmath.o: $(srcdir)/config/ia64/crtfastmath.c $(GCC_PASSES)\n \t$(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -c -o crtfastmath.o \\\n \t\t$(srcdir)/config/ia64/crtfastmath.c\n \n-LIB2ADDEH = $(srcdir)/config/ia64/unwind-ia64.c $(srcdir)/unwind-sjlj.c\n+LIB2ADDEH = $(srcdir)/config/ia64/unwind-ia64.c $(srcdir)/unwind-sjlj.c \\\n+  $(srcdir)/unwind-c.c\n \n ia64-c.o: $(srcdir)/config/ia64/ia64-c.c $(CONFIG_H) $(SYSTEM_H) \\\n     coretypes.h $(TM_H) $(TREE_H) $(CPPLIB_H) $(C_COMMON_H) c-pragma.h toplev.h"}, {"sha": "c5741e432343871e09f0b167aff87b0d0006710b", "filename": "gcc/config/t-darwin", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Fconfig%2Ft-darwin", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Fconfig%2Ft-darwin", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ft-darwin?ref=0bfa5f65bfb186f10d43304946fd7fcd69988732", "patch": "@@ -18,5 +18,5 @@ $(T)crt2$(objext): $(srcdir)/config/darwin-crt2.c $(GCC_PASSES) \\\n \n # Use unwind-dw2-fde-darwin\n LIB2ADDEH = $(srcdir)/unwind-dw2.c $(srcdir)/unwind-dw2-fde-darwin.c \\\n-  $(srcdir)/unwind-sjlj.c\n+  $(srcdir)/unwind-sjlj.c $(srcdir)/unwind-c.c\n LIB2ADDEHDEP = unwind.inc unwind-dw2-fde.h unwind-dw2-fde.c"}, {"sha": "752387c62ad236d88276d9a3aeb18f5a50aaf7b4", "filename": "gcc/config/t-linux", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Fconfig%2Ft-linux", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Fconfig%2Ft-linux", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ft-linux?ref=0bfa5f65bfb186f10d43304946fd7fcd69988732", "patch": "@@ -12,5 +12,5 @@ SHLIB_MAPFILES += $(srcdir)/config/libgcc-glibc.ver\n \n # Use unwind-dw2-fde-glibc\n LIB2ADDEH = $(srcdir)/unwind-dw2.c $(srcdir)/unwind-dw2-fde-glibc.c \\\n-  $(srcdir)/unwind-sjlj.c $(srcdir)/gthr-gnat.c\n+  $(srcdir)/unwind-sjlj.c $(srcdir)/gthr-gnat.c $(srcdir)/unwind-c.c\n LIB2ADDEHDEP = unwind.inc unwind-dw2-fde.h unwind-dw2-fde.c gthr-gnat.c"}, {"sha": "52effd5ca2f3701328f1135c6115c4de4c996e60", "filename": "gcc/config/t-linux-gnulibc1", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Fconfig%2Ft-linux-gnulibc1", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Fconfig%2Ft-linux-gnulibc1", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ft-linux-gnulibc1?ref=0bfa5f65bfb186f10d43304946fd7fcd69988732", "patch": "@@ -3,5 +3,5 @@ T_CFLAGS = -DUSE_GNULIBC_1\n \n # Use unwind-dw2-fde\n LIB2ADDEH = $(srcdir)/unwind-dw2.c $(srcdir)/unwind-dw2-fde.c \\\n-  $(srcdir)/unwind-sjlj.c\n+  $(srcdir)/unwind-sjlj.c $(srcdir)/unwind-c.c\n LIB2ADDEHDEP = unwind.inc unwind-dw2-fde.h"}, {"sha": "0da4407b2dc3d2be1d297d44d03c974a61213a37", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=0bfa5f65bfb186f10d43304946fd7fcd69988732", "patch": "@@ -3034,6 +3034,22 @@ up to a maximum of 8 byte alignment, then specifying @code{aligned(16)}\n in an @code{__attribute__} will still only provide you with 8 byte\n alignment.  See your linker documentation for further information.\n \n+@item cleanup (@var{cleanup_function})\n+@cindex @code{cleanup} attribute\n+The @code{cleanup} attribute runs a function when the variable goes\n+out of scope.  This attribute can only be applied to auto function\n+scope variables; it may not be applied to parameters or variables\n+with static storage duration.  The function must take one parameter,\n+a pointer to a type compatible with the variable.  The return value\n+of the function (if any) is ignored.\n+\n+If @option{-fexceptions} is enabled, then @var{cleanup_function}\n+will be run during the stack unwinding that happens during the\n+processing of the exception.  Note that the @code{cleanup} attribute\n+does not allow the exception to be caught, only to perform an action.\n+It is undefined what happens if @var{cleanup_function} does not\n+return normally.\n+\n @item common\n @itemx nocommon\n @cindex @code{common} attribute"}, {"sha": "1acdb65494c0919f2ad4e65b5ece1e687199cf26", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0bfa5f65bfb186f10d43304946fd7fcd69988732", "patch": "@@ -1,3 +1,13 @@\n+2003-06-04  Richard Henderson  <rth@redhat.com>\n+\n+        * gcc.dg/cleanup-1.c: New.\n+        * gcc.dg/cleanup-2.c: New.\n+        * gcc.dg/cleanup-3.c: New.\n+        * gcc.dg/cleanup-4.c: New.\n+        * gcc.dg/cleanup-5.c: New.\n+        * gcc.dg/cleanup-6.c: New.\n+        * gcc.dg/cleanup-7.c: New.\n+\n 2003-06-04  Mark Mitchell  <mark@codesourcery.com>\n \n \t* g++.dg/abi/vague1.C: Use xfail, rather than embedded Tcl code."}, {"sha": "e5853c4baa82daa2be4b874badd7b6362da66706", "filename": "gcc/testsuite/gcc.dg/cleanup-1.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-1.c?ref=0bfa5f65bfb186f10d43304946fd7fcd69988732", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wall\" } */\n+/* Validate expected warnings and errors.  */\n+\n+#define U\t__attribute__((unused))\n+#define C(x)\t__attribute__((cleanup(x)))\n+\n+static int f1(void *x U) { return 0; }\n+static void f2() { }\n+static void f3(void) { }\n+static void f4(void *x U) { }\n+static void f5(int *x U) { }\n+static void f6(double *x U) { }\n+static void f7(const int *x U) { }\n+static void f8(const int *x U, int y U) { }\n+static void f9(int x U) { }\n+\n+void test(void)\n+{\n+  int o1 C(f1);\n+  int o2 C(f2);\n+  int o3 C(f3);\t\t/* { dg-error \"too many arguments\" } */\n+  int o4 C(f4);\n+  int o5 C(f5);\n+  int o6 C(f6);\t\t/* { dg-warning \"incompatible pointer type\" } */\n+  int o7 C(f7);\n+  int o8 C(f8);\t\t/* { dg-error \"too few arguments\" } */\n+  int o9 C(f9);\t\t/* { dg-warning \"from pointer without a cast\" } */\n+  int o10 U C(undef);\t/* { dg-error \"not a function\" } */\n+  int o11 U C(o1);\t/* { dg-error \"not a function\" } */\n+  int o12 U C(\"f1\");\t/* { dg-error \"not an identifier\" } */\n+  static int o13 U C(f1); /* { dg-warning \"attribute ignored\" } */\n+}\n+\n+int o14 C(f1);\t\t/* { dg-warning \"attribute ignored\" } */\n+void t15(int o U C(f1)) {} /* { dg-warning \"attribute ignored\" } */"}, {"sha": "2c798023ccbd96b06485fd5fb46a901c21224d6a", "filename": "gcc/testsuite/gcc.dg/cleanup-2.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-2.c?ref=0bfa5f65bfb186f10d43304946fd7fcd69988732", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* Verify that cleanup works in the most basic of ways.  */\n+\n+extern void exit(int);\n+extern void abort(void);\n+\n+static void handler(void *p __attribute__((unused)))\n+{\n+  exit (0);\n+}\n+\n+static void doit(void)\n+{\n+  int x __attribute__((cleanup (handler)));\n+}\n+\n+int main()\n+{\n+  doit ();\n+  abort ();\n+}"}, {"sha": "b5b01fd59051bc4951ed4b719b023aa1aef554bc", "filename": "gcc/testsuite/gcc.dg/cleanup-3.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-3.c?ref=0bfa5f65bfb186f10d43304946fd7fcd69988732", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* Verify that the cleanup handler receives the proper contents\n+   of the variable.  */\n+\n+extern void exit(int);\n+extern void abort(void);\n+\n+static int expected;\n+\n+static void\n+handler(int *p)\n+{\n+  if (*p != expected)\n+    abort ();\n+}\n+\n+static void __attribute__((noinline))\n+bar(void)\n+{\n+}\n+\n+static void doit(int x, int y)\n+{\n+  int r __attribute__((cleanup (handler)));\n+  if (x < y)\n+    {\n+      r = 0;\n+      return;\n+    }\n+\n+  bar();\n+  r = x + y;\n+}\n+\n+int main()\n+{\n+  expected = 0;\n+  doit (1, 2);\n+\n+  expected = 3;\n+  doit (2, 1);\n+\n+  return 0;\n+}"}, {"sha": "a5487553d2ba399fad5055cfab58661d2dda36d8", "filename": "gcc/testsuite/gcc.dg/cleanup-4.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-4.c?ref=0bfa5f65bfb186f10d43304946fd7fcd69988732", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* Verify cleanup execution on non-trivial exit from a block.  */\n+\n+extern void exit(int);\n+extern void abort(void);\n+\n+static int counter;\n+\n+static void\n+handler(int *p)\n+{\n+  counter += *p;\n+}\n+\n+static void __attribute__((noinline))\n+bar(void)\n+{\n+}\n+\n+static void doit(int n, int n2)\n+{\n+  int i;\n+  for (i = 0; i < n; ++i)\n+    {\n+      int dummy __attribute__((cleanup (handler))) = i;\n+      if (i == n2)\n+\tbreak;\n+      bar();\n+    }\n+}\n+\n+int main()\n+{\n+  doit (10, 6);\n+  if (counter != 0 + 1 + 2 + 3 + 4 + 5 + 6)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "f5306db47526af3822f13f03b49097edc3a02c74", "filename": "gcc/testsuite/gcc.dg/cleanup-5.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-5.c?ref=0bfa5f65bfb186f10d43304946fd7fcd69988732", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fexceptions\" } */\n+/* Verify that cleanups work with exception handling.  */\n+\n+#include <unwind.h>\n+#include <stdlib.h>\n+\n+static _Unwind_Reason_Code\n+force_unwind_stop (int version, _Unwind_Action actions,\n+                   _Unwind_Exception_Class exc_class,\n+                   struct _Unwind_Exception *exc_obj,\n+                   struct _Unwind_Context *context,\n+                   void *stop_parameter)\n+{\n+  if (actions & _UA_END_OF_STACK)\n+    abort ();\n+  return _URC_NO_REASON;\n+}\n+\n+static void force_unwind ()\n+{\n+  struct _Unwind_Exception *exc = malloc (sizeof (*exc));\n+  exc->exception_class = 0;\n+  exc->exception_cleanup = 0;\n+                   \n+#ifndef __USING_SJLJ_EXCEPTIONS__\n+  _Unwind_ForcedUnwind (exc, force_unwind_stop, 0);\n+#else\n+  _Unwind_SjLj_ForcedUnwind (exc, force_unwind_stop, 0);\n+#endif\n+                   \n+  abort ();\n+}\n+\n+static void handler (void *p __attribute__((unused)))\n+{\n+  exit (0);\n+}\n+\n+static void doit ()\n+{\n+  char dummy __attribute__((cleanup (handler)));\n+  force_unwind ();\n+}\n+\n+int main()\n+{ \n+  doit ();\n+  abort ();\n+}"}, {"sha": "4e3d53893afc7d39f1335039f293f099e53c8023", "filename": "gcc/testsuite/gcc.dg/cleanup-6.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-6.c?ref=0bfa5f65bfb186f10d43304946fd7fcd69988732", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O\" } */\n+/* Verify that a cleanup marked \"inline\" gets inlined.  */\n+\n+static inline void xyzzy(void *p __attribute__((unused)))\n+{\n+}\n+\n+void doit(void)\n+{\n+  int x __attribute__((cleanup (xyzzy)));\n+}\n+\n+/* { dg-final { scan-assembler-not \"xyzzy\" } } */"}, {"sha": "eae3d52980c13dca6f4ab98da499c6b5e61c0a80", "filename": "gcc/testsuite/gcc.dg/cleanup-7.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-7.c?ref=0bfa5f65bfb186f10d43304946fd7fcd69988732", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* Verify that the search for function happens in the proper scope.  */\n+\n+extern void exit(int);\n+extern void abort(void);\n+\n+int main()\n+{\n+  auto void xyzzy(void *p __attribute__((unused)))\n+  {\n+    exit (0);\n+  }\n+\n+  auto void doit ()\n+  {\n+    int x __attribute__((cleanup (xyzzy)));\n+  }\n+\n+  doit ();\n+  abort ();\n+}"}, {"sha": "9ce09568988265b2c4dc6f62c5ee49a5a70b42ab", "filename": "gcc/unwind-c.c", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Funwind-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bfa5f65bfb186f10d43304946fd7fcd69988732/gcc%2Funwind-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-c.c?ref=0bfa5f65bfb186f10d43304946fd7fcd69988732", "patch": "@@ -0,0 +1,186 @@\n+/* Supporting functions for C exception handling.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n+   Contributed by Aldy Hernandez <aldy@quesejoda.com>.\n+   Shamelessly stolen from the Java front end.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+#include \"unwind.h\"\n+#include \"unwind-pe.h\"\n+\n+typedef struct\n+{\n+  _Unwind_Ptr Start;\n+  _Unwind_Ptr LPStart;\n+  _Unwind_Ptr ttype_base;\n+  const unsigned char *TType;\n+  const unsigned char *action_table;\n+  unsigned char ttype_encoding;\n+  unsigned char call_site_encoding;\n+} lsda_header_info;\n+\n+static const unsigned char *\n+parse_lsda_header (struct _Unwind_Context *context, const unsigned char *p,\n+\t\t   lsda_header_info *info)\n+{\n+  _Unwind_Word tmp;\n+  unsigned char lpstart_encoding;\n+\n+  info->Start = (context ? _Unwind_GetRegionStart (context) : 0);\n+\n+  /* Find @LPStart, the base to which landing pad offsets are relative.  */\n+  lpstart_encoding = *p++;\n+  if (lpstart_encoding != DW_EH_PE_omit)\n+    p = read_encoded_value (context, lpstart_encoding, p, &info->LPStart);\n+  else\n+    info->LPStart = info->Start;\n+\n+  /* Find @TType, the base of the handler and exception spec type data.  */\n+  info->ttype_encoding = *p++;\n+  if (info->ttype_encoding != DW_EH_PE_omit)\n+    {\n+      p = read_uleb128 (p, &tmp);\n+      info->TType = p + tmp;\n+    }\n+  else\n+    info->TType = 0;\n+\n+  /* The encoding and length of the call-site table; the action table\n+     immediately follows.  */\n+  info->call_site_encoding = *p++;\n+  p = read_uleb128 (p, &tmp);\n+  info->action_table = p + tmp;\n+\n+  return p;\n+}\n+\n+#ifdef __USING_SJLJ_EXCEPTIONS__\n+#define PERSONALITY_FUNCTION    __gcc_personality_sj0\n+#define __builtin_eh_return_data_regno(x) x\n+#else\n+#define PERSONALITY_FUNCTION    __gcc_personality_v0\n+#endif\n+#define PERSONALITY_FUNCTION    __gcc_personality_v0\n+\n+_Unwind_Reason_Code\n+PERSONALITY_FUNCTION (int, _Unwind_Action, _Unwind_Exception_Class,\n+\t\t      struct _Unwind_Exception *, struct _Unwind_Context *);\n+\n+_Unwind_Reason_Code\n+PERSONALITY_FUNCTION (int version,\n+\t\t      _Unwind_Action actions,\n+\t\t      _Unwind_Exception_Class exception_class ATTRIBUTE_UNUSED,\n+\t\t      struct _Unwind_Exception *ue_header,\n+\t\t      struct _Unwind_Context *context)\n+{\n+  lsda_header_info info;\n+  const unsigned char *language_specific_data, *p, *action_record;\n+  _Unwind_Ptr landing_pad, ip;\n+\n+  if (version != 1)\n+    return _URC_FATAL_PHASE1_ERROR;\n+\n+  /* Currently we only support cleanups for C.  */\n+  if ((actions & _UA_CLEANUP_PHASE) == 0)\n+    return _URC_CONTINUE_UNWIND;\n+\n+  language_specific_data = (const unsigned char *)\n+    _Unwind_GetLanguageSpecificData (context);\n+\n+  /* If no LSDA, then there are no handlers or cleanups.  */\n+  if (! language_specific_data)\n+    return _URC_CONTINUE_UNWIND;\n+\n+  /* Parse the LSDA header.  */\n+  p = parse_lsda_header (context, language_specific_data, &info);\n+  ip = _Unwind_GetIP (context) - 1;\n+  landing_pad = 0;\n+\n+#ifdef __USING_SJLJ_EXCEPTIONS__\n+  /* The given \"IP\" is an index into the call-site table, with two\n+     exceptions -- -1 means no-action, and 0 means terminate.  But\n+     since we're using uleb128 values, we've not got random access\n+     to the array.  */\n+  if ((int) ip <= 0)\n+    return _URC_CONTINUE_UNWIND;\n+  else\n+    {\n+      _Unwind_Word cs_lp, cs_action;\n+      do\n+\t{\n+\t  p = read_uleb128 (p, &cs_lp);\n+\t  p = read_uleb128 (p, &cs_action);\n+\t}\n+      while (--ip);\n+\n+      /* Can never have null landing pad for sjlj -- that would have\n+\t been indicated by a -1 call site index.  */\n+      landing_pad = cs_lp + 1;\n+      if (cs_action)\n+\taction_record = info.action_table + cs_action - 1;\n+      goto found_something;\n+    }\n+#else\n+  /* Search the call-site table for the action associated with this IP.  */\n+  while (p < info.action_table)\n+    {\n+      _Unwind_Ptr cs_start, cs_len, cs_lp;\n+      _Unwind_Word cs_action;\n+\n+      /* Note that all call-site encodings are \"absolute\" displacements.  */\n+      p = read_encoded_value (0, info.call_site_encoding, p, &cs_start);\n+      p = read_encoded_value (0, info.call_site_encoding, p, &cs_len);\n+      p = read_encoded_value (0, info.call_site_encoding, p, &cs_lp);\n+      p = read_uleb128 (p, &cs_action);\n+\n+      /* The table is sorted, so if we've passed the ip, stop.  */\n+      if (ip < info.Start + cs_start)\n+\tp = info.action_table;\n+      else if (ip < info.Start + cs_start + cs_len)\n+\t{\n+\t  if (cs_lp)\n+\t    landing_pad = info.LPStart + cs_lp;\n+\t  if (cs_action)\n+\t    action_record = info.action_table + cs_action - 1;\n+\t  goto found_something;\n+\t}\n+    }\n+  \n+#endif\n+\n+  /* IP is not in table.  No associated cleanups.  */\n+  /* ??? This is where C++ calls std::terminate to catch throw\n+     from a destructor.  */\n+  return _URC_CONTINUE_UNWIND;\n+\n+ found_something:\n+  if (landing_pad == 0)\n+    {\n+      /* IP is present, but has a null landing pad.\n+\t No handler to be run.  */\n+      return _URC_CONTINUE_UNWIND;\n+    }\n+\n+  _Unwind_SetGR (context, __builtin_eh_return_data_regno (0),\n+\t\t (_Unwind_Ptr) ue_header);\n+  _Unwind_SetGR (context, __builtin_eh_return_data_regno (1), 0);\n+  _Unwind_SetIP (context, landing_pad);\n+  return _URC_INSTALL_CONTEXT;\n+}"}]}