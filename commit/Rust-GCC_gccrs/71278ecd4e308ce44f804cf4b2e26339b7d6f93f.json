{"sha": "71278ecd4e308ce44f804cf4b2e26339b7d6f93f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzEyNzhlY2Q0ZTMwOGNlNDRmODA0Y2Y0YjJlMjYzMzliN2Q2ZjkzZg==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2019-08-22T19:33:38Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2019-08-22T19:33:38Z"}, "message": "rs6000: Move various non-vector things out of altivec.md\n\n\n\t* config/rs6000/altivec.md (unspec): Delete UNSPEC_DARN, UNSPEC_DARN_32,\n\tUNSPEC_DARN_RAW, UNSPEC_CMPRB, UNSPEC_CMPRB2, UNSPEC_CMPEQB; move to...\n\t* config/rs6000/rs6000.md (unspec): ... here.\n\t* config/rs6000/altivec.md (darn_32, darn_raw, darn, cmprb,\n\t*cmprb_internal, setb_signed, setb_unsigned, cmprb2, *cmprb2_internal,\n\tcmpeqb, *cmpeqb_internal): Delete, move to...\n\t* config/rs6000/rs6000.md (darn_32, darn_raw, darn, cmprb,\n\t*cmprb_internal, setb_signed, setb_unsigned, cmprb2, *cmprb2_internal,\n\tcmpeqb, *cmpeqb_internal): ... here.\n\nFrom-SVN: r274834", "tree": {"sha": "b48472af010b188e5fbedb2aa1b73fd91f7caaa0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b48472af010b188e5fbedb2aa1b73fd91f7caaa0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71278ecd4e308ce44f804cf4b2e26339b7d6f93f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71278ecd4e308ce44f804cf4b2e26339b7d6f93f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71278ecd4e308ce44f804cf4b2e26339b7d6f93f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71278ecd4e308ce44f804cf4b2e26339b7d6f93f/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "db376f458e0702a731fc13a62fee5485dca223fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db376f458e0702a731fc13a62fee5485dca223fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db376f458e0702a731fc13a62fee5485dca223fe"}], "stats": {"total": 459, "additions": 236, "deletions": 223}, "files": [{"sha": "a9e5668343ff5af14248d987f0ad2370c96ec4d0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71278ecd4e308ce44f804cf4b2e26339b7d6f93f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71278ecd4e308ce44f804cf4b2e26339b7d6f93f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=71278ecd4e308ce44f804cf4b2e26339b7d6f93f", "patch": "@@ -1,3 +1,15 @@\n+2019-08-22  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* config/rs6000/altivec.md (unspec): Delete UNSPEC_DARN, UNSPEC_DARN_32,\n+\tUNSPEC_DARN_RAW, UNSPEC_CMPRB, UNSPEC_CMPRB2, UNSPEC_CMPEQB; move to...\n+\t* config/rs6000/rs6000.md (unspec): ... here.\n+\t* config/rs6000/altivec.md (darn_32, darn_raw, darn, cmprb,\n+\t*cmprb_internal, setb_signed, setb_unsigned, cmprb2, *cmprb2_internal,\n+\tcmpeqb, *cmpeqb_internal): Delete, move to...\n+\t* config/rs6000/rs6000.md (darn_32, darn_raw, darn, cmprb,\n+\t*cmprb_internal, setb_signed, setb_unsigned, cmprb2, *cmprb2_internal,\n+\tcmpeqb, *cmpeqb_internal): ... here.\n+\n 2019-08-22  Kyrylo Tkachov <kyrylo.tkachov@arm.com>\n \n \t* config/arm/arm_acle.h: Use arch=armv8-a+crc+simd pragma for CRC32"}, {"sha": "6fa4d80fc8859d6351e3ac6589300ef1ec79fbb3", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 0, "deletions": 223, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71278ecd4e308ce44f804cf4b2e26339b7d6f93f/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71278ecd4e308ce44f804cf4b2e26339b7d6f93f/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=71278ecd4e308ce44f804cf4b2e26339b7d6f93f", "patch": "@@ -80,9 +80,6 @@\n    UNSPEC_VUPKHPX\n    UNSPEC_VUPKLPX\n    UNSPEC_CONVERT_4F32_8I16\n-   UNSPEC_DARN\n-   UNSPEC_DARN_32\n-   UNSPEC_DARN_RAW\n    UNSPEC_DST\n    UNSPEC_DSTT\n    UNSPEC_DSTST\n@@ -161,9 +158,6 @@\n    UNSPEC_BCDADD\n    UNSPEC_BCDSUB\n    UNSPEC_BCD_OVERFLOW\n-   UNSPEC_CMPRB\n-   UNSPEC_CMPRB2\n-   UNSPEC_CMPEQB\n    UNSPEC_VRLMI\n    UNSPEC_VRLNM\n ])\n@@ -4107,223 +4101,6 @@\n   \"bcd<bcd_add_sub>. %0,%1,%2,%3\"\n   [(set_attr \"type\" \"vecsimple\")])\n \n-(define_insn \"darn_32\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-        (unspec:SI [(const_int 0)] UNSPEC_DARN_32))]\n-  \"TARGET_P9_MISC\"\n-  \"darn %0,0\"\n-  [(set_attr \"type\" \"integer\")])\n-\n-(define_insn \"darn_raw\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-        (unspec:DI [(const_int 0)] UNSPEC_DARN_RAW))]\n-  \"TARGET_P9_MISC && TARGET_64BIT\"\n-  \"darn %0,2\"\n-  [(set_attr \"type\" \"integer\")])\n-\n-(define_insn \"darn\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-        (unspec:DI [(const_int 0)] UNSPEC_DARN))]\n-  \"TARGET_P9_MISC && TARGET_64BIT\"\n-  \"darn %0,1\"\n-  [(set_attr \"type\" \"integer\")])\n-\n-;; Test byte within range.\n-;;\n-;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx\n-;; represents a byte whose value is ignored in this context and\n-;; vv, the least significant byte, holds the byte value that is to\n-;; be tested for membership within the range specified by operand 2.\n-;; The bytes of operand 2 are organized as xx:xx:hi:lo.\n-;;\n-;; Return in target register operand 0 a value of 1 if lo <= vv and\n-;; vv <= hi.  Otherwise, set register operand 0 to 0.\n-;;\n-;; Though the instructions to which this expansion maps operate on\n-;; 64-bit registers, the current implementation only operates on\n-;; SI-mode operands as the high-order bits provide no information\n-;; that is not already available in the low-order bits.  To avoid the\n-;; costs of data widening operations, future enhancements might allow\n-;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.\n-(define_expand \"cmprb\"\n-  [(set (match_dup 3)\n-\t(unspec:CC [(match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"r\")]\n-\t UNSPEC_CMPRB))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(if_then_else:SI (lt (match_dup 3)\n-\t\t\t     (const_int 0))\n-\t\t\t (const_int -1)\n-\t\t\t (if_then_else (gt (match_dup 3)\n-\t\t\t\t\t   (const_int 0))\n-\t\t\t\t       (const_int 1)\n-\t\t\t\t       (const_int 0))))]\n-  \"TARGET_P9_MISC\"\n-{\n-  operands[3] = gen_reg_rtx (CCmode);\n-})\n-\n-;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx\n-;; represents a byte whose value is ignored in this context and\n-;; vv, the least significant byte, holds the byte value that is to\n-;; be tested for membership within the range specified by operand 2.\n-;; The bytes of operand 2 are organized as xx:xx:hi:lo.\n-;;\n-;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if\n-;; lo <= vv and vv <= hi.  Otherwise, set the GT bit to 0.  The other\n-;; 3 bits of the target CR register are all set to 0.\n-(define_insn \"*cmprb_internal\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=y\")\n-\t(unspec:CC [(match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"r\")]\n-\t UNSPEC_CMPRB))]\n-  \"TARGET_P9_MISC\"\n-  \"cmprb %0,0,%1,%2\"\n-  [(set_attr \"type\" \"logical\")])\n-\n-;; Set operand 0 register to -1 if the LT bit (0x8) of condition\n-;; register operand 1 is on.  Otherwise, set operand 0 register to 1\n-;; if the GT bit (0x4) of condition register operand 1 is on.\n-;; Otherwise, set operand 0 to 0.  Note that the result stored into\n-;; register operand 0 is non-zero iff either the LT or GT bits are on\n-;; within condition register operand 1.\n-(define_insn \"setb_signed\"\n-   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t (if_then_else:SI (lt (match_operand:CC 1 \"cc_reg_operand\" \"y\")\n-\t\t\t      (const_int 0))\n-\t\t\t  (const_int -1)\n-\t\t\t  (if_then_else (gt (match_dup 1)\n-\t\t\t\t\t    (const_int 0))\n-\t\t\t\t\t(const_int 1)\n-\t\t\t\t\t(const_int 0))))]\n-  \"TARGET_P9_MISC\"\n-  \"setb %0,%1\"\n-  [(set_attr \"type\" \"logical\")])\n-\n-(define_insn \"setb_unsigned\"\n-   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t (if_then_else:SI (ltu (match_operand:CCUNS 1 \"cc_reg_operand\" \"y\")\n-\t\t\t      (const_int 0))\n-\t\t\t  (const_int -1)\n-\t\t\t  (if_then_else (gtu (match_dup 1)\n-\t\t\t\t\t    (const_int 0))\n-\t\t\t\t\t(const_int 1)\n-\t\t\t\t\t(const_int 0))))]\n-  \"TARGET_P9_MISC\"\n-  \"setb %0,%1\"\n-  [(set_attr \"type\" \"logical\")])\n-\n-;; Test byte within two ranges.\n-;;\n-;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx\n-;; represents a byte whose value is ignored in this context and\n-;; vv, the least significant byte, holds the byte value that is to\n-;; be tested for membership within the range specified by operand 2.\n-;; The bytes of operand 2 are organized as hi_1:lo_1:hi_2:lo_2.\n-;;\n-;; Return in target register operand 0 a value of 1 if (lo_1 <= vv and\n-;; vv <= hi_1) or if (lo_2 <= vv and vv <= hi_2).  Otherwise, set register\n-;; operand 0 to 0.\n-;;\n-;; Though the instructions to which this expansion maps operate on\n-;; 64-bit registers, the current implementation only operates on\n-;; SI-mode operands as the high-order bits provide no information\n-;; that is not already available in the low-order bits.  To avoid the\n-;; costs of data widening operations, future enhancements might allow\n-;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.\n-(define_expand \"cmprb2\"\n-  [(set (match_dup 3)\n-\t(unspec:CC [(match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"r\")]\n-\t UNSPEC_CMPRB2))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(if_then_else:SI (lt (match_dup 3)\n-\t\t\t     (const_int 0))\n-\t\t\t (const_int -1)\n-\t\t\t (if_then_else (gt (match_dup 3)\n-\t\t\t\t\t   (const_int 0))\n-\t\t\t\t       (const_int 1)\n-\t\t\t\t       (const_int 0))))]\n-  \"TARGET_P9_MISC\"\n-{\n-  operands[3] = gen_reg_rtx (CCmode);\n-})\n-\n-;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx\n-;; represents a byte whose value is ignored in this context and\n-;; vv, the least significant byte, holds the byte value that is to\n-;; be tested for membership within the ranges specified by operand 2.\n-;; The bytes of operand 2 are organized as hi_1:lo_1:hi_2:lo_2.\n-;;\n-;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if\n-;; (lo_1 <= vv and vv <= hi_1) or if (lo_2 <= vv and vv <= hi_2).\n-;; Otherwise, set the GT bit to 0.  The other 3 bits of the target\n-;; CR register are all set to 0.\n-(define_insn \"*cmprb2_internal\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=y\")\n-\t(unspec:CC [(match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"r\")]\n-\t UNSPEC_CMPRB2))]\n-  \"TARGET_P9_MISC\"\n-  \"cmprb %0,1,%1,%2\"\n-  [(set_attr \"type\" \"logical\")])\n-\n-;; Test byte membership within set of 8 bytes.\n-;;\n-;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx\n-;; represents a byte whose value is ignored in this context and\n-;; vv, the least significant byte, holds the byte value that is to\n-;; be tested for membership within the set specified by operand 2.\n-;; The bytes of operand 2 are organized as e0:e1:e2:e3:e4:e5:e6:e7.\n-;;\n-;; Return in target register operand 0 a value of 1 if vv equals one\n-;; of the values e0, e1, e2, e3, e4, e5, e6, or e7.  Otherwise, set\n-;; register operand 0 to 0.  Note that the 8 byte values held within\n-;; operand 2 need not be unique.\n-;;\n-;; Though the instructions to which this expansion maps operate on\n-;; 64-bit registers, the current implementation requires that operands\n-;; 0 and 1 have mode SI as the high-order bits provide no information\n-;; that is not already available in the low-order bits.  To avoid the\n-;; costs of data widening operations, future enhancements might allow\n-;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.\n-(define_expand \"cmpeqb\"\n-  [(set (match_dup 3)\n-\t(unspec:CC [(match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r\")]\n-\t UNSPEC_CMPEQB))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(if_then_else:SI (lt (match_dup 3)\n-\t\t\t     (const_int 0))\n-\t\t\t (const_int -1)\n-\t\t\t (if_then_else (gt (match_dup 3)\n-\t\t\t\t\t   (const_int 0))\n-\t\t\t\t       (const_int 1)\n-\t\t\t\t       (const_int 0))))]\n-  \"TARGET_P9_MISC && TARGET_64BIT\"\n-{\n-  operands[3] = gen_reg_rtx (CCmode);\n-})\n-\n-;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx\n-;; represents a byte whose value is ignored in this context and\n-;; vv, the least significant byte, holds the byte value that is to\n-;; be tested for membership within the set specified by operand 2.\n-;; The bytes of operand 2 are organized as e0:e1:e2:e3:e4:e5:e6:e7.\n-;;\n-;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if vv\n-;; equals one of the values e0, e1, e2, e3, e4, e5, e6, or e7.  Otherwise,\n-;; set the GT bit to zero.  The other 3 bits of the target CR register\n-;; are all set to 0.\n-(define_insn \"*cmpeqb_internal\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=y\")\n-\t (unspec:CC [(match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-\t\t     (match_operand:DI 2 \"gpc_reg_operand\" \"r\")]\n-\t  UNSPEC_CMPEQB))]\n-  \"TARGET_P9_MISC && TARGET_64BIT\"\n-  \"cmpeqb %0,%1,%2\"\n-  [(set_attr \"type\" \"logical\")])\n-\n (define_expand \"bcd<bcd_add_sub>_<code>\"\n   [(parallel [(set (reg:CCFP CR6_REGNO)\n \t\t   (compare:CCFP"}, {"sha": "68cdf6817c291541fd77d783076e010825192e4c", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71278ecd4e308ce44f804cf4b2e26339b7d6f93f/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71278ecd4e308ce44f804cf4b2e26339b7d6f93f/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=71278ecd4e308ce44f804cf4b2e26339b7d6f93f", "patch": "@@ -134,6 +134,12 @@\n    UNSPEC_LSQ\n    UNSPEC_FUSION_GPR\n    UNSPEC_STACK_CHECK\n+   UNSPEC_DARN\n+   UNSPEC_DARN_32\n+   UNSPEC_DARN_RAW\n+   UNSPEC_CMPRB\n+   UNSPEC_CMPRB2\n+   UNSPEC_CMPEQB\n    UNSPEC_ADD_ROUND_TO_ODD\n    UNSPEC_SUB_ROUND_TO_ODD\n    UNSPEC_MUL_ROUND_TO_ODD\n@@ -14376,7 +14382,225 @@\n    \"xscmpuqp %0,%1,%2\"\n   [(set_attr \"type\" \"veccmp\")\n    (set_attr \"size\" \"128\")])\n+\f\n+;; Miscellaneous ISA 3.0 (power9) instructions\n+\n+(define_insn \"darn_32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (unspec:SI [(const_int 0)] UNSPEC_DARN_32))]\n+  \"TARGET_P9_MISC\"\n+  \"darn %0,0\"\n+  [(set_attr \"type\" \"integer\")])\n+\n+(define_insn \"darn_raw\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+        (unspec:DI [(const_int 0)] UNSPEC_DARN_RAW))]\n+  \"TARGET_P9_MISC && TARGET_64BIT\"\n+  \"darn %0,2\"\n+  [(set_attr \"type\" \"integer\")])\n+\n+(define_insn \"darn\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+        (unspec:DI [(const_int 0)] UNSPEC_DARN))]\n+  \"TARGET_P9_MISC && TARGET_64BIT\"\n+  \"darn %0,1\"\n+  [(set_attr \"type\" \"integer\")])\n+\n+;; Test byte within range.\n+;;\n+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx\n+;; represents a byte whose value is ignored in this context and\n+;; vv, the least significant byte, holds the byte value that is to\n+;; be tested for membership within the range specified by operand 2.\n+;; The bytes of operand 2 are organized as xx:xx:hi:lo.\n+;;\n+;; Return in target register operand 0 a value of 1 if lo <= vv and\n+;; vv <= hi.  Otherwise, set register operand 0 to 0.\n+;;\n+;; Though the instructions to which this expansion maps operate on\n+;; 64-bit registers, the current implementation only operates on\n+;; SI-mode operands as the high-order bits provide no information\n+;; that is not already available in the low-order bits.  To avoid the\n+;; costs of data widening operations, future enhancements might allow\n+;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.\n+(define_expand \"cmprb\"\n+  [(set (match_dup 3)\n+\t(unspec:CC [(match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n+\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"r\")]\n+\t UNSPEC_CMPRB))\n+   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n+\t(if_then_else:SI (lt (match_dup 3)\n+\t\t\t     (const_int 0))\n+\t\t\t (const_int -1)\n+\t\t\t (if_then_else (gt (match_dup 3)\n+\t\t\t\t\t   (const_int 0))\n+\t\t\t\t       (const_int 1)\n+\t\t\t\t       (const_int 0))))]\n+  \"TARGET_P9_MISC\"\n+{\n+  operands[3] = gen_reg_rtx (CCmode);\n+})\n+\n+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx\n+;; represents a byte whose value is ignored in this context and\n+;; vv, the least significant byte, holds the byte value that is to\n+;; be tested for membership within the range specified by operand 2.\n+;; The bytes of operand 2 are organized as xx:xx:hi:lo.\n+;;\n+;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if\n+;; lo <= vv and vv <= hi.  Otherwise, set the GT bit to 0.  The other\n+;; 3 bits of the target CR register are all set to 0.\n+(define_insn \"*cmprb_internal\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=y\")\n+\t(unspec:CC [(match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n+\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"r\")]\n+\t UNSPEC_CMPRB))]\n+  \"TARGET_P9_MISC\"\n+  \"cmprb %0,0,%1,%2\"\n+  [(set_attr \"type\" \"logical\")])\n+\n+;; Set operand 0 register to -1 if the LT bit (0x8) of condition\n+;; register operand 1 is on.  Otherwise, set operand 0 register to 1\n+;; if the GT bit (0x4) of condition register operand 1 is on.\n+;; Otherwise, set operand 0 to 0.  Note that the result stored into\n+;; register operand 0 is non-zero iff either the LT or GT bits are on\n+;; within condition register operand 1.\n+(define_insn \"setb_signed\"\n+   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n+\t (if_then_else:SI (lt (match_operand:CC 1 \"cc_reg_operand\" \"y\")\n+\t\t\t      (const_int 0))\n+\t\t\t  (const_int -1)\n+\t\t\t  (if_then_else (gt (match_dup 1)\n+\t\t\t\t\t    (const_int 0))\n+\t\t\t\t\t(const_int 1)\n+\t\t\t\t\t(const_int 0))))]\n+  \"TARGET_P9_MISC\"\n+  \"setb %0,%1\"\n+  [(set_attr \"type\" \"logical\")])\n \n+(define_insn \"setb_unsigned\"\n+   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n+\t (if_then_else:SI (ltu (match_operand:CCUNS 1 \"cc_reg_operand\" \"y\")\n+\t\t\t      (const_int 0))\n+\t\t\t  (const_int -1)\n+\t\t\t  (if_then_else (gtu (match_dup 1)\n+\t\t\t\t\t    (const_int 0))\n+\t\t\t\t\t(const_int 1)\n+\t\t\t\t\t(const_int 0))))]\n+  \"TARGET_P9_MISC\"\n+  \"setb %0,%1\"\n+  [(set_attr \"type\" \"logical\")])\n+\n+;; Test byte within two ranges.\n+;;\n+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx\n+;; represents a byte whose value is ignored in this context and\n+;; vv, the least significant byte, holds the byte value that is to\n+;; be tested for membership within the range specified by operand 2.\n+;; The bytes of operand 2 are organized as hi_1:lo_1:hi_2:lo_2.\n+;;\n+;; Return in target register operand 0 a value of 1 if (lo_1 <= vv and\n+;; vv <= hi_1) or if (lo_2 <= vv and vv <= hi_2).  Otherwise, set register\n+;; operand 0 to 0.\n+;;\n+;; Though the instructions to which this expansion maps operate on\n+;; 64-bit registers, the current implementation only operates on\n+;; SI-mode operands as the high-order bits provide no information\n+;; that is not already available in the low-order bits.  To avoid the\n+;; costs of data widening operations, future enhancements might allow\n+;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.\n+(define_expand \"cmprb2\"\n+  [(set (match_dup 3)\n+\t(unspec:CC [(match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n+\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"r\")]\n+\t UNSPEC_CMPRB2))\n+   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n+\t(if_then_else:SI (lt (match_dup 3)\n+\t\t\t     (const_int 0))\n+\t\t\t (const_int -1)\n+\t\t\t (if_then_else (gt (match_dup 3)\n+\t\t\t\t\t   (const_int 0))\n+\t\t\t\t       (const_int 1)\n+\t\t\t\t       (const_int 0))))]\n+  \"TARGET_P9_MISC\"\n+{\n+  operands[3] = gen_reg_rtx (CCmode);\n+})\n+\n+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx\n+;; represents a byte whose value is ignored in this context and\n+;; vv, the least significant byte, holds the byte value that is to\n+;; be tested for membership within the ranges specified by operand 2.\n+;; The bytes of operand 2 are organized as hi_1:lo_1:hi_2:lo_2.\n+;;\n+;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if\n+;; (lo_1 <= vv and vv <= hi_1) or if (lo_2 <= vv and vv <= hi_2).\n+;; Otherwise, set the GT bit to 0.  The other 3 bits of the target\n+;; CR register are all set to 0.\n+(define_insn \"*cmprb2_internal\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=y\")\n+\t(unspec:CC [(match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n+\t\t    (match_operand:SI 2 \"gpc_reg_operand\" \"r\")]\n+\t UNSPEC_CMPRB2))]\n+  \"TARGET_P9_MISC\"\n+  \"cmprb %0,1,%1,%2\"\n+  [(set_attr \"type\" \"logical\")])\n+\n+;; Test byte membership within set of 8 bytes.\n+;;\n+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx\n+;; represents a byte whose value is ignored in this context and\n+;; vv, the least significant byte, holds the byte value that is to\n+;; be tested for membership within the set specified by operand 2.\n+;; The bytes of operand 2 are organized as e0:e1:e2:e3:e4:e5:e6:e7.\n+;;\n+;; Return in target register operand 0 a value of 1 if vv equals one\n+;; of the values e0, e1, e2, e3, e4, e5, e6, or e7.  Otherwise, set\n+;; register operand 0 to 0.  Note that the 8 byte values held within\n+;; operand 2 need not be unique.\n+;;\n+;; Though the instructions to which this expansion maps operate on\n+;; 64-bit registers, the current implementation requires that operands\n+;; 0 and 1 have mode SI as the high-order bits provide no information\n+;; that is not already available in the low-order bits.  To avoid the\n+;; costs of data widening operations, future enhancements might allow\n+;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.\n+(define_expand \"cmpeqb\"\n+  [(set (match_dup 3)\n+\t(unspec:CC [(match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n+\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r\")]\n+\t UNSPEC_CMPEQB))\n+   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n+\t(if_then_else:SI (lt (match_dup 3)\n+\t\t\t     (const_int 0))\n+\t\t\t (const_int -1)\n+\t\t\t (if_then_else (gt (match_dup 3)\n+\t\t\t\t\t   (const_int 0))\n+\t\t\t\t       (const_int 1)\n+\t\t\t\t       (const_int 0))))]\n+  \"TARGET_P9_MISC && TARGET_64BIT\"\n+{\n+  operands[3] = gen_reg_rtx (CCmode);\n+})\n+\n+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx\n+;; represents a byte whose value is ignored in this context and\n+;; vv, the least significant byte, holds the byte value that is to\n+;; be tested for membership within the set specified by operand 2.\n+;; The bytes of operand 2 are organized as e0:e1:e2:e3:e4:e5:e6:e7.\n+;;\n+;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if vv\n+;; equals one of the values e0, e1, e2, e3, e4, e5, e6, or e7.  Otherwise,\n+;; set the GT bit to zero.  The other 3 bits of the target CR register\n+;; are all set to 0.\n+(define_insn \"*cmpeqb_internal\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=y\")\n+\t (unspec:CC [(match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n+\t\t     (match_operand:DI 2 \"gpc_reg_operand\" \"r\")]\n+\t  UNSPEC_CMPEQB))]\n+  \"TARGET_P9_MISC && TARGET_64BIT\"\n+  \"cmpeqb %0,%1,%2\"\n+  [(set_attr \"type\" \"logical\")])\n \f\n \n (include \"sync.md\")"}]}