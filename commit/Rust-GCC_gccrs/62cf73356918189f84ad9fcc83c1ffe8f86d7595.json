{"sha": "62cf73356918189f84ad9fcc83c1ffe8f86d7595", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJjZjczMzU2OTE4MTg5Zjg0YWQ5ZmNjODNjMWZmZThmODZkNzU5NQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-06-28T13:02:01Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-06-28T13:02:01Z"}, "message": "tree-vect-loop.c (vectorizable_reduction): Move special cond reduction IV var creation ...\n\n2017-06-28  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-loop.c (vectorizable_reduction): Move special\n\tcond reduction IV var creation ...\n\t(vect_create_epilog_for_reduction): ... here.  Remove induction_index\n\tparameter.  Use STMT_VINFO_VECTYPE.\n\t* tree-vect-slp.c (vect_get_constant_vectors): Properly reset\n\tconstant_p.\n\nFrom-SVN: r249736", "tree": {"sha": "df8c84fa418f106eeef7cb0c7803df63dbede91a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df8c84fa418f106eeef7cb0c7803df63dbede91a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62cf73356918189f84ad9fcc83c1ffe8f86d7595", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62cf73356918189f84ad9fcc83c1ffe8f86d7595", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62cf73356918189f84ad9fcc83c1ffe8f86d7595", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62cf73356918189f84ad9fcc83c1ffe8f86d7595/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "17a7218b811ffe1f8524ae04bc018f526186549f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17a7218b811ffe1f8524ae04bc018f526186549f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17a7218b811ffe1f8524ae04bc018f526186549f"}], "stats": {"total": 210, "additions": 108, "deletions": 102}, "files": [{"sha": "dc94164a21cc501f19fcd6fb5ed9a742c3ef4d6d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62cf73356918189f84ad9fcc83c1ffe8f86d7595/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62cf73356918189f84ad9fcc83c1ffe8f86d7595/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=62cf73356918189f84ad9fcc83c1ffe8f86d7595", "patch": "@@ -1,3 +1,12 @@\n+2017-06-28  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vect-loop.c (vectorizable_reduction): Move special\n+\tcond reduction IV var creation ...\n+\t(vect_create_epilog_for_reduction): ... here.  Remove induction_index\n+\tparameter.  Use STMT_VINFO_VECTYPE.\n+\t* tree-vect-slp.c (vect_get_constant_vectors): Properly reset\n+\tconstant_p.\n+\n 2017-06-28  Martin Liska  <mliska@suse.cz>\n \n \tPR ipa/81128"}, {"sha": "a0558360a96dc7c3554c4554c9a1e33c6037285d", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 96, "deletions": 95, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62cf73356918189f84ad9fcc83c1ffe8f86d7595/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62cf73356918189f84ad9fcc83c1ffe8f86d7595/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=62cf73356918189f84ad9fcc83c1ffe8f86d7595", "patch": "@@ -4263,8 +4263,6 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n    DOUBLE_REDUC is TRUE if double reduction phi nodes should be handled.\n    SLP_NODE is an SLP node containing a group of reduction statements. The \n      first one in this group is STMT.\n-   INDUCTION_INDEX is the index of the loop for condition reductions.\n-     Otherwise it is undefined.\n \n    This function:\n    1. Creates the reduction def-use cycles: sets the arguments for \n@@ -4310,7 +4308,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n \t\t\t\t  int ncopies, enum tree_code reduc_code,\n \t\t\t\t  vec<gimple *> reduction_phis,\n                                   int reduc_index, bool double_reduc, \n-\t\t\t\t  slp_tree slp_node, tree induction_index)\n+\t\t\t\t  slp_tree slp_node)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   stmt_vec_info prev_phi_info;\n@@ -4331,7 +4329,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n   tree bitsize;\n   tree adjustment_def = NULL;\n   tree vec_initial_def = NULL;\n-  tree reduction_op, expr, def, initial_def = NULL;\n+  tree expr, def, initial_def = NULL;\n   tree orig_name, scalar_result;\n   imm_use_iterator imm_iter, phi_imm_iter;\n   use_operand_p use_p, phi_use_p;\n@@ -4348,6 +4346,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n   bool slp_reduc = false;\n   tree new_phi_result;\n   gimple *inner_phi = NULL;\n+  tree induction_index = NULL_TREE;\n \n   if (slp_node)\n     group_size = SLP_TREE_SCALAR_STMTS (slp_node).length (); \n@@ -4360,9 +4359,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n       gcc_assert (!slp_node);\n     }\n \n-  reduction_op = get_reduction_op (stmt, reduc_index);\n-\n-  vectype = get_vectype_for_scalar_type (TREE_TYPE (reduction_op));\n+  vectype = STMT_VINFO_VECTYPE (stmt_info);\n   gcc_assert (vectype);\n   mode = TYPE_MODE (vectype);\n \n@@ -4396,6 +4393,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n     {\n       /* Get at the scalar def before the loop, that defines the initial value\n \t of the reduction variable.  */\n+      tree reduction_op = get_reduction_op (stmt, reduc_index);\n       gimple *def_stmt = SSA_NAME_DEF_STMT (reduction_op);\n       initial_def = PHI_ARG_DEF_FROM_EDGE (def_stmt,\n \t\t\t\t\t   loop_preheader_edge (loop));\n@@ -4465,6 +4463,95 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n         }\n     }\n \n+  /* For cond reductions we want to create a new vector (INDEX_COND_EXPR)\n+     which is updated with the current index of the loop for every match of\n+     the original loop's cond_expr (VEC_STMT).  This results in a vector\n+     containing the last time the condition passed for that vector lane.\n+     The first match will be a 1 to allow 0 to be used for non-matching\n+     indexes.  If there are no matches at all then the vector will be all\n+     zeroes.  */\n+  if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == COND_REDUCTION)\n+    {\n+      tree indx_before_incr, indx_after_incr;\n+      int nunits_out = TYPE_VECTOR_SUBPARTS (vectype);\n+      int k;\n+\n+      gimple *vec_stmt = STMT_VINFO_VEC_STMT (stmt_info);\n+      gcc_assert (gimple_assign_rhs_code (vec_stmt) == VEC_COND_EXPR);\n+\n+      int scalar_precision\n+\t= GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (vectype)));\n+      tree cr_index_scalar_type = make_unsigned_type (scalar_precision);\n+      tree cr_index_vector_type = build_vector_type\n+\t(cr_index_scalar_type, TYPE_VECTOR_SUBPARTS (vectype));\n+\n+      /* First we create a simple vector induction variable which starts\n+\t with the values {1,2,3,...} (SERIES_VECT) and increments by the\n+\t vector size (STEP).  */\n+\n+      /* Create a {1,2,3,...} vector.  */\n+      tree *vtemp = XALLOCAVEC (tree, nunits_out);\n+      for (k = 0; k < nunits_out; ++k)\n+\tvtemp[k] = build_int_cst (cr_index_scalar_type, k + 1);\n+      tree series_vect = build_vector (cr_index_vector_type, vtemp);\n+\n+      /* Create a vector of the step value.  */\n+      tree step = build_int_cst (cr_index_scalar_type, nunits_out);\n+      tree vec_step = build_vector_from_val (cr_index_vector_type, step);\n+\n+      /* Create an induction variable.  */\n+      gimple_stmt_iterator incr_gsi;\n+      bool insert_after;\n+      standard_iv_increment_position (loop, &incr_gsi, &insert_after);\n+      create_iv (series_vect, vec_step, NULL_TREE, loop, &incr_gsi,\n+\t\t insert_after, &indx_before_incr, &indx_after_incr);\n+\n+      /* Next create a new phi node vector (NEW_PHI_TREE) which starts\n+\t filled with zeros (VEC_ZERO).  */\n+\n+      /* Create a vector of 0s.  */\n+      tree zero = build_zero_cst (cr_index_scalar_type);\n+      tree vec_zero = build_vector_from_val (cr_index_vector_type, zero);\n+\n+      /* Create a vector phi node.  */\n+      tree new_phi_tree = make_ssa_name (cr_index_vector_type);\n+      new_phi = create_phi_node (new_phi_tree, loop->header);\n+      set_vinfo_for_stmt (new_phi,\n+\t\t\t  new_stmt_vec_info (new_phi, loop_vinfo));\n+      add_phi_arg (as_a <gphi *> (new_phi), vec_zero,\n+\t\t   loop_preheader_edge (loop), UNKNOWN_LOCATION);\n+\n+      /* Now take the condition from the loops original cond_expr\n+\t (VEC_STMT) and produce a new cond_expr (INDEX_COND_EXPR) which for\n+\t every match uses values from the induction variable\n+\t (INDEX_BEFORE_INCR) otherwise uses values from the phi node\n+\t (NEW_PHI_TREE).\n+\t Finally, we update the phi (NEW_PHI_TREE) to take the value of\n+\t the new cond_expr (INDEX_COND_EXPR).  */\n+\n+      /* Duplicate the condition from vec_stmt.  */\n+      tree ccompare = unshare_expr (gimple_assign_rhs1 (vec_stmt));\n+\n+      /* Create a conditional, where the condition is taken from vec_stmt\n+\t (CCOMPARE), then is the induction index (INDEX_BEFORE_INCR) and\n+\t else is the phi (NEW_PHI_TREE).  */\n+      tree index_cond_expr = build3 (VEC_COND_EXPR, cr_index_vector_type,\n+\t\t\t\t     ccompare, indx_before_incr,\n+\t\t\t\t     new_phi_tree);\n+      induction_index = make_ssa_name (cr_index_vector_type);\n+      gimple *index_condition = gimple_build_assign (induction_index,\n+\t\t\t\t\t\t     index_cond_expr);\n+      gsi_insert_before (&incr_gsi, index_condition, GSI_SAME_STMT);\n+      stmt_vec_info index_vec_info = new_stmt_vec_info (index_condition,\n+\t\t\t\t\t\t\tloop_vinfo);\n+      STMT_VINFO_VECTYPE (index_vec_info) = cr_index_vector_type;\n+      set_vinfo_for_stmt (index_condition, index_vec_info);\n+\n+      /* Update the phi with the vec cond.  */\n+      add_phi_arg (as_a <gphi *> (new_phi), induction_index,\n+\t\t   loop_latch_edge (loop), UNKNOWN_LOCATION);\n+    }\n+\n   /* 2. Create epilog code.\n         The reduction epilog code operates across the elements of the vector\n         of partial results computed by the vectorized loop.\n@@ -6248,100 +6335,14 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n       prev_phi_info = vinfo_for_stmt (new_phi);\n     }\n \n-  tree indx_before_incr, indx_after_incr, cond_name = NULL;\n-\n   /* Finalize the reduction-phi (set its arguments) and create the\n      epilog reduction code.  */\n   if ((!single_defuse_cycle || code == COND_EXPR) && !slp_node)\n-    {\n-      new_temp = gimple_assign_lhs (*vec_stmt);\n-      vect_defs[0] = new_temp;\n-\n-      /* For cond reductions we want to create a new vector (INDEX_COND_EXPR)\n-\t which is updated with the current index of the loop for every match of\n-\t the original loop's cond_expr (VEC_STMT).  This results in a vector\n-\t containing the last time the condition passed for that vector lane.\n-\t The first match will be a 1 to allow 0 to be used for non-matching\n-\t indexes.  If there are no matches at all then the vector will be all\n-\t zeroes.  */\n-      if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == COND_REDUCTION)\n-\t{\n-\t  int nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n-\t  int k;\n-\n-\t  gcc_assert (gimple_assign_rhs_code (*vec_stmt) == VEC_COND_EXPR);\n-\n-\t  /* First we create a simple vector induction variable which starts\n-\t     with the values {1,2,3,...} (SERIES_VECT) and increments by the\n-\t     vector size (STEP).  */\n-\n-\t  /* Create a {1,2,3,...} vector.  */\n-\t  tree *vtemp = XALLOCAVEC (tree, nunits_out);\n-\t  for (k = 0; k < nunits_out; ++k)\n-\t    vtemp[k] = build_int_cst (cr_index_scalar_type, k + 1);\n-\t  tree series_vect = build_vector (cr_index_vector_type, vtemp);\n-\n-\t  /* Create a vector of the step value.  */\n-\t  tree step = build_int_cst (cr_index_scalar_type, nunits_out);\n-\t  tree vec_step = build_vector_from_val (cr_index_vector_type, step);\n-\n-\t  /* Create an induction variable.  */\n-\t  gimple_stmt_iterator incr_gsi;\n-\t  bool insert_after;\n-\t  standard_iv_increment_position (loop, &incr_gsi, &insert_after);\n-\t  create_iv (series_vect, vec_step, NULL_TREE, loop, &incr_gsi,\n-\t\t     insert_after, &indx_before_incr, &indx_after_incr);\n-\n-\t  /* Next create a new phi node vector (NEW_PHI_TREE) which starts\n-\t     filled with zeros (VEC_ZERO).  */\n-\n-\t  /* Create a vector of 0s.  */\n-\t  tree zero = build_zero_cst (cr_index_scalar_type);\n-\t  tree vec_zero = build_vector_from_val (cr_index_vector_type, zero);\n-\n-\t  /* Create a vector phi node.  */\n-\t  tree new_phi_tree = make_ssa_name (cr_index_vector_type);\n-\t  new_phi = create_phi_node (new_phi_tree, loop->header);\n-\t  set_vinfo_for_stmt (new_phi,\n-\t\t\t      new_stmt_vec_info (new_phi, loop_vinfo));\n-\t  add_phi_arg (new_phi, vec_zero, loop_preheader_edge (loop),\n-\t\t       UNKNOWN_LOCATION);\n-\n-\t  /* Now take the condition from the loops original cond_expr\n-\t     (VEC_STMT) and produce a new cond_expr (INDEX_COND_EXPR) which for\n-\t     every match uses values from the induction variable\n-\t     (INDEX_BEFORE_INCR) otherwise uses values from the phi node\n-\t     (NEW_PHI_TREE).\n-\t     Finally, we update the phi (NEW_PHI_TREE) to take the value of\n-\t     the new cond_expr (INDEX_COND_EXPR).  */\n-\n-\t  /* Duplicate the condition from vec_stmt.  */\n-\t  tree ccompare = unshare_expr (gimple_assign_rhs1 (*vec_stmt));\n-\n-\t  /* Create a conditional, where the condition is taken from vec_stmt\n-\t     (CCOMPARE), then is the induction index (INDEX_BEFORE_INCR) and\n-\t     else is the phi (NEW_PHI_TREE).  */\n-\t  tree index_cond_expr = build3 (VEC_COND_EXPR, cr_index_vector_type,\n-\t\t\t\t\t ccompare, indx_before_incr,\n-\t\t\t\t\t new_phi_tree);\n-\t  cond_name = make_ssa_name (cr_index_vector_type);\n-\t  gimple *index_condition = gimple_build_assign (cond_name,\n-\t\t\t\t\t\t\t index_cond_expr);\n-\t  gsi_insert_before (&incr_gsi, index_condition, GSI_SAME_STMT);\n-\t  stmt_vec_info index_vec_info = new_stmt_vec_info (index_condition,\n-\t\t\t\t\t\t\t    loop_vinfo);\n-\t  STMT_VINFO_VECTYPE (index_vec_info) = cr_index_vector_type;\n-\t  set_vinfo_for_stmt (index_condition, index_vec_info);\n-\n-\t  /* Update the phi with the vec cond.  */\n-\t  add_phi_arg (new_phi, cond_name, loop_latch_edge (loop),\n-\t\t       UNKNOWN_LOCATION);\n-\t}\n-    }\n+    vect_defs[0] = gimple_assign_lhs (*vec_stmt);\n \n   vect_create_epilog_for_reduction (vect_defs, stmt, epilog_copies,\n                                     epilog_reduc_code, phis, reduc_index,\n-\t\t\t\t    double_reduc, slp_node, cond_name);\n+\t\t\t\t    double_reduc, slp_node);\n \n   return true;\n }"}, {"sha": "eb7bc55c43fbf56c1712b0225a4bcb72b64dbfc0", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62cf73356918189f84ad9fcc83c1ffe8f86d7595/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62cf73356918189f84ad9fcc83c1ffe8f86d7595/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=62cf73356918189f84ad9fcc83c1ffe8f86d7595", "patch": "@@ -3016,11 +3016,6 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n \n   gcc_assert (op);\n \n-  if (CONSTANT_CLASS_P (op))\n-    constant_p = true;\n-  else\n-    constant_p = false;\n-\n   /* NUMBER_OF_COPIES is the number of times we need to use the same values in\n      created vectors. It is greater than 1 if unrolling is performed.\n \n@@ -3040,6 +3035,7 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n   number_of_copies = nunits * number_of_vectors / group_size;\n \n   number_of_places_left_in_vector = nunits;\n+  constant_p = true;\n   elts = XALLOCAVEC (tree, nunits);\n   bool place_after_defs = false;\n   for (j = 0; j < number_of_copies; j++)\n@@ -3156,8 +3152,6 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n \n           if (number_of_places_left_in_vector == 0)\n             {\n-              number_of_places_left_in_vector = nunits;\n-\n \t      if (constant_p)\n \t\tvec_cst = build_vector (vector_type, elts);\n \t      else\n@@ -3188,6 +3182,8 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n \t\t}\n \t      voprnds.quick_push (init);\n \t      place_after_defs = false;\n+              number_of_places_left_in_vector = nunits;\n+\t      constant_p = true;\n             }\n         }\n     }"}]}