{"sha": "2be65d9e98a1335e0d948c2de59946e715afcbe5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJlNjVkOWU5OGExMzM1ZTBkOTQ4YzJkZTU5OTQ2ZTcxNWFmY2JlNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-21T14:50:56Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-21T14:50:56Z"}, "message": "Add a type_has_mode_precision_p helper function\n\n...to replace instances of:\n\n    TYPE_PRECISION (t) == GET_MODE_PRECISION (TYPE_MODE (t))\n\nThese conditions would need to be rewritten with variable-sized\nmodes anyway.\n\n2017-08-21  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* tree.h (type_has_mode_precision_p): New function.\n\t* convert.c (convert_to_integer_1): Use it.\n\t* expr.c (expand_expr_real_2): Likewise.\n\t(expand_expr_real_1): Likewise.\n\t* fold-const.c (fold_single_bit_test_into_sign_test): Likewise.\n\t* match.pd: Likewise.\n\t* tree-ssa-forwprop.c (simplify_rotate): Likewise.\n\t* tree-ssa-math-opts.c (convert_mult_to_fma): Likewise.\n\t* tree-tailcall.c (process_assignment): Likewise.\n\t* tree-vect-loop.c (vectorizable_reduction): Likewise.\n\t* tree-vect-patterns.c (vect_recog_vector_vector_shift_pattern)\n\t(vect_recog_mult_pattern, vect_recog_divmod_pattern): Likewise.\n\t* tree-vect-stmts.c (vectorizable_conversion): Likewise.\n\t(vectorizable_assignment): Likewise.\n\t(vectorizable_shift): Likewise.\n\t(vectorizable_operation): Likewise.\n\t* tree-vrp.c (register_edge_assert_for_2): Likewise.\n\nFrom-SVN: r251231", "tree": {"sha": "a5f3b1eb5eba6d6c7a010dd6ece0a25d1e89b38a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5f3b1eb5eba6d6c7a010dd6ece0a25d1e89b38a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2be65d9e98a1335e0d948c2de59946e715afcbe5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2be65d9e98a1335e0d948c2de59946e715afcbe5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2be65d9e98a1335e0d948c2de59946e715afcbe5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2be65d9e98a1335e0d948c2de59946e715afcbe5/comments", "author": null, "committer": null, "parents": [{"sha": "e83fe013941bf8b3129a8ceb19e14ea7d8c51aa2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e83fe013941bf8b3129a8ceb19e14ea7d8c51aa2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e83fe013941bf8b3129a8ceb19e14ea7d8c51aa2"}], "stats": {"total": 119, "additions": 62, "deletions": 57}, "files": [{"sha": "e7d4e16df59766298d3051f5e23dc4063fb2005e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2be65d9e98a1335e0d948c2de59946e715afcbe5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2be65d9e98a1335e0d948c2de59946e715afcbe5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2be65d9e98a1335e0d948c2de59946e715afcbe5", "patch": "@@ -1,3 +1,23 @@\n+2017-08-21  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* tree.h (type_has_mode_precision_p): New function.\n+\t* convert.c (convert_to_integer_1): Use it.\n+\t* expr.c (expand_expr_real_2): Likewise.\n+\t(expand_expr_real_1): Likewise.\n+\t* fold-const.c (fold_single_bit_test_into_sign_test): Likewise.\n+\t* match.pd: Likewise.\n+\t* tree-ssa-forwprop.c (simplify_rotate): Likewise.\n+\t* tree-ssa-math-opts.c (convert_mult_to_fma): Likewise.\n+\t* tree-tailcall.c (process_assignment): Likewise.\n+\t* tree-vect-loop.c (vectorizable_reduction): Likewise.\n+\t* tree-vect-patterns.c (vect_recog_vector_vector_shift_pattern)\n+\t(vect_recog_mult_pattern, vect_recog_divmod_pattern): Likewise.\n+\t* tree-vect-stmts.c (vectorizable_conversion): Likewise.\n+\t(vectorizable_assignment): Likewise.\n+\t(vectorizable_shift): Likewise.\n+\t(vectorizable_operation): Likewise.\n+\t* tree-vrp.c (register_edge_assert_for_2): Likewise.\n+\n 2017-08-21  Wilco Dijkstra  <wdijkstr@arm.com>\n \n \t* match.pd: Add pow (C, x) simplification."}, {"sha": "22152cae79b1742033d7f869b2aaf027790f2e2f", "filename": "gcc/convert.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2be65d9e98a1335e0d948c2de59946e715afcbe5/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2be65d9e98a1335e0d948c2de59946e715afcbe5/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=2be65d9e98a1335e0d948c2de59946e715afcbe5", "patch": "@@ -711,8 +711,7 @@ convert_to_integer_1 (tree type, tree expr, bool dofold)\n \t     the signed-to-unsigned case the high-order bits have to\n \t     be cleared.  */\n \t  if (TYPE_UNSIGNED (type) != TYPE_UNSIGNED (TREE_TYPE (expr))\n-\t      && (TYPE_PRECISION (TREE_TYPE (expr))\n-\t\t  != GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (expr)))))\n+\t      && !type_has_mode_precision_p (TREE_TYPE (expr)))\n \t    code = CONVERT_EXPR;\n \t  else\n \t    code = NOP_EXPR;"}, {"sha": "7f34f5d12a7d0d52de94e7af27484f98140fba29", "filename": "gcc/expr.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2be65d9e98a1335e0d948c2de59946e715afcbe5/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2be65d9e98a1335e0d948c2de59946e715afcbe5/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=2be65d9e98a1335e0d948c2de59946e715afcbe5", "patch": "@@ -8244,7 +8244,7 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n      result to be reduced to the precision of the bit-field type,\n      which is narrower than that of the type's mode.  */\n   reduce_bit_field = (INTEGRAL_TYPE_P (type)\n-\t\t      && GET_MODE_PRECISION (mode) > TYPE_PRECISION (type));\n+\t\t      && !type_has_mode_precision_p (type));\n \n   if (reduce_bit_field && modifier == EXPAND_STACK_PARM)\n     target = 0;\n@@ -9097,8 +9097,7 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n     case LROTATE_EXPR:\n     case RROTATE_EXPR:\n       gcc_assert (VECTOR_MODE_P (TYPE_MODE (type))\n-\t\t  || (GET_MODE_PRECISION (TYPE_MODE (type))\n-\t\t      == TYPE_PRECISION (type)));\n+\t\t  || type_has_mode_precision_p (type));\n       /* fall through */\n \n     case LSHIFT_EXPR:\n@@ -9671,7 +9670,7 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n      which is narrower than that of the type's mode.  */\n   reduce_bit_field = (!ignore\n \t\t      && INTEGRAL_TYPE_P (type)\n-\t\t      && GET_MODE_PRECISION (mode) > TYPE_PRECISION (type));\n+\t\t      && !type_has_mode_precision_p (type));\n \n   /* If we are going to ignore this result, we need only do something\n      if there is a side-effect somewhere in the expression.  If there"}, {"sha": "de60f681514aacedb993d5c83c081354fa3b342b", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2be65d9e98a1335e0d948c2de59946e715afcbe5/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2be65d9e98a1335e0d948c2de59946e715afcbe5/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=2be65d9e98a1335e0d948c2de59946e715afcbe5", "patch": "@@ -6638,8 +6638,7 @@ fold_single_bit_test_into_sign_test (location_t loc,\n       if (arg00 != NULL_TREE\n \t  /* This is only a win if casting to a signed type is cheap,\n \t     i.e. when arg00's type is not a partial mode.  */\n-\t  && TYPE_PRECISION (TREE_TYPE (arg00))\n-\t     == GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (arg00))))\n+\t  && type_has_mode_precision_p (TREE_TYPE (arg00)))\n \t{\n \t  tree stype = signed_type_for (TREE_TYPE (arg00));\n \t  return fold_build2_loc (loc, code == EQ_EXPR ? GE_EXPR : LT_EXPR,"}, {"sha": "69dd8193cd0524d99fba8be8da8183230b8d621a", "filename": "gcc/match.pd", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2be65d9e98a1335e0d948c2de59946e715afcbe5/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2be65d9e98a1335e0d948c2de59946e715afcbe5/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=2be65d9e98a1335e0d948c2de59946e715afcbe5", "patch": "@@ -992,7 +992,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n \t   || GET_MODE_CLASS (TYPE_MODE (type)) != MODE_INT\n \t   /* Or if the precision of TO is not the same as the precision\n \t      of its mode.  */\n-\t   || TYPE_PRECISION (type) != GET_MODE_PRECISION (TYPE_MODE (type))))\n+\t   || !type_has_mode_precision_p (type)))\n    (convert (bitop @0 (convert @1))))))\n \n (for bitop (bit_and bit_ior)\n@@ -1920,8 +1920,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n        if (shift == LSHIFT_EXPR)\n \t zerobits = ((HOST_WIDE_INT_1U << shiftc) - 1);\n        else if (shift == RSHIFT_EXPR\n-\t\t&& (TYPE_PRECISION (shift_type)\n-\t\t    == GET_MODE_PRECISION (TYPE_MODE (shift_type))))\n+\t\t&& type_has_mode_precision_p (shift_type))\n \t {\n \t   prec = TYPE_PRECISION (TREE_TYPE (@3));\n \t   tree arg00 = @0;\n@@ -1931,8 +1930,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n \t       && TYPE_UNSIGNED (TREE_TYPE (@0)))\n \t     {\n \t       tree inner_type = TREE_TYPE (@0);\n-\t       if ((TYPE_PRECISION (inner_type)\n-\t\t    == GET_MODE_PRECISION (TYPE_MODE (inner_type)))\n+\t       if (type_has_mode_precision_p (inner_type)\n \t\t   && TYPE_PRECISION (inner_type) < prec)\n \t\t {\n \t\t   prec = TYPE_PRECISION (inner_type);\n@@ -3226,8 +3224,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n  (simplify\n   (cmp (bit_and (convert?@2 @0) integer_pow2p@1) integer_zerop)\n   (if (INTEGRAL_TYPE_P (TREE_TYPE (@0))\n-       && (TYPE_PRECISION (TREE_TYPE (@0))\n-\t   == GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (@0))))\n+       && type_has_mode_precision_p (TREE_TYPE (@0))\n        && element_precision (@2) >= element_precision (@0)\n        && wi::only_sign_bit_p (@1, element_precision (@0)))\n    (with { tree stype = signed_type_for (TREE_TYPE (@0)); }\n@@ -4039,11 +4036,9 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n \t /* The precision of the type of each operand must match the\n \t    precision of the mode of each operand, similarly for the\n \t    result.  */\n-\t && (TYPE_PRECISION (TREE_TYPE (@0))\n-\t     == GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (@0))))\n-\t && (TYPE_PRECISION (TREE_TYPE (@1))\n-\t     == GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (@1))))\n-\t && TYPE_PRECISION (type) == GET_MODE_PRECISION (TYPE_MODE (type))\n+\t && type_has_mode_precision_p (TREE_TYPE (@0))\n+\t && type_has_mode_precision_p (TREE_TYPE (@1))\n+\t && type_has_mode_precision_p (type)\n \t /* The inner conversion must be a widening conversion.  */\n \t && TYPE_PRECISION (TREE_TYPE (@2)) > TYPE_PRECISION (TREE_TYPE (@0))\n \t && types_match (@0, type)\n@@ -4073,11 +4068,9 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n        /* The precision of the type of each operand must match the\n \t  precision of the mode of each operand, similarly for the\n \t  result.  */\n-       && (TYPE_PRECISION (TREE_TYPE (@0))\n-\t   == GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (@0))))\n-       && (TYPE_PRECISION (TREE_TYPE (@1))\n-\t   == GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (@1))))\n-       && TYPE_PRECISION (type) == GET_MODE_PRECISION (TYPE_MODE (type))\n+       && type_has_mode_precision_p (TREE_TYPE (@0))\n+       && type_has_mode_precision_p (TREE_TYPE (@1))\n+       && type_has_mode_precision_p (type)\n        /* The inner conversion must be a widening conversion.  */\n        && TYPE_PRECISION (TREE_TYPE (@2)) > TYPE_PRECISION (TREE_TYPE (@0))\n        && types_match (@0, @1)"}, {"sha": "529620672374d71445d0b7851747976182b1eade", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2be65d9e98a1335e0d948c2de59946e715afcbe5/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2be65d9e98a1335e0d948c2de59946e715afcbe5/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=2be65d9e98a1335e0d948c2de59946e715afcbe5", "patch": "@@ -1529,7 +1529,7 @@ simplify_rotate (gimple_stmt_iterator *gsi)\n   /* Only create rotates in complete modes.  Other cases are not\n      expanded properly.  */\n   if (!INTEGRAL_TYPE_P (rtype)\n-      || TYPE_PRECISION (rtype) != GET_MODE_PRECISION (TYPE_MODE (rtype)))\n+      || !type_has_mode_precision_p (rtype))\n     return false;\n \n   for (i = 0; i < 2; i++)\n@@ -1609,8 +1609,7 @@ simplify_rotate (gimple_stmt_iterator *gsi)\n \t      && INTEGRAL_TYPE_P (TREE_TYPE (cdef_arg1[i]))\n \t      && TYPE_PRECISION (TREE_TYPE (cdef_arg1[i]))\n \t\t > floor_log2 (TYPE_PRECISION (rtype))\n-\t      && TYPE_PRECISION (TREE_TYPE (cdef_arg1[i]))\n-\t\t == GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (cdef_arg1[i]))))\n+\t      && type_has_mode_precision_p (TREE_TYPE (cdef_arg1[i])))\n \t    {\n \t      def_arg2_alt[i] = cdef_arg1[i];\n \t      defcodefor_name (def_arg2_alt[i], &cdef_code[i],\n@@ -1639,8 +1638,7 @@ simplify_rotate (gimple_stmt_iterator *gsi)\n \t\t&& INTEGRAL_TYPE_P (TREE_TYPE (tem))\n \t\t&& TYPE_PRECISION (TREE_TYPE (tem))\n \t\t > floor_log2 (TYPE_PRECISION (rtype))\n-\t\t&& TYPE_PRECISION (TREE_TYPE (tem))\n-\t\t == GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (tem)))\n+\t\t&& type_has_mode_precision_p (TREE_TYPE (tem))\n \t\t&& (tem == def_arg2[1 - i]\n \t\t    || tem == def_arg2_alt[1 - i]))\n \t      {\n@@ -1667,8 +1665,7 @@ simplify_rotate (gimple_stmt_iterator *gsi)\n \t\t&& INTEGRAL_TYPE_P (TREE_TYPE (tem))\n \t\t&& TYPE_PRECISION (TREE_TYPE (tem))\n \t\t > floor_log2 (TYPE_PRECISION (rtype))\n-\t\t&& TYPE_PRECISION (TREE_TYPE (tem))\n-\t\t == GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (tem))))\n+\t\t&& type_has_mode_precision_p (TREE_TYPE (tem)))\n \t      defcodefor_name (tem, &code, &tem, NULL);\n \n \t    if (code == NEGATE_EXPR)\n@@ -1683,8 +1680,7 @@ simplify_rotate (gimple_stmt_iterator *gsi)\n \t\t    && INTEGRAL_TYPE_P (TREE_TYPE (tem))\n \t\t    && TYPE_PRECISION (TREE_TYPE (tem))\n \t\t       > floor_log2 (TYPE_PRECISION (rtype))\n-\t\t    && TYPE_PRECISION (TREE_TYPE (tem))\n-\t\t       == GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (tem)))\n+\t\t    && type_has_mode_precision_p (TREE_TYPE (tem))\n \t\t    && (tem == def_arg2[1 - i]\n \t\t\t|| tem == def_arg2_alt[1 - i]))\n \t\t  {"}, {"sha": "0d75751f230723c5c1a4c80474171bf99e6d1338", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2be65d9e98a1335e0d948c2de59946e715afcbe5/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2be65d9e98a1335e0d948c2de59946e715afcbe5/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=2be65d9e98a1335e0d948c2de59946e715afcbe5", "patch": "@@ -3564,8 +3564,7 @@ convert_mult_to_fma (gimple *mul_stmt, tree op1, tree op2)\n \n   /* We don't want to do bitfield reduction ops.  */\n   if (INTEGRAL_TYPE_P (type)\n-      && (TYPE_PRECISION (type)\n-\t  != GET_MODE_PRECISION (TYPE_MODE (type))))\n+      && !type_has_mode_precision_p (type))\n     return false;\n \n   /* If the target doesn't support it, don't generate it.  We assume that"}, {"sha": "c4b8cee4d27738a663d08a09ad0af28b5218ed45", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2be65d9e98a1335e0d948c2de59946e715afcbe5/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2be65d9e98a1335e0d948c2de59946e715afcbe5/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=2be65d9e98a1335e0d948c2de59946e715afcbe5", "patch": "@@ -289,8 +289,7 @@ process_assignment (gassign *stmt,\n \t     type is smaller than mode's precision,\n \t     reduce_to_bit_field_precision would generate additional code.  */\n \t  if (INTEGRAL_TYPE_P (TREE_TYPE (dest))\n-\t      && (GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (dest)))\n-\t\t  > TYPE_PRECISION (TREE_TYPE (dest))))\n+\t      && !type_has_mode_precision_p (TREE_TYPE (dest)))\n \t    return FAIL;\n \t}\n "}, {"sha": "59e41f69d9f556944dbc9c6f32de3df4dd625a14", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2be65d9e98a1335e0d948c2de59946e715afcbe5/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2be65d9e98a1335e0d948c2de59946e715afcbe5/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=2be65d9e98a1335e0d948c2de59946e715afcbe5", "patch": "@@ -5848,8 +5848,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n     return false;\n \n   /* Do not try to vectorize bit-precision reductions.  */\n-  if ((TYPE_PRECISION (scalar_type)\n-       != GET_MODE_PRECISION (TYPE_MODE (scalar_type))))\n+  if (!type_has_mode_precision_p (scalar_type))\n     return false;\n \n   /* All uses but the last are expected to be defined in the loop."}, {"sha": "877711a4f800bd26518cfce6aa1f061993e97e4c", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2be65d9e98a1335e0d948c2de59946e715afcbe5/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2be65d9e98a1335e0d948c2de59946e715afcbe5/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=2be65d9e98a1335e0d948c2de59946e715afcbe5", "patch": "@@ -2067,8 +2067,7 @@ vect_recog_vector_vector_shift_pattern (vec<gimple *> *stmts,\n   if (TREE_CODE (oprnd0) != SSA_NAME\n       || TREE_CODE (oprnd1) != SSA_NAME\n       || TYPE_MODE (TREE_TYPE (oprnd0)) == TYPE_MODE (TREE_TYPE (oprnd1))\n-      || TYPE_PRECISION (TREE_TYPE (oprnd1))\n-\t != GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (oprnd1)))\n+      || !type_has_mode_precision_p (TREE_TYPE (oprnd1))\n       || TYPE_PRECISION (TREE_TYPE (lhs))\n \t != TYPE_PRECISION (TREE_TYPE (oprnd0)))\n     return NULL;\n@@ -2470,7 +2469,7 @@ vect_recog_mult_pattern (vec<gimple *> *stmts,\n   if (TREE_CODE (oprnd0) != SSA_NAME\n       || TREE_CODE (oprnd1) != INTEGER_CST\n       || !INTEGRAL_TYPE_P (itype)\n-      || TYPE_PRECISION (itype) != GET_MODE_PRECISION (TYPE_MODE (itype)))\n+      || !type_has_mode_precision_p (itype))\n     return NULL;\n \n   vectype = get_vectype_for_scalar_type (itype);\n@@ -2585,7 +2584,7 @@ vect_recog_divmod_pattern (vec<gimple *> *stmts,\n   if (TREE_CODE (oprnd0) != SSA_NAME\n       || TREE_CODE (oprnd1) != INTEGER_CST\n       || TREE_CODE (itype) != INTEGER_TYPE\n-      || TYPE_PRECISION (itype) != GET_MODE_PRECISION (TYPE_MODE (itype)))\n+      || !type_has_mode_precision_p (itype))\n     return NULL;\n \n   vectype = get_vectype_for_scalar_type (itype);"}, {"sha": "0629c12a4bef8d1feca353220750d45fb8eddafb", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2be65d9e98a1335e0d948c2de59946e715afcbe5/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2be65d9e98a1335e0d948c2de59946e715afcbe5/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=2be65d9e98a1335e0d948c2de59946e715afcbe5", "patch": "@@ -4098,11 +4098,9 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   if (!VECTOR_BOOLEAN_TYPE_P (vectype_out)\n       && ((INTEGRAL_TYPE_P (lhs_type)\n-\t   && (TYPE_PRECISION (lhs_type)\n-\t       != GET_MODE_PRECISION (TYPE_MODE (lhs_type))))\n+\t   && !type_has_mode_precision_p (lhs_type))\n \t  || (INTEGRAL_TYPE_P (rhs_type)\n-\t      && (TYPE_PRECISION (rhs_type)\n-\t\t  != GET_MODE_PRECISION (TYPE_MODE (rhs_type))))))\n+\t      && !type_has_mode_precision_p (rhs_type))))\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -4696,10 +4694,8 @@ vectorizable_assignment (gimple *stmt, gimple_stmt_iterator *gsi,\n   if ((CONVERT_EXPR_CODE_P (code)\n        || code == VIEW_CONVERT_EXPR)\n       && INTEGRAL_TYPE_P (TREE_TYPE (scalar_dest))\n-      && ((TYPE_PRECISION (TREE_TYPE (scalar_dest))\n-\t   != GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (scalar_dest))))\n-\t  || ((TYPE_PRECISION (TREE_TYPE (op))\n-\t       != GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (op))))))\n+      && (!type_has_mode_precision_p (TREE_TYPE (scalar_dest))\n+\t  || !type_has_mode_precision_p (TREE_TYPE (op)))\n       /* But a conversion that does not change the bit-pattern is ok.  */\n       && !((TYPE_PRECISION (TREE_TYPE (scalar_dest))\n \t    > TYPE_PRECISION (TREE_TYPE (op)))\n@@ -4875,8 +4871,7 @@ vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   scalar_dest = gimple_assign_lhs (stmt);\n   vectype_out = STMT_VINFO_VECTYPE (stmt_info);\n-  if (TYPE_PRECISION (TREE_TYPE (scalar_dest))\n-      != GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (scalar_dest))))\n+  if (!type_has_mode_precision_p (TREE_TYPE (scalar_dest)))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5264,8 +5259,7 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n   /* Most operations cannot handle bit-precision types without extra\n      truncations.  */\n   if (!VECTOR_BOOLEAN_TYPE_P (vectype_out)\n-      && (TYPE_PRECISION (TREE_TYPE (scalar_dest))\n-\t  != GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (scalar_dest))))\n+      && !type_has_mode_precision_p (TREE_TYPE (scalar_dest))\n       /* Exception are bitwise binary operations.  */\n       && code != BIT_IOR_EXPR\n       && code != BIT_XOR_EXPR"}, {"sha": "e1038a10b7a353de3b97a9e2d278abbb97f1d261", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2be65d9e98a1335e0d948c2de59946e715afcbe5/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2be65d9e98a1335e0d948c2de59946e715afcbe5/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=2be65d9e98a1335e0d948c2de59946e715afcbe5", "patch": "@@ -5247,7 +5247,7 @@ register_edge_assert_for_2 (tree name, edge e,\n \t      && tree_fits_uhwi_p (cst2)\n \t      && INTEGRAL_TYPE_P (TREE_TYPE (name2))\n \t      && IN_RANGE (tree_to_uhwi (cst2), 1, prec - 1)\n-\t      && prec == GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (val))))\n+\t      && type_has_mode_precision_p (TREE_TYPE (val)))\n \t    {\n \t      mask = wi::mask (tree_to_uhwi (cst2), false, prec);\n \t      val2 = fold_binary (LSHIFT_EXPR, TREE_TYPE (val), val, cst2);"}, {"sha": "c855a4ccb5d14cbd3662ae6e6d0c176bf33fb52c", "filename": "gcc/tree.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2be65d9e98a1335e0d948c2de59946e715afcbe5/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2be65d9e98a1335e0d948c2de59946e715afcbe5/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=2be65d9e98a1335e0d948c2de59946e715afcbe5", "patch": "@@ -5414,4 +5414,13 @@ struct builtin_structptr_type\n   const char *str;\n };\n extern const builtin_structptr_type builtin_structptr_types[6];\n+\n+/* Return true if type T has the same precision as its underlying mode.  */\n+\n+inline bool\n+type_has_mode_precision_p (const_tree t)\n+{\n+  return TYPE_PRECISION (t) == GET_MODE_PRECISION (TYPE_MODE (t));\n+}\n+\n #endif  /* GCC_TREE_H  */"}]}