{"sha": "51f03c6b11a46d756ae05c67e34cca2ccb4fafaa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTFmMDNjNmIxMWE0NmQ3NTZhZTA1YzY3ZTM0Y2NhMmNjYjRmYWZhYQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-01-21T10:30:54Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-01-21T10:30:54Z"}, "message": "gfortran.h (gfc_extract_int): Change return type to bool.\n\n\t* gfortran.h (gfc_extract_int): Change return type to bool.  Add\n\tint argument with = 0.\n\t* decl.c (gfc_match_kind_spec): Adjust gfc_extract_int caller, pass\n\t1 as new last argument to it, don't emit gfc_error.\n\t(match_char_kind): Likewise.\n\t(gfc_match_decl_type_spec): Use gfc_get_string (\"%s\", x) instead of\n\tgfc_get_string (x).\n\t(gfc_match_derived_decl, match_binding_attributes): Likewise.\n\t(gfc_match_structure_decl): Don't sprintf back to name, call\n\tget_struct_decl directly with gfc_dt_upper_string (name) result.\n\t* trans-stmt.c (gfc_trans_allocate): Use gfc_get_string (\"%s\", x)\n\tinstead of gfc_get_string (x).\n\t* module.c (gfc_dt_lower_string, gfc_dt_upper_string,\n\tgfc_match_use, gfc_match_submodule, find_true_name, mio_pool_string,\n\tmio_symtree_ref, mio_expr, mio_omp_udr_expr, load_generic_interfaces,\n\tload_omp_udrs, load_needed, read_module, dump_module,\n\tcreate_intrinsic_function, import_iso_c_binding_module,\n\tcreate_int_parameter, create_int_parameter_array, create_derived_type,\n\tuse_iso_fortran_env_module): Likewise.\n\t* error.c (gfc_diagnostic_starter, gfc_diagnostic_start_span): Use\n\tpp_verbatim (context->printer, \"%s\", x) instead of\n\tpp_verbatim (context->printer, x).\n\t* match.c (gfc_match_small_int): Adjust gfc_extract_int caller, pass\n\t1 as new last argument to it, don't emit gfc_error.\n\t(gfc_match_small_int_expr): Likewise.\n\t* iresolve.c (gfc_get_string): Optimize format \"%s\" case.\n\t(resolve_bound): Use gfc_get_string (\"%s\", x) instead of\n\tgfc_get_string (x).\n\t(resolve_transformational): Formatting fix.\n\t(gfc_resolve_char_achar): Change name argument to bool is_achar,\n\tuse a single format string and if is_achar add \"a\" before \"char\".\n\t(gfc_resolve_achar, gfc_resolve_char): Adjust callers.\n\t* expr.c (gfc_extract_int): Change return type to bool, return true\n\tif some error occurred.  Add REPORT_ERROR argument, if non-zero\n\tcall either gfc_error or gfc_error_now depending on its sign.\n\t* arith.c (arith_power): Adjust gfc_extract_int caller.\n\t* symbol.c (gfc_add_component): Use gfc_get_string (\"%s\", x) instead\n\tof gfc_get_string (x).\n\t(gfc_new_symtree, gfc_delete_symtree, gfc_get_uop, gfc_new_symbol,\n\tgfc_get_gsymbol, generate_isocbinding_symbol): Likewise.\n\t* openmp.c (gfc_match_omp_clauses): Adjust gfc_extract_int caller, pass\n\t-1 as new last argument to it, don't emit gfc_error_now.\n\t(gfc_match_omp_declare_reduction): Use gfc_get_string (\"%s\", x)\n\tinstead of gfc_get_string (x).\n\t* check.c (kind_check): Adjust gfc_extract_int caller.\n\t* intrinsic.c (add_sym, find_sym, make_alias): Use\n\tgfc_get_string (\"%s\", x) instead of gfc_get_string (x).\n\t* simplify.c (get_kind, gfc_simplify_btest, gfc_simplify_maskr,\n\tgfc_simplify_maskl, gfc_simplify_poppar, gfc_simplify_repeat,\n\tgfc_simplify_selected_int_kind, gfc_simplify_selected_real_kind):\n\tAdjust gfc_extract_int callers.\n\t* trans-decl.c (gfc_find_module): Use gfc_get_string (\"%s\", x)\n\tinstead of gfc_get_string (x).\n\t* matchexp.c (expression_syntax): Add const.\n\t* primary.c (match_kind_param, match_hollerith_constant,\n\tmatch_string_constant): Adjust gfc_extract_int callers.\n\t(match_keyword_arg): Use gfc_get_string (\"%s\", x) instead of\n\tgfc_get_string (x).\n\t* frontend-passes.c (optimize_minmaxloc): Likewise.\n\nFrom-SVN: r244744", "tree": {"sha": "a3c04db8f13bc28886f7a7a7f58defc6d3b7c3be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3c04db8f13bc28886f7a7a7f58defc6d3b7c3be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c6c82710eda68ad57d06b50e42c009b42e7ea610", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6c82710eda68ad57d06b50e42c009b42e7ea610", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6c82710eda68ad57d06b50e42c009b42e7ea610"}], "stats": {"total": 351, "additions": 201, "deletions": 150}, "files": [{"sha": "5382696a1755a0e1df95ced508935bbab72e42e6", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=51f03c6b11a46d756ae05c67e34cca2ccb4fafaa", "patch": "@@ -1,3 +1,65 @@\n+2017-01-21  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gfortran.h (gfc_extract_int): Change return type to bool.  Add\n+\tint argument with = 0.\n+\t* decl.c (gfc_match_kind_spec): Adjust gfc_extract_int caller, pass\n+\t1 as new last argument to it, don't emit gfc_error.\n+\t(match_char_kind): Likewise.\n+\t(gfc_match_decl_type_spec): Use gfc_get_string (\"%s\", x) instead of\n+\tgfc_get_string (x).\n+\t(gfc_match_derived_decl, match_binding_attributes): Likewise.\n+\t(gfc_match_structure_decl): Don't sprintf back to name, call\n+\tget_struct_decl directly with gfc_dt_upper_string (name) result.\n+\t* trans-stmt.c (gfc_trans_allocate): Use gfc_get_string (\"%s\", x)\n+\tinstead of gfc_get_string (x).\n+\t* module.c (gfc_dt_lower_string, gfc_dt_upper_string,\n+\tgfc_match_use, gfc_match_submodule, find_true_name, mio_pool_string,\n+\tmio_symtree_ref, mio_expr, mio_omp_udr_expr, load_generic_interfaces,\n+\tload_omp_udrs, load_needed, read_module, dump_module,\n+\tcreate_intrinsic_function, import_iso_c_binding_module,\n+\tcreate_int_parameter, create_int_parameter_array, create_derived_type,\n+\tuse_iso_fortran_env_module): Likewise.\n+\t* error.c (gfc_diagnostic_starter, gfc_diagnostic_start_span): Use\n+\tpp_verbatim (context->printer, \"%s\", x) instead of\n+\tpp_verbatim (context->printer, x).\n+\t* match.c (gfc_match_small_int): Adjust gfc_extract_int caller, pass\n+\t1 as new last argument to it, don't emit gfc_error.\n+\t(gfc_match_small_int_expr): Likewise.\n+\t* iresolve.c (gfc_get_string): Optimize format \"%s\" case.\n+\t(resolve_bound): Use gfc_get_string (\"%s\", x) instead of\n+\tgfc_get_string (x).\n+\t(resolve_transformational): Formatting fix.\n+\t(gfc_resolve_char_achar): Change name argument to bool is_achar,\n+\tuse a single format string and if is_achar add \"a\" before \"char\".\n+\t(gfc_resolve_achar, gfc_resolve_char): Adjust callers.\n+\t* expr.c (gfc_extract_int): Change return type to bool, return true\n+\tif some error occurred.  Add REPORT_ERROR argument, if non-zero\n+\tcall either gfc_error or gfc_error_now depending on its sign.\n+\t* arith.c (arith_power): Adjust gfc_extract_int caller.\n+\t* symbol.c (gfc_add_component): Use gfc_get_string (\"%s\", x) instead\n+\tof gfc_get_string (x).\n+\t(gfc_new_symtree, gfc_delete_symtree, gfc_get_uop, gfc_new_symbol,\n+\tgfc_get_gsymbol, generate_isocbinding_symbol): Likewise.\n+\t* openmp.c (gfc_match_omp_clauses): Adjust gfc_extract_int caller, pass\n+\t-1 as new last argument to it, don't emit gfc_error_now.\n+\t(gfc_match_omp_declare_reduction): Use gfc_get_string (\"%s\", x)\n+\tinstead of gfc_get_string (x).\n+\t* check.c (kind_check): Adjust gfc_extract_int caller.\n+\t* intrinsic.c (add_sym, find_sym, make_alias): Use\n+\tgfc_get_string (\"%s\", x) instead of gfc_get_string (x).\n+\t* simplify.c (get_kind, gfc_simplify_btest, gfc_simplify_maskr,\n+\tgfc_simplify_maskl, gfc_simplify_poppar, gfc_simplify_repeat,\n+\tgfc_simplify_selected_int_kind, gfc_simplify_selected_real_kind):\n+\tAdjust gfc_extract_int callers.\n+\t* trans-decl.c (gfc_find_module): Use gfc_get_string (\"%s\", x)\n+\tinstead of gfc_get_string (x).\n+\t* matchexp.c (expression_syntax): Add const.\n+\t* primary.c (match_kind_param, match_hollerith_constant,\n+\tmatch_string_constant): Adjust gfc_extract_int callers.\n+\t(match_keyword_arg): Use gfc_get_string (\"%s\", x) instead of\n+\tgfc_get_string (x).\n+\t* frontend-passes.c (optimize_minmaxloc): Likewise.\n+\n 2017-01-19  Andre Vehreschild  <vehre@gcc.gnu.org>\n \n \tPR fortran/70696"}, {"sha": "9d14487237ff465cf91318ef7fc47bd4095c7df8", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=51f03c6b11a46d756ae05c67e34cca2ccb4fafaa", "patch": "@@ -875,7 +875,7 @@ arith_power (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n \t\t    /* if op2 < 0, op1**op2 == 0  because abs(op1) > 1.  */\n \t\t    mpz_set_si (result->value.integer, 0);\n \t\t  }\n-\t\telse if (gfc_extract_int (op2, &power) != NULL)\n+\t\telse if (gfc_extract_int (op2, &power))\n \t\t  {\n \t\t    /* If op2 doesn't fit in an int, the exponentiation will\n \t\t       overflow, because op2 > 0 and abs(op1) > 1.  */"}, {"sha": "c22bfa965eba355cc6b6afcd6e1b1a794cae26c5", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=51f03c6b11a46d756ae05c67e34cca2ccb4fafaa", "patch": "@@ -177,7 +177,7 @@ kind_check (gfc_expr *k, int n, bt type)\n       return false;\n     }\n \n-  if (gfc_extract_int (k, &kind) != NULL\n+  if (gfc_extract_int (k, &kind)\n       || gfc_validate_kind (type, kind, true) < 0)\n     {\n       gfc_error (\"Invalid kind for %s at %L\", gfc_basic_typename (type),"}, {"sha": "a92e06aa6fc1e17f215a2a3c08939f5106205433", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=51f03c6b11a46d756ae05c67e34cca2ccb4fafaa", "patch": "@@ -2540,7 +2540,6 @@ gfc_match_kind_spec (gfc_typespec *ts, bool kind_expr_only)\n   gfc_expr *e;\n   match m, n;\n   char c;\n-  const char *msg;\n \n   m = MATCH_NO;\n   n = MATCH_YES;\n@@ -2598,11 +2597,8 @@ gfc_match_kind_spec (gfc_typespec *ts, bool kind_expr_only)\n       goto no_match;\n     }\n \n-  msg = gfc_extract_int (e, &ts->kind);\n-\n-  if (msg != NULL)\n+  if (gfc_extract_int (e, &ts->kind, 1))\n     {\n-      gfc_error (msg);\n       m = MATCH_ERROR;\n       goto no_match;\n     }\n@@ -2700,7 +2696,7 @@ match_char_kind (int * kind, int * is_iso_c)\n   locus where;\n   gfc_expr *e;\n   match m, n;\n-  const char *msg;\n+  bool fail;\n \n   m = MATCH_NO;\n   e = NULL;\n@@ -2730,11 +2726,10 @@ match_char_kind (int * kind, int * is_iso_c)\n       goto no_match;\n     }\n \n-  msg = gfc_extract_int (e, kind);\n+  fail = gfc_extract_int (e, kind, 1);\n   *is_iso_c = e->ts.is_iso_c;\n-  if (msg != NULL)\n+  if (fail)\n     {\n-      gfc_error (msg);\n       m = MATCH_ERROR;\n       goto no_match;\n     }\n@@ -3302,7 +3297,7 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n \n       /* Use upper case to save the actual derived-type symbol.  */\n       gfc_get_symbol (dt_name, NULL, &dt_sym);\n-      dt_sym->name = gfc_get_string (sym->name);\n+      dt_sym->name = gfc_get_string (\"%s\", sym->name);\n       head = sym->generic;\n       intr = gfc_get_interface ();\n       intr->sym = dt_sym;\n@@ -8743,8 +8738,7 @@ gfc_match_structure_decl (void)\n   /* Store the actual type symbol for the structure with an upper-case first\n      letter (an invalid Fortran identifier).  */\n \n-  sprintf (name, gfc_dt_upper_string (name));\n-  if (!get_struct_decl (name, FL_STRUCT, &where, &sym))\n+  if (!get_struct_decl (gfc_dt_upper_string (name), FL_STRUCT, &where, &sym))\n     return MATCH_ERROR;\n \n   gfc_new_block = sym;\n@@ -8937,7 +8931,7 @@ gfc_match_derived_decl (void)\n     {\n       /* Use upper case to save the actual derived-type symbol.  */\n       gfc_get_symbol (gfc_dt_upper_string (gensym->name), NULL, &sym);\n-      sym->name = gfc_get_string (gensym->name);\n+      sym->name = gfc_get_string (\"%s\", gensym->name);\n       head = gensym->generic;\n       intr = gfc_get_interface ();\n       intr->sym = sym;\n@@ -9357,7 +9351,7 @@ match_binding_attributes (gfc_typebound_proc* ba, bool generic, bool ppc)\n \t      if (m == MATCH_ERROR)\n \t\tgoto error;\n \t      if (m == MATCH_YES)\n-\t\tba->pass_arg = gfc_get_string (arg);\n+\t\tba->pass_arg = gfc_get_string (\"%s\", arg);\n \t      gcc_assert ((m == MATCH_YES) == (ba->pass_arg != NULL));\n \n \t      found_passing = true;"}, {"sha": "ccf0be019e2f6f55968450ad61644f5542fef58c", "filename": "gcc/fortran/error.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ferror.c?ref=51f03c6b11a46d756ae05c67e34cca2ccb4fafaa", "patch": "@@ -1089,7 +1089,7 @@ gfc_diagnostic_starter (diagnostic_context *context,\n     }\n   else\n     {\n-      pp_verbatim (context->printer, locus_prefix);\n+      pp_verbatim (context->printer, \"%s\", locus_prefix);\n       free (locus_prefix);\n       /* Fortran uses an empty line between locus and caret line.  */\n       pp_newline (context->printer);\n@@ -1106,7 +1106,7 @@ gfc_diagnostic_start_span (diagnostic_context *context,\n {\n   char *locus_prefix;\n   locus_prefix = gfc_diagnostic_build_locus_prefix (context, exploc);\n-  pp_verbatim (context->printer, locus_prefix);\n+  pp_verbatim (context->printer, \"%s\", locus_prefix);\n   free (locus_prefix);\n   pp_newline (context->printer);\n   /* Fortran uses an empty line between locus and caret line.  */"}, {"sha": "f90bdc398762438850559e258b8d48e92f52a205", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=51f03c6b11a46d756ae05c67e34cca2ccb4fafaa", "patch": "@@ -611,28 +611,44 @@ gfc_replace_expr (gfc_expr *dest, gfc_expr *src)\n \n \n /* Try to extract an integer constant from the passed expression node.\n-   Returns an error message or NULL if the result is set.  It is\n-   tempting to generate an error and return true or false, but\n-   failure is OK for some callers.  */\n+   Return true if some error occurred, false on success.  If REPORT_ERROR\n+   is non-zero, emit error, for positive REPORT_ERROR using gfc_error,\n+   for negative using gfc_error_now.  */\n \n-const char *\n-gfc_extract_int (gfc_expr *expr, int *result)\n+bool\n+gfc_extract_int (gfc_expr *expr, int *result, int report_error)\n {\n   if (expr->expr_type != EXPR_CONSTANT)\n-    return _(\"Constant expression required at %C\");\n+    {\n+      if (report_error > 0)\n+\tgfc_error (\"Constant expression required at %C\");\n+      else if (report_error < 0)\n+\tgfc_error_now (\"Constant expression required at %C\");\n+      return true;\n+    }\n \n   if (expr->ts.type != BT_INTEGER)\n-    return _(\"Integer expression required at %C\");\n+    {\n+      if (report_error > 0)\n+\tgfc_error (\"Integer expression required at %C\");\n+      else if (report_error < 0)\n+\tgfc_error_now (\"Integer expression required at %C\");\n+      return true;\n+    }\n \n   if ((mpz_cmp_si (expr->value.integer, INT_MAX) > 0)\n       || (mpz_cmp_si (expr->value.integer, INT_MIN) < 0))\n     {\n-      return _(\"Integer value too large in expression at %C\");\n+      if (report_error > 0)\n+\tgfc_error (\"Integer value too large in expression at %C\");\n+      else if (report_error < 0)\n+\tgfc_error_now (\"Integer value too large in expression at %C\");\n+      return true;\n     }\n \n   *result = (int) mpz_get_si (expr->value.integer);\n \n-  return NULL;\n+  return false;\n }\n \n "}, {"sha": "b255e98af31c36bd18cf185a181d009ebd553f84", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=51f03c6b11a46d756ae05c67e34cca2ccb4fafaa", "patch": "@@ -1911,7 +1911,7 @@ optimize_minmaxloc (gfc_expr **e)\n   strcpy (name, fn->value.function.name);\n   p = strstr (name, \"loc0\");\n   p[3] = '1';\n-  fn->value.function.name = gfc_get_string (name);\n+  fn->value.function.name = gfc_get_string (\"%s\", name);\n   if (fn->value.function.actual->next)\n     {\n       a = fn->value.function.actual->next;"}, {"sha": "814ce7847c8a282c4717ed89fc63e171ea520b06", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=51f03c6b11a46d756ae05c67e34cca2ccb4fafaa", "patch": "@@ -3080,7 +3080,7 @@ void gfc_resolve_oacc_blocks (gfc_code *, gfc_namespace *);\n /* expr.c */\n void gfc_free_actual_arglist (gfc_actual_arglist *);\n gfc_actual_arglist *gfc_copy_actual_arglist (gfc_actual_arglist *);\n-const char *gfc_extract_int (gfc_expr *, int *);\n+bool gfc_extract_int (gfc_expr *, int *, int = 0);\n bool is_subref_array (gfc_expr *);\n bool gfc_is_simply_contiguous (gfc_expr *, bool, bool);\n bool gfc_check_init_expr (gfc_expr *);"}, {"sha": "e059a312dfdaf4af302dfc613030fea8792f3e3c", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=51f03c6b11a46d756ae05c67e34cca2ccb4fafaa", "patch": "@@ -333,11 +333,11 @@ add_sym (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt type\n       break;\n \n     case SZ_NOTHING:\n-      next_sym->name = gfc_get_string (name);\n+      next_sym->name = gfc_get_string (\"%s\", name);\n \n       strcpy (buf, \"_gfortran_\");\n       strcat (buf, name);\n-      next_sym->lib_name = gfc_get_string (buf);\n+      next_sym->lib_name = gfc_get_string (\"%s\", buf);\n \n       next_sym->pure = (cl != CLASS_IMPURE);\n       next_sym->elemental = (cl == CLASS_ELEMENTAL);\n@@ -884,7 +884,7 @@ find_sym (gfc_intrinsic_sym *start, int n, const char *name)\n   /* name may be a user-supplied string, so we must first make sure\n      that we're comparing against a pointer into the global string\n      table.  */\n-  const char *p = gfc_get_string (name);\n+  const char *p = gfc_get_string (\"%s\", name);\n \n   while (n > 0)\n     {\n@@ -1153,7 +1153,7 @@ make_alias (const char *name, int standard)\n \n     case SZ_NOTHING:\n       next_sym[0] = next_sym[-1];\n-      next_sym->name = gfc_get_string (name);\n+      next_sym->name = gfc_get_string (\"%s\", name);\n       next_sym->standard = standard;\n       next_sym++;\n       break;"}, {"sha": "f5a44623946e71e4c84d5c3981f75a62e5852823", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=51f03c6b11a46d756ae05c67e34cca2ccb4fafaa", "patch": "@@ -47,15 +47,27 @@ const char *\n gfc_get_string (const char *format, ...)\n {\n   char temp_name[128];\n+  const char *str;\n   va_list ap;\n   tree ident;\n \n-  va_start (ap, format);\n-  vsnprintf (temp_name, sizeof (temp_name), format, ap);\n-  va_end (ap);\n-  temp_name[sizeof (temp_name) - 1] = 0;\n+  /* Handle common case without vsnprintf and temporary buffer.  */\n+  if (format[0] == '%' && format[1] == 's' && format[2] == '\\0')\n+    {\n+      va_start (ap, format);\n+      str = va_arg (ap, const char *);\n+      va_end (ap);\n+    }\n+  else\n+    {\n+      va_start (ap, format);\n+      vsnprintf (temp_name, sizeof (temp_name), format, ap);\n+      va_end (ap);\n+      temp_name[sizeof (temp_name) - 1] = 0;\n+      str = temp_name;\n+    }\n \n-  ident = get_identifier (temp_name);\n+  ident = get_identifier (str);\n   return IDENTIFIER_POINTER (ident);\n }\n \n@@ -141,7 +153,7 @@ resolve_bound (gfc_expr *f, gfc_expr *array, gfc_expr *dim, gfc_expr *kind,\n \t}\n     }\n \n-  f->value.function.name = gfc_get_string (name);\n+  f->value.function.name = gfc_get_string (\"%s\", name);\n }\n \n \n@@ -174,7 +186,7 @@ resolve_transformational (const char *name, gfc_expr *f, gfc_expr *array,\n \n   f->value.function.name\n     = gfc_get_string (PREFIX (\"%s%s_%c%d\"), prefix, name,\n-\t\t    gfc_type_letter (array->ts.type), array->ts.kind);\n+\t\t      gfc_type_letter (array->ts.type), array->ts.kind);\n }\n \n \n@@ -229,24 +241,24 @@ gfc_resolve_adjustr (gfc_expr *f, gfc_expr *string)\n \n static void\n gfc_resolve_char_achar (gfc_expr *f, gfc_expr *x, gfc_expr *kind,\n-\t\t\tconst char *name)\n+\t\t\tbool is_achar)\n {\n   f->ts.type = BT_CHARACTER;\n   f->ts.kind = (kind == NULL)\n \t     ? gfc_default_character_kind : mpz_get_si (kind->value.integer);\n   f->ts.u.cl = gfc_new_charlen (gfc_current_ns, NULL);\n   f->ts.u.cl->length = gfc_get_int_expr (gfc_default_integer_kind, NULL, 1);\n \n-  f->value.function.name = gfc_get_string (name, f->ts.kind,\n-\t\t\t\t\t   gfc_type_letter (x->ts.type),\n-\t\t\t\t\t   x->ts.kind);\n+  f->value.function.name\n+    = gfc_get_string (\"__%schar_%d_%c%d\", is_achar ? \"a\" : \"\", f->ts.kind,\n+\t\t      gfc_type_letter (x->ts.type), x->ts.kind);\n }\n \n \n void\n gfc_resolve_achar (gfc_expr *f, gfc_expr *x, gfc_expr *kind)\n {\n-  gfc_resolve_char_achar (f, x, kind, \"__achar_%d_%c%d\");\n+  gfc_resolve_char_achar (f, x, kind, true);\n }\n \n \n@@ -536,7 +548,7 @@ gfc_resolve_ceiling (gfc_expr *f, gfc_expr *a, gfc_expr *kind)\n void\n gfc_resolve_char (gfc_expr *f, gfc_expr *a, gfc_expr *kind)\n {\n-  gfc_resolve_char_achar (f, a, kind, \"__char_%d_%c%d\");\n+  gfc_resolve_char_achar (f, a, kind, false);\n }\n \n "}, {"sha": "003a0434eb023272377c9da7928e0f4125a14800", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=51f03c6b11a46d756ae05c67e34cca2ccb4fafaa", "patch": "@@ -514,23 +514,17 @@ match\n gfc_match_small_int (int *value)\n {\n   gfc_expr *expr;\n-  const char *p;\n   match m;\n   int i;\n \n   m = gfc_match_expr (&expr);\n   if (m != MATCH_YES)\n     return m;\n \n-  p = gfc_extract_int (expr, &i);\n+  if (gfc_extract_int (expr, &i, 1))\n+    m = MATCH_ERROR;\n   gfc_free_expr (expr);\n \n-  if (p != NULL)\n-    {\n-      gfc_error (p);\n-      m = MATCH_ERROR;\n-    }\n-\n   *value = i;\n   return m;\n }\n@@ -547,21 +541,15 @@ gfc_match_small_int (int *value)\n match\n gfc_match_small_int_expr (int *value, gfc_expr **expr)\n {\n-  const char *p;\n   match m;\n   int i;\n \n   m = gfc_match_expr (expr);\n   if (m != MATCH_YES)\n     return m;\n \n-  p = gfc_extract_int (*expr, &i);\n-\n-  if (p != NULL)\n-    {\n-      gfc_error (p);\n-      m = MATCH_ERROR;\n-    }\n+  if (gfc_extract_int (*expr, &i, 1))\n+    m = MATCH_ERROR;\n \n   *value = i;\n   return m;"}, {"sha": "978702b3a2ae0ce1b45a5cb5f6d5aa367888bfcc", "filename": "gcc/fortran/matchexp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Fmatchexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Fmatchexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatchexp.c?ref=51f03c6b11a46d756ae05c67e34cca2ccb4fafaa", "patch": "@@ -25,7 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"arith.h\"\n #include \"match.h\"\n \n-static char expression_syntax[] = N_(\"Syntax error in expression at %C\");\n+static const char expression_syntax[] = N_(\"Syntax error in expression at %C\");\n \n \n /* Match a user-defined operator name.  This is a normal name with a"}, {"sha": "5515fed4ab4e17d7feeae637dc05412b6e48c4b9", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=51f03c6b11a46d756ae05c67e34cca2ccb4fafaa", "patch": "@@ -428,7 +428,7 @@ gfc_dt_lower_string (const char *name)\n   if (name[0] != (char) TOLOWER ((unsigned char) name[0]))\n     return gfc_get_string (\"%c%s\", (char) TOLOWER ((unsigned char) name[0]),\n \t\t\t   &name[1]);\n-  return gfc_get_string (name);\n+  return gfc_get_string (\"%s\", name);\n }\n \n \n@@ -443,7 +443,7 @@ gfc_dt_upper_string (const char *name)\n   if (name[0] != (char) TOUPPER ((unsigned char) name[0]))\n     return gfc_get_string (\"%c%s\", (char) TOUPPER ((unsigned char) name[0]),\n \t\t\t   &name[1]);\n-  return gfc_get_string (name);\n+  return gfc_get_string (\"%s\", name);\n }\n \n /* Call here during module reading when we know what pointer to\n@@ -594,7 +594,7 @@ gfc_match_use (void)\n       return m;\n     }\n \n-  use_list->module_name = gfc_get_string (name);\n+  use_list->module_name = gfc_get_string (\"%s\", name);\n \n   if (gfc_match_eos () == MATCH_YES)\n     goto done;\n@@ -774,7 +774,7 @@ gfc_match_submodule (void)\n       else\n \t{\n \t  module_list = use_list;\n-\t  use_list->module_name = gfc_get_string (name);\n+\t  use_list->module_name = gfc_get_string (\"%s\", name);\n \t  use_list->submodule_name = use_list->module_name;\n \t}\n \n@@ -963,9 +963,9 @@ find_true_name (const char *name, const char *module)\n   gfc_symbol sym;\n   int c;\n \n-  t.name = gfc_get_string (name);\n+  t.name = gfc_get_string (\"%s\", name);\n   if (module != NULL)\n-    sym.module = gfc_get_string (module);\n+    sym.module = gfc_get_string (\"%s\", module);\n   else\n     sym.module = NULL;\n   t.sym = &sym;\n@@ -1955,7 +1955,8 @@ mio_pool_string (const char **stringp)\n   else\n     {\n       require_atom (ATOM_STRING);\n-      *stringp = atom_string[0] == '\\0' ? NULL : gfc_get_string (atom_string);\n+      *stringp = (atom_string[0] == '\\0'\n+\t\t  ? NULL : gfc_get_string (\"%s\", atom_string));\n       free (atom_string);\n     }\n }\n@@ -2967,7 +2968,7 @@ mio_symtree_ref (gfc_symtree **stp)\n \t    {\n \t      p->u.rsym.sym = gfc_new_symbol (p->u.rsym.true_name,\n \t\t\t\t\t      gfc_current_ns);\n-\t      p->u.rsym.sym->module = gfc_get_string (p->u.rsym.module);\n+\t      p->u.rsym.sym->module = gfc_get_string (\"%s\", p->u.rsym.module);\n \t    }\n \n \t  p->u.rsym.symtree->n.sym = p->u.rsym.sym;\n@@ -3531,7 +3532,7 @@ mio_expr (gfc_expr **ep)\n \t  if (atom_string[0] == '\\0')\n \t    e->value.function.name = NULL;\n \t  else\n-\t    e->value.function.name = gfc_get_string (atom_string);\n+\t    e->value.function.name = gfc_get_string (\"%s\", atom_string);\n \t  free (atom_string);\n \n \t  mio_integer (&flag);\n@@ -4166,13 +4167,13 @@ mio_omp_udr_expr (gfc_omp_udr *udr, gfc_symbol **sym1, gfc_symbol **sym2,\n       q->u.pointer = (void *) ns;\n       sym = gfc_new_symbol (is_initializer ? \"omp_priv\" : \"omp_out\", ns);\n       sym->ts = udr->ts;\n-      sym->module = gfc_get_string (p1->u.rsym.module);\n+      sym->module = gfc_get_string (\"%s\", p1->u.rsym.module);\n       associate_integer_pointer (p1, sym);\n       sym->attr.omp_udr_artificial_var = 1;\n       gcc_assert (p2->u.rsym.sym == NULL);\n       sym = gfc_new_symbol (is_initializer ? \"omp_orig\" : \"omp_in\", ns);\n       sym->ts = udr->ts;\n-      sym->module = gfc_get_string (p2->u.rsym.module);\n+      sym->module = gfc_get_string (\"%s\", p2->u.rsym.module);\n       associate_integer_pointer (p2, sym);\n       sym->attr.omp_udr_artificial_var = 1;\n       if (mio_name (0, omp_declare_reduction_stmt) == 0)\n@@ -4514,7 +4515,7 @@ load_generic_interfaces (void)\n \t      if (!sym)\n \t\t{\n \t\t  gfc_get_symbol (p, NULL, &sym);\n-\t\t  sym->name = gfc_get_string (name);\n+\t\t  sym->name = gfc_get_string (\"%s\", name);\n \t\t  sym->module = module_name;\n \t\t  sym->attr.flavor = FL_PROCEDURE;\n \t\t  sym->attr.generic = 1;\n@@ -4757,7 +4758,7 @@ load_omp_udrs (void)\n \t  memcpy (altname + 1, newname, len);\n \t  altname[len + 1] = '.';\n \t  altname[len + 2] = '\\0';\n-\t  name = gfc_get_string (altname);\n+\t  name = gfc_get_string (\"%s\", altname);\n \t}\n       st = gfc_find_symtree (gfc_current_ns->omp_udr_root, name);\n       gfc_omp_udr *udr = gfc_omp_udr_find (st, &ts);\n@@ -4859,7 +4860,7 @@ load_needed (pointer_info *p)\n \n       sym = gfc_new_symbol (p->u.rsym.true_name, ns);\n       sym->name = gfc_dt_lower_string (p->u.rsym.true_name);\n-      sym->module = gfc_get_string (p->u.rsym.module);\n+      sym->module = gfc_get_string (\"%s\", p->u.rsym.module);\n       if (p->u.rsym.binding_label)\n \tsym->binding_label = IDENTIFIER_POINTER (get_identifier\n \t\t\t\t\t\t (p->u.rsym.binding_label));\n@@ -5234,12 +5235,13 @@ read_module (void)\n \t\t\t\t\t\t     gfc_current_ns);\n \t\t  info->u.rsym.sym->name = gfc_dt_lower_string (info->u.rsym.true_name);\n \t\t  sym = info->u.rsym.sym;\n-\t\t  sym->module = gfc_get_string (info->u.rsym.module);\n+\t\t  sym->module = gfc_get_string (\"%s\", info->u.rsym.module);\n \n \t\t  if (info->u.rsym.binding_label)\n-\t\t    sym->binding_label =\n-\t\t      IDENTIFIER_POINTER (get_identifier\n-\t\t\t\t\t  (info->u.rsym.binding_label));\n+\t\t    {\n+\t\t      tree id = get_identifier (info->u.rsym.binding_label);\n+\t\t      sym->binding_label = IDENTIFIER_POINTER (id);\n+\t\t    }\n \t\t}\n \n \t      st->n.sym = sym;\n@@ -6045,7 +6047,7 @@ dump_module (const char *name, int dump_flag)\n   char *filename, *filename_tmp;\n   uLong crc, crc_old;\n \n-  module_name = gfc_get_string (name);\n+  module_name = gfc_get_string (\"%s\", name);\n \n   if (dump_smod)\n     {\n@@ -6210,7 +6212,7 @@ create_intrinsic_function (const char *name, int id,\n   sym->attr.flavor = FL_PROCEDURE;\n   sym->attr.intrinsic = 1;\n \n-  sym->module = gfc_get_string (modname);\n+  sym->module = gfc_get_string (\"%s\", modname);\n   sym->attr.use_assoc = 1;\n   sym->from_intmod = module;\n   sym->intmod_sym_id = id;\n@@ -6250,7 +6252,7 @@ import_iso_c_binding_module (void)\n \n       mod_sym->attr.flavor = FL_MODULE;\n       mod_sym->attr.intrinsic = 1;\n-      mod_sym->module = gfc_get_string (iso_c_module_name);\n+      mod_sym->module = gfc_get_string (\"%s\", iso_c_module_name);\n       mod_sym->from_intmod = INTMOD_ISO_C_BINDING;\n     }\n \n@@ -6508,7 +6510,7 @@ create_int_parameter (const char *name, int value, const char *modname,\n   gfc_get_sym_tree (name, gfc_current_ns, &tmp_symtree, false);\n   sym = tmp_symtree->n.sym;\n \n-  sym->module = gfc_get_string (modname);\n+  sym->module = gfc_get_string (\"%s\", modname);\n   sym->attr.flavor = FL_PARAMETER;\n   sym->ts.type = BT_INTEGER;\n   sym->ts.kind = gfc_default_integer_kind;\n@@ -6541,7 +6543,7 @@ create_int_parameter_array (const char *name, int size, gfc_expr *value,\n   gfc_get_sym_tree (name, gfc_current_ns, &tmp_symtree, false);\n   sym = tmp_symtree->n.sym;\n \n-  sym->module = gfc_get_string (modname);\n+  sym->module = gfc_get_string (\"%s\", modname);\n   sym->attr.flavor = FL_PARAMETER;\n   sym->ts.type = BT_INTEGER;\n   sym->ts.kind = gfc_default_integer_kind;\n@@ -6582,7 +6584,7 @@ create_derived_type (const char *name, const char *modname,\n \n   gfc_get_sym_tree (name, gfc_current_ns, &tmp_symtree, false);\n   sym = tmp_symtree->n.sym;\n-  sym->module = gfc_get_string (modname);\n+  sym->module = gfc_get_string (\"%s\", modname);\n   sym->from_intmod = module;\n   sym->intmod_sym_id = id;\n   sym->attr.flavor = FL_PROCEDURE;\n@@ -6592,12 +6594,12 @@ create_derived_type (const char *name, const char *modname,\n   gfc_get_sym_tree (gfc_dt_upper_string (sym->name),\n \t\t    gfc_current_ns, &tmp_symtree, false);\n   dt_sym = tmp_symtree->n.sym;\n-  dt_sym->name = gfc_get_string (sym->name);\n+  dt_sym->name = gfc_get_string (\"%s\", sym->name);\n   dt_sym->attr.flavor = FL_DERIVED;\n   dt_sym->attr.private_comp = 1;\n   dt_sym->attr.zero_comp = 1;\n   dt_sym->attr.use_assoc = 1;\n-  dt_sym->module = gfc_get_string (modname);\n+  dt_sym->module = gfc_get_string (\"%s\", modname);\n   dt_sym->from_intmod = module;\n   dt_sym->intmod_sym_id = id;\n \n@@ -6677,7 +6679,7 @@ use_iso_fortran_env_module (void)\n \n       mod_sym->attr.flavor = FL_MODULE;\n       mod_sym->attr.intrinsic = 1;\n-      mod_sym->module = gfc_get_string (mod);\n+      mod_sym->module = gfc_get_string (\"%s\", mod);\n       mod_sym->from_intmod = INTMOD_ISO_FORTRAN_ENV;\n     }\n   else"}, {"sha": "d19ee9483300f1a7f5ba1d10e06ef0d011d3bac3", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=51f03c6b11a46d756ae05c67e34cca2ccb4fafaa", "patch": "@@ -1025,12 +1025,8 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t      if (m == MATCH_YES)\n \t\t{\n \t\t  int collapse;\n-\t\t  const char *p = gfc_extract_int (cexpr, &collapse);\n-\t\t  if (p)\n-\t\t    {\n-\t\t      gfc_error_now (p);\n-\t\t      collapse = 1;\n-\t\t    }\n+\t\t  if (gfc_extract_int (cexpr, &collapse, -1))\n+\t\t    collapse = 1;\n \t\t  else if (collapse <= 0)\n \t\t    {\n \t\t      gfc_error_now (\"COLLAPSE clause argument not\"\n@@ -1485,12 +1481,8 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t      if (m == MATCH_YES)\n \t\t{\n \t\t  int ordered = 0;\n-\t\t  const char *p = gfc_extract_int (cexpr, &ordered);\n-\t\t  if (p)\n-\t\t    {\n-\t\t      gfc_error_now (p);\n-\t\t      ordered = 0;\n-\t\t    }\n+\t\t  if (gfc_extract_int (cexpr, &ordered, -1))\n+\t\t    ordered = 0;\n \t\t  else if (ordered <= 0)\n \t\t    {\n \t\t      gfc_error_now (\"ORDERED clause argument not\"\n@@ -2866,7 +2858,7 @@ gfc_match_omp_declare_reduction (void)\n       const char *predef_name = NULL;\n \n       omp_udr = gfc_get_omp_udr ();\n-      omp_udr->name = gfc_get_string (name);\n+      omp_udr->name = gfc_get_string (\"%s\", name);\n       omp_udr->rop = rop;\n       omp_udr->ts = tss[i];\n       omp_udr->where = where;"}, {"sha": "d7fc6c41b038df05eb65e2cd8d4ff9a8c85c8d8d", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=51f03c6b11a46d756ae05c67e34cca2ccb4fafaa", "patch": "@@ -41,7 +41,6 @@ match_kind_param (int *kind, int *is_iso_c)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_symbol *sym;\n-  const char *p;\n   match m;\n \n   *is_iso_c = 0;\n@@ -68,8 +67,7 @@ match_kind_param (int *kind, int *is_iso_c)\n   if (sym->value == NULL)\n     return MATCH_NO;\n \n-  p = gfc_extract_int (sym->value, kind);\n-  if (p != NULL)\n+  if (gfc_extract_int (sym->value, kind))\n     return MATCH_NO;\n \n   gfc_set_sym_referenced (sym);\n@@ -257,7 +255,6 @@ match_hollerith_constant (gfc_expr **result)\n {\n   locus old_loc;\n   gfc_expr *e = NULL;\n-  const char *msg;\n   int num, pad;\n   int i;\n \n@@ -270,12 +267,8 @@ match_hollerith_constant (gfc_expr **result)\n       if (!gfc_notify_std (GFC_STD_LEGACY, \"Hollerith constant at %C\"))\n \tgoto cleanup;\n \n-      msg = gfc_extract_int (e, &num);\n-      if (msg != NULL)\n-\t{\n-\t  gfc_error (msg);\n-\t  goto cleanup;\n-\t}\n+      if (gfc_extract_int (e, &num, 1))\n+\tgoto cleanup;\n       if (num == 0)\n \t{\n \t  gfc_error (\"Invalid Hollerith constant: %L must contain at least \"\n@@ -1017,7 +1010,6 @@ match_string_constant (gfc_expr **result)\n   locus old_locus, start_locus;\n   gfc_symbol *sym;\n   gfc_expr *e;\n-  const char *q;\n   match m;\n   gfc_char_t c, delimiter, *p;\n \n@@ -1082,12 +1074,8 @@ match_string_constant (gfc_expr **result)\n \n   if (kind == -1)\n     {\n-      q = gfc_extract_int (sym->value, &kind);\n-      if (q != NULL)\n-\t{\n-\t  gfc_error (q);\n-\t  return MATCH_ERROR;\n-\t}\n+      if (gfc_extract_int (sym->value, &kind, 1))\n+\treturn MATCH_ERROR;\n       gfc_set_sym_referenced (sym);\n     }\n \n@@ -1659,7 +1647,7 @@ match_keyword_arg (gfc_actual_arglist *actual, gfc_actual_arglist *base)\n \t  }\n     }\n \n-  actual->name = gfc_get_string (name);\n+  actual->name = gfc_get_string (\"%s\", name);\n   return MATCH_YES;\n \n cleanup:"}, {"sha": "8ffe75a4a4648f8796d5703550ba4a778c847f45", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=51f03c6b11a46d756ae05c67e34cca2ccb4fafaa", "patch": "@@ -127,7 +127,7 @@ get_kind (bt type, gfc_expr *k, const char *name, int default_kind)\n       return -1;\n     }\n \n-  if (gfc_extract_int (k, &kind) != NULL\n+  if (gfc_extract_int (k, &kind)\n       || gfc_validate_kind (type, kind, true) < 0)\n     {\n       gfc_error (\"Invalid KIND parameter of %s at %L\", name, &k->where);\n@@ -1499,7 +1499,7 @@ gfc_simplify_btest (gfc_expr *e, gfc_expr *bit)\n   if (e->expr_type != EXPR_CONSTANT || bit->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n-  if (gfc_extract_int (bit, &b) != NULL || b < 0)\n+  if (gfc_extract_int (bit, &b) || b < 0)\n     return gfc_get_logical_expr (gfc_default_logical_kind, &e->where, false);\n \n   return gfc_get_logical_expr (gfc_default_logical_kind, &e->where,\n@@ -4234,7 +4234,6 @@ gfc_simplify_maskr (gfc_expr *i, gfc_expr *kind_arg)\n {\n   gfc_expr *result;\n   int kind, arg, k;\n-  const char *s;\n \n   if (i->expr_type != EXPR_CONSTANT)\n     return NULL;\n@@ -4244,8 +4243,8 @@ gfc_simplify_maskr (gfc_expr *i, gfc_expr *kind_arg)\n     return &gfc_bad_expr;\n   k = gfc_validate_kind (BT_INTEGER, kind, false);\n \n-  s = gfc_extract_int (i, &arg);\n-  gcc_assert (!s);\n+  bool fail = gfc_extract_int (i, &arg);\n+  gcc_assert (!fail);\n \n   result = gfc_get_constant_expr (BT_INTEGER, kind, &i->where);\n \n@@ -4265,7 +4264,6 @@ gfc_simplify_maskl (gfc_expr *i, gfc_expr *kind_arg)\n {\n   gfc_expr *result;\n   int kind, arg, k;\n-  const char *s;\n   mpz_t z;\n \n   if (i->expr_type != EXPR_CONSTANT)\n@@ -4276,8 +4274,8 @@ gfc_simplify_maskl (gfc_expr *i, gfc_expr *kind_arg)\n     return &gfc_bad_expr;\n   k = gfc_validate_kind (BT_INTEGER, kind, false);\n \n-  s = gfc_extract_int (i, &arg);\n-  gcc_assert (!s);\n+  bool fail = gfc_extract_int (i, &arg);\n+  gcc_assert (!fail);\n \n   result = gfc_get_constant_expr (BT_INTEGER, kind, &i->where);\n \n@@ -5060,7 +5058,6 @@ gfc_expr *\n gfc_simplify_poppar (gfc_expr *e)\n {\n   gfc_expr *popcnt;\n-  const char *s;\n   int i;\n \n   if (e->expr_type != EXPR_CONSTANT)\n@@ -5069,8 +5066,8 @@ gfc_simplify_poppar (gfc_expr *e)\n   popcnt = gfc_simplify_popcnt (e);\n   gcc_assert (popcnt);\n \n-  s = gfc_extract_int (popcnt, &i);\n-  gcc_assert (!s);\n+  bool fail = gfc_extract_int (popcnt, &i);\n+  gcc_assert (!fail);\n \n   return gfc_get_int_expr (gfc_default_integer_kind, &e->where, i % 2);\n }\n@@ -5282,8 +5279,8 @@ gfc_simplify_repeat (gfc_expr *e, gfc_expr *n)\n       (e->ts.u.cl->length &&\n        mpz_sgn (e->ts.u.cl->length->value.integer) != 0))\n     {\n-      const char *res = gfc_extract_int (n, &ncop);\n-      gcc_assert (res == NULL);\n+      bool fail = gfc_extract_int (n, &ncop);\n+      gcc_assert (!fail);\n     }\n   else\n     ncop = 0;\n@@ -5693,7 +5690,7 @@ gfc_simplify_selected_int_kind (gfc_expr *e)\n {\n   int i, kind, range;\n \n-  if (e->expr_type != EXPR_CONSTANT || gfc_extract_int (e, &range) != NULL)\n+  if (e->expr_type != EXPR_CONSTANT || gfc_extract_int (e, &range))\n     return NULL;\n \n   kind = INT_MAX;\n@@ -5722,7 +5719,7 @@ gfc_simplify_selected_real_kind (gfc_expr *p, gfc_expr *q, gfc_expr *rdx)\n   else\n     {\n       if (p->expr_type != EXPR_CONSTANT\n-\t  || gfc_extract_int (p, &precision) != NULL)\n+\t  || gfc_extract_int (p, &precision))\n \treturn NULL;\n       loc = &p->where;\n     }\n@@ -5732,7 +5729,7 @@ gfc_simplify_selected_real_kind (gfc_expr *p, gfc_expr *q, gfc_expr *rdx)\n   else\n     {\n       if (q->expr_type != EXPR_CONSTANT\n-\t  || gfc_extract_int (q, &range) != NULL)\n+\t  || gfc_extract_int (q, &range))\n \treturn NULL;\n \n       if (!loc)\n@@ -5744,7 +5741,7 @@ gfc_simplify_selected_real_kind (gfc_expr *p, gfc_expr *q, gfc_expr *rdx)\n   else\n     {\n       if (rdx->expr_type != EXPR_CONSTANT\n-\t  || gfc_extract_int (rdx, &radix) != NULL)\n+\t  || gfc_extract_int (rdx, &radix))\n \treturn NULL;\n \n       if (!loc)"}, {"sha": "9afa6d029f322729ea53e9b290a62dce6557359e", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=51f03c6b11a46d756ae05c67e34cca2ccb4fafaa", "patch": "@@ -2149,7 +2149,7 @@ gfc_add_component (gfc_symbol *sym, const char *name,\n   else\n     tail->next = p;\n \n-  p->name = gfc_get_string (name);\n+  p->name = gfc_get_string (\"%s\", name);\n   p->loc = gfc_current_locus;\n   p->ts.type = BT_UNKNOWN;\n \n@@ -2756,7 +2756,7 @@ gfc_new_symtree (gfc_symtree **root, const char *name)\n   gfc_symtree *st;\n \n   st = XCNEW (gfc_symtree);\n-  st->name = gfc_get_string (name);\n+  st->name = gfc_get_string (\"%s\", name);\n \n   gfc_insert_bbt (root, st, compare_symtree);\n   return st;\n@@ -2772,7 +2772,7 @@ gfc_delete_symtree (gfc_symtree **root, const char *name)\n \n   st0 = gfc_find_symtree (*root, name);\n \n-  st.name = gfc_get_string (name);\n+  st.name = gfc_get_string (\"%s\", name);\n   gfc_delete_bbt (root, &st, compare_symtree);\n \n   free (st0);\n@@ -2834,7 +2834,7 @@ gfc_get_uop (const char *name)\n   st = gfc_new_symtree (&ns->uop_root, name);\n \n   uop = st->n.uop = XCNEW (gfc_user_op);\n-  uop->name = gfc_get_string (name);\n+  uop->name = gfc_get_string (\"%s\", name);\n   uop->access = ACCESS_UNKNOWN;\n   uop->ns = ns;\n \n@@ -2955,7 +2955,7 @@ gfc_new_symbol (const char *name, gfc_namespace *ns)\n   if (strlen (name) > GFC_MAX_SYMBOL_LEN)\n     gfc_internal_error (\"new_symbol(): Symbol name too long\");\n \n-  p->name = gfc_get_string (name);\n+  p->name = gfc_get_string (\"%s\", name);\n \n   /* Make sure flags for symbol being C bound are clear initially.  */\n   p->attr.is_bind_c = 0;\n@@ -4146,7 +4146,7 @@ gfc_get_gsymbol (const char *name)\n \n   s = XCNEW (gfc_gsymbol);\n   s->type = GSYM_UNKNOWN;\n-  s->name = gfc_get_string (name);\n+  s->name = gfc_get_string (\"%s\", name);\n \n   gfc_insert_bbt (&gfc_gsym_root, s, gsym_compare);\n \n@@ -4609,7 +4609,7 @@ generate_isocbinding_symbol (const char *mod_name, iso_c_binding_symbol s,\n     }\n \n   /* Say what module this symbol belongs to.  */\n-  tmp_sym->module = gfc_get_string (mod_name);\n+  tmp_sym->module = gfc_get_string (\"%s\", mod_name);\n   tmp_sym->from_intmod = INTMOD_ISO_C_BINDING;\n   tmp_sym->intmod_sym_id = s;\n   tmp_sym->attr.is_iso_c = 1;\n@@ -4706,7 +4706,7 @@ generate_isocbinding_symbol (const char *mod_name, iso_c_binding_symbol s,\n \t      gfc_get_sym_tree (hidden_name, gfc_current_ns, &tmp_symtree, false);\n \t      dt_sym = tmp_symtree->n.sym;\n \t      dt_sym->name = gfc_get_string (s == ISOCBINDING_PTR\n-\t\t\t\t\t    ? \"c_ptr\" : \"c_funptr\");\n+\t\t\t\t\t     ? \"c_ptr\" : \"c_funptr\");\n \n \t      /* Generate an artificial generic function.  */\n \t      head = tmp_sym->generic;\n@@ -4726,7 +4726,7 @@ generate_isocbinding_symbol (const char *mod_name, iso_c_binding_symbol s,\n \t    }\n \n \t  /* Say what module this symbol belongs to.  */\n-\t  dt_sym->module = gfc_get_string (mod_name);\n+\t  dt_sym->module = gfc_get_string (\"%s\", mod_name);\n \t  dt_sym->from_intmod = INTMOD_ISO_C_BINDING;\n \t  dt_sym->intmod_sym_id = s;\n           dt_sym->attr.use_assoc = 1;"}, {"sha": "3e54e80a69a3b14711ca903a6dcc641a6db6b000", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=51f03c6b11a46d756ae05c67e34cca2ccb4fafaa", "patch": "@@ -4649,7 +4649,7 @@ gfc_find_module (const char *name)\n     {\n       module_htab_entry *entry = ggc_cleared_alloc<module_htab_entry> ();\n \n-      entry->name = gfc_get_string (name);\n+      entry->name = gfc_get_string (\"%s\", name);\n       entry->decls = hash_table<module_decl_hasher>::create_ggc (10);\n       *slot = entry;\n     }"}, {"sha": "ad4b7373a215b0506fce26bb239291b3806fda47", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51f03c6b11a46d756ae05c67e34cca2ccb4fafaa/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=51f03c6b11a46d756ae05c67e34cca2ccb4fafaa", "patch": "@@ -5883,8 +5883,8 @@ gfc_trans_allocate (gfc_code * code)\n \t  newsym = XCNEW (gfc_symtree);\n \t  /* The name of the symtree should be unique, because gfc_create_var ()\n \t     took care about generating the identifier.  */\n-\t  newsym->name = gfc_get_string (IDENTIFIER_POINTER (\n-\t\t\t\t\t\t\t    DECL_NAME (expr3)));\n+\t  newsym->name\n+\t    = gfc_get_string (\"%s\", IDENTIFIER_POINTER (DECL_NAME (expr3)));\n \t  newsym->n.sym = gfc_new_symbol (newsym->name, NULL);\n \t  /* The backend_decl is known.  It is expr3, which is inserted\n \t     here.  */"}]}