{"sha": "9eba0801b6256850a254f51713ee780037ef9b0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWViYTA4MDFiNjI1Njg1MGEyNTRmNTE3MTNlZTc4MDAzN2VmOWIwZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-08-11T08:52:58Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-08-11T08:52:58Z"}, "message": "reload.c (push_secondary_reload): When invoking a reload_{in,out} pattern...\n\n        * reload.c (push_secondary_reload): When invoking a reload_{in,out}\n        pattern, always allocate a tertiary scratch register.\n\n        * config/alpha/alpha.md (reload_inqi): Use a DImode scratch.\n        (reload_inhi): Likewise.\n\nFrom-SVN: r35626", "tree": {"sha": "b9bbd99999019a1c1eaf2326e11ca5a7fcb9af65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9bbd99999019a1c1eaf2326e11ca5a7fcb9af65"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9eba0801b6256850a254f51713ee780037ef9b0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eba0801b6256850a254f51713ee780037ef9b0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9eba0801b6256850a254f51713ee780037ef9b0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eba0801b6256850a254f51713ee780037ef9b0d/comments", "author": null, "committer": null, "parents": [{"sha": "8b4944fbce62beaf05ffeb0ac734d2b40bd5af80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b4944fbce62beaf05ffeb0ac734d2b40bd5af80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b4944fbce62beaf05ffeb0ac734d2b40bd5af80"}], "stats": {"total": 79, "additions": 32, "deletions": 47}, "files": [{"sha": "06a4ffac3465179eca461357c623cfedaab5a584", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eba0801b6256850a254f51713ee780037ef9b0d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eba0801b6256850a254f51713ee780037ef9b0d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9eba0801b6256850a254f51713ee780037ef9b0d", "patch": "@@ -1,3 +1,11 @@\n+2000-08-11  Richard Henderson  <rth@cygnus.com>\n+\n+\t* reload.c (push_secondary_reload): When invoking a reload_{in,out}\n+\tpattern, always allocate a tertiary scratch register.\n+\n+\t* config/alpha/alpha.md (reload_inqi): Use a DImode scratch.\n+\t(reload_inhi): Likewise.\n+\n 2000-08-11  Richard Henderson  <rth@cygnus.com>\n \n \t* function.c (put_reg_into_stack): Allow type to be NULL."}, {"sha": "a869185de91daf992bd60f941ed539f7f9f855c1", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eba0801b6256850a254f51713ee780037ef9b0d/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eba0801b6256850a254f51713ee780037ef9b0d/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=9eba0801b6256850a254f51713ee780037ef9b0d", "patch": "@@ -5343,11 +5343,11 @@\n (define_expand \"reload_inqi\"\n   [(parallel [(match_operand:QI 0 \"register_operand\" \"=r\")\n \t      (match_operand:QI 1 \"any_memory_operand\" \"m\")\n-\t      (match_operand:TI 2 \"register_operand\" \"=&r\")])]\n+\t      (match_operand:DI 2 \"register_operand\" \"=&r\")])]\n   \"! TARGET_BWX\"\n   \"\n {\n-  rtx scratch, seq;\n+  rtx seq;\n \n   if (GET_CODE (operands[1]) != MEM)\n     abort ();\n@@ -5361,16 +5361,8 @@\n     {\n       rtx addr;\n \n-      /* It is possible that one of the registers we got for operands[2]\n-\t might coincide with that of operands[0] (which is why we made\n-\t it TImode).  Pick the other one to use as our scratch.  */\n-      if (REGNO (operands[0]) == REGNO (operands[2]))\n-\tscratch = gen_rtx_REG (DImode, REGNO (operands[2]) + 1);\n-      else\n-\tscratch = gen_rtx_REG (DImode, REGNO (operands[2]));\n-\n       addr = get_unaligned_address (operands[1], 0);\n-      seq = gen_unaligned_loadqi (operands[0], addr, scratch,\n+      seq = gen_unaligned_loadqi (operands[0], addr, operands[2],\n \t\t\t  gen_rtx_REG (DImode, REGNO (operands[0])));\n       alpha_set_memflags (seq, operands[1]);\n     }\n@@ -5381,11 +5373,11 @@\n (define_expand \"reload_inhi\"\n   [(parallel [(match_operand:HI 0 \"register_operand\" \"=r\")\n \t      (match_operand:HI 1 \"any_memory_operand\" \"m\")\n-\t      (match_operand:TI 2 \"register_operand\" \"=&r\")])]\n+\t      (match_operand:DI 2 \"register_operand\" \"=&r\")])]\n   \"! TARGET_BWX\"\n   \"\n {\n-  rtx scratch, seq;\n+  rtx seq;\n \n   if (GET_CODE (operands[1]) != MEM)\n     abort ();\n@@ -5399,16 +5391,8 @@\n     {\n       rtx addr;\n \n-      /* It is possible that one of the registers we got for operands[2]\n-\t might coincide with that of operands[0] (which is why we made\n-\t it TImode).  Pick the other one to use as our scratch.  */\n-      if (REGNO (operands[0]) == REGNO (operands[2]))\n-\tscratch = gen_rtx_REG (DImode, REGNO (operands[2]) + 1);\n-      else\n-\tscratch = gen_rtx_REG (DImode, REGNO (operands[2]));\n-\n       addr = get_unaligned_address (operands[1], 0);\n-      seq = gen_unaligned_loadhi (operands[0], addr, scratch,\n+      seq = gen_unaligned_loadhi (operands[0], addr, operands[2],\n \t\t\t  gen_rtx_REG (DImode, REGNO (operands[0])));\n       alpha_set_memflags (seq, operands[1]);\n     }"}, {"sha": "57c1b852cb9c804fcc02ed33363ab8e85b411540", "filename": "gcc/reload.c", "status": "modified", "additions": 18, "deletions": 25, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eba0801b6256850a254f51713ee780037ef9b0d/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eba0801b6256850a254f51713ee780037ef9b0d/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=9eba0801b6256850a254f51713ee780037ef9b0d", "patch": "@@ -375,32 +375,26 @@ push_secondary_reload (in_p, x, opnum, optional, reload_class, reload_mode,\n \t in operand 1.  Outputs should have an initial \"=\", which we must\n \t skip.  */\n \n-      char insn_letter\n-\t= insn_data[(int) icode].operand[!in_p].constraint[in_p];\n-      enum reg_class insn_class\n-\t= (insn_letter == 'r' ? GENERAL_REGS\n-\t   : REG_CLASS_FROM_LETTER ((unsigned char) insn_letter));\n+      char insn_letter, t_letter;\n \n-      if (insn_class == NO_REGS\n+      insn_letter = insn_data[(int) icode].operand[!in_p].constraint[in_p];\n+      class = (insn_letter == 'r' ? GENERAL_REGS\n+\t       : REG_CLASS_FROM_LETTER ((unsigned char) insn_letter));\n+\n+      if (class == NO_REGS\n \t  || (in_p\n \t      && insn_data[(int) icode].operand[!in_p].constraint[0] != '=')\n \t  /* The scratch register's constraint must start with \"=&\".  */\n \t  || insn_data[(int) icode].operand[2].constraint[0] != '='\n \t  || insn_data[(int) icode].operand[2].constraint[1] != '&')\n \tabort ();\n \n-      if (reg_class_subset_p (reload_class, insn_class))\n-\tmode = insn_data[(int) icode].operand[2].mode;\n-      else\n-\t{\n-\t  char t_letter = insn_data[(int) icode].operand[2].constraint[2];\n-\t  class = insn_class;\n-\t  t_mode = insn_data[(int) icode].operand[2].mode;\n-\t  t_class = (t_letter == 'r' ? GENERAL_REGS\n-\t\t     : REG_CLASS_FROM_LETTER ((unsigned char) t_letter));\n-\t  t_icode = icode;\n-\t  icode = CODE_FOR_nothing;\n-\t}\n+      t_letter = insn_data[(int) icode].operand[2].constraint[2];\n+      t_mode = insn_data[(int) icode].operand[2].mode;\n+      t_class = (t_letter == 'r' ? GENERAL_REGS\n+\t\t : REG_CLASS_FROM_LETTER ((unsigned char) t_letter));\n+      t_icode = icode;\n+      icode = CODE_FOR_nothing;\n     }\n \n   /* This case isn't valid, so fail.  Reload is allowed to use the same\n@@ -410,15 +404,14 @@ push_secondary_reload (in_p, x, opnum, optional, reload_class, reload_mode,\n      silently generating incorrect code later.\n \n      The convention is that secondary input reloads are valid only if the\n-     secondary_class is different from class.  If you have such a case, you\n-     can not use secondary reloads, you must work around the problem some\n-     other way.\n+     secondary class is different from the reload class.  If you have such\n+     a case, you can not use secondary reloads, you must work around the\n+     problem some other way.\n \n-     Allow this when MODE is not reload_mode and assume that the generated\n-     code handles this case (it does on the Alpha, which is the only place\n-     this currently happens).  */\n+     Allow this when a tertiary reload is used; i.e. assume that the\n+     generated code handles this case.  */\n \n-  if (in_p && class == reload_class && mode == reload_mode)\n+  if (in_p && class == reload_class && t_class == NO_REGS)\n     abort ();\n \n   /* If we need a tertiary reload, see if we have one we can reuse or else"}]}