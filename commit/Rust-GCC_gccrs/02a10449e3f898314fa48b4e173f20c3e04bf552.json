{"sha": "02a10449e3f898314fa48b4e173f20c3e04bf552", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJhMTA0NDllM2Y4OTgzMTRmYTQ4YjRlMTczZjIwYzNlMDRiZjU1Mg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-05T22:37:11Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-05T22:37:11Z"}, "message": "(fixup_var_refs_insns): If SMALL_REGISTER_CLASSES...\n\n(fixup_var_refs_insns): If SMALL_REGISTER_CLASSES, ensure we don't put\nany insns between the setting of the function return register and it's use.\n\nFrom-SVN: r3660", "tree": {"sha": "9317f96e8daf2ef4f03ef1c5bd8a935a9e58e6a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9317f96e8daf2ef4f03ef1c5bd8a935a9e58e6a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02a10449e3f898314fa48b4e173f20c3e04bf552", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02a10449e3f898314fa48b4e173f20c3e04bf552", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02a10449e3f898314fa48b4e173f20c3e04bf552", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02a10449e3f898314fa48b4e173f20c3e04bf552/comments", "author": null, "committer": null, "parents": [{"sha": "c2ae03cb30827d0d28c78db0302b77824e3a4f2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2ae03cb30827d0d28c78db0302b77824e3a4f2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2ae03cb30827d0d28c78db0302b77824e3a4f2e"}], "stats": {"total": 45, "additions": 42, "deletions": 3}, "files": [{"sha": "cc288841974a97e8a04e0831cb17b14a5a4cdccc", "filename": "gcc/function.c", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02a10449e3f898314fa48b4e173f20c3e04bf552/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02a10449e3f898314fa48b4e173f20c3e04bf552/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=02a10449e3f898314fa48b4e173f20c3e04bf552", "patch": "@@ -999,6 +999,8 @@ fixup_var_refs_insns (var, promoted_mode, unsignedp, insn, toplevel)\n      rtx insn;\n      int toplevel;\n {\n+  rtx call_dest = 0;\n+\n   while (insn)\n     {\n       rtx next = NEXT_INSN (insn);\n@@ -1022,6 +1024,46 @@ fixup_var_refs_insns (var, promoted_mode, unsignedp, insn, toplevel)\n \t    }\n \t  else\n \t    {\n+\t      struct fixup_replacement *replacements = 0;\n+\t      rtx next_insn = NEXT_INSN (insn);\n+\n+#ifdef SMALL_REGISTER_CLASSES\n+\t      /* If the insn that copies the results of a CALL_INSN\n+\t\t into a pseudo now references VAR, we have to use an\n+\t\t intermediate pseudo since we want the life of the\n+\t\t return value register to be only a single insn.\n+\n+\t\t If we don't use an intermediate pseudo, such things as\n+\t\t address computations to make the address of VAR valid\n+\t\t if it is not can be placed beween the CALL_INSN and INSN.\n+\n+\t\t To make sure this doesn't happen, we record the destination\n+\t\t of the CALL_INSN and see if the next insn uses both that\n+\t\t and VAR.  */\n+\n+\t      if (call_dest != 0 && GET_CODE (insn) == INSN\n+\t\t  && reg_mentioned_p (var, PATTERN (insn))\n+\t\t  && reg_mentioned_p (call_dest, PATTERN (insn)))\n+\t\t{\n+\t\t  rtx temp = gen_reg_rtx (GET_MODE (call_dest));\n+\n+\t\t  emit_insn_before (gen_move_insn (temp, call_dest), insn);\n+\n+\t\t  PATTERN (insn) = replace_rtx (PATTERN (insn),\n+\t\t\t\t\t\tcall_dest, temp);\n+\t\t}\n+\t      \n+\t      if (GET_CODE (insn) == CALL_INSN\n+\t\t  && GET_CODE (PATTERN (insn)) == SET)\n+\t\tcall_dest = SET_DEST (PATTERN (insn));\n+\t      else if (GET_CODE (insn) == CALL_INSN\n+\t\t       && GET_CODE (PATTERN (insn)) == PARALLEL\n+\t\t       && GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == SET)\n+\t\tcall_dest = SET_DEST (XVECEXP (PATTERN (insn), 0, 0));\n+\t      else\n+\t\tcall_dest = 0;\n+#endif\n+\n \t      /* See if we have to do anything to INSN now that VAR is in\n \t\t memory.  If it needs to be loaded into a pseudo, use a single\n \t\t pseudo for the entire insn in case there is a MATCH_DUP\n@@ -1033,9 +1075,6 @@ fixup_var_refs_insns (var, promoted_mode, unsignedp, insn, toplevel)\n \t\t If it allocated a pseudo for any replacement, we copy into\n \t\t it here.  */\n \n-\t      struct fixup_replacement *replacements = 0;\n-\t      rtx next_insn = NEXT_INSN (insn);\n-\n \t      fixup_var_refs_1 (var, promoted_mode, &PATTERN (insn), insn,\n \t\t\t\t&replacements);\n "}]}