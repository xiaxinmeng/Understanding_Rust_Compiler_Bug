{"sha": "246a2fcb5ebf059b9761cec0d0d4b7c0c1147f17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQ2YTJmY2I1ZWJmMDU5Yjk3NjFjZWMwZDBkNGI3YzBjMTE0N2YxNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2010-08-21T19:05:40Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2010-08-21T19:05:40Z"}, "message": "Vectorize fast path of _cpp_clean_line.\n\n\t* configure.ac (AC_C_BIGENDIAN, AC_TYPE_UINTPTR_T): New tests.\n\t(ssize_t): Check via AC_TYPE_SSIZE_T instead of AC_CHECK_TYPE.\n\t(ptrdiff_t): Check via AC_CHECK_TYPE.\n\t* config.in, configure: Rebuild.\n\t* system.h: Include stdint.h, if available.\n\t* lex.c (WORDS_BIGENDIAN): Provide default.\n\t(acc_char_mask_misalign, acc_char_replicate, acc_char_cmp,\n\tacc_char_index, search_line_acc_char, repl_chars, search_line_mmx,\n\tsearch_line_sse2, search_line_sse42, init_vectorized_lexer,\n\tsearch_line_fast): New.\n\t(_cpp_clean_line): Use search_line_fast.  Restructure the fast\n\tloop to make it clear when we're leaving the loop.  Stay in the\n\tfast loop for non-trigraph '?'.\n\nCo-Authored-By: Andi Kleen <ak@linux.intel.com>\nCo-Authored-By: David S. Miller <davem@davemloft.net>\n\nFrom-SVN: r163446", "tree": {"sha": "be59d009f746b778dfd3ea463d4b4b994b456230", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be59d009f746b778dfd3ea463d4b4b994b456230"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/246a2fcb5ebf059b9761cec0d0d4b7c0c1147f17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/246a2fcb5ebf059b9761cec0d0d4b7c0c1147f17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/246a2fcb5ebf059b9761cec0d0d4b7c0c1147f17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/246a2fcb5ebf059b9761cec0d0d4b7c0c1147f17/comments", "author": null, "committer": null, "parents": [{"sha": "1d0134b3ccdc7e224f89540f05898742b13fecf9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d0134b3ccdc7e224f89540f05898742b13fecf9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d0134b3ccdc7e224f89540f05898742b13fecf9"}], "stats": {"total": 1052, "additions": 953, "deletions": 99}, "files": [{"sha": "25706ef3cd1612c22cb1288aff715a63552bb9a5", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/246a2fcb5ebf059b9761cec0d0d4b7c0c1147f17/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/246a2fcb5ebf059b9761cec0d0d4b7c0c1147f17/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=246a2fcb5ebf059b9761cec0d0d4b7c0c1147f17", "patch": "@@ -1,3 +1,21 @@\n+2010-08-21  Richard Henderson  <rth@redhat.com>\n+\t    Andi Kleen <ak@linux.intel.com>\n+\t    David S. Miller  <davem@davemloft.net>\n+\n+\t* configure.ac (AC_C_BIGENDIAN, AC_TYPE_UINTPTR_T): New tests.\n+\t(ssize_t): Check via AC_TYPE_SSIZE_T instead of AC_CHECK_TYPE.\n+\t(ptrdiff_t): Check via AC_CHECK_TYPE.\n+\t* config.in, configure: Rebuild.\n+\t* system.h: Include stdint.h, if available.\n+\t* lex.c (WORDS_BIGENDIAN): Provide default.\n+\t(acc_char_mask_misalign, acc_char_replicate, acc_char_cmp,\n+\tacc_char_index, search_line_acc_char, repl_chars, search_line_mmx,\n+\tsearch_line_sse2, search_line_sse42, init_vectorized_lexer,\n+\tsearch_line_fast): New.\n+\t(_cpp_clean_line): Use search_line_fast.  Restructure the fast\n+\tloop to make it clear when we're leaving the loop.  Stay in the\n+\tfast loop for non-trigraph '?'.\n+\n 2010-06-11  Jakub Jelinek  <jakub@redhat.com>\n \n \t* include/cpplib.h (struct cpp_callbacks): Add user_builtin_macro"}, {"sha": "95606c18abf352994b103ca01062b8d4c2a97221", "filename": "libcpp/config.in", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/246a2fcb5ebf059b9761cec0d0d4b7c0c1147f17/libcpp%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/246a2fcb5ebf059b9761cec0d0d4b7c0c1147f17/libcpp%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fconfig.in?ref=246a2fcb5ebf059b9761cec0d0d4b7c0c1147f17", "patch": "@@ -1,5 +1,8 @@\n /* config.in.  Generated from configure.ac by autoheader.  */\n \n+/* Define if building universal (internal helper macro) */\n+#undef AC_APPLE_UNIVERSAL_BUILD\n+\n /* Define to one of `_getb67', `GETB67', `getb67' for Cray-2 and Cray-YMP\n    systems. This function is required for `alloca.c' support on those systems.\n    */\n@@ -209,6 +212,9 @@\n /* Define if <sys/types.h> defines \\`uchar'. */\n #undef HAVE_UCHAR\n \n+/* Define to 1 if the system has the type `uintptr_t'. */\n+#undef HAVE_UINTPTR_T\n+\n /* Define to 1 if you have the <unistd.h> header file. */\n #undef HAVE_UNISTD_H\n \n@@ -266,6 +272,18 @@\n /* Define to 1 if your <sys/time.h> declares `struct tm'. */\n #undef TM_IN_SYS_TIME\n \n+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n+   significant byte first (like Motorola and SPARC, unlike Intel). */\n+#if defined AC_APPLE_UNIVERSAL_BUILD\n+# if defined __BIG_ENDIAN__\n+#  define WORDS_BIGENDIAN 1\n+# endif\n+#else\n+# ifndef WORDS_BIGENDIAN\n+#  undef WORDS_BIGENDIAN\n+# endif\n+#endif\n+\n /* Define to empty if `const' does not conform to ANSI C. */\n #undef const\n \n@@ -278,8 +296,15 @@\n /* Define to `long int' if <sys/types.h> does not define. */\n #undef off_t\n \n+/* Define to `int' if <sys/types.h> does not define. */\n+#undef ptrdiff_t\n+\n /* Define to `unsigned int' if <sys/types.h> does not define. */\n #undef size_t\n \n /* Define to `int' if <sys/types.h> does not define. */\n #undef ssize_t\n+\n+/* Define to the type of an unsigned integer type wide enough to hold a\n+   pointer, if such a type exists, and if the system does not define it. */\n+#undef uintptr_t"}, {"sha": "a2ce1c3a70a15787b437d3f055d484ef2723bd5a", "filename": "libcpp/configure", "status": "modified", "additions": 314, "deletions": 42, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/246a2fcb5ebf059b9761cec0d0d4b7c0c1147f17/libcpp%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/246a2fcb5ebf059b9761cec0d0d4b7c0c1147f17/libcpp%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fconfigure?ref=246a2fcb5ebf059b9761cec0d0d4b7c0c1147f17", "patch": "@@ -1846,6 +1846,48 @@ fi\n \n } # ac_fn_cxx_check_header_mongrel\n \n+# ac_fn_cxx_try_run LINENO\n+# ------------------------\n+# Try to link conftest.$ac_ext, and return whether this succeeded. Assumes\n+# that executables *can* be run.\n+ac_fn_cxx_try_run ()\n+{\n+  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n+  if { { ac_try=\"$ac_link\"\n+case \"(($ac_try\" in\n+  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n+  *) ac_try_echo=$ac_try;;\n+esac\n+eval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\n+$as_echo \"$ac_try_echo\"; } >&5\n+  (eval \"$ac_link\") 2>&5\n+  ac_status=$?\n+  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n+  test $ac_status = 0; } && { ac_try='./conftest$ac_exeext'\n+  { { case \"(($ac_try\" in\n+  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n+  *) ac_try_echo=$ac_try;;\n+esac\n+eval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\n+$as_echo \"$ac_try_echo\"; } >&5\n+  (eval \"$ac_try\") 2>&5\n+  ac_status=$?\n+  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n+  test $ac_status = 0; }; }; then :\n+  ac_retval=0\n+else\n+  $as_echo \"$as_me: program exited with status $ac_status\" >&5\n+       $as_echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+       ac_retval=$ac_status\n+fi\n+  rm -rf conftest.dSYM conftest_ipa8_conftest.oo\n+  eval $as_lineno_stack; test \"x$as_lineno_stack\" = x && { as_lineno=; unset as_lineno;}\n+  return $ac_retval\n+\n+} # ac_fn_cxx_try_run\n+\n # ac_fn_cxx_try_link LINENO\n # -------------------------\n # Try to link conftest.$ac_ext, and return whether this succeeded.\n@@ -1946,48 +1988,6 @@ $as_echo \"$ac_res\" >&6; }\n \n } # ac_fn_cxx_check_type\n \n-# ac_fn_cxx_try_run LINENO\n-# ------------------------\n-# Try to link conftest.$ac_ext, and return whether this succeeded. Assumes\n-# that executables *can* be run.\n-ac_fn_cxx_try_run ()\n-{\n-  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n-  if { { ac_try=\"$ac_link\"\n-case \"(($ac_try\" in\n-  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n-  *) ac_try_echo=$ac_try;;\n-esac\n-eval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\n-$as_echo \"$ac_try_echo\"; } >&5\n-  (eval \"$ac_link\") 2>&5\n-  ac_status=$?\n-  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n-  test $ac_status = 0; } && { ac_try='./conftest$ac_exeext'\n-  { { case \"(($ac_try\" in\n-  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n-  *) ac_try_echo=$ac_try;;\n-esac\n-eval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\n-$as_echo \"$ac_try_echo\"; } >&5\n-  (eval \"$ac_try\") 2>&5\n-  ac_status=$?\n-  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n-  test $ac_status = 0; }; }; then :\n-  ac_retval=0\n-else\n-  $as_echo \"$as_me: program exited with status $ac_status\" >&5\n-       $as_echo \"$as_me: failed program was:\" >&5\n-sed 's/^/| /' conftest.$ac_ext >&5\n-\n-       ac_retval=$ac_status\n-fi\n-  rm -rf conftest.dSYM conftest_ipa8_conftest.oo\n-  eval $as_lineno_stack; test \"x$as_lineno_stack\" = x && { as_lineno=; unset as_lineno;}\n-  return $ac_retval\n-\n-} # ac_fn_cxx_try_run\n-\n # ac_fn_cxx_compute_int LINENO EXPR VAR INCLUDES\n # ----------------------------------------------\n # Tries to find the compile-time value of EXPR in a program that includes\n@@ -5172,6 +5172,230 @@ done\n fi\n \n # Checks for typedefs, structures, and compiler characteristics.\n+ { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether byte ordering is bigendian\" >&5\n+$as_echo_n \"checking whether byte ordering is bigendian... \" >&6; }\n+if test \"${ac_cv_c_bigendian+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  ac_cv_c_bigendian=unknown\n+    # See if we're dealing with a universal compiler.\n+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#ifndef __APPLE_CC__\n+\t       not a universal capable compiler\n+\t     #endif\n+\t     typedef int dummy;\n+\n+_ACEOF\n+if ac_fn_cxx_try_compile \"$LINENO\"; then :\n+\n+\t# Check for potential -arch flags.  It is not universal unless\n+\t# there are at least two -arch flags with different values.\n+\tac_arch=\n+\tac_prev=\n+\tfor ac_word in $CC $CFLAGS $CPPFLAGS $LDFLAGS; do\n+\t if test -n \"$ac_prev\"; then\n+\t   case $ac_word in\n+\t     i?86 | x86_64 | ppc | ppc64)\n+\t       if test -z \"$ac_arch\" || test \"$ac_arch\" = \"$ac_word\"; then\n+\t\t ac_arch=$ac_word\n+\t       else\n+\t\t ac_cv_c_bigendian=universal\n+\t\t break\n+\t       fi\n+\t       ;;\n+\t   esac\n+\t   ac_prev=\n+\t elif test \"x$ac_word\" = \"x-arch\"; then\n+\t   ac_prev=arch\n+\t fi\n+       done\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+    if test $ac_cv_c_bigendian = unknown; then\n+      # See if sys/param.h defines the BYTE_ORDER macro.\n+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <sys/types.h>\n+\t     #include <sys/param.h>\n+\n+int\n+main ()\n+{\n+#if ! (defined BYTE_ORDER && defined BIG_ENDIAN \\\n+\t\t     && defined LITTLE_ENDIAN && BYTE_ORDER && BIG_ENDIAN \\\n+\t\t     && LITTLE_ENDIAN)\n+\t      bogus endian macros\n+\t     #endif\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_cxx_try_compile \"$LINENO\"; then :\n+  # It does; now see whether it defined to BIG_ENDIAN or not.\n+\t cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <sys/types.h>\n+\t\t#include <sys/param.h>\n+\n+int\n+main ()\n+{\n+#if BYTE_ORDER != BIG_ENDIAN\n+\t\t not big endian\n+\t\t#endif\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_cxx_try_compile \"$LINENO\"; then :\n+  ac_cv_c_bigendian=yes\n+else\n+  ac_cv_c_bigendian=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+    fi\n+    if test $ac_cv_c_bigendian = unknown; then\n+      # See if <limits.h> defines _LITTLE_ENDIAN or _BIG_ENDIAN (e.g., Solaris).\n+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <limits.h>\n+\n+int\n+main ()\n+{\n+#if ! (defined _LITTLE_ENDIAN || defined _BIG_ENDIAN)\n+\t      bogus endian macros\n+\t     #endif\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_cxx_try_compile \"$LINENO\"; then :\n+  # It does; now see whether it defined to _BIG_ENDIAN or not.\n+\t cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <limits.h>\n+\n+int\n+main ()\n+{\n+#ifndef _BIG_ENDIAN\n+\t\t not big endian\n+\t\t#endif\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_cxx_try_compile \"$LINENO\"; then :\n+  ac_cv_c_bigendian=yes\n+else\n+  ac_cv_c_bigendian=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+    fi\n+    if test $ac_cv_c_bigendian = unknown; then\n+      # Compile a test program.\n+      if test \"$cross_compiling\" = yes; then :\n+  # Try to guess by grepping values from an object file.\n+\t cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+short int ascii_mm[] =\n+\t\t  { 0x4249, 0x4765, 0x6E44, 0x6961, 0x6E53, 0x7953, 0 };\n+\t\tshort int ascii_ii[] =\n+\t\t  { 0x694C, 0x5454, 0x656C, 0x6E45, 0x6944, 0x6E61, 0 };\n+\t\tint use_ascii (int i) {\n+\t\t  return ascii_mm[i] + ascii_ii[i];\n+\t\t}\n+\t\tshort int ebcdic_ii[] =\n+\t\t  { 0x89D3, 0xE3E3, 0x8593, 0x95C5, 0x89C4, 0x9581, 0 };\n+\t\tshort int ebcdic_mm[] =\n+\t\t  { 0xC2C9, 0xC785, 0x95C4, 0x8981, 0x95E2, 0xA8E2, 0 };\n+\t\tint use_ebcdic (int i) {\n+\t\t  return ebcdic_mm[i] + ebcdic_ii[i];\n+\t\t}\n+\t\textern int foo;\n+\n+int\n+main ()\n+{\n+return use_ascii (foo) == use_ebcdic (foo);\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_cxx_try_compile \"$LINENO\"; then :\n+  if grep BIGenDianSyS conftest.$ac_objext >/dev/null; then\n+\t      ac_cv_c_bigendian=yes\n+\t    fi\n+\t    if grep LiTTleEnDian conftest.$ac_objext >/dev/null ; then\n+\t      if test \"$ac_cv_c_bigendian\" = unknown; then\n+\t\tac_cv_c_bigendian=no\n+\t      else\n+\t\t# finding both strings is unlikely to happen, but who knows?\n+\t\tac_cv_c_bigendian=unknown\n+\t      fi\n+\t    fi\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+else\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+$ac_includes_default\n+int\n+main ()\n+{\n+\n+\t     /* Are we little or big endian?  From Harbison&Steele.  */\n+\t     union\n+\t     {\n+\t       long int l;\n+\t       char c[sizeof (long int)];\n+\t     } u;\n+\t     u.l = 1;\n+\t     return u.c[sizeof (long int) - 1] == 1;\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_cxx_try_run \"$LINENO\"; then :\n+  ac_cv_c_bigendian=no\n+else\n+  ac_cv_c_bigendian=yes\n+fi\n+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \\\n+  conftest.$ac_objext conftest.beam conftest.$ac_ext\n+fi\n+\n+    fi\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_bigendian\" >&5\n+$as_echo \"$ac_cv_c_bigendian\" >&6; }\n+ case $ac_cv_c_bigendian in #(\n+   yes)\n+     $as_echo \"#define WORDS_BIGENDIAN 1\" >>confdefs.h\n+;; #(\n+   no)\n+      ;; #(\n+   universal)\n+\n+$as_echo \"#define AC_APPLE_UNIVERSAL_BUILD 1\" >>confdefs.h\n+\n+     ;; #(\n+   *)\n+     as_fn_error \"unknown endianness\n+ presetting ac_cv_c_bigendian=no (or yes) will help\" \"$LINENO\" 5 ;;\n+ esac\n+\n { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for an ANSI C-conforming const\" >&5\n $as_echo_n \"checking for an ANSI C-conforming const... \" >&6; }\n if test \"${ac_cv_c_const+set}\" = set; then :\n@@ -5369,6 +5593,53 @@ cat >>confdefs.h <<_ACEOF\n #define ssize_t int\n _ACEOF\n \n+fi\n+\n+\n+  ac_fn_cxx_check_type \"$LINENO\" \"uintptr_t\" \"ac_cv_type_uintptr_t\" \"$ac_includes_default\"\n+if test \"x$ac_cv_type_uintptr_t\" = x\"\"yes; then :\n+\n+$as_echo \"#define HAVE_UINTPTR_T 1\" >>confdefs.h\n+\n+else\n+  for ac_type in 'unsigned int' 'unsigned long int' \\\n+\t'unsigned long long int'; do\n+       cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+$ac_includes_default\n+int\n+main ()\n+{\n+static int test_array [1 - 2 * !(sizeof (void *) <= sizeof ($ac_type))];\n+test_array [0] = 0\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_cxx_try_compile \"$LINENO\"; then :\n+\n+cat >>confdefs.h <<_ACEOF\n+#define uintptr_t $ac_type\n+_ACEOF\n+\n+\t  ac_type=\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+       test -z \"$ac_type\" && break\n+     done\n+fi\n+\n+\n+ac_fn_cxx_check_type \"$LINENO\" \"ptrdiff_t\" \"ac_cv_type_ptrdiff_t\" \"$ac_includes_default\"\n+if test \"x$ac_cv_type_ptrdiff_t\" = x\"\"yes; then :\n+\n+else\n+\n+cat >>confdefs.h <<_ACEOF\n+#define ptrdiff_t int\n+_ACEOF\n+\n fi\n \n { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether struct tm is in sys/time.h or time.h\" >&5\n@@ -7042,6 +7313,7 @@ LTLIBOBJS=$ac_ltlibobjs\n \n \n \n+\n : ${CONFIG_STATUS=./config.status}\n ac_write_fail=0\n ac_clean_files_save=$ac_clean_files"}, {"sha": "1250f495a9d2ed1ea780a38767040cdb27e27b07", "filename": "libcpp/configure.ac", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/246a2fcb5ebf059b9761cec0d0d4b7c0c1147f17/libcpp%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/246a2fcb5ebf059b9761cec0d0d4b7c0c1147f17/libcpp%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fconfigure.ac?ref=246a2fcb5ebf059b9761cec0d0d4b7c0c1147f17", "patch": "@@ -70,12 +70,15 @@ else\n fi\n \n # Checks for typedefs, structures, and compiler characteristics.\n+AC_C_BIGENDIAN\n AC_C_CONST\n AC_C_INLINE\n AC_FUNC_OBSTACK\n AC_TYPE_OFF_T\n AC_TYPE_SIZE_T\n-AC_CHECK_TYPE(ssize_t, int)\n+AC_TYPE_SSIZE_T\n+AC_TYPE_UINTPTR_T\n+AC_CHECK_TYPE(ptrdiff_t, int)\n AC_STRUCT_TM\n AC_CHECK_SIZEOF(int)\n AC_CHECK_SIZEOF(long)"}, {"sha": "bc0086df1d5e82b05ac7271a30c967144cc39b06", "filename": "libcpp/lex.c", "status": "modified", "additions": 589, "deletions": 56, "changes": 645, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/246a2fcb5ebf059b9761cec0d0d4b7c0c1147f17/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/246a2fcb5ebf059b9761cec0d0d4b7c0c1147f17/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=246a2fcb5ebf059b9761cec0d0d4b7c0c1147f17", "patch": "@@ -1,5 +1,5 @@\n /* CPP Library - lexical analysis.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n    Contributed by Per Bothner, 1994-95.\n    Based on CCCP program by Paul Rubin, June 1986\n@@ -96,6 +96,531 @@ add_line_note (cpp_buffer *buffer, const uchar *pos, unsigned int type)\n   buffer->notes_used++;\n }\n \n+\f\n+/* Fast path to find line special characters using optimized character\n+   scanning algorithms.  Anything complicated falls back to the slow\n+   path below.  Since this loop is very hot it's worth doing these kinds\n+   of optimizations.\n+\n+   One of the paths through the ifdefs should provide \n+\n+     const uchar *search_line_fast (const uchar *s, const uchar *end);\n+\n+   Between S and END, search for \\n, \\r, \\\\, ?.  Return a pointer to\n+   the found character.\n+\n+   Note that the last character of the buffer is *always* a newline,\n+   as forced by _cpp_convert_input.  This fact can be used to avoid\n+   explicitly looking for the end of the buffer.  */\n+\n+/* Configure gives us an ifdef test.  */\n+#ifndef WORDS_BIGENDIAN\n+#define WORDS_BIGENDIAN 0\n+#endif\n+\n+/* We'd like the largest integer that fits into a register.  There's nothing\n+   in <stdint.h> that gives us that.  For most hosts this is unsigned long,\n+   but MS decided on an LLP64 model.  Thankfully when building with GCC we\n+   can get the \"real\" word size.  */\n+#ifdef __GNUC__\n+typedef unsigned int word_type __attribute__((__mode__(__word__)));\n+#else\n+typedef unsigned long word_type;\n+#endif\n+\n+/* The code below is only expecting sizes 4 or 8.\n+   Die at compile-time if this expectation is violated.  */\n+typedef char check_word_type_size\n+  [(sizeof(word_type) == 8 || sizeof(word_type) == 4) * 2 - 1];\n+\n+/* Return X with the first N bytes forced to values that won't match one\n+   of the interesting characters.  Note that NUL is not interesting.  */\n+\n+static inline word_type\n+acc_char_mask_misalign (word_type val, unsigned int n)\n+{\n+  word_type mask = -1;\n+  if (WORDS_BIGENDIAN)\n+    mask >>= n * 8;\n+  else\n+    mask <<= n * 8;\n+  return val & mask;\n+}\n+\n+/* Return X replicated to all byte positions within WORD_TYPE.  */\n+\n+static inline word_type\n+acc_char_replicate (uchar x)\n+{\n+  word_type ret;\n+\n+  ret = (x << 24) | (x << 16) | (x << 8) | x;\n+  if (sizeof(word_type) == 8)\n+    ret = (ret << 16 << 16) | ret;\n+  return ret;\n+}\n+\n+/* Return non-zero if some byte of VAL is (probably) C.  */\n+\n+static inline word_type\n+acc_char_cmp (word_type val, word_type c)\n+{\n+#if defined(__GNUC__) && defined(__alpha__)\n+  /* We can get exact results using a compare-bytes instruction.  \n+     Get (val == c) via (0 >= (val ^ c)).  */\n+  return __builtin_alpha_cmpbge (0, val ^ c);\n+#else\n+  word_type magic = 0x7efefefeU;\n+  if (sizeof(word_type) == 8)\n+    magic = (magic << 16 << 16) | 0xfefefefeU;\n+  magic |= 1;\n+\n+  val ^= c;\n+  return ((val + magic) ^ ~val) & ~magic;\n+#endif\n+}\n+\n+/* Given the result of acc_char_cmp is non-zero, return the index of\n+   the found character.  If this was a false positive, return -1.  */\n+\n+static inline int\n+acc_char_index (word_type cmp ATTRIBUTE_UNUSED,\n+\t\tword_type val ATTRIBUTE_UNUSED)\n+{\n+#if defined(__GNUC__) && defined(__alpha__) && !WORDS_BIGENDIAN\n+  /* The cmpbge instruction sets *bits* of the result corresponding to\n+     matches in the bytes with no false positives.  */\n+  return __builtin_ctzl (cmp);\n+#else\n+  unsigned int i;\n+\n+  /* ??? It would be nice to force unrolling here,\n+     and have all of these constants folded.  */\n+  for (i = 0; i < sizeof(word_type); ++i)\n+    {\n+      uchar c;\n+      if (WORDS_BIGENDIAN)\n+\tc = (val >> (sizeof(word_type) - i - 1) * 8) & 0xff;\n+      else\n+\tc = (val >> i * 8) & 0xff;\n+\n+      if (c == '\\n' || c == '\\r' || c == '\\\\' || c == '?')\n+\treturn i;\n+    }\n+\n+  return -1;\n+#endif\n+}\n+\n+/* A version of the fast scanner using bit fiddling techniques.\n+ \n+   For 32-bit words, one would normally perform 16 comparisons and\n+   16 branches.  With this algorithm one performs 24 arithmetic\n+   operations and one branch.  Whether this is faster with a 32-bit\n+   word size is going to be somewhat system dependent.\n+\n+   For 64-bit words, we eliminate twice the number of comparisons\n+   and branches without increasing the number of arithmetic operations.\n+   It's almost certainly going to be a win with 64-bit word size.  */\n+\n+static const uchar * search_line_acc_char (const uchar *, const uchar *)\n+  ATTRIBUTE_UNUSED;\n+\n+static const uchar *\n+search_line_acc_char (const uchar *s, const uchar *end ATTRIBUTE_UNUSED)\n+{\n+  const word_type repl_nl = acc_char_replicate ('\\n');\n+  const word_type repl_cr = acc_char_replicate ('\\r');\n+  const word_type repl_bs = acc_char_replicate ('\\\\');\n+  const word_type repl_qm = acc_char_replicate ('?');\n+\n+  unsigned int misalign;\n+  const word_type *p;\n+  word_type val, t;\n+  \n+  /* Align the buffer.  Mask out any bytes from before the beginning.  */\n+  p = (word_type *)((uintptr_t)s & -sizeof(word_type));\n+  val = *p;\n+  misalign = (uintptr_t)s & (sizeof(word_type) - 1);\n+  if (misalign)\n+    val = acc_char_mask_misalign (val, misalign);\n+\n+  /* Main loop.  */\n+  while (1)\n+    {\n+      t  = acc_char_cmp (val, repl_nl);\n+      t |= acc_char_cmp (val, repl_cr);\n+      t |= acc_char_cmp (val, repl_bs);\n+      t |= acc_char_cmp (val, repl_qm);\n+\n+      if (__builtin_expect (t != 0, 0))\n+\t{\n+\t  int i = acc_char_index (t, val);\n+\t  if (i >= 0)\n+\t    return (const uchar *)p + i;\n+\t}\n+\n+      val = *++p;\n+    }\n+}\n+\n+#if (GCC_VERSION >= 4005) && (defined(__i386__) || defined(__x86_64__))\n+\n+/* Replicated character data to be shared between implementations.\n+   Recall that outside of a context with vector support we can't\n+   define compatible vector types, therefore these are all defined\n+   in terms of raw characters.  */\n+static const char repl_chars[4][16] __attribute__((aligned(16))) = {\n+  { '\\n', '\\n', '\\n', '\\n', '\\n', '\\n', '\\n', '\\n',\n+    '\\n', '\\n', '\\n', '\\n', '\\n', '\\n', '\\n', '\\n' },\n+  { '\\r', '\\r', '\\r', '\\r', '\\r', '\\r', '\\r', '\\r',\n+    '\\r', '\\r', '\\r', '\\r', '\\r', '\\r', '\\r', '\\r' },\n+  { '\\\\', '\\\\', '\\\\', '\\\\', '\\\\', '\\\\', '\\\\', '\\\\',\n+    '\\\\', '\\\\', '\\\\', '\\\\', '\\\\', '\\\\', '\\\\', '\\\\' },\n+  { '?', '?', '?', '?', '?', '?', '?', '?',\n+    '?', '?', '?', '?', '?', '?', '?', '?' },\n+};\n+\n+/* A version of the fast scanner using MMX vectorized byte compare insns.\n+\n+   This uses the PMOVMSKB instruction which was introduced with \"MMX2\",\n+   which was packaged into SSE1; it is also present in the AMD 3dNOW-A\n+   extension.  Mark the function as using \"sse\" so that we emit a real\n+   \"emms\" instruction, rather than the 3dNOW \"femms\" instruction.  */\n+\n+static const uchar *\n+#ifndef __SSE__\n+__attribute__((__target__(\"sse\")))\n+#endif\n+search_line_mmx (const uchar *s, const uchar *end ATTRIBUTE_UNUSED)\n+{\n+  typedef char v8qi __attribute__ ((__vector_size__ (8)));\n+  typedef int __m64 __attribute__ ((__vector_size__ (8), __may_alias__));\n+\n+  const v8qi repl_nl = *(const v8qi *)repl_chars[0];\n+  const v8qi repl_cr = *(const v8qi *)repl_chars[1];\n+  const v8qi repl_bs = *(const v8qi *)repl_chars[2];\n+  const v8qi repl_qm = *(const v8qi *)repl_chars[3];\n+\n+  unsigned int misalign, found, mask;\n+  const v8qi *p;\n+  v8qi data, t, c;\n+\n+  /* Align the source pointer.  While MMX doesn't generate unaligned data\n+     faults, this allows us to safely scan to the end of the buffer without\n+     reading beyond the end of the last page.  */\n+  misalign = (uintptr_t)s & 7;\n+  p = (const v8qi *)((uintptr_t)s & -8);\n+  data = *p;\n+\n+  /* Create a mask for the bytes that are valid within the first\n+     16-byte block.  The Idea here is that the AND with the mask\n+     within the loop is \"free\", since we need some AND or TEST\n+     insn in order to set the flags for the branch anyway.  */\n+  mask = -1u << misalign;\n+\n+  /* Main loop processing 8 bytes at a time.  */\n+  goto start;\n+  do\n+    {\n+      data = *++p;\n+      mask = -1;\n+\n+    start:\n+      t = __builtin_ia32_pcmpeqb(data, repl_nl);\n+      c = __builtin_ia32_pcmpeqb(data, repl_cr);\n+      t = (v8qi) __builtin_ia32_por ((__m64)t, (__m64)c);\n+      c = __builtin_ia32_pcmpeqb(data, repl_bs);\n+      t = (v8qi) __builtin_ia32_por ((__m64)t, (__m64)c);\n+      c = __builtin_ia32_pcmpeqb(data, repl_qm);\n+      t = (v8qi) __builtin_ia32_por ((__m64)t, (__m64)c);\n+      found = __builtin_ia32_pmovmskb (t);\n+      found &= mask;\n+    }\n+  while (!found);\n+\n+  __builtin_ia32_emms ();\n+\n+  /* FOUND contains 1 in bits for which we matched a relevant\n+     character.  Conversion to the byte index is trivial.  */\n+  found = __builtin_ctz(found);\n+  return (const uchar *)p + found;\n+}\n+\n+/* A version of the fast scanner using SSE2 vectorized byte compare insns.  */\n+\n+static const uchar *\n+#ifndef __SSE2__\n+__attribute__((__target__(\"sse2\")))\n+#endif\n+search_line_sse2 (const uchar *s, const uchar *end ATTRIBUTE_UNUSED)\n+{\n+  typedef char v16qi __attribute__ ((__vector_size__ (16)));\n+\n+  const v16qi repl_nl = *(const v16qi *)repl_chars[0];\n+  const v16qi repl_cr = *(const v16qi *)repl_chars[1];\n+  const v16qi repl_bs = *(const v16qi *)repl_chars[2];\n+  const v16qi repl_qm = *(const v16qi *)repl_chars[3];\n+\n+  unsigned int misalign, found, mask;\n+  const v16qi *p;\n+  v16qi data, t;\n+\n+  /* Align the source pointer.  */\n+  misalign = (uintptr_t)s & 15;\n+  p = (const v16qi *)((uintptr_t)s & -16);\n+  data = *p;\n+\n+  /* Create a mask for the bytes that are valid within the first\n+     16-byte block.  The Idea here is that the AND with the mask\n+     within the loop is \"free\", since we need some AND or TEST\n+     insn in order to set the flags for the branch anyway.  */\n+  mask = -1u << misalign;\n+\n+  /* Main loop processing 16 bytes at a time.  */\n+  goto start;\n+  do\n+    {\n+      data = *++p;\n+      mask = -1;\n+\n+    start:\n+      t  = __builtin_ia32_pcmpeqb128(data, repl_nl);\n+      t |= __builtin_ia32_pcmpeqb128(data, repl_cr);\n+      t |= __builtin_ia32_pcmpeqb128(data, repl_bs);\n+      t |= __builtin_ia32_pcmpeqb128(data, repl_qm);\n+      found = __builtin_ia32_pmovmskb128 (t);\n+      found &= mask;\n+    }\n+  while (!found);\n+\n+  /* FOUND contains 1 in bits for which we matched a relevant\n+     character.  Conversion to the byte index is trivial.  */\n+  found = __builtin_ctz(found);\n+  return (const uchar *)p + found;\n+}\n+\n+/* A version of the fast scanner using SSE 4.2 vectorized string insns.  */\n+\n+static const uchar *\n+#ifndef __SSE4_2__\n+__attribute__((__target__(\"sse4.2\")))\n+#endif\n+search_line_sse42 (const uchar *s, const uchar *end)\n+{\n+  typedef char v16qi __attribute__ ((__vector_size__ (16)));\n+  static const v16qi search = { '\\n', '\\r', '?', '\\\\' };\n+\n+  uintptr_t si = (uintptr_t)s;\n+  uintptr_t index;\n+\n+  /* Check for unaligned input.  */\n+  if (si & 15)\n+    {\n+      if (__builtin_expect (end - s < 16, 0)\n+\t  && __builtin_expect ((si & 0xfff) > 0xff0, 0))\n+\t{\n+\t  /* There are less than 16 bytes left in the buffer, and less\n+\t     than 16 bytes left on the page.  Reading 16 bytes at this\n+\t     point might generate a spurious page fault.  Defer to the\n+\t     SSE2 implementation, which already handles alignment.  */\n+\t  return search_line_sse2 (s, end);\n+\t}\n+\n+      /* ??? The builtin doesn't understand that the PCMPESTRI read from\n+\t memory need not be aligned.  */\n+      __asm (\"%vpcmpestri $0, (%1), %2\"\n+\t     : \"=c\"(index) : \"r\"(s), \"x\"(search), \"a\"(4), \"d\"(16));\n+      if (__builtin_expect (index < 16, 0))\n+\tgoto found;\n+\n+      /* Advance the pointer to an aligned address.  We will re-scan a\n+\t few bytes, but we no longer need care for reading past the\n+\t end of a page, since we're guaranteed a match.  */\n+      s = (const uchar *)((si + 16) & -16);\n+    }\n+\n+  /* Main loop, processing 16 bytes at a time.  By doing the whole loop\n+     in inline assembly, we can make proper use of the flags set.  */\n+  __asm (      \"sub $16, %1\\n\"\n+\t\"\t.balign 16\\n\"\n+\t\"0:\tadd $16, %1\\n\"\n+\t\"\t%vpcmpestri $0, (%1), %2\\n\"\n+\t\"\tjnc 0b\"\n+\t: \"=&c\"(index), \"+r\"(s)\n+\t: \"x\"(search), \"a\"(4), \"d\"(16));\n+\n+ found:\n+  return s + index;\n+}\n+\n+/* Check the CPU capabilities.  */\n+\n+#include \"../gcc/config/i386/cpuid.h\"\n+\n+typedef const uchar * (*search_line_fast_type) (const uchar *, const uchar *);\n+static search_line_fast_type search_line_fast;\n+\n+static void __attribute__((constructor))\n+init_vectorized_lexer (void)\n+{\n+  unsigned dummy, ecx = 0, edx = 0;\n+  search_line_fast_type impl = search_line_acc_char;\n+  int minimum = 0;\n+\n+#if defined(__SSE4_2__)\n+  minimum = 3;\n+#elif defined(__SSE2__)\n+  minimum = 2;\n+#elif defined(__SSE__) || defined(__3dNOW_A__)\n+  minimum = 1;\n+#endif\n+\n+  if (minimum == 3)\n+    impl = search_line_sse42;\n+  else if (__get_cpuid (1, &dummy, &dummy, &ecx, &edx) || minimum == 2)\n+    {\n+      if (minimum == 3 || (ecx & bit_SSE4_2))\n+        impl = search_line_sse42;\n+      else if (minimum == 2 || (edx & bit_SSE2))\n+\timpl = search_line_sse2;\n+      else if (minimum == 1 || (edx & bit_SSE))\n+\timpl = search_line_mmx;\n+    }\n+  else if (__get_cpuid (0x80000001, &dummy, &dummy, &dummy, &edx))\n+    {\n+      if (minimum == 1 || edx & bit_3DNOWP)\n+\timpl = search_line_mmx;\n+    }\n+\n+  search_line_fast = impl;\n+}\n+\n+#elif defined(__GNUC__) && defined(__ALTIVEC__)\n+\n+/* A vection of the fast scanner using AltiVec vectorized byte compares.  */\n+/* ??? Unfortunately, attribute(target(\"altivec\")) is not yet supported,\n+   so we can't compile this function without -maltivec on the command line\n+   (or implied by some other switch).  */\n+\n+static const uchar *\n+search_line_fast (const uchar *s, const uchar *end ATTRIBUTE_UNUSED)\n+{\n+  typedef __attribute__((altivec(vector))) unsigned char vc;\n+\n+  const vc repl_nl = {\n+    '\\n', '\\n', '\\n', '\\n', '\\n', '\\n', '\\n', '\\n', \n+    '\\n', '\\n', '\\n', '\\n', '\\n', '\\n', '\\n', '\\n'\n+  };\n+  const vc repl_cr = {\n+    '\\r', '\\r', '\\r', '\\r', '\\r', '\\r', '\\r', '\\r', \n+    '\\r', '\\r', '\\r', '\\r', '\\r', '\\r', '\\r', '\\r'\n+  };\n+  const vc repl_bs = {\n+    '\\\\', '\\\\', '\\\\', '\\\\', '\\\\', '\\\\', '\\\\', '\\\\', \n+    '\\\\', '\\\\', '\\\\', '\\\\', '\\\\', '\\\\', '\\\\', '\\\\'\n+  };\n+  const vc repl_qm = {\n+    '?', '?', '?', '?', '?', '?', '?', '?', \n+    '?', '?', '?', '?', '?', '?', '?', '?', \n+  };\n+  const vc ones = {\n+    -1, -1, -1, -1, -1, -1, -1, -1,\n+    -1, -1, -1, -1, -1, -1, -1, -1,\n+  };\n+  const vc zero = { 0 };\n+\n+  vc data, mask, t;\n+\n+  /* Altivec loads automatically mask addresses with -16.  This lets us\n+     issue the first load as early as possible.  */\n+  data = __builtin_vec_ld(0, (const vc *)s);\n+\n+  /* Discard bytes before the beginning of the buffer.  Do this by\n+     beginning with all ones and shifting in zeros according to the\n+     mis-alignment.  The LVSR instruction pulls the exact shift we\n+     want from the address.  */\n+  mask = __builtin_vec_lvsr(0, s);\n+  mask = __builtin_vec_perm(zero, ones, mask);\n+  data &= mask;\n+\n+  /* While altivec loads mask addresses, we still need to align S so\n+     that the offset we compute at the end is correct.  */\n+  s = (const uchar *)((uintptr_t)s & -16);\n+\n+  /* Main loop processing 16 bytes at a time.  */\n+  goto start;\n+  do\n+    {\n+      vc m_nl, m_cr, m_bs, m_qm;\n+\n+      s += 16;\n+      data = __builtin_vec_ld(0, (const vc *)s);\n+\n+    start:\n+      m_nl = (vc) __builtin_vec_cmpeq(data, repl_nl);\n+      m_cr = (vc) __builtin_vec_cmpeq(data, repl_cr);\n+      m_bs = (vc) __builtin_vec_cmpeq(data, repl_bs);\n+      m_qm = (vc) __builtin_vec_cmpeq(data, repl_qm);\n+      t = (m_nl | m_cr) | (m_bs | m_qm);\n+\n+      /* T now contains 0xff in bytes for which we matched one of the relevant\n+\t characters.  We want to exit the loop if any byte in T is non-zero.\n+\t Below is the expansion of vec_any_ne(t, zero).  */\n+    }\n+  while (!__builtin_vec_vcmpeq_p(/*__CR6_LT_REV*/3, t, zero));\n+\n+  {\n+#define N  (sizeof(vc) / sizeof(long))\n+\n+    typedef char check_count[(N == 2 || N == 4) * 2 - 1];\n+    union {\n+      vc v;\n+      unsigned long l[N];\n+    } u;\n+    unsigned long l, i = 0;\n+\n+    u.v = t;\n+\n+    /* Find the first word of T that is non-zero.  */\n+    switch (N)\n+      {\n+      case 4:\n+\tl = u.l[i++];\n+\tif (l != 0)\n+\t  break;\n+\ts += sizeof(unsigned long);\n+\tl = u.l[i++];\n+\tif (l != 0)\n+\t  break;\n+\ts += sizeof(unsigned long);\n+      case 2:\n+\tl = u.l[i++];\n+\tif (l != 0)\n+\t  break;\n+\ts += sizeof(unsigned long);\n+\tl = u.l[i];\n+      }\n+\n+    /* L now contains 0xff in bytes for which we matched one of the\n+       relevant characters.  We can find the byte index by finding\n+       its bit index and dividing by 8.  */\n+    l = __builtin_clzl(l) >> 3;\n+    return s + l;\n+\n+#undef N\n+  }\n+}\n+\n+#else\n+\n+/* We only have one accellerated alternative.  Use a direct call so that\n+   we encourage inlining.  */\n+\n+#define search_line_fast  search_line_acc_char\n+\n+#endif\n+\n /* Returns with a logical line that contains no escaped newlines or\n    trigraphs.  This is a time-critical inner loop.  */\n void\n@@ -109,82 +634,91 @@ _cpp_clean_line (cpp_reader *pfile)\n   buffer->cur_note = buffer->notes_used = 0;\n   buffer->cur = buffer->line_base = buffer->next_line;\n   buffer->need_line = false;\n-  s = buffer->next_line - 1;\n+  s = buffer->next_line;\n \n   if (!buffer->from_stage3)\n     {\n       const uchar *pbackslash = NULL;\n \n-      /* Short circuit for the common case of an un-escaped line with\n+      /* Fast path.  This is the common case of an un-escaped line with\n \t no trigraphs.  The primary win here is by not writing any\n \t data back to memory until we have to.  */\n-      for (;;)\n+      while (1)\n \t{\n-\t  c = *++s;\n-\t  if (__builtin_expect (c == '\\n', false)\n-\t      || __builtin_expect (c == '\\r', false))\n-\t    {\n-\t      d = (uchar *) s;\n+\t  /* Perform an optimized search for \\n, \\r, \\\\, ?.  */\n+\t  s = search_line_fast (s, buffer->rlimit);\n \n-\t      if (__builtin_expect (s == buffer->rlimit, false))\n-\t\tgoto done;\n-\n-\t      /* DOS line ending? */\n-\t      if (__builtin_expect (c == '\\r', false)\n-\t\t  && s[1] == '\\n')\n-\t\t{\n-\t\t  s++;\n-\t\t  if (s == buffer->rlimit)\n-\t\t    goto done;\n-\t\t}\n-\n-\t      if (__builtin_expect (pbackslash == NULL, true))\n-\t\tgoto done;\n-\n-\t      /* Check for escaped newline.  */\n-\t      p = d;\n-\t      while (is_nvspace (p[-1]))\n-\t\tp--;\n-\t      if (p - 1 != pbackslash)\n-\t\tgoto done;\n-\n-\t      /* Have an escaped newline; process it and proceed to\n-\t\t the slow path.  */\n-\t      add_line_note (buffer, p - 1, p != d ? ' ' : '\\\\');\n-\t      d = p - 2;\n-\t      buffer->next_line = p - 1;\n-\t      break;\n+\t  c = *s;\n+\t  if (c == '\\\\')\n+\t    {\n+\t      /* Record the location of the backslash and continue.  */\n+\t      pbackslash = s++;\n \t    }\n-\t  if (__builtin_expect (c == '\\\\', false))\n-\t    pbackslash = s;\n-\t  else if (__builtin_expect (c == '?', false)\n-\t\t   && __builtin_expect (s[1] == '?', false)\n-\t\t   && _cpp_trigraph_map[s[2]])\n+\t  else if (__builtin_expect (c == '?', 0))\n \t    {\n-\t      /* Have a trigraph.  We may or may not have to convert\n-\t\t it.  Add a line note regardless, for -Wtrigraphs.  */\n-\t      add_line_note (buffer, s, s[2]);\n-\t      if (CPP_OPTION (pfile, trigraphs))\n+\t      if (__builtin_expect (s[1] == '?', false)\n+\t\t   && _cpp_trigraph_map[s[2]])\n \t\t{\n-\t\t  /* We do, and that means we have to switch to the\n-\t\t     slow path.  */\n-\t\t  d = (uchar *) s;\n-\t\t  *d = _cpp_trigraph_map[s[2]];\n-\t\t  s += 2;\n-\t\t  break;\n+\t\t  /* Have a trigraph.  We may or may not have to convert\n+\t\t     it.  Add a line note regardless, for -Wtrigraphs.  */\n+\t\t  add_line_note (buffer, s, s[2]);\n+\t\t  if (CPP_OPTION (pfile, trigraphs))\n+\t\t    {\n+\t\t      /* We do, and that means we have to switch to the\n+\t\t         slow path.  */\n+\t\t      d = (uchar *) s;\n+\t\t      *d = _cpp_trigraph_map[s[2]];\n+\t\t      s += 2;\n+\t\t      goto slow_path;\n+\t\t    }\n \t\t}\n+\t      /* Not a trigraph.  Continue on fast-path.  */\n+\t      s++;\n \t    }\n+\t  else\n+\t    break;\n \t}\n \n+      /* This must be \\r or \\n.  We're either done, or we'll be forced\n+\t to write back to the buffer and continue on the slow path.  */\n+      d = (uchar *) s;\n+\n+      if (__builtin_expect (s == buffer->rlimit, false))\n+\tgoto done;\n+\n+      /* DOS line ending? */\n+      if (__builtin_expect (c == '\\r', false) && s[1] == '\\n')\n+\t{\n+\t  s++;\n+\t  if (s == buffer->rlimit)\n+\t    goto done;\n+\t}\n+\n+      if (__builtin_expect (pbackslash == NULL, true))\n+\tgoto done;\n+\n+      /* Check for escaped newline.  */\n+      p = d;\n+      while (is_nvspace (p[-1]))\n+\tp--;\n+      if (p - 1 != pbackslash)\n+\tgoto done;\n+\n+      /* Have an escaped newline; process it and proceed to\n+\t the slow path.  */\n+      add_line_note (buffer, p - 1, p != d ? ' ' : '\\\\');\n+      d = p - 2;\n+      buffer->next_line = p - 1;\n \n-      for (;;)\n+    slow_path:\n+      while (1)\n \t{\n \t  c = *++s;\n \t  *++d = c;\n \n \t  if (c == '\\n' || c == '\\r')\n \t    {\n-\t\t  /* Handle DOS line endings.  */\n+\t      /* Handle DOS line endings.  */\n \t      if (c == '\\r' && s != buffer->rlimit && s[1] == '\\n')\n \t\ts++;\n \t      if (s == buffer->rlimit)\n@@ -215,9 +749,8 @@ _cpp_clean_line (cpp_reader *pfile)\n     }\n   else\n     {\n-      do\n+      while (*s != '\\n' && *s != '\\r')\n \ts++;\n-      while (*s != '\\n' && *s != '\\r');\n       d = (uchar *) s;\n \n       /* Handle DOS line endings.  */"}, {"sha": "1a74734a73e617571667b1f7e893a4f74dfa7825", "filename": "libcpp/system.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/246a2fcb5ebf059b9761cec0d0d4b7c0c1147f17/libcpp%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/246a2fcb5ebf059b9761cec0d0d4b7c0c1147f17/libcpp%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fsystem.h?ref=246a2fcb5ebf059b9761cec0d0d4b7c0c1147f17", "patch": "@@ -29,6 +29,9 @@ along with GCC; see the file COPYING3.  If not see\n #ifdef HAVE_STDDEF_H\n # include <stddef.h>\n #endif\n+#ifdef HAVE_STDINT_H\n+# include <stdint.h>\n+#endif\n \n #include <stdio.h>\n "}]}