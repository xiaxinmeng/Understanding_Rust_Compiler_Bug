{"sha": "8dc2b10365a3d9def1a6e0412db0cc0177cfad6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRjMmIxMDM2NWEzZDlkZWYxYTZlMDQxMmRiMGNjMDE3N2NmYWQ2ZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-08-30T15:28:48Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-08-30T15:28:48Z"}, "message": "call.c (check_dtor_name): Replace abort with gcc_assert or gcc_unreachable.\n\n\t* call.c (check_dtor_name): Replace abort with gcc_assert or\n\tgcc_unreachable.\n\t(build_call, add_builtin_candidate, build_new_op,\n\tconvert_like_real, build_over_call, in_charge_arg_for_name,\n\tsource_type, joust): Likewise.\n\t* class.c (build_simple_base_path, get_vcall_index,\n\tfinish_struct_1, instantiate_type, get_enclosing_class,\n\tadd_vcall_offset_vtbl_entries_1, cp_fold_obj_type_ref): Likewise.\n\t* cp-gimplify.c (cp_genericize): Likewise.\n\t* cp-lang.c (cp_expr_size, cp_tree_size): Likewise.\n\t* cvt.c (cp_convert_to_pointer, ocp_convert): Likewise.\n\t* decl.c (poplevel, make_unbound_class_template, reshape_init,\n\tcheck_special_function_return_type, grokdeclarator,\n\tgrok_op_properties, tag_name, xref_tag, start_preparsed_function,\n\tfinish_function): Likewise.\n\t* decl2.c (grokfield, maybe_emit_vtables):Likewise.\n\t* error.c (dump_global_iord, dump_decl, dump_template_decl,\n\tlanguage_to_string): Likewise.\n\t* except.c (choose_personality_routine): Likewise.\n\t* friend.c (do_friend): Likewise.\n\t* g++spec.c (lang_specific_driver): Likewise.\n\t* init.c (build_zero_init, expand_default_init, build_new_1,\n\tbuild_vec_delete_1, build_vec_init, build_dtor_call): Likewise.\n\t* lex.c (retrofit_lang_decl, cp_type_qual_from_rid): Likewise.\n\t* mangle.c (add_substitution, write_unscoped_name,\n\twrite_template_prefix, write_identifier,\n\twrite_special_name_destructor, write_type, write_builtin_type,\n\twrite_expression, write_template_param,\n\twrite_java_integer_type_codes): Likewise.\n\t* method.c (implicitly_declare_fn): Likewise.\n\nFrom-SVN: r86778", "tree": {"sha": "4ca6b4e112f696c8ceed5ba25d4dd59e1b129aba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ca6b4e112f696c8ceed5ba25d4dd59e1b129aba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/comments", "author": null, "committer": null, "parents": [{"sha": "e7023b0f5d50726613a97706f2de34e856eb1ec8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7023b0f5d50726613a97706f2de34e856eb1ec8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7023b0f5d50726613a97706f2de34e856eb1ec8"}], "stats": {"total": 466, "additions": 243, "deletions": 223}, "files": [{"sha": "78e651b0d98d49bd20122cff9c7afe9a9ce826d1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8dc2b10365a3d9def1a6e0412db0cc0177cfad6d", "patch": "@@ -1,3 +1,36 @@\n+2004-08-30  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* call.c (check_dtor_name): Replace abort with gcc_assert or\n+\tgcc_unreachable.\n+\t(build_call, add_builtin_candidate, build_new_op,\n+\tconvert_like_real, build_over_call, in_charge_arg_for_name,\n+\tsource_type, joust): Likewise.\n+\t* class.c (build_simple_base_path, get_vcall_index,\n+\tfinish_struct_1, instantiate_type, get_enclosing_class,\n+\tadd_vcall_offset_vtbl_entries_1, cp_fold_obj_type_ref): Likewise.\n+\t* cp-gimplify.c (cp_genericize): Likewise.\n+\t* cp-lang.c (cp_expr_size, cp_tree_size): Likewise.\n+\t* cvt.c (cp_convert_to_pointer, ocp_convert): Likewise.\n+\t* decl.c (poplevel, make_unbound_class_template, reshape_init,\n+\tcheck_special_function_return_type, grokdeclarator,\n+\tgrok_op_properties, tag_name, xref_tag, start_preparsed_function,\n+\tfinish_function): Likewise.\n+\t* decl2.c (grokfield, maybe_emit_vtables):Likewise.\n+\t* error.c (dump_global_iord, dump_decl, dump_template_decl,\n+\tlanguage_to_string): Likewise.\n+\t* except.c (choose_personality_routine): Likewise.\n+\t* friend.c (do_friend): Likewise.\n+\t* g++spec.c (lang_specific_driver): Likewise.\n+\t* init.c (build_zero_init, expand_default_init, build_new_1,\n+\tbuild_vec_delete_1, build_vec_init, build_dtor_call): Likewise.\n+\t* lex.c (retrofit_lang_decl, cp_type_qual_from_rid): Likewise.\n+\t* mangle.c (add_substitution, write_unscoped_name,\n+\twrite_template_prefix, write_identifier,\n+\twrite_special_name_destructor, write_type, write_builtin_type,\n+\twrite_expression, write_template_param,\n+\twrite_java_integer_type_codes): Likewise.\n+\t* method.c (implicitly_declare_fn): Likewise.\n+\n 2004-08-30  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* cp-tree.h (BINFO_PRIMARY_P): Use a binfo flag."}, {"sha": "4e5b3d590c139d6f3410a1f486e1ff6a5e36d3fb", "filename": "gcc/cp/call.c", "status": "modified", "additions": 41, "deletions": 39, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=8dc2b10365a3d9def1a6e0412db0cc0177cfad6d", "patch": "@@ -234,17 +234,18 @@ check_dtor_name (tree basetype, tree name)\n       else\n \tname = get_type_value (name);\n     }\n-  /* In the case of:\n-      \n-       template <class T> struct S { ~S(); };\n-       int i;\n-       i.~S();\n-\n-     NAME will be a class template.  */\n-  else if (DECL_CLASS_TEMPLATE_P (name))\n-    return false;\n   else\n-    abort ();\n+    {\n+      /* In the case of:\n+      \t  \t\n+      \t template <class T> struct S { ~S(); };\n+      \t int i;\n+       \t i.~S();\n+\t  \n+     \t NAME will be a class template.  */\n+      gcc_assert (DECL_CLASS_TEMPLATE_P (name));\n+      return false;\n+    }\n \n   if (name && TYPE_MAIN_VARIANT (basetype) == TYPE_MAIN_VARIANT (name))\n     return true;\n@@ -328,11 +329,10 @@ build_call (tree function, tree parms)\n       /* We invoke build_call directly for several library functions.\n \t These may have been declared normally if we're building libgcc,\n \t so we can't just check DECL_ARTIFICIAL.  */\n-      if (DECL_ARTIFICIAL (decl)\n-\t  || !strncmp (IDENTIFIER_POINTER (DECL_NAME (decl)), \"__\", 2))\n-\tmark_used (decl);\n-      else\n-\tabort ();\n+      gcc_assert (DECL_ARTIFICIAL (decl)\n+\t\t  || !strncmp (IDENTIFIER_POINTER (DECL_NAME (decl)),\n+\t\t\t       \"__\", 2));\n+      mark_used (decl);\n     }\n \n   /* Don't pass empty class objects by value.  This is useful\n@@ -1915,7 +1915,7 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n \t  return;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       type1 = build_reference_type (type1);\n       break;\n@@ -1952,7 +1952,7 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* If we're dealing with two pointer types or two enumeral types,\n@@ -3600,7 +3600,7 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n     case VEC_DELETE_EXPR:\n     case DELETE_EXPR:\n       /* Use build_op_new_call and build_op_delete_call instead.  */\n-      abort ();\n+      gcc_unreachable ();\n \n     case CALL_EXPR:\n       return build_object_call (arg1, arg2);\n@@ -3836,7 +3836,7 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n   if (result || result_valid_p)\n     return result;\n \n-builtin:\n+ builtin:\n   switch (code)\n     {\n     case MODIFY_EXPR:\n@@ -3895,9 +3895,9 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n       return NULL_TREE;\n \n     default:\n-      abort ();\n-      return NULL_TREE;\n+      gcc_unreachable ();\n     }\n+  return NULL_TREE;\n }\n \n /* Build a call to operator delete.  This has to be handled very specially,\n@@ -4180,11 +4180,10 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t\t\t\t    0);\n \n \t    args = build_tree_list (NULL_TREE, expr);\n-\t    if (DECL_HAS_IN_CHARGE_PARM_P (convfn)\n-\t\t|| DECL_HAS_VTT_PARM_P (convfn))\n-\t      /* We should never try to call the abstract or base constructor\n-\t\t from here.  */\n-\t      abort ();\n+\t    /* We should never try to call the abstract or base constructor\n+\t       from here.  */\n+\t    gcc_assert (!DECL_HAS_IN_CHARGE_PARM_P (convfn)\n+\t\t\t&& !DECL_HAS_VTT_PARM_P (convfn));\n \t    args = tree_cons (NULL_TREE, t, args);\n \t  }\n \telse\n@@ -4649,9 +4648,9 @@ build_over_call (struct z_candidate *cand, int flags)\n       converted_args = tree_cons (NULL_TREE, TREE_VALUE (arg), converted_args);\n       arg = TREE_CHAIN (arg);\n       parm = TREE_CHAIN (parm);\n-      if (DECL_HAS_IN_CHARGE_PARM_P (fn))\n-\t/* We should never try to call the abstract constructor.  */\n-\tabort ();\n+      /* We should never try to call the abstract constructor.  */\n+      gcc_assert (!DECL_HAS_IN_CHARGE_PARM_P (fn));\n+      \n       if (DECL_HAS_VTT_PARM_P (fn))\n \t{\n \t  converted_args = tree_cons\n@@ -4967,12 +4966,14 @@ build_java_interface_fn_ref (tree fn, tree instance)\n }\n \n /* Returns the value to use for the in-charge parameter when making a\n-   call to a function with the indicated NAME.  */\n+   call to a function with the indicated NAME.\n+   \n+   FIXME:Can't we find a neater way to do this mapping?  */\n \n tree\n in_charge_arg_for_name (tree name)\n {\n-  if (name == base_ctor_identifier\n+ if (name == base_ctor_identifier\n       || name == base_dtor_identifier)\n     return integer_zero_node;\n   else if (name == complete_ctor_identifier)\n@@ -4984,7 +4985,7 @@ in_charge_arg_for_name (tree name)\n \n   /* This function should only be called with one of the names listed\n      above.  */\n-  abort ();\n+  gcc_unreachable ();\n   return NULL_TREE;\n }\n \n@@ -5838,7 +5839,7 @@ source_type (conversion *t)\n \t  || t->kind == ck_identity)\n \treturn t->type;\n     }\n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* Note a warning about preferring WINNER to LOSER.  We do this by storing\n@@ -5899,17 +5900,18 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n   len = cand1->num_convs;\n   if (len != cand2->num_convs)\n     {\n-      if (DECL_STATIC_FUNCTION_P (cand1->fn)\n-\t  && ! DECL_STATIC_FUNCTION_P (cand2->fn))\n+      int static_1 = DECL_STATIC_FUNCTION_P (cand1->fn);\n+      int static_2 = DECL_STATIC_FUNCTION_P (cand2->fn);\n+\n+      gcc_assert (static_1 != static_2);\n+      \n+      if (static_1)\n \toff2 = 1;\n-      else if (! DECL_STATIC_FUNCTION_P (cand1->fn)\n-\t       && DECL_STATIC_FUNCTION_P (cand2->fn))\n+      else\n \t{\n \t  off1 = 1;\n \t  --len;\n \t}\n-      else\n-\tabort ();\n     }\n \n   for (i = 0; i < len; ++i)"}, {"sha": "22781e3c331e2da5cd26427a9af029ee17ff063c", "filename": "gcc/cp/class.c", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=8dc2b10365a3d9def1a6e0412db0cc0177cfad6d", "patch": "@@ -418,8 +418,7 @@ build_simple_base_path (tree expr, tree binfo)\n \n   if (d_binfo == NULL_TREE)\n     {\n-      if (TYPE_MAIN_VARIANT (TREE_TYPE (expr)) != type)\n-\tabort ();\n+      gcc_assert (TYPE_MAIN_VARIANT (TREE_TYPE (expr)) == type);\n       return expr;\n     }\n \n@@ -436,7 +435,7 @@ build_simple_base_path (tree expr, tree binfo)\n \t\t\t\t\t     NULL_TREE, false);\n \n   /* Didn't find the base field?!?  */\n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* Convert OBJECT to the base TYPE.  If CHECK_ACCESS is true, an error\n@@ -2007,9 +2006,7 @@ get_vcall_index (tree fn, tree type)\n       return p->value;\n \n   /* There should always be an appropriate index.  */\n-  abort ();\n-\n-  return NULL_TREE;\n+  gcc_unreachable ();\n }\n \n /* Update an entry in the vtable for BINFO, which is in the hierarchy\n@@ -4928,10 +4925,8 @@ finish_struct_1 (tree t)\n \n   if (COMPLETE_TYPE_P (t))\n     {\n-      if (IS_AGGR_TYPE (t))\n-\terror (\"redefinition of `%#T'\", t);\n-      else\n-\tabort ();\n+      gcc_assert (IS_AGGR_TYPE (t));\n+      error (\"redefinition of `%#T'\", t);\n       popclass ();\n       return;\n     }\n@@ -5942,8 +5937,7 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n     case CONVERT_EXPR:\n     case SAVE_EXPR:\n     case CONSTRUCTOR:\n-      abort ();\n-      return error_mark_node;\n+      gcc_unreachable ();\n \n     case INDIRECT_REF:\n     case ARRAY_REF:\n@@ -6014,8 +6008,7 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n \n     case CALL_EXPR:\n       /* This is too hard for now.  */\n-      abort ();\n-      return error_mark_node;\n+      gcc_unreachable ();\n \n     case PLUS_EXPR:\n     case MINUS_EXPR:\n@@ -6124,9 +6117,9 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n       return error_mark_node;\n \n     default:\n-      abort ();\n-      return error_mark_node;\n+      gcc_unreachable ();\n     }\n+  return error_mark_node;\n }\n \f\n /* Return the name of the virtual function pointer field\n@@ -6273,7 +6266,7 @@ get_enclosing_class (tree type)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n   return NULL_TREE;\n@@ -7604,8 +7597,7 @@ add_vcall_offset_vtbl_entries_1 (tree binfo, vtbl_init_data* vid)\n \t     might be a lost primary, so just skip down to vid->binfo.  */\n \t  if (BINFO_VIRTUAL_P (non_primary_binfo))\n \t    {\n-\t      if (non_primary_binfo != vid->vbase)\n-\t\tabort ();\n+\t      gcc_assert (non_primary_binfo == vid->vbase);\n \t      non_primary_binfo = vid->binfo;\n \t      break;\n \t    }\n@@ -7794,8 +7786,8 @@ cp_fold_obj_type_ref (tree ref, tree known_type)\n   fndecl = BV_FN (v);\n \n #ifdef ENABLE_CHECKING\n-  if (!tree_int_cst_equal (OBJ_TYPE_REF_TOKEN (ref), DECL_VINDEX (fndecl)))\n-    abort ();\n+  gcc_assert (tree_int_cst_equal (OBJ_TYPE_REF_TOKEN (ref),\n+\t\t\t\t  DECL_VINDEX (fndecl)));\n #endif\n \n   return build_address (fndecl);"}, {"sha": "c937a1149d396a1642dd59eeeda40b3d355022e4", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=8dc2b10365a3d9def1a6e0412db0cc0177cfad6d", "patch": "@@ -329,12 +329,10 @@ cp_genericize (tree fndecl)\n   /* Fix up the types of parms passed by invisible reference.  */\n   for (t = DECL_ARGUMENTS (fndecl); t; t = TREE_CHAIN (t))\n     {\n-      if (DECL_BY_REFERENCE (t))\n-\tabort ();\n+      gcc_assert (!DECL_BY_REFERENCE (t));\n       if (TREE_ADDRESSABLE (TREE_TYPE (t)))\n \t{\n-\t  if (DECL_ARG_TYPE (t) == TREE_TYPE (t))\n-\t    abort ();\n+\t  gcc_assert (DECL_ARG_TYPE (t) != TREE_TYPE (t));\n \t  TREE_TYPE (t) = DECL_ARG_TYPE (t);\n \t  DECL_BY_REFERENCE (t) = 1;\n \t  TREE_ADDRESSABLE (t) = 0;"}, {"sha": "a1359cd7c869347b6c1f8c032a0345c3b6951ca1", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=8dc2b10365a3d9def1a6e0412db0cc0177cfad6d", "patch": "@@ -260,13 +260,13 @@ cp_expr_size (tree exp)\n       /* The backend should not be interested in the size of an expression\n \t of a type with both of these set; all copies of such types must go\n \t through a constructor or assignment op.  */\n-      if (TYPE_HAS_COMPLEX_INIT_REF (TREE_TYPE (exp))\n-\t  && TYPE_HAS_COMPLEX_ASSIGN_REF (TREE_TYPE (exp))\n-\t  /* But storing a CONSTRUCTOR isn't a copy.  */\n-\t  && TREE_CODE (exp) != CONSTRUCTOR)\n-\tabort ();\n+      gcc_assert (!TYPE_HAS_COMPLEX_INIT_REF (TREE_TYPE (exp))\n+\t\t  || !TYPE_HAS_COMPLEX_ASSIGN_REF (TREE_TYPE (exp))\n+\t\t  /* But storing a CONSTRUCTOR isn't a copy.  */\n+\t\t  || TREE_CODE (exp) == CONSTRUCTOR);\n+      \n       /* This would be wrong for a type with virtual bases, but they are\n-\t caught by the abort above.  */\n+\t caught by the assert above.  */\n       return (is_empty_class (TREE_TYPE (exp))\n \t      ? size_zero_node\n \t      : CLASSTYPE_SIZE_UNIT (TREE_TYPE (exp)));\n@@ -289,7 +289,7 @@ cp_tree_size (enum tree_code code)\n     case DEFAULT_ARG:\t\treturn sizeof (struct tree_default_arg);\n     case OVERLOAD:\t\treturn sizeof (struct tree_overload);\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   /* NOTREACHED */\n }"}, {"sha": "cb179d55ab2e562f0ec6bd1ac7cfb6f1a00d12d3", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=8dc2b10365a3d9def1a6e0412db0cc0177cfad6d", "patch": "@@ -284,12 +284,12 @@ cp_convert_to_pointer (tree type, tree expr, bool force)\n       if (TYPE_PRECISION (intype) == POINTER_SIZE)\n \treturn build1 (CONVERT_EXPR, type, expr);\n       expr = cp_convert (c_common_type_for_size (POINTER_SIZE, 0), expr);\n-      /* Modes may be different but sizes should be the same.  */\n-      if (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (expr)))\n-\t  != GET_MODE_SIZE (TYPE_MODE (type)))\n-\t/* There is supposed to be some integral type\n-\t   that is the same width as a pointer.  */\n-\tabort ();\n+      /* Modes may be different but sizes should be the same.  There\n+\t is supposed to be some integral type that is the same width\n+\t as a pointer.  */\n+      gcc_assert (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (expr)))\n+\t\t  == GET_MODE_SIZE (TYPE_MODE (type)));\n+      \n       return convert_to_pointer (type, expr);\n     }\n \n@@ -647,17 +647,18 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \t  /* Don't build a NOP_EXPR of class type.  Instead, change the\n \t     type of the temporary.  Only allow this for cv-qual changes,\n \t     though.  */\n-\t  if (!same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (e)),\n-\t\t\t    TYPE_MAIN_VARIANT (type)))\n-\t    abort ();\n+\t  gcc_assert (same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (e)),\n+\t\t\t\t   TYPE_MAIN_VARIANT (type)));\n \t  TREE_TYPE (e) = TREE_TYPE (TARGET_EXPR_SLOT (e)) = type;\n \t  return e;\n \t}\n-      else if (TREE_ADDRESSABLE (type))\n-\t/* We shouldn't be treating objects of ADDRESSABLE type as rvalues.  */\n-\tabort ();\n       else\n-\treturn fold (build1 (NOP_EXPR, type, e));\n+\t{\n+\t  /* We shouldn't be treating objects of ADDRESSABLE type as\n+\t     rvalues.  */\n+\t  gcc_assert (!TREE_ADDRESSABLE (type));\n+\t  return fold (build1 (NOP_EXPR, type, e));\n+\t}\n     }\n \n   if (code == VOID_TYPE && (convtype & CONV_STATIC))"}, {"sha": "bd7098289b2c2e6031e1afce92801c1edee71a3b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8dc2b10365a3d9def1a6e0412db0cc0177cfad6d", "patch": "@@ -602,18 +602,20 @@ poplevel (int keep, int reverse, int functionbody)\n \t}\n       else\n \t{\n+\t  tree name;\n+\t  \n \t  /* Remove the binding.  */\n \t  decl = link;\n \n \t  if (TREE_CODE (decl) == TREE_LIST)\n \t    decl = TREE_VALUE (decl);\n+\t  name = decl;\n+\t  \n+\t  if (TREE_CODE (name) == OVERLOAD)\n+\t    name = OVL_FUNCTION (name);\n \n-\t  if (DECL_P (decl))\n-\t    pop_binding (DECL_NAME (decl), decl);\n-\t  else if (TREE_CODE (decl) == OVERLOAD)\n-\t    pop_binding (DECL_NAME (OVL_FUNCTION (decl)), decl);\n-\t  else\n-\t    abort ();\n+\t  gcc_assert (DECL_P (name));\n+\t  pop_binding (DECL_NAME (name), decl);\n \t}\n     }\n \n@@ -2702,8 +2704,7 @@ make_unbound_class_template (tree context, tree name, tsubst_flags_t complain)\n     name = TYPE_IDENTIFIER (name);\n   else if (DECL_P (name))\n     name = DECL_NAME (name);\n-  if (TREE_CODE (name) != IDENTIFIER_NODE)\n-    abort ();\n+  gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n \n   if (!dependent_type_p (context)\n       || currently_open_class (context))\n@@ -4324,7 +4325,7 @@ reshape_init (tree type, tree *initp)\n \t    }\n \t}\n       else\n-\tabort ();\n+\tgcc_unreachable ();\n \n       /* The initializers were placed in reverse order in the\n \t CONSTRUCTOR.  */\n@@ -6258,8 +6259,7 @@ check_special_function_return_type (special_function_kind sfk,\n       break;\n \n     default:\n-      abort ();\n-      break;\n+      gcc_unreachable ();\n     }\n \n   return type;\n@@ -6493,7 +6493,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\tbreak;\n \n \t      default:\n-\t\tabort ();\n+\t\tgcc_unreachable ();\n \t      }\n \t    break;\n \n@@ -6507,7 +6507,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t    break;\n \n \t  default:\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t  }\n \t}\n       if (id_declarator->kind == cdk_id)\n@@ -6982,7 +6982,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n \n@@ -7236,7 +7236,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n \n@@ -7619,10 +7619,8 @@ grokdeclarator (const cp_declarator *declarator,\n \terror (\"unnamed variable or field declared void\");\n       else if (TREE_CODE (unqualified_id) == IDENTIFIER_NODE)\n \t{\n-\t  if (IDENTIFIER_OPNAME_P (unqualified_id))\n-\t    abort ();\n-\t  else\n-\t    error (\"variable or field `%s' declared void\", name);\n+\t  gcc_assert (!IDENTIFIER_OPNAME_P (unqualified_id));\n+\t  error (\"variable or field `%s' declared void\", name);\n \t}\n       else\n \terror (\"variable or field declared void\");\n@@ -8524,7 +8522,7 @@ grok_op_properties (tree decl, int friendp, bool complain)\n #include \"operators.def\"\n #undef DEF_OPERATOR\n \n-\tabort ();\n+\tgcc_unreachable ();\n       }\n     while (0);\n   gcc_assert (operator_code != LAST_CPLUS_TREE_CODE);\n@@ -8694,7 +8692,7 @@ grok_op_properties (tree decl, int friendp, bool complain)\n \t\t  break;\n \n \t\tdefault:\n-\t\t  abort ();\n+\t\t  gcc_unreachable ();\n \t\t}\n \n \t      SET_OVERLOADED_OPERATOR_CODE (decl, operator_code);\n@@ -8825,7 +8823,7 @@ tag_name (enum tag_types code)\n     case enum_type:\n       return \"enum\";\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -8946,7 +8944,7 @@ xref_tag (enum tag_types tag_code, tree name,\n       code = ENUMERAL_TYPE;\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (! globalize)\n@@ -9845,8 +9843,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n \t}\n       if (DECL_HAS_VTT_PARM_P (decl1))\n \t{\n-\t  if (DECL_NAME (t) != vtt_parm_identifier)\n-\t    abort ();\n+\t  gcc_assert (DECL_NAME (t) == vtt_parm_identifier);\n \t  current_vtt_parm = t;\n \t}\n     }\n@@ -10356,8 +10353,7 @@ finish_function (int flags)\n   if (current_binding_level->kind != sk_function_parms)\n     {\n       /* Make sure we have already experienced errors.  */\n-      if (errorcount == 0)\n-\tabort ();\n+      gcc_assert (errorcount);\n \n       /* Throw away the broken statement tree and extra binding\n          levels.  */"}, {"sha": "5e0651e79bdf16073daf6b4d6119a6f6ab9cc668", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=8dc2b10365a3d9def1a6e0412db0cc0177cfad6d", "patch": "@@ -953,14 +953,14 @@ grokfield (const cp_declarator *declarator,\n   if (attrlist)\n     cplus_decl_attributes (&value, attrlist, 0);\n \n-  if (TREE_CODE (value) == VAR_DECL)\n+  switch (TREE_CODE (value))\n     {\n+    case VAR_DECL:\n       finish_static_data_member_decl (value, init, asmspec_tree, \n \t\t\t\t      flags);\n       return value;\n-    }\n-  if (TREE_CODE (value) == FIELD_DECL)\n-    {\n+\n+    case FIELD_DECL:\n       if (asmspec)\n \terror (\"`asm' specifiers are not permitted on non-static data members\");\n       if (DECL_INITIAL (value) == error_mark_node)\n@@ -969,9 +969,8 @@ grokfield (const cp_declarator *declarator,\n       DECL_INITIAL (value) = init;\n       DECL_IN_AGGR_P (value) = 1;\n       return value;\n-    }\n-  if (TREE_CODE (value) == FUNCTION_DECL)\n-    {\n+\n+    case  FUNCTION_DECL:\n       if (asmspec)\n \tset_user_assembler_name (value, asmspec);\n       if (!DECL_FRIEND_P (value))\n@@ -985,9 +984,10 @@ grokfield (const cp_declarator *declarator,\n \n       DECL_IN_AGGR_P (value) = 1;\n       return value;\n+      \n+    default:\n+      gcc_unreachable ();\n     }\n-  abort ();\n-  /* NOTREACHED */\n   return NULL_TREE;\n }\n \n@@ -1586,9 +1586,10 @@ maybe_emit_vtables (tree ctype)\n \n       if (TREE_TYPE (DECL_INITIAL (vtbl)) == 0)\n \t{\n+\t  tree expr = store_init_value (vtbl, DECL_INITIAL (vtbl));\n+\t  \n \t  /* It had better be all done at compile-time.  */\n-\t  if (store_init_value (vtbl, DECL_INITIAL (vtbl)))\n-\t    abort ();\n+\t  gcc_assert (!expr);\n \t}\n \n       /* Write it out.  */"}, {"sha": "03feaf3b7dac943b3285717ca5c164412877e63e", "filename": "gcc/cp/error.c", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=8dc2b10365a3d9def1a6e0412db0cc0177cfad6d", "patch": "@@ -677,7 +677,7 @@ dump_global_iord (tree t)\n   else if (DECL_GLOBAL_DTOR_P (t))\n     p = \"destructors\";\n   else\n-    abort ();\n+    gcc_unreachable ();\n \n   pp_printf (pp_base (cxx_pp), \"(static %s for %s)\", p, input_filename);\n }\n@@ -790,7 +790,7 @@ dump_decl (tree t, int flags)\n       break;\n \n     case TYPE_EXPR:\n-      abort ();\n+      gcc_unreachable ();\n       break;\n \n       /* These special cases are duplicated here so that other functions\n@@ -954,20 +954,22 @@ dump_template_decl (tree t, int flags)\n                 | (flags & TFF_DECL_SPECIFIERS ? TFF_CLASS_KEY_OR_ENUM : 0)));\n   else if (TREE_CODE (DECL_TEMPLATE_RESULT (t)) == VAR_DECL)\n     dump_decl (DECL_TEMPLATE_RESULT (t), flags | TFF_TEMPLATE_NAME);\n-  else if (TREE_TYPE (t) == NULL_TREE)\n-    abort ();\n   else\n-    switch (NEXT_CODE (t))\n     {\n-      case METHOD_TYPE:\n-      case FUNCTION_TYPE:\n-        dump_function_decl (t, flags | TFF_TEMPLATE_NAME);\n-        break;\n-      default:\n-        /* This case can occur with some invalid code.  */\n-        dump_type (TREE_TYPE (t),\n-                   (flags & ~TFF_CLASS_KEY_OR_ENUM) | TFF_TEMPLATE_NAME\n-                   | (flags & TFF_DECL_SPECIFIERS ? TFF_CLASS_KEY_OR_ENUM : 0));\n+      gcc_assert (TREE_TYPE (t));\n+      switch (NEXT_CODE (t))\n+\t{\n+\tcase METHOD_TYPE:\n+\tcase FUNCTION_TYPE:\n+\t  dump_function_decl (t, flags | TFF_TEMPLATE_NAME);\n+\t  break;\n+\tdefault:\n+\t  /* This case can occur with some invalid code.  */\n+\t  dump_type (TREE_TYPE (t),\n+\t\t     (flags & ~TFF_CLASS_KEY_OR_ENUM) | TFF_TEMPLATE_NAME\n+\t\t     | (flags & TFF_DECL_SPECIFIERS\n+\t\t\t? TFF_CLASS_KEY_OR_ENUM : 0));\n+\t}\n     }\n }\n \n@@ -2027,9 +2029,9 @@ language_to_string (enum languages c)\n       return \"Java\";\n \n     default:\n-      abort ();\n-      return 0;\n+      gcc_unreachable ();\n     }\n+  return 0;\n }\n \n /* Return the proper printed version of a parameter to a C++ function.  */"}, {"sha": "31bf96b780d7e1f27ef496f34aa71079f38d325b", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=8dc2b10365a3d9def1a6e0412db0cc0177cfad6d", "patch": "@@ -312,7 +312,7 @@ choose_personality_routine (enum languages lang)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   return;\n "}, {"sha": "1310a93d02bd3e23a29b4987cab13a0ce4a1fd3c", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=8dc2b10365a3d9def1a6e0412db0cc0177cfad6d", "patch": "@@ -337,8 +337,7 @@ do_friend (tree ctype, tree declarator, tree decl,\n \tdeclarator = DECL_NAME (get_first_fn (declarator));\n     }\n \n-  if (TREE_CODE (decl) != FUNCTION_DECL)\n-    abort ();\n+  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n \n   if (ctype)\n     {"}, {"sha": "16441400b34f1fcceaa9c75c35bd8021f4452790", "filename": "gcc/cp/g++spec.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2Fg%2B%2Bspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2Fg%2B%2Bspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fg%2B%2Bspec.c?ref=8dc2b10365a3d9def1a6e0412db0cc0177cfad6d", "patch": "@@ -293,7 +293,7 @@ lang_specific_driver (int *in_argc, const char *const **in_argv,\n \t      arglist[j++] = \"-xc++-header\";\n \t      break;\n \t    default:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t    }\n \t  arglist[j++] = argv[i];\n \t  arglist[j] = \"-xnone\";"}, {"sha": "01478818b27ad7e9e0fe8f321fecb9484975af94", "filename": "gcc/cp/init.c", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=8dc2b10365a3d9def1a6e0412db0cc0177cfad6d", "patch": "@@ -240,10 +240,8 @@ build_zero_init (tree type, tree nelts, bool static_storage_p)\n \t\t\t     inits);\n       CONSTRUCTOR_ELTS (init) = nreverse (inits);\n     }\n-  else if (TREE_CODE (type) == REFERENCE_TYPE)\n-    ;\n   else\n-    abort ();\n+    gcc_assert (TREE_CODE (type) == REFERENCE_TYPE);\n \n   /* In all cases, the initializer is a constant.  */\n   if (init)\n@@ -1166,8 +1164,7 @@ expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags)\n       && (flags & LOOKUP_ONLYCONVERTING))\n     {\n       /* Base subobjects should only get direct-initialization.  */\n-      if (true_exp != exp)\n-\tabort ();\n+      gcc_assert (true_exp == exp);\n \n       if (flags & DIRECT_BIND)\n \t/* Do nothing.  We hit this in two cases:  Reference initialization,\n@@ -2073,9 +2070,9 @@ build_new_1 (tree exp)\n \t  if (TREE_CODE (init) == TREE_LIST)\n \t    init = build_x_compound_expr_from_list (init, \"new initializer\");\n \n-\t  else if (TREE_CODE (init) == CONSTRUCTOR\n-\t\t   && TREE_TYPE (init) == NULL_TREE)\n-\t    abort ();\n+\t  else\n+\t    gcc_assert (TREE_CODE (init) != CONSTRUCTOR\n+\t\t\t|| TREE_TYPE (init) != NULL_TREE);\n \n \t  init_expr = build_modify_expr (init_expr, INIT_EXPR, init);\n \t  stable = stabilize_init (init_expr, &init_preeval_expr);\n@@ -2217,8 +2214,7 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n   tree controller = NULL_TREE;\n \n   /* We should only have 1-D arrays here.  */\n-  if (TREE_CODE (type) == ARRAY_TYPE)\n-    abort ();\n+  gcc_assert (TREE_CODE (type) != ARRAY_TYPE);\n \n   if (! IS_AGGR_TYPE (type) || TYPE_HAS_TRIVIAL_DESTRUCTOR (type))\n     goto no_destructor;\n@@ -2560,7 +2556,7 @@ build_vec_init (tree base, tree maxindex, tree init, int from_array)\n \t  else if (from)\n \t    elt_init = build_modify_expr (to, NOP_EXPR, from);\n \t  else\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t}\n       else if (TREE_CODE (type) == ARRAY_TYPE)\n \t{\n@@ -2670,7 +2666,7 @@ build_dtor_call (tree exp, special_function_kind dtor_kind, int flags)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   exp = convert_from_reference (exp);"}, {"sha": "468585edef5fa46028367b03e5901ff15830a50e", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=8dc2b10365a3d9def1a6e0412db0cc0177cfad6d", "patch": "@@ -687,7 +687,8 @@ retrofit_lang_decl (tree t)\n     SET_DECL_LANGUAGE (t, lang_c);\n   else if (current_lang_name == lang_name_java)\n     SET_DECL_LANGUAGE (t, lang_java);\n-  else abort ();\n+  else\n+    gcc_unreachable ();\n \n #ifdef GATHER_STATISTICS\n   tree_node_counts[(int)lang_decl] += 1;\n@@ -826,6 +827,6 @@ cp_type_qual_from_rid (tree rid)\n   else if (rid == ridpointers[(int) RID_RESTRICT])\n     return TYPE_QUAL_RESTRICT;\n \n-  abort ();\n+  gcc_unreachable ();\n   return TYPE_UNQUALIFIED;\n }"}, {"sha": "b6253b27b88b81e819dbc43cd35598e883e3f967", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=8dc2b10365a3d9def1a6e0412db0cc0177cfad6d", "patch": "@@ -373,12 +373,10 @@ add_substitution (tree node)\n     for (i = VARRAY_ACTIVE_SIZE (G.substitutions); --i >= 0; )\n       {\n \tconst tree candidate = VARRAY_TREE (G.substitutions, i);\n-\tif ((DECL_P (node) \n-\t     && node == candidate)\n-\t    || (TYPE_P (node) \n-\t\t&& TYPE_P (candidate) \n-\t\t&& same_type_p (node, candidate)))\n-\t  abort ();\n+\t\n+\tgcc_assert (!(DECL_P (node) && node == candidate));\n+\tgcc_assert (!(TYPE_P (node) && TYPE_P (candidate) \n+\t\t      && same_type_p (node, candidate)));\n       }\n   }\n #endif /* ENABLE_CHECKING */\n@@ -832,14 +830,16 @@ write_unscoped_name (const tree decl)\n       write_string (\"St\");\n       write_unqualified_name (decl);\n     }\n-  /* If not, it should be either in the global namespace, or directly\n-     in a local function scope.  */\n-  else if (context == global_namespace \n-\t   || context == NULL\n-\t   || TREE_CODE (context) == FUNCTION_DECL)\n-    write_unqualified_name (decl);\n-  else \n-    abort ();\n+  else\n+    {\n+      /* If not, it should be either in the global namespace, or directly\n+     \t in a local function scope.  */\n+      gcc_assert (context == global_namespace \n+\t\t  || context == NULL\n+\t\t  || TREE_CODE (context) == FUNCTION_DECL);\n+      \n+      write_unqualified_name (decl);\n+    }\n }\n \n /* <unscoped-template-name> ::= <unscoped-name>\n@@ -984,11 +984,12 @@ write_template_prefix (const tree node)\n   /* Find the template decl.  */\n   if (decl_is_template_id (decl, &template_info))\n     template = TI_TEMPLATE (template_info);\n-  else if (CLASSTYPE_TEMPLATE_ID_P (type))\n-    template = TYPE_TI_TEMPLATE (type);\n   else\n-    /* Oops, not a template.  */\n-    abort ();\n+    {\n+      gcc_assert (CLASSTYPE_TEMPLATE_ID_P (type));\n+  \n+      template = TYPE_TI_TEMPLATE (type);\n+    }\n \n   /* For a member template, though, the template name for the\n      innermost name must have all the outer template levels\n@@ -1325,16 +1326,18 @@ write_identifier (const char *identifier)\n static void\n write_special_name_constructor (const tree ctor)\n {\n-  if (DECL_COMPLETE_CONSTRUCTOR_P (ctor)\n-      /* Even though we don't ever emit a definition of the\n-\t old-style destructor, we still have to consider entities\n-\t (like static variables) nested inside it.  */\n-      || DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (ctor))\n-    write_string (\"C1\");\n-  else if (DECL_BASE_CONSTRUCTOR_P (ctor))\n+  if (DECL_BASE_CONSTRUCTOR_P (ctor))\n     write_string (\"C2\");\n   else\n-    abort ();\n+    {\n+      gcc_assert (DECL_COMPLETE_CONSTRUCTOR_P (ctor)\n+\t\t  /* Even though we don't ever emit a definition of\n+\t\t     the old-style destructor, we still have to\n+\t\t     consider entities (like static variables) nested\n+\t\t     inside it.  */\n+\t\t  || DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (ctor));\n+      write_string (\"C1\");\n+    }\n }\n \n /* Handle destructor productions of non-terminal <special-name>.\n@@ -1353,16 +1356,18 @@ write_special_name_destructor (const tree dtor)\n {\n   if (DECL_DELETING_DESTRUCTOR_P (dtor))\n     write_string (\"D0\");\n-  else if (DECL_COMPLETE_DESTRUCTOR_P (dtor)\n-\t   /* Even though we don't ever emit a definition of the\n-\t      old-style destructor, we still have to consider entities\n-\t      (like static variables) nested inside it.  */\n-\t   || DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (dtor))\n-    write_string (\"D1\");\n   else if (DECL_BASE_DESTRUCTOR_P (dtor))\n     write_string (\"D2\");\n   else\n-    abort ();\n+    {\n+      gcc_assert (DECL_COMPLETE_DESTRUCTOR_P (dtor)\n+\t\t  /* Even though we don't ever emit a definition of\n+\t      \t     the old-style destructor, we still have to\n+\t      \t     consider entities (like static variables) nested\n+\t      \t     inside it.  */\n+\t\t  || DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (dtor));\n+      write_string (\"D1\");\n+    }\n }\n \n /* Return the discriminator for ENTITY appearing inside\n@@ -1590,7 +1595,7 @@ write_type (tree type)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n \n@@ -1706,11 +1711,8 @@ write_builtin_type (tree type)\n \t\t\t\t\t       TYPE_UNSIGNED (type));\n \t      if (type == t)\n \t\t{\n-\t\t  if (TYPE_PRECISION (type) == 128)\n-\t\t    write_char (TYPE_UNSIGNED (type) ? 'o' : 'n');\n-\t\t  else\n-\t\t    /* Couldn't find this type.  */\n-\t\t    abort ();\n+\t\t  gcc_assert (TYPE_PRECISION (type) == 128);\n+\t\t  write_char (TYPE_UNSIGNED (type) ? 'o' : 'n');\n \t\t}\n \t      else\n \t\t{\n@@ -1731,11 +1733,11 @@ write_builtin_type (tree type)\n       else if (type == long_double_type_node)\n \twrite_char ('e');\n       else\n-\tabort ();\n+\tgcc_unreachable ();\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -2139,31 +2141,29 @@ write_expression (tree expr)\n static void\n write_template_arg_literal (const tree value)\n {\n-  tree type = TREE_TYPE (value);\n   write_char ('L');\n-  write_type (type);\n+  write_type (TREE_TYPE (value));\n \n-  if (TREE_CODE (value) == CONST_DECL)\n-    write_integer_cst (DECL_INITIAL (value));\n-  else if (TREE_CODE (value) == INTEGER_CST)\n+  switch (TREE_CODE (value))\n     {\n-      if (same_type_p (type, boolean_type_node))\n-\t{\n-\t  if (integer_zerop (value))\n-\t    write_unsigned_number (0);\n-\t  else if (integer_onep (value))\n-\t    write_unsigned_number (1);\n-\t  else \n-\t    abort ();\n-\t}\n-      else\n-\twrite_integer_cst (value);\n-    }\n-  else if (TREE_CODE (value) == REAL_CST)\n-    write_real_cst (value);\n-  else\n-    abort ();\n+    case CONST_DECL:\n+      write_integer_cst (DECL_INITIAL (value));\n+      break;\n+      \n+    case INTEGER_CST:\n+      gcc_assert (!same_type_p (TREE_TYPE (value), boolean_type_node)\n+\t\t  || integer_zerop (value) || integer_onep (value));\n+      write_integer_cst (value);\n+      break;\n+\n+    case REAL_CST:\n+      write_real_cst (value);\n+      break;\n \n+    default:\n+      gcc_unreachable ();\n+    }\n+  \n   write_char ('E');\n }\n \n@@ -2352,7 +2352,7 @@ write_template_param (const tree parm)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   write_char ('T');\n@@ -2803,7 +2803,7 @@ write_java_integer_type_codes (const tree type)\n   else if (type == java_boolean_type_node)\n     write_char ('b');\n   else\n-    abort ();\n+    gcc_unreachable ();\n }\n \n #include \"gt-cp-mangle.h\""}, {"sha": "fe4cb1f0d1db062233706ef8945ff07917b194e3", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc2b10365a3d9def1a6e0412db0cc0177cfad6d/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=8dc2b10365a3d9def1a6e0412db0cc0177cfad6d", "patch": "@@ -989,7 +989,7 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n       break;\n     }\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* Create the function.  */\n@@ -1028,8 +1028,7 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n   DECL_NOT_REALLY_EXTERN (fn) = 1;\n   DECL_DECLARED_INLINE_P (fn) = 1;\n   DECL_INLINE (fn) = 1;\n-  if (TREE_USED (fn))\n-    abort ();\n+  gcc_assert (!TREE_USED (fn));\n   \n   return fn;\n }"}]}