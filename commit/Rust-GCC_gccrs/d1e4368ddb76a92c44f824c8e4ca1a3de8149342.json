{"sha": "d1e4368ddb76a92c44f824c8e4ca1a3de8149342", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDFlNDM2OGRkYjc2YTkyYzQ0ZjgyNGM4ZTRjYTFhM2RlODE0OTM0Mg==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2021-04-14T09:56:36Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2021-04-14T09:56:36Z"}, "message": "arm: fix warning when -mcpu=neoverse-n1 is used with -mfpu=neon [PR100067]\n\nIf the compiler is configured with --with-fpu=<!auto> (or invoked\nwith, say, -mfpu=neon), then specifying -mcpu=neoverse-n1 can lead to\nan unexpected warning: cc1: warning: switch \u2018-mcpu=neoverse-n1\u2019\nconflicts with \u2018-march=armv8.2-a\u2019 switch\n\nThe fix for this is to correctly remove all the feature bits relating\nto simd/fp units when -mfpu is used, not just those bits that form\npart of the -mfpu specification (which is a subset).\n\ngcc:\n\tPR target/100067\n\t* config/arm/arm.c (arm_configure_build_target): Strip isa_all_fpbits\n\tfrom the isa_delta when -mfpu has been used.\n\t(arm_options_perform_arch_sanity_checks): It's the architecture that\n\tlacks an FPU not the processor.", "tree": {"sha": "b8ed63263832ac79e5453554d6c68722746e0a31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8ed63263832ac79e5453554d6c68722746e0a31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1e4368ddb76a92c44f824c8e4ca1a3de8149342", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1e4368ddb76a92c44f824c8e4ca1a3de8149342", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1e4368ddb76a92c44f824c8e4ca1a3de8149342", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1e4368ddb76a92c44f824c8e4ca1a3de8149342/comments", "author": null, "committer": null, "parents": [{"sha": "287be7f7a587cb08eb88ecee39ff5556a22976d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/287be7f7a587cb08eb88ecee39ff5556a22976d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/287be7f7a587cb08eb88ecee39ff5556a22976d2"}], "stats": {"total": 25, "additions": 14, "deletions": 11}, "files": [{"sha": "475fb0d827f43e5b2750f673125e1ac54134688e", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1e4368ddb76a92c44f824c8e4ca1a3de8149342/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1e4368ddb76a92c44f824c8e4ca1a3de8149342/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=d1e4368ddb76a92c44f824c8e4ca1a3de8149342", "patch": "@@ -3230,21 +3230,22 @@ arm_configure_build_target (struct arm_build_target *target,\n \t  bitmap_xor (isa_delta, cpu_isa, target->isa);\n \t  /* Ignore any bits that are quirk bits.  */\n \t  bitmap_and_compl (isa_delta, isa_delta, isa_quirkbits);\n-\t  /* Ignore (for now) any bits that might be set by -mfpu.  */\n-\t  bitmap_and_compl (isa_delta, isa_delta, isa_all_fpubits_internal);\n-\n-\t  /* And if the target ISA lacks floating point, ignore any\n-\t     extensions that depend on that.  */\n-\t  if (!bitmap_bit_p (target->isa, isa_bit_vfpv2))\n+\t  /* If the user (or the default configuration) has specified a\n+\t     specific FPU, then ignore any bits that depend on the FPU\n+\t     configuration.  Do similarly if using the soft-float\n+\t     ABI.  */\n+\t  if (opts->x_arm_fpu_index != TARGET_FPU_auto\n+\t      || arm_float_abi == ARM_FLOAT_ABI_SOFT)\n \t    bitmap_and_compl (isa_delta, isa_delta, isa_all_fpbits);\n \n \t  if (!bitmap_empty_p (isa_delta))\n \t    {\n \t      if (warn_compatible)\n \t\twarning (0, \"switch %<-mcpu=%s%> conflicts \"\n-\t\t\t \"with %<-march=%s%> switch\",\n-\t\t\t arm_selected_cpu->common.name,\n-\t\t\t arm_selected_arch->common.name);\n+\t\t\t \"with switch %<-march=%s%>\",\n+\t\t\t opts->x_arm_cpu_string,\n+\t\t\t opts->x_arm_arch_string);\n+\n \t      /* -march wins for code generation.\n \t\t -mcpu wins for default tuning.  */\n \t      if (!arm_selected_tune)\n@@ -3395,7 +3396,9 @@ arm_configure_build_target (struct arm_build_target *target,\n       auto_sbitmap fpu_bits (isa_num_bits);\n \n       arm_initialize_isa (fpu_bits, arm_selected_fpu->isa_bits);\n-      bitmap_and_compl (target->isa, target->isa, isa_all_fpubits_internal);\n+      /* Clear out ALL bits relating to the FPU/simd extensions, to avoid\n+\t potentially invalid combinations later on that we can't match.  */\n+      bitmap_and_compl (target->isa, target->isa, isa_all_fpbits);\n       bitmap_ior (target->isa, target->isa, fpu_bits);\n     }\n \n@@ -3856,7 +3859,7 @@ arm_options_perform_arch_sanity_checks (void)\n \t  arm_pcs_default = ARM_PCS_AAPCS_VFP;\n \t  if (!bitmap_bit_p (arm_active_target.isa, isa_bit_vfpv2)\n \t      && !bitmap_bit_p (arm_active_target.isa, isa_bit_mve))\n-\t    error (\"%<-mfloat-abi=hard%>: selected processor lacks an FPU\");\n+\t    error (\"%<-mfloat-abi=hard%>: selected architecture lacks an FPU\");\n \t}\n       else\n \tarm_pcs_default = ARM_PCS_AAPCS;"}]}