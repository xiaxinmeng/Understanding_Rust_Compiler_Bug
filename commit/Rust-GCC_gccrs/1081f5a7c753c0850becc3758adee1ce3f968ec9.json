{"sha": "1081f5a7c753c0850becc3758adee1ce3f968ec9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA4MWY1YTdjNzUzYzA4NTBiZWNjMzc1OGFkZWUxY2UzZjk2OGVjOQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-04-17T08:14:08Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-04-17T08:14:08Z"}, "message": "gigi.h (enum standard_datatypes): Add new values ADT_sbitsize_one_node and ADT_sbitsize_unit_node.\n\n\t* gcc-interface/gigi.h (enum standard_datatypes): Add new values\n\tADT_sbitsize_one_node and ADT_sbitsize_unit_node.\n\t(sbitsize_one_node): New macro.\n\t(sbitsize_unit_node): Likewise.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Subtype>: Fix\n\tlatent bug in the computation of subrange_p.  Fold wider_p predicate.\n\t(cannot_be_superflat_p): Use an explicitly signed 64-bit type to do\n\tthe final comparison.\n\t(make_aligning_type): Build real negation and use sizetype throughout\n\tthe offset computation.\n\t(maybe_pad_type): Do not issue the warning when the new size expression\n\tis too complex.\n\t(annotate_value) <INTEGER_CST>: Simplify code handling negative values.\n\t* gcc-interface/misc.c (gnat_init): Initialize sbitsize_one_node and\n\tsbitsize_unit_node.\n\t* gcc-interface/trans.c (Attribute_to_gnu) <Attr_Pool_Address>: Fold\n\tdouble negation.\n\t(gnat_to_gnu) <N_Free_Statement>: Likewise.\n\t* gcc-interface/utils.c (convert): Use sbitsize_unit_node.\n\t* gcc-interface/utils2.c (compare_arrays): Compute real lengths and use\n\tconstants in sizetype.  Remove dead code and tweak comments.  Generate\n\tequality instead of inequality comparisons for zero length tests.\n\nFrom-SVN: r158461", "tree": {"sha": "f52b778a479d5827dea31191f94c7e6e2e92abf9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f52b778a479d5827dea31191f94c7e6e2e92abf9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1081f5a7c753c0850becc3758adee1ce3f968ec9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1081f5a7c753c0850becc3758adee1ce3f968ec9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1081f5a7c753c0850becc3758adee1ce3f968ec9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1081f5a7c753c0850becc3758adee1ce3f968ec9/comments", "author": null, "committer": null, "parents": [{"sha": "80d56d040e2050cf478e7e0703d5fe9af30eaac1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80d56d040e2050cf478e7e0703d5fe9af30eaac1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80d56d040e2050cf478e7e0703d5fe9af30eaac1"}], "stats": {"total": 206, "additions": 105, "deletions": 101}, "files": [{"sha": "21800d82dc7521f8230edc32c29ae768bffa3aa3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1081f5a7c753c0850becc3758adee1ce3f968ec9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1081f5a7c753c0850becc3758adee1ce3f968ec9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1081f5a7c753c0850becc3758adee1ce3f968ec9", "patch": "@@ -1,3 +1,28 @@\n+2010-04-17  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (enum standard_datatypes): Add new values\n+\tADT_sbitsize_one_node and ADT_sbitsize_unit_node.\n+\t(sbitsize_one_node): New macro.\n+\t(sbitsize_unit_node): Likewise.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Subtype>: Fix\n+\tlatent bug in the computation of subrange_p.  Fold wider_p predicate.\n+\t(cannot_be_superflat_p): Use an explicitly signed 64-bit type to do\n+\tthe final comparison.\n+\t(make_aligning_type): Build real negation and use sizetype throughout\n+\tthe offset computation.\n+\t(maybe_pad_type): Do not issue the warning when the new size expression\n+\tis too complex.\n+\t(annotate_value) <INTEGER_CST>: Simplify code handling negative values.\n+\t* gcc-interface/misc.c (gnat_init): Initialize sbitsize_one_node and\n+\tsbitsize_unit_node.\n+\t* gcc-interface/trans.c (Attribute_to_gnu) <Attr_Pool_Address>: Fold\n+\tdouble negation.\n+\t(gnat_to_gnu) <N_Free_Statement>: Likewise.\n+\t* gcc-interface/utils.c (convert): Use sbitsize_unit_node.\n+\t* gcc-interface/utils2.c (compare_arrays): Compute real lengths and use\n+\tconstants in sizetype.  Remove dead code and tweak comments.  Generate\n+\tequality instead of inequality comparisons for zero length tests.\n+\n 2010-04-16  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/gigi.h (gnat_init_decl_processing): Delete."}, {"sha": "b7fd3318ceed7edb07363e2c60818f07f0d71882", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 28, "deletions": 44, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1081f5a7c753c0850becc3758adee1ce3f968ec9/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1081f5a7c753c0850becc3758adee1ce3f968ec9/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=1081f5a7c753c0850becc3758adee1ce3f968ec9", "patch": "@@ -2115,11 +2115,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      const int prec_comp\n \t\t= compare_tree_int (TYPE_RM_SIZE (gnu_index_type),\n \t\t\t\t    TYPE_PRECISION (sizetype));\n-\t      const bool subrange_p = (prec_comp < 0)\n-\t\t\t\t      || (prec_comp == 0\n-\t\t\t\t\t  && TYPE_UNSIGNED (gnu_index_type)\n-\t\t\t\t\t     == TYPE_UNSIGNED (sizetype));\n-\t      const bool wider_p = (prec_comp > 0);\n+\t      const bool subrange_p = (prec_comp < 0\n+\t\t\t\t       && (TYPE_UNSIGNED (gnu_index_type)\n+\t\t\t\t\t   || !TYPE_UNSIGNED (sizetype)))\n+ \t\t\t\t      || (prec_comp == 0\n+ \t\t\t\t\t  && TYPE_UNSIGNED (gnu_index_type)\n+ \t\t\t\t\t     == TYPE_UNSIGNED (sizetype));\n \t      tree gnu_orig_min = TYPE_MIN_VALUE (gnu_index_type);\n \t      tree gnu_orig_max = TYPE_MAX_VALUE (gnu_index_type);\n \t      tree gnu_min = convert (sizetype, gnu_orig_min);\n@@ -2298,7 +2299,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t      && TREE_CODE (TREE_TYPE (gnu_index_type))\n \t\t\t != INTEGER_TYPE)\n \t\t  || TYPE_BIASED_REPRESENTATION_P (gnu_index_type)\n-\t\t  || wider_p)\n+\t\t  || prec_comp > 0)\n \t\tneed_index_type_struct = true;\n \t    }\n \n@@ -5381,7 +5382,7 @@ cannot_be_superflat_p (Node_Id gnat_range)\n {\n   Node_Id gnat_lb = Low_Bound (gnat_range), gnat_hb = High_Bound (gnat_range);\n   Node_Id scalar_range;\n-  tree gnu_lb, gnu_hb;\n+  tree gnu_lb, gnu_hb, gnu_lb_minus_one;\n \n   /* If the low bound is not constant, try to find an upper bound.  */\n   while (Nkind (gnat_lb) != N_Integer_Literal\n@@ -5401,19 +5402,23 @@ cannot_be_superflat_p (Node_Id gnat_range)\n \t     || Nkind (scalar_range) == N_Range))\n     gnat_hb = Low_Bound (scalar_range);\n \n-  if (!(Nkind (gnat_lb) == N_Integer_Literal\n-\t&& Nkind (gnat_hb) == N_Integer_Literal))\n+  /* If we have failed to find constant bounds, punt.  */\n+  if (Nkind (gnat_lb) != N_Integer_Literal\n+      || Nkind (gnat_hb) != N_Integer_Literal)\n     return false;\n \n-  gnu_lb = UI_To_gnu (Intval (gnat_lb), bitsizetype);\n-  gnu_hb = UI_To_gnu (Intval (gnat_hb), bitsizetype);\n+  /* We need at least a signed 64-bit type to catch most cases.  */\n+  gnu_lb = UI_To_gnu (Intval (gnat_lb), sbitsizetype);\n+  gnu_hb = UI_To_gnu (Intval (gnat_hb), sbitsizetype);\n+  if (TREE_OVERFLOW (gnu_lb) || TREE_OVERFLOW (gnu_hb))\n+    return false;\n \n   /* If the low bound is the smallest integer, nothing can be smaller.  */\n-  gnu_lb = size_binop (MINUS_EXPR, gnu_lb, bitsize_one_node);\n-  if (TREE_OVERFLOW (gnu_lb))\n+  gnu_lb_minus_one = size_binop (MINUS_EXPR, gnu_lb, sbitsize_one_node);\n+  if (TREE_OVERFLOW (gnu_lb_minus_one))\n     return true;\n \n-  return (tree_int_cst_lt (gnu_hb, gnu_lb) == 0);\n+  return !tree_int_cst_lt (gnu_hb, gnu_lb_minus_one);\n }\n \n /* Return true if GNU_EXPR is (essentially) the address of a CONSTRUCTOR.  */\n@@ -5876,7 +5881,6 @@ make_aligning_type (tree type, unsigned int align, tree size,\n   /* We will be crafting a record type with one field at a position set to be\n      the next multiple of ALIGN past record'address + room bytes.  We use a\n      record placeholder to express record'address.  */\n-\n   tree record_type = make_node (RECORD_TYPE);\n   tree record = build0 (PLACEHOLDER_EXPR, record_type);\n \n@@ -5896,7 +5900,6 @@ make_aligning_type (tree type, unsigned int align, tree size,\n \n      Every length is in sizetype bytes there, except \"pos\" which has to be\n      set as a bit position in the GCC tree for the record.  */\n-\n   tree room_st = size_int (room);\n   tree vblock_addr_st = size_binop (PLUS_EXPR, record_addr_st, room_st);\n   tree voffset_st, pos, field;\n@@ -5911,13 +5914,11 @@ make_aligning_type (tree type, unsigned int align, tree size,\n   /* Compute VOFFSET and then POS.  The next byte position multiple of some\n      alignment after some address is obtained by \"and\"ing the alignment minus\n      1 with the two's complement of the address.   */\n-\n   voffset_st = size_binop (BIT_AND_EXPR,\n-\t\t\t   size_diffop (size_zero_node, vblock_addr_st),\n-\t\t\t   ssize_int ((align / BITS_PER_UNIT) - 1));\n+\t\t\t   fold_build1 (NEGATE_EXPR, sizetype, vblock_addr_st),\n+\t\t\t   size_int ((align / BITS_PER_UNIT) - 1));\n \n   /* POS = (ROOM + VOFFSET) * BIT_PER_UNIT, in bitsizetype.  */\n-\n   pos = size_binop (MULT_EXPR,\n \t\t    convert (bitsizetype,\n \t\t\t     size_binop (PLUS_EXPR, room_st, voffset_st)),\n@@ -5936,7 +5937,6 @@ make_aligning_type (tree type, unsigned int align, tree size,\n      consequences on the alignment computation, and create_field_decl would\n      make one without this special argument, for instance because of the\n      complex position expression.  */\n-\n   field = create_field_decl (get_identifier (\"F\"), type, record_type,\n                              1, size, pos, -1);\n   TYPE_FIELDS (record_type) = field;\n@@ -6287,6 +6287,7 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n   if (Present (gnat_entity)\n       && size\n       && TREE_CODE (size) != MAX_EXPR\n+      && TREE_CODE (size) != COND_EXPR\n       && !operand_equal_p (size, orig_size, 0)\n       && !(TREE_CODE (size) == INTEGER_CST\n \t   && TREE_CODE (orig_size) == INTEGER_CST\n@@ -7123,33 +7124,16 @@ annotate_value (tree gnu_size)\n       if (TREE_OVERFLOW (gnu_size))\n \treturn No_Uint;\n \n-      /* This may have come from a conversion from some smaller type,\n-\t so ensure this is in bitsizetype.  */\n+      /* This may come from a conversion from some smaller type, so ensure\n+\t this is in bitsizetype.  */\n       gnu_size = convert (bitsizetype, gnu_size);\n \n-      /* For negative values, use NEGATE_EXPR of the supplied value.  */\n+      /* For a negative value, use NEGATE_EXPR of the opposite.  Such values\n+\t appear in expressions containing aligning patterns.  */\n       if (tree_int_cst_sgn (gnu_size) < 0)\n \t{\n-\t  /* The ridiculous code below is to handle the case of the largest\n-\t     negative integer.  */\n-\t  tree negative_size = size_diffop (bitsize_zero_node, gnu_size);\n-\t  bool adjust = false;\n-\t  tree temp;\n-\n-\t  if (TREE_OVERFLOW (negative_size))\n-\t    {\n-\t      negative_size\n-\t\t= size_binop (MINUS_EXPR, bitsize_zero_node,\n-\t\t\t      size_binop (PLUS_EXPR, gnu_size,\n-\t\t\t\t\t  bitsize_one_node));\n-\t      adjust = true;\n-\t    }\n-\n-\t  temp = build1 (NEGATE_EXPR, bitsizetype, negative_size);\n-\t  if (adjust)\n-\t    temp = build2 (MINUS_EXPR, bitsizetype, temp, bitsize_one_node);\n-\n-\t  return annotate_value (temp);\n+\t  tree op_size = fold_build1 (NEGATE_EXPR, bitsizetype, gnu_size);\n+\t  return annotate_value (build1 (NEGATE_EXPR, bitsizetype, op_size));\n \t}\n \n       return UI_From_gnu (gnu_size);"}, {"sha": "224abe8e80f44f5f7a150afcb7f798dec39a2f16", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1081f5a7c753c0850becc3758adee1ce3f968ec9/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1081f5a7c753c0850becc3758adee1ce3f968ec9/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=1081f5a7c753c0850becc3758adee1ce3f968ec9", "patch": "@@ -356,9 +356,15 @@ enum standard_datatypes\n   /* Type declaration node  <==> typedef virtual void *T() */\n   ADT_fdesc_type,\n \n-  /* Null pointer for above type */\n+  /* Null pointer for above type.  */\n   ADT_null_fdesc,\n \n+  /* Value 1 in signed bitsizetype.  */\n+  ADT_sbitsize_one_node,\n+\n+  /* Value BITS_PER_UNIT in signed bitsizetype.  */\n+  ADT_sbitsize_unit_node,\n+\n   /* Function declaration nodes for run-time functions for allocating memory.\n      Ada allocators cause calls to these functions to be generated.  Malloc32\n      is used only on 64bit systems needing to allocate 32bit memory.  */\n@@ -401,6 +407,8 @@ extern GTY(()) tree gnat_raise_decls[(int) LAST_REASON_CODE + 1];\n #define ptr_void_ftype gnat_std_decls[(int) ADT_ptr_void_ftype]\n #define fdesc_type_node gnat_std_decls[(int) ADT_fdesc_type]\n #define null_fdesc_node gnat_std_decls[(int) ADT_null_fdesc]\n+#define sbitsize_one_node gnat_std_decls[(int) ADT_sbitsize_one_node]\n+#define sbitsize_unit_node gnat_std_decls[(int) ADT_sbitsize_unit_node]\n #define malloc_decl gnat_std_decls[(int) ADT_malloc_decl]\n #define malloc32_decl gnat_std_decls[(int) ADT_malloc32_decl]\n #define free_decl gnat_std_decls[(int) ADT_free_decl]"}, {"sha": "52fe65a560d772a7181cf081217ccedd8e85ed7e", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1081f5a7c753c0850becc3758adee1ce3f968ec9/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1081f5a7c753c0850becc3758adee1ce3f968ec9/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=1081f5a7c753c0850becc3758adee1ce3f968ec9", "patch": "@@ -407,6 +407,8 @@ gnat_init (void)\n   SET_TYPE_RM_SIZE (boolean_type_node, bitsize_int (1));\n \n   build_common_tree_nodes_2 (0);\n+  sbitsize_one_node = sbitsize_int (1);\n+  sbitsize_unit_node = sbitsize_int (BITS_PER_UNIT);\n   boolean_true_node = TYPE_MAX_VALUE (boolean_type_node);\n \n   ptr_void_type_node = build_pointer_type (void_type_node);"}, {"sha": "4b7946c865eee9e4d75590951438fcf5c45603e3", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1081f5a7c753c0850becc3758adee1ce3f968ec9/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1081f5a7c753c0850becc3758adee1ce3f968ec9/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=1081f5a7c753c0850becc3758adee1ce3f968ec9", "patch": "@@ -1356,15 +1356,9 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t  {\n \t    tree gnu_char_ptr_type = build_pointer_type (char_type_node);\n \t    tree gnu_pos = byte_position (TYPE_FIELDS (gnu_obj_type));\n-\t    tree gnu_byte_offset\n-\t      = convert (sizetype,\n-\t\t\t size_diffop (size_zero_node, gnu_pos));\n-\t    gnu_byte_offset\n-\t      = fold_build1 (NEGATE_EXPR, sizetype, gnu_byte_offset);\n-\n \t    gnu_ptr = convert (gnu_char_ptr_type, gnu_ptr);\n \t    gnu_ptr = build_binary_op (POINTER_PLUS_EXPR, gnu_char_ptr_type,\n-\t\t\t\t       gnu_ptr, gnu_byte_offset);\n+\t\t\t\t       gnu_ptr, gnu_pos);\n \t  }\n \n \tgnu_result = convert (gnu_result_type, gnu_ptr);\n@@ -5399,15 +5393,9 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    {\n \t      tree gnu_char_ptr_type = build_pointer_type (char_type_node);\n \t      tree gnu_pos = byte_position (TYPE_FIELDS (gnu_obj_type));\n-\t      tree gnu_byte_offset\n-\t\t= convert (sizetype,\n-\t\t\t   size_diffop (size_zero_node, gnu_pos));\n-\t      gnu_byte_offset\n-\t\t= fold_build1 (NEGATE_EXPR, sizetype, gnu_byte_offset);\n-\n \t      gnu_ptr = convert (gnu_char_ptr_type, gnu_ptr);\n \t      gnu_ptr = build_binary_op (POINTER_PLUS_EXPR, gnu_char_ptr_type,\n-\t\t\t\t\t gnu_ptr, gnu_byte_offset);\n+\t\t\t\t\t gnu_ptr, gnu_pos);\n \t    }\n \n \t  gnu_result"}, {"sha": "668226bd906fd3efacebe7ba2d81fdb95411bc4d", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1081f5a7c753c0850becc3758adee1ce3f968ec9/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1081f5a7c753c0850becc3758adee1ce3f968ec9/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=1081f5a7c753c0850becc3758adee1ce3f968ec9", "patch": "@@ -4066,9 +4066,8 @@ convert (tree type, tree expr)\n \t  tree bit_diff\n \t    = size_diffop (bit_position (TYPE_FIELDS (TREE_TYPE (etype))),\n \t\t\t   bit_position (TYPE_FIELDS (TREE_TYPE (type))));\n-\t  tree byte_diff = size_binop (CEIL_DIV_EXPR, bit_diff,\n-\t\t\t\t       sbitsize_int (BITS_PER_UNIT));\n-\n+\t  tree byte_diff\n+\t    = size_binop (CEIL_DIV_EXPR, bit_diff, sbitsize_unit_node);\n \t  expr = build1 (NOP_EXPR, type, expr);\n \t  TREE_CONSTANT (expr) = TREE_CONSTANT (TREE_OPERAND (expr, 0));\n \t  if (integer_zerop (byte_diff))"}, {"sha": "ca35cc7458a6a2ad0b2ef6579434a19731e58994", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 37, "deletions": 39, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1081f5a7c753c0850becc3758adee1ce3f968ec9/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1081f5a7c753c0850becc3758adee1ce3f968ec9/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=1081f5a7c753c0850becc3758adee1ce3f968ec9", "patch": "@@ -260,28 +260,27 @@ compare_arrays (tree result_type, tree a1, tree a2)\n     a2 = gnat_protect_expr (a2);\n \n   /* Process each dimension separately and compare the lengths.  If any\n-     dimension has a size known to be zero, set SIZE_ZERO_P to 1 to\n-     suppress the comparison of the data.  */\n+     dimension has a length known to be zero, set LENGTH_ZERO_P to true\n+     in order to suppress the comparison of the data at the end.  */\n   while (TREE_CODE (t1) == ARRAY_TYPE && TREE_CODE (t2) == ARRAY_TYPE)\n     {\n       tree lb1 = TYPE_MIN_VALUE (TYPE_DOMAIN (t1));\n       tree ub1 = TYPE_MAX_VALUE (TYPE_DOMAIN (t1));\n       tree lb2 = TYPE_MIN_VALUE (TYPE_DOMAIN (t2));\n       tree ub2 = TYPE_MAX_VALUE (TYPE_DOMAIN (t2));\n-      tree bt = get_base_type (TREE_TYPE (lb1));\n-      tree length1 = fold_build2 (MINUS_EXPR, bt, ub1, lb1);\n-      tree length2 = fold_build2 (MINUS_EXPR, bt, ub2, lb2);\n+      tree length1 = size_binop (PLUS_EXPR, size_binop (MINUS_EXPR, ub1, lb1),\n+\t\t\t\t size_one_node);\n+      tree length2 = size_binop (PLUS_EXPR, size_binop (MINUS_EXPR, ub2, lb2),\n+\t\t\t\t size_one_node);\n       tree comparison, this_a1_is_null, this_a2_is_null;\n-      tree nbt, tem;\n-      bool btem;\n \n       /* If the length of the first array is a constant, swap our operands\n-\t unless the length of the second array is the constant zero.\n-\t Note that we have set the `length' values to the length - 1.  */\n-      if (TREE_CODE (length1) == INTEGER_CST\n-\t  && !integer_zerop (fold_build2 (PLUS_EXPR, bt, length2,\n-\t\t\t\t\t  convert (bt, integer_one_node))))\n+\t unless the length of the second array is the constant zero.  */\n+      if (TREE_CODE (length1) == INTEGER_CST && !integer_zerop (length2))\n \t{\n+\t  tree tem;\n+\t  bool btem;\n+\n \t  tem = a1, a1 = a2, a2 = tem;\n \t  tem = t1, t1 = t2, t2 = tem;\n \t  tem = lb1, lb1 = lb2, lb2 = tem;\n@@ -292,57 +291,56 @@ compare_arrays (tree result_type, tree a1, tree a2)\n \t  a2_side_effects_p = btem;\n \t}\n \n-      /* If the length of this dimension in the second array is the constant\n-\t zero, we can just go inside the original bounds for the first\n-\t array and see if last < first.  */\n-      if (integer_zerop (fold_build2 (PLUS_EXPR, bt, length2,\n-\t\t\t\t      convert (bt, integer_one_node))))\n+      /* If the length of the second array is the constant zero, we can just\n+\t use the original stored bounds for the first array and see whether\n+\t last < first holds.  */\n+      if (integer_zerop (length2))\n \t{\n-\t  tree ub = TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n-\t  tree lb = TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n+\t  length_zero_p = true;\n \n-\t  comparison = build_binary_op (LT_EXPR, result_type, ub, lb);\n+\t  ub1 = TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n+\t  lb1 = TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n+\n+\t  comparison = build_binary_op (LT_EXPR, result_type, ub1, lb1);\n \t  comparison = SUBSTITUTE_PLACEHOLDER_IN_EXPR (comparison, a1);\n \t  if (EXPR_P (comparison))\n \t    SET_EXPR_LOCATION (comparison, input_location);\n \n-\t  length1 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (length1, a1);\n-\n-\t  length_zero_p = true;\n \t  this_a1_is_null = comparison;\n \t  this_a2_is_null = convert (result_type, boolean_true_node);\n \t}\n \n-      /* If the length is some other constant value, we know that the\n-\t this dimension in the first array cannot be superflat, so we\n-\t can just use its length from the actual stored bounds.  */\n+      /* Otherwise, if the length is some other constant value, we know that\n+\t this dimension in the second array cannot be superflat, so we can\n+\t just use its length computed from the actual stored bounds.  */\n       else if (TREE_CODE (length2) == INTEGER_CST)\n \t{\n+\t  tree bt;\n+\n \t  ub1 = TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n \t  lb1 = TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n \t  /* Note that we know that UB2 and LB2 are constant and hence\n \t     cannot contain a PLACEHOLDER_EXPR.  */\n \t  ub2 = TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t2)));\n \t  lb2 = TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t2)));\n-\t  nbt = get_base_type (TREE_TYPE (ub1));\n+\t  bt = get_base_type (TREE_TYPE (ub1));\n \n \t  comparison\n \t    = build_binary_op (EQ_EXPR, result_type,\n-\t\t\t       build_binary_op (MINUS_EXPR, nbt, ub1, lb1),\n-\t\t\t       build_binary_op (MINUS_EXPR, nbt, ub2, lb2));\n+\t\t\t       build_binary_op (MINUS_EXPR, bt, ub1, lb1),\n+\t\t\t       build_binary_op (MINUS_EXPR, bt, ub2, lb2));\n \t  comparison = SUBSTITUTE_PLACEHOLDER_IN_EXPR (comparison, a1);\n \t  if (EXPR_P (comparison))\n \t    SET_EXPR_LOCATION (comparison, input_location);\n \n-\t  length1 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (length1, a1);\n-\n \t  this_a1_is_null = build_binary_op (LT_EXPR, result_type, ub1, lb1);\n \t  if (EXPR_P (this_a1_is_null))\n \t    SET_EXPR_LOCATION (this_a1_is_null, input_location);\n+\n \t  this_a2_is_null = convert (result_type, boolean_false_node);\n \t}\n \n-      /* Otherwise compare the computed lengths.  */\n+      /* Otherwise, compare the computed lengths.  */\n       else\n \t{\n \t  length1 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (length1, a1);\n@@ -353,32 +351,32 @@ compare_arrays (tree result_type, tree a1, tree a2)\n \t  if (EXPR_P (comparison))\n \t    SET_EXPR_LOCATION (comparison, input_location);\n \n-\t  this_a1_is_null\n-\t    = build_binary_op (LT_EXPR, result_type, length1,\n-\t\t\t       convert (bt, integer_zero_node));\n+\t  this_a1_is_null = build_binary_op (EQ_EXPR, result_type, length1,\n+\t\t\t\t\t     size_zero_node);\n \t  if (EXPR_P (this_a1_is_null))\n \t    SET_EXPR_LOCATION (this_a1_is_null, input_location);\n \n-\t  this_a2_is_null\n-\t    = build_binary_op (LT_EXPR, result_type, length2,\n-\t\t\t       convert (bt, integer_zero_node));\n+\t  this_a2_is_null = build_binary_op (EQ_EXPR, result_type, length2,\n+\t\t\t\t\t     size_zero_node);\n \t  if (EXPR_P (this_a2_is_null))\n \t    SET_EXPR_LOCATION (this_a2_is_null, input_location);\n \t}\n \n+      /* Append expressions for this dimension to the final expressions.  */\n       result = build_binary_op (TRUTH_ANDIF_EXPR, result_type,\n \t\t\t\tresult, comparison);\n \n       a1_is_null = build_binary_op (TRUTH_ORIF_EXPR, result_type,\n \t\t\t\t    this_a1_is_null, a1_is_null);\n+\n       a2_is_null = build_binary_op (TRUTH_ORIF_EXPR, result_type,\n \t\t\t\t    this_a2_is_null, a2_is_null);\n \n       t1 = TREE_TYPE (t1);\n       t2 = TREE_TYPE (t2);\n     }\n \n-  /* Unless the size of some bound is known to be zero, compare the\n+  /* Unless the length of some dimension is known to be zero, compare the\n      data in the array.  */\n   if (!length_zero_p)\n     {"}]}