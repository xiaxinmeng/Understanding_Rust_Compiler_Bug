{"sha": "f9cacebbde8427e0537e79fe87dd1c89251a2582", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjljYWNlYmJkZTg0MjdlMDUzN2U3OWZlODdkZDFjODkyNTFhMjU4Mg==", "commit": {"author": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2019-03-18T13:13:27Z"}, "committer": {"name": "Andrew Stubbs", "email": "ams@gcc.gnu.org", "date": "2019-03-18T13:13:27Z"}, "message": "Implement circular print buffer.\n\n2019-03-18  Andrew Stubbs  <ams@codesourcery.com>\n\n\tgcc/\n\t* config/gcn/gcn-run.c (struct output): Make next_output unsigned.\n\tExtend queue to 1024 entries.\n\tAdd \"consumed\" field.\n\t(gomp_print_output): Remove print_index parameter.\n\tAdd final parameter.\n\tChange limit to unsigned.\n\tUse consumed field to implement circular buffer.\n\tDetect interrupted print in final pass.\n\tFlush output at the end.\n\t(run): Update gomp_print_output usage.\n\t(main): Initialize kernargs->output_data.consumed.\n\nFrom-SVN: r269764", "tree": {"sha": "6c5e24f93ba2899ab7eed74ea970ec3fdfef6bf2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c5e24f93ba2899ab7eed74ea970ec3fdfef6bf2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9cacebbde8427e0537e79fe87dd1c89251a2582", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9cacebbde8427e0537e79fe87dd1c89251a2582", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9cacebbde8427e0537e79fe87dd1c89251a2582", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9cacebbde8427e0537e79fe87dd1c89251a2582/comments", "author": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c57546fe94712a723bc2e123445dc5d9b0a0ca1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c57546fe94712a723bc2e123445dc5d9b0a0ca1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c57546fe94712a723bc2e123445dc5d9b0a0ca1a"}], "stats": {"total": 70, "additions": 49, "deletions": 21}, "files": [{"sha": "4688296cb8a0064d8570784a9cd55f0f9e26c615", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9cacebbde8427e0537e79fe87dd1c89251a2582/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9cacebbde8427e0537e79fe87dd1c89251a2582/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f9cacebbde8427e0537e79fe87dd1c89251a2582", "patch": "@@ -1,3 +1,17 @@\n+2019-03-18  Andrew Stubbs  <ams@codesourcery.com>\n+\n+\t* config/gcn/gcn-run.c (struct output): Make next_output unsigned.\n+\tExtend queue to 1024 entries.\n+\tAdd \"consumed\" field.\n+\t(gomp_print_output): Remove print_index parameter.\n+\tAdd final parameter.\n+\tChange limit to unsigned.\n+\tUse consumed field to implement circular buffer.\n+\tDetect interrupted print in final pass.\n+\tFlush output at the end.\n+\t(run): Update gomp_print_output usage.\n+\t(main): Initialize kernargs->output_data.consumed.\n+\n 2019-03-18  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vect-loop.c (vect_estimate_min_profitable_iters): Fix the"}, {"sha": "00a71014c2042783bf95b85e51be8162b6f0b477", "filename": "gcc/config/gcn/gcn-run.c", "status": "modified", "additions": 35, "deletions": 21, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9cacebbde8427e0537e79fe87dd1c89251a2582/gcc%2Fconfig%2Fgcn%2Fgcn-run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9cacebbde8427e0537e79fe87dd1c89251a2582/gcc%2Fconfig%2Fgcn%2Fgcn-run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn-run.c?ref=f9cacebbde8427e0537e79fe87dd1c89251a2582", "patch": "@@ -601,7 +601,7 @@ struct kernargs\n   struct output\n   {\n     int return_value;\n-    int next_output;\n+    unsigned int next_output;\n     struct printf_data\n     {\n       int written;\n@@ -613,7 +613,8 @@ struct kernargs\n \tdouble dvalue;\n \tchar text[128];\n       };\n-    } queue[1000];\n+    } queue[1024];\n+    unsigned int consumed;\n   } output_data;\n \n   struct heap\n@@ -624,21 +625,34 @@ struct kernargs\n };\n \n /* Print any console output from the kernel.\n-   We print all entries from print_index to the next entry without a \"written\"\n-   flag.  Subsequent calls should use the returned print_index value to resume\n-   from the same point.  */\n+   We print all entries from \"consumed\" to the next entry without a \"written\"\n+   flag, or \"next_output\" is reached.  The buffer is circular, but the\n+   indices are absolute.  It is assumed the kernel will stop writing data\n+   if \"next_output\" wraps (becomes smaller than \"consumed\").  */\n void\n-gomp_print_output (struct kernargs *kernargs, int *print_index)\n+gomp_print_output (struct kernargs *kernargs, bool final)\n {\n-  int limit = (sizeof (kernargs->output_data.queue)\n-\t       / sizeof (kernargs->output_data.queue[0]));\n+  unsigned int limit = (sizeof (kernargs->output_data.queue)\n+\t\t\t/ sizeof (kernargs->output_data.queue[0]));\n \n-  int i;\n-  for (i = *print_index; i < limit; i++)\n+  unsigned int from = __atomic_load_n (&kernargs->output_data.consumed,\n+\t\t\t\t       __ATOMIC_ACQUIRE);\n+  unsigned int to = kernargs->output_data.next_output;\n+\n+  if (from > to)\n+    {\n+      /* Overflow.  */\n+      if (final)\n+\tprintf (\"GCN print buffer overflowed.\\n\");\n+      return;\n+    }\n+\n+  unsigned int i;\n+  for (i = from; i < to; i++)\n     {\n-      struct printf_data *data = &kernargs->output_data.queue[i];\n+      struct printf_data *data = &kernargs->output_data.queue[i%limit];\n \n-      if (!data->written)\n+      if (!data->written && !final)\n \tbreak;\n \n       switch (data->type)\n@@ -655,16 +669,16 @@ gomp_print_output (struct kernargs *kernargs, int *print_index)\n \tcase 3:\n \t  printf (\"%.128s%.128s\", data->msg, data->text);\n \t  break;\n+\tdefault:\n+\t  printf (\"GCN print buffer error!\\n\");\n+\t  break;\n \t}\n \n       data->written = 0;\n+      __atomic_store_n (&kernargs->output_data.consumed, i+1,\n+\t\t\t__ATOMIC_RELEASE);\n     }\n-\n-  if (*print_index < limit && i == limit\n-      && kernargs->output_data.next_output > limit)\n-    printf (\"WARNING: GCN print buffer exhausted.\\n\");\n-\n-  *print_index = i;\n+  fflush (stdout);\n }\n \n /* Execute an already-loaded kernel on the device.  */\n@@ -711,16 +725,15 @@ run (void *kernargs)\n   hsa_fns.hsa_queue_store_write_index_relaxed_fn (queue, index + 1);\n   hsa_fns.hsa_signal_store_relaxed_fn (queue->doorbell_signal, index);\n   /* Kernel running ......  */\n-  int print_index = 0;\n   while (hsa_fns.hsa_signal_wait_relaxed_fn (signal, HSA_SIGNAL_CONDITION_LT,\n \t\t\t\t\t     1, 1000000,\n \t\t\t\t\t     HSA_WAIT_STATE_ACTIVE) != 0)\n     {\n       usleep (10000);\n-      gomp_print_output (kernargs, &print_index);\n+      gomp_print_output (kernargs, false);\n     }\n \n-  gomp_print_output (kernargs, &print_index);\n+  gomp_print_output (kernargs, true);\n \n   if (debug)\n     fprintf (stderr, \"Kernel exited\\n\");\n@@ -797,6 +810,7 @@ main (int argc, char *argv[])\n   for (unsigned i = 0; i < (sizeof (kernargs->output_data.queue)\n \t\t\t    / sizeof (kernargs->output_data.queue[0])); i++)\n     kernargs->output_data.queue[i].written = 0;\n+  kernargs->output_data.consumed = 0;\n   int offset = 0;\n   for (int i = 0; i < kernel_argc; i++)\n     {"}]}