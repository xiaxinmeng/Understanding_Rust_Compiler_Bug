{"sha": "cd66d1a11b97fdfe3f99fcea1042d8eba8387784", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Q2NmQxYTExYjk3ZmRmZTNmOTlmY2VhMTA0MmQ4ZWJhODM4Nzc4NA==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargls@comcast.net", "date": "2005-05-28T18:28:31Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2005-05-28T18:28:31Z"}, "message": "arith.c (gfc_arith_init_1): Fix off by one problem;\n\n* arith.c (gfc_arith_init_1): Fix off by one problem;\n  (gfc_check_integer_range): Chop extra bits in subnormal numbers.\n\nFrom-SVN: r100299", "tree": {"sha": "6fcc61181d817c363e2a3e5c9581f6dab7f025cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6fcc61181d817c363e2a3e5c9581f6dab7f025cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd66d1a11b97fdfe3f99fcea1042d8eba8387784", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd66d1a11b97fdfe3f99fcea1042d8eba8387784", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd66d1a11b97fdfe3f99fcea1042d8eba8387784", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd66d1a11b97fdfe3f99fcea1042d8eba8387784/comments", "author": null, "committer": null, "parents": [{"sha": "d416304e6dd69fced760e15912444cb3085a4d6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d416304e6dd69fced760e15912444cb3085a4d6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d416304e6dd69fced760e15912444cb3085a4d6b"}], "stats": {"total": 44, "additions": 41, "deletions": 3}, "files": [{"sha": "097ef92350f17dfa7b52f585b0ad142c94f8ae3d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd66d1a11b97fdfe3f99fcea1042d8eba8387784/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd66d1a11b97fdfe3f99fcea1042d8eba8387784/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=cd66d1a11b97fdfe3f99fcea1042d8eba8387784", "patch": "@@ -1,3 +1,8 @@\n+2005-05-28  Steven G. Kargl  <kargls@comcast.net>\n+\n+\t* arith.c (gfc_arith_init_1): Fix off by one problem;\n+\t(gfc_check_integer_range): Chop extra bits in subnormal numbers.\n+\n 2005-05-28  Jerry DeLisle   <jvdelisle@verizon.net>\n             Steven G. Kargl  <kargls@comcast.net>\n "}, {"sha": "88b6c36e80119ee4e864b93a923aa495ae848501", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd66d1a11b97fdfe3f99fcea1042d8eba8387784/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd66d1a11b97fdfe3f99fcea1042d8eba8387784/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=cd66d1a11b97fdfe3f99fcea1042d8eba8387784", "patch": "@@ -259,9 +259,9 @@ gfc_arith_init_1 (void)\n       mpfr_init (real_info->tiny);\n       mpfr_set (real_info->tiny, b, GFC_RND_MODE);\n \n-      /* subnormal (x) = b**(emin - digit + 1) */\n+      /* subnormal (x) = b**(emin - digit) */\n       mpfr_set_ui (b, real_info->radix, GFC_RND_MODE);\n-      mpfr_pow_si (b, b, real_info->min_exponent - real_info->digits + 1,\n+      mpfr_pow_si (b, b, real_info->min_exponent - real_info->digits,\n \t\t   GFC_RND_MODE);\n \n       mpfr_init (real_info->subnormal);\n@@ -381,9 +381,42 @@ gfc_check_real_range (mpfr_t p, int kind)\n   if (mpfr_sgn (q) == 0)\n     retval = ARITH_OK;\n   else if (mpfr_cmp (q, gfc_real_kinds[i].huge) > 0)\n-      retval = ARITH_OVERFLOW;\n+    retval = ARITH_OVERFLOW;\n   else if (mpfr_cmp (q, gfc_real_kinds[i].subnormal) < 0)\n     retval = ARITH_UNDERFLOW;\n+  else if (mpfr_cmp (q, gfc_real_kinds[i].tiny) < 0)\n+    {\n+      /* MPFR operates on a numbers with a given precision and enormous\n+\texponential range.  To represent subnormal numbers the exponent is\n+\tallowed to become smaller than emin, but always retains the full\n+\tprecision.  This function resets unused bits to 0 to alleviate\n+\trounding problems.  Note, a future version of MPFR will have a\n+ \tmpfr_subnormalize() function, which handles this truncation in a\n+\tmore efficient and robust way.  */\n+\n+      int j, k;\n+      char *bin, *s;\n+      mp_exp_t e;\n+\n+      bin = mpfr_get_str (NULL, &e, gfc_real_kinds[i].radix, 0, q, GMP_RNDN);\n+      k = gfc_real_kinds[i].digits - (gfc_real_kinds[i].min_exponent - e);\n+      for (j = k; j < gfc_real_kinds[i].digits; j++)\n+\tbin[j] = '0';\n+      /* Need space for '0.', bin, 'E', and e */\n+      s = (char *) gfc_getmem (strlen(bin)+10);\n+      sprintf (s, \"0.%sE%d\", bin, (int) e);\n+      mpfr_set_str (q, s, gfc_real_kinds[i].radix, GMP_RNDN);\n+\n+      if (mpfr_sgn (p) < 0)\n+\tmpfr_neg (p, q, GMP_RNDN);\n+      else\n+\tmpfr_set (p, q, GMP_RNDN);\n+\n+      gfc_free (s);\n+      gfc_free (bin);\n+\n+      retval = ARITH_OK;\n+    }\n   else\n     retval = ARITH_OK;\n "}]}