{"sha": "310213d49e368bd3cce0d20febe2666d0262d859", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzEwMjEzZDQ5ZTM2OGJkM2NjZTBkMjBmZWJlMjY2NmQwMjYyZDg1OQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-10-06T07:52:03Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-10-06T07:52:03Z"}, "message": "tree-vectorizer.h (vec_info): New base class for...\n\n2015-10-06  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (vec_info): New base class for...\n\t(_loop_vec_info): ... this and ...\n\t(_bb_vec_info): ... this.\n\t(vect_is_simple_use, vect_is_simple_use_1, new_stmt_vec_info,\n\tvect_analyze_data_refs_alignment, vect_verify_datarefs_alignment,\n\tvect_analyze_data_ref_accesses, vect_analyze_data_refs,\n\tvect_schedule_slp, vect_analyze_slp, vect_pattern_recog,\n\tvect_destroy_datarefs): Adjust interface to take a vec_info *\n\trather than both a loop_vec_info and a bb_vec_info argument.\n\t* tree-vect-data-refs.c (vect_compute_data_refs_alignment,\n\tvect_verify_datarefs_alignment, vect_enhance_data_refs_alignment,\n\tvect_analyze_data_refs_alignment, vect_analyze_data_ref_accesses,\n\tvect_analyze_data_refs, vect_create_data_ref_ptr): Adjust\n\taccordingly.\n\t* tree-vect-loop.c (new_loop_vec_info): Initialize base class.\n\t(destroy_loop_vec_info, vect_analyze_loop_2,\n\tvect_is_simple_reduction_1, get_initial_def_for_induction,\n\tvect_create_epilog_for_reduction, vectorizable_reduction,\n\tvectorizable_live_operation, vect_transform_loop): Adjust.\n\t* tree-vect-patterns.c (type_conversion_p,\n\tvect_recog_widen_mult_pattern, vect_recog_widen_shift_pattern,\n\tvect_recog_rotate_pattern, vect_recog_vector_vector_shift_pattern,\n\tvect_recog_divmod_pattern, vect_recog_mixed_size_cond_pattern,\n\tcheck_bool_pattern, vect_recog_bool_pattern,\n\tvect_mark_pattern_stmts, vect_pattern_recog): Likewise.\n\t* tree-vect-slp.c (vect_get_and_check_slp_defs,\n\tvect_build_slp_tree_1, vect_build_slp_tree, vect_analyze_slp_cost_1,\n\tvect_analyze_slp_instance, vect_analyze_slp, destroy_bb_vec_info,\n\tvect_slp_analyze_bb_1, vect_schedule_slp): Likewise.\n\t(new_bb_vec_info): Initialize base classs.\n\t* tree-vect-stmts.c (record_stmt_cost, process_use,\n\tvect_get_vec_def_for_operand, vect_finish_stmt_generation,\n\tvectorizable_mask_load_store, vectorizable_call,\n\tvectorizable_simd_clone_call, vectorizable_conversion,\n\tvectorizable_assignment, vectorizable_shift,\n\tvectorizable_operation, vectorizable_store,\n\tvectorizable_load, vect_is_simple_cond, vectorizable_condition,\n\tnew_stmt_vec_info, vect_is_simple_use, vect_is_simple_use_1): Likewise.\n\t* tree-vectorizer.c (vect_destroy_datarefs): Likewise.\n\nFrom-SVN: r228514", "tree": {"sha": "f5a9eaf645b48ccc34c866e5475c6abc13db74a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5a9eaf645b48ccc34c866e5475c6abc13db74a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/310213d49e368bd3cce0d20febe2666d0262d859", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/310213d49e368bd3cce0d20febe2666d0262d859", "html_url": "https://github.com/Rust-GCC/gccrs/commit/310213d49e368bd3cce0d20febe2666d0262d859", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/310213d49e368bd3cce0d20febe2666d0262d859/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5097195fabd4ce3611fd363eeb015c176b9a63b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5097195fabd4ce3611fd363eeb015c176b9a63b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5097195fabd4ce3611fd363eeb015c176b9a63b5"}], "stats": {"total": 739, "additions": 357, "deletions": 382}, "files": [{"sha": "9c59c1ea363b596cf977883c88a4fafba29039f1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310213d49e368bd3cce0d20febe2666d0262d859/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310213d49e368bd3cce0d20febe2666d0262d859/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=310213d49e368bd3cce0d20febe2666d0262d859", "patch": "@@ -1,3 +1,45 @@\n+2015-10-06  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (vec_info): New base class for...\n+\t(_loop_vec_info): ... this and ...\n+\t(_bb_vec_info): ... this.\n+\t(vect_is_simple_use, vect_is_simple_use_1, new_stmt_vec_info,\n+\tvect_analyze_data_refs_alignment, vect_verify_datarefs_alignment,\n+\tvect_analyze_data_ref_accesses, vect_analyze_data_refs,\n+\tvect_schedule_slp, vect_analyze_slp, vect_pattern_recog,\n+\tvect_destroy_datarefs): Adjust interface to take a vec_info *\n+\trather than both a loop_vec_info and a bb_vec_info argument.\n+\t* tree-vect-data-refs.c (vect_compute_data_refs_alignment,\n+\tvect_verify_datarefs_alignment, vect_enhance_data_refs_alignment,\n+\tvect_analyze_data_refs_alignment, vect_analyze_data_ref_accesses,\n+\tvect_analyze_data_refs, vect_create_data_ref_ptr): Adjust\n+\taccordingly.\n+\t* tree-vect-loop.c (new_loop_vec_info): Initialize base class.\n+\t(destroy_loop_vec_info, vect_analyze_loop_2,\n+\tvect_is_simple_reduction_1, get_initial_def_for_induction,\n+\tvect_create_epilog_for_reduction, vectorizable_reduction,\n+\tvectorizable_live_operation, vect_transform_loop): Adjust.\n+\t* tree-vect-patterns.c (type_conversion_p,\n+\tvect_recog_widen_mult_pattern, vect_recog_widen_shift_pattern,\n+\tvect_recog_rotate_pattern, vect_recog_vector_vector_shift_pattern,\n+\tvect_recog_divmod_pattern, vect_recog_mixed_size_cond_pattern,\n+\tcheck_bool_pattern, vect_recog_bool_pattern,\n+\tvect_mark_pattern_stmts, vect_pattern_recog): Likewise.\n+\t* tree-vect-slp.c (vect_get_and_check_slp_defs,\n+\tvect_build_slp_tree_1, vect_build_slp_tree, vect_analyze_slp_cost_1,\n+\tvect_analyze_slp_instance, vect_analyze_slp, destroy_bb_vec_info,\n+\tvect_slp_analyze_bb_1, vect_schedule_slp): Likewise.\n+\t(new_bb_vec_info): Initialize base classs.\n+\t* tree-vect-stmts.c (record_stmt_cost, process_use,\n+\tvect_get_vec_def_for_operand, vect_finish_stmt_generation,\n+\tvectorizable_mask_load_store, vectorizable_call,\n+\tvectorizable_simd_clone_call, vectorizable_conversion,\n+\tvectorizable_assignment, vectorizable_shift,\n+\tvectorizable_operation, vectorizable_store,\n+\tvectorizable_load, vect_is_simple_cond, vectorizable_condition,\n+\tnew_stmt_vec_info, vect_is_simple_use, vect_is_simple_use_1): Likewise.\n+\t* tree-vectorizer.c (vect_destroy_datarefs): Likewise.\n+\n 2015-10-05  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \tPR c/65345"}, {"sha": "e653c68a8c17454be6c16e116ffff1f764e77b52", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 36, "deletions": 53, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310213d49e368bd3cce0d20febe2666d0262d859/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310213d49e368bd3cce0d20febe2666d0262d859/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=310213d49e368bd3cce0d20febe2666d0262d859", "patch": "@@ -784,23 +784,17 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n    Return FALSE if a data reference is found that cannot be vectorized.  */\n \n static bool\n-vect_compute_data_refs_alignment (loop_vec_info loop_vinfo,\n-                                  bb_vec_info bb_vinfo)\n+vect_compute_data_refs_alignment (vec_info *vinfo)\n {\n-  vec<data_reference_p> datarefs;\n+  vec<data_reference_p> datarefs = vinfo->datarefs;\n   struct data_reference *dr;\n   unsigned int i;\n \n-  if (loop_vinfo)\n-    datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n-  else\n-    datarefs = BB_VINFO_DATAREFS (bb_vinfo);\n-\n   FOR_EACH_VEC_ELT (datarefs, i, dr)\n     if (STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (DR_STMT (dr)))\n         && !vect_compute_data_ref_alignment (dr))\n       {\n-        if (bb_vinfo)\n+        if (is_a <bb_vec_info> (vinfo))\n           {\n             /* Mark unsupported statement as unvectorizable.  */\n             STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (DR_STMT (dr))) = false;\n@@ -879,18 +873,13 @@ vect_update_misalignment_for_peel (struct data_reference *dr,\n    handled with respect to alignment.  */\n \n bool\n-vect_verify_datarefs_alignment (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n+vect_verify_datarefs_alignment (vec_info *vinfo)\n {\n-  vec<data_reference_p> datarefs;\n+  vec<data_reference_p> datarefs = vinfo->datarefs;\n   struct data_reference *dr;\n   enum dr_alignment_support supportable_dr_alignment;\n   unsigned int i;\n \n-  if (loop_vinfo)\n-    datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n-  else\n-    datarefs = BB_VINFO_DATAREFS (bb_vinfo);\n-\n   FOR_EACH_VEC_ELT (datarefs, i, dr)\n     {\n       gimple *stmt = DR_STMT (dr);\n@@ -1679,7 +1668,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n       if (do_peeling && known_alignment_for_access_p (dr0) && npeel == 0)\n         {\n-          stat = vect_verify_datarefs_alignment (loop_vinfo, NULL);\n+          stat = vect_verify_datarefs_alignment (loop_vinfo);\n           if (!stat)\n             do_peeling = false;\n           else\n@@ -1758,7 +1747,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t     Drop the body_cst_vec on the floor here.  */\n \t  body_cost_vec.release ();\n \n-\t  stat = vect_verify_datarefs_alignment (loop_vinfo, NULL);\n+\t  stat = vect_verify_datarefs_alignment (loop_vinfo);\n \t  gcc_assert (stat);\n           return stat;\n         }\n@@ -1875,15 +1864,15 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       /* Peeling and versioning can't be done together at this time.  */\n       gcc_assert (! (do_peeling && do_versioning));\n \n-      stat = vect_verify_datarefs_alignment (loop_vinfo, NULL);\n+      stat = vect_verify_datarefs_alignment (loop_vinfo);\n       gcc_assert (stat);\n       return stat;\n     }\n \n   /* This point is reached if neither peeling nor versioning is being done.  */\n   gcc_assert (! (do_peeling || do_versioning));\n \n-  stat = vect_verify_datarefs_alignment (loop_vinfo, NULL);\n+  stat = vect_verify_datarefs_alignment (loop_vinfo);\n   return stat;\n }\n \n@@ -1967,26 +1956,25 @@ vect_find_same_alignment_drs (struct data_dependence_relation *ddr,\n    Return FALSE if a data reference is found that cannot be vectorized.  */\n \n bool\n-vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo,\n-                                  bb_vec_info bb_vinfo)\n+vect_analyze_data_refs_alignment (vec_info *vinfo)\n {\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"=== vect_analyze_data_refs_alignment ===\\n\");\n \n   /* Mark groups of data references with same alignment using\n      data dependence information.  */\n-  if (loop_vinfo)\n+  if (is_a <loop_vec_info> (vinfo))\n     {\n-      vec<ddr_p> ddrs = LOOP_VINFO_DDRS (loop_vinfo);\n+      vec<ddr_p> ddrs = vinfo->ddrs;\n       struct data_dependence_relation *ddr;\n       unsigned int i;\n \n       FOR_EACH_VEC_ELT (ddrs, i, ddr)\n-\tvect_find_same_alignment_drs (ddr, loop_vinfo);\n+\tvect_find_same_alignment_drs (ddr, as_a <loop_vec_info> (vinfo));\n     }\n \n-  if (!vect_compute_data_refs_alignment (loop_vinfo, bb_vinfo))\n+  if (!vect_compute_data_refs_alignment (vinfo))\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -2516,21 +2504,16 @@ dr_group_sort_cmp (const void *dra_, const void *drb_)\n    FORNOW: handle only arrays and pointer accesses.  */\n \n bool\n-vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n+vect_analyze_data_ref_accesses (vec_info *vinfo)\n {\n   unsigned int i;\n-  vec<data_reference_p> datarefs;\n+  vec<data_reference_p> datarefs = vinfo->datarefs;\n   struct data_reference *dr;\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"=== vect_analyze_data_ref_accesses ===\\n\");\n \n-  if (loop_vinfo)\n-    datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n-  else\n-    datarefs = BB_VINFO_DATAREFS (bb_vinfo);\n-\n   if (datarefs.is_empty ())\n     return true;\n \n@@ -2654,7 +2637,7 @@ vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n \t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t                   \"not vectorized: complicated access pattern.\\n\");\n \n-        if (bb_vinfo)\n+        if (is_a <bb_vec_info> (vinfo))\n           {\n             /* Mark the statement as not vectorizable.  */\n             STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (DR_STMT (dr))) = false;\n@@ -3217,9 +3200,7 @@ vect_check_gather_scatter (gimple *stmt, loop_vec_info loop_vinfo, tree *basep,\n */\n \n bool\n-vect_analyze_data_refs (loop_vec_info loop_vinfo,\n-\t\t\tbb_vec_info bb_vinfo,\n-\t\t\tint *min_vf, unsigned *n_stmts)\n+vect_analyze_data_refs (vec_info *vinfo, int *min_vf, unsigned *n_stmts)\n {\n   struct loop *loop = NULL;\n   basic_block bb = NULL;\n@@ -3232,7 +3213,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"=== vect_analyze_data_refs ===\\n\");\n \n-  if (loop_vinfo)\n+  if (loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo))\n     {\n       basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n \n@@ -3304,6 +3285,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n     }\n   else\n     {\n+      bb_vec_info bb_vinfo = as_a <bb_vec_info> (vinfo);\n       gimple_stmt_iterator gsi;\n \n       bb = BB_VINFO_BB (bb_vinfo);\n@@ -3381,11 +3363,11 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t      && !TREE_THIS_VOLATILE (DR_REF (dr))\n \t      && targetm.vectorize.builtin_scatter != NULL;\n \t  bool maybe_simd_lane_access\n-\t    = loop_vinfo && loop->simduid;\n+\t    = is_a <loop_vec_info> (vinfo) && loop->simduid;\n \n \t  /* If target supports vector gather loads or scatter stores, or if\n \t     this might be a SIMD lane access, see if they can't be used.  */\n-\t  if (loop_vinfo\n+\t  if (is_a <loop_vec_info> (vinfo)\n \t      && (maybe_gather || maybe_scatter || maybe_simd_lane_access)\n \t      && !nested_in_vect_loop_p (loop, stmt))\n \t    {\n@@ -3468,7 +3450,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n                   dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t\t}\n \n-\t      if (bb_vinfo)\n+\t      if (is_a <bb_vec_info> (vinfo))\n \t\tbreak;\n \n \t      return false;\n@@ -3482,7 +3464,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n                              \"not vectorized: base addr of dr is a \"\n                              \"constant\\n\");\n \n-          if (bb_vinfo)\n+          if (is_a <bb_vec_info> (vinfo))\n \t    break;\n \n \t  if (gatherscatter != SG_NONE || simd_lane_access)\n@@ -3500,7 +3482,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n               dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n             }\n \n-          if (bb_vinfo)\n+          if (is_a <bb_vec_info> (vinfo))\n \t    break;\n \n           return false;\n@@ -3517,7 +3499,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n               dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n             }\n \n-          if (bb_vinfo)\n+          if (is_a <bb_vec_info> (vinfo))\n \t    break;\n \n \t  if (gatherscatter != SG_NONE || simd_lane_access)\n@@ -3537,7 +3519,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n               dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n             }\n \n-          if (bb_vinfo)\n+          if (is_a <bb_vec_info> (vinfo))\n \t    break;\n \n \t  if (gatherscatter != SG_NONE || simd_lane_access)\n@@ -3562,7 +3544,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t      dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t    }\n \n-\t  if (bb_vinfo)\n+\t  if (is_a <bb_vec_info> (vinfo))\n \t    break;\n \n \t  if (gatherscatter != SG_NONE || simd_lane_access)\n@@ -3700,7 +3682,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n               dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n             }\n \n-          if (bb_vinfo)\n+          if (is_a <bb_vec_info> (vinfo))\n \t    break;\n \n \t  if (gatherscatter != SG_NONE || simd_lane_access)\n@@ -3733,7 +3715,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n               dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n             }\n \n-          if (bb_vinfo)\n+          if (is_a <bb_vec_info> (vinfo))\n \t    break;\n \n \t  if (gatherscatter != SG_NONE || simd_lane_access)\n@@ -3766,7 +3748,8 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n       if (gatherscatter != SG_NONE)\n \t{\n \t  tree off;\n-\t  if (!vect_check_gather_scatter (stmt, loop_vinfo, NULL, &off, NULL)\n+\t  if (!vect_check_gather_scatter (stmt, as_a <loop_vec_info> (vinfo),\n+\t\t\t\t\t  NULL, &off, NULL)\n \t      || get_vectype_for_scalar_type (TREE_TYPE (off)) == NULL_TREE)\n \t    {\n \t      STMT_VINFO_DATA_REF (stmt_info) = NULL;\n@@ -3789,7 +3772,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t  STMT_VINFO_GATHER_SCATTER_P (stmt_info) = gatherscatter;\n \t}\n \n-      else if (loop_vinfo\n+      else if (is_a <loop_vec_info> (vinfo)\n \t       && TREE_CODE (DR_STEP (dr)) != INTEGER_CST)\n \t{\n \t  if (nested_in_vect_loop_p (loop, stmt))\n@@ -3814,7 +3797,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n      avoids spending useless time in analyzing their dependence.  */\n   if (i != datarefs.length ())\n     {\n-      gcc_assert (bb_vinfo != NULL);\n+      gcc_assert (is_a <bb_vec_info> (vinfo));\n       for (unsigned j = i; j < datarefs.length (); ++j)\n \t{\n \t  data_reference_p dr = datarefs[j];\n@@ -4259,7 +4242,7 @@ vect_create_data_ref_ptr (gimple *stmt, tree aggr_type, struct loop *at_loop,\n \t\t aggr_ptr, loop, &incr_gsi, insert_after,\n \t\t &indx_before_incr, &indx_after_incr);\n       incr = gsi_stmt (incr_gsi);\n-      set_vinfo_for_stmt (incr, new_stmt_vec_info (incr, loop_vinfo, NULL));\n+      set_vinfo_for_stmt (incr, new_stmt_vec_info (incr, loop_vinfo));\n \n       /* Copy the points-to information if it exists. */\n       if (DR_PTR_INFO (dr))\n@@ -4289,7 +4272,7 @@ vect_create_data_ref_ptr (gimple *stmt, tree aggr_type, struct loop *at_loop,\n \t\t containing_loop, &incr_gsi, insert_after, &indx_before_incr,\n \t\t &indx_after_incr);\n       incr = gsi_stmt (incr_gsi);\n-      set_vinfo_for_stmt (incr, new_stmt_vec_info (incr, loop_vinfo, NULL));\n+      set_vinfo_for_stmt (incr, new_stmt_vec_info (incr, loop_vinfo));\n \n       /* Copy the points-to information if it exists. */\n       if (DR_PTR_INFO (dr))"}, {"sha": "ca37ddeb633209089b8410d7641f3282fe754fa0", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310213d49e368bd3cce0d20febe2666d0262d859/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310213d49e368bd3cce0d20febe2666d0262d859/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=310213d49e368bd3cce0d20febe2666d0262d859", "patch": "@@ -897,6 +897,7 @@ new_loop_vec_info (struct loop *loop)\n   unsigned int i, nbbs;\n \n   res = (loop_vec_info) xcalloc (1, sizeof (struct _loop_vec_info));\n+  res->kind = vec_info::loop;\n   LOOP_VINFO_LOOP (res) = loop;\n \n   bbs = get_loop_body (loop);\n@@ -924,7 +925,7 @@ new_loop_vec_info (struct loop *loop)\n               loop_vec_info inner_loop_vinfo =\n                 STMT_VINFO_LOOP_VINFO (stmt_info);\n               gcc_assert (loop->inner == LOOP_VINFO_LOOP (inner_loop_vinfo));\n-              STMT_VINFO_LOOP_VINFO (stmt_info) = res;\n+              stmt_info->vinfo = res;\n             }\n           for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n            {\n@@ -933,7 +934,7 @@ new_loop_vec_info (struct loop *loop)\n               loop_vec_info inner_loop_vinfo =\n                  STMT_VINFO_LOOP_VINFO (stmt_info);\n               gcc_assert (loop->inner == LOOP_VINFO_LOOP (inner_loop_vinfo));\n-              STMT_VINFO_LOOP_VINFO (stmt_info) = res;\n+              stmt_info->vinfo = res;\n            }\n         }\n       else\n@@ -943,14 +944,14 @@ new_loop_vec_info (struct loop *loop)\n             {\n \t      gimple *phi = gsi_stmt (si);\n               gimple_set_uid (phi, 0);\n-              set_vinfo_for_stmt (phi, new_stmt_vec_info (phi, res, NULL));\n+              set_vinfo_for_stmt (phi, new_stmt_vec_info (phi, res));\n             }\n \n           for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n             {\n \t      gimple *stmt = gsi_stmt (si);\n               gimple_set_uid (stmt, 0);\n-              set_vinfo_for_stmt (stmt, new_stmt_vec_info (stmt, res, NULL));\n+              set_vinfo_for_stmt (stmt, new_stmt_vec_info (stmt, res));\n             }\n         }\n     }\n@@ -1055,7 +1056,7 @@ destroy_loop_vec_info (loop_vec_info loop_vinfo, bool clean_stmts)\n     }\n \n   free (LOOP_VINFO_BBS (loop_vinfo));\n-  vect_destroy_datarefs (loop_vinfo, NULL);\n+  vect_destroy_datarefs (loop_vinfo);\n   free_dependence_relations (LOOP_VINFO_DDRS (loop_vinfo));\n   LOOP_VINFO_LOOP_NEST (loop_vinfo).release ();\n   LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo).release ();\n@@ -1767,7 +1768,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n      FORNOW: Handle only simple, array references, which\n      alignment can be forced, and aligned pointer-references.  */\n \n-  ok = vect_analyze_data_refs (loop_vinfo, NULL, &min_vf, &n_stmts);\n+  ok = vect_analyze_data_refs (loop_vinfo, &min_vf, &n_stmts);\n   if (!ok)\n     {\n       if (dump_enabled_p ())\n@@ -1781,14 +1782,14 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n \n   vect_analyze_scalar_cycles (loop_vinfo);\n \n-  vect_pattern_recog (loop_vinfo, NULL);\n+  vect_pattern_recog (loop_vinfo);\n \n   vect_fixup_scalar_cycles_with_patterns (loop_vinfo);\n \n   /* Analyze the access patterns of the data-refs in the loop (consecutive,\n      complex, etc.). FORNOW: Only handle consecutive access pattern.  */\n \n-  ok = vect_analyze_data_ref_accesses (loop_vinfo, NULL);\n+  ok = vect_analyze_data_ref_accesses (loop_vinfo);\n   if (!ok)\n     {\n       if (dump_enabled_p ())\n@@ -1840,7 +1841,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n     }\n \n   /* Check the SLP opportunities in the loop, analyze and build SLP trees.  */\n-  ok = vect_analyze_slp (loop_vinfo, NULL, n_stmts);\n+  ok = vect_analyze_slp (loop_vinfo, n_stmts);\n   if (!ok)\n     return false;\n \n@@ -1858,7 +1859,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n   /* Analyze the alignment of the data-refs in the loop.\n      Fail if a data reference is found that cannot be vectorized.  */\n \n-  ok = vect_analyze_data_refs_alignment (loop_vinfo, NULL);\n+  ok = vect_analyze_data_refs_alignment (loop_vinfo);\n   if (!ok)\n     {\n       if (dump_enabled_p ())\n@@ -2646,7 +2647,7 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple *phi,\n       gimple *negate_stmt = gimple_build_assign (negrhs, NEGATE_EXPR, rhs);\n       gimple_stmt_iterator gsi = gsi_for_stmt (def_stmt);\n       set_vinfo_for_stmt (negate_stmt, new_stmt_vec_info (negate_stmt, \n-\t\t\t\t\t\t\t  loop_info, NULL));\n+\t\t\t\t\t\t\t  loop_info));\n       gsi_insert_before (&gsi, negate_stmt, GSI_NEW_STMT);\n       gimple_assign_set_rhs2 (def_stmt, negrhs);\n       gimple_assign_set_rhs_code (def_stmt, PLUS_EXPR);\n@@ -3508,7 +3509,7 @@ get_initial_def_for_induction (gimple *iv_phi)\n \t\t\t\t\t\t new_stmt);\n \t  gcc_assert (!new_bb);\n \t  set_vinfo_for_stmt (new_stmt,\n-\t\t\t      new_stmt_vec_info (new_stmt, loop_vinfo, NULL));\n+\t\t\t      new_stmt_vec_info (new_stmt, loop_vinfo));\n \t}\n     }\n   else\n@@ -3610,16 +3611,15 @@ get_initial_def_for_induction (gimple *iv_phi)\n   vec_dest = vect_get_new_vect_var (vectype, vect_simple_var, \"vec_iv_\");\n   induction_phi = create_phi_node (vec_dest, iv_loop->header);\n   set_vinfo_for_stmt (induction_phi,\n-\t\t      new_stmt_vec_info (induction_phi, loop_vinfo, NULL));\n+\t\t      new_stmt_vec_info (induction_phi, loop_vinfo));\n   induc_def = PHI_RESULT (induction_phi);\n \n   /* Create the iv update inside the loop  */\n   new_stmt = gimple_build_assign (vec_dest, PLUS_EXPR, induc_def, vec_step);\n   vec_def = make_ssa_name (vec_dest, new_stmt);\n   gimple_assign_set_lhs (new_stmt, vec_def);\n   gsi_insert_before (&si, new_stmt, GSI_SAME_STMT);\n-  set_vinfo_for_stmt (new_stmt, new_stmt_vec_info (new_stmt, loop_vinfo,\n-                                                   NULL));\n+  set_vinfo_for_stmt (new_stmt, new_stmt_vec_info (new_stmt, loop_vinfo));\n \n   /* Set the arguments of the phi node:  */\n   add_phi_arg (induction_phi, vec_init, pe, UNKNOWN_LOCATION);\n@@ -3684,7 +3684,7 @@ get_initial_def_for_induction (gimple *iv_phi)\n \t      gsi_insert_before (&si, new_stmt, GSI_SAME_STMT);\n \t    }\n \t  set_vinfo_for_stmt (new_stmt,\n-\t\t\t      new_stmt_vec_info (new_stmt, loop_vinfo, NULL));\n+\t\t\t      new_stmt_vec_info (new_stmt, loop_vinfo));\n \t  STMT_VINFO_RELATED_STMT (prev_stmt_vinfo) = new_stmt;\n \t  prev_stmt_vinfo = vinfo_for_stmt (new_stmt);\n \t}\n@@ -3752,7 +3752,7 @@ get_initial_def_for_induction (gimple *iv_phi)\n       si = gsi_after_labels (bb);\n       gsi_insert_before (&si, new_stmt, GSI_SAME_STMT);\n       set_vinfo_for_stmt (new_stmt,\n-\t\t\t  new_stmt_vec_info (new_stmt, loop_vinfo, NULL));\n+\t\t\t  new_stmt_vec_info (new_stmt, loop_vinfo));\n       STMT_VINFO_RELATED_STMT (vinfo_for_stmt (new_stmt))\n \t= STMT_VINFO_RELATED_STMT (vinfo_for_stmt (induction_phi));\n     }\n@@ -4177,7 +4177,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n         {\n \t  tree new_def = copy_ssa_name (def);\n           phi = create_phi_node (new_def, exit_bb);\n-          set_vinfo_for_stmt (phi, new_stmt_vec_info (phi, loop_vinfo, NULL));\n+          set_vinfo_for_stmt (phi, new_stmt_vec_info (phi, loop_vinfo));\n           if (j == 0)\n             new_phis.quick_push (phi);\n           else\n@@ -4205,7 +4205,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n \t  SET_PHI_ARG_DEF (outer_phi, single_exit (loop)->dest_idx,\n \t\t\t   PHI_RESULT (phi));\n \t  set_vinfo_for_stmt (outer_phi, new_stmt_vec_info (outer_phi,\n-\t\t\t\t\t\t\t    loop_vinfo, NULL));\n+\t\t\t\t\t\t\t    loop_vinfo));\n \t  inner_phis.quick_push (phi);\n \t  new_phis[i] = outer_phi;\n \t  prev_phi_info = vinfo_for_stmt (outer_phi);\n@@ -4217,7 +4217,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n \t      SET_PHI_ARG_DEF (outer_phi, single_exit (loop)->dest_idx,\n \t\t\t       PHI_RESULT (phi));\n \t      set_vinfo_for_stmt (outer_phi, new_stmt_vec_info (outer_phi,\n-\t\t\t\t\t\t\tloop_vinfo, NULL));\n+\t\t\t\t\t\t\t\tloop_vinfo));\n \t      STMT_VINFO_RELATED_STMT (prev_phi_info) = outer_phi;\n \t      prev_phi_info = vinfo_for_stmt (outer_phi);\n \t    }\n@@ -4558,8 +4558,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n       if (nested_in_vect_loop)\n         {\n           set_vinfo_for_stmt (epilog_stmt,\n-                              new_stmt_vec_info (epilog_stmt, loop_vinfo,\n-                                                 NULL));\n+                              new_stmt_vec_info (epilog_stmt, loop_vinfo));\n           STMT_VINFO_RELATED_STMT (vinfo_for_stmt (epilog_stmt)) =\n                 STMT_VINFO_RELATED_STMT (vinfo_for_stmt (new_phi));\n \n@@ -4730,7 +4729,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n                   /* Create vector phi node.  */\n                   vect_phi = create_phi_node (vec_initial_def, bb);\n                   new_phi_vinfo = new_stmt_vec_info (vect_phi,\n-                                    loop_vec_info_for_loop (outer_loop), NULL);\n+                                    loop_vec_info_for_loop (outer_loop));\n                   set_vinfo_for_stmt (vect_phi, new_phi_vinfo);\n \n                   /* Create vs0 - initial def of the double reduction phi.  */\n@@ -5037,7 +5036,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n       if (i == 0 && code == COND_EXPR)\n         continue;\n \n-      is_simple_use = vect_is_simple_use_1 (ops[i], stmt, loop_vinfo, NULL,\n+      is_simple_use = vect_is_simple_use_1 (ops[i], stmt, loop_vinfo,\n \t\t\t\t\t    &def_stmt, &def, &dt, &tem);\n       if (!vectype_in)\n \tvectype_in = tem;\n@@ -5058,7 +5057,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n         }\n     }\n \n-  is_simple_use = vect_is_simple_use_1 (ops[i], stmt, loop_vinfo, NULL,\n+  is_simple_use = vect_is_simple_use_1 (ops[i], stmt, loop_vinfo,\n \t\t\t\t\t&def_stmt, &def, &dt, &tem);\n   if (!vectype_in)\n     vectype_in = tem;\n@@ -5387,8 +5386,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n                  operand.  */\n               new_phi = create_phi_node (vec_dest, loop->header);\n               set_vinfo_for_stmt (new_phi,\n-                                  new_stmt_vec_info (new_phi, loop_vinfo,\n-                                                     NULL));\n+                                  new_stmt_vec_info (new_phi, loop_vinfo));\n                if (j == 0 || slp_node)\n                  phis.quick_push (new_phi);\n             }\n@@ -5440,14 +5438,14 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \t      gimple *dummy_stmt;\n               tree dummy;\n \n-              vect_is_simple_use (ops[!reduc_index], stmt, loop_vinfo, NULL,\n+              vect_is_simple_use (ops[!reduc_index], stmt, loop_vinfo,\n                                   &dummy_stmt, &dummy, &dt);\n               loop_vec_def0 = vect_get_vec_def_for_stmt_copy (dt,\n                                                               loop_vec_def0);\n               vec_oprnds0[0] = loop_vec_def0;\n               if (op_type == ternary_op)\n                 {\n-                  vect_is_simple_use (op1, stmt, loop_vinfo, NULL, &dummy_stmt,\n+                  vect_is_simple_use (op1, stmt, loop_vinfo, &dummy_stmt,\n                                       &dummy, &dt);\n                   loop_vec_def1 = vect_get_vec_def_for_stmt_copy (dt,\n                                                                 loop_vec_def1);\n@@ -5749,8 +5747,7 @@ vectorizable_live_operation (gimple *stmt,\n       else\n \top = gimple_op (stmt, i + 1);\n       if (op\n-          && !vect_is_simple_use (op, stmt, loop_vinfo, NULL, &def_stmt, &def,\n-\t\t\t\t  &dt))\n+          && !vect_is_simple_use (op, stmt, loop_vinfo, &def_stmt, &def, &dt))\n         {\n           if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -6218,7 +6215,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t\t    dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t\t     \"=== scheduling SLP instances ===\\n\");\n \n-\t\t  vect_schedule_slp (loop_vinfo, NULL);\n+\t\t  vect_schedule_slp (loop_vinfo);\n \t\t}\n \n \t      /* Hybrid SLP stmts must be vectorized in addition to SLP.  */"}, {"sha": "3d324bf6cf065e4d3b46e4c58a389786a7432a86", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 41, "deletions": 61, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310213d49e368bd3cce0d20febe2666d0262d859/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310213d49e368bd3cce0d20febe2666d0262d859/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=310213d49e368bd3cce0d20febe2666d0262d859", "patch": "@@ -171,18 +171,14 @@ type_conversion_p (tree name, gimple *use_stmt, bool check_sign,\n {\n   tree dummy;\n   gimple *dummy_gimple;\n-  loop_vec_info loop_vinfo;\n   stmt_vec_info stmt_vinfo;\n   tree type = TREE_TYPE (name);\n   tree oprnd0;\n   enum vect_def_type dt;\n   tree def;\n-  bb_vec_info bb_vinfo;\n \n   stmt_vinfo = vinfo_for_stmt (use_stmt);\n-  loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n-  bb_vinfo = STMT_VINFO_BB_VINFO (stmt_vinfo);\n-  if (!vect_is_simple_use (name, use_stmt, loop_vinfo, bb_vinfo, def_stmt,\n+  if (!vect_is_simple_use (name, use_stmt, stmt_vinfo->vinfo, def_stmt,\n \t\t\t   &def, &dt))\n     return false;\n \n@@ -211,8 +207,8 @@ type_conversion_p (tree name, gimple *use_stmt, bool check_sign,\n   else\n     *promotion = false;\n \n-  if (!vect_is_simple_use (oprnd0, *def_stmt, loop_vinfo,\n-\t\t\t   bb_vinfo, &dummy_gimple, &dummy, &dt))\n+  if (!vect_is_simple_use (oprnd0, *def_stmt, stmt_vinfo->vinfo,\n+\t\t\t   &dummy_gimple, &dummy, &dt))\n     return false;\n \n   return true;\n@@ -978,8 +974,6 @@ vect_recog_widen_mult_pattern (vec<gimple *> *stmts,\n   pattern_stmt = gimple_build_assign (var, WIDEN_MULT_EXPR, oprnd0, oprnd1);\n \n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n-  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n-  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_vinfo);\n   STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo) = NULL;\n \n   /* If the original two operands have different sizes, we may need to convert\n@@ -989,7 +983,7 @@ vect_recog_widen_mult_pattern (vec<gimple *> *stmts,\n     {\n       append_pattern_def_seq (stmt_vinfo, new_stmt);\n       stmt_vec_info new_stmt_info\n-        = new_stmt_vec_info (new_stmt, loop_vinfo, bb_vinfo);\n+        = new_stmt_vec_info (new_stmt, stmt_vinfo->vinfo);\n       set_vinfo_for_stmt (new_stmt, new_stmt_info);\n       STMT_VINFO_VECTYPE (new_stmt_info) = vectype;\n     }\n@@ -1000,7 +994,7 @@ vect_recog_widen_mult_pattern (vec<gimple *> *stmts,\n     {\n       append_pattern_def_seq (stmt_vinfo, pattern_stmt);\n       stmt_vec_info pattern_stmt_info\n-        = new_stmt_vec_info (pattern_stmt, loop_vinfo, bb_vinfo);\n+        = new_stmt_vec_info (pattern_stmt, stmt_vinfo->vinfo);\n       set_vinfo_for_stmt (pattern_stmt, pattern_stmt_info);\n       STMT_VINFO_VECTYPE (pattern_stmt_info) = vecitype;\n       pattern_stmt = gimple_build_assign (vect_recog_temp_ssa_var (type, NULL),\n@@ -1754,11 +1748,9 @@ vect_recog_widen_shift_pattern (vec<gimple *> *stmts,\n   if (wstmt)\n     {\n       stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n-      loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n-      bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_vinfo);\n       new_pattern_def_seq (stmt_vinfo, wstmt);\n       stmt_vec_info new_stmt_info\n-\t= new_stmt_vec_info (wstmt, loop_vinfo, bb_vinfo);\n+\t= new_stmt_vec_info (wstmt, stmt_vinfo->vinfo);\n       set_vinfo_for_stmt (wstmt, new_stmt_info);\n       STMT_VINFO_VECTYPE (new_stmt_info) = vectype;\n     }\n@@ -1807,8 +1799,7 @@ vect_recog_rotate_pattern (vec<gimple *> *stmts, tree *type_in, tree *type_out)\n   gimple *pattern_stmt, *def_stmt;\n   enum tree_code rhs_code;\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n-  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n-  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_vinfo);\n+  vec_info *vinfo = stmt_vinfo->vinfo;\n   enum vect_def_type dt;\n   optab optab1, optab2;\n   edge ext_def = NULL;\n@@ -1839,8 +1830,7 @@ vect_recog_rotate_pattern (vec<gimple *> *stmts, tree *type_in, tree *type_out)\n       || !TYPE_UNSIGNED (type))\n     return NULL;\n \n-  if (!vect_is_simple_use (oprnd1, last_stmt, loop_vinfo, bb_vinfo, &def_stmt,\n-\t\t\t   &def, &dt))\n+  if (!vect_is_simple_use (oprnd1, last_stmt, vinfo, &def_stmt, &def, &dt))\n     return NULL;\n \n   if (dt != vect_internal_def\n@@ -1859,7 +1849,7 @@ vect_recog_rotate_pattern (vec<gimple *> *stmts, tree *type_in, tree *type_out)\n       && optab_handler (optab1, TYPE_MODE (vectype)) != CODE_FOR_nothing)\n     return NULL;\n \n-  if (bb_vinfo != NULL || dt != vect_internal_def)\n+  if (is_a <bb_vec_info> (vinfo) || dt != vect_internal_def)\n     {\n       optab2 = optab_for_tree_code (rhs_code, vectype, optab_scalar);\n       if (optab2\n@@ -1876,7 +1866,7 @@ vect_recog_rotate_pattern (vec<gimple *> *stmts, tree *type_in, tree *type_out)\n       || !optab2\n       || optab_handler (optab2, TYPE_MODE (vectype)) == CODE_FOR_nothing)\n     {\n-      if (bb_vinfo == NULL && dt == vect_internal_def)\n+      if (! is_a <bb_vec_info> (vinfo) && dt == vect_internal_def)\n \treturn NULL;\n       optab1 = optab_for_tree_code (LSHIFT_EXPR, vectype, optab_scalar);\n       optab2 = optab_for_tree_code (RSHIFT_EXPR, vectype, optab_scalar);\n@@ -1894,9 +1884,9 @@ vect_recog_rotate_pattern (vec<gimple *> *stmts, tree *type_in, tree *type_out)\n \n   if (dt == vect_external_def\n       && TREE_CODE (oprnd1) == SSA_NAME\n-      && loop_vinfo)\n+      && is_a <loop_vec_info> (vinfo))\n     {\n-      struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+      struct loop *loop = as_a <loop_vec_info> (vinfo)->loop;\n       ext_def = loop_preheader_edge (loop);\n       if (!SSA_NAME_IS_DEFAULT_DEF (oprnd1))\n \t{\n@@ -1963,7 +1953,7 @@ vect_recog_rotate_pattern (vec<gimple *> *stmts, tree *type_in, tree *type_out)\n \t}\n       else\n \t{\n-\t  def_stmt_vinfo = new_stmt_vec_info (def_stmt, loop_vinfo, bb_vinfo);\n+\t  def_stmt_vinfo = new_stmt_vec_info (def_stmt, vinfo);\n \t  set_vinfo_for_stmt (def_stmt, def_stmt_vinfo);\n \t  STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecstype;\n \t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n@@ -1982,7 +1972,7 @@ vect_recog_rotate_pattern (vec<gimple *> *stmts, tree *type_in, tree *type_out)\n \t}\n       else\n \t{\n-\t  def_stmt_vinfo = new_stmt_vec_info (def_stmt, loop_vinfo, bb_vinfo);\n+\t  def_stmt_vinfo = new_stmt_vec_info (def_stmt, vinfo);\n \t  set_vinfo_for_stmt (def_stmt, def_stmt_vinfo);\n \t  STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecstype;\n \t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n@@ -2066,8 +2056,7 @@ vect_recog_vector_vector_shift_pattern (vec<gimple *> *stmts,\n   gimple *pattern_stmt, *def_stmt;\n   enum tree_code rhs_code;\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n-  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n-  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_vinfo);\n+  vec_info *vinfo = stmt_vinfo->vinfo;\n   enum vect_def_type dt;\n   tree def;\n \n@@ -2101,7 +2090,7 @@ vect_recog_vector_vector_shift_pattern (vec<gimple *> *stmts,\n \t != TYPE_PRECISION (TREE_TYPE (oprnd0)))\n     return NULL;\n \n-  if (!vect_is_simple_use (oprnd1, last_stmt, loop_vinfo, bb_vinfo, &def_stmt,\n+  if (!vect_is_simple_use (oprnd1, last_stmt, vinfo, &def_stmt,\n \t\t\t   &def, &dt))\n     return NULL;\n \n@@ -2329,8 +2318,7 @@ vect_recog_divmod_pattern (vec<gimple *> *stmts,\n   gimple *pattern_stmt, *def_stmt;\n   enum tree_code rhs_code;\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n-  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n-  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_vinfo);\n+  vec_info *vinfo = stmt_vinfo->vinfo;\n   optab optab;\n   tree q;\n   int dummy_int, prec;\n@@ -2435,17 +2423,15 @@ vect_recog_divmod_pattern (vec<gimple *> *stmts,\n \t      def_stmt = gimple_build_assign (var, COND_EXPR, cond,\n \t\t\t\t\t      build_int_cst (utype, -1),\n \t\t\t\t\t      build_int_cst (utype, 0));\n-\t      def_stmt_vinfo\n-\t\t= new_stmt_vec_info (def_stmt, loop_vinfo, bb_vinfo);\n+\t      def_stmt_vinfo = new_stmt_vec_info (def_stmt, vinfo);\n \t      set_vinfo_for_stmt (def_stmt, def_stmt_vinfo);\n \t      STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecutype;\n \t      append_pattern_def_seq (stmt_vinfo, def_stmt);\n \t      var = vect_recog_temp_ssa_var (utype, NULL);\n \t      def_stmt = gimple_build_assign (var, RSHIFT_EXPR,\n \t\t\t\t\t      gimple_assign_lhs (def_stmt),\n \t\t\t\t\t      shift);\n-\t      def_stmt_vinfo\n-\t\t= new_stmt_vec_info (def_stmt, loop_vinfo, bb_vinfo);\n+\t      def_stmt_vinfo = new_stmt_vec_info (def_stmt, vinfo);\n \t      set_vinfo_for_stmt (def_stmt, def_stmt_vinfo);\n \t      STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecutype;\n \t      append_pattern_def_seq (stmt_vinfo, def_stmt);\n@@ -2779,8 +2765,7 @@ vect_recog_mixed_size_cond_pattern (vec<gimple *> *stmts, tree *type_in,\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt), def_stmt_info;\n   tree type, vectype, comp_vectype, itype = NULL_TREE, vecitype;\n   gimple *pattern_stmt, *def_stmt;\n-  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n-  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_vinfo);\n+  vec_info *vinfo = stmt_vinfo->vinfo;\n   tree orig_type0 = NULL_TREE, orig_type1 = NULL_TREE;\n   gimple *def_stmt0 = NULL, *def_stmt1 = NULL;\n   bool promotion;\n@@ -2885,7 +2870,7 @@ vect_recog_mixed_size_cond_pattern (vec<gimple *> *stmts, tree *type_in,\n \t\t\t\t      NOP_EXPR, gimple_assign_lhs (def_stmt));\n \n   new_pattern_def_seq (stmt_vinfo, def_stmt);\n-  def_stmt_info = new_stmt_vec_info (def_stmt, loop_vinfo, bb_vinfo);\n+  def_stmt_info = new_stmt_vec_info (def_stmt, vinfo);\n   set_vinfo_for_stmt (def_stmt, def_stmt_info);\n   STMT_VINFO_VECTYPE (def_stmt_info) = vecitype;\n   *type_in = vecitype;\n@@ -2903,14 +2888,14 @@ vect_recog_mixed_size_cond_pattern (vec<gimple *> *stmts, tree *type_in,\n    true if bool VAR can be optimized that way.  */\n \n static bool\n-check_bool_pattern (tree var, loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n+check_bool_pattern (tree var, vec_info *vinfo)\n {\n   gimple *def_stmt;\n   enum vect_def_type dt;\n   tree def, rhs1;\n   enum tree_code rhs_code;\n \n-  if (!vect_is_simple_use (var, NULL, loop_vinfo, bb_vinfo, &def_stmt, &def,\n+  if (!vect_is_simple_use (var, NULL, vinfo, &def_stmt, &def,\n \t\t\t   &dt))\n     return false;\n \n@@ -2928,25 +2913,24 @@ check_bool_pattern (tree var, loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n   switch (rhs_code)\n     {\n     case SSA_NAME:\n-      return check_bool_pattern (rhs1, loop_vinfo, bb_vinfo);\n+      return check_bool_pattern (rhs1, vinfo);\n \n     CASE_CONVERT:\n       if ((TYPE_PRECISION (TREE_TYPE (rhs1)) != 1\n \t   || !TYPE_UNSIGNED (TREE_TYPE (rhs1)))\n \t  && TREE_CODE (TREE_TYPE (rhs1)) != BOOLEAN_TYPE)\n \treturn false;\n-      return check_bool_pattern (rhs1, loop_vinfo, bb_vinfo);\n+      return check_bool_pattern (rhs1, vinfo);\n \n     case BIT_NOT_EXPR:\n-      return check_bool_pattern (rhs1, loop_vinfo, bb_vinfo);\n+      return check_bool_pattern (rhs1, vinfo);\n \n     case BIT_AND_EXPR:\n     case BIT_IOR_EXPR:\n     case BIT_XOR_EXPR:\n-      if (!check_bool_pattern (rhs1, loop_vinfo, bb_vinfo))\n+      if (!check_bool_pattern (rhs1, vinfo))\n \treturn false;\n-      return check_bool_pattern (gimple_assign_rhs2 (def_stmt), loop_vinfo,\n-\t\t\t\t bb_vinfo);\n+      return check_bool_pattern (gimple_assign_rhs2 (def_stmt), vinfo);\n \n     default:\n       if (TREE_CODE_CLASS (rhs_code) == tcc_comparison)\n@@ -3243,8 +3227,7 @@ vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_in,\n   enum tree_code rhs_code;\n   tree var, lhs, rhs, vectype;\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n-  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n-  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_vinfo);\n+  vec_info *vinfo = stmt_vinfo->vinfo;\n   gimple *pattern_stmt;\n \n   if (!is_gimple_assign (last_stmt))\n@@ -3268,7 +3251,7 @@ vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_in,\n       if (vectype == NULL_TREE)\n \treturn NULL;\n \n-      if (!check_bool_pattern (var, loop_vinfo, bb_vinfo))\n+      if (!check_bool_pattern (var, vinfo))\n \treturn NULL;\n \n       rhs = adjust_bool_pattern (var, TREE_TYPE (lhs), NULL_TREE, stmts);\n@@ -3306,7 +3289,7 @@ vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_in,\n       if (get_vectype_for_scalar_type (type) == NULL_TREE)\n \treturn NULL;\n \n-      if (!check_bool_pattern (var, loop_vinfo, bb_vinfo))\n+      if (!check_bool_pattern (var, vinfo))\n \treturn NULL;\n \n       rhs = adjust_bool_pattern (var, type, NULL_TREE, stmts);\n@@ -3334,7 +3317,7 @@ vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_in,\n       gcc_assert (vectype != NULL_TREE);\n       if (!VECTOR_MODE_P (TYPE_MODE (vectype)))\n \treturn NULL;\n-      if (!check_bool_pattern (var, loop_vinfo, bb_vinfo))\n+      if (!check_bool_pattern (var, vinfo))\n \treturn NULL;\n \n       rhs = adjust_bool_pattern (var, TREE_TYPE (vectype), NULL_TREE, stmts);\n@@ -3347,8 +3330,7 @@ vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_in,\n \t  rhs = rhs2;\n \t}\n       pattern_stmt = gimple_build_assign (lhs, SSA_NAME, rhs);\n-      pattern_stmt_info = new_stmt_vec_info (pattern_stmt, loop_vinfo,\n-\t\t\t\t\t\tbb_vinfo);\n+      pattern_stmt_info = new_stmt_vec_info (pattern_stmt, vinfo);\n       set_vinfo_for_stmt (pattern_stmt, pattern_stmt_info);\n       STMT_VINFO_DATA_REF (pattern_stmt_info)\n \t= STMT_VINFO_DATA_REF (stmt_vinfo);\n@@ -3382,15 +3364,13 @@ vect_mark_pattern_stmts (gimple *orig_stmt, gimple *pattern_stmt,\n {\n   stmt_vec_info pattern_stmt_info, def_stmt_info;\n   stmt_vec_info orig_stmt_info = vinfo_for_stmt (orig_stmt);\n-  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (orig_stmt_info);\n-  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (orig_stmt_info);\n+  vec_info *vinfo = orig_stmt_info->vinfo;\n   gimple *def_stmt;\n \n   pattern_stmt_info = vinfo_for_stmt (pattern_stmt);\n   if (pattern_stmt_info == NULL)\n     {\n-      pattern_stmt_info = new_stmt_vec_info (pattern_stmt, loop_vinfo,\n-\t\t\t\t\t\tbb_vinfo);\n+      pattern_stmt_info = new_stmt_vec_info (pattern_stmt, vinfo);\n       set_vinfo_for_stmt (pattern_stmt, pattern_stmt_info);\n     }\n   gimple_set_bb (pattern_stmt, gimple_bb (orig_stmt));\n@@ -3413,8 +3393,7 @@ vect_mark_pattern_stmts (gimple *orig_stmt, gimple *pattern_stmt,\n \t  def_stmt_info = vinfo_for_stmt (def_stmt);\n \t  if (def_stmt_info == NULL)\n \t    {\n-\t      def_stmt_info = new_stmt_vec_info (def_stmt, loop_vinfo,\n-\t\t\t\t\t\t bb_vinfo);\n+\t      def_stmt_info = new_stmt_vec_info (def_stmt, vinfo);\n \t      set_vinfo_for_stmt (def_stmt, def_stmt_info);\n \t    }\n \t  gimple_set_bb (def_stmt, gimple_bb (orig_stmt));\n@@ -3629,7 +3608,7 @@ vect_pattern_recog_1 (vect_recog_func_ptr vect_recog_func,\n    be recorded in S3.  */\n \n void\n-vect_pattern_recog (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n+vect_pattern_recog (vec_info *vinfo)\n {\n   struct loop *loop;\n   basic_block *bbs;\n@@ -3644,15 +3623,15 @@ vect_pattern_recog (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"=== vect_pattern_recog ===\\n\");\n \n-  if (loop_vinfo)\n+  if (loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo))\n     {\n       loop = LOOP_VINFO_LOOP (loop_vinfo);\n       bbs = LOOP_VINFO_BBS (loop_vinfo);\n       nbbs = loop->num_nodes;\n     }\n   else\n     {\n-      bbs = &BB_VINFO_BB (bb_vinfo);\n+      bbs = &as_a <bb_vec_info> (vinfo)->bb;\n       nbbs = 1;\n     }\n \n@@ -3663,7 +3642,8 @@ vect_pattern_recog (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n       basic_block bb = bbs[i];\n       for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n         {\n-\t  if (bb_vinfo && (stmt = gsi_stmt (si))\n+\t  if (is_a <bb_vec_info> (vinfo)\n+\t      && (stmt = gsi_stmt (si))\n \t      && vinfo_for_stmt (stmt)\n \t      && !STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (stmt)))\n \t   continue;"}, {"sha": "11ffb64b1dbf0064668b877503a91d80b4828ee8", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 69, "deletions": 89, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310213d49e368bd3cce0d20febe2666d0262d859/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310213d49e368bd3cce0d20febe2666d0262d859/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=310213d49e368bd3cce0d20febe2666d0262d859", "patch": "@@ -211,7 +211,7 @@ vect_get_place_in_interleaving_chain (gimple *stmt, gimple *first_stmt)\n    operation return 1, if everything is ok return 0.  */\n \n static int \n-vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n+vect_get_and_check_slp_defs (vec_info *vinfo,\n \t\t\t     gimple *stmt, unsigned stmt_num,\n                              vec<slp_oprnd_info> *oprnds_info)\n {\n@@ -229,8 +229,8 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   bool first = stmt_num == 0;\n   bool second = stmt_num == 1;\n \n-  if (loop_vinfo)\n-    loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  if (is_a <loop_vec_info> (vinfo))\n+    loop = LOOP_VINFO_LOOP (as_a <loop_vec_info> (vinfo));\n \n   if (is_gimple_call (stmt))\n     {\n@@ -270,7 +270,7 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \n       oprnd_info = (*oprnds_info)[i];\n \n-      if (!vect_is_simple_use (oprnd, NULL, loop_vinfo, bb_vinfo, &def_stmt,\n+      if (!vect_is_simple_use (oprnd, NULL, vinfo, &def_stmt,\n \t\t\t       &def, &dt))\n \t{\n \t  if (dump_enabled_p ())\n@@ -288,8 +288,10 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n          from the pattern.  Check that all the stmts of the node are in the\n          pattern.  */\n       if (def_stmt && gimple_bb (def_stmt)\n-          && ((loop && flow_bb_inside_loop_p (loop, gimple_bb (def_stmt)))\n-\t      || (!loop && gimple_bb (def_stmt) == BB_VINFO_BB (bb_vinfo)\n+          && ((is_a <loop_vec_info> (vinfo)\n+\t       && flow_bb_inside_loop_p (loop, gimple_bb (def_stmt)))\n+\t      || (is_a <bb_vec_info> (vinfo)\n+\t\t  && gimple_bb (def_stmt) == as_a <bb_vec_info> (vinfo)->bb\n \t\t  && gimple_code (def_stmt) != GIMPLE_PHI))\n           && vinfo_for_stmt (def_stmt)\n           && STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (def_stmt))\n@@ -448,7 +450,7 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n    carried out or the stmts will never be vectorized by SLP.  */\n \n static bool\n-vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n+vect_build_slp_tree_1 (vec_info *vinfo,\n \t\t       vec<gimple *> stmts, unsigned int group_size,\n \t\t       unsigned nops, unsigned int *max_nunits,\n \t\t       unsigned int vectorization_factor, bool *matches,\n@@ -551,7 +553,7 @@ vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \n       /* If populating the vector type requires unrolling then fail\n          before adjusting *max_nunits for basic-block vectorization.  */\n-      if (bb_vinfo\n+      if (is_a <bb_vec_info> (vinfo)\n \t  && TYPE_VECTOR_SUBPARTS (vectype) > group_size)\n \t{\n \t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n@@ -566,7 +568,7 @@ vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       if (*max_nunits < TYPE_VECTOR_SUBPARTS (vectype))\n         {\n           *max_nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-          if (bb_vinfo)\n+          if (is_a <bb_vec_info> (vinfo))\n             vectorization_factor = *max_nunits;\n         }\n \n@@ -745,7 +747,7 @@ vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                  greater than the SLP group size.  */\n \t      unsigned ncopies\n \t\t= vectorization_factor / TYPE_VECTOR_SUBPARTS (vectype);\n-              if (loop_vinfo\n+              if (is_a <loop_vec_info> (vinfo)\n \t\t  && GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) == stmt\n                   && ((GROUP_SIZE (vinfo_for_stmt (stmt))\n \t\t       - GROUP_GAP (vinfo_for_stmt (stmt)))\n@@ -907,7 +909,7 @@ vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n    was found.  */\n \n static bool\n-vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n+vect_build_slp_tree (vec_info *vinfo,\n                      slp_tree *node, unsigned int group_size,\n                      unsigned int *max_nunits,\n                      vec<slp_tree> *loads,\n@@ -933,7 +935,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n     return false;\n \n   bool two_operators = false;\n-  if (!vect_build_slp_tree_1 (loop_vinfo, bb_vinfo,\n+  if (!vect_build_slp_tree_1 (vinfo,\n \t\t\t      SLP_TREE_SCALAR_STMTS (*node), group_size, nops,\n \t\t\t      max_nunits, vectorization_factor, matches,\n \t\t\t      &two_operators))\n@@ -953,8 +955,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   slp_oprnd_info oprnd_info;\n   FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (*node), i, stmt)\n     {\n-      switch (vect_get_and_check_slp_defs (loop_vinfo, bb_vinfo,\n-\t\t\t\t\t   stmt, i, &oprnds_info))\n+      switch (vect_get_and_check_slp_defs (vinfo, stmt, i, &oprnds_info))\n \t{\n \tcase 0:\n \t  break;\n@@ -999,7 +1000,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t  return false;\n \t}\n \n-      if (vect_build_slp_tree (loop_vinfo, bb_vinfo, &child,\n+      if (vect_build_slp_tree (vinfo, &child,\n \t\t\t       group_size, max_nunits, loads,\n \t\t\t       vectorization_factor, matches,\n \t\t\t       npermutes, &this_tree_size, max_tree_size))\n@@ -1046,7 +1047,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t fails (or we don't try permutation below).  Ideally we'd\n \t even compute a permutation that will end up with the maximum\n \t SLP tree size...  */\n-      if (bb_vinfo\n+      if (is_a <bb_vec_info> (vinfo)\n \t  && !matches[0]\n \t  /* ???  Rejecting patterns this way doesn't work.  We'd have to\n \t     do extra work to cancel the pattern so the uses see the\n@@ -1113,7 +1114,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t  dump_printf (MSG_NOTE, \"\\n\");\n \t  /* And try again with scratch 'matches' ... */\n \t  bool *tem = XALLOCAVEC (bool, group_size);\n-\t  if (vect_build_slp_tree (loop_vinfo, bb_vinfo, &child,\n+\t  if (vect_build_slp_tree (vinfo, &child,\n \t\t\t\t   group_size, max_nunits, loads,\n \t\t\t\t   vectorization_factor,\n \t\t\t\t   tem, npermutes, &this_tree_size,\n@@ -1542,9 +1543,7 @@ vect_analyze_slp_cost_1 (slp_instance instance, slp_tree node,\n       enum vect_def_type dt;\n       if (!op || op == lhs)\n \tcontinue;\n-      if (vect_is_simple_use (op, NULL, STMT_VINFO_LOOP_VINFO (stmt_info),\n-\t\t\t      STMT_VINFO_BB_VINFO (stmt_info),\n-\t\t\t      &def_stmt, &def, &dt))\n+      if (vect_is_simple_use (op, NULL, stmt_info->vinfo, &def_stmt, &def, &dt))\n \t{\n \t  /* Without looking at the actual initializer a vector of\n \t     constants can be implemented as load from the constant pool.\n@@ -1632,7 +1631,7 @@ vect_analyze_slp_cost (slp_instance instance, void *data)\n    Return FALSE if it's impossible to SLP any stmt in the loop.  */\n \n static bool\n-vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n+vect_analyze_slp_instance (vec_info *vinfo,\n \t\t\t   gimple *stmt, unsigned max_tree_size)\n {\n   slp_instance new_instance;\n@@ -1657,17 +1656,17 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n         }\n       else\n         {\n-          gcc_assert (loop_vinfo);\n+          gcc_assert (is_a <loop_vec_info> (vinfo));\n           vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt));\n         }\n \n       group_size = GROUP_SIZE (vinfo_for_stmt (stmt));\n     }\n   else\n     {\n-      gcc_assert (loop_vinfo);\n+      gcc_assert (is_a <loop_vec_info> (vinfo));\n       vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt));\n-      group_size = LOOP_VINFO_REDUCTIONS (loop_vinfo).length ();\n+      group_size = as_a <loop_vec_info> (vinfo)->reductions.length ();\n     }\n \n   if (!vectype)\n@@ -1684,14 +1683,14 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n     }\n \n   nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-  if (loop_vinfo)\n-    vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  if (is_a <loop_vec_info> (vinfo))\n+    vectorization_factor = as_a <loop_vec_info> (vinfo)->vectorization_factor;\n   else\n     vectorization_factor = nunits;\n \n   /* Calculate the unrolling factor.  */\n   unrolling_factor = least_common_multiple (nunits, group_size) / group_size;\n-  if (unrolling_factor != 1 && !loop_vinfo)\n+  if (unrolling_factor != 1 && is_a <bb_vec_info> (vinfo))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -1726,7 +1725,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   else\n     {\n       /* Collect reduction statements.  */\n-      vec<gimple *> reductions = LOOP_VINFO_REDUCTIONS (loop_vinfo);\n+      vec<gimple *> reductions = as_a <loop_vec_info> (vinfo)->reductions;\n       for (i = 0; reductions.iterate (i, &next); i++)\n \tscalar_stmts.safe_push (next);\n     }\n@@ -1738,7 +1737,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   /* Build the tree for the SLP instance.  */\n   bool *matches = XALLOCAVEC (bool, group_size);\n   unsigned npermutes = 0;\n-  if (vect_build_slp_tree (loop_vinfo, bb_vinfo, &node, group_size,\n+  if (vect_build_slp_tree (vinfo, &node, group_size,\n \t\t\t   &max_nunits, &loads,\n \t\t\t   vectorization_factor, matches, &npermutes, NULL,\n \t\t\t   max_tree_size))\n@@ -1748,7 +1747,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n         unrolling_factor = least_common_multiple (max_nunits, group_size)\n                            / group_size;\n \n-      if (unrolling_factor != 1 && !loop_vinfo)\n+      if (unrolling_factor != 1 && is_a <bb_vec_info> (vinfo))\n         {\n           if (dump_enabled_p ())\n             dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -1819,11 +1818,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n             }\n         }\n \n-\n-      if (loop_vinfo)\n-\tLOOP_VINFO_SLP_INSTANCES (loop_vinfo).safe_push (new_instance);\n-      else\n-        BB_VINFO_SLP_INSTANCES (bb_vinfo).safe_push (new_instance);\n+      vinfo->slp_instances.safe_push (new_instance);\n \n       if (dump_enabled_p ())\n \tvect_print_slp_tree (MSG_NOTE, node);\n@@ -1844,54 +1839,43 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n    trees of packed scalar stmts if SLP is possible.  */\n \n bool\n-vect_analyze_slp (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n-\t\t  unsigned max_tree_size)\n+vect_analyze_slp (vec_info *vinfo, unsigned max_tree_size)\n {\n   unsigned int i;\n-  vec<gimple *> grouped_stores;\n-  vec<gimple *> reductions = vNULL;\n-  vec<gimple *> reduc_chains = vNULL;\n   gimple *first_element;\n   bool ok = false;\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location, \"=== vect_analyze_slp ===\\n\");\n \n-  if (loop_vinfo)\n-    {\n-      grouped_stores = LOOP_VINFO_GROUPED_STORES (loop_vinfo);\n-      reduc_chains = LOOP_VINFO_REDUCTION_CHAINS (loop_vinfo);\n-      reductions = LOOP_VINFO_REDUCTIONS (loop_vinfo);\n-    }\n-  else\n-    grouped_stores = BB_VINFO_GROUPED_STORES (bb_vinfo);\n-\n   /* Find SLP sequences starting from groups of grouped stores.  */\n-  FOR_EACH_VEC_ELT (grouped_stores, i, first_element)\n-    if (vect_analyze_slp_instance (loop_vinfo, bb_vinfo, first_element,\n-\t\t\t\t   max_tree_size))\n+  FOR_EACH_VEC_ELT (vinfo->grouped_stores, i, first_element)\n+    if (vect_analyze_slp_instance (vinfo, first_element, max_tree_size))\n       ok = true;\n \n-  if (reduc_chains.length () > 0)\n+  if (loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo))\n     {\n-      /* Find SLP sequences starting from reduction chains.  */\n-      FOR_EACH_VEC_ELT (reduc_chains, i, first_element)\n-        if (vect_analyze_slp_instance (loop_vinfo, bb_vinfo, first_element,\n-\t\t\t\t       max_tree_size))\n-          ok = true;\n-        else\n-          return false;\n+      if (loop_vinfo->reduction_chains.length () > 0)\n+\t{\n+\t  /* Find SLP sequences starting from reduction chains.  */\n+\t  FOR_EACH_VEC_ELT (loop_vinfo->reduction_chains, i, first_element)\n+\t      if (vect_analyze_slp_instance (vinfo, first_element,\n+\t\t\t\t\t     max_tree_size))\n+\t\tok = true;\n+\t      else\n+\t\treturn false;\n \n-      /* Don't try to vectorize SLP reductions if reduction chain was\n-         detected.  */\n-      return ok;\n-    }\n+\t  /* Don't try to vectorize SLP reductions if reduction chain was\n+\t     detected.  */\n+\t  return ok;\n+\t}\n \n-  /* Find SLP sequences starting from groups of reductions.  */\n-  if (reductions.length () > 1\n-      && vect_analyze_slp_instance (loop_vinfo, bb_vinfo, reductions[0],\n-\t\t\t\t    max_tree_size))\n-    ok = true;\n+      /* Find SLP sequences starting from groups of reductions.  */\n+      if (loop_vinfo->reductions.length () > 1\n+\t  && vect_analyze_slp_instance (vinfo, loop_vinfo->reductions[0],\n+\t\t\t\t\tmax_tree_size))\n+\tok = true;\n+    }\n \n   return true;\n }\n@@ -2110,13 +2094,14 @@ new_bb_vec_info (basic_block bb)\n   gimple_stmt_iterator gsi;\n \n   res = (bb_vec_info) xcalloc (1, sizeof (struct _bb_vec_info));\n+  res->kind = vec_info::bb;\n   BB_VINFO_BB (res) = bb;\n \n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       gimple *stmt = gsi_stmt (gsi);\n       gimple_set_uid (stmt, 0);\n-      set_vinfo_for_stmt (stmt, new_stmt_vec_info (stmt, NULL, res));\n+      set_vinfo_for_stmt (stmt, new_stmt_vec_info (stmt, res));\n     }\n \n   BB_VINFO_GROUPED_STORES (res).create (10);\n@@ -2155,7 +2140,7 @@ destroy_bb_vec_info (bb_vec_info bb_vinfo)\n         free_stmt_vec_info (stmt);\n     }\n \n-  vect_destroy_datarefs (NULL, bb_vinfo);\n+  vect_destroy_datarefs (bb_vinfo);\n   free_dependence_relations (BB_VINFO_DDRS (bb_vinfo));\n   BB_VINFO_GROUPED_STORES (bb_vinfo).release ();\n   slp_instances = BB_VINFO_SLP_INSTANCES (bb_vinfo);\n@@ -2367,7 +2352,7 @@ vect_slp_analyze_bb_1 (basic_block bb)\n   if (!bb_vinfo)\n     return NULL;\n \n-  if (!vect_analyze_data_refs (NULL, bb_vinfo, &min_vf, &n_stmts))\n+  if (!vect_analyze_data_refs (bb_vinfo, &min_vf, &n_stmts))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -2389,7 +2374,7 @@ vect_slp_analyze_bb_1 (basic_block bb)\n       return NULL;\n     }\n \n-  if (!vect_analyze_data_ref_accesses (NULL, bb_vinfo))\n+  if (!vect_analyze_data_ref_accesses (bb_vinfo))\n     {\n      if (dump_enabled_p ())\n        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -2400,9 +2385,9 @@ vect_slp_analyze_bb_1 (basic_block bb)\n       return NULL;\n     }\n \n-  vect_pattern_recog (NULL, bb_vinfo);\n+  vect_pattern_recog (bb_vinfo);\n \n-  if (!vect_analyze_data_refs_alignment (NULL, bb_vinfo))\n+  if (!vect_analyze_data_refs_alignment (bb_vinfo))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -2415,7 +2400,7 @@ vect_slp_analyze_bb_1 (basic_block bb)\n \n   /* Check the SLP opportunities in the basic block, analyze and build SLP\n      trees.  */\n-  if (!vect_analyze_slp (NULL, bb_vinfo, n_stmts))\n+  if (!vect_analyze_slp (bb_vinfo, n_stmts))\n     {\n       if (dump_enabled_p ())\n \t{\n@@ -2463,7 +2448,7 @@ vect_slp_analyze_bb_1 (basic_block bb)\n        return NULL;\n      }\n \n-  if (!vect_verify_datarefs_alignment (NULL, bb_vinfo))\n+  if (!vect_verify_datarefs_alignment (bb_vinfo))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -3480,23 +3465,18 @@ vect_remove_slp_scalar_calls (slp_tree node)\n /* Generate vector code for all SLP instances in the loop/basic block.  */\n \n bool\n-vect_schedule_slp (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n+vect_schedule_slp (vec_info *vinfo)\n {\n   vec<slp_instance> slp_instances;\n   slp_instance instance;\n   unsigned int i, vf;\n   bool is_store = false;\n \n-  if (loop_vinfo)\n-    {\n-      slp_instances = LOOP_VINFO_SLP_INSTANCES (loop_vinfo);\n-      vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n-    }\n+  slp_instances = vinfo->slp_instances;\n+  if (is_a <loop_vec_info> (vinfo))\n+    vf = as_a <loop_vec_info> (vinfo)->vectorization_factor;\n   else\n-    {\n-      slp_instances = BB_VINFO_SLP_INSTANCES (bb_vinfo);\n-      vf = 1;\n-    }\n+    vf = 1;\n \n   FOR_EACH_VEC_ELT (slp_instances, i, instance)\n     {\n@@ -3522,7 +3502,7 @@ vect_schedule_slp (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n \t ???  For BB vectorization we can as well remove scalar\n \t stmts starting from the SLP tree root if they have no\n \t uses.  */\n-      if (loop_vinfo)\n+      if (is_a <loop_vec_info> (vinfo))\n \tvect_remove_slp_scalar_calls (root);\n \n       for (j = 0; SLP_TREE_SCALAR_STMTS (root).iterate (j, &store)\n@@ -3578,7 +3558,7 @@ vect_slp_transform_bb (basic_block bb)\n       /* Schedule all the SLP instances when the first SLP stmt is reached.  */\n       if (STMT_SLP_TYPE (stmt_info))\n         {\n-          vect_schedule_slp (NULL, bb_vinfo);\n+          vect_schedule_slp (bb_vinfo);\n           break;\n         }\n     }"}, {"sha": "aed247b027ba77cdfac0e9f7a263e61be1026d8e", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 67, "deletions": 79, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310213d49e368bd3cce0d20febe2666d0262d859/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310213d49e368bd3cce0d20febe2666d0262d859/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=310213d49e368bd3cce0d20febe2666d0262d859", "patch": "@@ -102,19 +102,8 @@ record_stmt_cost (stmt_vector_for_cost *body_cost_vec, int count,\n \t \n     }\n   else\n-    {\n-      loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-      bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n-      void *target_cost_data;\n-\n-      if (loop_vinfo)\n-\ttarget_cost_data = LOOP_VINFO_TARGET_COST_DATA (loop_vinfo);\n-      else\n-\ttarget_cost_data = BB_VINFO_TARGET_COST_DATA (bb_vinfo);\n-\n-      return add_stmt_cost (target_cost_data, count, kind, stmt_info,\n-\t\t\t    misalign, where);\n-    }\n+    return add_stmt_cost (stmt_info->vinfo->target_cost_data,\n+\t\t\t  count, kind, stmt_info, misalign, where);\n }\n \n /* Return a variable of type ELEM_TYPE[NELEMS].  */\n@@ -470,7 +459,7 @@ process_use (gimple *stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n   if (!force && !exist_non_indexing_operands_for_use_p (use, stmt))\n      return true;\n \n-  if (!vect_is_simple_use (use, stmt, loop_vinfo, NULL, &def_stmt, &def, &dt))\n+  if (!vect_is_simple_use (use, stmt, loop_vinfo, &def_stmt, &def, &dt))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -1375,7 +1364,7 @@ vect_get_vec_def_for_operand (tree op, gimple *stmt, tree *scalar_def)\n       dump_printf (MSG_NOTE, \"\\n\");\n     }\n \n-  is_simple_use = vect_is_simple_use (op, stmt, loop_vinfo, NULL,\n+  is_simple_use = vect_is_simple_use (op, stmt, loop_vinfo,\n \t\t\t\t      &def_stmt, &def, &dt);\n   gcc_assert (is_simple_use);\n   if (dump_enabled_p ())\n@@ -1651,8 +1640,7 @@ vect_finish_stmt_generation (gimple *stmt, gimple *vec_stmt,\n \t\t\t     gimple_stmt_iterator *gsi)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n+  vec_info *vinfo = stmt_info->vinfo;\n \n   gcc_assert (gimple_code (stmt) != GIMPLE_LABEL);\n \n@@ -1684,8 +1672,7 @@ vect_finish_stmt_generation (gimple *stmt, gimple *vec_stmt,\n     }\n   gsi_insert_before (gsi, vec_stmt, GSI_SAME_STMT);\n \n-  set_vinfo_for_stmt (vec_stmt, new_stmt_vec_info (vec_stmt, loop_vinfo,\n-                                                   bb_vinfo));\n+  set_vinfo_for_stmt (vec_stmt, new_stmt_vec_info (vec_stmt, vinfo));\n \n   if (dump_enabled_p ())\n     {\n@@ -1814,7 +1801,7 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n       gather_decl = vect_check_gather_scatter (stmt, loop_vinfo, &gather_base,\n \t\t\t\t       &gather_off, &gather_scale);\n       gcc_assert (gather_decl);\n-      if (!vect_is_simple_use_1 (gather_off, NULL, loop_vinfo, NULL,\n+      if (!vect_is_simple_use_1 (gather_off, NULL, loop_vinfo,\n \t\t\t\t &def_stmt, &def, &gather_dt,\n \t\t\t\t &gather_off_vectype))\n \t{\n@@ -1846,14 +1833,14 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (TREE_CODE (mask) != SSA_NAME)\n     return false;\n \n-  if (!vect_is_simple_use (mask, stmt, loop_vinfo, NULL,\n+  if (!vect_is_simple_use (mask, stmt, loop_vinfo,\n \t\t\t   &def_stmt, &def, &dt))\n     return false;\n \n   if (is_store)\n     {\n       tree rhs = gimple_call_arg (stmt, 3);\n-      if (!vect_is_simple_use (rhs, stmt, loop_vinfo, NULL,\n+      if (!vect_is_simple_use (rhs, stmt, loop_vinfo,\n \t\t\t       &def_stmt, &def, &dt))\n \treturn false;\n     }\n@@ -1971,7 +1958,7 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\tvec_mask = vect_get_vec_def_for_operand (mask, stmt, NULL);\n \t      else\n \t\t{\n-\t\t  vect_is_simple_use (vec_mask, NULL, loop_vinfo, NULL,\n+\t\t  vect_is_simple_use (vec_mask, NULL, loop_vinfo,\n \t\t\t\t      &def_stmt, &def, &dt);\n \t\t  vec_mask = vect_get_vec_def_for_stmt_copy (dt, vec_mask);\n \t\t}\n@@ -2068,10 +2055,10 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t    }\n \t  else\n \t    {\n-\t      vect_is_simple_use (vec_rhs, NULL, loop_vinfo, NULL, &def_stmt,\n+\t      vect_is_simple_use (vec_rhs, NULL, loop_vinfo, &def_stmt,\n \t\t\t\t  &def, &dt);\n \t      vec_rhs = vect_get_vec_def_for_stmt_copy (dt, vec_rhs);\n-\t      vect_is_simple_use (vec_mask, NULL, loop_vinfo, NULL, &def_stmt,\n+\t      vect_is_simple_use (vec_mask, NULL, loop_vinfo, &def_stmt,\n \t\t\t\t  &def, &dt);\n \t      vec_mask = vect_get_vec_def_for_stmt_copy (dt, vec_mask);\n \t      dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, gsi, stmt,\n@@ -2121,7 +2108,7 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t    }\n \t  else\n \t    {\n-\t      vect_is_simple_use (vec_mask, NULL, loop_vinfo, NULL, &def_stmt,\n+\t      vect_is_simple_use (vec_mask, NULL, loop_vinfo, &def_stmt,\n \t\t\t\t  &def, &dt);\n \t      vec_mask = vect_get_vec_def_for_stmt_copy (dt, vec_mask);\n \t      dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, gsi, stmt,\n@@ -2192,6 +2179,7 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   int nunits_out;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n+  vec_info *vinfo = stmt_info->vinfo;\n   tree fndecl, new_temp, def, rhs_type;\n   gimple *def_stmt;\n   enum vect_def_type dt[3]\n@@ -2265,7 +2253,7 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       if (!rhs_type)\n \trhs_type = TREE_TYPE (op);\n \n-      if (!vect_is_simple_use_1 (op, stmt, loop_vinfo, bb_vinfo,\n+      if (!vect_is_simple_use_1 (op, stmt, vinfo,\n \t\t\t\t &def_stmt, &def, &dt[i], &opvectype))\n \t{\n \t  if (dump_enabled_p ())\n@@ -2715,6 +2703,7 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n   unsigned int nunits;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n+  vec_info *vinfo = stmt_info->vinfo;\n   struct loop *loop = loop_vinfo ? LOOP_VINFO_LOOP (loop_vinfo) : NULL;\n   tree fndecl, new_temp, def;\n   gimple *def_stmt;\n@@ -2779,7 +2768,7 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n       thisarginfo.simd_lane_linear = false;\n \n       op = gimple_call_arg (stmt, i);\n-      if (!vect_is_simple_use_1 (op, stmt, loop_vinfo, bb_vinfo,\n+      if (!vect_is_simple_use_1 (op, stmt, vinfo,\n \t\t\t\t &def_stmt, &def, &thisarginfo.dt,\n \t\t\t\t &thisarginfo.vectype)\n \t  || thisarginfo.dt == vect_uninitialized_def)\n@@ -3139,8 +3128,7 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t  tree phi_res = copy_ssa_name (op);\n \t\t  gphi *new_phi = create_phi_node (phi_res, loop->header);\n \t\t  set_vinfo_for_stmt (new_phi,\n-\t\t\t\t      new_stmt_vec_info (new_phi, loop_vinfo,\n-\t\t\t\t\t\t\t NULL));\n+\t\t\t\t      new_stmt_vec_info (new_phi, loop_vinfo));\n \t\t  add_phi_arg (new_phi, arginfo[i].op,\n \t\t\t       loop_preheader_edge (loop), UNKNOWN_LOCATION);\n \t\t  enum tree_code code\n@@ -3158,8 +3146,7 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t  gimple_stmt_iterator si = gsi_after_labels (loop->header);\n \t\t  gsi_insert_after (&si, new_stmt, GSI_NEW_STMT);\n \t\t  set_vinfo_for_stmt (new_stmt,\n-\t\t\t\t      new_stmt_vec_info (new_stmt, loop_vinfo,\n-\t\t\t\t\t\t\t NULL));\n+\t\t\t\t      new_stmt_vec_info (new_stmt, loop_vinfo));\n \t\t  add_phi_arg (new_phi, phi_arg, loop_latch_edge (loop),\n \t\t\t       UNKNOWN_LOCATION);\n \t\t  arginfo[i].op = phi_res;\n@@ -3580,6 +3567,7 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n   vec<tree> vec_oprnds1 = vNULL;\n   tree vop0;\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n+  vec_info *vinfo = stmt_info->vinfo;\n   int multi_step_cvt = 0;\n   vec<tree> vec_dsts = vNULL;\n   vec<tree> interm_types = vNULL;\n@@ -3642,7 +3630,7 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n     }\n \n   /* Check the operands of the operation.  */\n-  if (!vect_is_simple_use_1 (op0, stmt, loop_vinfo, bb_vinfo,\n+  if (!vect_is_simple_use_1 (op0, stmt, vinfo,\n \t\t\t     &def_stmt, &def, &dt[0], &vectype_in))\n     {\n       if (dump_enabled_p ())\n@@ -3659,10 +3647,10 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n       /* For WIDEN_MULT_EXPR, if OP0 is a constant, use the type of\n \t OP1.  */\n       if (CONSTANT_CLASS_P (op0))\n-\tok = vect_is_simple_use_1 (op1, stmt, loop_vinfo, bb_vinfo,\n+\tok = vect_is_simple_use_1 (op1, stmt, vinfo,\n \t\t\t\t   &def_stmt, &def, &dt[1], &vectype_in);\n       else\n-\tok = vect_is_simple_use (op1, stmt, loop_vinfo, bb_vinfo, &def_stmt,\n+\tok = vect_is_simple_use (op1, stmt, vinfo, &def_stmt,\n \t\t\t\t &def, &dt[1]);\n \n       if (!ok)\n@@ -4150,6 +4138,7 @@ vectorizable_assignment (gimple *stmt, gimple_stmt_iterator *gsi,\n   vec<tree> vec_oprnds = vNULL;\n   tree vop;\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n+  vec_info *vinfo = stmt_info->vinfo;\n   gimple *new_stmt = NULL;\n   stmt_vec_info prev_stmt_info = NULL;\n   enum tree_code code;\n@@ -4193,7 +4182,7 @@ vectorizable_assignment (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   gcc_assert (ncopies >= 1);\n \n-  if (!vect_is_simple_use_1 (op, stmt, loop_vinfo, bb_vinfo,\n+  if (!vect_is_simple_use_1 (op, stmt, vinfo,\n \t\t\t     &def_stmt, &def, &dt[0], &vectype_in))\n     {\n       if (dump_enabled_p ())\n@@ -4365,6 +4354,7 @@ vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n   unsigned int k;\n   bool scalar_shift_arg = true;\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n+  vec_info *vinfo = stmt_info->vinfo;\n   int vf;\n \n   if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n@@ -4398,7 +4388,7 @@ vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n     }\n \n   op0 = gimple_assign_rhs1 (stmt);\n-  if (!vect_is_simple_use_1 (op0, stmt, loop_vinfo, bb_vinfo,\n+  if (!vect_is_simple_use_1 (op0, stmt, vinfo,\n                              &def_stmt, &def, &dt[0], &vectype))\n     {\n       if (dump_enabled_p ())\n@@ -4426,7 +4416,7 @@ vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n     return false;\n \n   op1 = gimple_assign_rhs2 (stmt);\n-  if (!vect_is_simple_use_1 (op1, stmt, loop_vinfo, bb_vinfo, &def_stmt,\n+  if (!vect_is_simple_use_1 (op1, stmt, vinfo, &def_stmt,\n \t\t\t     &def, &dt[1], &op1_vectype))\n     {\n       if (dump_enabled_p ())\n@@ -4728,6 +4718,7 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n   vec<tree> vec_oprnds2 = vNULL;\n   tree vop0, vop1, vop2;\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n+  vec_info *vinfo = stmt_info->vinfo;\n   int vf;\n \n   if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n@@ -4780,7 +4771,7 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n     }\n \n   op0 = gimple_assign_rhs1 (stmt);\n-  if (!vect_is_simple_use_1 (op0, stmt, loop_vinfo, bb_vinfo,\n+  if (!vect_is_simple_use_1 (op0, stmt, vinfo,\n \t\t\t     &def_stmt, &def, &dt[0], &vectype))\n     {\n       if (dump_enabled_p ())\n@@ -4816,7 +4807,7 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (op_type == binary_op || op_type == ternary_op)\n     {\n       op1 = gimple_assign_rhs2 (stmt);\n-      if (!vect_is_simple_use (op1, stmt, loop_vinfo, bb_vinfo, &def_stmt,\n+      if (!vect_is_simple_use (op1, stmt, vinfo, &def_stmt,\n \t\t\t       &def, &dt[1]))\n \t{\n \t  if (dump_enabled_p ())\n@@ -4828,7 +4819,7 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (op_type == ternary_op)\n     {\n       op2 = gimple_assign_rhs3 (stmt);\n-      if (!vect_is_simple_use (op2, stmt, loop_vinfo, bb_vinfo, &def_stmt,\n+      if (!vect_is_simple_use (op2, stmt, vinfo, &def_stmt,\n \t\t\t       &def, &dt[2]))\n \t{\n \t  if (dump_enabled_p ())\n@@ -5131,6 +5122,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   bool slp = (slp_node != NULL);\n   unsigned int vec_num;\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n+  vec_info *vinfo = stmt_info->vinfo;\n   tree aggr_type;\n   tree scatter_base = NULL_TREE, scatter_off = NULL_TREE;\n   tree scatter_off_vectype = NULL_TREE, scatter_decl = NULL_TREE;\n@@ -5191,7 +5183,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n     }\n \n   op = gimple_assign_rhs1 (stmt);\n-  if (!vect_is_simple_use (op, stmt, loop_vinfo, bb_vinfo, &def_stmt,\n+  if (!vect_is_simple_use (op, stmt, vinfo, &def_stmt,\n \t\t\t   &def, &dt))\n     {\n       if (dump_enabled_p ())\n@@ -5282,7 +5274,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n             {\n \t      gcc_assert (gimple_assign_single_p (next_stmt));\n \t      op = gimple_assign_rhs1 (next_stmt);\n-              if (!vect_is_simple_use (op, next_stmt, loop_vinfo, bb_vinfo,\n+              if (!vect_is_simple_use (op, next_stmt, vinfo,\n \t\t\t\t       &def_stmt, &def, &dt))\n                 {\n                   if (dump_enabled_p ())\n@@ -5302,7 +5294,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       scatter_decl = vect_check_gather_scatter (stmt, loop_vinfo, &scatter_base,\n \t\t\t\t\t\t&scatter_off, &scatter_scale);\n       gcc_assert (scatter_decl);\n-      if (!vect_is_simple_use_1 (scatter_off, NULL, loop_vinfo, bb_vinfo,\n+      if (!vect_is_simple_use_1 (scatter_off, NULL, vinfo,\n \t\t\t\t &def_stmt, &def, &scatter_idx_dt,\n \t\t\t\t &scatter_off_vectype))\n \t{\n@@ -5579,7 +5571,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t loop, &incr_gsi, insert_after,\n \t\t &offvar, NULL);\n       incr = gsi_stmt (incr_gsi);\n-      set_vinfo_for_stmt (incr, new_stmt_vec_info (incr, loop_vinfo, NULL));\n+      set_vinfo_for_stmt (incr, new_stmt_vec_info (incr, loop_vinfo));\n \n       stride_step = force_gimple_operand (stride_step, &stmts, true, NULL_TREE);\n       if (stmts)\n@@ -5628,8 +5620,8 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t    vec_oprnd = vec_oprnds[j];\n \t\t  else\n \t\t    {\n-\t\t      vect_is_simple_use (vec_oprnd, NULL, loop_vinfo,\n-\t\t\t\t\t  bb_vinfo, &def_stmt, &def, &dt);\n+\t\t      vect_is_simple_use (vec_oprnd, NULL, vinfo,\n+\t\t\t\t\t  &def_stmt, &def, &dt);\n \t\t      vec_oprnd = vect_get_vec_def_for_stmt_copy (dt, vec_oprnd);\n \t\t    }\n \t\t}\n@@ -5818,7 +5810,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t  for (i = 0; i < group_size; i++)\n \t    {\n \t      op = oprnds[i];\n-\t      vect_is_simple_use (op, NULL, loop_vinfo, bb_vinfo, &def_stmt,\n+\t      vect_is_simple_use (op, NULL, vinfo, &def_stmt,\n \t\t\t\t  &def, &dt);\n \t      vec_oprnd = vect_get_vec_def_for_stmt_copy (dt, op);\n \t      dr_chain[i] = vec_oprnd;\n@@ -6134,6 +6126,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   tree gather_off_vectype = NULL_TREE, gather_decl = NULL_TREE;\n   int gather_scale = 1;\n   enum vect_def_type gather_dt = vect_unknown_def_type;\n+  vec_info *vinfo = stmt_info->vinfo;\n \n   if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n     return false;\n@@ -6296,7 +6289,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       gather_decl = vect_check_gather_scatter (stmt, loop_vinfo, &gather_base,\n \t\t\t\t\t       &gather_off, &gather_scale);\n       gcc_assert (gather_decl);\n-      if (!vect_is_simple_use_1 (gather_off, NULL, loop_vinfo, bb_vinfo,\n+      if (!vect_is_simple_use_1 (gather_off, NULL, vinfo,\n \t\t\t\t &def_stmt, &def, &gather_dt,\n \t\t\t\t &gather_off_vectype))\n \t{\n@@ -6602,7 +6595,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t loop, &incr_gsi, insert_after,\n \t\t &offvar, NULL);\n       incr = gsi_stmt (incr_gsi);\n-      set_vinfo_for_stmt (incr, new_stmt_vec_info (incr, loop_vinfo, NULL));\n+      set_vinfo_for_stmt (incr, new_stmt_vec_info (incr, loop_vinfo));\n \n       stride_step = force_gimple_operand (unshare_expr (stride_step),\n \t\t\t\t\t  &stmts, true, NULL_TREE);\n@@ -7146,8 +7139,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t    }\n \t\t  new_stmt = SSA_NAME_DEF_STMT (new_temp);\n \t\t  set_vinfo_for_stmt (new_stmt,\n-\t\t\t\t      new_stmt_vec_info (new_stmt, loop_vinfo,\n-\t\t\t\t\t\t\t bb_vinfo));\n+\t\t\t\t      new_stmt_vec_info (new_stmt, vinfo));\n \t\t}\n \n \t      if (negative)\n@@ -7229,8 +7221,8 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n    condition operands are supportable using vec_is_simple_use.  */\n \n static bool\n-vect_is_simple_cond (tree cond, gimple *stmt, loop_vec_info loop_vinfo,\n-\t\t     bb_vec_info bb_vinfo, tree *comp_vectype)\n+vect_is_simple_cond (tree cond, gimple *stmt, vec_info *vinfo,\n+\t\t     tree *comp_vectype)\n {\n   tree lhs, rhs;\n   tree def;\n@@ -7246,7 +7238,7 @@ vect_is_simple_cond (tree cond, gimple *stmt, loop_vec_info loop_vinfo,\n   if (TREE_CODE (lhs) == SSA_NAME)\n     {\n       gimple *lhs_def_stmt = SSA_NAME_DEF_STMT (lhs);\n-      if (!vect_is_simple_use_1 (lhs, stmt, loop_vinfo, bb_vinfo,\n+      if (!vect_is_simple_use_1 (lhs, stmt, vinfo,\n \t\t\t\t &lhs_def_stmt, &def, &dt, &vectype1))\n \treturn false;\n     }\n@@ -7257,7 +7249,7 @@ vect_is_simple_cond (tree cond, gimple *stmt, loop_vec_info loop_vinfo,\n   if (TREE_CODE (rhs) == SSA_NAME)\n     {\n       gimple *rhs_def_stmt = SSA_NAME_DEF_STMT (rhs);\n-      if (!vect_is_simple_use_1 (rhs, stmt, loop_vinfo, bb_vinfo,\n+      if (!vect_is_simple_use_1 (rhs, stmt, vinfo,\n \t\t\t\t &rhs_def_stmt, &def, &dt, &vectype2))\n \treturn false;\n     }\n@@ -7355,15 +7347,14 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n   then_clause = gimple_assign_rhs2 (stmt);\n   else_clause = gimple_assign_rhs3 (stmt);\n \n-  if (!vect_is_simple_cond (cond_expr, stmt, loop_vinfo, bb_vinfo,\n-\t\t\t    &comp_vectype)\n+  if (!vect_is_simple_cond (cond_expr, stmt, stmt_info->vinfo, &comp_vectype)\n       || !comp_vectype)\n     return false;\n \n   if (TREE_CODE (then_clause) == SSA_NAME)\n     {\n       gimple *then_def_stmt = SSA_NAME_DEF_STMT (then_clause);\n-      if (!vect_is_simple_use (then_clause, stmt, loop_vinfo, bb_vinfo,\n+      if (!vect_is_simple_use (then_clause, stmt, stmt_info->vinfo,\n \t\t\t       &then_def_stmt, &def, &dt))\n \treturn false;\n     }\n@@ -7375,7 +7366,7 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (TREE_CODE (else_clause) == SSA_NAME)\n     {\n       gimple *else_def_stmt = SSA_NAME_DEF_STMT (else_clause);\n-      if (!vect_is_simple_use (else_clause, stmt, loop_vinfo, bb_vinfo,\n+      if (!vect_is_simple_use (else_clause, stmt, stmt_info->vinfo,\n \t\t\t       &else_def_stmt, &def, &dt))\n \treturn false;\n     }\n@@ -7442,21 +7433,21 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n \t      vect_get_vec_def_for_operand (TREE_OPERAND (cond_expr, 0),\n \t\t\t\t\t    stmt, NULL);\n \t      vect_is_simple_use (TREE_OPERAND (cond_expr, 0), stmt,\n-\t\t\t\t  loop_vinfo, NULL, &gtemp, &def, &dts[0]);\n+\t\t\t\t  loop_vinfo, &gtemp, &def, &dts[0]);\n \n \t      vec_cond_rhs =\n \t\tvect_get_vec_def_for_operand (TREE_OPERAND (cond_expr, 1),\n \t\t\t\t\t\tstmt, NULL);\n \t      vect_is_simple_use (TREE_OPERAND (cond_expr, 1), stmt,\n-\t\t\t\t  loop_vinfo, NULL, &gtemp, &def, &dts[1]);\n+\t\t\t\t  loop_vinfo, &gtemp, &def, &dts[1]);\n \t      if (reduc_index == 1)\n \t\tvec_then_clause = reduc_def;\n \t      else\n \t\t{\n \t\t  vec_then_clause = vect_get_vec_def_for_operand (then_clause,\n \t\t \t\t  \t\t\t      stmt, NULL);\n \t          vect_is_simple_use (then_clause, stmt, loop_vinfo,\n-\t\t\t\t\t  NULL, &gtemp, &def, &dts[2]);\n+\t\t\t\t      &gtemp, &def, &dts[2]);\n \t\t}\n \t      if (reduc_index == 2)\n \t\tvec_else_clause = reduc_def;\n@@ -7465,7 +7456,7 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t  vec_else_clause = vect_get_vec_def_for_operand (else_clause,\n \t\t\t\t\t\t\t      stmt, NULL);\n \t\t  vect_is_simple_use (else_clause, stmt, loop_vinfo,\n-\t\t\t\t  NULL, &gtemp, &def, &dts[3]);\n+\t\t\t\t      &gtemp, &def, &dts[3]);\n \t\t}\n \t    }\n \t}\n@@ -7983,16 +7974,14 @@ vect_remove_stores (gimple *first_stmt)\n    Create and initialize a new stmt_vec_info struct for STMT.  */\n \n stmt_vec_info\n-new_stmt_vec_info (gimple *stmt, loop_vec_info loop_vinfo,\n-                   bb_vec_info bb_vinfo)\n+new_stmt_vec_info (gimple *stmt, vec_info *vinfo)\n {\n   stmt_vec_info res;\n   res = (stmt_vec_info) xcalloc (1, sizeof (struct _stmt_vec_info));\n \n   STMT_VINFO_TYPE (res) = undef_vec_info_type;\n   STMT_VINFO_STMT (res) = stmt;\n-  STMT_VINFO_LOOP_VINFO (res) = loop_vinfo;\n-  STMT_VINFO_BB_VINFO (res) = bb_vinfo;\n+  res->vinfo = vinfo;\n   STMT_VINFO_RELEVANT (res) = vect_unused_in_scope;\n   STMT_VINFO_LIVE_P (res) = false;\n   STMT_VINFO_VECTYPE (res) = NULL;\n@@ -8222,9 +8211,8 @@ get_same_sized_vectype (tree scalar_type, tree vector_type)\n    For now, operands defined outside the basic block are not supported.  */\n \n bool\n-vect_is_simple_use (tree operand, gimple *stmt, loop_vec_info loop_vinfo,\n-                    bb_vec_info bb_vinfo, gimple **def_stmt,\n-\t\t    tree *def, enum vect_def_type *dt)\n+vect_is_simple_use (tree operand, gimple *stmt, vec_info *vinfo,\n+                    gimple **def_stmt, tree *def, enum vect_def_type *dt)\n {\n   *def_stmt = NULL;\n   *def = NULL_TREE;\n@@ -8274,15 +8262,16 @@ vect_is_simple_use (tree operand, gimple *stmt, loop_vec_info loop_vinfo,\n     }\n \n   basic_block bb = gimple_bb (*def_stmt);\n-  if ((loop_vinfo && !flow_bb_inside_loop_p (LOOP_VINFO_LOOP (loop_vinfo), bb))\n-      || (bb_vinfo\n-\t  && (bb != BB_VINFO_BB (bb_vinfo)\n+  if ((is_a <loop_vec_info> (vinfo)\n+       && !flow_bb_inside_loop_p (as_a <loop_vec_info> (vinfo)->loop, bb))\n+      || (is_a <bb_vec_info> (vinfo)\n+\t  && (bb != as_a <bb_vec_info> (vinfo)->bb\n \t      || gimple_code (*def_stmt) == GIMPLE_PHI)))\n     *dt = vect_external_def;\n   else\n     {\n       stmt_vec_info stmt_vinfo = vinfo_for_stmt (*def_stmt);\n-      if (bb_vinfo && !STMT_VINFO_VECTORIZABLE (stmt_vinfo))\n+      if (is_a <bb_vec_info> (vinfo) && !STMT_VINFO_VECTORIZABLE (stmt_vinfo))\n \t*dt = vect_external_def;\n       else\n \t*dt = STMT_VINFO_DEF_TYPE (stmt_vinfo);\n@@ -8369,12 +8358,11 @@ vect_is_simple_use (tree operand, gimple *stmt, loop_vec_info loop_vinfo,\n    scalar operand.  */\n \n bool\n-vect_is_simple_use_1 (tree operand, gimple *stmt, loop_vec_info loop_vinfo,\n-\t\t      bb_vec_info bb_vinfo, gimple **def_stmt,\n+vect_is_simple_use_1 (tree operand, gimple *stmt, vec_info *vinfo,\n+\t\t      gimple **def_stmt,\n \t\t      tree *def, enum vect_def_type *dt, tree *vectype)\n {\n-  if (!vect_is_simple_use (operand, stmt, loop_vinfo, bb_vinfo, def_stmt,\n-\t\t\t   def, dt))\n+  if (!vect_is_simple_use (operand, stmt, vinfo, def_stmt, def, dt))\n     return false;\n \n   /* Now get a vector type if the def is internal, otherwise supply"}, {"sha": "4efb22fcff8c2bf1b437de7184f5ddafc121fb20", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310213d49e368bd3cce0d20febe2666d0262d859/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310213d49e368bd3cce0d20febe2666d0262d859/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=310213d49e368bd3cce0d20febe2666d0262d859", "patch": "@@ -329,25 +329,19 @@ shrink_simd_arrays\n /* A helper function to free data refs.  */\n \n void\n-vect_destroy_datarefs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n+vect_destroy_datarefs (vec_info *vinfo)\n {\n-  vec<data_reference_p> datarefs;\n   struct data_reference *dr;\n   unsigned int i;\n \n- if (loop_vinfo)\n-    datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n-  else\n-    datarefs = BB_VINFO_DATAREFS (bb_vinfo);\n-\n-  FOR_EACH_VEC_ELT (datarefs, i, dr)\n+  FOR_EACH_VEC_ELT (vinfo->datarefs, i, dr)\n     if (dr->aux)\n       {\n         free (dr->aux);\n         dr->aux = NULL;\n       }\n \n-  free_data_refs (datarefs);\n+  free_data_refs (vinfo->datarefs);\n }\n \n "}, {"sha": "53c90ea66acde7485e51924ccc4ee626f667df88", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 70, "deletions": 59, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310213d49e368bd3cce0d20febe2666d0262d859/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310213d49e368bd3cce0d20febe2666d0262d859/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=310213d49e368bd3cce0d20febe2666d0262d859", "patch": "@@ -230,11 +230,51 @@ peel_info_hasher::equal (const _vect_peel_info *a, const _vect_peel_info *b)\n   return (a->npeel == b->npeel);\n }\n \n+/* Vectorizer state common between loop and basic-block vectorization.  */\n+struct vec_info {\n+  enum { bb, loop } kind;\n+\n+  /* All SLP instances.  */\n+  vec<slp_instance> slp_instances;\n+\n+  /* All data references.  */\n+  vec<data_reference_p> datarefs;\n+\n+  /* All data dependences.  */\n+  vec<ddr_p> ddrs;\n+\n+  /* All interleaving chains of stores, represented by the first\n+     stmt in the chain.  */\n+  vec<gimple *> grouped_stores;\n+\n+  /* Cost data used by the target cost model.  */\n+  void *target_cost_data;\n+};\n+\n+struct _loop_vec_info;\n+struct _bb_vec_info;\n+\n+template<>\n+template<>\n+inline bool\n+is_a_helper <_loop_vec_info *>::test (vec_info *i)\n+{\n+  return i->kind == vec_info::loop;\n+}\n+\n+template<>\n+template<>\n+inline bool\n+is_a_helper <_bb_vec_info *>::test (vec_info *i)\n+{\n+  return i->kind == vec_info::bb;\n+}\n+\n \n /*-----------------------------------------------------------------*/\n /* Info on vectorized loops.                                       */\n /*-----------------------------------------------------------------*/\n-typedef struct _loop_vec_info {\n+typedef struct _loop_vec_info : public vec_info {\n \n   /* The loop to which this info struct refers to.  */\n   struct loop *loop;\n@@ -286,12 +326,6 @@ typedef struct _loop_vec_info {\n   /* The loop nest in which the data dependences are computed.  */\n   vec<loop_p> loop_nest;\n \n-  /* All data references in the loop.  */\n-  vec<data_reference_p> datarefs;\n-\n-  /* All data dependences in the loop.  */\n-  vec<ddr_p> ddrs;\n-\n   /* Data Dependence Relations defining address ranges that are candidates\n      for a run-time aliasing check.  */\n   vec<ddr_p> may_alias_ddrs;\n@@ -304,14 +338,6 @@ typedef struct _loop_vec_info {\n      runtime (loop versioning) misalignment check.  */\n   vec<gimple *> may_misalign_stmts;\n \n-  /* All interleaving chains of stores in the loop, represented by the first\n-     stmt in the chain.  */\n-  vec<gimple *> grouped_stores;\n-\n-  /* All SLP instances in the loop. This is a subset of the set of GROUP_STORES\n-     of the loop.  */\n-  vec<slp_instance> slp_instances;\n-\n   /* The unrolling factor needed to SLP the loop. In case of that pure SLP is\n      applied to the loop, i.e., no unrolling is needed, this is 1.  */\n   unsigned slp_unrolling_factor;\n@@ -332,9 +358,6 @@ typedef struct _loop_vec_info {\n   /* Cost of a single scalar iteration.  */\n   int single_scalar_iteration_cost;\n \n-  /* Cost data used by the target cost model.  */\n-  void *target_cost_data;\n-\n   /* When we have grouped data accesses with gaps, we may introduce invalid\n      memory accesses.  We peel the last iteration of the loop to prevent\n      this.  */\n@@ -434,26 +457,9 @@ nested_in_vect_loop_p (struct loop *loop, gimple *stmt)\n           && (loop->inner == (gimple_bb (stmt))->loop_father));\n }\n \n-typedef struct _bb_vec_info {\n-\n+typedef struct _bb_vec_info : public vec_info\n+{\n   basic_block bb;\n-  /* All interleaving chains of stores in the basic block, represented by the\n-     first stmt in the chain.  */\n-  vec<gimple *> grouped_stores;\n-\n-  /* All SLP instances in the basic block. This is a subset of the set of\n-     GROUP_STORES of the basic block.  */\n-  vec<slp_instance> slp_instances;\n-\n-  /* All data references in the basic block.  */\n-  vec<data_reference_p> datarefs;\n-\n-  /* All data dependences in the basic block.  */\n-  vec<ddr_p> ddrs;\n-\n-  /* Cost data used by the target cost model.  */\n-  void *target_cost_data;\n-\n } *bb_vec_info;\n \n #define BB_VINFO_BB(B)               (B)->bb\n@@ -551,8 +557,8 @@ typedef struct _stmt_vec_info {\n   /* The stmt to which this info struct refers to.  */\n   gimple *stmt;\n \n-  /* The loop_vec_info with respect to which STMT is vectorized.  */\n-  loop_vec_info loop_vinfo;\n+  /* The vec_info with respect to which STMT is vectorized.  */\n+  vec_info *vinfo;\n \n   /* The vector type to be used for the LHS of this statement.  */\n   tree vectype;\n@@ -639,9 +645,6 @@ typedef struct _stmt_vec_info {\n      indicates whether the stmt needs to be vectorized.  */\n   enum vect_relevant relevant;\n \n-  /* The bb_vec_info with respect to which STMT is vectorized.  */\n-  bb_vec_info bb_vinfo;\n-\n   /* Is this statement vectorizable or should it be skipped in (partial)\n      vectorization.  */\n   bool vectorizable;\n@@ -659,8 +662,20 @@ typedef struct _stmt_vec_info {\n /* Access Functions.  */\n #define STMT_VINFO_TYPE(S)                 (S)->type\n #define STMT_VINFO_STMT(S)                 (S)->stmt\n-#define STMT_VINFO_LOOP_VINFO(S)           (S)->loop_vinfo\n-#define STMT_VINFO_BB_VINFO(S)             (S)->bb_vinfo\n+inline loop_vec_info\n+STMT_VINFO_LOOP_VINFO (stmt_vec_info stmt_vinfo)\n+{\n+  if (loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (stmt_vinfo->vinfo))\n+    return loop_vinfo;\n+  return NULL;\n+}\n+inline bb_vec_info\n+STMT_VINFO_BB_VINFO (stmt_vec_info stmt_vinfo)\n+{\n+  if (bb_vec_info bb_vinfo = dyn_cast <bb_vec_info> (stmt_vinfo->vinfo))\n+    return bb_vinfo;\n+  return NULL;\n+}\n #define STMT_VINFO_RELEVANT(S)             (S)->relevant\n #define STMT_VINFO_LIVE_P(S)               (S)->live\n #define STMT_VINFO_VECTYPE(S)              (S)->vectype\n@@ -996,11 +1011,9 @@ extern bool vect_can_advance_ivs_p (loop_vec_info);\n extern unsigned int current_vector_size;\n extern tree get_vectype_for_scalar_type (tree);\n extern tree get_same_sized_vectype (tree, tree);\n-extern bool vect_is_simple_use (tree, gimple *, loop_vec_info,\n-\t\t\t\tbb_vec_info, gimple **,\n+extern bool vect_is_simple_use (tree, gimple *, vec_info *, gimple **,\n                                 tree *,  enum vect_def_type *);\n-extern bool vect_is_simple_use_1 (tree, gimple *, loop_vec_info,\n-\t\t\t\t  bb_vec_info, gimple **,\n+extern bool vect_is_simple_use_1 (tree, gimple *, vec_info *, gimple **,\n \t\t\t\t  tree *,  enum vect_def_type *, tree *);\n extern bool supportable_widening_operation (enum tree_code, gimple *, tree,\n \t\t\t\t\t    tree, enum tree_code *,\n@@ -1009,8 +1022,7 @@ extern bool supportable_widening_operation (enum tree_code, gimple *, tree,\n extern bool supportable_narrowing_operation (enum tree_code, tree, tree,\n \t\t\t\t\t     enum tree_code *,\n \t\t\t\t\t     int *, vec<tree> *);\n-extern stmt_vec_info new_stmt_vec_info (gimple *stmt, loop_vec_info,\n-                                        bb_vec_info);\n+extern stmt_vec_info new_stmt_vec_info (gimple *stmt, vec_info *);\n extern void free_stmt_vec_info (gimple *stmt);\n extern tree vectorizable_function (gcall *, tree, tree);\n extern void vect_model_simple_cost (stmt_vec_info, int, enum vect_def_type *,\n@@ -1060,14 +1072,13 @@ extern tree vect_get_smallest_scalar_type (gimple *, HOST_WIDE_INT *,\n extern bool vect_analyze_data_ref_dependences (loop_vec_info, int *);\n extern bool vect_slp_analyze_data_ref_dependences (bb_vec_info);\n extern bool vect_enhance_data_refs_alignment (loop_vec_info);\n-extern bool vect_analyze_data_refs_alignment (loop_vec_info, bb_vec_info);\n-extern bool vect_verify_datarefs_alignment (loop_vec_info, bb_vec_info);\n-extern bool vect_analyze_data_ref_accesses (loop_vec_info, bb_vec_info);\n+extern bool vect_analyze_data_refs_alignment (vec_info *);\n+extern bool vect_verify_datarefs_alignment (vec_info *);\n+extern bool vect_analyze_data_ref_accesses (vec_info *);\n extern bool vect_prune_runtime_alias_test_list (loop_vec_info);\n extern tree vect_check_gather_scatter (gimple *, loop_vec_info, tree *, tree *,\n \t\t\t\t       int *);\n-extern bool vect_analyze_data_refs (loop_vec_info, bb_vec_info, int *,\n-\t\t\t\t    unsigned *);\n+extern bool vect_analyze_data_refs (vec_info *, int *, unsigned *);\n extern tree vect_create_data_ref_ptr (gimple *, tree, struct loop *, tree,\n \t\t\t\t      tree *, gimple_stmt_iterator *,\n \t\t\t\t      gimple **, bool, bool *,\n@@ -1121,8 +1132,8 @@ extern bool vect_transform_slp_perm_load (slp_tree, vec<tree> ,\n                                           slp_instance, bool);\n extern bool vect_slp_analyze_operations (vec<slp_instance> slp_instances,\n \t\t\t\t\t void *);\n-extern bool vect_schedule_slp (loop_vec_info, bb_vec_info);\n-extern bool vect_analyze_slp (loop_vec_info, bb_vec_info, unsigned);\n+extern bool vect_schedule_slp (vec_info *);\n+extern bool vect_analyze_slp (vec_info *, unsigned);\n extern bool vect_make_slp_decision (loop_vec_info);\n extern void vect_detect_hybrid_slp (loop_vec_info);\n extern void vect_get_slp_defs (vec<tree> , slp_tree,\n@@ -1138,10 +1149,10 @@ extern void vect_slp_transform_bb (basic_block);\n    in the future.  */\n typedef gimple *(* vect_recog_func_ptr) (vec<gimple *> *, tree *, tree *);\n #define NUM_PATTERNS 13\n-void vect_pattern_recog (loop_vec_info, bb_vec_info);\n+void vect_pattern_recog (vec_info *);\n \n /* In tree-vectorizer.c.  */\n unsigned vectorize_loops (void);\n-void vect_destroy_datarefs (loop_vec_info, bb_vec_info);\n+void vect_destroy_datarefs (vec_info *);\n \n #endif  /* GCC_TREE_VECTORIZER_H  */"}]}