{"sha": "d0a30acf3e50b0757a7e82cebf24e379906ce92d", "node_id": "C_kwDOANBUbNoAKGQwYTMwYWNmM2U1MGIwNzU3YTdlODJjZWJmMjRlMzc5OTA2Y2U5MmQ", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2023-02-12T15:43:57Z"}, "committer": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2023-02-12T15:43:57Z"}, "message": "Merge commit '9e56306f4d7c15e7667d8ac0b62ae6efb93ba756' into HEAD", "tree": {"sha": "0bac30424e2520c1d6e11fe0c4e38af06421c38e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0bac30424e2520c1d6e11fe0c4e38af06421c38e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0a30acf3e50b0757a7e82cebf24e379906ce92d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0a30acf3e50b0757a7e82cebf24e379906ce92d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0a30acf3e50b0757a7e82cebf24e379906ce92d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0a30acf3e50b0757a7e82cebf24e379906ce92d/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ebecfbd3519a1ee93083b46daaa57e4d666e46de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebecfbd3519a1ee93083b46daaa57e4d666e46de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebecfbd3519a1ee93083b46daaa57e4d666e46de"}, {"sha": "9e56306f4d7c15e7667d8ac0b62ae6efb93ba756", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e56306f4d7c15e7667d8ac0b62ae6efb93ba756", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e56306f4d7c15e7667d8ac0b62ae6efb93ba756"}], "stats": {"total": 181542, "additions": 176079, "deletions": 5463}, "files": [{"sha": "772dfbe5bb629581738d48eb4f1c20779f062699", "filename": "contrib/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1,3 +1,33 @@\n+2023-01-19  Gaius Mulley  <gaiusmod2@gmail.com>\n+\n+\t* gcc_update (files_and_dependencies): Add dependencies for\n+\tgcc/m2/gm2config.h.in, gcc/m2/configure,\n+\tgcc/m2/gm2-libs/config-host, libgm2/Makefile.in,\n+\tlibgm2/aclocal.m4, libgm2/libm2cor/Makefile.in,\n+\tlibgm2/libm2pim/Makefile.in, libgm2/libm2iso/Makefile.in,\n+\tlibgm2/libm2log/Makefile.in and libgm2/libm2min/Makefile.in.\n+\n+2023-01-17  Martin Liska  <mliska@suse.cz>\n+\n+\t* update-copyright.py: Ignore test_patches.txt.\n+\n+2023-01-17  Martin Liska  <mliska@suse.cz>\n+\n+\t* gcc-changelog/test_patches.txt: The CR character was removed\n+\twith ./contrib/update-copyright.py which I'm going to change.\n+\n+2023-01-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR other/108413\n+\t* update-copyright.py (LibPhobosFilter): Add __builtins.di to\n+\tskipped files.\n+\n+2023-01-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR other/108413\n+\t* update-copyright.py (TestsuiteFilter): Add .mod and .rs extensions.\n+\t(GCCCopyright): Add 'The fast_float authors' as external author.\n+\n 2023-01-15  Gerald Pfeifer  <gerald@pfeifer.com>\n \n \t* config-list.mk: Update FreeBSD targets to version 13."}, {"sha": "1d120f8e4723fc40941c34a709f8541f033e0449", "filename": "contrib/gcc-changelog/test_patches.txt", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/contrib%2Fgcc-changelog%2Ftest_patches.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/contrib%2Fgcc-changelog%2Ftest_patches.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc-changelog%2Ftest_patches.txt?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -3631,8 +3631,7 @@ index 0000000..d75da75\n +pub fn main ()\n +{\n +// { dg-error \"Isolated CR\" \"\" { target *-*-* } .+1 }\n-+  //! doc cr\n- comment\n++  //! doc cr\r comment\n +}\n -- \n 2.38.1"}, {"sha": "1bfc67ac91adcbf4d2fcc9ca922330aac19f7533", "filename": "contrib/gcc_update", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/contrib%2Fgcc_update", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/contrib%2Fgcc_update", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc_update?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -4,7 +4,7 @@\n # repository, with an emphasis on treating generated files correctly, so\n # that autoconf, gperf et al are not required for the ``end'' user.\n #\n-# (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009, \n+# (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009,\n # 2010, 2011, 2012, 2013, 2014, 2015, 2017 Free Software Foundation\n # Originally by Gerald Pfeifer <gerald@pfeifer.com>, August 1998.\n #\n@@ -96,6 +96,9 @@ gcc/config/rs6000/fusion.md: gcc/config/rs6000/genfusion.pl\n gcc/cp/cfns.h: gcc/cp/cfns.gperf\n gcc/cp/std-name-hint.h: gcc/cp/std-name-hint.gperf\n gcc/cp/std-name-hint.gperf: gcc/cp/cxxapi-data.csv\n+gcc/m2/configure: gcc/m2/configure.ac\n+gcc/m2/gm2config.h.in: gcc/m2/configure.ac\n+gcc/m2/gm2-libs/config-host: gcc/m2/gm2-libs/config-host.in\n # testsuite\n # Without this, _Pragma3.c can have a false negative.\n gcc/testsuite/gcc.dg/cpp/_Pragma3.c: gcc/testsuite/gcc.dg/cpp/mi1c.h\n@@ -128,6 +131,13 @@ libffi/configure: libffi/configure.ac libffi/aclocal.m4\n libffi/fficonfig.h.in: libffi/configure.ac libffi/aclocal.m4\n libgfortran/aclocal.m4: libgfortran/configure.ac libgfortran/acinclude.m4\n libgfortran/Makefile.in: libgfortran/Makefile.am libgfortran/configure.ac libgfortran/aclocal.m4\n+libgm2/Makefile.in: libgm2/Makefile.am libgm2/configure.ac libgm2/aclocal.m4\n+libgm2/aclocal.m4: libgm2/configure.ac\n+libgm2/libm2cor/Makefile.in: libgm2/libm2cor/Makefile.am\n+libgm2/libm2pim/Makefile.in: libgm2/libm2pim/Makefile.am\n+libgm2/libm2iso/Makefile.in: libgm2/libm2iso/Makefile.am\n+libgm2/libm2log/Makefile.in: libgm2/libm2log/Makefile.am\n+libgm2/libm2min/Makefile.in: libgm2/libm2min/Makefile.am\n libquadmath/configure: libquadmath/configure.ac libquadmath/aclocal.m4\n libquadmath/aclocal.m4: libquadmath/configure.ac libquadmath/acinclude.m4\n libquadmath/Makefile.in: libquadmath/Makefile.am libquadmath/configure.ac libgfortran/aclocal.m4\n@@ -345,7 +355,7 @@ case $vcs_type in\n \t\tfi\n \tfi\n \tbranch=`$GCC_GIT name-rev --name-only HEAD || :`\n-\t;;    \n+\t;;\n \n     hg)\n \tchat \"Updating HG tree\""}, {"sha": "f3691dc11cc9452574fb2a110fcc2e458821bfea", "filename": "contrib/update-copyright.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/contrib%2Fupdate-copyright.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/contrib%2Fupdate-copyright.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fupdate-copyright.py?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -693,6 +693,7 @@ def __init__ (self):\n                 'Info.plist',\n                 # Contains CR (^M).\n                 'repro_fail',\n+                'test_patches.txt',\n                 ])\n \n class GCCCopyright (Copyright):"}, {"sha": "f7d559264b0a171db427940618ee8c31d85437a9", "filename": "fixincludes/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/fixincludes%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/fixincludes%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fixincludes%2FChangeLog?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1,3 +1,17 @@\n+2023-01-21  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\t* fixincl.x: Regenerate.\n+\t* inclhack.def (darwin_objc_runtime_1): New hack.\n+\t* tests/base/objc/runtime.h: New file.\n+\n+2023-01-21  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\tPR target/107568\n+\t* fixincl.x: Regenerate.\n+\t* inclhack.def: Add a fix for MacOS13 SDK function deprecations\n+\tin stdio.h.\n+\t* tests/base/stdio.h (__deprecated_msg): New test.\n+\n 2022-11-23  Marek Polacek  <polacek@redhat.com>\n \n \tRevert:"}, {"sha": "acb906eea296b3cd847d05f625e409598ff9b998", "filename": "fixincludes/fixincl.x", "status": "modified", "additions": 104, "deletions": 5, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/fixincludes%2Ffixincl.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/fixincludes%2Ffixincl.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fixincludes%2Ffixincl.x?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -2,11 +2,11 @@\n  *\n  * DO NOT EDIT THIS FILE   (fixincl.x)\n  *\n- * It has been AutoGen-ed  September 29, 2022 at 10:22:55 PM by AutoGen 5.18.16\n+ * It has been AutoGen-ed  January 18, 2023 at 09:06:47 PM by AutoGen 5.18.7\n  * From the definitions    inclhack.def\n  * and the template file   fixincl\n  */\n-/* DO NOT SVN-MERGE THIS FILE, EITHER Thu Sep 29 22:22:55 CEST 2022\n+/* DO NOT SVN-MERGE THIS FILE, EITHER Wed Jan 18 21:06:47 GMT 2023\n  *\n  * You must regenerate it.  Use the ./genfixes script.\n  *\n@@ -15,7 +15,7 @@\n  * certain ANSI-incompatible system header files which are fixed to work\n  * correctly with ANSI C and placed in a directory that GNU C will search.\n  *\n- * This file contains 272 fixup descriptions.\n+ * This file contains 274 fixup descriptions.\n  *\n  * See README for more information.\n  *\n@@ -2608,6 +2608,46 @@ static const char* apzBsd_Stdio_Attrs_ConflictPatch[] = {\n int vfscanf(FILE *, const char *, __builtin_va_list) __asm__ (_BSD_STRING(__USER_LABEL_PREFIX__) \\\"__svfscanf\\\");\",\n     (char*)NULL };\n \n+/* * * * * * * * * * * * * * * * * * * * * * * * * *\n+ *\n+ *  Description of Apple_Local_Stdio_Fn_Deprecation fix\n+ */\n+tSCC zApple_Local_Stdio_Fn_DeprecationName[] =\n+     \"apple_local_stdio_fn_deprecation\";\n+\n+/*\n+ *  File name selection pattern\n+ */\n+tSCC zApple_Local_Stdio_Fn_DeprecationList[] =\n+  \"stdio.h\\0\";\n+/*\n+ *  Machine/OS name selection pattern\n+ */\n+tSCC* apzApple_Local_Stdio_Fn_DeprecationMachs[] = {\n+        \"*-*-*darwin2*\",\n+        (const char*)NULL };\n+\n+/*\n+ *  content selection pattern - do fix if pattern found\n+ */\n+tSCC zApple_Local_Stdio_Fn_DeprecationSelect0[] =\n+       \"__deprecated_msg([^\\n\\\n+]*)$\";\n+\n+#define    APPLE_LOCAL_STDIO_FN_DEPRECATION_TEST_CT  1\n+static tTestDesc aApple_Local_Stdio_Fn_DeprecationTests[] = {\n+  { TT_EGREP,    zApple_Local_Stdio_Fn_DeprecationSelect0, (regex_t*)NULL }, };\n+\n+/*\n+ *  Fix Command Arguments for Apple_Local_Stdio_Fn_Deprecation\n+ */\n+static const char* apzApple_Local_Stdio_Fn_DeprecationPatch[] = {\n+    \"format\",\n+    \"#if defined(__APPLE_LOCAL_DEPRECATIONS)\\n\\\n+%0\\n\\\n+#endif\",\n+    (char*)NULL };\n+\n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n  *\n  *  Description of Ctrl_Quotes_Def fix\n@@ -3044,6 +3084,53 @@ static const char* apzDarwin_Os_Trace_2Patch[] = {\n #endif\",\n     (char*)NULL };\n \n+/* * * * * * * * * * * * * * * * * * * * * * * * * *\n+ *\n+ *  Description of Darwin_Objc_Runtime_1 fix\n+ */\n+tSCC zDarwin_Objc_Runtime_1Name[] =\n+     \"darwin_objc_runtime_1\";\n+\n+/*\n+ *  File name selection pattern\n+ */\n+tSCC zDarwin_Objc_Runtime_1List[] =\n+  \"objc/runtime.h\\0\";\n+/*\n+ *  Machine/OS name selection pattern\n+ */\n+tSCC* apzDarwin_Objc_Runtime_1Machs[] = {\n+        \"*-*-darwin2*\",\n+        (const char*)NULL };\n+\n+/*\n+ *  content selection pattern - do fix if pattern found\n+ */\n+tSCC zDarwin_Objc_Runtime_1Select0[] =\n+       \"OBJC_EXPORT void.*\\n\\\n+objc_enumerateClasses.*\\n\\\n+.*\\n\\\n+.*\\n\\\n+.*\\n\\\n+.*void \\\\(\\\\^ _Nonnull block.*\\n\\\n+.*\\n\\\n+.*\\n\\\n+.*OBJC_REFINED_FOR_SWIFT.*\";\n+\n+#define    DARWIN_OBJC_RUNTIME_1_TEST_CT  1\n+static tTestDesc aDarwin_Objc_Runtime_1Tests[] = {\n+  { TT_EGREP,    zDarwin_Objc_Runtime_1Select0, (regex_t*)NULL }, };\n+\n+/*\n+ *  Fix Command Arguments for Darwin_Objc_Runtime_1\n+ */\n+static const char* apzDarwin_Objc_Runtime_1Patch[] = {\n+    \"format\",\n+    \"#if __BLOCKS__\\n\\\n+%0\\n\\\n+#endif\",\n+    (char*)NULL };\n+\n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n  *\n  *  Description of Darwin_Os_Trace_3 fix\n@@ -11075,9 +11162,9 @@ static const char* apzX11_SprintfPatch[] = {\n  *\n  *  List of all fixes\n  */\n-#define REGEX_COUNT          310\n+#define REGEX_COUNT          312\n #define MACH_LIST_SIZE_LIMIT 187\n-#define FIX_COUNT            272\n+#define FIX_COUNT            274\n \n /*\n  *  Enumerate the fixes\n@@ -11144,6 +11231,7 @@ typedef enum {\n     BROKEN_CABS_FIXIDX,\n     BROKEN_NAN_FIXIDX,\n     BSD_STDIO_ATTRS_CONFLICT_FIXIDX,\n+    APPLE_LOCAL_STDIO_FN_DEPRECATION_FIXIDX,\n     CTRL_QUOTES_DEF_FIXIDX,\n     CTRL_QUOTES_USE_FIXIDX,\n     CXX_UNREADY_FIXIDX,\n@@ -11155,6 +11243,7 @@ typedef enum {\n     DARWIN_LONGJMP_NORETURN_FIXIDX,\n     DARWIN_OS_TRACE_1_FIXIDX,\n     DARWIN_OS_TRACE_2_FIXIDX,\n+    DARWIN_OBJC_RUNTIME_1_FIXIDX,\n     DARWIN_OS_TRACE_3_FIXIDX,\n     DARWIN_OS_BASE_1_FIXIDX,\n     DARWIN_DISPATCH_OBJECT_1_FIXIDX,\n@@ -11663,6 +11752,11 @@ tFixDesc fixDescList[ FIX_COUNT ] = {\n      BSD_STDIO_ATTRS_CONFLICT_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,\n      aBsd_Stdio_Attrs_ConflictTests,   apzBsd_Stdio_Attrs_ConflictPatch, 0 },\n \n+  {  zApple_Local_Stdio_Fn_DeprecationName,    zApple_Local_Stdio_Fn_DeprecationList,\n+     apzApple_Local_Stdio_Fn_DeprecationMachs,\n+     APPLE_LOCAL_STDIO_FN_DEPRECATION_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,\n+     aApple_Local_Stdio_Fn_DeprecationTests,   apzApple_Local_Stdio_Fn_DeprecationPatch, 0 },\n+\n   {  zCtrl_Quotes_DefName,    zCtrl_Quotes_DefList,\n      apzCtrl_Quotes_DefMachs,\n      CTRL_QUOTES_DEF_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,\n@@ -11718,6 +11812,11 @@ tFixDesc fixDescList[ FIX_COUNT ] = {\n      DARWIN_OS_TRACE_2_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,\n      aDarwin_Os_Trace_2Tests,   apzDarwin_Os_Trace_2Patch, 0 },\n \n+  {  zDarwin_Objc_Runtime_1Name,    zDarwin_Objc_Runtime_1List,\n+     apzDarwin_Objc_Runtime_1Machs,\n+     DARWIN_OBJC_RUNTIME_1_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,\n+     aDarwin_Objc_Runtime_1Tests,   apzDarwin_Objc_Runtime_1Patch, 0 },\n+\n   {  zDarwin_Os_Trace_3Name,    zDarwin_Os_Trace_3List,\n      apzDarwin_Os_Trace_3Machs,\n      DARWIN_OS_TRACE_3_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,"}, {"sha": "b02dd8e057537a652569833de47c5993bf4699e7", "filename": "fixincludes/inclhack.def", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/fixincludes%2Finclhack.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/fixincludes%2Finclhack.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fixincludes%2Finclhack.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1269,6 +1269,18 @@ fix = {\n     test_text = '#define  vfscanf\t__svfscanf';\n };\n \n+fix = {\n+    hackname  = apple_local_stdio_fn_deprecation;\n+    mach      = \"*-*-*darwin2*\";\n+    files     = stdio.h;\n+    select    = \"__deprecated_msg([^\\n]*)$\";\n+    c_fix     = format;\n+    c_fix_arg = \"#if defined(__APPLE_LOCAL_DEPRECATIONS)\\n\"\n+                \"%0\\n\"\n+                \"#endif\";\n+    test_text = '__deprecated_msg(\"This function is provided for compat...\")';\n+};\n+\n /*\n  *  Fix various macros used to define ioctl numbers.\n  *  The traditional syntax was:\n@@ -1479,6 +1491,41 @@ fix = {\n   test_text = \"typedef void (^os_trace_payload_t)(xpc_object_t xdict);\";\n };\n \n+/*\n+ *  macOSX 13.0 SDK objc/runtime.h uses Apple Blocks extension without a guard.\n+ */\n+\n+fix = {\n+  hackname  = darwin_objc_runtime_1;\n+  mach      = \"*-*-darwin2*\";\n+  files     = objc/runtime.h;\n+  select    =   <<- _EOSelect_\n+\tOBJC_EXPORT void.*\n+\tobjc_enumerateClasses.*\n+\t.*\n+\t.*\n+\t.*\n+\t.*void \\(\\^ _Nonnull block.*\n+\t.*\n+\t.*\n+\t.*OBJC_REFINED_FOR_SWIFT.*\n+\t_EOSelect_;\n+  c_fix     = format;\n+  c_fix_arg = \"#if __BLOCKS__\\n%0\\n#endif\";\n+  test_text = <<- _OBJC_RUNTIME_1\n+OBJC_EXPORT void\n+objc_enumerateClasses(const void * _Nullable image,\n+                      const char * _Nullable namePrefix,\n+                      Protocol * _Nullable conformingTo,\n+                      Class _Nullable subclassing,\n+                      void (^ _Nonnull block)(Class _Nonnull aClass, BOOL * _Nonnull stop)\n+                      OBJC_NOESCAPE)\n+OBJC_AVAILABLE(13.0, 16.0, 16.0, 9.0, 7.0)\n+OBJC_REFINED_FOR_SWIFT;\n+_OBJC_RUNTIME_1;\n+};\n+\n+\n /*\n  *  In Mac OS X 10.1[012] <os/trace.h>, need to guard users of\n  *  os_trace_payload_t typedef, too."}, {"sha": "8b4855bb8ab0f527f3244953da375511c75e630a", "filename": "fixincludes/tests/base/objc/runtime.h", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/fixincludes%2Ftests%2Fbase%2Fobjc%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/fixincludes%2Ftests%2Fbase%2Fobjc%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fixincludes%2Ftests%2Fbase%2Fobjc%2Fruntime.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -0,0 +1,24 @@\n+/*  DO NOT EDIT THIS FILE.\n+\n+    It has been auto-edited by fixincludes from:\n+\n+\t\"fixinc/tests/inc/objc/runtime.h\"\n+\n+    This had to be done to correct non-standard usages in the\n+    original, manufacturer supplied header file.  */\n+\n+\n+\n+#if defined( DARWIN_OBJC_RUNTIME_1_CHECK )\n+#if __BLOCKS__\n+OBJC_EXPORT void\n+objc_enumerateClasses(const void * _Nullable image,\n+                      const char * _Nullable namePrefix,\n+                      Protocol * _Nullable conformingTo,\n+                      Class _Nullable subclassing,\n+                      void (^ _Nonnull block)(Class _Nonnull aClass, BOOL * _Nonnull stop)\n+                      OBJC_NOESCAPE)\n+OBJC_AVAILABLE(13.0, 16.0, 16.0, 9.0, 7.0)\n+OBJC_REFINED_FOR_SWIFT;\n+#endif\n+#endif  /* DARWIN_OBJC_RUNTIME_1_CHECK */"}, {"sha": "38381bacb2d5af025cceb485716d37ae027c0480", "filename": "fixincludes/tests/base/stdio.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/fixincludes%2Ftests%2Fbase%2Fstdio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/fixincludes%2Ftests%2Fbase%2Fstdio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fixincludes%2Ftests%2Fbase%2Fstdio.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -41,6 +41,13 @@ int vfscanf(FILE *, const char *, __builtin_va_list) __asm__ (_BSD_STRING(__USER\n #endif  /* BSD_STDIO_ATTRS_CONFLICT_CHECK */\n \n \n+#if defined( APPLE_LOCAL_STDIO_FN_DEPRECATION_CHECK )\n+#if defined(__APPLE_LOCAL_DEPRECATIONS)\n+__deprecated_msg(\"This function is provided for compat...\")\n+#endif\n+#endif  /* APPLE_LOCAL_STDIO_FN_DEPRECATION_CHECK */\n+\n+\n #if defined( HPUX10_STDIO_DECLARATIONS_CHECK )\n #  define _iob __iob\n "}, {"sha": "5cb7d8566fff607c34e26fa88ecf737156fbf0d9", "filename": "gcc/BASE-VER", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2FBASE-VER", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2FBASE-VER", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FBASE-VER?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1 +1 @@\n-13.0.0\n+13.0.1"}, {"sha": "3a8041bb3645845b4e1d4ad87aacb4ae5e3e90b4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 1156, "deletions": 0, "changes": 1156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1,3 +1,1159 @@\n+2023-01-31  Gerald Pfeifer  <gerald@pfeifer.com>\n+\n+\t* doc/include/fdl.texi: Change fsf.org to www.fsf.org.\n+\n+2023-01-30  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-protos.h (get_vector_mode): New function.\n+\t* config/riscv/riscv-v.cc (get_vector_mode): Ditto.\n+\t* config/riscv/riscv-vector-builtins-bases.cc (enum lst_type): New enum.\n+\t(class loadstore): Adjust for indexed loads/stores support.\n+\t(BASE): Ditto.\n+\t* config/riscv/riscv-vector-builtins-bases.h: New function declare.\n+\t* config/riscv/riscv-vector-builtins-functions.def (vluxei8): Ditto.\n+\t(vluxei16): Ditto.\n+\t(vluxei32): Ditto.\n+\t(vluxei64): Ditto.\n+\t(vloxei8): Ditto.\n+\t(vloxei16): Ditto.\n+\t(vloxei32): Ditto.\n+\t(vloxei64): Ditto.\n+\t(vsuxei8): Ditto.\n+\t(vsuxei16): Ditto.\n+\t(vsuxei32): Ditto.\n+\t(vsuxei64): Ditto.\n+\t(vsoxei8): Ditto.\n+\t(vsoxei16): Ditto.\n+\t(vsoxei32): Ditto.\n+\t(vsoxei64): Ditto.\n+\t* config/riscv/riscv-vector-builtins-shapes.cc\n+\t(struct indexed_loadstore_def): New class.\n+\t(SHAPE): Ditto.\n+\t* config/riscv/riscv-vector-builtins-shapes.h: Ditto.\n+\t* config/riscv/riscv-vector-builtins.cc (required_extensions_p): Adjust\n+\tfor indexed loads/stores support.\n+\t(check_required_extensions): Ditto.\n+\t(rvv_arg_type_info::get_base_vector_type): New function.\n+\t(rvv_arg_type_info::get_tree_type): Ditto.\n+\t(function_builder::add_unique_function): Adjust for indexed loads/stores\n+\tsupport.\n+\t(function_expander::use_exact_insn): New function.\n+\t* config/riscv/riscv-vector-builtins.h (enum rvv_base_type): Adjust for\n+\tindexed loads/stores support.\n+\t(struct rvv_arg_type_info): Ditto.\n+\t(function_expander::index_mode): New function.\n+\t(function_base::apply_tail_policy_p): Ditto.\n+\t(function_base::apply_mask_policy_p): Ditto.\n+\t* config/riscv/vector-iterators.md (unspec): New unspec.\n+\t* config/riscv/vector.md (unspec): Ditto.\n+\t(@pred_indexed_<order>load<VNX1_QHSD:mode><VNX1_QHSDI:mode>): New\n+\tpattern.\n+\t(@pred_indexed_<order>store<VNX1_QHSD:mode><VNX1_QHSDI:mode>): Ditto.\n+\t(@pred_indexed_<order>load<VNX2_QHSD:mode><VNX2_QHSDI:mode>): Ditto.\n+\t(@pred_indexed_<order>store<VNX2_QHSD:mode><VNX2_QHSDI:mode>): Ditto.\n+\t(@pred_indexed_<order>load<VNX4_QHSD:mode><VNX4_QHSDI:mode>): Ditto.\n+\t(@pred_indexed_<order>store<VNX4_QHSD:mode><VNX4_QHSDI:mode>): Ditto.\n+\t(@pred_indexed_<order>load<VNX8_QHSD:mode><VNX8_QHSDI:mode>): Ditto.\n+\t(@pred_indexed_<order>store<VNX8_QHSD:mode><VNX8_QHSDI:mode>): Ditto.\n+\t(@pred_indexed_<order>load<VNX16_QHS:mode><VNX16_QHSI:mode>): Ditto.\n+\t(@pred_indexed_<order>store<VNX16_QHS:mode><VNX16_QHSI:mode>): Ditto.\n+\t(@pred_indexed_<order>load<VNX32_QH:mode><VNX32_QHI:mode>): Ditto.\n+\t(@pred_indexed_<order>store<VNX32_QH:mode><VNX32_QHI:mode>): Ditto.\n+\t(@pred_indexed_<order>load<VNX64_Q:mode><VNX64_Q:mode>): Ditto.\n+\t(@pred_indexed_<order>store<VNX64_Q:mode><VNX64_Q:mode>): Ditto.\n+\n+2023-01-30  Flavio Cruz  <flaviocruz@gmail.com>\n+\n+\t* config.gcc: Recognize x86_64-*-gnu* targets and include\n+\ti386/gnu64.h.\n+\t* config/i386/gnu64.h: Define configuration for new target\n+\tincluding ld.so location.\n+\n+2023-01-30  Philipp Tomsich  <philipp.tomsich@vrull.eu>\n+\n+\t* config/aarch64/aarch64-cores.def (AARCH64_CORE): Update\n+\tampere1a to include SM4.\n+\n+2023-01-30  Andrew Pinski  <apinski@marvell.com>\n+\n+\tPR tree-optimization/108582\n+\t* tree-ssa-phiopt.cc (match_simplify_replacement): Add check\n+\tfor middlebb to have no phi nodes.\n+\n+2023-01-30  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/108574\n+\t* tree-ssa-sccvn.cc (visit_phi): Instead of swapping\n+\tsameval and def, ignore the equivalence if there's the\n+\tdanger of oscillating between two values.\n+\n+2023-01-30  Andreas Schwab  <schwab@suse.de>\n+\n+\t* common/config/riscv/riscv-common.cc\n+\t(riscv_option_optimization_table)\n+\t[TARGET_DEFAULT_ASYNC_UNWIND_TABLES]: Enable\n+\t-fasynchronous-unwind-tables and -funwind-tables.\n+\t* config.gcc (riscv*-*-linux*): Define\n+\tTARGET_DEFAULT_ASYNC_UNWIND_TABLES.\n+\n+2023-01-30  YunQiang Su  <yunqiang.su@cipunited.com>\n+\n+\t* Makefile.in (CROSS_SYSTEM_HEADER_DIR): set according the\n+\tvalue of includedir.\n+\n+2023-01-30  Richard Biener  <rguenther@suse.de>\n+\n+\tPR ipa/108511\n+\t* cgraph.cc (possibly_call_in_translation_unit_p): Relax\n+\tassert.\n+\n+2023-01-30  liuhongt  <hongtao.liu@intel.com>\n+\n+\t* config/i386/i386.opt: Change AVX512FP16 to AVX512-FP16.\n+\t* doc/invoke.texi: Ditto.\n+\n+2023-01-29  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-utils.cc: Include calls.h, cfgloop.h and cfganal.h\n+\t(stmt_may_terminate_function_p): If assuming return or EH\n+\tvolatile asm is safe.\n+\t(find_always_executed_bbs): Fix handling of terminating BBS and\n+\tinfinite loops; add debug output.\n+\t* tree-ssa-alias.cc (stmt_kills_ref_p): Fix debug output\n+\n+2023-01-28  Philipp Tomsich  <philipp.tomsich@vrull.eu>\n+\n+\t* config/aarch64/aarch64.cc (aarch64_uxt_size): fix an\n+\toff-by-one in checking the permissible shift-amount.\n+\n+2023-01-28  Gerald Pfeifer  <gerald@pfeifer.com>\n+\n+\t* doc/extend.texi (Named Address Spaces): Update link to the\n+\tAVR-Libc manual.\n+\n+2023-01-28  Gerald Pfeifer  <gerald@pfeifer.com>\n+\n+\t* doc/standards.texi (Standards): Fix markup.\n+\n+2023-01-28  Gerald Pfeifer  <gerald@pfeifer.com>\n+\n+\t* doc/standards.texi (Standards): Update link to Objective-C book.\n+\n+2023-01-28  Gerald Pfeifer  <gerald@pfeifer.com>\n+\n+\t* doc/invoke.texi (Instrumentation Options): Update reference to\n+\tAddressSanitizer.\n+\n+2023-01-28  Gerald Pfeifer  <gerald@pfeifer.com>\n+\n+\t* doc/standards.texi: Update Go1 link.\n+\n+2023-01-28  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/predicates.md (pmode_reg_or_0_operand): New predicate.\n+\t* config/riscv/riscv-vector-builtins-bases.cc (class loadstore):\n+\tSupport vlse/vsse.\n+\t(BASE): Ditto.\n+\t* config/riscv/riscv-vector-builtins-bases.h: Ditto.\n+\t* config/riscv/riscv-vector-builtins-functions.def (vlse): New class.\n+\t(vsse): New class.\n+\t* config/riscv/riscv-vector-builtins.cc\n+\t(function_expander::use_contiguous_load_insn): Support vlse/vsse.\n+\t* config/riscv/vector.md (@pred_strided_load<mode>): New md pattern.\n+\t(@pred_strided_store<mode>): Ditto.\n+\n+2023-01-28  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/vector.md (tail_policy_op_idx): Remove.\n+\t(mask_policy_op_idx): Remove.\n+\t(avl_type_op_idx): Remove.\n+\n+2023-01-27  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR tree-optimization/96373\n+\t* tree.h (sign_mask_for): Declare.\n+\t* tree.cc (sign_mask_for): New function.\n+\t(signed_or_unsigned_type_for): For vector types, try to use the\n+\trelated_int_vector_mode.\n+\t* genmatch.cc (commutative_op): Handle conditional internal functions.\n+\t* match.pd: Fold an IFN_COND_MUL+copysign into an IFN_COND_XOR+and.\n+\n+2023-01-27  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vectorizer.cc (vector_costs::compare_inside_loop_cost):\n+\tUse the likely minimum VF when bounding the denominators to\n+\tthe estimated number of iterations.\n+\n+2023-01-27  Richard Biener  <rguenther@suse.de>\n+\n+\tPR target/55522\n+\t* doc/invoke.texi (-shared): Clarify effect on -ffast-math\n+\tand -Ofast FP environment side-effects.\n+\n+2023-01-27  Richard Biener  <rguenther@suse.de>\n+\n+\tPR target/55522\n+\t* config/mips/gnu-user.h (GNU_USER_TARGET_MATHFILE_SPEC):\n+\tDon't add crtfastmath.o for -shared.\n+\n+2023-01-27  Richard Biener  <rguenther@suse.de>\n+\n+\tPR target/55522\n+\t* config/ia64/linux.h (ENDFILE_SPEC): Don't add crtfastmath.o\n+\tfor -shared.\n+\n+2023-01-27  Richard Biener  <rguenther@suse.de>\n+\n+\tPR target/55522\n+\t* config/alpha/linux.h (ENDFILE_SPEC): Don't add\n+\tcrtfastmath.o for -shared.\n+\n+2023-01-27  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\tPR tree-optimization/108306\n+\t* range-op.cc (operator_lshift::fold_range): Return [0, 0] not\n+\tvarying for shifts that are always out of void range.\n+\t(operator_rshift::fold_range): Return [0, 0] not\n+\tvarying for shifts that are always out of void range.\n+\n+2023-01-27  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\tPR tree-optimization/108447\n+\t* gimple-range-fold.cc (old_using_range::relation_fold_and_or):\n+\tDo not attempt to fold HONOR_NAN types.\n+\n+2023-01-27  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-vector-builtins-shapes.cc (struct loadstore_def):\n+\tRemove _m suffix for \"vop_m\" C++ overloaded API name.\n+\n+2023-01-27  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-vector-builtins-bases.cc (BASE): Add vlm/vsm support.\n+\t* config/riscv/riscv-vector-builtins-bases.h: Ditto.\n+\t* config/riscv/riscv-vector-builtins-functions.def (vlm): New define.\n+\t(vsm): Ditto.\n+\t* config/riscv/riscv-vector-builtins-shapes.cc (struct loadstore_def): Add vlm/vsm support.\n+\t* config/riscv/riscv-vector-builtins-types.def (DEF_RVV_B_OPS): Ditto.\n+\t(vbool64_t): Ditto.\n+\t(vbool32_t): Ditto.\n+\t(vbool16_t): Ditto.\n+\t(vbool8_t): Ditto.\n+\t(vbool4_t): Ditto.\n+\t(vbool2_t): Ditto.\n+\t(vbool1_t): Ditto.\n+\t* config/riscv/riscv-vector-builtins.cc (DEF_RVV_B_OPS): Ditto.\n+\t(rvv_arg_type_info::get_tree_type): Ditto.\n+\t(function_expander::use_contiguous_load_insn): Ditto.\n+\t* config/riscv/vector.md (@pred_store<mode>): Ditto.\n+\n+2023-01-27  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-vsetvl.cc (vsetvl_insn_p): Add condition to avoid ICE.\n+\t(vsetvl_discard_result_insn_p): New function.\n+\t(reg_killed_by_bb_p): rename to find_reg_killed_by.\n+\t(find_reg_killed_by): New name.\n+\t(get_vl): allow it to be called by more functions.\n+\t(has_vsetvl_killed_avl_p): Add condition.\n+\t(get_avl): allow it to be called by more functions.\n+\t(insn_should_be_added_p): New function.\n+\t(get_all_nonphi_defs): Refine function.\n+\t(get_all_sets): Ditto.\n+\t(get_same_bb_set): New function.\n+\t(any_insn_in_bb_p): Ditto.\n+\t(any_set_in_bb_p): Ditto.\n+\t(get_vl_vtype_info): Add VLMAX forward optimization.\n+\t(source_equal_p): Fix issues.\n+\t(extract_single_source): Refine.\n+\t(avl_info::multiple_source_equal_p): New function.\n+\t(avl_info::operator==): Adjust for final version.\n+\t(vl_vtype_info::operator==): Ditto.\n+\t(vl_vtype_info::same_avl_p): Ditto.\n+\t(vector_insn_info::parse_insn): Ditto.\n+\t(vector_insn_info::available_p): New function.\n+\t(vector_insn_info::merge): Adjust for final version.\n+\t(vector_insn_info::dump): Add hard_empty.\n+\t(pass_vsetvl::hard_empty_block_p): New function.\n+\t(pass_vsetvl::backward_demand_fusion): Adjust for final version.\n+\t(pass_vsetvl::forward_demand_fusion): Ditto.\n+\t(pass_vsetvl::demand_fusion): Ditto.\n+\t(pass_vsetvl::cleanup_illegal_dirty_blocks): New function.\n+\t(pass_vsetvl::compute_local_properties): Adjust for final version.\n+\t(pass_vsetvl::can_refine_vsetvl_p): Ditto.\n+\t(pass_vsetvl::refine_vsetvls): Ditto.\n+\t(pass_vsetvl::commit_vsetvls): Ditto.\n+\t(pass_vsetvl::propagate_avl): New function.\n+\t(pass_vsetvl::lazy_vsetvl): Adjust for new version.\n+\t* config/riscv/riscv-vsetvl.h (enum def_type): New enum.\n+\n+2023-01-27  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR other/108560\n+\t* doc/extend.texi: Fix up return type of __builtin_va_arg_pack_len\n+\tfrom size_t to int.\n+\n+2023-01-27  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR ipa/106061\n+\t* cgraph.cc (cgraph_edge::verify_corresponds_to_fndecl): Allow\n+\tredirection of calls to __builtin_trap in addition to redirection\n+\tto __builtin_unreachable.\n+\n+2023-01-27  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-vsetvl.cc (before_p): Fix bug.\n+\n+2023-01-27  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-vsetvl.cc (gen_vsetvl_pat): Refine function args.\n+\t(emit_vsetvl_insn): Ditto.\n+\n+2023-01-27  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/vector.md: Fix constraints.\n+\n+2023-01-27  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/vector-iterators.md: Add TARGET_MIN_VLEN > 32 predicates.\n+\n+2023-01-27  Patrick Palka  <ppalka@redhat.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* tree-core.h (tree_code_type, tree_code_length): For\n+\tC++17 and later, add inline keyword, otherwise don't define\n+\tthe arrays, but declare extern arrays.\n+\t* tree.cc (tree_code_type, tree_code_length): Define these\n+\tarrays for C++14 and older.\n+\n+2023-01-27  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-vsetvl.h: Change it into public.\n+\n+2023-01-27  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-passes.def (INSERT_PASS_BEFORE): Reorder VSETVL\n+\tpass.\n+\n+2023-01-27  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-vsetvl.cc (pass_vsetvl::execute): Always call split_all_insns.\n+\n+2023-01-27  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/vector.md: Fix incorrect attributes.\n+\n+2023-01-27  Richard Biener  <rguenther@suse.de>\n+\n+\tPR target/55522\n+\t* config/loongarch/gnu-user.h (GNU_USER_TARGET_MATHFILE_SPEC):\n+\tDon't add crtfastmath.o for -shared.\n+\n+2023-01-27  Alexandre Oliva  <oliva@gnu.org>\n+\n+\t* doc/options.texi (option, RejectNegative): Mention that\n+\t-g-started options are also implicitly negatable.\n+\n+2023-01-26  Kito Cheng  <kito.cheng@sifive.com>\n+\n+\t* config/riscv/riscv-vector-builtins.cc (register_builtin_types):\n+\tUse get_typenode_from_name to get fixed-width integer type\n+\tnodes.\n+\t* config/riscv/riscv-vector-builtins.def: Update define with\n+\tfixed-width integer type nodes.\n+\n+2023-01-26  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-vsetvl.cc (same_bb_and_before_p): Remove it.\n+\t(real_insn_and_same_bb_p): New function.\n+\t(same_bb_and_after_or_equal_p): Remove it.\n+\t(before_p): New function.\n+\t(reg_killed_by_bb_p): Ditto.\n+\t(has_vsetvl_killed_avl_p): Ditto.\n+\t(get_vl): Move location so that we can call it.\n+\t(anticipatable_occurrence_p): Fix issue of AVL=REG support.\n+\t(available_occurrence_p): Ditto.\n+\t(dominate_probability_p): Remove it.\n+\t(can_backward_propagate_p): Remove it.\n+\t(get_all_nonphi_defs): New function.\n+\t(get_all_predecessors): Ditto.\n+\t(any_insn_in_bb_p): Ditto.\n+\t(insert_vsetvl): Adjust AVL REG.\n+\t(source_equal_p): New function.\n+\t(extract_single_source): Ditto.\n+\t(avl_info::single_source_equal_p): Ditto.\n+\t(avl_info::operator==): Adjust for AVL=REG.\n+\t(vl_vtype_info::same_avl_p): Ditto.\n+\t(vector_insn_info::set_demand_info): Remove it.\n+\t(vector_insn_info::compatible_p): Adjust for AVL=REG.\n+\t(vector_insn_info::compatible_avl_p): New function.\n+\t(vector_insn_info::merge): Adjust AVL=REG.\n+\t(vector_insn_info::dump): Ditto.\n+\t(pass_vsetvl::merge_successors): Remove it.\n+\t(enum fusion_type): New enum.\n+\t(pass_vsetvl::get_backward_fusion_type): New function.\n+\t(pass_vsetvl::backward_demand_fusion): Adjust for AVL=REG.\n+\t(pass_vsetvl::forward_demand_fusion): Ditto.\n+\t(pass_vsetvl::demand_fusion): Ditto.\n+\t(pass_vsetvl::prune_expressions): Ditto.\n+\t(pass_vsetvl::compute_local_properties): Ditto.\n+\t(pass_vsetvl::cleanup_vsetvls): Ditto.\n+\t(pass_vsetvl::commit_vsetvls): Ditto.\n+\t(pass_vsetvl::init): Ditto.\n+\t* config/riscv/riscv-vsetvl.h (enum fusion_type): New enum.\n+\t(enum merge_type): New enum.\n+\n+2023-01-26  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-vsetvl.cc\n+\t(vector_infos_manager::vector_infos_manager): Add probability.\n+\t(vector_infos_manager::dump): Ditto.\n+\t(pass_vsetvl::compute_probabilities): Ditto.\n+\t* config/riscv/riscv-vsetvl.h (struct vector_block_info): Ditto.\n+\n+2023-01-26  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-vsetvl.cc (vector_insn_info::operator==): Remove dirty_pat.\n+\t(vector_insn_info::merge): Ditto.\n+\t(vector_insn_info::dump): Ditto.\n+\t(pass_vsetvl::merge_successors): Ditto.\n+\t(pass_vsetvl::backward_demand_fusion): Ditto.\n+\t(pass_vsetvl::forward_demand_fusion): Ditto.\n+\t(pass_vsetvl::commit_vsetvls): Ditto.\n+\t* config/riscv/riscv-vsetvl.h: Ditto.\n+\n+2023-01-26  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-vsetvl.cc (add_label_notes): Rename insn to\n+\trinsn.\n+\n+2023-01-26  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-vsetvl.cc (pass_vsetvl::backward_demand_fusion): Refine codes.\n+\n+2023-01-26  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-vsetvl.cc (pass_vsetvl::forward_demand_fusion):\n+\tAdd pre-check for redundant flow.\n+\n+2023-01-26  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-vsetvl.cc (vector_infos_manager::create_bitmap_vectors): New function.\n+\t(vector_infos_manager::free_bitmap_vectors): Ditto.\n+\t(pass_vsetvl::pre_vsetvl): Adjust codes.\n+\t* config/riscv/riscv-vsetvl.h: New function declaration.\n+\n+2023-01-26  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-vsetvl.cc (can_backward_propagate_p): Fix for null iter_bb.\n+\t(vector_insn_info::set_demand_info): New function.\n+\t(pass_vsetvl::emit_local_forward_vsetvls): Adjust for refinement of Phase 3.\n+\t(pass_vsetvl::merge_successors): Ditto.\n+\t(pass_vsetvl::compute_global_backward_infos): Ditto.\n+\t(pass_vsetvl::backward_demand_fusion): Ditto.\n+\t(pass_vsetvl::forward_demand_fusion): Ditto.\n+\t(pass_vsetvl::demand_fusion): New function.\n+\t(pass_vsetvl::lazy_vsetvl): Adjust for refinement of phase 3.\n+\t* config/riscv/riscv-vsetvl.h: New function declaration.\n+\n+2023-01-26  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-vsetvl.cc (vector_insn_info::operator>=): Fix available condition.\n+\n+2023-01-26  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-vsetvl.cc (change_vsetvl_insn): New function.\n+\t(pass_vsetvl::compute_global_backward_infos): Simplify codes.\n+\n+2023-01-26  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-vsetvl.cc (loop_basic_block_p): Adjust function.\n+\t(backward_propagate_worthwhile_p): Fix non-worthwhile.\n+\n+2023-01-26  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-vsetvl.cc (change_insn): Adjust in_group in validate_change.\n+\n+2023-01-26  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-vsetvl.cc (vector_infos_manager::all_same_avl_p): New function.\n+\t(pass_vsetvl::can_refine_vsetvl_p): Add AVL check.\n+\t(pass_vsetvl::commit_vsetvls): Ditto.\n+\t* config/riscv/riscv-vsetvl.h: New function declaration.\n+\n+2023-01-26  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/vector.md:\n+\n+2023-01-26  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-vector-builtins-bases.cc (class loadstore): use\n+\tpred_store for vse.\n+\t* config/riscv/riscv-vector-builtins.cc\n+\t(function_expander::add_mem_operand): Refine function.\n+\t(function_expander::use_contiguous_load_insn): Adjust new\n+\timplementation.\n+\t(function_expander::use_contiguous_store_insn): Ditto.\n+\t* config/riscv/riscv-vector-builtins.h: Refine function.\n+\t* config/riscv/vector.md (@pred_store<mode>): New pattern.\n+\n+2023-01-26  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-vector-builtins.cc: Change to scalar pointer.\n+\n+2023-01-26  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR middle-end/108543\n+\t* opts.cc (parse_sanitizer_options): Don't always clear SANITIZE_ADDRESS\n+\tif it was previously set.\n+\n+2023-01-26  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/108540\n+\t* range-op-float.cc (foperator_equal::fold_range): If both op1 and op2\n+\tare singletons, use range_true even if op1 != op2\n+\twhen one range is [-0.0, -0.0] and another [0.0, 0.0].  Similarly,\n+\teven if intersection of the ranges is empty and one has\n+\tzero low bound and another zero high bound, use range_true_and_false\n+\trather than range_false.\n+\t(foperator_not_equal::fold_range): If both op1 and op2\n+\tare singletons, use range_false even if op1 != op2\n+\twhen one range is [-0.0, -0.0] and another [0.0, 0.0].  Similarly,\n+\teven if intersection of the ranges is empty and one has\n+\tzero low bound and another zero high bound, use range_true_and_false\n+\trather than range_true.\n+\n+2023-01-26  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* value-relation.cc (kind_string): Add const.\n+\t(rr_negate_table, rr_swap_table, rr_intersect_table,\n+\trr_union_table, rr_transitive_table): Add static const, change\n+\telement type from relation_kind to unsigned char.\n+\t(relation_negate, relation_swap, relation_intersect, relation_union,\n+\trelation_transitive): Cast rr_*_table element to relation_kind.\n+\t(relation_to_code): Add static const.\n+\t(relation_tests): Assert VREL_LAST is smaller than UCHAR_MAX.\n+\n+2023-01-26  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/108547\n+\t* gimple-predicate-analysis.cc (value_sat_pred_p):\n+\tUse widest_int.\n+\n+2023-01-26  Siddhesh Poyarekar  <siddhesh@gotplt.org>\n+\n+\tPR tree-optimization/108522\n+\t* tree-object-size.cc (compute_object_offset): Make EXPR\n+\targument non-const.  Call component_ref_field_offset.\n+\n+2023-01-26  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* config/aarch64/aarch64-option-extensions.def (cssc): Specify\n+\tFEATURE_STRING field.\n+\n+2023-01-26  Gerald Pfeifer  <gerald@pfeifer.com>\n+\n+\t* doc/sourcebuild.texi: Refer to projects as GCC and GDB.\n+\n+2023-01-25  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\tPR modula2/102343\n+\tPR modula2/108182\n+\t* gcc.cc: Provide default specs for Modula-2 so that when the\n+\tlanguage is not built-in better diagnostics are emitted for\n+\tattempts to use .mod or .m2i file extensions.\n+\n+2023-01-25  Andrea Corallo  <andrea.corallo@arm.com>\n+\n+\t* config/arm/mve.md (mve_vqnegq_s<mode>): Fix spacing.\n+\n+2023-01-25  Andrea Corallo  <andrea.corallo@arm.com>\n+\n+\t* config/arm/mve.md (mve_vqabsq_s<mode>): Fix spacing.\n+\n+2023-01-25  Andrea Corallo  <andrea.corallo@arm.com>\n+\n+\t* config/arm/mve.md (mve_vnegq_f<mode>, mve_vnegq_s<mode>):\n+\tFix spacing.\n+\n+2023-01-25  Andrea Corallo  <andrea.corallo@arm.com>\n+\n+\t* config/arm/mve.md (@mve_vclzq_s<mode>): Fix spacing.\n+\n+2023-01-25  Andrea Corallo  <andrea.corallo@arm.com>\n+\n+\t* config/arm/mve.md (mve_vclsq_s<mode>): Fix spacing.\n+\n+2023-01-25  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/108523\n+\t* tree-ssa-sccvn.cc (visit_phi): Avoid using the exclusive\n+\tbackedge value for the result when using predication to\n+\tprove equivalence.\n+\n+2023-01-25  Richard Biener  <rguenther@suse.de>\n+\n+\t* doc/lto.texi (Command line options): Reword and update reference\n+\tto removed lto_read_all_file_options.\n+\n+2023-01-25  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* config/aarch64/aarch64.md (umax<mode>3): Separate the CNT and CSSC\n+\ttests.\n+\n+2023-01-25  Gerald Pfeifer  <gerald@pfeifer.com>\n+\n+\t* doc/contrib.texi: Add Jose E. Marchesi.\n+\n+2023-01-25  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/108498\n+\t* gimple-ssa-store-merging.cc (class store_operand_info):\n+\tEnd coment with full stop rather than comma.\n+\t(split_group): Likewise.\n+\t(merged_store_group::apply_stores): Clear string_concatenation if\n+\tstart or end aren't on a byte boundary.\n+\n+2023-01-25  Siddhesh Poyarekar  <siddhesh@gotplt.org>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/108522\n+\t* tree-object-size.cc (compute_object_offset): Use\n+\tTREE_OPERAND(ref, 2) for COMPONENT_REF when available.\n+\n+2023-01-24  Takayuki 'January June' Suwa  <jjsuwa_sys3175@yahoo.co.jp>\n+\n+\t* config/xtensa/xtensa.md:\n+\tFix exit from loops detecting references before overwriting in the\n+\tsplit pattern.\n+\n+2023-01-24  Vladimir N. Makarov  <vmakarov@redhat.com>\n+\n+\t* lra-constraints.cc (get_hard_regno): Remove final_p arg.  Always\n+\tdo elimination but only for hard register.\n+\t(operands_match_p, uses_hard_regs_p, process_alt_operands): Adjust\n+\tcalls of get_hard_regno.\n+\n+2023-01-24  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>\n+\n+\t* config/s390/s390-d.cc (s390_d_target_versions): Fix detection\n+\tof CPU version.\n+\n+2023-01-24  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n+\n+\tPR target/108177\n+\t* config/arm/mve.md (mve_vstrbq_p_<supf><mode>, mve_vstrhq_p_fv8hf,\n+\tmve_vstrhq_p_<supf><mode>, mve_vstrwq_p_<supf>v4si): Add memory operand\n+\tas input operand.\n+\n+2023-01-24  Xianmiao Qu  <cooper.qu@linux.alibaba.com>\n+\n+\t* config.gcc(csky-*-linux*): Define CSKY_ENABLE_MULTILIB\n+\tand only include 'csky/t-csky-linux' when enable multilib.\n+\t* config/csky/csky-linux-elf.h(SYSROOT_SUFFIX_SPEC): Don't\n+\tdefine it when disable multilib.\n+\n+2023-01-24  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/108500\n+\t* dominance.h (calculate_dominance_info): Add parameter\n+\tto indicate fast-query compute, defaulted to true.\n+\t* dominance.cc (calculate_dominance_info): Honor\n+\tfast-query compute parameter.\n+\t* tree-cfgcleanup.cc (cleanup_tree_cfg_noloop): Do\n+\tnot compute the dominator fast-query DFS numbers.\n+\n+2023-01-24  Eric Biggers  <ebiggers@google.com>\n+\n+\tPR bootstrap/90543\n+\t* optc-save-gen.awk: Fix copy-and-paste error.\n+\n+2023-01-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/108474\n+\t* cgraphbuild.cc: Include gimplify.h.\n+\t(record_reference): Replace VAR_DECLs with DECL_HAS_VALUE_EXPR_P with\n+\ttheir corresponding DECL_VALUE_EXPR expressions after unsharing.\n+\n+2023-01-24  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>\n+\n+\tPR target/108505\n+\t* config.gcc (tm_file): Move the variable out of loop.\n+\n+2023-01-24  Lulu Cheng  <chenglulu@loongson.cn>\n+\t    Yang Yujie  <yangyujie@loongson.cn>\n+\n+\tPR target/107731\n+\t* config/loongarch/loongarch.cc (loongarch_classify_address):\n+\tAdd precessint for CONST_INT.\n+\t(loongarch_print_operand_reloc): Operand modifier 'c' is supported.\n+\t(loongarch_print_operand): Increase the processing of '%c'.\n+\t* doc/extend.texi: Adds documents for LoongArch operand modifiers.\n+\tAnd port the public operand modifiers information to this document.\n+\n+2023-01-23  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>\n+\n+\t* doc/invoke.texi (-mbranch-protection): Update documentation.\n+\n+2023-01-23  Richard Biener  <rguenther@suse.de>\n+\n+\tPR target/55522\n+\t* config/sparc/freebsd.h (ENDFILE_SPEC): Don't add crtfastmath.o\n+\tfor -shared.\n+\t* config/sparc/linux.h (ENDFILE_SPEC): Likewise.\n+\t* config/sparc/linux64.h (ENDFILE_SPEC): Likewise.\n+\t* config/sparc/sp-elf.h (ENDFILE_SPEC): Likewise.\n+\t* config/sparc/sp64-elf.h (ENDFILE_SPEC): Likewise.\n+\n+2023-01-23  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>\n+\n+\t* config/arm/aout.h (ra_auth_code): Add entry in enum.\n+\t* config/arm/arm.cc (emit_multi_reg_push): Add RA_AUTH_CODE register\n+\tto dwarf frame expression.\n+\t(arm_emit_multi_reg_pop): Restore RA_AUTH_CODE register.\n+\t(arm_expand_prologue): Update frame related information and reg notes\n+\tfor pac/pacbit insn.\n+\t(arm_regno_class): Check for pac pseudo reigster.\n+\t(arm_dbx_register_number): Assign ra_auth_code register number in dwarf.\n+\t(arm_init_machine_status): Set pacspval_needed to zero.\n+\t(arm_debugger_regno): Check for PAC register.\n+\t(arm_unwind_emit_sequence): Print .save directive with ra_auth_code\n+\tregister.\n+\t(arm_unwind_emit_set): Add entry for IP_REGNUM in switch case.\n+\t(arm_unwind_emit): Update REG_CFA_REGISTER case._\n+\t* config/arm/arm.h (FIRST_PSEUDO_REGISTER): Modify.\n+\t(DWARF_PAC_REGNUM): Define.\n+\t(IS_PAC_REGNUM): Likewise.\n+\t(enum reg_class): Add PAC_REG entry.\n+\t(machine_function): Add pacbti_needed state to structure.\n+\t* config/arm/arm.md (RA_AUTH_CODE): Define.\n+\n+2023-01-23  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>\n+\n+\t* config.gcc ($tm_file): Update variable.\n+\t* config/arm/arm-mlib.h: Create new header file.\n+\t* config/arm/t-rmprofile (MULTI_ARCH_DIRS_RM): Rename mbranch-protection\n+\tmultilib arch directory.\n+\t(MULTILIB_REUSE): Add multilib reuse rules.\n+\t(MULTILIB_MATCHES): Add multilib match rules.\n+\n+2023-01-23  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>\n+\n+\t* config/arm/arm-cpus.in (cortex-m85): Define new CPU.\n+\t* config/arm/arm-tables.opt: Regenerate.\n+\t* config/arm/arm-tune.md: Likewise.\n+\t* doc/invoke.texi (Arm Options): Document -mcpu=cortex-m85.\n+\t* (-mfix-cmse-cve-2021-35465): Likewise.\n+\n+2023-01-23  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/108482\n+\t* tree-vect-generic.cc (expand_vector_operations): Fold remaining\n+\t.LOOP_DIST_ALIAS calls.\n+\n+2023-01-23  Andrea Corallo  <andrea.corallo@arm.com>\n+\n+\t* config.gcc (arm*-*-*): Add 'aarch-bti-insert.o' object.\n+\t* config/arm/arm-protos.h: Update.\n+\t* config/arm/aarch-common-protos.h: Declare\n+\t'aarch_bti_arch_check'.\n+\t* config/arm/arm.cc (aarch_bti_enabled) Update.\n+\t(aarch_bti_j_insn_p, aarch_pac_insn_p, aarch_gen_bti_c)\n+\t(aarch_gen_bti_j, aarch_bti_arch_check): New functions.\n+\t* config/arm/arm.md (bti_nop): New insn.\n+\t* config/arm/t-arm (PASSES_EXTRA): Add 'arm-passes.def'.\n+\t(aarch-bti-insert.o): New target.\n+\t* config/arm/unspecs.md (VUNSPEC_BTI_NOP): New unspec.\n+\t* config/arm/aarch-bti-insert.cc (rest_of_insert_bti): Verify arch\n+\tcompatibility.\n+\t(gate): Make use of 'aarch_bti_arch_check'.\n+\t* config/arm/arm-passes.def: New file.\n+\t* config/aarch64/aarch64.cc (aarch_bti_arch_check): New function.\n+\n+2023-01-23  Andrea Corallo  <andrea.corallo@arm.com>\n+\n+\t* config.gcc (aarch64*-*-*): Rename 'aarch64-bti-insert.o' into\n+\t'aarch-bti-insert.o'.\n+\t* config/aarch64/aarch64-protos.h: Remove 'aarch64_bti_enabled'\n+\tproto.\n+\t* config/aarch64/aarch64.cc (aarch_bti_enabled): Rename.\n+\t(aarch_bti_j_insn_p, aarch_pac_insn_p): New functions.\n+\t(aarch64_output_mi_thunk)\n+\t(aarch64_print_patchable_function_entry)\n+\t(aarch64_file_end_indicate_exec_stack): Update renamed function\n+\tcalls to renamed functions.\n+\t* config/aarch64/aarch64-c.cc (aarch64_update_cpp_builtins): Likewise.\n+\t* config/aarch64/t-aarch64 (aarch-bti-insert.o): Update\n+\ttarget.\n+\t* config/aarch64/aarch64-bti-insert.cc: Delete.\n+\t* config/arm/aarch-bti-insert.cc: New file including and\n+\tgeneralizing code from aarch64-bti-insert.cc.\n+\t* config/arm/aarch-common-protos.h: Update.\n+\n+2023-01-23  Andrea Corallo  <andrea.corallo@arm.com>\n+\n+\t* config/arm/arm.h (arm_arch8m_main): Declare it.\n+\t* config/arm/arm-protos.h (arm_current_function_pac_enabled_p):\n+\tDeclare it.\n+\t* config/arm/arm.cc (arm_arch8m_main): Define it.\n+\t(arm_option_reconfigure_globals): Set arm_arch8m_main.\n+\t(arm_compute_frame_layout, arm_expand_prologue)\n+\t(thumb2_expand_return, arm_expand_epilogue)\n+\t(arm_conditional_register_usage): Update for pac codegen.\n+\t(arm_current_function_pac_enabled_p): New function.\n+\t(aarch_bti_enabled) New function.\n+\t(use_return_insn): Return zero when pac is enabled.\n+\t* config/arm/arm.md (pac_ip_lr_sp, pacbti_ip_lr_sp, aut_ip_lr_sp):\n+\tAdd new patterns.\n+\t* config/arm/unspecs.md (UNSPEC_PAC_NOP)\n+\t(VUNSPEC_PACBTI_NOP, VUNSPEC_AUT_NOP): Add unspecs.\n+\n+2023-01-23  Andrea Corallo  <andrea.corallo@arm.com>\n+\n+\t* config/arm/t-rmprofile: Add multilib rules for march +pacbti and\n+\tmbranch-protection.\n+\n+2023-01-23  Andrea Corallo  <andrea.corallo@arm.com>\n+\t    Tejas Belagod   <tbelagod@arm.com>\n+\n+\t* config/arm/arm.cc (arm_file_start): Emit EABI attributes for\n+\tTag_PAC_extension, Tag_BTI_extension, TAG_BTI_use, TAG_PACRET_use.\n+\n+2023-01-23  Andrea Corallo  <andrea.corallo@arm.com>\n+\t    Tejas Belagod   <tbelagod@arm.com>\n+\t    Srinath Parvathaneni  <srinath.parvathaneni@arm.com>\n+\n+\t* ginclude/unwind-arm-common.h (_Unwind_VRS_RegClass): Introduce\n+\tnew pseudo register class _UVRSC_PAC.\n+\n+2023-01-23  Andrea Corallo  <andrea.corallo@arm.com>\n+\t    Tejas Belagod   <tbelagod@arm.com>\n+\n+\t* config/arm/arm-c.cc (arm_cpu_builtins): Define\n+\t__ARM_FEATURE_BTI_DEFAULT, __ARM_FEATURE_PAC_DEFAULT,\n+\t__ARM_FEATURE_PAUTH and __ARM_FEATURE_BTI.\n+\n+2023-01-23  Andrea Corallo  <andrea.corallo@arm.com>\n+\t    Tejas Belagod   <tbelagod@arm.com>\n+\n+\t* doc/sourcebuild.texi: Document arm_pacbti_hw.\n+\n+2023-01-23  Andrea Corallo  <andrea.corallo@arm.com>\n+\t    Tejas Belagod   <tbelagod@arm.com>\n+\t    Richard Earnshaw  <Richard.Earnshaw@arm.com>\n+\n+\t* config/arm/arm.cc (arm_configure_build_target): Parse and validate\n+\t-mbranch-protection option and initialize appropriate data structures.\n+\t* config/arm/arm.opt (-mbranch-protection): New option.\n+\t* doc/invoke.texi (Arm Options): Document it.\n+\n+2023-01-23  Andrea Corallo  <andrea.corallo@arm.com>\n+\t    Tejas Belagod   <tbelagod@arm.com>\n+\n+\t* config/arm/arm.h (TARGET_HAVE_PACBTI): New macro.\n+\t* config/arm/arm-cpus.in (pacbti): New feature.\n+\t* doc/invoke.texi (Arm Options): Document it.\n+\n+2023-01-23  Andrea Corallo  <andrea.corallo@arm.com>\n+\t    Tejas Belagod   <tbelagod@arm.com>\n+\n+\t* common/config/aarch64/aarch64-common.cc: Include aarch-common.h.\n+\t(all_architectures): Fix comment.\n+\t(aarch64_parse_extension): Rename return type, enum value names.\n+\t* config/aarch64/aarch64-c.cc (aarch64_update_cpp_builtins): Rename\n+\tfactored out aarch_ra_sign_scope and aarch_ra_sign_key variables.\n+\tAlso rename corresponding enum values.\n+\t* config/aarch64/aarch64-opts.h (aarch64_function_type): Factor\n+\tout aarch64_function_type and move it to common code as\n+\taarch_function_type in aarch-common.h.\n+\t* config/aarch64/aarch64-protos.h: Include common types header,\n+\tmove out types aarch64_parse_opt_result and aarch64_key_type to\n+\taarch-common.h\n+\t* config/aarch64/aarch64.cc: Move mbranch-protection parsing types\n+\tand functions out into aarch-common.h and aarch-common.cc.  Fix up\n+\tall the name changes resulting from the move.\n+\t* config/aarch64/aarch64.md: Fix up aarch64_ra_sign_key type name change\n+\tand enum value.\n+\t* config/aarch64/aarch64.opt: Include aarch-common.h to import\n+\ttype move.  Fix up name changes from factoring out common code and\n+\tdata.\n+\t* config/arm/aarch-common-protos.h: Export factored out routines to both\n+\tbackends.\n+\t* config/arm/aarch-common.cc: Include newly factored out types.\n+\tMove all mbranch-protection code and data structures from\n+\taarch64.cc.\n+\t* config/arm/aarch-common.h: New header that declares types shared\n+\tbetween aarch32 and aarch64 backends.\n+\t* config/arm/arm-protos.h: Declare types and variables that are\n+\tmade common to aarch64 and aarch32 backends - aarch_ra_sign_key,\n+\taarch_ra_sign_scope and aarch_enable_bti.\n+\t* config/arm/arm.opt (config/arm/aarch-common.h): Include header.\n+\t(aarch_ra_sign_scope, aarch_enable_bti): Declare variable.\n+\t* config/arm/arm.cc: Add missing includes.\n+\n+2023-01-23  Tobias Burnus  <tobias@codesourcery.com>\n+\n+\t* doc/install.texi (amdgcn, nvptx): Require newlib 4.3.0.\n+\n+2023-01-23  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/108449\n+\t* cgraphunit.cc (check_global_declaration): Do not turn\n+\tundefined statics into externs.\n+\n+2023-01-22  Dimitar Dimitrov  <dimitar@dinux.eu>\n+\n+\t* config/pru/pru.h (CLZ_DEFINED_VALUE_AT_ZERO): Fix value for QI\n+\tand HI input modes.\n+\t* config/pru/pru.md (clz): Fix generated code for QI and HI\n+\tinput modes.\n+\n+2023-01-22  Cupertino Miranda  <cupertino.miranda@oracle.com>\n+\n+\t* config/v850/v850.cc (v850_select_section): Put const volatile\n+\tobjects into read-only sections.\n+\n+2023-01-20  Tejas Belagod  <tejas.belagod@arm.com>\n+\n+\t* config/aarch64/arm_neon.h (vmull_p64, vmull_high_p64, vaeseq_u8,\n+\tvaesdq_u8, vaesmcq_u8, vaesimcq_u8): Gate under \"nothing+aes\".\n+\t(vsha1*_u32, vsha256*_u32): Gate under \"nothing+sha2\".\n+\n+2023-01-20  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/108457\n+\t* tree-ssa-loop-niter.cc (build_cltz_expr): Use\n+\tSCALAR_INT_TYPE_MODE (utype) directly as C[LT]Z_DEFINED_VALUE_AT_ZERO\n+\targument instead of a temporary.  Formatting fixes.\n+\n+2023-01-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/108447\n+\t* value-relation.cc (rr_union_table): Fix VREL_UNDEFINED row order.\n+\t(relation_tests): Add self-tests for relation_{intersect,union}\n+\tcommutativity.\n+\t* selftest.h (relation_tests): Declare.\n+\t* function-tests.cc (test_ranges): Call it.\n+\n+2023-01-19  H.J. Lu  <hjl.tools@gmail.com>\n+\n+\tPR target/108436\n+\t* config/i386/i386-expand.cc (ix86_expand_builtin): Check\n+\tinvalid third argument to __builtin_ia32_prefetch.\n+\n+2023-01-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/108459\n+\t* omp-expand.cc (expand_omp_for_init_counts): Use fold_build1 rather\n+\tthan fold_unary for NEGATE_EXPR.\n+\n+2023-01-19  Christophe Lyon  <christophe.lyon@arm.com>\n+\n+\tPR target/108411\n+\t* config/aarch64/aarch64.cc (aarch64_layout_arg): Improve\n+\tcomment. Move assert about alignment a bit later.\n+\n+2023-01-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/108440\n+\t* tree-ssa-forwprop.cc: Include gimple-range.h.\n+\t(simplify_rotate): For the forms with T2 wider than T and shift counts of\n+\tY and B - Y add & (B - 1) masking for the rotate count if Y could be equal\n+\tto B.  For the forms with T2 wider than T and shift counts of\n+\tY and (-Y) & (B - 1), don't punt if range could be [B, B2], but only if\n+\trange doesn't guarantee Y < B or Y = N * B.  If range doesn't guarantee\n+\tY < B, also add & (B - 1) masking for the rotate count.  Use lazily created\n+\tpass specific ranger instead of get_global_range_query.\n+\t(pass_forwprop::execute): Disable that ranger at the end of pass if it has\n+\tbeen created.\n+\n+2023-01-19  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n+\n+\t* config/aarch64/aarch64-simd.md (aarch64_simd_vec_set<mode>): Use\n+\texact_log2 (INTVAL (operands[2])) >= 0 as condition for gating\n+\tthe pattern.\n+\t(aarch64_simd_vec_copy_lane<mode>): Likewise.\n+\t(aarch64_simd_vec_copy_lane_<vswap_width_name><mode>): Likewise.\n+\n+2023-01-19  Alexandre Oliva  <oliva@adacore.com>\n+\n+\tPR debug/106746\n+\t* sched-deps.cc (sched_analyze_2): Skip cselib address lookup\n+\twithin debug insns.\n+\n+2023-01-18  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR ipa/107944\n+\t* cgraph.cc (cgraph_node::remove): Check whether nodes up the\n+\tlcone_of chain also do not need the body.\n+\n+2023-01-18  Richard Biener  <rguenther@suse.de>\n+\n+\tRevert:\n+\t2022-12-16  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/108086\n+\t* tree-inline.cc (remap_ssa_name): Do not unshare the\n+\tresult from the decl_map.\n+\n+2023-01-18  Murray Steele  <murray.steele@arm.com>\n+\n+\tPR target/108442\n+\t* config/arm/arm_mve.h (__arm_vst1q_p_u8): Use prefixed intrinsic\n+\tfunction.\n+\t(__arm_vst1q_p_s8): Likewise.\n+\t(__arm_vld1q_z_u8): Likewise.\n+\t(__arm_vld1q_z_s8): Likewise.\n+\t(__arm_vst1q_p_u16): Likewise.\n+\t(__arm_vst1q_p_s16): Likewise.\n+\t(__arm_vld1q_z_u16): Likewise.\n+\t(__arm_vld1q_z_s16): Likewise.\n+\t(__arm_vst1q_p_u32): Likewise.\n+\t(__arm_vst1q_p_s32): Likewise.\n+\t(__arm_vld1q_z_u32): Likewise.\n+\t(__arm_vld1q_z_s32): Likewise.\n+\t(__arm_vld1q_z_f16): Likewise.\n+\t(__arm_vst1q_p_f16): Likewise.\n+\t(__arm_vld1q_z_f32): Likewise.\n+\t(__arm_vst1q_p_f32): Likewise.\n+\n+2023-01-18  Takayuki 'January June' Suwa  <jjsuwa_sys3175@yahoo.co.jp>\n+\n+\t* config/xtensa/xtensa.md (xorsi3_internal):\n+\tRename from the original of \"xorsi3\".\n+\t(xorsi3): New expansion pattern that emits addition rather than\n+\tbitwise-XOR when the second source is a constant of -2147483648\n+\tif TARGET_DENSITY.\n+\n+2023-01-18  Kewen Lin  <linkw@linux.ibm.com>\n+\t    Andrew Pinski  <apinski@marvell.com>\n+\n+\tPR target/108396\n+\t* config/rs6000/rs6000-overload.def (VEC_VSUBCUQ): Fix typo\n+\tvec_vsubcuqP with vec_vsubcuq.\n+\n+2023-01-18  Kewen Lin  <linkw@linux.ibm.com>\n+\n+\tPR target/108348\n+\t* config/rs6000/rs6000.cc (rs6000_opaque_type_invalid_use_p): Add the\n+\tsupport for invalid uses of MMA opaque type in function arguments.\n+\n+2023-01-18  liuhongt  <hongtao.liu@intel.com>\n+\n+\tPR target/55522\n+\t* config/i386/cygwin.h (ENDFILE_SPEC): Link crtfastmath.o\n+\twhenever -mdaz-ftz is specified. Don't link crtfastmath.o when\n+\t-share or -mno-daz-ftz is specified.\n+\t* config/i386/darwin.h (ENDFILE_SPEC): Ditto.\n+\t* config/i386/mingw32.h (ENDFILE_SPEC): Ditto.\n+\n+2023-01-17  Jose E. Marchesi  <jose.marchesi@oracle.com>\n+\n+\t* config/bpf/bpf.cc (bpf_option_override): Disable\n+\t-fstack-protector.\n+\n+2023-01-17  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/106523\n+\t* tree-ssa-forwprop.cc (simplify_rotate): For the\n+\tpatterns with (-Y) & (B - 1) in one operand's shift\n+\tcount and Y in another, if T2 has wider precision than T,\n+\tpunt if Y could have a value in [B, B2 - 1] range.\n+\n+2023-01-16  H.J. Lu  <hjl.tools@gmail.com>\n+\n+\tPR target/105980\n+\t* config/i386/i386.cc (x86_output_mi_thunk): Disable\n+\t-mforce-indirect-call for PIC in 32-bit mode.\n+\n+2023-01-16  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/106077\n+\t* ipa-modref.cc (modref_access_analysis::analyze): Use\n+\tfind_always_executed_bbs.\n+\t* ipa-sra.cc (process_scan_results): Likewise.\n+\t* ipa-utils.cc (stmt_may_terminate_function_p): New function.\n+\t(find_always_executed_bbs): New function.\n+\t* ipa-utils.h (stmt_may_terminate_function_p): Declare.\n+\t(find_always_executed_bbs): Declare.\n+\n+2023-01-16  Jan Hubicka  <jh@suse.cz>\n+\n+\t* config/i386/i386.cc (ix86_vectorize_builtin_scatter): Guard scatter\n+\tby TARGET_USE_SCATTER.\n+\t* config/i386/i386.h (TARGET_USE_SCATTER_2PARTS,\n+\tTARGET_USE_SCATTER_4PARTS, TARGET_USE_SCATTER): New macros.\n+\t* config/i386/x86-tune.def (TARGET_USE_SCATTER_2PARTS,\n+\tTARGET_USE_SCATTER_4PARTS, TARGET_USE_SCATTER): New tunes.\n+\t(X86_TUNE_AVOID_256FMA_CHAINS, X86_TUNE_AVOID_512FMA_CHAINS): Disable\n+\tfor znver4.  (X86_TUNE_USE_GATHER): Disable for zen4.\n+\n+2023-01-16  Richard Biener  <rguenther@suse.de>\n+\n+\tPR target/55522\n+\t* config/sol2.h (ENDFILE_SPEC): Don't add crtfastmath.o for -shared.\n+\n+2023-01-16  Stam Markianos-Wright  <stam.markianos-wright@arm.com>\n+\n+\tPR target/96795\n+\tPR target/107515\n+\t* config/arm/arm_mve.h (__ARM_mve_coerce2): Split types.\n+\t(__ARM_mve_coerce3): Likewise.\n+\n+2023-01-16  Andrew Carlotti  <andrew.carlotti@arm.com>\n+\n+\t* tree-ssa-loop-niter.cc (build_popcount_expr): Add IFN support.\n+\n+2023-01-16  Andrew Carlotti  <andrew.carlotti@arm.com>\n+\n+\t* tree-ssa-loop-niter.cc (number_of_iterations_cltz): New.\n+\t(number_of_iterations_bitcount): Add call to the above.\n+\t(number_of_iterations_exit_assumptions): Add EQ_EXPR case for\n+\tc[lt]z idiom recognition.\n+\n+2023-01-16  Andrew Carlotti  <andrew.carlotti@arm.com>\n+\n+\t* doc/sourcebuild.texi: Add missing target attributes.\n+\n+2023-01-16  Andrew Carlotti  <andrew.carlotti@arm.com>\n+\n+\tPR tree-optimization/94793\n+\t* tree-scalar-evolution.cc (expression_expensive_p): Add checks\n+\tfor c[lt]z optabs.\n+\t* tree-ssa-loop-niter.cc (build_cltz_expr): New.\n+\t(number_of_iterations_cltz_complement): New.\n+\t(number_of_iterations_bitcount): Add call to the above.\n+\n+2023-01-16  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* doc/extend.texi (Common Function Attributes): Fix grammar.\n+\n+2023-01-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR other/108413\n+\t* config/riscv/riscv-vsetvl.h: Add space in between Copyright and (C).\n+\t* config/riscv/riscv-vsetvl.cc: Likewise.\n+\n+2023-01-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/105593\n+\t* config/i386/xmmintrin.h (_mm_undefined_ps): Temporarily\n+\tdisable -Winit-self using pragma GCC diagnostic ignored.\n+\t* config/i386/emmintrin.h (_mm_undefined_pd, _mm_undefined_si128):\n+\tLikewise.\n+\t* config/i386/avxintrin.h (_mm256_undefined_pd, _mm256_undefined_ps,\n+\t_mm256_undefined_si256): Likewise.\n+\t* config/i386/avx512fintrin.h (_mm512_undefined_pd,\n+\t_mm512_undefined_ps, _mm512_undefined_epi32): Likewise.\n+\t* config/i386/avx512fp16intrin.h (_mm_undefined_ph,\n+\t_mm256_undefined_ph, _mm512_undefined_ph): Likewise.\n+\n+2023-01-16  Kewen Lin  <linkw@linux.ibm.com>\n+\n+\tPR target/108272\n+\t* config/rs6000/rs6000.cc (rs6000_opaque_type_invalid_use_p): Add the\n+\tsupport for invalid uses in inline asm, factor out the checking and\n+\terroring to lambda function check_and_error_invalid_use.\n+\n 2023-01-15  Aldy Hernandez  <aldyh@redhat.com>\n \n \tPR tree-optimization/107608"}, {"sha": "aa6d8640ab91e4ed8737a946e0845e70d166baf5", "filename": "gcc/DATESTAMP", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2FDATESTAMP", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2FDATESTAMP", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FDATESTAMP?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1 +1 @@\n-20230116\n+20230131"}, {"sha": "487e5069952909a3994970b368770a3de718ac1a", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -532,7 +532,11 @@ LINKER_PLUGIN_API_H = $(srcdir)/../include/plugin-api.h\n # Default native SYSTEM_HEADER_DIR, to be overridden by targets.\n NATIVE_SYSTEM_HEADER_DIR = @NATIVE_SYSTEM_HEADER_DIR@\n # Default cross SYSTEM_HEADER_DIR, to be overridden by targets.\n-CROSS_SYSTEM_HEADER_DIR = @CROSS_SYSTEM_HEADER_DIR@\n+ifeq (@includedir@,$(prefix)/include)\n+  CROSS_SYSTEM_HEADER_DIR = @CROSS_SYSTEM_HEADER_DIR@\n+else\n+  CROSS_SYSTEM_HEADER_DIR = @includedir@\n+endif\n \n # autoconf sets SYSTEM_HEADER_DIR to one of the above.\n # Purge it of unnecessary internal relative paths"}, {"sha": "cebcb42d0ff140588349ecf950db8ba1b6771b75", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1,3 +1,101 @@\n+2023-01-16  Marc Poulhi\u00e8s  <poulhies@adacore.com>\n+\n+\t* gcc-interface/Make-lang.in: Update copyright years.\n+\t* gcc-interface/Makefile.in: Likewise.\n+\t* gcc-interface/ada-builtin-types.def: Likewise.\n+\t* gcc-interface/ada-builtins.def: Likewise.\n+\t* gcc-interface/ada-tree.def: Likewise.\n+\t* gcc-interface/ada-tree.h: Likewise.\n+\t* gcc-interface/ada.h: Likewise.\n+\t* gcc-interface/config-lang.in: Likewise.\n+\t* gcc-interface/cuintp.cc: Likewise.\n+\t* gcc-interface/decl.cc: Likewise.\n+\t* gcc-interface/gadaint.h: Likewise.\n+\t* gcc-interface/gigi.h: Likewise.\n+\t* gcc-interface/lang-specs.h: Likewise.\n+\t* gcc-interface/lang.opt: Likewise.\n+\t* gcc-interface/misc.cc: Likewise.\n+\t* gcc-interface/system.ads: Likewise.\n+\t* gcc-interface/targtyps.cc: Likewise.\n+\t* gcc-interface/trans.cc: Likewise.\n+\t* gcc-interface/utils.cc: Likewise.\n+\t* gcc-interface/utils2.cc: Likewise.\n+\n+2023-01-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_ch3.adb (Make_Allocator_For_Return): Fix typo in comment.\n+\n+2023-01-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_ch3.adb (Make_Allocator_For_Return): Convert the expression\n+\tto the return object's type in the constrained array case as well.\n+\n+2023-01-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_ch3.adb (Expand_N_Object_Declaration): For a class-wide non-\n+\tinterface stand-alone object initialized by a function call, call\n+\tRemove_Side_Effects on the expression to capture the result.\n+\n+2023-01-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_util.ads (Has_Tag_Of_Type): Declare.\n+\t* exp_util.adb (Has_Tag_Of_Type): Move to package level.  Recurse on\n+\tqualified expressions.\n+\t* exp_ch3.adb (Expand_N_Object_Declaration): Use a static reference\n+\tto the interface tag in more cases for class-wide interface objects.\n+\n+2023-01-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_util.adb (Make_CW_Equivalent_Type.Has_Tag_Of_Type): Fix pasto.\n+\n+2023-01-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_util.adb (Is_Temporary_For_Interface_Object): Delete.\n+\t(Is_Finalizable_Transient.Is_Aliased): Deal with the specific case\n+\tof temporaries generated for interface objects.\n+\n+2023-01-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_ch3.adb (Expand_N_Object_Declaration): Do not generate a back-\n+\tand-forth displacement of the object's address when using a renaming\n+\tfor an interface object with an expression of the same type.\n+\t* exp_ch4.adb (Expand_Allocator_Expression): Do not remove the side\n+\teffects of the expression up front for the simple allocators. Do not\n+\tcall the Adjust primitive if the expression is a function call.\n+\t* exp_ch6.adb (Expand_Ctrl_Function_Call): Do not expand the call\n+\tunnecessarily for a special return object.\n+\t(Expand_Simple_Function_Return): Restore the displacement of the\n+\treturn object's address in the case where the expression is the call\n+\tto a function whose result type is a type that needs finalization.\n+\t* exp_util.adb (Expand_Subtype_From_Expr): Do not remove the side\n+\teffects of the expression before calling Make_Subtype_From_Expr.\n+\t(Make_CW_Equivalent_Type): If the expression has the tag of its type\n+\tand this type has a uniform size, use 'Object_Size of this type in\n+\tlieu of 'Size of the expression to compute the expression's size.\n+\n+2023-01-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_ch3.adb (Make_Allocator_For_Return): Put back an interface\n+\tconversion for expressions with non-interface class-wide type.\n+\n+2023-01-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_ch3.adb (Expand_N_Object_Declaration): Also optimize aliased\n+\tobjects if their nominal subtype is not an unconstrained array.\n+\n+2023-01-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_ch3.adb (Expand_N_Object_Declaration): Factor out conditions\n+\tneeded for an initializating expression that is a function call to\n+\tbe renamable into the Is_Renamable_Function_Call predicate.\n+\tUse it to implement the renaming in the case of class-wide interface\n+\tobjects.  Remove an interface conversion on all paths, separate and\n+\toptimize the renaming path in the special expansion for interfaces.\n+\t(Is_Renamable_Function_Call): New predicate.\n+\t(Make_Allocator_For_Return): Put back an interface conversion.\n+\t* exp_ch6.adb (Apply_CW_Accessibility_Check): Remove useless access\n+\tchecks on RE_Tag_Ptr.\n+\n 2023-01-09  Arnaud Charlet  <charlet@adacore.com>\n \n \t* accessibility.adb, accessibility.ads, ada_get_targ.adb: Update copyright year."}, {"sha": "abe71b252e7761a8da1cb8d7a42a2705c6a6694f", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 205, "deletions": 122, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -6306,6 +6306,38 @@ package body Exp_Ch3 is\n       --  Generate all initialization actions for return object Def_Id. Any\n       --  new code is inserted after node After.\n \n+      function Is_Renamable_Function_Call (Expr : Node_Id) return Boolean;\n+      --  If we are not at library level and the object declaration originally\n+      --  appears in the form:\n+\n+      --    Obj : Typ := Func (...);\n+\n+      --  and has been rewritten as the dereference of a captured reference\n+      --  to the function result built either on the primary or the secondary\n+      --  stack, then the declaration can be rewritten as the renaming of this\n+      --  dereference:\n+\n+      --    type Ann is access all Typ;\n+      --    Rnn : constant Axx := Func (...)'reference;\n+      --    Obj : Typ renames Rnn.all;\n+\n+      --  This will avoid making an extra copy and, in the case where Typ needs\n+      --  finalization, a pair of calls to the Adjust and Finalize primitives,\n+      --  or Deep_Adjust and Deep_Finalize routines, depending on whether Typ\n+      --  has components that themselves need finalization.\n+\n+      --  However, in the case of a special return object, we need to make sure\n+      --  that the object Rnn is recognized by the Is_Related_To_Func_Return\n+      --  predicate; otherwise, if it is of a type that needs finalization,\n+      --  then Requires_Cleanup_Actions would return true because of this and\n+      --  Build_Finalizer would finalize it prematurely because of this (see\n+      --  also Expand_Simple_Function_Return for the same test in the case of\n+      --  a simple return).\n+\n+      --  Finally, in the case of a special return object, we also need to make\n+      --  sure that the two functions return on the same stack, otherwise we\n+      --  would create a dangling reference.\n+\n       function Make_Allocator_For_Return (Expr : Node_Id) return Node_Id;\n       --  Make an allocator for a return object initialized with Expr\n \n@@ -7100,12 +7132,28 @@ package body Exp_Ch3 is\n          end if;\n       end Initialize_Return_Object;\n \n+      --------------------------------\n+      -- Is_Renamable_Function_Call --\n+      --------------------------------\n+\n+      function Is_Renamable_Function_Call (Expr : Node_Id) return Boolean is\n+      begin\n+         return not Is_Library_Level_Entity (Def_Id)\n+           and then Is_Captured_Function_Call (Expr)\n+           and then (not Special_Ret_Obj\n+                      or else\n+                        (Is_Related_To_Func_Return (Entity (Prefix (Expr)))\n+                          and then Needs_Secondary_Stack (Etype (Expr)) =\n+                                   Needs_Secondary_Stack (Etype (Func_Id))));\n+      end Is_Renamable_Function_Call;\n+\n       -------------------------------\n       -- Make_Allocator_For_Return --\n       -------------------------------\n \n       function Make_Allocator_For_Return (Expr : Node_Id) return Node_Id is\n-         Alloc : Node_Id;\n+         Alloc      : Node_Id;\n+         Alloc_Expr : Entity_Id;\n \n       begin\n          --  If the return object's declaration includes an expression and the\n@@ -7131,18 +7179,32 @@ package body Exp_Ch3 is\n                Apply_CW_Accessibility_Check (Expr, Func_Id);\n             end if;\n \n+            Alloc_Expr := New_Copy_Tree (Expr);\n+\n+            --  In the constrained array case, deal with a potential sliding.\n+            --  In the interface case, put back a conversion that we may have\n+            --  removed earlier in the processing.\n+\n+            if (Ekind (Typ) = E_Array_Subtype\n+                 or else (Is_Interface (Typ)\n+                           and then Is_Class_Wide_Type (Etype (Alloc_Expr))))\n+              and then Typ /= Etype (Alloc_Expr)\n+            then\n+               Alloc_Expr := Convert_To (Typ, Alloc_Expr);\n+            end if;\n+\n             --  We always use the type of the expression for the qualified\n             --  expression, rather than the return object's type. We cannot\n             --  always use the return object's type because the expression\n-            --  might be of a specific type and the result object mignt not.\n+            --  might be of a specific type and the return object mignt not.\n \n             Alloc :=\n               Make_Allocator (Loc,\n                 Expression =>\n                   Make_Qualified_Expression (Loc,\n                     Subtype_Mark =>\n-                      New_Occurrence_Of (Etype (Expr), Loc),\n-                    Expression   => New_Copy_Tree (Expr)));\n+                      New_Occurrence_Of (Etype (Alloc_Expr), Loc),\n+                    Expression   => Alloc_Expr));\n \n          else\n             Alloc :=\n@@ -7479,12 +7541,42 @@ package body Exp_Ch3 is\n          then\n             pragma Assert (Is_Class_Wide_Type (Typ));\n \n+            --  If the original node of the expression was a conversion\n+            --  to this specific class-wide interface type then restore\n+            --  the original node because we must copy the object before\n+            --  displacing the pointer to reference the secondary tag\n+            --  component. This code must be kept synchronized with the\n+            --  expansion done by routine Expand_Interface_Conversion\n+\n+            if not Comes_From_Source (Expr)\n+              and then Nkind (Expr) = N_Explicit_Dereference\n+              and then Nkind (Original_Node (Expr)) = N_Type_Conversion\n+              and then Etype (Original_Node (Expr)) = Typ\n+            then\n+               Rewrite (Expr, Original_Node (Expression (N)));\n+            end if;\n+\n+            --  Avoid expansion of redundant interface conversion\n+\n+            if Nkind (Expr) = N_Type_Conversion\n+              and then Etype (Expr) = Typ\n+            then\n+               Expr_Q := Expression (Expr);\n+            else\n+               Expr_Q := Expr;\n+            end if;\n+\n+            --  We may use a renaming if the initialization expression is a\n+            --  captured function call that meets a few conditions.\n+\n+            Rewrite_As_Renaming := Is_Renamable_Function_Call (Expr_Q);\n+\n             --  If the object is a special return object, then bypass special\n             --  treatment of class-wide interface initialization below. In this\n-            --  case, the expansion of the return statement will take care of\n-            --  creating the object (via allocator) and initializing it.\n+            --  case, the expansion of the return object will take care of this\n+            --  initialization via the expansion of the allocator.\n \n-            if Special_Ret_Obj then\n+            if Special_Ret_Obj and then not Rewrite_As_Renaming then\n \n                --  If the type needs finalization and is not inherently\n                --  limited, then the target is adjusted after the copy\n@@ -7499,6 +7591,13 @@ package body Exp_Ch3 is\n                       Typ     => Base_Typ);\n                end if;\n \n+            --  Renaming an expression of the object's type is immediate\n+\n+            elsif Rewrite_As_Renaming\n+              and then Base_Type (Etype (Expr_Q)) = Base_Type (Typ)\n+            then\n+               null;\n+\n             elsif Tagged_Type_Expansion then\n                declare\n                   Iface : constant Entity_Id := Root_Type (Typ);\n@@ -7511,57 +7610,74 @@ package body Exp_Ch3 is\n                   Tag_Comp     : Node_Id;\n \n                begin\n-                  --  If the original node of the expression was a conversion\n-                  --  to this specific class-wide interface type then restore\n-                  --  the original node because we must copy the object before\n-                  --  displacing the pointer to reference the secondary tag\n-                  --  component. This code must be kept synchronized with the\n-                  --  expansion done by routine Expand_Interface_Conversion\n-\n-                  if not Comes_From_Source (Expr)\n-                    and then Nkind (Expr) = N_Explicit_Dereference\n-                    and then Nkind (Original_Node (Expr)) = N_Type_Conversion\n-                    and then Etype (Original_Node (Expr)) = Typ\n-                  then\n-                     Rewrite (Expr, Original_Node (Expression (N)));\n+                  Expr_Typ := Base_Type (Etype (Expr_Q));\n+                  if Is_Class_Wide_Type (Expr_Typ) then\n+                     Expr_Typ := Root_Type (Expr_Typ);\n                   end if;\n \n-                  --  Avoid expansion of redundant interface conversion\n+                  --  Rename limited objects since they cannot be copied\n \n-                  if Is_Interface (Etype (Expr))\n-                    and then Nkind (Expr) = N_Type_Conversion\n-                    and then Etype (Expr) = Typ\n-                  then\n-                     Expr_Q := Expression (Expr);\n-                  else\n-                     Expr_Q := Expr;\n+                  if Is_Limited_Record (Expr_Typ) then\n+                     Rewrite_As_Renaming := True;\n                   end if;\n \n-                  Obj_Id   := Make_Temporary (Loc, 'D', Expr_Q);\n-                  Expr_Typ := Base_Type (Etype (Expr_Q));\n+                  Obj_Id := Make_Temporary (Loc, 'D', Expr_Q);\n \n-                  if Is_Class_Wide_Type (Expr_Typ) then\n-                     Expr_Typ := Root_Type (Expr_Typ);\n-                  end if;\n+                  --  Replace\n+                  --     IW : I'Class := Expr;\n+                  --  by\n+                  --     Dnn : Tag renames Tag_Ptr!(Expr'Address).all;\n+                  --     type Ityp is not null access I'Class;\n+                  --     Rnn : constant Ityp :=\n+                  --             Ityp!(Displace (Dnn'Address, I'Tag));\n+                  --     IW : I'Class renames Rnn.all;\n+\n+                  if Rewrite_As_Renaming then\n+                     New_Expr :=\n+                       Make_Explicit_Dereference (Loc,\n+                         Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n+                           Make_Attribute_Reference (Loc,\n+                             Prefix => Relocate_Node (Expr_Q),\n+                             Attribute_Name => Name_Address)));\n+\n+                     --  Suppress junk access checks on RE_Tag_Ptr\n+\n+                     Insert_Action (N,\n+                       Make_Object_Renaming_Declaration (Loc,\n+                         Defining_Identifier => Obj_Id,\n+                         Subtype_Mark        =>\n+                           New_Occurrence_Of (RTE (RE_Tag), Loc),\n+                         Name                => New_Expr),\n+                       Suppress => Access_Check);\n+\n+                     --  Dynamically reference the tag associated with the\n+                     --  interface.\n+\n+                     Tag_Comp :=\n+                       Make_Function_Call (Loc,\n+                         Name => New_Occurrence_Of (RTE (RE_Displace), Loc),\n+                         Parameter_Associations => New_List (\n+                           Make_Attribute_Reference (Loc,\n+                             Prefix => New_Occurrence_Of (Obj_Id, Loc),\n+                             Attribute_Name => Name_Address),\n+                           New_Occurrence_Of\n+                             (Node (First_Elmt (Access_Disp_Table (Iface))),\n+                              Loc)));\n \n                   --  Replace\n-                  --     CW : I'Class := Obj;\n+                  --     IW : I'Class := Expr;\n                   --  by\n-                  --     Tmp : Typ := Obj;\n+                  --     Dnn : Typ := Expr;\n                   --     type Ityp is not null access I'Class;\n-                  --     Rnn : constant Ityp := Ityp (Tmp.I_Tag'Address);\n-                  --     CW  : I'Class renames Rnn.all;\n+                  --     Rnn : constant Ityp := Ityp (Dnn.I_Tag'Address);\n+                  --     IW  : I'Class renames Rnn.all;\n \n-                  if Comes_From_Source (Expr_Q)\n-                    and then Is_Entity_Name (Expr_Q)\n-                    and then not Is_Interface (Expr_Typ)\n+                  elsif Has_Tag_Of_Type (Expr_Q)\n                     and then Interface_Present_In_Ancestor (Expr_Typ, Typ)\n                     and then (Expr_Typ = Etype (Expr_Typ)\n                                or else not\n                                  Is_Variable_Size_Record (Etype (Expr_Typ)))\n                   then\n-                     --  Copy the object\n-\n                      Insert_Action (N,\n                        Make_Object_Declaration (Loc,\n                          Defining_Identifier => Obj_Id,\n@@ -7580,14 +7696,14 @@ package body Exp_Ch3 is\n                              (Find_Interface_Tag (Expr_Typ, Iface), Loc));\n \n                   --  Replace\n-                  --     IW : I'Class := Obj;\n+                  --     IW : I'Class := Expr;\n                   --  by\n                   --     type Equiv_Record is record ... end record;\n                   --     implicit subtype CW is <Class_Wide_Subtype>;\n-                  --     Tmp : CW := CW!(Obj);\n+                  --     Dnn : CW := CW!(Expr);\n                   --     type Ityp is not null access I'Class;\n                   --     Rnn : constant Ityp :=\n-                  --             Ityp!(Displace (Tmp'Address, I'Tag));\n+                  --             Ityp!(Displace (Dnn'Address, I'Tag));\n                   --     IW : I'Class renames Rnn.all;\n \n                   else\n@@ -7600,47 +7716,34 @@ package body Exp_Ch3 is\n                         Subtype_Indic => Obj_Def,\n                         Exp           => Expr_Q);\n \n-                     if not Is_Interface (Etype (Expr_Q)) then\n-                        New_Expr := Relocate_Node (Expr_Q);\n-\n                      --  For interface types we use 'Address which displaces\n-                     --  the pointer to the base of the object (if required)\n+                     --  the pointer to the base of the object (if required).\n \n-                     else\n+                     if Is_Interface (Etype (Expr_Q)) then\n                         New_Expr :=\n                           Unchecked_Convert_To (Etype (Obj_Def),\n                             Make_Explicit_Dereference (Loc,\n                               Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n                                 Make_Attribute_Reference (Loc,\n                                   Prefix => Relocate_Node (Expr_Q),\n                                   Attribute_Name => Name_Address))));\n-                     end if;\n-\n-                     --  Copy the object\n \n-                     if not Is_Limited_Record (Expr_Typ) then\n-                        Insert_Action (N,\n-                          Make_Object_Declaration (Loc,\n-                            Defining_Identifier => Obj_Id,\n-                            Object_Definition   =>\n-                              New_Occurrence_Of (Etype (Obj_Def), Loc),\n-                            Expression => New_Expr));\n-\n-                     --  Rename limited type object since they cannot be copied\n-                     --  This case occurs when the initialization expression\n-                     --  has been previously expanded into a temporary object.\n+                     --  For other types, no displacement is needed\n \n                      else\n-                        Insert_Action (N,\n-                          Make_Object_Renaming_Declaration (Loc,\n-                            Defining_Identifier => Obj_Id,\n-                            Subtype_Mark        =>\n-                              New_Occurrence_Of (Etype (Obj_Def), Loc),\n-                            Name                =>\n-                              Unchecked_Convert_To\n-                                (Etype (Obj_Def), New_Expr)));\n+                        New_Expr := Relocate_Node (Expr_Q);\n                      end if;\n \n+                     --  Suppress junk access checks on RE_Tag_Ptr\n+\n+                     Insert_Action (N,\n+                       Make_Object_Declaration (Loc,\n+                         Defining_Identifier => Obj_Id,\n+                         Object_Definition   =>\n+                           New_Occurrence_Of (Etype (Obj_Def), Loc),\n+                         Expression          => New_Expr),\n+                       Suppress => Access_Check);\n+\n                      --  Dynamically reference the tag associated with the\n                      --  interface.\n \n@@ -7684,6 +7787,7 @@ package body Exp_Ch3 is\n                   Set_Prefix (Tag_Comp, New_Occurrence_Of (Ptr_Obj_Id, Loc));\n                   Expr_Q := Tag_Comp;\n                   Set_Etype (Expr_Q, Typ);\n+                  Set_Parent (Expr_Q, N);\n \n                   Rewrite_As_Renaming := True;\n                end;\n@@ -7695,6 +7799,25 @@ package body Exp_Ch3 is\n          --  Common case of explicit object initialization\n \n          else\n+            --  Small optimization: if the expression is a function call and\n+            --  the object is stand-alone, not declared at library level and of\n+            --  a class-wide type, then we capture the result of the call into\n+            --  a temporary, with the benefit that, if the result's type does\n+            --  not need finalization, nothing will be finalized and, if it\n+            --  does, the temporary only will be finalized by means of a direct\n+            --  call to the Finalize primitive if the result's type is not a\n+            --  class-wide type; whereas, in both cases, the stand-alone object\n+            --  itself would be finalized by means of a dispatching call to the\n+            --  Deep_Finalize routine.\n+\n+            if Nkind (Expr_Q) = N_Function_Call\n+              and then not Special_Ret_Obj\n+              and then not Is_Library_Level_Entity (Def_Id)\n+              and then Is_Class_Wide_Type (Typ)\n+            then\n+               Remove_Side_Effects (Expr_Q);\n+            end if;\n+\n             --  In most cases, we must check that the initial value meets any\n             --  constraint imposed by the declared type. However, there is one\n             --  very important exception to this rule. If the entity has an\n@@ -7863,66 +7986,26 @@ package body Exp_Ch3 is\n             Rewrite_As_Renaming :=\n \n               --  The declaration cannot be rewritten if it has got constraints\n-              --  in other words the nominal subtype must be unconstrained.\n \n               Is_Entity_Name (Original_Node (Obj_Def))\n \n-                --  The aliased case has to be excluded because the expression\n-                --  will not be aliased in the general case.\n-\n-                and then not Aliased_Present (N)\n-\n-                --  If the object declaration originally appears in the form\n-\n-                --    Obj : Typ := Func (...);\n-\n-                --  and has been rewritten as the dereference of a reference\n-                --  to the function result built either on the primary or the\n-                --  secondary stack, then the declaration can be rewritten as\n-                --  the renaming of this dereference:\n-\n-                --    type Ann is access all Typ;\n-                --    Rnn : constant Axx := Func (...)'reference;\n-                --    Obj : Typ renames Rnn.all;\n+                --  Nor if it is effectively an unconstrained declaration\n \n-                --  This avoids an extra copy and, in the case where Typ needs\n-                --  finalization, a pair of Adjust/Finalize calls (see below).\n+                and then not (Is_Array_Type (Typ)\n+                               and then Is_Constr_Subt_For_UN_Aliased (Typ))\n \n-                --  However, in the case of a special return object, we need to\n-                --  make sure that the object Rnn is properly recognized by the\n-                --  Is_Related_To_Func_Return predicate; otherwise, if it is of\n-                --  a type that needs finalization, Requires_Cleanup_Actions\n-                --  would return true because of this and Build_Finalizer would\n-                --  finalize it prematurely (see Expand_Simple_Function_Return\n-                --  for the same test in the case of a simple return).\n-\n-                --  Moreover, in the case of a special return object, we also\n-                --  need to make sure that the two functions return on the same\n-                --  stack, otherwise we would create a dangling reference.\n+                --  We may use a renaming if the initialization expression is a\n+                --  captured function call that meets a few conditions.\n \n                 and then\n-                  ((not Is_Library_Level_Entity (Def_Id)\n-                     and then Is_Captured_Function_Call (Expr_Q)\n-                     and then\n-                       (not Special_Ret_Obj\n-                         or else\n-                          (Is_Related_To_Func_Return (Entity (Prefix (Expr_Q)))\n-                            and then Needs_Secondary_Stack (Etype (Expr_Q)) =\n-                                     Needs_Secondary_Stack (Etype (Func_Id)))))\n-\n-                   --  If the initializing expression is a variable with the\n-                   --  flag OK_To_Rename set, then transform:\n-\n-                   --     Obj : Typ := Expr;\n-\n-                   --  into\n+                  (Is_Renamable_Function_Call (Expr_Q)\n \n-                   --     Obj : Typ renames Expr;\n+                   --  Or else if it is a variable with OK_To_Rename set\n \n                    or else (OK_To_Rename_Ref (Expr_Q)\n                              and then not Special_Ret_Obj)\n \n-                   --  Likewise if it is a slice of such a variable\n+                   --  Or else if it is a slice of such a variable\n \n                    or else (Nkind (Expr_Q) = N_Slice\n                              and then OK_To_Rename_Ref (Prefix (Expr_Q))\n@@ -8117,8 +8200,8 @@ package body Exp_Ch3 is\n \n       if Is_Build_In_Place_Return_Object (Def_Id) then\n          declare\n-            Init_Stmt       : Node_Id;\n-            Obj_Acc_Formal  : Entity_Id;\n+            Init_Stmt      : Node_Id;\n+            Obj_Acc_Formal : Entity_Id;\n \n          begin\n             --  Retrieve the implicit access parameter passed by the caller"}, {"sha": "31823eaeca7e0b8d394abd8a6b4baecc61a8d6e0", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -698,11 +698,14 @@ package body Exp_Ch4 is\n          --  recursion and inappropriate call to Initialize.\n \n          --  We don't want to remove side effects when the expression must be\n-         --  built in place. In the case of a build-in-place function call,\n-         --  that could lead to a duplication of the call, which was already\n-         --  substituted for the allocator.\n+         --  built in place and we don't need it when there is no storage pool\n+         --  or this is a return/secondary stack allocation.\n \n-         if not Aggr_In_Place then\n+         if not Aggr_In_Place\n+           and then Present (Storage_Pool (N))\n+           and then not Is_RTE (Storage_Pool (N), RE_RS_Pool)\n+           and then not Is_RTE (Storage_Pool (N), RE_SS_Pool)\n+         then\n             Remove_Side_Effects (Exp);\n          end if;\n \n@@ -747,7 +750,7 @@ package body Exp_Ch4 is\n \n          --  Processing for allocators returning non-interface types\n \n-         if not Is_Interface (Directly_Designated_Type (PtrT)) then\n+         if not Is_Interface (DesigT) then\n             if Aggr_In_Place then\n                Temp_Decl :=\n                  Make_Object_Declaration (Loc,\n@@ -960,8 +963,9 @@ package body Exp_Ch4 is\n \n          if Needs_Finalization (DesigT)\n            and then Needs_Finalization (T)\n-           and then not Aggr_In_Place\n            and then not Is_Limited_View (T)\n+           and then not Aggr_In_Place\n+           and then Nkind (Exp) /= N_Function_Call\n            and then not For_Special_Return_Object (N)\n          then\n             --  An unchecked conversion is needed in the classwide case because\n@@ -993,7 +997,7 @@ package body Exp_Ch4 is\n          --  component containing the secondary dispatch table of the interface\n          --  type.\n \n-         if Is_Interface (Directly_Designated_Type (PtrT)) then\n+         if Is_Interface (DesigT) then\n             Displace_Allocator_Pointer (N);\n          end if;\n "}, {"sha": "7abf25e3859a8b6992f21fa0bf3f63284002df7b", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -687,7 +687,11 @@ package body Exp_Ch6 is\n       Loc : constant Source_Ptr := Sloc (Exp);\n \n    begin\n+       --  CodePeer does not do anything useful on Ada.Tags.Type_Specific_Data\n+       --  components.\n+\n       if Ada_Version >= Ada_2005\n+        and then not CodePeer_Mode\n         and then Tagged_Type_Expansion\n         and then not Scope_Suppress.Suppress (Accessibility_Check)\n         and then\n@@ -770,20 +774,18 @@ package body Exp_Ch6 is\n                    Attribute_Name => Name_Tag);\n             end if;\n \n-            --  CodePeer does not do anything useful with\n-            --  Ada.Tags.Type_Specific_Data components.\n-\n-            if not CodePeer_Mode then\n-               Insert_Action (Exp,\n-                 Make_Raise_Program_Error (Loc,\n-                   Condition =>\n-                     Make_Op_Gt (Loc,\n-                       Left_Opnd  => Build_Get_Access_Level (Loc, Tag_Node),\n-                       Right_Opnd =>\n-                         Make_Integer_Literal (Loc,\n-                           Scope_Depth (Enclosing_Dynamic_Scope (Func)))),\n-                   Reason    => PE_Accessibility_Check_Failed));\n-            end if;\n+            --  Suppress junk access chacks on RE_Tag_Ptr\n+\n+            Insert_Action (Exp,\n+              Make_Raise_Program_Error (Loc,\n+                Condition =>\n+                  Make_Op_Gt (Loc,\n+                    Left_Opnd  => Build_Get_Access_Level (Loc, Tag_Node),\n+                    Right_Opnd =>\n+                      Make_Integer_Literal (Loc,\n+                        Scope_Depth (Enclosing_Dynamic_Scope (Func)))),\n+                Reason    => PE_Accessibility_Check_Failed),\n+              Suppress => Access_Check);\n          end;\n       end if;\n    end Apply_CW_Accessibility_Check;\n@@ -5131,14 +5133,11 @@ package body Exp_Ch6 is\n \n       --  Another optimization: if the returned value is used to initialize an\n       --  object, then no need to copy/readjust/finalize, we can initialize it\n-      --  in place. However, if the call returns on the secondary stack or this\n-      --  is a special return object, then we need the expansion because we'll\n-      --  be renaming the temporary as the (permanent) object.\n+      --  in place. However, if the call returns on the secondary stack, then\n+      --  we need the expansion because we'll be renaming the temporary as the\n+      --  (permanent) object.\n \n-      if Nkind (Par) = N_Object_Declaration\n-        and then not Use_Sec_Stack\n-        and then not Is_Special_Return_Object (Defining_Entity (Par))\n-      then\n+      if Nkind (Par) = N_Object_Declaration and then not Use_Sec_Stack then\n          return;\n       end if;\n \n@@ -6743,7 +6742,7 @@ package body Exp_Ch6 is\n             null;\n \n          --  Optimize the case where the result is a function call that also\n-         --  returns on the secondary stack. In this case the result is already\n+         --  returns on the secondary stack; in this case the result is already\n          --  on the secondary stack and no further processing is required.\n \n          elsif Exp_Is_Function_Call\n@@ -6779,13 +6778,14 @@ package body Exp_Ch6 is\n          --  gigi is not able to properly allocate class-wide types.\n \n          --  But optimize the case where the result is a function call that\n-         --  also needs finalization. In this case the result can directly be\n+         --  also needs finalization; in this case the result can directly be\n          --  allocated on the secondary stack and no further processing is\n-         --  required.\n+         --  required, unless the returned object is an interface.\n \n          elsif CW_Or_Needs_Finalization (Utyp)\n-           and then not (Exp_Is_Function_Call\n-                          and then Needs_Finalization (Exp_Typ))\n+           and then (Is_Interface (R_Type)\n+                      or else not (Exp_Is_Function_Call\n+                                    and then Needs_Finalization (Exp_Typ)))\n          then\n             declare\n                Acc_Typ : constant Entity_Id := Make_Temporary (Loc, 'A');"}, {"sha": "80c01bf40fd27cd639bb9d7d7ed11fbb076e03b5", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 97, "deletions": 96, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -168,11 +168,6 @@ package body Exp_Util is\n    --  Force evaluation of bounds of a slice, which may be given by a range\n    --  or by a subtype indication with or without a constraint.\n \n-   function Is_Temporary_For_Interface_Object\n-     (Obj_Id : Entity_Id) return Boolean;\n-   --  Determine whether Obj_Id is a temporary created for the handling of a\n-   --  (class-wide) interface object.\n-\n    function Is_Uninitialized_Aggregate\n      (Exp : Node_Id;\n       T   : Entity_Id) return Boolean;\n@@ -5820,7 +5815,6 @@ package body Exp_Util is\n          --  discriminants.\n \n          else\n-            Remove_Side_Effects (Exp);\n             Rewrite (Subtype_Indic,\n               Make_Subtype_From_Expr (Exp, Underlying_Record_View (Unc_Type)));\n          end if;\n@@ -5885,7 +5879,6 @@ package body Exp_Util is\n          end if;\n \n       else\n-         Remove_Side_Effects (Exp);\n          Rewrite (Subtype_Indic,\n            Make_Subtype_From_Expr (Exp, Unc_Type, Related_Id));\n       end if;\n@@ -7193,6 +7186,63 @@ package body Exp_Util is\n       end if;\n    end Has_Access_Constraint;\n \n+   ---------------------\n+   -- Has_Tag_Of_Type --\n+   ---------------------\n+\n+   function Has_Tag_Of_Type (Exp : Node_Id) return Boolean is\n+      Typ : constant Entity_Id := Etype (Exp);\n+\n+   begin\n+      pragma Assert (Is_Tagged_Type (Typ));\n+\n+      --  The tag of an object of a class-wide type is that of its\n+      --  initialization expression.\n+\n+      if Is_Class_Wide_Type (Typ) then\n+         return False;\n+      end if;\n+\n+      --  The tag of a stand-alone object of a specific tagged type T\n+      --  identifies T.\n+\n+      if Is_Entity_Name (Exp)\n+        and then Ekind (Entity (Exp)) in E_Constant | E_Variable\n+      then\n+         return True;\n+\n+      else\n+         case Nkind (Exp) is\n+            --  The tag of a component or an aggregate of a specific tagged\n+            --  type T identifies T.\n+\n+            when N_Indexed_Component\n+              |  N_Selected_Component\n+              |  N_Aggregate\n+            =>\n+               return True;\n+\n+            --  The tag of the result returned by a function whose result\n+            --  type is a specific tagged type T identifies T.\n+\n+            when N_Function_Call =>\n+               return True;\n+\n+            when N_Explicit_Dereference =>\n+               return Is_Captured_Function_Call (Exp);\n+\n+            --  For a tagged type, the operand of a qualified expression\n+            --  shall resolve to be of the type of the expression.\n+\n+            when N_Qualified_Expression =>\n+               return Has_Tag_Of_Type (Expression (Exp));\n+\n+            when others =>\n+               return False;\n+         end case;\n+      end if;\n+   end Has_Tag_Of_Type;\n+\n    --------------------\n    -- Homonym_Number --\n    --------------------\n@@ -8399,6 +8449,23 @@ package body Exp_Util is\n                Search (Name (Ren_Decl));\n             end if;\n \n+            --  For renamings generated by Expand_N_Object_Declaration to deal\n+            --  with (class-wide) interface objects, there is an intermediate\n+            --  temporary of an anonymous access type used to hold the result\n+            --  of the displacement of the address of the renamed object.\n+\n+            if Present (Ren_Obj)\n+              and then Ekind (Ren_Obj) = E_Constant\n+              and then Is_Itype (Etype (Ren_Obj))\n+              and then Ekind (Etype (Ren_Obj)) = E_Anonymous_Access_Type\n+              and then\n+                Is_Class_Wide_Type (Directly_Designated_Type (Etype (Ren_Obj)))\n+              and then\n+                Is_Interface (Directly_Designated_Type (Etype (Ren_Obj)))\n+            then\n+               Search (Constant_Value (Ren_Obj));\n+            end if;\n+\n             return Ren_Obj;\n          end Find_Renamed_Object;\n \n@@ -8640,11 +8707,6 @@ package body Exp_Util is\n \n           and then not Initialized_By_Aliased_BIP_Func_Call (Obj_Id)\n \n-          --  Do not consider temporaries created for (class-wide) interface\n-          --  objects because they must exist as long as the object is around.\n-\n-          and then not Is_Temporary_For_Interface_Object (Obj_Id)\n-\n           --  Do not consider iterators because those are treated as normal\n           --  controlled objects and are processed by the usual finalization\n           --  machinery. This avoids the double finalization of an iterator.\n@@ -9152,24 +9214,6 @@ package body Exp_Util is\n         and then Has_Controlling_Result (Id);\n    end Is_Secondary_Stack_Thunk;\n \n-   ---------------------------------------\n-   -- Is_Temporary_For_Interface_Object --\n-   ---------------------------------------\n-\n-   function Is_Temporary_For_Interface_Object\n-     (Obj_Id : Entity_Id) return Boolean\n-   is\n-      Expr : constant Node_Id := Expression (Declaration_Node (Obj_Id));\n-\n-   begin\n-      --  This must be kept synchronized with Expand_N_Object_Declaration\n-\n-      return Is_Class_Wide_Type (Etype (Obj_Id))\n-        and then Present (Expr)\n-        and then Nkind (Expr) = N_Unchecked_Type_Conversion\n-        and then Is_RTE (Etype (Expression (Expr)), RE_Tag);\n-   end Is_Temporary_For_Interface_Object;\n-\n    --------------------------------\n    -- Is_Uninitialized_Aggregate --\n    --------------------------------\n@@ -9496,67 +9540,13 @@ package body Exp_Util is\n       Root_Utyp   : constant Entity_Id  := Underlying_Type (Root_Typ);\n       List_Def    : constant List_Id    := Empty_List;\n       Comp_List   : constant List_Id    := New_List;\n+\n       Equiv_Type  : Entity_Id;\n       Range_Type  : Entity_Id;\n       Str_Type    : Entity_Id;\n       Constr_Root : Entity_Id;\n+      Size_Attr   : Node_Id;\n       Size_Expr   : Node_Id;\n-      Size_Pref   : Node_Id;\n-\n-      function Has_Tag_Of_Type (Exp : Node_Id) return Boolean;\n-      --  Return True if expression Exp of a tagged type is known to statically\n-      --  have the tag of this tagged type as specified by RM 3.9(19-25).\n-\n-      ---------------------\n-      -- Has_Tag_Of_Type --\n-      ---------------------\n-\n-      function Has_Tag_Of_Type (Exp : Node_Id) return Boolean is\n-         Typ : constant Entity_Id := Etype (Exp);\n-\n-      begin\n-         pragma Assert (Is_Tagged_Type (Typ));\n-\n-         --  The tag of an object of a class-wide type is that of its\n-         --  initialization expression.\n-\n-         if Is_Class_Wide_Type (Typ) then\n-            return False;\n-         end if;\n-\n-         --  The tag of a stand-alone object of a specific tagged type T\n-         --  identifies T.\n-\n-         if Is_Entity_Name (Exp)\n-           and then Ekind (Entity (Exp)) in E_Constant | E_Variable\n-         then\n-            return True;\n-\n-         else\n-            case Nkind (E) is\n-               --  The tag of a component or an aggregate of a specific tagged\n-               --  type T identifies T.\n-\n-               when N_Indexed_Component\n-                 |  N_Selected_Component\n-                 |  N_Aggregate\n-               =>\n-                  return True;\n-\n-               --  The tag of the result returned by a function whose result\n-               --  type is a specific tagged type T identifies T.\n-\n-               when N_Function_Call =>\n-                  return True;\n-\n-               when N_Explicit_Dereference =>\n-                  return Is_Captured_Function_Call (Exp);\n-\n-               when others =>\n-                  return False;\n-            end case;\n-         end if;\n-      end Has_Tag_Of_Type;\n \n    begin\n       --  If the root type is already constrained, there are no discriminants\n@@ -9597,9 +9587,26 @@ package body Exp_Util is\n       --  the _Size primitive operation.\n \n       if Has_Tag_Of_Type (E) then\n-         Size_Pref := Duplicate_Subexpr_No_Checks (E);\n+         if not Has_Discriminants (Etype (E))\n+           or else Is_Constrained (Etype (E))\n+         then\n+            Size_Attr :=\n+              Make_Attribute_Reference (Loc,\n+                Prefix => New_Occurrence_Of (Etype (E), Loc),\n+                Attribute_Name => Name_Object_Size);\n+\n+         else\n+            Size_Attr :=\n+              Make_Attribute_Reference (Loc,\n+                Prefix => Duplicate_Subexpr_No_Checks (E),\n+                Attribute_Name => Name_Size);\n+         end if;\n+\n       else\n-         Size_Pref := OK_Convert_To (T, Duplicate_Subexpr_No_Checks (E));\n+         Size_Attr :=\n+           Make_Attribute_Reference (Loc,\n+             Prefix => OK_Convert_To (T, Duplicate_Subexpr_No_Checks (E)),\n+             Attribute_Name => Name_Size);\n       end if;\n \n       if not Is_Interface (Root_Typ) then\n@@ -9610,10 +9617,7 @@ package body Exp_Util is\n \n          Size_Expr :=\n            Make_Op_Subtract (Loc,\n-             Left_Opnd =>\n-               Make_Attribute_Reference (Loc,\n-                 Prefix => Size_Pref,\n-                 Attribute_Name => Name_Size),\n+             Left_Opnd => Size_Attr,\n              Right_Opnd =>\n                Make_Attribute_Reference (Loc,\n                  Prefix => New_Occurrence_Of (Constr_Root, Loc),\n@@ -9625,10 +9629,7 @@ package body Exp_Util is\n \n          Size_Expr :=\n            Make_Op_Subtract (Loc,\n-             Left_Opnd =>\n-               Make_Attribute_Reference (Loc,\n-                 Prefix => Size_Pref,\n-                 Attribute_Name => Name_Size),\n+             Left_Opnd => Size_Attr,\n              Right_Opnd =>\n                Make_Attribute_Reference (Loc,\n                  Prefix => New_Occurrence_Of (RTE (RE_Tag), Loc),"}, {"sha": "3dd10d77cea4a5401950b28c698a2ea46c0c9195", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -732,6 +732,10 @@ package Exp_Util is\n    function Has_Access_Constraint (E : Entity_Id) return Boolean;\n    --  Given object or type E, determine if a discriminant is of an access type\n \n+   function Has_Tag_Of_Type (Exp : Node_Id) return Boolean;\n+   --  Return True if expression Exp of a tagged type is known to statically\n+   --  have the tag of this tagged type as specified by RM 3.9(19-25).\n+\n    function Homonym_Number (Subp : Entity_Id) return Pos;\n    --  Here subp is the entity for a subprogram. This routine returns the\n    --  homonym number used to disambiguate overloaded subprograms in the same"}, {"sha": "9507f2f0920319539a34dceb6dc3e3ee5013708b", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1,7 +1,5 @@\n # Top level -*- makefile -*- fragment for GNU Ada (GNAT).\n-#   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-#   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013\n-#   Free Software Foundation, Inc.\n+# Copyright (C) 2009-2023 Free Software Foundation, Inc.\n \n #This file is part of GCC.\n "}, {"sha": "da6a56fcec816466ae86a1ae15d4074bc707c4d3", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1,5 +1,5 @@\n # Makefile for GNU Ada Compiler (GNAT).\n-#   Copyright (C) 1994-2018 Free Software Foundation, Inc.\n+#   Copyright (C) 1994-2023 Free Software Foundation, Inc.\n \n #This file is part of GCC.\n "}, {"sha": "b8925f5c90b55f63b6744fbb3d90a7f81316e42a", "filename": "gcc/ada/gcc-interface/ada-builtin-types.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Fada-builtin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Fada-builtin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-builtin-types.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1,7 +1,7 @@\n /* This file contains the type definitions for the builtins exclusively\n    used in the GNU Ada compiler.\n \n-   Copyright (C) 2019-2022 Free Software Foundation, Inc.\n+   Copyright (C) 2019-2023 Free Software Foundation, Inc.\n \n This file is part of GCC.\n "}, {"sha": "cf3d6a1327334a1ae92972e2368de1b72660aa8d", "filename": "gcc/ada/gcc-interface/ada-builtins.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Fada-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Fada-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-builtins.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1,7 +1,7 @@\n /* This file contains the definitions for the builtins exclusively used\n    in the GNU Ada compiler.\n \n-   Copyright (C) 2019-2022 Free Software Foundation, Inc.\n+   Copyright (C) 2019-2023 Free Software Foundation, Inc.\n \n This file is part of GCC.\n "}, {"sha": "ff88e54793f55f0f7f6eb8d597098b5d45824db4", "filename": "gcc/ada/gcc-interface/ada-tree.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Fada-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Fada-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              Specification                               *\n  *                                                                          *\n- *            Copyright (C) 1992-2009, Free Software Foundation, Inc.       *\n+ *            Copyright (C) 1992-2023, Free Software Foundation, Inc.       *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *"}, {"sha": "d0acf1de8f3debe12a8e1228397245f2958aefde", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2022, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2023, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *"}, {"sha": "45b5bd937c194b85e8384cc181568ac6b7c23923", "filename": "gcc/ada/gcc-interface/ada.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Fada.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Fada.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2022, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2023, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *"}, {"sha": "85c1f42d8f1fccf3223ea4945d70440f43a7b363", "filename": "gcc/ada/gcc-interface/config-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fconfig-lang.in?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1,5 +1,5 @@\n # Top level configure fragment for GNU Ada (GNAT).\n-#   Copyright (C) 1994-2013 Free Software Foundation, Inc.\n+#   Copyright (C) 1994-2023 Free Software Foundation, Inc.\n \n #This file is part of GCC.\n "}, {"sha": "117d4172be59fdcd8ae3822030f496cd0b164876", "filename": "gcc/ada/gcc-interface/cuintp.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Fcuintp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Fcuintp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fcuintp.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2021, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2023, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *"}, {"sha": "d24adf33601cee00690766779829265843dcf3f2", "filename": "gcc/ada/gcc-interface/decl.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2022, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2023, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *"}, {"sha": "5dccab660180066ce709794a057c265d28d5e1f6", "filename": "gcc/ada/gcc-interface/gadaint.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Fgadaint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Fgadaint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgadaint.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *           Copyright (C) 2010-2022, Free Software Foundation, Inc.        *\n+ *           Copyright (C) 2010-2023, Free Software Foundation, Inc.        *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *"}, {"sha": "fee0450a3381384901ced5cbb4b85a91d413adb7", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2022, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2023, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *"}, {"sha": "92d311a3a6868e0677bf4760014d47f3115bf88f", "filename": "gcc/ada/gcc-interface/lang-specs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Flang-specs.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *           Copyright (C) 1992-2022, Free Software Foundation, Inc.        *\n+ *           Copyright (C) 1992-2023, Free Software Foundation, Inc.        *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *"}, {"sha": "248bb4ce919a1881266f86a9e0e2f292e43e3a20", "filename": "gcc/ada/gcc-interface/lang.opt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Flang.opt?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1,5 +1,5 @@\n ; Options for the Ada front end.\n-; Copyright (C) 2003-2015 Free Software Foundation, Inc.\n+; Copyright (C) 2003-2023 Free Software Foundation, Inc.\n ;\n ; This file is part of GCC.\n ;"}, {"sha": "b18ca8c7d8844845b5b8f0b49cbee84d22da03f3", "filename": "gcc/ada/gcc-interface/misc.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Fmisc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Fmisc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                           C Implementation File                          *\n  *                                                                          *\n- *          Copyright (C) 1992-2021, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2023, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *"}, {"sha": "5fc8e865098682c85af3946d80fe20b07ac2c1a5", "filename": "gcc/ada/gcc-interface/system.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Fsystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Fsystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fsystem.ads?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -7,7 +7,7 @@\n --                                 S p e c                                  --\n --                            (Compiler Version)                            --\n --                                                                          --\n---          Copyright (C) 1992-2021, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2023, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --"}, {"sha": "c3f91c44fc329e87450471878782231371b537e5", "filename": "gcc/ada/gcc-interface/targtyps.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Ftargtyps.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Ftargtyps.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftargtyps.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2021, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2023, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *"}, {"sha": "28e3867d1426d0bf51a8a532e766beb1c69a1e8e", "filename": "gcc/ada/gcc-interface/trans.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Ftrans.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Ftrans.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2022, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2023, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *"}, {"sha": "392ec0b7f4eacf3aabeab9fe26cf6e9df0bb04a1", "filename": "gcc/ada/gcc-interface/utils.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Futils.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Futils.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2022, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2023, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *"}, {"sha": "6c17675f48889b4296877fc822e4e87c68352f40", "filename": "gcc/ada/gcc-interface/utils2.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Futils2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fada%2Fgcc-interface%2Futils2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2022, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2023, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *"}, {"sha": "f8b439ed3ee39bdcab9a07d8ab06b3163002adc9", "filename": "gcc/analyzer/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fanalyzer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fanalyzer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2FChangeLog?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1,3 +1,65 @@\n+2023-01-26  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR analyzer/108524\n+\t* analyzer.h (class feasible_node): New forward decl.\n+\t* diagnostic-manager.cc (epath_finder::get_best_epath): Add \"pd\"\n+\tparam.\n+\t(epath_finder::explore_feasible_paths): Likewise.\n+\t(epath_finder::process_worklist_item): Likewise.  Use it to call\n+\tpending_diagnostic::check_valid_fpath_p on the final fpath to\n+\tgive pending_diagnostic a way to add additional restrictions on\n+\tfeasibility.\n+\t(saved_diagnostic::calc_best_epath): Pass pending_diagnostic to\n+\tepath_finder::get_best_epath.\n+\t* infinite-recursion.cc: Include \"analyzer/feasible-graph.h\".\n+\t(infinite_recursion_diagnostic::check_valid_fpath_p): New.\n+\t(infinite_recursion_diagnostic::fedge_uses_conjured_svalue_p): New.\n+\t(infinite_recursion_diagnostic::expr_uses_conjured_svalue_p): New.\n+\t* pending-diagnostic.h (pending_diagnostic::check_valid_fpath_p):\n+\tNew vfunc.\n+\n+2023-01-19  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR analyzer/108455\n+\t* analyzer.h (class checker_event): New forward decl.\n+\t(class state_change_event): Indent.\n+\t(class warning_event): New forward decl.\n+\t* checker-event.cc (state_change_event::state_change_event): Add\n+\t\"enode\" param.\n+\t(warning_event::get_desc): Update for new param of\n+\tevdesc::final_event ctor.\n+\t* checker-event.h (state_change_event::state_change_event): Add\n+\t\"enode\" param.\n+\t(state_change_event::get_exploded_node): New accessor.\n+\t(state_change_event::m_enode): New field.\n+\t(warning_event::warning_event): New \"enode\" param.\n+\t(warning_event::get_exploded_node): New accessor.\n+\t(warning_event::m_enode): New field.\n+\t* diagnostic-manager.cc\n+\t(state_change_event_creator::on_global_state_change): Pass\n+\tsrc_node to state_change_event ctor.\n+\t(state_change_event_creator::on_state_change): Likewise.\n+\t(null_assignment_sm_context::set_next_state): Pass NULL for\n+\tnew param of state_change_event ctor.\n+\t* infinite-recursion.cc\n+\t(infinite_recursion_diagnostic::add_final_event): Update for new\n+\tparam of warning_event ctor.\n+\t* pending-diagnostic.cc (pending_diagnostic::add_final_event):\n+\tPass enode to warning_event ctor.\n+\t* pending-diagnostic.h (evdesc::final_event): Add reference to\n+\twarning_event.\n+\t* sm-malloc.cc: Include \"analyzer/checker-event.h\" and\n+\t\"analyzer/exploded-graph.h\".\n+\t(deref_before_check::deref_before_check): Initialize new fields.\n+\t(deref_before_check::emit): Reject warnings in which we were\n+\tunable to determine the enodes of the dereference and the check.\n+\tReject warnings interprocedural warnings. Reject warnings in which\n+\tthe dereference doesn't dominate the check.\n+\t(deref_before_check::describe_state_change): Set m_deref_enode.\n+\t(deref_before_check::describe_final_event): Set m_check_enode.\n+\t(deref_before_check::m_deref_enode): New field.\n+\t(deref_before_check::m_check_enode): New field.\n+\n 2023-01-13  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR analyzer/105273"}, {"sha": "a1619525afaf9322f1ef6d6ec387d6eea70f7c0f", "filename": "gcc/analyzer/analyzer.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -93,7 +93,9 @@ class bounded_ranges_manager;\n class pending_diagnostic;\n class pending_note;\n struct event_loc_info;\n-class state_change_event;\n+class checker_event;\n+  class state_change_event;\n+  class warning_event;\n class checker_path;\n class extrinsic_state;\n class sm_state_map;\n@@ -124,6 +126,8 @@ class call_summary_replay;\n struct per_function_data;\n struct interesting_t;\n \n+class feasible_node;\n+\n /* Forward decls of functions.  */\n \n extern void dump_tree (pretty_printer *pp, tree t);"}, {"sha": "3612df7bd1d36914cf5f00a0c0e3f87a503a5290", "filename": "gcc/analyzer/checker-event.cc", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fanalyzer%2Fchecker-event.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fanalyzer%2Fchecker-event.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-event.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -410,15 +410,17 @@ state_change_event::state_change_event (const supernode *node,\n \t\t\t\t\tstate_machine::state_t from,\n \t\t\t\t\tstate_machine::state_t to,\n \t\t\t\t\tconst svalue *origin,\n-\t\t\t\t\tconst program_state &dst_state)\n+\t\t\t\t\tconst program_state &dst_state,\n+\t\t\t\t\tconst exploded_node *enode)\n : checker_event (EK_STATE_CHANGE,\n \t\t event_loc_info (stmt->location,\n \t\t\t\t node->m_fun->decl,\n \t\t\t\t stack_depth)),\n   m_node (node), m_stmt (stmt), m_sm (sm),\n   m_sval (sval), m_from (from), m_to (to),\n   m_origin (origin),\n-  m_dst_state (dst_state)\n+  m_dst_state (dst_state),\n+  m_enode (enode)\n {\n }\n \n@@ -1159,7 +1161,7 @@ warning_event::get_desc (bool can_colorize) const\n       tree var = fixup_tree_for_diagnostic (m_var);\n       label_text ev_desc\n \t= m_pending_diagnostic->describe_final_event\n-\t    (evdesc::final_event (can_colorize, var, m_state));\n+\t    (evdesc::final_event (can_colorize, var, m_state, *this));\n       if (ev_desc.get ())\n \t{\n \t  if (m_sm && flag_analyzer_verbose_state_changes)"}, {"sha": "5dd25cb0775e62222d485cf5f573827b418ca72c", "filename": "gcc/analyzer/checker-event.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fanalyzer%2Fchecker-event.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fanalyzer%2Fchecker-event.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-event.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -357,7 +357,8 @@ class state_change_event : public checker_event\n \t\t      state_machine::state_t from,\n \t\t      state_machine::state_t to,\n \t\t      const svalue *origin,\n-\t\t      const program_state &dst_state);\n+\t\t      const program_state &dst_state,\n+\t\t      const exploded_node *enode);\n \n   label_text get_desc (bool can_colorize) const final override;\n   meaning get_meaning () const override;\n@@ -367,6 +368,8 @@ class state_change_event : public checker_event\n     return m_dst_state.get_current_function ();\n   }\n \n+  const exploded_node *get_exploded_node () const { return m_enode; }\n+\n   const supernode *m_node;\n   const gimple *m_stmt;\n   const state_machine &m_sm;\n@@ -375,6 +378,7 @@ class state_change_event : public checker_event\n   state_machine::state_t m_to;\n   const svalue *m_origin;\n   program_state m_dst_state;\n+  const exploded_node *m_enode;\n };\n \n /* Subclass of checker_event; parent class for subclasses that relate to\n@@ -668,17 +672,22 @@ class warning_event : public checker_event\n {\n public:\n   warning_event (const event_loc_info &loc_info,\n+\t\t const exploded_node *enode,\n \t\t const state_machine *sm,\n \t\t tree var, state_machine::state_t state)\n   : checker_event (EK_WARNING, loc_info),\n+    m_enode (enode),\n     m_sm (sm), m_var (var), m_state (state)\n   {\n   }\n \n   label_text get_desc (bool can_colorize) const final override;\n   meaning get_meaning () const override;\n \n+  const exploded_node *get_exploded_node () const { return m_enode; }\n+\n private:\n+  const exploded_node *m_enode;\n   const state_machine *m_sm;\n   tree m_var;\n   state_machine::state_t m_state;"}, {"sha": "4f036a6c28aa4996832a2ae5b198f8a7bfbaa424", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -88,6 +88,7 @@ class epath_finder\n \n   std::unique_ptr<exploded_path>\n   get_best_epath (const exploded_node *target_enode,\n+\t\t  const pending_diagnostic &pd,\n \t\t  const char *desc, unsigned diag_idx,\n \t\t  std::unique_ptr<feasibility_problem> *out_problem);\n \n@@ -96,12 +97,14 @@ class epath_finder\n \n   std::unique_ptr<exploded_path>\n   explore_feasible_paths (const exploded_node *target_enode,\n+\t\t\t  const pending_diagnostic &pd,\n \t\t\t  const char *desc, unsigned diag_idx);\n   bool\n   process_worklist_item (feasible_worklist *worklist,\n \t\t\t const trimmed_graph &tg,\n \t\t\t feasible_graph *fg,\n \t\t\t const exploded_node *target_enode,\n+\t\t\t const pending_diagnostic &pd,\n \t\t\t unsigned diag_idx,\n \t\t\t std::unique_ptr<exploded_path> *out_best_path) const;\n   void dump_trimmed_graph (const exploded_node *target_enode,\n@@ -138,6 +141,7 @@ class epath_finder\n \n std::unique_ptr<exploded_path>\n epath_finder::get_best_epath (const exploded_node *enode,\n+\t\t\t      const pending_diagnostic &pd,\n \t\t\t      const char *desc, unsigned diag_idx,\n \t\t\t      std::unique_ptr<feasibility_problem> *out_problem)\n {\n@@ -161,7 +165,7 @@ epath_finder::get_best_epath (const exploded_node *enode,\n       if (logger)\n \tlogger->log (\"trying to find shortest feasible path\");\n       if (std::unique_ptr<exploded_path> epath\n-\t    = explore_feasible_paths (enode, desc, diag_idx))\n+\t    = explore_feasible_paths (enode, pd, desc, diag_idx))\n \t{\n \t  if (logger)\n \t    logger->log (\"accepting %qs at EN: %i, SN: %i (sd: %i)\"\n@@ -374,6 +378,7 @@ class auto_checking_feasibility\n \n std::unique_ptr<exploded_path>\n epath_finder::explore_feasible_paths (const exploded_node *target_enode,\n+\t\t\t\t      const pending_diagnostic &pd,\n \t\t\t\t      const char *desc, unsigned diag_idx)\n {\n   logger *logger = get_logger ();\n@@ -415,8 +420,8 @@ epath_finder::explore_feasible_paths (const exploded_node *target_enode,\n   {\n     auto_checking_feasibility sentinel (mgr);\n \n-    while (process_worklist_item (&worklist, tg, &fg, target_enode, diag_idx,\n-\t\t\t\t  &best_path))\n+    while (process_worklist_item (&worklist, tg, &fg, target_enode, pd,\n+\t\t\t\t  diag_idx, &best_path))\n       {\n \t/* Empty; the work is done within process_worklist_item.  */\n       }\n@@ -449,14 +454,18 @@ epath_finder::explore_feasible_paths (const exploded_node *target_enode,\n    Return false if the processing of the worklist should stop\n    (either due to reaching TARGET_ENODE, or hitting a limit).\n    Write to *OUT_BEST_PATH if stopping due to finding a feasible path\n-   to TARGET_ENODE.  */\n+   to TARGET_ENODE.\n+   Use PD to provide additional restrictions on feasibility of\n+   the final path in the feasible_graph before converting to\n+   an exploded_path.  */\n \n bool\n epath_finder::\n process_worklist_item (feasible_worklist *worklist,\n \t\t       const trimmed_graph &tg,\n \t\t       feasible_graph *fg,\n \t\t       const exploded_node *target_enode,\n+\t\t       const pending_diagnostic &pd,\n \t\t       unsigned diag_idx,\n \t\t       std::unique_ptr<exploded_path> *out_best_path) const\n {\n@@ -514,6 +523,13 @@ process_worklist_item (feasible_worklist *worklist,\n \t\t\t     \" (length: %i)\",\n \t\t\t     target_enode->m_index, diag_idx,\n \t\t\t     succ_fnode->get_path_length ());\n+\t      if (!pd.check_valid_fpath_p (succ_fnode))\n+\t\t{\n+\t\t  if (logger)\n+\t\t    logger->log (\"rejecting feasible path due to\"\n+\t\t\t\t \" pending_diagnostic\");\n+\t\t  return false;\n+\t\t}\n \t      *out_best_path = fg->make_epath (succ_fnode);\n \t      if (flag_dump_analyzer_feasibility)\n \t\tdump_feasible_path (target_enode, diag_idx, *fg, *succ_fnode);\n@@ -808,7 +824,7 @@ saved_diagnostic::calc_best_epath (epath_finder *pf)\n   LOG_SCOPE (logger);\n   m_problem = NULL;\n \n-  m_best_epath = pf->get_best_epath (m_enode, m_d->get_kind (), m_idx,\n+  m_best_epath = pf->get_best_epath (m_enode, *m_d, m_d->get_kind (), m_idx,\n \t\t\t\t     &m_problem);\n \n   /* Handle failure to find a feasible path.  */\n@@ -1572,7 +1588,8 @@ class state_change_event_creator : public state_change_visitor\n \t\t\t\t\tsrc_sm_val,\n \t\t\t\t\tdst_sm_val,\n \t\t\t\t\tNULL,\n-\t\t\t\t\tdst_state));\n+\t\t\t\t\tdst_state,\n+\t\t\t\t\tsrc_node));\n     return false;\n   }\n \n@@ -1616,7 +1633,8 @@ class state_change_event_creator : public state_change_visitor\n \t\t\t\t\tsrc_sm_val,\n \t\t\t\t\tdst_sm_val,\n \t\t\t\t\tdst_origin_sval,\n-\t\t\t\t\tdst_state));\n+\t\t\t\t\tdst_state,\n+\t\t\t\t\tsrc_node));\n     return false;\n   }\n \n@@ -1760,7 +1778,8 @@ struct null_assignment_sm_context : public sm_context\n \t\t\t\t\tvar_new_sval,\n \t\t\t\t\tfrom, to,\n \t\t\t\t\tNULL,\n-\t\t\t\t\t*m_new_state));\n+\t\t\t\t\t*m_new_state,\n+\t\t\t\t\tNULL));\n   }\n \n   void set_next_state (const gimple *stmt,\n@@ -1785,7 +1804,8 @@ struct null_assignment_sm_context : public sm_context\n \t\t\t\t\tsval,\n \t\t\t\t\tfrom, to,\n \t\t\t\t\tNULL,\n-\t\t\t\t\t*m_new_state));\n+\t\t\t\t\t*m_new_state,\n+\t\t\t\t\tNULL));\n   }\n \n   void warn (const supernode *, const gimple *,"}, {"sha": "8d101d14fd0034f3b235b60b4eba850bf6eb5f70", "filename": "gcc/analyzer/infinite-recursion.cc", "status": "modified", "additions": 102, "deletions": 1, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fanalyzer%2Finfinite-recursion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fanalyzer%2Finfinite-recursion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Finfinite-recursion.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -62,6 +62,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/exploded-graph.h\"\n #include \"make-unique.h\"\n #include \"analyzer/checker-path.h\"\n+#include \"analyzer/feasible-graph.h\"\n \n /* A subclass of pending_diagnostic for complaining about suspected\n    infinite recursion.  */\n@@ -182,7 +183,7 @@ class infinite_recursion_diagnostic\n   /* Customize the location where the warning_event appears, putting\n      it at the topmost entrypoint to the function.  */\n   void add_final_event (const state_machine *,\n-\t\t\tconst exploded_node *,\n+\t\t\tconst exploded_node *enode,\n \t\t\tconst gimple *,\n \t\t\ttree,\n \t\t\tstate_machine::state_t,\n@@ -195,10 +196,110 @@ class infinite_recursion_diagnostic\n \t\t\t  ()->get_start_location (),\n \t\t\tm_callee_fndecl,\n \t\t\tm_new_entry_enode->get_stack_depth ()),\n+\tenode,\n \tNULL, NULL, NULL));\n   }\n \n+  /* Reject paths in which conjured svalues have affected control flow\n+     since m_prev_entry_enode.  */\n+\n+  bool check_valid_fpath_p (const feasible_node *final_fnode)\n+    const final override\n+  {\n+    /* Reject paths in which calls with unknown side effects have occurred\n+       since m_prev_entry_enode.\n+       Find num calls with side effects.  Walk backward until we reach the\n+       pref */\n+    gcc_assert (final_fnode->get_inner_node () == m_new_entry_enode);\n+\n+    /* FG is actually a tree.  Walk backwards from FINAL_FNODE until we\n+       reach the prev_entry_enode (or the origin).  */\n+    const feasible_node *iter_fnode = final_fnode;\n+    while (iter_fnode->get_inner_node ()->m_index != 0)\n+      {\n+\tgcc_assert (iter_fnode->m_preds.length () == 1);\n+\n+\tfeasible_edge *pred_fedge\n+\t  = static_cast <feasible_edge *> (iter_fnode->m_preds[0]);\n+\n+\t/* Determine if conjured svalues have affected control flow\n+\t   since the prev entry node.  */\n+\tif (fedge_uses_conjured_svalue_p (pred_fedge))\n+\t  /* If so, then reject this diagnostic.  */\n+\t  return false;\n+\titer_fnode = static_cast <feasible_node *> (pred_fedge->m_src);\n+\tif (iter_fnode->get_inner_node () == m_prev_entry_enode)\n+\t  /* Accept this diagnostic.  */\n+\t  return true;\n+    }\n+\n+    /* We shouldn't get here; if we do, reject the diagnostic.  */\n+    gcc_unreachable ();\n+    return false;\n+  }\n+\n private:\n+  /* Return true iff control flow along FEDGE was affected by\n+     a conjured_svalue.  */\n+  static bool fedge_uses_conjured_svalue_p (feasible_edge *fedge)\n+  {\n+    const exploded_edge *eedge = fedge->get_inner_edge ();\n+    const superedge *sedge = eedge->m_sedge;\n+    if (!sedge)\n+      return false;\n+    const cfg_superedge *cfg_sedge = sedge->dyn_cast_cfg_superedge ();\n+    if (!cfg_sedge)\n+      return false;\n+    const gimple *last_stmt = sedge->m_src->get_last_stmt ();\n+    if (!last_stmt)\n+      return false;\n+\n+    const feasible_node *dst_fnode\n+      = static_cast<const feasible_node *> (fedge->m_dest);\n+    const region_model &model = dst_fnode->get_state ().get_model ();\n+\n+    if (const gcond *cond_stmt = dyn_cast <const gcond *> (last_stmt))\n+      {\n+\tif (expr_uses_conjured_svalue_p (model, gimple_cond_lhs (cond_stmt)))\n+\t  return true;\n+\tif (expr_uses_conjured_svalue_p (model, gimple_cond_rhs (cond_stmt)))\n+\t  return true;\n+      }\n+    else if (const gswitch *switch_stmt\n+\t       = dyn_cast <const gswitch *> (last_stmt))\n+      {\n+\tif (expr_uses_conjured_svalue_p (model,\n+\t\t\t\t\t gimple_switch_index (switch_stmt)))\n+\t  return true;\n+      }\n+    return false;\n+  }\n+\n+  /* Return true iff EXPR is affected by a conjured_svalue.  */\n+  static bool expr_uses_conjured_svalue_p (const region_model &model,\n+\t\t\t\t\t   tree expr)\n+  {\n+    class conjured_svalue_finder : public visitor\n+    {\n+    public:\n+      conjured_svalue_finder () : m_found_conjured_svalues (false)\n+      {\n+      }\n+      void\n+      visit_conjured_svalue (const conjured_svalue *) final override\n+      {\n+\tm_found_conjured_svalues = true;\n+      }\n+\n+      bool m_found_conjured_svalues;\n+    };\n+\n+    const svalue *sval = model.get_rvalue (expr, NULL);\n+    conjured_svalue_finder v;\n+    sval->accept (&v);\n+    return v.m_found_conjured_svalues;\n+  }\n+\n   const exploded_node *m_prev_entry_enode;\n   const exploded_node *m_new_entry_enode;\n   tree m_callee_fndecl;"}, {"sha": "79e6c5528ebcd8ba54db35bbad2bf701c294aced", "filename": "gcc/analyzer/pending-diagnostic.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fanalyzer%2Fpending-diagnostic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fanalyzer%2Fpending-diagnostic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fpending-diagnostic.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -232,6 +232,7 @@ pending_diagnostic::add_final_event (const state_machine *sm,\n      (event_loc_info (get_stmt_location (stmt, enode->get_function ()),\n \t\t      enode->get_function ()->decl,\n \t\t      enode->get_stack_depth ()),\n+      enode,\n       sm, var, state));\n }\n "}, {"sha": "b919d5b9099192b901e7cc278d994dee870175b9", "filename": "gcc/analyzer/pending-diagnostic.h", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fanalyzer%2Fpending-diagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fanalyzer%2Fpending-diagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fpending-diagnostic.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -131,13 +131,15 @@ struct return_of_state : public event_desc\n struct final_event : public event_desc\n {\n   final_event (bool colorize,\n-\t       tree expr, state_machine::state_t state)\n+\t       tree expr, state_machine::state_t state,\n+\t       const warning_event &event)\n   : event_desc (colorize),\n-    m_expr (expr), m_state (state)\n+    m_expr (expr), m_state (state), m_event (event)\n   {}\n \n   tree m_expr;\n   state_machine::state_t m_state;\n+  const warning_event &m_event;\n };\n \n } /* end of namespace evdesc */\n@@ -345,6 +347,15 @@ class pending_diagnostic\n   {\n     /* Default no-op implementation.  */\n   }\n+\n+  /* Vfunc to give diagnostic subclasses the opportunity to reject diagnostics\n+     by imposing their own additional feasibility checks on the path to a\n+     given feasible_node.  */\n+  virtual bool check_valid_fpath_p (const feasible_node *) const\n+  {\n+    /* Default implementation: accept this path.  */\n+    return true;\n+  }\n };\n \n /* A template to make it easier to make subclasses of pending_diagnostic."}, {"sha": "9aee810f818b4c744bc97c0ec2abe6ae6ee32d13", "filename": "gcc/analyzer/sm-malloc.cc", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fanalyzer%2Fsm-malloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fanalyzer%2Fsm-malloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-malloc.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -45,6 +45,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"attribs.h\"\n #include \"analyzer/function-set.h\"\n #include \"analyzer/program-state.h\"\n+#include \"analyzer/checker-event.h\"\n+#include \"analyzer/exploded-graph.h\"\n \n #if ENABLE_ANALYZER\n \n@@ -1490,7 +1492,9 @@ class deref_before_check : public malloc_diagnostic\n {\n public:\n   deref_before_check (const malloc_state_machine &sm, tree arg)\n-  : malloc_diagnostic (sm, arg)\n+  : malloc_diagnostic (sm, arg),\n+    m_deref_enode (NULL),\n+    m_check_enode (NULL)\n   {}\n \n   const char *get_kind () const final override { return \"deref_before_check\"; }\n@@ -1502,6 +1506,31 @@ class deref_before_check : public malloc_diagnostic\n \n   bool emit (rich_location *rich_loc) final override\n   {\n+    /* Don't emit the warning if we can't show where the deref\n+       and the check occur.  */\n+    if (!m_deref_enode)\n+      return false;\n+    if (!m_check_enode)\n+      return false;\n+    /* Only emit the warning for intraprocedural cases.  */\n+    if (m_deref_enode->get_function () != m_check_enode->get_function ())\n+      return false;\n+    if (&m_deref_enode->get_point ().get_call_string ()\n+\t!= &m_check_enode->get_point ().get_call_string ())\n+      return false;\n+\n+    /* Reject the warning if the deref's BB doesn't dominate that\n+       of the check, so that we don't warn e.g. for shared cleanup\n+       code that checks a pointer for NULL, when that code is sometimes\n+       used before a deref and sometimes after.\n+       Using the dominance code requires setting cfun.  */\n+    auto_cfun sentinel (m_deref_enode->get_function ());\n+    calculate_dominance_info (CDI_DOMINATORS);\n+    if (!dominated_by_p (CDI_DOMINATORS,\n+\t\t\t m_check_enode->get_supernode ()->m_bb,\n+\t\t\t m_deref_enode->get_supernode ()->m_bb))\n+      return false;\n+\n     if (m_arg)\n       return warning_at (rich_loc, get_controlling_option (),\n \t\t\t \"check of %qE for NULL after already\"\n@@ -1520,6 +1549,7 @@ class deref_before_check : public malloc_diagnostic\n \t&& assumed_non_null_p (change.m_new_state))\n       {\n \tm_first_deref_event = change.m_event_id;\n+\tm_deref_enode = change.m_event.get_exploded_node ();\n \tif (m_arg)\n \t  return change.formatted_print (\"pointer %qE is dereferenced here\",\n \t\t\t\t\t m_arg);\n@@ -1531,6 +1561,7 @@ class deref_before_check : public malloc_diagnostic\n \n   label_text describe_final_event (const evdesc::final_event &ev) final override\n   {\n+    m_check_enode = ev.m_event.get_exploded_node ();\n     if (m_first_deref_event.known_p ())\n       {\n \tif (m_arg)\n@@ -1556,6 +1587,8 @@ class deref_before_check : public malloc_diagnostic\n \n private:\n   diagnostic_event_id_t m_first_deref_event;\n+  const exploded_node *m_deref_enode;\n+  const exploded_node *m_check_enode;\n };\n \n /* struct allocation_state : public state_machine::state.  */"}, {"sha": "615d5426a340c3a6ab736db0e33eeba570088022", "filename": "gcc/bb-reorder.cc", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fbb-reorder.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fbb-reorder.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1998,6 +1998,7 @@ fix_up_fall_thru_edges (void)\n \t\t     becomes EDGE_CROSSING.  */\n \n \t\t  fall_thru->flags &= ~EDGE_CROSSING;\n+\t\t  unsigned old_count = EDGE_COUNT (cur_bb->succs);\n \t\t  basic_block new_bb = force_nonfallthru (fall_thru);\n \n \t\t  if (new_bb)\n@@ -2009,7 +2010,25 @@ fix_up_fall_thru_edges (void)\n \t\t      gcc_assert (BB_PARTITION (new_bb)\n                                   == BB_PARTITION (cur_bb));\n \n-\t\t      single_succ_edge (new_bb)->flags |= EDGE_CROSSING;\n+\t\t      edge e = single_succ_edge (new_bb);\n+\t\t      e->flags |= EDGE_CROSSING;\n+\t\t      if (EDGE_COUNT (cur_bb->succs) > old_count)\n+\t\t\t{\n+\t\t\t  /* If asm goto has a crossing fallthrough edge\n+\t\t\t     and at least one of the labels to the same bb,\n+\t\t\t     force_nonfallthru can result in the fallthrough\n+\t\t\t     edge being redirected and a new edge added for the\n+\t\t\t     label or more labels to e->dest.  As we've\n+\t\t\t     temporarily cleared EDGE_CROSSING flag on the\n+\t\t\t     fallthrough edge, we need to restore it again.\n+\t\t\t     See PR108596.  */\n+\t\t\t  rtx_insn *j = BB_END (cur_bb);\n+\t\t\t  gcc_checking_assert (JUMP_P (j)\n+\t\t\t\t\t       && asm_noperands (PATTERN (j)));\n+\t\t\t  edge e2 = find_edge (cur_bb, e->dest);\n+\t\t\t  if (e2)\n+\t\t\t    e2->flags |= EDGE_CROSSING;\n+\t\t\t}\n \t\t    }\n \t\t  else\n \t\t    {"}, {"sha": "76b750325284bf51c8daad377d7f0585c0260975", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1,3 +1,13 @@\n+2023-01-26  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/105300\n+\t* c-pragma.cc (handle_pragma_message): Warn for CPP_STRING_USERDEF.\n+\n+2023-01-18  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c/108424\n+\t* c-common.cc (check_case_value): Check INTEGRAL_TYPE_P.\n+\n 2023-01-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/108365"}, {"sha": "ae92cd5adaf5e86d6b4e52b73fada7bc7561db6c", "filename": "gcc/c-family/c-common.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fc-family%2Fc-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fc-family%2Fc-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -2238,7 +2238,8 @@ check_case_value (location_t loc, tree value)\n   if (value == NULL_TREE)\n     return value;\n \n-  if (TREE_CODE (value) == INTEGER_CST)\n+  if (INTEGRAL_TYPE_P (TREE_TYPE (value))\n+      && TREE_CODE (value) == INTEGER_CST)\n     /* Promote char or short to int.  */\n     value = perform_integral_promotions (value);\n   else if (value != error_mark_node)"}, {"sha": "0d2b333cebbed32423d5dc6fd2a3ac0ce0bf8b94", "filename": "gcc/c-family/c-pragma.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fc-family%2Fc-pragma.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fc-family%2Fc-pragma.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1390,6 +1390,9 @@ handle_pragma_message (cpp_reader *)\n     }\n   else if (token == CPP_STRING)\n     message = x;\n+  else if (token == CPP_STRING_USERDEF)\n+    GCC_BAD (\"string literal with user-defined suffix is invalid in this \"\n+\t     \"context\");\n   else\n     GCC_BAD (\"expected a string after %<#pragma message%>\");\n "}, {"sha": "fd1b72f806790006db43139e675f59bcf2c15f40", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1,3 +1,15 @@\n+2023-01-27  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-parser.cc (c_parser_declaration_or_fndef): Do not allow braces\n+\taround auto initializer.\n+\n+2023-01-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/105593\n+\t* c-parser.cc (c_parser_initializer): Check warning_enabled_at\n+\tat the DECL_SOURCE_LOCATION (decl) for OPT_Winit_self instead\n+\tof warn_init_self.\n+\n 2023-01-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/108365"}, {"sha": "69230002bc8f38006463b7917f0467f4e16fc77c", "filename": "gcc/c/c-parser.cc", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fc%2Fc-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fc%2Fc-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -2480,18 +2480,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\t  int flag_sanitize_save = flag_sanitize;\n \t\t  if (nested && !empty_ok)\n \t\t    flag_sanitize = 0;\n-\t\t  if (std_auto_type_p\n-\t\t      && c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n-\t\t    {\n-\t\t      matching_braces braces;\n-\t\t      braces.consume_open (parser);\n-\t\t      init = c_parser_expr_no_commas (parser, NULL);\n-\t\t      if (c_parser_next_token_is (parser, CPP_COMMA))\n-\t\t\tc_parser_consume_token (parser);\n-\t\t      braces.skip_until_found_close (parser);\n-\t\t    }\n-\t\t  else\n-\t\t    init = c_parser_expr_no_commas (parser, NULL);\n+\t\t  init = c_parser_expr_no_commas (parser, NULL);\n \t\t  if (std_auto_type_p)\n \t\t    finish_underspecified_init (underspec_name,\n \t\t\t\t\t\tunderspec_state);"}, {"sha": "06bc980fa52220d6c6f0e3aa7988cd1300afc48e", "filename": "gcc/cgraph.cc", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcgraph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcgraph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1893,8 +1893,18 @@ cgraph_node::remove (void)\n   else if (clone_of)\n     {\n       clone_of->clones = next_sibling_clone;\n-      if (!clone_of->analyzed && !clone_of->clones && !clones)\n-\tclone_of->release_body ();\n+      if (!clones)\n+\t{\n+\t  bool need_body = false;\n+\t  for (cgraph_node *n = clone_of; n; n = n->clone_of)\n+\t    if (n->analyzed || n->clones)\n+\t      {\n+\t\tneed_body = true;\n+\t\tbreak;\n+\t      }\n+\t  if (!need_body)\n+\t    clone_of->release_body ();\n+\t}\n     }\n   if (next_sibling_clone)\n     next_sibling_clone->prev_sibling_clone = prev_sibling_clone;\n@@ -3238,9 +3248,11 @@ cgraph_edge::verify_corresponds_to_fndecl (tree decl)\n   node = node->ultimate_alias_target ();\n \n   /* Optimizers can redirect unreachable calls or calls triggering undefined\n-     behavior to builtin_unreachable.  */\n+     behavior to __builtin_unreachable or __builtin_trap.  */\n \n-  if (fndecl_built_in_p (callee->decl, BUILT_IN_UNREACHABLE))\n+  if (fndecl_built_in_p (callee->decl, BUILT_IN_NORMAL)\n+      && (DECL_FUNCTION_CODE (callee->decl) == BUILT_IN_UNREACHABLE\n+\t  || DECL_FUNCTION_CODE (callee->decl) == BUILT_IN_TRAP))\n     return false;\n \n   if (callee->former_clone_of != node->decl\n@@ -4171,7 +4183,7 @@ cgraph_edge::possibly_call_in_translation_unit_p (void)\n     node = node->previous_sharing_asm_name;\n   if (node->previous_sharing_asm_name)\n     node = symtab_node::get_for_asmname (DECL_ASSEMBLER_NAME (callee->decl));\n-  gcc_assert (TREE_PUBLIC (node->decl));\n+  gcc_assert (TREE_PUBLIC (node->decl) || DECL_EXTERNAL (node->decl));\n   return node->get_availability () >= AVAIL_INTERPOSABLE;\n }\n "}, {"sha": "597831e0a16540867c3d0def6f58b286e5fc6c5c", "filename": "gcc/cgraphbuild.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcgraphbuild.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcgraphbuild.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-walk.h\"\n #include \"ipa-utils.h\"\n #include \"except.h\"\n+#include \"gimplify.h\"\n \n /* Context of record_reference.  */\n struct record_reference_ctx\n@@ -79,6 +80,17 @@ record_reference (tree *tp, int *walk_subtrees, void *data)\n \n       if (VAR_P (decl))\n \t{\n+\t  /* Replace vars with their DECL_VALUE_EXPR if any.\n+\t     This is normally done during gimplification, but\n+\t     static var initializers are never gimplified.  */\n+\t  if (DECL_HAS_VALUE_EXPR_P (decl))\n+\t    {\n+\t      tree *p;\n+\t      for (p = tp; *p != decl; p = &TREE_OPERAND (*p, 0))\n+\t\t;\n+\t      *p = unshare_expr (DECL_VALUE_EXPR (decl));\n+\t      return record_reference (tp, walk_subtrees, data);\n+\t    }\n \t  varpool_node *vnode = varpool_node::get_create (decl);\n \t  ctx->varpool_node->create_reference (vnode, IPA_REF_ADDR);\n \t}"}, {"sha": "832818d651fd83059b07b2fcd9b2a8ec65490dc2", "filename": "gcc/cgraphunit.cc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcgraphunit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcgraphunit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1087,8 +1087,6 @@ check_global_declaration (symtab_node *snode)\n       else\n \twarning (OPT_Wunused_function, \"%q+F declared %<static%> but never \"\n \t\t\t\t       \"defined\", decl);\n-      /* This symbol is effectively an \"extern\" declaration now.  */\n-      TREE_PUBLIC (decl) = 1;\n     }\n \n   /* Warn about static fns or vars defined but not used.  */"}, {"sha": "5fb9e9de74792e6e8515d21ab29262b45da65351", "filename": "gcc/common/config/aarch64/aarch64-common.cc", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcommon%2Fconfig%2Faarch64%2Faarch64-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcommon%2Fconfig%2Faarch64%2Faarch64-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Faarch64%2Faarch64-common.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -31,6 +31,7 @@\n #include \"flags.h\"\n #include \"diagnostic.h\"\n #include \"config/aarch64/aarch64-feature-deps.h\"\n+#include \"config/arm/aarch-common.h\"\n \n #ifdef  TARGET_BIG_ENDIAN_DEFAULT\n #undef  TARGET_DEFAULT_TARGET_FLAGS\n@@ -191,13 +192,13 @@ static constexpr arch_to_arch_name all_architectures[] =\n \n /* Parse the architecture extension string STR and update ISA_FLAGS\n    with the architecture features turned on or off.  Return a\n-   aarch64_parse_opt_result describing the result.\n+   aarch_parse_opt_result describing the result.\n    When the STR string contains an invalid extension,\n    a copy of the string is created and stored to INVALID_EXTENSION.  */\n \n-enum aarch64_parse_opt_result\n+enum aarch_parse_opt_result\n aarch64_parse_extension (const char *str, aarch64_feature_flags *isa_flags,\n-\t\t\t std::string *invalid_extension)\n+                         std::string *invalid_extension)\n {\n   /* The extension string is parsed left to right.  */\n   const struct aarch64_option_extension *opt = NULL;\n@@ -228,7 +229,7 @@ aarch64_parse_extension (const char *str, aarch64_feature_flags *isa_flags,\n \tadding_ext = 1;\n \n       if (len == 0)\n-\treturn AARCH64_PARSE_MISSING_ARG;\n+\treturn AARCH_PARSE_MISSING_ARG;\n \n \n       /* Scan over the extensions table trying to find an exact match.  */\n@@ -250,13 +251,13 @@ aarch64_parse_extension (const char *str, aarch64_feature_flags *isa_flags,\n \t  /* Extension not found in list.  */\n \t  if (invalid_extension)\n \t    *invalid_extension = std::string (str, len);\n-\t  return AARCH64_PARSE_INVALID_FEATURE;\n+\t  return AARCH_PARSE_INVALID_FEATURE;\n \t}\n \n       str = ext;\n     };\n \n-  return AARCH64_PARSE_OK;\n+  return AARCH_PARSE_OK;\n }\n \n /* Append all architecture extension candidates to the CANDIDATES vector.  */"}, {"sha": "616e2f897b9dcb2c82186ca406856777b35bb342", "filename": "gcc/common/config/riscv/riscv-common.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcommon%2Fconfig%2Friscv%2Friscv-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcommon%2Fconfig%2Friscv%2Friscv-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Friscv%2Friscv-common.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1756,6 +1756,10 @@ static const struct default_options riscv_option_optimization_table[] =\n   {\n     { OPT_LEVELS_1_PLUS, OPT_fsection_anchors, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_free, NULL, 1 },\n+#if TARGET_DEFAULT_ASYNC_UNWIND_TABLES == 1\n+    { OPT_LEVELS_ALL, OPT_fasynchronous_unwind_tables, NULL, 1 },\n+    { OPT_LEVELS_ALL, OPT_funwind_tables, NULL, 1},\n+#endif\n     { OPT_LEVELS_NONE, 0, NULL, 0 }\n   };\n "}, {"sha": "217338ed2af2290f1f49d90a7bf83241b9dc95db", "filename": "gcc/config.gcc", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -349,7 +349,7 @@ aarch64*-*-*)\n \tc_target_objs=\"aarch64-c.o\"\n \tcxx_target_objs=\"aarch64-c.o\"\n \td_target_objs=\"aarch64-d.o\"\n-\textra_objs=\"aarch64-builtins.o aarch-common.o aarch64-sve-builtins.o aarch64-sve-builtins-shapes.o aarch64-sve-builtins-base.o aarch64-sve-builtins-sve2.o cortex-a57-fma-steering.o aarch64-speculation.o falkor-tag-collision-avoidance.o aarch64-bti-insert.o aarch64-cc-fusion.o\"\n+\textra_objs=\"aarch64-builtins.o aarch-common.o aarch64-sve-builtins.o aarch64-sve-builtins-shapes.o aarch64-sve-builtins-base.o aarch64-sve-builtins-sve2.o cortex-a57-fma-steering.o aarch64-speculation.o falkor-tag-collision-avoidance.o aarch-bti-insert.o aarch64-cc-fusion.o\"\n \ttarget_gtfiles=\"\\$(srcdir)/config/aarch64/aarch64-builtins.cc \\$(srcdir)/config/aarch64/aarch64-sve-builtins.h \\$(srcdir)/config/aarch64/aarch64-sve-builtins.cc\"\n \ttarget_has_targetm_common=yes\n \t;;\n@@ -373,7 +373,7 @@ arc*-*-*)\n \t;;\n arm*-*-*)\n \tcpu_type=arm\n-\textra_objs=\"arm-builtins.o arm-mve-builtins.o aarch-common.o\"\n+\textra_objs=\"arm-builtins.o arm-mve-builtins.o aarch-common.o aarch-bti-insert.o\"\n \textra_headers=\"mmintrin.h arm_neon.h arm_acle.h arm_fp16.h arm_cmse.h arm_bf16.h arm_mve_types.h arm_mve.h arm_cde.h\"\n \ttarget_type_format_char='%'\n \tc_target_objs=\"arm-c.o\"\n@@ -1683,7 +1683,12 @@ csky-*-*)\n \t\t;;\n \t    csky-*-linux*)\n \t\ttm_file=\"elfos.h gnu-user.h linux.h glibc-stdint.h ${tm_file} csky/csky-linux-elf.h\"\n-\t\ttmake_file=\"${tmake_file} csky/t-csky csky/t-csky-linux\"\n+\t\ttmake_file=\"${tmake_file} csky/t-csky\"\n+\n+\t\tif test \"x${enable_multilib}\" = xyes ; then\n+\t\t    tm_defines=\"$tm_defines CSKY_ENABLE_MULTILIB\"\n+\t\t    tmake_file=\"${tmake_file} csky/t-csky-linux\"\n+\t\tfi\n \n \t\tcase ${target} in\n \t\t    csky-*-linux-gnu*)\n@@ -2007,7 +2012,7 @@ i[34567]86-*-linux* | i[34567]86-*-kfreebsd*-gnu | i[34567]86-*-gnu* | i[34567]8\n \t\t;;\n \tesac\n \t;;\n-x86_64-*-linux* | x86_64-*-kfreebsd*-gnu)\n+x86_64-*-linux* | x86_64-*-kfreebsd*-gnu | x86_64-*-gnu*)\n \ttm_file=\"${tm_file} i386/unix.h i386/att.h elfos.h gnu-user.h glibc-stdint.h \\\n \t\t i386/x86-64.h i386/gnu-user-common.h i386/gnu-user64.h\"\n \tcase ${target} in\n@@ -2018,6 +2023,9 @@ x86_64-*-linux* | x86_64-*-kfreebsd*-gnu)\n \tx86_64-*-kfreebsd*-gnu)\n \t\ttm_file=\"${tm_file} kfreebsd-gnu.h i386/kfreebsd-gnu64.h\"\n \t\t;;\n+\tx86_64-*-gnu*)\n+\t\ttm_file=\"${tm_file} gnu.h i386/gnu64.h\"\n+\t\t;;\n \tesac\n \ttmake_file=\"${tmake_file} i386/t-linux64\"\n \tx86_multilibs=\"${with_multilib_list}\"\n@@ -2455,6 +2463,7 @@ riscv*-*-linux*)\n \t*) echo \"Unknown value for enable_multilib\"; exit 1\n \tesac\n \ttmake_file=\"${tmake_file} riscv/t-riscv riscv/t-linux\"\n+\ttm_defines=\"${tm_defines} TARGET_DEFAULT_ASYNC_UNWIND_TABLES=1\"\n \tgnu_ld=yes\n \tgas=yes\n \tcase $target in\n@@ -4435,6 +4444,7 @@ case \"${target}\" in\n \t\t\t\t# through to the multilib selector\n \t\t\t\twith_float=\"soft\"\n \t\t\t\ttmake_file=\"${tmake_file} ${tmake_profile_file}\"\n+\t\t\t\ttm_file=\"$tm_file arm/arm-mlib.h\"\n \t\t\t\tTM_MULTILIB_CONFIG=\"$with_multilib_list\"\n \t\t\tfi\n \t\tfi"}, {"sha": "578ec6f45b06347d90f951b37064006786baf10f", "filename": "gcc/config/aarch64/aarch64-c.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Faarch64%2Faarch64-c.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Faarch64%2Faarch64-c.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-c.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -179,18 +179,18 @@ aarch64_update_cpp_builtins (cpp_reader *pfile)\n   aarch64_def_or_undef (TARGET_RNG, \"__ARM_FEATURE_RNG\", pfile);\n   aarch64_def_or_undef (TARGET_MEMTAG, \"__ARM_FEATURE_MEMORY_TAGGING\", pfile);\n \n-  aarch64_def_or_undef (aarch64_bti_enabled (),\n+  aarch64_def_or_undef (aarch_bti_enabled (),\n \t\t\t\"__ARM_FEATURE_BTI_DEFAULT\", pfile);\n \n   cpp_undef (pfile, \"__ARM_FEATURE_PAC_DEFAULT\");\n-  if (aarch64_ra_sign_scope != AARCH64_FUNCTION_NONE)\n+  if (aarch_ra_sign_scope != AARCH_FUNCTION_NONE)\n     {\n       int v = 0;\n-      if (aarch64_ra_sign_key == AARCH64_KEY_A)\n+      if (aarch_ra_sign_key == AARCH_KEY_A)\n \tv |= 1;\n-      if (aarch64_ra_sign_key == AARCH64_KEY_B)\n+      if (aarch_ra_sign_key == AARCH_KEY_B)\n \tv |= 2;\n-      if (aarch64_ra_sign_scope == AARCH64_FUNCTION_ALL)\n+      if (aarch_ra_sign_scope == AARCH_FUNCTION_ALL)\n \tv |= 4;\n       builtin_define_with_int_value (\"__ARM_FEATURE_PAC_DEFAULT\", v);\n     }"}, {"sha": "85fdfd8bf74c29123271d80428a55ca5d182b800", "filename": "gcc/config/aarch64/aarch64-cores.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Faarch64%2Faarch64-cores.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Faarch64%2Faarch64-cores.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-cores.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -70,7 +70,7 @@ AARCH64_CORE(\"thunderxt83\",   thunderxt83,   thunderx,  V8A,  (CRC, CRYPTO), thu\n \n /* Ampere Computing ('\\xC0') cores. */\n AARCH64_CORE(\"ampere1\", ampere1, cortexa57, V8_6A, (F16, RNG, AES, SHA3), ampere1, 0xC0, 0xac3, -1)\n-AARCH64_CORE(\"ampere1a\", ampere1a, cortexa57, V8_6A, (F16, RNG, AES, SHA3, MEMTAG), ampere1a, 0xC0, 0xac4, -1)\n+AARCH64_CORE(\"ampere1a\", ampere1a, cortexa57, V8_6A, (F16, RNG, AES, SHA3, SM4, MEMTAG), ampere1a, 0xC0, 0xac4, -1)\n /* Do not swap around \"emag\" and \"xgene1\",\n    this order is required to handle variant correctly. */\n AARCH64_CORE(\"emag\",        emag,      xgene1,    V8A,  (CRC, CRYPTO), emag, 0x50, 0x000, 3)"}, {"sha": "825f3bf775899e2e5cffb1867b82766d632c8708", "filename": "gcc/config/aarch64/aarch64-option-extensions.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Faarch64%2Faarch64-option-extensions.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Faarch64%2Faarch64-option-extensions.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-option-extensions.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -149,6 +149,6 @@ AARCH64_OPT_EXTENSION(\"ls64\", LS64, (), (), (), \"\")\n \n AARCH64_OPT_EXTENSION(\"mops\", MOPS, (), (), (), \"\")\n \n-AARCH64_OPT_EXTENSION(\"cssc\", CSSC, (), (), (), \"\")\n+AARCH64_OPT_EXTENSION(\"cssc\", CSSC, (), (), (), \"cssc\")\n \n #undef AARCH64_OPT_EXTENSION"}, {"sha": "a9f3e2715ca6f76a6610b58794907906df441a57", "filename": "gcc/config/aarch64/aarch64-opts.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Faarch64%2Faarch64-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Faarch64%2Faarch64-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-opts.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -75,16 +75,6 @@ enum aarch64_code_model {\n   AARCH64_CMODEL_LARGE\n };\n \n-/* Function types -msign-return-address should sign.  */\n-enum aarch64_function_type {\n-  /* Don't sign any function.  */\n-  AARCH64_FUNCTION_NONE,\n-  /* Non-leaf functions.  */\n-  AARCH64_FUNCTION_NON_LEAF,\n-  /* All functions.  */\n-  AARCH64_FUNCTION_ALL\n-};\n-\n /* SVE vector register sizes.  */\n enum aarch64_sve_vector_bits_enum {\n   SVE_SCALABLE,"}, {"sha": "6ab6d49af3773b4a1b7cc4f5bd135dfb5ee48d1c", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -23,6 +23,7 @@\n #define GCC_AARCH64_PROTOS_H\n \n #include \"input.h\"\n+#include \"config/arm/aarch-common.h\"\n \n /* SYMBOL_SMALL_ABSOLUTE: Generate symbol accesses through\n    high and lo relocs that calculate the base address using a PC\n@@ -651,18 +652,6 @@ enum aarch64_extra_tuning_flags\n   AARCH64_EXTRA_TUNE_ALL = (1u << AARCH64_EXTRA_TUNE_index_END) - 1\n };\n \n-/* Enum describing the various ways that the\n-   aarch64_parse_{arch,tune,cpu,extension} functions can fail.\n-   This way their callers can choose what kind of error to give.  */\n-\n-enum aarch64_parse_opt_result\n-{\n-  AARCH64_PARSE_OK,\t\t\t/* Parsing was successful.  */\n-  AARCH64_PARSE_MISSING_ARG,\t\t/* Missing argument.  */\n-  AARCH64_PARSE_INVALID_FEATURE,\t/* Invalid feature modifier.  */\n-  AARCH64_PARSE_INVALID_ARG\t\t/* Invalid arch, tune, cpu arg.  */\n-};\n-\n /* Enum to distinguish which type of check is to be done in\n    aarch64_simd_valid_immediate.  This is used as a bitmask where\n    AARCH64_CHECK_MOV has both bits set.  Thus AARCH64_CHECK_MOV will\n@@ -673,6 +662,8 @@ enum simd_immediate_check {\n   AARCH64_CHECK_MOV  = AARCH64_CHECK_ORR | AARCH64_CHECK_BIC\n };\n \n+extern enum aarch_key_type aarch_ra_sign_key;\n+\n extern struct tune_params aarch64_tune_params;\n \n /* The available SVE predicate patterns, known in the ACLE as \"svpattern\".  */\n@@ -914,7 +905,6 @@ void aarch64_register_pragmas (void);\n void aarch64_relayout_simd_types (void);\n void aarch64_reset_previous_fndecl (void);\n bool aarch64_return_address_signing_enabled (void);\n-bool aarch64_bti_enabled (void);\n void aarch64_save_restore_target_globals (tree);\n void aarch64_addti_scratch_regs (rtx, rtx, rtx *,\n \t\t\t\t rtx *, rtx *,\n@@ -1038,9 +1028,9 @@ void aarch64_set_asm_isa_flags (gcc_options *, aarch64_feature_flags);\n bool aarch64_handle_option (struct gcc_options *, struct gcc_options *,\n \t\t\t     const struct cl_decoded_option *, location_t);\n const char *aarch64_rewrite_selected_cpu (const char *name);\n-enum aarch64_parse_opt_result aarch64_parse_extension (const char *,\n-\t\t\t\t\t\t       aarch64_feature_flags *,\n-\t\t\t\t\t\t       std::string *);\n+enum aarch_parse_opt_result aarch64_parse_extension (const char *,\n+                                                     aarch64_feature_flags *,\n+                                                     std::string *);\n void aarch64_get_all_extension_candidates (auto_vec<const char *> *candidates);\n std::string aarch64_get_extension_string_for_isa_flags (aarch64_feature_flags,\n \t\t\t\t\t\t\taarch64_feature_flags);"}, {"sha": "7f212bf37cd2c120dceb7efa733c9fa76226f029", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1064,7 +1064,7 @@\n \t\t(match_operand:<VEL> 1 \"aarch64_simd_nonimmediate_operand\" \"w,?r,Utv\"))\n \t    (match_operand:VALL_F16 3 \"register_operand\" \"0,0,0\")\n \t    (match_operand:SI 2 \"immediate_operand\" \"i,i,i\")))]\n-  \"TARGET_SIMD\"\n+  \"TARGET_SIMD && exact_log2 (INTVAL (operands[2])) >= 0\"\n   {\n    int elt = ENDIAN_LANE_N (<nunits>, exact_log2 (INTVAL (operands[2])));\n    operands[2] = GEN_INT ((HOST_WIDE_INT) 1 << elt);\n@@ -1093,7 +1093,7 @@\n \t\t  [(match_operand:SI 4 \"immediate_operand\" \"i\")])))\n \t    (match_operand:VALL_F16 1 \"register_operand\" \"0\")\n \t    (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n-  \"TARGET_SIMD\"\n+  \"TARGET_SIMD && exact_log2 (INTVAL (operands[2])) >= 0\"\n   {\n     int elt = ENDIAN_LANE_N (<nunits>, exact_log2 (INTVAL (operands[2])));\n     operands[2] = GEN_INT (HOST_WIDE_INT_1 << elt);\n@@ -1114,7 +1114,7 @@\n \t\t  [(match_operand:SI 4 \"immediate_operand\" \"i\")])))\n \t    (match_operand:VALL_F16_NO_V2Q 1 \"register_operand\" \"0\")\n \t    (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n-  \"TARGET_SIMD\"\n+  \"TARGET_SIMD && exact_log2 (INTVAL (operands[2])) >= 0\"\n   {\n     int elt = ENDIAN_LANE_N (<nunits>, exact_log2 (INTVAL (operands[2])));\n     operands[2] = GEN_INT (HOST_WIDE_INT_1 << elt);"}, {"sha": "17c1e23e5b54133cdd50adc8c4d2d90c3f1991c0", "filename": "gcc/config/aarch64/aarch64.cc", "status": "modified", "additions": 160, "deletions": 291, "changes": 451, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -82,6 +82,8 @@\n #include \"tree-dfa.h\"\n #include \"asan.h\"\n #include \"aarch64-feature-deps.h\"\n+#include \"config/arm/aarch-common.h\"\n+#include \"config/arm/aarch-common-protos.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -318,12 +320,8 @@ bool aarch64_pcrelative_literal_loads;\n /* Global flag for whether frame pointer is enabled.  */\n bool aarch64_use_frame_pointer;\n \n-#define BRANCH_PROTECT_STR_MAX 255\n char *accepted_branch_protection_string = NULL;\n \n-static enum aarch64_parse_opt_result\n-aarch64_parse_branch_protection (const char*, char**);\n-\n /* Support for command line parsing of boolean flags in the tuning\n    structures.  */\n struct aarch64_flag_desc\n@@ -2761,6 +2759,8 @@ static const struct processor all_cores[] =\n   {NULL, aarch64_none, aarch64_none, aarch64_no_arch, 0, NULL}\n };\n \n+enum aarch_key_type aarch_ra_sign_key = AARCH_KEY_A;\n+\n /* The current tuning set.  */\n struct tune_params aarch64_tune_params = generic_tunings;\n \n@@ -2826,100 +2826,6 @@ aarch64_cc;\n \n #define AARCH64_INVERSE_CONDITION_CODE(X) ((aarch64_cc) (((int) X) ^ 1))\n \n-struct aarch64_branch_protect_type\n-{\n-  /* The type's name that the user passes to the branch-protection option\n-    string.  */\n-  const char* name;\n-  /* Function to handle the protection type and set global variables.\n-    First argument is the string token corresponding with this type and the\n-    second argument is the next token in the option string.\n-    Return values:\n-    * AARCH64_PARSE_OK: Handling was sucessful.\n-    * AARCH64_INVALID_ARG: The type is invalid in this context and the caller\n-      should print an error.\n-    * AARCH64_INVALID_FEATURE: The type is invalid and the handler prints its\n-      own error.  */\n-  enum aarch64_parse_opt_result (*handler)(char*, char*);\n-  /* A list of types that can follow this type in the option string.  */\n-  const aarch64_branch_protect_type* subtypes;\n-  unsigned int num_subtypes;\n-};\n-\n-static enum aarch64_parse_opt_result\n-aarch64_handle_no_branch_protection (char* str, char* rest)\n-{\n-  aarch64_ra_sign_scope = AARCH64_FUNCTION_NONE;\n-  aarch64_enable_bti = 0;\n-  if (rest)\n-    {\n-      error (\"unexpected %<%s%> after %<%s%>\", rest, str);\n-      return AARCH64_PARSE_INVALID_FEATURE;\n-    }\n-  return AARCH64_PARSE_OK;\n-}\n-\n-static enum aarch64_parse_opt_result\n-aarch64_handle_standard_branch_protection (char* str, char* rest)\n-{\n-  aarch64_ra_sign_scope = AARCH64_FUNCTION_NON_LEAF;\n-  aarch64_ra_sign_key = AARCH64_KEY_A;\n-  aarch64_enable_bti = 1;\n-  if (rest)\n-    {\n-      error (\"unexpected %<%s%> after %<%s%>\", rest, str);\n-      return AARCH64_PARSE_INVALID_FEATURE;\n-    }\n-  return AARCH64_PARSE_OK;\n-}\n-\n-static enum aarch64_parse_opt_result\n-aarch64_handle_pac_ret_protection (char* str ATTRIBUTE_UNUSED,\n-\t\t\t\t    char* rest ATTRIBUTE_UNUSED)\n-{\n-  aarch64_ra_sign_scope = AARCH64_FUNCTION_NON_LEAF;\n-  aarch64_ra_sign_key = AARCH64_KEY_A;\n-  return AARCH64_PARSE_OK;\n-}\n-\n-static enum aarch64_parse_opt_result\n-aarch64_handle_pac_ret_leaf (char* str ATTRIBUTE_UNUSED,\n-\t\t\t      char* rest ATTRIBUTE_UNUSED)\n-{\n-  aarch64_ra_sign_scope = AARCH64_FUNCTION_ALL;\n-  return AARCH64_PARSE_OK;\n-}\n-\n-static enum aarch64_parse_opt_result\n-aarch64_handle_pac_ret_b_key (char* str ATTRIBUTE_UNUSED,\n-\t\t\t      char* rest ATTRIBUTE_UNUSED)\n-{\n-  aarch64_ra_sign_key = AARCH64_KEY_B;\n-  return AARCH64_PARSE_OK;\n-}\n-\n-static enum aarch64_parse_opt_result\n-aarch64_handle_bti_protection (char* str ATTRIBUTE_UNUSED,\n-\t\t\t\t    char* rest ATTRIBUTE_UNUSED)\n-{\n-  aarch64_enable_bti = 1;\n-  return AARCH64_PARSE_OK;\n-}\n-\n-static const struct aarch64_branch_protect_type aarch64_pac_ret_subtypes[] = {\n-  { \"leaf\", aarch64_handle_pac_ret_leaf, NULL, 0 },\n-  { \"b-key\", aarch64_handle_pac_ret_b_key, NULL, 0 },\n-  { NULL, NULL, NULL, 0 }\n-};\n-\n-static const struct aarch64_branch_protect_type aarch64_branch_protect_types[] = {\n-  { \"none\", aarch64_handle_no_branch_protection, NULL, 0 },\n-  { \"standard\", aarch64_handle_standard_branch_protection, NULL, 0 },\n-  { \"pac-ret\", aarch64_handle_pac_ret_protection, aarch64_pac_ret_subtypes,\n-    ARRAY_SIZE (aarch64_pac_ret_subtypes) },\n-  { \"bti\", aarch64_handle_bti_protection, NULL, 0 },\n-  { NULL, NULL, NULL, 0 }\n-};\n \n /* The condition codes of the processor, and the inverse function.  */\n static const char * const aarch64_condition_codes[] =\n@@ -7659,7 +7565,18 @@ aarch64_layout_arg (cumulative_args_t pcum_v, const function_arg_info &arg)\n        && (currently_expanding_function_start\n \t   || currently_expanding_gimple_stmt));\n \n-  /* There are several things to note here:\n+  /* HFAs and HVAs can have an alignment greater than 16 bytes.  For example:\n+\n+       typedef struct foo {\n+         __Int8x16_t foo[2] __attribute__((aligned(32)));\n+       } foo;\n+\n+     is still a HVA despite its larger-than-normal alignment.\n+     However, such over-aligned HFAs and HVAs are guaranteed to have\n+     no padding.\n+\n+     If we exclude HFAs and HVAs from the discussion below, then there\n+     are several things to note:\n \n      - Both the C and AAPCS64 interpretations of a type's alignment should\n        give a value that is no greater than the type's size.\n@@ -7704,12 +7621,6 @@ aarch64_layout_arg (cumulative_args_t pcum_v, const function_arg_info &arg)\n        would treat the alignment as though it was *equal to* 16 bytes.\n \n      Both behaviors were wrong, but in different cases.  */\n-  unsigned int alignment\n-    = aarch64_function_arg_alignment (mode, type, &abi_break,\n-\t\t\t\t      &abi_break_packed);\n-  gcc_assert (alignment <= 16 * BITS_PER_UNIT\n-\t      && (!alignment || abi_break < alignment)\n-\t      && (!abi_break_packed || alignment < abi_break_packed));\n \n   pcum->aapcs_arg_processed = true;\n \n@@ -7780,6 +7691,14 @@ aarch64_layout_arg (cumulative_args_t pcum_v, const function_arg_info &arg)\n \t\t\t\t\t\t &nregs);\n   gcc_assert (!sve_p || !allocate_nvrn);\n \n+  unsigned int alignment\n+    = aarch64_function_arg_alignment (mode, type, &abi_break,\n+\t\t\t\t      &abi_break_packed);\n+\n+  gcc_assert ((allocate_nvrn || alignment <= 16 * BITS_PER_UNIT)\n+\t      && (!alignment || abi_break < alignment)\n+\t      && (!abi_break_packed || alignment < abi_break_packed));\n+\n   /* allocate_ncrn may be false-positive, but allocate_nvrn is quite reliable.\n      The following code thus handles passing by SIMD/FP registers first.  */\n \n@@ -9007,18 +8926,72 @@ aarch64_return_address_signing_enabled (void)\n   if (crtl->calls_eh_return)\n     return false;\n \n-  /* If signing scope is AARCH64_FUNCTION_NON_LEAF, we only sign a leaf function\n+  /* If signing scope is AARCH_FUNCTION_NON_LEAF, we only sign a leaf function\n      if its LR is pushed onto stack.  */\n-  return (aarch64_ra_sign_scope == AARCH64_FUNCTION_ALL\n-\t  || (aarch64_ra_sign_scope == AARCH64_FUNCTION_NON_LEAF\n+  return (aarch_ra_sign_scope == AARCH_FUNCTION_ALL\n+\t  || (aarch_ra_sign_scope == AARCH_FUNCTION_NON_LEAF\n \t      && known_ge (cfun->machine->frame.reg_offset[LR_REGNUM], 0)));\n }\n \n+/* Only used by the arm backend.  */\n+void aarch_bti_arch_check (void)\n+{}\n+\n /* Return TRUE if Branch Target Identification Mechanism is enabled.  */\n bool\n-aarch64_bti_enabled (void)\n+aarch_bti_enabled (void)\n+{\n+  return (aarch_enable_bti == 1);\n+}\n+\n+/* Check if INSN is a BTI J insn.  */\n+bool\n+aarch_bti_j_insn_p (rtx_insn *insn)\n+{\n+  if (!insn || !INSN_P (insn))\n+    return false;\n+\n+  rtx pat = PATTERN (insn);\n+  return GET_CODE (pat) == UNSPEC_VOLATILE && XINT (pat, 1) == UNSPECV_BTI_J;\n+}\n+\n+/* Check if X (or any sub-rtx of X) is a PACIASP/PACIBSP instruction.  */\n+bool\n+aarch_pac_insn_p (rtx x)\n+{\n+  if (!INSN_P (x))\n+    return false;\n+\n+  subrtx_var_iterator::array_type array;\n+  FOR_EACH_SUBRTX_VAR (iter, array, PATTERN (x), ALL)\n+    {\n+      rtx sub = *iter;\n+      if (sub && GET_CODE (sub) == UNSPEC)\n+\t{\n+\t  int unspec_val = XINT (sub, 1);\n+\t  switch (unspec_val)\n+\t    {\n+\t    case UNSPEC_PACIASP:\n+            case UNSPEC_PACIBSP:\n+\t      return true;\n+\n+\t    default:\n+\t      return false;\n+\t    }\n+\t  iter.skip_subrtxes ();\n+\t}\n+    }\n+  return false;\n+}\n+\n+rtx aarch_gen_bti_c (void)\n+{\n+  return gen_bti_c ();\n+}\n+\n+rtx aarch_gen_bti_j (void)\n {\n-  return (aarch64_enable_bti == 1);\n+  return gen_bti_j ();\n }\n \n /* The caller is going to use ST1D or LD1D to save or restore an SVE\n@@ -10010,12 +9983,12 @@ aarch64_expand_prologue (void)\n   /* Sign return address for functions.  */\n   if (aarch64_return_address_signing_enabled ())\n     {\n-      switch (aarch64_ra_sign_key)\n+      switch (aarch_ra_sign_key)\n \t{\n-\t  case AARCH64_KEY_A:\n+\t  case AARCH_KEY_A:\n \t    insn = emit_insn (gen_paciasp ());\n \t    break;\n-\t  case AARCH64_KEY_B:\n+\t  case AARCH_KEY_B:\n \t    insn = emit_insn (gen_pacibsp ());\n \t    break;\n \t  default:\n@@ -10316,12 +10289,12 @@ aarch64_expand_epilogue (bool for_sibcall)\n   if (aarch64_return_address_signing_enabled ()\n       && (for_sibcall || !TARGET_ARMV8_3))\n     {\n-      switch (aarch64_ra_sign_key)\n+      switch (aarch_ra_sign_key)\n \t{\n-\t  case AARCH64_KEY_A:\n+\t  case AARCH_KEY_A:\n \t    insn = emit_insn (gen_autiasp ());\n \t    break;\n-\t  case AARCH64_KEY_B:\n+\t  case AARCH_KEY_B:\n \t    insn = emit_insn (gen_autibsp ());\n \t    break;\n \t  default:\n@@ -10400,7 +10373,7 @@ aarch64_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n   rtx_insn *insn;\n   const char *fnname = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (thunk));\n \n-  if (aarch64_bti_enabled ())\n+  if (aarch_bti_enabled ())\n     emit_insn (gen_bti_c());\n \n   reload_completed = 1;\n@@ -13049,7 +13022,7 @@ aarch64_output_casesi (rtx *operands)\n int\n aarch64_uxt_size (int shift, HOST_WIDE_INT mask)\n {\n-  if (shift >= 0 && shift <= 3)\n+  if (shift >= 0 && shift <= 4)\n     {\n       int size;\n       for (size = 8; size <= 32; size *= 2)\n@@ -17346,12 +17319,12 @@ static void initialize_aarch64_code_model (struct gcc_options *);\n \n /* Parse the TO_PARSE string and put the architecture struct that it\n    selects into RES and the architectural features into ISA_FLAGS.\n-   Return an aarch64_parse_opt_result describing the parse result.\n+   Return an aarch_parse_opt_result describing the parse result.\n    If there is an error parsing, RES and ISA_FLAGS are left unchanged.\n    When the TO_PARSE string contains an invalid extension,\n    a copy of the string is created and stored to INVALID_EXTENSION.  */\n \n-static enum aarch64_parse_opt_result\n+static enum aarch_parse_opt_result\n aarch64_parse_arch (const char *to_parse, const struct processor **res,\n \t\t    aarch64_feature_flags *isa_flags,\n \t\t    std::string *invalid_extension)\n@@ -17368,7 +17341,7 @@ aarch64_parse_arch (const char *to_parse, const struct processor **res,\n     len = strlen (to_parse);\n \n   if (len == 0)\n-    return AARCH64_PARSE_MISSING_ARG;\n+    return AARCH_PARSE_MISSING_ARG;\n \n \n   /* Loop through the list of supported ARCHes to find a match.  */\n@@ -17382,32 +17355,32 @@ aarch64_parse_arch (const char *to_parse, const struct processor **res,\n \t  if (ext != NULL)\n \t    {\n \t      /* TO_PARSE string contains at least one extension.  */\n-\t      enum aarch64_parse_opt_result ext_res\n+\t      enum aarch_parse_opt_result ext_res\n \t\t= aarch64_parse_extension (ext, &isa_temp, invalid_extension);\n \n-\t      if (ext_res != AARCH64_PARSE_OK)\n+\t      if (ext_res != AARCH_PARSE_OK)\n \t\treturn ext_res;\n \t    }\n \t  /* Extension parsing was successful.  Confirm the result\n \t     arch and ISA flags.  */\n \t  *res = arch;\n \t  *isa_flags = isa_temp;\n-\t  return AARCH64_PARSE_OK;\n+\t  return AARCH_PARSE_OK;\n \t}\n     }\n \n   /* ARCH name not found in list.  */\n-  return AARCH64_PARSE_INVALID_ARG;\n+  return AARCH_PARSE_INVALID_ARG;\n }\n \n /* Parse the TO_PARSE string and put the result tuning in RES and the\n-   architecture flags in ISA_FLAGS.  Return an aarch64_parse_opt_result\n+   architecture flags in ISA_FLAGS.  Return an aarch_parse_opt_result\n    describing the parse result.  If there is an error parsing, RES and\n    ISA_FLAGS are left unchanged.\n    When the TO_PARSE string contains an invalid extension,\n    a copy of the string is created and stored to INVALID_EXTENSION.  */\n \n-static enum aarch64_parse_opt_result\n+static enum aarch_parse_opt_result\n aarch64_parse_cpu (const char *to_parse, const struct processor **res,\n \t\t   aarch64_feature_flags *isa_flags,\n \t\t   std::string *invalid_extension)\n@@ -17424,7 +17397,7 @@ aarch64_parse_cpu (const char *to_parse, const struct processor **res,\n     len = strlen (to_parse);\n \n   if (len == 0)\n-    return AARCH64_PARSE_MISSING_ARG;\n+    return AARCH_PARSE_MISSING_ARG;\n \n \n   /* Loop through the list of supported CPUs to find a match.  */\n@@ -17437,29 +17410,29 @@ aarch64_parse_cpu (const char *to_parse, const struct processor **res,\n \t  if (ext != NULL)\n \t    {\n \t      /* TO_PARSE string contains at least one extension.  */\n-\t      enum aarch64_parse_opt_result ext_res\n+\t      enum aarch_parse_opt_result ext_res\n \t\t= aarch64_parse_extension (ext, &isa_temp, invalid_extension);\n \n-\t      if (ext_res != AARCH64_PARSE_OK)\n+\t      if (ext_res != AARCH_PARSE_OK)\n \t\treturn ext_res;\n \t    }\n \t  /* Extension parsing was successfull.  Confirm the result\n \t     cpu and ISA flags.  */\n \t  *res = cpu;\n \t  *isa_flags = isa_temp;\n-\t  return AARCH64_PARSE_OK;\n+\t  return AARCH_PARSE_OK;\n \t}\n     }\n \n   /* CPU name not found in list.  */\n-  return AARCH64_PARSE_INVALID_ARG;\n+  return AARCH_PARSE_INVALID_ARG;\n }\n \n /* Parse the TO_PARSE string and put the cpu it selects into RES.\n-   Return an aarch64_parse_opt_result describing the parse result.\n+   Return an aarch_parse_opt_result describing the parse result.\n    If the parsing fails the RES does not change.  */\n \n-static enum aarch64_parse_opt_result\n+static enum aarch_parse_opt_result\n aarch64_parse_tune (const char *to_parse, const struct processor **res)\n {\n   const struct processor *cpu;\n@@ -17470,12 +17443,12 @@ aarch64_parse_tune (const char *to_parse, const struct processor **res)\n       if (strcmp (cpu->name, to_parse) == 0)\n \t{\n \t  *res = cpu;\n-\t  return AARCH64_PARSE_OK;\n+\t  return AARCH_PARSE_OK;\n \t}\n     }\n \n   /* CPU name not found in list.  */\n-  return AARCH64_PARSE_INVALID_ARG;\n+  return AARCH_PARSE_INVALID_ARG;\n }\n \n /* Parse TOKEN, which has length LENGTH to see if it is an option\n@@ -18066,22 +18039,22 @@ aarch64_validate_mcpu (const char *str, const struct processor **res,\n \t\t       aarch64_feature_flags *isa_flags)\n {\n   std::string invalid_extension;\n-  enum aarch64_parse_opt_result parse_res\n+  enum aarch_parse_opt_result parse_res\n     = aarch64_parse_cpu (str, res, isa_flags, &invalid_extension);\n \n-  if (parse_res == AARCH64_PARSE_OK)\n+  if (parse_res == AARCH_PARSE_OK)\n     return true;\n \n   switch (parse_res)\n     {\n-      case AARCH64_PARSE_MISSING_ARG:\n+      case AARCH_PARSE_MISSING_ARG:\n \terror (\"missing cpu name in %<-mcpu=%s%>\", str);\n \tbreak;\n-      case AARCH64_PARSE_INVALID_ARG:\n+      case AARCH_PARSE_INVALID_ARG:\n \terror (\"unknown value %qs for %<-mcpu%>\", str);\n \taarch64_print_hint_for_core (str);\n \tbreak;\n-      case AARCH64_PARSE_INVALID_FEATURE:\n+      case AARCH_PARSE_INVALID_FEATURE:\n \terror (\"invalid feature modifier %qs in %<-mcpu=%s%>\",\n \t       invalid_extension.c_str (), str);\n \taarch64_print_hint_for_extensions (invalid_extension);\n@@ -18166,110 +18139,6 @@ aarch64_validate_sls_mitigation (const char *const_str)\n   free (str_root);\n }\n \n-/* Parses CONST_STR for branch protection features specified in\n-   aarch64_branch_protect_types, and set any global variables required.  Returns\n-   the parsing result and assigns LAST_STR to the last processed token from\n-   CONST_STR so that it can be used for error reporting.  */\n-\n-static enum\n-aarch64_parse_opt_result aarch64_parse_branch_protection (const char *const_str,\n-\t\t\t\t\t\t\t  char** last_str)\n-{\n-  char *str_root = xstrdup (const_str);\n-  char* token_save = NULL;\n-  char *str = strtok_r (str_root, \"+\", &token_save);\n-  enum aarch64_parse_opt_result res = AARCH64_PARSE_OK;\n-  if (!str)\n-    res = AARCH64_PARSE_MISSING_ARG;\n-  else\n-    {\n-      char *next_str = strtok_r (NULL, \"+\", &token_save);\n-      /* Reset the branch protection features to their defaults.  */\n-      aarch64_handle_no_branch_protection (NULL, NULL);\n-\n-      while (str && res == AARCH64_PARSE_OK)\n-\t{\n-\t  const aarch64_branch_protect_type* type = aarch64_branch_protect_types;\n-\t  bool found = false;\n-\t  /* Search for this type.  */\n-\t  while (type && type->name && !found && res == AARCH64_PARSE_OK)\n-\t    {\n-\t      if (strcmp (str, type->name) == 0)\n-\t\t{\n-\t\t  found = true;\n-\t\t  res = type->handler (str, next_str);\n-\t\t  str = next_str;\n-\t\t  next_str = strtok_r (NULL, \"+\", &token_save);\n-\t\t}\n-\t      else\n-\t\ttype++;\n-\t    }\n-\t  if (found && res == AARCH64_PARSE_OK)\n-\t    {\n-\t      bool found_subtype = true;\n-\t      /* Loop through each token until we find one that isn't a\n-\t\t subtype.  */\n-\t      while (found_subtype)\n-\t\t{\n-\t\t  found_subtype = false;\n-\t\t  const aarch64_branch_protect_type *subtype = type->subtypes;\n-\t\t  /* Search for the subtype.  */\n-\t\t  while (str && subtype && subtype->name && !found_subtype\n-\t\t\t  && res == AARCH64_PARSE_OK)\n-\t\t    {\n-\t\t      if (strcmp (str, subtype->name) == 0)\n-\t\t\t{\n-\t\t\t  found_subtype = true;\n-\t\t\t  res = subtype->handler (str, next_str);\n-\t\t\t  str = next_str;\n-\t\t\t  next_str = strtok_r (NULL, \"+\", &token_save);\n-\t\t\t}\n-\t\t      else\n-\t\t\tsubtype++;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  else if (!found)\n-\t    res = AARCH64_PARSE_INVALID_ARG;\n-\t}\n-    }\n-  /* Copy the last processed token into the argument to pass it back.\n-    Used by option and attribute validation to print the offending token.  */\n-  if (last_str)\n-    {\n-      if (str) strcpy (*last_str, str);\n-      else *last_str = NULL;\n-    }\n-  if (res == AARCH64_PARSE_OK)\n-    {\n-      /* If needed, alloc the accepted string then copy in const_str.\n-\tUsed by override_option_after_change_1.  */\n-      if (!accepted_branch_protection_string)\n-\taccepted_branch_protection_string = (char *) xmalloc (\n-\t\t\t\t\t\t      BRANCH_PROTECT_STR_MAX\n-\t\t\t\t\t\t\t+ 1);\n-      strncpy (accepted_branch_protection_string, const_str,\n-\t\tBRANCH_PROTECT_STR_MAX + 1);\n-      /* Forcibly null-terminate.  */\n-      accepted_branch_protection_string[BRANCH_PROTECT_STR_MAX] = '\\0';\n-    }\n-  return res;\n-}\n-\n-static bool\n-aarch64_validate_mbranch_protection (const char *const_str)\n-{\n-  char *str = (char *) xmalloc (strlen (const_str));\n-  enum aarch64_parse_opt_result res =\n-    aarch64_parse_branch_protection (const_str, &str);\n-  if (res == AARCH64_PARSE_INVALID_ARG)\n-    error (\"invalid argument %<%s%> for %<-mbranch-protection=%>\", str);\n-  else if (res == AARCH64_PARSE_MISSING_ARG)\n-    error (\"missing argument for %<-mbranch-protection=%>\");\n-  free (str);\n-  return res == AARCH64_PARSE_OK;\n-}\n-\n /* Validate a command-line -march option.  Parse the arch and extensions\n    (if any) specified in STR and throw errors if appropriate.  Put the\n    results, if they are valid, in RES and ISA_FLAGS.  Return whether the\n@@ -18280,27 +18149,27 @@ aarch64_validate_march (const char *str, const struct processor **res,\n \t\t\taarch64_feature_flags *isa_flags)\n {\n   std::string invalid_extension;\n-  enum aarch64_parse_opt_result parse_res\n+  enum aarch_parse_opt_result parse_res\n     = aarch64_parse_arch (str, res, isa_flags, &invalid_extension);\n \n-  if (parse_res == AARCH64_PARSE_OK)\n+  if (parse_res == AARCH_PARSE_OK)\n     return true;\n \n   switch (parse_res)\n     {\n-      case AARCH64_PARSE_MISSING_ARG:\n+      case AARCH_PARSE_MISSING_ARG:\n \terror (\"missing arch name in %<-march=%s%>\", str);\n \tbreak;\n-      case AARCH64_PARSE_INVALID_ARG:\n+      case AARCH_PARSE_INVALID_ARG:\n \terror (\"unknown value %qs for %<-march%>\", str);\n \taarch64_print_hint_for_arch (str);\n \t/* A common user error is confusing -march and -mcpu.\n \t   If the -march string matches a known CPU suggest -mcpu.  */\n \tparse_res = aarch64_parse_cpu (str, res, isa_flags, &invalid_extension);\n-\tif (parse_res == AARCH64_PARSE_OK)\n+\tif (parse_res == AARCH_PARSE_OK)\n \t  inform (input_location, \"did you mean %<-mcpu=%s%>?\", str);\n \tbreak;\n-      case AARCH64_PARSE_INVALID_FEATURE:\n+      case AARCH_PARSE_INVALID_FEATURE:\n \terror (\"invalid feature modifier %qs in %<-march=%s%>\",\n \t       invalid_extension.c_str (), str);\n \taarch64_print_hint_for_extensions (invalid_extension);\n@@ -18320,18 +18189,18 @@ aarch64_validate_march (const char *str, const struct processor **res,\n static bool\n aarch64_validate_mtune (const char *str, const struct processor **res)\n {\n-  enum aarch64_parse_opt_result parse_res\n+  enum aarch_parse_opt_result parse_res\n     = aarch64_parse_tune (str, res);\n \n-  if (parse_res == AARCH64_PARSE_OK)\n+  if (parse_res == AARCH_PARSE_OK)\n     return true;\n \n   switch (parse_res)\n     {\n-      case AARCH64_PARSE_MISSING_ARG:\n+      case AARCH_PARSE_MISSING_ARG:\n \terror (\"missing cpu name in %<-mtune=%s%>\", str);\n \tbreak;\n-      case AARCH64_PARSE_INVALID_ARG:\n+      case AARCH_PARSE_INVALID_ARG:\n \terror (\"unknown value %qs for %<-mtune%>\", str);\n \taarch64_print_hint_for_core (str);\n \tbreak;\n@@ -18393,7 +18262,7 @@ aarch64_override_options (void)\n     aarch64_validate_sls_mitigation (aarch64_harden_sls_string);\n \n   if (aarch64_branch_protection_string)\n-    aarch64_validate_mbranch_protection (aarch64_branch_protection_string);\n+    aarch_validate_mbranch_protection (aarch64_branch_protection_string);\n \n   /* -mcpu=CPU is shorthand for -march=ARCH_FOR_CPU, -mtune=CPU.\n      If either of -march or -mtune is given, they override their\n@@ -18446,12 +18315,12 @@ aarch64_override_options (void)\n \n   selected_tune = tune ? tune->ident : cpu->ident;\n \n-  if (aarch64_enable_bti == 2)\n+  if (aarch_enable_bti == 2)\n     {\n #ifdef TARGET_ENABLE_BTI\n-      aarch64_enable_bti = 1;\n+      aarch_enable_bti = 1;\n #else\n-      aarch64_enable_bti = 0;\n+      aarch_enable_bti = 0;\n #endif\n     }\n \n@@ -18461,9 +18330,9 @@ aarch64_override_options (void)\n   if (!TARGET_ILP32 && accepted_branch_protection_string == NULL)\n     {\n #ifdef TARGET_ENABLE_PAC_RET\n-      aarch64_ra_sign_scope = AARCH64_FUNCTION_NON_LEAF;\n+      aarch_ra_sign_scope = AARCH_FUNCTION_NON_LEAF;\n #else\n-      aarch64_ra_sign_scope = AARCH64_FUNCTION_NONE;\n+      aarch_ra_sign_scope = AARCH_FUNCTION_NONE;\n #endif\n     }\n \n@@ -18477,7 +18346,7 @@ aarch64_override_options (void)\n   /* Convert -msve-vector-bits to a VG count.  */\n   aarch64_sve_vg = aarch64_convert_sve_vector_bits (aarch64_sve_vector_bits);\n \n-  if (aarch64_ra_sign_scope != AARCH64_FUNCTION_NONE && TARGET_ILP32)\n+  if (aarch_ra_sign_scope != AARCH_FUNCTION_NONE && TARGET_ILP32)\n     sorry (\"return address signing is only supported for %<-mabi=lp64%>\");\n \n   /* The pass to insert speculation tracking runs before\n@@ -18692,10 +18561,10 @@ aarch64_handle_attr_arch (const char *str)\n   const struct processor *tmp_arch = NULL;\n   std::string invalid_extension;\n   aarch64_feature_flags tmp_flags;\n-  enum aarch64_parse_opt_result parse_res\n+  enum aarch_parse_opt_result parse_res\n     = aarch64_parse_arch (str, &tmp_arch, &tmp_flags, &invalid_extension);\n \n-  if (parse_res == AARCH64_PARSE_OK)\n+  if (parse_res == AARCH_PARSE_OK)\n     {\n       gcc_assert (tmp_arch);\n       selected_arch = tmp_arch->arch;\n@@ -18705,14 +18574,14 @@ aarch64_handle_attr_arch (const char *str)\n \n   switch (parse_res)\n     {\n-      case AARCH64_PARSE_MISSING_ARG:\n+      case AARCH_PARSE_MISSING_ARG:\n \terror (\"missing name in %<target(\\\"arch=\\\")%> pragma or attribute\");\n \tbreak;\n-      case AARCH64_PARSE_INVALID_ARG:\n+      case AARCH_PARSE_INVALID_ARG:\n \terror (\"invalid name %qs in %<target(\\\"arch=\\\")%> pragma or attribute\", str);\n \taarch64_print_hint_for_arch (str);\n \tbreak;\n-      case AARCH64_PARSE_INVALID_FEATURE:\n+      case AARCH_PARSE_INVALID_FEATURE:\n \terror (\"invalid feature modifier %s of value %qs in \"\n \t       \"%<target()%> pragma or attribute\", invalid_extension.c_str (), str);\n \taarch64_print_hint_for_extensions (invalid_extension);\n@@ -18732,10 +18601,10 @@ aarch64_handle_attr_cpu (const char *str)\n   const struct processor *tmp_cpu = NULL;\n   std::string invalid_extension;\n   aarch64_feature_flags tmp_flags;\n-  enum aarch64_parse_opt_result parse_res\n+  enum aarch_parse_opt_result parse_res\n     = aarch64_parse_cpu (str, &tmp_cpu, &tmp_flags, &invalid_extension);\n \n-  if (parse_res == AARCH64_PARSE_OK)\n+  if (parse_res == AARCH_PARSE_OK)\n     {\n       gcc_assert (tmp_cpu);\n       selected_tune = tmp_cpu->ident;\n@@ -18746,14 +18615,14 @@ aarch64_handle_attr_cpu (const char *str)\n \n   switch (parse_res)\n     {\n-      case AARCH64_PARSE_MISSING_ARG:\n+      case AARCH_PARSE_MISSING_ARG:\n \terror (\"missing name in %<target(\\\"cpu=\\\")%> pragma or attribute\");\n \tbreak;\n-      case AARCH64_PARSE_INVALID_ARG:\n+      case AARCH_PARSE_INVALID_ARG:\n \terror (\"invalid name %qs in %<target(\\\"cpu=\\\")%> pragma or attribute\", str);\n \taarch64_print_hint_for_core (str);\n \tbreak;\n-      case AARCH64_PARSE_INVALID_FEATURE:\n+      case AARCH_PARSE_INVALID_FEATURE:\n \terror (\"invalid feature modifier %qs of value %qs in \"\n \t       \"%<target()%> pragma or attribute\", invalid_extension.c_str (), str);\n \taarch64_print_hint_for_extensions (invalid_extension);\n@@ -18771,23 +18640,23 @@ aarch64_handle_attr_cpu (const char *str)\n  aarch64_handle_attr_branch_protection (const char* str)\n  {\n   char *err_str = (char *) xmalloc (strlen (str) + 1);\n-  enum aarch64_parse_opt_result res = aarch64_parse_branch_protection (str,\n-\t\t\t\t\t\t\t\t      &err_str);\n+  enum aarch_parse_opt_result res = aarch_parse_branch_protection (str,\n+\t\t\t\t\t\t\t\t   &err_str);\n   bool success = false;\n   switch (res)\n     {\n-     case AARCH64_PARSE_MISSING_ARG:\n+     case AARCH_PARSE_MISSING_ARG:\n        error (\"missing argument to %<target(\\\"branch-protection=\\\")%> pragma or\"\n \t      \" attribute\");\n        break;\n-     case AARCH64_PARSE_INVALID_ARG:\n+     case AARCH_PARSE_INVALID_ARG:\n        error (\"invalid protection type %qs in %<target(\\\"branch-protection\"\n \t      \"=\\\")%> pragma or attribute\", err_str);\n        break;\n-     case AARCH64_PARSE_OK:\n+     case AARCH_PARSE_OK:\n        success = true;\n       /* Fall through.  */\n-     case AARCH64_PARSE_INVALID_FEATURE:\n+     case AARCH_PARSE_INVALID_FEATURE:\n        break;\n      default:\n        gcc_unreachable ();\n@@ -18802,10 +18671,10 @@ static bool\n aarch64_handle_attr_tune (const char *str)\n {\n   const struct processor *tmp_tune = NULL;\n-  enum aarch64_parse_opt_result parse_res\n+  enum aarch_parse_opt_result parse_res\n     = aarch64_parse_tune (str, &tmp_tune);\n \n-  if (parse_res == AARCH64_PARSE_OK)\n+  if (parse_res == AARCH_PARSE_OK)\n     {\n       gcc_assert (tmp_tune);\n       selected_tune = tmp_tune->ident;\n@@ -18814,7 +18683,7 @@ aarch64_handle_attr_tune (const char *str)\n \n   switch (parse_res)\n     {\n-      case AARCH64_PARSE_INVALID_ARG:\n+      case AARCH_PARSE_INVALID_ARG:\n \terror (\"invalid name %qs in %<target(\\\"tune=\\\")%> pragma or attribute\", str);\n \taarch64_print_hint_for_core (str);\n \tbreak;\n@@ -18833,7 +18702,7 @@ aarch64_handle_attr_tune (const char *str)\n static bool\n aarch64_handle_attr_isa_flags (char *str)\n {\n-  enum aarch64_parse_opt_result parse_res;\n+  enum aarch_parse_opt_result parse_res;\n   auto isa_flags = aarch64_asm_isa_flags;\n \n   /* We allow \"+nothing\" in the beginning to clear out all architectural\n@@ -18847,19 +18716,19 @@ aarch64_handle_attr_isa_flags (char *str)\n   std::string invalid_extension;\n   parse_res = aarch64_parse_extension (str, &isa_flags, &invalid_extension);\n \n-  if (parse_res == AARCH64_PARSE_OK)\n+  if (parse_res == AARCH_PARSE_OK)\n     {\n       aarch64_set_asm_isa_flags (isa_flags);\n       return true;\n     }\n \n   switch (parse_res)\n     {\n-      case AARCH64_PARSE_MISSING_ARG:\n+      case AARCH_PARSE_MISSING_ARG:\n \terror (\"missing value in %<target()%> pragma or attribute\");\n \tbreak;\n \n-      case AARCH64_PARSE_INVALID_FEATURE:\n+      case AARCH_PARSE_INVALID_FEATURE:\n \terror (\"invalid feature modifier %qs of value %qs in \"\n \t       \"%<target()%> pragma or attribute\", invalid_extension.c_str (), str);\n \tbreak;\n@@ -19108,10 +18977,10 @@ aarch64_process_target_attr (tree args)\n \t     leading '+'.  */\n \t  aarch64_feature_flags isa_temp = 0;\n \t  auto with_plus = std::string (\"+\") + token;\n-\t  enum aarch64_parse_opt_result ext_res\n+\t  enum aarch_parse_opt_result ext_res\n \t    = aarch64_parse_extension (with_plus.c_str (), &isa_temp, nullptr);\n \n-\t  if (ext_res == AARCH64_PARSE_OK)\n+\t  if (ext_res == AARCH_PARSE_OK)\n \t    error (\"arch extension %<%s%> should be prefixed by %<+%>\",\n \t\t   token);\n \t  else\n@@ -22821,7 +22690,7 @@ aarch64_print_patchable_function_entry (FILE *file,\n \t\t\t       GEN_INT (record_p));\n   basic_block bb = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb;\n \n-  if (!aarch64_bti_enabled ()\n+  if (!aarch_bti_enabled ()\n       || cgraph_node::get (cfun->decl)->only_called_directly_p ())\n     {\n       /* Emit the patchable_area at the beginning of the function.  */\n@@ -22883,7 +22752,7 @@ void\n aarch64_post_cfi_startproc (FILE *f, tree ignored ATTRIBUTE_UNUSED)\n {\n   if (cfun->machine->frame.laid_out && aarch64_return_address_signing_enabled ()\n-      && aarch64_ra_sign_key == AARCH64_KEY_B)\n+      && aarch_ra_sign_key == AARCH_KEY_B)\n \tasm_fprintf (f, \"\\t.cfi_b_key_frame\\n\");\n }\n \n@@ -27292,10 +27161,10 @@ aarch64_file_end_indicate_exec_stack ()\n   file_end_indicate_exec_stack ();\n \n   unsigned feature_1_and = 0;\n-  if (aarch64_bti_enabled ())\n+  if (aarch_bti_enabled ())\n     feature_1_and |= GNU_PROPERTY_AARCH64_FEATURE_1_BTI;\n \n-  if (aarch64_ra_sign_scope != AARCH64_FUNCTION_NONE)\n+  if (aarch_ra_sign_scope != AARCH_FUNCTION_NONE)\n     feature_1_and |= GNU_PROPERTY_AARCH64_FEATURE_1_PAC;\n \n   if (feature_1_and)"}, {"sha": "0b326d497b47e1909d8cb2e136952253336bc333", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -891,7 +891,7 @@\n     if (aarch64_return_address_signing_enabled ()\n \t&& (TARGET_PAUTH))\n       {\n-\tif (aarch64_ra_sign_key == AARCH64_KEY_B)\n+\tif (aarch_ra_sign_key == AARCH_KEY_B)\n \t  ret = \"retab\";\n \telse\n \t  ret = \"retaa\";\n@@ -4457,8 +4457,9 @@\n   {\n     if (aarch64_sve_cnt_immediate (operands[1], <MODE>mode))\n       std::swap (operands[1], operands[2]);\n-    else if (!aarch64_sve_cnt_immediate (operands[2], <MODE>mode)\n-\t     && TARGET_CSSC)\n+    else if (aarch64_sve_cnt_immediate (operands[2], <MODE>mode))\n+      ;\n+    else if (TARGET_CSSC)\n       {\n \tif (aarch64_uminmax_immediate (operands[1], <MODE>mode))\n \t  std::swap (operands[1], operands[2]);"}, {"sha": "137e506fe19847ec1a3242ee9c9dde16e0421494", "filename": "gcc/config/aarch64/aarch64.opt", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.opt?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -21,6 +21,9 @@\n HeaderInclude\n config/aarch64/aarch64-opts.h\n \n+HeaderInclude\n+config/arm/aarch-common.h\n+\n TargetVariable\n enum aarch64_processor selected_tune = aarch64_none\n \n@@ -34,7 +37,7 @@ TargetVariable\n aarch64_feature_flags aarch64_isa_flags = 0\n \n TargetVariable\n-unsigned aarch64_enable_bti = 2\n+unsigned aarch_enable_bti = 2\n \n TargetVariable\n enum aarch64_key_type aarch64_ra_sign_key = AARCH64_KEY_A\n@@ -164,21 +167,21 @@ Target RejectNegative Joined Var(aarch64_branch_protection_string) Save\n Use branch-protection features.\n \n msign-return-address=\n-Target WarnRemoved RejectNegative Joined Enum(aarch64_ra_sign_scope_t) Var(aarch64_ra_sign_scope) Init(AARCH64_FUNCTION_NONE) Save\n+Target WarnRemoved RejectNegative Joined Enum(aarch_ra_sign_scope_t) Var(aarch_ra_sign_scope) Init(AARCH_FUNCTION_NONE) Save\n Select return address signing scope.\n \n Enum\n-Name(aarch64_ra_sign_scope_t) Type(enum aarch64_function_type)\n+Name(aarch_ra_sign_scope_t) Type(enum aarch_function_type)\n Supported AArch64 return address signing scope (for use with -msign-return-address= option):\n \n EnumValue\n-Enum(aarch64_ra_sign_scope_t) String(none) Value(AARCH64_FUNCTION_NONE)\n+Enum(aarch_ra_sign_scope_t) String(none) Value(AARCH_FUNCTION_NONE)\n \n EnumValue\n-Enum(aarch64_ra_sign_scope_t) String(non-leaf) Value(AARCH64_FUNCTION_NON_LEAF)\n+Enum(aarch_ra_sign_scope_t) String(non-leaf) Value(AARCH_FUNCTION_NON_LEAF)\n \n EnumValue\n-Enum(aarch64_ra_sign_scope_t) String(all) Value(AARCH64_FUNCTION_ALL)\n+Enum(aarch_ra_sign_scope_t) String(all) Value(AARCH_FUNCTION_ALL)\n \n mlow-precision-recip-sqrt\n Target Var(flag_mrecip_low_precision_sqrt) Optimization"}, {"sha": "eeec9f162e223df8cf7803b3227aef22e94227ac", "filename": "gcc/config/aarch64/arm_neon.h", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Faarch64%2Farm_neon.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Faarch64%2Farm_neon.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Farm_neon.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -7496,7 +7496,7 @@ vqrdmlshs_laneq_s32 (int32_t __a, int32_t __b, int32x4_t __c, const int __d)\n #pragma GCC pop_options\n \n #pragma GCC push_options\n-#pragma GCC target (\"+nothing+crypto\")\n+#pragma GCC target (\"+nothing+aes\")\n /* vaes  */\n \n __extension__ extern __inline uint8x16_t\n@@ -7526,6 +7526,22 @@ vaesimcq_u8 (uint8x16_t data)\n {\n   return __builtin_aarch64_crypto_aesimcv16qi_uu (data);\n }\n+\n+__extension__ extern __inline poly128_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vmull_p64 (poly64_t __a, poly64_t __b)\n+{\n+  return\n+    __builtin_aarch64_crypto_pmulldi_ppp (__a, __b);\n+}\n+\n+__extension__ extern __inline poly128_t\n+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n+vmull_high_p64 (poly64x2_t __a, poly64x2_t __b)\n+{\n+  return __builtin_aarch64_crypto_pmullv2di_ppp (__a, __b);\n+}\n+\n #pragma GCC pop_options\n \n /* vcage  */\n@@ -20772,7 +20788,7 @@ vrsrad_n_u64 (uint64_t __a, uint64_t __b, const int __c)\n }\n \n #pragma GCC push_options\n-#pragma GCC target (\"+nothing+crypto\")\n+#pragma GCC target (\"+nothing+sha2\")\n \n /* vsha1  */\n \n@@ -20849,21 +20865,6 @@ vsha256su1q_u32 (uint32x4_t __tw0_3, uint32x4_t __w8_11, uint32x4_t __w12_15)\n \t\t\t\t\t\t       __w12_15);\n }\n \n-__extension__ extern __inline poly128_t\n-__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n-vmull_p64 (poly64_t __a, poly64_t __b)\n-{\n-  return\n-    __builtin_aarch64_crypto_pmulldi_ppp (__a, __b);\n-}\n-\n-__extension__ extern __inline poly128_t\n-__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n-vmull_high_p64 (poly64x2_t __a, poly64x2_t __b)\n-{\n-  return __builtin_aarch64_crypto_pmullv2di_ppp (__a, __b);\n-}\n-\n #pragma GCC pop_options\n \n /* vshl */"}, {"sha": "a9a244ab6d6dda8ab6feffae2af5636e9c650b1c", "filename": "gcc/config/aarch64/t-aarch64", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Faarch64%2Ft-aarch64", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Faarch64%2Ft-aarch64", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Ft-aarch64?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -161,14 +161,14 @@ falkor-tag-collision-avoidance.o: \\\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t\t$(srcdir)/config/aarch64/falkor-tag-collision-avoidance.cc\n \n-aarch64-bti-insert.o: $(srcdir)/config/aarch64/aarch64-bti-insert.cc \\\n+aarch-bti-insert.o: $(srcdir)/config/arm/aarch-bti-insert.cc \\\n     $(CONFIG_H) $(SYSTEM_H) $(TM_H) $(REGS_H) insn-config.h $(RTL_BASE_H) \\\n     dominance.h cfg.h cfganal.h $(BASIC_BLOCK_H) $(INSN_ATTR_H) $(RECOG_H) \\\n     output.h hash-map.h $(DF_H) $(OBSTACK_H) $(TARGET_H) $(RTL_H) \\\n     $(CONTEXT_H) $(TREE_PASS_H) regrename.h \\\n     $(srcdir)/config/aarch64/aarch64-protos.h\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n-\t\t$(srcdir)/config/aarch64/aarch64-bti-insert.cc\n+\t\t$(srcdir)/config/arm/aarch-bti-insert.cc\n \n aarch64-cc-fusion.o: $(srcdir)/config/aarch64/aarch64-cc-fusion.cc \\\n     $(CONFIG_H) $(SYSTEM_H) $(CORETYPES_H) $(BACKEND_H) $(RTL_H) $(DF_H) \\"}, {"sha": "7d2f0e844f91599521d6bb1d2c41a01a8dc0dfb6", "filename": "gcc/config/alpha/linux.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Falpha%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Falpha%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Flinux.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -106,7 +106,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #undef\tENDFILE_SPEC\n #define ENDFILE_SPEC \\\n-  \"%{Ofast|ffast-math|funsafe-math-optimizations:crtfastmath.o%s} \\\n+  \"%{Ofast|ffast-math|funsafe-math-optimizations:%{!shared:crtfastmath.o%s}} \\\n    %{shared|pie:crtendS.o%s;:crtend.o%s} crtn.o%s\"\n \n #define LINK_GCC_C_SEQUENCE_SPEC \\"}, {"sha": "71a77e29406e7c65f707ee4ab65b69c81b40181f", "filename": "gcc/config/arm/aarch-bti-insert.cc", "status": "renamed", "additions": 19, "deletions": 53, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Faarch-bti-insert.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Faarch-bti-insert.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faarch-bti-insert.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -42,18 +42,20 @@\n #include \"tree-pass.h\"\n #include \"cgraph.h\"\n \n-/* This pass enables the support for Branch Target Identification Mechanism\n-   for AArch64.  This is a new security feature introduced in ARMv8.5-A\n-   archtitecture.  A BTI instruction is used to guard against the execution\n-   of instructions which are not the intended target of an indirect branch.\n+/* This pass enables the support for Branch Target Identification Mechanism for\n+   Arm/AArch64.  This is a security feature introduced in ARMv8.5-A\n+   architecture and ARMv8.1-M.  A BTI instruction is used to guard against the\n+   execution of instructions which are not the intended target of an indirect\n+   branch.\n \n    Outside of a guarded memory region, a BTI instruction executes as a NOP.\n    Within a guarded memory region any target of an indirect branch must be\n    a compatible BTI or BRK, HLT, PACIASP, PACIBASP instruction (even if the\n    branch is triggered in a non-guarded memory region).  An incompatibility\n    generates a Branch Target Exception.\n \n-   The compatibility of the BTI instruction is as follows:\n+   The compatibility of the BTI instruction is as follows (AArch64\n+   examples):\n    BTI j : Can be a target of any indirect jump (BR Xn).\n    BTI c : Can be a target of any indirect call (BLR Xn and BR X16/X17).\n    BTI jc: Can be a target of any indirect call or indirect jump.\n@@ -90,47 +92,6 @@ const pass_data pass_data_insert_bti =\n   0, /* todo_flags_finish.  */\n };\n \n-/* Check if X (or any sub-rtx of X) is a PACIASP/PACIBSP instruction.  */\n-static bool\n-aarch64_pac_insn_p (rtx x)\n-{\n-  if (!INSN_P (x))\n-    return false;\n-\n-  subrtx_var_iterator::array_type array;\n-  FOR_EACH_SUBRTX_VAR (iter, array, PATTERN (x), ALL)\n-    {\n-      rtx sub = *iter;\n-      if (sub && GET_CODE (sub) == UNSPEC)\n-\t{\n-\t  int unspec_val = XINT (sub, 1);\n-\t  switch (unspec_val)\n-\t    {\n-\t    case UNSPEC_PACIASP:\n-            /* fall-through.  */\n-            case UNSPEC_PACIBSP:\n-\t      return true;\n-\n-\t    default:\n-\t      return false;\n-\t    }\n-\t  iter.skip_subrtxes ();\n-\t}\n-    }\n-  return false;\n-}\n-\n-/* Check if INSN is a BTI J insn.  */\n-static bool\n-aarch64_bti_j_insn_p (rtx_insn *insn)\n-{\n-  if (!insn || !INSN_P (insn))\n-    return false;\n-\n-  rtx pat = PATTERN (insn);\n-  return GET_CODE (pat) == UNSPEC_VOLATILE && XINT (pat, 1) == UNSPECV_BTI_J;\n-}\n-\n /* Insert the BTI instruction.  */\n /* This is implemented as a late RTL pass that runs before branch\n    shortening and does the following.  */\n@@ -155,7 +116,7 @@ rest_of_insert_bti (void)\n \t       && (LABEL_PRESERVE_P (insn)\n \t\t   || bb->flags & BB_NON_LOCAL_GOTO_TARGET))\n \t    {\n-\t      bti_insn = gen_bti_j ();\n+\t      bti_insn = aarch_gen_bti_j ();\n \t      emit_insn_after (bti_insn, insn);\n \t      continue;\n \t    }\n@@ -177,10 +138,10 @@ rest_of_insert_bti (void)\n \t\t    {\n \t\t      label = as_a <rtx_insn *> (XEXP (RTVEC_ELT (vec, j), 0));\n \t\t      rtx_insn *next = next_nonnote_nondebug_insn (label);\n-\t\t      if (aarch64_bti_j_insn_p (next))\n+\t\t      if (aarch_bti_j_insn_p (next))\n \t\t\tcontinue;\n \n-\t\t      bti_insn = gen_bti_j ();\n+\t\t      bti_insn = aarch_gen_bti_j ();\n \t\t      emit_insn_after (bti_insn, label);\n \t\t    }\n \t\t}\n@@ -191,7 +152,7 @@ rest_of_insert_bti (void)\n \t     will return.  */\n \t  if (CALL_P (insn) && (find_reg_note (insn, REG_SETJMP, NULL)))\n \t    {\n-\t      bti_insn = gen_bti_j ();\n+\t      bti_insn = aarch_gen_bti_j ();\n \t      emit_insn_after (bti_insn, insn);\n \t      continue;\n \t    }\n@@ -207,9 +168,9 @@ rest_of_insert_bti (void)\n     {\n       bb = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb;\n       insn = BB_HEAD (bb);\n-      if (!aarch64_pac_insn_p (get_first_nonnote_insn ()))\n+      if (!aarch_pac_insn_p (get_first_nonnote_insn ()))\n \t{\n-\t  bti_insn = gen_bti_c ();\n+\t  bti_insn = aarch_gen_bti_c ();\n \t  emit_insn_before (bti_insn, insn);\n \t}\n     }\n@@ -229,7 +190,12 @@ class pass_insert_bti : public rtl_opt_pass\n   /* opt_pass methods: */\n   virtual bool gate (function *)\n     {\n-      return aarch64_bti_enabled ();\n+      if (aarch_bti_enabled ())\n+        {\n+          aarch_bti_arch_check ();\n+          return true;\n+        }\n+      return false;\n     }\n \n   virtual unsigned int execute (function *)", "previous_filename": "gcc/config/aarch64/aarch64-bti-insert.cc"}, {"sha": "f8cb656209602be63f6dcc9297f2b2561e9ab424", "filename": "gcc/config/arm/aarch-common-protos.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Faarch-common-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Faarch-common-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faarch-common-protos.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -42,6 +42,12 @@ extern int arm_no_early_alu_shift_value_dep (rtx, rtx);\n extern int arm_no_early_mul_dep (rtx, rtx);\n extern int arm_no_early_store_addr_dep (rtx, rtx);\n extern bool arm_rtx_shift_left_p (rtx);\n+extern void aarch_bti_arch_check (void);\n+extern bool aarch_bti_enabled (void);\n+extern bool aarch_bti_j_insn_p (rtx_insn *);\n+extern bool aarch_pac_insn_p (rtx);\n+extern rtx aarch_gen_bti_c (void);\n+extern rtx aarch_gen_bti_j (void);\n \n /* RTX cost table definitions.  These are used when tuning for speed rather\n    than for size and should reflect the _additional_ cost over the cost\n@@ -153,4 +159,10 @@ rtx_insn *arm_md_asm_adjust (vec<rtx> &outputs, vec<rtx> & /*inputs*/,\n \t\t\t     vec<rtx> &clobbers, HARD_REG_SET &clobbered_regs,\n \t\t\t     location_t loc);\n \n+/* Parsing routine for branch-protection common to AArch64 and Arm.  */\n+enum aarch_parse_opt_result aarch_parse_branch_protection (const char*, char**);\n+\n+/* Validation routine for branch-protection common to AArch64 and Arm.  */\n+bool aarch_validate_mbranch_protection (const char *);\n+\n #endif /* GCC_AARCH_COMMON_PROTOS_H */"}, {"sha": "27e6c8f39b47c8a366c7e5767ca49c184a0ddb76", "filename": "gcc/config/arm/aarch-common.cc", "status": "modified", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Faarch-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Faarch-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faarch-common.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -36,6 +36,7 @@\n #include \"expr.h\"\n #include \"function.h\"\n #include \"emit-rtl.h\"\n+#include \"aarch-common.h\"\n \n /* Return TRUE if X is either an arithmetic shift left, or\n    is a multiplication by a power of two.  */\n@@ -657,3 +658,187 @@ arm_md_asm_adjust (vec<rtx> &outputs, vec<rtx> & /*inputs*/,\n \n   return saw_asm_flag ? seq : NULL;\n }\n+\n+#define BRANCH_PROTECT_STR_MAX 255\n+extern char *accepted_branch_protection_string;\n+extern enum aarch_key_type aarch_ra_sign_key;\n+\n+static enum aarch_parse_opt_result\n+aarch_handle_no_branch_protection (char* str, char* rest)\n+{\n+  aarch_ra_sign_scope = AARCH_FUNCTION_NONE;\n+  aarch_enable_bti = 0;\n+  if (rest)\n+    {\n+      error (\"unexpected %<%s%> after %<%s%>\", rest, str);\n+      return AARCH_PARSE_INVALID_FEATURE;\n+    }\n+  return AARCH_PARSE_OK;\n+}\n+\n+static enum aarch_parse_opt_result\n+aarch_handle_standard_branch_protection (char* str, char* rest)\n+{\n+  aarch_ra_sign_scope = AARCH_FUNCTION_NON_LEAF;\n+  aarch_ra_sign_key = AARCH_KEY_A;\n+  aarch_enable_bti = 1;\n+  if (rest)\n+    {\n+      error (\"unexpected %<%s%> after %<%s%>\", rest, str);\n+      return AARCH_PARSE_INVALID_FEATURE;\n+    }\n+  return AARCH_PARSE_OK;\n+}\n+\n+static enum aarch_parse_opt_result\n+aarch_handle_pac_ret_protection (char* str ATTRIBUTE_UNUSED,\n+\t\t\t\t char* rest ATTRIBUTE_UNUSED)\n+{\n+  aarch_ra_sign_scope = AARCH_FUNCTION_NON_LEAF;\n+  aarch_ra_sign_key = AARCH_KEY_A;\n+  return AARCH_PARSE_OK;\n+}\n+\n+static enum aarch_parse_opt_result\n+aarch_handle_pac_ret_leaf (char* str ATTRIBUTE_UNUSED,\n+\t\t\t   char* rest ATTRIBUTE_UNUSED)\n+{\n+  aarch_ra_sign_scope = AARCH_FUNCTION_ALL;\n+  return AARCH_PARSE_OK;\n+}\n+\n+static enum aarch_parse_opt_result\n+aarch_handle_pac_ret_b_key (char* str ATTRIBUTE_UNUSED,\n+\t\t\t    char* rest ATTRIBUTE_UNUSED)\n+{\n+  aarch_ra_sign_key = AARCH_KEY_B;\n+  return AARCH_PARSE_OK;\n+}\n+\n+static enum aarch_parse_opt_result\n+aarch_handle_bti_protection (char* str ATTRIBUTE_UNUSED,\n+\t\t\t     char* rest ATTRIBUTE_UNUSED)\n+{\n+  aarch_enable_bti = 1;\n+  return AARCH_PARSE_OK;\n+}\n+\n+static const struct aarch_branch_protect_type aarch_pac_ret_subtypes[] = {\n+  { \"leaf\", aarch_handle_pac_ret_leaf, NULL, 0 },\n+  { \"b-key\", aarch_handle_pac_ret_b_key, NULL, 0 },\n+  { NULL, NULL, NULL, 0 }\n+};\n+\n+static const struct aarch_branch_protect_type aarch_branch_protect_types[] = {\n+  { \"none\", aarch_handle_no_branch_protection, NULL, 0 },\n+  { \"standard\", aarch_handle_standard_branch_protection, NULL, 0 },\n+  { \"pac-ret\", aarch_handle_pac_ret_protection, aarch_pac_ret_subtypes,\n+    ARRAY_SIZE (aarch_pac_ret_subtypes) },\n+  { \"bti\", aarch_handle_bti_protection, NULL, 0 },\n+  { NULL, NULL, NULL, 0 }\n+};\n+\n+/* Parses CONST_STR for branch protection features specified in\n+   aarch64_branch_protect_types, and set any global variables required.  Returns\n+   the parsing result and assigns LAST_STR to the last processed token from\n+   CONST_STR so that it can be used for error reporting.  */\n+\n+enum aarch_parse_opt_result\n+aarch_parse_branch_protection (const char *const_str, char** last_str)\n+{\n+  char *str_root = xstrdup (const_str);\n+  char* token_save = NULL;\n+  char *str = strtok_r (str_root, \"+\", &token_save);\n+  enum aarch_parse_opt_result res = AARCH_PARSE_OK;\n+  if (!str)\n+    res = AARCH_PARSE_MISSING_ARG;\n+  else\n+    {\n+      char *next_str = strtok_r (NULL, \"+\", &token_save);\n+      /* Reset the branch protection features to their defaults.  */\n+      aarch_handle_no_branch_protection (NULL, NULL);\n+\n+      while (str && res == AARCH_PARSE_OK)\n+\t{\n+\t  const aarch_branch_protect_type* type = aarch_branch_protect_types;\n+\t  bool found = false;\n+\t  /* Search for this type.  */\n+\t  while (type && type->name && !found && res == AARCH_PARSE_OK)\n+\t    {\n+\t      if (strcmp (str, type->name) == 0)\n+\t\t{\n+\t\t  found = true;\n+\t\t  res = type->handler (str, next_str);\n+\t\t  str = next_str;\n+\t\t  next_str = strtok_r (NULL, \"+\", &token_save);\n+\t\t}\n+\t      else\n+\t\ttype++;\n+\t    }\n+\t  if (found && res == AARCH_PARSE_OK)\n+\t    {\n+\t      bool found_subtype = true;\n+\t      /* Loop through each token until we find one that isn't a\n+\t\t subtype.  */\n+\t      while (found_subtype)\n+\t\t{\n+\t\t  found_subtype = false;\n+\t\t  const aarch_branch_protect_type *subtype = type->subtypes;\n+\t\t  /* Search for the subtype.  */\n+\t\t  while (str && subtype && subtype->name && !found_subtype\n+\t\t\t  && res == AARCH_PARSE_OK)\n+\t\t    {\n+\t\t      if (strcmp (str, subtype->name) == 0)\n+\t\t\t{\n+\t\t\t  found_subtype = true;\n+\t\t\t  res = subtype->handler (str, next_str);\n+\t\t\t  str = next_str;\n+\t\t\t  next_str = strtok_r (NULL, \"+\", &token_save);\n+\t\t\t}\n+\t\t      else\n+\t\t\tsubtype++;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  else if (!found)\n+\t    res = AARCH_PARSE_INVALID_ARG;\n+\t}\n+    }\n+  /* Copy the last processed token into the argument to pass it back.\n+    Used by option and attribute validation to print the offending token.  */\n+  if (last_str)\n+    {\n+      if (str)\n+\tstrcpy (*last_str, str);\n+      else\n+\t*last_str = NULL;\n+    }\n+\n+  if (res == AARCH_PARSE_OK)\n+    {\n+      /* If needed, alloc the accepted string then copy in const_str.\n+\tUsed by override_option_after_change_1.  */\n+      if (!accepted_branch_protection_string)\n+\taccepted_branch_protection_string\n+\t  = (char *) xmalloc (BRANCH_PROTECT_STR_MAX + 1);\n+      strncpy (accepted_branch_protection_string, const_str,\n+\t       BRANCH_PROTECT_STR_MAX + 1);\n+      /* Forcibly null-terminate.  */\n+      accepted_branch_protection_string[BRANCH_PROTECT_STR_MAX] = '\\0';\n+    }\n+  return res;\n+}\n+\n+bool\n+aarch_validate_mbranch_protection (const char *const_str)\n+{\n+  char *str = (char *) xmalloc (strlen (const_str));\n+  enum aarch_parse_opt_result res =\n+    aarch_parse_branch_protection (const_str, &str);\n+  if (res == AARCH_PARSE_INVALID_ARG)\n+    error (\"invalid argument %<%s%> for %<-mbranch-protection=%>\", str);\n+  else if (res == AARCH_PARSE_MISSING_ARG)\n+    error (\"missing argument for %<-mbranch-protection=%>\");\n+  free (str);\n+  return res == AARCH_PARSE_OK;\n+}"}, {"sha": "c6a67f0d05cc75d85d019e1cc910c37173884c03", "filename": "gcc/config/arm/aarch-common.h", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Faarch-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Faarch-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faarch-common.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -0,0 +1,73 @@\n+/* Types shared between arm and aarch64.\n+\n+   Copyright (C) 2009-2021 Free Software Foundation, Inc.\n+   Contributed by Arm Ltd.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_AARCH_COMMON_H\n+#define GCC_AARCH_COMMON_H\n+\n+/* Enum describing the various ways that the\n+   aarch*_parse_{arch,tune,cpu,extension} functions can fail.\n+   This way their callers can choose what kind of error to give.  */\n+\n+enum aarch_parse_opt_result\n+{\n+  AARCH_PARSE_OK,\t\t\t/* Parsing was successful.  */\n+  AARCH_PARSE_MISSING_ARG,\t\t/* Missing argument.  */\n+  AARCH_PARSE_INVALID_FEATURE,\t\t/* Invalid feature modifier.  */\n+  AARCH_PARSE_INVALID_ARG\t\t/* Invalid arch, tune, cpu arg.  */\n+};\n+\n+/* Function types -msign-return-address should sign.  */\n+enum aarch_function_type {\n+  /* Don't sign any function.  */\n+  AARCH_FUNCTION_NONE,\n+  /* Non-leaf functions.  */\n+  AARCH_FUNCTION_NON_LEAF,\n+  /* All functions.  */\n+  AARCH_FUNCTION_ALL\n+};\n+\n+/* The key type that -msign-return-address should use.  */\n+enum aarch_key_type {\n+  AARCH_KEY_A,\n+  AARCH_KEY_B\n+};\n+\n+struct aarch_branch_protect_type\n+{\n+  /* The type's name that the user passes to the branch-protection option\n+     string.  */\n+  const char* name;\n+  /* Function to handle the protection type and set global variables.\n+     First argument is the string token corresponding with this type and the\n+     second argument is the next token in the option string.\n+     Return values:\n+     * AARCH_PARSE_OK: Handling was sucessful.\n+     * AARCH_INVALID_ARG: The type is invalid in this context and the caller\n+     should print an error.\n+     * AARCH_INVALID_FEATURE: The type is invalid and the handler prints its\n+     own error.  */\n+  enum aarch_parse_opt_result (*handler)(char*, char*);\n+  /* A list of types that can follow this type in the option string.  */\n+  const struct aarch_branch_protect_type* subtypes;\n+  unsigned int num_subtypes;\n+};\n+\n+#endif /* GCC_AARCH_COMMON_H */"}, {"sha": "57c3b9b7b8b02f15e191ffcb9446f0edf27bbce6", "filename": "gcc/config/arm/aout.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Faout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Faout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faout.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -74,7 +74,8 @@\n   \"wr8\",   \"wr9\",   \"wr10\",  \"wr11\",\t\t\t\t\\\n   \"wr12\",  \"wr13\",  \"wr14\",  \"wr15\",\t\t\t\t\\\n   \"wcgr0\", \"wcgr1\", \"wcgr2\", \"wcgr3\",\t\t\t\t\\\n-  \"cc\", \"vfpcc\", \"sfp\", \"afp\", \"apsrq\", \"apsrge\", \"p0\"\t\t\\\n+  \"cc\", \"vfpcc\", \"sfp\", \"afp\", \"apsrq\", \"apsrge\", \"p0\",\t\t\\\n+  \"ra_auth_code\"\t\t\t\t\t\t\\\n }\n #endif\n "}, {"sha": "59c0d8ce747a72050a5ae0431564735ff59fad52", "filename": "gcc/config/arm/arm-c.cc", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Farm-c.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Farm-c.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-c.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -214,6 +214,24 @@ arm_cpu_builtins (struct cpp_reader* pfile)\n   def_or_undef_macro (pfile, \"__ARM_FEATURE_COMPLEX\", TARGET_COMPLEX);\n   def_or_undef_macro (pfile, \"__ARM_32BIT_STATE\", TARGET_32BIT);\n \n+  def_or_undef_macro (pfile, \"__ARM_FEATURE_PAUTH\", TARGET_HAVE_PACBTI);\n+  def_or_undef_macro (pfile, \"__ARM_FEATURE_BTI\", TARGET_HAVE_PACBTI);\n+  def_or_undef_macro (pfile, \"__ARM_FEATURE_BTI_DEFAULT\",\n+\t\t      aarch_enable_bti == 1);\n+\n+  cpp_undef (pfile, \"__ARM_FEATURE_PAC_DEFAULT\");\n+  if (aarch_ra_sign_scope != AARCH_FUNCTION_NONE)\n+  {\n+    unsigned int pac = 1;\n+\n+    gcc_assert (aarch_ra_sign_key == AARCH_KEY_A);\n+\n+    if (aarch_ra_sign_scope == AARCH_FUNCTION_ALL)\n+      pac |= 0x4;\n+\n+    builtin_define_with_int_value (\"__ARM_FEATURE_PAC_DEFAULT\", pac);\n+  }\n+\n   cpp_undef (pfile, \"__ARM_FEATURE_MVE\");\n   if (TARGET_HAVE_MVE && TARGET_HAVE_MVE_FLOAT)\n     {"}, {"sha": "f1fa3fa174ced6d479e1b339aea80a65eb765667", "filename": "gcc/config/arm/arm-cpus.in", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Farm-cpus.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Farm-cpus.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-cpus.in?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -229,6 +229,10 @@ define feature cdecp5\n define feature cdecp6\n define feature cdecp7\n \n+# M-profile control flow integrity extensions (PAC/AUT/BTI).\n+# Optional from Armv8.1-M Mainline.\n+define feature pacbti\n+\n # Feature groups.  Conventionally all (or mostly) upper case.\n # ALL_FPU lists all the feature bits associated with the floating-point\n # unit; these will all be removed if the floating-point unit is disabled\n@@ -743,6 +747,7 @@ begin arch armv8.1-m.main\n  isa ARMv8_1m_main\n # fp => FPv5-sp-d16; fp.dp => FPv5-d16\n  option dsp add armv7em\n+ option pacbti add pacbti\n  option fp add FPv5 fp16\n  option fp.dp add FPv5 FP_DBL fp16\n  option nofp remove ALL_FP\n@@ -1667,6 +1672,21 @@ begin cpu star-mc1\n  costs v7m\n end cpu star-mc1\n \n+begin cpu cortex-m85\n+ cname cortexm85\n+ tune flags LDSCHED\n+ architecture armv8.1-m.main+pacbti+mve.fp+fp.dp\n+ option nopacbti remove pacbti\n+ option nomve.fp remove mve_float\n+ option nomve remove mve mve_float\n+ option nofp remove ALL_FP mve_float\n+ option nodsp remove MVE mve_float\n+ isa quirk_no_asmcpu quirk_vlldm\n+ costs v7m\n+ part 0xd23\n+ vendor 41\n+end cpu cortex-m85\n+\n # V8 R-profile implementations.\n begin cpu cortex-r52\n  cname cortexr52"}, {"sha": "02cfba0ba24f856c3c4378875d37553c484c1898", "filename": "gcc/config/arm/arm-mlib.h", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Farm-mlib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Farm-mlib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-mlib.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -0,0 +1,22 @@\n+/* Arm multilib default option include file.\n+\n+   Copyright (C) 2023 Free Software Foundation, Inc.\n+   Contributed by Arm.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#define MULTILIB_DEFAULTS { \"mbranch-protection=none\" }"}, {"sha": "71d6b56364002b8635d9d68df7ac02ae9bc4d02f", "filename": "gcc/config/arm/arm-passes.def", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Farm-passes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Farm-passes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-passes.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -0,0 +1,21 @@\n+/* Arm-specific passes declarations.\n+   Copyright (C) 2022 Free Software Foundation, Inc.\n+   Contributed by Arm Ltd.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+INSERT_PASS_BEFORE (pass_shorten_branches, 1, pass_insert_bti);"}, {"sha": "aea472bfbb9deaa8e925756963c7c5cc6fdc0d09", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -24,6 +24,8 @@\n \n #include \"sbitmap.h\"\n \n+rtl_opt_pass *make_pass_insert_bti (gcc::context *ctxt);\n+\n extern enum unwind_info_type arm_except_unwind_info (struct gcc_options *);\n extern int use_return_insn (int, rtx);\n extern bool use_simple_return_p (void);\n@@ -379,6 +381,7 @@ extern int vfp3_const_double_for_bits (rtx);\n extern void arm_emit_coreregs_64bit_shift (enum rtx_code, rtx, rtx, rtx, rtx,\n \t\t\t\t\t   rtx);\n extern bool arm_fusion_enabled_p (tune_params::fuse_ops);\n+extern bool arm_current_function_pac_enabled_p (void);\n extern bool arm_valid_symbolic_address_p (rtx);\n extern bool arm_validize_comparison (rtx *, rtx *, rtx *);\n extern bool arm_expand_vector_compare (rtx, rtx_code, rtx, rtx, bool);\n@@ -582,6 +585,8 @@ struct cpu_option\n extern const arch_option all_architectures[];\n extern const cpu_option all_cores[];\n \n+extern enum aarch_key_type aarch_ra_sign_key;\n+\n const cpu_option *arm_parse_cpu_option_name (const cpu_option *, const char *,\n \t\t\t\t\t     const char *, bool = true);\n const arch_option *arm_parse_arch_option_name (const arch_option *,"}, {"sha": "88909c2698edbe937b73286340798b492013f470", "filename": "gcc/config/arm/arm-tables.opt", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Farm-tables.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Farm-tables.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-tables.opt?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -288,6 +288,9 @@ Enum(processor_type) String(cortex-m55) Value( TARGET_CPU_cortexm55)\n EnumValue\n Enum(processor_type) String(star-mc1) Value( TARGET_CPU_starmc1)\n \n+EnumValue\n+Enum(processor_type) String(cortex-m85) Value( TARGET_CPU_cortexm85)\n+\n EnumValue\n Enum(processor_type) String(cortex-r52) Value( TARGET_CPU_cortexr52)\n "}, {"sha": "5e95e827911aecdc5713c860b907bf321c6f3d2c", "filename": "gcc/config/arm/arm-tune.md", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Farm-tune.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Farm-tune.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-tune.md?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -46,9 +46,10 @@\n \tcortexa73cortexa53,cortexa55,cortexa75,\n \tcortexa76,cortexa76ae,cortexa77,\n \tcortexa78,cortexa78ae,cortexa78c,\n-\tcortexa710,cortexx1,cortexx1c,neoversen1,\n-\tcortexa75cortexa55,cortexa76cortexa55,neoversev1,\n-\tneoversen2,cortexm23,cortexm33,\n-\tcortexm35p,cortexm55,starmc1,\n-\tcortexr52,cortexr52plus\"\n+\tcortexa710,cortexx1,cortexx1c,\n+\tneoversen1,cortexa75cortexa55,cortexa76cortexa55,\n+\tneoversev1,neoversen2,cortexm23,\n+\tcortexm33,cortexm35p,cortexm55,\n+\tstarmc1,cortexm85,cortexr52,\n+\tcortexr52plus\"\n \t(const (symbol_ref \"((enum attr_tune) arm_tune)\")))"}, {"sha": "efc48349dd3508e6790c1a9f3bba5da689a986bc", "filename": "gcc/config/arm/arm.cc", "status": "modified", "additions": 233, "deletions": 21, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Farm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Farm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -72,6 +72,8 @@\n #include \"selftest.h\"\n #include \"tree-vectorizer.h\"\n #include \"opts.h\"\n+#include \"aarch-common.h\"\n+#include \"aarch-common-protos.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -921,6 +923,11 @@ int arm_arch8_3 = 0;\n \n /* Nonzero if this chip supports the ARM Architecture 8.4 extensions.  */\n int arm_arch8_4 = 0;\n+\n+/* Nonzero if this chip supports the ARM Architecture 8-M Mainline\n+   extensions.  */\n+int arm_arch8m_main = 0;\n+\n /* Nonzero if this chip supports the ARM Architecture 8.1-M Mainline\n    extensions.  */\n int arm_arch8_1m_main = 0;\n@@ -2413,6 +2420,11 @@ const struct tune_params arm_fa726te_tune =\n   tune_params::SCHED_AUTOPREF_OFF\n };\n \n+/* Key type for Pointer Authentication extension.  */\n+enum aarch_key_type aarch_ra_sign_key = AARCH_KEY_A;\n+\n+char *accepted_branch_protection_string = NULL;\n+\n /* Auto-generated CPU, FPU and architecture tables.  */\n #include \"arm-cpu-data.h\"\n \n@@ -3198,6 +3210,15 @@ arm_option_override_internal (struct gcc_options *opts,\n       arm_stack_protector_guard_offset = offs;\n     }\n \n+  if (arm_current_function_pac_enabled_p ())\n+    {\n+      if (!arm_arch8m_main)\n+        error (\"This architecture does not support branch protection \"\n+               \"instructions\");\n+      if (TARGET_TPCS_FRAME)\n+        sorry (\"Return address signing is not supported with %<-mtpcs-frame%>.\");\n+    }\n+\n #ifdef SUBTARGET_OVERRIDE_INTERNAL_OPTIONS\n   SUBTARGET_OVERRIDE_INTERNAL_OPTIONS;\n #endif\n@@ -3252,6 +3273,17 @@ arm_configure_build_target (struct arm_build_target *target,\n       tune_opts = strchr (opts->x_arm_tune_string, '+');\n     }\n \n+  if (opts->x_arm_branch_protection_string)\n+    {\n+      aarch_validate_mbranch_protection (opts->x_arm_branch_protection_string);\n+\n+      if (aarch_ra_sign_key != AARCH_KEY_A)\n+\t{\n+\t  warning (0, \"invalid key type for %<-mbranch-protection=%>\");\n+\t  aarch_ra_sign_key = AARCH_KEY_A;\n+\t}\n+    }\n+\n   if (arm_selected_arch)\n     {\n       arm_initialize_isa (target->isa, arm_selected_arch->common.isa_bits);\n@@ -3833,6 +3865,7 @@ arm_option_reconfigure_globals (void)\n   arm_arch_arm_hwdiv = bitmap_bit_p (arm_active_target.isa, isa_bit_adiv);\n   arm_arch_crc = bitmap_bit_p (arm_active_target.isa, isa_bit_crc32);\n   arm_arch_cmse = bitmap_bit_p (arm_active_target.isa, isa_bit_cmse);\n+  arm_arch8m_main = arm_arch7 && arm_arch_cmse;\n   arm_arch_lpae = bitmap_bit_p (arm_active_target.isa, isa_bit_lpae);\n   arm_arch_i8mm = bitmap_bit_p (arm_active_target.isa, isa_bit_i8mm);\n   arm_arch_bf16 = bitmap_bit_p (arm_active_target.isa, isa_bit_bf16);\n@@ -4332,6 +4365,12 @@ use_return_insn (int iscond, rtx sibling)\n   if (!reload_completed)\n     return 0;\n \n+  /* Never use a return instruction when return address signing\n+     mechanism is enabled as it requires more than one\n+     instruction.  */\n+  if (arm_current_function_pac_enabled_p ())\n+    return 0;\n+\n   func_type = arm_current_func_type ();\n \n   /* Naked, volatile and stack alignment functions need special\n@@ -21227,6 +21266,9 @@ arm_compute_save_core_reg_mask (void)\n \n   save_reg_mask |= arm_compute_save_reg0_reg12_mask ();\n \n+  if (arm_current_function_pac_enabled_p ())\n+    save_reg_mask |= 1 << IP_REGNUM;\n+\n   /* Decide if we need to save the link register.\n      Interrupt routines have their own banked link register,\n      so they never need to save it.\n@@ -22230,7 +22272,33 @@ emit_multi_reg_push (unsigned long mask, unsigned long dwarf_regs_mask)\n     {\n       if (mask & (1 << i))\n \t{\n-\t  reg = gen_rtx_REG (SImode, i);\n+\t  /* NOTE: Dwarf code emitter handle reg-reg copies correctly and in the\n+\t     following example reg-reg copy of SP to IP register is handled\n+\t     through .cfi_def_cfa_register directive and the .cfi_offset\n+\t     directive for IP register is skipped by dwarf code emitter.\n+\t     Example:\n+\t\tmov     ip, sp\n+\t\t.cfi_def_cfa_register 12\n+\t\tpush    {fp, ip, lr, pc}\n+\t\t.cfi_offset 11, -16\n+\t\t.cfi_offset 13, -12\n+\t\t.cfi_offset 14, -8\n+\n+\t     Where as Arm-specific .save directive handling is different to that\n+\t     of dwarf code emitter and it doesn't consider reg-reg copies while\n+\t     updating the register list.  When PACBTI is enabled we manually\n+\t     updated the .save directive register list to use \"ra_auth_code\"\n+\t     (pseduo register 143) instead of IP register as shown in following\n+\t     pseduo code.\n+\t     Example:\n+\t\tpacbti  ip, lr, sp\n+\t\t.cfi_register 143, 12\n+\t\tpush    {r3, r7, ip, lr}\n+\t\t.save {r3, r7, ra_auth_code, lr}\n+\t  */\n+\t  rtx dwarf_reg = reg = gen_rtx_REG (SImode, i);\n+\t  if (arm_current_function_pac_enabled_p () && i == IP_REGNUM)\n+\t    dwarf_reg = gen_rtx_REG (SImode, RA_AUTH_CODE);\n \n \t  XVECEXP (par, 0, 0)\n \t    = gen_rtx_SET (gen_frame_mem\n@@ -22248,7 +22316,7 @@ emit_multi_reg_push (unsigned long mask, unsigned long dwarf_regs_mask)\n \t  if (dwarf_regs_mask & (1 << i))\n \t    {\n \t      tmp = gen_rtx_SET (gen_frame_mem (SImode, stack_pointer_rtx),\n-\t\t\t\t reg);\n+\t\t\t\t dwarf_reg);\n \t      RTX_FRAME_RELATED_P (tmp) = 1;\n \t      XVECEXP (dwarf, 0, dwarf_par_index++) = tmp;\n \t    }\n@@ -22261,7 +22329,9 @@ emit_multi_reg_push (unsigned long mask, unsigned long dwarf_regs_mask)\n     {\n       if (mask & (1 << i))\n \t{\n-\t  reg = gen_rtx_REG (SImode, i);\n+\t  rtx dwarf_reg = reg = gen_rtx_REG (SImode, i);\n+\t  if (arm_current_function_pac_enabled_p () && i == IP_REGNUM)\n+\t    dwarf_reg = gen_rtx_REG (SImode, RA_AUTH_CODE);\n \n \t  XVECEXP (par, 0, j) = gen_rtx_USE (VOIDmode, reg);\n \n@@ -22272,7 +22342,7 @@ emit_multi_reg_push (unsigned long mask, unsigned long dwarf_regs_mask)\n \t\t\t       (SImode,\n \t\t\t\tplus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t       4 * j)),\n-\t\t\t       reg);\n+\t\t\t       dwarf_reg);\n \t      RTX_FRAME_RELATED_P (tmp) = 1;\n \t      XVECEXP (dwarf, 0, dwarf_par_index++) = tmp;\n \t    }\n@@ -22357,15 +22427,18 @@ arm_emit_multi_reg_pop (unsigned long saved_regs_mask)\n   for (j = 0, i = 0; j < num_regs; i++)\n     if (saved_regs_mask & (1 << i))\n       {\n-        reg = gen_rtx_REG (SImode, i);\n+\trtx dwarf_reg = reg = gen_rtx_REG (SImode, i);\n+\tif (arm_current_function_pac_enabled_p () && i == IP_REGNUM)\n+\t  dwarf_reg = gen_rtx_REG (SImode, RA_AUTH_CODE);\n         if ((num_regs == 1) && emit_update && !return_in_pc)\n           {\n             /* Emit single load with writeback.  */\n             tmp = gen_frame_mem (SImode,\n                                  gen_rtx_POST_INC (Pmode,\n                                                    stack_pointer_rtx));\n             tmp = emit_insn (gen_rtx_SET (reg, tmp));\n-            REG_NOTES (tmp) = alloc_reg_note (REG_CFA_RESTORE, reg, dwarf);\n+\t    REG_NOTES (tmp) = alloc_reg_note (REG_CFA_RESTORE, dwarf_reg,\n+\t\t\t\t\t      dwarf);\n             return;\n           }\n \n@@ -22379,7 +22452,7 @@ arm_emit_multi_reg_pop (unsigned long saved_regs_mask)\n         /* We need to maintain a sequence for DWARF info too.  As dwarf info\n            should not have PC, skip PC.  */\n         if (i != PC_REGNUM)\n-          dwarf = alloc_reg_note (REG_CFA_RESTORE, reg, dwarf);\n+\t  dwarf = alloc_reg_note (REG_CFA_RESTORE, dwarf_reg, dwarf);\n \n         j++;\n       }\n@@ -23518,12 +23591,13 @@ arm_expand_prologue (void)\n \n   /* The static chain register is the same as the IP register.  If it is\n      clobbered when creating the frame, we need to save and restore it.  */\n-  clobber_ip = IS_NESTED (func_type)\n-\t       && ((TARGET_APCS_FRAME && frame_pointer_needed && TARGET_ARM)\n-\t\t   || ((flag_stack_check == STATIC_BUILTIN_STACK_CHECK\n-\t\t\t|| flag_stack_clash_protection)\n-\t\t       && !df_regs_ever_live_p (LR_REGNUM)\n-\t\t       && arm_r3_live_at_start_p ()));\n+  clobber_ip = (IS_NESTED (func_type)\n+                && (((TARGET_APCS_FRAME && frame_pointer_needed && TARGET_ARM)\n+                     || ((flag_stack_check == STATIC_BUILTIN_STACK_CHECK\n+                          || flag_stack_clash_protection)\n+                         && !df_regs_ever_live_p (LR_REGNUM)\n+                         && arm_r3_live_at_start_p ()))\n+                    || arm_current_function_pac_enabled_p ()));\n \n   /* Find somewhere to store IP whilst the frame is being created.\n      We try the following places in order:\n@@ -23548,7 +23622,6 @@ arm_expand_prologue (void)\n \t{\n \t  rtx addr, dwarf;\n \n-\t  gcc_assert(arm_compute_static_chain_stack_bytes() == 4);\n \t  saved_regs += 4;\n \n \t  addr = gen_rtx_PRE_DEC (Pmode, stack_pointer_rtx);\n@@ -23561,6 +23634,8 @@ arm_expand_prologue (void)\n \t\t\t\t\t      -fp_offset));\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \t  add_reg_note (insn, REG_FRAME_RELATED_EXPR, dwarf);\n+\t  if (arm_current_function_pac_enabled_p ())\n+\t    cfun->machine->pacspval_needed = 1;\n \t}\n       else\n \t{\n@@ -23596,9 +23671,26 @@ arm_expand_prologue (void)\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \t  fp_offset = args_to_push;\n \t  args_to_push = 0;\n+\t  if (arm_current_function_pac_enabled_p ())\n+\t    cfun->machine->pacspval_needed = 1;\n \t}\n     }\n \n+  if (arm_current_function_pac_enabled_p ())\n+    {\n+      /* If IP was clobbered we only emit a PAC instruction as the BTI\n+         one will be added before the push of the clobbered IP (if\n+         necessary) by the bti pass.  */\n+      if (aarch_bti_enabled () && !clobber_ip)\n+\tinsn = emit_insn (gen_pacbti_nop ());\n+      else\n+\tinsn = emit_insn (gen_pac_nop ());\n+\n+      rtx dwarf = gen_rtx_SET (ip_rtx, gen_rtx_REG (SImode, RA_AUTH_CODE));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      add_reg_note (insn, REG_CFA_REGISTER, dwarf);\n+    }\n+\n   if (TARGET_APCS_FRAME && frame_pointer_needed && TARGET_ARM)\n     {\n       if (IS_INTERRUPT (func_type))\n@@ -25678,6 +25770,9 @@ arm_regno_class (int regno)\n   if (IS_VPR_REGNUM (regno))\n     return VPR_REG;\n \n+  if (IS_PAC_REGNUM (regno))\n+    return PAC_REG;\n+\n   if (TARGET_THUMB1)\n     {\n       if (regno == STACK_POINTER_REGNUM)\n@@ -26838,6 +26933,7 @@ arm_init_machine_status (void)\n   machine->func_type = ARM_FT_UNKNOWN;\n #endif\n   machine->static_chain_stack_bytes = -1;\n+  machine->pacspval_needed = 0;\n   return machine;\n }\n \n@@ -27410,7 +27506,14 @@ thumb2_expand_return (bool simple_return)\n \t to assert it for now to ensure that future code changes do not silently\n \t change this behavior.  */\n       gcc_assert (!IS_CMSE_ENTRY (arm_current_func_type ()));\n-      if (num_regs == 1)\n+      if (arm_current_function_pac_enabled_p ())\n+        {\n+          gcc_assert (!(saved_regs_mask & (1 << PC_REGNUM)));\n+          arm_emit_multi_reg_pop (saved_regs_mask);\n+          emit_insn (gen_aut_nop ());\n+          emit_jump_insn (simple_return_rtx);\n+        }\n+      else if (num_regs == 1)\n         {\n           rtx par = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (2));\n           rtx reg = gen_rtx_REG (SImode, PC_REGNUM);\n@@ -27834,7 +27937,8 @@ arm_expand_epilogue (bool really_return)\n           && really_return\n           && crtl->args.pretend_args_size == 0\n           && saved_regs_mask & (1 << LR_REGNUM)\n-          && !crtl->calls_eh_return)\n+          && !crtl->calls_eh_return\n+\t  && !arm_current_function_pac_enabled_p ())\n         {\n           saved_regs_mask &= ~(1 << LR_REGNUM);\n           saved_regs_mask |= (1 << PC_REGNUM);\n@@ -27948,6 +28052,9 @@ arm_expand_epilogue (bool really_return)\n \t}\n     }\n \n+  if (arm_current_function_pac_enabled_p ())\n+    emit_insn (gen_aut_nop ());\n+\n   if (!really_return)\n     return;\n \n@@ -28460,6 +28567,8 @@ static void\n arm_file_start (void)\n {\n   int val;\n+  bool pac = (aarch_ra_sign_scope != AARCH_FUNCTION_NONE);\n+  bool bti = (aarch_enable_bti == 1);\n \n   arm_print_asm_arch_directives\n     (asm_out_file, TREE_TARGET_OPTION (target_option_default_node));\n@@ -28530,6 +28639,22 @@ arm_file_start (void)\n \tarm_emit_eabi_attribute (\"Tag_ABI_FP_16bit_format\", 38,\n \t\t\t     (int) arm_fp16_format);\n \n+      if (TARGET_HAVE_PACBTI)\n+\t{\n+\t  arm_emit_eabi_attribute (\"Tag_PAC_extension\", 50, 2);\n+\t  arm_emit_eabi_attribute (\"Tag_BTI_extension\", 52, 2);\n+\t}\n+      else if (pac || bti)\n+\t{\n+\t  arm_emit_eabi_attribute (\"Tag_PAC_extension\", 50, 1);\n+\t  arm_emit_eabi_attribute (\"Tag_BTI_extension\", 52, 1);\n+\t}\n+\n+      if (bti)\n+        arm_emit_eabi_attribute (\"TAG_BTI_use\", 74, 1);\n+      if (pac)\n+\tarm_emit_eabi_attribute (\"TAG_PACRET_use\", 76, 1);\n+\n       if (arm_lang_output_object_attributes_hook)\n \tarm_lang_output_object_attributes_hook();\n     }\n@@ -29618,6 +29743,9 @@ arm_debugger_regno (unsigned int regno)\n   if (IS_IWMMXT_REGNUM (regno))\n     return 112 + regno - FIRST_IWMMXT_REGNUM;\n \n+  if (IS_PAC_REGNUM (regno))\n+    return DWARF_PAC_REGNUM;\n+\n   return DWARF_FRAME_REGISTERS;\n }\n \n@@ -29711,7 +29839,7 @@ arm_unwind_emit_sequence (FILE * out_file, rtx p)\n   gcc_assert (nregs);\n \n   reg = REGNO (SET_SRC (XVECEXP (p, 0, 1)));\n-  if (reg < 16)\n+  if (reg < 16 || IS_PAC_REGNUM (reg))\n     {\n       /* For -Os dummy registers can be pushed at the beginning to\n \t avoid separate stack pointer adjustment.  */\n@@ -29768,6 +29896,8 @@ arm_unwind_emit_sequence (FILE * out_file, rtx p)\n \t double precision register names.  */\n       if (IS_VFP_REGNUM (reg))\n \tasm_fprintf (out_file, \"d%d\", (reg - FIRST_VFP_REGNUM) / 2);\n+      else if (IS_PAC_REGNUM (reg))\n+\tasm_fprintf (asm_out_file, \"ra_auth_code\");\n       else\n \tasm_fprintf (out_file, \"%r\", reg);\n \n@@ -29862,7 +29992,7 @@ arm_unwind_emit_set (FILE * out_file, rtx p)\n \t  /* Move from sp to reg.  */\n \t  asm_fprintf (out_file, \"\\t.movsp %r\\n\", REGNO (e0));\n \t}\n-     else if (GET_CODE (e1) == PLUS\n+      else if (GET_CODE (e1) == PLUS\n \t      && REG_P (XEXP (e1, 0))\n \t      && REGNO (XEXP (e1, 0)) == SP_REGNUM\n \t      && CONST_INT_P (XEXP (e1, 1)))\n@@ -29871,6 +30001,11 @@ arm_unwind_emit_set (FILE * out_file, rtx p)\n \t  asm_fprintf (out_file, \"\\t.movsp %r, #%d\\n\",\n \t\t       REGNO (e0), (int)INTVAL(XEXP (e1, 1)));\n \t}\n+      else if (REGNO (e0) == IP_REGNUM && arm_current_function_pac_enabled_p ())\n+\t{\n+\t  if (cfun->machine->pacspval_needed)\n+\t    asm_fprintf (out_file, \"\\t.pacspval\\n\");\n+\t}\n       else\n \tabort ();\n       break;\n@@ -29925,10 +30060,15 @@ arm_unwind_emit (FILE * out_file, rtx_insn *insn)\n \t    src = SET_SRC (pat);\n \t    dest = SET_DEST (pat);\n \n-\t    gcc_assert (src == stack_pointer_rtx);\n+\t    gcc_assert (src == stack_pointer_rtx\n+\t\t\t|| IS_PAC_REGNUM (REGNO (src)));\n \t    reg = REGNO (dest);\n-\t    asm_fprintf (out_file, \"\\t.unwind_raw 0, 0x%x @ vsp = r%d\\n\",\n-\t\t\t reg + 0x90, reg);\n+\n+\t    if (IS_PAC_REGNUM (REGNO (src)))\n+\t      arm_unwind_emit_set (out_file, PATTERN (insn));\n+\t    else\n+\t      asm_fprintf (out_file, \"\\t.unwind_raw 0, 0x%x @ vsp = r%d\\n\",\n+\t\t\t   reg + 0x90, reg);\n \t  }\n \t  handled_one = true;\n \t  break;\n@@ -33031,6 +33171,78 @@ arm_fusion_enabled_p (tune_params::fuse_ops op)\n   return current_tune->fusible_ops & op;\n }\n \n+/* Return TRUE if return address signing mechanism is enabled.  */\n+bool\n+arm_current_function_pac_enabled_p (void)\n+{\n+  return (aarch_ra_sign_scope == AARCH_FUNCTION_ALL\n+          || (aarch_ra_sign_scope == AARCH_FUNCTION_NON_LEAF\n+              && !crtl->is_leaf));\n+}\n+\n+/* Raise an error if the current target arch is not bti compatible.  */\n+void aarch_bti_arch_check (void)\n+{\n+  if (!arm_arch8m_main)\n+    error (\"This architecture does not support branch protection instructions\");\n+}\n+\n+/* Return TRUE if Branch Target Identification Mechanism is enabled.  */\n+bool\n+aarch_bti_enabled (void)\n+{\n+  return aarch_enable_bti != 0;\n+}\n+\n+/* Check if INSN is a BTI J insn.  */\n+bool\n+aarch_bti_j_insn_p (rtx_insn *insn)\n+{\n+  if (!insn || !INSN_P (insn))\n+    return false;\n+\n+  rtx pat = PATTERN (insn);\n+  return GET_CODE (pat) == UNSPEC_VOLATILE && XINT (pat, 1) == VUNSPEC_BTI_NOP;\n+}\n+\n+/* Check if X (or any sub-rtx of X) is a PACIASP/PACIBSP instruction.  */\n+bool\n+aarch_pac_insn_p (rtx x)\n+{\n+  if (!x || !INSN_P (x))\n+    return false;\n+\n+  rtx pat = PATTERN (x);\n+\n+  if (GET_CODE (pat) == SET)\n+    {\n+      rtx tmp = XEXP (pat, 1);\n+      if (tmp\n+\t  && ((GET_CODE (tmp) == UNSPEC\n+               && XINT (tmp, 1) == UNSPEC_PAC_NOP)\n+              || (GET_CODE (tmp) == UNSPEC_VOLATILE\n+                  && XINT (tmp, 1) == VUNSPEC_PACBTI_NOP)))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+ /* Target specific mapping for aarch_gen_bti_c and aarch_gen_bti_j.\n+    For Arm, both of these map to a simple BTI instruction.  */\n+\n+rtx\n+aarch_gen_bti_c (void)\n+{\n+  return gen_bti_nop ();\n+}\n+\n+rtx\n+aarch_gen_bti_j (void)\n+{\n+  return gen_bti_nop ();\n+}\n+\n /* Implement TARGET_SCHED_CAN_SPECULATE_INSN.  Return true if INSN can be\n    scheduled for speculative execution.  Reject the long-running division\n    and square-root instructions.  */"}, {"sha": "632728371d5cef364e47bf33bfa0faba738db871", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -331,6 +331,12 @@ emission of floating point pcs attributes.  */\n \t\t\t\t\t\tisa_bit_mve_float) \\\n \t\t\t       && !TARGET_GENERAL_REGS_ONLY)\n \n+/* Non-zero if this target supports Armv8.1-M Mainline pointer-signing\n+   extension.  */\n+#define TARGET_HAVE_PACBTI (arm_arch8_1m_main \\\n+\t\t\t    && bitmap_bit_p (arm_active_target.isa, \\\n+\t\t\t\t\t     isa_bit_pacbti))\n+\n /* MVE have few common instructions as VFP, like VLDM alias VPOP, VLDR, VSTM\n    alia VPUSH, VSTR and VMOV, VMSR and VMRS.  In the same manner it updates few\n    registers such as FPCAR, FPCCR, FPDSCR, FPSCR, MVFR0, MVFR1 and MVFR2.  All\n@@ -500,6 +506,10 @@ extern int arm_arch8_3;\n /* Nonzero if this chip supports the ARM Architecture 8.4 extensions.  */\n extern int arm_arch8_4;\n \n+/* Nonzero if this chip supports the ARM Architecture 8-M Mainline\n+   extensions.  */\n+extern int arm_arch8m_main;\n+\n /* Nonzero if this chip supports the ARM Architecture 8.1-M Mainline\n    extensions.  */\n extern int arm_arch8_1m_main;\n@@ -806,7 +816,8 @@ extern const int arm_arch_cde_coproc_bits[];\n \ts16-s31\t      S\tVFP variable (aka d8-d15).\n \tvfpcc\t\tNot a real register.  Represents the VFP condition\n \t\t\tcode flags.\n-\tvpr\t\tUsed to represent MVE VPR predication.  */\n+\tvpr\t\tUsed to represent MVE VPR predication.\n+\tra_auth_code\tPseudo register to save PAC.  */\n \n /* The stack backtrace structure is as follows:\n   fp points to here:  |  save code pointer  |      [fp]\n@@ -847,7 +858,7 @@ extern const int arm_arch_cde_coproc_bits[];\n   1,1,1,1,1,1,1,1,\t\t\\\n   1,1,1,1,\t\t\t\\\n   /* Specials.  */\t\t\\\n-  1,1,1,1,1,1,1\t\t\t\\\n+  1,1,1,1,1,1,1,1\t\t\\\n }\n \n /* 1 for registers not available across function calls.\n@@ -877,7 +888,7 @@ extern const int arm_arch_cde_coproc_bits[];\n   1,1,1,1,1,1,1,1,\t\t\\\n   1,1,1,1,\t\t\t\\\n   /* Specials.  */\t\t\\\n-  1,1,1,1,1,1,1\t\t\t\\\n+  1,1,1,1,1,1,1,1\t\t\\\n }\n \n #ifndef SUBTARGET_CONDITIONAL_REGISTER_USAGE\n@@ -1053,10 +1064,12 @@ extern const int arm_arch_cde_coproc_bits[];\n    && (LAST_VFP_REGNUM - (REGNUM) >= 2 * (N) - 1))\n \n /* The number of hard registers is 16 ARM + 1 CC + 1 SFP + 1 AFP\n-   + 1 APSRQ + 1 APSRGE + 1 VPR.  */\n+   + 1 APSRQ + 1 APSRGE + 1 VPR + 1 Pseudo register to save PAC.  */\n /* Intel Wireless MMX Technology registers add 16 + 4 more.  */\n /* VFP (VFP3) adds 32 (64) + 1 VFPCC.  */\n-#define FIRST_PSEUDO_REGISTER   107\n+#define FIRST_PSEUDO_REGISTER   108\n+\n+#define DWARF_PAC_REGNUM 143\n \n #define DEBUGGER_REGNO(REGNO) arm_debugger_regno (REGNO)\n \n@@ -1243,12 +1256,15 @@ extern int arm_regs_in_sequence[];\n   CC_REGNUM, VFPCC_REGNUM,\t\t\t\\\n   FRAME_POINTER_REGNUM, ARG_POINTER_REGNUM,\t\\\n   SP_REGNUM, PC_REGNUM, APSRQ_REGNUM,\t\t\\\n-  APSRGE_REGNUM, VPR_REGNUM\t\t\t\\\n+  APSRGE_REGNUM, VPR_REGNUM, RA_AUTH_CODE\t\\\n }\n \n #define IS_VPR_REGNUM(REGNUM) \\\n   ((REGNUM) == VPR_REGNUM)\n \n+#define IS_PAC_REGNUM(REGNUM) \\\n+  ((REGNUM) == RA_AUTH_CODE)\n+\n /* Use different register alloc ordering for Thumb.  */\n #define ADJUST_REG_ALLOC_ORDER arm_order_regs_for_local_alloc ()\n \n@@ -1287,6 +1303,7 @@ enum reg_class\n   SFP_REG,\n   AFP_REG,\n   VPR_REG,\n+  PAC_REG,\n   GENERAL_AND_VPR_REGS,\n   ALL_REGS,\n   LIM_REG_CLASSES\n@@ -1317,6 +1334,7 @@ enum reg_class\n   \"SFP_REG\",\t\t\\\n   \"AFP_REG\",\t\t\\\n   \"VPR_REG\",\t\t\\\n+  \"PAC_REG\",\t\t\\\n   \"GENERAL_AND_VPR_REGS\", \\\n   \"ALL_REGS\"\t\t\\\n }\n@@ -1346,6 +1364,7 @@ enum reg_class\n   { 0x00000000, 0x00000000, 0x00000000, 0x00000040 }, /* SFP_REG */\t\\\n   { 0x00000000, 0x00000000, 0x00000000, 0x00000080 }, /* AFP_REG */\t\\\n   { 0x00000000, 0x00000000, 0x00000000, 0x00000400 }, /* VPR_REG.  */\t\\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000800 }, /* PAC_REG.  */\t\\\n   { 0x00005FFF, 0x00000000, 0x00000000, 0x00000400 }, /* GENERAL_AND_VPR_REGS.  */ \\\n   { 0xFFFF7FFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000040F }  /* ALL_REGS.  */\t\\\n }\n@@ -1611,6 +1630,9 @@ typedef struct GTY(()) machine_function\n   /* The number of bytes used to store the static chain register on the\n      stack, above the stack frame.  */\n   int static_chain_stack_bytes;\n+  /* Set to 1 when pointer authentication operation uses value of SP other\n+     than the incoming stack pointer value.  */\n+  int pacspval_needed;\n }\n machine_function;\n #endif"}, {"sha": "cbfc4543531452b0708a38bdf4abf5105b54f8b7", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -42,6 +42,7 @@\n    (APSRQ_REGNUM    104)\t; Q bit pseudo register\n    (APSRGE_REGNUM   105)\t; GE bits pseudo register\n    (VPR_REGNUM      106)\t; Vector Predication Register - MVE register.\n+   (RA_AUTH_CODE    107)\t; Pseudo register to save PAC.\n   ]\n )\n ;; 3rd operand to select_dominance_cc_mode\n@@ -12986,6 +12987,36 @@\n    (set_attr \"length\" \"8\")]\n )\n \n+(define_insn \"pac_nop\"\n+  [(set (reg:SI IP_REGNUM)\n+\t(unspec:SI [(reg:SI SP_REGNUM) (reg:SI LR_REGNUM)]\n+\t\t   UNSPEC_PAC_NOP))]\n+  \"arm_arch8m_main\"\n+  \"pac\\t%|ip, %|lr, %|sp\"\n+  [(set_attr \"conds\" \"unconditional\")])\n+\n+(define_insn \"pacbti_nop\"\n+  [(set (reg:SI IP_REGNUM)\n+\t(unspec_volatile:SI [(reg:SI SP_REGNUM) (reg:SI LR_REGNUM)]\n+\t\t\t    VUNSPEC_PACBTI_NOP))]\n+  \"arm_arch8m_main\"\n+  \"pacbti\\t%|ip, %|lr, %|sp\"\n+  [(set_attr \"conds\" \"unconditional\")])\n+\n+(define_insn \"aut_nop\"\n+  [(unspec_volatile:SI [(reg:SI IP_REGNUM) (reg:SI SP_REGNUM) (reg:SI LR_REGNUM)]\n+\t\t       VUNSPEC_AUT_NOP)]\n+  \"arm_arch8m_main\"\n+  \"aut\\t%|ip, %|lr, %|sp\"\n+  [(set_attr \"conds\" \"unconditional\")])\n+\n+(define_insn \"bti_nop\"\n+  [(unspec_volatile [(const_int 0)] VUNSPEC_BTI_NOP)]\n+  \"arm_arch8m_main\"\n+  \"bti\"\n+  [(set_attr \"conds\" \"unconditional\")\n+   (set_attr \"type\" \"nop\")])\n+\n ;; Vector bits common to IWMMXT, Neon and MVE\n (include \"vec-common.md\")\n ;; Load the Intel Wireless Multimedia Extension patterns"}, {"sha": "260700f16bcd110ae3b661b3c0ee06a99e4690de", "filename": "gcc/config/arm/arm.opt", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Farm.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Farm.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.opt?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -21,6 +21,15 @@\n HeaderInclude\n config/arm/arm-opts.h\n \n+HeaderInclude\n+config/arm/aarch-common.h\n+\n+TargetVariable\n+enum aarch_function_type aarch_ra_sign_scope = AARCH_FUNCTION_NONE\n+\n+TargetVariable\n+unsigned aarch_enable_bti = 0\n+\n Enum\n Name(tls_type) Type(enum arm_tls_type)\n TLS dialect to use:\n@@ -314,6 +323,10 @@ mbranch-cost=\n Target RejectNegative Joined UInteger Var(arm_branch_cost) Init(-1)\n Cost to assume for a branch insn.\n \n+mbranch-protection=\n+Target RejectNegative Joined Var(arm_branch_protection_string) Save\n+Use branch-protection features.\n+\n mgeneral-regs-only\n Target RejectNegative Mask(GENERAL_REGS_ONLY) Save\n Generate code which uses the core registers only (r0-r14)."}, {"sha": "bfbe1cdeabd24500d2d35da1e1415dfc456e5da2", "filename": "gcc/config/arm/arm_mve.h", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Farm_mve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Farm_mve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm_mve.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -16171,14 +16171,14 @@ __extension__ extern __inline void\n __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n __arm_vst1q_p_u8 (uint8_t * __addr, uint8x16_t __value, mve_pred16_t __p)\n {\n-  return vstrbq_p_u8 (__addr, __value, __p);\n+  return __arm_vstrbq_p_u8 (__addr, __value, __p);\n }\n \n __extension__ extern __inline void\n __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n __arm_vst1q_p_s8 (int8_t * __addr, int8x16_t __value, mve_pred16_t __p)\n {\n-  return vstrbq_p_s8 (__addr, __value, __p);\n+  return __arm_vstrbq_p_s8 (__addr, __value, __p);\n }\n \n __extension__ extern __inline void\n@@ -16203,14 +16203,14 @@ __extension__ extern __inline uint8x16_t\n __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n __arm_vld1q_z_u8 (uint8_t const *__base, mve_pred16_t __p)\n {\n-  return vldrbq_z_u8 ( __base, __p);\n+  return __arm_vldrbq_z_u8 ( __base, __p);\n }\n \n __extension__ extern __inline int8x16_t\n __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n __arm_vld1q_z_s8 (int8_t const *__base, mve_pred16_t __p)\n {\n-  return vldrbq_z_s8 ( __base, __p);\n+  return __arm_vldrbq_z_s8 ( __base, __p);\n }\n \n __extension__ extern __inline int8x16x2_t\n@@ -16253,14 +16253,14 @@ __extension__ extern __inline void\n __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n __arm_vst1q_p_u16 (uint16_t * __addr, uint16x8_t __value, mve_pred16_t __p)\n {\n-  return vstrhq_p_u16 (__addr, __value, __p);\n+  return __arm_vstrhq_p_u16 (__addr, __value, __p);\n }\n \n __extension__ extern __inline void\n __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n __arm_vst1q_p_s16 (int16_t * __addr, int16x8_t __value, mve_pred16_t __p)\n {\n-  return vstrhq_p_s16 (__addr, __value, __p);\n+  return __arm_vstrhq_p_s16 (__addr, __value, __p);\n }\n \n __extension__ extern __inline void\n@@ -16285,14 +16285,14 @@ __extension__ extern __inline uint16x8_t\n __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n __arm_vld1q_z_u16 (uint16_t const *__base, mve_pred16_t __p)\n {\n-  return vldrhq_z_u16 ( __base, __p);\n+  return __arm_vldrhq_z_u16 ( __base, __p);\n }\n \n __extension__ extern __inline int16x8_t\n __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n __arm_vld1q_z_s16 (int16_t const *__base, mve_pred16_t __p)\n {\n-  return vldrhq_z_s16 ( __base, __p);\n+  return __arm_vldrhq_z_s16 ( __base, __p);\n }\n \n __extension__ extern __inline int16x8x2_t\n@@ -16335,14 +16335,14 @@ __extension__ extern __inline void\n __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n __arm_vst1q_p_u32 (uint32_t * __addr, uint32x4_t __value, mve_pred16_t __p)\n {\n-  return vstrwq_p_u32 (__addr, __value, __p);\n+  return __arm_vstrwq_p_u32 (__addr, __value, __p);\n }\n \n __extension__ extern __inline void\n __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n __arm_vst1q_p_s32 (int32_t * __addr, int32x4_t __value, mve_pred16_t __p)\n {\n-  return vstrwq_p_s32 (__addr, __value, __p);\n+  return __arm_vstrwq_p_s32 (__addr, __value, __p);\n }\n \n __extension__ extern __inline void\n@@ -16367,14 +16367,14 @@ __extension__ extern __inline uint32x4_t\n __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n __arm_vld1q_z_u32 (uint32_t const *__base, mve_pred16_t __p)\n {\n-  return vldrwq_z_u32 ( __base, __p);\n+  return __arm_vldrwq_z_u32 ( __base, __p);\n }\n \n __extension__ extern __inline int32x4_t\n __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n __arm_vld1q_z_s32 (int32_t const *__base, mve_pred16_t __p)\n {\n-  return vldrwq_z_s32 ( __base, __p);\n+  return __arm_vldrwq_z_s32 ( __base, __p);\n }\n \n __extension__ extern __inline int32x4x2_t\n@@ -19837,7 +19837,7 @@ __extension__ extern __inline float16x8_t\n __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n __arm_vld1q_z_f16 (float16_t const *__base, mve_pred16_t __p)\n {\n-  return vldrhq_z_f16 (__base, __p);\n+  return __arm_vldrhq_z_f16 (__base, __p);\n }\n \n __extension__ extern __inline void\n@@ -19853,7 +19853,7 @@ __extension__ extern __inline void\n __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n __arm_vst1q_p_f16 (float16_t * __addr, float16x8_t __value, mve_pred16_t __p)\n {\n-  return vstrhq_p_f16 (__addr, __value, __p);\n+  return __arm_vstrhq_p_f16 (__addr, __value, __p);\n }\n \n __extension__ extern __inline float32x4x4_t\n@@ -19878,7 +19878,7 @@ __extension__ extern __inline float32x4_t\n __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n __arm_vld1q_z_f32 (float32_t const *__base, mve_pred16_t __p)\n {\n-  return vldrwq_z_f32 (__base, __p);\n+  return __arm_vldrwq_z_f32 (__base, __p);\n }\n \n __extension__ extern __inline void\n@@ -19894,7 +19894,7 @@ __extension__ extern __inline void\n __attribute__ ((__always_inline__, __gnu_inline__, __artificial__))\n __arm_vst1q_p_f32 (float32_t * __addr, float32x4_t __value, mve_pred16_t __p)\n {\n-  return vstrwq_p_f32 (__addr, __value, __p);\n+  return __arm_vstrwq_p_f32 (__addr, __value, __p);\n }\n \n __extension__ extern __inline float16x8_t\n@@ -35659,9 +35659,9 @@ extern void *__ARM_undef;\n #define __ARM_mve_coerce1(param, type) \\\n     _Generic(param, type: param, const type: param, default: *(type *)__ARM_undef)\n #define __ARM_mve_coerce2(param, type) \\\n-    _Generic(param, type: param, float16_t: param, float32_t: param, default: *(type *)__ARM_undef)\n+    _Generic(param, type: param, __fp16: param, default: _Generic (param, _Float16: param, float16_t: param, float32_t: param, default: *(type *)__ARM_undef))\n #define __ARM_mve_coerce3(param, type) \\\n-    _Generic(param, type: param, int8_t: param, int16_t: param, int32_t: param, int64_t: param, uint8_t: param, uint16_t: param, uint32_t: param, uint64_t: param, default: *(type *)__ARM_undef)\n+    _Generic(param, type: param, default: _Generic (param, int8_t: param, int16_t: param, int32_t: param, int64_t: param, uint8_t: param, uint16_t: param, uint32_t: param, uint64_t: param, default: *(type *)__ARM_undef))\n \n #if (__ARM_FEATURE_MVE & 2) /* MVE Floating point.  */\n "}, {"sha": "555ad1b66c84a143051a57bb9c5b23c8402f01bf", "filename": "gcc/config/arm/mve.md", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Fmve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Fmve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fmve.md?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -252,7 +252,7 @@\n \t(neg:MVE_0 (match_operand:MVE_0 1 \"s_register_operand\" \"w\")))\n   ]\n   \"TARGET_HAVE_MVE && TARGET_HAVE_MVE_FLOAT\"\n-  \"vneg.f%#<V_sz_elem>  %q0, %q1\"\n+  \"vneg.f%#<V_sz_elem>\\t%q0, %q1\"\n   [(set_attr \"type\" \"mve_move\")\n ])\n \n@@ -374,7 +374,7 @@\n \t VQNEGQ_S))\n   ]\n   \"TARGET_HAVE_MVE\"\n-  \"vqneg.s%#<V_sz_elem> %q0, %q1\"\n+  \"vqneg.s%#<V_sz_elem>\\t%q0, %q1\"\n   [(set_attr \"type\" \"mve_move\")\n ])\n \n@@ -388,7 +388,7 @@\n \t VQABSQ_S))\n   ]\n   \"TARGET_HAVE_MVE\"\n-  \"vqabs.s%#<V_sz_elem> %q0, %q1\"\n+  \"vqabs.s%#<V_sz_elem>\\t%q0, %q1\"\n   [(set_attr \"type\" \"mve_move\")\n ])\n \n@@ -401,7 +401,7 @@\n \t(neg:MVE_2 (match_operand:MVE_2 1 \"s_register_operand\" \"w\")))\n   ]\n   \"TARGET_HAVE_MVE\"\n-  \"vneg.s%#<V_sz_elem>  %q0, %q1\"\n+  \"vneg.s%#<V_sz_elem>\\t%q0, %q1\"\n   [(set_attr \"type\" \"mve_move\")\n ])\n \n@@ -448,7 +448,7 @@\n \t(clz:MVE_2 (match_operand:MVE_2 1 \"s_register_operand\" \"w\")))\n   ]\n   \"TARGET_HAVE_MVE\"\n-  \"vclz.i%#<V_sz_elem>  %q0, %q1\"\n+  \"vclz.i%#<V_sz_elem>\\t%q0, %q1\"\n   [(set_attr \"type\" \"mve_move\")\n ])\n (define_expand \"mve_vclzq_u<mode>\"\n@@ -469,7 +469,7 @@\n \t VCLSQ_S))\n   ]\n   \"TARGET_HAVE_MVE\"\n-  \"vcls.s%#<V_sz_elem>  %q0, %q1\"\n+  \"vcls.s%#<V_sz_elem>\\t%q0, %q1\"\n   [(set_attr \"type\" \"mve_move\")\n ])\n \n@@ -7272,15 +7272,13 @@\n }\n   [(set_attr \"length\" \"8\")])\n \n-;;\n-;; [vstrbq_p_s vstrbq_p_u]\n-;;\n (define_insn \"mve_vstrbq_p_<supf><mode>\"\n   [(set (match_operand:<MVE_B_ELEM> 0 \"mve_memory_operand\" \"=Ux\")\n-\t(unspec:<MVE_B_ELEM> [(match_operand:MVE_2 1 \"s_register_operand\" \"w\")\n-\t\t\t      (match_operand:<MVE_VPRED> 2 \"vpr_register_operand\" \"Up\")]\n-\t VSTRBQ))\n-  ]\n+\t(unspec:<MVE_B_ELEM>\n+\t [(match_operand:MVE_2 1 \"s_register_operand\" \"w\")\n+\t  (match_operand:<MVE_VPRED> 2 \"vpr_register_operand\" \"Up\")\n+\t  (match_dup 0)]\n+\t VSTRBQ))]\n   \"TARGET_HAVE_MVE\"\n {\n    rtx ops[2];\n@@ -8079,10 +8077,11 @@\n ;;\n (define_insn \"mve_vstrhq_p_fv8hf\"\n   [(set (match_operand:V8HI 0 \"mve_memory_operand\" \"=Ux\")\n-\t(unspec:V8HI [(match_operand:V8HF 1 \"s_register_operand\" \"w\")\n-\t\t      (match_operand:V8BI 2 \"vpr_register_operand\" \"Up\")]\n-\t VSTRHQ_F))\n-  ]\n+\t(unspec:V8HI\n+\t [(match_operand:V8HF 1 \"s_register_operand\" \"w\")\n+\t  (match_operand:V8BI 2 \"vpr_register_operand\" \"Up\")\n+\t  (match_dup 0)]\n+\t VSTRHQ_F))]\n   \"TARGET_HAVE_MVE && TARGET_HAVE_MVE_FLOAT\"\n {\n    rtx ops[2];\n@@ -8099,8 +8098,10 @@\n ;;\n (define_insn \"mve_vstrhq_p_<supf><mode>\"\n   [(set (match_operand:<MVE_H_ELEM> 0 \"mve_memory_operand\" \"=Ux\")\n-\t(unspec:<MVE_H_ELEM> [(match_operand:MVE_6 1 \"s_register_operand\" \"w\")\n-\t\t\t      (match_operand:<MVE_VPRED> 2 \"vpr_register_operand\" \"Up\")]\n+\t(unspec:<MVE_H_ELEM>\n+\t [(match_operand:MVE_6 1 \"s_register_operand\" \"w\")\n+\t  (match_operand:<MVE_VPRED> 2 \"vpr_register_operand\" \"Up\")\n+\t  (match_dup 0)]\n \t VSTRHQ))\n   ]\n   \"TARGET_HAVE_MVE\"\n@@ -8278,10 +8279,11 @@\n ;;\n (define_insn \"mve_vstrwq_p_fv4sf\"\n   [(set (match_operand:V4SI 0 \"mve_memory_operand\" \"=Ux\")\n-\t(unspec:V4SI [(match_operand:V4SF 1 \"s_register_operand\" \"w\")\n-\t\t      (match_operand:<MVE_VPRED> 2 \"vpr_register_operand\" \"Up\")]\n-\t VSTRWQ_F))\n-  ]\n+\t(unspec:V4SI\n+\t [(match_operand:V4SF 1 \"s_register_operand\" \"w\")\n+\t  (match_operand:<MVE_VPRED> 2 \"vpr_register_operand\" \"Up\")\n+\t  (match_dup 0)]\n+\t VSTRWQ_F))]\n   \"TARGET_HAVE_MVE && TARGET_HAVE_MVE_FLOAT\"\n {\n    rtx ops[2];\n@@ -8298,10 +8300,11 @@\n ;;\n (define_insn \"mve_vstrwq_p_<supf>v4si\"\n   [(set (match_operand:V4SI 0 \"mve_memory_operand\" \"=Ux\")\n-\t(unspec:V4SI [(match_operand:V4SI 1 \"s_register_operand\" \"w\")\n-\t\t      (match_operand:V4BI 2 \"vpr_register_operand\" \"Up\")]\n-\t VSTRWQ))\n-  ]\n+\t(unspec:V4SI\n+\t [(match_operand:V4SI 1 \"s_register_operand\" \"w\")\n+\t  (match_operand:V4BI 2 \"vpr_register_operand\" \"Up\")\n+\t  (match_dup 0)]\n+\t VSTRWQ))]\n   \"TARGET_HAVE_MVE\"\n {\n    rtx ops[2];"}, {"sha": "637e72af5bb7761536e5abee77c69561c2026376", "filename": "gcc/config/arm/t-arm", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Ft-arm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Ft-arm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-arm?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -175,3 +175,13 @@ arm-d.o: $(srcdir)/config/arm/arm-d.cc\n arm-common.o: arm-cpu-cdata.h\n \n driver-arm.o: arm-native.h\n+\n+PASSES_EXTRA += $(srcdir)/config/arm/arm-passes.def\n+\n+aarch-bti-insert.o: $(srcdir)/config/arm/aarch-bti-insert.cc \\\n+    $(CONFIG_H) $(SYSTEM_H) $(TM_H) $(REGS_H) insn-config.h $(RTL_BASE_H) \\\n+    dominance.h cfg.h cfganal.h $(BASIC_BLOCK_H) $(INSN_ATTR_H) $(RECOG_H) \\\n+    output.h hash-map.h $(DF_H) $(OBSTACK_H) $(TARGET_H) $(RTL_H) \\\n+    $(CONTEXT_H) $(TREE_PASS_H) regrename.h\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t\t$(srcdir)/config/arm/aarch-bti-insert.cc"}, {"sha": "4d8e6ce10b86b159271c36380cdfbcab429c6c1e", "filename": "gcc/config/arm/t-rmprofile", "status": "modified", "additions": 66, "deletions": 2, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Ft-rmprofile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Ft-rmprofile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-rmprofile?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -27,8 +27,11 @@\n \n # Arch and FPU variants to build libraries with\n \n-MULTI_ARCH_OPTS_RM\t= march=armv6s-m/march=armv7-m/march=armv7e-m/march=armv7e-m+fp/march=armv7e-m+fp.dp/march=armv8-m.base/march=armv8-m.main/march=armv8-m.main+fp/march=armv8-m.main+fp.dp/march=armv8.1-m.main+mve\n-MULTI_ARCH_DIRS_RM\t= v6-m v7-m v7e-m v7e-m+fp v7e-m+dp v8-m.base v8-m.main v8-m.main+fp v8-m.main+dp v8.1-m.main+mve\n+MULTI_ARCH_OPTS_RM\t= march=armv6s-m/march=armv7-m/march=armv7e-m/march=armv7e-m+fp/march=armv7e-m+fp.dp/march=armv8-m.base/march=armv8-m.main/march=armv8-m.main+fp/march=armv8-m.main+fp.dp/march=armv8.1-m.main+mve/march=armv8.1-m.main+pacbti/march=armv8.1-m.main+pacbti+fp/march=armv8.1-m.main+pacbti+fp.dp/march=armv8.1-m.main+pacbti+mve\n+MULTI_ARCH_DIRS_RM\t= v6-m v7-m v7e-m v7e-m+fp v7e-m+dp v8-m.base v8-m.main v8-m.main+fp v8-m.main+dp v8.1-m.main+mve v8.1-m.main+pacbti v8.1-m.main+pacbti+fp v8.1-m.main+pacbti+dp v8.1-m.main+pacbti+mve\n+\n+MULTI_ARCH_OPTS_RM\t+= mbranch-protection=standard\n+MULTI_ARCH_DIRS_RM\t+= bp\n \n # Base M-profile (no fp)\n MULTILIB_REQUIRED\t+= mthumb/march=armv6s-m/mfloat-abi=soft\n@@ -50,6 +53,13 @@ MULTILIB_REQUIRED\t+= mthumb/march=armv8-m.main+fp.dp/mfloat-abi=hard\n MULTILIB_REQUIRED\t+= mthumb/march=armv8-m.main+fp.dp/mfloat-abi=softfp\n MULTILIB_REQUIRED\t+= mthumb/march=armv8.1-m.main+mve/mfloat-abi=hard\n \n+MULTILIB_REQUIRED\t+= mthumb/march=armv8.1-m.main+pacbti/mbranch-protection=standard/mfloat-abi=soft\n+MULTILIB_REQUIRED\t+= mthumb/march=armv8.1-m.main+pacbti+fp/mbranch-protection=standard/mfloat-abi=softfp\n+MULTILIB_REQUIRED\t+= mthumb/march=armv8.1-m.main+pacbti+fp/mbranch-protection=standard/mfloat-abi=hard\n+MULTILIB_REQUIRED\t+= mthumb/march=armv8.1-m.main+pacbti+fp.dp/mbranch-protection=standard/mfloat-abi=softfp\n+MULTILIB_REQUIRED\t+= mthumb/march=armv8.1-m.main+pacbti+fp.dp/mbranch-protection=standard/mfloat-abi=hard\n+MULTILIB_REQUIRED\t+= mthumb/march=armv8.1-m.main+pacbti+mve/mbranch-protection=standard/mfloat-abi=hard\n+\n # Arch Matches\n MULTILIB_MATCHES\t+= march?armv6s-m=march?armv6-m\n \n@@ -87,9 +97,63 @@ MULTILIB_MATCHES += $(foreach FP, $(v8_1m_sp_variants), \\\n MULTILIB_MATCHES += $(foreach FP, $(v8_1m_dp_variants), \\\n \t\t\t     march?armv8-m.main+fp.dp=mlibarch?armv8.1-m.main$(FP))\n \n+# Map all mbranch-protection values other than 'none' to 'standard'.\n+MULTILIB_MATCHES\t+= mbranch-protection?standard=mbranch-protection?bti\n+MULTILIB_MATCHES\t+= mbranch-protection?standard=mbranch-protection?pac-ret\n+MULTILIB_MATCHES\t+= mbranch-protection?standard=mbranch-protection?pac-ret+leaf\n+MULTILIB_MATCHES\t+= mbranch-protection?standard=mbranch-protection?pac-ret+bti\n+MULTILIB_MATCHES\t+= mbranch-protection?standard=mbranch-protection?pac-ret+leaf+bti\n+MULTILIB_MATCHES\t+= mbranch-protection?standard=mbranch-protection?bti+pac-ret\n+MULTILIB_MATCHES\t+= mbranch-protection?standard=mbranch-protection?bti+pac-ret+leaf\n+MULTILIB_MATCHES\t+= mbranch-protection?standard=mbranch-protection?standard+leaf\n+\n # For all the MULTILIB_REQUIRED for v8-m and above, add MULTILIB_MATCHES which\n # maps mlibarch with march for multilib linking.\n MULTILIB_MATCHES\t+= march?armv8-m.main=mlibarch?armv8-m.main\n MULTILIB_MATCHES\t+= march?armv8-m.main+fp=mlibarch?armv8-m.main+fp\n MULTILIB_MATCHES\t+= march?armv8-m.main+fp.dp=mlibarch?armv8-m.main+fp.dp\n MULTILIB_MATCHES\t+= march?armv8.1-m.main+mve=mlibarch?armv8.1-m.main+mve\n+\n+# For -mbranch-protection=none and +pacbti reuses the existing non pacbti\n+# multilibs.\n+MULTILIB_REUSE\t\t+= $(foreach OPT, fp fp\\.dp, \\\n+\t\t\t     mthumb/march.armv8-m\\.main+$(OPT)/mfloat-abi.softfp=mthumb/march.armv8\\.1-m\\.main+pacbti+$(OPT)/mfloat-abi.softfp)\n+MULTILIB_REUSE\t\t+= $(foreach OPT, fp fp\\.dp, \\\n+\t\t\t     mthumb/march.armv8-m\\.main+$(OPT)/mfloat-abi.hard=mthumb/march.armv8\\.1-m\\.main+pacbti+$(OPT)/mfloat-abi.hard)\n+\n+MULTILIB_REUSE\t\t+= $(foreach OPT, pacbti pacbti+mve, \\\n+\t\t\t     mthumb/march.armv8-m\\.main/mfloat-abi.soft=mthumb/march.armv8\\.1-m\\.main+$(OPT)/mfloat-abi.soft)\n+MULTILIB_REUSE\t\t+= $(foreach OPT, pacbti pacbti+mve, \\\n+\t\t\t     mthumb/march.armv8-m\\.main/mfloat-abi.soft=mthumb/march.armv8\\.1-m\\.main+$(OPT)/mfloat-abi.softfp)\n+\n+MULTILIB_REUSE\t\t+= mthumb/march.armv8\\.1-m\\.main+mve/mfloat-abi.hard=mthumb/march.armv8\\.1-m\\.main+pacbti+mve/mfloat-abi.hard\n+\n+pacbti_fp_variants =  fp fp+mve mve.fp fp+mve.fp\n+pacbti_dp_variants = fp.dp fp.dp+mve fp.dp+mve.fp\n+\n+# For -mbranch-protection=standard and +pacbti linking to existing pacbti\n+# multlibs.\n+MULTILIB_MATCHES\t+= march?armv8.1-m.main+pacbti=mlibarch?armv8.1-m.main+pacbti\n+MULTILIB_MATCHES\t+= march?armv8.1-m.main+pacbti=mlibarch?armv8.1-m.main+pacbti+dsp\n+MULTILIB_MATCHES\t+= march?armv8.1-m.main+pacbti=mlibarch?armv8.1-m.main+dsp+pacbti\n+MULTILIB_MATCHES\t+= march?armv8.1-m.main+pacbti+mve=mlibarch?armv8.1-m.main+pacbti+mve\n+MULTILIB_MATCHES\t+= march?armv8.1-m.main+pacbti+mve=mlibarch?armv8.1-m.main+pacbti+dsp+mve\n+MULTILIB_MATCHES\t+= march?armv8.1-m.main+pacbti+mve=mlibarch?armv8.1-m.main+dsp+pacbti+mve\n+\n+MULTILIB_MATCHES\t+= $(foreach OPT, $(pacbti_fp_variants), \\\n+\t\t\t     march?armv8.1-m.main+pacbti+fp=mlibarch?armv8.1-m.main+pacbti+$(OPT))\n+\n+MULTILIB_MATCHES\t+= $(foreach OPT, $(pacbti_fp_variants), \\\n+\t\t\t     march?armv8.1-m.main+pacbti+fp=mlibarch?armv8.1-m.main+pacbti+dsp+$(OPT))\n+\n+MULTILIB_MATCHES\t+= $(foreach OPT, $(pacbti_dp_variants), \\\n+\t\t\t     march?armv8.1-m.main+pacbti+fp.dp=mlibarch?armv8.1-m.main+pacbti+$(OPT))\n+\n+MULTILIB_MATCHES\t+= $(foreach OPT, $(pacbti_dp_variants), \\\n+\t\t\t     march?armv8.1-m.main+pacbti+fp.dp=mlibarch?armv8.1-m.main+pacbti+dsp+$(OPT))\n+\n+MULTILIB_MATCHES\t+= $(foreach OPT, $(pacbti_fp_variants), \\\n+\t\t\t     march?armv8.1-m.main+pacbti+fp=mlibarch?armv8.1-m.main+dsp+pacbti+$(OPT))\n+\n+MULTILIB_MATCHES\t+= $(foreach OPT, $(pacbti_dp_variants), \\\n+\t\t\t     march?armv8.1-m.main+pacbti+fp.dp=mlibarch?armv8.1-m.main+dsp+pacbti+$(OPT))"}, {"sha": "50e1ac79acff1d9c11365f67169326146fd60966", "filename": "gcc/config/arm/unspecs.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Funspecs.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Farm%2Funspecs.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Funspecs.md?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -159,6 +159,7 @@\n   UNSPEC_VCDE\t\t; Custom Datapath Extension instruction.\n   UNSPEC_VCDEA\t\t; Custom Datapath Extension instruction.\n   UNSPEC_DLS\t\t; Used for DLS (Do Loop Start), Armv8.1-M Mainline instruction\n+  UNSPEC_PAC_NOP\t; Represents PAC signing LR\n ])\n \n \n@@ -254,6 +255,9 @@\n \t\t\t; instruction.\n   VUNSPEC_VLLDM\t\t; Represent the lazy load multiple with vlldm\n \t\t\t; instruction.\n+  VUNSPEC_PACBTI_NOP\t; Represents PAC signing LR + valid landing pad\n+  VUNSPEC_AUT_NOP\t; Represents PAC verifying LR\n+  VUNSPEC_BTI_NOP\t; Represent BTI\n ])\n \n ;; Enumerators for NEON unspecs."}, {"sha": "b268801d00c784e2ef9e47265e5e92c7c90a0722", "filename": "gcc/config/bpf/bpf.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fbpf%2Fbpf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fbpf%2Fbpf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbpf%2Fbpf.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -253,6 +253,14 @@ bpf_option_override (void)\n   if (bpf_has_jmp32 == -1)\n     bpf_has_jmp32 = (bpf_isa >= ISA_V3);\n \n+  /* Disable -fstack-protector as it is not supported in BPF.  */\n+  if (flag_stack_protect)\n+    {\n+      inform (input_location,\n+              \"%<-fstack-protector%> does not work \"\n+              \" on this architecture\");\n+      flag_stack_protect = 0;\n+    }\n }\n \n #undef TARGET_OPTION_OVERRIDE"}, {"sha": "117c2a12c74c33c01e6c07b329f51979896e4355", "filename": "gcc/config/csky/csky-linux-elf.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fcsky%2Fcsky-linux-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fcsky%2Fcsky-linux-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcsky%2Fcsky-linux-elf.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -65,13 +65,16 @@\n \n #define GLIBC_DYNAMIC_LINKER \"/lib/ld-linux-cskyv2%{mfloat-abi=hard:-hf}%{mbig-endian:-be}.so.1\"\n \n+#ifdef CSKY_ENABLE_MULTILIB\n+#undef SYSROOT_SUFFIX_SPEC\n #define SYSROOT_SUFFIX_SPEC\t\t\t\t\t\\\n   \"%{mbig-endian:/big}\"\t\t\t\t\t\t\\\n   \"%{mcpu=ck807*:/ck807}\"\t\t\t\t\t\\\n   \"%{mcpu=ck860*:/ck860}\"\t\t\t\t\t\\\n   \"%{mcpu=ck800*:/ck800}\"\t\t\t\t\t\\\n   \"%{mfloat-abi=softfp:/soft-fp}\"\t\t\t\t\\\n   \"%{mfloat-abi=hard:/hard-fp}\"\n+#endif\n \n #define LINUX_TARGET_LINK_SPEC\t\"%{h*} %{version:-v}\t\t\\\n    %{b}\t\t\t\t\t\t\t\t\\"}, {"sha": "bd83b7fbbc657c5f0b0263fb2474bc29921ed04e", "filename": "gcc/config/i386/avx512erintrin.h", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fi386%2Favx512erintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fi386%2Favx512erintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Favx512erintrin.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -51,9 +51,8 @@ extern __inline __m512d\n __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n _mm512_exp2a23_round_pd (__m512d __A, int __R)\n {\n-  __m512d __W;\n   return (__m512d) __builtin_ia32_exp2pd_mask ((__v8df) __A,\n-\t\t\t\t\t       (__v8df) __W,\n+\t\t\t\t\t       (__v8df) _mm512_undefined_pd (),\n \t\t\t\t\t       (__mmask8) -1, __R);\n }\n \n@@ -79,9 +78,8 @@ extern __inline __m512\n __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n _mm512_exp2a23_round_ps (__m512 __A, int __R)\n {\n-  __m512 __W;\n   return (__m512) __builtin_ia32_exp2ps_mask ((__v16sf) __A,\n-\t\t\t\t\t      (__v16sf) __W,\n+\t\t\t\t\t      (__v16sf) _mm512_undefined_ps (),\n \t\t\t\t\t      (__mmask16) -1, __R);\n }\n \n@@ -107,9 +105,8 @@ extern __inline __m512d\n __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n _mm512_rcp28_round_pd (__m512d __A, int __R)\n {\n-  __m512d __W;\n   return (__m512d) __builtin_ia32_rcp28pd_mask ((__v8df) __A,\n-\t\t\t\t\t\t(__v8df) __W,\n+\t\t\t\t\t\t(__v8df) _mm512_undefined_pd (),\n \t\t\t\t\t\t(__mmask8) -1, __R);\n }\n \n@@ -135,9 +132,8 @@ extern __inline __m512\n __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n _mm512_rcp28_round_ps (__m512 __A, int __R)\n {\n-  __m512 __W;\n   return (__m512) __builtin_ia32_rcp28ps_mask ((__v16sf) __A,\n-\t\t\t\t\t       (__v16sf) __W,\n+\t\t\t\t\t       (__v16sf) _mm512_undefined_ps (),\n \t\t\t\t\t       (__mmask16) -1, __R);\n }\n \n@@ -229,9 +225,8 @@ extern __inline __m512d\n __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n _mm512_rsqrt28_round_pd (__m512d __A, int __R)\n {\n-  __m512d __W;\n   return (__m512d) __builtin_ia32_rsqrt28pd_mask ((__v8df) __A,\n-\t\t\t\t\t\t  (__v8df) __W,\n+\t\t\t\t\t\t  (__v8df) _mm512_undefined_pd (),\n \t\t\t\t\t\t  (__mmask8) -1, __R);\n }\n \n@@ -257,9 +252,8 @@ extern __inline __m512\n __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n _mm512_rsqrt28_round_ps (__m512 __A, int __R)\n {\n-  __m512 __W;\n   return (__m512) __builtin_ia32_rsqrt28ps_mask ((__v16sf) __A,\n-\t\t\t\t\t\t (__v16sf) __W,\n+\t\t\t\t\t\t (__v16sf) _mm512_undefined_ps (),\n \t\t\t\t\t\t (__mmask16) -1, __R);\n }\n "}, {"sha": "b2c45ab5f67e80e46f891d9c0cf656580f62262d", "filename": "gcc/config/i386/cygwin.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fi386%2Fcygwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fi386%2Fcygwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygwin.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -48,7 +48,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #undef ENDFILE_SPEC\n #define ENDFILE_SPEC \\\n-  \"%{Ofast|ffast-math|funsafe-math-optimizations:crtfastmath.o%s}\\\n+  \"%{mdaz-ftz:crtfastmath.o%s;Ofast|ffast-math|funsafe-math-optimizations:%{!shared:%{!mno-daz-ftz:crtfastmath.o%s}}} \\\n    %{!shared:%:if-exists(default-manifest.o%s)}\\\n    %{fvtable-verify=none:%s; \\\n     fvtable-verify=preinit:vtv_end.o%s; \\"}, {"sha": "588bd669bddc9726b5451d160a3a2b79865a3ef8", "filename": "gcc/config/i386/darwin.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fi386%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fi386%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fdarwin.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -110,7 +110,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #undef ENDFILE_SPEC\n #define ENDFILE_SPEC \\\n-  \"%{Ofast|ffast-math|funsafe-math-optimizations:crtfastmath.o%s} \\\n+  \"%{mdaz-ftz:crtfastmath.o%s;Ofast|ffast-math|funsafe-math-optimizations:%{!shared:%{!mno-daz-ftz:crtfastmath.o%s}}} \\\n    %{mpc32:crtprec32.o%s} \\\n    %{mpc64:crtprec64.o%s} \\\n    %{mpc80:crtprec80.o%s}\" TM_DESTRUCTOR"}, {"sha": "a411f0e802a9bdc4df1d86324cdd5016e7e80300", "filename": "gcc/config/i386/gnu64.h", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fi386%2Fgnu64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fi386%2Fgnu64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fgnu64.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -0,0 +1,40 @@\n+/* Configuration for an x86_64 running GNU with ELF as the target machine.  */\n+\n+/*\n+Copyright (C) 2023 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software: you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation, either version 3 of the License, or\n+(at your option) any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC.  If not, see <http://www.gnu.org/licenses/>.\n+*/\n+\n+#define GNU_USER_LINK_EMULATION32 \"elf_i386\"\n+#define GNU_USER_LINK_EMULATION64 \"elf_x86_64\"\n+#define GNU_USER_LINK_EMULATIONX32 \"elf32_x86_64\"\n+\n+#undef GNU_USER_DYNAMIC_LINKER\n+#define GNU_USER_DYNAMIC_LINKER32 \"/lib/ld.so.1\"\n+#define GNU_USER_DYNAMIC_LINKER64 \"/lib/ld-x86-64.so.1\"\n+#define GNU_USER_DYNAMIC_LINKERX32 \"/lib/ld-x32.so.1\"\n+\n+#undef\tSTARTFILE_SPEC\n+#if defined HAVE_LD_PIE\n+#define STARTFILE_SPEC \\\n+  \"%{!shared: %{pg|p|profile:%{static:gcrt0.o%s;:gcrt1.o%s};pie:Scrt1.o%s;static:crt0.o%s;:crt1.o%s}} \\\n+   crti.o%s %{static:crtbeginT.o%s;shared|pie:crtbeginS.o%s;:crtbegin.o%s}\"\n+#else\n+#define STARTFILE_SPEC \\\n+  \"%{!shared: %{pg|p|profile:%{static:gcrt0.o%s;:gcrt1.o%s};static:crt0.o%s;:crt1.o%s}} \\\n+   crti.o%s %{static:crtbeginT.o%s;shared|pie:crtbeginS.o%s;:crtbegin.o%s}\"\n+#endif"}, {"sha": "e59c7b0150f9e6c834fa5d3dc7802941e193617b", "filename": "gcc/config/i386/i386-expand.cc", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fi386%2Fi386-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fi386%2Fi386-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -291,7 +291,9 @@ ix86_convert_const_wide_int_to_broadcast (machine_mode mode, rtx op)\n      broadcast only if vector broadcast is available.  */\n   if (!TARGET_AVX\n       || !CONST_WIDE_INT_P (op)\n-      || standard_sse_constant_p (op, mode))\n+      || standard_sse_constant_p (op, mode)\n+      || (CONST_WIDE_INT_NUNITS (op) * HOST_BITS_PER_WIDE_INT\n+\t  != GET_MODE_BITSIZE (mode)))\n     return nullptr;\n \n   HOST_WIDE_INT val = CONST_WIDE_INT_ELT (op, 0);\n@@ -13175,6 +13177,12 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget,\n \n \tif (INTVAL (op3) == 1)\n \t  {\n+\t    if (INTVAL (op2) < 2 || INTVAL (op2) > 3)\n+\t      {\n+\t\terror (\"invalid third argument\");\n+\t\treturn const0_rtx;\n+\t      }\n+\n \t    if (TARGET_64BIT && TARGET_PREFETCHI\n \t\t&& local_func_symbolic_operand (op0, GET_MODE (op0)))\n \t      emit_insn (gen_prefetchi (op0, op2));\n@@ -13195,6 +13203,12 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget,\n \t\top0 = copy_addr_to_reg (op0);\n \t      }\n \n+\t    if (INTVAL (op2) < 0 || INTVAL (op2) > 3)\n+\t      {\n+\t\twarning (0, \"invalid third argument to %<__builtin_ia32_prefetch%>; using zero\");\n+\t\top2 = const0_rtx;\n+\t      }\n+\n \t    if (TARGET_3DNOW || TARGET_PREFETCH_SSE\n \t\t|| TARGET_PRFCHW || TARGET_PREFETCHWT1)\n \t      emit_insn (gen_prefetch (op0, op1, op2));"}, {"sha": "3cacf738c4ae2f9211b9ea00571a823294847474", "filename": "gcc/config/i386/i386.cc", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fi386%2Fi386.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fi386%2Fi386.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -19051,6 +19051,13 @@ ix86_vectorize_builtin_scatter (const_tree vectype,\n   if (!TARGET_AVX512F)\n     return NULL_TREE;\n \n+  if (known_eq (TYPE_VECTOR_SUBPARTS (vectype), 2u)\n+      ? !TARGET_USE_SCATTER_2PARTS\n+      : (known_eq (TYPE_VECTOR_SUBPARTS (vectype), 4u)\n+\t ? !TARGET_USE_SCATTER_4PARTS\n+\t : !TARGET_USE_SCATTER))\n+    return NULL_TREE;\n+\n   if ((TREE_CODE (index_type) != INTEGER_TYPE\n        && !POINTER_TYPE_P (index_type))\n       || (TYPE_MODE (index_type) != SImode\n@@ -21473,6 +21480,7 @@ x86_output_mi_thunk (FILE *file, tree thunk_fndecl, HOST_WIDE_INT delta,\n   rtx this_reg, tmp, fnaddr;\n   unsigned int tmp_regno;\n   rtx_insn *insn;\n+  int saved_flag_force_indirect_call = flag_force_indirect_call;\n \n   if (TARGET_64BIT)\n     tmp_regno = R10_REG;\n@@ -21485,6 +21493,9 @@ x86_output_mi_thunk (FILE *file, tree thunk_fndecl, HOST_WIDE_INT delta,\n \ttmp_regno = DX_REG;\n       else\n \ttmp_regno = CX_REG;\n+\n+      if (flag_pic)\n+  flag_force_indirect_call = 0;\n     }\n \n   emit_note (NOTE_INSN_PROLOGUE_END);\n@@ -21652,6 +21663,8 @@ x86_output_mi_thunk (FILE *file, tree thunk_fndecl, HOST_WIDE_INT delta,\n   final (insn, file, 1);\n   final_end_function ();\n   assemble_end_function (thunk_fndecl, fnname);\n+\n+  flag_force_indirect_call = saved_flag_force_indirect_call;\n }\n \n static void"}, {"sha": "dd9391c492b0611322243fa9825bc4cd387fd29a", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -397,10 +397,16 @@ extern unsigned char ix86_tune_features[X86_TUNE_LAST];\n \tix86_tune_features[X86_TUNE_AVOID_4BYTE_PREFIXES]\n #define TARGET_USE_GATHER_2PARTS \\\n \tix86_tune_features[X86_TUNE_USE_GATHER_2PARTS]\n+#define TARGET_USE_SCATTER_2PARTS \\\n+\tix86_tune_features[X86_TUNE_USE_SCATTER_2PARTS]\n #define TARGET_USE_GATHER_4PARTS \\\n \tix86_tune_features[X86_TUNE_USE_GATHER_4PARTS]\n+#define TARGET_USE_SCATTER_4PARTS \\\n+\tix86_tune_features[X86_TUNE_USE_SCATTER_4PARTS]\n #define TARGET_USE_GATHER \\\n \tix86_tune_features[X86_TUNE_USE_GATHER]\n+#define TARGET_USE_SCATTER \\\n+\tix86_tune_features[X86_TUNE_USE_SCATTER]\n #define TARGET_FUSE_CMP_AND_BRANCH_32 \\\n \tix86_tune_features[X86_TUNE_FUSE_CMP_AND_BRANCH_32]\n #define TARGET_FUSE_CMP_AND_BRANCH_64 \\"}, {"sha": "7d57f617d65ba8e8ab32e1618c90fad7cbb075c2", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1209,7 +1209,7 @@ Support MWAIT and MONITOR built-in functions and code generation.\n \n mavx512fp16\n Target Mask(ISA2_AVX512FP16) Var(ix86_isa_flags2) Save\n-Support MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, AVX, AVX2, AVX512F and AVX512FP16 built-in functions and code generation.\n+Support MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, AVX, AVX2, AVX512F and AVX512-FP16 built-in functions and code generation.\n \n mdirect-extern-access\n Target Var(ix86_direct_extern_access) Init(1)"}, {"sha": "6a55baaa4587e926c7e0f83583410c9e0efc18fa", "filename": "gcc/config/i386/mingw32.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fi386%2Fmingw32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fi386%2Fmingw32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fmingw32.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -196,7 +196,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #undef ENDFILE_SPEC\n #define ENDFILE_SPEC \\\n-  \"%{Ofast|ffast-math|funsafe-math-optimizations:crtfastmath.o%s} \\\n+  \"%{mdaz-ftz:crtfastmath.o%s;Ofast|ffast-math|funsafe-math-optimizations:%{!shared:%{!mno-daz-ftz:crtfastmath.o%s}}} \\\n    %{!shared:%:if-exists(default-manifest.o%s)}\\\n    %{fvtable-verify=none:%s; \\\n     fvtable-verify=preinit:vtv_end.o%s; \\"}, {"sha": "c78dad07c88465df0dcbd7602598a13538398e82", "filename": "gcc/config/i386/x86-tune.def", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fi386%2Fx86-tune.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fi386%2Fx86-tune.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx86-tune.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -483,28 +483,43 @@ DEF_TUNE (X86_TUNE_AVOID_4BYTE_PREFIXES, \"avoid_4byte_prefixes\",\n DEF_TUNE (X86_TUNE_USE_GATHER_2PARTS, \"use_gather_2parts\",\n \t  ~(m_ZNVER1 | m_ZNVER2 | m_ZNVER3 | m_ZNVER4 | m_ALDERLAKE | m_CORE_ATOM | m_GENERIC))\n \n+/* X86_TUNE_USE_SCATTER_2PARTS: Use scater instructions for vectors with 2\n+   elements.  */\n+DEF_TUNE (X86_TUNE_USE_SCATTER_2PARTS, \"use_scatter_2parts\",\n+\t  ~(m_ZNVER4 | m_GENERIC))\n+\n /* X86_TUNE_USE_GATHER_4PARTS: Use gather instructions for vectors with 4\n    elements.  */\n DEF_TUNE (X86_TUNE_USE_GATHER_4PARTS, \"use_gather_4parts\",\n \t  ~(m_ZNVER1 | m_ZNVER2 | m_ZNVER3 | m_ZNVER4 | m_ALDERLAKE | m_CORE_ATOM | m_GENERIC))\n \n+/* X86_TUNE_USE_SCATTER_4PARTS: Use scater instructions for vectors with 4\n+   elements.  */\n+DEF_TUNE (X86_TUNE_USE_SCATTER_4PARTS, \"use_scatter_4parts\",\n+\t  ~(m_ZNVER4 | m_GENERIC))\n+\n /* X86_TUNE_USE_GATHER: Use gather instructions for vectors with 8 or more\n    elements.  */\n DEF_TUNE (X86_TUNE_USE_GATHER, \"use_gather\",\n-\t  ~(m_ZNVER1 | m_ZNVER2 | m_ALDERLAKE | m_CORE_ATOM | m_GENERIC))\n+\t  ~(m_ZNVER1 | m_ZNVER2 | m_ZNVER4 | m_ALDERLAKE | m_CORE_ATOM | m_GENERIC))\n+\n+/* X86_TUNE_USE_SCATTER: Use scater instructions for vectors with 8 or more\n+   elements.  */\n+DEF_TUNE (X86_TUNE_USE_SCATTER, \"use_scatter\",\n+\t  ~(m_ZNVER4 | m_GENERIC))\n \n /* X86_TUNE_AVOID_128FMA_CHAINS: Avoid creating loops with tight 128bit or\n    smaller FMA chain.  */\n-DEF_TUNE (X86_TUNE_AVOID_128FMA_CHAINS, \"avoid_fma_chains\", m_ZNVER)\n+DEF_TUNE (X86_TUNE_AVOID_128FMA_CHAINS, \"avoid_fma_chains\", m_ZNVER1 | m_ZNVER2 | m_ZNVER3)\n \n /* X86_TUNE_AVOID_256FMA_CHAINS: Avoid creating loops with tight 256bit or\n    smaller FMA chain.  */\n-DEF_TUNE (X86_TUNE_AVOID_256FMA_CHAINS, \"avoid_fma256_chains\", m_ZNVER2 | m_ZNVER3 | m_ZNVER4\n+DEF_TUNE (X86_TUNE_AVOID_256FMA_CHAINS, \"avoid_fma256_chains\", m_ZNVER2 | m_ZNVER3\n \t  | m_ALDERLAKE | m_SAPPHIRERAPIDS | m_CORE_ATOM)\n \n /* X86_TUNE_AVOID_512FMA_CHAINS: Avoid creating loops with tight 512bit or\n    smaller FMA chain.  */\n-DEF_TUNE (X86_TUNE_AVOID_512FMA_CHAINS, \"avoid_fma512_chains\", m_ZNVER4)\n+DEF_TUNE (X86_TUNE_AVOID_512FMA_CHAINS, \"avoid_fma512_chains\", m_NONE)\n \n /* X86_TUNE_V2DF_REDUCTION_PREFER_PHADDPD: Prefer haddpd\n    for v2df vector reduction.  */"}, {"sha": "5dfd428aa17c8f344b94204de0cb0ea3af8fab19", "filename": "gcc/config/ia64/linux.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fia64%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fia64%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Flinux.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -49,7 +49,7 @@ do {\t\t\t\t\t\t\\\n /* Similar to standard Linux, but adding -ffast-math support.  */\n #undef  ENDFILE_SPEC\n #define ENDFILE_SPEC \\\n-  \"%{Ofast|ffast-math|funsafe-math-optimizations:crtfastmath.o%s} \\\n+  \"%{Ofast|ffast-math|funsafe-math-optimizations:%{!shared:crtfastmath.o%s}} \\\n    %{shared|pie:crtendS.o%s;:crtend.o%s} crtn.o%s\"\n \n /* Define this for shared library support because it isn't in the main"}, {"sha": "aecaa02a1999b3bfcd787e1699615d45f9c31da6", "filename": "gcc/config/loongarch/gnu-user.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Floongarch%2Fgnu-user.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Floongarch%2Fgnu-user.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Fgnu-user.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -49,7 +49,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Similar to standard Linux, but adding -ffast-math support.  */\n #undef GNU_USER_TARGET_MATHFILE_SPEC\n #define GNU_USER_TARGET_MATHFILE_SPEC \\\n-  \"%{Ofast|ffast-math|funsafe-math-optimizations:crtfastmath.o%s}\"\n+  \"%{Ofast|ffast-math|funsafe-math-optimizations:%{!shared:crtfastmath.o%s}}\"\n \n #undef LIB_SPEC\n #define LIB_SPEC GNU_USER_TARGET_LIB_SPEC"}, {"sha": "6927bdc7fe5f4ce77f5e2acc4f18e8fcf2b18454", "filename": "gcc/config/loongarch/loongarch.cc", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Floongarch%2Floongarch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Floongarch%2Floongarch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Floongarch.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -2075,6 +2075,11 @@ loongarch_classify_address (struct loongarch_address_info *info, rtx x,\n       return (loongarch_valid_base_register_p (info->reg, mode, strict_p)\n \t      && loongarch_valid_lo_sum_p (info->symbol_type, mode,\n \t\t\t\t\t   info->offset));\n+    case CONST_INT:\n+      /* Small-integer addresses don't occur very often, but they\n+\t are legitimate if $r0 is a valid base register.  */\n+      info->type = ADDRESS_CONST_INT;\n+      return IMM12_OPERAND (INTVAL (x));\n \n     default:\n       return false;\n@@ -4933,6 +4938,7 @@ loongarch_print_operand_reloc (FILE *file, rtx op, bool hi64_part,\n \n    'A'\tPrint a _DB suffix if the memory model requires a release.\n    'b'\tPrint the address of a memory operand, without offset.\n+   'c'  Print an integer.\n    'C'\tPrint the integer branch condition for comparison OP.\n    'd'\tPrint CONST_INT OP in decimal.\n    'F'\tPrint the FPU branch condition for comparison OP.\n@@ -4979,6 +4985,14 @@ loongarch_print_operand (FILE *file, rtx op, int letter)\n        fputs (\"_db\", file);\n       break;\n \n+    case 'c':\n+      if (CONST_INT_P (op))\n+\tfprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (op));\n+      else\n+\toutput_operand_lossage (\"unsupported operand for code '%c'\", letter);\n+\n+      break;\n+\n     case 'C':\n       loongarch_print_int_branch_condition (file, code, letter);\n       break;"}, {"sha": "a4e5380b5894241ad3f9896f0ebdefa4a664a428", "filename": "gcc/config/mips/gnu-user.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fmips%2Fgnu-user.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fmips%2Fgnu-user.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fgnu-user.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -139,7 +139,7 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n /* Similar to standard Linux, but adding -ffast-math support.  */\n #undef\tGNU_USER_TARGET_MATHFILE_SPEC\n #define GNU_USER_TARGET_MATHFILE_SPEC \\\n-  \"%{Ofast|ffast-math|funsafe-math-optimizations:crtfastmath.o%s}\"\n+  \"%{Ofast|ffast-math|funsafe-math-optimizations:%{!shared:crtfastmath.o%s}}\"\n #undef  ENDFILE_SPEC\n #define ENDFILE_SPEC \\\n   GNU_USER_TARGET_MATHFILE_SPEC \" \" \\"}, {"sha": "1b5e874bc06bc7794a75047648b4ec3ee7a42ec3", "filename": "gcc/config/pru/pru.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fpru%2Fpru.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fpru%2Fpru.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpru.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -566,8 +566,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define CASE_VECTOR_MODE Pmode\n \n-/* See definition of clz pattern for rationale of value -1.  */\n-#define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) ((VALUE) = -1, 2)\n+/* See definition of clz pattern for rationale of the value.  */\n+#define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE)\t\\\n+\t((VALUE) = GET_MODE_BITSIZE (MODE) - 1 - 32, 2)\n \n /* Jumps are cheap on PRU.  */\n #define LOGICAL_OP_NON_SHORT_CIRCUIT\t\t0"}, {"sha": "6deb5ecfecb3687e4746d0ee0e25477492b3a20e", "filename": "gcc/config/pru/pru.md", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fpru%2Fpru.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fpru%2Fpru.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpru.md?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1723,8 +1723,16 @@\n   [(set_attr \"type\" \"control\")])\n \n ;; Count Leading Zeros implemented using LMBD.\n-;; LMBD returns 32 if bit value is not present, and we subtract 31 to get CLZ.\n-;; Hence we get a defined value -1 for CLZ_DEFINED_VALUE_AT_ZERO.\n+;;\n+;; LMBD returns 32 if bit value is not present, for any kind of input MODE.\n+;; The LMBD's search result for a \"1\" bit is subtracted from the\n+;; mode bit size minus one, in order to get CLZ.\n+;;\n+;; Hence for SImode we get a defined value -1 for CLZ_DEFINED_VALUE_AT_ZERO.\n+;;\n+;; The QImode and HImode defined values for zero inputs end up to be\n+;; non-standard (-25 and -17).  But this is considered acceptable in\n+;; order to keep the CLZ expansion to only two instructions.\n (define_expand \"clz<mode>2\"\n   [(set (match_operand:QISI 0 \"register_operand\")\n \t(clz:QISI (match_operand:QISI 1 \"register_operand\")))]\n@@ -1735,7 +1743,8 @@\n   rtx tmpval = gen_reg_rtx (<MODE>mode);\n \n   emit_insn (gen_pru_lmbd (<MODE>mode, tmpval, src, const1_rtx));\n-  emit_insn (gen_sub3_insn (dst, GEN_INT (31), tmpval));\n+  int msb_bitn = GET_MODE_BITSIZE (<MODE>mode) - 1;\n+  emit_insn (gen_sub3_insn (dst, GEN_INT (msb_bitn), tmpval));\n   DONE;\n })\n "}, {"sha": "f9013bbf8bb1582c393e3cf28e7f6dceea406fac", "filename": "gcc/config/riscv/predicates.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fpredicates.md?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -286,6 +286,10 @@\n \t    (match_test \"GET_CODE (op) == UNSPEC\n \t\t\t && (XINT (op, 1) == UNSPEC_VUNDEF)\"))))\n \n+(define_special_predicate \"pmode_reg_or_0_operand\"\n+  (ior (match_operand 0 \"const_0_operand\")\n+       (match_operand 0 \"pmode_register_operand\")))\n+\n ;; The scalar operand can be directly broadcast by RVV instructions.\n (define_predicate \"direct_broadcast_operand\"\n   (ior (match_operand 0 \"register_operand\")"}, {"sha": "4084122cf0a8edef3486862a57005ba279501e07", "filename": "gcc/config/riscv/riscv-passes.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Friscv-passes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Friscv-passes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-passes.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -18,4 +18,4 @@\n    <http://www.gnu.org/licenses/>.  */\n \n INSERT_PASS_AFTER (pass_rtl_store_motion, 1, pass_shorten_memrefs);\n-INSERT_PASS_BEFORE (pass_sched2, 1, pass_vsetvl);\n+INSERT_PASS_BEFORE (pass_fast_rtl_dce, 1, pass_vsetvl);"}, {"sha": "ceae4007fd1d3fe8c3c61d76e62b4fef759d77a4", "filename": "gcc/config/riscv/riscv-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-protos.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -172,6 +172,7 @@ enum mask_policy\n enum tail_policy get_prefer_tail_policy ();\n enum mask_policy get_prefer_mask_policy ();\n rtx get_avl_type_rtx (enum avl_type);\n+opt_machine_mode get_vector_mode (scalar_mode, poly_uint64);\n }\n \n /* We classify builtin types into two classes:"}, {"sha": "992b3437926a08cf2b0c09b1139aa79cbe263b2d", "filename": "gcc/config/riscv/riscv-v.cc", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Friscv-v.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Friscv-v.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-v.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -349,4 +349,26 @@ get_avl_type_rtx (enum avl_type type)\n   return gen_int_mode (type, Pmode);\n }\n \n+/* Return the RVV vector mode that has NUNITS elements of mode INNER_MODE.\n+   This function is not only used by builtins, but also will be used by\n+   auto-vectorization in the future.  */\n+opt_machine_mode\n+get_vector_mode (scalar_mode inner_mode, poly_uint64 nunits)\n+{\n+  enum mode_class mclass;\n+  if (inner_mode == E_BImode)\n+    mclass = MODE_VECTOR_BOOL;\n+  else if (FLOAT_MODE_P (inner_mode))\n+    mclass = MODE_VECTOR_FLOAT;\n+  else\n+    mclass = MODE_VECTOR_INT;\n+  machine_mode mode;\n+  FOR_EACH_MODE_IN_CLASS (mode, mclass)\n+    if (inner_mode == GET_MODE_INNER (mode)\n+\t&& known_eq (nunits, GET_MODE_NUNITS (mode))\n+\t&& riscv_v_ext_vector_mode_p (mode))\n+      return mode;\n+  return opt_machine_mode ();\n+}\n+\n } // namespace riscv_vector"}, {"sha": "129e89f443eff3866ef018714cf299a680f6db76", "filename": "gcc/config/riscv/riscv-vector-builtins-bases.cc", "status": "modified", "additions": 90, "deletions": 8, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -48,6 +48,16 @@ using namespace riscv_vector;\n \n namespace riscv_vector {\n \n+/* Enumerates types of loads/stores operations.\n+   It's only used in here so we don't define it\n+   in riscv-vector-builtins-bases.h.  */\n+enum lst_type\n+{\n+  LST_UNIT_STRIDE,\n+  LST_STRIDED,\n+  LST_INDEXED,\n+};\n+\n /* Implements vsetvl<mode> && vsetvlmax<mode>.  */\n template<bool VLMAX_P>\n class vsetvl : public function_base\n@@ -84,10 +94,16 @@ class vsetvl : public function_base\n   }\n };\n \n-/* Implements vle.v/vse.v codegen.  */\n-template <bool STORE_P>\n+/* Implements\n+ * vle.v/vse.v/vlm.v/vsm.v/vlse.v/vsse.v/vluxei.v/vloxei.v/vsuxei.v/vsoxei.v\n+ * codegen.  */\n+template<bool STORE_P, lst_type LST_TYPE, bool ORDERED_P>\n class loadstore : public function_base\n {\n+public:\n+  bool apply_tail_policy_p () const override { return !STORE_P; }\n+  bool apply_mask_policy_p () const override { return !STORE_P; }\n+\n   unsigned int call_properties (const function_instance &) const override\n   {\n     if (STORE_P)\n@@ -98,24 +114,70 @@ class loadstore : public function_base\n \n   bool can_be_overloaded_p (enum predication_type_index pred) const override\n   {\n-    if (STORE_P)\n+    if (STORE_P || LST_TYPE == LST_INDEXED)\n       return true;\n     return pred != PRED_TYPE_none && pred != PRED_TYPE_mu;\n   }\n \n   rtx expand (function_expander &e) const override\n   {\n-    if (STORE_P)\n-      return e.use_contiguous_store_insn (code_for_pred_mov (e.vector_mode ()));\n+    if (LST_TYPE == LST_INDEXED)\n+      {\n+\tint unspec = ORDERED_P ? UNSPEC_ORDERED : UNSPEC_UNORDERED;\n+\tif (STORE_P)\n+\t  return e.use_exact_insn (\n+\t    code_for_pred_indexed_store (unspec, e.vector_mode (),\n+\t\t\t\t\t e.index_mode ()));\n+\telse\n+\t  return e.use_exact_insn (\n+\t    code_for_pred_indexed_load (unspec, e.vector_mode (),\n+\t\t\t\t\te.index_mode ()));\n+      }\n+    else if (LST_TYPE == LST_STRIDED)\n+      {\n+\tif (STORE_P)\n+\t  return e.use_contiguous_store_insn (\n+\t    code_for_pred_strided_store (e.vector_mode ()));\n+\telse\n+\t  return e.use_contiguous_load_insn (\n+\t    code_for_pred_strided_load (e.vector_mode ()));\n+      }\n     else\n-      return e.use_contiguous_load_insn (code_for_pred_mov (e.vector_mode ()));\n+      {\n+\tif (STORE_P)\n+\t  return e.use_contiguous_store_insn (\n+\t    code_for_pred_store (e.vector_mode ()));\n+\telse\n+\t  return e.use_contiguous_load_insn (\n+\t    code_for_pred_mov (e.vector_mode ()));\n+      }\n   }\n };\n \n static CONSTEXPR const vsetvl<false> vsetvl_obj;\n static CONSTEXPR const vsetvl<true> vsetvlmax_obj;\n-static CONSTEXPR const loadstore<false> vle_obj;\n-static CONSTEXPR const loadstore<true> vse_obj;\n+static CONSTEXPR const loadstore<false, LST_UNIT_STRIDE, false> vle_obj;\n+static CONSTEXPR const loadstore<true, LST_UNIT_STRIDE, false> vse_obj;\n+static CONSTEXPR const loadstore<false, LST_UNIT_STRIDE, false> vlm_obj;\n+static CONSTEXPR const loadstore<true, LST_UNIT_STRIDE, false> vsm_obj;\n+static CONSTEXPR const loadstore<false, LST_STRIDED, false> vlse_obj;\n+static CONSTEXPR const loadstore<true, LST_STRIDED, false> vsse_obj;\n+static CONSTEXPR const loadstore<false, LST_INDEXED, false> vluxei8_obj;\n+static CONSTEXPR const loadstore<false, LST_INDEXED, false> vluxei16_obj;\n+static CONSTEXPR const loadstore<false, LST_INDEXED, false> vluxei32_obj;\n+static CONSTEXPR const loadstore<false, LST_INDEXED, false> vluxei64_obj;\n+static CONSTEXPR const loadstore<false, LST_INDEXED, true> vloxei8_obj;\n+static CONSTEXPR const loadstore<false, LST_INDEXED, true> vloxei16_obj;\n+static CONSTEXPR const loadstore<false, LST_INDEXED, true> vloxei32_obj;\n+static CONSTEXPR const loadstore<false, LST_INDEXED, true> vloxei64_obj;\n+static CONSTEXPR const loadstore<true, LST_INDEXED, false> vsuxei8_obj;\n+static CONSTEXPR const loadstore<true, LST_INDEXED, false> vsuxei16_obj;\n+static CONSTEXPR const loadstore<true, LST_INDEXED, false> vsuxei32_obj;\n+static CONSTEXPR const loadstore<true, LST_INDEXED, false> vsuxei64_obj;\n+static CONSTEXPR const loadstore<true, LST_INDEXED, true> vsoxei8_obj;\n+static CONSTEXPR const loadstore<true, LST_INDEXED, true> vsoxei16_obj;\n+static CONSTEXPR const loadstore<true, LST_INDEXED, true> vsoxei32_obj;\n+static CONSTEXPR const loadstore<true, LST_INDEXED, true> vsoxei64_obj;\n \n /* Declare the function base NAME, pointing it to an instance\n    of class <NAME>_obj.  */\n@@ -126,5 +188,25 @@ BASE (vsetvl)\n BASE (vsetvlmax)\n BASE (vle)\n BASE (vse)\n+BASE (vlm)\n+BASE (vsm)\n+BASE (vlse)\n+BASE (vsse)\n+BASE (vluxei8)\n+BASE (vluxei16)\n+BASE (vluxei32)\n+BASE (vluxei64)\n+BASE (vloxei8)\n+BASE (vloxei16)\n+BASE (vloxei32)\n+BASE (vloxei64)\n+BASE (vsuxei8)\n+BASE (vsuxei16)\n+BASE (vsuxei32)\n+BASE (vsuxei64)\n+BASE (vsoxei8)\n+BASE (vsoxei16)\n+BASE (vsoxei32)\n+BASE (vsoxei64)\n \n } // end namespace riscv_vector"}, {"sha": "238c01dbf1fe491cbcd8e60f5891cece586081ac", "filename": "gcc/config/riscv/riscv-vector-builtins-bases.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -28,6 +28,26 @@ extern const function_base *const vsetvl;\n extern const function_base *const vsetvlmax;\n extern const function_base *const vle;\n extern const function_base *const vse;\n+extern const function_base *const vlm;\n+extern const function_base *const vsm;\n+extern const function_base *const vlse;\n+extern const function_base *const vsse;\n+extern const function_base *const vluxei8;\n+extern const function_base *const vluxei16;\n+extern const function_base *const vluxei32;\n+extern const function_base *const vluxei64;\n+extern const function_base *const vloxei8;\n+extern const function_base *const vloxei16;\n+extern const function_base *const vloxei32;\n+extern const function_base *const vloxei64;\n+extern const function_base *const vsuxei8;\n+extern const function_base *const vsuxei16;\n+extern const function_base *const vsuxei32;\n+extern const function_base *const vsuxei64;\n+extern const function_base *const vsoxei8;\n+extern const function_base *const vsoxei16;\n+extern const function_base *const vsoxei32;\n+extern const function_base *const vsoxei64;\n }\n \n } // end namespace riscv_vector"}, {"sha": "9719b9b4bf122c6e87b99727a32b53df19ed30df", "filename": "gcc/config/riscv/riscv-vector-builtins-functions.def", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-functions.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-functions.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-functions.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -42,5 +42,25 @@ DEF_RVV_FUNCTION (vsetvlmax, vsetvlmax, none_preds, i_none_size_void_ops)\n /* 7. Vector Loads and Stores. */\n DEF_RVV_FUNCTION (vle, loadstore, full_preds, all_v_scalar_const_ptr_ops)\n DEF_RVV_FUNCTION (vse, loadstore, none_m_preds, all_v_scalar_ptr_ops)\n+DEF_RVV_FUNCTION (vlm, loadstore, none_preds, b_v_scalar_const_ptr_ops)\n+DEF_RVV_FUNCTION (vsm, loadstore, none_preds, b_v_scalar_ptr_ops)\n+DEF_RVV_FUNCTION (vlse, loadstore, full_preds, all_v_scalar_const_ptr_ptrdiff_ops)\n+DEF_RVV_FUNCTION (vsse, loadstore, none_m_preds, all_v_scalar_ptr_ptrdiff_ops)\n+DEF_RVV_FUNCTION (vluxei8, indexed_loadstore, full_preds, all_v_scalar_const_ptr_uint8_index_ops)\n+DEF_RVV_FUNCTION (vluxei16, indexed_loadstore, full_preds, all_v_scalar_const_ptr_uint16_index_ops)\n+DEF_RVV_FUNCTION (vluxei32, indexed_loadstore, full_preds, all_v_scalar_const_ptr_uint32_index_ops)\n+DEF_RVV_FUNCTION (vluxei64, indexed_loadstore, full_preds, all_v_scalar_const_ptr_uint64_index_ops)\n+DEF_RVV_FUNCTION (vloxei8, indexed_loadstore, full_preds, all_v_scalar_const_ptr_uint8_index_ops)\n+DEF_RVV_FUNCTION (vloxei16, indexed_loadstore, full_preds, all_v_scalar_const_ptr_uint16_index_ops)\n+DEF_RVV_FUNCTION (vloxei32, indexed_loadstore, full_preds, all_v_scalar_const_ptr_uint32_index_ops)\n+DEF_RVV_FUNCTION (vloxei64, indexed_loadstore, full_preds, all_v_scalar_const_ptr_uint64_index_ops)\n+DEF_RVV_FUNCTION (vsuxei8, indexed_loadstore, none_m_preds, all_v_scalar_ptr_uint8_index_ops)\n+DEF_RVV_FUNCTION (vsuxei16, indexed_loadstore, none_m_preds, all_v_scalar_ptr_uint16_index_ops)\n+DEF_RVV_FUNCTION (vsuxei32, indexed_loadstore, none_m_preds, all_v_scalar_ptr_uint32_index_ops)\n+DEF_RVV_FUNCTION (vsuxei64, indexed_loadstore, none_m_preds, all_v_scalar_ptr_uint64_index_ops)\n+DEF_RVV_FUNCTION (vsoxei8, indexed_loadstore, none_m_preds, all_v_scalar_ptr_uint8_index_ops)\n+DEF_RVV_FUNCTION (vsoxei16, indexed_loadstore, none_m_preds, all_v_scalar_ptr_uint16_index_ops)\n+DEF_RVV_FUNCTION (vsoxei32, indexed_loadstore, none_m_preds, all_v_scalar_ptr_uint32_index_ops)\n+DEF_RVV_FUNCTION (vsoxei64, indexed_loadstore, none_m_preds, all_v_scalar_ptr_uint64_index_ops)\n \n #undef DEF_RVV_FUNCTION"}, {"sha": "d261dfbceb7088640b1f265057c38f4e5ed9ac61", "filename": "gcc/config/riscv/riscv-vector-builtins-shapes.cc", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -116,7 +116,8 @@ struct loadstore_def : public build_base\n     machine_mode mode = TYPE_MODE (type);\n     int sew = GET_MODE_BITSIZE (GET_MODE_INNER (mode));\n     /* vop --> vop<sew>.  */\n-    b.append_sew (sew);\n+    if (GET_MODE_CLASS (mode) != MODE_VECTOR_BOOL)\n+      b.append_sew (sew);\n \n     /* vop<sew>_v --> vop<sew>_v_<type>.  */\n     if (!overloaded_p)\n@@ -127,6 +128,58 @@ struct loadstore_def : public build_base\n \tb.append_name (type_suffixes[instance.type.index].vector);\n       }\n \n+    /* According to rvv-intrinsic-doc, it does not add \"_m\" suffix\n+       for vop_m C++ overloaded API.  */\n+    if (overloaded_p && instance.pred == PRED_TYPE_m)\n+      return b.finish_name ();\n+    b.append_name (predication_suffixes[instance.pred]);\n+    return b.finish_name ();\n+  }\n+};\n+\n+/* indexed_loadstore_def class.  */\n+struct indexed_loadstore_def : public function_shape\n+{\n+  void build (function_builder &b,\n+\t      const function_group_info &group) const override\n+  {\n+    for (unsigned int pred_idx = 0; group.preds[pred_idx] != NUM_PRED_TYPES;\n+\t ++pred_idx)\n+      {\n+\tfor (unsigned int vec_type_idx = 0;\n+\t     group.ops_infos.types[vec_type_idx].index != NUM_VECTOR_TYPES;\n+\t     ++vec_type_idx)\n+\t  {\n+\t    tree index_type = group.ops_infos.args[1].get_tree_type (\n+\t      group.ops_infos.types[vec_type_idx].index);\n+\t    if (!index_type)\n+\t      continue;\n+\t    build_one (b, group, pred_idx, vec_type_idx);\n+\t  }\n+      }\n+  }\n+\n+  char *get_name (function_builder &b, const function_instance &instance,\n+\t\t  bool overloaded_p) const override\n+  {\n+    /* Return nullptr if it can not be overloaded.  */\n+    if (overloaded_p && !instance.base->can_be_overloaded_p (instance.pred))\n+      return nullptr;\n+\n+    b.append_base_name (instance.base_name);\n+    /* vop<sew>_v --> vop<sew>_v_<type>.  */\n+    if (!overloaded_p)\n+      {\n+\t/* vop<sew> --> vop<sew>_v.  */\n+\tb.append_name (operand_suffixes[instance.op_info->op]);\n+\t/* vop<sew>_v --> vop<sew>_v_<type>.  */\n+\tb.append_name (type_suffixes[instance.type.index].vector);\n+      }\n+\n+    /* According to rvv-intrinsic-doc, it does not add \"_m\" suffix\n+       for vop_m C++ overloaded API.  */\n+    if (overloaded_p && instance.pred == PRED_TYPE_m)\n+      return b.finish_name ();\n     b.append_name (predication_suffixes[instance.pred]);\n     return b.finish_name ();\n   }\n@@ -135,5 +188,6 @@ struct loadstore_def : public build_base\n SHAPE(vsetvl, vsetvl)\n SHAPE(vsetvl, vsetvlmax)\n SHAPE(loadstore, loadstore)\n+SHAPE(indexed_loadstore, indexed_loadstore)\n \n } // end namespace riscv_vector"}, {"sha": "05bc68b7f12fa6467afa9b4e62406008997a0715", "filename": "gcc/config/riscv/riscv-vector-builtins-shapes.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -27,6 +27,7 @@ namespace shapes {\n extern const function_shape *const vsetvl;\n extern const function_shape *const vsetvlmax;\n extern const function_shape *const loadstore;\n+extern const function_shape *const indexed_loadstore;\n }\n \n } // end namespace riscv_vector"}, {"sha": "a95fad031bedc0dee6edd5ac4bbcb27556f734cc", "filename": "gcc/config/riscv/riscv-vector-builtins-types.def", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-types.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -36,6 +36,12 @@ along with GCC; see the file COPYING3. If not see\n #define DEF_RVV_F_OPS(TYPE, REQUIRE)\n #endif\n \n+/* Use \"DEF_RVV_B_OPS\" macro include all bool value which will be\n+   iterated and registered as intrinsic functions.  */\n+#ifndef DEF_RVV_B_OPS\n+#define DEF_RVV_B_OPS(TYPE, REQUIRE)\n+#endif\n+\n DEF_RVV_I_OPS (vint8mf8_t, RVV_REQUIRE_ZVE64)\n DEF_RVV_I_OPS (vint8mf4_t, 0)\n DEF_RVV_I_OPS (vint8mf2_t, 0)\n@@ -92,6 +98,15 @@ DEF_RVV_F_OPS (vfloat64m2_t, RVV_REQUIRE_ELEN_FP_64)\n DEF_RVV_F_OPS (vfloat64m4_t, RVV_REQUIRE_ELEN_FP_64)\n DEF_RVV_F_OPS (vfloat64m8_t, RVV_REQUIRE_ELEN_FP_64)\n \n+DEF_RVV_B_OPS (vbool64_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_B_OPS (vbool32_t, 0)\n+DEF_RVV_B_OPS (vbool16_t, 0)\n+DEF_RVV_B_OPS (vbool8_t, 0)\n+DEF_RVV_B_OPS (vbool4_t, 0)\n+DEF_RVV_B_OPS (vbool2_t, 0)\n+DEF_RVV_B_OPS (vbool1_t, 0)\n+\n #undef DEF_RVV_I_OPS\n #undef DEF_RVV_U_OPS\n #undef DEF_RVV_F_OPS\n+#undef DEF_RVV_B_OPS"}, {"sha": "df4e2ee18417f96b7237dff88f45482d74f5660a", "filename": "gcc/config/riscv/riscv-vector-builtins.cc", "status": "modified", "additions": 332, "deletions": 32, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -141,6 +141,12 @@ static const rvv_type_info all_ops[] = {\n #include \"riscv-vector-builtins-types.def\"\n   {NUM_VECTOR_TYPES, 0}};\n \n+/* A list of all bool will be registered for intrinsic functions.  */\n+static const rvv_type_info b_ops[] = {\n+#define DEF_RVV_B_OPS(TYPE, REQUIRE) {VECTOR_TYPE_##TYPE, REQUIRE},\n+#include \"riscv-vector-builtins-types.def\"\n+  {NUM_VECTOR_TYPES, 0}};\n+\n static CONSTEXPR const rvv_arg_type_info rvv_arg_type_info_end\n   = rvv_arg_type_info (NUM_BASE_TYPES);\n \n@@ -158,7 +164,72 @@ static CONSTEXPR const rvv_arg_type_info scalar_const_ptr_args[]\n \n /* A list of args for void func (scalar_type *, vector_type) function.  */\n static CONSTEXPR const rvv_arg_type_info scalar_ptr_args[]\n+  = {rvv_arg_type_info (RVV_BASE_scalar_ptr),\n+     rvv_arg_type_info (RVV_BASE_vector), rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (const scalar_type *, ptrdiff_t)\n+ * function.  */\n+static CONSTEXPR const rvv_arg_type_info scalar_const_ptr_ptrdiff_args[]\n   = {rvv_arg_type_info (RVV_BASE_scalar_const_ptr),\n+     rvv_arg_type_info (RVV_BASE_ptrdiff), rvv_arg_type_info_end};\n+\n+/* A list of args for void func (scalar_type *, ptrdiff_t, vector_type)\n+ * function.  */\n+static CONSTEXPR const rvv_arg_type_info scalar_ptr_ptrdiff_args[]\n+  = {rvv_arg_type_info (RVV_BASE_scalar_ptr),\n+     rvv_arg_type_info (RVV_BASE_ptrdiff), rvv_arg_type_info (RVV_BASE_vector),\n+     rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (const scalar_type *, uint8_index_type)\n+ * function.  */\n+static CONSTEXPR const rvv_arg_type_info scalar_const_ptr_uint8_index_args[]\n+  = {rvv_arg_type_info (RVV_BASE_scalar_const_ptr),\n+     rvv_arg_type_info (RVV_BASE_uint8_index), rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (const scalar_type *, uint16_index_type)\n+ * function.  */\n+static CONSTEXPR const rvv_arg_type_info scalar_const_ptr_uint16_index_args[]\n+  = {rvv_arg_type_info (RVV_BASE_scalar_const_ptr),\n+     rvv_arg_type_info (RVV_BASE_uint16_index), rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (const scalar_type *, uint32_index_type)\n+ * function.  */\n+static CONSTEXPR const rvv_arg_type_info scalar_const_ptr_uint32_index_args[]\n+  = {rvv_arg_type_info (RVV_BASE_scalar_const_ptr),\n+     rvv_arg_type_info (RVV_BASE_uint32_index), rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (const scalar_type *, uint64_index_type)\n+ * function.  */\n+static CONSTEXPR const rvv_arg_type_info scalar_const_ptr_uint64_index_args[]\n+  = {rvv_arg_type_info (RVV_BASE_scalar_const_ptr),\n+     rvv_arg_type_info (RVV_BASE_uint64_index), rvv_arg_type_info_end};\n+\n+/* A list of args for void func (scalar_type *, uint8_index_type, vector_type)\n+ * function.  */\n+static CONSTEXPR const rvv_arg_type_info scalar_ptr_uint8_index_args[]\n+  = {rvv_arg_type_info (RVV_BASE_scalar_ptr),\n+     rvv_arg_type_info (RVV_BASE_uint8_index),\n+     rvv_arg_type_info (RVV_BASE_vector), rvv_arg_type_info_end};\n+\n+/* A list of args for void func (scalar_type *, uint16_index_type, vector_type)\n+ * function.  */\n+static CONSTEXPR const rvv_arg_type_info scalar_ptr_uint16_index_args[]\n+  = {rvv_arg_type_info (RVV_BASE_scalar_ptr),\n+     rvv_arg_type_info (RVV_BASE_uint16_index),\n+     rvv_arg_type_info (RVV_BASE_vector), rvv_arg_type_info_end};\n+\n+/* A list of args for void func (scalar_type *, uint32_index_type, vector_type)\n+ * function.  */\n+static CONSTEXPR const rvv_arg_type_info scalar_ptr_uint32_index_args[]\n+  = {rvv_arg_type_info (RVV_BASE_scalar_ptr),\n+     rvv_arg_type_info (RVV_BASE_uint32_index),\n+     rvv_arg_type_info (RVV_BASE_vector), rvv_arg_type_info_end};\n+\n+/* A list of args for void func (scalar_type *, uint64_index_type, vector_type)\n+ * function.  */\n+static CONSTEXPR const rvv_arg_type_info scalar_ptr_uint64_index_args[]\n+  = {rvv_arg_type_info (RVV_BASE_scalar_ptr),\n+     rvv_arg_type_info (RVV_BASE_uint64_index),\n      rvv_arg_type_info (RVV_BASE_vector), rvv_arg_type_info_end};\n \n /* A list of none preds that will be registered for intrinsic functions.  */\n@@ -205,6 +276,102 @@ static CONSTEXPR const rvv_op_info all_v_scalar_ptr_ops\n      rvv_arg_type_info (RVV_BASE_void), /* Return type */\n      scalar_ptr_args /* Args */};\n \n+/* A static operand information for vector_type func (const scalar_type *)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info b_v_scalar_const_ptr_ops\n+  = {b_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_v,\t\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     scalar_const_ptr_args /* Args */};\n+\n+/* A static operand information for void func (scalar_type *, vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info b_v_scalar_ptr_ops\n+  = {b_ops,\t\t\t\t/* Types */\n+     OP_TYPE_v,\t\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_void), /* Return type */\n+     scalar_ptr_args /* Args */};\n+\n+/* A static operand information for vector_type func (const scalar_type *,\n+ * ptrdiff_t) function registration. */\n+static CONSTEXPR const rvv_op_info all_v_scalar_const_ptr_ptrdiff_ops\n+  = {all_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_v,\t\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     scalar_const_ptr_ptrdiff_args /* Args */};\n+\n+/* A static operand information for vector_type func (const scalar_type *,\n+ * uint8_index_type) function registration. */\n+static CONSTEXPR const rvv_op_info all_v_scalar_const_ptr_uint8_index_ops\n+  = {all_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_v,\t\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     scalar_const_ptr_uint8_index_args /* Args */};\n+\n+/* A static operand information for vector_type func (const scalar_type *,\n+ * uint16_index_type) function registration. */\n+static CONSTEXPR const rvv_op_info all_v_scalar_const_ptr_uint16_index_ops\n+  = {all_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_v,\t\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     scalar_const_ptr_uint16_index_args /* Args */};\n+\n+/* A static operand information for vector_type func (const scalar_type *,\n+ * uint32_index_type) function registration. */\n+static CONSTEXPR const rvv_op_info all_v_scalar_const_ptr_uint32_index_ops\n+  = {all_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_v,\t\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     scalar_const_ptr_uint32_index_args /* Args */};\n+\n+/* A static operand information for vector_type func (const scalar_type *,\n+ * uint64_index_type) function registration. */\n+static CONSTEXPR const rvv_op_info all_v_scalar_const_ptr_uint64_index_ops\n+  = {all_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_v,\t\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     scalar_const_ptr_uint64_index_args /* Args */};\n+\n+/* A static operand information for void func (scalar_type *, ptrdiff_t,\n+ * vector_type) function registration. */\n+static CONSTEXPR const rvv_op_info all_v_scalar_ptr_ptrdiff_ops\n+  = {all_ops,\t\t\t\t/* Types */\n+     OP_TYPE_v,\t\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_void), /* Return type */\n+     scalar_ptr_ptrdiff_args /* Args */};\n+\n+/* A static operand information for void func (scalar_type *, uint8_index_type,\n+ * vector_type) function registration. */\n+static CONSTEXPR const rvv_op_info all_v_scalar_ptr_uint8_index_ops\n+  = {all_ops,\t\t\t\t/* Types */\n+     OP_TYPE_v,\t\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_void), /* Return type */\n+     scalar_ptr_uint8_index_args /* Args */};\n+\n+/* A static operand information for void func (scalar_type *, uint16_index_type,\n+ * vector_type) function registration. */\n+static CONSTEXPR const rvv_op_info all_v_scalar_ptr_uint16_index_ops\n+  = {all_ops,\t\t\t\t/* Types */\n+     OP_TYPE_v,\t\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_void), /* Return type */\n+     scalar_ptr_uint16_index_args /* Args */};\n+\n+/* A static operand information for void func (scalar_type *, uint32_index_type,\n+ * vector_type) function registration. */\n+static CONSTEXPR const rvv_op_info all_v_scalar_ptr_uint32_index_ops\n+  = {all_ops,\t\t\t\t/* Types */\n+     OP_TYPE_v,\t\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_void), /* Return type */\n+     scalar_ptr_uint32_index_args /* Args */};\n+\n+/* A static operand information for void func (scalar_type *, uint64_index_type,\n+ * vector_type) function registration. */\n+static CONSTEXPR const rvv_op_info all_v_scalar_ptr_uint64_index_ops\n+  = {all_ops,\t\t\t\t/* Types */\n+     OP_TYPE_v,\t\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_void), /* Return type */\n+     scalar_ptr_uint64_index_args /* Args */};\n+\n /* A list of all RVV intrinsic functions.  */\n static function_group_info function_groups[] = {\n #define DEF_RVV_FUNCTION(NAME, SHAPE, PREDS, OPS_INFO)                         \\\n@@ -346,14 +513,15 @@ register_builtin_type (vector_type_index type, tree eltype, machine_mode mode)\n static void\n register_builtin_types ()\n {\n-  /* int32_t/uint32_t defined as `long`/`unsigned long` in RV32,\n-     but intSI_type_node/unsigned_intSI_type_node is\n-     `int` and `unsigned int`, so use long_integer_type_node and\n-     long_unsigned_type_node here for type consistent.  */\n-  tree int32_type_node\n-    = TARGET_64BIT ? intSI_type_node : long_integer_type_node;\n-  tree unsigned_int32_type_node\n-    = TARGET_64BIT ? unsigned_intSI_type_node : long_unsigned_type_node;\n+  /* Get type node from get_typenode_from_name to prevent we have different type\n+     node define in different target libraries, e.g. int32_t defined as\n+     `long` in RV32/newlib-stdint, but `int` for RV32/glibc-stdint.h.\n+     NOTE: uint[16|32|64]_type_node already defined in tree.h.  */\n+  tree int8_type_node = get_typenode_from_name (INT8_TYPE);\n+  tree uint8_type_node = get_typenode_from_name (UINT8_TYPE);\n+  tree int16_type_node = get_typenode_from_name (INT16_TYPE);\n+  tree int32_type_node = get_typenode_from_name (INT32_TYPE);\n+  tree int64_type_node = get_typenode_from_name (INT64_TYPE);\n \n   machine_mode mode;\n #define DEF_RVV_TYPE(NAME, NCHARS, ABI_NAME, SCALAR_TYPE, VECTOR_MODE,         \\\n@@ -392,11 +560,41 @@ register_vector_type (vector_type_index type)\n   builtin_types[type].vector_ptr = build_pointer_type (vectype);\n }\n \n+/* Return true if the type has required_extensions.  */\n+static bool\n+required_extensions_p (enum rvv_base_type type)\n+{\n+  return type == RVV_BASE_vector || type == RVV_BASE_uint8_index\n+\t || type == RVV_BASE_uint16_index || type == RVV_BASE_uint32_index\n+\t || type == RVV_BASE_uint64_index;\n+}\n+\n /* Check whether all the RVV_REQUIRE_* values in REQUIRED_EXTENSIONS are\n    enabled.  */\n static bool\n-check_required_extensions (uint64_t required_extensions)\n+check_required_extensions (const function_instance &instance)\n {\n+  rvv_type_info type_info = instance.type;\n+  uint64_t required_extensions = type_info.required_extensions;\n+  const rvv_op_info *op_info = instance.op_info;\n+  tree type = builtin_types[type_info.index].vector;\n+  for (unsigned i = 0; op_info->args[i].base_type != NUM_BASE_TYPES; ++i)\n+    {\n+      if (!required_extensions_p (op_info->args[i].base_type))\n+\tcontinue;\n+\n+      enum vector_type_index vector_type\n+\t= op_info->args[i].get_base_vector_type (type);\n+      if (vector_type == NUM_VECTOR_TYPES)\n+\tcontinue;\n+      required_extensions |= op_info->types[vector_type].required_extensions;\n+\n+      /* According to RVV ISA, EEW=64 index of indexed loads/stores require\n+\t XLEN = 64.  */\n+      if (op_info->args[i].base_type == RVV_BASE_uint64_index)\n+\trequired_extensions |= RVV_REQUIRE_RV64BIT;\n+    }\n+\n   uint64_t riscv_isa_flags = 0;\n \n   if (TARGET_VECTOR_ELEN_FP_32)\n@@ -450,6 +648,56 @@ get_mask_policy_for_pred (enum predication_type_index pred)\n   return gen_int_mode (get_prefer_mask_policy (), Pmode);\n }\n \n+vector_type_index\n+rvv_arg_type_info::get_base_vector_type (tree type) const\n+{\n+  if (!type)\n+    return NUM_VECTOR_TYPES;\n+  poly_int64 nunits = GET_MODE_NUNITS (TYPE_MODE (type));\n+  machine_mode inner_mode;\n+  bool unsigned_p = TYPE_UNSIGNED (type);\n+  switch (base_type)\n+    {\n+    case RVV_BASE_uint8_index:\n+      inner_mode = E_QImode;\n+      unsigned_p = true;\n+      break;\n+    case RVV_BASE_uint16_index:\n+      inner_mode = E_HImode;\n+      unsigned_p = true;\n+      break;\n+    case RVV_BASE_uint32_index:\n+      inner_mode = E_SImode;\n+      unsigned_p = true;\n+      break;\n+    case RVV_BASE_uint64_index:\n+      inner_mode = E_DImode;\n+      unsigned_p = true;\n+      break;\n+    default:\n+      return NUM_VECTOR_TYPES;\n+    }\n+\n+  opt_machine_mode mode\n+    = get_vector_mode (as_a<scalar_mode> (inner_mode), nunits);\n+\n+  if (!mode.exists ())\n+    return NUM_VECTOR_TYPES;\n+  for (unsigned int i = 0; i < NUM_VECTOR_TYPES + 1; i++)\n+    {\n+      tree vector_type = builtin_types[i].vector;\n+      if (!vector_type)\n+\tcontinue;\n+\n+      if (TYPE_UNSIGNED (vector_type) != unsigned_p)\n+\tcontinue;\n+\n+      if (TYPE_MODE (vector_type) == mode.require ())\n+\treturn (enum vector_type_index) i;\n+    }\n+  return NUM_VECTOR_TYPES;\n+}\n+\n tree\n rvv_arg_type_info::get_tree_type (vector_type_index type_idx) const\n {\n@@ -462,9 +710,19 @@ rvv_arg_type_info::get_tree_type (vector_type_index type_idx) const\n     case RVV_BASE_vector_ptr:\n       return builtin_types[type_idx].vector_ptr;\n     case RVV_BASE_scalar_ptr:\n-      return builtin_types[type_idx].scalar_ptr;\n+      /* According to the latest rvv-intrinsic-doc, it defines vsm.v intrinsic:\n+\t __riscv_vsm (uint8_t *base, vbool1_t value, size_t vl).  */\n+      if (type_idx >= VECTOR_TYPE_vbool64_t && type_idx <= VECTOR_TYPE_vbool1_t)\n+\treturn builtin_types[VECTOR_TYPE_vuint8mf8_t].scalar_ptr;\n+      else\n+\treturn builtin_types[type_idx].scalar_ptr;\n     case RVV_BASE_scalar_const_ptr:\n-      return builtin_types[type_idx].scalar_const_ptr;\n+      /* According to the latest rvv-intrinsic-doc, it defines vlm.v intrinsic:\n+\t __riscv_vlm_v_b1 (const uint8_t *base, size_t vl).  */\n+      if (type_idx >= VECTOR_TYPE_vbool64_t && type_idx <= VECTOR_TYPE_vbool1_t)\n+\treturn builtin_types[VECTOR_TYPE_vuint8mf8_t].scalar_const_ptr;\n+      else\n+\treturn builtin_types[type_idx].scalar_const_ptr;\n     case RVV_BASE_void:\n       return void_type_node;\n     case RVV_BASE_size:\n@@ -475,9 +733,20 @@ rvv_arg_type_info::get_tree_type (vector_type_index type_idx) const\n       return long_unsigned_type_node;\n     case RVV_BASE_long:\n       return long_integer_type_node;\n+    case RVV_BASE_uint8_index:\n+    case RVV_BASE_uint16_index:\n+    case RVV_BASE_uint32_index:\n+    case RVV_BASE_uint64_index:\n+      if (get_base_vector_type (builtin_types[type_idx].vector)\n+\t  != NUM_VECTOR_TYPES)\n+\treturn builtin_types[get_base_vector_type (\n+\t\t\t       builtin_types[type_idx].vector)].vector;\n+      break;\n     default:\n       gcc_unreachable ();\n     }\n+  /* Return NULL_TREE if the type we don't want to register.  */\n+  return NULL_TREE;\n }\n \n function_instance::function_instance (const char *base_name_in,\n@@ -777,7 +1046,7 @@ function_builder::add_unique_function (const function_instance &instance,\n \t\t\t\t       vec<tree> &argument_types)\n {\n   /* Do not add this function if it is invalid.  */\n-  if (!check_required_extensions (instance.type.required_extensions))\n+  if (!check_required_extensions (instance))\n     return;\n \n   /* Add the function under its full (unique) name.  */\n@@ -845,15 +1114,53 @@ function_expander::add_vundef_operand (machine_mode mode)\n }\n \n /* Add a memory operand with mode MODE and address ADDR.  */\n-rtx\n-function_expander::add_mem_operand (machine_mode mode, rtx addr)\n+void\n+function_expander::add_mem_operand (machine_mode mode, unsigned argno)\n {\n   gcc_assert (VECTOR_MODE_P (mode));\n+  rtx addr = expand_normal (CALL_EXPR_ARG (exp, argno));\n   rtx mem = gen_rtx_MEM (mode, memory_address (mode, addr));\n   /* The memory is only guaranteed to be element-aligned.  */\n   set_mem_align (mem, GET_MODE_ALIGNMENT (GET_MODE_INNER (mode)));\n   add_fixed_operand (mem);\n-  return mem;\n+}\n+\n+/* Implement the call using instruction ICODE, with a 1:1 mapping between\n+   arguments and input operands.  */\n+rtx\n+function_expander::use_exact_insn (insn_code icode)\n+{\n+  machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n+  tree mask_type = builtin_types[mask_types[type.index]].vector;\n+  machine_mode mask_mode = TYPE_MODE (mask_type);\n+\n+  /* Record the offset to get the argument.  */\n+  int arg_offset = 0;\n+\n+  if (use_real_mask_p (pred))\n+    add_input_operand (arg_offset++);\n+  else\n+    add_all_one_mask_operand (mask_mode);\n+\n+  /* Store operation doesn't have merge operand.  */\n+  if (!function_returns_void_p ())\n+    {\n+      if (use_real_merge_p (pred))\n+\tadd_input_operand (arg_offset++);\n+      else\n+\tadd_vundef_operand (mode);\n+    }\n+\n+  for (int argno = arg_offset; argno < call_expr_nargs (exp); argno++)\n+    add_input_operand (argno);\n+\n+  if (base->apply_tail_policy_p ())\n+    add_input_operand (Pmode, get_tail_policy_for_pred (pred));\n+  if (base->apply_mask_policy_p ())\n+    add_input_operand (Pmode, get_mask_policy_for_pred (pred));\n+\n+  add_input_operand (Pmode, get_avl_type_rtx (avl_type::NONVLMAX));\n+  return generate_insn (icode);\n }\n \n /* Use contiguous load INSN.  */\n@@ -878,16 +1185,19 @@ function_expander::use_contiguous_load_insn (insn_code icode)\n   else\n     add_vundef_operand (mode);\n \n-  tree addr_arg = CALL_EXPR_ARG (exp, arg_offset++);\n-  rtx addr = expand_normal (addr_arg);\n-  add_mem_operand (mode, addr);\n+  add_mem_operand (mode, arg_offset++);\n \n   for (int argno = arg_offset; argno < call_expr_nargs (exp); argno++)\n     add_input_operand (argno);\n \n-  add_input_operand (Pmode, get_tail_policy_for_pred (pred));\n-  add_input_operand (Pmode, get_mask_policy_for_pred (pred));\n-  add_input_operand (Pmode, get_avl_type_rtx (avl_type::NONVLMAX));\n+  if (GET_MODE_CLASS (mode) != MODE_VECTOR_BOOL)\n+    {\n+      add_input_operand (Pmode, get_tail_policy_for_pred (pred));\n+      add_input_operand (Pmode, get_mask_policy_for_pred (pred));\n+    }\n+\n+  if (opno != insn_data[icode].n_generator_args)\n+    add_input_operand (Pmode, get_avl_type_rtx (avl_type::NONVLMAX));\n \n   return generate_insn (icode);\n }\n@@ -904,27 +1214,17 @@ function_expander::use_contiguous_store_insn (insn_code icode)\n   /* Record the offset to get the argument.  */\n   int arg_offset = 0;\n \n-  int addr_loc = use_real_mask_p (pred) ? 1 : 0;\n-  tree addr_arg = CALL_EXPR_ARG (exp, addr_loc);\n-  rtx addr = expand_normal (addr_arg);\n-  rtx mem = add_mem_operand (mode, addr);\n+  add_mem_operand (mode, use_real_mask_p (pred) ? 1 : 0);\n \n   if (use_real_mask_p (pred))\n     add_input_operand (arg_offset++);\n   else\n     add_all_one_mask_operand (mask_mode);\n \n-  /* To model \"+m\" constraint, we include memory operand into input.  */\n-  add_input_operand (mode, mem);\n-\n   arg_offset++;\n   for (int argno = arg_offset; argno < call_expr_nargs (exp); argno++)\n     add_input_operand (argno);\n \n-  add_input_operand (Pmode, get_tail_policy_for_pred (pred));\n-  add_input_operand (Pmode, get_mask_policy_for_pred (pred));\n-  add_input_operand (Pmode, get_avl_type_rtx (avl_type::NONVLMAX));\n-\n   return generate_insn (icode);\n }\n "}, {"sha": "89bd5f13995f1fa1085f40c5a48330eb6c20d964", "filename": "gcc/config/riscv/riscv-vector-builtins.def", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -89,147 +89,147 @@ DEF_RVV_TYPE (vbool1_t, 13, __rvv_bool1_t, boolean, VNx64BI, VNx32BI, _b1, , , v\n \n /* LMUL = 1/8:\n    Only enble when TARGET_MIN_VLEN > 32 and machine mode = VNx1QImode.  */\n-DEF_RVV_TYPE (vint8mf8_t, 15, __rvv_int8mf8_t, intQI, VNx1QI, VOID, _i8mf8, _i8,\n+DEF_RVV_TYPE (vint8mf8_t, 15, __rvv_int8mf8_t, int8, VNx1QI, VOID, _i8mf8, _i8,\n \t      _e8mf8, vbool64_t)\n-DEF_RVV_TYPE (vuint8mf8_t, 16, __rvv_uint8mf8_t, unsigned_intQI, VNx1QI, VOID,\n+DEF_RVV_TYPE (vuint8mf8_t, 16, __rvv_uint8mf8_t, uint8, VNx1QI, VOID,\n \t      _u8mf8, _u8, _e8mf8, vbool64_t)\n /* LMUL = 1/4:\n    Machine mode = VNx2QImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx1QImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vint8mf4_t, 15, __rvv_int8mf4_t, intQI, VNx2QI, VNx1QI, _i8mf4,\n+DEF_RVV_TYPE (vint8mf4_t, 15, __rvv_int8mf4_t, int8, VNx2QI, VNx1QI, _i8mf4,\n \t      _i8, _e8mf4, vbool32_t)\n-DEF_RVV_TYPE (vuint8mf4_t, 16, __rvv_uint8mf4_t, unsigned_intQI, VNx2QI, VNx1QI,\n+DEF_RVV_TYPE (vuint8mf4_t, 16, __rvv_uint8mf4_t, uint8, VNx2QI, VNx1QI,\n \t      _u8mf4, _u8, _e8mf4, vbool32_t)\n /* LMUL = 1/2:\n    Machine mode = VNx4QImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx2QImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vint8mf2_t, 15, __rvv_int8mf2_t, intQI, VNx4QI, VNx2QI, _i8mf2,\n+DEF_RVV_TYPE (vint8mf2_t, 15, __rvv_int8mf2_t, int8, VNx4QI, VNx2QI, _i8mf2,\n \t      _i8, _e8mf2, vbool16_t)\n-DEF_RVV_TYPE (vuint8mf2_t, 16, __rvv_uint8mf2_t, unsigned_intQI, VNx4QI, VNx2QI,\n+DEF_RVV_TYPE (vuint8mf2_t, 16, __rvv_uint8mf2_t, uint8, VNx4QI, VNx2QI,\n \t      _u8mf2, _u8, _e8mf2, vbool16_t)\n /* LMUL = 1:\n    Machine mode = VNx8QImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx4QImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vint8m1_t, 14, __rvv_int8m1_t, intQI, VNx8QI, VNx4QI, _i8m1, _i8,\n+DEF_RVV_TYPE (vint8m1_t, 14, __rvv_int8m1_t, int8, VNx8QI, VNx4QI, _i8m1, _i8,\n \t      _e8m1, vbool8_t)\n-DEF_RVV_TYPE (vuint8m1_t, 15, __rvv_uint8m1_t, unsigned_intQI, VNx8QI, VNx4QI,\n+DEF_RVV_TYPE (vuint8m1_t, 15, __rvv_uint8m1_t, uint8, VNx8QI, VNx4QI,\n \t      _u8m1, _u8, _e8m1, vbool8_t)\n /* LMUL = 2:\n    Machine mode = VNx16QImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx8QImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vint8m2_t, 14, __rvv_int8m2_t, intQI, VNx16QI, VNx8QI, _i8m2, _i8,\n+DEF_RVV_TYPE (vint8m2_t, 14, __rvv_int8m2_t, int8, VNx16QI, VNx8QI, _i8m2, _i8,\n \t      _e8m2, vbool4_t)\n-DEF_RVV_TYPE (vuint8m2_t, 15, __rvv_uint8m2_t, unsigned_intQI, VNx16QI, VNx8QI,\n+DEF_RVV_TYPE (vuint8m2_t, 15, __rvv_uint8m2_t, uint8, VNx16QI, VNx8QI,\n \t      _u8m2, _u8, _e8m2, vbool4_t)\n /* LMUL = 4:\n    Machine mode = VNx32QImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx16QImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vint8m4_t, 14, __rvv_int8m4_t, intQI, VNx32QI, VNx16QI, _i8m4,\n+DEF_RVV_TYPE (vint8m4_t, 14, __rvv_int8m4_t, int8, VNx32QI, VNx16QI, _i8m4,\n \t      _i8, _e8m4, vbool2_t)\n-DEF_RVV_TYPE (vuint8m4_t, 15, __rvv_uint8m4_t, unsigned_intQI, VNx32QI, VNx16QI,\n+DEF_RVV_TYPE (vuint8m4_t, 15, __rvv_uint8m4_t, uint8, VNx32QI, VNx16QI,\n \t      _u8m4, _u8, _e8m4, vbool2_t)\n /* LMUL = 8:\n    Machine mode = VNx64QImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx32QImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vint8m8_t, 14, __rvv_int8m8_t, intQI, VNx64QI, VNx32QI, _i8m8,\n+DEF_RVV_TYPE (vint8m8_t, 14, __rvv_int8m8_t, int8, VNx64QI, VNx32QI, _i8m8,\n \t      _i8, _e8m8, vbool1_t)\n-DEF_RVV_TYPE (vuint8m8_t, 15, __rvv_uint8m8_t, unsigned_intQI, VNx64QI, VNx32QI,\n+DEF_RVV_TYPE (vuint8m8_t, 15, __rvv_uint8m8_t, uint8, VNx64QI, VNx32QI,\n \t      _u8m8, _u8, _e8m8, vbool1_t)\n \n /* LMUL = 1/4:\n    Only enble when TARGET_MIN_VLEN > 32 and machine mode = VNx1HImode.  */\n-DEF_RVV_TYPE (vint16mf4_t, 16, __rvv_int16mf4_t, intHI, VNx1HI, VOID, _i16mf4,\n+DEF_RVV_TYPE (vint16mf4_t, 16, __rvv_int16mf4_t, int16, VNx1HI, VOID, _i16mf4,\n \t      _i16, _e16mf4, vbool64_t)\n-DEF_RVV_TYPE (vuint16mf4_t, 17, __rvv_uint16mf4_t, unsigned_intHI, VNx1HI, VOID,\n+DEF_RVV_TYPE (vuint16mf4_t, 17, __rvv_uint16mf4_t, uint16, VNx1HI, VOID,\n \t      _u16mf4, _u16, _e16mf4, vbool64_t)\n /* LMUL = 1/2:\n    Machine mode = VNx2HImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx1HImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vint16mf2_t, 16, __rvv_int16mf2_t, intHI, VNx2HI, VNx1HI, _i16mf2,\n+DEF_RVV_TYPE (vint16mf2_t, 16, __rvv_int16mf2_t, int16, VNx2HI, VNx1HI, _i16mf2,\n \t      _i16, _e16mf2, vbool32_t)\n-DEF_RVV_TYPE (vuint16mf2_t, 17, __rvv_uint16mf2_t, unsigned_intHI, VNx2HI,\n+DEF_RVV_TYPE (vuint16mf2_t, 17, __rvv_uint16mf2_t, uint16, VNx2HI,\n \t      VNx1HI, _u16mf2, _u16, _e16mf2, vbool32_t)\n /* LMUL = 1:\n    Machine mode = VNx4HImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx2HImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vint16m1_t, 15, __rvv_int16m1_t, intHI, VNx4HI, VNx2HI, _i16m1,\n+DEF_RVV_TYPE (vint16m1_t, 15, __rvv_int16m1_t, int16, VNx4HI, VNx2HI, _i16m1,\n \t      _i16, _e16m1, vbool16_t)\n-DEF_RVV_TYPE (vuint16m1_t, 16, __rvv_uint16m1_t, unsigned_intHI, VNx4HI, VNx2HI,\n+DEF_RVV_TYPE (vuint16m1_t, 16, __rvv_uint16m1_t, uint16, VNx4HI, VNx2HI,\n \t      _u16m1, _u16, _e16m1, vbool16_t)\n /* LMUL = 2:\n    Machine mode = VNx8HImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx4HImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vint16m2_t, 15, __rvv_int16m2_t, intHI, VNx8HI, VNx4HI, _i16m2,\n+DEF_RVV_TYPE (vint16m2_t, 15, __rvv_int16m2_t, int16, VNx8HI, VNx4HI, _i16m2,\n \t      _i16, _e16m2, vbool8_t)\n-DEF_RVV_TYPE (vuint16m2_t, 16, __rvv_uint16m2_t, unsigned_intHI, VNx8HI, VNx4HI,\n+DEF_RVV_TYPE (vuint16m2_t, 16, __rvv_uint16m2_t, uint16, VNx8HI, VNx4HI,\n \t      _u16m2, _u16, _e16m2, vbool8_t)\n /* LMUL = 4:\n    Machine mode = VNx16HImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx8HImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vint16m4_t, 15, __rvv_int16m4_t, intHI, VNx16HI, VNx8HI, _i16m4,\n+DEF_RVV_TYPE (vint16m4_t, 15, __rvv_int16m4_t, int16, VNx16HI, VNx8HI, _i16m4,\n \t      _i16, _e16m4, vbool4_t)\n-DEF_RVV_TYPE (vuint16m4_t, 16, __rvv_uint16m4_t, unsigned_intHI, VNx16HI,\n+DEF_RVV_TYPE (vuint16m4_t, 16, __rvv_uint16m4_t, uint16, VNx16HI,\n \t      VNx8HI, _u16m4, _u16, _e16m4, vbool4_t)\n /* LMUL = 8:\n    Machine mode = VNx32HImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx16HImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vint16m8_t, 15, __rvv_int16m8_t, intHI, VNx32HI, VNx16HI, _i16m8,\n+DEF_RVV_TYPE (vint16m8_t, 15, __rvv_int16m8_t, int16, VNx32HI, VNx16HI, _i16m8,\n \t      _i16, _e16m8, vbool2_t)\n-DEF_RVV_TYPE (vuint16m8_t, 16, __rvv_uint16m8_t, unsigned_intHI, VNx32HI,\n+DEF_RVV_TYPE (vuint16m8_t, 16, __rvv_uint16m8_t, uint16, VNx32HI,\n \t      VNx16HI, _u16m8, _u16, _e16m8, vbool2_t)\n \n /* LMUL = 1/2:\n    Only enble when TARGET_MIN_VLEN > 32 and machine mode = VNx1SImode.  */\n DEF_RVV_TYPE (vint32mf2_t, 16, __rvv_int32mf2_t, int32, VNx1SI, VOID, _i32mf2,\n \t      _i32, _e32mf2, vbool64_t)\n-DEF_RVV_TYPE (vuint32mf2_t, 17, __rvv_uint32mf2_t, unsigned_int32, VNx1SI, VOID,\n+DEF_RVV_TYPE (vuint32mf2_t, 17, __rvv_uint32mf2_t, uint32, VNx1SI, VOID,\n \t      _u32mf2, _u32, _e32mf2, vbool64_t)\n /* LMUL = 1:\n    Machine mode = VNx2SImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx1SImode when TARGET_MIN_VLEN = 32.  */\n DEF_RVV_TYPE (vint32m1_t, 15, __rvv_int32m1_t, int32, VNx2SI, VNx1SI, _i32m1,\n \t      _i32, _e32m1, vbool32_t)\n-DEF_RVV_TYPE (vuint32m1_t, 16, __rvv_uint32m1_t, unsigned_int32, VNx2SI, VNx1SI,\n+DEF_RVV_TYPE (vuint32m1_t, 16, __rvv_uint32m1_t, uint32, VNx2SI, VNx1SI,\n \t      _u32m1, _u32, _e32m1, vbool32_t)\n /* LMUL = 2:\n    Machine mode = VNx4SImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx2SImode when TARGET_MIN_VLEN = 32.  */\n DEF_RVV_TYPE (vint32m2_t, 15, __rvv_int32m2_t, int32, VNx4SI, VNx2SI, _i32m2,\n \t      _i32, _e32m2, vbool16_t)\n-DEF_RVV_TYPE (vuint32m2_t, 16, __rvv_uint32m2_t, unsigned_int32, VNx4SI, VNx2SI,\n+DEF_RVV_TYPE (vuint32m2_t, 16, __rvv_uint32m2_t, uint32, VNx4SI, VNx2SI,\n \t      _u32m2, _u32, _e32m2, vbool16_t)\n /* LMUL = 4:\n    Machine mode = VNx8SImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx4SImode when TARGET_MIN_VLEN = 32.  */\n DEF_RVV_TYPE (vint32m4_t, 15, __rvv_int32m4_t, int32, VNx8SI, VNx4SI, _i32m4,\n \t      _i32, _e32m4, vbool8_t)\n-DEF_RVV_TYPE (vuint32m4_t, 16, __rvv_uint32m4_t, unsigned_int32, VNx8SI, VNx4SI,\n+DEF_RVV_TYPE (vuint32m4_t, 16, __rvv_uint32m4_t, uint32, VNx8SI, VNx4SI,\n \t      _u32m4, _u32, _e32m4, vbool8_t)\n /* LMUL = 8:\n    Machine mode = VNx16SImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx8SImode when TARGET_MIN_VLEN = 32.  */\n DEF_RVV_TYPE (vint32m8_t, 15, __rvv_int32m8_t, int32, VNx16SI, VNx8SI, _i32m8,\n \t      _i32, _e32m8, vbool4_t)\n-DEF_RVV_TYPE (vuint32m8_t, 16, __rvv_uint32m8_t, unsigned_int32, VNx16SI,\n+DEF_RVV_TYPE (vuint32m8_t, 16, __rvv_uint32m8_t, uint32, VNx16SI,\n \t      VNx8SI, _u32m8, _u32, _e32m8, vbool4_t)\n \n /* SEW = 64:\n    Disable when TARGET_MIN_VLEN > 32.  */\n-DEF_RVV_TYPE (vint64m1_t, 15, __rvv_int64m1_t, intDI, VNx1DI, VOID, _i64m1,\n+DEF_RVV_TYPE (vint64m1_t, 15, __rvv_int64m1_t, int64, VNx1DI, VOID, _i64m1,\n \t      _i64, _e64m1, vbool64_t)\n-DEF_RVV_TYPE (vuint64m1_t, 16, __rvv_uint64m1_t, unsigned_intDI, VNx1DI, VOID,\n+DEF_RVV_TYPE (vuint64m1_t, 16, __rvv_uint64m1_t, uint64, VNx1DI, VOID,\n \t      _u64m1, _u64, _e64m1, vbool64_t)\n-DEF_RVV_TYPE (vint64m2_t, 15, __rvv_int64m2_t, intDI, VNx2DI, VOID, _i64m2,\n+DEF_RVV_TYPE (vint64m2_t, 15, __rvv_int64m2_t, int64, VNx2DI, VOID, _i64m2,\n \t      _i64, _e64m2, vbool32_t)\n-DEF_RVV_TYPE (vuint64m2_t, 16, __rvv_uint64m2_t, unsigned_intDI, VNx2DI, VOID,\n+DEF_RVV_TYPE (vuint64m2_t, 16, __rvv_uint64m2_t, uint64, VNx2DI, VOID,\n \t      _u64m2, _u64, _e64m2, vbool32_t)\n-DEF_RVV_TYPE (vint64m4_t, 15, __rvv_int64m4_t, intDI, VNx4DI, VOID, _i64m4,\n+DEF_RVV_TYPE (vint64m4_t, 15, __rvv_int64m4_t, int64, VNx4DI, VOID, _i64m4,\n \t      _i64, _e64m4, vbool16_t)\n-DEF_RVV_TYPE (vuint64m4_t, 16, __rvv_uint64m4_t, unsigned_intDI, VNx4DI, VOID,\n+DEF_RVV_TYPE (vuint64m4_t, 16, __rvv_uint64m4_t, uint64, VNx4DI, VOID,\n \t      _u64m4, _u64, _e64m4, vbool16_t)\n-DEF_RVV_TYPE (vint64m8_t, 15, __rvv_int64m8_t, intDI, VNx8DI, VOID, _i64m8,\n+DEF_RVV_TYPE (vint64m8_t, 15, __rvv_int64m8_t, int64, VNx8DI, VOID, _i64m8,\n \t      _i64, _e64m8, vbool8_t)\n-DEF_RVV_TYPE (vuint64m8_t, 16, __rvv_uint64m8_t, unsigned_intDI, VNx8DI, VOID,\n+DEF_RVV_TYPE (vuint64m8_t, 16, __rvv_uint64m8_t, uint64, VNx8DI, VOID,\n \t      _u64m8, _u64, _e64m8, vbool8_t)\n \n /* LMUL = 1/2:"}, {"sha": "aec66b8ca4b8a97d55adccdea1d858ff3302d8f7", "filename": "gcc/config/riscv/riscv-vector-builtins.h", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -147,6 +147,10 @@ enum rvv_base_type\n   RVV_BASE_ptrdiff,\n   RVV_BASE_unsigned_long,\n   RVV_BASE_long,\n+  RVV_BASE_uint8_index,\n+  RVV_BASE_uint16_index,\n+  RVV_BASE_uint32_index,\n+  RVV_BASE_uint64_index,\n   NUM_BASE_TYPES\n };\n \n@@ -176,6 +180,7 @@ struct rvv_arg_type_info\n   {}\n   enum rvv_base_type base_type;\n \n+  vector_type_index get_base_vector_type (tree type) const;\n   tree get_tree_type (vector_type_index) const;\n };\n \n@@ -317,15 +322,17 @@ class function_expander : public function_call_info\n   rtx expand ();\n \n   void add_input_operand (machine_mode, rtx);\n-  void add_input_operand (unsigned argno);\n+  void add_input_operand (unsigned);\n   void add_output_operand (machine_mode, rtx);\n-  void add_all_one_mask_operand (machine_mode mode);\n-  void add_vundef_operand (machine_mode mode);\n+  void add_all_one_mask_operand (machine_mode);\n+  void add_vundef_operand (machine_mode);\n   void add_fixed_operand (rtx);\n-  rtx add_mem_operand (machine_mode, rtx);\n+  void add_mem_operand (machine_mode, unsigned);\n \n   machine_mode vector_mode (void) const;\n+  machine_mode index_mode (void) const;\n \n+  rtx use_exact_insn (insn_code);\n   rtx use_contiguous_load_insn (insn_code);\n   rtx use_contiguous_store_insn (insn_code);\n   rtx generate_insn (insn_code);\n@@ -358,6 +365,12 @@ class function_base\n   /* Return true if intrinsics should apply vl operand.  */\n   virtual bool apply_vl_p () const;\n \n+  /* Return true if intrinsics should apply tail policy operand.  */\n+  virtual bool apply_tail_policy_p () const;\n+\n+  /* Return true if intrinsics should apply mask policy operand.  */\n+  virtual bool apply_mask_policy_p () const;\n+\n   /* Return true if intrinsic can be overloaded.  */\n   virtual bool can_be_overloaded_p (enum predication_type_index) const;\n \n@@ -444,6 +457,13 @@ function_expander::vector_mode (void) const\n   return TYPE_MODE (builtin_types[type.index].vector);\n }\n \n+/* Return the machine_mode of the corresponding index type.  */\n+inline machine_mode\n+function_expander::index_mode (void) const\n+{\n+  return TYPE_MODE (op_info->args[1].get_tree_type (type.index));\n+}\n+\n /* Default implementation of function_base::call_properties, with conservatively\n    correct behavior for floating-point instructions.  */\n inline unsigned int\n@@ -463,6 +483,22 @@ function_base::apply_vl_p () const\n   return true;\n }\n \n+/* We choose to apply tail policy operand by default since most of the\n+   intrinsics has tail policy operand.  */\n+inline bool\n+function_base::apply_tail_policy_p () const\n+{\n+  return true;\n+}\n+\n+/* We choose to apply mask policy operand by default since most of the\n+   intrinsics has mask policy operand.  */\n+inline bool\n+function_base::apply_mask_policy_p () const\n+{\n+  return true;\n+}\n+\n /* Since most of intrinsics can be overloaded, we set it true by default.  */\n inline bool\n function_base::can_be_overloaded_p (enum predication_type_index) const"}, {"sha": "ef5b74c58d241f8c5731c1e82def9e6fc89008d4", "filename": "gcc/config/riscv/riscv-vsetvl.cc", "status": "modified", "additions": 1498, "deletions": 387, "changes": 1885, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -43,7 +43,8 @@ along with GCC; see the file COPYING3.  If not see\n     -  Phase 2 - Emit vsetvl instructions within each basic block according to\n        demand, compute and save ANTLOC && AVLOC of each block.\n \n-    -  Phase 3 - Backward demanded info propagation and fusion across blocks.\n+    -  Phase 3 - Backward && forward demanded info propagation and fusion across\n+       blocks.\n \n     -  Phase 4 - Lazy code motion including: compute local properties,\n        pre_edge_lcm and vsetvl insertion && delete edges for LCM results.\n@@ -52,6 +53,8 @@ along with GCC; see the file COPYING3.  If not see\n        used any more and VL operand of VSETVL instruction if it is not used by\n        any non-debug instructions.\n \n+    -  Phase 6 - Propagate AVL between vsetvl instructions.\n+\n     Implementation:\n \n     -  The subroutine of optimize == 0 is simple_vsetvl.\n@@ -116,10 +119,27 @@ vlmax_avl_insn_p (rtx_insn *rinsn)\n \t  || INSN_CODE (rinsn) == CODE_FOR_vlmax_avldi);\n }\n \n+/* Return true if the block is a loop itself:\n+\t  local_dem\n+\t     __________\n+\t ____|____     |\n+\t|        |     |\n+\t|________|     |\n+\t     |_________|\n+\t  reaching_out\n+*/\n static bool\n loop_basic_block_p (const basic_block cfg_bb)\n {\n-  return JUMP_P (BB_END (cfg_bb)) && any_condjump_p (BB_END (cfg_bb));\n+  if (JUMP_P (BB_END (cfg_bb)) && any_condjump_p (BB_END (cfg_bb)))\n+    {\n+      edge e;\n+      edge_iterator ei;\n+      FOR_EACH_EDGE (e, ei, cfg_bb->succs)\n+\tif (e->dest->index == cfg_bb->index)\n+\t  return true;\n+    }\n+  return false;\n }\n \n /* Return true if it is an RVV instruction depends on VTYPE global\n@@ -156,163 +176,339 @@ vector_config_insn_p (rtx_insn *rinsn)\n static bool\n vsetvl_insn_p (rtx_insn *rinsn)\n {\n+  if (!vector_config_insn_p (rinsn))\n+    return false;\n   return (INSN_CODE (rinsn) == CODE_FOR_vsetvldi\n-\t || INSN_CODE (rinsn) == CODE_FOR_vsetvlsi);\n+\t  || INSN_CODE (rinsn) == CODE_FOR_vsetvlsi);\n+}\n+\n+/* Return true if it is vsetvl zero, rs1.  */\n+static bool\n+vsetvl_discard_result_insn_p (rtx_insn *rinsn)\n+{\n+  if (!vector_config_insn_p (rinsn))\n+    return false;\n+  return (INSN_CODE (rinsn) == CODE_FOR_vsetvl_discard_resultdi\n+\t  || INSN_CODE (rinsn) == CODE_FOR_vsetvl_discard_resultsi);\n+}\n+\n+static bool\n+real_insn_and_same_bb_p (const insn_info *insn, const bb_info *bb)\n+{\n+  return insn != nullptr && insn->is_real () && insn->bb () == bb;\n }\n \n-/* Return true if INSN1 comes befeore INSN2 in the same block.  */\n static bool\n-same_bb_and_before_p (const insn_info *insn1, const insn_info *insn2)\n+before_p (const insn_info *insn1, const insn_info *insn2)\n+{\n+  return insn1->compare_with (insn2) < 0;\n+}\n+\n+static insn_info *\n+find_reg_killed_by (const bb_info *bb, rtx x)\n+{\n+  if (!x || vlmax_avl_p (x) || !REG_P (x))\n+    return nullptr;\n+  for (insn_info *insn : bb->reverse_real_nondebug_insns ())\n+    if (find_access (insn->defs (), REGNO (x)))\n+      return insn;\n+  return nullptr;\n+}\n+\n+/* Helper function to get VL operand.  */\n+static rtx\n+get_vl (rtx_insn *rinsn)\n {\n-  return ((insn1->bb ()->index () == insn2->bb ()->index ())\n-\t && (*insn1 < *insn2));\n+  if (has_vl_op (rinsn))\n+    {\n+      extract_insn_cached (rinsn);\n+      return recog_data.operand[get_attr_vl_op_idx (rinsn)];\n+    }\n+  return SET_DEST (XVECEXP (PATTERN (rinsn), 0, 0));\n }\n \n-/* Return true if INSN1 comes after or equal INSN2 in the same block.  */\n static bool\n-same_bb_and_after_or_equal_p (const insn_info *insn1, const insn_info *insn2)\n+has_vsetvl_killed_avl_p (const bb_info *bb, const vector_insn_info &info)\n {\n-  return ((insn1->bb ()->index () == insn2->bb ()->index ())\n-\t && (*insn1 >= *insn2));\n+  if (info.dirty_with_killed_avl_p ())\n+    {\n+      rtx avl = info.get_avl ();\n+      if (vlmax_avl_p (avl))\n+\treturn find_reg_killed_by (bb, get_vl (info.get_insn ()->rtl ()))\n+\t       != nullptr;\n+      for (const insn_info *insn : bb->reverse_real_nondebug_insns ())\n+\t{\n+\t  def_info *def = find_access (insn->defs (), REGNO (avl));\n+\t  if (def)\n+\t    {\n+\t      set_info *set = safe_dyn_cast<set_info *> (def);\n+\t      if (!set)\n+\t\treturn false;\n+\n+\t      rtx new_avl = gen_rtx_REG (GET_MODE (avl), REGNO (avl));\n+\t      gcc_assert (new_avl != avl);\n+\t      if (!info.compatible_avl_p (avl_info (new_avl, set)))\n+\t\treturn false;\n+\n+\t      return true;\n+\t    }\n+\t}\n+    }\n+  return false;\n }\n \n /* An \"anticipatable occurrence\" is one that is the first occurrence in the\n    basic block, the operands are not modified in the basic block prior\n    to the occurrence and the output is not used between the start of\n-   the block and the occurrence.  */\n+   the block and the occurrence.\n+\n+   For VSETVL instruction, we have these following formats:\n+     1. vsetvl zero, rs1.\n+     2. vsetvl zero, imm.\n+     3. vsetvl rd, rs1.\n+\n+   So base on these circumstances, a DEM is considered as a local anticipatable\n+   occurrence should satisfy these following conditions:\n+\n+     1). rs1 (avl) are not modified in the basic block prior to the VSETVL.\n+     2). rd (vl) are not modified in the basic block prior to the VSETVL.\n+     3). rd (vl) is not used between the start of the block and the occurrence.\n+\n+   Note: We don't need to check VL/VTYPE here since DEM is UNKNOWN if VL/VTYPE\n+\t is modified prior to the occurrence. This case is already considered as\n+\t a non-local anticipatable occurrence.\n+*/\n static bool\n-anticipatable_occurrence_p (const insn_info *insn, const vector_insn_info dem)\n+anticipatable_occurrence_p (const bb_info *bb, const vector_insn_info dem)\n {\n+  insn_info *insn = dem.get_insn ();\n   /* The only possible operand we care of VSETVL is AVL.  */\n   if (dem.has_avl_reg ())\n     {\n-      /* The operands should not be modified in the basic block prior\n-\t to the occurrence.  */\n+      /* rs1 (avl) are not modified in the basic block prior to the VSETVL.  */\n       if (!vlmax_avl_p (dem.get_avl ()))\n \t{\n \t  set_info *set\n \t    = find_access (insn->uses (), REGNO (dem.get_avl ()))->def ();\n \t  /* If it's undefined, it's not anticipatable conservatively.  */\n \t  if (!set)\n \t    return false;\n-\t  if (same_bb_and_before_p (set->insn (), insn))\n+\t  if (real_insn_and_same_bb_p (set->insn (), bb)\n+\t      && before_p (set->insn (), insn))\n \t    return false;\n \t}\n     }\n \n-  /* The output should not be used between the start of the block\n-     and the occurrence.  */\n+  /* rd (vl) is not used between the start of the block and the occurrence.  */\n   if (vsetvl_insn_p (insn->rtl ()))\n     {\n-      rtx dest = SET_DEST (XVECEXP (PATTERN (insn->rtl ()), 0, 0));\n-      for (insn_info *i = insn->prev_nondebug_insn (); i != nullptr;\n-\t   i = i->prev_nondebug_insn ())\n-\tif (find_access (i->uses (), REGNO (dest)))\n-\t  return false;\n+      rtx dest = get_vl (insn->rtl ());\n+      for (insn_info *i = insn->prev_nondebug_insn ();\n+\t   real_insn_and_same_bb_p (i, bb); i = i->prev_nondebug_insn ())\n+\t{\n+\t  /* rd (vl) is not used between the start of the block and the\n+\t   * occurrence.  */\n+\t  if (find_access (i->uses (), REGNO (dest)))\n+\t    return false;\n+\t  /* rd (vl) are not modified in the basic block prior to the VSETVL. */\n+\t  if (find_access (i->defs (), REGNO (dest)))\n+\t    return false;\n+\t}\n     }\n \n   return true;\n }\n \n /* An \"available occurrence\" is one that is the last occurrence in the\n    basic block and the operands are not modified by following statements in\n-   the basic block [including this insn].  */\n+   the basic block [including this insn].\n+\n+   For VSETVL instruction, we have these following formats:\n+     1. vsetvl zero, rs1.\n+     2. vsetvl zero, imm.\n+     3. vsetvl rd, rs1.\n+\n+   So base on these circumstances, a DEM is considered as a local available\n+   occurrence should satisfy these following conditions:\n+\n+     1). rs1 (avl) are not modified by following statements in\n+\t the basic block.\n+     2). rd (vl) are not modified by following statements in\n+\t the basic block.\n+\n+   Note: We don't need to check VL/VTYPE here since DEM is UNKNOWN if VL/VTYPE\n+\t is modified prior to the occurrence. This case is already considered as\n+\t a non-local available occurrence.\n+*/\n static bool\n-available_occurrence_p (const insn_info *insn, const vector_insn_info dem)\n+available_occurrence_p (const bb_info *bb, const vector_insn_info dem)\n {\n+  insn_info *insn = dem.get_insn ();\n   /* The only possible operand we care of VSETVL is AVL.  */\n   if (dem.has_avl_reg ())\n     {\n-      /* The operands should not be modified in the basic block prior\n-\t to the occurrence.\n-\t e.g.\n-\t    bb:\n-\t      vsetvl hr3, hr2, ...\n-\t      ...\n-\t      vadd ... (vl=hr3)\n-      */\n       if (!vlmax_avl_p (dem.get_avl ()))\n \t{\n-\t  set_info *set\n-\t    = find_access (insn->uses (), REGNO (dem.get_avl ()))->def ();\n-\t  /* If it's undefined, it's not available conservatively.  */\n-\t  if (!set)\n-\t    return false;\n-\t  if (same_bb_and_after_or_equal_p (set->insn (), insn))\n-\t    return false;\n+\t  rtx dest = NULL_RTX;\n+\t  if (vsetvl_insn_p (insn->rtl ()))\n+\t    dest = get_vl (insn->rtl ());\n+\t  for (const insn_info *i = insn; real_insn_and_same_bb_p (i, bb);\n+\t       i = i->next_nondebug_insn ())\n+\t    {\n+\t      /* rs1 (avl) are not modified by following statements in\n+\t\t the basic block.  */\n+\t      if (find_access (i->defs (), REGNO (dem.get_avl ())))\n+\t\treturn false;\n+\t      /* rd (vl) are not modified by following statements in\n+\t\t the basic block.  */\n+\t      if (dest && find_access (i->defs (), REGNO (dest)))\n+\t\treturn false;\n+\t    }\n \t}\n     }\n   return true;\n }\n \n-/* Return true if the branch probability is dominate.  */\n-static bool\n-dominate_probability_p (edge e)\n-{\n-  /* TODO: We simpily pick dominate probability >= 50%.\n-     However, it isn't always optimal. Consider cases\n-     like this:\n-       bb 0: 80% succs: bb 2, bb 3, bb 4, bb 5.\n-       bb 1: 20%\n-\n-     Assume bb 1, bb 2, bb 3, bb 4, bb 5 are different\n-     one another, and bb 2, bb 3, bb 4, bb 5 are incompatible.\n-\n-     ??? Maybe backward propagate bb 1 is better ???\n-     May need to support an accurate and reliable COST model\n-     in the future.  */\n-  return e->probability >= profile_probability::even ();\n-}\n-\n /* Return true if the block is worthwhile backward propagation.  */\n static bool\n backward_propagate_worthwhile_p (const basic_block cfg_bb,\n \t\t\t\t const vector_block_info block_info)\n {\n   if (loop_basic_block_p (cfg_bb))\n     {\n-      if (block_info.local_dem.compatible_p (block_info.reaching_out))\n-\treturn true;\n-\n-      /* There is a obvious case that is not worthwhile and meaningless\n-\t to propagate the demand information:\n-\t\t\t  local_dem\n-\t\t\t     __________\n-\t\t\t ____|____     |\n-\t\t\t|        |     |\n-\t\t\t|________|     |\n-\t\t\t     |_________|\n-\t\t\t  reaching_out\n-\t  Header is incompatible with reaching_out and the block is loop itself,\n-\t  we don't backward propagate the local_dem since we can't avoid emit\n-\t  vsetvl for the local_dem.  */\n-      edge e;\n-      edge_iterator ei;\n-      FOR_EACH_EDGE (e, ei, cfg_bb->succs)\n-\tif (e->dest->index == cfg_bb->index)\n+      if (block_info.reaching_out.valid_or_dirty_p ())\n+\t{\n+\t  if (block_info.local_dem.compatible_p (block_info.reaching_out))\n+\t    {\n+\t      /* Case 1 (Can backward propagate):\n+\t\t ....\n+\t\t bb0:\n+\t\t ...\n+\t\t for (int i = 0; i < n; i++)\n+\t\t   {\n+\t\t     vint16mf4_t v = __riscv_vle16_v_i16mf4 (in + i + 5, 7);\n+\t\t     __riscv_vse16_v_i16mf4 (out + i + 5, v, 7);\n+\t\t   }\n+\t\t The local_dem is compatible with reaching_out. Such case is\n+\t\t worthwhile backward propagation.  */\n+\t      return true;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Case 2 (Don't backward propagate):\n+\t\t    ....\n+\t\t    bb0:\n+\t\t    ...\n+\t\t    for (int i = 0; i < n; i++)\n+\t\t      {\n+\t\t\tvint16mf4_t v = __riscv_vle16_v_i16mf4 (in + i + 5, 7);\n+\t\t\t__riscv_vse16_v_i16mf4 (out + i + 5, v, 7);\n+\t\t\tvint16mf2_t v2 = __riscv_vle16_v_i16mf2 (in + i + 6, 8);\n+\t\t\t__riscv_vse16_v_i16mf2 (out + i + 6, v, 8);\n+\t\t      }\n+\t\t The local_dem is incompatible with reaching_out.\n+\t\t It makes no sense to backward propagate the local_dem since we\n+\t\t can't avoid VSETVL inside the loop.  */\n+\t      return false;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (block_info.reaching_out.unknown_p ());\n+\t  /* Case 3 (Don't backward propagate):\n+\t\t....\n+\t\tbb0:\n+\t\t...\n+\t\tfor (int i = 0; i < n; i++)\n+\t\t  {\n+\t\t    vint16mf4_t v = __riscv_vle16_v_i16mf4 (in + i + 5, 7);\n+\t\t    __riscv_vse16_v_i16mf4 (out + i + 5, v, 7);\n+\t\t    fn3 ();\n+\t\t  }\n+\t    The local_dem is VALID, but the reaching_out is UNKNOWN.\n+\t    It makes no sense to backward propagate the local_dem since we\n+\t    can't avoid VSETVL inside the loop.  */\n \t  return false;\n+\t}\n     }\n \n   return true;\n }\n \n-/* Helper function to get VL operand.  */\n-static rtx\n-get_vl (rtx_insn *rinsn)\n+static bool\n+insn_should_be_added_p (const insn_info *insn, unsigned int types)\n {\n-  if (has_vl_op (rinsn))\n+  if (insn->is_real () && (types & REAL_SET))\n+    return true;\n+  if (insn->is_phi () && (types & PHI_SET))\n+    return true;\n+  if (insn->is_bb_head () && (types & BB_HEAD_SET))\n+    return true;\n+  if (insn->is_bb_end () && (types & BB_END_SET))\n+    return true;\n+  return false;\n+}\n+\n+/* Recursively find all define instructions. The kind of instruction is\n+   specified by the DEF_TYPE.  */\n+static hash_set<set_info *>\n+get_all_sets (phi_info *phi, unsigned int types)\n+{\n+  hash_set<set_info *> insns;\n+  auto_vec<phi_info *> work_list;\n+  hash_set<phi_info *> visited_list;\n+  if (!phi)\n+    return hash_set<set_info *> ();\n+  work_list.safe_push (phi);\n+\n+  while (!work_list.is_empty ())\n     {\n-      extract_insn_cached (rinsn);\n-      return recog_data.operand[get_attr_vl_op_idx (rinsn)];\n+      phi_info *phi = work_list.pop ();\n+      visited_list.add (phi);\n+      for (use_info *use : phi->inputs ())\n+\t{\n+\t  def_info *def = use->def ();\n+\t  set_info *set = safe_dyn_cast<set_info *> (def);\n+\t  if (!set)\n+\t    return hash_set<set_info *> ();\n+\n+\t  gcc_assert (!set->insn ()->is_debug_insn ());\n+\n+\t  if (insn_should_be_added_p (set->insn (), types))\n+\t    insns.add (set);\n+\t  if (set->insn ()->is_phi ())\n+\t    {\n+\t      phi_info *new_phi = as_a<phi_info *> (set);\n+\t      if (!visited_list.contains (new_phi))\n+\t\twork_list.safe_push (new_phi);\n+\t    }\n+\t}\n     }\n-  return SET_DEST (XVECEXP (PATTERN (rinsn), 0, 0));\n+  return insns;\n+}\n+\n+static hash_set<set_info *>\n+get_all_sets (set_info *set, bool /* get_real_inst */ real_p,\n+\t      bool /*get_phi*/ phi_p, bool /* get_function_parameter*/ param_p)\n+{\n+  if (real_p && phi_p && param_p)\n+    return get_all_sets (safe_dyn_cast<phi_info *> (set),\n+\t\t\t REAL_SET | PHI_SET | BB_HEAD_SET | BB_END_SET);\n+\n+  else if (real_p && param_p)\n+    return get_all_sets (safe_dyn_cast<phi_info *> (set),\n+\t\t\t REAL_SET | BB_HEAD_SET | BB_END_SET);\n+\n+  else if (real_p)\n+    return get_all_sets (safe_dyn_cast<phi_info *> (set), REAL_SET);\n+  return hash_set<set_info *> ();\n }\n \n /* Helper function to get AVL operand.  */\n static rtx\n get_avl (rtx_insn *rinsn)\n {\n-  if (vsetvl_insn_p (rinsn))\n+  if (vsetvl_insn_p (rinsn) || vsetvl_discard_result_insn_p (rinsn))\n     return XVECEXP (SET_SRC (XVECEXP (PATTERN (rinsn), 0, 0)), 0, 0);\n \n   if (!has_vl_op (rinsn))\n@@ -323,97 +519,48 @@ get_avl (rtx_insn *rinsn)\n   return recog_data.operand[get_attr_vl_op_idx (rinsn)];\n }\n \n-static bool\n-can_backward_propagate_p (const function_info *ssa, const basic_block cfg_bb,\n-\t\t\t  const vector_insn_info prop)\n+static set_info *\n+get_same_bb_set (hash_set<set_info *> &sets, const basic_block cfg_bb)\n {\n-  insn_info *insn = prop.get_insn ();\n-\n-  /* TODO: We don't backward propagate the explict VSETVL here\n-     since we will change vsetvl and vsetvlmax intrinsics into\n-     no side effects which can be optimized into optimal location\n-     by GCC internal passes. We only need to support these backward\n-     propagation if vsetvl intrinsics have side effects.  */\n-  if (vsetvl_insn_p (insn->rtl ()))\n-    return false;\n+  for (set_info *set : sets)\n+    if (set->bb ()->cfg_bb () == cfg_bb)\n+      return set;\n+  return nullptr;\n+}\n \n-  gcc_assert (has_vtype_op (insn->rtl ()));\n-  rtx reg = NULL_RTX;\n+/* Recursively find all predecessor blocks for cfg_bb. */\n+static hash_set<basic_block>\n+get_all_predecessors (basic_block cfg_bb)\n+{\n+  hash_set<basic_block> blocks;\n+  auto_vec<basic_block> work_list;\n+  hash_set<basic_block> visited_list;\n+  work_list.safe_push (cfg_bb);\n \n-  /* Case 1: Don't need VL. Just let it backward propagate.  */\n-  if (!has_vl_op (insn->rtl ()))\n-    return true;\n-  else\n+  while (!work_list.is_empty ())\n     {\n-      /* Case 2: CONST_INT AVL, we don't need to check def.  */\n-      if (prop.has_avl_imm ())\n-\treturn true;\n-      else\n+      basic_block new_cfg_bb = work_list.pop ();\n+      visited_list.add (new_cfg_bb);\n+      edge e;\n+      edge_iterator ei;\n+      FOR_EACH_EDGE (e, ei, new_cfg_bb->preds)\n \t{\n-\t  /* Case 3: REG AVL, we need to check the distance of def to make\n-\t     sure we won't backward propagate over the def.  */\n-\t  gcc_assert (prop.has_avl_reg ());\n-\t  if (vlmax_avl_p (prop.get_avl ()))\n-\t    /* Check VL operand for vsetvl vl,zero.  */\n-\t    reg = get_vl (insn->rtl ());\n-\t  else\n-\t    /* Check AVL operand for vsetvl zero,avl.  */\n-\t    reg = get_avl (insn->rtl ());\n+\t  if (!visited_list.contains (e->src))\n+\t    work_list.safe_push (e->src);\n+\t  blocks.add (e->src);\n \t}\n     }\n+  return blocks;\n+}\n \n-  def_info *def = find_access (insn->uses (), REGNO (reg))->def ();\n-\n-  /* If the definition is in the current block, we can't propagate it\n-     across blocks.  */\n-  if (def->bb ()->cfg_bb ()->index == insn->bb ()->cfg_bb ()->index)\n-    {\n-      set_info *set = safe_dyn_cast<set_info *> (def);\n-\n-      /* True if it is a degenerate PHI that can be backward propagated.  */\n-      auto valid_degenerate_phi_p = [&] () {\n-\tif (!set)\n-\t  return false;\n-\n-\tphi_info *phi = safe_dyn_cast<phi_info *> (set);\n-\tif (!phi)\n-\t  return false;\n-\n-\tbasic_block iter_bb;\n-\tset_info *ultimate_def = look_through_degenerate_phi (set);\n-\tconst basic_block ultimate_bb = ultimate_def->bb ()->cfg_bb ();\n-\tFOR_BB_BETWEEN (iter_bb, ultimate_bb, def->bb ()->cfg_bb (), next_bb)\n-\t  if (iter_bb->index == cfg_bb->index)\n-\t    return true;\n-\n-\treturn false;\n-      };\n-\n-      if (valid_degenerate_phi_p ())\n-\treturn true;\n-\n-      /* TODO: Support non-degenerate PHI backward propagation later.  */\n-      return false;\n-    }\n-\n-  /* If the definition block is the current block that we iterate, we\n-     can backward propagate it since we will insert or change VL/VTYPE\n-     info at the end of the current block we iterate.  */\n-  if (def->bb ()->cfg_bb ()->index == cfg_bb->index)\n-    return true;\n-\n-  /* Make sure we don't backward propagate the VL/VTYPE info over the\n-     definition blocks.  */\n-  bool visited_p = false;\n-  for (const bb_info *bb : ssa->reverse_bbs ())\n-    {\n-      if (bb->cfg_bb ()->index == cfg_bb->index && visited_p)\n-\treturn false;\n-      if (bb->cfg_bb ()->index == def->bb ()->cfg_bb ()->index)\n-\tvisited_p = true;\n-    }\n-\n-  return true;\n+/* Return true if there is an INSN in insns staying in the block BB.  */\n+static bool\n+any_set_in_bb_p (hash_set<set_info *> sets, const bb_info *bb)\n+{\n+  for (const set_info *set : sets)\n+    if (set->bb ()->index () == bb->index ())\n+      return true;\n+  return false;\n }\n \n /* Helper function to get SEW operand. We always have SEW value for\n@@ -487,7 +634,7 @@ has_vector_insn (function *fn)\n \n /* Emit vsetvl instruction.  */\n static rtx\n-gen_vsetvl_pat (enum vsetvl_type insn_type, vl_vtype_info info, rtx vl)\n+gen_vsetvl_pat (enum vsetvl_type insn_type, const vl_vtype_info &info, rtx vl)\n {\n   rtx avl = info.get_avl ();\n   rtx sew = gen_int_mode (info.get_sew (), Pmode);\n@@ -507,7 +654,7 @@ gen_vsetvl_pat (enum vsetvl_type insn_type, vl_vtype_info info, rtx vl)\n }\n \n static rtx\n-gen_vsetvl_pat (rtx_insn *rinsn, const vector_insn_info info)\n+gen_vsetvl_pat (rtx_insn *rinsn, const vector_insn_info &info)\n {\n   rtx new_pat;\n   if (vsetvl_insn_p (rinsn) || vlmax_avl_p (info.get_avl ()))\n@@ -524,7 +671,7 @@ gen_vsetvl_pat (rtx_insn *rinsn, const vector_insn_info info)\n \n static void\n emit_vsetvl_insn (enum vsetvl_type insn_type, enum emit_type emit_type,\n-\t\t  vl_vtype_info info, rtx vl, rtx_insn *rinsn)\n+\t\t  const vl_vtype_info &info, rtx vl, rtx_insn *rinsn)\n {\n   rtx pat = gen_vsetvl_pat (insn_type, info, vl);\n   if (dump_file)\n@@ -562,7 +709,7 @@ insert_vsetvl (enum emit_type emit_type, rtx_insn *rinsn,\n   /* Use X0, X0 form if the AVL is the same and the SEW+LMUL gives the same\n      VLMAX.  */\n   if (prev_info.valid_or_dirty_p () && !prev_info.unknown_p ()\n-      && info.same_avl_p (prev_info) && info.same_vlmax_p (prev_info))\n+      && info.compatible_avl_p (prev_info) && info.same_vlmax_p (prev_info))\n     {\n       emit_vsetvl_insn (VSETVL_VTYPE_CHANGE_ONLY, emit_type, info, NULL_RTX,\n \t\t\trinsn);\n@@ -627,7 +774,7 @@ insert_vsetvl (enum emit_type emit_type, rtx_insn *rinsn,\n    necessary REG_LABEL_OPERAND and REG_LABEL_TARGET notes.  */\n \n static void\n-add_label_notes (rtx x, rtx_insn *insn)\n+add_label_notes (rtx x, rtx_insn *rinsn)\n {\n   enum rtx_code code = GET_CODE (x);\n   int i, j;\n@@ -644,8 +791,8 @@ add_label_notes (rtx x, rtx_insn *insn)\n       /* There's no reason for current users to emit jump-insns with\n \t such a LABEL_REF, so we don't have to handle REG_LABEL_TARGET\n \t notes.  */\n-      gcc_assert (!JUMP_P (insn));\n-      add_reg_note (insn, REG_LABEL_OPERAND, label_ref_label (x));\n+      gcc_assert (!JUMP_P (rinsn));\n+      add_reg_note (rinsn, REG_LABEL_OPERAND, label_ref_label (x));\n \n       if (LABEL_P (label_ref_label (x)))\n \tLABEL_NUSES (label_ref_label (x))++;\n@@ -656,10 +803,10 @@ add_label_notes (rtx x, rtx_insn *insn)\n   for (i = GET_RTX_LENGTH (code) - 1, fmt = GET_RTX_FORMAT (code); i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\tadd_label_notes (XEXP (x, i), insn);\n+\tadd_label_notes (XEXP (x, i), rinsn);\n       else if (fmt[i] == 'E')\n \tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t  add_label_notes (XVECEXP (x, i, j), insn);\n+\t  add_label_notes (XVECEXP (x, i, j), rinsn);\n     }\n }\n \n@@ -741,10 +888,6 @@ insert_insn_end_basic_block (rtx_insn *rinsn, basic_block cfg_bb)\n static vl_vtype_info\n get_vl_vtype_info (const insn_info *insn)\n {\n-  if (vector_config_insn_p (insn->rtl ()))\n-    gcc_assert (vsetvl_insn_p (insn->rtl ())\n-\t\t&& \"Can't handle X0, rs1 vsetvli yet\");\n-\n   set_info *set = nullptr;\n   rtx avl = ::get_avl (insn->rtl ());\n   if (avl && REG_P (avl) && !vlmax_avl_p (avl))\n@@ -787,7 +930,7 @@ change_insn (rtx_insn *rinsn, rtx new_pat)\n       print_rtl_single (dump_file, PATTERN (rinsn));\n     }\n \n-  validate_change (rinsn, &PATTERN (rinsn), new_pat, true);\n+  validate_change (rinsn, &PATTERN (rinsn), new_pat, false);\n \n   if (dump_file)\n     {\n@@ -829,6 +972,107 @@ change_insn (function_info *ssa, insn_change change, insn_info *insn,\n   return true;\n }\n \n+static void\n+change_vsetvl_insn (const insn_info *insn, const vector_insn_info &info)\n+{\n+  rtx_insn *rinsn;\n+  if (vector_config_insn_p (insn->rtl ()))\n+    {\n+      rinsn = insn->rtl ();\n+      gcc_assert (vsetvl_insn_p (rinsn) && \"Can't handle X0, rs1 vsetvli yet\");\n+    }\n+  else\n+    {\n+      gcc_assert (has_vtype_op (insn->rtl ()));\n+      rinsn = PREV_INSN (insn->rtl ());\n+      gcc_assert (vector_config_insn_p (rinsn));\n+    }\n+  rtx new_pat = gen_vsetvl_pat (rinsn, info);\n+  change_insn (rinsn, new_pat);\n+}\n+\n+static bool\n+source_equal_p (insn_info *insn1, insn_info *insn2)\n+{\n+  if (!insn1 || !insn2)\n+    return false;\n+  rtx_insn *rinsn1 = insn1->rtl ();\n+  rtx_insn *rinsn2 = insn2->rtl ();\n+  if (!rinsn1 || !rinsn2)\n+    return false;\n+  rtx note1 = find_reg_equal_equiv_note (rinsn1);\n+  rtx note2 = find_reg_equal_equiv_note (rinsn2);\n+  rtx single_set1 = single_set (rinsn1);\n+  rtx single_set2 = single_set (rinsn2);\n+\n+  if (note1 && note2 && rtx_equal_p (note1, note2))\n+    return true;\n+\n+  /* Since vsetvl instruction is not single SET.\n+     We handle this case specially here.  */\n+  if (vsetvl_insn_p (insn1->rtl ()) && vsetvl_insn_p (insn2->rtl ()))\n+    {\n+      /* For example:\n+\t   vsetvl1 a6,a5,e32m1\n+\t   RVV 1 (use a6 as AVL)\n+\t   vsetvl2 a5,a5,e8mf4\n+\t   RVV 2 (use a5 as AVL)\n+\t We consider AVL of RVV 1 and RVV 2 are same so that we can\n+\t gain more optimization opportunities.\n+\n+\t Note: insn1_info.compatible_avl_p (insn2_info)\n+\t will make sure there is no instruction between vsetvl1 and vsetvl2\n+\t modify a5 since their def will be different if there is instruction\n+\t modify a5 and compatible_avl_p will return false.  */\n+      vector_insn_info insn1_info, insn2_info;\n+      insn1_info.parse_insn (insn1);\n+      insn2_info.parse_insn (insn2);\n+      if (insn1_info.same_vlmax_p (insn2_info)\n+\t  && insn1_info.compatible_avl_p (insn2_info))\n+\treturn true;\n+    }\n+\n+  /* We only handle AVL is set by instructions with no side effects.  */\n+  if (!single_set1 || !single_set2)\n+    return false;\n+  if (!rtx_equal_p (SET_SRC (single_set1), SET_SRC (single_set2)))\n+    return false;\n+  gcc_assert (insn1->uses ().size () == insn2->uses ().size ());\n+  for (size_t i = 0; i < insn1->uses ().size (); i++)\n+    if (insn1->uses ()[i] != insn2->uses ()[i])\n+      return false;\n+  return true;\n+}\n+\n+/* Helper function to get single same real RTL source.\n+   return NULL if it is not a single real RTL source.  */\n+static insn_info *\n+extract_single_source (set_info *set)\n+{\n+  if (!set)\n+    return nullptr;\n+  if (set->insn ()->is_real ())\n+    return set->insn ();\n+  if (!set->insn ()->is_phi ())\n+    return nullptr;\n+  hash_set<set_info *> sets = get_all_sets (set, true, false, true);\n+\n+  insn_info *first_insn = (*sets.begin ())->insn ();\n+  if (first_insn->is_artificial ())\n+    return nullptr;\n+  for (const set_info *set : sets)\n+    {\n+      /* If there is a head or end insn, we conservative return\n+\t NULL so that VSETVL PASS will insert vsetvl directly.  */\n+      if (set->insn ()->is_artificial ())\n+\treturn nullptr;\n+      if (!source_equal_p (set->insn (), first_insn))\n+\treturn nullptr;\n+    }\n+\n+  return first_insn;\n+}\n+\n avl_info::avl_info (const avl_info &other)\n {\n   m_value = other.get_value ();\n@@ -839,6 +1083,89 @@ avl_info::avl_info (rtx value_in, set_info *source_in)\n   : m_value (value_in), m_source (source_in)\n {}\n \n+bool\n+avl_info::single_source_equal_p (const avl_info &other) const\n+{\n+  set_info *set1 = m_source;\n+  set_info *set2 = other.get_source ();\n+  insn_info *insn1 = extract_single_source (set1);\n+  insn_info *insn2 = extract_single_source (set2);\n+  if (!insn1 || !insn2)\n+    return false;\n+  return source_equal_p (insn1, insn2);\n+}\n+\n+bool\n+avl_info::multiple_source_equal_p (const avl_info &other) const\n+{\n+  /* TODO: We don't do too much optimization here since it's\n+     too complicated in case of analyzing the PHI node.\n+\n+     For example:\n+       void f (void * restrict in, void * restrict out, int n, int m, int cond)\n+\t{\n+\t  size_t vl;\n+\t  switch (cond)\n+\t  {\n+\t  case 1:\n+\t    vl = 100;\n+\t    break;\n+\t  case 2:\n+\t    vl = *(size_t*)(in + 100);\n+\t    break;\n+\t  case 3:\n+\t    {\n+\t      size_t new_vl = *(size_t*)(in + 500);\n+\t      size_t new_vl2 = *(size_t*)(in + 600);\n+\t      vl = new_vl + new_vl2 + 777;\n+\t      break;\n+\t    }\n+\t  default:\n+\t    vl = 4000;\n+\t    break;\n+\t  }\n+\t  for (size_t i = 0; i < n; i++)\n+\t    {\n+\t      vint8mf8_t v = __riscv_vle8_v_i8mf8 (in + i, vl);\n+\t      __riscv_vse8_v_i8mf8 (out + i, v, vl);\n+\n+\t      vint8mf8_t v2 = __riscv_vle8_v_i8mf8_tu (v, in + i + 100, vl);\n+\t      __riscv_vse8_v_i8mf8 (out + i + 100, v2, vl);\n+\t    }\n+\n+\t  size_t vl2;\n+\t  switch (cond)\n+\t  {\n+\t  case 1:\n+\t    vl2 = 100;\n+\t    break;\n+\t  case 2:\n+\t    vl2 = *(size_t*)(in + 100);\n+\t    break;\n+\t  case 3:\n+\t    {\n+\t      size_t new_vl = *(size_t*)(in + 500);\n+\t      size_t new_vl2 = *(size_t*)(in + 600);\n+\t      vl2 = new_vl + new_vl2 + 777;\n+\t      break;\n+\t    }\n+\t  default:\n+\t    vl2 = 4000;\n+\t    break;\n+\t  }\n+\t  for (size_t i = 0; i < m; i++)\n+\t    {\n+\t      vint8mf8_t v = __riscv_vle8_v_i8mf8 (in + i + 300, vl2);\n+\t      __riscv_vse8_v_i8mf8 (out + i + 300, v, vl2);\n+\t      vint8mf8_t v2 = __riscv_vle8_v_i8mf8_tu (v, in + i + 200, vl2);\n+\t      __riscv_vse8_v_i8mf8 (out + i + 200, v2, vl2);\n+\t    }\n+\t}\n+     Such case may not be necessary to optimize since the codes of defining\n+     vl and vl2 are redundant.  */\n+  return m_source == other.get_source ();\n+}\n+\n avl_info &\n avl_info::operator= (const avl_info &other)\n {\n@@ -855,11 +1182,6 @@ avl_info::operator== (const avl_info &other) const\n   if (!other.get_value ())\n     return false;\n \n-  /* It's safe to consider they are equal if their RTX value are\n-     strictly the same.  */\n-  if (m_value == other.get_value ())\n-    return true;\n-\n   if (GET_CODE (m_value) != GET_CODE (other.get_value ()))\n     return false;\n \n@@ -871,9 +1193,16 @@ avl_info::operator== (const avl_info &other) const\n   if (vlmax_avl_p (m_value))\n     return vlmax_avl_p (other.get_value ());\n \n-  /* TODO: So far we only support VLMAX (AVL=zero) comparison,\n-     we will support non-VLMAX AVL in the future.  */\n-  return false;\n+  /* If any source is undef value, we think they are not equal.  */\n+  if (!m_source || !other.get_source ())\n+    return false;\n+\n+  /* If both sources are single source (defined by a single real RTL)\n+     and their definitions are same.  */\n+  if (single_source_equal_p (other))\n+    return true;\n+\n+  return multiple_source_equal_p (other);\n }\n \n bool\n@@ -895,7 +1224,7 @@ vl_vtype_info::vl_vtype_info (avl_info avl_in, uint8_t sew_in,\n bool\n vl_vtype_info::operator== (const vl_vtype_info &other) const\n {\n-  return m_avl == other.get_avl_info () && m_sew == other.get_sew ()\n+  return same_avl_p (other) && m_sew == other.get_sew ()\n \t && m_vlmul == other.get_vlmul () && m_ta == other.get_ta ()\n \t && m_ma == other.get_ma () && m_ratio == other.get_ratio ();\n }\n@@ -919,7 +1248,12 @@ vl_vtype_info::has_non_zero_avl () const\n bool\n vl_vtype_info::same_avl_p (const vl_vtype_info &other) const\n {\n-  return get_avl_info () == other.get_avl_info ();\n+  /* We need to compare both RTL and SET. If both AVL are CONST_INT.\n+     For example, const_int 3 and const_int 4, we need to compare\n+     RTL. If both AVL are REG and their REGNO are same, we need to\n+     compare SET.  */\n+  return get_avl () == other.get_avl ()\n+\t && get_avl_source () == other.get_avl_source ();\n }\n \n bool\n@@ -978,12 +1312,10 @@ vector_insn_info::operator>= (const vector_insn_info &other) const\n \t}\n     }\n \n-  if (demand_p (DEMAND_TAIL_POLICY) && !other.demand_p (DEMAND_TAIL_POLICY)\n-      && get_ta () != other.get_ta ())\n+  if (!demand_p (DEMAND_TAIL_POLICY) && other.demand_p (DEMAND_TAIL_POLICY))\n     return false;\n \n-  if (demand_p (DEMAND_MASK_POLICY) && !other.demand_p (DEMAND_MASK_POLICY)\n-      && get_ma () != other.get_ma ())\n+  if (!demand_p (DEMAND_MASK_POLICY) && other.demand_p (DEMAND_MASK_POLICY))\n     return false;\n \n   return true;\n@@ -1011,10 +1343,10 @@ vector_insn_info::operator== (const vector_insn_info &other) const\n     if (m_demands[i] != other.demand_p ((enum demand_type) i))\n       return false;\n \n-  if (m_insn != other.get_insn ())\n-    return false;\n-  if (m_dirty_pat != other.get_dirty_pat ())\n-    return false;\n+  if (vector_config_insn_p (m_insn->rtl ())\n+      || vector_config_insn_p (other.get_insn ()->rtl ()))\n+    if (m_insn != other.get_insn ())\n+      return false;\n \n   if (!same_avl_p (other))\n     return false;\n@@ -1102,12 +1434,31 @@ vector_insn_info::parse_insn (insn_info *insn)\n     m_demands[DEMAND_TAIL_POLICY] = true;\n   if (get_attr_ma (insn->rtl ()) != INVALID_ATTRIBUTE)\n     m_demands[DEMAND_MASK_POLICY] = true;\n-}\n \n-void\n-vector_insn_info::demand_vl_vtype ()\n-{\n-  m_state = VALID;\n+  if (vector_config_insn_p (insn->rtl ()))\n+    return;\n+\n+  if (!has_avl_reg () || !m_avl.get_source ()\n+      || !m_avl.get_source ()->insn ()->is_phi ())\n+    return;\n+\n+  insn_info *def_insn = extract_single_source (m_avl.get_source ());\n+  if (def_insn)\n+    {\n+      vector_insn_info new_info;\n+      new_info.parse_insn (def_insn);\n+      if (!same_vlmax_p (new_info))\n+\treturn;\n+      /* TODO: Currently, we don't forward AVL for non-VLMAX vsetvl.  */\n+      if (vlmax_avl_p (new_info.get_avl ()))\n+\tset_avl_info (new_info.get_avl_info ());\n+    }\n+}\n+\n+void\n+vector_insn_info::demand_vl_vtype ()\n+{\n+  m_state = VALID;\n   m_demands[DEMAND_AVL] = true;\n   m_demands[DEMAND_SEW] = true;\n   m_demands[DEMAND_LMUL] = true;\n@@ -1150,7 +1501,7 @@ vector_insn_info::compatible_p (const vector_insn_info &other) const\n     return false;\n \n   if (demand_p (DEMAND_AVL) && other.demand_p (DEMAND_AVL))\n-    return m_avl == other.get_avl_info ();\n+    return compatible_avl_p (other);\n \n   return true;\n }\n@@ -1165,6 +1516,15 @@ vector_insn_info::compatible_avl_p (const vl_vtype_info &other) const\n   return get_avl_info () == other.get_avl_info ();\n }\n \n+bool\n+vector_insn_info::compatible_avl_p (const avl_info &other) const\n+{\n+  gcc_assert (valid_or_dirty_p () && \"Can't compare invalid vl_vtype_info\");\n+  gcc_assert (!unknown_p () && \"Can't compare AVL in unknown state\");\n+  gcc_assert (demand_p (DEMAND_AVL) && \"Can't compare AVL undemand state\");\n+  return get_avl_info () == other;\n+}\n+\n bool\n vector_insn_info::compatible_vtype_p (const vl_vtype_info &other) const\n {\n@@ -1206,33 +1566,50 @@ vector_insn_info::compatible_p (const vl_vtype_info &curr_info) const\n   return compatible_avl_p (curr_info) && compatible_vtype_p (curr_info);\n }\n \n+bool\n+vector_insn_info::available_p (const vector_insn_info &other) const\n+{\n+  if (*this >= other)\n+    return true;\n+  return false;\n+}\n+\n vector_insn_info\n vector_insn_info::merge (const vector_insn_info &merge_info,\n-\t\t\t bool across_bb_p = false) const\n+\t\t\t enum merge_type type = LOCAL_MERGE) const\n {\n-  gcc_assert (this->compatible_p (merge_info)\n-\t      && \"Can't merge incompatible demanded infos\");\n+  if (!vsetvl_insn_p (get_insn ()->rtl ()))\n+    gcc_assert (this->compatible_p (merge_info)\n+\t\t&& \"Can't merge incompatible demanded infos\");\n \n   vector_insn_info new_info;\n   new_info.demand_vl_vtype ();\n \n-  if (dirty_p ())\n+  if (type == LOCAL_MERGE)\n     {\n-      gcc_assert (across_bb_p);\n-      if (demand_p (DEMAND_AVL))\n-\tnew_info.set_insn (get_insn ());\n-      else\n-\tnew_info.set_insn (merge_info.get_insn ());\n+      /* For local backward data flow, we always update INSN && AVL as the\n+\t latest INSN and AVL so that we can keep track status of each INSN.*/\n+      new_info.set_insn (merge_info.get_insn ());\n+      if (merge_info.demand_p (DEMAND_AVL))\n+\tnew_info.set_avl_info (merge_info.get_avl_info ());\n+      else if (demand_p (DEMAND_AVL))\n+\tnew_info.set_avl_info (get_avl_info ());\n     }\n   else\n     {\n-      if (across_bb_p)\n-\tnew_info.set_insn (get_insn ());\n-      else\n-\tnew_info.set_insn (merge_info.get_insn ());\n-    }\n+      /* For global data flow, we should keep original INSN and AVL if they\n+\t valid since we should keep the life information of each block.\n \n-  new_info.set_dirty_pat (merge_info.get_dirty_pat ());\n+\t For example:\n+\t   bb 0 -> bb 1.\n+\t We should keep INSN && AVL of bb 1 since we will eventually emit\n+\t vsetvl instruction according to INSN and AVL of bb 1.  */\n+      new_info.set_insn (get_insn ());\n+      if (demand_p (DEMAND_AVL))\n+\tnew_info.set_avl_info (get_avl_info ());\n+      else if (merge_info.demand_p (DEMAND_AVL))\n+\tnew_info.set_avl_info (merge_info.get_avl_info ());\n+    }\n \n   if (!demand_p (DEMAND_AVL) && !merge_info.demand_p (DEMAND_AVL))\n     new_info.undemand (DEMAND_AVL);\n@@ -1248,11 +1625,6 @@ vector_insn_info::merge (const vector_insn_info &merge_info,\n       && !merge_info.demand_p (DEMAND_MASK_POLICY))\n     new_info.undemand (DEMAND_MASK_POLICY);\n \n-  if (merge_info.demand_p (DEMAND_AVL))\n-    new_info.set_avl_info (merge_info.get_avl_info ());\n-  else if (demand_p (DEMAND_AVL))\n-    new_info.set_avl_info (get_avl_info ());\n-\n   if (merge_info.demand_p (DEMAND_SEW))\n     new_info.set_sew (merge_info.get_sew ());\n   else if (demand_p (DEMAND_SEW))\n@@ -1320,6 +1692,10 @@ vector_insn_info::dump (FILE *file) const\n     fprintf (file, \"UNKNOWN,\");\n   else if (empty_p ())\n     fprintf (file, \"EMPTY,\");\n+  else if (hard_empty_p ())\n+    fprintf (file, \"HARD_EMPTY,\");\n+  else if (dirty_with_killed_avl_p ())\n+    fprintf (file, \"DIRTY_WITH_KILLED_AVL,\");\n   else\n     fprintf (file, \"DIRTY,\");\n \n@@ -1346,11 +1722,6 @@ vector_insn_info::dump (FILE *file) const\n \t  fprintf (file, \"The real INSN=\");\n \t  print_rtl_single (file, get_insn ()->rtl ());\n \t}\n-      if (get_dirty_pat ())\n-\t{\n-\t  fprintf (file, \"Dirty RTL Pattern=\");\n-\t  print_rtl_single (file, get_dirty_pat ());\n-\t}\n     }\n }\n \n@@ -1387,6 +1758,7 @@ vector_infos_manager::vector_infos_manager ()\n \t  vector_block_infos[bb->index ()].reaching_out = vector_insn_info ();\n \t  for (insn_info *insn : bb->real_insns ())\n \t    vector_insn_infos[insn->uid ()].parse_insn (insn);\n+\t  vector_block_infos[bb->index ()].probability = profile_probability ();\n \t}\n     }\n }\n@@ -1415,7 +1787,7 @@ vector_infos_manager::get_all_available_exprs (\n {\n   auto_vec<size_t> available_list;\n   for (size_t i = 0; i < vector_exprs.length (); i++)\n-    if (info >= *vector_exprs[i])\n+    if (info.available_p (*vector_exprs[i]))\n       available_list.safe_push (i);\n   return available_list;\n }\n@@ -1440,6 +1812,29 @@ vector_infos_manager::all_same_ratio_p (sbitmap bitdata) const\n   return true;\n }\n \n+bool\n+vector_infos_manager::all_same_avl_p (const basic_block cfg_bb,\n+\t\t\t\t      sbitmap bitdata) const\n+{\n+  if (bitmap_empty_p (bitdata))\n+    return false;\n+\n+  const auto &block_info = vector_block_infos[cfg_bb->index];\n+  if (!block_info.local_dem.demand_p (DEMAND_AVL))\n+    return true;\n+\n+  avl_info avl = block_info.local_dem.get_avl_info ();\n+  unsigned int bb_index;\n+  sbitmap_iterator sbi;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (bitdata, 0, bb_index, sbi)\n+  {\n+    if (vector_exprs[bb_index]->get_avl_info () != avl)\n+      return false;\n+  }\n+  return true;\n+}\n+\n size_t\n vector_infos_manager::expr_set_num (sbitmap bitdata) const\n {\n@@ -1461,18 +1856,62 @@ vector_infos_manager::release (void)\n     vector_exprs.release ();\n \n   if (optimize > 0)\n-    {\n-      /* Finished. Free up all the things we've allocated.  */\n-      free_edge_list (vector_edge_list);\n-      sbitmap_vector_free (vector_del);\n-      sbitmap_vector_free (vector_insert);\n-      sbitmap_vector_free (vector_kill);\n-      sbitmap_vector_free (vector_antic);\n-      sbitmap_vector_free (vector_transp);\n-      sbitmap_vector_free (vector_comp);\n-      sbitmap_vector_free (vector_avin);\n-      sbitmap_vector_free (vector_avout);\n-    }\n+    free_bitmap_vectors ();\n+}\n+\n+void\n+vector_infos_manager::create_bitmap_vectors (void)\n+{\n+  /* Create the bitmap vectors.  */\n+  vector_antic = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n+\t\t\t\t       vector_exprs.length ());\n+  vector_transp = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n+\t\t\t\t\tvector_exprs.length ());\n+  vector_comp = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n+\t\t\t\t      vector_exprs.length ());\n+  vector_avin = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n+\t\t\t\t      vector_exprs.length ());\n+  vector_avout = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n+\t\t\t\t       vector_exprs.length ());\n+  vector_kill = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n+\t\t\t\t      vector_exprs.length ());\n+\n+  bitmap_vector_ones (vector_transp, last_basic_block_for_fn (cfun));\n+  bitmap_vector_clear (vector_antic, last_basic_block_for_fn (cfun));\n+  bitmap_vector_clear (vector_comp, last_basic_block_for_fn (cfun));\n+}\n+\n+void\n+vector_infos_manager::free_bitmap_vectors (void)\n+{\n+  /* Finished. Free up all the things we've allocated.  */\n+  free_edge_list (vector_edge_list);\n+  if (vector_del)\n+    sbitmap_vector_free (vector_del);\n+  if (vector_insert)\n+    sbitmap_vector_free (vector_insert);\n+  if (vector_kill)\n+    sbitmap_vector_free (vector_kill);\n+  if (vector_antic)\n+    sbitmap_vector_free (vector_antic);\n+  if (vector_transp)\n+    sbitmap_vector_free (vector_transp);\n+  if (vector_comp)\n+    sbitmap_vector_free (vector_comp);\n+  if (vector_avin)\n+    sbitmap_vector_free (vector_avin);\n+  if (vector_avout)\n+    sbitmap_vector_free (vector_avout);\n+\n+  vector_edge_list = nullptr;\n+  vector_kill = nullptr;\n+  vector_del = nullptr;\n+  vector_insert = nullptr;\n+  vector_antic = nullptr;\n+  vector_transp = nullptr;\n+  vector_comp = nullptr;\n+  vector_avin = nullptr;\n+  vector_avout = nullptr;\n }\n \n void\n@@ -1497,6 +1936,8 @@ vector_infos_manager::dump (FILE *file) const\n \t}\n       fprintf (file, \"<FOOTER>=\");\n       vector_block_infos[cfg_bb->index].reaching_out.dump (file);\n+      fprintf (file, \"<Probability>=\");\n+      vector_block_infos[cfg_bb->index].probability.dump (file);\n       fprintf (file, \"\\n\\n\");\n     }\n \n@@ -1600,13 +2041,18 @@ class pass_vsetvl : public rtl_opt_pass\n   void emit_local_forward_vsetvls (const bb_info *);\n \n   /* Phase 3.  */\n-  void merge_successors (const basic_block, const basic_block);\n-  void compute_global_backward_infos (void);\n+  enum fusion_type get_backward_fusion_type (const bb_info *,\n+\t\t\t\t\t     const vector_insn_info &);\n+  bool hard_empty_block_p (const bb_info *, const vector_insn_info &) const;\n+  bool backward_demand_fusion (void);\n+  bool forward_demand_fusion (void);\n+  bool cleanup_illegal_dirty_blocks (void);\n+  void demand_fusion (void);\n \n   /* Phase 4.  */\n   void prune_expressions (void);\n   void compute_local_properties (void);\n-  bool can_refine_vsetvl_p (const basic_block, uint8_t) const;\n+  bool can_refine_vsetvl_p (const basic_block, const vector_insn_info &) const;\n   void refine_vsetvls (void) const;\n   void cleanup_vsetvls (void);\n   bool commit_vsetvls (void);\n@@ -1615,8 +2061,12 @@ class pass_vsetvl : public rtl_opt_pass\n   /* Phase 5.  */\n   void cleanup_insns (void) const;\n \n+  /* Phase 6.  */\n+  void propagate_avl (void) const;\n+\n   void init (void);\n   void done (void);\n+  void compute_probabilities (void);\n \n public:\n   pass_vsetvl (gcc::context *ctxt) : rtl_opt_pass (pass_data_vsetvl, ctxt) {}\n@@ -1774,54 +2224,287 @@ pass_vsetvl::emit_local_forward_vsetvls (const bb_info *bb)\n   block_info.reaching_out = curr_info;\n }\n \n-/* Merge all successors of Father except child node.  */\n-void\n-pass_vsetvl::merge_successors (const basic_block father,\n-\t\t\t       const basic_block child)\n+enum fusion_type\n+pass_vsetvl::get_backward_fusion_type (const bb_info *bb,\n+\t\t\t\t       const vector_insn_info &prop)\n {\n-  edge e;\n-  edge_iterator ei;\n-  auto &father_info = m_vector_manager->vector_block_infos[father->index];\n-  gcc_assert (father_info.local_dem.dirty_p ()\n-\t      || father_info.local_dem.empty_p ());\n-  gcc_assert (father_info.reaching_out.dirty_p ()\n-\t      || father_info.reaching_out.empty_p ());\n+  insn_info *insn = prop.get_insn ();\n+\n+  /* TODO: We don't backward propagate the explict VSETVL here\n+     since we will change vsetvl and vsetvlmax intrinsics into\n+     no side effects which can be optimized into optimal location\n+     by GCC internal passes. We only need to support these backward\n+     propagation if vsetvl intrinsics have side effects.  */\n+  if (vsetvl_insn_p (insn->rtl ()))\n+    return INVALID_FUSION;\n+\n+  gcc_assert (has_vtype_op (insn->rtl ()));\n+  rtx reg = NULL_RTX;\n \n-  FOR_EACH_EDGE (e, ei, father->succs)\n+  /* Case 1: Don't need VL. Just let it backward propagate.  */\n+  if (!has_vl_op (insn->rtl ()))\n+    return VALID_AVL_FUSION;\n+  else\n     {\n-      const basic_block succ = e->dest;\n-      if (succ->index == child->index)\n-\tcontinue;\n+      /* Case 2: CONST_INT AVL, we don't need to check def.  */\n+      if (prop.has_avl_imm ())\n+\treturn VALID_AVL_FUSION;\n+      else\n+\t{\n+\t  /* Case 3: REG AVL, we need to check the distance of def to make\n+\t     sure we won't backward propagate over the def.  */\n+\t  gcc_assert (prop.has_avl_reg ());\n+\t  if (vlmax_avl_p (prop.get_avl ()))\n+\t    /* Check VL operand for vsetvl vl,zero.  */\n+\t    reg = get_vl (insn->rtl ());\n+\t  else\n+\t    /* Check AVL operand for vsetvl zero,avl.  */\n+\t    reg = get_avl (insn->rtl ());\n+\t}\n+    }\n \n-      const auto succ_info\n-\t= m_vector_manager->vector_block_infos[succ->index].local_dem;\n+  gcc_assert (reg);\n+  def_info *def = find_access (insn->uses (), REGNO (reg))->def ();\n+  if (!def->insn ()->is_phi () && def->insn ()->bb () == insn->bb ())\n+    return INVALID_FUSION;\n+  hash_set<set_info *> sets\n+    = get_all_sets (prop.get_avl_source (), true, true, true);\n+  if (any_set_in_bb_p (sets, insn->bb ()))\n+    return INVALID_FUSION;\n \n-      if (!succ_info.valid_p ())\n-\tcontinue;\n+  if (vlmax_avl_p (prop.get_avl ()))\n+    {\n+      if (find_reg_killed_by (bb, reg))\n+\treturn INVALID_FUSION;\n+      else\n+\treturn VALID_AVL_FUSION;\n+    }\n \n-      vector_insn_info new_info;\n-      if (father_info.reaching_out.dirty_p ())\n+  /* By default, we always enable backward fusion so that we can\n+     gain more optimizations.  */\n+  if (!find_reg_killed_by (bb, reg))\n+    return VALID_AVL_FUSION;\n+  return KILLED_AVL_FUSION;\n+}\n+\n+/* We almost enable all cases in get_backward_fusion_type, this function\n+   disable the backward fusion by changing dirty blocks into hard empty\n+   blocks in forward dataflow. We can have more accurate optimization by\n+   this method.  */\n+bool\n+pass_vsetvl::hard_empty_block_p (const bb_info *bb,\n+\t\t\t\t const vector_insn_info &info) const\n+{\n+  if (!info.dirty_p () || !info.has_avl_reg ())\n+    return false;\n+\n+  basic_block cfg_bb = bb->cfg_bb ();\n+  sbitmap avin = m_vector_manager->vector_avin[cfg_bb->index];\n+  rtx avl = vlmax_avl_p (info.get_avl ()) ? get_vl (info.get_insn ()->rtl ())\n+\t\t\t\t\t  : get_avl (info.get_insn ()->rtl ());\n+  insn_info *insn = info.get_insn ();\n+  set_info *set = find_access (insn->uses (), REGNO (avl))->def ();\n+  hash_set<set_info *> sets = get_all_sets (set, true, false, false);\n+  hash_set<basic_block> pred_cfg_bbs = get_all_predecessors (cfg_bb);\n+\n+  if (find_reg_killed_by (bb, avl))\n+    {\n+      /* Condition 1:\n+\t Dirty block with killed AVL means that the empty block (no RVV\n+\t instructions) are polluted as Dirty blocks with the value of current\n+\t AVL is killed. For example:\n+\t      bb 0:\n+\t\t...\n+\t      bb 1:\n+\t\tdef a5\n+\t      bb 2:\n+\t\tRVV (use a5)\n+\t In backward dataflow, we will polluted BB0 and BB1 as Dirt with AVL\n+\t killed. since a5 is killed in BB1.\n+\t In this case, let's take a look at this example:\n+\n+\t      bb 3:        bb 4:\n+\t\tdef3 a5       def4 a5\n+\t      bb 5:        bb 6:\n+\t\tdef1 a5       def2 a5\n+\t\t    \\         /\n+\t\t     \\       /\n+\t\t      \\     /\n+\t\t       \\   /\n+\t\t\tbb 7:\n+\t\t    RVV (use a5)\n+\t In thi case, we can polluted BB5 and BB6 as dirty if get-def\n+\t of a5 from RVV instruction in BB7 is the def1 in BB5 and\n+\t def2 BB6 so we can return false early here for HARD_EMPTY_BLOCK_P.\n+\t However, we are not sure whether BB3 and BB4 can be\n+\t polluted as Dirty with AVL killed so we can't return false\n+\t for HARD_EMPTY_BLOCK_P here since it's too early which will\n+\t potentially produce issues.  */\n+      gcc_assert (info.dirty_with_killed_avl_p ());\n+      if (info.get_avl_source ()\n+\t  && get_same_bb_set (sets, bb->cfg_bb ()) == info.get_avl_source ())\n+\treturn false;\n+    }\n+\n+  /* Condition 2:\n+     Suppress the VL/VTYPE info backward propagation too early:\n+\t\t\t ________\n+\t\t\t|   BB0  |\n+\t\t\t|________|\n+\t\t\t    |\n+\t\t\t____|____\n+\t\t\t|   BB1  |\n+\t\t\t|________|\n+     In this case, suppose BB 1 has multiple predecessors, BB 0 is one\n+     of them. BB1 has VL/VTYPE info (may be VALID or DIRTY) to backward\n+     propagate.\n+     The AVIN (available in) which is calculated by LCM is empty only\n+     in these 2 circumstances:\n+       1. all predecessors of BB1 are empty (not VALID\n+\t  and can not be polluted in backward fusion flow)\n+       2. VL/VTYPE info of BB1 predecessors are conflict.\n+\n+     We keep it as dirty in 2nd circumstance and set it as HARD_EMPTY\n+     (can not be polluted as DIRTY any more) in 1st circumstance.\n+     We don't backward propagate in 1st circumstance since there is\n+     no VALID RVV instruction and no polluted blocks (dirty blocks)\n+     by backward propagation from other following blocks.\n+     It's meaningless to keep it as Dirty anymore.\n+\n+     However, since we keep it as dirty in 2nd since there are VALID or\n+     Dirty blocks in predecessors, we can still gain the benefits and\n+     optimization opportunities. For example, in this case:\n+\tfor (size_t i = 0; i < n; i++)\n+\t {\n+\t   if (i != cond) {\n+\t     vint8mf8_t v = *(vint8mf8_t*)(in + i + 100);\n+\t     *(vint8mf8_t*)(out + i + 100) = v;\n+\t   } else {\n+\t     vbool1_t v = *(vbool1_t*)(in + i + 400);\n+\t     *(vbool1_t*)(out + i + 400) = v;\n+\t   }\n+\t }\n+     VL/VTYPE in if-else are conflict which will produce empty AVIN LCM result\n+     but we can still keep dirty blocks if *(i != cond)* is very unlikely then\n+     we can preset vsetvl (VL/VTYPE) info from else (static propability model).\n+\n+     We don't want to backward propagate VL/VTYPE information too early\n+     which is not the optimal and may potentially produce issues.  */\n+  if (bitmap_empty_p (avin))\n+    {\n+      bool hard_empty_p = true;\n+      for (const basic_block pred_cfg_bb : pred_cfg_bbs)\n \t{\n-\t  if (!father_info.reaching_out.compatible_p (succ_info))\n+\t  if (pred_cfg_bb == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \t    continue;\n-\n-\t  new_info = succ_info.merge (father_info.reaching_out, true);\n+\t  sbitmap avout = m_vector_manager->vector_avout[pred_cfg_bb->index];\n+\t  if (!bitmap_empty_p (avout))\n+\t    {\n+\t      hard_empty_p = false;\n+\t      break;\n+\t    }\n \t}\n-      else\n-\tnew_info = succ_info;\n+      if (hard_empty_p)\n+\treturn true;\n+    }\n \n-      new_info.set_dirty ();\n-      rtx new_pat = gen_vsetvl_pat (new_info.get_insn ()->rtl (), new_info);\n-      new_info.set_dirty_pat (new_pat);\n+  edge e;\n+  edge_iterator ei;\n+  bool has_avl_killed_insn_p = false;\n+  FOR_EACH_EDGE (e, ei, cfg_bb->succs)\n+    {\n+      const auto block_info\n+\t= m_vector_manager->vector_block_infos[e->dest->index];\n+      if (block_info.local_dem.dirty_with_killed_avl_p ())\n+\t{\n+\t  has_avl_killed_insn_p = true;\n+\t  break;\n+\t}\n+    }\n+  if (!has_avl_killed_insn_p)\n+    return false;\n \n-      father_info.local_dem = new_info;\n-      father_info.reaching_out = new_info;\n+  bool any_set_in_bbs_p = false;\n+  for (const basic_block pred_cfg_bb : pred_cfg_bbs)\n+    {\n+      insn_info *def_insn = extract_single_source (set);\n+      if (def_insn)\n+\t{\n+\t  /* Condition 3:\n+\n+\t    Case 1:                               Case 2:\n+\t\tbb 0:                                 bb 0:\n+\t\t  def a5 101                             ...\n+\t\tbb 1:                                 bb 1:\n+\t\t  ...                                    ...\n+\t\tbb 2:                                 bb 2:\n+\t\t  RVV 1 (use a5 with TAIL ANY)           ...\n+\t\tbb 3:                                 bb 3:\n+\t\t  def a5 101                             def a5 101\n+\t\tbb 4:                                 bb 4:\n+\t\t  ...                                    ...\n+\t\tbb 5:                                 bb 5:\n+\t\t  RVV 2 (use a5 with TU)                 RVV 1 (use a5)\n+\n+\t    Case 1: We can pollute BB3,BB2,BB1,BB0 are all Dirt blocks\n+\t    with killed AVL so that we can merge TU demand info from RVV 2\n+\t    into RVV 1 and elide the vsevl instruction in BB5.\n+\n+\t    TODO: We only optimize for single source def since multiple source\n+\t    def is quite complicated.\n+\n+\t    Case 2: We only can pollute bb 3 as dirty and it has been accepted\n+\t    in Condition 2 and we can't pollute BB3,BB2,BB1,BB0 like case 1. */\n+\t  insn_info *last_killed_insn\n+\t    = find_reg_killed_by (crtl->ssa->bb (pred_cfg_bb), avl);\n+\t  if (!last_killed_insn || pred_cfg_bb == def_insn->bb ()->cfg_bb ())\n+\t    continue;\n+\t  if (source_equal_p (last_killed_insn, def_insn))\n+\t    {\n+\t      any_set_in_bbs_p = true;\n+\t      break;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Condition 4:\n+\n+\t      bb 0:        bb 1:         bb 3:\n+\t\tdef1 a5       def2 a5     ...\n+\t\t    \\         /            /\n+\t\t     \\       /            /\n+\t\t      \\     /            /\n+\t\t       \\   /            /\n+\t\t\tbb 4:          /\n+\t\t\t |            /\n+\t\t\t |           /\n+\t\t\tbb 5:       /\n+\t\t\t |         /\n+\t\t\t |        /\n+\t\t\tbb 6:    /\n+\t\t\t |      /\n+\t\t\t |     /\n+\t\t\t  bb 8:\n+\t\t\tRVV 1 (use a5)\n+\t  If we get-def (REAL) of a5 from RVV 1 instruction, we will get\n+\t  def1 from BB0 and def2 from BB1. So we will pollute BB6,BB5,BB4,\n+\t  BB0,BB1 with DIRTY and set BB3 as HARD_EMPTY so that we won't\n+\t  propagate AVL to BB3.  */\n+\t  if (any_set_in_bb_p (sets, crtl->ssa->bb (pred_cfg_bb)))\n+\t    {\n+\t      any_set_in_bbs_p = true;\n+\t      break;\n+\t    }\n+\t}\n     }\n+  if (!any_set_in_bbs_p)\n+    return true;\n+  return false;\n }\n \n /* Compute global backward demanded info.  */\n-void\n-pass_vsetvl::compute_global_backward_infos (void)\n+bool\n+pass_vsetvl::backward_demand_fusion (void)\n {\n   /* We compute global infos by backward propagation.\n      We want to have better performance in these following cases:\n@@ -1848,26 +2531,26 @@ pass_vsetvl::compute_global_backward_infos (void)\n \t   We backward propagate the first VSETVL into e32,mf2 so that we\n \t   could be able to eliminate the second VSETVL in LCM.  */\n \n+  bool changed_p = false;\n   for (const bb_info *bb : crtl->ssa->reverse_bbs ())\n     {\n       basic_block cfg_bb = bb->cfg_bb ();\n-      const auto &prop\n-\t= m_vector_manager->vector_block_infos[cfg_bb->index].local_dem;\n+      const auto &curr_block_info\n+\t= m_vector_manager->vector_block_infos[cfg_bb->index];\n+      const auto &prop = curr_block_info.local_dem;\n \n       /* If there is nothing to propagate, just skip it.  */\n       if (!prop.valid_or_dirty_p ())\n \tcontinue;\n \n-      if (!backward_propagate_worthwhile_p (\n-\t    cfg_bb, m_vector_manager->vector_block_infos[cfg_bb->index]))\n+      if (!backward_propagate_worthwhile_p (cfg_bb, curr_block_info))\n \tcontinue;\n \n       edge e;\n       edge_iterator ei;\n       /* Backward propagate to each predecessor.  */\n       FOR_EACH_EDGE (e, ei, cfg_bb->preds)\n \t{\n-\t  rtx new_pat;\n \t  auto &block_info\n \t    = m_vector_manager->vector_block_infos[e->src->index];\n \n@@ -1879,22 +2562,31 @@ pass_vsetvl::compute_global_backward_infos (void)\n \n \t  if (block_info.reaching_out.unknown_p ())\n \t    continue;\n+\t  else if (block_info.reaching_out.hard_empty_p ())\n+\t    continue;\n \t  else if (block_info.reaching_out.empty_p ())\n \t    {\n-\t      if (!can_backward_propagate_p (crtl->ssa, e->src, prop))\n+\t      enum fusion_type type\n+\t\t= get_backward_fusion_type (crtl->ssa->bb (e->src), prop);\n+\t      if (type == INVALID_FUSION)\n \t\tcontinue;\n \n-\t      if (dominate_probability_p (e))\n-\t\t{\n-\t\t  rtx new_pat = gen_vsetvl_pat (prop.get_insn ()->rtl (), prop);\n+\t      block_info.reaching_out = prop;\n+\t      block_info.reaching_out.set_dirty (type);\n \n-\t\t  block_info.reaching_out = prop;\n-\t\t  block_info.reaching_out.set_dirty ();\n-\t\t  block_info.reaching_out.set_dirty_pat (new_pat);\n-\t\t  block_info.local_dem = block_info.reaching_out;\n+\t      if (prop.has_avl_reg () && !vlmax_avl_p (prop.get_avl ()))\n+\t\t{\n+\t\t  hash_set<set_info *> sets\n+\t\t    = get_all_sets (prop.get_avl_source (), true, true, true);\n+\t\t  set_info *set = get_same_bb_set (sets, e->src);\n+\t\t  if (set)\n+\t\t    block_info.reaching_out.set_avl_info (\n+\t\t      avl_info (prop.get_avl (), set));\n \t\t}\n \n-\t      merge_successors (e->src, cfg_bb);\n+\t      block_info.local_dem = block_info.reaching_out;\n+\t      block_info.probability = curr_block_info.probability;\n+\t      changed_p = true;\n \t    }\n \t  else if (block_info.reaching_out.dirty_p ())\n \t    {\n@@ -1905,59 +2597,228 @@ pass_vsetvl::compute_global_backward_infos (void)\n \t\t{\n \t\t  if (block_info.reaching_out >= prop)\n \t\t    continue;\n-\t\t  new_info = block_info.reaching_out.merge (prop, true);\n+\t\t  new_info = block_info.reaching_out.merge (prop, GLOBAL_MERGE);\n+\t\t  new_info.set_dirty (\n+\t\t    block_info.reaching_out.dirty_with_killed_avl_p ());\n+\t\t  block_info.probability += curr_block_info.probability;\n \t\t}\n \t      else\n \t\t{\n-\t\t  if (dominate_probability_p (e))\n-\t\t    new_info = prop;\n+\t\t  if (curr_block_info.probability > block_info.probability)\n+\t\t    {\n+\t\t      enum fusion_type type\n+\t\t\t= get_backward_fusion_type (crtl->ssa->bb (e->src),\n+\t\t\t\t\t\t    prop);\n+\t\t      if (type == INVALID_FUSION)\n+\t\t\tcontinue;\n+\t\t      new_info = prop;\n+\t\t      new_info.set_dirty (type);\n+\t\t      block_info.probability = curr_block_info.probability;\n+\t\t    }\n \t\t  else\n \t\t    continue;\n \t\t}\n \n-\t      rtx new_pat\n-\t\t= gen_vsetvl_pat (new_info.get_insn ()->rtl (), new_info);\n-\t      new_info.set_dirty ();\n-\t      new_info.set_dirty_pat (new_pat);\n \t      block_info.local_dem = new_info;\n \t      block_info.reaching_out = new_info;\n+\t      changed_p = true;\n \t    }\n \t  else\n \t    {\n \t      /* We not only change the info during backward propagation,\n \t\t but also change the VSETVL instruction.  */\n \t      gcc_assert (block_info.reaching_out.valid_p ());\n-\t      if (!block_info.reaching_out.compatible_p (prop))\n-\t\tcontinue;\n-\t      if (block_info.reaching_out >= prop)\n-\t\tcontinue;\n-\n-\t      vector_insn_info be_merged = block_info.reaching_out;\n-\t      if (block_info.local_dem == block_info.reaching_out)\n-\t\tbe_merged = block_info.local_dem;\n-\t      vector_insn_info new_info = be_merged.merge (prop, true);\n-\n-\t      rtx_insn *rinsn;\n-\t      if (vector_config_insn_p (new_info.get_insn ()->rtl ()))\n+\t      hash_set<set_info *> sets\n+\t\t= get_all_sets (prop.get_avl_source (), true, false, false);\n+\t      set_info *set = get_same_bb_set (sets, e->src);\n+\t      if (vsetvl_insn_p (block_info.reaching_out.get_insn ()->rtl ())\n+\t\t  && prop.has_avl_reg () && !vlmax_avl_p (prop.get_avl ()))\n \t\t{\n-\t\t  rinsn = new_info.get_insn ()->rtl ();\n-\t\t  gcc_assert (vsetvl_insn_p (rinsn)\n-\t\t\t      && \"Can't handle X0, rs1 vsetvli yet\");\n+\t\t  if (!block_info.reaching_out.same_vlmax_p (prop))\n+\t\t    continue;\n+\t\t  if (block_info.reaching_out.same_vtype_p (prop))\n+\t\t    continue;\n+\t\t  if (!set)\n+\t\t    continue;\n+\t\t  if (set->insn () != block_info.reaching_out.get_insn ())\n+\t\t    continue;\n \t\t}\n \t      else\n \t\t{\n-\t\t  gcc_assert (has_vtype_op (new_info.get_insn ()->rtl ()));\n-\t\t  rinsn = PREV_INSN (new_info.get_insn ()->rtl ());\n-\t\t  gcc_assert (vector_config_insn_p (rinsn));\n+\t\t  if (!block_info.reaching_out.compatible_p (prop))\n+\t\t    continue;\n+\t\t  if (block_info.reaching_out >= prop)\n+\t\t    continue;\n \t\t}\n-\t      new_pat = gen_vsetvl_pat (rinsn, new_info);\n-\t      change_insn (rinsn, new_pat);\n+\n+\t      vector_insn_info be_merged = block_info.reaching_out;\n+\t      if (block_info.local_dem == block_info.reaching_out)\n+\t\tbe_merged = block_info.local_dem;\n+\t      vector_insn_info new_info = be_merged.merge (prop, GLOBAL_MERGE);\n+\n+\t      if (curr_block_info.probability > block_info.probability)\n+\t\tblock_info.probability = curr_block_info.probability;\n+\n+\t      change_vsetvl_insn (new_info.get_insn (), new_info);\n \t      if (block_info.local_dem == block_info.reaching_out)\n \t\tblock_info.local_dem = new_info;\n \t      block_info.reaching_out = new_info;\n+\t      changed_p = true;\n+\t    }\n+\t}\n+    }\n+  return changed_p;\n+}\n+\n+/* Compute global forward demanded info.  */\n+bool\n+pass_vsetvl::forward_demand_fusion (void)\n+{\n+  /* Enhance the global information propagation especially\n+     backward propagation miss the propagation.\n+     Consider such case:\n+\n+\t\t\tbb0\n+\t\t\t(TU)\n+\t\t       /   \\\n+\t\t     bb1   bb2\n+\t\t     (TU)  (ANY)\n+  existing edge -----> \\    / (TU) <----- LCM create this edge.\n+\t\t\tbb3\n+\t\t\t(TU)\n+\n+     Base on the situation, LCM fails to eliminate the VSETVL instruction and\n+     insert an edge from bb2 to bb3 since we can't backward propagate bb3 into\n+     bb2. To avoid this confusing LCM result and non-optimal codegen, we should\n+     forward propagate information from bb0 to bb2 which is friendly to LCM.  */\n+  bool changed_p = false;\n+  for (const bb_info *bb : crtl->ssa->bbs ())\n+    {\n+      basic_block cfg_bb = bb->cfg_bb ();\n+      const auto &prop\n+\t= m_vector_manager->vector_block_infos[cfg_bb->index].reaching_out;\n+\n+      /* If there is nothing to propagate, just skip it.  */\n+      if (!prop.valid_or_dirty_p ())\n+\tcontinue;\n+\n+      if (cfg_bb == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n+\tcontinue;\n+\n+      edge e;\n+      edge_iterator ei;\n+      /* Forward propagate to each successor.  */\n+      FOR_EACH_EDGE (e, ei, cfg_bb->succs)\n+\t{\n+\t  auto &local_dem\n+\t    = m_vector_manager->vector_block_infos[e->dest->index].local_dem;\n+\t  auto &reaching_out\n+\t    = m_vector_manager->vector_block_infos[e->dest->index].reaching_out;\n+\n+\t  /* It's quite obvious, we don't need to propagate itself.  */\n+\t  if (e->dest->index == cfg_bb->index)\n+\t    continue;\n+\t  /* We don't propagate through critical edges.  */\n+\t  if (e->flags & EDGE_COMPLEX)\n+\t    continue;\n+\t  if (e->dest->index == EXIT_BLOCK_PTR_FOR_FN (cfun)->index)\n+\t    continue;\n+\n+\t  /* If there is nothing to propagate, just skip it.  */\n+\t  if (!local_dem.valid_or_dirty_p ())\n+\t    continue;\n+\t  if (local_dem >= prop)\n+\t    continue;\n+\t  if (!local_dem.compatible_p (prop))\n+\t    continue;\n+\n+\t  vector_insn_info new_info = local_dem.merge (prop, GLOBAL_MERGE);\n+\t  new_info.set_insn (local_dem.get_insn ());\n+\t  if (local_dem.dirty_p ())\n+\t    {\n+\t      gcc_assert (local_dem == reaching_out);\n+\t      new_info.set_dirty (local_dem.dirty_with_killed_avl_p ());\n+\t      local_dem = new_info;\n+\t      reaching_out = local_dem;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (reaching_out == local_dem)\n+\t\treaching_out = new_info;\n+\t      local_dem = new_info;\n+\t      change_vsetvl_insn (local_dem.get_insn (), new_info);\n \t    }\n+\t  auto &prob\n+\t    = m_vector_manager->vector_block_infos[e->dest->index].probability;\n+\t  auto &curr_prob\n+\t    = m_vector_manager->vector_block_infos[cfg_bb->index].probability;\n+\t  prob = curr_prob * e->probability;\n+\t  changed_p = true;\n \t}\n     }\n+  return changed_p;\n+}\n+\n+void\n+pass_vsetvl::demand_fusion (void)\n+{\n+  bool changed_p = true;\n+  while (changed_p)\n+    {\n+      changed_p = false;\n+      /* To optimize the case like this:\n+\t void f2 (int8_t * restrict in, int8_t * restrict out, int n, int cond)\n+\t   {\n+\t     size_t vl = 101;\n+\n+\t     for (size_t i = 0; i < n; i++)\n+\t       {\n+\t\t vint8mf8_t v = __riscv_vle8_v_i8mf8 (in + i + 300, vl);\n+\t\t __riscv_vse8_v_i8mf8 (out + i + 300, v, vl);\n+\t       }\n+\n+\t     for (size_t i = 0; i < n; i++)\n+\t       {\n+\t\t vint8mf8_t v = __riscv_vle8_v_i8mf8 (in + i, vl);\n+\t\t __riscv_vse8_v_i8mf8 (out + i, v, vl);\n+\n+\t\t vint8mf8_t v2 = __riscv_vle8_v_i8mf8_tu (v, in + i + 100, vl);\n+\t\t __riscv_vse8_v_i8mf8 (out + i + 100, v2, vl);\n+\t       }\n+\t   }\n+\n+\t  bb 0: li a5, 101 (killed avl)\n+\t  ...\n+\t  bb 1: vsetvli zero, a5, ta\n+\t  ...\n+\t  bb 2: li a5, 101 (killed avl)\n+\t  ...\n+\t  bb 3: vsetvli zero, a3, tu\n+\n+\tWe want to fuse VSEVLI instructions on bb 1 and bb 3. However, there is\n+\tan AVL kill instruction in bb 2 that we can't backward fuse bb 3 or\n+\tforward bb 1 arbitrarily. We need available information of each block to\n+\thelp for such cases.  */\n+      changed_p |= backward_demand_fusion ();\n+      changed_p |= forward_demand_fusion ();\n+    }\n+\n+  changed_p = true;\n+  while (changed_p)\n+    {\n+      changed_p = false;\n+      prune_expressions ();\n+      m_vector_manager->create_bitmap_vectors ();\n+      compute_local_properties ();\n+      compute_available (m_vector_manager->vector_comp,\n+\t\t\t m_vector_manager->vector_kill,\n+\t\t\t m_vector_manager->vector_avout,\n+\t\t\t m_vector_manager->vector_avin);\n+      changed_p |= cleanup_illegal_dirty_blocks ();\n+      m_vector_manager->free_bitmap_vectors ();\n+      if (!m_vector_manager->vector_exprs.is_empty ())\n+\tm_vector_manager->vector_exprs.release ();\n+    }\n \n   if (dump_file)\n     {\n@@ -1970,6 +2831,34 @@ pass_vsetvl::compute_global_backward_infos (void)\n     }\n }\n \n+/* Cleanup illegal dirty blocks.  */\n+bool\n+pass_vsetvl::cleanup_illegal_dirty_blocks (void)\n+{\n+  bool changed_p = false;\n+  for (const bb_info *bb : crtl->ssa->bbs ())\n+    {\n+      basic_block cfg_bb = bb->cfg_bb ();\n+      const auto &prop\n+\t= m_vector_manager->vector_block_infos[cfg_bb->index].reaching_out;\n+\n+      /* If there is nothing to cleanup, just skip it.  */\n+      if (!prop.valid_or_dirty_p ())\n+\tcontinue;\n+\n+      if (hard_empty_block_p (bb, prop))\n+\t{\n+\t  m_vector_manager->vector_block_infos[cfg_bb->index].local_dem\n+\t    = vector_insn_info::get_hard_empty ();\n+\t  m_vector_manager->vector_block_infos[cfg_bb->index].reaching_out\n+\t    = vector_insn_info::get_hard_empty ();\n+\t  changed_p = true;\n+\t  continue;\n+\t}\n+    }\n+  return changed_p;\n+}\n+\n /* Assemble the candidates expressions for LCM.  */\n void\n pass_vsetvl::prune_expressions (void)\n@@ -2000,6 +2889,21 @@ pass_vsetvl::prune_expressions (void)\n     }\n }\n \n+/* Compute the local properties of each recorded expression.\n+\n+   Local properties are those that are defined by the block, irrespective of\n+   other blocks.\n+\n+   An expression is transparent in a block if its operands are not modified\n+   in the block.\n+\n+   An expression is computed (locally available) in a block if it is computed\n+   at least once and expression would contain the same value if the\n+   computation was moved to the end of the block.\n+\n+   An expression is locally anticipatable in a block if it is computed at\n+   least once and expression would contain the same value if the computation\n+   was moved to the beginning of the block.  */\n void\n pass_vsetvl::compute_local_properties (void)\n {\n@@ -2022,41 +2926,87 @@ pass_vsetvl::compute_local_properties (void)\n \tthe block and the occurrence.  */\n \n   basic_block cfg_bb;\n-  FOR_EACH_BB_FN (cfg_bb, cfun)\n+  for (const bb_info *bb : crtl->ssa->bbs ())\n     {\n-      int curr_bb_idx = cfg_bb->index;\n+      unsigned int curr_bb_idx = bb->index ();\n       const auto local_dem\n \t= m_vector_manager->vector_block_infos[curr_bb_idx].local_dem;\n       const auto reaching_out\n \t= m_vector_manager->vector_block_infos[curr_bb_idx].reaching_out;\n \n-      if (!local_dem.empty_p ())\n+      /* Compute transparent.  */\n+      for (size_t i = 0; i < m_vector_manager->vector_exprs.length (); i++)\n \t{\n-\t  for (size_t i = 0; i < m_vector_manager->vector_exprs.length (); i++)\n+\t  const vector_insn_info *expr = m_vector_manager->vector_exprs[i];\n+\t  if (local_dem.real_dirty_p () || local_dem.valid_p ()\n+\t      || local_dem.unknown_p ()\n+\t      || has_vsetvl_killed_avl_p (bb, local_dem))\n \t    bitmap_clear_bit (m_vector_manager->vector_transp[curr_bb_idx], i);\n+\t  /* FIXME: Here we set the block as non-transparent (killed) if there\n+\t     is an instruction killed the value of AVL according to the\n+\t     definition of Local transparent. This is true for such following\n+\t     case:\n+\n+\t\tbb 0 (Loop label):\n+\t\t  vsetvl zero, a5, e8, mf8\n+\t\tbb 1:\n+\t\t  def a5\n+\t\tbb 2:\n+\t\t  branch bb 0 (Loop label).\n+\n+\t     In this case, we known there is a loop bb 0->bb 1->bb 2. According\n+\t     to LCM definition, it is correct when we set vsetvl zero, a5, e8,\n+\t     mf8 as non-transparent (killed) so that LCM will not hoist outside\n+\t     the bb 0.\n+\n+\t     However, such conservative configuration will forbid optimization\n+\t     on some unlucky case. For example:\n+\n+\t\tbb 0:\n+\t\t  li a5, 101\n+\t\tbb 1:\n+\t\t  vsetvl zero, a5, e8, mf8\n+\t\tbb 2:\n+\t\t  li a5, 101\n+\t\tbb 3:\n+\t\t  vsetvl zero, a5, e8, mf8.\n+\t     So we also relax def a5 as transparent to gain more optimizations\n+\t     as long as the all real def insn of avl do not come from this\n+\t     block. This configuration may be still missing some optimization\n+\t     opportunities.  */\n+\t  if (find_reg_killed_by (bb, expr->get_avl ()))\n+\t    {\n+\t      hash_set<set_info *> sets\n+\t\t= get_all_sets (expr->get_avl_source (), true, false, false);\n+\t      if (any_set_in_bb_p (sets, bb))\n+\t\tbitmap_clear_bit (m_vector_manager->vector_transp[curr_bb_idx],\n+\t\t\t\t  i);\n+\t    }\n \t}\n \n-      if (local_dem.valid_or_dirty_p ())\n-\t{\n-\t  const insn_info *header_insn = local_dem.get_insn ();\n-\t  size_t header_index = m_vector_manager->get_expr_id (local_dem);\n-\t  if (anticipatable_occurrence_p (header_insn, local_dem))\n-\t    bitmap_set_bit (m_vector_manager->vector_antic[curr_bb_idx],\n-\t\t\t    header_index);\n-\t}\n+      /* Compute anticipatable occurrences.  */\n+      if (local_dem.valid_p () || local_dem.real_dirty_p ()\n+\t  || (has_vsetvl_killed_avl_p (bb, local_dem)\n+\t      && vlmax_avl_p (local_dem.get_avl ())))\n+\tif (anticipatable_occurrence_p (bb, local_dem))\n+\t  bitmap_set_bit (m_vector_manager->vector_antic[curr_bb_idx],\n+\t\t\t  m_vector_manager->get_expr_id (local_dem));\n \n+      /* Compute available occurrences.  */\n       if (reaching_out.valid_or_dirty_p ())\n \t{\n-\t  const insn_info *footer_insn = reaching_out.get_insn ();\n-\t  size_t footer_index = m_vector_manager->get_expr_id (reaching_out);\n-\t  if (available_occurrence_p (footer_insn, reaching_out))\n-\t    bitmap_set_bit (m_vector_manager->vector_comp[curr_bb_idx],\n-\t\t\t    footer_index);\n \t  auto_vec<size_t> available_list\n \t    = m_vector_manager->get_all_available_exprs (reaching_out);\n \t  for (size_t i = 0; i < available_list.length (); i++)\n-\t    bitmap_set_bit (m_vector_manager->vector_comp[curr_bb_idx],\n-\t\t\t    available_list[i]);\n+\t    {\n+\t      const vector_insn_info *expr\n+\t\t= m_vector_manager->vector_exprs[available_list[i]];\n+\t      if (reaching_out.real_dirty_p ()\n+\t\t  || has_vsetvl_killed_avl_p (bb, reaching_out)\n+\t\t  || available_occurrence_p (bb, *expr))\n+\t\tbitmap_set_bit (m_vector_manager->vector_comp[curr_bb_idx],\n+\t\t\t\tavailable_list[i]);\n+\t    }\n \t}\n     }\n \n@@ -2105,15 +3055,22 @@ pass_vsetvl::compute_local_properties (void)\n \n /* Return true if VSETVL in the block can be refined as vsetvl zero,zero.  */\n bool\n-pass_vsetvl::can_refine_vsetvl_p (const basic_block cfg_bb, uint8_t ratio) const\n+pass_vsetvl::can_refine_vsetvl_p (const basic_block cfg_bb,\n+\t\t\t\t  const vector_insn_info &info) const\n {\n   if (!m_vector_manager->all_same_ratio_p (\n \tm_vector_manager->vector_avin[cfg_bb->index]))\n     return false;\n \n+  if (!m_vector_manager->all_same_avl_p (\n+\tcfg_bb, m_vector_manager->vector_avin[cfg_bb->index]))\n+    return false;\n+\n   size_t expr_id\n     = bitmap_first_set_bit (m_vector_manager->vector_avin[cfg_bb->index]);\n-  if (m_vector_manager->vector_exprs[expr_id]->get_ratio () != ratio)\n+  if (!m_vector_manager->vector_exprs[expr_id]->same_vlmax_p (info))\n+    return false;\n+  if (!m_vector_manager->vector_exprs[expr_id]->compatible_avl_p (info))\n     return false;\n \n   edge e;\n@@ -2156,7 +3113,7 @@ pass_vsetvl::refine_vsetvls (void) const\n \tcontinue;\n \n       rtx_insn *rinsn = insn->rtl ();\n-      if (!can_refine_vsetvl_p (cfg_bb, info.get_ratio ()))\n+      if (!can_refine_vsetvl_p (cfg_bb, info))\n \tcontinue;\n \n       if (!vector_config_insn_p (rinsn))\n@@ -2185,8 +3142,11 @@ pass_vsetvl::cleanup_vsetvls ()\n \t\tinfo.set_unknown ();\n \t      else\n \t\t{\n-\t\t  insn_info *insn\n-\t\t    = m_vector_manager->vector_exprs[i]->get_insn ();\n+\t\t  const auto dem\n+\t\t    = m_vector_manager->vector_block_infos[cfg_bb->index]\n+\t\t\t.local_dem;\n+\t\t  gcc_assert (dem == *m_vector_manager->vector_exprs[i]);\n+\t\t  insn_info *insn = dem.get_insn ();\n \t\t  gcc_assert (insn && insn->rtl ());\n \t\t  rtx_insn *rinsn;\n \t\t  if (vector_config_insn_p (insn->rtl ()))\n@@ -2225,11 +3185,11 @@ pass_vsetvl::commit_vsetvls (void)\n \n \t      insn_info *insn = require->get_insn ();\n \t      vector_insn_info prev_info = vector_insn_info ();\n-\t      if (m_vector_manager->all_same_ratio_p (\n-\t\t    m_vector_manager->vector_avout[eg->src->index]))\n+\t      sbitmap bitdata = m_vector_manager->vector_avout[eg->src->index];\n+\t      if (m_vector_manager->all_same_ratio_p (bitdata)\n+\t\t  && m_vector_manager->all_same_avl_p (eg->dest, bitdata))\n \t\t{\n-\t\t  size_t first = bitmap_first_set_bit (\n-\t\t    m_vector_manager->vector_avout[eg->src->index]);\n+\t\t  size_t first = bitmap_first_set_bit (bitdata);\n \t\t  prev_info = *m_vector_manager->vector_exprs[first];\n \t\t}\n \n@@ -2246,18 +3206,45 @@ pass_vsetvl::commit_vsetvls (void)\n \t}\n     }\n \n-  basic_block cfg_bb;\n-  FOR_EACH_BB_FN (cfg_bb, cfun)\n+  for (const bb_info *bb : crtl->ssa->bbs ())\n     {\n+      basic_block cfg_bb = bb->cfg_bb ();\n       const auto reaching_out\n \t= m_vector_manager->vector_block_infos[cfg_bb->index].reaching_out;\n       if (!reaching_out.dirty_p ())\n \tcontinue;\n \n-      rtx new_pat = reaching_out.get_dirty_pat ();\n-      if (can_refine_vsetvl_p (cfg_bb, reaching_out.get_ratio ()))\n+      if (reaching_out.dirty_with_killed_avl_p ())\n+\t{\n+\t  if (!has_vsetvl_killed_avl_p (bb, reaching_out))\n+\t    continue;\n+\n+\t  unsigned int bb_index;\n+\t  sbitmap_iterator sbi;\n+\t  sbitmap avin = m_vector_manager->vector_avin[cfg_bb->index];\n+\t  bool available_p = false;\n+\t  EXECUTE_IF_SET_IN_BITMAP (avin, 0, bb_index, sbi)\n+\t  {\n+\t    if (*m_vector_manager->vector_exprs[bb_index] >= reaching_out)\n+\t      {\n+\t\tavailable_p = true;\n+\t\tbreak;\n+\t      }\n+\t  }\n+\t  if (available_p)\n+\t    continue;\n+\t}\n+\n+      rtx new_pat;\n+      if (can_refine_vsetvl_p (cfg_bb, reaching_out))\n \tnew_pat\n \t  = gen_vsetvl_pat (VSETVL_VTYPE_CHANGE_ONLY, reaching_out, NULL_RTX);\n+      else if (vlmax_avl_p (reaching_out.get_avl ()))\n+\tnew_pat = gen_vsetvl_pat (VSETVL_NORMAL, reaching_out,\n+\t\t\t\t  get_vl (reaching_out.get_insn ()->rtl ()));\n+      else\n+\tnew_pat\n+\t  = gen_vsetvl_pat (VSETVL_DISCARD_RESULT, reaching_out, NULL_RTX);\n \n       start_sequence ();\n       emit_insn (new_pat);\n@@ -2282,32 +3269,7 @@ pass_vsetvl::pre_vsetvl (void)\n   /* Compute entity list.  */\n   prune_expressions ();\n \n-  /* Create the bitmap vectors.  */\n-  m_vector_manager->vector_antic\n-    = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n-\t\t\t    m_vector_manager->vector_exprs.length ());\n-  m_vector_manager->vector_transp\n-    = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n-\t\t\t    m_vector_manager->vector_exprs.length ());\n-  m_vector_manager->vector_comp\n-    = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n-\t\t\t    m_vector_manager->vector_exprs.length ());\n-  m_vector_manager->vector_avin\n-    = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n-\t\t\t    m_vector_manager->vector_exprs.length ());\n-  m_vector_manager->vector_avout\n-    = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n-\t\t\t    m_vector_manager->vector_exprs.length ());\n-  m_vector_manager->vector_kill\n-    = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n-\t\t\t    m_vector_manager->vector_exprs.length ());\n-\n-  bitmap_vector_ones (m_vector_manager->vector_transp,\n-\t\t      last_basic_block_for_fn (cfun));\n-  bitmap_vector_clear (m_vector_manager->vector_antic,\n-\t\t       last_basic_block_for_fn (cfun));\n-  bitmap_vector_clear (m_vector_manager->vector_comp,\n-\t\t       last_basic_block_for_fn (cfun));\n+  m_vector_manager->create_bitmap_vectors ();\n   compute_local_properties ();\n   m_vector_manager->vector_edge_list = pre_edge_lcm_avs (\n     m_vector_manager->vector_exprs.length (), m_vector_manager->vector_transp,\n@@ -2368,6 +3330,115 @@ pass_vsetvl::cleanup_insns (void) const\n     }\n }\n \n+void\n+pass_vsetvl::propagate_avl (void) const\n+{\n+  /* Rebuild the RTL_SSA according to the new CFG generated by LCM.  */\n+  /* Finalization of RTL_SSA.  */\n+  free_dominance_info (CDI_DOMINATORS);\n+  if (crtl->ssa->perform_pending_updates ())\n+    cleanup_cfg (0);\n+  delete crtl->ssa;\n+  crtl->ssa = nullptr;\n+  /* Initialization of RTL_SSA.  */\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  df_analyze ();\n+  crtl->ssa = new function_info (cfun);\n+\n+  hash_set<rtx_insn *> to_delete;\n+  for (const bb_info *bb : crtl->ssa->bbs ())\n+    {\n+      for (insn_info *insn : bb->real_nondebug_insns ())\n+\t{\n+\t  if (vsetvl_discard_result_insn_p (insn->rtl ()))\n+\t    {\n+\t      rtx avl = get_avl (insn->rtl ());\n+\t      if (!REG_P (avl))\n+\t\tcontinue;\n+\n+\t      set_info *set = find_access (insn->uses (), REGNO (avl))->def ();\n+\t      insn_info *def_insn = extract_single_source (set);\n+\t      if (!def_insn)\n+\t\tcontinue;\n+\n+\t      /* Handle this case:\n+\t\t vsetvli\ta6,zero,e32,m1,ta,mu\n+\t\t li\ta5,4096\n+\t\t add\ta7,a0,a5\n+\t\t addi\ta7,a7,-96\n+\t\t vsetvli\tt1,zero,e8,mf8,ta,ma\n+\t\t vle8.v\tv24,0(a7)\n+\t\t add\ta5,a3,a5\n+\t\t addi\ta5,a5,-96\n+\t\t vse8.v\tv24,0(a5)\n+\t\t vsetvli\tzero,a6,e32,m1,tu,ma\n+\t      */\n+\t      if (vsetvl_insn_p (def_insn->rtl ()))\n+\t\t{\n+\t\t  vl_vtype_info def_info = get_vl_vtype_info (def_insn);\n+\t\t  vl_vtype_info info = get_vl_vtype_info (insn);\n+\t\t  rtx avl = get_avl (def_insn->rtl ());\n+\t\t  rtx vl = get_vl (def_insn->rtl ());\n+\t\t  if (def_info.get_ratio () == info.get_ratio ())\n+\t\t    {\n+\t\t      if (vlmax_avl_p (def_info.get_avl ()))\n+\t\t\t{\n+\t\t\t  info.set_avl_info (\n+\t\t\t    avl_info (def_info.get_avl (), nullptr));\n+\t\t\t  rtx new_pat\n+\t\t\t    = gen_vsetvl_pat (VSETVL_NORMAL, info, vl);\n+\t\t\t  validate_change (insn->rtl (),\n+\t\t\t\t\t   &PATTERN (insn->rtl ()), new_pat,\n+\t\t\t\t\t   false);\n+\t\t\t  continue;\n+\t\t\t}\n+\t\t      if (def_info.has_avl_imm () || rtx_equal_p (avl, vl))\n+\t\t\t{\n+\t\t\t  info.set_avl_info (avl_info (avl, nullptr));\n+\t\t\t  emit_vsetvl_insn (VSETVL_DISCARD_RESULT, EMIT_AFTER,\n+\t\t\t\t\t    info, NULL_RTX, insn->rtl ());\n+\t\t\t  if (set->single_nondebug_insn_use ())\n+\t\t\t    {\n+\t\t\t      to_delete.add (insn->rtl ());\n+\t\t\t      to_delete.add (def_insn->rtl ());\n+\t\t\t    }\n+\t\t\t  continue;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  /* Change vsetvl rd, rs1 --> vsevl zero, rs1,\n+\t     if rd is not used by any nondebug instructions.\n+\t     Even though this PASS runs after RA and it doesn't help for\n+\t     reduce register pressure, it can help instructions scheduling\n+\t     since we remove the dependencies.  */\n+\t  if (vsetvl_insn_p (insn->rtl ()))\n+\t    {\n+\t      rtx vl = get_vl (insn->rtl ());\n+\t      rtx avl = get_avl (insn->rtl ());\n+\t      if (vlmax_avl_p (avl))\n+\t\tcontinue;\n+\t      def_info *def = find_access (insn->defs (), REGNO (vl));\n+\t      set_info *set = safe_dyn_cast<set_info *> (def);\n+\t      gcc_assert (set);\n+\t      const vl_vtype_info info = get_vl_vtype_info (insn);\n+\t      rtx new_pat\n+\t\t= gen_vsetvl_pat (VSETVL_DISCARD_RESULT, info, NULL_RTX);\n+\t      if (!set->has_nondebug_insn_uses ())\n+\t\t{\n+\t\t  validate_change (insn->rtl (), &PATTERN (insn->rtl ()),\n+\t\t\t\t   new_pat, false);\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  for (rtx_insn *rinsn : to_delete)\n+    eliminate_insn (rinsn);\n+}\n+\n void\n pass_vsetvl::init (void)\n {\n@@ -2380,6 +3451,7 @@ pass_vsetvl::init (void)\n     }\n \n   m_vector_manager = new vector_infos_manager ();\n+  compute_probabilities ();\n \n   if (dump_file)\n     {\n@@ -2405,6 +3477,41 @@ pass_vsetvl::done (void)\n   m_vector_manager = nullptr;\n }\n \n+/* Compute probability for each block.  */\n+void\n+pass_vsetvl::compute_probabilities (void)\n+{\n+  /* Don't compute it in -O0 since we don't need it.  */\n+  if (!optimize)\n+    return;\n+  edge e;\n+  edge_iterator ei;\n+\n+  for (const bb_info *bb : crtl->ssa->bbs ())\n+    {\n+      basic_block cfg_bb = bb->cfg_bb ();\n+      auto &curr_prob\n+\t= m_vector_manager->vector_block_infos[cfg_bb->index].probability;\n+      if (ENTRY_BLOCK_PTR_FOR_FN (cfun) == cfg_bb)\n+\tcurr_prob = profile_probability::always ();\n+      gcc_assert (curr_prob.initialized_p ());\n+      FOR_EACH_EDGE (e, ei, cfg_bb->succs)\n+\t{\n+\t  auto &new_prob\n+\t    = m_vector_manager->vector_block_infos[e->dest->index].probability;\n+\t  if (!new_prob.initialized_p ())\n+\t    new_prob = curr_prob * e->probability;\n+\t  else if (new_prob == profile_probability::always ())\n+\t    continue;\n+\t  else\n+\t    new_prob += curr_prob * e->probability;\n+\t}\n+    }\n+  auto &exit_block\n+    = m_vector_manager->vector_block_infos[EXIT_BLOCK_PTR_FOR_FN (cfun)->index];\n+  exit_block.probability = profile_probability::always ();\n+}\n+\n /* Lazy vsetvl insertion for optimize > 0. */\n void\n pass_vsetvl::lazy_vsetvl (void)\n@@ -2437,7 +3544,7 @@ pass_vsetvl::lazy_vsetvl (void)\n   /* Phase 3 - Propagate demanded info across blocks.  */\n   if (dump_file)\n     fprintf (dump_file, \"\\nPhase 3: Demands propagation across blocks\\n\");\n-  compute_global_backward_infos ();\n+  demand_fusion ();\n   if (dump_file)\n     m_vector_manager->dump (dump_file);\n \n@@ -2450,6 +3557,12 @@ pass_vsetvl::lazy_vsetvl (void)\n   if (dump_file)\n     fprintf (dump_file, \"\\nPhase 5: Cleanup AVL and VL operands\\n\");\n   cleanup_insns ();\n+\n+  /* Phase 6 - Rebuild RTL_SSA to propagate AVL between vsetvls.  */\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \"\\nPhase 6: Rebuild RTL_SSA to propagate AVL between vsetvls\\n\");\n+  propagate_avl ();\n }\n \n /* Main entry point for this pass.  */\n@@ -2459,12 +3572,10 @@ pass_vsetvl::execute (function *)\n   if (n_basic_blocks_for_fn (cfun) <= 0)\n     return 0;\n \n-  /* The reason we have this since we didn't finish splitting yet\n-     when optimize == 0. In this case, we should conservatively\n-     split all instructions here to make sure we don't miss any\n-     RVV instruction.  */\n-  if (!optimize)\n-    split_all_insns ();\n+  /* The RVV instruction may change after split which is not a stable\n+     instruction. We need to split it here to avoid potential issue\n+     since the VSETVL PASS is insert before split PASS.  */\n+  split_all_insns ();\n \n   /* Early return for there is no vector instructions.  */\n   if (!has_vector_insn (cfun))"}, {"sha": "09df4695518305a948cb54c201ec318f05c890ed", "filename": "gcc/config/riscv/riscv-vsetvl.h", "status": "modified", "additions": 104, "deletions": 19, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -52,6 +52,34 @@ enum demand_type\n   NUM_DEMAND\n };\n \n+enum fusion_type\n+{\n+  INVALID_FUSION,\n+  VALID_AVL_FUSION,\n+  KILLED_AVL_FUSION\n+};\n+\n+enum merge_type\n+{\n+  LOCAL_MERGE,\n+  GLOBAL_MERGE\n+};\n+\n+enum def_type\n+{\n+  REAL_SET = 1 << 0,\n+  PHI_SET = 1 << 1,\n+  BB_HEAD_SET = 1 << 2,\n+  BB_END_SET = 1 << 3,\n+  /* ??? TODO: In RTL_SSA framework, we have REAL_SET,\n+     PHI_SET, BB_HEAD_SET, BB_END_SET and\n+     CLOBBER_DEF def_info types. Currently,\n+     we conservatively do not optimize clobber\n+     def since we don't see the case that we\n+     need to optimize it.  */\n+  CLOBBER_DEF = 1 << 4\n+};\n+\n /* AVL info for RVV instruction. Most RVV instructions have AVL operand in\n    implicit dependency. The AVL comparison between 2 RVV instructions is\n    very important since it affects our decision whether we should insert\n@@ -129,6 +157,8 @@ class avl_info\n   avl_info (rtx, rtl_ssa::set_info *);\n   rtx get_value () const { return m_value; }\n   rtl_ssa::set_info *get_source () const { return m_source; }\n+  bool single_source_equal_p (const avl_info &) const;\n+  bool multiple_source_equal_p (const avl_info &) const;\n   avl_info &operator= (const avl_info &);\n   bool operator== (const avl_info &) const;\n   bool operator!= (const avl_info &) const;\n@@ -174,6 +204,7 @@ struct vl_vtype_info\n \n   rtx get_avl () const { return m_avl.get_value (); }\n   const avl_info &get_avl_info () const { return m_avl; }\n+  rtl_ssa::set_info *get_avl_source () const { return m_avl.get_source (); }\n   void set_avl_info (const avl_info &avl) { m_avl = avl; }\n   uint8_t get_sew () const { return m_sew; }\n   riscv_vector::vlmul_type get_vlmul () const { return m_vlmul; }\n@@ -195,11 +226,31 @@ class vector_insn_info : public vl_vtype_info\n     VALID,\n     UNKNOWN,\n     EMPTY,\n+    /* The empty block can not be polluted as dirty.  */\n+    HARD_EMPTY,\n \n     /* The block is polluted as containing VSETVL instruction during dem\n        backward propagation to gain better LCM optimization even though\n        such VSETVL instruction is not really emit yet during this time.  */\n-    DIRTY\n+    DIRTY,\n+    /* The block is polluted with killed AVL.\n+       We will backward propagate such case:\n+\t bb 0: def a5, 55 (empty).\n+\t ...\n+\t bb 1: vsetvli zero, a5.\n+\t ...\n+\t bb 2: empty.\n+\t ...\n+\t bb 3: def a3, 55 (empty).\n+\t ...\n+\t bb 4: vsetvli zero, a3.\n+\n+       To elide vsetvli in bb 4, we need to backward pollute bb 3 and bb 2\n+       as DIRTY block as long as there is a block def AVL which has the same\n+       source with AVL in bb 4. Such polluted block, we call it as\n+       DIRTY_WITH_KILLED_AVL\n+    */\n+    DIRTY_WITH_KILLED_AVL\n   };\n \n   enum state_type m_state;\n@@ -220,45 +271,50 @@ class vector_insn_info : public vl_vtype_info\n      (with AVL included) before vmv.x.s, but vmv.x.s is not the INSN holding the\n      definition of AVL.  */\n   rtl_ssa::insn_info *m_insn;\n-  /* Save instruction pattern for Dirty block.\n-     Since empty block may be polluted as a dirty block during dem backward\n-     propagation (phase 3) which is intending to cheat LCM there is a VSETVL\n-     instruction here to gain better LCM optimization. Such instruction is not\n-     emit yet, we save this here and then emit it in the 4th phase if it is\n-     necessary.  */\n-  rtx m_dirty_pat;\n \n   /* Parse the instruction to get VL/VTYPE information and demanding\n    * information.  */\n   /* This is only called by simple_vsetvl subroutine when optimize == 0.\n      Since RTL_SSA can not be enabled when optimize == 0, we don't initialize\n      the m_insn.  */\n   void parse_insn (rtx_insn *);\n-  /* This is only called by lazy_vsetvl subroutine when optimize > 0.\n-     We use RTL_SSA framework to initialize the insn_info.  */\n-  void parse_insn (rtl_ssa::insn_info *);\n \n   friend class vector_infos_manager;\n \n public:\n   vector_insn_info ()\n     : vl_vtype_info (), m_state (UNINITIALIZED), m_demands{false},\n-      m_insn (nullptr), m_dirty_pat (NULL_RTX)\n+      m_insn (nullptr)\n   {}\n \n+  /* This is only called by lazy_vsetvl subroutine when optimize > 0.\n+     We use RTL_SSA framework to initialize the insn_info.  */\n+  void parse_insn (rtl_ssa::insn_info *);\n+\n   bool operator> (const vector_insn_info &) const;\n   bool operator>= (const vector_insn_info &) const;\n   bool operator== (const vector_insn_info &) const;\n \n   bool uninit_p () const { return m_state == UNINITIALIZED; }\n   bool valid_p () const { return m_state == VALID; }\n   bool unknown_p () const { return m_state == UNKNOWN; }\n-  bool empty_p () const { return m_state == EMPTY; }\n-  bool dirty_p () const { return m_state == DIRTY; }\n+  bool empty_p () const { return m_state == EMPTY || m_state == HARD_EMPTY; }\n+  bool hard_empty_p () const { return m_state == HARD_EMPTY; }\n+  bool dirty_p () const\n+  {\n+    return m_state == DIRTY || m_state == DIRTY_WITH_KILLED_AVL;\n+  }\n+  bool dirty_with_killed_avl_p () const\n+  {\n+    return m_state == DIRTY_WITH_KILLED_AVL;\n+  }\n+  bool real_dirty_p () const { return m_state == DIRTY; }\n   bool valid_or_dirty_p () const\n   {\n-    return m_state == VALID || m_state == DIRTY;\n+    return m_state == VALID || m_state == DIRTY\n+\t   || m_state == DIRTY_WITH_KILLED_AVL;\n   }\n+  bool available_p (const vector_insn_info &) const;\n \n   static vector_insn_info get_unknown ()\n   {\n@@ -267,11 +323,32 @@ class vector_insn_info : public vl_vtype_info\n     return info;\n   }\n \n+  static vector_insn_info get_hard_empty ()\n+  {\n+    vector_insn_info info;\n+    info.set_hard_empty ();\n+    return info;\n+  }\n+\n   void set_valid () { m_state = VALID; }\n   void set_unknown () { m_state = UNKNOWN; }\n   void set_empty () { m_state = EMPTY; }\n-  void set_dirty () { m_state = DIRTY; }\n-  void set_dirty_pat (rtx pat) { m_dirty_pat = pat; }\n+  void set_hard_empty () { m_state = HARD_EMPTY; }\n+  void set_dirty (enum fusion_type type)\n+  {\n+    gcc_assert (type == VALID_AVL_FUSION || type == KILLED_AVL_FUSION);\n+    if (type == VALID_AVL_FUSION)\n+      m_state = DIRTY;\n+    else\n+      m_state = DIRTY_WITH_KILLED_AVL;\n+  }\n+  void set_dirty (bool dirty_with_killed_avl_p)\n+  {\n+    if (dirty_with_killed_avl_p)\n+      m_state = DIRTY_WITH_KILLED_AVL;\n+    else\n+      m_state = DIRTY;\n+  }\n   void set_insn (rtl_ssa::insn_info *insn) { m_insn = insn; }\n \n   bool demand_p (enum demand_type type) const { return m_demands[type]; }\n@@ -281,12 +358,12 @@ class vector_insn_info : public vl_vtype_info\n \n   bool compatible_p (const vector_insn_info &) const;\n   bool compatible_avl_p (const vl_vtype_info &) const;\n+  bool compatible_avl_p (const avl_info &) const;\n   bool compatible_vtype_p (const vl_vtype_info &) const;\n   bool compatible_p (const vl_vtype_info &) const;\n-  vector_insn_info merge (const vector_insn_info &, bool) const;\n+  vector_insn_info merge (const vector_insn_info &, enum merge_type) const;\n \n   rtl_ssa::insn_info *get_insn () const { return m_insn; }\n-  rtx get_dirty_pat () const { return m_dirty_pat; }\n \n   void dump (FILE *) const;\n };\n@@ -299,6 +376,9 @@ struct vector_block_info\n   /* The reaching_out vector insn_info of the block.  */\n   vector_insn_info reaching_out;\n \n+  /* The static execute probability of the demand info.  */\n+  profile_probability probability;\n+\n   vector_block_info () = default;\n };\n \n@@ -333,10 +413,15 @@ class vector_infos_manager\n   /* Get all relaxer expression id for corresponding vector info.  */\n   auto_vec<size_t> get_all_available_exprs (const vector_insn_info &) const;\n \n+  /* Return true if all expression set in bitmap are same AVL.  */\n+  bool all_same_avl_p (const basic_block, sbitmap) const;\n+\n   /* Return true if all expression set in bitmap are same ratio.  */\n   bool all_same_ratio_p (sbitmap) const;\n \n   void release (void);\n+  void create_bitmap_vectors (void);\n+  void free_bitmap_vectors (void);\n \n   void dump (FILE *) const;\n };"}, {"sha": "2ac75b3f94c7983b116112e9c05249c41d83a0e1", "filename": "gcc/config/riscv/vector-iterators.md", "status": "modified", "additions": 91, "deletions": 2, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Fvector-iterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Fvector-iterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fvector-iterators.md?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -18,11 +18,24 @@\n ;; along with GCC; see the file COPYING3.  If not see\n ;; <http://www.gnu.org/licenses/>.\n \n+(define_c_enum \"unspec\" [\n+  UNSPEC_VSETVL\n+  UNSPEC_VUNDEF\n+  UNSPEC_VPREDICATE\n+  UNSPEC_VLMAX\n+  UNSPEC_STRIDED\n+\n+  ;; It's used to specify ordered/unorderd operation.\n+  UNSPEC_ORDERED\n+  UNSPEC_UNORDERED\n+])\n+\n (define_mode_iterator V [\n   VNx1QI VNx2QI VNx4QI VNx8QI VNx16QI VNx32QI (VNx64QI \"TARGET_MIN_VLEN > 32\")\n   VNx1HI VNx2HI VNx4HI VNx8HI VNx16HI (VNx32HI \"TARGET_MIN_VLEN > 32\")\n   VNx1SI VNx2SI VNx4SI VNx8SI (VNx16SI \"TARGET_MIN_VLEN > 32\")\n-  VNx1DI VNx2DI VNx4DI (VNx8DI \"TARGET_MIN_VLEN > 32\")\n+  (VNx1DI \"TARGET_MIN_VLEN > 32\") (VNx2DI \"TARGET_MIN_VLEN > 32\")\n+  (VNx4DI \"TARGET_MIN_VLEN > 32\") (VNx8DI \"TARGET_MIN_VLEN > 32\")\n   (VNx1SF \"TARGET_VECTOR_ELEN_FP_32\")\n   (VNx2SF \"TARGET_VECTOR_ELEN_FP_32\")\n   (VNx4SF \"TARGET_VECTOR_ELEN_FP_32\")\n@@ -34,11 +47,81 @@\n   (VNx8DF \"TARGET_VECTOR_ELEN_FP_64\")\n ])\n \n+(define_mode_iterator VNX1_QHSD [\n+  VNx1QI VNx1HI VNx1SI\n+  (VNx1DI \"TARGET_MIN_VLEN > 32\")\n+  (VNx1SF \"TARGET_VECTOR_ELEN_FP_32\")\n+  (VNx1DF \"TARGET_VECTOR_ELEN_FP_64\")\n+])\n+\n+(define_mode_iterator VNX2_QHSD [\n+  VNx2QI VNx2HI VNx2SI\n+  (VNx2DI \"TARGET_MIN_VLEN > 32\")\n+  (VNx2SF \"TARGET_VECTOR_ELEN_FP_32\")\n+  (VNx2DF \"TARGET_VECTOR_ELEN_FP_64\")\n+])\n+\n+(define_mode_iterator VNX4_QHSD [\n+  VNx4QI VNx4HI VNx4SI\n+  (VNx4DI \"TARGET_MIN_VLEN > 32\")\n+  (VNx4SF \"TARGET_VECTOR_ELEN_FP_32\")\n+  (VNx4DF \"TARGET_VECTOR_ELEN_FP_64\")\n+])\n+\n+(define_mode_iterator VNX8_QHSD [\n+  VNx8QI VNx8HI VNx8SI\n+  (VNx8DI \"TARGET_MIN_VLEN > 32\")\n+  (VNx8SF \"TARGET_VECTOR_ELEN_FP_32\")\n+  (VNx8DF \"TARGET_VECTOR_ELEN_FP_64\")\n+])\n+\n+(define_mode_iterator VNX16_QHS [\n+  VNx16QI VNx16HI (VNx16SI \"TARGET_MIN_VLEN > 32\")\n+  (VNx16SF \"TARGET_VECTOR_ELEN_FP_32 && TARGET_MIN_VLEN > 32\")\n+])\n+\n+(define_mode_iterator VNX32_QH [\n+  VNx32QI (VNx32HI \"TARGET_MIN_VLEN > 32\")\n+])\n+\n+(define_mode_iterator VNX64_Q [\n+  (VNx64QI \"TARGET_MIN_VLEN > 32\")\n+])\n+\n+(define_mode_iterator VNX1_QHSDI [\n+  VNx1QI VNx1HI VNx1SI\n+  (VNx1DI \"TARGET_64BIT && TARGET_MIN_VLEN > 32\")\n+])\n+\n+(define_mode_iterator VNX2_QHSDI [\n+  VNx2QI VNx2HI VNx2SI\n+  (VNx2DI \"TARGET_64BIT && TARGET_MIN_VLEN > 32\")\n+])\n+\n+(define_mode_iterator VNX4_QHSDI [\n+  VNx4QI VNx4HI VNx4SI\n+  (VNx4DI \"TARGET_64BIT && TARGET_MIN_VLEN > 32\")\n+])\n+\n+(define_mode_iterator VNX8_QHSDI [\n+  VNx8QI VNx8HI VNx8SI\n+  (VNx8DI \"TARGET_64BIT && TARGET_MIN_VLEN > 32\")\n+])\n+\n+(define_mode_iterator VNX16_QHSI [\n+  VNx16QI VNx16HI (VNx16SI \"TARGET_MIN_VLEN > 32\")\n+])\n+\n+(define_mode_iterator VNX32_QHI [\n+  VNx32QI (VNx32HI \"TARGET_MIN_VLEN > 32\")\n+])\n+\n (define_mode_iterator V_WHOLE [\n   (VNx4QI \"TARGET_MIN_VLEN == 32\") VNx8QI VNx16QI VNx32QI (VNx64QI \"TARGET_MIN_VLEN > 32\")\n   (VNx2HI \"TARGET_MIN_VLEN == 32\") VNx4HI VNx8HI VNx16HI (VNx32HI \"TARGET_MIN_VLEN > 32\")\n   (VNx1SI \"TARGET_MIN_VLEN == 32\") VNx2SI VNx4SI VNx8SI (VNx16SI \"TARGET_MIN_VLEN > 32\")\n-  VNx1DI VNx2DI VNx4DI (VNx8DI \"TARGET_MIN_VLEN > 32\")\n+  (VNx1DI \"TARGET_MIN_VLEN > 32\") (VNx2DI \"TARGET_MIN_VLEN > 32\")\n+  (VNx4DI \"TARGET_MIN_VLEN > 32\") (VNx8DI \"TARGET_MIN_VLEN > 32\")\n   (VNx1SF \"TARGET_VECTOR_ELEN_FP_32 && TARGET_MIN_VLEN == 32\")\n   (VNx2SF \"TARGET_VECTOR_ELEN_FP_32\")\n   (VNx4SF \"TARGET_VECTOR_ELEN_FP_32\")\n@@ -88,3 +171,9 @@\n   (VNx1SF \"32\") (VNx2SF \"32\") (VNx4SF \"32\") (VNx8SF \"32\") (VNx16SF \"32\")\n   (VNx1DF \"64\") (VNx2DF \"64\") (VNx4DF \"64\") (VNx8DF \"64\")\n ])\n+\n+(define_int_iterator ORDER [UNSPEC_ORDERED UNSPEC_UNORDERED])\n+\n+(define_int_attr order [\n+  (UNSPEC_ORDERED \"o\") (UNSPEC_UNORDERED \"u\")\n+])"}, {"sha": "403d2f6cda372dfb6d3a53c2555503c3aa92c054", "filename": "gcc/config/riscv/vector.md", "status": "modified", "additions": 433, "deletions": 66, "changes": 499, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Friscv%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fvector.md?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -28,13 +28,6 @@\n \n (include \"vector-iterators.md\")\n \n-(define_c_enum \"unspec\" [\n-  UNSPEC_VSETVL\n-  UNSPEC_VUNDEF\n-  UNSPEC_VPREDICATE\n-  UNSPEC_VLMAX\n-])\n-\n (define_constants [\n    (INVALID_ATTRIBUTE            255)\n ])\n@@ -95,13 +88,7 @@\n \t (const_int 32)\n \t (eq_attr \"mode\" \"VNx1DI,VNx2DI,VNx4DI,VNx8DI,\\\n \t\t\t  VNx1DF,VNx2DF,VNx4DF,VNx8DF\")\n-\t (const_int 64)\n-\n-\t (eq_attr \"type\" \"vsetvl\")\n-\t (if_then_else (eq_attr \"INSN_CODE (curr_insn) == CODE_FOR_vsetvldi\n-\t\t\t\t || INSN_CODE (curr_insn) == CODE_FOR_vsetvlsi\")\n-\t\t       (symbol_ref \"INTVAL (operands[2])\")\n-\t\t       (const_int INVALID_ATTRIBUTE))]\n+\t (const_int 64)]\n \t(const_int INVALID_ATTRIBUTE)))\n \n ;; Ditto to LMUL.\n@@ -149,17 +136,12 @@\n \t (eq_attr \"mode\" \"VNx4DI,VNx4DF\")\n \t   (symbol_ref \"riscv_vector::get_vlmul(E_VNx4DImode)\")\n \t (eq_attr \"mode\" \"VNx8DI,VNx8DF\")\n-\t   (symbol_ref \"riscv_vector::get_vlmul(E_VNx8DImode)\")\n-\t (eq_attr \"type\" \"vsetvl\")\n-\t (if_then_else (eq_attr \"INSN_CODE (curr_insn) == CODE_FOR_vsetvldi\n-\t\t\t\t || INSN_CODE (curr_insn) == CODE_FOR_vsetvlsi\")\n-\t\t       (symbol_ref \"INTVAL (operands[3])\")\n-\t\t       (const_int INVALID_ATTRIBUTE))]\n+\t   (symbol_ref \"riscv_vector::get_vlmul(E_VNx8DImode)\")]\n \t(const_int INVALID_ATTRIBUTE)))\n \n ;; It is valid for instruction that require sew/lmul ratio.\n (define_attr \"ratio\" \"\"\n-  (cond [(eq_attr \"type\" \"vimov,vfmov\")\n+  (cond [(eq_attr \"type\" \"vimov,vfmov,vldux,vldox,vstux,vstox\")\n \t   (const_int INVALID_ATTRIBUTE)\n \t (eq_attr \"mode\" \"VNx1QI,VNx1BI\")\n \t   (symbol_ref \"riscv_vector::get_ratio(E_VNx1QImode)\")\n@@ -209,53 +191,75 @@\n \n ;; The index of operand[] to get the merge op.\n (define_attr \"merge_op_idx\" \"\"\n-\t(cond [(eq_attr \"type\" \"vlde,vste,vimov,vfmov,vldm,vstm,vlds,vmalu\")\n+\t(cond [(eq_attr \"type\" \"vlde,vimov,vfmov,vldm,vlds,vmalu,vldux,vldox\")\n \t (const_int 2)]\n \t(const_int INVALID_ATTRIBUTE)))\n \n ;; The index of operand[] to get the avl op.\n (define_attr \"vl_op_idx\" \"\"\n-\t(cond [(eq_attr \"type\" \"vlde,vste,vimov,vfmov,vldm,vstm,vlds,vmalu\")\n-\t (const_int 4)]\n-\t(const_int INVALID_ATTRIBUTE)))\n+  (cond [(eq_attr \"type\" \"vlde,vste,vimov,vfmov,vldm,vstm,vmalu,vsts,vstux,vstox\")\n+\t   (const_int 4)\n \n-;; The index of operand[] to get the tail policy op.\n-(define_attr \"tail_policy_op_idx\" \"\"\n-  (cond [(eq_attr \"type\" \"vlde,vste,vimov,vfmov,vlds\")\n-\t (const_int 5)]\n-\t(const_int INVALID_ATTRIBUTE)))\n-\n-;; The index of operand[] to get the mask policy op.\n-(define_attr \"mask_policy_op_idx\" \"\"\n-  (cond [(eq_attr \"type\" \"vlde,vste,vlds\")\n-\t (const_int 6)]\n-\t(const_int INVALID_ATTRIBUTE)))\n+\t ;; If operands[3] of \"vlds\" is not vector mode, it is pred_broadcast.\n+\t ;; wheras it is pred_strided_load if operands[3] is vector mode.\n+         (eq_attr \"type\" \"vlds\")\n+\t   (if_then_else (match_test \"VECTOR_MODE_P (GET_MODE (operands[3]))\")\n+             (const_int 5)\n+             (const_int 4))\n \n-;; The index of operand[] to get the mask policy op.\n-(define_attr \"avl_type_op_idx\" \"\"\n-  (cond [(eq_attr \"type\" \"vlde,vlde,vste,vimov,vimov,vimov,vfmov,vlds,vlds\")\n-\t (const_int 7)\n-\t (eq_attr \"type\" \"vldm,vstm,vimov,vmalu,vmalu\")\n-\t (const_int 5)]\n-\t(const_int INVALID_ATTRIBUTE)))\n+\t (eq_attr \"type\" \"vldux,vldox\")\n+\t   (const_int 5)]\n+  (const_int INVALID_ATTRIBUTE)))\n \n ;; The tail policy op value.\n (define_attr \"ta\" \"\"\n-  (cond [(eq_attr \"type\" \"vlde,vimov,vfmov,vlds\")\n-\t   (symbol_ref \"riscv_vector::get_ta(operands[5])\")]\n+  (cond [(eq_attr \"type\" \"vlde,vimov,vfmov\")\n+\t   (symbol_ref \"riscv_vector::get_ta(operands[5])\")\n+\n+\t ;; If operands[3] of \"vlds\" is not vector mode, it is pred_broadcast.\n+\t ;; wheras it is pred_strided_load if operands[3] is vector mode.\n+\t (eq_attr \"type\" \"vlds\")\n+\t   (if_then_else (match_test \"VECTOR_MODE_P (GET_MODE (operands[3]))\")\n+\t     (symbol_ref \"riscv_vector::get_ta(operands[6])\")\n+\t     (symbol_ref \"riscv_vector::get_ta(operands[5])\"))\n+\n+\t (eq_attr \"type\" \"vldux,vldox\")\n+\t   (symbol_ref \"riscv_vector::get_ta(operands[6])\")]\n \t(const_int INVALID_ATTRIBUTE)))\n \n ;; The mask policy op value.\n (define_attr \"ma\" \"\"\n-  (cond [(eq_attr \"type\" \"vlde,vlds\")\n-\t   (symbol_ref \"riscv_vector::get_ma(operands[6])\")]\n+  (cond [(eq_attr \"type\" \"vlde\")\n+\t   (symbol_ref \"riscv_vector::get_ma(operands[6])\")\n+\n+\t ;; If operands[3] of \"vlds\" is not vector mode, it is pred_broadcast.\n+\t ;; wheras it is pred_strided_load if operands[3] is vector mode.\n+\t (eq_attr \"type\" \"vlds\")\n+\t   (if_then_else (match_test \"VECTOR_MODE_P (GET_MODE (operands[3]))\")\n+\t     (symbol_ref \"riscv_vector::get_ma(operands[7])\")\n+\t     (symbol_ref \"riscv_vector::get_ma(operands[6])\"))\n+\n+\t (eq_attr \"type\" \"vldux,vldox\")\n+\t   (symbol_ref \"riscv_vector::get_ma(operands[7])\")]\n \t(const_int INVALID_ATTRIBUTE)))\n \n ;; The avl type value.\n (define_attr \"avl_type\" \"\"\n-  (cond [(eq_attr \"type\" \"vlde,vlde,vste,vimov,vimov,vimov,vfmov,vlds,vlds\")\n+  (cond [(eq_attr \"type\" \"vlde,vlde,vste,vimov,vimov,vimov,vfmov\")\n \t   (symbol_ref \"INTVAL (operands[7])\")\n \t (eq_attr \"type\" \"vldm,vstm,vimov,vmalu,vmalu\")\n+\t   (symbol_ref \"INTVAL (operands[5])\")\n+\n+\t ;; If operands[3] of \"vlds\" is not vector mode, it is pred_broadcast.\n+\t ;; wheras it is pred_strided_load if operands[3] is vector mode.\n+\t (eq_attr \"type\" \"vlds\")\n+\t   (if_then_else (match_test \"VECTOR_MODE_P (GET_MODE (operands[3]))\")\n+\t     (const_int INVALID_ATTRIBUTE)\n+\t     (symbol_ref \"INTVAL (operands[7])\"))\n+\n+\t (eq_attr \"type\" \"vldux,vldox\")\n+\t   (symbol_ref \"INTVAL (operands[8])\")\n+\t (eq_attr \"type\" \"vstux,vstox\")\n \t   (symbol_ref \"INTVAL (operands[5])\")]\n \t(const_int INVALID_ATTRIBUTE)))\n \n@@ -551,7 +555,11 @@\n   \"TARGET_VECTOR\"\n   \"vset%i1vli\\t%0,%1,e%2,%m3,t%p4,m%p5\"\n   [(set_attr \"type\" \"vsetvl\")\n-   (set_attr \"mode\" \"<MODE>\")])\n+   (set_attr \"mode\" \"<MODE>\")\n+   (set (attr \"sew\") (symbol_ref \"INTVAL (operands[2])\"))\n+   (set (attr \"vlmul\") (symbol_ref \"INTVAL (operands[3])\"))\n+   (set (attr \"ta\") (symbol_ref \"INTVAL (operands[4])\"))\n+   (set (attr \"ma\") (symbol_ref \"INTVAL (operands[5])\"))])\n \n ;; vsetvl zero,zero,vtype instruction.\n ;; This pattern has no side effects and does not set X0 register.\n@@ -581,9 +589,13 @@\n \t\t    (match_operand 3 \"const_int_operand\" \"i\")\n \t\t    (match_operand 4 \"const_int_operand\" \"i\")] UNSPEC_VSETVL))]\n   \"TARGET_VECTOR\"\n-  \"vsetvli\\tzero,%0,e%1,%m2,t%p3,m%p4\"\n+  \"vset%i0vli\\tzero,%0,e%1,%m2,t%p3,m%p4\"\n   [(set_attr \"type\" \"vsetvl\")\n-   (set_attr \"mode\" \"<MODE>\")])\n+   (set_attr \"mode\" \"<MODE>\")\n+   (set (attr \"sew\") (symbol_ref \"INTVAL (operands[1])\"))\n+   (set (attr \"vlmul\") (symbol_ref \"INTVAL (operands[2])\"))\n+   (set (attr \"ta\") (symbol_ref \"INTVAL (operands[3])\"))\n+   (set (attr \"ma\") (symbol_ref \"INTVAL (operands[4])\"))])\n \n ;; It's emit by vsetvl/vsetvlmax intrinsics with no side effects.\n ;; Since we have many optmization passes from \"expand\" to \"reload_completed\",\n@@ -656,22 +668,23 @@\n ;;    2. (const_vector:VNx1SF repeat [\n ;;                (const_double:SF 0.0 [0x0.0p+0])]).\n (define_insn_and_split \"@pred_mov<mode>\"\n-  [(set (match_operand:V 0 \"nonimmediate_operand\"          \"=vd,    vr,     m,    vr,    vr\")\n-\t(if_then_else:V\n-\t  (unspec:<VM>\n-\t    [(match_operand:<VM> 1 \"vector_mask_operand\" \"vmWc1, vmWc1, vmWc1,   Wc1,   Wc1\")\n-\t     (match_operand 4 \"vector_length_operand\"    \"   rK,    rK,    rK,    rK,    rK\")\n-\t     (match_operand 5 \"const_int_operand\"        \"    i,     i,     i,     i,     i\")\n-\t     (match_operand 6 \"const_int_operand\"        \"    i,     i,     i,     i,     i\")\n-\t     (match_operand 7 \"const_int_operand\"        \"    i,     i,     i,     i,     i\")\n-\t     (reg:SI VL_REGNUM)\n-\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n-\t  (match_operand:V 3 \"vector_move_operand\"       \"    m,     m,    vr,    vr, viWc0\")\n-\t  (match_operand:V 2 \"vector_merge_operand\"      \"    0,    vu,   vu0,   vu0,   vu0\")))]\n+  [(set (match_operand:V 0 \"nonimmediate_operand\"      \"=vr,    vr,    vd,     m,    vr,    vr\")\n+    (if_then_else:V\n+      (unspec:<VM>\n+        [(match_operand:<VM> 1 \"vector_mask_operand\" \"vmWc1,   Wc1,    vm, vmWc1,   Wc1,   Wc1\")\n+         (match_operand 4 \"vector_length_operand\"    \"   rK,    rK,    rK,    rK,    rK,    rK\")\n+         (match_operand 5 \"const_int_operand\"        \"    i,     i,     i,     i,     i,     i\")\n+         (match_operand 6 \"const_int_operand\"        \"    i,     i,     i,     i,     i,     i\")\n+         (match_operand 7 \"const_int_operand\"        \"    i,     i,     i,     i,     i,     i\")\n+         (reg:SI VL_REGNUM)\n+         (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+      (match_operand:V 3 \"vector_move_operand\"       \"    m,     m,     m,    vr,    vr, viWc0\")\n+      (match_operand:V 2 \"vector_merge_operand\"      \"    0,    vu,    vu,    vu,   vu0,   vu0\")))]\n   \"TARGET_VECTOR\"\n   \"@\n    vle<sew>.v\\t%0,%3%p1\n-   vle<sew>.v\\t%0,%3%p1\n+   vle<sew>.v\\t%0,%3\n+   vle<sew>.v\\t%0,%3,%1.t\n    vse<sew>.v\\t%3,%0%p1\n    vmv.v.v\\t%0,%3\n    vmv.v.i\\t%0,%v3\"\n@@ -680,9 +693,28 @@\n    && satisfies_constraint_vu (operands[2])\"\n   [(set (match_dup 0) (match_dup 3))]\n   \"\"\n-  [(set_attr \"type\" \"vlde,vlde,vste,vimov,vimov\")\n+  [(set_attr \"type\" \"vlde,vlde,vlde,vste,vimov,vimov\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n+;; Dedicated pattern for vse.v instruction since we can't reuse pred_mov pattern to include\n+;; memory operand as input which will produce inferior codegen.\n+(define_insn \"@pred_store<mode>\"\n+  [(set (match_operand:V 0 \"memory_operand\"                 \"+m\")\n+\t(if_then_else:V\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\" \"vmWc1\")\n+\t     (match_operand 3 \"vector_length_operand\"    \"   rK\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operand:V 2 \"register_operand\"         \"    vr\")\n+\t  (match_dup 0)))]\n+  \"TARGET_VECTOR\"\n+  \"vse<sew>.v\\t%2,%0%p1\"\n+  [(set_attr \"type\" \"vste\")\n+   (set_attr \"mode\" \"<MODE>\")\n+   (set (attr \"avl_type\") (symbol_ref \"riscv_vector::NONVLMAX\"))\n+   (set_attr \"vl_op_idx\" \"3\")])\n+\n ;; vlm.v/vsm.v/vmclr.m/vmset.m.\n ;; constraint alternative 0 match vlm.v.\n ;; constraint alternative 1 match vsm.v.\n@@ -698,7 +730,7 @@\n \t     (reg:SI VL_REGNUM)\n \t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n \t  (match_operand:VB 3 \"vector_move_operand\"      \"  m,  vr,  vr, Wc0, Wc1\")\n-\t  (match_operand:VB 2 \"vector_merge_operand\"     \" vu, vu0,  vu,  vu,  vu\")))]\n+\t  (match_operand:VB 2 \"vector_merge_operand\"     \" vu,  vu,  vu,  vu,  vu\")))]\n   \"TARGET_VECTOR\"\n   \"@\n    vlm.v\\t%0,%3\n@@ -713,6 +745,25 @@\n   [(set_attr \"type\" \"vldm,vstm,vimov,vmalu,vmalu\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n+;; Dedicated pattern for vsm.v instruction since we can't reuse pred_mov pattern to include\n+;; memory operand as input which will produce inferior codegen.\n+(define_insn \"@pred_store<mode>\"\n+  [(set (match_operand:VB 0 \"memory_operand\"            \"+m\")\n+\t(if_then_else:VB\n+\t  (unspec:VB\n+\t    [(match_operand:VB 1 \"vector_mask_operand\" \"Wc1\")\n+\t     (match_operand 3 \"vector_length_operand\"  \" rK\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operand:VB 2 \"register_operand\"       \" vr\")\n+\t  (match_dup 0)))]\n+  \"TARGET_VECTOR\"\n+  \"vsm.v\\t%2,%0\"\n+  [(set_attr \"type\" \"vstm\")\n+   (set_attr \"mode\" \"<MODE>\")\n+   (set (attr \"avl_type\") (symbol_ref \"riscv_vector::NONVLMAX\"))\n+   (set_attr \"vl_op_idx\" \"3\")])\n+\n ;; -------------------------------------------------------------------------------\n ;; ---- Predicated Broadcast\n ;; -------------------------------------------------------------------------------\n@@ -744,3 +795,319 @@\n    vlse<sew>.v\\t%0,%3,zero\"\n   [(set_attr \"type\" \"vimov,vfmov,vlds,vlds\")\n    (set_attr \"mode\" \"<MODE>\")])\n+\n+;; -------------------------------------------------------------------------------\n+;; ---- Predicated Strided loads/stores\n+;; -------------------------------------------------------------------------------\n+;; Includes:\n+;; - 7.5. Vector Strided Instructions\n+;; -------------------------------------------------------------------------------\n+\n+(define_insn \"@pred_strided_load<mode>\"\n+  [(set (match_operand:V 0 \"register_operand\"              \"=vr,    vr,    vd\")\n+\t(if_then_else:V\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\" \"vmWc1,   Wc1,    vm\")\n+\t     (match_operand 5 \"vector_length_operand\"    \"   rK,    rK,    rK\")\n+\t     (match_operand 6 \"const_int_operand\"        \"    i,     i,     i\")\n+\t     (match_operand 7 \"const_int_operand\"        \"    i,     i,     i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (unspec:V\n+\t    [(match_operand:V 3 \"memory_operand\"         \"    m,     m,     m\")\n+\t     (match_operand 4 \"pmode_reg_or_0_operand\"   \"   rJ,    rJ,    rJ\")] UNSPEC_STRIDED)\n+\t  (match_operand:V 2 \"vector_merge_operand\"      \"    0,    vu,    vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vlse<sew>.v\\t%0,%3,%z4%p1\"\n+  [(set_attr \"type\" \"vlds\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"@pred_strided_store<mode>\"\n+  [(set (match_operand:V 0 \"memory_operand\"                 \"+m\")\n+\t(if_then_else:V\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\" \"vmWc1\")\n+\t     (match_operand 4 \"vector_length_operand\"    \"   rK\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (unspec:V\n+\t    [(match_operand 2 \"pmode_reg_or_0_operand\"   \"   rJ\")\n+\t     (match_operand:V 3 \"register_operand\"       \"   vr\")] UNSPEC_STRIDED)\n+\t  (match_dup 0)))]\n+  \"TARGET_VECTOR\"\n+  \"vsse<sew>.v\\t%3,%0,%z2%p1\"\n+  [(set_attr \"type\" \"vsts\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; -------------------------------------------------------------------------------\n+;; ---- Predicated indexed loads/stores\n+;; -------------------------------------------------------------------------------\n+;; Includes:\n+;; - 7.6. Vector Indexed Instructions\n+;; -------------------------------------------------------------------------------\n+\n+(define_insn \"@pred_indexed_<order>load<VNX1_QHSD:mode><VNX1_QHSDI:mode>\"\n+  [(set (match_operand:VNX1_QHSD 0 \"register_operand\"      \"=&vr\")\n+\t(if_then_else:VNX1_QHSD\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"  \"vmWc1\")\n+\t     (match_operand 5 \"vector_length_operand\"     \"   rK\")\n+\t     (match_operand 6 \"const_int_operand\"         \"    i\")\n+\t     (match_operand 7 \"const_int_operand\"         \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"         \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (unspec:VNX1_QHSD\n+\t    [(match_operand 3 \"pmode_register_operand\"    \"    r\")\n+\t     (mem:BLK (scratch))\n+\t     (match_operand:VNX1_QHSDI 4 \"register_operand\" \" vr\")] ORDER)\n+\t  (match_operand:VNX1_QHSD 2 \"vector_merge_operand\" \"0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vl<order>xei<VNX1_QHSDI:sew>.v\\t%0,(%3),%4%p1\"\n+  [(set_attr \"type\" \"vld<order>x\")\n+   (set_attr \"mode\" \"<VNX1_QHSD:MODE>\")])\n+\n+(define_insn \"@pred_indexed_<order>store<VNX1_QHSD:mode><VNX1_QHSDI:mode>\"\n+  [(set (mem:BLK (scratch))\n+\t(unspec:BLK\n+\t  [(unspec:<VM>\n+\t    [(match_operand:<VM> 0 \"vector_mask_operand\" \"vmWc1\")\n+\t     (match_operand 4 \"vector_length_operand\"    \"   rK\")\n+\t     (match_operand 5 \"const_int_operand\"        \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t   (match_operand 1 \"pmode_register_operand\"      \"   r\")\n+\t   (match_operand:VNX1_QHSDI 2 \"register_operand\" \"  vr\")\n+\t   (match_operand:VNX1_QHSD 3 \"register_operand\"  \"  vr\")] ORDER))]\n+  \"TARGET_VECTOR\"\n+  \"vs<order>xei<VNX1_QHSDI:sew>.v\\t%3,(%1),%2%p0\"\n+  [(set_attr \"type\" \"vst<order>x\")\n+   (set_attr \"mode\" \"<VNX1_QHSD:MODE>\")])\n+\n+(define_insn \"@pred_indexed_<order>load<VNX2_QHSD:mode><VNX2_QHSDI:mode>\"\n+  [(set (match_operand:VNX2_QHSD 0 \"register_operand\"      \"=&vr\")\n+\t(if_then_else:VNX2_QHSD\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"  \"vmWc1\")\n+\t     (match_operand 5 \"vector_length_operand\"     \"   rK\")\n+\t     (match_operand 6 \"const_int_operand\"         \"    i\")\n+\t     (match_operand 7 \"const_int_operand\"         \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"         \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (unspec:VNX2_QHSD\n+\t    [(match_operand 3 \"pmode_register_operand\"    \"    r\")\n+\t     (mem:BLK (scratch))\n+\t     (match_operand:VNX2_QHSDI 4 \"register_operand\" \" vr\")] ORDER)\n+\t  (match_operand:VNX2_QHSD 2 \"vector_merge_operand\" \"0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vl<order>xei<VNX2_QHSDI:sew>.v\\t%0,(%3),%4%p1\"\n+  [(set_attr \"type\" \"vld<order>x\")\n+   (set_attr \"mode\" \"<VNX2_QHSD:MODE>\")])\n+\n+(define_insn \"@pred_indexed_<order>store<VNX2_QHSD:mode><VNX2_QHSDI:mode>\"\n+  [(set (mem:BLK (scratch))\n+\t(unspec:BLK\n+\t  [(unspec:<VM>\n+\t    [(match_operand:<VM> 0 \"vector_mask_operand\" \"vmWc1\")\n+\t     (match_operand 4 \"vector_length_operand\"    \"   rK\")\n+\t     (match_operand 5 \"const_int_operand\"        \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t   (match_operand 1 \"pmode_register_operand\"      \"   r\")\n+\t   (match_operand:VNX2_QHSDI 2 \"register_operand\" \"  vr\")\n+\t   (match_operand:VNX2_QHSD 3 \"register_operand\"  \"  vr\")] ORDER))]\n+  \"TARGET_VECTOR\"\n+  \"vs<order>xei<VNX2_QHSDI:sew>.v\\t%3,(%1),%2%p0\"\n+  [(set_attr \"type\" \"vst<order>x\")\n+   (set_attr \"mode\" \"<VNX2_QHSD:MODE>\")])\n+\n+(define_insn \"@pred_indexed_<order>load<VNX4_QHSD:mode><VNX4_QHSDI:mode>\"\n+  [(set (match_operand:VNX4_QHSD 0 \"register_operand\"      \"=&vr\")\n+\t(if_then_else:VNX4_QHSD\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"  \"vmWc1\")\n+\t     (match_operand 5 \"vector_length_operand\"     \"   rK\")\n+\t     (match_operand 6 \"const_int_operand\"         \"    i\")\n+\t     (match_operand 7 \"const_int_operand\"         \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"         \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (unspec:VNX4_QHSD\n+\t    [(match_operand 3 \"pmode_register_operand\"    \"    r\")\n+\t     (mem:BLK (scratch))\n+\t     (match_operand:VNX4_QHSDI 4 \"register_operand\" \" vr\")] ORDER)\n+\t  (match_operand:VNX4_QHSD 2 \"vector_merge_operand\" \"0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vl<order>xei<VNX4_QHSDI:sew>.v\\t%0,(%3),%4%p1\"\n+  [(set_attr \"type\" \"vld<order>x\")\n+   (set_attr \"mode\" \"<VNX4_QHSD:MODE>\")])\n+\n+(define_insn \"@pred_indexed_<order>store<VNX4_QHSD:mode><VNX4_QHSDI:mode>\"\n+  [(set (mem:BLK (scratch))\n+\t(unspec:BLK\n+\t  [(unspec:<VM>\n+\t    [(match_operand:<VM> 0 \"vector_mask_operand\" \"vmWc1\")\n+\t     (match_operand 4 \"vector_length_operand\"    \"   rK\")\n+\t     (match_operand 5 \"const_int_operand\"        \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t   (match_operand 1 \"pmode_register_operand\"      \"   r\")\n+\t   (match_operand:VNX4_QHSDI 2 \"register_operand\" \"  vr\")\n+\t   (match_operand:VNX4_QHSD 3 \"register_operand\"  \"  vr\")] ORDER))]\n+  \"TARGET_VECTOR\"\n+  \"vs<order>xei<VNX4_QHSDI:sew>.v\\t%3,(%1),%2%p0\"\n+  [(set_attr \"type\" \"vst<order>x\")\n+   (set_attr \"mode\" \"<VNX4_QHSD:MODE>\")])\n+\n+(define_insn \"@pred_indexed_<order>load<VNX8_QHSD:mode><VNX8_QHSDI:mode>\"\n+  [(set (match_operand:VNX8_QHSD 0 \"register_operand\"      \"=&vr\")\n+\t(if_then_else:VNX8_QHSD\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"  \"vmWc1\")\n+\t     (match_operand 5 \"vector_length_operand\"     \"   rK\")\n+\t     (match_operand 6 \"const_int_operand\"         \"    i\")\n+\t     (match_operand 7 \"const_int_operand\"         \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"         \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (unspec:VNX8_QHSD\n+\t    [(match_operand 3 \"pmode_register_operand\"    \"    r\")\n+\t     (mem:BLK (scratch))\n+\t     (match_operand:VNX8_QHSDI 4 \"register_operand\" \" vr\")] ORDER)\n+\t  (match_operand:VNX8_QHSD 2 \"vector_merge_operand\" \"0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vl<order>xei<VNX8_QHSDI:sew>.v\\t%0,(%3),%4%p1\"\n+  [(set_attr \"type\" \"vld<order>x\")\n+   (set_attr \"mode\" \"<VNX8_QHSD:MODE>\")])\n+\n+(define_insn \"@pred_indexed_<order>store<VNX8_QHSD:mode><VNX8_QHSDI:mode>\"\n+  [(set (mem:BLK (scratch))\n+\t(unspec:BLK\n+\t  [(unspec:<VM>\n+\t    [(match_operand:<VM> 0 \"vector_mask_operand\" \"vmWc1\")\n+\t     (match_operand 4 \"vector_length_operand\"    \"   rK\")\n+\t     (match_operand 5 \"const_int_operand\"        \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t   (match_operand 1 \"pmode_register_operand\"      \"   r\")\n+\t   (match_operand:VNX8_QHSDI 2 \"register_operand\" \"  vr\")\n+\t   (match_operand:VNX8_QHSD 3 \"register_operand\"  \"  vr\")] ORDER))]\n+  \"TARGET_VECTOR\"\n+  \"vs<order>xei<VNX8_QHSDI:sew>.v\\t%3,(%1),%2%p0\"\n+  [(set_attr \"type\" \"vst<order>x\")\n+   (set_attr \"mode\" \"<VNX8_QHSD:MODE>\")])\n+\n+(define_insn \"@pred_indexed_<order>load<VNX16_QHS:mode><VNX16_QHSI:mode>\"\n+  [(set (match_operand:VNX16_QHS 0 \"register_operand\"      \"=&vr\")\n+\t(if_then_else:VNX16_QHS\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"  \"vmWc1\")\n+\t     (match_operand 5 \"vector_length_operand\"     \"   rK\")\n+\t     (match_operand 6 \"const_int_operand\"         \"    i\")\n+\t     (match_operand 7 \"const_int_operand\"         \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"         \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (unspec:VNX16_QHS\n+\t    [(match_operand 3 \"pmode_register_operand\"    \"    r\")\n+\t     (mem:BLK (scratch))\n+\t     (match_operand:VNX16_QHSI 4 \"register_operand\" \" vr\")] ORDER)\n+\t  (match_operand:VNX16_QHS 2 \"vector_merge_operand\" \"0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vl<order>xei<VNX16_QHSI:sew>.v\\t%0,(%3),%4%p1\"\n+  [(set_attr \"type\" \"vld<order>x\")\n+   (set_attr \"mode\" \"<VNX16_QHS:MODE>\")])\n+\n+(define_insn \"@pred_indexed_<order>store<VNX16_QHS:mode><VNX16_QHSI:mode>\"\n+  [(set (mem:BLK (scratch))\n+\t(unspec:BLK\n+\t  [(unspec:<VM>\n+\t    [(match_operand:<VM> 0 \"vector_mask_operand\" \"vmWc1\")\n+\t     (match_operand 4 \"vector_length_operand\"    \"   rK\")\n+\t     (match_operand 5 \"const_int_operand\"        \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t   (match_operand 1 \"pmode_register_operand\"      \"   r\")\n+\t   (match_operand:VNX16_QHSI 2 \"register_operand\" \"  vr\")\n+\t   (match_operand:VNX16_QHS 3 \"register_operand\"  \"  vr\")] ORDER))]\n+  \"TARGET_VECTOR\"\n+  \"vs<order>xei<VNX16_QHSI:sew>.v\\t%3,(%1),%2%p0\"\n+  [(set_attr \"type\" \"vst<order>x\")\n+   (set_attr \"mode\" \"<VNX16_QHS:MODE>\")])\n+\n+(define_insn \"@pred_indexed_<order>load<VNX32_QH:mode><VNX32_QHI:mode>\"\n+  [(set (match_operand:VNX32_QH 0 \"register_operand\"      \"=&vr\")\n+\t(if_then_else:VNX32_QH\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"  \"vmWc1\")\n+\t     (match_operand 5 \"vector_length_operand\"     \"   rK\")\n+\t     (match_operand 6 \"const_int_operand\"         \"    i\")\n+\t     (match_operand 7 \"const_int_operand\"         \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"         \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (unspec:VNX32_QH\n+\t    [(match_operand 3 \"pmode_register_operand\"    \"    r\")\n+\t     (mem:BLK (scratch))\n+\t     (match_operand:VNX32_QHI 4 \"register_operand\"  \" vr\")] ORDER)\n+\t  (match_operand:VNX32_QH 2 \"vector_merge_operand\"  \"0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vl<order>xei<VNX32_QHI:sew>.v\\t%0,(%3),%4%p1\"\n+  [(set_attr \"type\" \"vld<order>x\")\n+   (set_attr \"mode\" \"<VNX32_QH:MODE>\")])\n+\n+(define_insn \"@pred_indexed_<order>store<VNX32_QH:mode><VNX32_QHI:mode>\"\n+  [(set (mem:BLK (scratch))\n+\t(unspec:BLK\n+\t  [(unspec:<VM>\n+\t    [(match_operand:<VM> 0 \"vector_mask_operand\" \"vmWc1\")\n+\t     (match_operand 4 \"vector_length_operand\"    \"   rK\")\n+\t     (match_operand 5 \"const_int_operand\"        \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t   (match_operand 1 \"pmode_register_operand\"      \"   r\")\n+\t   (match_operand:VNX32_QHI 2 \"register_operand\"  \"  vr\")\n+\t   (match_operand:VNX32_QH 3 \"register_operand\"   \"  vr\")] ORDER))]\n+  \"TARGET_VECTOR\"\n+  \"vs<order>xei<VNX32_QHI:sew>.v\\t%3,(%1),%2%p0\"\n+  [(set_attr \"type\" \"vst<order>x\")\n+   (set_attr \"mode\" \"<VNX32_QH:MODE>\")])\n+\n+(define_insn \"@pred_indexed_<order>load<VNX64_Q:mode><VNX64_Q:mode>\"\n+  [(set (match_operand:VNX64_Q 0 \"register_operand\"      \"=&vr\")\n+\t(if_then_else:VNX64_Q\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"  \"vmWc1\")\n+\t     (match_operand 5 \"vector_length_operand\"     \"   rK\")\n+\t     (match_operand 6 \"const_int_operand\"         \"    i\")\n+\t     (match_operand 7 \"const_int_operand\"         \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"         \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (unspec:VNX64_Q\n+\t    [(match_operand 3 \"pmode_register_operand\"    \"    r\")\n+\t     (mem:BLK (scratch))\n+\t     (match_operand:VNX64_Q 4 \"register_operand\"    \" vr\")] ORDER)\n+\t  (match_operand:VNX64_Q 2 \"vector_merge_operand\"   \"0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vl<order>xei<VNX64_Q:sew>.v\\t%0,(%3),%4%p1\"\n+  [(set_attr \"type\" \"vld<order>x\")\n+   (set_attr \"mode\" \"<VNX64_Q:MODE>\")])\n+\n+(define_insn \"@pred_indexed_<order>store<VNX64_Q:mode><VNX64_Q:mode>\"\n+  [(set (mem:BLK (scratch))\n+\t(unspec:BLK\n+\t  [(unspec:<VM>\n+\t    [(match_operand:<VM> 0 \"vector_mask_operand\" \"vmWc1\")\n+\t     (match_operand 4 \"vector_length_operand\"    \"   rK\")\n+\t     (match_operand 5 \"const_int_operand\"        \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t   (match_operand 1 \"pmode_register_operand\"      \"   r\")\n+\t   (match_operand:VNX64_Q 2 \"register_operand\"    \"  vr\")\n+\t   (match_operand:VNX64_Q 3 \"register_operand\"    \"  vr\")] ORDER))]\n+  \"TARGET_VECTOR\"\n+  \"vs<order>xei<VNX64_Q:sew>.v\\t%3,(%1),%2%p0\"\n+  [(set_attr \"type\" \"vst<order>x\")\n+   (set_attr \"mode\" \"<VNX64_Q:MODE>\")])"}, {"sha": "c582490c0847e99867544b9ef86100b9842e0660", "filename": "gcc/config/rs6000/rs6000-overload.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Frs6000%2Frs6000-overload.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Frs6000%2Frs6000-overload.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-overload.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -5930,7 +5930,7 @@\n   unsigned int __builtin_vec_scalar_test_data_class_sp (float, const int);\n     VSTDCSP  VSTDCSP_DEPR1\n \n-[VEC_VSUBCUQ, vec_vsubcuqP, __builtin_vec_vsubcuq]\n+[VEC_VSUBCUQ, vec_vsubcuq, __builtin_vec_vsubcuq]\n   vsq __builtin_vec_vsubcuq (vsq, vsq);\n     VSUBCUQ  VSUBCUQ_DEPR1\n   vuq __builtin_vec_vsubcuq (vuq, vuq);"}, {"sha": "16ca3a31757dffa71c9e4c967bdb8b0fa7e4a483", "filename": "gcc/config/rs6000/rs6000.cc", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Frs6000%2Frs6000.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Frs6000%2Frs6000.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -28928,9 +28928,9 @@ constant_generates_xxspltidp (vec_const_128bit_type *vsx_const)\n    __vector_pair built-in types.  They are target specific and\n    only available when MMA is supported.  With MMA supported, it\n    simply returns true, otherwise it checks if the given gimple\n-   STMT is an assignment or asm stmt and uses either of these two\n-   opaque types unexpectedly, if yes, it would raise an error\n-   message and returns true, otherwise it returns false.  */\n+   STMT is an assignment, asm or call stmt and uses either of\n+   these two opaque types unexpectedly, if yes, it would raise\n+   an error message and returns true, otherwise it returns false.  */\n \n bool\n rs6000_opaque_type_invalid_use_p (gimple *stmt)\n@@ -28959,7 +28959,7 @@ rs6000_opaque_type_invalid_use_p (gimple *stmt)\n   if (stmt)\n     {\n       /* The usage of MMA opaque types is very limited for now,\n-\t to check with gassign and gasm is enough so far.  */\n+\t to check with gassign, gasm and gcall is enough so far.  */\n       if (gassign *ga = dyn_cast<gassign *> (stmt))\n \t{\n \t  tree lhs = gimple_assign_lhs (ga);\n@@ -28988,6 +28988,17 @@ rs6000_opaque_type_invalid_use_p (gimple *stmt)\n \t\treturn true;\n \t    }\n \t}\n+      else if (gcall *gc = dyn_cast<gcall *> (stmt))\n+\t{\n+\t  unsigned nargs = gimple_call_num_args (gc);\n+\t  for (unsigned i = 0; i < nargs; i++)\n+\t    {\n+\t      tree arg = gimple_call_arg (gc, i);\n+\t      tree type = TREE_TYPE (arg);\n+\t      if (check_and_error_invalid_use (type))\n+\t\treturn true;\n+\t    }\n+\t}\n     }\n \n   return false;"}, {"sha": "6e9c80f7283307a1e52bcb70cb55272d3ef20e90", "filename": "gcc/config/s390/s390-d.cc", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fs390%2Fs390-d.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fs390%2Fs390-d.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-d.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -30,10 +30,11 @@ along with GCC; see the file COPYING3.  If not see\n void\n s390_d_target_versions (void)\n {\n-  if (TARGET_ZARCH)\n-    d_add_builtin_version (\"SystemZ\");\n-  else if (TARGET_64BIT)\n-    d_add_builtin_version (\"S390X\");\n+  if (TARGET_64BIT)\n+    {\n+      d_add_builtin_version (\"S390X\");\n+      d_add_builtin_version (\"SystemZ\");\n+    }\n   else\n     d_add_builtin_version (\"S390\");\n "}, {"sha": "616f9b91212dea9b2c39257a5cb14c51a552f74d", "filename": "gcc/config/sol2.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fsol2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fsol2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsol2.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -295,7 +295,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #undef  ENDFILE_SPEC\n #define ENDFILE_SPEC \\\n-  \"%{Ofast|ffast-math|funsafe-math-optimizations:crtfastmath.o%s} \\\n+  \"%{Ofast|ffast-math|funsafe-math-optimizations:%{!shared:crtfastmath.o%s}} \\\n    %(endfile_arch) %(endfile_vtv) %(endfile_crtend) crtn.o%s\"\n \n #undef LINK_ARCH32_SPEC_BASE"}, {"sha": "f77203c9f0a226073eaf0713d849a63d08fdb4a4", "filename": "gcc/config/sparc/freebsd.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fsparc%2Ffreebsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fsparc%2Ffreebsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Ffreebsd.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -127,7 +127,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #undef ENDFILE_SPEC\n #define ENDFILE_SPEC\t\t\t\t\t\t\\\n-  \"%{Ofast|ffast-math|funsafe-math-optimizations:crtfastmath.o%s} \"\t\\\n+  \"%{Ofast|ffast-math|funsafe-math-optimizations:%{!shared:crtfastmath.o%s}} \"\t\\\n   FBSD_ENDFILE_SPEC\n \n /* We use GNU ld so undefine this so that attribute((init_priority)) works.  */"}, {"sha": "0e33b3cac2cf32cb0f4067104a4360d2c0c19a97", "filename": "gcc/config/sparc/linux.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fsparc%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fsparc%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flinux.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -30,7 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #undef  ENDFILE_SPEC\n #define ENDFILE_SPEC \\\n   GNU_USER_TARGET_ENDFILE_SPEC \\\n-  \"%{Ofast|ffast-math|funsafe-math-optimizations:crtfastmath.o%s}\"\n+  \"%{Ofast|ffast-math|funsafe-math-optimizations:%{!shared:crtfastmath.o%s}}\"\n \n /* -mcpu=native handling only makes sense with compiler running on\n    a SPARC chip.  */"}, {"sha": "f1cc0a19e493fb1e2eabc34c60c6183b1ee88bcc", "filename": "gcc/config/sparc/linux64.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fsparc%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fsparc%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flinux64.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -47,7 +47,7 @@ along with GCC; see the file COPYING3.  If not see\n #undef\tENDFILE_SPEC\n #define ENDFILE_SPEC \\\n   GNU_USER_TARGET_ENDFILE_SPEC \\\n-  \"%{Ofast|ffast-math|funsafe-math-optimizations:crtfastmath.o%s}\"\n+  \"%{Ofast|ffast-math|funsafe-math-optimizations:%{!shared:crtfastmath.o%s}}\"\n \n /* The default code model.  */\n #undef SPARC_DEFAULT_CMODEL"}, {"sha": "0d6a9af5dfe1c3ccfe998833bd34bccdb5c6f9d7", "filename": "gcc/config/sparc/sp-elf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fsparc%2Fsp-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fsparc%2Fsp-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsp-elf.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -32,7 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #undef ENDFILE_SPEC\n #define ENDFILE_SPEC \\\n-  \"%{Ofast|ffast-math|funsafe-math-optimizations:crtfastmath.o%s} \\\n+  \"%{Ofast|ffast-math|funsafe-math-optimizations:%{!shared:crtfastmath.o%s}} \\\n    crtend.o%s crtn.o%s\"\n \n /* Don't set the target flags, this is done by the linker script */"}, {"sha": "11c95046448273d4992ef2f86e0b71b20b26fd27", "filename": "gcc/config/sparc/sp64-elf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fsparc%2Fsp64-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fsparc%2Fsp64-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsp64-elf.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -44,7 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #undef ENDFILE_SPEC\n #define ENDFILE_SPEC \\\n-  \"%{Ofast|ffast-math|funsafe-math-optimizations:crtfastmath.o%s} \\\n+  \"%{Ofast|ffast-math|funsafe-math-optimizations:%{!shared:crtfastmath.o%s}} \\\n    crtend.o%s crtn.o%s\"\n \n /* Use the default (for now).  */"}, {"sha": "367ba033d66abc89a6eb682647161a6152f98282", "filename": "gcc/config/v850/v850.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fv850%2Fv850.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fv850%2Fv850.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -2865,7 +2865,6 @@ v850_select_section (tree exp,\n     {\n       int is_const;\n       if (!TREE_READONLY (exp)\n-\t  || TREE_SIDE_EFFECTS (exp)\n \t  || !DECL_INITIAL (exp)\n \t  || (DECL_INITIAL (exp) != error_mark_node\n \t      && !TREE_CONSTANT (DECL_INITIAL (exp))))"}, {"sha": "d3996b26cb5c1d1e6b6bba8e3a24ab6b8bc3b246", "filename": "gcc/config/xtensa/xtensa.md", "status": "modified", "additions": 62, "deletions": 36, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.md?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -736,7 +736,31 @@\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr \"length\"\t\"3\")])\n \n-(define_insn \"xorsi3\"\n+(define_expand \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\")))]\n+  \"\"\n+{\n+  if (register_operand (operands[2], SImode))\n+    emit_insn (gen_xorsi3_internal (operands[0], operands[1],\n+\t\t\t\t    operands[2]));\n+  else\n+    {\n+      rtx (*gen_op)(rtx, rtx, rtx);\n+      if (TARGET_DENSITY\n+\t  && CONST_INT_P (operands[2])\n+\t  && INTVAL (operands[2]) == -2147483648L)\n+\tgen_op = gen_addsi3;\n+      else\n+\tgen_op = gen_xorsi3_internal;\n+      emit_insn (gen_op (operands[0], operands[1],\n+\t\t\t force_reg (SImode, operands[2])));\n+    }\n+  DONE;\n+})\n+\n+(define_insn \"xorsi3_internal\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n \t(xor:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n \t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n@@ -2949,45 +2973,47 @@\n {\n   auto_sbitmap bmp (FIRST_PSEUDO_REGISTER);\n   rtx_insn *insn;\n-  rtx reg = gen_rtx_REG (SImode, 0);\n+  rtx reg = gen_rtx_REG (SImode, 0), dest;\n+  unsigned int regno;\n+  sbitmap_iterator iter;\n   bitmap_set_range (bmp, REGNO (operands[0]), REG_NREGS (operands[0]));\n   for (insn = next_nonnote_nondebug_insn_bb (curr_insn);\n        insn; insn = next_nonnote_nondebug_insn_bb (insn))\n-    {\n-      sbitmap_iterator iter;\n-      unsigned int regno;\n-      if (NONJUMP_INSN_P (insn))\n-\t{\n-\t  EXECUTE_IF_SET_IN_BITMAP (bmp, 2, regno, iter)\n-\t    {\n-\t      set_regno_raw (reg, regno, REG_NREGS (reg));\n-\t      if (reg_overlap_mentioned_p (reg, PATTERN (insn)))\n-\t\tbreak;\n-\t    }\n-\t  if (GET_CODE (PATTERN (insn)) == SET)\n-\t    {\n-\t      rtx x = SET_DEST (PATTERN (insn));\n-\t      if (REG_P (x) && HARD_REGISTER_P (x))\n-\t\tbitmap_clear_range (bmp, REGNO (x), REG_NREGS (x));\n-\t      else if (SUBREG_P (x) && HARD_REGISTER_P (SUBREG_REG (x)))\n-\t\t{\n-\t\t  struct subreg_info info;\n-\t\t  subreg_get_info (regno = REGNO (SUBREG_REG (x)),\n-\t\t\t\t   GET_MODE (SUBREG_REG (x)),\n-\t\t\t\t   SUBREG_BYTE (x), GET_MODE (x), &info);\n-\t\t  if (!info.representable_p)\n-\t\t    break;\n-\t\t  bitmap_clear_range (bmp, regno + info.offset, info.nregs);\n-\t\t}\n-\t    }\n-\t  if (bitmap_empty_p (bmp))\n-\t    goto FALLTHRU;\n-\t}\n-      else if (CALL_P (insn))\n+    if (NONJUMP_INSN_P (insn))\n+      {\n \tEXECUTE_IF_SET_IN_BITMAP (bmp, 2, regno, iter)\n-\t if (call_used_or_fixed_reg_p (regno))\n-\t   break;\n-    }\n+\t  {\n+\t    set_regno_raw (reg, regno, REG_NREGS (reg));\n+\t    if (reg_referenced_p (reg, PATTERN (insn)))\n+\t      goto ABORT;\n+\t  }\n+\tif (GET_CODE (PATTERN (insn)) == SET\n+\t    || GET_CODE (PATTERN (insn)) == CLOBBER)\n+\t  {\n+\t    dest = SET_DEST (PATTERN (insn));\n+\t    if (REG_P (dest) && HARD_REGISTER_P (dest))\n+\t      bitmap_clear_range (bmp, REGNO (dest), REG_NREGS (dest));\n+\t    else if (SUBREG_P (dest)\n+\t\t     && HARD_REGISTER_P (SUBREG_REG (dest)))\n+\t      {\n+\t\tstruct subreg_info info;\n+\t\tsubreg_get_info (regno = REGNO (SUBREG_REG (dest)),\n+\t\t\t\t GET_MODE (SUBREG_REG (dest)),\n+\t\t\t\t SUBREG_BYTE (dest), GET_MODE (dest),\n+\t\t\t\t &info);\n+\t\tif (!info.representable_p)\n+\t\t  break;\n+\t\tbitmap_clear_range (bmp, regno + info.offset, info.nregs);\n+\t      }\n+\t  }\n+\tif (bitmap_empty_p (bmp))\n+\t  goto FALLTHRU;\n+      }\n+    else if (CALL_P (insn))\n+      EXECUTE_IF_SET_IN_BITMAP (bmp, 2, regno, iter)\n+\tif (call_used_or_fixed_reg_p (regno))\n+\t  goto ABORT;\n+ABORT:\n   FAIL;\n FALLTHRU:;\n })"}, {"sha": "bb6ddc0f3283de6927b2aaab6003fcd20d07b66d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1,3 +1,120 @@\n+2023-01-26  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/105300\n+\t* parser.cc: Remove unnecessary forward declarations.\n+\t(cp_parser_string_literal): New wrapper.\n+\t(cp_parser_string_literal_common): Renamed from\n+\tcp_parser_string_literal.  Add a bool parameter.  Give an error when\n+\tUDLs are not permitted.\n+\t(cp_parser_userdef_string_literal): New wrapper.\n+\t(finish_userdef_string_literal): Renamed from\n+\tcp_parser_userdef_string_literal.\n+\t(cp_parser_primary_expression): Call cp_parser_userdef_string_literal\n+\tinstead of cp_parser_string_literal.\n+\t(cp_parser_linkage_specification): Move a variable declaration closer\n+\tto its first use.\n+\t(cp_parser_static_assert): Likewise.\n+\t(cp_parser_operator): Call cp_parser_userdef_string_literal instead of\n+\tcp_parser_string_literal.\n+\t(cp_parser_asm_definition): Move a variable declaration closer to its\n+\tfirst use.\n+\t(cp_parser_asm_specification_opt): Move variable declarations closer to\n+\ttheir first use.\n+\t(cp_parser_asm_operand_list): Likewise.\n+\t(cp_parser_asm_clobber_list): Likewise.\n+\n+2023-01-26  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/108503\n+\t* parser.cc (cp_convert_omp_range_for): If cp_finish_decomp has been\n+\tcalled in !processing_template_decl with processing_template_decl\n+\ttemporarily set, clear DECL_HAS_VALUE_EXPR_P on the vars temporarily.\n+\t(cp_finish_omp_range_for): And set it back again here.\n+\n+2023-01-25  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/108525\n+\t* mangle.cc (write_closure_type_name): Don't assume all\n+\tlambda operator() fns are methods.\n+\n+2023-01-24  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/108504\n+\t* parser.cc (cp_lexer_new_main): Pass C_LEX_STRING_NO_JOIN for first\n+\ttoken, too.\n+\n+2023-01-24  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/108526\n+\t* pt.cc (tsubst_function_decl): Handle static lambda.\n+\n+2023-01-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/108474\n+\t* cp-gimplify.cc (cp_fold_r): Revert 2023-01-19 changes.\n+\n+2023-01-24  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/107303\n+\tPR c++/107329\n+\t* cp-gimplify.cc (cp_fold_r) [TARGET_EXPR]: In case of double\n+\tTARGET_EXPR, keep the outer one instead of the inner one.\n+\t(maybe_replace_decl): New.\n+\n+2023-01-23  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/107267\n+\t* cp-gimplify.cc (cp_gimplify_init_expr): Allow unexpected elision\n+\tof trivial types.\n+\n+2023-01-23  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/107797\n+\t* cvt.cc (ocp_convert): copy_warning when creating a new\n+\tCOMPOUND_EXPR.\n+\t* init.cc (build_new_1): Suppress -Wunused-value on\n+\tcompiler-generated COMPOUND_EXPRs.\n+\n+2023-01-23  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/108195\n+\t* call.cc (build_user_type_conversion_1): Check whether the\n+\titerators also find a list ctor.\n+\n+2023-01-23  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/108496\n+\t* decl.cc (grokdeclarator): Check whether DECL_RESULT is already\n+\tset.\n+\n+2023-01-23  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/53288\n+\tDR 1299\n+\t* call.cc (extend_ref_init_temps_1): Handle ptrmem expression.\n+\n+2023-01-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/108437\n+\t* cp-tree.h (keep_unused_object_arg): Declare.\n+\t* call.cc (keep_unused_object_arg): No longer static.\n+\t* tree.cc (build_min_non_dep_op_overload): Handle ARRAY_REF\n+\twith overload being static member function.\n+\n+2023-01-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/53932\n+\t* cp-gimplify.cc (cp_fold_r): During cp_fully_fold_init replace\n+\tDECL_ANON_UNION_VAR_P VAR_DECLs with their corresponding\n+\tDECL_VALUE_EXPR.\n+\n+2023-01-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/105593\n+\t* decl.cc (cp_finish_decl): Check warning_enabled_at\n+\tat the DECL_SOURCE_LOCATION (decl) for OPT_Winit_self instead\n+\tof warn_init_self.\n+\n 2023-01-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/108365"}, {"sha": "5715a7cd1de8aa946c00cb646b8eef55c8eb6a3a", "filename": "gcc/cp/call.cc", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcp%2Fcall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcp%2Fcall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -4581,7 +4581,7 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags,\n   if (tree iters = maybe_init_list_as_range (cand->fn, expr))\n     if (z_candidate *cand2\n \t= build_user_type_conversion_1 (totype, iters, flags, tf_none))\n-      if (cand2->viable == 1)\n+      if (cand2->viable == 1 && !is_list_ctor (cand2->fn))\n \t{\n \t  cand = cand2;\n \t  expr = iters;\n@@ -5187,7 +5187,7 @@ build_operator_new_call (tree fnname, vec<tree, va_gc> **args,\n    or static operator(), in which cases the source expression\n    would be `obj[...]' or `obj(...)'.  */\n \n-static tree\n+tree\n keep_unused_object_arg (tree result, tree obj, tree fn)\n {\n   if (result == NULL_TREE\n@@ -13952,6 +13952,34 @@ static tree\n extend_ref_init_temps_1 (tree decl, tree init, vec<tree, va_gc> **cleanups,\n \t\t\t tree *cond_guard)\n {\n+  /* CWG1299 (C++20): The temporary object to which the reference is bound or\n+     the temporary object that is the complete object of a subobject to which\n+     the reference is bound persists for the lifetime of the reference if the\n+     glvalue to which the reference is bound was obtained through one of the\n+     following:\n+     - a temporary materialization conversion ([conv.rval]),\n+     - ( expression ), where expression is one of these expressions,\n+     - subscripting ([expr.sub]) of an array operand, where that operand is one\n+       of these expressions,\n+     - a class member access ([expr.ref]) using the . operator where the left\n+       operand is one of these expressions and the right operand designates a\n+       non-static data member of non-reference type,\n+     - a pointer-to-member operation ([expr.mptr.oper]) using the .* operator\n+       where the left operand is one of these expressions and the right operand\n+       is a pointer to data member of non-reference type,\n+     - a const_cast ([expr.const.cast]), static_cast ([expr.static.cast]),\n+       dynamic_cast ([expr.dynamic.cast]), or reinterpret_cast\n+       ([expr.reinterpret.cast]) converting, without a user-defined conversion,\n+       a glvalue operand that is one of these expressions to a glvalue that\n+       refers to the object designated by the operand, or to its complete\n+       object or a subobject thereof,\n+     - a conditional expression ([expr.cond]) that is a glvalue where the\n+       second or third operand is one of these expressions, or\n+     - a comma expression ([expr.comma]) that is a glvalue where the right\n+       operand is one of these expressions.  */\n+\n+  /* FIXME several cases are still handled wrong (101572, 81420).  */\n+\n   tree sub = init;\n   tree *p;\n   STRIP_NOPS (sub);\n@@ -13962,6 +13990,16 @@ extend_ref_init_temps_1 (tree decl, tree init, vec<tree, va_gc> **cleanups,\n \t\t\t\t   cond_guard);\n       return init;\n     }\n+  if (TREE_CODE (sub) == POINTER_PLUS_EXPR\n+      && TYPE_PTRDATAMEM_P (TREE_TYPE (tree_strip_nop_conversions\n+\t\t\t\t       (TREE_OPERAND (sub, 1)))))\n+    {\n+      /* A pointer-to-member operation.  */\n+      TREE_OPERAND (sub, 0)\n+\t= extend_ref_init_temps_1 (decl, TREE_OPERAND (sub, 0), cleanups,\n+\t\t\t\t   cond_guard);\n+      return init;\n+    }\n   if (TREE_CODE (sub) == COND_EXPR)\n     {\n       tree cur_cond_guard = NULL_TREE;"}, {"sha": "a35cedd05ccca003d08f8a47e73f7739fd04f6fb", "filename": "gcc/cp/cp-gimplify.cc", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcp%2Fcp-gimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcp%2Fcp-gimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -250,7 +250,10 @@ cp_gimplify_init_expr (tree *expr_p)\n   if (TREE_CODE (from) == TARGET_EXPR)\n     if (tree init = TARGET_EXPR_INITIAL (from))\n       {\n-\tgcc_checking_assert (TARGET_EXPR_ELIDING_P (from));\n+\t/* Make sure that we expected to elide this temporary.  But also allow\n+\t   gimplify_modify_expr_rhs to elide temporaries of trivial type.  */\n+\tgcc_checking_assert (TARGET_EXPR_ELIDING_P (from)\n+\t\t\t     || !TREE_ADDRESSABLE (TREE_TYPE (from)));\n \tif (target_expr_needs_replace (from))\n \t  {\n \t    /* If this was changed by cp_genericize_target_expr, we need to\n@@ -949,6 +952,28 @@ cp_genericize_target_expr (tree *stmt_p)\n   gcc_assert (!DECL_INITIAL (slot));\n }\n \n+/* Similar to if (target_expr_needs_replace) replace_decl, but TP is the\n+   TARGET_EXPR_INITIAL, and this also updates *_SLOT.  We need this extra\n+   replacement when cp_folding TARGET_EXPR to preserve the invariant that\n+   AGGR_INIT_EXPR_SLOT agrees with the enclosing TARGET_EXPR_SLOT.  */\n+\n+bool\n+maybe_replace_decl (tree *tp, tree decl, tree replacement)\n+{\n+  if (!*tp || !VOID_TYPE_P (TREE_TYPE (*tp)))\n+    return false;\n+  tree t = *tp;\n+  while (TREE_CODE (t) == COMPOUND_EXPR)\n+    t = TREE_OPERAND (t, 1);\n+  if (TREE_CODE (t) == AGGR_INIT_EXPR)\n+    replace_decl (&AGGR_INIT_EXPR_SLOT (t), decl, replacement);\n+  else if (TREE_CODE (t) == VEC_INIT_EXPR)\n+    replace_decl (&VEC_INIT_EXPR_SLOT (t), decl, replacement);\n+  else\n+    replace_decl (tp, decl, replacement);\n+  return true;\n+}\n+\n /* Genericization context.  */\n \n struct cp_genericize_data\n@@ -1103,15 +1128,18 @@ cp_fold_r (tree *stmt_p, int *walk_subtrees, void *data_)\n \tcp_genericize_target_expr (stmt_p);\n \n       /* Folding might replace e.g. a COND_EXPR with a TARGET_EXPR; in\n-\t that case, use it in place of this one.  */\n+\t that case, strip it in favor of this one.  */\n       if (tree &init = TARGET_EXPR_INITIAL (stmt))\n \t{\n \t  cp_walk_tree (&init, cp_fold_r, data, NULL);\n+\t  cp_walk_tree (&TARGET_EXPR_CLEANUP (stmt), cp_fold_r, data, NULL);\n \t  *walk_subtrees = 0;\n \t  if (TREE_CODE (init) == TARGET_EXPR)\n \t    {\n-\t      TARGET_EXPR_ELIDING_P (init) = TARGET_EXPR_ELIDING_P (stmt);\n-\t      *stmt_p = init;\n+\t      tree sub = TARGET_EXPR_INITIAL (init);\n+\t      maybe_replace_decl (&sub, TARGET_EXPR_SLOT (init),\n+\t\t\t\t  TARGET_EXPR_SLOT (stmt));\n+\t      init = sub;\n \t    }\n \t}\n       break;"}, {"sha": "9f188724cf2f2944565842d5b02c8167144a6048", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -6599,6 +6599,7 @@ inline tree build_new_op (const op_location_t &loc, enum tree_code code,\n   return build_new_op (loc, code, flags, arg1, arg2, NULL_TREE, NULL_TREE,\n \t\t       NULL, complain);\n }\n+extern tree keep_unused_object_arg\t\t(tree, tree, tree);\n extern tree build_op_call\t\t\t(tree, vec<tree, va_gc> **,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree build_op_subscript\t\t\t(const op_location_t &, tree,"}, {"sha": "17827d06a4a6693e27710394c889756e8765a288", "filename": "gcc/cp/cvt.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcp%2Fcvt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcp%2Fcvt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -711,8 +711,10 @@ ocp_convert (tree type, tree expr, int convtype, int flags,\n \treturn error_mark_node;\n       if (e == TREE_OPERAND (expr, 1))\n \treturn expr;\n-      return build2_loc (EXPR_LOCATION (expr), COMPOUND_EXPR, TREE_TYPE (e),\n-\t\t\t TREE_OPERAND (expr, 0), e);\n+      e = build2_loc (EXPR_LOCATION (expr), COMPOUND_EXPR, TREE_TYPE (e),\n+\t\t      TREE_OPERAND (expr, 0), e);\n+      copy_warning (e, expr);\n+      return e;\n     }\n \n   complete_type (type);"}, {"sha": "d606b31d7a7afeee1d5bbaf31aa074eb7dea3528", "filename": "gcc/cp/decl.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcp%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcp%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -14776,14 +14776,18 @@ grokdeclarator (const cp_declarator *declarator,\n       {\n \t/* If we saw a return type, record its location.  */\n \tlocation_t loc = declspecs->locations[ds_type_spec];\n-\tif (loc != UNKNOWN_LOCATION)\n+\tif (loc == UNKNOWN_LOCATION)\n+\t  /* Build DECL_RESULT in start_preparsed_function.  */;\n+\telse if (!DECL_RESULT (decl))\n \t  {\n \t    tree restype = TREE_TYPE (TREE_TYPE (decl));\n \t    tree resdecl = build_decl (loc, RESULT_DECL, 0, restype);\n \t    DECL_ARTIFICIAL (resdecl) = 1;\n \t    DECL_IGNORED_P (resdecl) = 1;\n \t    DECL_RESULT (decl) = resdecl;\n \t  }\n+\telse if (funcdef_flag)\n+\t  DECL_SOURCE_LOCATION (DECL_RESULT (decl)) = loc;\n       }\n \n     /* Record constancy and volatility on the DECL itself .  There's"}, {"sha": "52e96fbe59088f7e8043e76a5969612a7c75309a", "filename": "gcc/cp/init.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcp%2Finit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcp%2Finit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -3800,6 +3800,8 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n   if (cookie_expr)\n     rval = build2 (COMPOUND_EXPR, TREE_TYPE (rval), cookie_expr, rval);\n \n+  suppress_warning (rval, OPT_Wunused_value);\n+\n   if (rval == data_addr && TREE_CODE (alloc_expr) == TARGET_EXPR)\n     /* If we don't have an initializer or a cookie, strip the TARGET_EXPR\n        and return the call (which doesn't need to be adjusted).  */"}, {"sha": "f2cda3be2cf2f228ce60097dc4a35c929b6862ff", "filename": "gcc/cp/mangle.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcp%2Fmangle.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcp%2Fmangle.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1816,7 +1816,7 @@ write_closure_type_name (const tree type)\n       if (abi_warn_or_compat_version_crosses (18))\n \tG.need_abi_warning = true;\n \n-  write_method_parms (parms, /*method_p=*/1, fn);\n+  write_method_parms (parms, TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE, fn);\n   write_char ('E');\n   if ((LAMBDA_EXPR_SCOPE_SIG_DISCRIMINATOR (lambda)\n        != LAMBDA_EXPR_SCOPE_ONLY_DISCRIMINATOR (lambda))"}, {"sha": "4cdc1cd472f33689aea93d0b3e58f8763e334542", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 117, "deletions": 45, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -705,7 +705,7 @@ cp_lexer_new_main (void)\n   /* It's possible that parsing the first pragma will load a PCH file,\n      which is a GC collection point.  So we have to do that before\n      allocating any memory.  */\n-  cp_lexer_get_preprocessor_token (0, &token);\n+  cp_lexer_get_preprocessor_token (C_LEX_STRING_NO_JOIN, &token);\n   cp_parser_initial_pragma (&token);\n   c_common_no_more_pch ();\n \n@@ -2227,16 +2227,8 @@ pop_unparsed_function_queues (cp_parser *parser)\n \n /* Lexical conventions [gram.lex]  */\n \n-static cp_expr cp_parser_identifier\n-  (cp_parser *);\n-static cp_expr cp_parser_string_literal\n-  (cp_parser *, bool, bool, bool);\n-static cp_expr cp_parser_userdef_char_literal\n-  (cp_parser *);\n-static tree cp_parser_userdef_string_literal\n+static tree finish_userdef_string_literal\n   (tree);\n-static cp_expr cp_parser_userdef_numeric_literal\n-  (cp_parser *);\n \n /* Basic concepts [gram.basic]  */\n \n@@ -4408,11 +4400,15 @@ cp_parser_identifier (cp_parser* parser)\n     return error_mark_node;\n }\n \n-/* Parse a sequence of adjacent string constants.  Returns a\n+/* Worker for cp_parser_string_literal and cp_parser_userdef_string_literal.\n+   Do not call this directly; use either of the above.\n+\n+   Parse a sequence of adjacent string constants.  Return a\n    TREE_STRING representing the combined, nul-terminated string\n    constant.  If TRANSLATE is true, translate the string to the\n    execution character set.  If WIDE_OK is true, a wide string is\n-   invalid here.\n+   valid here.  If UDL_OK is true, a string literal with user-defined\n+   suffix can be used in this context.\n \n    C++98 [lex.string] says that if a narrow string literal token is\n    adjacent to a wide string literal token, the behavior is undefined.\n@@ -4422,9 +4418,11 @@ cp_parser_identifier (cp_parser* parser)\n    This code is largely lifted from lex_string() in c-lex.cc.\n \n    FUTURE: ObjC++ will need to handle @-strings here.  */\n+\n static cp_expr\n-cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok,\n-\t\t\t  bool lookup_udlit = true)\n+cp_parser_string_literal_common (cp_parser *parser, bool translate,\n+\t\t\t\t bool wide_ok, bool udl_ok,\n+\t\t\t\t bool lookup_udlit)\n {\n   tree value;\n   size_t count;\n@@ -4449,6 +4447,12 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok,\n \n   if (cpp_userdef_string_p (tok->type))\n     {\n+      if (!udl_ok)\n+\t{\n+\t  error_at (loc, \"string literal with user-defined suffix \"\n+\t\t    \"is invalid in this context\");\n+\t  return error_mark_node;\n+\t}\n       string_tree = USERDEF_LITERAL_VALUE (tok->u.value);\n       curr_type = cpp_userdef_string_remove_type (tok->type);\n       curr_tok_is_userdef_p = true;\n@@ -4539,6 +4543,12 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok,\n \t  tok = cp_lexer_peek_token (parser->lexer);\n \t  if (cpp_userdef_string_p (tok->type))\n \t    {\n+\t      if (!udl_ok)\n+\t\t{\n+\t\t  error_at (loc, \"string literal with user-defined suffix \"\n+\t\t\t    \"is invalid in this context\");\n+\t\t  return error_mark_node;\n+\t\t}\n \t      string_tree = USERDEF_LITERAL_VALUE (tok->u.value);\n \t      curr_type = cpp_userdef_string_remove_type (tok->type);\n \t      curr_tok_is_userdef_p = true;\n@@ -4608,7 +4618,7 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok,\n \t  tree literal = build_userdef_literal (suffix_id, value,\n \t\t\t\t\t\tOT_NONE, NULL_TREE);\n \t  if (lookup_udlit)\n-\t    value = cp_parser_userdef_string_literal (literal);\n+\t    value = finish_userdef_string_literal (literal);\n \t  else\n \t    value = literal;\n \t}\n@@ -4626,6 +4636,37 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok,\n   return cp_expr (value, loc);\n }\n \n+/* Parse a sequence of adjacent string constants.  Return a TREE_STRING\n+   representing the combined, nul-terminated string constant.  If\n+   TRANSLATE is true, translate the string to the execution character set.\n+   If WIDE_OK is true, a wide string is valid here.\n+\n+   This function issues an error if a user defined string literal is\n+   encountered; use cp_parser_userdef_string_literal if UDLs are allowed.  */\n+\n+static inline cp_expr\n+cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok)\n+{\n+  return cp_parser_string_literal_common (parser, translate, wide_ok,\n+\t\t\t\t\t  /*udl_ok=*/false,\n+\t\t\t\t\t  /*lookup_udlit=*/false);\n+}\n+\n+/* Parse a string literal or user defined string literal.\n+\n+   user-defined-string-literal :\n+     string-literal ud-suffix\n+\n+   If LOOKUP_UDLIT, perform a lookup for a suitable template function.  */\n+\n+static inline cp_expr\n+cp_parser_userdef_string_literal (cp_parser *parser, bool lookup_udlit)\n+{\n+  return cp_parser_string_literal_common (parser, /*translate=*/true,\n+\t\t\t\t\t  /*wide_ok=*/true, /*udl_ok=*/true,\n+\t\t\t\t\t  lookup_udlit);\n+}\n+\n /* Look up a literal operator with the name and the exact arguments.  */\n \n static tree\n@@ -4923,7 +4964,7 @@ cp_parser_userdef_numeric_literal (cp_parser *parser)\n    as arguments.  */\n \n static tree\n-cp_parser_userdef_string_literal (tree literal)\n+finish_userdef_string_literal (tree literal)\n {\n   tree suffix_id = USERDEF_LITERAL_SUFFIX_ID (literal);\n   tree name = cp_literal_operator_id (IDENTIFIER_POINTER (suffix_id));\n@@ -5663,10 +5704,15 @@ cp_parser_primary_expression (cp_parser *parser,\n       /* ??? Should wide strings be allowed when parser->translate_strings_p\n \t is false (i.e. in attributes)?  If not, we can kill the third\n \t argument to cp_parser_string_literal.  */\n-      return (cp_parser_string_literal (parser,\n-\t\t\t\t\tparser->translate_strings_p,\n-\t\t\t\t\ttrue)\n-\t      .maybe_add_location_wrapper ());\n+      if (parser->translate_strings_p)\n+\treturn (cp_parser_userdef_string_literal (parser,\n+\t\t\t\t\t\t  /*lookup_udlit=*/true)\n+\t\t.maybe_add_location_wrapper ());\n+      else\n+\treturn (cp_parser_string_literal (parser,\n+\t\t\t\t\t  /*translate=*/false,\n+\t\t\t\t\t  /*wide_ok=*/true)\n+\t\t.maybe_add_location_wrapper ());\n \n     case CPP_OPEN_PAREN:\n       /* If we see `( { ' then we are looking at the beginning of\n@@ -16222,15 +16268,14 @@ cp_parser_function_specifier_opt (cp_parser* parser,\n static void\n cp_parser_linkage_specification (cp_parser* parser, tree prefix_attr)\n {\n-  tree linkage;\n-\n   /* Look for the `extern' keyword.  */\n   cp_token *extern_token\n     = cp_parser_require_keyword (parser, RID_EXTERN, RT_EXTERN);\n \n   /* Look for the string-literal.  */\n   cp_token *string_token = cp_lexer_peek_token (parser->lexer);\n-  linkage = cp_parser_string_literal (parser, false, false);\n+  tree linkage = cp_parser_string_literal (parser, /*translate=*/false,\n+\t\t\t\t\t   /*wide_ok=*/false);\n \n   /* Transform the literal into an identifier.  If the literal is a\n      wide-character string, or contains embedded NULs, then we can't\n@@ -16360,9 +16405,8 @@ cp_parser_static_assert(cp_parser *parser, bool member_p)\n       cp_parser_require (parser, CPP_COMMA, RT_COMMA);\n \n       /* Parse the string-literal message.  */\n-      message = cp_parser_string_literal (parser,\n-                                \t  /*translate=*/false,\n-                                \t  /*wide_ok=*/true);\n+      message = cp_parser_string_literal (parser, /*translate=*/false,\n+\t\t\t\t\t  /*wide_ok=*/true);\n \n       /* A `)' completes the static assertion.  */\n       if (!parens.require_close (parser))\n@@ -17410,16 +17454,15 @@ cp_parser_operator (cp_parser* parser, location_t start_loc)\n     case CPP_STRING16_USERDEF:\n     case CPP_STRING32_USERDEF:\n       {\n-\tcp_expr str;\n \ttree string_tree;\n \tint sz, len;\n \n \tif (cxx_dialect == cxx98)\n \t  maybe_warn_cpp0x (CPP0X_USER_DEFINED_LITERALS);\n \n \t/* Consume the string.  */\n-\tstr = cp_parser_string_literal (parser, /*translate=*/true,\n-\t\t\t\t      /*wide_ok=*/true, /*lookup_udlit=*/false);\n+\tcp_expr str = cp_parser_userdef_string_literal (parser,\n+\t\t\t\t\t\t\t/*lookup_udlit=*/false);\n \tif (str == error_mark_node)\n \t  return error_mark_node;\n \telse if (TREE_CODE (str) == USERDEF_LITERAL)\n@@ -22072,7 +22115,6 @@ cp_parser_using_directive (cp_parser* parser)\n static void\n cp_parser_asm_definition (cp_parser* parser)\n {\n-  tree string;\n   tree outputs = NULL_TREE;\n   tree inputs = NULL_TREE;\n   tree clobbers = NULL_TREE;\n@@ -22180,7 +22222,8 @@ cp_parser_asm_definition (cp_parser* parser)\n   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n     return;\n   /* Look for the string.  */\n-  string = cp_parser_string_literal (parser, false, false);\n+  tree string = cp_parser_string_literal (parser, /*translate=*/false,\n+\t\t\t\t\t  /*wide_ok=*/false);\n   if (string == error_mark_node)\n     {\n       cp_parser_skip_to_closing_parenthesis (parser, true, false,\n@@ -28655,11 +28698,8 @@ cp_parser_yield_expression (cp_parser* parser)\n static tree\n cp_parser_asm_specification_opt (cp_parser* parser)\n {\n-  cp_token *token;\n-  tree asm_specification;\n-\n   /* Peek at the next token.  */\n-  token = cp_lexer_peek_token (parser->lexer);\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n   /* If the next token isn't the `asm' keyword, then there's no\n      asm-specification.  */\n   if (!cp_parser_is_keyword (token, RID_ASM))\n@@ -28672,7 +28712,9 @@ cp_parser_asm_specification_opt (cp_parser* parser)\n   parens.require_open (parser);\n \n   /* Look for the string-literal.  */\n-  asm_specification = cp_parser_string_literal (parser, false, false);\n+  tree asm_specification = cp_parser_string_literal (parser,\n+\t\t\t\t\t\t     /*translate=*/false,\n+\t\t\t\t\t\t     /*wide_ok=*/false);\n \n   /* Look for the `)'.  */\n   parens.require_close (parser);\n@@ -28705,8 +28747,6 @@ cp_parser_asm_operand_list (cp_parser* parser)\n \n   while (true)\n     {\n-      tree string_literal;\n-      tree expression;\n       tree name;\n \n       if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_SQUARE))\n@@ -28724,13 +28764,15 @@ cp_parser_asm_operand_list (cp_parser* parser)\n       else\n \tname = NULL_TREE;\n       /* Look for the string-literal.  */\n-      string_literal = cp_parser_string_literal (parser, false, false);\n+      tree string_literal = cp_parser_string_literal (parser,\n+\t\t\t\t\t\t      /*translate=*/false,\n+\t\t\t\t\t\t      /*wide_ok=*/false);\n \n       /* Look for the `('.  */\n       matching_parens parens;\n       parens.require_open (parser);\n       /* Parse the expression.  */\n-      expression = cp_parser_expression (parser);\n+      tree expression = cp_parser_expression (parser);\n       /* Look for the `)'.  */\n       parens.require_close (parser);\n \n@@ -28770,10 +28812,10 @@ cp_parser_asm_clobber_list (cp_parser* parser)\n \n   while (true)\n     {\n-      tree string_literal;\n-\n       /* Look for the string literal.  */\n-      string_literal = cp_parser_string_literal (parser, false, false);\n+      tree string_literal = cp_parser_string_literal (parser,\n+\t\t\t\t\t\t      /*translate=*/false,\n+\t\t\t\t\t\t      /*wide_ok=*/false);\n       /* Add it to the list.  */\n       clobbers = tree_cons (NULL_TREE, string_literal, clobbers);\n       /* If the next token is not a `,', then the list is\n@@ -43039,6 +43081,7 @@ cp_convert_omp_range_for (tree &this_pre_body, vec<tree, va_gc> *for_block,\n {\n   tree begin, end, range_temp_decl = NULL_TREE;\n   tree iter_type, begin_expr, end_expr;\n+  bool clear_has_value_expr = false;\n \n   if (processing_template_decl)\n     {\n@@ -43185,6 +43228,8 @@ cp_convert_omp_range_for (tree &this_pre_body, vec<tree, va_gc> *for_block,\n \t      ++processing_template_decl;\n \t      cp_finish_decomp (orig_decl, decomp_first_name, decomp_cnt);\n \t      --processing_template_decl;\n+\t      if (!processing_template_decl)\n+\t\tclear_has_value_expr = true;\n \t    }\n \t}\n     }\n@@ -43193,8 +43238,20 @@ cp_convert_omp_range_for (tree &this_pre_body, vec<tree, va_gc> *for_block,\n   TREE_VEC_ELT (v, 0) = range_temp_decl;\n   TREE_VEC_ELT (v, 1) = end;\n   TREE_VEC_ELT (v, 2) = orig_decl;\n+  if (clear_has_value_expr)\n+    TREE_PUBLIC (v) = 1;\n   for (unsigned i = 0; i < decomp_cnt; i++)\n     {\n+      if (clear_has_value_expr)\n+\t{\n+\t  /* If cp_finish_decomp was called with processing_template_decl\n+\t     temporarily set to 1, then decomp names will have deduced\n+\t     name but the DECL_VALUE_EXPR will be dependent.  Hide those\n+\t     from folding of other loop initializers e.g. for warning\n+\t     purposes until cp_finish_omp_range_for.  */\n+\t  gcc_checking_assert (DECL_HAS_VALUE_EXPR_P (decomp_first_name));\n+\t  DECL_HAS_VALUE_EXPR_P (decomp_first_name) = 0;\n+\t}\n       TREE_VEC_ELT (v, i + 3) = decomp_first_name;\n       decomp_first_name = DECL_CHAIN (decomp_first_name);\n     }\n@@ -43217,6 +43274,18 @@ cp_finish_omp_range_for (tree orig, tree begin)\n     {\n       decomp_first_name = TREE_VEC_ELT (TREE_CHAIN (orig), 3);\n       decomp_cnt = TREE_VEC_LENGTH (TREE_CHAIN (orig)) - 3;\n+      if (TREE_PUBLIC (TREE_CHAIN (orig)))\n+\t{\n+\t  /* Undo temporary clearing of DECL_HAS_VALUE_EXPR_P done\n+\t     by cp_convert_omp_range_for above.  */\n+\t  TREE_PUBLIC (TREE_CHAIN (orig)) = 0;\n+\t  tree d = decomp_first_name;\n+\t  for (unsigned i = 0; i < decomp_cnt; i++)\n+\t    {\n+\t      DECL_HAS_VALUE_EXPR_P (d) = 1;\n+\t      d = DECL_CHAIN (d);\n+\t    }\n+\t}\n       cp_maybe_mangle_decomp (decl, decomp_first_name, decomp_cnt);\n     }\n \n@@ -46345,7 +46414,9 @@ cp_parser_omp_context_selector (cp_parser *parser, tree set, bool has_parms_p)\n \t\t      cp_lexer_consume_token (parser->lexer);\n \t\t    }\n \t\t  else if (cp_lexer_next_token_is (parser->lexer, CPP_STRING))\n-\t\t    value = cp_parser_string_literal (parser, false, false);\n+\t\t    value = cp_parser_string_literal (parser,\n+\t\t\t\t\t\t      /*translate=*/false,\n+\t\t\t\t\t\t      /*wide_ok=*/false);\n \t\t  else\n \t\t    {\n \t\t      cp_parser_error (parser, \"expected identifier or \"\n@@ -49367,7 +49438,8 @@ pragma_lex (tree *value, location_t *loc)\n   if (ret == CPP_PRAGMA_EOL)\n     ret = CPP_EOF;\n   else if (ret == CPP_STRING)\n-    *value = cp_parser_string_literal (the_parser, false, false);\n+    *value = cp_parser_string_literal (the_parser, /*translate=*/false,\n+\t\t\t\t       /*wide_ok=*/false);\n   else\n     {\n       if (ret == CPP_KEYWORD)"}, {"sha": "51fc246ed71ae73ce62c3655aec5c401c95b16ef", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -14306,6 +14306,11 @@ tsubst_function_decl (tree t, tree args, tsubst_flags_t complain,\n   tree ctx = closure ? closure : DECL_CONTEXT (t);\n   bool member = ctx && TYPE_P (ctx);\n \n+  /* If this is a static lambda, remove the 'this' pointer added in\n+     tsubst_lambda_expr now that we know the closure type.  */\n+  if (lambda_fntype && DECL_STATIC_FUNCTION_P (t))\n+    lambda_fntype = static_fn_type (lambda_fntype);\n+\n   if (member && !closure)\n     ctx = tsubst_aggr_type (ctx, args,\n \t\t\t    complain, t, /*entering_scope=*/1);"}, {"sha": "c1da868732b2eaad5d9095e6e5090fa3c6fa1847", "filename": "gcc/cp/tree.cc", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcp%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fcp%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -3693,14 +3693,20 @@ build_min_non_dep_op_overload (enum tree_code op,\n {\n   va_list p;\n   int nargs, expected_nargs;\n-  tree fn, call;\n+  tree fn, call, obj = NULL_TREE;\n \n   non_dep = extract_call_expr (non_dep);\n \n   nargs = call_expr_nargs (non_dep);\n \n   expected_nargs = cp_tree_code_length (op);\n-  if (TREE_CODE (TREE_TYPE (overload)) == METHOD_TYPE)\n+  if (TREE_CODE (TREE_TYPE (overload)) == METHOD_TYPE\n+      /* For ARRAY_REF, operator[] is either a non-static member or newly\n+\t static member, never out of class and for the static member case\n+\t if user uses single index the operator[] needs to have a single\n+\t argument as well, but the function is called with 2 - the object\n+\t it is invoked on and the index.  */\n+      || op == ARRAY_REF)\n     expected_nargs -= 1;\n   if ((op == POSTINCREMENT_EXPR\n        || op == POSTDECREMENT_EXPR)\n@@ -3715,6 +3721,8 @@ build_min_non_dep_op_overload (enum tree_code op,\n   if (TREE_CODE (TREE_TYPE (overload)) == FUNCTION_TYPE)\n     {\n       fn = overload;\n+      if (op == ARRAY_REF)\n+\tobj = va_arg (p, tree);\n       for (int i = 0; i < nargs; i++)\n \t{\n \t  tree arg = va_arg (p, tree);\n@@ -3746,6 +3754,8 @@ build_min_non_dep_op_overload (enum tree_code op,\n   CALL_EXPR_ORDERED_ARGS (call_expr) = CALL_EXPR_ORDERED_ARGS (non_dep);\n   CALL_EXPR_REVERSE_ARGS (call_expr) = CALL_EXPR_REVERSE_ARGS (non_dep);\n \n+  if (obj)\n+    return keep_unused_object_arg (call, obj, overload);\n   return call;\n }\n \n@@ -3759,11 +3769,15 @@ build_min_non_dep_op_overload (tree non_dep, tree overload, tree object,\n   non_dep = extract_call_expr (non_dep);\n \n   unsigned int nargs = call_expr_nargs (non_dep);\n-  gcc_assert (TREE_CODE (TREE_TYPE (overload)) == METHOD_TYPE);\n-  tree binfo = TYPE_BINFO (TREE_TYPE (object));\n-  tree method = build_baselink (binfo, binfo, overload, NULL_TREE);\n-  tree fn = build_min (COMPONENT_REF, TREE_TYPE (overload),\n-\t\t       object, method, NULL_TREE);\n+  tree fn = overload;\n+  if (TREE_CODE (TREE_TYPE (overload)) == METHOD_TYPE)\n+    {\n+      tree binfo = TYPE_BINFO (TREE_TYPE (object));\n+      tree method = build_baselink (binfo, binfo, overload, NULL_TREE);\n+      fn = build_min (COMPONENT_REF, TREE_TYPE (overload),\n+\t\t      object, method, NULL_TREE);\n+      object = NULL_TREE;\n+    }\n   gcc_assert (vec_safe_length (args) == nargs);\n \n   tree call = build_min_non_dep_call_vec (non_dep, fn, args);\n@@ -3774,6 +3788,8 @@ build_min_non_dep_op_overload (tree non_dep, tree overload, tree object,\n   CALL_EXPR_ORDERED_ARGS (call_expr) = CALL_EXPR_ORDERED_ARGS (non_dep);\n   CALL_EXPR_REVERSE_ARGS (call_expr) = CALL_EXPR_REVERSE_ARGS (non_dep);\n \n+  if (object)\n+    return keep_unused_object_arg (call, object, overload);\n   return call;\n }\n "}, {"sha": "758805dc5dbaabbf8b1de2d91d718b0fe2d2b382", "filename": "gcc/doc/contrib.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fdoc%2Fcontrib.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fdoc%2Fcontrib.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcontrib.texi?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -634,6 +634,10 @@ and unit testing.\n @item\n Bob Manson for his behind the scenes work on dejagnu.\n \n+@item\n+Jose E. Marchesi for contributing the eBPF backend and his ongoing\n+work maintaining it.\n+\n @item\n John Marino for contributing the DragonFly BSD port.\n "}, {"sha": "5a026c4b48cee57e361c1d34bfd3b582149bb2fa", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -688,7 +688,7 @@ myprintf (FILE *f, const char *format, ...)\n @end smallexample\n @end deftypefn\n \n-@deftypefn {Built-in Function} {size_t} __builtin_va_arg_pack_len ()\n+@deftypefn {Built-in Function} {int} __builtin_va_arg_pack_len ()\n This built-in function returns the number of anonymous arguments of\n an inline function.  It can be used only in inline functions that\n are always inlined, never compiled as a separate function, such\n@@ -1578,7 +1578,7 @@ locates data in flash but\n accesses to these data read from generic address space, i.e.@:\n from RAM,\n so that you need special accessors like @code{pgm_read_byte}\n-from @w{@uref{http://nongnu.org/avr-libc/user-manual/,AVR-LibC}}\n+from @w{@uref{https://www.nongnu.org/avr-libc/user-manual/,AVR-LibC}}\n together with attribute @code{progmem}.\n \n @noindent\n@@ -10402,8 +10402,10 @@ ensures that modifying @var{a} does not affect the address referenced by\n is undefined if @var{a} is modified before using @var{b}.\n \n @code{asm} supports operand modifiers on operands (for example @samp{%k2} \n-instead of simply @samp{%2}). Typically these qualifiers are hardware \n-dependent. The list of supported modifiers for x86 is found at \n+instead of simply @samp{%2}). @ref{GenericOperandmodifiers,\n+Generic Operand modifiers} lists the modifiers that are available\n+on all targets.  Other modifiers are hardware dependent.\n+For example, the list of supported modifiers for x86 is found at\n @ref{x86Operandmodifiers,x86 Operand modifiers}.\n \n If the C code that follows the @code{asm} makes no use of any of the output \n@@ -10671,8 +10673,10 @@ optimizers may discard the @code{asm} statement as unneeded\n (see @ref{Volatile}).\n \n @code{asm} supports operand modifiers on operands (for example @samp{%k2} \n-instead of simply @samp{%2}). Typically these qualifiers are hardware \n-dependent. The list of supported modifiers for x86 is found at \n+instead of simply @samp{%2}). @ref{GenericOperandmodifiers,\n+Generic Operand modifiers} lists the modifiers that are available\n+on all targets.  Other modifiers are hardware dependent.\n+For example, the list of supported modifiers for x86 is found at\n @ref{x86Operandmodifiers,x86 Operand modifiers}.\n \n In this example using the fictitious @code{combine} instruction, the \n@@ -11024,6 +11028,30 @@ lab:\n @}\n @end example\n \n+@anchor{GenericOperandmodifiers}\n+@subsubsection Generic Operand Modifiers\n+@noindent\n+The following table shows the modifiers supported by all targets and their effects:\n+\n+@multitable {Modifier} {Description} {Example}\n+@headitem Modifier @tab Description @tab Example\n+@item @code{c}\n+@tab Require a constant operand and print the constant expression with no punctuation.\n+@tab @code{%c0}\n+@item @code{n}\n+@tab Like @samp{%c} except that the value of the constant is negated before printing.\n+@tab @code{%n0}\n+@item @code{a}\n+@tab Substitute a memory reference, with the actual operand treated as the address.\n+This may be useful when outputting a ``load address'' instruction, because\n+often the assembler syntax for such an instruction requires you to write the\n+operand as if it were a memory reference.\n+@tab @code{%a0}\n+@item @code{l}\n+@tab Print the label name with no punctuation.\n+@tab @code{%l0}\n+@end multitable\n+\n @anchor{x86Operandmodifiers}\n @subsubsection x86 Operand Modifiers\n \n@@ -11374,6 +11402,21 @@ constant.  Used to select the specified bit position.\n @item @code{x} @tab Equivialent to @code{X}, but only for pointers.\n @end multitable\n \n+@anchor{loongarchOperandmodifiers}\n+@subsubsection LoongArch Operand Modifiers\n+\n+The list below describes the supported modifiers and their effects for LoongArch.\n+\n+@multitable @columnfractions .10 .90\n+@headitem Modifier @tab Description\n+@item @code{d} @tab Same as @code{c}.\n+@item @code{i} @tab Print the character ''@code{i}'' if the operand is not a register.\n+@item @code{m} @tab Same as @code{c}, but the printed value is @code{operand - 1}.\n+@item @code{X} @tab Print a constant integer operand in hexadecimal.\n+@item @code{z} @tab Print the operand in its unmodified form, followed by a comma.\n+@end multitable\n+\n+\n @lowersections\n @include md.texi\n @raisesections"}, {"sha": "af1a9c1d1965b115dbdf325cce17743eb094db74", "filename": "gcc/doc/include/fdl.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fdoc%2Finclude%2Ffdl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fdoc%2Finclude%2Ffdl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finclude%2Ffdl.texi?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -7,7 +7,7 @@ gpl(7), fsf-funding(7).\n @c man end\n @c man begin COPYRIGHT\n Copyright @copyright{} 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.\n-@uref{https://fsf.org/}\n+@uref{https://www.fsf.org}\n \n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n@@ -46,7 +46,7 @@ of this license document, but changing it is not allowed.\n \n @display\n Copyright @copyright{} 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.\n-@uref{https://fsf.org/}\n+@uref{https://www.fsf.org}\n \n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed."}, {"sha": "b1861a6a437ec5a5fbe81d7ee94434b5942dde58", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -3855,7 +3855,7 @@ Instead of GNU Binutils, you will need to install LLVM 13.0.1, or later, and cop\n @file{bin/llvm-ar} to both @file{bin/amdgcn-amdhsa-ar} and\n @file{bin/amdgcn-amdhsa-ranlib}.\n \n-Use Newlib (3.2.0, or newer).\n+Use Newlib (4.3.0 or newer).\n \n To run the binaries, install the HSA Runtime from the\n @uref{https://rocm.github.io,,ROCm Platform}, and use\n@@ -4672,7 +4672,7 @@ Instead of GNU binutils, you will need to install\n Tell GCC where to find it:\n @option{--with-build-time-tools=[install-nvptx-tools]/nvptx-none/bin}.\n \n-You will need newlib 3.1.0 or later.  It can be\n+You will need newlib 4.3.0 or later.  It can be\n automatically built together with GCC@.  For this, add a symbolic link\n to nvptx-newlib's @file{newlib} directory to the directory containing\n the GCC sources."}, {"sha": "d12f318adfdcf8233158620639dfa7028413e9ff", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 63, "deletions": 18, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -850,7 +850,9 @@ Objective-C and Objective-C++ Dialects}.\n -mcmse @gol\n -mfix-cmse-cve-2021-35465 @gol\n -mstack-protector-guard=@var{guard} -mstack-protector-guard-offset=@var{offset} @gol\n--mfdpic}\n+-mfdpic @gol\n+-mbranch-protection=@var{none}|@var{standard}|@var{pac-ret}[+@var{leaf}]\n+[+@var{bti}]|@var{bti}[+@var{pac-ret}[+@var{leaf}]]}\n \n @emph{AVR Options}\n @gccoptlist{-mmcu=@var{mcu}  -mabsdata  -maccumulate-args @gol\n@@ -16561,7 +16563,7 @@ this can be achieved with @samp{setarch `uname -m` -R ./prog}.\n @item -fsanitize=kernel-address\n @opindex fsanitize=kernel-address\n Enable AddressSanitizer for Linux kernel.\n-See @uref{https://github.com/google/kasan} for more details.\n+See @uref{https://github.com/google/kernel-sanitizers} for more details.\n \n @item -fsanitize=hwaddress\n @opindex fsanitize=hwaddress\n@@ -17694,8 +17696,9 @@ needs to build supplementary stub code for constructors to work.  On\n multi-libbed systems, @samp{gcc -shared} must select the correct support\n libraries to link against.  Failing to supply the correct flags may lead\n to subtle defects.  Supplying them in cases where they are not necessary\n-is innocuous. For x86, crtfastmath.o will not be added when\n-@option{-shared} is specified. }\n+is innocuous.  @option{-shared} suppresses the addition of startup code\n+to alter the floating-point environment as done with @option{-ffast-math},\n+@option{-Ofast} or @option{-funsafe-math-optimizations} on some targets.}\n \n @item -shared-libgcc\n @itemx -static-libgcc\n@@ -22020,6 +22023,9 @@ Disable the floating-point extension.\n @item +cdecp0, +cdecp1, ... , +cdecp7\n Enable the Custom Datapath Extension (CDE) on selected coprocessors according\n to the numbers given in the options in the range 0 to 7.\n+\n+@item +pacbti\n+Enable the Pointer Authentication and Branch Target Identification Extension.\n @end table\n \n @item  armv8-m.main\n@@ -22092,8 +22098,8 @@ Permissible names are: @samp{arm7tdmi}, @samp{arm7tdmi-s}, @samp{arm710t},\n @samp{cortex-r7}, @samp{cortex-r8}, @samp{cortex-r52}, @samp{cortex-r52plus},\n @samp{cortex-m0}, @samp{cortex-m0plus}, @samp{cortex-m1}, @samp{cortex-m3},\n @samp{cortex-m4}, @samp{cortex-m7}, @samp{cortex-m23}, @samp{cortex-m33},\n-@samp{cortex-m35p}, @samp{cortex-m55}, @samp{cortex-x1}, @samp{cortex-x1c},\n-@samp{cortex-m1.small-multiply}, @samp{cortex-m0.small-multiply},\n+@samp{cortex-m35p}, @samp{cortex-m55}, @samp{cortex-m85}, @samp{cortex-x1},\n+@samp{cortex-x1c}, @samp{cortex-m1.small-multiply}, @samp{cortex-m0.small-multiply},\n @samp{cortex-m0plus.small-multiply}, @samp{exynos-m1}, @samp{marvell-pj4},\n @samp{neoverse-n1}, @samp{neoverse-n2}, @samp{neoverse-v1}, @samp{xscale},\n @samp{iwmmxt}, @samp{iwmmxt2}, @samp{ep9312}, @samp{fa526}, @samp{fa626},\n@@ -22157,17 +22163,22 @@ The following extension options are common to the listed CPUs:\n \n @table @samp\n @item +nodsp\n-Disable the DSP instructions on @samp{cortex-m33}, @samp{cortex-m35p}\n-and @samp{cortex-m55}. Also disable the M-Profile Vector Extension (MVE)\n-integer and single precision floating-point instructions on @samp{cortex-m55}.\n+Disable the DSP instructions on @samp{cortex-m33}, @samp{cortex-m35p},\n+@samp{cortex-m55} and @samp{cortex-m85}. Also disable the M-Profile Vector\n+Extension (MVE) integer and single precision floating-point instructions on\n+@samp{cortex-m55} and @samp{cortex-m85}.\n+\n+@item +nopacbti\n+Disable the Pointer Authentication and Branch Target Identification Extension\n+on @samp{cortex-m85}.\n \n @item +nomve\n Disable the M-Profile Vector Extension (MVE) integer and single precision\n-floating-point instructions on @samp{cortex-m55}.\n+floating-point instructions on @samp{cortex-m55} and @samp{cortex-m85}.\n \n @item +nomve.fp\n Disable the M-Profile Vector Extension (MVE) single precision floating-point\n-instructions on @samp{cortex-m55}.\n+instructions on @samp{cortex-m55} and @samp{cortex-m85}.\n \n @item +cdecp0, +cdecp1, ... , +cdecp7\n Enable the Custom Datapath Extension (CDE) on selected coprocessors according\n@@ -22179,7 +22190,8 @@ Disables the floating-point instructions on @samp{arm9e},\n @samp{arm1020e}, @samp{arm1022e}, @samp{arm926ej-s},\n @samp{arm1026ej-s}, @samp{cortex-r5}, @samp{cortex-r7}, @samp{cortex-r8},\n @samp{cortex-m4}, @samp{cortex-m7}, @samp{cortex-m33}, @samp{cortex-m35p}\n-and @samp{cortex-m55}.\n+@samp{cortex-m4}, @samp{cortex-m7}, @samp{cortex-m33}, @samp{cortex-m35p},\n+@samp{cortex-m55} and @samp{cortex-m85}.\n Disables the floating-point and SIMD instructions on\n @samp{generic-armv7-a}, @samp{cortex-a5}, @samp{cortex-a7},\n @samp{cortex-a8}, @samp{cortex-a9}, @samp{cortex-a12},\n@@ -22519,9 +22531,9 @@ Development Tools Engineering Specification\", which can be found on\n Mitigate against a potential security issue with the @code{VLLDM} instruction\n in some M-profile devices when using CMSE (CVE-2021-365465).  This option is\n enabled by default when the option @option{-mcpu=} is used with\n-@code{cortex-m33}, @code{cortex-m35p}, @code{cortex-m55} or @code{star-mc1}.\n-The option @option{-mno-fix-cmse-cve-2021-35465} can be used to disable\n-the mitigation.\n+@code{cortex-m33}, @code{cortex-m35p}, @code{cortex-m55}, @code{cortex-m85}\n+or @code{star-mc1}. The option @option{-mno-fix-cmse-cve-2021-35465} can be used\n+to disable the mitigation.\n \n @item -mstack-protector-guard=@var{guard}\n @itemx -mstack-protector-guard-offset=@var{offset}\n@@ -22553,6 +22565,39 @@ The opposite @option{-mno-fdpic} option is useful (and required) to\n build the Linux kernel using the same (@code{arm-*-uclinuxfdpiceabi})\n toolchain as the one used to build the userland programs.\n \n+@item -mbranch-protection=@var{none}|@var{standard}|@var{pac-ret}[+@var{leaf}][+@var{bti}]|@var{bti}[+@var{pac-ret}[+@var{leaf}]]\n+@opindex mbranch-protection\n+Enable branch protection features (armv8.1-m.main only).\n+@samp{none} generate code without branch protection or return address\n+signing.\n+@samp{standard[+@var{leaf}]} generate code with all branch protection\n+features enabled at their standard level.\n+@samp{pac-ret[+@var{leaf}]} generate code with return address signing\n+set to its standard level, which is to sign all functions that save\n+the return address to memory.\n+@samp{leaf} When return address signing is enabled, also sign leaf\n+functions even if they do not write the return address to memory.\n++@samp{bti} Add landing-pad instructions at the permitted targets of\n+indirect branch instructions.\n+\n+If the @samp{+pacbti} architecture extension is not enabled, then all\n+branch protection and return address signing operations are\n+constrained to use only the instructions defined in the\n+architectural-NOP space. The generated code will remain\n+backwards-compatible with earlier versions of the architecture, but\n+the additional security can be enabled at run time on processors that\n+support the @samp{PACBTI} extension.\n+\n+Branch target enforcement using BTI can only be enabled at runtime if\n+all code in the application has been compiled with at least\n+@samp{-mbranch-protection=bti}.\n+\n+Any setting other than @samp{none} is supported only on armv8-m.main\n+or later.\n+\n+The default is to generate code without branch protection or return\n+address signing.\n+\n @end table\n \n @node AVR Options\n@@ -32291,7 +32336,7 @@ AES, CLFLUSHOPT, XSAVEC, XSAVES, SGX, AVX512F, AVX512VL, AVX512BW, AVX512DQ,\n AVX512CD, PKU, AVX512VBMI, AVX512IFMA, SHA, AVX512VNNI, GFNI, VAES, AVX512VBMI2,\n VPCLMULQDQ, AVX512BITALG, RDPID, AVX512VPOPCNTDQ, PCONFIG, WBNOINVD, CLWB,\n MOVDIRI, MOVDIR64B, ENQCMD, CLDEMOTE, PTWRITE, WAITPKG, SERIALIZE, TSXLDTRK,\n-UINTR, AMX-BF16, AMX-TILE, AMX-INT8, AVX-VNNI, AVX512FP16 and AVX512BF16\n+UINTR, AMX-BF16, AMX-TILE, AMX-INT8, AVX-VNNI, AVX512-FP16 and AVX512BF16\n instruction set support.\n \n @item alderlake\n@@ -32318,7 +32363,7 @@ AES, CLFLUSHOPT, XSAVEC, XSAVES, SGX, AVX512F, AVX512VL, AVX512BW, AVX512DQ,\n AVX512CD, PKU, AVX512VBMI, AVX512IFMA, SHA, AVX512VNNI, GFNI, VAES, AVX512VBMI2,\n VPCLMULQDQ, AVX512BITALG, RDPID, AVX512VPOPCNTDQ, PCONFIG, WBNOINVD, CLWB,\n MOVDIRI, MOVDIR64B, AVX512VP2INTERSECT, ENQCMD, CLDEMOTE, PTWRITE, WAITPKG,\n-SERIALIZE, TSXLDTRK, UINTR, AMX-BF16, AMX-TILE, AMX-INT8, AVX-VNNI, AVX512FP16,\n+SERIALIZE, TSXLDTRK, UINTR, AMX-BF16, AMX-TILE, AMX-INT8, AVX-VNNI, AVX512-FP16,\n AVX512BF16, AMX-FP16 and PREFETCHI instruction set support.\n \n @item k6\n@@ -33184,7 +33229,7 @@ WBNOINVD, FMA4, PREFETCHW, RDPID, PREFETCHWT1, RDSEED, SGX, XOP, LWP,\n XSAVEOPT, XSAVEC, XSAVES, RTM, HLE, TBM, MWAITX, CLZERO, PKU, AVX512VBMI2,\n GFNI, VAES, WAITPKG, VPCLMULQDQ, AVX512BITALG, MOVDIRI, MOVDIR64B, AVX512BF16,\n ENQCMD, AVX512VPOPCNTDQ, AVX5124FMAPS, AVX512VNNI, AVX5124VNNIW, SERIALIZE,\n-UINTR, HRESET, AMXTILE, AMXINT8, AMXBF16, KL, WIDEKL, AVXVNNI, AVX512FP16,\n+UINTR, HRESET, AMXTILE, AMXINT8, AMXBF16, KL, WIDEKL, AVXVNNI, AVX512-FP16,\n AVXIFMA, AVXVNNIINT8, AVXNECONVERT, CMPCCXADD, AMX-FP16, PREFETCHI, RAOINT or\n CLDEMOTE extended instruction sets. Each has a corresponding @option{-mno-}\n option to disable use of these instructions."}, {"sha": "eb5f54bf90835938ecb09c47c6660d6c08b455c7", "filename": "gcc/doc/lto.texi", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fdoc%2Flto.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fdoc%2Flto.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Flto.texi?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -170,13 +170,11 @@ object files.  This is used at link time to determine the optimization\n level and other settings when they are not explicitly specified at the\n linker command line.\n \n-Currently, GCC does not support combining LTO object files compiled\n-with different set of the command line options into a single binary.\n-At link time, the options given on the command line and the options\n-saved on all the files in a link-time set are applied globally.  No\n-attempt is made at validating the combination of flags (other than the\n-usual validation done by option processing).  This is implemented in\n-@file{lto/lto.cc}:@code{lto_read_all_file_options}.\n+Most options are recorded at a per function level and their setting\n+restored when processing the functions at link time.  Global options\n+are composed from options specified at compile time and link time.\n+How exactly they are combined or mismatches diagnosed is implemented in\n+@file{lto-wrapper.cc}:@code{find_and_merge_options}.\n \n \n @item Symbol table (@code{.gnu.lto_.symtab})"}, {"sha": "f50063c97870be87db32b6b93463f8ea1b5483b7", "filename": "gcc/doc/options.texi", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fdoc%2Foptions.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fdoc%2Foptions.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Foptions.texi?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -161,7 +161,7 @@ the help text to use for @option{--help} (omitted if the second field\n contains the @code{Undocumented} property).\n @end enumerate\n \n-By default, all options beginning with ``f'', ``W'' or ``m'' are\n+By default, all options beginning with ``f'', ``g'', ``W'' or ``m'' are\n implicitly assumed to take a ``no-'' form.  This form should not be\n listed separately.  If an option beginning with one of these letters\n does not have a ``no-'' form, you can use the @code{RejectNegative}\n@@ -239,8 +239,8 @@ and should not be accepted by the driver.\n \n @item RejectNegative\n The option does not have a ``no-'' form.  All options beginning with\n-``f'', ``W'' or ``m'' are assumed to have a ``no-'' form unless this\n-property is used.\n+``f'', ``g'', ``W'' or ``m'' are assumed to have a ``no-'' form unless\n+this property is used.\n \n @item Negative(@var{othername})\n The option will turn off another option @var{othername}, which is"}, {"sha": "df54526464ee5cea4f769ae21213c332513fe23d", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -73,10 +73,10 @@ The runtime support library for atomic operations (e.g.@: for @code{__sync}\n and @code{__atomic}).\n \n @item libbacktrace\n-A library that allows gcc to produce backtraces when it crashes.\n+A library that allows GCC to produce backtraces when it crashes.\n \n @item libcc1\n-A library that allows gdb to make use of the compiler.\n+A library that allows GDB to make use of the compiler.\n \n @item libcody\n A compiler dynamism library to allow communication between compilers and\n@@ -2195,6 +2195,10 @@ ARM target supports options to generate instructions from ARMv8.1-M with\n the Custom Datapath Extension (CDE) and M-Profile Vector Extension (MVE).\n Some multilibs may be incompatible with these options.\n \n+@item arm_pacbti_hw\n+Test system supports executing Pointer Authentication and Branch Target\n+Identification instructions.\n+\n @item arm_prefer_ldrd_strd\n ARM target prefers @code{LDRD} and @code{STRD} instructions over\n @code{LDM} and @code{STM} instructions.\n@@ -2284,6 +2288,12 @@ ARM target generates Thumb-2 code for @code{-mthumb} but does not\n support executing the Armv8.1-M Mainline Low Overhead Loop\n instructions @code{DLS} and @code{LE}.\n \n+@item mbranch_protection_ok\n+ARM target supporting @code{-mbranch-protection=standard}.\n+\n+@item arm_pacbti_hw\n+Test system supports for executing non nop pacbti instructions.\n+\n @end table\n \n @subsubsection AArch64-specific attributes"}, {"sha": "2bcb664eb6babc24d33b7294e88e4a71c5c9c252", "filename": "gcc/doc/standards.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fdoc%2Fstandards.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fdoc%2Fstandards.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fstandards.texi?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -280,7 +280,7 @@ works with the Apple/NeXT Objective-C runtime library.\n There is no formal written standard for Objective-C or Objective-C++@.\n The authoritative manual on traditional Objective-C (1.0) is\n ``Object-Oriented Programming and the Objective-C Language'':\n-@uref{http://www.gnustep.org/@/resources/@/documentation/@/ObjectivCBook.pdf}\n+@uref{https://gnustep.github.io/@/resources/@/documentation/@/ObjectivCBook.pdf}\n is the original NeXTstep document.\n \n The Objective-C exception and synchronization syntax (that is, the\n@@ -318,7 +318,7 @@ available online, see @uref{https://gcc.gnu.org/readings.html}\n @section Go Language\n \n As of the GCC 4.7.1 release, GCC supports the Go 1 language standard,\n-described at @uref{https://golang.org/doc/go1}.\n+described at @uref{https://go.dev/doc/go1}.\n \n @section D language\n "}, {"sha": "099b8fd3f24b243a1f320db71ecb8b4dd24f5914", "filename": "gcc/dominance.cc", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fdominance.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fdominance.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -705,10 +705,12 @@ compute_dom_fast_query_in_region (enum cdi_direction dir,\n }\n \n /* The main entry point into this module.  DIR is set depending on whether\n-   we want to compute dominators or postdominators.  */\n+   we want to compute dominators or postdominators.  If COMPUTE_FAST_QUERY\n+   is false then the DFS numbers allowing for a O(1) dominance query\n+   are not computed.  */\n \n void\n-calculate_dominance_info (cdi_direction dir)\n+calculate_dominance_info (cdi_direction dir, bool compute_fast_query)\n {\n   unsigned int dir_index = dom_convert_dir_to_idx (dir);\n \n@@ -745,7 +747,8 @@ calculate_dominance_info (cdi_direction dir)\n   else\n     checking_verify_dominators (dir);\n \n-  compute_dom_fast_query (dir);\n+  if (compute_fast_query)\n+    compute_dom_fast_query (dir);\n \n   timevar_pop (TV_DOMINANCE);\n }"}, {"sha": "3c5a345f4786ad05d474824fdc37afd9a9ffbbf4", "filename": "gcc/dominance.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fdominance.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fdominance.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -35,7 +35,7 @@ enum dom_state\n   DOM_OK\t\t/* Everything is ok.  */\n };\n \n-extern void calculate_dominance_info (enum cdi_direction);\n+extern void calculate_dominance_info (enum cdi_direction, bool = true);\n extern void calculate_dominance_info_for_region (enum cdi_direction,\n \t\t\t\t\t\t vec<basic_block>);\n extern void free_dominance_info (function *, enum cdi_direction);"}, {"sha": "d1a481be8141b8235f68851cbb364e4ef327082c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1,3 +1,93 @@\n+2023-01-29  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/108450\n+\t* check.cc (gfc_check_minloc_maxloc): Explicitly set argument name.\n+\t(gfc_check_findloc): Ditto.\n+\n+2023-01-29  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR fortran/103506\n+\t* parse.cc (parse_module): Remove use of a bool error value\n+\tthat prevented proper setting of the namespace pointer.\n+\n+2023-01-28  Harald Anlauf  <anlauf@gmx.de>\n+\t    Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR fortran/108527\n+\t* resolve.cc (compare_bound_int): Expression to compare must be of\n+\ttype INTEGER.\n+\t(compare_bound_mpz_t): Likewise.\n+\t(check_dimension): Fix comment on checks applied to array section\n+\tand clean up associated logic.\n+\n+2023-01-28  Harald Anlauf  <anlauf@gmx.de>\n+\n+\tPR fortran/108453\n+\t* match.cc (gfc_match_common): A USE associated name shall not appear\n+\tin a COMMON block (F2018:C8121).\n+\n+2023-01-27  Tobias Burnus  <tobias@codesourcery.com>\n+\n+\tPR fortran/108558\n+\t* trans-openmp.cc (gfc_split_omp_clauses): Handle has_device_addr.\n+\n+2023-01-26  Harald Anlauf  <anlauf@gmx.de>\n+\n+\tPR fortran/108544\n+\t* resolve.cc (check_host_association): Extend host association check\n+\tso that it is not restricted to functions.  Also prevent NULL pointer\n+\tdereference.\n+\n+2023-01-25  Steve Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR fortran/108528\n+\t* array.cc (compare_bounds): Return false instead of generating an\n+\tinternal error on an invalid argument type.\n+\n+2023-01-24  Harald Anlauf  <anlauf@gmx.de>\n+\n+\tPR fortran/108529\n+\t* simplify.cc (simplify_transformation): Do not try to simplify\n+\ttransformational intrinsic when the ARRAY argument has a NULL shape.\n+\n+2023-01-23  Harald Anlauf  <anlauf@gmx.de>\n+\n+\tPR fortran/108502\n+\t* dependency.cc (gfc_check_dependency): Prevent NULL pointer\n+\tdereference while recursively checking expressions.\n+\n+2023-01-23  Harald Anlauf  <anlauf@gmx.de>\n+\n+\tPR fortran/108501\n+\t* interface.cc (get_expr_storage_size): Check array subscript triplets\n+\tthat we actually have integer values before trying to extract with\n+\tmpz_get_si.\n+\n+2023-01-23  Harald Anlauf  <anlauf@gmx.de>\n+\n+\tPR fortran/108420\n+\t* iresolve.cc (check_charlen_present): Preserve character length if\n+\tthere is no array constructor.\n+\n+2023-01-21  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR fortran/102595\n+\t* data.cc (gfc_assign_data_value): Remove check for PARAMETER in DATA.\n+\t* primary.cc (match_variable): Add check for PARAMETER in DATA.\n+\n+2023-01-19  Harald Anlauf  <anlauf@gmx.de>\n+\n+\tPR fortran/108434\n+\t* expr.cc (class_allocatable): Prevent NULL pointer dereference\n+\tor invalid read.\n+\t(class_pointer): Likewise.\n+\n+2023-01-17  Harald Anlauf  <anlauf@gmx.de>\n+\n+\tPR fortran/108421\n+\t* interface.cc (get_expr_storage_size): Check that we actually have\n+\tan integer value before trying to extract it with mpz_get_si.\n+\n 2023-01-12  Tobias Burnus  <tobias@codesourcery.com>\n \n \tPR fortran/107706"}, {"sha": "253af76c872cc1c00e6d5c914fe15d535a487543", "filename": "gcc/fortran/ChangeLog-2022", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffortran%2FChangeLog-2022", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffortran%2FChangeLog-2022", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog-2022?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1,6 +1,6 @@\n 2022-12-30  Steve Kargl  <kargl@gcc.gnu.org>\n \n-\tPR fortran/102595\n+\tPR fortran/102331\n \t* decl.cc (attr_decl1): Guard against NULL pointer.\n \t* parse.cc (match_deferred_characteristics): Include BT_CLASS in check for\n \tderived being undefined."}, {"sha": "be5eb8b6a0f63324628676de082e933128ab727b", "filename": "gcc/fortran/array.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffortran%2Farray.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffortran%2Farray.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -967,7 +967,7 @@ gfc_copy_array_spec (gfc_array_spec *src)\n \n \n /* Returns nonzero if the two expressions are equal.\n-   We should not need to support more than constant values, as that\u2019s what is\n+   We should not need to support more than constant values, as that's what is\n    allowed in derived type component array spec.  However, we may create types\n    with non-constant array spec for dummy variable class container types, for\n    which the _data component holds the array spec of the variable declaration.\n@@ -979,7 +979,7 @@ compare_bounds (gfc_expr *bound1, gfc_expr *bound2)\n   if (bound1 == NULL || bound2 == NULL\n       || bound1->ts.type != BT_INTEGER\n       || bound2->ts.type != BT_INTEGER)\n-    gfc_internal_error (\"gfc_compare_array_spec(): Array spec clobbered\");\n+    return false;\n \n   /* What qualifies as identical bounds?  We could probably just check that the\n      expressions are exact clones.  We avoid rewriting a specific comparison"}, {"sha": "8c1ae8c2f000fc79f381f6a1bf55dec1d0587388", "filename": "gcc/fortran/check.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffortran%2Fcheck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffortran%2Fcheck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -3888,6 +3888,7 @@ gfc_check_minloc_maxloc (gfc_actual_arglist *ap)\n     {\n       b = gfc_get_logical_expr (gfc_logical_4_kind, NULL, 0);\n       ap->next->next->next->next->expr = b;\n+      ap->next->next->next->next->name = gfc_get_string (\"back\");\n     }\n \n   if (m == NULL && d != NULL && d->ts.type == BT_LOGICAL\n@@ -3969,6 +3970,7 @@ gfc_check_findloc (gfc_actual_arglist *ap)\n     {\n       b = gfc_get_logical_expr (gfc_logical_4_kind, NULL, 0);\n       ap->next->next->next->next->next->expr = b;\n+      ap->next->next->next->next->next->name = gfc_get_string (\"back\");\n     }\n \n   if (m == NULL && d != NULL && d->ts.type == BT_LOGICAL"}, {"sha": "d29eb12c1b16a7bc11d7b3ed54c372b4c8e16530", "filename": "gcc/fortran/data.cc", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffortran%2Fdata.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffortran%2Fdata.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdata.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -244,13 +244,6 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index,\n \t\t    \"array-element nor a scalar-structure-component\";\n \n   symbol = lvalue->symtree->n.sym;\n-  if (symbol->attr.flavor == FL_PARAMETER)\n-    {\n-      gfc_error (\"PARAMETER %qs shall not appear in a DATA statement at %L\",\n-\t\t symbol->name, &lvalue->where);\n-      return false;\n-    }\n-\n   init = symbol->value;\n   last_ts = &symbol->ts;\n   last_con = NULL;"}, {"sha": "9117825ee6e898e7c97682b33f9fc75a872aa9de", "filename": "gcc/fortran/dependency.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffortran%2Fdependency.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffortran%2Fdependency.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1292,6 +1292,11 @@ gfc_check_dependency (gfc_expr *expr1, gfc_expr *expr2, bool identical)\n   if (expr1->expr_type != EXPR_VARIABLE)\n     gfc_internal_error (\"gfc_check_dependency: expecting an EXPR_VARIABLE\");\n \n+  /* Prevent NULL pointer dereference while recursively analyzing invalid\n+     expressions.  */\n+  if (expr2 == NULL)\n+    return 0;\n+\n   switch (expr2->expr_type)\n     {\n     case EXPR_OP:"}, {"sha": "3036b1be60f0313ce8765e77e82fedbfad08aaa2", "filename": "gcc/fortran/expr.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffortran%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffortran%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -4996,14 +4996,14 @@ get_union_initializer (gfc_symbol *union_type, gfc_component **map_p)\n static bool\n class_allocatable (gfc_component *comp)\n {\n-  return comp->ts.type == BT_CLASS && CLASS_DATA (comp)\n+  return comp->ts.type == BT_CLASS && comp->attr.class_ok && CLASS_DATA (comp)\n     && CLASS_DATA (comp)->attr.allocatable;\n }\n \n static bool\n class_pointer (gfc_component *comp)\n {\n-  return comp->ts.type == BT_CLASS && CLASS_DATA (comp)\n+  return comp->ts.type == BT_CLASS && comp->attr.class_ok && CLASS_DATA (comp)\n     && CLASS_DATA (comp)->attr.pointer;\n }\n "}, {"sha": "dafe41753b7e3d0718e74fe1335c245e027de685", "filename": "gcc/fortran/interface.cc", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffortran%2Finterface.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffortran%2Finterface.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -2858,7 +2858,8 @@ get_expr_storage_size (gfc_expr *e)\n   if (e->ts.type == BT_CHARACTER)\n     {\n       if (e->ts.u.cl && e->ts.u.cl->length\n-          && e->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n+\t  && e->ts.u.cl->length->expr_type == EXPR_CONSTANT\n+\t  && e->ts.u.cl->length->ts.type == BT_INTEGER)\n \tstrlen = mpz_get_si (e->ts.u.cl->length->value.integer);\n       else if (e->expr_type == EXPR_CONSTANT\n \t       && (e->ts.u.cl == NULL || e->ts.u.cl->length == NULL))\n@@ -2909,34 +2910,39 @@ get_expr_storage_size (gfc_expr *e)\n \n \t    if (ref->u.ar.stride[i])\n \t      {\n-\t\tif (ref->u.ar.stride[i]->expr_type == EXPR_CONSTANT)\n+\t\tif (ref->u.ar.stride[i]->expr_type == EXPR_CONSTANT\n+\t\t    && ref->u.ar.stride[i]->ts.type == BT_INTEGER)\n \t\t  stride = mpz_get_si (ref->u.ar.stride[i]->value.integer);\n \t\telse\n \t\t  return 0;\n \t      }\n \n \t    if (ref->u.ar.start[i])\n \t      {\n-\t\tif (ref->u.ar.start[i]->expr_type == EXPR_CONSTANT)\n+\t\tif (ref->u.ar.start[i]->expr_type == EXPR_CONSTANT\n+\t\t    && ref->u.ar.start[i]->ts.type == BT_INTEGER)\n \t\t  start = mpz_get_si (ref->u.ar.start[i]->value.integer);\n \t\telse\n \t\t  return 0;\n \t      }\n \t    else if (ref->u.ar.as->lower[i]\n-\t\t     && ref->u.ar.as->lower[i]->expr_type == EXPR_CONSTANT)\n+\t\t     && ref->u.ar.as->lower[i]->expr_type == EXPR_CONSTANT\n+\t\t     && ref->u.ar.as->lower[i]->ts.type == BT_INTEGER)\n \t      start = mpz_get_si (ref->u.ar.as->lower[i]->value.integer);\n \t    else\n \t      return 0;\n \n \t    if (ref->u.ar.end[i])\n \t      {\n-\t\tif (ref->u.ar.end[i]->expr_type == EXPR_CONSTANT)\n+\t\tif (ref->u.ar.end[i]->expr_type == EXPR_CONSTANT\n+\t\t    && ref->u.ar.end[i]->ts.type == BT_INTEGER)\n \t\t  end = mpz_get_si (ref->u.ar.end[i]->value.integer);\n \t\telse\n \t\t  return 0;\n \t      }\n \t    else if (ref->u.ar.as->upper[i]\n-\t\t     && ref->u.ar.as->upper[i]->expr_type == EXPR_CONSTANT)\n+\t\t     && ref->u.ar.as->upper[i]->expr_type == EXPR_CONSTANT\n+\t\t     && ref->u.ar.as->upper[i]->ts.type == BT_INTEGER)\n \t      end = mpz_get_si (ref->u.ar.as->upper[i]->value.integer);\n \t    else\n \t      return 0;\n@@ -2977,7 +2983,9 @@ get_expr_storage_size (gfc_expr *e)\n \t\t  || ref->u.ar.as->upper[i] == NULL\n \t\t  || ref->u.ar.as->lower[i] == NULL\n \t\t  || ref->u.ar.as->upper[i]->expr_type != EXPR_CONSTANT\n-\t\t  || ref->u.ar.as->lower[i]->expr_type != EXPR_CONSTANT)\n+\t\t  || ref->u.ar.as->lower[i]->expr_type != EXPR_CONSTANT\n+\t\t  || ref->u.ar.as->upper[i]->ts.type != BT_INTEGER\n+\t\t  || ref->u.ar.as->lower[i]->ts.type != BT_INTEGER)\n \t\treturn 0;\n \n \t      elements\n@@ -2999,7 +3007,9 @@ get_expr_storage_size (gfc_expr *e)\n \t    {\n \t      if (!as->upper[i] || !as->lower[i]\n \t\t  || as->upper[i]->expr_type != EXPR_CONSTANT\n-\t\t  || as->lower[i]->expr_type != EXPR_CONSTANT)\n+\t\t  || as->lower[i]->expr_type != EXPR_CONSTANT\n+\t\t  || as->upper[i]->ts.type != BT_INTEGER\n+\t\t  || as->lower[i]->ts.type != BT_INTEGER)\n \t\treturn 0;\n \n \t      elements = elements"}, {"sha": "33794f0a8587c9d7c962352b1c09fa9da3a7f3a4", "filename": "gcc/fortran/iresolve.cc", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffortran%2Firesolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffortran%2Firesolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -94,9 +94,12 @@ check_charlen_present (gfc_expr *source)\n   else if (source->expr_type == EXPR_ARRAY)\n     {\n       gfc_constructor *c = gfc_constructor_first (source->value.constructor);\n-      source->ts.u.cl->length\n-\t\t= gfc_get_int_expr (gfc_charlen_int_kind, NULL,\n-\t\t\t\t    c->expr->value.character.length);\n+      if (c)\n+\tsource->ts.u.cl->length\n+\t  = gfc_get_int_expr (gfc_charlen_int_kind, NULL,\n+\t\t\t      c->expr->value.character.length);\n+      if (source->ts.u.cl->length == NULL)\n+\tgfc_internal_error (\"check_charlen_present(): length not set\");\n     }\n }\n "}, {"sha": "5eb6d0e1c1dbfffd9fb473f5a259171dc8268bb8", "filename": "gcc/fortran/match.cc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffortran%2Fmatch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffortran%2Fmatch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -5345,6 +5345,16 @@ gfc_match_common (void)\n \t\tgoto cleanup;\n \t    }\n \n+\t  /* F2018:R874:  common-block-object is variable-name [ (array-spec) ]\n+\t     F2018:C8121: A variable-name shall not be a name made accessible\n+\t     by use association.  */\n+\t  if (sym->attr.use_assoc)\n+\t    {\n+\t      gfc_error (\"Symbol %qs at %C is USE associated from module %qs \"\n+\t\t\t \"and cannot occur in COMMON\", sym->name, sym->module);\n+\t      goto cleanup;\n+\t    }\n+\n \t  /* Deal with an optional array specification after the\n \t     symbol name.  */\n \t  m = gfc_match_array_spec (&as, true, true);"}, {"sha": "039e7e7da5314b40e7ee8bed08e025e1b3a5899d", "filename": "gcc/fortran/parse.cc", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffortran%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffortran%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -6502,7 +6502,6 @@ parse_module (void)\n {\n   gfc_statement st;\n   gfc_gsymbol *s;\n-  bool error;\n \n   s = gfc_get_gsymbol (gfc_new_block->name, false);\n   if (s->defined || (s->type != GSYM_UNKNOWN && s->type != GSYM_MODULE))\n@@ -6525,7 +6524,6 @@ parse_module (void)\n \n   st = parse_spec (ST_NONE);\n \n-  error = false;\n loop:\n   switch (st)\n     {\n@@ -6544,16 +6542,11 @@ parse_module (void)\n     default:\n       gfc_error (\"Unexpected %s statement in MODULE at %C\",\n \t\t gfc_ascii_statement (st));\n-\n-      error = true;\n       reject_statement ();\n       st = next_statement ();\n       goto loop;\n     }\n-\n-  /* Make sure not to free the namespace twice on error.  */\n-  if (!error)\n-    s->ns = gfc_current_ns;\n+  s->ns = gfc_current_ns;\n }\n \n "}, {"sha": "28ce5fea8656b8af4153381bb72e7abf29d5fc8e", "filename": "gcc/fortran/primary.cc", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffortran%2Fprimary.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffortran%2Fprimary.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -4076,8 +4076,14 @@ match_variable (gfc_expr **result, int equiv_flag, int host_flag)\n \t  gfc_error (\"Named constant at %C in an EQUIVALENCE\");\n \t  return MATCH_ERROR;\n \t}\n-      /* Otherwise this is checked for and an error given in the\n-\t variable definition context checks.  */\n+      if (gfc_in_match_data())\n+\t{\n+\t  gfc_error (\"PARAMETER %qs shall not appear in a DATA statement at %C\",\n+\t\t      sym->name);\n+\t  return MATCH_ERROR;\n+\t}\n+\t/* Otherwise this is checked for an error given in the\n+\t   variable definition context checks.  */\n       break;\n \n     case FL_PROCEDURE:"}, {"sha": "100b2382e22f9881df44b6c9c221f14fd6bcf248", "filename": "gcc/fortran/resolve.cc", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffortran%2Fresolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffortran%2Fresolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -4575,12 +4575,11 @@ compare_bound_int (gfc_expr *a, int b)\n {\n   int i;\n \n-  if (a == NULL || a->expr_type != EXPR_CONSTANT)\n+  if (a == NULL\n+      || a->expr_type != EXPR_CONSTANT\n+      || a->ts.type != BT_INTEGER)\n     return CMP_UNKNOWN;\n \n-  if (a->ts.type != BT_INTEGER)\n-    gfc_internal_error (\"compare_bound_int(): Bad expression\");\n-\n   i = mpz_cmp_si (a->value.integer, b);\n \n   if (i < 0)\n@@ -4598,12 +4597,11 @@ compare_bound_mpz_t (gfc_expr *a, mpz_t b)\n {\n   int i;\n \n-  if (a == NULL || a->expr_type != EXPR_CONSTANT)\n+  if (a == NULL\n+      || a->expr_type != EXPR_CONSTANT\n+      || a->ts.type != BT_INTEGER)\n     return CMP_UNKNOWN;\n \n-  if (a->ts.type != BT_INTEGER)\n-    gfc_internal_error (\"compare_bound_int(): Bad expression\");\n-\n   i = mpz_cmp (a->value.integer, b);\n \n   if (i < 0)\n@@ -4733,23 +4731,24 @@ check_dimension (int i, gfc_array_ref *ar, gfc_array_spec *as)\n #define AR_END (ar->end[i] ? ar->end[i] : as->upper[i])\n \n \tcompare_result comp_start_end = compare_bound (AR_START, AR_END);\n+\tcompare_result comp_stride_zero = compare_bound_int (ar->stride[i], 0);\n \n \t/* Check for zero stride, which is not allowed.  */\n-\tif (compare_bound_int (ar->stride[i], 0) == CMP_EQ)\n+\tif (comp_stride_zero == CMP_EQ)\n \t  {\n \t    gfc_error (\"Illegal stride of zero at %L\", &ar->c_where[i]);\n \t    return false;\n \t  }\n \n-\t/* if start == len || (stride > 0 && start < len)\n-\t\t\t   || (stride < 0 && start > len),\n+\t/* if start == end || (stride > 0 && start < end)\n+\t\t\t   || (stride < 0 && start > end),\n \t   then the array section contains at least one element.  In this\n \t   case, there is an out-of-bounds access if\n \t   (start < lower || start > upper).  */\n-\tif (compare_bound (AR_START, AR_END) == CMP_EQ\n-\t    || ((compare_bound_int (ar->stride[i], 0) == CMP_GT\n-\t\t || ar->stride[i] == NULL) && comp_start_end == CMP_LT)\n-\t    || (compare_bound_int (ar->stride[i], 0) == CMP_LT\n+\tif (comp_start_end == CMP_EQ\n+\t    || ((comp_stride_zero == CMP_GT || ar->stride[i] == NULL)\n+\t\t&& comp_start_end == CMP_LT)\n+\t    || (comp_stride_zero == CMP_LT\n \t        && comp_start_end == CMP_GT))\n \t  {\n \t    if (compare_bound (AR_START, as->lower[i]) == CMP_LT)\n@@ -6087,7 +6086,6 @@ check_host_association (gfc_expr *e)\n       gfc_find_symbol (e->symtree->name, gfc_current_ns, 1, &sym);\n \n       if (sym && old_sym != sym\n-\t      && sym->ts.type == old_sym->ts.type\n \t      && sym->attr.flavor == FL_PROCEDURE\n \t      && sym->attr.contained)\n \t{\n@@ -6132,6 +6130,9 @@ check_host_association (gfc_expr *e)\n \t\t  return false;\n \t\t}\n \n+\t      if (ref == NULL)\n+\t\treturn false;\n+\n \t      gcc_assert (ref->type == REF_ARRAY);\n \n \t      /* Grab the start expressions from the array ref and"}, {"sha": "20ea38e0007aff82e2a8d53c566d513876f6d97f", "filename": "gcc/fortran/simplify.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffortran%2Fsimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffortran%2Fsimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -720,6 +720,7 @@ simplify_transformation (gfc_expr *array, gfc_expr *dim, gfc_expr *mask,\n   size_zero = gfc_is_size_zero_array (array);\n \n   if (!(is_constant_array_expr (array) || size_zero)\n+      || array->shape == NULL\n       || !gfc_is_constant_expr (dim))\n     return NULL;\n "}, {"sha": "5283d0ce5f30eba8a103c0cb2c1452867786f8ec", "filename": "gcc/fortran/trans-openmp.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffortran%2Ftrans-openmp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffortran%2Ftrans-openmp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -6205,6 +6205,8 @@ gfc_split_omp_clauses (gfc_code *code,\n \t    = code->ext.omp_clauses->lists[OMP_LIST_MAP];\n \t  clausesa[GFC_OMP_SPLIT_TARGET].lists[OMP_LIST_IS_DEVICE_PTR]\n \t    = code->ext.omp_clauses->lists[OMP_LIST_IS_DEVICE_PTR];\n+\t  clausesa[GFC_OMP_SPLIT_TARGET].lists[OMP_LIST_HAS_DEVICE_ADDR]\n+\t    = code->ext.omp_clauses->lists[OMP_LIST_HAS_DEVICE_ADDR];\n \t  clausesa[GFC_OMP_SPLIT_TARGET].device\n \t    = code->ext.omp_clauses->device;\n \t  clausesa[GFC_OMP_SPLIT_TARGET].thread_limit"}, {"sha": "39970b2fcfd920d7d9c9ad730c091f2e7bd567e0", "filename": "gcc/function-tests.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffunction-tests.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Ffunction-tests.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction-tests.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -583,6 +583,7 @@ test_ranges ()\n   push_cfun (fun);\n   range_tests ();\n   range_op_tests ();\n+  relation_tests ();\n \n   build_cfg (fndecl);\n   convert_to_ssa (fndecl);"}, {"sha": "d8130024a8c41e56cb8783da2fa864290f6a7984", "filename": "gcc/gcc.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fgcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fgcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1423,6 +1423,7 @@ static const struct compiler default_compilers[] =\n   {\".r\", \"#Ratfor\", 0, 0, 0},\n   {\".go\", \"#Go\", 0, 1, 0},\n   {\".d\", \"#D\", 0, 1, 0}, {\".dd\", \"#D\", 0, 1, 0}, {\".di\", \"#D\", 0, 1, 0},\n+  {\".mod\", \"#Modula-2\", 0, 0, 0}, {\".m2i\", \"#Modula-2\", 0, 0, 0},\n   /* Next come the entries for C.  */\n   {\".c\", \"@c\", 0, 0, 1},\n   {\"@c\","}, {"sha": "e147ab9db7ad07b545246c180dd3b8fc49d9ce4f", "filename": "gcc/genmatch.cc", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fgenmatch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fgenmatch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -489,6 +489,21 @@ commutative_op (id_base *id)\n       case CFN_FNMS:\n \treturn 0;\n \n+      case CFN_COND_ADD:\n+      case CFN_COND_MUL:\n+      case CFN_COND_MIN:\n+      case CFN_COND_MAX:\n+      case CFN_COND_FMIN:\n+      case CFN_COND_FMAX:\n+      case CFN_COND_AND:\n+      case CFN_COND_IOR:\n+      case CFN_COND_XOR:\n+      case CFN_COND_FMA:\n+      case CFN_COND_FMS:\n+      case CFN_COND_FNMA:\n+      case CFN_COND_FNMS:\n+\treturn 1;\n+\n       default:\n \treturn -1;\n       }"}, {"sha": "094e8c7aff3ec69622cc4f2125b2c0cb2a942fad", "filename": "gcc/gimple-predicate-analysis.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fgimple-predicate-analysis.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fgimple-predicate-analysis.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-predicate-analysis.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -728,11 +728,11 @@ value_sat_pred_p (tree val, tree boundary, tree_code cmpc,\n   if (cmpc != BIT_AND_EXPR)\n     return is_value_included_in (val, boundary, cmpc);\n \n-  wide_int andw = wi::to_wide (val) & wi::to_wide (boundary);\n+  widest_int andw = wi::to_widest (val) & wi::to_widest (boundary);\n   if (exact_p)\n-    return andw == wi::to_wide (val);\n+    return andw == wi::to_widest (val);\n \n-  return andw.to_uhwi ();\n+  return wi::ne_p (andw, 0);\n }\n \n /* Return true if the domain of single predicate expression PRED1"}, {"sha": "9c5359a3fc6ea61ec4298650e4282f364e433e6f", "filename": "gcc/gimple-range-fold.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fgimple-range-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fgimple-range-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1039,6 +1039,9 @@ fold_using_range::relation_fold_and_or (irange& lhs_range, gimple *s,\n   if (!ssa1_dep1 || !ssa1_dep2 || !ssa2_dep1 || !ssa2_dep2)\n     return;\n \n+  if (HONOR_NANS (TREE_TYPE (ssa1_dep1)))\n+    return;\n+\n   // Make sure they are the same dependencies, and detect the order of the\n   // relationship.\n   bool reverse_op2 = true;"}, {"sha": "df7afd2fd78a4502a3606d2de6d8c12bce14e6dc", "filename": "gcc/gimple-ssa-store-merging.cc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fgimple-ssa-store-merging.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fgimple-ssa-store-merging.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1614,7 +1614,7 @@ namespace {\n    then VAL represents the constant and all the other fields are zero, or\n    a memory load, then VAL represents the reference, BASE_ADDR is non-NULL\n    and the other fields also reflect the memory load, or an SSA name, then\n-   VAL represents the SSA name and all the other fields are zero,  */\n+   VAL represents the SSA name and all the other fields are zero.  */\n \n class store_operand_info\n {\n@@ -2309,6 +2309,10 @@ merged_store_group::apply_stores ()\n   if (buf_size <= MOVE_MAX)\n     string_concatenation = false;\n \n+  /* String concatenation only works for byte aligned start and end.  */\n+  if (start % BITS_PER_UNIT != 0 || width % BITS_PER_UNIT != 0)\n+    string_concatenation = false;\n+\n   /* Create a power-of-2-sized buffer for native_encode_expr.  */\n   if (!string_concatenation)\n     buf_size = 1 << ceil_log2 (buf_size);\n@@ -3631,7 +3635,7 @@ split_group (merged_store_group *group, bool allow_unaligned_store,\n \n   /* For bswap framework using sets of stores, all the checking has been done\n      earlier in try_coalesce_bswap and the result always needs to be emitted\n-     as a single store.  Likewise for string concatenation,  */\n+     as a single store.  Likewise for string concatenation.  */\n   if (group->stores[0]->rhs_code == LROTATE_EXPR\n       || group->stores[0]->rhs_code == NOP_EXPR\n       || group->string_concatenation)"}, {"sha": "3ee0a6b1f27dbb4ee893c0d545db9d4120a587d4", "filename": "gcc/ginclude/unwind-arm-common.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fginclude%2Funwind-arm-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fginclude%2Funwind-arm-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Funwind-arm-common.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -127,7 +127,8 @@ extern \"C\" {\n       _UVRSC_VFP = 1,       /* vfp */\n       _UVRSC_FPA = 2,       /* fpa */\n       _UVRSC_WMMXD = 3,     /* Intel WMMX data register */\n-      _UVRSC_WMMXC = 4      /* Intel WMMX control register */\n+      _UVRSC_WMMXC = 4,     /* Intel WMMX control register */\n+      _UVRSC_PAC = 5        /* Armv8.1-M Mainline PAC/AUTH pseudo-register */\n     }\n   _Unwind_VRS_RegClass;\n "}, {"sha": "a4173f42bd8f66fbd0429223eef38486db7edcd8", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1,3 +1,9 @@\n+2023-01-17  Ian Lance Taylor  <iant@golang.org>\n+\n+\tPR go/108426\n+\t* go-gcc.cc (Gcc_backend::Gcc_backend): Define __builtin_ctzl and\n+\t__builtin_clzl.  Patch by Andrew Pinski.\n+\n 2023-01-02  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gccgo.texi: Bump @copyrights-go year."}, {"sha": "07c34a58241b164825cacfe2c94f79c522fed8c1", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -627,6 +627,11 @@ Gcc_backend::Gcc_backend()\n \t\t\t\t\t\tunsigned_type_node,\n \t\t\t\t\t\tNULL_TREE),\n \t\t       builtin_const);\n+  this->define_builtin(BUILT_IN_CTZL, \"__builtin_ctzl\", \"ctzl\",\n+\t\t      build_function_type_list(integer_type_node,\n+\t\t\t\t\t       long_unsigned_type_node,\n+\t\t\t\t\t       NULL_TREE),\n+\t\t      builtin_const);\n   this->define_builtin(BUILT_IN_CTZLL, \"__builtin_ctzll\", \"ctzll\",\n \t\t       build_function_type_list(integer_type_node,\n \t\t\t\t\t\tlong_long_unsigned_type_node,\n@@ -637,6 +642,11 @@ Gcc_backend::Gcc_backend()\n \t\t\t\t\t\tunsigned_type_node,\n \t\t\t\t\t\tNULL_TREE),\n \t\t       builtin_const);\n+  this->define_builtin(BUILT_IN_CLZL, \"__builtin_clzl\", \"clzl\",\n+\t\t      build_function_type_list(integer_type_node,\n+\t\t\t\t\t       long_unsigned_type_node,\n+\t\t\t\t\t       NULL_TREE),\n+\t\t      builtin_const);\n   this->define_builtin(BUILT_IN_CLZLL, \"__builtin_clzll\", \"clzll\",\n \t\t       build_function_type_list(integer_type_node,\n \t\t\t\t\t\tlong_long_unsigned_type_node,"}, {"sha": "e3196df8aa9ded9b1ccee272a252cb0443b4c974", "filename": "gcc/ipa-modref.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fipa-modref.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fipa-modref.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1875,11 +1875,11 @@ modref_access_analysis::analyze ()\n      statement cannot be analyzed (for any reason), the entire function cannot\n      be analyzed by modref.  */\n   basic_block bb;\n+  bitmap always_executed_bbs = find_always_executed_bbs (cfun, true);\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n       gimple_stmt_iterator si;\n-      bool always_executed\n-\t      = bb == single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun))->dest;\n+      bool always_executed = bitmap_bit_p (always_executed_bbs, bb->index);\n \n       for (si = gsi_start_nondebug_after_labels_bb (bb);\n \t   !gsi_end_p (si); gsi_next_nondebug (&si))\n@@ -1926,6 +1926,7 @@ modref_access_analysis::analyze ()\n \t  && !finite_function_p ())\n \tm_summary_lto->side_effects = true;\n     }\n+  BITMAP_FREE (always_executed_bbs);\n }\n \n /* Return true if OP accesses memory pointed to by SSA_NAME.  */"}, {"sha": "81b75910db1be090d967b1c916b32b32c168f969", "filename": "gcc/ipa-sra.cc", "status": "modified", "additions": 36, "deletions": 16, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fipa-sra.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fipa-sra.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-sra.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -2529,7 +2529,8 @@ process_scan_results (cgraph_node *node, struct function *fun,\n      TODO: Measure the overhead and the effect of just being pessimistic.\n      Maybe this is only -O3 material?  */\n \n-  bool pdoms_calculated = false;\n+  hash_map<gimple *, bool> analyzed_stmts;\n+  bitmap always_executed_bbs = NULL;\n   if (check_pass_throughs)\n     for (cgraph_edge *cs = node->callees; cs; cs = cs->next_callee)\n       {\n@@ -2566,27 +2567,46 @@ process_scan_results (cgraph_node *node, struct function *fun,\n \t\tcontinue;\n \t      }\n \n-\t    /* Post-dominator check placed last, hoping that it usually won't\n-\t       be needed.  */\n-\t    if (!pdoms_calculated)\n+\t    /* Walk basic block and see if its execution can terminate earlier.\n+\t       Keep the info for later re-use to avoid quadratic behavoiur here.  */\n+\t    gimple_stmt_iterator gsi = gsi_for_stmt (call_stmt);\n+\t    bool safe = true;\n+\t    int n = 0;\n+\t    for (gsi_prev (&gsi); !gsi_end_p (gsi); gsi_prev (&gsi))\n \t      {\n-\t\tgcc_checking_assert (cfun);\n-\t\tconnect_infinite_loops_to_exit ();\n-\t\tcalculate_dominance_info (CDI_POST_DOMINATORS);\n-\t\tpdoms_calculated = true;\n+\t\tbool *b = analyzed_stmts.get (gsi_stmt (gsi));\n+\t\tif (b)\n+\t\t  {\n+\t\t    safe = *b;\n+\t\t    gsi_next (&gsi);\n+\t\t    break;\n+\t\t  }\n+\t\tn++;\n+\t\tif (stmt_may_terminate_function_p (fun, gsi_stmt (gsi), false))\n+\t\t  {\n+\t\t    safe = false;\n+\t\t    break;\n+\t\t  }\n \t      }\n-\t    if (dominated_by_p (CDI_POST_DOMINATORS,\n-\t\t\t\tgimple_bb (call_stmt),\n-\t\t\t\tsingle_succ (ENTRY_BLOCK_PTR_FOR_FN (fun))))\n+\t    if (n)\n+\t      {\n+\t\tif (gsi_end_p (gsi))\n+\t\t  gsi = gsi_start_bb (gimple_bb (call_stmt));\n+\t\tfor (; gsi_stmt (gsi) != call_stmt; gsi_next (&gsi))\n+\t\t  analyzed_stmts.get_or_insert (gsi_stmt (gsi)) = safe;\n+\t      }\n+\n+\t    if (safe && !always_executed_bbs)\n+\t      {\n+\t\tmark_dfs_back_edges ();\n+\t\talways_executed_bbs = find_always_executed_bbs (fun, false);\n+\t      }\n+\t    if (safe && bitmap_bit_p (always_executed_bbs, gimple_bb (call_stmt)->index))\n \t      csum->m_arg_flow[argidx].safe_to_import_accesses = true;\n \t  }\n \n       }\n-  if (pdoms_calculated)\n-    {\n-      free_dominance_info (CDI_POST_DOMINATORS);\n-      remove_fake_exit_edges ();\n-    }\n+  BITMAP_FREE (always_executed_bbs);\n \n   /* TODO: Add early exit if we disqualified everything.  This also requires\n      that we either relax the restriction that"}, {"sha": "8badcc2c1109414373e89859452a0d6f7501a127", "filename": "gcc/ipa-utils.cc", "status": "modified", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fipa-utils.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fipa-utils.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -35,6 +35,14 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-vrp.h\"\n #include \"ipa-prop.h\"\n #include \"ipa-fnsummary.h\"\n+#include \"tree-eh.h\"\n+#include \"gimple-iterator.h\"\n+#include \"ipa-modref-tree.h\"\n+#include \"ipa-modref.h\"\n+#include \"tree-ssa-loop-niter.h\"\n+#include \"calls.h\"\n+#include \"cfgloop.h\"\n+#include \"cfganal.h\"\n \n /* Debugging function for postorder and inorder code. NOTE is a string\n    that is printed before the nodes are printed.  ORDER is an array of\n@@ -781,3 +789,258 @@ recursive_call_p (tree func, tree dest)\n       return false;\n   return true;\n }\n+\n+/* Return true if stmt may terminate execution of function.\n+   If assume_return_or_eh we can further assume that the function ends\n+   either by retrn statement or EH (no trapping or infinite loops).  */\n+\n+bool\n+stmt_may_terminate_function_p (function *fun, gimple *stmt, bool assume_return_or_eh)\n+{\n+  if (stmt_can_throw_external (fun, stmt))\n+    return true;\n+  if (assume_return_or_eh)\n+    return false;\n+  gasm *astmt = dyn_cast <gasm *> (stmt);\n+  if (astmt && gimple_asm_volatile_p (astmt))\n+    return true;\n+  if (gimple_could_trap_p (stmt))\n+    return true;\n+  if (gcall *call = dyn_cast <gcall *> (stmt))\n+    {\n+      int flags = gimple_call_flags (call);\n+      if (flags & (ECF_PURE | ECF_CONST) && ! (flags & ECF_LOOPING_CONST_OR_PURE))\n+\treturn false;\n+      modref_summary *s = get_modref_function_summary (call, NULL);\n+      if (s && !s->side_effects)\n+\treturn false;\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Return bitmap of all basic blocks whose first statements are known to\n+   execute on every invocation of the function.\n+\n+   If assume_return_or_eh we can further assume that the function ends\n+   either by retrn statement or EH (no trapping or infinite loops).\n+   This is useful when sumarizing function in passes like ipa-modref.\n+ \n+   Seeing assume_return_or_eh to false is used to prove that given\n+   statmeent will be executed even if the function gets into infinite\n+   loop or trap.  */\n+bitmap\n+find_always_executed_bbs (function *fun, bool assume_return_or_eh)\n+{\n+  auto_vec<basic_block, 20> stack;\n+  auto_vec<basic_block, 20> terminating_bbs;\n+  hash_set<basic_block> visited;\n+  hash_set<basic_block> terminating_bbs_set;\n+  edge e;\n+  edge_iterator ei;\n+  int flags = flags_from_decl_or_type (fun->decl);\n+  /* PUre and const functions always return.  */\n+  assume_return_or_eh |= (flags & (ECF_CONST|ECF_PURE)) && !(flags & ECF_LOOPING_CONST_OR_PURE);\n+  if (!assume_return_or_eh)\n+    mark_dfs_back_edges (fun);\n+\n+  /* First walk all BBs reachable from entry stopping on statements that may\n+     terminate execution.  Everything past this statement is not going to be executed\n+     each invocation.  */\n+  stack.safe_push (ENTRY_BLOCK_PTR_FOR_FN (fun));\n+  while (!stack.is_empty ())\n+    {\n+      basic_block bb = stack.pop ();\n+      bool found = false, found_exit = false;\n+      if (bb->index == EXIT_BLOCK)\n+\tcontinue;\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t{\n+\t  if (e->dest == EXIT_BLOCK_PTR_FOR_FN (fun))\n+\t    {\n+\t      found_exit = true;\n+\t      break;\n+\t    }\n+\t  /* Watch for infinite loops.  */\n+\t  if (!found\n+\t      && !assume_return_or_eh && (e->flags & EDGE_DFS_BACK))\n+\t    {\n+\t      if (!dom_info_available_p (CDI_DOMINATORS))\n+\t\tcalculate_dominance_info (CDI_DOMINATORS);\n+\t      /* If this is not a loop latch edge it is an irreducible region.\n+\t\t Assume that it is infinite.\n+\t\t TODO: with C++ forced progression we can still walk the\n+\t\t irreducible region and see if it contains any side effects.\n+\t\t Similarly for loops.  -ffinite-loops does not really imply\n+\t\t this since we allow inlining across -ffinite-loops bondary\n+\t\t and thus it can be used only as a loop flag.  */\n+\t      if (e->dest->loop_father->header != e->dest\n+\t\t  || !dominated_by_p (CDI_DOMINATORS, bb, e->dest))\n+\t\tfound = true;\n+\t      else if (!finite_loop_p (e->dest->loop_father))\n+\t\tfound = true;\n+\t    }\n+\t}\n+      if (!assume_return_or_eh\n+\t  && (EDGE_COUNT (bb->succs) == 0 || (bb->flags & BB_IRREDUCIBLE_LOOP)))\n+\tfound = true;\n+      for (gimple_stmt_iterator si = gsi_start_nondebug_after_labels_bb (bb);\n+\t   !gsi_end_p (si) && !found; gsi_next_nondebug (&si))\n+\tif (stmt_may_terminate_function_p (fun, gsi_stmt (si), assume_return_or_eh))\n+\t  {\n+\t    found = true;\n+\t    break;\n+\t  }\n+      if (found)\n+\t{\n+\t  visited.add (EXIT_BLOCK_PTR_FOR_FN (fun));\n+\t  if (!found_exit)\n+\t    {\n+\t      terminating_bbs.safe_push (bb);\n+\t      terminating_bbs_set.add (bb);\n+\t    }\n+\t}\n+      else\n+\tFOR_EACH_EDGE (e, ei, bb->succs)\n+\t  if (!visited.add (e->dest))\n+\t    stack.safe_push (e->dest);\n+    }\n+\n+  /* Next walk from exit block and find all articulations in the CFG.\n+     Add all terminating basic blocks as \"fake\" predecessors of the\n+     exit block.  */\n+\n+  bitmap ret = BITMAP_ALLOC (NULL);\n+  /* A degenerated case when there is no path to exit.  */\n+  if (!visited.contains (EXIT_BLOCK_PTR_FOR_FN (fun)))\n+    {\n+      bitmap_set_bit (ret,\n+\t\t      single_succ_edge\n+\t\t        (ENTRY_BLOCK_PTR_FOR_FN (fun))->dest->index);\n+      return ret;\n+    }\n+\n+  struct astate\n+  {\n+    unsigned int dfs_preorder;\n+    unsigned int dfs_postorder;\n+\n+    unsigned int low, high;\n+  };\n+\n+  struct worklist\n+  {\n+    basic_block bb;\n+    astate *cstate;\n+  };\n+\n+  struct obstack state_obstack;\n+  gcc_obstack_init (&state_obstack);\n+  hash_map<basic_block, astate *> state;\n+  auto_vec<worklist, 32> worklist_vec;\n+  unsigned int next_dfs_num = 1;\n+\n+  /* Always executed blocks are blocks that are on every path from entry to exit.\n+     We proceed in two steps.  First we do backward DFS walk (so we know that entry\n+     is always reached) and record preorder and postorder visiting times.\n+\n+     In second step we proceed in postorder and for every block A we compute\n+     minimal preorder (A.low) and maximal postorder (A.high) of block reachable\n+     from the BBs in DFS subtree of A.  If A is always executed there are no\n+     edges out of this subtree.  This can be tested by checking that A.low == A.preorder\n+     and B.high == A.postorder.\n+    \n+     This is first step. Do backward DFS walk and record preorder, postorder\n+     and predecessor info.  Initialize stack in postorder.  */\n+  worklist we = {EXIT_BLOCK_PTR_FOR_FN (fun), NULL};\n+  worklist_vec.safe_push (we);\n+  while (!worklist_vec.is_empty ())\n+    {\n+      worklist &w = worklist_vec.last ();\n+      basic_block bb = w.bb;\n+      astate *cstate = w.cstate;\n+\n+      if (!cstate)\n+\t{\n+\t  astate **slot = &state.get_or_insert (bb);\n+\n+\t  cstate = *slot;\n+\t  /* Already processed by DFS?  */\n+\t  if (cstate)\n+\t    {\n+\t      worklist_vec.pop ();\n+\t      continue;\n+\t    }\n+\t  /* DFS is visiting BB for first time.  */\n+\t  *slot = cstate = XOBNEW (&state_obstack, struct astate);\n+\t  cstate->low = cstate->high = cstate->dfs_preorder = next_dfs_num++;\n+\t  w.cstate = cstate;\n+\t  /* Exit block is special; process all fake edges we identified.  */\n+\t  if (bb == EXIT_BLOCK_PTR_FOR_FN (fun))\n+\t    for (basic_block bb2 : terminating_bbs)\n+\t      {\n+\t\tworklist we = {bb2, NULL};\n+\t\tworklist_vec.safe_push (we);\n+\t      }\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n+\t    if (visited.contains (e->src))\n+\t      {\n+\t\tworklist we = {e->src, NULL};\n+\t\tworklist_vec.safe_push (we);\n+\t      }\n+\t  /* Keep BB on worklist so we process it last time.  */\n+\t  continue;\n+\t}\n+      /* We are finished with processing reachable BBs, see if we have articulation.  */\n+      worklist_vec.pop ();\n+      cstate->high = cstate->dfs_postorder = next_dfs_num++;\n+      stack.safe_push (bb);\n+    }\n+  /* This is the final postorder walk.  Determine low and high values and mark\n+     always executed blocks.  */\n+  for (basic_block bb : stack)\n+    {\n+      astate *cstate = *state.get (bb);\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\t{\n+\t  astate **cstate2 = state.get (e->src);\n+\t  /* We skip walking part of CFG reached only after first edge to exit.\n+\t     No BB reachable from the skipped part is always executed */\n+\t  if (!cstate2)\n+\t    {\n+\t      if (e->src != ENTRY_BLOCK_PTR_FOR_FN (fun))\n+\t\tcstate->low = 0;\n+\t      continue;\n+\t    }\n+\t  cstate->low = MIN (cstate->low, (*cstate2)->low);\n+\t  cstate->high = MAX (cstate->high, (*cstate2)->high);\n+\t}\n+      if (dump_file && (dump_flags & TDF_DETAILS) && bb != EXIT_BLOCK_PTR_FOR_FN (fun))\n+\tfprintf (dump_file, \"BB %i %s preorder %i posorder %i low %i high %i\\n\",\n+\t\t bb->index, terminating_bbs_set.contains (bb) ? \"(terminating)\": \"\",\n+\t\t cstate->dfs_preorder, cstate->dfs_postorder, cstate->low, cstate->high);\n+      if (cstate->low == cstate->dfs_preorder && cstate->high == cstate->dfs_postorder\n+\t  && bb != EXIT_BLOCK_PTR_FOR_FN (fun))\n+\tbitmap_set_bit (ret, bb->index);\n+      if (terminating_bbs_set.contains (bb))\n+\tcstate->low = 0;\n+      else\n+\tFOR_EACH_EDGE (e, ei, bb->succs)\n+\t  {\n+\t    astate **cstate2 = state.get (e->dest);\n+\t    if (!cstate2)\n+\t      continue;\n+\t    cstate->low = MIN (cstate->low, (*cstate2)->low);\n+\t    cstate->high = MAX (cstate->high, (*cstate2)->high);\n+\t  }\n+      }\n+  obstack_free (&state_obstack, NULL);\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"Always executed bbbs %s: \",\n+\t       assume_return_or_eh ? \"(assuming return or EH)\": \"\");\n+      bitmap_print (dump_file, ret, \"\", \"\\n\");\n+    }\n+\n+  return ret;\n+}"}, {"sha": "0eefcf40d4401a18d88325212aa1e1a7f23f376b", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -46,6 +46,8 @@ tree get_base_var (tree);\n void ipa_merge_profiles (struct cgraph_node *dst,\n \t\t\t struct cgraph_node *src, bool preserve_body = false);\n bool recursive_call_p (tree, tree);\n+bool stmt_may_terminate_function_p (function *fun, gimple *stmt, bool assume_return_or_eh);\n+bitmap find_always_executed_bbs (function *fun, bool assume_return_or_eh);\n \n /* In ipa-pure-const.cc  */\n bool finite_function_p ();"}, {"sha": "7bffbc07ee2331cd7bd6ad3d075e0c6a3c83a00b", "filename": "gcc/lra-constraints.cc", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Flra-constraints.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Flra-constraints.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -184,12 +184,12 @@ get_try_hard_regno (int regno)\n   return ira_class_hard_regs[rclass][0];\n }\n \n-/* Return the hard regno of X after removing its subreg.  If X is not\n-   a register or a subreg of a register, return -1.  If X is a pseudo,\n-   use its assignment.  If FINAL_P return the final hard regno which will\n-   be after elimination.  */\n+/* Return the hard regno of X after removing its subreg.  If X is not a\n+   register or a subreg of a register, return -1.  If X is a pseudo, use its\n+   assignment.  If X is a hard regno, return the final hard regno which will be\n+   after elimination.  */\n static int\n-get_hard_regno (rtx x, bool final_p)\n+get_hard_regno (rtx x)\n {\n   rtx reg;\n   int hard_regno;\n@@ -203,7 +203,7 @@ get_hard_regno (rtx x, bool final_p)\n     hard_regno = lra_get_regno_hard_regno (hard_regno);\n   if (hard_regno < 0)\n     return -1;\n-  if (final_p)\n+  if (HARD_REGISTER_NUM_P (REGNO (reg)))\n     hard_regno = lra_get_elimination_hard_regno (hard_regno);\n   if (SUBREG_P (x))\n     hard_regno += subreg_regno_offset (hard_regno, GET_MODE (reg),\n@@ -782,7 +782,7 @@ operands_match_p (rtx x, rtx y, int y_hard_regno)\n     {\n       int j;\n \n-      i = get_hard_regno (x, false);\n+      i = get_hard_regno (x);\n       if (i < 0)\n \tgoto slow;\n \n@@ -1920,7 +1920,7 @@ uses_hard_regs_p (rtx x, HARD_REG_SET set)\n \n   if (REG_P (x) || SUBREG_P (x))\n     {\n-      x_hard_regno = get_hard_regno (x, true);\n+      x_hard_regno = get_hard_regno (x);\n       return (x_hard_regno >= 0\n \t      && overlaps_hard_reg_set_p (set, mode, x_hard_regno));\n     }\n@@ -2078,7 +2078,7 @@ process_alt_operands (int only_alternative)\n \n       op = no_subreg_reg_operand[nop] = *curr_id->operand_loc[nop];\n       /* The real hard regno of the operand after the allocation.  */\n-      hard_regno[nop] = get_hard_regno (op, true);\n+      hard_regno[nop] = get_hard_regno (op);\n \n       operand_reg[nop] = reg = op;\n       biggest_mode[nop] = GET_MODE (op);\n@@ -2258,7 +2258,7 @@ process_alt_operands (int only_alternative)\n \t\t\t&& curr_operand_mode[m] != curr_operand_mode[nop])\n \t\t      break;\n \t\t    \n-\t\t    m_hregno = get_hard_regno (*curr_id->operand_loc[m], false);\n+\t\t    m_hregno = get_hard_regno (*curr_id->operand_loc[m]);\n \t\t    /* We are supposed to match a previous operand.\n \t\t       If we do, we win if that one did.  If we do\n \t\t       not, count both of the operands as losers."}, {"sha": "6e9bc21481f9f0c746ee6dfd403337b578a3117f", "filename": "gcc/m2/ChangeLog", "status": "modified", "additions": 352, "deletions": 0, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2FChangeLog?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1,3 +1,355 @@\n+2023-01-28  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\t* lang.opt: Claim Wreturn-type.\n+\n+2023-01-27  Gaius Mulley  <gaiusmod2@gmail.com>\n+\n+\t* gm2-compiler/M2Comp.mod:  Import MetaString0.\n+\t(ExamineCompilationUnit): New variable Message.\n+\tCreate and format error string.\n+\t* gm2-compiler/M2LexBuf.mod: New variable SeenEof.\n+\t(GetNonEofToken): New procedure.\n+\t(Init): Set SeenEof to FALSE.\n+\t(GetToken): Use GetNonEofToken instead of calls to\n+\tm2flex.GetToken and GetToken.\n+\t(AddTok): Detect eoftok and set SeenEof.\n+\n+2023-01-27  Gaius Mulley  <gaiusmod2@gmail.com>\n+\n+\t* gm2-compiler/M2Options.def: Export GetMQ, SetMQ.\n+\t* gm2-compiler/M2Preprocess.mod: (MakeSaveTempsFileName):\n+\tTest NewDir against NIL.  Test Dumpdir against NIL.\n+\tTest GetMD () against NIL.  Test GetMMD () against NIL.\n+\tTest GetMQ () against NIL.  Test GetObj () against NIL.\n+\tTest tempfile against NIL.\n+\t* gm2-compiler/P2SymBuild.def: Export\n+\tBuildNoReturnAttribute.\n+\n+2023-01-27  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\tPR modula2/108555\n+\tPR modula2/108182\n+\tPR modula2/102343\n+\t* gm2-lang.cc (gm2_langhook_option_lang_mask): Do not claim CL_C\n+\tor CL_DRIVER.\n+\t(gm2_langhook_init_options): Handle options that we want to pass\n+\tto the preprocessor.\n+\t* lang-specs.h: Pass -B and -save-temps to regular compile lines.\n+\t* lang.opt: Add C and Driver options that Modula-2 intercepts for\n+\tinternal use. Reorder options into two sections and to collate.\n+\n+2023-01-26  Gaius Mulley  <gaiusmod2@gmail.com>\n+\n+\t* gm2-compiler/M2GCCDeclare.mod: Import IsProcedureNoReturn.\n+\t(DeclareProcedureToGccWholeProgram): New variable declared and set\n+\treturnType.  Pass returnType to BuildEndFunctionDeclaration.\n+\tExtra parameter IsProcedureNoReturn passed to\n+\tBuildEndFunctionDeclaration.\n+\t* gm2-compiler/M2Quads.mod (BuildM2MainFunction): Correct\n+\tscaffold comment and add extra return 0.\n+\t* gm2-compiler/P2Build.bnf: Import BuildNoReturnAttribute.\n+\t(ProcedureHeading): Process EndBuildFormalParameters before\n+\tparsing AttributeNoReturn.\n+\t(DefProcedureHeading): Process EndBuildFormalParameters before\n+\tparsing AttributeNoReturn.\n+\t(AttributeNoReturn): Call BuildNoReturnAttribute.\n+\t* gm2-compiler/P2SymBuild.def (BuildNoReturnAttribute): New\n+\tprocedure.\n+\t* gm2-compiler/P2SymBuild.mod (BuildNoReturnAttribute): New\n+\tprocedure.\n+\t* gm2-compiler/SymbolTable.def (PutProcedureInline): Corrected\n+\tcomment.\n+\t(PutProcedureNoReturn): New procedure.\n+\t(IsProcedureNoReturn): New procedure function.\n+\t* gm2-compiler/SymbolTable.mod (SymProcedure): IsNoReturn\n+\tnew field.\n+\t(MakeProcedure): Initialize IsNoReturn to FALSE.\n+\t(PutProcedureNoReturn): New procedure.\n+\t(IsProcedureNoReturn): New procedure function.\n+\t* gm2-gcc/m2decl.cc (m2decl_BuildEndFunctionDeclaration):\n+\tAdd extra parameter isnoreturn.  Set TREE_THIS_VOLATILE\n+\tto isnoreturn.\n+\t* gm2-gcc/m2decl.def (BuildEndFunctionDeclaration): Add\n+\textra parameter isnoreturn.\n+\t* gm2-gcc/m2decl.h (m2decl_BuildEndFunctionDeclaration): Add\n+\textra parameter isnoreturn.\n+\t* gm2-gcc/m2except.cc (m2except_InitExceptions): Change all\n+\tfunction decl to pass an extra parameter isnoreturn.\n+\n+2023-01-26  Gaius Mulley  <gaiusmod2@gmail.com>\n+\n+\t* m2.flex (splitSlashStar): Fix comment so that /* does not\n+\tappear inside the comment.\n+\n+2023-01-26  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\tPR modula2/108553\n+\t* gm2-lang.cc (gm2_langhook_init_options): Remove debug code.\n+\n+2023-01-26  Gaius Mulley  <gaiusmod2@gmail.com>\n+\n+\t* Make-lang.in (m2/gm2config.h): Rewrite rule to be\n+\tdependent upon m2/gm2config.aci.\n+\t(m2/gm2config.aci): Newrule.\n+\t* configure.ac (AC_CONFIG_HEADERS): Change destination\n+\tto gm2config.aci.\n+\t* configure: Regenerate.\n+\t* gm2-libs/config-host: Regenerate.\n+\t* gm2-compiler/M2GCCDeclare.mod (AddSymToWatch): Comment\n+\tout.\n+\t* gm2-compiler/M2Quads.mod (BuildConstHighFromSym): Remove\n+\tDim.\n+\t(StartBuildWith): Call BuildStmtNoteTok.\n+\t(BuildStmtNoteTok): New procedure.\n+\t(BuildStmtNote): Re-implement re-factor into two\n+\tprocedures and call BuildStmtNoteTok.\n+\t* gm2config.h.in: Remove.\n+\t* gm2config.aci.in: New file.\n+\n+2023-01-25  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\tPR modula2/102343\n+\tPR modula2/108182\n+\t* gm2-compiler/M2Comp.mod: Early exit for pre-processor-only jobs.\n+\t* gm2-compiler/M2Options.def (SetPPOnly, GetPPOnly, SetMD, GetMD,\n+\tSetMMD, GetMMD, SetMQ, GetMQ, SetObj, GetObj, SetDumpDir,\n+\tGetDumpDir):New.\n+\t* gm2-compiler/M2Options.mod:(SetPPOnly, GetPPOnly, SetMD, GetMD,\n+\tSetMMD, GetMMD, SetMQ, GetMQ, SetObj, GetObj, SetDumpDir,\n+\tGetDumpDir):New.\n+\t* gm2-compiler/M2Preprocess.def (PreprocessModule): Add flag to\n+\tindicate the main file.\n+\t* gm2-compiler/M2Preprocess.mod: Handle Preprocess-only jobs,\n+\thandle MD, MMD and MQ options.\n+\t* gm2-gcc/m2options.h (M2Options_SetPPOnly, M2Options_GetPPOnly,\n+\tM2Options_SetDumpDir, M2Options_SetMD, M2Options_GetMD,\n+\tM2Options_SetMMD, M2Options_GetMMD, M2Options_SetMQ, M2Options_GetMQ,\n+\tM2Options_SetObj, M2Options_GetObj): New.\n+\t* gm2-gcc/m2type.cc (m2type_InitBaseTypes): Early exit for pre-\n+\tprocessor-only jobs.\n+\t* gm2-lang.cc (gm2_langhook_init): Handle preprocess-only commands.\n+\t(gm2_langhook_option_lang_mask): Claim C and Driver options so that\n+\twe can intercept them for building pre-processor commands.\n+\t(gm2_langhook_init_options): Collect the preprocessor line here.\n+\tSave options that have different actions for preprocessor and compile\n+\tcommands.\n+\t(gm2_langhook_handle_option): Only handle the modula-2 options here.\n+\t(gm2_langhook_post_options): Do not create a back-end for pre-\n+\tprocessor-only jobs.\n+\t* gm2spec.cc (lang_specific_driver): Ignore PCH options, append a\n+\tscaffold-main for cases where we are building a main module with\n+\t-c.\n+\t* lang-specs.h: Revise to handle preprocessor-only jobs and to\n+\tconsume pre-processed files.\n+\t* lang.opt: Remove Driver and C options copies (we claim these\n+\tseparately).\n+\n+2023-01-24  Co-Authored by: Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\t* Make-lang.in (GM2-COMP-BOOT-DEFS): Add\n+\tDynamicStringPath.def.\n+\t(GM2-COMP-BOOT-MODS): Add DynamicStringPath.mod.\n+\t(GM2-COMP-DEFS): Add DynamicStringPath.def.\n+\t(GM2-COMP-MODS): Add DynamicStringPath.mod.\n+\t($(objdir)/m2/gm2-libs-min/SYSTEM.def): Split path into\n+\tmultiple -I components.\n+\t($(objdir)/m2/gm2-libs/SYSTEM.def): Ditto.\n+\t($(objdir)/m2/gm2-libs-coroutines/SYSTEM.def): Ditto.\n+\t* gm2-compiler/M2Options.mod: Import DynamicStringPath.\n+\t(SetSearchPath): Reimplement using DynamicStringPath\n+\tprocedures.\n+\t* gm2-compiler/M2Search.def (InitSearchPath): Remove.\n+\t(PrependSearchPath): Remove.\n+\t* gm2-compiler/M2Search.mod (SFIO): Remove import.\n+\t(DynamicStringPath): Add import.\n+\t(Directory): Remove.\n+\t(UserPath): Remove.\n+\t(InitialPath): Remove.\n+\t(InitSearchPath): Remove.\n+\t(PrependSearchPath): Remove.\n+\t(FindSourceFile): Re-implement.\n+\t(FindSourceDefFile): Re-implement.\n+\t(FindSourceModFile): Re-implement.\n+\t* gm2-gcc/init.cc (_M2_DynamicStringPath_init):\n+\tNew prototype.\n+\t(init_FrontEndInit): Call _M2_DynamicStringPath_init.\n+\t* tools-src/makeSystem: Allow multiple -I paths.\n+\t* gm2-compiler/DynamicStringPath.def: New file.\n+\t* gm2-compiler/DynamicStringPath.mod: New file.\n+\t* gm2-gcc/m2options.h (M2Options_SetMakeIncludePath): Add\n+\tprototype.\n+\n+2023-01-24  Gaius Mulley  <gaiusmod2@gmail.com>\n+\n+\t* m2.flex (cpreprocessor): Add temporary variable\n+\twhich is initialized to 0.\n+\t(commentCLevel): New variable.\n+\t(endOfCComment): New function.\n+\t(splitSlashStar): New function to split /* into / and *\n+\ttokens.\n+\t(COMMENTC): New flex state.\n+\t(\"/*\"): New rule to test whether we should treat /*\n+\tas a single token or as two tokens.\n+\t(<COMMENTC>.): New rule to skip a character.\n+\t(<COMMENTC>\\n.*): New rule to consume the line.\n+\t(<COMMENTC>\"*/\"): New rule to call endOfCComment.\n+\n+2023-01-24  Gaius Mulley  <gaiusmod2@gmail.com>\n+\n+\t* gm2-libs-iso/RTco.def: Import RTentity.\n+\tDeclare RTco as a definition for C module.\n+\n+2023-01-23  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\tPR modula2/108182\n+\tPR modula2/108480\n+\t* Make-lang.in: Pass libsubdir to the language init\n+\tbuild.\n+\t* gm2-lang.cc (INCLUDE_VECTOR): Define.\n+\t(add_one_import_path): New.\n+\t(add_m2_import_paths): New.\n+\t(gm2_langhook_post_options): Arrange to add the include\n+\tpaths (and add the system ones) in the same order as C\n+\tuses.\n+\t* gm2spec.cc (build_archive_path): Remove.\n+\t(add_default_combination): Remove.\n+\t(add_default_archives): Remove.\n+\t(add_default_libs): We no longer need a '-L' option, just\n+\temit the -l and each library in use.\n+\t(build_include_path): Remove.\n+\t(add_include): Remove.\n+\t(add_default_includes): Remove.\n+\t(library_installed): Remove.\n+\t(check_valid_library): Remove.\n+\t(check_valid_list): Remove.\n+\t(convert_abbreviation): Diagnose unhandled cases.\n+\t(lang_specific_driver): Skip options where we will add back\n+\ta validated version.\n+\t* lang-specs.h (M2CPP): Reformat, append %I when -fcpp is not\n+\tin use.  Revise the cc1gm2 spec to omit mentioning options that\n+\tare handled in the c pre-processor line.\n+\t* lang.opt: Allow preprocessing and path options as input to the\n+\tcc1gm2 invocation, so that they can be passed to the preprocessor\n+\tinvocation.\n+\n+2023-01-23  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\tPR modula2/108405\n+\t* gm2-libs-iso/Preemptive.mod (initPreemptive): Use a value for\n+\textra space that is divisible by common OS pagesizes.\n+\n+2023-01-20  Gaius Mulley  <gaiusmod2@gmail.com>\n+\n+\t* gm2-libs/Args.mod (GetArg): Check index before\n+\taccessing array.\n+\t* gm2-libs/M2Dependent.mod (toCString): Check index\n+\tbefore accessing array.\n+\t* mc-boot/GArgs.c: Rebuilt.\n+\t* mc-boot/GM2Dependent.c: Rebuilt.\n+\t* mc-boot/Gkeyc.c: Rebuilt.\n+\t* mc/keyc.mod (seenUIntMin): Initialize once.\n+\t(seenUIntMax): Initialize once.\n+\t(checkLimits): Only test seenUIntMin and seenUIntMax\n+\tonce.\n+\t* pge-boot/GArgs.c:  Rebuilt.\n+\t* pge-boot/GM2Dependent.c: Rebuilt.\n+\n+2023-01-20  Gaius Mulley  <gaiusmod2@gmail.com>\n+\n+\t* gm2-gcc/m2statement.cc (gm2_gimplify_function_node):\n+\tRemove.\n+\t* gm2-libs/DynamicStrings.mod (Equal): Remove dead code.\n+\t* m2.flex (<COMMENT>\"<*\"): Add {} for else statement.\n+\t* m2pp.cc (hextree): Add conditional #ifdef DEBUGGING.\n+\t* mc-boot/GDynamicStrings.c: Rebuild.\n+\t* pge-boot/GDynamicStrings.c: Rebuild.\n+\t* pge-boot/GFIO.c: Rebuild.\n+\t* pge-boot/GIndexing.c: Rebuild.\n+\t* pge-boot/GM2EXCEPTION.c: Rebuild.\n+\t* pge-boot/GM2RTS.c: Rebuild.\n+\t* pge-boot/GNameKey.c: Rebuild.\n+\t* pge-boot/GPushBackInput.c: Rebuild.\n+\t* pge-boot/GRTExceptions.c: Rebuild.\n+\t* pge-boot/GStdIO.c: Rebuild.\n+\t* pge-boot/GSymbolKey.c: Rebuild.\n+\t* pge-boot/GSysStorage.c: Rebuild.\n+\n+2023-01-17  Gaius Mulley  <gaiusmod2@gmail.com>\n+\n+\t* mc-boot/GM2RTS.c: Rebuilt.\n+\t* mc-boot/GM2RTS.h: Rebuilt.\n+\t* mc-boot/Gdecl.c: Rebuilt.\n+\t* mc-boot/GmcOptions.c: Rebuilt.\n+\t* mc/mcOptions.mod (displayVersion):\n+\tSplit first printf into three components\n+\n+2023-01-17  Gaius Mulley  <gaiusmod2@gmail.com>\n+\n+\t* gm2-libs-iso/M2RTS.def (Halt): Parameter file renamed to filename.\n+\t(HaltC): New procedure declaration.\n+\t(ErrorMessage): Parameter file renamed to filename.\n+\t* gm2-libs-iso/M2RTS.mod (Halt): Parameter file renamed to\n+\tfilename.\n+\t(HaltC): New procedure implementation.\n+\t(ErrorStringC): New procedure implementation.\n+\t(ErrorMessageC): New procedure implementation.\n+\t* gm2-libs/M2RTS.def (Halt): Parameter file renamed to filename.\n+\t(HaltC): New procedure declaration.\n+\t(ErrorMessage): Parameter file renamed to filename.\n+\t* gm2-libs/M2RTS.mod (Halt): Parameter file renamed to filename.\n+\t(HaltC): New procedure implementation.\n+\t(ErrorStringC): New procedure implementation.\n+\t(ErrorMessageC): New procedure implementation.\n+\n+2023-01-16  Gaius Mulley  <gaiusmod2@gmail.com>\n+\n+\t* mc-boot-ch/Glibc.c (libc_time): New function.\n+\t(libc_localtime): New function.\n+\t* mc-boot/GDynamicStrings.c: Regenerate.\n+\t* mc-boot/GFIO.c: Regenerate.\n+\t* mc-boot/GFormatStrings.c: Regenerate.\n+\t* mc-boot/GIndexing.c: Regenerate.\n+\t* mc-boot/GM2Dependent.c: Regenerate.\n+\t* mc-boot/GM2EXCEPTION.c: Regenerate.\n+\t* mc-boot/GPushBackInput.c: Regenerate.\n+\t* mc-boot/GRTExceptions.c: Regenerate.\n+\t* mc-boot/GRTint.c: Regenerate.\n+\t* mc-boot/GStdIO.c: Regenerate.\n+\t* mc-boot/GStringConvert.c: Regenerate.\n+\t* mc-boot/GSysStorage.c: Regenerate.\n+\t* mc-boot/Gdecl.c: Regenerate.\n+\t* mc-boot/GmcComment.c: Regenerate.\n+\t* mc-boot/GmcComp.c: Regenerate.\n+\t* mc-boot/GmcDebug.c: Regenerate.\n+\t* mc-boot/GmcMetaError.c: Regenerate.\n+\t* mc-boot/GmcOptions.c: Regenerate.\n+\t* mc-boot/GmcStack.c: Regenerate.\n+\t* mc-boot/GnameKey.c: Regenerate.\n+\t* mc-boot/GsymbolKey.c: Regenerate.\n+\t* mc-boot/Gkeyc.c: Regenerate.\n+\t* mc/decl.mod (putFieldRecord): Change NulName to NulKey\n+\tand fix type comparision.\n+\t* mc/mcOptions.mod (YEAR): Remove.\n+\t(getYear): New procedure function.\n+\t(displayVersion): Use result from getYear instead of YEAR.\n+\tEmit boilerplate for GPL v3.\n+\t(gplBody): Use result from getYear instead of YEAR.\n+\t(glplBody): Use result from getYear instead of YEAR.\n+\n+2023-01-16  Gaius Mulley  <gaiusmod2@gmail.com>\n+\n+\t* gm2-compiler/M2Quads.mod (AssignUnboundedVar): Check Type\n+\tagainst NulSym and call MetaErrorT1 if necessary.\n+\t(AssignUnboundedNonVar): Check Type against NulSym and\n+\tcall MetaErrorT1 if necessary.\n+\t(BuildDesignatorPointer): Check Type1 against NulSym and\n+\tcall MetaErrorT1 if necessary.\n+\n+2023-01-16  Gaius Mulley  <gaiusmod2@gmail.com>\n+\n+\t* mc/mcOptions.mod (displayVersion): Change GPLv2 to GPLv3.\n+\t(YEAR) set to 2023.\n+\n 2023-01-15  Gaius Mulley  <gaiusmod2@gmail.com>\n \n \t* gm2-compiler/M2LexBuf.mod (isSrcToken): Add block comment."}, {"sha": "03677d9e5eac69fb6b2bf3b29a4ff80b5a1a8b55", "filename": "gcc/m2/Make-lang.in", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2FMake-lang.in?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -176,7 +176,7 @@ m2/gm2-libs.texi: gm2-libs.texi-check; @true\n ifeq ($(HAVE_PYTHON),yes)\n gm2-libs.texi-check: m2/SYSTEM-pim.texi m2/SYSTEM-iso.texi m2/Builtins.texi \\\n                      $(objdir)/m2/gm2-libs-coroutines/SYSTEM.def\n-\ttest -d m2/gm2-libs-pim || $(mkinstalldirs) m2/gm2-libs-pim\n+\ttest -d m2/gm2-libs-log || $(mkinstalldirs) m2/gm2-libs-log\n \ttest -d m2/gm2-libs-iso || $(mkinstalldirs) m2/gm2-libs-iso\n \ttest -d m2/gm2-libs || $(mkinstalldirs) m2/gm2-libs\n \t$(PYTHON) $(srcdir)/m2/tools-src/def2doc.py -t -uLibraries -s$(srcdir)/m2 -b$(objdir)/m2 -o $(objdir)/m2/gm2-libs.texi\n@@ -543,6 +543,7 @@ m2/gm2-gcc/m2configure.o: $(srcdir)/m2/gm2-gcc/m2configure.cc \\\n \n m2/gm2-lang.o: $(srcdir)/m2/gm2-lang.cc gt-m2-gm2-lang.h $(GCC_HEADER_DEPENDENCIES_FOR_M2)\n \t$(COMPILER) -c -g $(GM2GCC) $(ALL_COMPILERFLAGS) \\\n+\t    -DLIBSUBDIR=\\\"$(libsubdir)\\\" \\\n             $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n \n m2/stor-layout.o: $(srcdir)/stor-layout.cc $(GCC_HEADER_DEPENDENCIES_FOR_M2)\n@@ -689,6 +690,7 @@ GM2-COMP-BOOT-DEFS = \\\n    M2DebugStack.def \\\n    M2Defaults.def \\\n    M2DriverOptions.def \\\n+   DynamicStringPath.def \\\n    M2Emit.def \\\n    M2Error.def \\\n    M2EvalSym.def \\\n@@ -760,6 +762,7 @@ GM2-COMP-BOOT-MODS = \\\n    M2DebugStack.mod \\\n    M2Defaults.mod \\\n    M2DriverOptions.mod \\\n+   DynamicStringPath.mod \\\n    M2Emit.mod \\\n    M2Error.mod \\\n    M2FileName.mod \\\n@@ -964,6 +967,7 @@ GM2-COMP-DEFS = \\\n    M2DebugStack.def \\\n    M2Defaults.def \\\n    M2DriverOptions.def \\\n+   DynamicStringPath.def \\\n    M2Emit.def \\\n    M2Error.def \\\n    M2FileName.def \\\n@@ -1031,6 +1035,7 @@ GM2-COMP-MODS = \\\n    M2DebugStack.mod \\\n    M2Defaults.mod \\\n    M2DriverOptions.mod \\\n+   DynamicStringPath.mod \\\n    M2Emit.mod \\\n    M2Error.mod \\\n    M2FileName.mod \\\n@@ -1498,7 +1503,10 @@ m2/gm2-libs/gm2-libs-host.h:\n # Autoconf inserts -DCROSS_DIRECTORY_STRUCTURE if we are building a\n # cross compiler and the ../Makefile.in above appends this to INTERNAL_CFLAGS.\n \n-m2/gm2config.h:\n+m2/gm2config.h: m2/gm2config.aci\n+\tgrep -v define\\ PACKAGE_ $< > $@\n+\n+m2/gm2config.aci:\n \tNEW_SRCDIR=`${srcdir}/m2/tools-src/calcpath ../ ${srcdir} m2` ; \\\n         export NEW_SRCDIR ; \\\n \tcd m2 ; \\\n@@ -1521,7 +1529,7 @@ $(objdir)/m2/gm2-libs-min/SYSTEM.def: $(GM2_PROG_DEP)\n \t$(SHELL) $(srcdir)/m2/tools-src/makeSystem -fpim \\\n              $(srcdir)/m2/gm2-libs-min/SYSTEM.def \\\n              $(srcdir)/m2/gm2-libs-min/SYSTEM.mod \\\n-             -I$(srcdir)/m2/gm2-libs-min:$(srcdir)/m2/gm2-libs \\\n+             -I$(srcdir)/m2/gm2-libs-min -I$(srcdir)/m2/gm2-libs \\\n              \"$(GM2_FOR_TARGET)\" $@\n \n $(objdir)/m2/gm2-libs/SYSTEM.def: $(GM2_PROG_DEP)\n@@ -1539,15 +1547,15 @@ $(objdir)/m2/gm2-libs-iso/SYSTEM.def: $(GM2_PROG_DEP)\n \t$(SHELL) $(srcdir)/m2/tools-src/makeSystem -fiso \\\n              $(srcdir)/m2/gm2-libs-iso/SYSTEM.def \\\n              $(srcdir)/m2/gm2-libs-iso/SYSTEM.mod \\\n-             -I$(srcdir)/m2/gm2-libs-iso:$(srcdir)/m2/gm2-libs \\\n+             -I$(srcdir)/m2/gm2-libs-iso -I$(srcdir)/m2/gm2-libs \\\n              \"$(GM2_FOR_TARGET)\" $@\n \n $(objdir)/m2/gm2-libs-coroutines/SYSTEM.def: $(GM2_PROG_DEP)\n \t-test -d m2/gm2-libs-coroutines || $(mkinstalldirs) m2/gm2-libs-coroutines\n \t$(SHELL) $(srcdir)/m2/tools-src/makeSystem -fpim \\\n              $(srcdir)/m2/gm2-libs-coroutines/SYSTEM.def \\\n              $(srcdir)/m2/gm2-libs-coroutines/SYSTEM.mod \\\n-             -I$(srcdir)/m2/gm2-libs-coroutines:$(srcdir)/m2/gm2-libs-iso:$(srcdir)/m2/gm2-libs \\\n+             -I$(srcdir)/m2/gm2-libs-coroutines -I$(srcdir)/m2/gm2-libs-iso -I$(srcdir)/m2/gm2-libs \\\n              \"$(GM2_FOR_TARGET)\" $@\n \n build-compiler: $(GM2-COMP-MODS:%.mod=m2/gm2-compiler/%.o) \\"}, {"sha": "de78fdd37247c6ff4d00ea4b61a69885db613491", "filename": "gcc/m2/configure", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fconfigure?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -3645,7 +3645,7 @@ $as_echo \"#define HAVE_OPENDIR 1\" >>confdefs.h\n \n fi\n \n-ac_config_headers=\"$ac_config_headers gm2config.h\"\n+ac_config_headers=\"$ac_config_headers gm2config.aci\"\n \n cat >confcache <<\\_ACEOF\n # This file is a shell script that caches the results of configure\n@@ -4319,7 +4319,7 @@ cat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n for ac_config_target in $ac_config_targets\n do\n   case $ac_config_target in\n-    \"gm2config.h\") CONFIG_HEADERS=\"$CONFIG_HEADERS gm2config.h\" ;;\n+    \"gm2config.aci\") CONFIG_HEADERS=\"$CONFIG_HEADERS gm2config.aci\" ;;\n \n   *) as_fn_error $? \"invalid argument: \\`$ac_config_target'\" \"$LINENO\" 5;;\n   esac\n@@ -4630,7 +4630,7 @@ $as_echo \"$as_me: $ac_file is unchanged\" >&6;}\n \n \n   case $ac_file$ac_mode in\n-    \"gm2config.h\":H) echo timestamp > stamp-h ;;\n+    \"gm2config.aci\":H) echo timestamp > stamp-h ;;\n \n   esac\n done # for ac_tag"}, {"sha": "0a77caeaa17998aa89ed6b34ed5f9fc4e6488792", "filename": "gcc/m2/configure.ac", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fconfigure.ac?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1,4 +1,4 @@\n-# configure.ac provides gm2spec.c with access to config values.\n+# configure.ac provides gm2spec.cc with access to config values.\n \n # Copyright (C) 2001-2023 Free Software Foundation, Inc.\n # Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n@@ -29,5 +29,5 @@ AC_CHECK_FUNCS([stpcpy])\n AC_CHECK_HEADERS(sys/types.h)\n AC_HEADER_DIRENT\n AC_CHECK_LIB([c],[opendir],[AC_DEFINE([HAVE_OPENDIR],[1],[found opendir])])\n-AC_CONFIG_HEADERS(gm2config.h, [echo timestamp > stamp-h])\n+AC_CONFIG_HEADERS(gm2config.aci, [echo timestamp > stamp-h])\n AC_OUTPUT"}, {"sha": "e9fdff7ee144e8411172b5df37129b383f45a11c", "filename": "gcc/m2/gm2-compiler/DynamicStringPath.def", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FDynamicStringPath.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FDynamicStringPath.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FDynamicStringPath.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -0,0 +1,113 @@\n+(* DynamicStringPath.def implements a path for DynamicStrings.\n+\n+Copyright (C) 2001-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  *)\n+\n+DEFINITION MODULE DynamicStringPath ;  (*!m2iso+gm2*)\n+\n+FROM DynamicStrings IMPORT String ;\n+\n+TYPE\n+   PathList ;\n+\n+\n+(*\n+   GetUserPath - returns the current UserPath.\n+*)\n+\n+PROCEDURE GetUserPath () : PathList ;\n+\n+\n+(*\n+   GetSystemPath - returns the current SystemPath.\n+*)\n+\n+PROCEDURE GetSystemPath () : PathList ;\n+\n+\n+(*\n+   SetUserPath - assigns UserPath to pl.\n+*)\n+\n+PROCEDURE SetUserPath (pl: PathList) ;\n+\n+\n+(*\n+   SetSystemPath - assigns SystemPath to pl.\n+*)\n+\n+PROCEDURE SetSystemPath (pl: PathList) ;\n+\n+\n+(*\n+   InitPathList - creates a new empty path list.\n+*)\n+\n+PROCEDURE InitPathList (str: String) : PathList ;\n+\n+\n+(*\n+   KillPathList - places list pl onto the freelist.\n+                  Postcondition: pl will be NIL.\n+*)\n+\n+PROCEDURE KillPathList (VAR pl: PathList) ;\n+\n+\n+(*\n+   Cons - appends str to the end of a path list.\n+          If pl is NIL a new list is created and returned\n+          containing str.\n+*)\n+\n+PROCEDURE Cons (pl: PathList; str: String) : PathList ;\n+\n+\n+(*\n+   ConsList - concatenates path list left and right together.\n+              It always returns NIL which should be assigned\n+              to the callers right parameter after ConsList\n+              has been completed signifying that right should\n+              no longer be accessed.\n+*)\n+\n+PROCEDURE ConsList (left, right: PathList) : PathList ;\n+\n+\n+(*\n+   Stash - returns pl before setting pl to NIL.\n+*)\n+\n+PROCEDURE Stash (VAR pl: PathList) : PathList ;\n+\n+\n+(*\n+   FindFileName - returns NIL if a file cannot be found otherwise\n+                  it returns the path including the filename.\n+*)\n+\n+PROCEDURE FindFileName (filename: String; pl: PathList) : String ;\n+\n+\n+END DynamicStringPath."}, {"sha": "601456e0787de4b478b1fbd0f731ea409951339c", "filename": "gcc/m2/gm2-compiler/DynamicStringPath.mod", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FDynamicStringPath.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FDynamicStringPath.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FDynamicStringPath.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -0,0 +1,265 @@\n+(* DynamicStringPath.def implements a path for DynamicStrings.\n+\n+Copyright (C) 2001-2023 Free Software Foundation, Inc.\n+Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n+\n+This file is part of GNU Modula-2.\n+\n+GNU Modula-2 is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU Modula-2 is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  *)\n+\n+IMPLEMENTATION MODULE DynamicStringPath ;  (*!m2iso+gm2*)\n+\n+FROM Storage IMPORT ALLOCATE, DEALLOCATE ;\n+FROM DynamicStrings IMPORT InitString, ConCat, ConCatChar, char, Dup,\n+                           KillString, Length ;\n+FROM SFIO IMPORT Exists ;\n+FROM FIO IMPORT StdErr ;\n+FROM M2Printf IMPORT fprintf0, fprintf1 ;\n+\n+CONST\n+   Directory = '/' ;\n+   Debugging = FALSE ;\n+\n+TYPE\n+   PathList = POINTER TO RECORD\n+                            tail,\n+                            next : PathList ;\n+                            entry: String ;\n+                         END ;\n+\n+\n+VAR\n+   FreeList,\n+   DefaultUserPath,\n+   DefaultSystemPath: PathList ;\n+\n+\n+(*\n+   GetUserPath - returns the current UserPath.\n+*)\n+\n+PROCEDURE GetUserPath () : PathList ;\n+BEGIN\n+   RETURN DefaultUserPath\n+END GetUserPath ;\n+\n+\n+(*\n+   GetSystemPath - returns the current SystemPath.\n+*)\n+\n+PROCEDURE GetSystemPath () : PathList ;\n+BEGIN\n+   RETURN DefaultSystemPath\n+END GetSystemPath ;\n+\n+\n+(*\n+   SetUserPath - assigns UserPath to pl.\n+*)\n+\n+PROCEDURE SetUserPath (pl: PathList) ;\n+BEGIN\n+   DefaultUserPath := pl ;\n+   DumpPath ('DefaultUserPath', DefaultUserPath)\n+END SetUserPath ;\n+\n+\n+(*\n+   SetSystemPath - assigns SystemPath to pl.\n+*)\n+\n+PROCEDURE SetSystemPath (pl: PathList) ;\n+BEGIN\n+   DefaultSystemPath := pl ;\n+   DumpPath ('DefaultSystemPath', DefaultSystemPath)\n+END SetSystemPath ;\n+\n+\n+(*\n+   KillPathList - places list pl onto the freelist.\n+                  Postcondition: pl will be NIL.\n+*)\n+\n+PROCEDURE KillPathList (VAR pl: PathList) ;\n+BEGIN\n+   IF pl # NIL\n+   THEN\n+      pl^.tail^.next := FreeList ;\n+      FreeList := pl ;\n+      pl := NIL\n+   END\n+END KillPathList ;\n+\n+\n+(*\n+   InitPathList - creates a new empty path list.\n+                  It takes a copy of the string.\n+*)\n+\n+PROCEDURE InitPathList (str: String) : PathList ;\n+VAR\n+   pl: PathList ;\n+BEGIN\n+   NEW (pl) ;\n+   WITH pl^ DO\n+      tail := pl ;\n+      next := NIL ;\n+      entry := Dup (str)\n+   END ;\n+   RETURN pl\n+END InitPathList ;\n+\n+\n+(*\n+   Cons - appends str to the end of a path list.\n+          If pl is NIL a new list is created and returned\n+          containing str.\n+*)\n+\n+PROCEDURE Cons (pl: PathList; str: String) : PathList ;\n+BEGIN\n+   IF pl = NIL\n+   THEN\n+      pl := InitPathList (str)\n+   ELSE\n+      pl := ConsList (pl, InitPathList (str))\n+   END ;\n+   RETURN pl\n+END Cons ;\n+\n+\n+(*\n+   ConsList - concatenates path list left and right together.\n+              It always returns NIL which should be assigned\n+              to the callers right parameter after ConsList\n+              has been completed signifying that right should\n+              no longer be accessed.\n+*)\n+\n+PROCEDURE ConsList (left, right: PathList) : PathList ;\n+BEGIN\n+   IF right # NIL\n+   THEN\n+      left^.tail^.next := right ;\n+      left^.tail := right^.tail\n+   END ;\n+   RETURN left\n+END ConsList ;\n+\n+\n+(*\n+   Stash - returns pl before setting pl to NIL.\n+*)\n+\n+PROCEDURE Stash (VAR pl: PathList) : PathList ;\n+VAR\n+   old: PathList ;\n+BEGIN\n+   old := pl ;\n+   pl := NIL ;\n+   RETURN old\n+END Stash ;\n+\n+\n+(*\n+   AddDir - if str is not empty and does not end with / then add\n+            a directory.\n+            Postcondition: str is returned (with a '/' at the end)\n+            or is empty.\n+*)\n+\n+PROCEDURE AddDir (str: String) : String ;\n+BEGIN\n+   IF Length (str) > 0\n+   THEN\n+      IF char (str, -1) # Directory\n+      THEN\n+         str := ConCatChar (str, Directory)\n+      END\n+   END ;\n+   RETURN str\n+END AddDir ;\n+\n+\n+(*\n+   FindFileName - returns NIL if a file cannot be found otherwise\n+                  it returns the path including the filename.\n+*)\n+\n+PROCEDURE FindFileName (filename: String; pl: PathList) : String ;\n+VAR\n+   s: String ;\n+BEGIN\n+   WHILE pl # NIL DO\n+      s := ConCat (AddDir (Dup (pl^.entry)), Dup (filename)) ;\n+      IF Debugging\n+      THEN\n+         fprintf1 (StdErr, \"testing for %s: \", s)\n+      END ;\n+      IF Exists (s)\n+      THEN\n+         IF Debugging\n+         THEN\n+            fprintf0 (StdErr, \"yes\\n\")\n+         END ;\n+         RETURN s\n+      END ;\n+      IF Debugging\n+      THEN\n+         fprintf0 (StdErr, \"no\\n\")\n+      END ;\n+      s := KillString (s) ;\n+      pl := pl^.next\n+   END ;\n+   IF Debugging\n+   THEN\n+      fprintf1 (StdErr, \"FindFileName did not find: %s in path\\n\", filename)\n+   END ;\n+   RETURN NIL\n+END FindFileName ;\n+\n+\n+(*\n+   DumpPath - debugging dump of the pathlist.\n+*)\n+\n+PROCEDURE DumpPath (name: ARRAY OF CHAR; pl: PathList) ;\n+BEGIN\n+   IF Debugging\n+   THEN\n+      fprintf0 (StdErr, name) ;\n+      fprintf0 (StdErr, \":\") ;\n+      WHILE pl # NIL DO\n+         fprintf0 (StdErr, \" {\") ;\n+         fprintf1 (StdErr, \"%s\", pl^.entry) ;\n+         fprintf0 (StdErr, \"}\") ;\n+         pl := pl^.next\n+      END ;\n+      fprintf0 (StdErr, \"\\n\")\n+   END\n+END DumpPath ;\n+\n+\n+BEGIN\n+   DefaultSystemPath := NIL ;\n+   DefaultUserPath := NIL ;\n+   FreeList := NIL\n+END DynamicStringPath."}, {"sha": "3c2c3643b186c2205f5e67f4b4c570dfca415e99", "filename": "gcc/m2/gm2-compiler/M2Comp.mod", "status": "modified", "additions": 39, "deletions": 18, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FM2Comp.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FM2Comp.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FM2Comp.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -22,7 +22,8 @@ along with GNU Modula-2; see the file COPYING3.  If not see\n IMPLEMENTATION MODULE M2Comp ;\n \n \n-FROM M2Options IMPORT Statistics, Quiet, WholeProgram, ExtendedOpaque, GenModuleList ;\n+FROM M2Options IMPORT PPonly, Statistics, Quiet, WholeProgram,\n+                      ExtendedOpaque, GenModuleList ;\n \n FROM M2Pass IMPORT SetPassToPass0, SetPassToPass1, SetPassToPass2, SetPassToPassC, SetPassToPass3,\n                    SetPassToNoPass, SetPassToPassHidden ;\n@@ -38,7 +39,7 @@ FROM libc IMPORT exit ;\n FROM M2Error IMPORT ErrorStringAt, ErrorStringAt2, ErrorStringsAt2,\n                     WriteFormat0, FlushErrors, FlushWarnings, ResetErrorScope ;\n \n-FROM M2MetaError IMPORT MetaErrorString1, MetaError0, MetaError1 ;\n+FROM M2MetaError IMPORT MetaErrorString0, MetaErrorString1, MetaError0, MetaError1, MetaString0 ;\n FROM FormatStrings IMPORT Sprintf1 ;\n FROM P0SymBuild IMPORT P0Init, P1Init ;\n \n@@ -60,11 +61,12 @@ FROM SymbolTable IMPORT GetSymName, IsDefImp, NulSym,\n                         ResolveConstructorTypes, SanityCheckConstants, IsDefinitionForC,\n                         IsBuiltinInModule, PutModLink, IsDefLink, IsModLink ;\n \n-FROM FIO IMPORT StdErr ;\n+FROM FIO IMPORT StdErr, StdOut ;\n FROM NameKey IMPORT Name, GetKey, KeyToCharStar, makekey ;\n FROM M2Printf IMPORT fprintf1 ;\n FROM M2Quiet IMPORT qprintf0, qprintf1, qprintf2 ;\n FROM DynamicStrings IMPORT String, InitString, KillString, InitStringCharStar, Dup, Mark, string ;\n+FROM M2Options IMPORT Verbose ;\n \n CONST\n    Debugging = FALSE ;\n@@ -126,6 +128,10 @@ PROCEDURE Compile (s: String) ;\n BEGIN\n    DoPass0(s) ;\n    FlushWarnings ; FlushErrors ;\n+   IF PPonly\n+   THEN\n+      RETURN\n+   END;\n    ResetForNewPass ; ResetErrorScope ;\n    qprintf0('Pass 1: scopes, enumerated types, imports and exports\\n') ;\n    DoPass1 ;\n@@ -167,6 +173,8 @@ END compile ;\n *)\n \n PROCEDURE ExamineCompilationUnit (VAR name: ADDRESS; VAR isdefimp: BOOLEAN) ;\n+VAR\n+   Message: String ;\n BEGIN\n    isdefimp := FALSE ;   (* default to program module *)\n    (* stop if we see eof, ';' or '[' *)\n@@ -183,8 +191,9 @@ BEGIN\n       END ;\n       GetToken\n    END ;\n-   m2flex.M2Error(string(InitString('failed to find module name'))) ;\n-   exit(1)\n+   Message := MetaString0 (InitString ('no {%kMODULE} name found')) ;\n+   m2flex.M2Error (string (Message)) ;\n+   exit (1)\n END ExamineCompilationUnit ;\n \n \n@@ -198,20 +207,20 @@ VAR\n    name    : ADDRESS ;\n    isdefimp: BOOLEAN ;\n BEGIN\n-   IF OpenSource(PreprocessModule(s))\n+   IF OpenSource (s)\n    THEN\n-      ExamineCompilationUnit(name, isdefimp) ;\n+      ExamineCompilationUnit (name, isdefimp) ;\n       IF isdefimp\n       THEN\n-         SetMainModule(MakeImplementationSource(GetTokenNo(), makekey(name)))\n+         SetMainModule (MakeImplementationSource (GetTokenNo (), makekey (name)))\n       ELSE\n-         SetMainModule(MakeProgramSource(GetTokenNo(), makekey(name)))\n+         SetMainModule (MakeProgramSource (GetTokenNo (), makekey (name)))\n       END ;\n       CloseSource ;\n       ReInitialize\n    ELSE\n-      fprintf1(StdErr, 'failed to open %s\\n', s) ;\n-      exit(1)\n+      fprintf1 (StdErr, 'failed to open %s\\n', s) ;\n+      exit (1)\n    END\n END PeepInto ;\n \n@@ -226,15 +235,26 @@ VAR\n    Sym     : CARDINAL ;\n    i       : CARDINAL ;\n    SymName,\n-   FileName: String ;\n+   FileName,\n+   PPSource: String ;\n BEGIN\n    P0Init ;\n    SetPassToPass0 ;\n-   PeepInto(s) ;\n+   (* Maybe preprocess the main file.  *)\n+   PPSource := PreprocessModule(s, TRUE);\n+   IF PPonly\n+   THEN\n+      RETURN\n+   END;\n+   PeepInto (PPSource) ;\n    Main := GetMainModule() ;\n    i := 1 ;\n    Sym := GetModuleNo(i) ;\n-   qprintf1('Compiling: %s\\n', s) ;\n+   qprintf1('Compiling: %s\\n', PPSource) ;\n+   IF Verbose\n+   THEN\n+      fprintf1(StdOut, 'Compiling: %s\\n', PPSource) ;\n+   END ;\n    qprintf0('Pass 0: lexical analysis, parsing, modules and associated filenames\\n') ;\n    WHILE Sym#NulSym DO\n       SymName := InitStringCharStar(KeyToCharStar(GetSymName(Sym))) ;\n@@ -243,7 +263,7 @@ BEGIN\n          IF FindSourceDefFile(SymName, FileName)\n          THEN\n             ModuleType := Definition ;\n-            IF OpenSource(AssociateDefinition(PreprocessModule(FileName), Sym))\n+            IF OpenSource(AssociateDefinition(PreprocessModule(FileName, FALSE), Sym))\n             THEN\n                IF NOT P0SyntaxCheck.CompilationUnit()\n                THEN\n@@ -280,15 +300,16 @@ BEGIN\n          (* only need to read implementation module if hidden types are declared or it is the main module *)\n          IF Main=Sym\n          THEN\n-            FileName := Dup(s)\n+            FileName := Dup (PPSource)\n          ELSE\n             IF FindSourceModFile (SymName, FileName)\n             THEN\n+               FileName := PreprocessModule (FileName, FALSE)\n             END\n          END ;\n          IF FileName#NIL\n          THEN\n-            IF OpenSource (AssociateModule (PreprocessModule (FileName), Sym))\n+            IF OpenSource (AssociateModule (Dup (FileName), Sym))\n             THEN\n                IF NOT P0SyntaxCheck.CompilationUnit()\n                THEN\n@@ -325,7 +346,7 @@ BEGIN\n             IF FindSourceModFile (SymName, FileName)\n             THEN\n                qprintf2 ('   Module %-20s : %s (linking)\\n', SymName, FileName) ;\n-               IF OpenSource (AssociateModule (PreprocessModule (FileName), Sym))\n+               IF OpenSource (AssociateModule (PreprocessModule (FileName, FALSE), Sym))\n                THEN\n                   PutModLink (Sym, TRUE) ;   (* This source is only used to determine link time info.  *)\n                   IF NOT P0SyntaxCheck.CompilationUnit ()"}, {"sha": "445c039a0c24c892b0bebe5b633912b04241077b", "filename": "gcc/m2/gm2-compiler/M2GCCDeclare.mod", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FM2GCCDeclare.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FM2GCCDeclare.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FM2GCCDeclare.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -105,7 +105,7 @@ FROM SymbolTable IMPORT NulSym,\n                         IsAModula2Type, UsesVarArgs,\n                         GetSymName, GetParent,\n                         GetDeclaredMod, GetVarBackEndType,\n-                        GetProcedureBeginEnd,\n+                        GetProcedureBeginEnd, IsProcedureNoReturn,\n                         GetString, GetStringLength, IsConstString,\n                         IsConstStringM2, IsConstStringC, IsConstStringM2nul, IsConstStringCnul,\n                         GetAlignment, IsDeclaredPacked, PutDeclaredPacked,\n@@ -347,6 +347,7 @@ END DebugSetNumbers ;\n                    lists.\n *)\n \n+(*\n PROCEDURE AddSymToWatch (sym: WORD) ;\n BEGIN\n    IF (sym#NulSym) AND (NOT IsElementInSet(WatchList, sym))\n@@ -357,6 +358,7 @@ BEGIN\n       FIO.FlushBuffer(FIO.StdOut)\n    END\n END AddSymToWatch ;\n+*)\n \n \n (*\n@@ -2345,6 +2347,7 @@ END IsExternalToWholeProgram ;\n \n PROCEDURE DeclareProcedureToGccWholeProgram (Sym: CARDINAL) ;\n VAR\n+   returnType,\n    GccParam  : Tree ;\n    scope,\n    Son,\n@@ -2389,20 +2392,17 @@ BEGIN\n       PushBinding(scope) ;\n       IF GetSType(Sym)=NulSym\n       THEN\n-         PreAddModGcc(Sym, BuildEndFunctionDeclaration(begin, end,\n-                                                       KeyToCharStar(GetFullSymName(Sym)),\n-                                                       NIL,\n-                                                       IsExternalToWholeProgram(Sym),\n-                                                       IsProcedureGccNested(Sym),\n-                                                       IsExported(GetModuleWhereDeclared(Sym), Sym)))\n+         returnType := NIL\n       ELSE\n-         PreAddModGcc(Sym, BuildEndFunctionDeclaration(begin, end,\n-                                                       KeyToCharStar(GetFullSymName(Sym)),\n-                                                       Mod2Gcc(GetSType(Sym)),\n-                                                       IsExternalToWholeProgram(Sym),\n-                                                       IsProcedureGccNested(Sym),\n-                                                       IsExported(GetModuleWhereDeclared(Sym), Sym)))\n+         returnType := Mod2Gcc(GetSType(Sym))\n       END ;\n+      PreAddModGcc(Sym, BuildEndFunctionDeclaration(begin, end,\n+                                                    KeyToCharStar(GetFullSymName(Sym)),\n+                                                    returnType,\n+                                                    IsExternalToWholeProgram(Sym),\n+                                                    IsProcedureGccNested(Sym),\n+                                                    IsExported(GetModuleWhereDeclared(Sym), Sym),\n+                                                    IsProcedureNoReturn(Sym))) ;\n       PopBinding(scope) ;\n       WatchRemoveList(Sym, todolist) ;\n       WatchIncludeList(Sym, fullydeclared)\n@@ -2479,7 +2479,8 @@ BEGIN\n                                                       IsExternal (Sym),  (* Extern relative to the main module.  *)\n                                                       IsProcedureGccNested (Sym),\n                                                       (* Exported from the module where it was declared.  *)\n-                                                      IsExported (GetModuleWhereDeclared (Sym), Sym) OR IsExtern (Sym))) ;\n+                                                      IsExported (GetModuleWhereDeclared (Sym), Sym) OR IsExtern (Sym),\n+                                                      IsProcedureNoReturn(Sym))) ;\n       PopBinding(scope) ;\n       WatchRemoveList(Sym, todolist) ;\n       WatchIncludeList(Sym, fullydeclared)"}, {"sha": "ac496f2d9327c0ed36887ba1ec46de74d7edfedf", "filename": "gcc/m2/gm2-compiler/M2LexBuf.mod", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FM2LexBuf.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FM2LexBuf.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FM2LexBuf.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -82,6 +82,8 @@ VAR\n    ListOfTokens     : ListDesc ;\n    CurrentTokNo     : CARDINAL ;\n    InsertionIndex   : CARDINAL ;\n+   SeenEof          : BOOLEAN ;  (* Have we seen eof since the last call\n+                                    to OpenSource.  *)\n \n \n (*\n@@ -122,6 +124,7 @@ END InitTokenList ;\n \n PROCEDURE Init ;\n BEGIN\n+   SeenEof := FALSE ;\n    InsertionIndex := 0 ;\n    currenttoken := eoftok ;\n    CurrentTokNo := InitialSourceToken ;\n@@ -337,6 +340,7 @@ END SetFile ;\n \n PROCEDURE OpenSource (s: String) : BOOLEAN ;\n BEGIN\n+   SeenEof := FALSE ;\n    IF UseBufferedTokens\n    THEN\n       GetToken ;\n@@ -605,6 +609,27 @@ BEGIN\n END DumpTokens ;\n \n \n+(*\n+   GetNonEofToken - providing that we have not already seen an eof for this source\n+                    file call m2flex.GetToken and GetToken if requested.\n+*)\n+\n+PROCEDURE GetNonEofToken (callGetToken: BOOLEAN) ;\n+BEGIN\n+   IF SeenEof\n+   THEN\n+      currenttoken := eoftok\n+   ELSE\n+      (* Call the lexical phase to place a new token into the last bucket.  *)\n+      m2flex.GetToken () ;\n+      IF callGetToken\n+      THEN\n+         GetToken\n+      END\n+   END\n+END GetNonEofToken ;\n+\n+\n (*\n    GetToken - gets the next token into currenttoken.\n *)\n@@ -622,24 +647,22 @@ BEGIN\n    ELSE\n       IF ListOfTokens.tail=NIL\n       THEN\n-         m2flex.GetToken () ;\n+         GetNonEofToken (FALSE) ;\n          IF ListOfTokens.tail=NIL\n          THEN\n             HALT\n          END\n       END ;\n       IF CurrentTokNo>=ListOfTokens.LastBucketOffset\n       THEN\n-         (* CurrentTokNo is in the last bucket or needs to be read *)\n+         (* CurrentTokNo is in the last bucket or needs to be read.  *)\n          IF CurrentTokNo-ListOfTokens.LastBucketOffset<ListOfTokens.tail^.len\n          THEN\n             UpdateFromBucket (ListOfTokens.tail,\n                               CurrentTokNo-ListOfTokens.LastBucketOffset)\n          ELSE\n-            (* call the lexical phase to place a new token into the last bucket *)\n-            m2flex.GetToken () ;\n-            GetToken ;  (* and call ourselves again to collect the token from bucket *)\n-            RETURN\n+            (* and call ourselves again to collect the token from bucket *)\n+            GetNonEofToken (TRUE)\n          END\n       ELSE\n          t := CurrentTokNo ;\n@@ -1175,6 +1198,10 @@ PROCEDURE AddTok (t: toktype) ;\n VAR\n    s: String ;\n BEGIN\n+   IF t = eoftok\n+   THEN\n+      SeenEof := TRUE\n+   END ;\n    IF NOT ((t=eoftok) AND IsLastTokenEof())\n    THEN\n       AddTokToList(t, NulName, 0,"}, {"sha": "dd2698430057fb7879e0da4ec32d6c27d65dc763", "filename": "gcc/m2/gm2-compiler/M2Options.def", "status": "modified", "additions": 85, "deletions": 6, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FM2Options.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FM2Options.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FM2Options.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -52,11 +52,12 @@ EXPORT QUALIFIED SetReturnCheck, SetNilCheck, SetCaseCheck,\n \t\t SetWholeValueCheck, GetWholeValueCheck,\n                  SetLowerCaseKeywords,\n                  SetIndex, SetRange, SetWholeDiv, SetStrictTypeChecking,\n-                 Setc, Getc, SetUselist, GetUselist, GetUselistFilename,\n-                 SetShared, SetB,\n+                 Setc, Getc, SetPPOnly, GetPPOnly,\n+                 SetUselist, GetUselist, GetUselistFilename,\n+                 SetShared,\n \n                  Iso, Pim, Pim2, Pim3, Pim4,\n-                 cflag,\n+                 PPonly, cflag,\n                  PositiveModFloorDiv,\n                  Pedantic, Verbose, Statistics,\n                  UnboundedByReference, VerboseUnbounded,\n@@ -83,7 +84,7 @@ EXPORT QUALIFIED SetReturnCheck, SetNilCheck, SetCaseCheck,\n                  DebugBuiltins, setdefextension, setmodextension,\n                  SetStatistics, SetWall,\n                  SetSaveTemps, SetSaveTempsDir, SaveTemps, GetSaveTempsDir,\n-                 GenModuleList,\n+                 SetDumpDir, GetDumpDir, GenModuleList,\n                  CppArg, CppCommandLine, CppRemember,\n \t\t SetDebugFunctionLineNumbers, DebugFunctionLineNumbers,\n \t\t SetGenerateStatementNote, GenerateStatementNote,\n@@ -92,10 +93,12 @@ EXPORT QUALIFIED SetReturnCheck, SetNilCheck, SetCaseCheck,\n                  SetScaffoldMain, ScaffoldMain,\n                  SetRuntimeModuleOverride, GetRuntimeModuleOverride,\n                  SetGenModuleList, GetGenModuleFilename, SharedFlag,\n-                 GetB ;\n+                 SetB, GetB, SetMD, GetMD, SetMMD, GetMMD, SetObj, GetObj,\n+                 GetMQ, SetMQ ;\n \n \n VAR\n+   PPonly,                       (* -E/M/MM present? - preprocessing only    *)\n    cflag,                        (* -c flag present?                         *)\n    Iso,                          (* -fiso use ISO SYSTEM.def                 *)\n    Pim,                          (* -fpim use PIM [234] SYSTEM.def           *)\n@@ -174,6 +177,18 @@ VAR\n    Coding,\n    Profiling               : BOOLEAN ;\n \n+(*\n+   SetPPOnly - set the PPonly to value (on E, M, MM).\n+*)\n+\n+PROCEDURE SetPPOnly (value: BOOLEAN) ;\n+\n+\n+(*\n+   GetPPOnly - get the PPonly (Preprocess only).\n+*)\n+\n+PROCEDURE GetPPOnly () : BOOLEAN ;\n \n (*\n    Setc - set the cflag (compile only flag -c) to value.\n@@ -195,13 +210,64 @@ PROCEDURE Getc () : BOOLEAN ;\n \n PROCEDURE SetB (arg: ADDRESS) ;\n \n-\n (*\n    GetB - returns argument to the -B option as a string or NIL if it were never set.\n *)\n \n PROCEDURE GetB () : ADDRESS ;\n \n+(*\n+   SetMD - assigns MD file to arg.\n+*)\n+\n+PROCEDURE SetMD (arg: ADDRESS) ;\n+\n+(*\n+   GetMD - returns the filename set for MD or NIL if it was never set.\n+*)\n+\n+PROCEDURE GetMD () : ADDRESS ;\n+\n+\n+(*\n+   SetMMD - assigns MMD file to arg.\n+*)\n+\n+PROCEDURE SetMMD (arg: ADDRESS) ;\n+\n+(*\n+   GetMMD - returns the filename set for MMD or NIL if it was never set.\n+*)\n+\n+PROCEDURE GetMMD () : ADDRESS ;\n+\n+(*\n+   SetMQ - assigns MQ file to arg.\n+*)\n+\n+PROCEDURE SetMQ (arg: ADDRESS) ;\n+\n+(*\n+   GetMQ - returns the filename set for MQ or NIL if it was never set.\n+*)\n+\n+PROCEDURE GetMQ () : ADDRESS ;\n+\n+(*\n+   SetScaffoldDynamic - set the -fscaffold-dynamic flag.\n+*)\n+\n+(*\n+   SetObj - assigns given object file to arg.\n+*)\n+\n+PROCEDURE SetObj (arg: ADDRESS) ;\n+\n+(*\n+   GetObj - returns the filename set for Object or NIL if it was never set.\n+*)\n+\n+PROCEDURE GetObj () : ADDRESS ;\n \n (*\n    SetScaffoldDynamic - set the -fscaffold-dynamic flag.\n@@ -784,6 +850,19 @@ PROCEDURE SetSaveTempsDir (arg: ADDRESS) ;\n \n PROCEDURE GetSaveTempsDir () : String ;\n \n+(*\n+   SetDumpDir - Specify dump dir.\n+*)\n+\n+PROCEDURE SetDumpDir (arg: ADDRESS) ;\n+\n+\n+(*\n+   GetDumpDir - return DumpDir or NIL.\n+*)\n+\n+PROCEDURE GetDumpDir () : String ;\n+\n \n (*\n    SetGenModuleList - set the GenModuleList flag to value and pass"}, {"sha": "865b85783679c410d0ec33d52f412a03e389df0d", "filename": "gcc/m2/gm2-compiler/M2Options.mod", "status": "modified", "additions": 144, "deletions": 7, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FM2Options.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FM2Options.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FM2Options.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -24,8 +24,10 @@ IMPLEMENTATION MODULE M2Options ;\n \n IMPORT CmdArgs ;\n FROM SArgs IMPORT GetArg, Narg ;\n-FROM M2Search IMPORT PrependSearchPath, SetDefExtension, SetModExtension ;\n-FROM M2Printf IMPORT printf0, printf1 ;\n+FROM M2Search IMPORT SetDefExtension, SetModExtension ;\n+FROM DynamicStringPath IMPORT Cons, GetUserPath, SetUserPath, Cons ;\n+FROM M2Printf IMPORT printf0, printf1, fprintf1 ;\n+FROM FIO IMPORT StdErr ;\n FROM libc IMPORT exit ;\n FROM Debug IMPORT Halt ;\n FROM m2linemap IMPORT location_t ;\n@@ -52,7 +54,12 @@ CONST\n \n VAR\n    Barg,\n+   MDarg,\n+   MMDarg,\n+   MQarg,\n+   CmdLineObj,\n    SaveTempsDir,\n+   DumpDir,\n    GenModuleListFilename,\n    UselistFilename,\n    RuntimeModuleOverride,\n@@ -130,6 +137,94 @@ BEGIN\n END GetB ;\n \n \n+(*\n+   SetMD - assigns MDarg to the filename from arg.\n+   This overrides any previous MMD.\n+*)\n+\n+PROCEDURE SetMD (arg: ADDRESS) ;\n+BEGIN\n+   MMDarg := KillString (MMDarg) ;\n+   MDarg := KillString (MDarg) ;\n+   MDarg := InitStringCharStar (arg)\n+END SetMD ;\n+\n+\n+(*\n+   GetMD - returns MDarg filename as a c-string or NIL if it was never set.\n+*)\n+\n+PROCEDURE GetMD () : ADDRESS ;\n+BEGIN\n+   RETURN string (MDarg)\n+END GetMD ;\n+\n+\n+(*\n+   SetMMD - assigns MMDarg to the filename from arg.\n+   This overrides any previous MD.\n+*)\n+\n+PROCEDURE SetMMD (arg: ADDRESS) ;\n+BEGIN\n+   MDarg := KillString (MDarg) ;\n+   MMDarg := KillString (MMDarg) ;\n+   MMDarg := InitStringCharStar (arg)\n+END SetMMD ;\n+\n+\n+(*\n+   GetMMD - returns MMDarg filename as a c-string or NIL if it was never set.\n+*)\n+\n+PROCEDURE GetMMD () : ADDRESS ;\n+BEGIN\n+   RETURN string (MMDarg)\n+END GetMMD ;\n+\n+\n+(*\n+   SetMQ - assigns MQarg to the filename from arg.\n+*)\n+\n+PROCEDURE SetMQ (arg: ADDRESS) ;\n+BEGIN\n+   MQarg := KillString (MQarg) ;\n+   MQarg := InitStringCharStar (arg)\n+END SetMQ ;\n+\n+\n+(*\n+   GetMMD - returns MQarg filename as a c-string or NIL if it was never set.\n+*)\n+\n+PROCEDURE GetMQ () : ADDRESS ;\n+BEGIN\n+   RETURN string (MQarg)\n+END GetMQ ;\n+\n+\n+(*\n+   SetObj - assigns CmdLineObj to the filename from arg.\n+*)\n+\n+PROCEDURE SetObj (arg: ADDRESS) ;\n+BEGIN\n+   CmdLineObj := KillString (CmdLineObj) ;\n+   CmdLineObj := InitStringCharStar (arg)\n+END SetObj ;\n+\n+\n+(*\n+   GetObj - returns CmdLineObj filename as a c-string or NIL if it was never set.\n+*)\n+\n+PROCEDURE GetObj () : ADDRESS ;\n+BEGIN\n+   RETURN string (CmdLineObj)\n+END GetObj ;\n+\n+\n (*\n    CppCommandLine - returns the Cpp command line and all arguments.\n                     NIL is returned if the -fcpp is absent.\n@@ -362,6 +457,25 @@ BEGIN\n END GetCpp ;\n \n \n+(*\n+   SetPPOnly - set the PPonly (preprocess only) to value.\n+*)\n+\n+PROCEDURE SetPPOnly (value: BOOLEAN) ;\n+BEGIN\n+   PPonly := value\n+END SetPPOnly ;\n+\n+(*\n+   GetPPOnly - get the PPonly (preprocess only).\n+*)\n+\n+PROCEDURE GetPPOnly () : BOOLEAN ;\n+BEGIN\n+   RETURN PPonly\n+END GetPPOnly ;\n+\n+\n (*\n    Setc - set the cflag (compile only flag -c) to value.\n *)\n@@ -789,10 +903,10 @@ BEGIN\n    s := InitStringCharStar(arg) ;\n    IF Debugging\n    THEN\n-      printf1(\"setting search path to: %s\\n\", s)\n+      fprintf1 (StdErr, \"M2Search.SetSearchPath setting search path to: %s\\n\", s)\n    END ;\n-   PrependSearchPath(s) ;\n-   s := KillString(s)\n+   SetUserPath (Cons (GetUserPath (), s)) ;\n+   s := KillString (s)\n END SetSearchPath ;\n \n \n@@ -1048,7 +1162,8 @@ END SetSaveTemps ;\n \n PROCEDURE SetSaveTempsDir (arg: ADDRESS) ;\n BEGIN\n-   SaveTempsDir := InitStringCharStar (arg)\n+   SaveTempsDir := InitStringCharStar (arg) ;\n+   SaveTemps := TRUE\n END SetSaveTempsDir ;\n \n \n@@ -1061,6 +1176,24 @@ BEGIN\n    RETURN SaveTempsDir\n END GetSaveTempsDir ;\n \n+(*\n+   SetDumpDir - Set the dump dir.\n+*)\n+\n+PROCEDURE SetDumpDir (arg: ADDRESS) ;\n+BEGIN\n+   DumpDir := InitStringCharStar (arg)\n+END SetDumpDir ;\n+\n+\n+(*\n+   GetDumpDir - return DumpDir or NIL.\n+*)\n+\n+PROCEDURE GetDumpDir () : String ;\n+BEGIN\n+   RETURN DumpDir\n+END GetDumpDir ;\n \n (*\n    SetScaffoldDynamic - set the -fscaffold-dynamic flag.\n@@ -1245,5 +1378,9 @@ BEGIN\n    GenModuleListFilename        := NIL ;\n    SharedFlag                   := FALSE ;\n    Barg                         := NIL ;\n-   SaveTempsDir                 := NIL\n+   MDarg                        := NIL ;\n+   MMDarg                       := NIL ;\n+   MQarg                        := NIL ;\n+   SaveTempsDir                 := NIL ;\n+   DumpDir                      := NIL\n END M2Options."}, {"sha": "02585800317255bee9b3ec969a2d60434de3634a", "filename": "gcc/m2/gm2-compiler/M2Preprocess.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FM2Preprocess.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FM2Preprocess.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FM2Preprocess.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -45,7 +45,7 @@ EXPORT QUALIFIED PreprocessModule ;\n                       All temporary files will be deleted when the compiler exits.\n *)\n \n-PROCEDURE PreprocessModule (filename: String) : String ;\n+PROCEDURE PreprocessModule (filename: String; isMain: BOOLEAN) : String ;\n \n \n END M2Preprocess."}, {"sha": "d63db35f93898dcc1e61e3ff11074851227620d9", "filename": "gcc/m2/gm2-compiler/M2Preprocess.mod", "status": "modified", "additions": 117, "deletions": 13, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FM2Preprocess.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FM2Preprocess.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FM2Preprocess.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -25,15 +25,16 @@ IMPLEMENTATION MODULE M2Preprocess ;\n FROM SYSTEM IMPORT WORD ;\n \n FROM DynamicStrings IMPORT string, InitString, Mark, KillString, EqualArray, InitStringCharStar,\n-                           Dup, ConCat, ConCatChar, RIndex, Slice ;\n+                           Dup, ConCat, ConCatChar, RIndex, Slice, Length ;\n \n FROM choosetemp IMPORT make_temp_file ;\n FROM pexecute IMPORT pexecute ;\n FROM libc IMPORT system, exit, unlink, printf, atexit ;\n FROM Lists IMPORT List, InitList, KillList, IncludeItemIntoList, ForeachItemInListDo ;\n FROM FIO IMPORT StdErr, StdOut ;\n FROM M2Printf IMPORT fprintf1 ;\n-FROM M2Options IMPORT Verbose, CppCommandLine, SaveTemps ;\n+FROM M2Options IMPORT Verbose, PPonly, GetObj, GetMD, GetMMD, GetMQ,\n+                      CppCommandLine, SaveTemps, GetSaveTempsDir, GetDumpDir ;\n FROM NameKey IMPORT Name, MakeKey, KeyToCharStar, makekey ;\n \n \n@@ -77,14 +78,80 @@ BEGIN\n    RETURN 0\n END RemoveFiles ;\n \n+(*\n+   Return the filename with no path.\n+*)\n+\n+PROCEDURE GetFileName (Path: String) : String ;\n+VAR\n+   fstart: INTEGER ;\n+BEGIN\n+   fstart := RIndex(Path, '/', 0) ;\n+   IF fstart=-1\n+   THEN\n+      fstart := 0\n+   ELSE\n+      fstart := fstart + 1\n+   END ;\n+   RETURN Dup (Slice(Path, fstart, Length (Path)))\n+END GetFileName ;\n+\n+\n+(*\n+   Return basename.\n+*)\n+\n+PROCEDURE BaseName (Path: String) : String ;\n+VAR\n+   ext,\n+   basename: INTEGER ;\n+BEGIN\n+   basename := RIndex(Path, '/', 0) ;\n+   IF basename=-1\n+   THEN\n+      basename := 0\n+   ELSE\n+      basename := basename + 1\n+   END ;\n+   ext := RIndex(Path, '.', 0) ;\n+   IF ext=-1\n+   THEN\n+      ext := 0\n+   END ;\n+   RETURN Dup (Slice(Path, basename, ext))\n+END BaseName ;\n \n (*\n-   MakeSaveTempsFileName - return a temporary file \"filename.i\".\n+   MakeSaveTempsFileName - return a temporary file like \n+   \"./filename.{def,mod}.m2i\" in the CWD unless SaveTempsDir = obj,\n+   when we put it in the dumpdir if that is specified (or fallback to '.'\n+   if not).\n+   We have to keep the original extension because that disambiguates .def\n+   and .mod files (otherwise, we'd need two 'preprocessed' extensions).\n *)\n \n PROCEDURE MakeSaveTempsFileName (filename: String) : String ;\n+VAR\n+   NewName,\n+   DumpDir,\n+   NewDir : String ;\n BEGIN\n-   RETURN ConCat (Dup (filename), InitString ('.i'))\n+   NewName := ConCat (GetFileName (filename), InitString ('.m2i')) ;\n+   NewDir := GetSaveTempsDir () ;\n+   DumpDir := GetDumpDir () ;\n+(*   IF Verbose\n+   THEN\n+      fprintf1 (StdOut, \"newname: %s\", NewName) ;\n+      fprintf1 (StdOut, \" NewDir: %s\", NewDir) ;\n+      fprintf1 (StdOut, \" DumpDir: %s\\n\", DumpDir)\n+   END ;\n+*)\n+   IF (NewDir#NIL) AND EqualArray (NewDir, 'obj') AND (DumpDir#NIL)\n+   THEN\n+      RETURN Dup (ConCat (DumpDir, NewName))\n+   ELSE\n+      RETURN Dup (ConCat (InitString ('./'), NewName))\n+   END ;\n END MakeSaveTempsFileName ;\n \n \n@@ -98,7 +165,7 @@ END MakeSaveTempsFileName ;\n                       All temporary files will be deleted when the compiler exits.\n *)\n \n-PROCEDURE PreprocessModule (filename: String) : String ;\n+PROCEDURE PreprocessModule (filename: String; isMain: BOOLEAN) : String ;\n VAR\n    tempfile,\n    command,\n@@ -107,18 +174,55 @@ BEGIN\n    command := CppCommandLine () ;\n    IF (command = NIL) OR EqualArray (command, '')\n    THEN\n-      RETURN filename\n+      RETURN Dup (filename)\n    ELSE\n-      IF SaveTemps\n+      commandLine := Dup (command) ;\n+      tempfile := NIL ;\n+      (* We support MD and MMD for the main file only, at present.  *)\n+      IF isMain OR PPonly\n+      THEN\n+         IF GetMD () # NIL\n+         THEN\n+            tempfile := ConCat( Mark (InitString(' -MD ')),\n+                                InitStringCharStar (GetMD ()))\n+         ELSIF GetMMD () # NIL\n+         THEN\n+            tempfile := ConCat( Mark (InitString(' -MMD ')),\n+                                InitStringCharStar (GetMMD ()))\n+         END ;\n+         IF tempfile#NIL\n+         THEN\n+            commandLine := ConCat (Dup (commandLine), Dup (tempfile)) ;\n+            (* We can only add MQ if we already have an MD/MMD.  *)\n+            IF GetMQ () # NIL\n+            THEN\n+               tempfile := ConCat( Mark (InitString(' -MQ ')),\n+                                 InitStringCharStar (GetMQ ())) ;\n+               commandLine := ConCat (Dup (commandLine), Dup (tempfile))\n+            END ;\n+         END ;\n+      END ;\n+      (* The output file depends on whether we are in stand-alone PP mode, and\n+         if an output file is specified.  *)\n+      tempfile := NIL ;\n+      IF PPonly\n+      THEN\n+         IF GetObj () # NIL\n+         THEN\n+           tempfile := InitStringCharStar (GetObj ())\n+         END ;\n+      ELSIF SaveTemps\n       THEN\n-         tempfile := InitStringCharStar (MakeSaveTempsFileName (filename))\n+         tempfile := MakeSaveTempsFileName (filename)\n       ELSE\n-         tempfile := InitStringCharStar (make_temp_file (KeyToCharStar (MakeKey('i'))))\n+         tempfile := InitStringCharStar (make_temp_file (KeyToCharStar (MakeKey('.m2i'))))\n+      END ;\n+      commandLine := ConCat (ConCatChar (Dup (commandLine), ' '), filename) ;\n+      IF tempfile # NIL\n+      THEN\n+         commandLine := ConCat (ConCat (Dup (commandLine),\n+                                        Mark (InitString(' -o '))), tempfile) ;\n       END ;\n-      commandLine := Dup (command) ;\n-      commandLine := ConCat (ConCat (ConCat (ConCatChar (Dup (commandLine), ' '), filename),\n-                                     Mark (InitString(' -o '))),\n-                             tempfile) ;\n (*  use pexecute in the future\n       res := pexecute(string(Slice(commandLine, 0, Index(commandLine, ' ', 0))), etc etc );\n *)"}, {"sha": "3b6ed4531e9d97ec1681f796824921fc61ca712a", "filename": "gcc/m2/gm2-compiler/M2Quads.mod", "status": "modified", "additions": 39, "deletions": 19, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FM2Quads.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FM2Quads.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FM2Quads.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -2469,6 +2469,7 @@ BEGIN\n             }\n             catch (...) {\n                RTExceptions_DefaultErrorCatch ();\n+               return 0;\n             }\n          }\n       *)\n@@ -2492,10 +2493,11 @@ BEGIN\n       PushTtok (RequestSym (tokno, MakeKey (\"envp\")), tokno) ;\n       PushT (3) ;\n       BuildProcedureCall (tokno) ;\n-\n       PushZero (tokno, Integer) ;\n       BuildReturn (tokno) ;\n       BuildExcept (tokno) ;\n+      PushZero (tokno, Integer) ;\n+      BuildReturn (tokno) ;\n       EndScope ;\n       BuildProcedureEnd ;\n       PopN (1)\n@@ -6327,7 +6329,10 @@ BEGIN\n    ELSIF IsVar(Sym)\n    THEN\n       Type := GetDType(Sym) ;\n-      IF IsUnbounded(Type)\n+      IF Type = NulSym\n+      THEN\n+         MetaErrorT1 (tok, '{%1ad} has no type and cannot be passed to a VAR formal parameter', Sym)\n+      ELSIF IsUnbounded(Type)\n       THEN\n          IF Type = GetSType (UnboundedSym)\n          THEN\n@@ -6382,7 +6387,10 @@ BEGIN\n    ELSIF IsVar (Sym)\n    THEN\n       Type := GetDType (Sym) ;\n-      IF IsUnbounded (Type)\n+      IF Type = NulSym\n+      THEN\n+         MetaErrorT1 (tok, '{%1ad} has no type and cannot be passed to a non VAR formal parameter', Sym)\n+      ELSIF IsUnbounded (Type)\n       THEN\n          UnboundedNonVarLinkToArray (tok, Sym, ArraySym, UnboundedSym, ParamType, dim)\n       ELSIF IsArray (Type) OR IsGenericSystemType (ParamType)\n@@ -8095,14 +8103,11 @@ END BuildHighFunction ;\n \n PROCEDURE BuildConstHighFromSym (tok: CARDINAL) ;\n VAR\n-   Dim,\n    NoOfParam,\n    ReturnVar: CARDINAL ;\n BEGIN\n    PopT (NoOfParam) ;\n    ReturnVar := MakeTemporary (tok, ImmediateValue) ;\n-   Dim := OperandD (1) ;\n-   INC (Dim) ;\n    GenHigh (tok, ReturnVar, 1, OperandT (1)) ;\n    PopN (NoOfParam+1) ;\n    PushTtok (ReturnVar, tok)\n@@ -11386,7 +11391,10 @@ VAR\n BEGIN\n    PopTFrwtok (Sym1, Type1, rw, exprtok) ;\n    Type1 := SkipType (Type1) ;\n-   IF IsUnknown (Sym1)\n+   IF Type1 = NulSym\n+   THEN\n+      MetaErrorT1 (ptrtok, '{%1ad} has no type and therefore cannot be dereferenced by ^', Sym1)\n+   ELSIF IsUnknown (Sym1)\n    THEN\n       MetaError1 ('{%1EMad} is undefined and therefore {%1ad}^ cannot be resolved', Sym1)\n    ELSIF IsPointer (Type1)\n@@ -11436,6 +11444,7 @@ VAR\n    Sym, Type,\n    Ref      : CARDINAL ;\n BEGIN\n+   BuildStmtNoteTok (withTok) ;\n    DisplayStack ;\n    PopTFtok (Sym, Type, tok) ;\n    Type := SkipType (Type) ;\n@@ -14098,25 +14107,36 @@ END PushLineNo ;\n \n PROCEDURE BuildStmtNote (offset: INTEGER) ;\n VAR\n-   filename: Name ;\n-   f       : QuadFrame ;\n-   i       : INTEGER ;\n+   tokenno: INTEGER ;\n BEGIN\n    IF NextQuad#Head\n    THEN\n-      f := GetQF (NextQuad-1) ;\n-      i := offset ;\n-      INC (i, GetTokenNo ()) ;\n-      (* no need to have multiple notes at the same position.  *)\n-      IF (f^.Operator # StatementNoteOp) OR (f^.Operand3 # VAL (CARDINAL, i))\n-      THEN\n-         filename := makekey (string (GetFileName ())) ;\n-         GenQuad (StatementNoteOp, WORD (filename), NulSym, i)\n-      END\n+      tokenno := offset ;\n+      INC (tokenno, GetTokenNo ()) ;\n+      BuildStmtNoteTok (VAL(CARDINAL, tokenno))\n    END\n END BuildStmtNote ;\n \n \n+(*\n+   BuildStmtNoteTok - adds a nop (with an assigned tokenno location) to the code.\n+*)\n+\n+PROCEDURE BuildStmtNoteTok (tokenno: CARDINAL) ;\n+VAR\n+   filename: Name ;\n+   f       : QuadFrame ;\n+BEGIN\n+   f := GetQF (NextQuad-1) ;\n+   (* no need to have multiple notes at the same position.  *)\n+   IF (f^.Operator # StatementNoteOp) OR (f^.Operand3 # tokenno)\n+   THEN\n+      filename := makekey (string (GetFileName ())) ;\n+      GenQuad (StatementNoteOp, WORD (filename), NulSym, tokenno)\n+   END\n+END BuildStmtNoteTok ;\n+\n+\n (*\n    AddRecordToList - adds the record held on the top of stack to the\n                      list of records and varient fields."}, {"sha": "3d172378cf5ee5e8809612c36cf098092644c84c", "filename": "gcc/m2/gm2-compiler/M2Search.def", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FM2Search.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FM2Search.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FM2Search.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -31,31 +31,6 @@ DEFINITION MODULE M2Search ;\n *)\n \n FROM DynamicStrings IMPORT String ;\n-EXPORT QUALIFIED InitSearchPath, PrependSearchPath, FindSourceFile,\n-                 FindSourceDefFile, FindSourceModFile,\n-                 SetDefExtension, SetModExtension ;\n-\n-\n-(*\n-   InitSearchPath - assigns the search path to Path.\n-                    The string Path may take the form:\n-\n-                    Path           ::= IndividualPath { \":\" IndividualPath }\n-                    IndividualPath ::= \".\" | DirectoryPath\n-                    DirectoryPath  ::= [ \"/\" ] Name { \"/\" Name }\n-                    Name           ::= Letter { (Letter | Number) }\n-                    Letter         ::= A..Z | a..z\n-                    Number         ::= 0..9\n-*)\n-\n-PROCEDURE InitSearchPath (Path: String) ;\n-\n-\n-(*\n-   PrependSearchPath - prepends a new path to the initial search path.\n-*)\n-\n-PROCEDURE PrependSearchPath (path: String) ;\n \n \n (*"}, {"sha": "cc61ebfb3539e8693b4aab11cf2174b60133d16f", "filename": "gcc/m2/gm2-compiler/M2Search.mod", "status": "modified", "additions": 22, "deletions": 109, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FM2Search.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FM2Search.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FM2Search.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -22,9 +22,9 @@ along with GNU Modula-2; see the file COPYING3.  If not see\n IMPLEMENTATION MODULE M2Search ;\n \n \n-FROM SFIO IMPORT Exists ;\n FROM M2FileName IMPORT CalculateFileName ;\n FROM Assertion IMPORT Assert ;\n+FROM DynamicStringPath IMPORT GetUserPath, GetSystemPath, FindFileName ;\n \n FROM DynamicStrings IMPORT InitString, InitStringChar,\n                            KillString, ConCat, ConCatChar, Index, Slice,\n@@ -35,13 +35,10 @@ FROM DynamicStrings IMPORT InitString, InitStringChar,\n \n \n CONST\n-   Directory        =   '/' ;\n    GarbageDebugging = FALSE ;\n \n VAR\n-   Def, Mod,\n-   UserPath,\n-   InitialPath: String ;\n+   Def, Mod: String ;\n \n (* Internal garbage collection debugging routines.  *)\n \n@@ -109,24 +106,6 @@ END DSdbExit ;\n *)\n \n \n-(*\n-   PrependSearchPath - prepends a new path to the initial search path.\n-*)\n-\n-PROCEDURE PrependSearchPath (path: String) ;\n-BEGIN\n-   DSdbEnter ;\n-   IF EqualArray(UserPath, '')\n-   THEN\n-      UserPath := KillString(UserPath) ;\n-      UserPath := Dup(path)\n-   ELSE\n-      UserPath := ConCat(ConCatChar(UserPath, ':'), path)\n-   END ;\n-   DSdbExit (UserPath)\n-END PrependSearchPath ;\n-\n-\n (*\n    FindSourceFile - attempts to locate the source file FileName.\n                     If a file is found then TRUE is returned otherwise\n@@ -143,55 +122,13 @@ END PrependSearchPath ;\n \n PROCEDURE FindSourceFile (FileName: String;\n                           VAR FullPath: String) : BOOLEAN ;\n-VAR\n-   CompleteSearchPath: String ;\n-   start, end        : INTEGER ;\n-   newpath           : String ;\n BEGIN\n-   IF EqualArray(UserPath, '')\n+   FullPath := FindFileName (FileName, GetUserPath ()) ;\n+   IF FullPath = NIL\n    THEN\n-      IF EqualArray(InitialPath, '')\n-      THEN\n-         CompleteSearchPath := InitString('.')\n-      ELSE\n-         CompleteSearchPath := Dup(InitialPath)\n-      END\n-   ELSE\n-      CompleteSearchPath := ConCat(ConCatChar(Dup(UserPath), ':'), InitialPath)\n+      FullPath := FindFileName (FileName, GetSystemPath ())\n    END ;\n-   start := 0 ;\n-   end   := Index(CompleteSearchPath, ':', CARDINAL(start)) ;\n-   REPEAT\n-      IF end=-1\n-      THEN\n-         end := 0\n-      END ;\n-      newpath := Slice(CompleteSearchPath, start, end) ;\n-      IF EqualArray(newpath, '.')\n-      THEN\n-         newpath := KillString(newpath) ;\n-         newpath := Dup(FileName)\n-      ELSE\n-         newpath := ConCat(ConCatChar(newpath, Directory), FileName)\n-      END ;\n-      IF Exists(newpath)\n-      THEN\n-         FullPath := newpath ;\n-         CompleteSearchPath := KillString(CompleteSearchPath) ;\n-         RETURN( TRUE )\n-      END ;\n-      newpath := KillString(newpath) ;\n-      IF end#0\n-      THEN\n-         start := end+1 ;\n-         end   := Index(CompleteSearchPath, ':', CARDINAL(start))\n-      END\n-   UNTIL end=0 ;\n-\n-   FullPath := NIL ;\n-   newpath := KillString(newpath) ;\n-   CompleteSearchPath :=  KillString(CompleteSearchPath) ;\n-   RETURN( FALSE )\n+   RETURN FullPath # NIL\n END FindSourceFile ;\n \n \n@@ -206,18 +143,18 @@ PROCEDURE FindSourceDefFile (Stem: String; VAR FullPath: String) : BOOLEAN ;\n VAR\n    f: String ;\n BEGIN\n-   IF Def#NIL\n+   IF Def # NIL\n    THEN\n-      f := CalculateFileName(Stem, Def) ;\n-      IF FindSourceFile(f, FullPath)\n+      f := CalculateFileName (Stem, Def) ;\n+      IF FindSourceFile (f, FullPath)\n       THEN\n-         RETURN( TRUE )\n+         RETURN TRUE\n       END ;\n-      f := KillString(f)\n+      f := KillString (f)\n    END ;\n-   (* and try the GNU Modula-2 default extension *)\n-   f := CalculateFileName(Stem, Mark(InitString('def'))) ;\n-   RETURN( FindSourceFile(f, FullPath) )\n+   (* Try the GNU Modula-2 default extension.  *)\n+   f := CalculateFileName (Stem, Mark(InitString ('def'))) ;\n+   RETURN FindSourceFile (f, FullPath)\n END FindSourceDefFile ;\n \n \n@@ -234,16 +171,16 @@ VAR\n BEGIN\n    IF Mod#NIL\n    THEN\n-      f := CalculateFileName(Stem, Mod) ;\n-      IF FindSourceFile(f, FullPath)\n+      f := CalculateFileName (Stem, Mod) ;\n+      IF FindSourceFile (f, FullPath)\n       THEN\n-         RETURN( TRUE )\n+         RETURN TRUE\n       END ;\n-      f := KillString(f)\n+      f := KillString (f)\n    END ;\n-   (* and try the GNU Modula-2 default extension *)\n-   f := CalculateFileName(Stem, Mark(InitString('mod'))) ;\n-   RETURN( FindSourceFile(f, FullPath) )\n+   (* Try the GNU Modula-2 default extension.  *)\n+   f := CalculateFileName (Stem, Mark(InitString ('mod'))) ;\n+   RETURN FindSourceFile (f, FullPath)\n END FindSourceModFile ;\n \n \n@@ -274,35 +211,11 @@ END SetModExtension ;\n \n \n (*\n-   InitSearchPath - assigns the search path to Path.\n-                    The string Path may take the form:\n-\n-                    Path           ::= IndividualPath { \":\" IndividualPath }\n-                    IndividualPath ::= \".\" | DirectoryPath\n-                    DirectoryPath  ::= [ \"/\" ] Name { \"/\" Name }\n-                    Name           ::= Letter { (Letter | Number) }\n-                    Letter         ::= A..Z | a..z\n-                    Number         ::= 0..9\n-*)\n-\n-PROCEDURE InitSearchPath (Path: String) ;\n-BEGIN\n-   IF InitialPath#NIL\n-   THEN\n-      InitialPath := KillString(InitialPath)\n-   END ;\n-   InitialPath := Path\n-END InitSearchPath ;\n-\n-\n-(*\n-   Init - initializes the search path.\n+   Init - initializes the def and mod default string names to NIL.\n *)\n \n PROCEDURE Init ;\n BEGIN\n-   UserPath    := InitString('') ;\n-   InitialPath := InitStringChar('.') ;\n    Def := NIL ;\n    Mod := NIL\n END Init ;"}, {"sha": "ea5cfe73a5d0d730319eda80cb754e745a9acc1c", "filename": "gcc/m2/gm2-compiler/P2Build.bnf", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FP2Build.bnf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FP2Build.bnf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FP2Build.bnf?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -97,6 +97,7 @@ FROM P2SymBuild IMPORT P2StartBuildProgramModule,\n                        StartBuildProcedure,\n                        EndBuildProcedure,\n                        BuildFunction, BuildOptFunction,\n+                       BuildNoReturnAttribute,\n \n                        BuildPointerType,\n                        BuildRecord, BuildFieldRecord,\n@@ -1025,8 +1026,8 @@ ProcedureHeading := \"PROCEDURE\"                                            % M2E\n                                                                            % StartBuildProcedure %\n                                                                            % Assert(IsProcedure(OperandT(1))) %\n                                                                            % StartBuildFormalParameters  %\n-                       [ FormalParameters ] AttributeNoReturn\n-                                                                           % EndBuildFormalParameters %\n+                       [ FormalParameters ]                                % EndBuildFormalParameters %\n+                                            AttributeNoReturn\n                                                                            % BuildProcedureHeading %\n                      )\n                      =:\n@@ -1039,15 +1040,17 @@ DefProcedureHeading := \"PROCEDURE\"                                         % M2E\n                                                                            % StartBuildProcedure %\n                                                                            % Assert(IsProcedure(OperandT(1))) %\n                                                                            % StartBuildFormalParameters  %\n-                          [ DefFormalParameters ] AttributeNoReturn\n-                                                                           % EndBuildFormalParameters %\n+                          [ DefFormalParameters ]                          % EndBuildFormalParameters %\n+                                                  AttributeNoReturn\n                                                                            % BuildProcedureHeading %\n                         )                                                  % M2Error.LeaveErrorScope %\n                     =:\n \n AttributeNoReturn := [ \"<*\"                                                % PushAutoOn %\n                             Ident                                          % PopAuto %\n                                                                            % checkReturnAttribute %\n+                                                                           % Assert(IsProcedure(OperandT(1))) %\n+                                                                           % BuildNoReturnAttribute (OperandT(1)) %\n                                    \"*>\" ] =:\n \n AttributeUnused := [ \"<*\"                                                  % PushAutoOn %"}, {"sha": "d5dd9feb25c0162aacc26ee68fbbba3a4ff84c7a", "filename": "gcc/m2/gm2-compiler/P2SymBuild.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FP2SymBuild.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FP2SymBuild.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FP2SymBuild.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -61,6 +61,7 @@ EXPORT QUALIFIED P2StartBuildDefModule,\n                  BuildOptArg,\n                  StartBuildProcedure,\n                  EndBuildProcedure,\n+                 BuildNoReturnAttribute,\n                  BuildFunction,\n                  BuildOptFunction,\n                  BuildPointerType,\n@@ -863,6 +864,13 @@ PROCEDURE StartBuildProcedure ;\n PROCEDURE EndBuildProcedure ;\n \n \n+(*\n+   BuildNoReturnAttribute - provide an interface to the symbol table module.\n+*)\n+\n+PROCEDURE BuildNoReturnAttribute (procedureSym: CARDINAL) ;\n+\n+\n (*\n    BuildPointerType - builds a pointer type.\n                       The Stack:"}, {"sha": "de56cc46c5c6b7525b9901c02ad74777b1d56ccf", "filename": "gcc/m2/gm2-compiler/P2SymBuild.mod", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FP2SymBuild.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FP2SymBuild.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FP2SymBuild.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -108,6 +108,7 @@ FROM SymbolTable IMPORT NulSym,\n                         ParametersDefinedInDefinition,\n                         ParametersDefinedInImplementation,\n                         ProcedureParametersDefined,\n+                        PutProcedureNoReturn,\n                         CheckForUnImplementedExports,\n                         CheckForUndeclaredExports,\n                         IsHiddenTypeDeclared,\n@@ -2098,6 +2099,17 @@ BEGIN\n END BuildOptFunction ;\n \n \n+(*\n+   BuildNoReturnAttribute - provide an interface to the symbol table module.\n+*)\n+\n+PROCEDURE BuildNoReturnAttribute (procedureSym: CARDINAL) ;\n+BEGIN\n+   Assert (IsProcedure (procedureSym)) ;\n+   PutProcedureNoReturn (procedureSym, TRUE)\n+END BuildNoReturnAttribute ;\n+\n+\n (*\n    BuildPointerType - builds a pointer type.\n                       The Stack:"}, {"sha": "c6c39d929621b46985b3ea360bf04a4ee8622248", "filename": "gcc/m2/gm2-compiler/SymbolTable.def", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FSymbolTable.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FSymbolTable.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FSymbolTable.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -191,6 +191,7 @@ EXPORT QUALIFIED NulSym,\n                  PutProcedureEndQuad,\n                  PutProcedureScopeQuad,\n                  PutProcedureReachable,\n+                 PutProcedureNoReturn, IsProcedureNoReturn,\n                  PutReadQuad, RemoveReadQuad,\n                  PutWriteQuad, RemoveWriteQuad,\n                  PutGnuAsm, PutGnuAsmOutput, PutGnuAsmInput, PutGnuAsmTrash,\n@@ -1274,7 +1275,7 @@ PROCEDURE PutProcedureInline (Sym: CARDINAL) ;\n \n \n (*\n-   IsProcedureBuiltin - returns TRUE if this procedure was declared as inlined.\n+   IsProcedureInline - returns TRUE if this procedure was declared as inlined.\n *)\n \n PROCEDURE IsProcedureInline (Sym: CARDINAL) : BOOLEAN ;\n@@ -1636,6 +1637,21 @@ PROCEDURE PutProcedureReachable (Sym: CARDINAL) ;\n PROCEDURE IsProcedureReachable (Sym: CARDINAL) : BOOLEAN ;\n \n \n+(*\n+   PutProcedureNoReturn - places value into the no return attribute\n+                          field of procedure sym.\n+*)\n+\n+PROCEDURE PutProcedureNoReturn (Sym: CARDINAL; value: BOOLEAN) ;\n+\n+\n+(*\n+   IsProcedureNoReturn - returns TRUE if this procedure never returns.\n+*)\n+\n+PROCEDURE IsProcedureNoReturn (Sym: CARDINAL) : BOOLEAN ;\n+\n+\n (*\n    PutModuleStartQuad - Places QuadNumber into the Module symbol, Sym.\n                         QuadNumber is the start quad of Module,"}, {"sha": "cc1a874b7913adca52ca85faa3321c5985ca30b5", "filename": "gcc/m2/gm2-compiler/SymbolTable.mod", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FSymbolTable.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-compiler%2FSymbolTable.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-compiler%2FSymbolTable.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -360,6 +360,7 @@ TYPE\n                IsBuiltin     : BOOLEAN ;    (* Was it declared __BUILTIN__ ? *)\n                BuiltinName   : Name ;       (* name of equivalent builtin    *)\n                IsInline      : BOOLEAN ;    (* Was it declared __INLINE__ ?  *)\n+               IsNoReturn    : BOOLEAN ;    (* Attribute noreturn ?          *)\n                ReturnOptional: BOOLEAN ;    (* Is the return value optional? *)\n                IsExtern      : BOOLEAN ;    (* Make this procedure extern.   *)\n                IsPublic      : BOOLEAN ;    (* Make this procedure visible.  *)\n@@ -3775,6 +3776,7 @@ BEGIN\n             IsBuiltin := FALSE ;         (* Was it declared __BUILTIN__ ? *)\n             BuiltinName := NulName ;     (* name of equivalent builtin    *)\n             IsInline := FALSE ;          (* Was is declared __INLINE__ ?  *)\n+            IsNoReturn := FALSE ;        (* Declared attribute noreturn ? *)\n             ReturnOptional := FALSE ;    (* Is the return value optional? *)\n             IsExtern := FALSE ;          (* Make this procedure external. *)\n             IsPublic := FALSE ;          (* Make this procedure visible.  *)\n@@ -3824,6 +3826,49 @@ BEGIN\n END MakeProcedure ;\n \n \n+(*\n+   PutProcedureNoReturn - places value into the no return attribute\n+                          field of procedure sym.\n+*)\n+\n+PROCEDURE PutProcedureNoReturn (Sym: CARDINAL; value: BOOLEAN) ;\n+VAR\n+   pSym: PtrToSymbol ;\n+BEGIN\n+   pSym := GetPsym (Sym) ;\n+   WITH pSym^ DO\n+      CASE SymbolType OF\n+\n+      ProcedureSym: Procedure.IsNoReturn := value\n+\n+      ELSE\n+         InternalError ('expecting ProcedureSym symbol')\n+      END\n+   END\n+END PutProcedureNoReturn ;\n+\n+\n+(*\n+   IsProcedureNoReturn - returns TRUE if this procedure never returns.\n+*)\n+\n+PROCEDURE IsProcedureNoReturn (Sym: CARDINAL) : BOOLEAN ;\n+VAR\n+   pSym: PtrToSymbol ;\n+BEGIN\n+   pSym := GetPsym (Sym) ;\n+   WITH pSym^ DO\n+      CASE SymbolType OF\n+\n+      ProcedureSym: RETURN Procedure.IsNoReturn\n+\n+      ELSE\n+         InternalError ('expecting ProcedureSym symbol')\n+      END\n+   END\n+END IsProcedureNoReturn ;\n+\n+\n (*\n    PutMonoName - changes the IsMonoName boolean inside the procedure.\n *)"}, {"sha": "a9dfcc70069d837ce6f1d26b586a37f129bee7b4", "filename": "gcc/m2/gm2-gcc/init.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-gcc%2Finit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-gcc%2Finit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-gcc%2Finit.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -55,6 +55,7 @@ EXTERN void _M2_CmdArgs_init (int argc, char *argv[], char *envp[]);\n EXTERN void _M2_M2Preprocess_init (int argc, char *argv[], char *envp[]);\n EXTERN void _M2_M2Error_init (int argc, char *argv[], char *envp[]);\n EXTERN void _M2_M2Search_init (int argc, char *argv[], char *envp[]);\n+EXTERN void _M2_DynamicStringPath_init (int argc, char *argv[], char *envp[]);\n EXTERN void _M2_Indexing_init (int argc, char *argv[], char *envp[]);\n EXTERN void _M2_NameKey_init (int argc, char *argv[], char *envp[]);\n EXTERN void _M2_NumberIO_init (int argc, char *argv[], char *envp[]);\n@@ -141,6 +142,7 @@ init_FrontEndInit (void)\n   _M2_StrLib_init (0, NULL, NULL);\n   _M2_dtoa_init (0, NULL, NULL);\n   _M2_ldtoa_init (0, NULL, NULL);\n+  _M2_DynamicStringPath_init (0, NULL, NULL);\n   _M2_M2Search_init (0, NULL, NULL);\n   _M2_M2Options_init (0, NULL, NULL);\n }"}, {"sha": "ab409378673f566decb518ff74073920d2edd0d6", "filename": "gcc/m2/gm2-gcc/m2decl.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-gcc%2Fm2decl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-gcc%2Fm2decl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-gcc%2Fm2decl.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -211,7 +211,7 @@ tree\n m2decl_BuildEndFunctionDeclaration (location_t location_begin,\n                                     location_t location_end, const char *name,\n                                     tree returntype, int isexternal,\n-                                    int isnested, int ispublic)\n+                                    int isnested, int ispublic, int isnoreturn)\n {\n   tree fntype;\n   tree fndecl;\n@@ -244,6 +244,7 @@ m2decl_BuildEndFunctionDeclaration (location_t location_begin,\n       = build_decl (location_end, RESULT_DECL, NULL_TREE, returntype);\n   DECL_CONTEXT (DECL_RESULT (fndecl)) = fndecl;\n   TREE_TYPE (fndecl) = fntype;\n+  TREE_THIS_VOLATILE (fndecl) = isnoreturn;\n \n   DECL_SOURCE_LOCATION (fndecl) = location_begin;\n "}, {"sha": "6a1969336a20604decf84ea4c8029963bc47a5cb", "filename": "gcc/m2/gm2-gcc/m2decl.def", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-gcc%2Fm2decl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-gcc%2Fm2decl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-gcc%2Fm2decl.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -149,7 +149,8 @@ PROCEDURE BuildStartFunctionDeclaration (uses_varargs: BOOLEAN) ;\n \n PROCEDURE BuildEndFunctionDeclaration (location_begin, location_end: location_t;\n                                        name: ADDRESS; returntype: Tree;\n-                                       isexternal, isnested, ispublic: BOOLEAN) : Tree ;\n+                                       isexternal, isnested, ispublic,\n+                                       isnoreturn: BOOLEAN) : Tree ;\n \n \n (*"}, {"sha": "19dbb7be4e172f944e29fce33b030a5db1c683fc", "filename": "gcc/m2/gm2-gcc/m2decl.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-gcc%2Fm2decl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-gcc%2Fm2decl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-gcc%2Fm2decl.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -58,7 +58,8 @@ EXTERN void m2decl_RememberVariables (tree l);\n \n EXTERN tree m2decl_BuildEndFunctionDeclaration (\n     location_t location_begin, location_t location_end, const char *name,\n-    tree returntype, int isexternal, int isnested, int ispublic);\n+    tree returntype, int isexternal, int isnested, int ispublic,\n+    int isnoreturn);\n EXTERN void m2decl_BuildStartFunctionDeclaration (int uses_varargs);\n EXTERN tree m2decl_BuildParameterDeclaration (location_t location, char *name,\n                                               tree type, int isreference);"}, {"sha": "ab7df80455898a1af74961fb430adb9fb2b06662", "filename": "gcc/m2/gm2-gcc/m2except.cc", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-gcc%2Fm2except.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-gcc%2Fm2except.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-gcc%2Fm2except.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -103,18 +103,19 @@ m2except_InitExceptions (location_t location)\n \n   m2decl_BuildStartFunctionDeclaration (FALSE);\n   fn_rethrow_tree = m2decl_BuildEndFunctionDeclaration (\n-      location, location, \"__cxa_rethrow\", void_type_node, TRUE, FALSE, TRUE);\n+     location, location, \"__cxa_rethrow\", void_type_node, TRUE, FALSE,\n+     TRUE, FALSE);\n   TREE_NOTHROW (fn_rethrow_tree) = 0;\n \n   m2decl_BuildStartFunctionDeclaration (FALSE);\n   m2decl_BuildParameterDeclaration (location, NULL, ptr_type_node, FALSE);\n   fn_begin_catch_tree = m2decl_BuildEndFunctionDeclaration (\n       location, location, \"__cxa_begin_catch\", ptr_type_node, TRUE, FALSE,\n-      TRUE);\n+      TRUE, FALSE);\n   m2decl_BuildStartFunctionDeclaration (FALSE);\n   fn_end_catch_tree = m2decl_BuildEndFunctionDeclaration (\n       location, location, \"__cxa_end_catch\", void_type_node, TRUE, FALSE,\n-      TRUE);\n+      TRUE, FALSE);\n   /* This can throw if the destructor for the exception throws.  */\n   TREE_NOTHROW (fn_end_catch_tree) = 0;\n \n@@ -130,26 +131,28 @@ m2except_InitExceptions (location_t location)\n   m2decl_BuildParameterDeclaration (location, NULL, ptr_type_node, FALSE);\n   m2decl_BuildParameterDeclaration (location, NULL, ptr_type_node, FALSE);\n   fn_throw_tree = m2decl_BuildEndFunctionDeclaration (\n-      location, location, \"__cxa_throw\", void_type_node, TRUE, FALSE, TRUE);\n+      location, location, \"__cxa_throw\", void_type_node, TRUE, FALSE, TRUE,\n+      FALSE);\n \n   /* Declare void __cxa_rethrow (void).  */\n   m2decl_BuildStartFunctionDeclaration (FALSE);\n   fn_rethrow_tree = m2decl_BuildEndFunctionDeclaration (\n-      location, location, \"__cxa_rethrow\", void_type_node, TRUE, FALSE, TRUE);\n+     location, location, \"__cxa_rethrow\", void_type_node, TRUE, FALSE, TRUE,\n+     FALSE);\n \n   /* Declare void *__cxa_allocate_exception (size_t).  */\n   m2decl_BuildStartFunctionDeclaration (FALSE);\n   m2decl_BuildParameterDeclaration (location, NULL, size_type_node, FALSE);\n   fn_allocate_exception_tree = m2decl_BuildEndFunctionDeclaration (\n       location, location, \"__cxa_allocate_exception\", ptr_type_node, TRUE,\n-      FALSE, TRUE);\n+      FALSE, TRUE, FALSE);\n \n   /* Declare void *__cxa_free_exception (void *).  */\n   m2decl_BuildStartFunctionDeclaration (FALSE);\n   m2decl_BuildParameterDeclaration (location, NULL, ptr_type_node, FALSE);\n   fn_free_exception_tree = m2decl_BuildEndFunctionDeclaration (\n       location, location, \"__cxa_free_exception\", ptr_type_node, TRUE, FALSE,\n-      TRUE);\n+      TRUE, FALSE);\n \n   /* Define integer type exception type which will match C++ int type\n      in the C++ runtime library.  */"}, {"sha": "92b4fd5b64c14b10735aee566305a1982b488142", "filename": "gcc/m2/gm2-gcc/m2options.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-gcc%2Fm2options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-gcc%2Fm2options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-gcc%2Fm2options.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -38,7 +38,6 @@ along with GNU Modula-2; see the file COPYING3.  If not see\n \n #include \"input.h\"\n \n-EXTERN void M2Options_SetMakeIncludePath (const char *arg);\n EXTERN void M2Options_SetSearchPath (const char *arg);\n EXTERN void M2Options_setdefextension (const char *arg);\n EXTERN void M2Options_setmodextension (const char *arg);\n@@ -62,6 +61,8 @@ EXTERN int M2Options_GetWholeValueCheck (void);\n \n EXTERN void M2Options_Setc (int value);\n EXTERN int M2Options_Getc (void);\n+EXTERN void M2Options_SetPPOnly (int value);\n+EXTERN int M2Options_GetPPOnly (void);\n \n EXTERN void M2Options_SetUselist (int value, const char *filename);\n EXTERN void M2Options_SetAutoInit (int value);\n@@ -113,6 +114,7 @@ EXTERN void M2Options_SetStrictTypeChecking (int value);\n EXTERN void M2Options_SetWall (int value);\n EXTERN void M2Options_SetSaveTemps (int value);\n EXTERN void M2Options_SetSaveTempsDir (const char *arg);\n+EXTERN void M2Options_SetDumpDir (const char *arg);\n EXTERN int M2Options_GetSaveTemps (void);\n EXTERN void M2Options_SetScaffoldStatic (int value);\n EXTERN void M2Options_SetScaffoldDynamic (int value);\n@@ -122,6 +124,14 @@ EXTERN void M2Options_SetGenModuleList (int value, const char *filename);\n EXTERN void M2Options_SetShared (int value);\n EXTERN void M2Options_SetB (const char *arg);\n EXTERN char *M2Options_GetB (void);\n+EXTERN void M2Options_SetMD (const char *arg);\n+EXTERN char *M2Options_GetMD (void);\n+EXTERN void M2Options_SetMMD (const char *arg);\n+EXTERN char *M2Options_GetMMD (void);\n+EXTERN void M2Options_SetMQ (const char *arg);\n+EXTERN char *M2Options_GetMQ (void);\n+EXTERN void M2Options_SetObj (const char *arg);\n+EXTERN char *M2Options_GetObj (void);\n \n #undef EXTERN\n #endif /* m2options_h.  */"}, {"sha": "c3307db23beb285c2c54cccc09511616740d1661", "filename": "gcc/m2/gm2-gcc/m2statement.cc", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-gcc%2Fm2statement.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-gcc%2Fm2statement.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-gcc%2Fm2statement.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -84,23 +84,6 @@ m2statement_BuildStartFunctionCode (location_t location, tree fndecl,\n   DECL_DECLARED_INLINE_P (fndecl) = 0; /* isinline;  */\n }\n \n-static void\n-gm2_gimplify_function_node (tree fndecl)\n-{\n-  /* Convert all nested functions to GIMPLE now.  We do things in this\n-     order so that items like VLA sizes are expanded properly in the\n-     context of the correct function.  */\n-  struct cgraph_node *cgn;\n-\n-  dump_function (TDI_original, fndecl);\n-  gimplify_function_tree (fndecl);\n-\n-  cgn = cgraph_node::get_create (fndecl);\n-  for (cgn = first_nested_function (cgn);\n-       cgn != NULL; cgn = next_nested_function (cgn))\n-    gm2_gimplify_function_node (cgn->decl);\n-}\n-\n /* BuildEndFunctionCode - generates the function epilogue.  */\n \n void"}, {"sha": "634fad8df7c9b278b4f6c90b25f7c0cb01eb189d", "filename": "gcc/m2/gm2-gcc/m2type.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-gcc%2Fm2type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-gcc%2Fm2type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-gcc%2Fm2type.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -36,6 +36,7 @@ along with GNU Modula-2; see the file COPYING3.  If not see\n #include \"m2tree.h\"\n #include \"m2treelib.h\"\n #include \"m2type.h\"\n+#include \"m2options.h\"\n \n #undef USE_BOOLEAN\n static int broken_set_debugging_info = TRUE;\n@@ -1782,6 +1783,9 @@ m2type_InitBaseTypes (location_t location)\n \n   m2_packed_boolean_type_node = build_nonstandard_integer_type (1, TRUE);\n \n+  if (M2Options_GetPPOnly ())\n+    return;\n+\n   m2builtins_init (location);\n   m2except_InitExceptions (location);\n   m2expr_init (location);"}, {"sha": "999c57c1cfa0d4fc40fff0447c795b2aa5d63ec1", "filename": "gcc/m2/gm2-lang.cc", "status": "modified", "additions": 298, "deletions": 51, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-lang.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -20,6 +20,7 @@ along with GNU Modula-2; see the file COPYING.  If not, write to the\n Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n 02110-1301, USA.  */\n \n+#define INCLUDE_VECTOR\n #include \"gm2-gcc/gcc-consolidation.h\"\n \n #include \"langhooks-def.h\" /* FIXME: for lhd_set_decl_assembler_name.  */\n@@ -45,6 +46,18 @@ static void write_globals (void);\n \n static int insideCppArgs = FALSE;\n \n+/* We default to pim in the absence of fiso.  */\n+static bool iso = false;\n+\n+/* The language include paths are based on the libraries in use.  */\n+static bool allow_libraries = true;\n+static const char *flibs = nullptr;\n+static const char *iprefix = nullptr;\n+static const char *imultilib = nullptr;\n+static std::vector<const char*>Ipaths;\n+static std::vector<const char*>isystem;\n+static std::vector<const char*>iquote;\n+\n #define EXPR_STMT_EXPR(NODE) TREE_OPERAND (EXPR_STMT_CHECK (NODE), 0)\n \n /* start of new stuff.  */\n@@ -94,6 +107,8 @@ struct GTY (()) language_function\n \n /* Language hooks.  */\n \n+static void gm2_langhook_parse_file (void);\n+\n bool\n gm2_langhook_init (void)\n {\n@@ -107,6 +122,13 @@ gm2_langhook_init (void)\n \n   /* GNU Modula-2 uses exceptions.  */\n   using_eh_for_cleanups ();\n+\n+  if (M2Options_GetPPOnly ())\n+    {\n+      /* preprocess the file here.  */\n+      gm2_langhook_parse_file ();\n+      return false; /* Finish now, no further compilation.  */\n+    }\n   return true;\n }\n \n@@ -142,27 +164,150 @@ gm2_langhook_init_options_struct (struct gcc_options *opts)\n \n static vec<bool> filename_cpp;\n \n+/* Build the C preprocessor command line here, since we need to include\n+   options that are not passed to the handle_option function.  */\n+\n void\n gm2_langhook_init_options (unsigned int decoded_options_count,\n                            struct cl_decoded_option *decoded_options)\n {\n   unsigned int i;\n   bool in_cpp_args = false;\n+  bool building_cpp_command = false;\n \n   for (i = 1; i < decoded_options_count; i++)\n     {\n-      switch (decoded_options[i].opt_index)\n-        {\n-        case OPT_fcpp_begin:\n-          in_cpp_args = true;\n-          break;\n-        case OPT_fcpp_end:\n-          in_cpp_args = false;\n-          break;\n-        case OPT_SPECIAL_input_file:\n-        case OPT_SPECIAL_program_name:\n-          filename_cpp.safe_push (in_cpp_args);\n-        }\n+      enum opt_code code = (enum opt_code)decoded_options[i].opt_index;\n+      const struct cl_option *option = &cl_options[code];\n+      const char *opt = (const char *)option->opt_text;\n+      const char *arg = decoded_options[i].arg;\n+      HOST_WIDE_INT value = decoded_options[i].value;\n+      switch (code)\n+\t{\n+\tcase OPT_fcpp:\n+\t  gcc_checking_assert (building_cpp_command);\n+\t  break;\n+\tcase OPT_fcpp_begin:\n+\t  in_cpp_args = true;\n+\t  building_cpp_command = true;\n+\t  break;\n+\tcase OPT_fcpp_end:\n+\t  in_cpp_args = false;\n+\t  break;\n+\tcase OPT_SPECIAL_input_file:\n+\t  filename_cpp.safe_push (in_cpp_args);\n+\t  break;\n+\n+\t/* C and driver opts that are not passed to the preprocessor for\n+\t   modula-2, but that we use internally for building preprocesor\n+\t   command lines.  */\n+\tcase OPT_B:\n+\t  M2Options_SetB (arg);\n+\t  break;\n+\tcase OPT_c:\n+\t  M2Options_Setc (value);\n+\t  break;\n+\tcase OPT_dumpdir:\n+\t  if (building_cpp_command)\n+\t    M2Options_SetDumpDir (arg);\n+\t  break;\n+\tcase OPT_save_temps:\n+\t  if (building_cpp_command)\n+\t    M2Options_SetSaveTemps (value);\n+\t  break;\n+\tcase OPT_save_temps_:\n+\t  if (building_cpp_command)\n+\t    /* Also sets SaveTemps. */\n+\t    M2Options_SetSaveTempsDir (arg);\n+\t  break;\n+\n+\tcase OPT_E:\n+\t  if (!in_cpp_args)\n+\t    {\n+\t      M2Options_SetPPOnly (value);\n+\t      building_cpp_command = true;\n+\t    }\n+\t  M2Options_CppArg (opt, arg, (option->flags & CL_JOINED)\n+\t\t\t      && !(option->flags & CL_SEPARATE));\n+\t  break;\n+\tcase OPT_M:\n+\tcase OPT_MM:\n+\t  gcc_checking_assert (building_cpp_command);\n+\t  M2Options_SetPPOnly (value);\n+\t  /* This is a preprocessor command.  */\n+\t  M2Options_CppArg (opt, arg, (option->flags & CL_JOINED)\n+\t\t\t      && !(option->flags & CL_SEPARATE));\n+\t  break;\n+\n+\t/* We can only use MQ when the command line is either PP-only, or\n+\t   when there is a MD/MMD on it.  */\n+\tcase OPT_MQ:\n+\t  M2Options_SetMQ (arg);\n+\t  break;\n+\n+\tcase OPT_o:\n+\t  M2Options_SetObj (arg);\n+\t  break;\n+\n+\t/* C and driver options that we ignore for the preprocessor lines.  */\n+\tcase OPT_fpch_deps:\n+\tcase OPT_fpch_preprocess:\n+\t  break;\n+\n+\tcase OPT_fplugin_:\n+\t  /* FIXME: We might need to handle this specially, since the modula-2\n+\t     plugin is not usable here, but others might be.\n+\t     For now skip all plugins to avoid fails with the m2 one.  */\n+\t  break;\n+\n+\t/* Preprocessor arguments with a following filename, we add these\n+\t   back to the main file preprocess line, but not to dependents\n+\t   TODO Handle MF.  */\n+\tcase OPT_MD:\n+\t  M2Options_SetMD (arg);\n+\t  break;\n+\tcase OPT_MMD:\n+\t  M2Options_SetMMD (arg);\n+\t  break;\n+\n+\t/* Modula 2 claimed options we pass to the preprocessor.  */\n+\tcase OPT_ansi:\n+\tcase OPT_traditional_cpp:\n+\t  if (building_cpp_command)\n+\t    M2Options_CppArg (opt, arg, (option->flags & CL_JOINED)\n+\t\t\t      && !(option->flags & CL_SEPARATE));\n+\t  break;\n+\n+\t/* Options we act on and also pass to the preprocessor.  */\n+\tcase OPT_O:\n+\t  M2Options_SetOptimizing (value);\n+\t  if (building_cpp_command)\n+\t    M2Options_CppArg (opt, arg, (option->flags & CL_JOINED)\n+\t\t\t      && !(option->flags & CL_SEPARATE));\n+\t  break;\n+\tcase OPT_quiet:\n+\t  M2Options_SetQuiet (value);\n+\t  if (building_cpp_command)\n+\t    M2Options_CppArg (opt, arg, (option->flags & CL_JOINED)\n+\t\t\t      && !(option->flags & CL_SEPARATE));\n+\t  break;\n+\tcase OPT_v:\n+\t  M2Options_SetVerbose (value);\n+\t  /* FALLTHROUGH */\n+\tdefault:\n+\t  /* We handled input files above.  */\n+\t  if (code >= N_OPTS)\n+\t    break;\n+\t  /* Do not pass Modula-2 args to the preprocessor, any that we care\n+\t     about here should already have been handled above.  */\n+\t  if (option->flags & CL_ModulaX2)\n+\t    break;\n+\t  /* Otherwise, add this to the CPP command line.  */\n+\t  if (building_cpp_command)\n+\t    M2Options_CppArg (opt, arg, (option->flags & CL_JOINED)\n+\t\t\t      && !(option->flags & CL_SEPARATE));\n+\t  break;\n+\t}\n     }\n   filename_cpp.safe_push (false);\n }\n@@ -184,48 +329,43 @@ gm2_langhook_handle_option (\n {\n   enum opt_code code = (enum opt_code)scode;\n \n+  const struct cl_option *option = &cl_options[scode];\n+  const char *opt = (const char *)option->opt_text;\n   /* ignore file names.  */\n   if (code == N_OPTS)\n     return 1;\n \n   switch (code)\n     {\n-    case OPT_B:\n-      M2Options_SetB (arg);\n-      return 1;\n-    case OPT_c:\n-      M2Options_Setc (value);\n-      return 1;\n     case OPT_I:\n-      if (insideCppArgs)\n-        {\n-          const struct cl_option *option = &cl_options[scode];\n-          const char *opt = (const char *)option->opt_text;\n-          M2Options_CppArg (opt, arg, TRUE);\n-        }\n-      else\n-        M2Options_SetSearchPath (arg);\n+      Ipaths.push_back (arg);\n       return 1;\n     case OPT_fiso:\n       M2Options_SetISO (value);\n+      iso = value;\n       return 1;\n     case OPT_fpim:\n       M2Options_SetPIM (value);\n+      iso = value ? false : iso;\n       return 1;\n     case OPT_fpim2:\n       M2Options_SetPIM2 (value);\n+      iso = value ? false : iso;\n       return 1;\n     case OPT_fpim3:\n       M2Options_SetPIM3 (value);\n+      iso = value ? false : iso;\n       return 1;\n     case OPT_fpim4:\n       M2Options_SetPIM4 (value);\n+      iso = value ? false : iso;\n       return 1;\n     case OPT_fpositive_mod_floor_div:\n       M2Options_SetPositiveModFloor (value);\n       return 1;\n     case OPT_flibs_:\n-      /* handled in the gm2 driver.  */\n+      allow_libraries = value;\n+      flibs = arg;\n       return 1;\n     case OPT_fgen_module_list_:\n       M2Options_SetGenModuleList (value, arg);\n@@ -338,6 +478,9 @@ gm2_langhook_handle_option (\n     case OPT_fcpp:\n       M2Options_SetCpp (value);\n       return 1;\n+    case OPT_fpreprocessed:\n+      /* Provided for compatibility; ignore for now.  */\n+      return 1;\n     case OPT_fcpp_begin:\n       insideCppArgs = TRUE;\n       return 1;\n@@ -374,12 +517,27 @@ gm2_langhook_handle_option (\n     case OPT_fm2_g:\n       M2Options_SetM2g (value);\n       return 1;\n-    case OPT_O:\n-      M2Options_SetOptimizing (value);\n+      break;\n+    case OPT_iprefix:\n+      iprefix = arg;\n       return 1;\n-    case OPT_quiet:\n-      M2Options_SetQuiet (value);\n+      break;\n+    case OPT_imultilib:\n+      imultilib = arg;\n       return 1;\n+      break;\n+    case OPT_isystem:\n+      isystem.push_back (arg);\n+      return 1;\n+      break;\n+    case OPT_iquote:\n+      iquote.push_back (arg);\n+      return 1;\n+      break;\n+    case OPT_isysroot:\n+      /* Otherwise, ignored, at least for now. */\n+      return 1;\n+      break;\n     case OPT_fm2_whole_program:\n       M2Options_SetWholeProgram (value);\n       return 1;\n@@ -401,29 +559,82 @@ gm2_langhook_handle_option (\n         }\n       else\n         return 0;\n-    case OPT_save_temps:\n-      M2Options_SetSaveTemps (value);\n-      return 1;\n-    case OPT_save_temps_:\n-      M2Options_SetSaveTempsDir (arg);\n-      return 1;\n-    case OPT_v:\n-      M2Options_SetVerbose (value);\n-      return 1;\n     default:\n       if (insideCppArgs)\n-        {\n-          const struct cl_option *option = &cl_options[scode];\n-          const char *opt = (const char *)option->opt_text;\n-\n-          M2Options_CppArg (opt, arg, TRUE);\n-          return 1;\n-        }\n-      return 0;\n+\t/* Handled in gm2_langhook_init_options ().  */\n+\treturn 1;\n+      else if (option->flags & CL_DRIVER)\n+\t/* Driver options (unless specifically claimed above) should be handled\n+\t   in gm2_langhook_init_options ().  */\n+\treturn 1;\n+      else if (option->flags & CL_C)\n+\t/* C options (unless specifically claimed above) should be handled\n+\t   in gm2_langhook_init_options ().  */\n+\treturn 1;\n+      break;\n     }\n   return 0;\n }\n \n+/* This prefixes LIBNAME with the current compiler prefix (if it has been\n+   relocated) or the LIBSUBDIR, if not.  */\n+static void\n+add_one_import_path (const char *libname)\n+{\n+  const char *libpath = iprefix ? iprefix : LIBSUBDIR;\n+  const char dir_sep[] = {DIR_SEPARATOR, (char)0};\n+  size_t dir_sep_size = strlen (dir_sep);\n+  unsigned int mlib_len = 0;\n+\n+  if (imultilib)\n+    {\n+      mlib_len = strlen (imultilib);\n+      mlib_len += strlen (dir_sep);\n+    }\n+\n+  char *lib = (char *)alloca (strlen (libpath) + dir_sep_size\n+\t\t\t      + strlen (\"m2\") + dir_sep_size\n+\t\t\t      + strlen (libname) + 1\n+\t\t\t      + mlib_len + 1);\n+  strcpy (lib, libpath);\n+  /* iprefix has a trailing dir separator, LIBSUBDIR does not.  */\n+  if (!iprefix)\n+    strcat (lib, dir_sep);\n+\n+  if (imultilib)\n+    {\n+      strcat (lib, imultilib);\n+      strcat (lib, dir_sep);\n+    }\n+  strcat (lib, \"m2\");\n+  strcat (lib, dir_sep);\n+  strcat (lib, libname);\n+  M2Options_SetSearchPath (lib);\n+}\n+\n+/* For each comma-separated standard library name in LIBLIST, add the\n+   corresponding include path.  */\n+static void\n+add_m2_import_paths (const char *liblist)\n+{\n+  while (*liblist != 0 && *liblist != '-')\n+    {\n+      const char *comma = strstr (liblist, \",\");\n+      size_t len;\n+      if (comma)\n+\tlen = comma - liblist;\n+      else\n+\tlen = strlen (liblist);\n+      char *libname = (char *) alloca (len+1);\n+      strncpy (libname, liblist, len);\n+      libname[len] = 0;\n+      add_one_import_path (libname);\n+      liblist += len;\n+      if (*liblist == ',')\n+\tliblist++;\n+    }\n+}\n+\n /* Run after parsing options.  */\n \n static bool\n@@ -435,8 +646,43 @@ gm2_langhook_post_options (const char **pfilename)\n   M2Options_FinaliseOptions ();\n   main_input_filename = filename;\n \n-  /* Returning false means that the backend should be used.  */\n-  return false;\n+  /* Add the include paths as per the libraries specified.\n+     NOTE: This assumes that the driver has validated the input and makes\n+     no attempt to be defensive of nonsense input in flibs=.  */\n+  if (allow_libraries)\n+    {\n+      if (!flibs)\n+\t{\n+\t  if (iso)\n+\t    flibs = \"m2iso,m2cor,m2pim,m2log\";\n+\t  else\n+\t    flibs = \"m2pim,m2iso,m2cor,m2log\";\n+\t}\n+    }\n+\n+  /* Add search paths.\n+     We are not handling all of the cases yet (e.g idirafter).\n+     This (barring the missing cases) is intended to follow the directory\n+     search rules used for c-family.  It would be less confusing if the\n+     presence of absence of these search paths was not dependent on the\n+     flibs= option. */\n+\n+  for (auto *s : iquote)\n+    M2Options_SetSearchPath (s);\n+  iquote.clear();\n+  for (auto *s : Ipaths)\n+    M2Options_SetSearchPath (s);\n+  Ipaths.clear();\n+  for (auto *s : isystem)\n+    M2Options_SetSearchPath (s);\n+  isystem.clear();\n+  /* FIXME: this is not a good way to suppress the addition of the import\n+     paths.  */\n+  if (allow_libraries)\n+    add_m2_import_paths (flibs);\n+\n+ /* Returning false means that the backend should be used.  */\n+  return M2Options_GetPPOnly ();\n }\n \n /* Call the compiler for every source filename on the command line.  */\n@@ -459,7 +705,8 @@ static void\n gm2_langhook_parse_file (void)\n {\n   gm2_parse_input_files (in_fnames, num_in_fnames);\n-  write_globals ();\n+  if (!M2Options_GetPPOnly ())\n+    write_globals ();\n }\n \n static tree"}, {"sha": "6958fd416675553a858bab5905e8f519cf39be98", "filename": "gcc/m2/gm2-libs-iso/M2RTS.def", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-iso%2FM2RTS.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-iso%2FM2RTS.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-iso%2FM2RTS.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -111,13 +111,24 @@ PROCEDURE HALT ([exitcode: INTEGER = -1]) ;\n \n (*\n    Halt - provides a more user friendly version of HALT, which takes\n-          four parameters to aid debugging.\n+           four parameters to aid debugging.  It writes an error message\n+           to stderr and calls exit (1).\n *)\n \n-PROCEDURE Halt (file: ARRAY OF CHAR; line: CARDINAL;\n+PROCEDURE Halt (filename: ARRAY OF CHAR; line: CARDINAL;\n                 function: ARRAY OF CHAR; description: ARRAY OF CHAR) ;\n \n \n+(*\n+   HaltC - provides a more user friendly version of HALT, which takes\n+           four parameters to aid debugging.  It writes an error message\n+           to stderr and calls exit (1).\n+*)\n+\n+PROCEDURE HaltC (filename: ADDRESS; line: CARDINAL;\n+                 function, description: ADDRESS) ;\n+\n+\n (*\n    ExitOnHalt - if HALT is executed then call exit with the exit code, e.\n *)\n@@ -130,7 +141,7 @@ PROCEDURE ExitOnHalt (e: INTEGER) ;\n *)\n \n PROCEDURE ErrorMessage (message: ARRAY OF CHAR;\n-                        file: ARRAY OF CHAR;\n+                        filename: ARRAY OF CHAR;\n                         line: CARDINAL;\n                         function: ARRAY OF CHAR) ;\n "}, {"sha": "cbe70a958d17bef0856cd0e3b6277ee59740e788", "filename": "gcc/m2/gm2-libs-iso/M2RTS.mod", "status": "modified", "additions": 67, "deletions": 13, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-iso%2FM2RTS.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-iso%2FM2RTS.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-iso%2FM2RTS.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -27,7 +27,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n IMPLEMENTATION MODULE M2RTS ;\n \n \n-FROM libc IMPORT abort, exit, write, getenv, printf ;\n+FROM libc IMPORT abort, exit, write, getenv, printf, strlen ;\n (* FROM Builtins IMPORT strncmp, strcmp ;  not available during bootstrap.  *)\n FROM NumberIO IMPORT CardToStr ;\n FROM StrLib IMPORT StrCopy, StrLen, StrEqual ;\n@@ -39,6 +39,9 @@ IMPORT RTExceptions ;\n IMPORT M2EXCEPTION ;\n IMPORT M2Dependent ;\n \n+CONST\n+   stderrFd = 2 ;\n+\n TYPE\n    PtrToChar = POINTER TO CHAR ;\n \n@@ -255,47 +258,98 @@ PROCEDURE ErrorString (a: ARRAY OF CHAR) ;\n VAR\n    n: INTEGER ;\n BEGIN\n-   n := write (2, ADR (a), StrLen (a))\n+   n := write (stderrFd, ADR (a), StrLen (a))\n END ErrorString ;\n \n \n+(*\n+   ErrorStringC - writes a string to stderr.\n+*)\n+\n+PROCEDURE ErrorStringC (str: ADDRESS) ;\n+VAR\n+   len: INTEGER ;\n+BEGIN\n+   len := write (stderrFd, str, strlen (str))\n+END ErrorStringC ;\n+\n+\n (*\n    ErrorMessage - emits an error message to stderr and then calls exit (1).\n *)\n \n PROCEDURE ErrorMessage (message: ARRAY OF CHAR;\n-                        file: ARRAY OF CHAR;\n+                        filename: ARRAY OF CHAR;\n                         line: CARDINAL;\n                         function: ARRAY OF CHAR) <* noreturn *> ;\n VAR\n-   LineNo: ARRAY [0..10] OF CHAR ;\n+   buffer: ARRAY [0..10] OF CHAR ;\n BEGIN\n-   ErrorString (file) ; ErrorString(':') ;\n-   CardToStr (line, 0, LineNo) ;\n-   ErrorString (LineNo) ; ErrorString(':') ;\n+   ErrorString (filename) ; ErrorString(':') ;\n+   CardToStr (line, 0, buffer) ;\n+   ErrorString (buffer) ; ErrorString(':') ;\n    IF NOT StrEqual (function, '')\n    THEN\n       ErrorString ('in ') ;\n       ErrorString (function) ;\n       ErrorString (' has caused ') ;\n    END ;\n    ErrorString (message) ;\n-   LineNo[0] := nl ; LineNo[1] := nul ;\n-   ErrorString (LineNo) ;\n+   buffer[0] := nl ; buffer[1] := nul ;\n+   ErrorString (buffer) ;\n    exit (1)\n END ErrorMessage ;\n \n \n+(*\n+   ErrorMessageC - emits an error message to stderr and then calls exit (1).\n+*)\n+\n+PROCEDURE ErrorMessageC (message, filename: ADDRESS;\n+                         line: CARDINAL;\n+                         function: ADDRESS) <* noreturn *> ;\n+VAR\n+   buffer: ARRAY [0..10] OF CHAR ;\n+BEGIN\n+   ErrorStringC (filename) ; ErrorString (':') ;\n+   CardToStr (line, 0, buffer) ;\n+   ErrorString (buffer) ; ErrorString(':') ;\n+   IF strlen (function) > 0\n+   THEN\n+      ErrorString ('in ') ;\n+      ErrorStringC (function) ;\n+      ErrorString (' has caused ') ;\n+   END ;\n+   ErrorStringC (message) ;\n+   buffer[0] := nl ; buffer[1] := nul ;\n+   ErrorString (buffer) ;\n+   exit (1)\n+END ErrorMessageC ;\n+\n+\n+(*\n+   HaltC - provides a more user friendly version of HALT, which takes\n+           four parameters to aid debugging.  It writes an error message\n+           to stderr and calls exit (1).\n+*)\n+\n+PROCEDURE HaltC (filename: ADDRESS; line: CARDINAL;\n+                 function, description: ADDRESS) ;\n+BEGIN\n+   ErrorMessageC (description, filename, line, function)\n+END HaltC ;\n+\n+\n (*\n    Halt - provides a more user friendly version of HALT, which takes\n-          four parameters to aid debugging.\n+          four parameters to aid debugging.  It writes an error message\n+          to stderr and calls exit (1).\n *)\n \n-PROCEDURE Halt (file: ARRAY OF CHAR; line: CARDINAL;\n+PROCEDURE Halt (filename: ARRAY OF CHAR; line: CARDINAL;\n                 function: ARRAY OF CHAR; description: ARRAY OF CHAR) ;\n BEGIN\n-   ErrorMessage (description, file, line, function) ;\n-   HALT\n+   ErrorMessage (description, filename, line, function)\n END Halt ;\n \n "}, {"sha": "44aa62ba48aee2e596ab1cfc334638040595537b", "filename": "gcc/m2/gm2-libs-iso/Preemptive.mod", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-iso%2FPreemptive.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-iso%2FPreemptive.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-iso%2FPreemptive.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -33,6 +33,9 @@ FROM libc IMPORT printf ;\n \n CONST\n    debugging = FALSE ;\n+   (* The space we request becomes part of a stack request, which generally\n+      has constraints on size and alignment.  *)\n+   extraWorkSpace = 10 * 1024 * 1024 ;\n \n (*\n    timer - the timer process which runs at maximum scheduling priority with\n@@ -107,7 +110,7 @@ BEGIN\n    IF NOT init\n    THEN\n       init := TRUE ;\n-      Create (timer, 10000000, MAX (Urgency), NIL, timerId) ;\n+      Create (timer, extraWorkSpace, MAX (Urgency), NIL, timerId) ;\n       Activate (timerId)\n    END\n END initPreemptive ;"}, {"sha": "5285a7deb10b0521888e977390463c11f6872090", "filename": "gcc/m2/gm2-libs-iso/RTco.def", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-iso%2FRTco.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-iso%2FRTco.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-iso%2FRTco.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -24,10 +24,12 @@ a copy of the GCC Runtime Library Exception along with this program;\n see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  *)\n \n-DEFINITION MODULE RTco ;\n+DEFINITION MODULE FOR \"C\" RTco ;\n \n FROM SYSTEM IMPORT ADDRESS ;\n \n+IMPORT RTentity ;  (* Imported so the initialization call graph\n+                      understands that RTco.cc depends upon RTentity.  *)\n \n (* init initializes the module and allows the application to lazily invoke threads.  *)\n "}, {"sha": "bb928112704254495a0f27444b9d3fc9d237f29e", "filename": "gcc/m2/gm2-libs-log/BitBlockOps.def", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FBitBlockOps.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FBitBlockOps.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FBitBlockOps.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/BitBlockOps.def"}, {"sha": "863680f309adaf7de0319885d2669b02c3bec0a6", "filename": "gcc/m2/gm2-libs-log/BitBlockOps.mod", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FBitBlockOps.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FBitBlockOps.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FBitBlockOps.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/BitBlockOps.mod"}, {"sha": "e6344c283230d94d809735c7f7676df5f9f8e561", "filename": "gcc/m2/gm2-libs-log/BitByteOps.def", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FBitByteOps.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FBitByteOps.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FBitByteOps.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/BitByteOps.def"}, {"sha": "318a2e3b53d3d082ffe3df250c02dde6a668f674", "filename": "gcc/m2/gm2-libs-log/BitByteOps.mod", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FBitByteOps.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FBitByteOps.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FBitByteOps.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/BitByteOps.mod"}, {"sha": "899bb0a9b9f02a5d1a15b6ac7c57c9705d7ade5c", "filename": "gcc/m2/gm2-libs-log/BitWordOps.def", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FBitWordOps.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FBitWordOps.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FBitWordOps.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/BitWordOps.def"}, {"sha": "9dd94e75ea833fb3d268adf6560a39ab2fe15925", "filename": "gcc/m2/gm2-libs-log/BitWordOps.mod", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FBitWordOps.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FBitWordOps.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FBitWordOps.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/BitWordOps.mod"}, {"sha": "8cd1ebdecff19ad1763da20de2f7a7e63c396a29", "filename": "gcc/m2/gm2-libs-log/BlockOps.def", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FBlockOps.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FBlockOps.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FBlockOps.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/BlockOps.def"}, {"sha": "eab69384b53319c7e421af04f532ad4f9a27e49b", "filename": "gcc/m2/gm2-libs-log/BlockOps.mod", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FBlockOps.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FBlockOps.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FBlockOps.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/BlockOps.mod"}, {"sha": "ecb33b047ac0fa786e9b9ab552fe01a4a49d4fa9", "filename": "gcc/m2/gm2-libs-log/Break.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FBreak.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FBreak.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FBreak.c?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/Break.c"}, {"sha": "271384c61423f2fb232f7eb31622c654b7046b1c", "filename": "gcc/m2/gm2-libs-log/Break.def", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FBreak.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FBreak.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FBreak.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/Break.def"}, {"sha": "d6b4eece31b5177b17c8e66f77b446326cee9f59", "filename": "gcc/m2/gm2-libs-log/CardinalIO.def", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FCardinalIO.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FCardinalIO.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FCardinalIO.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/CardinalIO.def"}, {"sha": "5f7e75023f6d6baf4aa8e916cc193e9dfd619f51", "filename": "gcc/m2/gm2-libs-log/CardinalIO.mod", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FCardinalIO.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FCardinalIO.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FCardinalIO.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/CardinalIO.mod"}, {"sha": "d178e0518a6dc555422fab53b94c7ed706afbb6d", "filename": "gcc/m2/gm2-libs-log/Conversions.def", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FConversions.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FConversions.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FConversions.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/Conversions.def"}, {"sha": "1c8b8933f0e4d0f44ff4e45e4702251cbd60a750", "filename": "gcc/m2/gm2-libs-log/Conversions.mod", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FConversions.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FConversions.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FConversions.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/Conversions.mod"}, {"sha": "9a3adf6a5dcdfc0bade366fc92e6aff8e5f5bddf", "filename": "gcc/m2/gm2-libs-log/DebugPMD.def", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FDebugPMD.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FDebugPMD.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FDebugPMD.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/DebugPMD.def"}, {"sha": "12a86ca0804824fceac7754d59a586c2f6703616", "filename": "gcc/m2/gm2-libs-log/DebugPMD.mod", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FDebugPMD.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FDebugPMD.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FDebugPMD.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/DebugPMD.mod"}, {"sha": "9a00b71b8314dce4ba6900201828e3052ef07f9e", "filename": "gcc/m2/gm2-libs-log/DebugTrace.def", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FDebugTrace.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FDebugTrace.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FDebugTrace.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/DebugTrace.def"}, {"sha": "10cf797bc50afc273c84a3aa78aa9de5b55d4c28", "filename": "gcc/m2/gm2-libs-log/DebugTrace.mod", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FDebugTrace.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FDebugTrace.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FDebugTrace.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/DebugTrace.mod"}, {"sha": "ccb65e2ad7f166ef941514fef86bc6ee16176850", "filename": "gcc/m2/gm2-libs-log/Delay.def", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FDelay.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FDelay.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FDelay.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/Delay.def"}, {"sha": "e8e0ee13df91f15e4ce36a1cc00f5817ab8855ef", "filename": "gcc/m2/gm2-libs-log/Delay.mod", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FDelay.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FDelay.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FDelay.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/Delay.mod"}, {"sha": "7c55971373e89e72d96cfe724f7b5d650020444f", "filename": "gcc/m2/gm2-libs-log/Display.def", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FDisplay.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FDisplay.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FDisplay.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/Display.def"}, {"sha": "80066422a92a66aa652964241fc42ef7eb3035fe", "filename": "gcc/m2/gm2-libs-log/Display.mod", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FDisplay.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FDisplay.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FDisplay.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/Display.mod"}, {"sha": "8be1fc27b103685d6294cf57ffd538592a68410e", "filename": "gcc/m2/gm2-libs-log/ErrorCode.def", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FErrorCode.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FErrorCode.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FErrorCode.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/ErrorCode.def"}, {"sha": "37b7945cb187d2e1b7dcdc26eabe11b4cdbb3513", "filename": "gcc/m2/gm2-libs-log/ErrorCode.mod", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FErrorCode.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FErrorCode.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FErrorCode.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/ErrorCode.mod"}, {"sha": "784c6839d28c50e3ac09d4e27f221d4a54fa0dd2", "filename": "gcc/m2/gm2-libs-log/FileSystem.def", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FFileSystem.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FFileSystem.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FFileSystem.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/FileSystem.def"}, {"sha": "9f08819d58666fa03e7e99db9c37121a2bad1603", "filename": "gcc/m2/gm2-libs-log/FileSystem.mod", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FFileSystem.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FFileSystem.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FFileSystem.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/FileSystem.mod"}, {"sha": "f49f8b80228f5205f5b4545059c1bf8d14138d32", "filename": "gcc/m2/gm2-libs-log/FloatingUtilities.def", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FFloatingUtilities.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FFloatingUtilities.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FFloatingUtilities.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/FloatingUtilities.def"}, {"sha": "61fc1b3341ebff49a1d962e309b3c68327655250", "filename": "gcc/m2/gm2-libs-log/FloatingUtilities.mod", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FFloatingUtilities.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FFloatingUtilities.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FFloatingUtilities.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/FloatingUtilities.mod"}, {"sha": "23584444fa7dfe84fa1c62c659fde650cbbd8a86", "filename": "gcc/m2/gm2-libs-log/InOut.def", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FInOut.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FInOut.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FInOut.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/InOut.def"}, {"sha": "517aca2c7b43c59c577224ad75d69c24602d0909", "filename": "gcc/m2/gm2-libs-log/InOut.mod", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FInOut.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FInOut.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FInOut.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/InOut.mod"}, {"sha": "e9ebf847ef53677c06a57478cb78bea36a6324b4", "filename": "gcc/m2/gm2-libs-log/Keyboard.def", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FKeyboard.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FKeyboard.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FKeyboard.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/Keyboard.def"}, {"sha": "7081c5ff5801dd7b1a74825cc9325b230e22347e", "filename": "gcc/m2/gm2-libs-log/Keyboard.mod", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FKeyboard.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FKeyboard.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FKeyboard.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/Keyboard.mod"}, {"sha": "ca37245275a8e38f5096f81ad2e60aa2c34f3f95", "filename": "gcc/m2/gm2-libs-log/LongIO.def", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FLongIO.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FLongIO.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FLongIO.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/LongIO.def"}, {"sha": "f9f598f0dddb723b29d86e33be4c6500accad254", "filename": "gcc/m2/gm2-libs-log/LongIO.mod", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FLongIO.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FLongIO.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FLongIO.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/LongIO.mod"}, {"sha": "4bd069732c366f8428a708a08f45a99e00b61bd8", "filename": "gcc/m2/gm2-libs-log/NumberConversion.def", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FNumberConversion.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FNumberConversion.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FNumberConversion.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/NumberConversion.def"}, {"sha": "634e543aef95c1a72db7ec404cedb5d9e6c8b2de", "filename": "gcc/m2/gm2-libs-log/NumberConversion.mod", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FNumberConversion.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FNumberConversion.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FNumberConversion.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/NumberConversion.mod"}, {"sha": "4ea3c11f281b555cc6c99052513ade8a9e94399d", "filename": "gcc/m2/gm2-libs-log/README.texi", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FREADME.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FREADME.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FREADME.texi?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/README.texi"}, {"sha": "bc7fa4b142eb7593fb09904414b1e3507baabf1c", "filename": "gcc/m2/gm2-libs-log/Random.def", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FRandom.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FRandom.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FRandom.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/Random.def"}, {"sha": "e50dfbfc975e1479f575050385eeda02151ab1fc", "filename": "gcc/m2/gm2-libs-log/Random.mod", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FRandom.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FRandom.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FRandom.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/Random.mod"}, {"sha": "033cd3a4584541ad302ee7abfc03b0abdb9c3330", "filename": "gcc/m2/gm2-libs-log/RealConversions.def", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FRealConversions.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FRealConversions.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FRealConversions.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/RealConversions.def"}, {"sha": "189096ae96babc005c78dd9f6bba74e05a5a7300", "filename": "gcc/m2/gm2-libs-log/RealConversions.mod", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FRealConversions.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FRealConversions.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FRealConversions.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/RealConversions.mod"}, {"sha": "2c6a04bb2c6cdc1d1004d8752da8afcbc13311b1", "filename": "gcc/m2/gm2-libs-log/RealInOut.def", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FRealInOut.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FRealInOut.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FRealInOut.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/RealInOut.def"}, {"sha": "855ab9bb6b9191fce4f01a3f2cad1d2deb438ee4", "filename": "gcc/m2/gm2-libs-log/RealInOut.mod", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FRealInOut.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FRealInOut.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FRealInOut.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/RealInOut.mod"}, {"sha": "5f3f42c3dfabadf5bfebd2caf6b24b7bcb7803e1", "filename": "gcc/m2/gm2-libs-log/Strings.def", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FStrings.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FStrings.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FStrings.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/Strings.def"}, {"sha": "99dc6c1193dee50d79c6ddc98a1fc2f7997b4640", "filename": "gcc/m2/gm2-libs-log/Strings.mod", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FStrings.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FStrings.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FStrings.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/Strings.mod"}, {"sha": "8adc5d06b9b828cfa38eaf0ba6d1ac55996b7201", "filename": "gcc/m2/gm2-libs-log/Termbase.def", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FTermbase.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FTermbase.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FTermbase.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/Termbase.def"}, {"sha": "0b47826321b4e7e8d7e2305dea9c4e1e74da651d", "filename": "gcc/m2/gm2-libs-log/Termbase.mod", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FTermbase.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FTermbase.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FTermbase.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/Termbase.mod"}, {"sha": "a97e9fb9ca765a6e498d346bd63f87991cb9c547", "filename": "gcc/m2/gm2-libs-log/Terminal.def", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FTerminal.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FTerminal.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FTerminal.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/Terminal.def"}, {"sha": "cff1b5c1d7ab900fd4778b071307a3190c7e0cd7", "filename": "gcc/m2/gm2-libs-log/Terminal.mod", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FTerminal.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FTerminal.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FTerminal.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/Terminal.mod"}, {"sha": "d3f3e7d4e6259598e4296cdfc5cf82692c285e6f", "filename": "gcc/m2/gm2-libs-log/TimeDate.def", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FTimeDate.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FTimeDate.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FTimeDate.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/TimeDate.def"}, {"sha": "74644e8a19b530e598fa590f0065134a6d6029a1", "filename": "gcc/m2/gm2-libs-log/TimeDate.mod", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FTimeDate.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs-log%2FTimeDate.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs-log%2FTimeDate.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "previous_filename": "gcc/m2/gm2-libs-pim/TimeDate.mod"}, {"sha": "fa14f8cedfbe2b405c3098656c3ee221289d03de", "filename": "gcc/m2/gm2-libs/Args.mod", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs%2FArgs.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs%2FArgs.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs%2FArgs.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -62,7 +62,7 @@ BEGIN\n    IF i < GetArgC ()\n    THEN\n       Source := GetArgV () ;\n-      WHILE (Source^[i]^[j]#nul) AND (j<High) DO\n+      WHILE (j<High) AND (Source^[i]^[j]#nul) DO\n          a[j] := Source^[i]^[j] ;\n          INC(j)\n       END"}, {"sha": "a109e7a33c9f8afd47908c4a63c2be97c881ba45", "filename": "gcc/m2/gm2-libs/DynamicStrings.mod", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs%2FDynamicStrings.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs%2FDynamicStrings.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs%2FDynamicStrings.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1215,14 +1215,6 @@ BEGIN\n          i := 0 ;\n          Assert (a^.contents.len = b^.contents.len) ;\n          WHILE i<a^.contents.len DO\n-            IF a^.contents.buf[i] # a^.contents.buf[i]\n-            THEN\n-               HALT\n-            END ;\n-            IF b^.contents.buf[i] # b^.contents.buf[i]\n-            THEN\n-               HALT\n-            END ;\n             IF a^.contents.buf[i] # b^.contents.buf[i]\n             THEN\n                RETURN FALSE"}, {"sha": "f343ac3f185335955d3f6bac0c49446539aa1bfb", "filename": "gcc/m2/gm2-libs/M2Dependent.mod", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs%2FM2Dependent.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs%2FM2Dependent.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs%2FM2Dependent.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -203,7 +203,7 @@ BEGIN\n    i := 0 ;\n    high := HIGH (str) ;\n    WHILE i < high DO\n-      IF (str[i] = \"\\\") AND (i < high)\n+      IF (i < high) AND (str[i] = \"\\\")\n       THEN\n          IF str[i+1] = \"n\"\n          THEN"}, {"sha": "b551725126e005682c876237b96fb47936b2496e", "filename": "gcc/m2/gm2-libs/M2RTS.def", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs%2FM2RTS.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs%2FM2RTS.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs%2FM2RTS.def?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -120,12 +120,23 @@ PROCEDURE HALT ([exitcode: INTEGER = -1]) <* noreturn *> ;\n \n (*\n    Halt - provides a more user friendly version of HALT, which takes\n-          four parameters to aid debugging.\n+           four parameters to aid debugging.  It writes an error message\n+           to stderr and calls exit (1).\n *)\n \n-PROCEDURE Halt (file: ARRAY OF CHAR; line: CARDINAL;\n+PROCEDURE Halt (filename: ARRAY OF CHAR; line: CARDINAL;\n                 function: ARRAY OF CHAR; description: ARRAY OF CHAR)\n-\t\t<* noreturn *> ;\n+\t \t<* noreturn *> ;\n+\n+\n+(*\n+   HaltC - provides a more user friendly version of HALT, which takes\n+           four parameters to aid debugging.  It writes an error message\n+           to stderr and calls exit (1).\n+*)\n+\n+PROCEDURE HaltC (filename: ADDRESS; line: CARDINAL;\n+                 function, description: ADDRESS) ;\n \n \n (*\n@@ -140,7 +151,7 @@ PROCEDURE ExitOnHalt (e: INTEGER) ;\n *)\n \n PROCEDURE ErrorMessage (message: ARRAY OF CHAR;\n-                        file: ARRAY OF CHAR;\n+                        filename: ARRAY OF CHAR;\n                         line: CARDINAL;\n                         function: ARRAY OF CHAR) <* noreturn *> ;\n "}, {"sha": "4280fec7dc7912a6f8dad64df2e0895ad8572b01", "filename": "gcc/m2/gm2-libs/M2RTS.mod", "status": "modified", "additions": 67, "deletions": 13, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs%2FM2RTS.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs%2FM2RTS.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs%2FM2RTS.mod?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -27,7 +27,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n IMPLEMENTATION MODULE M2RTS ;\n \n \n-FROM libc IMPORT abort, exit, write, getenv, printf ;\n+FROM libc IMPORT abort, exit, write, getenv, printf, strlen ;\n (* FROM Builtins IMPORT strncmp, strcmp ;  not available during bootstrap.  *)\n FROM NumberIO IMPORT CardToStr ;\n FROM StrLib IMPORT StrCopy, StrLen, StrEqual ;\n@@ -39,6 +39,9 @@ IMPORT RTExceptions ;\n IMPORT M2EXCEPTION ;\n IMPORT M2Dependent ;\n \n+CONST\n+   stderrFd = 2 ;\n+\n TYPE\n    PtrToChar = POINTER TO CHAR ;\n \n@@ -254,47 +257,98 @@ PROCEDURE ErrorString (a: ARRAY OF CHAR) ;\n VAR\n    n: INTEGER ;\n BEGIN\n-   n := write (2, ADR (a), StrLen (a))\n+   n := write (stderrFd, ADR (a), StrLen (a))\n END ErrorString ;\n \n \n+(*\n+   ErrorStringC - writes a string to stderr.\n+*)\n+\n+PROCEDURE ErrorStringC (str: ADDRESS) ;\n+VAR\n+   len: INTEGER ;\n+BEGIN\n+   len := write (stderrFd, str, strlen (str))\n+END ErrorStringC ;\n+\n+\n (*\n    ErrorMessage - emits an error message to stderr and then calls exit (1).\n *)\n \n PROCEDURE ErrorMessage (message: ARRAY OF CHAR;\n-                        file: ARRAY OF CHAR;\n+                        filename: ARRAY OF CHAR;\n                         line: CARDINAL;\n                         function: ARRAY OF CHAR) <* noreturn *> ;\n VAR\n-   LineNo: ARRAY [0..10] OF CHAR ;\n+   buffer: ARRAY [0..10] OF CHAR ;\n BEGIN\n-   ErrorString (file) ; ErrorString(':') ;\n-   CardToStr (line, 0, LineNo) ;\n-   ErrorString (LineNo) ; ErrorString(':') ;\n+   ErrorString (filename) ; ErrorString(':') ;\n+   CardToStr (line, 0, buffer) ;\n+   ErrorString (buffer) ; ErrorString(':') ;\n    IF NOT StrEqual (function, '')\n    THEN\n       ErrorString ('in ') ;\n       ErrorString (function) ;\n       ErrorString (' has caused ') ;\n    END ;\n    ErrorString (message) ;\n-   LineNo[0] := nl ; LineNo[1] := nul ;\n-   ErrorString (LineNo) ;\n+   buffer[0] := nl ; buffer[1] := nul ;\n+   ErrorString (buffer) ;\n    exit (1)\n END ErrorMessage ;\n \n \n+(*\n+   ErrorMessageC - emits an error message to stderr and then calls exit (1).\n+*)\n+\n+PROCEDURE ErrorMessageC (message, filename: ADDRESS;\n+                         line: CARDINAL;\n+                         function: ADDRESS) <* noreturn *> ;\n+VAR\n+   buffer: ARRAY [0..10] OF CHAR ;\n+BEGIN\n+   ErrorStringC (filename) ; ErrorString (':') ;\n+   CardToStr (line, 0, buffer) ;\n+   ErrorString (buffer) ; ErrorString(':') ;\n+   IF strlen (function) > 0\n+   THEN\n+      ErrorString ('in ') ;\n+      ErrorStringC (function) ;\n+      ErrorString (' has caused ') ;\n+   END ;\n+   ErrorStringC (message) ;\n+   buffer[0] := nl ; buffer[1] := nul ;\n+   ErrorString (buffer) ;\n+   exit (1)\n+END ErrorMessageC ;\n+\n+\n+(*\n+   HaltC - provides a more user friendly version of HALT, which takes\n+           four parameters to aid debugging.  It writes an error message\n+           to stderr and calls exit (1).\n+*)\n+\n+PROCEDURE HaltC (filename: ADDRESS; line: CARDINAL;\n+                 function, description: ADDRESS) ;\n+BEGIN\n+   ErrorMessageC (description, filename, line, function)\n+END HaltC ;\n+\n+\n (*\n    Halt - provides a more user friendly version of HALT, which takes\n-          four parameters to aid debugging.\n+          four parameters to aid debugging.  It writes an error message\n+          to stderr and calls exit (1).\n *)\n \n-PROCEDURE Halt (file: ARRAY OF CHAR; line: CARDINAL;\n+PROCEDURE Halt (filename: ARRAY OF CHAR; line: CARDINAL;\n                 function: ARRAY OF CHAR; description: ARRAY OF CHAR) ;\n BEGIN\n-   ErrorMessage (description, file, line, function) ;\n-   HALT\n+   ErrorMessage (description, filename, line, function)\n END Halt ;\n \n "}, {"sha": "5d6d33d2b8403f501f2ce22b0fc96460922f9b1c", "filename": "gcc/m2/gm2-libs/config-host", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs%2Fconfig-host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2-libs%2Fconfig-host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2-libs%2Fconfig-host?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -5,7 +5,7 @@\n # Report bugs to <gm2@nongnu.org>.\n #\n #\n-# Copyright (C) 1992-2023 Free Software Foundation, Inc.\n+# Copyright (C) 1992-1996, 1998-2012 Free Software Foundation, Inc.\n #\n #\n # This configure script is free software; the Free Software Foundation\n@@ -1369,7 +1369,7 @@ if $ac_init_version; then\n ASCII.def configure 1.9.5\n generated by GNU Autoconf 2.69\n \n-Copyright (C) 2012-2023 Free Software Foundation, Inc.\n+Copyright (C) 2012 Free Software Foundation, Inc.\n This configure script is free software; the Free Software Foundation\n gives unlimited permission to copy, distribute and modify it.\n _ACEOF\n@@ -5298,7 +5298,7 @@ ASCII.def config.status 1.9.5\n configured by $0, generated by GNU Autoconf 2.69,\n   with options \\\\\"\\$ac_cs_config\\\\\"\n \n-Copyright (C) 2012-2023 Free Software Foundation, Inc.\n+Copyright (C) 2012 Free Software Foundation, Inc.\n This config.status script is free software; the Free Software Foundation\n gives unlimited permission to copy, distribute and modify it.\"\n "}, {"sha": "cb9f5054f44d59802cc9ac148ac9bbba8819178f", "filename": "gcc/m2/gm2config.aci.in", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2config.aci.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2config.aci.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2config.aci.in?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1,4 +1,4 @@\n-/* gm2config.h.in.  Generated from configure.ac by autoheader.  */\n+/* gm2config.aci.in.  Generated from configure.ac by autoheader.  */\n \n /* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.\n    */", "previous_filename": "gcc/m2/gm2config.h.in"}, {"sha": "bc93133243c427521fdeb6ad3fd2575c7af8e353", "filename": "gcc/m2/gm2spec.cc", "status": "modified", "additions": 120, "deletions": 251, "changes": 371, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2spec.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fgm2spec.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fgm2spec.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -103,6 +103,7 @@ enum stdcxxlib_kind\n };\n \n #define DEFAULT_DIALECT \"pim\"\n+\n #undef DEBUG_ARG\n \n typedef enum { iso, pim, min, logitech, pimcoroutine, maxlib } libs;\n@@ -132,14 +133,15 @@ static const char *add_include (const char *libpath, const char *library);\n \n static bool seen_scaffold_static = false;\n static bool seen_scaffold_dynamic = false;\n+static bool seen_scaffold_main = false;\n static bool scaffold_static = false;\n-static bool scaffold_dynamic = true;  // Default uses -fscaffold-dynamic.\n+static bool scaffold_dynamic = true; // Default uses -fscaffold-dynamic.\n+static bool scaffold_main = false;\n static bool seen_gen_module_list = false;\n static bool seen_uselist = false;\n static bool uselist = false;\n static bool gen_module_list = true;  // Default uses -fgen-module-list=-.\n static const char *gen_module_filename = \"-\";\n-static const char *multilib_dir = NULL;\n /* The original argument list and related info is copied here.  */\n static unsigned int gm2_xargc;\n static const struct cl_decoded_option *gm2_x_decoded_options;\n@@ -148,6 +150,8 @@ static void append_arg (const struct cl_decoded_option *);\n /* The new argument list will be built here.  */\n static unsigned int gm2_newargc;\n static struct cl_decoded_option *gm2_new_decoded_options;\n+static const char *full_libraries = NULL;\n+static const char *libraries = NULL;  /* Abbreviated libraries.  */\n \n \n /* Return whether strings S1 and S2 are both NULL or both the same\n@@ -227,50 +231,6 @@ append_option (size_t opt_index, const char *arg, int value)\n   append_arg (&decoded);\n }\n \n-/* build_archive_path returns a string containing the path to the\n-   archive defined by libpath and dialectLib.  */\n-\n-static const char *\n-build_archive_path (const char *libpath, const char *library)\n-{\n-  if (library != NULL)\n-    {\n-      const char *libdir = (const char *)library;\n-\n-      if (libdir != NULL)\n-        {\n-\t  int machine_length = 0;\n-          char dir_sep[2];\n-\n-          dir_sep[0] = DIR_SEPARATOR;\n-          dir_sep[1] = (char)0;\n-\n-\t  if (multilib_dir != NULL)\n-\t    {\n-\t      machine_length = strlen (multilib_dir);\n-\t      machine_length += strlen (dir_sep);\n-\t    }\n-\n-\t  int l = strlen (libpath) + 1 + strlen (\"m2\") + 1\n-\t    + strlen (libdir) + 1 + machine_length + 1;\n-          char *s = (char *)xmalloc (l);\n-\n-          strcpy (s, libpath);\n-          strcat (s, dir_sep);\n-\t  if (machine_length > 0)\n-\t    {\n-\t      strcat (s, multilib_dir);\n-\t      strcat (s, dir_sep);\n-\t    }\n-          strcat (s, \"m2\");\n-          strcat (s, dir_sep);\n-          strcat (s, libdir);\n-          return s;\n-        }\n-    }\n-  return NULL;\n-}\n-\n /* safe_strdup safely duplicates a string.  */\n \n static char *\n@@ -281,205 +241,65 @@ safe_strdup (const char *s)\n   return NULL;\n }\n \n-/* add_default_combination adds the correct link path and then the\n-   library name.  */\n-\n-static bool\n-add_default_combination (const char *libpath, const char *library)\n+static char *\n+concat_option (char *dest, const char *pre, const char *path, const char *post)\n {\n-  if (library != NULL)\n+  if (dest == NULL)\n+    {\n+      dest = (char *) xmalloc (strlen (pre) + strlen (path) + strlen (post) + 1);\n+      strcpy (dest, pre);\n+      strcat (dest, path);\n+      strcat (dest, post);\n+      return dest;\n+    }\n+  else\n     {\n-      append_option (OPT_L, build_archive_path (libpath, library), 1);\n-      append_option (OPT_l, safe_strdup (library), 1);\n-      return true;\n+      char *result = (char *) xmalloc (strlen (dest) + strlen (pre)\n+\t\t\t\t       + strlen (path) + strlen (post) + 1 + 1);\n+      strcpy (result, dest);\n+      strcat (result, \" \");\n+      strcat (result, pre);\n+      strcat (result, path);\n+      strcat (result, post);\n+      free (dest);\n+      return result;\n     }\n-  return false;\n }\n \n-/* add_default_archives adds the default archives to the end of the\n-   current command line.  */\n+/* add_default_libs adds the -l option which is derived from the\n+   libraries.  */\n \n static int\n-add_default_archives (const char *libpath, const char *libraries)\n+add_default_libs (const char *libraries)\n {\n   const char *l = libraries;\n   const char *e;\n   char *libname;\n   unsigned int libcount = 0;\n \n-  do\n+  while ((l != NULL) && (l[0] != (char)0))\n     {\n       e = index (l, ',');\n       if (e == NULL)\n         {\n           libname = xstrdup (l);\n           l = NULL;\n-\t  if (add_default_combination (libpath, libname))\n-\t    libcount++;\n+\t  append_option (OPT_l, safe_strdup (libname), 1);\n+\t  libcount++;\n \t  free (libname);\n         }\n       else\n         {\n           libname = xstrndup (l, e - l);\n           l = e + 1;\n-\t  if (add_default_combination (libpath, libname))\n-\t    libcount++;\n+\t  append_option (OPT_l, safe_strdup (libname), 1);\n+\t  libcount++;\n \t  free (libname);\n         }\n     }\n-  while ((l != NULL) && (l[0] != (char)0));\n   return libcount;\n }\n \n-/* build_include_path builds the component of the include path\n-   referenced by the library.  */\n-\n-static const char *\n-build_include_path (const char *libpath, const char *library)\n-{\n-  char dir_sep[2];\n-  char *gm2libs;\n-  unsigned int machine_length = 0;\n-\n-  dir_sep[0] = DIR_SEPARATOR;\n-  dir_sep[1] = (char)0;\n-\n-  if (multilib_dir != NULL)\n-    {\n-      machine_length = strlen (multilib_dir);\n-      machine_length += strlen (dir_sep);\n-    }\n-\n-  gm2libs = (char *)alloca (strlen (libpath) + strlen (dir_sep) + strlen (\"m2\")\n-                            + strlen (dir_sep) + strlen (library) + 1\n-\t\t\t    + machine_length + 1);\n-  strcpy (gm2libs, libpath);\n-  strcat (gm2libs, dir_sep);\n-  if (machine_length > 0)\n-    {\n-      strcat (gm2libs, multilib_dir);\n-      strcat (gm2libs, dir_sep);\n-    }\n-  strcat (gm2libs, \"m2\");\n-  strcat (gm2libs, dir_sep);\n-  strcat (gm2libs, library);\n-\n-  return xstrdup (gm2libs);\n-}\n-\n-/* add_include add the correct include path given the libpath and\n-   library.  The new path is returned.  */\n-\n-static const char *\n-add_include (const char *libpath, const char *library)\n-{\n-  if (library == NULL)\n-    return NULL;\n-  else\n-    return build_include_path (libpath, library);\n-}\n-\n-/* add_default_includes add the appropriate default include paths\n-   depending upon the style of libraries chosen.  */\n-\n-static void\n-add_default_includes (const char *libpath, const char *libraries)\n-{\n-  const char *l = libraries;\n-  const char *e;\n-  const char *c;\n-  const char *path;\n-\n-  do\n-    {\n-      e = index (l, ',');\n-      if (e == NULL)\n-        {\n-          c = xstrdup (l);\n-          l = NULL;\n-        }\n-      else\n-        {\n-          c = xstrndup (l, e - l);\n-          l = e + 1;\n-        }\n-      path = add_include (libpath, c);\n-      append_option (OPT_I, path, 1);\n-    }\n-  while ((l != NULL) && (l[0] != (char)0));\n-}\n-\n-/* library_installed returns true if directory library is found under\n-   libpath.  */\n-\n-static bool\n-library_installed (const char *libpath, const char *library)\n-{\n-#if defined(HAVE_OPENDIR) && defined(HAVE_DIRENT_H)\n-  const char *complete = build_archive_path (libpath, library);\n-  DIR *directory = opendir (complete);\n-\n-  if (directory == NULL || (errno == ENOENT))\n-    return false;\n-  /* Directory exists and therefore the library also exists.  */\n-  closedir (directory);\n-  return true;\n-#else\n-  return false;\n-#endif\n-}\n-\n-/* check_valid check to see that the library is valid.\n-   It check the library against the default library set in gm2 and\n-   also against any additional libraries installed in the prefix tree.  */\n-\n-static bool\n-check_valid_library (const char *libpath, const char *library)\n-{\n-  /* Firstly check against the default libraries (which might not be\n-     installed yet).  */\n-  for (int i = 0; i < maxlib; i++)\n-    if (strcmp (library, library_name[i]) == 0)\n-      return true;\n-  /* Secondly check whether it is installed (a third party library).  */\n-  return library_installed (libpath, library);\n-}\n-\n-/* check_valid_list check to see that the libraries specified are valid.\n-   It checks against the default library set in gm2 and also against\n-   any additional libraries installed in the libpath tree.  */\n-\n-static bool\n-check_valid_list (const char *libpath, const char *libraries)\n-{\n-  const char *start = libraries;\n-  const char *end;\n-  const char *copy;\n-\n-  do\n-    {\n-      end = index (start, ',');\n-      if (end == NULL)\n-        {\n-          copy = xstrdup (start);\n-          start = NULL;\n-        }\n-      else\n-        {\n-          copy = xstrndup (start, end - start);\n-          start = end + 1;\n-        }\n-      if (! check_valid_library (libpath, copy))\n-\t{\n-\t  error (\"library specified %sq is either not installed or does not exist\",\n-\t\t copy);\n-\t  return false;\n-\t}\n-    }\n-  while ((start != NULL) && (start[0] != (char)0));\n-  return true;\n-}\n-\n /* add_word returns a new string which has the contents of lib\n    appended to list.  If list is NULL then lib is duplicated and\n    returned otherwise the list is appended by \",\" and the contents of\n@@ -509,8 +329,14 @@ convert_abbreviation (const char *full_libraries, const char *abbreviation)\n   for (int i = 0; i < maxlib; i++)\n     if (strcmp (abbreviation, library_abbrev[i]) == 0)\n       return add_word (full_libraries, library_name[i]);\n-  /* No abbreviation found therefore assume user specified full library name.  */\n-  return add_word (full_libraries, abbreviation);\n+  /* Perhaps the user typed in the whole lib name rather than an abbrev.  */\n+  for (int i = 0; i < maxlib; i++)\n+    if (strcmp (abbreviation, library_name[i]) == 0)\n+      return add_word (full_libraries, abbreviation);\n+  /* Not found, probably a user typo.  */\n+  error (\"%qs is not a valid Modula-2 system library name or abbreviation\",\n+\t abbreviation);\n+  return full_libraries;\n }\n \n /* convert_abbreviations checks each element in the library list to\n@@ -535,7 +361,8 @@ convert_abbreviations (const char *libraries)\n         }\n       else\n         {\n-          full_libraries = convert_abbreviation (full_libraries, xstrndup (start, end - start));\n+\t  full_libraries = convert_abbreviation (full_libraries,\n+\t\t\t\t\t\t xstrndup (start, end - start));\n           start = end + 1;\n         }\n     }\n@@ -572,9 +399,7 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n   /* Which c++ runtime library to link.  */\n   stdcxxlib_kind which_library = USE_LIBSTDCXX;\n \n-  const char *libraries = NULL;\n   const char *dialect = DEFAULT_DIALECT;\n-  const char *libpath = LIBSUBDIR;\n \n   /* An array used to flag each argument that needs a bit set for\n      LANGSPEC, MATHLIB, or WITHLIBC.  */\n@@ -673,12 +498,15 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n \tcase OPT_flibs_:\n \t  libraries = xstrdup (arg);\n \t  allow_libraries = decoded_options[i].value;\n+\t  args[i] |= SKIPOPT; /* We will add the option if it is needed.  */\n \t  break;\n \tcase OPT_fmod_:\n \t  seen_module_extension = true;\n+\t  args[i] |= SKIPOPT; /* We will add the option if it is needed.  */\n \t  break;\n         case OPT_fpthread:\n           need_pthread = decoded_options[i].value;\n+\t  args[i] |= SKIPOPT; /* We will add the option if it is needed.  */\n           break;\n         case OPT_fm2_plugin:\n           need_plugin = decoded_options[i].value;\n@@ -687,14 +515,22 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n \t    error (\"plugin support is disabled; configure with \"\n \t\t   \"%<--enable-plugin%>\");\n #endif\n+\t  args[i] |= SKIPOPT; /* We will add the option if it is needed.  */\n           break;\n \tcase OPT_fscaffold_dynamic:\n \t  seen_scaffold_dynamic = true;\n \t  scaffold_dynamic = decoded_options[i].value;\n+\t  args[i] |= SKIPOPT; /* We will add the option if it is needed.  */\n \t  break;\n \tcase OPT_fscaffold_static:\n \t  seen_scaffold_static = true;\n \t  scaffold_static = decoded_options[i].value;\n+\t  args[i] |= SKIPOPT; /* We will add the option if it is needed.  */\n+\t  break;\n+\tcase OPT_fscaffold_main:\n+\t  seen_scaffold_main = true;\n+\t  scaffold_main = decoded_options[i].value;\n+\t  args[i] |= SKIPOPT; /* We will add the option if it is needed.  */\n \t  break;\n \tcase OPT_fgen_module_list_:\n \t  seen_gen_module_list = true;\n@@ -761,6 +597,14 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n \t  library = -1;\n \t  break;\n \n+\t/* PCH makes no sense here, we do not catch -output-pch on purpose,\n+\t   that should flag an error.  */\n+\tcase OPT_fpch_deps:\n+\tcase OPT_fpch_preprocess:\n+\tcase OPT_Winvalid_pch:\n+\t  args[i] |= SKIPOPT;\n+\t  break;\n+\n \tcase OPT_static:\n \t  static_link = 1;\n \t  break;\n@@ -794,24 +638,23 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n \t  break;\n \n \tdefault:\n-\t  if ((decoded_options[i].orig_option_with_args_text != NULL)\n-\t      && (strncmp (decoded_options[i].orig_option_with_args_text,\n-\t\t\t   \"-m\", 2) == 0))\n-\t    multilib_dir = xstrdup (decoded_options[i].orig_option_with_args_text\n-\t\t\t\t    + 2);\n+\t  break;\n \t}\n     }\n   if (language != NULL && (strcmp (language, \"modula-2\") != 0))\n     return;\n \n-  if (scaffold_static && scaffold_dynamic)\n-    {\n-      if (! seen_scaffold_dynamic)\n-\tscaffold_dynamic = false;\n-      if (scaffold_dynamic && scaffold_static)\n-\terror (\"%qs and %qs cannot both be enabled\",\n-\t       \"-fscaffold-dynamic\", \"-fscaffold-static\");\n-    }\n+  /* Override the default when the user specifies it.  */\n+  if (seen_scaffold_static && scaffold_static && !seen_scaffold_dynamic)\n+    scaffold_dynamic = false;\n+\n+  /* If both options have been seen and both are true, that means the user\n+     tried to set both.  */\n+  if (seen_scaffold_dynamic && scaffold_dynamic\n+     && seen_scaffold_static && scaffold_static)\n+    error (\"%qs and %qs cannot both be enabled\",\n+\t   \"-fscaffold-dynamic\", \"-fscaffold-static\");\n+\n   if (uselist && gen_module_list)\n     {\n       if (! seen_gen_module_list)\n@@ -855,32 +698,54 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n #endif\n     }\n \n-  /* We now add in extra arguments to facilitate a successful\n-     compile or link.  For example include paths for dialect of Modula-2,\n-     library paths and default scaffold linking options.  */\n+  /* We now add in extra arguments to facilitate a successful link.\n+     Note that the libraries are added to the end of the link here\n+     and also placed earlier into the link by lang-specs.h.  Possibly\n+     this is needed because the m2pim,m2iso libraries are cross linked\n+     (--fixme-- combine all the m2 libraries into a single archive).\n+\n+     We also add default scaffold linking options.  */\n \n   /* If we have not seen either uselist or gen_module_list and we need\n-     to link then we turn on -fgen_module_list=- as the default.  */\n-  if ((! (seen_uselist || seen_gen_module_list)) && linking)\n+     to link or compile a module list then we turn on -fgen_module_list=-\n+     as the default.  */\n+  if (!seen_uselist && !seen_gen_module_list\n+      && (linking || scaffold_main))\n     append_option (OPT_fgen_module_list_, \"-\", 1);\n \n+  /* We checked that they were not both enabled above, if there was a set\n+     value (even iff that is 'off'), pass that to the FE.  */\n+  if (seen_scaffold_dynamic || scaffold_dynamic)\n+    append_option (OPT_fscaffold_dynamic, NULL, scaffold_dynamic);\n+  if (seen_scaffold_static)\n+    append_option (OPT_fscaffold_static, NULL, scaffold_static);\n+\n+  /* If the user has set fscaffold-main specifically, use that.  Otherwise, if\n+     we are linking then set it so that we generate the relevant code for the\n+     main module.  */\n+  if (seen_scaffold_main)\n+    append_option (OPT_fscaffold_main, NULL, scaffold_main);\n+  else if (linking)\n+    append_option (OPT_fscaffold_main, NULL, true);\n+\n   if (allow_libraries)\n     {\n-      /* If the libraries have not been specified by the user but the\n-\t dialect has been specified then select the appropriate libraries.  */\n+      /* If the libraries have not been specified by the user, select the\n+\t appropriate libraries for the active dialect.  */\n       if (libraries == NULL)\n \t{\n \t  if (strcmp (dialect, \"iso\") == 0)\n-\t    libraries = xstrdup (\"m2iso,m2pim\");\n+\t    libraries = xstrdup (\"m2iso,m2cor,m2pim,m2log\");\n \t  else\n-\t    /* Default to pim libraries if none specified.  */\n-\t    libraries = xstrdup (\"m2pim,m2log,m2iso\");\n+\t    /* Default to pim libraries otherwise.  */\n+\t    libraries = xstrdup (\"m2pim,m2iso,m2cor,m2log\");\n \t}\n       libraries = convert_abbreviations (libraries);\n-      if (! check_valid_list (libpath, libraries))\n-\treturn;\n-      add_default_includes (libpath, libraries);\n+      append_option (OPT_flibs_, xstrdup (libraries), 1);\n     }\n+  else\n+    append_option (OPT_flibs_, xstrdup (\"-\"), 0); /* no system libs.  */\n+\n   if ((! seen_x_flag) && seen_module_extension)\n     append_option (OPT_x, \"modula-2\", 1);\n \n@@ -889,16 +754,19 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n \n   if (linking)\n     {\n+      if (allow_libraries)\n+\t{\n #ifdef HAVE_LD_STATIC_DYNAMIC\n-      if (allow_libraries && !shared_libgm2)\n-\tappend_option (OPT_Wl_, LD_STATIC_OPTION, 1);\n+\t  if (!shared_libgm2)\n+\t    append_option (OPT_Wl_, LD_STATIC_OPTION, 1);\n #endif\n-      if (allow_libraries)\n-\tadd_default_archives (libpath, libraries);\n+\t  added_libraries += add_default_libs (libraries);\n #ifdef HAVE_LD_STATIC_DYNAMIC\n-      if (allow_libraries && !shared_libgm2)\n-\tappend_option (OPT_Wl_, LD_DYNAMIC_OPTION, 1);\n+\t  if (!shared_libgm2)\n+\t    append_option (OPT_Wl_, LD_DYNAMIC_OPTION, 1);\n #endif\n+\t}\n+\n       /* Add `-lstdc++' if we haven't already done so.  */\n #ifdef HAVE_LD_STATIC_DYNAMIC\n       if (library > 1 && !static_link)\n@@ -962,6 +830,7 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n   *in_added_libraries = added_libraries;\n }\n \n+\n /* Called before linking.  Returns 0 on success and -1 on failure.  */\n int\n lang_specific_pre_link (void)  /* Not used for M2.  */"}, {"sha": "65004e1cabd83a014f305c306f9c7e95b0b6a6a4", "filename": "gcc/m2/lang-specs.h", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Flang-specs.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -21,18 +21,36 @@ along with GCC; see the file COPYING3.  If not see\n /* This is the contribution to the `default_compilers' array in gcc.c for\n    GNU Modula-2.  */\n \n-/* Pass the preprocessor options on the command line together with\n-   the exec prefix.  */\n-\n-#define M2CPP \"%{fcpp:-fcpp-begin \" \\\n-              \"      -E -lang-asm -traditional-cpp \" \\\n-              \"      %(cpp_unique_options) -fcpp-end}\"\n+/* A spec for the 'integrated' preprocessor implementation for Modula-2.  */\n+#define M2CPP \\\n+  \"%{E|M|MM|fcpp: %{E} -fcpp-begin \" \\\n+  \"      %{!E:-E} %(cpp_unique_options) -traditional-cpp -ansi \" \\\n+  \"      -fcpp-end %{B*} %{save-temps*} ; \\\n+     : %{v} %I %{B*} %{save-temps*} } \"\n+\n+/* We have three modes:\n+   1. When the preprocessing step is explict and there is no following\n+      compilation.  Here we do a similar process to cc1 -E where most of\n+      the compilation is short-circuited.\n+   2. When we are mimicking an integrated preprocessor.  Here we use the\n+      modula-2 'fcpp' to construct a command line for the preprocessor and\n+      snarf save-temps and dumpdir inputs to try and be consistent.\n+   3. We can consume a pre-processed modula-2 source.  */\n \n   {\".mod\", \"@modula-2\", 0, 0, 0},\n   {\"@modula-2\",\n-      \"cc1gm2 \" M2CPP\n-      \"      %(cc1_options) %{B*} %{c*} %{f*} %{+e*} %{I*} \"\n-      \"      %{MD} %{MMD} %{M} %{MM} %{MA} %{MT*} %{MF*} %V\"\n-      \"      %{save-temps*} %{v} \"\n-      \"      %i %{!fsyntax-only:%(invoke_as)}\",\n-      0, 0, 0},\n+   /* For preprocessing we use cc1 but wrap it in cc1gm2.  */\n+   \"%{E|M|MM:\\\n+      cc1gm2 \" M2CPP \" %{!fcpp:-fcpp;:%{fcpp}} %{I*} %i } \\\n+    %{!E:%{!M:%{!MM:\\\n+      cc1gm2 \" M2CPP \" %(cc1_options) %{I*} %i %{c} \\\n+      %{!fcpp:%{MD|MMD|MF*: \\\n+\t\t%eto generate dependencies you must specify '-fcpp' }} \\\n+      %{!fsyntax-only:%(invoke_as)} \\\n+    }}}\", 0, 0, 0},\n+  {\".m2i\", \"@modula-2-cpp-output\", 0, 0, 0},\n+  {\"@modula-2-cpp-output\",\n+   \"%{!M:%{!MM:%{!E: \\\n+      cc1gm2 %<fcpp %(cc1_options) %{v} %I -fmod=.mod.m2i -fdef=.def.m2i %{I*} \\\n+\t-fpreprocessed %i %{c} \\\n+    %{!fsyntax-only:%(invoke_as)}}}}\", 0, 0, 0},"}, {"sha": "b6ef8161d90d7b671e81622ac2521cd503635af6", "filename": "gcc/m2/lang.opt", "status": "modified", "additions": 127, "deletions": 73, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Flang.opt?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -21,47 +21,15 @@\n \n ; See the GCC internals manual for a description of this file's format.\n \n+; There are two sections:\n+;  1. Options specific to Modula-2\n+;  2. Options shared with C or the Driver.\n+; Please keep any new additions for either case in the relevant section.\n ; Please try to keep this file in ASCII collating order.\n \n Language\n Modula-2\n \n-B\n-Modula-2\n-; Documented in c.opt\n-\n-D\n-Modula-2\n-; Documented in c.opt\n-\n-E\n-Modula-2\n-; Documented in c.opt (passed to the preprocessor if -fcpp is used)\n-\n-I\n-Modula-2 Joined Separate\n-; Documented in c.opt\n-\n-L\n-Modula-2 Joined Separate\n-; Not documented\n-\n-M\n-Modula-2\n-; Documented in c.opt\n-\n-O\n-Modula-2\n-; Documented in c.opt\n-\n-Wall\n-Modula-2\n-; Documented in c.opt\n-\n-Wpedantic\n-Modula-2\n-; Documented in common.opt\n-\n Wpedantic-param-names\n Modula-2\n compiler checks to force definition module procedure parameter names with their implementation module counterpart\n@@ -78,18 +46,6 @@ Wstyle\n Modula-2\n extra compile time semantic checking, typically tries to catch poor programming style\n \n-Wunused-variable\n-Modula-2\n-; Documented in c.opt\n-\n-Wunused-parameter\n-Modula-2\n-; Documented in c.opt\n-\n-c\n-Modula-2\n-; Documented in c.opt\n-\n fauto-init\n Modula-2\n automatically initializes all pointers to NIL\n@@ -102,10 +58,6 @@ fcase\n Modula-2\n turns on runtime checking to check whether a CASE statement requires an ELSE clause when on was not specified\n \n-fobjc-std=objc1\n-Modula-2\n-; Documented in c.opt\n-\n fcpp\n Modula-2\n use cpp to preprocess the module\n@@ -146,10 +98,6 @@ fdump-system-exports\n Modula-2\n display all inbuilt system items\n \n-fexceptions\n-Modula-2\n-; Documented in common.opt\n-\n fextended-opaque\n Modula-2\n allows opaque types to be implemented as any type (a GNU Modula-2 extension)\n@@ -306,26 +254,144 @@ fwholevalue\n Modula-2\n turns on runtime checking to check whether a whole number is about to exceed range\n \n-iprefix\n+static-libgm2\n+Driver\n+Link the standard Modula-2 libraries statically in the compilation.\n+\n+; Here are C options that we also recognise, either within the compiler\n+; or to build the preprocessor command lines.\n+\n+Wall\n Modula-2\n ; Documented in c.opt\n \n-isystem\n+Wpedantic\n+Modula-2\n+; Documented in common.opt\n+\n+Wreturn-type\n+Modula-2\n+; Documented in common.opt\n+\n+Wunused-variable\n Modula-2\n ; Documented in c.opt\n \n-idirafter\n+Wunused-parameter\n Modula-2\n ; Documented in c.opt\n \n-imultilib\n+B\n+Modula-2\n+; Documented in c.opt\n+\n+D\n+Modula-2\n+; Documented in c.opt\n+\n+E\n+Modula-2\n+; Documented in c.opt\n+\n+I\n+Modula-2 Joined Separate\n+; Documented in c.opt\n+\n+L\n+Modula-2 Joined Separate\n+; Not documented\n+\n+M\n+Modula-2\n+; Documented in c.opt\n+\n+MD\n+Modula-2\n+; Documented in c.opt\n+\n+MF\n+Modula-2\n+; Documented in c.opt\n+\n+MG\n+Modula-2\n+; Documented in c.opt\n+\n+MM\n+Modula-2\n+; Documented in c.opt\n+\n+MMD\n+Modula-2\n+; Documented in c.opt\n+\n+Mmodules\n+Modula-2\n+; Documented in c.opt\n+\n+Mno-modules\n+Modula-2\n+; Documented in c.opt\n+\n+MP\n+Modula-2\n+; Documented in c.opt\n+\n+MQ\n+Modula-2\n+; Documented in c.opt\n+\n+MT\n+Modula-2\n+; Documented in c.opt\n+\n+P\n+Modula-2\n+; Documented in c.opt\n+\n+ansi\n+Modula-2\n+; Documented in c.opt\n+\n+c\n+Modula-2\n+; Documented in c.opt\n+\n+fexceptions\n+Modula-2\n+; Documented in common.opt\n+\n+fobjc-std=objc1\n+Modula-2\n+; Documented in c.opt\n+\n+fpreprocessed\n Modula-2\n ; Documented in c.opt\n \n-lang-asm\n+fworking-directory\n Modula-2\n ; Documented in c.opt\n \n+iprefix\n+Modula-2\n+; Documented in c.opt\n+\n+iquote\n+Modula-2\n+; Documented in c.opt\n+\n+isystem\n+Modula-2\n+; Documented in c.opt\n+\n+idirafter\n+Modula-2\n+; Documented in c.opt\n+\n+imultilib\n+Modula-2\n+\n -save-temps\n Modula-2 Alias(save-temps)\n \n@@ -341,16 +407,4 @@ traditional-cpp\n Modula-2\n ; Documented in c.opt\n \n-v\n-Modula-2\n-; Documented in c.opt\n-\n-x\n-Modula-2 Joined\n-specify the language from the compiler driver\n-\n-static-libgm2\n-Driver\n-Link the standard Modula-2 libraries statically in the compilation.\n-\n ; This comment is to ensure we retain the blank line above."}, {"sha": "2937290635c5b9906422775a86766dbe7656a218", "filename": "gcc/m2/m2.flex", "status": "modified", "additions": 71, "deletions": 2, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fm2.flex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fm2.flex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fm2.flex?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -27,6 +27,7 @@ along with GNU Modula-2; see the file COPYING3.  If not see\n #include \"input.h\"\n #include \"m2options.h\"\n \n+static int cpreprocessor = 0;  /* Replace this with correct getter.  */\n \n #if defined(GM2USEGGC)\n #  include \"ggc.h\"\n@@ -70,6 +71,7 @@ along with GNU Modula-2; see the file COPYING3.  If not see\n   static int                  lineno      =1;   /* a running count of the file line number */\n   static char                *filename    =NULL;\n   static int                  commentLevel=0;\n+  static int                  commentCLevel=0;\n   static struct lineInfo     *currentLine=NULL;\n   static struct functionInfo *currentFunction=NULL;\n   static int                  seenFunctionStart=FALSE;\n@@ -87,6 +89,8 @@ static  void updatepos                (void);\n static  void skippos                  (void);\n static  void poperrorskip             (const char *);\n static  void endOfComment             (void);\n+static  void endOfCComment            (void);\n+static  void splitSlashStar           (void);\n static  void handleDate               (void);\n static  void handleLine               (void);\n static  void handleFile               (void);\n@@ -117,7 +121,7 @@ extern  void  yylex                   (void);\n %}\n \n %option nounput\n-%x COMMENT COMMENT1 LINE0 LINE1 LINE2\n+%x COMMENT COMMENT1 COMMENTC LINE0 LINE1 LINE2\n \n %%\n \n@@ -131,8 +135,9 @@ extern  void  yylex                   (void);\n                                pushLine();\n                                skippos();\n                                BEGIN COMMENT1;\n-                             } else\n+                             } else {\n                                updatepos(); skippos();\n+\t\t\t     }\n                            }\n <COMMENT>\\n.*              { consumeLine(); }\n <COMMENT>.                 { updatepos(); skippos(); }\n@@ -144,6 +149,24 @@ extern  void  yylex                   (void);\n <COMMENT1><<EOF>>          { poperrorskip(\"unterminated source code directive, missing *>\"); BEGIN COMMENT; }\n <COMMENT><<EOF>>           { poperrorskip(\"unterminated comment found at the end of the file, missing *)\"); BEGIN INITIAL; }\n \n+\"/*\"                       { /* Possibly handle C preprocessor comment.  */\n+                             if (cpreprocessor)\n+\t\t\t       {\n+\t\t\t\t updatepos ();\n+\t\t\t\t commentCLevel++;\n+\t\t\t\t if (commentCLevel == 1)\n+\t\t\t\t   {\n+\t\t\t\t     pushLine ();\n+\t\t\t\t     skippos ();\n+\t\t\t\t   }\n+\t\t\t\t BEGIN COMMENTC;\n+\t\t\t       }\n+\t\t\t     else\n+\t\t\t       splitSlashStar ();\n+                           }\n+<COMMENTC>.                { updatepos(); skippos(); }\n+<COMMENTC>\\n.*             { consumeLine(); }\n+<COMMENTC>\"*/\"             { endOfCComment(); }\n ^\\#.*                      { consumeLine(); /* printf(\"found: %s\\n\", currentLine->linebuf); */ BEGIN LINE0; }\n \\n\\#.*                     { consumeLine(); /* printf(\"found: %s\\n\", currentLine->linebuf); */ BEGIN LINE0; }\n <LINE0>\\#[ \\t]*            { updatepos(); }\n@@ -435,6 +458,19 @@ static void endOfComment (void)\n     popLine();\n }\n \n+/*\n+ *  endOfCComment - handles the end of C comment.\n+ */\n+\n+static void endOfCComment (void)\n+{\n+  commentCLevel = 0;\n+  updatepos();\n+  skippos();\n+  BEGIN INITIAL;\n+  finishedLine();\n+}\n+\n /*\n  *  m2flex_M2Error - displays the error message, s, after the code line and pointer\n  *                   to the erroneous token.\n@@ -503,6 +539,39 @@ static void assert_location (location_t location ATTRIBUTE_UNUSED)\n #endif\n }\n \n+/*\n+ *  splitSlashStar - called if we are not tokenizing source code after it\n+ *                   has been preprocessed by cpp.  It is only called\n+ *                   if the current token was a / immediately followed by * and\n+ *                   therefore it will be split into two m2 tokens:  / and *.\n+ */\n+\n+static void splitSlashStar (void)\n+{\n+  seenFunctionStart    = FALSE;\n+  seenEnd              = FALSE;\n+  seenModuleStart      = FALSE;\n+  currentLine->nextpos = currentLine->tokenpos+1;  /* \"/\".  */\n+  currentLine->toklen  = 1;\n+  currentLine->column = currentLine->tokenpos+1;\n+  currentLine->location =\n+    M2Options_OverrideLocation (GET_LOCATION (currentLine->column,\n+                                              currentLine->column+currentLine->toklen-1));\n+  assert_location (GET_LOCATION (currentLine->column,\n+                                 currentLine->column+currentLine->toklen-1));\n+  M2LexBuf_AddTok (M2Reserved_dividetok);\n+  currentLine->nextpos = currentLine->tokenpos+1;  /* \"*\".  */\n+  currentLine->toklen  = 1;\n+  currentLine->column = currentLine->tokenpos+1;\n+  currentLine->location =\n+    M2Options_OverrideLocation (GET_LOCATION (currentLine->column,\n+                                              currentLine->column+currentLine->toklen-1));\n+  assert_location (GET_LOCATION (currentLine->column,\n+                                 currentLine->column+currentLine->toklen-1));\n+  M2LexBuf_AddTok (M2Reserved_timestok);\n+}\n+\n+\n /*\n  *  updatepos - updates the current token position.\n  *              Should be used when a rule matches a token."}, {"sha": "3f4518074c8b84b9bbfed821c54a8edfff80f1aa", "filename": "gcc/m2/m2pp.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fm2pp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fm2pp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fm2pp.cc?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -547,6 +547,7 @@ m2pp_types (pretty *s)\n     }\n }\n \n+#ifdef DEBUGGING\n /* hextree displays the critical fields for function, block and\n    bind_expr trees in raw hex.  */\n \n@@ -607,6 +608,7 @@ hextree (tree t)\n       killPretty (state);\n     }\n }\n+#endif\n \n /* translation produce a pseudo implementation module from the tree t.  */\n "}, {"sha": "7a37fef6150a627fae1d773bc7afd80ad2c75abe", "filename": "gcc/m2/mc-boot-ch/Glibc.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fmc-boot-ch%2FGlibc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fmc-boot-ch%2FGlibc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot-ch%2FGlibc.c?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -77,6 +77,20 @@ libc_strlen (char *s)\n   return strlen (s);\n }\n \n+EXTERN\n+time_t\n+libc_time (time_t *buf)\n+{\n+  return time (buf);\n+}\n+\n+EXTERN\n+void *\n+libc_localtime (time_t *epochtime)\n+{\n+  return localtime (epochtime);\n+}\n+\n EXTERN\n int\n libc_printf (char *_format, unsigned int _format_high, ...)"}, {"sha": "bcb1b1323653cfd68e1951c00e028401cb0414ea", "filename": "gcc/m2/mc-boot/GArgs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fmc-boot%2FGArgs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fmc-boot%2FGArgs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGArgs.c?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -83,7 +83,7 @@ extern \"C\" unsigned int Args_GetArg (char *a, unsigned int _a_high, unsigned int\n   if (i < (UnixArgs_GetArgC ()))\n     {\n       Source = static_cast<Args__T1> (UnixArgs_GetArgV ());\n-      while (((*(*Source).array[i]).array[j] != ASCII_nul) && (j < High))\n+      while ((j < High) && ((*(*Source).array[i]).array[j] != ASCII_nul))\n         {\n           a[j] = (*(*Source).array[i]).array[j];\n           j += 1;"}, {"sha": "a28b641c47a13083296ff5e6d1ec25bfa233d9b4", "filename": "gcc/m2/mc-boot/GDynamicStrings.c", "status": "modified", "additions": 16, "deletions": 26, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fmc-boot%2FGDynamicStrings.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fmc-boot%2FGDynamicStrings.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGDynamicStrings.c?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -1214,7 +1214,7 @@ static void ConcatContents (DynamicStrings_Contents *c, const char *a_, unsigned\n       (*c).next->contents.next = NULL;\n       ConcatContents (&(*c).next->contents, (const char *) a, _a_high, h, o);\n       AddDebugInfo ((*c).next);\n-      (*c).next = AssignDebug ((*c).next, (const char *) \"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/DynamicStrings.mod\", 62, 722, (const char *) \"ConcatContents\", 14);\n+      (*c).next = AssignDebug ((*c).next, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 722, (const char *) \"ConcatContents\", 14);\n     }\n   else\n     {\n@@ -1312,7 +1312,7 @@ static void ConcatContentsAddress (DynamicStrings_Contents *c, void * a, unsigne\n       AddDebugInfo ((*c).next);\n       if (TraceOn)\n         {\n-          (*c).next = AssignDebug ((*c).next, (const char *) \"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/DynamicStrings.mod\", 62, 917, (const char *) \"ConcatContentsAddress\", 21);\n+          (*c).next = AssignDebug ((*c).next, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 917, (const char *) \"ConcatContentsAddress\", 21);\n         }\n     }\n   else\n@@ -1537,7 +1537,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_InitString (const char *a_, unsi\n   AddDebugInfo (s);\n   if (TraceOn)\n     {\n-      s = AssignDebug (s, (const char *) \"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/DynamicStrings.mod\", 62, 758, (const char *) \"InitString\", 10);\n+      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 758, (const char *) \"InitString\", 10);\n     }\n   return s;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -1640,7 +1640,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_InitStringCharStar (void * a)\n   AddDebugInfo (s);\n   if (TraceOn)\n     {\n-      s = AssignDebug (s, (const char *) \"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/DynamicStrings.mod\", 62, 957, (const char *) \"InitStringCharStar\", 18);\n+      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 957, (const char *) \"InitStringCharStar\", 18);\n     }\n   return s;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -1665,7 +1665,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_InitStringChar (char ch)\n   s = DynamicStrings_InitString ((const char *) &a.array[0], 1);\n   if (TraceOn)\n     {\n-      s = AssignDebug (s, (const char *) \"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/DynamicStrings.mod\", 62, 977, (const char *) \"InitStringChar\", 14);\n+      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 977, (const char *) \"InitStringChar\", 14);\n     }\n   return s;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -1823,7 +1823,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_Dup (DynamicStrings_String s)\n   s = DynamicStrings_Assign (DynamicStrings_InitString ((const char *) \"\", 0), s);\n   if (TraceOn)\n     {\n-      s = AssignDebug (s, (const char *) \"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/DynamicStrings.mod\", 62, 1173, (const char *) \"Dup\", 3);\n+      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1173, (const char *) \"Dup\", 3);\n     }\n   return s;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -1845,7 +1845,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_Add (DynamicStrings_String a, Dy\n   a = DynamicStrings_ConCat (DynamicStrings_ConCat (DynamicStrings_InitString ((const char *) \"\", 0), a), b);\n   if (TraceOn)\n     {\n-      a = AssignDebug (a, (const char *) \"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/DynamicStrings.mod\", 62, 1193, (const char *) \"Add\", 3);\n+      a = AssignDebug (a, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1193, (const char *) \"Add\", 3);\n     }\n   return a;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -1874,16 +1874,6 @@ extern \"C\" unsigned int DynamicStrings_Equal (DynamicStrings_String a, DynamicSt\n           Assertion_Assert (a->contents.len == b->contents.len);\n           while (i < a->contents.len)\n             {\n-              if (a->contents.buf.array[i] != a->contents.buf.array[i])\n-                {\n-                  M2RTS_HALT (-1);\n-                  __builtin_unreachable ();\n-                }\n-              if (b->contents.buf.array[i] != b->contents.buf.array[i])\n-                {\n-                  M2RTS_HALT (-1);\n-                  __builtin_unreachable ();\n-                }\n               if (a->contents.buf.array[i] != b->contents.buf.array[i])\n                 {\n                   return FALSE;\n@@ -1920,7 +1910,7 @@ extern \"C\" unsigned int DynamicStrings_EqualCharStar (DynamicStrings_String s, v\n   t = DynamicStrings_InitStringCharStar (a);\n   if (TraceOn)\n     {\n-      t = AssignDebug (t, (const char *) \"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/DynamicStrings.mod\", 62, 1258, (const char *) \"EqualCharStar\", 13);\n+      t = AssignDebug (t, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1250, (const char *) \"EqualCharStar\", 13);\n     }\n   t = AddToGarbage (t, s);\n   if (DynamicStrings_Equal (t, s))\n@@ -1958,7 +1948,7 @@ extern \"C\" unsigned int DynamicStrings_EqualArray (DynamicStrings_String s, cons\n   t = DynamicStrings_InitString ((const char *) a, _a_high);\n   if (TraceOn)\n     {\n-      t = AssignDebug (t, (const char *) \"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/DynamicStrings.mod\", 62, 1288, (const char *) \"EqualArray\", 10);\n+      t = AssignDebug (t, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1280, (const char *) \"EqualArray\", 10);\n     }\n   t = AddToGarbage (t, s);\n   if (DynamicStrings_Equal (t, s))\n@@ -1996,7 +1986,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_Mult (DynamicStrings_String s, u\n     }\n   if (TraceOn)\n     {\n-      s = AssignDebug (s, (const char *) \"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/DynamicStrings.mod\", 62, 1320, (const char *) \"Mult\", 4);\n+      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1312, (const char *) \"Mult\", 4);\n     }\n   return s;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -2075,7 +2065,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_Slice (DynamicStrings_String s,\n                       AddDebugInfo (t->contents.next);\n                       if (TraceOn)\n                         {\n-                          t->contents.next = AssignDebug (t->contents.next, (const char *) \"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/DynamicStrings.mod\", 62, 1388, (const char *) \"Slice\", 5);\n+                          t->contents.next = AssignDebug (t->contents.next, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1380, (const char *) \"Slice\", 5);\n                         }\n                     }\n                   t = t->contents.next;\n@@ -2093,7 +2083,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_Slice (DynamicStrings_String s,\n     }\n   if (TraceOn)\n     {\n-      d = AssignDebug (d, (const char *) \"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/DynamicStrings.mod\", 62, 1405, (const char *) \"Slice\", 5);\n+      d = AssignDebug (d, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1397, (const char *) \"Slice\", 5);\n     }\n   return d;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -2221,7 +2211,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_RemoveComment (DynamicStrings_St\n     }\n   if (TraceOn)\n     {\n-      s = AssignDebug (s, (const char *) \"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/DynamicStrings.mod\", 62, 1517, (const char *) \"RemoveComment\", 13);\n+      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1509, (const char *) \"RemoveComment\", 13);\n     }\n   return s;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -2246,7 +2236,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_RemoveWhitePrefix (DynamicString\n   s = DynamicStrings_Slice (s, (int ) (i), 0);\n   if (TraceOn)\n     {\n-      s = AssignDebug (s, (const char *) \"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/DynamicStrings.mod\", 62, 1629, (const char *) \"RemoveWhitePrefix\", 17);\n+      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1621, (const char *) \"RemoveWhitePrefix\", 17);\n     }\n   return s;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -2271,7 +2261,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_RemoveWhitePostfix (DynamicStrin\n   s = DynamicStrings_Slice (s, 0, i+1);\n   if (TraceOn)\n     {\n-      s = AssignDebug (s, (const char *) \"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/DynamicStrings.mod\", 62, 1651, (const char *) \"RemoveWhitePostfix\", 18);\n+      s = AssignDebug (s, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 1643, (const char *) \"RemoveWhitePostfix\", 18);\n     }\n   return s;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -2640,7 +2630,7 @@ extern \"C\" DynamicStrings_String DynamicStrings_PopAllocationExemption (unsigned\n         {\n           stop ();\n           /* writeString (\"mismatched number of PopAllocation's compared to PushAllocation's\")  */\n-          M2RTS_Halt ((const char *) \"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/DynamicStrings.mod\", 62, 176, (const char *) \"PopAllocationExemption\", 22, (const char *) \"mismatched number of PopAllocation's compared to PushAllocation's\", 65);\n+          M2RTS_Halt ((const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/DynamicStrings.mod\", 55, 176, (const char *) \"PopAllocationExemption\", 22, (const char *) \"mismatched number of PopAllocation's compared to PushAllocation's\", 65);\n         }\n       else\n         {"}, {"sha": "74cd8580cf51c20e164a96574cf7bd2ca234039d", "filename": "gcc/m2/mc-boot/GFIO.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fmc-boot%2FGFIO.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fmc-boot%2FGFIO.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGFIO.c?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -555,7 +555,7 @@ static FIO_File GetNextFreeDescriptor (void)\n         return f;  /* create new slot  */\n       }\n   }\n-  ReturnException (\"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/FIO.def\", 25, 1);\n+  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/FIO.def\", 25, 1);\n   __builtin_unreachable ();\n }\n \n@@ -1703,7 +1703,7 @@ extern \"C\" unsigned int FIO_ReadNBytes (FIO_File f, unsigned int nBytes, void *\n extern \"C\" void FIO_ReadAny (FIO_File f, unsigned char *a, unsigned int _a_high)\n {\n   CheckAccess (f, FIO_openedforread, FALSE);\n-  if ((BufferedRead (f, _a_high, a)) == _a_high)\n+  if ((BufferedRead (f, _a_high, a)) == ((int ) (_a_high)))\n     {\n       SetEndOfLine (f, static_cast<char> (a[_a_high]));\n     }\n@@ -1762,7 +1762,7 @@ extern \"C\" unsigned int FIO_WriteNBytes (FIO_File f, unsigned int nBytes, void *\n extern \"C\" void FIO_WriteAny (FIO_File f, unsigned char *a, unsigned int _a_high)\n {\n   CheckAccess (f, FIO_openedforwrite, TRUE);\n-  if ((BufferedWrite (f, _a_high, a)) == _a_high)\n+  if ((BufferedWrite (f, _a_high, a)) == ((int ) (_a_high)))\n     {}  /* empty.  */\n }\n \n@@ -1774,7 +1774,7 @@ extern \"C\" void FIO_WriteAny (FIO_File f, unsigned char *a, unsigned int _a_high\n extern \"C\" void FIO_WriteChar (FIO_File f, char ch)\n {\n   CheckAccess (f, FIO_openedforwrite, TRUE);\n-  if ((BufferedWrite (f, sizeof (ch), &ch)) == sizeof (ch))\n+  if ((BufferedWrite (f, sizeof (ch), &ch)) == ((int ) (sizeof (ch))))\n     {}  /* empty.  */\n }\n \n@@ -1873,7 +1873,7 @@ extern \"C\" char FIO_ReadChar (FIO_File f)\n   char ch;\n \n   CheckAccess (f, FIO_openedforread, FALSE);\n-  if ((BufferedRead (f, sizeof (ch), &ch)) == sizeof (ch))\n+  if ((BufferedRead (f, sizeof (ch), &ch)) == ((int ) (sizeof (ch))))\n     {\n       SetEndOfLine (f, ch);\n       return ch;\n@@ -2266,7 +2266,7 @@ extern \"C\" void * FIO_getFileName (FIO_File f)\n           return fd->name.address;\n         }\n     }\n-  ReturnException (\"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/FIO.def\", 25, 1);\n+  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/FIO.def\", 25, 1);\n   __builtin_unreachable ();\n }\n \n@@ -2293,7 +2293,7 @@ extern \"C\" unsigned int FIO_getFileNameLength (FIO_File f)\n           return fd->name.size;\n         }\n     }\n-  ReturnException (\"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/FIO.def\", 25, 1);\n+  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/FIO.def\", 25, 1);\n   __builtin_unreachable ();\n }\n "}, {"sha": "7710c8aae4236d22bb146057c97d138442fcedaa", "filename": "gcc/m2/mc-boot/GFormatStrings.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fmc-boot%2FGFormatStrings.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fmc-boot%2FGFormatStrings.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGFormatStrings.c?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -545,7 +545,7 @@ static DynamicStrings_String HandlePercent (DynamicStrings_String fmt, DynamicSt\n   int prevpos;\n   DynamicStrings_String result;\n \n-  if ((startpos == (DynamicStrings_Length (fmt))) || (startpos < 0))\n+  if ((startpos == ((int ) (DynamicStrings_Length (fmt)))) || (startpos < 0))\n     {\n       return s;\n     }"}, {"sha": "c809e4b9b6e0acf0fc8071b77c38da562d29d276", "filename": "gcc/m2/mc-boot/GIndexing.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fmc-boot%2FGIndexing.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fmc-boot%2FGIndexing.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGIndexing.c?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -222,7 +222,7 @@ extern \"C\" unsigned int Indexing_InBounds (Indexing_Index i, unsigned int n)\n     {\n       return (n >= i->Low) && (n <= i->High);\n     }\n-  ReturnException (\"../../gcc-git-devel-modula2/gcc/m2/mc/Indexing.def\", 20, 1);\n+  ReturnException (\"../../gcc-read-write/gcc/m2/mc/Indexing.def\", 20, 1);\n   __builtin_unreachable ();\n }\n \n@@ -242,7 +242,7 @@ extern \"C\" unsigned int Indexing_HighIndice (Indexing_Index i)\n     {\n       return i->High;\n     }\n-  ReturnException (\"../../gcc-git-devel-modula2/gcc/m2/mc/Indexing.def\", 20, 1);\n+  ReturnException (\"../../gcc-read-write/gcc/m2/mc/Indexing.def\", 20, 1);\n   __builtin_unreachable ();\n }\n \n@@ -262,7 +262,7 @@ extern \"C\" unsigned int Indexing_LowIndice (Indexing_Index i)\n     {\n       return i->Low;\n     }\n-  ReturnException (\"../../gcc-git-devel-modula2/gcc/m2/mc/Indexing.def\", 20, 1);\n+  ReturnException (\"../../gcc-read-write/gcc/m2/mc/Indexing.def\", 20, 1);\n   __builtin_unreachable ();\n }\n "}, {"sha": "fb22f1b9145531bf5d3491475a4c45437005771e", "filename": "gcc/m2/mc-boot/GM2Dependent.c", "status": "modified", "additions": 47, "deletions": 2, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fmc-boot%2FGM2Dependent.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fmc-boot%2FGM2Dependent.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGM2Dependent.c?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -262,6 +262,13 @@ static void combine (M2Dependent_DependencyState src, M2Dependent_DependencyStat\n \n static void ForceDependencies (void);\n \n+/*\n+   CheckApplication - check to see that the application is the last entry in the list.\n+                      This might happen if the application only imports FOR C modules.\n+*/\n+\n+static void CheckApplication (void);\n+\n /*\n    equal - return TRUE if C string cstr is equal to str.\n */\n@@ -450,7 +457,7 @@ static void toCString (char *str, unsigned int _str_high)\n   high = _str_high;\n   while (i < high)\n     {\n-      if ((str[i] == '\\\\') && (i < high))\n+      if ((i < high) && (str[i] == '\\\\'))\n         {\n           if (str[i+1] == 'n')\n             {\n@@ -730,6 +737,7 @@ static void ResolveDependencies (void * currentmodule)\n static void DisplayModuleInfo (M2Dependent_DependencyState state, const char *name_, unsigned int _name_high)\n {\n   M2Dependent_ModuleChain mptr;\n+  unsigned int count;\n   char name[_name_high+1];\n \n   /* make a local copy of each unbounded array.  */\n@@ -739,8 +747,10 @@ static void DisplayModuleInfo (M2Dependent_DependencyState state, const char *na\n     {\n       libc_printf ((const char *) \"%s modules\\\\n\", 12, &name);\n       mptr = Modules.array[state-M2Dependent_unregistered];\n+      count = 0;\n       do {\n-        libc_printf ((const char *) \"  %s\", 4, mptr->name);\n+        libc_printf ((const char *) \"  %d  %s\", 8, count, mptr->name);\n+        count += 1;\n         if (mptr->dependency.appl)\n           {\n             libc_printf ((const char *) \" application\", 12);\n@@ -851,6 +861,38 @@ static void ForceDependencies (void)\n }\n \n \n+/*\n+   CheckApplication - check to see that the application is the last entry in the list.\n+                      This might happen if the application only imports FOR C modules.\n+*/\n+\n+static void CheckApplication (void)\n+{\n+  M2Dependent_ModuleChain mptr;\n+  M2Dependent_ModuleChain appl;\n+\n+  mptr = Modules.array[M2Dependent_ordered-M2Dependent_unregistered];\n+  if (mptr != NULL)\n+    {\n+      appl = NULL;\n+      do {\n+        if (mptr->dependency.appl)\n+          {\n+            appl = mptr;\n+          }\n+        else\n+          {\n+            mptr = mptr->next;\n+          }\n+      } while (! ((appl != NULL) || (mptr == Modules.array[M2Dependent_ordered-M2Dependent_unregistered])));\n+      if (appl != NULL)\n+        {\n+          Modules.array[M2Dependent_ordered-M2Dependent_unregistered] = appl->next;\n+        }\n+    }\n+}\n+\n+\n /*\n    equal - return TRUE if C string cstr is equal to str.\n */\n@@ -1006,6 +1048,9 @@ extern \"C\" void M2Dependent_ConstructModules (void * applicationmodule, int argc\n   ForceDependencies ();\n   traceprintf (ForceTrace, (const char *) \"After user forcing ordering\\\\n\", 29);\n   DumpModuleData (ForceTrace);\n+  CheckApplication ();\n+  traceprintf (ForceTrace, (const char *) \"After runtime forces application to the end\\\\n\", 45);\n+  DumpModuleData (ForceTrace);\n   if (Modules.array[M2Dependent_ordered-M2Dependent_unregistered] == NULL)\n     {\n       traceprintf2 (ModuleTrace, (const char *) \"  module: %s has not registered itself using a global constructor\\\\n\", 67, applicationmodule);"}, {"sha": "7915442b6e1d1649244598bbd04b67a28f542417", "filename": "gcc/m2/mc-boot/GM2EXCEPTION.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fmc-boot%2FGM2EXCEPTION.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fmc-boot%2FGM2EXCEPTION.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGM2EXCEPTION.c?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -57,13 +57,13 @@ extern \"C\" M2EXCEPTION_M2Exceptions M2EXCEPTION_M2Exception (void)\n   n = RTExceptions_GetNumber (e);\n   if (n == (UINT_MAX))\n     {\n-      RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_exException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/M2EXCEPTION.mod\")), 47, 6, const_cast<void*> (reinterpret_cast<const void*>(\"M2Exception\")), const_cast<void*> (reinterpret_cast<const void*>(\"current coroutine is not in the exceptional execution state\")));\n+      RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_exException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/M2EXCEPTION.mod\")), 47, 6, const_cast<void*> (reinterpret_cast<const void*>(\"M2Exception\")), const_cast<void*> (reinterpret_cast<const void*>(\"current coroutine is not in the exceptional execution state\")));\n     }\n   else\n     {\n       return (M2EXCEPTION_M2Exceptions) (n);\n     }\n-  ReturnException (\"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/M2EXCEPTION.def\", 25, 1);\n+  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/M2EXCEPTION.def\", 25, 1);\n   __builtin_unreachable ();\n }\n "}, {"sha": "1b08741181b271d0d5befe575ec1ac3409c5db78", "filename": "gcc/m2/mc-boot/GM2RTS.c", "status": "modified", "additions": 98, "deletions": 23, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fmc-boot%2FGM2RTS.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fmc-boot%2FGM2RTS.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGM2RTS.c?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -61,6 +61,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n typedef struct M2RTS_ArgCVEnvP_p M2RTS_ArgCVEnvP;\n \n+#   define stderrFd 2\n typedef struct M2RTS_ProcedureList_r M2RTS_ProcedureList;\n \n typedef char *M2RTS_PtrToChar;\n@@ -175,10 +176,19 @@ extern \"C\" void M2RTS_HALT (int exitcode) __attribute__ ((noreturn));\n \n /*\n    Halt - provides a more user friendly version of HALT, which takes\n-          four parameters to aid debugging.\n+          four parameters to aid debugging.  It writes an error message\n+          to stderr and calls exit (1).\n */\n \n-extern \"C\" void M2RTS_Halt (const char *file_, unsigned int _file_high, unsigned int line, const char *function_, unsigned int _function_high, const char *description_, unsigned int _description_high) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_Halt (const char *filename_, unsigned int _filename_high, unsigned int line, const char *function_, unsigned int _function_high, const char *description_, unsigned int _description_high) __attribute__ ((noreturn));\n+\n+/*\n+   HaltC - provides a more user friendly version of HALT, which takes\n+           four parameters to aid debugging.  It writes an error message\n+           to stderr and calls exit (1).\n+*/\n+\n+extern \"C\" void M2RTS_HaltC (void * filename, unsigned int line, void * function, void * description);\n \n /*\n    ExitOnHalt - if HALT is executed then call exit with the exit code, e.\n@@ -190,7 +200,7 @@ extern \"C\" void M2RTS_ExitOnHalt (int e);\n    ErrorMessage - emits an error message to stderr and then calls exit (1).\n */\n \n-extern \"C\" void M2RTS_ErrorMessage (const char *message_, unsigned int _message_high, const char *file_, unsigned int _file_high, unsigned int line, const char *function_, unsigned int _function_high) __attribute__ ((noreturn));\n+extern \"C\" void M2RTS_ErrorMessage (const char *message_, unsigned int _message_high, const char *filename_, unsigned int _filename_high, unsigned int line, const char *function_, unsigned int _function_high) __attribute__ ((noreturn));\n \n /*\n    Length - returns the length of a string, a. This is called whenever\n@@ -245,6 +255,18 @@ static unsigned int AppendProc (M2RTS_ProcedureList *proclist, PROC proc);\n \n static void ErrorString (const char *a_, unsigned int _a_high);\n \n+/*\n+   ErrorStringC - writes a string to stderr.\n+*/\n+\n+static void ErrorStringC (void * str);\n+\n+/*\n+   ErrorMessageC - emits an error message to stderr and then calls exit (1).\n+*/\n+\n+static void ErrorMessageC (void * message, void * filename, unsigned int line, void * function) __attribute__ ((noreturn));\n+\n /*\n    InitProcList - initialize the head and tail pointers to NIL.\n */\n@@ -319,7 +341,49 @@ static void ErrorString (const char *a_, unsigned int _a_high)\n   /* make a local copy of each unbounded array.  */\n   memcpy (a, a_, _a_high+1);\n \n-  n = static_cast<int> (libc_write (2, &a, static_cast<size_t> (StrLib_StrLen ((const char *) a, _a_high))));\n+  n = static_cast<int> (libc_write (stderrFd, &a, static_cast<size_t> (StrLib_StrLen ((const char *) a, _a_high))));\n+}\n+\n+\n+/*\n+   ErrorStringC - writes a string to stderr.\n+*/\n+\n+static void ErrorStringC (void * str)\n+{\n+  int len;\n+\n+  len = static_cast<int> (libc_write (stderrFd, str, libc_strlen (str)));\n+}\n+\n+\n+/*\n+   ErrorMessageC - emits an error message to stderr and then calls exit (1).\n+*/\n+\n+static void ErrorMessageC (void * message, void * filename, unsigned int line, void * function)\n+{\n+  typedef struct ErrorMessageC__T2_a ErrorMessageC__T2;\n+\n+  struct ErrorMessageC__T2_a { char array[10+1]; };\n+  ErrorMessageC__T2 buffer;\n+\n+  ErrorStringC (filename);\n+  ErrorString ((const char *) \":\", 1);\n+  NumberIO_CardToStr (line, 0, (char *) &buffer.array[0], 10);\n+  ErrorString ((const char *) &buffer.array[0], 10);\n+  ErrorString ((const char *) \":\", 1);\n+  if ((libc_strlen (function)) > 0)\n+    {\n+      ErrorString ((const char *) \"in \", 3);\n+      ErrorStringC (function);\n+      ErrorString ((const char *) \" has caused \", 12);\n+    }\n+  ErrorStringC (message);\n+  buffer.array[0] = ASCII_nl;\n+  buffer.array[1] = ASCII_nul;\n+  ErrorString ((const char *) &buffer.array[0], 10);\n+  libc_exit (1);\n }\n \n \n@@ -516,23 +580,34 @@ extern \"C\" void M2RTS_HALT (int exitcode)\n \n /*\n    Halt - provides a more user friendly version of HALT, which takes\n-          four parameters to aid debugging.\n+          four parameters to aid debugging.  It writes an error message\n+          to stderr and calls exit (1).\n */\n \n-extern \"C\" void M2RTS_Halt (const char *file_, unsigned int _file_high, unsigned int line, const char *function_, unsigned int _function_high, const char *description_, unsigned int _description_high)\n+extern \"C\" void M2RTS_Halt (const char *filename_, unsigned int _filename_high, unsigned int line, const char *function_, unsigned int _function_high, const char *description_, unsigned int _description_high)\n {\n-  char file[_file_high+1];\n+  char filename[_filename_high+1];\n   char function[_function_high+1];\n   char description[_description_high+1];\n \n   /* make a local copy of each unbounded array.  */\n-  memcpy (file, file_, _file_high+1);\n+  memcpy (filename, filename_, _filename_high+1);\n   memcpy (function, function_, _function_high+1);\n   memcpy (description, description_, _description_high+1);\n \n-  M2RTS_ErrorMessage ((const char *) description, _description_high, (const char *) file, _file_high, line, (const char *) function, _function_high);\n-  M2RTS_HALT (-1);\n-  __builtin_unreachable ();\n+  M2RTS_ErrorMessage ((const char *) description, _description_high, (const char *) filename, _filename_high, line, (const char *) function, _function_high);\n+}\n+\n+\n+/*\n+   HaltC - provides a more user friendly version of HALT, which takes\n+           four parameters to aid debugging.  It writes an error message\n+           to stderr and calls exit (1).\n+*/\n+\n+extern \"C\" void M2RTS_HaltC (void * filename, unsigned int line, void * function, void * description)\n+{\n+  ErrorMessageC (description, filename, line, function);\n }\n \n \n@@ -551,25 +626,25 @@ extern \"C\" void M2RTS_ExitOnHalt (int e)\n    ErrorMessage - emits an error message to stderr and then calls exit (1).\n */\n \n-extern \"C\" void M2RTS_ErrorMessage (const char *message_, unsigned int _message_high, const char *file_, unsigned int _file_high, unsigned int line, const char *function_, unsigned int _function_high)\n+extern \"C\" void M2RTS_ErrorMessage (const char *message_, unsigned int _message_high, const char *filename_, unsigned int _filename_high, unsigned int line, const char *function_, unsigned int _function_high)\n {\n-  typedef struct ErrorMessage__T2_a ErrorMessage__T2;\n+  typedef struct ErrorMessage__T3_a ErrorMessage__T3;\n \n-  struct ErrorMessage__T2_a { char array[10+1]; };\n-  ErrorMessage__T2 LineNo;\n+  struct ErrorMessage__T3_a { char array[10+1]; };\n+  ErrorMessage__T3 buffer;\n   char message[_message_high+1];\n-  char file[_file_high+1];\n+  char filename[_filename_high+1];\n   char function[_function_high+1];\n \n   /* make a local copy of each unbounded array.  */\n   memcpy (message, message_, _message_high+1);\n-  memcpy (file, file_, _file_high+1);\n+  memcpy (filename, filename_, _filename_high+1);\n   memcpy (function, function_, _function_high+1);\n \n-  ErrorString ((const char *) file, _file_high);\n+  ErrorString ((const char *) filename, _filename_high);\n   ErrorString ((const char *) \":\", 1);\n-  NumberIO_CardToStr (line, 0, (char *) &LineNo.array[0], 10);\n-  ErrorString ((const char *) &LineNo.array[0], 10);\n+  NumberIO_CardToStr (line, 0, (char *) &buffer.array[0], 10);\n+  ErrorString ((const char *) &buffer.array[0], 10);\n   ErrorString ((const char *) \":\", 1);\n   if (! (StrLib_StrEqual ((const char *) function, _function_high, (const char *) \"\", 0)))\n     {\n@@ -578,9 +653,9 @@ extern \"C\" void M2RTS_ErrorMessage (const char *message_, unsigned int _message_\n       ErrorString ((const char *) \" has caused \", 12);\n     }\n   ErrorString ((const char *) message, _message_high);\n-  LineNo.array[0] = ASCII_nl;\n-  LineNo.array[1] = ASCII_nul;\n-  ErrorString ((const char *) &LineNo.array[0], 10);\n+  buffer.array[0] = ASCII_nl;\n+  buffer.array[1] = ASCII_nul;\n+  ErrorString ((const char *) &buffer.array[0], 10);\n   libc_exit (1);\n }\n "}, {"sha": "5db589e259742c2cdc45167aca9289a73a21b272", "filename": "gcc/m2/mc-boot/GM2RTS.h", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fmc-boot%2FGM2RTS.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fmc-boot%2FGM2RTS.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGM2RTS.h?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -126,10 +126,19 @@ EXTERN void M2RTS_HALT (int exitcode) __attribute__ ((noreturn));\n \n /*\n    Halt - provides a more user friendly version of HALT, which takes\n-          four parameters to aid debugging.\n+           four parameters to aid debugging.  It writes an error message\n+           to stderr and calls exit (1).\n */\n \n-EXTERN void M2RTS_Halt (const char *file_, unsigned int _file_high, unsigned int line, const char *function_, unsigned int _function_high, const char *description_, unsigned int _description_high) __attribute__ ((noreturn));\n+EXTERN void M2RTS_Halt (const char *filename_, unsigned int _filename_high, unsigned int line, const char *function_, unsigned int _function_high, const char *description_, unsigned int _description_high) __attribute__ ((noreturn));\n+\n+/*\n+   HaltC - provides a more user friendly version of HALT, which takes\n+           four parameters to aid debugging.  It writes an error message\n+           to stderr and calls exit (1).\n+*/\n+\n+EXTERN void M2RTS_HaltC (void * filename, unsigned int line, void * function, void * description);\n \n /*\n    ExitOnHalt - if HALT is executed then call exit with the exit code, e.\n@@ -141,7 +150,7 @@ EXTERN void M2RTS_ExitOnHalt (int e);\n    ErrorMessage - emits an error message to stderr and then calls exit (1).\n */\n \n-EXTERN void M2RTS_ErrorMessage (const char *message_, unsigned int _message_high, const char *file_, unsigned int _file_high, unsigned int line, const char *function_, unsigned int _function_high) __attribute__ ((noreturn));\n+EXTERN void M2RTS_ErrorMessage (const char *message_, unsigned int _message_high, const char *filename_, unsigned int _filename_high, unsigned int line, const char *function_, unsigned int _function_high) __attribute__ ((noreturn));\n \n /*\n    Length - returns the length of a string, a. This is called whenever"}, {"sha": "6812343de8c75351af6a7e269b2112752f84e6cb", "filename": "gcc/m2/mc-boot/GPushBackInput.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fmc-boot%2FGPushBackInput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fmc-boot%2FGPushBackInput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGPushBackInput.c?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -274,7 +274,7 @@ extern \"C\" char PushBackInput_PutCh (char ch)\n     }\n   else\n     {\n-      Debug_Halt ((const char *) \"max push back stack exceeded, increase MaxPushBackStack\", 55, 150, (const char *) \"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/PushBackInput.mod\", 61);\n+      Debug_Halt ((const char *) \"max push back stack exceeded, increase MaxPushBackStack\", 55, 150, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/PushBackInput.mod\", 54);\n     }\n   return ch;\n   /* static analysis guarentees a RETURN statement will be used before here.  */\n@@ -300,7 +300,7 @@ extern \"C\" void PushBackInput_PutString (const char *a_, unsigned int _a_high)\n       l -= 1;\n       if ((PushBackInput_PutCh (a[l])) != a[l])\n         {\n-          Debug_Halt ((const char *) \"assert failed\", 13, 132, (const char *) \"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/PushBackInput.mod\", 61);\n+          Debug_Halt ((const char *) \"assert failed\", 13, 132, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/PushBackInput.mod\", 54);\n         }\n     }\n }\n@@ -321,7 +321,7 @@ extern \"C\" void PushBackInput_PutStr (DynamicStrings_String s)\n       i -= 1;\n       if ((PushBackInput_PutCh (DynamicStrings_char (s, static_cast<int> (i)))) != (DynamicStrings_char (s, static_cast<int> (i))))\n         {\n-          Debug_Halt ((const char *) \"assert failed\", 13, 113, (const char *) \"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/PushBackInput.mod\", 61);\n+          Debug_Halt ((const char *) \"assert failed\", 13, 113, (const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/PushBackInput.mod\", 54);\n         }\n     }\n }"}, {"sha": "a6aa8069f05d31f71007f733dc3ed8d97d61e18c", "filename": "gcc/m2/mc-boot/GRTExceptions.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fmc-boot%2FGRTExceptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fmc-boot%2FGRTExceptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGRTExceptions.c?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -719,7 +719,7 @@ static void AddHandler (RTExceptions_EHBlock e, RTExceptions_Handler h)\n \n static void indexf (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_indexException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/RTExceptions.mod\")), 612, 9, const_cast<void*> (reinterpret_cast<const void*>(\"indexf\")), const_cast<void*> (reinterpret_cast<const void*>(\"array index out of bounds\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_indexException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 612, 9, const_cast<void*> (reinterpret_cast<const void*>(\"indexf\")), const_cast<void*> (reinterpret_cast<const void*>(\"array index out of bounds\")));\n }\n \n \n@@ -729,7 +729,7 @@ static void indexf (void * a)\n \n static void range (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_rangeException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/RTExceptions.mod\")), 624, 9, const_cast<void*> (reinterpret_cast<const void*>(\"range\")), const_cast<void*> (reinterpret_cast<const void*>(\"assignment out of range\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_rangeException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 624, 9, const_cast<void*> (reinterpret_cast<const void*>(\"range\")), const_cast<void*> (reinterpret_cast<const void*>(\"assignment out of range\")));\n }\n \n \n@@ -739,7 +739,7 @@ static void range (void * a)\n \n static void casef (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_caseSelectException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/RTExceptions.mod\")), 636, 9, const_cast<void*> (reinterpret_cast<const void*>(\"casef\")), const_cast<void*> (reinterpret_cast<const void*>(\"case selector out of range\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_caseSelectException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 636, 9, const_cast<void*> (reinterpret_cast<const void*>(\"casef\")), const_cast<void*> (reinterpret_cast<const void*>(\"case selector out of range\")));\n }\n \n \n@@ -749,7 +749,7 @@ static void casef (void * a)\n \n static void invalidloc (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_invalidLocation)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/RTExceptions.mod\")), 648, 9, const_cast<void*> (reinterpret_cast<const void*>(\"invalidloc\")), const_cast<void*> (reinterpret_cast<const void*>(\"invalid address referenced\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_invalidLocation)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 648, 9, const_cast<void*> (reinterpret_cast<const void*>(\"invalidloc\")), const_cast<void*> (reinterpret_cast<const void*>(\"invalid address referenced\")));\n }\n \n \n@@ -759,7 +759,7 @@ static void invalidloc (void * a)\n \n static void function (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_functionException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/RTExceptions.mod\")), 660, 9, const_cast<void*> (reinterpret_cast<const void*>(\"function\")), const_cast<void*> (reinterpret_cast<const void*>(\"... function ... \")));  /* --fixme-- what has happened ?  */\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_functionException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 660, 9, const_cast<void*> (reinterpret_cast<const void*>(\"function\")), const_cast<void*> (reinterpret_cast<const void*>(\"... function ... \")));  /* --fixme-- what has happened ?  */\n }\n \n \n@@ -769,7 +769,7 @@ static void function (void * a)\n \n static void wholevalue (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_wholeValueException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/RTExceptions.mod\")), 672, 9, const_cast<void*> (reinterpret_cast<const void*>(\"wholevalue\")), const_cast<void*> (reinterpret_cast<const void*>(\"illegal whole value exception\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_wholeValueException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 672, 9, const_cast<void*> (reinterpret_cast<const void*>(\"wholevalue\")), const_cast<void*> (reinterpret_cast<const void*>(\"illegal whole value exception\")));\n }\n \n \n@@ -779,7 +779,7 @@ static void wholevalue (void * a)\n \n static void wholediv (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_wholeDivException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/RTExceptions.mod\")), 684, 9, const_cast<void*> (reinterpret_cast<const void*>(\"wholediv\")), const_cast<void*> (reinterpret_cast<const void*>(\"illegal whole value exception\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_wholeDivException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 684, 9, const_cast<void*> (reinterpret_cast<const void*>(\"wholediv\")), const_cast<void*> (reinterpret_cast<const void*>(\"illegal whole value exception\")));\n }\n \n \n@@ -789,7 +789,7 @@ static void wholediv (void * a)\n \n static void realvalue (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_realValueException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/RTExceptions.mod\")), 696, 9, const_cast<void*> (reinterpret_cast<const void*>(\"realvalue\")), const_cast<void*> (reinterpret_cast<const void*>(\"illegal real value exception\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_realValueException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 696, 9, const_cast<void*> (reinterpret_cast<const void*>(\"realvalue\")), const_cast<void*> (reinterpret_cast<const void*>(\"illegal real value exception\")));\n }\n \n \n@@ -799,7 +799,7 @@ static void realvalue (void * a)\n \n static void realdiv (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_realDivException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/RTExceptions.mod\")), 708, 9, const_cast<void*> (reinterpret_cast<const void*>(\"realdiv\")), const_cast<void*> (reinterpret_cast<const void*>(\"real number division by zero exception\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_realDivException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 708, 9, const_cast<void*> (reinterpret_cast<const void*>(\"realdiv\")), const_cast<void*> (reinterpret_cast<const void*>(\"real number division by zero exception\")));\n }\n \n \n@@ -809,7 +809,7 @@ static void realdiv (void * a)\n \n static void complexvalue (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_complexValueException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/RTExceptions.mod\")), 720, 9, const_cast<void*> (reinterpret_cast<const void*>(\"complexvalue\")), const_cast<void*> (reinterpret_cast<const void*>(\"illegal complex value exception\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_complexValueException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 720, 9, const_cast<void*> (reinterpret_cast<const void*>(\"complexvalue\")), const_cast<void*> (reinterpret_cast<const void*>(\"illegal complex value exception\")));\n }\n \n \n@@ -819,7 +819,7 @@ static void complexvalue (void * a)\n \n static void complexdiv (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_complexDivException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/RTExceptions.mod\")), 732, 9, const_cast<void*> (reinterpret_cast<const void*>(\"complexdiv\")), const_cast<void*> (reinterpret_cast<const void*>(\"complex number division by zero exception\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_complexDivException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 732, 9, const_cast<void*> (reinterpret_cast<const void*>(\"complexdiv\")), const_cast<void*> (reinterpret_cast<const void*>(\"complex number division by zero exception\")));\n }\n \n \n@@ -829,7 +829,7 @@ static void complexdiv (void * a)\n \n static void protection (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_protException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/RTExceptions.mod\")), 744, 9, const_cast<void*> (reinterpret_cast<const void*>(\"protection\")), const_cast<void*> (reinterpret_cast<const void*>(\"protection exception\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_protException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 744, 9, const_cast<void*> (reinterpret_cast<const void*>(\"protection\")), const_cast<void*> (reinterpret_cast<const void*>(\"protection exception\")));\n }\n \n \n@@ -839,7 +839,7 @@ static void protection (void * a)\n \n static void systemf (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_sysException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/RTExceptions.mod\")), 756, 9, const_cast<void*> (reinterpret_cast<const void*>(\"systemf\")), const_cast<void*> (reinterpret_cast<const void*>(\"system exception\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_sysException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 756, 9, const_cast<void*> (reinterpret_cast<const void*>(\"systemf\")), const_cast<void*> (reinterpret_cast<const void*>(\"system exception\")));\n }\n \n \n@@ -849,7 +849,7 @@ static void systemf (void * a)\n \n static void coroutine (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_coException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/RTExceptions.mod\")), 768, 9, const_cast<void*> (reinterpret_cast<const void*>(\"coroutine\")), const_cast<void*> (reinterpret_cast<const void*>(\"coroutine exception\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_coException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 768, 9, const_cast<void*> (reinterpret_cast<const void*>(\"coroutine\")), const_cast<void*> (reinterpret_cast<const void*>(\"coroutine exception\")));\n }\n \n \n@@ -859,7 +859,7 @@ static void coroutine (void * a)\n \n static void exception (void * a)\n {\n-  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_exException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/RTExceptions.mod\")), 780, 9, const_cast<void*> (reinterpret_cast<const void*>(\"exception\")), const_cast<void*> (reinterpret_cast<const void*>(\"exception exception\")));\n+  RTExceptions_Raise ( ((unsigned int) (M2EXCEPTION_exException)), const_cast<void*> (reinterpret_cast<const void*>(\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\")), 780, 9, const_cast<void*> (reinterpret_cast<const void*>(\"exception\")), const_cast<void*> (reinterpret_cast<const void*>(\"exception exception\")));\n }\n \n \n@@ -1178,13 +1178,13 @@ extern \"C\" RTExceptions_EHBlock RTExceptions_GetBaseExceptionBlock (void)\n {\n   if (currentEHB == NULL)\n     {\n-      M2RTS_Halt ((const char *) \"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/RTExceptions.mod\", 60, 598, (const char *) \"GetBaseExceptionBlock\", 21, (const char *) \"currentEHB has not been initialized yet\", 39);\n+      M2RTS_Halt ((const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.mod\", 53, 598, (const char *) \"GetBaseExceptionBlock\", 21, (const char *) \"currentEHB has not been initialized yet\", 39);\n     }\n   else\n     {\n       return currentEHB;\n     }\n-  ReturnException (\"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/RTExceptions.def\", 25, 1);\n+  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/RTExceptions.def\", 25, 1);\n   __builtin_unreachable ();\n }\n "}, {"sha": "d8cac277252bafe1dbb05a144fc83508137a2e82", "filename": "gcc/m2/mc-boot/GRTint.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fmc-boot%2FGRTint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a30acf3e50b0757a7e82cebf24e379906ce92d/gcc%2Fm2%2Fmc-boot%2FGRTint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fmc-boot%2FGRTint.c?ref=d0a30acf3e50b0757a7e82cebf24e379906ce92d", "patch": "@@ -595,7 +595,7 @@ static unsigned int activatePending (unsigned int untilInterrupt, RTint_Dispatch\n \n \n               default:\n-                CaseException (\"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/RTint.def\", 25, 1);\n+                CaseException (\"../../gcc-read-write/gcc/m2/gm2-libs/RTint.def\", 25, 1);\n                 __builtin_unreachable ();\n             }\n           v = v->pending;\n@@ -708,7 +708,7 @@ extern \"C\" unsigned int RTint_InitOutputVector (int fd, unsigned int pri)\n       RTco_signal (lock);\n       return v->no;\n     }\n-  ReturnException (\"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/RTint.def\", 25, 1);\n+  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/RTint.def\", 25, 1);\n   __builtin_unreachable ();\n }\n \n@@ -765,7 +765,7 @@ extern \"C\" void RTint_ReArmTimeVector (unsigned int vec, unsigned int micro, uns\n   v = FindVectorNo (vec);\n   if (v == NULL)\n     {\n-      M2RTS_Halt ((const char *) \"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/RTint.mod\", 53, 286, (const char *) \"ReArmTimeVector\", 15, (const char *) \"cannot find vector supplied\", 27);\n+      M2RTS_Halt ((const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/RTint.mod\", 46, 286, (const char *) \"ReArmTimeVector\", 15, (const char *) \"cannot find vector supplied\", 27);\n     }\n   else\n     {\n@@ -790,7 +790,7 @@ extern \"C\" void RTint_GetTimeVector (unsigned int vec, unsigned int *micro, unsi\n   v = FindVectorNo (vec);\n   if (v == NULL)\n     {\n-      M2RTS_Halt ((const char *) \"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/RTint.mod\", 53, 312, (const char *) \"GetTimeVector\", 13, (const char *) \"cannot find vector supplied\", 27);\n+      M2RTS_Halt ((const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/RTint.mod\", 46, 312, (const char *) \"GetTimeVector\", 13, (const char *) \"cannot find vector supplied\", 27);\n     }\n   else\n     {\n@@ -816,7 +816,7 @@ extern \"C\" void * RTint_AttachVector (unsigned int vec, void * p)\n   v = FindVectorNo (vec);\n   if (v == NULL)\n     {\n-      M2RTS_Halt ((const char *) \"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/RTint.mod\", 53, 339, (const char *) \"AttachVector\", 12, (const char *) \"cannot find vector supplied\", 27);\n+      M2RTS_Halt ((const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/RTint.mod\", 46, 339, (const char *) \"AttachVector\", 12, (const char *) \"cannot find vector supplied\", 27);\n     }\n   else\n     {\n@@ -830,7 +830,7 @@ extern \"C\" void * RTint_AttachVector (unsigned int vec, void * p)\n       RTco_signal (lock);\n       return l;\n     }\n-  ReturnException (\"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/RTint.def\", 25, 1);\n+  ReturnException (\"../../gcc-read-write/gcc/m2/gm2-libs/RTint.def\", 25, 1);\n   __builtin_unreachable ();\n }\n \n@@ -855,7 +855,7 @@ extern \"C\" void RTint_IncludeVector (unsigned int vec)\n       v = FindVectorNo (vec);\n       if (v == NULL)\n         {\n-          M2RTS_Halt ((const char *) \"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/RTint.mod\", 53, 372, (const char *) \"IncludeVector\", 13, (const char *) \"cannot find vector supplied\", 27);\n+          M2RTS_Halt ((const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/RTint.mod\", 46, 372, (const char *) \"IncludeVector\", 13, (const char *) \"cannot find vector supplied\", 27);\n         }\n       else\n         {\n@@ -902,7 +902,7 @@ extern \"C\" void RTint_ExcludeVector (unsigned int vec)\n   v = FindPendingVector (vec);\n   if (v == NULL)\n     {\n-      M2RTS_Halt ((const char *) \"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/RTint.mod\", 53, 415, (const char *) \"ExcludeVector\", 13, (const char *) \"cannot find pending vector supplied\", 35);\n+      M2RTS_Halt ((const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/RTint.mod\", 46, 415, (const char *) \"ExcludeVector\", 13, (const char *) \"cannot find pending vector supplied\", 35);\n     }\n   else\n     {\n@@ -1003,7 +1003,7 @@ extern \"C\" void RTint_Listen (unsigned int untilInterrupt, RTint_DispatchVector\n \n \n                   default:\n-                    CaseException (\"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/RTint.def\", 25, 1);\n+                    CaseException (\"../../gcc-read-write/gcc/m2/gm2-libs/RTint.def\", 25, 1);\n                     __builtin_unreachable ();\n                 }\n               v = v->pending;\n@@ -1016,7 +1016,7 @@ extern \"C\" void RTint_Listen (unsigned int untilInterrupt, RTint_DispatchVector\n         }\n       if (((untilInterrupt && (i == NULL)) && (o == NULL)) && ! found)\n         {\n-          M2RTS_Halt ((const char *) \"../../gcc-git-devel-modula2/gcc/m2/gm2-libs/RTint.mod\", 53, 731, (const char *) \"Listen\", 6, (const char *) \"deadlock found, no more processes to run and no interrupts active\", 65);\n+          M2RTS_Halt ((const char *) \"../../gcc-read-write/gcc/m2/gm2-libs/RTint.mod\", 46, 731, (const char *) \"Listen\", 6, (const char *) \"deadlock found, no more processes to run and no interrupts active\", 65);\n         }\n       /* printf('}\n       ') ;  */"}]}