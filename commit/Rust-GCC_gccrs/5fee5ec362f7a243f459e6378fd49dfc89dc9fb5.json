{"sha": "5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "node_id": "C_kwDOANBUbNoAKDVmZWU1ZWMzNjJmN2EyNDNmNDU5ZTYzNzhmZDQ5ZGZjODlkYzlmYjU", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2019-06-18T18:42:10Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-11-30T15:53:28Z"}, "message": "d: Import dmd b8384668f, druntime e6caaab9, phobos 5ab9ad256 (v2.098.0-beta.1)\n\nThe D front-end is now itself written in D, in order to build GDC, you\nwill need a working GDC compiler (GCC version 9.1 or later).\n\nGCC changes:\n\n    - Add support for bootstrapping the D front-end.\n\nThese add the required components in order to have a D front-end written\nin D itself.  Because the compiler front-end only depends on the core\nruntime modules, only libdruntime is built for the bootstrap stages.\n\nD front-end changes:\n\n    - Import dmd v2.098.0-beta.1.\n\nDruntime changes:\n\n    - Import druntime v2.098.0-beta.1.\n\nPhobos changes:\n\n    - Import phobos v2.098.0-beta.1.\n\nThe jump from v2.076.1 to v2.098.0 covers nearly 4 years worth of\ndevelopment on the D programming language and run-time libraries.\n\nChangeLog:\n\n\t* Makefile.def: Add bootstrap to libbacktrace, libphobos, zlib, and\n\tlibatomic.\n\t* Makefile.in: Regenerate.\n\t* Makefile.tpl (POSTSTAGE1_HOST_EXPORTS): Fix command for GDC.\n\t(STAGE1_CONFIGURE_FLAGS): Add --with-libphobos-druntime-only if\n\ttarget-libphobos-bootstrap.\n\t(STAGE2_CONFIGURE_FLAGS): Likewise.\n\t* configure: Regenerate.\n\t* configure.ac: Add support for bootstrapping D front-end.\n\nconfig/ChangeLog:\n\n\t* acx.m4 (ACX_PROG_GDC): New m4 function.\n\ngcc/ChangeLog:\n\n\t* Makefile.in (GDC): New variable.\n\t(GDCFLAGS): New variable.\n\t* configure: Regenerate.\n\t* configure.ac: Add call to ACX_PROG_GDC.  Substitute GDCFLAGS.\n\ngcc/d/ChangeLog:\n\n\t* dmd/MERGE: Merge upstream dmd b8384668f.\n\t* Make-lang.in (d-warn): Use strict warnings.\n\t(DMD_WARN_CXXFLAGS): Remove.\n\t(DMD_COMPILE): Remove.\n\t(CHECKING_DFLAGS): Define.\n\t(WARN_DFLAGS): Define.\n\t(ALL_DFLAGS): Define.\n\t(DCOMPILE.base): Define.\n\t(DCOMPILE): Define.\n\t(DPOSTCOMPILE): Define.\n\t(DLINKER): Define.\n\t(DLLINKER): Define.\n\t(D_FRONTEND_OBJS): Add new dmd front-end objects.\n\t(D_GENERATED_SRCS): Remove.\n\t(D_GENERATED_OBJS): Remove.\n\t(D_ALL_OBJS): Remove D_GENERATED_OBJS.\n\t(d21$(exeext)): Build using DLLINKER and -static-libphobos.\n\t(d.tags): Remove dmd/*.c and dmd/root/*.c.\n\t(d.mostlyclean): Remove D_GENERATED_SRCS, d/idgen$(build_exeext),\n\td/impcnvgen$(build_exeext).\n\t(D_INCLUDES): Include $(srcdir)/d/dmd/res.\n\t(CFLAGS-d/id.o): Remove.\n\t(CFLAGS-d/impcnvtab.o): Remove.\n\t(d/%.o): Build using DCOMPILE and DPOSTCOMPILE.  Update dependencies\n\tfrom d/dmd/%.c to d/dmd/%.d.\n\t(d/idgen$(build_exeext)): Remove.\n\t(d/impcnvgen$(build_exeext)): Remove.\n\t(d/id.c): Remove.\n\t(d/id.h): Remove.\n\t(d/impcnvtab.c): Remove.\n\t(d/%.dmdgen.o): Remove.\n\t(D_SYSTEM_H): Remove.\n\t(d/idgen.dmdgen.o): Remove.\n\t(d/impcnvgen.dmdgen.o): Remove.\n\t* config-lang.in (boot_language): New variable.\n\t* d-attribs.cc: Include dmd/expression.h.\n\t* d-builtins.cc: Include d-frontend.h.\n\t(build_frontend_type): Update for new front-end interface.\n\t(d_eval_constant_expression): Likewise.\n\t(d_build_builtins_module): Likewise.\n\t(maybe_set_builtin_1): Likewise.\n\t(d_build_d_type_nodes): Likewise.\n\t* d-codegen.cc (d_decl_context): Likewise.\n\t(declaration_reference_p): Likewise.\n\t(declaration_type): Likewise.\n\t(parameter_reference_p): Likewise.\n\t(parameter_type): Likewise.\n\t(get_array_length): Likewise.\n\t(build_delegate_cst): Likewise.\n\t(build_typeof_null_value): Likewise.\n\t(identity_compare_p): Likewise.\n\t(lower_struct_comparison): Likewise.\n\t(build_filename_from_loc): Likewise.\n\t(build_assert_call): Remove LIBCALL_SWITCH_ERROR.\n\t(build_bounds_index_condition): Call LIBCALL_ARRAYBOUNDS_INDEXP on\n\tbounds error.\n\t(build_bounds_slice_condition): Call LIBCALL_ARRAYBOUNDS_SLICEP on\n\tbounds error.\n\t(array_bounds_check): Update for new front-end interface.\n\t(checkaction_trap_p): Handle CHECKACTION_context.\n\t(get_function_type): Update for new front-end interface.\n\t(d_build_call): Likewise.\n\t* d-compiler.cc: Remove include of dmd/scope.h.\n\t(Compiler::genCmain): Remove.\n\t(Compiler::paintAsType): Update for new front-end interface.\n\t(Compiler::onParseModule): Likewise.\n\t* d-convert.cc (convert_expr): Remove call to LIBCALL_ARRAYCAST.\n\t(convert_for_rvalue): Update for new front-end interface.\n\t(convert_for_assignment): Likewise.\n\t(convert_for_condition): Likewise.\n\t(d_array_convert): Likewise.\n\t* d-diagnostic.cc (error): Remove.\n\t(errorSupplemental): Remove.\n\t(warning): Remove.\n\t(warningSupplemental): Remove.\n\t(deprecation): Remove.\n\t(deprecationSupplemental): Remove.\n\t(message): Remove.\n\t(vtip): New.\n\t* d-frontend.cc (global): Remove.\n\t(Global::_init): Remove.\n\t(Global::startGagging): Remove.\n\t(Global::endGagging): Remove.\n\t(Global::increaseErrorCount): Remove.\n\t(Loc::Loc): Remove.\n\t(Loc::toChars): Remove.\n\t(Loc::equals): Remove.\n\t(isBuiltin): Update for new front-end interface.\n\t(eval_builtin): Likewise.\n\t(getTypeInfoType): Likewise.\n\t(inlineCopy): Remove.\n\t* d-incpath.cc: Include d-frontend.h.\n\t(add_globalpaths): Call d_gc_malloc to allocate Strings.\n\t(add_filepaths): Likewise.\n\t* d-lang.cc: Include dmd/id.h, dmd/root/file.h, d-frontend.h.  Remove\n\tinclude of dmd/mars.h, id.h.\n\t(entrypoint_module): Remove.\n\t(entrypoint_root_module): Remove.\n\t(deps_write_string): Update for new front-end interface.\n\t(deps_write): Likewise.\n\t(d_init_options): Call rt_init.  Remove setting global params that are\n\tdefault initialized by the front-end.\n\t(d_handle_option): Handle OPT_fcheckaction_, OPT_fdump_c___spec_,\n\tOPT_fdump_c___spec_verbose, OPT_fextern_std_, OPT_fpreview,\n\tOPT_revert, OPT_fsave_mixins_, and OPT_ftransition.\n\t(d_post_options): Propagate dip1021 and dip1000 preview flags to\n\tdip25, and flag_diagnostics_show_caret to printErrorContext.\n\t(d_add_entrypoint_module): Remove.\n\t(d_parse_file): Update for new front-end interface.\n\t(d_type_promotes_to): Likewise.\n\t(d_types_compatible_p): Likewise.\n\t* d-longdouble.cc (CTFloat::zero): Remove.\n\t(CTFloat::one): Remove.\n\t(CTFloat::minusone): Remove.\n\t(CTFloat::half): Remove.\n\t* d-system.h (POSIX): Remove.\n\t(realpath): Remove.\n\t(isalpha): Remove.\n\t(isalnum): Remove.\n\t(isdigit): Remove.\n\t(islower): Remove.\n\t(isprint): Remove.\n\t(isspace): Remove.\n\t(isupper): Remove.\n\t(isxdigit): Remove.\n\t(tolower): Remove.\n\t(_mkdir): Remove.\n\t(INT32_MAX): Remove.\n\t(INT32_MIN): Remove.\n\t(INT64_MIN): Remove.\n\t(UINT32_MAX): Remove.\n\t(UINT64_MAX): Remove.\n\t* d-target.cc: Include calls.h.\n\t(target): Remove.\n\t(define_float_constants): Remove initialization of snan.\n\t(Target::_init): Update for new front-end interface.\n\t(Target::isVectorTypeSupported): Likewise.\n\t(Target::isVectorOpSupported): Remove cases for unordered operators.\n\t(TargetCPP::typeMangle): Update for new front-end interface.\n\t(TargetCPP::parameterType): Likewise.\n\t(Target::systemLinkage): Likewise.\n\t(Target::isReturnOnStack): Likewise.\n\t(Target::isCalleeDestroyingArgs): Define.\n\t(Target::preferPassByRef): Define.\n\t* d-tree.h (d_add_entrypoint_module): Remove.\n\t* decl.cc (gcc_attribute_p): Update for new front-end interface.\n\t(apply_pragma_crt): Define.\n\t(DeclVisitor::visit(PragmaDeclaration *)): Handle pragmas\n\tcrt_constructor and crt_destructor.\n\t(DeclVisitor::visit(TemplateDeclaration *)): Update for new front-end\n\tinterface.\n\t(DeclVisitor::visit): Likewise.\n\t(DeclVisitor::finish_vtable): Likewise.\n\t(get_symbol_decl): Error if template has more than one nesting\n\tcontext.  Update for new front-end interface.\n\t(make_thunk): Update for new front-end interface.\n\t(get_vtable_decl): Likewise.\n\t* expr.cc (ExprVisitor::visit): Likewise.\n\t(build_return_dtor): Likewise.\n\t* imports.cc (ImportVisitor::visit): Likewise.\n\t* intrinsics.cc: Include dmd/expression.h.  Remove include of\n\tdmd/mangle.h.\n\t(maybe_set_intrinsic): Update for new front-end interface.\n\t* intrinsics.def (INTRINSIC_ROL): Update intrinsic signature.\n\t(INTRINSIC_ROR): Likewise.\n\t(INTRINSIC_ROR_TIARG): Likewise.\n\t(INTRINSIC_TOPREC): Likewise.\n\t(INTRINSIC_TOPRECL): Likewise.\n\t(INTRINSIC_TAN): Update intrinsic module and signature.\n\t(INTRINSIC_ISNAN): Likewise.\n\t(INTRINSIC_ISFINITE): Likewise.\n\t(INTRINSIC_COPYSIGN): Define intrinsic.\n\t(INTRINSIC_COPYSIGNI): Define intrinsic.\n\t(INTRINSIC_EXP): Update intrinsic module.\n\t(INTRINSIC_EXPM1): Likewise.\n\t(INTRINSIC_EXP2): Likewise.\n\t(INTRINSIC_LOG): Likewise.\n\t(INTRINSIC_LOG2): Likewise.\n\t(INTRINSIC_LOG10): Likewise.\n\t(INTRINSIC_POW): Likewise.\n\t(INTRINSIC_ROUND): Likewise.\n\t(INTRINSIC_FLOORF): Likewise.\n\t(INTRINSIC_FLOOR): Likewise.\n\t(INTRINSIC_FLOORL): Likewise.\n\t(INTRINSIC_CEILF): Likewise.\n\t(INTRINSIC_CEIL): Likewise.\n\t(INTRINSIC_CEILL): Likewise.\n\t(INTRINSIC_TRUNC): Likewise.\n\t(INTRINSIC_FMIN): Likewise.\n\t(INTRINSIC_FMAX): Likewise.\n\t(INTRINSIC_FMA): Likewise.\n\t(INTRINSIC_VA_ARG): Update intrinsic signature.\n\t(INTRINSIC_VASTART): Likewise.\n\t* lang.opt (fcheck=): Add alternate aliases for contract switches.\n\t(fcheckaction=): New option.\n\t(check_action): New Enum and EnumValue entries.\n\t(fdump-c++-spec-verbose): New option.\n\t(fdump-c++-spec=): New option.\n\t(fextern-std=): New option.\n\t(extern_stdcpp): New Enum and EnumValue entries\n\t(fpreview=): New options.\n\t(frevert=): New options.\n\t(fsave-mixins): New option.\n\t(ftransition=): Update options.\n\t* modules.cc (get_internal_fn): Replace Prot with Visibility.\n\t(build_internal_fn): Likewise.\n\t(build_dso_cdtor_fn): Likewise.\n\t(build_module_tree): Remove check for __entrypoint module.\n\t* runtime.def (P5): Define.\n\t(ARRAYBOUNDS_SLICEP): Define.\n\t(ARRAYBOUNDS_INDEXP): Define.\n\t(NEWTHROW): Define.\n\t(ADCMP2): Remove.\n\t(ARRAYCAST): Remove.\n\t(SWITCH_STRING): Remove.\n\t(SWITCH_USTRING): Remove.\n\t(SWITCH_DSTRING): Remove.\n\t(SWITCH_ERROR): Remove.\n\t* toir.cc (IRVisitor::visit): Update for new front-end interface.\n\t(IRVisitor::check_previous_goto): Remove checks for case and default\n\tstatements.\n\t(IRVisitor::visit(SwitchStatement *)): Remove handling of string\n\tswitch conditions.\n\t* typeinfo.cc: Include d-frontend.h.\n\t(get_typeinfo_kind): Update for new front-end interface.\n\t(make_frontend_typeinfo): Likewise.\n\t(TypeInfoVisitor::visit): Likewise.\n\t(builtin_typeinfo_p): Likewise.\n\t(get_typeinfo_decl): Likewise.\n\t(build_typeinfo): Likewise.\n\t* types.cc (valist_array_p): Likewise.\n\t(make_array_type): Likewise.\n\t(merge_aggregate_types): Likewise.\n\t(TypeVisitor::visit(TypeBasic *)): Likewise.\n\t(TypeVisitor::visit(TypeFunction *)): Likewise.\n\t(TypeVisitor::visit(TypeStruct *)): Update comment.\n\t* verstr.h: Removed.\n\t* d-frontend.h: New file.\n\ngcc/po/ChangeLog:\n\n\t* EXCLUDES: Remove d/dmd sources from list.\n\ngcc/testsuite/ChangeLog:\n\n\t* gdc.dg/Wcastresult2.d: Update test.\n\t* gdc.dg/asm1.d: Likewise.\n\t* gdc.dg/asm2.d: Likewise.\n\t* gdc.dg/asm3.d: Likewise.\n\t* gdc.dg/gdc282.d: Likewise.\n\t* gdc.dg/imports/gdc170.d: Likewise.\n\t* gdc.dg/intrinsics.d: Likewise.\n\t* gdc.dg/pr101672.d: Likewise.\n\t* gdc.dg/pr90650a.d: Likewise.\n\t* gdc.dg/pr90650b.d: Likewise.\n\t* gdc.dg/pr94777a.d: Likewise.\n\t* gdc.dg/pr95250.d: Likewise.\n\t* gdc.dg/pr96869.d: Likewise.\n\t* gdc.dg/pr98277.d: Likewise.\n\t* gdc.dg/pr98457.d: Likewise.\n\t* gdc.dg/simd1.d: Likewise.\n\t* gdc.dg/simd2a.d: Likewise.\n\t* gdc.dg/simd2b.d: Likewise.\n\t* gdc.dg/simd2c.d: Likewise.\n\t* gdc.dg/simd2d.d: Likewise.\n\t* gdc.dg/simd2e.d: Likewise.\n\t* gdc.dg/simd2f.d: Likewise.\n\t* gdc.dg/simd2g.d: Likewise.\n\t* gdc.dg/simd2h.d: Likewise.\n\t* gdc.dg/simd2i.d: Likewise.\n\t* gdc.dg/simd2j.d: Likewise.\n\t* gdc.dg/simd7951.d: Likewise.\n\t* gdc.dg/torture/gdc309.d: Likewise.\n\t* gdc.dg/torture/pr94424.d: Likewise.\n\t* gdc.dg/torture/pr94777b.d: Likewise.\n\t* lib/gdc-utils.exp (gdc-convert-args): Handle new compiler options.\n\t(gdc-convert-test): Handle CXXFLAGS, EXTRA_OBJC_SOURCES, and ARG_SETS\n\ttest directives.\n\t(gdc-do-test): Only import modules in the test run directory.\n\t* gdc.dg/pr94777c.d: New test.\n\t* gdc.dg/pr96156b.d: New test.\n\t* gdc.dg/pr96157c.d: New test.\n\t* gdc.dg/simd_ctfe.d: New test.\n\t* gdc.dg/torture/simd17344.d: New test.\n\t* gdc.dg/torture/simd20052.d: New test.\n\t* gdc.dg/torture/simd6.d: New test.\n\t* gdc.dg/torture/simd7.d: New test.\n\nlibphobos/ChangeLog:\n\n\t* libdruntime/MERGE: Merge upstream druntime e6caaab9.\n\t* libdruntime/Makefile.am (D_EXTRA_FLAGS): Build libdruntime with\n\t-fpreview=dip1000, -fpreview=fieldwise, and -fpreview=dtorfields.\n\t(ALL_DRUNTIME_SOURCES): Add DRUNTIME_DSOURCES_STDCXX.\n\t(DRUNTIME_DSOURCES): Update list of C binding modules.\n\t(DRUNTIME_DSOURCES_STDCXX): Likewise.\n\t(DRUNTIME_DSOURCES_LINUX): Likewise.\n\t(DRUNTIME_DSOURCES_OPENBSD): Likewise.\n\t(DRUNTIME_DISOURCES): Remove __entrypoint.di.\n\t* libdruntime/Makefile.in: Regenerated.\n\t* libdruntime/__entrypoint.di: Removed.\n\t* libdruntime/gcc/deh.d (_d_isbaseof): Update signature.\n\t(_d_createTrace): Likewise.\n\t(__gdc_begin_catch): Remove reference to the exception.\n\t(_d_throw): Increment reference count of thrown object before unwind.\n\t(__gdc_personality): Chain exceptions with  Throwable.chainTogether.\n\t* libdruntime/gcc/emutls.d: Update imports.\n\t* libdruntime/gcc/sections/elf.d: Update imports.\n\t(DSO.moduleGroup): Update signature.\n\t* libdruntime/gcc/sections/macho.d: Update imports.\n\t(DSO.moduleGroup): Update signature.\n\t* libdruntime/gcc/sections/pecoff.d: Update imports.\n\t(DSO.moduleGroup): Update signature.\n\t* src/MERGE: Merge upstream phobos 5ab9ad256.\n\t* src/Makefile.am (D_EXTRA_DFLAGS): Add -fpreview=dip1000 and\n\t-fpreview=dtorfields flags.\n\t(PHOBOS_DSOURCES): Update list of std modules.\n\t* src/Makefile.in: Regenerate.\n\t* testsuite/lib/libphobos.exp (libphobos-dg-test): Handle assembly\n\tcompile types.\n\t(dg-test): Override.\n\t(additional_prunes): Define.\n\t(libphobos-dg-prune): Filter any additional_prunes set by tests.\n\t* testsuite/libphobos.aa/test_aa.d: Update test.\n\t* testsuite/libphobos.druntime/druntime.exp (version_flags): Add\n\t-fversion=CoreUnittest.\n\t* testsuite/libphobos.druntime_shared/druntime_shared.exp\n\t(version_flags): Add -fversion=CoreUnittest -fversion=Shared.\n\t* testsuite/libphobos.exceptions/unknown_gc.d: Update test.\n\t* testsuite/libphobos.hash/test_hash.d: Update test.\n\t* testsuite/libphobos.phobos/phobos.exp (version_flags): Add\n\t-fversion=StdUnittest\n\t* testsuite/libphobos.phobos_shared/phobos_shared.exp (version_flags):\n\tLikewise.\n\t* testsuite/libphobos.shared/host.c: Update test.\n\t* testsuite/libphobos.shared/load.d: Update test.\n\t* testsuite/libphobos.shared/load_13414.d: Update test.\n\t* testsuite/libphobos.thread/fiber_guard_page.d: Update test.\n\t* testsuite/libphobos.thread/tlsgc_sections.d: Update test.\n\t* testsuite/testsuite_flags.in: Add -fpreview=dip1000 to --gdcflags.\n\t* testsuite/libphobos.shared/link_mod_collision.d: Removed.\n\t* testsuite/libphobos.shared/load_mod_collision.d: Removed.\n\t* testsuite/libphobos.betterc/betterc.exp: New test.\n\t* testsuite/libphobos.config/config.exp: New test.\n\t* testsuite/libphobos.gc/gc.exp: New test.\n\t* testsuite/libphobos.imports/imports.exp: New test.\n\t* testsuite/libphobos.lifetime/lifetime.exp: New test.\n\t* testsuite/libphobos.unittest/unittest.exp: New test.", "tree": {"sha": "61d1bdbca854a903c0860406f457f06b2040be7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61d1bdbca854a903c0860406f457f06b2040be7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3f60112edcb85b459e60f66c44a55138b1cef49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3f60112edcb85b459e60f66c44a55138b1cef49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3f60112edcb85b459e60f66c44a55138b1cef49"}], "stats": {"total": 554864, "additions": 349907, "deletions": 204957}, "files": [{"sha": "4e2087fbcfae3c4a318757b5e4286dc50e536d73", "filename": "Makefile.def", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/Makefile.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/Makefile.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.def?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -169,14 +169,14 @@ target_modules = { module= newlib; };\n target_modules = { module= libgcc; bootstrap=true; no_check=true;\n \t\t  missing=TAGS;\n \t\t  missing=install-dvi; };\n-target_modules = { module= libbacktrace; };\n+target_modules = { module= libbacktrace; bootstrap=true; };\n target_modules = { module= libquadmath; };\n target_modules = { module= libgfortran; };\n target_modules = { module= libobjc;\n \t\t  missing=TAGS;\n \t\t  missing=install-dvi; };\n target_modules = { module= libgo; };\n-target_modules = { module= libphobos;\n+target_modules = { module= libphobos; bootstrap=true;\n \t\t   lib_path=src/.libs; };\n target_modules = { module= libtermcap; no_check=true;\n                    missing=mostlyclean;\n@@ -186,12 +186,12 @@ target_modules = { module= libtermcap; no_check=true;\n target_modules = { module= winsup; };\n target_modules = { module= libgloss; no_check=true; };\n target_modules = { module= libffi; no_install=true; };\n-target_modules = { module= zlib; };\n+target_modules = { module= zlib; bootstrap=true; };\n target_modules = { module= rda; };\n target_modules = { module= libada; };\n target_modules = { module= libgomp; bootstrap= true; lib_path=.libs; };\n target_modules = { module= libitm; lib_path=.libs; };\n-target_modules = { module= libatomic; lib_path=.libs; };\n+target_modules = { module= libatomic; bootstrap=true; lib_path=.libs; };\n \n // These are (some of) the make targets to be done in each subdirectory.\n // Not all; these are the ones which don't have special options."}, {"sha": "0f18c67120a5b54f2cb1d9b09fce1be05be5b5a7", "filename": "Makefile.in", "status": "modified", "additions": 3620, "deletions": 351, "changes": 3971, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/Makefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/Makefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.in?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "21fece892805d8d8d160183cbb0c472dbef61d52", "filename": "Makefile.tpl", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/Makefile.tpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/Makefile.tpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.tpl?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -276,11 +276,14 @@ POSTSTAGE1_HOST_EXPORTS = \\\n \t$(POSTSTAGE1_CXX_EXPORT) \\\n \t$(LTO_EXPORTS) \\\n \tGDC=\"$$r/$(HOST_SUBDIR)/prev-gcc/gdc$(exeext) -B$$r/$(HOST_SUBDIR)/prev-gcc/ \\\n-\t  -B$(build_tooldir)/bin/ $(GDC_FLAGS_FOR_TARGET) \\\n+\t  -B$(build_tooldir)/bin/ $(GDCFLAGS_FOR_TARGET) \\\n+\t  -B$$r/prev-$(TARGET_SUBDIR)/libphobos/libdruntime/gcc \\\n \t  -B$$r/prev-$(TARGET_SUBDIR)/libphobos/src \\\n+\t  -B$$r/prev-$(TARGET_SUBDIR)/libphobos/src/.libs \\\n \t  -I$$r/prev-$(TARGET_SUBDIR)/libphobos/libdruntime -I$$s/libphobos/libdruntime \\\n \t  -L$$r/prev-$(TARGET_SUBDIR)/libphobos/src/.libs \\\n-\t  -L$$r/prev-$(TARGET_SUBDIR)/libphobos/libdruntime/.libs\"; \\\n+\t  -B$$r/prev-$(TARGET_SUBDIR)/libstdc++-v3/src/.libs \\\n+\t  -L$$r/prev-$(TARGET_SUBDIR)/libstdc++-v3/src/.libs\"; \\\n \texport GDC; \\\n \tGDC_FOR_BUILD=\"$$GDC\"; export GDC_FOR_BUILD; \\\n \tGNATBIND=\"$$r/$(HOST_SUBDIR)/prev-gcc/gnatbind\"; export GNATBIND; \\\n@@ -487,6 +490,11 @@ STAGE1_CONFIGURE_FLAGS = --disable-intermodule $(STAGE1_CHECKING) \\\n \t  --disable-coverage --enable-languages=\"$(STAGE1_LANGUAGES)\" \\\n \t  --disable-build-format-warnings\n \n+@if target-libphobos-bootstrap\n+STAGE1_CONFIGURE_FLAGS += --with-libphobos-druntime-only\n+STAGE2_CONFIGURE_FLAGS += --with-libphobos-druntime-only\n+@endif target-libphobos-bootstrap\n+\n # When using the slow stage1 compiler disable IL verification and forcefully\n # enable it when using the stage2 compiler instead.  As we later compare\n # stage2 and stage3 we are merely avoid doing redundant work, plus we apply"}, {"sha": "3c65d820628f9586da666361434d38c4a93febfa", "filename": "config/acx.m4", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/config%2Facx.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/config%2Facx.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Facx.m4?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -420,6 +420,18 @@ else\n fi\n ])\n \n+# Test for D.\n+AC_DEFUN([ACX_PROG_GDC],\n+[AC_REQUIRE([AC_CHECK_TOOL_PREFIX])\n+AC_REQUIRE([AC_PROG_CC])\n+AC_CHECK_TOOL(GDC, gdc, no)\n+if test \"x$GDC\" != xno; then\n+  have_gdc=yes\n+else\n+  have_gdc=no\n+fi\n+])\n+\n dnl 'make compare' can be significantly faster, if cmp itself can\n dnl skip bytes instead of using tail.  The test being performed is\n dnl \"if cmp --ignore-initial=2 t1 t2 && ! cmp --ignore-initial=1 t1 t2\""}, {"sha": "f8e6e2c3020857d8f04e70e2fcbed6f44f881acf", "filename": "configure", "status": "modified", "additions": 132, "deletions": 1, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -619,6 +619,7 @@ GFORTRAN_FOR_TARGET\n GCC_FOR_TARGET\n CXX_FOR_TARGET\n CC_FOR_TARGET\n+GDCFLAGS\n READELF\n OTOOL\n OBJDUMP\n@@ -702,6 +703,7 @@ gmplibs\n HAVE_CXX11_FOR_BUILD\n HAVE_CXX11\n do_compare\n+GDC\n GNATMAKE\n GNATBIND\n ac_ct_CXX\n@@ -5625,6 +5627,106 @@ else\n   have_gnat=no\n fi\n \n+\n+\n+if test -n \"$ac_tool_prefix\"; then\n+  # Extract the first word of \"${ac_tool_prefix}gdc\", so it can be a program name with args.\n+set dummy ${ac_tool_prefix}gdc; ac_word=$2\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\n+$as_echo_n \"checking for $ac_word... \" >&6; }\n+if ${ac_cv_prog_GDC+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  if test -n \"$GDC\"; then\n+  ac_cv_prog_GDC=\"$GDC\" # Let the user override the test.\n+else\n+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\n+for as_dir in $PATH\n+do\n+  IFS=$as_save_IFS\n+  test -z \"$as_dir\" && as_dir=.\n+    for ac_exec_ext in '' $ac_executable_extensions; do\n+  if as_fn_executable_p \"$as_dir/$ac_word$ac_exec_ext\"; then\n+    ac_cv_prog_GDC=\"${ac_tool_prefix}gdc\"\n+    $as_echo \"$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext\" >&5\n+    break 2\n+  fi\n+done\n+  done\n+IFS=$as_save_IFS\n+\n+fi\n+fi\n+GDC=$ac_cv_prog_GDC\n+if test -n \"$GDC\"; then\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $GDC\" >&5\n+$as_echo \"$GDC\" >&6; }\n+else\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n+$as_echo \"no\" >&6; }\n+fi\n+\n+\n+fi\n+if test -z \"$ac_cv_prog_GDC\"; then\n+  ac_ct_GDC=$GDC\n+  # Extract the first word of \"gdc\", so it can be a program name with args.\n+set dummy gdc; ac_word=$2\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\n+$as_echo_n \"checking for $ac_word... \" >&6; }\n+if ${ac_cv_prog_ac_ct_GDC+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  if test -n \"$ac_ct_GDC\"; then\n+  ac_cv_prog_ac_ct_GDC=\"$ac_ct_GDC\" # Let the user override the test.\n+else\n+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\n+for as_dir in $PATH\n+do\n+  IFS=$as_save_IFS\n+  test -z \"$as_dir\" && as_dir=.\n+    for ac_exec_ext in '' $ac_executable_extensions; do\n+  if as_fn_executable_p \"$as_dir/$ac_word$ac_exec_ext\"; then\n+    ac_cv_prog_ac_ct_GDC=\"gdc\"\n+    $as_echo \"$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext\" >&5\n+    break 2\n+  fi\n+done\n+  done\n+IFS=$as_save_IFS\n+\n+fi\n+fi\n+ac_ct_GDC=$ac_cv_prog_ac_ct_GDC\n+if test -n \"$ac_ct_GDC\"; then\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_ct_GDC\" >&5\n+$as_echo \"$ac_ct_GDC\" >&6; }\n+else\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n+$as_echo \"no\" >&6; }\n+fi\n+\n+  if test \"x$ac_ct_GDC\" = x; then\n+    GDC=\"no\"\n+  else\n+    case $cross_compiling:$ac_tool_warned in\n+yes:)\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet\" >&5\n+$as_echo \"$as_me: WARNING: using cross tools not prefixed with host triplet\" >&2;}\n+ac_tool_warned=yes ;;\n+esac\n+    GDC=$ac_ct_GDC\n+  fi\n+else\n+  GDC=\"$ac_cv_prog_GDC\"\n+fi\n+\n+if test \"x$GDC\" != xno; then\n+  have_gdc=yes\n+else\n+  have_gdc=no\n+fi\n+\n { $as_echo \"$as_me:${as_lineno-$LINENO}: checking how to compare bootstrapped objects\" >&5\n $as_echo_n \"checking how to compare bootstrapped objects... \" >&6; }\n if ${gcc_cv_prog_cmp_skip+:} false; then :\n@@ -8679,6 +8781,23 @@ $as_echo \"$as_me: WARNING: GNAT is required to build $language\" >&2;}\n             ;;\n         esac\n \n+        # Disable D if no preexisting GDC is available.\n+        case ${add_this_lang}:${language}:${have_gdc} in\n+          yes:d:no)\n+            # Specifically requested language; tell them.\n+            as_fn_error $? \"GDC is required to build $language\" \"$LINENO\" 5\n+           ;;\n+          all:d:no)\n+            { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: GDC is required to build $language\" >&5\n+$as_echo \"$as_me: WARNING: GDC is required to build $language\" >&2;}\n+            add_this_lang=unsupported\n+            ;;\n+          *:d:no)\n+            # Silently disable.\n+            add_this_lang=unsupported\n+            ;;\n+        esac\n+\n         # Disable jit if -enable-host-shared not specified\n         # but not if building for Mingw. All code in Windows\n         # is position independent code (PIC).\n@@ -8748,7 +8867,7 @@ $as_echo \"$as_me: WARNING: ${language} not supported for this target\" >&2;}\n \t\t  *) stage1_languages=\"${stage1_languages}${language},\" ;;\n \t\tesac\n \t\t# We need to bootstrap any supporting libraries.\n-\t\tbootstrap_target_libs=\"${bootstrap_target_libs}${target_libs},\"\n+\t\tbootstrap_target_libs=`echo \"${bootstrap_target_libs}${target_libs},\" | sed \"s/ /,/g\"`\n \t\t;;\n \t    esac\n \t    ;;\n@@ -9517,6 +9636,16 @@ if echo \" ${target_configdirs} \" | grep \" libvtv \" > /dev/null 2>&1 &&\n   bootstrap_target_libs=${bootstrap_target_libs}target-libvtv,\n fi\n \n+# If we are building libatomic and the list of enabled languages includes the\n+# D frontend, bootstrap it.\n+if echo \" ${target_configdirs} \" | grep \" libatomic \" > /dev/null 2>&1; then\n+  case ,${enable_languages}, in\n+    *,d,*)\n+      bootstrap_target_libs=${bootstrap_target_libs}target-libatomic,\n+      ;;\n+  esac\n+fi\n+\n # Determine whether gdb needs tk/tcl or not.\n # Use 'maybe' since enable_gdbtk might be true even if tk isn't available\n # and in that case we want gdb to be built without tk.  Ugh!\n@@ -12614,6 +12743,8 @@ fi\n \n \n \n+\n+\n # Target tools.\n \n # Check whether --with-build-time-tools was given."}, {"sha": "2de381fe86342d26a9830e6dfa3d1490d8adcfca", "filename": "configure.ac", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -1406,6 +1406,7 @@ int main() {}])],\n fi\n \n ACX_PROG_GNAT\n+ACX_PROG_GDC\n ACX_PROG_CMP_IGNORE_INITIAL\n \n AC_ARG_ENABLE([bootstrap],\n@@ -2087,6 +2088,22 @@ if test -d ${srcdir}/gcc; then\n             ;;\n         esac\n \n+        # Disable D if no preexisting GDC is available.\n+        case ${add_this_lang}:${language}:${have_gdc} in\n+          yes:d:no)\n+            # Specifically requested language; tell them.\n+            AC_MSG_ERROR([GDC is required to build $language])\n+           ;;\n+          all:d:no)\n+            AC_MSG_WARN([GDC is required to build $language])\n+            add_this_lang=unsupported\n+            ;;\n+          *:d:no)\n+            # Silently disable.\n+            add_this_lang=unsupported\n+            ;;\n+        esac\n+\n         # Disable jit if -enable-host-shared not specified\n         # but not if building for Mingw. All code in Windows\n         # is position independent code (PIC).\n@@ -2154,7 +2171,7 @@ directories, to avoid imposing the performance cost of\n \t\t  *) stage1_languages=\"${stage1_languages}${language},\" ;;\n \t\tesac\n \t\t# We need to bootstrap any supporting libraries.\n-\t\tbootstrap_target_libs=\"${bootstrap_target_libs}${target_libs},\"\n+\t\tbootstrap_target_libs=`echo \"${bootstrap_target_libs}${target_libs},\" | sed \"s/ /,/g\"`\n \t\t;;\n \t    esac\n \t    ;;\n@@ -2837,6 +2854,16 @@ if echo \" ${target_configdirs} \" | grep \" libvtv \" > /dev/null 2>&1 &&\n   bootstrap_target_libs=${bootstrap_target_libs}target-libvtv,\n fi\n \n+# If we are building libatomic and the list of enabled languages includes the\n+# D frontend, bootstrap it.\n+if echo \" ${target_configdirs} \" | grep \" libatomic \" > /dev/null 2>&1; then\n+  case ,${enable_languages}, in\n+    *,d,*)\n+      bootstrap_target_libs=${bootstrap_target_libs}target-libatomic,\n+      ;;\n+  esac\n+fi\n+\n # Determine whether gdb needs tk/tcl or not.\n # Use 'maybe' since enable_gdbtk might be true even if tk isn't available\n # and in that case we want gdb to be built without tk.  Ugh!\n@@ -3505,6 +3532,8 @@ AC_SUBST(CC)\n AC_SUBST(CXX)\n AC_SUBST(CFLAGS)\n AC_SUBST(CXXFLAGS)\n+AC_SUBST(GDC)\n+AC_SUBST(GDCFLAGS)\n \n # Target tools.\n AC_ARG_WITH([build-time-tools], "}, {"sha": "81ea8a73b9915229ff93a4c945681531c159c475", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -1092,6 +1092,10 @@ SYSLIBS = @GNAT_LIBEXC@\n GNATBIND = @GNATBIND@\n GNATMAKE = @GNATMAKE@\n \n+# Used from d/Make-lang.in\n+GDC = @GDC@\n+GDCFLAGS = @GDCFLAGS@\n+\n # Libs needed (at present) just for jcf-dump.\n LDEXP_LIB = @LDEXP_LIB@\n "}, {"sha": "a5160da83ecc3102f565354b1d2b93cf2ca1d0a4", "filename": "gcc/configure", "status": "modified", "additions": 105, "deletions": 2, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -858,6 +858,8 @@ EGREP\n GREP\n CXXCPP\n PICFLAG_FOR_TARGET\n+GDCFLAGS\n+GDC\n GNATMAKE\n GNATBIND\n ac_ct_CXX\n@@ -5257,6 +5259,106 @@ else\n fi\n \n \n+\n+if test -n \"$ac_tool_prefix\"; then\n+  # Extract the first word of \"${ac_tool_prefix}gdc\", so it can be a program name with args.\n+set dummy ${ac_tool_prefix}gdc; ac_word=$2\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\n+$as_echo_n \"checking for $ac_word... \" >&6; }\n+if ${ac_cv_prog_GDC+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  if test -n \"$GDC\"; then\n+  ac_cv_prog_GDC=\"$GDC\" # Let the user override the test.\n+else\n+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\n+for as_dir in $PATH\n+do\n+  IFS=$as_save_IFS\n+  test -z \"$as_dir\" && as_dir=.\n+    for ac_exec_ext in '' $ac_executable_extensions; do\n+  if as_fn_executable_p \"$as_dir/$ac_word$ac_exec_ext\"; then\n+    ac_cv_prog_GDC=\"${ac_tool_prefix}gdc\"\n+    $as_echo \"$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext\" >&5\n+    break 2\n+  fi\n+done\n+  done\n+IFS=$as_save_IFS\n+\n+fi\n+fi\n+GDC=$ac_cv_prog_GDC\n+if test -n \"$GDC\"; then\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $GDC\" >&5\n+$as_echo \"$GDC\" >&6; }\n+else\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n+$as_echo \"no\" >&6; }\n+fi\n+\n+\n+fi\n+if test -z \"$ac_cv_prog_GDC\"; then\n+  ac_ct_GDC=$GDC\n+  # Extract the first word of \"gdc\", so it can be a program name with args.\n+set dummy gdc; ac_word=$2\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\n+$as_echo_n \"checking for $ac_word... \" >&6; }\n+if ${ac_cv_prog_ac_ct_GDC+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  if test -n \"$ac_ct_GDC\"; then\n+  ac_cv_prog_ac_ct_GDC=\"$ac_ct_GDC\" # Let the user override the test.\n+else\n+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\n+for as_dir in $PATH\n+do\n+  IFS=$as_save_IFS\n+  test -z \"$as_dir\" && as_dir=.\n+    for ac_exec_ext in '' $ac_executable_extensions; do\n+  if as_fn_executable_p \"$as_dir/$ac_word$ac_exec_ext\"; then\n+    ac_cv_prog_ac_ct_GDC=\"gdc\"\n+    $as_echo \"$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext\" >&5\n+    break 2\n+  fi\n+done\n+  done\n+IFS=$as_save_IFS\n+\n+fi\n+fi\n+ac_ct_GDC=$ac_cv_prog_ac_ct_GDC\n+if test -n \"$ac_ct_GDC\"; then\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_ct_GDC\" >&5\n+$as_echo \"$ac_ct_GDC\" >&6; }\n+else\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n+$as_echo \"no\" >&6; }\n+fi\n+\n+  if test \"x$ac_ct_GDC\" = x; then\n+    GDC=\"no\"\n+  else\n+    case $cross_compiling:$ac_tool_warned in\n+yes:)\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet\" >&5\n+$as_echo \"$as_me: WARNING: using cross tools not prefixed with host triplet\" >&2;}\n+ac_tool_warned=yes ;;\n+esac\n+    GDC=$ac_ct_GDC\n+  fi\n+else\n+  GDC=\"$ac_cv_prog_GDC\"\n+fi\n+\n+if test \"x$GDC\" != xno; then\n+  have_gdc=yes\n+else\n+  have_gdc=no\n+fi\n+\n+\n # Do configure tests with the C++ compiler, since that's what we build with.\n ac_ext=cpp\n ac_cpp='$CXXCPP $CPPFLAGS'\n@@ -5275,6 +5377,7 @@ esac\n \n \n \n+\n # Determine PICFLAG for target gnatlib.\n \n \n@@ -19458,7 +19561,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 19461 \"configure\"\n+#line 19564 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -19564,7 +19667,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 19567 \"configure\"\n+#line 19670 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H"}, {"sha": "df4d2d8863c8f9dcb41ae936575e33f469513617", "filename": "gcc/configure.ac", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -435,6 +435,7 @@ rm -f a.out a.exe b.out\n AC_PROG_CC\n AC_PROG_CXX\n ACX_PROG_GNAT([-I\"$srcdir\"/ada/libgnat])\n+ACX_PROG_GDC([-I\"$srcdir\"/d])\n \n # Do configure tests with the C++ compiler, since that's what we build with.\n AC_LANG(C++)\n@@ -448,6 +449,7 @@ case \"$CC\" in\n esac\n AC_SUBST(CFLAGS)\n AC_SUBST(CXXFLAGS)\n+AC_SUBST(GDCFLAGS)\n \n # Determine PICFLAG for target gnatlib.\n GCC_PICFLAG_FOR_TARGET"}, {"sha": "4c0a0321eba266fda498b07169ef6dc0ff87f532", "filename": "gcc/d/Make-lang.in", "status": "modified", "additions": 73, "deletions": 59, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2FMake-lang.in?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -46,30 +46,61 @@ gdc-cross$(exeext): gdc$(exeext)\n \t-rm -f gdc-cross$(exeext)\n \tcp gdc$(exeext) gdc-cross$(exeext)\n \n-# Filter out pedantic and virtual overload warnings.\n-d-warn = $(filter-out -pedantic -Woverloaded-virtual, $(STRICT_WARN))\n-\n-# Also filter out warnings for missing format attributes in the D Frontend.\n-DMD_WARN_CXXFLAGS = $(filter-out -Wmissing-format-attribute, $(WARN_CXXFLAGS))\n-DMD_COMPILE = $(subst $(WARN_CXXFLAGS), $(DMD_WARN_CXXFLAGS), $(COMPILE))\n+# Use strict warnings.\n+d-warn = $(STRICT_WARN)\n+\n+# D compiler and flags for building the front-end.\n+ifeq ($(TREECHECKING),)\n+CHECKING_DFLAGS = -frelease\n+else\n+CHECKING_DFLAGS =\n+endif\n+WARN_DFLAGS = -Wall -Wdeprecated $(NOCOMMON_FLAG)\n+\n+ALL_DFLAGS = $(DFLAGS-$@) $(GDCFLAGS) -fversion=IN_GCC $(CHECKING_DFLAGS) \\\n+\t$(PICFLAG) $(ALIASING_FLAGS) $(COVERAGE_FLAGS) $(WARN_DFLAGS)\n+\n+DCOMPILE.base = $(GDC) $(NO_PIE_CFLAGS) -c $(ALL_DFLAGS) -o $@\n+DCOMPILE = $(DCOMPILE.base) -MT $@ -MMD -MP -MF $(@D)/$(DEPDIR)/$(*F).TPo\n+DPOSTCOMPILE = @mv $(@D)/$(DEPDIR)/$(*F).TPo $(@D)/$(DEPDIR)/$(*F).Po\n+DLINKER = $(GDC) $(NO_PIE_FLAG) -lstdc++\n+\n+# Like LINKER, but use a mutex for serializing front end links.\n+ifeq (@DO_LINK_MUTEX@,true)\n+DLLINKER = $(SHELL) $(srcdir)/lock-and-run.sh linkfe.lck $(DLINKER)\n+else\n+DLLINKER = $(DLINKER)\n+endif\n \n # D Frontend object files.\n D_FRONTEND_OBJS = \\\n \td/aav.o \\\n \td/access.o \\\n+\td/aggregate.o \\\n \td/aliasthis.o \\\n \td/apply.o \\\n+\td/array.o \\\n \td/arrayop.o \\\n+\td/arraytypes.o \\\n \td/attrib.o \\\n+\td/ast_node.o \\\n+\td/astcodegen.o \\\n+\td/astenums.o \\\n+\td/bitarray.o \\\n \td/blockexit.o \\\n+\td/builtin.o \\\n \td/canthrow.o \\\n-\td/checkedint.o \\\n \td/chkformat.o \\\n \td/clone.o \\\n+\td/compiler.o \\\n+\td/complex.o \\\n \td/cond.o \\\n \td/constfold.o \\\n+\td/cparse.o \\\n \td/cppmangle.o \\\n \td/ctfeexpr.o \\\n+\td/ctfloat.o \\\n+\td/ctorflow.o \\\n \td/dcast.o \\\n \td/dclass.o \\\n \td/declaration.o \\\n@@ -86,32 +117,49 @@ D_FRONTEND_OBJS = \\\n \td/dsymbol.o \\\n \td/dsymbolsem.o \\\n \td/dtemplate.o \\\n+\td/dtoh.o \\\n \td/dversion.o \\\n \td/entity.o \\\n+\td/errors.o \\\n \td/escape.o \\\n \td/expression.o \\\n \td/expressionsem.o \\\n \td/file.o \\\n \td/filename.o \\\n+\td/foreachvar.o \\\n \td/func.o \\\n+\td/globals.o \\\n+\td/gluelayer.o \\\n+\td/hash.o \\\n \td/hdrgen.o \\\n \td/iasm.o \\\n \td/iasmgcc.o \\\n+\td/id.o \\\n \td/identifier.o \\\n+\td/impcnvtab.o \\\n \td/imphint.o \\\n \td/init.o \\\n \td/initsem.o \\\n+\td/inline.o \\\n \td/intrange.o \\\n \td/json.o \\\n+\td/lambdacomp.o \\\n \td/lexer.o \\\n+\td/longdouble.o \\\n \td/mtype.o \\\n \td/nogc.o \\\n \td/nspace.o \\\n+\td/ob.o \\\n \td/objc.o \\\n \td/opover.o \\\n \td/optimize.o \\\n \td/outbuffer.o \\\n \td/parse.o \\\n+\td/parsetimevisitor.o \\\n+\td/permissivevisitor.o \\\n+\td/port.o \\\n+\td/printast.o \\\n+\td/region.o \\\n \td/rmem.o \\\n \td/rootobject.o \\\n \td/safe.o \\\n@@ -121,20 +169,23 @@ D_FRONTEND_OBJS = \\\n \td/sideeffect.o \\\n \td/speller.o \\\n \td/statement.o \\\n+\td/statement_rewrite_walker.o \\\n \td/statementsem.o \\\n \td/staticassert.o \\\n \td/staticcond.o \\\n+\td/stmtstate.o \\\n+\td/string.o \\\n \td/stringtable.o \\\n+\td/target.o \\\n \td/templateparamsem.o \\\n \td/tokens.o \\\n \td/traits.o \\\n+\td/transitivevisitor.o \\\n \td/typesem.o \\\n+\td/typinf.o \\\n \td/utf.o \\\n-\td/utils.o\n-\n-# D Frontend generated files.\n-D_GENERATED_SRCS = d/id.c d/id.h d/impcnvtab.c\n-D_GENERATED_OBJS = d/id.o d/impcnvtab.o\n+\td/utils.o \\\n+\td/visitor.o\n \n # Language-specific object files for D.\n D_OBJS = \\\n@@ -163,13 +214,13 @@ D_OBJS = \\\n \td/types.o\n \n # All language-specific object files for D.\n-D_ALL_OBJS = $(D_FRONTEND_OBJS) $(D_GENERATED_OBJS) $(D_OBJS) $(D_TARGET_OBJS)\n+D_ALL_OBJS = $(D_FRONTEND_OBJS) $(D_OBJS) $(D_TARGET_OBJS)\n \n d_OBJS = $(D_ALL_OBJS) d/d-spec.o\n \n d21$(exeext): $(D_ALL_OBJS) attribs.o $(BACKEND) $(LIBDEPS) $(d.prev)\n \t@$(call LINK_PROGRESS,$(INDEX.d),start)\n-\t+$(LLINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \\\n+\t+$(DLLINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -static-libphobos -o $@ \\\n \t\t$(D_ALL_OBJS) attribs.o $(BACKEND) $(LIBS) $(BACKENDLIBS)\n \t@$(call LINK_PROGRESS,$(INDEX.d),end)\n \n@@ -221,7 +272,7 @@ d.srcextra:\n \n d.tags: force\n \tcd $(srcdir)/d; \\\n-\t$(ETAGS) -o TAGS.sub *.c *.cc *.h dmd/*.c dmd/*.h dmd/root/*.h dmd/root/*.c; \\\n+\t$(ETAGS) -o TAGS.sub *.c *.cc *.h dmd/*.h dmd/root/*.h; \\\n \t$(ETAGS) --include TAGS.sub --include ../TAGS.sub\n \n d.man: doc/gdc.1\n@@ -313,8 +364,6 @@ d.uninstall:\n d.mostlyclean:\n \t-rm -f d/*$(objext)\n \t-rm -f d/*$(coverageexts)\n-\t-rm -f $(D_GENERATED_SRCS)\n-\t-rm -f d/idgen$(build_exeext) d/impcnvgen$(build_exeext)\n \t-rm -f gdc$(exeext) gdc-cross$(exeext) d21$(exeext)\n d.clean:\n d.distclean:\n@@ -337,48 +386,13 @@ d.stagefeedback: stagefeedback-start\n \t-mv d/*$(objext) stagefeedback/d\n \n # Include the dfrontend and build directories for headers.\n-D_INCLUDES = -I$(srcdir)/d -I$(srcdir)/d/dmd -Id\n-\n-CFLAGS-d/id.o += $(D_INCLUDES)\n-CFLAGS-d/impcnvtab.o += $(D_INCLUDES)\n+D_INCLUDES = -I$(srcdir)/d -J$(srcdir)/d/dmd -J$(srcdir)/d/dmd/res\n \n # Override build rules for D frontend.\n-d/%.o: d/dmd/%.c $(D_GENERATED_SRCS)\n-\t$(DMD_COMPILE) $(D_INCLUDES) $<\n-\t$(POSTCOMPILE)\n-\n-d/%.o: d/dmd/root/%.c $(D_GENERATED_SRCS)\n-\t$(DMD_COMPILE) $(D_INCLUDES) $<\n-\t$(POSTCOMPILE)\n-\n-# Generated programs.\n-d/idgen$(build_exeext): d/idgen.dmdgen.o $(BUILD_LIBDEPS)\n-\t+$(LINKER_FOR_BUILD) $(BUILD_LINKERFLAGS) $(BUILD_LDFLAGS) -o $@ \\\n-\t    $(filter-out $(BUILD_LIBDEPS), $^) $(BUILD_LIBS)\n-\n-d/impcnvgen$(build_exeext): d/impcnvgen.dmdgen.o $(BUILD_LIBDEPS)\n-\t+$(LINKER_FOR_BUILD) $(BUILD_LINKERFLAGS) $(BUILD_LDFLAGS) -o $@ \\\n-\t    $(filter-out $(BUILD_LIBDEPS), $^) $(BUILD_LIBS)\n-\n-# Generated sources.\n-d/id.c: d/idgen$(build_exeext)\n-\tcd d && ./idgen$(build_exeext)\n-\n-# idgen also generates id.h; just verify it exists.\n-d/id.h: d/id.c\n-\n-d/impcnvtab.c: d/impcnvgen$(build_exeext)\n-\tcd d && ./impcnvgen$(build_exeext)\n-\n-# Compile the generator programs.\n-d/%.dmdgen.o: $(srcdir)/d/dmd/%.c\n-\t$(COMPILER_FOR_BUILD) -c $(BUILD_COMPILERFLAGS) $(D_INCLUDES) \\\n-\t\t$(BUILD_CPPFLAGS) -o $@ $<\n-\n-# Header dependencies for the generator programs.\n-D_SYSTEM_H = d/dmd/root/dsystem.h d/d-system.h\n-\n-d/idgen.dmdgen.o: d/dmd/idgen.c $(D_SYSTEM_H) $(BCONFIG_H) $(SYSTEM_H)\n+d/%.o: d/dmd/%.d\n+\t$(DCOMPILE) $(D_INCLUDES) $<\n+\t$(DPOSTCOMPILE)\n \n-d/impcnvgen.dmdgen.o: d/dmd/impcnvgen.c d/dmd/mtype.h $(D_SYSTEM_H) \\\n-\t$(BCONFIG_H) $(SYSTEM_H)\n+d/%.o: d/dmd/root/%.d\n+\t$(DCOMPILE) $(D_INCLUDES) $<\n+\t$(DPOSTCOMPILE)"}, {"sha": "00a71d6b8b52ae64281c36c705bd29e1070725a4", "filename": "gcc/d/config-lang.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fconfig-lang.in?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -19,10 +19,12 @@\n # We define several parameters used by configure:\n #\n # language\t- name of language as it would appear in $(LANGUAGES)\n+# boot_language\t- \"yes\" if we need to build this language in stage1\n # compilers\t- value to add to $(COMPILERS)\n \n language=\"d\"\n \n+boot_language=yes\n compilers=\"d21\\$(exeext)\"\n \n phobos_target_deps=\"target-zlib target-libbacktrace\""}, {"sha": "04b9791ab1bfb55ae7594dc2cd6ef6b1eb98e0ad", "filename": "gcc/d/d-attribs.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fd-attribs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fd-attribs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-attribs.cc?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -24,6 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"dmd/attrib.h\"\n #include \"dmd/declaration.h\"\n+#include \"dmd/expression.h\"\n #include \"dmd/module.h\"\n #include \"dmd/mtype.h\"\n #include \"dmd/template.h\""}, {"sha": "ab3a950689f960dfdd60b99a867504772eade3d2", "filename": "gcc/d/d-builtins.cc", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fd-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fd-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-builtins.cc?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -39,6 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stor-layout.h\"\n \n #include \"d-tree.h\"\n+#include \"d-frontend.h\"\n #include \"d-target.h\"\n \n \n@@ -98,7 +99,7 @@ build_frontend_type (tree type)\n \t  if (TYPE_MAIN_VARIANT (TREE_TYPE (type)) == char_type_node)\n \t    return Type::tchar->addMod (dtype->mod)->pointerTo ()->addMod (mod);\n \n-\t  if (dtype->ty == Tfunction)\n+\t  if (dtype->ty == TY::Tfunction)\n \t    return (TypePointer::create (dtype))->addMod (mod);\n \n \t  return dtype->pointerTo ()->addMod (mod);\n@@ -130,7 +131,7 @@ build_frontend_type (tree type)\n \n       /* For now, skip support for cent/ucent until the frontend\n \t has better support for handling it.  */\n-      for (size_t i = Tint8; i <= Tuns64; i++)\n+      for (size_t i = (size_t) TY::Tint8; i <= (size_t) TY::Tuns64; i++)\n \t{\n \t  dtype = Type::basic[i];\n \n@@ -148,7 +149,7 @@ build_frontend_type (tree type)\n     {\n       unsigned size = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (type));\n \n-      for (size_t i = Tfloat32; i <= Tfloat80; i++)\n+      for (size_t i = (size_t) TY::Tfloat32; i <= (size_t) TY::Tfloat80; i++)\n \t{\n \t  dtype = Type::basic[i];\n \n@@ -164,7 +165,8 @@ build_frontend_type (tree type)\n     case COMPLEX_TYPE:\n     {\n       unsigned size = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (type));\n-      for (size_t i = Tcomplex32; i <= Tcomplex80; i++)\n+      for (size_t i = (size_t) TY::Tcomplex32; i <= (size_t) TY::Tcomplex80;\n+\t   i++)\n \t{\n \t  dtype = Type::basic[i];\n \n@@ -235,15 +237,15 @@ build_frontend_type (tree type)\n       sdecl->structsize = int_size_in_bytes (type);\n       sdecl->alignsize = TYPE_ALIGN_UNIT (type);\n       sdecl->alignment = STRUCTALIGN_DEFAULT;\n-      sdecl->sizeok = SIZEOKdone;\n+      sdecl->sizeok = Sizeok::done;\n       sdecl->type = (TypeStruct::create (sdecl))->addMod (mod);\n       sdecl->type->ctype = type;\n       sdecl->type->merge2 ();\n \n       /* Add both named and anonymous fields as members of the struct.\n \t Anonymous fields still need a name in D, so call them \"__pad%u\".  */\n       unsigned anonfield_id = 0;\n-      sdecl->members = new Dsymbols;\n+      sdecl->members = d_gc_malloc<Dsymbols> ();\n \n       for (tree field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n \t{\n@@ -253,7 +255,6 @@ build_frontend_type (tree type)\n \t      /* Drop any field types that got cached before the conversion\n \t\t of this record type failed.  */\n \t      builtin_converted_decls.truncate (saved_builtin_decls_length);\n-\t      delete sdecl->members;\n \t      return NULL;\n \t    }\n \n@@ -292,7 +293,7 @@ build_frontend_type (tree type)\n \t  tree parms = TYPE_ARG_TYPES (type);\n \t  VarArg varargs_p = VARARGvariadic;\n \n-\t  Parameters *args = new Parameters;\n+\t  Parameters *args = d_gc_malloc<Parameters> ();\n \t  args->reserve (list_length (parms));\n \n \t  /* Attempt to convert all parameter types.  */\n@@ -318,7 +319,6 @@ build_frontend_type (tree type)\n \t\t  /* Drop any parameter types that got cached before the\n \t\t     conversion of this function type failed.  */\n \t\t  builtin_converted_decls.truncate (saved_builtin_decls_length);\n-\t\t  delete args;\n \t\t  return NULL;\n \t\t}\n \n@@ -329,7 +329,7 @@ build_frontend_type (tree type)\n \t     have no named parameters, and so can't be represented in D.  */\n \t  if (args->length != 0 || varargs_p == VARARGnone)\n \t    {\n-\t      dtype = TypeFunction::create (args, dtype, varargs_p, LINKc);\n+\t      dtype = TypeFunction::create (args, dtype, varargs_p, LINK::c);\n \t      return dtype->addMod (mod);\n \t    }\n \t}\n@@ -386,7 +386,7 @@ d_eval_constant_expression (const Loc &loc, tree cst)\n       else if (code == VECTOR_CST)\n \t{\n \t  dinteger_t nunits = VECTOR_CST_NELTS (cst).to_constant ();\n-\t  Expressions *elements = new Expressions;\n+\t  Expressions *elements = d_gc_malloc<Expressions> ();\n \t  elements->setDim (nunits);\n \n \t  for (size_t i = 0; i < nunits; i++)\n@@ -520,7 +520,7 @@ build_alias_declaration (const char *alias, Type *type)\n void\n d_build_builtins_module (Module *m)\n {\n-  Dsymbols *members = new Dsymbols;\n+  Dsymbols *members = d_gc_malloc<Dsymbols> ();\n   tree decl;\n \n   for (size_t i = 0; vec_safe_iterate (gcc_builtins_functions, i, &decl); ++i)\n@@ -543,24 +543,24 @@ d_build_builtins_module (Module *m)\n \t   flag_unsafe_math_optimizations.\n \t - Built-ins never use the GC or raise a D exception, and so are always\n \t   marked as `nothrow' and `@nogc'.  */\n-      tf->purity = DECL_PURE_P (decl) ? PUREstrong\n-\t: TREE_READONLY (decl) ? PUREconst\n-\t: DECL_IS_NOVOPS (decl) ? PUREweak\n-\t: !DECL_ASSEMBLER_NAME_SET_P (decl) ? PUREweak\n-\t: PUREimpure;\n-      tf->trust = !DECL_ASSEMBLER_NAME_SET_P (decl) ? TRUSTsafe\n-\t: TREE_NOTHROW (decl) ? TRUSTtrusted\n-\t: TRUSTsystem;\n-      tf->isnothrow = true;\n-      tf->isnogc = true;\n+      tf->purity = DECL_PURE_P (decl) ? PURE::strong\n+\t: TREE_READONLY (decl) ? PURE::const_\n+\t: DECL_IS_NOVOPS (decl) ? PURE::weak\n+\t: !DECL_ASSEMBLER_NAME_SET_P (decl) ? PURE::weak\n+\t: PURE::impure;\n+      tf->trust = !DECL_ASSEMBLER_NAME_SET_P (decl) ? TRUST::safe\n+\t: TREE_NOTHROW (decl) ? TRUST::trusted\n+\t: TRUST::system;\n+      tf->isnothrow (true);\n+      tf->isnogc (true);\n \n       FuncDeclaration *func\n \t= FuncDeclaration::create (Loc (), Loc (),\n \t\t\t\t   Identifier::idPool (name),\n \t\t\t\t   STCextern, tf);\n       DECL_LANG_SPECIFIC (decl) = build_lang_decl (func);\n       func->csym = decl;\n-      func->builtin = BUILTINgcc;\n+      func->builtin = BUILTIN::gcc;\n \n       members->push (func);\n     }\n@@ -660,7 +660,7 @@ d_build_builtins_module (Module *m)\n     members->push (build_alias_declaration (\"__builtin_unwind_uint\", t));\n   }\n \n-  m->members->push (LinkDeclaration::create (LINKc, members));\n+  m->members->push (LinkDeclaration::create (Loc (), LINK::c, members));\n }\n \n /* Search for any `extern(C)' functions that match any known GCC library builtin\n@@ -700,7 +700,7 @@ maybe_set_builtin_1 (Dsymbol *d)\n \t  /* Found a match, tell the frontend this is a builtin.  */\n \t  DECL_LANG_SPECIFIC (t) = build_lang_decl (fd);\n \t  fd->csym = t;\n-\t  fd->builtin = BUILTINgcc;\n+\t  fd->builtin = BUILTIN::gcc;\n \t  return;\n \t}\n     }\n@@ -858,7 +858,7 @@ d_build_d_type_nodes (void)\n \n   /* Calling build_ctype() links the front-end Type to the GCC node,\n      and sets the TYPE_NAME to the D language type.  */\n-  for (unsigned ty = 0; ty < TMAX; ty++)\n+  for (unsigned ty = 0; ty < (unsigned) TY::TMAX; ty++)\n     {\n       if (Type::basic[ty] != NULL)\n \tbuild_ctype (Type::basic[ty]);"}, {"sha": "403e3c7437709f103a21bea2d8d4f61b4012849b", "filename": "gcc/d/d-codegen.cc", "status": "modified", "additions": 52, "deletions": 26, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fd-codegen.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fd-codegen.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-codegen.cc?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -76,7 +76,7 @@ d_decl_context (Dsymbol *dsym)\n \t but only for extern(D) symbols.  */\n       if (parent->isModule ())\n \t{\n-\t  if ((decl != NULL && decl->linkage != LINKd)\n+\t  if ((decl != NULL && decl->linkage != LINK::d)\n \t      || (ad != NULL && ad->classKind != ClassKind::d))\n \t    return NULL_TREE;\n \n@@ -131,7 +131,7 @@ declaration_reference_p (Declaration *decl)\n   Type *tb = decl->type->toBasetype ();\n \n   /* Declaration is a reference type.  */\n-  if (tb->ty == Treference || decl->storage_class & (STCout | STCref))\n+  if (tb->ty == TY::Treference || decl->storage_class & (STCout | STCref))\n     return true;\n \n   return false;\n@@ -146,7 +146,7 @@ declaration_type (Declaration *decl)\n   if (decl->storage_class & STClazy)\n     {\n       TypeFunction *tf = TypeFunction::create (NULL, decl->type,\n-\t\t\t\t\t       VARARGnone, LINKd);\n+\t\t\t\t\t       VARARGnone, LINK::d);\n       TypeDelegate *t = TypeDelegate::create (tf);\n       return build_ctype (t->merge2 ());\n     }\n@@ -181,7 +181,7 @@ parameter_reference_p (Parameter *arg)\n   Type *tb = arg->type->toBasetype ();\n \n   /* Parameter is a reference type.  */\n-  if (tb->ty == Treference || arg->storageClass & (STCout | STCref))\n+  if (tb->ty == TY::Treference || arg->storageClass & (STCout | STCref))\n     return true;\n \n   return false;\n@@ -196,7 +196,7 @@ parameter_type (Parameter *arg)\n   if (arg->storageClass & STClazy)\n     {\n       TypeFunction *tf = TypeFunction::create (NULL, arg->type,\n-\t\t\t\t\t       VARARGnone, LINKd);\n+\t\t\t\t\t       VARARGnone, LINK::d);\n       TypeDelegate *t = TypeDelegate::create (tf);\n       return build_ctype (t->merge2 ());\n     }\n@@ -319,10 +319,10 @@ get_array_length (tree exp, Type *type)\n \n   switch (tb->ty)\n     {\n-    case Tsarray:\n+    case TY::Tsarray:\n       return size_int (tb->isTypeSArray ()->dim->toUInteger ());\n \n-    case Tarray:\n+    case TY::Tarray:\n       return d_array_length (exp);\n \n     default:\n@@ -411,7 +411,7 @@ build_delegate_cst (tree method, tree object, Type *type)\n   tree ctype;\n \n   Type *tb = type->toBasetype ();\n-  if (tb->ty == Tdelegate)\n+  if (tb->ty == TY::Tdelegate)\n     ctype = build_ctype (type);\n   else\n     {\n@@ -464,11 +464,11 @@ build_typeof_null_value (Type *type)\n   tree value;\n \n   /* For dynamic arrays, set length and pointer fields to zero.  */\n-  if (tb->ty == Tarray)\n+  if (tb->ty == TY::Tarray)\n     value = d_array_value (build_ctype (type), size_int (0), null_pointer_node);\n \n   /* For associative arrays, set the pointer field to null.  */\n-  else if (tb->ty == Taarray)\n+  else if (tb->ty == TY::Taarray)\n     {\n       tree ctype = build_ctype (type);\n       gcc_assert (TYPE_ASSOCIATIVE_ARRAY (ctype));\n@@ -478,7 +478,7 @@ build_typeof_null_value (Type *type)\n     }\n \n   /* For delegates, set the frame and function pointer fields to null.  */\n-  else if (tb->ty == Tdelegate)\n+  else if (tb->ty == TY::Tdelegate)\n     value = build_delegate_cst (null_pointer_node, null_pointer_node, type);\n \n   /* Simple zero constant for all other types.  */\n@@ -882,7 +882,9 @@ identity_compare_p (StructDeclaration *sd)\n \t}\n \n       /* Check for types that may have padding.  */\n-      if ((tb->ty == Tcomplex80 || tb->ty == Tfloat80 || tb->ty == Timaginary80)\n+      if ((tb->ty == TY::Tcomplex80\n+\t   || tb->ty == TY::Tfloat80\n+\t   || tb->ty == TY::Timaginary80)\n \t  && target.realpad != 0)\n \treturn false;\n \n@@ -960,12 +962,12 @@ lower_struct_comparison (tree_code code, StructDeclaration *sd,\n \t  /* Compare inner data structures.  */\n \t  tcmp = lower_struct_comparison (code, ts->sym, t1ref, t2ref);\n \t}\n-      else if (type->ty != Tvector && type->isintegral ())\n+      else if (type->ty != TY::Tvector && type->isintegral ())\n \t{\n \t  /* Integer comparison, no special handling required.  */\n \t  tcmp = build_boolop (code, t1ref, t2ref);\n \t}\n-      else if (type->ty != Tvector && type->isfloating ())\n+      else if (type->ty != TY::Tvector && type->isfloating ())\n \t{\n \t  /* Floating-point comparison, don't compare padding in type.  */\n \t  if (!type->iscomplex ())\n@@ -1839,7 +1841,7 @@ static tree\n build_filename_from_loc (const Loc &loc)\n {\n   const char *filename = loc.filename\n-    ? loc.filename : d_function_chain->module->srcfile->toChars ();\n+    ? loc.filename : d_function_chain->module->srcfile.toChars ();\n \n   unsigned length = strlen (filename);\n   tree str = build_string (length, filename);\n@@ -1862,7 +1864,6 @@ build_assert_call (const Loc &loc, libcall_fn libcall, tree msg)\n     {\n     case LIBCALL_ASSERT_MSG:\n     case LIBCALL_UNITTEST_MSG:\n-    case LIBCALL_SWITCH_ERROR:\n       /* File location is passed as a D string.  */\n       if (loc.filename)\n \t{\n@@ -1912,7 +1913,7 @@ build_array_bounds_call (const Loc &loc)\n \n /* Builds a bounds condition checking that INDEX is between 0 and LENGTH\n    in the index expression IE.  The condition returns the INDEX if true, or\n-   throws a `RangeError`.  */\n+   throws a `ArrayIndexError`.  */\n \n tree\n build_bounds_index_condition (IndexExp *ie, tree index, tree length)\n@@ -1927,7 +1928,16 @@ build_bounds_index_condition (IndexExp *ie, tree index, tree length)\n      No need to check whether INDEX >= 0 as the front-end should\n      have already taken care of implicit casts to unsigned.  */\n   tree condition = fold_build2 (GE_EXPR, d_bool_type, index, length);\n-  tree boundserr = build_array_bounds_call (ie->e2->loc);\n+  tree boundserr;\n+\n+  if (checkaction_trap_p ())\n+    boundserr = build_call_expr (builtin_decl_explicit (BUILT_IN_TRAP), 0);\n+  else\n+    {\n+      boundserr = build_libcall (LIBCALL_ARRAYBOUNDS_INDEXP, Type::tvoid, 4,\n+\t\t\t\t build_filename_from_loc (ie->e2->loc),\n+\t\t\t\t size_int (ie->e2->loc.linnum), index, length);\n+    }\n \n   return build_condition (TREE_TYPE (index), condition, boundserr, index);\n }\n@@ -1963,7 +1973,22 @@ build_bounds_slice_condition (SliceExp *se, tree lower, tree upper, tree length)\n \n       if (condition != NULL_TREE)\n \t{\n-\t  tree boundserr = build_array_bounds_call (se->loc);\n+\t  tree boundserr;\n+\n+\t  if (checkaction_trap_p ())\n+\t    {\n+\t      boundserr =\n+\t\tbuild_call_expr (builtin_decl_explicit (BUILT_IN_TRAP), 0);\n+\t    }\n+\t  else\n+\t    {\n+\t      boundserr = build_libcall (LIBCALL_ARRAYBOUNDS_SLICEP,\n+\t\t\t\t\t Type::tvoid, 5,\n+\t\t\t\t\t build_filename_from_loc (se->loc),\n+\t\t\t\t\t size_int (se->loc.linnum),\n+\t\t\t\t\t lower, upper, length);\n+\t    }\n+\n \t  upper = build_condition (TREE_TYPE (upper), condition,\n \t\t\t\t   boundserr, upper);\n \t}\n@@ -1993,9 +2018,9 @@ array_bounds_check (void)\n     case CHECKENABLEsafeonly:\n       /* For D2 safe functions only.  */\n       fd = d_function_chain->function;\n-      if (fd && fd->type->ty == Tfunction)\n+      if (fd && fd->type->ty == TY::Tfunction)\n \t{\n-\t  if (fd->type->isTypeFunction ()->trust == TRUSTsafe)\n+\t  if (fd->type->isTypeFunction ()->trust == TRUST::safe)\n \t    return true;\n \t}\n       return false;\n@@ -2014,6 +2039,7 @@ checkaction_trap_p (void)\n   switch (global.params.checkAction)\n     {\n     case CHECKACTION_D:\n+    case CHECKACTION_context:\n       return false;\n \n     case CHECKACTION_C:\n@@ -2032,11 +2058,11 @@ TypeFunction *\n get_function_type (Type *t)\n {\n   TypeFunction *tf = NULL;\n-  if (t->ty == Tpointer)\n+  if (t->ty == TY::Tpointer)\n     t = t->nextOf ()->toBasetype ();\n-  if (t->ty == Tfunction)\n+  if (t->ty == TY::Tfunction)\n     tf = t->isTypeFunction ();\n-  else if (t->ty == Tdelegate)\n+  else if (t->ty == TY::Tdelegate)\n     tf = t->isTypeDelegate ()->next->isTypeFunction ();\n   return tf;\n }\n@@ -2096,7 +2122,7 @@ d_build_call (TypeFunction *tf, tree callable, tree object,\n \n   gcc_assert (FUNC_OR_METHOD_TYPE_P (ctype));\n   gcc_assert (tf != NULL);\n-  gcc_assert (tf->ty == Tfunction);\n+  gcc_assert (tf->ty == TY::Tfunction);\n \n   if (TREE_CODE (ctype) != FUNCTION_TYPE && object == NULL_TREE)\n     {\n@@ -2195,7 +2221,7 @@ d_build_call (TypeFunction *tf, tree callable, tree object,\n   SET_EXPR_LOCATION (result, input_location);\n \n   /* Enforce left to right evaluation.  */\n-  if (tf->linkage == LINKd)\n+  if (tf->linkage == LINK::d)\n     CALL_EXPR_ARGS_ORDERED (result) = 1;\n \n   result = maybe_expand_intrinsic (result);"}, {"sha": "3df40073ac5470d041ab9e408cf0a50a6e976f36", "filename": "gcc/d/d-compiler.cc", "status": "modified", "additions": 7, "deletions": 42, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fd-compiler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fd-compiler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-compiler.cc?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -20,7 +20,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n \n #include \"dmd/compiler.h\"\n-#include \"dmd/scope.h\"\n #include \"dmd/expression.h\"\n #include \"dmd/identifier.h\"\n #include \"dmd/module.h\"\n@@ -34,40 +33,6 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Implements the Compiler interface used by the frontend.  */\n \n-/* Generate C main() in response to seeing D main().  This used to be in\n-   libdruntime, but contained a reference to _Dmain which didn't work when\n-   druntime was made into a shared library and was linked to a program, such\n-   as a C++ program, that didn't have a _Dmain.  */\n-\n-void\n-Compiler::genCmain (Scope *sc)\n-{\n-  static bool initialized = false;\n-\n-  if (initialized)\n-    return;\n-\n-  /* The D code to be generated is provided by __entrypoint.di, try to load it,\n-     but don't fail if unfound.  */\n-  unsigned errors = global.startGagging ();\n-  Module *m = Module::load (Loc (), NULL, Identifier::idPool (\"__entrypoint\"));\n-\n-  if (global.endGagging (errors))\n-    m = NULL;\n-\n-  if (m != NULL)\n-    {\n-      m->importedFrom = m;\n-      m->importAll (NULL);\n-      dsymbolSemantic (m, NULL);\n-      semantic2 (m, NULL);\n-      semantic3 (m, NULL);\n-      d_add_entrypoint_module (m, sc->_module);\n-    }\n-\n-  initialized = true;\n-}\n-\n /* Perform a reinterpret cast of EXPR to type TYPE for use in CTFE.\n    The front end should have already ensured that EXPR is a constant,\n    so we just lower the value to GCC and return the converted CST.  */\n@@ -123,7 +88,7 @@ Compiler::paintAsType (UnionExp *, Expression *expr, Type *type)\n   /* Encode CST to buffer.  */\n   int len = native_encode_expr (cst, buffer, sizeof (buffer));\n \n-  if (tb->ty == Tsarray)\n+  if (tb->ty == TY::Tsarray)\n     {\n       /* Interpret value as a vector of the same size,\n \t then return the array literal.  */\n@@ -161,22 +126,22 @@ Compiler::onParseModule (Module *m)\n {\n   ModuleDeclaration *md = m->md;\n \n-  if (!md || !md->id || !md->packages)\n+  if (!md || !md->id|| md->packages.length == 0)\n     {\n       Identifier *id = (md && md->id) ? md->id : m->ident;\n       if (!strcmp (id->toChars (), \"object\"))\n \tcreate_tinfo_types (m);\n     }\n-  else if (md->packages->length == 1)\n+  else if (md->packages.length == 1)\n     {\n-      if (!strcmp ((*md->packages)[0]->toChars (), \"gcc\")\n+      if (!strcmp (md->packages.ptr[0]->toChars (), \"gcc\")\n \t  && !strcmp (md->id->toChars (), \"builtins\"))\n \td_build_builtins_module (m);\n     }\n-  else if (md->packages->length == 2)\n+  else if (md->packages.length == 2)\n     {\n-      if (!strcmp ((*md->packages)[0]->toChars (), \"core\")\n-\t  && !strcmp ((*md->packages)[1]->toChars (), \"stdc\"))\n+      if (!strcmp (md->packages.ptr[0]->toChars (), \"core\")\n+\t  && !strcmp (md->packages.ptr[1]->toChars (), \"stdc\"))\n \td_add_builtin_module (m);\n     }\n }"}, {"sha": "25fd603edfac54b95845a0abdabc362320157d17", "filename": "gcc/d/d-convert.cc", "status": "modified", "additions": 48, "deletions": 38, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fd-convert.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fd-convert.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-convert.cc?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -361,14 +361,14 @@ convert_expr (tree exp, Type *etype, Type *totype)\n \n   switch (ebtype->ty)\n     {\n-    case Tdelegate:\n-      if (tbtype->ty == Tdelegate)\n+    case TY::Tdelegate:\n+      if (tbtype->ty == TY::Tdelegate)\n \t{\n \t  exp = d_save_expr (exp);\n \t  return build_delegate_cst (delegate_method (exp),\n \t\t\t\t     delegate_object (exp), totype);\n \t}\n-      else if (tbtype->ty == Tpointer)\n+      else if (tbtype->ty == TY::Tpointer)\n \t{\n \t  /* The front-end converts <delegate>.ptr to cast (void *)<delegate>.\n \t     Maybe should only allow void* ?  */\n@@ -382,8 +382,8 @@ convert_expr (tree exp, Type *etype, Type *totype)\n \t}\n       break;\n \n-    case Tstruct:\n-      if (tbtype->ty == Tstruct)\n+    case TY::Tstruct:\n+      if (tbtype->ty == TY::Tstruct)\n \t{\n \t  if (totype->size () == etype->size ())\n \t    {\n@@ -400,8 +400,8 @@ convert_expr (tree exp, Type *etype, Type *totype)\n       /* else, default conversion, which should produce an error.  */\n       break;\n \n-    case Tclass:\n-      if (tbtype->ty == Tclass)\n+    case TY::Tclass:\n+      if (tbtype->ty == TY::Tclass)\n \t{\n \t  ClassDeclaration *cdfrom = ebtype->isClassHandle ();\n \t  ClassDeclaration *cdto = tbtype->isClassHandle ();\n@@ -460,12 +460,12 @@ convert_expr (tree exp, Type *etype, Type *totype)\n       /* else default conversion.  */\n       break;\n \n-    case Tsarray:\n-      if (tbtype->ty == Tpointer)\n+    case TY::Tsarray:\n+      if (tbtype->ty == TY::Tpointer)\n \t{\n \t  result = build_nop (build_ctype (totype), build_address (exp));\n \t}\n-      else if (tbtype->ty == Tarray)\n+      else if (tbtype->ty == TY::Tarray)\n \t{\n \t  dinteger_t dim = ebtype->isTypeSArray ()->dim->toInteger ();\n \t  dinteger_t esize = ebtype->nextOf ()->size ();\n@@ -490,12 +490,12 @@ convert_expr (tree exp, Type *etype, Type *totype)\n \t  return d_array_value (build_ctype (totype), size_int (dim),\n \t\t\t\tbuild_nop (ptrtype, build_address (exp)));\n \t}\n-      else if (tbtype->ty == Tsarray)\n+      else if (tbtype->ty == TY::Tsarray)\n \t{\n \t  /* D allows casting a static array to any static array type.  */\n \t  return build_nop (build_ctype (totype), exp);\n \t}\n-      else if (tbtype->ty == Tstruct)\n+      else if (tbtype->ty == TY::Tstruct)\n \t{\n \t  /* And allows casting a static array to any struct type too.\n \t     Type sizes should have already been checked by the frontend.  */\n@@ -510,22 +510,31 @@ convert_expr (tree exp, Type *etype, Type *totype)\n \t}\n       break;\n \n-    case Tarray:\n-      if (tbtype->ty == Tpointer)\n+    case TY::Tarray:\n+      if (tbtype->ty == TY::Tpointer)\n \t{\n \t  return d_convert (build_ctype (totype), d_array_ptr (exp));\n \t}\n-      else if (tbtype->ty == Tarray)\n+      else if (tbtype->ty == TY::Tarray)\n \t{\n \t  /* Assume tvoid->size() == 1.  */\n \t  d_uns64 fsize = ebtype->nextOf ()->toBasetype ()->size ();\n \t  d_uns64 tsize = tbtype->nextOf ()->toBasetype ()->size ();\n \n \t  if (fsize != tsize)\n \t    {\n-\t      /* Conversion requires a reinterpret cast of array.  */\n-\t      return build_libcall (LIBCALL_ARRAYCAST, totype, 3,\n-\t\t\t\t    size_int (tsize), size_int (fsize), exp);\n+\t      /* Conversion requires a reinterpret cast of array.\n+\t\t This case should have been lowered in the semantic pass.  */\n+\t      if (tsize != 0 && fsize % tsize == 0)\n+\t\t{\n+\t\t  /* Set array dimension to (length * (fsize / tsize)).  */\n+\t\t  tree newlength = size_mult_expr (d_array_length (exp),\n+\t\t\t\t\t\t   size_int (fsize / tsize));\n+\t\t  return d_array_value (build_ctype (totype), newlength,\n+\t\t\t\t\td_array_ptr (exp));\n+\t\t}\n+\t      else\n+\t\tgcc_unreachable ();\n \t    }\n \t  else\n \t    {\n@@ -534,7 +543,7 @@ convert_expr (tree exp, Type *etype, Type *totype)\n \t      return build_vconvert (build_ctype (totype), exp);\n \t    }\n \t}\n-      else if (tbtype->ty == Tsarray)\n+      else if (tbtype->ty == TY::Tsarray)\n \t{\n \t  /* Strings are treated as dynamic arrays in D2.  */\n \t  if (ebtype->isString () && tbtype->isString ())\n@@ -548,23 +557,23 @@ convert_expr (tree exp, Type *etype, Type *totype)\n \t}\n       break;\n \n-    case Taarray:\n-      if (tbtype->ty == Taarray)\n+    case TY::Taarray:\n+      if (tbtype->ty == TY::Taarray)\n \treturn build_vconvert (build_ctype (totype), exp);\n       /* Can convert associative arrays to void pointers.  */\n-      else if (tbtype->ty == Tpointer && tbtype->nextOf ()->ty == Tvoid)\n+      else if (tbtype->ty == TY::Tpointer && tbtype->nextOf ()->ty == TY::Tvoid)\n \treturn build_vconvert (build_ctype (totype), exp);\n       /* Else, default conversion, which should product an error.  */\n       break;\n \n-    case Tpointer:\n+    case TY::Tpointer:\n       /* Can convert void pointers to associative arrays too.  */\n-      if (tbtype->ty == Taarray && ebtype->nextOf ()->ty == Tvoid)\n+      if (tbtype->ty == TY::Taarray && ebtype->nextOf ()->ty == TY::Tvoid)\n \treturn build_vconvert (build_ctype (totype), exp);\n       break;\n \n-    case Tnull:\n-    case Tnoreturn:\n+    case TY::Tnull:\n+    case TY::Tnoreturn:\n       /* Casting from `typeof(null)' for `null' expressions, or `typeof(*null)'\n \t for `noreturn' expressions is represented as all zeros.  */\n       result = build_typeof_null_value (totype);\n@@ -574,8 +583,8 @@ convert_expr (tree exp, Type *etype, Type *totype)\n \tresult = compound_expr (exp, result);\n       break;\n \n-    case Tvector:\n-      if (tbtype->ty == Tsarray)\n+    case TY::Tvector:\n+      if (tbtype->ty == TY::Tsarray)\n \t{\n \t  if (tbtype->size () == ebtype->size ())\n \t    return build_vconvert (build_ctype (totype), exp);\n@@ -613,7 +622,7 @@ convert_for_rvalue (tree expr, Type *etype, Type *totype)\n   Type *ebtype = etype->toBasetype ();\n   Type *tbtype = totype->toBasetype ();\n \n-  if (ebtype->ty == Tbool)\n+  if (ebtype->ty == TY::Tbool)\n     {\n       /* If casting from bool, the result is either 0 or 1, any other value\n \t violates @safe code, so enforce that it is never invalid.  */\n@@ -651,7 +660,7 @@ convert_for_assignment (tree expr, Type *etype, Type *totype)\n \n   /* Assuming this only has to handle converting a non Tsarray type to\n      arbitrarily dimensioned Tsarrays.  */\n-  if (tbtype->ty == Tsarray)\n+  if (tbtype->ty == TY::Tsarray)\n     {\n       Type *telem = tbtype->nextOf ()->baseElemOf ();\n \n@@ -685,7 +694,7 @@ convert_for_assignment (tree expr, Type *etype, Type *totype)\n     }\n \n   /* D Front end uses IntegerExp(0) to mean zero-init an array or structure.  */\n-  if ((tbtype->ty == Tsarray || tbtype->ty == Tstruct)\n+  if ((tbtype->ty == TY::Tsarray || tbtype->ty == TY::Tstruct)\n       && ebtype->isintegral ())\n     {\n       if (!integer_zerop (expr))\n@@ -736,12 +745,12 @@ convert_for_condition (tree expr, Type *type)\n \n   switch (type->toBasetype ()->ty)\n     {\n-    case Taarray:\n+    case TY::Taarray:\n       /* Checks that aa.ptr !is null.  */\n       result = component_ref (expr, TYPE_FIELDS (TREE_TYPE (expr)));\n       break;\n \n-    case Tarray:\n+    case TY::Tarray:\n       {\n \t/* Checks (arr.length || arr.ptr) (i.e arr !is null).  */\n \texpr = d_save_expr (expr);\n@@ -762,7 +771,7 @@ convert_for_condition (tree expr, Type *type)\n \tbreak;\n       }\n \n-    case Tdelegate:\n+    case TY::Tdelegate:\n       {\n \t/* Checks (function || object), but what good is it if there is\n \t   a null function pointer?  */\n@@ -783,7 +792,7 @@ convert_for_condition (tree expr, Type *type)\n \tbreak;\n       }\n \n-    case Tnoreturn:\n+    case TY::Tnoreturn:\n       /* Front-end allows conditionals that never return, represent the\n \t conditional result value as all zeros.  */\n       result = build_zero_cst (d_bool_type);\n@@ -810,10 +819,10 @@ d_array_convert (Expression *exp)\n {\n   Type *tb = exp->type->toBasetype ();\n \n-  if (tb->ty == Tarray)\n+  if (tb->ty == TY::Tarray)\n     return build_expr (exp);\n \n-  if (tb->ty == Tsarray)\n+  if (tb->ty == TY::Tsarray)\n     {\n       Type *totype = tb->nextOf ()->arrayOf ();\n       return convert_expr (build_expr (exp), exp->type, totype);\n@@ -832,7 +841,8 @@ d_array_convert (Type *etype, Expression *exp)\n {\n   Type *tb = exp->type->toBasetype ();\n \n-  if ((tb->ty != Tarray && tb->ty != Tsarray) || same_type_p (tb, etype))\n+  if ((tb->ty != TY::Tarray && tb->ty != TY::Tsarray)\n+      || same_type_p (tb, etype))\n     {\n       /* Convert single element to an array.  */\n       tree expr = build_expr (exp);"}, {"sha": "947b6e21d60da004a9e443b8fa315b70648f9503", "filename": "gcc/d/d-diagnostic.cc", "status": "modified", "additions": 5, "deletions": 70, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fd-diagnostic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fd-diagnostic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-diagnostic.cc?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -222,15 +222,6 @@ d_diagnostic_report_diagnostic (const Loc &loc, int opt, const char *format,\n    message prefix PREFIX1 and PREFIX2, increasing the global or gagged\n    error count.  */\n \n-void ATTRIBUTE_GCC_DIAG(2,3)\n-error (const Loc &loc, const char *format, ...)\n-{\n-  va_list ap;\n-  va_start (ap, format);\n-  verror (loc, format, ap);\n-  va_end (ap);\n-}\n-\n void ATTRIBUTE_GCC_DIAG(2,0)\n verror (const Loc &loc, const char *format, va_list ap,\n \tconst char *prefix1, const char *prefix2, const char *)\n@@ -263,15 +254,6 @@ verror (const Loc &loc, const char *format, va_list ap,\n /* Print supplementary message about the last error with explicit location LOC.\n    This doesn't increase the global error count.  */\n \n-void ATTRIBUTE_GCC_DIAG(2,3)\n-errorSupplemental (const Loc &loc, const char *format, ...)\n-{\n-  va_list ap;\n-  va_start (ap, format);\n-  verrorSupplemental (loc, format, ap);\n-  va_end (ap);\n-}\n-\n void ATTRIBUTE_GCC_DIAG(2,0)\n verrorSupplemental (const Loc &loc, const char *format, va_list ap)\n {\n@@ -284,15 +266,6 @@ verrorSupplemental (const Loc &loc, const char *format, va_list ap)\n /* Print a warning message with explicit location LOC, increasing the\n    global warning count.  */\n \n-void ATTRIBUTE_GCC_DIAG(2,3)\n-warning (const Loc &loc, const char *format, ...)\n-{\n-  va_list ap;\n-  va_start (ap, format);\n-  vwarning (loc, format, ap);\n-  va_end (ap);\n-}\n-\n void ATTRIBUTE_GCC_DIAG(2,0)\n vwarning (const Loc &loc, const char *format, va_list ap)\n {\n@@ -311,15 +284,6 @@ vwarning (const Loc &loc, const char *format, va_list ap)\n /* Print supplementary message about the last warning with explicit location\n    LOC.  This doesn't increase the global warning count.  */\n \n-void ATTRIBUTE_GCC_DIAG(2,3)\n-warningSupplemental (const Loc &loc, const char *format, ...)\n-{\n-  va_list ap;\n-  va_start (ap, format);\n-  vwarningSupplemental (loc, format, ap);\n-  va_end (ap);\n-}\n-\n void ATTRIBUTE_GCC_DIAG(2,0)\n vwarningSupplemental (const Loc &loc, const char *format, va_list ap)\n {\n@@ -333,15 +297,6 @@ vwarningSupplemental (const Loc &loc, const char *format, va_list ap)\n    message prefix PREFIX1 and PREFIX2, increasing the global warning or\n    error count depending on how deprecations are treated.  */\n \n-void ATTRIBUTE_GCC_DIAG(2,3)\n-deprecation (const Loc &loc, const char *format, ...)\n-{\n-  va_list ap;\n-  va_start (ap, format);\n-  vdeprecation (loc, format, ap);\n-  va_end (ap);\n-}\n-\n void ATTRIBUTE_GCC_DIAG(2,0)\n vdeprecation (const Loc &loc, const char *format, va_list ap,\n \t      const char *prefix1, const char *prefix2)\n@@ -372,15 +327,6 @@ vdeprecation (const Loc &loc, const char *format, va_list ap,\n /* Print supplementary message about the last deprecation with explicit\n    location LOC.  This does not increase the global error count.  */\n \n-void ATTRIBUTE_GCC_DIAG(2,3)\n-deprecationSupplemental (const Loc &loc, const char *format, ...)\n-{\n-  va_list ap;\n-  va_start (ap, format);\n-  vdeprecationSupplemental (loc, format, ap);\n-  va_end (ap);\n-}\n-\n void ATTRIBUTE_GCC_DIAG(2,0)\n vdeprecationSupplemental (const Loc &loc, const char *format, va_list ap)\n {\n@@ -392,30 +338,19 @@ vdeprecationSupplemental (const Loc &loc, const char *format, va_list ap)\n \n /* Print a verbose message with explicit location LOC.  */\n \n-void ATTRIBUTE_GCC_DIAG(2, 3)\n-message (const Loc &loc, const char *format, ...)\n-{\n-  va_list ap;\n-  va_start (ap, format);\n-  vmessage (loc, format, ap);\n-  va_end (ap);\n-}\n-\n void ATTRIBUTE_GCC_DIAG(2,0)\n vmessage (const Loc &loc, const char *format, va_list ap)\n {\n   d_diagnostic_report_diagnostic (loc, 0, format, ap, DK_NOTE, true);\n }\n \n-/* Same as above, but doesn't take a location argument.  */\n+/* Print a tip message with prefix and highlighing.  */\n \n-void ATTRIBUTE_GCC_DIAG(1, 2)\n-message (const char *format, ...)\n+void ATTRIBUTE_GCC_DIAG(1,0)\n+vtip (const char *format, va_list ap)\n {\n-  va_list ap;\n-  va_start (ap, format);\n-  vmessage (Loc (), format, ap);\n-  va_end (ap);\n+  if (!global.gag)\n+    d_diagnostic_report_diagnostic (Loc (), 0, format, ap, DK_DEBUG, true);\n }\n \n /* Call this after printing out fatal error messages to clean up and"}, {"sha": "522095f12c56f478734883d86f7482ea3c8bc6f9", "filename": "gcc/d/d-frontend.cc", "status": "modified", "additions": 3, "deletions": 116, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fd-frontend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fd-frontend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-frontend.cc?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -27,124 +27,19 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dmd/scope.h\"\n \n #include \"tree.h\"\n-#include \"options.h\"\n #include \"fold-const.h\"\n #include \"diagnostic.h\"\n \n #include \"d-tree.h\"\n \n-\n-/* Implements the Global interface defined by the frontend.\n-   Used for managing the state of the current compilation.  */\n-\n-Global global;\n-\n-void\n-Global::_init (void)\n-{\n-  this->mars_ext = \"d\";\n-  this->hdr_ext  = \"di\";\n-  this->doc_ext  = \"html\";\n-  this->ddoc_ext = \"ddoc\";\n-  this->json_ext = \"json\";\n-  this->obj_ext = \"o\";\n-\n-  this->run_noext = true;\n-  this->version = \"v\"\n-#include \"verstr.h\"\n-    ;\n-\n-  this->stdmsg = stderr;\n-}\n-\n-/* Start gagging. Return the current number of gagged errors.  */\n-\n-unsigned\n-Global::startGagging (void)\n-{\n-  this->gag++;\n-  return this->gaggedErrors;\n-}\n-\n-/* End gagging, restoring the old gagged state.  Return true if errors\n-   occured while gagged.  */\n-\n-bool\n-Global::endGagging (unsigned oldGagged)\n-{\n-  bool anyErrs = (this->gaggedErrors != oldGagged);\n-  this->gag--;\n-\n-  /* Restore the original state of gagged errors; set total errors\n-     to be original errors + new ungagged errors.  */\n-  this->errors -= (this->gaggedErrors - oldGagged);\n-  this->gaggedErrors = oldGagged;\n-\n-  return anyErrs;\n-}\n-\n-/* Increment the error count to record that an error has occured in the\n-   current context.  An error message may or may not have been printed.  */\n-\n-void\n-Global::increaseErrorCount (void)\n-{\n-  if (gag)\n-    this->gaggedErrors++;\n-\n-  this->errors++;\n-}\n-\n-\n-/* Implements the Loc interface defined by the frontend.\n-   Used for keeping track of current file/line position in code.  */\n-\n-Loc::Loc (const char *filename, unsigned linnum, unsigned charnum)\n-{\n-  this->linnum = linnum;\n-  this->charnum = charnum;\n-  this->filename = filename;\n-}\n-\n-const char *\n-Loc::toChars (void) const\n-{\n-  OutBuffer buf;\n-\n-  if (this->filename)\n-    buf.printf (\"%s\", this->filename);\n-\n-  if (this->linnum)\n-    {\n-      buf.printf (\":%u\", this->linnum);\n-      if (this->charnum)\n-\tbuf.printf (\":%u\", this->charnum);\n-    }\n-\n-  return buf.extractChars ();\n-}\n-\n-bool\n-Loc::equals (const Loc &loc)\n-{\n-  if (this->linnum != loc.linnum || this->charnum != loc.charnum)\n-    return false;\n-\n-  if (!FileName::equals (this->filename, loc.filename))\n-    return false;\n-\n-  return true;\n-}\n-\n-\n /* Implements back-end specific interfaces used by the frontend.  */\n \n /* Determine if function FD is a builtin one that we can evaluate in CTFE.  */\n \n BUILTIN\n isBuiltin (FuncDeclaration *fd)\n {\n-  if (fd->builtin != BUILTINunknown)\n+  if (fd->builtin != BUILTIN::unknown)\n     return fd->builtin;\n \n   maybe_set_intrinsic (fd);\n@@ -158,7 +53,7 @@ isBuiltin (FuncDeclaration *fd)\n Expression *\n eval_builtin (Loc loc, FuncDeclaration *fd, Expressions *arguments)\n {\n-  if (fd->builtin == BUILTINunimp)\n+  if (fd->builtin == BUILTIN::unimp)\n     return NULL;\n \n   tree decl = get_symbol_decl (fd);\n@@ -185,16 +80,8 @@ eval_builtin (Loc loc, FuncDeclaration *fd, Expressions *arguments)\n Type *\n getTypeInfoType (Loc loc, Type *type, Scope *sc)\n {\n-  gcc_assert (type->ty != Terror);\n+  gcc_assert (type->ty != TY::Terror);\n   check_typeinfo_type (loc, sc);\n   create_typeinfo (type, sc ? sc->_module->importedFrom : NULL);\n   return type->vtinfo->type;\n }\n-\n-/* Return an inlined copy of a default argument for a function parameter.  */\n-\n-Expression *\n-inlineCopy (Expression *e, Scope *)\n-{\n-  return e->copy ();\n-}"}, {"sha": "3edf812212a9de07da086787f72a903076393552", "filename": "gcc/d/d-frontend.h", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fd-frontend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fd-frontend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-frontend.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -0,0 +1,37 @@\n+/* d-frontend.h -- D frontend interface to the gcc back-end.\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_D_FRONTEND_H\n+#define GCC_D_FRONTEND_H\n+\n+/* These functions are defined in D runtime.  */\n+extern \"C\" int rt_init (void);\n+extern \"C\" int rt_term (void);\n+//extern \"C\" void gc_disable (void);\n+extern \"C\" void *gc_malloc (size_t sz, unsigned ba = 0, const void *ti = NULL);\n+extern \"C\" void gc_free (void *);\n+extern \"C\" void gc_collect (void);\n+\n+template<typename T>\n+inline T *\n+d_gc_malloc (void)\n+{\n+  void *ptr = gc_malloc (sizeof (T));\n+  return new(ptr) T ();\n+}\n+\n+#endif"}, {"sha": "9a65622229b5333070214f70ed9a5fdecf387743", "filename": "gcc/d/d-incpath.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fd-incpath.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fd-incpath.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-incpath.cc?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -20,6 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n \n #include \"dmd/globals.h\"\n+#include \"d-frontend.h\"\n \n #include \"cppdefault.h\"\n \n@@ -71,7 +72,7 @@ add_globalpaths (Strings *paths)\n   if (paths)\n     {\n       if (!global.path)\n-\tglobal.path = new Strings ();\n+\tglobal.path = d_gc_malloc<Strings> ();\n \n       for (size_t i = 0; i < paths->length; i++)\n \t{\n@@ -98,7 +99,7 @@ add_filepaths (Strings *paths)\n   if (paths)\n     {\n       if (!global.filePath)\n-\tglobal.filePath = new Strings ();\n+\tglobal.filePath = d_gc_malloc<Strings> ();\n \n       for (size_t i = 0; i < paths->length; i++)\n \t{"}, {"sha": "d20370e5d8a60bd01964da5de3b0028a19bd929b", "filename": "gcc/d/d-lang.cc", "status": "modified", "additions": 207, "deletions": 80, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fd-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fd-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-lang.cc?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -26,12 +26,13 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dmd/errors.h\"\n #include \"dmd/expression.h\"\n #include \"dmd/hdrgen.h\"\n+#include \"dmd/id.h\"\n #include \"dmd/identifier.h\"\n #include \"dmd/json.h\"\n #include \"dmd/mangle.h\"\n-#include \"dmd/mars.h\"\n #include \"dmd/module.h\"\n #include \"dmd/mtype.h\"\n+#include \"dmd/root/file.h\"\n #include \"dmd/target.h\"\n \n #include \"opts.h\"\n@@ -53,7 +54,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"input.h\"\n \n #include \"d-tree.h\"\n-#include \"id.h\"\n+#include \"d-frontend.h\"\n \n \n /* Array of D frontend type/decl nodes.  */\n@@ -83,10 +84,6 @@ d_option;\n /* List of modules being compiled.  */\n static Modules builtin_modules;\n \n-/* Module where `C main' is defined, compiled in if needed.  */\n-static Module *entrypoint_module = NULL;\n-static Module *entrypoint_root_module = NULL;\n-\n /* The current and global binding level in effect.  */\n struct binding_level *current_binding_level;\n struct binding_level *global_binding_level;\n@@ -202,7 +199,7 @@ deps_write (Module *module, obstack *buffer)\n \tdeps_write_string (d_option.deps_target[i], buffer, column);\n     }\n   else\n-    deps_write_string (module->objfile->name->str, buffer, column);\n+    deps_write_string (module->objfile.toChars (), buffer, column);\n \n   obstack_1grow (buffer, ':');\n   column++;\n@@ -212,7 +209,7 @@ deps_write (Module *module, obstack *buffer)\n     {\n       Module *depmod = modlist.pop ();\n \n-      const char *modstr = depmod->srcfile->name->str;\n+      const char *modstr = depmod->srcfile.toChars ();\n \n       /* Skip modules that have already been looked at.  */\n       if (seen_modules.add (modstr))\n@@ -238,9 +235,7 @@ deps_write (Module *module, obstack *buffer)\n \t  Module *m = depmod->aimports[i];\n \n \t  /* Ignore compiler-generated modules.  */\n-\t  if ((m->ident == Identifier::idPool (\"__entrypoint\")\n-\t       || m->ident == Identifier::idPool (\"__main\"))\n-\t      && m->parent == NULL)\n+\t  if (m->ident == Identifier::idPool (\"__main\") && m->parent == NULL)\n \t    continue;\n \n \t  /* Don't search system installed modules, this includes\n@@ -251,9 +246,9 @@ deps_write (Module *module, obstack *buffer)\n \t\t  && m->parent == NULL)\n \t\tcontinue;\n \n-\t      if (m->md && m->md->packages)\n+\t      if (m->md && m->md->packages.length)\n \t\t{\n-\t\t  Identifier *package = (*m->md->packages)[0];\n+\t\t  Identifier *package = m->md->packages.ptr[0];\n \n \t\t  if (package == Identifier::idPool (\"core\")\n \t\t      || package == Identifier::idPool (\"std\")\n@@ -291,27 +286,15 @@ deps_write (Module *module, obstack *buffer)\n static void\n d_init_options (unsigned int, cl_decoded_option *decoded_options)\n {\n+  /* Initialize the D runtime.  */\n+  rt_init ();\n+//  gc_disable ();\n+\n   /* Set default values.  */\n   global._init ();\n \n   global.vendor = lang_hooks.name;\n   global.params.argv0 = xstrdup (decoded_options[0].arg);\n-  global.params.link = true;\n-  global.params.useAssert = CHECKENABLEdefault;\n-  global.params.useInvariants = CHECKENABLEdefault;\n-  global.params.useIn = CHECKENABLEdefault;\n-  global.params.useOut = CHECKENABLEdefault;\n-  global.params.useArrayBounds = CHECKENABLEdefault;\n-  global.params.useSwitchError = CHECKENABLEdefault;\n-  global.params.checkAction = CHECKACTION_D;\n-  global.params.useModuleInfo = true;\n-  global.params.useTypeInfo = true;\n-  global.params.useExceptions = true;\n-  global.params.useInline = false;\n-  global.params.obj = true;\n-  global.params.hdrStripPlainFunctions = true;\n-  global.params.betterC = false;\n-  global.params.allInst = false;\n   global.params.errorLimit = flag_max_errors;\n \n   /* Default extern(C++) mangling to C++14.  */\n@@ -320,9 +303,10 @@ d_init_options (unsigned int, cl_decoded_option *decoded_options)\n   /* Warnings and deprecations are disabled by default.  */\n   global.params.useDeprecated = DIAGNOSTICinform;\n   global.params.warnings = DIAGNOSTICoff;\n+  global.params.messageStyle = MESSAGESTYLEgnu;\n \n-  global.params.imppath = new Strings ();\n-  global.params.fileImppath = new Strings ();\n+  global.params.imppath = d_gc_malloc<Strings> ();\n+  global.params.fileImppath = d_gc_malloc<Strings> ();\n \n   /* Extra GDC-specific options.  */\n   d_option.fonly = NULL;\n@@ -462,6 +446,11 @@ d_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,\n \t: (value == 1) ? CHECKENABLEsafeonly : CHECKENABLEoff;\n       break;\n \n+    case OPT_fcheckaction_:\n+      global.params.checkAction = (value == 0) ? CHECKACTION_D\n+\t: (value == 1) ? CHECKACTION_halt : CHECKACTION_context;\n+      break;\n+\n     case OPT_fdebug:\n       global.params.debuglevel = value ? 1 : 0;\n       break;\n@@ -480,7 +469,7 @@ d_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,\n       if (Identifier::isValidIdentifier (CONST_CAST (char *, arg)))\n \t{\n \t  if (!global.params.debugids)\n-\t    global.params.debugids = new Strings ();\n+\t    global.params.debugids = d_gc_malloc<Strings> ();\n \t  global.params.debugids->push (arg);\n \t  break;\n \t}\n@@ -510,6 +499,16 @@ d_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,\n       global.params.betterC = !value;\n       break;\n \n+    case OPT_fdump_c___spec_:\n+      if (global.params.doCxxHdrGeneration == CxxHeaderMode::none)\n+\tglobal.params.doCxxHdrGeneration = CxxHeaderMode::silent;\n+      global.params.cxxhdrname = arg;\n+      break;\n+\n+    case OPT_fdump_c___spec_verbose:\n+      global.params.doCxxHdrGeneration = CxxHeaderMode::verbose;\n+      break;\n+\n     case OPT_fdump_d_original:\n       global.params.vcg_ast = value;\n       break;\n@@ -518,6 +517,22 @@ d_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,\n       global.params.useExceptions = value;\n       break;\n \n+    case OPT_fextern_std_:\n+      switch (value)\n+\t{\n+\tcase CppStdRevisionCpp98:\n+\tcase CppStdRevisionCpp11:\n+\tcase CppStdRevisionCpp14:\n+\tcase CppStdRevisionCpp17:\n+\tcase CppStdRevisionCpp20:\n+\t  global.params.cplusplus = (CppStdRevision) value;\n+\t  break;\n+\n+\tdefault:\n+\t  error (\"bad argument for %<-fextern-std%>: %qs\", arg);\n+\t}\n+      break;\n+\n     case OPT_fignore_unknown_pragmas:\n       global.params.ignoreUnsupportedPragmas = value;\n       break;\n@@ -552,35 +567,115 @@ d_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,\n       global.params.useIn = value ? CHECKENABLEon : CHECKENABLEoff;\n       break;\n \n+    case OPT_fpreview_all:\n+      global.params.ehnogc = value;\n+      global.params.useDIP25 = FeatureState::enabled;\n+      global.params.useDIP1000 = FeatureState::enabled;\n+      global.params.useDIP1021 = value;\n+      global.params.dtorFields = FeatureState::enabled;\n+      global.params.fieldwise = value;\n+      global.params.fixAliasThis = value;\n+      global.params.previewIn = value;\n+      global.params.fix16997 = value;\n+      global.params.markdown = value;\n+      global.params.noSharedAccess = value;\n+      global.params.rvalueRefParam = value;\n+      global.params.inclusiveInContracts = value;\n+      global.params.shortenedMethods = value;\n+      break;\n+\n+    case OPT_fpreview_dip1000:\n+      global.params.useDIP1000 = FeatureState::enabled;\n+      break;\n+\n+    case OPT_fpreview_dip1008:\n+      global.params.ehnogc = value;\n+      break;\n+\n+    case OPT_fpreview_dip1021:\n+      global.params.useDIP1021 = value;\n+      break;\n+\n+    case OPT_fpreview_dip25:\n+      global.params.useDIP25 = FeatureState::enabled;\n+      break;\n+\n+    case OPT_fpreview_dtorfields:\n+      global.params.dtorFields = FeatureState::enabled;\n+      break;\n+\n+    case OPT_fpreview_fieldwise:\n+      global.params.fieldwise = value;\n+      break;\n+\n+    case OPT_fpreview_fixaliasthis:\n+      global.params.fixAliasThis = value;\n+      break;\n+\n+    case OPT_fpreview_in:\n+      global.params.previewIn = value;\n+      break;\n+\n+    case OPT_fpreview_inclusiveincontracts:\n+      global.params.inclusiveInContracts = value;\n+      break;\n+\n+    case OPT_fpreview_intpromote:\n+      global.params.fix16997 = value;\n+      break;\n+\n+    case OPT_fpreview_nosharedaccess:\n+      global.params.noSharedAccess = value;\n+      break;\n+\n+    case OPT_fpreview_rvaluerefparam:\n+      global.params.rvalueRefParam = value;\n+      break;\n+\n+    case OPT_fpreview_shortenedmethods:\n+      global.params.shortenedMethods = value;\n+      break;\n+\n     case OPT_frelease:\n       global.params.release = value;\n       break;\n \n-    case OPT_frtti:\n-      global.params.useTypeInfo = value;\n+    case OPT_frevert_all:\n+      global.params.useDIP25 = FeatureState::disabled;\n+      global.params.markdown = !value;\n+      global.params.dtorFields = FeatureState::disabled;\n       break;\n \n-    case OPT_fswitch_errors:\n-      global.params.useSwitchError = value ? CHECKENABLEon : CHECKENABLEoff;\n+    case OPT_frevert_dip25:\n+      global.params.useDIP25 = FeatureState::disabled;\n       break;\n \n-    case OPT_ftransition_all:\n-      global.params.vtls = value;\n-      global.params.vfield = value;\n-      global.params.vcomplex = value;\n+    case OPT_frevert_dtorfields:\n+      global.params.dtorFields = FeatureState::disabled;\n+      break;\n+\n+    case OPT_frevert_markdown:\n+      global.params.markdown = !value;\n       break;\n \n-    case OPT_ftransition_complex:\n-      global.params.vcomplex = value;\n+    case OPT_frtti:\n+      global.params.useTypeInfo = value;\n       break;\n \n-    case OPT_ftransition_dip1000:\n-      global.params.vsafe = value;\n-      global.params.useDIP25 = value;\n+    case OPT_fsave_mixins_:\n+      global.params.mixinFile = arg;\n+      global.params.mixinOut = d_gc_malloc<OutBuffer> ();\n       break;\n \n-    case OPT_ftransition_dip25:\n-      global.params.useDIP25 = value;\n+    case OPT_fswitch_errors:\n+      global.params.useSwitchError = value ? CHECKENABLEon : CHECKENABLEoff;\n+      break;\n+\n+    case OPT_ftransition_all:\n+      global.params.vfield = value;\n+      global.params.vgc = value;\n+      global.params.vmarkdown= value;\n+      global.params.vtls = value;\n       break;\n \n     case OPT_ftransition_field:\n@@ -591,6 +686,14 @@ d_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,\n       global.params.vgc = value;\n       break;\n \n+    case OPT_ftransition_vmarkdown:\n+      global.params.vmarkdown = value;\n+      break;\n+\n+    case OPT_ftransition_templates:\n+      global.params.vtemplates = value;\n+      break;\n+\n     case OPT_ftransition_tls:\n       global.params.vtls = value;\n       break;\n@@ -613,7 +716,7 @@ d_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,\n       if (Identifier::isValidIdentifier (CONST_CAST (char *, arg)))\n \t{\n \t  if (!global.params.versionids)\n-\t    global.params.versionids = new Strings ();\n+\t    global.params.versionids = d_gc_malloc<Strings> ();\n \t  global.params.versionids->push (arg);\n \t  break;\n \t}\n@@ -804,6 +907,14 @@ d_post_options (const char ** fn)\n       global.params.checkAction = CHECKACTION_C;\n     }\n \n+  /* Enabling DIP1021 implies DIP1000.  */\n+  if (global.params.useDIP1021)\n+    global.params.useDIP1000 = FeatureState::enabled;\n+\n+  /* Enabling DIP1000 implies DIP25.  */\n+  if (global.params.useDIP1000 == FeatureState::enabled)\n+    global.params.useDIP25 = FeatureState::enabled;\n+\n   /* Keep in sync with existing -fbounds-check flag.  */\n   flag_bounds_check = (global.params.useArrayBounds == CHECKENABLEon);\n \n@@ -828,6 +939,7 @@ d_post_options (const char ** fn)\n   global.params.symdebug = write_symbols != NO_DEBUG;\n   global.params.useInline = flag_inline_functions;\n   global.params.showColumns = flag_show_column;\n+  global.params.printErrorContext = flag_diagnostics_show_caret;\n \n   if (global.params.useInline)\n     global.params.hdrStripPlainFunctions = false;\n@@ -872,17 +984,6 @@ d_add_builtin_module (Module *m)\n   builtin_modules.push (m);\n }\n \n-/* Record the entrypoint module ENTRY which will be compiled in the current\n-   compilation.  ROOT is the module scope where this was requested from.  */\n-\n-void\n-d_add_entrypoint_module (Module *entry, Module *root)\n-{\n-  /* We are emitting this straight to object file.  */\n-  entrypoint_module = entry;\n-  entrypoint_root_module = root;\n-}\n-\n /* Implements the lang_hooks.parse_file routine for language D.  */\n \n static void\n@@ -891,7 +992,7 @@ d_parse_file (void)\n   if (global.params.verbose)\n     {\n       message (\"binary    %s\", global.params.argv0.ptr);\n-      message (\"version   %s\", global.version.ptr);\n+      message (\"version   %s\", global.versionChars ());\n \n       if (global.versionids)\n \t{\n@@ -955,16 +1056,16 @@ d_parse_file (void)\n \n \t  /* Handling stdin, generate a unique name for the module.  */\n \t  Module *m = Module::create (in_fnames[i],\n-\t\t\t\t      Identifier::generateId (\"__stdin\"),\n+\t\t\t\t      Identifier::idPool (\"__stdin\"),\n \t\t\t\t      global.params.doDocComments,\n \t\t\t\t      global.params.doHdrGeneration);\n \t  modules.push (m);\n \n \t  /* Overwrite the source file for the module, the one created by\n \t     Module::create would have a forced a `.d' suffix.  */\n-\t  m->srcfile = File::create (\"<stdin>\");\n-\t  m->srcfile->len = len;\n-\t  m->srcfile->buffer = buffer;\n+\t  m->srcBuffer = FileBuffer::create ();\n+\t  m->srcBuffer->data.length = len;\n+\t  m->srcBuffer->data.ptr = buffer;\n \t}\n       else\n \t{\n@@ -1011,15 +1112,16 @@ d_parse_file (void)\n     }\n \n   /* Load the module containing D main.  */\n+  Module *main_module = NULL;\n   if (global.params.addMain)\n     {\n       unsigned errors = global.startGagging ();\n-      Module *m = Module::load (Loc (), NULL, Identifier::idPool (\"__main\"));\n+      main_module = Module::load (Loc (), NULL, Identifier::idPool (\"__main\"));\n \n       if (!global.endGagging (errors))\n \t{\n-\t  m->importedFrom = m;\n-\t  modules.push (m);\n+\t  main_module->importedFrom = main_module;\n+\t  modules.push (main_module);\n \t}\n     }\n \n@@ -1038,7 +1140,7 @@ d_parse_file (void)\n       for (size_t i = 0; i < modules.length; i++)\n \t{\n \t  Module *m = modules[i];\n-\t  if (d_option.fonly && m != Module::rootModule)\n+\t  if (m->isHdrFile || (d_option.fonly && m != Module::rootModule))\n \t    continue;\n \n \t  if (global.params.verbose)\n@@ -1203,7 +1305,7 @@ d_parse_file (void)\n       if (name && (name[0] != '-' || name[1] != '\\0'))\n \t{\n \t  const char *nameext\n-\t    = FileName::defaultExt (name, global.json_ext.ptr);\n+\t    = FileName::defaultExt (name, json_ext.ptr);\n \t  json_stream = fopen (nameext, \"w\");\n \t  if (!json_stream)\n \t    {\n@@ -1245,22 +1347,25 @@ d_parse_file (void)\n \t}\n     }\n \n+  /* Generate C++ header files.  */\n+  if (global.params.doCxxHdrGeneration != CxxHeaderMode::none)\n+    genCppHdrFiles (modules);\n+\n+  if (global.errors)\n+    goto had_errors;\n+\n   for (size_t i = 0; i < modules.length; i++)\n     {\n       Module *m = modules[i];\n-      if (d_option.fonly && m != Module::rootModule)\n+      if ((m->isHdrFile && m != main_module)\n+\t  || (d_option.fonly && m != Module::rootModule))\n \tcontinue;\n \n       if (global.params.verbose)\n \tmessage (\"code      %s\", m->toChars ());\n \n       if (!flag_syntax_only)\n-\t{\n-\t  if ((entrypoint_module != NULL) && (m == entrypoint_root_module))\n-\t    build_decl_tree (entrypoint_module);\n-\n-\t  build_decl_tree (m);\n-\t}\n+\tbuild_decl_tree (m);\n     }\n \n   /* And end the main input file, if the debug writer wants it.  */\n@@ -1272,16 +1377,37 @@ d_parse_file (void)\n      exit with an error status.  */\n   errorcount += (global.errors + global.warnings);\n \n+  /* We want to write the mixin expansion file also on error.  */\n+  if (global.params.mixinOut)\n+    {\n+      FILE *mixin_stream = fopen (global.params.mixinFile, \"w\");\n+\n+      if (mixin_stream)\n+\t{\n+\t  OutBuffer *buf = global.params.mixinOut;\n+\t  fprintf (mixin_stream, \"%s\", buf->peekChars ());\n+\n+\t  if (ferror (mixin_stream) || fclose (mixin_stream))\n+\t    fatal_error (input_location, \"closing mixin file %s: %m\",\n+\t\t\t global.params.mixinFile);\n+\t}\n+      else\n+\t{\n+\t  fatal_error (input_location, \"opening mixin file %s: %m\",\n+\t\t       global.params.mixinFile);\n+\t}\n+    }\n+\n   /* Remove generated .di files on error.  */\n   if (errorcount && dump_headers)\n     {\n       for (size_t i = 0; i < modules.length; i++)\n \t{\n \t  Module *m = modules[i];\n-\t  if (d_option.fonly && m != Module::rootModule)\n+\t  if (m->isHdrFile || (d_option.fonly && m != Module::rootModule))\n \t    continue;\n \n-\t  remove (m->hdrfile->toChars ());\n+\t  remove (m->hdrfile.toChars ());\n \t}\n     }\n \n@@ -1406,7 +1532,7 @@ d_type_promotes_to (tree type)\n   /* Promotions are only applied on unnamed function arguments for declarations\n      with `extern(C)' or `extern(C++)' linkage.  */\n   if (cfun && DECL_LANG_FRONTEND (cfun->decl)\n-      && DECL_LANG_FRONTEND (cfun->decl)->linkage != LINKd)\n+      && DECL_LANG_FRONTEND (cfun->decl)->linkage != LINK::d)\n     {\n       /* In [type/integer-promotions], integer promotions are conversions of the\n \t following types:\n@@ -1559,7 +1685,8 @@ d_types_compatible_p (tree x, tree y)\n \treturn true;\n \n       /* Type system allows implicit conversion between.  */\n-      if (tx->implicitConvTo (ty) || ty->implicitConvTo (tx))\n+      if (tx->implicitConvTo (ty) != MATCH::nomatch\n+\t  || ty->implicitConvTo (tx) != MATCH::nomatch)\n \treturn true;\n     }\n "}, {"sha": "27c8d17a065166d128d41e8ac7a2f1d843d46baa", "filename": "gcc/d/d-longdouble.cc", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fd-longdouble.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fd-longdouble.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-longdouble.cc?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -30,12 +30,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"longdouble.h\"\n \n \n-/* Constant real values 0, 1, -1 and 0.5.  */\n-real_t CTFloat::zero;\n-real_t CTFloat::one;\n-real_t CTFloat::minusone;\n-real_t CTFloat::half;\n-\n /* Truncate longdouble to the highest precision supported by target.  */\n \n longdouble"}, {"sha": "d7a0079ecf32bfea7cdcfc59c3d1c2cd2ab6921b", "filename": "gcc/d/d-system.h", "status": "modified", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fd-system.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fd-system.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-system.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -26,60 +26,8 @@\n #endif\n #include \"system.h\"\n \n-/* Used by the dmd front-end to determine if we have POSIX-style IO.  */\n-#define POSIX (__linux__ || __GLIBC__ || __gnu_hurd__ || __APPLE__ \\\n-\t       || __FreeBSD__ || __NetBSD__ || __OpenBSD__ || __DragonFly__ \\\n-\t       || __sun || __unix__)\n-\n /* Forward assert invariants to gcc_assert.  */\n #undef assert\n #define assert(EXPR) gcc_assert(EXPR)\n \n-/* Use libiberty's lrealpath to avoid portability problems.  */\n-#undef realpath\n-#define realpath(a, b) lrealpath((a))\n-\n-/* Forward ctype.h macros used by the dmd front-end to safe-ctype.h.  */\n-#undef isalpha\n-#define isalpha(c) ISALPHA(c)\n-#undef isalnum\n-#define isalnum(c) ISALNUM(c)\n-#undef isdigit\n-#define isdigit(c) ISDIGIT(c)\n-#undef islower\n-#define islower(c) ISLOWER(c)\n-#undef isprint\n-#define isprint(c) ISPRINT(c)\n-#undef isspace\n-#define isspace(c) ISSPACE(c)\n-#undef isupper\n-#define isupper(c) ISUPPER(c)\n-#undef isxdigit\n-#define isxdigit(c) ISXDIGIT(c)\n-#undef tolower\n-#define tolower(c) TOLOWER(c)\n-\n-/* Forward _mkdir on MinGW to mkdir in system.h.  */\n-#ifdef _WIN32\n-#undef _mkdir\n-#define _mkdir(p) mkdir(p, 0)\n-#endif\n-\n-/* Define any missing _MAX and _MIN macros.  */\n-#ifndef INT32_MAX\n-# define INT32_MAX INTTYPE_MAXIMUM (int32_t)\n-#endif\n-#ifndef INT32_MIN\n-# define INT32_MIN INTTYPE_MINIMUM (int32_t)\n-#endif\n-#ifndef INT64_MIN\n-# define INT64_MIN INTTYPE_MINIMUM (int64_t)\n-#endif\n-#ifndef UINT32_MAX\n-# define UINT32_MAX INTTYPE_MAXIMUM (uint32_t)\n-#endif\n-#ifndef UINT64_MAX\n-# define UINT64_MAX INTTYPE_MAXIMUM (uint64_t)\n-#endif\n-\n #endif  /* GCC_D_SYSTEM_H  */"}, {"sha": "21417dddf78139908e85d46575dceb1bd41e3156", "filename": "gcc/d/d-target.cc", "status": "modified", "additions": 68, "deletions": 44, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fd-target.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fd-target.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-target.cc?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -35,15 +35,14 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm.h\"\n #include \"tm_p.h\"\n #include \"target.h\"\n+#include \"calls.h\"\n \n #include \"d-tree.h\"\n #include \"d-target.h\"\n \n /* Implements the Target interface defined by the front end.\n    Used for retrieving target-specific information.  */\n \n-Target target;\n-\n /* Internal key handlers for `__traits(getTargetInfo)'.  */\n static tree d_handle_target_cpp_std (void);\n static tree d_handle_target_cpp_runtime_library (void);\n@@ -89,9 +88,6 @@ define_float_constants (T &f, tree type)\n   /* Floating-point NaN.  */\n   real_nan (&f.nan.rv (), \"\", 1, mode);\n \n-  /* Signalling floating-point NaN.  */\n-  real_nan (&f.snan.rv (), \"\", 0, mode);\n-\n   /* Floating-point +Infinity if the target supports infinities.  */\n   real_inf (&f.infinity.rv ());\n \n@@ -142,19 +138,19 @@ Target::_init (const Param &)\n   /* Define what type to use for size_t, ptrdiff_t.  */\n   if (this->ptrsize == 8)\n     {\n-      global.params.isLP64 = true;\n-      Type::tsize_t = Type::basic[Tuns64];\n-      Type::tptrdiff_t = Type::basic[Tint64];\n+      this->isLP64 = true;\n+      Type::tsize_t = Type::basic[(int)TY::Tuns64];\n+      Type::tptrdiff_t = Type::basic[(int)TY::Tint64];\n     }\n   else if (this->ptrsize == 4)\n     {\n-      Type::tsize_t = Type::basic[Tuns32];\n-      Type::tptrdiff_t = Type::basic[Tint32];\n+      Type::tsize_t = Type::basic[(int)TY::Tuns32];\n+      Type::tptrdiff_t = Type::basic[(int)TY::Tint32];\n     }\n   else if (this->ptrsize == 2)\n     {\n-      Type::tsize_t = Type::basic[Tuns16];\n-      Type::tptrdiff_t = Type::basic[Tint16];\n+      Type::tsize_t = Type::basic[(int)TY::Tuns16];\n+      Type::tptrdiff_t = Type::basic[(int)TY::Tint16];\n     }\n   else\n     sorry (\"D does not support pointers on this target.\");\n@@ -164,15 +160,7 @@ Target::_init (const Param &)\n   /* Set-up target C ABI.  */\n   this->c.longsize = int_size_in_bytes (long_integer_type_node);\n   this->c.long_doublesize = int_size_in_bytes (long_double_type_node);\n-\n-  /* Define what type to use for wchar_t.  We don't want to support wide\n-     characters less than \"short\" in D.  */\n-  if (WCHAR_TYPE_SIZE == 32)\n-    this->c.twchar_t = Type::basic[Tdchar];\n-  else if (WCHAR_TYPE_SIZE == 16)\n-    this->c.twchar_t = Type::basic[Twchar];\n-  else\n-    sorry (\"D does not support wide characters on this target.\");\n+  this->c.wchar_tsize = (WCHAR_TYPE_SIZE / BITS_PER_UNIT);\n \n   /* Set-up target C++ ABI.  */\n   this->cpp.reverseOverloads = false;\n@@ -182,6 +170,12 @@ Target::_init (const Param &)\n   /* Set-up target Objective-C ABI.  */\n   this->objc.supported = false;\n \n+  /* Set-up environmental settings.  */\n+  this->obj_ext = \"o\";\n+  this->lib_ext = \"a\";\n+  this->dll_ext = \"so\";\n+  this->run_noext = true;\n+\n   /* Initialize all compile-time properties for floating-point types.\n      Should ensure that our real_t type is able to represent real_value.  */\n   gcc_assert (sizeof (real_t) >= sizeof (real_value));\n@@ -273,7 +267,7 @@ Target::isVectorTypeSupported (int sz, Type *type)\n     type = Type::tuns8;\n \n   /* No support for non-trivial types, complex types, or booleans.  */\n-  if (!type->isTypeBasic () || type->iscomplex () || type->ty == Tbool)\n+  if (!type->isTypeBasic () || type->iscomplex () || type->ty == TY::Tbool)\n     return 2;\n \n   /* In [simd/vector extensions], which vector types are supported depends on\n@@ -293,9 +287,9 @@ Target::isVectorTypeSupported (int sz, Type *type)\n    Returns true if the operation is supported or type is not a vector.  */\n \n bool\n-Target::isVectorOpSupported (Type *type, TOK op, Type *)\n+Target::isVectorOpSupported (Type *type, unsigned op, Type *)\n {\n-  if (type->ty != Tvector)\n+  if (type->ty != TY::Tvector)\n     return true;\n \n   /* Don't support if type is non-scalar, such as __vector(void[]).  */\n@@ -322,18 +316,10 @@ Target::isVectorOpSupported (Type *type, TOK op, Type *)\n       /* Logical operators must have a result type of bool.  */\n       return false;\n \n-    case TOKue:\n-    case TOKlg:\n-    case TOKule:\n-    case TOKul:\n-    case TOKuge:\n-    case TOKug:\n     case TOKle:\n     case TOKlt:\n     case TOKge:\n     case TOKgt:\n-    case TOKleg:\n-    case TOKunord:\n     case TOKequal:\n     case TOKnotequal:\n     case TOKidentity:\n@@ -379,7 +365,8 @@ TargetCPP::thunkMangle (FuncDeclaration *fd, int offset)\n const char *\n TargetCPP::typeMangle (Type *type)\n {\n-  if (type->isTypeBasic () || type->ty == Tvector || type->ty == Tstruct)\n+  if (type->isTypeBasic () || type->ty == TY::Tvector\n+      || type->ty == TY::Tstruct)\n     {\n       tree ctype = build_ctype (type);\n       return targetm.mangle_type (ctype);\n@@ -400,14 +387,14 @@ TargetCPP::parameterType (Parameter *arg)\n   else if (arg->storageClass & STClazy)\n     {\n       /* Mangle as delegate.  */\n-      Type *td = TypeFunction::create (NULL, t, VARARGnone, LINKd);\n-      td = TypeDelegate::create (td);\n-      t = t->merge2 ();\n+      TypeFunction *tf = TypeFunction::create (NULL, t, VARARGnone, LINK::d);\n+      TypeDelegate *td = TypeDelegate::create (tf);\n+      t = td->merge2 ();\n     }\n \n   /* Could be a va_list, which we mangle as a pointer.  */\n   Type *tvalist = target.va_listType (Loc (), NULL);\n-  if (t->ty == Tsarray && tvalist->ty == Tsarray)\n+  if (t->ty == TY::Tsarray && tvalist->ty == TY::Tsarray)\n     {\n       Type *tb = t->toBasetype ()->mutableOf ();\n       if (tb == tvalist)\n@@ -450,10 +437,10 @@ Target::systemLinkage (void)\n       /* In [attribute/linkage], `System' is the same as `Windows' on Windows\n \t platforms, and `C' on other platforms.  */\n       if (link_system)\n-\treturn LINKwindows;\n+\treturn LINK::windows;\n     }\n \n-  return LINKc;\n+  return LINK::c;\n }\n \n /* Generate a TypeTuple of the equivalent types used to determine if a\n@@ -477,12 +464,12 @@ Target::isReturnOnStack (TypeFunction *tf, bool)\n   /* Need the back-end type to determine this, but this is called from the\n      frontend before semantic processing is finished.  An accurate value\n      is not currently needed anyway.  */\n-  if (tf->isref)\n+  if (tf->isref ())\n     return false;\n \n   Type *tn = tf->next->toBasetype ();\n \n-  return (tn->ty == Tstruct || tn->ty == Tsarray);\n+  return (tn->ty == TY::Tstruct || tn->ty == TY::Tsarray);\n }\n \n /* Add all target info in HANDLERS to D_TARGET_INFO_TABLE for use by\n@@ -575,12 +562,49 @@ Target::getTargetInfo (const char *key, const Loc &loc)\n   return NULL;\n }\n \n-/**\n- * Returns true if the implementation for object monitors is always defined\n- * in the D runtime library (rt/monitor_.d).  */\n+/* Returns true if the callee invokes destructors for arguments.  */\n+\n+bool\n+Target::isCalleeDestroyingArgs (TypeFunction *tf)\n+{\n+  return tf->linkage == LINK::d;\n+}\n+\n+/* Returns true if the implementation for object monitors is always defined\n+   in the D runtime library (rt/monitor_.d).  */\n \n bool\n Target::libraryObjectMonitors (FuncDeclaration *, Statement *)\n {\n   return true;\n }\n+\n+/* Decides whether an `in' parameter of the specified POD type PARAM_TYPE is to\n+   be passed by reference or by valie.  This is used only when compiling with\n+   `-fpreview=in' enabled.  */\n+\n+bool\n+Target::preferPassByRef (Type *param_type)\n+{\n+  if (param_type->size () == SIZE_INVALID)\n+    return false;\n+\n+  tree type = build_ctype (param_type);\n+\n+  /* Prefer a `ref' if the type is an aggregate, and its size is greater than\n+     its alignment.  */\n+  if (AGGREGATE_TYPE_P (type)\n+      && (!valid_constant_size_p (TYPE_SIZE_UNIT (type))\n+\t  || compare_tree_int (TYPE_SIZE_UNIT (type), TYPE_ALIGN (type)) > 0))\n+    return true;\n+\n+  /* If the back-end is always going to pass this by invisible reference.  */\n+  if (pass_by_reference (NULL, function_arg_info (type, true)))\n+    return true;\n+\n+  /* If returning the parameter means the caller will do RVO.  */\n+  if (targetm.calls.return_in_memory (type, NULL_TREE))\n+    return true;\n+\n+  return false;\n+}"}, {"sha": "328b6b861d287c28814c07a9b0be4a4e2a6fe21f", "filename": "gcc/d/d-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fd-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fd-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-tree.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -617,7 +617,6 @@ extern void add_import_paths (const char *, const char *, bool);\n \n /* In d-lang.cc.  */\n extern void d_add_builtin_module (Module *);\n-extern void d_add_entrypoint_module (Module *, Module *);\n extern d_tree_node_structure_enum d_tree_node_structure (lang_tree_node *);\n extern struct lang_type *build_lang_type (Type *);\n extern struct lang_decl *build_lang_decl (Declaration *);"}, {"sha": "e28a581a7ec82786ef2e72c46a1688d1189a4021", "filename": "gcc/d/decl.cc", "status": "modified", "additions": 120, "deletions": 46, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdecl.cc?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -106,16 +106,69 @@ gcc_attribute_p (Dsymbol *decl)\n {\n   ModuleDeclaration *md = decl->getModule ()->md;\n \n-  if (md && md->packages && md->packages->length == 1)\n+  if (md && md->packages.length == 1)\n     {\n-      if (!strcmp ((*md->packages)[0]->toChars (), \"gcc\")\n+      if (!strcmp (md->packages.ptr[0]->toChars (), \"gcc\")\n \t  && !strcmp (md->id->toChars (), \"attributes\"))\n \treturn true;\n     }\n \n   return false;\n }\n \n+/* Subroutine of pragma declaration visitor for marking the function in the\n+   defined in SYM as a global constructor or destructor.  If ISCTOR is true,\n+   then we're applying pragma(crt_constructor).  */\n+\n+static int\n+apply_pragma_crt (Dsymbol *sym, bool isctor)\n+{\n+  AttribDeclaration *ad = sym->isAttribDeclaration ();\n+  if (ad != NULL)\n+    {\n+      int nested = 0;\n+\n+      /* Walk all declarations of the attribute scope.  */\n+      Dsymbols *ds = ad->include (NULL);\n+      if (ds)\n+\t{\n+\t  for (size_t i = 0; i < ds->length; i++)\n+\t    nested += apply_pragma_crt ((*ds)[i], isctor);\n+\t}\n+\n+      return nested;\n+    }\n+\n+  FuncDeclaration *fd = sym->isFuncDeclaration ();\n+  if (fd != NULL)\n+    {\n+      tree decl = get_decl_tree (fd);\n+\n+      /* Apply flags to the function.  */\n+      if (isctor)\n+\t{\n+\t  DECL_STATIC_CONSTRUCTOR (decl) = 1;\n+\t  decl_init_priority_insert (decl, DEFAULT_INIT_PRIORITY);\n+\t}\n+      else\n+\t{\n+\t  DECL_STATIC_DESTRUCTOR (decl) = 1;\n+\t  decl_fini_priority_insert (decl, DEFAULT_INIT_PRIORITY);\n+\t}\n+\n+      if (fd->linkage != LINK::c)\n+\t{\n+\t  error_at (make_location_t (fd->loc),\n+\t\t    \"must be %<extern(C)%> for %<pragma(%s)%>\",\n+\t\t    isctor ? \"crt_constructor\" : \"crt_destructor\");\n+\t}\n+\n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\n /* Implements the visitor interface to lower all Declaration AST classes\n    emitted from the D Front-end to GCC trees.\n    All visit methods accept one parameter D, which holds the frontend AST\n@@ -246,19 +299,31 @@ class DeclVisitor : public Visitor\n   }\n \n   /* Pragmas are a way to pass special information to the compiler and to add\n-     vendor specific extensions to D.  We don't do anything here, yet.  */\n+     vendor specific extensions to D.  */\n \n   void visit (PragmaDeclaration *d)\n   {\n-    if (!global.params.ignoreUnsupportedPragmas)\n+    if (d->ident == Identifier::idPool (\"lib\")\n+\t|| d->ident == Identifier::idPool (\"startaddress\"))\n       {\n-\tif (d->ident == Identifier::idPool (\"lib\")\n-\t    || d->ident == Identifier::idPool (\"startaddress\"))\n+\tif (!global.params.ignoreUnsupportedPragmas)\n \t  {\n \t    warning_at (make_location_t (d->loc), OPT_Wunknown_pragmas,\n \t\t\t\"pragma(%s) not implemented\", d->ident->toChars ());\n \t  }\n       }\n+    else if (d->ident == Identifier::idPool (\"crt_constructor\")\n+\t     || d->ident == Identifier::idPool (\"crt_destructor\"))\n+      {\n+\t/* Handle pragma(crt_constructor) and pragma(crt_destructor).  Apply\n+\t   flag to indicate that the functions enclosed should run automatically\n+\t   at the beginning or end of execution.  */\n+\tbool isctor = (d->ident == Identifier::idPool (\"crt_constructor\"));\n+\n+\tif (apply_pragma_crt (d, isctor) > 1)\n+\t  error_at (make_location_t (d->loc),\n+\t\t    \"can only apply to a single declaration\");\n+      }\n \n     visit ((AttribDeclaration *) d);\n   }\n@@ -311,14 +376,14 @@ class DeclVisitor : public Visitor\n        nested members.  Only applies to classes or structs.  */\n     Type *tb = fd->type->nextOf ()->baseElemOf ();\n \n-    while (tb->ty == Tarray || tb->ty == Tpointer)\n+    while (tb->ty == TY::Tarray || tb->ty == TY::Tpointer)\n       tb = tb->nextOf ()->baseElemOf ();\n \n     TemplateInstance *ti = NULL;\n \n-    if (tb->ty == Tstruct)\n+    if (tb->ty == TY::Tstruct)\n       ti = tb->isTypeStruct ()->sym->isInstantiated ();\n-    else if (tb->ty == Tclass)\n+    else if (tb->ty == TY::Tclass)\n       ti = tb->isTypeClass ()->sym->isInstantiated ();\n \n     /* Return type is instantiated from this template declaration, walk over\n@@ -360,7 +425,7 @@ class DeclVisitor : public Visitor\n     if (d->semanticRun >= PASSobj)\n       return;\n \n-    if (d->type->ty == Terror)\n+    if (d->type->ty == TY::Terror)\n       {\n \terror_at (make_location_t (d->loc),\n \t\t  \"had semantic errors when compiling\");\n@@ -447,7 +512,8 @@ class DeclVisitor : public Visitor\n \t    if (fd2->isFuture ())\n \t      continue;\n \n-\t    if (fd->leastAsSpecialized (fd2) || fd2->leastAsSpecialized (fd))\n+\t    if (fd->leastAsSpecialized (fd2) != MATCH::nomatch\n+\t\t|| fd2->leastAsSpecialized (fd) != MATCH::nomatch)\n \t      {\n \t\terror_at (make_location_t (fd->loc), \"use of %qs\",\n \t\t\t  fd->toPrettyChars ());\n@@ -474,7 +540,7 @@ class DeclVisitor : public Visitor\n     if (d->semanticRun >= PASSobj)\n       return;\n \n-    if (d->type->ty == Terror)\n+    if (d->type->ty == TY::Terror)\n       {\n \terror_at (make_location_t (d->loc),\n \t\t  \"had semantic errors when compiling\");\n@@ -495,7 +561,8 @@ class DeclVisitor : public Visitor\n \n     /* Generate C symbols.  */\n     d->csym = get_classinfo_decl (d);\n-    d->vtblsym = get_vtable_decl (d);\n+    Dsymbol *vtblsym = d->vtblSymbol ();\n+    vtblsym->csym = get_vtable_decl (d);\n     tree sinit = aggregate_initializer_decl (d);\n \n     /* Generate static initializer.  */\n@@ -527,9 +594,9 @@ class DeclVisitor : public Visitor\n \t  }\n       }\n \n-    DECL_INITIAL (d->vtblsym)\n-      = build_constructor (TREE_TYPE (d->vtblsym), elms);\n-    d_finish_decl (d->vtblsym);\n+    DECL_INITIAL (vtblsym->csym)\n+      = build_constructor (TREE_TYPE (vtblsym->csym), elms);\n+    d_finish_decl (vtblsym->csym);\n \n     /* Add this decl to the current binding level.  */\n     tree ctype = TREE_TYPE (build_ctype (d->type));\n@@ -547,7 +614,7 @@ class DeclVisitor : public Visitor\n     if (d->semanticRun >= PASSobj)\n       return;\n \n-    if (d->type->ty == Terror)\n+    if (d->type->ty == TY::Terror)\n       {\n \terror_at (make_location_t (d->loc),\n \t\t  \"had semantic errors when compiling\");\n@@ -590,7 +657,7 @@ class DeclVisitor : public Visitor\n     if (d->semanticRun >= PASSobj)\n       return;\n \n-    if (d->errors || d->type->ty == Terror)\n+    if (d->errors || d->type->ty == TY::Terror)\n       {\n \terror_at (make_location_t (d->loc),\n \t\t  \"had semantic errors when compiling\");\n@@ -629,7 +696,7 @@ class DeclVisitor : public Visitor\n     if (d->semanticRun >= PASSobj)\n       return;\n \n-    if (d->type->ty == Terror)\n+    if (d->type->ty == TY::Terror)\n       {\n \terror_at (make_location_t (d->loc),\n \t\t  \"had semantic errors when compiling\");\n@@ -695,7 +762,7 @@ class DeclVisitor : public Visitor\n \n \t/* Frontend should have already caught this.  */\n \tgcc_assert (!integer_zerop (size)\n-\t\t    || d->type->toBasetype ()->ty == Tsarray);\n+\t\t    || d->type->toBasetype ()->ty == TY::Tsarray);\n \n \td_finish_decl (decl);\n \n@@ -770,7 +837,7 @@ class DeclVisitor : public Visitor\n     /* Check if any errors occurred when running semantic.  */\n     if (TypeFunction *tf = d->type->isTypeFunction ())\n       {\n-\tif (tf->next == NULL || tf->next->ty == Terror)\n+\tif (tf->next == NULL || tf->next->ty == TY::Terror)\n \t  return;\n       }\n \n@@ -1183,6 +1250,17 @@ get_symbol_decl (Declaration *decl)\n     }\n   else if (TREE_CODE (decl->csym) == FUNCTION_DECL)\n     {\n+      /* Dual-context functions require the code generation to build an array\n+\t for the context pointer of the function, making the delicate task of\n+\t tracking which context to follow when encountering a non-local symbol,\n+\t and so are a not planned to be supported.  */\n+      if (fd->needThis () && !fd->isMember2 ())\n+\t{\n+\t  fatal_error (make_location_t (fd->loc),\n+\t\t       \"function requires a dual-context, which is not yet \"\n+\t\t       \"supported by GDC\");\n+\t}\n+\n       /* The real function type may differ from its declaration.  */\n       tree fntype = TREE_TYPE (decl->csym);\n       tree newfntype = NULL_TREE;\n@@ -1238,9 +1316,9 @@ get_symbol_decl (Declaration *decl)\n \n       /* In [pragma/inline], functions decorated with `pragma(inline)' affects\n \t whether they are inlined or not.  */\n-      if (fd->inlining == PINLINEalways)\n+      if (fd->inlining == PINLINE::always)\n \tDECL_DECLARED_INLINE_P (decl->csym) = 1;\n-      else if (fd->inlining == PINLINEnever)\n+      else if (fd->inlining == PINLINE::never)\n \tDECL_UNINLINABLE (decl->csym) = 1;\n \n       /* Function was declared `naked'.  */\n@@ -1254,13 +1332,6 @@ get_symbol_decl (Declaration *decl)\n       if (fd->generated)\n \tDECL_ARTIFICIAL (decl->csym) = 1;\n \n-      /* Vector array operations are always compiler generated.  */\n-      if (fd->isArrayOp)\n-\t{\n-\t  DECL_ARTIFICIAL (decl->csym) = 1;\n-\t  DECL_DECLARED_INLINE_P (decl->csym) = 1;\n-\t}\n-\n       /* Ensure and require contracts are lexically nested in the function they\n \t part of, but are always publicly callable.  */\n       if (fd->ident == Identifier::idPool (\"ensure\")\n@@ -1271,7 +1342,7 @@ get_symbol_decl (Declaration *decl)\n \tDECL_FINAL_P (decl->csym) = 1;\n \n       /* Function is of type `noreturn' or `typeof(*null)'.  */\n-      if (fd->type->nextOf ()->ty == Tnoreturn)\n+      if (fd->type->nextOf ()->ty == TY::Tnoreturn)\n \tTREE_THIS_VOLATILE (decl->csym) = 1;\n \n       /* Check whether this function is expanded by the frontend.  */\n@@ -1298,10 +1369,10 @@ get_symbol_decl (Declaration *decl)\n   if (decl->storage_class & STCvolatile)\n     TREE_THIS_VOLATILE (decl->csym) = 1;\n \n-  /* Protection attributes are used by the debugger.  */\n-  if (decl->protection.kind == Prot::private_)\n+  /* Visibility attributes are used by the debugger.  */\n+  if (decl->visibility.kind == Visibility::private_)\n     TREE_PRIVATE (decl->csym) = 1;\n-  else if (decl->protection.kind == Prot::protected_)\n+  else if (decl->visibility.kind == Visibility::protected_)\n     TREE_PROTECTED (decl->csym) = 1;\n \n   /* Likewise, so could the deprecated attribute.  */\n@@ -1794,7 +1865,7 @@ make_thunk (FuncDeclaration *decl, int offset)\n      forcing a D local thunk to be emitted.  */\n   const char *ident;\n \n-  if (decl->linkage == LINKcpp)\n+  if (decl->linkage == LINK::cpp)\n     ident = target.cpp.thunkMangle (decl, offset);\n   else\n     {\n@@ -1810,7 +1881,9 @@ make_thunk (FuncDeclaration *decl, int offset)\n   SET_DECL_ASSEMBLER_NAME (thunk, DECL_NAME (thunk));\n \n   d_keep (thunk);\n-  free (CONST_CAST (char *, ident));\n+\n+  if (decl->linkage != LINK::cpp)\n+    free (CONST_CAST (char *, ident));\n \n   if (!DECL_EXTERNAL (function))\n     finish_thunk (thunk, function);\n@@ -1989,26 +2062,27 @@ d_mark_needed (tree decl)\n tree\n get_vtable_decl (ClassDeclaration *decl)\n {\n-  if (decl->vtblsym)\n-    return decl->vtblsym;\n+  if (decl->vtblsym && decl->vtblsym->csym)\n+    return decl->vtblsym->csym;\n \n   tree ident = mangle_internal_decl (decl, \"__vtbl\", \"Z\");\n   /* Note: Using a static array type for the VAR_DECL, the DECL_INITIAL value\n      will have a different type.  However the back-end seems to accept this.  */\n   tree type = build_ctype (Type::tvoidptr->sarrayOf (decl->vtbl.length));\n \n-  decl->vtblsym = declare_extern_var (ident, type);\n-  DECL_LANG_SPECIFIC (decl->vtblsym) = build_lang_decl (NULL);\n+  Dsymbol *vtblsym = decl->vtblSymbol ();\n+  vtblsym->csym = declare_extern_var (ident, type);\n+  DECL_LANG_SPECIFIC (vtblsym->csym) = build_lang_decl (NULL);\n \n   /* Class is a reference, want the record type.  */\n-  DECL_CONTEXT (decl->vtblsym) = TREE_TYPE (build_ctype (decl->type));\n-  TREE_READONLY (decl->vtblsym) = 1;\n-  DECL_VIRTUAL_P (decl->vtblsym) = 1;\n+  DECL_CONTEXT (vtblsym->csym) = TREE_TYPE (build_ctype (decl->type));\n+  TREE_READONLY (vtblsym->csym) = 1;\n+  DECL_VIRTUAL_P (vtblsym->csym) = 1;\n \n-  SET_DECL_ALIGN (decl->vtblsym, TARGET_VTABLE_ENTRY_ALIGN);\n-  DECL_USER_ALIGN (decl->vtblsym) = true;\n+  SET_DECL_ALIGN (vtblsym->csym, TARGET_VTABLE_ENTRY_ALIGN);\n+  DECL_USER_ALIGN (vtblsym->csym) = true;\n \n-  return decl->vtblsym;\n+  return vtblsym->csym;\n }\n \n /* Helper function of build_class_instance.  Find the field inside aggregate"}, {"sha": "129050b6780452076f4b338a8900e59e3ff1ef5b", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -1,4 +1,4 @@\n-27e388b4c4d292cac25811496aaf79341c05c940\n+b8384668f28741ad5884fc055a2bdb9c05fd95ec\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "720d25683af95343b219622671b4df77f8030281", "filename": "gcc/d/dmd/README.md", "status": "added", "additions": 259, "deletions": 0, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2FREADME.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2FREADME.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FREADME.md?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -0,0 +1,259 @@\n+# DMD Source code\n+\n+This is the source code to the DMD compiler\n+for the D Programming Language defined in the documents at\n+http://dlang.org/\n+\n+These sources are free, they are redistributable and modifiable\n+under the terms of the Boost Software License, Version 1.0.\n+The terms of this license are in the file boostlicense.txt,\n+or see http://www.boost.org/LICENSE_1_0.txt.\n+\n+If a particular file has a different license in it, that overrides\n+this license for that file.\n+\n+-Walter Bright\n+\n+## Directory structure\n+\n+| Folder                                                                   | Purpose                                                                                                                                                                                                       |\n+|--------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| [dmd/](https://github.com/dlang/dmd/tree/master/src/dmd)                 | The dmd driver and front-end                                                                                                                                                                                  |\n+| [dmd/backend/](https://github.com/dlang/dmd/tree/master/src/dmd/backend) | Code generation for x86 or x86-64. Shared by the [Digital Mars C compiler](https://github.com/DigitalMars/Compiler/), but not [LDC](https://github.com/ldc-developers/ldc) or [GDC](https://gdcproject.org/). |\n+| [dmd/root/](https://github.com/dlang/dmd/tree/master/src/dmd/root)       | Meant as a portable utility library, but [\"it wasn't very good and the only project left using it is dmd\"](https://github.com/dlang/dmd/pull/9844#issuecomment-498479516).                                    |\n+\n+DMD has a mostly flat directory structure, so this section aims to divide all source files into logical groups for easier navigation.\n+The groups are roughly ordered by how late they appear in the compilation process.\n+Note that these groups have no strict meaning, the category assignments are a bit subjective.\n+\n+### Driver\n+\n+| File                                                                        | Purpose                                                               |\n+|-----------------------------------------------------------------------------|-----------------------------------------------------------------------|\n+| [mars.d](https://github.com/dlang/dmd/blob/master/src/dmd/mars.d)           | The entry point. Contains `main`.                                     |\n+| [cli.d](https://github.com/dlang/dmd/blob/master/src/dmd/cli.d)             | Define the command line interface                                     |\n+| [globals.d](https://github.com/dlang/dmd/blob/master/src/dmd/globals.d)     | Define a structure storing command line options                       |\n+| [dinifile.d](https://github.com/dlang/dmd/blob/master/src/dmd/dinifile.d)   | Parse settings from .ini file (`sc.ini` / `dmd.conf`)                 |\n+| [vsoptions.d](https://github.com/dlang/dmd/blob/master/src/dmd/vsoptions.d) | Detect the Microsoft Visual Studio toolchain for linking              |\n+| [frontend.d](https://github.com/dlang/dmd/blob/master/src/dmd/frontend.d)   | An interface for using DMD as a library                               |\n+| [errors.d](https://github.com/dlang/dmd/blob/master/src/dmd/errors.d)       | Error reporting functionality                                         |\n+| [target.d](https://github.com/dlang/dmd/blob/master/src/dmd/target.d)       | Manage target-specific parameters for cross-compiling (for LDC/GDC)   |\n+| [compiler.d](https://github.com/dlang/dmd/blob/master/src/dmd/compiler.d)   | Describe a back-end compiler and implements compiler-specific actions |\n+\n+### Lexing / parsing\n+\n+| File                                                                  | Purpose                                                              |\n+|-----------------------------------------------------------------------|----------------------------------------------------------------------|\n+| [lexer.d](https://github.com/dlang/dmd/blob/master/src/dmd/lexer.d)   | Convert source code into tokens for the D and ImportC parsers        |\n+| [entity.d](https://github.com/dlang/dmd/blob/master/src/dmd/entity.d) | Define \"\\\\&Entity;\" escape sequence for strings / character literals |\n+| [tokens.d](https://github.com/dlang/dmd/blob/master/src/dmd/tokens.d) | Define lexical tokens.                                               |\n+| [parse.d](https://github.com/dlang/dmd/blob/master/src/dmd/parse.d)   | D parser, converting tokens into an Abstract Syntax Tree (AST)       |\n+| [cparse.d](https://github.com/dlang/dmd/blob/master/src/dmd/cparse.d) | ImportC parser, converting tokens into an Abstract Syntax Tree (AST) |\n+\n+### Semantic analysis\n+\n+**Symbols and declarations**\n+\n+| File                                                                            | Purpose                                                                                                          |\n+|---------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------|\n+| [dsymbol.d](https://github.com/dlang/dmd/blob/master/src/dmd/dsymbol.d)         | Base class for a D symbol, e.g. a variable, function, module, enum etc.                                          |\n+| [identifier.d](https://github.com/dlang/dmd/blob/master/src/dmd/identifier.d)   | Represents the name of a `Dsymbol`                                                                               |\n+| [id.d](https://github.com/dlang/dmd/blob/master/src/dmd/id.d)                   | Define strings for pre-defined identifiers (e.g. `sizeof`, `string`)                                             |\n+| [dscope.d](https://github.com/dlang/dmd/blob/master/src/dmd/dscope.d)           | Define a 'scope' on which symbol lookup can be performed                                                         |\n+| [dtemplate.d](https://github.com/dlang/dmd/blob/master/src/dmd/dtemplate.d)     | A template declaration or instance                                                                               |\n+| [dmodule.d](https://github.com/dlang/dmd/blob/master/src/dmd/dmodule.d)         | Define a package and module                                                                                      |\n+| [mtype.d](https://github.com/dlang/dmd/blob/master/src/dmd/mtype.d)             | Define expression types such as `int`, `char[]`, `void function()`                                               |\n+| [arraytypes.d](https://github.com/dlang/dmd/blob/master/src/dmd/arraytypes.d)   | For certain Declaration nodes of type `T`, provides aliases for `Array!T`                                        |\n+| [declaration.d](https://github.com/dlang/dmd/blob/master/src/dmd/declaration.d) | Misc. declarations of `alias`, variables, type tuples, `ClassInfo` etc.                                          |\n+| [denum.d](https://github.com/dlang/dmd/blob/master/src/dmd/denum.d)             | Defines `enum` declarations and enum members                                                                     |\n+| [attrib.d](https://github.com/dlang/dmd/blob/master/src/dmd/nogc.d)             | Declarations of 'attributes' such as `private`, `pragma()`, `immutable`, `@UDA`, `align`, `extern(C++)` and more |\n+| [func.d](https://github.com/dlang/dmd/blob/master/src/dmd/func.d)               | Define a function declaration (includes function literals, `invariant`, `unittest`)                              |\n+| [dversion.d](https://github.com/dlang/dmd/blob/master/src/dmd/dversion.d)       | Defines a version symbol, e.g. `version = ident`, `debug = ident`                                                |\n+\n+**AST nodes**\n+\n+| File                                                                              | Purpose                                                     |\n+|-----------------------------------------------------------------------------------|-------------------------------------------------------------|\n+| [ast_node.d](https://github.com/dlang/dmd/blob/master/src/dmd/ast_node.d)         | Define an abstract AST node class                           |\n+| [astbase.d](https://github.com/dlang/dmd/blob/master/src/dmd/astbase.d)           | Namespace of AST nodes that can be produced by the parser   |\n+| [astcodegen.d](https://github.com/dlang/dmd/blob/master/src/dmd/astcodegen.d)     | Namespace of AST nodes of a AST ready for code generation   |\n+| [astenums.d](https://github.com/dlang/dmd/blob/master/src/dmd/astenums.d)         | Enums common to DMD and AST                                 |\n+| [expression.d](https://github.com/dlang/dmd/blob/master/src/dmd/expression.d)     | Define expression AST nodes                                 |\n+| [statement.d](https://github.com/dlang/dmd/blob/master/src/dmd/statement.d)       | Define statement AST nodes                                  |\n+| [staticassert.d](https://github.com/dlang/dmd/blob/master/src/dmd/staticassert.d) | Define a `static assert` AST node                           |\n+| [aggregate.d](https://github.com/dlang/dmd/blob/master/src/dmd/aggregate.d)       | Define an aggregate (`struct`, `union` or `class`) AST node |\n+| [dclass.d](https://github.com/dlang/dmd/blob/master/src/dmd/dclass.d)             | Define a `class` AST node                                   |\n+| [dstruct.d](https://github.com/dlang/dmd/blob/master/src/dmd/dstruct.d)           | Define a `struct` or `union` AST node                       |\n+| [init.d](https://github.com/dlang/dmd/blob/master/src/dmd/init.d)                 | Define variable initializers                                |\n+\n+**AST visitors**\n+\n+| File                                                                                                      | Purpose                                                                          |\n+|-----------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------|\n+| [parsetimevisitor.d](https://github.com/dlang/dmd/blob/master/src/dmd/parsetimevisitor.d)                 | General [visitor](https://en.wikipedia.org/wiki/Visitor_pattern) for AST nodes   |\n+| [permissivevisitor.d](https://github.com/dlang/dmd/blob/master/src/dmd/permissivevisitor.d)               | Subclass of ParseTimeVisitor that does not `assert(0)` on unimplemented nodes    |\n+| [strictvisitor.d](https://github.com/dlang/dmd/blob/master/src/dmd/strictvisitor.d)                       | Visitor that forces derived classes to implement `visit` for every possible node |\n+| [visitor.d](https://github.com/dlang/dmd/blob/master/src/dmd/visitor.d)                                   | A visitor implementing `visit` for all nodes present in the compiler             |\n+| [transitivevisitor.d](https://github.com/dlang/dmd/blob/master/src/dmd/transitivevisitor.d)               | Provide a mixin template with visit methods for the parse time AST               |\n+| [apply.d](https://github.com/dlang/dmd/blob/master/src/dmd/apply.d)                                       | Depth-first expression visitor                                                   |\n+| [sapply.d](https://github.com/dlang/dmd/blob/master/src/dmd/sapply.d)                                     | Depth-first statement visitor                                                    |\n+| [statement_rewrite_walker.d](https://github.com/dlang/dmd/blob/master/src/dmd/statement_rewrite_walker.d) | Statement visitor that allows replacing the currently visited node               |\n+\n+**Semantic passes**\n+\n+| File                                                                                      | Purpose                                                           |\n+|-------------------------------------------------------------------------------------------|-------------------------------------------------------------------|\n+| [dsymbolsem.d](https://github.com/dlang/dmd/blob/master/src/dmd/dsymbolsem.d)             | Do semantic 1 pass (symbol identifiers/types)                     |\n+| [semantic2.d](https://github.com/dlang/dmd/blob/master/src/dmd/semantic2.d)               | Do semantic 2 pass (symbol initializers)                          |\n+| [semantic3.d](https://github.com/dlang/dmd/blob/master/src/dmd/semantic3.d)               | Do semantic 3 pass (function bodies)                              |\n+| [inline.d](https://github.com/dlang/dmd/blob/master/src/dmd/inline.d)                     | Do inline pass (optimization pass that dmd does in the front-end) |\n+| [inlinecost.d](https://github.com/dlang/dmd/blob/master/src/dmd/inlinecost.d)             | Compute the cost of inlining a function call.                     |\n+| [expressionsem.d](https://github.com/dlang/dmd/blob/master/src/dmd/expressionsem.d)       | Do semantic analysis for expressions                              |\n+| [statementsem.d](https://github.com/dlang/dmd/blob/master/src/dmd/statementsem.d)         | Do semantic analysis for statements                               |\n+| [initsem.d](https://github.com/dlang/dmd/blob/master/src/dmd/initsem.d)                   | Do semantic analysis for initializers                             |\n+| [templateparamsem.d](https://github.com/dlang/dmd/blob/master/src/dmd/templateparamsem.d) | Do semantic analysis for template parameters                      |\n+| [typesem.d](https://github.com/dlang/dmd/blob/master/src/dmd/typesem.d)                   | Do semantic analysis for types                                    |\n+\n+**Semantic helpers**\n+\n+| File                                                                          | Purpose                                                                                    |\n+|-------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------|\n+| [opover.d](https://github.com/dlang/dmd/blob/master/src/dmd/opover.d)         | Operator overloading                                                                       |\n+| [clone.d](https://github.com/dlang/dmd/blob/master/src/dmd/dsymbolsem.d)      | Generate automatic `opEquals`, `opAssign` and constructors for structs                     |\n+| [blockexit.d](https://github.com/dlang/dmd/blob/master/src/dmd/blockexit.d)   | Find out in what ways control flow can exit a block                                        |\n+| [ctorflow.d](https://github.com/dlang/dmd/blob/master/src/dmd/ctorflow.d)     | Control flow in constructors                                                               |\n+| [constfold.d](https://github.com/dlang/dmd/blob/master/src/dmd/constfold.d)   | Do constant folding of arithmetic expressions                                              |\n+| [optimize.d](https://github.com/dlang/dmd/blob/master/src/dmd/optimize.d)     | Do constant folding more generally                                                         |\n+| [dcast.d](https://github.com/dlang/dmd/blob/master/src/dmd/dcast.d)           | Implicit or explicit cast(), finding common types e.g. in `x ? a : b`, integral promotions |\n+| [impcnvtab.d](https://github.com/dlang/dmd/blob/master/src/dmd/impcnvtab.d)   | Define an implicit conversion table for basic types                                        |\n+| [sideeffect.d](https://github.com/dlang/dmd/blob/master/src/dmd/sideeffect.d) | Extract side-effects of expressions for certain lowerings.                                 |\n+\n+**Compile Time Function Execution (CTFE)**\n+\n+| File                                                                          | Purpose                                                                             |\n+|-------------------------------------------------------------------------------|-------------------------------------------------------------------------------------|\n+| [dinterpret.d](https://github.com/dlang/dmd/blob/master/src/dmd/dinterpret.d) | CTFE entry point                                                                    |\n+| [ctfeexpr.d](https://github.com/dlang/dmd/blob/master/src/dmd/ctfeexpr.d)     | CTFE for expressions involving pointers, slices, array concatenation etc.           |\n+| [builtin.d](https://github.com/dlang/dmd/blob/master/src/dmd/builtin.d)       | Allow CTFE of certain external functions (`core.math`, `std.math` and `core.bitop`) |\n+\n+### Specific language features\n+\n+**Attribute checks**\n+\n+| File                                                                      | Purpose                                |\n+|---------------------------------------------------------------------------|----------------------------------------|\n+| [nogc.d](https://github.com/dlang/dmd/blob/master/src/dmd/nogc.d)         | `@nogc` checks                         |\n+| [safe.d](https://github.com/dlang/dmd/blob/master/src/dmd/safe.d)         | `@safe` checks                         |\n+| [canthrow.d](https://github.com/dlang/dmd/blob/master/src/dmd/canthrow.d) | `nothrow` checks                       |\n+| [escape.d](https://github.com/dlang/dmd/blob/master/src/dmd/escape.d)     | `scope` checks                         |\n+| [access.d](https://github.com/dlang/dmd/blob/master/src/dmd/access.d)     | `public` / `private` checks            |\n+| [ob.d](https://github.com/dlang/dmd/blob/master/src/dmd/ob.d)             | Ownership / borrowing (`@live`) checks |\n+\n+**Inline Assembly**\n+\n+| File                                                                    | Purpose                                   |\n+|-------------------------------------------------------------------------|-------------------------------------------|\n+| [iasm.d](https://github.com/dlang/dmd/blob/master/src/dmd/iasm.d)       | Inline assembly depending on the compiler |\n+| [iasmdmd.d](https://github.com/dlang/dmd/blob/master/src/dmd/iasmdmd.d) | Inline assembly for DMD                   |\n+| [iasmgcc.d](https://github.com/dlang/dmd/blob/master/src/dmd/iasmgcc.d) | Inline assembly for GDC                   |\n+\n+**Other**\n+\n+| File                                                                          | Purpose                                                                                     |\n+|-------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------|\n+| [aliasthis.d](https://github.com/dlang/dmd/blob/master/src/dmd/aliasthis.d)   | Resolve implicit conversions for `alias X this`                                             |\n+| [traits.d](https://github.com/dlang/dmd/blob/master/src/dmd/traits.d)         | `__traits()`                                                                                |\n+| [lambdacomp.d](https://github.com/dlang/dmd/blob/master/src/dmd/lambdacomp.d) | `__traits(isSame, x => y, z => w)`                                                          |\n+| [cond.d](https://github.com/dlang/dmd/blob/master/src/dmd/cond.d)             | Evaluate `static if`, `version` `debug `                                                    |\n+| [staticcond.d](https://github.com/dlang/dmd/blob/master/src/dmd/staticcond.d) | Lazily evaluate static conditions for `static if`, `static assert` and template constraints |\n+| [delegatize.d](https://github.com/dlang/dmd/blob/master/src/dmd/delegatize.d) | Converts expression to delegates for `lazy` parameters                                      |\n+| [eh.d](https://github.com/dlang/dmd/blob/master/src/dmd/eh.d)                 | Generate tables for exception handling                                                      |\n+| [nspace.d](https://github.com/dlang/dmd/blob/master/src/dmd/nspace.d)         | Namespace for `extern (C++, Module)`                                                        |\n+| [intrange.d](https://github.com/dlang/dmd/blob/master/src/dmd/intrange.d)     | [Value range propagation](https://digitalmars.com/articles/b62.html)                        |\n+| [dimport.d](https://github.com/dlang/dmd/blob/master/src/dmd/dimport.d)       | Renamed imports (`import aliasSymbol = pkg1.pkg2.symbol`)                                   |\n+| [arrayop.d](https://github.com/dlang/dmd/blob/master/src/dmd/arrayop.d)       | Array operations (`a[] = b[] + c[]`)                                                        |\n+| [typinf.d](https://github.com/dlang/dmd/blob/master/src/dmd/typinf.d)         | Generate typeinfo for `typeid()` (as well as internals)                                     |\n+\n+| File                                                                        | Purpose                                                                            |\n+|-----------------------------------------------------------------------------|------------------------------------------------------------------------------------|\n+| [chkformat.d](https://github.com/dlang/dmd/blob/master/src/dmd/chkformat.d) | Validate arguments with format specifiers for `printf` / `scanf` etc.              |\n+| [imphint.d](https://github.com/dlang/dmd/blob/master/src/dmd/imphint.d)     | Give a suggestion to e.g. `import std.stdio` when `writeln` could not be resolved. |\n+\n+### Library files\n+\n+| File                                                                          | Purpose                                              |\n+|-------------------------------------------------------------------------------|------------------------------------------------------|\n+| [lib.d](https://github.com/dlang/dmd/blob/master/src/dmd/lib.d)               | Abstract library class                               |\n+| [libelf.d](https://github.com/dlang/dmd/blob/master/src/dmd/libelf.d)         | Library in ELF format (Unix)                         |\n+| [libmach.d](https://github.com/dlang/dmd/blob/master/src/dmd/libmach.d)       | Library in Mach-O format (macOS)                     |\n+| [libmscoff.d](https://github.com/dlang/dmd/blob/master/src/dmd/libmscoff.d)   | Library in COFF format (32/64-bit Windows)           |\n+| [libomf.d](https://github.com/dlang/dmd/blob/master/src/dmd/libomf.d)         | Library in OMF format (legacy 32-bit Windows)        |\n+| [scanelf.d](https://github.com/dlang/dmd/blob/master/src/dmd/scanelf.d)       | Extract symbol names from a library in ELF format    |\n+| [scanmach.d](https://github.com/dlang/dmd/blob/master/src/dmd/scanmach.d)     | Extract symbol names from a library in Mach-O format |\n+| [scanmscoff.d](https://github.com/dlang/dmd/blob/master/src/dmd/scanmscoff.d) | Extract symbol names from a library in COFF format   |\n+| [scanomf.d](https://github.com/dlang/dmd/blob/master/src/dmd/scanomf.d)       | Extract symbol names from a library in OMF format    |\n+\n+### Code generation / back-end interfacing\n+\n+| File                                                                                        | Purpose                                                                             |\n+|---------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------|\n+| [dmsc.d](https://github.com/dlang/dmd/blob/master/src/dmd/dmsc.d)                           | Configures and initializes the back-end                                             |\n+| [toobj.d](https://github.com/dlang/dmd/blob/master/src/dmd/toobj.d)                         | Convert an AST that went through all semantic phases into an object file            |\n+| [toir.d](https://github.com/dlang/dmd/blob/master/src/dmd/toir.d)                           | Convert Dsymbols intermediate representation                                        |\n+| [e2ir.d](https://github.com/dlang/dmd/blob/master/src/dmd/e2ir.d)                           | Convert Expressions to intermediate representation                                  |\n+| [s2ir.d](https://github.com/dlang/dmd/blob/master/src/dmd/s2ir.d)                           | Convert Statements to intermediate representation                                   |\n+| [stmtstate.d](https://github.com/dlang/dmd/blob/master/src/dmd/stmtstate.d)                 | Used to help transform statement AST into flow graph                                |\n+| [toctype.d](https://github.com/dlang/dmd/blob/master/src/dmd/toctype.d)                     | Convert a D type to a type the back-end understands                                 |\n+| [tocsym.d](https://github.com/dlang/dmd/blob/master/src/dmd/tocsym.d)                       | Convert a D symbol to a symbol the linker understands (with mangled name)           |\n+| [argtypes_x86.d](https://github.com/dlang/dmd/blob/master/src/dmd/argtypes_x86.d)           | Convert a D type into simple (register) types for the 32-bit x86 ABI                |\n+| [argtypes_sysv_x64.d](https://github.com/dlang/dmd/blob/master/src/dmd/argtypes_sysv_x64.d) | 'argtypes' for the x86_64 System V ABI                                              |\n+| [argtypes_aarch64.d](https://github.com/dlang/dmd/blob/master/src/dmd/argtypes_aarch64.d)   | 'argtypes' for the AArch64 ABI                                                      |\n+| [glue.d](https://github.com/dlang/dmd/blob/master/src/dmd/glue.d)                           | Generate the object file for function declarations                                  |\n+| [gluelayer.d](https://github.com/dlang/dmd/blob/master/src/dmd/gluelayer.d)                 | Declarations for back-end functions that the front-end invokes                      |\n+| [todt.d](https://github.com/dlang/dmd/blob/master/src/dmd/todt.d)                           | Convert initializers into structures that the back-end will add to the data segment |\n+| [tocvdebug.d](https://github.com/dlang/dmd/blob/master/src/dmd/tovcdebug.d)                 | Generate debug info in the CV4 debug format.                                        |\n+| [objc.d](https://github.com/dlang/dmd/blob/master/src/dmd/objc.d)                           | Objective-C interfacing                                                             |\n+| [objc_glue.d](https://github.com/dlang/dmd/blob/master/src/dmd/objc_glue.d)                 | Glue code for Objective-C interop.                                                  |\n+\n+**Name mangling**\n+\n+| File                                                                              | Purpose                                                          |\n+|-----------------------------------------------------------------------------------|------------------------------------------------------------------|\n+| [cppmangle.d](https://github.com/dlang/dmd/blob/master/src/dmd/cppmangle.d)       | C++ name mangling                                                |\n+| [cppmanglewin.d](https://github.com/dlang/dmd/blob/master/src/dmd/cppmanglewin.d) | C++ name mangling for Windows                                    |\n+| [dmangle.d](https://github.com/dlang/dmd/blob/master/src/dmd/dmangle.d)           | D [name mangling](https://dlang.org/spec/abi.html#name_mangling) |\n+\n+### Linking\n+\n+| File                                                              | Purpose                                 |\n+|-------------------------------------------------------------------|-----------------------------------------|\n+| [link.d](https://github.com/dlang/dmd/blob/master/src/dmd/link.d) | Invoke the linker as a separate process |\n+\n+### Special output\n+\n+| File                                                                  | Purpose                                                                                                 |\n+|-----------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------|\n+| [doc.d](https://github.com/dlang/dmd/blob/master/src/dmd/doc.d)       | [Documentation generation](https://dlang.org/spec/ddoc.html)                                            |\n+| [dmacro.d](https://github.com/dlang/dmd/blob/master/src/dmd/dmacro.d) | DDoc macro processing                                                                                   |\n+| [hdrgen.d](https://github.com/dlang/dmd/blob/master/src/dmd/hdrgen.d) | Convert an AST into D source code for `.di` header generation, as well as `-vcg-ast` and error messages |\n+| [json.d](https://github.com/dlang/dmd/blob/master/src/dmd/json.d)     | Describe the module in a `.json` file for the `-X` flag                                                 |\n+| [dtoh.d](https://github.com/dlang/dmd/blob/master/src/dmd/dtoh.d)     | C++ header generation from D source files                                                               |\n+\n+### Utility\n+\n+Note: many other utilities are in [dmd/root](https://github.com/dlang/dmd/tree/master/src/dmd/root).\n+\n+| File                                                                        | Purpose                                           |\n+|-----------------------------------------------------------------------------|---------------------------------------------------|\n+| [env.d](https://github.com/dlang/dmd/blob/master/src/dmd/env.d)             | Modify environment variables                      |\n+| [console.d](https://github.com/dlang/dmd/blob/master/src/dmd/console.d)     | Print error messages in color                     |\n+| [utf.d](https://github.com/dlang/dmd/blob/master/src/dmd/utf.d)             | Encoding/decoding Unicode text                    |\n+| [filecache.d](https://github.com/dlang/dmd/blob/master/src/dmd/filecache.d) | Keep file contents in memory                      |\n+| [utils.d](https://github.com/dlang/dmd/blob/master/src/dmd/utils.d)         | Utility functions related to files and file paths |\n+| [complex.d](https://github.com/dlang/dmd/blob/master/src/dmd/complex.d)     | A complex number type                             |\n+\n+| File                                                                            | Purpose                                                       |\n+|---------------------------------------------------------------------------------|---------------------------------------------------------------|\n+| [asttypename.d](https://github.com/dlang/dmd/blob/master/src/dmd/asttypename.d) | Print the internal name of an AST node (for debugging only)   |\n+| [printast.d](https://github.com/dlang/dmd/blob/master/src/dmd/printast.d)       | Print the AST data structure                                  |\n+| [foreachvar.d](https://github.com/dlang/dmd/blob/master/src/dmd/foreachvar.d)   | Used in `ob.d` to iterate over all variables in an expression |"}, {"sha": "64ce79a7c451e51349b4a8b405cdeaff4047e5c8", "filename": "gcc/d/dmd/VERSION", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FVERSION?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -0,0 +1 @@\n+v2.097.2"}, {"sha": "11b26c5dc5c3569b0c50aaa95d511faa5ef6ee58", "filename": "gcc/d/dmd/access.c", "status": "removed", "additions": 0, "deletions": 560, "changes": 560, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Faccess.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Faccess.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faccess.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49", "patch": "@@ -1,560 +0,0 @@\n-/* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n- * written by Walter Bright\n- * http://www.digitalmars.com\n- * Distributed under the Boost Software License, Version 1.0.\n- * http://www.boost.org/LICENSE_1_0.txt\n- * https://github.com/D-Programming-Language/dmd/blob/master/src/access.c\n- */\n-\n-#include \"root/dsystem.h\"\n-#include \"root/root.h\"\n-#include \"root/rmem.h\"\n-\n-#include \"errors.h\"\n-#include \"enum.h\"\n-#include \"aggregate.h\"\n-#include \"init.h\"\n-#include \"attrib.h\"\n-#include \"scope.h\"\n-#include \"id.h\"\n-#include \"mtype.h\"\n-#include \"declaration.h\"\n-#include \"aggregate.h\"\n-#include \"expression.h\"\n-#include \"module.h\"\n-#include \"template.h\"\n-\n-/* Code to do access checks\n- */\n-\n-bool hasPackageAccess(Scope *sc, Dsymbol *s);\n-bool hasPackageAccess(Module *mod, Dsymbol *s);\n-bool hasPrivateAccess(AggregateDeclaration *ad, Dsymbol *smember);\n-bool isFriendOf(AggregateDeclaration *ad, AggregateDeclaration *cd);\n-static Dsymbol *mostVisibleOverload(Dsymbol *s);\n-\n-/****************************************\n- * Return Prot access for Dsymbol smember in this declaration.\n- */\n-Prot getAccess(AggregateDeclaration *ad, Dsymbol *smember)\n-{\n-    Prot access_ret = Prot(Prot::none);\n-\n-    assert(ad->isStructDeclaration() || ad->isClassDeclaration());\n-    if (smember->toParent() == ad)\n-    {\n-        access_ret = smember->prot();\n-    }\n-    else if (smember->isDeclaration()->isStatic())\n-    {\n-        access_ret = smember->prot();\n-    }\n-    if (ClassDeclaration *cd = ad->isClassDeclaration())\n-    {\n-        for (size_t i = 0; i < cd->baseclasses->length; i++)\n-        {\n-            BaseClass *b = (*cd->baseclasses)[i];\n-\n-            Prot access = getAccess(b->sym, smember);\n-            switch (access.kind)\n-            {\n-                case Prot::none:\n-                    break;\n-\n-                case Prot::private_:\n-                    access_ret = Prot(Prot::none);  // private members of base class not accessible\n-                    break;\n-\n-                case Prot::package_:\n-                case Prot::protected_:\n-                case Prot::public_:\n-                case Prot::export_:\n-                    // If access is to be tightened\n-                    if (Prot::public_ < access.kind)\n-                        access = Prot(Prot::public_);\n-\n-                    // Pick path with loosest access\n-                    if (access_ret.isMoreRestrictiveThan(access))\n-                        access_ret = access;\n-                    break;\n-\n-                default:\n-                    assert(0);\n-            }\n-        }\n-    }\n-\n-    return access_ret;\n-}\n-\n-/********************************************************\n- * Helper function for checkAccess()\n- * Returns:\n- *      false   is not accessible\n- *      true    is accessible\n- */\n-static bool isAccessible(\n-        Dsymbol *smember,\n-        Dsymbol *sfunc,\n-        AggregateDeclaration *dthis,\n-        AggregateDeclaration *cdscope)\n-{\n-    assert(dthis);\n-\n-    if (hasPrivateAccess(dthis, sfunc) ||\n-        isFriendOf(dthis, cdscope))\n-    {\n-        if (smember->toParent() == dthis)\n-            return true;\n-\n-        if (ClassDeclaration *cdthis = dthis->isClassDeclaration())\n-        {\n-            for (size_t i = 0; i < cdthis->baseclasses->length; i++)\n-            {\n-                BaseClass *b = (*cdthis->baseclasses)[i];\n-                Prot access = getAccess(b->sym, smember);\n-                if (access.kind >= Prot::protected_ ||\n-                    isAccessible(smember, sfunc, b->sym, cdscope))\n-                {\n-                    return true;\n-                }\n-            }\n-        }\n-    }\n-    else\n-    {\n-        if (smember->toParent() != dthis)\n-        {\n-            if (ClassDeclaration *cdthis = dthis->isClassDeclaration())\n-            {\n-                for (size_t i = 0; i < cdthis->baseclasses->length; i++)\n-                {\n-                    BaseClass *b = (*cdthis->baseclasses)[i];\n-                    if (isAccessible(smember, sfunc, b->sym, cdscope))\n-                        return true;\n-                }\n-            }\n-        }\n-    }\n-    return false;\n-}\n-\n-/*******************************\n- * Do access check for member of this class, this class being the\n- * type of the 'this' pointer used to access smember.\n- * Returns true if the member is not accessible.\n- */\n-bool checkAccess(AggregateDeclaration *ad, Loc loc, Scope *sc, Dsymbol *smember)\n-{\n-    FuncDeclaration *f = sc->func;\n-    AggregateDeclaration *cdscope = sc->getStructClassScope();\n-\n-    Dsymbol *smemberparent = smember->toParent();\n-    if (!smemberparent || !smemberparent->isAggregateDeclaration())\n-    {\n-        return false;                   // then it is accessible\n-    }\n-\n-    // BUG: should enable this check\n-    //assert(smember->parent->isBaseOf(this, NULL));\n-\n-    bool result;\n-    Prot access;\n-    if (smemberparent == ad)\n-    {\n-        access = smember->prot();\n-        result = access.kind >= Prot::public_ ||\n-                 hasPrivateAccess(ad, f) ||\n-                 isFriendOf(ad, cdscope) ||\n-                 (access.kind == Prot::package_ && hasPackageAccess(sc, smember)) ||\n-                 ad->getAccessModule() == sc->_module;\n-    }\n-    else if ((access = getAccess(ad, smember)).kind >= Prot::public_)\n-    {\n-        result = true;\n-    }\n-    else if (access.kind == Prot::package_ && hasPackageAccess(sc, ad))\n-    {\n-        result = true;\n-    }\n-    else\n-    {\n-        result = isAccessible(smember, f, ad, cdscope);\n-    }\n-    if (!result)\n-    {\n-        ad->error(loc, \"member %s is not accessible\", smember->toChars());\n-        //printf(\"smember = %s %s, prot = %d, semanticRun = %d\\n\",\n-        //        smember->kind(), smember->toPrettyChars(), smember->prot(), smember->semanticRun);\n-        return true;\n-    }\n-    return false;\n-}\n-\n-/****************************************\n- * Determine if this is the same or friend of cd.\n- */\n-bool isFriendOf(AggregateDeclaration *ad, AggregateDeclaration *cd)\n-{\n-    if (ad == cd)\n-        return true;\n-\n-    // Friends if both are in the same module\n-    //if (toParent() == cd->toParent())\n-    if (cd && ad->getAccessModule() == cd->getAccessModule())\n-    {\n-        return true;\n-    }\n-\n-    return false;\n-}\n-\n-/****************************************\n- * Determine if scope sc has package level access to s.\n- */\n-bool hasPackageAccess(Scope *sc, Dsymbol *s)\n-{\n-    return hasPackageAccess(sc->_module, s);\n-}\n-\n-bool hasPackageAccess(Module *mod, Dsymbol *s)\n-{\n-    Package *pkg = NULL;\n-\n-    if (s->prot().pkg)\n-        pkg = s->prot().pkg;\n-    else\n-    {\n-        // no explicit package for protection, inferring most qualified one\n-        for (; s; s = s->parent)\n-        {\n-            if (Module *m = s->isModule())\n-            {\n-                DsymbolTable *dst = Package::resolve(m->md ? m->md->packages : NULL, NULL, NULL);\n-                assert(dst);\n-                Dsymbol *s2 = dst->lookup(m->ident);\n-                assert(s2);\n-                Package *p = s2->isPackage();\n-                if (p && p->isPackageMod())\n-                {\n-                    pkg = p;\n-                    break;\n-                }\n-            }\n-            else if ((pkg = s->isPackage()) != NULL)\n-                break;\n-        }\n-    }\n-\n-    if (pkg)\n-    {\n-        if (pkg == mod->parent)\n-        {\n-            return true;\n-        }\n-        if (pkg->isPackageMod() == mod)\n-        {\n-            return true;\n-        }\n-        Dsymbol* ancestor = mod->parent;\n-        for (; ancestor; ancestor = ancestor->parent)\n-        {\n-            if (ancestor == pkg)\n-            {\n-                return true;\n-            }\n-        }\n-    }\n-\n-    return false;\n-}\n-\n-/****************************************\n- * Determine if scope sc has protected level access to cd.\n- */\n-bool hasProtectedAccess(Scope *sc, Dsymbol *s)\n-{\n-    if (ClassDeclaration *cd = s->isClassMember()) // also includes interfaces\n-    {\n-        for (Scope *scx = sc; scx; scx = scx->enclosing)\n-        {\n-            if (!scx->scopesym)\n-                continue;\n-            ClassDeclaration *cd2 = scx->scopesym->isClassDeclaration();\n-            if (cd2 && cd->isBaseOf(cd2, NULL))\n-                return true;\n-        }\n-    }\n-    return sc->_module == s->getAccessModule();\n-}\n-\n-/**********************************\n- * Determine if smember has access to private members of this declaration.\n- */\n-bool hasPrivateAccess(AggregateDeclaration *ad, Dsymbol *smember)\n-{\n-    if (smember)\n-    {\n-        AggregateDeclaration *cd = NULL;\n-        Dsymbol *smemberparent = smember->toParent();\n-        if (smemberparent)\n-            cd = smemberparent->isAggregateDeclaration();\n-\n-        if (ad == cd)         // smember is a member of this class\n-        {\n-            return true;           // so we get private access\n-        }\n-\n-        // If both are members of the same module, grant access\n-        while (1)\n-        {\n-            Dsymbol *sp = smember->toParent();\n-            if (sp->isFuncDeclaration() && smember->isFuncDeclaration())\n-                smember = sp;\n-            else\n-                break;\n-        }\n-        if (!cd && ad->toParent() == smember->toParent())\n-        {\n-            return true;\n-        }\n-        if (!cd && ad->getAccessModule() == smember->getAccessModule())\n-        {\n-            return true;\n-        }\n-    }\n-    return false;\n-}\n-\n-/****************************************\n- * Check access to d for expression e.d\n- * Returns true if the declaration is not accessible.\n- */\n-bool checkAccess(Loc loc, Scope *sc, Expression *e, Declaration *d)\n-{\n-    if (sc->flags & SCOPEnoaccesscheck)\n-        return false;\n-\n-    if (d->isUnitTestDeclaration())\n-    {\n-        // Unittests are always accessible.\n-        return false;\n-    }\n-    if (!e)\n-        return false;\n-\n-    if (e->type->ty == Tclass)\n-    {\n-        // Do access check\n-        ClassDeclaration *cd = (ClassDeclaration *)(((TypeClass *)e->type)->sym);\n-        if (e->op == TOKsuper)\n-        {\n-            ClassDeclaration *cd2 = sc->func->toParent()->isClassDeclaration();\n-            if (cd2)\n-                cd = cd2;\n-        }\n-        return checkAccess(cd, loc, sc, d);\n-    }\n-    else if (e->type->ty == Tstruct)\n-    {\n-        // Do access check\n-        StructDeclaration *cd = (StructDeclaration *)(((TypeStruct *)e->type)->sym);\n-        return checkAccess(cd, loc, sc, d);\n-    }\n-    return false;\n-}\n-\n-/****************************************\n- * Check access to package/module `p` from scope `sc`.\n- *\n- * Params:\n- *   loc = source location for issued error message\n- *   sc = scope from which to access to a fully qualified package name\n- *   p = the package/module to check access for\n- * Returns: true if the package is not accessible.\n- *\n- * Because a global symbol table tree is used for imported packages/modules,\n- * access to them needs to be checked based on the imports in the scope chain\n- * (see Bugzilla 313).\n- *\n- */\n-bool checkAccess(Scope *sc, Package *p)\n-{\n-    if (sc->_module == p)\n-        return false;\n-    for (; sc; sc = sc->enclosing)\n-    {\n-        if (sc->scopesym && sc->scopesym->isPackageAccessible(p, Prot(Prot::private_)))\n-            return false;\n-    }\n-\n-    return true;\n-}\n-\n-/**\n- * Check whether symbols `s` is visible in `mod`.\n- *\n- * Params:\n- *  mod = lookup origin\n- *  s = symbol to check for visibility\n- * Returns: true if s is visible in mod\n- */\n-bool symbolIsVisible(Module *mod, Dsymbol *s)\n-{\n-    // should sort overloads by ascending protection instead of iterating here\n-    s = mostVisibleOverload(s);\n-\n-    switch (s->prot().kind)\n-    {\n-        case Prot::undefined:\n-            return true;\n-        case Prot::none:\n-            return false; // no access\n-        case Prot::private_:\n-            return s->getAccessModule() == mod;\n-        case Prot::package_:\n-            return s->getAccessModule() == mod || hasPackageAccess(mod, s);\n-        case Prot::protected_:\n-            return s->getAccessModule() == mod;\n-        case Prot::public_:\n-        case Prot::export_:\n-            return true;\n-        default:\n-            assert(0);\n-    }\n-    return false;\n-}\n-\n-/**\n- * Same as above, but determines the lookup module from symbols `origin`.\n- */\n-bool symbolIsVisible(Dsymbol *origin, Dsymbol *s)\n-{\n-    return symbolIsVisible(origin->getAccessModule(), s);\n-}\n-\n-/**\n- * Same as above but also checks for protected symbols visible from scope `sc`.\n- * Used for qualified name lookup.\n- *\n- * Params:\n- *  sc = lookup scope\n- *  s = symbol to check for visibility\n- * Returns: true if s is visible by origin\n- */\n-bool symbolIsVisible(Scope *sc, Dsymbol *s)\n-{\n-    s = mostVisibleOverload(s);\n-\n-    switch (s->prot().kind)\n-    {\n-        case Prot::undefined:\n-            return true;\n-        case Prot::none:\n-            return false; // no access\n-        case Prot::private_:\n-            return sc->_module == s->getAccessModule();\n-        case Prot::package_:\n-            return sc->_module == s->getAccessModule() || hasPackageAccess(sc->_module, s);\n-        case Prot::protected_:\n-            return hasProtectedAccess(sc, s);\n-        case Prot::public_:\n-        case Prot::export_:\n-            return true;\n-        default:\n-            assert(0);\n-    }\n-    return false;\n-}\n-\n-/**\n- * Use the most visible overload to check visibility. Later perform an access\n- * check on the resolved overload.  This function is similar to overloadApply,\n- * but doesn't recurse nor resolve aliases because protection/visibility is an\n- * attribute of the alias not the aliasee.\n- */\n-static Dsymbol *mostVisibleOverload(Dsymbol *s)\n-{\n-    if (!s->isOverloadable())\n-        return s;\n-\n-    Dsymbol *next = NULL;\n-    Dsymbol *fstart = s;\n-    Dsymbol *mostVisible = s;\n-    for (; s; s = next)\n-    {\n-        // void func() {}\n-        // private void func(int) {}\n-        if (FuncDeclaration *fd = s->isFuncDeclaration())\n-            next = fd->overnext;\n-        // template temp(T) {}\n-        // private template temp(T:int) {}\n-        else if (TemplateDeclaration *td = s->isTemplateDeclaration())\n-            next = td->overnext;\n-        // alias common = mod1.func1;\n-        // alias common = mod2.func2;\n-        else if (FuncAliasDeclaration *fa = s->isFuncAliasDeclaration())\n-            next = fa->overnext;\n-        // alias common = mod1.templ1;\n-        // alias common = mod2.templ2;\n-        else if (OverDeclaration *od = s->isOverDeclaration())\n-            next = od->overnext;\n-        // alias name = sym;\n-        // private void name(int) {}\n-        else if (AliasDeclaration *ad = s->isAliasDeclaration())\n-        {\n-            if (!ad->isOverloadable())\n-            {\n-                //printf(\"Non overloadable Aliasee in overload list\\n\");\n-                assert(0);\n-            }\n-            // Yet unresolved aliases store overloads in overnext.\n-            if (ad->semanticRun < PASSsemanticdone)\n-                next = ad->overnext;\n-            else\n-            {\n-                /* This is a bit messy due to the complicated implementation of\n-                 * alias.  Aliases aren't overloadable themselves, but if their\n-                 * Aliasee is overloadable they can be converted to an overloadable\n-                 * alias.\n-                 *\n-                 * This is done by replacing the Aliasee w/ FuncAliasDeclaration\n-                 * (for functions) or OverDeclaration (for templates) which are\n-                 * simply overloadable aliases w/ weird names.\n-                 *\n-                 * Usually aliases should not be resolved for visibility checking\n-                 * b/c public aliases to private symbols are public. But for the\n-                 * overloadable alias situation, the Alias (_ad_) has been moved\n-                 * into it's own Aliasee, leaving a shell that we peel away here.\n-                 */\n-                Dsymbol *aliasee = ad->toAlias();\n-                if (aliasee->isFuncAliasDeclaration() || aliasee->isOverDeclaration())\n-                    next = aliasee;\n-                else\n-                {\n-                    /* A simple alias can be at the end of a function or template overload chain.\n-                     * It can't have further overloads b/c it would have been\n-                     * converted to an overloadable alias.\n-                     */\n-                    if (ad->overnext)\n-                    {\n-                        //printf(\"Unresolved overload of alias\\n\");\n-                        assert(0);\n-                    }\n-                    break;\n-                }\n-            }\n-\n-            // handled by overloadApply for unknown reason\n-            assert(next != ad); // should not alias itself\n-            assert(next != fstart); // should not alias the overload list itself\n-        }\n-        else\n-            break;\n-\n-        if (next && mostVisible->prot().isMoreRestrictiveThan(next->prot()))\n-            mostVisible = next;\n-    }\n-    return mostVisible;\n-}"}, {"sha": "944c9d3e124521da4538b1ce061c0dab0243f0ad", "filename": "gcc/d/dmd/access.d", "status": "added", "additions": 410, "deletions": 0, "changes": 410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Faccess.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Faccess.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faccess.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -0,0 +1,410 @@\n+/**\n+ * Enforce visibility contrains such as `public` and `private`.\n+ *\n+ * Specification: $(LINK2 https://dlang.org/spec/attribute.html#visibility_attributes, Visibility Attributes)\n+ *\n+ * Copyright:   Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n+ * Authors:     $(LINK2 http://www.digitalmars.com, Walter Bright)\n+ * License:     $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+ * Source:      $(LINK2 https://github.com/dlang/dmd/blob/master/src/dmd/access.d, _access.d)\n+ * Documentation:  https://dlang.org/phobos/dmd_access.html\n+ * Coverage:    https://codecov.io/gh/dlang/dmd/src/master/src/dmd/access.d\n+ */\n+\n+module dmd.access;\n+\n+import dmd.aggregate;\n+import dmd.astenums;\n+import dmd.dclass;\n+import dmd.declaration;\n+import dmd.dmodule;\n+import dmd.dscope;\n+import dmd.dstruct;\n+import dmd.dsymbol;\n+import dmd.errors;\n+import dmd.expression;\n+import dmd.func;\n+import dmd.globals;\n+import dmd.mtype;\n+import dmd.tokens;\n+\n+private enum LOG = false;\n+\n+\n+/*******************************\n+ * Do access check for member of this class, this class being the\n+ * type of the 'this' pointer used to access smember.\n+ * Returns true if the member is not accessible.\n+ */\n+bool checkAccess(AggregateDeclaration ad, Loc loc, Scope* sc, Dsymbol smember)\n+{\n+    static if (LOG)\n+    {\n+        printf(\"AggregateDeclaration::checkAccess() for %s.%s in function %s() in scope %s\\n\", ad.toChars(), smember.toChars(), f ? f.toChars() : null, cdscope ? cdscope.toChars() : null);\n+    }\n+\n+    const p = smember.toParent();\n+    if (p && p.isTemplateInstance())\n+    {\n+        return false; // for backward compatibility\n+    }\n+\n+    if (!symbolIsVisible(sc, smember))\n+    {\n+        // when in @safe code or with -preview=dip1000\n+        if (sc.flags & SCOPE.onlysafeaccess)\n+        {\n+            // if there is a func. ask for it's opinion of safety, and if it considers the access @safe accept it.\n+            if (sc.func && !sc.func.setUnsafe())\n+                return false;\n+        }\n+\n+        ad.error(loc, \"%s `%s` is not accessible%s\", smember.kind(), smember.toChars(), (sc.flags & SCOPE.onlysafeaccess) ? \" from `@safe` code\".ptr : \"\".ptr);\n+        //printf(\"smember = %s %s, vis = %d, semanticRun = %d\\n\",\n+        //        smember.kind(), smember.toPrettyChars(), smember.visible() smember.semanticRun);\n+        return true;\n+    }\n+    return false;\n+}\n+\n+/****************************************\n+ * Determine if scope sc has package level access to s.\n+ */\n+private bool hasPackageAccess(Scope* sc, Dsymbol s)\n+{\n+    return hasPackageAccess(sc._module, s);\n+}\n+\n+private bool hasPackageAccess(Module mod, Dsymbol s)\n+{\n+    static if (LOG)\n+    {\n+        printf(\"hasPackageAccess(s = '%s', mod = '%s', s.visibility.pkg = '%s')\\n\", s.toChars(), mod.toChars(), s.visible().pkg ? s.visible().pkg.toChars() : \"NULL\");\n+    }\n+    Package pkg = null;\n+    if (s.visible().pkg)\n+        pkg = s.visible().pkg;\n+    else\n+    {\n+        // no explicit package for visibility, inferring most qualified one\n+        for (; s; s = s.parent)\n+        {\n+            if (auto m = s.isModule())\n+            {\n+                DsymbolTable dst = Package.resolve(m.md ? m.md.packages : null, null, null);\n+                assert(dst);\n+                Dsymbol s2 = dst.lookup(m.ident);\n+                assert(s2);\n+                Package p = s2.isPackage();\n+                if (p && p.isPackageMod())\n+                {\n+                    pkg = p;\n+                    break;\n+                }\n+            }\n+            else if ((pkg = s.isPackage()) !is null)\n+                break;\n+        }\n+    }\n+    static if (LOG)\n+    {\n+        if (pkg)\n+            printf(\"\\tsymbol access binds to package '%s'\\n\", pkg.toChars());\n+    }\n+    if (pkg)\n+    {\n+        if (pkg == mod.parent)\n+        {\n+            static if (LOG)\n+            {\n+                printf(\"\\tsc is in permitted package for s\\n\");\n+            }\n+            return true;\n+        }\n+        if (pkg.isPackageMod() == mod)\n+        {\n+            static if (LOG)\n+            {\n+                printf(\"\\ts is in same package.d module as sc\\n\");\n+            }\n+            return true;\n+        }\n+        Dsymbol ancestor = mod.parent;\n+        for (; ancestor; ancestor = ancestor.parent)\n+        {\n+            if (ancestor == pkg)\n+            {\n+                static if (LOG)\n+                {\n+                    printf(\"\\tsc is in permitted ancestor package for s\\n\");\n+                }\n+                return true;\n+            }\n+        }\n+    }\n+    static if (LOG)\n+    {\n+        printf(\"\\tno package access\\n\");\n+    }\n+    return false;\n+}\n+\n+/****************************************\n+ * Determine if scope sc has protected level access to cd.\n+ */\n+private bool hasProtectedAccess(Scope *sc, Dsymbol s)\n+{\n+    if (auto cd = s.isClassMember()) // also includes interfaces\n+    {\n+        for (auto scx = sc; scx; scx = scx.enclosing)\n+        {\n+            if (!scx.scopesym)\n+                continue;\n+            auto cd2 = scx.scopesym.isClassDeclaration();\n+            if (cd2 && cd.isBaseOf(cd2, null))\n+                return true;\n+        }\n+    }\n+    return sc._module == s.getAccessModule();\n+}\n+\n+/****************************************\n+ * Check access to d for expression e.d\n+ * Returns true if the declaration is not accessible.\n+ */\n+bool checkAccess(Loc loc, Scope* sc, Expression e, Dsymbol d)\n+{\n+    if (sc.flags & SCOPE.noaccesscheck)\n+        return false;\n+    static if (LOG)\n+    {\n+        if (e)\n+        {\n+            printf(\"checkAccess(%s . %s)\\n\", e.toChars(), d.toChars());\n+            printf(\"\\te.type = %s\\n\", e.type.toChars());\n+        }\n+        else\n+        {\n+            printf(\"checkAccess(%s)\\n\", d.toPrettyChars());\n+        }\n+    }\n+    if (d.isUnitTestDeclaration())\n+    {\n+        // Unittests are always accessible.\n+        return false;\n+    }\n+\n+    if (!e)\n+        return false;\n+\n+    if (auto tc = e.type.isTypeClass())\n+    {\n+        // Do access check\n+        ClassDeclaration cd = tc.sym;\n+        if (e.op == TOK.super_)\n+        {\n+            if (ClassDeclaration cd2 = sc.func.toParent().isClassDeclaration())\n+                cd = cd2;\n+        }\n+        return checkAccess(cd, loc, sc, d);\n+    }\n+    else if (auto ts = e.type.isTypeStruct())\n+    {\n+        // Do access check\n+        StructDeclaration cd = ts.sym;\n+        return checkAccess(cd, loc, sc, d);\n+    }\n+    return false;\n+}\n+\n+/****************************************\n+ * Check access to package/module `p` from scope `sc`.\n+ *\n+ * Params:\n+ *   sc = scope from which to access to a fully qualified package name\n+ *   p = the package/module to check access for\n+ * Returns: true if the package is not accessible.\n+ *\n+ * Because a global symbol table tree is used for imported packages/modules,\n+ * access to them needs to be checked based on the imports in the scope chain\n+ * (see https://issues.dlang.org/show_bug.cgi?id=313).\n+ *\n+ */\n+bool checkAccess(Scope* sc, Package p)\n+{\n+    if (sc._module == p)\n+        return false;\n+    for (; sc; sc = sc.enclosing)\n+    {\n+        if (sc.scopesym && sc.scopesym.isPackageAccessible(p, Visibility(Visibility.Kind.private_)))\n+            return false;\n+    }\n+\n+    return true;\n+}\n+\n+/**\n+ * Check whether symbols `s` is visible in `mod`.\n+ *\n+ * Params:\n+ *  mod = lookup origin\n+ *  s = symbol to check for visibility\n+ * Returns: true if s is visible in mod\n+ */\n+bool symbolIsVisible(Module mod, Dsymbol s)\n+{\n+    // should sort overloads by ascending visibility instead of iterating here\n+    s = mostVisibleOverload(s);\n+    final switch (s.visible().kind)\n+    {\n+    case Visibility.Kind.undefined: return true;\n+    case Visibility.Kind.none: return false; // no access\n+    case Visibility.Kind.private_: return s.getAccessModule() == mod;\n+    case Visibility.Kind.package_: return s.getAccessModule() == mod || hasPackageAccess(mod, s);\n+    case Visibility.Kind.protected_: return s.getAccessModule() == mod;\n+    case Visibility.Kind.public_, Visibility.Kind.export_: return true;\n+    }\n+}\n+\n+/**\n+ * Same as above, but determines the lookup module from symbols `origin`.\n+ */\n+bool symbolIsVisible(Dsymbol origin, Dsymbol s)\n+{\n+    return symbolIsVisible(origin.getAccessModule(), s);\n+}\n+\n+/**\n+ * Same as above but also checks for protected symbols visible from scope `sc`.\n+ * Used for qualified name lookup.\n+ *\n+ * Params:\n+ *  sc = lookup scope\n+ *  s = symbol to check for visibility\n+ * Returns: true if s is visible by origin\n+ */\n+bool symbolIsVisible(Scope *sc, Dsymbol s)\n+{\n+    s = mostVisibleOverload(s);\n+    return checkSymbolAccess(sc, s);\n+}\n+\n+/**\n+ * Check if a symbol is visible from a given scope without taking\n+ * into account the most visible overload.\n+ *\n+ * Params:\n+ *  sc = lookup scope\n+ *  s = symbol to check for visibility\n+ * Returns: true if s is visible by origin\n+ */\n+bool checkSymbolAccess(Scope *sc, Dsymbol s)\n+{\n+    final switch (s.visible().kind)\n+    {\n+    case Visibility.Kind.undefined: return true;\n+    case Visibility.Kind.none: return false; // no access\n+    case Visibility.Kind.private_: return sc._module == s.getAccessModule();\n+    case Visibility.Kind.package_: return sc._module == s.getAccessModule() || hasPackageAccess(sc._module, s);\n+    case Visibility.Kind.protected_: return hasProtectedAccess(sc, s);\n+    case Visibility.Kind.public_, Visibility.Kind.export_: return true;\n+    }\n+}\n+\n+/**\n+ * Use the most visible overload to check visibility. Later perform an access\n+ * check on the resolved overload.  This function is similar to overloadApply,\n+ * but doesn't recurse nor resolve aliases because visibility is an\n+ * attribute of the alias not the aliasee.\n+ */\n+public Dsymbol mostVisibleOverload(Dsymbol s, Module mod = null)\n+{\n+    if (!s.isOverloadable())\n+        return s;\n+\n+    Dsymbol next, fstart = s, mostVisible = s;\n+    for (; s; s = next)\n+    {\n+        // void func() {}\n+        // private void func(int) {}\n+        if (auto fd = s.isFuncDeclaration())\n+            next = fd.overnext;\n+        // template temp(T) {}\n+        // private template temp(T:int) {}\n+        else if (auto td = s.isTemplateDeclaration())\n+            next = td.overnext;\n+        // alias common = mod1.func1;\n+        // alias common = mod2.func2;\n+        else if (auto fa = s.isFuncAliasDeclaration())\n+            next = fa.overnext;\n+        // alias common = mod1.templ1;\n+        // alias common = mod2.templ2;\n+        else if (auto od = s.isOverDeclaration())\n+            next = od.overnext;\n+        // alias name = sym;\n+        // private void name(int) {}\n+        else if (auto ad = s.isAliasDeclaration())\n+        {\n+            assert(ad.isOverloadable || ad.type && ad.type.ty == Terror,\n+                \"Non overloadable Aliasee in overload list\");\n+            // Yet unresolved aliases store overloads in overnext.\n+            if (ad.semanticRun < PASS.semanticdone)\n+                next = ad.overnext;\n+            else\n+            {\n+                /* This is a bit messy due to the complicated implementation of\n+                 * alias.  Aliases aren't overloadable themselves, but if their\n+                 * Aliasee is overloadable they can be converted to an overloadable\n+                 * alias.\n+                 *\n+                 * This is done by replacing the Aliasee w/ FuncAliasDeclaration\n+                 * (for functions) or OverDeclaration (for templates) which are\n+                 * simply overloadable aliases w/ weird names.\n+                 *\n+                 * Usually aliases should not be resolved for visibility checking\n+                 * b/c public aliases to private symbols are public. But for the\n+                 * overloadable alias situation, the Alias (_ad_) has been moved\n+                 * into its own Aliasee, leaving a shell that we peel away here.\n+                 */\n+                auto aliasee = ad.toAlias();\n+                if (aliasee.isFuncAliasDeclaration || aliasee.isOverDeclaration)\n+                    next = aliasee;\n+                else\n+                {\n+                    /* A simple alias can be at the end of a function or template overload chain.\n+                     * It can't have further overloads b/c it would have been\n+                     * converted to an overloadable alias.\n+                     */\n+                    assert(ad.overnext is null, \"Unresolved overload of alias\");\n+                    break;\n+                }\n+            }\n+            // handled by dmd.func.overloadApply for unknown reason\n+            assert(next !is ad); // should not alias itself\n+            assert(next !is fstart); // should not alias the overload list itself\n+        }\n+        else\n+            break;\n+\n+        /**\n+        * Return the \"effective\" visibility attribute of a symbol when accessed in a module.\n+        * The effective visibility attribute is the same as the regular visibility attribute,\n+        * except package() is \"private\" if the module is outside the package;\n+        * otherwise, \"public\".\n+        */\n+        static Visibility visibilitySeenFromModule(Dsymbol d, Module mod = null)\n+        {\n+            Visibility vis = d.visible();\n+            if (mod && vis.kind == Visibility.Kind.package_)\n+            {\n+                return hasPackageAccess(mod, d) ? Visibility(Visibility.Kind.public_) : Visibility(Visibility.Kind.private_);\n+            }\n+            return vis;\n+        }\n+\n+        if (next &&\n+            visibilitySeenFromModule(mostVisible, mod) < visibilitySeenFromModule(next, mod))\n+            mostVisible = next;\n+    }\n+    return mostVisible;\n+}"}, {"sha": "cff4b9feb45f9c0cf1388d602baf1b641b987a76", "filename": "gcc/d/dmd/aggregate.d", "status": "added", "additions": 769, "deletions": 0, "changes": 769, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Faggregate.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Faggregate.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faggregate.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -0,0 +1,769 @@\n+/**\n+ * Defines a `Dsymbol` representing an aggregate, which is a `struct`, `union` or `class`.\n+ *\n+ * Specification: $(LINK2 https://dlang.org/spec/struct.html, Structs, Unions),\n+ *                $(LINK2 https://dlang.org/spec/class.html, Class).\n+ *\n+ * Copyright:   Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n+ * Authors:     $(LINK2 http://www.digitalmars.com, Walter Bright)\n+ * License:     $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+ * Source:      $(LINK2 https://github.com/dlang/dmd/blob/master/src/dmd/aggregate.d, _aggregate.d)\n+ * Documentation:  https://dlang.org/phobos/dmd_aggregate.html\n+ * Coverage:    https://codecov.io/gh/dlang/dmd/src/master/src/dmd/aggregate.d\n+ */\n+\n+module dmd.aggregate;\n+\n+import core.stdc.stdio;\n+import core.checkedint;\n+\n+import dmd.aliasthis;\n+import dmd.apply;\n+import dmd.arraytypes;\n+import dmd.astenums;\n+import dmd.declaration;\n+import dmd.dscope;\n+import dmd.dstruct;\n+import dmd.dsymbol;\n+import dmd.dsymbolsem;\n+import dmd.dtemplate;\n+import dmd.errors;\n+import dmd.expression;\n+import dmd.func;\n+import dmd.globals;\n+import dmd.id;\n+import dmd.identifier;\n+import dmd.mtype;\n+import dmd.tokens;\n+import dmd.typesem : defaultInit;\n+import dmd.visitor;\n+\n+/**\n+ * The ClassKind enum is used in AggregateDeclaration AST nodes to\n+ * specify the linkage type of the struct/class/interface or if it\n+ * is an anonymous class. If the class is anonymous it is also\n+ * considered to be a D class.\n+ */\n+enum ClassKind : ubyte\n+{\n+    /// the aggregate is a d(efault) class\n+    d,\n+    /// the aggregate is a C++ struct/class/interface\n+    cpp,\n+    /// the aggregate is an Objective-C class/interface\n+    objc,\n+    /// the aggregate is a C struct\n+    c,\n+}\n+\n+/**\n+ * If an aggregate has a pargma(mangle, ...) this holds the information\n+ * to mangle.\n+ */\n+struct MangleOverride\n+{\n+    Dsymbol agg;   // The symbol to copy template parameters from (if any)\n+    Identifier id; // the name to override the aggregate's with, defaults to agg.ident\n+}\n+\n+/***********************************************************\n+ * Abstract aggregate as a common ancestor for Class- and StructDeclaration.\n+ */\n+extern (C++) abstract class AggregateDeclaration : ScopeDsymbol\n+{\n+    Type type;                  ///\n+    StorageClass storage_class; ///\n+    uint structsize;            /// size of struct\n+    uint alignsize;             /// size of struct for alignment purposes\n+    VarDeclarations fields;     /// VarDeclaration fields\n+    Dsymbol deferred;           /// any deferred semantic2() or semantic3() symbol\n+\n+    /// specifies whether this is a D, C++, Objective-C or anonymous struct/class/interface\n+    ClassKind classKind;\n+    /// Specify whether to mangle the aggregate as a `class` or a `struct`\n+    /// This information is used by the MSVC mangler\n+    /// Only valid for class and struct. TODO: Merge with ClassKind ?\n+    CPPMANGLE cppmangle;\n+\n+    /// overridden symbol with pragma(mangle, \"...\") if not null\n+    MangleOverride* mangleOverride;\n+\n+    /**\n+     * !=null if is nested\n+     * pointing to the dsymbol that directly enclosing it.\n+     * 1. The function that enclosing it (nested struct and class)\n+     * 2. The class that enclosing it (nested class only)\n+     * 3. If enclosing aggregate is template, its enclosing dsymbol.\n+     *\n+     * See AggregateDeclaraton::makeNested for the details.\n+     */\n+    Dsymbol enclosing;\n+\n+    VarDeclaration vthis;   /// 'this' parameter if this aggregate is nested\n+    VarDeclaration vthis2;  /// 'this' parameter if this aggregate is a template and is nested\n+\n+    // Special member functions\n+    FuncDeclarations invs;  /// Array of invariants\n+    FuncDeclaration inv;    /// Merged invariant calling all members of invs\n+\n+    /// CtorDeclaration or TemplateDeclaration\n+    Dsymbol ctor;\n+\n+    /// default constructor - should have no arguments, because\n+    /// it would be stored in TypeInfo_Class.defaultConstructor\n+    CtorDeclaration defaultCtor;\n+\n+    AliasThis aliasthis;    /// forward unresolved lookups to aliasthis\n+\n+    DtorDeclarations dtors;     /// Array of destructors\n+    DtorDeclaration dtor;       /// aggregate destructor calling dtors and member constructors\n+    DtorDeclaration primaryDtor;/// non-deleting C++ destructor, same as dtor for D\n+    DtorDeclaration tidtor;     /// aggregate destructor used in TypeInfo (must have extern(D) ABI)\n+    FuncDeclaration fieldDtor;  /// aggregate destructor for just the fields\n+\n+    Expression getRTInfo;   /// pointer to GC info generated by object.RTInfo(this)\n+\n+    ///\n+    Visibility visibility;\n+    bool noDefaultCtor;             /// no default construction\n+    bool disableNew;                /// disallow allocations using `new`\n+    Sizeok sizeok = Sizeok.none;    /// set when structsize contains valid data\n+\n+    final extern (D) this(const ref Loc loc, Identifier id)\n+    {\n+        super(loc, id);\n+        visibility = Visibility(Visibility.Kind.public_);\n+    }\n+\n+    /***************************************\n+     * Create a new scope from sc.\n+     * semantic, semantic2 and semantic3 will use this for aggregate members.\n+     */\n+    Scope* newScope(Scope* sc)\n+    {\n+        auto sc2 = sc.push(this);\n+        sc2.stc &= STC.flowThruAggregate;\n+        sc2.parent = this;\n+        sc2.inunion = isUnionDeclaration();\n+        sc2.visibility = Visibility(Visibility.Kind.public_);\n+        sc2.explicitVisibility = 0;\n+        sc2.aligndecl = null;\n+        sc2.userAttribDecl = null;\n+        sc2.namespace = null;\n+        return sc2;\n+    }\n+\n+    override final void setScope(Scope* sc)\n+    {\n+        // Might need a scope to resolve forward references. The check for\n+        // semanticRun prevents unnecessary setting of _scope during deferred\n+        // setScope phases for aggregates which already finished semantic().\n+        // See https://issues.dlang.org/show_bug.cgi?id=16607\n+        if (semanticRun < PASS.semanticdone)\n+            ScopeDsymbol.setScope(sc);\n+    }\n+\n+    /***************************************\n+     * Returns:\n+     *      The total number of fields minus the number of hidden fields.\n+     */\n+    final size_t nonHiddenFields()\n+    {\n+        return fields.dim - isNested() - (vthis2 !is null);\n+    }\n+\n+    /***************************************\n+     * Collect all instance fields, then determine instance size.\n+     * Returns:\n+     *      false if failed to determine the size.\n+     */\n+    final bool determineSize(Loc loc)\n+    {\n+        //printf(\"AggregateDeclaration::determineSize() %s, sizeok = %d\\n\", toChars(), sizeok);\n+\n+        // The previous instance size finalizing had:\n+        if (type.ty == Terror)\n+            return false;   // failed already\n+        if (sizeok == Sizeok.done)\n+            return true;    // succeeded\n+\n+        if (!members)\n+        {\n+            error(loc, \"unknown size\");\n+            return false;\n+        }\n+\n+        if (_scope)\n+            dsymbolSemantic(this, null);\n+\n+        // Determine the instance size of base class first.\n+        if (auto cd = isClassDeclaration())\n+        {\n+            cd = cd.baseClass;\n+            if (cd && !cd.determineSize(loc))\n+                goto Lfail;\n+        }\n+\n+        // Determine instance fields when sizeok == Sizeok.none\n+        if (!this.determineFields())\n+            goto Lfail;\n+        if (sizeok != Sizeok.done)\n+            finalizeSize();\n+\n+        // this aggregate type has:\n+        if (type.ty == Terror)\n+            return false;   // marked as invalid during the finalizing.\n+        if (sizeok == Sizeok.done)\n+            return true;    // succeeded to calculate instance size.\n+\n+    Lfail:\n+        // There's unresolvable forward reference.\n+        if (type != Type.terror)\n+            error(loc, \"no size because of forward reference\");\n+        // Don't cache errors from speculative semantic, might be resolvable later.\n+        // https://issues.dlang.org/show_bug.cgi?id=16574\n+        if (!global.gag)\n+        {\n+            type = Type.terror;\n+            errors = true;\n+        }\n+        return false;\n+    }\n+\n+    abstract void finalizeSize();\n+\n+    override final d_uns64 size(const ref Loc loc)\n+    {\n+        //printf(\"+AggregateDeclaration::size() %s, scope = %p, sizeok = %d\\n\", toChars(), _scope, sizeok);\n+        bool ok = determineSize(loc);\n+        //printf(\"-AggregateDeclaration::size() %s, scope = %p, sizeok = %d\\n\", toChars(), _scope, sizeok);\n+        return ok ? structsize : SIZE_INVALID;\n+    }\n+\n+    /***************************************\n+     * Calculate field[i].overlapped and overlapUnsafe, and check that all of explicit\n+     * field initializers have unique memory space on instance.\n+     * Returns:\n+     *      true if any errors happen.\n+     */\n+    extern (D) final bool checkOverlappedFields()\n+    {\n+        //printf(\"AggregateDeclaration::checkOverlappedFields() %s\\n\", toChars());\n+        assert(sizeok == Sizeok.done);\n+        size_t nfields = fields.dim;\n+        if (isNested())\n+        {\n+            auto cd = isClassDeclaration();\n+            if (!cd || !cd.baseClass || !cd.baseClass.isNested())\n+                nfields--;\n+            if (vthis2 && !(cd && cd.baseClass && cd.baseClass.vthis2))\n+                nfields--;\n+        }\n+        bool errors = false;\n+\n+        // Fill in missing any elements with default initializers\n+        foreach (i; 0 .. nfields)\n+        {\n+            auto vd = fields[i];\n+            if (vd.errors)\n+            {\n+                errors = true;\n+                continue;\n+            }\n+\n+            const vdIsVoidInit = vd._init && vd._init.isVoidInitializer();\n+\n+            // Find overlapped fields with the hole [vd.offset .. vd.offset.size()].\n+            foreach (j; 0 .. nfields)\n+            {\n+                if (i == j)\n+                    continue;\n+                auto v2 = fields[j];\n+                if (v2.errors)\n+                {\n+                    errors = true;\n+                    continue;\n+                }\n+                if (!vd.isOverlappedWith(v2))\n+                    continue;\n+\n+                // vd and v2 are overlapping.\n+                vd.overlapped = true;\n+                v2.overlapped = true;\n+\n+                if (!MODimplicitConv(vd.type.mod, v2.type.mod))\n+                    v2.overlapUnsafe = true;\n+                if (!MODimplicitConv(v2.type.mod, vd.type.mod))\n+                    vd.overlapUnsafe = true;\n+\n+                if (i > j)\n+                    continue;\n+\n+                if (!v2._init)\n+                    continue;\n+\n+                if (v2._init.isVoidInitializer())\n+                    continue;\n+\n+                if (vd._init && !vdIsVoidInit && v2._init)\n+                {\n+                    .error(loc, \"overlapping default initialization for field `%s` and `%s`\", v2.toChars(), vd.toChars());\n+                    errors = true;\n+                }\n+                else if (v2._init && i < j)\n+                {\n+                    .error(v2.loc, \"union field `%s` with default initialization `%s` must be before field `%s`\",\n+                        v2.toChars(), v2._init.toChars(), vd.toChars());\n+                    errors = true;\n+                }\n+            }\n+        }\n+        return errors;\n+    }\n+\n+    /***************************************\n+     * Fill out remainder of elements[] with default initializers for fields[].\n+     * Params:\n+     *      loc         = location\n+     *      elements    = explicit arguments which given to construct object.\n+     *      ctorinit    = true if the elements will be used for default initialization.\n+     * Returns:\n+     *      false if any errors occur.\n+     *      Otherwise, returns true and the missing arguments will be pushed in elements[].\n+     */\n+    final bool fill(Loc loc, Expressions* elements, bool ctorinit)\n+    {\n+        //printf(\"AggregateDeclaration::fill() %s\\n\", toChars());\n+        assert(sizeok == Sizeok.done);\n+        assert(elements);\n+        const nfields = nonHiddenFields();\n+        bool errors = false;\n+\n+        size_t dim = elements.dim;\n+        elements.setDim(nfields);\n+        foreach (size_t i; dim .. nfields)\n+            (*elements)[i] = null;\n+\n+        // Fill in missing any elements with default initializers\n+        foreach (i; 0 .. nfields)\n+        {\n+            if ((*elements)[i])\n+                continue;\n+\n+            auto vd = fields[i];\n+            auto vx = vd;\n+            if (vd._init && vd._init.isVoidInitializer())\n+                vx = null;\n+\n+            // Find overlapped fields with the hole [vd.offset .. vd.offset.size()].\n+            size_t fieldi = i;\n+            foreach (j; 0 .. nfields)\n+            {\n+                if (i == j)\n+                    continue;\n+                auto v2 = fields[j];\n+                if (!vd.isOverlappedWith(v2))\n+                    continue;\n+\n+                if ((*elements)[j])\n+                {\n+                    vx = null;\n+                    break;\n+                }\n+                if (v2._init && v2._init.isVoidInitializer())\n+                    continue;\n+\n+                version (all)\n+                {\n+                    /* Prefer first found non-void-initialized field\n+                     * union U { int a; int b = 2; }\n+                     * U u;    // Error: overlapping initialization for field a and b\n+                     */\n+                    if (!vx)\n+                    {\n+                        vx = v2;\n+                        fieldi = j;\n+                    }\n+                    else if (v2._init)\n+                    {\n+                        .error(loc, \"overlapping initialization for field `%s` and `%s`\", v2.toChars(), vd.toChars());\n+                        errors = true;\n+                    }\n+                }\n+                else\n+                {\n+                    // fixes https://issues.dlang.org/show_bug.cgi?id=1432 by enabling this path always\n+\n+                    /* Prefer explicitly initialized field\n+                     * union U { int a; int b = 2; }\n+                     * U u;    // OK (u.b == 2)\n+                     */\n+                    if (!vx || !vx._init && v2._init)\n+                    {\n+                        vx = v2;\n+                        fieldi = j;\n+                    }\n+                    else if (vx != vd && !vx.isOverlappedWith(v2))\n+                    {\n+                        // Both vx and v2 fills vd, but vx and v2 does not overlap\n+                    }\n+                    else if (vx._init && v2._init)\n+                    {\n+                        .error(loc, \"overlapping default initialization for field `%s` and `%s`\",\n+                            v2.toChars(), vd.toChars());\n+                        errors = true;\n+                    }\n+                    else\n+                        assert(vx._init || !vx._init && !v2._init);\n+                }\n+            }\n+            if (vx)\n+            {\n+                Expression e;\n+                if (vx.type.size() == 0)\n+                {\n+                    e = null;\n+                }\n+                else if (vx._init)\n+                {\n+                    assert(!vx._init.isVoidInitializer());\n+                    if (vx.inuse)   // https://issues.dlang.org/show_bug.cgi?id=18057\n+                    {\n+                        vx.error(loc, \"recursive initialization of field\");\n+                        errors = true;\n+                    }\n+                    else\n+                        e = vx.getConstInitializer(false);\n+                }\n+                else\n+                {\n+                    if ((vx.storage_class & STC.nodefaultctor) && !ctorinit)\n+                    {\n+                        .error(loc, \"field `%s.%s` must be initialized because it has no default constructor\",\n+                            type.toChars(), vx.toChars());\n+                        errors = true;\n+                    }\n+                    /* https://issues.dlang.org/show_bug.cgi?id=12509\n+                     * Get the element of static array type.\n+                     */\n+                    Type telem = vx.type;\n+                    if (telem.ty == Tsarray)\n+                    {\n+                        /* We cannot use Type::baseElemOf() here.\n+                         * If the bottom of the Tsarray is an enum type, baseElemOf()\n+                         * will return the base of the enum, and its default initializer\n+                         * would be different from the enum's.\n+                         */\n+                        TypeSArray tsa;\n+                        while ((tsa = telem.toBasetype().isTypeSArray()) !is null)\n+                            telem = tsa.next;\n+                        if (telem.ty == Tvoid)\n+                            telem = Type.tuns8.addMod(telem.mod);\n+                    }\n+                    if (telem.needsNested() && ctorinit)\n+                        e = telem.defaultInit(loc);\n+                    else\n+                        e = telem.defaultInitLiteral(loc);\n+                }\n+                (*elements)[fieldi] = e;\n+            }\n+        }\n+        foreach (e; *elements)\n+        {\n+            if (e && e.op == TOK.error)\n+                return false;\n+        }\n+\n+        return !errors;\n+    }\n+\n+    /****************************\n+     * Do byte or word alignment as necessary.\n+     * Align sizes of 0, as we may not know array sizes yet.\n+     * Params:\n+     *   alignment = struct alignment that is in effect\n+     *   size = alignment requirement of field\n+     *   poffset = pointer to offset to be aligned\n+     */\n+    extern (D) static void alignmember(structalign_t alignment, uint size, uint* poffset) pure nothrow @safe\n+    {\n+        //printf(\"alignment = %d, size = %d, offset = %d\\n\",alignment,size,offset);\n+        switch (alignment)\n+        {\n+        case cast(structalign_t)1:\n+            // No alignment\n+            break;\n+\n+        case cast(structalign_t)STRUCTALIGN_DEFAULT:\n+            // Alignment in Target::fieldalignsize must match what the\n+            // corresponding C compiler's default alignment behavior is.\n+            assert(size > 0 && !(size & (size - 1)));\n+            *poffset = (*poffset + size - 1) & ~(size - 1);\n+            break;\n+\n+        default:\n+            // Align on alignment boundary, which must be a positive power of 2\n+            assert(alignment > 0 && !(alignment & (alignment - 1)));\n+            *poffset = (*poffset + alignment - 1) & ~(alignment - 1);\n+            break;\n+        }\n+    }\n+\n+    /****************************************\n+     * Place a member (mem) into an aggregate (agg), which can be a struct, union or class\n+     * Returns:\n+     *      offset to place field at\n+     *\n+     * nextoffset:    next location in aggregate\n+     * memsize:       size of member\n+     * memalignsize:  natural alignment of member\n+     * alignment:     alignment in effect for this member\n+     * paggsize:      size of aggregate (updated)\n+     * paggalignsize: alignment of aggregate (updated)\n+     * isunion:       the aggregate is a union\n+     */\n+    extern (D) static uint placeField(uint* nextoffset, uint memsize, uint memalignsize,\n+        structalign_t alignment, uint* paggsize, uint* paggalignsize, bool isunion)\n+    {\n+        uint ofs = *nextoffset;\n+\n+        const uint actualAlignment =\n+            alignment == STRUCTALIGN_DEFAULT ? memalignsize : alignment;\n+\n+        // Ensure no overflow\n+        bool overflow;\n+        const sz = addu(memsize, actualAlignment, overflow);\n+        addu(ofs, sz, overflow);\n+        if (overflow) assert(0);\n+\n+        alignmember(alignment, memalignsize, &ofs);\n+        uint memoffset = ofs;\n+        ofs += memsize;\n+        if (ofs > *paggsize)\n+            *paggsize = ofs;\n+        if (!isunion)\n+            *nextoffset = ofs;\n+\n+        if (*paggalignsize < actualAlignment)\n+            *paggalignsize = actualAlignment;\n+\n+        return memoffset;\n+    }\n+\n+    override final Type getType()\n+    {\n+        return type;\n+    }\n+\n+    // is aggregate deprecated?\n+    override final bool isDeprecated() const\n+    {\n+        return !!(this.storage_class & STC.deprecated_);\n+    }\n+\n+    /// Flag this aggregate as deprecated\n+    final void setDeprecated()\n+    {\n+        this.storage_class |= STC.deprecated_;\n+    }\n+\n+    /****************************************\n+     * Returns true if there's an extra member which is the 'this'\n+     * pointer to the enclosing context (enclosing aggregate or function)\n+     */\n+    final bool isNested() const\n+    {\n+        return enclosing !is null;\n+    }\n+\n+    /* Append vthis field (this.tupleof[$-1]) to make this aggregate type nested.\n+     */\n+    extern (D) final void makeNested()\n+    {\n+        if (enclosing) // if already nested\n+            return;\n+        if (sizeok == Sizeok.done)\n+            return;\n+        if (isUnionDeclaration() || isInterfaceDeclaration())\n+            return;\n+        if (storage_class & STC.static_)\n+            return;\n+\n+        // If nested struct, add in hidden 'this' pointer to outer scope\n+        auto s = toParentLocal();\n+        if (!s)\n+            s = toParent2();\n+        if (!s)\n+            return;\n+        Type t = null;\n+        if (auto fd = s.isFuncDeclaration())\n+        {\n+            enclosing = fd;\n+\n+            /* https://issues.dlang.org/show_bug.cgi?id=14422\n+             * If a nested class parent is a function, its\n+             * context pointer (== `outer`) should be void* always.\n+             */\n+            t = Type.tvoidptr;\n+        }\n+        else if (auto ad = s.isAggregateDeclaration())\n+        {\n+            if (isClassDeclaration() && ad.isClassDeclaration())\n+            {\n+                enclosing = ad;\n+            }\n+            else if (isStructDeclaration())\n+            {\n+                if (auto ti = ad.parent.isTemplateInstance())\n+                {\n+                    enclosing = ti.enclosing;\n+                }\n+            }\n+            t = ad.handleType();\n+        }\n+        if (enclosing)\n+        {\n+            //printf(\"makeNested %s, enclosing = %s\\n\", toChars(), enclosing.toChars());\n+            assert(t);\n+            if (t.ty == Tstruct)\n+                t = Type.tvoidptr; // t should not be a ref type\n+\n+            assert(!vthis);\n+            vthis = new ThisDeclaration(loc, t);\n+            //vthis.storage_class |= STC.ref_;\n+\n+            // Emulate vthis.addMember()\n+            members.push(vthis);\n+\n+            // Emulate vthis.dsymbolSemantic()\n+            vthis.storage_class |= STC.field;\n+            vthis.parent = this;\n+            vthis.visibility = Visibility(Visibility.Kind.public_);\n+            vthis.alignment = t.alignment();\n+            vthis.semanticRun = PASS.semanticdone;\n+\n+            if (sizeok == Sizeok.fwd)\n+                fields.push(vthis);\n+\n+            makeNested2();\n+        }\n+    }\n+\n+    /* Append vthis2 field (this.tupleof[$-1]) to add a second context pointer.\n+     */\n+    extern (D) final void makeNested2()\n+    {\n+        if (vthis2)\n+            return;\n+        if (!vthis)\n+            makeNested();   // can't add second before first\n+        if (!vthis)\n+            return;\n+        if (sizeok == Sizeok.done)\n+            return;\n+        if (isUnionDeclaration() || isInterfaceDeclaration())\n+            return;\n+        if (storage_class & STC.static_)\n+            return;\n+\n+        auto s0 = toParentLocal();\n+        auto s = toParent2();\n+        if (!s || !s0 || s == s0)\n+            return;\n+        auto cd = s.isClassDeclaration();\n+        Type t = cd ? cd.type : Type.tvoidptr;\n+\n+        vthis2 = new ThisDeclaration(loc, t);\n+        //vthis2.storage_class |= STC.ref_;\n+\n+        // Emulate vthis2.addMember()\n+        members.push(vthis2);\n+\n+        // Emulate vthis2.dsymbolSemantic()\n+        vthis2.storage_class |= STC.field;\n+        vthis2.parent = this;\n+        vthis2.visibility = Visibility(Visibility.Kind.public_);\n+        vthis2.alignment = t.alignment();\n+        vthis2.semanticRun = PASS.semanticdone;\n+\n+        if (sizeok == Sizeok.fwd)\n+            fields.push(vthis2);\n+    }\n+\n+    override final bool isExport() const\n+    {\n+        return visibility.kind == Visibility.Kind.export_;\n+    }\n+\n+    /*******************************************\n+     * Look for constructor declaration.\n+     */\n+    final Dsymbol searchCtor()\n+    {\n+        auto s = search(Loc.initial, Id.ctor);\n+        if (s)\n+        {\n+            if (!(s.isCtorDeclaration() ||\n+                  s.isTemplateDeclaration() ||\n+                  s.isOverloadSet()))\n+            {\n+                s.error(\"is not a constructor; identifiers starting with `__` are reserved for the implementation\");\n+                errors = true;\n+                s = null;\n+            }\n+        }\n+        if (s && s.toParent() != this)\n+            s = null; // search() looks through ancestor classes\n+        if (s)\n+        {\n+            // Finish all constructors semantics to determine this.noDefaultCtor.\n+            struct SearchCtor\n+            {\n+                extern (C++) static int fp(Dsymbol s, void* ctxt)\n+                {\n+                    auto f = s.isCtorDeclaration();\n+                    if (f && f.semanticRun == PASS.init)\n+                        f.dsymbolSemantic(null);\n+                    return 0;\n+                }\n+            }\n+\n+            for (size_t i = 0; i < members.dim; i++)\n+            {\n+                auto sm = (*members)[i];\n+                sm.apply(&SearchCtor.fp, null);\n+            }\n+        }\n+        return s;\n+    }\n+\n+    override final Visibility visible() pure nothrow @nogc @safe\n+    {\n+        return visibility;\n+    }\n+\n+    // 'this' type\n+    final Type handleType()\n+    {\n+        return type;\n+    }\n+\n+    // Does this class have an invariant function?\n+    final bool hasInvariant()\n+    {\n+        return invs.length != 0;\n+    }\n+\n+    // Back end\n+    void* sinit;  /// initializer symbol\n+\n+    override final inout(AggregateDeclaration) isAggregateDeclaration() inout\n+    {\n+        return this;\n+    }\n+\n+    override void accept(Visitor v)\n+    {\n+        v.visit(this);\n+    }\n+}"}, {"sha": "f8d2f45706ae5f066c097fe6e30c4f555cc8bdf2", "filename": "gcc/d/dmd/aggregate.h", "status": "modified", "additions": 87, "deletions": 102, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Faggregate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Faggregate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faggregate.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -10,95 +10,79 @@\n \n #pragma once\n \n-#include \"root/root.h\"\n-\n #include \"dsymbol.h\"\n-#include \"declaration.h\"\n #include \"objc.h\"\n \n+class AliasThis;\n class Identifier;\n class Type;\n class TypeFunction;\n class Expression;\n class FuncDeclaration;\n class CtorDeclaration;\n class DtorDeclaration;\n-class InvariantDeclaration;\n-class NewDeclaration;\n-class DeleteDeclaration;\n class InterfaceDeclaration;\n class TypeInfoClassDeclaration;\n class VarDeclaration;\n \n-enum Sizeok\n+enum class Sizeok : uint8_t\n {\n-    SIZEOKnone,         // size of aggregate is not yet able to compute\n-    SIZEOKfwd,          // size of aggregate is ready to compute\n-    SIZEOKdone          // size of aggregate is set correctly\n+    none,         // size of aggregate is not yet able to compute\n+    fwd,          // size of aggregate is ready to compute\n+    inProcess,    // in the midst of computing the size\n+    done          // size of aggregate is set correctly\n };\n \n-enum Baseok\n+enum class Baseok : uint8_t\n {\n-    BASEOKnone,         // base classes not computed yet\n-    BASEOKin,           // in process of resolving base classes\n-    BASEOKdone,         // all base classes are resolved\n-    BASEOKsemanticdone  // all base classes semantic done\n+    none,         // base classes not computed yet\n+    in,           // in process of resolving base classes\n+    done,         // all base classes are resolved\n+    semanticdone  // all base classes semantic done\n };\n \n-enum StructPOD\n+enum class ThreeState : uint8_t\n {\n-    ISPODno,            // struct is not POD\n-    ISPODyes,           // struct is POD\n-    ISPODfwd            // POD not yet computed\n+    none,         // value not yet computed\n+    no,           // value is false\n+    yes,          // value is true\n };\n \n-enum Abstract\n+FuncDeclaration *search_toString(StructDeclaration *sd);\n+\n+enum class ClassKind : uint8_t\n {\n-    ABSfwdref = 0,      // whether an abstract class is not yet computed\n-    ABSyes,             // is abstract class\n-    ABSno               // is not abstract class\n+  /// the aggregate is a d(efault) struct/class/interface\n+  d,\n+  /// the aggregate is a C++ struct/class/interface\n+  cpp,\n+  /// the aggregate is an Objective-C class/interface\n+  objc,\n+  /// the aggregate is a C struct\n+  c,\n };\n \n-FuncDeclaration *hasIdentityOpAssign(AggregateDeclaration *ad, Scope *sc);\n-FuncDeclaration *buildOpAssign(StructDeclaration *sd, Scope *sc);\n-bool needOpEquals(StructDeclaration *sd);\n-FuncDeclaration *buildOpEquals(StructDeclaration *sd, Scope *sc);\n-FuncDeclaration *buildXopEquals(StructDeclaration *sd, Scope *sc);\n-FuncDeclaration *buildXopCmp(StructDeclaration *sd, Scope *sc);\n-FuncDeclaration *buildXtoHash(StructDeclaration *ad, Scope *sc);\n-FuncDeclaration *buildPostBlit(StructDeclaration *sd, Scope *sc);\n-FuncDeclaration *buildDtor(AggregateDeclaration *ad, Scope *sc);\n-FuncDeclaration *buildInv(AggregateDeclaration *ad, Scope *sc);\n-FuncDeclaration *search_toString(StructDeclaration *sd);\n-\n-struct ClassKind\n+struct MangleOverride\n {\n-    enum Type\n-    {\n-        /// the class is a d(efault) class\n-        d,\n-        /// the class is a C++ interface\n-        cpp,\n-        /// the class is an Objective-C class/interface\n-        objc,\n-    };\n+    Dsymbol *agg;\n+    Identifier *id;\n };\n \n class AggregateDeclaration : public ScopeDsymbol\n {\n public:\n     Type *type;\n     StorageClass storage_class;\n-    Prot protection;\n     unsigned structsize;        // size of struct\n     unsigned alignsize;         // size of struct for alignment purposes\n     VarDeclarations fields;     // VarDeclaration fields\n-    Sizeok sizeok;              // set when structsize contains valid data\n     Dsymbol *deferred;          // any deferred semantic2() or semantic3() symbol\n-    bool isdeprecated;          // true if deprecated\n \n-    ClassKind::Type classKind;  // specifies the linkage type\n+    ClassKind classKind;        // specifies the linkage type\n+    CPPMANGLE cppmangle;\n \n+    // overridden symbol with pragma(mangle, \"...\")\n+    MangleOverride *mangleOverride;\n     /* !=NULL if is nested\n      * pointing to the dsymbol that directly enclosing it.\n      * 1. The function that enclosing it (nested struct and class)\n@@ -108,63 +92,63 @@ class AggregateDeclaration : public ScopeDsymbol\n      */\n     Dsymbol *enclosing;\n     VarDeclaration *vthis;      // 'this' parameter if this aggregate is nested\n+    VarDeclaration *vthis2;     // 'this' parameter if this aggregate is a template and is nested\n     // Special member functions\n     FuncDeclarations invs;              // Array of invariants\n     FuncDeclaration *inv;               // invariant\n-    NewDeclaration *aggNew;             // allocator\n-    DeleteDeclaration *aggDelete;       // deallocator\n \n     Dsymbol *ctor;                      // CtorDeclaration or TemplateDeclaration\n \n     // default constructor - should have no arguments, because\n     // it would be stored in TypeInfo_Class.defaultConstructor\n     CtorDeclaration *defaultCtor;\n \n-    Dsymbol *aliasthis;         // forward unresolved lookups to aliasthis\n-    bool noDefaultCtor;         // no default construction\n+    AliasThis *aliasthis;       // forward unresolved lookups to aliasthis\n \n-    FuncDeclarations dtors;     // Array of destructors\n-    FuncDeclaration *dtor;      // aggregate destructor\n+    DtorDeclarations dtors;     // Array of destructors\n+    DtorDeclaration *dtor;      // aggregate destructor\n+    DtorDeclaration *primaryDtor; // non-deleting C++ destructor, same as dtor for D\n+    DtorDeclaration *tidtor;    // aggregate destructor used in TypeInfo (must have extern(D) ABI)\n+    FuncDeclaration *fieldDtor;   // aggregate destructor for just the fields\n \n     Expression *getRTInfo;      // pointer to GC info generated by object.RTInfo(this)\n \n-    AggregateDeclaration(Loc loc, Identifier *id);\n+    Visibility visibility;\n+    bool noDefaultCtor;         // no default construction\n+    bool disableNew;            // disallow allocations using `new`\n+    Sizeok sizeok;              // set when structsize contains valid data\n+\n     virtual Scope *newScope(Scope *sc);\n     void setScope(Scope *sc);\n-    bool determineFields();\n+    size_t nonHiddenFields();\n     bool determineSize(Loc loc);\n     virtual void finalizeSize() = 0;\n-    d_uns64 size(Loc loc);\n-    bool checkOverlappedFields();\n+    d_uns64 size(const Loc &loc);\n     bool fill(Loc loc, Expressions *elements, bool ctorinit);\n-    static void alignmember(structalign_t salign, unsigned size, unsigned *poffset);\n-    static unsigned placeField(unsigned *nextoffset,\n-        unsigned memsize, unsigned memalignsize, structalign_t memalign,\n-        unsigned *paggsize, unsigned *paggalignsize, bool isunion);\n     Type *getType();\n-    bool isDeprecated();         // is aggregate deprecated?\n-    bool isNested();\n-    void makeNested();\n+    bool isDeprecated() const;         // is aggregate deprecated?\n+    void setDeprecated();\n+    bool isNested() const;\n     bool isExport() const;\n     Dsymbol *searchCtor();\n \n-    Prot prot();\n+    Visibility visible();\n \n     // 'this' type\n     Type *handleType() { return type; }\n \n+    bool hasInvariant();\n+\n     // Back end\n-    Symbol *stag;               // tag symbol for debug data\n-    Symbol *sinit;\n+    void *sinit;\n \n     AggregateDeclaration *isAggregateDeclaration() { return this; }\n     void accept(Visitor *v) { v->visit(this); }\n };\n \n struct StructFlags\n {\n-    typedef unsigned Type;\n-    enum Enum\n+    enum Type\n     {\n         none = 0x0,\n         hasPointers = 0x1  // NB: should use noPointers as in ClassFlags\n@@ -174,9 +158,17 @@ struct StructFlags\n class StructDeclaration : public AggregateDeclaration\n {\n public:\n-    int zeroInit;               // !=0 if initialize with 0 fill\n+    bool zeroInit;              // !=0 if initialize with 0 fill\n     bool hasIdentityAssign;     // true if has identity opAssign\n+    bool hasBlitAssign;         // true if opAssign is a blit\n     bool hasIdentityEquals;     // true if has identity opEquals\n+    bool hasNoFields;           // has no fields\n+    bool hasCopyCtor;           // copy constructor\n+    // Even if struct is defined as non-root symbol, some built-in operations\n+    // (e.g. TypeidExp, NewExp, ArrayLiteralExp, etc) request its TypeInfo.\n+    // For those, today TypeInfo_Struct is generated in COMDAT.\n+    bool requestTypeInfo;\n+\n     FuncDeclarations postblits; // Array of postblit functions\n     FuncDeclaration *postblit;  // aggregate postblit\n \n@@ -187,36 +179,30 @@ class StructDeclaration : public AggregateDeclaration\n     static FuncDeclaration *xerrcmp;     // object.xopCmp\n \n     structalign_t alignment;    // alignment applied outside of the struct\n-    StructPOD ispod;            // if struct is POD\n+    ThreeState ispod;           // if struct is POD\n \n-    // For 64 bit Efl function call/return ABI\n-    Type *arg1type;\n-    Type *arg2type;\n+    // ABI-specific type(s) if the struct can be passed in registers\n+    TypeTuple *argTypes;\n \n-    // Even if struct is defined as non-root symbol, some built-in operations\n-    // (e.g. TypeidExp, NewExp, ArrayLiteralExp, etc) request its TypeInfo.\n-    // For those, today TypeInfo_Struct is generated in COMDAT.\n-    bool requestTypeInfo;\n-\n-    StructDeclaration(Loc loc, Identifier *id, bool inObject);\n     static StructDeclaration *create(Loc loc, Identifier *id, bool inObject);\n-    Dsymbol *syntaxCopy(Dsymbol *s);\n-    void semanticTypeInfoMembers();\n+    StructDeclaration *syntaxCopy(Dsymbol *s);\n     Dsymbol *search(const Loc &loc, Identifier *ident, int flags = SearchLocalsOnly);\n     const char *kind() const;\n     void finalizeSize();\n-    bool fit(Loc loc, Scope *sc, Expressions *elements, Type *stype);\n     bool isPOD();\n \n     StructDeclaration *isStructDeclaration() { return this; }\n     void accept(Visitor *v) { v->visit(this); }\n+\n+    unsigned numArgTypes() const;\n+    Type *argType(unsigned index);\n+    bool hasRegularCtor(bool checkDisabled = false);\n };\n \n class UnionDeclaration : public StructDeclaration\n {\n public:\n-    UnionDeclaration(Loc loc, Identifier *id);\n-    Dsymbol *syntaxCopy(Dsymbol *s);\n+    UnionDeclaration *syntaxCopy(Dsymbol *s);\n     const char *kind() const;\n \n     UnionDeclaration *isUnionDeclaration() { return this; }\n@@ -236,18 +222,14 @@ struct BaseClass\n     DArray<BaseClass> baseInterfaces;   // if BaseClass is an interface, these\n                                         // are a copy of the InterfaceDeclaration::interfaces\n \n-    BaseClass();\n-    BaseClass(Type *type);\n-\n     bool fillVtbl(ClassDeclaration *cd, FuncDeclarations *vtbl, int newinstance);\n-    void copyBaseInterfaces(BaseClasses *);\n };\n \n struct ClassFlags\n {\n-    typedef unsigned Type;\n-    enum Enum\n+    enum Type\n     {\n+        none = 0x0,\n         isCOMclass = 0x1,\n         noPointers = 0x2,\n         hasOffTi = 0x4,\n@@ -286,15 +268,18 @@ class ClassDeclaration : public AggregateDeclaration\n \n     TypeInfoClassDeclaration *vclassinfo;       // the ClassInfo object for this ClassDeclaration\n     bool com;                           // true if this is a COM class (meaning it derives from IUnknown)\n-    bool isscope;                       // true if this is a scope class\n-    Abstract isabstract;                // 0: fwdref, 1: is abstract class, 2: not abstract\n-    int inuse;                          // to prevent recursive attempts\n+    bool stack;                         // true if this is a scope class\n+    int cppDtorVtblIndex;               // slot reserved for the virtual destructor [extern(C++)]\n+    bool inuse;                         // to prevent recursive attempts\n+\n+    ThreeState isabstract;              // if abstract class\n     Baseok baseok;                      // set the progress of base classes resolving\n+    ObjcClassDeclaration objc;          // Data for a class declaration that is needed for the Objective-C integration\n     Symbol *cpp_type_info_ptr_sym;      // cached instance of class Id.cpp_type_info_ptr\n \n-    ClassDeclaration(Loc loc, Identifier *id, BaseClasses *baseclasses, Dsymbols *members, bool inObject = false);\n     static ClassDeclaration *create(Loc loc, Identifier *id, BaseClasses *baseclasses, Dsymbols *members, bool inObject);\n-    Dsymbol *syntaxCopy(Dsymbol *s);\n+    const char *toPrettyChars(bool QualifyTypes = false);\n+    ClassDeclaration *syntaxCopy(Dsymbol *s);\n     Scope *newScope(Scope *sc);\n     bool isBaseOf2(ClassDeclaration *cd);\n \n@@ -318,9 +303,11 @@ class ClassDeclaration : public AggregateDeclaration\n     const char *kind() const;\n \n     void addLocalClass(ClassDeclarations *);\n+    void addObjcSymbols(ClassDeclarations *classes, ClassDeclarations *categories);\n \n     // Back end\n-    Symbol *vtblsym;\n+    Dsymbol *vtblsym;\n+    Dsymbol *vtblSymbol();\n \n     ClassDeclaration *isClassDeclaration() { return (ClassDeclaration *)this; }\n     void accept(Visitor *v) { v->visit(this); }\n@@ -329,11 +316,9 @@ class ClassDeclaration : public AggregateDeclaration\n class InterfaceDeclaration : public ClassDeclaration\n {\n public:\n-    InterfaceDeclaration(Loc loc, Identifier *id, BaseClasses *baseclasses);\n-    Dsymbol *syntaxCopy(Dsymbol *s);\n+    InterfaceDeclaration *syntaxCopy(Dsymbol *s);\n     Scope *newScope(Scope *sc);\n     bool isBaseOf(ClassDeclaration *cd, int *poffset);\n-    bool isBaseOf(BaseClass *bc, int *poffset);\n     const char *kind() const;\n     int vtblOffset() const;\n     bool isCPPinterface() const;"}, {"sha": "458416f495099bbc1931ccbd9c9a993c494cf12d", "filename": "gcc/d/dmd/aliasthis.c", "status": "removed", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Faliasthis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Faliasthis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faliasthis.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49", "patch": "@@ -1,94 +0,0 @@\n-\n-/* Compiler implementation of the D programming language\n- * Copyright (C) 2009-2021 by The D Language Foundation, All Rights Reserved\n- * written by Walter Bright\n- * http://www.digitalmars.com\n- * Distributed under the Boost Software License, Version 1.0.\n- * http://www.boost.org/LICENSE_1_0.txt\n- * https://github.com/D-Programming-Language/dmd/blob/master/src/aliasthis.c\n- */\n-\n-#include \"root/dsystem.h\"\n-\n-#include \"mars.h\"\n-#include \"identifier.h\"\n-#include \"aliasthis.h\"\n-#include \"scope.h\"\n-#include \"aggregate.h\"\n-#include \"dsymbol.h\"\n-#include \"mtype.h\"\n-#include \"declaration.h\"\n-#include \"expression.h\"\n-#include \"tokens.h\"\n-\n-Expression *resolveAliasThis(Scope *sc, Expression *e, bool gag)\n-{\n-    AggregateDeclaration *ad = isAggregate(e->type);\n-\n-    if (ad && ad->aliasthis)\n-    {\n-        unsigned olderrors = gag ? global.startGagging() : 0;\n-\n-        Loc loc = e->loc;\n-        Type *tthis = (e->op == TOKtype ? e->type : NULL);\n-        e = new DotIdExp(loc, e, ad->aliasthis->ident);\n-        e = expressionSemantic(e, sc);\n-        if (tthis && ad->aliasthis->needThis())\n-        {\n-            if (e->op == TOKvar)\n-            {\n-                if (FuncDeclaration *fd = ((VarExp *)e)->var->isFuncDeclaration())\n-                {\n-                    // Bugzilla 13009: Support better match for the overloaded alias this.\n-                    bool hasOverloads = false;\n-                    if (FuncDeclaration *f = fd->overloadModMatch(loc, tthis, hasOverloads))\n-                    {\n-                        if (!hasOverloads)\n-                            fd = f;     // use exact match\n-                        e = new VarExp(loc, fd, hasOverloads);\n-                        e->type = f->type;\n-                        e = new CallExp(loc, e);\n-                        goto L1;\n-                    }\n-                }\n-            }\n-            /* non-@property function is not called inside typeof(),\n-             * so resolve it ahead.\n-             */\n-            {\n-            int save = sc->intypeof;\n-            sc->intypeof = 1;   // bypass \"need this\" error check\n-            e = resolveProperties(sc, e);\n-            sc->intypeof = save;\n-            }\n-\n-        L1:\n-            e = new TypeExp(loc, new TypeTypeof(loc, e));\n-            e = expressionSemantic(e, sc);\n-        }\n-        e = resolveProperties(sc, e);\n-\n-        if (gag && global.endGagging(olderrors))\n-            e = NULL;\n-    }\n-\n-    return e;\n-}\n-\n-AliasThis::AliasThis(Loc loc, Identifier *ident)\n-    : Dsymbol(NULL)             // it's anonymous (no identifier)\n-{\n-    this->loc = loc;\n-    this->ident = ident;\n-}\n-\n-Dsymbol *AliasThis::syntaxCopy(Dsymbol *s)\n-{\n-    assert(!s);\n-    return new AliasThis(loc, ident);\n-}\n-\n-const char *AliasThis::kind() const\n-{\n-    return \"alias this\";\n-}"}, {"sha": "81e0d7e64bead010f8505543d26c12046510cd86", "filename": "gcc/d/dmd/aliasthis.d", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Faliasthis.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Faliasthis.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faliasthis.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -0,0 +1,202 @@\n+/**\n+ * Implements the `alias this` symbol.\n+ *\n+ * Specification: $(LINK2 https://dlang.org/spec/class.html#alias-this, Alias This)\n+ *\n+ * Copyright:   Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n+ * Authors:     $(LINK2 http://www.digitalmars.com, Walter Bright)\n+ * License:     $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+ * Source:      $(LINK2 https://github.com/dlang/dmd/blob/master/src/dmd/aliasthis.d, _aliasthis.d)\n+ * Documentation:  https://dlang.org/phobos/dmd_aliasthis.html\n+ * Coverage:    https://codecov.io/gh/dlang/dmd/src/master/src/dmd/aliasthis.d\n+ */\n+\n+module dmd.aliasthis;\n+\n+import core.stdc.stdio;\n+import dmd.aggregate;\n+import dmd.dscope;\n+import dmd.dsymbol;\n+import dmd.expression;\n+import dmd.expressionsem;\n+import dmd.globals;\n+import dmd.identifier;\n+import dmd.mtype;\n+import dmd.opover;\n+import dmd.tokens;\n+import dmd.visitor;\n+\n+/***********************************************************\n+ * alias ident this;\n+ */\n+extern (C++) final class AliasThis : Dsymbol\n+{\n+    Identifier ident;\n+    /// The symbol this `alias this` resolves to\n+    Dsymbol sym;\n+    /// Whether this `alias this` is deprecated or not\n+    bool isDeprecated_;\n+\n+    extern (D) this(const ref Loc loc, Identifier ident)\n+    {\n+        super(loc, null);    // it's anonymous (no identifier)\n+        this.ident = ident;\n+    }\n+\n+    override AliasThis syntaxCopy(Dsymbol s)\n+    {\n+        assert(!s);\n+        auto at = new AliasThis(loc, ident);\n+        at.comment = comment;\n+        return at;\n+    }\n+\n+    override const(char)* kind() const\n+    {\n+        return \"alias this\";\n+    }\n+\n+    AliasThis isAliasThis()\n+    {\n+        return this;\n+    }\n+\n+    override void accept(Visitor v)\n+    {\n+        v.visit(this);\n+    }\n+\n+    override bool isDeprecated() const\n+    {\n+        return this.isDeprecated_;\n+    }\n+}\n+\n+Expression resolveAliasThis(Scope* sc, Expression e, bool gag = false)\n+{\n+    for (AggregateDeclaration ad = isAggregate(e.type); ad;)\n+    {\n+        if (ad.aliasthis)\n+        {\n+            uint olderrors = gag ? global.startGagging() : 0;\n+            Loc loc = e.loc;\n+            Type tthis = (e.op == TOK.type ? e.type : null);\n+            e = new DotIdExp(loc, e, ad.aliasthis.ident);\n+            e = e.expressionSemantic(sc);\n+            if (tthis && ad.aliasthis.sym.needThis())\n+            {\n+                if (e.op == TOK.variable)\n+                {\n+                    if (auto fd = (cast(VarExp)e).var.isFuncDeclaration())\n+                    {\n+                        // https://issues.dlang.org/show_bug.cgi?id=13009\n+                        // Support better match for the overloaded alias this.\n+                        bool hasOverloads;\n+                        if (auto f = fd.overloadModMatch(loc, tthis, hasOverloads))\n+                        {\n+                            if (!hasOverloads)\n+                                fd = f;     // use exact match\n+                            e = new VarExp(loc, fd, hasOverloads);\n+                            e.type = f.type;\n+                            e = new CallExp(loc, e);\n+                            goto L1;\n+                        }\n+                    }\n+                }\n+                /* non-@property function is not called inside typeof(),\n+                 * so resolve it ahead.\n+                 */\n+                {\n+                    int save = sc.intypeof;\n+                    sc.intypeof = 1; // bypass \"need this\" error check\n+                    e = resolveProperties(sc, e);\n+                    sc.intypeof = save;\n+                }\n+            L1:\n+                e = new TypeExp(loc, new TypeTypeof(loc, e));\n+                e = e.expressionSemantic(sc);\n+            }\n+            e = resolveProperties(sc, e);\n+            if (!gag)\n+                ad.aliasthis.checkDeprecatedAliasThis(loc, sc);\n+            else if (global.endGagging(olderrors))\n+                e = null;\n+        }\n+\n+        import dmd.dclass : ClassDeclaration;\n+        auto cd = ad.isClassDeclaration();\n+        if ((!e || !ad.aliasthis) && cd && cd.baseClass && cd.baseClass != ClassDeclaration.object)\n+        {\n+            ad = cd.baseClass;\n+            continue;\n+        }\n+        break;\n+    }\n+    return e;\n+}\n+\n+/**\n+ * Check if an `alias this` is deprecated\n+ *\n+ * Usually one would use `expression.checkDeprecated(scope, aliasthis)` to\n+ * check if `expression` uses a deprecated `aliasthis`, but this calls\n+ * `toPrettyChars` which lead to the following message:\n+ * \"Deprecation: alias this `fullyqualified.aggregate.__anonymous` is deprecated\"\n+ *\n+ * Params:\n+ *   at  = The `AliasThis` object to check\n+ *   loc = `Loc` of the expression triggering the access to `at`\n+ *   sc  = `Scope` of the expression\n+ *         (deprecations do not trigger in deprecated scopes)\n+ *\n+ * Returns:\n+ *   Whether the alias this was reported as deprecated.\n+ */\n+bool checkDeprecatedAliasThis(AliasThis at, const ref Loc loc, Scope* sc)\n+{\n+    import dmd.errors : deprecation, Classification;\n+    import dmd.dsymbolsem : getMessage;\n+\n+    if (global.params.useDeprecated != DiagnosticReporting.off\n+        && at.isDeprecated() && !sc.isDeprecated())\n+    {\n+        const(char)* message = null;\n+        for (Dsymbol p = at; p; p = p.parent)\n+        {\n+            message = p.depdecl ? p.depdecl.getMessage() : null;\n+            if (message)\n+                break;\n+        }\n+        if (message)\n+            deprecation(loc, \"`alias %s this` is deprecated - %s\",\n+                        at.sym.toChars(), message);\n+        else\n+            deprecation(loc, \"`alias %s this` is deprecated\",\n+                        at.sym.toChars());\n+\n+        if (auto ti = sc.parent ? sc.parent.isInstantiated() : null)\n+            ti.printInstantiationTrace(Classification.deprecation);\n+\n+        return true;\n+    }\n+    return false;\n+}\n+\n+/**************************************\n+ * Check and set 'att' if 't' is a recursive 'alias this' type\n+ * Params:\n+ *   att = type reference used to detect recursion\n+ *   t   = 'alias this' type\n+ *\n+ * Returns:\n+ *   Whether the 'alias this' is recursive or not\n+ */\n+bool isRecursiveAliasThis(ref Type att, Type t)\n+{\n+    auto tb = t.toBasetype();\n+    if (att && tb.equivalent(att))\n+        return true;\n+    else if (!att && tb.checkAliasThisRec())\n+        att = tb;\n+    return false;\n+}"}, {"sha": "de93a8e6ae42a4788c8ab9b0c6d75f55c9ee520c", "filename": "gcc/d/dmd/aliasthis.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Faliasthis.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Faliasthis.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faliasthis.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -5,11 +5,12 @@\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n  * http://www.boost.org/LICENSE_1_0.txt\n- * https://github.com/dlang/dmd/blob/master/src/aliasthis.h\n+ * https://github.com/dlang/dmd/blob/master/src/dmd/aliasthis.h\n  */\n \n #pragma once\n \n+#include \"globals.h\"\n #include \"dsymbol.h\"\n \n /**************************************************************/\n@@ -19,11 +20,12 @@ class AliasThis : public Dsymbol\n public:\n    // alias Identifier this;\n     Identifier *ident;\n+    Dsymbol    *sym;\n+    bool       isDeprecated_;\n \n-    AliasThis(Loc loc, Identifier *ident);\n-\n-    Dsymbol *syntaxCopy(Dsymbol *);\n+    AliasThis *syntaxCopy(Dsymbol *);\n     const char *kind() const;\n     AliasThis *isAliasThis() { return this; }\n     void accept(Visitor *v) { v->visit(this); }\n+    bool isDeprecated() const { return this->isDeprecated_; }\n };"}, {"sha": "8a727ae66d144177e7525b12ee159815837f7df3", "filename": "gcc/d/dmd/apply.c", "status": "removed", "additions": 0, "deletions": 149, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fapply.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fapply.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fapply.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49", "patch": "@@ -1,149 +0,0 @@\n-\n-/* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n- * written by Walter Bright\n- * http://www.digitalmars.com\n- * Distributed under the Boost Software License, Version 1.0.\n- * http://www.boost.org/LICENSE_1_0.txt\n- * https://github.com/D-Programming-Language/dmd/blob/master/src/apply.c\n- */\n-\n-#include \"root/dsystem.h\"\n-\n-#include \"mars.h\"\n-#include \"expression.h\"\n-#include \"template.h\"\n-#include \"visitor.h\"\n-\n-\n-/**************************************\n- * An Expression tree walker that will visit each Expression e in the tree,\n- * in depth-first evaluation order, and call fp(e,param) on it.\n- * fp() signals whether the walking continues with its return value:\n- * Returns:\n- *      0       continue\n- *      1       done\n- * It's a bit slower than using virtual functions, but more encapsulated and less brittle.\n- * Creating an iterator for this would be much more complex.\n- */\n-\n-class PostorderExpressionVisitor : public StoppableVisitor\n-{\n-public:\n-    StoppableVisitor *v;\n-    PostorderExpressionVisitor(StoppableVisitor *v) : v(v) {}\n-\n-    bool doCond(Expression *e)\n-    {\n-        if (!stop && e)\n-            e->accept(this);\n-        return stop;\n-    }\n-    bool doCond(Expressions *e)\n-    {\n-        if (!e)\n-            return false;\n-        for (size_t i = 0; i < e->length && !stop; i++)\n-            doCond((*e)[i]);\n-        return stop;\n-    }\n-    bool applyTo(Expression *e)\n-    {\n-        e->accept(v);\n-        stop = v->stop;\n-        return true;\n-    }\n-\n-    void visit(Expression *e)\n-    {\n-        applyTo(e);\n-    }\n-\n-    void visit(NewExp *e)\n-    {\n-        //printf(\"NewExp::apply(): %s\\n\", toChars());\n-\n-        doCond(e->thisexp) || doCond(e->newargs) || doCond(e->arguments) || applyTo(e);\n-    }\n-\n-    void visit(NewAnonClassExp *e)\n-    {\n-        //printf(\"NewAnonClassExp::apply(): %s\\n\", toChars());\n-\n-        doCond(e->thisexp) || doCond(e->newargs) || doCond(e->arguments) || applyTo(e);\n-    }\n-\n-    void visit(TypeidExp *e)\n-    {\n-        doCond(isExpression(e->obj)) || applyTo(e);\n-    }\n-\n-    void visit(UnaExp *e)\n-    {\n-        doCond(e->e1) || applyTo(e);\n-    }\n-\n-    void visit(BinExp *e)\n-    {\n-        doCond(e->e1) || doCond(e->e2) || applyTo(e);\n-    }\n-\n-    void visit(AssertExp *e)\n-    {\n-        //printf(\"CallExp::apply(apply_fp_t fp, void *param): %s\\n\", toChars());\n-        doCond(e->e1) || doCond(e->msg) || applyTo(e);\n-    }\n-\n-    void visit(CallExp *e)\n-    {\n-        //printf(\"CallExp::apply(apply_fp_t fp, void *param): %s\\n\", toChars());\n-        doCond(e->e1) || doCond(e->arguments) || applyTo(e);\n-    }\n-\n-    void visit(ArrayExp *e)\n-    {\n-        //printf(\"ArrayExp::apply(apply_fp_t fp, void *param): %s\\n\", toChars());\n-        doCond(e->e1) || doCond(e->arguments) || applyTo(e);\n-    }\n-\n-    void visit(SliceExp *e)\n-    {\n-        doCond(e->e1) || doCond(e->lwr) || doCond(e->upr) || applyTo(e);\n-    }\n-\n-    void visit(ArrayLiteralExp *e)\n-    {\n-        doCond(e->basis) || doCond(e->elements) || applyTo(e);\n-    }\n-\n-    void visit(AssocArrayLiteralExp *e)\n-    {\n-        doCond(e->keys) || doCond(e->values) || applyTo(e);\n-    }\n-\n-    void visit(StructLiteralExp *e)\n-    {\n-        if (e->stageflags & stageApply) return;\n-        int old = e->stageflags;\n-        e->stageflags |= stageApply;\n-        doCond(e->elements) || applyTo(e);\n-        e->stageflags = old;\n-    }\n-\n-    void visit(TupleExp *e)\n-    {\n-        doCond(e->e0) || doCond(e->exps) || applyTo(e);\n-    }\n-\n-    void visit(CondExp *e)\n-    {\n-        doCond(e->econd) || doCond(e->e1) || doCond(e->e2) || applyTo(e);\n-    }\n-};\n-\n-bool walkPostorder(Expression *e, StoppableVisitor *v)\n-{\n-    PostorderExpressionVisitor pv(v);\n-    e->accept(&pv);\n-    return v->stop;\n-}"}, {"sha": "ab427e885dc76d537d6cdfd0c98de4102273347b", "filename": "gcc/d/dmd/apply.d", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fapply.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fapply.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fapply.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -0,0 +1,189 @@\n+/**\n+ * A depth-first visitor for expressions.\n+ *\n+ * Copyright:   Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n+ * Authors:     $(LINK2 http://www.digitalmars.com, Walter Bright)\n+ * License:     $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+ * Source:      $(LINK2 https://github.com/dlang/dmd/blob/master/src/dmd/apply.d, _apply.d)\n+ * Documentation:  https://dlang.org/phobos/dmd_apply.html\n+ * Coverage:    https://codecov.io/gh/dlang/dmd/src/master/src/dmd/apply.d\n+ */\n+\n+module dmd.apply;\n+\n+import dmd.arraytypes;\n+import dmd.dsymbol;\n+import dmd.dsymbolsem;\n+import dmd.dtemplate;\n+import dmd.expression;\n+import dmd.visitor;\n+\n+bool walkPostorder(Expression e, StoppableVisitor v)\n+{\n+    scope PostorderExpressionVisitor pv = new PostorderExpressionVisitor(v);\n+    e.accept(pv);\n+    return v.stop;\n+}\n+\n+/*********************************\n+ * Iterate this dsymbol or members of this scoped dsymbol, then\n+ * call `fp` with the found symbol and `params`.\n+ * Params:\n+ *  symbol = the dsymbol or parent of members to call fp on\n+ *  fp = function pointer to process the iterated symbol.\n+ *       If it returns nonzero, the iteration will be aborted.\n+ *  params = any parameters passed to fp.\n+ * Returns:\n+ *  nonzero if the iteration is aborted by the return value of fp,\n+ *  or 0 if it's completed.\n+ */\n+int apply(FP, Params...)(Dsymbol symbol, FP fp, Params params)\n+{\n+    if (auto nd = symbol.isNspace())\n+    {\n+        return nd.members.foreachDsymbol( (s) { return s && s.apply(fp, params); } );\n+    }\n+    if (auto ad = symbol.isAttribDeclaration())\n+    {\n+        return ad.include(ad._scope).foreachDsymbol( (s) { return s && s.apply(fp, params); } );\n+    }\n+    if (auto tm = symbol.isTemplateMixin())\n+    {\n+        if (tm._scope) // if fwd reference\n+            dsymbolSemantic(tm, null); // try to resolve it\n+\n+        return tm.members.foreachDsymbol( (s) { return s && s.apply(fp, params); } );\n+    }\n+\n+    return fp(symbol, params);\n+}\n+\n+/**************************************\n+ * An Expression tree walker that will visit each Expression e in the tree,\n+ * in depth-first evaluation order, and call fp(e,param) on it.\n+ * fp() signals whether the walking continues with its return value:\n+ * Returns:\n+ *      0       continue\n+ *      1       done\n+ * It's a bit slower than using virtual functions, but more encapsulated and less brittle.\n+ * Creating an iterator for this would be much more complex.\n+ */\n+private extern (C++) final class PostorderExpressionVisitor : StoppableVisitor\n+{\n+    alias visit = typeof(super).visit;\n+public:\n+    StoppableVisitor v;\n+\n+    extern (D) this(StoppableVisitor v)\n+    {\n+        this.v = v;\n+    }\n+\n+    bool doCond(Expression e)\n+    {\n+        if (!stop && e)\n+            e.accept(this);\n+        return stop;\n+    }\n+\n+    bool doCond(Expressions* e)\n+    {\n+        if (!e)\n+            return false;\n+        for (size_t i = 0; i < e.dim && !stop; i++)\n+            doCond((*e)[i]);\n+        return stop;\n+    }\n+\n+    bool applyTo(Expression e)\n+    {\n+        e.accept(v);\n+        stop = v.stop;\n+        return true;\n+    }\n+\n+    override void visit(Expression e)\n+    {\n+        applyTo(e);\n+    }\n+\n+    override void visit(NewExp e)\n+    {\n+        //printf(\"NewExp::apply(): %s\\n\", toChars());\n+        doCond(e.thisexp) || doCond(e.newargs) || doCond(e.arguments) || applyTo(e);\n+    }\n+\n+    override void visit(NewAnonClassExp e)\n+    {\n+        //printf(\"NewAnonClassExp::apply(): %s\\n\", toChars());\n+        doCond(e.thisexp) || doCond(e.newargs) || doCond(e.arguments) || applyTo(e);\n+    }\n+\n+    override void visit(TypeidExp e)\n+    {\n+        doCond(isExpression(e.obj)) || applyTo(e);\n+    }\n+\n+    override void visit(UnaExp e)\n+    {\n+        doCond(e.e1) || applyTo(e);\n+    }\n+\n+    override void visit(BinExp e)\n+    {\n+        doCond(e.e1) || doCond(e.e2) || applyTo(e);\n+    }\n+\n+    override void visit(AssertExp e)\n+    {\n+        //printf(\"CallExp::apply(apply_fp_t fp, void *param): %s\\n\", toChars());\n+        doCond(e.e1) || doCond(e.msg) || applyTo(e);\n+    }\n+\n+    override void visit(CallExp e)\n+    {\n+        //printf(\"CallExp::apply(apply_fp_t fp, void *param): %s\\n\", toChars());\n+        doCond(e.e1) || doCond(e.arguments) || applyTo(e);\n+    }\n+\n+    override void visit(ArrayExp e)\n+    {\n+        //printf(\"ArrayExp::apply(apply_fp_t fp, void *param): %s\\n\", toChars());\n+        doCond(e.e1) || doCond(e.arguments) || applyTo(e);\n+    }\n+\n+    override void visit(SliceExp e)\n+    {\n+        doCond(e.e1) || doCond(e.lwr) || doCond(e.upr) || applyTo(e);\n+    }\n+\n+    override void visit(ArrayLiteralExp e)\n+    {\n+        doCond(e.basis) || doCond(e.elements) || applyTo(e);\n+    }\n+\n+    override void visit(AssocArrayLiteralExp e)\n+    {\n+        doCond(e.keys) || doCond(e.values) || applyTo(e);\n+    }\n+\n+    override void visit(StructLiteralExp e)\n+    {\n+        if (e.stageflags & stageApply)\n+            return;\n+        int old = e.stageflags;\n+        e.stageflags |= stageApply;\n+        doCond(e.elements) || applyTo(e);\n+        e.stageflags = old;\n+    }\n+\n+    override void visit(TupleExp e)\n+    {\n+        doCond(e.e0) || doCond(e.exps) || applyTo(e);\n+    }\n+\n+    override void visit(CondExp e)\n+    {\n+        doCond(e.econd) || doCond(e.e1) || doCond(e.e2) || applyTo(e);\n+    }\n+}"}, {"sha": "52d596bb87191598f3f3a5c2899be736e92693a6", "filename": "gcc/d/dmd/arrayop.c", "status": "removed", "additions": 0, "deletions": 634, "changes": 634, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Farrayop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Farrayop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Farrayop.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49", "patch": "@@ -1,634 +0,0 @@\n-\n-/* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n- * written by Walter Bright\n- * http://www.digitalmars.com\n- * Distributed under the Boost Software License, Version 1.0.\n- * http://www.boost.org/LICENSE_1_0.txt\n- * https://github.com/D-Programming-Language/dmd/blob/master/src/arrayop.c\n- */\n-\n-#include \"root/dsystem.h\"\n-#include \"root/rmem.h\"\n-#include \"root/aav.h\"\n-\n-#include \"mars.h\"\n-#include \"expression.h\"\n-#include \"statement.h\"\n-#include \"mtype.h\"\n-#include \"declaration.h\"\n-#include \"scope.h\"\n-#include \"id.h\"\n-#include \"module.h\"\n-#include \"init.h\"\n-#include \"tokens.h\"\n-\n-void buildArrayIdent(Expression *e, OutBuffer *buf, Expressions *arguments);\n-Expression *buildArrayLoop(Expression *e, Parameters *fparams);\n-\n-/**************************************\n- * Hash table of array op functions already generated or known about.\n- */\n-\n-AA *arrayfuncs;\n-\n-/**************************************\n- * Structure to contain information needed to insert an array op call\n- */\n-\n-FuncDeclaration *buildArrayOp(Identifier *ident, BinExp *exp, Scope *sc)\n-{\n-    Parameters *fparams = new Parameters();\n-    Expression *loopbody = buildArrayLoop(exp, fparams);\n-\n-    /* Construct the function body:\n-     *  foreach (i; 0 .. p.length)    for (size_t i = 0; i < p.length; i++)\n-     *      loopbody;\n-     *  return p;\n-     */\n-\n-    Parameter *p = (*fparams)[0];\n-    // foreach (i; 0 .. p.length)\n-    Statement *s1 = new ForeachRangeStatement(Loc(), TOKforeach,\n-        new Parameter(0, NULL, Id::p, NULL, NULL),\n-        new IntegerExp(Loc(), 0, Type::tsize_t),\n-        new ArrayLengthExp(Loc(), new IdentifierExp(Loc(), p->ident)),\n-        new ExpStatement(Loc(), loopbody),\n-        Loc());\n-    //printf(\"%s\\n\", s1->toChars());\n-    Statement *s2 = new ReturnStatement(Loc(), new IdentifierExp(Loc(), p->ident));\n-    //printf(\"s2: %s\\n\", s2->toChars());\n-    Statement *fbody = new CompoundStatement(Loc(), s1, s2);\n-\n-    // Built-in array ops should be @trusted, pure, nothrow and nogc\n-    StorageClass stc = STCtrusted | STCpure | STCnothrow | STCnogc;\n-\n-    /* Construct the function\n-     */\n-    TypeFunction *ftype = new TypeFunction(ParameterList(fparams), exp->e1->type, LINKc, stc);\n-    //printf(\"fd: %s %s\\n\", ident->toChars(), ftype->toChars());\n-    FuncDeclaration *fd = new FuncDeclaration(Loc(), Loc(), ident, STCundefined, ftype);\n-    fd->fbody = fbody;\n-    fd->protection = Prot(Prot::public_);\n-    fd->linkage = LINKc;\n-    fd->isArrayOp = 1;\n-\n-    sc->_module->importedFrom->members->push(fd);\n-\n-    sc = sc->push();\n-    sc->parent = sc->_module->importedFrom;\n-    sc->stc = 0;\n-    sc->linkage = LINKc;\n-    dsymbolSemantic(fd, sc);\n-    semantic2(fd, sc);\n-    unsigned errors = global.startGagging();\n-    semantic3(fd, sc);\n-    if (global.endGagging(errors))\n-    {\n-        fd->type = Type::terror;\n-        fd->errors = true;\n-        fd->fbody = NULL;\n-    }\n-    sc->pop();\n-\n-    return fd;\n-}\n-\n-/**********************************************\n- * Check that there are no uses of arrays without [].\n- */\n-bool isArrayOpValid(Expression *e)\n-{\n-    if (e->op == TOKslice)\n-        return true;\n-    if (e->op == TOKarrayliteral)\n-    {\n-        Type *t = e->type->toBasetype();\n-        while (t->ty == Tarray || t->ty == Tsarray)\n-            t = t->nextOf()->toBasetype();\n-        return (t->ty != Tvoid);\n-    }\n-    Type *tb = e->type->toBasetype();\n-    if (tb->ty == Tarray || tb->ty == Tsarray)\n-    {\n-        if (isUnaArrayOp(e->op))\n-        {\n-             return isArrayOpValid(((UnaExp *)e)->e1);\n-        }\n-        if (isBinArrayOp(e->op) ||\n-            isBinAssignArrayOp(e->op) ||\n-            e->op == TOKassign)\n-        {\n-            BinExp *be = (BinExp *)e;\n-            return isArrayOpValid(be->e1) && isArrayOpValid(be->e2);\n-        }\n-        if (e->op == TOKconstruct)\n-        {\n-            BinExp *be = (BinExp *)e;\n-            return be->e1->op == TOKslice && isArrayOpValid(be->e2);\n-        }\n-        if (e->op == TOKcall)\n-        {\n-             return false; // TODO: Decide if [] is required after arrayop calls.\n-        }\n-        else\n-        {\n-            return false;\n-        }\n-    }\n-    return true;\n-}\n-\n-bool isNonAssignmentArrayOp(Expression *e)\n-{\n-    if (e->op == TOKslice)\n-        return isNonAssignmentArrayOp(((SliceExp *)e)->e1);\n-\n-    Type *tb = e->type->toBasetype();\n-    if (tb->ty == Tarray || tb->ty == Tsarray)\n-    {\n-        return (isUnaArrayOp(e->op) || isBinArrayOp(e->op));\n-    }\n-    return false;\n-}\n-\n-bool checkNonAssignmentArrayOp(Expression *e, bool suggestion)\n-{\n-    if (isNonAssignmentArrayOp(e))\n-    {\n-        const char *s = \"\";\n-        if (suggestion)\n-            s = \" (possible missing [])\";\n-        e->error(\"array operation %s without destination memory not allowed%s\", e->toChars(), s);\n-        return true;\n-    }\n-    return false;\n-}\n-\n-/***********************************\n- * Construct the array operation expression.\n- */\n-\n-Expression *arrayOp(BinExp *e, Scope *sc)\n-{\n-    //printf(\"BinExp::arrayOp() %s\\n\", toChars());\n-\n-    Type *tb = e->type->toBasetype();\n-    assert(tb->ty == Tarray || tb->ty == Tsarray);\n-    Type *tbn = tb->nextOf()->toBasetype();\n-    if (tbn->ty == Tvoid)\n-    {\n-        e->error(\"cannot perform array operations on void[] arrays\");\n-        return new ErrorExp();\n-    }\n-    if (!isArrayOpValid(e))\n-    {\n-        e->error(\"invalid array operation %s (possible missing [])\", e->toChars());\n-        return new ErrorExp();\n-    }\n-\n-    Expressions *arguments = new Expressions();\n-\n-    /* The expression to generate an array operation for is mangled\n-     * into a name to use as the array operation function name.\n-     * Mangle in the operands and operators in RPN order, and type.\n-     */\n-    OutBuffer buf;\n-    buf.writestring(\"_array\");\n-    buildArrayIdent(e, &buf, arguments);\n-    buf.writeByte('_');\n-\n-    /* Append deco of array element type\n-     */\n-    buf.writestring(e->type->toBasetype()->nextOf()->toBasetype()->mutableOf()->deco);\n-\n-    char *name = buf.peekChars();\n-    Identifier *ident = Identifier::idPool(name);\n-\n-    FuncDeclaration **pFd = (FuncDeclaration **)dmd_aaGet(&arrayfuncs, (void *)ident);\n-    FuncDeclaration *fd = *pFd;\n-\n-    if (!fd)\n-        fd = buildArrayOp(ident, e, sc);\n-\n-    if (fd && fd->errors)\n-    {\n-        const char *fmt;\n-        if (tbn->ty == Tstruct || tbn->ty == Tclass)\n-            fmt = \"invalid array operation '%s' because %s doesn't support necessary arithmetic operations\";\n-        else if (!tbn->isscalar())\n-            fmt = \"invalid array operation '%s' because %s is not a scalar type\";\n-        else\n-            fmt = \"invalid array operation '%s' for element type %s\";\n-\n-        e->error(fmt, e->toChars(), tbn->toChars());\n-        return new ErrorExp();\n-    }\n-\n-    *pFd = fd;\n-\n-    Expression *ev = new VarExp(e->loc, fd);\n-    Expression *ec = new CallExp(e->loc, ev, arguments);\n-\n-    return expressionSemantic(ec, sc);\n-}\n-\n-Expression *arrayOp(BinAssignExp *e, Scope *sc)\n-{\n-    //printf(\"BinAssignExp::arrayOp() %s\\n\", toChars());\n-\n-    /* Check that the elements of e1 can be assigned to\n-     */\n-    Type *tn = e->e1->type->toBasetype()->nextOf();\n-\n-    if (tn && (!tn->isMutable() || !tn->isAssignable()))\n-    {\n-        e->error(\"slice %s is not mutable\", e->e1->toChars());\n-        return new ErrorExp();\n-    }\n-    if (e->e1->op == TOKarrayliteral)\n-    {\n-        return e->e1->modifiableLvalue(sc, e->e1);\n-    }\n-\n-    return arrayOp((BinExp *)e, sc);\n-}\n-\n-/******************************************\n- * Construct the identifier for the array operation function,\n- * and build the argument list to pass to it.\n- */\n-\n-void buildArrayIdent(Expression *e, OutBuffer *buf, Expressions *arguments)\n-{\n-    class BuildArrayIdentVisitor : public Visitor\n-    {\n-        OutBuffer *buf;\n-        Expressions *arguments;\n-    public:\n-        BuildArrayIdentVisitor(OutBuffer *buf, Expressions *arguments)\n-            : buf(buf), arguments(arguments)\n-        {\n-        }\n-\n-        void visit(Expression *e)\n-        {\n-            buf->writestring(\"Exp\");\n-            arguments->shift(e);\n-        }\n-\n-        void visit(CastExp *e)\n-        {\n-            Type *tb = e->type->toBasetype();\n-            if (tb->ty == Tarray || tb->ty == Tsarray)\n-            {\n-                e->e1->accept(this);\n-            }\n-            else\n-                visit((Expression *)e);\n-        }\n-\n-        void visit(ArrayLiteralExp *e)\n-        {\n-            buf->writestring(\"Slice\");\n-            arguments->shift(e);\n-        }\n-\n-        void visit(SliceExp *e)\n-        {\n-            buf->writestring(\"Slice\");\n-            arguments->shift(e);\n-        }\n-\n-        void visit(AssignExp *e)\n-        {\n-            /* Evaluate assign expressions right to left\n-             */\n-            e->e2->accept(this);\n-            e->e1->accept(this);\n-            buf->writestring(\"Assign\");\n-        }\n-\n-        void visit(BinAssignExp *e)\n-        {\n-            /* Evaluate assign expressions right to left\n-             */\n-            e->e2->accept(this);\n-            e->e1->accept(this);\n-            const char *s;\n-            switch(e->op)\n-            {\n-            case TOKaddass: s = \"Addass\"; break;\n-            case TOKminass: s = \"Minass\"; break;\n-            case TOKmulass: s = \"Mulass\"; break;\n-            case TOKdivass: s = \"Divass\"; break;\n-            case TOKmodass: s = \"Modass\"; break;\n-            case TOKxorass: s = \"Xorass\"; break;\n-            case TOKandass: s = \"Andass\"; break;\n-            case TOKorass:  s = \"Orass\";  break;\n-            case TOKpowass: s = \"Powass\"; break;\n-            default: assert(0);\n-            }\n-            buf->writestring(s);\n-        }\n-\n-        void visit(NegExp *e)\n-        {\n-            e->e1->accept(this);\n-            buf->writestring(\"Neg\");\n-        }\n-\n-        void visit(ComExp *e)\n-        {\n-            e->e1->accept(this);\n-            buf->writestring(\"Com\");\n-        }\n-\n-        void visit(BinExp *e)\n-        {\n-            /* Evaluate assign expressions left to right\n-             */\n-            const char *s = NULL;\n-            switch(e->op)\n-            {\n-            case TOKadd: s = \"Add\"; break;\n-            case TOKmin: s = \"Min\"; break;\n-            case TOKmul: s = \"Mul\"; break;\n-            case TOKdiv: s = \"Div\"; break;\n-            case TOKmod: s = \"Mod\"; break;\n-            case TOKxor: s = \"Xor\"; break;\n-            case TOKand: s = \"And\"; break;\n-            case TOKor:  s = \"Or\";  break;\n-            case TOKpow: s = \"Pow\"; break;\n-            default: break;\n-            }\n-            if (s)\n-            {\n-                Type *tb = e->type->toBasetype();\n-                Type *t1 = e->e1->type->toBasetype();\n-                Type *t2 = e->e2->type->toBasetype();\n-                e->e1->accept(this);\n-                if (t1->ty == Tarray &&\n-                    ((t2->ty == Tarray && !t1->equivalent(tb)) ||\n-                     (t2->ty != Tarray && !t1->nextOf()->equivalent(e->e2->type))))\n-                {\n-                    // Bugzilla 12780: if A is narrower than B\n-                    //  A[] op B[]\n-                    //  A[] op B\n-                    buf->writestring(\"Of\");\n-                    buf->writestring(t1->nextOf()->mutableOf()->deco);\n-                }\n-                e->e2->accept(this);\n-                if (t2->ty == Tarray &&\n-                    ((t1->ty == Tarray && !t2->equivalent(tb)) ||\n-                     (t1->ty != Tarray && !t2->nextOf()->equivalent(e->e1->type))))\n-                {\n-                    // Bugzilla 12780: if B is narrower than A:\n-                    //  A[] op B[]\n-                    //  A op B[]\n-                    buf->writestring(\"Of\");\n-                    buf->writestring(t2->nextOf()->mutableOf()->deco);\n-                }\n-                buf->writestring(s);\n-            }\n-            else\n-                visit((Expression *)e);\n-        }\n-    };\n-\n-    BuildArrayIdentVisitor v(buf, arguments);\n-    e->accept(&v);\n-}\n-\n-/******************************************\n- * Construct the inner loop for the array operation function,\n- * and build the parameter list.\n- */\n-\n-Expression *buildArrayLoop(Expression *e, Parameters *fparams)\n-{\n-    class BuildArrayLoopVisitor : public Visitor\n-    {\n-        Parameters *fparams;\n-        Expression *result;\n-\n-    public:\n-        BuildArrayLoopVisitor(Parameters *fparams)\n-            : fparams(fparams), result(NULL)\n-        {\n-        }\n-\n-        void visit(Expression *e)\n-        {\n-            Identifier *id = Identifier::generateId(\"c\", fparams->length);\n-            Parameter *param = new Parameter(0, e->type, id, NULL, NULL);\n-            fparams->shift(param);\n-            result = new IdentifierExp(Loc(), id);\n-        }\n-\n-        void visit(CastExp *e)\n-        {\n-            Type *tb = e->type->toBasetype();\n-            if (tb->ty == Tarray || tb->ty == Tsarray)\n-            {\n-                e->e1->accept(this);\n-            }\n-            else\n-                visit((Expression *)e);\n-        }\n-\n-        void visit(ArrayLiteralExp *e)\n-        {\n-            Identifier *id = Identifier::generateId(\"p\", fparams->length);\n-            Parameter *param = new Parameter(STCconst, e->type, id, NULL, NULL);\n-            fparams->shift(param);\n-            Expression *ie = new IdentifierExp(Loc(), id);\n-            Expression *index = new IdentifierExp(Loc(), Id::p);\n-            result = new ArrayExp(Loc(), ie, index);\n-        }\n-\n-        void visit(SliceExp *e)\n-        {\n-            Identifier *id = Identifier::generateId(\"p\", fparams->length);\n-            Parameter *param = new Parameter(STCconst, e->type, id, NULL, NULL);\n-            fparams->shift(param);\n-            Expression *ie = new IdentifierExp(Loc(), id);\n-            Expression *index = new IdentifierExp(Loc(), Id::p);\n-            result = new ArrayExp(Loc(), ie, index);\n-        }\n-\n-        void visit(AssignExp *e)\n-        {\n-            /* Evaluate assign expressions right to left\n-             */\n-            Expression *ex2 = buildArrayLoop(e->e2);\n-            /* Need the cast because:\n-             *   b = c + p[i];\n-             * where b is a byte fails because (c + p[i]) is an int\n-             * which cannot be implicitly cast to byte.\n-             */\n-            ex2 = new CastExp(Loc(), ex2, e->e1->type->nextOf());\n-            Expression *ex1 = buildArrayLoop(e->e1);\n-            Parameter *param = (*fparams)[0];\n-            param->storageClass = 0;\n-            result = new AssignExp(Loc(), ex1, ex2);\n-        }\n-\n-        void visit(BinAssignExp *e)\n-        {\n-            /* Evaluate assign expressions right to left\n-             */\n-            Expression *ex2 = buildArrayLoop(e->e2);\n-            Expression *ex1 = buildArrayLoop(e->e1);\n-            Parameter *param = (*fparams)[0];\n-            param->storageClass = 0;\n-            switch(e->op)\n-            {\n-            case TOKaddass: result = new AddAssignExp(e->loc, ex1, ex2); return;\n-            case TOKminass: result = new MinAssignExp(e->loc, ex1, ex2); return;\n-            case TOKmulass: result = new MulAssignExp(e->loc, ex1, ex2); return;\n-            case TOKdivass: result = new DivAssignExp(e->loc, ex1, ex2); return;\n-            case TOKmodass: result = new ModAssignExp(e->loc, ex1, ex2); return;\n-            case TOKxorass: result = new XorAssignExp(e->loc, ex1, ex2); return;\n-            case TOKandass: result = new AndAssignExp(e->loc, ex1, ex2); return;\n-            case TOKorass:  result = new OrAssignExp(e->loc, ex1, ex2); return;\n-            case TOKpowass: result = new PowAssignExp(e->loc, ex1, ex2); return;\n-            default:\n-                assert(0);\n-            }\n-        }\n-\n-        void visit(NegExp *e)\n-        {\n-            Expression *ex1 = buildArrayLoop(e->e1);\n-            result = new NegExp(Loc(), ex1);\n-        }\n-\n-        void visit(ComExp *e)\n-        {\n-            Expression *ex1 = buildArrayLoop(e->e1);\n-            result = new ComExp(Loc(), ex1);\n-        }\n-\n-        void visit(BinExp *e)\n-        {\n-            if (isBinArrayOp(e->op))\n-            {\n-                /* Evaluate assign expressions left to right\n-                 */\n-                BinExp *be = (BinExp *)e->copy();\n-                be->e1 = buildArrayLoop(be->e1);\n-                be->e2 = buildArrayLoop(be->e2);\n-                be->type = NULL;\n-                result = be;\n-                return;\n-            }\n-            else\n-            {\n-                visit((Expression *)e);\n-                return;\n-            }\n-        }\n-\n-        Expression *buildArrayLoop(Expression *e)\n-        {\n-            e->accept(this);\n-            return result;\n-        }\n-    };\n-\n-    BuildArrayLoopVisitor v(fparams);\n-    return v.buildArrayLoop(e);\n-}\n-\n-/***********************************************\n- * Test if expression is a unary array op.\n- */\n-\n-bool isUnaArrayOp(TOK op)\n-{\n-    switch (op)\n-    {\n-    case TOKneg:\n-    case TOKtilde:\n-        return true;\n-    default:\n-        break;\n-    }\n-    return false;\n-}\n-\n-/***********************************************\n- * Test if expression is a binary array op.\n- */\n-\n-bool isBinArrayOp(TOK op)\n-{\n-    switch (op)\n-    {\n-    case TOKadd:\n-    case TOKmin:\n-    case TOKmul:\n-    case TOKdiv:\n-    case TOKmod:\n-    case TOKxor:\n-    case TOKand:\n-    case TOKor:\n-    case TOKpow:\n-        return true;\n-    default:\n-        break;\n-    }\n-    return false;\n-}\n-\n-/***********************************************\n- * Test if expression is a binary assignment array op.\n- */\n-\n-bool isBinAssignArrayOp(TOK op)\n-{\n-    switch (op)\n-    {\n-    case TOKaddass:\n-    case TOKminass:\n-    case TOKmulass:\n-    case TOKdivass:\n-    case TOKmodass:\n-    case TOKxorass:\n-    case TOKandass:\n-    case TOKorass:\n-    case TOKpowass:\n-        return true;\n-    default:\n-        break;\n-    }\n-    return false;\n-}\n-\n-/***********************************************\n- * Test if operand is a valid array op operand.\n- */\n-\n-bool isArrayOpOperand(Expression *e)\n-{\n-    //printf(\"Expression::isArrayOpOperand() %s\\n\", e->toChars());\n-    if (e->op == TOKslice)\n-        return true;\n-    if (e->op == TOKarrayliteral)\n-    {\n-        Type *t = e->type->toBasetype();\n-        while (t->ty == Tarray || t->ty == Tsarray)\n-            t = t->nextOf()->toBasetype();\n-        return (t->ty != Tvoid);\n-    }\n-    Type *tb = e->type->toBasetype();\n-    if (tb->ty == Tarray)\n-    {\n-        return (isUnaArrayOp(e->op) ||\n-                isBinArrayOp(e->op) ||\n-                isBinAssignArrayOp(e->op) ||\n-                e->op == TOKassign);\n-    }\n-    return false;\n-}"}, {"sha": "66be73ea21fee3149dc073385d0bcd96a106aae4", "filename": "gcc/d/dmd/arrayop.d", "status": "added", "additions": 387, "deletions": 0, "changes": 387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Farrayop.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Farrayop.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Farrayop.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -0,0 +1,387 @@\n+/**\n+ * Implement array operations, such as `a[] = b[] + c[]`.\n+ *\n+ * Specification: $(LINK2 https://dlang.org/spec/arrays.html#array-operations, Array Operations)\n+ *\n+ * Copyright:   Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n+ * Authors:     $(LINK2 http://www.digitalmars.com, Walter Bright)\n+ * License:     $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+ * Source:      $(LINK2 https://github.com/dlang/dmd/blob/master/src/dmd/arrayop.d, _arrayop.d)\n+ * Documentation:  https://dlang.org/phobos/dmd_arrayop.html\n+ * Coverage:    https://codecov.io/gh/dlang/dmd/src/master/src/dmd/arrayop.d\n+ */\n+\n+module dmd.arrayop;\n+\n+import core.stdc.stdio;\n+import dmd.arraytypes;\n+import dmd.astenums;\n+import dmd.declaration;\n+import dmd.dscope;\n+import dmd.dsymbol;\n+import dmd.expression;\n+import dmd.expressionsem;\n+import dmd.func;\n+import dmd.globals;\n+import dmd.id;\n+import dmd.identifier;\n+import dmd.mtype;\n+import dmd.root.outbuffer;\n+import dmd.statement;\n+import dmd.tokens;\n+import dmd.visitor;\n+\n+/**********************************************\n+ * Check that there are no uses of arrays without [].\n+ */\n+bool isArrayOpValid(Expression e)\n+{\n+    //printf(\"isArrayOpValid() %s\\n\", e.toChars());\n+    if (e.op == TOK.slice)\n+        return true;\n+    if (e.op == TOK.arrayLiteral)\n+    {\n+        Type t = e.type.toBasetype();\n+        while (t.ty == Tarray || t.ty == Tsarray)\n+            t = t.nextOf().toBasetype();\n+        return (t.ty != Tvoid);\n+    }\n+    Type tb = e.type.toBasetype();\n+    if (tb.ty == Tarray || tb.ty == Tsarray)\n+    {\n+        if (isUnaArrayOp(e.op))\n+        {\n+            return isArrayOpValid((cast(UnaExp)e).e1);\n+        }\n+        if (isBinArrayOp(e.op) || isBinAssignArrayOp(e.op) || e.op == TOK.assign)\n+        {\n+            BinExp be = cast(BinExp)e;\n+            return isArrayOpValid(be.e1) && isArrayOpValid(be.e2);\n+        }\n+        if (e.op == TOK.construct)\n+        {\n+            BinExp be = cast(BinExp)e;\n+            return be.e1.op == TOK.slice && isArrayOpValid(be.e2);\n+        }\n+        // if (e.op == TOK.call)\n+        // {\n+        // TODO: Decide if [] is required after arrayop calls.\n+        // }\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool isNonAssignmentArrayOp(Expression e)\n+{\n+    if (e.op == TOK.slice)\n+        return isNonAssignmentArrayOp((cast(SliceExp)e).e1);\n+\n+    Type tb = e.type.toBasetype();\n+    if (tb.ty == Tarray || tb.ty == Tsarray)\n+    {\n+        return (isUnaArrayOp(e.op) || isBinArrayOp(e.op));\n+    }\n+    return false;\n+}\n+\n+bool checkNonAssignmentArrayOp(Expression e, bool suggestion = false)\n+{\n+    if (isNonAssignmentArrayOp(e))\n+    {\n+        const(char)* s = \"\";\n+        if (suggestion)\n+            s = \" (possible missing [])\";\n+        e.error(\"array operation `%s` without destination memory not allowed%s\", e.toChars(), s);\n+        return true;\n+    }\n+    return false;\n+}\n+\n+/***********************************\n+ * Construct the array operation expression, call object._arrayOp!(tiargs)(args).\n+ *\n+ * Encode operand types and operations into tiargs using reverse polish notation (RPN) to preserve precedence.\n+ * Unary operations are prefixed with \"u\" (e.g. \"u~\").\n+ * Pass operand values (slices or scalars) as args.\n+ *\n+ * Scalar expression sub-trees of `e` are evaluated before calling\n+ * into druntime to hoist them out of the loop. This is a valid\n+ * evaluation order as the actual array operations have no\n+ * side-effect.\n+ * References:\n+ * https://github.com/dlang/druntime/blob/master/src/object.d#L3944\n+ * https://github.com/dlang/druntime/blob/master/src/core/internal/array/operations.d\n+ */\n+Expression arrayOp(BinExp e, Scope* sc)\n+{\n+    //printf(\"BinExp.arrayOp() %s\\n\", e.toChars());\n+    Type tb = e.type.toBasetype();\n+    assert(tb.ty == Tarray || tb.ty == Tsarray);\n+    Type tbn = tb.nextOf().toBasetype();\n+    if (tbn.ty == Tvoid)\n+    {\n+        e.error(\"cannot perform array operations on `void[]` arrays\");\n+        return ErrorExp.get();\n+    }\n+    if (!isArrayOpValid(e))\n+        return arrayOpInvalidError(e);\n+\n+    auto tiargs = new Objects();\n+    auto args = new Expressions();\n+    buildArrayOp(sc, e, tiargs, args);\n+\n+    import dmd.dtemplate : TemplateDeclaration;\n+    __gshared TemplateDeclaration arrayOp;\n+    if (arrayOp is null)\n+    {\n+        // Create .object._arrayOp\n+        Identifier idArrayOp = Identifier.idPool(\"_arrayOp\");\n+        Expression id = new IdentifierExp(e.loc, Id.empty);\n+        id = new DotIdExp(e.loc, id, Id.object);\n+        id = new DotIdExp(e.loc, id, idArrayOp);\n+\n+        id = id.expressionSemantic(sc);\n+        if (auto te = id.isTemplateExp())\n+            arrayOp = te.td;\n+        else\n+            ObjectNotFound(idArrayOp);   // fatal error\n+    }\n+\n+    auto fd = resolveFuncCall(e.loc, sc, arrayOp, tiargs, null, args, FuncResolveFlag.standard);\n+    if (!fd || fd.errors)\n+        return ErrorExp.get();\n+    return new CallExp(e.loc, new VarExp(e.loc, fd, false), args).expressionSemantic(sc);\n+}\n+\n+/// ditto\n+Expression arrayOp(BinAssignExp e, Scope* sc)\n+{\n+    //printf(\"BinAssignExp.arrayOp() %s\\n\", toChars());\n+\n+    /* Check that the elements of e1 can be assigned to\n+     */\n+    Type tn = e.e1.type.toBasetype().nextOf();\n+\n+    if (tn && (!tn.isMutable() || !tn.isAssignable()))\n+    {\n+        e.error(\"slice `%s` is not mutable\", e.e1.toChars());\n+        if (e.op == TOK.addAssign)\n+            checkPossibleAddCatError!(AddAssignExp, CatAssignExp)(e.isAddAssignExp);\n+        return ErrorExp.get();\n+    }\n+    if (e.e1.op == TOK.arrayLiteral)\n+    {\n+        return e.e1.modifiableLvalue(sc, e.e1);\n+    }\n+\n+    return arrayOp(cast(BinExp)e, sc);\n+}\n+\n+/******************************************\n+ * Convert the expression tree e to template and function arguments,\n+ * using reverse polish notation (RPN) to encode order of operations.\n+ * Encode operations as string arguments, using a \"u\" prefix for unary operations.\n+ */\n+private void buildArrayOp(Scope* sc, Expression e, Objects* tiargs, Expressions* args)\n+{\n+    extern (C++) final class BuildArrayOpVisitor : Visitor\n+    {\n+        alias visit = Visitor.visit;\n+        Scope* sc;\n+        Objects* tiargs;\n+        Expressions* args;\n+\n+    public:\n+        extern (D) this(Scope* sc, Objects* tiargs, Expressions* args)\n+        {\n+            this.sc = sc;\n+            this.tiargs = tiargs;\n+            this.args = args;\n+        }\n+\n+        override void visit(Expression e)\n+        {\n+            tiargs.push(e.type);\n+            args.push(e);\n+        }\n+\n+        override void visit(SliceExp e)\n+        {\n+            visit(cast(Expression) e);\n+        }\n+\n+        override void visit(CastExp e)\n+        {\n+            visit(cast(Expression) e);\n+        }\n+\n+        override void visit(UnaExp e)\n+        {\n+            Type tb = e.type.toBasetype();\n+            if (tb.ty != Tarray && tb.ty != Tsarray) // hoist scalar expressions\n+            {\n+                visit(cast(Expression) e);\n+            }\n+            else\n+            {\n+                // RPN, prefix unary ops with u\n+                OutBuffer buf;\n+                buf.writestring(\"u\");\n+                buf.writestring(Token.toString(e.op));\n+                e.e1.accept(this);\n+                tiargs.push(new StringExp(Loc.initial, buf.extractSlice()).expressionSemantic(sc));\n+            }\n+        }\n+\n+        override void visit(BinExp e)\n+        {\n+            Type tb = e.type.toBasetype();\n+            if (tb.ty != Tarray && tb.ty != Tsarray) // hoist scalar expressions\n+            {\n+                visit(cast(Expression) e);\n+            }\n+            else\n+            {\n+                // RPN\n+                e.e1.accept(this);\n+                e.e2.accept(this);\n+                tiargs.push(new StringExp(Loc.initial, Token.toString(e.op)).expressionSemantic(sc));\n+            }\n+        }\n+    }\n+\n+    scope v = new BuildArrayOpVisitor(sc, tiargs, args);\n+    e.accept(v);\n+}\n+\n+/***********************************************\n+ * Some implicit casting can be performed by the _arrayOp template.\n+ * Params:\n+ *      tfrom = type converting from\n+ *      tto   = type converting to\n+ * Returns:\n+ *      true if can be performed by _arrayOp\n+ */\n+bool isArrayOpImplicitCast(TypeDArray tfrom, TypeDArray tto)\n+{\n+    const tyf = tfrom.nextOf().toBasetype().ty;\n+    const tyt = tto  .nextOf().toBasetype().ty;\n+    return tyf == tyt ||\n+           tyf == Tint32 && tyt == Tfloat64;\n+}\n+\n+/***********************************************\n+ * Test if expression is a unary array op.\n+ */\n+bool isUnaArrayOp(TOK op)\n+{\n+    switch (op)\n+    {\n+    case TOK.negate:\n+    case TOK.tilde:\n+        return true;\n+    default:\n+        break;\n+    }\n+    return false;\n+}\n+\n+/***********************************************\n+ * Test if expression is a binary array op.\n+ */\n+bool isBinArrayOp(TOK op)\n+{\n+    switch (op)\n+    {\n+    case TOK.add:\n+    case TOK.min:\n+    case TOK.mul:\n+    case TOK.div:\n+    case TOK.mod:\n+    case TOK.xor:\n+    case TOK.and:\n+    case TOK.or:\n+    case TOK.pow:\n+        return true;\n+    default:\n+        break;\n+    }\n+    return false;\n+}\n+\n+/***********************************************\n+ * Test if expression is a binary assignment array op.\n+ */\n+bool isBinAssignArrayOp(TOK op)\n+{\n+    switch (op)\n+    {\n+    case TOK.addAssign:\n+    case TOK.minAssign:\n+    case TOK.mulAssign:\n+    case TOK.divAssign:\n+    case TOK.modAssign:\n+    case TOK.xorAssign:\n+    case TOK.andAssign:\n+    case TOK.orAssign:\n+    case TOK.powAssign:\n+        return true;\n+    default:\n+        break;\n+    }\n+    return false;\n+}\n+\n+/***********************************************\n+ * Test if operand is a valid array op operand.\n+ */\n+bool isArrayOpOperand(Expression e)\n+{\n+    //printf(\"Expression.isArrayOpOperand() %s\\n\", e.toChars());\n+    if (e.op == TOK.slice)\n+        return true;\n+    if (e.op == TOK.arrayLiteral)\n+    {\n+        Type t = e.type.toBasetype();\n+        while (t.ty == Tarray || t.ty == Tsarray)\n+            t = t.nextOf().toBasetype();\n+        return (t.ty != Tvoid);\n+    }\n+    Type tb = e.type.toBasetype();\n+    if (tb.ty == Tarray)\n+    {\n+        return (isUnaArrayOp(e.op) ||\n+                isBinArrayOp(e.op) ||\n+                isBinAssignArrayOp(e.op) ||\n+                e.op == TOK.assign);\n+    }\n+    return false;\n+}\n+\n+\n+/***************************************************\n+ * Print error message about invalid array operation.\n+ * Params:\n+ *      e = expression with the invalid array operation\n+ * Returns:\n+ *      instance of ErrorExp\n+ */\n+\n+ErrorExp arrayOpInvalidError(Expression e)\n+{\n+    e.error(\"invalid array operation `%s` (possible missing [])\", e.toChars());\n+    if (e.op == TOK.add)\n+        checkPossibleAddCatError!(AddExp, CatExp)(e.isAddExp());\n+    else if (e.op == TOK.addAssign)\n+        checkPossibleAddCatError!(AddAssignExp, CatAssignExp)(e.isAddAssignExp());\n+    return ErrorExp.get();\n+}\n+\n+private void checkPossibleAddCatError(AddT, CatT)(AddT ae)\n+{\n+    if (!ae.e2.type || ae.e2.type.ty != Tarray || !ae.e2.type.implicitConvTo(ae.e1.type))\n+        return;\n+    CatT ce = new CatT(ae.loc, ae.e1, ae.e2);\n+    ae.errorSupplemental(\"did you mean to concatenate (`%s`) instead ?\", ce.toChars());\n+}"}, {"sha": "b1f8d86a208caa6ae934ce3277c34dae51775234", "filename": "gcc/d/dmd/arraytypes.d", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Farraytypes.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Farraytypes.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Farraytypes.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -0,0 +1,57 @@\n+/**\n+ * Provide aliases for arrays of certain declarations or statements.\n+ *\n+ * Copyright:   Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n+ * Authors:     $(LINK2 http://www.digitalmars.com, Walter Bright)\n+ * License:     $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+ * Source:      $(LINK2 https://github.com/dlang/dmd/blob/master/src/dmd/arraytypes.d, _arraytypes.d)\n+ * Documentation:  https://dlang.org/phobos/dmd_arraytypes.html\n+ * Coverage:    https://codecov.io/gh/dlang/dmd/src/master/src/dmd/arraytypes.d\n+ */\n+\n+module dmd.arraytypes;\n+\n+import dmd.dclass;\n+import dmd.declaration;\n+import dmd.dmodule;\n+import dmd.dsymbol;\n+import dmd.dtemplate;\n+import dmd.expression;\n+import dmd.func;\n+import dmd.identifier;\n+import dmd.init;\n+import dmd.mtype;\n+import dmd.root.array;\n+import dmd.root.rootobject;\n+import dmd.statement;\n+\n+alias Strings = Array!(const(char)*);\n+alias Identifiers = Array!(Identifier);\n+alias TemplateParameters = Array!(TemplateParameter);\n+alias Expressions = Array!(Expression);\n+alias Statements = Array!(Statement);\n+alias BaseClasses = Array!(BaseClass*);\n+alias ClassDeclarations = Array!(ClassDeclaration);\n+alias Dsymbols = Array!(Dsymbol);\n+alias Objects = Array!(RootObject);\n+alias DtorDeclarations = Array!(DtorDeclaration);\n+alias FuncDeclarations = Array!(FuncDeclaration);\n+alias Parameters = Array!(Parameter);\n+alias Initializers = Array!(Initializer);\n+alias VarDeclarations = Array!(VarDeclaration);\n+alias Types = Array!(Type);\n+alias Catches = Array!(Catch);\n+alias StaticDtorDeclarations = Array!(StaticDtorDeclaration);\n+alias SharedStaticDtorDeclarations = Array!(SharedStaticDtorDeclaration);\n+alias AliasDeclarations = Array!(AliasDeclaration);\n+alias Modules = Array!(Module);\n+alias CaseStatements = Array!(CaseStatement);\n+alias ScopeStatements = Array!(ScopeStatement);\n+alias GotoCaseStatements = Array!(GotoCaseStatement);\n+alias ReturnStatements = Array!(ReturnStatement);\n+alias GotoStatements = Array!(GotoStatement);\n+alias TemplateInstances = Array!(TemplateInstance);\n+alias Ensures = Array!(Ensure);\n+alias Designators = Array!(Designator);\n+alias DesigInits = Array!(DesigInit);\n+"}, {"sha": "602d89059a04bb9db7e33a42e5a4f7ef166ff0ab", "filename": "gcc/d/dmd/arraytypes.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Farraytypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Farraytypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Farraytypes.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -27,6 +27,8 @@ typedef Array<class Dsymbol *> Dsymbols;\n \n typedef Array<class RootObject *> Objects;\n \n+typedef Array<class DtorDeclaration *> DtorDeclarations;\n+\n typedef Array<class FuncDeclaration *> FuncDeclarations;\n \n typedef Array<class Parameter *> Parameters;\n@@ -48,8 +50,6 @@ typedef Array<class AliasDeclaration *> AliasDeclarations;\n \n typedef Array<class Module *> Modules;\n \n-typedef Array<struct File *> Files;\n-\n typedef Array<class CaseStatement *> CaseStatements;\n \n typedef Array<class ScopeStatement *> ScopeStatements;\n@@ -63,3 +63,8 @@ typedef Array<class GotoStatement *> GotoStatements;\n typedef Array<class TemplateInstance *> TemplateInstances;\n \n typedef Array<struct Ensure> Ensures;\n+\n+typedef Array<struct Designator> Designators;\n+\n+typedef Array<struct DesigInit> DesigInits;\n+"}, {"sha": "82d62a036575fcbcbbe4c1b70ce1ad9ecb1d2802", "filename": "gcc/d/dmd/ast_node.d", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fast_node.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fast_node.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fast_node.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -0,0 +1,26 @@\n+/**\n+ * Defines the base class for all nodes which are part of the AST.\n+ *\n+ * Copyright:   Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n+ * Authors:     $(LINK2 http://www.digitalmars.com, Walter Bright)\n+ * License:     $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+ * Source:      $(LINK2 https://github.com/dlang/dmd/blob/master/src/dmd/ast_node.d, _ast_node.d)\n+ * Documentation:  https://dlang.org/phobos/dmd_ast_node.html\n+ * Coverage:    https://codecov.io/gh/dlang/dmd/src/master/src/dmd/ast_node.d\n+ */\n+module dmd.ast_node;\n+\n+import dmd.root.rootobject : RootObject;\n+import dmd.visitor : Visitor;\n+\n+/// The base class of all AST nodes.\n+extern (C++) abstract class ASTNode : RootObject\n+{\n+    /**\n+     * Visits this AST node using the given visitor.\n+     *\n+     * Params:\n+     *  v = the visitor to use when visiting this node\n+     */\n+    abstract void accept(Visitor v);\n+}"}, {"sha": "d40f836faae4dc18cbccc396a637151770781d64", "filename": "gcc/d/dmd/astcodegen.d", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fastcodegen.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fastcodegen.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fastcodegen.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -0,0 +1,102 @@\n+/**\n+ * Defines AST nodes for the code generation stage.\n+ *\n+ * Documentation:  https://dlang.org/phobos/dmd_astcodegen.html\n+ * Coverage:    https://codecov.io/gh/dlang/dmd/src/master/src/dmd/astcodegen.d\n+ */\n+module dmd.astcodegen;\n+\n+\n+struct ASTCodegen\n+{\n+    public import dmd.aggregate;\n+    public import dmd.aliasthis;\n+    public import dmd.arraytypes;\n+    public import dmd.attrib;\n+    public import dmd.cond;\n+    public import dmd.dclass;\n+    public import dmd.declaration;\n+    public import dmd.denum;\n+    public import dmd.dimport;\n+    public import dmd.dmodule;\n+    public import dmd.dstruct;\n+    public import dmd.dsymbol;\n+    public import dmd.dtemplate;\n+    public import dmd.dversion;\n+    public import dmd.expression;\n+    public import dmd.func;\n+    public import dmd.hdrgen;\n+    public import dmd.init;\n+    public import dmd.initsem;\n+    public import dmd.mtype;\n+    public import dmd.nspace;\n+    public import dmd.statement;\n+    public import dmd.staticassert;\n+    public import dmd.typesem;\n+    public import dmd.ctfeexpr;\n+    public import dmd.init : Designator;\n+\n+\n+    alias initializerToExpression   = dmd.initsem.initializerToExpression;\n+    alias typeToExpression          = dmd.typesem.typeToExpression;\n+    alias UserAttributeDeclaration  = dmd.attrib.UserAttributeDeclaration;\n+    alias Ensure                    = dmd.func.Ensure; // workaround for bug in older DMD frontends\n+    alias ErrorExp                  = dmd.expression.ErrorExp;\n+\n+    alias MODFlags                  = dmd.mtype.MODFlags;\n+    alias Type                      = dmd.mtype.Type;\n+    alias Parameter                 = dmd.mtype.Parameter;\n+    alias Tarray                    = dmd.mtype.Tarray;\n+    alias Taarray                   = dmd.mtype.Taarray;\n+    alias Tbool                     = dmd.mtype.Tbool;\n+    alias Tchar                     = dmd.mtype.Tchar;\n+    alias Tdchar                    = dmd.mtype.Tdchar;\n+    alias Tdelegate                 = dmd.mtype.Tdelegate;\n+    alias Tenum                     = dmd.mtype.Tenum;\n+    alias Terror                    = dmd.mtype.Terror;\n+    alias Tfloat32                  = dmd.mtype.Tfloat32;\n+    alias Tfloat64                  = dmd.mtype.Tfloat64;\n+    alias Tfloat80                  = dmd.mtype.Tfloat80;\n+    alias Tfunction                 = dmd.mtype.Tfunction;\n+    alias Tpointer                  = dmd.mtype.Tpointer;\n+    alias Treference                = dmd.mtype.Treference;\n+    alias Tident                    = dmd.mtype.Tident;\n+    alias Tint8                     = dmd.mtype.Tint8;\n+    alias Tint16                    = dmd.mtype.Tint16;\n+    alias Tint32                    = dmd.mtype.Tint32;\n+    alias Tint64                    = dmd.mtype.Tint64;\n+    alias Tsarray                   = dmd.mtype.Tsarray;\n+    alias Tstruct                   = dmd.mtype.Tstruct;\n+    alias Tuns8                     = dmd.mtype.Tuns8;\n+    alias Tuns16                    = dmd.mtype.Tuns16;\n+    alias Tuns32                    = dmd.mtype.Tuns32;\n+    alias Tuns64                    = dmd.mtype.Tuns64;\n+    alias Tvoid                     = dmd.mtype.Tvoid;\n+    alias Twchar                    = dmd.mtype.Twchar;\n+    alias Tnoreturn                 = dmd.mtype.Tnoreturn;\n+\n+    alias Timaginary32              = dmd.mtype.Timaginary32;\n+    alias Timaginary64              = dmd.mtype.Timaginary64;\n+    alias Timaginary80              = dmd.mtype.Timaginary80;\n+    alias Tcomplex32                = dmd.mtype.Tcomplex32;\n+    alias Tcomplex64                = dmd.mtype.Tcomplex64;\n+    alias Tcomplex80                = dmd.mtype.Tcomplex80;\n+\n+    alias ParameterList             = dmd.mtype.ParameterList;\n+    alias VarArg                    = dmd.mtype.VarArg;\n+    alias STC                       = dmd.declaration.STC;\n+    alias Dsymbol                   = dmd.dsymbol.Dsymbol;\n+    alias Dsymbols                  = dmd.dsymbol.Dsymbols;\n+    alias Visibility                = dmd.dsymbol.Visibility;\n+\n+    alias stcToBuffer               = dmd.hdrgen.stcToBuffer;\n+    alias linkageToChars            = dmd.hdrgen.linkageToChars;\n+    alias visibilityToChars         = dmd.hdrgen.visibilityToChars;\n+\n+    alias isType                    = dmd.dtemplate.isType;\n+    alias isExpression              = dmd.dtemplate.isExpression;\n+    alias isTuple                   = dmd.dtemplate.isTuple;\n+\n+    alias IgnoreErrors              = dmd.dsymbol.IgnoreErrors;\n+    alias PASS                      = dmd.dsymbol.PASS;\n+}"}, {"sha": "df88bb97bdf7836cdab6017f15e7a80a1c2c2552", "filename": "gcc/d/dmd/astenums.d", "status": "added", "additions": 391, "deletions": 0, "changes": 391, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fastenums.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fastenums.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fastenums.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -0,0 +1,391 @@\n+/**\n+ * Defines enums common to dmd and dmd as parse library.\n+ *\n+ * Copyright:   Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n+ * License:     $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+ * Source:      $(LINK2 https://github.com/dlang/dmd/blob/master/src/dmd/astenums.d, _astenums.d)\n+ * Documentation:  https://dlang.org/phobos/dmd_astenums.html\n+ * Coverage:    https://codecov.io/gh/dlang/dmd/src/master/src/dmd/astenums.d\n+ */\n+\n+module dmd.astenums;\n+\n+enum Sizeok : ubyte\n+{\n+    none,               /// size of aggregate is not yet able to compute\n+    fwd,                /// size of aggregate is ready to compute\n+    inProcess,          /// in the midst of computing the size\n+    done,               /// size of aggregate is set correctly\n+}\n+\n+enum Baseok : ubyte\n+{\n+    none,               /// base classes not computed yet\n+    start,              /// in process of resolving base classes\n+    done,               /// all base classes are resolved\n+    semanticdone,       /// all base classes semantic done\n+}\n+\n+enum MODFlags : int\n+{\n+    const_       = 1,    // type is const\n+    immutable_   = 4,    // type is immutable\n+    shared_      = 2,    // type is shared\n+    wild         = 8,    // type is wild\n+    wildconst    = (MODFlags.wild | MODFlags.const_), // type is wild const\n+    mutable      = 0x10, // type is mutable (only used in wildcard matching)\n+}\n+\n+alias MOD = ubyte;\n+\n+enum STC : ulong  // transfer changes to declaration.h\n+{\n+    undefined_          = 0,\n+\n+    static_             = 1,   /// `static`\n+    extern_             = 2,   /// `extern`\n+    const_              = 4,   /// `const`\n+    final_              = 8,   /// `final`\n+\n+    abstract_           = 0x10,   /// `abstract`\n+    parameter           = 0x20,   /// is function parameter\n+    field               = 0x40,   /// is field of struct, union or class\n+    override_           = 0x80,   /// `override`\n+\n+    auto_               = 0x100,   /// `auto`\n+    synchronized_       = 0x200,   /// `synchronized`\n+    deprecated_         = 0x400,   /// `deprecated`\n+    in_                 = 0x800,   /// `in` parameter\n+\n+    out_                = 0x1000,   /// `out` parameter\n+    lazy_               = 0x2000,   /// `lazy` parameter\n+    foreach_            = 0x4000,   /// variable for foreach loop\n+    variadic            = 0x8000,   /// the `variadic` parameter in: T foo(T a, U b, V variadic...)\n+\n+    ctorinit            = 0x1_0000,   /// can only be set inside constructor\n+    templateparameter   = 0x2_0000,   /// template parameter\n+    ref_                = 0x4_0000,   /// `ref`\n+    scope_              = 0x8_0000,   /// `scope`\n+\n+    maybescope          = 0x10_0000,   /// parameter might be `scope`\n+    scopeinferred       = 0x20_0000,   /// `scope` has been inferred and should not be part of mangling, `scope_` must also be set\n+    return_             = 0x40_0000,   /// 'return ref' or 'return scope' for function parameters\n+    returnScope         = 0x80_0000,   /// if `ref return scope` then resolve to `ref` and `return scope`\n+\n+    returninferred      = 0x100_0000,   /// `return` has been inferred and should not be part of mangling, `return_` must also be set\n+    immutable_          = 0x200_0000,   /// `immutable`\n+    init                = 0x400_0000,   /// has explicit initializer\n+    manifest            = 0x800_0000,   /// manifest constant\n+\n+    nodtor              = 0x1000_0000,   /// do not run destructor\n+    nothrow_            = 0x2000_0000,   /// `nothrow` meaning never throws exceptions\n+    pure_               = 0x4000_0000,   /// `pure` function\n+    tls                 = 0x8000_0000,   /// thread local\n+\n+    alias_              = 0x1_0000_0000,   /// `alias` parameter\n+    shared_             = 0x2_0000_0000,   /// accessible from multiple threads\n+    gshared             = 0x4_0000_0000,   /// accessible from multiple threads, but not typed as `shared`\n+    wild                = 0x8_0000_0000,   /// for wild type constructor\n+\n+    property            = 0x10_0000_0000,   /// `@property`\n+    safe                = 0x20_0000_0000,   /// `@safe`\n+    trusted             = 0x40_0000_0000,   /// `@trusted`\n+    system              = 0x80_0000_0000,   /// `@system`\n+\n+    ctfe                = 0x100_0000_0000,   /// can be used in CTFE, even if it is static\n+    disable             = 0x200_0000_0000,   /// for functions that are not callable\n+    result              = 0x400_0000_0000,   /// for result variables passed to out contracts\n+    nodefaultctor       = 0x800_0000_0000,   /// must be set inside constructor\n+\n+    temp                = 0x1000_0000_0000,   /// temporary variable\n+    rvalue              = 0x2000_0000_0000,   /// force rvalue for variables\n+    nogc                = 0x4000_0000_0000,   /// `@nogc`\n+    autoref             = 0x8000_0000_0000,   /// Mark for the already deduced `auto ref` parameter\n+\n+    inference           = 0x1_0000_0000_0000,   /// do attribute inference\n+    exptemp             = 0x2_0000_0000_0000,   /// temporary variable that has lifetime restricted to an expression\n+    future              = 0x4_0000_0000_0000,   /// introducing new base class function\n+    local               = 0x8_0000_0000_0000,   /// do not forward (see dmd.dsymbol.ForwardingScopeDsymbol).\n+\n+    live                = 0x10_0000_0000_0000,   /// function `@live` attribute\n+    register            = 0x20_0000_0000_0000,   /// `register` storage class (ImportC)\n+    volatile_           = 0x40_0000_0000_0000,   /// destined for volatile in the back end\n+\n+    safeGroup = STC.safe | STC.trusted | STC.system,\n+    IOR  = STC.in_ | STC.ref_ | STC.out_,\n+    TYPECTOR = (STC.const_ | STC.immutable_ | STC.shared_ | STC.wild),\n+    FUNCATTR = (STC.ref_ | STC.nothrow_ | STC.nogc | STC.pure_ | STC.property | STC.live |\n+                safeGroup),\n+\n+    /* These are visible to the user, i.e. are expressed by the user\n+     */\n+    visibleStorageClasses =\n+        (STC.auto_ | STC.scope_ | STC.static_ | STC.extern_ | STC.const_ | STC.final_ | STC.abstract_ | STC.synchronized_ |\n+         STC.deprecated_ | STC.future | STC.override_ | STC.lazy_ | STC.alias_ | STC.out_ | STC.in_ | STC.manifest |\n+         STC.immutable_ | STC.shared_ | STC.wild | STC.nothrow_ | STC.nogc | STC.pure_ | STC.ref_ | STC.return_ | STC.tls | STC.gshared |\n+         STC.property | STC.safeGroup | STC.disable | STC.local | STC.live),\n+\n+    /* These storage classes \"flow through\" to the inner scope of a Dsymbol\n+     */\n+    flowThruAggregate = STC.safeGroup,    /// for an AggregateDeclaration\n+    flowThruFunction = ~(STC.auto_ | STC.scope_ | STC.static_ | STC.extern_ | STC.abstract_ | STC.deprecated_ | STC.override_ |\n+                         STC.TYPECTOR | STC.final_ | STC.tls | STC.gshared | STC.ref_ | STC.return_ | STC.property |\n+                         STC.nothrow_ | STC.pure_ | STC.safe | STC.trusted | STC.system), /// for a FuncDeclaration\n+\n+}\n+\n+/********\n+ * Determine if it's the ambigous case of where `return` attaches to.\n+ * Params:\n+ *   stc = STC flags\n+ * Returns:\n+ *   true if (`ref` | `out`) and `scope` and `return`\n+ */\n+@safe pure @nogc nothrow\n+bool isRefReturnScope(const ulong stc)\n+{\n+    return (stc & (STC.scope_ | STC.return_)) == (STC.scope_ | STC.return_) &&\n+           stc & (STC.ref_ | STC.out_);\n+}\n+\n+/* This is different from the one in declaration.d, make that fix a separate PR */\n+static if (0)\n+extern (C++) __gshared const(StorageClass) STCStorageClass =\n+    (STC.auto_ | STC.scope_ | STC.static_ | STC.extern_ | STC.const_ | STC.final_ |\n+     STC.abstract_ | STC.synchronized_ | STC.deprecated_ | STC.override_ | STC.lazy_ |\n+     STC.alias_ | STC.out_ | STC.in_ | STC.manifest | STC.immutable_ | STC.shared_ |\n+     STC.wild | STC.nothrow_ | STC.nogc | STC.pure_ | STC.ref_ | STC.return_ | STC.tls |\n+     STC.gshared | STC.property | STC.live |\n+     STC.safeGroup | STC.disable);\n+\n+enum TY : ubyte\n+{\n+    Tarray,     // slice array, aka T[]\n+    Tsarray,    // static array, aka T[dimension]\n+    Taarray,    // associative array, aka T[type]\n+    Tpointer,\n+    Treference,\n+    Tfunction,\n+    Tident,\n+    Tclass,\n+    Tstruct,\n+    Tenum,\n+\n+    Tdelegate,\n+    Tnone,\n+    Tvoid,\n+    Tint8,\n+    Tuns8,\n+    Tint16,\n+    Tuns16,\n+    Tint32,\n+    Tuns32,\n+    Tint64,\n+\n+    Tuns64,\n+    Tfloat32,\n+    Tfloat64,\n+    Tfloat80,\n+    Timaginary32,\n+    Timaginary64,\n+    Timaginary80,\n+    Tcomplex32,\n+    Tcomplex64,\n+    Tcomplex80,\n+\n+    Tbool,\n+    Tchar,\n+    Twchar,\n+    Tdchar,\n+    Terror,\n+    Tinstance,\n+    Ttypeof,\n+    Ttuple,\n+    Tslice,\n+    Treturn,\n+\n+    Tnull,\n+    Tvector,\n+    Tint128,\n+    Tuns128,\n+    Ttraits,\n+    Tmixin,\n+    Tnoreturn,\n+    Ttag,\n+    TMAX\n+}\n+\n+alias Tarray = TY.Tarray;\n+alias Tsarray = TY.Tsarray;\n+alias Taarray = TY.Taarray;\n+alias Tpointer = TY.Tpointer;\n+alias Treference = TY.Treference;\n+alias Tfunction = TY.Tfunction;\n+alias Tident = TY.Tident;\n+alias Tclass = TY.Tclass;\n+alias Tstruct = TY.Tstruct;\n+alias Tenum = TY.Tenum;\n+alias Tdelegate = TY.Tdelegate;\n+alias Tnone = TY.Tnone;\n+alias Tvoid = TY.Tvoid;\n+alias Tint8 = TY.Tint8;\n+alias Tuns8 = TY.Tuns8;\n+alias Tint16 = TY.Tint16;\n+alias Tuns16 = TY.Tuns16;\n+alias Tint32 = TY.Tint32;\n+alias Tuns32 = TY.Tuns32;\n+alias Tint64 = TY.Tint64;\n+alias Tuns64 = TY.Tuns64;\n+alias Tfloat32 = TY.Tfloat32;\n+alias Tfloat64 = TY.Tfloat64;\n+alias Tfloat80 = TY.Tfloat80;\n+alias Timaginary32 = TY.Timaginary32;\n+alias Timaginary64 = TY.Timaginary64;\n+alias Timaginary80 = TY.Timaginary80;\n+alias Tcomplex32 = TY.Tcomplex32;\n+alias Tcomplex64 = TY.Tcomplex64;\n+alias Tcomplex80 = TY.Tcomplex80;\n+alias Tbool = TY.Tbool;\n+alias Tchar = TY.Tchar;\n+alias Twchar = TY.Twchar;\n+alias Tdchar = TY.Tdchar;\n+alias Terror = TY.Terror;\n+alias Tinstance = TY.Tinstance;\n+alias Ttypeof = TY.Ttypeof;\n+alias Ttuple = TY.Ttuple;\n+alias Tslice = TY.Tslice;\n+alias Treturn = TY.Treturn;\n+alias Tnull = TY.Tnull;\n+alias Tvector = TY.Tvector;\n+alias Tint128 = TY.Tint128;\n+alias Tuns128 = TY.Tuns128;\n+alias Ttraits = TY.Ttraits;\n+alias Tmixin = TY.Tmixin;\n+alias Tnoreturn = TY.Tnoreturn;\n+alias Ttag = TY.Ttag;\n+alias TMAX = TY.TMAX;\n+\n+enum TFlags\n+{\n+    integral     = 1,\n+    floating     = 2,\n+    unsigned     = 4,\n+    real_        = 8,\n+    imaginary    = 0x10,\n+    complex      = 0x20,\n+}\n+\n+enum PKG : int\n+{\n+    unknown,      /// not yet determined whether it's a package.d or not\n+    module_,      /// already determined that's an actual package.d\n+    package_,     /// already determined that's an actual package\n+}\n+\n+enum ThreeState : ubyte\n+{\n+    none,  /// state is not yet computed\n+    no,    /// state is false\n+    yes,   /// state is true\n+}\n+\n+enum TRUST : ubyte\n+{\n+    default_   = 0,\n+    system     = 1,    // @system (same as TRUST.default)\n+    trusted    = 2,    // @trusted\n+    safe       = 3,    // @safe\n+}\n+\n+enum PURE : ubyte\n+{\n+    impure      = 0,    // not pure at all\n+    fwdref      = 1,    // it's pure, but not known which level yet\n+    weak        = 2,    // no mutable globals are read or written\n+    const_      = 3,    // parameters are values or const\n+    strong      = 4,    // parameters are values or immutable\n+}\n+\n+// Whether alias this dependency is recursive or not\n+enum AliasThisRec : int\n+{\n+    no           = 0,    // no alias this recursion\n+    yes          = 1,    // alias this has recursive dependency\n+    fwdref       = 2,    // not yet known\n+    typeMask     = 3,    // mask to read no/yes/fwdref\n+    tracing      = 0x4,  // mark in progress of implicitConvTo/deduceWild\n+    tracingDT    = 0x8,  // mark in progress of deduceType\n+}\n+\n+/***************\n+ * Variadic argument lists\n+ * https://dlang.org/spec/function.html#variadic\n+ */\n+enum VarArg : ubyte\n+{\n+    none     = 0,  /// fixed number of arguments\n+    variadic = 1,  /// (T t, ...)  can be C-style (core.stdc.stdarg) or D-style (core.vararg)\n+    typesafe = 2,  /// (T t ...) typesafe https://dlang.org/spec/function.html#typesafe_variadic_functions\n+                   ///   or https://dlang.org/spec/function.html#typesafe_variadic_functions\n+}\n+\n+/*************************\n+ * Identify Statement types with this enum rather than\n+ * virtual functions\n+ */\n+enum STMT : ubyte\n+{\n+    Error,\n+    Peel,\n+    Exp, DtorExp,\n+    Compile,\n+    Compound, CompoundDeclaration, CompoundAsm,\n+    UnrolledLoop,\n+    Scope,\n+    Forwarding,\n+    While,\n+    Do,\n+    For,\n+    Foreach,\n+    ForeachRange,\n+    If,\n+    Conditional,\n+    StaticForeach,\n+    Pragma,\n+    StaticAssert,\n+    Switch,\n+    Case,\n+    CaseRange,\n+    Default,\n+    GotoDefault,\n+    GotoCase,\n+    SwitchError,\n+    Return,\n+    Break,\n+    Continue,\n+    Synchronized,\n+    With,\n+    TryCatch,\n+    TryFinally,\n+    ScopeGuard,\n+    Throw,\n+    Debug,\n+    Goto,\n+    Label,\n+    Asm, InlineAsm, GccAsm,\n+    Import,\n+}\n+\n+/**********************\n+ * Discriminant for which kind of initializer\n+ */\n+enum InitKind : ubyte\n+{\n+    void_,\n+    error,\n+    struct_,\n+    array,\n+    exp,\n+    C_,\n+}\n+"}, {"sha": "a808b8a6c3fb722389cd2a054e629f0afa0eb49f", "filename": "gcc/d/dmd/attrib.c", "status": "removed", "additions": 0, "deletions": 1320, "changes": 1320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fattrib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fattrib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fattrib.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49", "patch": "@@ -1,1320 +0,0 @@\n-\n-/* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n- * written by Walter Bright\n- * http://www.digitalmars.com\n- * Distributed under the Boost Software License, Version 1.0.\n- * http://www.boost.org/LICENSE_1_0.txt\n- * https://github.com/D-Programming-Language/dmd/blob/master/src/attrib.c\n- */\n-\n-#include \"root/dsystem.h\"               // memcmp()\n-#include \"root/rmem.h\"\n-\n-#include \"mars.h\"\n-#include \"init.h\"\n-#include \"declaration.h\"\n-#include \"attrib.h\"\n-#include \"cond.h\"\n-#include \"scope.h\"\n-#include \"id.h\"\n-#include \"expression.h\"\n-#include \"dsymbol.h\"\n-#include \"aggregate.h\"\n-#include \"module.h\"\n-#include \"parse.h\"\n-#include \"target.h\"\n-#include \"template.h\"\n-#include \"utf.h\"\n-#include \"mtype.h\"\n-\n-bool definitelyValueParameter(Expression *e);\n-Dsymbols *makeTupleForeachStaticDecl(Scope *sc, ForeachStatement *fs, Dsymbols *dbody, bool needExpansion);\n-\n-/********************************* AttribDeclaration ****************************/\n-\n-AttribDeclaration::AttribDeclaration(Dsymbols *decl)\n-        : Dsymbol()\n-{\n-    this->decl = decl;\n-}\n-\n-Dsymbols *AttribDeclaration::include(Scope *)\n-{\n-    if (errors)\n-        return NULL;\n-\n-    return decl;\n-}\n-\n-int AttribDeclaration::apply(Dsymbol_apply_ft_t fp, void *param)\n-{\n-    Dsymbols *d = include(_scope);\n-\n-    if (d)\n-    {\n-        for (size_t i = 0; i < d->length; i++)\n-        {\n-            Dsymbol *s = (*d)[i];\n-            if (s)\n-            {\n-                if (s->apply(fp, param))\n-                    return 1;\n-            }\n-        }\n-    }\n-    return 0;\n-}\n-\n-/****************************************\n- * Create a new scope if one or more given attributes\n- * are different from the sc's.\n- * If the returned scope != sc, the caller should pop\n- * the scope after it used.\n- */\n-Scope *AttribDeclaration::createNewScope(Scope *sc,\n-        StorageClass stc, LINK linkage, CPPMANGLE cppmangle, Prot protection,\n-        int explicitProtection, AlignDeclaration *aligndecl, PINLINE inlining)\n-{\n-    Scope *sc2 = sc;\n-    if (stc != sc->stc ||\n-        linkage != sc->linkage ||\n-        cppmangle != sc->cppmangle ||\n-        explicitProtection != sc->explicitProtection ||\n-        !(protection == sc->protection) ||\n-        aligndecl != sc->aligndecl ||\n-        inlining != sc->inlining)\n-    {\n-        // create new one for changes\n-        sc2 = sc->copy();\n-        sc2->stc = stc;\n-        sc2->linkage = linkage;\n-        sc2->cppmangle = cppmangle;\n-        sc2->protection = protection;\n-        sc2->explicitProtection = explicitProtection;\n-        sc2->aligndecl = aligndecl;\n-        sc2->inlining = inlining;\n-    }\n-    return sc2;\n-}\n-\n-/****************************************\n- * A hook point to supply scope for members.\n- * addMember, setScope, importAll, semantic, semantic2 and semantic3 will use this.\n- */\n-Scope *AttribDeclaration::newScope(Scope *sc)\n-{\n-    return sc;\n-}\n-\n-void AttribDeclaration::addMember(Scope *sc, ScopeDsymbol *sds)\n-{\n-    Dsymbols *d = include(sc);\n-\n-    if (d)\n-    {\n-        Scope *sc2 = newScope(sc);\n-\n-        for (size_t i = 0; i < d->length; i++)\n-        {\n-            Dsymbol *s = (*d)[i];\n-            //printf(\"\\taddMember %s to %s\\n\", s->toChars(), sds->toChars());\n-            s->addMember(sc2, sds);\n-        }\n-\n-        if (sc2 != sc)\n-            sc2->pop();\n-    }\n-}\n-\n-void AttribDeclaration::setScope(Scope *sc)\n-{\n-    Dsymbols *d = include(sc);\n-\n-    //printf(\"\\tAttribDeclaration::setScope '%s', d = %p\\n\",toChars(), d);\n-    if (d)\n-    {\n-        Scope *sc2 = newScope(sc);\n-\n-        for (size_t i = 0; i < d->length; i++)\n-        {\n-            Dsymbol *s = (*d)[i];\n-            s->setScope(sc2);\n-        }\n-\n-        if (sc2 != sc)\n-            sc2->pop();\n-    }\n-}\n-\n-void AttribDeclaration::importAll(Scope *sc)\n-{\n-    Dsymbols *d = include(sc);\n-\n-    //printf(\"\\tAttribDeclaration::importAll '%s', d = %p\\n\", toChars(), d);\n-    if (d)\n-    {\n-        Scope *sc2 = newScope(sc);\n-\n-        for (size_t i = 0; i < d->length; i++)\n-        {\n-            Dsymbol *s = (*d)[i];\n-            s->importAll(sc2);\n-        }\n-\n-        if (sc2 != sc)\n-            sc2->pop();\n-    }\n-}\n-\n-void AttribDeclaration::addComment(const utf8_t *comment)\n-{\n-    //printf(\"AttribDeclaration::addComment %s\\n\", comment);\n-    if (comment)\n-    {\n-        Dsymbols *d = include(NULL);\n-\n-        if (d)\n-        {\n-            for (size_t i = 0; i < d->length; i++)\n-            {\n-                Dsymbol *s = (*d)[i];\n-                //printf(\"AttribDeclaration::addComment %s\\n\", s->toChars());\n-                s->addComment(comment);\n-            }\n-        }\n-    }\n-}\n-\n-void AttribDeclaration::setFieldOffset(AggregateDeclaration *ad, unsigned *poffset, bool isunion)\n-{\n-    Dsymbols *d = include(NULL);\n-\n-    if (d)\n-    {\n-        for (size_t i = 0; i < d->length; i++)\n-        {\n-            Dsymbol *s = (*d)[i];\n-            s->setFieldOffset(ad, poffset, isunion);\n-        }\n-    }\n-}\n-\n-bool AttribDeclaration::hasPointers()\n-{\n-    Dsymbols *d = include(NULL);\n-\n-    if (d)\n-    {\n-        for (size_t i = 0; i < d->length; i++)\n-        {\n-            Dsymbol *s = (*d)[i];\n-            if (s->hasPointers())\n-                return true;\n-        }\n-    }\n-    return false;\n-}\n-\n-bool AttribDeclaration::hasStaticCtorOrDtor()\n-{\n-    Dsymbols *d = include(NULL);\n-\n-    if (d)\n-    {\n-        for (size_t i = 0; i < d->length; i++)\n-        {\n-            Dsymbol *s = (*d)[i];\n-            if (s->hasStaticCtorOrDtor())\n-                return true;\n-        }\n-    }\n-    return false;\n-}\n-\n-const char *AttribDeclaration::kind() const\n-{\n-    return \"attribute\";\n-}\n-\n-bool AttribDeclaration::oneMember(Dsymbol **ps, Identifier *ident)\n-{\n-    Dsymbols *d = include(NULL);\n-\n-    return Dsymbol::oneMembers(d, ps, ident);\n-}\n-\n-void AttribDeclaration::checkCtorConstInit()\n-{\n-    Dsymbols *d = include(NULL);\n-\n-    if (d)\n-    {\n-        for (size_t i = 0; i < d->length; i++)\n-        {\n-            Dsymbol *s = (*d)[i];\n-            s->checkCtorConstInit();\n-        }\n-    }\n-}\n-\n-/****************************************\n- */\n-\n-void AttribDeclaration::addLocalClass(ClassDeclarations *aclasses)\n-{\n-    Dsymbols *d = include(NULL);\n-\n-    if (d)\n-    {\n-        for (size_t i = 0; i < d->length; i++)\n-        {\n-            Dsymbol *s = (*d)[i];\n-            s->addLocalClass(aclasses);\n-        }\n-    }\n-}\n-\n-/************************* StorageClassDeclaration ****************************/\n-\n-StorageClassDeclaration::StorageClassDeclaration(StorageClass stc, Dsymbols *decl)\n-        : AttribDeclaration(decl)\n-{\n-    this->stc = stc;\n-}\n-\n-Dsymbol *StorageClassDeclaration::syntaxCopy(Dsymbol *s)\n-{\n-    assert(!s);\n-    return new StorageClassDeclaration(stc, Dsymbol::arraySyntaxCopy(decl));\n-}\n-\n-bool StorageClassDeclaration::oneMember(Dsymbol **ps, Identifier *ident)\n-{\n-    bool t = Dsymbol::oneMembers(decl, ps, ident);\n-    if (t && *ps)\n-    {\n-        /* This is to deal with the following case:\n-         * struct Tick {\n-         *   template to(T) { const T to() { ... } }\n-         * }\n-         * For eponymous function templates, the 'const' needs to get attached to 'to'\n-         * before the semantic analysis of 'to', so that template overloading based on the\n-         * 'this' pointer can be successful.\n-         */\n-\n-        FuncDeclaration *fd = (*ps)->isFuncDeclaration();\n-        if (fd)\n-        {\n-            /* Use storage_class2 instead of storage_class otherwise when we do .di generation\n-             * we'll wind up with 'const const' rather than 'const'.\n-             */\n-            /* Don't think we need to worry about mutually exclusive storage classes here\n-             */\n-            fd->storage_class2 |= stc;\n-        }\n-    }\n-    return t;\n-}\n-\n-void StorageClassDeclaration::addMember(Scope *sc, ScopeDsymbol *sds)\n-{\n-    Dsymbols *d = include(sc);\n-    if (d)\n-    {\n-        Scope *sc2 = newScope(sc);\n-        for (size_t i = 0; i < d->length; i++)\n-        {\n-            Dsymbol *s = (*d)[i];\n-            //printf(\"\\taddMember %s to %s\\n\", s->toChars(), sds->toChars());\n-            // STClocal needs to be attached before the member is added to the scope (because it influences the parent symbol)\n-            if (Declaration *decl = s->isDeclaration())\n-            {\n-                decl->storage_class |= stc & STClocal;\n-                if (StorageClassDeclaration *sdecl = s->isStorageClassDeclaration())\n-                {\n-                    sdecl->stc |= stc & STClocal;\n-                }\n-            }\n-            s->addMember(sc2, sds);\n-        }\n-        if (sc2 != sc)\n-            sc2->pop();\n-    }\n-}\n-\n-Scope *StorageClassDeclaration::newScope(Scope *sc)\n-{\n-    StorageClass scstc = sc->stc;\n-\n-    /* These sets of storage classes are mutually exclusive,\n-     * so choose the innermost or most recent one.\n-     */\n-    if (stc & (STCauto | STCscope | STCstatic | STCextern | STCmanifest))\n-        scstc &= ~(STCauto | STCscope | STCstatic | STCextern | STCmanifest);\n-    if (stc & (STCauto | STCscope | STCstatic | STCtls | STCmanifest | STCgshared))\n-        scstc &= ~(STCauto | STCscope | STCstatic | STCtls | STCmanifest | STCgshared);\n-    if (stc & (STCconst | STCimmutable | STCmanifest))\n-        scstc &= ~(STCconst | STCimmutable | STCmanifest);\n-    if (stc & (STCgshared | STCshared | STCtls))\n-        scstc &= ~(STCgshared | STCshared | STCtls);\n-    if (stc & (STCsafe | STCtrusted | STCsystem))\n-        scstc &= ~(STCsafe | STCtrusted | STCsystem);\n-    scstc |= stc;\n-    //printf(\"scstc = x%llx\\n\", scstc);\n-\n-    return createNewScope(sc, scstc, sc->linkage, sc->cppmangle,\n-        sc->protection, sc->explicitProtection, sc->aligndecl,\n-        sc->inlining);\n-}\n-\n-/********************************* DeprecatedDeclaration ****************************/\n-\n-DeprecatedDeclaration::DeprecatedDeclaration(Expression *msg, Dsymbols *decl)\n-        : StorageClassDeclaration(STCdeprecated, decl)\n-{\n-    this->msg = msg;\n-    this->msgstr = NULL;\n-}\n-\n-Dsymbol *DeprecatedDeclaration::syntaxCopy(Dsymbol *s)\n-{\n-    assert(!s);\n-    return new DeprecatedDeclaration(msg->syntaxCopy(), Dsymbol::arraySyntaxCopy(decl));\n-}\n-\n-/**\n- * Provides a new scope with `STCdeprecated` and `Scope.depdecl` set\n- *\n- * Calls `StorageClassDeclaration.newScope` (as it must be called or copied\n- * in any function overriding `newScope`), then set the `Scope`'s depdecl.\n- *\n- * Returns:\n- *   Always a new scope, to use for this `DeprecatedDeclaration`'s members.\n- */\n-Scope *DeprecatedDeclaration::newScope(Scope *sc)\n-{\n-    Scope *scx = StorageClassDeclaration::newScope(sc);\n-    // The enclosing scope is deprecated as well\n-    if (scx == sc)\n-        scx = sc->push();\n-    scx->depdecl = this;\n-    return scx;\n-}\n-\n-void DeprecatedDeclaration::setScope(Scope *sc)\n-{\n-    //printf(\"DeprecatedDeclaration::setScope() %p\\n\", this);\n-    if (decl)\n-        Dsymbol::setScope(sc); // for forward reference\n-    return AttribDeclaration::setScope(sc);\n-}\n-\n-const char *DeprecatedDeclaration::getMessage()\n-{\n-    if (Scope *sc = _scope)\n-    {\n-        _scope = NULL;\n-\n-        sc = sc->startCTFE();\n-        msg = expressionSemantic(msg, sc);\n-        msg = resolveProperties(sc, msg);\n-        sc = sc->endCTFE();\n-        msg = msg->ctfeInterpret();\n-\n-        if (StringExp *se = msg->toStringExp())\n-            msgstr = (char *)se->string;\n-        else\n-            msg->error(\"compile time constant expected, not `%s`\", msg->toChars());\n-    }\n-    return msgstr;\n-}\n-\n-/********************************* LinkDeclaration ****************************/\n-\n-LinkDeclaration::LinkDeclaration(LINK p, Dsymbols *decl)\n-        : AttribDeclaration(decl)\n-{\n-    //printf(\"LinkDeclaration(linkage = %d, decl = %p)\\n\", p, decl);\n-    linkage = (p == LINKsystem) ? target.systemLinkage() : p;\n-}\n-\n-LinkDeclaration *LinkDeclaration::create(LINK p, Dsymbols *decl)\n-{\n-    return new LinkDeclaration(p, decl);\n-}\n-\n-Dsymbol *LinkDeclaration::syntaxCopy(Dsymbol *s)\n-{\n-    assert(!s);\n-    return new LinkDeclaration(linkage, Dsymbol::arraySyntaxCopy(decl));\n-}\n-\n-Scope *LinkDeclaration::newScope(Scope *sc)\n-{\n-    return createNewScope(sc, sc->stc, this->linkage, sc->cppmangle,\n-        sc->protection, sc->explicitProtection, sc->aligndecl,\n-        sc->inlining);\n-}\n-\n-const char *LinkDeclaration::toChars()\n-{\n-    return \"extern ()\";\n-}\n-\n-/********************************* CPPMangleDeclaration ****************************/\n-\n-CPPMangleDeclaration::CPPMangleDeclaration(CPPMANGLE p, Dsymbols *decl)\n-        : AttribDeclaration(decl)\n-{\n-    //printf(\"CPPMangleDeclaration(cppmangle = %d, decl = %p)\\n\", p, decl);\n-    cppmangle = p;\n-}\n-\n-Dsymbol *CPPMangleDeclaration::syntaxCopy(Dsymbol *s)\n-{\n-    assert(!s);\n-    return new CPPMangleDeclaration(cppmangle, Dsymbol::arraySyntaxCopy(decl));\n-}\n-\n-Scope *CPPMangleDeclaration::newScope(Scope *sc)\n-{\n-    return createNewScope(sc, sc->stc, LINKcpp, this->cppmangle,\n-        sc->protection, sc->explicitProtection, sc->aligndecl,\n-        sc->inlining);\n-}\n-\n-const char *CPPMangleDeclaration::toChars()\n-{\n-    return \"extern ()\";\n-}\n-\n-/********************************* ProtDeclaration ****************************/\n-\n-/**\n- * Params:\n- *  loc = source location of attribute token\n- *  p = protection attribute data\n- *  decl = declarations which are affected by this protection attribute\n- */\n-ProtDeclaration::ProtDeclaration(Loc loc, Prot p, Dsymbols *decl)\n-        : AttribDeclaration(decl)\n-{\n-    this->loc = loc;\n-    this->protection = p;\n-    this->pkg_identifiers = NULL;\n-    //printf(\"decl = %p\\n\", decl);\n-}\n-\n-/**\n- * Params:\n- *  loc = source location of attribute token\n- *  pkg_identifiers = list of identifiers for a qualified package name\n- *  decl = declarations which are affected by this protection attribute\n- */\n-ProtDeclaration::ProtDeclaration(Loc loc, Identifiers* pkg_identifiers, Dsymbols *decl)\n-        : AttribDeclaration(decl)\n-{\n-    this->loc = loc;\n-    this->protection.kind = Prot::package_;\n-    this->protection.pkg  = NULL;\n-    this->pkg_identifiers = pkg_identifiers;\n-}\n-\n-Dsymbol *ProtDeclaration::syntaxCopy(Dsymbol *s)\n-{\n-    assert(!s);\n-    if (protection.kind == Prot::package_)\n-        return new ProtDeclaration(this->loc, pkg_identifiers, Dsymbol::arraySyntaxCopy(decl));\n-    else\n-        return new ProtDeclaration(this->loc, protection, Dsymbol::arraySyntaxCopy(decl));\n-}\n-\n-Scope *ProtDeclaration::newScope(Scope *sc)\n-{\n-    if (pkg_identifiers)\n-        dsymbolSemantic(this, sc);\n-    return createNewScope(sc, sc->stc, sc->linkage, sc->cppmangle,\n-        this->protection, 1, sc->aligndecl,\n-        sc->inlining);\n-}\n-\n-void ProtDeclaration::addMember(Scope *sc, ScopeDsymbol *sds)\n-{\n-    if (pkg_identifiers)\n-    {\n-        Dsymbol* tmp;\n-        Package::resolve(pkg_identifiers, &tmp, NULL);\n-        protection.pkg = tmp ? tmp->isPackage() : NULL;\n-        pkg_identifiers = NULL;\n-    }\n-\n-    if (protection.kind == Prot::package_ && protection.pkg && sc->_module)\n-    {\n-        Module *m = sc->_module;\n-\n-        // While isAncestorPackageOf does an equality check, the fix for issue 17441 adds a check to see if\n-        // each package's .isModule() properites are equal.\n-        //\n-        // Properties generated from `package(foo)` i.e. protection.pkg have .isModule() == null.\n-        // This breaks package declarations of the package in question if they are declared in\n-        // the same package.d file, which _do_ have a module associated with them, and hence a non-null\n-        // isModule()\n-        if (!m->isPackage() || !protection.pkg->ident->equals(m->isPackage()->ident))\n-        {\n-            Package* pkg = m->parent ? m->parent->isPackage() : NULL;\n-            if (!pkg || !protection.pkg->isAncestorPackageOf(pkg))\n-                error(\"does not bind to one of ancestor packages of module `%s`\",\n-                      m->toPrettyChars(true));\n-        }\n-    }\n-\n-    return AttribDeclaration::addMember(sc, sds);\n-}\n-\n-const char *ProtDeclaration::kind() const\n-{\n-    return \"protection attribute\";\n-}\n-\n-const char *ProtDeclaration::toPrettyChars(bool)\n-{\n-    assert(protection.kind > Prot::undefined);\n-\n-    OutBuffer buf;\n-    buf.writeByte('\\'');\n-    protectionToBuffer(&buf, protection);\n-    buf.writeByte('\\'');\n-    return buf.extractChars();\n-}\n-\n-/********************************* AlignDeclaration ****************************/\n-\n-AlignDeclaration::AlignDeclaration(Loc loc, Expression *ealign, Dsymbols *decl)\n-        : AttribDeclaration(decl)\n-{\n-    this->loc = loc;\n-    this->ealign = ealign;\n-    this->salign = 0;\n-}\n-\n-Dsymbol *AlignDeclaration::syntaxCopy(Dsymbol *s)\n-{\n-    assert(!s);\n-    return new AlignDeclaration(loc,\n-        ealign ? ealign->syntaxCopy() : NULL,\n-        Dsymbol::arraySyntaxCopy(decl));\n-}\n-\n-Scope *AlignDeclaration::newScope(Scope *sc)\n-{\n-    return createNewScope(sc, sc->stc, sc->linkage, sc->cppmangle,\n-        sc->protection, sc->explicitProtection, this,\n-        sc->inlining);\n-}\n-\n-structalign_t AlignDeclaration::getAlignment(Scope *sc)\n-{\n-    if (salign != 0)\n-        return salign;\n-\n-    if (!ealign)\n-        return salign = STRUCTALIGN_DEFAULT;\n-\n-    sc = sc->startCTFE();\n-    ealign = expressionSemantic(ealign, sc);\n-    ealign = resolveProperties(sc, ealign);\n-    sc = sc->endCTFE();\n-    ealign = ealign->ctfeInterpret();\n-\n-    if (ealign->op == TOKerror)\n-        return salign = STRUCTALIGN_DEFAULT;\n-\n-    Type *tb = ealign->type->toBasetype();\n-    sinteger_t n = ealign->toInteger();\n-\n-    if (n < 1 || n & (n - 1) || STRUCTALIGN_DEFAULT < n || !tb->isintegral())\n-    {\n-        ::error(loc, \"alignment must be an integer positive power of 2, not %s\", ealign->toChars());\n-        return salign = STRUCTALIGN_DEFAULT;\n-    }\n-\n-    return salign = (structalign_t)n;\n-}\n-\n-/********************************* AnonDeclaration ****************************/\n-\n-AnonDeclaration::AnonDeclaration(Loc loc, bool isunion, Dsymbols *decl)\n-        : AttribDeclaration(decl)\n-{\n-    this->loc = loc;\n-    this->isunion = isunion;\n-    this->sem = 0;\n-    this->anonoffset = 0;\n-    this->anonstructsize = 0;\n-    this->anonalignsize = 0;\n-}\n-\n-Dsymbol *AnonDeclaration::syntaxCopy(Dsymbol *s)\n-{\n-    assert(!s);\n-    return new AnonDeclaration(loc, isunion, Dsymbol::arraySyntaxCopy(decl));\n-}\n-\n-void AnonDeclaration::setScope(Scope *sc)\n-{\n-    //printf(\"AnonDeclaration::setScope() %p\\n\", this);\n-    if (decl)\n-        Dsymbol::setScope(sc);\n-    AttribDeclaration::setScope(sc);\n-}\n-\n-void AnonDeclaration::setFieldOffset(AggregateDeclaration *ad, unsigned *poffset, bool isunion)\n-{\n-    //printf(\"\\tAnonDeclaration::setFieldOffset %s %p\\n\", isunion ? \"union\" : \"struct\", this);\n-\n-    if (decl)\n-    {\n-        /* This works by treating an AnonDeclaration as an aggregate 'member',\n-         * so in order to place that member we need to compute the member's\n-         * size and alignment.\n-         */\n-\n-        size_t fieldstart = ad->fields.length;\n-\n-        /* Hackishly hijack ad's structsize and alignsize fields\n-         * for use in our fake anon aggregate member.\n-         */\n-        unsigned savestructsize = ad->structsize;\n-        unsigned savealignsize  = ad->alignsize;\n-        ad->structsize = 0;\n-        ad->alignsize = 0;\n-\n-        unsigned offset = 0;\n-        for (size_t i = 0; i < decl->length; i++)\n-        {\n-            Dsymbol *s = (*decl)[i];\n-            s->setFieldOffset(ad, &offset, this->isunion);\n-            if (this->isunion)\n-                offset = 0;\n-        }\n-\n-        /* Bugzilla 13613: If the fields in this->members had been already\n-         * added in ad->fields, just update *poffset for the subsequent\n-         * field offset calculation.\n-         */\n-        if (fieldstart == ad->fields.length)\n-        {\n-            ad->structsize = savestructsize;\n-            ad->alignsize  = savealignsize;\n-            *poffset = ad->structsize;\n-            return;\n-        }\n-\n-        anonstructsize = ad->structsize;\n-        anonalignsize  = ad->alignsize;\n-        ad->structsize = savestructsize;\n-        ad->alignsize  = savealignsize;\n-\n-        // 0 sized structs are set to 1 byte\n-        // TODO: is this corect hebavior?\n-        if (anonstructsize == 0)\n-        {\n-            anonstructsize = 1;\n-            anonalignsize = 1;\n-        }\n-\n-        assert(_scope);\n-        structalign_t alignment = _scope->alignment();\n-\n-        /* Given the anon 'member's size and alignment,\n-         * go ahead and place it.\n-         */\n-        anonoffset = AggregateDeclaration::placeField(\n-                poffset,\n-                anonstructsize, anonalignsize, alignment,\n-                &ad->structsize, &ad->alignsize,\n-                isunion);\n-\n-        // Add to the anon fields the base offset of this anonymous aggregate\n-        //printf(\"anon fields, anonoffset = %d\\n\", anonoffset);\n-        for (size_t i = fieldstart; i < ad->fields.length; i++)\n-        {\n-            VarDeclaration *v = ad->fields[i];\n-            //printf(\"\\t[%d] %s %d\\n\", i, v->toChars(), v->offset);\n-            v->offset += anonoffset;\n-        }\n-    }\n-}\n-\n-const char *AnonDeclaration::kind() const\n-{\n-    return (isunion ? \"anonymous union\" : \"anonymous struct\");\n-}\n-\n-/********************************* PragmaDeclaration ****************************/\n-\n-PragmaDeclaration::PragmaDeclaration(Loc loc, Identifier *ident, Expressions *args, Dsymbols *decl)\n-        : AttribDeclaration(decl)\n-{\n-    this->loc = loc;\n-    this->ident = ident;\n-    this->args = args;\n-}\n-\n-Dsymbol *PragmaDeclaration::syntaxCopy(Dsymbol *s)\n-{\n-    //printf(\"PragmaDeclaration::syntaxCopy(%s)\\n\", toChars());\n-    assert(!s);\n-    return new PragmaDeclaration(loc, ident,\n-        Expression::arraySyntaxCopy(args),\n-        Dsymbol::arraySyntaxCopy(decl));\n-}\n-\n-Scope *PragmaDeclaration::newScope(Scope *sc)\n-{\n-    if (ident == Id::Pinline)\n-    {\n-        PINLINE inlining = PINLINEdefault;\n-        if (!args || args->length == 0)\n-            inlining = PINLINEdefault;\n-        else if (args->length != 1)\n-        {\n-            error(\"one boolean expression expected for pragma(inline), not %d\", args->length);\n-            args->setDim(1);\n-            (*args)[0] = new ErrorExp();\n-        }\n-        else\n-        {\n-            Expression *e = (*args)[0];\n-\n-            if (e->op != TOKint64 || !e->type->equals(Type::tbool))\n-            {\n-                if (e->op != TOKerror)\n-                {\n-                    error(\"pragma(inline, true or false) expected, not %s\", e->toChars());\n-                    (*args)[0] = new ErrorExp();\n-                }\n-            }\n-            else if (e->isBool(true))\n-                inlining = PINLINEalways;\n-            else if (e->isBool(false))\n-                inlining = PINLINEnever;\n-        }\n-\n-        return createNewScope(sc, sc->stc, sc->linkage, sc->cppmangle,\n-            sc->protection, sc->explicitProtection, sc->aligndecl,\n-            inlining);\n-    }\n-    if (ident == Id::printf || ident == Id::scanf)\n-    {\n-        Scope *sc2 = sc->push();\n-\n-        if (ident == Id::printf)\n-            // Override previous setting, never let both be set\n-            sc2->flags = (sc2->flags & ~SCOPEscanf) | SCOPEprintf;\n-        else\n-            sc2->flags = (sc2->flags & ~SCOPEprintf) | SCOPEscanf;\n-\n-        return sc2;\n-    }\n-    return sc;\n-}\n-\n-const char *PragmaDeclaration::kind() const\n-{\n-    return \"pragma\";\n-}\n-\n-/********************************* ConditionalDeclaration ****************************/\n-\n-ConditionalDeclaration::ConditionalDeclaration(Condition *condition, Dsymbols *decl, Dsymbols *elsedecl)\n-        : AttribDeclaration(decl)\n-{\n-    //printf(\"ConditionalDeclaration::ConditionalDeclaration()\\n\");\n-    this->condition = condition;\n-    this->elsedecl = elsedecl;\n-}\n-\n-Dsymbol *ConditionalDeclaration::syntaxCopy(Dsymbol *s)\n-{\n-    assert(!s);\n-    return new ConditionalDeclaration(condition->syntaxCopy(),\n-        Dsymbol::arraySyntaxCopy(decl),\n-        Dsymbol::arraySyntaxCopy(elsedecl));\n-}\n-\n-bool ConditionalDeclaration::oneMember(Dsymbol **ps, Identifier *ident)\n-{\n-    //printf(\"ConditionalDeclaration::oneMember(), inc = %d\\n\", condition->inc);\n-    if (condition->inc)\n-    {\n-        Dsymbols *d = condition->include(NULL) ? decl : elsedecl;\n-        return Dsymbol::oneMembers(d, ps, ident);\n-    }\n-    else\n-    {\n-        bool res = (Dsymbol::oneMembers(    decl, ps, ident) && *ps == NULL &&\n-                    Dsymbol::oneMembers(elsedecl, ps, ident) && *ps == NULL);\n-        *ps = NULL;\n-        return res;\n-    }\n-}\n-\n-// Decide if 'then' or 'else' code should be included\n-\n-Dsymbols *ConditionalDeclaration::include(Scope *sc)\n-{\n-    //printf(\"ConditionalDeclaration::include(sc = %p) _scope = %p\\n\", sc, _scope);\n-\n-    if (errors)\n-        return NULL;\n-\n-    assert(condition);\n-    return condition->include(_scope ? _scope : sc) ? decl : elsedecl;\n-}\n-\n-void ConditionalDeclaration::setScope(Scope *sc)\n-{\n-    Dsymbols *d = include(sc);\n-\n-    //printf(\"\\tConditionalDeclaration::setScope '%s', d = %p\\n\",toChars(), d);\n-    if (d)\n-    {\n-       for (size_t i = 0; i < d->length; i++)\n-       {\n-           Dsymbol *s = (*d)[i];\n-           s->setScope(sc);\n-       }\n-    }\n-}\n-\n-void ConditionalDeclaration::addComment(const utf8_t *comment)\n-{\n-    /* Because addComment is called by the parser, if we called\n-     * include() it would define a version before it was used.\n-     * But it's no problem to drill down to both decl and elsedecl,\n-     * so that's the workaround.\n-     */\n-\n-    if (comment)\n-    {\n-        Dsymbols *d = decl;\n-\n-        for (int j = 0; j < 2; j++)\n-        {\n-            if (d)\n-            {\n-                for (size_t i = 0; i < d->length; i++)\n-                {\n-                    Dsymbol *s = (*d)[i];\n-                    //printf(\"ConditionalDeclaration::addComment %s\\n\", s->toChars());\n-                    s->addComment(comment);\n-                }\n-            }\n-            d = elsedecl;\n-        }\n-    }\n-}\n-\n-/***************************** StaticIfDeclaration ****************************/\n-\n-StaticIfDeclaration::StaticIfDeclaration(Condition *condition,\n-        Dsymbols *decl, Dsymbols *elsedecl)\n-        : ConditionalDeclaration(condition, decl, elsedecl)\n-{\n-    //printf(\"StaticIfDeclaration::StaticIfDeclaration()\\n\");\n-    scopesym = NULL;\n-    addisdone = false;\n-    onStack = false;\n-}\n-\n-Dsymbol *StaticIfDeclaration::syntaxCopy(Dsymbol *s)\n-{\n-    assert(!s);\n-    return new StaticIfDeclaration(condition->syntaxCopy(),\n-        Dsymbol::arraySyntaxCopy(decl),\n-        Dsymbol::arraySyntaxCopy(elsedecl));\n-}\n-\n-/****************************************\n- * Different from other AttribDeclaration subclasses, include() call requires\n- * the completion of addMember and setScope phases.\n- */\n-Dsymbols *StaticIfDeclaration::include(Scope *sc)\n-{\n-    //printf(\"StaticIfDeclaration::include(sc = %p) _scope = %p\\n\", sc, _scope);\n-\n-    if (errors || onStack)\n-        return NULL;\n-    onStack = true;\n-    Dsymbols *d;\n-\n-    if (condition->inc == 0)\n-    {\n-        assert(scopesym);   // addMember is already done\n-        assert(_scope);      // setScope is already done\n-\n-        d = ConditionalDeclaration::include(_scope);\n-\n-        if (d && !addisdone)\n-        {\n-            // Add members lazily.\n-            for (size_t i = 0; i < d->length; i++)\n-            {\n-                Dsymbol *s = (*d)[i];\n-                s->addMember(_scope, scopesym);\n-            }\n-\n-            // Set the member scopes lazily.\n-            for (size_t i = 0; i < d->length; i++)\n-            {\n-                Dsymbol *s = (*d)[i];\n-                s->setScope(_scope);\n-            }\n-\n-            addisdone = true;\n-        }\n-        onStack = false;\n-        return d;\n-    }\n-    else\n-    {\n-        d = ConditionalDeclaration::include(sc);\n-        onStack = false;\n-        return d;\n-    }\n-}\n-\n-void StaticIfDeclaration::addMember(Scope *, ScopeDsymbol *sds)\n-{\n-    //printf(\"StaticIfDeclaration::addMember() '%s'\\n\", toChars());\n-    /* This is deferred until the condition evaluated later (by the include() call),\n-     * so that expressions in the condition can refer to declarations\n-     * in the same scope, such as:\n-     *\n-     * template Foo(int i)\n-     * {\n-     *     const int j = i + 1;\n-     *     static if (j == 3)\n-     *         const int k;\n-     * }\n-     */\n-    this->scopesym = sds;\n-}\n-\n-void StaticIfDeclaration::importAll(Scope *)\n-{\n-    // do not evaluate condition before semantic pass\n-}\n-\n-void StaticIfDeclaration::setScope(Scope *sc)\n-{\n-    // do not evaluate condition before semantic pass\n-\n-    // But do set the scope, in case we need it for forward referencing\n-    Dsymbol::setScope(sc);\n-}\n-\n-const char *StaticIfDeclaration::kind() const\n-{\n-    return \"static if\";\n-}\n-\n-/***************************** StaticForeachDeclaration ***********************/\n-\n-/* Static foreach at declaration scope, like:\n- *     static foreach (i; [0, 1, 2]){ }\n- */\n-\n-StaticForeachDeclaration::StaticForeachDeclaration(StaticForeach *sfe, Dsymbols *decl)\n-        : AttribDeclaration(decl)\n-{\n-    this->sfe = sfe;\n-    this->scopesym = NULL;\n-    this->onStack = false;\n-    this->cached = false;\n-    this->cache = NULL;\n-}\n-\n-Dsymbol *StaticForeachDeclaration::syntaxCopy(Dsymbol *s)\n-{\n-    assert(!s);\n-    return new StaticForeachDeclaration(\n-        sfe->syntaxCopy(),\n-        Dsymbol::arraySyntaxCopy(decl));\n-}\n-\n-bool StaticForeachDeclaration::oneMember(Dsymbol **ps, Identifier *ident)\n-{\n-    // Required to support IFTI on a template that contains a\n-    // `static foreach` declaration.  `super.oneMember` calls\n-    // include with a `null` scope.  As `static foreach` requires\n-    // the scope for expansion, `oneMember` can only return a\n-    // precise result once `static foreach` has been expanded.\n-    if (cached)\n-    {\n-        return AttribDeclaration::oneMember(ps, ident);\n-    }\n-    *ps = NULL; // a `static foreach` declaration may in general expand to multiple symbols\n-    return false;\n-}\n-\n-Dsymbols *StaticForeachDeclaration::include(Scope *)\n-{\n-    if (errors || onStack)\n-        return NULL;\n-    if (cached)\n-    {\n-        assert(!onStack);\n-        return cache;\n-    }\n-    onStack = true;\n-\n-    if (_scope)\n-    {\n-        staticForeachPrepare(sfe, _scope); // lower static foreach aggregate\n-    }\n-    if (!staticForeachReady(sfe))\n-    {\n-        onStack = false;\n-        return NULL; // TODO: ok?\n-    }\n-\n-    // expand static foreach\n-    Dsymbols *d = makeTupleForeachStaticDecl(_scope, sfe->aggrfe, decl, sfe->needExpansion);\n-    if (d) // process generated declarations\n-    {\n-        // Add members lazily.\n-        for (size_t i = 0; i < d->length; i++)\n-        {\n-            Dsymbol *s = (*d)[i];\n-            s->addMember(_scope, scopesym);\n-        }\n-        // Set the member scopes lazily.\n-        for (size_t i = 0; i < d->length; i++)\n-        {\n-            Dsymbol *s = (*d)[i];\n-            s->setScope(_scope);\n-        }\n-    }\n-    onStack = false;\n-    cached = true;\n-    cache = d;\n-    return d;\n-}\n-\n-void StaticForeachDeclaration::addMember(Scope *, ScopeDsymbol *sds)\n-{\n-    // used only for caching the enclosing symbol\n-    this->scopesym = sds;\n-}\n-\n-void StaticForeachDeclaration::addComment(const utf8_t *)\n-{\n-    // do nothing\n-    // change this to give semantics to documentation comments on static foreach declarations\n-}\n-\n-void StaticForeachDeclaration::setScope(Scope *sc)\n-{\n-    // do not evaluate condition before semantic pass\n-    // But do set the scope, in case we need it for forward referencing\n-    Dsymbol::setScope(sc);\n-}\n-\n-void StaticForeachDeclaration::importAll(Scope *)\n-{\n-    // do not evaluate aggregate before semantic pass\n-}\n-\n-const char *StaticForeachDeclaration::kind() const\n-{\n-    return \"static foreach\";\n-}\n-\n-/***********************************************************\n- * Collection of declarations that stores foreach index variables in a\n- * local symbol table.  Other symbols declared within are forwarded to\n- * another scope, like:\n- *\n- *      static foreach (i; 0 .. 10) // loop variables for different indices do not conflict.\n- *      { // this body is expanded into 10 ForwardingAttribDeclarations, where `i` has storage class STClocal\n- *          mixin(\"enum x\" ~ to!string(i) ~ \" = i\"); // ok, can access current loop variable\n- *      }\n- *\n- *      static foreach (i; 0.. 10)\n- *      {\n- *          pragma(msg, mixin(\"x\" ~ to!string(i))); // ok, all 10 symbols are visible as they were forwarded to the global scope\n- *      }\n- *\n- *      static assert (!is(typeof(i))); // loop index variable is not visible outside of the static foreach loop\n- *\n- * A StaticForeachDeclaration generates one\n- * ForwardingAttribDeclaration for each expansion of its body.  The\n- * AST of the ForwardingAttribDeclaration contains both the `static\n- * foreach` variables and the respective copy of the `static foreach`\n- * body.  The functionality is achieved by using a\n- * ForwardingScopeDsymbol as the parent symbol for the generated\n- * declarations.\n- */\n-\n-ForwardingAttribDeclaration::ForwardingAttribDeclaration(Dsymbols *decl)\n-        : AttribDeclaration(decl)\n-{\n-    sym = new ForwardingScopeDsymbol(NULL);\n-    sym->symtab = new DsymbolTable();\n-}\n-\n-/**************************************\n- * Use the ForwardingScopeDsymbol as the parent symbol for members.\n- */\n-Scope *ForwardingAttribDeclaration::newScope(Scope *sc)\n-{\n-    return sc->push(sym);\n-}\n-\n-/***************************************\n- * Lazily initializes the scope to forward to.\n- */\n-void ForwardingAttribDeclaration::addMember(Scope *sc, ScopeDsymbol *sds)\n-{\n-    parent = sym->parent = sym->forward = sds;\n-    return AttribDeclaration::addMember(sc, sym);\n-}\n-\n-/***************************** CompileDeclaration *****************************/\n-\n-// These are mixin declarations, like mixin(\"int x\");\n-\n-CompileDeclaration::CompileDeclaration(Loc loc, Expressions *exps)\n-    : AttribDeclaration(NULL)\n-{\n-    //printf(\"CompileDeclaration(loc = %d)\\n\", loc.linnum);\n-    this->loc = loc;\n-    this->exps = exps;\n-    this->scopesym = NULL;\n-    this->compiled = false;\n-}\n-\n-Dsymbol *CompileDeclaration::syntaxCopy(Dsymbol *)\n-{\n-    //printf(\"CompileDeclaration::syntaxCopy('%s')\\n\", toChars());\n-    return new CompileDeclaration(loc, Expression::arraySyntaxCopy(exps));\n-}\n-\n-void CompileDeclaration::addMember(Scope *, ScopeDsymbol *sds)\n-{\n-    //printf(\"CompileDeclaration::addMember(sc = %p, sds = %p, memnum = %d)\\n\", sc, sds, memnum);\n-    this->scopesym = sds;\n-}\n-\n-void CompileDeclaration::setScope(Scope *sc)\n-{\n-    Dsymbol::setScope(sc);\n-}\n-\n-const char *CompileDeclaration::kind() const\n-{\n-    return \"mixin\";\n-}\n-\n-/***************************** UserAttributeDeclaration *****************************/\n-\n-UserAttributeDeclaration::UserAttributeDeclaration(Expressions *atts, Dsymbols *decl)\n-        : AttribDeclaration(decl)\n-{\n-    //printf(\"UserAttributeDeclaration()\\n\");\n-    this->atts = atts;\n-}\n-\n-Dsymbol *UserAttributeDeclaration::syntaxCopy(Dsymbol *s)\n-{\n-    //printf(\"UserAttributeDeclaration::syntaxCopy('%s')\\n\", toChars());\n-    assert(!s);\n-    return new UserAttributeDeclaration(\n-        Expression::arraySyntaxCopy(this->atts),\n-        Dsymbol::arraySyntaxCopy(decl));\n-}\n-\n-Scope *UserAttributeDeclaration::newScope(Scope *sc)\n-{\n-    Scope *sc2 = sc;\n-    if (atts && atts->length)\n-    {\n-        // create new one for changes\n-        sc2 = sc->copy();\n-        sc2->userAttribDecl = this;\n-    }\n-    return sc2;\n-}\n-\n-void UserAttributeDeclaration::setScope(Scope *sc)\n-{\n-    //printf(\"UserAttributeDeclaration::setScope() %p\\n\", this);\n-    if (decl)\n-        Dsymbol::setScope(sc);  // for forward reference of UDAs\n-\n-    return AttribDeclaration::setScope(sc);\n-}\n-\n-void udaExpressionEval(Scope *sc, Expressions *exps)\n-{\n-    for (size_t i = 0; i < exps->length; i++)\n-    {\n-        Expression *e = (*exps)[i];\n-        if (e)\n-        {\n-            e = expressionSemantic(e, sc);\n-            if (definitelyValueParameter(e))\n-                e = e->ctfeInterpret();\n-            if (e->op == TOKtuple)\n-            {\n-                TupleExp *te = (TupleExp *)e;\n-                udaExpressionEval(sc, te->exps);\n-            }\n-            (*exps)[i] = e;\n-        }\n-    }\n-}\n-\n-Expressions *UserAttributeDeclaration::concat(Expressions *udas1, Expressions *udas2)\n-{\n-    Expressions *udas;\n-    if (!udas1 || udas1->length == 0)\n-        udas = udas2;\n-    else if (!udas2 || udas2->length == 0)\n-        udas = udas1;\n-    else\n-    {\n-        /* Create a new tuple that combines them\n-         * (do not append to left operand, as this is a copy-on-write operation)\n-         */\n-        udas = new Expressions();\n-        udas->push(new TupleExp(Loc(), udas1));\n-        udas->push(new TupleExp(Loc(), udas2));\n-    }\n-    return udas;\n-}\n-\n-Expressions *UserAttributeDeclaration::getAttributes()\n-{\n-    if (Scope *sc = _scope)\n-    {\n-        _scope = NULL;\n-        arrayExpressionSemantic(atts, sc);\n-    }\n-\n-    Expressions *exps = new Expressions();\n-    if (userAttribDecl)\n-        exps->push(new TupleExp(Loc(), userAttribDecl->getAttributes()));\n-    if (atts && atts->length)\n-        exps->push(new TupleExp(Loc(), atts));\n-\n-    return exps;\n-}\n-\n-const char *UserAttributeDeclaration::kind() const\n-{\n-    return \"UserAttribute\";\n-}"}, {"sha": "ae8f65b6daa06c2caf3d3cfc6fa405c8d0c77f86", "filename": "gcc/d/dmd/attrib.d", "status": "added", "additions": 1518, "deletions": 0, "changes": 1518, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fattrib.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fattrib.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fattrib.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -0,0 +1,1518 @@\n+/**\n+ * Defines declarations of various attributes.\n+ *\n+ * The term 'attribute' refers to things that can apply to a larger scope than a single declaration.\n+ * Among them are:\n+ * - Alignment (`align(8)`)\n+ * - User defined attributes (`@UDA`)\n+ * - Function Attributes (`@safe`)\n+ * - Storage classes (`static`, `__gshared`)\n+ * - Mixin declarations  (`mixin(\"int x;\")`)\n+ * - Conditional compilation (`static if`, `static foreach`)\n+ * - Linkage (`extern(C)`)\n+ * - Anonymous structs / unions\n+ * - Protection (`private`, `public`)\n+ * - Deprecated declarations (`@deprecated`)\n+ *\n+ * Copyright:   Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n+ * Authors:     $(LINK2 http://www.digitalmars.com, Walter Bright)\n+ * License:     $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+ * Source:      $(LINK2 https://github.com/dlang/dmd/blob/master/src/dmd/attrib.d, _attrib.d)\n+ * Documentation:  https://dlang.org/phobos/dmd_attrib.html\n+ * Coverage:    https://codecov.io/gh/dlang/dmd/src/master/src/dmd/attrib.d\n+ */\n+\n+module dmd.attrib;\n+\n+import dmd.aggregate;\n+import dmd.arraytypes;\n+import dmd.astenums;\n+import dmd.cond;\n+import dmd.declaration;\n+import dmd.dmodule;\n+import dmd.dscope;\n+import dmd.dsymbol;\n+import dmd.dsymbolsem : dsymbolSemantic;\n+import dmd.expression;\n+import dmd.expressionsem;\n+import dmd.func;\n+import dmd.globals;\n+import dmd.hdrgen : visibilityToBuffer;\n+import dmd.id;\n+import dmd.identifier;\n+import dmd.mtype;\n+import dmd.objc; // for objc.addSymbols\n+import dmd.root.outbuffer;\n+import dmd.target; // for target.systemLinkage\n+import dmd.tokens;\n+import dmd.visitor;\n+\n+/***********************************************************\n+ * Abstract attribute applied to Dsymbol's used as a common\n+ * ancestor for storage classes (StorageClassDeclaration),\n+ * linkage (LinkageDeclaration) and others.\n+ */\n+extern (C++) abstract class AttribDeclaration : Dsymbol\n+{\n+    Dsymbols* decl;     /// Dsymbol's affected by this AttribDeclaration\n+\n+    extern (D) this(Dsymbols* decl)\n+    {\n+        this.decl = decl;\n+    }\n+\n+    extern (D) this(const ref Loc loc, Identifier ident, Dsymbols* decl)\n+    {\n+        super(loc, ident);\n+        this.decl = decl;\n+    }\n+\n+    Dsymbols* include(Scope* sc)\n+    {\n+        if (errors)\n+            return null;\n+\n+        return decl;\n+    }\n+\n+    /****************************************\n+     * Create a new scope if one or more given attributes\n+     * are different from the sc's.\n+     * If the returned scope != sc, the caller should pop\n+     * the scope after it used.\n+     */\n+    extern (D) static Scope* createNewScope(Scope* sc, StorageClass stc, LINK linkage,\n+        CPPMANGLE cppmangle, Visibility visibility, int explicitVisibility,\n+        AlignDeclaration aligndecl, PragmaDeclaration inlining)\n+    {\n+        Scope* sc2 = sc;\n+        if (stc != sc.stc ||\n+            linkage != sc.linkage ||\n+            cppmangle != sc.cppmangle ||\n+            explicitVisibility != sc.explicitVisibility ||\n+            visibility != sc.visibility ||\n+            aligndecl !is sc.aligndecl ||\n+            inlining != sc.inlining)\n+        {\n+            // create new one for changes\n+            sc2 = sc.copy();\n+            sc2.stc = stc;\n+            sc2.linkage = linkage;\n+            sc2.cppmangle = cppmangle;\n+            sc2.visibility = visibility;\n+            sc2.explicitVisibility = explicitVisibility;\n+            sc2.aligndecl = aligndecl;\n+            sc2.inlining = inlining;\n+        }\n+        return sc2;\n+    }\n+\n+    /****************************************\n+     * A hook point to supply scope for members.\n+     * addMember, setScope, importAll, semantic, semantic2 and semantic3 will use this.\n+     */\n+    Scope* newScope(Scope* sc)\n+    {\n+        return sc;\n+    }\n+\n+    override void addMember(Scope* sc, ScopeDsymbol sds)\n+    {\n+        Dsymbols* d = include(sc);\n+        if (d)\n+        {\n+            Scope* sc2 = newScope(sc);\n+            d.foreachDsymbol( s => s.addMember(sc2, sds) );\n+            if (sc2 != sc)\n+                sc2.pop();\n+        }\n+    }\n+\n+    override void setScope(Scope* sc)\n+    {\n+        Dsymbols* d = include(sc);\n+        //printf(\"\\tAttribDeclaration::setScope '%s', d = %p\\n\",toChars(), d);\n+        if (d)\n+        {\n+            Scope* sc2 = newScope(sc);\n+            d.foreachDsymbol( s => s.setScope(sc2) );\n+            if (sc2 != sc)\n+                sc2.pop();\n+        }\n+    }\n+\n+    override void importAll(Scope* sc)\n+    {\n+        Dsymbols* d = include(sc);\n+        //printf(\"\\tAttribDeclaration::importAll '%s', d = %p\\n\", toChars(), d);\n+        if (d)\n+        {\n+            Scope* sc2 = newScope(sc);\n+            d.foreachDsymbol( s => s.importAll(sc2) );\n+            if (sc2 != sc)\n+                sc2.pop();\n+        }\n+    }\n+\n+    override void addComment(const(char)* comment)\n+    {\n+        //printf(\"AttribDeclaration::addComment %s\\n\", comment);\n+        if (comment)\n+        {\n+            include(null).foreachDsymbol( s => s.addComment(comment) );\n+        }\n+    }\n+\n+    override const(char)* kind() const\n+    {\n+        return \"attribute\";\n+    }\n+\n+    override bool oneMember(Dsymbol* ps, Identifier ident)\n+    {\n+        Dsymbols* d = include(null);\n+        return Dsymbol.oneMembers(d, ps, ident);\n+    }\n+\n+    override void setFieldOffset(AggregateDeclaration ad, ref FieldState fieldState, bool isunion)\n+    {\n+        include(null).foreachDsymbol( s => s.setFieldOffset(ad, fieldState, isunion) );\n+    }\n+\n+    override final bool hasPointers()\n+    {\n+        return include(null).foreachDsymbol( (s) { return s.hasPointers(); } ) != 0;\n+    }\n+\n+    override final bool hasStaticCtorOrDtor()\n+    {\n+        return include(null).foreachDsymbol( (s) { return s.hasStaticCtorOrDtor(); } ) != 0;\n+    }\n+\n+    override final void checkCtorConstInit()\n+    {\n+        include(null).foreachDsymbol( s => s.checkCtorConstInit() );\n+    }\n+\n+    /****************************************\n+     */\n+    override final void addLocalClass(ClassDeclarations* aclasses)\n+    {\n+        include(null).foreachDsymbol( s => s.addLocalClass(aclasses) );\n+    }\n+\n+    override final void addObjcSymbols(ClassDeclarations* classes, ClassDeclarations* categories)\n+    {\n+        objc.addSymbols(this, classes, categories);\n+    }\n+\n+    override final inout(AttribDeclaration) isAttribDeclaration() inout pure @safe\n+    {\n+        return this;\n+    }\n+\n+    override void accept(Visitor v)\n+    {\n+        v.visit(this);\n+    }\n+}\n+\n+/***********************************************************\n+ * Storage classes applied to Dsymbols, e.g. `const int i;`\n+ *\n+ * <stc> <decl...>\n+ */\n+extern (C++) class StorageClassDeclaration : AttribDeclaration\n+{\n+    StorageClass stc;\n+\n+    extern (D) this(StorageClass stc, Dsymbols* decl)\n+    {\n+        super(decl);\n+        this.stc = stc;\n+    }\n+\n+    override StorageClassDeclaration syntaxCopy(Dsymbol s)\n+    {\n+        assert(!s);\n+        return new StorageClassDeclaration(stc, Dsymbol.arraySyntaxCopy(decl));\n+    }\n+\n+    override Scope* newScope(Scope* sc)\n+    {\n+        StorageClass scstc = sc.stc;\n+        /* These sets of storage classes are mutually exclusive,\n+         * so choose the innermost or most recent one.\n+         */\n+        if (stc & (STC.auto_ | STC.scope_ | STC.static_ | STC.extern_ | STC.manifest))\n+            scstc &= ~(STC.auto_ | STC.scope_ | STC.static_ | STC.extern_ | STC.manifest);\n+        if (stc & (STC.auto_ | STC.scope_ | STC.static_ | STC.tls | STC.manifest | STC.gshared))\n+            scstc &= ~(STC.auto_ | STC.scope_ | STC.static_ | STC.tls | STC.manifest | STC.gshared);\n+        if (stc & (STC.const_ | STC.immutable_ | STC.manifest))\n+            scstc &= ~(STC.const_ | STC.immutable_ | STC.manifest);\n+        if (stc & (STC.gshared | STC.shared_ | STC.tls))\n+            scstc &= ~(STC.gshared | STC.shared_ | STC.tls);\n+        if (stc & (STC.safe | STC.trusted | STC.system))\n+            scstc &= ~(STC.safe | STC.trusted | STC.system);\n+        scstc |= stc;\n+        //printf(\"scstc = x%llx\\n\", scstc);\n+        return createNewScope(sc, scstc, sc.linkage, sc.cppmangle,\n+            sc.visibility, sc.explicitVisibility, sc.aligndecl, sc.inlining);\n+    }\n+\n+    override final bool oneMember(Dsymbol* ps, Identifier ident)\n+    {\n+        bool t = Dsymbol.oneMembers(decl, ps, ident);\n+        if (t && *ps)\n+        {\n+            /* This is to deal with the following case:\n+             * struct Tick {\n+             *   template to(T) { const T to() { ... } }\n+             * }\n+             * For eponymous function templates, the 'const' needs to get attached to 'to'\n+             * before the semantic analysis of 'to', so that template overloading based on the\n+             * 'this' pointer can be successful.\n+             */\n+            FuncDeclaration fd = (*ps).isFuncDeclaration();\n+            if (fd)\n+            {\n+                /* Use storage_class2 instead of storage_class otherwise when we do .di generation\n+                 * we'll wind up with 'const const' rather than 'const'.\n+                 */\n+                /* Don't think we need to worry about mutually exclusive storage classes here\n+                 */\n+                fd.storage_class2 |= stc;\n+            }\n+        }\n+        return t;\n+    }\n+\n+    override void addMember(Scope* sc, ScopeDsymbol sds)\n+    {\n+        Dsymbols* d = include(sc);\n+        if (d)\n+        {\n+            Scope* sc2 = newScope(sc);\n+\n+            d.foreachDsymbol( (s)\n+            {\n+                //printf(\"\\taddMember %s to %s\\n\", s.toChars(), sds.toChars());\n+                // STC.local needs to be attached before the member is added to the scope (because it influences the parent symbol)\n+                if (auto decl = s.isDeclaration())\n+                {\n+                    decl.storage_class |= stc & STC.local;\n+                    if (auto sdecl = s.isStorageClassDeclaration()) // TODO: why is this not enough to deal with the nested case?\n+                    {\n+                        sdecl.stc |= stc & STC.local;\n+                    }\n+                }\n+                s.addMember(sc2, sds);\n+            });\n+\n+            if (sc2 != sc)\n+                sc2.pop();\n+        }\n+\n+    }\n+\n+    override inout(StorageClassDeclaration) isStorageClassDeclaration() inout\n+    {\n+        return this;\n+    }\n+\n+    override void accept(Visitor v)\n+    {\n+        v.visit(this);\n+    }\n+}\n+\n+/***********************************************************\n+ * Deprecation with an additional message applied to Dsymbols,\n+ * e.g. `deprecated(\"Superseeded by foo\") int bar;`.\n+ * (Note that `deprecated int bar;` is currently represented as a\n+ * StorageClassDeclaration with STC.deprecated_)\n+ *\n+ * `deprecated(<msg>) <decl...>`\n+ */\n+extern (C++) final class DeprecatedDeclaration : StorageClassDeclaration\n+{\n+    Expression msg;         /// deprecation message\n+    const(char)* msgstr;    /// cached string representation of msg\n+\n+    extern (D) this(Expression msg, Dsymbols* decl)\n+    {\n+        super(STC.deprecated_, decl);\n+        this.msg = msg;\n+    }\n+\n+    override DeprecatedDeclaration syntaxCopy(Dsymbol s)\n+    {\n+        assert(!s);\n+        return new DeprecatedDeclaration(msg.syntaxCopy(), Dsymbol.arraySyntaxCopy(decl));\n+    }\n+\n+    /**\n+     * Provides a new scope with `STC.deprecated_` and `Scope.depdecl` set\n+     *\n+     * Calls `StorageClassDeclaration.newScope` (as it must be called or copied\n+     * in any function overriding `newScope`), then set the `Scope`'s depdecl.\n+     *\n+     * Returns:\n+     *   Always a new scope, to use for this `DeprecatedDeclaration`'s members.\n+     */\n+    override Scope* newScope(Scope* sc)\n+    {\n+        auto scx = super.newScope(sc);\n+        // The enclosing scope is deprecated as well\n+        if (scx == sc)\n+            scx = sc.push();\n+        scx.depdecl = this;\n+        return scx;\n+    }\n+\n+    override void setScope(Scope* sc)\n+    {\n+        //printf(\"DeprecatedDeclaration::setScope() %p\\n\", this);\n+        if (decl)\n+            Dsymbol.setScope(sc); // for forward reference\n+        return AttribDeclaration.setScope(sc);\n+    }\n+\n+    override void accept(Visitor v)\n+    {\n+        v.visit(this);\n+    }\n+}\n+\n+/***********************************************************\n+ * Linkage attribute applied to Dsymbols, e.g.\n+ * `extern(C) void foo()`.\n+ *\n+ * `extern(<linkage>) <decl...>`\n+ */\n+extern (C++) final class LinkDeclaration : AttribDeclaration\n+{\n+    LINK linkage; /// either explicitly set or `default_`\n+\n+    extern (D) this(const ref Loc loc, LINK linkage, Dsymbols* decl)\n+    {\n+        super(loc, null, decl);\n+        //printf(\"LinkDeclaration(linkage = %d, decl = %p)\\n\", linkage, decl);\n+        this.linkage = (linkage == LINK.system) ? target.systemLinkage() : linkage;\n+    }\n+\n+    static LinkDeclaration create(const ref Loc loc, LINK p, Dsymbols* decl)\n+    {\n+        return new LinkDeclaration(loc, p, decl);\n+    }\n+\n+    override LinkDeclaration syntaxCopy(Dsymbol s)\n+    {\n+        assert(!s);\n+        return new LinkDeclaration(loc, linkage, Dsymbol.arraySyntaxCopy(decl));\n+    }\n+\n+    override Scope* newScope(Scope* sc)\n+    {\n+        return createNewScope(sc, sc.stc, this.linkage, sc.cppmangle, sc.visibility, sc.explicitVisibility,\n+            sc.aligndecl, sc.inlining);\n+    }\n+\n+    override const(char)* toChars() const\n+    {\n+        return toString().ptr;\n+    }\n+\n+    extern(D) override const(char)[] toString() const\n+    {\n+        return \"extern ()\";\n+    }\n+\n+    override void accept(Visitor v)\n+    {\n+        v.visit(this);\n+    }\n+}\n+\n+/***********************************************************\n+ * Attribute declaring whether an external aggregate should be mangled as\n+ * a struct or class in C++, e.g. `extern(C++, struct) class C { ... }`.\n+ * This is required for correct name mangling on MSVC targets,\n+ * see cppmanglewin.d for details.\n+ *\n+ * `extern(C++, <cppmangle>) <decl...>`\n+ */\n+extern (C++) final class CPPMangleDeclaration : AttribDeclaration\n+{\n+    CPPMANGLE cppmangle;\n+\n+    extern (D) this(const ref Loc loc, CPPMANGLE cppmangle, Dsymbols* decl)\n+    {\n+        super(loc, null, decl);\n+        //printf(\"CPPMangleDeclaration(cppmangle = %d, decl = %p)\\n\", cppmangle, decl);\n+        this.cppmangle = cppmangle;\n+    }\n+\n+    override CPPMangleDeclaration syntaxCopy(Dsymbol s)\n+    {\n+        assert(!s);\n+        return new CPPMangleDeclaration(loc, cppmangle, Dsymbol.arraySyntaxCopy(decl));\n+    }\n+\n+    override Scope* newScope(Scope* sc)\n+    {\n+        return createNewScope(sc, sc.stc, LINK.cpp, cppmangle, sc.visibility, sc.explicitVisibility,\n+            sc.aligndecl, sc.inlining);\n+    }\n+\n+    override void setScope(Scope* sc)\n+    {\n+        if (decl)\n+            Dsymbol.setScope(sc); // for forward reference\n+        return AttribDeclaration.setScope(sc);\n+    }\n+\n+    override const(char)* toChars() const\n+    {\n+        return toString().ptr;\n+    }\n+\n+    extern(D) override const(char)[] toString() const\n+    {\n+        return \"extern ()\";\n+    }\n+\n+    override void accept(Visitor v)\n+    {\n+        v.visit(this);\n+    }\n+}\n+\n+/**\n+ * A node to represent an `extern(C++)` namespace attribute\n+ *\n+ * There are two ways to declarate a symbol as member of a namespace:\n+ * `Nspace` and `CPPNamespaceDeclaration`.\n+ * The former creates a scope for the symbol, and inject them in the\n+ * parent scope at the same time.\n+ * The later, this class, has no semantic implications and is only\n+ * used for mangling.\n+ * Additionally, this class allows one to use reserved identifiers\n+ * (D keywords) in the namespace.\n+ *\n+ * A `CPPNamespaceDeclaration` can be created from an `Identifier`\n+ * (already resolved) or from an `Expression`, which is CTFE-ed\n+ * and can be either a `TupleExp`, in which can additional\n+ * `CPPNamespaceDeclaration` nodes are created, or a `StringExp`.\n+ *\n+ * Note that this class, like `Nspace`, matches only one identifier\n+ * part of a namespace. For the namespace `\"foo::bar\"`,\n+ * the will be a `CPPNamespaceDeclaration` with its `ident`\n+ * set to `\"bar\"`, and its `namespace` field pointing to another\n+ * `CPPNamespaceDeclaration` with its `ident` set to `\"foo\"`.\n+ */\n+extern (C++) final class CPPNamespaceDeclaration : AttribDeclaration\n+{\n+    /// CTFE-able expression, resolving to `TupleExp` or `StringExp`\n+    Expression exp;\n+\n+    extern (D) this(const ref Loc loc, Identifier ident, Dsymbols* decl)\n+    {\n+        super(loc, ident, decl);\n+    }\n+\n+    extern (D) this(const ref Loc loc, Expression exp, Dsymbols* decl)\n+    {\n+        super(loc, null, decl);\n+        this.exp = exp;\n+    }\n+\n+    extern (D) this(const ref Loc loc, Identifier ident, Expression exp, Dsymbols* decl,\n+                    CPPNamespaceDeclaration parent)\n+    {\n+        super(loc, ident, decl);\n+        this.exp = exp;\n+        this.cppnamespace = parent;\n+    }\n+\n+    override CPPNamespaceDeclaration syntaxCopy(Dsymbol s)\n+    {\n+        assert(!s);\n+        return new CPPNamespaceDeclaration(\n+            this.loc, this.ident, this.exp, Dsymbol.arraySyntaxCopy(this.decl), this.cppnamespace);\n+    }\n+\n+    /**\n+     * Returns:\n+     *   A copy of the parent scope, with `this` as `namespace` and C++ linkage\n+     */\n+    override Scope* newScope(Scope* sc)\n+    {\n+        auto scx = sc.copy();\n+        scx.linkage = LINK.cpp;\n+        scx.namespace = this;\n+        return scx;\n+    }\n+\n+    override const(char)* toChars() const\n+    {\n+        return toString().ptr;\n+    }\n+\n+    extern(D) override const(char)[] toString() const\n+    {\n+        return \"extern (C++, `namespace`)\";\n+    }\n+\n+    override void accept(Visitor v)\n+    {\n+        v.visit(this);\n+    }\n+\n+    override inout(CPPNamespaceDeclaration) isCPPNamespaceDeclaration() inout { return this; }\n+}\n+\n+/***********************************************************\n+ * Visibility declaration for Dsymbols, e.g. `public int i;`\n+ *\n+ * `<visibility> <decl...>` or\n+ * `package(<pkg_identifiers>) <decl...>` if `pkg_identifiers !is null`\n+ */\n+extern (C++) final class VisibilityDeclaration : AttribDeclaration\n+{\n+    Visibility visibility;          /// the visibility\n+    Identifier[] pkg_identifiers;   /// identifiers for `package(foo.bar)` or null\n+\n+    /**\n+     * Params:\n+     *  loc = source location of attribute token\n+     *  visibility = visibility attribute data\n+     *  decl = declarations which are affected by this visibility attribute\n+     */\n+    extern (D) this(const ref Loc loc, Visibility visibility, Dsymbols* decl)\n+    {\n+        super(loc, null, decl);\n+        this.visibility = visibility;\n+        //printf(\"decl = %p\\n\", decl);\n+    }\n+\n+    /**\n+     * Params:\n+     *  loc = source location of attribute token\n+     *  pkg_identifiers = list of identifiers for a qualified package name\n+     *  decl = declarations which are affected by this visibility attribute\n+     */\n+    extern (D) this(const ref Loc loc, Identifier[] pkg_identifiers, Dsymbols* decl)\n+    {\n+        super(loc, null, decl);\n+        this.visibility.kind = Visibility.Kind.package_;\n+        this.pkg_identifiers = pkg_identifiers;\n+        if (pkg_identifiers.length > 0)\n+        {\n+            Dsymbol tmp;\n+            Package.resolve(pkg_identifiers, &tmp, null);\n+            visibility.pkg = tmp ? tmp.isPackage() : null;\n+        }\n+    }\n+\n+    override VisibilityDeclaration syntaxCopy(Dsymbol s)\n+    {\n+        assert(!s);\n+\n+        if (visibility.kind == Visibility.Kind.package_)\n+            return new VisibilityDeclaration(this.loc, pkg_identifiers, Dsymbol.arraySyntaxCopy(decl));\n+        else\n+            return new VisibilityDeclaration(this.loc, visibility, Dsymbol.arraySyntaxCopy(decl));\n+    }\n+\n+    override Scope* newScope(Scope* sc)\n+    {\n+        if (pkg_identifiers)\n+            dsymbolSemantic(this, sc);\n+        return createNewScope(sc, sc.stc, sc.linkage, sc.cppmangle, this.visibility, 1, sc.aligndecl, sc.inlining);\n+    }\n+\n+    override void addMember(Scope* sc, ScopeDsymbol sds)\n+    {\n+        if (pkg_identifiers)\n+        {\n+            Dsymbol tmp;\n+            Package.resolve(pkg_identifiers, &tmp, null);\n+            visibility.pkg = tmp ? tmp.isPackage() : null;\n+            pkg_identifiers = null;\n+        }\n+        if (visibility.kind == Visibility.Kind.package_ && visibility.pkg && sc._module)\n+        {\n+            Module m = sc._module;\n+\n+            // While isAncestorPackageOf does an equality check, the fix for issue 17441 adds a check to see if\n+            // each package's .isModule() properites are equal.\n+            //\n+            // Properties generated from `package(foo)` i.e. visibility.pkg have .isModule() == null.\n+            // This breaks package declarations of the package in question if they are declared in\n+            // the same package.d file, which _do_ have a module associated with them, and hence a non-null\n+            // isModule()\n+            if (!m.isPackage() || !visibility.pkg.ident.equals(m.isPackage().ident))\n+            {\n+                Package pkg = m.parent ? m.parent.isPackage() : null;\n+                if (!pkg || !visibility.pkg.isAncestorPackageOf(pkg))\n+                    error(\"does not bind to one of ancestor packages of module `%s`\", m.toPrettyChars(true));\n+            }\n+        }\n+        return AttribDeclaration.addMember(sc, sds);\n+    }\n+\n+    override const(char)* kind() const\n+    {\n+        return \"visibility attribute\";\n+    }\n+\n+    override const(char)* toPrettyChars(bool)\n+    {\n+        assert(visibility.kind > Visibility.Kind.undefined);\n+        OutBuffer buf;\n+        visibilityToBuffer(&buf, visibility);\n+        return buf.extractChars();\n+    }\n+\n+    override inout(VisibilityDeclaration) isVisibilityDeclaration() inout\n+    {\n+        return this;\n+    }\n+\n+    override void accept(Visitor v)\n+    {\n+        v.visit(this);\n+    }\n+}\n+\n+/***********************************************************\n+ * Alignment attribute for aggregates, members and variables.\n+ *\n+ * `align(<ealign>) <decl...>` or\n+ * `align <decl...>` if `ealign` is null\n+ */\n+extern (C++) final class AlignDeclaration : AttribDeclaration\n+{\n+    Expressions* exps;                              /// Expression(s) yielding the desired alignment,\n+                                                    /// the largest value wins\n+    enum structalign_t UNKNOWN = 0;                 /// alignment not yet computed\n+    static assert(STRUCTALIGN_DEFAULT != UNKNOWN);\n+\n+    /// the actual alignment, `UNKNOWN` until it's either set to the value of `ealign`\n+    /// or `STRUCTALIGN_DEFAULT` if `ealign` is null ( / an error ocurred)\n+    structalign_t salign = UNKNOWN;\n+\n+\n+    extern (D) this(const ref Loc loc, Expression exp, Dsymbols* decl)\n+    {\n+        super(loc, null, decl);\n+        if (exp)\n+        {\n+            if (!exps)\n+                exps = new Expressions();\n+            exps.push(exp);\n+        }\n+    }\n+\n+    extern (D) this(const ref Loc loc, Expressions* exps, Dsymbols* decl)\n+    {\n+        super(loc, null, decl);\n+        this.exps = exps;\n+    }\n+\n+    override AlignDeclaration syntaxCopy(Dsymbol s)\n+    {\n+        assert(!s);\n+        return new AlignDeclaration(loc,\n+            Expression.arraySyntaxCopy(exps),\n+            Dsymbol.arraySyntaxCopy(decl));\n+    }\n+\n+    override Scope* newScope(Scope* sc)\n+    {\n+        return createNewScope(sc, sc.stc, sc.linkage, sc.cppmangle, sc.visibility, sc.explicitVisibility, this, sc.inlining);\n+    }\n+\n+    override void accept(Visitor v)\n+    {\n+        v.visit(this);\n+    }\n+}\n+\n+/***********************************************************\n+ * An anonymous struct/union (defined by `isunion`).\n+ */\n+extern (C++) final class AnonDeclaration : AttribDeclaration\n+{\n+    bool isunion;           /// whether it's a union\n+    int sem;                /// 1 if successful semantic()\n+    uint anonoffset;        /// offset of anonymous struct\n+    uint anonstructsize;    /// size of anonymous struct\n+    uint anonalignsize;     /// size of anonymous struct for alignment purposes\n+\n+    extern (D) this(const ref Loc loc, bool isunion, Dsymbols* decl)\n+    {\n+        super(loc, null, decl);\n+        this.isunion = isunion;\n+    }\n+\n+    override AnonDeclaration syntaxCopy(Dsymbol s)\n+    {\n+        assert(!s);\n+        return new AnonDeclaration(loc, isunion, Dsymbol.arraySyntaxCopy(decl));\n+    }\n+\n+    override void setScope(Scope* sc)\n+    {\n+        if (decl)\n+            Dsymbol.setScope(sc);\n+        return AttribDeclaration.setScope(sc);\n+    }\n+\n+    override void setFieldOffset(AggregateDeclaration ad, ref FieldState fieldState, bool isunion)\n+    {\n+        //printf(\"\\tAnonDeclaration::setFieldOffset %s %p\\n\", isunion ? \"union\" : \"struct\", this);\n+        if (decl)\n+        {\n+            /* This works by treating an AnonDeclaration as an aggregate 'member',\n+             * so in order to place that member we need to compute the member's\n+             * size and alignment.\n+             */\n+            size_t fieldstart = ad.fields.dim;\n+\n+            /* Hackishly hijack ad's structsize and alignsize fields\n+             * for use in our fake anon aggregate member.\n+             */\n+            uint savestructsize = ad.structsize;\n+            uint savealignsize = ad.alignsize;\n+            ad.structsize = 0;\n+            ad.alignsize = 0;\n+\n+            FieldState fs;\n+            decl.foreachDsymbol( (s)\n+            {\n+                s.setFieldOffset(ad, fs, this.isunion);\n+                if (this.isunion)\n+                    fs.offset = 0;\n+            });\n+\n+            /* https://issues.dlang.org/show_bug.cgi?id=13613\n+             * If the fields in this.members had been already\n+             * added in ad.fields, just update *poffset for the subsequent\n+             * field offset calculation.\n+             */\n+            if (fieldstart == ad.fields.dim)\n+            {\n+                ad.structsize = savestructsize;\n+                ad.alignsize = savealignsize;\n+                fieldState.offset = ad.structsize;\n+                return;\n+            }\n+\n+            anonstructsize = ad.structsize;\n+            anonalignsize = ad.alignsize;\n+            ad.structsize = savestructsize;\n+            ad.alignsize = savealignsize;\n+\n+            // 0 sized structs are set to 1 byte\n+            if (anonstructsize == 0)\n+            {\n+                anonstructsize = 1;\n+                anonalignsize = 1;\n+            }\n+\n+            assert(_scope);\n+            auto alignment = _scope.alignment();\n+\n+            /* Given the anon 'member's size and alignment,\n+             * go ahead and place it.\n+             */\n+            anonoffset = AggregateDeclaration.placeField(\n+                &fieldState.offset,\n+                anonstructsize, anonalignsize, alignment,\n+                &ad.structsize, &ad.alignsize,\n+                isunion);\n+\n+            // Add to the anon fields the base offset of this anonymous aggregate\n+            //printf(\"anon fields, anonoffset = %d\\n\", anonoffset);\n+            foreach (const i; fieldstart .. ad.fields.dim)\n+            {\n+                VarDeclaration v = ad.fields[i];\n+                //printf(\"\\t[%d] %s %d\\n\", i, v.toChars(), v.offset);\n+                v.offset += anonoffset;\n+            }\n+        }\n+    }\n+\n+    override const(char)* kind() const\n+    {\n+        return (isunion ? \"anonymous union\" : \"anonymous struct\");\n+    }\n+\n+    override inout(AnonDeclaration) isAnonDeclaration() inout\n+    {\n+        return this;\n+    }\n+\n+    override void accept(Visitor v)\n+    {\n+        v.visit(this);\n+    }\n+}\n+\n+/***********************************************************\n+ * Pragma applied to Dsymbols, e.g. `pragma(inline, true) void foo`,\n+ * but not PragmaStatement's like `pragma(msg, \"hello\");`.\n+ *\n+ * pragma(<ident>, <args>)\n+ */\n+extern (C++) final class PragmaDeclaration : AttribDeclaration\n+{\n+    Expressions* args;      /// parameters of this pragma\n+\n+    extern (D) this(const ref Loc loc, Identifier ident, Expressions* args, Dsymbols* decl)\n+    {\n+        super(loc, ident, decl);\n+        this.args = args;\n+    }\n+\n+    override PragmaDeclaration syntaxCopy(Dsymbol s)\n+    {\n+        //printf(\"PragmaDeclaration::syntaxCopy(%s)\\n\", toChars());\n+        assert(!s);\n+        return new PragmaDeclaration(loc, ident, Expression.arraySyntaxCopy(args), Dsymbol.arraySyntaxCopy(decl));\n+    }\n+\n+    override Scope* newScope(Scope* sc)\n+    {\n+        if (ident == Id.Pinline)\n+        {\n+            // We keep track of this pragma inside scopes,\n+            // then it's evaluated on demand in function semantic\n+            return createNewScope(sc, sc.stc, sc.linkage, sc.cppmangle, sc.visibility, sc.explicitVisibility, sc.aligndecl, this);\n+        }\n+        if (ident == Id.printf || ident == Id.scanf)\n+        {\n+            auto sc2 = sc.push();\n+\n+            if (ident == Id.printf)\n+                // Override previous setting, never let both be set\n+                sc2.flags = (sc2.flags & ~SCOPE.scanf) | SCOPE.printf;\n+            else\n+                sc2.flags = (sc2.flags & ~SCOPE.printf) | SCOPE.scanf;\n+\n+            return sc2;\n+        }\n+        return sc;\n+    }\n+\n+    PINLINE evalPragmaInline(Scope* sc)\n+    {\n+        if (!args || args.dim == 0)\n+            return PINLINE.default_;\n+\n+        Expression e = (*args)[0];\n+        if (!e.type)\n+        {\n+\n+            sc = sc.startCTFE();\n+            e = e.expressionSemantic(sc);\n+            e = resolveProperties(sc, e);\n+            sc = sc.endCTFE();\n+            e = e.ctfeInterpret();\n+            e = e.toBoolean(sc);\n+            if (e.isErrorExp())\n+                error(\"pragma(`inline`, `true` or `false`) expected, not `%s`\", (*args)[0].toChars());\n+            (*args)[0] = e;\n+        }\n+\n+        if (e.isBool(true))\n+            return PINLINE.always;\n+        else if (e.isBool(false))\n+            return PINLINE.never;\n+        else\n+            return PINLINE.default_;\n+    }\n+\n+    override const(char)* kind() const\n+    {\n+        return \"pragma\";\n+    }\n+\n+    override void accept(Visitor v)\n+    {\n+        v.visit(this);\n+    }\n+}\n+\n+/***********************************************************\n+ * A conditional compilation declaration, used for `version`\n+ * / `debug` and specialized for `static if`.\n+ *\n+ * <condition> { <decl...> } else { <elsedecl> }\n+ */\n+extern (C++) class ConditionalDeclaration : AttribDeclaration\n+{\n+    Condition condition;    /// condition deciding whether decl or elsedecl applies\n+    Dsymbols* elsedecl;     /// array of Dsymbol's for else block\n+\n+    extern (D) this(const ref Loc loc, Condition condition, Dsymbols* decl, Dsymbols* elsedecl)\n+    {\n+        super(loc, null, decl);\n+        //printf(\"ConditionalDeclaration::ConditionalDeclaration()\\n\");\n+        this.condition = condition;\n+        this.elsedecl = elsedecl;\n+    }\n+\n+    override ConditionalDeclaration syntaxCopy(Dsymbol s)\n+    {\n+        assert(!s);\n+        return new ConditionalDeclaration(loc, condition.syntaxCopy(), Dsymbol.arraySyntaxCopy(decl), Dsymbol.arraySyntaxCopy(elsedecl));\n+    }\n+\n+    override final bool oneMember(Dsymbol* ps, Identifier ident)\n+    {\n+        //printf(\"ConditionalDeclaration::oneMember(), inc = %d\\n\", condition.inc);\n+        if (condition.inc != Include.notComputed)\n+        {\n+            Dsymbols* d = condition.include(null) ? decl : elsedecl;\n+            return Dsymbol.oneMembers(d, ps, ident);\n+        }\n+        else\n+        {\n+            bool res = (Dsymbol.oneMembers(decl, ps, ident) && *ps is null && Dsymbol.oneMembers(elsedecl, ps, ident) && *ps is null);\n+            *ps = null;\n+            return res;\n+        }\n+    }\n+\n+    // Decide if 'then' or 'else' code should be included\n+    override Dsymbols* include(Scope* sc)\n+    {\n+        //printf(\"ConditionalDeclaration::include(sc = %p) scope = %p\\n\", sc, scope);\n+\n+        if (errors)\n+            return null;\n+\n+        assert(condition);\n+        return condition.include(_scope ? _scope : sc) ? decl : elsedecl;\n+    }\n+\n+    override final void addComment(const(char)* comment)\n+    {\n+        /* Because addComment is called by the parser, if we called\n+         * include() it would define a version before it was used.\n+         * But it's no problem to drill down to both decl and elsedecl,\n+         * so that's the workaround.\n+         */\n+        if (comment)\n+        {\n+            decl    .foreachDsymbol( s => s.addComment(comment) );\n+            elsedecl.foreachDsymbol( s => s.addComment(comment) );\n+        }\n+    }\n+\n+    override void setScope(Scope* sc)\n+    {\n+        include(sc).foreachDsymbol( s => s.setScope(sc) );\n+    }\n+\n+    override void accept(Visitor v)\n+    {\n+        v.visit(this);\n+    }\n+}\n+\n+/***********************************************************\n+ * `<scopesym> {\n+ *      static if (<condition>) { <decl> } else { <elsedecl> }\n+ * }`\n+ */\n+extern (C++) final class StaticIfDeclaration : ConditionalDeclaration\n+{\n+    ScopeDsymbol scopesym;          /// enclosing symbol (e.g. module) where symbols will be inserted\n+    private bool addisdone = false; /// true if members have been added to scope\n+    private bool onStack = false;   /// true if a call to `include` is currently active\n+\n+    extern (D) this(const ref Loc loc, Condition condition, Dsymbols* decl, Dsymbols* elsedecl)\n+    {\n+        super(loc, condition, decl, elsedecl);\n+        //printf(\"StaticIfDeclaration::StaticIfDeclaration()\\n\");\n+    }\n+\n+    override StaticIfDeclaration syntaxCopy(Dsymbol s)\n+    {\n+        assert(!s);\n+        return new StaticIfDeclaration(loc, condition.syntaxCopy(), Dsymbol.arraySyntaxCopy(decl), Dsymbol.arraySyntaxCopy(elsedecl));\n+    }\n+\n+    /****************************************\n+     * Different from other AttribDeclaration subclasses, include() call requires\n+     * the completion of addMember and setScope phases.\n+     */\n+    override Dsymbols* include(Scope* sc)\n+    {\n+        //printf(\"StaticIfDeclaration::include(sc = %p) scope = %p\\n\", sc, scope);\n+\n+        if (errors || onStack)\n+            return null;\n+        onStack = true;\n+        scope(exit) onStack = false;\n+\n+        if (sc && condition.inc == Include.notComputed)\n+        {\n+            assert(scopesym); // addMember is already done\n+            assert(_scope); // setScope is already done\n+            Dsymbols* d = ConditionalDeclaration.include(_scope);\n+            if (d && !addisdone)\n+            {\n+                // Add members lazily.\n+                d.foreachDsymbol( s => s.addMember(_scope, scopesym) );\n+\n+                // Set the member scopes lazily.\n+                d.foreachDsymbol( s => s.setScope(_scope) );\n+\n+                addisdone = true;\n+            }\n+            return d;\n+        }\n+        else\n+        {\n+            return ConditionalDeclaration.include(sc);\n+        }\n+    }\n+\n+    override void addMember(Scope* sc, ScopeDsymbol sds)\n+    {\n+        //printf(\"StaticIfDeclaration::addMember() '%s'\\n\", toChars());\n+        /* This is deferred until the condition evaluated later (by the include() call),\n+         * so that expressions in the condition can refer to declarations\n+         * in the same scope, such as:\n+         *\n+         * template Foo(int i)\n+         * {\n+         *     const int j = i + 1;\n+         *     static if (j == 3)\n+         *         const int k;\n+         * }\n+         */\n+        this.scopesym = sds;\n+    }\n+\n+    override void setScope(Scope* sc)\n+    {\n+        // do not evaluate condition before semantic pass\n+        // But do set the scope, in case we need it for forward referencing\n+        Dsymbol.setScope(sc);\n+    }\n+\n+    override void importAll(Scope* sc)\n+    {\n+        // do not evaluate condition before semantic pass\n+    }\n+\n+    override const(char)* kind() const\n+    {\n+        return \"static if\";\n+    }\n+\n+    override void accept(Visitor v)\n+    {\n+        v.visit(this);\n+    }\n+}\n+\n+/***********************************************************\n+ * Static foreach at declaration scope, like:\n+ *     static foreach (i; [0, 1, 2]){ }\n+ */\n+\n+extern (C++) final class StaticForeachDeclaration : AttribDeclaration\n+{\n+    StaticForeach sfe; /// contains `static foreach` expansion logic\n+\n+    ScopeDsymbol scopesym; /// cached enclosing scope (mimics `static if` declaration)\n+\n+    /++\n+     `include` can be called multiple times, but a `static foreach`\n+     should be expanded at most once.  Achieved by caching the result\n+     of the first call.  We need both `cached` and `cache`, because\n+     `null` is a valid value for `cache`.\n+     +/\n+    bool onStack = false;\n+    bool cached = false;\n+    Dsymbols* cache = null;\n+\n+    extern (D) this(StaticForeach sfe, Dsymbols* decl)\n+    {\n+        super(sfe.loc, null, decl);\n+        this.sfe = sfe;\n+    }\n+\n+    override StaticForeachDeclaration syntaxCopy(Dsymbol s)\n+    {\n+        assert(!s);\n+        return new StaticForeachDeclaration(\n+            sfe.syntaxCopy(),\n+            Dsymbol.arraySyntaxCopy(decl));\n+    }\n+\n+    override bool oneMember(Dsymbol* ps, Identifier ident)\n+    {\n+        // Required to support IFTI on a template that contains a\n+        // `static foreach` declaration.  `super.oneMember` calls\n+        // include with a `null` scope.  As `static foreach` requires\n+        // the scope for expansion, `oneMember` can only return a\n+        // precise result once `static foreach` has been expanded.\n+        if (cached)\n+        {\n+            return super.oneMember(ps, ident);\n+        }\n+        *ps = null; // a `static foreach` declaration may in general expand to multiple symbols\n+        return false;\n+    }\n+\n+    override Dsymbols* include(Scope* sc)\n+    {\n+        if (errors || onStack)\n+            return null;\n+        if (cached)\n+        {\n+            assert(!onStack);\n+            return cache;\n+        }\n+        onStack = true;\n+        scope(exit) onStack = false;\n+\n+        if (_scope)\n+        {\n+            sfe.prepare(_scope); // lower static foreach aggregate\n+        }\n+        if (!sfe.ready())\n+        {\n+            return null; // TODO: ok?\n+        }\n+\n+        // expand static foreach\n+        import dmd.statementsem: makeTupleForeach;\n+        Dsymbols* d = makeTupleForeach!(true,true)(_scope, sfe.aggrfe, decl, sfe.needExpansion);\n+        if (d) // process generated declarations\n+        {\n+            // Add members lazily.\n+            d.foreachDsymbol( s => s.addMember(_scope, scopesym) );\n+\n+            // Set the member scopes lazily.\n+            d.foreachDsymbol( s => s.setScope(_scope) );\n+        }\n+        cached = true;\n+        cache = d;\n+        return d;\n+    }\n+\n+    override void addMember(Scope* sc, ScopeDsymbol sds)\n+    {\n+        // used only for caching the enclosing symbol\n+        this.scopesym = sds;\n+    }\n+\n+    override void addComment(const(char)* comment)\n+    {\n+        // do nothing\n+        // change this to give semantics to documentation comments on static foreach declarations\n+    }\n+\n+    override void setScope(Scope* sc)\n+    {\n+        // do not evaluate condition before semantic pass\n+        // But do set the scope, in case we need it for forward referencing\n+        Dsymbol.setScope(sc);\n+    }\n+\n+    override void importAll(Scope* sc)\n+    {\n+        // do not evaluate aggregate before semantic pass\n+    }\n+\n+    override const(char)* kind() const\n+    {\n+        return \"static foreach\";\n+    }\n+\n+    override void accept(Visitor v)\n+    {\n+        v.visit(this);\n+    }\n+}\n+\n+/***********************************************************\n+ * Collection of declarations that stores foreach index variables in a\n+ * local symbol table.  Other symbols declared within are forwarded to\n+ * another scope, like:\n+ *\n+ *      static foreach (i; 0 .. 10) // loop variables for different indices do not conflict.\n+ *      { // this body is expanded into 10 ForwardingAttribDeclarations, where `i` has storage class STC.local\n+ *          mixin(\"enum x\" ~ to!string(i) ~ \" = i\"); // ok, can access current loop variable\n+ *      }\n+ *\n+ *      static foreach (i; 0.. 10)\n+ *      {\n+ *          pragma(msg, mixin(\"x\" ~ to!string(i))); // ok, all 10 symbols are visible as they were forwarded to the global scope\n+ *      }\n+ *\n+ *      static assert (!is(typeof(i))); // loop index variable is not visible outside of the static foreach loop\n+ *\n+ * A StaticForeachDeclaration generates one\n+ * ForwardingAttribDeclaration for each expansion of its body.  The\n+ * AST of the ForwardingAttribDeclaration contains both the `static\n+ * foreach` variables and the respective copy of the `static foreach`\n+ * body.  The functionality is achieved by using a\n+ * ForwardingScopeDsymbol as the parent symbol for the generated\n+ * declarations.\n+ */\n+\n+extern(C++) final class ForwardingAttribDeclaration: AttribDeclaration\n+{\n+    ForwardingScopeDsymbol sym = null;\n+\n+    this(Dsymbols* decl)\n+    {\n+        super(decl);\n+        sym = new ForwardingScopeDsymbol(null);\n+        sym.symtab = new DsymbolTable();\n+    }\n+\n+    /**************************************\n+     * Use the ForwardingScopeDsymbol as the parent symbol for members.\n+     */\n+    override Scope* newScope(Scope* sc)\n+    {\n+        return sc.push(sym);\n+    }\n+\n+    /***************************************\n+     * Lazily initializes the scope to forward to.\n+     */\n+    override void addMember(Scope* sc, ScopeDsymbol sds)\n+    {\n+        parent = sym.parent = sym.forward = sds;\n+        return super.addMember(sc, sym);\n+    }\n+\n+    override inout(ForwardingAttribDeclaration) isForwardingAttribDeclaration() inout\n+    {\n+        return this;\n+    }\n+\n+    override void accept(Visitor v)\n+    {\n+        v.visit(this);\n+    }\n+}\n+\n+\n+/***********************************************************\n+ * Mixin declarations, like:\n+ *      mixin(\"int x\");\n+ * https://dlang.org/spec/module.html#mixin-declaration\n+ */\n+extern (C++) final class CompileDeclaration : AttribDeclaration\n+{\n+    Expressions* exps;\n+    ScopeDsymbol scopesym;\n+    bool compiled;\n+\n+    extern (D) this(const ref Loc loc, Expressions* exps)\n+    {\n+        super(loc, null, null);\n+        //printf(\"CompileDeclaration(loc = %d)\\n\", loc.linnum);\n+        this.exps = exps;\n+    }\n+\n+    override CompileDeclaration syntaxCopy(Dsymbol s)\n+    {\n+        //printf(\"CompileDeclaration::syntaxCopy('%s')\\n\", toChars());\n+        return new CompileDeclaration(loc, Expression.arraySyntaxCopy(exps));\n+    }\n+\n+    override void addMember(Scope* sc, ScopeDsymbol sds)\n+    {\n+        //printf(\"CompileDeclaration::addMember(sc = %p, sds = %p, memnum = %d)\\n\", sc, sds, memnum);\n+        this.scopesym = sds;\n+    }\n+\n+    override void setScope(Scope* sc)\n+    {\n+        Dsymbol.setScope(sc);\n+    }\n+\n+    override const(char)* kind() const\n+    {\n+        return \"mixin\";\n+    }\n+\n+    override inout(CompileDeclaration) isCompileDeclaration() inout\n+    {\n+        return this;\n+    }\n+\n+    override void accept(Visitor v)\n+    {\n+        v.visit(this);\n+    }\n+}\n+\n+/***********************************************************\n+ * User defined attributes look like:\n+ *      @foo(args, ...)\n+ *      @(args, ...)\n+ */\n+extern (C++) final class UserAttributeDeclaration : AttribDeclaration\n+{\n+    Expressions* atts;\n+\n+    extern (D) this(Expressions* atts, Dsymbols* decl)\n+    {\n+        super(decl);\n+        this.atts = atts;\n+    }\n+\n+    override UserAttributeDeclaration syntaxCopy(Dsymbol s)\n+    {\n+        //printf(\"UserAttributeDeclaration::syntaxCopy('%s')\\n\", toChars());\n+        assert(!s);\n+        return new UserAttributeDeclaration(Expression.arraySyntaxCopy(this.atts), Dsymbol.arraySyntaxCopy(decl));\n+    }\n+\n+    override Scope* newScope(Scope* sc)\n+    {\n+        Scope* sc2 = sc;\n+        if (atts && atts.dim)\n+        {\n+            // create new one for changes\n+            sc2 = sc.copy();\n+            sc2.userAttribDecl = this;\n+        }\n+        return sc2;\n+    }\n+\n+    override void setScope(Scope* sc)\n+    {\n+        //printf(\"UserAttributeDeclaration::setScope() %p\\n\", this);\n+        if (decl)\n+            Dsymbol.setScope(sc); // for forward reference of UDAs\n+        return AttribDeclaration.setScope(sc);\n+    }\n+\n+    extern (D) static Expressions* concat(Expressions* udas1, Expressions* udas2)\n+    {\n+        Expressions* udas;\n+        if (!udas1 || udas1.dim == 0)\n+            udas = udas2;\n+        else if (!udas2 || udas2.dim == 0)\n+            udas = udas1;\n+        else\n+        {\n+            /* Create a new tuple that combines them\n+             * (do not append to left operand, as this is a copy-on-write operation)\n+             */\n+            udas = new Expressions(2);\n+            (*udas)[0] = new TupleExp(Loc.initial, udas1);\n+            (*udas)[1] = new TupleExp(Loc.initial, udas2);\n+        }\n+        return udas;\n+    }\n+\n+    Expressions* getAttributes()\n+    {\n+        if (auto sc = _scope)\n+        {\n+            _scope = null;\n+            arrayExpressionSemantic(atts, sc);\n+        }\n+        auto exps = new Expressions();\n+        if (userAttribDecl && userAttribDecl !is this)\n+            exps.push(new TupleExp(Loc.initial, userAttribDecl.getAttributes()));\n+        if (atts && atts.dim)\n+            exps.push(new TupleExp(Loc.initial, atts));\n+        return exps;\n+    }\n+\n+    override const(char)* kind() const\n+    {\n+        return \"UserAttribute\";\n+    }\n+\n+    override void accept(Visitor v)\n+    {\n+        v.visit(this);\n+    }\n+\n+    /**\n+     * Check if the provided expression references `core.attribute.gnuAbiTag`\n+     *\n+     * This should be called after semantic has been run on the expression.\n+     * Semantic on UDA happens in semantic2 (see `dmd.semantic2`).\n+     *\n+     * Params:\n+     *   e = Expression to check (usually from `UserAttributeDeclaration.atts`)\n+     *\n+     * Returns:\n+     *   `true` if the expression references the compiler-recognized `gnuAbiTag`\n+     */\n+    static bool isGNUABITag(Expression e)\n+    {\n+        if (global.params.cplusplus < CppStdRevision.cpp11)\n+            return false;\n+\n+        auto ts = e.type ? e.type.isTypeStruct() : null;\n+        if (!ts)\n+            return false;\n+        if (ts.sym.ident != Id.udaGNUAbiTag || !ts.sym.parent)\n+            return false;\n+        // Can only be defined in druntime\n+        Module m = ts.sym.parent.isModule();\n+        if (!m || !m.isCoreModule(Id.attribute))\n+            return false;\n+        return true;\n+    }\n+\n+    /**\n+     * Called from a symbol's semantic to check if `gnuAbiTag` UDA\n+     * can be applied to them\n+     *\n+     * Directly emits an error if the UDA doesn't work with this symbol\n+     *\n+     * Params:\n+     *   sym = symbol to check for `gnuAbiTag`\n+     *   linkage = Linkage of the symbol (Declaration.link or sc.link)\n+     */\n+    static void checkGNUABITag(Dsymbol sym, LINK linkage)\n+    {\n+        if (global.params.cplusplus < CppStdRevision.cpp11)\n+            return;\n+\n+        // Avoid `if` at the call site\n+        if (sym.userAttribDecl is null || sym.userAttribDecl.atts is null)\n+            return;\n+\n+        foreach (exp; *sym.userAttribDecl.atts)\n+        {\n+            if (isGNUABITag(exp))\n+            {\n+                if (sym.isCPPNamespaceDeclaration() || sym.isNspace())\n+                {\n+                    exp.error(\"`@%s` cannot be applied to namespaces\", Id.udaGNUAbiTag.toChars());\n+                    sym.errors = true;\n+                }\n+                else if (linkage != LINK.cpp)\n+                {\n+                    exp.error(\"`@%s` can only apply to C++ symbols\", Id.udaGNUAbiTag.toChars());\n+                    sym.errors = true;\n+                }\n+                // Only one `@gnuAbiTag` is allowed by semantic2\n+                return;\n+            }\n+        }\n+    }\n+}"}, {"sha": "e63c80be3c6ba14e8eae5056c8795ed24f2df116", "filename": "gcc/d/dmd/attrib.h", "status": "modified", "additions": 37, "deletions": 49, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fattrib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fattrib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fattrib.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -10,13 +10,10 @@\n \n #pragma once\n \n+#include \"root/port.h\"\n #include \"dsymbol.h\"\n \n class Expression;\n-class Statement;\n-class LabelDsymbol;\n-class Initializer;\n-class Module;\n class Condition;\n class StaticForeach;\n \n@@ -27,20 +24,15 @@ class AttribDeclaration : public Dsymbol\n public:\n     Dsymbols *decl;     // array of Dsymbol's\n \n-    AttribDeclaration(Dsymbols *decl);\n     virtual Dsymbols *include(Scope *sc);\n-    int apply(Dsymbol_apply_ft_t fp, void *param);\n-    static Scope *createNewScope(Scope *sc,\n-        StorageClass newstc, LINK linkage, CPPMANGLE cppmangle, Prot protection,\n-        int explicitProtection, AlignDeclaration *aligndecl, PINLINE inlining);\n     virtual Scope *newScope(Scope *sc);\n     void addMember(Scope *sc, ScopeDsymbol *sds);\n     void setScope(Scope *sc);\n     void importAll(Scope *sc);\n     void addComment(const utf8_t *comment);\n     const char *kind() const;\n     bool oneMember(Dsymbol **ps, Identifier *ident);\n-    void setFieldOffset(AggregateDeclaration *ad, unsigned *poffset, bool isunion);\n+    void setFieldOffset(AggregateDeclaration *ad, FieldState& fieldState, bool isunion);\n     bool hasPointers();\n     bool hasStaticCtorOrDtor();\n     void checkCtorConstInit();\n@@ -55,8 +47,7 @@ class StorageClassDeclaration : public AttribDeclaration\n public:\n     StorageClass stc;\n \n-    StorageClassDeclaration(StorageClass stc, Dsymbols *decl);\n-    Dsymbol *syntaxCopy(Dsymbol *s);\n+    StorageClassDeclaration *syntaxCopy(Dsymbol *s);\n     Scope *newScope(Scope *sc);\n     bool oneMember(Dsymbol **ps, Identifier *ident);\n     void addMember(Scope *sc, ScopeDsymbol *sds);\n@@ -71,11 +62,9 @@ class DeprecatedDeclaration : public StorageClassDeclaration\n     Expression *msg;\n     const char *msgstr;\n \n-    DeprecatedDeclaration(Expression *msg, Dsymbols *decl);\n-    Dsymbol *syntaxCopy(Dsymbol *s);\n+    DeprecatedDeclaration *syntaxCopy(Dsymbol *s);\n     Scope *newScope(Scope *sc);\n     void setScope(Scope *sc);\n-    const char *getMessage();\n     void accept(Visitor *v) { v->visit(this); }\n };\n \n@@ -84,11 +73,10 @@ class LinkDeclaration : public AttribDeclaration\n public:\n     LINK linkage;\n \n-    LinkDeclaration(LINK p, Dsymbols *decl);\n-    static LinkDeclaration *create(LINK p, Dsymbols *decl);\n-    Dsymbol *syntaxCopy(Dsymbol *s);\n+    static LinkDeclaration *create(const Loc &loc, LINK p, Dsymbols *decl);\n+    LinkDeclaration *syntaxCopy(Dsymbol *s);\n     Scope *newScope(Scope *sc);\n-    const char *toChars();\n+    const char *toChars() const;\n     void accept(Visitor *v) { v->visit(this); }\n };\n \n@@ -97,40 +85,48 @@ class CPPMangleDeclaration : public AttribDeclaration\n public:\n     CPPMANGLE cppmangle;\n \n-    CPPMangleDeclaration(CPPMANGLE p, Dsymbols *decl);\n-    Dsymbol *syntaxCopy(Dsymbol *s);\n+    CPPMangleDeclaration *syntaxCopy(Dsymbol *s);\n     Scope *newScope(Scope *sc);\n-    const char *toChars();\n+    void setScope(Scope *sc);\n+    const char *toChars() const;\n     void accept(Visitor *v) { v->visit(this); }\n };\n \n-class ProtDeclaration : public AttribDeclaration\n+class CPPNamespaceDeclaration : public AttribDeclaration\n {\n public:\n-    Prot protection;\n-    Identifiers* pkg_identifiers;\n+    Expression *exp;\n \n-    ProtDeclaration(Loc loc, Prot p, Dsymbols *decl);\n-    ProtDeclaration(Loc loc, Identifiers* pkg_identifiers, Dsymbols *decl);\n+    CPPNamespaceDeclaration *syntaxCopy(Dsymbol *s);\n+    Scope *newScope(Scope *sc);\n+    const char *toChars() const;\n+    void accept(Visitor *v) { v->visit(this); }\n+};\n+\n+class VisibilityDeclaration : public AttribDeclaration\n+{\n+public:\n+    Visibility visibility;\n+    DArray<Identifier*> pkg_identifiers;\n \n-    Dsymbol *syntaxCopy(Dsymbol *s);\n+    VisibilityDeclaration *syntaxCopy(Dsymbol *s);\n     Scope *newScope(Scope *sc);\n     void addMember(Scope *sc, ScopeDsymbol *sds);\n     const char *kind() const;\n     const char *toPrettyChars(bool unused);\n+    VisibilityDeclaration *isVisibilityDeclaration() { return this; }\n     void accept(Visitor *v) { v->visit(this); }\n };\n \n class AlignDeclaration : public AttribDeclaration\n {\n public:\n-    Expression *ealign;\n+    Expressions *alignExps;\n     structalign_t salign;\n \n-    AlignDeclaration(Loc loc, Expression *ealign, Dsymbols *decl);\n-    Dsymbol *syntaxCopy(Dsymbol *s);\n+    AlignDeclaration(const Loc &loc, Expression *ealign, Dsymbols *decl);\n+    AlignDeclaration *syntaxCopy(Dsymbol *s);\n     Scope *newScope(Scope *sc);\n-    structalign_t getAlignment(Scope *sc);\n     void accept(Visitor *v) { v->visit(this); }\n };\n \n@@ -143,10 +139,9 @@ class AnonDeclaration : public AttribDeclaration\n     unsigned anonstructsize;    // size of anonymous struct\n     unsigned anonalignsize;     // size of anonymous struct for alignment purposes\n \n-    AnonDeclaration(Loc loc, bool isunion, Dsymbols *decl);\n-    Dsymbol *syntaxCopy(Dsymbol *s);\n+    AnonDeclaration *syntaxCopy(Dsymbol *s);\n     void setScope(Scope *sc);\n-    void setFieldOffset(AggregateDeclaration *ad, unsigned *poffset, bool isunion);\n+    void setFieldOffset(AggregateDeclaration *ad, FieldState& fieldState, bool isunion);\n     const char *kind() const;\n     AnonDeclaration *isAnonDeclaration() { return this; }\n     void accept(Visitor *v) { v->visit(this); }\n@@ -157,9 +152,9 @@ class PragmaDeclaration : public AttribDeclaration\n public:\n     Expressions *args;          // array of Expression's\n \n-    PragmaDeclaration(Loc loc, Identifier *ident, Expressions *args, Dsymbols *decl);\n-    Dsymbol *syntaxCopy(Dsymbol *s);\n+    PragmaDeclaration *syntaxCopy(Dsymbol *s);\n     Scope *newScope(Scope *sc);\n+    PINLINE evalPragmaInline(Scope* sc);\n     const char *kind() const;\n     void accept(Visitor *v) { v->visit(this); }\n };\n@@ -170,8 +165,7 @@ class ConditionalDeclaration : public AttribDeclaration\n     Condition *condition;\n     Dsymbols *elsedecl; // array of Dsymbol's for else block\n \n-    ConditionalDeclaration(Condition *condition, Dsymbols *decl, Dsymbols *elsedecl);\n-    Dsymbol *syntaxCopy(Dsymbol *s);\n+    ConditionalDeclaration *syntaxCopy(Dsymbol *s);\n     bool oneMember(Dsymbol **ps, Identifier *ident);\n     Dsymbols *include(Scope *sc);\n     void addComment(const utf8_t *comment);\n@@ -186,8 +180,7 @@ class StaticIfDeclaration : public ConditionalDeclaration\n     bool addisdone;\n     bool onStack;\n \n-    StaticIfDeclaration(Condition *condition, Dsymbols *decl, Dsymbols *elsedecl);\n-    Dsymbol *syntaxCopy(Dsymbol *s);\n+    StaticIfDeclaration *syntaxCopy(Dsymbol *s);\n     Dsymbols *include(Scope *sc);\n     void addMember(Scope *sc, ScopeDsymbol *sds);\n     void setScope(Scope *sc);\n@@ -205,8 +198,7 @@ class StaticForeachDeclaration : public AttribDeclaration\n     bool cached;\n     Dsymbols *cache;\n \n-    StaticForeachDeclaration(StaticForeach *sfe, Dsymbols *decl);\n-    Dsymbol *syntaxCopy(Dsymbol *s);\n+    StaticForeachDeclaration *syntaxCopy(Dsymbol *s);\n     bool oneMember(Dsymbol **ps, Identifier *ident);\n     Dsymbols *include(Scope *sc);\n     void addMember(Scope *sc, ScopeDsymbol *sds);\n@@ -222,7 +214,6 @@ class ForwardingAttribDeclaration : public AttribDeclaration\n public:\n     ForwardingScopeDsymbol *sym;\n \n-    ForwardingAttribDeclaration(Dsymbols *decl);\n     Scope *newScope(Scope *sc);\n     void addMember(Scope *sc, ScopeDsymbol *sds);\n     ForwardingAttribDeclaration *isForwardingAttribDeclaration() { return this; }\n@@ -239,8 +230,7 @@ class CompileDeclaration : public AttribDeclaration\n     ScopeDsymbol *scopesym;\n     bool compiled;\n \n-    CompileDeclaration(Loc loc, Expressions *exps);\n-    Dsymbol *syntaxCopy(Dsymbol *s);\n+    CompileDeclaration *syntaxCopy(Dsymbol *s);\n     void addMember(Scope *sc, ScopeDsymbol *sds);\n     void setScope(Scope *sc);\n     const char *kind() const;\n@@ -256,11 +246,9 @@ class UserAttributeDeclaration : public AttribDeclaration\n public:\n     Expressions *atts;\n \n-    UserAttributeDeclaration(Expressions *atts, Dsymbols *decl);\n-    Dsymbol *syntaxCopy(Dsymbol *s);\n+    UserAttributeDeclaration *syntaxCopy(Dsymbol *s);\n     Scope *newScope(Scope *sc);\n     void setScope(Scope *sc);\n-    static Expressions *concat(Expressions *udas1, Expressions *udas2);\n     Expressions *getAttributes();\n     const char *kind() const;\n     void accept(Visitor *v) { v->visit(this); }"}, {"sha": "1895d36fb1ebcafa6301dddb3071e3eadf589a30", "filename": "gcc/d/dmd/blockexit.c", "status": "removed", "additions": 0, "deletions": 506, "changes": 506, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fblockexit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fblockexit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fblockexit.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49", "patch": "@@ -1,506 +0,0 @@\n-\n-/* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n- * written by Walter Bright\n- * http://www.digitalmars.com\n- * Distributed under the Boost Software License, Version 1.0.\n- * http://www.boost.org/LICENSE_1_0.txt\n- */\n-\n-#include \"statement.h\"\n-#include \"declaration.h\"\n-#include \"aggregate.h\"\n-#include \"id.h\"\n-\n-/* Only valid after semantic analysis\n- * If 'mustNotThrow' is true, generate an error if it throws\n- */\n-int blockExit(Statement *s, FuncDeclaration *func, bool mustNotThrow)\n-{\n-    class BlockExit : public Visitor\n-    {\n-    public:\n-        FuncDeclaration *func;\n-        bool mustNotThrow;\n-        int result;\n-\n-        BlockExit(FuncDeclaration *func, bool mustNotThrow)\n-            : func(func), mustNotThrow(mustNotThrow)\n-        {\n-            result = BEnone;\n-        }\n-\n-        void visit(Statement *s)\n-        {\n-            printf(\"Statement::blockExit(%p)\\n\", s);\n-            printf(\"%s\\n\", s->toChars());\n-            assert(0);\n-            result = BEany;\n-        }\n-\n-        void visit(ErrorStatement *)\n-        {\n-            result = BEany;\n-        }\n-\n-        void visit(ExpStatement *s)\n-        {\n-            result = BEfallthru;\n-            if (s->exp)\n-            {\n-                if (s->exp->op == TOKhalt)\n-                {\n-                    result = BEhalt;\n-                    return;\n-                }\n-                if (s->exp->op == TOKassert)\n-                {\n-                    AssertExp *a = (AssertExp *)s->exp;\n-                    if (a->e1->isBool(false))   // if it's an assert(0)\n-                    {\n-                        result = BEhalt;\n-                        return;\n-                    }\n-                }\n-                if (s->exp->type->toBasetype()->isTypeNoreturn())\n-                    result = BEhalt;\n-                if (canThrow(s->exp, func, mustNotThrow))\n-                    result |= BEthrow;\n-            }\n-        }\n-\n-        void visit(CompileStatement *)\n-        {\n-            assert(global.errors);\n-            result = BEfallthru;\n-        }\n-\n-        void visit(CompoundStatement *cs)\n-        {\n-            //printf(\"CompoundStatement::blockExit(%p) %d result = x%X\\n\", cs, cs->statements->length, result);\n-            result = BEfallthru;\n-            Statement *slast = NULL;\n-            for (size_t i = 0; i < cs->statements->length; i++)\n-            {\n-                Statement *s = (*cs->statements)[i];\n-                if (s)\n-                {\n-                    //printf(\"result = x%x\\n\", result);\n-                    //printf(\"s: %s\\n\", s->toChars());\n-                    if (result & BEfallthru && slast)\n-                    {\n-                        slast = slast->last();\n-                        if (slast && (slast->isCaseStatement() || slast->isDefaultStatement()) &&\n-                                     (s->isCaseStatement() || s->isDefaultStatement()))\n-                        {\n-                            // Allow if last case/default was empty\n-                            CaseStatement *sc = slast->isCaseStatement();\n-                            DefaultStatement *sd = slast->isDefaultStatement();\n-                            if (sc && (!sc->statement->hasCode() || sc->statement->isCaseStatement() || sc->statement->isErrorStatement()))\n-                                ;\n-                            else if (sd && (!sd->statement->hasCode() || sd->statement->isCaseStatement() || sd->statement->isErrorStatement()))\n-                                ;\n-                            else\n-                            {\n-                                const char *gototype = s->isCaseStatement() ? \"case\" : \"default\";\n-                                s->deprecation(\"switch case fallthrough - use 'goto %s;' if intended\", gototype);\n-                            }\n-                        }\n-                    }\n-\n-                    if (!(result & BEfallthru) && !s->comeFrom())\n-                    {\n-                        if (blockExit(s, func, mustNotThrow) != BEhalt && s->hasCode())\n-                            s->warning(\"statement is not reachable\");\n-                    }\n-                    else\n-                    {\n-                        result &= ~BEfallthru;\n-                        result |= blockExit(s, func, mustNotThrow);\n-                    }\n-                    slast = s;\n-                }\n-            }\n-        }\n-\n-        void visit(UnrolledLoopStatement *uls)\n-        {\n-            result = BEfallthru;\n-            for (size_t i = 0; i < uls->statements->length; i++)\n-            {\n-                Statement *s = (*uls->statements)[i];\n-                if (s)\n-                {\n-                    int r = blockExit(s, func, mustNotThrow);\n-                    result |= r & ~(BEbreak | BEcontinue | BEfallthru);\n-                    if ((r & (BEfallthru | BEcontinue | BEbreak)) == 0)\n-                        result &= ~BEfallthru;\n-                }\n-            }\n-        }\n-\n-        void visit(ScopeStatement *s)\n-        {\n-            //printf(\"ScopeStatement::blockExit(%p)\\n\", s->statement);\n-            result = s->statement ? blockExit(s->statement, func, mustNotThrow) : BEfallthru;\n-        }\n-\n-        void visit(WhileStatement *)\n-        {\n-            assert(global.errors);\n-            result = BEfallthru;\n-        }\n-\n-        void visit(DoStatement *s)\n-        {\n-            if (s->_body)\n-            {\n-                result = blockExit(s->_body, func, mustNotThrow);\n-                if (result == BEbreak)\n-                {\n-                    result = BEfallthru;\n-                    return;\n-                }\n-                if (result & BEcontinue)\n-                    result |= BEfallthru;\n-            }\n-            else\n-                result = BEfallthru;\n-            if (result & BEfallthru)\n-            {\n-                if (canThrow(s->condition, func, mustNotThrow))\n-                    result |= BEthrow;\n-                if (!(result & BEbreak) && s->condition->isBool(true))\n-                    result &= ~BEfallthru;\n-            }\n-            result &= ~(BEbreak | BEcontinue);\n-        }\n-\n-        void visit(ForStatement *s)\n-        {\n-            result = BEfallthru;\n-            if (s->_init)\n-            {\n-                result = blockExit(s->_init, func, mustNotThrow);\n-                if (!(result & BEfallthru))\n-                    return;\n-            }\n-            if (s->condition)\n-            {\n-                if (canThrow(s->condition, func, mustNotThrow))\n-                    result |= BEthrow;\n-                if (s->condition->isBool(true))\n-                    result &= ~BEfallthru;\n-                else if (s->condition->isBool(false))\n-                    return;\n-            }\n-            else\n-                result &= ~BEfallthru;  // the body must do the exiting\n-            if (s->_body)\n-            {\n-                int r = blockExit(s->_body, func, mustNotThrow);\n-                if (r & (BEbreak | BEgoto))\n-                    result |= BEfallthru;\n-                result |= r & ~(BEfallthru | BEbreak | BEcontinue);\n-            }\n-            if (s->increment && canThrow(s->increment, func, mustNotThrow))\n-                result |= BEthrow;\n-        }\n-\n-        void visit(ForeachStatement *s)\n-        {\n-            result = BEfallthru;\n-            if (canThrow(s->aggr, func, mustNotThrow))\n-                result |= BEthrow;\n-            if (s->_body)\n-                result |= blockExit(s->_body, func, mustNotThrow) & ~(BEbreak | BEcontinue);\n-        }\n-\n-        void visit(ForeachRangeStatement *)\n-        {\n-            assert(global.errors);\n-            result = BEfallthru;\n-        }\n-\n-        void visit(IfStatement *s)\n-        {\n-            //printf(\"IfStatement::blockExit(%p)\\n\", s);\n-\n-            result = BEnone;\n-            if (canThrow(s->condition, func, mustNotThrow))\n-                result |= BEthrow;\n-            if (s->condition->isBool(true))\n-            {\n-                if (s->ifbody)\n-                    result |= blockExit(s->ifbody, func, mustNotThrow);\n-                else\n-                    result |= BEfallthru;\n-            }\n-            else if (s->condition->isBool(false))\n-            {\n-                if (s->elsebody)\n-                    result |= blockExit(s->elsebody, func, mustNotThrow);\n-                else\n-                    result |= BEfallthru;\n-            }\n-            else\n-            {\n-                if (s->ifbody)\n-                    result |= blockExit(s->ifbody, func, mustNotThrow);\n-                else\n-                    result |= BEfallthru;\n-                if (s->elsebody)\n-                    result |= blockExit(s->elsebody, func, mustNotThrow);\n-                else\n-                    result |= BEfallthru;\n-            }\n-            //printf(\"IfStatement::blockExit(%p) = x%x\\n\", s, result);\n-        }\n-\n-        void visit(ConditionalStatement *s)\n-        {\n-            result = blockExit(s->ifbody, func, mustNotThrow);\n-            if (s->elsebody)\n-                result |= blockExit(s->elsebody, func, mustNotThrow);\n-        }\n-\n-        void visit(PragmaStatement *)\n-        {\n-            result = BEfallthru;\n-        }\n-\n-        void visit(StaticAssertStatement *)\n-        {\n-            result = BEfallthru;\n-        }\n-\n-        void visit(SwitchStatement *s)\n-        {\n-            result = BEnone;\n-            if (canThrow(s->condition, func, mustNotThrow))\n-                result |= BEthrow;\n-            if (s->_body)\n-            {\n-                result |= blockExit(s->_body, func, mustNotThrow);\n-                if (result & BEbreak)\n-                {\n-                    result |= BEfallthru;\n-                    result &= ~BEbreak;\n-                }\n-            }\n-            else\n-                result |= BEfallthru;\n-        }\n-\n-        void visit(CaseStatement *s)\n-        {\n-            result = blockExit(s->statement, func, mustNotThrow);\n-        }\n-\n-        void visit(DefaultStatement *s)\n-        {\n-            result = blockExit(s->statement, func, mustNotThrow);\n-        }\n-\n-        void visit(GotoDefaultStatement *)\n-        {\n-            result = BEgoto;\n-        }\n-\n-        void visit(GotoCaseStatement *)\n-        {\n-            result = BEgoto;\n-        }\n-\n-        void visit(SwitchErrorStatement *)\n-        {\n-            // Switch errors are non-recoverable\n-            result = BEhalt;\n-        }\n-\n-        void visit(ReturnStatement *s)\n-        {\n-            result = BEreturn;\n-            if (s->exp && canThrow(s->exp, func, mustNotThrow))\n-                result |= BEthrow;\n-        }\n-\n-        void visit(BreakStatement *s)\n-        {\n-            //printf(\"BreakStatement::blockExit(%p) = x%x\\n\", s, s->ident ? BEgoto : BEbreak);\n-            result = s->ident ? BEgoto : BEbreak;\n-        }\n-\n-        void visit(ContinueStatement *s)\n-        {\n-            result = s->ident ? BEgoto : BEcontinue;\n-        }\n-\n-        void visit(SynchronizedStatement *s)\n-        {\n-            result = s->_body ? blockExit(s->_body, func, mustNotThrow) : BEfallthru;\n-        }\n-\n-        void visit(WithStatement *s)\n-        {\n-            result = BEnone;\n-            if (canThrow(s->exp, func, mustNotThrow))\n-                result = BEthrow;\n-            if (s->_body)\n-                result |= blockExit(s->_body, func, mustNotThrow);\n-            else\n-                result |= BEfallthru;\n-        }\n-\n-        void visit(TryCatchStatement *s)\n-        {\n-            assert(s->_body);\n-            result = blockExit(s->_body, func, false);\n-\n-            int catchresult = 0;\n-            for (size_t i = 0; i < s->catches->length; i++)\n-            {\n-                Catch *c = (*s->catches)[i];\n-                if (c->type == Type::terror)\n-                    continue;\n-\n-                int cresult;\n-                if (c->handler)\n-                    cresult = blockExit(c->handler, func, mustNotThrow);\n-                else\n-                    cresult = BEfallthru;\n-\n-                /* If we're catching Object, then there is no throwing\n-                 */\n-                Identifier *id = c->type->toBasetype()->isClassHandle()->ident;\n-                if (c->internalCatch && (cresult & BEfallthru))\n-                {\n-                    // Bugzilla 11542: leave blockExit flags of the body\n-                    cresult &= ~BEfallthru;\n-                }\n-                else if (id == Id::Object || id == Id::Throwable)\n-                {\n-                    result &= ~(BEthrow | BEerrthrow);\n-                }\n-                else if (id == Id::Exception)\n-                {\n-                    result &= ~BEthrow;\n-                }\n-                catchresult |= cresult;\n-            }\n-            if (mustNotThrow && (result & BEthrow))\n-            {\n-                // now explain why this is nothrow\n-                blockExit(s->_body, func, mustNotThrow);\n-            }\n-            result |= catchresult;\n-        }\n-\n-        void visit(TryFinallyStatement *s)\n-        {\n-            result = BEfallthru;\n-            if (s->_body)\n-                result = blockExit(s->_body, func, false);\n-\n-            // check finally body as well, it may throw (bug #4082)\n-            int finalresult = BEfallthru;\n-            if (s->finalbody)\n-                finalresult = blockExit(s->finalbody, func, false);\n-\n-            // If either body or finalbody halts\n-            if (result == BEhalt)\n-                finalresult = BEnone;\n-            if (finalresult == BEhalt)\n-                result = BEnone;\n-\n-            if (mustNotThrow)\n-            {\n-                // now explain why this is nothrow\n-                if (s->_body && (result & BEthrow))\n-                    blockExit(s->_body, func, mustNotThrow);\n-                if (s->finalbody && (finalresult & BEthrow))\n-                    blockExit(s->finalbody, func, mustNotThrow);\n-            }\n-\n-        #if 0\n-            // Bugzilla 13201: Mask to prevent spurious warnings for\n-            // destructor call, exit of synchronized statement, etc.\n-            if (result == BEhalt && finalresult != BEhalt && s->finalbody &&\n-                s->finalbody->hasCode())\n-            {\n-                s->finalbody->warning(\"statement is not reachable\");\n-            }\n-        #endif\n-\n-            if (!(finalresult & BEfallthru))\n-                result &= ~BEfallthru;\n-            result |= finalresult & ~BEfallthru;\n-        }\n-\n-        void visit(ScopeGuardStatement *)\n-        {\n-            // At this point, this statement is just an empty placeholder\n-            result = BEfallthru;\n-        }\n-\n-        void visit(ThrowStatement *s)\n-        {\n-            if (s->internalThrow)\n-            {\n-                // Bugzilla 8675: Allow throwing 'Throwable' object even if mustNotThrow.\n-                result = BEfallthru;\n-                return;\n-            }\n-\n-            Type *t = s->exp->type->toBasetype();\n-            ClassDeclaration *cd = t->isClassHandle();\n-            assert(cd);\n-\n-            if (cd == ClassDeclaration::errorException ||\n-                ClassDeclaration::errorException->isBaseOf(cd, NULL))\n-            {\n-                result = BEerrthrow;\n-                return;\n-            }\n-            if (mustNotThrow)\n-                s->error(\"%s is thrown but not caught\", s->exp->type->toChars());\n-\n-            result = BEthrow;\n-        }\n-\n-        void visit(GotoStatement *)\n-        {\n-            //printf(\"GotoStatement::blockExit(%p)\\n\", s);\n-            result = BEgoto;\n-        }\n-\n-        void visit(LabelStatement *s)\n-        {\n-            //printf(\"LabelStatement::blockExit(%p)\\n\", s);\n-            result = s->statement ? blockExit(s->statement, func, mustNotThrow) : BEfallthru;\n-            if (s->breaks)\n-                result |= BEfallthru;\n-        }\n-\n-        void visit(CompoundAsmStatement *s)\n-        {\n-            if (mustNotThrow && !(s->stc & STCnothrow))\n-                s->deprecation(\"asm statement is assumed to throw - mark it with `nothrow` if it does not\");\n-\n-            // Assume the worst\n-            result = BEfallthru | BEreturn | BEgoto | BEhalt;\n-            if (!(s->stc & STCnothrow)) result |= BEthrow;\n-        }\n-\n-        void visit(ImportStatement *)\n-        {\n-            result = BEfallthru;\n-        }\n-    };\n-\n-    if (!s)\n-        return BEfallthru;\n-    BlockExit be(func, mustNotThrow);\n-    s->accept(&be);\n-    return be.result;\n-}"}, {"sha": "1fd9005183010263b4ed697bd38bd9b110972a37", "filename": "gcc/d/dmd/blockexit.d", "status": "added", "additions": 537, "deletions": 0, "changes": 537, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fblockexit.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fblockexit.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fblockexit.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -0,0 +1,537 @@\n+/**\n+ * Find out in what ways control flow can exit a statement block.\n+ *\n+ * Copyright:   Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n+ * Authors:     $(LINK2 http://www.digitalmars.com, Walter Bright)\n+ * License:     $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+ * Source:      $(LINK2 https://github.com/dlang/dmd/blob/master/src/dmd/blockexit.d, _blockexit.d)\n+ * Documentation:  https://dlang.org/phobos/dmd_blockexit.html\n+ * Coverage:    https://codecov.io/gh/dlang/dmd/src/master/src/dmd/blockexit.d\n+ */\n+\n+module dmd.blockexit;\n+\n+import core.stdc.stdio;\n+\n+import dmd.arraytypes;\n+import dmd.astenums;\n+import dmd.canthrow;\n+import dmd.dclass;\n+import dmd.declaration;\n+import dmd.expression;\n+import dmd.func;\n+import dmd.globals;\n+import dmd.id;\n+import dmd.identifier;\n+import dmd.mtype;\n+import dmd.statement;\n+import dmd.tokens;\n+import dmd.visitor;\n+\n+/**\n+ * BE stands for BlockExit.\n+ *\n+ * It indicates if a statement does transfer control to another block.\n+ * A block is a sequence of statements enclosed in { }\n+ */\n+enum BE : int\n+{\n+    none      = 0,\n+    fallthru  = 1,\n+    throw_    = 2,\n+    return_   = 4,\n+    goto_     = 8,\n+    halt      = 0x10,\n+    break_    = 0x20,\n+    continue_ = 0x40,\n+    errthrow  = 0x80,\n+    any       = (fallthru | throw_ | return_ | goto_ | halt),\n+}\n+\n+\n+/*********************************************\n+ * Determine mask of ways that a statement can exit.\n+ *\n+ * Only valid after semantic analysis.\n+ * Params:\n+ *   s = statement to check for block exit status\n+ *   func = function that statement s is in\n+ *   mustNotThrow = generate an error if it throws\n+ * Returns:\n+ *   BE.xxxx\n+ */\n+int blockExit(Statement s, FuncDeclaration func, bool mustNotThrow)\n+{\n+    extern (C++) final class BlockExit : Visitor\n+    {\n+        alias visit = Visitor.visit;\n+    public:\n+        FuncDeclaration func;\n+        bool mustNotThrow;\n+        int result;\n+\n+        extern (D) this(FuncDeclaration func, bool mustNotThrow)\n+        {\n+            this.func = func;\n+            this.mustNotThrow = mustNotThrow;\n+            result = BE.none;\n+        }\n+\n+        override void visit(Statement s)\n+        {\n+            printf(\"Statement::blockExit(%p)\\n\", s);\n+            printf(\"%s\\n\", s.toChars());\n+            assert(0);\n+        }\n+\n+        override void visit(ErrorStatement s)\n+        {\n+            result = BE.none;\n+        }\n+\n+        override void visit(ExpStatement s)\n+        {\n+            result = BE.fallthru;\n+            if (s.exp)\n+            {\n+                if (s.exp.op == TOK.halt)\n+                {\n+                    result = BE.halt;\n+                    return;\n+                }\n+                if (s.exp.op == TOK.assert_)\n+                {\n+                    AssertExp a = cast(AssertExp)s.exp;\n+                    if (a.e1.isBool(false)) // if it's an assert(0)\n+                    {\n+                        result = BE.halt;\n+                        return;\n+                    }\n+                }\n+                if (s.exp.type.toBasetype().isTypeNoreturn())\n+                    result = BE.halt;\n+                if (canThrow(s.exp, func, mustNotThrow))\n+                    result |= BE.throw_;\n+            }\n+        }\n+\n+        override void visit(CompileStatement s)\n+        {\n+            assert(global.errors);\n+            result = BE.fallthru;\n+        }\n+\n+        override void visit(CompoundStatement cs)\n+        {\n+            //printf(\"CompoundStatement.blockExit(%p) %d result = x%X\\n\", cs, cs.statements.dim, result);\n+            result = BE.fallthru;\n+            Statement slast = null;\n+            foreach (s; *cs.statements)\n+            {\n+                if (s)\n+                {\n+                    //printf(\"result = x%x\\n\", result);\n+                    //printf(\"s: %s\\n\", s.toChars());\n+                    if (result & BE.fallthru && slast)\n+                    {\n+                        slast = slast.last();\n+                        if (slast && (slast.isCaseStatement() || slast.isDefaultStatement()) && (s.isCaseStatement() || s.isDefaultStatement()))\n+                        {\n+                            // Allow if last case/default was empty\n+                            CaseStatement sc = slast.isCaseStatement();\n+                            DefaultStatement sd = slast.isDefaultStatement();\n+                            if (sc && (!sc.statement.hasCode() || sc.statement.isCaseStatement() || sc.statement.isErrorStatement()))\n+                            {\n+                            }\n+                            else if (sd && (!sd.statement.hasCode() || sd.statement.isCaseStatement() || sd.statement.isErrorStatement()))\n+                            {\n+                            }\n+                            else\n+                            {\n+                                const(char)* gototype = s.isCaseStatement() ? \"case\" : \"default\";\n+                                s.deprecation(\"switch case fallthrough - use 'goto %s;' if intended\", gototype);\n+                            }\n+                        }\n+                    }\n+\n+                    if (!(result & BE.fallthru) && !s.comeFrom())\n+                    {\n+                        if (blockExit(s, func, mustNotThrow) != BE.halt && s.hasCode() &&\n+                            s.loc != Loc.initial) // don't emit warning for generated code\n+                            s.warning(\"statement is not reachable\");\n+                    }\n+                    else\n+                    {\n+                        result &= ~BE.fallthru;\n+                        result |= blockExit(s, func, mustNotThrow);\n+                    }\n+                    slast = s;\n+                }\n+            }\n+        }\n+\n+        override void visit(UnrolledLoopStatement uls)\n+        {\n+            result = BE.fallthru;\n+            foreach (s; *uls.statements)\n+            {\n+                if (s)\n+                {\n+                    int r = blockExit(s, func, mustNotThrow);\n+                    result |= r & ~(BE.break_ | BE.continue_ | BE.fallthru);\n+                    if ((r & (BE.fallthru | BE.continue_ | BE.break_)) == 0)\n+                        result &= ~BE.fallthru;\n+                }\n+            }\n+        }\n+\n+        override void visit(ScopeStatement s)\n+        {\n+            //printf(\"ScopeStatement::blockExit(%p)\\n\", s.statement);\n+            result = blockExit(s.statement, func, mustNotThrow);\n+        }\n+\n+        override void visit(WhileStatement s)\n+        {\n+            assert(global.errors);\n+            result = BE.fallthru;\n+        }\n+\n+        override void visit(DoStatement s)\n+        {\n+            if (s._body)\n+            {\n+                result = blockExit(s._body, func, mustNotThrow);\n+                if (result == BE.break_)\n+                {\n+                    result = BE.fallthru;\n+                    return;\n+                }\n+                if (result & BE.continue_)\n+                    result |= BE.fallthru;\n+            }\n+            else\n+                result = BE.fallthru;\n+            if (result & BE.fallthru)\n+            {\n+                if (canThrow(s.condition, func, mustNotThrow))\n+                    result |= BE.throw_;\n+                if (!(result & BE.break_) && s.condition.isBool(true))\n+                    result &= ~BE.fallthru;\n+            }\n+            result &= ~(BE.break_ | BE.continue_);\n+        }\n+\n+        override void visit(ForStatement s)\n+        {\n+            result = BE.fallthru;\n+            if (s._init)\n+            {\n+                result = blockExit(s._init, func, mustNotThrow);\n+                if (!(result & BE.fallthru))\n+                    return;\n+            }\n+            if (s.condition)\n+            {\n+                if (canThrow(s.condition, func, mustNotThrow))\n+                    result |= BE.throw_;\n+                if (s.condition.isBool(true))\n+                    result &= ~BE.fallthru;\n+                else if (s.condition.isBool(false))\n+                    return;\n+            }\n+            else\n+                result &= ~BE.fallthru; // the body must do the exiting\n+            if (s._body)\n+            {\n+                int r = blockExit(s._body, func, mustNotThrow);\n+                if (r & (BE.break_ | BE.goto_))\n+                    result |= BE.fallthru;\n+                result |= r & ~(BE.fallthru | BE.break_ | BE.continue_);\n+            }\n+            if (s.increment && canThrow(s.increment, func, mustNotThrow))\n+                result |= BE.throw_;\n+        }\n+\n+        override void visit(ForeachStatement s)\n+        {\n+            result = BE.fallthru;\n+            if (canThrow(s.aggr, func, mustNotThrow))\n+                result |= BE.throw_;\n+            if (s._body)\n+                result |= blockExit(s._body, func, mustNotThrow) & ~(BE.break_ | BE.continue_);\n+        }\n+\n+        override void visit(ForeachRangeStatement s)\n+        {\n+            assert(global.errors);\n+            result = BE.fallthru;\n+        }\n+\n+        override void visit(IfStatement s)\n+        {\n+            //printf(\"IfStatement::blockExit(%p)\\n\", s);\n+            result = BE.none;\n+            if (canThrow(s.condition, func, mustNotThrow))\n+                result |= BE.throw_;\n+            if (s.condition.isBool(true))\n+            {\n+                result |= blockExit(s.ifbody, func, mustNotThrow);\n+            }\n+            else if (s.condition.isBool(false))\n+            {\n+                result |= blockExit(s.elsebody, func, mustNotThrow);\n+            }\n+            else\n+            {\n+                result |= blockExit(s.ifbody, func, mustNotThrow);\n+                result |= blockExit(s.elsebody, func, mustNotThrow);\n+            }\n+            //printf(\"IfStatement::blockExit(%p) = x%x\\n\", s, result);\n+        }\n+\n+        override void visit(ConditionalStatement s)\n+        {\n+            result = blockExit(s.ifbody, func, mustNotThrow);\n+            if (s.elsebody)\n+                result |= blockExit(s.elsebody, func, mustNotThrow);\n+        }\n+\n+        override void visit(PragmaStatement s)\n+        {\n+            result = BE.fallthru;\n+        }\n+\n+        override void visit(StaticAssertStatement s)\n+        {\n+            result = BE.fallthru;\n+        }\n+\n+        override void visit(SwitchStatement s)\n+        {\n+            result = BE.none;\n+            if (canThrow(s.condition, func, mustNotThrow))\n+                result |= BE.throw_;\n+            if (s._body)\n+            {\n+                result |= blockExit(s._body, func, mustNotThrow);\n+                if (result & BE.break_)\n+                {\n+                    result |= BE.fallthru;\n+                    result &= ~BE.break_;\n+                }\n+            }\n+            else\n+                result |= BE.fallthru;\n+        }\n+\n+        override void visit(CaseStatement s)\n+        {\n+            result = blockExit(s.statement, func, mustNotThrow);\n+        }\n+\n+        override void visit(DefaultStatement s)\n+        {\n+            result = blockExit(s.statement, func, mustNotThrow);\n+        }\n+\n+        override void visit(GotoDefaultStatement s)\n+        {\n+            result = BE.goto_;\n+        }\n+\n+        override void visit(GotoCaseStatement s)\n+        {\n+            result = BE.goto_;\n+        }\n+\n+        override void visit(SwitchErrorStatement s)\n+        {\n+            // Switch errors are non-recoverable\n+            result = BE.halt;\n+        }\n+\n+        override void visit(ReturnStatement s)\n+        {\n+            result = BE.return_;\n+            if (s.exp && canThrow(s.exp, func, mustNotThrow))\n+                result |= BE.throw_;\n+        }\n+\n+        override void visit(BreakStatement s)\n+        {\n+            //printf(\"BreakStatement::blockExit(%p) = x%x\\n\", s, s.ident ? BE.goto_ : BE.break_);\n+            result = s.ident ? BE.goto_ : BE.break_;\n+        }\n+\n+        override void visit(ContinueStatement s)\n+        {\n+            result = s.ident ? BE.continue_ | BE.goto_ : BE.continue_;\n+        }\n+\n+        override void visit(SynchronizedStatement s)\n+        {\n+            result = blockExit(s._body, func, mustNotThrow);\n+        }\n+\n+        override void visit(WithStatement s)\n+        {\n+            result = BE.none;\n+            if (canThrow(s.exp, func, mustNotThrow))\n+                result = BE.throw_;\n+            result |= blockExit(s._body, func, mustNotThrow);\n+        }\n+\n+        override void visit(TryCatchStatement s)\n+        {\n+            assert(s._body);\n+            result = blockExit(s._body, func, false);\n+\n+            int catchresult = 0;\n+            foreach (c; *s.catches)\n+            {\n+                if (c.type == Type.terror)\n+                    continue;\n+\n+                int cresult = blockExit(c.handler, func, mustNotThrow);\n+\n+                /* If we're catching Object, then there is no throwing\n+                 */\n+                Identifier id = c.type.toBasetype().isClassHandle().ident;\n+                if (c.internalCatch && (cresult & BE.fallthru))\n+                {\n+                    // https://issues.dlang.org/show_bug.cgi?id=11542\n+                    // leave blockExit flags of the body\n+                    cresult &= ~BE.fallthru;\n+                }\n+                else if (id == Id.Object || id == Id.Throwable)\n+                {\n+                    result &= ~(BE.throw_ | BE.errthrow);\n+                }\n+                else if (id == Id.Exception)\n+                {\n+                    result &= ~BE.throw_;\n+                }\n+                catchresult |= cresult;\n+            }\n+            if (mustNotThrow && (result & BE.throw_))\n+            {\n+                // now explain why this is nothrow\n+                blockExit(s._body, func, mustNotThrow);\n+            }\n+            result |= catchresult;\n+        }\n+\n+        override void visit(TryFinallyStatement s)\n+        {\n+            result = BE.fallthru;\n+            if (s._body)\n+                result = blockExit(s._body, func, false);\n+\n+            // check finally body as well, it may throw (bug #4082)\n+            int finalresult = BE.fallthru;\n+            if (s.finalbody)\n+                finalresult = blockExit(s.finalbody, func, false);\n+\n+            // If either body or finalbody halts\n+            if (result == BE.halt)\n+                finalresult = BE.none;\n+            if (finalresult == BE.halt)\n+                result = BE.none;\n+\n+            if (mustNotThrow)\n+            {\n+                // now explain why this is nothrow\n+                if (s._body && (result & BE.throw_))\n+                    blockExit(s._body, func, mustNotThrow);\n+                if (s.finalbody && (finalresult & BE.throw_))\n+                    blockExit(s.finalbody, func, mustNotThrow);\n+            }\n+\n+            version (none)\n+            {\n+                // https://issues.dlang.org/show_bug.cgi?id=13201\n+                // Mask to prevent spurious warnings for\n+                // destructor call, exit of synchronized statement, etc.\n+                if (result == BE.halt && finalresult != BE.halt && s.finalbody && s.finalbody.hasCode())\n+                {\n+                    s.finalbody.warning(\"statement is not reachable\");\n+                }\n+            }\n+\n+            if (!(finalresult & BE.fallthru))\n+                result &= ~BE.fallthru;\n+            result |= finalresult & ~BE.fallthru;\n+        }\n+\n+        override void visit(ScopeGuardStatement s)\n+        {\n+            // At this point, this statement is just an empty placeholder\n+            result = BE.fallthru;\n+        }\n+\n+        override void visit(ThrowStatement s)\n+        {\n+            if (s.internalThrow)\n+            {\n+                // https://issues.dlang.org/show_bug.cgi?id=8675\n+                // Allow throwing 'Throwable' object even if mustNotThrow.\n+                result = BE.fallthru;\n+                return;\n+            }\n+\n+            Type t = s.exp.type.toBasetype();\n+            ClassDeclaration cd = t.isClassHandle();\n+            assert(cd);\n+\n+            if (cd == ClassDeclaration.errorException || ClassDeclaration.errorException.isBaseOf(cd, null))\n+            {\n+                result = BE.errthrow;\n+                return;\n+            }\n+            if (mustNotThrow)\n+                s.error(\"`%s` is thrown but not caught\", s.exp.type.toChars());\n+\n+            result = BE.throw_;\n+        }\n+\n+        override void visit(GotoStatement s)\n+        {\n+            //printf(\"GotoStatement::blockExit(%p)\\n\", s);\n+            result = BE.goto_;\n+        }\n+\n+        override void visit(LabelStatement s)\n+        {\n+            //printf(\"LabelStatement::blockExit(%p)\\n\", s);\n+            result = blockExit(s.statement, func, mustNotThrow);\n+            if (s.breaks)\n+                result |= BE.fallthru;\n+        }\n+\n+        override void visit(CompoundAsmStatement s)\n+        {\n+            // Assume the worst\n+            result = BE.fallthru | BE.return_ | BE.goto_ | BE.halt;\n+            if (!(s.stc & STC.nothrow_))\n+            {\n+                if (mustNotThrow && !(s.stc & STC.nothrow_))\n+                    s.deprecation(\"`asm` statement is assumed to throw - mark it with `nothrow` if it does not\");\n+                else\n+                    result |= BE.throw_;\n+            }\n+        }\n+\n+        override void visit(ImportStatement s)\n+        {\n+            result = BE.fallthru;\n+        }\n+    }\n+\n+    if (!s)\n+        return BE.fallthru;\n+    scope BlockExit be = new BlockExit(func, mustNotThrow);\n+    s.accept(be);\n+    return be.result;\n+}\n+"}, {"sha": "b99f690e156d2a9c3041677d4bc0f515fab181f3", "filename": "gcc/d/dmd/builtin.d", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fbuiltin.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fbuiltin.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fbuiltin.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -0,0 +1,33 @@\n+/**\n+ * Implement CTFE for intrinsic (builtin) functions.\n+ *\n+ * Currently includes functions from `std.math`, `core.math` and `core.bitop`.\n+ *\n+ * Copyright:   Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n+ * Authors:     $(LINK2 http://www.digitalmars.com, Walter Bright)\n+ * License:     $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+ * Source:      $(LINK2 https://github.com/dlang/dmd/blob/master/src/dmd/builtin.d, _builtin.d)\n+ * Documentation:  https://dlang.org/phobos/dmd_builtin.html\n+ * Coverage:    https://codecov.io/gh/dlang/dmd/src/master/src/dmd/builtin.d\n+ */\n+\n+module dmd.builtin;\n+\n+import core.stdc.math;\n+import core.stdc.string;\n+import dmd.arraytypes;\n+import dmd.expression;\n+import dmd.func;\n+import dmd.globals;\n+\n+/**********************************\n+ * Determine if function is a builtin one that we can\n+ * evaluate at compile time.\n+ */\n+public extern (C++) BUILTIN isBuiltin(FuncDeclaration fd);\n+\n+/**************************************\n+ * Evaluate builtin function.\n+ * Return result; NULL if cannot evaluate it.\n+ */\n+public extern (C++) Expression eval_builtin(Loc loc, FuncDeclaration fd, Expressions* arguments);"}, {"sha": "5d180f54367a68b977a1292ee7237d3644691e9b", "filename": "gcc/d/dmd/canthrow.c", "status": "removed", "additions": 0, "deletions": 316, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fcanthrow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fcanthrow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcanthrow.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49", "patch": "@@ -1,316 +0,0 @@\n-\n-/* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n- * written by Walter Bright\n- * http://www.digitalmars.com\n- * Distributed under the Boost Software License, Version 1.0.\n- * http://www.boost.org/LICENSE_1_0.txt\n- * https://github.com/D-Programming-Language/dmd/blob/master/src/canthrow.c\n- */\n-\n-#include \"root/dsystem.h\"\n-\n-#include \"mars.h\"\n-#include \"init.h\"\n-#include \"expression.h\"\n-#include \"template.h\"\n-#include \"statement.h\"\n-#include \"mtype.h\"\n-#include \"utf.h\"\n-#include \"declaration.h\"\n-#include \"aggregate.h\"\n-#include \"scope.h\"\n-#include \"attrib.h\"\n-#include \"tokens.h\"\n-\n-bool Dsymbol_canThrow(Dsymbol *s, FuncDeclaration *func, bool mustNotThrow);\n-bool walkPostorder(Expression *e, StoppableVisitor *v);\n-\n-/********************************************\n- * Returns true if the expression may throw exceptions.\n- * If 'mustNotThrow' is true, generate an error if it throws\n- */\n-\n-bool canThrow(Expression *e, FuncDeclaration *func, bool mustNotThrow)\n-{\n-    //printf(\"Expression::canThrow(%d) %s\\n\", mustNotThrow, toChars());\n-\n-    // stop walking if we determine this expression can throw\n-    class CanThrow : public StoppableVisitor\n-    {\n-        FuncDeclaration *func;\n-        bool mustNotThrow;\n-\n-    public:\n-        CanThrow(FuncDeclaration *func, bool mustNotThrow)\n-            : func(func), mustNotThrow(mustNotThrow)\n-        {\n-        }\n-\n-        void visit(Expression *)\n-        {\n-        }\n-\n-        void visit(DeclarationExp *de)\n-        {\n-            stop = Dsymbol_canThrow(de->declaration, func, mustNotThrow);\n-        }\n-\n-        void visit(CallExp *ce)\n-        {\n-            if (global.errors && !ce->e1->type)\n-                return;                       // error recovery\n-\n-            /* If calling a function or delegate that is typed as nothrow,\n-             * then this expression cannot throw.\n-             * Note that pure functions can throw.\n-             */\n-            Type *t = ce->e1->type->toBasetype();\n-            if (ce->f && ce->f == func)\n-                return;\n-            if (t->ty == Tfunction && ((TypeFunction *)t)->isnothrow)\n-                return;\n-            if (t->ty == Tdelegate && ((TypeFunction *)((TypeDelegate *)t)->next)->isnothrow)\n-                return;\n-\n-            if (mustNotThrow)\n-            {\n-                if (ce->f)\n-                {\n-                    ce->error(\"%s `%s` is not nothrow\",\n-                        ce->f->kind(), ce->f->toPrettyChars());\n-                }\n-                else\n-                {\n-                    Expression *e1 = ce->e1;\n-                    if (e1->op == TOKstar)   // print 'fp' if e1 is (*fp)\n-                        e1 = ((PtrExp *)e1)->e1;\n-                    ce->error(\"`%s` is not nothrow\", e1->toChars());\n-                }\n-            }\n-            stop = true;\n-        }\n-\n-        void visit(NewExp *ne)\n-        {\n-            if (ne->member)\n-            {\n-                if (ne->allocator)\n-                {\n-                    // Bugzilla 14407\n-                    Type *t = ne->allocator->type->toBasetype();\n-                    if (t->ty == Tfunction && !((TypeFunction *)t)->isnothrow)\n-                    {\n-                        if (mustNotThrow)\n-                        {\n-                            ne->error(\"%s `%s` is not nothrow\",\n-                                ne->allocator->kind(), ne->allocator->toPrettyChars());\n-                        }\n-                        stop = true;\n-                    }\n-                }\n-                // See if constructor call can throw\n-                Type *t = ne->member->type->toBasetype();\n-                if (t->ty == Tfunction && !((TypeFunction *)t)->isnothrow)\n-                {\n-                    if (mustNotThrow)\n-                    {\n-                        ne->error(\"%s `%s` is not nothrow\",\n-                            ne->member->kind(), ne->member->toPrettyChars());\n-                    }\n-                    stop = true;\n-                }\n-            }\n-            // regard storage allocation failures as not recoverable\n-        }\n-\n-        void visit(DeleteExp *de)\n-        {\n-            Type *tb = de->e1->type->toBasetype();\n-            AggregateDeclaration *ad = NULL;\n-            switch (tb->ty)\n-            {\n-            case Tclass:\n-                ad = ((TypeClass *)tb)->sym;\n-                break;\n-\n-            case Tpointer:\n-                tb = ((TypePointer *)tb)->next->toBasetype();\n-                if (tb->ty == Tstruct)\n-                    ad = ((TypeStruct *)tb)->sym;\n-                break;\n-\n-            case Tarray:\n-            {\n-                Type *tv = tb->nextOf()->baseElemOf();\n-                if (tv->ty == Tstruct)\n-                {\n-                    ad = ((TypeStruct *)tv)->sym;\n-                    break;\n-                }\n-            }\n-\n-            default:\n-                break;\n-            }\n-            if (!ad)\n-                return;\n-\n-            if (ad->dtor)\n-            {\n-                Type *t = ad->dtor->type->toBasetype();\n-                if (t->ty == Tfunction && !((TypeFunction *)t)->isnothrow)\n-                {\n-                    if (mustNotThrow)\n-                    {\n-                        de->error(\"%s `%s` is not nothrow\",\n-                            ad->dtor->kind(), ad->dtor->toPrettyChars());\n-                    }\n-                    stop = true;\n-                }\n-            }\n-            if (ad->aggDelete && tb->ty != Tarray)\n-            {\n-                Type *t = ad->aggDelete->type;\n-                if (t->ty == Tfunction && !((TypeFunction *)t)->isnothrow)\n-                {\n-                    if (mustNotThrow)\n-                    {\n-                        de->error(\"%s `%s` is not nothrow\",\n-                            ad->aggDelete->kind(), ad->aggDelete->toPrettyChars());\n-                    }\n-                    stop = true;\n-                }\n-            }\n-        }\n-\n-        void visit(AssignExp *ae)\n-        {\n-            // blit-init cannot throw\n-            if (ae->op == TOKblit)\n-                return;\n-\n-            /* Element-wise assignment could invoke postblits.\n-             */\n-            Type *t;\n-            if (ae->type->toBasetype()->ty == Tsarray)\n-            {\n-                if (!ae->e2->isLvalue())\n-                    return;\n-                t = ae->type;\n-            }\n-            else if (ae->e1->op == TOKslice)\n-                t = ((SliceExp *)ae->e1)->e1->type;\n-            else\n-                return;\n-\n-            Type *tv = t->baseElemOf();\n-            if (tv->ty != Tstruct)\n-                return;\n-            StructDeclaration *sd = ((TypeStruct *)tv)->sym;\n-            if (!sd->postblit || sd->postblit->type->ty != Tfunction)\n-                return;\n-\n-            if (((TypeFunction *)sd->postblit->type)->isnothrow)\n-                ;\n-            else\n-            {\n-                if (mustNotThrow)\n-                {\n-                    ae->error(\"%s `%s` is not nothrow\",\n-                        sd->postblit->kind(), sd->postblit->toPrettyChars());\n-                }\n-                stop = true;\n-            }\n-        }\n-\n-        void visit(NewAnonClassExp *)\n-        {\n-            assert(0);          // should have been lowered by semantic()\n-        }\n-    };\n-\n-    CanThrow ct(func, mustNotThrow);\n-    return walkPostorder(e, &ct);\n-}\n-\n-/**************************************\n- * Does symbol, when initialized, throw?\n- * Mirrors logic in Dsymbol_toElem().\n- */\n-\n-bool Dsymbol_canThrow(Dsymbol *s, FuncDeclaration *func, bool mustNotThrow)\n-{\n-    AttribDeclaration *ad;\n-    VarDeclaration *vd;\n-    TemplateMixin *tm;\n-    TupleDeclaration *td;\n-\n-    //printf(\"Dsymbol_toElem() %s\\n\", s->toChars());\n-    ad = s->isAttribDeclaration();\n-    if (ad)\n-    {\n-        Dsymbols *decl = ad->include(NULL);\n-        if (decl && decl->length)\n-        {\n-            for (size_t i = 0; i < decl->length; i++)\n-            {\n-                s = (*decl)[i];\n-                if (Dsymbol_canThrow(s, func, mustNotThrow))\n-                    return true;\n-            }\n-        }\n-    }\n-    else if ((vd = s->isVarDeclaration()) != NULL)\n-    {\n-        s = s->toAlias();\n-        if (s != vd)\n-            return Dsymbol_canThrow(s, func, mustNotThrow);\n-        if (vd->storage_class & STCmanifest)\n-            ;\n-        else if (vd->isStatic() || vd->storage_class & (STCextern | STCtls | STCgshared))\n-            ;\n-        else\n-        {\n-            if (vd->_init)\n-            {\n-                ExpInitializer *ie = vd->_init->isExpInitializer();\n-                if (ie && canThrow(ie->exp, func, mustNotThrow))\n-                    return true;\n-            }\n-            if (vd->needsScopeDtor())\n-                return canThrow(vd->edtor, func, mustNotThrow);\n-        }\n-    }\n-    else if ((tm = s->isTemplateMixin()) != NULL)\n-    {\n-        //printf(\"%s\\n\", tm->toChars());\n-        if (tm->members)\n-        {\n-            for (size_t i = 0; i < tm->members->length; i++)\n-            {\n-                Dsymbol *sm = (*tm->members)[i];\n-                if (Dsymbol_canThrow(sm, func, mustNotThrow))\n-                    return true;\n-            }\n-        }\n-    }\n-    else if ((td = s->isTupleDeclaration()) != NULL)\n-    {\n-        for (size_t i = 0; i < td->objects->length; i++)\n-        {\n-            RootObject *o = (*td->objects)[i];\n-            if (o->dyncast() == DYNCAST_EXPRESSION)\n-            {\n-                Expression *eo = (Expression *)o;\n-                if (eo->op == TOKdsymbol)\n-                {\n-                    DsymbolExp *se = (DsymbolExp *)eo;\n-                    if (Dsymbol_canThrow(se->s, func, mustNotThrow))\n-                        return true;\n-                }\n-            }\n-        }\n-    }\n-    return false;\n-}"}, {"sha": "ed05af6ac7cb31c6c66878e30134772da6872e0e", "filename": "gcc/d/dmd/canthrow.d", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fcanthrow.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fcanthrow.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcanthrow.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -0,0 +1,244 @@\n+/**\n+ * Perform checks for `nothrow`.\n+ *\n+ * Specification: $(LINK2 https://dlang.org/spec/function.html#nothrow-functions, Nothrow Functions)\n+ *\n+ * Copyright:   Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n+ * Authors:     $(LINK2 http://www.digitalmars.com, Walter Bright)\n+ * License:     $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+ * Source:      $(LINK2 https://github.com/dlang/dmd/blob/master/src/dmd/canthrow.d, _canthrow.d)\n+ * Documentation:  https://dlang.org/phobos/dmd_canthrow.html\n+ * Coverage:    https://codecov.io/gh/dlang/dmd/src/master/src/dmd/canthrow.d\n+ */\n+\n+module dmd.canthrow;\n+\n+import dmd.aggregate;\n+import dmd.apply;\n+import dmd.arraytypes;\n+import dmd.attrib;\n+import dmd.astenums;\n+import dmd.declaration;\n+import dmd.dsymbol;\n+import dmd.expression;\n+import dmd.func;\n+import dmd.globals;\n+import dmd.init;\n+import dmd.mtype;\n+import dmd.root.rootobject;\n+import dmd.tokens;\n+import dmd.visitor;\n+\n+/********************************************\n+ * Returns true if the expression may throw exceptions.\n+ * If 'mustNotThrow' is true, generate an error if it throws\n+ */\n+extern (C++) bool canThrow(Expression e, FuncDeclaration func, bool mustNotThrow)\n+{\n+    //printf(\"Expression::canThrow(%d) %s\\n\", mustNotThrow, toChars());\n+    // stop walking if we determine this expression can throw\n+    extern (C++) final class CanThrow : StoppableVisitor\n+    {\n+        alias visit = typeof(super).visit;\n+        FuncDeclaration func;\n+        bool mustNotThrow;\n+\n+    public:\n+        extern (D) this(FuncDeclaration func, bool mustNotThrow)\n+        {\n+            this.func = func;\n+            this.mustNotThrow = mustNotThrow;\n+        }\n+\n+        void checkFuncThrows(Expression e, FuncDeclaration f)\n+        {\n+            auto tf = f.type.toBasetype().isTypeFunction();\n+            if (tf && !tf.isnothrow)\n+            {\n+                if (mustNotThrow)\n+                {\n+                    e.error(\"%s `%s` is not `nothrow`\",\n+                        f.kind(), f.toPrettyChars());\n+\n+                    e.checkOverridenDtor(null, f, dd => dd.type.toTypeFunction().isnothrow, \"not nothrow\");\n+                }\n+                stop = true;  // if any function throws, then the whole expression throws\n+            }\n+        }\n+\n+        override void visit(Expression)\n+        {\n+        }\n+\n+        override void visit(DeclarationExp de)\n+        {\n+            stop = Dsymbol_canThrow(de.declaration, func, mustNotThrow);\n+        }\n+\n+        override void visit(CallExp ce)\n+        {\n+            if (ce.inDebugStatement)\n+                return;\n+\n+            if (global.errors && !ce.e1.type)\n+                return; // error recovery\n+            /* If calling a function or delegate that is typed as nothrow,\n+             * then this expression cannot throw.\n+             * Note that pure functions can throw.\n+             */\n+            if (ce.f && ce.f == func)\n+                return;\n+            Type t = ce.e1.type.toBasetype();\n+            auto tf = t.isTypeFunction();\n+            if (tf && tf.isnothrow)\n+                return;\n+            else\n+            {\n+                auto td = t.isTypeDelegate();\n+                if (td && td.nextOf().isTypeFunction().isnothrow)\n+                    return;\n+            }\n+\n+            if (ce.f)\n+                checkFuncThrows(ce, ce.f);\n+            else if (mustNotThrow)\n+            {\n+                auto e1 = ce.e1;\n+                if (auto pe = e1.isPtrExp())   // print 'fp' if e1 is (*fp)\n+                    e1 = pe.e1;\n+                ce.error(\"`%s` is not `nothrow`\", e1.toChars());\n+            }\n+            stop = true;\n+        }\n+\n+        override void visit(NewExp ne)\n+        {\n+            if (ne.member)\n+            {\n+                // See if constructor call can throw\n+                checkFuncThrows(ne, ne.member);\n+            }\n+            // regard storage allocation failures as not recoverable\n+        }\n+\n+        override void visit(DeleteExp de)\n+        {\n+            Type tb = de.e1.type.toBasetype();\n+            AggregateDeclaration ad = null;\n+            switch (tb.ty)\n+            {\n+            case Tclass:\n+                ad = tb.isTypeClass().sym;\n+                break;\n+\n+            case Tpointer:\n+            case Tarray:\n+                auto ts = tb.nextOf().baseElemOf().isTypeStruct();\n+                if (!ts)\n+                    return;\n+                ad = ts.sym;\n+                break;\n+\n+            default:\n+                assert(0);  // error should have been detected by semantic()\n+            }\n+\n+            if (ad.dtor)\n+                checkFuncThrows(de, ad.dtor);\n+        }\n+\n+        override void visit(AssignExp ae)\n+        {\n+            // blit-init cannot throw\n+            if (ae.op == TOK.blit)\n+                return;\n+            /* Element-wise assignment could invoke postblits.\n+             */\n+            Type t;\n+            if (ae.type.toBasetype().ty == Tsarray)\n+            {\n+                if (!ae.e2.isLvalue())\n+                    return;\n+                t = ae.type;\n+            }\n+            else if (auto se = ae.e1.isSliceExp())\n+                t = se.e1.type;\n+            else\n+                return;\n+\n+            if (auto ts = t.baseElemOf().isTypeStruct())\n+                if (auto postblit = ts.sym.postblit)\n+                    checkFuncThrows(ae, postblit);\n+        }\n+\n+        override void visit(NewAnonClassExp)\n+        {\n+            assert(0); // should have been lowered by semantic()\n+        }\n+    }\n+\n+    scope CanThrow ct = new CanThrow(func, mustNotThrow);\n+    return walkPostorder(e, ct);\n+}\n+\n+/**************************************\n+ * Does symbol, when initialized, throw?\n+ * Mirrors logic in Dsymbol_toElem().\n+ */\n+private bool Dsymbol_canThrow(Dsymbol s, FuncDeclaration func, bool mustNotThrow)\n+{\n+    int symbolDg(Dsymbol s)\n+    {\n+        return Dsymbol_canThrow(s, func, mustNotThrow);\n+    }\n+\n+    //printf(\"Dsymbol_toElem() %s\\n\", s.toChars());\n+    if (auto vd = s.isVarDeclaration())\n+    {\n+        s = s.toAlias();\n+        if (s != vd)\n+            return Dsymbol_canThrow(s, func, mustNotThrow);\n+        if (vd.storage_class & STC.manifest)\n+        {\n+        }\n+        else if (vd.isStatic() || vd.storage_class & (STC.extern_ | STC.tls | STC.gshared))\n+        {\n+        }\n+        else\n+        {\n+            if (vd._init)\n+            {\n+                if (auto ie = vd._init.isExpInitializer())\n+                    if (canThrow(ie.exp, func, mustNotThrow))\n+                        return true;\n+            }\n+            if (vd.needsScopeDtor())\n+                return canThrow(vd.edtor, func, mustNotThrow);\n+        }\n+    }\n+    else if (auto ad = s.isAttribDeclaration())\n+    {\n+        return ad.include(null).foreachDsymbol(&symbolDg) != 0;\n+    }\n+    else if (auto tm = s.isTemplateMixin())\n+    {\n+        return tm.members.foreachDsymbol(&symbolDg) != 0;\n+    }\n+    else if (auto td = s.isTupleDeclaration())\n+    {\n+        for (size_t i = 0; i < td.objects.dim; i++)\n+        {\n+            RootObject o = (*td.objects)[i];\n+            if (o.dyncast() == DYNCAST.expression)\n+            {\n+                Expression eo = cast(Expression)o;\n+                if (auto se = eo.isDsymbolExp())\n+                {\n+                    if (Dsymbol_canThrow(se.s, func, mustNotThrow))\n+                        return true;\n+                }\n+            }\n+        }\n+    }\n+    return false;\n+}"}, {"sha": "a4a97c9bf50d54162960bbdf58def9238ca15fe4", "filename": "gcc/d/dmd/chkformat.c", "status": "removed", "additions": 0, "deletions": 985, "changes": 985, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fchkformat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fchkformat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fchkformat.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49", "patch": "@@ -1,985 +0,0 @@\n-\n-/* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n- * written by Walter Bright\n- * http://www.digitalmars.com\n- * Distributed under the Boost Software License, Version 1.0.\n- * http://www.boost.org/LICENSE_1_0.txt\n- */\n-\n-// Check the arguments to `printf` and `scanf` against the `format` string.\n-\n-#include \"root/dsystem.h\"\n-#include \"root/dcompat.h\"\n-\n-#include \"arraytypes.h\"\n-#include \"cond.h\"\n-#include \"errors.h\"\n-#include \"expression.h\"\n-#include \"globals.h\"\n-#include \"identifier.h\"\n-#include \"mtype.h\"\n-#include \"target.h\"\n-\n-\n-/* Different kinds of formatting specifications, variations we don't\n-   care about are merged. (Like we don't care about the difference between\n-   f, e, g, a, etc.)\n-\n-   For `scanf`, every format is a pointer.\n- */\n-enum Format\n-{\n-    Format_d,          // int\n-    Format_hhd,        // signed char\n-    Format_hd,         // short int\n-    Format_ld,         // long int\n-    Format_lld,        // long long int\n-    Format_jd,         // intmax_t\n-    Format_zd,         // size_t\n-    Format_td,         // ptrdiff_t\n-    Format_u,          // unsigned int\n-    Format_hhu,        // unsigned char\n-    Format_hu,         // unsigned short int\n-    Format_lu,         // unsigned long int\n-    Format_llu,        // unsigned long long int\n-    Format_ju,         // uintmax_t\n-    Format_g,          // float (scanf) / double (printf)\n-    Format_lg,         // double (scanf)\n-    Format_Lg,         // long double (both)\n-    Format_s,          // char string (both)\n-    Format_ls,         // wchar_t string (both)\n-    Format_c,          // char (printf)\n-    Format_lc,         // wint_t (printf)\n-    Format_p,          // pointer\n-    Format_n,          // pointer to int\n-    Format_hhn,        // pointer to signed char\n-    Format_hn,         // pointer to short\n-    Format_ln,         // pointer to long int\n-    Format_lln,        // pointer to long long int\n-    Format_jn,         // pointer to intmax_t\n-    Format_zn,         // pointer to size_t\n-    Format_tn,         // pointer to ptrdiff_t\n-    Format_GNU_a,      // GNU ext. : address to a string with no maximum size (scanf)\n-    Format_GNU_m,      // GNU ext. : string corresponding to the error code in errno (printf) / length modifier (scanf)\n-    Format_percent,    // %% (i.e. no argument)\n-    Format_error,      // invalid format specification\n-};\n-\n-/**************************************\n- * Parse the *length specifier* and the *specifier* of the following form:\n- * `[length]specifier`\n- *\n- * Params:\n- *      format = format string\n- *      idx = index of of start of format specifier,\n- *          which gets updated to index past the end of it,\n- *          even if `Format_error` is returned\n- *      genSpecifier = Generic specifier. For instance, it will be set to `d` if the\n- *           format is `hdd`.\n- * Returns:\n- *      Format\n- */\n-static Format parseGenericFormatSpecifier(const char *format,\n-            size_t &idx, char &genSpecifier, bool useGNUExts =\n-            findCondition(global.versionids, Identifier::idPool(\"CRuntime_Glibc\")))\n-{\n-    genSpecifier = 0;\n-\n-    const size_t length = strlen(format);\n-\n-    /* Read the `length modifier`\n-     */\n-    const char lm = format[idx];\n-    bool lm1= false;        // if jztL\n-    bool lm2= false;        // if `hh` or `ll`\n-    if (lm == 'j' ||\n-        lm == 'z' ||\n-        lm == 't' ||\n-        lm == 'L')\n-    {\n-        ++idx;\n-        if (idx == length)\n-            return Format_error;\n-        lm1 = true;\n-    }\n-    else if (lm == 'h' || lm == 'l')\n-    {\n-        ++idx;\n-        if (idx == length)\n-            return Format_error;\n-        lm2 = lm == format[idx];\n-        if (lm2)\n-        {\n-            ++idx;\n-            if (idx == length)\n-                return Format_error;\n-        }\n-    }\n-\n-    /* Read the `specifier`\n-     */\n-    Format specifier;\n-    const char sc = format[idx];\n-    genSpecifier = sc;\n-    switch (sc)\n-    {\n-        case 'd':\n-        case 'i':\n-            if (lm == 'L')\n-                specifier = Format_error;\n-            else\n-                specifier = lm == 'h' && lm2 ? Format_hhd :\n-                            lm == 'h'        ? Format_hd  :\n-                            lm == 'l' && lm2 ? Format_lld :\n-                            lm == 'l'        ? Format_ld  :\n-                            lm == 'j'        ? Format_jd  :\n-                            lm == 'z'        ? Format_zd  :\n-                            lm == 't'        ? Format_td  :\n-                                               Format_d;\n-            break;\n-\n-        case 'u':\n-        case 'o':\n-        case 'x':\n-        case 'X':\n-            if (lm == 'L')\n-                specifier = Format_error;\n-            else\n-                specifier = lm == 'h' && lm2 ? Format_hhu :\n-                            lm == 'h'        ? Format_hu  :\n-                            lm == 'l' && lm2 ? Format_llu :\n-                            lm == 'l'        ? Format_lu  :\n-                            lm == 'j'        ? Format_ju  :\n-                            lm == 'z'        ? Format_zd  :\n-                            lm == 't'        ? Format_td  :\n-                                               Format_u;\n-            break;\n-\n-        case 'a':\n-            if (useGNUExts)\n-            {\n-                // https://www.gnu.org/software/libc/manual/html_node/Dynamic-String-Input.html\n-                specifier = Format_GNU_a;\n-                break;\n-            }\n-            /* fall through */\n-\n-        case 'f':\n-        case 'F':\n-        case 'e':\n-        case 'E':\n-        case 'g':\n-        case 'G':\n-        case 'A':\n-            if (lm == 'L')\n-                specifier = Format_Lg;\n-            else if (lm1 || lm2 || lm == 'h')\n-                specifier = Format_error;\n-            else\n-                specifier = lm == 'l' ? Format_lg : Format_g;\n-            break;\n-\n-        case 'c':\n-            if (lm1 || lm2 || lm == 'h')\n-                specifier = Format_error;\n-            else\n-                specifier = lm == 'l' ? Format_lc : Format_c;\n-            break;\n-\n-        case 's':\n-            if (lm1 || lm2 || lm == 'h')\n-                specifier = Format_error;\n-            else\n-                specifier = lm == 'l' ? Format_ls : Format_s;\n-            break;\n-\n-        case 'p':\n-            if (lm1 || lm2 || lm == 'h' || lm == 'l')\n-                specifier = Format_error;\n-            else\n-                specifier = Format_p;\n-            break;\n-\n-        case 'n':\n-            if (lm == 'L')\n-                specifier = Format_error;\n-            else\n-                specifier = lm == 'l' && lm2 ? Format_lln :\n-                            lm == 'l'        ? Format_ln  :\n-                            lm == 'h' && lm2 ? Format_hhn :\n-                            lm == 'h'        ? Format_hn  :\n-                            lm == 'j'        ? Format_jn  :\n-                            lm == 'z'        ? Format_zn  :\n-                            lm == 't'        ? Format_tn  :\n-                                               Format_n;\n-            break;\n-\n-        case 'm':\n-            if (useGNUExts)\n-            {\n-                // http://www.gnu.org/software/libc/manual/html_node/Other-Output-Conversions.html\n-                specifier = Format_GNU_m;\n-                break;\n-            }\n-            goto Ldefault;\n-\n-        default:\n-        Ldefault:\n-            specifier = Format_error;\n-            break;\n-    }\n-\n-    ++idx;\n-    return specifier; // success\n-}\n-\n-Format formatError(size_t &idx, size_t i)\n-{\n-    idx = i;\n-    return Format_error;\n-}\n-\n-/**************************************\n- * Parse the *format specifier* which is of the form:\n- *\n- * `%[*][width][length]specifier`\n- *\n- * Params:\n- *      format = format string\n- *      idx = index of `%` of start of format specifier,\n- *          which gets updated to index past the end of it,\n- *          even if `Format_error` is returned\n- *      asterisk = set if there is a `*` sub-specifier\n- * Returns:\n- *      Format\n- */\n-static Format parseScanfFormatSpecifier(const char *format, size_t &idx,\n-                bool &asterisk)\n-{\n-    asterisk = false;\n-\n-    size_t i = idx;\n-    assert(format[i] == '%');\n-    const size_t length = strlen(format);\n-\n-    ++i;\n-    if (i == length)\n-        return formatError(idx, i);\n-\n-    if (format[i] == '%')\n-    {\n-        idx = i + 1;\n-        return Format_percent;\n-    }\n-\n-    // * sub-specifier\n-    if (format[i] == '*')\n-    {\n-        ++i;\n-        if (i == length)\n-            return formatError(idx, i);\n-        asterisk = true;\n-    }\n-\n-    // fieldWidth\n-    while (isdigit(format[i]))\n-    {\n-        i++;\n-        if (i == length)\n-            return formatError(idx, i);\n-    }\n-\n-    /* Read the scanset\n-     * A scanset can be anything, so we just check that it is paired\n-     */\n-    if (format[i] == '[')\n-    {\n-        while (i < length)\n-        {\n-            if (format[i] == ']')\n-                break;\n-            ++i;\n-        }\n-\n-        // no `]` found\n-        if (i == length)\n-            return formatError(idx, i);\n-\n-        ++i;\n-        // no specifier after `]`\n-        // it could be mixed with the one above, but then idx won't have the right index\n-        if (i == length)\n-            return formatError(idx, i);\n-    }\n-\n-    /* Read the specifier\n-     */\n-    char genSpec;\n-    Format specifier = parseGenericFormatSpecifier(format, i, genSpec);\n-    if (specifier == Format_error)\n-        return formatError(idx, i);\n-\n-    idx = i;\n-    return specifier;  // success\n-}\n-\n-/**************************************\n- * Parse the *format specifier* which is of the form:\n- *\n- * `%[flags][field width][.precision][length modifier]specifier`\n- *\n- * Params:\n- *      format = format string\n- *      idx = index of `%` of start of format specifier,\n- *          which gets updated to index past the end of it,\n- *          even if `Format_error` is returned\n- *      widthStar = set if * for width\n- *      precisionStar = set if * for precision\n- * Returns:\n- *      Format\n- */\n-static Format parsePrintfFormatSpecifier(const char *format, size_t &idx,\n-                bool &widthStar, bool &precisionStar)\n-{\n-    widthStar = false;\n-    precisionStar = false;\n-\n-    size_t i = idx;\n-    assert(format[i] == '%');\n-    const size_t format_length = strlen(format);\n-    const size_t length = format_length;\n-    bool hash = false;\n-    bool zero = false;\n-    bool flags = false;\n-    bool width = false;\n-    bool precision = false;\n-\n-    ++i;\n-    if (i == length)\n-        return formatError(idx, i);\n-\n-    if (format[i] == '%')\n-    {\n-        idx = i + 1;\n-        return Format_percent;\n-    }\n-\n-    /* Read the `flags`\n-     */\n-    while (1)\n-    {\n-        const char c = format[i];\n-        if (c == '-' ||\n-            c == '+' ||\n-            c == ' ')\n-        {\n-            flags = true;\n-        }\n-        else if (c == '#')\n-        {\n-            hash = true;\n-        }\n-        else if (c == '0')\n-        {\n-            zero = true;\n-        }\n-        else\n-            break;\n-        ++i;\n-        if (i == length)\n-            return formatError(idx, i);\n-    }\n-\n-    /* Read the `field width`\n-     */\n-    {\n-        const char c = format[i];\n-        if (c == '*')\n-        {\n-            width = true;\n-            widthStar = true;\n-            ++i;\n-            if (i == length)\n-                return formatError(idx, i);\n-        }\n-        else if ('1' <= c && c <= '9')\n-        {\n-            width = true;\n-            ++i;\n-            if (i == length)\n-                return formatError(idx, i);\n-            while ('0' <= format[i] && format[i] <= '9')\n-            {\n-               ++i;\n-               if (i == length)\n-                    return formatError(idx, i);\n-            }\n-        }\n-    }\n-\n-    /* Read the `precision`\n-     */\n-    if (format[i] == '.')\n-    {\n-        precision = true;\n-        ++i;\n-        if (i == length)\n-            return formatError(idx, i);\n-        const char c = format[i];\n-        if (c == '*')\n-        {\n-            precisionStar = true;\n-            ++i;\n-            if (i == length)\n-                return formatError(idx, i);\n-        }\n-        else if ('0' <= c && c <= '9')\n-        {\n-            ++i;\n-            if (i == length)\n-                return formatError(idx, i);\n-            while ('0' <= format[i] && format[i] <= '9')\n-            {\n-               ++i;\n-               if (i == length)\n-                    return formatError(idx, i);\n-            }\n-        }\n-    }\n-\n-    /* Read the specifier\n-     */\n-    char genSpec;\n-    Format specifier = parseGenericFormatSpecifier(format, i, genSpec);\n-    if (specifier == Format_error)\n-        return formatError(idx, i);\n-\n-    switch (genSpec)\n-    {\n-        case 'c':\n-        case 's':\n-            if (hash || zero)\n-                return formatError(idx, i);\n-            break;\n-\n-        case 'd':\n-        case 'i':\n-            if (hash)\n-                return formatError(idx, i);\n-            break;\n-\n-        case 'n':\n-            if (hash || zero || precision || width || flags)\n-                return formatError(idx, i);\n-            break;\n-\n-        default:\n-            break;\n-    }\n-\n-    idx = i;\n-    return specifier;  // success\n-}\n-\n-/*******************************************/\n-\n-static Expression *getNextPrintfArg(const Loc &loc, Expressions &args, size_t &n,\n-                size_t gnu_m_count, bool &skip)\n-{\n-    if (n == args.length)\n-    {\n-        if (args.length < (n + 1) - gnu_m_count)\n-            deprecation(loc, \"more format specifiers than %d arguments\", (int)n);\n-        else\n-            skip = true;\n-        return NULL;\n-    }\n-    return args[n++];\n-}\n-\n-static void errorPrintfFormat(const char *prefix, DString &slice, Expression *arg,\n-                const char *texpect, Type *tactual)\n-{\n-    deprecation(arg->loc, \"%sargument `%s` for format specification `\\\"%.*s\\\"` must be `%s`, not `%s`\",\n-                prefix ? prefix : \"\", arg->toChars(), (int)slice.length, slice.ptr, texpect, tactual->toChars());\n-}\n-\n-/******************************************\n- * Check that arguments to a printf format string are compatible\n- * with that string. Issue errors for incompatibilities.\n- *\n- * Follows the C99 specification for printf.\n- *\n- * Takes a generous, rather than strict, view of compatiblity.\n- * For example, an unsigned value can be formatted with a signed specifier.\n- *\n- * Diagnosed incompatibilities are:\n- *\n- * 1. incompatible sizes which will cause argument misalignment\n- * 2. deferencing arguments that are not pointers\n- * 3. insufficient number of arguments\n- * 4. struct arguments\n- * 5. array and slice arguments\n- * 6. non-pointer arguments to `s` specifier\n- * 7. non-standard formats\n- * 8. undefined behavior per C99\n- *\n- * Per the C Standard, extra arguments are ignored.\n- *\n- * No attempt is made to fix the arguments or the format string.\n- *\n- * Params:\n- *      loc = location for error messages\n- *      format = format string\n- *      args = arguments to match with format string\n- *      isVa_list = if a \"v\" function (format check only)\n- *\n- * Returns:\n- *      `true` if errors occurred\n- * References:\n- * C99 7.19.6.1\n- * http://www.cplusplus.com/reference/cstdio/printf/\n- */\n-bool checkPrintfFormat(const Loc &loc, const char *format, Expressions &args, bool isVa_list)\n-{\n-    //printf(\"checkPrintFormat('%s')\\n\", format);\n-    size_t n = 0;             // index in args\n-    size_t gnu_m_count = 0;   // number of Format_GNU_m\n-    const size_t format_length = strlen(format);\n-    for (size_t i = 0; i < format_length;)\n-    {\n-        if (format[i] != '%')\n-        {\n-            ++i;\n-            continue;\n-        }\n-        bool widthStar = false;\n-        bool precisionStar = false;\n-        size_t j = i;\n-        const Format fmt = parsePrintfFormatSpecifier(format, j, widthStar, precisionStar);\n-        DString slice = DString(j - i, format + i);\n-        i = j;\n-\n-        if (fmt == Format_percent)\n-            continue;                   // \"%%\", no arguments\n-\n-        if (isVa_list)\n-        {\n-            // format check only\n-            if (fmt == Format_error)\n-                deprecation(loc, \"format specifier `\\\"%.*s\\\"` is invalid\", (int)slice.length, slice.ptr);\n-            continue;\n-        }\n-\n-        if (fmt == Format_GNU_m)\n-            ++gnu_m_count;\n-\n-        if (widthStar)\n-        {\n-            bool skip = false;\n-            Expression *e = getNextPrintfArg(loc, args, n, gnu_m_count, skip);\n-            if (skip)\n-                continue;\n-            if (!e)\n-                return true;\n-            Type *t = e->type->toBasetype();\n-            if (t->ty != Tint32 && t->ty != Tuns32)\n-                errorPrintfFormat(\"width \", slice, e, \"int\", t);\n-        }\n-\n-        if (precisionStar)\n-        {\n-            bool skip = false;\n-            Expression *e = getNextPrintfArg(loc, args, n, gnu_m_count, skip);\n-            if (skip)\n-                continue;\n-            if (!e)\n-                return true;\n-            Type *t = e->type->toBasetype();\n-            if (t->ty != Tint32 && t->ty != Tuns32)\n-                errorPrintfFormat(\"precision \", slice, e, \"int\", t);\n-        }\n-\n-        bool skip = false;\n-        Expression *e = getNextPrintfArg(loc, args, n, gnu_m_count, skip);\n-        if (skip)\n-            continue;\n-        if (!e)\n-            return true;\n-        Type *t = e->type->toBasetype();\n-        Type *tnext = t->nextOf();\n-        const unsigned c_longsize = target.c.longsize;\n-        const unsigned ptrsize = target.ptrsize;\n-\n-        // Types which are promoted to int are allowed.\n-        // Spec: C99 6.5.2.2.7\n-        switch (fmt)\n-        {\n-            case Format_u:      // unsigned int\n-            case Format_d:      // int\n-                if (t->ty != Tint32 && t->ty != Tuns32)\n-                    errorPrintfFormat(NULL, slice, e, fmt == Format_u ? \"uint\" : \"int\", t);\n-                break;\n-\n-            case Format_hhu:    // unsigned char\n-            case Format_hhd:    // signed char\n-                if (t->ty != Tint32 && t->ty != Tuns32 && t->ty != Tint8 && t->ty != Tuns8)\n-                    errorPrintfFormat(NULL, slice, e, fmt == Format_hhu ? \"ubyte\" : \"byte\", t);\n-                break;\n-\n-            case Format_hu:     // unsigned short int\n-            case Format_hd:     // short int\n-                if (t->ty != Tint32 && t->ty != Tuns32 && t->ty != Tint16 && t->ty != Tuns16)\n-                    errorPrintfFormat(NULL, slice, e, fmt == Format_hu ? \"ushort\" : \"short\", t);\n-                break;\n-\n-            case Format_lu:     // unsigned long int\n-            case Format_ld:     // long int\n-                if (!(t->isintegral() && t->size() == c_longsize))\n-                {\n-                    if (fmt == Format_lu)\n-                        errorPrintfFormat(NULL, slice, e, (c_longsize == 4 ? \"uint\" : \"ulong\"), t);\n-                    else\n-                        errorPrintfFormat(NULL, slice, e, (c_longsize == 4 ? \"int\" : \"long\"), t);\n-                }\n-                break;\n-\n-            case Format_llu:    // unsigned long long int\n-            case Format_lld:    // long long int\n-                if (t->ty != Tint64 && t->ty != Tuns64)\n-                    errorPrintfFormat(NULL, slice, e, fmt == Format_llu ? \"ulong\" : \"long\", t);\n-                break;\n-\n-            case Format_ju:     // uintmax_t\n-            case Format_jd:     // intmax_t\n-                if (t->ty != Tint64 && t->ty != Tuns64)\n-                {\n-                    if (fmt == Format_ju)\n-                        errorPrintfFormat(NULL, slice, e, \"core.stdc.stdint.uintmax_t\", t);\n-                    else\n-                        errorPrintfFormat(NULL, slice, e, \"core.stdc.stdint.intmax_t\", t);\n-                }\n-                break;\n-\n-            case Format_zd:     // size_t\n-                if (!(t->isintegral() && t->size() == ptrsize))\n-                    errorPrintfFormat(NULL, slice, e, \"size_t\", t);\n-                break;\n-\n-            case Format_td:     // ptrdiff_t\n-                if (!(t->isintegral() && t->size() == ptrsize))\n-                    errorPrintfFormat(NULL, slice, e, \"ptrdiff_t\", t);\n-                break;\n-\n-            case Format_GNU_a:  // Format_GNU_a is only for scanf\n-            case Format_lg:\n-            case Format_g:      // double\n-                if (t->ty != Tfloat64 && t->ty != Timaginary64)\n-                    errorPrintfFormat(NULL, slice, e, \"double\", t);\n-                break;\n-\n-            case Format_Lg:     // long double\n-                if (t->ty != Tfloat80 && t->ty != Timaginary80)\n-                    errorPrintfFormat(NULL, slice, e, \"real\", t);\n-                break;\n-\n-            case Format_p:      // pointer\n-                if (t->ty != Tpointer && t->ty != Tnull && t->ty != Tclass && t->ty != Tdelegate && t->ty != Taarray)\n-                    errorPrintfFormat(NULL, slice, e, \"void*\", t);\n-                break;\n-\n-            case Format_n:      // pointer to int\n-                if (!(t->ty == Tpointer && tnext->ty == Tint32))\n-                    errorPrintfFormat(NULL, slice, e, \"int*\", t);\n-                break;\n-\n-            case Format_ln:     // pointer to long int\n-                if (!(t->ty == Tpointer && tnext->isintegral() && !tnext->isunsigned() && tnext->size() == c_longsize))\n-                    errorPrintfFormat(NULL, slice, e, (c_longsize == 4 ? \"int*\" : \"long*\"), t);\n-                break;\n-\n-            case Format_lln:    // pointer to long long int\n-                if (!(t->ty == Tpointer && tnext->ty == Tint64))\n-                    errorPrintfFormat(NULL, slice, e, \"long*\", t);\n-                break;\n-\n-            case Format_hn:     // pointer to short\n-                if (!(t->ty == Tpointer && tnext->ty == Tint16))\n-                    errorPrintfFormat(NULL, slice, e, \"short*\", t);\n-                break;\n-\n-            case Format_hhn:    // pointer to signed char\n-                if (!(t->ty == Tpointer && tnext->ty == Tint16))\n-                    errorPrintfFormat(NULL, slice, e, \"byte*\", t);\n-                break;\n-\n-            case Format_jn:     // pointer to intmax_t\n-                if (!(t->ty == Tpointer && tnext->ty == Tint64))\n-                    errorPrintfFormat(NULL, slice, e, \"core.stdc.stdint.intmax_t*\", t);\n-                break;\n-\n-            case Format_zn:     // pointer to size_t\n-                if (!(t->ty == Tpointer && tnext->isintegral() && tnext->isunsigned() && tnext->size() == ptrsize))\n-                    errorPrintfFormat(NULL, slice, e, \"size_t*\", t);\n-                break;\n-\n-            case Format_tn:     // pointer to ptrdiff_t\n-                if (!(t->ty == Tpointer && tnext->isintegral() && !tnext->isunsigned() && tnext->size() == ptrsize))\n-                    errorPrintfFormat(NULL, slice, e, \"ptrdiff_t*\", t);\n-                break;\n-\n-            case Format_c:      // char\n-                if (t->ty != Tint32 && t->ty != Tuns32)\n-                    errorPrintfFormat(NULL, slice, e, \"char\", t);\n-                break;\n-\n-            case Format_lc:     // wint_t\n-                if (t->ty != Tint32 && t->ty != Tuns32)\n-                    errorPrintfFormat(NULL, slice, e, \"wchar_t\", t);\n-                break;\n-\n-            case Format_s:      // pointer to char string\n-                if (!(t->ty == Tpointer && (tnext->ty == Tchar || tnext->ty == Tint8 || tnext->ty == Tuns8)))\n-                    errorPrintfFormat(NULL, slice, e, \"char*\", t);\n-                break;\n-\n-            case Format_ls:     // pointer to wchar_t string\n-            {\n-                if (!(t->ty == Tpointer && tnext == target.c.twchar_t))\n-                    errorPrintfFormat(NULL, slice, e, \"wchar_t*\", t);\n-                break;\n-            }\n-            case Format_error:\n-                deprecation(loc, \"format specifier `\\\"%.*s\\\"` is invalid\", (int)slice.length, slice.ptr);\n-                break;\n-\n-            case Format_GNU_m:\n-                break;  // not assert(0) because it may go through it if there are extra arguments\n-\n-            case Format_percent:\n-            default:\n-                assert(0);\n-        }\n-    }\n-    return false;\n-}\n-\n-/*******************************************/\n-\n-static Expression *getNextScanfArg(const Loc &loc, Expressions &args, size_t &n, bool asterisk)\n-{\n-    if (n == args.length)\n-    {\n-        if (!asterisk)\n-            deprecation(loc, \"more format specifiers than %d arguments\", (int)n);\n-        return NULL;\n-    }\n-    return args[n++];\n-}\n-\n-static void errorScanfFormat(const char *prefix, DString &slice,\n-                Expression *arg, const char *texpect, Type *tactual)\n-{\n-    deprecation(arg->loc, \"%sargument `%s` for format specification `\\\"%.*s\\\"` must be `%s`, not `%s`\",\n-                prefix ? prefix : \"\", arg->toChars(), (int)slice.length, slice.ptr, texpect, tactual->toChars());\n-}\n-\n-/******************************************\n- * Check that arguments to a scanf format string are compatible\n- * with that string. Issue errors for incompatibilities.\n- *\n- * Follows the C99 specification for scanf.\n- *\n- * Takes a generous, rather than strict, view of compatiblity.\n- * For example, an unsigned value can be formatted with a signed specifier.\n- *\n- * Diagnosed incompatibilities are:\n- *\n- * 1. incompatible sizes which will cause argument misalignment\n- * 2. deferencing arguments that are not pointers\n- * 3. insufficient number of arguments\n- * 4. struct arguments\n- * 5. array and slice arguments\n- * 6. non-standard formats\n- * 7. undefined behavior per C99\n- *\n- * Per the C Standard, extra arguments are ignored.\n- *\n- * No attempt is made to fix the arguments or the format string.\n- *\n- * Params:\n- *      loc = location for error messages\n- *      format = format string\n- *      args = arguments to match with format string\n- *      isVa_list = if a \"v\" function (format check only)\n- *\n- * Returns:\n- *      `true` if errors occurred\n- * References:\n- * C99 7.19.6.2\n- * http://www.cplusplus.com/reference/cstdio/scanf/\n- */\n-bool checkScanfFormat(const Loc &loc, const char *format, Expressions &args, bool isVa_list)\n-{\n-    size_t n = 0;\n-    const size_t format_length = strlen(format);\n-    for (size_t i = 0; i < format_length;)\n-    {\n-        if (format[i] != '%')\n-        {\n-            ++i;\n-            continue;\n-        }\n-        bool asterisk = false;\n-        size_t j = i;\n-        const Format fmt = parseScanfFormatSpecifier(format, j, asterisk);\n-        DString slice = DString(j - i, format + i);\n-        i = j;\n-\n-        if (fmt == Format_percent || asterisk)\n-            continue;   // \"%%\", \"%*\": no arguments\n-\n-        if (isVa_list)\n-        {\n-            // format check only\n-            if (fmt == Format_error)\n-                deprecation(loc, \"format specifier `\\\"%.*s\\\"` is invalid\", (int)slice.length, slice.ptr);\n-            continue;\n-        }\n-\n-        Expression *e = getNextScanfArg(loc, args, n, asterisk);\n-        if (!e)\n-            return true;\n-\n-        Type *t = e->type->toBasetype();\n-        Type *tnext = t->nextOf();\n-        const unsigned c_longsize = target.c.longsize;\n-        const unsigned ptrsize = target.ptrsize;\n-\n-        switch (fmt)\n-        {\n-            case Format_n:\n-            case Format_d:      // pointer to int\n-                if (!(t->ty == Tpointer && tnext->ty == Tint32))\n-                    errorScanfFormat(NULL, slice, e, \"int*\", t);\n-                break;\n-\n-            case Format_hhn:\n-            case Format_hhd:    // pointer to signed char\n-                if (!(t->ty == Tpointer && tnext->ty == Tint16))\n-                    errorScanfFormat(NULL, slice, e, \"byte*\", t);\n-                break;\n-\n-            case Format_hn:\n-            case Format_hd:     // pointer to short\n-                if (!(t->ty == Tpointer && tnext->ty == Tint16))\n-                    errorScanfFormat(NULL, slice, e, \"short*\", t);\n-                break;\n-\n-            case Format_ln:\n-            case Format_ld:     // pointer to long int\n-                if (!(t->ty == Tpointer && tnext->isintegral() && tnext->size() == c_longsize))\n-                    errorScanfFormat(NULL, slice, e, (c_longsize == 4 ? \"int*\" : \"long*\"), t);\n-                break;\n-\n-            case Format_lln:\n-            case Format_lld:    // pointer to long long int\n-                if (!(t->ty == Tpointer && tnext->ty == Tint64))\n-                    errorScanfFormat(NULL, slice, e, \"long*\", t);\n-                break;\n-\n-            case Format_jn:\n-            case Format_jd:     // pointer to intmax_t\n-                if (!(t->ty == Tpointer && tnext->ty == Tint64))\n-                    errorScanfFormat(NULL, slice, e, \"core.stdc.stdint.intmax_t*\", t);\n-                break;\n-\n-            case Format_zn:\n-            case Format_zd:     // pointer to size_t\n-                if (!(t->ty == Tpointer && tnext->isintegral() && tnext->isunsigned() && tnext->size() == ptrsize))\n-                    errorScanfFormat(NULL, slice, e, \"size_t*\", t);\n-                break;\n-\n-            case Format_tn:\n-            case Format_td:     // pointer to ptrdiff_t\n-                if (!(t->ty == Tpointer && tnext->isintegral() && !tnext->isunsigned() && tnext->size() == ptrsize))\n-                    errorScanfFormat(NULL, slice, e, \"ptrdiff_t*\", t);\n-                break;\n-\n-            case Format_u:      // pointer to unsigned int\n-                if (!(t->ty == Tpointer && tnext->ty == Tuns32))\n-                    errorScanfFormat(NULL, slice, e, \"uint*\", t);\n-                break;\n-\n-            case Format_hhu:    // pointer to unsigned char\n-                if (!(t->ty == Tpointer && tnext->ty == Tuns8))\n-                    errorScanfFormat(NULL, slice, e, \"ubyte*\", t);\n-                break;\n-\n-            case Format_hu:     // pointer to unsigned short int\n-                if (!(t->ty == Tpointer && tnext->ty == Tuns16))\n-                    errorScanfFormat(NULL, slice, e, \"ushort*\", t);\n-                break;\n-\n-            case Format_lu:     // pointer to unsigned long int\n-                if (!(t->ty == Tpointer && tnext->isintegral() && tnext->isunsigned() && tnext->size() == c_longsize))\n-                    errorScanfFormat(NULL, slice, e, (c_longsize == 4 ? \"uint*\" : \"ulong*\"), t);\n-                break;\n-\n-            case Format_llu:    // pointer to unsigned long long int\n-                if (!(t->ty == Tpointer && tnext->ty == Tuns64))\n-                    errorScanfFormat(NULL, slice, e, \"ulong*\", t);\n-                break;\n-\n-            case Format_ju:     // pointer to uintmax_t\n-                if (!(t->ty == Tpointer && tnext->ty == Tuns64))\n-                    errorScanfFormat(NULL, slice, e, \"ulong*\", t);\n-                break;\n-\n-            case Format_g:      // pointer to float\n-                if (!(t->ty == Tpointer && tnext->ty == Tfloat32))\n-                    errorScanfFormat(NULL, slice, e, \"float*\", t);\n-                break;\n-\n-            case Format_lg:     // pointer to double\n-                if (!(t->ty == Tpointer && tnext->ty == Tfloat64))\n-                    errorScanfFormat(NULL, slice, e, \"double*\", t);\n-                break;\n-\n-            case Format_Lg:     // pointer to long double\n-                if (!(t->ty == Tpointer && tnext->ty == Tfloat80))\n-                    errorScanfFormat(NULL, slice, e, \"real*\", t);\n-                break;\n-\n-            case Format_GNU_a:\n-            case Format_GNU_m:\n-            case Format_c:\n-            case Format_s:      // pointer to char string\n-                if (!(t->ty == Tpointer && (tnext->ty == Tchar || tnext->ty == Tint8 || tnext->ty == Tuns8)))\n-                    errorScanfFormat(NULL, slice, e, \"char*\", t);\n-                break;\n-\n-            case Format_lc:\n-            case Format_ls:     // pointer to wchar_t string\n-            {\n-                if (!(t->ty == Tpointer && tnext == target.c.twchar_t))\n-                    errorScanfFormat(NULL, slice, e, \"wchar_t*\", t);\n-                break;\n-            }\n-            case Format_p:      // double pointer\n-                if (!(t->ty == Tpointer && tnext->ty == Tpointer))\n-                    errorScanfFormat(NULL, slice, e, \"void**\", t);\n-                break;\n-\n-            case Format_error:\n-                deprecation(loc, \"format specifier `\\\"%.*s\\\"` is invalid\", (int)slice.length, slice.ptr);\n-                break;\n-\n-            case Format_percent:\n-            default:\n-                assert(0);\n-        }\n-    }\n-    return false;\n-}"}, {"sha": "97adc5ad8ac49139b8e68b2f5553ce2874753f27", "filename": "gcc/d/dmd/chkformat.d", "status": "added", "additions": 1364, "deletions": 0, "changes": 1364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fchkformat.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fchkformat.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fchkformat.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -0,0 +1,1364 @@\n+/**\n+ * Check the arguments to `printf` and `scanf` against the `format` string.\n+ *\n+ * Copyright:   Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n+ * Authors:     $(LINK2 http://www.digitalmars.com, Walter Bright)\n+ * License:     $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+ * Source:      $(LINK2 https://github.com/dlang/dmd/blob/master/src/dmd/chkformat.d, _chkformat.d)\n+ * Documentation:  https://dlang.org/phobos/dmd_chkformat.html\n+ * Coverage:    https://codecov.io/gh/dlang/dmd/src/master/src/dmd/chkformat.d\n+ */\n+module dmd.chkformat;\n+\n+//import core.stdc.stdio : printf, scanf;\n+import core.stdc.ctype : isdigit;\n+\n+import dmd.astenums;\n+import dmd.cond;\n+import dmd.errors;\n+import dmd.expression;\n+import dmd.globals;\n+import dmd.identifier;\n+import dmd.mtype;\n+import dmd.target;\n+\n+\n+/******************************************\n+ * Check that arguments to a printf format string are compatible\n+ * with that string. Issue errors for incompatibilities.\n+ *\n+ * Follows the C99 specification for printf.\n+ *\n+ * Takes a generous, rather than strict, view of compatiblity.\n+ * For example, an unsigned value can be formatted with a signed specifier.\n+ *\n+ * Diagnosed incompatibilities are:\n+ *\n+ * 1. incompatible sizes which will cause argument misalignment\n+ * 2. deferencing arguments that are not pointers\n+ * 3. insufficient number of arguments\n+ * 4. struct arguments\n+ * 5. array and slice arguments\n+ * 6. non-pointer arguments to `s` specifier\n+ * 7. non-standard formats\n+ * 8. undefined behavior per C99\n+ *\n+ * Per the C Standard, extra arguments are ignored.\n+ *\n+ * No attempt is made to fix the arguments or the format string.\n+ *\n+ * Params:\n+ *      loc = location for error messages\n+ *      format = format string\n+ *      args = arguments to match with format string\n+ *      isVa_list = if a \"v\" function (format check only)\n+ *\n+ * Returns:\n+ *      `true` if errors occurred\n+ * References:\n+ * C99 7.19.6.1\n+ * http://www.cplusplus.com/reference/cstdio/printf/\n+ */\n+bool checkPrintfFormat(ref const Loc loc, scope const char[] format, scope Expression[] args, bool isVa_list)\n+{\n+    //printf(\"checkPrintFormat('%.*s')\\n\", cast(int)format.length, format.ptr);\n+    size_t n, gnu_m_count;    // index in args / number of Format.GNU_m\n+    for (size_t i = 0; i < format.length;)\n+    {\n+        if (format[i] != '%')\n+        {\n+            ++i;\n+            continue;\n+        }\n+        bool widthStar;\n+        bool precisionStar;\n+        size_t j = i;\n+        const fmt = parsePrintfFormatSpecifier(format, j, widthStar, precisionStar);\n+        const slice = format[i .. j];\n+        i = j;\n+\n+        if (fmt == Format.percent)\n+            continue;                   // \"%%\", no arguments\n+\n+        if (isVa_list)\n+        {\n+            // format check only\n+            if (fmt == Format.error)\n+                deprecation(loc, \"format specifier `\\\"%.*s\\\"` is invalid\", cast(int)slice.length, slice.ptr);\n+            continue;\n+        }\n+\n+        if (fmt == Format.GNU_m)\n+            ++gnu_m_count;\n+\n+        Expression getNextArg(ref bool skip)\n+        {\n+            if (n == args.length)\n+            {\n+                if (args.length < (n + 1) - gnu_m_count)\n+                    deprecation(loc, \"more format specifiers than %d arguments\", cast(int)n);\n+                else\n+                    skip = true;\n+                return null;\n+            }\n+            return args[n++];\n+        }\n+\n+        void errorMsg(const char* prefix, Expression arg, const char* texpect, Type tactual)\n+        {\n+            deprecation(arg.loc, \"%sargument `%s` for format specification `\\\"%.*s\\\"` must be `%s`, not `%s`\",\n+                  prefix ? prefix : \"\", arg.toChars(), cast(int)slice.length, slice.ptr, texpect, tactual.toChars());\n+        }\n+\n+        if (widthStar)\n+        {\n+            bool skip;\n+            auto e = getNextArg(skip);\n+            if (skip)\n+                continue;\n+            if (!e)\n+                return true;\n+            auto t = e.type.toBasetype();\n+            if (t.ty != Tint32 && t.ty != Tuns32)\n+                errorMsg(\"width \", e, \"int\", t);\n+        }\n+\n+        if (precisionStar)\n+        {\n+            bool skip;\n+            auto e = getNextArg(skip);\n+            if (skip)\n+                continue;\n+            if (!e)\n+                return true;\n+            auto t = e.type.toBasetype();\n+            if (t.ty != Tint32 && t.ty != Tuns32)\n+                errorMsg(\"precision \", e, \"int\", t);\n+        }\n+\n+        bool skip;\n+        auto e = getNextArg(skip);\n+        if (skip)\n+            continue;\n+        if (!e)\n+            return true;\n+        auto t = e.type.toBasetype();\n+        auto tnext = t.nextOf();\n+        const c_longsize = target.c.longsize;\n+        const ptrsize = target.ptrsize;\n+\n+        // Types which are promoted to int are allowed.\n+        // Spec: C99 6.5.2.2.7\n+        final switch (fmt)\n+        {\n+            case Format.u:      // unsigned int\n+            case Format.d:      // int\n+                if (t.ty != Tint32 && t.ty != Tuns32)\n+                    errorMsg(null, e, fmt == Format.u ? \"uint\" : \"int\", t);\n+                break;\n+\n+            case Format.hhu:    // unsigned char\n+            case Format.hhd:    // signed char\n+                if (t.ty != Tint32 && t.ty != Tuns32 && t.ty != Tint8 && t.ty != Tuns8)\n+                    errorMsg(null, e, fmt == Format.hhu ? \"ubyte\" : \"byte\", t);\n+                break;\n+\n+            case Format.hu:     // unsigned short int\n+            case Format.hd:     // short int\n+                if (t.ty != Tint32 && t.ty != Tuns32 && t.ty != Tint16 && t.ty != Tuns16)\n+                    errorMsg(null, e, fmt == Format.hu ? \"ushort\" : \"short\", t);\n+                break;\n+\n+            case Format.lu:     // unsigned long int\n+            case Format.ld:     // long int\n+                if (!(t.isintegral() && t.size() == c_longsize))\n+                {\n+                    if (fmt == Format.lu)\n+                        errorMsg(null, e, (c_longsize == 4 ? \"uint\" : \"ulong\"), t);\n+                    else\n+                        errorMsg(null, e, (c_longsize == 4 ? \"int\" : \"long\"), t);\n+                }\n+                break;\n+\n+            case Format.llu:    // unsigned long long int\n+            case Format.lld:    // long long int\n+                if (t.ty != Tint64 && t.ty != Tuns64)\n+                    errorMsg(null, e, fmt == Format.llu ? \"ulong\" : \"long\", t);\n+                break;\n+\n+            case Format.ju:     // uintmax_t\n+            case Format.jd:     // intmax_t\n+                if (t.ty != Tint64 && t.ty != Tuns64)\n+                {\n+                    if (fmt == Format.ju)\n+                        errorMsg(null, e, \"core.stdc.stdint.uintmax_t\", t);\n+                    else\n+                        errorMsg(null, e, \"core.stdc.stdint.intmax_t\", t);\n+                }\n+                break;\n+\n+            case Format.zd:     // size_t\n+                if (!(t.isintegral() && t.size() == ptrsize))\n+                    errorMsg(null, e, \"size_t\", t);\n+                break;\n+\n+            case Format.td:     // ptrdiff_t\n+                if (!(t.isintegral() && t.size() == ptrsize))\n+                    errorMsg(null, e, \"ptrdiff_t\", t);\n+                break;\n+\n+            case Format.GNU_a:  // Format.GNU_a is only for scanf\n+            case Format.lg:\n+            case Format.g:      // double\n+                if (t.ty != Tfloat64 && t.ty != Timaginary64)\n+                    errorMsg(null, e, \"double\", t);\n+                break;\n+\n+            case Format.Lg:     // long double\n+                if (t.ty != Tfloat80 && t.ty != Timaginary80)\n+                    errorMsg(null, e, \"real\", t);\n+                break;\n+\n+            case Format.p:      // pointer\n+                if (t.ty != Tpointer && t.ty != Tnull && t.ty != Tclass && t.ty != Tdelegate && t.ty != Taarray)\n+                    errorMsg(null, e, \"void*\", t);\n+                break;\n+\n+            case Format.n:      // pointer to int\n+                if (!(t.ty == Tpointer && tnext.ty == Tint32))\n+                    errorMsg(null, e, \"int*\", t);\n+                break;\n+\n+            case Format.ln:     // pointer to long int\n+                if (!(t.ty == Tpointer && tnext.isintegral() && tnext.size() == c_longsize))\n+                    errorMsg(null, e, (c_longsize == 4 ? \"int*\" : \"long*\"), t);\n+                break;\n+\n+            case Format.lln:    // pointer to long long int\n+                if (!(t.ty == Tpointer && tnext.ty == Tint64))\n+                    errorMsg(null, e, \"long*\", t);\n+                break;\n+\n+            case Format.hn:     // pointer to short\n+                if (!(t.ty == Tpointer && tnext.ty == Tint16))\n+                    errorMsg(null, e, \"short*\", t);\n+                break;\n+\n+            case Format.hhn:    // pointer to signed char\n+                if (!(t.ty == Tpointer && tnext.ty == Tint16))\n+                    errorMsg(null, e, \"byte*\", t);\n+                break;\n+\n+            case Format.jn:     // pointer to intmax_t\n+                if (!(t.ty == Tpointer && tnext.ty == Tint64))\n+                    errorMsg(null, e, \"core.stdc.stdint.intmax_t*\", t);\n+                break;\n+\n+            case Format.zn:     // pointer to size_t\n+                if (!(t.ty == Tpointer && tnext.isintegral() && tnext.isunsigned() && tnext.size() == ptrsize))\n+                    errorMsg(null, e, \"size_t*\", t);\n+                break;\n+\n+            case Format.tn:     // pointer to ptrdiff_t\n+                if (!(t.ty == Tpointer && tnext.isintegral() && !tnext.isunsigned() && tnext.size() == ptrsize))\n+                    errorMsg(null, e, \"ptrdiff_t*\", t);\n+                break;\n+\n+            case Format.c:      // char\n+                if (t.ty != Tint32 && t.ty != Tuns32)\n+                    errorMsg(null, e, \"char\", t);\n+                break;\n+\n+            case Format.lc:     // wint_t\n+                if (t.ty != Tint32 && t.ty != Tuns32)\n+                    errorMsg(null, e, \"wchar_t\", t);\n+                break;\n+\n+            case Format.s:      // pointer to char string\n+                if (!(t.ty == Tpointer && (tnext.ty == Tchar || tnext.ty == Tint8 || tnext.ty == Tuns8)))\n+                    errorMsg(null, e, \"char*\", t);\n+                break;\n+\n+            case Format.ls:     // pointer to wchar_t string\n+                if (!(t.ty == Tpointer && tnext.ty.isSomeChar && tnext.size() == target.c.wchar_tsize))\n+                    errorMsg(null, e, \"wchar_t*\", t);\n+                break;\n+\n+            case Format.error:\n+                deprecation(loc, \"format specifier `\\\"%.*s\\\"` is invalid\", cast(int)slice.length, slice.ptr);\n+                break;\n+\n+            case Format.GNU_m:\n+                break;  // not assert(0) because it may go through it if there are extra arguments\n+\n+            case Format.percent:\n+                assert(0);\n+        }\n+    }\n+    return false;\n+}\n+\n+/******************************************\n+ * Check that arguments to a scanf format string are compatible\n+ * with that string. Issue errors for incompatibilities.\n+ *\n+ * Follows the C99 specification for scanf.\n+ *\n+ * Takes a generous, rather than strict, view of compatiblity.\n+ * For example, an unsigned value can be formatted with a signed specifier.\n+ *\n+ * Diagnosed incompatibilities are:\n+ *\n+ * 1. incompatible sizes which will cause argument misalignment\n+ * 2. deferencing arguments that are not pointers\n+ * 3. insufficient number of arguments\n+ * 4. struct arguments\n+ * 5. array and slice arguments\n+ * 6. non-standard formats\n+ * 7. undefined behavior per C99\n+ *\n+ * Per the C Standard, extra arguments are ignored.\n+ *\n+ * No attempt is made to fix the arguments or the format string.\n+ *\n+ * Params:\n+ *      loc = location for error messages\n+ *      format = format string\n+ *      args = arguments to match with format string\n+ *      isVa_list = if a \"v\" function (format check only)\n+ *\n+ * Returns:\n+ *      `true` if errors occurred\n+ * References:\n+ * C99 7.19.6.2\n+ * http://www.cplusplus.com/reference/cstdio/scanf/\n+ */\n+bool checkScanfFormat(ref const Loc loc, scope const char[] format, scope Expression[] args, bool isVa_list)\n+{\n+    size_t n = 0;\n+    for (size_t i = 0; i < format.length;)\n+    {\n+        if (format[i] != '%')\n+        {\n+            ++i;\n+            continue;\n+        }\n+        bool asterisk;\n+        size_t j = i;\n+        const fmt = parseScanfFormatSpecifier(format, j, asterisk);\n+        const slice = format[i .. j];\n+        i = j;\n+\n+        if (fmt == Format.percent || asterisk)\n+            continue;   // \"%%\", \"%*\": no arguments\n+\n+        if (isVa_list)\n+        {\n+            // format check only\n+            if (fmt == Format.error)\n+                deprecation(loc, \"format specifier `\\\"%.*s\\\"` is invalid\", cast(int)slice.length, slice.ptr);\n+            continue;\n+        }\n+\n+        Expression getNextArg()\n+        {\n+            if (n == args.length)\n+            {\n+                if (!asterisk)\n+                    deprecation(loc, \"more format specifiers than %d arguments\", cast(int)n);\n+                return null;\n+            }\n+            return args[n++];\n+        }\n+\n+        void errorMsg(const char* prefix, Expression arg, const char* texpect, Type tactual)\n+        {\n+            deprecation(arg.loc, \"%sargument `%s` for format specification `\\\"%.*s\\\"` must be `%s`, not `%s`\",\n+                  prefix ? prefix : \"\", arg.toChars(), cast(int)slice.length, slice.ptr, texpect, tactual.toChars());\n+        }\n+\n+        auto e = getNextArg();\n+        if (!e)\n+            return true;\n+\n+        auto t = e.type.toBasetype();\n+        auto tnext = t.nextOf();\n+        const c_longsize = target.c.longsize;\n+        const ptrsize = target.ptrsize;\n+\n+        final switch (fmt)\n+        {\n+            case Format.n:\n+            case Format.d:      // pointer to int\n+                if (!(t.ty == Tpointer && tnext.ty == Tint32))\n+                    errorMsg(null, e, \"int*\", t);\n+                break;\n+\n+            case Format.hhn:\n+            case Format.hhd:    // pointer to signed char\n+                if (!(t.ty == Tpointer && tnext.ty == Tint16))\n+                    errorMsg(null, e, \"byte*\", t);\n+                break;\n+\n+            case Format.hn:\n+            case Format.hd:     // pointer to short\n+                if (!(t.ty == Tpointer && tnext.ty == Tint16))\n+                    errorMsg(null, e, \"short*\", t);\n+                break;\n+\n+            case Format.ln:\n+            case Format.ld:     // pointer to long int\n+                if (!(t.ty == Tpointer && tnext.isintegral() && !tnext.isunsigned() && tnext.size() == c_longsize))\n+                    errorMsg(null, e, (c_longsize == 4 ? \"int*\" : \"long*\"), t);\n+                break;\n+\n+            case Format.lln:\n+            case Format.lld:    // pointer to long long int\n+                if (!(t.ty == Tpointer && tnext.ty == Tint64))\n+                    errorMsg(null, e, \"long*\", t);\n+                break;\n+\n+            case Format.jn:\n+            case Format.jd:     // pointer to intmax_t\n+                if (!(t.ty == Tpointer && tnext.ty == Tint64))\n+                    errorMsg(null, e, \"core.stdc.stdint.intmax_t*\", t);\n+                break;\n+\n+            case Format.zn:\n+            case Format.zd:     // pointer to size_t\n+                if (!(t.ty == Tpointer && tnext.isintegral() && tnext.isunsigned() && tnext.size() == ptrsize))\n+                    errorMsg(null, e, \"size_t*\", t);\n+                break;\n+\n+            case Format.tn:\n+            case Format.td:     // pointer to ptrdiff_t\n+                if (!(t.ty == Tpointer && tnext.isintegral() && !tnext.isunsigned() && tnext.size() == ptrsize))\n+                    errorMsg(null, e, \"ptrdiff_t*\", t);\n+                break;\n+\n+            case Format.u:      // pointer to unsigned int\n+                if (!(t.ty == Tpointer && tnext.ty == Tuns32))\n+                    errorMsg(null, e, \"uint*\", t);\n+                break;\n+\n+            case Format.hhu:    // pointer to unsigned char\n+                if (!(t.ty == Tpointer && tnext.ty == Tuns8))\n+                    errorMsg(null, e, \"ubyte*\", t);\n+                break;\n+\n+            case Format.hu:     // pointer to unsigned short int\n+                if (!(t.ty == Tpointer && tnext.ty == Tuns16))\n+                    errorMsg(null, e, \"ushort*\", t);\n+                break;\n+\n+            case Format.lu:     // pointer to unsigned long int\n+                if (!(t.ty == Tpointer && tnext.isintegral() && tnext.isunsigned() && tnext.size() == c_longsize))\n+                    errorMsg(null, e, (c_longsize == 4 ? \"uint*\" : \"ulong*\"), t);\n+                break;\n+\n+            case Format.llu:    // pointer to unsigned long long int\n+                if (!(t.ty == Tpointer && tnext.ty == Tuns64))\n+                    errorMsg(null, e, \"ulong*\", t);\n+                break;\n+\n+            case Format.ju:     // pointer to uintmax_t\n+                if (!(t.ty == Tpointer && tnext.ty == Tuns64))\n+                    errorMsg(null, e, \"core.stdc.stdint.uintmax_t*\", t);\n+                break;\n+\n+            case Format.g:      // pointer to float\n+                if (!(t.ty == Tpointer && tnext.ty == Tfloat32))\n+                    errorMsg(null, e, \"float*\", t);\n+                break;\n+\n+            case Format.lg:     // pointer to double\n+                if (!(t.ty == Tpointer && tnext.ty == Tfloat64))\n+                    errorMsg(null, e, \"double*\", t);\n+                break;\n+\n+            case Format.Lg:     // pointer to long double\n+                if (!(t.ty == Tpointer && tnext.ty == Tfloat80))\n+                    errorMsg(null, e, \"real*\", t);\n+                break;\n+\n+            case Format.GNU_a:\n+            case Format.GNU_m:\n+            case Format.c:\n+            case Format.s:      // pointer to char string\n+                if (!(t.ty == Tpointer && (tnext.ty == Tchar || tnext.ty == Tint8 || tnext.ty == Tuns8)))\n+                    errorMsg(null, e, \"char*\", t);\n+                break;\n+\n+            case Format.lc:\n+            case Format.ls:     // pointer to wchar_t string\n+                if (!(t.ty == Tpointer && tnext.ty.isSomeChar && tnext.size() == target.c.wchar_tsize))\n+                    errorMsg(null, e, \"wchar_t*\", t);\n+                break;\n+\n+            case Format.p:      // double pointer\n+                if (!(t.ty == Tpointer && tnext.ty == Tpointer))\n+                    errorMsg(null, e, \"void**\", t);\n+                break;\n+\n+            case Format.error:\n+                deprecation(loc, \"format specifier `\\\"%.*s\\\"` is invalid\", cast(int)slice.length, slice.ptr);\n+                break;\n+\n+            case Format.percent:\n+                assert(0);\n+        }\n+    }\n+    return false;\n+}\n+\n+private:\n+\n+/**************************************\n+ * Parse the *format specifier* which is of the form:\n+ *\n+ * `%[*][width][length]specifier`\n+ *\n+ * Params:\n+ *      format = format string\n+ *      idx = index of `%` of start of format specifier,\n+ *          which gets updated to index past the end of it,\n+ *          even if `Format.error` is returned\n+ *      asterisk = set if there is a `*` sub-specifier\n+ * Returns:\n+ *      Format\n+ */\n+Format parseScanfFormatSpecifier(scope const char[] format, ref size_t idx,\n+        out bool asterisk) nothrow pure @safe\n+{\n+    auto i = idx;\n+    assert(format[i] == '%');\n+    const length = format.length;\n+\n+    Format error()\n+    {\n+        idx = i;\n+        return Format.error;\n+    }\n+\n+    ++i;\n+    if (i == length)\n+        return error();\n+\n+    if (format[i] == '%')\n+    {\n+        idx = i + 1;\n+        return Format.percent;\n+    }\n+\n+    // * sub-specifier\n+    if (format[i] == '*')\n+    {\n+        ++i;\n+        if (i == length)\n+            return error();\n+        asterisk = true;\n+    }\n+\n+    // fieldWidth\n+    while (isdigit(format[i]))\n+    {\n+        i++;\n+        if (i == length)\n+            return error();\n+    }\n+\n+    /* Read the scanset\n+     * A scanset can be anything, so we just check that it is paired\n+     */\n+    if (format[i] == '[')\n+    {\n+        while (i < length)\n+        {\n+            if (format[i] == ']')\n+                break;\n+            ++i;\n+        }\n+\n+        // no `]` found\n+        if (i == length)\n+            return error();\n+\n+        ++i;\n+        // no specifier after `]`\n+        // it could be mixed with the one above, but then idx won't have the right index\n+        if (i == length)\n+            return error();\n+    }\n+\n+    /* Read the specifier\n+     */\n+    char genSpec;\n+    Format specifier = parseGenericFormatSpecifier(format, i, genSpec);\n+    if (specifier == Format.error)\n+        return error();\n+\n+    idx = i;\n+    return specifier;  // success\n+}\n+\n+/**************************************\n+ * Parse the *format specifier* which is of the form:\n+ *\n+ * `%[flags][field width][.precision][length modifier]specifier`\n+ *\n+ * Params:\n+ *      format = format string\n+ *      idx = index of `%` of start of format specifier,\n+ *          which gets updated to index past the end of it,\n+ *          even if `Format.error` is returned\n+ *      widthStar = set if * for width\n+ *      precisionStar = set if * for precision\n+ * Returns:\n+ *      Format\n+ */\n+Format parsePrintfFormatSpecifier(scope const char[] format, ref size_t idx,\n+        out bool widthStar, out bool precisionStar) nothrow pure @safe\n+{\n+    auto i = idx;\n+    assert(format[i] == '%');\n+    const length = format.length;\n+    bool hash;\n+    bool zero;\n+    bool flags;\n+    bool width;\n+    bool precision;\n+\n+    Format error()\n+    {\n+        idx = i;\n+        return Format.error;\n+    }\n+\n+    ++i;\n+    if (i == length)\n+        return error();\n+\n+    if (format[i] == '%')\n+    {\n+        idx = i + 1;\n+        return Format.percent;\n+    }\n+\n+    /* Read the `flags`\n+     */\n+    while (1)\n+    {\n+        const c = format[i];\n+        if (c == '-' ||\n+            c == '+' ||\n+            c == ' ')\n+        {\n+            flags = true;\n+        }\n+        else if (c == '#')\n+        {\n+            hash = true;\n+        }\n+        else if (c == '0')\n+        {\n+            zero = true;\n+        }\n+        else\n+            break;\n+        ++i;\n+        if (i == length)\n+            return error();\n+    }\n+\n+    /* Read the `field width`\n+     */\n+    {\n+        const c = format[i];\n+        if (c == '*')\n+        {\n+            width = true;\n+            widthStar = true;\n+            ++i;\n+            if (i == length)\n+                return error();\n+        }\n+        else if ('1' <= c && c <= '9')\n+        {\n+            width = true;\n+            ++i;\n+            if (i == length)\n+                return error();\n+            while ('0' <= format[i] && format[i] <= '9')\n+            {\n+               ++i;\n+               if (i == length)\n+                    return error();\n+            }\n+        }\n+    }\n+\n+    /* Read the `precision`\n+     */\n+    if (format[i] == '.')\n+    {\n+        precision = true;\n+        ++i;\n+        if (i == length)\n+            return error();\n+        const c = format[i];\n+        if (c == '*')\n+        {\n+            precisionStar = true;\n+            ++i;\n+            if (i == length)\n+                return error();\n+        }\n+        else if ('0' <= c && c <= '9')\n+        {\n+            ++i;\n+            if (i == length)\n+                return error();\n+            while ('0' <= format[i] && format[i] <= '9')\n+            {\n+               ++i;\n+               if (i == length)\n+                    return error();\n+            }\n+        }\n+    }\n+\n+    /* Read the specifier\n+     */\n+    char genSpec;\n+    Format specifier = parseGenericFormatSpecifier(format, i, genSpec);\n+    if (specifier == Format.error)\n+        return error();\n+\n+    switch (genSpec)\n+    {\n+        case 'c':\n+        case 's':\n+            if (hash || zero)\n+                return error();\n+            break;\n+\n+        case 'd':\n+        case 'i':\n+            if (hash)\n+                return error();\n+            break;\n+\n+        case 'n':\n+            if (hash || zero || precision || width || flags)\n+                return error();\n+            break;\n+\n+        default:\n+            break;\n+    }\n+\n+    idx = i;\n+    return specifier;  // success\n+}\n+\n+/* Different kinds of formatting specifications, variations we don't\n+   care about are merged. (Like we don't care about the difference between\n+   f, e, g, a, etc.)\n+\n+   For `scanf`, every format is a pointer.\n+ */\n+enum Format\n+{\n+    d,          // int\n+    hhd,        // signed char\n+    hd,         // short int\n+    ld,         // long int\n+    lld,        // long long int\n+    jd,         // intmax_t\n+    zd,         // size_t\n+    td,         // ptrdiff_t\n+    u,          // unsigned int\n+    hhu,        // unsigned char\n+    hu,         // unsigned short int\n+    lu,         // unsigned long int\n+    llu,        // unsigned long long int\n+    ju,         // uintmax_t\n+    g,          // float (scanf) / double (printf)\n+    lg,         // double (scanf)\n+    Lg,         // long double (both)\n+    s,          // char string (both)\n+    ls,         // wchar_t string (both)\n+    c,          // char (printf)\n+    lc,         // wint_t (printf)\n+    p,          // pointer\n+    n,          // pointer to int\n+    hhn,        // pointer to signed char\n+    hn,         // pointer to short\n+    ln,         // pointer to long int\n+    lln,        // pointer to long long int\n+    jn,         // pointer to intmax_t\n+    zn,         // pointer to size_t\n+    tn,         // pointer to ptrdiff_t\n+    GNU_a,      // GNU ext. : address to a string with no maximum size (scanf)\n+    GNU_m,      // GNU ext. : string corresponding to the error code in errno (printf) / length modifier (scanf)\n+    percent,    // %% (i.e. no argument)\n+    error,      // invalid format specification\n+}\n+\n+/**************************************\n+ * Parse the *length specifier* and the *specifier* of the following form:\n+ * `[length]specifier`\n+ *\n+ * Params:\n+ *      format = format string\n+ *      idx = index of of start of format specifier,\n+ *          which gets updated to index past the end of it,\n+ *          even if `Format.error` is returned\n+ *      genSpecifier = Generic specifier. For instance, it will be set to `d` if the\n+ *           format is `hdd`.\n+ * Returns:\n+ *      Format\n+ */\n+Format parseGenericFormatSpecifier(scope const char[] format,\n+    ref size_t idx, out char genSpecifier, bool useGNUExts =\n+    findCondition(global.versionids, Identifier.idPool(\"CRuntime_Glibc\"))) nothrow pure @trusted\n+{\n+    const length = format.length;\n+\n+    /* Read the `length modifier`\n+     */\n+    const lm = format[idx];\n+    bool lm1;        // if jztL\n+    bool lm2;        // if `hh` or `ll`\n+    if (lm == 'j' ||\n+        lm == 'z' ||\n+        lm == 't' ||\n+        lm == 'L')\n+    {\n+        ++idx;\n+        if (idx == length)\n+            return Format.error;\n+        lm1 = true;\n+    }\n+    else if (lm == 'h' || lm == 'l')\n+    {\n+        ++idx;\n+        if (idx == length)\n+            return Format.error;\n+        lm2 = lm == format[idx];\n+        if (lm2)\n+        {\n+            ++idx;\n+            if (idx == length)\n+                return Format.error;\n+        }\n+    }\n+\n+    /* Read the `specifier`\n+     */\n+    Format specifier;\n+    const sc = format[idx];\n+    genSpecifier = sc;\n+    switch (sc)\n+    {\n+        case 'd':\n+        case 'i':\n+            if (lm == 'L')\n+                specifier = Format.error;\n+            else\n+                specifier = lm == 'h' && lm2 ? Format.hhd :\n+                            lm == 'h'        ? Format.hd  :\n+                            lm == 'l' && lm2 ? Format.lld :\n+                            lm == 'l'        ? Format.ld  :\n+                            lm == 'j'        ? Format.jd  :\n+                            lm == 'z'        ? Format.zd  :\n+                            lm == 't'        ? Format.td  :\n+                                               Format.d;\n+            break;\n+\n+        case 'u':\n+        case 'o':\n+        case 'x':\n+        case 'X':\n+            if (lm == 'L')\n+                specifier = Format.error;\n+            else\n+                specifier = lm == 'h' && lm2 ? Format.hhu :\n+                            lm == 'h'        ? Format.hu  :\n+                            lm == 'l' && lm2 ? Format.llu :\n+                            lm == 'l'        ? Format.lu  :\n+                            lm == 'j'        ? Format.ju  :\n+                            lm == 'z'        ? Format.zd  :\n+                            lm == 't'        ? Format.td  :\n+                                               Format.u;\n+            break;\n+\n+        case 'a':\n+            if (useGNUExts)\n+            {\n+                // https://www.gnu.org/software/libc/manual/html_node/Dynamic-String-Input.html\n+                specifier = Format.GNU_a;\n+                break;\n+            }\n+            goto case;\n+\n+        case 'f':\n+        case 'F':\n+        case 'e':\n+        case 'E':\n+        case 'g':\n+        case 'G':\n+        case 'A':\n+            if (lm == 'L')\n+                specifier = Format.Lg;\n+            else if (lm1 || lm2 || lm == 'h')\n+                specifier = Format.error;\n+            else\n+                specifier = lm == 'l' ? Format.lg : Format.g;\n+            break;\n+\n+        case 'c':\n+            if (lm1 || lm2 || lm == 'h')\n+                specifier = Format.error;\n+            else\n+                specifier = lm == 'l' ? Format.lc : Format.c;\n+            break;\n+\n+        case 's':\n+            if (lm1 || lm2 || lm == 'h')\n+                specifier = Format.error;\n+            else\n+                specifier = lm == 'l' ? Format.ls : Format.s;\n+            break;\n+\n+        case 'p':\n+            if (lm1 || lm2 || lm == 'h' || lm == 'l')\n+                specifier = Format.error;\n+            else\n+                specifier = Format.p;\n+            break;\n+\n+        case 'n':\n+            if (lm == 'L')\n+                specifier = Format.error;\n+            else\n+                specifier = lm == 'l' && lm2 ? Format.lln :\n+                            lm == 'l'        ? Format.ln  :\n+                            lm == 'h' && lm2 ? Format.hhn :\n+                            lm == 'h'        ? Format.hn  :\n+                            lm == 'j'        ? Format.jn  :\n+                            lm == 'z'        ? Format.zn  :\n+                            lm == 't'        ? Format.tn  :\n+                                               Format.n;\n+            break;\n+\n+        case 'm':\n+            if (useGNUExts)\n+            {\n+                // http://www.gnu.org/software/libc/manual/html_node/Other-Output-Conversions.html\n+                specifier = Format.GNU_m;\n+                break;\n+            }\n+            goto default;\n+\n+        default:\n+            specifier = Format.error;\n+            break;\n+    }\n+\n+    ++idx;\n+    return specifier; // success\n+}\n+\n+unittest\n+{\n+    /* parseGenericFormatSpecifier\n+     */\n+\n+    char genSpecifier;\n+    size_t idx;\n+\n+    assert(parseGenericFormatSpecifier(\"hhd\", idx, genSpecifier) == Format.hhd);\n+    assert(genSpecifier == 'd');\n+\n+    idx = 0;\n+    assert(parseGenericFormatSpecifier(\"hn\", idx, genSpecifier) == Format.hn);\n+    assert(genSpecifier == 'n');\n+\n+    idx = 0;\n+    assert(parseGenericFormatSpecifier(\"ji\", idx, genSpecifier) == Format.jd);\n+    assert(genSpecifier == 'i');\n+\n+    idx = 0;\n+    assert(parseGenericFormatSpecifier(\"lu\", idx, genSpecifier) == Format.lu);\n+    assert(genSpecifier == 'u');\n+\n+    idx = 0;\n+    assert(parseGenericFormatSpecifier(\"k\", idx, genSpecifier) == Format.error);\n+\n+    /* parsePrintfFormatSpecifier\n+     */\n+\n+     bool widthStar;\n+     bool precisionStar;\n+\n+     // one for each Format\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%d\", idx, widthStar, precisionStar) == Format.d);\n+     assert(idx == 2);\n+     assert(!widthStar && !precisionStar);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%ld\", idx, widthStar, precisionStar) == Format.ld);\n+     assert(idx == 3);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%lld\", idx, widthStar, precisionStar) == Format.lld);\n+     assert(idx == 4);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%jd\", idx, widthStar, precisionStar) == Format.jd);\n+     assert(idx == 3);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%zd\", idx, widthStar, precisionStar) == Format.zd);\n+     assert(idx == 3);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%td\", idx, widthStar, precisionStar) == Format.td);\n+     assert(idx == 3);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%g\", idx, widthStar, precisionStar) == Format.g);\n+     assert(idx == 2);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%Lg\", idx, widthStar, precisionStar) == Format.Lg);\n+     assert(idx == 3);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%p\", idx, widthStar, precisionStar) == Format.p);\n+     assert(idx == 2);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%n\", idx, widthStar, precisionStar) == Format.n);\n+     assert(idx == 2);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%ln\", idx, widthStar, precisionStar) == Format.ln);\n+     assert(idx == 3);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%lln\", idx, widthStar, precisionStar) == Format.lln);\n+     assert(idx == 4);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%hn\", idx, widthStar, precisionStar) == Format.hn);\n+     assert(idx == 3);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%hhn\", idx, widthStar, precisionStar) == Format.hhn);\n+     assert(idx == 4);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%jn\", idx, widthStar, precisionStar) == Format.jn);\n+     assert(idx == 3);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%zn\", idx, widthStar, precisionStar) == Format.zn);\n+     assert(idx == 3);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%tn\", idx, widthStar, precisionStar) == Format.tn);\n+     assert(idx == 3);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%c\", idx, widthStar, precisionStar) == Format.c);\n+     assert(idx == 2);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%lc\", idx, widthStar, precisionStar) == Format.lc);\n+     assert(idx == 3);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%s\", idx, widthStar, precisionStar) == Format.s);\n+     assert(idx == 2);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%ls\", idx, widthStar, precisionStar) == Format.ls);\n+     assert(idx == 3);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%%\", idx, widthStar, precisionStar) == Format.percent);\n+     assert(idx == 2);\n+\n+     // Synonyms\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%i\", idx, widthStar, precisionStar) == Format.d);\n+     assert(idx == 2);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%u\", idx, widthStar, precisionStar) == Format.u);\n+     assert(idx == 2);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%o\", idx, widthStar, precisionStar) == Format.u);\n+     assert(idx == 2);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%x\", idx, widthStar, precisionStar) == Format.u);\n+     assert(idx == 2);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%X\", idx, widthStar, precisionStar) == Format.u);\n+     assert(idx == 2);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%f\", idx, widthStar, precisionStar) == Format.g);\n+     assert(idx == 2);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%F\", idx, widthStar, precisionStar) == Format.g);\n+     assert(idx == 2);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%G\", idx, widthStar, precisionStar) == Format.g);\n+     assert(idx == 2);\n+\n+     idx = 0;\n+     Format g = parsePrintfFormatSpecifier(\"%a\", idx, widthStar, precisionStar);\n+     assert(g == Format.g || g == Format.GNU_a);\n+     assert(idx == 2);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%A\", idx, widthStar, precisionStar) == Format.g);\n+     assert(idx == 2);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%lg\", idx, widthStar, precisionStar) == Format.lg);\n+     assert(idx == 3);\n+\n+     // width, precision\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%*d\", idx, widthStar, precisionStar) == Format.d);\n+     assert(idx == 3);\n+     assert(widthStar && !precisionStar);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%.*d\", idx, widthStar, precisionStar) == Format.d);\n+     assert(idx == 4);\n+     assert(!widthStar && precisionStar);\n+\n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%*.*d\", idx, widthStar, precisionStar) == Format.d);\n+     assert(idx == 5);\n+     assert(widthStar && precisionStar);\n+\n+     // Too short formats\n+     {\n+         foreach (s; [\"%\", \"%-\", \"%+\", \"% \", \"%#\", \"%0\", \"%*\", \"%1\", \"%19\", \"%.\", \"%.*\", \"%.1\", \"%.12\",\n+                      \"%j\", \"%z\", \"%t\", \"%l\", \"%h\", \"%ll\", \"%hh\"])\n+         {\n+             idx = 0;\n+             assert(parsePrintfFormatSpecifier(s, idx, widthStar, precisionStar) == Format.error);\n+             assert(idx == s.length);\n+         }\n+     }\n+\n+     // Undefined format combinations\n+     {\n+         foreach (s; [\"%#d\", \"%llg\", \"%jg\", \"%zg\", \"%tg\", \"%hg\", \"%hhg\",\n+                      \"%#c\", \"%0c\", \"%jc\", \"%zc\", \"%tc\", \"%Lc\", \"%hc\", \"%hhc\", \"%llc\",\n+                      \"%#s\", \"%0s\", \"%js\", \"%zs\", \"%ts\", \"%Ls\", \"%hs\", \"%hhs\", \"%lls\",\n+                      \"%jp\", \"%zp\", \"%tp\", \"%Lp\", \"%hp\", \"%lp\", \"%hhp\", \"%llp\",\n+                      \"%-n\", \"%+n\", \"% n\", \"%#n\", \"%0n\", \"%*n\", \"%1n\", \"%19n\", \"%.n\", \"%.*n\", \"%.1n\", \"%.12n\", \"%Ln\", \"%K\"])\n+         {\n+             idx = 0;\n+             assert(parsePrintfFormatSpecifier(s, idx, widthStar, precisionStar) == Format.error);\n+             assert(idx == s.length);\n+         }\n+     }\n+\n+    /* parseScanfFormatSpecifier\n+     */\n+\n+    bool asterisk;\n+\n+    // one for each Format\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%d\", idx, asterisk) == Format.d);\n+    assert(idx == 2);\n+    assert(!asterisk);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%hhd\", idx, asterisk) == Format.hhd);\n+    assert(idx == 4);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%hd\", idx, asterisk) == Format.hd);\n+    assert(idx == 3);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%ld\", idx, asterisk) == Format.ld);\n+    assert(idx == 3);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%lld\", idx, asterisk) == Format.lld);\n+    assert(idx == 4);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%jd\", idx, asterisk) == Format.jd);\n+    assert(idx == 3);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%zd\", idx, asterisk) == Format.zd);\n+    assert(idx == 3);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%td\", idx, asterisk,) == Format.td);\n+    assert(idx == 3);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%u\", idx, asterisk) == Format.u);\n+    assert(idx == 2);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%hhu\", idx, asterisk,) == Format.hhu);\n+    assert(idx == 4);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%hu\", idx, asterisk) == Format.hu);\n+    assert(idx == 3);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%lu\", idx, asterisk) == Format.lu);\n+    assert(idx == 3);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%llu\", idx, asterisk) == Format.llu);\n+    assert(idx == 4);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%ju\", idx, asterisk) == Format.ju);\n+    assert(idx == 3);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%g\", idx, asterisk) == Format.g);\n+    assert(idx == 2);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%lg\", idx, asterisk) == Format.lg);\n+    assert(idx == 3);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%Lg\", idx, asterisk) == Format.Lg);\n+    assert(idx == 3);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%p\", idx, asterisk) == Format.p);\n+    assert(idx == 2);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%s\", idx, asterisk) == Format.s);\n+    assert(idx == 2);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%ls\", idx, asterisk,) == Format.ls);\n+    assert(idx == 3);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%%\", idx, asterisk) == Format.percent);\n+    assert(idx == 2);\n+\n+    // Synonyms\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%i\", idx, asterisk) == Format.d);\n+    assert(idx == 2);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%n\", idx, asterisk) == Format.n);\n+    assert(idx == 2);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%o\", idx, asterisk) == Format.u);\n+    assert(idx == 2);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%x\", idx, asterisk) == Format.u);\n+    assert(idx == 2);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%f\", idx, asterisk) == Format.g);\n+    assert(idx == 2);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%e\", idx, asterisk) == Format.g);\n+    assert(idx == 2);\n+\n+    idx = 0;\n+    g = parseScanfFormatSpecifier(\"%a\", idx, asterisk);\n+    assert(g == Format.g || g == Format.GNU_a);\n+    assert(idx == 2);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%c\", idx, asterisk) == Format.c);\n+    assert(idx == 2);\n+\n+    // asterisk\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%*d\", idx, asterisk) == Format.d);\n+    assert(idx == 3);\n+    assert(asterisk);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%9ld\", idx, asterisk) == Format.ld);\n+    assert(idx == 4);\n+    assert(!asterisk);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%*25984hhd\", idx, asterisk) == Format.hhd);\n+    assert(idx == 10);\n+    assert(asterisk);\n+\n+    // scansets\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%[a-zA-Z]s\", idx, asterisk) == Format.s);\n+    assert(idx == 10);\n+    assert(!asterisk);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%*25[a-z]hhd\", idx, asterisk) == Format.hhd);\n+    assert(idx == 12);\n+    assert(asterisk);\n+\n+    // Too short formats\n+    foreach (s; [\"%\", \"% \", \"%#\", \"%0\", \"%*\", \"%1\", \"%19\",\n+                 \"%j\", \"%z\", \"%t\", \"%l\", \"%h\", \"%ll\", \"%hh\", \"%K\"])\n+    {\n+        idx = 0;\n+        assert(parseScanfFormatSpecifier(s, idx, asterisk) == Format.error);\n+        assert(idx == s.length);\n+    }\n+\n+\n+    // Undefined format combinations\n+    foreach (s; [\"%Ld\", \"%llg\", \"%jg\", \"%zg\", \"%tg\", \"%hg\", \"%hhg\",\n+                 \"%jc\", \"%zc\", \"%tc\", \"%Lc\", \"%hc\", \"%hhc\", \"%llc\",\n+                 \"%jp\", \"%zp\", \"%tp\", \"%Lp\", \"%hp\", \"%lp\", \"%hhp\", \"%llp\",\n+                 \"%-\", \"%+\", \"%#\", \"%0\", \"%.\", \"%Ln\"])\n+    {\n+        idx = 0;\n+        assert(parseScanfFormatSpecifier(s, idx, asterisk) == Format.error);\n+        assert(idx == s.length);\n+\n+    }\n+\n+    // Invalid scansets\n+    foreach (s; [\"%[]\", \"%[s\", \"%[0-9lld\", \"%[\", \"%[a-z]\"])\n+    {\n+        idx = 0;\n+        assert(parseScanfFormatSpecifier(s, idx, asterisk) == Format.error);\n+        assert(idx == s.length);\n+    }\n+\n+}"}, {"sha": "eb09076b2d207fc0c7c7560353ad7ba3864536e8", "filename": "gcc/d/dmd/clone.c", "status": "removed", "additions": 0, "deletions": 1179, "changes": 1179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fclone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fclone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fclone.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49", "patch": "@@ -1,1179 +0,0 @@\n-\n-/* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n- * written by Walter Bright\n- * http://www.digitalmars.com\n- * Distributed under the Boost Software License, Version 1.0.\n- * http://www.boost.org/LICENSE_1_0.txt\n- * https://github.com/D-Programming-Language/dmd/blob/master/src/clone.c\n- */\n-\n-#include \"root/dsystem.h\"\n-#include \"root/root.h\"\n-\n-#include \"aggregate.h\"\n-#include \"scope.h\"\n-#include \"mtype.h\"\n-#include \"declaration.h\"\n-#include \"module.h\"\n-#include \"id.h\"\n-#include \"expression.h\"\n-#include \"statement.h\"\n-#include \"init.h\"\n-#include \"template.h\"\n-#include \"tokens.h\"\n-\n-/*******************************************\n- * Merge function attributes pure, nothrow, @safe, @nogc, and @disable\n- */\n-StorageClass mergeFuncAttrs(StorageClass s1, FuncDeclaration *f)\n-{\n-    if (!f)\n-        return s1;\n-\n-    StorageClass s2 = (f->storage_class & STCdisable);\n-    TypeFunction *tf = (TypeFunction *)f->type;\n-    if (tf->trust == TRUSTsafe)\n-        s2 |= STCsafe;\n-    else if (tf->trust == TRUSTsystem)\n-        s2 |= STCsystem;\n-    else if (tf->trust == TRUSTtrusted)\n-        s2 |= STCtrusted;\n-    if (tf->purity != PUREimpure)\n-        s2 |= STCpure;\n-    if (tf->isnothrow)\n-        s2 |= STCnothrow;\n-    if (tf->isnogc)\n-        s2 |= STCnogc;\n-\n-    StorageClass stc = 0;\n-    StorageClass sa = s1 & s2;\n-    StorageClass so = s1 | s2;\n-\n-    if (so & STCsystem)\n-        stc |= STCsystem;\n-    else if (sa & STCtrusted)\n-        stc |= STCtrusted;\n-    else if ((so & (STCtrusted | STCsafe)) == (STCtrusted | STCsafe))\n-        stc |= STCtrusted;\n-    else if (sa & STCsafe)\n-        stc |= STCsafe;\n-\n-    if (sa & STCpure)\n-        stc |= STCpure;\n-\n-    if (sa & STCnothrow)\n-        stc |= STCnothrow;\n-\n-    if (sa & STCnogc)\n-        stc |= STCnogc;\n-\n-    if (so & STCdisable)\n-        stc |= STCdisable;\n-\n-    return stc;\n-}\n-\n-/*******************************************\n- * Check given aggregate actually has an identity opAssign or not.\n- * Params:\n- *      ad = struct or class\n- *      sc = current scope\n- * Returns:\n- *      if found, returns FuncDeclaration of opAssign, otherwise null\n- */\n-FuncDeclaration *hasIdentityOpAssign(AggregateDeclaration *ad, Scope *sc)\n-{\n-    Dsymbol *assign = search_function(ad, Id::assign);\n-    if (assign)\n-    {\n-        /* check identity opAssign exists\n-         */\n-        UnionExp er; new(&er) NullExp(ad->loc, ad->type);    // dummy rvalue\n-        UnionExp el; new(&el) IdentifierExp(ad->loc, Id::p); // dummy lvalue\n-        el.exp()->type = ad->type;\n-        Expressions a;\n-        a.setDim(1);\n-\n-        unsigned errors = global.startGagging();    // Do not report errors, even if the template opAssign fbody makes it.\n-        sc = sc->push();\n-        sc->tinst = NULL;\n-        sc->minst = NULL;\n-\n-        a[0] = er.exp();\n-        FuncDeclaration *f = resolveFuncCall(ad->loc, sc, assign, NULL, ad->type, &a, 1);\n-        if (!f)\n-        {\n-            a[0] = el.exp();\n-            f = resolveFuncCall(ad->loc, sc, assign, NULL, ad->type, &a, 1);\n-        }\n-\n-        sc = sc->pop();\n-        global.endGagging(errors);\n-\n-        if (f)\n-        {\n-            if (f->errors)\n-                return NULL;\n-            ParameterList fparams = f->getParameterList();\n-            if (fparams.length())\n-            {\n-                Parameter *fparam0 = fparams[0];\n-                if (fparam0->type->toDsymbol(NULL) != ad)\n-                    f = NULL;\n-            }\n-        }\n-        // BUGS: This detection mechanism cannot find some opAssign-s like follows:\n-        // struct S { void opAssign(ref immutable S) const; }\n-        return f;\n-    }\n-    return NULL;\n-}\n-\n-/*******************************************\n- * We need an opAssign for the struct if\n- * it has a destructor or a postblit.\n- * We need to generate one if a user-specified one does not exist.\n- */\n-bool needOpAssign(StructDeclaration *sd)\n-{\n-    //printf(\"StructDeclaration::needOpAssign() %s\\n\", sd->toChars());\n-    if (sd->isUnionDeclaration())\n-        return false;\n-\n-    if (sd->hasIdentityAssign)\n-        goto Lneed;         // because has identity==elaborate opAssign\n-\n-    if (sd->dtor || sd->postblit)\n-        goto Lneed;\n-\n-    /* If any of the fields need an opAssign, then we\n-     * need it too.\n-     */\n-    for (size_t i = 0; i < sd->fields.length; i++)\n-    {\n-        VarDeclaration *v = sd->fields[i];\n-        if (v->storage_class & STCref)\n-            continue;\n-        if (v->overlapped)              // if field of a union\n-            continue;                   // user must handle it themselves\n-        Type *tv = v->type->baseElemOf();\n-        if (tv->ty == Tstruct)\n-        {\n-            TypeStruct *ts = (TypeStruct *)tv;\n-            if (ts->sym->isUnionDeclaration())\n-                continue;\n-            if (needOpAssign(ts->sym))\n-                goto Lneed;\n-        }\n-    }\n-    //printf(\"\\tdontneed\\n\");\n-    return false;\n-\n-Lneed:\n-    //printf(\"\\tneed\\n\");\n-    return true;\n-}\n-\n-/******************************************\n- * Build opAssign for struct.\n- *      ref S opAssign(S s) { ... }\n- *\n- * Note that s will be constructed onto the stack, and probably\n- * copy-constructed in caller site.\n- *\n- * If S has copy copy construction and/or destructor,\n- * the body will make bit-wise object swap:\n- *          S __swap = this; // bit copy\n- *          this = s;        // bit copy\n- *          __swap.dtor();\n- * Instead of running the destructor on s, run it on tmp instead.\n- *\n- * Otherwise, the body will make member-wise assignments:\n- * Then, the body is:\n- *          this.field1 = s.field1;\n- *          this.field2 = s.field2;\n- *          ...;\n- */\n-FuncDeclaration *buildOpAssign(StructDeclaration *sd, Scope *sc)\n-{\n-    if (FuncDeclaration *f = hasIdentityOpAssign(sd, sc))\n-    {\n-        sd->hasIdentityAssign = true;\n-        return f;\n-    }\n-    // Even if non-identity opAssign is defined, built-in identity opAssign\n-    // will be defined.\n-\n-    if (!needOpAssign(sd))\n-        return NULL;\n-\n-    //printf(\"StructDeclaration::buildOpAssign() %s\\n\", sd->toChars());\n-    StorageClass stc = STCsafe | STCnothrow | STCpure | STCnogc;\n-    Loc declLoc = sd->loc;\n-    Loc loc = Loc();    // internal code should have no loc to prevent coverage\n-\n-    // One of our sub-field might have `@disable opAssign` so we need to\n-    // check for it.\n-    // In this event, it will be reflected by having `stc` (opAssign's\n-    // storage class) include `STCdisabled`.\n-    for (size_t i = 0; i < sd->fields.length; i++)\n-    {\n-        VarDeclaration *v = sd->fields[i];\n-        if (v->storage_class & STCref)\n-            continue;\n-        if (v->overlapped)\n-            continue;\n-        Type *tv = v->type->baseElemOf();\n-        if (tv->ty != Tstruct)\n-            continue;\n-\n-        StructDeclaration *sdv = ((TypeStruct *)tv)->sym;\n-        stc = mergeFuncAttrs(stc, hasIdentityOpAssign(sdv, sc));\n-    }\n-\n-    if (sd->dtor || sd->postblit)\n-    {\n-        if (!sd->type->isAssignable())  // Bugzilla 13044\n-            return NULL;\n-        stc = mergeFuncAttrs(stc, sd->dtor);\n-        if (stc & STCsafe)\n-            stc = (stc & ~STCsafe) | STCtrusted;\n-    }\n-\n-    Parameters *fparams = new Parameters;\n-    fparams->push(new Parameter(STCnodtor, sd->type, Id::p, NULL, NULL));\n-    TypeFunction *tf = new TypeFunction(ParameterList(fparams), sd->handleType(), LINKd, stc | STCref);\n-\n-    FuncDeclaration *fop = new FuncDeclaration(declLoc, Loc(), Id::assign, stc, tf);\n-    fop->storage_class |= STCinference;\n-    fop->generated = true;\n-    Expression *e = NULL;\n-    if (stc & STCdisable)\n-    {\n-    }\n-    else if (sd->dtor || sd->postblit)\n-    {\n-        /* Do swap this and rhs.\n-         *    __swap = this; this = s; __swap.dtor();\n-         */\n-        //printf(\"\\tswap copy\\n\");\n-        Identifier *idtmp = Identifier::generateId(\"__swap\");\n-        VarDeclaration *tmp = NULL;\n-        AssignExp *ec = NULL;\n-        if (sd->dtor)\n-        {\n-            tmp = new VarDeclaration(loc, sd->type, idtmp, new VoidInitializer(loc));\n-            tmp->storage_class |= STCnodtor | STCtemp | STCctfe;\n-            e = new DeclarationExp(loc, tmp);\n-            ec = new BlitExp(loc, new VarExp(loc, tmp), new ThisExp(loc));\n-            e = Expression::combine(e, ec);\n-        }\n-        ec = new BlitExp(loc, new ThisExp(loc), new IdentifierExp(loc, Id::p));\n-        e = Expression::combine(e, ec);\n-        if (sd->dtor)\n-        {\n-            /* Instead of running the destructor on s, run it\n-             * on tmp. This avoids needing to copy tmp back in to s.\n-             */\n-            Expression *ec2 = new DotVarExp(loc, new VarExp(loc, tmp), sd->dtor, false);\n-            ec2 = new CallExp(loc, ec2);\n-            e = Expression::combine(e, ec2);\n-        }\n-    }\n-    else\n-    {\n-        /* Do memberwise copy.\n-         *\n-         * If sd is a nested struct, its vthis field assignment is:\n-         * 1. If it's nested in a class, it's a rebind of class reference.\n-         * 2. If it's nested in a function or struct, it's an update of void*.\n-         * In both cases, it will change the parent context.\n-         */\n-        //printf(\"\\tmemberwise copy\\n\");\n-        for (size_t i = 0; i < sd->fields.length; i++)\n-        {\n-            VarDeclaration *v = sd->fields[i];\n-            // this.v = s.v;\n-            AssignExp *ec = new AssignExp(loc,\n-                new DotVarExp(loc, new ThisExp(loc), v),\n-                new DotVarExp(loc, new IdentifierExp(loc, Id::p), v));\n-            e = Expression::combine(e, ec);\n-        }\n-    }\n-    if (e)\n-    {\n-        Statement *s1 = new ExpStatement(loc, e);\n-\n-        /* Add:\n-         *   return this;\n-         */\n-        e = new ThisExp(loc);\n-        Statement *s2 = new ReturnStatement(loc, e);\n-\n-        fop->fbody = new CompoundStatement(loc, s1, s2);\n-        tf->isreturn = true;\n-    }\n-\n-    sd->members->push(fop);\n-    fop->addMember(sc, sd);\n-    sd->hasIdentityAssign = true;        // temporary mark identity assignable\n-\n-    unsigned errors = global.startGagging();    // Do not report errors, even if the template opAssign fbody makes it.\n-    Scope *sc2 = sc->push();\n-    sc2->stc = 0;\n-    sc2->linkage = LINKd;\n-\n-    dsymbolSemantic(fop, sc2);\n-    semantic2(fop, sc2);\n-    // Bugzilla 15044: fop->semantic3 isn't run here for lazy forward reference resolution.\n-\n-    sc2->pop();\n-    if (global.endGagging(errors))    // if errors happened\n-    {\n-        // Disable generated opAssign, because some members forbid identity assignment.\n-        fop->storage_class |= STCdisable;\n-        fop->fbody = NULL;  // remove fbody which contains the error\n-    }\n-\n-    //printf(\"-StructDeclaration::buildOpAssign() %s, errors = %d\\n\", sd->toChars(), (fop->storage_class & STCdisable) != 0);\n-\n-    return fop;\n-}\n-\n-/*******************************************\n- * We need an opEquals for the struct if\n- * any fields has an opEquals.\n- * Generate one if a user-specified one does not exist.\n- */\n-bool needOpEquals(StructDeclaration *sd)\n-{\n-    //printf(\"StructDeclaration::needOpEquals() %s\\n\", sd->toChars());\n-    if (sd->isUnionDeclaration())\n-        goto Ldontneed;\n-\n-    if (sd->hasIdentityEquals)\n-        goto Lneed;\n-\n-    /* If any of the fields has an opEquals, then we\n-     * need it too.\n-     */\n-    for (size_t i = 0; i < sd->fields.length; i++)\n-    {\n-        VarDeclaration *v = sd->fields[i];\n-        if (v->storage_class & STCref)\n-            continue;\n-        if (v->overlapped)\n-            continue;\n-        Type *tv = v->type->toBasetype();\n-        Type *tvbase = tv->baseElemOf();\n-        if (tvbase->ty == Tstruct)\n-        {\n-            TypeStruct *ts = (TypeStruct *)tvbase;\n-            if (ts->sym->isUnionDeclaration())\n-                continue;\n-            if (needOpEquals(ts->sym))\n-                goto Lneed;\n-            if (ts->sym->aliasthis)     // Bugzilla 14806\n-                goto Lneed;\n-        }\n-        if (tv->isfloating())\n-        {\n-            // This is necessray for:\n-            //  1. comparison of +0.0 and -0.0 should be true.\n-            //  2. comparison of NANs should be false always.\n-            goto Lneed;\n-        }\n-        if (tv->ty == Tarray)\n-            goto Lneed;\n-        if (tv->ty == Taarray)\n-            goto Lneed;\n-        if (tv->ty == Tclass)\n-            goto Lneed;\n-    }\n-Ldontneed:\n-    //printf(\"\\tdontneed\\n\");\n-    return false;\n-\n-Lneed:\n-    //printf(\"\\tneed\\n\");\n-    return true;\n-}\n-\n-/*******************************************\n- * Check given aggregate actually has an identity opEquals or not.\n- */\n-FuncDeclaration *hasIdentityOpEquals(AggregateDeclaration *ad,  Scope *sc)\n-{\n-    Dsymbol *eq = search_function(ad, Id::eq);\n-    if (eq)\n-    {\n-        /* check identity opEquals exists\n-         */\n-        UnionExp er; new(&er) NullExp(ad->loc, NULL);        // dummy rvalue\n-        UnionExp el; new(&el) IdentifierExp(ad->loc, Id::p); // dummy lvalue\n-        Expressions a;\n-        a.setDim(1);\n-        for (size_t i = 0; i < 5; i++)\n-        {\n-            Type *tthis = NULL;         // dead-store to prevent spurious warning\n-            switch (i)\n-            {\n-                case 0:  tthis = ad->type;                  break;\n-                case 1:  tthis = ad->type->constOf();       break;\n-                case 2:  tthis = ad->type->immutableOf();   break;\n-                case 3:  tthis = ad->type->sharedOf();      break;\n-                case 4:  tthis = ad->type->sharedConstOf(); break;\n-                default: assert(0);\n-            }\n-            FuncDeclaration *f = NULL;\n-\n-            unsigned errors = global.startGagging();    // Do not report errors, even if the template opAssign fbody makes it.\n-            sc = sc->push();\n-            sc->tinst = NULL;\n-            sc->minst = NULL;\n-\n-            for (size_t j = 0; j < 2; j++)\n-            {\n-                a[0] = (j == 0 ? er.exp() : el.exp());\n-                a[0]->type = tthis;\n-                f = resolveFuncCall(ad->loc, sc, eq, NULL, tthis, &a, 1);\n-                if (f)\n-                    break;\n-            }\n-\n-            sc = sc->pop();\n-            global.endGagging(errors);\n-\n-            if (f)\n-            {\n-                if (f->errors)\n-                    return NULL;\n-                return f;\n-            }\n-        }\n-    }\n-    return NULL;\n-}\n-\n-/******************************************\n- * Build opEquals for struct.\n- *      const bool opEquals(const S s) { ... }\n- *\n- * By fixing bugzilla 3789, opEquals is changed to be never implicitly generated.\n- * Now, struct objects comparison s1 == s2 is translated to:\n- *      s1.tupleof == s2.tupleof\n- * to calculate structural equality. See EqualExp::op_overload.\n- */\n-FuncDeclaration *buildOpEquals(StructDeclaration *sd, Scope *sc)\n-{\n-    if (hasIdentityOpEquals(sd, sc))\n-    {\n-        sd->hasIdentityEquals = true;\n-    }\n-    return NULL;\n-}\n-\n-/******************************************\n- * Build __xopEquals for TypeInfo_Struct\n- *      static bool __xopEquals(ref const S p, ref const S q)\n- *      {\n- *          return p == q;\n- *      }\n- *\n- * This is called by TypeInfo.equals(p1, p2). If the struct does not support\n- * const objects comparison, it will throw \"not implemented\" Error in runtime.\n- */\n-FuncDeclaration *buildXopEquals(StructDeclaration *sd, Scope *sc)\n-{\n-    if (!needOpEquals(sd))\n-        return NULL;        // bitwise comparison would work\n-\n-    //printf(\"StructDeclaration::buildXopEquals() %s\\n\", sd->toChars());\n-    if (Dsymbol *eq = search_function(sd, Id::eq))\n-    {\n-        if (FuncDeclaration *fd = eq->isFuncDeclaration())\n-        {\n-            TypeFunction *tfeqptr;\n-            {\n-                Scope scx;\n-\n-                /* const bool opEquals(ref const S s);\n-                 */\n-                Parameters *parameters = new Parameters;\n-                parameters->push(new Parameter(STCref | STCconst, sd->type, NULL, NULL, NULL));\n-                tfeqptr = new TypeFunction(ParameterList(parameters), Type::tbool, LINKd);\n-                tfeqptr->mod = MODconst;\n-                tfeqptr = (TypeFunction *)typeSemantic(tfeqptr, Loc(), &scx);\n-            }\n-            fd = fd->overloadExactMatch(tfeqptr);\n-            if (fd)\n-                return fd;\n-        }\n-    }\n-\n-    if (!sd->xerreq)\n-    {\n-        // object._xopEquals\n-        Identifier *id = Identifier::idPool(\"_xopEquals\");\n-        Expression *e = new IdentifierExp(sd->loc, Id::empty);\n-        e = new DotIdExp(sd->loc, e, Id::object);\n-        e = new DotIdExp(sd->loc, e, id);\n-        e = expressionSemantic(e, sc);\n-        Dsymbol *s = getDsymbol(e);\n-        assert(s);\n-        sd->xerreq = s->isFuncDeclaration();\n-    }\n-\n-    Loc declLoc = Loc();    // loc is unnecessary so __xopEquals is never called directly\n-    Loc loc = Loc();        // loc is unnecessary so errors are gagged\n-\n-    Parameters *parameters = new Parameters;\n-    parameters->push(new Parameter(STCref | STCconst, sd->type, Id::p, NULL, NULL));\n-    parameters->push(new Parameter(STCref | STCconst, sd->type, Id::q, NULL, NULL));\n-    TypeFunction *tf = new TypeFunction(ParameterList(parameters), Type::tbool, LINKd);\n-\n-    Identifier *id = Id::xopEquals;\n-    FuncDeclaration *fop = new FuncDeclaration(declLoc, Loc(), id, STCstatic, tf);\n-    fop->generated = true;\n-    Expression *e1 = new IdentifierExp(loc, Id::p);\n-    Expression *e2 = new IdentifierExp(loc, Id::q);\n-    Expression *e = new EqualExp(TOKequal, loc, e1, e2);\n-\n-    fop->fbody = new ReturnStatement(loc, e);\n-\n-    unsigned errors = global.startGagging();    // Do not report errors\n-    Scope *sc2 = sc->push();\n-    sc2->stc = 0;\n-    sc2->linkage = LINKd;\n-\n-    dsymbolSemantic(fop, sc2);\n-    semantic2(fop, sc2);\n-\n-    sc2->pop();\n-    if (global.endGagging(errors))    // if errors happened\n-        fop = sd->xerreq;\n-\n-    return fop;\n-}\n-\n-/******************************************\n- * Build __xopCmp for TypeInfo_Struct\n- *      static bool __xopCmp(ref const S p, ref const S q)\n- *      {\n- *          return p.opCmp(q);\n- *      }\n- *\n- * This is called by TypeInfo.compare(p1, p2). If the struct does not support\n- * const objects comparison, it will throw \"not implemented\" Error in runtime.\n- */\n-FuncDeclaration *buildXopCmp(StructDeclaration *sd, Scope *sc)\n-{\n-    //printf(\"StructDeclaration::buildXopCmp() %s\\n\", toChars());\n-    if (Dsymbol *cmp = search_function(sd, Id::cmp))\n-    {\n-        if (FuncDeclaration *fd = cmp->isFuncDeclaration())\n-        {\n-            TypeFunction *tfcmpptr;\n-            {\n-                Scope scx;\n-\n-                /* const int opCmp(ref const S s);\n-                 */\n-                Parameters *parameters = new Parameters;\n-                parameters->push(new Parameter(STCref | STCconst, sd->type, NULL, NULL, NULL));\n-                tfcmpptr = new TypeFunction(ParameterList(parameters), Type::tint32, LINKd);\n-                tfcmpptr->mod = MODconst;\n-                tfcmpptr = (TypeFunction *)typeSemantic(tfcmpptr, Loc(), &scx);\n-            }\n-            fd = fd->overloadExactMatch(tfcmpptr);\n-            if (fd)\n-                return fd;\n-        }\n-    }\n-    else\n-    {\n-        // FIXME: doesn't work for recursive alias this\n-        return NULL;\n-    }\n-\n-    if (!sd->xerrcmp)\n-    {\n-        // object._xopCmp\n-        Identifier *id = Identifier::idPool(\"_xopCmp\");\n-        Expression *e = new IdentifierExp(sd->loc, Id::empty);\n-        e = new DotIdExp(sd->loc, e, Id::object);\n-        e = new DotIdExp(sd->loc, e, id);\n-        e = expressionSemantic(e, sc);\n-        Dsymbol *s = getDsymbol(e);\n-        assert(s);\n-        sd->xerrcmp = s->isFuncDeclaration();\n-    }\n-\n-    Loc declLoc = Loc();    // loc is unnecessary so __xopCmp is never called directly\n-    Loc loc = Loc();        // loc is unnecessary so errors are gagged\n-\n-    Parameters *parameters = new Parameters;\n-    parameters->push(new Parameter(STCref | STCconst, sd->type, Id::p, NULL, NULL));\n-    parameters->push(new Parameter(STCref | STCconst, sd->type, Id::q, NULL, NULL));\n-    TypeFunction *tf = new TypeFunction(ParameterList(parameters), Type::tint32, LINKd);\n-\n-    Identifier *id = Id::xopCmp;\n-    FuncDeclaration *fop = new FuncDeclaration(declLoc, Loc(), id, STCstatic, tf);\n-    fop->generated = true;\n-    Expression *e1 = new IdentifierExp(loc, Id::p);\n-    Expression *e2 = new IdentifierExp(loc, Id::q);\n-#ifdef IN_GCC\n-    Expression *e = new CallExp(loc, new DotIdExp(loc, e1, Id::cmp), e2);\n-#else\n-    Expression *e = new CallExp(loc, new DotIdExp(loc, e2, Id::cmp), e1);\n-#endif\n-\n-    fop->fbody = new ReturnStatement(loc, e);\n-\n-    unsigned errors = global.startGagging();    // Do not report errors\n-    Scope *sc2 = sc->push();\n-    sc2->stc = 0;\n-    sc2->linkage = LINKd;\n-\n-    dsymbolSemantic(fop, sc2);\n-    semantic2(fop, sc2);\n-\n-    sc2->pop();\n-    if (global.endGagging(errors))    // if errors happened\n-        fop = sd->xerrcmp;\n-\n-    return fop;\n-}\n-\n-/*******************************************\n- * We need a toHash for the struct if\n- * any fields has a toHash.\n- * Generate one if a user-specified one does not exist.\n- */\n-bool needToHash(StructDeclaration *sd)\n-{\n-    //printf(\"StructDeclaration::needToHash() %s\\n\", sd->toChars());\n-    if (sd->isUnionDeclaration())\n-        goto Ldontneed;\n-\n-    if (sd->xhash)\n-        goto Lneed;\n-\n-    /* If any of the fields has an opEquals, then we\n-     * need it too.\n-     */\n-    for (size_t i = 0; i < sd->fields.length; i++)\n-    {\n-        VarDeclaration *v = sd->fields[i];\n-        if (v->storage_class & STCref)\n-            continue;\n-        if (v->overlapped)\n-            continue;\n-        Type *tv = v->type->toBasetype();\n-        Type *tvbase = tv->baseElemOf();\n-        if (tvbase->ty == Tstruct)\n-        {\n-            TypeStruct *ts = (TypeStruct *)tvbase;\n-            if (ts->sym->isUnionDeclaration())\n-                continue;\n-            if (needToHash(ts->sym))\n-                goto Lneed;\n-            if (ts->sym->aliasthis)     // Bugzilla 14948\n-                goto Lneed;\n-        }\n-        if (tv->isfloating())\n-        {\n-            // This is necessray for:\n-            //  1. comparison of +0.0 and -0.0 should be true.\n-            goto Lneed;\n-        }\n-        if (tv->ty == Tarray)\n-            goto Lneed;\n-        if (tv->ty == Taarray)\n-            goto Lneed;\n-        if (tv->ty == Tclass)\n-            goto Lneed;\n-    }\n-Ldontneed:\n-    //printf(\"\\tdontneed\\n\");\n-    return false;\n-\n-Lneed:\n-    //printf(\"\\tneed\\n\");\n-    return true;\n-}\n-\n-/******************************************\n- * Build __xtoHash for non-bitwise hashing\n- *      static hash_t xtoHash(ref const S p) nothrow @trusted;\n- */\n-FuncDeclaration *buildXtoHash(StructDeclaration *sd, Scope *sc)\n-{\n-    if (Dsymbol *s = search_function(sd, Id::tohash))\n-    {\n-        static TypeFunction *tftohash;\n-        if (!tftohash)\n-        {\n-            tftohash = new TypeFunction(ParameterList(), Type::thash_t, LINKd);\n-            tftohash->mod = MODconst;\n-            tftohash = (TypeFunction *)tftohash->merge();\n-        }\n-\n-        if (FuncDeclaration *fd = s->isFuncDeclaration())\n-        {\n-            fd = fd->overloadExactMatch(tftohash);\n-            if (fd)\n-                return fd;\n-        }\n-    }\n-\n-    if (!needToHash(sd))\n-        return NULL;\n-\n-    //printf(\"StructDeclaration::buildXtoHash() %s\\n\", sd->toPrettyChars());\n-    Loc declLoc = Loc();    // loc is unnecessary so __xtoHash is never called directly\n-    Loc loc = Loc();        // internal code should have no loc to prevent coverage\n-\n-    Parameters *parameters = new Parameters();\n-    parameters->push(new Parameter(STCref | STCconst, sd->type, Id::p, NULL, NULL));\n-    TypeFunction *tf = new TypeFunction(ParameterList(parameters), Type::thash_t,\n-                                        LINKd, STCnothrow | STCtrusted);\n-\n-    Identifier *id = Id::xtoHash;\n-    FuncDeclaration *fop = new FuncDeclaration(declLoc, Loc(), id, STCstatic, tf);\n-    fop->generated = true;\n-\n-    /* Do memberwise hashing.\n-     *\n-     * If sd is a nested struct, and if it's nested in a class, the calculated\n-     * hash value will also contain the result of parent class's toHash().\n-     */\n-    const char *code =\n-        \"size_t h = 0;\"\n-        \"foreach (i, T; typeof(p.tupleof))\"\n-        \"    h += typeid(T).getHash(cast(const void*)&p.tupleof[i]);\"\n-        \"return h;\";\n-    fop->fbody = new CompileStatement(loc, new StringExp(loc, const_cast<char *>(code)));\n-\n-    Scope *sc2 = sc->push();\n-    sc2->stc = 0;\n-    sc2->linkage = LINKd;\n-\n-    dsymbolSemantic(fop, sc2);\n-    semantic2(fop, sc2);\n-\n-    sc2->pop();\n-\n-    //printf(\"%s fop = %s %s\\n\", sd->toChars(), fop->toChars(), fop->type->toChars());\n-    return fop;\n-}\n-\n-/*****************************************\n- * Create inclusive postblit for struct by aggregating\n- * all the postblits in postblits[] with the postblits for\n- * all the members.\n- * Note the close similarity with AggregateDeclaration::buildDtor(),\n- * and the ordering changes (runs forward instead of backwards).\n- */\n-FuncDeclaration *buildPostBlit(StructDeclaration *sd, Scope *sc)\n-{\n-    //printf(\"StructDeclaration::buildPostBlit() %s\\n\", sd->toChars());\n-    if (sd->isUnionDeclaration())\n-        return NULL;\n-\n-    StorageClass stc = STCsafe | STCnothrow | STCpure | STCnogc;\n-    Loc declLoc = sd->postblits.length ? sd->postblits[0]->loc : sd->loc;\n-    Loc loc = Loc();    // internal code should have no loc to prevent coverage\n-\n-    for (size_t i = 0; i < sd->postblits.length; i++)\n-    {\n-        stc |= sd->postblits[i]->storage_class & STCdisable;\n-    }\n-\n-    Statements *a = new Statements();\n-    for (size_t i = 0; i < sd->fields.length && !(stc & STCdisable); i++)\n-    {\n-        VarDeclaration *v = sd->fields[i];\n-        if (v->storage_class & STCref)\n-            continue;\n-        if (v->overlapped)\n-            continue;\n-        Type *tv = v->type->baseElemOf();\n-        if (tv->ty != Tstruct)\n-            continue;\n-        StructDeclaration *sdv = ((TypeStruct *)tv)->sym;\n-        if (!sdv->postblit)\n-            continue;\n-        assert(!sdv->isUnionDeclaration());\n-        sdv->postblit->functionSemantic();\n-\n-        stc = mergeFuncAttrs(stc, sdv->postblit);\n-        stc = mergeFuncAttrs(stc, sdv->dtor);\n-        if (stc & STCdisable)\n-        {\n-            a->setDim(0);\n-            break;\n-        }\n-\n-        Expression *ex = NULL;\n-        tv = v->type->toBasetype();\n-        if (tv->ty == Tstruct)\n-        {\n-            // this.v.__xpostblit()\n-\n-            ex = new ThisExp(loc);\n-            ex = new DotVarExp(loc, ex, v);\n-\n-            // This is a hack so we can call postblits on const/immutable objects.\n-            ex = new AddrExp(loc, ex);\n-            ex = new CastExp(loc, ex, v->type->mutableOf()->pointerTo());\n-            ex = new PtrExp(loc, ex);\n-            if (stc & STCsafe)\n-                stc = (stc & ~STCsafe) | STCtrusted;\n-\n-            ex = new DotVarExp(loc, ex, sdv->postblit, false);\n-            ex = new CallExp(loc, ex);\n-        }\n-        else\n-        {\n-            // __ArrayPostblit((cast(S*)this.v.ptr)[0 .. n])\n-\n-            uinteger_t n = tv->numberOfElems(loc);\n-            if (n == 0)\n-                continue;\n-\n-            ex = new ThisExp(loc);\n-            ex = new DotVarExp(loc, ex, v);\n-\n-            // This is a hack so we can call postblits on const/immutable objects.\n-            ex = new DotIdExp(loc, ex, Id::ptr);\n-            ex = new CastExp(loc, ex, sdv->type->pointerTo());\n-            if (stc & STCsafe)\n-                stc = (stc & ~STCsafe) | STCtrusted;\n-\n-            ex = new SliceExp(loc, ex, new IntegerExp(loc, 0, Type::tsize_t),\n-                                       new IntegerExp(loc, n, Type::tsize_t));\n-            // Prevent redundant bounds check\n-            ((SliceExp *)ex)->upperIsInBounds = true;\n-            ((SliceExp *)ex)->lowerIsLessThanUpper = true;\n-\n-            ex = new CallExp(loc, new IdentifierExp(loc, Id::__ArrayPostblit), ex);\n-        }\n-        a->push(new ExpStatement(loc, ex)); // combine in forward order\n-\n-        /* Bugzilla 10972: When the following field postblit calls fail,\n-         * this field should be destructed for Exception Safety.\n-         */\n-        if (!sdv->dtor)\n-            continue;\n-        sdv->dtor->functionSemantic();\n-\n-        tv = v->type->toBasetype();\n-        if (v->type->toBasetype()->ty == Tstruct)\n-        {\n-            // this.v.__xdtor()\n-\n-            ex = new ThisExp(loc);\n-            ex = new DotVarExp(loc, ex, v);\n-\n-            // This is a hack so we can call destructors on const/immutable objects.\n-            ex = new AddrExp(loc, ex);\n-            ex = new CastExp(loc, ex, v->type->mutableOf()->pointerTo());\n-            ex = new PtrExp(loc, ex);\n-            if (stc & STCsafe)\n-                stc = (stc & ~STCsafe) | STCtrusted;\n-\n-            ex = new DotVarExp(loc, ex, sdv->dtor, false);\n-            ex = new CallExp(loc, ex);\n-        }\n-        else\n-        {\n-            // __ArrayDtor((cast(S*)this.v.ptr)[0 .. n])\n-\n-            uinteger_t n = tv->numberOfElems(loc);\n-            //if (n == 0)\n-            //    continue;\n-\n-            ex = new ThisExp(loc);\n-            ex = new DotVarExp(loc, ex, v);\n-\n-            // This is a hack so we can call destructors on const/immutable objects.\n-            ex = new DotIdExp(loc, ex, Id::ptr);\n-            ex = new CastExp(loc, ex, sdv->type->pointerTo());\n-            if (stc & STCsafe)\n-                stc = (stc & ~STCsafe) | STCtrusted;\n-\n-            ex = new SliceExp(loc, ex, new IntegerExp(loc, 0, Type::tsize_t),\n-                                       new IntegerExp(loc, n, Type::tsize_t));\n-            // Prevent redundant bounds check\n-            ((SliceExp *)ex)->upperIsInBounds = true;\n-            ((SliceExp *)ex)->lowerIsLessThanUpper = true;\n-\n-            ex = new CallExp(loc, new IdentifierExp(loc, Id::__ArrayDtor), ex);\n-        }\n-        a->push(new ScopeGuardStatement(loc, TOKon_scope_failure, new ExpStatement(loc, ex)));\n-    }\n-\n-    // Build our own \"postblit\" which executes a, but only if needed.\n-    if (a->length || (stc & STCdisable))\n-    {\n-        //printf(\"Building __fieldPostBlit()\\n\");\n-        PostBlitDeclaration *dd = new PostBlitDeclaration(declLoc, Loc(), stc, Id::__fieldPostblit);\n-        dd->generated = true;\n-        dd->storage_class |= STCinference;\n-        dd->fbody = (stc & STCdisable) ? NULL : new CompoundStatement(loc, a);\n-        sd->postblits.shift(dd);\n-        sd->members->push(dd);\n-        dsymbolSemantic(dd, sc);\n-    }\n-\n-    FuncDeclaration *xpostblit = NULL;\n-    switch (sd->postblits.length)\n-    {\n-        case 0:\n-            break;\n-\n-        case 1:\n-            xpostblit = sd->postblits[0];\n-            break;\n-\n-        default:\n-            Expression *e = NULL;\n-            stc = STCsafe | STCnothrow | STCpure | STCnogc;\n-            for (size_t i = 0; i < sd->postblits.length; i++)\n-            {\n-                FuncDeclaration *fd = sd->postblits[i];\n-                stc = mergeFuncAttrs(stc, fd);\n-                if (stc & STCdisable)\n-                {\n-                    e = NULL;\n-                    break;\n-                }\n-                Expression *ex = new ThisExp(loc);\n-                ex = new DotVarExp(loc, ex, fd, false);\n-                ex = new CallExp(loc, ex);\n-                e = Expression::combine(e, ex);\n-            }\n-            PostBlitDeclaration *dd = new PostBlitDeclaration(declLoc, Loc(), stc, Id::__aggrPostblit);\n-            dd->storage_class |= STCinference;\n-            dd->fbody = new ExpStatement(loc, e);\n-            sd->members->push(dd);\n-            dsymbolSemantic(dd, sc);\n-            xpostblit = dd;\n-            break;\n-    }\n-    // Add an __xpostblit alias to make the inclusive postblit accessible\n-    if (xpostblit)\n-    {\n-        AliasDeclaration *alias = new AliasDeclaration(Loc(), Id::__xpostblit, xpostblit);\n-        dsymbolSemantic(alias, sc);\n-        sd->members->push(alias);\n-        alias->addMember(sc, sd); // add to symbol table\n-    }\n-    return xpostblit;\n-}\n-\n-/*****************************************\n- * Create inclusive destructor for struct/class by aggregating\n- * all the destructors in dtors[] with the destructors for\n- * all the members.\n- * Note the close similarity with StructDeclaration::buildPostBlit(),\n- * and the ordering changes (runs backward instead of forwards).\n- */\n-FuncDeclaration *buildDtor(AggregateDeclaration *ad, Scope *sc)\n-{\n-    //printf(\"AggregateDeclaration::buildDtor() %s\\n\", ad->toChars());\n-    if (ad->isUnionDeclaration())\n-        return NULL;\n-\n-    StorageClass stc = STCsafe | STCnothrow | STCpure | STCnogc;\n-    Loc declLoc = ad->dtors.length ? ad->dtors[0]->loc : ad->loc;\n-    Loc loc = Loc();    // internal code should have no loc to prevent coverage\n-\n-    Expression *e = NULL;\n-    for (size_t i = 0; i < ad->fields.length; i++)\n-    {\n-        VarDeclaration *v = ad->fields[i];\n-        if (v->storage_class & STCref)\n-            continue;\n-        if (v->overlapped)\n-            continue;\n-        Type *tv = v->type->baseElemOf();\n-        if (tv->ty != Tstruct)\n-            continue;\n-        StructDeclaration *sdv = ((TypeStruct *)tv)->sym;\n-        if (!sdv->dtor)\n-            continue;\n-        sdv->dtor->functionSemantic();\n-\n-        stc = mergeFuncAttrs(stc, sdv->dtor);\n-        if (stc & STCdisable)\n-        {\n-            e = NULL;\n-            break;\n-        }\n-\n-        Expression *ex = NULL;\n-        tv = v->type->toBasetype();\n-        if (tv->ty == Tstruct)\n-        {\n-            // this.v.__xdtor()\n-\n-            ex = new ThisExp(loc);\n-            ex = new DotVarExp(loc, ex, v);\n-\n-            // This is a hack so we can call destructors on const/immutable objects.\n-            ex = new AddrExp(loc, ex);\n-            ex = new CastExp(loc, ex, v->type->mutableOf()->pointerTo());\n-            ex = new PtrExp(loc, ex);\n-            if (stc & STCsafe)\n-                stc = (stc & ~STCsafe) | STCtrusted;\n-\n-            ex = new DotVarExp(loc, ex, sdv->dtor, false);\n-            ex = new CallExp(loc, ex);\n-        }\n-        else\n-        {\n-            // __ArrayDtor((cast(S*)this.v.ptr)[0 .. n])\n-\n-            uinteger_t n = tv->numberOfElems(loc);\n-            if (n == 0)\n-                continue;\n-\n-            ex = new ThisExp(loc);\n-            ex = new DotVarExp(loc, ex, v);\n-\n-            // This is a hack so we can call destructors on const/immutable objects.\n-            ex = new DotIdExp(loc, ex, Id::ptr);\n-            ex = new CastExp(loc, ex, sdv->type->pointerTo());\n-            if (stc & STCsafe)\n-                stc = (stc & ~STCsafe) | STCtrusted;\n-\n-            ex = new SliceExp(loc, ex, new IntegerExp(loc, 0, Type::tsize_t),\n-                                       new IntegerExp(loc, n, Type::tsize_t));\n-            // Prevent redundant bounds check\n-            ((SliceExp *)ex)->upperIsInBounds = true;\n-            ((SliceExp *)ex)->lowerIsLessThanUpper = true;\n-\n-            ex = new CallExp(loc, new IdentifierExp(loc, Id::__ArrayDtor), ex);\n-        }\n-        e = Expression::combine(ex, e); // combine in reverse order\n-    }\n-\n-    /* Build our own \"destructor\" which executes e\n-     */\n-    if (e || (stc & STCdisable))\n-    {\n-        //printf(\"Building __fieldDtor()\\n\");\n-        DtorDeclaration *dd = new DtorDeclaration(declLoc, Loc(), stc, Id::__fieldDtor);\n-        dd->generated = true;\n-        dd->storage_class |= STCinference;\n-        dd->fbody = new ExpStatement(loc, e);\n-        ad->dtors.shift(dd);\n-        ad->members->push(dd);\n-        dsymbolSemantic(dd, sc);\n-    }\n-\n-    FuncDeclaration *xdtor = NULL;\n-    switch (ad->dtors.length)\n-    {\n-        case 0:\n-            break;\n-\n-        case 1:\n-            xdtor = ad->dtors[0];\n-            break;\n-\n-        default:\n-            e = NULL;\n-            stc = STCsafe | STCnothrow | STCpure | STCnogc;\n-            for (size_t i = 0; i < ad->dtors.length; i++)\n-            {\n-                FuncDeclaration *fd = ad->dtors[i];\n-                stc = mergeFuncAttrs(stc, fd);\n-                if (stc & STCdisable)\n-                {\n-                    e = NULL;\n-                    break;\n-                }\n-                Expression *ex = new ThisExp(loc);\n-                ex = new DotVarExp(loc, ex, fd, false);\n-                ex = new CallExp(loc, ex);\n-                e = Expression::combine(ex, e);\n-            }\n-            DtorDeclaration *dd = new DtorDeclaration(declLoc, Loc(), stc, Id::__aggrDtor);\n-            dd->generated = true;\n-            dd->storage_class |= STCinference;\n-            dd->fbody = new ExpStatement(loc, e);\n-            ad->members->push(dd);\n-            dsymbolSemantic(dd, sc);\n-            xdtor = dd;\n-            break;\n-    }\n-    // Add an __xdtor alias to make the inclusive dtor accessible\n-    if (xdtor)\n-    {\n-        AliasDeclaration *alias = new AliasDeclaration(Loc(), Id::__xdtor, xdtor);\n-        dsymbolSemantic(alias, sc);\n-        ad->members->push(alias);\n-        alias->addMember(sc, ad); // add to symbol table\n-    }\n-    return xdtor;\n-}\n-\n-/******************************************\n- * Create inclusive invariant for struct/class by aggregating\n- * all the invariants in invs[].\n- *      void __invariant() const [pure nothrow @trusted]\n- *      {\n- *          invs[0](), invs[1](), ...;\n- *      }\n- */\n-FuncDeclaration *buildInv(AggregateDeclaration *ad, Scope *sc)\n-{\n-    StorageClass stc = STCsafe | STCnothrow | STCpure | STCnogc;\n-    Loc declLoc = ad->loc;\n-    Loc loc = Loc();    // internal code should have no loc to prevent coverage\n-\n-    switch (ad->invs.length)\n-    {\n-        case 0:\n-            return NULL;\n-\n-        case 1:\n-            // Don't return invs[0] so it has uniquely generated name.\n-            /* fall through */\n-\n-        default:\n-            Expression *e = NULL;\n-            StorageClass stcx = 0;\n-            for (size_t i = 0; i < ad->invs.length; i++)\n-            {\n-                stc = mergeFuncAttrs(stc, ad->invs[i]);\n-                if (stc & STCdisable)\n-                {\n-                    // What should do?\n-                }\n-                StorageClass stcy = (ad->invs[i]->storage_class & STCsynchronized) |\n-                                    (ad->invs[i]->type->mod & MODshared ? STCshared : 0);\n-                if (i == 0)\n-                    stcx = stcy;\n-                else if (stcx ^ stcy)\n-                {\n-            #if 1   // currently rejects\n-                    ad->error(ad->invs[i]->loc, \"mixing invariants with shared/synchronized differene is not supported\");\n-                    e = NULL;\n-                    break;\n-            #endif\n-                }\n-                e = Expression::combine(e, new CallExp(loc, new VarExp(loc, ad->invs[i], false)));\n-            }\n-            InvariantDeclaration *inv;\n-            inv = new InvariantDeclaration(declLoc, Loc(), stc | stcx, Id::classInvariant);\n-            inv->fbody = new ExpStatement(loc, e);\n-            ad->members->push(inv);\n-            dsymbolSemantic(inv, sc);\n-            return inv;\n-    }\n-}"}, {"sha": "d3006170be76b0bcde2e68d0f6df5b87a6a89005", "filename": "gcc/d/dmd/clone.d", "status": "added", "additions": 1695, "deletions": 0, "changes": 1695, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fclone.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fclone.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fclone.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -0,0 +1,1695 @@\n+/**\n+ * Builds struct member functions if needed and not defined by the user.\n+ * Includes `opEquals`, `opAssign`, post blit, copy constructor and destructor.\n+ *\n+ * Copyright:   Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n+ * Authors:     $(LINK2 http://www.digitalmars.com, Walter Bright)\n+ * License:     $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+ * Source:      $(LINK2 https://github.com/dlang/dmd/blob/master/src/dmd/clone.d, _clone.d)\n+ * Documentation:  https://dlang.org/phobos/dmd_clone.html\n+ * Coverage:    https://codecov.io/gh/dlang/dmd/src/master/src/dmd/clone.d\n+ */\n+\n+module dmd.clone;\n+\n+import core.stdc.stdio;\n+import dmd.aggregate;\n+import dmd.arraytypes;\n+import dmd.astenums;\n+import dmd.dclass;\n+import dmd.declaration;\n+import dmd.dscope;\n+import dmd.dstruct;\n+import dmd.dsymbol;\n+import dmd.dsymbolsem;\n+import dmd.dtemplate;\n+import dmd.errors;\n+import dmd.expression;\n+import dmd.expressionsem;\n+import dmd.func;\n+import dmd.globals;\n+import dmd.id;\n+import dmd.identifier;\n+import dmd.init;\n+import dmd.mtype;\n+import dmd.opover;\n+import dmd.semantic2;\n+import dmd.semantic3;\n+import dmd.statement;\n+import dmd.target;\n+import dmd.typesem;\n+import dmd.tokens;\n+\n+/*******************************************\n+ * Merge function attributes pure, nothrow, @safe, @nogc, and @disable\n+ * from f into s1.\n+ * Params:\n+ *      s1 = storage class to merge into\n+ *      f = function\n+ * Returns:\n+ *      merged storage class\n+ */\n+StorageClass mergeFuncAttrs(StorageClass s1, const FuncDeclaration f) pure\n+{\n+    if (!f)\n+        return s1;\n+    StorageClass s2 = (f.storage_class & STC.disable);\n+\n+    TypeFunction tf = cast(TypeFunction)f.type;\n+    if (tf.trust == TRUST.safe)\n+        s2 |= STC.safe;\n+    else if (tf.trust == TRUST.system)\n+        s2 |= STC.system;\n+    else if (tf.trust == TRUST.trusted)\n+        s2 |= STC.trusted;\n+\n+    if (tf.purity != PURE.impure)\n+        s2 |= STC.pure_;\n+    if (tf.isnothrow)\n+        s2 |= STC.nothrow_;\n+    if (tf.isnogc)\n+        s2 |= STC.nogc;\n+\n+    const sa = s1 & s2;\n+    const so = s1 | s2;\n+\n+    StorageClass stc = (sa & (STC.pure_ | STC.nothrow_ | STC.nogc)) | (so & STC.disable);\n+\n+    if (so & STC.system)\n+        stc |= STC.system;\n+    else if (sa & STC.trusted)\n+        stc |= STC.trusted;\n+    else if ((so & (STC.trusted | STC.safe)) == (STC.trusted | STC.safe))\n+        stc |= STC.trusted;\n+    else if (sa & STC.safe)\n+        stc |= STC.safe;\n+\n+    return stc;\n+}\n+\n+/*******************************************\n+ * Check given aggregate actually has an identity opAssign or not.\n+ * Params:\n+ *      ad = struct or class\n+ *      sc = current scope\n+ * Returns:\n+ *      if found, returns FuncDeclaration of opAssign, otherwise null\n+ */\n+FuncDeclaration hasIdentityOpAssign(AggregateDeclaration ad, Scope* sc)\n+{\n+    Dsymbol assign = search_function(ad, Id.assign);\n+    if (assign)\n+    {\n+        /* check identity opAssign exists\n+         */\n+        scope er = new NullExp(ad.loc, ad.type);    // dummy rvalue\n+        scope el = new IdentifierExp(ad.loc, Id.p); // dummy lvalue\n+        el.type = ad.type;\n+        Expressions a;\n+        a.setDim(1);\n+        const errors = global.startGagging(); // Do not report errors, even if the template opAssign fbody makes it.\n+        sc = sc.push();\n+        sc.tinst = null;\n+        sc.minst = null;\n+\n+        a[0] = er;\n+        auto f = resolveFuncCall(ad.loc, sc, assign, null, ad.type, &a, FuncResolveFlag.quiet);\n+        if (!f)\n+        {\n+            a[0] = el;\n+            f = resolveFuncCall(ad.loc, sc, assign, null, ad.type, &a, FuncResolveFlag.quiet);\n+        }\n+\n+        sc = sc.pop();\n+        global.endGagging(errors);\n+        if (f)\n+        {\n+            if (f.errors)\n+                return null;\n+            auto fparams = f.getParameterList();\n+            if (fparams.length)\n+            {\n+                auto fparam0 = fparams[0];\n+                if (fparam0.type.toDsymbol(null) != ad)\n+                    f = null;\n+            }\n+        }\n+        // BUGS: This detection mechanism cannot find some opAssign-s like follows:\n+        // struct S { void opAssign(ref immutable S) const; }\n+        return f;\n+    }\n+    return null;\n+}\n+\n+/*******************************************\n+ * We need an opAssign for the struct if\n+ * it has a destructor or a postblit.\n+ * We need to generate one if a user-specified one does not exist.\n+ */\n+private bool needOpAssign(StructDeclaration sd)\n+{\n+    //printf(\"StructDeclaration::needOpAssign() %s\\n\", sd.toChars());\n+\n+    static bool isNeeded()\n+    {\n+        //printf(\"\\tneed\\n\");\n+        return true;\n+    }\n+\n+    if (sd.isUnionDeclaration())\n+        return !isNeeded();\n+\n+    if (sd.hasIdentityAssign || // because has identity==elaborate opAssign\n+        sd.dtor ||\n+        sd.postblit)\n+        return isNeeded();\n+\n+    /* If any of the fields need an opAssign, then we\n+     * need it too.\n+     */\n+    foreach (v; sd.fields)\n+    {\n+        if (v.storage_class & STC.ref_)\n+            continue;\n+        if (v.overlapped)               // if field of a union\n+            continue;                   // user must handle it themselves\n+        Type tv = v.type.baseElemOf();\n+        if (tv.ty == Tstruct)\n+        {\n+            TypeStruct ts = cast(TypeStruct)tv;\n+            if (ts.sym.isUnionDeclaration())\n+                continue;\n+            if (needOpAssign(ts.sym))\n+                return isNeeded();\n+        }\n+    }\n+    return !isNeeded();\n+}\n+\n+/******************************************\n+ * Build opAssign for a `struct`.\n+ *\n+ * The generated `opAssign` function has the following signature:\n+ *---\n+ *ref S opAssign(S s)    // S is the name of the `struct`\n+ *---\n+ *\n+ * The opAssign function will be built for a struct `S` if the\n+ * following constraints are met:\n+ *\n+ * 1. `S` does not have an identity `opAssign` defined.\n+ *\n+ * 2. `S` has at least one of the following members: a postblit (user-defined or\n+ * generated for fields that have a defined postblit), a destructor\n+ * (user-defined or generated for fields that have a defined destructor)\n+ * or at least one field that has a defined `opAssign`.\n+ *\n+ * 3. `S` does not have any non-mutable fields.\n+ *\n+ * If `S` has a disabled destructor or at least one field that has a disabled\n+ * `opAssign`, `S.opAssign` is going to be generated, but marked with `@disable`\n+ *\n+ * If `S` defines a destructor, the generated code for `opAssign` is:\n+ *\n+ *---\n+ *S __swap = void;\n+ *__swap = this;   // bit copy\n+ *this = s;        // bit copy\n+ *__swap.dtor();\n+ *---\n+ *\n+ * Otherwise, if `S` defines a postblit, the generated code for `opAssign` is:\n+ *\n+ *---\n+ *this = s;\n+ *---\n+ *\n+ * Note that the parameter to the generated `opAssign` is passed by value, which means\n+ * that the postblit is going to be called (if it is defined) in both  of the above\n+ * situations before entering the body of `opAssign`. The assignments in the above generated\n+ * function bodies are blit expressions, so they can be regarded as `memcpy`s\n+ * (`opAssign` is not called as this will result in an infinite recursion; the postblit\n+ * is not called because it has already been called when the parameter was passed by value).\n+ *\n+ * If `S` does not have a postblit or a destructor, but contains at least one field that defines\n+ * an `opAssign` function (which is not disabled), then the body will make member-wise\n+ * assignments:\n+ *\n+ *---\n+ *this.field1 = s.field1;\n+ *this.field2 = s.field2;\n+ *...;\n+ *---\n+ *\n+ * In this situation, the assignemnts are actual assign expressions (`opAssign` is used\n+ * if defined).\n+ *\n+ * References:\n+ *      https://dlang.org/spec/struct.html#assign-overload\n+ * Params:\n+ *      sd = struct to generate opAssign for\n+ *      sc = context\n+ * Returns:\n+ *      generated `opAssign` function\n+ */\n+FuncDeclaration buildOpAssign(StructDeclaration sd, Scope* sc)\n+{\n+    if (FuncDeclaration f = hasIdentityOpAssign(sd, sc))\n+    {\n+        sd.hasIdentityAssign = true;\n+        return f;\n+    }\n+    // Even if non-identity opAssign is defined, built-in identity opAssign\n+    // will be defined.\n+    if (!needOpAssign(sd))\n+        return null;\n+\n+    //printf(\"StructDeclaration::buildOpAssign() %s\\n\", sd.toChars());\n+    StorageClass stc = STC.safe | STC.nothrow_ | STC.pure_ | STC.nogc;\n+    Loc declLoc = sd.loc;\n+    Loc loc; // internal code should have no loc to prevent coverage\n+\n+    // One of our sub-field might have `@disable opAssign` so we need to\n+    // check for it.\n+    // In this event, it will be reflected by having `stc` (opAssign's\n+    // storage class) include `STC.disabled`.\n+    foreach (v; sd.fields)\n+    {\n+        if (v.storage_class & STC.ref_)\n+            continue;\n+        if (v.overlapped)\n+            continue;\n+        Type tv = v.type.baseElemOf();\n+        if (tv.ty != Tstruct)\n+            continue;\n+        StructDeclaration sdv = (cast(TypeStruct)tv).sym;\n+        stc = mergeFuncAttrs(stc, hasIdentityOpAssign(sdv, sc));\n+    }\n+\n+    if (sd.dtor || sd.postblit)\n+    {\n+        // if the type is not assignable, we cannot generate opAssign\n+        if (!sd.type.isAssignable()) // https://issues.dlang.org/show_bug.cgi?id=13044\n+            return null;\n+        stc = mergeFuncAttrs(stc, sd.dtor);\n+        if (stc & STC.safe)\n+            stc = (stc & ~STC.safe) | STC.trusted;\n+    }\n+\n+    auto fparams = new Parameters();\n+    fparams.push(new Parameter(STC.nodtor, sd.type, Id.p, null, null));\n+    auto tf = new TypeFunction(ParameterList(fparams), sd.handleType(), LINK.d, stc | STC.ref_);\n+    auto fop = new FuncDeclaration(declLoc, Loc.initial, Id.assign, stc, tf);\n+    fop.storage_class |= STC.inference;\n+    fop.generated = true;\n+    Expression e;\n+    if (stc & STC.disable)\n+    {\n+        e = null;\n+    }\n+    /* Do swap this and rhs.\n+     *    __swap = this; this = s; __swap.dtor();\n+     */\n+    else if (sd.dtor)\n+    {\n+        //printf(\"\\tswap copy\\n\");\n+        TypeFunction tdtor = cast(TypeFunction)sd.dtor.type;\n+        assert(tdtor.ty == Tfunction);\n+\n+        auto idswap = Identifier.generateId(\"__swap\");\n+        auto swap = new VarDeclaration(loc, sd.type, idswap, new VoidInitializer(loc));\n+        swap.storage_class |= STC.nodtor | STC.temp | STC.ctfe;\n+        if (tdtor.isScopeQual)\n+            swap.storage_class |= STC.scope_;\n+        auto e1 = new DeclarationExp(loc, swap);\n+\n+        auto e2 = new BlitExp(loc, new VarExp(loc, swap), new ThisExp(loc));\n+        auto e3 = new BlitExp(loc, new ThisExp(loc), new IdentifierExp(loc, Id.p));\n+\n+        /* Instead of running the destructor on s, run it\n+         * on swap. This avoids needing to copy swap back in to s.\n+         */\n+        auto e4 = new CallExp(loc, new DotVarExp(loc, new VarExp(loc, swap), sd.dtor, false));\n+\n+        e = Expression.combine(e1, e2, e3, e4);\n+    }\n+    /* postblit was called when the value was passed to opAssign, we just need to blit the result */\n+    else if (sd.postblit)\n+    {\n+        e = new BlitExp(loc, new ThisExp(loc), new IdentifierExp(loc, Id.p));\n+        sd.hasBlitAssign = true;\n+    }\n+    else\n+    {\n+        /* Do memberwise copy.\n+         *\n+         * If sd is a nested struct, its vthis field assignment is:\n+         * 1. If it's nested in a class, it's a rebind of class reference.\n+         * 2. If it's nested in a function or struct, it's an update of void*.\n+         * In both cases, it will change the parent context.\n+         */\n+        //printf(\"\\tmemberwise copy\\n\");\n+        e = null;\n+        foreach (v; sd.fields)\n+        {\n+            // this.v = s.v;\n+            auto ec = new AssignExp(loc,\n+                new DotVarExp(loc, new ThisExp(loc), v),\n+                new DotVarExp(loc, new IdentifierExp(loc, Id.p), v));\n+            e = Expression.combine(e, ec);\n+        }\n+    }\n+    if (e)\n+    {\n+        Statement s1 = new ExpStatement(loc, e);\n+        /* Add:\n+         *   return this;\n+         */\n+        auto er = new ThisExp(loc);\n+        Statement s2 = new ReturnStatement(loc, er);\n+        fop.fbody = new CompoundStatement(loc, s1, s2);\n+        tf.isreturn = true;\n+    }\n+    sd.members.push(fop);\n+    fop.addMember(sc, sd);\n+    sd.hasIdentityAssign = true; // temporary mark identity assignable\n+    const errors = global.startGagging(); // Do not report errors, even if the template opAssign fbody makes it.\n+    Scope* sc2 = sc.push();\n+    sc2.stc = 0;\n+    sc2.linkage = LINK.d;\n+    fop.dsymbolSemantic(sc2);\n+    fop.semantic2(sc2);\n+    // https://issues.dlang.org/show_bug.cgi?id=15044\n+    //semantic3(fop, sc2); // isn't run here for lazy forward reference resolution.\n+\n+    sc2.pop();\n+    if (global.endGagging(errors)) // if errors happened\n+    {\n+        // Disable generated opAssign, because some members forbid identity assignment.\n+        fop.storage_class |= STC.disable;\n+        fop.fbody = null; // remove fbody which contains the error\n+    }\n+\n+    //printf(\"-StructDeclaration::buildOpAssign() %s, errors = %d\\n\", sd.toChars(), (fop.storage_class & STC.disable) != 0);\n+    //printf(\"fop.type: %s\\n\", fop.type.toPrettyChars());\n+    return fop;\n+}\n+\n+/*******************************************\n+ * We need an opEquals for the struct if\n+ * any fields has an opEquals.\n+ * Generate one if a user-specified one does not exist.\n+ */\n+bool needOpEquals(StructDeclaration sd)\n+{\n+    //printf(\"StructDeclaration::needOpEquals() %s\\n\", sd.toChars());\n+    if (sd.isUnionDeclaration())\n+        goto Ldontneed;\n+    if (sd.hasIdentityEquals)\n+        goto Lneed;\n+    /* If any of the fields has an opEquals, then we\n+     * need it too.\n+     */\n+    foreach (VarDeclaration v; sd.fields)\n+    {\n+        if (v.storage_class & STC.ref_)\n+            continue;\n+        if (v.overlapped)\n+            continue;\n+        Type tv = v.type.toBasetype();\n+        auto tvbase = tv.baseElemOf();\n+        if (tvbase.ty == Tstruct)\n+        {\n+            TypeStruct ts = cast(TypeStruct)tvbase;\n+            if (ts.sym.isUnionDeclaration())\n+                continue;\n+            if (needOpEquals(ts.sym))\n+                goto Lneed;\n+        }\n+        if (tvbase.isfloating())\n+        {\n+            // This is necessray for:\n+            //  1. comparison of +0.0 and -0.0 should be true.\n+            //  2. comparison of NANs should be false always.\n+            goto Lneed;\n+        }\n+        if (tvbase.ty == Tarray)\n+            goto Lneed;\n+        if (tvbase.ty == Taarray)\n+            goto Lneed;\n+        if (tvbase.ty == Tclass)\n+            goto Lneed;\n+    }\n+Ldontneed:\n+    //printf(\"\\tdontneed\\n\");\n+    return false;\n+Lneed:\n+    //printf(\"\\tneed\\n\");\n+    return true;\n+}\n+\n+/*******************************************\n+ * Check given aggregate actually has an identity opEquals or not.\n+ */\n+private FuncDeclaration hasIdentityOpEquals(AggregateDeclaration ad, Scope* sc)\n+{\n+    FuncDeclaration f;\n+    if (Dsymbol eq = search_function(ad, Id.eq))\n+    {\n+        /* check identity opEquals exists\n+         */\n+        scope er = new NullExp(ad.loc, null); // dummy rvalue\n+        scope el = new IdentifierExp(ad.loc, Id.p); // dummy lvalue\n+        Expressions a;\n+        a.setDim(1);\n+\n+        bool hasIt(Type tthis)\n+        {\n+            const errors = global.startGagging(); // Do not report errors, even if the template opAssign fbody makes it\n+            sc = sc.push();\n+            sc.tinst = null;\n+            sc.minst = null;\n+\n+            FuncDeclaration rfc(Expression e)\n+            {\n+                a[0] = e;\n+                a[0].type = tthis;\n+                return resolveFuncCall(ad.loc, sc, eq, null, tthis, &a, FuncResolveFlag.quiet);\n+            }\n+\n+            f = rfc(er);\n+            if (!f)\n+                f = rfc(el);\n+\n+            sc = sc.pop();\n+            global.endGagging(errors);\n+\n+            return f !is null;\n+        }\n+\n+        if (hasIt(ad.type)               ||\n+            hasIt(ad.type.constOf())     ||\n+            hasIt(ad.type.immutableOf()) ||\n+            hasIt(ad.type.sharedOf())    ||\n+            hasIt(ad.type.sharedConstOf()))\n+        {\n+            if (f.errors)\n+                return null;\n+        }\n+    }\n+    return f;\n+}\n+\n+/******************************************\n+ * Build opEquals for struct.\n+ *      const bool opEquals(const S s) { ... }\n+ *\n+ * By fixing https://issues.dlang.org/show_bug.cgi?id=3789\n+ * opEquals is changed to be never implicitly generated.\n+ * Now, struct objects comparison s1 == s2 is translated to:\n+ *      s1.tupleof == s2.tupleof\n+ * to calculate structural equality. See EqualExp.op_overload.\n+ */\n+FuncDeclaration buildOpEquals(StructDeclaration sd, Scope* sc)\n+{\n+    if (hasIdentityOpEquals(sd, sc))\n+    {\n+        sd.hasIdentityEquals = true;\n+    }\n+    return null;\n+}\n+\n+/******************************************\n+ * Build __xopEquals for TypeInfo_Struct\n+ *      static bool __xopEquals(ref const S p, ref const S q)\n+ *      {\n+ *          return p == q;\n+ *      }\n+ *\n+ * This is called by TypeInfo.equals(p1, p2). If the struct does not support\n+ * const objects comparison, it will throw \"not implemented\" Error in runtime.\n+ */\n+FuncDeclaration buildXopEquals(StructDeclaration sd, Scope* sc)\n+{\n+    if (!needOpEquals(sd))\n+        return null; // bitwise comparison would work\n+\n+    //printf(\"StructDeclaration::buildXopEquals() %s\\n\", sd.toChars());\n+    if (Dsymbol eq = search_function(sd, Id.eq))\n+    {\n+        if (FuncDeclaration fd = eq.isFuncDeclaration())\n+        {\n+            TypeFunction tfeqptr;\n+            {\n+                Scope scx;\n+                /* const bool opEquals(ref const S s);\n+                 */\n+                auto parameters = new Parameters();\n+                parameters.push(new Parameter(STC.ref_ | STC.const_, sd.type, null, null, null));\n+                tfeqptr = new TypeFunction(ParameterList(parameters), Type.tbool, LINK.d);\n+                tfeqptr.mod = MODFlags.const_;\n+                tfeqptr = cast(TypeFunction)tfeqptr.typeSemantic(Loc.initial, &scx);\n+            }\n+            fd = fd.overloadExactMatch(tfeqptr);\n+            if (fd)\n+                return fd;\n+        }\n+    }\n+    if (!sd.xerreq)\n+    {\n+        // object._xopEquals\n+        Identifier id = Identifier.idPool(\"_xopEquals\");\n+        Expression e = new IdentifierExp(sd.loc, Id.empty);\n+        e = new DotIdExp(sd.loc, e, Id.object);\n+        e = new DotIdExp(sd.loc, e, id);\n+        e = e.expressionSemantic(sc);\n+        Dsymbol s = getDsymbol(e);\n+        assert(s);\n+        sd.xerreq = s.isFuncDeclaration();\n+    }\n+    Loc declLoc; // loc is unnecessary so __xopEquals is never called directly\n+    Loc loc; // loc is unnecessary so errors are gagged\n+    auto parameters = new Parameters();\n+    parameters.push(new Parameter(STC.ref_ | STC.const_, sd.type, Id.p, null, null))\n+              .push(new Parameter(STC.ref_ | STC.const_, sd.type, Id.q, null, null));\n+    auto tf = new TypeFunction(ParameterList(parameters), Type.tbool, LINK.d);\n+    Identifier id = Id.xopEquals;\n+    auto fop = new FuncDeclaration(declLoc, Loc.initial, id, STC.static_, tf);\n+    fop.generated = true;\n+    Expression e1 = new IdentifierExp(loc, Id.p);\n+    Expression e2 = new IdentifierExp(loc, Id.q);\n+    Expression e = new EqualExp(TOK.equal, loc, e1, e2);\n+    fop.fbody = new ReturnStatement(loc, e);\n+    uint errors = global.startGagging(); // Do not report errors\n+    Scope* sc2 = sc.push();\n+    sc2.stc = 0;\n+    sc2.linkage = LINK.d;\n+    fop.dsymbolSemantic(sc2);\n+    fop.semantic2(sc2);\n+    sc2.pop();\n+    if (global.endGagging(errors)) // if errors happened\n+        fop = sd.xerreq;\n+    return fop;\n+}\n+\n+/******************************************\n+ * Build __xopCmp for TypeInfo_Struct\n+ *      static bool __xopCmp(ref const S p, ref const S q)\n+ *      {\n+ *          return p.opCmp(q);\n+ *      }\n+ *\n+ * This is called by TypeInfo.compare(p1, p2). If the struct does not support\n+ * const objects comparison, it will throw \"not implemented\" Error in runtime.\n+ */\n+FuncDeclaration buildXopCmp(StructDeclaration sd, Scope* sc)\n+{\n+    //printf(\"StructDeclaration::buildXopCmp() %s\\n\", toChars());\n+    if (Dsymbol cmp = search_function(sd, Id.cmp))\n+    {\n+        if (FuncDeclaration fd = cmp.isFuncDeclaration())\n+        {\n+            TypeFunction tfcmpptr;\n+            {\n+                Scope scx;\n+                /* const int opCmp(ref const S s);\n+                 */\n+                auto parameters = new Parameters();\n+                parameters.push(new Parameter(STC.ref_ | STC.const_, sd.type, null, null, null));\n+                tfcmpptr = new TypeFunction(ParameterList(parameters), Type.tint32, LINK.d);\n+                tfcmpptr.mod = MODFlags.const_;\n+                tfcmpptr = cast(TypeFunction)tfcmpptr.typeSemantic(Loc.initial, &scx);\n+            }\n+            fd = fd.overloadExactMatch(tfcmpptr);\n+            if (fd)\n+                return fd;\n+        }\n+    }\n+    else\n+    {\n+        version (none) // FIXME: doesn't work for recursive alias this\n+        {\n+            /* Check opCmp member exists.\n+             * Consider 'alias this', but except opDispatch.\n+             */\n+            Expression e = new DsymbolExp(sd.loc, sd);\n+            e = new DotIdExp(sd.loc, e, Id.cmp);\n+            Scope* sc2 = sc.push();\n+            e = e.trySemantic(sc2);\n+            sc2.pop();\n+            if (e)\n+            {\n+                Dsymbol s = null;\n+                switch (e.op)\n+                {\n+                case TOK.overloadSet:\n+                    s = (cast(OverExp)e).vars;\n+                    break;\n+                case TOK.scope_:\n+                    s = (cast(ScopeExp)e).sds;\n+                    break;\n+                case TOK.variable:\n+                    s = (cast(VarExp)e).var;\n+                    break;\n+                default:\n+                    break;\n+                }\n+                if (!s || s.ident != Id.cmp)\n+                    e = null; // there's no valid member 'opCmp'\n+            }\n+            if (!e)\n+                return null; // bitwise comparison would work\n+            /* Essentially, a struct which does not define opCmp is not comparable.\n+             * At this time, typeid(S).compare might be correct that throwing \"not implement\" Error.\n+             * But implementing it would break existing code, such as:\n+             *\n+             * struct S { int value; }  // no opCmp\n+             * int[S] aa;   // Currently AA key uses bitwise comparison\n+             *              // (It's default behavior of TypeInfo_Strust.compare).\n+             *\n+             * Not sure we should fix this inconsistency, so just keep current behavior.\n+             */\n+        }\n+        else\n+        {\n+            return null;\n+        }\n+    }\n+    if (!sd.xerrcmp)\n+    {\n+        // object._xopCmp\n+        Identifier id = Identifier.idPool(\"_xopCmp\");\n+        Expression e = new IdentifierExp(sd.loc, Id.empty);\n+        e = new DotIdExp(sd.loc, e, Id.object);\n+        e = new DotIdExp(sd.loc, e, id);\n+        e = e.expressionSemantic(sc);\n+        Dsymbol s = getDsymbol(e);\n+        assert(s);\n+        sd.xerrcmp = s.isFuncDeclaration();\n+    }\n+    Loc declLoc; // loc is unnecessary so __xopCmp is never called directly\n+    Loc loc; // loc is unnecessary so errors are gagged\n+    auto parameters = new Parameters();\n+    parameters.push(new Parameter(STC.ref_ | STC.const_, sd.type, Id.p, null, null));\n+    parameters.push(new Parameter(STC.ref_ | STC.const_, sd.type, Id.q, null, null));\n+    auto tf = new TypeFunction(ParameterList(parameters), Type.tint32, LINK.d);\n+    Identifier id = Id.xopCmp;\n+    auto fop = new FuncDeclaration(declLoc, Loc.initial, id, STC.static_, tf);\n+    fop.generated = true;\n+    Expression e1 = new IdentifierExp(loc, Id.p);\n+    Expression e2 = new IdentifierExp(loc, Id.q);\n+    version (IN_GCC)\n+        Expression e = new CallExp(loc, new DotIdExp(loc, e1, Id.cmp), e2);\n+    else\n+        Expression e = new CallExp(loc, new DotIdExp(loc, e2, Id.cmp), e1);\n+    fop.fbody = new ReturnStatement(loc, e);\n+    uint errors = global.startGagging(); // Do not report errors\n+    Scope* sc2 = sc.push();\n+    sc2.stc = 0;\n+    sc2.linkage = LINK.d;\n+    fop.dsymbolSemantic(sc2);\n+    fop.semantic2(sc2);\n+    sc2.pop();\n+    if (global.endGagging(errors)) // if errors happened\n+        fop = sd.xerrcmp;\n+    return fop;\n+}\n+\n+/*******************************************\n+ * We need a toHash for the struct if\n+ * any fields has a toHash.\n+ * Generate one if a user-specified one does not exist.\n+ */\n+private bool needToHash(StructDeclaration sd)\n+{\n+    //printf(\"StructDeclaration::needToHash() %s\\n\", sd.toChars());\n+    if (sd.isUnionDeclaration())\n+        goto Ldontneed;\n+    if (sd.xhash)\n+        goto Lneed;\n+\n+    /* If any of the fields has an toHash, then we\n+     * need it too.\n+     */\n+    foreach (VarDeclaration v; sd.fields)\n+    {\n+        if (v.storage_class & STC.ref_)\n+            continue;\n+        if (v.overlapped)\n+            continue;\n+        Type tv = v.type.toBasetype();\n+        auto tvbase = tv.baseElemOf();\n+        if (tvbase.ty == Tstruct)\n+        {\n+            TypeStruct ts = cast(TypeStruct)tvbase;\n+            if (ts.sym.isUnionDeclaration())\n+                continue;\n+            if (needToHash(ts.sym))\n+                goto Lneed;\n+        }\n+        if (tvbase.isfloating())\n+        {\n+            /* This is necessary because comparison of +0.0 and -0.0 should be true,\n+             * i.e. not a bit compare.\n+             */\n+            goto Lneed;\n+        }\n+        if (tvbase.ty == Tarray)\n+            goto Lneed;\n+        if (tvbase.ty == Taarray)\n+            goto Lneed;\n+        if (tvbase.ty == Tclass)\n+            goto Lneed;\n+    }\n+Ldontneed:\n+    //printf(\"\\tdontneed\\n\");\n+    return false;\n+Lneed:\n+    //printf(\"\\tneed\\n\");\n+    return true;\n+}\n+\n+/******************************************\n+ * Build __xtoHash for non-bitwise hashing\n+ *      static hash_t xtoHash(ref const S p) nothrow @trusted;\n+ */\n+FuncDeclaration buildXtoHash(StructDeclaration sd, Scope* sc)\n+{\n+    if (Dsymbol s = search_function(sd, Id.tohash))\n+    {\n+        __gshared TypeFunction tftohash;\n+        if (!tftohash)\n+        {\n+            tftohash = new TypeFunction(ParameterList(), Type.thash_t, LINK.d);\n+            tftohash.mod = MODFlags.const_;\n+            tftohash = cast(TypeFunction)tftohash.merge();\n+        }\n+        if (FuncDeclaration fd = s.isFuncDeclaration())\n+        {\n+            fd = fd.overloadExactMatch(tftohash);\n+            if (fd)\n+                return fd;\n+        }\n+    }\n+    if (!needToHash(sd))\n+        return null;\n+\n+    //printf(\"StructDeclaration::buildXtoHash() %s\\n\", sd.toPrettyChars());\n+    Loc declLoc; // loc is unnecessary so __xtoHash is never called directly\n+    Loc loc; // internal code should have no loc to prevent coverage\n+    auto parameters = new Parameters();\n+    parameters.push(new Parameter(STC.ref_ | STC.const_, sd.type, Id.p, null, null));\n+    auto tf = new TypeFunction(ParameterList(parameters), Type.thash_t, LINK.d, STC.nothrow_ | STC.trusted);\n+    Identifier id = Id.xtoHash;\n+    auto fop = new FuncDeclaration(declLoc, Loc.initial, id, STC.static_, tf);\n+    fop.generated = true;\n+\n+    /* Do memberwise hashing.\n+     *\n+     * If sd is a nested struct, and if it's nested in a class, the calculated\n+     * hash value will also contain the result of parent class's toHash().\n+     */\n+    const(char)[] code =\n+        \".object.size_t h = 0;\" ~\n+        \"foreach (i, T; typeof(p.tupleof))\" ~\n+        // workaround https://issues.dlang.org/show_bug.cgi?id=17968\n+        \"    static if(is(T* : const(.object.Object)*)) \" ~\n+        \"        h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);\" ~\n+        \"    else \" ~\n+        \"        h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);\" ~\n+        \"return h;\";\n+    fop.fbody = new CompileStatement(loc, new StringExp(loc, code));\n+    Scope* sc2 = sc.push();\n+    sc2.stc = 0;\n+    sc2.linkage = LINK.d;\n+    fop.dsymbolSemantic(sc2);\n+    fop.semantic2(sc2);\n+    sc2.pop();\n+\n+    //printf(\"%s fop = %s %s\\n\", sd.toChars(), fop.toChars(), fop.type.toChars());\n+    return fop;\n+}\n+\n+/*****************************************\n+ * Create inclusive destructor for struct/class by aggregating\n+ * all the destructors in dtors[] with the destructors for\n+ * all the members.\n+ * Params:\n+ *      ad = struct or class to build destructor for\n+ *      sc = context\n+ * Returns:\n+ *      generated function, null if none needed\n+ * Note:\n+ * Close similarity with StructDeclaration::buildPostBlit(),\n+ * and the ordering changes (runs backward instead of forwards).\n+ */\n+DtorDeclaration buildDtor(AggregateDeclaration ad, Scope* sc)\n+{\n+    //printf(\"AggregateDeclaration::buildDtor() %s\\n\", ad.toChars());\n+    if (ad.isUnionDeclaration())\n+        return null;                    // unions don't have destructors\n+\n+    StorageClass stc = STC.safe | STC.nothrow_ | STC.pure_ | STC.nogc;\n+    Loc declLoc = ad.dtors.dim ? ad.dtors[0].loc : ad.loc;\n+    Loc loc; // internal code should have no loc to prevent coverage\n+    FuncDeclaration xdtor_fwd = null;\n+\n+    // if the dtor is an extern(C++) prototype, then we expect it performs a full-destruction; we don't need to build a full-dtor\n+    const bool dtorIsCppPrototype = ad.dtors.dim == 1 && ad.dtors[0].linkage == LINK.cpp && !ad.dtors[0].fbody;\n+    if (!dtorIsCppPrototype)\n+    {\n+        Expression e = null;\n+        for (size_t i = 0; i < ad.fields.dim; i++)\n+        {\n+            auto v = ad.fields[i];\n+            if (v.storage_class & STC.ref_)\n+                continue;\n+            if (v.overlapped)\n+                continue;\n+            auto tv = v.type.baseElemOf();\n+            if (tv.ty != Tstruct)\n+                continue;\n+            auto sdv = (cast(TypeStruct)tv).sym;\n+            if (!sdv.dtor)\n+                continue;\n+\n+            // fix: https://issues.dlang.org/show_bug.cgi?id=17257\n+            // braces for shrink wrapping scope of a\n+            {\n+                xdtor_fwd = sdv.dtor; // this dtor is temporary it could be anything\n+                auto a = new AliasDeclaration(Loc.initial, Id.__xdtor, xdtor_fwd);\n+                a.addMember(sc, ad); // temporarily add to symbol table\n+            }\n+\n+            sdv.dtor.functionSemantic();\n+\n+            stc = mergeFuncAttrs(stc, sdv.dtor);\n+            if (stc & STC.disable)\n+            {\n+                e = null;\n+                break;\n+            }\n+\n+            Expression ex;\n+            tv = v.type.toBasetype();\n+            if (tv.ty == Tstruct)\n+            {\n+                // this.v.__xdtor()\n+\n+                ex = new ThisExp(loc);\n+                ex = new DotVarExp(loc, ex, v);\n+\n+                // This is a hack so we can call destructors on const/immutable objects.\n+                // Do it as a type 'paint'.\n+                ex = new CastExp(loc, ex, v.type.mutableOf());\n+                if (stc & STC.safe)\n+                    stc = (stc & ~STC.safe) | STC.trusted;\n+\n+                ex = new DotVarExp(loc, ex, sdv.dtor, false);\n+                ex = new CallExp(loc, ex);\n+            }\n+            else\n+            {\n+                // __ArrayDtor((cast(S*)this.v.ptr)[0 .. n])\n+\n+                const n = tv.numberOfElems(loc);\n+                if (n == 0)\n+                    continue;\n+\n+                ex = new ThisExp(loc);\n+                ex = new DotVarExp(loc, ex, v);\n+\n+                // This is a hack so we can call destructors on const/immutable objects.\n+                ex = new DotIdExp(loc, ex, Id.ptr);\n+                ex = new CastExp(loc, ex, sdv.type.pointerTo());\n+                if (stc & STC.safe)\n+                    stc = (stc & ~STC.safe) | STC.trusted;\n+\n+                ex = new SliceExp(loc, ex, new IntegerExp(loc, 0, Type.tsize_t),\n+                                           new IntegerExp(loc, n, Type.tsize_t));\n+                // Prevent redundant bounds check\n+                (cast(SliceExp)ex).upperIsInBounds = true;\n+                (cast(SliceExp)ex).lowerIsLessThanUpper = true;\n+\n+                ex = new CallExp(loc, new IdentifierExp(loc, Id.__ArrayDtor), ex);\n+            }\n+            e = Expression.combine(ex, e); // combine in reverse order\n+        }\n+\n+        /* extern(C++) destructors call into super to destruct the full hierarchy\n+        */\n+        ClassDeclaration cldec = ad.isClassDeclaration();\n+        if (cldec && cldec.classKind == ClassKind.cpp && cldec.baseClass && cldec.baseClass.primaryDtor)\n+        {\n+            // WAIT BUT: do I need to run `cldec.baseClass.dtor` semantic? would it have been run before?\n+            cldec.baseClass.dtor.functionSemantic();\n+\n+            stc = mergeFuncAttrs(stc, cldec.baseClass.primaryDtor);\n+            if (!(stc & STC.disable))\n+            {\n+                // super.__xdtor()\n+\n+                Expression ex = new SuperExp(loc);\n+\n+                // This is a hack so we can call destructors on const/immutable objects.\n+                // Do it as a type 'paint'.\n+                ex = new CastExp(loc, ex, cldec.baseClass.type.mutableOf());\n+                if (stc & STC.safe)\n+                    stc = (stc & ~STC.safe) | STC.trusted;\n+\n+                ex = new DotVarExp(loc, ex, cldec.baseClass.primaryDtor, false);\n+                ex = new CallExp(loc, ex);\n+\n+                e = Expression.combine(e, ex); // super dtor last\n+            }\n+        }\n+\n+        /* Build our own \"destructor\" which executes e\n+         */\n+        if (e || (stc & STC.disable))\n+        {\n+            //printf(\"Building __fieldDtor(), %s\\n\", e.toChars());\n+            auto dd = new DtorDeclaration(declLoc, Loc.initial, stc, Id.__fieldDtor);\n+            dd.generated = true;\n+            dd.storage_class |= STC.inference;\n+            dd.fbody = new ExpStatement(loc, e);\n+            ad.dtors.shift(dd);\n+            ad.members.push(dd);\n+            dd.dsymbolSemantic(sc);\n+            ad.fieldDtor = dd;\n+        }\n+    }\n+\n+    DtorDeclaration xdtor = null;\n+    switch (ad.dtors.dim)\n+    {\n+    case 0:\n+        break;\n+\n+    case 1:\n+        xdtor = ad.dtors[0];\n+        break;\n+\n+    default:\n+        assert(!dtorIsCppPrototype);\n+        Expression e = null;\n+        e = null;\n+        stc = STC.safe | STC.nothrow_ | STC.pure_ | STC.nogc;\n+        foreach (FuncDeclaration fd; ad.dtors)\n+        {\n+            stc = mergeFuncAttrs(stc, fd);\n+            if (stc & STC.disable)\n+            {\n+                e = null;\n+                break;\n+            }\n+            Expression ex = new ThisExp(loc);\n+            ex = new DotVarExp(loc, ex, fd, false);\n+            ex = new CallExp(loc, ex);\n+            e = Expression.combine(ex, e);\n+        }\n+        auto dd = new DtorDeclaration(declLoc, Loc.initial, stc, Id.__aggrDtor);\n+        dd.generated = true;\n+        dd.storage_class |= STC.inference;\n+        dd.fbody = new ExpStatement(loc, e);\n+        ad.members.push(dd);\n+        dd.dsymbolSemantic(sc);\n+        xdtor = dd;\n+        break;\n+    }\n+\n+    ad.primaryDtor = xdtor;\n+\n+    if (xdtor && xdtor.linkage == LINK.cpp && !target.cpp.twoDtorInVtable)\n+        xdtor = buildWindowsCppDtor(ad, xdtor, sc);\n+\n+    // Add an __xdtor alias to make the inclusive dtor accessible\n+    if (xdtor)\n+    {\n+        auto _alias = new AliasDeclaration(Loc.initial, Id.__xdtor, xdtor);\n+        _alias.dsymbolSemantic(sc);\n+        ad.members.push(_alias);\n+        if (xdtor_fwd)\n+            ad.symtab.update(_alias); // update forward dtor to correct one\n+        else\n+            _alias.addMember(sc, ad); // add to symbol table\n+    }\n+\n+    return xdtor;\n+}\n+\n+/**\n+ * build a shim function around the compound dtor that accepts an argument\n+ *  that is used to implement the deleting C++ destructor\n+ *\n+ * Params:\n+ *  ad = the aggregate that contains the destructor to wrap\n+ *  dtor = the destructor to wrap\n+ *  sc = the scope in which to analyze the new function\n+ *\n+ * Returns:\n+ *  the shim destructor, semantically analyzed and added to the class as a member\n+ */\n+private DtorDeclaration buildWindowsCppDtor(AggregateDeclaration ad, DtorDeclaration dtor, Scope* sc)\n+{\n+    auto cldec = ad.isClassDeclaration();\n+    if (!cldec || cldec.cppDtorVtblIndex == -1) // scalar deleting dtor not built for non-virtual dtors\n+        return dtor;\n+\n+    // generate deleting C++ destructor corresponding to:\n+    // void* C::~C(int del)\n+    // {\n+    //   this->~C();\n+    //   // TODO: if (del) delete (char*)this;\n+    //   return (void*) this;\n+    // }\n+    Parameter delparam = new Parameter(STC.undefined_, Type.tuns32, Identifier.idPool(\"del\"), new IntegerExp(dtor.loc, 0, Type.tuns32), null);\n+    Parameters* params = new Parameters;\n+    params.push(delparam);\n+    auto ftype = new TypeFunction(ParameterList(params), Type.tvoidptr, LINK.cpp, dtor.storage_class);\n+    auto func = new DtorDeclaration(dtor.loc, dtor.loc, dtor.storage_class, Id.cppdtor);\n+    func.type = ftype;\n+    if (dtor.fbody)\n+    {\n+        const loc = dtor.loc;\n+        auto stmts = new Statements;\n+        auto call = new CallExp(loc, dtor, null);\n+        call.directcall = true;\n+        stmts.push(new ExpStatement(loc, call));\n+        stmts.push(new ReturnStatement(loc, new CastExp(loc, new ThisExp(loc), Type.tvoidptr)));\n+        func.fbody = new CompoundStatement(loc, stmts);\n+        func.generated = true;\n+    }\n+\n+    auto sc2 = sc.push();\n+    sc2.stc &= ~STC.static_; // not a static destructor\n+    sc2.linkage = LINK.cpp;\n+\n+    ad.members.push(func);\n+    func.addMember(sc2, ad);\n+    func.dsymbolSemantic(sc2);\n+\n+    sc2.pop();\n+    return func;\n+}\n+\n+/**\n+ * build a shim function around the compound dtor that translates\n+ *  a C++ destructor to a destructor with extern(D) calling convention\n+ *\n+ * Params:\n+ *  ad = the aggregate that contains the destructor to wrap\n+ *  sc = the scope in which to analyze the new function\n+ *\n+ * Returns:\n+ *  the shim destructor, semantically analyzed and added to the class as a member\n+ */\n+DtorDeclaration buildExternDDtor(AggregateDeclaration ad, Scope* sc)\n+{\n+    auto dtor = ad.primaryDtor;\n+    if (!dtor)\n+        return null;\n+\n+    // Generate shim only when ABI incompatible on target platform\n+    if (ad.classKind != ClassKind.cpp || !target.cpp.wrapDtorInExternD)\n+        return dtor;\n+\n+    // generate member function that adjusts calling convention\n+    // (EAX used for 'this' instead of ECX on Windows/stack on others):\n+    // extern(D) void __ticppdtor()\n+    // {\n+    //     Class.__dtor();\n+    // }\n+    auto ftype = new TypeFunction(ParameterList(), Type.tvoid, LINK.d, dtor.storage_class);\n+    auto func = new DtorDeclaration(dtor.loc, dtor.loc, dtor.storage_class, Id.ticppdtor);\n+    func.type = ftype;\n+\n+    auto call = new CallExp(dtor.loc, dtor, null);\n+    call.directcall = true;                   // non-virtual call Class.__dtor();\n+    func.fbody = new ExpStatement(dtor.loc, call);\n+    func.generated = true;\n+    func.storage_class |= STC.inference;\n+\n+    auto sc2 = sc.push();\n+    sc2.stc &= ~STC.static_; // not a static destructor\n+    sc2.linkage = LINK.d;\n+\n+    ad.members.push(func);\n+    func.addMember(sc2, ad);\n+    func.dsymbolSemantic(sc2);\n+    func.functionSemantic(); // to infer attributes\n+\n+    sc2.pop();\n+    return func;\n+}\n+\n+/******************************************\n+ * Create inclusive invariant for struct/class by aggregating\n+ * all the invariants in invs[].\n+ * ---\n+ * void __invariant() const [pure nothrow @trusted]\n+ * {\n+ *     invs[0](), invs[1](), ...;\n+ * }\n+ * ---\n+ */\n+FuncDeclaration buildInv(AggregateDeclaration ad, Scope* sc)\n+{\n+    switch (ad.invs.dim)\n+    {\n+    case 0:\n+        return null;\n+\n+    case 1:\n+        // Don't return invs[0] so it has uniquely generated name.\n+        goto default;\n+\n+    default:\n+        Expression e = null;\n+        StorageClass stcx = 0;\n+        StorageClass stc = STC.safe | STC.nothrow_ | STC.pure_ | STC.nogc;\n+        foreach (i, inv; ad.invs)\n+        {\n+            stc = mergeFuncAttrs(stc, inv);\n+            if (stc & STC.disable)\n+            {\n+                // What should do?\n+            }\n+            const stcy = (inv.storage_class & STC.synchronized_) |\n+                         (inv.type.mod & MODFlags.shared_ ? STC.shared_ : 0);\n+            if (i == 0)\n+                stcx = stcy;\n+            else if (stcx ^ stcy)\n+            {\n+                version (all)\n+                {\n+                    // currently rejects\n+                    ad.error(inv.loc, \"mixing invariants with different `shared`/`synchronized` qualifiers is not supported\");\n+                    e = null;\n+                    break;\n+                }\n+            }\n+            e = Expression.combine(e, new CallExp(Loc.initial, new VarExp(Loc.initial, inv, false)));\n+        }\n+        auto inv = new InvariantDeclaration(ad.loc, Loc.initial, stc | stcx,\n+                Id.classInvariant, new ExpStatement(Loc.initial, e));\n+        ad.members.push(inv);\n+        inv.dsymbolSemantic(sc);\n+        return inv;\n+    }\n+}\n+\n+/*****************************************\n+ * Create inclusive postblit for struct by aggregating\n+ * all the postblits in postblits[] with the postblits for\n+ * all the members.\n+ * Note the close similarity with AggregateDeclaration::buildDtor(),\n+ * and the ordering changes (runs forward instead of backwards).\n+ */\n+FuncDeclaration buildPostBlit(StructDeclaration sd, Scope* sc)\n+{\n+    //printf(\"buildPostBlit() %s\\n\", sd.toChars());\n+    if (sd.isUnionDeclaration())\n+        return null;\n+\n+    const hasUserDefinedPosblit = sd.postblits.dim && !sd.postblits[0].isDisabled ? true : false;\n+\n+    // by default, the storage class of the created postblit\n+    StorageClass stc = STC.safe | STC.nothrow_ | STC.pure_ | STC.nogc;\n+    Loc declLoc = sd.postblits.dim ? sd.postblits[0].loc : sd.loc;\n+    Loc loc; // internal code should have no loc to prevent coverage\n+\n+    // if any of the postblits are disabled, then the generated postblit\n+    // will be disabled\n+    foreach (postblit; sd.postblits)\n+        stc |= postblit.storage_class & STC.disable;\n+\n+    VarDeclaration[] fieldsToDestroy;\n+    auto postblitCalls = new Statements();\n+    // iterate through all the struct fields that are not disabled\n+    for (size_t i = 0; i < sd.fields.dim && !(stc & STC.disable); i++)\n+    {\n+        auto structField = sd.fields[i];\n+        if (structField.storage_class & STC.ref_)\n+            continue;\n+        if (structField.overlapped)\n+            continue;\n+        // if it's a struct declaration or an array of structs\n+        Type tv = structField.type.baseElemOf();\n+        if (tv.ty != Tstruct)\n+            continue;\n+        auto sdv = (cast(TypeStruct)tv).sym;\n+        // which has a postblit declaration\n+        if (!sdv.postblit)\n+            continue;\n+        assert(!sdv.isUnionDeclaration());\n+\n+        // if this field's postblit is not `nothrow`, add a `scope(failure)`\n+        // block to destroy any prior successfully postblitted fields should\n+        // this field's postblit fail\n+        if (fieldsToDestroy.length > 0 && !(cast(TypeFunction)sdv.postblit.type).isnothrow)\n+        {\n+             // create a list of destructors that need to be called\n+            Expression[] dtorCalls;\n+            foreach(sf; fieldsToDestroy)\n+            {\n+                Expression ex;\n+                tv = sf.type.toBasetype();\n+                if (tv.ty == Tstruct)\n+                {\n+                    // this.v.__xdtor()\n+\n+                    ex = new ThisExp(loc);\n+                    ex = new DotVarExp(loc, ex, sf);\n+\n+                    // This is a hack so we can call destructors on const/immutable objects.\n+                    ex = new AddrExp(loc, ex);\n+                    ex = new CastExp(loc, ex, sf.type.mutableOf().pointerTo());\n+                    ex = new PtrExp(loc, ex);\n+                    if (stc & STC.safe)\n+                        stc = (stc & ~STC.safe) | STC.trusted;\n+\n+                    auto sfv = (cast(TypeStruct)sf.type.baseElemOf()).sym;\n+\n+                    ex = new DotVarExp(loc, ex, sfv.dtor, false);\n+                    ex = new CallExp(loc, ex);\n+\n+                    dtorCalls ~= ex;\n+                }\n+                else\n+                {\n+                    // _ArrayDtor((cast(S*)this.v.ptr)[0 .. n])\n+\n+                    const length = tv.numberOfElems(loc);\n+\n+                    ex = new ThisExp(loc);\n+                    ex = new DotVarExp(loc, ex, sf);\n+\n+                    // This is a hack so we can call destructors on const/immutable objects.\n+                    ex = new DotIdExp(loc, ex, Id.ptr);\n+                    ex = new CastExp(loc, ex, sdv.type.pointerTo());\n+                    if (stc & STC.safe)\n+                        stc = (stc & ~STC.safe) | STC.trusted;\n+\n+                    auto se = new SliceExp(loc, ex, new IntegerExp(loc, 0, Type.tsize_t),\n+                                                    new IntegerExp(loc, length, Type.tsize_t));\n+                    // Prevent redundant bounds check\n+                    se.upperIsInBounds = true;\n+                    se.lowerIsLessThanUpper = true;\n+\n+                    ex = new CallExp(loc, new IdentifierExp(loc, Id.__ArrayDtor), se);\n+\n+                    dtorCalls ~= ex;\n+                }\n+            }\n+            fieldsToDestroy = [];\n+\n+            // aggregate the destructor calls\n+            auto dtors = new Statements();\n+            foreach_reverse(dc; dtorCalls)\n+            {\n+                dtors.push(new ExpStatement(loc, dc));\n+            }\n+\n+            // put destructor calls in a `scope(failure)` block\n+            postblitCalls.push(new ScopeGuardStatement(loc, TOK.onScopeFailure, new CompoundStatement(loc, dtors)));\n+        }\n+\n+        // perform semantic on the member postblit in order to\n+        // be able to aggregate it later on with the rest of the\n+        // postblits\n+        sdv.postblit.functionSemantic();\n+\n+        stc = mergeFuncAttrs(stc, sdv.postblit);\n+        stc = mergeFuncAttrs(stc, sdv.dtor);\n+\n+        // if any of the struct member fields has disabled\n+        // its postblit, then `sd` is not copyable, so no\n+        // postblit is generated\n+        if (stc & STC.disable)\n+        {\n+            postblitCalls.setDim(0);\n+            break;\n+        }\n+\n+        Expression ex;\n+        tv = structField.type.toBasetype();\n+        if (tv.ty == Tstruct)\n+        {\n+            // this.v.__xpostblit()\n+\n+            ex = new ThisExp(loc);\n+            ex = new DotVarExp(loc, ex, structField);\n+\n+            // This is a hack so we can call postblits on const/immutable objects.\n+            ex = new AddrExp(loc, ex);\n+            ex = new CastExp(loc, ex, structField.type.mutableOf().pointerTo());\n+            ex = new PtrExp(loc, ex);\n+            if (stc & STC.safe)\n+                stc = (stc & ~STC.safe) | STC.trusted;\n+\n+            ex = new DotVarExp(loc, ex, sdv.postblit, false);\n+            ex = new CallExp(loc, ex);\n+        }\n+        else\n+        {\n+            // _ArrayPostblit((cast(S*)this.v.ptr)[0 .. n])\n+\n+            const length = tv.numberOfElems(loc);\n+            if (length == 0)\n+                continue;\n+\n+            ex = new ThisExp(loc);\n+            ex = new DotVarExp(loc, ex, structField);\n+\n+            // This is a hack so we can call postblits on const/immutable objects.\n+            ex = new DotIdExp(loc, ex, Id.ptr);\n+            ex = new CastExp(loc, ex, sdv.type.pointerTo());\n+            if (stc & STC.safe)\n+                stc = (stc & ~STC.safe) | STC.trusted;\n+\n+            auto se = new SliceExp(loc, ex, new IntegerExp(loc, 0, Type.tsize_t),\n+                                            new IntegerExp(loc, length, Type.tsize_t));\n+            // Prevent redundant bounds check\n+            se.upperIsInBounds = true;\n+            se.lowerIsLessThanUpper = true;\n+            ex = new CallExp(loc, new IdentifierExp(loc, Id.__ArrayPostblit), se);\n+        }\n+        postblitCalls.push(new ExpStatement(loc, ex)); // combine in forward order\n+\n+        /* https://issues.dlang.org/show_bug.cgi?id=10972\n+         * When subsequent field postblit calls fail,\n+         * this field should be destructed for Exception Safety.\n+         */\n+        if (sdv.dtor)\n+        {\n+            sdv.dtor.functionSemantic();\n+\n+            // keep a list of fields that need to be destroyed in case\n+            // of a future postblit failure\n+            fieldsToDestroy ~= structField;\n+        }\n+    }\n+\n+    void checkShared()\n+    {\n+        if (sd.type.isShared())\n+            stc |= STC.shared_;\n+    }\n+\n+    // Build our own \"postblit\" which executes a, but only if needed.\n+    if (postblitCalls.dim || (stc & STC.disable))\n+    {\n+        //printf(\"Building __fieldPostBlit()\\n\");\n+        checkShared();\n+        auto dd = new PostBlitDeclaration(declLoc, Loc.initial, stc, Id.__fieldPostblit);\n+        dd.generated = true;\n+        dd.storage_class |= STC.inference | STC.scope_;\n+        dd.fbody = (stc & STC.disable) ? null : new CompoundStatement(loc, postblitCalls);\n+        sd.postblits.shift(dd);\n+        sd.members.push(dd);\n+        dd.dsymbolSemantic(sc);\n+    }\n+\n+    // create __xpostblit, which is the generated postblit\n+    FuncDeclaration xpostblit = null;\n+    switch (sd.postblits.dim)\n+    {\n+    case 0:\n+        break;\n+\n+    case 1:\n+        xpostblit = sd.postblits[0];\n+        break;\n+\n+    default:\n+        Expression e = null;\n+        stc = STC.safe | STC.nothrow_ | STC.pure_ | STC.nogc;\n+        foreach (fd; sd.postblits)\n+        {\n+            stc = mergeFuncAttrs(stc, fd);\n+            if (stc & STC.disable)\n+            {\n+                e = null;\n+                break;\n+            }\n+            Expression ex = new ThisExp(loc);\n+            ex = new DotVarExp(loc, ex, fd, false);\n+            ex = new CallExp(loc, ex);\n+            e = Expression.combine(e, ex);\n+        }\n+\n+        checkShared();\n+        auto dd = new PostBlitDeclaration(declLoc, Loc.initial, stc, Id.__aggrPostblit);\n+        dd.generated = true;\n+        dd.storage_class |= STC.inference;\n+        dd.fbody = new ExpStatement(loc, e);\n+        sd.members.push(dd);\n+        dd.dsymbolSemantic(sc);\n+        xpostblit = dd;\n+        break;\n+    }\n+\n+    // Add an __xpostblit alias to make the inclusive postblit accessible\n+    if (xpostblit)\n+    {\n+        auto _alias = new AliasDeclaration(Loc.initial, Id.__xpostblit, xpostblit);\n+        _alias.dsymbolSemantic(sc);\n+        sd.members.push(_alias);\n+        _alias.addMember(sc, sd); // add to symbol table\n+    }\n+\n+    if (sd.hasCopyCtor)\n+    {\n+        // we have user defined postblit, so we prioritize it\n+        if (hasUserDefinedPosblit)\n+        {\n+            sd.hasCopyCtor = false;\n+            return xpostblit;\n+        }\n+        // we have fields with postblits, so print deprecations\n+        if (xpostblit && !xpostblit.isDisabled())\n+        {\n+            deprecation(sd.loc, \"`struct %s` implicitly-generated postblit hides copy constructor.\", sd.toChars);\n+            deprecationSupplemental(sd.loc, \"The field postblit will have priority over the copy constructor.\");\n+            deprecationSupplemental(sd.loc, \"To change this, the postblit should be disabled for `struct %s`\", sd.toChars());\n+            sd.hasCopyCtor = false;\n+        }\n+        else\n+            xpostblit = null;\n+    }\n+\n+    return xpostblit;\n+}\n+\n+/**\n+ * Generates a copy constructor declaration with the specified storage\n+ * class for the parameter and the function.\n+ *\n+ * Params:\n+ *  sd = the `struct` that contains the copy constructor\n+ *  paramStc = the storage class of the copy constructor parameter\n+ *  funcStc = the storage class for the copy constructor declaration\n+ *\n+ * Returns:\n+ *  The copy constructor declaration for struct `sd`.\n+ */\n+private CtorDeclaration generateCopyCtorDeclaration(StructDeclaration sd, const StorageClass paramStc, const StorageClass funcStc)\n+{\n+    auto fparams = new Parameters();\n+    auto structType = sd.type;\n+    fparams.push(new Parameter(paramStc | STC.ref_ | STC.return_ | STC.scope_, structType, Id.p, null, null));\n+    ParameterList pList = ParameterList(fparams);\n+    auto tf = new TypeFunction(pList, structType, LINK.d, STC.ref_);\n+    auto ccd = new CtorDeclaration(sd.loc, Loc.initial, STC.ref_, tf, true);\n+    ccd.storage_class |= funcStc;\n+    ccd.storage_class |= STC.inference;\n+    ccd.generated = true;\n+    return ccd;\n+}\n+\n+/**\n+ * Generates a trivial copy constructor body that simply does memberwise\n+ * initialization:\n+ *\n+ *    this.field1 = rhs.field1;\n+ *    this.field2 = rhs.field2;\n+ *    ...\n+ *\n+ * Params:\n+ *  sd = the `struct` declaration that contains the copy constructor\n+ *\n+ * Returns:\n+ *  A `CompoundStatement` containing the body of the copy constructor.\n+ */\n+private Statement generateCopyCtorBody(StructDeclaration sd)\n+{\n+    Loc loc;\n+    Expression e;\n+    foreach (v; sd.fields)\n+    {\n+        auto ec = new AssignExp(loc,\n+            new DotVarExp(loc, new ThisExp(loc), v),\n+            new DotVarExp(loc, new IdentifierExp(loc, Id.p), v));\n+        e = Expression.combine(e, ec);\n+        //printf(\"e.toChars = %s\\n\", e.toChars());\n+    }\n+    Statement s1 = new ExpStatement(loc, e);\n+    return new CompoundStatement(loc, s1);\n+}\n+\n+/**\n+ * Determine if a copy constructor is needed for struct sd,\n+ * if the following conditions are met:\n+ *\n+ * 1. sd does not define a copy constructor\n+ * 2. at least one field of sd defines a copy constructor\n+ *\n+ * Params:\n+ *  sd = the `struct` for which the copy constructor is generated\n+ *  hasCpCtor = set to true if a copy constructor is already present\n+ *\n+ * Returns:\n+ *  `true` if one needs to be generated\n+ *  `false` otherwise\n+ */\n+private bool needCopyCtor(StructDeclaration sd, out bool hasCpCtor)\n+{\n+    if (global.errors)\n+        return false;\n+\n+    auto ctor = sd.search(sd.loc, Id.ctor);\n+    if (ctor)\n+    {\n+        if (ctor.isOverloadSet())\n+            return false;\n+        if (auto td = ctor.isTemplateDeclaration())\n+            ctor = td.funcroot;\n+    }\n+\n+    CtorDeclaration cpCtor;\n+    CtorDeclaration rvalueCtor;\n+\n+    if (!ctor)\n+        goto LcheckFields;\n+\n+    overloadApply(ctor, (Dsymbol s)\n+    {\n+        if (s.isTemplateDeclaration())\n+            return 0;\n+        auto ctorDecl = s.isCtorDeclaration();\n+        assert(ctorDecl);\n+        if (ctorDecl.isCpCtor)\n+        {\n+            if (!cpCtor)\n+                cpCtor = ctorDecl;\n+            return 0;\n+        }\n+\n+        auto tf = ctorDecl.type.toTypeFunction();\n+        const dim = tf.parameterList.length;\n+        if (dim == 1)\n+        {\n+            auto param = tf.parameterList[0];\n+            if (param.type.mutableOf().unSharedOf() == sd.type.mutableOf().unSharedOf())\n+            {\n+                rvalueCtor = ctorDecl;\n+            }\n+        }\n+        return 0;\n+    });\n+\n+    if (cpCtor)\n+    {\n+        if (rvalueCtor)\n+        {\n+            .error(sd.loc, \"`struct %s` may not define both a rvalue constructor and a copy constructor\", sd.toChars());\n+            errorSupplemental(rvalueCtor.loc,\"rvalue constructor defined here\");\n+            errorSupplemental(cpCtor.loc, \"copy constructor defined here\");\n+        }\n+        hasCpCtor = true;\n+        return false;\n+    }\n+\n+LcheckFields:\n+    VarDeclaration fieldWithCpCtor;\n+    // see if any struct members define a copy constructor\n+    foreach (v; sd.fields)\n+    {\n+        if (v.storage_class & STC.ref_)\n+            continue;\n+        if (v.overlapped)\n+            continue;\n+\n+        auto ts = v.type.baseElemOf().isTypeStruct();\n+        if (!ts)\n+            continue;\n+        if (ts.sym.hasCopyCtor)\n+        {\n+            fieldWithCpCtor = v;\n+            break;\n+        }\n+    }\n+\n+    if (fieldWithCpCtor && rvalueCtor)\n+    {\n+        .error(sd.loc, \"`struct %s` may not define a rvalue constructor and have fields with copy constructors\", sd.toChars());\n+        errorSupplemental(rvalueCtor.loc,\"rvalue constructor defined here\");\n+        errorSupplemental(fieldWithCpCtor.loc, \"field with copy constructor defined here\");\n+        return false;\n+    }\n+    else if (!fieldWithCpCtor)\n+        return false;\n+    return true;\n+}\n+\n+/**\n+ * Generates a copy constructor if needCopyCtor() returns true.\n+ * The generated copy constructor will be of the form:\n+ *   this(ref return scope inout(S) rhs) inout\n+ *   {\n+ *      this.field1 = rhs.field1;\n+ *      this.field2 = rhs.field2;\n+ *      ...\n+ *   }\n+ *\n+ * Params:\n+ *  sd = the `struct` for which the copy constructor is generated\n+ *  sc = the scope where the copy constructor is generated\n+ *\n+ * Returns:\n+ *  `true` if `struct` sd defines a copy constructor (explicitly or generated),\n+ *  `false` otherwise.\n+ */\n+bool buildCopyCtor(StructDeclaration sd, Scope* sc)\n+{\n+    bool hasCpCtor;\n+    if (!needCopyCtor(sd, hasCpCtor))\n+        return hasCpCtor;\n+\n+    //printf(\"generating copy constructor for %s\\n\", sd.toChars());\n+    const MOD paramMod = MODFlags.wild;\n+    const MOD funcMod = MODFlags.wild;\n+    auto ccd = generateCopyCtorDeclaration(sd, ModToStc(paramMod), ModToStc(funcMod));\n+    auto copyCtorBody = generateCopyCtorBody(sd);\n+    ccd.fbody = copyCtorBody;\n+    sd.members.push(ccd);\n+    ccd.addMember(sc, sd);\n+    const errors = global.startGagging();\n+    Scope* sc2 = sc.push();\n+    sc2.stc = 0;\n+    sc2.linkage = LINK.d;\n+    ccd.dsymbolSemantic(sc2);\n+    ccd.semantic2(sc2);\n+    ccd.semantic3(sc2);\n+    //printf(\"ccd semantic: %s\\n\", ccd.type.toChars());\n+    sc2.pop();\n+    if (global.endGagging(errors) || sd.isUnionDeclaration())\n+    {\n+        ccd.storage_class |= STC.disable;\n+        ccd.fbody = null;\n+    }\n+    return true;\n+}\n+\n+"}, {"sha": "28f9ba6fdc465b3e88a83b098b9ab5a539241c42", "filename": "gcc/d/dmd/compiler.d", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fcompiler.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fcompiler.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcompiler.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -0,0 +1,57 @@\n+/**\n+ * Describes a back-end compiler and implements compiler-specific actions.\n+ *\n+ * Copyright:   Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n+ * Authors:     $(LINK2 http://www.digitalmars.com, Walter Bright)\n+ * License:     $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+ * Source:      $(LINK2 https://github.com/dlang/dmd/blob/master/src/dmd/compiler.d, _compiler.d)\n+ * Documentation:  https://dlang.org/phobos/dmd_compiler.html\n+ * Coverage:    https://codecov.io/gh/dlang/dmd/src/master/src/dmd/compiler.d\n+ */\n+\n+module dmd.compiler;\n+\n+import dmd.arraytypes;\n+import dmd.dmodule;\n+import dmd.dscope;\n+import dmd.expression;\n+import dmd.mtype;\n+import dmd.root.array;\n+\n+extern (C++) __gshared\n+{\n+    bool includeImports = false;\n+    // array of module patterns used to include/exclude imported modules\n+    Array!(const(char)*) includeModulePatterns;\n+    Modules compiledImports;\n+}\n+\n+\n+/**\n+ * A data structure that describes a back-end compiler and implements\n+ * compiler-specific actions.\n+ */\n+extern (C++) struct Compiler\n+{\n+    /******************************\n+     * Encode the given expression, which is assumed to be an rvalue literal\n+     * as another type for use in CTFE.\n+     * This corresponds roughly to the idiom *(Type *)&e.\n+     */\n+    extern (C++) static Expression paintAsType(UnionExp* pue, Expression e, Type type);\n+\n+    /******************************\n+     * For the given module, perform any post parsing analysis.\n+     * Certain compiler backends (ie: GDC) have special placeholder\n+     * modules whose source are empty, but code gets injected\n+     * immediately after loading.\n+     */\n+    extern (C++) static void onParseModule(Module m);\n+\n+    /**\n+     * A callback function that is called once an imported module is\n+     * parsed. If the callback returns true, then it tells the\n+     * frontend that the driver intends on compiling the import.\n+     */\n+    extern (C++) static bool onImport(Module m);\n+}"}, {"sha": "27e87b692a87ee213346ac12401818c9d3337276", "filename": "gcc/d/dmd/compiler.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fcompiler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fcompiler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcompiler.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -22,11 +22,6 @@ class Type;\n struct Scope;\n struct UnionExp;\n \n-// DMD-generated module `__entrypoint` where the C main resides\n-extern Module *entrypoint;\n-// Module in which the D main is\n-extern Module *rootHasMain;\n-\n extern bool includeImports;\n // array of module patterns used to include/exclude imported modules\n extern Array<const char*> includeModulePatterns;\n@@ -37,7 +32,6 @@ struct Compiler\n     // CTFE support for cross-compilation.\n     static Expression *paintAsType(UnionExp *, Expression *, Type *);\n     // Backend\n-    static void genCmain(Scope *);\n     static bool onImport(Module *);\n     static void onParseModule(Module *);\n };"}, {"sha": "84bf5e9763a53008ff1f8b663f2205e2c80ec611", "filename": "gcc/d/dmd/complex.d", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fcomplex.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fcomplex.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcomplex.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -0,0 +1,112 @@\n+/**\n+ * Implements a complex number type.\n+ *\n+ * Copyright:   Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n+ * Authors:     $(LINK2 http://www.digitalmars.com, Walter Bright)\n+ * License:     $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+ * Source:      $(LINK2 https://github.com/dlang/dmd/blob/master/src/dmd/complex.d, _complex.d)\n+ * Documentation:  https://dlang.org/phobos/dmd_complex.html\n+ * Coverage:    https://codecov.io/gh/dlang/dmd/src/master/src/dmd/complex.d\n+ */\n+\n+module dmd.complex;\n+\n+import dmd.root.ctfloat;\n+\n+extern (C++) struct complex_t\n+{\n+    real_t re;\n+    real_t im;\n+\n+    this() @disable;\n+\n+    this(real_t re)\n+    {\n+        this(re, CTFloat.zero);\n+    }\n+\n+    this(real_t re, real_t im)\n+    {\n+        this.re = re;\n+        this.im = im;\n+    }\n+\n+    extern (D) complex_t opBinary(string op)(complex_t y)\n+        if (op == \"+\")\n+    {\n+        return complex_t(re + y.re, im + y.im);\n+    }\n+\n+    extern (D) complex_t opBinary(string op)(complex_t y)\n+        if (op == \"-\")\n+    {\n+        return complex_t(re - y.re, im - y.im);\n+    }\n+\n+    extern (D) complex_t opUnary(string op)()\n+        if (op == \"-\")\n+    {\n+        return complex_t(-re, -im);\n+    }\n+\n+    extern (D) complex_t opBinary(string op)(complex_t y)\n+        if (op == \"*\")\n+    {\n+        return complex_t(re * y.re - im * y.im, im * y.re + re * y.im);\n+    }\n+\n+    extern (D) complex_t opBinaryRight(string op)(real_t x)\n+        if (op == \"*\")\n+    {\n+        return complex_t(x) * this;\n+    }\n+\n+    extern (D) complex_t opBinary(string op)(real_t y)\n+        if (op == \"*\")\n+    {\n+        return this * complex_t(y);\n+    }\n+\n+    extern (D) complex_t opBinary(string op)(real_t y)\n+        if (op == \"/\")\n+    {\n+        return this / complex_t(y);\n+    }\n+\n+    extern (D) complex_t opBinary(string op)(complex_t y)\n+        if (op == \"/\")\n+    {\n+        if (CTFloat.fabs(y.re) < CTFloat.fabs(y.im))\n+        {\n+            const r = y.re / y.im;\n+            const den = y.im + r * y.re;\n+            return complex_t((re * r + im) / den, (im * r - re) / den);\n+        }\n+        else\n+        {\n+            const r = y.im / y.re;\n+            const den = y.re + r * y.im;\n+            return complex_t((re + r * im) / den, (im - r * re) / den);\n+        }\n+    }\n+\n+    extern (D) bool opCast(T : bool)() const\n+    {\n+        return re || im;\n+    }\n+\n+    int opEquals(complex_t y) const\n+    {\n+        return re == y.re && im == y.im;\n+    }\n+}\n+\n+extern (C++) real_t creall(complex_t x)\n+{\n+    return x.re;\n+}\n+\n+extern (C++) real_t cimagl(complex_t x)\n+{\n+    return x.im;\n+}"}, {"sha": "335917135c2560355522a3213500610bebe762c0", "filename": "gcc/d/dmd/complex_t.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fcomplex_t.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fcomplex_t.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcomplex_t.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -20,7 +20,7 @@ struct complex_t\n     real_t re;\n     real_t im;\n \n-    complex_t(real_t re) : re(re), im(ldouble(0)) {}\n+    complex_t(real_t re) : re(re), im(CTFloat::zero) {}\n     complex_t(real_t re, real_t im) : re(re), im(im) {}\n \n     complex_t operator + (complex_t y) { return complex_t(re + y.re, im + y.im); }\n@@ -52,7 +52,7 @@ struct complex_t\n     int operator != (complex_t y) { return re != y.re || im != y.im; }\n \n private:\n-    complex_t() : re(ldouble(0)), im(ldouble(0)) {}\n+    complex_t() : re(CTFloat::zero), im(CTFloat::zero) {}\n };\n \n inline complex_t operator * (real_t x, complex_t y) { return complex_t(x) * y; }"}, {"sha": "6c7dc9eb1a34fc9a137f440507f0fa8606dcbea8", "filename": "gcc/d/dmd/cond.c", "status": "removed", "additions": 0, "deletions": 738, "changes": 738, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fcond.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fcond.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcond.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49", "patch": "@@ -1,738 +0,0 @@\n-\n-/* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n- * written by Walter Bright\n- * http://www.digitalmars.com\n- * Distributed under the Boost Software License, Version 1.0.\n- * http://www.boost.org/LICENSE_1_0.txt\n- * https://github.com/D-Programming-Language/dmd/blob/master/src/cond.c\n- */\n-\n-#include \"root/dsystem.h\"               // strcmp()\n-\n-#include \"mars.h\"\n-#include \"id.h\"\n-#include \"init.h\"\n-#include \"aggregate.h\"\n-#include \"declaration.h\"\n-#include \"identifier.h\"\n-#include \"expression.h\"\n-#include \"cond.h\"\n-#include \"module.h\"\n-#include \"template.h\"\n-#include \"mtype.h\"\n-#include \"scope.h\"\n-#include \"statement.h\"\n-#include \"arraytypes.h\"\n-#include \"tokens.h\"\n-\n-bool evalStaticCondition(Scope *sc, Expression *exp, Expression *e, bool &errors);\n-\n-int findCondition(Identifiers *ids, Identifier *ident)\n-{\n-    if (ids)\n-    {\n-        for (size_t i = 0; i < ids->length; i++)\n-        {\n-            Identifier *id = (*ids)[i];\n-\n-            if (id == ident)\n-                return true;\n-        }\n-    }\n-\n-    return false;\n-}\n-\n-/* ============================================================ */\n-\n-Condition::Condition(Loc loc)\n-{\n-    this->loc = loc;\n-    inc = 0;\n-}\n-\n-/* ============================================================ */\n-\n-StaticForeach::StaticForeach(Loc loc, ForeachStatement *aggrfe, ForeachRangeStatement *rangefe)\n-{\n-    assert(!!aggrfe ^ !!rangefe);\n-    this->loc = loc;\n-    this->aggrfe = aggrfe;\n-    this->rangefe = rangefe;\n-    this->needExpansion = false;\n-}\n-\n-StaticForeach *StaticForeach::syntaxCopy()\n-{\n-    return new StaticForeach(\n-        loc,\n-        aggrfe ? (ForeachStatement *)aggrfe->syntaxCopy() : NULL,\n-        rangefe ? (ForeachRangeStatement *)rangefe->syntaxCopy() : NULL\n-    );\n-}\n-\n-/*****************************************\n- * Turn an aggregate which is an array into an expression tuple\n- * of its elements. I.e., lower\n- *     static foreach (x; [1, 2, 3, 4]) { ... }\n- * to\n- *     static foreach (x; AliasSeq!(1, 2, 3, 4)) { ... }\n- */\n-\n-static void lowerArrayAggregate(StaticForeach *sfe, Scope *sc)\n-{\n-    Expression *aggr = sfe->aggrfe->aggr;\n-    Expression *el = new ArrayLengthExp(aggr->loc, aggr);\n-    sc = sc->startCTFE();\n-    el = expressionSemantic(el, sc);\n-    sc = sc->endCTFE();\n-    el = el->optimize(WANTvalue);\n-    el = el->ctfeInterpret();\n-    if (el->op == TOKint64)\n-    {\n-        Expressions *es;\n-        if (ArrayLiteralExp *ale = aggr->isArrayLiteralExp())\n-        {\n-            // Directly use the elements of the array for the TupleExp creation\n-            es = ale->elements;\n-        }\n-        else\n-        {\n-            size_t length = (size_t)el->toInteger();\n-            es = new Expressions();\n-            es->setDim(length);\n-            for (size_t i = 0; i < length; i++)\n-            {\n-                IntegerExp *index = new IntegerExp(sfe->loc, i, Type::tsize_t);\n-                Expression *value = new IndexExp(aggr->loc, aggr, index);\n-                (*es)[i] = value;\n-            }\n-        }\n-        sfe->aggrfe->aggr = new TupleExp(aggr->loc, es);\n-        sfe->aggrfe->aggr = expressionSemantic(sfe->aggrfe->aggr, sc);\n-        sfe->aggrfe->aggr = sfe->aggrfe->aggr->optimize(WANTvalue);\n-        sfe->aggrfe->aggr = sfe->aggrfe->aggr->ctfeInterpret();\n-    }\n-    else\n-    {\n-        sfe->aggrfe->aggr = new ErrorExp();\n-    }\n-}\n-\n-/*****************************************\n- * Wrap a statement into a function literal and call it.\n- *\n- * Params:\n- *     loc = The source location.\n- *     s  = The statement.\n- * Returns:\n- *     AST of the expression `(){ s; }()` with location loc.\n- */\n-\n-static Expression *wrapAndCall(Loc loc, Statement *s)\n-{\n-    TypeFunction *tf = new TypeFunction(ParameterList(), NULL, LINKdefault, 0);\n-    FuncLiteralDeclaration *fd = new FuncLiteralDeclaration(loc, loc, tf, TOKreserved, NULL);\n-    fd->fbody = s;\n-    FuncExp *fe = new FuncExp(loc, fd);\n-    Expression *ce = new CallExp(loc, fe, new Expressions());\n-    return ce;\n-}\n-\n-/*****************************************\n- * Create a `foreach` statement from `aggrefe/rangefe` with given\n- * `foreach` variables and body `s`.\n- *\n- * Params:\n- *     loc = The source location.\n- *     parameters = The foreach variables.\n- *     s = The `foreach` body.\n- * Returns:\n- *     `foreach (parameters; aggregate) s;` or\n- *     `foreach (parameters; lower .. upper) s;`\n- *     Where aggregate/lower, upper are as for the current StaticForeach.\n- */\n-\n-static Statement *createForeach(StaticForeach *sfe, Loc loc, Parameters *parameters, Statement *s)\n-{\n-    if (sfe->aggrfe)\n-    {\n-        return new ForeachStatement(loc, sfe->aggrfe->op, parameters, sfe->aggrfe->aggr->syntaxCopy(), s, loc);\n-    }\n-    else\n-    {\n-        assert(sfe->rangefe && parameters->length == 1);\n-        return new ForeachRangeStatement(loc, sfe->rangefe->op, (*parameters)[0],\n-                                         sfe->rangefe->lwr->syntaxCopy(),\n-                                         sfe->rangefe->upr->syntaxCopy(), s, loc);\n-    }\n-}\n-\n-/*****************************************\n- * For a `static foreach` with multiple loop variables, the\n- * aggregate is lowered to an array of tuples. As D does not have\n- * built-in tuples, we need a suitable tuple type. This generates\n- * a `struct` that serves as the tuple type. This type is only\n- * used during CTFE and hence its typeinfo will not go to the\n- * object file.\n- *\n- * Params:\n- *     loc = The source location.\n- *     e = The expressions we wish to store in the tuple.\n- *     sc  = The current scope.\n- * Returns:\n- *     A struct type of the form\n- *         struct Tuple\n- *         {\n- *             typeof(AliasSeq!(e)) tuple;\n- *         }\n- */\n-\n-static TypeStruct *createTupleType(Loc loc, Expressions *e)\n-{   // TODO: move to druntime?\n-    Identifier *sid = Identifier::generateId(\"Tuple\");\n-    StructDeclaration *sdecl = new StructDeclaration(loc, sid, false);\n-    sdecl->storage_class |= STCstatic;\n-    sdecl->members = new Dsymbols();\n-    Identifier *fid = Identifier::idPool(\"tuple\");\n-    Type *ty = new TypeTypeof(loc, new TupleExp(loc, e));\n-    sdecl->members->push(new VarDeclaration(loc, ty, fid, NULL));\n-    TypeStruct *r = (TypeStruct *)sdecl->type;\n-    if (global.params.useTypeInfo && Type::dtypeinfo)\n-        r->vtinfo = TypeInfoStructDeclaration::create(r); // prevent typeinfo from going to object file\n-    return r;\n-}\n-\n-/*****************************************\n- * Create the AST for an instantiation of a suitable tuple type.\n- *\n- * Params:\n- *     loc = The source location.\n- *     type = A Tuple type, created with createTupleType.\n- *     e = The expressions we wish to store in the tuple.\n- * Returns:\n- *     An AST for the expression `Tuple(e)`.\n- */\n-\n-static Expression *createTuple(Loc loc, TypeStruct *type, Expressions *e)\n-{   // TODO: move to druntime?\n-    return new CallExp(loc, new TypeExp(loc, type), e);\n-}\n-\n-/*****************************************\n- * Lower any aggregate that is not an array to an array using a\n- * regular foreach loop within CTFE.  If there are multiple\n- * `static foreach` loop variables, an array of tuples is\n- * generated. In thise case, the field `needExpansion` is set to\n- * true to indicate that the static foreach loop expansion will\n- * need to expand the tuples into multiple variables.\n- *\n- * For example, `static foreach (x; range) { ... }` is lowered to:\n- *\n- *     static foreach (x; {\n- *         typeof({\n- *             foreach (x; range) return x;\n- *         }())[] __res;\n- *         foreach (x; range) __res ~= x;\n- *         return __res;\n- *     }()) { ... }\n- *\n- * Finally, call `lowerArrayAggregate` to turn the produced\n- * array into an expression tuple.\n- *\n- * Params:\n- *     sc = The current scope.\n- */\n-\n-static void lowerNonArrayAggregate(StaticForeach *sfe, Scope *sc)\n-{\n-    size_t nvars = sfe->aggrfe ? sfe->aggrfe->parameters->length : 1;\n-    Loc aloc = sfe->aggrfe ? sfe->aggrfe->aggr->loc : sfe->rangefe->lwr->loc;\n-    // We need three sets of foreach loop variables because the\n-    // lowering contains three foreach loops.\n-    Parameters *pparams[3] = {new Parameters(), new Parameters(), new Parameters()};\n-    for (size_t i = 0; i < nvars; i++)\n-    {\n-        for (size_t j = 0; j < 3; j++)\n-        {\n-            Parameters *params = pparams[j];\n-            Parameter *p = sfe->aggrfe ? (*sfe->aggrfe->parameters)[i] : sfe->rangefe->prm;\n-            params->push(new Parameter(p->storageClass, p->type, p->ident, NULL, NULL));\n-        }\n-    }\n-    Expression *res[2];\n-    TypeStruct *tplty = NULL;\n-    if (nvars == 1) // only one `static foreach` variable, generate identifiers.\n-    {\n-        for (size_t i = 0; i < 2; i++)\n-        {\n-            res[i] = new IdentifierExp(aloc, (*pparams[i])[0]->ident);\n-        }\n-    }\n-    else // multiple `static foreach` variables, generate tuples.\n-    {\n-        for (size_t i = 0; i < 2; i++)\n-        {\n-            Expressions *e = new Expressions();\n-            for (size_t j = 0; j < pparams[0]->length; j++)\n-            {\n-                Parameter *p = (*pparams[i])[j];\n-                e->push(new IdentifierExp(aloc, p->ident));\n-            }\n-            if (!tplty)\n-            {\n-                tplty = createTupleType(aloc, e);\n-            }\n-            res[i] = createTuple(aloc, tplty, e);\n-        }\n-        sfe->needExpansion = true; // need to expand the tuples later\n-    }\n-    // generate remaining code for the new aggregate which is an\n-    // array (see documentation comment).\n-    if (sfe->rangefe)\n-    {\n-        sc = sc->startCTFE();\n-        sfe->rangefe->lwr = expressionSemantic(sfe->rangefe->lwr, sc);\n-        sfe->rangefe->lwr = resolveProperties(sc, sfe->rangefe->lwr);\n-        sfe->rangefe->upr = expressionSemantic(sfe->rangefe->upr, sc);\n-        sfe->rangefe->upr = resolveProperties(sc, sfe->rangefe->upr);\n-        sc = sc->endCTFE();\n-        sfe->rangefe->lwr = sfe->rangefe->lwr->optimize(WANTvalue);\n-        sfe->rangefe->lwr = sfe->rangefe->lwr->ctfeInterpret();\n-        sfe->rangefe->upr = sfe->rangefe->upr->optimize(WANTvalue);\n-        sfe->rangefe->upr = sfe->rangefe->upr->ctfeInterpret();\n-    }\n-    Statements *s1 = new Statements();\n-    Statements *sfebody = new Statements();\n-    if (tplty) sfebody->push(new ExpStatement(sfe->loc, tplty->sym));\n-    sfebody->push(new ReturnStatement(aloc, res[0]));\n-    s1->push(createForeach(sfe, aloc, pparams[0], new CompoundStatement(aloc, sfebody)));\n-    s1->push(new ExpStatement(aloc, new AssertExp(aloc, new IntegerExp(aloc, 0, Type::tint32))));\n-    Type *ety = new TypeTypeof(aloc, wrapAndCall(aloc, new CompoundStatement(aloc, s1)));\n-    Type *aty = ety->arrayOf();\n-    Identifier *idres = Identifier::generateId(\"__res\");\n-    VarDeclaration *vard = new VarDeclaration(aloc, aty, idres, NULL);\n-    Statements *s2 = new Statements();\n-\n-    // Run 'typeof' gagged to avoid duplicate errors and if it fails just create\n-    // an empty foreach to expose them.\n-    unsigned olderrors = global.startGagging();\n-    ety = typeSemantic(ety, aloc, sc);\n-    if (global.endGagging(olderrors))\n-        s2->push(createForeach(sfe, aloc, pparams[1], NULL));\n-    else\n-    {\n-        s2->push(new ExpStatement(aloc, vard));\n-        Expression *catass = new CatAssignExp(aloc, new IdentifierExp(aloc, idres), res[1]);\n-        s2->push(createForeach(sfe, aloc, pparams[1], new ExpStatement(aloc, catass)));\n-        s2->push(new ReturnStatement(aloc, new IdentifierExp(aloc, idres)));\n-    }\n-\n-    Expression *aggr;\n-    Type *indexty;\n-\n-    if (sfe->rangefe && (indexty = ety)->isintegral())\n-    {\n-        sfe->rangefe->lwr->type = indexty;\n-        sfe->rangefe->upr->type = indexty;\n-        IntRange lwrRange = getIntRange(sfe->rangefe->lwr);\n-        IntRange uprRange = getIntRange(sfe->rangefe->upr);\n-\n-        const dinteger_t lwr = sfe->rangefe->lwr->toInteger();\n-        dinteger_t upr = sfe->rangefe->upr->toInteger();\n-        size_t length = 0;\n-\n-        if (lwrRange.imin <= uprRange.imax)\n-            length = (size_t)(upr - lwr);\n-\n-        Expressions *exps = new Expressions();\n-        exps->setDim(length);\n-\n-        if (sfe->rangefe->op == TOKforeach)\n-        {\n-            for (size_t i = 0; i < length; i++)\n-                (*exps)[i] = new IntegerExp(aloc, lwr + i, indexty);\n-        }\n-        else\n-        {\n-            --upr;\n-            for (size_t i = 0; i < length; i++)\n-                (*exps)[i] = new IntegerExp(aloc, upr - i, indexty);\n-        }\n-        aggr = new ArrayLiteralExp(aloc, indexty->arrayOf(), exps);\n-    }\n-    else\n-    {\n-        aggr = wrapAndCall(aloc, new CompoundStatement(aloc, s2));\n-        sc = sc->startCTFE();\n-        aggr = expressionSemantic(aggr, sc);\n-        aggr = resolveProperties(sc, aggr);\n-        sc = sc->endCTFE();\n-        aggr = aggr->optimize(WANTvalue);\n-        aggr = aggr->ctfeInterpret();\n-    }\n-\n-    assert(!!sfe->aggrfe ^ !!sfe->rangefe);\n-    sfe->aggrfe = new ForeachStatement(sfe->loc, TOKforeach, pparams[2], aggr,\n-                                  sfe->aggrfe ? sfe->aggrfe->_body : sfe->rangefe->_body,\n-                                  sfe->aggrfe ? sfe->aggrfe->endloc : sfe->rangefe->endloc);\n-    sfe->rangefe = NULL;\n-    lowerArrayAggregate(sfe, sc); // finally, turn generated array into expression tuple\n-}\n-\n-/*****************************************\n- * Perform `static foreach` lowerings that are necessary in order\n- * to finally expand the `static foreach` using\n- * `ddmd.statementsem.makeTupleForeach`.\n- */\n-\n-void staticForeachPrepare(StaticForeach *sfe, Scope *sc)\n-{\n-    assert(sc);\n-    if (sfe->aggrfe)\n-    {\n-        sc = sc->startCTFE();\n-        sfe->aggrfe->aggr = expressionSemantic(sfe->aggrfe->aggr, sc);\n-        sc = sc->endCTFE();\n-        sfe->aggrfe->aggr = sfe->aggrfe->aggr->optimize(WANTvalue);\n-    }\n-\n-    if (sfe->aggrfe && sfe->aggrfe->aggr->type->toBasetype()->ty == Terror)\n-    {\n-        return;\n-    }\n-\n-    if (!staticForeachReady(sfe))\n-    {\n-        if (sfe->aggrfe && sfe->aggrfe->aggr->type->toBasetype()->ty == Tarray)\n-        {\n-            lowerArrayAggregate(sfe, sc);\n-        }\n-        else\n-        {\n-            lowerNonArrayAggregate(sfe, sc);\n-        }\n-    }\n-}\n-\n-/*****************************************\n- * Returns:\n- *     `true` iff ready to call `ddmd.statementsem.makeTupleForeach`.\n- */\n-\n-bool staticForeachReady(StaticForeach *sfe)\n-{\n-    return sfe->aggrfe && sfe->aggrfe->aggr && sfe->aggrfe->aggr->type &&\n-        sfe->aggrfe->aggr->type->toBasetype()->ty == Ttuple;\n-}\n-\n-/* ============================================================ */\n-\n-DVCondition::DVCondition(Module *mod, unsigned level, Identifier *ident)\n-        : Condition(Loc())\n-{\n-    this->mod = mod;\n-    this->level = level;\n-    this->ident = ident;\n-}\n-\n-Condition *DVCondition::syntaxCopy()\n-{\n-    return this;        // don't need to copy\n-}\n-\n-/* ============================================================ */\n-\n-void DebugCondition::addGlobalIdent(const char *ident)\n-{\n-    if (!global.debugids)\n-        global.debugids = new Identifiers();\n-    global.debugids->push(Identifier::idPool(ident));\n-}\n-\n-\n-DebugCondition::DebugCondition(Module *mod, unsigned level, Identifier *ident)\n-    : DVCondition(mod, level, ident)\n-{\n-}\n-\n-// Helper for printing dependency information\n-void printDepsConditional(Scope *sc, DVCondition* condition, const char* depType)\n-{\n-    if (!global.params.moduleDeps || global.params.moduleDepsFile.length)\n-        return;\n-    OutBuffer *ob = global.params.moduleDeps;\n-    Module* imod = sc ? sc->instantiatingModule() : condition->mod;\n-    if (!imod)\n-        return;\n-    ob->writestring(depType);\n-    ob->writestring(imod->toPrettyChars());\n-    ob->writestring(\" (\");\n-    escapePath(ob, imod->srcfile->toChars());\n-    ob->writestring(\") : \");\n-    if (condition->ident)\n-        ob->printf(\"%s\\n\", condition->ident->toChars());\n-    else\n-        ob->printf(\"%d\\n\", condition->level);\n-}\n-\n-\n-int DebugCondition::include(Scope *sc)\n-{\n-    //printf(\"DebugCondition::include() level = %d, debuglevel = %d\\n\", level, global.params.debuglevel);\n-    if (inc == 0)\n-    {\n-        inc = 2;\n-        bool definedInModule = false;\n-        if (ident)\n-        {\n-            if (findCondition(mod->debugids, ident))\n-            {\n-                inc = 1;\n-                definedInModule = true;\n-            }\n-            else if (findCondition(global.debugids, ident))\n-                inc = 1;\n-            else\n-            {   if (!mod->debugidsNot)\n-                    mod->debugidsNot = new Identifiers();\n-                mod->debugidsNot->push(ident);\n-            }\n-        }\n-        else if (level <= global.params.debuglevel || level <= mod->debuglevel)\n-            inc = 1;\n-        if (!definedInModule)\n-            printDepsConditional(sc, this, \"depsDebug \");\n-    }\n-    return (inc == 1);\n-}\n-\n-/* ============================================================ */\n-\n-static bool isReserved(const char *ident)\n-{\n-    static const char* reserved[] =\n-    {\n-        \"DigitalMars\",\n-        \"GNU\",\n-        \"LDC\",\n-        \"SDC\",\n-        \"Windows\",\n-        \"Win32\",\n-        \"Win64\",\n-        \"linux\",\n-        \"OSX\",\n-        \"FreeBSD\",\n-        \"OpenBSD\",\n-        \"NetBSD\",\n-        \"DragonFlyBSD\",\n-        \"BSD\",\n-        \"Solaris\",\n-        \"Posix\",\n-        \"AIX\",\n-        \"Haiku\",\n-        \"SkyOS\",\n-        \"SysV3\",\n-        \"SysV4\",\n-        \"Hurd\",\n-        \"Android\",\n-        \"PlayStation\",\n-        \"PlayStation4\",\n-        \"Cygwin\",\n-        \"MinGW\",\n-        \"FreeStanding\",\n-        \"X86\",\n-        \"X86_64\",\n-        \"ARM\",\n-        \"ARM_Thumb\",\n-        \"ARM_SoftFloat\",\n-        \"ARM_SoftFP\",\n-        \"ARM_HardFloat\",\n-        \"AArch64\",\n-        \"Epiphany\",\n-        \"PPC\",\n-        \"PPC_SoftFloat\",\n-        \"PPC_HardFloat\",\n-        \"PPC64\",\n-        \"IA64\",\n-        \"MIPS32\",\n-        \"MIPS64\",\n-        \"MIPS_O32\",\n-        \"MIPS_N32\",\n-        \"MIPS_O64\",\n-        \"MIPS_N64\",\n-        \"MIPS_EABI\",\n-        \"MIPS_SoftFloat\",\n-        \"MIPS_HardFloat\",\n-        \"MSP430\",\n-        \"NVPTX\",\n-        \"NVPTX64\",\n-        \"RISCV32\",\n-        \"RISCV64\",\n-        \"SPARC\",\n-        \"SPARC_V8Plus\",\n-        \"SPARC_SoftFloat\",\n-        \"SPARC_HardFloat\",\n-        \"SPARC64\",\n-        \"S390\",\n-        \"S390X\",\n-        \"HPPA\",\n-        \"HPPA64\",\n-        \"SH\",\n-        \"Alpha\",\n-        \"Alpha_SoftFloat\",\n-        \"Alpha_HardFloat\",\n-        \"LittleEndian\",\n-        \"BigEndian\",\n-        \"ELFv1\",\n-        \"ELFv2\",\n-        \"CRuntime_Digitalmars\",\n-        \"CRuntime_Glibc\",\n-        \"CRuntime_Microsoft\",\n-        \"CRuntime_Musl\",\n-        \"CRuntime_UClibc\",\n-        \"CppRuntime_Clang\",\n-        \"CppRuntime_DigitalMars\",\n-        \"CppRuntime_Gcc\",\n-        \"CppRuntime_Microsoft\",\n-        \"CppRuntime_Sun\",\n-        \"D_Coverage\",\n-        \"D_Ddoc\",\n-        \"D_InlineAsm_X86\",\n-        \"D_InlineAsm_X86_64\",\n-        \"D_LP64\",\n-        \"D_X32\",\n-        \"D_HardFloat\",\n-        \"D_SoftFloat\",\n-        \"D_PIC\",\n-        \"D_SIMD\",\n-        \"D_Version2\",\n-        \"D_NoBoundsChecks\",\n-        \"unittest\",\n-        \"assert\",\n-        \"all\",\n-        \"none\",\n-        NULL\n-    };\n-\n-    for (unsigned i = 0; reserved[i]; i++)\n-    {\n-        if (strcmp(ident, reserved[i]) == 0)\n-            return true;\n-    }\n-\n-    if (ident[0] == 'D' && ident[1] == '_')\n-        return true;\n-    return false;\n-}\n-\n-void checkReserved(Loc loc, const char *ident)\n-{\n-    if (isReserved(ident))\n-        error(loc, \"version identifier `%s` is reserved and cannot be set\", ident);\n-}\n-\n-void VersionCondition::addGlobalIdent(const char *ident)\n-{\n-    checkReserved(Loc(), ident);\n-    addPredefinedGlobalIdent(ident);\n-}\n-\n-void VersionCondition::addPredefinedGlobalIdent(const char *ident)\n-{\n-    if (!global.versionids)\n-        global.versionids = new Identifiers();\n-    global.versionids->push(Identifier::idPool(ident));\n-}\n-\n-\n-VersionCondition::VersionCondition(Module *mod, unsigned level, Identifier *ident)\n-    : DVCondition(mod, level, ident)\n-{\n-}\n-\n-int VersionCondition::include(Scope *sc)\n-{\n-    //printf(\"VersionCondition::include() level = %d, versionlevel = %d\\n\", level, global.params.versionlevel);\n-    //if (ident) printf(\"\\tident = '%s'\\n\", ident->toChars());\n-    if (inc == 0)\n-    {\n-        inc = 2;\n-        bool definedInModule=false;\n-        if (ident)\n-        {\n-            if (findCondition(mod->versionids, ident))\n-            {\n-                inc = 1;\n-                definedInModule = true;\n-            }\n-            else if (findCondition(global.versionids, ident))\n-                inc = 1;\n-            else\n-            {\n-                if (!mod->versionidsNot)\n-                    mod->versionidsNot = new Identifiers();\n-                mod->versionidsNot->push(ident);\n-            }\n-        }\n-        else if (level <= global.params.versionlevel || level <= mod->versionlevel)\n-            inc = 1;\n-        if (!definedInModule && (!ident || (!isReserved(ident->toChars()) && ident != Id::_unittest && ident != Id::_assert)))\n-            printDepsConditional(sc, this, \"depsVersion \");\n-    }\n-    return (inc == 1);\n-}\n-\n-/**************************** StaticIfCondition *******************************/\n-\n-StaticIfCondition::StaticIfCondition(Loc loc, Expression *exp)\n-    : Condition(loc)\n-{\n-    this->exp = exp;\n-}\n-\n-Condition *StaticIfCondition::syntaxCopy()\n-{\n-    return new StaticIfCondition(loc, exp->syntaxCopy());\n-}\n-\n-int StaticIfCondition::include(Scope *sc)\n-{\n-    if (inc == 0)\n-    {\n-        if (!sc)\n-        {\n-            error(loc, \"static if conditional cannot be at global scope\");\n-            inc = 2;\n-            return 0;\n-        }\n-\n-        sc = sc->push(sc->scopesym);\n-\n-        bool errors = false;\n-\n-        if (!exp)\n-            goto Lerror;\n-\n-        bool result = evalStaticCondition(sc, exp, exp, errors);\n-        sc->pop();\n-\n-        // Prevent repeated condition evaluation.\n-        // See: fail_compilation/fail7815.d\n-        if (inc != 0)\n-            return (inc == 1);\n-        if (errors)\n-            goto Lerror;\n-        if (result)\n-            inc = 1;\n-        else\n-            inc = 2;\n-    }\n-    return (inc == 1);\n-\n-Lerror:\n-    if (!global.gag)\n-        inc = 2;                // so we don't see the error message again\n-    return 0;\n-}"}, {"sha": "d4a8b136d430ad8fc82e0d632ee142234c84cb20", "filename": "gcc/d/dmd/cond.d", "status": "added", "additions": 1004, "deletions": 0, "changes": 1004, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fcond.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fcond.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcond.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -0,0 +1,1004 @@\n+/**\n+ * Evaluate compile-time conditionals, such as `static if` `version` and `debug`.\n+ *\n+ * Specification: $(LINK2 https://dlang.org/spec/version.html, Conditional Compilation)\n+ *\n+ * Copyright:   Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n+ * Authors:     $(LINK2 http://www.digitalmars.com, Walter Bright)\n+ * License:     $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+ * Source:      $(LINK2 https://github.com/dlang/dmd/blob/master/src/dmd/cond.d, _cond.d)\n+ * Documentation:  https://dlang.org/phobos/dmd_cond.html\n+ * Coverage:    https://codecov.io/gh/dlang/dmd/src/master/src/dmd/cond.d\n+ */\n+\n+module dmd.cond;\n+\n+import core.stdc.string;\n+import dmd.arraytypes;\n+import dmd.astenums;\n+import dmd.ast_node;\n+import dmd.dcast;\n+import dmd.dmodule;\n+import dmd.dscope;\n+import dmd.dsymbol;\n+import dmd.errors;\n+import dmd.expression;\n+import dmd.expressionsem;\n+import dmd.globals;\n+import dmd.identifier;\n+import dmd.mtype;\n+import dmd.typesem;\n+import dmd.root.outbuffer;\n+import dmd.root.rootobject;\n+import dmd.root.string;\n+import dmd.tokens;\n+import dmd.utils;\n+import dmd.visitor;\n+import dmd.id;\n+import dmd.statement;\n+import dmd.declaration;\n+import dmd.dstruct;\n+import dmd.func;\n+\n+/***********************************************************\n+ */\n+\n+enum Include : ubyte\n+{\n+    notComputed,        /// not computed yet\n+    yes,                /// include the conditional code\n+    no,                 /// do not include the conditional code\n+}\n+\n+extern (C++) abstract class Condition : ASTNode\n+{\n+    Loc loc;\n+\n+    Include inc;\n+\n+    override final DYNCAST dyncast() const\n+    {\n+        return DYNCAST.condition;\n+    }\n+\n+    extern (D) this(const ref Loc loc)\n+    {\n+        this.loc = loc;\n+    }\n+\n+    abstract Condition syntaxCopy();\n+\n+    abstract int include(Scope* sc);\n+\n+    inout(DebugCondition) isDebugCondition() inout\n+    {\n+        return null;\n+    }\n+\n+    inout(VersionCondition) isVersionCondition() inout\n+    {\n+        return null;\n+    }\n+\n+    override void accept(Visitor v)\n+    {\n+        v.visit(this);\n+    }\n+}\n+\n+/***********************************************************\n+ * Implements common functionality for StaticForeachDeclaration and\n+ * StaticForeachStatement This performs the necessary lowerings before\n+ * dmd.statementsem.makeTupleForeach can be used to expand the\n+ * corresponding `static foreach` declaration or statement.\n+ */\n+\n+extern (C++) final class StaticForeach : RootObject\n+{\n+    extern(D) static immutable tupleFieldName = \"tuple\"; // used in lowering\n+\n+    Loc loc;\n+\n+    /***************\n+     * Not `null` iff the `static foreach` is over an aggregate. In\n+     * this case, it contains the corresponding ForeachStatement. For\n+     * StaticForeachDeclaration, the body is `null`.\n+    */\n+    ForeachStatement aggrfe;\n+    /***************\n+     * Not `null` iff the `static foreach` is over a range. Exactly\n+     * one of the `aggrefe` and `rangefe` fields is not null. See\n+     * `aggrfe` field for more details.\n+     */\n+    ForeachRangeStatement rangefe;\n+\n+    /***************\n+     * true if it is necessary to expand a tuple into multiple\n+     * variables (see lowerNonArrayAggregate).\n+     */\n+    bool needExpansion = false;\n+\n+    extern (D) this(const ref Loc loc, ForeachStatement aggrfe, ForeachRangeStatement rangefe)\n+    {\n+        assert(!!aggrfe ^ !!rangefe);\n+\n+        this.loc = loc;\n+        this.aggrfe = aggrfe;\n+        this.rangefe = rangefe;\n+    }\n+\n+    StaticForeach syntaxCopy()\n+    {\n+        return new StaticForeach(\n+            loc,\n+            aggrfe ? aggrfe.syntaxCopy() : null,\n+            rangefe ? rangefe.syntaxCopy() : null\n+        );\n+    }\n+\n+    /*****************************************\n+     * Turn an aggregate which is an array into an expression tuple\n+     * of its elements. I.e., lower\n+     *     static foreach (x; [1, 2, 3, 4]) { ... }\n+     * to\n+     *     static foreach (x; AliasSeq!(1, 2, 3, 4)) { ... }\n+     */\n+    private extern(D) void lowerArrayAggregate(Scope* sc)\n+    {\n+        auto aggr = aggrfe.aggr;\n+        Expression el = new ArrayLengthExp(aggr.loc, aggr);\n+        sc = sc.startCTFE();\n+        el = el.expressionSemantic(sc);\n+        sc = sc.endCTFE();\n+        el = el.optimize(WANTvalue);\n+        el = el.ctfeInterpret();\n+        if (el.op == TOK.int64)\n+        {\n+            Expressions *es = void;\n+            if (auto ale = aggr.isArrayLiteralExp())\n+            {\n+                // Directly use the elements of the array for the TupleExp creation\n+                es = ale.elements;\n+            }\n+            else\n+            {\n+                const length = cast(size_t)el.toInteger();\n+                es = new Expressions(length);\n+                foreach (i; 0 .. length)\n+                {\n+                    auto index = new IntegerExp(loc, i, Type.tsize_t);\n+                    auto value = new IndexExp(aggr.loc, aggr, index);\n+                    (*es)[i] = value;\n+                }\n+            }\n+            aggrfe.aggr = new TupleExp(aggr.loc, es);\n+            aggrfe.aggr = aggrfe.aggr.expressionSemantic(sc);\n+            aggrfe.aggr = aggrfe.aggr.optimize(WANTvalue);\n+            aggrfe.aggr = aggrfe.aggr.ctfeInterpret();\n+        }\n+        else\n+        {\n+            aggrfe.aggr = ErrorExp.get();\n+        }\n+    }\n+\n+    /*****************************************\n+     * Wrap a statement into a function literal and call it.\n+     *\n+     * Params:\n+     *     loc = The source location.\n+     *     s  = The statement.\n+     * Returns:\n+     *     AST of the expression `(){ s; }()` with location loc.\n+     */\n+    private extern(D) Expression wrapAndCall(const ref Loc loc, Statement s)\n+    {\n+        auto tf = new TypeFunction(ParameterList(), null, LINK.default_, 0);\n+        auto fd = new FuncLiteralDeclaration(loc, loc, tf, TOK.reserved, null);\n+        fd.fbody = s;\n+        auto fe = new FuncExp(loc, fd);\n+        auto ce = new CallExp(loc, fe, new Expressions());\n+        return ce;\n+    }\n+\n+    /*****************************************\n+     * Create a `foreach` statement from `aggrefe/rangefe` with given\n+     * `foreach` variables and body `s`.\n+     *\n+     * Params:\n+     *     loc = The source location.\n+     *     parameters = The foreach variables.\n+     *     s = The `foreach` body.\n+     * Returns:\n+     *     `foreach (parameters; aggregate) s;` or\n+     *     `foreach (parameters; lower .. upper) s;`\n+     *     Where aggregate/lower, upper are as for the current StaticForeach.\n+     */\n+    private extern(D) Statement createForeach(const ref Loc loc, Parameters* parameters, Statement s)\n+    {\n+        if (aggrfe)\n+        {\n+            return new ForeachStatement(loc, aggrfe.op, parameters, aggrfe.aggr.syntaxCopy(), s, loc);\n+        }\n+        else\n+        {\n+            assert(rangefe && parameters.dim == 1);\n+            return new ForeachRangeStatement(loc, rangefe.op, (*parameters)[0], rangefe.lwr.syntaxCopy(), rangefe.upr.syntaxCopy(), s, loc);\n+        }\n+    }\n+\n+    /*****************************************\n+     * For a `static foreach` with multiple loop variables, the\n+     * aggregate is lowered to an array of tuples. As D does not have\n+     * built-in tuples, we need a suitable tuple type. This generates\n+     * a `struct` that serves as the tuple type. This type is only\n+     * used during CTFE and hence its typeinfo will not go to the\n+     * object file.\n+     *\n+     * Params:\n+     *     loc = The source location.\n+     *     e = The expressions we wish to store in the tuple.\n+     *     sc  = The current scope.\n+     * Returns:\n+     *     A struct type of the form\n+     *         struct Tuple\n+     *         {\n+     *             typeof(AliasSeq!(e)) tuple;\n+     *         }\n+     */\n+\n+    private extern(D) TypeStruct createTupleType(const ref Loc loc, Expressions* e, Scope* sc)\n+    {   // TODO: move to druntime?\n+        auto sid = Identifier.generateId(\"Tuple\");\n+        auto sdecl = new StructDeclaration(loc, sid, false);\n+        sdecl.storage_class |= STC.static_;\n+        sdecl.members = new Dsymbols();\n+        auto fid = Identifier.idPool(tupleFieldName.ptr, tupleFieldName.length);\n+        auto ty = new TypeTypeof(loc, new TupleExp(loc, e));\n+        sdecl.members.push(new VarDeclaration(loc, ty, fid, null, 0));\n+        auto r = cast(TypeStruct)sdecl.type;\n+        if (global.params.useTypeInfo && Type.dtypeinfo)\n+            r.vtinfo = TypeInfoStructDeclaration.create(r); // prevent typeinfo from going to object file\n+        return r;\n+    }\n+\n+    /*****************************************\n+     * Create the AST for an instantiation of a suitable tuple type.\n+     *\n+     * Params:\n+     *     loc = The source location.\n+     *     type = A Tuple type, created with createTupleType.\n+     *     e = The expressions we wish to store in the tuple.\n+     * Returns:\n+     *     An AST for the expression `Tuple(e)`.\n+     */\n+\n+    private extern(D) Expression createTuple(const ref Loc loc, TypeStruct type, Expressions* e)\n+    {   // TODO: move to druntime?\n+        return new CallExp(loc, new TypeExp(loc, type), e);\n+    }\n+\n+\n+    /*****************************************\n+     * Lower any aggregate that is not an array to an array using a\n+     * regular foreach loop within CTFE.  If there are multiple\n+     * `static foreach` loop variables, an array of tuples is\n+     * generated. In thise case, the field `needExpansion` is set to\n+     * true to indicate that the static foreach loop expansion will\n+     * need to expand the tuples into multiple variables.\n+     *\n+     * For example, `static foreach (x; range) { ... }` is lowered to:\n+     *\n+     *     static foreach (x; {\n+     *         typeof({\n+     *             foreach (x; range) return x;\n+     *         }())[] __res;\n+     *         foreach (x; range) __res ~= x;\n+     *         return __res;\n+     *     }()) { ... }\n+     *\n+     * Finally, call `lowerArrayAggregate` to turn the produced\n+     * array into an expression tuple.\n+     *\n+     * Params:\n+     *     sc = The current scope.\n+     */\n+\n+    private void lowerNonArrayAggregate(Scope* sc)\n+    {\n+        auto nvars = aggrfe ? aggrfe.parameters.dim : 1;\n+        auto aloc = aggrfe ? aggrfe.aggr.loc : rangefe.lwr.loc;\n+        // We need three sets of foreach loop variables because the\n+        // lowering contains three foreach loops.\n+        Parameters*[3] pparams = [new Parameters(), new Parameters(), new Parameters()];\n+        foreach (i; 0 .. nvars)\n+        {\n+            foreach (params; pparams)\n+            {\n+                auto p = aggrfe ? (*aggrfe.parameters)[i] : rangefe.prm;\n+                params.push(new Parameter(p.storageClass, p.type, p.ident, null, null));\n+            }\n+        }\n+        Expression[2] res;\n+        TypeStruct tplty = null;\n+        if (nvars == 1) // only one `static foreach` variable, generate identifiers.\n+        {\n+            foreach (i; 0 .. 2)\n+            {\n+                res[i] = new IdentifierExp(aloc, (*pparams[i])[0].ident);\n+            }\n+        }\n+        else // multiple `static foreach` variables, generate tuples.\n+        {\n+            foreach (i; 0 .. 2)\n+            {\n+                auto e = new Expressions(pparams[0].dim);\n+                foreach (j, ref elem; *e)\n+                {\n+                    auto p = (*pparams[i])[j];\n+                    elem = new IdentifierExp(aloc, p.ident);\n+                }\n+                if (!tplty)\n+                {\n+                    tplty = createTupleType(aloc, e, sc);\n+                }\n+                res[i] = createTuple(aloc, tplty, e);\n+            }\n+            needExpansion = true; // need to expand the tuples later\n+        }\n+        // generate remaining code for the new aggregate which is an\n+        // array (see documentation comment).\n+        if (rangefe)\n+        {\n+            sc = sc.startCTFE();\n+            rangefe.lwr = rangefe.lwr.expressionSemantic(sc);\n+            rangefe.lwr = resolveProperties(sc, rangefe.lwr);\n+            rangefe.upr = rangefe.upr.expressionSemantic(sc);\n+            rangefe.upr = resolveProperties(sc, rangefe.upr);\n+            sc = sc.endCTFE();\n+            rangefe.lwr = rangefe.lwr.optimize(WANTvalue);\n+            rangefe.lwr = rangefe.lwr.ctfeInterpret();\n+            rangefe.upr = rangefe.upr.optimize(WANTvalue);\n+            rangefe.upr = rangefe.upr.ctfeInterpret();\n+        }\n+        auto s1 = new Statements();\n+        auto sfe = new Statements();\n+        if (tplty) sfe.push(new ExpStatement(loc, tplty.sym));\n+        sfe.push(new ReturnStatement(aloc, res[0]));\n+        s1.push(createForeach(aloc, pparams[0], new CompoundStatement(aloc, sfe)));\n+        s1.push(new ExpStatement(aloc, new AssertExp(aloc, IntegerExp.literal!0)));\n+        Type ety = new TypeTypeof(aloc, wrapAndCall(aloc, new CompoundStatement(aloc, s1)));\n+        auto aty = ety.arrayOf();\n+        auto idres = Identifier.generateId(\"__res\");\n+        auto vard = new VarDeclaration(aloc, aty, idres, null);\n+        auto s2 = new Statements();\n+\n+        // Run 'typeof' gagged to avoid duplicate errors and if it fails just create\n+        // an empty foreach to expose them.\n+        uint olderrors = global.startGagging();\n+        ety = ety.typeSemantic(aloc, sc);\n+        if (global.endGagging(olderrors))\n+            s2.push(createForeach(aloc, pparams[1], null));\n+        else\n+        {\n+            s2.push(new ExpStatement(aloc, vard));\n+            auto catass = new CatAssignExp(aloc, new IdentifierExp(aloc, idres), res[1]);\n+            s2.push(createForeach(aloc, pparams[1], new ExpStatement(aloc, catass)));\n+            s2.push(new ReturnStatement(aloc, new IdentifierExp(aloc, idres)));\n+        }\n+\n+        Expression aggr = void;\n+        Type indexty = void;\n+\n+        if (rangefe && (indexty = ety).isintegral())\n+        {\n+            rangefe.lwr.type = indexty;\n+            rangefe.upr.type = indexty;\n+            auto lwrRange = getIntRange(rangefe.lwr);\n+            auto uprRange = getIntRange(rangefe.upr);\n+\n+            const lwr = rangefe.lwr.toInteger();\n+            auto  upr = rangefe.upr.toInteger();\n+            size_t length = 0;\n+\n+            if (lwrRange.imin <= uprRange.imax)\n+                    length = cast(size_t) (upr - lwr);\n+\n+            auto exps = new Expressions(length);\n+\n+            if (rangefe.op == TOK.foreach_)\n+            {\n+                foreach (i; 0 .. length)\n+                    (*exps)[i] = new IntegerExp(aloc, lwr + i, indexty);\n+            }\n+            else\n+            {\n+                --upr;\n+                foreach (i; 0 .. length)\n+                    (*exps)[i] = new IntegerExp(aloc, upr - i, indexty);\n+            }\n+            aggr = new ArrayLiteralExp(aloc, indexty.arrayOf(), exps);\n+        }\n+        else\n+        {\n+            aggr = wrapAndCall(aloc, new CompoundStatement(aloc, s2));\n+            sc = sc.startCTFE();\n+            aggr = aggr.expressionSemantic(sc);\n+            aggr = resolveProperties(sc, aggr);\n+            sc = sc.endCTFE();\n+            aggr = aggr.optimize(WANTvalue);\n+            aggr = aggr.ctfeInterpret();\n+        }\n+\n+        assert(!!aggrfe ^ !!rangefe);\n+        aggrfe = new ForeachStatement(loc, TOK.foreach_, pparams[2], aggr,\n+                                      aggrfe ? aggrfe._body : rangefe._body,\n+                                      aggrfe ? aggrfe.endloc : rangefe.endloc);\n+        rangefe = null;\n+        lowerArrayAggregate(sc); // finally, turn generated array into expression tuple\n+    }\n+\n+    /*****************************************\n+     * Perform `static foreach` lowerings that are necessary in order\n+     * to finally expand the `static foreach` using\n+     * `dmd.statementsem.makeTupleForeach`.\n+     */\n+    extern(D) void prepare(Scope* sc)\n+    {\n+        assert(sc);\n+\n+        if (aggrfe)\n+        {\n+            sc = sc.startCTFE();\n+            aggrfe.aggr = aggrfe.aggr.expressionSemantic(sc);\n+            sc = sc.endCTFE();\n+            aggrfe.aggr = aggrfe.aggr.optimize(WANTvalue);\n+        }\n+\n+        if (aggrfe && aggrfe.aggr.type.toBasetype().ty == Terror)\n+        {\n+            return;\n+        }\n+\n+        if (!ready())\n+        {\n+            if (aggrfe && aggrfe.aggr.type.toBasetype().ty == Tarray)\n+            {\n+                lowerArrayAggregate(sc);\n+            }\n+            else\n+            {\n+                lowerNonArrayAggregate(sc);\n+            }\n+        }\n+    }\n+\n+    /*****************************************\n+     * Returns:\n+     *     `true` iff ready to call `dmd.statementsem.makeTupleForeach`.\n+     */\n+    extern(D) bool ready()\n+    {\n+        return aggrfe && aggrfe.aggr && aggrfe.aggr.type && aggrfe.aggr.type.toBasetype().ty == Ttuple;\n+    }\n+}\n+\n+/***********************************************************\n+ */\n+extern (C++) class DVCondition : Condition\n+{\n+    uint level;\n+    Identifier ident;\n+    Module mod;\n+\n+    extern (D) this(const ref Loc loc, Module mod, uint level, Identifier ident)\n+    {\n+        super(loc);\n+        this.mod = mod;\n+        this.level = level;\n+        this.ident = ident;\n+    }\n+\n+    override final DVCondition syntaxCopy()\n+    {\n+        return this; // don't need to copy\n+    }\n+\n+    override void accept(Visitor v)\n+    {\n+        v.visit(this);\n+    }\n+}\n+\n+/***********************************************************\n+ */\n+extern (C++) final class DebugCondition : DVCondition\n+{\n+    /**\n+     * Add an user-supplied identifier to the list of global debug identifiers\n+     *\n+     * Can be called from either the driver or a `debug = Ident;` statement.\n+     * Unlike version identifier, there isn't any reserved debug identifier\n+     * so no validation takes place.\n+     *\n+     * Params:\n+     *   ident = identifier to add\n+     */\n+    deprecated(\"Kept for C++ compat - Use the string overload instead\")\n+    static void addGlobalIdent(const(char)* ident)\n+    {\n+        addGlobalIdent(ident[0 .. ident.strlen]);\n+    }\n+\n+    /// Ditto\n+    extern(D) static void addGlobalIdent(string ident)\n+    {\n+        // Overload necessary for string literals\n+        addGlobalIdent(cast(const(char)[])ident);\n+    }\n+\n+\n+    /// Ditto\n+    extern(D) static void addGlobalIdent(const(char)[] ident)\n+    {\n+        if (!global.debugids)\n+            global.debugids = new Identifiers();\n+        global.debugids.push(Identifier.idPool(ident));\n+    }\n+\n+\n+    /**\n+     * Instantiate a new `DebugCondition`\n+     *\n+     * Params:\n+     *   mod = Module this node belongs to\n+     *   level = Minimum global level this condition needs to pass.\n+     *           Only used if `ident` is `null`.\n+     *   ident = Identifier required for this condition to pass.\n+     *           If `null`, this conditiion will use an integer level.\n+     *  loc = Location in the source file\n+     */\n+    extern (D) this(const ref Loc loc, Module mod, uint level, Identifier ident)\n+    {\n+        super(loc, mod, level, ident);\n+    }\n+\n+    override int include(Scope* sc)\n+    {\n+        //printf(\"DebugCondition::include() level = %d, debuglevel = %d\\n\", level, global.params.debuglevel);\n+        if (inc == Include.notComputed)\n+        {\n+            inc = Include.no;\n+            bool definedInModule = false;\n+            if (ident)\n+            {\n+                if (findCondition(mod.debugids, ident))\n+                {\n+                    inc = Include.yes;\n+                    definedInModule = true;\n+                }\n+                else if (findCondition(global.debugids, ident))\n+                    inc = Include.yes;\n+                else\n+                {\n+                    if (!mod.debugidsNot)\n+                        mod.debugidsNot = new Identifiers();\n+                    mod.debugidsNot.push(ident);\n+                }\n+            }\n+            else if (level <= global.params.debuglevel || level <= mod.debuglevel)\n+                inc = Include.yes;\n+            if (!definedInModule)\n+                printDepsConditional(sc, this, \"depsDebug \");\n+        }\n+        return (inc == Include.yes);\n+    }\n+\n+    override inout(DebugCondition) isDebugCondition() inout\n+    {\n+        return this;\n+    }\n+\n+    override void accept(Visitor v)\n+    {\n+        v.visit(this);\n+    }\n+\n+    override const(char)* toChars() const\n+    {\n+        return ident ? ident.toChars() : \"debug\".ptr;\n+    }\n+}\n+\n+/**\n+ * Node to represent a version condition\n+ *\n+ * A version condition is of the form:\n+ * ---\n+ * version (Identifier)\n+ * ---\n+ * In user code.\n+ * This class also provides means to add version identifier\n+ * to the list of global (cross module) identifiers.\n+ */\n+extern (C++) final class VersionCondition : DVCondition\n+{\n+    /**\n+     * Check if a given version identifier is reserved.\n+     *\n+     * Params:\n+     *   ident = identifier being checked\n+     *\n+     * Returns:\n+     *   `true` if it is reserved, `false` otherwise\n+     */\n+    extern(D) private static bool isReserved(const(char)[] ident)\n+    {\n+        // This list doesn't include \"D_*\" versions, see the last return\n+        switch (ident)\n+        {\n+            case \"AArch64\":\n+            case \"AIX\":\n+            case \"all\":\n+            case \"Alpha\":\n+            case \"Alpha_HardFloat\":\n+            case \"Alpha_SoftFloat\":\n+            case \"Android\":\n+            case \"ARM\":\n+            case \"ARM_HardFloat\":\n+            case \"ARM_SoftFloat\":\n+            case \"ARM_SoftFP\":\n+            case \"ARM_Thumb\":\n+            case \"AsmJS\":\n+            case \"assert\":\n+            case \"AVR\":\n+            case \"BigEndian\":\n+            case \"BSD\":\n+            case \"CppRuntime_Clang\":\n+            case \"CppRuntime_DigitalMars\":\n+            case \"CppRuntime_Gcc\":\n+            case \"CppRuntime_Microsoft\":\n+            case \"CppRuntime_Sun\":\n+            case \"CRuntime_Bionic\":\n+            case \"CRuntime_DigitalMars\":\n+            case \"CRuntime_Glibc\":\n+            case \"CRuntime_Microsoft\":\n+            case \"CRuntime_Musl\":\n+            case \"CRuntime_Newlib\":\n+            case \"CRuntime_UClibc\":\n+            case \"CRuntime_WASI\":\n+            case \"Cygwin\":\n+            case \"DigitalMars\":\n+            case \"DragonFlyBSD\":\n+            case \"Emscripten\":\n+            case \"ELFv1\":\n+            case \"ELFv2\":\n+            case \"Epiphany\":\n+            case \"FreeBSD\":\n+            case \"FreeStanding\":\n+            case \"GNU\":\n+            case \"Haiku\":\n+            case \"HPPA\":\n+            case \"HPPA64\":\n+            case \"Hurd\":\n+            case \"IA64\":\n+            case \"iOS\":\n+            case \"LDC\":\n+            case \"linux\":\n+            case \"LittleEndian\":\n+            case \"MinGW\":\n+            case \"MIPS32\":\n+            case \"MIPS64\":\n+            case \"MIPS_EABI\":\n+            case \"MIPS_HardFloat\":\n+            case \"MIPS_N32\":\n+            case \"MIPS_N64\":\n+            case \"MIPS_O32\":\n+            case \"MIPS_O64\":\n+            case \"MIPS_SoftFloat\":\n+            case \"MSP430\":\n+            case \"NetBSD\":\n+            case \"none\":\n+            case \"NVPTX\":\n+            case \"NVPTX64\":\n+            case \"OpenBSD\":\n+            case \"OSX\":\n+            case \"PlayStation\":\n+            case \"PlayStation4\":\n+            case \"Posix\":\n+            case \"PPC\":\n+            case \"PPC64\":\n+            case \"PPC_HardFloat\":\n+            case \"PPC_SoftFloat\":\n+            case \"RISCV32\":\n+            case \"RISCV64\":\n+            case \"S390\":\n+            case \"S390X\":\n+            case \"SDC\":\n+            case \"SH\":\n+            case \"SkyOS\":\n+            case \"Solaris\":\n+            case \"SPARC\":\n+            case \"SPARC64\":\n+            case \"SPARC_HardFloat\":\n+            case \"SPARC_SoftFloat\":\n+            case \"SPARC_V8Plus\":\n+            case \"SystemZ\":\n+            case \"SysV3\":\n+            case \"SysV4\":\n+            case \"TVOS\":\n+            case \"unittest\":\n+            case \"WASI\":\n+            case \"WatchOS\":\n+            case \"WebAssembly\":\n+            case \"Win32\":\n+            case \"Win64\":\n+            case \"Windows\":\n+            case \"X86\":\n+            case \"X86_64\":\n+                return true;\n+\n+            default:\n+                // Anything that starts with \"D_\" is reserved\n+                return (ident.length >= 2 && ident[0 .. 2] == \"D_\");\n+        }\n+    }\n+\n+    /**\n+     * Raises an error if a version identifier is reserved.\n+     *\n+     * Called when setting a version identifier, e.g. `-version=identifier`\n+     * parameter to the compiler or `version = Foo` in user code.\n+     *\n+     * Params:\n+     *   loc = Where the identifier is set\n+     *   ident = identifier being checked (ident[$] must be '\\0')\n+     */\n+    extern(D) static void checkReserved(const ref Loc loc, const(char)[] ident)\n+    {\n+        if (isReserved(ident))\n+            error(loc, \"version identifier `%s` is reserved and cannot be set\",\n+                  ident.ptr);\n+    }\n+\n+    /**\n+     * Add an user-supplied global identifier to the list\n+     *\n+     * Only called from the driver for `-version=Ident` parameters.\n+     * Will raise an error if the identifier is reserved.\n+     *\n+     * Params:\n+     *   ident = identifier to add\n+     */\n+    deprecated(\"Kept for C++ compat - Use the string overload instead\")\n+    static void addGlobalIdent(const(char)* ident)\n+    {\n+        addGlobalIdent(ident[0 .. ident.strlen]);\n+    }\n+\n+    /// Ditto\n+    extern(D) static void addGlobalIdent(string ident)\n+    {\n+        // Overload necessary for string literals\n+        addGlobalIdent(cast(const(char)[])ident);\n+    }\n+\n+\n+    /// Ditto\n+    extern(D) static void addGlobalIdent(const(char)[] ident)\n+    {\n+        checkReserved(Loc.initial, ident);\n+        addPredefinedGlobalIdent(ident);\n+    }\n+\n+    /**\n+     * Add any global identifier to the list, without checking\n+     * if it's predefined\n+     *\n+     * Only called from the driver after platform detection,\n+     * and internally.\n+     *\n+     * Params:\n+     *   ident = identifier to add (ident[$] must be '\\0')\n+     */\n+    deprecated(\"Kept for C++ compat - Use the string overload instead\")\n+    static void addPredefinedGlobalIdent(const(char)* ident)\n+    {\n+        addPredefinedGlobalIdent(ident.toDString());\n+    }\n+\n+    /// Ditto\n+    extern(D) static void addPredefinedGlobalIdent(string ident)\n+    {\n+        // Forward: Overload necessary for string literal\n+        addPredefinedGlobalIdent(cast(const(char)[])ident);\n+    }\n+\n+\n+    /// Ditto\n+    extern(D) static void addPredefinedGlobalIdent(const(char)[] ident)\n+    {\n+        if (!global.versionids)\n+            global.versionids = new Identifiers();\n+        global.versionids.push(Identifier.idPool(ident));\n+    }\n+\n+    /**\n+     * Instantiate a new `VersionCondition`\n+     *\n+     * Params:\n+     *   mod = Module this node belongs to\n+     *   level = Minimum global level this condition needs to pass.\n+     *           Only used if `ident` is `null`.\n+     *   ident = Identifier required for this condition to pass.\n+     *           If `null`, this conditiion will use an integer level.\n+     *  loc = Location in the source file\n+     */\n+    extern (D) this(const ref Loc loc, Module mod, uint level, Identifier ident)\n+    {\n+        super(loc, mod, level, ident);\n+    }\n+\n+    override int include(Scope* sc)\n+    {\n+        //printf(\"VersionCondition::include() level = %d, versionlevel = %d\\n\", level, global.params.versionlevel);\n+        //if (ident) printf(\"\\tident = '%s'\\n\", ident.toChars());\n+        if (inc == Include.notComputed)\n+        {\n+            inc = Include.no;\n+            bool definedInModule = false;\n+            if (ident)\n+            {\n+                if (findCondition(mod.versionids, ident))\n+                {\n+                    inc = Include.yes;\n+                    definedInModule = true;\n+                }\n+                else if (findCondition(global.versionids, ident))\n+                    inc = Include.yes;\n+                else\n+                {\n+                    if (!mod.versionidsNot)\n+                        mod.versionidsNot = new Identifiers();\n+                    mod.versionidsNot.push(ident);\n+                }\n+            }\n+            else if (level <= global.params.versionlevel || level <= mod.versionlevel)\n+                inc = Include.yes;\n+            if (!definedInModule &&\n+                (!ident || (!isReserved(ident.toString()) && ident != Id._unittest && ident != Id._assert)))\n+            {\n+                printDepsConditional(sc, this, \"depsVersion \");\n+            }\n+        }\n+        return (inc == Include.yes);\n+    }\n+\n+    override inout(VersionCondition) isVersionCondition() inout\n+    {\n+        return this;\n+    }\n+\n+    override void accept(Visitor v)\n+    {\n+        v.visit(this);\n+    }\n+\n+    override const(char)* toChars() const\n+    {\n+        return ident ? ident.toChars() : \"version\".ptr;\n+    }\n+}\n+\n+/***********************************************************\n+ */\n+extern (C++) final class StaticIfCondition : Condition\n+{\n+    Expression exp;\n+\n+    extern (D) this(const ref Loc loc, Expression exp)\n+    {\n+        super(loc);\n+        this.exp = exp;\n+    }\n+\n+    override StaticIfCondition syntaxCopy()\n+    {\n+        return new StaticIfCondition(loc, exp.syntaxCopy());\n+    }\n+\n+    override int include(Scope* sc)\n+    {\n+        // printf(\"StaticIfCondition::include(sc = %p) this=%p inc = %d\\n\", sc, this, inc);\n+\n+        int errorReturn()\n+        {\n+            if (!global.gag)\n+                inc = Include.no; // so we don't see the error message again\n+            return 0;\n+        }\n+\n+        if (inc == Include.notComputed)\n+        {\n+            if (!sc)\n+            {\n+                error(loc, \"`static if` conditional cannot be at global scope\");\n+                inc = Include.no;\n+                return 0;\n+            }\n+\n+            import dmd.staticcond;\n+            bool errors;\n+\n+            if (!exp)\n+                return errorReturn();\n+\n+            bool result = evalStaticCondition(sc, exp, exp, errors);\n+\n+            // Prevent repeated condition evaluation.\n+            // See: fail_compilation/fail7815.d\n+            if (inc != Include.notComputed)\n+                return (inc == Include.yes);\n+            if (errors)\n+                return errorReturn();\n+            if (result)\n+                inc = Include.yes;\n+            else\n+                inc = Include.no;\n+        }\n+        return (inc == Include.yes);\n+    }\n+\n+    override void accept(Visitor v)\n+    {\n+        v.visit(this);\n+    }\n+\n+    override const(char)* toChars() const\n+    {\n+        return exp ? exp.toChars() : \"static if\".ptr;\n+    }\n+}\n+\n+\n+/****************************************\n+ * Find `ident` in an array of identifiers.\n+ * Params:\n+ *      ids = array of identifiers\n+ *      ident = identifier to search for\n+ * Returns:\n+ *      true if found\n+ */\n+bool findCondition(Identifiers* ids, Identifier ident) @safe nothrow pure\n+{\n+    if (ids)\n+    {\n+        foreach (id; *ids)\n+        {\n+            if (id == ident)\n+                return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+// Helper for printing dependency information\n+private void printDepsConditional(Scope* sc, DVCondition condition, const(char)[] depType)\n+{\n+    if (!global.params.moduleDeps || global.params.moduleDepsFile)\n+        return;\n+    OutBuffer* ob = global.params.moduleDeps;\n+    Module imod = sc ? sc._module : condition.mod;\n+    if (!imod)\n+        return;\n+    ob.writestring(depType);\n+    ob.writestring(imod.toPrettyChars());\n+    ob.writestring(\" (\");\n+    escapePath(ob, imod.srcfile.toChars());\n+    ob.writestring(\") : \");\n+    if (condition.ident)\n+        ob.writestring(condition.ident.toString());\n+    else\n+        ob.print(condition.level);\n+    ob.writeByte('\\n');\n+}"}, {"sha": "4f261162ebb1e19c46047f2638ccebd85e134afd", "filename": "gcc/d/dmd/cond.h", "status": "modified", "additions": 9, "deletions": 22, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fcond.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fcond.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcond.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5", "patch": "@@ -16,26 +16,24 @@\n \n class Expression;\n class Identifier;\n-struct OutBuffer;\n class Module;\n struct Scope;\n-class ScopeDsymbol;\n class DebugCondition;\n class ForeachStatement;\n class ForeachRangeStatement;\n \n-int findCondition(Identifiers *ids, Identifier *ident);\n+enum Include\n+{\n+    INCLUDEnotComputed, /// not computed yet\n+    INCLUDEyes,         /// include the conditional code\n+    INCLUDEno           /// do not include the conditional code\n+};\n \n class Condition : public ASTNode\n {\n public:\n     Loc loc;\n-    // 0: not computed yet\n-    // 1: include\n-    // 2: do not include\n-    int inc;\n-\n-    Condition(Loc loc);\n+    Include inc;\n \n     virtual Condition *syntaxCopy() = 0;\n     virtual int include(Scope *sc) = 0;\n@@ -54,23 +52,17 @@ class StaticForeach\n \n     bool needExpansion;\n \n-    StaticForeach(Loc loc, ForeachStatement *aggrfe, ForeachRangeStatement *rangefe);\n     StaticForeach *syntaxCopy();\n };\n \n-void staticForeachPrepare(StaticForeach *sfe, Scope *sc);\n-bool staticForeachReady(StaticForeach *sfe);\n-\n class DVCondition : public Condition\n {\n public:\n     unsigned level;\n     Identifier *ident;\n     Module *mod;\n \n-    DVCondition(Module *mod, unsigned level, Identifier *ident);\n-\n-    Condition *syntaxCopy();\n+    DVCondition *syntaxCopy();\n     void accept(Visitor *v) { v->visit(this); }\n };\n \n@@ -79,8 +71,6 @@ class DebugCondition : public DVCondition\n public:\n     static void addGlobalIdent(const char *ident);\n \n-    DebugCondition(Module *mod, unsigned level, Identifier *ident);\n-\n     int include(Scope *sc);\n     DebugCondition *isDebugCondition() { return this; }\n     void accept(Visitor *v) { v->visit(this); }\n@@ -92,8 +82,6 @@ class VersionCondition : public DVCondition\n     static void addGlobalIdent(const char *ident);\n     static void addPredefinedGlobalIdent(const char *ident);\n \n-    VersionCondition(Module *mod, unsigned level, Identifier *ident);\n-\n     int include(Scope *sc);\n     VersionCondition *isVersionCondition() { return this; }\n     void accept(Visitor *v) { v->visit(this); }\n@@ -104,8 +92,7 @@ class StaticIfCondition : public Condition\n public:\n     Expression *exp;\n \n-    StaticIfCondition(Loc loc, Expression *exp);\n-    Condition *syntaxCopy();\n+    StaticIfCondition *syntaxCopy();\n     int include(Scope *sc);\n     void accept(Visitor *v) { v->visit(this); }\n };"}, {"sha": "8cfeac54e20ae5e745c83306d55e467b0e806ce5", "filename": "gcc/d/dmd/constfold.c", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fconstfold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fconstfold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fconstfold.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "1dada60de3b4a4f754e59ed7196d04c0d43b03b8", "filename": "gcc/d/dmd/constfold.d", "status": "added", "additions": 1825, "deletions": 0, "changes": 1825, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fconstfold.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fconstfold.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fconstfold.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "bb40649dc0bfa5d085587c57c3caa08925465713", "filename": "gcc/d/dmd/cparse.d", "status": "added", "additions": 4249, "deletions": 0, "changes": 4249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fcparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fcparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcparse.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "baf64c5653e7d11fb207269a49e69b7e0318eae6", "filename": "gcc/d/dmd/cppmangle.c", "status": "removed", "additions": 0, "deletions": 1168, "changes": 1168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fcppmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fcppmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcppmangle.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "0381f9ad6a466838b6113feb37f44aab6d3b4589", "filename": "gcc/d/dmd/cppmangle.d", "status": "added", "additions": 2540, "deletions": 0, "changes": 2540, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fcppmangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fcppmangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcppmangle.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "242dd552b94da39440a233cc5a51fde5f7cd9eb3", "filename": "gcc/d/dmd/ctfe.h", "status": "modified", "additions": 9, "deletions": 213, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fctfe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fctfe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fctfe.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "a8e97833ad023f529bebd623d246b3a896037235", "filename": "gcc/d/dmd/ctfeexpr.c", "status": "removed", "additions": 0, "deletions": 2127, "changes": 2127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fctfeexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fctfeexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fctfeexpr.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "22633a869d4510234bca515250acae09e87c77fa", "filename": "gcc/d/dmd/ctfeexpr.d", "status": "added", "additions": 2096, "deletions": 0, "changes": 2096, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fctfeexpr.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fctfeexpr.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fctfeexpr.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "c8b61be44a5280fc0948a08db78330db8f2efb38", "filename": "gcc/d/dmd/ctorflow.d", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fctorflow.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fctorflow.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fctorflow.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "d84ab7ffc21a2a6e90268e6b6ada72127c0b77ce", "filename": "gcc/d/dmd/dcast.c", "status": "removed", "additions": 0, "deletions": 3566, "changes": 3566, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdcast.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdcast.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdcast.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "4c70565e5c2027553fb4cb86894b9569f005e217", "filename": "gcc/d/dmd/dcast.d", "status": "added", "additions": 3741, "deletions": 0, "changes": 3741, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdcast.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdcast.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdcast.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "3f33014da9f59e5c8ff693cb20642f13d33cf511", "filename": "gcc/d/dmd/dclass.c", "status": "removed", "additions": 0, "deletions": 1041, "changes": 1041, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdclass.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "b065251e6523198154c0636dfd867e27ce308e41", "filename": "gcc/d/dmd/dclass.d", "status": "added", "additions": 1139, "deletions": 0, "changes": 1139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdclass.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdclass.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdclass.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "a9394dcce7fb6bb9efdf7f3deee68c77dee445ed", "filename": "gcc/d/dmd/declaration.c", "status": "removed", "additions": 0, "deletions": 1575, "changes": 1575, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdeclaration.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdeclaration.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "0f40c1142c73f5c36ea509e50e138e2217a7caeb", "filename": "gcc/d/dmd/declaration.d", "status": "added", "additions": 2323, "deletions": 0, "changes": 2323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdeclaration.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdeclaration.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "1c56defd3ee3a4c7e4825f77931de22e7ca2c106", "filename": "gcc/d/dmd/declaration.h", "status": "modified", "additions": 250, "deletions": 332, "changes": 582, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdeclaration.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdeclaration.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "b3019aae4b8d503745c8d9d0319c456611dab842", "filename": "gcc/d/dmd/delegatize.c", "status": "removed", "additions": 0, "deletions": 208, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdelegatize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdelegatize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdelegatize.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "07c1bbda650577e955d91c81f53ee1518051151a", "filename": "gcc/d/dmd/delegatize.d", "status": "added", "additions": 305, "deletions": 0, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdelegatize.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdelegatize.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdelegatize.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "b00eaa02f9dd873c416cc7a81b63121cd148e5b1", "filename": "gcc/d/dmd/denum.c", "status": "removed", "additions": 0, "deletions": 388, "changes": 388, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdenum.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdenum.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdenum.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "54467d8efd49bd0bf5ddd94fc779216c5bdd2c76", "filename": "gcc/d/dmd/denum.d", "status": "added", "additions": 333, "deletions": 0, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdenum.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdenum.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdenum.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "7b63a1865525093668a793d9e5e4cafed606f900", "filename": "gcc/d/dmd/dimport.c", "status": "removed", "additions": 0, "deletions": 320, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdimport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdimport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdimport.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "8cd436422eeb6563fbde34c087e1dd672516c564", "filename": "gcc/d/dmd/dimport.d", "status": "added", "additions": 358, "deletions": 0, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdimport.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdimport.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdimport.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "ab9d88c660c806b2ad73f7a01d6e95881f3b66e0", "filename": "gcc/d/dmd/dinterpret.c", "status": "removed", "additions": 0, "deletions": 7017, "changes": 7017, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdinterpret.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdinterpret.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdinterpret.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "541fac7dfb43389087a88038466e9b692f457436", "filename": "gcc/d/dmd/dinterpret.d", "status": "added", "additions": 7487, "deletions": 0, "changes": 7487, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdinterpret.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdinterpret.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdinterpret.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "91cbe50713ce6bd2174e3755cdbe974475416ea3", "filename": "gcc/d/dmd/dmacro.c", "status": "removed", "additions": 0, "deletions": 458, "changes": 458, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmacro.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "ddfee2ccab0516e4eeae2a9e38f268e58ef3c5f9", "filename": "gcc/d/dmd/dmacro.d", "status": "added", "additions": 435, "deletions": 0, "changes": 435, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdmacro.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdmacro.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmacro.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "83f4c18bee835ea87c68fb644c5e172734ba212f", "filename": "gcc/d/dmd/dmangle.c", "status": "removed", "additions": 0, "deletions": 1122, "changes": 1122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmangle.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "71b8c7a609897c6099ae79da7405fd47485ab8e6", "filename": "gcc/d/dmd/dmangle.d", "status": "added", "additions": 1297, "deletions": 0, "changes": 1297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdmangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdmangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmangle.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "472b2b9e7f89915a0fd1810eac1ddf7ddb9e2abf", "filename": "gcc/d/dmd/dmodule.c", "status": "removed", "additions": 0, "deletions": 1276, "changes": 1276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmodule.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "768eaa05a08e2fa0344affdcca15e8726bd940cf", "filename": "gcc/d/dmd/dmodule.d", "status": "added", "additions": 1608, "deletions": 0, "changes": 1608, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdmodule.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdmodule.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmodule.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "5d2da1ccdb91f974c10b1312135716a1037a9123", "filename": "gcc/d/dmd/doc.c", "status": "removed", "additions": 0, "deletions": 2807, "changes": 2807, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdoc.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "9b4329b8b0a4afcb9e6c57f21c8d7e8de62a1b1b", "filename": "gcc/d/dmd/doc.d", "status": "added", "additions": 5388, "deletions": 0, "changes": 5388, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdoc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdoc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdoc.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "a144417daee34250dde93473891c3f0fb8cf522d", "filename": "gcc/d/dmd/doc.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdoc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdoc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdoc.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "e56f3936ee07eee24ee970785c888f71f9c5cc55", "filename": "gcc/d/dmd/dscope.c", "status": "removed", "additions": 0, "deletions": 646, "changes": 646, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdscope.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdscope.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdscope.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "638fc7e52957898a1b276554386d953607aed955", "filename": "gcc/d/dmd/dscope.d", "status": "added", "additions": 768, "deletions": 0, "changes": 768, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdscope.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdscope.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdscope.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "98621594bd267ab564b93041d8a78c21e94f539a", "filename": "gcc/d/dmd/dstruct.c", "status": "removed", "additions": 0, "deletions": 1303, "changes": 1303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdstruct.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdstruct.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdstruct.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "80ecd3611358ff3a6efd26ee88b6368e61a0da41", "filename": "gcc/d/dmd/dstruct.d", "status": "added", "additions": 610, "deletions": 0, "changes": 610, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdstruct.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdstruct.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdstruct.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "f0c1cf6d93cfe0e7b9052accd98cc81918872825", "filename": "gcc/d/dmd/dsymbol.c", "status": "removed", "additions": 0, "deletions": 1803, "changes": 1803, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "3a6dff2d44fb45fafd6416d0302743028893fce3", "filename": "gcc/d/dmd/dsymbol.d", "status": "added", "additions": 2386, "deletions": 0, "changes": 2386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdsymbol.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdsymbol.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "f43bc83799264decd6580602be3a4dece53e1a7e", "filename": "gcc/d/dmd/dsymbol.h", "status": "modified", "additions": 72, "deletions": 70, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdsymbol.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdsymbol.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "7a44ed2c41d859d64192431e6929d5be83001682", "filename": "gcc/d/dmd/dsymbolsem.c", "status": "removed", "additions": 0, "deletions": 5620, "changes": 5620, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdsymbolsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdsymbolsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbolsem.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "eac20952eb5504ae6b3b63fbe30ab475f55c8170", "filename": "gcc/d/dmd/dsymbolsem.d", "status": "added", "additions": 6654, "deletions": 0, "changes": 6654, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbolsem.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "20036f2dbff0b068ffa6c77b92b2bb7c9acd798b", "filename": "gcc/d/dmd/dtemplate.c", "status": "removed", "additions": 0, "deletions": 7581, "changes": 7581, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdtemplate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdtemplate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtemplate.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "c3503bbf7d6a91a08897bfe867df5ed330ea421a", "filename": "gcc/d/dmd/dtemplate.d", "status": "added", "additions": 8415, "deletions": 0, "changes": 8415, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdtemplate.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdtemplate.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtemplate.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "28054d02904484834c17982190ecf8d4f016f6f2", "filename": "gcc/d/dmd/dtoh.d", "status": "added", "additions": 3225, "deletions": 0, "changes": 3225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdtoh.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdtoh.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtoh.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "269d92466cdf3784177e959283176242919dd29d", "filename": "gcc/d/dmd/dversion.c", "status": "removed", "additions": 0, "deletions": 187, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fdversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdversion.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "0dff754bee55e1495cb4993d69067709ba9a1600", "filename": "gcc/d/dmd/dversion.d", "status": "added", "additions": 215, "deletions": 0, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdversion.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fdversion.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdversion.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "cac901d1a6e9ea9c3a86ec0ebcb754e9bf01c9b7", "filename": "gcc/d/dmd/entity.c", "status": "removed", "additions": 0, "deletions": 2390, "changes": 2390, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fentity.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fentity.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fentity.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "f22dfdb0249cdc4a499e4a5a045ac82a2685857a", "filename": "gcc/d/dmd/entity.d", "status": "added", "additions": 2395, "deletions": 0, "changes": 2395, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fentity.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fentity.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fentity.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "76c1235715bdcdb2d51e9e1bee50dcd02e331b76", "filename": "gcc/d/dmd/enum.h", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fenum.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fenum.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fenum.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "91a5c77b53e4383d58bd4530510203ff924f81e2", "filename": "gcc/d/dmd/errors.d", "status": "added", "additions": 446, "deletions": 0, "changes": 446, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Ferrors.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Ferrors.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ferrors.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "6d9587d14366cd09422f780abcfa70e189d25df8", "filename": "gcc/d/dmd/errors.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Ferrors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Ferrors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ferrors.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "cd0382b0a22cdf27266160285ce77a114053fd0e", "filename": "gcc/d/dmd/escape.c", "status": "removed", "additions": 0, "deletions": 1234, "changes": 1234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fescape.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fescape.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fescape.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "d502f80975b37dec6de5356b5f9ca791adc6b1b2", "filename": "gcc/d/dmd/escape.d", "status": "added", "additions": 2290, "deletions": 0, "changes": 2290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fescape.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fescape.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fescape.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "18aa6aa9ab4300a45e846ee88d37f4eb5c548b8a", "filename": "gcc/d/dmd/expression.c", "status": "removed", "additions": 0, "deletions": 5706, "changes": 5706, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fexpression.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fexpression.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "0d6fa1e88f37c56395a06ee64126c21010e2f240", "filename": "gcc/d/dmd/expression.d", "status": "added", "additions": 6985, "deletions": 0, "changes": 6985, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fexpression.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fexpression.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "dec3713b676b4802b443113af59f8d72e252254d", "filename": "gcc/d/dmd/expression.h", "status": "modified", "additions": 137, "deletions": 442, "changes": 579, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fexpression.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fexpression.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "5ae5fe6a717dde6f76edbe3e65b9185e7ac0a070", "filename": "gcc/d/dmd/expressionsem.c", "status": "removed", "additions": 0, "deletions": 10740, "changes": 10740, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fexpressionsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fexpressionsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "3b604af53b98a1c53cbc8c87b03552f287a6ac34", "filename": "gcc/d/dmd/expressionsem.d", "status": "added", "additions": 13058, "deletions": 0, "changes": 13058, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "9579ac7d6a544bde97d36de6734b8105daf67c66", "filename": "gcc/d/dmd/foreachvar.d", "status": "added", "additions": 323, "deletions": 0, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fforeachvar.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fforeachvar.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fforeachvar.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "b8e1e3183760c98018fa588321dfcdadc0990d5b", "filename": "gcc/d/dmd/func.c", "status": "removed", "additions": 0, "deletions": 3161, "changes": 3161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Ffunc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Ffunc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffunc.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "7f0b0bb9a28d893dfd1728b4c3bc1818d30d0147", "filename": "gcc/d/dmd/func.d", "status": "added", "additions": 4102, "deletions": 0, "changes": 4102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Ffunc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Ffunc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffunc.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "9b65d024b97de0eae27a331ba64136a6844dcd22", "filename": "gcc/d/dmd/globals.d", "status": "added", "additions": 640, "deletions": 0, "changes": 640, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fglobals.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fglobals.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fglobals.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "6e794748beeea53b096bcf24bd8e59e6bf9d416f", "filename": "gcc/d/dmd/globals.h", "status": "modified", "additions": 159, "deletions": 96, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fglobals.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fglobals.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fglobals.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "debb9ca62d4f8bfe08d8d93b96d61e60a9991d4a", "filename": "gcc/d/dmd/gluelayer.d", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fgluelayer.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fgluelayer.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fgluelayer.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "9397b1e8abd8acf9f208733052f1994cedd1b611", "filename": "gcc/d/dmd/hdrgen.c", "status": "removed", "additions": 0, "deletions": 3591, "changes": 3591, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fhdrgen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fhdrgen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fhdrgen.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "8c31590a3115af2b1559261d5cb8fe877ff3adaa", "filename": "gcc/d/dmd/hdrgen.d", "status": "added", "additions": 3956, "deletions": 0, "changes": 3956, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fhdrgen.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fhdrgen.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fhdrgen.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "531d5d8c0da0043033661c73f7720732c57602c7", "filename": "gcc/d/dmd/hdrgen.h", "status": "modified", "additions": 5, "deletions": 38, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fhdrgen.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fhdrgen.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fhdrgen.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "fc58a3c4462fd64a22efdfd2193df620a6fbac73", "filename": "gcc/d/dmd/iasm.c", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fiasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fiasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fiasm.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "df8d1c98770f3cea696c566e8f662d9f41a52450", "filename": "gcc/d/dmd/iasm.d", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fiasm.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fiasm.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fiasm.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "e3940a8adbf4da0d4f1ce9114f5028e1b395959a", "filename": "gcc/d/dmd/iasmgcc.c", "status": "removed", "additions": 0, "deletions": 379, "changes": 379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fiasmgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fiasmgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fiasmgcc.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "e61fb23eb5d4d826dc10621b3986c547dda6e477", "filename": "gcc/d/dmd/iasmgcc.d", "status": "added", "additions": 537, "deletions": 0, "changes": 537, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fiasmgcc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fiasmgcc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fiasmgcc.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "1f04dcfbc11422bc4b65948ce6fba691904c881b", "filename": "gcc/d/dmd/id.d", "status": "added", "additions": 568, "deletions": 0, "changes": 568, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fid.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fid.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fid.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "8066747c69bf92be2057e054a2508ea02e66c855", "filename": "gcc/d/dmd/id.h", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fid.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fid.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fid.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "197d288e5323a7270c63f952823df05a21989014", "filename": "gcc/d/dmd/identifier.c", "status": "removed", "additions": 0, "deletions": 188, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fidentifier.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fidentifier.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fidentifier.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "43a1435cd107d0f5440354e3e92960458323b1ae", "filename": "gcc/d/dmd/identifier.d", "status": "added", "additions": 362, "deletions": 0, "changes": 362, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fidentifier.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fidentifier.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fidentifier.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "790d5a036d432a0d8a563a77caa828b42426ec4d", "filename": "gcc/d/dmd/identifier.h", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fidentifier.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fidentifier.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fidentifier.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "0740653709ae37c5459ca69616f6c4c52ebfd820", "filename": "gcc/d/dmd/idgen.c", "status": "removed", "additions": 0, "deletions": 560, "changes": 560, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fidgen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fidgen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fidgen.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "d7c27eaa7714051be4b1db40d1b23dd972cf8e10", "filename": "gcc/d/dmd/impcnvgen.c", "status": "removed", "additions": 0, "deletions": 598, "changes": 598, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fimpcnvgen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fimpcnvgen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fimpcnvgen.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "db09f0c568e14e93fe1af69dcc416f193318f8f1", "filename": "gcc/d/dmd/impcnvtab.d", "status": "added", "additions": 379, "deletions": 0, "changes": 379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fimpcnvtab.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fimpcnvtab.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fimpcnvtab.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "239cb07333266b2c3054c3481982899a2adb8230", "filename": "gcc/d/dmd/imphint.c", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fimphint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fimphint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fimphint.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "e1919a67037c91b104a7a01b3f35bdcb2d58e356", "filename": "gcc/d/dmd/imphint.d", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fimphint.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fimphint.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fimphint.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "34c5a05a8cdaa4e5d0ec4e0b51cdb3b50a3b119b", "filename": "gcc/d/dmd/import.h", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fimport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fimport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fimport.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "d18e0549aace1411b2505c11484462a8f8262bed", "filename": "gcc/d/dmd/init.c", "status": "removed", "additions": 0, "deletions": 282, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finit.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "45e101b903a4fe93882e8687cc7d1907cacf3dbf", "filename": "gcc/d/dmd/init.d", "status": "added", "additions": 332, "deletions": 0, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Finit.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Finit.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finit.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "23204b81253e76d552bec3d9ccac448bd2c10ea2", "filename": "gcc/d/dmd/init.h", "status": "modified", "additions": 32, "deletions": 37, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Finit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Finit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finit.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "c7d1dfe0deb8a5e84f6bb59353186ff11b2027f9", "filename": "gcc/d/dmd/initsem.c", "status": "removed", "additions": 0, "deletions": 914, "changes": 914, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Finitsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Finitsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finitsem.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "ae8bde2ff57611cf0daac3371e1e37362373b931", "filename": "gcc/d/dmd/initsem.d", "status": "added", "additions": 1268, "deletions": 0, "changes": 1268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Finitsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Finitsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finitsem.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "cfd619ac4a45450dc23c40ae6ae973876b6bc808", "filename": "gcc/d/dmd/inline.d", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Finline.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Finline.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finline.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "36af8dac9eedadfa0e576d0d9b90c8f3225df399", "filename": "gcc/d/dmd/intrange.c", "status": "removed", "additions": 0, "deletions": 839, "changes": 839, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fintrange.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fintrange.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fintrange.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "9b70f49a0e8cc5226c25327afe8cb24896c0d9ba", "filename": "gcc/d/dmd/intrange.d", "status": "added", "additions": 919, "deletions": 0, "changes": 919, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fintrange.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fintrange.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fintrange.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "832e559a875c2613ef87de3f44aaf8db9582c837", "filename": "gcc/d/dmd/json.c", "status": "removed", "additions": 0, "deletions": 888, "changes": 888, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fjson.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fjson.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fjson.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "bfd31bc1d13697c304c8cc4b57fb4cdf13a1c52c", "filename": "gcc/d/dmd/json.d", "status": "added", "additions": 1085, "deletions": 0, "changes": 1085, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fjson.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fjson.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fjson.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "1311fb3ab2e94df46878c6f9c11b8ac6f9b04cc2", "filename": "gcc/d/dmd/json.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fjson.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fjson.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fjson.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "d29bdc1380615e83d83d9f0443fbb278235ba261", "filename": "gcc/d/dmd/lambdacomp.d", "status": "added", "additions": 495, "deletions": 0, "changes": 495, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Flambdacomp.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Flambdacomp.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Flambdacomp.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "3ea932c036eb38adcb8a8a4c8d1337bfb37ab493", "filename": "gcc/d/dmd/lexer.c", "status": "removed", "additions": 0, "deletions": 2405, "changes": 2405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Flexer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Flexer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Flexer.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "afffc2dcf303786a0d22cdc8794f8f6c773d632d", "filename": "gcc/d/dmd/lexer.d", "status": "added", "additions": 3273, "deletions": 0, "changes": 3273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Flexer.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Flexer.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Flexer.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "670cf4d62308b59184149d461d898b83e8972c6f", "filename": "gcc/d/dmd/mangle.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fmangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fmangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmangle.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "969290c476ccad03efb91fc38ab152713b21640a", "filename": "gcc/d/dmd/module.h", "status": "modified", "additions": 28, "deletions": 31, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fmodule.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fmodule.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmodule.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "6cccf40df986ba519e38529b828b7dd0723bd9e8", "filename": "gcc/d/dmd/mtype.c", "status": "removed", "additions": 0, "deletions": 8722, "changes": 8722, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fmtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fmtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "80e47918f2da03bbc6e0f0c047a3d87c16769010", "filename": "gcc/d/dmd/mtype.d", "status": "added", "additions": 7355, "deletions": 0, "changes": 7355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fmtype.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fmtype.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "cdf221f55f762ed367650ef23ae09ca700e0a527", "filename": "gcc/d/dmd/mtype.h", "status": "modified", "additions": 182, "deletions": 262, "changes": 444, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fmtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fmtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "12c8b490cfb4936778c2adb0c12481e7c3301a6a", "filename": "gcc/d/dmd/nogc.c", "status": "removed", "additions": 0, "deletions": 241, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fnogc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fnogc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fnogc.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "4bb2907c9ba2b2e7dcb52278179fdf7e3f9213b2", "filename": "gcc/d/dmd/nogc.d", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fnogc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fnogc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fnogc.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "95cfb6f0d346fd87fbf4f6ab528e86d777121d00", "filename": "gcc/d/dmd/nspace.c", "status": "removed", "additions": 0, "deletions": 164, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fnspace.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fnspace.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fnspace.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "215f2595888cd9f953c2bfe208c080de40693519", "filename": "gcc/d/dmd/nspace.d", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fnspace.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fnspace.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fnspace.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "43d36e9e4e0b798643a38a6b54683770ab3191a4", "filename": "gcc/d/dmd/nspace.h", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fnspace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fnspace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fnspace.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "7719ccfe2978ed7b4dc1d858708b2533c0e78f1b", "filename": "gcc/d/dmd/ob.d", "status": "added", "additions": 2680, "deletions": 0, "changes": 2680, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fob.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fob.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fob.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "3199a0164ee3f0839e59262ba15b3b01e076a8e8", "filename": "gcc/d/dmd/objc.c", "status": "removed", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fobjc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fobjc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fobjc.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "85e371e6e63d5465d167003dd0f30191f1b966e1", "filename": "gcc/d/dmd/objc.d", "status": "added", "additions": 953, "deletions": 0, "changes": 953, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fobjc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fobjc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fobjc.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "483e50149e7727979745e96d92b53534adec9bb0", "filename": "gcc/d/dmd/objc.h", "status": "modified", "additions": 43, "deletions": 12, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fobjc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fobjc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fobjc.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "0aff8b43551788b840ddaa31ba453da7e8aec11f", "filename": "gcc/d/dmd/opover.c", "status": "removed", "additions": 0, "deletions": 1960, "changes": 1960, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fopover.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fopover.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fopover.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "4ef55f3acc9a4fd1c8ec35584dc60e6f71737005", "filename": "gcc/d/dmd/opover.d", "status": "added", "additions": 1843, "deletions": 0, "changes": 1843, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fopover.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fopover.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fopover.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "44dedd84038a9829b1c69db9e1d7d93a65d6b4c3", "filename": "gcc/d/dmd/optimize.c", "status": "removed", "additions": 0, "deletions": 1230, "changes": 1230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Foptimize.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "3ae30619a207176c8542fdc7b1c00e9eb4ab824c", "filename": "gcc/d/dmd/optimize.d", "status": "added", "additions": 1186, "deletions": 0, "changes": 1186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Foptimize.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Foptimize.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Foptimize.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "e1f13214d586204ba49d36b0ade2dd1cee30b463", "filename": "gcc/d/dmd/parse.c", "status": "removed", "additions": 0, "deletions": 8492, "changes": 8492, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "21042dd80ea0e114e670b92cea2db93873a803ee", "filename": "gcc/d/dmd/parse.d", "status": "added", "additions": 9365, "deletions": 0, "changes": 9365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "d3e30861a8a882b05e5653afc690e4af9bddb967", "filename": "gcc/d/dmd/parsetimevisitor.d", "status": "added", "additions": 297, "deletions": 0, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fparsetimevisitor.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fparsetimevisitor.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparsetimevisitor.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "5d7f3fcba2c16216235b06b595103c4b1902131b", "filename": "gcc/d/dmd/permissivevisitor.d", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fpermissivevisitor.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fpermissivevisitor.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fpermissivevisitor.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "3f12b173357f0149a78f816c89f1dd04f052a695", "filename": "gcc/d/dmd/printast.d", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fprintast.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fprintast.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fprintast.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "a9a31af1b6ea74eb0f2ee7e71d5f7e0a1ece6547", "filename": "gcc/d/dmd/readme.txt", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Freadme.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Freadme.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Freadme.txt?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "7ae0db898eff72071a1b787b54c6216684646332", "filename": "gcc/d/dmd/res/default_ddoc_theme.ddoc", "status": "added", "additions": 825, "deletions": 0, "changes": 825, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fres%2Fdefault_ddoc_theme.ddoc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fres%2Fdefault_ddoc_theme.ddoc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fres%2Fdefault_ddoc_theme.ddoc?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "539b940d6fb62a94eee05d857f33648f00ad763a", "filename": "gcc/d/dmd/root/README.md", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2FREADME.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2FREADME.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2FREADME.md?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "992a117da2af7e8cad4136cf1657aa1995a756d1", "filename": "gcc/d/dmd/root/aav.c", "status": "removed", "additions": 0, "deletions": 171, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Froot%2Faav.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Froot%2Faav.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Faav.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "92b58ba5cd83c59863054f15b3bcdb58dd660511", "filename": "gcc/d/dmd/root/aav.d", "status": "added", "additions": 339, "deletions": 0, "changes": 339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Faav.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Faav.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Faav.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "ed925c8f6e3dd7d16ff4763dd415e8558a4f8252", "filename": "gcc/d/dmd/root/array.d", "status": "added", "additions": 1121, "deletions": 0, "changes": 1121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Farray.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Farray.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Farray.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "f573dcaa3eeae195e8fe76e3ba63304bf9c46509", "filename": "gcc/d/dmd/root/array.h", "status": "modified", "additions": 14, "deletions": 38, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Farray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Farray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Farray.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "f9129611dd4adb1330fac32e512515b462610210", "filename": "gcc/d/dmd/root/bitarray.d", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Fbitarray.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Fbitarray.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fbitarray.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "e773711e7f569a00f47c6fc1dc6e0bb5eacc4138", "filename": "gcc/d/dmd/root/bitarray.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Fbitarray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Fbitarray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fbitarray.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "af7b56f145c6ab1c312ab09a1ab153edeee7b15a", "filename": "gcc/d/dmd/root/checkedint.c", "status": "removed", "additions": 0, "deletions": 238, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Froot%2Fcheckedint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Froot%2Fcheckedint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fcheckedint.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "9b98742440d685dd57e7ee13c1c775dd0e6492d0", "filename": "gcc/d/dmd/root/ctfloat.d", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Fctfloat.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Fctfloat.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fctfloat.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "1221b8221885aac38978ae5511c26a5ad90f194a", "filename": "gcc/d/dmd/root/ctfloat.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Fctfloat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Fctfloat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fctfloat.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "88f20952cc9ef88bdb889398da8d631a23ac8a4f", "filename": "gcc/d/dmd/root/dcompat.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Fdcompat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Fdcompat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fdcompat.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "314b5b512c8bbd385c7088c7e39fdfe04f506af1", "filename": "gcc/d/dmd/root/file.c", "status": "removed", "additions": 0, "deletions": 258, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Froot%2Ffile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Froot%2Ffile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Ffile.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "ef6056cfed039ac5eadd8b8b214172ec09fa4ed3", "filename": "gcc/d/dmd/root/file.d", "status": "added", "additions": 814, "deletions": 0, "changes": 814, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Ffile.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Ffile.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Ffile.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "ee0d51e105c7b73dc5be4bde01d0359b61efe700", "filename": "gcc/d/dmd/root/file.h", "status": "modified", "additions": 21, "deletions": 33, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Ffile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Ffile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Ffile.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "0c5138b6ddf8f802e65e11b2625c65b5f47e6fd6", "filename": "gcc/d/dmd/root/filename.c", "status": "removed", "additions": 0, "deletions": 671, "changes": 671, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Froot%2Ffilename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Froot%2Ffilename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Ffilename.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "1e4ccb5d344f88de0283a7ca3c391799d81539d7", "filename": "gcc/d/dmd/root/filename.d", "status": "added", "additions": 1273, "deletions": 0, "changes": 1273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Ffilename.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Ffilename.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Ffilename.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "9f773b5bb99de7ef4971652e118284fb7e888958", "filename": "gcc/d/dmd/root/filename.h", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Ffilename.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Ffilename.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Ffilename.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "f484819be55e752fa966c68cd395d8daaa4e1ef0", "filename": "gcc/d/dmd/root/hash.d", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Fhash.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Fhash.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fhash.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "a845c9768e858501999fd5ba6f5c61b37888cf92", "filename": "gcc/d/dmd/root/longdouble.d", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Flongdouble.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Flongdouble.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Flongdouble.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "fb367bc1649a4b33275b28fb44bfb6df24eb01ac", "filename": "gcc/d/dmd/root/object.h", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Fobject.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Fobject.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fobject.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "7fbbfe57db32d57216a861be04a403bec79dfc96", "filename": "gcc/d/dmd/root/outbuffer.c", "status": "removed", "additions": 0, "deletions": 417, "changes": 417, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Froot%2Foutbuffer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Froot%2Foutbuffer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Foutbuffer.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "e756917b88da81da8b02220bafb331cf079655ac", "filename": "gcc/d/dmd/root/outbuffer.d", "status": "added", "additions": 720, "deletions": 0, "changes": 720, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Foutbuffer.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Foutbuffer.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Foutbuffer.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "b635373c1838956dc1349b452047abd5b13eb1f1", "filename": "gcc/d/dmd/root/outbuffer.h", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Foutbuffer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Foutbuffer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Foutbuffer.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "1bafa2070774db19a88d349d5f5becfa9160da37", "filename": "gcc/d/dmd/root/port.d", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Fport.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Fport.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fport.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "08cf66cf10e7718f410d65f8facaca446dd59348", "filename": "gcc/d/dmd/root/port.h", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Fport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Fport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fport.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "50689fe872d4578700f261109b8867bd2df0cebb", "filename": "gcc/d/dmd/root/region.d", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Fregion.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Fregion.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fregion.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "768b75d27154c1e14c321597d5bd7583b73c09ca", "filename": "gcc/d/dmd/root/rmem.c", "status": "removed", "additions": 0, "deletions": 191, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Froot%2Frmem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Froot%2Frmem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Frmem.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "198f3d01437f0c62e92064990e32b2fe544014ea", "filename": "gcc/d/dmd/root/rmem.d", "status": "added", "additions": 375, "deletions": 0, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Frmem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Frmem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Frmem.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "04d9e3fb9a2cc01008c817d01c0c211c4ddaeb73", "filename": "gcc/d/dmd/root/rmem.h", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Frmem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Frmem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Frmem.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "667ce67fb7c8a8f05aa8e12c0dca1f668cfd5968", "filename": "gcc/d/dmd/root/root.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Froot.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Froot.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Froot.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "7fee0d7297b2282e0051c064b33aa340d2c0f695", "filename": "gcc/d/dmd/root/rootobject.c", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Froot%2Frootobject.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Froot%2Frootobject.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Frootobject.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "854ec1a65bc275d999c22fa457bdc749111c2da6", "filename": "gcc/d/dmd/root/rootobject.d", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Frootobject.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Frootobject.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Frootobject.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "3957c112a0782952710abd65c3d6f1c40d7c93f3", "filename": "gcc/d/dmd/root/speller.c", "status": "removed", "additions": 0, "deletions": 231, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Froot%2Fspeller.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Froot%2Fspeller.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fspeller.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "543005b34dfc9f7ecf72db6a0fb246097c12f686", "filename": "gcc/d/dmd/root/speller.d", "status": "added", "additions": 303, "deletions": 0, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Fspeller.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Fspeller.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fspeller.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "73fe562f356ff02543061f955bc5055d24816cc0", "filename": "gcc/d/dmd/root/string.d", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Fstring.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Fstring.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fstring.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "fe14807791d628a8d45899a05c153052b006d231", "filename": "gcc/d/dmd/root/stringtable.c", "status": "removed", "additions": 0, "deletions": 196, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Froot%2Fstringtable.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Froot%2Fstringtable.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fstringtable.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "42b26e26c38ab99447e642c8f1af5dd5f92b55b1", "filename": "gcc/d/dmd/root/stringtable.d", "status": "added", "additions": 411, "deletions": 0, "changes": 411, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Fstringtable.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Froot%2Fstringtable.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fstringtable.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "7d83dd170ade10f1fdd4ab5c4cbedfd609fe73ac", "filename": "gcc/d/dmd/safe.c", "status": "removed", "additions": 0, "deletions": 168, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fsafe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fsafe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsafe.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "35734b2caa585510a47dcb9de09af1fc7c2545cb", "filename": "gcc/d/dmd/safe.d", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fsafe.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fsafe.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsafe.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "ce0892606b8b532a37bd694f93f3d76ae3e23c81", "filename": "gcc/d/dmd/sapply.c", "status": "removed", "additions": 0, "deletions": 155, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fsapply.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fsapply.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsapply.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "018b0462c84d6c19911482d2b872a87cb675dd3d", "filename": "gcc/d/dmd/sapply.d", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fsapply.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fsapply.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsapply.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "4d8c0bbef186a54f74ae1840db79b4b573ef7184", "filename": "gcc/d/dmd/scope.h", "status": "modified", "additions": 56, "deletions": 66, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fscope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fscope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fscope.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "194a3fb96611c28646c35e653c83647ab49791e5", "filename": "gcc/d/dmd/semantic2.c", "status": "removed", "additions": 0, "deletions": 430, "changes": 430, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fsemantic2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fsemantic2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsemantic2.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "7b2fa5e93cdd0db0a529ba1b4009857e6587e493", "filename": "gcc/d/dmd/semantic2.d", "status": "added", "additions": 774, "deletions": 0, "changes": 774, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fsemantic2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fsemantic2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsemantic2.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "6bd9a6d2e27c6e266aad902757d823ce474a53c6", "filename": "gcc/d/dmd/semantic3.c", "status": "removed", "additions": 0, "deletions": 1399, "changes": 1399, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fsemantic3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fsemantic3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsemantic3.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "ac2b239efafd1ea75829ecd2e4bdd1356f2d39e2", "filename": "gcc/d/dmd/semantic3.d", "status": "added", "additions": 1624, "deletions": 0, "changes": 1624, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fsemantic3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fsemantic3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsemantic3.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "661bd43134c8ee5c2d44b818ab2fcafe56a3a9db", "filename": "gcc/d/dmd/sideeffect.c", "status": "removed", "additions": 0, "deletions": 432, "changes": 432, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fsideeffect.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fsideeffect.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsideeffect.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "d238150e75ecfdb3e4e79a31fb1886661a75f9a2", "filename": "gcc/d/dmd/sideeffect.d", "status": "added", "additions": 418, "deletions": 0, "changes": 418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fsideeffect.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fsideeffect.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsideeffect.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "1f8e5122b1a72c829f686fbecff55406f6035dfc", "filename": "gcc/d/dmd/statement.c", "status": "removed", "additions": 0, "deletions": 1793, "changes": 1793, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fstatement.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fstatement.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatement.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "b49c9035d3f38f8c3344c63d7475570e6df2a726", "filename": "gcc/d/dmd/statement.d", "status": "added", "additions": 2053, "deletions": 0, "changes": 2053, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fstatement.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fstatement.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatement.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "7825762db9e09e729a0bc76924e3bf70dac40a6a", "filename": "gcc/d/dmd/statement.h", "status": "modified", "additions": 164, "deletions": 190, "changes": 354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fstatement.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fstatement.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatement.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "2f6605c43548e8733728688c460885d0fb443c4a", "filename": "gcc/d/dmd/statement_rewrite_walker.d", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fstatement_rewrite_walker.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fstatement_rewrite_walker.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatement_rewrite_walker.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "24e534e50a82d0198e442fa491f9c0e6c28123f2", "filename": "gcc/d/dmd/statementsem.c", "status": "removed", "additions": 0, "deletions": 3875, "changes": 3875, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fstatementsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fstatementsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatementsem.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "f067c91b3163d6ab4ae15b5efaffe23607f11a69", "filename": "gcc/d/dmd/statementsem.d", "status": "added", "additions": 4995, "deletions": 0, "changes": 4995, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fstatementsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fstatementsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatementsem.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "c2d0f5b65c280ac68368be33ec2871bff9f5c024", "filename": "gcc/d/dmd/staticassert.c", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fstaticassert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fstaticassert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstaticassert.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "984dc42fbab77d4229aa7f181ebbc9080fa67e3a", "filename": "gcc/d/dmd/staticassert.d", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fstaticassert.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fstaticassert.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstaticassert.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "8f880804454e56978b0c210b28a8181402e01a35", "filename": "gcc/d/dmd/staticassert.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fstaticassert.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fstaticassert.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstaticassert.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "ef0a35ff38211e4eb424e243566c13e85a25ae50", "filename": "gcc/d/dmd/staticcond.c", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fstaticcond.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Fstaticcond.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstaticcond.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "2f27414a56c7ea9063c3c5ede73179e1e68deb77", "filename": "gcc/d/dmd/staticcond.d", "status": "added", "additions": 424, "deletions": 0, "changes": 424, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fstaticcond.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fstaticcond.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstaticcond.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "bb13d7c0d065eab4a440963a8abb8a641e487241", "filename": "gcc/d/dmd/stmtstate.d", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fstmtstate.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fstmtstate.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstmtstate.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "d5b3de2c522cbb9cee86c50835b2875f2d37043f", "filename": "gcc/d/dmd/target.d", "status": "added", "additions": 438, "deletions": 0, "changes": 438, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Ftarget.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Ftarget.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftarget.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "83281a6358f58524c4598956e5eecf76e2168f86", "filename": "gcc/d/dmd/target.h", "status": "modified", "additions": 105, "deletions": 13, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftarget.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "08ce9acef99f301b3993ea1c893927d58338aa44", "filename": "gcc/d/dmd/template.h", "status": "modified", "additions": 35, "deletions": 111, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Ftemplate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Ftemplate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftemplate.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "d3e9b2390e924c1f5ae09c6605f33ae507ad9adb", "filename": "gcc/d/dmd/templateparamsem.c", "status": "removed", "additions": 0, "deletions": 116, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Ftemplateparamsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Ftemplateparamsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftemplateparamsem.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "620492fc0c7161a2ead0e98565e7901a9f85fa47", "filename": "gcc/d/dmd/templateparamsem.d", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Ftemplateparamsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Ftemplateparamsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftemplateparamsem.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "eb06beed9b64ba09637ba2cc16ea7dea2f376b8e", "filename": "gcc/d/dmd/tokens.c", "status": "removed", "additions": 0, "deletions": 476, "changes": 476, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Ftokens.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Ftokens.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftokens.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "7680fb8500b658d472b7a8742b5d9aea01c7883c", "filename": "gcc/d/dmd/tokens.d", "status": "added", "additions": 1022, "deletions": 0, "changes": 1022, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Ftokens.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Ftokens.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftokens.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "0fd6634f2ce586472e3b940202f77da5b2362208", "filename": "gcc/d/dmd/tokens.h", "status": "modified", "additions": 48, "deletions": 21, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Ftokens.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Ftokens.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftokens.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "5a9f58b79f5c39f2d074640964ba7aad57d524c8", "filename": "gcc/d/dmd/traits.c", "status": "removed", "additions": 0, "deletions": 1973, "changes": 1973, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Ftraits.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Ftraits.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftraits.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "8f968ed0dc2ecb648a00e8200f9cd284da219e43", "filename": "gcc/d/dmd/traits.d", "status": "added", "additions": 2202, "deletions": 0, "changes": 2202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Ftraits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Ftraits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftraits.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "0479d5ad045ed53cba86511e71152de0e2918e98", "filename": "gcc/d/dmd/transitivevisitor.d", "status": "added", "additions": 1207, "deletions": 0, "changes": 1207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Ftransitivevisitor.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Ftransitivevisitor.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftransitivevisitor.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "31e93c28bdb1afde082fde96604d1c5b7add0826", "filename": "gcc/d/dmd/typesem.c", "status": "removed", "additions": 0, "deletions": 1462, "changes": 1462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Ftypesem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Ftypesem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftypesem.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "ace4e423bccf25ac78fdcadd733e305f6b831fb7", "filename": "gcc/d/dmd/typesem.d", "status": "added", "additions": 4896, "deletions": 0, "changes": 4896, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Ftypesem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Ftypesem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftypesem.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "d8160f0d633a7fcd399b46cf24c469c5177da690", "filename": "gcc/d/dmd/typinf.d", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Ftypinf.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Ftypinf.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftypinf.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "f6b543590f2165602fa3c892010f768f83f2d8bb", "filename": "gcc/d/dmd/utf.c", "status": "removed", "additions": 0, "deletions": 306, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Futf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Futf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Futf.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "1125c21212254004d46f0f8df145b3ea382d9ddb", "filename": "gcc/d/dmd/utf.d", "status": "added", "additions": 561, "deletions": 0, "changes": 561, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Futf.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Futf.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Futf.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "c9e632234efdf7c5dbb49072c0ce7fa0fc264e8c", "filename": "gcc/d/dmd/utils.c", "status": "removed", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fdmd%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Futils.c?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "600521fbd495db0e159948a5bc5ab9c549661355", "filename": "gcc/d/dmd/utils.d", "status": "added", "additions": 298, "deletions": 0, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Futils.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Futils.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Futils.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "6c5e2f0f236eb8cb3a5aa53884ca2064c325ac32", "filename": "gcc/d/dmd/version.h", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fversion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fversion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fversion.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "8b9c01253de5631d3997ed818193acddaae2df87", "filename": "gcc/d/dmd/visitor.d", "status": "added", "additions": 254, "deletions": 0, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fvisitor.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fvisitor.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fvisitor.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "e61f16d7c8bbfaeb97f74db107bc793a36bfa7d4", "filename": "gcc/d/dmd/visitor.h", "status": "modified", "additions": 267, "deletions": 214, "changes": 481, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fvisitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fdmd%2Fvisitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fvisitor.h?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "31680564bdd7911927b831f74894951eb391523c", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 117, "deletions": 150, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "740a020321c4d6f48ed0a3fc4c4a3618264378ea", "filename": "gcc/d/imports.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fimports.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fimports.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fimports.cc?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "b14b0ca5111e06d1256f0624e57c0dcd86ae4a67", "filename": "gcc/d/intrinsics.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fintrinsics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fintrinsics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fintrinsics.cc?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "1f350f3c236324fe96a447574b9578b606b3f85f", "filename": "gcc/d/intrinsics.def", "status": "modified", "additions": 48, "deletions": 49, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fintrinsics.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fintrinsics.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fintrinsics.def?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "f7f90fb08c32fe8f39663145de6cacbd744e64ae", "filename": "gcc/d/lang.opt", "status": "modified", "additions": 152, "deletions": 13, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Flang.opt?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "06eb5ae3424c38c49fc33dc7973f2b9a609d7f50", "filename": "gcc/d/modules.cc", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fmodules.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fmodules.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fmodules.cc?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "fdff6db06260bef21a87097d3644d051890bef90", "filename": "gcc/d/runtime.def", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fruntime.def?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "55d63f89cb7915783fc942d75b34fb722faff3e2", "filename": "gcc/d/toir.cc", "status": "modified", "additions": 17, "deletions": 84, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Ftoir.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Ftoir.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftoir.cc?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "065f6b3de803039373132c88539f911fbb5c64ff", "filename": "gcc/d/typeinfo.cc", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Ftypeinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Ftypeinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftypeinfo.cc?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "db500ee2efedf65783d27acee3b2631c0dd166be", "filename": "gcc/d/types.cc", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fd%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftypes.cc?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "0dd41eeaebe5614209ebd8ccf144aab405773fdc", "filename": "gcc/d/verstr.h", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fverstr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f60112edcb85b459e60f66c44a55138b1cef49/gcc%2Fd%2Fverstr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fverstr.h?ref=b3f60112edcb85b459e60f66c44a55138b1cef49"}, {"sha": "d2c5cbf3f2a409eddf1757a43e700cff9bd8d1ed", "filename": "gcc/po/EXCLUDES", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fpo%2FEXCLUDES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Fpo%2FEXCLUDES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpo%2FEXCLUDES?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "83d189a6adf9b2de687e9ce344becfc59d72c154", "filename": "gcc/testsuite/gdc.dg/Wcastresult2.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2FWcastresult2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2FWcastresult2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2FWcastresult2.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "1b249ee7b35e9984507f2cd58bd936bb6d1cac5d", "filename": "gcc/testsuite/gdc.dg/asm1.d", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fasm1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fasm1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fasm1.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "5b86e3564ef403061119aff3ce07c5cacf570491", "filename": "gcc/testsuite/gdc.dg/asm2.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fasm2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fasm2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fasm2.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "d792b2474becc54f3a7e0d335380c8e88af8a1e8", "filename": "gcc/testsuite/gdc.dg/asm3.d", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fasm3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fasm3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fasm3.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "93e11fa0cbce309c69b3700823765a42b630c730", "filename": "gcc/testsuite/gdc.dg/gdc282.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fgdc282.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fgdc282.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fgdc282.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "aedef60c6b43e79526dc901119b2dfcb124ab72e", "filename": "gcc/testsuite/gdc.dg/imports/gdc170.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fimports%2Fgdc170.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fimports%2Fgdc170.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fimports%2Fgdc170.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "dca40d2cf69c217ad6affd643e585be6017f16cf", "filename": "gcc/testsuite/gdc.dg/intrinsics.d", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fintrinsics.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fintrinsics.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fintrinsics.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "8b337a4cf19553cd87fab07d796a351f455af7c2", "filename": "gcc/testsuite/gdc.dg/pr101672.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fpr101672.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fpr101672.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fpr101672.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "62b79941f2063e77b48e602c5a4e0c38e534b2b4", "filename": "gcc/testsuite/gdc.dg/pr90650a.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fpr90650a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fpr90650a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fpr90650a.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "11a0225948142f446de33ed582619772430f824d", "filename": "gcc/testsuite/gdc.dg/pr90650b.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fpr90650b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fpr90650b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fpr90650b.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "d0cb5569e46c41312e221849e9c89e579f32abe1", "filename": "gcc/testsuite/gdc.dg/pr94777a.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fpr94777a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fpr94777a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fpr94777a.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "9b725c052c37c4ed930505b313b379d0a4fce7dd", "filename": "gcc/testsuite/gdc.dg/pr94777c.d", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fpr94777c.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fpr94777c.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fpr94777c.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "ba0adeac521922d1fd17dd5cac5d3a0ded46c85f", "filename": "gcc/testsuite/gdc.dg/pr95250.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fpr95250.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fpr95250.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fpr95250.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "ae79d568ec6cab892ae49c6cc5c889e6aa307812", "filename": "gcc/testsuite/gdc.dg/pr96156b.d", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fpr96156b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fpr96156b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fpr96156b.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "8f48cbdc1b48c1644f724729eaadf9a1233e0789", "filename": "gcc/testsuite/gdc.dg/pr96157c.d", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fpr96157c.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fpr96157c.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fpr96157c.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "348da1bcb3d505fdc81a6f56082ce875980740d2", "filename": "gcc/testsuite/gdc.dg/pr96869.d", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fpr96869.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fpr96869.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fpr96869.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "0dff142a6ef41abdfe760c0c7a8d51a8808109ce", "filename": "gcc/testsuite/gdc.dg/pr98277.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fpr98277.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fpr98277.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fpr98277.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "0cc83aca064fe21dfa86de65ac69714754c60b63", "filename": "gcc/testsuite/gdc.dg/pr98457.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fpr98457.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fpr98457.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fpr98457.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "b25b99e3e1d04aedf6295a430dff78eeea411723", "filename": "gcc/testsuite/gdc.dg/simd1.d", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fsimd1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fsimd1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fsimd1.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "0fb391cc0577a821b165d11c166ecd780c6de1f2", "filename": "gcc/testsuite/gdc.dg/simd2a.d", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fsimd2a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fsimd2a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fsimd2a.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}, {"sha": "41a4eb3c34a8df8832e2ad5600bfa3676d47fa77", "filename": "gcc/testsuite/gdc.dg/simd2b.d", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fsimd2b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fee5ec362f7a243f459e6378fd49dfc89dc9fb5/gcc%2Ftestsuite%2Fgdc.dg%2Fsimd2b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fsimd2b.d?ref=5fee5ec362f7a243f459e6378fd49dfc89dc9fb5"}]}