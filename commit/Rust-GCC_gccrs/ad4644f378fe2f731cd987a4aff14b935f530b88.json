{"sha": "ad4644f378fe2f731cd987a4aff14b935f530b88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQ0NjQ0ZjM3OGZlMmY3MzFjZDk4N2E0YWZmMTRiOTM1ZjUzMGI4OA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-09-18T07:38:32Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-09-18T07:38:32Z"}, "message": "[x86] Tweak testcases for PR82361\n\ngcc/testsuite/gcc.target/i386/pr82361-[12].c check whether we\ncan optimise away a 32-to-64-bit zero extension of a 32-bit\ndivision or modulus result.  Currently this fails for the modulus\npart of f1 and f2 in pr82361-1.c:\n\n/* FIXME: We are still not able to optimize the modulo in f1/f2, only manage\n   one.  */\n/* { dg-final { scan-assembler-times \"movl\\t%edx\" 2 } } */\n\npr82361-2.c instead expects no failures:\n\n/* Ditto %edx to %rdx zero extensions.  */\n/* { dg-final { scan-assembler-not \"movl\\t%edx, %edx\" } } */\n\nBut we actually get the same zero-extensions for f1 and f2 in pr82361-2.c.\nThe reason they don't trigger a failure is that the RA allocates the\nasm input for \"d\" to %rdi rather than %rdx, so we have:\n\n\tmovl\t%rdx, %rdi\n\ninstead of:\n\n\tmovl\t%rdx, %rdx\n\nFor the tests to work as expected, I think they have to force \"c\" and\n\"d\" to be %rax and %rdx respectively.  We then see the same failure in\npr82361-2.c as for pr82361-1.c (but doubled, due to the 8-bit division\npath).\n\n2019-09-18  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/testsuite/\n\t* gcc.target/i386/pr82361-1.c (f1, f2, f3, f4, f5, f6): Force\n\t\"c\" to be in %rax and \"d\" to be in %rdx.\n\t* gcc.target/i386/pr82361-2.c: Expect 4 instances of \"movl\\t%edx\".\n\nFrom-SVN: r275836", "tree": {"sha": "e1ab6bf98f498255409c3b8f4e0d0b004e09dc63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1ab6bf98f498255409c3b8f4e0d0b004e09dc63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad4644f378fe2f731cd987a4aff14b935f530b88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad4644f378fe2f731cd987a4aff14b935f530b88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad4644f378fe2f731cd987a4aff14b935f530b88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad4644f378fe2f731cd987a4aff14b935f530b88/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6a6341917f9e6d8cf500c24883e543caf3b6af8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a6341917f9e6d8cf500c24883e543caf3b6af8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a6341917f9e6d8cf500c24883e543caf3b6af8b"}], "stats": {"total": 31, "additions": 19, "deletions": 12}, "files": [{"sha": "cc27ca318c222cbf6870f3ef63f692906d356bab", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad4644f378fe2f731cd987a4aff14b935f530b88/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad4644f378fe2f731cd987a4aff14b935f530b88/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ad4644f378fe2f731cd987a4aff14b935f530b88", "patch": "@@ -1,3 +1,9 @@\n+2019-09-18  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.target/i386/pr82361-1.c (f1, f2, f3, f4, f5, f6): Force\n+\t\"c\" to be in %rax and \"d\" to be in %rdx.\n+\t* gcc.target/i386/pr82361-2.c: Expect 4 instances of \"movl\\t%edx\".\n+\n 2019-19-17  Christophe Lyon  <christophe.lyon@st.com>\n \n \t* lib/target-supports.exp"}, {"sha": "dec1792aecbf5556d0c46008a8fc93404736a33d", "filename": "gcc/testsuite/gcc.target/i386/pr82361-1.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad4644f378fe2f731cd987a4aff14b935f530b88/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82361-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad4644f378fe2f731cd987a4aff14b935f530b88/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82361-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82361-1.c?ref=ad4644f378fe2f731cd987a4aff14b935f530b88", "patch": "@@ -4,50 +4,50 @@\n /* We should be able to optimize all %eax to %rax zero extensions, because\n    div and idiv instructions with 32-bit operands zero-extend both results.   */\n /* { dg-final { scan-assembler-not \"movl\\t%eax, %eax\" } } */\n-/* FIXME: We are still not able to optimize the modulo in f1/f2, only manage\n-   one.  */\n+/* FIXME: The compiler does not merge zero-extension to the modulo part\n+   of f1 and f2.  */\n /* { dg-final { scan-assembler-times \"movl\\t%edx\" 2 } } */\n \n void\n f1 (unsigned int a, unsigned int b)\n {\n-  unsigned long long c = a / b;\n-  unsigned long long d = a % b;\n+  register unsigned long long c asm (\"rax\") = a / b;\n+  register unsigned long long d asm (\"rdx\") = a % b;\n   asm volatile (\"\" : : \"r\" (c), \"r\" (d));\n }\n \n void\n f2 (int a, int b)\n {\n-  unsigned long long c = (unsigned int) (a / b);\n-  unsigned long long d = (unsigned int) (a % b);\n+  register unsigned long long c asm (\"rax\") = (unsigned int) (a / b);\n+  register unsigned long long d asm (\"rdx\") = (unsigned int) (a % b);\n   asm volatile (\"\" : : \"r\" (c), \"r\" (d));\n }\n \n void\n f3 (unsigned int a, unsigned int b)\n {\n-  unsigned long long c = a / b;\n+  register unsigned long long c asm (\"rax\") = a / b;\n   asm volatile (\"\" : : \"r\" (c));\n }\n \n void\n f4 (int a, int b)\n {\n-  unsigned long long c = (unsigned int) (a / b);\n+  register unsigned long long c asm (\"rax\") = (unsigned int) (a / b);\n   asm volatile (\"\" : : \"r\" (c));\n }\n \n void\n f5 (unsigned int a, unsigned int b)\n {\n-  unsigned long long d = a % b;\n+  register unsigned long long d asm (\"rdx\") = a % b;\n   asm volatile (\"\" : : \"r\" (d));\n }\n \n void\n f6 (int a, int b)\n {\n-  unsigned long long d = (unsigned int) (a % b);\n+  register unsigned long long d asm (\"rdx\") = (unsigned int) (a % b);\n   asm volatile (\"\" : : \"r\" (d));\n }"}, {"sha": "2d87de182ea80cffff2c967d3405806a1913350a", "filename": "gcc/testsuite/gcc.target/i386/pr82361-2.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad4644f378fe2f731cd987a4aff14b935f530b88/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82361-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad4644f378fe2f731cd987a4aff14b935f530b88/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82361-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82361-2.c?ref=ad4644f378fe2f731cd987a4aff14b935f530b88", "patch": "@@ -4,7 +4,8 @@\n /* We should be able to optimize all %eax to %rax zero extensions, because\n    div and idiv instructions with 32-bit operands zero-extend both results.   */\n /* { dg-final { scan-assembler-not \"movl\\t%eax, %eax\" } } */\n-/* Ditto %edx to %rdx zero extensions.  */\n-/* { dg-final { scan-assembler-not \"movl\\t%edx, %edx\" } } */\n+/* FIXME: The compiler does not merge zero-extension to the modulo part\n+   of f1 and f2.  */\n+/* { dg-final { scan-assembler-times \"movl\\t%edx\" 4 } } */\n \n #include \"pr82361-1.c\""}]}