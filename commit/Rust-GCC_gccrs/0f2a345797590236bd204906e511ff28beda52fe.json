{"sha": "0f2a345797590236bd204906e511ff28beda52fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGYyYTM0NTc5NzU5MDIzNmJkMjA0OTA2ZTUxMWZmMjhiZWRhNTJmZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2002-04-19T21:09:16Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2002-04-19T21:09:16Z"}, "message": "re PR rtl-optimization/3756 (gcc wishlist: arithmetic right shift for ternary operator)\n\n\tPR optimization/3756\n\t* config/i386/i386.c (ix86_expand_int_movcc): Optimize\n\tx = ((int) y < 0) ? cst1 : cst2.\n\nFrom-SVN: r52539", "tree": {"sha": "423689570f0515c9ab3975c78ddffc115a639b7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/423689570f0515c9ab3975c78ddffc115a639b7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f2a345797590236bd204906e511ff28beda52fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f2a345797590236bd204906e511ff28beda52fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f2a345797590236bd204906e511ff28beda52fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f2a345797590236bd204906e511ff28beda52fe/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ce5e43d03eab3681671efc777b479a5855dc5906", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce5e43d03eab3681671efc777b479a5855dc5906", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce5e43d03eab3681671efc777b479a5855dc5906"}], "stats": {"total": 118, "additions": 105, "deletions": 13}, "files": [{"sha": "b9dee8f49bcc8812a3db045074b1fb670ac9abee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f2a345797590236bd204906e511ff28beda52fe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f2a345797590236bd204906e511ff28beda52fe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0f2a345797590236bd204906e511ff28beda52fe", "patch": "@@ -1,3 +1,9 @@\n+2002-04-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR optimization/3756\n+\t* config/i386/i386.c (ix86_expand_int_movcc): Optimize\n+\tx = ((int) y < 0) ? cst1 : cst2.\n+\n 2002-04-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/6358"}, {"sha": "41ec025c750e97617f2ecddab954dd75d2f03e5a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 99, "deletions": 13, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f2a345797590236bd204906e511ff28beda52fe/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f2a345797590236bd204906e511ff28beda52fe/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=0f2a345797590236bd204906e511ff28beda52fe", "patch": "@@ -8131,6 +8131,61 @@ ix86_expand_int_movcc (operands)\n \t      code = reverse_condition (code);\n \t    }\n \t}\n+\n+      compare_code = NIL;\n+      if (GET_MODE_CLASS (GET_MODE (ix86_compare_op0)) == MODE_INT\n+\t  && GET_CODE (ix86_compare_op1) == CONST_INT)\n+\t{\n+\t  if (ix86_compare_op1 == const0_rtx\n+\t      && (code == LT || code == GE))\n+\t    compare_code = code;\n+\t  else if (ix86_compare_op1 == constm1_rtx)\n+\t    {\n+\t      if (code == LE)\n+\t\tcompare_code = LT;\n+\t      else if (code == GT)\n+\t\tcompare_code = GE;\n+\t    }\n+\t}\n+\n+      /* Optimize dest = (op0 < 0) ? -1 : cf.  */\n+      if (compare_code != NIL\n+\t  && GET_MODE (ix86_compare_op0) == GET_MODE (out)\n+\t  && (cf == -1 || ct == -1))\n+\t{\n+\t  /* If lea code below could be used, only optimize\n+\t     if it results in a 2 insn sequence.  */\n+\n+\t  if (! (diff == 1 || diff == 2 || diff == 4 || diff == 8\n+\t\t || diff == 3 || diff == 5 || diff == 9)\n+\t      || (compare_code == LT && ct == -1)\n+\t      || (compare_code == GE && cf == -1))\n+\t    {\n+\t      /*\n+\t       * notl op1\t(if necessary)\n+\t       * sarl $31, op1\n+\t       * orl cf, op1\n+\t       */\n+\t      if (ct != -1)\n+\t\t{\n+\t\t  cf = ct;\n+\t  \t  ct = -1;\n+\t\t  code = reverse_condition (code);\n+\t\t}\n+\n+\t      out = emit_store_flag (out, code, ix86_compare_op0,\n+\t\t\t\t     ix86_compare_op1, VOIDmode, 0, -1);\n+\n+\t      out = expand_simple_binop (mode, IOR,\n+\t\t\t\t\t out, GEN_INT (cf),\n+\t\t\t\t\t out, 1, OPTAB_DIRECT);\n+\t      if (out != operands[0])\n+\t\temit_move_insn (operands[0], out);\n+\n+\t      return 1; /* DONE */\n+\t    }\n+\t}\n+\n       if ((diff == 1 || diff == 2 || diff == 4 || diff == 8\n \t   || diff == 3 || diff == 5 || diff == 9)\n \t  && (mode != DImode || x86_64_sign_extended_value (GEN_INT (cf))))\n@@ -8223,27 +8278,58 @@ ix86_expand_int_movcc (operands)\n \t      ct = cf;\n \t      cf = 0;\n \t      if (FLOAT_MODE_P (GET_MODE (ix86_compare_op0)))\n+\t\t/* We may be reversing unordered compare to normal compare,\n+\t\t   that is not valid in general (we may convert non-trapping\n+\t\t   condition to trapping one), however on i386 we currently\n+\t\t   emit all comparisons unordered.  */\n+\t\tcode = reverse_condition_maybe_unordered (code);\n+\t      else\n+\t\t{\n+\t\t  code = reverse_condition (code);\n+\t\t  if (compare_code != NIL)\n+\t\t    compare_code = reverse_condition (compare_code);\n+\t\t}\n+\t    }\n+\n+\t  if (compare_code != NIL)\n+\t    {\n+\t      /* notl op1\t(if needed)\n+\t\t sarl $31, op1\n+\t\t andl (cf-ct), op1\n+\t \t addl ct, op1\n+\n+\t\t For x < 0 (resp. x <= -1) there will be no notl,\n+\t\t so if possible swap the constants to get rid of the\n+\t\t complement.\n+\t\t True/false will be -1/0 while code below (store flag\n+\t\t followed by decrement) is 0/-1, so the constants need\n+\t\t to be exchanged once more.  */\n+\n+\t      if (compare_code == GE || !cf)\n \t\t{\n-\t\t  /* We may be reversing unordered compare to normal compare,\n-\t\t     that is not valid in general (we may convert non-trapping\n-\t\t     condition to trapping one), however on i386 we currently\n-\t\t     emit all comparisons unordered.  */\n-\t\t  compare_code = reverse_condition_maybe_unordered (compare_code);\n-\t\t  code = reverse_condition_maybe_unordered (code);\n+\t  \t  code = reverse_condition (code);\n+\t\t  compare_code = LT;\n \t\t}\n \t      else\n \t\t{\n-\t\t  compare_code = reverse_condition (compare_code);\n-\t\t  code = reverse_condition (code);\n+\t\t  HOST_WIDE_INT tmp = cf;\n+\t  \t  cf = ct;\n+\t\t  ct = tmp;\n \t\t}\n+\n+\t      out = emit_store_flag (out, code, ix86_compare_op0,\n+\t\t\t\t     ix86_compare_op1, VOIDmode, 0, -1);\n \t    }\n+\t  else\n+\t    {\n+\t      out = emit_store_flag (out, code, ix86_compare_op0,\n+\t\t\t\t     ix86_compare_op1, VOIDmode, 0, 1);\n \n-\t  out = emit_store_flag (out, code, ix86_compare_op0,\n-\t\t\t\t ix86_compare_op1, VOIDmode, 0, 1);\n+\t      out = expand_simple_binop (mode, PLUS,\n+\t\t\t\t\t out, constm1_rtx,\n+\t\t\t\t\t out, 1, OPTAB_DIRECT);\n+\t    }\n \n-\t  out = expand_simple_binop (mode, PLUS,\n-\t\t\t\t     out, constm1_rtx,\n-\t\t\t\t     out, 1, OPTAB_DIRECT);\n \t  out = expand_simple_binop (mode, AND,\n \t\t\t\t     out,\n \t\t\t\t     gen_int_mode (cf - ct, mode),"}]}