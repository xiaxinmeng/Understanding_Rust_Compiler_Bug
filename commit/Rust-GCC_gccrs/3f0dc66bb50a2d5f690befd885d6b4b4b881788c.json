{"sha": "3f0dc66bb50a2d5f690befd885d6b4b4b881788c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2YwZGM2NmJiNTBhMmQ1ZjY5MGJlZmQ4ODVkNmI0YjRiODgxNzg4Yw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2006-01-29T22:23:10Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2006-01-29T22:23:10Z"}, "message": "Revert\n\n\t2005-11-09  Eric Botcazou  <ebotcazou@adacore.com>\n\t* tree.c (build_qualified_type): Chain the new type to the original\n\ttype's TYPE_NEXT_PTR_TO or TYPE_NEXT_REF_TO linked lists if it is\n\ta POINTER_TYPE or a REFERENCE_TYPE respectively.\n\t(build_pointer_type_for_mode): Only return unqualified types.\n\t(build_reference_type_for_mode): Likewise.\n\nFrom-SVN: r110382", "tree": {"sha": "3be7cb2f6188c3efff67ae9aa40c8dd9a65d151e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3be7cb2f6188c3efff67ae9aa40c8dd9a65d151e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f0dc66bb50a2d5f690befd885d6b4b4b881788c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f0dc66bb50a2d5f690befd885d6b4b4b881788c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f0dc66bb50a2d5f690befd885d6b4b4b881788c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f0dc66bb50a2d5f690befd885d6b4b4b881788c/comments", "author": null, "committer": null, "parents": [{"sha": "dd9cf77f3c53067675eb5d0f6c2b3228868c3925", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd9cf77f3c53067675eb5d0f6c2b3228868c3925", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd9cf77f3c53067675eb5d0f6c2b3228868c3925"}], "stats": {"total": 41, "additions": 17, "deletions": 24}, "files": [{"sha": "de75a3b5c7b931568f485f88e663ea15b698938f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f0dc66bb50a2d5f690befd885d6b4b4b881788c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f0dc66bb50a2d5f690befd885d6b4b4b881788c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3f0dc66bb50a2d5f690befd885d6b4b4b881788c", "patch": "@@ -1,3 +1,14 @@\n+2006-01-29  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tRevert\n+\n+\t2005-11-09  Eric Botcazou  <ebotcazou@adacore.com>\n+\t* tree.c (build_qualified_type): Chain the new type to the original\n+\ttype's TYPE_NEXT_PTR_TO or TYPE_NEXT_REF_TO linked lists if it is\n+\ta POINTER_TYPE or a REFERENCE_TYPE respectively.\n+\t(build_pointer_type_for_mode): Only return unqualified types.\n+\t(build_reference_type_for_mode): Likewise.\n+\n 2006-01-29  Gabriel Dos Reis  <gdr@integgrable-solutions.net>\n \n \t* configure.ac (cxx_compat_warn): Set if -Wc++-compat is supported."}, {"sha": "456b3e1d2d5508e720c4052b79f749695f495a2c", "filename": "gcc/tree.c", "status": "modified", "additions": 6, "deletions": 24, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f0dc66bb50a2d5f690befd885d6b4b4b881788c/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f0dc66bb50a2d5f690befd885d6b4b4b881788c/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=3f0dc66bb50a2d5f690befd885d6b4b4b881788c", "patch": "@@ -3738,20 +3738,6 @@ build_qualified_type (tree type, int type_quals)\n     {\n       t = build_variant_type_copy (type);\n       set_type_quals (t, type_quals);\n-\n-      /* If it's a pointer type, the new variant points to the same type.  */\n-      if (TREE_CODE (type) == POINTER_TYPE)\n-\t{\n-\t  TYPE_NEXT_PTR_TO (t) = TYPE_NEXT_PTR_TO (type);\n-\t  TYPE_NEXT_PTR_TO (type) = t;\n-\t}\n-\n-      /* Same for a reference type.  */\n-      else if (TREE_CODE (type) == REFERENCE_TYPE)\n-\t{\n-\t  TYPE_NEXT_REF_TO (t) = TYPE_NEXT_REF_TO (type);\n-\t  TYPE_NEXT_REF_TO (type) = t;\n-\t}\n     }\n \n   return t;\n@@ -4867,12 +4853,10 @@ build_pointer_type_for_mode (tree to_type, enum machine_mode mode,\n       && TREE_CODE (TYPE_POINTER_TO (to_type)) != POINTER_TYPE)\n     return TYPE_POINTER_TO (to_type);\n \n-  /* First, if we already have an unqualified type for pointers to TO_TYPE\n-     and it's the proper mode, use it.  */\n+  /* First, if we already have a type for pointers to TO_TYPE and it's\n+     the proper mode, use it.  */\n   for (t = TYPE_POINTER_TO (to_type); t; t = TYPE_NEXT_PTR_TO (t))\n-    if (TYPE_MODE (t) == mode\n-\t&& !TYPE_QUALS (t)\n-\t&& TYPE_REF_CAN_ALIAS_ALL (t) == can_alias_all)\n+    if (TYPE_MODE (t) == mode && TYPE_REF_CAN_ALIAS_ALL (t) == can_alias_all)\n       return t;\n \n   t = make_node (POINTER_TYPE);\n@@ -4918,12 +4902,10 @@ build_reference_type_for_mode (tree to_type, enum machine_mode mode,\n       && TREE_CODE (TYPE_REFERENCE_TO (to_type)) != REFERENCE_TYPE)\n     return TYPE_REFERENCE_TO (to_type);\n \n-  /* First, if we already have an unqualified type for references to TO_TYPE\n-     and it's the proper mode, use it.  */\n+  /* First, if we already have a type for pointers to TO_TYPE and it's\n+     the proper mode, use it.  */\n   for (t = TYPE_REFERENCE_TO (to_type); t; t = TYPE_NEXT_REF_TO (t))\n-    if (TYPE_MODE (t) == mode\n-\t&& !TYPE_QUALS (t)\n-\t&& TYPE_REF_CAN_ALIAS_ALL (t) == can_alias_all)\n+    if (TYPE_MODE (t) == mode && TYPE_REF_CAN_ALIAS_ALL (t) == can_alias_all)\n       return t;\n \n   t = make_node (REFERENCE_TYPE);"}]}