{"sha": "7fd01431a32dd01cde21e6c35f2af826fd01f487", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ZkMDE0MzFhMzJkZDAxY2RlMjFlNmMzNWYyYWY4MjZmZDAxZjQ4Nw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-11-15T23:37:55Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-11-15T23:37:55Z"}, "message": "(expand_abs): New function, code moved from expand_expr.\n\nFrom-SVN: r8444", "tree": {"sha": "b25c8a1b9ceb9e2b506ce5b67d16a717da2f1e2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b25c8a1b9ceb9e2b506ce5b67d16a717da2f1e2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7fd01431a32dd01cde21e6c35f2af826fd01f487", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fd01431a32dd01cde21e6c35f2af826fd01f487", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fd01431a32dd01cde21e6c35f2af826fd01f487", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fd01431a32dd01cde21e6c35f2af826fd01f487/comments", "author": null, "committer": null, "parents": [{"sha": "2e5ec6cf3b1256e2ded7f8f5f8376b5c79dbcd74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e5ec6cf3b1256e2ded7f8f5f8376b5c79dbcd74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e5ec6cf3b1256e2ded7f8f5f8376b5c79dbcd74"}], "stats": {"total": 84, "additions": 84, "deletions": 0}, "files": [{"sha": "db68da8f9fb4943ef02222e1b5f320b396bbccf8", "filename": "gcc/optabs.c", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fd01431a32dd01cde21e6c35f2af826fd01f487/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fd01431a32dd01cde21e6c35f2af826fd01f487/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=7fd01431a32dd01cde21e6c35f2af826fd01f487", "patch": "@@ -2051,6 +2051,90 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n    MODE is the mode of the operand; the mode of the result is\n    different but can be deduced from MODE.\n \n+   UNSIGNEDP is relevant if extension is needed.  */\n+\n+rtx\n+expand_abs (mode, op0, target, unsignedp, safe)\n+     enum machine_mode mode;\n+     rtx op0;\n+     rtx target;\n+     int unsignedp;\n+     int safe;\n+{\n+  rtx temp, op1;\n+\n+  /* First try to do it with a special abs instruction.  */\n+  temp = expand_unop (mode, abs_optab, op0, target, 0);\n+  if (temp != 0)\n+    return temp;\n+\n+  /* If this machine has expensive jumps, we can do integer absolute\n+     value of X as (((signed) x >> (W-1)) ^ x) - ((signed) x >> (W-1)),\n+     where W is the width of MODE.  */\n+\n+  if (GET_MODE_CLASS (mode) == MODE_INT && BRANCH_COST >= 2)\n+    {\n+      rtx extended = expand_shift (RSHIFT_EXPR, mode, op0,\n+\t\t\t\t   size_int (GET_MODE_BITSIZE (mode) - 1),\n+\t\t\t\t   NULL_RTX, 0);\n+\n+      temp = expand_binop (mode, xor_optab, extended, op0, target, 0,\n+\t\t\t   OPTAB_LIB_WIDEN);\n+      if (temp != 0)\n+\ttemp = expand_binop (mode, sub_optab, temp, extended, target, 0,\n+\t\t\t     OPTAB_LIB_WIDEN);\n+\n+      if (temp != 0)\n+\treturn temp;\n+    }\n+\n+  /* If that does not win, use conditional jump and negate.  */\n+  op1 = gen_label_rtx ();\n+  if (target == 0 || ! safe\n+      || GET_MODE (target) != mode\n+      || (GET_CODE (target) == MEM && MEM_VOLATILE_P (target))\n+      || (GET_CODE (target) == REG\n+\t  && REGNO (target) < FIRST_PSEUDO_REGISTER))\n+    target = gen_reg_rtx (mode);\n+\n+  emit_move_insn (target, op0);\n+  NO_DEFER_POP;\n+\n+  /* If this mode is an integer too wide to compare properly,\n+     compare word by word.  Rely on CSE to optimize constant cases.  */\n+  if (GET_MODE_CLASS (mode) == MODE_INT && ! can_compare_p (mode))\n+    do_jump_by_parts_greater_rtx (mode, 0, target, const0_rtx, \n+\t\t\t\t  NULL_RTX, op1);\n+  else\n+    {\n+      temp = compare_from_rtx (target, CONST0_RTX (mode), GE, 0, mode,\n+\t\t\t       NULL_RTX, 0);\n+      if (temp == const1_rtx)\n+\treturn target;\n+      else if (temp != const0_rtx)\n+\t{\n+\t  if (bcc_gen_fctn[(int) GET_CODE (temp)] != 0)\n+\t    emit_jump_insn ((*bcc_gen_fctn[(int) GET_CODE (temp)]) (op1));\n+\t  else\n+\t    abort ();\n+\t}\n+    }\n+\n+  op0 = expand_unop (mode, neg_optab, target, target, 0);\n+  if (op0 != target)\n+    emit_move_insn (target, op0);\n+  emit_label (op1);\n+  OK_DEFER_POP;\n+  return target;\n+}\n+\f\n+/* Emit code to compute the absolute value of OP0, with result to\n+   TARGET if convenient.  (TARGET may be 0.)  The return value says\n+   where the result actually is to be found.\n+\n+   MODE is the mode of the operand; the mode of the result is\n+   different but can be deduced from MODE.\n+\n    UNSIGNEDP is relevant for complex integer modes.  */\n \n rtx"}]}