{"sha": "c7256c8260afa313e019fd531574ad33ec49b9f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzcyNTZjODI2MGFmYTMxM2UwMTlmZDUzMTU3NGFkMzNlYzQ5YjlmNg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2020-12-26T16:44:24Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2020-12-26T16:44:24Z"}, "message": "Fortran: Correction to recent patch in light of comments [PR98022].\n\n2020-12-26  Paul Thomas  <pault@gcc.gnu.org>\n\ngcc/fortran\n\tPR fortran/98022\n\t* data.c (gfc_assign_data_value): Throw an error for inquiry\n\treferences. Follow with corrected code that would provide the\n\texpected result and provides clean error recovery.\n\ngcc/testsuite/\n\tPR fortran/98022\n\t* gfortran.dg/data_inquiry_ref.f90: Change to dg-compile and\n\tadd errors for inquiry references.", "tree": {"sha": "268a0bf07007205e5b2445f2f53133891f887fee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/268a0bf07007205e5b2445f2f53133891f887fee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7256c8260afa313e019fd531574ad33ec49b9f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7256c8260afa313e019fd531574ad33ec49b9f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7256c8260afa313e019fd531574ad33ec49b9f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7256c8260afa313e019fd531574ad33ec49b9f6/comments", "author": null, "committer": null, "parents": [{"sha": "0175d45d14b1f9ebc4c15ea5bafcda655c37fc35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0175d45d14b1f9ebc4c15ea5bafcda655c37fc35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0175d45d14b1f9ebc4c15ea5bafcda655c37fc35"}], "stats": {"total": 93, "additions": 61, "deletions": 32}, "files": [{"sha": "07fa1c5e9ba1ecf315ac05389ebeace3b9051d55", "filename": "gcc/fortran/data.c", "status": "modified", "additions": 43, "deletions": 20, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7256c8260afa313e019fd531574ad33ec49b9f6/gcc%2Ffortran%2Fdata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7256c8260afa313e019fd531574ad33ec49b9f6/gcc%2Ffortran%2Fdata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdata.c?ref=c7256c8260afa313e019fd531574ad33ec49b9f6", "patch": "@@ -221,11 +221,14 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index,\n   gfc_ref *ref;\n   gfc_expr *init;\n   gfc_expr *expr = NULL;\n+  gfc_expr *rexpr;\n   gfc_constructor *con;\n   gfc_constructor *last_con;\n   gfc_symbol *symbol;\n   gfc_typespec *last_ts;\n   mpz_t offset;\n+  const char *msg = \"F18(R841): data-implied-do object at %L is neither an \"\n+\t\t    \"array-element nor a scalar-structure-component\";\n \n   symbol = lvalue->symtree->n.sym;\n   init = symbol->value;\n@@ -466,21 +469,38 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index,\n \n \tcase REF_INQUIRY:\n \n+\t  /* After some discussion on clf it was determined that the following\n+\t     violates F18(R841). If the error is removed, the expected result\n+\t     is obtained. Leaving the code in place ensures a clean error\n+\t     recovery.  */\n+\t  gfc_error (msg, &lvalue->where);\n+\n \t  /* This breaks with the other reference types in that the output\n \t     constructor has to be of type COMPLEX, whereas the lvalue is\n \t     of type REAL.  The rvalue is copied to the real or imaginary\n-\t     part as appropriate.  */\n+\t     part as appropriate.  In addition, for all except scalar\n+\t     complex variables, a complex expression has to provided, where\n+\t     the constructor does not have it, and the expression modified\n+\t     with a new value for the real or imaginary part.  */\n \t  gcc_assert (ref->next == NULL && last_ts->type == BT_COMPLEX);\n-\t  expr = gfc_copy_expr (rvalue);\n-\t  if (!gfc_compare_types (&lvalue->ts, &expr->ts))\n-\t    gfc_convert_type (expr, &lvalue->ts, 0);\n-\n-\t  if (last_con->expr)\n-\t    gfc_free_expr (last_con->expr);\n-\n-\t  last_con->expr = gfc_get_constant_expr (BT_COMPLEX,\n-\t\t\t\t\t\t  last_ts->kind,\n-\t\t\t\t\t\t  &lvalue->where);\n+\t  rexpr = gfc_copy_expr (rvalue);\n+\t  if (!gfc_compare_types (&lvalue->ts, &rexpr->ts))\n+\t    gfc_convert_type (rexpr, &lvalue->ts, 0);\n+\n+\t  /* This is the scalar, complex case, where an initializer exists.  */\n+\t  if (init && ref == lvalue->ref)\n+\t    expr = symbol->value;\n+\t  /* Then all cases, where a complex expression does not exist.  */\n+\t  else if (!last_con || !last_con->expr)\n+\t    {\n+\t      expr = gfc_get_constant_expr (BT_COMPLEX, lvalue->ts.kind,\n+\t\t\t\t\t    &lvalue->where);\n+\t      if (last_con)\n+\t\tlast_con->expr = expr;\n+\t    }\n+\t  else\n+\t    /* Finally, and existing constructor expression to be modified.  */\n+\t    expr = last_con->expr;\n \n \t  /* Rejection of LEN and KIND inquiry references is handled\n \t     elsewhere. The error here is added as backup. The assertion\n@@ -493,22 +513,25 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index,\n \t\t\t &lvalue->where);\n \t      goto abort;\n \t    case INQUIRY_RE:\n-\t      mpfr_set (mpc_realref (last_con->expr->value.complex),\n-\t\t\texpr->value.real,\n+\t      mpfr_set (mpc_realref (expr->value.complex),\n+\t\t\trexpr->value.real,\n \t\t\tGFC_RND_MODE);\n-\t      mpfr_set_ui (mpc_imagref (last_con->expr->value.complex),\n-\t\t\t   0.0, GFC_RND_MODE);\n \t      break;\n \t    case INQUIRY_IM:\n-\t      mpfr_set (mpc_imagref (last_con->expr->value.complex),\n-\t\t\texpr->value.real,\n+\t      mpfr_set (mpc_imagref (expr->value.complex),\n+\t\t\trexpr->value.real,\n \t\t\tGFC_RND_MODE);\n-\t      mpfr_set_ui (mpc_realref (last_con->expr->value.complex),\n-\t\t\t   0.0, GFC_RND_MODE);\n \t      break;\n \t    }\n \n-\t  gfc_free_expr (expr);\n+\t  /* Only the scalar, complex expression needs to be saved as the\n+\t     symbol value since the last constructor expression is already\n+\t     provided as the initializer in the code after the reference\n+\t     cases.  */\n+\t  if (ref == lvalue->ref)\n+\t    symbol->value = expr;\n+\n+\t  gfc_free_expr (rexpr);\n \t  mpz_clear (offset);\n \t  return true;\n "}, {"sha": "de320f178ed8245c72843ffd4dded62dea3bca98", "filename": "gcc/testsuite/gfortran.dg/data_inquiry_ref.f90", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7256c8260afa313e019fd531574ad33ec49b9f6/gcc%2Ftestsuite%2Fgfortran.dg%2Fdata_inquiry_ref.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7256c8260afa313e019fd531574ad33ec49b9f6/gcc%2Ftestsuite%2Fgfortran.dg%2Fdata_inquiry_ref.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdata_inquiry_ref.f90?ref=c7256c8260afa313e019fd531574ad33ec49b9f6", "patch": "@@ -1,16 +1,20 @@\n-! { dg-do run }\n+! { dg-do compile }\n !\n-! Test the fix for PR98022.\n+! Test the fix for PR98022. Code is in place to deliver the expected result.\n+! However, it was determined that the data statements below violate F18(R841)\n+! and so an error results.\n !\n ! Contributed by Arseny Solokha  <asolokha@gmx.com>\n !\n module ur\n contains\n ! The reporter's test.\n   function kn1() result(hm2)\n-    complex :: hm(1:2), hm2(1:2)\n-    data (hm(md)%re, md=1,2)/1.0, 2.0/\n-    hm2 = hm\n+    complex :: hm(1:2), hm2(1:3), scalar\n+    data (hm(md)%re, md=1,2)/1.0, 2.0/, scalar%re/42.0/     ! { dg-error \"neither an array-element\" }\n+    data (hm(md)%im, md=1,2)/0.0, 0.0/, scalar%im/-42.0/    ! { dg-error \"neither an array-element\" }\n+    hm2(1:2) = hm\n+    hm2(3) = scalar\n   end function kn1\n \n ! Check for derived types with complex components.\n@@ -19,15 +23,17 @@ function kn2() result(hm2)\n       complex :: c\n       integer :: i\n     end type\n-    type (t) :: hm(1:2)\n-    complex :: hm2(1:2)\n-    data (hm(md)%c%im, md=1,2)/1.0, 2.0/\n+    type (t) :: hm(1:2), scalar\n+    complex :: hm2(1:3)\n+    data (hm(md)%c%re, md=1,2)/0.0, 0.0/, scalar%c%re/42.0/  ! { dg-error \"neither an array-element\" }\n+    data (hm(md)%c%im, md=1,2)/1.0, 2.0/, scalar%c%im/-42.0/ ! { dg-error \"neither an array-element\" }\n     data (hm(md)%i, md=1,2)/1, 2/\n-    hm2 = hm%c\n+    hm2(1:2) = hm%c\n+    hm2(3) = scalar%c\n   end function kn2\n end module ur\n \n-  use ur\n-  if (any (kn1() .ne. [(1.0,0.0),(2.0,0.0)])) stop 1\n-  if (any (kn2() .ne. [(0.0,1.0),(0.0,2.0)])) stop 2\n+!  use ur\n+!  if (any (kn1() .ne. [(1.0,0.0),(2.0,0.0),(42.0,-42.0)])) stop 1\n+!  if (any (kn2() .ne. [(0.0,1.0),(0.0,2.0),(42.0,-42.0)])) stop 2\n end"}]}