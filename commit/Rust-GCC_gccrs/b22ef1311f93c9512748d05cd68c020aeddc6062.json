{"sha": "b22ef1311f93c9512748d05cd68c020aeddc6062", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjIyZWYxMzExZjkzYzk1MTI3NDhkMDVjZDY4YzAyMGFlZGRjNjA2Mg==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-04-03T22:33:12Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-04-03T22:33:12Z"}, "message": "cppexp.c: wrap long lines.\n\n\t* cppexp.c: wrap long lines.  New macros CPP_ICE, SYNTAX_ERROR\n\tand SYNTAX_ERROR2. Replace `' in messages with ''.\n\t(op_to_str): Make re-entrant.\n\t(_cpp_parse_expr): Implement new error macros. Use | rather\n\tthan || to logically or 2 boolean integers.  Simply expression\n\tchecking we have a left operand iff needed.\n\nFrom-SVN: r32890", "tree": {"sha": "77d4b989768bc39de03ac84c1227f318fe6676d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77d4b989768bc39de03ac84c1227f318fe6676d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b22ef1311f93c9512748d05cd68c020aeddc6062", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b22ef1311f93c9512748d05cd68c020aeddc6062", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b22ef1311f93c9512748d05cd68c020aeddc6062", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b22ef1311f93c9512748d05cd68c020aeddc6062/comments", "author": null, "committer": null, "parents": [{"sha": "d799cfa6e5fd32e8e620e30058211222395c2c14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d799cfa6e5fd32e8e620e30058211222395c2c14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d799cfa6e5fd32e8e620e30058211222395c2c14"}], "stats": {"total": 160, "additions": 82, "deletions": 78}, "files": [{"sha": "a0fca72da1acfe9175fe68f2057fcbf26ff432ae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b22ef1311f93c9512748d05cd68c020aeddc6062/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b22ef1311f93c9512748d05cd68c020aeddc6062/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b22ef1311f93c9512748d05cd68c020aeddc6062", "patch": "@@ -1,3 +1,12 @@\n+2000-04-03  Neil Booth  <NeilB@earthling.net>\n+\n+\t* cppexp.c: wrap long lines.  New macros CPP_ICE, SYNTAX_ERROR\n+\tand SYNTAX_ERROR2. Replace `' in messages with ''.\n+\t(op_to_str): Make re-entrant.\n+\t(_cpp_parse_expr): Implement new error macros. Use | rather\n+\tthan || to logically or 2 boolean integers.  Simply expression\n+\tchecking we have a left operand iff needed.\n+\n 2000-04-03  Nick Clifton  <nickc@cygnus.com>\n \n \t* Makefile.in (diagnostic.o): Depend upon diagnostic.c"}, {"sha": "50a135110d156f70b4e0e6f86a0dcd0c3391ecb0", "filename": "gcc/cppexp.c", "status": "modified", "additions": 73, "deletions": 78, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b22ef1311f93c9512748d05cd68c020aeddc6062/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b22ef1311f93c9512748d05cd68c020aeddc6062/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=b22ef1311f93c9512748d05cd68c020aeddc6062", "patch": "@@ -62,8 +62,8 @@ Written by Per Bothner 1994.  */\n #endif\n \n #define MAX_CHAR_TYPE_MASK (MAX_CHAR_TYPE_SIZE < HOST_BITS_PER_WIDEST_INT \\\n-\t\t\t    ? (~(~(HOST_WIDEST_INT) 0 << MAX_CHAR_TYPE_SIZE)) \\\n-\t\t\t    : ~ (HOST_WIDEST_INT) 0)\n+\t\t    ? (~(~(HOST_WIDEST_INT) 0 << MAX_CHAR_TYPE_SIZE)) \\\n+\t\t    : ~ (HOST_WIDEST_INT) 0)\n \n #define MAX_WCHAR_TYPE_MASK (MAX_WCHAR_TYPE_SIZE < HOST_BITS_PER_WIDEST_INT \\\n \t\t\t     ? ~(~(HOST_WIDEST_INT) 0 << MAX_WCHAR_TYPE_SIZE) \\\n@@ -90,7 +90,7 @@ static struct operation parse_defined PARAMS ((cpp_reader *));\n static HOST_WIDEST_INT parse_escape PARAMS ((cpp_reader *, U_CHAR **,\n \t\t\t\t\t     HOST_WIDEST_INT));\n static struct operation lex PARAMS ((cpp_reader *, int));\n-static const char * op_to_str PARAMS ((op_t));\n+static const char * op_to_str PARAMS ((op_t, char *));\n \n #define ERROR 299\n #define OROR 300\n@@ -159,15 +159,16 @@ parse_number (pfile, start, end)\n \n       if (c >= '0' && c <= '9')\n \tdigit = c - '0';\n-      else if (base == 16 && c >= 'a' && c <= 'f') /* FIXME: assumes ASCII */\n+      /* FIXME: assumes ASCII */\n+      else if (base == 16 && c >= 'a' && c <= 'f')\n \tdigit = c - 'a' + 10;\n       else if (base == 16 && c >= 'A' && c <= 'F')\n \tdigit = c - 'A' + 10;\n       else if (c == '.')\n \t{\n \t  /* It's a float since it contains a point.  */\n \t  cpp_error (pfile,\n-\t\t\"floating point numbers are not allowed in #if expressions\");\n+\t     \"floating point numbers are not allowed in #if expressions\");\n \t  goto error;\n \t}\n       else\n@@ -181,9 +182,9 @@ parse_number (pfile, start, end)\n \t\t  op.unsignedp++;\n \t      else\n \t\t{\n-\t\t  /* Decrement p here so that the error for an invalid number\n-\t\t     will be generated below in the case where this is the\n-\t\t     last character in the buffer.  */\n+\t\t  /* Decrement p here so that the error for an invalid\n+\t\t     number will be generated below in the case where\n+\t\t     this is the last character in the buffer.  */\n \t\t  p--;\n \t\t  break;\n \t\t}\n@@ -209,17 +210,18 @@ parse_number (pfile, start, end)\n     }\n   else if (spec_long > (CPP_OPTION (pfile, c89) ? 1 : 2))\n     {\n-      cpp_error (pfile, \"too many `l' suffixes in integer constant\");\n+      cpp_error (pfile, \"too many 'l' suffixes in integer constant\");\n       goto error;\n     }\n   else if (op.unsignedp > 1)\n     {\n-      cpp_error (pfile, \"too many `u' suffixes in integer constant\");\n+      cpp_error (pfile, \"too many 'u' suffixes in integer constant\");\n       goto error;\n     }\n   \n   if (base <= largest_digit)\n-    cpp_pedwarn (pfile, \"integer constant contains digits beyond the radix\");\n+    cpp_pedwarn (pfile,\n+\t\t \"integer constant contains digits beyond the radix\");\n \n   if (overflow)\n     cpp_pedwarn (pfile, \"integer constant out of range\");\n@@ -279,7 +281,8 @@ parse_charconst (pfile, start, end)\n \t  c = parse_escape (pfile, &ptr, mask);\n \t  if (width < HOST_BITS_PER_INT\n \t      && (unsigned int) c >= (unsigned int)(1 << width))\n-\t    cpp_pedwarn (pfile, \"escape sequence out of range for character\");\n+\t    cpp_pedwarn (pfile,\n+\t\t\t \"escape sequence out of range for character\");\n \t}\n \t  \n       /* Merge character into result; ignore excess chars.  */\n@@ -375,7 +378,7 @@ parse_defined (pfile)\n  oops:\n   CPP_SET_WRITTEN (pfile, old_written);\n   pfile->no_macro_expand--;\n-  cpp_error (pfile, \"`defined' without an identifier\");\n+  cpp_error (pfile, \"'defined' without an identifier\");\n \n   op.op = ERROR;\n   return op;\n@@ -431,7 +434,8 @@ lex (pfile, skip_evaluation)\n       return parse_number (pfile, tok_start, tok_end);\n     case CPP_STRING:\n     case CPP_WSTRING:\n-      cpp_error (pfile, \"string constants are not allowed in #if expressions\");\n+      cpp_error (pfile,\n+\t\t \"string constants are not allowed in #if expressions\");\n       op.op = ERROR;\n       return op;\n \n@@ -448,7 +452,7 @@ lex (pfile, skip_evaluation)\n       op.value = 0;\n \n       if (CPP_OPTION (pfile, warn_undef) && !skip_evaluation)\n-\tcpp_warning (pfile, \"`%.*s' is not defined\",\n+\tcpp_warning (pfile, \"'%.*s' is not defined\",\n \t\t     (int) (tok_end - tok_start), tok_start);\n       return op;\n \n@@ -467,7 +471,7 @@ lex (pfile, skip_evaluation)\n \t\t&& tok_start[1] == toktab->operator[1])\n \t\tbreak;\n \t  if (toktab->token == ERROR)\n-\t    cpp_error (pfile, \"`%s' not allowed in operand of `#if'\",\n+\t    cpp_error (pfile, \"'%s' not allowed in operand of #if\",\n \t\t       tok_start);\n \t  op.op = toktab->token; \n \t  return op;\n@@ -479,12 +483,14 @@ lex (pfile, skip_evaluation)\n   }\n }\n \n-/* Convert an operator ID to a string.  */\n+/* Convert an operator ID to a string.  BUFF is a buffer at least 5\n+   characters long which might be used to store the string.  */\n+/* XXX FIXME: Remove BUFF when new lexer is implemented.  */\n static const char *\n-op_to_str (op)\n+op_to_str (op, buff)\n      op_t op;\n+     char *buff;\n {\n-  static char str[5];\t\t/* XXX static variable.  */\n   const struct token *toktab;\n \n   /* See if it is a special token of length 2.  */\n@@ -493,10 +499,10 @@ op_to_str (op)\n       return toktab->operator;\n \n   if (ISGRAPH (op))\n-    sprintf (str, \"%c\", (int) op);\n+    sprintf (buff, \"%c\", (int) op);\n   else\n-    sprintf (str, \"\\\\%03o\", (int) op);\n-  return str;\n+    sprintf (buff, \"\\\\%03o\", (int) op);\n+  return buff;\n }\n \n /* Parse a C escape sequence.  STRING_PTR points to a variable\n@@ -529,7 +535,7 @@ parse_escape (pfile, string_ptr, result_mask)\n     case 'e':\n     case 'E':\n       if (CPP_PEDANTIC (pfile))\n-\tcpp_pedwarn (pfile, \"non-ANSI-standard escape sequence, `\\\\%c'\", c);\n+\tcpp_pedwarn (pfile, \"non-ANSI-standard escape sequence, '\\\\%c'\", c);\n       return TARGET_ESC;\n     case 'f':\n       return TARGET_FF;\n@@ -723,15 +729,24 @@ be handled with operator-specific code.  */\n \n #define COMPARE(OP) \\\n   top->unsignedp = 0; \\\n-  top->value = (unsigned1 || unsigned2) \\\n+  top->value = (unsigned1 | unsigned2) \\\n   ? (unsigned HOST_WIDEST_INT) v1 OP (unsigned HOST_WIDEST_INT) v2 \\\n   : (v1 OP v2)\n #define EQUALITY(OP) \\\n   top->value = v1 OP v2; \\\n   top->unsignedp = 0;\n #define LOGICAL(OP) \\\n   top->value = v1 OP v2; \\\n-  top->unsignedp = unsigned1 || unsigned2;\n+  top->unsignedp = unsigned1 | unsigned2;\n+\n+/* With -O2, gcc appears to produce nice code, moving the error\n+   message load and subsequent jump completely out of the main path.  */\n+#define CPP_ICE(msgid) \\\n+  do { cpp_ice (pfile, msgid); goto syntax_error; } while(0)\n+#define SYNTAX_ERROR(msgid) \\\n+  do { cpp_error (pfile, msgid); goto syntax_error; } while(0)\n+#define SYNTAX_ERROR2(msgid, arg) \\\n+  do { cpp_error (pfile, msgid, arg); goto syntax_error; } while(0)\n \n /* Parse and evaluate a C expression, reading from PFILE.\n    Returns the truth value of the expression.  */\n@@ -758,6 +773,7 @@ _cpp_parse_expr (pfile)\n   long old_written = CPP_WRITTEN (pfile);\n   int skip_evaluation = 0;\n   int result;\n+  char buff[5];\n \n   pfile->parsing_if_directive++;\n   /* We've finished when we try to reduce this.  */\n@@ -782,7 +798,7 @@ _cpp_parse_expr (pfile)\n       switch (op.op)\n \t{\n \tcase NAME:\n-\t  cpp_ice (pfile, \"lex returns a NAME\");\n+\t  CPP_ICE (\"lex returns a NAME\");\n \tcase ERROR:\n \t  goto syntax_error;\n \tcase '#':\n@@ -791,18 +807,14 @@ _cpp_parse_expr (pfile)\n \t     already issued an error.  */\n \t  goto syntax_error;\n \tdefault:\n-\t  cpp_error (pfile, \"invalid character in #if\");\n-\t  goto syntax_error;\n+\t  SYNTAX_ERROR (\"invalid character in #if\");\n \n+\tpush_immediate:\n \tcase INT:\n \tcase CHAR:\n-\tpush_immediate:\n \t  /* Push a value onto the stack.  */\n \t  if (top->flags & HAVE_VALUE)\n-\t    {\n-\t      cpp_error (pfile, \"missing binary operator\");\n-\t      goto syntax_error;\n-\t    }\n+\t    SYNTAX_ERROR (\"missing binary operator\");\n \t  top->value = op.value;\n \t  top->unsignedp = op.unsignedp;\n \t  top->flags |= HAVE_VALUE;\n@@ -855,11 +867,10 @@ _cpp_parse_expr (pfile)\n \t  if ((top->flags & (HAVE_VALUE | NO_R_OPERAND)) == 0)\n \t    {\n \t      if (top->op == '(')\n-\t\tcpp_error (pfile, \"void expression between '(' and ')'\");\n+\t\tSYNTAX_ERROR (\"void expression between '(' and ')'\");\n \t      else\n-\t\tcpp_error (pfile, \"operator `%s' has no right operand\",\n-\t\t\t   op_to_str (top->op));\n-\t      goto syntax_error;\n+\t\tSYNTAX_ERROR2 (\"operator '%s' has no right operand\",\n+\t\t\t       op_to_str (top->op, buff));\n \t    }\n \n \t  unsigned2 = top->unsignedp, v2 = top->value;\n@@ -879,7 +890,7 @@ _cpp_parse_expr (pfile)\n \t      else\n \t\t{\n \t\t  top->value = v1 + v2;\n-\t\t  top->unsignedp = unsigned1 || unsigned2;\n+\t\t  top->unsignedp = unsigned1 | unsigned2;\n \t\t  if (! top->unsignedp && ! skip_evaluation\n \t\t      && ! possible_sum_sign (v1, v2, top->value))\n \t\t    integer_overflow (pfile);\n@@ -898,14 +909,14 @@ _cpp_parse_expr (pfile)\n \t      else\n \t\t{ /* Binary '-' */\n \t\t  top->value = v1 - v2;\n-\t\t  top->unsignedp = unsigned1 || unsigned2;\n+\t\t  top->unsignedp = unsigned1 | unsigned2;\n \t\t  if (! top->unsignedp && ! skip_evaluation\n \t\t      && ! possible_sum_sign (top->value, v2, v1))\n \t\t    integer_overflow (pfile);\n \t\t}\n \t      break;\n \t    case '*':\n-\t      top->unsignedp = unsigned1 || unsigned2;\n+\t      top->unsignedp = unsigned1 | unsigned2;\n \t      if (top->unsignedp)\n \t\ttop->value = (unsigned HOST_WIDEST_INT) v1 * v2;\n \t      else if (!skip_evaluation)\n@@ -921,11 +932,8 @@ _cpp_parse_expr (pfile)\n \t      if (skip_evaluation)\n \t\tbreak;\n \t      if (v2 == 0)\n-\t\t{\n-\t\t  cpp_error (pfile, \"division by zero in #if\");\n-\t\t  v2 = 1;\n-\t\t}\n-\t      top->unsignedp = unsigned1 || unsigned2;\n+\t\tSYNTAX_ERROR (\"division by zero in #if\");\n+\t      top->unsignedp = unsigned1 | unsigned2;\n \t      if (top[1].op == '/')\n \t\t{\n \t\t  if (top->unsignedp)\n@@ -992,45 +1000,33 @@ _cpp_parse_expr (pfile)\n \t      break;\n \t    case ',':\n \t      if (CPP_PEDANTIC (pfile))\n-\t\tcpp_pedwarn (pfile, \"comma operator in operand of `#if'\");\n+\t\tcpp_pedwarn (pfile, \"comma operator in operand of #if\");\n \t      top->value = v2;\n \t      top->unsignedp = unsigned2;\n \t      break;\n \t    case '?':\n-\t      cpp_error (pfile, \"syntax error '?' without following ':'\");\n-\t      goto syntax_error;\n+\t      SYNTAX_ERROR (\"syntax error '?' without following ':'\");\n \t    case ':':\n \t      if (top[0].op != '?')\n-\t\t{\n-\t\t  cpp_error (pfile,\n-\t\t\t     \"syntax error ':' without preceding '?'\");\n-\t\t  goto syntax_error;\n-\t\t}\n+\t\tSYNTAX_ERROR (\"syntax error ':' without preceding '?'\");\n \t      top--;\n \t      if (top->value) skip_evaluation--;\n \t      top->value = top->value ? v1 : v2;\n-\t      top->unsignedp = unsigned1 || unsigned2;\n+\t      top->unsignedp = unsigned1 | unsigned2;\n \t      break;\n \t    case '(':\n \t      if (op.op != ')')\n-\t\t{\n-\t\t  cpp_error (pfile, \"missing ')' in expression\");\n-\t\t  goto syntax_error;\n-\t\t}\n+\t\tSYNTAX_ERROR (\"missing ')' in expression\");\n \t      op.value = v2;\n \t      op.unsignedp = unsigned2;\n \t      goto push_immediate;\n \t    default:\n-\t      cpp_error (pfile, \"unimplemented operator `%s'\",\n-\t\t\t op_to_str (top[1].op));\n-\t      break;\n+\t      SYNTAX_ERROR2 (\"unimplemented operator '%s'\",\n+\t\t\t     op_to_str (top[1].op, buff));\n \t    case FINISHED:\n \t      /* Reducing this dummy operator indicates we've finished.  */\n \t      if (op.op == ')')\n-\t\t{\n-\t\t  cpp_error (pfile, \"missing '(' in expression\");\n-\t\t  goto syntax_error;\n-\t\t}\n+\t\tSYNTAX_ERROR (\"missing '(' in expression\");\n \t      goto done;\n \t    }\n \t}\n@@ -1051,15 +1047,17 @@ _cpp_parse_expr (pfile)\n \n     skip_reduction:\n       /* Check we have a left operand iff we need one.  */\n-      if (((flags & NO_L_OPERAND) != 0) ^ ((top->flags & HAVE_VALUE) == 0))\n+      if (flags & NO_L_OPERAND)\n \t{\n-\t  if (flags & NO_L_OPERAND)\n-\t    cpp_error (pfile, \"missing binary operator before `%s'\",\n-\t\t       op_to_str (op.op));\n-\t  else\n-\t    cpp_error (pfile, \"operator `%s' has no left operand\",\n-\t\t       op_to_str (op.op));\n-\t  goto syntax_error;\n+\t  if (top->flags & HAVE_VALUE)\n+\t    SYNTAX_ERROR2 (\"missing binary operator before '%s'\",\n+\t\t\t   op_to_str (op.op, buff));\n+\t}\n+      else\n+\t{\n+\t  if (!(top->flags & HAVE_VALUE))\n+\t    SYNTAX_ERROR2 (\"operator '%s' has no left operand\",\n+\t\t\t   op_to_str (op.op, buff));\n \t}\n \n       /* Check for and handle stack overflow.  */\n@@ -1089,13 +1087,10 @@ _cpp_parse_expr (pfile)\n  done:\n   result = (top[1].value != 0);\n   if (top != stack)\n-    {\n-      cpp_ice (pfile, \"unbalanced stack in #if expression\");\n-      goto syntax_error;\n-    }\n+    CPP_ICE (\"unbalanced stack in #if expression\");\n   else if (!(top[1].flags & HAVE_VALUE))\n     {\n-      cpp_error (pfile, \"#if with no expression\");\n+      SYNTAX_ERROR (\"#if with no expression\");\n     syntax_error:\n       _cpp_skip_rest_of_line (pfile);\n       result = 0;  /* Return 0 on syntax error.  */"}]}