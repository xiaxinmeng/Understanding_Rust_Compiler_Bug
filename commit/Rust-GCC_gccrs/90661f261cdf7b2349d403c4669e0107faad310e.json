{"sha": "90661f261cdf7b2349d403c4669e0107faad310e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTA2NjFmMjYxY2RmN2IyMzQ5ZDQwM2M0NjY5ZTAxMDdmYWFkMzEwZQ==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2009-07-25T11:56:35Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2009-07-25T11:56:35Z"}, "message": "re PR fortran/39630 ([F03] Procedure Pointer Components)\n\n2009-07-25  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/39630\n\t* decl.c (match_ppc_decl): Implement the PASS attribute for procedure\n\tpointer components.\n\t(match_binding_attributes): Ditto.\n\t* gfortran.h (gfc_component): Add member 'tb'.\n\t(gfc_typebound_proc): Add member 'ppc' and make 'pass_arg' const.\n\t* module.c (MOD_VERSION): Bump module version.\n\t(binding_ppc): New string constants.\n\t(mio_component): Only use formal args if component is a procedure\n\tpointer and add 'tb' member.\n\t(mio_typebound_proc): Include pass_arg and take care of procedure\n\tpointer components.\n\t* resolve.c (update_arglist_pass): Add argument 'name' and take care of\n\toptional arguments.\n\t(extract_ppc_passed_object): New function, analogous to\n\textract_compcall_passed_object, but for procedure pointer components.\n\t(update_ppc_arglist): New function, analogous to\n\tupdate_compcall_arglist, but for procedure pointer components.\n\t(resolve_typebound_generic_call): Added argument to update_arglist_pass.\n\t(resolve_ppc_call, resolve_expr_ppc): Take care of PASS attribute.\n\t(resolve_fl_derived): Check the PASS argument for procedure pointer\n\tcomponents.\n\t* symbol.c (verify_bind_c_derived_type): Reject procedure pointer\n\tcomponents in BIND(C) types.\n\n2009-07-25  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/39630\n\t* gfortran.dg/proc_ptr_comp_3.f90: Modified.\n\t* gfortran.dg/proc_ptr_comp_pass_1.f90: New.\n\t* gfortran.dg/proc_ptr_comp_pass_2.f90: New.\n\t* gfortran.dg/proc_ptr_comp_pass_3.f90: New.\n\t* gfortran.dg/proc_ptr_comp_pass_4.f90: New.\n\t* gfortran.dg/proc_ptr_comp_pass_5.f90: New.\n\t* gfortran.dg/typebound_call_10.f03: New.\n\nFrom-SVN: r150078", "tree": {"sha": "5f96889c85c7f39e41827b1e710416e711dd6077", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f96889c85c7f39e41827b1e710416e711dd6077"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90661f261cdf7b2349d403c4669e0107faad310e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90661f261cdf7b2349d403c4669e0107faad310e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90661f261cdf7b2349d403c4669e0107faad310e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90661f261cdf7b2349d403c4669e0107faad310e/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "330b922f19394dccb7f3d00ed9dd0d4223787a28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/330b922f19394dccb7f3d00ed9dd0d4223787a28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/330b922f19394dccb7f3d00ed9dd0d4223787a28"}], "stats": {"total": 631, "additions": 580, "deletions": 51}, "files": [{"sha": "86f066248592f4a2da8c61522b516fc49759541f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90661f261cdf7b2349d403c4669e0107faad310e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90661f261cdf7b2349d403c4669e0107faad310e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=90661f261cdf7b2349d403c4669e0107faad310e", "patch": "@@ -1,3 +1,30 @@\n+2009-07-25  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/39630\n+\t* decl.c (match_ppc_decl): Implement the PASS attribute for procedure\n+\tpointer components.\n+\t(match_binding_attributes): Ditto.\n+\t* gfortran.h (gfc_component): Add member 'tb'.\n+\t(gfc_typebound_proc): Add member 'ppc' and make 'pass_arg' const.\n+\t* module.c (MOD_VERSION): Bump module version.\n+\t(binding_ppc): New string constants.\n+\t(mio_component): Only use formal args if component is a procedure\n+\tpointer and add 'tb' member.\n+\t(mio_typebound_proc): Include pass_arg and take care of procedure\n+\tpointer components.\n+\t* resolve.c (update_arglist_pass): Add argument 'name' and take care of\n+\toptional arguments.\n+\t(extract_ppc_passed_object): New function, analogous to\n+\textract_compcall_passed_object, but for procedure pointer components.\n+\t(update_ppc_arglist): New function, analogous to\n+\tupdate_compcall_arglist, but for procedure pointer components.\n+\t(resolve_typebound_generic_call): Added argument to update_arglist_pass.\n+\t(resolve_ppc_call, resolve_expr_ppc): Take care of PASS attribute.\n+\t(resolve_fl_derived): Check the PASS argument for procedure pointer\n+\tcomponents.\n+\t* symbol.c (verify_bind_c_derived_type): Reject procedure pointer\n+\tcomponents in BIND(C) types.\n+\n 2009-07-24  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/40822"}, {"sha": "392f2a57e68228cf63954216c10e7766da4a9ded", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90661f261cdf7b2349d403c4669e0107faad310e/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90661f261cdf7b2349d403c4669e0107faad310e/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=90661f261cdf7b2349d403c4669e0107faad310e", "patch": "@@ -4411,14 +4411,6 @@ match_ppc_decl (void)\n   if (m == MATCH_ERROR)\n     return m;\n \n-  /* TODO: Implement PASS.  */\n-  if (!tb->nopass)\n-    {\n-      gfc_error (\"Procedure Pointer Component with PASS at %C \"\n-\t\t \"not yet implemented\");\n-      return MATCH_ERROR;\n-    }\n-\n   gfc_clear_attr (&current_attr);\n   current_attr.procedure = 1;\n   current_attr.proc_pointer = 1;\n@@ -4462,6 +4454,8 @@ match_ppc_decl (void)\n       if (gfc_add_proc (&c->attr, name, NULL) == FAILURE)\n \treturn MATCH_ERROR;\n \n+      c->tb = tb;\n+\n       /* Set interface.  */\n       if (proc_if != NULL)\n \t{\n@@ -7028,7 +7022,7 @@ match_binding_attributes (gfc_typebound_proc* ba, bool generic, bool ppc)\n {\n   bool found_passing = false;\n   bool seen_ptr = false;\n-  match m;\n+  match m = MATCH_YES;\n \n   /* Intialize to defaults.  Do so even before the MATCH_NO check so that in\n      this case the defaults are in there.  */\n@@ -7038,13 +7032,12 @@ match_binding_attributes (gfc_typebound_proc* ba, bool generic, bool ppc)\n   ba->nopass = 0;\n   ba->non_overridable = 0;\n   ba->deferred = 0;\n+  ba->ppc = ppc;\n \n   /* If we find a comma, we believe there are binding attributes.  */\n-  if (gfc_match_char (',') == MATCH_NO)\n-    {\n-      ba->access = gfc_typebound_default_access;\n-      return MATCH_NO;\n-    }\n+  m = gfc_match_char (',');\n+  if (m == MATCH_NO)\n+    goto done;\n \n   do\n     {\n@@ -7121,7 +7114,7 @@ match_binding_attributes (gfc_typebound_proc* ba, bool generic, bool ppc)\n \t      if (m == MATCH_ERROR)\n \t\tgoto error;\n \t      if (m == MATCH_YES)\n-\t\tba->pass_arg = xstrdup (arg);\n+\t\tba->pass_arg = gfc_get_string (arg);\n \t      gcc_assert ((m == MATCH_YES) == (ba->pass_arg != NULL));\n \n \t      found_passing = true;\n@@ -7144,7 +7137,6 @@ match_binding_attributes (gfc_typebound_proc* ba, bool generic, bool ppc)\n \t\t    }\n \n \t\t  seen_ptr = true;\n-\t\t  /*ba->ppc = 1;*/\n         \t  continue;\n \t\t}\n \t    }\n@@ -7201,6 +7193,9 @@ match_binding_attributes (gfc_typebound_proc* ba, bool generic, bool ppc)\n       goto error;\n     }\n \n+  m = MATCH_YES;\n+\n+done:\n   if (ba->access == ACCESS_UNKNOWN)\n     ba->access = gfc_typebound_default_access;\n \n@@ -7211,10 +7206,9 @@ match_binding_attributes (gfc_typebound_proc* ba, bool generic, bool ppc)\n       goto error;\n     }\n \n-  return MATCH_YES;\n+  return m;\n \n error:\n-  gfc_free (ba->pass_arg);\n   return MATCH_ERROR;\n }\n "}, {"sha": "7792cfabab67b684b1de530535a79fcde22b3ceb", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90661f261cdf7b2349d403c4669e0107faad310e/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90661f261cdf7b2349d403c4669e0107faad310e/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=90661f261cdf7b2349d403c4669e0107faad310e", "patch": "@@ -879,8 +879,10 @@ typedef struct gfc_component\n   struct gfc_expr *initializer;\n   struct gfc_component *next;\n \n+  /* Needed for procedure pointer components.  */\n   struct gfc_formal_arglist *formal;\n   struct gfc_namespace *formal_ns;\n+  struct gfc_typebound_proc *tb;\n }\n gfc_component;\n \n@@ -1064,7 +1066,7 @@ typedef struct gfc_typebound_proc\n   u;\n \n   gfc_access access;\n-  char* pass_arg; /* Argument-name for PASS.  NULL if not specified.  */\n+  const char* pass_arg; /* Argument-name for PASS.  NULL if not specified.  */\n \n   /* The overridden type-bound proc (or GENERIC with this name in the\n      parent-type) or NULL if non.  */\n@@ -1081,6 +1083,7 @@ typedef struct gfc_typebound_proc\n   unsigned is_generic:1;\n   unsigned function:1, subroutine:1;\n   unsigned error:1; /* Ignore it, when an error occurred during resolution.  */\n+  unsigned ppc:1;\n }\n gfc_typebound_proc;\n "}, {"sha": "eff482ca68687e2e9171c1827d8fb86390da1a43", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 33, "deletions": 23, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90661f261cdf7b2349d403c4669e0107faad310e/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90661f261cdf7b2349d403c4669e0107faad310e/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=90661f261cdf7b2349d403c4669e0107faad310e", "patch": "@@ -77,7 +77,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Don't put any single quote (') in MOD_VERSION, \n    if yout want it to be recognized.  */\n-#define MOD_VERSION \"1\"\n+#define MOD_VERSION \"2\"\n \n \n /* Structure that describes a position within a module file.  */\n@@ -1719,7 +1719,12 @@ static const mstring binding_generic[] =\n     minit (\"GENERIC\", 1),\n     minit (NULL, -1)\n };\n-\n+static const mstring binding_ppc[] =\n+{\n+    minit (\"NO_PPC\", 0),\n+    minit (\"PPC\", 1),\n+    minit (NULL, -1)\n+};\n \n /* Specialization of mio_name.  */\n DECL_MIO_NAME (ab_attribute)\n@@ -2260,7 +2265,7 @@ mio_component_ref (gfc_component **cp, gfc_symbol *sym)\n \n static void mio_namespace_ref (gfc_namespace **nsp);\n static void mio_formal_arglist (gfc_formal_arglist **formal);\n-\n+static void mio_typebound_proc (gfc_typebound_proc** proc);\n \n static void\n mio_component (gfc_component *c)\n@@ -2295,28 +2300,33 @@ mio_component (gfc_component *c)\n \n   mio_expr (&c->initializer);\n \n-  if (iomode == IO_OUTPUT)\n+  if (c->attr.proc_pointer)\n     {\n-      formal = c->formal;\n-      while (formal && !formal->sym)\n-\tformal = formal->next;\n+      if (iomode == IO_OUTPUT)\n+\t{\n+\t  formal = c->formal;\n+\t  while (formal && !formal->sym)\n+\t    formal = formal->next;\n \n-      if (formal)\n-\tmio_namespace_ref (&formal->sym->ns);\n+\t  if (formal)\n+\t    mio_namespace_ref (&formal->sym->ns);\n+\t  else\n+\t    mio_namespace_ref (&c->formal_ns);\n+\t}\n       else\n-\tmio_namespace_ref (&c->formal_ns);\n-    }\n-  else\n-    {\n-      mio_namespace_ref (&c->formal_ns);\n-      /* TODO: if (c->formal_ns)\n \t{\n-\t  c->formal_ns->proc_name = c;\n-\t  c->refs++;\n-\t}*/\n-    }\n+\t  mio_namespace_ref (&c->formal_ns);\n+\t  /* TODO: if (c->formal_ns)\n+\t    {\n+\t      c->formal_ns->proc_name = c;\n+\t      c->refs++;\n+\t    }*/\n+\t}\n+\n+      mio_formal_arglist (&c->formal);\n \n-  mio_formal_arglist (&c->formal);\n+      mio_typebound_proc (&c->tb);\n+    }\n \n   mio_rparen ();\n }\n@@ -3265,9 +3275,9 @@ mio_typebound_proc (gfc_typebound_proc** proc)\n \n   (*proc)->nopass = mio_name ((*proc)->nopass, binding_passing);\n   (*proc)->is_generic = mio_name ((*proc)->is_generic, binding_generic);\n+  (*proc)->ppc = mio_name((*proc)->ppc, binding_ppc);\n \n-  if (iomode == IO_INPUT)\n-    (*proc)->pass_arg = NULL;\n+  mio_pool_string (&((*proc)->pass_arg));\n \n   flag = (int) (*proc)->pass_arg_num;\n   mio_integer (&flag);\n@@ -3304,7 +3314,7 @@ mio_typebound_proc (gfc_typebound_proc** proc)\n \n       mio_rparen ();\n     }\n-  else\n+  else if (!(*proc)->ppc)\n     mio_symtree_ref (&(*proc)->u.specific);\n \n   mio_rparen ();"}, {"sha": "aaab554d4de91f3eb129f2a96ff63de385591981", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 183, "deletions": 8, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90661f261cdf7b2349d403c4669e0107faad310e/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90661f261cdf7b2349d403c4669e0107faad310e/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=90661f261cdf7b2349d403c4669e0107faad310e", "patch": "@@ -4535,7 +4535,8 @@ fixup_charlen (gfc_expr *e)\n    procedures at the right position.  */\n \n static gfc_actual_arglist*\n-update_arglist_pass (gfc_actual_arglist* lst, gfc_expr* po, unsigned argpos)\n+update_arglist_pass (gfc_actual_arglist* lst, gfc_expr* po, unsigned argpos,\n+\t\t     const char *name)\n {\n   gcc_assert (argpos > 0);\n \n@@ -4546,14 +4547,16 @@ update_arglist_pass (gfc_actual_arglist* lst, gfc_expr* po, unsigned argpos)\n       result = gfc_get_actual_arglist ();\n       result->expr = po;\n       result->next = lst;\n+      if (name)\n+        result->name = name;\n \n       return result;\n     }\n \n-  gcc_assert (lst);\n-  gcc_assert (argpos > 1);\n-\n-  lst->next = update_arglist_pass (lst->next, po, argpos - 1);\n+  if (lst)\n+    lst->next = update_arglist_pass (lst->next, po, argpos - 1, name);\n+  else\n+    lst = update_arglist_pass (NULL, po, argpos - 1, name);\n   return lst;\n }\n \n@@ -4611,7 +4614,74 @@ update_compcall_arglist (gfc_expr* e)\n \n   gcc_assert (tbp->pass_arg_num > 0);\n   e->value.compcall.actual = update_arglist_pass (e->value.compcall.actual, po,\n-\t\t\t\t\t\t  tbp->pass_arg_num);\n+\t\t\t\t\t\t  tbp->pass_arg_num,\n+\t\t\t\t\t\t  tbp->pass_arg);\n+\n+  return SUCCESS;\n+}\n+\n+\n+/* Extract the passed object from a PPC call (a copy of it).  */\n+\n+static gfc_expr*\n+extract_ppc_passed_object (gfc_expr *e)\n+{\n+  gfc_expr *po;\n+  gfc_ref **ref;\n+\n+  po = gfc_get_expr ();\n+  po->expr_type = EXPR_VARIABLE;\n+  po->symtree = e->symtree;\n+  po->ref = gfc_copy_ref (e->ref);\n+\n+  /* Remove PPC reference.  */\n+  ref = &po->ref;\n+  while ((*ref)->next)\n+    (*ref) = (*ref)->next;\n+  gfc_free_ref_list (*ref);\n+  *ref = NULL;\n+\n+  if (gfc_resolve_expr (po) == FAILURE)\n+    return NULL;\n+\n+  return po;\n+}\n+\n+\n+/* Update the actual arglist of a procedure pointer component to include the\n+   passed-object.  */\n+\n+static gfc_try\n+update_ppc_arglist (gfc_expr* e)\n+{\n+  gfc_expr* po;\n+  gfc_component *ppc;\n+  gfc_typebound_proc* tb;\n+\n+  if (!gfc_is_proc_ptr_comp (e, &ppc))\n+    return FAILURE;\n+\n+  tb = ppc->tb;\n+\n+  if (tb->error)\n+    return FAILURE;\n+  else if (tb->nopass)\n+    return SUCCESS;\n+\n+  po = extract_ppc_passed_object (e);\n+  if (!po)\n+    return FAILURE;\n+\n+  if (po->rank > 0)\n+    {\n+      gfc_error (\"Passed-object at %L must be scalar\", &e->where);\n+      return FAILURE;\n+    }\n+\n+  gcc_assert (tb->pass_arg_num > 0);\n+  e->value.compcall.actual = update_arglist_pass (e->value.compcall.actual, po,\n+\t\t\t\t\t\t  tb->pass_arg_num,\n+\t\t\t\t\t\t  tb->pass_arg);\n \n   return SUCCESS;\n }\n@@ -4714,7 +4784,8 @@ resolve_typebound_generic_call (gfc_expr* e)\n \n \t      gcc_assert (g->specific->pass_arg_num > 0);\n \t      gcc_assert (!g->specific->error);\n-\t      args = update_arglist_pass (args, po, g->specific->pass_arg_num);\n+\t      args = update_arglist_pass (args, po, g->specific->pass_arg_num,\n+\t\t\t\t\t  g->specific->pass_arg);\n \t    }\n \t  resolve_actual_arglist (args, target->attr.proc,\n \t\t\t\t  is_external_proc (target) && !target->formal);\n@@ -4836,14 +4907,18 @@ resolve_ppc_call (gfc_code* c)\n \n   c->resolved_sym = c->expr1->symtree->n.sym;\n   c->expr1->expr_type = EXPR_VARIABLE;\n-  c->ext.actual = c->expr1->value.compcall.actual;\n \n   if (!comp->attr.subroutine)\n     gfc_add_subroutine (&comp->attr, comp->name, &c->expr1->where);\n \n   if (resolve_ref (c->expr1) == FAILURE)\n     return FAILURE;\n \n+  if (update_ppc_arglist (c->expr1) == FAILURE)\n+    return FAILURE;\n+\n+  c->ext.actual = c->expr1->value.compcall.actual;\n+\n   if (resolve_actual_arglist (c->ext.actual, comp->attr.proc,\n \t\t\t      comp->formal == NULL) == FAILURE)\n     return FAILURE;\n@@ -4880,6 +4955,9 @@ resolve_expr_ppc (gfc_expr* e)\n \t\t\t      comp->formal == NULL) == FAILURE)\n     return FAILURE;\n \n+  if (update_ppc_arglist (e) == FAILURE)\n+    return FAILURE;\n+\n   gfc_ppc_use (comp, &e->value.compcall.actual, &e->where);\n \n   return SUCCESS;\n@@ -9095,6 +9173,103 @@ resolve_fl_derived (gfc_symbol *sym)\n \t  c->attr.implicit_type = 1;\n \t}\n \n+      /* Procedure pointer components: Check PASS arg.  */\n+      if (c->attr.proc_pointer && !c->tb->nopass && c->tb->pass_arg_num == 0)\n+\t{\n+\t  gfc_symbol* me_arg;\n+\n+\t  if (c->tb->pass_arg)\n+\t    {\n+\t      gfc_formal_arglist* i;\n+\n+\t      /* If an explicit passing argument name is given, walk the arg-list\n+\t\tand look for it.  */\n+\n+\t      me_arg = NULL;\n+\t      c->tb->pass_arg_num = 1;\n+\t      for (i = c->formal; i; i = i->next)\n+\t\t{\n+\t\t  if (!strcmp (i->sym->name, c->tb->pass_arg))\n+\t\t    {\n+\t\t      me_arg = i->sym;\n+\t\t      break;\n+\t\t    }\n+\t\t  c->tb->pass_arg_num++;\n+\t\t}\n+\n+\t      if (!me_arg)\n+\t\t{\n+\t\t  gfc_error (\"Procedure pointer component '%s' with PASS(%s) \"\n+\t\t\t     \"at %L has no argument '%s'\", c->name,\n+\t\t\t     c->tb->pass_arg, &c->loc, c->tb->pass_arg);\n+\t\t  c->tb->error = 1;\n+\t\t  return FAILURE;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Otherwise, take the first one; there should in fact be at least\n+\t\tone.  */\n+\t      c->tb->pass_arg_num = 1;\n+\t      if (!c->formal)\n+\t\t{\n+\t\t  gfc_error (\"Procedure pointer component '%s' with PASS at %L \"\n+\t\t\t     \"must have at least one argument\",\n+\t\t\t     c->name, &c->loc);\n+\t\t  c->tb->error = 1;\n+\t\t  return FAILURE;\n+\t\t}\n+\t      me_arg = c->formal->sym;\n+\t    }\n+\n+\t  /* Now check that the argument-type matches.  */\n+\t  gcc_assert (me_arg);\n+\t  if (me_arg->ts.type != BT_DERIVED\n+\t      || me_arg->ts.derived != sym)\n+\t    {\n+\t      gfc_error (\"Argument '%s' of '%s' with PASS(%s) at %L must be of\"\n+\t\t\t \" the derived type '%s'\", me_arg->name, c->name,\n+\t\t\t me_arg->name, &c->loc, sym->name);\n+\t      c->tb->error = 1;\n+\t      return FAILURE;\n+\t    }\n+\n+\t  /* Check for C453.  */\n+\t  if (me_arg->attr.dimension)\n+\t    {\n+\t      gfc_error (\"Argument '%s' of '%s' with PASS(%s) at %L \"\n+\t\t\t \"must be scalar\", me_arg->name, c->name, me_arg->name,\n+\t\t\t &c->loc);\n+\t      c->tb->error = 1;\n+\t      return FAILURE;\n+\t    }\n+\n+\t  if (me_arg->attr.pointer)\n+\t    {\n+\t      gfc_error (\"Argument '%s' of '%s' with PASS(%s) at %L \"\n+\t\t\t \"may not have the POINTER attribute\", me_arg->name,\n+\t\t\t c->name, me_arg->name, &c->loc);\n+\t      c->tb->error = 1;\n+\t      return FAILURE;\n+\t    }\n+\n+\t  if (me_arg->attr.allocatable)\n+\t    {\n+\t      gfc_error (\"Argument '%s' of '%s' with PASS(%s) at %L \"\n+\t\t\t \"may not be ALLOCATABLE\", me_arg->name, c->name,\n+\t\t\t me_arg->name, &c->loc);\n+\t      c->tb->error = 1;\n+\t      return FAILURE;\n+\t    }\n+\n+\t  /* TODO: Make this an error once CLASS is implemented.  */\n+\t  if (!sym->attr.sequence)\n+\t    gfc_warning (\"Polymorphic entities are not yet implemented,\"\n+\t\t\t \" non-polymorphic passed-object dummy argument of '%s'\"\n+\t\t\t \" at %L accepted\", c->name, &c->loc);\n+\n+\t}\n+\n       /* Check type-spec if this is not the parent-type component.  */\n       if ((!sym->attr.extension || c != sym->components)\n \t  && resolve_typespec_used (&c->ts, &c->loc, c->name) == FAILURE)"}, {"sha": "ec4afbe020951127fc6d022ef841275147d7542b", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90661f261cdf7b2349d403c4669e0107faad310e/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90661f261cdf7b2349d403c4669e0107faad310e/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=90661f261cdf7b2349d403c4669e0107faad310e", "patch": "@@ -3452,6 +3452,15 @@ verify_bind_c_derived_type (gfc_symbol *derived_sym)\n           retval = FAILURE;\n         }\n \n+      if (curr_comp->attr.proc_pointer != 0)\n+\t{\n+\t  gfc_error (\"Procedure pointer component '%s' at %L cannot be a member\"\n+\t\t     \" of the BIND(C) derived type '%s' at %L\", curr_comp->name,\n+\t\t     &curr_comp->loc, derived_sym->name,\n+\t\t     &derived_sym->declared_at);\n+          retval = FAILURE;\n+        }\n+\n       /* The components cannot be allocatable.\n          J3/04-007, Section 15.2.3, C1505.\t*/\n       if (curr_comp->attr.allocatable != 0)"}, {"sha": "71f3ad9d9afe73c3aa2c1f35f0e20ab0540f67e6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90661f261cdf7b2349d403c4669e0107faad310e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90661f261cdf7b2349d403c4669e0107faad310e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=90661f261cdf7b2349d403c4669e0107faad310e", "patch": "@@ -1,3 +1,14 @@\n+2009-07-25  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/39630\n+\t* gfortran.dg/proc_ptr_comp_3.f90: Modified.\n+\t* gfortran.dg/proc_ptr_comp_pass_1.f90: New.\n+\t* gfortran.dg/proc_ptr_comp_pass_2.f90: New.\n+\t* gfortran.dg/proc_ptr_comp_pass_3.f90: New.\n+\t* gfortran.dg/proc_ptr_comp_pass_4.f90: New.\n+\t* gfortran.dg/proc_ptr_comp_pass_5.f90: New.\n+\t* gfortran.dg/typebound_call_10.f03: New.\n+\n 2009-07-24  Jason Merrill  <jason@redhat.com>\n \n \t* g++.dg/cpp0x/defaulted11.C: New."}, {"sha": "74dd4b8ef6b11b592bf2222ed922972d219054db", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_comp_3.f90", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90661f261cdf7b2349d403c4669e0107faad310e/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90661f261cdf7b2349d403c4669e0107faad310e/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_3.f90?ref=90661f261cdf7b2349d403c4669e0107faad310e", "patch": "@@ -16,7 +16,6 @@ subroutine sub\n external :: aaargh\n \n type :: t\n-  procedure(sub), pointer :: ptr1                ! { dg-error \"not yet implemented\" }\n   procedure(real), pointer, nopass :: ptr2\n   procedure(sub), pointer, nopass :: ptr3\n   procedure(), pointer, nopass ptr4              ! { dg-error \"Expected '::'\" }\n@@ -29,6 +28,10 @@ subroutine sub\n   real :: y\n end type t\n \n+type,bind(c) :: bct                   ! { dg-error \"BIND.C. derived type\" }\n+  procedure(), pointer,nopass :: ptr  ! { dg-error \"cannot be a member of|may not be C interoperable\" }\n+end type bct\n+\n procedure(sub), pointer :: pp\n \n type(t) :: x"}, {"sha": "14a21ec8f53743e8bc0a7e696982eec7c5c33545", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_comp_pass_1.f90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90661f261cdf7b2349d403c4669e0107faad310e/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_pass_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90661f261cdf7b2349d403c4669e0107faad310e/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_pass_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_pass_1.f90?ref=90661f261cdf7b2349d403c4669e0107faad310e", "patch": "@@ -0,0 +1,51 @@\n+! { dg-do run }\n+!\n+! FIXME: Remove -w after polymorphic entities are supported.\n+! { dg-options \"-w\" }\n+!\n+! PR 39630: [F03] Procedure Pointer Components with PASS\n+!\n+! found at http://groups.google.com/group/comp.lang.fortran/browse_thread/thread/4a827e8ced6efb0f/884b9eca6d7e6742\n+\n+module mymod\n+\n+    type :: mytype\n+        integer :: i\n+        procedure(set_int_value), pointer :: seti\n+    end type\n+\n+    abstract interface\n+        subroutine set_int_value(this,i)\n+            import\n+            type(mytype), intent(inout) :: this\n+            integer, intent(in) :: i\n+        end subroutine set_int_value\n+    end interface\n+\n+    contains\n+\n+    subroutine seti_proc(this,i)\n+        type(mytype), intent(inout) :: this\n+        integer, intent(in) :: i\n+        this%i=i\n+    end subroutine seti_proc\n+\n+end module mymod\n+\n+program Test_03\n+    use mymod\n+    implicit none\n+\n+    type(mytype) :: m\n+\n+    m%i = 44\n+    m%seti => seti_proc\n+\n+    call m%seti(6)\n+\n+    if (m%i/=6) call abort()\n+\n+end program Test_03\n+\n+! { dg-final { cleanup-modules \"mymod\" } }\n+"}, {"sha": "c6671a639c95471356df2d9fe899e5a2fb749363", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_comp_pass_2.f90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90661f261cdf7b2349d403c4669e0107faad310e/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_pass_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90661f261cdf7b2349d403c4669e0107faad310e/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_pass_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_pass_2.f90?ref=90661f261cdf7b2349d403c4669e0107faad310e", "patch": "@@ -0,0 +1,51 @@\n+! { dg-do run }\n+!\n+! FIXME: Remove -w after polymorphic entities are supported.\n+! { dg-options \"-w\" }\n+!\n+! PR 39630: [F03] Procedure Pointer Components with PASS\n+!\n+! taken from \"The Fortran 2003 Handbook\" (Adams et al., 2009)\n+\n+module passed_object_example\n+\n+  type t\n+    real :: a\n+    procedure(print_me), pointer, pass(arg) :: proc\n+  end type t\n+\n+contains\n+\n+  subroutine print_me (arg, lun)\n+    type(t), intent(in) :: arg\n+    integer, intent(in) :: lun\n+    if (abs(arg%a-2.718)>1E-6) call abort()\n+    write (lun,*) arg%a\n+  end subroutine print_me\n+\n+  subroutine print_my_square (arg, lun)\n+    type(t), intent(in) :: arg\n+    integer, intent(in) :: lun\n+    if (abs(arg%a-2.718)>1E-6) call abort()\n+    write (lun,*) arg%a**2\n+  end subroutine print_my_square\n+\n+end module passed_object_example\n+\n+\n+program main\n+  use passed_object_example\n+  use iso_fortran_env, only: output_unit\n+\n+  type(t) :: x\n+\n+  x%a = 2.718\n+  x%proc => print_me\n+  call x%proc (output_unit)\n+  x%proc => print_my_square\n+  call x%proc (output_unit)\n+\n+end program main\n+\n+! { dg-final { cleanup-modules \"passed_object_example\" } }\n+"}, {"sha": "15a090425eb0026c8dcd0653481979b2d22f9344", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_comp_pass_3.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90661f261cdf7b2349d403c4669e0107faad310e/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_pass_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90661f261cdf7b2349d403c4669e0107faad310e/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_pass_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_pass_3.f90?ref=90661f261cdf7b2349d403c4669e0107faad310e", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do run }\n+!\n+! FIXME: Remove -w after polymorphic entities are supported.\n+! { dg-options \"-w\" }\n+!\n+! PR 39630: [F03] Procedure Pointer Components with PASS\n+!\n+! taken from \"Fortran 95/2003 explained\" (Metcalf, Reid, Cohen, 2004)\n+\n+type t\n+  procedure(obp), pointer, pass(x) :: p\n+  character(100) :: name\n+end type\n+\n+abstract interface\n+  subroutine obp(w,x)\n+    import :: t\n+    integer :: w\n+    type(t) :: x\n+  end subroutine\n+end interface\n+\n+type(t) :: a\n+a%p => my_obp_sub\n+a%name = \"doodoo\"\n+\n+call a%p(32)\n+\n+contains\n+\n+  subroutine my_obp_sub(w,x)\n+    integer :: w\n+    type(t) :: x\n+    if (x%name/=\"doodoo\") call abort()\n+    if (w/=32) call abort()\n+  end subroutine\n+\n+end\n+"}, {"sha": "b52c810cdf2822f9c03ff7a0be20d9d35d236347", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_comp_pass_4.f90", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90661f261cdf7b2349d403c4669e0107faad310e/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_pass_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90661f261cdf7b2349d403c4669e0107faad310e/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_pass_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_pass_4.f90?ref=90661f261cdf7b2349d403c4669e0107faad310e", "patch": "@@ -0,0 +1,75 @@\n+! { dg-do compile }\n+!\n+! PR 39630: [F03] Procedure Pointer Components with PASS\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+module m\n+\n+ type :: t0\n+  procedure() :: p0  ! { dg-error \"POINTER attribute is required for procedure pointer component\" }\n+ end type\n+\n+ type :: t1\n+  integer :: i\n+  procedure(foo1), pointer :: f1  ! { dg-error \"must be scalar\" }\n+ end type\n+\n+ type :: t2\n+  integer :: i\n+  procedure(foo2), pointer :: f2  ! { dg-error \"may not have the POINTER attribute\" }\n+ end type\n+\n+ type :: t3\n+  integer :: i\n+  procedure(foo3), pointer :: f3  ! { dg-error \"may not be ALLOCATABLE\" }\n+ end type\n+\n+ type :: t4\n+   procedure(),     pass(x), pointer :: f4  ! { dg-error \"NOPASS or explicit interface required\" }\n+   procedure(real), pass(y), pointer :: f5  ! { dg-error \"NOPASS or explicit interface required\" }\n+   procedure(foo6), pass(c), pointer :: f6  ! { dg-error \"has no argument\" }\n+ end type\n+\n+ type :: t7\n+   procedure(foo7), pass, pointer :: f7  ! { dg-error \"must have at least one argument\" }\n+ end type\n+\n+ type :: t8\n+   procedure(foo8), pass, pointer :: f8  ! { dg-error \"must be of the derived type\" }\n+ end type\n+\n+contains\n+\n+ subroutine foo1 (x1,y1)\n+  type(t1) :: x1(:)\n+  type(t1) :: y1\n+ end subroutine\n+\n+ subroutine foo2 (x2,y2)\n+  type(t2),pointer :: x2\n+  type(t2) :: y2\n+ end subroutine\n+\n+ subroutine foo3 (x3,y3)  ! { dg-error \"may not be ALLOCATABLE\" }\n+  type(t3),allocatable :: x3\n+  type(t3) :: y3\n+ end subroutine\n+\n+ real function foo6 (a,b)\n+   real :: a,b\n+   foo6 = 1.\n+ end function\n+\n+ integer function foo7 ()\n+   foo7 = 2\n+ end function\n+\n+ character function foo8 (i)\n+   integer :: i\n+ end function\n+\n+end module m\n+\n+! { dg-final { cleanup-modules \"m\" } }\n+"}, {"sha": "216a554f1104cfaffc7f3b4ca1b0e67033721722", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_comp_pass_5.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90661f261cdf7b2349d403c4669e0107faad310e/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_pass_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90661f261cdf7b2349d403c4669e0107faad310e/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_pass_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_pass_5.f90?ref=90661f261cdf7b2349d403c4669e0107faad310e", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do run }\n+!\n+! PR 39630: [F03] Procedure Pointer Components with PASS\n+!\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+\n+module m\n+ type :: t\n+  sequence\n+  integer :: i\n+  procedure(foo), pointer,pass(y) :: foo\n+ end type t\n+contains\n+ subroutine foo(x,y)\n+  type(t),optional :: x\n+  type(t) :: y\n+  if(present(x)) then\n+    print *, 'foo', x%i, y%i\n+    if (mod(x%i+y%i,3)/=2) call abort()\n+  else\n+    print *, 'foo', y%i\n+    if (mod(y%i,3)/=1) call abort()\n+  end if\n+ end subroutine foo\n+end module m\n+\n+use m\n+type(t) :: t1, t2\n+t1%i = 4\n+t2%i = 7\n+t1%foo => foo\n+t2%foo => t1%foo\n+call t1%foo()\n+call t2%foo()\n+call t2%foo(t1)\n+end\n+\n+! { dg-final { cleanup-modules \"m\" } }\n+"}, {"sha": "29b6401f56b1b137d4d61c1752e7ebb89bfb44d4", "filename": "gcc/testsuite/gfortran.dg/typebound_call_10.f03", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90661f261cdf7b2349d403c4669e0107faad310e/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_10.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90661f261cdf7b2349d403c4669e0107faad310e/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_10.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_10.f03?ref=90661f261cdf7b2349d403c4669e0107faad310e", "patch": "@@ -0,0 +1,42 @@\n+! { dg-do run }\n+!\n+! FIXME: Remove -w after polymorphic entities are supported.\n+! { dg-options \"-w\" }\n+!\n+! PR 39630: [F03] Procedure Pointer Components with PASS\n+!\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+\n+module m\n+\n+ type :: t\n+  integer :: i\n+ contains\n+  procedure, pass(y) :: foo\n+ end type t\n+\n+contains\n+\n+ subroutine foo(x,y)\n+  type(t),optional :: x\n+  type(t) :: y\n+  if(present(x)) then\n+    print *, 'foo', x%i, y%i\n+  else\n+    print *, 'foo', y%i\n+  end if\n+ end subroutine foo\n+\n+end module m\n+\n+use m\n+type(t) :: t1, t2\n+t1%i = 3\n+t2%i = 4\n+call t1%foo()\n+call t2%foo()\n+call t1%foo(t2)\n+end\n+\n+! { dg-final { cleanup-modules \"m\" } }\n+"}]}