{"sha": "7cf078dceaaf3fac20ae6cad5077f9cec6256c8f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2NmMDc4ZGNlYWFmM2ZhYzIwYWU2Y2FkNTA3N2Y5Y2VjNjI1NmM4Zg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2009-10-05T18:19:55Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2009-10-05T18:19:55Z"}, "message": "trans-expr.c (select_class_proc): New function.\n\n2009-10-05  Paul Thomas  <pault@gcc.gnu.org>\n\n\t* trans-expr.c (select_class_proc): New function.\n\t(conv_function_val): Deal with class methods and call above.\n\t* symbol.c (gfc_type_compatible): Treat case where both ts1 and\n\tts2 are BT_CLASS.\n\tgfortran.h : Add structure gfc_class_esym_list and include in\n\tthe structure gfc_expr.\n\t* module.c (load_derived_extensions): New function.\n\t(read_module): Call above.\n\t(write_dt_extensions): New function.\n\t(write_derived_extensions): New function.\n\t(write_module): Use the above.\n\t* resolve.c (resolve_typebound_call): Add a function expression\n\tfor class methods.  This carries the chain of symbols for the\n\tdynamic dispatch in select_class_proc.\n\t(resolve_compcall): Add second, boolean argument to indicate if\n\ta function is being handled.\n\t(check_members): New function.\n\t(check_class_members): New function.\n\t(resolve_class_compcall): New function.\n\t(resolve_class_typebound_call): New function.\n\t(gfc_resolve_expr): Call above for component calls.. \n\n2009-10-05  Paul Thomas  <pault@gcc.gnu.org>\n\n\t* gfortran.dg/dynamic_dispatch_1.f90: New test.\n\t* gfortran.dg/dynamic_dispatch_2.f90: New test.\n\t* gfortran.dg/dynamic_dispatch_3.f90: New test.\n\t* gfortran.dg/module_md5_1.f90: Update md5 sum.\n\nFrom-SVN: r152463", "tree": {"sha": "dcef12f6299ca2279a3958f860cb3333621196ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcef12f6299ca2279a3958f860cb3333621196ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7cf078dceaaf3fac20ae6cad5077f9cec6256c8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cf078dceaaf3fac20ae6cad5077f9cec6256c8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cf078dceaaf3fac20ae6cad5077f9cec6256c8f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cf078dceaaf3fac20ae6cad5077f9cec6256c8f/comments", "author": null, "committer": null, "parents": [{"sha": "e48efd3b2b9cb628b41e8d0e09eac19a66e90ad2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e48efd3b2b9cb628b41e8d0e09eac19a66e90ad2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e48efd3b2b9cb628b41e8d0e09eac19a66e90ad2"}], "stats": {"total": 790, "additions": 778, "deletions": 12}, "files": [{"sha": "24891ab3835e675248daad87a6707a09fe312569", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cf078dceaaf3fac20ae6cad5077f9cec6256c8f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cf078dceaaf3fac20ae6cad5077f9cec6256c8f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=7cf078dceaaf3fac20ae6cad5077f9cec6256c8f", "patch": "@@ -1,3 +1,27 @@\n+2009-10-05  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\t* trans-expr.c (select_class_proc): New function.\n+\t(conv_function_val): Deal with class methods and call above.\n+\t* symbol.c (gfc_type_compatible): Treat case where both ts1 and\n+\tts2 are BT_CLASS.\n+\tgfortran.h : Add structure gfc_class_esym_list and include in\n+\tthe structure gfc_expr.\n+\t* module.c (load_derived_extensions): New function.\n+\t(read_module): Call above.\n+\t(write_dt_extensions): New function.\n+\t(write_derived_extensions): New function.\n+\t(write_module): Use the above.\n+\t* resolve.c (resolve_typebound_call): Add a function expression\n+\tfor class methods.  This carries the chain of symbols for the\n+\tdynamic dispatch in select_class_proc.\n+\t(resolve_compcall): Add second, boolean argument to indicate if\n+\ta function is being handled.\n+\t(check_members): New function.\n+\t(check_class_members): New function.\n+\t(resolve_class_compcall): New function.\n+\t(resolve_class_typebound_call): New function.\n+\t(gfc_resolve_expr): Call above for component calls.. \n+\n 2009-10-05  Daniel Kraft  <d@domob.eu>\n \n \tPR fortran/41403"}, {"sha": "72f0126463011cbd100d02ffb657f547e290cb6c", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cf078dceaaf3fac20ae6cad5077f9cec6256c8f/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cf078dceaaf3fac20ae6cad5077f9cec6256c8f/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=7cf078dceaaf3fac20ae6cad5077f9cec6256c8f", "patch": "@@ -1594,6 +1594,17 @@ typedef struct gfc_intrinsic_sym\n gfc_intrinsic_sym;\n \n \n+typedef struct gfc_class_esym_list\n+{\n+  gfc_symbol *derived;\n+  gfc_symbol *esym;\n+  gfc_symbol *class_object;\n+  struct gfc_class_esym_list *next;\n+}\n+gfc_class_esym_list;\n+\n+#define gfc_get_class_esym_list() XCNEW (gfc_class_esym_list)\n+\n /* Expression nodes.  The expression node types deserve explanations,\n    since the last couple can be easily misconstrued:\n \n@@ -1705,6 +1716,7 @@ typedef struct gfc_expr\n       const char *name;\t/* Points to the ultimate name of the function */\n       gfc_intrinsic_sym *isym;\n       gfc_symbol *esym;\n+      gfc_class_esym_list *class_esym;\n     }\n     function;\n "}, {"sha": "2112d3e82b18e4ea83ff2276fad529a0d9b786bd", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 102, "deletions": 2, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cf078dceaaf3fac20ae6cad5077f9cec6256c8f/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cf078dceaaf3fac20ae6cad5077f9cec6256c8f/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=7cf078dceaaf3fac20ae6cad5077f9cec6256c8f", "patch": "@@ -3972,6 +3972,61 @@ load_equiv (void)\n }\n \n \n+/* This function loads the sym_root of f2k_derived with the extensions to\n+   the derived type.  */\n+static void\n+load_derived_extensions (void)\n+{\n+  int symbol, nuse, j;\n+  gfc_symbol *derived;\n+  gfc_symbol *dt;\n+  gfc_symtree *st;\n+  pointer_info *info;\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n+  char module[GFC_MAX_SYMBOL_LEN + 1];\n+  const char *p;\n+\n+  mio_lparen ();\n+  while (peek_atom () != ATOM_RPAREN)\n+    {\n+      mio_lparen ();\n+      mio_integer (&symbol);\n+      info = get_integer (symbol);\n+      derived = info->u.rsym.sym;\n+\n+      gcc_assert (derived->attr.flavor == FL_DERIVED);\n+      if (derived->f2k_derived == NULL)\n+\tderived->f2k_derived = gfc_get_namespace (NULL, 0);\n+\n+      while (peek_atom () != ATOM_RPAREN)\n+\t{\n+\t  mio_lparen ();\n+\t  mio_internal_string (name);\n+\t  mio_internal_string (module);\n+\n+          /* Only use one use name to find the symbol.  */\n+\t  nuse = number_use_names (name, false);\n+\t  j = 1;\n+\t  p = find_use_name_n (name, &j, false);\n+\t  st = gfc_find_symtree (gfc_current_ns->sym_root, p);\n+\t  dt = st->n.sym;\n+\t  st = gfc_find_symtree (derived->f2k_derived->sym_root, name);\n+\t  if (st == NULL)\n+\t    {\n+\t      /* Only use the real name in f2k_derived to ensure a single\n+\t\t symtree.  */\n+\t      st = gfc_new_symtree (&derived->f2k_derived->sym_root, name);\n+\t      st->n.sym = dt;\n+\t      st->n.sym->refs++;\n+\t    }\n+\t  mio_rparen ();\n+\t}\n+      mio_rparen ();\n+    }\n+  mio_rparen ();\n+}\n+\n+\n /* Recursive function to traverse the pointer_info tree and load a\n    needed symbol.  We return nonzero if we load a symbol and stop the\n    traversal, because the act of loading can alter the tree.  */\n@@ -4113,7 +4168,7 @@ check_for_ambiguous (gfc_symbol *st_sym, pointer_info *info)\n static void\n read_module (void)\n {\n-  module_locus operator_interfaces, user_operators;\n+  module_locus operator_interfaces, user_operators, extensions;\n   const char *p;\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   int i;\n@@ -4130,10 +4185,13 @@ read_module (void)\n   skip_list ();\n   skip_list ();\n \n-  /* Skip commons and equivalences for now.  */\n+  /* Skip commons, equivalences and derived type extensions for now.  */\n   skip_list ();\n   skip_list ();\n \n+  get_module_locus (&extensions);\n+  skip_list ();\n+\n   mio_lparen ();\n \n   /* Create the fixup nodes for all the symbols.  */\n@@ -4386,6 +4444,11 @@ read_module (void)\n \n   gfc_check_interfaces (gfc_current_ns);\n \n+  /* Now we should be in a position to fill f2k_derived with derived type\n+     extensions, since everything has been loaded.  */\n+  set_module_locus (&extensions);\n+  load_derived_extensions ();\n+\n   /* Clean up symbol nodes that were never loaded, create references\n      to hidden symbols.  */\n \n@@ -4594,6 +4657,36 @@ write_equiv (void)\n }\n \n \n+/* Write derived type extensions to the module.  */\n+\n+static void\n+write_dt_extensions (gfc_symtree *st)\n+{\n+  mio_lparen ();\n+  mio_pool_string (&st->n.sym->name);\n+  if (st->n.sym->module != NULL)\n+    mio_pool_string (&st->n.sym->module);\n+  else\n+    mio_internal_string (module_name);\n+  mio_rparen ();\n+}\n+\n+static void\n+write_derived_extensions (gfc_symtree *st)\n+{\n+  if (!((st->n.sym->attr.flavor == FL_DERIVED)\n+\t  && (st->n.sym->f2k_derived != NULL)\n+\t  && (st->n.sym->f2k_derived->sym_root != NULL)))\n+    return;\n+\n+  mio_lparen ();\n+  mio_symbol_ref (&(st->n.sym));\n+  gfc_traverse_symtree (st->n.sym->f2k_derived->sym_root,\n+\t\t\twrite_dt_extensions);\n+  mio_rparen ();\n+}\n+\n+\n /* Write a symbol to the module.  */\n \n static void\n@@ -4820,6 +4913,13 @@ write_module (void)\n   write_char ('\\n');\n   write_char ('\\n');\n \n+  mio_lparen ();\n+  gfc_traverse_symtree (gfc_current_ns->sym_root,\n+\t\t\twrite_derived_extensions);\n+  mio_rparen ();\n+  write_char ('\\n');\n+  write_char ('\\n');\n+\n   /* Write symbol information.  First we traverse all symbols in the\n      primary namespace, writing those that need to be written.\n      Sometimes writing one symbol will cause another to need to be"}, {"sha": "2f0972b04ebbc438243906e82ee7b9111c7723d0", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 224, "deletions": 8, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cf078dceaaf3fac20ae6cad5077f9cec6256c8f/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cf078dceaaf3fac20ae6cad5077f9cec6256c8f/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=7cf078dceaaf3fac20ae6cad5077f9cec6256c8f", "patch": "@@ -4997,28 +4997,42 @@ resolve_typebound_call (gfc_code* c)\n   c->op = (c->expr1->value.compcall.assign ? EXEC_ASSIGN_CALL : EXEC_CALL);\n \n   gcc_assert (!c->expr1->ref && !c->expr1->value.compcall.actual);\n+\n   gfc_free_expr (c->expr1);\n-  c->expr1 = NULL;\n+  c->expr1 = gfc_get_expr ();\n+  c->expr1->expr_type = EXPR_FUNCTION;\n+  c->expr1->symtree = target;\n+  c->expr1->where = c->loc;\n \n   return resolve_call (c);\n }\n \n \n-/* Resolve a component-call expression.  */\n-\n+/* Resolve a component-call expression.  This originally was intended\n+   only to see functions.  However, it is convenient to use it in \n+   resolving subroutine class methods, since we do not have to add a\n+   gfc_code each time. */\n static gfc_try\n-resolve_compcall (gfc_expr* e)\n+resolve_compcall (gfc_expr* e, bool fcn)\n {\n   gfc_actual_arglist* newactual;\n   gfc_symtree* target;\n \n   /* Check that's really a FUNCTION.  */\n-  if (!e->value.compcall.tbp->function)\n+  if (fcn && !e->value.compcall.tbp->function)\n     {\n       gfc_error (\"'%s' at %L should be a FUNCTION\",\n \t\t e->value.compcall.name, &e->where);\n       return FAILURE;\n     }\n+  else if (!fcn && !e->value.compcall.tbp->subroutine)\n+    {\n+      /* To resolve class member calls, we borrow this bit\n+         of code to select the specific procedures.  */\n+      gfc_error (\"'%s' at %L should be a SUBROUTINE\",\n+\t\t e->value.compcall.name, &e->where);\n+      return FAILURE;\n+    }\n \n   /* These must not be assign-calls!  */\n   gcc_assert (!e->value.compcall.assign);\n@@ -5043,12 +5057,207 @@ resolve_compcall (gfc_expr* e)\n   e->value.function.actual = newactual;\n   e->value.function.name = e->value.compcall.name;\n   e->value.function.esym = target->n.sym;\n+  e->value.function.class_esym = NULL;\n   e->value.function.isym = NULL;\n   e->symtree = target;\n   e->ts = target->n.sym->ts;\n   e->expr_type = EXPR_FUNCTION;\n \n-  return gfc_resolve_expr (e);\n+  /* Resolution is not necessary if this is a class subroutine; this\n+     function only has to identify the specific proc. Resolution of\n+     the call will be done next in resolve_typebound_call.  */\n+  return fcn ? gfc_resolve_expr (e) : SUCCESS;\n+}\n+\n+\n+/* Resolve a typebound call for the members in a class.  This group of\n+   functions implements dynamic dispatch in the provisional version\n+   of f03 OOP.  As soon as vtables are in place and contain pointers\n+   to methods, this will no longer be necessary.  */\n+static gfc_expr *list_e;\n+static void check_class_members (gfc_symbol *);\n+static gfc_try class_try;\n+static bool fcn_flag;\n+static gfc_symbol *class_object;\n+\n+\n+static void\n+check_members (gfc_symbol *derived)\n+{\n+  if (derived->attr.flavor == FL_DERIVED)\n+    check_class_members (derived);\n+}\n+\n+\n+static void \n+check_class_members (gfc_symbol *derived)\n+{\n+  gfc_symbol* tbp_sym;\n+  gfc_expr *e;\n+  gfc_symtree *tbp;\n+  gfc_class_esym_list *etmp;\n+\n+  e = gfc_copy_expr (list_e);\n+\n+  tbp = gfc_find_typebound_proc (derived, &class_try,\n+\t\t\t\t e->value.compcall.name,\n+\t\t\t\t false, &e->where);\n+\n+  if (tbp == NULL)\n+    {\n+      gfc_error (\"no typebound available procedure named '%s' at %L\",\n+\t\t e->value.compcall.name, &e->where);\n+      return;\n+    }\n+\n+  if (tbp->n.tb->is_generic)\n+    {\n+      tbp_sym = NULL;\n+\n+      /* If we have to match a passed class member, force the actual\n+\t expression to have the correct type.  */\n+      if (!tbp->n.tb->nopass)\n+\t{\n+\t  if (e->value.compcall.base_object == NULL)\n+\t    e->value.compcall.base_object =\n+\t\t\textract_compcall_passed_object (e);\n+\n+          e->value.compcall.base_object->ts.type = BT_DERIVED;\n+          e->value.compcall.base_object->ts.u.derived = derived;\n+\t}\n+    }\n+  else\n+    tbp_sym = tbp->n.tb->u.specific->n.sym;\n+\n+  e->value.compcall.tbp = tbp->n.tb;\n+  e->value.compcall.name = tbp->name;\n+\n+  /* Do the renaming, PASSing, generic => specific and other\n+     good things for each class member.  */\n+  class_try = (resolve_compcall (e, fcn_flag) == SUCCESS)\n+\t\t\t\t? class_try : FAILURE;\n+\n+  /* Now transfer the found symbol to the esym list.  */\n+  if (class_try == SUCCESS)\n+    {\n+      etmp = list_e->value.function.class_esym;\n+      list_e->value.function.class_esym\n+\t\t= gfc_get_class_esym_list();\n+      list_e->value.function.class_esym->next = etmp;\n+      list_e->value.function.class_esym->derived = derived;\n+      list_e->value.function.class_esym->class_object\n+\t\t= class_object;\n+      list_e->value.function.class_esym->esym\n+\t\t= e->value.function.esym;\n+    }\n+\n+  gfc_free_expr (e);\n+  \n+  /* Burrow down into grandchildren types.  */\n+  if (derived->f2k_derived)\n+    gfc_traverse_ns (derived->f2k_derived, check_members);\n+}\n+\n+\n+/* Eliminate esym_lists where all the members point to the\n+   typebound procedure of the declared type; ie. one where\n+   type selection has no effect..  */\n+static void\n+resolve_class_esym (gfc_expr *e)\n+{\n+  gfc_class_esym_list *p, *q;\n+  bool empty = true;\n+\n+  gcc_assert (e && e->expr_type == EXPR_FUNCTION);\n+\n+  p = e->value.function.class_esym;\n+  if (p == NULL)\n+    return;\n+\n+  for (; p; p = p->next)\n+    empty = empty && (e->value.function.esym == p->esym);\n+\n+  if (empty)\n+    {\n+      p = e->value.function.class_esym;\n+      for (; p; p = q)\n+\t{\n+\t  q = p->next;\n+\t  gfc_free (p);\n+\t}\n+      e->value.function.class_esym = NULL;\n+   }\n+}\n+\n+\n+/* Resolve a CLASS typebound function, or 'method'.  */\n+static gfc_try\n+resolve_class_compcall (gfc_expr* e)\n+{\n+  gfc_symbol *derived;\n+\n+  class_object = e->symtree->n.sym;\n+\n+  /* Get the CLASS type.  */\n+  derived = e->symtree->n.sym->ts.u.derived;\n+\n+  /* Get the data component, which is of the declared type.  */\n+  derived = derived->components->ts.u.derived;\n+\n+  /* Resolve the function call for each member of the class.  */\n+  class_try = SUCCESS;\n+  fcn_flag = true;\n+  list_e = gfc_copy_expr (e);\n+  check_class_members (derived);\n+\n+  class_try = (resolve_compcall (e, true) == SUCCESS)\n+\t\t ? class_try : FAILURE;\n+\n+  /* Transfer the class list to the original expression.  Note that\n+     the class_esym list is cleaned up in trans-expr.c, as the calls\n+     are translated.  */\n+  e->value.function.class_esym = list_e->value.function.class_esym;\n+  list_e->value.function.class_esym = NULL;\n+  gfc_free_expr (list_e);\n+\n+  resolve_class_esym (e);\n+\n+  return class_try;\n+}\n+\n+/* Resolve a CLASS typebound subroutine, or 'method'.  */\n+static gfc_try\n+resolve_class_typebound_call (gfc_code *code)\n+{\n+  gfc_symbol *derived;\n+\n+  class_object = code->expr1->symtree->n.sym;\n+\n+  /* Get the CLASS type.  */\n+  derived = code->expr1->symtree->n.sym->ts.u.derived;\n+\n+  /* Get the data component, which is of the declared type.  */\n+  derived = derived->components->ts.u.derived;\n+\n+  class_try = SUCCESS;\n+  fcn_flag = false;\n+  list_e = gfc_copy_expr (code->expr1);\n+  check_class_members (derived);\n+\n+  class_try = (resolve_typebound_call (code) == SUCCESS)\n+\t\t ? class_try : FAILURE;\n+\n+  /* Transfer the class list to the original expression.  Note that\n+     the class_esym list is cleaned up in trans-expr.c, as the calls\n+     are translated.  */\n+  code->expr1->value.function.class_esym\n+\t\t\t= list_e->value.function.class_esym;\n+  list_e->value.function.class_esym = NULL;\n+  gfc_free_expr (list_e);\n+\n+  resolve_class_esym (code->expr1);\n+\n+  return class_try;\n }\n \n \n@@ -5162,7 +5371,10 @@ gfc_resolve_expr (gfc_expr *e)\n       break;\n \n     case EXPR_COMPCALL:\n-      t = resolve_compcall (e);\n+      if (e->symtree && e->symtree->n.sym->ts.type == BT_CLASS)\n+\tt = resolve_class_compcall (e);\n+      else\n+\tt = resolve_compcall (e, true);\n       break;\n \n     case EXPR_SUBSTRING:\n@@ -7517,7 +7729,11 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \n \tcase EXEC_COMPCALL:\n \tcompcall:\n-\t  resolve_typebound_call (code);\n+\t  if (code->expr1->symtree\n+\t\t&& code->expr1->symtree->n.sym->ts.type == BT_CLASS)\n+\t    resolve_class_typebound_call (code);\n+\t  else\n+\t    resolve_typebound_call (code);\n \t  break;\n \n \tcase EXEC_CALL_PPC:"}, {"sha": "8cd18db0a8fe955a8f5358f06dd8f3959b4ded38", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cf078dceaaf3fac20ae6cad5077f9cec6256c8f/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cf078dceaaf3fac20ae6cad5077f9cec6256c8f/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=7cf078dceaaf3fac20ae6cad5077f9cec6256c8f", "patch": "@@ -4579,9 +4579,12 @@ gfc_type_compatible (gfc_typespec *ts1, gfc_typespec *ts2)\n   if ((ts1->type == BT_DERIVED || ts1->type == BT_CLASS)\n       && (ts2->type == BT_DERIVED || ts2->type == BT_CLASS))\n     {\n-      if (ts1->type == BT_CLASS)\n+      if (ts1->type == BT_CLASS && ts2->type == BT_DERIVED)\n \treturn gfc_type_is_extension_of (ts1->u.derived->components->ts.u.derived,\n \t\t\t\t\t ts2->u.derived);\n+      else if (ts1->type == BT_CLASS && ts2->type == BT_CLASS)\n+\treturn gfc_type_is_extension_of (ts1->u.derived->components->ts.u.derived,\n+\t\t\t\t\t ts2->u.derived->components->ts.u.derived);\n       else if (ts2->type != BT_CLASS)\n \treturn gfc_compare_derived_types (ts1->u.derived, ts2->u.derived);\n       else"}, {"sha": "77953c8e15f79d95fe5678e11a1380055c898497", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cf078dceaaf3fac20ae6cad5077f9cec6256c8f/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cf078dceaaf3fac20ae6cad5077f9cec6256c8f/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=7cf078dceaaf3fac20ae6cad5077f9cec6256c8f", "patch": "@@ -1523,11 +1523,135 @@ get_proc_ptr_comp (gfc_expr *e)\n }\n \n \n+/* Select a class typebound procedure at runtime.  */\n+static void\n+select_class_proc (gfc_se *se, gfc_class_esym_list *elist,\n+\t\t   tree declared, locus *where)\n+{\n+  tree end_label;\n+  tree label;\n+  tree tmp;\n+  tree vindex;\n+  stmtblock_t body;\n+  gfc_class_esym_list *next_elist, *tmp_elist;\n+\n+  /* Calculate the switch expression: class_object.vindex.  */\n+  gcc_assert (elist->class_object->ts.type == BT_CLASS);\n+  tmp = elist->class_object->ts.u.derived->components->next->backend_decl;\n+  vindex = fold_build3 (COMPONENT_REF, TREE_TYPE (tmp),\n+\t\t\telist->class_object->backend_decl,\n+\t\t\ttmp, NULL_TREE);\n+  vindex = gfc_evaluate_now (vindex, &se->pre);\n+\n+  /* Fix the function type to be that of the declared type.  */\n+  declared = gfc_create_var (TREE_TYPE (declared), \"method\");\n+\n+  end_label = gfc_build_label_decl (NULL_TREE);\n+\n+  gfc_init_block (&body);\n+\n+  /* Go through the list of extensions.  */\n+  for (; elist; elist = next_elist)\n+    {\n+      /* This case has already been added.  */\n+      if (elist->derived == NULL)\n+\tgoto free_elist;\n+\n+      /* Run through the chain picking up all the cases that call the\n+\t same procedure.  */\n+      tmp_elist = elist;\n+      for (; elist; elist = elist->next)\n+\t{\n+\t  tree cval;\n+\n+\t  if (elist->esym != tmp_elist->esym)\n+\t    continue;\n+\n+\t  cval = build_int_cst (TREE_TYPE (vindex),\n+\t\t\t\telist->derived->vindex);\n+\t  /* Build a label for the vindex value.  */\n+\t  label = gfc_build_label_decl (NULL_TREE);\n+\t  tmp = fold_build3 (CASE_LABEL_EXPR, void_type_node,\n+\t\t\t     cval, NULL_TREE, label);\n+\t  gfc_add_expr_to_block (&body, tmp);\n+\n+\t  /* Null the reference the derived type so that this case is\n+\t     not used again.  */\n+\t  elist->derived = NULL;\n+\t}\n+\n+      elist = tmp_elist;\n+\n+      /* Get a pointer to the procedure,  */\n+      tmp = gfc_get_symbol_decl (elist->esym);\n+      if (!POINTER_TYPE_P (TREE_TYPE (tmp)))\n+\t{\n+\t  gcc_assert (TREE_CODE (tmp) == FUNCTION_DECL);\n+\t  tmp = gfc_build_addr_expr (NULL_TREE, tmp);\n+\t}\n+\n+      /* Assign the pointer to the appropriate procedure.  */\n+      gfc_add_modify (&body, declared,\n+\t\t      fold_convert (TREE_TYPE (declared), tmp));\n+\n+      /* Break to the end of the construct.  */\n+      tmp = build1_v (GOTO_EXPR, end_label);\n+      gfc_add_expr_to_block (&body, tmp);\n+\n+      /* Free the elists as we go; freeing them in gfc_free_expr causes\n+\t segfaults because it occurs too early and too often.  */\n+    free_elist:\n+      next_elist = elist->next;\n+      gfc_free (elist);\n+      elist = NULL;\n+    }\n+\n+  /* Default is an error.  */\n+  label = gfc_build_label_decl (NULL_TREE);\n+  tmp = fold_build3 (CASE_LABEL_EXPR, void_type_node,\n+\t\t     NULL_TREE, NULL_TREE, label);\n+  gfc_add_expr_to_block (&body, tmp);\n+  tmp = gfc_trans_runtime_error (true, where,\n+\t\t\"internal error: bad vindex in dynamic dispatch\");\n+  gfc_add_expr_to_block (&body, tmp);\n+\n+  /* Write the switch expression.  */\n+  tmp = gfc_finish_block (&body);\n+  tmp = build3_v (SWITCH_EXPR, vindex, tmp, NULL_TREE);\n+  gfc_add_expr_to_block (&se->pre, tmp);\n+\n+  tmp = build1_v (LABEL_EXPR, end_label);\n+  gfc_add_expr_to_block (&se->pre, tmp);\n+\n+  se->expr = declared;\n+  return;\n+}\n+\n+\n static void\n conv_function_val (gfc_se * se, gfc_symbol * sym, gfc_expr * expr)\n {\n   tree tmp;\n \n+  if (expr && expr->symtree\n+\t&& expr->value.function.class_esym)\n+    {\n+      if (!sym->backend_decl)\n+\tsym->backend_decl = gfc_get_extern_function_decl (sym);\n+\n+      tmp = sym->backend_decl;\n+\n+      if (!POINTER_TYPE_P (TREE_TYPE (tmp)))\n+\t{\n+\t  gcc_assert (TREE_CODE (tmp) == FUNCTION_DECL);\n+\t  tmp = gfc_build_addr_expr (NULL_TREE, tmp);\n+\t}\n+\n+      select_class_proc (se, expr->value.function.class_esym,\n+\t\t\t tmp, &expr->where);\n+      return;\n+    }\n+\n   if (gfc_is_proc_ptr_comp (expr, NULL))\n     tmp = get_proc_ptr_comp (expr);\n   else if (sym->attr.dummy)"}, {"sha": "bf1b53217ea69d772d18028dc7ff56966a381f40", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cf078dceaaf3fac20ae6cad5077f9cec6256c8f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cf078dceaaf3fac20ae6cad5077f9cec6256c8f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7cf078dceaaf3fac20ae6cad5077f9cec6256c8f", "patch": "@@ -1,3 +1,10 @@\n+2009-10-05  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\t* gfortran.dg/dynamic_dispatch_1.f90: New test.\n+\t* gfortran.dg/dynamic_dispatch_2.f90: New test.\n+\t* gfortran.dg/dynamic_dispatch_3.f90: New test.\n+\t* gfortran.dg/module_md5_1.f90: Update md5 sum.\n+\n 2009-10-05  Sriraman Tallam  <tmsriram@google.com>\n \n \t* gcc.dg/plugin/selfassign.c (plugin_init): Change plugin_pass to"}, {"sha": "4854b0ff08d5a3f69ccddcea05e46b3b473fa510", "filename": "gcc/testsuite/gfortran.dg/dynamic_dispatch_1.f03", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cf078dceaaf3fac20ae6cad5077f9cec6256c8f/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cf078dceaaf3fac20ae6cad5077f9cec6256c8f/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_1.f03?ref=7cf078dceaaf3fac20ae6cad5077f9cec6256c8f", "patch": "@@ -0,0 +1,84 @@\n+! { dg-do run }\n+! Tests dynamic dispatch of class functions.\n+!\n+! Contributed by Paul Thomas <pault@gcc.gnu.org>\n+!\n+module m\n+  type :: t1\n+    integer :: i = 42\n+    procedure(make_real), pointer :: ptr\n+  contains\n+    procedure, pass :: real => make_real\n+    procedure, pass :: make_integer\n+    procedure, pass :: prod => i_m_j\n+    generic, public :: extract => real, make_integer\n+    generic, public :: base_extract => real, make_integer\n+  end type t1\n+\n+  type, extends(t1) :: t2\n+    integer :: j = 99\n+  contains\n+    procedure, pass :: real => make_real2\n+    procedure, pass :: make_integer_2\n+    procedure, pass :: prod => i_m_j_2\n+    generic, public :: extract => real, make_integer_2\n+  end type t2\n+contains\n+  real function make_real (arg)\n+    class(t1), intent(in) :: arg\n+    make_real = real (arg%i)\n+  end function make_real\n+\n+  real function make_real2 (arg)\n+    class(t2), intent(in) :: arg\n+    make_real2 = real (arg%j)\n+  end function make_real2\n+\n+  integer function make_integer (arg, arg2)\n+    class(t1), intent(in) :: arg\n+    integer :: arg2\n+    make_integer = arg%i * arg2\n+  end function make_integer\n+\n+  integer function make_integer_2 (arg, arg2)\n+    class(t2), intent(in) :: arg\n+    integer :: arg2\n+    make_integer_2 = arg%j * arg2\n+  end function make_integer_2\n+\n+  integer function i_m_j (arg)\n+    class(t1), intent(in) :: arg\n+        i_m_j = arg%i\n+  end function i_m_j\n+\n+  integer function i_m_j_2 (arg)\n+    class(t2), intent(in) :: arg\n+        i_m_j_2 = arg%j\n+  end function i_m_j_2\n+end module m\n+\n+  use m\n+  type, extends(t1) :: l1\n+    character(16) :: chr\n+  end type l1\n+  class(t1), pointer :: a !=> NULL()\n+  type(t1), target :: b\n+  type(t2), target :: c\n+  type(l1), target :: d\n+  a => b                                   ! declared type\n+  if (a%real() .ne. real (42)) call abort\n+  if (a%prod() .ne. 42) call abort\n+  if (a%extract (2) .ne. 84) call abort\n+  if (a%base_extract (2) .ne. 84) call abort\n+  a => c                                   ! extension in module\n+  if (a%real() .ne. real (99)) call abort\n+  if (a%prod() .ne. 99) call abort\n+  if (a%extract (3) .ne. 297) call abort\n+  if (a%base_extract (3) .ne. 126) call abort\n+  a => d                                   ! extension in main\n+  if (a%real() .ne. real (42)) call abort\n+  if (a%prod() .ne. 42) call abort\n+  if (a%extract (4) .ne. 168) call abort\n+  if (a%base_extract (4) .ne. 168) call abort\n+end\n+! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "989a2e0d3f03d03e3e6c3e9d0b7beb53f253873d", "filename": "gcc/testsuite/gfortran.dg/dynamic_dispatch_2.f03", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cf078dceaaf3fac20ae6cad5077f9cec6256c8f/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cf078dceaaf3fac20ae6cad5077f9cec6256c8f/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_2.f03?ref=7cf078dceaaf3fac20ae6cad5077f9cec6256c8f", "patch": "@@ -0,0 +1,105 @@\n+! { dg-do run }\n+! Tests dynamic dispatch of class subroutines.\n+!\n+! Contributed by Paul Thomas <pault@gcc.gnu.org>\n+!\n+module m\n+  type :: t1\n+    integer :: i = 42\n+    procedure(make_real), pointer :: ptr\n+  contains\n+    procedure, pass :: real => make_real\n+    procedure, pass :: make_integer\n+    procedure, pass :: prod => i_m_j\n+    generic, public :: extract => real, make_integer\n+    generic, public :: base_extract => real, make_integer\n+  end type t1\n+\n+  type, extends(t1) :: t2\n+    integer :: j = 99\n+  contains\n+    procedure, pass :: real => make_real2\n+    procedure, pass :: make_integer_2\n+    procedure, pass :: prod => i_m_j_2\n+    generic, public :: extract => real, make_integer_2\n+  end type t2\n+contains\n+  subroutine make_real (arg, arg2)\n+    class(t1), intent(in) :: arg\n+    real :: arg2\n+    arg2 = real (arg%i)\n+  end subroutine make_real\n+\n+  subroutine make_real2 (arg, arg2)\n+    class(t2), intent(in) :: arg\n+    real :: arg2\n+    arg2 = real (arg%j)\n+  end subroutine make_real2\n+\n+  subroutine make_integer (arg, arg2, arg3)\n+    class(t1), intent(in) :: arg\n+    integer :: arg2, arg3\n+    arg3 = arg%i * arg2\n+  end subroutine make_integer\n+\n+  subroutine make_integer_2 (arg, arg2, arg3)\n+    class(t2), intent(in) :: arg\n+    integer :: arg2, arg3\n+    arg3 = arg%j * arg2\n+  end subroutine make_integer_2\n+\n+  subroutine i_m_j (arg, arg2)\n+    class(t1), intent(in) :: arg\n+    integer :: arg2\n+        arg2 = arg%i\n+  end subroutine i_m_j\n+\n+  subroutine i_m_j_2 (arg, arg2)\n+    class(t2), intent(in) :: arg\n+    integer :: arg2\n+        arg2 = arg%j\n+  end subroutine i_m_j_2\n+end module m\n+\n+  use m\n+  type, extends(t1) :: l1\n+    character(16) :: chr\n+  end type l1\n+  class(t1), pointer :: a !=> NULL()\n+  type(t1), target :: b\n+  type(t2), target :: c\n+  type(l1), target :: d\n+  real :: r\n+  integer :: i\n+\n+  a => b                                   ! declared type\n+  call a%real(r)\n+  if (r .ne. real (42)) call abort\n+  call a%prod(i)\n+  if (i .ne. 42) call abort\n+  call a%extract (2, i)\n+  if (i .ne. 84) call abort\n+  call a%base_extract (2, i)\n+  if (i .ne. 84) call abort\n+\n+  a => c                                   ! extension in module\n+  call a%real(r)\n+  if (r .ne. real (99)) call abort\n+  call a%prod(i)\n+  if (i .ne. 99) call abort\n+  call a%extract (3, i)\n+  if (i .ne. 297) call abort\n+  call a%base_extract (3, i)\n+  if (i .ne. 126) call abort\n+\n+  a => d                                   ! extension in main\n+  call a%real(r)\n+  if (r .ne. real (42)) call abort\n+  call a%prod(i)\n+  if (i .ne. 42) call abort\n+  call a%extract (4, i)\n+  if (i .ne. 168) call abort\n+  call a%extract (4, i)\n+  if (i .ne. 168) call abort\n+end\n+! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "aa8713ef4d4afe5162aed50642c78694cd548379", "filename": "gcc/testsuite/gfortran.dg/dynamic_dispatch_3.f03", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cf078dceaaf3fac20ae6cad5077f9cec6256c8f/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cf078dceaaf3fac20ae6cad5077f9cec6256c8f/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_3.f03?ref=7cf078dceaaf3fac20ae6cad5077f9cec6256c8f", "patch": "@@ -0,0 +1,91 @@\n+! { dg-do run }\n+! Tests dynamic dispatch of class functions, spread over\n+! different modules. Apart from the location of the derived\n+! type declarations, this test is the same as\n+! dynamic_dispatch_1.f03\n+!\n+! Contributed by Paul Thomas <pault@gcc.gnu.org>\n+!\n+module m1\n+  type :: t1\n+    integer :: i = 42\n+    procedure(make_real), pointer :: ptr\n+  contains\n+    procedure, pass :: real => make_real\n+    procedure, pass :: make_integer\n+    procedure, pass :: prod => i_m_j\n+    generic, public :: extract => real, make_integer\n+    generic, public :: base_extract => real, make_integer\n+  end type t1\n+contains\n+  real function make_real (arg)\n+    class(t1), intent(in) :: arg\n+    make_real = real (arg%i)\n+  end function make_real\n+\n+  integer function make_integer (arg, arg2)\n+    class(t1), intent(in) :: arg\n+    integer :: arg2\n+    make_integer = arg%i * arg2\n+  end function make_integer\n+\n+  integer function i_m_j (arg)\n+    class(t1), intent(in) :: arg\n+        i_m_j = arg%i\n+  end function i_m_j\n+end module m1\n+\n+module m2\n+  use m1\n+  type, extends(t1) :: t2\n+    integer :: j = 99\n+  contains\n+    procedure, pass :: real => make_real2\n+    procedure, pass :: make_integer_2\n+    procedure, pass :: prod => i_m_j_2\n+    generic, public :: extract => real, make_integer_2\n+  end type t2\n+contains\n+  real function make_real2 (arg)\n+    class(t2), intent(in) :: arg\n+    make_real2 = real (arg%j)\n+  end function make_real2\n+\n+  integer function make_integer_2 (arg, arg2)\n+    class(t2), intent(in) :: arg\n+    integer :: arg2\n+    make_integer_2 = arg%j * arg2\n+  end function make_integer_2\n+\n+  integer function i_m_j_2 (arg)\n+    class(t2), intent(in) :: arg\n+        i_m_j_2 = arg%j\n+  end function i_m_j_2\n+end module m2\n+\n+  use m1\n+  use m2\n+  type, extends(t1) :: l1\n+    character(16) :: chr\n+  end type l1\n+  class(t1), pointer :: a !=> NULL()\n+  type(t1), target :: b\n+  type(t2), target :: c\n+  type(l1), target :: d\n+  a => b                                   ! declared type in module m1\n+  if (a%real() .ne. real (42)) call abort\n+  if (a%prod() .ne. 42) call abort\n+  if (a%extract (2) .ne. 84) call abort\n+  if (a%base_extract (2) .ne. 84) call abort\n+  a => c                                   ! extension in module m2\n+  if (a%real() .ne. real (99)) call abort\n+  if (a%prod() .ne. 99) call abort\n+  if (a%extract (3) .ne. 297) call abort\n+  if (a%base_extract (3) .ne. 126) call abort\n+  a => d                                   ! extension in main\n+  if (a%real() .ne. real (42)) call abort\n+  if (a%prod() .ne. 42) call abort\n+  if (a%extract (4) .ne. 168) call abort\n+  if (a%base_extract (4) .ne. 168) call abort\n+end\n+! { dg-final { cleanup-modules \"m1, m2\" } }"}, {"sha": "88002c204bfd2c4c324820378d86baa4e0afa0e2", "filename": "gcc/testsuite/gfortran.dg/module_md5_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cf078dceaaf3fac20ae6cad5077f9cec6256c8f/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_md5_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cf078dceaaf3fac20ae6cad5077f9cec6256c8f/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_md5_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_md5_1.f90?ref=7cf078dceaaf3fac20ae6cad5077f9cec6256c8f", "patch": "@@ -10,5 +10,5 @@ program test\n   use foo\n   print *, pi\n end program test\n-! { dg-final { scan-module \"foo\" \"MD5:dc2fd1358dcaddc25e3c89dae859ef32\" } }\n+! { dg-final { scan-module \"foo\" \"MD5:9c43cf4d713824ec6894b83250720e68\" } }\n ! { dg-final { cleanup-modules \"foo\" } }"}]}