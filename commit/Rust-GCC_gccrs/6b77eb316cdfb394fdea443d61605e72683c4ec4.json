{"sha": "6b77eb316cdfb394fdea443d61605e72683c4ec4", "node_id": "C_kwDOANBUbNoAKDZiNzdlYjMxNmNkZmIzOTRmZGVhNDQzZDYxNjA1ZTcyNjgzYzRlYzQ", "commit": {"author": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2023-03-16T21:03:34Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2023-03-18T00:15:08Z"}, "message": "gccrs: Add move_val_init intrinsic\n\nThis implements it as a builtin memcpy using the generic param T for the\nsize hint.\n\nFixes #1902\n\ngcc/rust/ChangeLog:\n\n\t* backend/rust-compile-intrinsic.cc (move_val_init_handler): new intrinsice\n\t(uninit_handler): use a builtin memcpy\n\ngcc/testsuite/ChangeLog:\n\n\t* rust/compile/issue-1981.rs: New test.\n\nSigned-off-by: Philip Herron <herron.philip@googlemail.com>", "tree": {"sha": "5a609127ddc3f6d0a0231be612f906ce9fe525d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a609127ddc3f6d0a0231be612f906ce9fe525d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b77eb316cdfb394fdea443d61605e72683c4ec4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b77eb316cdfb394fdea443d61605e72683c4ec4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b77eb316cdfb394fdea443d61605e72683c4ec4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b77eb316cdfb394fdea443d61605e72683c4ec4/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "858fd17fcf9aeddd9392d480c19471aaac891e5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/858fd17fcf9aeddd9392d480c19471aaac891e5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/858fd17fcf9aeddd9392d480c19471aaac891e5f"}], "stats": {"total": 188, "additions": 187, "deletions": 1}, "files": [{"sha": "b9951a07974ef29705baccb4c1c37dad757db003", "filename": "gcc/rust/backend/rust-compile-intrinsic.cc", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b77eb316cdfb394fdea443d61605e72683c4ec4/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b77eb316cdfb394fdea443d61605e72683c4ec4/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc?ref=6b77eb316cdfb394fdea443d61605e72683c4ec4", "patch": "@@ -83,6 +83,8 @@ static tree\n op_with_overflow_inner (Context *ctx, TyTy::FnType *fntype, tree_code op);\n static tree\n uninit_handler (Context *ctx, TyTy::FnType *fntype);\n+static tree\n+move_val_init_handler (Context *ctx, TyTy::FnType *fntype);\n \n enum class Prefetch\n {\n@@ -205,6 +207,7 @@ static const std::map<std::string,\n     {\"unchecked_shl\", unchecked_op_handler (LSHIFT_EXPR)},\n     {\"unchecked_shr\", unchecked_op_handler (RSHIFT_EXPR)},\n     {\"uninit\", uninit_handler},\n+    {\"move_val_init\", move_val_init_handler},\n };\n \n Intrinsics::Intrinsics (Context *ctx) : ctx (ctx) {}\n@@ -1001,7 +1004,7 @@ uninit_handler (Context *ctx, TyTy::FnType *fntype)\n \n   auto fndecl = compile_intrinsic_function (ctx, fntype);\n \n-  // get the template parameter type tree fn size_of<T>();\n+  // get the template parameter type tree fn uninit<T>();\n   rust_assert (fntype->get_num_substitutions () == 1);\n   auto &param_mapping = fntype->get_substs ().at (0);\n   const TyTy::ParamType *param_tyty = param_mapping.get_param_ty ();\n@@ -1042,5 +1045,56 @@ uninit_handler (Context *ctx, TyTy::FnType *fntype)\n   return fndecl;\n }\n \n+static tree\n+move_val_init_handler (Context *ctx, TyTy::FnType *fntype)\n+{\n+  rust_assert (fntype->get_params ().size () == 2);\n+\n+  tree lookup = NULL_TREE;\n+  if (check_for_cached_intrinsic (ctx, fntype, &lookup))\n+    return lookup;\n+\n+  auto fndecl = compile_intrinsic_function (ctx, fntype);\n+\n+  // get the template parameter type tree fn size_of<T>();\n+  rust_assert (fntype->get_num_substitutions () == 1);\n+  auto &param_mapping = fntype->get_substs ().at (0);\n+  const TyTy::ParamType *param_tyty = param_mapping.get_param_ty ();\n+  TyTy::BaseType *resolved_tyty = param_tyty->resolve ();\n+  tree template_parameter_type\n+    = TyTyResolveCompile::compile (ctx, resolved_tyty);\n+\n+  std::vector<Bvariable *> param_vars;\n+  compile_fn_params (ctx, fntype, fndecl, &param_vars);\n+\n+  if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n+    return error_mark_node;\n+\n+  enter_intrinsic_block (ctx, fndecl);\n+\n+  // BUILTIN size_of FN BODY BEGIN\n+\n+  tree dst = ctx->get_backend ()->var_expression (param_vars[0], Location ());\n+  tree src = ctx->get_backend ()->var_expression (param_vars[1], Location ());\n+  tree size = TYPE_SIZE_UNIT (template_parameter_type);\n+\n+  tree memcpy_builtin = error_mark_node;\n+  BuiltinsContext::get ().lookup_simple_builtin (\"memcpy\", &memcpy_builtin);\n+  rust_assert (memcpy_builtin != error_mark_node);\n+\n+  src = build_fold_addr_expr_loc (BUILTINS_LOCATION, src);\n+  tree memset_call = build_call_expr_loc (BUILTINS_LOCATION, memcpy_builtin, 3,\n+\t\t\t\t\t  dst, src, size);\n+  TREE_READONLY (memset_call) = 0;\n+  TREE_SIDE_EFFECTS (memset_call) = 1;\n+\n+  ctx->add_statement (memset_call);\n+  // BUILTIN size_of FN BODY END\n+\n+  finalize_intrinsic_block (ctx, fndecl);\n+\n+  return fndecl;\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "e3f17238100625435d6b3eb0b00bd494c1049c3a", "filename": "gcc/testsuite/rust/compile/issue-1981.rs", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b77eb316cdfb394fdea443d61605e72683c4ec4/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1981.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b77eb316cdfb394fdea443d61605e72683c4ec4/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1981.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1981.rs?ref=6b77eb316cdfb394fdea443d61605e72683c4ec4", "patch": "@@ -0,0 +1,132 @@\n+mod intrinsics {\n+    extern \"rust-intrinsic\" {\n+        pub fn offset<T>(ptr: *const T, count: isize) -> *const T;\n+        pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n+        pub fn move_val_init<T>(dst: *mut T, src: T);\n+        pub fn uninit<T>() -> T;\n+    }\n+}\n+\n+mod ptr {\n+    #[lang = \"const_ptr\"]\n+    impl<T> *const T {\n+        pub unsafe fn offset(self, count: isize) -> *const T {\n+            intrinsics::offset(self, count)\n+        }\n+    }\n+\n+    #[lang = \"mut_ptr\"]\n+    impl<T> *mut T {\n+        pub unsafe fn offset(self, count: isize) -> *mut T {\n+            intrinsics::offset(self, count) as *mut T\n+        }\n+    }\n+\n+    pub unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\n+        let x = x as *mut T;\n+        let y = y as *mut T;\n+        let len = mem::size_of::<T>() * count;\n+        swap_nonoverlapping_bytes(x, y, len)\n+    }\n+\n+    pub unsafe fn swap_nonoverlapping_one<T>(x: *mut T, y: *mut T) {\n+        // For types smaller than the block optimization below,\n+        // just swap directly to avoid pessimizing codegen.\n+        if mem::size_of::<T>() < 32 {\n+            let z = read(x);\n+            intrinsics::copy_nonoverlapping(y, x, 1);\n+            write(y, z);\n+        } else {\n+            swap_nonoverlapping(x, y, 1);\n+        }\n+    }\n+\n+    pub unsafe fn write<T>(dst: *mut T, src: T) {\n+        intrinsics::move_val_init(&mut *dst, src)\n+    }\n+\n+    pub unsafe fn read<T>(src: *const T) -> T {\n+        let mut tmp: T = mem::uninitialized();\n+        intrinsics::copy_nonoverlapping(src, &mut tmp, 1);\n+        tmp\n+    }\n+\n+    unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n+        struct Block(u64, u64, u64, u64);\n+        struct UnalignedBlock(u64, u64, u64, u64);\n+\n+        let block_size = mem::size_of::<Block>();\n+\n+        // Loop through x & y, copying them `Block` at a time\n+        // The optimizer should unroll the loop fully for most types\n+        // N.B. We can't use a for loop as the `range` impl calls `mem::swap` recursively\n+        let mut i = 0;\n+        while i + block_size <= len {\n+            // Create some uninitialized memory as scratch space\n+            // Declaring `t` here avoids aligning the stack when this loop is unused\n+            let mut t: Block = mem::uninitialized();\n+            let t = &mut t as *mut _ as *mut u8;\n+            let x = x.offset(i as isize);\n+            let y = y.offset(i as isize);\n+\n+            // Swap a block of bytes of x & y, using t as a temporary buffer\n+            // This should be optimized into efficient SIMD operations where available\n+            intrinsics::copy_nonoverlapping(x, t, block_size);\n+            intrinsics::copy_nonoverlapping(y, x, block_size);\n+            intrinsics::copy_nonoverlapping(t, y, block_size);\n+            i += block_size;\n+        }\n+\n+        if i < len {\n+            // Swap any remaining bytes\n+            let mut t: UnalignedBlock = mem::uninitialized();\n+            let rem = len - i;\n+\n+            let t = &mut t as *mut _ as *mut u8;\n+            let x = x.offset(i as isize);\n+            let y = y.offset(i as isize);\n+\n+            intrinsics::copy_nonoverlapping(x, t, rem);\n+            intrinsics::copy_nonoverlapping(y, x, rem);\n+            intrinsics::copy_nonoverlapping(t, y, rem);\n+        }\n+    }\n+}\n+\n+mod mem {\n+    extern \"rust-intrinsic\" {\n+        pub fn transmute<T, U>(_: T) -> U;\n+        pub fn size_of<T>() -> usize;\n+    }\n+\n+    pub fn swap<T>(x: &mut T, y: &mut T) {\n+        unsafe {\n+            ptr::swap_nonoverlapping_one(x, y);\n+        }\n+    }\n+\n+    pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n+        swap(dest, &mut src);\n+        src\n+    }\n+\n+    pub unsafe fn uninitialized<T>() -> T {\n+        intrinsics::uninit()\n+    }\n+}\n+\n+trait Step {\n+    fn replace_zero(&mut self) -> Self;\n+}\n+\n+impl Step for i32 {\n+    fn replace_zero(&mut self) -> Self {\n+        mem::replace(self, 0)\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let a = 123;\n+    a.replace_zero();\n+    a\n+}"}]}