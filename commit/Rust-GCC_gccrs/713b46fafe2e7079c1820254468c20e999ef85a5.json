{"sha": "713b46fafe2e7079c1820254468c20e999ef85a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzEzYjQ2ZmFmZTJlNzA3OWMxODIwMjU0NDY4YzIwZTk5OWVmODVhNQ==", "commit": {"author": {"name": "Balaji V. Iyer", "email": "balaji.v.iyer@intel.com", "date": "2013-06-25T20:41:21Z"}, "committer": {"name": "Balaji V. Iyer", "email": "bviyer@gcc.gnu.org", "date": "2013-06-25T20:41:21Z"}, "message": "Replaced Dynamic arrays with vec trees in Array Notation for C.\n\ngcc/c-family/ChangeLog\n2013-06-21  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n\n        * array-notation-common.c (length_mismatch_in_expr): Changed the\n        parameter type's from a dynamic array to a vec_tree.  Also removed\n        the size parameters.\n        * c-common.h (length_mismatch_in_expr_p): Fixed prototype's as per\n        the change above.\n\ngcc/cp/ChangeLog\n2013-06-21  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n\n        * cp-array-notation.c (cp_length_mismatch_in_expr_p): Remove.\n        (expand_an_in_modify_expr): Changed a function call from the above\n        removed function to length_mismatch_in_expr_p.\n\ngcc/c/ChangeLog\n2013-06-21  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n\n        * c-array-notation.c (make_triplet_val_inv): New function.\n        (create_cmp_incr): Likewise.\n        (create_array_refs): Likewise.\n        (fix_builtin_array_notation_fn): Replaced all mallocs with tree vec.\n        Also modularized common parts between functions and called the function.\n        (build_array_notation_expr): Likewise.\n        (fix_conditional_array_notations_1): Likewise.\n        (fix_array_notation_expr): Likewise.\n        (fix_array_notation_call_expr): Likewise.\n\nFrom-SVN: r200405", "tree": {"sha": "d0304bbb6ee06694d451892f81119e01d2141350", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0304bbb6ee06694d451892f81119e01d2141350"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/713b46fafe2e7079c1820254468c20e999ef85a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/713b46fafe2e7079c1820254468c20e999ef85a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/713b46fafe2e7079c1820254468c20e999ef85a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/713b46fafe2e7079c1820254468c20e999ef85a5/comments", "author": null, "committer": null, "parents": [{"sha": "818cac82f73e867779c7c62c42f256d9983ef5d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/818cac82f73e867779c7c62c42f256d9983ef5d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/818cac82f73e867779c7c62c42f256d9983ef5d1"}], "stats": {"total": 1719, "additions": 338, "deletions": 1381}, "files": [{"sha": "bc73a809a555a3ff9a75249050d0c5e0dc7fc3c1", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713b46fafe2e7079c1820254468c20e999ef85a5/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713b46fafe2e7079c1820254468c20e999ef85a5/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=713b46fafe2e7079c1820254468c20e999ef85a5", "patch": "@@ -4,6 +4,14 @@\n \t* c-cppbuiltin.c (c_cpp_builtins): Likewise.\n \t* c-opts.c (c_common_post_options): Likewise.\n \n+2013-06-21  Balaji V. Iyer  <balaji.v.iyer@intel.com>  \n+\n+\t* array-notation-common.c (length_mismatch_in_expr): Changed the\n+\tparameter type's from a dynamic array to a vec_tree.  Also removed\n+\tthe size parameters.\n+\t* c-common.h (length_mismatch_in_expr_p): Fixed prototype's as per\n+\tthe change above.\n+\n 2013-06-21  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n \n \t* c-common.h (struct cilkplus_an_parts): New structure."}, {"sha": "8eab89ba6fbc5c726d9e85c5df732ca20cb83331", "filename": "gcc/c-family/array-notation-common.c", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713b46fafe2e7079c1820254468c20e999ef85a5/gcc%2Fc-family%2Farray-notation-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713b46fafe2e7079c1820254468c20e999ef85a5/gcc%2Fc-family%2Farray-notation-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Farray-notation-common.c?ref=713b46fafe2e7079c1820254468c20e999ef85a5", "patch": "@@ -75,45 +75,47 @@ extract_sec_implicit_index_arg (location_t location, tree fn)\n   return return_int;\n }\n \n-/* Returns true if there is length mismatch among expressions\n-   on the same dimension and on the same side of the equal sign.  The\n-   expressions (or ARRAY_NOTATION lengths) are passed in through 2-D array\n-   **LIST where X and Y indicate first and second dimension sizes of LIST,\n-   respectively.  */\n+/* Returns true if there is a length mismatch among exprssions that are at the\n+   same dimension and one the same side of the equal sign.  The Array notation\n+   lengths (LIST->LENGTH) is passed in as a 2D vector of trees.  */\n \n bool\n-length_mismatch_in_expr_p (location_t loc, tree **list, size_t x, size_t y)\n+length_mismatch_in_expr_p (location_t loc, vec<vec<an_parts> >list)\n {\n   size_t ii, jj;\n-  tree start = NULL_TREE;\n-  HOST_WIDE_INT l_start, l_node;\n+  tree length = NULL_TREE;\n+  HOST_WIDE_INT l_length, l_node;\n+  \n+  size_t x = list.length ();\n+  size_t y = list[0].length ();\n+  \n   for (jj = 0; jj < y; jj++)\n     {\n-      start = NULL_TREE;\n+      length = NULL_TREE;\n       for (ii = 0; ii < x; ii++)\n \t{\n-\t  if (!start)\n-\t    start = list[ii][jj];\n-\t  else if (TREE_CODE (start) == INTEGER_CST)\n+\t  if (!length)\n+\t    length = list[ii][jj].length;\n+\t  else if (TREE_CODE (length) == INTEGER_CST)\n \t    {\n-\t      /* If start is a INTEGER, and list[ii][jj] is an integer then\n+\t      /* If length is a INTEGER, and list[ii][jj] is an integer then\n \t\t check if they are equal.  If they are not equal then return\n \t\t true.  */\n-\t      if (TREE_CODE (list[ii][jj]) == INTEGER_CST)\n+\t      if (TREE_CODE (list[ii][jj].length) == INTEGER_CST)\n \t\t{\n-\t\t  l_node = int_cst_value (list[ii][jj]);\n-\t\t  l_start = int_cst_value (start);\n-\t\t  if (absu_hwi (l_start) != absu_hwi (l_node))\n+\t\t  l_node = int_cst_value (list[ii][jj].length);\n+\t\t  l_length = int_cst_value (length);\n+\t\t  if (absu_hwi (l_length) != absu_hwi (l_node))\n \t\t    {\n \t\t      error_at (loc, \"length mismatch in expression\");\n \t\t      return true;\n \t\t    }\n \t\t}\n \t    }\n \t  else\n-\t    /* We set the start node as the current node just in case it turns\n+\t    /* We set the length node as the current node just in case it turns\n \t       out to be an integer.  */\n-\t    start = list[ii][jj];\n+\t    length = list[ii][jj].length;\n \t}\n     }\n   return false;"}, {"sha": "625c3011460c5d0a00c4fdc03ae63bcca091bc55", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713b46fafe2e7079c1820254468c20e999ef85a5/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713b46fafe2e7079c1820254468c20e999ef85a5/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=713b46fafe2e7079c1820254468c20e999ef85a5", "patch": "@@ -1193,7 +1193,7 @@ extern bool contains_array_notation_expr (tree);\n extern tree expand_array_notation_exprs (tree);\n extern tree fix_conditional_array_notations (tree);\n extern tree find_correct_array_notation_type (tree);\n-extern bool length_mismatch_in_expr_p (location_t, tree **, size_t, size_t);\n+extern bool length_mismatch_in_expr_p (location_t, vec<vec<an_parts> >);\n extern enum built_in_function is_cilkplus_reduce_builtin (tree);\n extern bool find_rank (location_t, tree, tree, bool, size_t *);\n extern void extract_array_notation_exprs (tree, bool, vec<tree, va_gc> **);"}, {"sha": "313fa7e96bc971662248495c2bbc830bfa80310e", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713b46fafe2e7079c1820254468c20e999ef85a5/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713b46fafe2e7079c1820254468c20e999ef85a5/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=713b46fafe2e7079c1820254468c20e999ef85a5", "patch": "@@ -1,3 +1,15 @@\n+2013-06-21  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n+\n+\t* c-array-notation.c (make_triplet_val_inv): New function.\n+\t(create_cmp_incr): Likewise.\n+\t(create_array_refs): Likewise.\n+\t(fix_builtin_array_notation_fn): Replaced all mallocs with tree vec.\n+\tAlso modularized common parts between functions and called the function.\n+\t(build_array_notation_expr): Likewise.\n+\t(fix_conditional_array_notations_1): Likewise.\n+\t(fix_array_notation_expr): Likewise.\n+\t(fix_array_notation_call_expr): Likewise.\n+\n 2013-06-18  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/57630"}, {"sha": "7788f7bf145e25ed759c301ee9ba81e90367f92e", "filename": "gcc/c/c-array-notation.c", "status": "modified", "additions": 287, "deletions": 1312, "changes": 1599, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713b46fafe2e7079c1820254468c20e999ef85a5/gcc%2Fc%2Fc-array-notation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713b46fafe2e7079c1820254468c20e999ef85a5/gcc%2Fc%2Fc-array-notation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-array-notation.c?ref=713b46fafe2e7079c1820254468c20e999ef85a5", "patch": "@@ -74,6 +74,83 @@\n #include \"opts.h\"\n #include \"c-family/c-common.h\"\n \n+/* If *VALUE is not of type INTEGER_CST, PARM_DECL or VAR_DECL, then map it\n+   to a variable and then set *VALUE to the new variable.  */\n+\n+static inline void\n+make_triplet_val_inv (location_t loc, tree *value)\n+{\n+  tree var, new_exp;\n+  if (TREE_CODE (*value) != INTEGER_CST\n+      && TREE_CODE (*value) != PARM_DECL\n+      && TREE_CODE (*value) != VAR_DECL)\n+    {\n+      var = build_decl (loc, VAR_DECL, NULL_TREE, integer_type_node);\n+      new_exp = build_modify_expr (loc, var, TREE_TYPE (var), NOP_EXPR, loc,\n+\t\t\t\t   *value, TREE_TYPE (*value));\n+      add_stmt (new_exp);\n+      *value = var;\n+    }\n+}\n+\n+/* Populates the INCR and CMP vectors with the increment (of type POSTINCREMENT\n+   or POSTDECREMENT) and comparison (of TYPE GT_EXPR or LT_EXPR) expressions,\n+   using data from LENGTH, COUNT_DOWN, and VAR.  INCR and CMP vectors are of\n+   size RANK.  */\n+\n+static void\n+create_cmp_incr (location_t loc, vec<an_loop_parts> *node, size_t rank,\n+\t\t vec<vec<an_parts> > an_info)\n+{\n+  for (size_t ii = 0; ii < rank; ii++)\n+    {\n+      tree var = (*node)[ii].var;\n+      tree length = an_info[0][ii].length;\n+      (*node)[ii].incr = build_unary_op (loc, POSTINCREMENT_EXPR, var, 0);\n+      (*node)[ii].cmp = build2 (LT_EXPR, boolean_type_node, var, length);\n+    }\n+}\n+\n+/* Returns a vector of size RANK that contains an array ref that is derived from\n+   array notation triplet parameters stored in VALUE, START, STRIDE.  IS_VECTOR\n+   is used to check if the data stored at its corresponding location is an\n+   array notation. VAR is the induction variable passed in by the caller.\n+\n+   For example: For an array notation A[5:10:2], the vector start  will be\n+   of size 1 holding '5', stride of same size as start but holding the value of\n+   as 2, is_vector as true and count_down as false. Let's assume VAR is 'x'\n+   This function returns a vector of size 1 with the following data:\n+   A[5 + (x * 2)] .\n+*/\n+\n+static vec<tree, va_gc> *\n+create_array_refs (location_t loc, vec<vec<an_parts> > an_info,\n+\t\t   vec<an_loop_parts> an_loop_info, size_t size, size_t rank)\n+{\n+  tree ind_mult, ind_incr;\n+  vec<tree, va_gc> *array_operand = NULL;\n+  for (size_t ii = 0; ii < size; ii++)\n+    if (an_info[ii][0].is_vector)\n+      {\n+\ttree array_opr = an_info[ii][rank - 1].value;\n+\tfor (int s_jj = rank - 1; s_jj >= 0; s_jj--)\n+\t  {\n+\t    tree var = an_loop_info[s_jj].var;\n+\t    tree stride = an_info[ii][s_jj].stride;\n+\t    tree start = an_info[ii][s_jj].start;\n+\t    ind_mult = build2 (MULT_EXPR, TREE_TYPE (var), var, stride);\n+\t    ind_incr = build2 (PLUS_EXPR, TREE_TYPE (var), start, ind_mult);\n+\t    array_opr = build_array_ref (loc, array_opr, ind_incr);\n+\t  }\n+\tvec_safe_push (array_operand, array_opr);\n+      }\n+    else\n+      /* This is just a dummy node to make sure both the list sizes for both\n+\t array list and array operand list are the same.  */\n+      vec_safe_push (array_operand, integer_one_node);\n+  return array_operand;\n+}\t\t     \n+  \n /* Replaces all the scalar expressions in *NODE.  Returns a STATEMENT_LIST that\n    holds the NODE along with variables that holds the results of the invariant\n    expressions.  */\n@@ -124,16 +201,13 @@ fix_builtin_array_notation_fn (tree an_builtin_fn, tree *new_var)\n   tree new_yes_list, new_cond_expr, new_var_init = NULL_TREE;\n   tree new_exp_init = NULL_TREE;\n   vec<tree, va_gc> *array_list = NULL, *array_operand = NULL;\n-  size_t list_size = 0, rank = 0, ii = 0, jj = 0;\n-  int s_jj = 0;\n-  tree **array_ops, *array_var, jj_tree, loop_init, array_op0;\n-  tree **array_value, **array_stride, **array_length, **array_start;\n-  tree *compare_expr, *expr_incr, *ind_init;\n+  size_t list_size = 0, rank = 0, ii = 0;\n+  tree loop_init, array_op0;\n   tree identity_value = NULL_TREE, call_fn = NULL_TREE, new_call_expr, body;\n-  bool **count_down, **array_vector;\n   location_t location = UNKNOWN_LOCATION;\n   tree loop_with_init = alloc_stmt_list ();\n-  \n+  vec<vec<an_parts> > an_info = vNULL;\n+  vec<an_loop_parts> an_loop_info = vNULL;\n   enum built_in_function an_type =\n     is_cilkplus_reduce_builtin (CALL_EXPR_FN (an_builtin_fn));\n   if (an_type == BUILT_IN_NONE)\n@@ -201,157 +275,27 @@ fix_builtin_array_notation_fn (tree an_builtin_fn, tree *new_var)\n     default:\n       gcc_unreachable (); \n     }\n-  \n-  array_ops = XNEWVEC (tree *, list_size);\n-  for (ii = 0; ii < list_size; ii++)\n-    array_ops[ii] = XNEWVEC (tree, rank);\n-  \n-  array_vector = XNEWVEC (bool *, list_size);\n-  for (ii = 0; ii < list_size; ii++)\n-    array_vector[ii] = XNEWVEC (bool, rank);\n-\n-  array_value = XNEWVEC (tree *, list_size);\n-  array_stride = XNEWVEC (tree *, list_size);\n-  array_length = XNEWVEC (tree *, list_size);\n-  array_start = XNEWVEC (tree *, list_size);\n-\n-  for (ii = 0; ii < list_size; ii++)\n-    {\n-      array_value[ii]  = XNEWVEC (tree, rank);\n-      array_stride[ii] = XNEWVEC (tree, rank);\n-      array_length[ii] = XNEWVEC (tree, rank);\n-      array_start[ii]  = XNEWVEC (tree, rank);\n-    }\n-\n-  compare_expr = XNEWVEC (tree, rank);\n-  expr_incr = XNEWVEC (tree,  rank);\n-  ind_init = XNEWVEC (tree, rank);\n-  \n-  count_down = XNEWVEC (bool *, list_size);\n-  for (ii = 0; ii < list_size; ii++)\n-    count_down[ii] = XNEWVEC (bool,  rank);\n-  \n-  array_var = XNEWVEC (tree, rank);\n-\n-  for (ii = 0; ii < list_size; ii++)\n-    {\n-      jj = 0;\n-      for (jj_tree = (*array_list)[ii];\n-\t   jj_tree && TREE_CODE (jj_tree) == ARRAY_NOTATION_REF;\n-\t   jj_tree = ARRAY_NOTATION_ARRAY (jj_tree))\n-\t{\n-\t  array_ops[ii][jj] = jj_tree;\n-\t  jj++;\n-\t}\n-    }\n-\n-  for (ii = 0; ii < list_size; ii++)\n-    {\n-      tree array_node = (*array_list)[ii];\n-      if (TREE_CODE (array_node) == ARRAY_NOTATION_REF)\n-\t{\n-\t  for (jj = 0; jj < rank; jj++)\n-\t    {\n-\t      if (TREE_CODE (array_ops[ii][jj]) == ARRAY_NOTATION_REF)\n-\t\t{\n-\t\t  array_value[ii][jj] =\n-\t\t    ARRAY_NOTATION_ARRAY (array_ops[ii][jj]);\n-\t\t  array_start[ii][jj] =\n-\t\t    ARRAY_NOTATION_START (array_ops[ii][jj]);\n-\t\t  array_length[ii][jj] =\n-\t\t    fold_build1 (CONVERT_EXPR, integer_type_node,\n-\t\t\t\t ARRAY_NOTATION_LENGTH (array_ops[ii][jj]));\n-\t\t  array_stride[ii][jj] =\n-\t\t    fold_build1 (CONVERT_EXPR, integer_type_node,\n-\t\t\t\t ARRAY_NOTATION_STRIDE (array_ops[ii][jj]));\n-\t\t  array_vector[ii][jj] = true;\n-\n-\t\t  if (!TREE_CONSTANT (array_length[ii][jj]))\n-\t\t    count_down[ii][jj] = false;\n-\t\t  else if (tree_int_cst_lt\n-\t\t\t   (array_length[ii][jj],\n-\t\t\t    build_int_cst (TREE_TYPE (array_length[ii][jj]),\n-\t\t\t\t\t   0)))\n-\t\t    count_down[ii][jj] = true;\n-\t\t  else\n-\t\t    count_down[ii][jj] = false;\n-\t\t}\n-\t      else\n-\t\tarray_vector[ii][jj] = false;\n-\t    }\n-\t}\n-    }\n \n+  an_loop_info.safe_grow_cleared (rank);\n+  cilkplus_extract_an_triplets (array_list, list_size, rank, &an_info);\n   loop_init = alloc_stmt_list ();\n \n   for (ii = 0; ii < rank; ii++)\n     {\n-      array_var[ii] = build_decl (location, VAR_DECL, NULL_TREE,\n+      an_loop_info[ii].var = build_decl (location, VAR_DECL, NULL_TREE,\n \t\t\t\t  integer_type_node);\n-      ind_init[ii] =\n-\tbuild_modify_expr (location, array_var[ii],\n-\t\t\t   TREE_TYPE (array_var[ii]), NOP_EXPR,\n+      an_loop_info[ii].ind_init =\n+\tbuild_modify_expr (location, an_loop_info[ii].var,\n+\t\t\t   TREE_TYPE (an_loop_info[ii].var), NOP_EXPR,\n \t\t\t   location,\n-\t\t\t   build_int_cst (TREE_TYPE (array_var[ii]), 0),\n-\t\t\t   TREE_TYPE (array_var[ii]));\t\n-    }\n-  for (ii = 0; ii < list_size; ii++)\n-    {\n-      if (array_vector[ii][0])\n-\t{\n-\t  tree array_opr_node  = array_value[ii][rank - 1];\n-\t  for (s_jj = rank - 1; s_jj >= 0; s_jj--)\n-\t    {\n-\t      if (count_down[ii][s_jj])\n-\t\t{\n-\t\t  /* Array[start_index - (induction_var * stride)] */\n-\t\t  array_opr_node = build_array_ref\n-\t\t    (location, array_opr_node,\n-\t\t     build2 (MINUS_EXPR, TREE_TYPE (array_var[s_jj]),\n-\t\t\t     array_start[ii][s_jj],\n-\t\t\t     build2 (MULT_EXPR, TREE_TYPE (array_var[s_jj]),\n-\t\t\t\t     array_var[s_jj], array_stride[ii][s_jj])));\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* Array[start_index + (induction_var * stride)] */\n-\t\t  array_opr_node = build_array_ref\n-\t\t    (location, array_opr_node,\n-\t\t     build2 (PLUS_EXPR, TREE_TYPE (array_var[s_jj]),\n-\t\t\t     array_start[ii][s_jj],\n-\t\t\t     build2 (MULT_EXPR, TREE_TYPE (array_var[s_jj]),\n-\t\t\t\t     array_var[s_jj], array_stride[ii][s_jj])));\n-\t\t}\n-\t    }\n-\t  vec_safe_push (array_operand, array_opr_node);\n-\t}\n-      else\n-\t/* This is just a dummy node to make sure the list sizes for both\n-\t   array list and array operand list are the same.  */\n-\tvec_safe_push (array_operand, integer_one_node);\n+\t\t\t   build_int_cst (TREE_TYPE (an_loop_info[ii].var), 0),\n+\t\t\t   TREE_TYPE (an_loop_info[ii].var));\t\n     }\n+  array_operand = create_array_refs (location, an_info, an_loop_info,\n+\t\t\t\t     list_size, rank);\n   replace_array_notations (&func_parm, true, array_list, array_operand);\n-  for (ii = 0; ii < rank; ii++)\n-    expr_incr[ii] =\n-      build2 (MODIFY_EXPR, void_type_node, array_var[ii],\n-\t      build2 (PLUS_EXPR, TREE_TYPE (array_var[ii]), array_var[ii],\n-\t\t      build_int_cst (TREE_TYPE (array_var[ii]), 1)));\n-  for (jj = 0; jj < rank; jj++)\n-    {\n-      if (rank && expr_incr[jj])\n-\t{\n-\t  if (count_down[0][jj])\n-\t    compare_expr[jj] =\n-\t      build2 (LT_EXPR, boolean_type_node, array_var[jj],\n-\t\t      build2 (MULT_EXPR, TREE_TYPE (array_var[jj]),\n-\t\t\t      array_length[0][jj],\n-\t\t\t      build_int_cst (TREE_TYPE (array_var[jj]), -1)));\n-\t  else\n-\t    compare_expr[jj] = build2 (LT_EXPR, boolean_type_node,\n-\t\t\t\t       array_var[jj], array_length[0][jj]);\n-\t}\n-    }\n \n+  create_cmp_incr (location, &an_loop_info, rank, an_info);\n   if (an_type != BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING)\n     {\n       *new_var = build_decl (location, VAR_DECL, NULL_TREE, new_var_type);\n@@ -519,7 +463,7 @@ fix_builtin_array_notation_fn (tree an_builtin_fn, tree *new_var)\n \t{\n \t  new_yes_ind = build_modify_expr\n \t    (location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t     location, array_var[0], TREE_TYPE (array_var[0]));\n+\t     location, an_loop_info[0].var, TREE_TYPE (an_loop_info[0].var));\n \t  new_yes_expr = build_modify_expr\n \t    (location, array_ind_value, TREE_TYPE (array_ind_value),\n \t     NOP_EXPR,\n@@ -569,7 +513,7 @@ fix_builtin_array_notation_fn (tree an_builtin_fn, tree *new_var)\n \t{\n \t  new_yes_ind = build_modify_expr\n \t    (location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t     location, array_var[0], TREE_TYPE (array_var[0]));\n+\t     location, an_loop_info[0].var, TREE_TYPE (an_loop_info[0].var));\n \t  new_yes_expr = build_modify_expr\n \t    (location, array_ind_value, TREE_TYPE (array_ind_value),\n \t     NOP_EXPR,\n@@ -619,7 +563,7 @@ fix_builtin_array_notation_fn (tree an_builtin_fn, tree *new_var)\n     }\n \n   for (ii = 0; ii < rank; ii++)\n-    append_to_statement_list (ind_init [ii], &loop_init);\n+    append_to_statement_list (an_loop_info[ii].ind_init, &loop_init);\n \n   if (an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND\n       || an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND)\n@@ -632,33 +576,14 @@ fix_builtin_array_notation_fn (tree an_builtin_fn, tree *new_var)\n   for (ii = 0; ii < rank; ii++)\n     {\n       tree new_loop = push_stmt_list ();\n-      c_finish_loop (location, compare_expr[ii], expr_incr[ii], body, NULL_TREE,\n-\t\t     NULL_TREE, true);\n+      c_finish_loop (location, an_loop_info[ii].cmp, an_loop_info[ii].incr,\n+\t\t     body, NULL_TREE, NULL_TREE, true);\n       body = pop_stmt_list (new_loop);\n     }\n   append_to_statement_list_force (body, &loop_with_init);\n-  \n-  XDELETEVEC (compare_expr);\n-  XDELETEVEC (expr_incr);\n-  XDELETEVEC (ind_init);\n-  XDELETEVEC (array_var);  \n-  for (ii = 0; ii < list_size; ii++)\n-    {\n-      XDELETEVEC (count_down[ii]);\n-      XDELETEVEC (array_value[ii]);\n-      XDELETEVEC (array_stride[ii]);\n-      XDELETEVEC (array_length[ii]);\n-      XDELETEVEC (array_start[ii]);\n-      XDELETEVEC (array_ops[ii]);\n-      XDELETEVEC (array_vector[ii]);\n-    }\n-  XDELETEVEC (count_down);\n-  XDELETEVEC (array_value);\n-  XDELETEVEC (array_stride);\n-  XDELETEVEC (array_length);\n-  XDELETEVEC (array_start);\n-  XDELETEVEC (array_ops);\n-  XDELETEVEC (array_vector);\n+\n+  an_info.release ();\n+  an_loop_info.release ();\n   \n   return loop_with_init;\n }\n@@ -674,31 +599,22 @@ build_array_notation_expr (location_t location, tree lhs, tree lhs_origtype,\n \t\t\t   enum tree_code modifycode, location_t rhs_loc,\n \t\t\t   tree rhs, tree rhs_origtype)\n {\n-  bool **lhs_vector = NULL, **rhs_vector = NULL, found_builtin_fn = false;\n-  tree **lhs_array = NULL, **rhs_array = NULL;\n+  bool found_builtin_fn = false;\n   tree array_expr_lhs = NULL_TREE, array_expr_rhs = NULL_TREE;\n   tree array_expr = NULL_TREE;\n-  tree **lhs_value = NULL, **rhs_value = NULL;\n-  tree **lhs_stride = NULL, **lhs_length = NULL, **lhs_start = NULL;\n-  tree **rhs_stride = NULL, **rhs_length = NULL, **rhs_start = NULL;\n-  tree an_init = NULL_TREE, *lhs_var = NULL, *rhs_var = NULL;\n-  tree *cond_expr = NULL;\n+  tree an_init = NULL_TREE;\n+  vec<tree> cond_expr = vNULL;\n   tree body, loop_with_init = alloc_stmt_list();\n   tree scalar_mods = NULL_TREE;\n-  tree *lhs_expr_incr = NULL, *rhs_expr_incr = NULL;\n-  tree *lhs_ind_init = NULL, *rhs_ind_init = NULL;\n-  bool **lhs_count_down = NULL, **rhs_count_down = NULL;\n-  tree *lhs_compare = NULL, *rhs_compare = NULL;\n   vec<tree, va_gc> *rhs_array_operand = NULL, *lhs_array_operand = NULL;\n   size_t lhs_rank = 0, rhs_rank = 0;\n-  size_t ii = 0, jj = 0;\n-  int s_jj = 0;\n-  tree ii_tree = NULL_TREE, new_modify_expr;\n+  size_t ii = 0;\n   vec<tree, va_gc> *lhs_list = NULL, *rhs_list = NULL;\n-  tree new_var = NULL_TREE, builtin_loop = NULL_TREE;\n-  tree begin_var, lngth_var, strde_var;\n-  size_t rhs_list_size = 0, lhs_list_size = 0;\n-\n+  tree new_modify_expr, new_var = NULL_TREE, builtin_loop = NULL_TREE;\n+  size_t rhs_list_size = 0, lhs_list_size = 0; \n+  vec<vec<an_parts> > lhs_an_info = vNULL, rhs_an_info = vNULL;\n+  vec<an_loop_parts> lhs_an_loop_info = vNULL, rhs_an_loop_info = vNULL;\n+  \n   /* If either of this is true, an error message must have been send out\n      already.  Not necessary to send out multiple error messages.  */\n   if (lhs == error_mark_node || rhs == error_mark_node)\n@@ -810,296 +726,49 @@ build_array_notation_expr (location_t location, tree lhs, tree lhs_origtype,\n   /* Here we assign the array notation components to variable so that we can\n      satisfy the exec once rule.  */\n   for (ii = 0; ii < lhs_list_size; ii++)\n-    {\n+    { \n       tree array_node = (*lhs_list)[ii];\n-      tree array_begin = ARRAY_NOTATION_START (array_node);\n-      tree array_lngth = ARRAY_NOTATION_LENGTH (array_node);\n-      tree array_strde = ARRAY_NOTATION_STRIDE (array_node);\n-\n-      if (TREE_CODE (array_begin) != INTEGER_CST)\n-\t{\n-\t  begin_var = build_decl (location, VAR_DECL, NULL_TREE,\n-\t\t\t\t  integer_type_node);\n-\t  add_stmt (build_modify_expr (location, begin_var,\n-\t\t\t\t       TREE_TYPE (begin_var),\n-\t\t\t\t       NOP_EXPR, location, array_begin,\n-\t\t\t\t       TREE_TYPE (array_begin)));      \n-\t  ARRAY_NOTATION_START (array_node) = begin_var;\n-\t}\n-\n-      if (TREE_CODE (array_lngth) != INTEGER_CST)\n-\t{\n-\t  lngth_var = build_decl (location, VAR_DECL, NULL_TREE,\n-\t\t\t\t  integer_type_node);\n-\t  add_stmt (build_modify_expr (location, lngth_var,\n-\t\t\t\t       TREE_TYPE (lngth_var),\n-\t\t\t\t       NOP_EXPR, location, array_lngth,\n-\t\t\t\t       TREE_TYPE (array_lngth)));\n-\t  ARRAY_NOTATION_LENGTH (array_node) = lngth_var;\n-\t}\n-      if (TREE_CODE (array_strde) != INTEGER_CST)\n-\t{\n-\t  strde_var = build_decl (location, VAR_DECL, NULL_TREE,\n-\t\t\t\t  integer_type_node);\n-\n-\t  add_stmt (build_modify_expr (location, strde_var,\n-\t\t\t\t       TREE_TYPE (strde_var),\n-\t\t\t\t       NOP_EXPR, location, array_strde,\n-\t\t\t\t       TREE_TYPE (array_strde)));\n-\t  ARRAY_NOTATION_STRIDE (array_node) = strde_var;\n-\t}\n-    }\n-  for (ii = 0; ii < rhs_list_size; ii++)\n-    {\n-      tree array_node = (*rhs_list)[ii];\n-      if (array_node && TREE_CODE (array_node) == ARRAY_NOTATION_REF)\n-\t{\n-\t  tree array_begin = ARRAY_NOTATION_START (array_node);\n-\t  tree array_lngth = ARRAY_NOTATION_LENGTH (array_node);\n-\t  tree array_strde = ARRAY_NOTATION_STRIDE (array_node);\n-\n-\t  if (TREE_CODE (array_begin) != INTEGER_CST)\n-\t    {\n-\t      begin_var = build_decl (location, VAR_DECL, NULL_TREE,\n-\t\t\t\t      integer_type_node);\n-\t      add_stmt (build_modify_expr (location, begin_var,\n-\t\t\t\t\t   TREE_TYPE (begin_var),\n-\t\t\t\t\t   NOP_EXPR, location, array_begin,\n-\t\t\t\t\t   TREE_TYPE (array_begin)));\n-\t      ARRAY_NOTATION_START (array_node) = begin_var;\n-\t    }\n-\t  if (TREE_CODE (array_lngth) != INTEGER_CST)\n-\t    {\n-\t      lngth_var = build_decl (location, VAR_DECL, NULL_TREE,\n-\t\t\t\t      integer_type_node);\n-\t      add_stmt (build_modify_expr (location, lngth_var,\n-\t\t\t\t\t   TREE_TYPE (lngth_var),\n-\t\t\t\t\t   NOP_EXPR, location, array_lngth,\n-\t\t\t\t\t   TREE_TYPE (array_lngth)));\n-\t      ARRAY_NOTATION_LENGTH (array_node) = lngth_var;\n-\t    }\n-\t  if (TREE_CODE (array_strde) != INTEGER_CST)\n-\t    {\n-\t      strde_var = build_decl (location, VAR_DECL, NULL_TREE,\n-\t\t\t\t      integer_type_node);\n-\n-\t      add_stmt (build_modify_expr (location, strde_var,\n-\t\t\t\t\t   TREE_TYPE (strde_var),\n-\t\t\t\t\t   NOP_EXPR, location, array_strde,\n-\t\t\t\t\t   TREE_TYPE (array_strde)));\n-\t      ARRAY_NOTATION_STRIDE (array_node) = strde_var;\n-\t    }\n-\t}\n+      make_triplet_val_inv (location, &ARRAY_NOTATION_START (array_node));\n+      make_triplet_val_inv (location, &ARRAY_NOTATION_LENGTH (array_node));\n+      make_triplet_val_inv (location, &ARRAY_NOTATION_STRIDE (array_node));\n     }\n-  \n-  lhs_vector = XNEWVEC (bool *, lhs_list_size);\n-  for (ii = 0; ii < lhs_list_size; ii++)\n-    lhs_vector[ii] = XNEWVEC (bool, lhs_rank);\n-  \n-  rhs_vector = XNEWVEC (bool *, rhs_list_size);\n-  for (ii = 0; ii < rhs_list_size; ii++)\n-    rhs_vector[ii] = XNEWVEC (bool, rhs_rank);\n-  \n-  lhs_array = XNEWVEC (tree *, lhs_list_size);\n-  for (ii = 0; ii < lhs_list_size; ii++)\n-    lhs_array[ii] = XNEWVEC (tree, lhs_rank);\n-  \n-  rhs_array = XNEWVEC (tree *, rhs_list_size);\n-  for (ii = 0; ii < rhs_list_size; ii++)\n-    rhs_array[ii] = XNEWVEC (tree, rhs_rank);\n-\n-  lhs_value = XNEWVEC (tree *, lhs_list_size);\n-  for (ii = 0; ii < lhs_list_size; ii++)\n-    lhs_value[ii] = XNEWVEC (tree, lhs_rank);\n-  \n-  rhs_value = XNEWVEC (tree *, rhs_list_size);\n-  for (ii = 0; ii < rhs_list_size; ii++)\n-    rhs_value[ii] = XNEWVEC (tree, rhs_rank);\n-\n-  lhs_stride = XNEWVEC (tree *, lhs_list_size);\n-  for (ii = 0; ii < lhs_list_size; ii++)\n-    lhs_stride[ii] = XNEWVEC (tree, lhs_rank);\n-  \n-  rhs_stride = XNEWVEC (tree *, rhs_list_size);\n   for (ii = 0; ii < rhs_list_size; ii++)\n-    rhs_stride[ii] = XNEWVEC (tree, rhs_rank);\n-\n-  lhs_length = XNEWVEC (tree *, lhs_list_size);\n-  for (ii = 0; ii < lhs_list_size; ii++)\n-    lhs_length[ii] = XNEWVEC (tree, lhs_rank);\n-  \n-  rhs_length = XNEWVEC (tree *, rhs_list_size);\n-  for (ii = 0; ii < rhs_list_size; ii++)\n-    rhs_length[ii] = XNEWVEC (tree, rhs_rank);\n-  \n-  lhs_start = XNEWVEC (tree *, lhs_list_size);\n-  for (ii = 0; ii < lhs_list_size; ii++)\n-    lhs_start[ii] = XNEWVEC (tree, lhs_rank);\n-  \n-  rhs_start = XNEWVEC (tree *, rhs_list_size);\n-  for (ii = 0; ii < rhs_list_size; ii++)\n-    rhs_start[ii] = XNEWVEC (tree, rhs_rank);\n-\n-  lhs_var = XNEWVEC (tree, lhs_rank);\n-  rhs_var = XNEWVEC (tree, rhs_rank);\n-  cond_expr = XNEWVEC (tree, MAX (lhs_rank, rhs_rank));\n-\n-  lhs_expr_incr = XNEWVEC (tree, lhs_rank);\n-  rhs_expr_incr =XNEWVEC (tree, rhs_rank);\n-\n-  lhs_ind_init = XNEWVEC (tree, lhs_rank);\n-  rhs_ind_init = XNEWVEC (tree, rhs_rank);\n-\n-  lhs_count_down = XNEWVEC (bool *, lhs_list_size);\n-  for (ii = 0; ii < lhs_list_size; ii++)\n-    lhs_count_down[ii] =  XNEWVEC (bool, lhs_rank);\n+    if ((*rhs_list)[ii] && TREE_CODE ((*rhs_list)[ii]) == ARRAY_NOTATION_REF)\n+      {  \n+\ttree array_node = (*rhs_list)[ii];\n+\tmake_triplet_val_inv (location, &ARRAY_NOTATION_START (array_node));\n+\tmake_triplet_val_inv (location, &ARRAY_NOTATION_LENGTH (array_node));\n+\tmake_triplet_val_inv (location, &ARRAY_NOTATION_STRIDE (array_node));\n+      }\n   \n-  rhs_count_down =  XNEWVEC (bool *, rhs_list_size);\n-  for (ii = 0; ii < rhs_list_size; ii++)\n-    rhs_count_down[ii] = XNEWVEC (bool, rhs_rank);\n+  cond_expr.safe_grow_cleared (MAX (lhs_rank, rhs_rank));\n \n-  lhs_compare =  XNEWVEC (tree, lhs_rank);\n-  rhs_compare =  XNEWVEC (tree, rhs_rank);\n-  \n-  if (lhs_rank)\n-    {\n-      for (ii = 0; ii < lhs_list_size; ii++)\n-\t{\n-\t  jj = 0;\n-\t  ii_tree = (*lhs_list)[ii];\n-\t  while (ii_tree)\n-\t    {\n-\t      if (TREE_CODE (ii_tree) == ARRAY_NOTATION_REF)\n-\t\t{\n-\t\t  lhs_array[ii][jj] = ii_tree;\n-\t\t  jj++;\n-\t\t  ii_tree = ARRAY_NOTATION_ARRAY (ii_tree);\n-\t\t}\n-\t      else if (TREE_CODE (ii_tree) == ARRAY_REF)\n-\t\tii_tree = TREE_OPERAND (ii_tree, 0);\n-\t      else if (TREE_CODE (ii_tree) == VAR_DECL\n-\t\t       || TREE_CODE (ii_tree) == PARM_DECL)\n-\t\tbreak;\n-\t    }\n-\t}\n-    }\n-  else\n-    lhs_array[0][0] = NULL_TREE;\n-  \n+  lhs_an_loop_info.safe_grow_cleared (lhs_rank);\n   if (rhs_rank)\n-    {\n-      for (ii = 0; ii < rhs_list_size; ii++)\n-\t{ \n-\t  jj = 0; \n-\t  ii_tree = (*rhs_list)[ii];\n-\t  while (ii_tree)\n-\t    {\n-\t      if (TREE_CODE (ii_tree) == ARRAY_NOTATION_REF)\n-\t\t{\n-\t\t  rhs_array[ii][jj] = ii_tree;\n-\t\t  jj++;\n-\t\t  ii_tree = ARRAY_NOTATION_ARRAY (ii_tree);\n-\t\t}\n-\t      else if (TREE_CODE (ii_tree) == ARRAY_REF)\n-\t\tii_tree = TREE_OPERAND (ii_tree, 0);\n-\t      else if (TREE_CODE (ii_tree) == VAR_DECL\n-\t\t       || TREE_CODE (ii_tree) == PARM_DECL\n-\t\t       || TREE_CODE (ii_tree) == CALL_EXPR)\n-\t\tbreak;\n-\t    }\n-\t}\n-    }\n+    rhs_an_loop_info.safe_grow_cleared (rhs_rank);\n \n-  for (ii = 0; ii < lhs_list_size; ii++)\n-    {\n-      tree lhs_node = (*lhs_list)[ii];\n-      if (TREE_CODE (lhs_node) == ARRAY_NOTATION_REF)\n-\t{\n-\t  for (jj = 0; jj < lhs_rank; jj++)\n-\t    {\n-\t      if (TREE_CODE (lhs_array[ii][jj]) == ARRAY_NOTATION_REF)\n-\t\t{\n-\t\t  lhs_value[ii][jj] = ARRAY_NOTATION_ARRAY (lhs_array[ii][jj]);\n-\t\t  lhs_start[ii][jj] = ARRAY_NOTATION_START (lhs_array[ii][jj]);\n-\t\t  lhs_length[ii][jj] =\n-\t\t    fold_build1 (CONVERT_EXPR, integer_type_node,\n-\t\t\t\t ARRAY_NOTATION_LENGTH (lhs_array[ii][jj]));\n-\t\t  lhs_stride[ii][jj] =\n-\t\t    fold_build1 (CONVERT_EXPR, integer_type_node,\n-\t\t\t\t ARRAY_NOTATION_STRIDE (lhs_array[ii][jj]));\n-\t\t  lhs_vector[ii][jj] = true;\n-\t\t  /* IF the stride value is variable (i.e. not constant) then \n-\t\t     assume that the length is positive.  */\n-\t\t  if (!TREE_CONSTANT (lhs_length[ii][jj]))\n-\t\t    lhs_count_down[ii][jj] = false;\n-\t\t  else if (tree_int_cst_lt\n-\t\t\t   (lhs_length[ii][jj],\n-\t\t\t    build_zero_cst (TREE_TYPE (lhs_length[ii][jj]))))\n-\t\t    lhs_count_down[ii][jj] = true;\n-\t\t  else\n-\t\t    lhs_count_down[ii][jj] = false;\n-\t\t}\n-\t      else\n-\t\tlhs_vector[ii][jj] = false;\n-\t    }\n-\t}\n-    }\n-  for (ii = 0; ii < rhs_list_size; ii++)\n+  cilkplus_extract_an_triplets (lhs_list, lhs_list_size, lhs_rank,\n+\t\t\t\t&lhs_an_info);\n+  if (rhs_rank)\n     {\n-      if (TREE_CODE ((*rhs_list)[ii]) == ARRAY_NOTATION_REF)\n-\t{\n-\t  for (jj = 0; jj < rhs_rank; jj++)\n-\t    {\n-\t      if (TREE_CODE (rhs_array[ii][jj]) == ARRAY_NOTATION_REF)\n-\t\t{\n-\t\t  rhs_value[ii][jj]  = ARRAY_NOTATION_ARRAY (rhs_array[ii][jj]);\n-\t\t  rhs_start[ii][jj]  = ARRAY_NOTATION_START (rhs_array[ii][jj]);\n-\t\t  rhs_length[ii][jj] =\n-\t\t    fold_build1 (CONVERT_EXPR, integer_type_node,\n-\t\t\t\t ARRAY_NOTATION_LENGTH (rhs_array[ii][jj]));\n-\t\t  rhs_stride[ii][jj] =\n-\t\t    fold_build1 (CONVERT_EXPR, integer_type_node,\n-\t\t\t\t ARRAY_NOTATION_STRIDE (rhs_array[ii][jj]));\n-\t\t  rhs_vector[ii][jj] = true;\n-\t\t  /* If the stride value is variable (i.e. not constant) then \n-\t\t     assume that the length is positive.  */\n-\t\t  if (!TREE_CONSTANT (rhs_length[ii][jj]))\n-\t\t    rhs_count_down[ii][jj] = false;\n-\t\t  else if (tree_int_cst_lt\n-\t\t\t   (rhs_length[ii][jj],\n-\t\t\t    build_int_cst (TREE_TYPE (rhs_length[ii][jj]), 0)))\n-\t\t    rhs_count_down[ii][jj] = true;\n-\t\t  else\n-\t\t    rhs_count_down[ii][jj] = false;\t\n-\t\t}\n-\t      else\n-\t\trhs_vector[ii][jj] = false;\n-\t    }\n-\t}\n-      else\n-\tfor (jj = 0; jj < rhs_rank; jj++)\n-\t  { \n-\t    rhs_vector[ii][jj] = false;\n-\t    rhs_length[ii][jj] = NULL_TREE;\n-\t  }\n+      rhs_an_loop_info.safe_grow_cleared (rhs_rank);\n+      cilkplus_extract_an_triplets (rhs_list, rhs_list_size, rhs_rank,\n+\t\t\t\t    &rhs_an_info);\n     }\n-\n-  if (length_mismatch_in_expr_p (EXPR_LOCATION (lhs), lhs_length,\n-\t\t\t\t lhs_list_size, lhs_rank)\n-      || length_mismatch_in_expr_p (EXPR_LOCATION (rhs), rhs_length,\n-\t\t\t\t    rhs_list_size, rhs_rank))\n+  if (length_mismatch_in_expr_p (EXPR_LOCATION (lhs), lhs_an_info)\n+      || (rhs_rank\n+\t  && length_mismatch_in_expr_p (EXPR_LOCATION (rhs), rhs_an_info)))\n     {\n       pop_stmt_list (an_init);\n       return error_mark_node;\n     }\n-\n   if (lhs_list_size > 0 && rhs_list_size > 0 && lhs_rank > 0 && rhs_rank > 0\n-      && TREE_CODE (lhs_length[0][0]) == INTEGER_CST\n-      && rhs_length[0][0]\n-      && TREE_CODE (rhs_length[0][0]) == INTEGER_CST)\n+      && TREE_CODE (lhs_an_info[0][0].length) == INTEGER_CST\n+      && rhs_an_info[0][0].length\n+      && TREE_CODE (rhs_an_info[0][0].length) == INTEGER_CST)\n     {\n-      HOST_WIDE_INT l_length = int_cst_value (lhs_length[0][0]);\n-      HOST_WIDE_INT r_length = int_cst_value (rhs_length[0][0]);\n+      HOST_WIDE_INT l_length = int_cst_value (lhs_an_info[0][0].length);\n+      HOST_WIDE_INT r_length = int_cst_value (rhs_an_info[0][0].length);\n       /* Length can be negative or positive.  As long as the magnitude is OK,\n \t then the array notation is valid.  */\n       if (absu_hwi (l_length) != absu_hwi (r_length))\n@@ -1110,256 +779,77 @@ build_array_notation_expr (location_t location, tree lhs, tree lhs_origtype,\n \t}\n     }\n   for (ii = 0; ii < lhs_rank; ii++)\n-    {\n-      if (lhs_vector[0][ii])\n-\t{\n-\t  lhs_var[ii] = build_decl (location, VAR_DECL, NULL_TREE,\n-\t\t\t\t    integer_type_node);\n-\t  lhs_ind_init[ii] = build_modify_expr\n-\t    (location, lhs_var[ii], TREE_TYPE (lhs_var[ii]),\n-\t     NOP_EXPR,\n-\t     location, build_zero_cst (TREE_TYPE (lhs_var[ii])),\n-\t     TREE_TYPE (lhs_var[ii]));\n-\t}\n-    }\n-\n+    if (lhs_an_info[0][ii].is_vector)\n+      {\n+\tlhs_an_loop_info[ii].var = build_decl (location, VAR_DECL, NULL_TREE,\n+\t\t\t\t\t       integer_type_node);\n+\tlhs_an_loop_info[ii].ind_init = build_modify_expr\n+\t  (location, lhs_an_loop_info[ii].var,\n+\t   TREE_TYPE (lhs_an_loop_info[ii].var), NOP_EXPR,\n+\t   location, build_zero_cst (TREE_TYPE (lhs_an_loop_info[ii].var)),\n+\t   TREE_TYPE (lhs_an_loop_info[ii].var));\n+      }\n   for (ii = 0; ii < rhs_rank; ii++)\n     {\n       /* When we have a polynomial, we assume that the indices are of type \n \t integer.  */\n-      rhs_var[ii] = build_decl (location, VAR_DECL, NULL_TREE,\n-\t\t\t\tinteger_type_node);\n-      rhs_ind_init[ii] = build_modify_expr\n-\t(location, rhs_var[ii], TREE_TYPE (rhs_var[ii]),\n-\t NOP_EXPR,\n-\t location, build_int_cst (TREE_TYPE (rhs_var[ii]), 0),\n-\t TREE_TYPE (rhs_var[ii]));\n+      rhs_an_loop_info[ii].var = build_decl (location, VAR_DECL, NULL_TREE,\n+\t\t\t\t\t     integer_type_node);\n+      rhs_an_loop_info[ii].ind_init = build_modify_expr\n+\t(location, rhs_an_loop_info[ii].var,\n+\t TREE_TYPE (rhs_an_loop_info[ii].var), NOP_EXPR,\n+\t location, build_int_cst (TREE_TYPE (rhs_an_loop_info[ii].var), 0),\n+\t TREE_TYPE (rhs_an_loop_info[ii].var));\n     }\n   if (lhs_rank)\n     {\n-      for (ii = 0; ii < lhs_list_size; ii++)\n-\t{\n-\t  if (lhs_vector[ii][0])\n-\t    { \n-\t      /* The last ARRAY_NOTATION element's ARRAY component should be \n-\t\t the array's base value.  */\n-\t      tree lhs_array_opr = lhs_value[ii][lhs_rank - 1];\n-\t      for (s_jj = lhs_rank - 1; s_jj >= 0; s_jj--)\n-\t\t{\n-\t\t  if (lhs_count_down[ii][s_jj])\n-\t  \t      /* Array[start_index + (induction_var * stride)].  */\n-\t\t      lhs_array_opr = build_array_ref\n-\t\t\t(location, lhs_array_opr,\n-\t\t\t build2 (MINUS_EXPR, TREE_TYPE (lhs_var[s_jj]),\n-\t\t\t\t lhs_start[ii][s_jj],\n-\t\t\t\t build2 (MULT_EXPR, TREE_TYPE (lhs_var[s_jj]),\n-\t\t\t\t\t lhs_var[s_jj],\n-\t\t\t\t\t lhs_stride[ii][s_jj])));\n-\t\t  else\n-\t\t    lhs_array_opr = build_array_ref\n-\t\t      (location, lhs_array_opr,\n-\t\t       build2 (PLUS_EXPR, TREE_TYPE (lhs_var[s_jj]),\n-\t\t\t       lhs_start[ii][s_jj],\n-\t\t\t       build2 (MULT_EXPR, TREE_TYPE (lhs_var[s_jj]),\n-\t\t\t\t       lhs_var[s_jj],\n-\t\t\t\t       lhs_stride[ii][s_jj])));\n-\t\t}\n-\t      vec_safe_push (lhs_array_operand, lhs_array_opr);\n-\t    }\n-\t  else\n-\t    vec_safe_push (lhs_array_operand, integer_one_node);\n-\t}\n+      lhs_array_operand = create_array_refs\n+\t(location, lhs_an_info, lhs_an_loop_info, lhs_list_size, lhs_rank);\n       replace_array_notations (&lhs, true, lhs_list, lhs_array_operand);\n       array_expr_lhs = lhs;\n     }\n-\n+  if (rhs_array_operand)\n+    vec_safe_truncate (rhs_array_operand, 0);\n   if (rhs_rank)\n     {\n-      for (ii = 0; ii < rhs_list_size; ii++)\n-\t{\n-\t  if (rhs_vector[ii][0])\n-\t    {\n-\t      tree rhs_array_opr = rhs_value[ii][rhs_rank - 1];\n-\t      for (s_jj = rhs_rank - 1; s_jj >= 0; s_jj--)\n-\t\t{\n-\t\t  if (rhs_count_down[ii][s_jj])\n-\t\t    /* Array[start_index - (induction_var * stride)] */\n-\t\t    rhs_array_opr = build_array_ref\n-\t\t      (location, rhs_array_opr,\n-\t\t       build2 (MINUS_EXPR, TREE_TYPE (rhs_var[s_jj]),\n-\t\t\t       rhs_start[ii][s_jj],\n-\t\t\t       build2 (MULT_EXPR, TREE_TYPE (rhs_var[s_jj]),\n-\t\t\t\t       rhs_var[s_jj],\n-\t\t\t\t       rhs_stride[ii][s_jj])));\n-\t\t  else\n-\t\t    /* Array[start_index  + (induction_var * stride)] */\n-\t\t    rhs_array_opr = build_array_ref\n-\t\t      (location, rhs_array_opr,\n-\t\t       build2 (PLUS_EXPR, TREE_TYPE (rhs_var[s_jj]),\n-\t\t\t       rhs_start[ii][s_jj],\n-\t\t\t       build2 (MULT_EXPR, TREE_TYPE (rhs_var[s_jj]),\n-\t\t\t\t       rhs_var[s_jj],\n-\t\t\t\t       rhs_stride[ii][s_jj])));\n-\t\t}\n-\t      vec_safe_push (rhs_array_operand, rhs_array_opr);\n-\t    }\n-\t  else\n-\t  /* This is just a dummy node to make sure the list sizes for both\n-\t     array list and array operand list are the same.  */\n-\t  vec_safe_push (rhs_array_operand, integer_one_node);\n-\t}\n-\n-      for (ii = 0; ii < rhs_list_size; ii++)\n-\t{\n-\t  tree rhs_node = (*rhs_list)[ii];\n-\t  if (TREE_CODE (rhs_node) == CALL_EXPR)\n-\t    {\n-\t      int idx_value = 0;\n-\t      tree func_name = CALL_EXPR_FN (rhs_node);\n-\t      if (TREE_CODE (func_name) == ADDR_EXPR)\n-\t\tif (is_sec_implicit_index_fn (func_name))\n-\t\t  {\n-\t\t    idx_value = \n-\t\t      extract_sec_implicit_index_arg (location, rhs_node);\n-\t\t    if (idx_value == -1) /* This means we have an error.  */\n-\t\t      return error_mark_node;\n-\t\t    else if (idx_value < (int) lhs_rank && idx_value >= 0)\n-\t\t      vec_safe_push (rhs_array_operand, lhs_var[idx_value]);\n-\t\t    else\n-\t\t      {\n-\t\t\tsize_t ee = 0;\n-\t\t\ttree lhs_base = (*lhs_list)[ii];\n-\t\t\tfor (ee = 0; ee < lhs_rank; ee++)\n-\t\t\t  lhs_base = ARRAY_NOTATION_ARRAY (lhs_base);\n-\t\t\terror_at (location, \"__sec_implicit_index argument %d \"\n-\t\t\t\t  \"must be less than rank of %qD\", idx_value,\n-\t\t\t\t  lhs_base);\n-\t\t\treturn error_mark_node;\n-\t\t      }\n-\t\t  }  \n-\t    }\n-\t}\n+      rhs_array_operand = create_array_refs\n+\t(location, rhs_an_info, rhs_an_loop_info, rhs_list_size, rhs_rank);\n+      replace_array_notations (&rhs, true, rhs_list, rhs_array_operand);\n+      vec_safe_truncate (rhs_array_operand, 0);\n+      rhs_array_operand = fix_sec_implicit_args (location, rhs_list,\n+\t\t\t\t\t\t rhs_an_loop_info, rhs_rank,\n+\t\t\t\t\t\t rhs);\n+      if (!rhs_array_operand)\n+\treturn error_mark_node;\n       replace_array_notations (&rhs, true, rhs_list, rhs_array_operand);\n-      array_expr_rhs = rhs;\n     }\n-  else\n+  else if (rhs_list_size > 0)\n     {\n-      for (ii = 0; ii < rhs_list_size; ii++)\n-\t{\n-\t  tree rhs_node = (*rhs_list)[ii];\n-\t  if (TREE_CODE (rhs_node) == CALL_EXPR)\n-\t    {\n-\t      int idx_value = 0;\n-\t      tree func_name = CALL_EXPR_FN (rhs_node);\n-\t      if (TREE_CODE (func_name) == ADDR_EXPR)\n-\t\tif (is_sec_implicit_index_fn (func_name))\n-\t\t  {\n-\t\t    idx_value = \n-\t\t      extract_sec_implicit_index_arg (location, rhs_node);\n-\t\t    if (idx_value == -1) /* This means we have an error.  */\n-\t\t      return error_mark_node;\n-\t\t    else if (idx_value < (int) lhs_rank && idx_value >= 0)\n-\t\t      vec_safe_push (rhs_array_operand, lhs_var[idx_value]);\n-\t\t    else\n-\t\t      {\n-\t\t\tsize_t ee = 0;\n-\t\t\ttree lhs_base = (*lhs_list)[ii];\n-\t\t\tfor (ee = 0; ee < lhs_rank; ee++)\n-\t\t\t  lhs_base = ARRAY_NOTATION_ARRAY (lhs_base);\n-\t\t\terror_at (location, \"__sec_implicit_index argument %d \"\n-\t\t\t\t  \"must be less than rank of %qD\", idx_value,\n-\t\t\t\t  lhs_base);\n-\t\t\treturn error_mark_node;\n-\t\t      }\n-\t\t  }  \n-\t    }\n-\t}\n+      rhs_array_operand = fix_sec_implicit_args (location, rhs_list,\n+\t\t\t\t\t\t lhs_an_loop_info, lhs_rank,\n+\t\t\t\t\t\t lhs);\n+      if (!rhs_array_operand)\n+\treturn error_mark_node;\n       replace_array_notations (&rhs, true, rhs_list, rhs_array_operand);\n-      array_expr_rhs = rhs;\n-      rhs_expr_incr[0] = NULL_TREE;\n     }\n-\n-  for (ii = 0; ii < rhs_rank; ii++) \n-    rhs_expr_incr[ii] = build2 (MODIFY_EXPR, void_type_node, rhs_var[ii], \n-\t\t\t\tbuild2 \n-\t\t\t\t(PLUS_EXPR, TREE_TYPE (rhs_var[ii]), \n-\t\t\t\t rhs_var[ii], \n-\t\t\t\t build_one_cst (TREE_TYPE (rhs_var[ii]))));\n-\n-  for (ii = 0; ii < lhs_rank; ii++) \n-    lhs_expr_incr[ii] = build2 \n-      (MODIFY_EXPR, void_type_node, lhs_var[ii], \n-       build2 (PLUS_EXPR, TREE_TYPE (lhs_var[ii]), lhs_var[ii], \n-\t       build_one_cst (TREE_TYPE (lhs_var[ii]))));\n-  \n-  /* If array_expr_lhs is NULL, then we have function that returns void or\n-     its return value is ignored.  */\n-  if (!array_expr_lhs)\n-    array_expr_lhs = lhs;\n-\n+  array_expr_lhs = lhs;\n+  array_expr_rhs = rhs;\n   array_expr = build_modify_expr (location, array_expr_lhs, lhs_origtype, \n \t\t\t\t  modifycode, rhs_loc, array_expr_rhs, \n \t\t\t\t  rhs_origtype);\n-\n-  for (jj = 0; jj < MAX (lhs_rank, rhs_rank); jj++)\n-    {\n-      if (rhs_rank && rhs_expr_incr[jj])\n-\t{\n-\t  size_t iii = 0;\n-\t  if (lhs_rank == 0)\n-\t    lhs_compare[jj] = integer_one_node;\n-\t  else if (lhs_count_down[0][jj])\n-\t    lhs_compare[jj] = build2\n-\t      (GT_EXPR, boolean_type_node, lhs_var[jj], lhs_length[0][jj]);\n-\t  else\n-\t    lhs_compare[jj] = build2\n-\t      (LT_EXPR, boolean_type_node, lhs_var[jj], lhs_length[0][jj]);\n-\n-\n-\t  /* The reason why we have this here is for the following case:\n-\t         Array[:][:] = function_call(something) + Array2[:][:];\n-\n-\t     So, we will skip the first operand of RHS and then go to the\n-\t     2nd to find whether we should count up or down.  */\n-\t \n-\t  for (iii = 0; iii < rhs_list_size; iii++)\n-\t    if (rhs_vector[iii][jj])\n-\t      break;\n-\t      \n-\t  /* What we are doing here is this:\n-\t     We always count up, so:\n-\t       if (length is negative ==> which means we count down)\n-\t          we multiply length by -1 and count up => ii < -LENGTH\n-\t       else\n-\t          we just count up, so we compare for  ii < LENGTH\n-\t   */\n-\t  if (rhs_count_down[iii][jj])\n-\t    /* We use iii for rhs_length because that is the correct countdown\n-\t       we have to use.  */\n-\t      rhs_compare[jj] = build2\n-\t\t(LT_EXPR, boolean_type_node, rhs_var[jj],\n-\t\t build2 (MULT_EXPR, TREE_TYPE (rhs_var[jj]),\n-\t\t\t rhs_length[iii][jj],\n-\t\t\t build_int_cst (TREE_TYPE (rhs_var[jj]), -1)));\n-\t  else\n-\t    rhs_compare[jj] = build2 (LT_EXPR, boolean_type_node, rhs_var[jj],\n-\t\t\t\t      rhs_length[iii][jj]);\n-\t  if (lhs_compare[ii] != integer_one_node)\n-\t    cond_expr[jj] = build2 (TRUTH_ANDIF_EXPR, void_type_node,\n-\t\t\t\t    lhs_compare[jj], rhs_compare[jj]);\n-\t  else\n-\t    cond_expr[jj] = rhs_compare[jj];\n-\t}\n-      else\n-\t{\n-\t  if (lhs_count_down[0][jj])\n-\t    cond_expr[jj] = build2\n-\t      (GT_EXPR, boolean_type_node, lhs_var[jj], lhs_length[0][jj]);\n-\t  else\n-\t    cond_expr[jj] = build2\n-\t      (LT_EXPR, boolean_type_node, lhs_var[jj], lhs_length[0][jj]);\n-\t}\n-    }\n+  create_cmp_incr (location, &lhs_an_loop_info, lhs_rank, lhs_an_info);\n+  if (rhs_rank)\n+    create_cmp_incr (location, &rhs_an_loop_info, rhs_rank, rhs_an_info);\n+  \n+  for (ii = 0; ii < MAX (lhs_rank, rhs_rank); ii++)\n+    if (ii < lhs_rank && ii < rhs_rank)\n+      cond_expr[ii] = build2 (TRUTH_ANDIF_EXPR, boolean_type_node,\n+\t\t\t      lhs_an_loop_info[ii].cmp,\n+\t\t\t      rhs_an_loop_info[ii].cmp);\n+    else if (ii < lhs_rank && ii >= rhs_rank)\n+      cond_expr[ii] = lhs_an_loop_info[ii].cmp;\n+    else\n+      gcc_unreachable ();\n \n   an_init = pop_stmt_list (an_init);\n   append_to_statement_list_force (an_init, &loop_with_init);\n@@ -1369,18 +859,27 @@ build_array_notation_expr (location_t location, tree lhs, tree lhs_origtype,\n       tree incr_list = alloc_stmt_list ();\n       tree new_loop = push_stmt_list ();\n       if (lhs_rank)\n-\tadd_stmt (lhs_ind_init[ii]);\n+\tadd_stmt (lhs_an_loop_info[ii].ind_init);\n       if (rhs_rank)\n-\tadd_stmt (rhs_ind_init[ii]);\n+\tadd_stmt (rhs_an_loop_info[ii].ind_init);\n       if (lhs_rank)\n-\tappend_to_statement_list_force (lhs_expr_incr[ii], &incr_list);\n-      if (rhs_rank && rhs_expr_incr[ii])\n-\tappend_to_statement_list_force (rhs_expr_incr[ii], &incr_list);\n+\tappend_to_statement_list_force (lhs_an_loop_info[ii].incr, &incr_list);\n+      if (rhs_rank && rhs_an_loop_info[ii].incr)\n+\tappend_to_statement_list_force (rhs_an_loop_info[ii].incr, &incr_list);\n       c_finish_loop (location, cond_expr[ii], incr_list, body, NULL_TREE,\n \t\t     NULL_TREE, true);\n       body = pop_stmt_list (new_loop);\n     }\n   append_to_statement_list_force (body, &loop_with_init);\n+\n+  lhs_an_info.release ();\n+  lhs_an_loop_info.release ();\n+  if (rhs_rank)\n+    {\n+      rhs_an_info.release ();\n+      rhs_an_loop_info.release ();\n+    }\n+  cond_expr.release ();\n   return loop_with_init;\n }\n \n@@ -1396,15 +895,13 @@ fix_conditional_array_notations_1 (tree stmt)\n   vec<tree, va_gc> *array_list = NULL, *array_operand = NULL;\n   size_t list_size = 0;\n   tree cond = NULL_TREE, builtin_loop = NULL_TREE, new_var = NULL_TREE;\n-  size_t rank = 0, ii = 0, jj = 0;\n-  int s_jj = 0;\n-  tree **array_ops, *array_var, jj_tree, loop_init;\n-  tree **array_value, **array_stride, **array_length, **array_start;\n-  tree *compare_expr, *expr_incr, *ind_init;\n-  bool **count_down, **array_vector;\n-  tree begin_var, lngth_var, strde_var;\n+  size_t rank = 0, ii = 0;\n+  tree loop_init;\n   location_t location = EXPR_LOCATION (stmt);\n   tree body = NULL_TREE, loop_with_init = alloc_stmt_list ();\n+  vec<vec<an_parts> > an_info = vNULL;\n+  vec<an_loop_parts> an_loop_info = vNULL;\n+ \n   if (TREE_CODE (stmt) == COND_EXPR)\n     cond = COND_EXPR_COND (stmt);\n   else if (TREE_CODE (stmt) == SWITCH_EXPR)\n@@ -1440,7 +937,6 @@ fix_conditional_array_notations_1 (tree stmt)\n \t    }\n \t}\n     }\n-\n   if (!find_rank (location, stmt, stmt, true, &rank))\n     {\n       pop_stmt_list (loop_init);\n@@ -1458,228 +954,50 @@ fix_conditional_array_notations_1 (tree stmt)\n     return stmt;\n \n   list_size = vec_safe_length (array_list);\n-\n-  array_ops =  XNEWVEC (tree *, list_size);\n-  for (ii = 0; ii < list_size; ii++)\n-    array_ops[ii] =  XNEWVEC (tree, rank);\n-\n-  array_vector =  XNEWVEC (bool *, list_size);\n-  for (ii = 0; ii < list_size; ii++)\n-    array_vector[ii] =  XNEWVEC (bool, rank);\n-\n-  array_value = XNEWVEC (tree *, list_size);\n-  array_stride = XNEWVEC (tree *, list_size);\n-  array_length = XNEWVEC (tree *, list_size);\n-  array_start =  XNEWVEC (tree *, list_size);\n-\n-  for (ii = 0; ii < list_size; ii++)\n-    {\n-      array_value[ii]  = XNEWVEC (tree, rank);\n-      array_stride[ii] = XNEWVEC (tree, rank);\n-      array_length[ii] = XNEWVEC (tree, rank);\n-      array_start[ii]  = XNEWVEC (tree, rank);\n-    }\n-\n-  compare_expr = XNEWVEC (tree, rank);\n-  expr_incr = XNEWVEC (tree, rank);\n-  ind_init = XNEWVEC (tree,  rank);\n-\n-  count_down = XNEWVEC (bool *, list_size);\n-  for (ii = 0; ii < list_size; ii++)\n-    count_down[ii] = XNEWVEC (bool, rank);\n-\n-  array_var = XNEWVEC (tree, rank);\n-\n-  for (ii = 0; ii < list_size; ii++)\n-    {\n-      tree array_node = (*array_list)[ii];\n-      if (array_node && TREE_CODE (array_node) == ARRAY_NOTATION_REF)\n-\t{\n-\t  tree array_begin = ARRAY_NOTATION_START (array_node);\n-\t  tree array_lngth = ARRAY_NOTATION_LENGTH (array_node);\n-\t  tree array_strde = ARRAY_NOTATION_STRIDE (array_node);\n-\n-\t  if (TREE_CODE (array_begin) != INTEGER_CST)\n-\t    {\n-\t      begin_var = build_decl (location, VAR_DECL, NULL_TREE,\n-\t\t\t\t      integer_type_node);\n-\t      add_stmt (build_modify_expr (location, begin_var,\n-\t\t\t\t\t   TREE_TYPE (begin_var),\n-\t\t\t\t\t   NOP_EXPR, location, array_begin,\n-\t\t\t\t\t   TREE_TYPE (array_begin)));\n-\t      ARRAY_NOTATION_START (array_node) = begin_var;\n-\t    }\n-\t  if (TREE_CODE (array_lngth) != INTEGER_CST)\n-\t    {\n-\t      lngth_var = build_decl (location, VAR_DECL, NULL_TREE,\n-\t\t\t\t      integer_type_node);\n-\t      add_stmt (build_modify_expr (location, lngth_var,\n-\t\t\t\t\t   TREE_TYPE (lngth_var),\n-\t\t\t\t\t   NOP_EXPR, location, array_lngth,\n-\t\t\t\t\t   TREE_TYPE (array_lngth)));\n-\t      ARRAY_NOTATION_LENGTH (array_node) = lngth_var;\n-\t    }\n-\t  if (TREE_CODE (array_strde) != INTEGER_CST)\n-\t    {\n-\t      strde_var = build_decl (location, VAR_DECL, NULL_TREE,\n-\t\t\t\t      integer_type_node);\n-\t      add_stmt (build_modify_expr (location, strde_var,\n-\t\t\t\t\t   TREE_TYPE (strde_var),\n-\t\t\t\t\t   NOP_EXPR, location, array_strde,\n-\t\t\t\t\t   TREE_TYPE (array_strde)));\n-\t      ARRAY_NOTATION_STRIDE (array_node) = strde_var;\n-\t    }\n-\t}\n-    }  \n-  for (ii = 0; ii < list_size; ii++)\n-    {\n-      tree array_node = (*array_list)[ii];\n-      jj = 0;\n-      for (jj_tree = array_node;\n-\t   jj_tree && TREE_CODE (jj_tree) == ARRAY_NOTATION_REF;\n-\t   jj_tree = ARRAY_NOTATION_ARRAY (jj_tree))\n-\t{\n-\t  array_ops[ii][jj] = jj_tree;\n-\t  jj++;\n-\t}\n-    }\n+  an_loop_info.safe_grow_cleared (rank);\n+  \n   for (ii = 0; ii < list_size; ii++)\n-    {\n-      tree array_node = (*array_list)[ii];\n-      if (TREE_CODE (array_node) == ARRAY_NOTATION_REF)\n-\t{\n-\t  for (jj = 0; jj < rank; jj++)\n-\t    {\n-\t      if (TREE_CODE (array_ops[ii][jj]) == ARRAY_NOTATION_REF)\n-\t\t{\n-\t\t  array_value[ii][jj] =\n-\t\t    ARRAY_NOTATION_ARRAY (array_ops[ii][jj]);\n-\t\t  array_start[ii][jj] =\n-\t\t    ARRAY_NOTATION_START (array_ops[ii][jj]);\n-\t\t  array_length[ii][jj] =\n-\t\t    fold_build1 (CONVERT_EXPR, integer_type_node,\n-\t\t\t\t ARRAY_NOTATION_LENGTH (array_ops[ii][jj]));\n-\t\t  array_stride[ii][jj] =\n-\t\t    fold_build1 (CONVERT_EXPR, integer_type_node,\n-\t\t\t\t ARRAY_NOTATION_STRIDE (array_ops[ii][jj]));\n-\t\t  array_vector[ii][jj] = true;\n-\n-\t\t  if (!TREE_CONSTANT (array_length[ii][jj]))\n-\t\t      count_down[ii][jj] = false;\n-\t\t  else if (tree_int_cst_lt\n-\t\t\t   (array_length[ii][jj],\n-\t\t\t    build_int_cst (TREE_TYPE (array_length[ii][jj]),\n-\t\t\t\t\t   0)))\n-\t\t    count_down[ii][jj] = true;\n-\t\t  else\n-\t\t    count_down[ii][jj] = false;\n-\t\t}\n-\t      else\n-\t\tarray_vector[ii][jj] = false;\n-\t    }\n-\t}\n-    }\n-\n+    if ((*array_list)[ii]\n+\t&& TREE_CODE ((*array_list)[ii]) == ARRAY_NOTATION_REF)\n+      {\n+\ttree array_node = (*array_list)[ii];\n+\tmake_triplet_val_inv (location, &ARRAY_NOTATION_START (array_node));\n+\tmake_triplet_val_inv (location, &ARRAY_NOTATION_LENGTH (array_node));\n+\tmake_triplet_val_inv (location, &ARRAY_NOTATION_STRIDE (array_node));\n+      }\n+  cilkplus_extract_an_triplets (array_list, list_size, rank, &an_info);\n   for (ii = 0; ii < rank; ii++)\n     {\n-      array_var[ii] = build_decl (location, VAR_DECL, NULL_TREE,\n-\t\t\t\t  integer_type_node);\n-      ind_init[ii] =\n-\tbuild_modify_expr (location, array_var[ii],\n-\t\t\t   TREE_TYPE (array_var[ii]), NOP_EXPR,\n+      an_loop_info[ii].var = build_decl (location, VAR_DECL, NULL_TREE,\n+\t\t\t\t\t integer_type_node);\n+      an_loop_info[ii].ind_init =\n+\tbuild_modify_expr (location, an_loop_info[ii].var,\n+\t\t\t   TREE_TYPE (an_loop_info[ii].var), NOP_EXPR,\n \t\t\t   location,\n-\t\t\t   build_int_cst (TREE_TYPE (array_var[ii]), 0),\n-\t\t\t   TREE_TYPE (array_var[ii]));\n-    }\n-  \n-  for (ii = 0; ii < list_size; ii++)\n-    {\n-      if (array_vector[ii][0])\n-\t{\n-\t  tree array_opr = array_value[ii][rank - 1];\n-\t  for (s_jj = rank - 1; s_jj >= 0; s_jj--)\n-\t    {\n-\t      if (count_down[ii][s_jj])\n-\t\t/* Array[start_index - (induction_var * stride)] */\n-\t\tarray_opr = build_array_ref\n-\t\t  (location, array_opr,\n-\t\t   build2 (MINUS_EXPR, TREE_TYPE (array_var[s_jj]),\n-\t\t\t   array_start[ii][s_jj],\n-\t\t\t   build2 (MULT_EXPR, TREE_TYPE (array_var[s_jj]),\n-\t\t\t\t   array_var[s_jj], array_stride[ii][s_jj])));\n-\t      else\n-\t\t/* Array[start_index + (induction_var * stride)] */\n-\t\tarray_opr = build_array_ref\n-\t\t  (location, array_opr,\n-\t\t   build2 (PLUS_EXPR, TREE_TYPE (array_var[s_jj]),\n-\t\t\t   array_start[ii][s_jj],\n-\t\t\t   build2 (MULT_EXPR, TREE_TYPE (array_var[s_jj]),\n-\t\t\t\t   array_var[s_jj], array_stride[ii][s_jj])));\n-\t    }\n-\t  vec_safe_push (array_operand, array_opr);\n-\t}\n-      else\n-\t/* This is just a dummy node to make sure the list sizes for both\n-\t   array list and array operand list are the same.  */\n-\tvec_safe_push (array_operand, integer_one_node);\n+\t\t\t   build_int_cst (TREE_TYPE (an_loop_info[ii].var), 0),\n+\t\t\t   TREE_TYPE (an_loop_info[ii].var));\n     }\n+  array_operand = create_array_refs (location, an_info, an_loop_info,\n+\t\t\t\t     list_size, rank);\n   replace_array_notations (&stmt, true, array_list, array_operand);\n-  for (ii = 0; ii < rank; ii++) \n-    expr_incr[ii] = build2 (MODIFY_EXPR, void_type_node, array_var[ii], \n-\t\t\t    build2 (PLUS_EXPR, TREE_TYPE (array_var[ii]), \n-\t\t\t\t    array_var[ii], \n-\t\t\t\t    build_int_cst (TREE_TYPE (array_var[ii]), \n-\t\t\t\t\t\t   1)));\n-  for (jj = 0; jj < rank; jj++)\n-    {\n-      if (rank && expr_incr[jj])\n-\t{\n-\t  if (count_down[0][jj])\n-\t    compare_expr[jj] =\n-\t      build2 (LT_EXPR, boolean_type_node, array_var[jj],\n-\t\t      build2 (MULT_EXPR, TREE_TYPE (array_var[jj]),\n-\t\t\t      array_length[0][jj],\n-\t\t\t      build_int_cst (TREE_TYPE (array_var[jj]), -1)));\n-\t  else\n-\t    compare_expr[jj] = build2 (LT_EXPR, boolean_type_node,\n-\t\t\t\t       array_var[jj], array_length[0][jj]);\n-\t}\n-    }\n-\n+  create_cmp_incr (location, &an_loop_info, rank, an_info);\n+  \n   loop_init = pop_stmt_list (loop_init);\n   body = stmt;\n   append_to_statement_list_force (loop_init, &loop_with_init);\n \n   for (ii = 0; ii < rank; ii++)\n     {\n       tree new_loop = push_stmt_list ();\n-      add_stmt (ind_init[ii]);\n-      c_finish_loop (location, compare_expr[ii], expr_incr[ii], body, NULL_TREE,\n-\t\t     NULL_TREE, true);\n+      add_stmt (an_loop_info[ii].ind_init);\n+      c_finish_loop (location, an_loop_info[ii].cmp, an_loop_info[ii].incr,\n+\t\t     body, NULL_TREE, NULL_TREE, true);\n       body = pop_stmt_list (new_loop);\n     }\n   append_to_statement_list_force (body, &loop_with_init);\n-  XDELETEVEC (expr_incr);\n-  XDELETEVEC (ind_init);\n-  \n-  for (ii = 0; ii < list_size; ii++)\n-    {\n-      XDELETEVEC (count_down[ii]);\n-      XDELETEVEC (array_value[ii]);\n-      XDELETEVEC (array_stride[ii]);\n-      XDELETEVEC (array_length[ii]);\n-      XDELETEVEC (array_start[ii]);\n-      XDELETEVEC (array_ops[ii]);\n-      XDELETEVEC (array_vector[ii]);\n-    }\n \n-  XDELETEVEC (count_down);\n-  XDELETEVEC (array_value);\n-  XDELETEVEC (array_stride);\n-  XDELETEVEC (array_length);\n-  XDELETEVEC (array_start);\n-  XDELETEVEC (array_ops);\n-  XDELETEVEC (array_vector);\n+  an_loop_info.release ();\n+  an_info.release ();\n \n   return loop_with_init;\n }\n@@ -1716,13 +1034,11 @@ fix_array_notation_expr (location_t location, enum tree_code code,\n {\n \n   vec<tree, va_gc> *array_list = NULL, *array_operand = NULL;\n-  size_t list_size = 0, rank = 0, ii = 0, jj = 0;\n-  int s_jj = 0;\n-  tree **array_ops, *array_var, jj_tree, loop_init;\n-  tree **array_value, **array_stride, **array_length, **array_start;\n-  tree *compare_expr, *expr_incr, *ind_init;\n+  size_t list_size = 0, rank = 0, ii = 0;\n+  tree loop_init;\n   tree body, loop_with_init = alloc_stmt_list ();\n-  bool **count_down, **array_vector;\n+  vec<vec<an_parts> > an_info = vNULL;\n+  vec<an_loop_parts> an_loop_info = vNULL;\n   \n   if (!find_rank (location, arg.value, arg.value, false, &rank))\n     {\n@@ -1742,165 +1058,33 @@ fix_array_notation_expr (location_t location, enum tree_code code,\n     return arg;\n \n   list_size = vec_safe_length (array_list);\n-  \n-  array_ops = XNEWVEC (tree *, list_size);\n-  for (ii = 0; ii < list_size; ii++)\n-    array_ops[ii] = XNEWVEC (tree,  rank);\n-  \n-  array_vector =  XNEWVEC (bool *, list_size);\n-  for (ii = 0; ii < list_size; ii++)\n-    array_vector[ii] = XNEWVEC (bool, rank);\n-\n-  array_value = XNEWVEC (tree *, list_size);\n-  array_stride = XNEWVEC (tree *, list_size);\n-  array_length = XNEWVEC (tree *, list_size);\n-  array_start = XNEWVEC (tree *, list_size);\n-\n-  for (ii = 0; ii < list_size; ii++)\n-    {\n-      array_value[ii]  = XNEWVEC (tree, rank);\n-      array_stride[ii] = XNEWVEC (tree, rank);\n-      array_length[ii] = XNEWVEC (tree, rank);\n-      array_start[ii]  = XNEWVEC (tree, rank);\n-    }\n \n-  compare_expr = XNEWVEC (tree, rank);\n-  expr_incr = XNEWVEC (tree, rank);\n-  ind_init = XNEWVEC (tree, rank);\n-  \n-  count_down = XNEWVEC (bool *, list_size);\n-  for (ii = 0; ii < list_size; ii++)\n-    count_down[ii] = XNEWVEC (bool, rank);\n-  array_var = XNEWVEC (tree, rank);\n-\n-  for (ii = 0; ii < list_size; ii++)\n-    {\n-      jj = 0;\n-      for (jj_tree = (*array_list)[ii];\n-\t   jj_tree && TREE_CODE (jj_tree) == ARRAY_NOTATION_REF;\n-\t   jj_tree = ARRAY_NOTATION_ARRAY (jj_tree))\n-\t{\n-\t  array_ops[ii][jj] = jj_tree;\n-\t  jj++;\n-\t}\n-    }\n+  an_loop_info.safe_grow_cleared (rank);\n+  cilkplus_extract_an_triplets (array_list, list_size, rank, &an_info);\n   \n   loop_init = push_stmt_list ();\n-\n-  for (ii = 0; ii < list_size; ii++)\n-    {\n-      tree array_node = (*array_list)[ii];\n-      if (TREE_CODE (array_node) == ARRAY_NOTATION_REF)\n-\t{\n-\t  for (jj = 0; jj < rank; jj++)\n-\t    {\n-\t      if (TREE_CODE (array_ops[ii][jj]) == ARRAY_NOTATION_REF)\n-\t\t{\n-\t\t  array_value[ii][jj] =\n-\t\t    ARRAY_NOTATION_ARRAY (array_ops[ii][jj]);\n-\t\t  array_start[ii][jj] =\n-\t\t    ARRAY_NOTATION_START (array_ops[ii][jj]);\n-\t\t  array_length[ii][jj] =\n-\t\t    fold_build1 (CONVERT_EXPR, integer_type_node,\n-\t\t\t\t ARRAY_NOTATION_LENGTH (array_ops[ii][jj]));\n-\t\t  array_stride[ii][jj] =\n-\t\t    fold_build1 (CONVERT_EXPR, integer_type_node,\n-\t\t\t\t ARRAY_NOTATION_STRIDE (array_ops[ii][jj]));\n-\t\t  array_vector[ii][jj] = true;\n-\n-\t\t  if (!TREE_CONSTANT (array_length[ii][jj])) \n-\t\t    count_down[ii][jj] = false;\n-\t\t  else if (tree_int_cst_lt\n-\t\t\t   (array_length[ii][jj],\n-\t\t\t    build_int_cst (TREE_TYPE (array_length[ii][jj]),\n-\t\t\t\t\t   0)))\n-\t\t    count_down[ii][jj] = true;\n-\t\t  else\n-\t\t    count_down[ii][jj] = false;\n-\t\t}\n-\t      else\n-\t\tarray_vector[ii][jj] = false;\n-\t    }\n-\t}\n-    }\n-\n   for (ii = 0; ii < rank; ii++)\n     {\n-      array_var[ii] = build_decl (location, VAR_DECL, NULL_TREE,\n-\t\t\t\t  integer_type_node);\n-      ind_init[ii] =\n-\tbuild_modify_expr (location, array_var[ii],\n-\t\t\t   TREE_TYPE (array_var[ii]), NOP_EXPR,\n+      an_loop_info[ii].var = build_decl (location, VAR_DECL, NULL_TREE,\n+\t\t\t\t\t integer_type_node);\n+      an_loop_info[ii].ind_init =\n+\tbuild_modify_expr (location, an_loop_info[ii].var,\n+\t\t\t   TREE_TYPE (an_loop_info[ii].var), NOP_EXPR,\n \t\t\t   location,\n-\t\t\t   build_int_cst (TREE_TYPE (array_var[ii]), 0),\n-\t\t\t   TREE_TYPE (array_var[ii]));\n+\t\t\t   build_int_cst (TREE_TYPE (an_loop_info[ii].var), 0),\n+\t\t\t   TREE_TYPE (an_loop_info[ii].var));;\n \t\n     }\n-  for (ii = 0; ii < list_size; ii++)\n-    {\n-      if (array_vector[ii][0])\n-\t{\n-\t  tree array_opr = array_value[ii][rank - 1];\n-\t  for (s_jj = rank - 1; s_jj >= 0; s_jj--)\n-\t    {\n-\t      if (count_down[ii][s_jj])\n-\t\t/* Array[start_index - (induction_var * stride)] */\n-\t\tarray_opr = build_array_ref\n-\t\t  (location, array_opr,\n-\t\t   build2 (MINUS_EXPR, TREE_TYPE (array_var[s_jj]),\n-\t\t\t   array_start[ii][s_jj],\n-\t\t\t   build2 (MULT_EXPR, TREE_TYPE (array_var[s_jj]),\n-\t\t\t\t   array_var[s_jj], array_stride[ii][s_jj])));\n-\t      else\n-\t\t/* Array[start_index + (induction_var * stride)] */\n-\t\tarray_opr = build_array_ref\n-\t\t  (location, array_opr,\n-\t\t   build2 (PLUS_EXPR, TREE_TYPE (array_var[s_jj]),\n-\t\t\t   array_start[ii][s_jj],\n-\t\t\t   build2 (MULT_EXPR, TREE_TYPE (array_var[s_jj]),\n-\t\t\t\t   array_var[s_jj], array_stride[ii][s_jj])));\n-\t    }\n-\t  vec_safe_push (array_operand, array_opr);\n-\t}\n-      else\n-      \t/* This is just a dummy node to make sure the list sizes for both\n-\t   array list and array operand list are the same.  */\n-\tvec_safe_push (array_operand, integer_one_node);\n-    }\n+  array_operand = create_array_refs (location, an_info, an_loop_info,\n+\t\t\t\t     list_size, rank);\n   replace_array_notations (&arg.value, true, array_list, array_operand);\n+  create_cmp_incr (location, &an_loop_info, rank, an_info);\n \n-  for (ii = 0; ii < rank; ii++)\n-    expr_incr[ii] =\n-      build2 (MODIFY_EXPR, void_type_node, array_var[ii],\n-\t      build2 (PLUS_EXPR, TREE_TYPE (array_var[ii]), array_var[ii],\n-\t\t      build_int_cst (TREE_TYPE (array_var[ii]), 1)));\n-  \n-  for (jj = 0; jj < rank; jj++)\n-    {\n-      if (rank && expr_incr[jj])\n-\t{\n-\t  if (count_down[0][jj])\n-\t    compare_expr[jj] =\n-\t      build2 (LT_EXPR, boolean_type_node, array_var[jj],\n-\t\t      build2 (MULT_EXPR, TREE_TYPE (array_var[jj]),\n-\t\t\t      array_length[0][jj],\n-\t\t\t      build_int_cst (TREE_TYPE (array_var[jj]), -1)));\n-\t  else\n-\t    compare_expr[jj] = build2 (LT_EXPR, boolean_type_node,\n-\t\t\t\t       array_var[jj], array_length[0][jj]);\n-\t}\n-    }\n-  \n+  arg = default_function_array_read_conversion (location, arg);\n   if (code == POSTINCREMENT_EXPR || code == POSTDECREMENT_EXPR)\n-    {\n-      arg = default_function_array_read_conversion (location, arg);\n-      arg.value = build_unary_op (location, code, arg.value, 0);\n-    }\n+    arg.value = build_unary_op (location, code, arg.value, 0);\n   else if (code == PREINCREMENT_EXPR || code == PREDECREMENT_EXPR)\n-    {\n-      arg = default_function_array_read_conversion (location, arg);\n-      arg = parser_build_unary_op (location, code, arg);\n-    }\n+    arg = parser_build_unary_op (location, code, arg);\n \n   loop_init = pop_stmt_list (loop_init);\n   append_to_statement_list_force (loop_init, &loop_with_init);\n@@ -1909,36 +1093,16 @@ fix_array_notation_expr (location_t location, enum tree_code code,\n   for (ii = 0; ii < rank; ii++)\n     {\n       tree new_loop = push_stmt_list ();\n-      add_stmt (ind_init[ii]);\n-      c_finish_loop (location, compare_expr[ii], expr_incr[ii], body, NULL_TREE,\n+      add_stmt (an_loop_info[ii].ind_init);\n+      c_finish_loop (location, an_loop_info[ii].cmp,\n+\t\t     an_loop_info[ii].incr, body, NULL_TREE,\n \t\t     NULL_TREE, true);\n       body = pop_stmt_list (new_loop);\n     }\n   append_to_statement_list_force (body, &loop_with_init);\n-   XDELETEVEC (expr_incr);\n-  XDELETEVEC (ind_init);\n-  XDELETEVEC (array_var);\n-  \n-  for (ii = 0; ii < list_size; ii++)\n-    {\n-      XDELETEVEC (count_down[ii]);\n-      XDELETEVEC (array_value[ii]);\n-      XDELETEVEC (array_stride[ii]);\n-      XDELETEVEC (array_length[ii]);\n-      XDELETEVEC (array_start[ii]);\n-      XDELETEVEC (array_ops[ii]);\n-      XDELETEVEC (array_vector[ii]);\n-    }\n-\n-  XDELETEVEC (count_down);\n-  XDELETEVEC (array_value);\n-  XDELETEVEC (array_stride);\n-  XDELETEVEC (array_length);\n-  XDELETEVEC (array_start);\n-  XDELETEVEC (array_ops);\n-  XDELETEVEC (array_vector);\n-\n   arg.value = loop_with_init;\n+  an_info.release ();\n+  an_loop_info.release ();\n   return arg;\n }\n \n@@ -1950,15 +1114,12 @@ fix_array_notation_call_expr (tree arg)\n {\n   vec<tree, va_gc> *array_list = NULL, *array_operand = NULL;\n   tree new_var = NULL_TREE;\n-  size_t list_size = 0, rank = 0, ii = 0, jj = 0;\n-  int s_jj = 0;\n-  tree **array_ops, *array_var, jj_tree, loop_init;\n-  tree **array_value, **array_stride, **array_length, **array_start;\n+  size_t list_size = 0, rank = 0, ii = 0;\n+  tree loop_init;\n   tree body, loop_with_init = alloc_stmt_list ();\n-  tree *compare_expr, *expr_incr, *ind_init;\n-  bool **count_down, **array_vector;\n-  tree begin_var, lngth_var, strde_var;\n   location_t location = UNKNOWN_LOCATION;\n+  vec<vec<an_parts> > an_info = vNULL;\n+  vec<an_loop_parts> an_loop_info = vNULL;\n \n   if (TREE_CODE (arg) == CALL_EXPR\n       && is_cilkplus_reduce_builtin (CALL_EXPR_FN (arg)))\n@@ -1967,8 +1128,7 @@ fix_array_notation_call_expr (tree arg)\n       /* We are ignoring the new var because either the user does not want to\n \t capture it OR he is using sec_reduce_mutating function.  */\n       return loop_init;\n-    }\n-  \n+    }  \n   if (!find_rank (location, arg, arg, false, &rank))\n     return error_mark_node;\n   \n@@ -1981,237 +1141,53 @@ fix_array_notation_call_expr (tree arg)\n   \n   list_size = vec_safe_length (array_list);\n   location = EXPR_LOCATION (arg);\n-\n-  array_ops = XNEWVEC (tree *, list_size);\n-  for (ii = 0; ii < list_size; ii++)\n-    array_ops[ii] = XNEWVEC (tree, rank);\n-  \n-  array_vector = XNEWVEC (bool *, list_size);\n-  for (ii = 0; ii < list_size; ii++)\n-    array_vector[ii] = (bool *) XNEWVEC (bool, rank);\n-\n-  array_value = XNEWVEC (tree *, list_size);\n-  array_stride = XNEWVEC (tree *, list_size);\n-  array_length = XNEWVEC (tree *, list_size);\n-  array_start = XNEWVEC (tree *, list_size);\n-\n-  for (ii = 0; ii < list_size; ii++)\n-    {\n-      array_value[ii]  = XNEWVEC (tree, rank);\n-      array_stride[ii] = XNEWVEC (tree, rank);\n-      array_length[ii] = XNEWVEC (tree, rank);\n-      array_start[ii]  = XNEWVEC (tree, rank);\n-    }\n-\n-  compare_expr = XNEWVEC (tree, rank);\n-  expr_incr = XNEWVEC (tree, rank);\n-  ind_init = XNEWVEC (tree, rank);\n-  \n-  count_down =  XNEWVEC (bool *, list_size);\n-  for (ii = 0; ii < list_size; ii++)\n-    count_down[ii] = XNEWVEC (bool, rank);\n-  \n-  array_var = XNEWVEC (tree, rank);\n+  an_loop_info.safe_grow_cleared (rank);\n   \n   loop_init = push_stmt_list ();\n   for (ii = 0; ii < list_size; ii++)\n-    {\n-      tree array_node = (*array_list)[ii];\n-      if (array_node && TREE_CODE (array_node) == ARRAY_NOTATION_REF)\n-\t{\n-\t  tree array_begin = ARRAY_NOTATION_START (array_node);\n-\t  tree array_lngth = ARRAY_NOTATION_LENGTH (array_node);\n-\t  tree array_strde = ARRAY_NOTATION_STRIDE (array_node);\n-\n-\t  if (TREE_CODE (array_begin) != INTEGER_CST)\n-\t    {\n-\t      begin_var = build_decl (location, VAR_DECL, NULL_TREE,\n-\t\t\t\t      integer_type_node);\n-\t      add_stmt (build_modify_expr (location, begin_var,\n-\t\t\t\t\t   TREE_TYPE (begin_var),\n-\t\t\t\t\t   NOP_EXPR, location, array_begin,\n-\t\t\t\t\t   TREE_TYPE (array_begin)));\n-\t      ARRAY_NOTATION_START (array_node) = begin_var;\n-\t    }\n-\t  if (TREE_CODE (array_lngth) != INTEGER_CST)\n-\t    {\n-\t      lngth_var = build_decl (location, VAR_DECL, NULL_TREE,\n-\t\t\t\t      integer_type_node);\n-\t      add_stmt (build_modify_expr (location, lngth_var,\n-\t\t\t\t\t   TREE_TYPE (lngth_var),\n-\t\t\t\t\t   NOP_EXPR, location, array_lngth,\n-\t\t\t\t\t   TREE_TYPE (array_lngth)));\n-\t      ARRAY_NOTATION_LENGTH (array_node) = lngth_var;\n-\t    }\n-\t  if (TREE_CODE (array_strde) != INTEGER_CST)\n-\t    {\n-\t      strde_var = build_decl (location, VAR_DECL, NULL_TREE,\n-\t\t\t\t      integer_type_node);\n-\t      add_stmt (build_modify_expr (location, strde_var,\n-\t\t\t\t\t   TREE_TYPE (strde_var),\n-\t\t\t\t\t   NOP_EXPR, location, array_strde,\n-\t\t\t\t\t   TREE_TYPE (array_strde)));\n-\t      ARRAY_NOTATION_STRIDE (array_node) = strde_var;\n-\t    }\n-\t}\n-    }\n-  for (ii = 0; ii < list_size; ii++)\n-    {\n-      jj = 0;\n-      for (jj_tree = (*array_list)[ii];\n-\t   jj_tree && TREE_CODE (jj_tree) == ARRAY_NOTATION_REF;\n-\t   jj_tree = ARRAY_NOTATION_ARRAY (jj_tree))\n+    if ((*array_list)[ii]\n+\t&& TREE_CODE ((*array_list)[ii]) == ARRAY_NOTATION_REF)\n \t{\n-\t  array_ops[ii][jj] = jj_tree;\n-\t  jj++;\n+\t  tree array_node = (*array_list)[ii];\n+\t  make_triplet_val_inv (location, &ARRAY_NOTATION_START (array_node));\n+\t  make_triplet_val_inv (location, &ARRAY_NOTATION_LENGTH (array_node));\n+\t  make_triplet_val_inv (location, &ARRAY_NOTATION_STRIDE (array_node));\n \t}\n-    }\n-\n-  for (ii = 0; ii < list_size; ii++)\n-    {\n-      tree array_node = (*array_list)[ii];\n-      if (TREE_CODE (array_node) == ARRAY_NOTATION_REF)\n-\t{\n-\t  for (jj = 0; jj < rank; jj++)\n-\t    {\n-\t      if (TREE_CODE (array_ops[ii][jj]) == ARRAY_NOTATION_REF)\n-\t\t{\n-\t\t  array_value[ii][jj] =\n-\t\t    ARRAY_NOTATION_ARRAY (array_ops[ii][jj]);\n-\t\t  array_start[ii][jj] =\n-\t\t    ARRAY_NOTATION_START (array_ops[ii][jj]);\n-\t\t  array_length[ii][jj] =\n-\t\t    fold_build1 (CONVERT_EXPR, integer_type_node,\n-\t\t\t\t ARRAY_NOTATION_LENGTH (array_ops[ii][jj]));\n-\t\t  array_stride[ii][jj] =\n-\t\t    fold_build1 (CONVERT_EXPR, integer_type_node,\n-\t\t\t\t ARRAY_NOTATION_STRIDE (array_ops[ii][jj]));\n-\t\t  array_vector[ii][jj] = true;\n-\n-\t\t  if (!TREE_CONSTANT (array_length[ii][jj])) \n-\t\t    count_down[ii][jj] = false;\n-\t\t  else if (tree_int_cst_lt\n-\t\t\t   (array_length[ii][jj],\n-\t\t\t    build_int_cst (TREE_TYPE (array_length[ii][jj]),\n-\t\t\t\t\t   0)))\n-\t\t    count_down[ii][jj] = true;\n-\t\t  else\n-\t\t    count_down[ii][jj] = false;\n-\t\t}\n-\t      else\n-\t\tarray_vector[ii][jj] = false;\n-\t    }\n-\t}\n-    }\n-\n-  if (length_mismatch_in_expr_p (location, array_length, list_size, rank))\n+  cilkplus_extract_an_triplets (array_list, list_size, rank, &an_info);\n+  if (length_mismatch_in_expr_p (location, an_info))\n     {\n       pop_stmt_list (loop_init);\n       return error_mark_node;\n     }\n-  \n   for (ii = 0; ii < rank; ii++)\n     {\n-      array_var[ii] = build_decl (location, VAR_DECL, NULL_TREE,\n-\t\t\t\t  integer_type_node);\n-      ind_init[ii] =\n-\tbuild_modify_expr (location, array_var[ii],\n-\t\t\t   TREE_TYPE (array_var[ii]), NOP_EXPR,\n-\t\t\t   location,\n-\t\t\t   build_int_cst (TREE_TYPE (array_var[ii]), 0),\n-\t\t\t   TREE_TYPE (array_var[ii]));\n+      an_loop_info[ii].var = build_decl (location, VAR_DECL, NULL_TREE,\n+\t\t\t\t\t integer_type_node);\n+      an_loop_info[ii].ind_init =\n+\tbuild_modify_expr (location, an_loop_info[ii].var,\n+\t\t\t   TREE_TYPE (an_loop_info[ii].var), NOP_EXPR, location,\n+\t\t\t   build_int_cst (TREE_TYPE (an_loop_info[ii].var), 0),\n+\t\t\t   TREE_TYPE (an_loop_info[ii].var));\n \t\n     }\n-  for (ii = 0; ii < list_size; ii++)\n-    {\n-      if (array_vector[ii][0])\n-\t{\n-\t  tree array_opr_node = array_value[ii][rank - 1];\n-\t  for (s_jj = rank - 1; s_jj >= 0; s_jj--)\n-\t    {\n-\t      if (count_down[ii][s_jj])\n-\t\t/* Array[start_index - (induction_var * stride)] */\n-\t\tarray_opr_node = build_array_ref\n-\t\t  (location, array_opr_node,\n-\t\t   build2 (MINUS_EXPR, TREE_TYPE (array_var[s_jj]),\n-\t\t\t   array_start[ii][s_jj],\n-\t\t\t   build2 (MULT_EXPR, TREE_TYPE (array_var[s_jj]),\n-\t\t\t\t   array_var[s_jj], array_stride[ii][s_jj])));\n-\t      else\n-\t\t/* Array[start_index + (induction_var * stride)] */\n-\t\tarray_opr_node = build_array_ref\n-\t\t  (location, array_opr_node,\n-\t\t   build2 (PLUS_EXPR, TREE_TYPE (array_var[s_jj]),\n-\t\t\t   array_start[ii][s_jj],\n-\t\t\t   build2 (MULT_EXPR, TREE_TYPE (array_var[s_jj]),\n-\t\t\t\t   array_var[s_jj], array_stride[ii][s_jj])));\n-\t    }\n-\t  vec_safe_push (array_operand, array_opr_node);\n-\t}\n-      else\n-\t/* This is just a dummy node to make sure the list sizes for both\n-\t   array list and array operand list are the same.  */\n-\tvec_safe_push (array_operand, integer_one_node);\n-    }\n+  array_operand = create_array_refs (location, an_info, an_loop_info,\n+\t\t\t\t     list_size, rank);\n   replace_array_notations (&arg, true, array_list, array_operand);\n-  for (ii = 0; ii < rank; ii++) \n-    expr_incr[ii] = \n-      build2 (MODIFY_EXPR, void_type_node, array_var[ii], \n-\t      build2 (PLUS_EXPR, TREE_TYPE (array_var[ii]), array_var[ii], \n-\t\t      build_int_cst (TREE_TYPE (array_var[ii]), 1)));\n-  \n-  for (jj = 0; jj < rank; jj++)\n-    {\n-      if (rank && expr_incr[jj])\n-\t{\n-\t  if (count_down[0][jj])\n-\t    compare_expr[jj] =\n-\t      build2 (LT_EXPR, boolean_type_node, array_var[jj],\n-\t\t      build2 (MULT_EXPR, TREE_TYPE (array_var[jj]),\n-\t\t\t      array_length[0][jj],\n-\t\t\t      build_int_cst (TREE_TYPE (array_var[jj]), -1)));\n-\t  else\n-\t    compare_expr[jj] = build2 (LT_EXPR, boolean_type_node,\n-\t\t\t\t       array_var[jj], array_length[0][jj]);\n-\t}\n-    }\n-\n+  create_cmp_incr (location, &an_loop_info, rank, an_info);\n   loop_init = pop_stmt_list (loop_init);\n   append_to_statement_list_force (loop_init, &loop_with_init);\n   body = arg;\n   for (ii = 0; ii < rank; ii++)\n     {\n       tree new_loop = push_stmt_list ();\n-      add_stmt (ind_init[ii]);\n-      c_finish_loop (location, compare_expr[ii], expr_incr[ii], body, NULL_TREE,\n-\t\t     NULL_TREE, true);\n+      add_stmt (an_loop_info[ii].ind_init);\n+      c_finish_loop (location, an_loop_info[ii].cmp, an_loop_info[ii].incr,\n+\t\t     body, NULL_TREE, NULL_TREE, true);\n       body = pop_stmt_list (new_loop);\n     }\n   append_to_statement_list_force (body, &loop_with_init);\n-  XDELETEVEC (compare_expr);\n-  XDELETEVEC (expr_incr);\n-  XDELETEVEC (ind_init);\n-  XDELETEVEC (array_var);\n-  \n-  for (ii = 0; ii < list_size; ii++)\n-    {\n-      XDELETEVEC (count_down[ii]);\n-      XDELETEVEC (array_value[ii]);\n-      XDELETEVEC (array_stride[ii]);\n-      XDELETEVEC (array_length[ii]);\n-      XDELETEVEC (array_start[ii]);\n-      XDELETEVEC (array_ops[ii]);\n-      XDELETEVEC (array_vector[ii]);\n-    }\n-\n-  XDELETEVEC (count_down);\n-  XDELETEVEC (array_value);\n-  XDELETEVEC (array_stride);\n-  XDELETEVEC (array_length);\n-  XDELETEVEC (array_start);\n-  XDELETEVEC (array_ops);\n-  XDELETEVEC (array_vector);\n-  \n+  an_loop_info.release ();\n+  an_info.release ();\n   return loop_with_init;\n }\n \n@@ -2390,4 +1366,3 @@ build_array_notation_ref (location_t loc, tree array, tree start_index,\n   \n   return array_ntn_tree;\n }\n-"}, {"sha": "97d7fad089ccedd9b55397672d26eec1488598bd", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713b46fafe2e7079c1820254468c20e999ef85a5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713b46fafe2e7079c1820254468c20e999ef85a5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=713b46fafe2e7079c1820254468c20e999ef85a5", "patch": "@@ -40,6 +40,12 @@\n \t* typeck.c (build_x_conditional_expr): Likewise.\n \t* typeck2.c (check_narrowing): Likewise.\n \n+2013-06-21  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n+\n+\t* cp-array-notation.c (cp_length_mismatch_in_expr_p): Remove.\n+\t(expand_an_in_modify_expr): Changed a function call from the above\n+\tremoved function to length_mismatch_in_expr_p.\n+\n 2013-06-21  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n \n \t* call.c (convert_like_real): Added a check if array notation is present"}, {"sha": "491da0fecc4fe37f8be3b11f4f8fd7a0822568c3", "filename": "gcc/cp/cp-array-notation.c", "status": "modified", "additions": 3, "deletions": 49, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713b46fafe2e7079c1820254468c20e999ef85a5/gcc%2Fcp%2Fcp-array-notation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713b46fafe2e7079c1820254468c20e999ef85a5/gcc%2Fcp%2Fcp-array-notation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-array-notation.c?ref=713b46fafe2e7079c1820254468c20e999ef85a5", "patch": "@@ -78,52 +78,6 @@ create_an_loop (tree init, tree cond, tree incr, tree body)\n   finish_for_stmt (for_stmt);\n }\n \n-/* Returns true if there is a length mismatch among exprssions that are at the\n-   same dimension and one the same side of the equal sign.  The Array notation\n-   lengths (LIST->LENGTH) is passed in as a 2D vector of trees.  */\n-\n-static bool\n-cp_length_mismatch_in_expr_p (location_t loc, vec<vec<an_parts> >list)\n-{\n-  size_t ii, jj;\n-  tree length = NULL_TREE;\n-  HOST_WIDE_INT l_length, l_node;\n-  \n-  size_t x = list.length ();\n-  size_t y = list[0].length ();\n-  \n-  for (jj = 0; jj < y; jj++)\n-    {\n-      length = NULL_TREE;\n-      for (ii = 0; ii < x; ii++)\n-\t{\n-\t  if (!length)\n-\t    length = list[ii][jj].length;\n-\t  else if (TREE_CODE (length) == INTEGER_CST)\n-\t    {\n-\t      /* If length is a INTEGER, and list[ii][jj] is an integer then\n-\t\t check if they are equal.  If they are not equal then return\n-\t\t true.  */\n-\t      if (TREE_CODE (list[ii][jj].length) == INTEGER_CST)\n-\t\t{\n-\t\t  l_node = int_cst_value (list[ii][jj].length);\n-\t\t  l_length = int_cst_value (length);\n-\t\t  if (absu_hwi (l_length) != absu_hwi (l_node))\n-\t\t    {\n-\t\t      error_at (loc, \"length mismatch in expression\");\n-\t\t      return true;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  else\n-\t    /* We set the length node as the current node just in case it turns\n-\t       out to be an integer.  */\n-\t    length = list[ii][jj].length;\n-\t}\n-    }\n-  return false;\n-}\n-\n /* If *VALUE is not a constant integer, then this function replaces it with\n    a variable to make it loop invariant for array notations.  */\n \n@@ -744,9 +698,9 @@ expand_an_in_modify_expr (location_t location, tree lhs,\n   if (rhs_list)\n     cilkplus_extract_an_triplets (rhs_list, rhs_list_size, rhs_rank,\n \t\t\t\t  &rhs_an_info);\n-  if (cp_length_mismatch_in_expr_p (EXPR_LOCATION (lhs), lhs_an_info)\n-      || (rhs_list && cp_length_mismatch_in_expr_p (EXPR_LOCATION (rhs),\n-\t\t\t\t\t\t    rhs_an_info)))\n+  if (length_mismatch_in_expr_p (EXPR_LOCATION (lhs), lhs_an_info)\n+      || (rhs_list && length_mismatch_in_expr_p (EXPR_LOCATION (rhs),\n+\t\t\t\t\t\t rhs_an_info)))\n     {\n       pop_stmt_list (an_init);\n       return error_mark_node;"}]}