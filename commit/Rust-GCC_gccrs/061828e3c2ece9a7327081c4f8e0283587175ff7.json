{"sha": "061828e3c2ece9a7327081c4f8e0283587175ff7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDYxODI4ZTNjMmVjZTlhNzMyNzA4MWM0ZjhlMDI4MzU4NzE3NWZmNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-20T15:47:03Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-20T15:47:03Z"}, "message": "[multiple changes]\n\n2014-01-20  Robert Dewar  <dewar@adacore.com>\n\n\t* s-tataat.adb: Minor reformatting.\n\n2014-01-20  Robert Dewar  <dewar@adacore.com>\n\n\t* einfo.adb (Is_Descendent_Of_Address): Now applies to all\n\tentities, and also fix documentation to remove mention of visible\n\tinteger type, since this is not what the implementation does.\n\t* einfo.ads (Is_Descendent_Of_Address): Now applies to all\n\tentities, and also fix documentation to remove mention of visible\n\tinteger type, since this is not what the implementation does.\n\t* gnat_rm.texi: Minor clarification of Allow_Integer_Address\n\tfunction.\n\t* sem_ch4.adb (Analyze_One_Call): Handle Allow_Integer_Address\n\tcase for parameter type check.\n\t* sem_res.adb (Resolve): Use new function\n\tAddress_Integer_Convert_OK.\n\t* sem_type.adb: Minor code reorganization (use Ekind_In) Minor\n\treformatting throughout.\n\t* sem_util.adb (Address_Integer_Convert_OK): New function.\n\t* sem_util.ads: Minor reformatting (put specs in alpha order)\n\t(Address_Integer_Convert_OK): New function.\n\n2014-01-20  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_ch7.adb (Wrap_Transient_Expression):\n\tInsertion extra conditional expression only if\n\tOpt.Suppress_Control_Flow_Optimizations is set.\n\nFrom-SVN: r206832", "tree": {"sha": "20e082023d177655c2761b1671694c8dcac5d825", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20e082023d177655c2761b1671694c8dcac5d825"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/061828e3c2ece9a7327081c4f8e0283587175ff7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/061828e3c2ece9a7327081c4f8e0283587175ff7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/061828e3c2ece9a7327081c4f8e0283587175ff7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/061828e3c2ece9a7327081c4f8e0283587175ff7/comments", "author": null, "committer": null, "parents": [{"sha": "ff4e28eb7d01f36d8848a328d0ad7cf4b8c1d3c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff4e28eb7d01f36d8848a328d0ad7cf4b8c1d3c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff4e28eb7d01f36d8848a328d0ad7cf4b8c1d3c5"}], "stats": {"total": 391, "additions": 209, "deletions": 182}, "files": [{"sha": "93c1d9fa1d3694db898ab580956961c5abda40fc", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061828e3c2ece9a7327081c4f8e0283587175ff7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061828e3c2ece9a7327081c4f8e0283587175ff7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=061828e3c2ece9a7327081c4f8e0283587175ff7", "patch": "@@ -1,3 +1,33 @@\n+2014-01-20  Robert Dewar  <dewar@adacore.com>\n+\n+\t* s-tataat.adb: Minor reformatting.\n+\n+2014-01-20  Robert Dewar  <dewar@adacore.com>\n+\n+\t* einfo.adb (Is_Descendent_Of_Address): Now applies to all\n+\tentities, and also fix documentation to remove mention of visible\n+\tinteger type, since this is not what the implementation does.\n+\t* einfo.ads (Is_Descendent_Of_Address): Now applies to all\n+\tentities, and also fix documentation to remove mention of visible\n+\tinteger type, since this is not what the implementation does.\n+\t* gnat_rm.texi: Minor clarification of Allow_Integer_Address\n+\tfunction.\n+\t* sem_ch4.adb (Analyze_One_Call): Handle Allow_Integer_Address\n+\tcase for parameter type check.\n+\t* sem_res.adb (Resolve): Use new function\n+\tAddress_Integer_Convert_OK.\n+\t* sem_type.adb: Minor code reorganization (use Ekind_In) Minor\n+\treformatting throughout.\n+\t* sem_util.adb (Address_Integer_Convert_OK): New function.\n+\t* sem_util.ads: Minor reformatting (put specs in alpha order)\n+\t(Address_Integer_Convert_OK): New function.\n+\n+2014-01-20  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_ch7.adb (Wrap_Transient_Expression):\n+\tInsertion extra conditional expression only if\n+\tOpt.Suppress_Control_Flow_Optimizations is set.\n+\n 2014-01-20  Arnaud Charlet  <charlet@adacore.com>\n \n \t* s-tataat.adb (Initialize_Attributes): Abort might already be"}, {"sha": "399afa8e097825869f7fa5be32a8256506e17ce2", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061828e3c2ece9a7327081c4f8e0283587175ff7/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061828e3c2ece9a7327081c4f8e0283587175ff7/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=061828e3c2ece9a7327081c4f8e0283587175ff7", "patch": "@@ -1927,7 +1927,6 @@ package body Einfo is\n \n    function Is_Descendent_Of_Address (Id : E) return B is\n    begin\n-      pragma Assert (Is_Type (Id));\n       return Flag223 (Id);\n    end Is_Descendent_Of_Address;\n "}, {"sha": "9f4726cb0842c60c8fa6a55e1e74d6a762e03f0a", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061828e3c2ece9a7327081c4f8e0283587175ff7/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061828e3c2ece9a7327081c4f8e0283587175ff7/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=061828e3c2ece9a7327081c4f8e0283587175ff7", "patch": "@@ -2216,10 +2216,8 @@ package Einfo is\n --       types and subtypes.\n \n --    Is_Descendent_Of_Address (Flag223)\n---       Defined in all type and subtype entities. Indicates that a type is an\n---       address type that is visibly a numeric type. Used for semantic checks\n---       on VMS to remove ambiguities in universal integer expressions that may\n---       have an address interpretation\n+--       Defined in all entities. True if the entity is type System.Address,\n+--       or (recursively) a subtype or derived type of System.Address.\n \n --    Is_Discrete_Type (synthesized)\n --       Applies to all entities, true for all discrete types and subtypes\n@@ -4961,6 +4959,7 @@ package Einfo is\n    --    Is_Child_Unit                       (Flag73)\n    --    Is_Compilation_Unit                 (Flag149)\n    --    Is_Completely_Hidden                (Flag103)\n+   --    Is_Descendent_Of_Address            (Flag223)\n    --    Is_Discrim_SO_Function              (Flag176)\n    --    Is_Dispatch_Table_Entity            (Flag234)\n    --    Is_Dispatching_Operation            (Flag6)\n@@ -6451,6 +6450,7 @@ package Einfo is\n    function Is_Constructor                      (Id : E) return B;\n    function Is_Controlled                       (Id : E) return B;\n    function Is_Controlling_Formal               (Id : E) return B;\n+   function Is_Descendent_Of_Address            (Id : E) return B;\n    function Is_Discrim_SO_Function              (Id : E) return B;\n    function Is_Dispatch_Table_Entity            (Id : E) return B;\n    function Is_Dispatching_Operation            (Id : E) return B;\n@@ -6666,7 +6666,6 @@ package Einfo is\n    function Is_Concurrent_Type                  (Id : E) return B;\n    function Is_Decimal_Fixed_Point_Type         (Id : E) return B;\n    function Is_Digits_Type                      (Id : E) return B;\n-   function Is_Descendent_Of_Address            (Id : E) return B;\n    function Is_Discrete_Or_Fixed_Point_Type     (Id : E) return B;\n    function Is_Discrete_Type                    (Id : E) return B;\n    function Is_Elementary_Type                  (Id : E) return B;"}, {"sha": "42d499b2d1842b03e9a3585f0a3bafe75255fc31", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061828e3c2ece9a7327081c4f8e0283587175ff7/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061828e3c2ece9a7327081c4f8e0283587175ff7/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=061828e3c2ece9a7327081c4f8e0283587175ff7", "patch": "@@ -7982,16 +7982,13 @@ package body Exp_Ch7 is\n       --    end;\n \n       --  A special case is made for Boolean expressions so that the back-end\n-      --  knows to generate a conditional branch instruction if running with\n+      --  knows to generate a conditional branch instruction, if running with\n       --  -fpreserve-control-flow. This ensures that a control flow change\n       --  signalling the decision outcome occurs before the cleanup actions.\n-      --  In the absence of -fpreserve-control-flow, the back-end will\n-      --  optimize away the extra conditional expression, so we can do this\n-      --  modification unconditionally here.\n \n-      --  Why don't we add a test of Opt.Preserve_Control_Flow here???\n-\n-      if Is_Boolean_Type (Typ) then\n+      if Opt.Suppress_Control_Flow_Optimizations\n+           and then Is_Boolean_Type (Typ)\n+      then\n          Expr :=\n            Make_If_Expression (Loc,\n              Expressions => New_List ("}, {"sha": "53286d8b5c4cd9875375c2ab2555e69180b15e0f", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061828e3c2ece9a7327081c4f8e0283587175ff7/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061828e3c2ece9a7327081c4f8e0283587175ff7/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=061828e3c2ece9a7327081c4f8e0283587175ff7", "patch": "@@ -1263,6 +1263,12 @@ package AddrAsInt is\n end AddrAsInt;\n @end smallexample\n \n+@noindent\n+Note that these automatic conversions do not apply to expressions used\n+as subprogram arguments, because in general overloading can take place,\n+so that the required type is not fixed by the context. If necessary\n+adjust the type of the subprogram argument, e.g. by adding a conversion.\n+\n @node Pragma Annotate\n @unnumberedsec Pragma Annotate\n @findex Annotate"}, {"sha": "e812d1415cb50c883f4366357ff9a5086a0494c1", "filename": "gcc/ada/s-tataat.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061828e3c2ece9a7327081c4f8e0283587175ff7/gcc%2Fada%2Fs-tataat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061828e3c2ece9a7327081c4f8e0283587175ff7/gcc%2Fada%2Fs-tataat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tataat.adb?ref=061828e3c2ece9a7327081c4f8e0283587175ff7", "patch": "@@ -186,6 +186,9 @@ package body System.Tasking.Task_Attributes is\n       Self_Id : constant Task_Id := Self;\n \n    begin\n+      --  Note: we call [Un]Defer_Abort_Nestable, rather than [Un]Defer_Abort,\n+      --  because Abort might already be deferred in Create_Task.\n+\n       Defer_Abort_Nestable (Self_Id);\n       Lock_RTS;\n "}, {"sha": "daf8afe353b5b98857f61ed9367b6acd9b777856", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061828e3c2ece9a7327081c4f8e0283587175ff7/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061828e3c2ece9a7327081c4f8e0283587175ff7/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=061828e3c2ece9a7327081c4f8e0283587175ff7", "patch": "@@ -3189,6 +3189,23 @@ package body Sem_Ch4 is\n                   Next_Actual (Actual);\n                   Next_Formal (Formal);\n \n+               --  In Allow_Integer_Address mode, we allow an actual integer to\n+               --  match a formal address type and vice versa. We only do this\n+               --  if we are certain that an error will otherwise be issued\n+\n+               elsif Address_Integer_Convert_OK\n+                       (Etype (Actual), Etype (Formal))\n+                 and then (Report and not Is_Indexed and not Is_Indirect)\n+               then\n+                  --  Handle this case by introducing an unchecked conversion\n+\n+                  Rewrite (Actual,\n+                           Unchecked_Convert_To (Etype (Formal),\n+                             Relocate_Node (Actual)));\n+                  Analyze_And_Resolve (Actual, Etype (Formal));\n+                  Next_Actual (Actual);\n+                  Next_Formal (Formal);\n+\n                else\n                   if Debug_Flag_E then\n                      Write_Str (\" type checking fails in call \");\n@@ -3200,6 +3217,8 @@ package body Sem_Ch4 is\n                      Write_Eol;\n                   end if;\n \n+                  --  Comment needed on the following test???\n+\n                   if Report and not Is_Indexed and not Is_Indirect then\n \n                      --  Ada 2005 (AI-251): Complete the error notification"}, {"sha": "89fbb75490544b620664acfa0dd24191e5e30d9f", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061828e3c2ece9a7327081c4f8e0283587175ff7/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061828e3c2ece9a7327081c4f8e0283587175ff7/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=061828e3c2ece9a7327081c4f8e0283587175ff7", "patch": "@@ -2619,17 +2619,10 @@ package body Sem_Res is\n             --  treated as an Address. The reverse case of integer wanted,\n             --  Address found, is treated in an analogous manner.\n \n-            if Allow_Integer_Address then\n-               if (Is_RTE (Typ, RE_Address)\n-                    and then Is_Integer_Type (Etype (N)))\n-                 or else\n-                   (Is_Integer_Type (Typ)\n-                     and then Is_RTE (Etype (N), RE_Address))\n-               then\n-                  Rewrite (N, Unchecked_Convert_To (Typ, Relocate_Node (N)));\n-                  Analyze_And_Resolve (N, Typ);\n-                  return;\n-               end if;\n+            if Address_Integer_Convert_OK (Typ, Etype (N)) then\n+               Rewrite (N, Unchecked_Convert_To (Typ, Relocate_Node (N)));\n+               Analyze_And_Resolve (N, Typ);\n+               return;\n             end if;\n \n             --  That special Allow_Integer_Address check did not appply, so we\n@@ -11095,14 +11088,7 @@ package body Sem_Res is\n       --  Allow_Integer_Address is in effect. We convert the conversion to\n       --  an unchecked conversion in this case and we are all done!\n \n-      if Allow_Integer_Address\n-        and then\n-          ((Is_RTE (Target_Type, RE_Address)\n-             and then Is_Integer_Type (Opnd_Type))\n-          or else\n-           (Is_RTE (Opnd_Type, RE_Address)\n-             and then Is_Integer_Type (Target_Type)))\n-      then\n+      if Address_Integer_Convert_OK (Opnd_Type, Target_Type) then\n          Rewrite (N, Unchecked_Convert_To (Target_Type, Expression (N)));\n          Analyze_And_Resolve (N, Target_Type);\n          return True;"}, {"sha": "b7371b7d5003ad863104d0ee8d9c31df7b5361fb", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 94, "deletions": 131, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061828e3c2ece9a7327081c4f8e0283587175ff7/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061828e3c2ece9a7327081c4f8e0283587175ff7/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=061828e3c2ece9a7327081c4f8e0283587175ff7", "patch": "@@ -252,10 +252,9 @@ package body Sem_Type is\n             --  preference rule applies.\n \n             if (((Ekind (Name) = E_Function or else Ekind (Name) = E_Procedure)\n-                 and then Ekind (Name) = Ekind (It.Nam))\n-                or else (Ekind (Name) = E_Operator\n-              and then Ekind (It.Nam) = E_Function))\n-\n+                   and then Ekind (Name) = Ekind (It.Nam))\n+                 or else (Ekind (Name) = E_Operator\n+                           and then Ekind (It.Nam) = E_Function))\n               and then Is_Immediately_Visible (It.Nam)\n               and then Type_Conformant (Name, It.Nam)\n               and then Base_Type (It.Typ) = Base_Type (T)\n@@ -269,9 +268,9 @@ package body Sem_Type is\n                --  predefined operator in any case.\n \n                elsif Nkind (N) = N_Operator_Symbol\n-                 or else (Nkind (N) = N_Expanded_Name\n-                            and then\n-                          Nkind (Selector_Name (N)) = N_Operator_Symbol)\n+                 or else\n+                   (Nkind (N) = N_Expanded_Name\n+                     and then Nkind (Selector_Name (N)) = N_Operator_Symbol)\n                then\n                   exit;\n \n@@ -373,7 +372,7 @@ package body Sem_Type is\n            or else Is_Potentially_Use_Visible (Vis_Type)\n            or else In_Use (Vis_Type)\n            or else (In_Use (Scope (Vis_Type))\n-                      and then not Is_Hidden (Vis_Type))\n+                     and then not Is_Hidden (Vis_Type))\n            or else Nkind (N) = N_Expanded_Name\n            or else (Nkind (N) in N_Op and then E = Entity (N))\n            or else In_Instance\n@@ -390,8 +389,8 @@ package body Sem_Type is\n          elsif Nkind (N) = N_Function_Call\n            and then Nkind (Name (N)) = N_Expanded_Name\n            and then (Entity (Prefix (Name (N))) = Scope (Base_Type (T))\n-                       or else Entity (Prefix (Name (N))) = Scope (Vis_Type)\n-                       or else Scope (Vis_Type) = System_Aux_Id)\n+                      or else Entity (Prefix (Name (N))) = Scope (Vis_Type)\n+                      or else Scope (Vis_Type) = System_Aux_Id)\n          then\n             null;\n \n@@ -472,7 +471,7 @@ package body Sem_Type is\n       elsif Interp_Map.Last < 0\n         or else\n           (Interp_Map.Table (Interp_Map.Last).Node /= N\n-             and then not Is_Overloaded (N))\n+            and then not Is_Overloaded (N))\n       then\n          New_Interps (N);\n \n@@ -601,6 +600,7 @@ package body Sem_Type is\n             if Scop = Inst then\n                return True;\n             end if;\n+\n             Scop := Scope (Scop);\n          end loop;\n \n@@ -641,9 +641,8 @@ package body Sem_Type is\n             exit when (not Is_Overloadable (H))\n               and then Is_Immediately_Visible (H);\n \n-            if Is_Immediately_Visible (H)\n-              and then H /= Ent\n-            then\n+            if Is_Immediately_Visible (H) and then H /= Ent then\n+\n                --  Only add interpretation if not hidden by an inner\n                --  immediately visible one.\n \n@@ -766,9 +765,9 @@ package body Sem_Type is\n            Is_Private_Type (Typ1)\n              and then\n               ((Present (Full_View (Typ1))\n-                    and then Covers (Full_View (Typ1), Typ2))\n-                 or else Base_Type (Typ1) = Typ2\n-                 or else Base_Type (Typ2) = Typ1);\n+                  and then Covers (Full_View (Typ1), Typ2))\n+                or else Base_Type (Typ1) = Typ2\n+                or else Base_Type (Typ2) = Typ1);\n       end Full_View_Covers;\n \n       -----------------\n@@ -979,7 +978,7 @@ package body Sem_Type is\n       elsif Is_Class_Wide_Type (T2)\n         and then\n           (Class_Wide_Type (T1) = Class_Wide_Type (T2)\n-             or else Base_Type (Root_Type (T2)) = BT1)\n+            or else Base_Type (Root_Type (T2)) = BT1)\n       then\n          return True;\n \n@@ -998,9 +997,7 @@ package body Sem_Type is\n \n       --  An aggregate is compatible with an array or record type\n \n-      elsif T2 = Any_Composite\n-        and then Is_Aggregate_Type (T1)\n-      then\n+      elsif T2 = Any_Composite and then Is_Aggregate_Type (T1) then\n          return True;\n \n       --  If the expected type is an anonymous access, the designated type must\n@@ -1037,12 +1034,9 @@ package body Sem_Type is\n         and then (not Comes_From_Source (T1)\n                    or else not Comes_From_Source (T2))\n         and then (Is_Overloadable (Designated_Type (T2))\n-                    or else\n-                  Ekind (Designated_Type (T2)) = E_Subprogram_Type)\n-        and then\n-          Type_Conformant (Designated_Type (T1), Designated_Type (T2))\n-        and then\n-          Mode_Conformant (Designated_Type (T1), Designated_Type (T2))\n+                   or else Ekind (Designated_Type (T2)) = E_Subprogram_Type)\n+        and then Type_Conformant (Designated_Type (T1), Designated_Type (T2))\n+        and then Mode_Conformant (Designated_Type (T1), Designated_Type (T2))\n       then\n          return True;\n \n@@ -1058,12 +1052,9 @@ package body Sem_Type is\n         and then (not Comes_From_Source (T1)\n                    or else not Comes_From_Source (T2))\n         and then (Is_Overloadable (Designated_Type (T2))\n-                    or else\n-                  Ekind (Designated_Type (T2)) = E_Subprogram_Type)\n-        and then\n-           Type_Conformant (Designated_Type (T1), Designated_Type (T2))\n-        and then\n-           Mode_Conformant (Designated_Type (T1), Designated_Type (T2))\n+                   or else Ekind (Designated_Type (T2)) = E_Subprogram_Type)\n+        and then Type_Conformant (Designated_Type (T1), Designated_Type (T2))\n+        and then Mode_Conformant (Designated_Type (T1), Designated_Type (T2))\n       then\n          return True;\n \n@@ -1072,17 +1063,15 @@ package body Sem_Type is\n       --  vice versa.\n \n       elsif Is_Record_Type (T1)\n-        and then (Is_Remote_Call_Interface (T1)\n-                   or else Is_Remote_Types (T1))\n+        and then (Is_Remote_Call_Interface (T1) or else Is_Remote_Types (T1))\n         and then Present (Corresponding_Remote_Type (T1))\n       then\n          return Covers (Corresponding_Remote_Type (T1), T2);\n \n       --  and conversely.\n \n       elsif Is_Record_Type (T2)\n-        and then (Is_Remote_Call_Interface (T2)\n-                   or else Is_Remote_Types (T2))\n+        and then (Is_Remote_Call_Interface (T2) or else Is_Remote_Types (T2))\n         and then Present (Corresponding_Remote_Type (T2))\n       then\n          return Covers (Corresponding_Remote_Type (T2), T1);\n@@ -1122,20 +1111,16 @@ package body Sem_Type is\n \n       --  Ditto for allocators, which eventually resolve to the context type\n \n-      elsif Ekind (T2) = E_Allocator_Type\n-        and then Is_Access_Type (T1)\n-      then\n+      elsif Ekind (T2) = E_Allocator_Type and then Is_Access_Type (T1) then\n          return Covers (Designated_Type (T1), Designated_Type (T2))\n-          or else\n-            (From_Limited_With (Designated_Type (T1))\n-              and then Covers (Designated_Type (T2), Designated_Type (T1)));\n+           or else\n+             (From_Limited_With (Designated_Type (T1))\n+               and then Covers (Designated_Type (T2), Designated_Type (T1)));\n \n       --  A boolean operation on integer literals is compatible with modular\n       --  context.\n \n-      elsif T2 = Any_Modular\n-        and then Is_Modular_Integer_Type (T1)\n-      then\n+      elsif T2 = Any_Modular and then Is_Modular_Integer_Type (T1) then\n          return True;\n \n       --  The actual type may be the result of a previous error\n@@ -1167,9 +1152,7 @@ package body Sem_Type is\n       --  legal, to prevent cascaded errors.\n \n       elsif In_Instance\n-        and then\n-          (Full_View_Covers (T1, T2)\n-            or else Full_View_Covers (T2, T1))\n+        and then (Full_View_Covers (T1, T2) or else Full_View_Covers (T2, T1))\n       then\n          return True;\n \n@@ -1190,15 +1173,16 @@ package body Sem_Type is\n \n       elsif In_Inlined_Body\n         and then (Underlying_Type (T1) = Underlying_Type (T2)\n-                   or else (Is_Access_Type (T1)\n-                              and then Is_Access_Type (T2)\n-                              and then\n-                                Designated_Type (T1) = Designated_Type (T2))\n-                   or else (T1 = Any_Access\n-                              and then Is_Access_Type (Underlying_Type (T2)))\n-                   or else (T2 = Any_Composite\n-                              and then\n-                                Is_Composite_Type (Underlying_Type (T1))))\n+                   or else\n+                     (Is_Access_Type (T1)\n+                       and then Is_Access_Type (T2)\n+                       and then Designated_Type (T1) = Designated_Type (T2))\n+                   or else\n+                     (T1 = Any_Access\n+                       and then Is_Access_Type (Underlying_Type (T2)))\n+                   or else\n+                     (T2 = Any_Composite\n+                       and then Is_Composite_Type (Underlying_Type (T1))))\n       then\n          return True;\n \n@@ -1364,8 +1348,8 @@ package body Sem_Type is\n          else\n             return Is_Entity_Name (Subtype_Indication (Type_Definition (Par)))\n               and then\n-               Is_Generic_Actual_Type (\n-                 Entity (Subtype_Indication (Type_Definition (Par))));\n+                Is_Generic_Actual_Type (\n+                  Entity (Subtype_Indication (Type_Definition (Par))));\n          end if;\n       end Inherited_From_Actual;\n \n@@ -1383,10 +1367,10 @@ package body Sem_Type is\n          return In_Same_List (Parent (Typ), Op_Decl)\n            or else\n              (Ekind_In (Scop, E_Package, E_Generic_Package)\n-                and then List_Containing (Op_Decl) =\n-                  Visible_Declarations (Parent (Scop))\n-                and then List_Containing (Parent (Typ)) =\n-                  Private_Declarations (Parent (Scop)));\n+               and then List_Containing (Op_Decl) =\n+                              Visible_Declarations (Parent (Scop))\n+               and then List_Containing (Parent (Typ)) =\n+                              Private_Declarations (Parent (Scop)));\n       end In_Same_Declaration_List;\n \n       --------------------------\n@@ -1765,8 +1749,7 @@ package body Sem_Type is\n             begin\n                Get_First_Interp (N, I, It);\n                while Present (It.Typ) loop\n-                  if (Covers (Typ, It.Typ)\n-                        or else Typ = Any_Type)\n+                  if (Covers (Typ, It.Typ) or else Typ = Any_Type)\n                     and then\n                      (It.Typ = Universal_Integer\n                        or else It.Typ = Universal_Real)\n@@ -1917,9 +1900,7 @@ package body Sem_Type is\n          --  handled here as well. We test Comes_From_Source to exclude this\n          --  treatment for implicit renamings created for formal subprograms.\n \n-         elsif In_Instance\n-           and then not In_Generic_Actual (N)\n-         then\n+         elsif In_Instance and then not In_Generic_Actual (N) then\n             if Nkind (N) in N_Subprogram_Call\n               or else\n                 (Nkind (N) in N_Has_Entity\n@@ -2053,7 +2034,7 @@ package body Sem_Type is\n \n       else\n          if (In_Open_Scopes (Scope (User_Subp))\n-           or else Is_Potentially_Use_Visible (User_Subp))\n+              or else Is_Potentially_Use_Visible (User_Subp))\n            and then not In_Instance\n          then\n             if Is_Fixed_Point_Type (Typ)\n@@ -2149,14 +2130,10 @@ package body Sem_Type is\n       then\n          return Type_Conformant (New_S, Old_S);\n \n-      elsif Ekind (New_S) = E_Function\n-        and then Ekind (Old_S) = E_Operator\n-      then\n+      elsif Ekind (New_S) = E_Function and then Ekind (Old_S) = E_Operator then\n          return Operator_Matches_Spec (Old_S, New_S);\n \n-      elsif Ekind (New_S) = E_Procedure\n-        and then Is_Entry (Old_S)\n-      then\n+      elsif Ekind (New_S) = E_Procedure and then Is_Entry (Old_S) then\n          return Type_Conformant (New_S, Old_S);\n \n       else\n@@ -2184,7 +2161,6 @@ package body Sem_Type is\n                --  apply preference rule.\n \n                if TR /= Any_Type then\n-\n                   if (T = Universal_Integer or else T = Universal_Real)\n                     and then It.Typ = T\n                   then\n@@ -2230,19 +2206,16 @@ package body Sem_Type is\n       --  is no rule in 4.6 that allows \"access Integer\" to be converted to P.\n \n       elsif Ada_Version >= Ada_2005\n-        and then\n-          (Ekind (Etype (L)) = E_Anonymous_Access_Type\n-             or else\n-           Ekind (Etype (L)) = E_Anonymous_Access_Subprogram_Type)\n+        and then Ekind_In (Etype (L), E_Anonymous_Access_Type,\n+                                      E_Anonymous_Access_Subprogram_Type)\n         and then Is_Access_Type (Etype (R))\n         and then Ekind (Etype (R)) /= E_Access_Type\n       then\n          return Etype (L);\n \n       elsif Ada_Version >= Ada_2005\n-        and then\n-          (Ekind (Etype (R)) = E_Anonymous_Access_Type\n-            or else Ekind (Etype (R)) = E_Anonymous_Access_Subprogram_Type)\n+        and then Ekind_In (Etype (R), E_Anonymous_Access_Type,\n+                                      E_Anonymous_Access_Subprogram_Type)\n         and then Is_Access_Type (Etype (L))\n         and then Ekind (Etype (L)) /= E_Access_Type\n       then\n@@ -2273,9 +2246,7 @@ package body Sem_Type is\n       if Is_Overloaded (N) and then Is_Overloadable (E) then\n          Act_Parm  := First_Actual (N);\n          Form_Parm := First_Formal (E);\n-         while Present (Act_Parm)\n-           and then Present (Form_Parm)\n-         loop\n+         while Present (Act_Parm) and then Present (Form_Parm) loop\n             Act := Act_Parm;\n \n             if Nkind (Act) = N_Parameter_Association then\n@@ -2379,20 +2350,22 @@ package body Sem_Type is\n \n            or else\n              (Is_Record_Type (Typ)\n-                and then Is_Concurrent_Type (Etype (N))\n-                and then Present (Corresponding_Record_Type (Etype (N)))\n-                and then Covers (Typ, Corresponding_Record_Type (Etype (N))))\n+               and then Is_Concurrent_Type (Etype (N))\n+               and then Present (Corresponding_Record_Type (Etype (N)))\n+               and then Covers (Typ, Corresponding_Record_Type (Etype (N))))\n \n            or else\n              (Is_Concurrent_Type (Typ)\n-                and then Is_Record_Type (Etype (N))\n-                and then Present (Corresponding_Record_Type (Typ))\n-                and then Covers (Corresponding_Record_Type (Typ), Etype (N)))\n+               and then Is_Record_Type (Etype (N))\n+               and then Present (Corresponding_Record_Type (Typ))\n+               and then Covers (Corresponding_Record_Type (Typ), Etype (N)))\n \n            or else\n              (not Is_Tagged_Type (Typ)\n-                and then Ekind (Typ) /= E_Anonymous_Access_Type\n-                and then Covers (Etype (N), Typ));\n+               and then Ekind (Typ) /= E_Anonymous_Access_Type\n+               and then Covers (Etype (N), Typ));\n+\n+      --  Overloaded case\n \n       else\n          Get_First_Interp (N, I, It);\n@@ -2474,10 +2447,10 @@ package body Sem_Type is\n    begin\n       return Operator_Matches_Spec (Op, F)\n         and then (In_Open_Scopes (Scope (F))\n-                    or else Scope (F) = Scope (Btyp)\n-                    or else (not In_Open_Scopes (Scope (Btyp))\n-                              and then not In_Use (Btyp)\n-                              and then not In_Use (Scope (Btyp))));\n+                   or else Scope (F) = Scope (Btyp)\n+                   or else (not In_Open_Scopes (Scope (Btyp))\n+                             and then not In_Use (Btyp)\n+                             and then not In_Use (Scope (Btyp))));\n    end Hides_Op;\n \n    ------------------------\n@@ -2621,7 +2594,7 @@ package body Sem_Type is\n                      return True;\n \n                   elsif Present (Interfaces (Etype (AI)))\n-                     and then Iface_Present_In_Ancestor (Etype (AI))\n+                    and then Iface_Present_In_Ancestor (Etype (AI))\n                   then\n                      return True;\n                   end if;\n@@ -2727,11 +2700,10 @@ package body Sem_Type is\n          --  Ada 2005 (AI-251): Complete the error notification\n \n          elsif Is_Class_Wide_Type (Etype (R))\n-             and then Is_Interface (Etype (Class_Wide_Type (Etype (R))))\n+           and then Is_Interface (Etype (Class_Wide_Type (Etype (R))))\n          then\n             Error_Msg_NE (\"(Ada 2005) does not implement interface }\",\n                           L, Etype (Class_Wide_Type (Etype (R))));\n-\n          else\n             Error_Msg_N (\"incompatible types\", Parent (L));\n          end if;\n@@ -2843,8 +2815,8 @@ package body Sem_Type is\n \n             elsif BT1 = Base_Type (Par)\n               or else (Is_Private_Type (T1)\n-                         and then Present (Full_View (T1))\n-                         and then Base_Type (Par) = Base_Type (Full_View (T1)))\n+                        and then Present (Full_View (T1))\n+                        and then Base_Type (Par) = Base_Type (Full_View (T1)))\n             then\n                return True;\n \n@@ -3162,10 +3134,10 @@ package body Sem_Type is\n             return Is_Array_Type (T)\n               and then (Base_Type (T) = Base_Type (Etype (Op)))\n               and then (Base_Type (T1) = Base_Type (T)\n-                         or else\n+                          or else\n                         Base_Type (T1) = Base_Type (Component_Type (T)))\n               and then (Base_Type (T2) = Base_Type (T)\n-                         or else\n+                          or else\n                         Base_Type (T2) = Base_Type (Component_Type (T)));\n \n          else\n@@ -3314,14 +3286,10 @@ package body Sem_Type is\n       then\n          return T1;\n \n-      elsif T2 = Any_Composite\n-        and then Is_Aggregate_Type (T1)\n-      then\n+      elsif T2 = Any_Composite and then Is_Aggregate_Type (T1) then\n          return T1;\n \n-      elsif T1 = Any_Composite\n-        and then Is_Aggregate_Type (T2)\n-      then\n+      elsif T1 = Any_Composite and then Is_Aggregate_Type (T2) then\n          return T2;\n \n       elsif T1 = Any_Modular and then Is_Modular_Integer_Type (T2) then\n@@ -3349,7 +3317,7 @@ package body Sem_Type is\n \n       elsif Is_Class_Wide_Type (T2)\n         and then Is_Interface (Etype (T2))\n-        and then Interface_Present_In_Ancestor (Typ => T1,\n+        and then Interface_Present_In_Ancestor (Typ   => T1,\n                                                 Iface => Etype (T2))\n       then\n          return T1;\n@@ -3364,32 +3332,30 @@ package body Sem_Type is\n       then\n          return T2;\n \n-      elsif (Ekind (B1) = E_Access_Subprogram_Type\n-               or else\n-             Ekind (B1) = E_Access_Protected_Subprogram_Type)\n+      elsif Ekind_In (B1, E_Access_Subprogram_Type,\n+                          E_Access_Protected_Subprogram_Type)\n         and then Ekind (Designated_Type (B1)) /= E_Subprogram_Type\n         and then Is_Access_Type (T2)\n       then\n          return T2;\n \n-      elsif (Ekind (B2) = E_Access_Subprogram_Type\n-               or else\n-             Ekind (B2) = E_Access_Protected_Subprogram_Type)\n+      elsif Ekind_In (B2, E_Access_Subprogram_Type,\n+                          E_Access_Protected_Subprogram_Type)\n         and then Ekind (Designated_Type (B2)) /= E_Subprogram_Type\n         and then Is_Access_Type (T1)\n       then\n          return T1;\n \n-      elsif (Ekind (T1) = E_Allocator_Type\n-              or else Ekind (T1) = E_Access_Attribute_Type\n-              or else Ekind (T1) = E_Anonymous_Access_Type)\n+      elsif Ekind_In (T1, E_Allocator_Type,\n+                          E_Access_Attribute_Type,\n+                          E_Anonymous_Access_Type)\n         and then Is_Access_Type (T2)\n       then\n          return T2;\n \n-      elsif (Ekind (T2) = E_Allocator_Type\n-              or else Ekind (T2) = E_Access_Attribute_Type\n-              or else Ekind (T2) = E_Anonymous_Access_Type)\n+      elsif Ekind_In (T2, E_Allocator_Type,\n+                          E_Access_Attribute_Type,\n+                          E_Anonymous_Access_Type)\n         and then Is_Access_Type (T1)\n       then\n          return T1;\n@@ -3435,8 +3401,7 @@ package body Sem_Type is\n         and then Number_Dimensions (T) = 1\n         and then Is_Boolean_Type (Component_Type (T))\n         and then\n-         ((not Is_Private_Composite (T)\n-            and then not Is_Limited_Composite (T))\n+         ((not Is_Private_Composite (T) and then not Is_Limited_Composite (T))\n            or else In_Instance\n            or else Available_Full_View_Of_Component (T))\n       then\n@@ -3465,10 +3430,8 @@ package body Sem_Type is\n       elsif Is_Array_Type (T)\n           and then Number_Dimensions (T) = 1\n           and then Is_Discrete_Type (Component_Type (T))\n-          and then (not Is_Private_Composite (T)\n-                     or else In_Instance)\n-          and then (not Is_Limited_Composite (T)\n-                     or else In_Instance)\n+          and then (not Is_Private_Composite (T) or else In_Instance)\n+          and then (not Is_Limited_Composite (T) or else In_Instance)\n       then\n          return True;\n "}, {"sha": "7664e60659d29c416951efce4aa2eb804bcdce0f", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061828e3c2ece9a7327081c4f8e0283587175ff7/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061828e3c2ece9a7327081c4f8e0283587175ff7/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=061828e3c2ece9a7327081c4f8e0283587175ff7", "patch": "@@ -361,6 +361,27 @@ package body Sem_Util is\n       Analyze (N);\n    end Add_Global_Declaration;\n \n+   --------------------------------\n+   -- Address_Integer_Convert_OK --\n+   --------------------------------\n+\n+   function Address_Integer_Convert_OK (T1, T2 : Entity_Id) return Boolean is\n+   begin\n+      if Allow_Integer_Address\n+        and then ((Is_Descendent_Of_Address  (T1)\n+                    and then Is_Private_Type (T1)\n+                    and then Is_Integer_Type (T2))\n+                            or else\n+                  (Is_Descendent_Of_Address  (T2)\n+                    and then Is_Private_Type (T2)\n+                    and then Is_Integer_Type (T1)))\n+      then\n+         return True;\n+      else\n+         return False;\n+      end if;\n+   end Address_Integer_Convert_OK;\n+\n    -----------------\n    -- Addressable --\n    -----------------"}, {"sha": "4c6dde99f96267e7f0892458f70457df17a64338", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/061828e3c2ece9a7327081c4f8e0283587175ff7/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/061828e3c2ece9a7327081c4f8e0283587175ff7/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=061828e3c2ece9a7327081c4f8e0283587175ff7", "patch": "@@ -67,6 +67,11 @@ package Sem_Util is\n    --  for the current unit. The declarations are added in the current scope,\n    --  so the caller should push a new scope as required before the call.\n \n+   function Address_Integer_Convert_OK (T1, T2 : Entity_Id) return Boolean;\n+   --  Given two types, returns True if we are in Allow_Integer_Address mode\n+   --  and one of the types is (a descendent of) System.Address (and this type\n+   --  is private), and the other type is any integer type.\n+\n    function Addressable (V : Uint) return Boolean;\n    function Addressable (V : Int)  return Boolean;\n    pragma Inline (Addressable);\n@@ -398,12 +403,12 @@ package Sem_Util is\n       --    * Array-of-scalars with specified Default_Component_Value\n       --    * Array type with fully default initialized component type\n       --    * Record or protected type with components that either have a\n-      --        default expression or their related types are fully default\n-      --        initialized.\n+      --      default expression or their related types are fully default\n+      --      initialized.\n       --    * Scalar type with specified Default_Value\n       --    * Task type\n       --    * Type extension of a type with full default initialization where\n-      --        the extension components are also fully default initialized\n+      --      the extension components are also fully default initialized.\n \n       Mixed_Initialization,\n       --  This value applies to a type where some of its internals are fully\n@@ -415,8 +420,7 @@ package Sem_Util is\n \n    function Default_Initialization\n      (Typ : Entity_Id) return Default_Initialization_Kind;\n-   --  Determine the default initialization kind that applies to a particular\n-   --  type.\n+   --  Determine default initialization kind that applies to a particular type\n \n    function Deepest_Type_Access_Level (Typ : Entity_Id) return Uint;\n    --  Same as Type_Access_Level, except that if the type is the type of an Ada\n@@ -973,6 +977,20 @@ package Sem_Util is\n    function Is_CPP_Constructor_Call (N : Node_Id) return Boolean;\n    --  Returns True if N is a call to a CPP constructor\n \n+   function Is_Child_Or_Sibling\n+     (Pack_1        : Entity_Id;\n+      Pack_2        : Entity_Id;\n+      Private_Child : Boolean) return Boolean;\n+   --  Determine the following relations between two arbitrary packages:\n+   --    1) One package is the parent of a child package\n+   --    2) Both packages are siblings and share a common parent\n+   --  If flag Private_Child is set, then the child in case 1) or both siblings\n+   --  in case 2) must be private.\n+\n+   function Is_Concurrent_Interface (T : Entity_Id) return Boolean;\n+   --  First determine whether type T is an interface and then check whether\n+   --  it is of protected, synchronized or task kind.\n+\n    function Is_Dependent_Component_Of_Mutable_Object\n      (Object : Node_Id) return Boolean;\n    --  Returns True if Object is the name of a subcomponent that depends on\n@@ -991,20 +1009,6 @@ package Sem_Util is\n    --  This is the RM definition, a type is a descendent of another type if it\n    --  is the same type or is derived from a descendent of the other type.\n \n-   function Is_Child_Or_Sibling\n-     (Pack_1        : Entity_Id;\n-      Pack_2        : Entity_Id;\n-      Private_Child : Boolean) return Boolean;\n-   --  Determine the following relations between two arbitrary packages:\n-   --    1) One package is the parent of a child package\n-   --    2) Both packages are siblings and share a common parent\n-   --  If flag Private_Child is set, then the child in case 1) or both siblings\n-   --  in case 2) must be private.\n-\n-   function Is_Concurrent_Interface (T : Entity_Id) return Boolean;\n-   --  First determine whether type T is an interface and then check whether\n-   --  it is of protected, synchronized or task kind.\n-\n    function Is_Expression_Function (Subp : Entity_Id) return Boolean;\n    --  Predicate to determine whether a scope entity comes from a rewritten\n    --  expression function call, and should be inlined unconditionally. Also"}]}