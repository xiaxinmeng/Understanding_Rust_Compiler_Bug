{"sha": "110e1ccc08a859c62b672e3a8b697caff350de38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTEwZTFjY2MwOGE4NTljNjJiNjcyZTNhOGI2OTdjYWZmMzUwZGUzOA==", "commit": {"author": {"name": "James Greenhalgh", "email": "james.greenhalgh@arm.com", "date": "2014-04-22T10:49:48Z"}, "committer": {"name": "James Greenhalgh", "email": "jgreenhalgh@gcc.gnu.org", "date": "2014-04-22T10:49:48Z"}, "message": "Re: [AArch64] Fix possible wrong code generation when comparing DImode values.\n\ngcc/\n\n\t* config/aarch64/aarch64-simd.md\n\t(aarch64_cm<optab>di): Always split.\n\t(*aarch64_cm<optab>di): New.\n\t(aarch64_cmtstdi): Always split.\n\t(*aarch64_cmtstdi): New.\n\nFrom-SVN: r209617", "tree": {"sha": "9b76b58e41be54e3bdf58a208239490cfec45044", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b76b58e41be54e3bdf58a208239490cfec45044"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/110e1ccc08a859c62b672e3a8b697caff350de38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/110e1ccc08a859c62b672e3a8b697caff350de38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/110e1ccc08a859c62b672e3a8b697caff350de38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/110e1ccc08a859c62b672e3a8b697caff350de38/comments", "author": {"login": "jgreenhalgh-arm", "id": 6104025, "node_id": "MDQ6VXNlcjYxMDQwMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6104025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jgreenhalgh-arm", "html_url": "https://github.com/jgreenhalgh-arm", "followers_url": "https://api.github.com/users/jgreenhalgh-arm/followers", "following_url": "https://api.github.com/users/jgreenhalgh-arm/following{/other_user}", "gists_url": "https://api.github.com/users/jgreenhalgh-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jgreenhalgh-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jgreenhalgh-arm/subscriptions", "organizations_url": "https://api.github.com/users/jgreenhalgh-arm/orgs", "repos_url": "https://api.github.com/users/jgreenhalgh-arm/repos", "events_url": "https://api.github.com/users/jgreenhalgh-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/jgreenhalgh-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2044a4c3cc2db3697e62eea701c489378ad54947", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2044a4c3cc2db3697e62eea701c489378ad54947", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2044a4c3cc2db3697e62eea701c489378ad54947"}], "stats": {"total": 158, "additions": 113, "deletions": 45}, "files": [{"sha": "b1850b9c4f90e0ca3e6efa356bc31472e3bcb69b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110e1ccc08a859c62b672e3a8b697caff350de38/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110e1ccc08a859c62b672e3a8b697caff350de38/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=110e1ccc08a859c62b672e3a8b697caff350de38", "patch": "@@ -1,3 +1,11 @@\n+2014-04-22  James Greenhalgh  <james.greenhalgh@arm.com>\n+\n+\t* config/aarch64/aarch64-simd.md\n+\t(aarch64_cm<optab>di): Always split.\n+\t(*aarch64_cm<optab>di): New.\n+\t(aarch64_cmtstdi): Always split.\n+\t(*aarch64_cmtstdi): New.\n+\n 2014-04-22  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/60823"}, {"sha": "995b4a81acd0838347965e629147d322f7351fa7", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 105, "deletions": 45, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110e1ccc08a859c62b672e3a8b697caff350de38/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110e1ccc08a859c62b672e3a8b697caff350de38/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=110e1ccc08a859c62b672e3a8b697caff350de38", "patch": "@@ -3415,26 +3415,46 @@\n \t  )))\n      (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_SIMD\"\n-  \"@\n-  cm<n_optab>\\t%d0, %d<cmp_1>, %d<cmp_2>\n-  cm<optab>\\t%d0, %d1, #0\n-  #\"\n-  \"reload_completed\n-   /* We need to prevent the split from\n-      happening in the 'w' constraint cases.  */\n-   && GP_REGNUM_P (REGNO (operands[0]))\n-   && GP_REGNUM_P (REGNO (operands[1]))\"\n-  [(const_int 0)]\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_operand:DI 0 \"register_operand\")\n+\t(neg:DI\n+\t  (COMPARISONS:DI\n+\t    (match_operand:DI 1 \"register_operand\")\n+\t    (match_operand:DI 2 \"aarch64_simd_reg_or_zero\")\n+\t  )))]\n   {\n-    enum machine_mode mode = SELECT_CC_MODE (<CMP>, operands[1], operands[2]);\n-    rtx cc_reg = aarch64_gen_compare_reg (<CMP>, operands[1], operands[2]);\n-    rtx comparison = gen_rtx_<CMP> (mode, operands[1], operands[2]);\n-    emit_insn (gen_cstoredi_neg (operands[0], comparison, cc_reg));\n-    DONE;\n+    /* If we are in the general purpose register file,\n+       we split to a sequence of comparison and store.  */\n+    if (GP_REGNUM_P (REGNO (operands[0]))\n+\t&& GP_REGNUM_P (REGNO (operands[1])))\n+      {\n+\tenum machine_mode mode = SELECT_CC_MODE (<CMP>, operands[1], operands[2]);\n+\trtx cc_reg = aarch64_gen_compare_reg (<CMP>, operands[1], operands[2]);\n+\trtx comparison = gen_rtx_<CMP> (mode, operands[1], operands[2]);\n+\temit_insn (gen_cstoredi_neg (operands[0], comparison, cc_reg));\n+\tDONE;\n+      }\n+    /* Otherwise, we expand to a similar pattern which does not\n+       clobber CC_REGNUM.  */\n   }\n   [(set_attr \"type\" \"neon_compare, neon_compare_zero, multiple\")]\n )\n \n+(define_insn \"*aarch64_cm<optab>di\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=w,w\")\n+\t(neg:DI\n+\t  (COMPARISONS:DI\n+\t    (match_operand:DI 1 \"register_operand\" \"w,w\")\n+\t    (match_operand:DI 2 \"aarch64_simd_reg_or_zero\" \"w,ZDz\")\n+\t  )))]\n+  \"TARGET_SIMD && reload_completed\"\n+  \"@\n+  cm<n_optab>\\t%d0, %d<cmp_1>, %d<cmp_2>\n+  cm<optab>\\t%d0, %d1, #0\"\n+  [(set_attr \"type\" \"neon_compare, neon_compare_zero\")]\n+)\n+\n ;; cm(hs|hi)\n \n (define_insn \"aarch64_cm<optab><mode>\"\n@@ -3458,23 +3478,42 @@\n \t  )))\n     (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_SIMD\"\n-  \"@\n-  cm<n_optab>\\t%d0, %d<cmp_1>, %d<cmp_2>\n-  #\"\n-  \"reload_completed\n-   /* We need to prevent the split from\n-      happening in the 'w' constraint cases.  */\n-   && GP_REGNUM_P (REGNO (operands[0]))\n-   && GP_REGNUM_P (REGNO (operands[1]))\"\n-  [(const_int 0)]\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_operand:DI 0 \"register_operand\")\n+\t(neg:DI\n+\t  (UCOMPARISONS:DI\n+\t    (match_operand:DI 1 \"register_operand\")\n+\t    (match_operand:DI 2 \"aarch64_simd_reg_or_zero\")\n+\t  )))]\n   {\n-    enum machine_mode mode = CCmode;\n-    rtx cc_reg = aarch64_gen_compare_reg (<CMP>, operands[1], operands[2]);\n-    rtx comparison = gen_rtx_<CMP> (mode, operands[1], operands[2]);\n-    emit_insn (gen_cstoredi_neg (operands[0], comparison, cc_reg));\n-    DONE;\n+    /* If we are in the general purpose register file,\n+       we split to a sequence of comparison and store.  */\n+    if (GP_REGNUM_P (REGNO (operands[0]))\n+\t&& GP_REGNUM_P (REGNO (operands[1])))\n+      {\n+\tenum machine_mode mode = CCmode;\n+\trtx cc_reg = aarch64_gen_compare_reg (<CMP>, operands[1], operands[2]);\n+\trtx comparison = gen_rtx_<CMP> (mode, operands[1], operands[2]);\n+\temit_insn (gen_cstoredi_neg (operands[0], comparison, cc_reg));\n+\tDONE;\n+      }\n+    /* Otherwise, we expand to a similar pattern which does not\n+       clobber CC_REGNUM.  */\n   }\n-  [(set_attr \"type\" \"neon_compare, neon_compare_zero\")]\n+  [(set_attr \"type\" \"neon_compare,multiple\")]\n+)\n+\n+(define_insn \"*aarch64_cm<optab>di\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=w\")\n+\t(neg:DI\n+\t  (UCOMPARISONS:DI\n+\t    (match_operand:DI 1 \"register_operand\" \"w\")\n+\t    (match_operand:DI 2 \"aarch64_simd_reg_or_zero\" \"w\")\n+\t  )))]\n+  \"TARGET_SIMD && reload_completed\"\n+  \"cm<n_optab>\\t%d0, %d<cmp_1>, %d<cmp_2>\"\n+  [(set_attr \"type\" \"neon_compare\")]\n )\n \n ;; cmtst\n@@ -3502,23 +3541,44 @@\n \t    (const_int 0))))\n     (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_SIMD\"\n-  \"@\n-  cmtst\\t%d0, %d1, %d2\n-  #\"\n-  \"reload_completed\n-   /* We need to prevent the split from\n-      happening in the 'w' constraint cases.  */\n-   && GP_REGNUM_P (REGNO (operands[0]))\n-   && GP_REGNUM_P (REGNO (operands[1]))\"\n-  [(const_int 0)]\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_operand:DI 0 \"register_operand\")\n+\t(neg:DI\n+\t  (ne:DI\n+\t    (and:DI\n+\t      (match_operand:DI 1 \"register_operand\")\n+\t      (match_operand:DI 2 \"register_operand\"))\n+\t    (const_int 0))))]\n   {\n-    rtx and_tree = gen_rtx_AND (DImode, operands[1], operands[2]);\n-    enum machine_mode mode = SELECT_CC_MODE (NE, and_tree, const0_rtx);\n-    rtx cc_reg = aarch64_gen_compare_reg (NE, and_tree, const0_rtx);\n-    rtx comparison = gen_rtx_NE (mode, and_tree, const0_rtx);\n-    emit_insn (gen_cstoredi_neg (operands[0], comparison, cc_reg));\n-    DONE;\n+    /* If we are in the general purpose register file,\n+       we split to a sequence of comparison and store.  */\n+    if (GP_REGNUM_P (REGNO (operands[0]))\n+\t&& GP_REGNUM_P (REGNO (operands[1])))\n+      {\n+\trtx and_tree = gen_rtx_AND (DImode, operands[1], operands[2]);\n+\tenum machine_mode mode = SELECT_CC_MODE (NE, and_tree, const0_rtx);\n+\trtx cc_reg = aarch64_gen_compare_reg (NE, and_tree, const0_rtx);\n+\trtx comparison = gen_rtx_NE (mode, and_tree, const0_rtx);\n+\temit_insn (gen_cstoredi_neg (operands[0], comparison, cc_reg));\n+\tDONE;\n+      }\n+    /* Otherwise, we expand to a similar pattern which does not\n+       clobber CC_REGNUM.  */\n   }\n+  [(set_attr \"type\" \"neon_tst,multiple\")]\n+)\n+\n+(define_insn \"*aarch64_cmtstdi\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=w\")\n+\t(neg:DI\n+\t  (ne:DI\n+\t    (and:DI\n+\t      (match_operand:DI 1 \"register_operand\" \"w\")\n+\t      (match_operand:DI 2 \"register_operand\" \"w\"))\n+\t    (const_int 0))))]\n+  \"TARGET_SIMD\"\n+  \"cmtst\\t%d0, %d1, %d2\"\n   [(set_attr \"type\" \"neon_tst\")]\n )\n "}]}