{"sha": "04a704a4aafd2da62601578e9bdd7928aec45fd0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDRhNzA0YTRhYWZkMmRhNjI2MDE1NzhlOWJkZDc5MjhhZWM0NWZkMA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-06-20T15:10:49Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-06-20T15:10:49Z"}, "message": "For PR libgcj/7073:\n\n\t* resolve.cc (_Jv_PrepareClass): Only resolve superclass if it\n\texists.\n\t* defineclass.cc (handleClassBegin): Superclass for interface is\n\t`null'.\n\nFrom-SVN: r54835", "tree": {"sha": "5fe7164c297cc6a841a25c673434a465963b9818", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5fe7164c297cc6a841a25c673434a465963b9818"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04a704a4aafd2da62601578e9bdd7928aec45fd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04a704a4aafd2da62601578e9bdd7928aec45fd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04a704a4aafd2da62601578e9bdd7928aec45fd0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04a704a4aafd2da62601578e9bdd7928aec45fd0/comments", "author": null, "committer": null, "parents": [{"sha": "aa16c0facca1a54d453555e97546b941f197c661", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa16c0facca1a54d453555e97546b941f197c661", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa16c0facca1a54d453555e97546b941f197c661"}], "stats": {"total": 68, "additions": 40, "deletions": 28}, "files": [{"sha": "7db99ce160f0a78f32ae3d69c832d21e59dd62a6", "filename": "libjava/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04a704a4aafd2da62601578e9bdd7928aec45fd0/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04a704a4aafd2da62601578e9bdd7928aec45fd0/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=04a704a4aafd2da62601578e9bdd7928aec45fd0", "patch": "@@ -1,3 +1,11 @@\n+2002-06-20  Tom Tromey  <tromey@redhat.com>\n+\n+\tFor PR libgcj/7073:\n+\t* resolve.cc (_Jv_PrepareClass): Only resolve superclass if it\n+\texists.\n+\t* defineclass.cc (handleClassBegin): Superclass for interface is\n+\t`null'.\n+\n 2002-06-18  Tom Tromey  <tromey@redhat.com>\n \n \t* gcj/javaprims.h: Updated class declaration list."}, {"sha": "190af6ac356954323ab5de05bcc6d4c752178d78", "filename": "libjava/defineclass.cc", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04a704a4aafd2da62601578e9bdd7928aec45fd0/libjava%2Fdefineclass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04a704a4aafd2da62601578e9bdd7928aec45fd0/libjava%2Fdefineclass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdefineclass.cc?ref=04a704a4aafd2da62601578e9bdd7928aec45fd0", "patch": "@@ -1,6 +1,6 @@\n // defineclass.cc - defining a class from .class format.\n \n-/* Copyright (C) 1999, 2000, 2001  Free Software Foundation\n+/* Copyright (C) 1999, 2000, 2001, 2002  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -895,20 +895,11 @@ _Jv_ClassReader::handleClassBegin\n   pool_data[this_class].clazz = def;\n   pool_tags[this_class] = JV_CONSTANT_ResolvedClass;\n \n-  if (super_class == 0)\n+  if (super_class == 0 && ! (access_flags & Modifier::INTERFACE))\n     {\n-      // interfaces have java.lang.Object as super.\n-      if (access_flags & Modifier::INTERFACE)\n-\t{\n-\t  def->superclass = (jclass)&java::lang::Object::class$;\n-\t}\n-\n       // FIXME: Consider this carefully!  \n-      else if (!_Jv_equalUtf8Consts (def->name,\n-\t\t\t\t     java::lang::Object::class$.name))\n-\t{\n-\t  throw_no_class_def_found_error (\"loading java.lang.Object\");\n-\t}\n+      if (! _Jv_equalUtf8Consts (def->name, java::lang::Object::class$.name))\n+\tthrow_no_class_def_found_error (\"loading java.lang.Object\");\n     }\n \n   // In the pre-loading state, it can be looked up in the\n@@ -924,25 +915,30 @@ _Jv_ClassReader::handleClassBegin\n \n   if (super_class != 0)\n     {\n-      // load the super class\n+      // Load the superclass.\n       check_tag (super_class, JV_CONSTANT_Class);\n       _Jv_Utf8Const* super_name = pool_data[super_class].utf8; \n \n-      // load the super class using our defining loader\n+      // Load the superclass using our defining loader.\n       jclass the_super = _Jv_FindClass (super_name,\n \t\t\t\t\tdef->loader);\n \n       // This will establish that we are allowed to be a subclass,\n-      // and check for class circularity error\n+      // and check for class circularity error.\n       checkExtends (def, the_super);\n \n-      def->superclass = the_super;\n+      // Note: for an interface we will find Object as the\n+      // superclass.  We still check it above to ensure class file\n+      // validity, but we simply assign `null' to the actual field in\n+      // this case.\n+      def->superclass = (((access_flags & Modifier::INTERFACE))\n+\t\t\t ? NULL : the_super);\n       pool_data[super_class].clazz = the_super;\n       pool_tags[super_class] = JV_CONSTANT_ResolvedClass;\n     }\n \n-  // now we've come past the circularity problem, we can \n-  // now say that we're loading...\n+  // Now we've come past the circularity problem, we can \n+  // now say that we're loading.\n \n   def->state = JV_STATE_LOADING;\n   def->notifyAll ();"}, {"sha": "f55875509e3abd71b93d5d20171f701dd53a4fea", "filename": "libjava/resolve.cc", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04a704a4aafd2da62601578e9bdd7928aec45fd0/libjava%2Fresolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04a704a4aafd2da62601578e9bdd7928aec45fd0/libjava%2Fresolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fresolve.cc?ref=04a704a4aafd2da62601578e9bdd7928aec45fd0", "patch": "@@ -516,11 +516,14 @@ _Jv_PrepareClass(jclass klass)\n   if (klass->state >= JV_STATE_PREPARED)\n     return;\n \n-  // make sure super-class is linked.  This involves taking a lock on\n-  // the super class, so we use the Java method resolveClass, which will\n-  // unlock it properly, should an exception happen.\n+  // Make sure super-class is linked.  This involves taking a lock on\n+  // the super class, so we use the Java method resolveClass, which\n+  // will unlock it properly, should an exception happen.  If there's\n+  // no superclass, do nothing -- Object will already have been\n+  // resolved.\n \n-  java::lang::ClassLoader::resolveClass0 (klass->superclass);\n+  if (klass->superclass)\n+    java::lang::ClassLoader::resolveClass0 (klass->superclass);\n \n   _Jv_InterpClass *clz = (_Jv_InterpClass*)klass;\n \n@@ -529,8 +532,12 @@ _Jv_PrepareClass(jclass klass)\n   int instance_size;\n   int static_size;\n \n-  // java.lang.Object is never interpreted!\n-  instance_size = clz->superclass->size ();\n+  // Although java.lang.Object is never interpreted, an interface can\n+  // have a null superclass.\n+  if (clz->superclass)\n+    instance_size = clz->superclass->size();\n+  else\n+    instance_size = java::lang::Object::class$.size();\n   static_size   = 0;\n \n   for (int i = 0; i < clz->field_count; i++)\n@@ -646,9 +653,6 @@ _Jv_PrepareClass(jclass klass)\n \n   jclass super_class = clz->getSuperclass ();\n \n-  if (super_class == 0)\n-    throw_internal_error (\"cannot handle interpreted base classes\");\n-\n   for (int i = 0; i < clz->method_count; i++)\n     {\n       _Jv_Method *this_meth = &clz->methods[i];\n@@ -708,6 +712,10 @@ _Jv_PrepareClass(jclass klass)\n     while (effective_superclass && effective_superclass->vtable == NULL)\n       effective_superclass = effective_superclass->superclass;\n \n+    /* If we ended up without a superclass, use Object.  */\n+    if (! effective_superclass)\n+      effective_superclass = &java::lang::Object::class$;\n+\n     /* copy super class' vtable entries. */\n     if (effective_superclass && effective_superclass->vtable)\n       for (int i = 0; i < effective_superclass->vtable_method_count; ++i)"}]}