{"sha": "9b7bf67dadd9a23364c784de2c64be87d1819b67", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI3YmY2N2RhZGQ5YTIzMzY0Yzc4NGRlMmM2NGJlODdkMTgxOWI2Nw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-07-17T22:19:58Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-07-17T22:19:58Z"}, "message": "ia64.md (movdi): Split out load address code.\n\n        * config/ia64/ia64.md (movdi): Split out load address code.\n        New post-reload splitter for symbolic operands.\n        (movdi_internal): Abort if we didn't split symbolic operands\n        when we should have.\n        * config/ia64/ia64.c (ia64_expand_load_address): New, from movdi bits.\n        (ia64_reorg): Split insns when not optimizing.\n        * config/ia64/ia64-protos.h (ia64_expand_load_address): Declare.\n\nFrom-SVN: r35106", "tree": {"sha": "84a0d95bd1cb6c54a3aefe6a2cc6016d9bc3b4ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84a0d95bd1cb6c54a3aefe6a2cc6016d9bc3b4ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b7bf67dadd9a23364c784de2c64be87d1819b67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b7bf67dadd9a23364c784de2c64be87d1819b67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b7bf67dadd9a23364c784de2c64be87d1819b67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b7bf67dadd9a23364c784de2c64be87d1819b67/comments", "author": null, "committer": null, "parents": [{"sha": "5dc6aef5d443eae0800271a357d9a03c3b75bc15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dc6aef5d443eae0800271a357d9a03c3b75bc15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5dc6aef5d443eae0800271a357d9a03c3b75bc15"}], "stats": {"total": 170, "additions": 111, "deletions": 59}, "files": [{"sha": "1cca26365fb7db23af0da887152b081d7add30aa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b7bf67dadd9a23364c784de2c64be87d1819b67/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b7bf67dadd9a23364c784de2c64be87d1819b67/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9b7bf67dadd9a23364c784de2c64be87d1819b67", "patch": "@@ -1,3 +1,13 @@\n+2000-07-17  Richard Henderson  <rth@cygnus.com>\n+\n+\t* config/ia64/ia64.md (movdi): Split out load address code.\n+\tNew post-reload splitter for symbolic operands.\n+\t(movdi_internal): Abort if we didn't split symbolic operands\n+\twhen we should have.\n+\t* config/ia64/ia64.c (ia64_expand_load_address): New, from movdi bits.\n+\t(ia64_reorg): Split insns when not optimizing.\n+\t* config/ia64/ia64-protos.h (ia64_expand_load_address): Declare.\n+\n Mon Jul 17 23:43:26 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n \n \t* real.h (REAL_VALUE_TO_TARGET_LONG_DOUBLE): Use LONG_DOUBLE_TYPE_SIZE\n@@ -39,7 +49,7 @@ Mon Jul 17 08:26:35 2000  Clinton Popetz  <cpopetz@cygnus.com>\n \n 2000-07-17  Mark Klein <mklein@dis.com>\n \n-         * pa.c (emit_hpdiv_const): Update to match new pattern for udivsi3.\n+\t * pa.c (emit_hpdiv_const): Update to match new pattern for udivsi3.\n \n 2000-07-17  J. David Anglin  <dave@hiauly1.hia.nrc.ca>\n "}, {"sha": "8949c1dfac9f7eb69a64ed8e6f1c23d312f235d5", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b7bf67dadd9a23364c784de2c64be87d1819b67/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b7bf67dadd9a23364c784de2c64be87d1819b67/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=9b7bf67dadd9a23364c784de2c64be87d1819b67", "patch": "@@ -52,6 +52,7 @@ extern int call_multiple_values_operation PARAMS((rtx, enum machine_mode));\n extern int predicate_operator PARAMS((rtx, enum machine_mode));\n extern int ia64_move_ok PARAMS((rtx, rtx));\n \n+extern void ia64_expand_load_address PARAMS((rtx, rtx));\n extern void ia64_expand_fetch_and_op PARAMS ((enum fetchop_code,\n \t\t\t\t\t      enum machine_mode, rtx []));\n extern void ia64_expand_op_and_fetch PARAMS ((enum fetchop_code,"}, {"sha": "a87d25661c623b9b2d7c9e3b6be3455b55d7f76b", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b7bf67dadd9a23364c784de2c64be87d1819b67/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b7bf67dadd9a23364c784de2c64be87d1819b67/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=9b7bf67dadd9a23364c784de2c64be87d1819b67", "patch": "@@ -542,7 +542,7 @@ predicate_operator (op, mode)\n   return ((GET_MODE (op) == mode || mode == VOIDmode)\n \t  && (code == EQ || code == NE));\n }\n-\n+\f\n /* Return 1 if the operands of a move are ok.  */\n \n int\n@@ -566,6 +566,53 @@ ia64_move_ok (dst, src)\n   else\n     return GET_CODE (src) == CONST_DOUBLE && CONST_DOUBLE_OK_FOR_G (src);\n }\n+\n+/* Expand a symbolic constant load.  */\n+/* ??? Should generalize this, so that we can also support 32 bit pointers.  */\n+\n+void\n+ia64_expand_load_address (dest, src)\n+      rtx dest, src;\n+{\n+  rtx temp;\n+\n+  /* The destination could be a MEM during initial rtl generation,\n+     which isn't a valid destination for the PIC load address patterns.  */\n+  if (! register_operand (dest, DImode))\n+    temp = gen_reg_rtx (DImode);\n+  else\n+    temp = dest;\n+\n+  if (TARGET_AUTO_PIC)\n+    emit_insn (gen_load_gprel64 (temp, src));\n+  else if (GET_CODE (src) == SYMBOL_REF && SYMBOL_REF_FLAG (src))\n+    emit_insn (gen_load_fptr (temp, src));\n+  else if (sdata_symbolic_operand (src, DImode))\n+    emit_insn (gen_load_gprel (temp, src));\n+  else if (GET_CODE (src) == CONST\n+\t   && GET_CODE (XEXP (src, 0)) == PLUS\n+\t   && GET_CODE (XEXP (XEXP (src, 0), 1)) == CONST_INT\n+\t   && (INTVAL (XEXP (XEXP (src, 0), 1)) & 0x1fff) != 0)\n+    {\n+      rtx subtarget = no_new_pseudos ? temp : gen_reg_rtx (DImode);\n+      rtx sym = XEXP (XEXP (src, 0), 0);\n+      HOST_WIDE_INT ofs, hi, lo;\n+\n+      /* Split the offset into a sign extended 14-bit low part\n+\t and a complementary high part.  */\n+      ofs = INTVAL (XEXP (XEXP (src, 0), 1));\n+      lo = ((ofs & 0x3fff) ^ 0x2000) - 0x2000;\n+      hi = ofs - lo;\n+\n+      emit_insn (gen_load_symptr (subtarget, plus_constant (sym, hi)));\n+      emit_insn (gen_adddi3 (temp, subtarget, GEN_INT (lo)));\n+    }\n+  else\n+    emit_insn (gen_load_symptr (temp, src));\n+\n+  if (temp != dest)\n+    emit_move_insn (dest, temp);\n+}\n \f\n /* Begin the assembly file.  */\n \n@@ -3016,6 +3063,10 @@ void\n ia64_reorg (insns)\n      rtx insns;\n {\n+  /* If optimizing, we'll have split before scheduling.  */\n+  if (optimize == 0)\n+    split_all_insns (0);\n+\n   emit_predicate_relation_info (insns);\n   emit_insn_group_barriers (insns);\n }"}, {"sha": "1e5253b201921e3d0ec8851aa5df6b102b79c2aa", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 47, "deletions": 57, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b7bf67dadd9a23364c784de2c64be87d1819b67/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b7bf67dadd9a23364c784de2c64be87d1819b67/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=9b7bf67dadd9a23364c784de2c64be87d1819b67", "patch": "@@ -247,53 +247,11 @@\n   \"\"\n   \"\n {\n-  /* ??? Should generalize this, so that we can also support 32 bit\n-     pointers.  */\n   if (! TARGET_NO_PIC && symbolic_operand (operands[1], DImode))\n     {\n-      rtx temp;\n-\n-      /* Operand[0] could be a MEM, which isn't a valid destination for the\n-\t PIC load address patterns.  */\n-      if (! register_operand (operands[0], DImode))\n-\ttemp = gen_reg_rtx (DImode);\n-      else\n-\ttemp = operands[0];\n-\n-      if (TARGET_AUTO_PIC)\n-\temit_insn (gen_load_gprel64 (temp, operands[1]));\n-      else if (GET_CODE (operands[1]) == SYMBOL_REF\n-\t       && SYMBOL_REF_FLAG (operands[1]))\n-\temit_insn (gen_load_fptr (temp, operands[1]));\n-      else if (sdata_symbolic_operand (operands[1], DImode))\n-\temit_insn (gen_load_gprel (temp, operands[1]));\n-      else if (GET_CODE (operands[1]) == CONST\n-\t       && GET_CODE (XEXP (operands[1], 0)) == PLUS\n-\t       && GET_CODE (XEXP (XEXP (operands[1], 0), 1)) == CONST_INT\n-\t       && (INTVAL (XEXP (XEXP (operands[1], 0), 1)) & 0x1fff) != 0)\n-\t{\n-\t  rtx subtarget = no_new_pseudos ? temp : gen_reg_rtx (DImode);\n-\t  rtx sym = XEXP (XEXP (operands[1], 0), 0);\n-\t  HOST_WIDE_INT ofs, hi, lo;\n-\n-\t  /* Split the offset into a sign extended 14-bit low part\n-\t     and a complementary high part.  */\n-\t  ofs = INTVAL (XEXP (XEXP (operands[1], 0), 1));\n-\t  lo = ((ofs & 0x3fff) ^ 0x2000) - 0x2000;\n-\t  hi = ofs - lo;\n-\t\n-\t  emit_insn (gen_load_symptr (subtarget, plus_constant (sym, hi)));\n-\t  emit_insn (gen_adddi3 (temp, subtarget, GEN_INT (lo)));\n-\t}\n-      else\n-\temit_insn (gen_load_symptr (temp, operands[1]));\n-\n-      if (temp == operands[0])\n-\tDONE;\n-\n-      operands[1] = temp;\n+      ia64_expand_load_address (operands[0], operands[1]);\n+      DONE;\n     }\n-\n   if (! reload_in_progress && ! reload_completed\n       && ! ia64_move_ok (operands[0], operands[1]))\n     operands[1] = force_reg (DImode, operands[1]);\n@@ -303,21 +261,53 @@\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r, m,r,*f,*f,*f,Q, r,*b\")\n \t(match_operand:DI 1 \"move_operand\"         \"rO,J,i,m,rO,*f,rO,*f,Q,*f,*b,rO\"))]\n   \"ia64_move_ok (operands[0], operands[1])\"\n-  \"@\n-  mov %0 = %r1\n-  addl %0 = %1, r0\n-  movl %0 = %1\n-  ld8%O1 %0 = %1%P1\n-  st8%Q0 %0 = %r1%P0\n-  getf.sig %0 = %1\n-  setf.sig %0 = %r1\n-  mov %0 = %1\n-  ldf8 %0 = %1%P1\n-  stf8 %0 = %1%P0\n-  mov %0 = %1\n-  mov %0 = %r1\"\n+  \"*\n+{\n+  static const char * const alt[] = {\n+    \\\"mov %0 = %r1\\\",\n+    \\\"addl %0 = %1, r0\\\",\n+    \\\"movl %0 = %1\\\",\n+    \\\"ld8%O1 %0 = %1%P1\\\",\n+    \\\"st8%Q0 %0 = %r1%P0\\\",\n+    \\\"getf.sig %0 = %1\\\",\n+    \\\"setf.sig %0 = %r1\\\",\n+    \\\"mov %0 = %1\\\",\n+    \\\"ldf8 %0 = %1%P1\\\",\n+    \\\"stf8 %0 = %1%P0\\\",\n+    \\\"mov %0 = %1\\\",\n+    \\\"mov %0 = %r1\\\"\n+  };\n+\n+  /* We use 'i' for alternative 2 despite possible PIC problems.\n+\n+     If we define LEGITIMATE_CONSTANT_P such that symbols are not\n+     allowed, then the compiler dumps the data into constant memory\n+     instead of letting us read the values from the GOT.  Similarly\n+     if we use 'n' instead of 'i'.\n+\n+     Instead, we allow such insns through reload and then split them\n+     afterward (even without optimization).  Therefore, we should\n+     never get so far with a symbolic operand.  */\n+\n+  if (which_alternative == 2 && ! TARGET_NO_PIC\n+      && symbolic_operand (operands[1], VOIDmode))\n+    abort ();\n+\n+  return alt[which_alternative];\n+}\"\n   [(set_attr \"type\" \"A,A,L,M,M,M,M,F,M,M,I,I\")])\n \n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(match_operand:DI 1 \"symbolic_operand\" \"\"))]\n+  \"reload_completed && ! TARGET_NO_PIC\"\n+  [(const_int 0)]\n+  \"\n+{\n+  ia64_expand_load_address (operands[0], operands[1]);\n+  DONE;\n+}\")\n+\n (define_expand \"load_fptr\"\n   [(set (match_dup 2)\n \t(plus:DI (reg:DI 1) (match_operand:DI 1 \"function_operand\" \"\")))"}]}