{"sha": "2805fcb32660bc0cdcd5ba54310f1f02651e039f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjgwNWZjYjMyNjYwYmMwY2RjZDViYTU0MzEwZjFmMDI2NTFlMDM5Zg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-10-01T09:16:44Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-10-01T09:16:44Z"}, "message": "c++: Handle std::construct_at on automatic vars during constant evaluation [PR97195]\n\nAs mentioned in the PR, we only support due to a bug in constant expressions\nstd::construct_at on non-automatic variables, because we VERIFY_CONSTANT the\nsecond argument of placement new, which fails verification if it is an\naddress of an automatic variable.\nThe following patch fixes it by not performing that verification, the\nplacement new evaluation later on will verify it after it is dereferenced.\n\n2020-10-01  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c++/97195\n\t* constexpr.c (cxx_eval_call_expression): Don't VERIFY_CONSTANT the\n\tsecond argument.\n\n\t* g++.dg/cpp2a/constexpr-new14.C: New test.", "tree": {"sha": "365c7a4a2491d674e8847fd175ceda5d9ee7beb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/365c7a4a2491d674e8847fd175ceda5d9ee7beb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2805fcb32660bc0cdcd5ba54310f1f02651e039f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2805fcb32660bc0cdcd5ba54310f1f02651e039f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2805fcb32660bc0cdcd5ba54310f1f02651e039f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2805fcb32660bc0cdcd5ba54310f1f02651e039f/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85516b71730d8f9401c34407ac3fadf5f1ebfc4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85516b71730d8f9401c34407ac3fadf5f1ebfc4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85516b71730d8f9401c34407ac3fadf5f1ebfc4e"}], "stats": {"total": 76, "additions": 75, "deletions": 1}, "files": [{"sha": "a118f8a810bf1f10066ccdde22281169ce8c6ec5", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2805fcb32660bc0cdcd5ba54310f1f02651e039f/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2805fcb32660bc0cdcd5ba54310f1f02651e039f/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=2805fcb32660bc0cdcd5ba54310f1f02651e039f", "patch": "@@ -2342,9 +2342,10 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t      tree arg = CALL_EXPR_ARG (t, i);\n \t      arg = cxx_eval_constant_expression (ctx, arg, false,\n \t\t\t\t\t\t  non_constant_p, overflow_p);\n-\t      VERIFY_CONSTANT (arg);\n \t      if (i == 1)\n \t\targ1 = arg;\n+\t      else\n+\t\tVERIFY_CONSTANT (arg);\n \t    }\n \t  gcc_assert (arg1);\n \t  return arg1;"}, {"sha": "fd6f6075ef0c03a5ed722be36e6382068083f03e", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-new14.C", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2805fcb32660bc0cdcd5ba54310f1f02651e039f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2805fcb32660bc0cdcd5ba54310f1f02651e039f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new14.C?ref=2805fcb32660bc0cdcd5ba54310f1f02651e039f", "patch": "@@ -0,0 +1,73 @@\n+// PR c++/97195\n+// { dg-do compile { target c++20 } }\n+\n+namespace std\n+{\n+  typedef __SIZE_TYPE__ size_t;\n+\n+  template <typename T>\n+  struct allocator\n+  {\n+    constexpr allocator () noexcept {}\n+\n+    constexpr T *allocate (size_t n)\n+    { return static_cast<T *> (::operator new (n * sizeof(T))); }\n+\n+    constexpr void\n+    deallocate (T *p, size_t n)\n+    { ::operator delete (p); }\n+  };\n+\n+  template <typename T, typename U = T &&>\n+  U __declval (int);\n+  template <typename T>\n+  T __declval (long);\n+  template <typename T>\n+  auto declval () noexcept -> decltype (__declval<T> (0));\n+\n+  template <typename T>\n+  struct remove_reference\n+  { typedef T type; };\n+  template <typename T>\n+  struct remove_reference<T &>\n+  { typedef T type; };\n+  template <typename T>\n+  struct remove_reference<T &&>\n+  { typedef T type; };\n+\n+  template <typename T>\n+  constexpr T &&\n+  forward (typename std::remove_reference<T>::type &t) noexcept\n+  { return static_cast<T&&> (t); }\n+\n+  template<typename T>\n+  constexpr T &&\n+  forward (typename std::remove_reference<T>::type &&t) noexcept\n+  { return static_cast<T&&> (t); }\n+\n+  template <typename T, typename... A>\n+  constexpr auto\n+  construct_at (T *l, A &&... a)\n+  noexcept (noexcept (::new ((void *) 0) T (std::declval<A> ()...)))\n+  -> decltype (::new ((void *) 0) T (std::declval<A> ()...))\n+  { return ::new ((void *) l) T (std::forward<A> (a)...); }\n+\n+  template <typename T>\n+  constexpr inline void\n+  destroy_at (T *l)\n+  { l->~T (); }\n+}\n+\n+inline void *operator new (std::size_t, void *p) noexcept\n+{ return p; }\n+\n+constexpr bool\n+foo ()\n+{\n+  int a = 5;\n+  int *p = std::construct_at (&a, -1);\n+  if (p[0] != -1)\n+    throw 1;\n+  return true;\n+}\n+constexpr bool b = foo ();"}]}