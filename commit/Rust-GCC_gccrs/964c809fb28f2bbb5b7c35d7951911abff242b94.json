{"sha": "964c809fb28f2bbb5b7c35d7951911abff242b94", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTY0YzgwOWZiMjhmMmJiYjViN2MzNWQ3OTUxOTExYWJmZjI0MmI5NA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-02-05T01:50:22Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-02-05T01:50:22Z"}, "message": "compiler: in range, evaluate array if it has receives or calls\n    \n    The last change was incomplete, in that it did not evaluate the array\n    argument in some cases where it had to be evaluated.  This reuses the\n    existing code for checking whether len/cap is constant.\n    \n    Also clean up the use of _ as the second variable in a for/range,\n    which was previously inconsistent depending on whether the statement\n    used = or :=.\n    \n    Updates golang/go#22313\n    \n    Reviewed-on: https://go-review.googlesource.com/91715\n\nFrom-SVN: r257377", "tree": {"sha": "b28da004d38101795417db74c7864f081e38ba3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b28da004d38101795417db74c7864f081e38ba3f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/964c809fb28f2bbb5b7c35d7951911abff242b94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/964c809fb28f2bbb5b7c35d7951911abff242b94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/964c809fb28f2bbb5b7c35d7951911abff242b94", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/964c809fb28f2bbb5b7c35d7951911abff242b94/comments", "author": null, "committer": null, "parents": [{"sha": "4cff15eaca92180183608371351ba2c818990304", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cff15eaca92180183608371351ba2c818990304", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cff15eaca92180183608371351ba2c818990304"}], "stats": {"total": 59, "additions": 37, "deletions": 22}, "files": [{"sha": "575756eae5a3ec55a35b8bec3393080040cc7e04", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/964c809fb28f2bbb5b7c35d7951911abff242b94/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/964c809fb28f2bbb5b7c35d7951911abff242b94/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=964c809fb28f2bbb5b7c35d7951911abff242b94", "patch": "@@ -1,4 +1,4 @@\n-312af623f48633989e9eb6e559ede84a23998ece\n+5031f878a761bf83f5f96710d62f83e2dc5ecf04\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "3bcc5ae1471c1d270c71f9035f505a7ee586ba25", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/964c809fb28f2bbb5b7c35d7951911abff242b94/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/964c809fb28f2bbb5b7c35d7951911abff242b94/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=964c809fb28f2bbb5b7c35d7951911abff242b94", "patch": "@@ -7957,15 +7957,35 @@ class Find_call_expression : public Traverse\n int\n Find_call_expression::expression(Expression** pexpr)\n {\n-  if ((*pexpr)->call_expression() != NULL\n-      || (*pexpr)->receive_expression() != NULL)\n+  Expression* expr = *pexpr;\n+  if (!expr->is_constant()\n+      && (expr->call_expression() != NULL\n+\t  || expr->receive_expression() != NULL))\n     {\n       this->found_ = true;\n       return TRAVERSE_EXIT;\n     }\n   return TRAVERSE_CONTINUE;\n }\n \n+// Return whether calling len or cap on EXPR, of array type, is a\n+// constant.  The language spec says \"the expressions len(s) and\n+// cap(s) are constants if the type of s is an array or pointer to an\n+// array and the expression s does not contain channel receives or\n+// (non-constant) function calls.\"\n+\n+bool\n+Builtin_call_expression::array_len_is_constant(Expression* expr)\n+{\n+  go_assert(expr->type()->deref()->array_type() != NULL\n+\t    && !expr->type()->deref()->is_slice_type());\n+  if (expr->is_constant())\n+    return true;\n+  Find_call_expression find_call;\n+  Expression::traverse(&expr, &find_call);\n+  return !find_call.found();\n+}\n+\n // Return whether this is constant: len of a string constant, or len\n // or cap of an array, or unsafe.Sizeof, unsafe.Offsetof,\n // unsafe.Alignof.\n@@ -7993,19 +8013,9 @@ Builtin_call_expression::do_is_constant() const\n \t    && !arg_type->points_to()->is_slice_type())\n \t  arg_type = arg_type->points_to();\n \n-\t// The len and cap functions are only constant if there are no\n-\t// function calls or channel operations in the arguments.\n-\t// Otherwise we have to make the call.\n-\tif (!arg->is_constant())\n-\t  {\n-\t    Find_call_expression find_call;\n-\t    Expression::traverse(&arg, &find_call);\n-\t    if (find_call.found())\n-\t      return false;\n-\t  }\n-\n \tif (arg_type->array_type() != NULL\n-\t    && arg_type->array_type()->length() != NULL)\n+\t    && arg_type->array_type()->length() != NULL\n+\t    && Builtin_call_expression::array_len_is_constant(arg))\n \t  return true;\n \n \tif (this->code_ == BUILTIN_LEN && arg_type->is_string_type())"}, {"sha": "18fd91b054fff1790c65613f3eea8a0f31379aa3", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/964c809fb28f2bbb5b7c35d7951911abff242b94/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/964c809fb28f2bbb5b7c35d7951911abff242b94/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=964c809fb28f2bbb5b7c35d7951911abff242b94", "patch": "@@ -2406,6 +2406,11 @@ class Builtin_call_expression : public Call_expression\n   is_builtin()\n   { return true; }\n \n+  // Return whether EXPR, of array type, is a constant if passed to\n+  // len or cap.\n+  static bool\n+  array_len_is_constant(Expression* expr);\n+\n  protected:\n   // This overrides Call_expression::do_lower.\n   Expression*"}, {"sha": "9700cc34363a34303303d2493802acd1ff5d308e", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/964c809fb28f2bbb5b7c35d7951911abff242b94/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/964c809fb28f2bbb5b7c35d7951911abff242b94/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=964c809fb28f2bbb5b7c35d7951911abff242b94", "patch": "@@ -5459,8 +5459,7 @@ Parse::range_clause_decl(const Typed_identifier_list* til,\n \tno->var_value()->set_type_from_range_value();\n       if (is_new)\n \tany_new = true;\n-      if (!Gogo::is_sink_name(pti->name()))\n-        p_range_clause->value = Expression::make_var_reference(no, location);\n+      p_range_clause->value = Expression::make_var_reference(no, location);\n     }\n \n   if (!any_new)"}, {"sha": "c94d8cf369e3080371fe8596435d16d06f1cdc14", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/964c809fb28f2bbb5b7c35d7951911abff242b94/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/964c809fb28f2bbb5b7c35d7951911abff242b94/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=964c809fb28f2bbb5b7c35d7951911abff242b94", "patch": "@@ -5311,11 +5311,12 @@ For_range_statement::do_lower(Gogo* gogo, Named_object*, Block* enclosing,\n   // constant, then we do not evaluate the range variable.  len(x) is\n   // a contant if x is a string constant or if x is an array.  If x is\n   // a constant then evaluating it won't make any difference, so the\n-  // only case to consider is when x is an array.\n+  // only case to consider is when x is an array whose length is constant.\n   bool eval = true;\n-  if (this->value_var_ == NULL\n+  if ((this->value_var_ == NULL || this->value_var_->is_sink_expression())\n       && range_type->array_type() != NULL\n-      && !range_type->is_slice_type())\n+      && !range_type->is_slice_type()\n+      && Builtin_call_expression::array_len_is_constant(this->range_))\n     eval = false;\n \n   Location loc = this->location();\n@@ -5341,7 +5342,7 @@ For_range_statement::do_lower(Gogo* gogo, Named_object*, Block* enclosing,\n   temp_block->add_statement(index_temp);\n \n   Temporary_statement* value_temp = NULL;\n-  if (this->value_var_ != NULL)\n+  if (this->value_var_ != NULL && !this->value_var_->is_sink_expression())\n     {\n       value_temp = Statement::make_temporary(value_type, NULL, loc);\n       temp_block->add_statement(value_temp);\n@@ -5393,7 +5394,7 @@ For_range_statement::do_lower(Gogo* gogo, Named_object*, Block* enclosing,\n       Statement* assign;\n       Expression* index_ref =\n \tExpression::make_temporary_reference(index_temp, loc);\n-      if (this->value_var_ == NULL)\n+      if (this->value_var_ == NULL || this->value_var_->is_sink_expression())\n \tassign = Statement::make_assignment(this->index_var_, index_ref, loc);\n       else\n \t{"}]}