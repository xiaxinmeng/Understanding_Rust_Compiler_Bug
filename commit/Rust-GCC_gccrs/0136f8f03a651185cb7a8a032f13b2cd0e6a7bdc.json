{"sha": "0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDEzNmY4ZjAzYTY1MTE4NWNiN2E4YTAzMmYxM2IyY2QwZTZhN2JkYw==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2013-11-27T11:20:06Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-11-27T11:20:06Z"}, "message": "cgraph.h (enum cgraph_simd_clone_arg_type): New.\n\n\t* cgraph.h (enum cgraph_simd_clone_arg_type): New.\n\t(struct cgraph_simd_clone_arg, struct cgraph_simd_clone): New.\n\t(struct cgraph_node): Add simdclone and simd_clones fields.\n\t* config/i386/i386.c (ix86_simd_clone_compute_vecsize_and_simdlen,\n\tix86_simd_clone_adjust, ix86_simd_clone_usable): New functions.\n\t(TARGET_SIMD_CLONE_COMPUTE_VECSIZE_AND_SIMDLEN,\n\tTARGET_SIMD_CLONE_ADJUST, TARGET_SIMD_CLONE_USABLE): Define.\n\t* doc/tm.texi.in (TARGET_SIMD_CLONE_COMPUTE_VECSIZE_AND_SIMDLEN,\n\tTARGET_SIMD_CLONE_ADJUST, TARGET_SIMD_CLONE_USABLE): Add.\n\t* doc/tm.texi: Regenerated.\n\t* ggc.h (ggc_alloc_cleared_simd_clone_stat): New function.\n\t* ipa-cp.c (determine_versionability): Fail if \"omp declare simd\"\n\tattribute is present.\n\t* omp-low.c: Include pretty-print.h, ipa-prop.h and tree-eh.h.\n\t(simd_clone_vector_of_formal_parm_types): New function.\n\t(simd_clone_struct_alloc, simd_clone_struct_copy,\n\tsimd_clone_vector_of_formal_parm_types, simd_clone_clauses_extract,\n\tsimd_clone_compute_base_data_type, simd_clone_mangle,\n\tsimd_clone_create, simd_clone_adjust_return_type,\n\tcreate_tmp_simd_array, simd_clone_adjust_argument_types,\n\tsimd_clone_init_simd_arrays): New functions.\n\t(struct modify_stmt_info): New type.\n\t(ipa_simd_modify_stmt_ops, ipa_simd_modify_function_body,\n\tsimd_clone_adjust, expand_simd_clones, ipa_omp_simd_clone): New\n\tfunctions.\n\t(pass_data_omp_simd_clone): New variable.\n\t(pass_omp_simd_clone): New class.\n\t(make_pass_omp_simd_clone): New function.\n\t* passes.def (pass_omp_simd_clone): New.\n\t* target.def (TARGET_SIMD_CLONE_COMPUTE_VECSIZE_AND_SIMDLEN,\n\tTARGET_SIMD_CLONE_ADJUST, TARGET_SIMD_CLONE_USABLE): New target\n\thooks.\n\t* target.h (struct cgraph_node, struct cgraph_simd_node): Declare.\n\t* tree-core.h (OMP_CLAUSE_LINEAR_VARIABLE_STRIDE): Document.\n\t* tree.h (OMP_CLAUSE_LINEAR_VARIABLE_STRIDE): Define.\n\t* tree-pass.h (make_pass_omp_simd_clone): New prototype.\n\t* tree-vect-data-refs.c: Include cgraph.h.\n\t(vect_analyze_data_refs): Inline by hand find_data_references_in_loop\n\tand find_data_references_in_bb, if find_data_references_in_stmt\n\tfails, still allow calls to #pragma omp declare simd functions\n\tin #pragma omp simd loops unless they contain data references among\n\tthe call arguments or in lhs.\n\t* tree-vect-loop.c (vect_determine_vectorization_factor): Handle\n\tcalls with no lhs.\n\t(vect_transform_loop): Allow NULL STMT_VINFO_VECTYPE for calls without\n\tlhs.\n\t* tree-vectorizer.h (enum stmt_vec_info_type): Add\n\tcall_simd_clone_vec_info_type.\n\t(struct _stmt_vec_info): Add simd_clone_fndecl field.\n\t(STMT_VINFO_SIMD_CLONE_FNDECL): Define.\n\t* tree-vect-stmts.c: Include tree-ssa-loop.h,\n\ttree-scalar-evolution.h and cgraph.h.\n\t(vectorizable_call): Handle calls without lhs.  Assert\n\t!stmt_can_throw_internal instead of failing for it.  Don't update\n\tEH stuff.\n\t(struct simd_call_arg_info): New.\n\t(vectorizable_simd_clone_call): New function.\n\t(vect_transform_stmt): Call it.\n\t(vect_analyze_stmt): Likewise.  Allow NULL STMT_VINFO_VECTYPE for\n\tcalls without lhs.\n\t* ipa-prop.c (ipa_add_new_function): Only call ipa_analyze_node\n\tif cgraph_function_with_gimple_body_p is true.\nc/\n\t* c-decl.c (c_builtin_function_ext_scope): Avoid binding if\n\texternal_scope is NULL.\ncp/\n\t* semantics.c (finish_omp_clauses): For #pragma omp declare simd\n\tlinear clause step call maybe_constant_value.\ntestsuite/\n\t* g++.dg/gomp/declare-simd-1.C (f38): Make sure\n\tsimdlen is a power of two.\n\t* gcc.dg/gomp/simd-clones-2.c: Compile on all targets.\n\tRemove -msse2.  Adjust regexps for name mangling changes.\n\t* gcc.dg/gomp/simd-clones-3.c: Likewise.\n\t* gcc.dg/vect/vect-simd-clone-1.c: New test.\n\t* gcc.dg/vect/vect-simd-clone-2.c: New test.\n\t* gcc.dg/vect/vect-simd-clone-3.c: New test.\n\t* gcc.dg/vect/vect-simd-clone-4.c: New test.\n\t* gcc.dg/vect/vect-simd-clone-5.c: New test.\n\t* gcc.dg/vect/vect-simd-clone-6.c: New test.\n\t* gcc.dg/vect/vect-simd-clone-7.c: New test.\n\t* gcc.dg/vect/vect-simd-clone-8.c: New test.\n\t* gcc.dg/vect/vect-simd-clone-9.c: New test.\n\t* gcc.dg/vect/vect-simd-clone-10.c: New test.\n\t* gcc.dg/vect/vect-simd-clone-10.h: New file.\n\t* gcc.dg/vect/vect-simd-clone-10a.c: New file.\n\t* gcc.dg/vect/vect-simd-clone-11.c: New test.\n\nCo-Authored-By: Jakub Jelinek <jakub@redhat.com>\n\nFrom-SVN: r205442", "tree": {"sha": "25ba65398ef4237033d6e7ed198c0ba75295716e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25ba65398ef4237033d6e7ed198c0ba75295716e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a7d4a96bf73a4609d596dcec1793f80ac3e9c5ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7d4a96bf73a4609d596dcec1793f80ac3e9c5ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7d4a96bf73a4609d596dcec1793f80ac3e9c5ac"}], "stats": {"total": 3263, "additions": 3234, "deletions": 29}, "files": [{"sha": "2b8ce47490c238a4afbff13c34181c01ed0d67d1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -1,3 +1,69 @@\n+2013-11-27  Aldy Hernandez  <aldyh@redhat.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* cgraph.h (enum cgraph_simd_clone_arg_type): New.\n+\t(struct cgraph_simd_clone_arg, struct cgraph_simd_clone): New.\n+\t(struct cgraph_node): Add simdclone and simd_clones fields.\n+\t* config/i386/i386.c (ix86_simd_clone_compute_vecsize_and_simdlen,\n+\tix86_simd_clone_adjust, ix86_simd_clone_usable): New functions.\n+\t(TARGET_SIMD_CLONE_COMPUTE_VECSIZE_AND_SIMDLEN,\n+\tTARGET_SIMD_CLONE_ADJUST, TARGET_SIMD_CLONE_USABLE): Define.\n+\t* doc/tm.texi.in (TARGET_SIMD_CLONE_COMPUTE_VECSIZE_AND_SIMDLEN,\n+\tTARGET_SIMD_CLONE_ADJUST, TARGET_SIMD_CLONE_USABLE): Add.\n+\t* doc/tm.texi: Regenerated.\n+\t* ggc.h (ggc_alloc_cleared_simd_clone_stat): New function.\n+\t* ipa-cp.c (determine_versionability): Fail if \"omp declare simd\"\n+\tattribute is present.\n+\t* omp-low.c: Include pretty-print.h, ipa-prop.h and tree-eh.h.\n+\t(simd_clone_vector_of_formal_parm_types): New function.\n+\t(simd_clone_struct_alloc, simd_clone_struct_copy,\n+\tsimd_clone_vector_of_formal_parm_types, simd_clone_clauses_extract,\n+\tsimd_clone_compute_base_data_type, simd_clone_mangle,\n+\tsimd_clone_create, simd_clone_adjust_return_type,\n+\tcreate_tmp_simd_array, simd_clone_adjust_argument_types,\n+\tsimd_clone_init_simd_arrays): New functions.\n+\t(struct modify_stmt_info): New type.\n+\t(ipa_simd_modify_stmt_ops, ipa_simd_modify_function_body,\n+\tsimd_clone_adjust, expand_simd_clones, ipa_omp_simd_clone): New\n+\tfunctions.\n+\t(pass_data_omp_simd_clone): New variable.\n+\t(pass_omp_simd_clone): New class.\n+\t(make_pass_omp_simd_clone): New function.\n+\t* passes.def (pass_omp_simd_clone): New.\n+\t* target.def (TARGET_SIMD_CLONE_COMPUTE_VECSIZE_AND_SIMDLEN,\n+\tTARGET_SIMD_CLONE_ADJUST, TARGET_SIMD_CLONE_USABLE): New target\n+\thooks.\n+\t* target.h (struct cgraph_node, struct cgraph_simd_node): Declare.\n+\t* tree-core.h (OMP_CLAUSE_LINEAR_VARIABLE_STRIDE): Document.\n+\t* tree.h (OMP_CLAUSE_LINEAR_VARIABLE_STRIDE): Define.\n+\t* tree-pass.h (make_pass_omp_simd_clone): New prototype.\n+\t* tree-vect-data-refs.c: Include cgraph.h.\n+\t(vect_analyze_data_refs): Inline by hand find_data_references_in_loop\n+\tand find_data_references_in_bb, if find_data_references_in_stmt\n+\tfails, still allow calls to #pragma omp declare simd functions\n+\tin #pragma omp simd loops unless they contain data references among\n+\tthe call arguments or in lhs.\n+\t* tree-vect-loop.c (vect_determine_vectorization_factor): Handle\n+\tcalls with no lhs.\n+\t(vect_transform_loop): Allow NULL STMT_VINFO_VECTYPE for calls without\n+\tlhs.\n+\t* tree-vectorizer.h (enum stmt_vec_info_type): Add\n+\tcall_simd_clone_vec_info_type.\n+\t(struct _stmt_vec_info): Add simd_clone_fndecl field.\n+\t(STMT_VINFO_SIMD_CLONE_FNDECL): Define.\n+\t* tree-vect-stmts.c: Include tree-ssa-loop.h,\n+\ttree-scalar-evolution.h and cgraph.h.\n+\t(vectorizable_call): Handle calls without lhs.  Assert\n+\t!stmt_can_throw_internal instead of failing for it.  Don't update\n+\tEH stuff.\n+\t(struct simd_call_arg_info): New.\n+\t(vectorizable_simd_clone_call): New function.\n+\t(vect_transform_stmt): Call it.\n+\t(vect_analyze_stmt): Likewise.  Allow NULL STMT_VINFO_VECTYPE for\n+\tcalls without lhs.\n+\t* ipa-prop.c (ipa_add_new_function): Only call ipa_analyze_node\n+\tif cgraph_function_with_gimple_body_p is true.\n+\n 2013-11-27  Tom de Vries  <tom@codesourcery.com>\n \t    Marc Glisse  <marc.glisse@inria.fr>\n "}, {"sha": "397e5f69979ddf4ebd093c1e75d172f76697121d", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -1,3 +1,9 @@\n+2013-11-27  Aldy Hernandez  <aldyh@redhat.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-decl.c (c_builtin_function_ext_scope): Avoid binding if\n+\texternal_scope is NULL.\n+\n 2013-11-27  Tom de Vries  <tom@codesourcery.com>\n \t    Marc Glisse  <marc.glisse@inria.fr>\n "}, {"sha": "c019a3eec3218f0fde54b90ece71dab53700c7a5", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -3646,8 +3646,9 @@ c_builtin_function_ext_scope (tree decl)\n   const char *name = IDENTIFIER_POINTER (id);\n   C_DECL_BUILTIN_PROTOTYPE (decl) = prototype_p (type);\n \n-  bind (id, decl, external_scope, /*invisible=*/false, /*nested=*/false,\n-\tUNKNOWN_LOCATION);\n+  if (external_scope)\n+    bind (id, decl, external_scope, /*invisible=*/false, /*nested=*/false,\n+\t  UNKNOWN_LOCATION);\n \n   /* Builtins in the implementation namespace are made visible without\n      needing to be explicitly declared.  See push_file_scope.  */"}, {"sha": "547950498d05772fbc1a748a645aa1c8342ce32c", "filename": "gcc/cgraph.h", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -256,6 +256,99 @@ struct GTY(()) cgraph_clone_info\n   bitmap combined_args_to_skip;\n };\n \n+enum cgraph_simd_clone_arg_type\n+{\n+  SIMD_CLONE_ARG_TYPE_VECTOR,\n+  SIMD_CLONE_ARG_TYPE_UNIFORM,\n+  SIMD_CLONE_ARG_TYPE_LINEAR_CONSTANT_STEP,\n+  SIMD_CLONE_ARG_TYPE_LINEAR_VARIABLE_STEP,\n+  SIMD_CLONE_ARG_TYPE_MASK\n+};\n+\n+/* Function arguments in the original function of a SIMD clone.\n+   Supplementary data for `struct simd_clone'.  */\n+\n+struct GTY(()) cgraph_simd_clone_arg {\n+  /* Original function argument as it originally existed in\n+     DECL_ARGUMENTS.  */\n+  tree orig_arg;\n+\n+  /* orig_arg's function (or for extern functions type from\n+     TYPE_ARG_TYPES).  */\n+  tree orig_type;\n+\n+  /* If argument is a vector, this holds the vector version of\n+     orig_arg that after adjusting the argument types will live in\n+     DECL_ARGUMENTS.  Otherwise, this is NULL.\n+\n+     This basically holds:\n+       vector(simdlen) __typeof__(orig_arg) new_arg.  */\n+  tree vector_arg;\n+\n+  /* vector_arg's type (or for extern functions new vector type.  */\n+  tree vector_type;\n+\n+  /* If argument is a vector, this holds the array where the simd\n+     argument is held while executing the simd clone function.  This\n+     is a local variable in the cloned function.  Its content is\n+     copied from vector_arg upon entry to the clone.\n+\n+     This basically holds:\n+       __typeof__(orig_arg) simd_array[simdlen].  */\n+  tree simd_array;\n+\n+  /* A SIMD clone's argument can be either linear (constant or\n+     variable), uniform, or vector.  */\n+  enum cgraph_simd_clone_arg_type arg_type;\n+\n+  /* For arg_type SIMD_CLONE_ARG_TYPE_LINEAR_CONSTANT_STEP this is\n+     the constant linear step, if arg_type is\n+     SIMD_CLONE_ARG_TYPE_LINEAR_VARIABLE_STEP, this is index of\n+     the uniform argument holding the step, otherwise 0.  */\n+  HOST_WIDE_INT linear_step;\n+\n+  /* Variable alignment if available, otherwise 0.  */\n+  unsigned int alignment;\n+};\n+\n+/* Specific data for a SIMD function clone.  */\n+\n+struct GTY(()) cgraph_simd_clone {\n+  /* Number of words in the SIMD lane associated with this clone.  */\n+  unsigned int simdlen;\n+\n+  /* Number of annotated function arguments in `args'.  This is\n+     usually the number of named arguments in FNDECL.  */\n+  unsigned int nargs;\n+\n+  /* Max hardware vector size in bits for integral vectors.  */\n+  unsigned int vecsize_int;\n+\n+  /* Max hardware vector size in bits for floating point vectors.  */\n+  unsigned int vecsize_float;\n+\n+  /* The mangling character for a given vector size.  This is is used\n+     to determine the ISA mangling bit as specified in the Intel\n+     Vector ABI.  */\n+  unsigned char vecsize_mangle;\n+\n+  /* True if this is the masked, in-branch version of the clone,\n+     otherwise false.  */\n+  unsigned int inbranch : 1;\n+\n+  /* True if this is a Cilk Plus variant.  */\n+  unsigned int cilk_elemental : 1;\n+\n+  /* Doubly linked list of SIMD clones.  */\n+  struct cgraph_node *prev_clone, *next_clone;\n+\n+  /* Original cgraph node the SIMD clones were created for.  */\n+  struct cgraph_node *origin;\n+\n+  /* Annotated function arguments for the original function.  */\n+  struct cgraph_simd_clone_arg GTY((length (\"%h.nargs\"))) args[1];\n+};\n+\n \n /* The cgraph data structure.\n    Each function decl has assigned cgraph_node listing callees and callers.  */\n@@ -284,6 +377,12 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n   /* Declaration node used to be clone of. */\n   tree former_clone_of;\n \n+  /* If this is a SIMD clone, this points to the SIMD specific\n+     information for it.  */\n+  struct cgraph_simd_clone *simdclone;\n+  /* If this function has SIMD clones, this points to the first clone.  */\n+  struct cgraph_node *simd_clones;\n+\n   /* Interprocedural passes scheduled to have their transform functions\n      applied next time we execute local pass on them.  We maintain it\n      per-function in order to allow IPA passes to introduce new functions.  */"}, {"sha": "6d2fd69350de845b58ed5e6f5755c524912a8736", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -43690,6 +43690,184 @@ ix86_memmodel_check (unsigned HOST_WIDE_INT val)\n   return val;\n }\n \n+/* Set CLONEI->vecsize_mangle, CLONEI->vecsize_int,\n+   CLONEI->vecsize_float and if CLONEI->simdlen is 0, also\n+   CLONEI->simdlen.  Return 0 if SIMD clones shouldn't be emitted,\n+   or number of vecsize_mangle variants that should be emitted.  */\n+\n+static int\n+ix86_simd_clone_compute_vecsize_and_simdlen (struct cgraph_node *node,\n+\t\t\t\t\t     struct cgraph_simd_clone *clonei,\n+\t\t\t\t\t     tree base_type, int num)\n+{\n+  int ret = 1;\n+\n+  if (clonei->simdlen\n+      && (clonei->simdlen < 2\n+\t  || clonei->simdlen > 16\n+\t  || (clonei->simdlen & (clonei->simdlen - 1)) != 0))\n+    {\n+      warning_at (DECL_SOURCE_LOCATION (node->decl), 0,\n+\t\t  \"unsupported simdlen %d\\n\", clonei->simdlen);\n+      return 0;\n+    }\n+\n+  tree ret_type = TREE_TYPE (TREE_TYPE (node->decl));\n+  if (TREE_CODE (ret_type) != VOID_TYPE)\n+    switch (TYPE_MODE (ret_type))\n+      {\n+      case QImode:\n+      case HImode:\n+      case SImode:\n+      case DImode:\n+      case SFmode:\n+      case DFmode:\n+      /* case SCmode: */\n+      /* case DCmode: */\n+\tbreak;\n+      default:\n+\twarning_at (DECL_SOURCE_LOCATION (node->decl), 0,\n+\t\t    \"unsupported return type %qT for simd\\n\", ret_type);\n+\treturn 0;\n+      }\n+\n+  tree t;\n+  int i;\n+\n+  for (t = DECL_ARGUMENTS (node->decl), i = 0; t; t = DECL_CHAIN (t), i++)\n+    /* FIXME: Shouldn't we allow such arguments if they are uniform?  */\n+    switch (TYPE_MODE (TREE_TYPE (t)))\n+      {\n+      case QImode:\n+      case HImode:\n+      case SImode:\n+      case DImode:\n+      case SFmode:\n+      case DFmode:\n+      /* case SCmode: */\n+      /* case DCmode: */\n+\tbreak;\n+      default:\n+\twarning_at (DECL_SOURCE_LOCATION (node->decl), 0,\n+\t\t    \"unsupported argument type %qT for simd\\n\", TREE_TYPE (t));\n+\treturn 0;\n+      }\n+\n+  if (clonei->cilk_elemental)\n+    {\n+      /* Parse here processor clause.  If not present, default to 'b'.  */\n+      clonei->vecsize_mangle = 'b';\n+    }\n+  else if (!TREE_PUBLIC (node->decl))\n+    {\n+      /* If the function isn't exported, we can pick up just one ISA\n+\t for the clones.  */\n+      if (TARGET_AVX2)\n+\tclonei->vecsize_mangle = 'd';\n+      else if (TARGET_AVX)\n+\tclonei->vecsize_mangle = 'c';\n+      else\n+\tclonei->vecsize_mangle = 'b';\n+      ret = 1;\n+    }\n+  else\n+    {\n+      clonei->vecsize_mangle = \"bcd\"[num];\n+      ret = 3;\n+    }\n+  switch (clonei->vecsize_mangle)\n+    {\n+    case 'b':\n+      clonei->vecsize_int = 128;\n+      clonei->vecsize_float = 128;\n+      break;\n+    case 'c':\n+      clonei->vecsize_int = 128;\n+      clonei->vecsize_float = 256;\n+      break;\n+    case 'd':\n+      clonei->vecsize_int = 256;\n+      clonei->vecsize_float = 256;\n+      break;\n+    }\n+  if (clonei->simdlen == 0)\n+    {\n+      if (SCALAR_INT_MODE_P (TYPE_MODE (base_type)))\n+\tclonei->simdlen = clonei->vecsize_int;\n+      else\n+\tclonei->simdlen = clonei->vecsize_float;\n+      clonei->simdlen /= GET_MODE_BITSIZE (TYPE_MODE (base_type));\n+      if (clonei->simdlen > 16)\n+\tclonei->simdlen = 16;\n+    }\n+  return ret;\n+}\n+\n+/* Add target attribute to SIMD clone NODE if needed.  */\n+\n+static void\n+ix86_simd_clone_adjust (struct cgraph_node *node)\n+{\n+  const char *str = NULL;\n+  gcc_assert (node->decl == cfun->decl);\n+  switch (node->simdclone->vecsize_mangle)\n+    {\n+    case 'b':\n+      if (!TARGET_SSE2)\n+\tstr = \"sse2\";\n+      break;\n+    case 'c':\n+      if (!TARGET_AVX)\n+\tstr = \"avx\";\n+      break;\n+    case 'd':\n+      if (!TARGET_AVX2)\n+\tstr = \"avx2\";\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  if (str == NULL)\n+    return;\n+  push_cfun (NULL);\n+  tree args = build_tree_list (NULL_TREE, build_string (strlen (str), str));\n+  bool ok = ix86_valid_target_attribute_p (node->decl, NULL, args, 0);\n+  gcc_assert (ok);\n+  pop_cfun ();\n+  ix86_previous_fndecl = NULL_TREE;\n+  ix86_set_current_function (node->decl);\n+}\n+\n+/* If SIMD clone NODE can't be used in a vectorized loop\n+   in current function, return -1, otherwise return a badness of using it\n+   (0 if it is most desirable from vecsize_mangle point of view, 1\n+   slightly less desirable, etc.).  */\n+\n+static int\n+ix86_simd_clone_usable (struct cgraph_node *node)\n+{\n+  switch (node->simdclone->vecsize_mangle)\n+    {\n+    case 'b':\n+      if (!TARGET_SSE2)\n+\treturn -1;\n+      if (!TARGET_AVX)\n+\treturn 0;\n+      return TARGET_AVX2 ? 2 : 1;\n+    case 'c':\n+      if (!TARGET_AVX)\n+\treturn -1;\n+      return TARGET_AVX2 ? 1 : 0;\n+      break;\n+    case 'd':\n+      if (!TARGET_AVX2)\n+\treturn -1;\n+      return 0;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* Implement TARGET_FLOAT_EXCEPTIONS_ROUNDING_SUPPORTED_P.  */\n \n static bool\n@@ -44178,6 +44356,18 @@ ix86_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)\n #undef TARGET_SPILL_CLASS\n #define TARGET_SPILL_CLASS ix86_spill_class\n \n+#undef TARGET_SIMD_CLONE_COMPUTE_VECSIZE_AND_SIMDLEN\n+#define TARGET_SIMD_CLONE_COMPUTE_VECSIZE_AND_SIMDLEN \\\n+  ix86_simd_clone_compute_vecsize_and_simdlen\n+\n+#undef TARGET_SIMD_CLONE_ADJUST\n+#define TARGET_SIMD_CLONE_ADJUST \\\n+  ix86_simd_clone_adjust\n+\n+#undef TARGET_SIMD_CLONE_USABLE\n+#define TARGET_SIMD_CLONE_USABLE \\\n+  ix86_simd_clone_usable\n+\n #undef TARGET_FLOAT_EXCEPTIONS_ROUNDING_SUPPORTED_P\n #define TARGET_FLOAT_EXCEPTIONS_ROUNDING_SUPPORTED_P \\\n   ix86_float_exceptions_rounding_supported_p"}, {"sha": "c45ddbec7bd26ce0b20257bccec6c46e95515b3e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -1,3 +1,9 @@\n+2013-11-27  Aldy Hernandez  <aldyh@redhat.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* semantics.c (finish_omp_clauses): For #pragma omp declare simd\n+\tlinear clause step call maybe_constant_value.\n+\n 2013-11-27  Tom de Vries  <tom@codesourcery.com>\n \t    Marc Glisse  <marc.glisse@inria.fr>\n "}, {"sha": "e72a9c2f1691b580cd53f92de37b4705e635a83e", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -5202,6 +5202,8 @@ finish_omp_clauses (tree clauses)\n \t      t = mark_rvalue_use (t);\n \t      if (!processing_template_decl)\n \t\t{\n+\t\t  if (TREE_CODE (OMP_CLAUSE_DECL (c)) == PARM_DECL)\n+\t\t    t = maybe_constant_value (t);\n \t\t  t = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n \t\t  if (TREE_CODE (TREE_TYPE (OMP_CLAUSE_DECL (c)))\n \t\t      == POINTER_TYPE)"}, {"sha": "966576fe721ba22371697339f2d2f40bbd265a56", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -5818,6 +5818,26 @@ The default is @code{NULL_TREE} which means to not vectorize gather\n loads.\n @end deftypefn\n \n+@deftypefn {Target Hook} int TARGET_SIMD_CLONE_COMPUTE_VECSIZE_AND_SIMDLEN (struct cgraph_node *@var{}, struct cgraph_simd_clone *@var{}, @var{tree}, @var{int})\n+This hook should set @var{vecsize_mangle}, @var{vecsize_int}, @var{vecsize_float}\n+fields in @var{simd_clone} structure pointed by @var{clone_info} argument and also\n+@var{simdlen} field if it was previously 0.\n+The hook should return 0 if SIMD clones shouldn't be emitted,\n+or number of @var{vecsize_mangle} variants that should be emitted.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_SIMD_CLONE_ADJUST (struct cgraph_node *@var{})\n+This hook should add implicit @code{attribute(target(\"...\"))} attribute\n+to SIMD clone @var{node} if needed.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} int TARGET_SIMD_CLONE_USABLE (struct cgraph_node *@var{})\n+This hook should return -1 if SIMD clone @var{node} shouldn't be used\n+in vectorized loops in current function, or non-negative number if it is\n+usable.  In that case, the smaller the number is, the more desirable it is\n+to use it.\n+@end deftypefn\n+\n @node Anchored Addresses\n @section Anchored Addresses\n @cindex anchored addresses"}, {"sha": "63f4edb3a4324f77877fe94bdb22f5d87c8f1eea", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -4422,6 +4422,12 @@ address;  but often a machine-dependent strategy can generate better code.\n \n @hook TARGET_VECTORIZE_BUILTIN_GATHER\n \n+@hook TARGET_SIMD_CLONE_COMPUTE_VECSIZE_AND_SIMDLEN\n+\n+@hook TARGET_SIMD_CLONE_ADJUST\n+\n+@hook TARGET_SIMD_CLONE_USABLE\n+\n @node Anchored Addresses\n @section Anchored Addresses\n @cindex anchored addresses"}, {"sha": "f9033445270fa6393b91d299d6979a1f46171298", "filename": "gcc/ggc.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -276,4 +276,11 @@ ggc_alloc_cleared_gimple_statement_stat (size_t s MEM_STAT_DECL)\n     ggc_internal_cleared_alloc_stat (s PASS_MEM_STAT);\n }\n \n+static inline struct simd_clone *\n+ggc_alloc_cleared_simd_clone_stat (size_t s MEM_STAT_DECL)\n+{\n+  return (struct simd_clone *)\n+    ggc_internal_cleared_alloc_stat (s PASS_MEM_STAT);\n+}\n+\n #endif"}, {"sha": "6fd7e9cfb955c751d27f6cd5dace92dd5a886d43", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -430,6 +430,13 @@ determine_versionability (struct cgraph_node *node)\n     reason = \"not a tree_versionable_function\";\n   else if (cgraph_function_body_availability (node) <= AVAIL_OVERWRITABLE)\n     reason = \"insufficient body availability\";\n+  else if (lookup_attribute (\"omp declare simd\", DECL_ATTRIBUTES (node->decl)))\n+    {\n+      /* Ideally we should clone the SIMD clones themselves and create\n+\t vector copies of them, so IPA-cp and SIMD clones can happily\n+\t coexist, but that may not be worth the effort.  */\n+      reason = \"function has SIMD clones\";\n+    }\n \n   if (reason && dump_file && !node->alias && !node->thunk.thunk_p)\n     fprintf (dump_file, \"Function %s/%i is not versionable, reason: %s.\\n\","}, {"sha": "2254d0de421db792ba599beb6f2f347dbb902053", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -3217,7 +3217,8 @@ ipa_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n static void\n ipa_add_new_function (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n {\n-  ipa_analyze_node (node);\n+  if (cgraph_function_with_gimple_body_p (node))\n+    ipa_analyze_node (node);\n }\n \n /* Register our cgraph hooks if they are not already there.  */"}, {"sha": "042c501ae885d7abb51d5e722c7921b37f1e3b76", "filename": "gcc/ipa.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -426,6 +426,19 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t\t      enqueue_node (cnode, &first, reachable);\n \t\t    }\n \t\t}\n+\n+\t    }\n+\t  /* If any reachable function has simd clones, mark them as\n+\t     reachable as well.  */\n+\t  if (cnode->simd_clones)\n+\t    {\n+\t      cgraph_node *next;\n+\t      for (next = cnode->simd_clones;\n+\t\t   next;\n+\t\t   next = next->simdclone->next_clone)\n+\t\tif (in_boundary_p\n+\t\t    || !pointer_set_insert (reachable, next))\n+\t\t  enqueue_node (next, &first, reachable);\n \t    }\n \t}\n       /* When we see constructor of external variable, keep referred nodes in the"}, {"sha": "71dc81187348367f77b6f313420dc97e75151cbd", "filename": "gcc/omp-low.c", "status": "modified", "additions": 1161, "deletions": 0, "changes": 1161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -67,7 +67,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"omp-low.h\"\n #include \"gimple-low.h\"\n #include \"tree-cfgcleanup.h\"\n+#include \"pretty-print.h\"\n+#include \"ipa-prop.h\"\n #include \"tree-nested.h\"\n+#include \"tree-eh.h\"\n \n \n /* Lowering of OpenMP parallel and workshare constructs proceeds in two\n@@ -10615,5 +10618,1163 @@ make_pass_diagnose_omp_blocks (gcc::context *ctxt)\n {\n   return new pass_diagnose_omp_blocks (ctxt);\n }\n+\f\n+/* SIMD clone supporting code.  */\n+\n+/* Allocate a fresh `simd_clone' and return it.  NARGS is the number\n+   of arguments to reserve space for.  */\n+\n+static struct cgraph_simd_clone *\n+simd_clone_struct_alloc (int nargs)\n+{\n+  struct cgraph_simd_clone *clone_info;\n+  size_t len = (sizeof (struct cgraph_simd_clone)\n+\t\t+ nargs * sizeof (struct cgraph_simd_clone_arg));\n+  clone_info = (struct cgraph_simd_clone *)\n+\t       ggc_internal_cleared_alloc_stat (len PASS_MEM_STAT);\n+  return clone_info;\n+}\n+\n+/* Make a copy of the `struct cgraph_simd_clone' in FROM to TO.  */\n+\n+static inline void\n+simd_clone_struct_copy (struct cgraph_simd_clone *to,\n+\t\t\tstruct cgraph_simd_clone *from)\n+{\n+  memcpy (to, from, (sizeof (struct cgraph_simd_clone)\n+\t\t     + from->nargs * sizeof (struct cgraph_simd_clone_arg)));\n+}\n+\n+/* Return vector of parameter types of function FNDECL.  This uses\n+   TYPE_ARG_TYPES if available, otherwise falls back to types of\n+   DECL_ARGUMENTS types.  */\n+\n+vec<tree>\n+simd_clone_vector_of_formal_parm_types (tree fndecl)\n+{\n+  if (TYPE_ARG_TYPES (TREE_TYPE (fndecl)))\n+    return ipa_get_vector_of_formal_parm_types (TREE_TYPE (fndecl));\n+  vec<tree> args = ipa_get_vector_of_formal_parms (fndecl);\n+  unsigned int i;\n+  tree arg;\n+  FOR_EACH_VEC_ELT (args, i, arg)\n+    args[i] = TREE_TYPE (args[i]);\n+  return args;\n+}\n+\n+/* Given a simd function in NODE, extract the simd specific\n+   information from the OMP clauses passed in CLAUSES, and return\n+   the struct cgraph_simd_clone * if it should be cloned.  *INBRANCH_SPECIFIED\n+   is set to TRUE if the `inbranch' or `notinbranch' clause specified,\n+   otherwise set to FALSE.  */\n+\n+static struct cgraph_simd_clone *\n+simd_clone_clauses_extract (struct cgraph_node *node, tree clauses,\n+\t\t\t    bool *inbranch_specified)\n+{\n+  vec<tree> args = simd_clone_vector_of_formal_parm_types (node->decl);\n+  tree t;\n+  int n;\n+  *inbranch_specified = false;\n+\n+  n = args.length ();\n+  if (n > 0 && args.last () == void_type_node)\n+    n--;\n+\n+  /* To distinguish from an OpenMP simd clone, Cilk Plus functions to\n+     be cloned have a distinctive artificial label in addition to \"omp\n+     declare simd\".  */\n+  bool cilk_clone\n+    = (flag_enable_cilkplus\n+       && lookup_attribute (\"cilk plus elemental\",\n+\t\t\t    DECL_ATTRIBUTES (node->decl)));\n+\n+  /* Allocate one more than needed just in case this is an in-branch\n+     clone which will require a mask argument.  */\n+  struct cgraph_simd_clone *clone_info = simd_clone_struct_alloc (n + 1);\n+  clone_info->nargs = n;\n+  clone_info->cilk_elemental = cilk_clone;\n+\n+  if (!clauses)\n+    {\n+      args.release ();\n+      return clone_info;\n+    }\n+  clauses = TREE_VALUE (clauses);\n+  if (!clauses || TREE_CODE (clauses) != OMP_CLAUSE)\n+    return clone_info;\n+\n+  for (t = clauses; t; t = OMP_CLAUSE_CHAIN (t))\n+    {\n+      switch (OMP_CLAUSE_CODE (t))\n+\t{\n+\tcase OMP_CLAUSE_INBRANCH:\n+\t  clone_info->inbranch = 1;\n+\t  *inbranch_specified = true;\n+\t  break;\n+\tcase OMP_CLAUSE_NOTINBRANCH:\n+\t  clone_info->inbranch = 0;\n+\t  *inbranch_specified = true;\n+\t  break;\n+\tcase OMP_CLAUSE_SIMDLEN:\n+\t  clone_info->simdlen\n+\t    = TREE_INT_CST_LOW (OMP_CLAUSE_SIMDLEN_EXPR (t));\n+\t  break;\n+\tcase OMP_CLAUSE_LINEAR:\n+\t  {\n+\t    tree decl = OMP_CLAUSE_DECL (t);\n+\t    tree step = OMP_CLAUSE_LINEAR_STEP (t);\n+\t    int argno = TREE_INT_CST_LOW (decl);\n+\t    if (OMP_CLAUSE_LINEAR_VARIABLE_STRIDE (t))\n+\t      {\n+\t\tclone_info->args[argno].arg_type\n+\t\t  = SIMD_CLONE_ARG_TYPE_LINEAR_VARIABLE_STEP;\n+\t\tclone_info->args[argno].linear_step = tree_to_shwi (step);\n+\t\tgcc_assert (clone_info->args[argno].linear_step >= 0\n+\t\t\t    && clone_info->args[argno].linear_step < n);\n+\t      }\n+\t    else\n+\t      {\n+\t\tif (POINTER_TYPE_P (args[argno]))\n+\t\t  step = fold_convert (ssizetype, step);\n+\t\tif (!tree_fits_shwi_p (step))\n+\t\t  {\n+\t\t    warning_at (OMP_CLAUSE_LOCATION (t), 0,\n+\t\t\t\t\"ignoring large linear step\");\n+\t\t    args.release ();\n+\t\t    return NULL;\n+\t\t  }\n+\t\telse if (integer_zerop (step))\n+\t\t  {\n+\t\t    warning_at (OMP_CLAUSE_LOCATION (t), 0,\n+\t\t\t\t\"ignoring zero linear step\");\n+\t\t    args.release ();\n+\t\t    return NULL;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    clone_info->args[argno].arg_type\n+\t\t      = SIMD_CLONE_ARG_TYPE_LINEAR_CONSTANT_STEP;\n+\t\t    clone_info->args[argno].linear_step = tree_to_shwi (step);\n+\t\t  }\n+\t      }\n+\t    break;\n+\t  }\n+\tcase OMP_CLAUSE_UNIFORM:\n+\t  {\n+\t    tree decl = OMP_CLAUSE_DECL (t);\n+\t    int argno = tree_to_uhwi (decl);\n+\t    clone_info->args[argno].arg_type\n+\t      = SIMD_CLONE_ARG_TYPE_UNIFORM;\n+\t    break;\n+\t  }\n+\tcase OMP_CLAUSE_ALIGNED:\n+\t  {\n+\t    tree decl = OMP_CLAUSE_DECL (t);\n+\t    int argno = tree_to_uhwi (decl);\n+\t    clone_info->args[argno].alignment\n+\t      = TREE_INT_CST_LOW (OMP_CLAUSE_ALIGNED_ALIGNMENT (t));\n+\t    break;\n+\t  }\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+  args.release ();\n+  return clone_info;\n+}\n+\n+/* Given a SIMD clone in NODE, calculate the characteristic data\n+   type and return the coresponding type.  The characteristic data\n+   type is computed as described in the Intel Vector ABI.  */\n+\n+static tree\n+simd_clone_compute_base_data_type (struct cgraph_node *node,\n+\t\t\t\t   struct cgraph_simd_clone *clone_info)\n+{\n+  tree type = integer_type_node;\n+  tree fndecl = node->decl;\n+\n+  /* a) For non-void function, the characteristic data type is the\n+        return type.  */\n+  if (TREE_CODE (TREE_TYPE (TREE_TYPE (fndecl))) != VOID_TYPE)\n+    type = TREE_TYPE (TREE_TYPE (fndecl));\n+\n+  /* b) If the function has any non-uniform, non-linear parameters,\n+        then the characteristic data type is the type of the first\n+        such parameter.  */\n+  else\n+    {\n+      vec<tree> map = simd_clone_vector_of_formal_parm_types (fndecl);\n+      for (unsigned int i = 0; i < clone_info->nargs; ++i)\n+\tif (clone_info->args[i].arg_type == SIMD_CLONE_ARG_TYPE_VECTOR)\n+\t  {\n+\t    type = map[i];\n+\t    break;\n+\t  }\n+      map.release ();\n+    }\n+\n+  /* c) If the characteristic data type determined by a) or b) above\n+        is struct, union, or class type which is pass-by-value (except\n+        for the type that maps to the built-in complex data type), the\n+        characteristic data type is int.  */\n+  if (RECORD_OR_UNION_TYPE_P (type)\n+      && !aggregate_value_p (type, NULL)\n+      && TREE_CODE (type) != COMPLEX_TYPE)\n+    return integer_type_node;\n+\n+  /* d) If none of the above three classes is applicable, the\n+        characteristic data type is int.  */\n+\n+  return type;\n+\n+  /* e) For Intel Xeon Phi native and offload compilation, if the\n+        resulting characteristic data type is 8-bit or 16-bit integer\n+        data type, the characteristic data type is int.  */\n+  /* Well, we don't handle Xeon Phi yet.  */\n+}\n+\n+static tree\n+simd_clone_mangle (struct cgraph_node *node,\n+\t\t   struct cgraph_simd_clone *clone_info)\n+{\n+  char vecsize_mangle = clone_info->vecsize_mangle;\n+  char mask = clone_info->inbranch ? 'M' : 'N';\n+  unsigned int simdlen = clone_info->simdlen;\n+  unsigned int n;\n+  pretty_printer pp;\n+\n+  gcc_assert (vecsize_mangle && simdlen);\n+\n+  pp_string (&pp, \"_ZGV\");\n+  pp_character (&pp, vecsize_mangle);\n+  pp_character (&pp, mask);\n+  pp_decimal_int (&pp, simdlen);\n+\n+  for (n = 0; n < clone_info->nargs; ++n)\n+    {\n+      struct cgraph_simd_clone_arg arg = clone_info->args[n];\n+\n+      if (arg.arg_type == SIMD_CLONE_ARG_TYPE_UNIFORM)\n+\tpp_character (&pp, 'u');\n+      else if (arg.arg_type == SIMD_CLONE_ARG_TYPE_LINEAR_CONSTANT_STEP)\n+\t{\n+\t  gcc_assert (arg.linear_step != 0);\n+\t  pp_character (&pp, 'l');\n+\t  if (arg.linear_step > 1)\n+\t    pp_unsigned_wide_integer (&pp, arg.linear_step);\n+\t  else if (arg.linear_step < 0)\n+\t    {\n+\t      pp_character (&pp, 'n');\n+\t      pp_unsigned_wide_integer (&pp, (-(unsigned HOST_WIDE_INT)\n+\t\t\t\t\t      arg.linear_step));\n+\t    }\n+\t}\n+      else if (arg.arg_type == SIMD_CLONE_ARG_TYPE_LINEAR_VARIABLE_STEP)\n+\t{\n+\t  pp_character (&pp, 's');\n+\t  pp_unsigned_wide_integer (&pp, arg.linear_step);\n+\t}\n+      else\n+\tpp_character (&pp, 'v');\n+      if (arg.alignment)\n+\t{\n+\t  pp_character (&pp, 'a');\n+\t  pp_decimal_int (&pp, arg.alignment);\n+\t}\n+    }\n+\n+  pp_underscore (&pp);\n+  pp_string (&pp,\n+\t     IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (node->decl)));\n+  const char *str = pp_formatted_text (&pp);\n+\n+  /* If there already is a SIMD clone with the same mangled name, don't\n+     add another one.  This can happen e.g. for\n+     #pragma omp declare simd\n+     #pragma omp declare simd simdlen(8)\n+     int foo (int, int);\n+     if the simdlen is assumed to be 8 for the first one, etc.  */\n+  for (struct cgraph_node *clone = node->simd_clones; clone;\n+       clone = clone->simdclone->next_clone)\n+    if (strcmp (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (clone->decl)),\n+\t\tstr) == 0)\n+      return NULL_TREE;\n+\n+  return get_identifier (str);\n+}\n+\n+/* Create a simd clone of OLD_NODE and return it.  */\n+\n+static struct cgraph_node *\n+simd_clone_create (struct cgraph_node *old_node)\n+{\n+  struct cgraph_node *new_node;\n+  if (old_node->definition)\n+    new_node = cgraph_function_versioning (old_node, vNULL, NULL, NULL, false,\n+\t\t\t\t\t   NULL, NULL, \"simdclone\");\n+  else\n+    {\n+      tree old_decl = old_node->decl;\n+      tree new_decl = copy_node (old_node->decl);\n+      DECL_NAME (new_decl) = clone_function_name (old_decl, \"simdclone\");\n+      SET_DECL_ASSEMBLER_NAME (new_decl, DECL_NAME (new_decl));\n+      SET_DECL_RTL (new_decl, NULL);\n+      DECL_STATIC_CONSTRUCTOR (new_decl) = 0;\n+      DECL_STATIC_DESTRUCTOR (new_decl) = 0;\n+      new_node\n+\t= cgraph_copy_node_for_versioning (old_node, new_decl, vNULL, NULL);\n+      cgraph_call_function_insertion_hooks (new_node);\n+    }\n+  if (new_node == NULL)\n+    return new_node;\n+\n+  TREE_PUBLIC (new_node->decl) = TREE_PUBLIC (old_node->decl);\n+\n+  /* The function cgraph_function_versioning () will force the new\n+     symbol local.  Undo this, and inherit external visability from\n+     the old node.  */\n+  new_node->local.local = old_node->local.local;\n+  new_node->externally_visible = old_node->externally_visible;\n+\n+  return new_node;\n+}\n+\n+/* Adjust the return type of the given function to its appropriate\n+   vector counterpart.  Returns a simd array to be used throughout the\n+   function as a return value.  */\n+\n+static tree\n+simd_clone_adjust_return_type (struct cgraph_node *node)\n+{\n+  tree fndecl = node->decl;\n+  tree orig_rettype = TREE_TYPE (TREE_TYPE (fndecl));\n+  unsigned int veclen;\n+  tree t;\n+\n+  /* Adjust the function return type.  */\n+  if (orig_rettype == void_type_node)\n+    return NULL_TREE;\n+  TREE_TYPE (fndecl) = build_distinct_type_copy (TREE_TYPE (fndecl));\n+  if (INTEGRAL_TYPE_P (TREE_TYPE (TREE_TYPE (fndecl)))\n+      || POINTER_TYPE_P (TREE_TYPE (TREE_TYPE (fndecl))))\n+    veclen = node->simdclone->vecsize_int;\n+  else\n+    veclen = node->simdclone->vecsize_float;\n+  veclen /= GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (TREE_TYPE (fndecl))));\n+  if (veclen > node->simdclone->simdlen)\n+    veclen = node->simdclone->simdlen;\n+  if (veclen == node->simdclone->simdlen)\n+    TREE_TYPE (TREE_TYPE (fndecl))\n+      = build_vector_type (TREE_TYPE (TREE_TYPE (fndecl)),\n+\t\t\t   node->simdclone->simdlen);\n+  else\n+    {\n+      t = build_vector_type (TREE_TYPE (TREE_TYPE (fndecl)), veclen);\n+      t = build_array_type_nelts (t, node->simdclone->simdlen / veclen);\n+      TREE_TYPE (TREE_TYPE (fndecl)) = t;\n+    }\n+  if (!node->definition)\n+    return NULL_TREE;\n+\n+  t = DECL_RESULT (fndecl);\n+  /* Adjust the DECL_RESULT.  */\n+  gcc_assert (TREE_TYPE (t) != void_type_node);\n+  TREE_TYPE (t) = TREE_TYPE (TREE_TYPE (fndecl));\n+  relayout_decl (t);\n+\n+  tree atype = build_array_type_nelts (orig_rettype,\n+\t\t\t\t       node->simdclone->simdlen);\n+  if (veclen != node->simdclone->simdlen)\n+    return build1 (VIEW_CONVERT_EXPR, atype, t);\n+\n+  /* Set up a SIMD array to use as the return value.  */\n+  tree retval = create_tmp_var_raw (atype, \"retval\");\n+  gimple_add_tmp_var (retval);\n+  return retval;\n+}\n+\n+/* Each vector argument has a corresponding array to be used locally\n+   as part of the eventual loop.  Create such temporary array and\n+   return it.\n+\n+   PREFIX is the prefix to be used for the temporary.\n+\n+   TYPE is the inner element type.\n+\n+   SIMDLEN is the number of elements.  */\n+\n+static tree\n+create_tmp_simd_array (const char *prefix, tree type, int simdlen)\n+{\n+  tree atype = build_array_type_nelts (type, simdlen);\n+  tree avar = create_tmp_var_raw (atype, prefix);\n+  gimple_add_tmp_var (avar);\n+  return avar;\n+}\n+\n+/* Modify the function argument types to their corresponding vector\n+   counterparts if appropriate.  Also, create one array for each simd\n+   argument to be used locally when using the function arguments as\n+   part of the loop.\n+\n+   NODE is the function whose arguments are to be adjusted.\n+\n+   Returns an adjustment vector that will be filled describing how the\n+   argument types will be adjusted.  */\n+\n+static ipa_parm_adjustment_vec\n+simd_clone_adjust_argument_types (struct cgraph_node *node)\n+{\n+  vec<tree> args;\n+  ipa_parm_adjustment_vec adjustments;\n+\n+  if (node->definition)\n+    args = ipa_get_vector_of_formal_parms (node->decl);\n+  else\n+    args = simd_clone_vector_of_formal_parm_types (node->decl);\n+  adjustments.create (args.length ());\n+  unsigned i, j, veclen;\n+  struct ipa_parm_adjustment adj;\n+  for (i = 0; i < node->simdclone->nargs; ++i)\n+    {\n+      memset (&adj, 0, sizeof (adj));\n+      tree parm = args[i];\n+      tree parm_type = node->definition ? TREE_TYPE (parm) : parm;\n+      adj.base_index = i;\n+      adj.base = parm;\n+\n+      node->simdclone->args[i].orig_arg = node->definition ? parm : NULL_TREE;\n+      node->simdclone->args[i].orig_type = parm_type;\n+\n+      if (node->simdclone->args[i].arg_type != SIMD_CLONE_ARG_TYPE_VECTOR)\n+\t{\n+\t  /* No adjustment necessary for scalar arguments.  */\n+\t  adj.op = IPA_PARM_OP_COPY;\n+\t}\n+      else\n+\t{\n+\t  if (INTEGRAL_TYPE_P (parm_type) || POINTER_TYPE_P (parm_type))\n+\t    veclen = node->simdclone->vecsize_int;\n+\t  else\n+\t    veclen = node->simdclone->vecsize_float;\n+\t  veclen /= GET_MODE_BITSIZE (TYPE_MODE (parm_type));\n+\t  if (veclen > node->simdclone->simdlen)\n+\t    veclen = node->simdclone->simdlen;\n+\t  adj.arg_prefix = \"simd\";\n+\t  adj.type = build_vector_type (parm_type, veclen);\n+\t  node->simdclone->args[i].vector_type = adj.type;\n+\t  for (j = veclen; j < node->simdclone->simdlen; j += veclen)\n+\t    {\n+\t      adjustments.safe_push (adj);\n+\t      if (j == veclen)\n+\t\t{\n+\t\t  memset (&adj, 0, sizeof (adj));\n+\t\t  adj.op = IPA_PARM_OP_NEW;\n+\t\t  adj.arg_prefix = \"simd\";\n+\t\t  adj.base_index = i;\n+\t\t  adj.type = node->simdclone->args[i].vector_type;\n+\t\t}\n+\t    }\n+\n+\t  if (node->definition)\n+\t    node->simdclone->args[i].simd_array\n+\t      = create_tmp_simd_array (IDENTIFIER_POINTER (DECL_NAME (parm)),\n+\t\t\t\t       parm_type, node->simdclone->simdlen);\n+\t}\n+      adjustments.safe_push (adj);\n+    }\n+\n+  if (node->simdclone->inbranch)\n+    {\n+      tree base_type\n+\t= simd_clone_compute_base_data_type (node->simdclone->origin,\n+\t\t\t\t\t     node->simdclone);\n+\n+      memset (&adj, 0, sizeof (adj));\n+      adj.op = IPA_PARM_OP_NEW;\n+      adj.arg_prefix = \"mask\";\n+\n+      adj.base_index = i;\n+      if (INTEGRAL_TYPE_P (base_type) || POINTER_TYPE_P (base_type))\n+\tveclen = node->simdclone->vecsize_int;\n+      else\n+\tveclen = node->simdclone->vecsize_float;\n+      veclen /= GET_MODE_BITSIZE (TYPE_MODE (base_type));\n+      if (veclen > node->simdclone->simdlen)\n+\tveclen = node->simdclone->simdlen;\n+      adj.type = build_vector_type (base_type, veclen);\n+      adjustments.safe_push (adj);\n+\n+      for (j = veclen; j < node->simdclone->simdlen; j += veclen)\n+\tadjustments.safe_push (adj);\n+\n+      /* We have previously allocated one extra entry for the mask.  Use\n+\t it and fill it.  */\n+      struct cgraph_simd_clone *sc = node->simdclone;\n+      sc->nargs++;\n+      if (node->definition)\n+\t{\n+\t  sc->args[i].orig_arg\n+\t    = build_decl (UNKNOWN_LOCATION, PARM_DECL, NULL, base_type);\n+\t  sc->args[i].simd_array\n+\t    = create_tmp_simd_array (\"mask\", base_type, sc->simdlen);\n+\t}\n+      sc->args[i].orig_type = base_type;\n+      sc->args[i].arg_type = SIMD_CLONE_ARG_TYPE_MASK;\n+    }\n+\n+  if (node->definition)\n+    ipa_modify_formal_parameters (node->decl, adjustments);\n+  else\n+    {\n+      tree new_arg_types = NULL_TREE, new_reversed;\n+      bool last_parm_void = false;\n+      if (args.length () > 0 && args.last () == void_type_node)\n+\tlast_parm_void = true;\n+\n+      gcc_assert (TYPE_ARG_TYPES (TREE_TYPE (node->decl)));\n+      j = adjustments.length ();\n+      for (i = 0; i < j; i++)\n+\t{\n+\t  struct ipa_parm_adjustment *adj = &adjustments[i];\n+\t  tree ptype;\n+\t  if (adj->op == IPA_PARM_OP_COPY)\n+\t    ptype = args[adj->base_index];\n+\t  else\n+\t    ptype = adj->type;\n+\t  new_arg_types = tree_cons (NULL_TREE, ptype, new_arg_types);\n+\t}\n+      new_reversed = nreverse (new_arg_types);\n+      if (last_parm_void)\n+\t{\n+\t  if (new_reversed)\n+\t    TREE_CHAIN (new_arg_types) = void_list_node;\n+\t  else\n+\t    new_reversed = void_list_node;\n+\t}\n+\n+      tree new_type = build_distinct_type_copy (TREE_TYPE (node->decl));\n+      TYPE_ARG_TYPES (new_type) = new_reversed;\n+      TREE_TYPE (node->decl) = new_type;\n+\n+      adjustments.release ();\n+    }\n+  args.release ();\n+  return adjustments;\n+}\n+\n+/* Initialize and copy the function arguments in NODE to their\n+   corresponding local simd arrays.  Returns a fresh gimple_seq with\n+   the instruction sequence generated.  */\n+\n+static gimple_seq\n+simd_clone_init_simd_arrays (struct cgraph_node *node,\n+\t\t\t     ipa_parm_adjustment_vec adjustments)\n+{\n+  gimple_seq seq = NULL;\n+  unsigned i = 0, j = 0, k;\n+\n+  for (tree arg = DECL_ARGUMENTS (node->decl);\n+       arg;\n+       arg = DECL_CHAIN (arg), i++, j++)\n+    {\n+      if (adjustments[j].op == IPA_PARM_OP_COPY)\n+\tcontinue;\n+\n+      node->simdclone->args[i].vector_arg = arg;\n+\n+      tree array = node->simdclone->args[i].simd_array;\n+      if (TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg)) == node->simdclone->simdlen)\n+\t{\n+\t  tree ptype = build_pointer_type (TREE_TYPE (TREE_TYPE (array)));\n+\t  tree ptr = build_fold_addr_expr (array);\n+\t  tree t = build2 (MEM_REF, TREE_TYPE (arg), ptr,\n+\t\t\t   build_int_cst (ptype, 0));\n+\t  t = build2 (MODIFY_EXPR, TREE_TYPE (t), t, arg);\n+\t  gimplify_and_add (t, &seq);\n+\t}\n+      else\n+\t{\n+\t  unsigned int simdlen = TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg));\n+\t  tree ptype = build_pointer_type (TREE_TYPE (TREE_TYPE (array)));\n+\t  for (k = 0; k < node->simdclone->simdlen; k += simdlen)\n+\t    {\n+\t      tree ptr = build_fold_addr_expr (array);\n+\t      int elemsize;\n+\t      if (k)\n+\t\t{\n+\t\t  arg = DECL_CHAIN (arg);\n+\t\t  j++;\n+\t\t}\n+\t      elemsize\n+\t\t= GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (TREE_TYPE (arg))));\n+\t      tree t = build2 (MEM_REF, TREE_TYPE (arg), ptr,\n+\t\t\t       build_int_cst (ptype, k * elemsize));\n+\t      t = build2 (MODIFY_EXPR, TREE_TYPE (t), t, arg);\n+\t      gimplify_and_add (t, &seq);\n+\t    }\n+\t}\n+    }\n+  return seq;\n+}\n+\n+/* Callback info for ipa_simd_modify_stmt_ops below.  */\n+\n+struct modify_stmt_info {\n+  ipa_parm_adjustment_vec adjustments;\n+  gimple stmt;\n+  /* True if the parent statement was modified by\n+     ipa_simd_modify_stmt_ops.  */\n+  bool modified;\n+};\n+\n+/* Callback for walk_gimple_op.\n+\n+   Adjust operands from a given statement as specified in the\n+   adjustments vector in the callback data.  */\n+\n+static tree\n+ipa_simd_modify_stmt_ops (tree *tp, int *walk_subtrees, void *data)\n+{\n+  struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n+  if (!SSA_VAR_P (*tp))\n+    {\n+      /* Make sure we treat subtrees as a RHS.  This makes sure that\n+\t when examining the `*foo' in *foo=x, the `foo' get treated as\n+\t a use properly.  */\n+      wi->is_lhs = false;\n+      wi->val_only = true;\n+      if (TYPE_P (*tp))\n+\t*walk_subtrees = 0;\n+      return NULL_TREE;\n+    }\n+  struct modify_stmt_info *info = (struct modify_stmt_info *) wi->info;\n+  struct ipa_parm_adjustment *cand\n+    = ipa_get_adjustment_candidate (&tp, NULL, info->adjustments, true);\n+  if (!cand)\n+    return NULL_TREE;\n+\n+  tree t = *tp;\n+  tree repl = make_ssa_name (TREE_TYPE (t), NULL);\n+\n+  gimple stmt;\n+  gimple_stmt_iterator gsi = gsi_for_stmt (info->stmt);\n+  if (wi->is_lhs)\n+    {\n+      stmt = gimple_build_assign (unshare_expr (cand->new_decl), repl);\n+      gsi_insert_after (&gsi, stmt, GSI_SAME_STMT);\n+      SSA_NAME_DEF_STMT (repl) = info->stmt;\n+    }\n+  else\n+    {\n+      /* You'd think we could skip the extra SSA variable when\n+\t wi->val_only=true, but we may have `*var' which will get\n+\t replaced into `*var_array[iter]' and will likely be something\n+\t not gimple.  */\n+      stmt = gimple_build_assign (repl, unshare_expr (cand->new_decl));\n+      gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n+    }\n+\n+  if (!useless_type_conversion_p (TREE_TYPE (*tp), TREE_TYPE (repl)))\n+    {\n+      tree vce = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (*tp), repl);\n+      *tp = vce;\n+    }\n+  else\n+    *tp = repl;\n+\n+  info->modified = true;\n+  wi->is_lhs = false;\n+  wi->val_only = true;\n+  return NULL_TREE;\n+}\n+\n+/* Traverse the function body and perform all modifications as\n+   described in ADJUSTMENTS.  At function return, ADJUSTMENTS will be\n+   modified such that the replacement/reduction value will now be an\n+   offset into the corresponding simd_array.\n+\n+   This function will replace all function argument uses with their\n+   corresponding simd array elements, and ajust the return values\n+   accordingly.  */\n+\n+static void\n+ipa_simd_modify_function_body (struct cgraph_node *node,\n+\t\t\t       ipa_parm_adjustment_vec adjustments,\n+\t\t\t       tree retval_array, tree iter)\n+{\n+  basic_block bb;\n+  unsigned int i, j;\n+\n+  /* Re-use the adjustments array, but this time use it to replace\n+     every function argument use to an offset into the corresponding\n+     simd_array.  */\n+  for (i = 0, j = 0; i < node->simdclone->nargs; ++i, ++j)\n+    {\n+      if (!node->simdclone->args[i].vector_arg)\n+\tcontinue;\n+\n+      tree basetype = TREE_TYPE (node->simdclone->args[i].orig_arg);\n+      tree vectype = TREE_TYPE (node->simdclone->args[i].vector_arg);\n+      adjustments[j].new_decl\n+\t= build4 (ARRAY_REF,\n+\t\t  basetype,\n+\t\t  node->simdclone->args[i].simd_array,\n+\t\t  iter,\n+\t\t  NULL_TREE, NULL_TREE);\n+      if (adjustments[j].op == IPA_PARM_OP_NONE\n+\t  && TYPE_VECTOR_SUBPARTS (vectype) < node->simdclone->simdlen)\n+\tj += node->simdclone->simdlen / TYPE_VECTOR_SUBPARTS (vectype) - 1;\n+    }\n+\n+  struct modify_stmt_info info;\n+  info.adjustments = adjustments;\n+\n+  FOR_EACH_BB_FN (bb, DECL_STRUCT_FUNCTION (node->decl))\n+    {\n+      gimple_stmt_iterator gsi;\n+\n+      gsi = gsi_start_bb (bb);\n+      while (!gsi_end_p (gsi))\n+\t{\n+\t  gimple stmt = gsi_stmt (gsi);\n+\t  info.stmt = stmt;\n+\t  struct walk_stmt_info wi;\n+\n+\t  memset (&wi, 0, sizeof (wi));\n+\t  info.modified = false;\n+\t  wi.info = &info;\n+\t  walk_gimple_op (stmt, ipa_simd_modify_stmt_ops, &wi);\n+\n+\t  if (gimple_code (stmt) == GIMPLE_RETURN)\n+\t    {\n+\t      tree retval = gimple_return_retval (stmt);\n+\t      if (!retval)\n+\t\t{\n+\t\t  gsi_remove (&gsi, true);\n+\t\t  continue;\n+\t\t}\n+\n+\t      /* Replace `return foo' with `retval_array[iter] = foo'.  */\n+\t      tree ref = build4 (ARRAY_REF, TREE_TYPE (retval),\n+\t\t\t\t retval_array, iter, NULL, NULL);\n+\t      stmt = gimple_build_assign (ref, retval);\n+\t      gsi_replace (&gsi, stmt, true);\n+\t      info.modified = true;\n+\t    }\n+\n+\t  if (info.modified)\n+\t    {\n+\t      update_stmt (stmt);\n+\t      if (maybe_clean_eh_stmt (stmt))\n+\t\tgimple_purge_dead_eh_edges (gimple_bb (stmt));\n+\t    }\n+\t  gsi_next (&gsi);\n+\t}\n+    }\n+}\n+\n+/* Adjust the argument types in NODE to their appropriate vector\n+   counterparts.  */\n+\n+static void\n+simd_clone_adjust (struct cgraph_node *node)\n+{\n+  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+\n+  targetm.simd_clone.adjust (node);\n+\n+  tree retval = simd_clone_adjust_return_type (node);\n+  ipa_parm_adjustment_vec adjustments\n+    = simd_clone_adjust_argument_types (node);\n+\n+  push_gimplify_context ();\n+\n+  gimple_seq seq = simd_clone_init_simd_arrays (node, adjustments);\n+\n+  /* Adjust all uses of vector arguments accordingly.  Adjust all\n+     return values accordingly.  */\n+  tree iter = create_tmp_var (unsigned_type_node, \"iter\");\n+  tree iter1 = make_ssa_name (iter, NULL);\n+  tree iter2 = make_ssa_name (iter, NULL);\n+  ipa_simd_modify_function_body (node, adjustments, retval, iter1);\n+\n+  /* Initialize the iteration variable.  */\n+  basic_block entry_bb = single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+  basic_block body_bb = split_block_after_labels (entry_bb)->dest;\n+  gimple_stmt_iterator gsi = gsi_after_labels (entry_bb);\n+  /* Insert the SIMD array and iv initialization at function\n+     entry.  */\n+  gsi_insert_seq_before (&gsi, seq, GSI_NEW_STMT);\n+\n+  pop_gimplify_context (NULL);\n+\n+  /* Create a new BB right before the original exit BB, to hold the\n+     iteration increment and the condition/branch.  */\n+  basic_block orig_exit = EDGE_PRED (EXIT_BLOCK_PTR_FOR_FN (cfun), 0)->src;\n+  basic_block incr_bb = create_empty_bb (orig_exit);\n+  /* The succ of orig_exit was EXIT_BLOCK_PTR_FOR_FN (cfun), with an empty\n+     flag.  Set it now to be a FALLTHRU_EDGE.  */\n+  gcc_assert (EDGE_COUNT (orig_exit->succs) == 1);\n+  EDGE_SUCC (orig_exit, 0)->flags |= EDGE_FALLTHRU;\n+  for (unsigned i = 0;\n+       i < EDGE_COUNT (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds); ++i)\n+    {\n+      edge e = EDGE_PRED (EXIT_BLOCK_PTR_FOR_FN (cfun), i);\n+      redirect_edge_succ (e, incr_bb);\n+    }\n+  edge e = make_edge (incr_bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n+  e->probability = REG_BR_PROB_BASE;\n+  gsi = gsi_last_bb (incr_bb);\n+  gimple g = gimple_build_assign_with_ops (PLUS_EXPR, iter2, iter1,\n+\t\t\t\t\t   build_int_cst (unsigned_type_node,\n+\t\t\t\t\t\t\t  1));\n+  gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n+\n+  /* Mostly annotate the loop for the vectorizer (the rest is done below).  */\n+  struct loop *loop = alloc_loop ();\n+  cfun->has_force_vect_loops = true;\n+  loop->safelen = node->simdclone->simdlen;\n+  loop->force_vect = true;\n+  loop->header = body_bb;\n+  add_bb_to_loop (incr_bb, loop);\n+\n+  /* Branch around the body if the mask applies.  */\n+  if (node->simdclone->inbranch)\n+    {\n+      gimple_stmt_iterator gsi = gsi_last_bb (loop->header);\n+      tree mask_array\n+\t= node->simdclone->args[node->simdclone->nargs - 1].simd_array;\n+      tree mask = make_ssa_name (TREE_TYPE (TREE_TYPE (mask_array)), NULL);\n+      tree aref = build4 (ARRAY_REF,\n+\t\t\t  TREE_TYPE (TREE_TYPE (mask_array)),\n+\t\t\t  mask_array, iter1,\n+\t\t\t  NULL, NULL);\n+      g = gimple_build_assign (mask, aref);\n+      gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n+      int bitsize = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (aref)));\n+      if (!INTEGRAL_TYPE_P (TREE_TYPE (aref)))\n+\t{\n+\t  aref = build1 (VIEW_CONVERT_EXPR,\n+\t\t\t build_nonstandard_integer_type (bitsize, 0), mask);\n+\t  mask = make_ssa_name (TREE_TYPE (aref), NULL);\n+\t  g = gimple_build_assign (mask, aref);\n+\t  gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n+\t}\n+\n+      g = gimple_build_cond (EQ_EXPR, mask, build_zero_cst (TREE_TYPE (mask)),\n+\t\t\t     NULL, NULL);\n+      gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n+      make_edge (loop->header, incr_bb, EDGE_TRUE_VALUE);\n+      FALLTHRU_EDGE (loop->header)->flags = EDGE_FALSE_VALUE;\n+    }\n+\n+  /* Generate the condition.  */\n+  g = gimple_build_cond (LT_EXPR,\n+\t\t\t iter2,\n+\t\t\t build_int_cst (unsigned_type_node,\n+\t\t\t\t\tnode->simdclone->simdlen),\n+\t\t\t NULL, NULL);\n+  gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n+  e = split_block (incr_bb, gsi_stmt (gsi));\n+  basic_block latch_bb = e->dest;\n+  basic_block new_exit_bb = e->dest;\n+  new_exit_bb = split_block (latch_bb, NULL)->dest;\n+  loop->latch = latch_bb;\n+\n+  redirect_edge_succ (FALLTHRU_EDGE (latch_bb), body_bb);\n+\n+  make_edge (incr_bb, new_exit_bb, EDGE_FALSE_VALUE);\n+  /* The successor of incr_bb is already pointing to latch_bb; just\n+     change the flags.\n+     make_edge (incr_bb, latch_bb, EDGE_TRUE_VALUE);  */\n+  FALLTHRU_EDGE (incr_bb)->flags = EDGE_TRUE_VALUE;\n+\n+  gimple phi = create_phi_node (iter1, body_bb);\n+  edge preheader_edge = find_edge (entry_bb, body_bb);\n+  edge latch_edge = single_succ_edge (latch_bb);\n+  add_phi_arg (phi, build_zero_cst (unsigned_type_node), preheader_edge,\n+\t       UNKNOWN_LOCATION);\n+  add_phi_arg (phi, iter2, latch_edge, UNKNOWN_LOCATION);\n+\n+  /* Generate the new return.  */\n+  gsi = gsi_last_bb (new_exit_bb);\n+  if (retval\n+      && TREE_CODE (retval) == VIEW_CONVERT_EXPR\n+      && TREE_CODE (TREE_OPERAND (retval, 0)) == RESULT_DECL)\n+    retval = TREE_OPERAND (retval, 0);\n+  else if (retval)\n+    {\n+      retval = build1 (VIEW_CONVERT_EXPR,\n+\t\t       TREE_TYPE (TREE_TYPE (node->decl)),\n+\t\t       retval);\n+      retval = force_gimple_operand_gsi (&gsi, retval, true, NULL,\n+\t\t\t\t\t false, GSI_CONTINUE_LINKING);\n+    }\n+  g = gimple_build_return (retval);\n+  gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n+\n+  /* Handle aligned clauses by replacing default defs of the aligned\n+     uniform args with __builtin_assume_aligned (arg_N(D), alignment)\n+     lhs.  Handle linear by adding PHIs.  */\n+  for (unsigned i = 0; i < node->simdclone->nargs; i++)\n+    if (node->simdclone->args[i].alignment\n+\t&& node->simdclone->args[i].arg_type == SIMD_CLONE_ARG_TYPE_UNIFORM\n+\t&& (node->simdclone->args[i].alignment\n+\t    & (node->simdclone->args[i].alignment - 1)) == 0\n+\t&& TREE_CODE (TREE_TYPE (node->simdclone->args[i].orig_arg))\n+\t   == POINTER_TYPE)\n+      {\n+\tunsigned int alignment = node->simdclone->args[i].alignment;\n+\ttree orig_arg = node->simdclone->args[i].orig_arg;\n+\ttree def = ssa_default_def (cfun, orig_arg);\n+\tif (!has_zero_uses (def))\n+\t  {\n+\t    tree fn = builtin_decl_explicit (BUILT_IN_ASSUME_ALIGNED);\n+\t    gimple_seq seq = NULL;\n+\t    bool need_cvt = false;\n+\t    gimple call\n+\t      = gimple_build_call (fn, 2, def, size_int (alignment));\n+\t    g = call;\n+\t    if (!useless_type_conversion_p (TREE_TYPE (orig_arg),\n+\t\t\t\t\t    ptr_type_node))\n+\t      need_cvt = true;\n+\t    tree t = make_ssa_name (need_cvt ? ptr_type_node : orig_arg, NULL);\n+\t    gimple_call_set_lhs (g, t);\n+\t    gimple_seq_add_stmt_without_update (&seq, g);\n+\t    if (need_cvt)\n+\t      {\n+\t\tt = make_ssa_name (orig_arg, NULL);\n+\t\tg = gimple_build_assign_with_ops (NOP_EXPR, t,\n+\t\t\t\t\t\t  gimple_call_lhs (g),\n+\t\t\t\t\t\t  NULL_TREE);\n+\t\tgimple_seq_add_stmt_without_update (&seq, g);\n+\t      }\n+\t    gsi_insert_seq_on_edge_immediate\n+\t      (single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun)), seq);\n+\n+\t    entry_bb = single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+\t    int freq = compute_call_stmt_bb_frequency (current_function_decl,\n+\t\t\t\t\t\t       entry_bb);\n+\t    cgraph_create_edge (node, cgraph_get_create_node (fn),\n+\t\t\t\tcall, entry_bb->count, freq);\n+\n+\t    imm_use_iterator iter;\n+\t    use_operand_p use_p;\n+\t    gimple use_stmt;\n+\t    tree repl = gimple_get_lhs (g);\n+\t    FOR_EACH_IMM_USE_STMT (use_stmt, iter, def)\n+\t      if (is_gimple_debug (use_stmt) || use_stmt == call)\n+\t\tcontinue;\n+\t      else\n+\t\tFOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n+\t\t  SET_USE (use_p, repl);\n+\t  }\n+      }\n+    else if (node->simdclone->args[i].arg_type\n+\t     == SIMD_CLONE_ARG_TYPE_LINEAR_CONSTANT_STEP)\n+      {\n+\ttree orig_arg = node->simdclone->args[i].orig_arg;\n+\ttree def = ssa_default_def (cfun, orig_arg);\n+\tgcc_assert (INTEGRAL_TYPE_P (TREE_TYPE (orig_arg))\n+\t\t    || POINTER_TYPE_P (TREE_TYPE (orig_arg)));\n+\tif (!has_zero_uses (def))\n+\t  {\n+\t    iter1 = make_ssa_name (orig_arg, NULL);\n+\t    iter2 = make_ssa_name (orig_arg, NULL);\n+\t    phi = create_phi_node (iter1, body_bb);\n+\t    add_phi_arg (phi, def, preheader_edge, UNKNOWN_LOCATION);\n+\t    add_phi_arg (phi, iter2, latch_edge, UNKNOWN_LOCATION);\n+\t    enum tree_code code = INTEGRAL_TYPE_P (TREE_TYPE (orig_arg))\n+\t\t\t\t  ? PLUS_EXPR : POINTER_PLUS_EXPR;\n+\t    tree addtype = INTEGRAL_TYPE_P (TREE_TYPE (orig_arg))\n+\t\t\t   ? TREE_TYPE (orig_arg) : sizetype;\n+\t    tree addcst\n+\t      = build_int_cst (addtype, node->simdclone->args[i].linear_step);\n+\t    g = gimple_build_assign_with_ops (code, iter2, iter1, addcst);\n+\t    gsi = gsi_last_bb (incr_bb);\n+\t    gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\n+\t    imm_use_iterator iter;\n+\t    use_operand_p use_p;\n+\t    gimple use_stmt;\n+\t    FOR_EACH_IMM_USE_STMT (use_stmt, iter, def)\n+\t      if (use_stmt == phi)\n+\t\tcontinue;\n+\t      else\n+\t\tFOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n+\t\t  SET_USE (use_p, iter1);\n+\t  }\n+      }\n+\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  add_loop (loop, loop->header->loop_father);\n+  update_ssa (TODO_update_ssa);\n+\n+  pop_cfun ();\n+}\n+\n+/* If the function in NODE is tagged as an elemental SIMD function,\n+   create the appropriate SIMD clones.  */\n+\n+static void\n+expand_simd_clones (struct cgraph_node *node)\n+{\n+  if (lookup_attribute (\"noclone\", DECL_ATTRIBUTES (node->decl)))\n+    return;\n+\n+  tree attr = lookup_attribute (\"omp declare simd\",\n+\t\t\t\tDECL_ATTRIBUTES (node->decl));\n+  if (!attr || targetm.simd_clone.compute_vecsize_and_simdlen == NULL)\n+    return;\n+  /* Ignore\n+     #pragma omp declare simd\n+     extern int foo ();\n+     in C, there we don't know the argument types at all.  */\n+  if (!node->definition\n+      && TYPE_ARG_TYPES (TREE_TYPE (node->decl)) == NULL_TREE)\n+    return;\n+\n+  do\n+    {\n+      /* Start with parsing the \"omp declare simd\" attribute(s).  */\n+      bool inbranch_clause_specified;\n+      struct cgraph_simd_clone *clone_info\n+\t= simd_clone_clauses_extract (node, TREE_VALUE (attr),\n+\t\t\t\t      &inbranch_clause_specified);\n+      if (clone_info == NULL)\n+\tcontinue;\n+\n+      int orig_simdlen = clone_info->simdlen;\n+      tree base_type = simd_clone_compute_base_data_type (node, clone_info);\n+      /* The target can return 0 (no simd clones should be created),\n+\t 1 (just one ISA of simd clones should be created) or higher\n+\t count of ISA variants.  In that case, clone_info is initialized\n+\t for the first ISA variant.  */\n+      int count\n+\t= targetm.simd_clone.compute_vecsize_and_simdlen (node, clone_info,\n+\t\t\t\t\t\t\t  base_type, 0);\n+      if (count == 0)\n+\tcontinue;\n+\n+      /* Loop over all COUNT ISA variants, and if !INBRANCH_CLAUSE_SPECIFIED,\n+\t also create one inbranch and one !inbranch clone of it.  */\n+      for (int i = 0; i < count * 2; i++)\n+\t{\n+\t  struct cgraph_simd_clone *clone = clone_info;\n+\t  if (inbranch_clause_specified && (i & 1) != 0)\n+\t    continue;\n+\n+\t  if (i != 0)\n+\t    {\n+\t      clone = simd_clone_struct_alloc (clone_info->nargs\n+\t\t\t\t\t       - clone_info->inbranch\n+\t\t\t\t\t       + ((i & 1) != 0));\n+\t      simd_clone_struct_copy (clone, clone_info);\n+\t      /* Undo changes targetm.simd_clone.compute_vecsize_and_simdlen\n+\t\t and simd_clone_adjust_argument_types did to the first\n+\t\t clone's info.  */\n+\t      clone->nargs -= clone_info->inbranch;\n+\t      clone->simdlen = orig_simdlen;\n+\t      /* And call the target hook again to get the right ISA.  */\n+\t      targetm.simd_clone.compute_vecsize_and_simdlen (node, clone,\n+\t\t\t\t\t\t\t      base_type,\n+\t\t\t\t\t\t\t      i / 2);\n+\t      if ((i & 1) != 0)\n+\t\tclone->inbranch = 1;\n+\t    }\n+\n+\t  /* simd_clone_mangle might fail if such a clone has been created\n+\t     already.  */\n+\t  tree id = simd_clone_mangle (node, clone);\n+\t  if (id == NULL_TREE)\n+\t    continue;\n+\n+\t  /* Only when we are sure we want to create the clone actually\n+\t     clone the function (or definitions) or create another\n+\t     extern FUNCTION_DECL (for prototypes without definitions).  */\n+\t  struct cgraph_node *n = simd_clone_create (node);\n+\t  if (n == NULL)\n+\t    continue;\n+\n+\t  n->simdclone = clone;\n+\t  clone->origin = node;\n+\t  clone->next_clone = NULL;\n+\t  if (node->simd_clones == NULL)\n+\t    {\n+\t      clone->prev_clone = n;\n+\t      node->simd_clones = n;\n+\t    }\n+\t  else\n+\t    {\n+\t      clone->prev_clone = node->simd_clones->simdclone->prev_clone;\n+\t      clone->prev_clone->simdclone->next_clone = n;\n+\t      node->simd_clones->simdclone->prev_clone = n;\n+\t    }\n+\t  change_decl_assembler_name (n->decl, id);\n+\t  /* And finally adjust the return type, parameters and for\n+\t     definitions also function body.  */\n+\t  if (node->definition)\n+\t    simd_clone_adjust (n);\n+\t  else\n+\t    {\n+\t      simd_clone_adjust_return_type (n);\n+\t      simd_clone_adjust_argument_types (n);\n+\t    }\n+\t}\n+    }\n+  while ((attr = lookup_attribute (\"omp declare simd\", TREE_CHAIN (attr))));\n+}\n+\n+/* Entry point for IPA simd clone creation pass.  */\n+\n+static unsigned int\n+ipa_omp_simd_clone (void)\n+{\n+  struct cgraph_node *node;\n+  FOR_EACH_FUNCTION (node)\n+    expand_simd_clones (node);\n+  return 0;\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_omp_simd_clone =\n+{\n+  SIMPLE_IPA_PASS,\t\t/* type */\n+  \"simdclone\",\t\t\t/* name */\n+  OPTGROUP_NONE,\t\t/* optinfo_flags */\n+  true,\t\t\t\t/* has_gate */\n+  true,\t\t\t\t/* has_execute */\n+  TV_NONE,\t\t\t/* tv_id */\n+  ( PROP_ssa | PROP_cfg ),\t/* properties_required */\n+  0,\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t/* todo_flags_start */\n+  0,\t\t\t\t/* todo_flags_finish */\n+};\n+\n+class pass_omp_simd_clone : public simple_ipa_opt_pass\n+{\n+public:\n+  pass_omp_simd_clone(gcc::context *ctxt)\n+    : simple_ipa_opt_pass(pass_data_omp_simd_clone, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return flag_openmp || flag_openmp_simd\n+\t\t\t|| flag_enable_cilkplus; }\n+  unsigned int execute () { return ipa_omp_simd_clone (); }\n+};\n+\n+} // anon namespace\n+\n+simple_ipa_opt_pass *\n+make_pass_omp_simd_clone (gcc::context *ctxt)\n+{\n+  return new pass_omp_simd_clone (ctxt);\n+}\n \n #include \"gt-omp-low.h\""}, {"sha": "65c00bbbb413fa99c886692b0faefed77b819961", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -117,6 +117,7 @@ along with GCC; see the file COPYING3.  If not see\n      compiled unit.  */\n   INSERT_PASSES_AFTER (all_late_ipa_passes)\n   NEXT_PASS (pass_ipa_pta);\n+  NEXT_PASS (pass_omp_simd_clone);\n   TERMINATE_PASS_LIST ()\n \n   /* These passes are run after IPA passes on every function that is being"}, {"sha": "ca1d2506c7b5cfd88c3ad898950866c3ebdc5781", "filename": "gcc/target.def", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -1521,6 +1521,36 @@ hook_int_uint_mode_1)\n \n HOOK_VECTOR_END (sched)\n \n+/* Functions relating to OpenMP and Cilk Plus SIMD clones.  */\n+#undef HOOK_PREFIX\n+#define HOOK_PREFIX \"TARGET_SIMD_CLONE_\"\n+HOOK_VECTOR (TARGET_SIMD_CLONE, simd_clone)\n+\n+DEFHOOK\n+(compute_vecsize_and_simdlen,\n+\"This hook should set @var{vecsize_mangle}, @var{vecsize_int}, @var{vecsize_float}\\n\\\n+fields in @var{simd_clone} structure pointed by @var{clone_info} argument and also\\n\\\n+@var{simdlen} field if it was previously 0.\\n\\\n+The hook should return 0 if SIMD clones shouldn't be emitted,\\n\\\n+or number of @var{vecsize_mangle} variants that should be emitted.\",\n+int, (struct cgraph_node *, struct cgraph_simd_clone *, tree, int), NULL)\n+\n+DEFHOOK\n+(adjust,\n+\"This hook should add implicit @code{attribute(target(\\\"...\\\"))} attribute\\n\\\n+to SIMD clone @var{node} if needed.\",\n+void, (struct cgraph_node *), NULL)\n+\n+DEFHOOK\n+(usable,\n+\"This hook should return -1 if SIMD clone @var{node} shouldn't be used\\n\\\n+in vectorized loops in current function, or non-negative number if it is\\n\\\n+usable.  In that case, the smaller the number is, the more desirable it is\\n\\\n+to use it.\",\n+int, (struct cgraph_node *), NULL)\n+\n+HOOK_VECTOR_END (simd_clone)\n+\n /* Functions relating to vectorization.  */\n #undef HOOK_PREFIX\n #define HOOK_PREFIX \"TARGET_VECTORIZE_\""}, {"sha": "7c12f82af7dcfcf05ebf16edcd9acd226829e499", "filename": "gcc/target.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -93,6 +93,8 @@ extern bool target_default_pointer_address_modes_p (void);\n struct stdarg_info;\n struct spec_info_def;\n struct hard_reg_set_container;\n+struct cgraph_node;\n+struct cgraph_simd_clone;\n \n /* The struct used by the secondary_reload target hook.  */\n typedef struct secondary_reload_info"}, {"sha": "20e885ade3c79276f4145b0d2c3006e18dbdf560", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -1,3 +1,25 @@\n+2013-11-27  Aldy Hernandez  <aldyh@redhat.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* g++.dg/gomp/declare-simd-1.C (f38): Make sure\n+\tsimdlen is a power of two.\n+\t* gcc.dg/gomp/simd-clones-2.c: Compile on all targets.\n+\tRemove -msse2.  Adjust regexps for name mangling changes.\n+\t* gcc.dg/gomp/simd-clones-3.c: Likewise.\n+\t* gcc.dg/vect/vect-simd-clone-1.c: New test.\n+\t* gcc.dg/vect/vect-simd-clone-2.c: New test.\n+\t* gcc.dg/vect/vect-simd-clone-3.c: New test.\n+\t* gcc.dg/vect/vect-simd-clone-4.c: New test.\n+\t* gcc.dg/vect/vect-simd-clone-5.c: New test.\n+\t* gcc.dg/vect/vect-simd-clone-6.c: New test.\n+\t* gcc.dg/vect/vect-simd-clone-7.c: New test.\n+\t* gcc.dg/vect/vect-simd-clone-8.c: New test.\n+\t* gcc.dg/vect/vect-simd-clone-9.c: New test.\n+\t* gcc.dg/vect/vect-simd-clone-10.c: New test.\n+\t* gcc.dg/vect/vect-simd-clone-10.h: New file.\n+\t* gcc.dg/vect/vect-simd-clone-10a.c: New file.\n+\t* gcc.dg/vect/vect-simd-clone-11.c: New test.\n+\n 2013-11-27  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* gcc.dg/cilk-plus/cilk-plus.exp: Append to ld_library_path."}, {"sha": "4b2812fb6e65d310f4307348d6630af802b6c92d", "filename": "gcc/testsuite/g++.dg/gomp/declare-simd-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-simd-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-simd-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-simd-1.C?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -239,5 +239,5 @@ struct D\n void\n f38 (D &d)\n {\n-  d.f37 <12> (6);\n+  d.f37 <16> (6);\n }"}, {"sha": "486b67a637aaea5c4bc93e3c56b1622b715b8ed9", "filename": "gcc/testsuite/gcc.dg/gomp/simd-clones-1.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsimd-clones-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsimd-clones-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsimd-clones-1.c?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-optimized -O3\" } */\n+\n+/* Test that functions that have SIMD clone counterparts are not\n+   cloned by IPA-cp.  For example, special_add() below has SIMD clones\n+   created for it.  However, if IPA-cp later decides to clone a\n+   specialization of special_add(x, 666) when analyzing fillit(), we\n+   will forever keep the vectorizer from using the SIMD versions of\n+   special_add in a loop.\n+\n+   If IPA-CP gets taught how to adjust the SIMD clones as well, this\n+   test could be removed.  */\n+\n+#pragma omp declare simd simdlen(4)\n+static int  __attribute__ ((noinline))\n+special_add (int x, int y)\n+{\n+  if (y == 666)\n+    return x + y + 123;\n+  else\n+    return x + y;\n+}\n+\n+void fillit(int *tot)\n+{\n+  int i;\n+\n+  for (i=0; i < 10000; ++i)\n+    tot[i] = special_add (i, 666);\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"special_add.constprop\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "030ae6cb19bacc7de2c9362810592d2476c54948", "filename": "gcc/testsuite/gcc.dg/gomp/simd-clones-2.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsimd-clones-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsimd-clones-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsimd-clones-2.c?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-options \"-fopenmp -fdump-tree-optimized -O\" } */\n+\n+#pragma omp declare simd inbranch uniform(c) linear(b:66)\n+#pragma omp declare simd notinbranch aligned(c:32)\n+int addit(int a, int b, int *c)\n+{\n+  return a + b;\n+}\n+\n+#pragma omp declare simd uniform(a) aligned(a:32) linear(k:1) notinbranch\n+float setArray(float *a, float x, int k)\n+{\n+  a[k] = a[k] + x;\n+  return a[k];\n+}\n+\n+/* { dg-final { scan-tree-dump \"_ZGVbN4ua32vl_setArray\" \"optimized\" { target i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"_ZGVbN4vvva32_addit\" \"optimized\" { target i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"_ZGVbM4vl66u_addit\" \"optimized\" { target i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"_ZGVcN8ua32vl_setArray\" \"optimized\" { target i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"_ZGVcN4vvva32_addit\" \"optimized\" { target i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"_ZGVcM4vl66u_addit\" \"optimized\" { target i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"_ZGVdN8ua32vl_setArray\" \"optimized\" { target i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"_ZGVdN8vvva32_addit\" \"optimized\" { target i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"_ZGVdM8vl66u_addit\" \"optimized\" { target i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "98e767c3ae36697c4029b0b3e984c3d44b280287", "filename": "gcc/testsuite/gcc.dg/gomp/simd-clones-3.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsimd-clones-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsimd-clones-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsimd-clones-3.c?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-options \"-fopenmp -fdump-tree-optimized -O2\" } */\n+\n+/* Test that if there is no *inbranch clauses, that both the masked and\n+   the unmasked version are created.  */\n+\n+#pragma omp declare simd\n+int addit(int a, int b, int c)\n+{\n+  return a + b;\n+}\n+\n+/* { dg-final { scan-tree-dump \"_ZGVbN4vvv_addit\" \"optimized\" { target i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"_ZGVbM4vvv_addit\" \"optimized\" { target i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"_ZGVcN4vvv_addit\" \"optimized\" { target i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"_ZGVcM4vvv_addit\" \"optimized\" { target i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"_ZGVdN8vvv_addit\" \"optimized\" { target i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"_ZGVdM8vvv_addit\" \"optimized\" { target i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "893f44e690fb5f2f93546bc29e02b2a4ec106912", "filename": "gcc/testsuite/gcc.dg/gomp/simd-clones-4.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsimd-clones-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsimd-clones-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsimd-clones-4.c?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+#pragma omp declare simd simdlen(4) notinbranch\n+int f2 (int a, int b)\n+{\n+  if (a > 5)\n+    return a + b;\n+  else\n+    return a - b;\n+}"}, {"sha": "801c24f34affdfea7f73cd9e4d1aeced3224066a", "filename": "gcc/testsuite/gcc.dg/gomp/simd-clones-5.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsimd-clones-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsimd-clones-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsimd-clones-5.c?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-fopenmp -w\" } */\n+\n+/* ?? The -w above is to inhibit the following warning for now:\n+   a.c:2:6: warning: AVX vector argument without AVX enabled changes\n+   the ABI [enabled by default].  */\n+\n+#pragma omp declare simd notinbranch simdlen(4)\n+void foo (int *a)\n+{\n+  *a = 555;\n+}"}, {"sha": "8818594bfac22320fe707e9fc752143631f6ea1e", "filename": "gcc/testsuite/gcc.dg/gomp/simd-clones-6.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsimd-clones-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsimd-clones-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsimd-clones-6.c?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+/* Test that array subscripts are properly adjusted.  */\n+\n+int array[1000];\n+#pragma omp declare simd notinbranch simdlen(4)\n+void foo (int i)\n+{\n+  array[i] = 555;\n+}"}, {"sha": "ef6fa113c1ab03981c17079e8b60a4ebdde726d8", "filename": "gcc/testsuite/gcc.dg/gomp/simd-clones-7.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsimd-clones-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsimd-clones-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsimd-clones-7.c?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-fopenmp -w\" } */\n+\n+int array[1000];\n+\n+#pragma omp declare simd notinbranch simdlen(4)\n+void foo (int *a, int b)\n+{\n+  a[b] = 555;\n+}\n+\n+#pragma omp declare simd notinbranch simdlen(4)\n+void bar (int *a)\n+{\n+  *a = 555;\n+}"}, {"sha": "d802dfb7e27172571ee973148c10ecf8517cb3f1", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-1.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-1.c?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+#include \"tree-vect.h\"\n+\n+#ifndef N\n+#define N 1024\n+#endif\n+\n+int array[N];\n+\n+#pragma omp declare simd simdlen(4) notinbranch\n+#pragma omp declare simd simdlen(4) notinbranch uniform(b) linear(c:3)\n+#pragma omp declare simd simdlen(8) notinbranch\n+#pragma omp declare simd simdlen(8) notinbranch uniform(b) linear(c:3)\n+__attribute__((noinline)) int\n+foo (int a, int b, int c)\n+{\n+  if (a < 30)\n+    return 5;\n+  return a + b + c;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+bar ()\n+{\n+  int i;\n+#pragma omp simd\n+  for (i = 0; i < N; ++i)\n+    array[i] = foo (i, 123, i * 3);\n+}\n+\n+__attribute__((noinline, noclone)) void\n+baz ()\n+{\n+  int i;\n+#pragma omp simd\n+  for (i = 0; i < N; ++i)\n+    array[i] = foo (i, array[i], i * 3);\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+  check_vect ();\n+  bar ();\n+  for (i = 0; i < N; i++)\n+    if (array[i] != (i < 30 ? 5 : i * 4 + 123))\n+      abort ();\n+  baz ();\n+  for (i = 0; i < N; i++)\n+    if (array[i] != (i < 30 ? 5 : i * 8 + 123))\n+      abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "3f29b52a8c3b3ba37fc5ca1c953db6b74d5e6c8f", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-10.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-10.c?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -0,0 +1,83 @@\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+/* { dg-additional-sources vect-simd-clone-10a.c } */\n+\n+#include \"tree-vect.h\"\n+\n+#ifndef N\n+#define N 1024\n+#endif\n+\n+int a[N], b[N];\n+long int c[N];\n+unsigned char d[N];\n+\n+#include \"vect-simd-clone-10.h\"\n+\n+__attribute__((noinline)) void\n+fn1 (void)\n+{\n+  int i;\n+  #pragma omp simd\n+  for (i = 0; i < N; i++)\n+    a[i] = foo (c[i], a[i], b[i]) + 6;\n+  #pragma omp simd\n+  for (i = 0; i < N; i++)\n+    c[i] = bar (a[i], b[i], c[i]) * 2;\n+}\n+\n+__attribute__((noinline)) void\n+fn2 (void)\n+{\n+  int i;\n+  #pragma omp simd\n+  for (i = 0; i < N; i++)\n+    {\n+      a[i] = foo (c[i], a[i], b[i]) + 6;\n+      d[i]++;\n+    }\n+  #pragma omp simd\n+  for (i = 0; i < N; i++)\n+    {\n+      c[i] = bar (a[i], b[i], c[i]) * 2;\n+      d[i] /= 2;\n+    }\n+}\n+\n+__attribute__((noinline)) void\n+fn3 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    {\n+      a[i] = i * 2;\n+      b[i] = 17 + (i % 37);\n+      c[i] = (i & 63);\n+      d[i] = 16 + i;\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+  check_vect ();\n+  fn3 ();\n+  fn1 ();\n+  for (i = 0; i < N; i++)\n+    if (a[i] != i * 2 + 23 + (i % 37) + (i & 63)\n+\t|| b[i] != 17 + (i % 37)\n+\t|| c[i] != i * 4 + 80 + 4 * (i % 37) + 4 * (i & 63))\n+      abort ();\n+  fn3 ();\n+  fn2 ();\n+  for (i = 0; i < N; i++)\n+    if (a[i] != i * 2 + 23 + (i % 37) + (i & 63)\n+\t|| b[i] != 17 + (i % 37)\n+\t|| c[i] != i * 4 + 80 + 4 * (i % 37) + 4 * (i & 63)\n+\t|| d[i] != ((unsigned char) (17 + i)) / 2)\n+      abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "ac3b81f8616291575ef77c6903879f4948cfa67c", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-10.h", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-10.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-10.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-10.h?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -0,0 +1,4 @@\n+#pragma omp declare simd notinbranch\n+extern int foo (long int a, int b, int c);\n+#pragma omp declare simd notinbranch\n+extern long int bar (int a, int b, long int c);"}, {"sha": "cd42e7c8bc89c5ad760bf731b1b57d2c11813254", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-10a.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-10a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-10a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-10a.c?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+\n+#include \"vect-simd-clone-10.h\"\n+\n+#pragma omp declare simd notinbranch\n+extern int\n+foo (long int a, int b, int c)\n+{\n+  return a + b + c;\n+}\n+\n+#pragma omp declare simd notinbranch\n+extern long int\n+bar (int a, int b, long int c)\n+{\n+  return a + b + c;\n+}"}, {"sha": "4cccf852d0e4f19a1098331d77876f0e1518f315", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-11.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-11.c?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -0,0 +1,66 @@\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+#include \"tree-vect.h\"\n+\n+#ifndef N\n+#define N 1024\n+#endif\n+\n+int a[N] __attribute__((aligned (32)));\n+\n+#pragma omp declare simd linear(a) linear(b:3) linear(c:6) notinbranch\n+__attribute__((noinline)) int\n+foo (int a, int b, int c)\n+{\n+  return a ^ (b * 512) ^ (c * 512 * 512);\n+}\n+\n+__attribute__((noinline, noclone)) void\n+bar (int *d)\n+{\n+  int i, j, k;\n+  for (i = 0, j = 0, k = 0; i < N / 2; i++, j++, k += 3)\n+    d[i] = foo (j, i * 3, 2 * k + 2);\n+}\n+\n+#if 0\n+__attribute__((noinline, noclone)) void\n+baz (int *d)\n+{\n+  long int i, j, k;\n+  for (i = 0, j = 0, k = 0; i < N / 2;\n+       i = (int) i + 1, j = (int) j + 1, k = (int) k + 3)\n+    d[i] = foo (j, i * 3, 2 * k + 2);\n+}\n+#endif\n+\n+int\n+main ()\n+{\n+  int i;\n+  check_vect ();\n+  if (sizeof (int) * __CHAR_BIT__ < 32)\n+    return 0;\n+  bar (a + 7);\n+  for (i = 0; i < N / 2; i++)\n+    if (a[i + 7] != (i ^ (i * 3 * 512) ^ (((i * 6) + 2) * 512 * 512)))\n+      abort ();\n+  bar (a);\n+  for (i = 0; i < N / 2; i++)\n+    if (a[i] != (i ^ (i * 3 * 512) ^ (((i * 6) + 2) * 512 * 512)))\n+      abort ();\n+#if 0\n+  baz (a + 7);\n+  for (i = 0; i < N / 2; i++)\n+    if (a[i + 7] != (i ^ (i * 3 * 512) ^ (((i * 6) + 2) * 512 * 512)))\n+      abort ();\n+  baz (a);\n+  for (i = 0; i < N / 2; i++)\n+    if (a[i] != (i ^ (i * 3 * 512) ^ (((i * 6) + 2) * 512 * 512)))\n+      abort ();\n+#endif\n+  return 0;\n+}\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "4447607ef518a84f68abe51f63ad9a382812d5c6", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-2.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-2.c?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+#include \"tree-vect.h\"\n+\n+#ifndef N\n+#define N 1024\n+#endif\n+\n+int array[N] __attribute__((aligned (32)));\n+\n+#pragma omp declare simd simdlen(4) notinbranch aligned(a:16) uniform(a) linear(b)\n+#pragma omp declare simd simdlen(4) notinbranch aligned(a:32) uniform(a) linear(b)\n+#pragma omp declare simd simdlen(8) notinbranch aligned(a:16) uniform(a) linear(b)\n+#pragma omp declare simd simdlen(8) notinbranch aligned(a:32) uniform(a) linear(b)\n+__attribute__((noinline)) void\n+foo (int *a, int b, int c)\n+{\n+  a[b] = c;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+bar ()\n+{\n+  int i;\n+#pragma omp simd\n+  for (i = 0; i < N; ++i)\n+    foo (array, i, i * array[i]);\n+}\n+\n+__attribute__((noinline, noclone)) void\n+baz ()\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    array[i] = 5 * (i & 7);\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+  check_vect ();\n+  baz ();\n+  bar ();\n+  for (i = 0; i < N; i++)\n+    if (array[i] != 5 * (i & 7) * i)\n+      abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "222d88e3016f06cb2b854c611978b5f5d7c0c30e", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-3.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-3.c?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+#include \"tree-vect.h\"\n+\n+#ifndef N\n+#define N 1024\n+#endif\n+\n+int d[N], e[N];\n+\n+#pragma omp declare simd simdlen(4) notinbranch uniform(b) linear(c:3)\n+__attribute__((noinline)) int\n+foo (int a, int b, int c)\n+{\n+  if (a < 30)\n+    return 5;\n+  return a + b + c;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+bar ()\n+{\n+  int i;\n+#pragma omp simd\n+  for (i = 0; i < N; ++i)\n+    {\n+      d[i] = foo (i, 123, i * 3);\n+      e[i] = e[i] + i;\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+  check_vect ();\n+  bar ();\n+  for (i = 0; i < N; i++)\n+    if (d[i] != (i < 30 ? 5 : i * 4 + 123) || e[i] != i)\n+      abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "5b0a93a53d7cc1c42e67571bb221caf942e1aa54", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-4.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-4.c?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+#include \"tree-vect.h\"\n+\n+#ifndef N\n+#define N 1024\n+#endif\n+\n+float d[N];\n+int e[N];\n+unsigned short f[N];\n+\n+#pragma omp declare simd simdlen(8) notinbranch uniform(b)\n+__attribute__((noinline)) float\n+foo (float a, float b, float c)\n+{\n+  if (a < 30)\n+    return 5.0f;\n+  return a + b + c;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+bar ()\n+{\n+  int i;\n+#pragma omp simd\n+  for (i = 0; i < N; ++i)\n+    {\n+      d[i] = foo (i, 123, i * 3);\n+      e[i] = e[i] * 3;\n+      f[i] = f[i] + 1;\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+  check_vect ();\n+  bar ();\n+  for (i = 0; i < N; i++)\n+    if (d[i] != (i < 30 ? 5.0f : i * 4 + 123.0f) || e[i] || f[i] != 1)\n+      abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "fd1d5ffd322837671f5037c912dda2a89682be34", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-5.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-5.c?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+#include \"tree-vect.h\"\n+\n+#ifndef N\n+#define N 1024\n+#endif\n+\n+int d[N], e[N];\n+\n+#pragma omp declare simd simdlen(4) notinbranch uniform(b) linear(c:3)\n+__attribute__((noinline)) long long int\n+foo (int a, int b, int c)\n+{\n+  return a + b + c;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+bar ()\n+{\n+  int i;\n+#pragma omp simd\n+  for (i = 0; i < N; ++i)\n+    {\n+      d[i] = foo (i, 123, i * 3);\n+      e[i] = e[i] + i;\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+  check_vect ();\n+  bar ();\n+  for (i = 0; i < N; i++)\n+    if (d[i] != i * 4 + 123 || e[i] != i)\n+      abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "5e5641476c5338b9ea6ce7564b932ec3118468e8", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-6.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-6.c?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -0,0 +1,74 @@\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+#include \"tree-vect.h\"\n+\n+#ifndef N\n+#define N 1024\n+#endif\n+\n+int a[N];\n+long long int b[N];\n+short c[N];\n+\n+#pragma omp declare simd\n+#pragma omp declare simd uniform(b) linear(c:3)\n+__attribute__((noinline)) short\n+foo (int a, long long int b, short c)\n+{\n+  return a + b + c;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+bar (int x)\n+{\n+  int i;\n+  if (x == 0)\n+    {\n+    #pragma omp simd\n+      for (i = 0; i < N; i++)\n+\tc[i] = foo (a[i], b[i], c[i]);\n+    }\n+  else\n+    {\n+    #pragma omp simd\n+      for (i = 0; i < N; i++)\n+\tc[i] = foo (a[i], x, i * 3);\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+baz (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    {\n+      a[i] = 2 * i;\n+      b[i] = -7 * i + 6;\n+      c[i] = (i & 31) << 4;\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+  check_vect ();\n+  baz ();\n+  bar (0);\n+  for (i = 0; i < N; i++)\n+    if (a[i] != 2 * i || b[i] != 6 - 7 * i\n+\t|| c[i] != 6 - 5 * i + ((i & 31) << 4))\n+      abort ();\n+    else\n+      a[i] = c[i];\n+  bar (17);\n+  for (i = 0; i < N; i++)\n+    if (a[i] != 6 - 5 * i + ((i & 31) << 4)\n+\t|| b[i] != 6 - 7 * i\n+\t|| c[i] != 23 - 2 * i + ((i & 31) << 4))\n+      abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "24856eaa41a08bd07993d43bb2a97640350f1aad", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-7.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-7.c?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -0,0 +1,74 @@\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+#include \"tree-vect.h\"\n+\n+#ifndef N\n+#define N 1024\n+#endif\n+\n+int a[N];\n+long long int b[N];\n+short c[N];\n+\n+#pragma omp declare simd\n+#pragma omp declare simd uniform(b) linear(c:3)\n+__attribute__((noinline)) short\n+foo (int a, long long int b, int c)\n+{\n+  return a + b + c;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+bar (int x)\n+{\n+  int i;\n+  if (x == 0)\n+    {\n+    #pragma omp simd\n+      for (i = 0; i < N; i++)\n+\tc[i] = foo (a[i], b[i], c[i]);\n+    }\n+  else\n+    {\n+    #pragma omp simd\n+      for (i = 0; i < N; i++)\n+\tc[i] = foo (a[i], x, i * 3);\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+baz (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    {\n+      a[i] = 2 * i;\n+      b[i] = -7 * i + 6;\n+      c[i] = (i & 31) << 4;\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+  check_vect ();\n+  baz ();\n+  bar (0);\n+  for (i = 0; i < N; i++)\n+    if (a[i] != 2 * i || b[i] != 6 - 7 * i\n+\t|| c[i] != 6 - 5 * i + ((i & 31) << 4))\n+      abort ();\n+    else\n+      a[i] = c[i];\n+  bar (17);\n+  for (i = 0; i < N; i++)\n+    if (a[i] != 6 - 5 * i + ((i & 31) << 4)\n+\t|| b[i] != 6 - 7 * i\n+\t|| c[i] != 23 - 2 * i + ((i & 31) << 4))\n+      abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "19c25c9db490c57e4d8f4003cdbbec60d4b1d42d", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-8.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-8.c?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -0,0 +1,94 @@\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+#include \"tree-vect.h\"\n+\n+#ifndef N\n+#define N 1024\n+#endif\n+\n+int a[N], b[N];\n+long int c[N];\n+unsigned char d[N];\n+\n+#pragma omp declare simd simdlen(8) notinbranch\n+__attribute__((noinline)) int\n+foo (long int a, int b, int c)\n+{\n+  return a + b + c;\n+}\n+\n+#pragma omp declare simd simdlen(8) notinbranch\n+__attribute__((noinline)) long int\n+bar (int a, int b, long int c)\n+{\n+  return a + b + c;\n+}\n+\n+__attribute__((noinline)) void\n+fn1 (void)\n+{\n+  int i;\n+  #pragma omp simd\n+  for (i = 0; i < N; i++)\n+    a[i] = foo (c[i], a[i], b[i]) + 6;\n+  #pragma omp simd\n+  for (i = 0; i < N; i++)\n+    c[i] = bar (a[i], b[i], c[i]) * 2;\n+}\n+\n+__attribute__((noinline)) void\n+fn2 (void)\n+{\n+  int i;\n+  #pragma omp simd\n+  for (i = 0; i < N; i++)\n+    {\n+      a[i] = foo (c[i], a[i], b[i]) + 6;\n+      d[i]++;\n+    }\n+  #pragma omp simd\n+  for (i = 0; i < N; i++)\n+    {\n+      c[i] = bar (a[i], b[i], c[i]) * 2;\n+      d[i] /= 2;\n+    }\n+}\n+\n+__attribute__((noinline)) void\n+fn3 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    {\n+      a[i] = i * 2;\n+      b[i] = 17 + (i % 37);\n+      c[i] = (i & 63);\n+      d[i] = 16 + i;\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+  check_vect ();\n+  fn3 ();\n+  fn1 ();\n+  for (i = 0; i < N; i++)\n+    if (a[i] != i * 2 + 23 + (i % 37) + (i & 63)\n+\t|| b[i] != 17 + (i % 37)\n+\t|| c[i] != i * 4 + 80 + 4 * (i % 37) + 4 * (i & 63))\n+      abort ();\n+  fn3 ();\n+  fn2 ();\n+  for (i = 0; i < N; i++)\n+    if (a[i] != i * 2 + 23 + (i % 37) + (i & 63)\n+\t|| b[i] != 17 + (i % 37)\n+\t|| c[i] != i * 4 + 80 + 4 * (i % 37) + 4 * (i & 63)\n+\t|| d[i] != ((unsigned char) (17 + i)) / 2)\n+      abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "95156b90f011b213b778fba240dea6d691c1841c", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-clone-9.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-clone-9.c?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -0,0 +1,94 @@\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+#include \"tree-vect.h\"\n+\n+#ifndef N\n+#define N 1024\n+#endif\n+\n+int a[N], b[N];\n+long int c[N];\n+unsigned char d[N];\n+\n+#pragma omp declare simd notinbranch\n+__attribute__((noinline)) static int\n+foo (long int a, int b, int c)\n+{\n+  return a + b + c;\n+}\n+\n+#pragma omp declare simd notinbranch\n+__attribute__((noinline)) static long int\n+bar (int a, int b, long int c)\n+{\n+  return a + b + c;\n+}\n+\n+__attribute__((noinline)) void\n+fn1 (void)\n+{\n+  int i;\n+  #pragma omp simd\n+  for (i = 0; i < N; i++)\n+    a[i] = foo (c[i], a[i], b[i]) + 6;\n+  #pragma omp simd\n+  for (i = 0; i < N; i++)\n+    c[i] = bar (a[i], b[i], c[i]) * 2;\n+}\n+\n+__attribute__((noinline)) void\n+fn2 (void)\n+{\n+  int i;\n+  #pragma omp simd\n+  for (i = 0; i < N; i++)\n+    {\n+      a[i] = foo (c[i], a[i], b[i]) + 6;\n+      d[i]++;\n+    }\n+  #pragma omp simd\n+  for (i = 0; i < N; i++)\n+    {\n+      c[i] = bar (a[i], b[i], c[i]) * 2;\n+      d[i] /= 2;\n+    }\n+}\n+\n+__attribute__((noinline)) void\n+fn3 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    {\n+      a[i] = i * 2;\n+      b[i] = 17 + (i % 37);\n+      c[i] = (i & 63);\n+      d[i] = 16 + i;\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+  check_vect ();\n+  fn3 ();\n+  fn1 ();\n+  for (i = 0; i < N; i++)\n+    if (a[i] != i * 2 + 23 + (i % 37) + (i & 63)\n+\t|| b[i] != 17 + (i % 37)\n+\t|| c[i] != i * 4 + 80 + 4 * (i % 37) + 4 * (i & 63))\n+      abort ();\n+  fn3 ();\n+  fn2 ();\n+  for (i = 0; i < N; i++)\n+    if (a[i] != i * 2 + 23 + (i % 37) + (i & 63)\n+\t|| b[i] != 17 + (i % 37)\n+\t|| c[i] != i * 4 + 80 + 4 * (i % 37) + 4 * (i & 63)\n+\t|| d[i] != ((unsigned char) (17 + i)) / 2)\n+      abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "e2750e0de7e94bd58b3508f5ee81cd544afc8d3d", "filename": "gcc/tree-core.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -903,6 +903,9 @@ struct GTY(()) tree_base {\n        CALL_ALLOCA_FOR_VAR_P in\n            CALL_EXPR\n \n+       OMP_CLAUSE_LINEAR_VARIABLE_STRIDE in\n+\t   OMP_CLAUSE_LINEAR\n+\n    side_effects_flag:\n \n        TREE_SIDE_EFFECTS in"}, {"sha": "4d570b19fc810f71fec1130ca6bc50d519dfc317", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -472,6 +472,7 @@ extern ipa_opt_pass_d *make_pass_ipa_reference (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_pure_const (gcc::context *ctxt);\n extern simple_ipa_opt_pass *make_pass_ipa_pta (gcc::context *ctxt);\n extern simple_ipa_opt_pass *make_pass_ipa_tm (gcc::context *ctxt);\n+extern simple_ipa_opt_pass *make_pass_omp_simd_clone (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_profile (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_cdtor_merge (gcc::context *ctxt);\n "}, {"sha": "a61f2a1a8685336f3a5455ddfab4111230ce076f", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 56, "deletions": 4, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -53,6 +53,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-scalar-evolution.h\"\n #include \"tree-vectorizer.h\"\n #include \"diagnostic-core.h\"\n+#include \"cgraph.h\"\n /* Need to include rtl.h, expr.h, etc. for optabs.  */\n #include \"expr.h\"\n #include \"optabs.h\"\n@@ -3167,10 +3168,11 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \n   if (loop_vinfo)\n     {\n+      basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n+\n       loop = LOOP_VINFO_LOOP (loop_vinfo);\n-      if (!find_loop_nest (loop, &LOOP_VINFO_LOOP_NEST (loop_vinfo))\n-\t  || find_data_references_in_loop\n-\t       (loop, &LOOP_VINFO_DATAREFS (loop_vinfo)))\n+      datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n+      if (!find_loop_nest (loop, &LOOP_VINFO_LOOP_NEST (loop_vinfo)))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -3179,7 +3181,57 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t  return false;\n \t}\n \n-      datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n+      for (i = 0; i < loop->num_nodes; i++)\n+\t{\n+\t  gimple_stmt_iterator gsi;\n+\n+\t  for (gsi = gsi_start_bb (bbs[i]); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t    {\n+\t      gimple stmt = gsi_stmt (gsi);\n+\t      if (!find_data_references_in_stmt (loop, stmt, &datarefs))\n+\t\t{\n+\t\t  if (is_gimple_call (stmt) && loop->safelen)\n+\t\t    {\n+\t\t      tree fndecl = gimple_call_fndecl (stmt), op;\n+\t\t      if (fndecl != NULL_TREE)\n+\t\t\t{\n+\t\t\t  struct cgraph_node *node = cgraph_get_node (fndecl);\n+\t\t\t  if (node != NULL && node->simd_clones != NULL)\n+\t\t\t    {\n+\t\t\t      unsigned int j, n = gimple_call_num_args (stmt);\n+\t\t\t      for (j = 0; j < n; j++)\n+\t\t\t\t{\n+\t\t\t\t  op = gimple_call_arg (stmt, j);\n+\t\t\t\t  if (DECL_P (op)\n+\t\t\t\t      || (REFERENCE_CLASS_P (op)\n+\t\t\t\t\t  && get_base_address (op)))\n+\t\t\t\t    break;\n+\t\t\t\t}\n+\t\t\t      op = gimple_call_lhs (stmt);\n+\t\t\t      /* Ignore #pragma omp declare simd functions\n+\t\t\t\t if they don't have data references in the\n+\t\t\t\t call stmt itself.  */\n+\t\t\t      if (j == n\n+\t\t\t\t  && !(op\n+\t\t\t\t       && (DECL_P (op)\n+\t\t\t\t\t   || (REFERENCE_CLASS_P (op)\n+\t\t\t\t\t       && get_base_address (op)))))\n+\t\t\t\tcontinue;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  LOOP_VINFO_DATAREFS (loop_vinfo) = datarefs;\n+\t\t  if (dump_enabled_p ())\n+\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t     \"not vectorized: loop contains function \"\n+\t\t\t\t     \"calls or data references that cannot \"\n+\t\t\t\t     \"be analyzed\\n\");\n+\t\t  return false;\n+\t\t}\n+\t    }\n+\t}\n+\n+      LOOP_VINFO_DATAREFS (loop_vinfo) = datarefs;\n     }\n   else\n     {"}, {"sha": "42a78de326521f83aba92a8fd747f5108beca7c6", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -376,6 +376,19 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \n \t  if (gimple_get_lhs (stmt) == NULL_TREE)\n \t    {\n+\t      if (is_gimple_call (stmt))\n+\t\t{\n+\t\t  /* Ignore calls with no lhs.  These must be calls to\n+\t\t     #pragma omp simd functions, and what vectorization factor\n+\t\t     it really needs can't be determined until\n+\t\t     vectorizable_simd_clone_call.  */\n+\t\t  if (!analyze_pattern_stmt && gsi_end_p (pattern_def_si))\n+\t\t    {\n+\t\t      pattern_def_seq = NULL;\n+\t\t      gsi_next (&si);\n+\t\t    }\n+\t\t  continue;\n+\t\t}\n \t      if (dump_enabled_p ())\n \t\t{\n \t          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5699,7 +5712,6 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   int vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   bool grouped_store;\n   bool slp_scheduled = false;\n-  unsigned int nunits;\n   gimple stmt, pattern_stmt;\n   gimple_seq pattern_def_seq = NULL;\n   gimple_stmt_iterator pattern_def_si = gsi_none ();\n@@ -5957,16 +5969,18 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t\ttransform_pattern_stmt = false;\n             }\n \n-\t  gcc_assert (STMT_VINFO_VECTYPE (stmt_info));\n-\t  nunits = (unsigned int) TYPE_VECTOR_SUBPARTS (\n-                                               STMT_VINFO_VECTYPE (stmt_info));\n-\t  if (!STMT_SLP_TYPE (stmt_info)\n-\t      && nunits != (unsigned int) vectorization_factor\n-              && dump_enabled_p ())\n-\t    /* For SLP VF is set according to unrolling factor, and not to\n-\t       vector size, hence for SLP this print is not valid.  */\n-            dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t     \"multiple-types.\\n\");\n+\t  if (STMT_VINFO_VECTYPE (stmt_info))\n+\t    {\n+\t      unsigned int nunits\n+\t\t= (unsigned int)\n+\t\t  TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (stmt_info));\n+\t      if (!STMT_SLP_TYPE (stmt_info)\n+\t\t  && nunits != (unsigned int) vectorization_factor\n+\t\t  && dump_enabled_p ())\n+\t\t  /* For SLP VF is set according to unrolling factor, and not\n+\t\t     to vector size, hence for SLP this print is not valid.  */\n+\t\tdump_printf_loc (MSG_NOTE, vect_location, \"multiple-types.\\n\");\n+\t    }\n \n \t  /* SLP. Schedule all the SLP instances when the first SLP stmt is\n \t     reached.  */"}, {"sha": "ff7b59aa52d34cbd01a1505311f727dd22b4601c", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 617, "deletions": 10, "changes": 627, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -46,12 +46,15 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssanames.h\"\n #include \"tree-ssa-loop-manip.h\"\n #include \"cfgloop.h\"\n+#include \"tree-ssa-loop.h\"\n+#include \"tree-scalar-evolution.h\"\n #include \"expr.h\"\n #include \"recog.h\"\t\t/* FIXME: for insn_data */\n #include \"optabs.h\"\n #include \"diagnostic-core.h\"\n #include \"tree-vectorizer.h\"\n #include \"dumpfile.h\"\n+#include \"cgraph.h\"\n \n /* For lang_hooks.types.type_for_mode.  */\n #include \"langhooks.h\"\n@@ -1735,11 +1738,11 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   if (!is_gimple_call (stmt))\n     return false;\n \n-  if (TREE_CODE (gimple_call_lhs (stmt)) != SSA_NAME)\n+  if (gimple_call_lhs (stmt) == NULL_TREE\n+      || TREE_CODE (gimple_call_lhs (stmt)) != SSA_NAME)\n     return false;\n \n-  if (stmt_can_throw_internal (stmt))\n-    return false;\n+  gcc_checking_assert (!stmt_can_throw_internal (stmt));\n \n   vectype_out = STMT_VINFO_VECTYPE (stmt_info);\n \n@@ -2082,10 +2085,6 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \n   vargs.release ();\n \n-  /* Update the exception handling table with the vector stmt if necessary.  */\n-  if (maybe_clean_or_replace_eh_stmt (stmt, *vec_stmt))\n-    gimple_purge_dead_eh_edges (gimple_bb (stmt));\n-\n   /* The call in STMT might prevent it from being removed in dce.\n      We however cannot remove it here, due to the way the ssa name\n      it defines is mapped to the new definition.  So just replace\n@@ -2109,6 +2108,605 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n }\n \n \n+struct simd_call_arg_info\n+{\n+  tree vectype;\n+  tree op;\n+  enum vect_def_type dt;\n+  HOST_WIDE_INT linear_step;\n+  unsigned int align;\n+};\n+\n+/* Function vectorizable_simd_clone_call.\n+\n+   Check if STMT performs a function call that can be vectorized\n+   by calling a simd clone of the function.\n+   If VEC_STMT is also passed, vectorize the STMT: create a vectorized\n+   stmt to replace it, put it in VEC_STMT, and insert it at BSI.\n+   Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n+\n+static bool\n+vectorizable_simd_clone_call (gimple stmt, gimple_stmt_iterator *gsi,\n+\t\t\t      gimple *vec_stmt, slp_tree slp_node)\n+{\n+  tree vec_dest;\n+  tree scalar_dest;\n+  tree op, type;\n+  tree vec_oprnd0 = NULL_TREE;\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt), prev_stmt_info;\n+  tree vectype;\n+  unsigned int nunits;\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n+  struct loop *loop = loop_vinfo ? LOOP_VINFO_LOOP (loop_vinfo) : NULL;\n+  tree fndecl, new_temp, def;\n+  gimple def_stmt;\n+  gimple new_stmt = NULL;\n+  int ncopies, j;\n+  vec<simd_call_arg_info> arginfo = vNULL;\n+  vec<tree> vargs = vNULL;\n+  size_t i, nargs;\n+  tree lhs, rtype, ratype;\n+  vec<constructor_elt, va_gc> *ret_ctor_elts;\n+\n+  /* Is STMT a vectorizable call?   */\n+  if (!is_gimple_call (stmt))\n+    return false;\n+\n+  fndecl = gimple_call_fndecl (stmt);\n+  if (fndecl == NULL_TREE)\n+    return false;\n+\n+  struct cgraph_node *node = cgraph_get_node (fndecl);\n+  if (node == NULL || node->simd_clones == NULL)\n+    return false;\n+\n+  if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n+    return false;\n+\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def)\n+    return false;\n+\n+  if (gimple_call_lhs (stmt)\n+      && TREE_CODE (gimple_call_lhs (stmt)) != SSA_NAME)\n+    return false;\n+\n+  gcc_checking_assert (!stmt_can_throw_internal (stmt));\n+\n+  vectype = STMT_VINFO_VECTYPE (stmt_info);\n+\n+  if (loop_vinfo && nested_in_vect_loop_p (loop, stmt))\n+    return false;\n+\n+  /* FORNOW */\n+  if (slp_node || PURE_SLP_STMT (stmt_info))\n+    return false;\n+\n+  /* Process function arguments.  */\n+  nargs = gimple_call_num_args (stmt);\n+\n+  /* Bail out if the function has zero arguments.  */\n+  if (nargs == 0)\n+    return false;\n+\n+  arginfo.create (nargs);\n+\n+  for (i = 0; i < nargs; i++)\n+    {\n+      simd_call_arg_info thisarginfo;\n+      affine_iv iv;\n+\n+      thisarginfo.linear_step = 0;\n+      thisarginfo.align = 0;\n+      thisarginfo.op = NULL_TREE;\n+\n+      op = gimple_call_arg (stmt, i);\n+      if (!vect_is_simple_use_1 (op, stmt, loop_vinfo, bb_vinfo,\n+\t\t\t\t &def_stmt, &def, &thisarginfo.dt,\n+\t\t\t\t &thisarginfo.vectype)\n+\t  || thisarginfo.dt == vect_uninitialized_def)\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"use not simple.\\n\");\n+\t  arginfo.release ();\n+\t  return false;\n+\t}\n+\n+      if (thisarginfo.dt == vect_constant_def\n+\t  || thisarginfo.dt == vect_external_def)\n+\tgcc_assert (thisarginfo.vectype == NULL_TREE);\n+      else\n+\tgcc_assert (thisarginfo.vectype != NULL_TREE);\n+\n+      if (thisarginfo.dt != vect_constant_def\n+\t  && thisarginfo.dt != vect_external_def\n+\t  && loop_vinfo\n+\t  && TREE_CODE (op) == SSA_NAME\n+\t  && simple_iv (loop, loop_containing_stmt (stmt), op, &iv, false)\n+\t  && tree_fits_shwi_p (iv.step))\n+\t{\n+\t  thisarginfo.linear_step = tree_to_shwi (iv.step);\n+\t  thisarginfo.op = iv.base;\n+\t}\n+      else if ((thisarginfo.dt == vect_constant_def\n+\t\t|| thisarginfo.dt == vect_external_def)\n+\t       && POINTER_TYPE_P (TREE_TYPE (op)))\n+\tthisarginfo.align = get_pointer_alignment (op) / BITS_PER_UNIT;\n+\n+      arginfo.quick_push (thisarginfo);\n+    }\n+\n+  unsigned int badness = 0;\n+  struct cgraph_node *bestn = NULL;\n+  if (STMT_VINFO_SIMD_CLONE_FNDECL (stmt_info))\n+    bestn = cgraph_get_node (STMT_VINFO_SIMD_CLONE_FNDECL (stmt_info));\n+  else\n+    for (struct cgraph_node *n = node->simd_clones; n != NULL;\n+\t n = n->simdclone->next_clone)\n+      {\n+\tunsigned int this_badness = 0;\n+\tif (n->simdclone->simdlen\n+\t    > (unsigned) LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n+\t    || n->simdclone->nargs != nargs)\n+\t  continue;\n+\tif (n->simdclone->simdlen\n+\t    < (unsigned) LOOP_VINFO_VECT_FACTOR (loop_vinfo))\n+\t  this_badness += (exact_log2 (LOOP_VINFO_VECT_FACTOR (loop_vinfo))\n+\t\t\t   - exact_log2 (n->simdclone->simdlen)) * 1024;\n+\tif (n->simdclone->inbranch)\n+\t  this_badness += 2048;\n+\tint target_badness = targetm.simd_clone.usable (n);\n+\tif (target_badness < 0)\n+\t  continue;\n+\tthis_badness += target_badness * 512;\n+\t/* FORNOW: Have to add code to add the mask argument.  */\n+\tif (n->simdclone->inbranch)\n+\t  continue;\n+\tfor (i = 0; i < nargs; i++)\n+\t  {\n+\t    switch (n->simdclone->args[i].arg_type)\n+\t      {\n+\t      case SIMD_CLONE_ARG_TYPE_VECTOR:\n+\t\tif (!useless_type_conversion_p\n+\t\t\t(n->simdclone->args[i].orig_type,\n+\t\t\t TREE_TYPE (gimple_call_arg (stmt, i))))\n+\t\t  i = -1;\n+\t\telse if (arginfo[i].dt == vect_constant_def\n+\t\t\t || arginfo[i].dt == vect_external_def\n+\t\t\t || arginfo[i].linear_step)\n+\t\t  this_badness += 64;\n+\t\tbreak;\n+\t      case SIMD_CLONE_ARG_TYPE_UNIFORM:\n+\t\tif (arginfo[i].dt != vect_constant_def\n+\t\t    && arginfo[i].dt != vect_external_def)\n+\t\t  i = -1;\n+\t\tbreak;\n+\t      case SIMD_CLONE_ARG_TYPE_LINEAR_CONSTANT_STEP:\n+\t\tif (arginfo[i].dt == vect_constant_def\n+\t\t    || arginfo[i].dt == vect_external_def\n+\t\t    || (arginfo[i].linear_step\n+\t\t\t!= n->simdclone->args[i].linear_step))\n+\t\t  i = -1;\n+\t\tbreak;\n+\t      case SIMD_CLONE_ARG_TYPE_LINEAR_VARIABLE_STEP:\n+\t\t/* FORNOW */\n+\t\ti = -1;\n+\t\tbreak;\n+\t      case SIMD_CLONE_ARG_TYPE_MASK:\n+\t\tgcc_unreachable ();\n+\t      }\n+\t    if (i == (size_t) -1)\n+\t      break;\n+\t    if (n->simdclone->args[i].alignment > arginfo[i].align)\n+\t      {\n+\t\ti = -1;\n+\t\tbreak;\n+\t      }\n+\t    if (arginfo[i].align)\n+\t      this_badness += (exact_log2 (arginfo[i].align)\n+\t\t\t       - exact_log2 (n->simdclone->args[i].alignment));\n+\t  }\n+\tif (i == (size_t) -1)\n+\t  continue;\n+\tif (bestn == NULL || this_badness < badness)\n+\t  {\n+\t    bestn = n;\n+\t    badness = this_badness;\n+\t  }\n+      }\n+\n+  if (bestn == NULL)\n+    {\n+      arginfo.release ();\n+      return false;\n+    }\n+\n+  for (i = 0; i < nargs; i++)\n+    if ((arginfo[i].dt == vect_constant_def\n+\t || arginfo[i].dt == vect_external_def)\n+\t&& bestn->simdclone->args[i].arg_type == SIMD_CLONE_ARG_TYPE_VECTOR)\n+      {\n+\targinfo[i].vectype\n+\t  = get_vectype_for_scalar_type (TREE_TYPE (gimple_call_arg (stmt,\n+\t\t\t\t\t\t\t\t     i)));\n+\tif (arginfo[i].vectype == NULL\n+\t    || (TYPE_VECTOR_SUBPARTS (arginfo[i].vectype)\n+\t\t> bestn->simdclone->simdlen))\n+\t  {\n+\t    arginfo.release ();\n+\t    return false;\n+\t  }\n+      }\n+\n+  fndecl = bestn->decl;\n+  nunits = bestn->simdclone->simdlen;\n+  ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n+\n+  /* If the function isn't const, only allow it in simd loops where user\n+     has asserted that at least nunits consecutive iterations can be\n+     performed using SIMD instructions.  */\n+  if ((loop == NULL || (unsigned) loop->safelen < nunits)\n+      && gimple_vuse (stmt))\n+    {\n+      arginfo.release ();\n+      return false;\n+    }\n+\n+  /* Sanity check: make sure that at least one copy of the vectorized stmt\n+     needs to be generated.  */\n+  gcc_assert (ncopies >= 1);\n+\n+  if (!vec_stmt) /* transformation not required.  */\n+    {\n+      STMT_VINFO_SIMD_CLONE_FNDECL (stmt_info) = bestn->decl;\n+      STMT_VINFO_TYPE (stmt_info) = call_simd_clone_vec_info_type;\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"=== vectorizable_simd_clone_call ===\\n\");\n+/*      vect_model_simple_cost (stmt_info, ncopies, dt, NULL, NULL); */\n+      arginfo.release ();\n+      return true;\n+    }\n+\n+  /** Transform.  **/\n+\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location, \"transform call.\\n\");\n+\n+  /* Handle def.  */\n+  scalar_dest = gimple_call_lhs (stmt);\n+  vec_dest = NULL_TREE;\n+  rtype = NULL_TREE;\n+  ratype = NULL_TREE;\n+  if (scalar_dest)\n+    {\n+      vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+      rtype = TREE_TYPE (TREE_TYPE (fndecl));\n+      if (TREE_CODE (rtype) == ARRAY_TYPE)\n+\t{\n+\t  ratype = rtype;\n+\t  rtype = TREE_TYPE (ratype);\n+\t}\n+    }\n+\n+  prev_stmt_info = NULL;\n+  for (j = 0; j < ncopies; ++j)\n+    {\n+      /* Build argument list for the vectorized call.  */\n+      if (j == 0)\n+\tvargs.create (nargs);\n+      else\n+\tvargs.truncate (0);\n+\n+      for (i = 0; i < nargs; i++)\n+\t{\n+\t  unsigned int k, l, m, o;\n+\t  tree atype;\n+\t  op = gimple_call_arg (stmt, i);\n+\t  switch (bestn->simdclone->args[i].arg_type)\n+\t    {\n+\t    case SIMD_CLONE_ARG_TYPE_VECTOR:\n+\t      atype = bestn->simdclone->args[i].vector_type;\n+\t      o = nunits / TYPE_VECTOR_SUBPARTS (atype);\n+\t      for (m = j * o; m < (j + 1) * o; m++)\n+\t\t{\n+\t\t  if (TYPE_VECTOR_SUBPARTS (atype)\n+\t\t      < TYPE_VECTOR_SUBPARTS (arginfo[i].vectype))\n+\t\t    {\n+\t\t      unsigned int prec = GET_MODE_BITSIZE (TYPE_MODE (atype));\n+\t\t      k = (TYPE_VECTOR_SUBPARTS (arginfo[i].vectype)\n+\t\t\t   / TYPE_VECTOR_SUBPARTS (atype));\n+\t\t      gcc_assert ((k & (k - 1)) == 0);\n+\t\t      if (m == 0)\n+\t\t\tvec_oprnd0\n+\t\t\t  = vect_get_vec_def_for_operand (op, stmt, NULL);\n+\t\t      else\n+\t\t\t{\n+\t\t\t  vec_oprnd0 = arginfo[i].op;\n+\t\t\t  if ((m & (k - 1)) == 0)\n+\t\t\t    vec_oprnd0\n+\t\t\t      = vect_get_vec_def_for_stmt_copy (arginfo[i].dt,\n+\t\t\t\t\t\t\t\tvec_oprnd0);\n+\t\t\t}\n+\t\t      arginfo[i].op = vec_oprnd0;\n+\t\t      vec_oprnd0\n+\t\t\t= build3 (BIT_FIELD_REF, atype, vec_oprnd0,\n+\t\t\t\t  size_int (prec),\n+\t\t\t\t  bitsize_int ((m & (k - 1)) * prec));\n+\t\t      new_stmt\n+\t\t\t= gimple_build_assign (make_ssa_name (atype, NULL),\n+\t\t\t\t\t       vec_oprnd0);\n+\t\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t\t      vargs.safe_push (gimple_assign_lhs (new_stmt));\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      k = (TYPE_VECTOR_SUBPARTS (atype)\n+\t\t\t   / TYPE_VECTOR_SUBPARTS (arginfo[i].vectype));\n+\t\t      gcc_assert ((k & (k - 1)) == 0);\n+\t\t      vec<constructor_elt, va_gc> *ctor_elts;\n+\t\t      if (k != 1)\n+\t\t\tvec_alloc (ctor_elts, k);\n+\t\t      else\n+\t\t\tctor_elts = NULL;\n+\t\t      for (l = 0; l < k; l++)\n+\t\t\t{\n+\t\t\t  if (m == 0 && l == 0)\n+\t\t\t    vec_oprnd0\n+\t\t\t      = vect_get_vec_def_for_operand (op, stmt, NULL);\n+\t\t\t  else\n+\t\t\t    vec_oprnd0\n+\t\t\t      = vect_get_vec_def_for_stmt_copy (arginfo[i].dt,\n+\t\t\t\t\t\t\t\targinfo[i].op);\n+\t\t\t  arginfo[i].op = vec_oprnd0;\n+\t\t\t  if (k == 1)\n+\t\t\t    break;\n+\t\t\t  CONSTRUCTOR_APPEND_ELT (ctor_elts, NULL_TREE,\n+\t\t\t\t\t\t  vec_oprnd0);\n+\t\t\t}\n+\t\t      if (k == 1)\n+\t\t\tvargs.safe_push (vec_oprnd0);\n+\t\t      else\n+\t\t\t{\n+\t\t\t  vec_oprnd0 = build_constructor (atype, ctor_elts);\n+\t\t\t  new_stmt\n+\t\t\t    = gimple_build_assign (make_ssa_name (atype, NULL),\n+\t\t\t\t\t\t   vec_oprnd0);\n+\t\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t\t\t  vargs.safe_push (gimple_assign_lhs (new_stmt));\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t      break;\n+\t    case SIMD_CLONE_ARG_TYPE_UNIFORM:\n+\t      vargs.safe_push (op);\n+\t      break;\n+\t    case SIMD_CLONE_ARG_TYPE_LINEAR_CONSTANT_STEP:\n+\t      if (j == 0)\n+\t\t{\n+\t\t  gimple_seq stmts;\n+\t\t  arginfo[i].op\n+\t\t    = force_gimple_operand (arginfo[i].op, &stmts, true,\n+\t\t\t\t\t    NULL_TREE);\n+\t\t  if (stmts != NULL)\n+\t\t    {\n+\t\t      basic_block new_bb;\n+\t\t      edge pe = loop_preheader_edge (loop);\n+\t\t      new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n+\t\t      gcc_assert (!new_bb);\n+\t\t    }\n+\t\t  tree phi_res = copy_ssa_name (op, NULL);\n+\t\t  gimple new_phi = create_phi_node (phi_res, loop->header);\n+\t\t  set_vinfo_for_stmt (new_phi,\n+\t\t\t\t      new_stmt_vec_info (new_phi, loop_vinfo,\n+\t\t\t\t\t\t\t NULL));\n+\t\t  add_phi_arg (new_phi, arginfo[i].op,\n+\t\t\t       loop_preheader_edge (loop), UNKNOWN_LOCATION);\n+\t\t  enum tree_code code\n+\t\t    = POINTER_TYPE_P (TREE_TYPE (op))\n+\t\t      ? POINTER_PLUS_EXPR : PLUS_EXPR;\n+\t\t  tree type = POINTER_TYPE_P (TREE_TYPE (op))\n+\t\t\t      ? sizetype : TREE_TYPE (op);\n+\t\t  double_int cst\n+\t\t    = double_int::from_shwi\n+\t\t\t(bestn->simdclone->args[i].linear_step);\n+\t\t  cst *= double_int::from_uhwi (ncopies * nunits);\n+\t\t  tree tcst = double_int_to_tree (type, cst);\n+\t\t  tree phi_arg = copy_ssa_name (op, NULL);\n+\t\t  new_stmt = gimple_build_assign_with_ops (code, phi_arg,\n+\t\t\t\t\t\t\t   phi_res, tcst);\n+\t\t  gimple_stmt_iterator si = gsi_after_labels (loop->header);\n+\t\t  gsi_insert_after (&si, new_stmt, GSI_NEW_STMT);\n+\t\t  set_vinfo_for_stmt (new_stmt,\n+\t\t\t\t      new_stmt_vec_info (new_stmt, loop_vinfo,\n+\t\t\t\t\t\t\t NULL));\n+\t\t  add_phi_arg (new_phi, phi_arg, loop_latch_edge (loop),\n+\t\t\t       UNKNOWN_LOCATION);\n+\t\t  arginfo[i].op = phi_res;\n+\t\t  vargs.safe_push (phi_res);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  enum tree_code code\n+\t\t    = POINTER_TYPE_P (TREE_TYPE (op))\n+\t\t      ? POINTER_PLUS_EXPR : PLUS_EXPR;\n+\t\t  tree type = POINTER_TYPE_P (TREE_TYPE (op))\n+\t\t\t      ? sizetype : TREE_TYPE (op);\n+\t\t  double_int cst\n+\t\t    = double_int::from_shwi\n+\t\t\t(bestn->simdclone->args[i].linear_step);\n+\t\t  cst *= double_int::from_uhwi (j * nunits);\n+\t\t  tree tcst = double_int_to_tree (type, cst);\n+\t\t  new_temp = make_ssa_name (TREE_TYPE (op), NULL);\n+\t\t  new_stmt\n+\t\t    = gimple_build_assign_with_ops (code, new_temp,\n+\t\t\t\t\t\t    arginfo[i].op, tcst);\n+\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t\t  vargs.safe_push (new_temp);\n+\t\t}\n+\t      break;\n+\t    case SIMD_CLONE_ARG_TYPE_LINEAR_VARIABLE_STEP:\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t}\n+\n+      new_stmt = gimple_build_call_vec (fndecl, vargs);\n+      if (vec_dest)\n+\t{\n+\t  gcc_assert (ratype || TYPE_VECTOR_SUBPARTS (rtype) == nunits);\n+\t  if (ratype)\n+\t    new_temp = create_tmp_var (ratype, NULL);\n+\t  else if (TYPE_VECTOR_SUBPARTS (vectype)\n+\t\t   == TYPE_VECTOR_SUBPARTS (rtype))\n+\t    new_temp = make_ssa_name (vec_dest, new_stmt);\n+\t  else\n+\t    new_temp = make_ssa_name (rtype, new_stmt);\n+\t  gimple_call_set_lhs (new_stmt, new_temp);\n+\t}\n+      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\n+      if (vec_dest)\n+\t{\n+\t  if (TYPE_VECTOR_SUBPARTS (vectype) < nunits)\n+\t    {\n+\t      unsigned int k, l;\n+\t      unsigned int prec = GET_MODE_BITSIZE (TYPE_MODE (vectype));\n+\t      k = nunits / TYPE_VECTOR_SUBPARTS (vectype);\n+\t      gcc_assert ((k & (k - 1)) == 0);\n+\t      for (l = 0; l < k; l++)\n+\t\t{\n+\t\t  tree t;\n+\t\t  if (ratype)\n+\t\t    {\n+\t\t      t = build_fold_addr_expr (new_temp);\n+\t\t      t = build2 (MEM_REF, vectype, t,\n+\t\t\t\t  build_int_cst (TREE_TYPE (t),\n+\t\t\t\t\t\t l * prec / BITS_PER_UNIT));\n+\t\t    }\n+\t\t  else\n+\t\t    t = build3 (BIT_FIELD_REF, vectype, new_temp,\n+\t\t\t\tsize_int (prec), bitsize_int (l * prec));\n+\t\t  new_stmt\n+\t\t    = gimple_build_assign (make_ssa_name (vectype, NULL), t);\n+\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t\t  if (j == 0 && l == 0)\n+\t\t    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+\t\t  else\n+\t\t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+\n+\t\t  prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\t\t}\n+\n+\t      if (ratype)\n+\t\t{\n+\t\t  tree clobber = build_constructor (ratype, NULL);\n+\t\t  TREE_THIS_VOLATILE (clobber) = 1;\n+\t\t  new_stmt = gimple_build_assign (new_temp, clobber);\n+\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t\t}\n+\t      continue;\n+\t    }\n+\t  else if (TYPE_VECTOR_SUBPARTS (vectype) > nunits)\n+\t    {\n+\t      unsigned int k = (TYPE_VECTOR_SUBPARTS (vectype)\n+\t\t\t\t/ TYPE_VECTOR_SUBPARTS (rtype));\n+\t      gcc_assert ((k & (k - 1)) == 0);\n+\t      if ((j & (k - 1)) == 0)\n+\t\tvec_alloc (ret_ctor_elts, k);\n+\t      if (ratype)\n+\t\t{\n+\t\t  unsigned int m, o = nunits / TYPE_VECTOR_SUBPARTS (rtype);\n+\t\t  for (m = 0; m < o; m++)\n+\t\t    {\n+\t\t      tree tem = build4 (ARRAY_REF, rtype, new_temp,\n+\t\t\t\t\t size_int (m), NULL_TREE, NULL_TREE);\n+\t\t      new_stmt\n+\t\t\t= gimple_build_assign (make_ssa_name (rtype, NULL),\n+\t\t\t\t\t       tem);\n+\t\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t\t      CONSTRUCTOR_APPEND_ELT (ret_ctor_elts, NULL_TREE,\n+\t\t\t\t\t      gimple_assign_lhs (new_stmt));\n+\t\t    }\n+\t\t  tree clobber = build_constructor (ratype, NULL);\n+\t\t  TREE_THIS_VOLATILE (clobber) = 1;\n+\t\t  new_stmt = gimple_build_assign (new_temp, clobber);\n+\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t\t}\n+\t      else\n+\t\tCONSTRUCTOR_APPEND_ELT (ret_ctor_elts, NULL_TREE, new_temp);\n+\t      if ((j & (k - 1)) != k - 1)\n+\t\tcontinue;\n+\t      vec_oprnd0 = build_constructor (vectype, ret_ctor_elts);\n+\t      new_stmt\n+\t\t= gimple_build_assign (make_ssa_name (vec_dest, NULL),\n+\t\t\t\t       vec_oprnd0);\n+\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\n+\t      if ((unsigned) j == k - 1)\n+\t\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+\t      else\n+\t\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+\n+\t      prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\t      continue;\n+\t    }\n+\t  else if (ratype)\n+\t    {\n+\t      tree t = build_fold_addr_expr (new_temp);\n+\t      t = build2 (MEM_REF, vectype, t,\n+\t\t\t  build_int_cst (TREE_TYPE (t), 0));\n+\t      new_stmt\n+\t\t= gimple_build_assign (make_ssa_name (vec_dest, NULL), t);\n+\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t      tree clobber = build_constructor (ratype, NULL);\n+\t      TREE_THIS_VOLATILE (clobber) = 1;\n+\t      vect_finish_stmt_generation (stmt,\n+\t\t\t\t\t   gimple_build_assign (new_temp,\n+\t\t\t\t\t\t\t\tclobber), gsi);\n+\t    }\n+\t}\n+\n+      if (j == 0)\n+\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+      else\n+\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+\n+      prev_stmt_info = vinfo_for_stmt (new_stmt);\n+    }\n+\n+  vargs.release ();\n+\n+  /* The call in STMT might prevent it from being removed in dce.\n+     We however cannot remove it here, due to the way the ssa name\n+     it defines is mapped to the new definition.  So just replace\n+     rhs of the statement with something harmless.  */\n+\n+  if (slp_node)\n+    return true;\n+\n+  if (scalar_dest)\n+    {\n+      type = TREE_TYPE (scalar_dest);\n+      if (is_pattern_stmt_p (stmt_info))\n+\tlhs = gimple_call_lhs (STMT_VINFO_RELATED_STMT (stmt_info));\n+      else\n+\tlhs = gimple_call_lhs (stmt);\n+      new_stmt = gimple_build_assign (lhs, build_zero_cst (type));\n+    }\n+  else\n+    new_stmt = gimple_build_nop ();\n+  set_vinfo_for_stmt (new_stmt, stmt_info);\n+  set_vinfo_for_stmt (stmt, NULL);\n+  STMT_VINFO_STMT (stmt_info) = new_stmt;\n+  gsi_replace (gsi, new_stmt, false);\n+  unlink_stmt_vdef (stmt);\n+\n+  return true;\n+}\n+\n+\n /* Function vect_gen_widened_results_half\n \n    Create a vector stmt whose code, type, number of arguments, and result\n@@ -5819,15 +6417,18 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n   if (STMT_VINFO_RELEVANT_P (stmt_info))\n     {\n       gcc_assert (!VECTOR_MODE_P (TYPE_MODE (gimple_expr_type (stmt))));\n-      gcc_assert (STMT_VINFO_VECTYPE (stmt_info));\n+      gcc_assert (STMT_VINFO_VECTYPE (stmt_info)\n+\t\t  || (is_gimple_call (stmt)\n+\t\t      && gimple_call_lhs (stmt) == NULL_TREE));\n       *need_to_vectorize = true;\n     }\n \n    ok = true;\n    if (!bb_vinfo\n        && (STMT_VINFO_RELEVANT_P (stmt_info)\n            || STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def))\n-      ok = (vectorizable_conversion (stmt, NULL, NULL, NULL)\n+      ok = (vectorizable_simd_clone_call (stmt, NULL, NULL, NULL)\n+\t    || vectorizable_conversion (stmt, NULL, NULL, NULL)\n             || vectorizable_shift (stmt, NULL, NULL, NULL)\n             || vectorizable_operation (stmt, NULL, NULL, NULL)\n             || vectorizable_assignment (stmt, NULL, NULL, NULL)\n@@ -5839,7 +6440,8 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n     else\n       {\n         if (bb_vinfo)\n-\t  ok = (vectorizable_conversion (stmt, NULL, NULL, node)\n+\t  ok = (vectorizable_simd_clone_call (stmt, NULL, NULL, node)\n+\t\t|| vectorizable_conversion (stmt, NULL, NULL, node)\n \t\t|| vectorizable_shift (stmt, NULL, NULL, node)\n                 || vectorizable_operation (stmt, NULL, NULL, node)\n                 || vectorizable_assignment (stmt, NULL, NULL, node)\n@@ -5967,6 +6569,11 @@ vect_transform_stmt (gimple stmt, gimple_stmt_iterator *gsi,\n       stmt = gsi_stmt (*gsi);\n       break;\n \n+    case call_simd_clone_vec_info_type:\n+      done = vectorizable_simd_clone_call (stmt, gsi, &vec_stmt, slp_node);\n+      stmt = gsi_stmt (*gsi);\n+      break;\n+\n     case reduc_vec_info_type:\n       done = vectorizable_reduction (stmt, gsi, &vec_stmt, slp_node);\n       gcc_assert (done);"}, {"sha": "39d7d41c65e0f713b99f08731a81d1ab9d772b74", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -443,6 +443,7 @@ enum stmt_vec_info_type {\n   shift_vec_info_type,\n   op_vec_info_type,\n   call_vec_info_type,\n+  call_simd_clone_vec_info_type,\n   assignment_vec_info_type,\n   condition_vec_info_type,\n   reduc_vec_info_type,\n@@ -565,6 +566,9 @@ typedef struct _stmt_vec_info {\n      of this stmt.  */\n   vec<dr_p> same_align_refs;\n \n+  /* Selected SIMD clone's function decl.  */\n+  tree simd_clone_fndecl;\n+\n   /* Classify the def of this stmt.  */\n   enum vect_def_type def_type;\n \n@@ -633,6 +637,7 @@ typedef struct _stmt_vec_info {\n #define STMT_VINFO_RELATED_STMT(S)         (S)->related_stmt\n #define STMT_VINFO_PATTERN_DEF_SEQ(S)      (S)->pattern_def_seq\n #define STMT_VINFO_SAME_ALIGN_REFS(S)      (S)->same_align_refs\n+#define STMT_VINFO_SIMD_CLONE_FNDECL(S)\t   (S)->simd_clone_fndecl\n #define STMT_VINFO_DEF_TYPE(S)             (S)->def_type\n #define STMT_VINFO_GROUP_FIRST_ELEMENT(S)  (S)->first_element\n #define STMT_VINFO_GROUP_NEXT_ELEMENT(S)   (S)->next_element"}, {"sha": "88c8d56bf3ab91ad8d7e25d14766c6f1f4f5d91b", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=0136f8f03a651185cb7a8a032f13b2cd0e6a7bdc", "patch": "@@ -1344,6 +1344,10 @@ extern void protected_set_expr_location (tree, location_t);\n #define OMP_CLAUSE_LINEAR_NO_COPYOUT(NODE) \\\n   TREE_PRIVATE (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LINEAR))\n \n+/* True if a LINEAR clause has a stride that is variable.  */\n+#define OMP_CLAUSE_LINEAR_VARIABLE_STRIDE(NODE) \\\n+  TREE_PROTECTED (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LINEAR))\n+\n #define OMP_CLAUSE_LINEAR_STEP(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LINEAR), 1)\n "}]}