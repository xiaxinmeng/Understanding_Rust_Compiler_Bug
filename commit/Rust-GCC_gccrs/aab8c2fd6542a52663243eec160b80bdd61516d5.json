{"sha": "aab8c2fd6542a52663243eec160b80bdd61516d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFiOGMyZmQ2NTQyYTUyNjYzMjQzZWVjMTYwYjgwYmRkNjE1MTZkNQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-10-16T14:21:06Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-10-16T14:21:06Z"}, "message": "tree-vect-loop.c (vect_valid_reduction_input_p): Remove.\n\n2019-10-16  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-loop.c (vect_valid_reduction_input_p): Remove.\n\t(vect_is_simple_reduction): Delay checking to\n\tvectorizable_reduction and relax the checking.\n\t(vectorizable_reduction): Check we have a simple use.  Check\n\tfor bogus condition reductions.\n\t* tree-vect-stmts.c (vect_transform_stmt): Make sure we\n\tare looking at the last stmt in a pattern sequence when\n\tfilling in backedge PHI values.\n\n\t* gcc.dg/vect/vect-cond-reduc-3.c: New testcase.\n\t* gcc.dg/vect/vect-cond-reduc-4.c: Likewise.\n\nFrom-SVN: r277067", "tree": {"sha": "a02f519c98c98384942081ea85ded7d9a8fee137", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a02f519c98c98384942081ea85ded7d9a8fee137"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aab8c2fd6542a52663243eec160b80bdd61516d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aab8c2fd6542a52663243eec160b80bdd61516d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aab8c2fd6542a52663243eec160b80bdd61516d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aab8c2fd6542a52663243eec160b80bdd61516d5/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1624d351f14049bfe08bc2c86c63a9cccfb43ab8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1624d351f14049bfe08bc2c86c63a9cccfb43ab8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1624d351f14049bfe08bc2c86c63a9cccfb43ab8"}], "stats": {"total": 234, "additions": 138, "deletions": 96}, "files": [{"sha": "a6047ec1008cafe9f9addcad7cd0f48e8bf0f86f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab8c2fd6542a52663243eec160b80bdd61516d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab8c2fd6542a52663243eec160b80bdd61516d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aab8c2fd6542a52663243eec160b80bdd61516d5", "patch": "@@ -1,3 +1,14 @@\n+2019-10-16  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vect-loop.c (vect_valid_reduction_input_p): Remove.\n+\t(vect_is_simple_reduction): Delay checking to\n+\tvectorizable_reduction and relax the checking.\n+\t(vectorizable_reduction): Check we have a simple use.  Check\n+\tfor bogus condition reductions.\n+\t* tree-vect-stmts.c (vect_transform_stmt): Make sure we\n+\tare looking at the last stmt in a pattern sequence when\n+\tfilling in backedge PHI values.\n+\n 2019-10-16  Peter Bergner <bergner@linux.ibm.com>\n \t    Jiufu Guo  <guojiufu@linux.ibm.com>\n "}, {"sha": "cd43ef621066785ec33b5b5c4052390b780b2f8a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab8c2fd6542a52663243eec160b80bdd61516d5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab8c2fd6542a52663243eec160b80bdd61516d5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=aab8c2fd6542a52663243eec160b80bdd61516d5", "patch": "@@ -1,3 +1,8 @@\n+2019-10-16  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/vect/vect-cond-reduc-3.c: New testcase.\n+\t* gcc.dg/vect/vect-cond-reduc-4.c: Likewise.\n+\n 2019-10-16  Peter Bergner <bergner@linux.ibm.com>\n \t    Jiufu Guo  <guojiufu@linux.ibm.com>\n "}, {"sha": "a5b3849a8c35089e3e9b18f6bfffea4d483364a4", "filename": "gcc/testsuite/gcc.dg/vect/vect-cond-reduc-3.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab8c2fd6542a52663243eec160b80bdd61516d5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-reduc-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab8c2fd6542a52663243eec160b80bdd61516d5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-reduc-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-reduc-3.c?ref=aab8c2fd6542a52663243eec160b80bdd61516d5", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-require-effective-target vect_condition } */\n+/* { dg-require-effective-target vect_float } */\n+\n+#include \"tree-vect.h\"\n+\n+extern void abort (void) __attribute__ ((noreturn));\n+\n+#define N 27\n+\n+/* Condition reduction with different types.  */\n+\n+int\n+condition_reduction (float *a, float min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] < min_v)\n+      last = i;\n+\n+  return last;\n+}\n+\n+int\n+main (void)\n+{\n+  float a[N] = {\n+  11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\n+  1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\n+  21, 22, 23, 24, 25, 26, 27\n+  };\n+\n+  check_vect ();\n+\n+  int ret = condition_reduction (a, 10);\n+  if (ret != 18)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"optimizing condition reduction with FOLD_EXTRACT_LAST\" 4 \"vect\" { target vect_fold_extract_last } } } */\n+/* { dg-final { scan-tree-dump-times \"condition expression based on integer induction.\" 2 \"vect\" { target { ! vect_fold_extract_last } } } } */\n+"}, {"sha": "6b6d17fb93c7d3a4f8d589df6fb5a80900e56a78", "filename": "gcc/testsuite/gcc.dg/vect/vect-cond-reduc-4.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab8c2fd6542a52663243eec160b80bdd61516d5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-reduc-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab8c2fd6542a52663243eec160b80bdd61516d5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-reduc-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-reduc-4.c?ref=aab8c2fd6542a52663243eec160b80bdd61516d5", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-require-effective-target vect_condition } */\n+/* { dg-require-effective-target vect_double } */\n+\n+#include \"tree-vect.h\"\n+\n+extern void abort (void) __attribute__ ((noreturn));\n+\n+#define N 27\n+\n+/* Condition reduction with different types.  */\n+\n+int\n+condition_reduction (double *a, double min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] < min_v)\n+      last = i;\n+\n+  return last;\n+}\n+\n+int\n+main (void)\n+{\n+  double a[N] = {\n+  11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\n+  1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\n+  21, 22, 23, 24, 25, 26, 27\n+  };\n+\n+  check_vect ();\n+\n+  int ret = condition_reduction (a, 10);\n+  if (ret != 18)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"optimizing condition reduction with FOLD_EXTRACT_LAST\" 4 \"vect\" { target vect_fold_extract_last } } } */\n+/* { dg-final { scan-tree-dump-times \"condition expression based on integer induction.\" 2 \"vect\" { target { ! vect_fold_extract_last } } } } */\n+"}, {"sha": "0530d6643b46b8af306f1eae001682b189c46055", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 31, "deletions": 96, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab8c2fd6542a52663243eec160b80bdd61516d5/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab8c2fd6542a52663243eec160b80bdd61516d5/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=aab8c2fd6542a52663243eec160b80bdd61516d5", "patch": "@@ -2532,21 +2532,6 @@ report_vect_op (dump_flags_t msg_type, gimple *stmt, const char *msg)\n   dump_printf_loc (msg_type, vect_location, \"%s%G\", msg, stmt);\n }\n \n-/* DEF_STMT_INFO occurs in a loop that contains a potential reduction\n-   operation.  Return true if the results of DEF_STMT_INFO are something\n-   that can be accumulated by such a reduction.  */\n-\n-static bool\n-vect_valid_reduction_input_p (stmt_vec_info def_stmt_info)\n-{\n-  return (is_gimple_assign (def_stmt_info->stmt)\n-\t  || is_gimple_call (def_stmt_info->stmt)\n-\t  || STMT_VINFO_DEF_TYPE (def_stmt_info) == vect_induction_def\n-\t  || (gimple_code (def_stmt_info->stmt) == GIMPLE_PHI\n-\t      && STMT_VINFO_DEF_TYPE (def_stmt_info) == vect_internal_def\n-\t      && !is_loop_header_bb_p (gimple_bb (def_stmt_info->stmt))));\n-}\n-\n /* Return true if we need an in-order reduction for operation CODE\n    on type TYPE.  NEED_WRAPPING_INTEGRAL_OVERFLOW is true if integer\n    overflow must wrap.  */\n@@ -2748,13 +2733,7 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n \t\t\t  bool *double_reduc)\n {\n   gphi *phi = as_a <gphi *> (phi_info->stmt);\n-  class loop *loop = (gimple_bb (phi))->loop_father;\n-  class loop *vect_loop = LOOP_VINFO_LOOP (loop_info);\n-  bool nested_in_vect_loop = flow_loop_nested_p (vect_loop, loop);\n   gimple *phi_use_stmt = NULL;\n-  enum tree_code orig_code, code;\n-  tree op1, op2, op3 = NULL_TREE, op4 = NULL_TREE;\n-  tree type;\n   imm_use_iterator imm_iter;\n   use_operand_p use_p;\n \n@@ -2768,6 +2747,7 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n      can be constant.  See PR60382.  */\n   if (has_zero_uses (phi_name))\n     return NULL;\n+  class loop *loop = (gimple_bb (phi))->loop_father;\n   unsigned nphi_def_loop_uses = 0;\n   FOR_EACH_IMM_USE_FAST (use_p, imm_iter, phi_name)\n     {\n@@ -2802,6 +2782,8 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n       || !flow_bb_inside_loop_p (loop, gimple_bb (def_stmt_info->stmt)))\n     return NULL;\n \n+  bool nested_in_vect_loop\n+    = flow_loop_nested_p (LOOP_VINFO_LOOP (loop_info), loop);\n   unsigned nlatch_def_loop_uses = 0;\n   auto_vec<gphi *, 3> lcphis;\n   bool inner_loop_of_double_reduc = false;\n@@ -2849,8 +2831,7 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n      defined in the inner loop.  */\n   if (gphi *def_stmt = dyn_cast <gphi *> (def_stmt_info->stmt))\n     {\n-      op1 = PHI_ARG_DEF (def_stmt, 0);\n-\n+      tree op1 = PHI_ARG_DEF (def_stmt, 0);\n       if (gimple_phi_num_args (def_stmt) != 1\n           || TREE_CODE (op1) != SSA_NAME)\n         {\n@@ -2890,7 +2871,7 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n \t\t\t def_stmt_info->stmt);\n       return NULL;\n     }\n-  code = orig_code = gimple_assign_rhs_code (def_stmt);\n+  enum tree_code code = gimple_assign_rhs_code (def_stmt);\n \n   /* We can handle \"res -= x[i]\", which is non-associative by\n      simply rewriting this into \"res += -x[i]\".  Avoid changing\n@@ -2899,26 +2880,11 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n   if (code == MINUS_EXPR && gimple_assign_rhs2 (def_stmt) != phi_name)\n     code = PLUS_EXPR;\n \n+  tree op1, op2;\n   if (code == COND_EXPR)\n     {\n       if (! nested_in_vect_loop)\n \tSTMT_VINFO_REDUC_TYPE (phi_info) = COND_REDUCTION;\n-\n-      op3 = gimple_assign_rhs1 (def_stmt);\n-      if (COMPARISON_CLASS_P (op3))\n-        {\n-          op4 = TREE_OPERAND (op3, 1);\n-          op3 = TREE_OPERAND (op3, 0);\n-        }\n-      if (op3 == phi_name || op4 == phi_name)\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    report_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n-\t\t\t    \"reduction: condition depends on previous\"\n-\t\t\t    \" iteration: \");\n-\t  return NULL;\n-\t}\n-\n       op1 = gimple_assign_rhs2 (def_stmt);\n       op2 = gimple_assign_rhs3 (def_stmt);\n     }\n@@ -2951,40 +2917,14 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n       return NULL;\n     }\n \n-  type = TREE_TYPE (gimple_assign_lhs (def_stmt));\n-  if ((TREE_CODE (op1) == SSA_NAME\n-       && !types_compatible_p (type,TREE_TYPE (op1)))\n-      || (TREE_CODE (op2) == SSA_NAME\n-          && !types_compatible_p (type, TREE_TYPE (op2)))\n-      || (op3 && TREE_CODE (op3) == SSA_NAME\n-          && !types_compatible_p (type, TREE_TYPE (op3)))\n-      || (op4 && TREE_CODE (op4) == SSA_NAME\n-          && !types_compatible_p (type, TREE_TYPE (op4))))\n-    {\n-      if (dump_enabled_p ())\n-        {\n-          dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t   \"reduction: multiple types: operation type: \"\n-\t\t\t   \"%T, operands types: %T,%T\",\n-\t\t\t   type,  TREE_TYPE (op1), TREE_TYPE (op2));\n-          if (op3)\n-\t    dump_printf (MSG_NOTE, \",%T\", TREE_TYPE (op3));\n-\n-          if (op4)\n-\t    dump_printf (MSG_NOTE, \",%T\", TREE_TYPE (op4));\n-          dump_printf (MSG_NOTE, \"\\n\");\n-        }\n-\n-      return NULL;\n-    }\n-\n   /* Check whether it's ok to change the order of the computation.\n      Generally, when vectorizing a reduction we change the order of the\n      computation.  This may change the behavior of the program in some\n      cases, so we need to check that this is ok.  One exception is when\n      vectorizing an outer-loop: the inner-loop is executed sequentially,\n      and therefore vectorizing reductions in the inner-loop during\n      outer-loop vectorization is safe.  */\n+  tree type = TREE_TYPE (gimple_assign_lhs (def_stmt));\n   if (STMT_VINFO_REDUC_TYPE (phi_info) == TREE_CODE_REDUCTION\n       && needs_fold_left_reduction_p (type, code))\n     STMT_VINFO_REDUC_TYPE (phi_info) = FOLD_LEFT_REDUCTION;\n@@ -2993,46 +2933,28 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n      1) integer arithmetic and no trapv\n      2) floating point arithmetic, and special flags permit this optimization\n      3) nested cycle (i.e., outer loop vectorization).  */\n+\n+  /* Check for the simple case that one def is the reduction def,\n+     defined by the PHI node.  */\n   stmt_vec_info def1_info = loop_info->lookup_def (op1);\n   stmt_vec_info def2_info = loop_info->lookup_def (op2);\n-  if (code != COND_EXPR && !def1_info && !def2_info)\n-    {\n-      if (dump_enabled_p ())\n-\treport_vect_op (MSG_NOTE, def_stmt, \"reduction: no defs for operands: \");\n-      return NULL;\n-    }\n-\n-  /* Check that one def is the reduction def, defined by PHI,\n-     the other def is either defined in the loop (\"vect_internal_def\"),\n-     or it's an induction (defined by a loop-header phi-node).  */\n-\n-  if (def2_info\n-      && def2_info->stmt == phi\n-      && (code == COND_EXPR\n-\t  || !def1_info\n-\t  || !flow_bb_inside_loop_p (loop, gimple_bb (def1_info->stmt))\n-\t  || vect_valid_reduction_input_p (def1_info)))\n+  if (def2_info && def2_info->stmt == phi)\n     {\n       STMT_VINFO_REDUC_IDX (def_stmt_info) = 1 + (code == COND_EXPR ? 1 : 0);\n       if (dump_enabled_p ())\n \treport_vect_op (MSG_NOTE, def_stmt, \"detected reduction: \");\n       return def_stmt_info;\n     }\n-\n-  if (def1_info\n-      && def1_info->stmt == phi\n-      && (code == COND_EXPR\n-\t  || !def2_info\n-\t  || !flow_bb_inside_loop_p (loop, gimple_bb (def2_info->stmt))\n-\t  || vect_valid_reduction_input_p (def2_info)))\n+  else if (def1_info && def1_info->stmt == phi)\n     {\n       STMT_VINFO_REDUC_IDX (def_stmt_info) = 0 + (code == COND_EXPR ? 1 : 0);\n       if (dump_enabled_p ())\n \treport_vect_op (MSG_NOTE, def_stmt, \"detected reduction: \");\n       return def_stmt_info;\n     }\n \n-  /* Look for the expression computing latch_def from loop PHI result.  */\n+  /* Look for the expression computing latch_def from then loop PHI result\n+     in a way involving more than one stmt.  */\n   auto_vec<std::pair<ssa_op_iter, use_operand_p> > path;\n   if (check_reduction_path (vect_location, loop, phi, latch_def, code,\n \t\t\t    path))\n@@ -5716,7 +5638,6 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n   enum vect_def_type dt, cond_reduc_dt = vect_unknown_def_type;\n   stmt_vec_info cond_stmt_vinfo = NULL;\n   tree scalar_type;\n-  bool is_simple_use;\n   int i;\n   int ncopies;\n   bool single_defuse_cycle = false;\n@@ -5887,10 +5808,15 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n         continue;\n \n       stmt_vec_info def_stmt_info;\n-      is_simple_use = vect_is_simple_use (ops[i], loop_vinfo, &dts[i], &tem,\n-\t\t\t\t\t  &def_stmt_info);\n+      if (!vect_is_simple_use (ops[i], loop_vinfo, &dts[i], &tem,\n+\t\t\t       &def_stmt_info))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"use not simple.\\n\");\n+\t  return false;\n+\t}\n       dt = dts[i];\n-      gcc_assert (is_simple_use);\n       if (dt == vect_reduction_def\n \t  && ops[i] == reduc_def)\n \t{\n@@ -6000,6 +5926,15 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n \t  return false;\n \t}\n \n+      /* When the condition uses the reduction value in the condition, fail.  */\n+      if (reduc_index == 0)\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"condition depends on previous iteration\\n\");\n+\t  return false;\n+\t}\n+\n       if (direct_internal_fn_supported_p (IFN_FOLD_EXTRACT_LAST,\n \t\t\t\t\t  vectype_in, OPTIMIZE_FOR_SPEED))\n \t{"}, {"sha": "e7255fb76bc12b9e43046d2891ddbd511412dbae", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab8c2fd6542a52663243eec160b80bdd61516d5/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab8c2fd6542a52663243eec160b80bdd61516d5/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=aab8c2fd6542a52663243eec160b80bdd61516d5", "patch": "@@ -10901,6 +10901,7 @@ vect_transform_stmt (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   stmt_vec_info orig_stmt_info = vect_orig_stmt (stmt_info);\n   stmt_vec_info reduc_info;\n   if (STMT_VINFO_REDUC_DEF (orig_stmt_info)\n+      && vect_stmt_to_vectorize (orig_stmt_info) == stmt_info\n       && (reduc_info = info_for_reduction (orig_stmt_info))\n       && STMT_VINFO_REDUC_TYPE (reduc_info) != FOLD_LEFT_REDUCTION\n       && STMT_VINFO_REDUC_TYPE (reduc_info) != EXTRACT_LAST_REDUCTION)"}]}