{"sha": "e02f385ab580d77ae5ead2252c8cb90162cce03b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTAyZjM4NWFiNTgwZDc3YWU1ZWFkMjI1MmM4Y2I5MDE2MmNjZTAzYg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-25T19:18:28Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-25T19:18:28Z"}, "message": "(clear_units): Remove decl of unused variable UNIT.\n\n(actual_hazard_this_instance): Remove decl of unused variable I.\n(actual_hazard): Remove two block-scope decls of unused variable BEST.\n(sched_analyze_1): Remove decls of unused variables OFFSET and BIT.\n(sched_analyze): Remove decl of unused variable DEST.\n(sched_note_set): Remove decl of unused variable J.\n(create_reg_dead_note): Remove decl of unused variable BACKLINK.\n(new_sometimes_live): Remove decl of unused variable I.\n(schedule_block): Remove decls of unused variables LAST_NOTE and REGNO.\n(schedule_insns): Remove decls of unused variables I and INSNS.\n\nFrom-SVN: r6893", "tree": {"sha": "45c0d99fb196cd81823ec0fcdf240a439db8865f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45c0d99fb196cd81823ec0fcdf240a439db8865f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e02f385ab580d77ae5ead2252c8cb90162cce03b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e02f385ab580d77ae5ead2252c8cb90162cce03b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e02f385ab580d77ae5ead2252c8cb90162cce03b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e02f385ab580d77ae5ead2252c8cb90162cce03b/comments", "author": null, "committer": null, "parents": [{"sha": "d6924effb5224d4edb9bebc9f26453480b2d32c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6924effb5224d4edb9bebc9f26453480b2d32c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6924effb5224d4edb9bebc9f26453480b2d32c7"}], "stats": {"total": 19, "additions": 4, "deletions": 15}, "files": [{"sha": "1e22650fa9da1ae31d457ed8f7985f7954a59b64", "filename": "gcc/sched.c", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e02f385ab580d77ae5ead2252c8cb90162cce03b/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e02f385ab580d77ae5ead2252c8cb90162cce03b/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=e02f385ab580d77ae5ead2252c8cb90162cce03b", "patch": "@@ -1170,8 +1170,6 @@ static int unit_n_insns[FUNCTION_UNITS_SIZE];\n static void\n clear_units ()\n {\n-  int unit;\n-\n   bzero (unit_last_insn, sizeof (unit_last_insn));\n   bzero (unit_tick, sizeof (unit_tick));\n   bzero (unit_n_insns, sizeof (unit_n_insns));\n@@ -1202,7 +1200,6 @@ actual_hazard_this_instance (unit, instance, insn, clock, cost)\n      int unit, instance, clock, cost;\n      rtx insn;\n {\n-  int i;\n   int tick = unit_tick[instance];\n \n   if (tick - clock > cost)\n@@ -1278,7 +1275,6 @@ actual_hazard (unit, insn, clock, cost)\n     {\n       /* Find the instance of the function unit with the minimum hazard.  */\n       int instance = unit;\n-      int best = instance;\n       int best_cost = actual_hazard_this_instance (unit, instance, insn,\n \t\t\t\t\t\t   clock, cost);\n       int this_cost;\n@@ -1293,7 +1289,6 @@ actual_hazard (unit, insn, clock, cost)\n \t\t\t\t\t\t       clock, cost);\n \t      if (this_cost < best_cost)\n \t\t{\n-\t\t  best = instance;\n \t\t  best_cost = this_cost;\n \t\t  if (this_cost <= cost)\n \t\t    break;\n@@ -1684,7 +1679,7 @@ sched_analyze_1 (x, insn)\n \n   if (GET_CODE (dest) == REG)\n     {\n-      register int offset, bit, i;\n+      register int i;\n \n       regno = REGNO (dest);\n \n@@ -2142,7 +2137,6 @@ sched_analyze (head, tail)\n \t}\n       else if (GET_CODE (insn) == CALL_INSN)\n \t{\n-\t  rtx dest = 0;\n \t  rtx x;\n \t  register int i;\n \n@@ -2237,7 +2231,7 @@ sched_note_set (b, x, death)\n      rtx x;\n      int death;\n {\n-  register int regno, j;\n+  register int regno;\n   register rtx reg = SET_DEST (x);\n   int subreg_p = 0;\n \n@@ -2664,7 +2658,7 @@ static void\n create_reg_dead_note (reg, insn)\n      rtx reg, insn;\n {\n-  rtx link, backlink;\n+  rtx link;\n \t\t\n   /* The number of registers killed after scheduling must be the same as the\n      number of registers killed before scheduling.  The number of REG_DEAD\n@@ -2998,7 +2992,6 @@ new_sometimes_live (regs_sometimes_live, offset, bit, sometimes_max)\n {\n   register struct sometimes *p;\n   register int regno = offset * REGSET_ELT_BITS + bit;\n-  int i;\n \n   /* There should never be a register greater than max_regno here.  If there\n      is, it means that a define_split has created a new pseudo reg.  This\n@@ -3048,7 +3041,6 @@ schedule_block (b, file)\n      FILE *file;\n {\n   rtx insn, last;\n-  rtx last_note = 0;\n   rtx *ready, link;\n   int i, j, n_ready = 0, new_ready, n_insns = 0;\n   int sched_n_insns = 0;\n@@ -3461,8 +3453,6 @@ schedule_block (b, file)\n \t  /* Need to know what registers this insn kills.  */\n \t  for (prev = 0, link = REG_NOTES (insn); link; link = next)\n \t    {\n-\t      int regno;\n-\n \t      next = XEXP (link, 1);\n \t      if ((REG_NOTE_KIND (link) == REG_DEAD\n \t\t   || REG_NOTE_KIND (link) == REG_UNUSED)\n@@ -4574,7 +4564,7 @@ schedule_insns (dump_file)\n      FILE *dump_file;\n {\n   int max_uid = MAX_INSNS_PER_SPLIT * (get_max_uid () + 1);\n-  int i, b;\n+  int b;\n   rtx insn;\n \n   /* Taking care of this degenerate case makes the rest of\n@@ -4684,7 +4674,6 @@ schedule_insns (dump_file)\n   for (b = 0; b < n_basic_blocks; b++)\n     {\n       rtx insn, next;\n-      rtx insns;\n \n       note_list = 0;\n "}]}