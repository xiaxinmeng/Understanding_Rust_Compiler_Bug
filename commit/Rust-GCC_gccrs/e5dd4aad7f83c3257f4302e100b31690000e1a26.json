{"sha": "e5dd4aad7f83c3257f4302e100b31690000e1a26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTVkZDRhYWQ3ZjgzYzMyNTdmNDMwMmUxMDBiMzE2OTAwMDBlMWEyNg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2001-02-26T11:01:44Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2001-02-26T11:01:44Z"}, "message": "except.c (call_eh_info): Cleanup generation of cp_eh_info struct.\n\n\t* except.c (call_eh_info): Cleanup generation of cp_eh_info struct.\n\n\t* decl.c (mark_inlined_fns): Prototype.\n\nFrom-SVN: r40065", "tree": {"sha": "142477486cd3b6b7f5f8fe3ce3c4e8951c25c741", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/142477486cd3b6b7f5f8fe3ce3c4e8951c25c741"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5dd4aad7f83c3257f4302e100b31690000e1a26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5dd4aad7f83c3257f4302e100b31690000e1a26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5dd4aad7f83c3257f4302e100b31690000e1a26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5dd4aad7f83c3257f4302e100b31690000e1a26/comments", "author": null, "committer": null, "parents": [{"sha": "7787480c2a6e70abf2654864980a7ffce446fea8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7787480c2a6e70abf2654864980a7ffce446fea8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7787480c2a6e70abf2654864980a7ffce446fea8"}], "stats": {"total": 106, "additions": 68, "deletions": 38}, "files": [{"sha": "ede5dc12f500cc55063c8d37945902fc853595cd", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5dd4aad7f83c3257f4302e100b31690000e1a26/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5dd4aad7f83c3257f4302e100b31690000e1a26/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e5dd4aad7f83c3257f4302e100b31690000e1a26", "patch": "@@ -1,3 +1,9 @@\n+2001-02-26  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* except.c (call_eh_info): Cleanup generation of cp_eh_info struct.\n+\t\n+\t* decl.c (mark_inlined_fns): Prototype.\n+\n 2001-02-22  Mark Mitchell  <mark@codesourcery.com>\n \n \t* spew.c (yylex): Correct handling of friends."}, {"sha": "941f95a81b1963297711d70fe973912017cbccbf", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5dd4aad7f83c3257f4302e100b31690000e1a26/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5dd4aad7f83c3257f4302e100b31690000e1a26/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=e5dd4aad7f83c3257f4302e100b31690000e1a26", "patch": "@@ -130,6 +130,7 @@ static void mark_binding_level PARAMS ((void *));\n static void mark_named_label_lists PARAMS ((void *, void *));\n static void mark_cp_function_context PARAMS ((struct function *));\n static void mark_saved_scope PARAMS ((void *));\n+static void mark_inlined_fns PARAMS ((struct lang_decl_inlined_fns *));\n static void mark_lang_function PARAMS ((struct cp_language_function *));\n static void save_function_data PARAMS ((tree));\n static void check_function_type PARAMS ((tree, tree));"}, {"sha": "9d3a6a5f7bdeeba9eed772bcba8a4cbea86c74af", "filename": "gcc/cp/except.c", "status": "modified", "additions": 61, "deletions": 38, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5dd4aad7f83c3257f4302e100b31690000e1a26/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5dd4aad7f83c3257f4302e100b31690000e1a26/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=e5dd4aad7f83c3257f4302e100b31690000e1a26", "patch": "@@ -169,62 +169,85 @@ call_eh_info ()\n     fn = IDENTIFIER_GLOBAL_VALUE (fn);\n   else\n     {\n-      tree t1, t, fields[7];\n-\n-      /* Declare cp_eh_info * __start_cp_handler (void),\n-\t as defined in exception.cc. */\n-\n-      /* struct cp_eh_info.  This must match exception.cc.  Note that this\n-\t type is not pushed anywhere.  */\n-      t1= make_aggr_type (RECORD_TYPE);\n-      fields[0] = build_decl (FIELD_DECL, \n-                    get_identifier (\"handler_label\"), ptr_type_node);\n-      fields[1] = build_decl (FIELD_DECL, \n-                    get_identifier (\"dynamic_handler_chain\"), ptr_type_node);\n-      fields[2] = build_decl (FIELD_DECL, \n-                    get_identifier (\"info\"), ptr_type_node);\n-      fields[3] = build_decl (FIELD_DECL, \n-                    get_identifier (\"table_index\"), ptr_type_node);\n-      /* N.B.: The fourth field LEN is expected to be\n-\t the number of fields - 1, not the total number of fields.  */\n-      finish_builtin_type (t1, \"eh_context\", fields, 3, ptr_type_node);\n-      t1 = build_pointer_type (t1);\n-\n-      t1= make_aggr_type (RECORD_TYPE);\n+      tree eh_info_type;\n+      tree cleanup_fn_type;\n+      tree matcher_fn_type;\n+      tree cp_eh_info_type;\n+      tree exception_desc_type;\n+      tree fields[8];\n+\n+      eh_info_type = make_aggr_type (RECORD_TYPE);\n+      exception_desc_type = make_aggr_type (RECORD_TYPE);\n+      \n+      /* void * (*) (__eh_info *, void *, exception_descriptor *); */\n+      matcher_fn_type = tree_cons\n+          (NULL_TREE, build_pointer_type (eh_info_type), tree_cons\n+            (NULL_TREE, ptr_type_node, tree_cons\n+              (NULL_TREE, build_pointer_type (exception_desc_type),\n+                void_list_node)));\n+      matcher_fn_type = build_function_type (ptr_type_node, matcher_fn_type);\n+      matcher_fn_type = build_pointer_type (matcher_fn_type);\n+\n+      /* void (*) (void *); */\n+      cleanup_fn_type = tree_cons\n+          (NULL_TREE, ptr_type_node, void_list_node);\n+      cleanup_fn_type = build_function_type (void_type_node, cleanup_fn_type);\n+      cleanup_fn_type = build_pointer_type (cleanup_fn_type);\n+\n+      /* eh-common.h\n+        struct __eh_info \n+        {\n+          __eh_matcher match_function;\n+          short language;\n+          short version;\n+        };  */\n       fields[0] = build_decl (FIELD_DECL, \n-                    get_identifier (\"match_function\"), ptr_type_node);\n+                    get_identifier (\"match_function\"), matcher_fn_type);\n       fields[1] = build_decl (FIELD_DECL, \n                     get_identifier (\"language\"), short_integer_type_node);\n       fields[2] = build_decl (FIELD_DECL, \n                     get_identifier (\"version\"), short_integer_type_node);\n       /* N.B.: The fourth field LEN is expected to be\n \t the number of fields - 1, not the total number of fields.  */\n-      finish_builtin_type (t1, \"__eh_info\", fields, 2, ptr_type_node);\n-      t = make_aggr_type (RECORD_TYPE);\n-      fields[0] = build_decl (FIELD_DECL, \n-\t\t\t      get_identifier (\"eh_info\"), t1);\n+      finish_builtin_type (eh_info_type, \"__eh_info\", fields, 2, ptr_type_node);\n+      \n+      /* exception_support.h\n+        struct cp_eh_info\n+        {\n+          __eh_info eh_info;\n+          void *value;\n+          void *type;\n+          cleanup_fn cleanup;\n+          bool caught;\n+          cp_eh_info *next;\n+          long handlers;\n+          void *original_value;\n+        };  */\n+      cp_eh_info_type = make_aggr_type (RECORD_TYPE);\n+      fields[0] = build_decl (FIELD_DECL, get_identifier (\"eh_info\"),\n+                              eh_info_type);\n       fields[1] = build_decl (FIELD_DECL, get_identifier (\"value\"),\n \t\t\t      ptr_type_node);\n       fields[2] = build_decl (FIELD_DECL, get_identifier (\"type\"),\n \t\t\t      ptr_type_node);\n-      fields[3] = build_decl\n-\t(FIELD_DECL, get_identifier (\"cleanup\"),\n-\t build_pointer_type (build_function_type\n-\t\t\t     (ptr_type_node, tree_cons\n-\t\t\t      (NULL_TREE, ptr_type_node, void_list_node))));\n+      fields[3] = build_decl (FIELD_DECL, get_identifier (\"cleanup\"),\n+                              cleanup_fn_type);\n       fields[4] = build_decl (FIELD_DECL, get_identifier (\"caught\"),\n \t\t\t      boolean_type_node);\n       fields[5] = build_decl (FIELD_DECL, get_identifier (\"next\"),\n-\t\t\t      build_pointer_type (t));\n-      fields[6] = build_decl\n-\t(FIELD_DECL, get_identifier (\"handlers\"), long_integer_type_node);\n+\t\t\t      build_pointer_type (cp_eh_info_type));\n+      fields[6] = build_decl (FIELD_DECL, get_identifier (\"handlers\"),\n+                              long_integer_type_node);\n+      fields[7] = build_decl (FIELD_DECL, get_identifier (\"original_value\"),\n+                              ptr_type_node);\n       /* N.B.: The fourth field LEN is expected to be\n \t the number of fields - 1, not the total number of fields.  */\n-      finish_builtin_type (t, \"cp_eh_info\", fields, 6, ptr_type_node);\n-      t = build_pointer_type (t);\n+      finish_builtin_type (cp_eh_info_type, \"cp_eh_info\", fields, 7, ptr_type_node);\n \n       /* And now the function.  */\n-      fn = push_library_fn (fn, build_function_type (t, void_list_node));\n+      fn = push_library_fn (fn,\n+              build_function_type (build_pointer_type (cp_eh_info_type),\n+                                   void_list_node));\n     }\n   return build_function_call (fn, NULL_TREE);\n }"}]}