{"sha": "a252028f29c37224e012050e81883025540b8024", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI1MjAyOGYyOWMzNzIyNGUwMTIwNTBlODE4ODMwMjU1NDBiODAyNA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-10-31T13:06:15Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-10-31T13:06:15Z"}, "message": "Include tree.h #ifdef VMS.\n\n(struct extern_list): Move inside #ifdef VMS; add SIZE and IN_CONST fields;\nmake `extern_head' static; add second list head.\n(vms_check_external): Move inside #ifdef VMS; give new args; maintain list of\nboth pending external symbols and previously defined ones.\n(vms_flush_pending_externals): New function.\n\nFrom-SVN: r8367", "tree": {"sha": "fdf7ba4119e7f559c7294413f1f9d227c55dce8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fdf7ba4119e7f559c7294413f1f9d227c55dce8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a252028f29c37224e012050e81883025540b8024", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a252028f29c37224e012050e81883025540b8024", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a252028f29c37224e012050e81883025540b8024", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a252028f29c37224e012050e81883025540b8024/comments", "author": null, "committer": null, "parents": [{"sha": "fea1b650454bbedd43270ddb4aaaf3df56cc0818", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fea1b650454bbedd43270ddb4aaaf3df56cc0818", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fea1b650454bbedd43270ddb4aaaf3df56cc0818"}], "stats": {"total": 95, "additions": 82, "deletions": 13}, "files": [{"sha": "e43b30606c7589da4576100cb88c04a73e292253", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 82, "deletions": 13, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a252028f29c37224e012050e81883025540b8024/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a252028f29c37224e012050e81883025540b8024/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=a252028f29c37224e012050e81883025540b8024", "patch": "@@ -28,7 +28,9 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"insn-flags.h\"\n #include \"output.h\"\n #include \"insn-attr.h\"\n-\n+#ifdef VMS\n+#include \"tree.h\"\n+#endif\n \n /* This is like nonimmediate_operand with a restriction on the type of MEM.  */\n \n@@ -646,36 +648,102 @@ check_float_value (mode, d, overflow)\n   return 0;\n }\n \f\n+#ifdef VMS\n+\n /* Linked list of all externals that are to be emitted when optimizing\n    for the global pointer if they haven't been declared by the end of\n    the program with an appropriate .comm or initialization.  */\n \n+static\n struct extern_list {\n   struct extern_list *next;\t/* next external */\n   char *name;\t\t\t/* name of the external */\n-} *extern_head = 0;\n+  int size;\t\t\t/* external's actual size */\n+  int in_const;\t\t/* section type flag */\n+} *extern_head = 0, *pending_head = 0;\n \n-/* Return 1 if NAME has already had an external definition;\n-   0 if it has not (so caller should output one).  */\n+/* Check whether NAME is already on the external definition list.  If not,\n+   Add it to either that list of the pending definition list.  */\n \n-int\n-vms_check_external (name)\n+void\n+vms_check_external (decl, name, pending)\n+     tree decl;\n      char *name;\n+     int pending;\n {\n-  register struct extern_list *p;\n+  register struct extern_list *p, *p0;\n \n   for (p = extern_head; p; p = p->next)\n     if (!strcmp (p->name, name))\n-      return 1;\n+      return;\n \n+  for (p = pending_head, p0 = 0; p; p0 = p, p = p->next)\n+    if (!strcmp (p->name, name))\n+      {\n+\tif (pending)\n+\t  return;\n+\n+\t/* Was pending, but may now be defined; move it to other list.  */\n+\tif (p == pending_head)\n+\t  pending_head = 0;\n+\telse\n+\t  p0->next = p->next;\n+\tp->next = extern_head;\n+\textern_head = p;\n+\treturn;\n+      }\n+\n+  /* Not previously seen; create a new list entry.  */\n   p = (struct extern_list *)permalloc ((long) sizeof (struct extern_list));\n-  p->next = extern_head;\n   p->name = name;\n-  extern_head = p;\n-  return 0;\n+\n+  if (pending)\n+    {\n+      /* Save the size and section type and link to `pending' list.  */\n+      p->size = (DECL_SIZE (decl) == 0) ? 0 :\n+\tTREE_INT_CST_LOW (size_binop (CEIL_DIV_EXPR, DECL_SIZE (decl),\n+\t\t\t\t      size_int (BITS_PER_UNIT)));\n+      p->in_const = (TREE_READONLY (decl) && ! TREE_THIS_VOLATILE (decl));\n+\n+      p->next = pending_head;\n+      pending_head = p;\n+    }\n+  else\n+    {\n+      /* Size and section type don't matter; link to `declared' list.  */\n+      p->size = p->in_const = 0;        /* arbitrary init */\n+\n+      p->next = extern_head;\n+      extern_head = p;\n+    }\n+  return;\n+}\n+\n+void\n+vms_flush_pending_externals (file)\n+     FILE *file;\n+{\n+  register struct extern_list *p;\n+\n+  while (pending_head)\n+    {\n+      /* Move next pending declaration to the \"done\" list.  */\n+      p = pending_head;\n+      pending_head = p->next;\n+      p->next = extern_head;\n+      extern_head = p;\n+\n+      /* Now output the actual declaration.  */\n+      if (p->in_const)\n+\tconst_section ();\n+      else\n+\tdata_section ();\n+      fputs (\".comm \", file);\n+      assemble_name (file, p->name);\n+      fprintf (file, \",%d\\n\", p->size);\n+    }\n }\n \f\n-#ifdef VMS\n /* Additional support code for VMS. */\n \n #ifdef QSORT_WORKAROUND\n@@ -685,7 +753,8 @@ vms_check_external (name)\n \tand is longword aligned, you cannot safely sort anything which\n \tis either not a multiple of 4 in size or not longword aligned.\n \tA static \"move-by-longword\" optimization flag inside qsort() is\n-\tnever reset.  This is known of affect VMS V4.6 through VMS V5.5-1.\n+\tnever reset.  This is known of affect VMS V4.6 through VMS V5.5-1,\n+\tand was finally fixed in VMS V5.5-2.\n \n \tIn this work-around an insertion sort is used for simplicity.\n \tThe qsort code from glibc should probably be used instead."}]}