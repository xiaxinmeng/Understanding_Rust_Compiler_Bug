{"sha": "a1d8947aa1168fac70052d1d7d8b64dde934de8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFkODk0N2FhMTE2OGZhYzcwMDUyZDFkN2Q4YjY0ZGRlOTM0ZGU4ZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2013-04-02T18:27:45Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-04-02T18:27:45Z"}, "message": "re PR c++/34949 (Dead code in empty destructors.)\n\n\tPR c++/34949\n\t* tree-ssa-alias.c (stmt_kills_ref_p_1): If base != ref->base\n\tand both of them are MEM_REFs, just compare first argument for\n\tequality and attempt to deal even with differing offsets.\n\nFrom-SVN: r197370", "tree": {"sha": "d91b288513346f92e0771562d6559092b4173ce6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d91b288513346f92e0771562d6559092b4173ce6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1d8947aa1168fac70052d1d7d8b64dde934de8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1d8947aa1168fac70052d1d7d8b64dde934de8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1d8947aa1168fac70052d1d7d8b64dde934de8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1d8947aa1168fac70052d1d7d8b64dde934de8d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5d751b0c970f54e3a99a177d4b2d77db81116e09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d751b0c970f54e3a99a177d4b2d77db81116e09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d751b0c970f54e3a99a177d4b2d77db81116e09"}], "stats": {"total": 51, "additions": 43, "deletions": 8}, "files": [{"sha": "81321f67f9fd7a08fef9fe4609a13fe03d44a21a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1d8947aa1168fac70052d1d7d8b64dde934de8d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1d8947aa1168fac70052d1d7d8b64dde934de8d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a1d8947aa1168fac70052d1d7d8b64dde934de8d", "patch": "@@ -1,5 +1,10 @@\n 2013-04-02  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR c++/34949\n+\t* tree-ssa-alias.c (stmt_kills_ref_p_1): If base != ref->base\n+\tand both of them are MEM_REFs, just compare first argument for\n+\tequality and attempt to deal even with differing offsets.\n+\n \tPR c++/34949\n \t* tree-cfg.c (verify_gimple_assign_single): Allow lhs\n \tof gimple_clobber_p to be MEM_REF."}, {"sha": "968c50548938a21b7b186950e8344ea8f75143d9", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1d8947aa1168fac70052d1d7d8b64dde934de8d/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1d8947aa1168fac70052d1d7d8b64dde934de8d/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=a1d8947aa1168fac70052d1d7d8b64dde934de8d", "patch": "@@ -1889,20 +1889,50 @@ stmt_kills_ref_p_1 (gimple stmt, ao_ref *ref)\n       && !stmt_can_throw_internal (stmt))\n     {\n       tree base, lhs = gimple_get_lhs (stmt);\n-      HOST_WIDE_INT size, offset, max_size;\n+      HOST_WIDE_INT size, offset, max_size, ref_offset = ref->offset;\n       base = get_ref_base_and_extent (lhs, &offset, &size, &max_size);\n       /* We can get MEM[symbol: sZ, index: D.8862_1] here,\n \t so base == ref->base does not always hold.  */\n-      if (base == ref->base)\n+      if (base != ref->base)\n \t{\n-\t  /* For a must-alias check we need to be able to constrain\n-\t     the access properly.  */\n-\t  if (size != -1 && size == max_size)\n+\t  /* If both base and ref->base are MEM_REFs, only compare the\n+\t     first operand, and if the second operand isn't equal constant,\n+\t     try to add the offsets into offset and ref_offset.  */\n+\t  if (TREE_CODE (base) == MEM_REF && TREE_CODE (ref->base) == MEM_REF\n+\t      && TREE_OPERAND (base, 0) == TREE_OPERAND (ref->base, 0))\n \t    {\n-\t      if (offset <= ref->offset\n-\t\t  && offset + size >= ref->offset + ref->max_size)\n-\t\treturn true;\n+\t      if (!tree_int_cst_equal (TREE_OPERAND (base, 0),\n+\t\t\t\t       TREE_OPERAND (ref->base, 0)))\n+\t\t{\n+\t\t  double_int off1 = mem_ref_offset (base);\n+\t\t  off1 = off1.alshift (BITS_PER_UNIT == 8\n+\t\t\t\t       ? 3 : exact_log2 (BITS_PER_UNIT),\n+\t\t\t\t       HOST_BITS_PER_DOUBLE_INT);\n+\t\t  off1 = off1 + double_int::from_shwi (offset);\n+\t\t  double_int off2 = mem_ref_offset (ref->base);\n+\t\t  off2 = off2.alshift (BITS_PER_UNIT == 8\n+\t\t\t\t       ? 3 : exact_log2 (BITS_PER_UNIT),\n+\t\t\t\t       HOST_BITS_PER_DOUBLE_INT);\n+\t\t  off2 = off2 + double_int::from_shwi (ref_offset);\n+\t\t  if (off1.fits_shwi () && off2.fits_shwi ())\n+\t\t    {\n+\t\t      offset = off1.to_shwi ();\n+\t\t      ref_offset = off2.to_shwi ();\n+\t\t    }\n+\t\t  else\n+\t\t    size = -1;\n+\t\t}\n \t    }\n+\t  else\n+\t    size = -1;\n+\t}\n+      /* For a must-alias check we need to be able to constrain\n+\t the access properly.  */\n+      if (size != -1 && size == max_size)\n+\t{\n+\t  if (offset <= ref_offset\n+\t      && offset + size >= ref_offset + ref->max_size)\n+\t    return true;\n \t}\n     }\n "}]}