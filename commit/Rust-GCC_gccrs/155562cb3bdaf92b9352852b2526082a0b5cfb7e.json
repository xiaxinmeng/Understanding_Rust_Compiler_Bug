{"sha": "155562cb3bdaf92b9352852b2526082a0b5cfb7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU1NTYyY2IzYmRhZjkyYjkzNTI4NTJiMjUyNjA4MmEwYjVjZmI3ZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-29T14:12:27Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-29T14:12:27Z"}, "message": "[multiple changes]\n\n2014-07-29  Ed Schonberg  <schonberg@adacore.com>\n\n\t* gnat_rm.texi: No doc needed for Ada2012 aspect\n\tImplicit_dereference.\n\n2014-07-29  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_attr.adb (Attribute_12): New array\n\t(Analyze_Attribute): Check impl-defined Ada 2012 attributes.\n\t(Check_Ada_2012_Attribute): Removed.\n\n2014-07-29  Doug Rupp  <rupp@adacore.com>\n\n\t* init.c (vxworks6): Call sigtramp for RTP (as well as DKM) for ARM,\n\tPPC, and e500.\n\t* sigtramp-vxworks.c: New file.\n\t* sigtramp-armvxw.c, sigtramp-ppcvxw.c: removed files.\n\nFrom-SVN: r213199", "tree": {"sha": "5039b1f06df3071b12c863e4746105414e17bff9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5039b1f06df3071b12c863e4746105414e17bff9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/155562cb3bdaf92b9352852b2526082a0b5cfb7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/155562cb3bdaf92b9352852b2526082a0b5cfb7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/155562cb3bdaf92b9352852b2526082a0b5cfb7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/155562cb3bdaf92b9352852b2526082a0b5cfb7e/comments", "author": null, "committer": null, "parents": [{"sha": "ad8bd3f47cd12be5905dd43d058b3f26319449a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad8bd3f47cd12be5905dd43d058b3f26319449a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad8bd3f47cd12be5905dd43d058b3f26319449a2"}], "stats": {"total": 643, "additions": 244, "deletions": 399}, "files": [{"sha": "251cc2dd96b29ac806d049141d00ced753a4af95", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/155562cb3bdaf92b9352852b2526082a0b5cfb7e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/155562cb3bdaf92b9352852b2526082a0b5cfb7e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=155562cb3bdaf92b9352852b2526082a0b5cfb7e", "patch": "@@ -1,3 +1,21 @@\n+2014-07-29  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* gnat_rm.texi: No doc needed for Ada2012 aspect\n+\tImplicit_dereference.\n+\n+2014-07-29  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_attr.adb (Attribute_12): New array\n+\t(Analyze_Attribute): Check impl-defined Ada 2012 attributes.\n+\t(Check_Ada_2012_Attribute): Removed.\n+\n+2014-07-29  Doug Rupp  <rupp@adacore.com>\n+\n+\t* init.c (vxworks6): Call sigtramp for RTP (as well as DKM) for ARM,\n+\tPPC, and e500.\n+\t* sigtramp-vxworks.c: New file.\n+\t* sigtramp-armvxw.c, sigtramp-ppcvxw.c: removed files.\n+\n 2014-07-29  Ed Schonberg  <schonberg@adacore.com>\n \n \t* lib-xref.adb (Output_Refs, Check_Type_Reference): For a"}, {"sha": "d631fd755c3914cafc39b9f3792a6d179332cc33", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/155562cb3bdaf92b9352852b2526082a0b5cfb7e/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/155562cb3bdaf92b9352852b2526082a0b5cfb7e/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=155562cb3bdaf92b9352852b2526082a0b5cfb7e", "patch": "@@ -364,7 +364,6 @@ Implementation Defined Attributes\n * Attribute Has_Access_Values::\n * Attribute Has_Discriminants::\n * Attribute Img::\n-* Attribute Implicit_Dereference::\n * Attribute Integer_Value::\n * Attribute Invalid_Value::\n * Attribute Iterable::\n@@ -8574,7 +8573,6 @@ consideration, you should minimize the use of these attributes.\n * Attribute Has_Access_Values::\n * Attribute Has_Discriminants::\n * Attribute Img::\n-* Attribute Implicit_Dereference::\n * Attribute Integer_Value::\n * Attribute Invalid_Value::\n * Attribute Iterable::\n@@ -9066,12 +9064,6 @@ that returns the appropriate string when called. This means that\n @code{X'Img} can be renamed as a function-returning-string, or used\n in an instantiation as a function parameter.\n \n-@node Attribute Implicit_Dereference\n-@unnumberedsec Attribute Implicit_Dereference\n-@findex Implicit_Dereference\n-@noindent\n-PLEASE ADD DOCUMENTATION HERE???\n-\n @node Attribute Integer_Value\n @unnumberedsec Attribute Integer_Value\n @findex Integer_Value"}, {"sha": "de9b34b0ffb99355b1f5613a514a20eeac16cb1d", "filename": "gcc/ada/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/155562cb3bdaf92b9352852b2526082a0b5cfb7e/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/155562cb3bdaf92b9352852b2526082a0b5cfb7e/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=155562cb3bdaf92b9352852b2526082a0b5cfb7e", "patch": "@@ -1911,7 +1911,7 @@ __gnat_error_handler (int sig, siginfo_t *si, void *sc)\n   sigdelset (&mask, sig);\n   sigprocmask (SIG_SETMASK, &mask, NULL);\n \n-#if defined (__ARMEL__) || (defined (__PPC__) && defined (_WRS_KERNEL))\n+#if defined (__ARMEL__) || defined (__PPC__)\n   /* On PowerPC, kernel mode, we process signals through a Call Frame Info\n      trampoline, voiding the need for myriads of fallback_frame_state\n      variants in the ZCX runtime.  We have no simple way to distinguish ZCX"}, {"sha": "bc75fed35a89f3071049d5e4c67fc9cd70cfa9b6", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 76, "deletions": 82, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/155562cb3bdaf92b9352852b2526082a0b5cfb7e/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/155562cb3bdaf92b9352852b2526082a0b5cfb7e/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=155562cb3bdaf92b9352852b2526082a0b5cfb7e", "patch": "@@ -86,79 +86,89 @@ package body Sem_Attr is\n    --  used so that we can abandon the processing so we don't run into\n    --  trouble with cascaded errors.\n \n-   --  The following array is the list of attributes defined in the Ada 83 RM\n-   --  that are not included in Ada 95, but still get recognized in GNAT.\n+   --  The following array is the list of attributes defined in the Ada 83 RM:\n \n    Attribute_83 : constant Attribute_Class_Array := Attribute_Class_Array'(\n-      Attribute_Address                |\n-      Attribute_Aft                    |\n-      Attribute_Alignment              |\n-      Attribute_Base                   |\n-      Attribute_Callable               |\n-      Attribute_Constrained            |\n-      Attribute_Count                  |\n-      Attribute_Delta                  |\n-      Attribute_Digits                 |\n-      Attribute_Emax                   |\n-      Attribute_Epsilon                |\n-      Attribute_First                  |\n-      Attribute_First_Bit              |\n-      Attribute_Fore                   |\n-      Attribute_Image                  |\n-      Attribute_Large                  |\n-      Attribute_Last                   |\n-      Attribute_Last_Bit               |\n-      Attribute_Leading_Part           |\n-      Attribute_Length                 |\n-      Attribute_Machine_Emax           |\n-      Attribute_Machine_Emin           |\n-      Attribute_Machine_Mantissa       |\n-      Attribute_Machine_Overflows      |\n-      Attribute_Machine_Radix          |\n-      Attribute_Machine_Rounds         |\n-      Attribute_Mantissa               |\n-      Attribute_Pos                    |\n-      Attribute_Position               |\n-      Attribute_Pred                   |\n-      Attribute_Range                  |\n-      Attribute_Safe_Emax              |\n-      Attribute_Safe_Large             |\n-      Attribute_Safe_Small             |\n-      Attribute_Size                   |\n-      Attribute_Small                  |\n-      Attribute_Storage_Size           |\n-      Attribute_Succ                   |\n-      Attribute_Terminated             |\n-      Attribute_Val                    |\n-      Attribute_Value                  |\n-      Attribute_Width                  => True,\n-      others                           => False);\n+      Attribute_Address                      |\n+      Attribute_Aft                          |\n+      Attribute_Alignment                    |\n+      Attribute_Base                         |\n+      Attribute_Callable                     |\n+      Attribute_Constrained                  |\n+      Attribute_Count                        |\n+      Attribute_Delta                        |\n+      Attribute_Digits                       |\n+      Attribute_Emax                         |\n+      Attribute_Epsilon                      |\n+      Attribute_First                        |\n+      Attribute_First_Bit                    |\n+      Attribute_Fore                         |\n+      Attribute_Image                        |\n+      Attribute_Large                        |\n+      Attribute_Last                         |\n+      Attribute_Last_Bit                     |\n+      Attribute_Leading_Part                 |\n+      Attribute_Length                       |\n+      Attribute_Machine_Emax                 |\n+      Attribute_Machine_Emin                 |\n+      Attribute_Machine_Mantissa             |\n+      Attribute_Machine_Overflows            |\n+      Attribute_Machine_Radix                |\n+      Attribute_Machine_Rounds               |\n+      Attribute_Mantissa                     |\n+      Attribute_Pos                          |\n+      Attribute_Position                     |\n+      Attribute_Pred                         |\n+      Attribute_Range                        |\n+      Attribute_Safe_Emax                    |\n+      Attribute_Safe_Large                   |\n+      Attribute_Safe_Small                   |\n+      Attribute_Size                         |\n+      Attribute_Small                        |\n+      Attribute_Storage_Size                 |\n+      Attribute_Succ                         |\n+      Attribute_Terminated                   |\n+      Attribute_Val                          |\n+      Attribute_Value                        |\n+      Attribute_Width                        => True,\n+      others                                 => False);\n \n    --  The following array is the list of attributes defined in the Ada 2005\n    --  RM which are not defined in Ada 95. These are recognized in Ada 95 mode,\n    --  but in Ada 95 they are considered to be implementation defined.\n \n    Attribute_05 : constant Attribute_Class_Array := Attribute_Class_Array'(\n-      Attribute_Machine_Rounding       |\n-      Attribute_Mod                    |\n-      Attribute_Priority               |\n-      Attribute_Stream_Size            |\n-      Attribute_Wide_Wide_Width        => True,\n-      others                           => False);\n+      Attribute_Machine_Rounding             |\n+      Attribute_Mod                          |\n+      Attribute_Priority                     |\n+      Attribute_Stream_Size                  |\n+      Attribute_Wide_Wide_Width              => True,\n+      others                                 => False);\n+\n+   --  The following array is the list of attributes defined in the Ada 2012\n+   --  RM which are not defined in Ada 2005. These are recognized in Ada 95\n+   --  and Ada 2005 modes, but are considered to be implementation defined.\n+\n+   Attribute_12 : constant Attribute_Class_Array := Attribute_Class_Array'(\n+      Attribute_First_Valid                  |\n+      Attribute_Has_Same_Storage             |\n+      Attribute_Last_Valid                   |\n+      Attribute_Max_Alignment_For_Allocation => True,\n+      others                                 => False);\n \n    --  The following array contains all attributes that imply a modification\n    --  of their prefixes or result in an access value. Such prefixes can be\n    --  considered as lvalues.\n \n    Attribute_Name_Implies_Lvalue_Prefix : constant Attribute_Class_Array :=\n       Attribute_Class_Array'(\n-      Attribute_Access                 |\n-      Attribute_Address                |\n-      Attribute_Input                  |\n-      Attribute_Read                   |\n-      Attribute_Unchecked_Access       |\n-      Attribute_Unrestricted_Access    => True,\n-      others                           => False);\n+      Attribute_Access                       |\n+      Attribute_Address                      |\n+      Attribute_Input                        |\n+      Attribute_Read                         |\n+      Attribute_Unchecked_Access             |\n+      Attribute_Unrestricted_Access          => True,\n+      others                                 => False);\n \n    -----------------------\n    -- Local_Subprograms --\n@@ -180,8 +190,7 @@ package body Sem_Attr is\n \n    function Is_Anonymous_Tagged_Base\n      (Anon : Entity_Id;\n-      Typ  : Entity_Id)\n-      return Boolean;\n+      Typ  : Entity_Id) return Boolean;\n    --  For derived tagged types that constrain parent discriminants we build\n    --  an anonymous unconstrained base type. We need to recognize the relation\n    --  between the two when analyzing an access attribute for a constrained\n@@ -235,11 +244,6 @@ package body Sem_Attr is\n       --  for internally generated uses of the attributes. This legality rule\n       --  only applies to scalar types.\n \n-      procedure Check_Ada_2012_Attribute;\n-      --  Check that we are in Ada 2012 mode for an Ada 2012 attribute, and\n-      --  issue appropriate messages if not (and return to caller even in\n-      --  the error case).\n-\n       procedure Check_Array_Or_Scalar_Type;\n       --  Common procedure used by First, Last, Range attribute to check\n       --  that the prefix is a constrained array or scalar type, or a name\n@@ -1083,16 +1087,6 @@ package body Sem_Attr is\n          end if;\n       end Bad_Attribute_For_Predicate;\n \n-      ------------------------------\n-      -- Check_Ada_2012_Attribute --\n-      ------------------------------\n-\n-      procedure Check_Ada_2012_Attribute is\n-      begin\n-         Error_Msg_Name_1 := Aname;\n-         Error_Msg_Ada_2012_Feature (\"attribute %\", Sloc (N));\n-      end Check_Ada_2012_Attribute;\n-\n       --------------------------------\n       -- Check_Array_Or_Scalar_Type --\n       --------------------------------\n@@ -1487,7 +1481,6 @@ package body Sem_Attr is\n \n       procedure Check_First_Last_Valid is\n       begin\n-         Check_Ada_2012_Attribute;\n          Check_Discrete_Type;\n \n          --  Freeze the subtype now, so that the following test for predicates\n@@ -2382,9 +2375,13 @@ package body Sem_Attr is\n       end if;\n \n       --  Deal with Ada 2005 attributes that are implementation attributes\n-      --  because they appear in a version of Ada before Ada 2005.\n+      --  because they appear in a version of Ada before Ada 2005, and\n+      --  similarly for Ada 2012 attributes appearing in an earlier version.\n \n-      if Attribute_05 (Attr_Id) and then Ada_Version < Ada_2005 then\n+      if (Attribute_05 (Attr_Id) and then Ada_Version < Ada_2005)\n+            or else\n+         (Attribute_12 (Attr_Id) and then Ada_Version < Ada_2012)\n+      then\n          Check_Restriction (No_Implementation_Attributes, N);\n       end if;\n \n@@ -3646,7 +3643,6 @@ package body Sem_Attr is\n       ----------------------\n \n       when Attribute_Has_Same_Storage =>\n-         Check_Ada_2012_Attribute;\n          Check_E1;\n \n          --  The arguments must be objects of any type\n@@ -6335,7 +6331,6 @@ package body Sem_Attr is\n \n       begin\n          Check_E1;\n-         Check_Ada_2012_Attribute;\n \n          if not Is_Object_Reference (P) then\n             Error_Attr_P (\"prefix of attribute % must denote an object\");\n@@ -9766,8 +9761,7 @@ package body Sem_Attr is\n \n    function Is_Anonymous_Tagged_Base\n      (Anon : Entity_Id;\n-      Typ  : Entity_Id)\n-      return Boolean\n+      Typ  : Entity_Id) return Boolean\n    is\n    begin\n       return"}, {"sha": "ff2f0a8792b3a21365b0e9ccf9a4d1a4527d4288", "filename": "gcc/ada/sigtramp-ppcvxw.c", "status": "removed", "additions": 0, "deletions": 293, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad8bd3f47cd12be5905dd43d058b3f26319449a2/gcc%2Fada%2Fsigtramp-ppcvxw.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad8bd3f47cd12be5905dd43d058b3f26319449a2/gcc%2Fada%2Fsigtramp-ppcvxw.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsigtramp-ppcvxw.c?ref=ad8bd3f47cd12be5905dd43d058b3f26319449a2", "patch": "@@ -1,293 +0,0 @@\n-/****************************************************************************\n- *                                                                          *\n- *                         GNAT COMPILER COMPONENTS                         *\n- *                                                                          *\n- *                             S I G T R A M P                              *\n- *                                                                          *\n- *                         Asm Implementation File                          *\n- *                                                                          *\n- *         Copyright (C) 2011-2014, Free Software Foundation, Inc.          *\n- *                                                                          *\n- * GNAT is free software;  you can  redistribute it  and/or modify it under *\n- * terms of the  GNU General Public License as published  by the Free Soft- *\n- * ware  Foundation;  either version 3,  or (at your option) any later ver- *\n- * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n- * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n- * or FITNESS FOR A PARTICULAR PURPOSE.                                     *\n- *                                                                          *\n- * As a special exception under Section 7 of GPL version 3, you are granted *\n- * additional permissions described in the GCC Runtime Library Exception,   *\n- * version 3.1, as published by the Free Software Foundation.               *\n- *                                                                          *\n- * You should have received a copy of the GNU General Public License and    *\n- * a copy of the GCC Runtime Library Exception along with this program;     *\n- * see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    *\n- * <http://www.gnu.org/licenses/>.                                          *\n- *                                                                          *\n- * GNAT was originally developed  by the GNAT team at  New York University. *\n- * Extensive contributions were provided by Ada Core Technologies Inc.      *\n- *                                                                          *\n- ****************************************************************************/\n-\n-/**********************************************************\n- * PowerPC-VxWorks version of the __gnat_sigtramp service *\n- **********************************************************/\n-\n-#include \"sigtramp.h\"\n-/* See sigtramp.h for a general explanation of functionality.  */\n-\n-#include <vxWorks.h>\n-#include <arch/../regs.h>\n-#include <sigLib.h>\n-\n-/* ----------------------\n-   -- General comments --\n-   ----------------------\n-\n-   Stubs are generated from toplevel asms and .cfi directives, much simpler\n-   to use and check for correctness than manual encodings of CFI byte\n-   sequences.  The general idea is to establish CFA as sigcontext->sc_pregs\n-   and state where to find the registers as offsets from there.\n-\n-   As of today, we support a stub providing CFI info for common\n-   registers (GPRs, LR, ...). We might need variants with support for floating\n-   point or altivec registers as well at some point.\n-\n-   Checking which variant should apply and getting at sc_pregs is simpler\n-   to express in C (we can't use offsetof in toplevel asms and hardcoding\n-   constants is not workable with the flurry of VxWorks variants), so this\n-   is the choice for our toplevel interface.\n-\n-   Note that the registers we \"restore\" here are those to which we have\n-   direct access through the system sigcontext structure, which includes\n-   only a partial set of the non-volatiles ABI-wise.  */\n-\n-/* -----------------------------------------\n-   -- Protypes for our internal asm stubs --\n-   -----------------------------------------\n-\n-   SC_PREGS is always expected to be SIGCONTEXT->sc_pregs.  Eventhough our\n-   symbols will remain local, the prototype claims \"extern\" and not\n-   \"static\" to prevent compiler complaints about a symbol used but never\n-   defined.  */\n-\n-/* sigtramp stub providing CFI info for common registers.  */\n-\n-extern void __gnat_sigtramp_common\n-(int signo, void *siginfo, void *sigcontext,\n- __sigtramphandler_t * handler, void * sc_pregs);\n-\n-\n-/* -------------------------------------\n-   -- Common interface implementation --\n-   -------------------------------------\n-\n-   We enforce optimization to minimize the overhead of the extra layer.  */\n-\n-void __gnat_sigtramp (int signo, void *si, void *sc,\n-\t\t      __sigtramphandler_t * handler)\n-     __attribute__((optimize(2)));\n-\n-void __gnat_sigtramp (int signo, void *si, void *sc,\n-\t\t      __sigtramphandler_t * handler)\n-{\n-  struct sigcontext * sctx = (struct sigcontext *) sc;\n-\n-  __gnat_sigtramp_common (signo, si, sctx, handler, sctx->sc_pregs);\n-}\n-\n-\n-/* ---------------------------\n-   -- And now the asm stubs --\n-   ---------------------------\n-\n-   They all have a common structure with blocks of asm sequences queued one\n-   after the others.  Typically:\n-\n-   SYMBOL_START\n-\n-   CFI_DIRECTIVES\n-     CFI_DEF_CFA,\n-     CFI_COMMON_REGISTERS,\n-     ...\n-\n-   STUB_BODY\n-     asm code to establish frame, setup the cfa reg value,\n-     call the real signal handler, ...\n-\n-   SYMBOL_END\n-*/\n-\n-/*--------------------------------\n-  -- Misc constants and helpers --\n-  -------------------------------- */\n-\n-/* REGNO constants, dwarf column numbers for registers of interest.  */\n-\n-#define REGNO_LR  65\n-#define REGNO_CTR 66\n-#define REGNO_CR  70\n-#define REGNO_XER 76\n-#define REGNO_GR(N) (N)\n-\n-#define REGNO_PC  67  /* ARG_POINTER_REGNUM  */\n-\n-/* asm string construction helpers.  */\n-\n-#define STR(TEXT) #TEXT\n-/* stringify expanded TEXT, surrounding it with double quotes.  */\n-\n-#define S(E) STR(E)\n-/* stringify E, which will resolve as text but may contain macros\n-   still to be expanded.  */\n-\n-/* asm (TEXT) outputs <tab>TEXT. These facilitate the output of\n-   multine contents:  */\n-#define TAB(S) \"\\t\" S\n-#define CR(S)  S \"\\n\"\n-\n-#undef TCR\n-#define TCR(S) TAB(CR(S))\n-\n-/*------------------------------\n-  -- Stub construction blocks --\n-  ------------------------------ */\n-\n-/* CFA setup block\n-   ---------------\n-   Only non-volatile registers are suitable for a CFA base. These are the\n-   only ones we can expect to be able retrieve from the unwinding context\n-   while walking up the chain, saved by at least the bottom-most exception\n-   propagation services.  We use r15 here and set it to the value we need\n-   in stub body that follows.  Note that r14 is inappropriate here, even\n-   though it is non-volatile according to the ABI, because GCC uses it as\n-   an extra SCRATCH on SPE targets.  */\n-\n-#define CFA_REG 15\n-\n-#define CFI_DEF_CFA \\\n-CR(\".cfi_def_cfa \" S(CFA_REG) \", 0\")\n-\n-/* Register location blocks\n-   ------------------------\n-   Rules to find registers of interest from the CFA. This should comprise\n-   all the non-volatile registers relevant to the interrupted context.\n-\n-   Note that we include r1 in this set, unlike the libgcc unwinding\n-   fallbacks.  This is useful for fallbacks to allow the use of r1 in CFI\n-   expressions and the absence of rule for r1 gets compensated by using the\n-   target CFA instead.  We don't need the expression facility here and\n-   setup a fake CFA to allow very simple offset expressions, so having a\n-   rule for r1 is the proper thing to do.  We for sure have observed\n-   crashes in some cases without it.  */\n-\n-#define COMMON_CFI(REG) \\\n-  \".cfi_offset \" S(REGNO_##REG) \",\" S(REG_SET_##REG)\n-\n-#define CFI_COMMON_REGS \\\n-CR(\"# CFI for common registers\\n\") \\\n-TCR(COMMON_CFI(GR(0)))  \\\n-TCR(COMMON_CFI(GR(1)))  \\\n-TCR(COMMON_CFI(GR(2)))  \\\n-TCR(COMMON_CFI(GR(3)))  \\\n-TCR(COMMON_CFI(GR(4)))  \\\n-TCR(COMMON_CFI(GR(5)))  \\\n-TCR(COMMON_CFI(GR(6)))  \\\n-TCR(COMMON_CFI(GR(7)))  \\\n-TCR(COMMON_CFI(GR(8)))  \\\n-TCR(COMMON_CFI(GR(9)))  \\\n-TCR(COMMON_CFI(GR(10)))  \\\n-TCR(COMMON_CFI(GR(11)))  \\\n-TCR(COMMON_CFI(GR(12)))  \\\n-TCR(COMMON_CFI(GR(13)))  \\\n-TCR(COMMON_CFI(GR(14))) \\\n-TCR(COMMON_CFI(GR(15))) \\\n-TCR(COMMON_CFI(GR(16))) \\\n-TCR(COMMON_CFI(GR(17))) \\\n-TCR(COMMON_CFI(GR(18))) \\\n-TCR(COMMON_CFI(GR(19))) \\\n-TCR(COMMON_CFI(GR(20))) \\\n-TCR(COMMON_CFI(GR(21))) \\\n-TCR(COMMON_CFI(GR(22))) \\\n-TCR(COMMON_CFI(GR(23))) \\\n-TCR(COMMON_CFI(GR(24))) \\\n-TCR(COMMON_CFI(GR(25))) \\\n-TCR(COMMON_CFI(GR(26))) \\\n-TCR(COMMON_CFI(GR(27))) \\\n-TCR(COMMON_CFI(GR(28))) \\\n-TCR(COMMON_CFI(GR(29))) \\\n-TCR(COMMON_CFI(GR(30))) \\\n-TCR(COMMON_CFI(GR(31))) \\\n-TCR(COMMON_CFI(LR)) \\\n-TCR(COMMON_CFI(CR)) \\\n-TCR(COMMON_CFI(CTR)) \\\n-TCR(COMMON_CFI(XER)) \\\n-TCR(COMMON_CFI(PC)) \\\n-TCR(\".cfi_return_column \" S(REGNO_PC))\n-\n-/* Trampoline body block\n-   ---------------------  */\n-\n-#define SIGTRAMP_BODY \\\n-CR(\"\") \\\n-TCR(\"# Allocate frame and save the non-volatile\") \\\n-TCR(\"# registers we're going to modify\") \\\n-TCR(\"stwu %r1,-16(%r1)\")  \\\n-TCR(\"mflr %r0\")\t\\\n-TCR(\"stw %r0,20(%r1)\")\t\\\n-TCR(\"stw %r\" S(CFA_REG) \",8(%r1)\")\t\\\n-TCR(\"\")\t\t\t\\\n-TCR(\"# Setup CFA_REG = sc_pregs, that we'll retrieve as our CFA value\") \\\n-TCR(\"mr %r\" S(CFA_REG) \", %r7\") \\\n-TCR(\"\")\t\t\t\\\n-TCR(\"# Call the real handler. The signo, siginfo and sigcontext\") \\\n-TCR(\"# arguments are the same as those we received in r3, r4 and r5\") \\\n-TCR(\"mtctr %r6\") \\\n-TCR(\"bctrl\")\t\\\n-TCR(\"\")\t\t\\\n-TCR(\"# Restore our callee-saved items, release our frame and return\") \\\n-TCR(\"lwz %r\" S(CFA_REG) \",8(%r1)\")\t\\\n-TCR(\"lwz %r0,20(%r1)\")\t\\\n-TCR(\"mtlr %r0\")\t\t\\\n-TCR(\"\")\t\t\t\\\n-TCR(\"addi %r1,%r1,16\")\t\\\n-TCR(\"blr\")\n-\n-/* Symbol definition block\n-   -----------------------  */\n-\n-#define SIGTRAMP_START(SYM) \\\n-CR(\"# \" S(SYM) \" cfi trampoline\") \\\n-TCR(\".type \" S(SYM) \", @function\") \\\n-CR(\"\") \\\n-CR(S(SYM) \":\") \\\n-TCR(\".cfi_startproc\") \\\n-TCR(\".cfi_signal_frame\")\n-\n-/* Symbol termination block\n-   ------------------------  */\n-\n-#define SIGTRAMP_END(SYM) \\\n-CR(\".cfi_endproc\") \\\n-TCR(\".size \" S(SYM) \", .-\" S(SYM))\n-\n-/*----------------------------\n-  -- And now, the real code --\n-  ---------------------------- */\n-\n-/* Text section start.  The compiler isn't aware of that switch.  */\n-\n-asm (\".text\\n\"\n-     TCR(\".align 2\"));\n-\n-/* sigtramp stub for common registers.  */\n-\n-#define TRAMP_COMMON __gnat_sigtramp_common\n-\n-asm (SIGTRAMP_START(TRAMP_COMMON));\n-asm (CFI_DEF_CFA);\n-asm (CFI_COMMON_REGS);\n-asm (SIGTRAMP_BODY);\n-asm (SIGTRAMP_END(TRAMP_COMMON));\n-\n-"}, {"sha": "bd65b64198184c6abec3026960aada1f45deb926", "filename": "gcc/ada/sigtramp-vxworks.c", "status": "renamed", "additions": 149, "deletions": 15, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/155562cb3bdaf92b9352852b2526082a0b5cfb7e/gcc%2Fada%2Fsigtramp-vxworks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/155562cb3bdaf92b9352852b2526082a0b5cfb7e/gcc%2Fada%2Fsigtramp-vxworks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsigtramp-vxworks.c?ref=155562cb3bdaf92b9352852b2526082a0b5cfb7e", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                         Asm Implementation File                          *\n  *                                                                          *\n- *           Copyright (C) 2014, Free Software Foundation, Inc.             *\n+ *         Copyright (C) 2011-2014, Free Software Foundation, Inc.          *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -29,9 +29,9 @@\n  *                                                                          *\n  ****************************************************************************/\n \n-/******************************************************\n- * ARM-VxWorks version of the __gnat_sigtramp service *\n- ******************************************************/\n+/**************************************************\n+ * VxWorks version of the __gnat_sigtramp service *\n+ **************************************************/\n \n #include \"sigtramp.h\"\n /* See sigtramp.h for a general explanation of functionality.  */\n@@ -42,7 +42,20 @@\n #include <sigLib.h>\n #else\n #include <signal.h>\n-#include <base/b_ucontext_t.h>\n+#include <regs.h>\n+\n+typedef struct mcontext\n+  {\n+    REG_SET     regs;\n+  } mcontext_t;\n+\n+typedef struct ucontext\n+  {\n+    mcontext_t          uc_mcontext;    /* register set */\n+    struct ucontext *   uc_link;        /* not used */\n+    sigset_t            uc_sigmask;     /* set of signals blocked */\n+    stack_t             uc_stack;       /* stack of context signaled */\n+  } ucontext_t;\n #endif\n \n /* ----------------------\n@@ -135,12 +148,6 @@ void __gnat_sigtramp (int signo, void *si, void *sc,\n   -- Misc constants and helpers --\n   -------------------------------- */\n \n-/* REGNO constants, dwarf column numbers for registers of interest.  */\n-\n-#define REGNO_G_REG_OFFSET(N) (N)\n-\n-#define REGNO_PC_OFFSET  15  /* PC_REGNUM  */\n-\n /* asm string construction helpers.  */\n \n #define STR(TEXT) #TEXT\n@@ -158,6 +165,33 @@ void __gnat_sigtramp (int signo, void *si, void *sc,\n #undef TCR\n #define TCR(S) TAB(CR(S))\n \n+/* REGNO constants, dwarf column numbers for registers of interest.  */\n+\n+#if defined (__PPC__)\n+\n+#define REGNO_LR  65\n+#define REGNO_CTR 66\n+#define REGNO_CR  70\n+#define REGNO_XER 76\n+#define REGNO_GR(N) (N)\n+\n+#define REGNO_PC  67  /* ARG_POINTER_REGNUM  */\n+\n+#define FUNCTION \"@function\"\n+\n+#elif defined (__ARMEL__)\n+\n+#define REGNO_G_REG_OFFSET(N) (N)\n+\n+#define REGNO_PC_OFFSET  15  /* PC_REGNUM  */\n+\n+#define FUNCTION \"%function\"\n+\n+#else\n+Not implemented;\n+#endif /* REGNO constants */\n+\n+\n /*------------------------------\n   -- Stub construction blocks --\n   ------------------------------ */\n@@ -167,22 +201,119 @@ void __gnat_sigtramp (int signo, void *si, void *sc,\n    Only non-volatile registers are suitable for a CFA base. These are the\n    only ones we can expect to be able retrieve from the unwinding context\n    while walking up the chain, saved by at least the bottom-most exception\n-   propagation services. We use r8 here and set it to the value we need\n-   in stub body that follows. Any of r4-r8 should work.  */\n+   propagation services.  We set a non-volatile register to the value we\n+   need in the stub body that follows.  */\n+\n+#if defined (__PPC__)\n+\n+/* Use r15 for PPC.  Note that r14 is inappropriate here, even though it\n+   is non-volatile according to the ABI, because GCC uses it as an extra\n+   SCRATCH on SPE targets.  */\n+\n+#define CFA_REG 15\n+\n+#elif defined (__ARMEL__)\n+\n+/* Use r8 for ARM.  Any of r4-r8 should work.  */\n \n #define CFA_REG 8\n \n+#else\n+Not_implemented;\n+#endif /* CFA setup block */\n+\n #define CFI_DEF_CFA \\\n CR(\".cfi_def_cfa \" S(CFA_REG) \", 0\")\n \n /* Register location blocks\n    ------------------------\n    Rules to find registers of interest from the CFA. This should comprise\n-   all the non-volatile registers relevant to the interrupted context.  */\n+   all the non-volatile registers relevant to the interrupted context.\n+\n+   Note that we include r1 in this set, unlike the libgcc unwinding\n+   fallbacks.  This is useful for fallbacks to allow the use of r1 in CFI\n+   expressions and the absence of rule for r1 gets compensated by using the\n+   target CFA instead.  We don't need the expression facility here and\n+   setup a fake CFA to allow very simple offset expressions, so having a\n+   rule for r1 is the proper thing to do.  We for sure have observed\n+   crashes in some cases without it.  */\n \n #define COMMON_CFI(REG) \\\n   \".cfi_offset \" S(REGNO_##REG) \",\" S(REG_SET_##REG)\n \n+#if defined (__PPC__)\n+\n+#define CFI_COMMON_REGS \\\n+CR(\"# CFI for common registers\\n\") \\\n+TCR(COMMON_CFI(GR(0)))  \\\n+TCR(COMMON_CFI(GR(1)))  \\\n+TCR(COMMON_CFI(GR(2)))  \\\n+TCR(COMMON_CFI(GR(3)))  \\\n+TCR(COMMON_CFI(GR(4)))  \\\n+TCR(COMMON_CFI(GR(5)))  \\\n+TCR(COMMON_CFI(GR(6)))  \\\n+TCR(COMMON_CFI(GR(7)))  \\\n+TCR(COMMON_CFI(GR(8)))  \\\n+TCR(COMMON_CFI(GR(9)))  \\\n+TCR(COMMON_CFI(GR(10)))  \\\n+TCR(COMMON_CFI(GR(11)))  \\\n+TCR(COMMON_CFI(GR(12)))  \\\n+TCR(COMMON_CFI(GR(13)))  \\\n+TCR(COMMON_CFI(GR(14))) \\\n+TCR(COMMON_CFI(GR(15))) \\\n+TCR(COMMON_CFI(GR(16))) \\\n+TCR(COMMON_CFI(GR(17))) \\\n+TCR(COMMON_CFI(GR(18))) \\\n+TCR(COMMON_CFI(GR(19))) \\\n+TCR(COMMON_CFI(GR(20))) \\\n+TCR(COMMON_CFI(GR(21))) \\\n+TCR(COMMON_CFI(GR(22))) \\\n+TCR(COMMON_CFI(GR(23))) \\\n+TCR(COMMON_CFI(GR(24))) \\\n+TCR(COMMON_CFI(GR(25))) \\\n+TCR(COMMON_CFI(GR(26))) \\\n+TCR(COMMON_CFI(GR(27))) \\\n+TCR(COMMON_CFI(GR(28))) \\\n+TCR(COMMON_CFI(GR(29))) \\\n+TCR(COMMON_CFI(GR(30))) \\\n+TCR(COMMON_CFI(GR(31))) \\\n+TCR(COMMON_CFI(LR)) \\\n+TCR(COMMON_CFI(CR)) \\\n+TCR(COMMON_CFI(CTR)) \\\n+TCR(COMMON_CFI(XER)) \\\n+TCR(COMMON_CFI(PC)) \\\n+TCR(\".cfi_return_column \" S(REGNO_PC))\n+\n+/* Trampoline body block\n+   ---------------------  */\n+\n+#define SIGTRAMP_BODY \\\n+CR(\"\") \\\n+TCR(\"# Allocate frame and save the non-volatile\") \\\n+TCR(\"# registers we're going to modify\") \\\n+TCR(\"stwu %r1,-16(%r1)\")  \\\n+TCR(\"mflr %r0\")\t\\\n+TCR(\"stw %r0,20(%r1)\")\t\\\n+TCR(\"stw %r\" S(CFA_REG) \",8(%r1)\")\t\\\n+TCR(\"\")\t\t\t\\\n+TCR(\"# Setup CFA_REG = context, which we'll retrieve as our CFA value\") \\\n+TCR(\"mr %r\" S(CFA_REG) \", %r7\") \\\n+TCR(\"\")\t\t\t\\\n+TCR(\"# Call the real handler. The signo, siginfo and sigcontext\") \\\n+TCR(\"# arguments are the same as those we received in r3, r4 and r5\") \\\n+TCR(\"mtctr %r6\") \\\n+TCR(\"bctrl\")\t\\\n+TCR(\"\")\t\t\\\n+TCR(\"# Restore our callee-saved items, release our frame and return\") \\\n+TCR(\"lwz %r\" S(CFA_REG) \",8(%r1)\")\t\\\n+TCR(\"lwz %r0,20(%r1)\")\t\\\n+TCR(\"mtlr %r0\")\t\t\\\n+TCR(\"\")\t\t\t\\\n+TCR(\"addi %r1,%r1,16\")\t\\\n+TCR(\"blr\")\n+\n+#elif defined (__ARMEL__)\n+\n #define CFI_COMMON_REGS \\\n CR(\"# CFI for common registers\\n\") \\\n TCR(COMMON_CFI(G_REG_OFFSET(0)))  \\\n@@ -222,13 +353,16 @@ TCR(\"blx\tr3\") \\\n TCR(\"# Restore our callee-saved items, release our frame and return\") \\\n TCR(\"ldmfd\tsp, {r\"S(CFA_REG)\", fp, sp, pc}\")\n \n+#else\n+Not_implemented;\n+#endif /* CFI_COMMON_REGS and SIGTRAMP_BODY */\n \n /* Symbol definition block\n    -----------------------  */\n \n #define SIGTRAMP_START(SYM) \\\n CR(\"# \" S(SYM) \" cfi trampoline\") \\\n-TCR(\".type \" S(SYM) \", %function\") \\\n+TCR(\".type \" S(SYM) \", \"FUNCTION) \\\n CR(\"\") \\\n CR(S(SYM) \":\") \\\n TCR(\".cfi_startproc\") \\", "previous_filename": "gcc/ada/sigtramp-armvxw.c"}]}