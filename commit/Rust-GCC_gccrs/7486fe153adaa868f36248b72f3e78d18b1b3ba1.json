{"sha": "7486fe153adaa868f36248b72f3e78d18b1b3ba1", "node_id": "C_kwDOANBUbNoAKDc0ODZmZTE1M2FkYWE4NjhmMzYyNDhiNzJmM2U3OGQxOGIxYjNiYTE", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2023-01-27T17:03:51Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2023-01-27T17:03:51Z"}, "message": "Add support for conditional xorsign [PR96373]\n\nThis patch is an optimisation, but it's also a prerequisite for\nfixing PR96373 without regressing vect-xorsign_exec.c.\n\nCurrently the vectoriser vectorises:\n\n  for (i = 0; i < N; i++)\n    r[i] = a[i] * __builtin_copysignf (1.0f, b[i]);\n\nas two unconditional operations (copysign and mult).\ntree-ssa-math-opts.cc later combines them into an \"xorsign\" function.\nThis works for both Advanced SIMD and SVE.\n\nHowever, with the fix for PR96373, the vectoriser will instead\ngenerate a conditional multiplication (IFN_COND_MUL).  Something then\nneeds to fold copysign & IFN_COND_MUL to the equivalent of a conditional\nxorsign.  Three obvious options were:\n\n(1) Extend tree-ssa-math-opts.cc.\n(2) Do the fold in match.pd.\n(3) Leave it to rtl combine.\n\nI'm against (3), because this isn't a target-specific optimisation.\n(1) would be possible, but would involve open-coding a lot of what\nmatch.pd does for us.  And, in contrast to doing the current\ntree-ssa-math-opts.cc optimisation in match.pd, there should be\nno danger of (2) happening too early.  If we have an IFN_COND_MUL\nthen we're already past the stage of simplifying the original\nsource code.\n\nThere was also a choice between adding a conditional xorsign ifn\nand simply open-coding the xorsign.  The latter seems simpler,\nand means less boiler-plate for target-specific code.\n\nThe signed_or_unsigned_type_for change is needed to make sure\nthat we stay in \"SVE space\" when doing the optimisation on 128-bit\nfixed-length SVE.\n\ngcc/\n\tPR tree-optimization/96373\n\t* tree.h (sign_mask_for): Declare.\n\t* tree.cc (sign_mask_for): New function.\n\t(signed_or_unsigned_type_for): For vector types, try to use the\n\trelated_int_vector_mode.\n\t* genmatch.cc (commutative_op): Handle conditional internal functions.\n\t* match.pd: Fold an IFN_COND_MUL+copysign into an IFN_COND_XOR+and.\n\ngcc/testsuite/\n\tPR tree-optimization/96373\n\t* gcc.target/aarch64/sve/cond_xorsign_1.c: New test.\n\t* gcc.target/aarch64/sve/cond_xorsign_2.c: Likewise.", "tree": {"sha": "a032a0741ea03f90921b41e02085a23d71dfde48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a032a0741ea03f90921b41e02085a23d71dfde48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7486fe153adaa868f36248b72f3e78d18b1b3ba1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7486fe153adaa868f36248b72f3e78d18b1b3ba1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7486fe153adaa868f36248b72f3e78d18b1b3ba1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7486fe153adaa868f36248b72f3e78d18b1b3ba1/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "553f8003ba5ecfdf0574a171692843ef838226b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/553f8003ba5ecfdf0574a171692843ef838226b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/553f8003ba5ecfdf0574a171692843ef838226b4"}], "stats": {"total": 114, "additions": 114, "deletions": 0}, "files": [{"sha": "e147ab9db7ad07b545246c180dd3b8fc49d9ce4f", "filename": "gcc/genmatch.cc", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7486fe153adaa868f36248b72f3e78d18b1b3ba1/gcc%2Fgenmatch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7486fe153adaa868f36248b72f3e78d18b1b3ba1/gcc%2Fgenmatch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.cc?ref=7486fe153adaa868f36248b72f3e78d18b1b3ba1", "patch": "@@ -489,6 +489,21 @@ commutative_op (id_base *id)\n       case CFN_FNMS:\n \treturn 0;\n \n+      case CFN_COND_ADD:\n+      case CFN_COND_MUL:\n+      case CFN_COND_MIN:\n+      case CFN_COND_MAX:\n+      case CFN_COND_FMIN:\n+      case CFN_COND_FMAX:\n+      case CFN_COND_AND:\n+      case CFN_COND_IOR:\n+      case CFN_COND_XOR:\n+      case CFN_COND_FMA:\n+      case CFN_COND_FMS:\n+      case CFN_COND_FNMA:\n+      case CFN_COND_FNMS:\n+\treturn 1;\n+\n       default:\n \treturn -1;\n       }"}, {"sha": "f605b798c44a6aa07dc0e7e6abcb548a2838e294", "filename": "gcc/match.pd", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7486fe153adaa868f36248b72f3e78d18b1b3ba1/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7486fe153adaa868f36248b72f3e78d18b1b3ba1/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=7486fe153adaa868f36248b72f3e78d18b1b3ba1", "patch": "@@ -339,6 +339,20 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n  (if (REAL_VALUE_NEGATIVE (TREE_REAL_CST (@0)))\n   (COPYSIGN_ALL (negate @0) @1)))\n \n+/* Transform c ? x * copysign (1, y) : z to c ? x ^ signs(y) : z.\n+   tree-ssa-math-opts.cc does the corresponding optimization for\n+   unconditional multiplications (via xorsign).  */\n+(simplify\n+ (IFN_COND_MUL:c @0 @1 (IFN_COPYSIGN real_onep @2) @3)\n+ (with { tree signs = sign_mask_for (type); }\n+  (if (signs)\n+   (with { tree inttype = TREE_TYPE (signs); }\n+    (view_convert:type\n+     (IFN_COND_XOR:inttype @0\n+      (view_convert:inttype @1)\n+      (bit_and (view_convert:inttype @2) { signs; })\n+      (view_convert:inttype @3)))))))\n+\n /* (x >= 0 ? x : 0) + (x <= 0 ? -x : 0) -> abs x.  */\n (simplify\n   (plus:c (max @0 integer_zerop) (max (negate @0) integer_zerop))"}, {"sha": "338ca6059237f847aaf52d7152afcb1468daf393", "filename": "gcc/testsuite/gcc.target/aarch64/sve/cond_xorsign_1.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7486fe153adaa868f36248b72f3e78d18b1b3ba1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_xorsign_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7486fe153adaa868f36248b72f3e78d18b1b3ba1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_xorsign_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_xorsign_1.c?ref=7486fe153adaa868f36248b72f3e78d18b1b3ba1", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#define xorsign(A, B, SUFFIX) ((A) * __builtin_copysign##SUFFIX (1.0, B))\n+\n+#define DEF_LOOP(TYPE, SUFFIX)\t\t\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\\\n+  test_##TYPE (TYPE *__restrict r, TYPE *__restrict a,\t\t\\\n+\t       TYPE *__restrict b, TYPE *__restrict c,\t\t\\\n+\t       int n)\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n+      r[i] = a[i] < 20 ? xorsign(b[i], c[i], SUFFIX) : b[i];\t\\\n+  }\n+\n+#define TEST_ALL(T) \\\n+  T (_Float16, f16) \\\n+  T (float, f) \\\n+  T (double, )\n+\n+TEST_ALL (DEF_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.h, z[0-9]+\\.h,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.s, z[0-9]+\\.s,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.d, z[0-9]+\\.d,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.h, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-not {\\tfmul} } } */\n+/* { dg-final { scan-assembler-not {\\tmov\\tz[^,]*z} } } */\n+/* { dg-final { scan-assembler-not {\\tmovprfx\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tsel\\t} } } */"}, {"sha": "274dd0ede5919a4ff505af598fe3951d1a6ce6b6", "filename": "gcc/testsuite/gcc.target/aarch64/sve/cond_xorsign_2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7486fe153adaa868f36248b72f3e78d18b1b3ba1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_xorsign_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7486fe153adaa868f36248b72f3e78d18b1b3ba1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_xorsign_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_xorsign_2.c?ref=7486fe153adaa868f36248b72f3e78d18b1b3ba1", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -msve-vector-bits=128 --param aarch64-autovec-preference=2\" } */\n+\n+#include \"cond_xorsign_1.c\"\n+\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.h, z[0-9]+\\.h,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.s, z[0-9]+\\.s,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.d, z[0-9]+\\.d,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.h, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-not {\\tfmul} } } */\n+/* { dg-final { scan-assembler-not {\\tmov\\tz[^,]*z} } } */\n+/* { dg-final { scan-assembler-not {\\tmovprfx\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tsel\\t} } } */"}, {"sha": "80c09676754508c4799921d55777e84a4d19ba27", "filename": "gcc/tree.cc", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7486fe153adaa868f36248b72f3e78d18b1b3ba1/gcc%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7486fe153adaa868f36248b72f3e78d18b1b3ba1/gcc%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.cc?ref=7486fe153adaa868f36248b72f3e78d18b1b3ba1", "patch": "@@ -2695,6 +2695,35 @@ build_zero_cst (tree type)\n     }\n }\n \n+/* If floating-point type TYPE has an IEEE-style sign bit, return an\n+   unsigned constant in which only the sign bit is set.  Return null\n+   otherwise.  */\n+\n+tree\n+sign_mask_for (tree type)\n+{\n+  /* Avoid having to choose between a real-only sign and a pair of signs.\n+     This could be relaxed if the choice becomes obvious later.  */\n+  if (TREE_CODE (type) == COMPLEX_TYPE)\n+    return NULL_TREE;\n+\n+  auto eltmode = as_a<scalar_float_mode> (element_mode (type));\n+  auto bits = REAL_MODE_FORMAT (eltmode)->ieee_bits;\n+  if (!bits || !pow2p_hwi (bits))\n+    return NULL_TREE;\n+\n+  tree inttype = unsigned_type_for (type);\n+  if (!inttype)\n+    return NULL_TREE;\n+\n+  auto mask = wi::set_bit_in_zero (bits - 1, bits);\n+  if (TREE_CODE (inttype) == VECTOR_TYPE)\n+    {\n+      tree elt = wide_int_to_tree (TREE_TYPE (inttype), mask);\n+      return build_vector_from_val (inttype, elt);\n+    }\n+  return wide_int_to_tree (inttype, mask);\n+}\n \n /* Build a BINFO with LEN language slots.  */\n \n@@ -10987,6 +11016,10 @@ signed_or_unsigned_type_for (int unsignedp, tree type)\n \treturn NULL_TREE;\n       if (inner == inner2)\n \treturn type;\n+      machine_mode new_mode;\n+      if (VECTOR_MODE_P (TYPE_MODE (type))\n+\t  && related_int_vector_mode (TYPE_MODE (type)).exists (&new_mode))\n+\treturn build_vector_type_for_mode (inner2, new_mode);\n       return build_vector_type (inner2, TYPE_VECTOR_SUBPARTS (type));\n     }\n "}, {"sha": "c656cd5b7bf0dc5e426ee8b56f2409a6f6e6fbe4", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7486fe153adaa868f36248b72f3e78d18b1b3ba1/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7486fe153adaa868f36248b72f3e78d18b1b3ba1/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=7486fe153adaa868f36248b72f3e78d18b1b3ba1", "patch": "@@ -4675,6 +4675,7 @@ extern tree build_one_cst (tree);\n extern tree build_minus_one_cst (tree);\n extern tree build_all_ones_cst (tree);\n extern tree build_zero_cst (tree);\n+extern tree sign_mask_for (tree);\n extern tree build_string (unsigned, const char * = NULL);\n extern tree build_poly_int_cst (tree, const poly_wide_int_ref &);\n extern tree build_tree_list (tree, tree CXX_MEM_STAT_INFO);"}]}