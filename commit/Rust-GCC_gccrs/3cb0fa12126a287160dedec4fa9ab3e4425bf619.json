{"sha": "3cb0fa12126a287160dedec4fa9ab3e4425bf619", "node_id": "C_kwDOANBUbNoAKDNjYjBmYTEyMTI2YTI4NzE2MGRlZGVjNGZhOWFiM2U0NDI1YmY2MTk", "commit": {"author": {"name": "Ju-Zhe Zhong", "email": "juzhe.zhong@rivai.ai", "date": "2023-02-15T08:39:54Z"}, "committer": {"name": "Kito Cheng", "email": "kito.cheng@sifive.com", "date": "2023-02-17T02:46:35Z"}, "message": "RISC-V: Normalize SEW = 64 handling into a simplified function\n\nCo-authored-by: kito-cheng <kito.cheng@sifive.com>\n\ngcc/ChangeLog:\n\n\t* config/riscv/riscv-protos.h (sew64_scalar_helper): New function.\n\t* config/riscv/riscv-v.cc (has_vi_variant_p): Adjust.\n\t(sew64_scalar_helper): New function.\n\t* config/riscv/vector.md: Normalization.\n\nCo-authored-by: kito-cheng <kito.cheng@sifive.com>", "tree": {"sha": "7862e5d26609d27fbc93b1e00780dd2a56a4a301", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7862e5d26609d27fbc93b1e00780dd2a56a4a301"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3cb0fa12126a287160dedec4fa9ab3e4425bf619", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cb0fa12126a287160dedec4fa9ab3e4425bf619", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cb0fa12126a287160dedec4fa9ab3e4425bf619", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cb0fa12126a287160dedec4fa9ab3e4425bf619/comments", "author": {"login": "zhongjuzhe", "id": 66454988, "node_id": "MDQ6VXNlcjY2NDU0OTg4", "avatar_url": "https://avatars.githubusercontent.com/u/66454988?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zhongjuzhe", "html_url": "https://github.com/zhongjuzhe", "followers_url": "https://api.github.com/users/zhongjuzhe/followers", "following_url": "https://api.github.com/users/zhongjuzhe/following{/other_user}", "gists_url": "https://api.github.com/users/zhongjuzhe/gists{/gist_id}", "starred_url": "https://api.github.com/users/zhongjuzhe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zhongjuzhe/subscriptions", "organizations_url": "https://api.github.com/users/zhongjuzhe/orgs", "repos_url": "https://api.github.com/users/zhongjuzhe/repos", "events_url": "https://api.github.com/users/zhongjuzhe/events{/privacy}", "received_events_url": "https://api.github.com/users/zhongjuzhe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2dec44ee77c00bab51faa8527106a01b7c796f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2dec44ee77c00bab51faa8527106a01b7c796f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2dec44ee77c00bab51faa8527106a01b7c796f4"}], "stats": {"total": 819, "additions": 316, "deletions": 503}, "files": [{"sha": "37c634eca1d594b9ac47a1673457bd06139f1b56", "filename": "gcc/config/riscv/riscv-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb0fa12126a287160dedec4fa9ab3e4425bf619/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb0fa12126a287160dedec4fa9ab3e4425bf619/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-protos.h?ref=3cb0fa12126a287160dedec4fa9ab3e4425bf619", "patch": "@@ -181,6 +181,8 @@ bool neg_simm5_p (rtx);\n #ifdef RTX_CODE\n bool has_vi_variant_p (rtx_code, rtx);\n #endif\n+bool sew64_scalar_helper (rtx *, rtx *, rtx, machine_mode, machine_mode,\n+\t\t\t  bool, void (*)(rtx *, rtx));\n }\n \n /* We classify builtin types into two classes:"}, {"sha": "59c25c65cd521c74318e36739d1921754f0b4a40", "filename": "gcc/config/riscv/riscv-v.cc", "status": "modified", "additions": 43, "deletions": 3, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb0fa12126a287160dedec4fa9ab3e4425bf619/gcc%2Fconfig%2Friscv%2Friscv-v.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb0fa12126a287160dedec4fa9ab3e4425bf619/gcc%2Fconfig%2Friscv%2Friscv-v.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-v.cc?ref=3cb0fa12126a287160dedec4fa9ab3e4425bf619", "patch": "@@ -418,14 +418,11 @@ has_vi_variant_p (rtx_code code, rtx x)\n   switch (code)\n     {\n     case PLUS:\n-    case MINUS:\n     case AND:\n     case IOR:\n     case XOR:\n     case SS_PLUS:\n-    case SS_MINUS:\n     case US_PLUS:\n-    case US_MINUS:\n     case EQ:\n     case NE:\n     case LE:\n@@ -438,10 +435,53 @@ has_vi_variant_p (rtx_code code, rtx x)\n     case LTU:\n     case GE:\n     case GEU:\n+    case MINUS:\n+    case SS_MINUS:\n       return neg_simm5_p (x);\n+\n     default:\n       return false;\n     }\n }\n \n+bool\n+sew64_scalar_helper (rtx *operands, rtx *scalar_op, rtx vl,\n+\t\t     machine_mode vector_mode, machine_mode mask_mode,\n+\t\t     bool has_vi_variant_p,\n+\t\t     void (*emit_vector_func) (rtx *, rtx))\n+{\n+  machine_mode scalar_mode = GET_MODE_INNER (vector_mode);\n+  if (has_vi_variant_p)\n+    {\n+      *scalar_op = force_reg (scalar_mode, *scalar_op);\n+      return false;\n+    }\n+\n+  if (TARGET_64BIT)\n+    {\n+      if (!rtx_equal_p (*scalar_op, const0_rtx))\n+\t*scalar_op = force_reg (scalar_mode, *scalar_op);\n+      return false;\n+    }\n+\n+  if (immediate_operand (*scalar_op, Pmode))\n+    {\n+      if (!rtx_equal_p (*scalar_op, const0_rtx))\n+\t*scalar_op = force_reg (Pmode, *scalar_op);\n+\n+      *scalar_op = gen_rtx_SIGN_EXTEND (scalar_mode, *scalar_op);\n+      return false;\n+    }\n+\n+  if (CONST_INT_P (*scalar_op))\n+    *scalar_op = force_reg (scalar_mode, *scalar_op);\n+\n+  rtx tmp = gen_reg_rtx (vector_mode);\n+  riscv_vector::emit_nonvlmax_op (code_for_pred_broadcast (vector_mode), tmp,\n+\t\t\t\t  *scalar_op, vl, mask_mode);\n+  emit_vector_func (operands, tmp);\n+\n+  return true;\n+}\n+\n } // namespace riscv_vector"}, {"sha": "c897a365819059b5aea5806ad5ba3f0d1b63e620", "filename": "gcc/config/riscv/vector.md", "status": "modified", "additions": 271, "deletions": 500, "changes": 771, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb0fa12126a287160dedec4fa9ab3e4425bf619/gcc%2Fconfig%2Friscv%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb0fa12126a287160dedec4fa9ab3e4425bf619/gcc%2Fconfig%2Friscv%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fvector.md?ref=3cb0fa12126a287160dedec4fa9ab3e4425bf619", "patch": "@@ -882,32 +882,21 @@\n         (match_operand:VI_D 2 \"register_operand\"))\n       (match_operand:VI_D 1 \"vector_merge_operand\")))]\n   \"TARGET_VECTOR\"\n-  {\n-    if (riscv_vector::simm5_p (operands[3]))\n-      operands[3] = force_reg (<VEL>mode, operands[3]);\n-    else if (!TARGET_64BIT)\n-      {\n-\trtx v = gen_reg_rtx (<MODE>mode);\n-\n-\tif (immediate_operand (operands[3], Pmode))\n-\t  operands[3] = gen_rtx_SIGN_EXTEND (<VEL>mode,\n-\t\tforce_reg (Pmode, operands[3]));\n-\telse\n-\t  {\n-\t    if (CONST_INT_P (operands[3]))\n-\t      operands[3] = force_reg (<VEL>mode, operands[3]);\n-\n-\t    riscv_vector::emit_nonvlmax_op (code_for_pred_broadcast (<MODE>mode),\n-\t\t\tv, operands[3], operands[5], <VM>mode);\n-\t    emit_insn (gen_pred_merge<mode> (operands[0], operands[1],\n-\t\t\toperands[2], v, operands[4],operands[5],\n-\t\t\toperands[6], operands[7]));\n-\t    DONE;\n-\t  }\n-      }\n-    else\n-      operands[3] = force_reg (<VEL>mode, operands[3]);\n-  })\n+{\n+  if (riscv_vector::sew64_scalar_helper (\n+\toperands,\n+\t/* scalar op */&operands[3],\n+\t/* vl */operands[5],\n+\t<MODE>mode,\n+\t<VM>mode,\n+\triscv_vector::simm5_p (operands[3]),\n+\t[] (rtx *operands, rtx boardcast_scalar) {\n+\t  emit_insn (gen_pred_merge<mode> (operands[0], operands[1],\n+\t       operands[2], boardcast_scalar, operands[4], operands[5],\n+\t       operands[6], operands[7]));\n+        }))\n+    DONE;\n+})\n \n (define_insn \"*pred_merge<mode>_scalar\"\n   [(set (match_operand:VI_D 0 \"register_operand\"     \"=vd\")\n@@ -1471,38 +1460,21 @@\n \t    (match_operand:VI_D 3 \"register_operand\"))\n \t  (match_operand:VI_D 2 \"vector_merge_operand\")))]\n   \"TARGET_VECTOR\"\n-  {\n-    if (riscv_vector::has_vi_variant_p (<CODE>, operands[4]))\n-      operands[4] = force_reg (<VEL>mode, operands[4]);\n-    else if (!TARGET_64BIT)\n-      {\n-\trtx v = gen_reg_rtx (<MODE>mode);\n-\n-\tif (immediate_operand (operands[4], Pmode))\n-\t  {\n-\t    if (!rtx_equal_p (operands[4], const0_rtx))\n-\t      operands[4] = force_reg (Pmode, operands[4]);\n-\t    operands[4] = gen_rtx_SIGN_EXTEND (<VEL>mode, operands[4]);\n-\t  }\n-\telse\n-\t  {\n-\t    if (CONST_INT_P (operands[4]))\n-\t      operands[4] = force_reg (<VEL>mode, operands[4]);\n-\n-\t    riscv_vector::emit_nonvlmax_op (code_for_pred_broadcast (<MODE>mode),\n-\t\t\tv, operands[4], operands[5], <VM>mode);\n-\t    emit_insn (gen_pred_<optab><mode> (operands[0], operands[1],\n-\t\t\toperands[2], operands[3], v, operands[5],\n-\t\t\toperands[6], operands[7], operands[8]));\n-\t    DONE;\n-\t  }\n-      }\n-    else\n-      {\n-\tif (!rtx_equal_p (operands[4], const0_rtx))\n-\t  operands[4] = force_reg (<VEL>mode, operands[4]);\n-      }\n-  })\n+{\n+  if (riscv_vector::sew64_scalar_helper (\n+\toperands,\n+\t/* scalar op */&operands[4],\n+\t/* vl */operands[5],\n+\t<MODE>mode,\n+\t<VM>mode,\n+\triscv_vector::has_vi_variant_p (<CODE>, operands[4]),\n+\t[] (rtx *operands, rtx boardcast_scalar) {\n+\t  emit_insn (gen_pred_<optab><mode> (operands[0], operands[1],\n+\t       operands[2], operands[3], boardcast_scalar, operands[5],\n+\t       operands[6], operands[7], operands[8]));\n+        }))\n+    DONE;\n+})\n \n (define_insn \"*pred_<optab><mode>_scalar\"\n   [(set (match_operand:VI_D 0 \"register_operand\"         \"=vd, vr\")\n@@ -1564,38 +1536,21 @@\n \t      (match_operand:<VEL> 4 \"reg_or_int_operand\")))\n \t  (match_operand:VI_D 2 \"vector_merge_operand\")))]\n   \"TARGET_VECTOR\"\n-  {\n-    if (riscv_vector::has_vi_variant_p (<CODE>, operands[4]))\n-      operands[4] = force_reg (<VEL>mode, operands[4]);\n-    else if (!TARGET_64BIT)\n-      {\n-\trtx v = gen_reg_rtx (<MODE>mode);\n-\n-\tif (immediate_operand (operands[4], Pmode))\n-\t  {\n-\t    if (!rtx_equal_p (operands[4], const0_rtx))\n-\t      operands[4] = force_reg (Pmode, operands[4]);\n-\t    operands[4] = gen_rtx_SIGN_EXTEND (<VEL>mode, operands[4]);\n-\t  }\n-\telse\n-\t  {\n-\t    if (CONST_INT_P (operands[4]))\n-\t      operands[4] = force_reg (<VEL>mode, operands[4]);\n-\n-\t    riscv_vector::emit_nonvlmax_op (code_for_pred_broadcast (<MODE>mode),\n-\t\t\tv, operands[4], operands[5], <VM>mode);\n-\t    emit_insn (gen_pred_<optab><mode> (operands[0], operands[1],\n-\t\t\toperands[2], operands[3], v, operands[5],\n-\t\t\toperands[6], operands[7], operands[8]));\n-\t    DONE;\n-\t  }\n-      }\n-    else\n-      {\n-\tif (!rtx_equal_p (operands[4], const0_rtx))\n-\t  operands[4] = force_reg (<VEL>mode, operands[4]);\n-      }\n-  })\n+{\n+  if (riscv_vector::sew64_scalar_helper (\n+\toperands,\n+\t/* scalar op */&operands[4],\n+\t/* vl */operands[5],\n+\t<MODE>mode,\n+\t<VM>mode,\n+\triscv_vector::has_vi_variant_p (<CODE>, operands[4]),\n+\t[] (rtx *operands, rtx boardcast_scalar) {\n+\t  emit_insn (gen_pred_<optab><mode> (operands[0], operands[1],\n+\t       operands[2], operands[3], boardcast_scalar, operands[5],\n+\t       operands[6], operands[7], operands[8]));\n+        }))\n+    DONE;\n+})\n \n (define_insn \"*pred_<optab><mode>_scalar\"\n   [(set (match_operand:VI_D 0 \"register_operand\"         \"=vd, vr\")\n@@ -1657,32 +1612,21 @@\n \t    (match_operand:VI_D 3 \"register_operand\"))\n \t  (match_operand:VI_D 2 \"vector_merge_operand\")))]\n   \"TARGET_VECTOR\"\n-  {\n-    if (riscv_vector::neg_simm5_p (operands[4]))\n-      operands[4] = force_reg (<VEL>mode, operands[4]);\n-    else if (!TARGET_64BIT)\n-      {\n-\trtx v = gen_reg_rtx (<MODE>mode);\n-\n-\tif (immediate_operand (operands[4], Pmode))\n-\t  operands[4] = gen_rtx_SIGN_EXTEND (<VEL>mode,\n-\t\tforce_reg (Pmode, operands[4]));\n-\telse\n-\t  {\n-\t    if (CONST_INT_P (operands[4]))\n-\t      operands[4] = force_reg (<VEL>mode, operands[4]);\n-\n-\t    riscv_vector::emit_nonvlmax_op (code_for_pred_broadcast (<MODE>mode),\n-\t\t\tv, operands[4], operands[5], <VM>mode);\n-\t    emit_insn (gen_pred_sub<mode> (operands[0], operands[1],\n-\t\t\toperands[2], operands[3], v, operands[5],\n-\t\t\toperands[6], operands[7], operands[8]));\n-\t    DONE;\n-\t  }\n-      }\n-    else\n-      operands[4] = force_reg (<VEL>mode, operands[4]);\n-  })\n+{\n+  if (riscv_vector::sew64_scalar_helper (\n+\toperands,\n+\t/* scalar op */&operands[4],\n+\t/* vl */operands[5],\n+\t<MODE>mode,\n+\t<VM>mode,\n+\triscv_vector::neg_simm5_p (operands[4]),\n+\t[] (rtx *operands, rtx boardcast_scalar) {\n+\t  emit_insn (gen_pred_sub<mode> (operands[0], operands[1],\n+\t       operands[2], operands[3], boardcast_scalar, operands[5],\n+\t       operands[6], operands[7], operands[8]));\n+        }))\n+    DONE;\n+})\n \n (define_insn \"*pred_sub<mode>_reverse_scalar\"\n   [(set (match_operand:VI_D 0 \"register_operand\"         \"=vd, vr\")\n@@ -1786,36 +1730,21 @@\n \t     (match_operand:VFULLI_D 3 \"register_operand\")] VMULH)\n \t  (match_operand:VFULLI_D 2 \"vector_merge_operand\")))]\n   \"TARGET_VECTOR\"\n-  {\n-    if (!TARGET_64BIT)\n-      {\n-\trtx v = gen_reg_rtx (<MODE>mode);\n-\n-\tif (immediate_operand (operands[4], Pmode))\n-\t  {\n-\t    if (!rtx_equal_p (operands[4], const0_rtx))\n-\t      operands[4] = force_reg (Pmode, operands[4]);\n-\t    operands[4] = gen_rtx_SIGN_EXTEND (<VEL>mode, operands[4]);\n-\t  }\n-\telse\n-\t  {\n-\t    if (CONST_INT_P (operands[4]))\n-\t      operands[4] = force_reg (<VEL>mode, operands[4]);\n-\n-\t    riscv_vector::emit_nonvlmax_op (code_for_pred_broadcast (<MODE>mode),\n-\t\t\tv, operands[4], operands[5], <VM>mode);\n-\t    emit_insn (gen_pred_mulh<v_su><mode> (operands[0], operands[1],\n-\t\t\toperands[2], operands[3], v, operands[5],\n-\t\t\toperands[6], operands[7], operands[8]));\n-\t    DONE;\n-\t  }\n-      }\n-    else\n-      {\n-\tif (!rtx_equal_p (operands[4], const0_rtx))\n-\t  operands[4] = force_reg (<VEL>mode, operands[4]);\n-      }\n-  })\n+{\n+  if (riscv_vector::sew64_scalar_helper (\n+\toperands,\n+\t/* scalar op */&operands[4],\n+\t/* vl */operands[5],\n+\t<MODE>mode,\n+\t<VM>mode,\n+\tfalse,\n+\t[] (rtx *operands, rtx boardcast_scalar) {\n+\t  emit_insn (gen_pred_mulh<v_su><mode> (operands[0], operands[1],\n+\t       operands[2], operands[3], boardcast_scalar, operands[5],\n+\t       operands[6], operands[7], operands[8]));\n+        }))\n+    DONE;\n+})\n \n (define_insn \"*pred_mulh<v_su><mode>_scalar\"\n   [(set (match_operand:VFULLI_D 0 \"register_operand\"       \"=vd, vr\")\n@@ -1976,33 +1905,21 @@\n \t      (match_operand:<VM> 4 \"register_operand\")] UNSPEC_VADC)\n \t  (match_operand:VI_D 1 \"vector_merge_operand\")))]\n   \"TARGET_VECTOR\"\n-  {\n-    if (riscv_vector::simm5_p (operands[3]))\n-      operands[3] = force_reg (<VEL>mode, operands[3]);\n-    else if (!TARGET_64BIT)\n-      {\n-        rtx v = gen_reg_rtx (<MODE>mode);\n-\n-\tif (immediate_operand (operands[3], Pmode))\n-\t  operands[3] = gen_rtx_SIGN_EXTEND (<VEL>mode,\n-\t\tforce_reg (Pmode, operands[3]));\n-        else\n-  \t  {\n-  \t    if (CONST_INT_P (operands[3]))\n-  \t      operands[3] = force_reg (<VEL>mode, operands[3]);\n-\n-  \t    riscv_vector::emit_nonvlmax_op (code_for_pred_broadcast (<MODE>mode),\n-  \t  \t\t\t\t    v, operands[3], operands[5],\n-  \t  \t\t\t\t    <VM>mode);\n-  \t    emit_insn (gen_pred_adc<mode> (operands[0], operands[1], operands[2],\n-  \t  \t\t\t\t   v, operands[4], operands[5],\n-  \t  \t\t\t\t   operands[6], operands[7]));\n-  \t    DONE;\n-  \t  }\n-      }\n-    else\n-      operands[3] = force_reg (<VEL>mode, operands[3]);\n-  })\n+{\n+  if (riscv_vector::sew64_scalar_helper (\n+\toperands,\n+\t/* scalar op */&operands[3],\n+\t/* vl */operands[5],\n+\t<MODE>mode,\n+\t<VM>mode,\n+\triscv_vector::simm5_p (operands[3]),\n+\t[] (rtx *operands, rtx boardcast_scalar) {\n+\t  emit_insn (gen_pred_adc<mode> (operands[0], operands[1],\n+\t       operands[2], boardcast_scalar, operands[4], operands[5],\n+\t       operands[6], operands[7]));\n+        }))\n+    DONE;\n+})\n \n (define_insn \"*pred_adc<mode>_scalar\"\n   [(set (match_operand:VI_D 0 \"register_operand\"           \"=&vr\")\n@@ -2016,12 +1933,12 @@\n \t  (unspec:VI_D\n \t     [(plus:VI_D\n \t        (vec_duplicate:VI_D\n-\t          (match_operand:<VEL> 3 \"register_operand\" \"  r\"))\n+\t          (match_operand:<VEL> 3 \"reg_or_0_operand\" \" rJ\"))\n \t        (match_operand:VI_D 2 \"register_operand\"    \" vr\"))\n \t      (match_operand:<VM> 4 \"register_operand\"      \" vm\")] UNSPEC_VADC)\n \t  (match_operand:VI_D 1 \"vector_merge_operand\"      \"0vu\")))]\n   \"TARGET_VECTOR\"\n-  \"vadc.vxm\\t%0,%2,%3,%4\"\n+  \"vadc.vxm\\t%0,%2,%z3,%4\"\n   [(set_attr \"type\" \"vicalu\")\n    (set_attr \"mode\" \"<MODE>\")\n    (set_attr \"merge_op_idx\" \"1\")\n@@ -2042,12 +1959,12 @@\n \t     [(plus:VI_D\n \t        (vec_duplicate:VI_D\n \t          (sign_extend:<VEL>\n-\t            (match_operand:<VSUBEL> 3 \"register_operand\" \"  r\")))\n+\t            (match_operand:<VSUBEL> 3 \"reg_or_0_operand\" \" rJ\")))\n \t        (match_operand:VI_D 2 \"register_operand\"         \" vr\"))\n \t      (match_operand:<VM> 4 \"register_operand\"           \" vm\")] UNSPEC_VADC)\n \t  (match_operand:VI_D 1 \"vector_merge_operand\"           \"0vu\")))]\n   \"TARGET_VECTOR\"\n-  \"vadc.vxm\\t%0,%2,%3,%4\"\n+  \"vadc.vxm\\t%0,%2,%z3,%4\"\n   [(set_attr \"type\" \"vicalu\")\n    (set_attr \"mode\" \"<MODE>\")\n    (set_attr \"merge_op_idx\" \"1\")\n@@ -2072,37 +1989,21 @@\n \t      (match_operand:<VM> 4 \"register_operand\")] UNSPEC_VSBC)\n \t  (match_operand:VI_D 1 \"vector_merge_operand\")))]\n   \"TARGET_VECTOR\"\n-  {\n-    if (!TARGET_64BIT)\n-      {\n-        rtx v = gen_reg_rtx (<MODE>mode);\n-\n-\tif (immediate_operand (operands[3], Pmode))\n-\t  {\n-\t    if (!rtx_equal_p (operands[3], const0_rtx))\n-\t      operands[3] = force_reg (Pmode, operands[3]);\n-\t    operands[3] = gen_rtx_SIGN_EXTEND (<VEL>mode, operands[3]);\n-\t  }\n-        else\n-  \t  {\n-  \t    if (CONST_INT_P (operands[3]))\n-  \t      operands[3] = force_reg (<VEL>mode, operands[3]);\n-\n-  \t    riscv_vector::emit_nonvlmax_op (code_for_pred_broadcast (<MODE>mode),\n-  \t  \t\t\t\t    v, operands[3], operands[5],\n-  \t  \t\t\t\t    <VM>mode);\n-  \t    emit_insn (gen_pred_sbc<mode> (operands[0], operands[1], operands[2],\n-  \t  \t\t\t\t   v, operands[4], operands[5],\n-  \t  \t\t\t\t   operands[6], operands[7]));\n-  \t    DONE;\n-  \t  }\n-      }\n-    else\n-      {\n-\tif (!rtx_equal_p (operands[3], const0_rtx))\n-\t  operands[3] = force_reg (<VEL>mode, operands[3]);\n-      }\n-  })\n+{\n+  if (riscv_vector::sew64_scalar_helper (\n+\toperands,\n+\t/* scalar op */&operands[3],\n+\t/* vl */operands[5],\n+\t<MODE>mode,\n+\t<VM>mode,\n+\tfalse,\n+\t[] (rtx *operands, rtx boardcast_scalar) {\n+\t  emit_insn (gen_pred_sbc<mode> (operands[0], operands[1],\n+\t       operands[2], boardcast_scalar, operands[4], operands[5],\n+\t       operands[6], operands[7]));\n+        }))\n+    DONE;\n+})\n \n (define_insn \"*pred_sbc<mode>_scalar\"\n   [(set (match_operand:VI_D 0 \"register_operand\"           \"=&vr\")\n@@ -2247,39 +2148,27 @@\n \t       (reg:SI VL_REGNUM)\n \t       (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)] UNSPEC_VMADC))]\n   \"TARGET_VECTOR\"\n-  {\n-    if (riscv_vector::simm5_p (operands[2]))\n-      operands[2] = force_reg (<VEL>mode, operands[2]);\n-    else if (!TARGET_64BIT)\n-      {\n-\trtx v = gen_reg_rtx (<MODE>mode);\n-\n-\tif (immediate_operand (operands[2], Pmode))\n-\t  operands[2] = gen_rtx_SIGN_EXTEND (<VEL>mode,\n-\t\tforce_reg (Pmode, operands[2]));\n-\telse\n-\t  {\n-\t    if (CONST_INT_P (operands[2]))\n-\t      operands[2] = force_reg (<VEL>mode, operands[2]);\n-\n-\t    riscv_vector::emit_nonvlmax_op (code_for_pred_broadcast (<MODE>mode),\n-\t\t\t\t\t    v, operands[2], operands[5],\n-\t\t\t\t\t    <VM>mode);\n-\t    emit_insn (gen_pred_madc<mode> (operands[0], operands[1], v, operands[3],\n-\t\t\t\t\t    operands[4], operands[5]));\n-\t    DONE;\n-\t  }\n-      }\n-    else\n-      operands[2] = force_reg (<VEL>mode, operands[2]);\n-  })\n+{\n+  if (riscv_vector::sew64_scalar_helper (\n+\toperands,\n+\t/* scalar op */&operands[2],\n+\t/* vl */operands[4],\n+\t<MODE>mode,\n+\t<VM>mode,\n+\triscv_vector::simm5_p (operands[2]),\n+\t[] (rtx *operands, rtx boardcast_scalar) {\n+\t  emit_insn (gen_pred_madc<mode> (operands[0], operands[1],\n+\t       boardcast_scalar, operands[3], operands[4], operands[5]));\n+        }))\n+    DONE;\n+})\n \n (define_insn \"*pred_madc<mode>_scalar\"\n   [(set (match_operand:<VM> 0 \"register_operand\"         \"=&vr\")\n \t(unspec:<VM>\n \t   [(plus:VI_D\n \t     (vec_duplicate:VI_D\n-\t       (match_operand:<VEL> 2 \"register_operand\" \"   r\"))\n+\t       (match_operand:<VEL> 2 \"reg_or_0_operand\" \"  rJ\"))\n \t     (match_operand:VI_D 1 \"register_operand\"    \"  vr\"))\n \t    (match_operand:<VM> 3 \"register_operand\"     \"  vm\")\n \t    (unspec:<VM>\n@@ -2288,7 +2177,7 @@\n \t       (reg:SI VL_REGNUM)\n \t       (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)] UNSPEC_VMADC))]\n   \"TARGET_VECTOR\"\n-  \"vmadc.vxm\\t%0,%1,%2,%3\"\n+  \"vmadc.vxm\\t%0,%1,%z2,%3\"\n   [(set_attr \"type\" \"vicalu\")\n    (set_attr \"mode\" \"<MODE>\")\n    (set_attr \"vl_op_idx\" \"4\")\n@@ -2300,7 +2189,7 @@\n \t   [(plus:VI_D\n \t     (vec_duplicate:VI_D\n \t       (sign_extend:<VEL>\n-\t         (match_operand:<VSUBEL> 2 \"register_operand\" \"   r\")))\n+\t         (match_operand:<VSUBEL> 2 \"reg_or_0_operand\" \"  rJ\")))\n \t     (match_operand:VI_D 1 \"register_operand\"         \"  vr\"))\n \t    (match_operand:<VM> 3 \"register_operand\"          \"  vm\")\n \t    (unspec:<VM>\n@@ -2309,7 +2198,7 @@\n \t       (reg:SI VL_REGNUM)\n \t       (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)] UNSPEC_VMADC))]\n   \"TARGET_VECTOR\"\n-  \"vmadc.vxm\\t%0,%1,%2,%3\"\n+  \"vmadc.vxm\\t%0,%1,%z2,%3\"\n   [(set_attr \"type\" \"vicalu\")\n    (set_attr \"mode\" \"<MODE>\")\n    (set_attr \"vl_op_idx\" \"4\")\n@@ -2329,36 +2218,20 @@\n \t       (reg:SI VL_REGNUM)\n \t       (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)] UNSPEC_VMSBC))]\n   \"TARGET_VECTOR\"\n-  {\n-    if (!TARGET_64BIT)\n-      {\n-        rtx v = gen_reg_rtx (<MODE>mode);\n-\n-\tif (immediate_operand (operands[2], Pmode))\n-\t  {\n-\t    if (!rtx_equal_p (operands[2], const0_rtx))\n-\t      operands[2] = force_reg (Pmode, operands[2]);\n-\t    operands[2] = gen_rtx_SIGN_EXTEND (<VEL>mode, operands[2]);\n-\t  }\n-\telse\n-\t  {\n-\t    if (CONST_INT_P (operands[2]))\n-\t      operands[2] = force_reg (<VEL>mode, operands[2]);\n-\n-\t    riscv_vector::emit_nonvlmax_op (code_for_pred_broadcast (<MODE>mode),\n-\t\t\t\t\t    v, operands[2], operands[5],\n-\t\t\t\t\t    <VM>mode);\n-\t    emit_insn (gen_pred_msbc<mode> (operands[0], operands[1], v, operands[3],\n-\t\t\t\t\t    operands[4], operands[5]));\n-\t    DONE;\n-\t  }\n-      }\n-    else\n-      {\n-\tif (!rtx_equal_p (operands[2], const0_rtx))\n-\t  operands[2] = force_reg (<VEL>mode, operands[2]);\n-      }\n-  })\n+{\n+  if (riscv_vector::sew64_scalar_helper (\n+\toperands,\n+\t/* scalar op */&operands[2],\n+\t/* vl */operands[4],\n+\t<MODE>mode,\n+\t<VM>mode,\n+\tfalse,\n+\t[] (rtx *operands, rtx boardcast_scalar) {\n+\t  emit_insn (gen_pred_msbc<mode> (operands[0], operands[1],\n+\t       boardcast_scalar, operands[3], operands[4], operands[5]));\n+        }))\n+    DONE;\n+})\n \n (define_insn \"*pred_msbc<mode>_scalar\"\n   [(set (match_operand:<VM> 0 \"register_operand\"         \"=&vr\")\n@@ -2442,15 +2315,15 @@\n \t(unspec:<VM>\n \t   [(plus:VI_QHS\n \t     (vec_duplicate:VI_QHS\n-\t       (match_operand:<VEL> 2 \"register_operand\" \"   r\"))\n+\t       (match_operand:<VEL> 2 \"reg_or_0_operand\" \"  rJ\"))\n \t     (match_operand:VI_QHS 1 \"register_operand\"  \"  vr\"))\n \t    (unspec:<VM>\n \t      [(match_operand 3 \"vector_length_operand\"  \"  rK\")\n \t       (match_operand 4 \"const_int_operand\"      \"   i\")\n \t       (reg:SI VL_REGNUM)\n \t       (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)] UNSPEC_OVERFLOW))]\n   \"TARGET_VECTOR\"\n-  \"vmadc.vx\\t%0,%1,%2\"\n+  \"vmadc.vx\\t%0,%1,%z2\"\n   [(set_attr \"type\" \"vicalu\")\n    (set_attr \"mode\" \"<MODE>\")\n    (set_attr \"vl_op_idx\" \"3\")\n@@ -2488,47 +2361,35 @@\n \t       (reg:SI VL_REGNUM)\n \t       (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)] UNSPEC_OVERFLOW))]\n   \"TARGET_VECTOR\"\n-  {\n-    if (riscv_vector::simm5_p (operands[2]))\n-      operands[2] = force_reg (<VEL>mode, operands[2]);\n-    else if (!TARGET_64BIT)\n-      {\n-        rtx v = gen_reg_rtx (<MODE>mode);\n-\n-\tif (immediate_operand (operands[2], Pmode))\n-\t  operands[2] = gen_rtx_SIGN_EXTEND (<VEL>mode,\n-\t\tforce_reg (Pmode, operands[2]));\n-\telse\n-\t  {\n-\t    if (CONST_INT_P (operands[2]))\n-\t      operands[2] = force_reg (<VEL>mode, operands[2]);\n-\n-\t    riscv_vector::emit_nonvlmax_op (code_for_pred_broadcast (<MODE>mode),\n-\t\t\t\t\t    v, operands[2], operands[3],\n-\t\t\t\t\t    <VM>mode);\n-\t    emit_insn (gen_pred_madc<mode>_overflow (operands[0], operands[1],\n-\t\t\t\t\t\t     v, operands[3], operands[4]));\n-\t    DONE;\n-\t  }\n-      }\n-    else\n-      operands[2] = force_reg (<VEL>mode, operands[2]);\n-  })\n+{\n+  if (riscv_vector::sew64_scalar_helper (\n+\toperands,\n+\t/* scalar op */&operands[2],\n+\t/* vl */operands[3],\n+\t<MODE>mode,\n+\t<VM>mode,\n+\triscv_vector::simm5_p (operands[2]),\n+\t[] (rtx *operands, rtx boardcast_scalar) {\n+\t  emit_insn (gen_pred_madc<mode>_overflow (operands[0], operands[1],\n+\t       boardcast_scalar, operands[3], operands[4]));\n+        }))\n+    DONE;\n+})\n \n (define_insn \"*pred_madc<mode>_overflow_scalar\"\n   [(set (match_operand:<VM> 0 \"register_operand\"         \"=&vr\")\n \t(unspec:<VM>\n \t   [(plus:VI_D\n \t     (vec_duplicate:VI_D\n-\t       (match_operand:<VEL> 2 \"register_operand\" \"   r\"))\n+\t       (match_operand:<VEL> 2 \"reg_or_0_operand\" \"  rJ\"))\n \t     (match_operand:VI_D 1 \"register_operand\"    \"  vr\"))\n \t    (unspec:<VM>\n \t      [(match_operand 3 \"vector_length_operand\"  \"  rK\")\n \t       (match_operand 4 \"const_int_operand\"      \"   i\")\n \t       (reg:SI VL_REGNUM)\n \t       (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)] UNSPEC_OVERFLOW))]\n   \"TARGET_VECTOR\"\n-  \"vmadc.vx\\t%0,%1,%2\"\n+  \"vmadc.vx\\t%0,%1,%z2\"\n   [(set_attr \"type\" \"vicalu\")\n    (set_attr \"mode\" \"<MODE>\")\n    (set_attr \"vl_op_idx\" \"3\")\n@@ -2540,15 +2401,15 @@\n \t   [(plus:VI_D\n \t     (vec_duplicate:VI_D\n \t       (sign_extend:<VEL>\n-\t         (match_operand:<VSUBEL> 2 \"register_operand\" \"   r\")))\n+\t         (match_operand:<VSUBEL> 2 \"reg_or_0_operand\" \"  rJ\")))\n \t     (match_operand:VI_D 1 \"register_operand\"         \"  vr\"))\n \t    (unspec:<VM>\n \t      [(match_operand 3 \"vector_length_operand\"       \"  rK\")\n \t       (match_operand 4 \"const_int_operand\"           \"   i\")\n \t       (reg:SI VL_REGNUM)\n \t       (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)] UNSPEC_OVERFLOW))]\n   \"TARGET_VECTOR\"\n-  \"vmadc.vx\\t%0,%1,%2\"\n+  \"vmadc.vx\\t%0,%1,%z2\"\n   [(set_attr \"type\" \"vicalu\")\n    (set_attr \"mode\" \"<MODE>\")\n    (set_attr \"vl_op_idx\" \"3\")\n@@ -2567,36 +2428,20 @@\n \t       (reg:SI VL_REGNUM)\n \t       (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)] UNSPEC_OVERFLOW))]\n   \"TARGET_VECTOR\"\n-  {\n-    if (!TARGET_64BIT)\n-      {\n-        rtx v = gen_reg_rtx (<MODE>mode);\n-\n-\tif (immediate_operand (operands[2], Pmode))\n-\t  {\n-\t    if (!rtx_equal_p (operands[2], const0_rtx))\n-\t      operands[2] = force_reg (Pmode, operands[2]);\n-\t    operands[2] = gen_rtx_SIGN_EXTEND (<VEL>mode, operands[2]);\n-\t  }\n-\telse\n-\t  {\n-\t    if (CONST_INT_P (operands[2]))\n-\t      operands[2] = force_reg (<VEL>mode, operands[2]);\n-\n-\t    riscv_vector::emit_nonvlmax_op (code_for_pred_broadcast (<MODE>mode),\n-\t\t\t\t\t    v, operands[2], operands[3],\n-\t\t\t\t\t    <VM>mode);\n-\t    emit_insn (gen_pred_msbc<mode>_overflow (operands[0], operands[1],\n-\t\t\t\t\t\t     v, operands[3], operands[4]));\n-\t    DONE;\n-\t  }\n-      }\n-    else\n-      {\n-\tif (!rtx_equal_p (operands[2], const0_rtx))\n-\t  operands[2] = force_reg (<VEL>mode, operands[2]);\n-      }\n-  })\n+{\n+  if (riscv_vector::sew64_scalar_helper (\n+\toperands,\n+\t/* scalar op */&operands[2],\n+\t/* vl */operands[3],\n+\t<MODE>mode,\n+\t<VM>mode,\n+\tfalse,\n+\t[] (rtx *operands, rtx boardcast_scalar) {\n+\t  emit_insn (gen_pred_msbc<mode>_overflow (operands[0], operands[1],\n+\t       boardcast_scalar, operands[3], operands[4]));\n+        }))\n+    DONE;\n+})\n \n (define_insn \"*pred_msbc<mode>_overflow_scalar\"\n   [(set (match_operand:<VM> 0 \"register_operand\"         \"=&vr\")\n@@ -3069,32 +2914,21 @@\n \t    (match_operand:VI_D 3 \"register_operand\"))\n \t  (match_operand:VI_D 2 \"vector_merge_operand\")))]\n   \"TARGET_VECTOR\"\n-  {\n-    if (riscv_vector::has_vi_variant_p (<CODE>, operands[4]))\n-      operands[4] = force_reg (<VEL>mode, operands[4]);\n-    else if (!TARGET_64BIT)\n-      {\n-\trtx v = gen_reg_rtx (<MODE>mode);\n-\n-\tif (immediate_operand (operands[4], Pmode))\n-\t  operands[4] = gen_rtx_SIGN_EXTEND (<VEL>mode,\n-\t\tforce_reg (Pmode, operands[4]));\n-\telse\n-\t  {\n-\t    if (CONST_INT_P (operands[4]))\n-\t      operands[4] = force_reg (<VEL>mode, operands[4]);\n-\n-\t    riscv_vector::emit_nonvlmax_op (code_for_pred_broadcast (<MODE>mode),\n-\t\t\tv, operands[4], operands[5], <VM>mode);\n-\t    emit_insn (gen_pred_<optab><mode> (operands[0], operands[1],\n-\t\t\toperands[2], operands[3], v, operands[5],\n-\t\t\toperands[6], operands[7], operands[8]));\n-\t    DONE;\n-\t  }\n-      }\n-    else\n-      operands[4] = force_reg (<VEL>mode, operands[4]);\n-  })\n+{\n+  if (riscv_vector::sew64_scalar_helper (\n+\toperands,\n+\t/* scalar op */&operands[4],\n+\t/* vl */operands[5],\n+\t<MODE>mode,\n+\t<VM>mode,\n+\triscv_vector::has_vi_variant_p (<CODE>, operands[4]),\n+\t[] (rtx *operands, rtx boardcast_scalar) {\n+\t  emit_insn (gen_pred_<optab><mode> (operands[0], operands[1],\n+\t       operands[2], operands[3], boardcast_scalar, operands[5],\n+\t       operands[6], operands[7], operands[8]));\n+        }))\n+    DONE;\n+})\n \n (define_insn \"*pred_<optab><mode>_scalar\"\n   [(set (match_operand:VI_D 0 \"register_operand\"         \"=vd, vr\")\n@@ -3156,32 +2990,21 @@\n \t      (match_operand:<VEL> 4 \"reg_or_int_operand\")))\n \t  (match_operand:VI_D 2 \"vector_merge_operand\")))]\n   \"TARGET_VECTOR\"\n-  {\n-    if (riscv_vector::has_vi_variant_p (<CODE>, operands[4]))\n-      operands[4] = force_reg (<VEL>mode, operands[4]);\n-    else if (!TARGET_64BIT)\n-      {\n-\trtx v = gen_reg_rtx (<MODE>mode);\n-\n-\tif (immediate_operand (operands[4], Pmode))\n-\t  operands[4] = gen_rtx_SIGN_EXTEND (<VEL>mode,\n-\t\tforce_reg (Pmode, operands[4]));\n-\telse\n-\t  {\n-\t    if (CONST_INT_P (operands[4]))\n-\t      operands[4] = force_reg (<VEL>mode, operands[4]);\n-\n-\t    riscv_vector::emit_nonvlmax_op (code_for_pred_broadcast (<MODE>mode),\n-\t\t\tv, operands[4], operands[5], <VM>mode);\n-\t    emit_insn (gen_pred_<optab><mode> (operands[0], operands[1],\n-\t\t\toperands[2], operands[3], v, operands[5],\n-\t\t\toperands[6], operands[7], operands[8]));\n-\t    DONE;\n-\t  }\n-      }\n-    else\n-      operands[4] = force_reg (<VEL>mode, operands[4]);\n-  })\n+{\n+  if (riscv_vector::sew64_scalar_helper (\n+\toperands,\n+\t/* scalar op */&operands[4],\n+\t/* vl */operands[5],\n+\t<MODE>mode,\n+\t<VM>mode,\n+\triscv_vector::has_vi_variant_p (<CODE>, operands[4]),\n+\t[] (rtx *operands, rtx boardcast_scalar) {\n+\t  emit_insn (gen_pred_<optab><mode> (operands[0], operands[1],\n+\t       operands[2], operands[3], boardcast_scalar, operands[5],\n+\t       operands[6], operands[7], operands[8]));\n+        }))\n+    DONE;\n+})\n \n (define_insn \"*pred_<optab><mode>_scalar\"\n   [(set (match_operand:VI_D 0 \"register_operand\"         \"=vd, vr\")\n@@ -3305,36 +3128,21 @@\n \t     (match_operand:<VEL> 4 \"reg_or_int_operand\")] VSAT_ARITH_OP)\n \t  (match_operand:VI_D 2 \"vector_merge_operand\")))]\n   \"TARGET_VECTOR\"\n-  {\n-    if (!TARGET_64BIT)\n-      {\n-\trtx v = gen_reg_rtx (<MODE>mode);\n-\n-\tif (immediate_operand (operands[4], Pmode))\n-\t  {\n-\t    if (!rtx_equal_p (operands[4], const0_rtx))\n-\t      operands[4] = force_reg (Pmode, operands[4]);\n-\t    operands[4] = gen_rtx_SIGN_EXTEND (<VEL>mode, operands[4]);\n-\t  }\n-\telse\n-\t  {\n-\t    if (CONST_INT_P (operands[4]))\n-\t      operands[4] = force_reg (<VEL>mode, operands[4]);\n-\n-\t    riscv_vector::emit_nonvlmax_op (code_for_pred_broadcast (<MODE>mode),\n-\t\t\tv, operands[4], operands[5], <VM>mode);\n-\t    emit_insn (gen_pred_<sat_op><mode> (operands[0], operands[1],\n-\t\t\toperands[2], operands[3], v, operands[5],\n-\t\t\toperands[6], operands[7], operands[8]));\n-\t    DONE;\n-\t  }\n-      }\n-    else\n-      {\n-\tif (!rtx_equal_p (operands[4], const0_rtx))\n-\t  operands[4] = force_reg (<VEL>mode, operands[4]);\n-      }\n-  })\n+{\n+  if (riscv_vector::sew64_scalar_helper (\n+\toperands,\n+\t/* scalar op */&operands[4],\n+\t/* vl */operands[5],\n+\t<MODE>mode,\n+\t<VM>mode,\n+\tfalse,\n+\t[] (rtx *operands, rtx boardcast_scalar) {\n+\t  emit_insn (gen_pred_<sat_op><mode> (operands[0], operands[1],\n+\t       operands[2], operands[3], boardcast_scalar, operands[5],\n+\t       operands[6], operands[7], operands[8]));\n+        }))\n+    DONE;\n+})\n \n (define_insn \"*pred_<sat_op><mode>_scalar\"\n   [(set (match_operand:VI_D 0 \"register_operand\"         \"=vd, vr\")\n@@ -3677,42 +3485,29 @@\n \t        (match_operand:<VEL> 5 \"reg_or_int_operand\"))])\n \t  (match_operand:<VM> 2 \"vector_merge_operand\")))]\n   \"TARGET_VECTOR\"\n-  {\n-    enum rtx_code code = GET_CODE (operands[3]);\n-\n-    if (riscv_vector::has_vi_variant_p (code, operands[5]))\n-      operands[5] = force_reg (<VEL>mode, operands[5]);\n-    else if (!TARGET_64BIT)\n-      {\n-\trtx v = gen_reg_rtx (<MODE>mode);\n-\n-\tif (immediate_operand (operands[5], Pmode))\n-\t  {\n-\t    if (!rtx_equal_p (operands[5], const0_rtx))\n-\t      operands[5] = force_reg (Pmode, operands[5]);\n-\t    operands[5] = gen_rtx_SIGN_EXTEND (<VEL>mode, operands[5]);\n-\t  }\n-\telse\n-\t  {\n-\t    if (CONST_INT_P (operands[5]))\n-\t      operands[5] = force_reg (<VEL>mode, operands[5]);\n-\n-\t    riscv_vector::emit_nonvlmax_op (code_for_pred_broadcast (<MODE>mode),\n-\t\t\tv, operands[5], operands[6], <VM>mode);\n-\t    if (code == LT || code == LTU)\n-\t\temit_insn (gen_pred_ltge<mode> (operands[0], operands[1],\n-\t\t\t   operands[2], operands[3], operands[4], v,\n-\t\t\t   operands[6], operands[7], operands[8]));\n-\t    else\n-\t\temit_insn (gen_pred_cmp<mode> (operands[0], operands[1],\n-\t\t\t   operands[2], operands[3], operands[4], v,\n-\t\t\t   operands[6], operands[7], operands[8]));\n-\t    DONE;\n-\t  }\n-      }\n-    else\n-      operands[5] = force_reg (<VEL>mode, operands[5]);\n-  })\n+{\n+  enum rtx_code code = GET_CODE (operands[3]);\n+  if (riscv_vector::sew64_scalar_helper (\n+\toperands,\n+\t/* scalar op */&operands[5],\n+\t/* vl */operands[6],\n+\t<MODE>mode,\n+\t<VM>mode,\n+\triscv_vector::has_vi_variant_p (code, operands[5]),\n+\tcode == LT || code == LTU ?\n+\t  [] (rtx *operands, rtx boardcast_scalar) {\n+\t    emit_insn (gen_pred_ltge<mode> (operands[0], operands[1],\n+\t    \toperands[2], operands[3], operands[4], boardcast_scalar,\n+\t  \toperands[6], operands[7], operands[8]));\n+          }\n+\t:\n+\t  [] (rtx *operands, rtx boardcast_scalar) {\n+\t    emit_insn (gen_pred_cmp<mode> (operands[0], operands[1],\n+\t    \toperands[2], operands[3], operands[4], boardcast_scalar,\n+\t  \toperands[6], operands[7], operands[8]));\n+          }))\n+    DONE;\n+})\n \n (define_expand \"@pred_eqne<mode>_scalar\"\n   [(set (match_operand:<VM> 0 \"register_operand\")\n@@ -3730,37 +3525,22 @@\n \t      (match_operand:VI_D 4 \"register_operand\")])\n \t  (match_operand:<VM> 2 \"vector_merge_operand\")))]\n   \"TARGET_VECTOR\"\n-  {\n-    enum rtx_code code = GET_CODE (operands[3]);\n-\n-    if (riscv_vector::has_vi_variant_p (code, operands[5]))\n-      operands[5] = force_reg (<VEL>mode, operands[5]);\n-    else if (!TARGET_64BIT)\n-      {\n-\trtx v = gen_reg_rtx (<MODE>mode);\n-\n-\tif (immediate_operand (operands[5], Pmode))\n-\t  {\n-\t    if (!rtx_equal_p (operands[5], const0_rtx))\n-\t      operands[5] = force_reg (Pmode, operands[5]);\n-\t    operands[5] = gen_rtx_SIGN_EXTEND (<VEL>mode, operands[5]);\n-\t  }\n-\telse\n-\t  {\n-\t    if (CONST_INT_P (operands[5]))\n-\t      operands[5] = force_reg (<VEL>mode, operands[5]);\n-\n-\t    riscv_vector::emit_nonvlmax_op (code_for_pred_broadcast (<MODE>mode),\n-\t\t\tv, operands[5], operands[6], <VM>mode);\n-\t    emit_insn (gen_pred_cmp<mode> (operands[0], operands[1],\n-\t\t       operands[2], operands[3], operands[4], v,\n-\t\t       operands[6], operands[7], operands[8]));\n-\t    DONE;\n-\t  }\n-      }\n-    else\n-      operands[5] = force_reg (<VEL>mode, operands[5]);\n-  })\n+{\n+  enum rtx_code code = GET_CODE (operands[3]);\n+  if (riscv_vector::sew64_scalar_helper (\n+\toperands,\n+\t/* scalar op */&operands[5],\n+\t/* vl */operands[6],\n+\t<MODE>mode,\n+\t<VM>mode,\n+\triscv_vector::has_vi_variant_p (code, operands[5]),\n+\t[] (rtx *operands, rtx boardcast_scalar) {\n+\t  emit_insn (gen_pred_cmp<mode> (operands[0], operands[1],\n+\t  \toperands[2], operands[3], operands[4], boardcast_scalar,\n+\t\toperands[6], operands[7], operands[8]));\n+        }))\n+    DONE;\n+})\n \n ;; We don't use early-clobber for LMUL <= 1 to get better codegen.\n (define_insn \"*pred_cmp<mode>_scalar\"\n@@ -4400,28 +4180,19 @@\n \t  (match_operand:VI_D 5 \"vector_merge_operand\")))]\n   \"TARGET_VECTOR\"\n {\n-  if (!TARGET_64BIT)\n-    {\n-      rtx v = gen_reg_rtx (<MODE>mode);\n-\n-      if (immediate_operand (operands[2], Pmode))\n-        operands[2] = gen_rtx_SIGN_EXTEND (<VEL>mode,\n-      \t\tforce_reg (Pmode, operands[2]));\n-      else\n-        {\n-          if (CONST_INT_P (operands[2]))\n-            operands[2] = force_reg (<VEL>mode, operands[2]);\n-\n-\t  riscv_vector::emit_nonvlmax_op (code_for_pred_broadcast (<MODE>mode),\n-\t\t\tv, operands[2], operands[6], <VM>mode);\n+  if (riscv_vector::sew64_scalar_helper (\n+\toperands,\n+\t/* scalar op */&operands[2],\n+\t/* vl */operands[6],\n+\t<MODE>mode,\n+\t<VM>mode,\n+\tfalse,\n+\t[] (rtx *operands, rtx boardcast_scalar) {\n \t  emit_insn (gen_pred_mul_<optab><mode> (operands[0], operands[1],\n-\t\t\tv, operands[3], operands[4], operands[5], operands[6],\n-\t\t\toperands[7], operands[8], operands[9]));\n-\t  DONE;\n-\t}\n-    }\n-   else\n-    operands[2] = force_reg (<VEL>mode, operands[2]);\n+\t       boardcast_scalar, operands[3], operands[4], operands[5],\n+\t       operands[6], operands[7], operands[8], operands[9]));\n+        }))\n+    DONE;\n })\n \n (define_insn \"*pred_mul_<optab><mode>_undef_merge_extended_scalar\""}]}