{"sha": "d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDk0MWNlZTZmZmEzYzMyOTM5ZDRkZGYxZDFiMGNhMTYxM2RmMjZkMA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-29T10:25:10Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-29T10:25:10Z"}, "message": "[multiple changes]\n\n2011-08-29  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch13.adb: Additional semantic checks for aspects involved in\n\titerators.\n\n2011-08-29  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-comutr.ads, a-comutr.adb, a-cimutr.ads, a-cimutr.adb,\n\ta-cbmutr.ads, a-cbmutr.adb (Find_In_Subtree): Remove superfluous\n\tContainer parameter.\n\t(Ancestor_Find): ditto.\n\n2011-08-29  Robert Dewar  <dewar@adacore.com>\n\n\t* par-endh.adb: Minor reformatting.\n\nFrom-SVN: r178190", "tree": {"sha": "7231c914b20a6192d1398f725c6a779419140c9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7231c914b20a6192d1398f725c6a779419140c9a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0/comments", "author": null, "committer": null, "parents": [{"sha": "b970af399230f7b18a3c602fcf57b7d9bfe5415c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b970af399230f7b18a3c602fcf57b7d9bfe5415c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b970af399230f7b18a3c602fcf57b7d9bfe5415c"}], "stats": {"total": 497, "additions": 376, "deletions": 121}, "files": [{"sha": "6799af82e999e2cdf64c3783399848e1de114a1a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0", "patch": "@@ -1,7 +1,19 @@\n+2011-08-29  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch13.adb: Additional semantic checks for aspects involved in\n+\titerators.\n+\n+2011-08-29  Matthew Heaney  <heaney@adacore.com>\n+\n+\t* a-comutr.ads, a-comutr.adb, a-cimutr.ads, a-cimutr.adb,\n+\ta-cbmutr.ads, a-cbmutr.adb (Find_In_Subtree): Remove superfluous\n+\tContainer parameter.\n+\t(Ancestor_Find): ditto.\n+\n 2011-08-29  Thomas Quinot  <quinot@adacore.com>\n \n \t* par-endh.adb: Minor reformatting.\n-z\n+\n 2011-08-29  Tristan Gingold  <gingold@adacore.com>\n \n \t* a-exexpr-gcc.adb (Unwind_Action) Rewrite as an integer with constants."}, {"sha": "e206e98e38f56618cb524d0005b571ef61c3b7a5", "filename": "gcc/ada/a-cbmutr.adb", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0/gcc%2Fada%2Fa-cbmutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0/gcc%2Fada%2Fa-cbmutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbmutr.adb?ref=d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0", "patch": "@@ -286,21 +286,21 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n    -------------------\n \n    function Ancestor_Find\n-     (Container : Tree;\n-      Item      : Element_Type;\n-      Position  : Cursor) return Cursor\n+     (Position : Cursor;\n+      Item     : Element_Type) return Cursor\n    is\n-      R : constant Count_Type := Root_Node (Container);\n-      N : Count_Type;\n+      R, N : Count_Type;\n \n    begin\n       if Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error with \"Position cursor not in container\";\n-      end if;\n+      --  Commented-out pending ruling by ARG.  ???\n+\n+      --  if Position.Container /= Container'Unrestricted_Access then\n+      --     raise Program_Error with \"Position cursor not in container\";\n+      --  end if;\n \n       --  AI-0136 says to raise PE if Position equals the root node. This does\n       --  not seem correct, as this value is just the limiting condition of the\n@@ -311,13 +311,14 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       --     raise Program_Error with \"Position cursor designates root\";\n       --  end if;\n \n+      R := Root_Node (Position.Container.all);\n       N := Position.Node;\n       while N /= R loop\n-         if Container.Elements (N) = Item then\n-            return Cursor'(Container'Unrestricted_Access, N);\n+         if Position.Container.Elements (N) = Item then\n+            return Cursor'(Position.Container, N);\n          end if;\n \n-         N := Container.Nodes (N).Parent;\n+         N := Position.Container.Nodes (N).Parent;\n       end loop;\n \n       return No_Element;\n@@ -1289,9 +1290,8 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n    ---------------------\n \n    function Find_In_Subtree\n-     (Container : Tree;\n-      Item      : Element_Type;\n-      Position  : Cursor) return Cursor\n+     (Position : Cursor;\n+      Item     : Element_Type) return Cursor\n    is\n       Result : Count_Type;\n \n@@ -1300,27 +1300,35 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error with \"Position cursor not in container\";\n-      end if;\n+      --  Commented-out pending ruling by ARG.  ???\n \n-      if Container.Count = 0 then\n+      --  if Position.Container /= Container'Unrestricted_Access then\n+      --     raise Program_Error with \"Position cursor not in container\";\n+      --  end if;\n+\n+      if Position.Container.Count = 0 then\n          pragma Assert (Is_Root (Position));\n          return No_Element;\n       end if;\n \n       if Is_Root (Position) then\n-         Result := Find_In_Children (Container, Position.Node, Item);\n+         Result := Find_In_Children\n+                     (Container => Position.Container.all,\n+                      Subtree   => Position.Node,\n+                      Item      => Item);\n \n       else\n-         Result := Find_In_Subtree (Container, Position.Node, Item);\n+         Result := Find_In_Subtree\n+                     (Container => Position.Container.all,\n+                      Subtree   => Position.Node,\n+                      Item      => Item);\n       end if;\n \n       if Result = 0 then\n          return No_Element;\n       end if;\n \n-      return Cursor'(Container'Unrestricted_Access, Result);\n+      return Cursor'(Position.Container, Result);\n    end Find_In_Subtree;\n \n    function Find_In_Subtree"}, {"sha": "818cde28a1c7628c20b9a2a1e56367ace23f1cf8", "filename": "gcc/ada/a-cbmutr.ads", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0/gcc%2Fada%2Fa-cbmutr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0/gcc%2Fada%2Fa-cbmutr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbmutr.ads?ref=d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0", "patch": "@@ -113,22 +113,36 @@ package Ada.Containers.Bounded_Multiway_Trees is\n       Item      : Element_Type) return Cursor;\n \n    --  This version of the AI:\n-\n-   --    10-06-02  AI05-0136-1/07\n-\n-   --  declares Find_In_Subtree with a Container parameter, but this seems\n-   --  incorrect. We need a ruling from the ARG about whether this really was\n-   --  intended. ???\n+   --   10-06-02  AI05-0136-1/07\n+   --  declares Find_In_Subtree this way:\n+   --\n+   --  function Find_In_Subtree\n+   --    (Container : Tree;\n+   --     Item      : Element_Type;\n+   --     Position  : Cursor) return Cursor;\n+   --\n+   --  It seems that the Container parameter is there by mistake, but we need\n+   --  an official ruling from the ARG. ???\n \n    function Find_In_Subtree\n-     (Container : Tree;\n-      Item      : Element_Type;\n-      Position  : Cursor) return Cursor;\n+     (Position : Cursor;\n+      Item     : Element_Type) return Cursor;\n+\n+   --  This version of the AI:\n+   --   10-06-02  AI05-0136-1/07\n+   --  declares Ancestor_Find this way:\n+   --\n+   --  function Ancestor_Find\n+   --    (Container : Tree;\n+   --     Item      : Element_Type;\n+   --     Position  : Cursor) return Cursor;\n+   --\n+   --  It seems that the Container parameter is there by mistake, but we need\n+   --  an official ruling from the ARG. ???\n \n    function Ancestor_Find\n-     (Container : Tree;\n-      Item      : Element_Type;\n-      Position  : Cursor) return Cursor;\n+     (Position : Cursor;\n+      Item     : Element_Type) return Cursor;\n \n    function Contains\n      (Container : Tree;"}, {"sha": "90fedaef0e17523c46adeddf9ea3d36fba926669", "filename": "gcc/ada/a-cimutr.adb", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0/gcc%2Fada%2Fa-cimutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0/gcc%2Fada%2Fa-cimutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cimutr.adb?ref=d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0", "patch": "@@ -164,21 +164,21 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n    -------------------\n \n    function Ancestor_Find\n-     (Container : Tree;\n-      Item      : Element_Type;\n-      Position  : Cursor) return Cursor\n+     (Position : Cursor;\n+      Item     : Element_Type) return Cursor\n    is\n-      R : constant Tree_Node_Access := Root_Node (Container);\n-      N : Tree_Node_Access;\n+      R, N : Tree_Node_Access;\n \n    begin\n       if Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error with \"Position cursor not in container\";\n-      end if;\n+      --  Commented-out pending ARG ruling.  ???\n+\n+      --  if Position.Container /= Container'Unrestricted_Access then\n+      --     raise Program_Error with \"Position cursor not in container\";\n+      --  end if;\n \n       --  AI-0136 says to raise PE if Position equals the root node. This does\n       --  not seem correct, as this value is just the limiting condition of the\n@@ -188,10 +188,11 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       --     raise Program_Error with \"Position cursor designates root\";\n       --  end if;\n \n+      R := Root_Node (Position.Container.all);\n       N := Position.Node;\n       while N /= R loop\n          if N.Element.all = Item then\n-            return Cursor'(Container'Unrestricted_Access, N);\n+            return Cursor'(Position.Container, N);\n          end if;\n \n          N := N.Parent;\n@@ -974,9 +975,8 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n    ---------------------\n \n    function Find_In_Subtree\n-     (Container : Tree;\n-      Item      : Element_Type;\n-      Position  : Cursor) return Cursor\n+     (Position : Cursor;\n+      Item     : Element_Type) return Cursor\n    is\n       Result : Tree_Node_Access;\n \n@@ -985,9 +985,11 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error with \"Position cursor not in container\";\n-      end if;\n+      --  Commented-out pending ruling from ARG.  ???\n+\n+      --  if Position.Container /= Container'Unrestricted_Access then\n+      --     raise Program_Error with \"Position cursor not in container\";\n+      --  end if;\n \n       if Is_Root (Position) then\n          Result := Find_In_Children (Position.Node, Item);\n@@ -1000,7 +1002,7 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          return No_Element;\n       end if;\n \n-      return Cursor'(Container'Unrestricted_Access, Result);\n+      return Cursor'(Position.Container, Result);\n    end Find_In_Subtree;\n \n    function Find_In_Subtree"}, {"sha": "9f3b5d7c193e2b4ac9e0c5bd6afbaf124c5d16b6", "filename": "gcc/ada/a-cimutr.ads", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0/gcc%2Fada%2Fa-cimutr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0/gcc%2Fada%2Fa-cimutr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cimutr.ads?ref=d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0", "patch": "@@ -113,15 +113,37 @@ package Ada.Containers.Indefinite_Multiway_Trees is\n      (Container : Tree;\n       Item      : Element_Type) return Cursor;\n \n+   --  This version of the AI:\n+   --   10-06-02  AI05-0136-1/07\n+   --  declares Find_In_Subtree this way:\n+   --\n+   --  function Find_In_Subtree\n+   --    (Container : Tree;\n+   --     Item      : Element_Type;\n+   --     Position  : Cursor) return Cursor;\n+   --\n+   --  It seems that the Container parameter is there by mistake, but we need\n+   --  an official ruling from the ARG. ???\n+\n    function Find_In_Subtree\n-     (Container : Tree;\n-      Item      : Element_Type;\n-      Position  : Cursor) return Cursor;\n+     (Position : Cursor;\n+      Item     : Element_Type) return Cursor;\n+\n+   --  This version of the AI:\n+   --   10-06-02  AI05-0136-1/07\n+   --  declares Ancestor_Find this way:\n+   --\n+   --  function Ancestor_Find\n+   --    (Container : Tree;\n+   --     Item      : Element_Type;\n+   --     Position  : Cursor) return Cursor;\n+   --\n+   --  It seems that the Container parameter is there by mistake, but we need\n+   --  an official ruling from the ARG. ???\n \n    function Ancestor_Find\n-     (Container : Tree;\n-      Item      : Element_Type;\n-      Position  : Cursor) return Cursor;\n+     (Position : Cursor;\n+      Item     : Element_Type) return Cursor;\n \n    function Contains\n      (Container : Tree;"}, {"sha": "c4ad64ef0c17985f66fd7a081485c978823f7226", "filename": "gcc/ada/a-comutr.adb", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0/gcc%2Fada%2Fa-comutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0/gcc%2Fada%2Fa-comutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-comutr.adb?ref=d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0", "patch": "@@ -163,21 +163,21 @@ package body Ada.Containers.Multiway_Trees is\n    -------------------\n \n    function Ancestor_Find\n-     (Container : Tree;\n-      Item      : Element_Type;\n-      Position  : Cursor) return Cursor\n+     (Position : Cursor;\n+      Item     : Element_Type) return Cursor\n    is\n-      R : constant Tree_Node_Access := Root_Node (Container);\n-      N : Tree_Node_Access;\n+      R, N : Tree_Node_Access;\n \n    begin\n       if Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error with \"Position cursor not in container\";\n-      end if;\n+      --  Commented-out pending official ruling from ARG.  ???\n+\n+      --  if Position.Container /= Container'Unrestricted_Access then\n+      --     raise Program_Error with \"Position cursor not in container\";\n+      --  end if;\n \n       --  AI-0136 says to raise PE if Position equals the root node. This does\n       --  not seem correct, as this value is just the limiting condition of the\n@@ -187,10 +187,11 @@ package body Ada.Containers.Multiway_Trees is\n       --     raise Program_Error with \"Position cursor designates root\";\n       --  end if;\n \n+      R := Root_Node (Position.Container.all);\n       N := Position.Node;\n       while N /= R loop\n          if N.Element = Item then\n-            return Cursor'(Container'Unrestricted_Access, N);\n+            return Cursor'(Position.Container, N);\n          end if;\n \n          N := N.Parent;\n@@ -950,9 +951,8 @@ package body Ada.Containers.Multiway_Trees is\n    ---------------------\n \n    function Find_In_Subtree\n-     (Container : Tree;\n-      Item      : Element_Type;\n-      Position  : Cursor) return Cursor\n+     (Position : Cursor;\n+      Item     : Element_Type) return Cursor\n    is\n       Result : Tree_Node_Access;\n \n@@ -961,9 +961,11 @@ package body Ada.Containers.Multiway_Trees is\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error with \"Position cursor not in container\";\n-      end if;\n+      --  Commented out pending official ruling by ARG.  ???\n+\n+      --  if Position.Container /= Container'Unrestricted_Access then\n+      --     raise Program_Error with \"Position cursor not in container\";\n+      --  end if;\n \n       if Is_Root (Position) then\n          Result := Find_In_Children (Position.Node, Item);\n@@ -976,7 +978,7 @@ package body Ada.Containers.Multiway_Trees is\n          return No_Element;\n       end if;\n \n-      return Cursor'(Container'Unrestricted_Access, Result);\n+      return Cursor'(Position.Container, Result);\n    end Find_In_Subtree;\n \n    function Find_In_Subtree"}, {"sha": "d2291df0ce419074ff57a668fb0de307fb870cfb", "filename": "gcc/ada/a-comutr.ads", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0/gcc%2Fada%2Fa-comutr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0/gcc%2Fada%2Fa-comutr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-comutr.ads?ref=d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0", "patch": "@@ -113,15 +113,37 @@ package Ada.Containers.Multiway_Trees is\n      (Container : Tree;\n       Item      : Element_Type) return Cursor;\n \n+   --  This version of the AI:\n+   --   10-06-02  AI05-0136-1/07\n+   --  declares Find_In_Subtree this way:\n+   --\n+   --  function Find_In_Subtree\n+   --    (Container : Tree;\n+   --     Item      : Element_Type;\n+   --     Position  : Cursor) return Cursor;\n+   --\n+   --  It seems that the Container parameter is there by mistake, but we need\n+   --  an official ruling from the ARG. ???\n+\n    function Find_In_Subtree\n-     (Container : Tree;\n-      Item      : Element_Type;\n-      Position  : Cursor) return Cursor;\n+     (Position : Cursor;\n+      Item     : Element_Type) return Cursor;\n+\n+   --  This version of the AI:\n+   --   10-06-02  AI05-0136-1/07\n+   --  declares Ancestor_Find this way:\n+   --\n+   --  function Ancestor_Find\n+   --    (Container : Tree;\n+   --     Item      : Element_Type;\n+   --     Position  : Cursor) return Cursor;\n+   --\n+   --  It seems that the Container parameter is there by mistake, but we need\n+   --  an official ruling from the ARG. ???\n \n    function Ancestor_Find\n-     (Container : Tree;\n-      Item      : Element_Type;\n-      Position  : Cursor) return Cursor;\n+     (Position : Cursor;\n+      Item     : Element_Type) return Cursor;\n \n    function Contains\n      (Container : Tree;"}, {"sha": "3a2c9402e48597f73fd66e379b34e808d347797f", "filename": "gcc/ada/par-endh.adb", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0/gcc%2Fada%2Fpar-endh.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0/gcc%2Fada%2Fpar-endh.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-endh.adb?ref=d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0", "patch": "@@ -799,10 +799,10 @@ package body Endh is\n       --  In the following test we protect the call to Comes_From_Source\n       --  against lines containing previously reported syntax errors.\n \n-      elsif (Etyp = E_Loop\n-               or else Etyp = E_Name\n-               or else Etyp = E_Suspicious_Is\n-               or else Etyp = E_Bad_Is)\n+      elsif (Etyp = E_Loop          or else\n+             Etyp = E_Name          or else\n+             Etyp = E_Suspicious_Is or else\n+             Etyp = E_Bad_Is)\n          and then Comes_From_Source (L)\n       then\n          return True;\n@@ -818,7 +818,6 @@ package body Endh is\n \n    procedure Output_End_Deleted is\n    begin\n-\n       if End_Type = E_Loop then\n          Error_Msg_SC (\"no LOOP for this `END LOOP`!\");\n \n@@ -1042,9 +1041,9 @@ package body Endh is\n          --  We also reserve an end with a name before the end of file if the\n          --  name is the one we expect at the outer level.\n \n-         if (Token = Tok_EOF\n-               or else Token = Tok_With\n-               or else Token = Tok_Separate)\n+         if (Token = Tok_EOF  or else\n+             Token = Tok_With or else\n+             Token = Tok_Separate)\n            and then End_Type >= E_Name\n            and then (not End_Labl_Present\n                       or else Same_Label (End_Labl, Scope.Table (1).Labl))"}, {"sha": "1856647c0da42cef039db86a9aca1927c2608e33", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 209, "deletions": 35, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=d941cee6ffa3c32939d4ddf1d1b0ca1613df26d0", "patch": "@@ -1539,6 +1539,13 @@ package body Sem_Ch13 is\n       --  attribute has the proper type structure. If the name is overloaded,\n       --  check that all interpretations are legal.\n \n+      procedure Check_Iterator_Functions;\n+      --  Check that there is a single function in Default_Iterator attribute\n+      --  that  has the  proper type structure.\n+\n+      function Check_Primitive_Function (Subp : Entity_Id) return Boolean;\n+      --  Common legality check for the previoous two.\n+\n       -----------------------------------\n       -- Analyze_Stream_TSS_Definition --\n       -----------------------------------\n@@ -1681,8 +1688,6 @@ package body Sem_Ch13 is\n       ------------------------------\n \n       procedure Check_Indexing_Functions is\n-         Ctrl : Entity_Id;\n-\n          procedure Check_One_Function (Subp : Entity_Id);\n          --  Check one possible interpretation\n \n@@ -1692,34 +1697,10 @@ package body Sem_Ch13 is\n \n          procedure Check_One_Function (Subp : Entity_Id) is\n          begin\n-            if Ekind (Subp) /= E_Function then\n-               Error_Msg_N (\"indexing requires a function\", Subp);\n-            end if;\n-\n-            if No (First_Formal (Subp)) then\n-               Error_Msg_N\n-                 (\"function for indexing must have parameters\", Subp);\n-            else\n-               Ctrl := Etype (First_Formal (Subp));\n-            end if;\n-\n-            if Ctrl = Ent\n-              or else Ctrl = Class_Wide_Type (Ent)\n-              or else\n-                (Ekind (Ctrl) = E_Anonymous_Access_Type\n-                  and then\n-                    (Designated_Type (Ctrl) = Ent\n-                      or else Designated_Type (Ctrl) = Class_Wide_Type (Ent)))\n-            then\n-               null;\n-\n-            else\n-               Error_Msg_N (\"indexing function must apply to type&\", Subp);\n-            end if;\n-\n-            if No (Next_Formal (First_Formal (Subp))) then\n-               Error_Msg_N\n-                 (\"function for indexing must have two parameters\", Subp);\n+            if not Check_Primitive_Function (Subp) then\n+               Error_Msg_NE\n+                 (\"aspect Indexing requires a function that applies to type&\",\n+                   Subp, Ent);\n             end if;\n \n             if not Has_Implicit_Dereference (Etype (Subp)) then\n@@ -1731,6 +1712,10 @@ package body Sem_Ch13 is\n       --  Start of processing for Check_Indexing_Functions\n \n       begin\n+         if In_Instance then\n+            return;\n+         end if;\n+\n          Analyze (Expr);\n \n          if not Is_Overloaded (Expr) then\n@@ -1759,6 +1744,138 @@ package body Sem_Ch13 is\n          end if;\n       end Check_Indexing_Functions;\n \n+      ------------------------------\n+      -- Check_Iterator_Functions --\n+      ------------------------------\n+\n+      procedure Check_Iterator_Functions is\n+         Default : Entity_Id;\n+\n+         function Valid_Default_Iterator (Subp : Entity_Id) return Boolean;\n+         --  Check one possible interpretation.\n+\n+         ----------------------------\n+         -- Valid_Default_Iterator --\n+         ----------------------------\n+\n+         function Valid_Default_Iterator (Subp : Entity_Id) return Boolean is\n+            Formal : Entity_Id;\n+\n+         begin\n+            if not Check_Primitive_Function (Subp) then\n+               return False;\n+            else\n+               Formal := First_Formal (Subp);\n+            end if;\n+\n+            Formal := Next_Formal (Formal);\n+\n+            --  I don't see why the if is required here, we will return\n+            --  True anyway if Present (Formal) is false on first loop ???\n+\n+            if No (Formal) then\n+               return True;\n+\n+            else\n+               while Present (Formal) loop\n+                  if No (Expression (Parent (Formal))) then\n+                     return False;\n+                  end if;\n+\n+                  Next_Formal (Formal);\n+               end loop;\n+            end if;\n+\n+            return True;\n+         end Valid_Default_Iterator;\n+\n+      --  Start of processing for Check_Iterator_Functions\n+\n+      begin\n+         Analyze (Expr);\n+\n+         if not Is_Entity_Name (Expr) then\n+            Error_Msg_N (\"aspect Iterator must be a function name\", Expr);\n+         end if;\n+\n+         if not Is_Overloaded (Expr) then\n+            if not Check_Primitive_Function (Entity (Expr)) then\n+               Error_Msg_NE\n+                 (\"aspect Indexing requires a function that applies to type&\",\n+                   Entity (Expr), Ent);\n+            end if;\n+\n+            if not Valid_Default_Iterator (Entity (Expr)) then\n+               Error_Msg_N (\"improper function for default iterator\", Expr);\n+            end if;\n+\n+         else\n+            Default := Empty;\n+            declare\n+               I : Interp_Index;\n+               It : Interp;\n+\n+            begin\n+               Get_First_Interp (Expr, I, It);\n+               while Present (It.Nam) loop\n+                  if not Check_Primitive_Function (It.Nam)\n+                    or else Valid_Default_Iterator (It.Nam)\n+                  then\n+                     Remove_Interp (I);\n+\n+                  elsif Present (Default) then\n+                     Error_Msg_N (\"default iterator must be unique\", Expr);\n+\n+                  else\n+                     Default := It.Nam;\n+                  end if;\n+\n+                  Get_Next_Interp (I, It);\n+               end loop;\n+            end;\n+\n+            if Present (Default) then\n+               Set_Entity (Expr, Default);\n+               Set_Is_Overloaded (Expr, False);\n+            end if;\n+         end if;\n+      end Check_Iterator_Functions;\n+\n+      -------------------------------\n+      -- Check_Primitive_Function  --\n+      -------------------------------\n+\n+      function Check_Primitive_Function (Subp : Entity_Id) return Boolean is\n+         Ctrl : Entity_Id;\n+\n+      begin\n+         if Ekind (Subp) /= E_Function then\n+            return False;\n+         end if;\n+\n+         if No (First_Formal (Subp)) then\n+            return False;\n+         else\n+            Ctrl := Etype (First_Formal (Subp));\n+         end if;\n+\n+         if Ctrl = Ent\n+           or else Ctrl = Class_Wide_Type (Ent)\n+           or else\n+             (Ekind (Ctrl) = E_Anonymous_Access_Type\n+               and then\n+                 (Designated_Type (Ctrl) = Ent\n+                   or else Designated_Type (Ctrl) = Class_Wide_Type (Ent)))\n+         then\n+            null;\n+\n+         else\n+            return False;\n+         end if;\n+\n+         return True;\n+      end Check_Primitive_Function;\n+\n       ----------------------\n       -- Duplicate_Clause --\n       ----------------------\n@@ -2385,6 +2502,39 @@ package body Sem_Ch13 is\n          when Attribute_Constant_Indexing =>\n             Check_Indexing_Functions;\n \n+         ----------------------\n+         -- Default_Iterator --\n+         ----------------------\n+\n+         when Attribute_Default_Iterator =>  Default_Iterator : declare\n+            Func : Entity_Id;\n+\n+         begin\n+            if not Is_Tagged_Type (U_Ent) then\n+               Error_Msg_N\n+                 (\"aspect Default_Iterator applies to  tagged type\", Nam);\n+            end if;\n+\n+            Check_Iterator_Functions;\n+\n+            Analyze (Expr);\n+\n+            if not Is_Entity_Name (Expr)\n+              or else Ekind (Entity (Expr)) /= E_Function\n+            then\n+               Error_Msg_N (\"aspect Iterator must be a function\", Expr);\n+            else\n+               Func := Entity (Expr);\n+            end if;\n+\n+            if No (First_Formal (Func))\n+              or else Etype (First_Formal (Func)) /= U_Ent\n+            then\n+               Error_Msg_NE\n+                 (\"Default Iterator must be a primitive of&\", Func, U_Ent);\n+            end if;\n+         end Default_Iterator;\n+\n          ------------------\n          -- External_Tag --\n          ------------------\n@@ -2431,9 +2581,10 @@ package body Sem_Ch13 is\n \n          when Attribute_Implicit_Dereference =>\n \n-            --  Legality checks already performed above\n+            --  Legality checks already performed at the point of\n+            --  the type declaration, aspect is not delayed.\n \n-            null;   --  TBD???\n+            null;\n \n          -----------\n          -- Input --\n@@ -2443,6 +2594,19 @@ package body Sem_Ch13 is\n             Analyze_Stream_TSS_Definition (TSS_Stream_Input);\n             Set_Has_Specified_Stream_Input (Ent);\n \n+         ----------------------\n+         -- Iterator_Element --\n+         ----------------------\n+\n+         when Attribute_Iterator_Element =>\n+            Analyze (Expr);\n+\n+            if not Is_Entity_Name (Expr)\n+              or else not Is_Type (Entity (Expr))\n+            then\n+               Error_Msg_N (\"aspect Iterator_Element must be a type\", Expr);\n+            end if;\n+\n          -------------------\n          -- Machine_Radix --\n          -------------------\n@@ -3546,6 +3710,7 @@ package body Sem_Ch13 is\n                if Nkind (Ritem) = N_Aspect_Specification\n                  and then Entity (Ritem) = E\n                  and then Is_Delayed_Aspect (Ritem)\n+                 and then Scope (E) = Current_Scope\n                then\n                   Check_Aspect_At_Freeze_Point (Ritem);\n                end if;\n@@ -5482,7 +5647,7 @@ package body Sem_Ch13 is\n       Ident : constant Node_Id   := Identifier (ASN);\n \n       Freeze_Expr : constant Node_Id := Expression (ASN);\n-      --  Preanalyzed expression from call to Check_Aspect_At_Freeze_Point\n+      --  Expression from call to Check_Aspect_At_Freeze_Point\n \n       End_Decl_Expr : constant Node_Id := Entity (Ident);\n       --  Expression to be analyzed at end of declarations\n@@ -5512,11 +5677,20 @@ package body Sem_Ch13 is\n          Err := Entity (End_Decl_Expr) /= Entity (Freeze_Expr);\n \n       elsif A_Id = Aspect_Variable_Indexing or else\n-            A_Id = Aspect_Constant_Indexing\n+            A_Id = Aspect_Constant_Indexing or else\n+            A_Id = Aspect_Default_Iterator  or else\n+            A_Id = Aspect_Iterator_Element\n       then\n          Analyze (End_Decl_Expr);\n          Analyze (Aspect_Rep_Item (ASN));\n-         Err := Entity (End_Decl_Expr) /= Entity (Freeze_Expr);\n+\n+         --  If the end of declarations comes before any other freeze\n+         --  point, the Freeze_Expr is not analyzed: no check needed.\n+\n+         Err :=\n+           Analyzed (Freeze_Expr)\n+             and then not In_Instance\n+             and then Entity (End_Decl_Expr) /= Entity (Freeze_Expr);\n \n       --  All other cases\n "}]}