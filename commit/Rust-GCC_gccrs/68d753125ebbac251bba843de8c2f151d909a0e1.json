{"sha": "68d753125ebbac251bba843de8c2f151d909a0e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjhkNzUzMTI1ZWJiYWMyNTFiYmE4NDNkZThjMmYxNTFkOTA5YTBlMQ==", "commit": {"author": {"name": "John F. Carr", "email": "jfc@mit.edu", "date": "1997-12-12T00:27:40Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-12-12T00:27:40Z"}, "message": "rtl.h (global_rtl): New variable, replacing separate variables for commonly used rtl.\n\n        * rtl.h (global_rtl): New variable, replacing separate variables for\n        commonly used rtl.\n        (const_int_rtx): Now array of rtx_def, not rtx.\n        * emit-rtl.c: Update for new rtl data structures.\n        * genattrtab.c: Define global_rtl.\n\nFrom-SVN: r17049", "tree": {"sha": "77b4b39b2226b5667df7adc519da0ea92872fa27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77b4b39b2226b5667df7adc519da0ea92872fa27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68d753125ebbac251bba843de8c2f151d909a0e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68d753125ebbac251bba843de8c2f151d909a0e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68d753125ebbac251bba843de8c2f151d909a0e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68d753125ebbac251bba843de8c2f151d909a0e1/comments", "author": {"login": "VoxSciurorum", "id": 60116679, "node_id": "MDQ6VXNlcjYwMTE2Njc5", "avatar_url": "https://avatars.githubusercontent.com/u/60116679?v=4", "gravatar_id": "", "url": "https://api.github.com/users/VoxSciurorum", "html_url": "https://github.com/VoxSciurorum", "followers_url": "https://api.github.com/users/VoxSciurorum/followers", "following_url": "https://api.github.com/users/VoxSciurorum/following{/other_user}", "gists_url": "https://api.github.com/users/VoxSciurorum/gists{/gist_id}", "starred_url": "https://api.github.com/users/VoxSciurorum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/VoxSciurorum/subscriptions", "organizations_url": "https://api.github.com/users/VoxSciurorum/orgs", "repos_url": "https://api.github.com/users/VoxSciurorum/repos", "events_url": "https://api.github.com/users/VoxSciurorum/events{/privacy}", "received_events_url": "https://api.github.com/users/VoxSciurorum/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "44517326d6488d36f18fda182f0b0b7bf99d34a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44517326d6488d36f18fda182f0b0b7bf99d34a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44517326d6488d36f18fda182f0b0b7bf99d34a6"}], "stats": {"total": 206, "additions": 112, "deletions": 94}, "files": [{"sha": "8d44e4f3b8ae078c342e3a04f13a901e29077a4e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d753125ebbac251bba843de8c2f151d909a0e1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d753125ebbac251bba843de8c2f151d909a0e1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=68d753125ebbac251bba843de8c2f151d909a0e1", "patch": "@@ -1,3 +1,11 @@\n+Thu Dec 11 17:23:48 1997  John F. Carr  <jfc@mit.edu>\n+\n+\t* rtl.h (global_rtl): New variable, replacing separate variables for\n+\tcommonly used rtl.\n+\t(const_int_rtx): Now array of rtx_def, not rtx.\n+\t* emit-rtl.c: Update for new rtl data structures.\n+\t* genattrtab.c: Define global_rtl.\n+\n Thu Dec 11 15:50:29 1997 David Edelsohn  <edelsohn@mhpcc.edu>\n \n \t* configure.in ({rs6000,powerpc}-*-*): Enable Haifa scheduler by"}, {"sha": "c8ee89c7ccbe0cf40924ce775fdcc281607ca05e", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 53, "deletions": 69, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d753125ebbac251bba843de8c2f151d909a0e1/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d753125ebbac251bba843de8c2f151d909a0e1/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=68d753125ebbac251bba843de8c2f151d909a0e1", "patch": "@@ -111,21 +111,28 @@ static int no_line_numbers;\n    All of these except perhaps the floating-point CONST_DOUBLEs\n    are unique; no other rtx-object will be equal to any of these.  */\n \n-rtx pc_rtx;\t\t\t/* (PC) */\n-rtx cc0_rtx;\t\t\t/* (CC0) */\n-rtx cc1_rtx;\t\t\t/* (CC1) (not actually used nowadays) */\n-rtx const0_rtx;\t\t\t/* (CONST_INT 0) */\n-rtx const1_rtx;\t\t\t/* (CONST_INT 1) */\n-rtx const2_rtx;\t\t\t/* (CONST_INT 2) */\n-rtx constm1_rtx;\t\t/* (CONST_INT -1) */\n-rtx const_true_rtx;\t\t/* (CONST_INT STORE_FLAG_VALUE) */\n+struct _global_rtl global_rtl =\n+{\n+  {PC, VOIDmode},\t\t\t/* pc_rtx */\n+  {CC0, VOIDmode},\t\t\t/* cc0_rtx */\n+  {REG},\t\t\t\t/* stack_pointer_rtx */\n+  {REG},\t\t\t\t/* frame_pointer_rtx */\n+  {REG},\t\t\t\t/* hard_frame_pointer_rtx */\n+  {REG},\t\t\t\t/* arg_pointer_rtx */\n+  {REG},\t\t\t\t/* virtual_incoming_args_rtx */\n+  {REG},\t\t\t\t/* virtual_stack_vars_rtx */\n+  {REG},\t\t\t\t/* virtual_stack_dynamic_rtx */\n+  {REG},\t\t\t\t/* virtual_outgoing_args_rtx */\n+};\n \n /* We record floating-point CONST_DOUBLEs in each floating-point mode for\n    the values of 0, 1, and 2.  For the integer entries and VOIDmode, we\n    record a copy of const[012]_rtx.  */\n \n rtx const_tiny_rtx[3][(int) MAX_MACHINE_MODE];\n \n+rtx const_true_rtx;\n+\n REAL_VALUE_TYPE dconst0;\n REAL_VALUE_TYPE dconst1;\n REAL_VALUE_TYPE dconst2;\n@@ -149,10 +156,6 @@ REAL_VALUE_TYPE dconstm1;\n \n    In an inline procedure, the stack and frame pointer rtxs may not be\n    used for anything else.  */\n-rtx stack_pointer_rtx;\t\t/* (REG:Pmode STACK_POINTER_REGNUM) */\n-rtx frame_pointer_rtx;\t\t/* (REG:Pmode FRAME_POINTER_REGNUM) */\n-rtx hard_frame_pointer_rtx;\t/* (REG:Pmode HARD_FRAME_POINTER_REGNUM) */\n-rtx arg_pointer_rtx;\t\t/* (REG:Pmode ARG_POINTER_REGNUM) */\n rtx struct_value_rtx;\t\t/* (REG:Pmode STRUCT_VALUE_REGNUM) */\n rtx struct_value_incoming_rtx;\t/* (REG:Pmode STRUCT_VALUE_INCOMING_REGNUM) */\n rtx static_chain_rtx;\t\t/* (REG:Pmode STATIC_CHAIN_REGNUM) */\n@@ -163,19 +166,12 @@ rtx pic_offset_table_rtx;\t/* (REG:Pmode PIC_OFFSET_TABLE_REGNUM) */\n    See for instance the MIPS port.  */\n rtx return_address_pointer_rtx;\t/* (REG:Pmode RETURN_ADDRESS_POINTER_REGNUM) */\n \n-rtx virtual_incoming_args_rtx;\t/* (REG:Pmode VIRTUAL_INCOMING_ARGS_REGNUM) */\n-rtx virtual_stack_vars_rtx;\t/* (REG:Pmode VIRTUAL_STACK_VARS_REGNUM) */\n-rtx virtual_stack_dynamic_rtx;\t/* (REG:Pmode VIRTUAL_STACK_DYNAMIC_REGNUM) */\n-rtx virtual_outgoing_args_rtx;\t/* (REG:Pmode VIRTUAL_OUTGOING_ARGS_REGNUM) */\n-\n /* We make one copy of (const_int C) where C is in\n    [- MAX_SAVED_CONST_INT, MAX_SAVED_CONST_INT]\n    to save space during the compilation and simplify comparisons of\n    integers.  */\n \n-#define MAX_SAVED_CONST_INT 64\n-\n-static rtx const_int_rtx[MAX_SAVED_CONST_INT * 2 + 1];\n+struct rtx_def const_int_rtx[MAX_SAVED_CONST_INT * 2 + 1];\n \n /* The ends of the doubly-linked chain of rtl for the current function.\n    Both are reset to null at the start of rtl generation for the function.\n@@ -314,10 +310,12 @@ gen_rtx VPROTO((enum rtx_code code, enum machine_mode mode, ...))\n       HOST_WIDE_INT arg = va_arg (p, HOST_WIDE_INT);\n \n       if (arg >= - MAX_SAVED_CONST_INT && arg <= MAX_SAVED_CONST_INT)\n-\treturn const_int_rtx[arg + MAX_SAVED_CONST_INT];\n+\treturn &const_int_rtx[arg + MAX_SAVED_CONST_INT];\n \n+#if STORE_FLAG_VALUE != 1 && STORE_FLAG_VALUE != -1\n       if (const_true_rtx && arg == STORE_FLAG_VALUE)\n \treturn const_true_rtx;\n+#endif\n \n       rt_val = rtx_alloc (code);\n       INTVAL (rt_val) = arg;\n@@ -340,16 +338,16 @@ gen_rtx VPROTO((enum rtx_code code, enum machine_mode mode, ...))\n \t Also don't do this when we are making new REGs in reload,\n \t since we don't want to get confused with the real pointers.  */\n \n-      if (frame_pointer_rtx && regno == FRAME_POINTER_REGNUM && mode == Pmode\n+      if (regno == FRAME_POINTER_REGNUM && mode == Pmode\n \t  && ! reload_in_progress)\n \treturn frame_pointer_rtx;\n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n-      if (hard_frame_pointer_rtx && regno == HARD_FRAME_POINTER_REGNUM\n-\t  && mode == Pmode && ! reload_in_progress)\n+      if (regno == HARD_FRAME_POINTER_REGNUM && mode == Pmode\n+\t  && ! reload_in_progress)\n \treturn hard_frame_pointer_rtx;\n #endif\n #if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM && HARD_FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n-      if (arg_pointer_rtx && regno == ARG_POINTER_REGNUM && mode == Pmode\n+      if (regno == ARG_POINTER_REGNUM && mode == Pmode\n \t  && ! reload_in_progress)\n \treturn arg_pointer_rtx;\n #endif\n@@ -358,7 +356,7 @@ gen_rtx VPROTO((enum rtx_code code, enum machine_mode mode, ...))\n \t  && mode == Pmode && ! reload_in_progress)\n \treturn return_address_pointer_rtx;\n #endif\n-      if (stack_pointer_rtx && regno == STACK_POINTER_REGNUM && mode == Pmode\n+      if (regno == STACK_POINTER_REGNUM && mode == Pmode\n \t  && ! reload_in_progress)\n \treturn stack_pointer_rtx;\n       else\n@@ -3360,26 +3358,18 @@ init_emit_once (line_numbers)\n \n   /* Create the unique rtx's for certain rtx codes and operand values.  */\n \n-  pc_rtx = gen_rtx (PC, VOIDmode);\n-  cc0_rtx = gen_rtx (CC0, VOIDmode);\n-\n-  /* Don't use gen_rtx here since gen_rtx in this case\n-     tries to use these variables.  */\n   for (i = - MAX_SAVED_CONST_INT; i <= MAX_SAVED_CONST_INT; i++)\n     {\n-      const_int_rtx[i + MAX_SAVED_CONST_INT] = rtx_alloc (CONST_INT);\n-      PUT_MODE (const_int_rtx[i + MAX_SAVED_CONST_INT], VOIDmode);\n-      INTVAL (const_int_rtx[i + MAX_SAVED_CONST_INT]) = i;\n+      PUT_CODE (&const_int_rtx[i + MAX_SAVED_CONST_INT], CONST_INT);\n+      PUT_MODE (&const_int_rtx[i + MAX_SAVED_CONST_INT], VOIDmode);\n+      INTVAL (&const_int_rtx[i + MAX_SAVED_CONST_INT]) = i;\n     }\n \n-  /* These four calls obtain some of the rtx expressions made above.  */\n-  const0_rtx = GEN_INT (0);\n-  const1_rtx = GEN_INT (1);\n-  const2_rtx = GEN_INT (2);\n-  constm1_rtx = GEN_INT (-1);\n-\n-  /* This will usually be one of the above constants, but may be a new rtx.  */\n-  const_true_rtx = GEN_INT (STORE_FLAG_VALUE);\n+  if (STORE_FLAG_VALUE >= - MAX_SAVED_CONST_INT\n+      && STORE_FLAG_VALUE <= MAX_SAVED_CONST_INT)\n+    const_true_rtx = &const_int_rtx[STORE_FLAG_VALUE + MAX_SAVED_CONST_INT];\n+  else\n+    const_true_rtx = gen_rtx (CONST_INT, VOIDmode, STORE_FLAG_VALUE);\n \n   dconst0 = REAL_VALUE_ATOF (\"0\", DFmode);\n   dconst1 = REAL_VALUE_ATOF (\"1\", DFmode);\n@@ -3420,40 +3410,34 @@ init_emit_once (line_numbers)\n        mode = GET_MODE_WIDER_MODE (mode))\n     const_tiny_rtx[0][(int) mode] = const0_rtx;\n \n-  stack_pointer_rtx = gen_rtx (REG, Pmode, STACK_POINTER_REGNUM);\n-  frame_pointer_rtx = gen_rtx (REG, Pmode, FRAME_POINTER_REGNUM);\n \n-  if (HARD_FRAME_POINTER_REGNUM == FRAME_POINTER_REGNUM)\n-    hard_frame_pointer_rtx = frame_pointer_rtx;\n-  else\n-    hard_frame_pointer_rtx = gen_rtx (REG, Pmode, HARD_FRAME_POINTER_REGNUM);\n-  \n-  if (FRAME_POINTER_REGNUM == ARG_POINTER_REGNUM)\n-    arg_pointer_rtx = frame_pointer_rtx;\n-  else if (HARD_FRAME_POINTER_REGNUM == ARG_POINTER_REGNUM)\n-    arg_pointer_rtx = hard_frame_pointer_rtx;\n-  else if (STACK_POINTER_REGNUM == ARG_POINTER_REGNUM)\n-    arg_pointer_rtx = stack_pointer_rtx;\n-  else\n-    arg_pointer_rtx = gen_rtx (REG, Pmode, ARG_POINTER_REGNUM);\n+  /* Assign register numbers to the globally defined register rtx.\n+     This must be done at runtime because the register number field\n+     is in a union and some compilers can't initialize unions.  */\n+\n+  REGNO (stack_pointer_rtx) = STACK_POINTER_REGNUM;\n+  PUT_MODE (stack_pointer_rtx, Pmode);\n+  REGNO (frame_pointer_rtx) = FRAME_POINTER_REGNUM;\n+  PUT_MODE (frame_pointer_rtx, Pmode);\n+  REGNO (hard_frame_pointer_rtx) = HARD_FRAME_POINTER_REGNUM;\n+  PUT_MODE (hard_frame_pointer_rtx, Pmode);\n+  REGNO (arg_pointer_rtx) = ARG_POINTER_REGNUM;\n+  PUT_MODE (arg_pointer_rtx, Pmode);\n+\n+  REGNO (virtual_incoming_args_rtx) = VIRTUAL_INCOMING_ARGS_REGNUM;\n+  PUT_MODE (virtual_incoming_args_rtx, Pmode);\n+  REGNO (virtual_stack_vars_rtx) = VIRTUAL_STACK_VARS_REGNUM;\n+  PUT_MODE (virtual_stack_vars_rtx, Pmode);\n+  REGNO (virtual_stack_dynamic_rtx) = VIRTUAL_STACK_DYNAMIC_REGNUM;\n+  PUT_MODE (virtual_stack_dynamic_rtx, Pmode);\n+  REGNO (virtual_outgoing_args_rtx) = VIRTUAL_OUTGOING_ARGS_REGNUM;\n+  PUT_MODE (virtual_outgoing_args_rtx, Pmode);\n \n #ifdef RETURN_ADDRESS_POINTER_REGNUM\n   return_address_pointer_rtx = gen_rtx (REG, Pmode,\n \t\t\t\t\tRETURN_ADDRESS_POINTER_REGNUM);\n #endif\n \n-  /* Create the virtual registers.  Do so here since the following objects\n-     might reference them.  */\n-\n-  virtual_incoming_args_rtx = gen_rtx (REG, Pmode,\n-\t\t\t\t       VIRTUAL_INCOMING_ARGS_REGNUM);\n-  virtual_stack_vars_rtx = gen_rtx (REG, Pmode,\n-\t\t\t\t    VIRTUAL_STACK_VARS_REGNUM);\n-  virtual_stack_dynamic_rtx = gen_rtx (REG, Pmode,\n-\t\t\t\t       VIRTUAL_STACK_DYNAMIC_REGNUM);\n-  virtual_outgoing_args_rtx = gen_rtx (REG, Pmode,\n-\t\t\t\t       VIRTUAL_OUTGOING_ARGS_REGNUM);\n-\n #ifdef STRUCT_VALUE\n   struct_value_rtx = STRUCT_VALUE;\n #else"}, {"sha": "ac5cf0a31c970e767edcbf11ca58e100cd395c5b", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d753125ebbac251bba843de8c2f151d909a0e1/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d753125ebbac251bba843de8c2f151d909a0e1/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=68d753125ebbac251bba843de8c2f151d909a0e1", "patch": "@@ -366,8 +366,7 @@ static char *alternative_name;\n /* These are referenced by rtlanal.c and hence need to be defined somewhere.\n    They won't actually be used.  */\n \n-rtx frame_pointer_rtx, hard_frame_pointer_rtx, stack_pointer_rtx;\n-rtx arg_pointer_rtx;\n+struct _global_rtl global_rtl;\n \n static rtx attr_rtx\t\tPVPROTO((enum rtx_code, ...));\n #ifdef HAVE_VPRINTF\n@@ -493,8 +492,6 @@ struct attr_hash *attr_hash_table[RTL_HASH_SIZE];\n    codes are made.  */\n #define RTL_HASH(RTL) ((HOST_WIDE_INT) (RTL) & 0777777)\n \n-rtx pc_rtx;\n-\n /* Add an entry to the hash table for RTL with hash code HASHCODE.  */\n \n static void\n@@ -5620,11 +5617,6 @@ main (argc, argv)\n \n   init_rtl ();\n \n-  /* We don't use this, but it is referenced in rtlanal.c. \n-     Set it up correctly just in case someone tries to use it someday.  */\n-  pc_rtx = rtx_alloc (PC);\n-  PUT_MODE (pc_rtx, VOIDmode);\n-\n   /* Set up true and false rtx's */\n   true_rtx = rtx_alloc (CONST_INT);\n   XWINT (true_rtx, 0) = 1;"}, {"sha": "667cab72c5baa30e0cb3c326ab13e7156e164c04", "filename": "gcc/rtl.h", "status": "modified", "additions": 50, "deletions": 16, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d753125ebbac251bba843de8c2f151d909a0e1/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d753125ebbac251bba843de8c2f151d909a0e1/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=68d753125ebbac251bba843de8c2f151d909a0e1", "patch": "@@ -886,12 +886,16 @@ extern enum reg_class reg_alternate_class PROTO((int));\n extern rtx get_first_nonparm_insn\tPROTO((void));\n \n /* Standard pieces of rtx, to be substituted directly into things.  */\n-extern rtx pc_rtx;\n-extern rtx cc0_rtx;\n-extern rtx const0_rtx;\n-extern rtx const1_rtx;\n-extern rtx const2_rtx;\n-extern rtx constm1_rtx;\n+#define pc_rtx\t\t(&global_rtl.pc_val)\n+#define cc0_rtx\t\t(&global_rtl.cc0_val)\n+\n+#define MAX_SAVED_CONST_INT 64\n+extern struct rtx_def const_int_rtx[MAX_SAVED_CONST_INT * 2 + 1];\n+\n+#define const0_rtx\t(&const_int_rtx[MAX_SAVED_CONST_INT])\n+#define const1_rtx\t(&const_int_rtx[MAX_SAVED_CONST_INT+1])\n+#define const2_rtx\t(&const_int_rtx[MAX_SAVED_CONST_INT+2])\n+#define constm1_rtx\t(&const_int_rtx[MAX_SAVED_CONST_INT-1])\n extern rtx const_true_rtx;\n \n extern rtx const_tiny_rtx[3][(int) MAX_MACHINE_MODE];\n@@ -906,13 +910,24 @@ extern rtx const_tiny_rtx[3][(int) MAX_MACHINE_MODE];\n #define CONST1_RTX(MODE) (const_tiny_rtx[1][(int) (MODE)])\n #define CONST2_RTX(MODE) (const_tiny_rtx[2][(int) (MODE)])\n \n+extern struct _global_rtl\n+{\n+  struct rtx_def pc_val, cc0_val;\n+  struct rtx_def stack_pointer_val, frame_pointer_val;\n+  struct rtx_def hard_frame_pointer_val;\n+  struct rtx_def arg_pointer_val;\n+  struct rtx_def virtual_incoming_args_val;\n+  struct rtx_def virtual_stack_vars_val;\n+  struct rtx_def virtual_stack_dynamic_val;\n+  struct rtx_def virtual_outgoing_args_val;\n+} global_rtl;\n+\n /* All references to certain hard regs, except those created\n    by allocating pseudo regs into them (when that's possible),\n    go through these unique rtx objects.  */\n-extern rtx stack_pointer_rtx;\n-extern rtx frame_pointer_rtx;\n-extern rtx hard_frame_pointer_rtx;\n-extern rtx arg_pointer_rtx;\n+#define stack_pointer_rtx\t(&global_rtl.stack_pointer_val)\n+#define frame_pointer_rtx\t(&global_rtl.frame_pointer_val)\n+\n extern rtx pic_offset_table_rtx;\n extern rtx struct_value_rtx;\n extern rtx struct_value_incoming_rtx;\n@@ -929,6 +944,25 @@ extern rtx static_chain_incoming_rtx;\n #define HARD_FRAME_POINTER_REGNUM FRAME_POINTER_REGNUM\n #endif\n \n+/* For register elimination to work properly these hard_frame_pointer_rtx,\n+   frame_pointer_rtx, and arg_pointer_rtx must be the same if they refer to\n+   the same register.  */\n+#if HARD_FRAME_POINTER_REGNUM == FRAME_POINTER_REGNUM\n+#define hard_frame_pointer_rtx\t(&global_rtl.frame_pointer_val)\n+#else\n+#define hard_frame_pointer_rtx\t(&global_rtl.hard_frame_pointer_val)\n+#endif\n+\n+#if FRAME_POINTER_REGNUM == ARG_POINTER_REGNUM\n+#define arg_pointer_rtx\t\t(&global_rtl.frame_pointer_val)\n+#else\n+#if HARD_POINTER_REGNUM == ARG_POINTER_REGNUM\n+#define arg_pointer_rtx\t\t(&global_rtl.hard_frame_pointer_val)\n+#else\n+#define arg_pointer_rtx\t\t(&global_rtl.arg_pointer_val)\n+#endif\n+#endif\n+\n /* Virtual registers are used during RTL generation to refer to locations into\n    the stack frame when the actual location isn't known until RTL generation\n    is complete.  The routine instantiate_virtual_regs replaces these with\n@@ -941,31 +975,31 @@ extern rtx static_chain_incoming_rtx;\n    either by the caller or by the callee when pretending it was passed by the\n    caller.  */\n \n-extern rtx virtual_incoming_args_rtx;\n+#define virtual_incoming_args_rtx (&global_rtl.virtual_incoming_args_val)\n \n #define VIRTUAL_INCOMING_ARGS_REGNUM\t(FIRST_VIRTUAL_REGISTER)\n \n /* If FRAME_GROWS_DOWNWARD, this points to immediately above the first\n    variable on the stack.  Otherwise, it points to the first variable on\n    the stack.  */\n \n-extern rtx virtual_stack_vars_rtx;\n+#define virtual_stack_vars_rtx\t(&global_rtl.virtual_stack_vars_val)\n \n #define VIRTUAL_STACK_VARS_REGNUM\t((FIRST_VIRTUAL_REGISTER) + 1)\n \n /* This points to the location of dynamically-allocated memory on the stack\n    immediately after the stack pointer has been adjusted by the amount\n    desired.  */\n \n-extern rtx virtual_stack_dynamic_rtx;\n+#define virtual_stack_dynamic_rtx\t(&global_rtl.virtual_stack_dynamic_val)\n \n #define VIRTUAL_STACK_DYNAMIC_REGNUM\t((FIRST_VIRTUAL_REGISTER) + 2)\n \n /* This points to the location in the stack at which outgoing arguments should\n    be written when the stack is pre-pushed (arguments pushed using push\n    insns always use sp).  */\n \n-extern rtx virtual_outgoing_args_rtx;\n+#define virtual_outgoing_args_rtx\t(&global_rtl.virtual_outgoing_args_val)\n \n #define VIRTUAL_OUTGOING_ARGS_REGNUM\t((FIRST_VIRTUAL_REGISTER) + 3)\n \n@@ -1015,8 +1049,8 @@ extern int cse_not_expected;\n    Allocated in parallel with regno_pointer_flag.  */\n extern rtx *regno_reg_rtx;\n \n-/* Vector indexed by regno; contains the alignment in bytes for a\n-   register that contains a pointer, if known.  */\n+/* Vector indexed by regno; contain the alignment in bytes and type\n+   pointed to for a register that contains a pointer, if known.  */\n extern char *regno_pointer_align;\n #define REGNO_POINTER_ALIGN(REGNO) regno_pointer_align[REGNO]\n "}]}