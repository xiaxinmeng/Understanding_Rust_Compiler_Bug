{"sha": "02fcaf412ae9508b75efa9602cd4ac58bc63d6a4", "node_id": "C_kwDOANBUbNoAKDAyZmNhZjQxMmFlOTUwOGI3NWVmYTk2MDJjZDRhYzU4YmM2M2Q2YTQ", "commit": {"author": {"name": "Christoph M\u00fcllner", "email": "christoph.muellner@vrull.eu", "date": "2023-02-24T05:18:04Z"}, "committer": {"name": "Philipp Tomsich", "email": "philipp.tomsich@vrull.eu", "date": "2023-03-15T09:01:17Z"}, "message": "riscv: thead: Add support for the XTheadMemPair ISA extension\n\nThe XTheadMemPair ISA extension allows to pair two loads or stores:\n* th.ldd (2x LD)\n* th.lwd (2x LW)\n* th.lwud (2x LWU)\n* th.sdd (2x SD)\n* th.swd (2x SW)\n\nThe displacement of these instructions is quite limited:\n* Displacement := imm2 << shamt\n* imm2 is a 2-bit unsigned value {0..3}\n* shamt is 4 for th.ldd/th.sdd and 3 otherwise\nBut even with this small displacement we can identify many candidates.\n\nThe merge of the two loads/stores is realized in form of peephole2\npasses that support instruction reordering.\nThe CFA expansion (save/restore registers on/from stack) is not\nprocessed by the peephole2 pass and, therefore, needs special-treatment.\nMany ideas of this patch are inspired by similar/equal approaches\nin other backends.\n\ngcc/ChangeLog:\n\n\t* config.gcc: Add thead.o to RISC-V extra_objs.\n\t* config/riscv/peephole.md: Add mempair peephole passes.\n\t* config/riscv/riscv-protos.h (riscv_split_64bit_move_p): New\n\tprototype.\n\t(th_mempair_operands_p): Likewise.\n\t(th_mempair_order_operands): Likewise.\n\t(th_mempair_prepare_save_restore_operands): Likewise.\n\t(th_mempair_save_restore_regs): Likewise.\n\t(th_mempair_output_move): Likewise.\n\t* config/riscv/riscv.cc (riscv_save_reg): Move code.\n\t(riscv_restore_reg): Move code.\n\t(riscv_for_each_saved_reg): Add code to emit mempair insns.\n\t* config/riscv/t-riscv: Add thead.cc.\n\t* config/riscv/thead.md (*th_mempair_load_<GPR:mode>2):\n\tNew insn.\n\t(*th_mempair_store_<GPR:mode>2): Likewise.\n\t(*th_mempair_load_extendsidi2): Likewise.\n\t(*th_mempair_load_zero_extendsidi2): Likewise.\n\t* config/riscv/thead.cc: New file.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/riscv/xtheadmempair-1.c: New test.\n\t* gcc.target/riscv/xtheadmempair-2.c: New test.\n\t* gcc.target/riscv/xtheadmempair-3.c: New test.\n\nSigned-off-by: Christoph M\u00fcllner <christoph.muellner@vrull.eu>", "tree": {"sha": "7fd244141f5999622af0c620f01ba59d0d549924", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7fd244141f5999622af0c620f01ba59d0d549924"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02fcaf412ae9508b75efa9602cd4ac58bc63d6a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02fcaf412ae9508b75efa9602cd4ac58bc63d6a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02fcaf412ae9508b75efa9602cd4ac58bc63d6a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02fcaf412ae9508b75efa9602cd4ac58bc63d6a4/comments", "author": {"login": "cmuellner", "id": 92810, "node_id": "MDQ6VXNlcjkyODEw", "avatar_url": "https://avatars.githubusercontent.com/u/92810?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cmuellner", "html_url": "https://github.com/cmuellner", "followers_url": "https://api.github.com/users/cmuellner/followers", "following_url": "https://api.github.com/users/cmuellner/following{/other_user}", "gists_url": "https://api.github.com/users/cmuellner/gists{/gist_id}", "starred_url": "https://api.github.com/users/cmuellner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cmuellner/subscriptions", "organizations_url": "https://api.github.com/users/cmuellner/orgs", "repos_url": "https://api.github.com/users/cmuellner/repos", "events_url": "https://api.github.com/users/cmuellner/events{/privacy}", "received_events_url": "https://api.github.com/users/cmuellner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ptomsich", "id": 14983582, "node_id": "MDQ6VXNlcjE0OTgzNTgy", "avatar_url": "https://avatars.githubusercontent.com/u/14983582?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ptomsich", "html_url": "https://github.com/ptomsich", "followers_url": "https://api.github.com/users/ptomsich/followers", "following_url": "https://api.github.com/users/ptomsich/following{/other_user}", "gists_url": "https://api.github.com/users/ptomsich/gists{/gist_id}", "starred_url": "https://api.github.com/users/ptomsich/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ptomsich/subscriptions", "organizations_url": "https://api.github.com/users/ptomsich/orgs", "repos_url": "https://api.github.com/users/ptomsich/repos", "events_url": "https://api.github.com/users/ptomsich/events{/privacy}", "received_events_url": "https://api.github.com/users/ptomsich/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75047aeb7e6af248dee47ee29bdcd57f93e7352e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75047aeb7e6af248dee47ee29bdcd57f93e7352e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75047aeb7e6af248dee47ee29bdcd57f93e7352e"}], "stats": {"total": 853, "additions": 824, "deletions": 29}, "files": [{"sha": "629d324b5efff60e340a573348a79f2b8d133a5d", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02fcaf412ae9508b75efa9602cd4ac58bc63d6a4/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02fcaf412ae9508b75efa9602cd4ac58bc63d6a4/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=02fcaf412ae9508b75efa9602cd4ac58bc63d6a4", "patch": "@@ -531,6 +531,7 @@ riscv*)\n \tcpu_type=riscv\n \textra_objs=\"riscv-builtins.o riscv-c.o riscv-sr.o riscv-shorten-memrefs.o riscv-selftests.o riscv-v.o riscv-vsetvl.o\"\n \textra_objs=\"${extra_objs} riscv-vector-builtins.o riscv-vector-builtins-shapes.o riscv-vector-builtins-bases.o\"\n+\textra_objs=\"${extra_objs} thead.o\"\n \td_target_objs=\"riscv-d.o\"\n \textra_headers=\"riscv_vector.h\"\n \ttarget_gtfiles=\"$target_gtfiles \\$(srcdir)/config/riscv/riscv-vector-builtins.cc\""}, {"sha": "67e7046d7e65d47165f4385d2220b2df7e504344", "filename": "gcc/config/riscv/peephole.md", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02fcaf412ae9508b75efa9602cd4ac58bc63d6a4/gcc%2Fconfig%2Friscv%2Fpeephole.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02fcaf412ae9508b75efa9602cd4ac58bc63d6a4/gcc%2Fconfig%2Friscv%2Fpeephole.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fpeephole.md?ref=02fcaf412ae9508b75efa9602cd4ac58bc63d6a4", "patch": "@@ -38,3 +38,59 @@\n {\n   operands[5] = GEN_INT (INTVAL (operands[2]) - INTVAL (operands[5]));\n })\n+\n+;; XTheadMemPair: merge two SI or DI loads\n+(define_peephole2\n+  [(set (match_operand:GPR 0 \"register_operand\" \"\")\n+\t(match_operand:GPR 1 \"memory_operand\" \"\"))\n+   (set (match_operand:GPR 2 \"register_operand\" \"\")\n+\t(match_operand:GPR 3 \"memory_operand\" \"\"))]\n+  \"TARGET_XTHEADMEMPAIR\n+  && th_mempair_operands_p (operands, true, <GPR:MODE>mode)\"\n+  [(parallel [(set (match_dup 0) (match_dup 1))\n+\t          (set (match_dup 2) (match_dup 3))])]\n+{\n+  th_mempair_order_operands (operands, true, <GPR:MODE>mode);\n+})\n+\n+;; XTheadMemPair: merge two SI or DI stores\n+(define_peephole2\n+  [(set (match_operand:GPR 0 \"memory_operand\" \"\")\n+\t(match_operand:GPR 1 \"register_operand\" \"\"))\n+   (set (match_operand:GPR 2 \"memory_operand\" \"\")\n+\t(match_operand:GPR 3 \"register_operand\" \"\"))]\n+  \"TARGET_XTHEADMEMPAIR\n+  && th_mempair_operands_p (operands, false, <GPR:MODE>mode)\"\n+  [(parallel [(set (match_dup 0) (match_dup 1))\n+              (set (match_dup 2) (match_dup 3))])]\n+{\n+  th_mempair_order_operands (operands, false, <GPR:MODE>mode);\n+})\n+\n+;; XTheadMemPair: merge two SI loads with sign-extension\n+(define_peephole2\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(sign_extend:DI (match_operand:SI 1 \"memory_operand\" \"\")))\n+   (set (match_operand:DI 2 \"register_operand\" \"\")\n+\t(sign_extend:DI (match_operand:SI 3 \"memory_operand\" \"\")))]\n+  \"TARGET_XTHEADMEMPAIR && TARGET_64BIT\n+  && th_mempair_operands_p (operands, true, SImode)\"\n+  [(parallel [(set (match_dup 0) (sign_extend:DI (match_dup 1)))\n+              (set (match_dup 2) (sign_extend:DI (match_dup 3)))])]\n+{\n+  th_mempair_order_operands (operands, true, SImode);\n+})\n+\n+;; XTheadMemPair: merge two SI loads with zero-extension\n+(define_peephole2\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(zero_extend:DI (match_operand:SI 1 \"memory_operand\" \"\")))\n+   (set (match_operand:DI 2 \"register_operand\" \"\")\n+\t(zero_extend:DI (match_operand:SI 3 \"memory_operand\" \"\")))]\n+  \"TARGET_XTHEADMEMPAIR && TARGET_64BIT\n+  && th_mempair_operands_p (operands, true, SImode)\"\n+  [(parallel [(set (match_dup 0) (zero_extend:DI (match_dup 1)))\n+              (set (match_dup 2) (zero_extend:DI (match_dup 3)))])]\n+{\n+  th_mempair_order_operands (operands, true, SImode);\n+})"}, {"sha": "78c47ece51e51cd683b3ec086d2a826b7f87ca54", "filename": "gcc/config/riscv/riscv-protos.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02fcaf412ae9508b75efa9602cd4ac58bc63d6a4/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02fcaf412ae9508b75efa9602cd4ac58bc63d6a4/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-protos.h?ref=02fcaf412ae9508b75efa9602cd4ac58bc63d6a4", "patch": "@@ -54,6 +54,7 @@ extern bool riscv_split_64bit_move_p (rtx, rtx);\n extern void riscv_split_doubleword_move (rtx, rtx);\n extern const char *riscv_output_move (rtx, rtx);\n extern const char *riscv_output_return ();\n+\n #ifdef RTX_CODE\n extern void riscv_expand_int_scc (rtx, enum rtx_code, rtx, rtx);\n extern void riscv_expand_float_scc (rtx, enum rtx_code, rtx, rtx);\n@@ -219,4 +220,17 @@ const unsigned int RISCV_BUILTIN_SHIFT = 1;\n /* Mask that selects the riscv_builtin_class part of a function code.  */\n const unsigned int RISCV_BUILTIN_CLASS = (1 << RISCV_BUILTIN_SHIFT) - 1;\n \n+/* Routines implemented in thead.cc.  */\n+extern bool th_mempair_operands_p (rtx[4], bool, machine_mode);\n+extern void th_mempair_order_operands (rtx[4], bool, machine_mode);\n+extern void th_mempair_prepare_save_restore_operands (rtx[4], bool,\n+\t\t\t\t\t\t      machine_mode,\n+\t\t\t\t\t\t      int, HOST_WIDE_INT,\n+\t\t\t\t\t\t      int, HOST_WIDE_INT);\n+extern void th_mempair_save_restore_regs (rtx[4], bool, machine_mode);\n+#ifdef RTX_CODE\n+extern const char*\n+th_mempair_output_move (rtx[4], bool, machine_mode, RTX_CODE);\n+#endif\n+\n #endif /* ! GCC_RISCV_PROTOS_H */"}, {"sha": "1db12091b5a7601d34995477a2afe1d6e595df0b", "filename": "gcc/config/riscv/riscv.cc", "status": "modified", "additions": 59, "deletions": 29, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02fcaf412ae9508b75efa9602cd4ac58bc63d6a4/gcc%2Fconfig%2Friscv%2Friscv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02fcaf412ae9508b75efa9602cd4ac58bc63d6a4/gcc%2Fconfig%2Friscv%2Friscv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.cc?ref=02fcaf412ae9508b75efa9602cd4ac58bc63d6a4", "patch": "@@ -4976,6 +4976,35 @@ riscv_set_return_address (rtx address, rtx scratch)\n   riscv_emit_move (gen_frame_mem (GET_MODE (address), slot_address), address);\n }\n \n+/* Save register REG to MEM.  Make the instruction frame-related.  */\n+\n+static void\n+riscv_save_reg (rtx reg, rtx mem)\n+{\n+  riscv_emit_move (mem, reg);\n+  riscv_set_frame_expr (riscv_frame_set (mem, reg));\n+}\n+\n+/* Restore register REG from MEM.  */\n+\n+static void\n+riscv_restore_reg (rtx reg, rtx mem)\n+{\n+  rtx insn = riscv_emit_move (reg, mem);\n+  rtx dwarf = NULL_RTX;\n+  dwarf = alloc_reg_note (REG_CFA_RESTORE, reg, dwarf);\n+\n+  if (epilogue_cfa_sp_offset && REGNO (reg) == HARD_FRAME_POINTER_REGNUM)\n+    {\n+      rtx cfa_adjust_rtx = gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t GEN_INT (epilogue_cfa_sp_offset));\n+      dwarf = alloc_reg_note (REG_CFA_DEF_CFA, cfa_adjust_rtx, dwarf);\n+    }\n+\n+  REG_NOTES (insn) = dwarf;\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+}\n+\n /* A function to save or store a register.  The first argument is the\n    register and the second is the stack slot.  */\n typedef void (*riscv_save_restore_fn) (rtx, rtx);\n@@ -5070,6 +5099,36 @@ riscv_for_each_saved_reg (poly_int64 sp_offset, riscv_save_restore_fn fn,\n \t  && riscv_is_eh_return_data_register (regno))\n \tcontinue;\n \n+      if (TARGET_XTHEADMEMPAIR)\n+\t{\n+\t  /* Get the next reg/offset pair.  */\n+\t  HOST_WIDE_INT offset2 = offset;\n+\t  unsigned int regno2 = riscv_next_saved_reg (regno, limit, &offset2);\n+\n+\t  /* Validate everything before emitting a mempair instruction.  */\n+\t  if (regno2 != INVALID_REGNUM\n+\t      && !cfun->machine->reg_is_wrapped_separately[regno2]\n+\t      && !(epilogue && !maybe_eh_return\n+\t\t   && riscv_is_eh_return_data_register (regno2)))\n+\t    {\n+\t      bool load_p = (fn == riscv_restore_reg);\n+\t      rtx operands[4];\n+\t      th_mempair_prepare_save_restore_operands (operands,\n+\t\t\t\t\t\t\tload_p, word_mode,\n+\t\t\t\t\t\t\tregno, offset,\n+\t\t\t\t\t\t\tregno2, offset2);\n+\n+\t      /* If the operands fit into a mempair insn, then emit one.  */\n+\t      if (th_mempair_operands_p (operands, load_p, word_mode))\n+\t\t{\n+\t\t  th_mempair_save_restore_regs (operands, load_p, word_mode);\n+\t\t  offset = offset2;\n+\t\t  regno = regno2;\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\t}\n+\n       riscv_save_restore_reg (word_mode, regno, offset, fn);\n     }\n \n@@ -5088,35 +5147,6 @@ riscv_for_each_saved_reg (poly_int64 sp_offset, riscv_save_restore_fn fn,\n       }\n }\n \n-/* Save register REG to MEM.  Make the instruction frame-related.  */\n-\n-static void\n-riscv_save_reg (rtx reg, rtx mem)\n-{\n-  riscv_emit_move (mem, reg);\n-  riscv_set_frame_expr (riscv_frame_set (mem, reg));\n-}\n-\n-/* Restore register REG from MEM.  */\n-\n-static void\n-riscv_restore_reg (rtx reg, rtx mem)\n-{\n-  rtx insn = riscv_emit_move (reg, mem);\n-  rtx dwarf = NULL_RTX;\n-  dwarf = alloc_reg_note (REG_CFA_RESTORE, reg, dwarf);\n-\n-  if (epilogue_cfa_sp_offset && REGNO (reg) == HARD_FRAME_POINTER_REGNUM)\n-    {\n-      rtx cfa_adjust_rtx = gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t GEN_INT (epilogue_cfa_sp_offset));\n-      dwarf = alloc_reg_note (REG_CFA_DEF_CFA, cfa_adjust_rtx, dwarf);\n-    }\n-\n-  REG_NOTES (insn) = dwarf;\n-  RTX_FRAME_RELATED_P (insn) = 1;\n-}\n-\n /* For stack frames that can't be allocated with a single ADDI instruction,\n    compute the best value to initially allocate.  It must at a minimum\n    allocate enough space to spill the callee-saved registers.  If TARGET_RVC,"}, {"sha": "01f30a853e35329ec1032470ac3846f0a15c25f4", "filename": "gcc/config/riscv/t-riscv", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02fcaf412ae9508b75efa9602cd4ac58bc63d6a4/gcc%2Fconfig%2Friscv%2Ft-riscv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02fcaf412ae9508b75efa9602cd4ac58bc63d6a4/gcc%2Fconfig%2Friscv%2Ft-riscv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Ft-riscv?ref=02fcaf412ae9508b75efa9602cd4ac58bc63d6a4", "patch": "@@ -76,6 +76,10 @@ riscv-v.o: $(srcdir)/config/riscv/riscv-v.cc\n \t$(COMPILE) $<\n \t$(POSTCOMPILE)\n \n+thead.o: $(srcdir)/config/riscv/thead.cc\n+\t$(COMPILE) $<\n+\t$(POSTCOMPILE)\n+\n PASSES_EXTRA += $(srcdir)/config/riscv/riscv-passes.def\n \n $(common_out_file): $(srcdir)/config/riscv/riscv-cores.def \\"}, {"sha": "752038053102cee81f3797a813157ebcff7d5c94", "filename": "gcc/config/riscv/thead.cc", "status": "added", "additions": 427, "deletions": 0, "changes": 427, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02fcaf412ae9508b75efa9602cd4ac58bc63d6a4/gcc%2Fconfig%2Friscv%2Fthead.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02fcaf412ae9508b75efa9602cd4ac58bc63d6a4/gcc%2Fconfig%2Friscv%2Fthead.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fthead.cc?ref=02fcaf412ae9508b75efa9602cd4ac58bc63d6a4", "patch": "@@ -0,0 +1,427 @@\n+/* Subroutines used for code generation for RISC-V.\n+   Copyright (C) 2023 Free Software Foundation, Inc.\n+   Contributed by Christoph M\u00fcllner (christoph.muellner@vrull.eu).\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#define IN_TARGET_CODE 1\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"target.h\"\n+#include \"backend.h\"\n+#include \"rtl.h\"\n+#include \"memmodel.h\"\n+#include \"emit-rtl.h\"\n+#include \"poly-int.h\"\n+#include \"output.h\"\n+\n+/* If MEM is in the form of \"base+offset\", extract the two parts\n+   of address and set to BASE and OFFSET, otherwise return false\n+   after clearing BASE and OFFSET.  */\n+\n+static bool\n+extract_base_offset_in_addr (rtx mem, rtx *base, rtx *offset)\n+{\n+  rtx addr;\n+\n+  gcc_assert (MEM_P (mem));\n+\n+  addr = XEXP (mem, 0);\n+\n+  if (REG_P (addr))\n+    {\n+      *base = addr;\n+      *offset = const0_rtx;\n+      return true;\n+    }\n+\n+  if (GET_CODE (addr) == PLUS\n+      && REG_P (XEXP (addr, 0)) && CONST_INT_P (XEXP (addr, 1)))\n+    {\n+      *base = XEXP (addr, 0);\n+      *offset = XEXP (addr, 1);\n+      return true;\n+    }\n+\n+  *base = NULL_RTX;\n+  *offset = NULL_RTX;\n+\n+  return false;\n+}\n+\n+/* If X is a PLUS of a CONST_INT, return the two terms in *BASE_PTR\n+   and *OFFSET_PTR.  Return X in *BASE_PTR and 0 in *OFFSET_PTR otherwise.  */\n+\n+static void\n+split_plus (rtx x, rtx *base_ptr, HOST_WIDE_INT *offset_ptr)\n+{\n+  if (GET_CODE (x) == PLUS && CONST_INT_P (XEXP (x, 1)))\n+    {\n+      *base_ptr = XEXP (x, 0);\n+      *offset_ptr = INTVAL (XEXP (x, 1));\n+    }\n+  else\n+    {\n+      *base_ptr = x;\n+      *offset_ptr = 0;\n+    }\n+}\n+\n+/* Output a mempair instruction with the provided OPERANDS.\n+   LOAD_P is true if a we have a pair of loads (stores otherwise).\n+   MODE is the access mode (DI or SI).\n+   CODE is the extension code (UNKNOWN, SIGN_EXTEND or ZERO_EXTEND).\n+   This instruction does not handle invalid inputs gracefully,\n+   but is full of assertions to ensure that only valid instructions\n+   are emitted.  */\n+\n+const char *\n+th_mempair_output_move (rtx operands[4], bool load_p,\n+\t\t\tmachine_mode mode, RTX_CODE code)\n+{\n+  rtx reg1, reg2, mem1, mem2, base1, base2;\n+  HOST_WIDE_INT offset1, offset2;\n+  rtx output_operands[5];\n+  const char* format;\n+\n+  gcc_assert (mode == SImode || mode == DImode);\n+\n+  /* Paired 64-bit access instructions have a fixed shift amount of 4.\n+     Paired 32-bit access instructions have a fixed shift amount of 3.  */\n+  unsigned shamt = (mode == DImode) ? 4 : 3;\n+\n+  if (load_p)\n+    {\n+\treg1 = copy_rtx (operands[0]);\n+\treg2 = copy_rtx (operands[2]);\n+\tmem1 = copy_rtx (operands[1]);\n+\tmem2 = copy_rtx (operands[3]);\n+\n+\tif (mode == SImode)\n+\t  if (code == ZERO_EXTEND)\n+\t    format = \"th.lwud\\t%0, %1, (%2), %3, %4\";\n+\t  else //SIGN_EXTEND or UNKNOWN\n+\t    format = \"th.lwd\\t%0, %1, (%2), %3, %4\";\n+\telse\n+\t  format = \"th.ldd\\t%0, %1, (%2), %3, %4\";\n+    }\n+  else\n+    {\n+\treg1 = copy_rtx (operands[1]);\n+\treg2 = copy_rtx (operands[3]);\n+\tmem1 = copy_rtx (operands[0]);\n+\tmem2 = copy_rtx (operands[2]);\n+\n+\tif (mode == SImode)\n+\t  format = \"th.swd\\t%z0, %z1, (%2), %3, %4\";\n+\telse\n+\t  format = \"th.sdd\\t%z0, %z1, (%2), %3, %4\";\n+    }\n+\n+  split_plus (XEXP (mem1, 0), &base1, &offset1);\n+  split_plus (XEXP (mem2, 0), &base2, &offset2);\n+  gcc_assert (rtx_equal_p (base1, base2));\n+  auto size1 = MEM_SIZE (mem1);\n+  auto size2 = MEM_SIZE (mem2);\n+  gcc_assert (known_eq (size1, size2));\n+  gcc_assert (known_eq (offset1 + size1, offset2));\n+\n+  HOST_WIDE_INT imm2 = offset1 >> shamt;\n+\n+  /* Make sure all mempair instruction constraints are met.  */\n+  gcc_assert (imm2 >= 0 && imm2 < 4);\n+  gcc_assert ((imm2 << shamt) == offset1);\n+  gcc_assert (REG_P (reg1));\n+  gcc_assert (REG_P (reg2));\n+  gcc_assert (REG_P (base1));\n+  if (load_p)\n+    {\n+      gcc_assert (REGNO (reg1) != REGNO (reg2));\n+      gcc_assert (REGNO (reg1) != REGNO (base1));\n+      gcc_assert (REGNO (reg2) != REGNO (base1));\n+    }\n+\n+  /* Output the mempair instruction.  */\n+  output_operands[0] = copy_rtx (reg1);\n+  output_operands[1] = copy_rtx (reg2);\n+  output_operands[2] = copy_rtx (base1);\n+  output_operands[3] = gen_rtx_CONST_INT (mode, imm2);\n+  output_operands[4] = gen_rtx_CONST_INT (mode, shamt);\n+  output_asm_insn (format, output_operands);\n+\n+  return \"\";\n+}\n+\n+/* Analyse if a pair of loads/stores MEM1 and MEM2 with given MODE\n+   are consecutive so they can be merged into a mempair instruction.\n+   RESERVED will be set to true, if a reversal of the accesses is\n+   required (false otherwise). Returns true if the accesses can be\n+   merged (even if reversing is necessary) and false if not.  */\n+\n+static bool\n+th_mempair_check_consecutive_mems (machine_mode mode, rtx *mem1, rtx *mem2,\n+\t\t\t\t   bool *reversed)\n+{\n+  rtx base1, base2, offset1, offset2;\n+  extract_base_offset_in_addr (*mem1, &base1, &offset1);\n+  extract_base_offset_in_addr (*mem2, &base2, &offset2);\n+\n+  /* Make sure both mems are in base+offset form.  */\n+  if (!base1 || !base2)\n+    return false;\n+\n+  /* If both mems use the same base register, just check the offsets.  */\n+  if (rtx_equal_p (base1, base2))\n+    {\n+      auto size = GET_MODE_SIZE (mode);\n+\n+      if (known_eq (UINTVAL (offset1) + size, UINTVAL (offset2)))\n+\t{\n+\t  *reversed = false;\n+\t  return true;\n+\t}\n+\n+      if (known_eq (UINTVAL (offset2) + size, UINTVAL (offset1)))\n+\t{\n+\t  *reversed = true;\n+\t  return true;\n+\t}\n+\n+      return false;\n+    }\n+\n+  return false;\n+}\n+\n+/* Check if the given MEM can be used to define the address of a mempair\n+   instruction.  */\n+\n+static bool\n+th_mempair_operand_p (rtx mem, machine_mode mode)\n+{\n+  if (!MEM_SIZE_KNOWN_P (mem))\n+    return false;\n+\n+  /* Only DI or SI mempair instructions exist.  */\n+  gcc_assert (mode == SImode || mode == DImode);\n+  auto mem_sz = MEM_SIZE (mem);\n+  auto mode_sz = GET_MODE_SIZE (mode);\n+  if (!known_eq (mem_sz, mode_sz))\n+    return false;\n+\n+  /* Paired 64-bit access instructions have a fixed shift amount of 4.\n+     Paired 32-bit access instructions have a fixed shift amount of 3.  */\n+  machine_mode mem_mode = GET_MODE (mem);\n+  unsigned shamt = (mem_mode == DImode) ? 4 : 3;\n+\n+  rtx base;\n+  HOST_WIDE_INT offset;\n+  split_plus (XEXP (mem, 0), &base, &offset);\n+  HOST_WIDE_INT imm2 = offset >> shamt;\n+\n+  if (imm2 < 0 || imm2 >= 4)\n+    return false;\n+\n+  if ((imm2 << shamt) != offset)\n+    return false;\n+\n+  return true;\n+}\n+\n+static bool\n+th_mempair_load_overlap_p (rtx reg1, rtx reg2, rtx mem)\n+{\n+  if (REGNO (reg1) == REGNO (reg2))\n+    return true;\n+\n+  if (reg_overlap_mentioned_p (reg1, mem))\n+    return true;\n+\n+  rtx base;\n+  HOST_WIDE_INT offset;\n+  split_plus (XEXP (mem, 0), &base, &offset);\n+\n+  if (!REG_P (base))\n+    return true;\n+\n+  if (REG_P (base))\n+    {\n+      if (REGNO (base) == REGNO (reg1)\n+\t  || REGNO (base) == REGNO (reg2))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Given OPERANDS of consecutive load/store, check if we can merge\n+   them into load-pair or store-pair instructions.\n+   LOAD is true if they are load instructions.\n+   MODE is the mode of memory operation.  */\n+\n+bool\n+th_mempair_operands_p (rtx operands[4], bool load_p,\n+\t\t       machine_mode mode)\n+{\n+  rtx mem_1, mem_2, reg_1, reg_2;\n+\n+  if (load_p)\n+    {\n+      reg_1 = operands[0];\n+      mem_1 = operands[1];\n+      reg_2 = operands[2];\n+      mem_2 = operands[3];\n+      if (!REG_P (reg_1) || !REG_P (reg_2))\n+\treturn false;\n+      if (th_mempair_load_overlap_p (reg_1, reg_2, mem_1))\n+\treturn false;\n+      if (th_mempair_load_overlap_p (reg_1, reg_2, mem_2))\n+\treturn false;\n+    }\n+  else\n+    {\n+      mem_1 = operands[0];\n+      reg_1 = operands[1];\n+      mem_2 = operands[2];\n+      reg_2 = operands[3];\n+    }\n+\n+  /* Check if the registers are GP registers.  */\n+  if (!REG_P (reg_1) || !GP_REG_P (REGNO (reg_1))\n+      || !REG_P (reg_2) || !GP_REG_P (REGNO (reg_2)))\n+    return false;\n+\n+  /* The mems cannot be volatile.  */\n+  if (!MEM_P (mem_1) || !MEM_P (mem_2))\n+    return false;\n+  if (MEM_VOLATILE_P (mem_1) || MEM_VOLATILE_P (mem_2))\n+    return false;\n+\n+  /* If we have slow unaligned access, we only accept aligned memory.  */\n+  if (riscv_slow_unaligned_access_p\n+      && known_lt (MEM_ALIGN (mem_1), GET_MODE_SIZE (mode) * BITS_PER_UNIT))\n+    return false;\n+\n+  /* Check if the addresses are in the form of [base+offset].  */\n+  bool reversed = false;\n+  if (!th_mempair_check_consecutive_mems (mode, &mem_1, &mem_2, &reversed))\n+    return false;\n+\n+  /* The first memory accesses must be a mempair operand.  */\n+  if ((!reversed && !th_mempair_operand_p (mem_1, mode))\n+      || (reversed && !th_mempair_operand_p (mem_2, mode)))\n+    return false;\n+\n+  /* The operands must be of the same size.  */\n+  gcc_assert (known_eq (GET_MODE_SIZE (GET_MODE (mem_1)),\n+\t\t\tGET_MODE_SIZE (GET_MODE (mem_2))));\n+\n+  return true;\n+}\n+\n+/* Given OPERANDS of consecutive load/store that can be merged,\n+   swap them if they are not in ascending order.\n+   Return true if swap was performed.  */\n+void\n+th_mempair_order_operands (rtx operands[4], bool load_p, machine_mode mode)\n+{\n+  int mem_op = load_p ? 1 : 0;\n+  bool reversed = false;\n+  if (!th_mempair_check_consecutive_mems (mode,\n+\t\t\t\t\t  operands + mem_op,\n+\t\t\t\t\t  operands + mem_op + 2,\n+\t\t\t\t\t  &reversed))\n+    gcc_unreachable ();\n+\n+  if (reversed)\n+    {\n+      /* Irrespective of whether this is a load or a store,\n+\t we do the same swap.  */\n+      std::swap (operands[0], operands[2]);\n+      std::swap (operands[1], operands[3]);\n+    }\n+}\n+\n+/* Similar like riscv_save_reg, but saves two registers to memory\n+   and marks the resulting instruction as frame-related.  */\n+\n+static void\n+th_mempair_save_regs (rtx operands[4])\n+{\n+  rtx set1 = gen_rtx_SET (operands[0], operands[1]);\n+  rtx set2 = gen_rtx_SET (operands[2], operands[3]);\n+  rtx insn = emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, set1, set2)));\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+  add_reg_note (insn, REG_CFA_OFFSET, copy_rtx (set1));\n+  add_reg_note (insn, REG_CFA_OFFSET, copy_rtx (set2));\n+}\n+\n+/* Similar like riscv_restore_reg, but restores two registers from memory\n+   and marks the instruction frame-related.  */\n+\n+static void\n+th_mempair_restore_regs (rtx operands[4])\n+{\n+  rtx set1 = gen_rtx_SET (operands[0], operands[1]);\n+  rtx set2 = gen_rtx_SET (operands[2], operands[3]);\n+  rtx insn = emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, set1, set2)));\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+  add_reg_note (insn, REG_CFA_RESTORE, operands[0]);\n+  add_reg_note (insn, REG_CFA_RESTORE, operands[2]);\n+}\n+\n+/* Prepare the OPERANDS array to emit a mempair instruction using the\n+   provided information. No checks are performed, the resulting array\n+   should be validated using th_mempair_operands_p().  */\n+\n+void\n+th_mempair_prepare_save_restore_operands (rtx operands[4],\n+\t\t\t\t\t  bool load_p, machine_mode mode,\n+\t\t\t\t\t  int regno, HOST_WIDE_INT offset,\n+\t\t\t\t\t  int regno2, HOST_WIDE_INT offset2)\n+{\n+  int reg_op = load_p ? 0 : 1;\n+  int mem_op = load_p ? 1 : 0;\n+\n+  rtx mem1 = plus_constant (mode, stack_pointer_rtx, offset);\n+  mem1 = gen_frame_mem (mode, mem1);\n+  rtx mem2 = plus_constant (mode, stack_pointer_rtx, offset2);\n+  mem2 = gen_frame_mem (mode, mem2);\n+\n+  operands[reg_op] = gen_rtx_REG (mode, regno);\n+  operands[mem_op] = mem1;\n+  operands[2 + reg_op] = gen_rtx_REG (mode, regno2);\n+  operands[2 + mem_op] = mem2;\n+}\n+\n+/* Emit a mempair instruction to save/restore two registers to/from stack.  */\n+\n+void\n+th_mempair_save_restore_regs (rtx operands[4], bool load_p,\n+\t\t\t\t machine_mode mode)\n+{\n+  gcc_assert (th_mempair_operands_p (operands, load_p, mode));\n+\n+  th_mempair_order_operands (operands, load_p, mode);\n+\n+  if (load_p)\n+    th_mempair_restore_regs (operands);\n+  else\n+    th_mempair_save_regs (operands);\n+}"}, {"sha": "63c4af6f77d80a8205b73393fe927c1e0d95cb98", "filename": "gcc/config/riscv/thead.md", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02fcaf412ae9508b75efa9602cd4ac58bc63d6a4/gcc%2Fconfig%2Friscv%2Fthead.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02fcaf412ae9508b75efa9602cd4ac58bc63d6a4/gcc%2Fconfig%2Friscv%2Fthead.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fthead.md?ref=02fcaf412ae9508b75efa9602cd4ac58bc63d6a4", "patch": "@@ -292,3 +292,55 @@\n   [(set_attr \"type\" \"imul\")\n    (set_attr \"mode\" \"SI\")]\n )\n+\n+;; XTheadMemPair\n+\n+;; MEMPAIR load 64/32 bit\n+(define_insn \"*th_mempair_load_<GPR:mode>2\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=r\")\n+\t(match_operand:GPR 1 \"memory_operand\" \"m\"))\n+   (set (match_operand:GPR 2 \"register_operand\" \"=r\")\n+\t(match_operand:GPR 3 \"memory_operand\" \"m\"))]\n+  \"TARGET_XTHEADMEMPAIR && reload_completed\n+   && th_mempair_operands_p (operands, true, <GPR:MODE>mode)\"\n+  { return th_mempair_output_move (operands, true, <GPR:MODE>mode, UNKNOWN); }\n+  [(set_attr \"move_type\" \"load\")\n+   (set_attr \"mode\" \"<GPR:MODE>\")])\n+\n+;; MEMPAIR store 64/32 bit\n+(define_insn \"*th_mempair_store_<GPR:mode>2\"\n+  [(set (match_operand:GPR 0 \"memory_operand\" \"=m\")\n+\t(match_operand:GPR 1 \"register_operand\" \"r\"))\n+   (set (match_operand:GPR 2 \"memory_operand\" \"=m\")\n+\t(match_operand:GPR 3 \"register_operand\" \"r\"))]\n+  \"TARGET_XTHEADMEMPAIR && reload_completed\n+   && th_mempair_operands_p (operands, false, <GPR:MODE>mode)\"\n+  { return th_mempair_output_move (operands, false, <GPR:MODE>mode, UNKNOWN); }\n+  [(set_attr \"move_type\" \"store\")\n+   (set_attr \"mode\" \"<GPR:MODE>\")])\n+\n+;; MEMPAIR load DI extended signed SI\n+(define_insn \"*th_mempair_load_extendsidi2\"\n+  [(set (match_operand 0 \"register_operand\" \"=r\")\n+\t(sign_extend:DI (match_operand 1 \"memory_operand\" \"m\")))\n+   (set (match_operand 2 \"register_operand\" \"=r\")\n+\t(sign_extend:DI (match_operand 3 \"memory_operand\" \"m\")))]\n+  \"TARGET_XTHEADMEMPAIR && TARGET_64BIT && reload_completed\n+   && th_mempair_operands_p (operands, true, SImode)\"\n+  { return th_mempair_output_move (operands, true, SImode, SIGN_EXTEND); }\n+  [(set_attr \"move_type\" \"load\")\n+   (set_attr \"mode\" \"DI\")\n+   (set_attr \"length\" \"8\")])\n+\n+;; MEMPAIR load DI extended unsigned SI\n+(define_insn \"*th_mempair_load_zero_extendsidi2\"\n+  [(set (match_operand 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI (match_operand 1 \"memory_operand\" \"m\")))\n+   (set (match_operand 2 \"register_operand\" \"=r\")\n+\t(zero_extend:DI (match_operand 3 \"memory_operand\" \"m\")))]\n+  \"TARGET_XTHEADMEMPAIR && TARGET_64BIT && reload_completed\n+   && th_mempair_operands_p (operands, true, SImode)\"\n+  { return th_mempair_output_move (operands, true, SImode, ZERO_EXTEND); }\n+  [(set_attr \"move_type\" \"load\")\n+   (set_attr \"mode\" \"DI\")\n+   (set_attr \"length\" \"8\")])"}, {"sha": "34a29ab9c047ebff92159b62d1229ebe5bb6373f", "filename": "gcc/testsuite/gcc.target/riscv/xtheadmempair-1.c", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02fcaf412ae9508b75efa9602cd4ac58bc63d6a4/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadmempair-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02fcaf412ae9508b75efa9602cd4ac58bc63d6a4/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadmempair-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadmempair-1.c?ref=02fcaf412ae9508b75efa9602cd4ac58bc63d6a4", "patch": "@@ -0,0 +1,98 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-O0\" \"-O1\" \"-g\" \"-Oz\" \"-Os\" \"-flto\" } } */\n+/* { dg-options \"-march=rv64gc_xtheadmempair -mtune=thead-c906\" { target { rv64 } } } */\n+/* { dg-options \"-march=rv32gc_xtheadmempair -mtune=thead-c906\" { target { rv32 } } } */\n+\n+#include <inttypes.h>\n+\n+#if __riscv_xlen == 32\n+typedef uint32_t xlen_t;\n+#else\n+typedef uint64_t xlen_t;\n+#endif\n+\n+void foof (xlen_t*, xlen_t, xlen_t);\n+void foor (xlen_t*, xlen_t, xlen_t);\n+void foowu (uint32_t*, uint64_t, uint64_t);\n+void foows (int32_t*, int64_t, int64_t);\n+\n+#define LxD_TEST(f, T, i1, i2)\t\t\\\n+void\t\t\t\t\t\\\n+f ## i1 ## i2(T *arr)\t\t\t\\\n+{\t\t\t\t\t\\\n+  foo ## f(arr, arr[i1], arr[i2]);\t\\\n+}\n+\n+// works\n+LxD_TEST(f, xlen_t, 0, 1)\n+// does not work (can't merge with unaligned offset)\n+LxD_TEST(f, xlen_t, 1, 2)\n+// works\n+LxD_TEST(f, xlen_t, 2, 3)\n+// does not work (can't merge with unaligned offset)\n+LxD_TEST(f, xlen_t, 3, 4)\n+// works\n+LxD_TEST(f, xlen_t, 4, 5)\n+// does not work (can't merge with unaligned offset)\n+LxD_TEST(f, xlen_t, 5, 6)\n+// works\n+LxD_TEST(f, xlen_t, 6, 7)\n+// does not work (can't merge with unaligned offset)\n+LxD_TEST(f, xlen_t, 7, 8)\n+// does not work (out of range)\n+LxD_TEST(f, xlen_t, 8, 9)\n+\n+// works with reordering\n+LxD_TEST(r, xlen_t, 1, 0)\n+// does not work (can't merge with unaligned offset)\n+LxD_TEST(r, xlen_t, 2, 1)\n+// works with reordering\n+LxD_TEST(r, xlen_t, 3, 2)\n+// does not work (can't merge with unaligned offset)\n+LxD_TEST(r, xlen_t, 4, 3)\n+// works with reordering\n+LxD_TEST(r, xlen_t, 5, 4)\n+// does not work (can't merge with unaligned offset)\n+LxD_TEST(r, xlen_t, 6, 5)\n+// works with reordering\n+LxD_TEST(r, xlen_t, 7, 6)\n+// does not work (can't merge with unaligned offset)\n+LxD_TEST(r, xlen_t, 8, 7)\n+// does not work (out of range)\n+LxD_TEST(r, xlen_t, 9, 8)\n+\n+#if __riscv_xlen != 32\n+// works\n+LxD_TEST(wu, uint32_t, 0, 1)\n+LxD_TEST(ws, int32_t, 0, 1)\n+// does not work (can't merge with unaligned offset)\n+LxD_TEST(wu, uint32_t, 1, 2)\n+LxD_TEST(ws, int32_t, 1, 2)\n+// works\n+LxD_TEST(wu, uint32_t, 2, 3)\n+LxD_TEST(ws, int32_t, 2, 3)\n+// does not work (can't merge with unaligned offset)\n+LxD_TEST(wu, uint32_t, 3, 4)\n+LxD_TEST(ws, int32_t, 3, 4)\n+// works\n+LxD_TEST(wu, uint32_t, 4, 5)\n+LxD_TEST(ws, int32_t, 4, 5)\n+// does not work (can't merge with unaligned offset)\n+LxD_TEST(wu, uint32_t, 5, 6)\n+LxD_TEST(ws, int32_t, 5, 6)\n+// works\n+LxD_TEST(wu, uint32_t, 6, 7)\n+LxD_TEST(ws, int32_t, 6, 7)\n+// does not work (can't merge with unaligned offset)\n+LxD_TEST(wu, uint32_t, 7, 8)\n+LxD_TEST(ws, int32_t, 7, 8)\n+// does not work (out of range)\n+LxD_TEST(wu, uint32_t, 8, 9)\n+LxD_TEST(ws, int32_t, 8, 9)\n+#endif\n+\n+/* { dg-final { scan-assembler-times \"th.ldd\\t\" 8 { target { rv64 } } } } */\n+/* { dg-final { scan-assembler-times \"th.lwud\\t\" 4 { target { rv64 } } } } */\n+/* { dg-final { scan-assembler-times \"th.lwd\\t\" 4 { target { rv64 } } } } */\n+\n+/* { dg-final { scan-assembler-times \"th.lwd\\t\" 8 { target { rv32 } } } } */"}, {"sha": "ed6397091966724ac17a4139fdd2c9d9b610b5a7", "filename": "gcc/testsuite/gcc.target/riscv/xtheadmempair-2.c", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02fcaf412ae9508b75efa9602cd4ac58bc63d6a4/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadmempair-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02fcaf412ae9508b75efa9602cd4ac58bc63d6a4/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadmempair-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadmempair-2.c?ref=02fcaf412ae9508b75efa9602cd4ac58bc63d6a4", "patch": "@@ -0,0 +1,84 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-O0\" \"-O1\" \"-g\" \"-Oz\" \"-Os\" \"-flto\" } } */\n+/* { dg-options \"-march=rv64gc_xtheadmempair -mtune=thead-c906\" { target { rv64 } } } */\n+/* { dg-options \"-march=rv32gc_xtheadmempair -mtune=thead-c906\" { target { rv32 } } } */\n+\n+#include <inttypes.h>\n+\n+#if __riscv_xlen == 32\n+typedef uint32_t xlen_t;\n+#else\n+typedef uint64_t xlen_t;\n+#endif\n+\n+#define SxD_TEST(f, T, i1, i2)\t\t\\\n+void\t\t\t\t\t\\\n+f ## i1 ## i2(T *arr, T x, T y)\t\t\\\n+{\t\t\t\t\t\\\n+  arr[i1] = x;\t\t\t\t\\\n+  arr[i2] = y;\t\t\t\t\\\n+}\n+\n+// works\n+SxD_TEST(f, xlen_t, 0, 1)\n+// does not work (can't merge with unaligned offset)\n+SxD_TEST(f, xlen_t, 1, 2)\n+// works\n+SxD_TEST(f, xlen_t, 2, 3)\n+// does not work (can't merge with unaligned offset)\n+SxD_TEST(f, xlen_t, 3, 4)\n+// works\n+SxD_TEST(f, xlen_t, 4, 5)\n+// does not work (can't merge with unaligned offset)\n+SxD_TEST(f, xlen_t, 5, 6)\n+// works\n+SxD_TEST(f, xlen_t, 6, 7)\n+// does not work (can't merge with unaligned offset)\n+SxD_TEST(f, xlen_t, 7, 8)\n+// does not work (out of range)\n+SxD_TEST(f, xlen_t, 8, 9)\n+\n+// works with reordering\n+SxD_TEST(r, xlen_t, 1, 0)\n+// does not work (can't merge with unaligned offset)\n+SxD_TEST(r, xlen_t, 2, 1)\n+// works with reordering\n+SxD_TEST(r, xlen_t, 3, 2)\n+// does not work (can't merge with unaligned offset)\n+SxD_TEST(r, xlen_t, 4, 3)\n+// works with reordering\n+SxD_TEST(r, xlen_t, 5, 4)\n+// does not work (can't merge with unaligned offset)\n+SxD_TEST(r, xlen_t, 6, 5)\n+// works with reordering\n+SxD_TEST(r, xlen_t, 7, 6)\n+// does not work (can't merge with unaligned offset)\n+SxD_TEST(r, xlen_t, 8, 7)\n+// does not work (out of range)\n+SxD_TEST(r, xlen_t, 9, 8)\n+\n+#if __riscv_xlen != 32\n+// works\n+SxD_TEST(w, uint32_t, 0, 1)\n+// does not work (can't merge with unaligned offset)\n+SxD_TEST(w, uint32_t, 1, 2)\n+// works\n+SxD_TEST(w, uint32_t, 2, 3)\n+// does not work (can't merge with unaligned offset)\n+SxD_TEST(w, uint32_t, 3, 4)\n+// works\n+SxD_TEST(w, uint32_t, 4, 5)\n+// does not work (can't merge with unaligned offset)\n+SxD_TEST(w, uint32_t, 5, 6)\n+// works\n+SxD_TEST(w, uint32_t, 6, 7)\n+// does not work (can't merge with unaligned offset)\n+SxD_TEST(w, uint32_t, 7, 8)\n+// does not work (out of range)\n+SxD_TEST(w, uint32_t, 8, 9)\n+#endif\n+\n+/* { dg-final { scan-assembler-times \"th.sdd\\t\" 8 { target { rv64 } } } } */\n+/* { dg-final { scan-assembler-times \"th.swd\\t\" 4 { target { rv64 } } } } */\n+\n+/* { dg-final { scan-assembler-times \"th.swd\\t\" 8 { target { rv32 } } } } */"}, {"sha": "5dec702819aef04fa3afc7479713400868abd262", "filename": "gcc/testsuite/gcc.target/riscv/xtheadmempair-3.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02fcaf412ae9508b75efa9602cd4ac58bc63d6a4/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadmempair-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02fcaf412ae9508b75efa9602cd4ac58bc63d6a4/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadmempair-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fxtheadmempair-3.c?ref=02fcaf412ae9508b75efa9602cd4ac58bc63d6a4", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-O0\" \"-O1\" \"-g\" \"-Oz\" \"-Os\" \"-flto\" } } */\n+/* { dg-options \"-march=rv64gc_xtheadmempair -mtune=thead-c906\" { target { rv64 } } } */\n+/* { dg-options \"-march=rv32gc_xtheadmempair -mtune=thead-c906\" { target { rv32 } } } */\n+\n+#include <inttypes.h>\n+\n+#if __riscv_xlen == 32\n+typedef uint32_t xlen_t;\n+#else\n+typedef uint64_t xlen_t;\n+#endif\n+\n+void foo (xlen_t, xlen_t, xlen_t, xlen_t, xlen_t, xlen_t, xlen_t, xlen_t);\n+void bar (xlen_t, xlen_t, xlen_t, xlen_t, xlen_t, xlen_t, xlen_t, xlen_t);\n+\n+void baz (xlen_t a, xlen_t b, xlen_t c, xlen_t d, xlen_t e, xlen_t f, xlen_t g, xlen_t h)\n+{\n+  foo (a, b, c, d, e, f, g, h);\n+  /* RV64: We don't use 0(sp), therefore we can only get 3 mempairs.  */\n+  /* RV32: We don't use 0(sp)-8(sp), therefore we can only get 2 mempairs.  */\n+  bar (a, b, c, d, e, f, g, h);\n+}\n+\n+/* { dg-final { scan-assembler-times \"th.ldd\\t\" 3 { target { rv64 } } } } */\n+/* { dg-final { scan-assembler-times \"th.sdd\\t\" 3 { target { rv64 } } } } */\n+\n+/* { dg-final { scan-assembler-times \"th.lwd\\t\" 2 { target { rv32 } } } } */\n+/* { dg-final { scan-assembler-times \"th.swd\\t\" 2 { target { rv32 } } } } */"}]}