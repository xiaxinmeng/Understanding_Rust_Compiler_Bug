{"sha": "80a093b29e752ac54172945174c7cd59cec1fd05", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODBhMDkzYjI5ZTc1MmFjNTQxNzI5NDUxNzRjN2NkNTljZWMxZmQwNQ==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-08-27T20:51:39Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-08-27T20:51:39Z"}, "message": "\ufffd\nMigrate from devo/gcc/ch.\n\nFrom-SVN: r22034", "tree": {"sha": "878b128b0bfbd427bff598b9db9be9cbf462fbec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/878b128b0bfbd427bff598b9db9be9cbf462fbec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80a093b29e752ac54172945174c7cd59cec1fd05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80a093b29e752ac54172945174c7cd59cec1fd05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80a093b29e752ac54172945174c7cd59cec1fd05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80a093b29e752ac54172945174c7cd59cec1fd05/comments", "author": null, "committer": null, "parents": [{"sha": "fc5074d4c9e4e1877450249c436f7d8af846b12b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc5074d4c9e4e1877450249c436f7d8af846b12b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc5074d4c9e4e1877450249c436f7d8af846b12b"}], "stats": {"total": 13517, "additions": 13517, "deletions": 0}, "files": [{"sha": "d1eceb366a6cc626d31e52861308988836f3e309", "filename": "gcc/ch/actions.h", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Factions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Factions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Factions.h?ref=80a093b29e752ac54172945174c7cd59cec1fd05", "patch": "@@ -0,0 +1,33 @@\n+/* Declarations for ch-actions.c.\n+   Copyright (C) 1992, 93, 1994 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* used by compile_file */\n+\n+void init_chill PROTO((void));\n+\n+extern int grant_count;\n+\n+extern void push_handler PROTO((void));\n+extern void pop_handler PROTO((int));\n+extern void push_action PROTO((void));\n+\n+extern int  chill_handle_single_dimension_case_label PROTO((tree, tree, int *, int *));\n+extern tree build_chill_multi_dimension_case_expr    PROTO((tree, tree, tree));\n+extern tree build_multi_case_selector_expression     PROTO((tree, tree));\n+extern void compute_else_ranges                      PROTO((tree, tree));"}, {"sha": "d3b3c709247d51108304bb19fc5d6d7f8e9ebdcf", "filename": "gcc/ch/except.c", "status": "added", "additions": 703, "deletions": 0, "changes": 703, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fexcept.c?ref=80a093b29e752ac54172945174c7cd59cec1fd05", "patch": "@@ -0,0 +1,703 @@\n+/* Exception support for GNU CHILL.\n+   WARNING:  Only works for native (needs setjmp.h)!  FIXME!\n+   Copyright (C) 1992, 93, 1994 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"ch-tree.h\"\n+#include \"rtl.h\"\n+\n+/* On Suns this can get you to the right definition if you\n+   set the right value for TARGET.  */\n+#include <setjmp.h>\n+#ifdef sequent\n+/* Can you believe they forgot this?  */\n+#ifndef _JBLEN\n+#define _JBLEN 11\n+#endif\n+#endif\n+\n+#ifndef _JBLEN\n+#define _JBLEN (sizeof(jmp_buf)/sizeof(int))\n+#define _JBLEN_2 _JBLEN+20\n+#else\n+/* if we use i.e. posix threads, this buffer must be longer */\n+#define _JBLEN_2 _JBLEN+20\n+#endif\n+\n+/* On Linux setjmp is __setjmp FIXME: what is for CROSS */\n+#ifndef SETJMP_LIBRARY_NAME\n+#ifdef __linux__\n+#define SETJMP_LIBRARY_NAME \"__setjmp\"\n+#else\n+#define SETJMP_LIBRARY_NAME \"setjmp\"\n+#endif\n+#endif\n+\n+extern int  expand_exit_needed;\n+extern tree build_chill_exception_decl PROTO((char *));\n+extern void chill_handle_case_default  PROTO((void));\n+extern void emit_jump                  PROTO((rtx));\n+extern void expand_decl                PROTO((tree));\n+extern void fatal                      PROTO((char *, ...));\n+extern void make_decl_rtl              PROTO((tree, char *, int));\n+extern void rest_of_decl_compilation   PROTO((tree, char *, int, int));\n+\n+static tree link_handler_decl;\n+static tree handler_link_pointer_type;\n+static tree unlink_handler_decl;\n+static int exceptions_initialized = 0;\n+static void emit_setup_handler PROTO((void));\n+static void initialize_exceptions PROTO((void));\n+static tree char_pointer_type_for_handler;\n+\n+/* If this is 1, operations to push and pop on the __exceptionStack\n+   are inline.  The default is is to use a function call, to\n+   allow for a per-thread exception stack. */\n+static int inline_exception_stack_ops = 0;\n+\n+struct handler_state\n+{\n+  struct handler_state *next;\n+\n+  /* Starts at 0, then incremented for every <on-alternative>. */\n+  int prev_on_alternative;\n+\n+  /* If > 0: handler number for ELSE handler. */\n+  int else_handler;\n+\n+  int action_number;\n+\n+  char do_pushlevel;\n+\n+  tree on_alt_list;\n+  tree setjmp_expr;\n+\n+  /* A decl for the static handler array (used to map exception name to int).*/\n+  tree handler_array_decl;\n+\n+  rtx end_label;\n+\n+  /* Used to pass a tree from emit_setup_handler to chill_start_on. */\n+  tree handler_ref;\n+\n+  tree unlink_cleanup;\n+\n+  tree function;\n+\n+  /* flag to indicate that we are currently compiling this handler.\n+     is_handled will need this to determine an unhandled exception */\n+  int compiling;\n+};\n+\n+/* This is incremented by one each time we start an action which\n+   might have an ON-handler.  It is reset between passes. */\n+static int action_number = 0;\n+\n+int action_nesting_level = 0;\n+\n+/* The global_handler_list is constructed in pass 1.  It is not sorted.\n+   It contains one element for each action that actually had an ON-handler.\n+   An element's ACTION_NUMBER matches the action_number\n+   of that action.  The global_handler_list is eaten up during pass 2. */\n+#define ACTION_NUMBER(HANDLER) ((HANDLER)->action_number)\n+struct handler_state *global_handler_list = NULL;\n+\n+/* This is a stack of handlers, one for each nested ON-handler. */\n+static struct handler_state *current_handler = NULL;\n+\n+static struct handler_state *free_handlers = NULL; /* freelist */\n+\n+static tree handler_element_type;\n+static tree handler_link_type;\n+static tree BISJ;\n+static tree jbuf_ident, prev_ident, handlers_ident;\n+static tree exception_stack_decl = 0;\n+\n+/* Chain of cleanups assocated with exception handlers.\n+   The TREE_PURPOSE is an INTEGER_CST whose value is the\n+   DECL_ACTION_NESTING_LEVEL (when the handled actions was entered).\n+   The TREE_VALUE is an expression to expand when we exit that action. */\n+\n+static tree cleanup_chain = NULL_TREE;\n+\f\n+#if 0\n+/* Merge the current sequence onto the tail of the previous one. */\n+\n+void\n+pop_sequence ()\n+{\n+  rtx sequence_first = get_insns ();\n+\n+  end_sequence ();\n+  emit_insns (sequence_first);\n+  \n+}\n+#endif\n+\n+/* Things we need to do at the beginning of pass 2. */\n+\n+void\n+except_init_pass_2 ()\n+{\n+  /* First sort the global_handler_list on ACTION_NUMBER.\n+     This will already be in close to reverse order (the exception being\n+     nested ON-handlers), so insertion sort should essentially linear. */\n+\n+  register struct handler_state *old_list = global_handler_list;\n+\n+  /* First add a dummy final element. */\n+  if (free_handlers)\n+    global_handler_list = free_handlers;\n+  else\n+    global_handler_list\n+      = (struct handler_state*) permalloc (sizeof (struct handler_state));\n+  /* Make the final dummy \"larger\" than any other element. */\n+  ACTION_NUMBER (global_handler_list) = action_number + 1;\n+  /* Now move all the elements in old_list over to global_handler_list. */\n+  while (old_list != NULL)\n+    {\n+      register struct handler_state **ptr = &global_handler_list;\n+      /* Unlink from old_list. */\n+      register struct handler_state *current = old_list;\n+      old_list = old_list->next;\n+\n+      while (ACTION_NUMBER (current) > ACTION_NUMBER (*ptr))\n+\tptr = &(*ptr)->next;\n+      /* Link into proper place in global_handler_list (new list). */\n+      current->next = *ptr;\n+      *ptr = current;\n+    }\n+     \n+  /* Don't forget to reset action_number. */\n+  action_number = 0;\n+}\n+\n+/* This function is called at the beginning of an action that might be\n+   followed by an ON-handler.  Chill syntax doesn't let us know if\n+   we actually have an ON-handler until we see the ON, so we save\n+   away during pass 1 that information for use during pass 2. */\n+\n+void\n+push_handler ()\n+{\n+  register struct handler_state *hstate;\n+\n+  action_number++;\n+  action_nesting_level++;\n+\n+  if (pass == 1)\n+    {\n+      if (free_handlers)\n+\t{\n+\t  hstate = free_handlers;\n+\t  free_handlers = hstate->next;\n+\t}\n+      else\n+\t{\n+\t  hstate =\n+\t    (struct handler_state*) permalloc (sizeof (struct handler_state));\n+\t}\n+\n+      hstate->next = current_handler;\n+      current_handler = hstate;\n+      hstate->prev_on_alternative = 0;\n+      hstate->else_handler = 0;\n+      hstate->on_alt_list = NULL_TREE;\n+      hstate->compiling = 0;\n+\n+      ACTION_NUMBER (hstate) = action_number;\n+      return;\n+    }\n+\n+  if (ACTION_NUMBER (global_handler_list) != action_number)\n+    return;\n+\n+  /* OK.  This action actually has an ON-handler.\n+     Pop it from global_handler_list, and use it. */\n+\n+  hstate = global_handler_list;\n+  global_handler_list = hstate->next;\n+\n+  /* Since this is pass 2, let's generate prologue code for that. */\n+\n+  hstate->next = current_handler;\n+  current_handler = hstate;\n+\n+  hstate->prev_on_alternative = 0;\n+  hstate->function = current_function_decl;\n+\n+  emit_setup_handler ();\n+}\n+\n+static tree\n+start_handler_array ()\n+{\n+  tree handler_array_type, decl;\n+\n+  push_obstacks_nochange ();\n+  end_temporary_allocation ();\n+  handler_array_type = build_array_type (handler_element_type, NULL_TREE);\n+  decl = build_lang_decl (VAR_DECL,\n+\t\t\t  get_unique_identifier (\"handler_table\"),\n+\t\t\t  handler_array_type);\n+\n+/*  TREE_TYPE (decl) = handler_array_type;*/\n+  TREE_READONLY (decl) = 1;\n+  TREE_STATIC (decl) = 1;\n+  DECL_INITIAL (decl) = error_mark_node;\n+  \n+  pushdecl (decl);\n+  make_decl_rtl (decl, NULL_PTR, 0);\n+  current_handler->handler_array_decl = decl;\n+  return decl;\n+}\n+\n+static void\n+finish_handler_array ()\n+{\n+  tree decl = current_handler->handler_array_decl;\n+  tree t;\n+  tree handler_array_init = NULL_TREE;\n+  int handlers_count = 1;\n+  int nelts;\n+\n+  /* Build the table mapping exceptions to handler(-number)s.\n+     This is done in reverse order. */\n+  \n+  /* First push the end of the list.  This is either the ELSE\n+     handler (current_handler->else_handler>0) or NULL handler to indicate\n+     the end of the list (if current_handler->else-handler == 0).\n+     The following works either way. */\n+  handler_array_init = build_tree_list\n+    (NULL_TREE, chill_expand_tuple\n+     (handler_element_type,\n+      build_nt (CONSTRUCTOR, NULL_TREE,\n+\t\ttree_cons (NULL_TREE,\n+\t\t\t   null_pointer_node,\n+\t\t\t   build_tree_list (NULL_TREE,\n+\t\t\t\t\t    build_int_2 (current_handler->else_handler,\n+\t\t\t\t\t\t\t     0))))));\n+  \n+  for (t = current_handler->on_alt_list; t != NULL_TREE; t = TREE_CHAIN (t))\n+    { tree handler_number = TREE_PURPOSE(t);\n+      tree elist = TREE_VALUE (t);\n+      for ( ; elist != NULL_TREE; elist = TREE_CHAIN (elist))\n+\t{\n+\t  tree ex_decl =\n+\t    build_chill_exception_decl (IDENTIFIER_POINTER(TREE_VALUE(elist)));\n+\t  tree ex_addr = build1 (ADDR_EXPR,\n+\t\t\t\t char_pointer_type_for_handler,\n+\t\t\t\t ex_decl);\n+\t  tree el = build_nt (CONSTRUCTOR, NULL_TREE,\n+\t\t\t      tree_cons (NULL_TREE,\n+\t\t\t\t\t ex_addr,\n+\t\t\t\t\t build_tree_list (NULL_TREE,\n+\t\t\t\t\t\t\t  handler_number)));\n+\t  mark_addressable (ex_decl);\n+\t  TREE_CONSTANT (ex_addr) = 1;\n+\t  handler_array_init =\n+\t    tree_cons (NULL_TREE,\n+\t\t       chill_expand_tuple (handler_element_type, el),\n+\t\t       handler_array_init);\n+\t  handlers_count++;\n+\t}\n+    }\n+\n+#if 1\n+  nelts = list_length (handler_array_init);\n+  TYPE_DOMAIN (TREE_TYPE (decl))\n+    = build_index_type (build_int_2 (nelts - 1, - (nelts == 0)));\n+  layout_type (TREE_TYPE (decl));\n+  DECL_INITIAL (decl)\n+    = convert (TREE_TYPE (decl),\n+\t       build_nt (CONSTRUCTOR, NULL_TREE, handler_array_init));\n+\n+  /* Pop back to the obstack that is current for this binding level.\n+     This is because MAXINDEX, rtl, etc. to be made below\n+     must go in the permanent obstack.  But don't discard the\n+     temporary data yet.  */\n+  pop_obstacks ();\n+  layout_decl (decl, 0);\n+  /* To prevent make_decl_rtl (called indiectly by rest_of_decl_compilation)\n+     throwing the existing RTL (which has already been used). */\n+  PUT_MODE (DECL_RTL (decl), DECL_MODE (decl));\n+  rest_of_decl_compilation (decl, (char*)0, 0, 0);\n+  expand_decl_init (decl);\n+#else\n+  /* To prevent make_decl_rtl (called indirectly by finish_decl)\n+     altering the existing RTL. */\n+  GET_MODE (DECL_RTL (current_handler->handler_array_decl)) =\n+    DECL_MODE (current_handler->handler_array_decl);\n+\n+  finish_decl (current_handler->handler_array_decl,\n+\t       build_nt (CONSTRUCTOR, NULL_TREE, handler_array_init),\n+\t       NULL_TREE);\n+#endif\n+}\n+\n+\n+void\n+pop_handler (used)\n+     int used;\n+{\n+  action_nesting_level--;\n+  if (pass == 1)\n+    {\n+      struct handler_state *old = current_handler;\n+      if (old == NULL)\n+\tfatal (\"internal error: on stack out of sync\");\n+      current_handler = old->next;\n+\n+      if (used)\n+\t{ /* Push unto global_handler_list. */\n+\t  old->next = global_handler_list;\n+\t  global_handler_list = old;\n+\t}\n+      else\n+\t{\n+\t  /* Push onto free_handlers free list. */\n+\t  old->next = free_handlers;\n+\t  free_handlers = old;\n+\t}\n+    }\n+  else if (used)\n+    {\n+      current_handler = current_handler->next;\n+    }\n+}\n+\n+/* Emit code before an action that has an ON-handler. */\n+\n+static void\n+emit_setup_handler ()\n+{\n+  tree handler_decl, handler_addr, t;\n+\n+  /* Field references. */\n+  tree jbuf_ref, handlers_ref,prev_ref;\n+  if (!exceptions_initialized)\n+    {\n+      /* We temporarily reset the maximum_field_alignment to zero so the\n+\t compiler's exception data structures can be compatible with the\n+\t run-time system, even when we're compiling with -fpack. */\n+      extern int maximum_field_alignment;\n+      int save_maximum_field_alignment = maximum_field_alignment;\n+      maximum_field_alignment = 0;\n+      push_obstacks_nochange ();\n+      end_temporary_allocation ();\n+      initialize_exceptions ();\n+      pop_obstacks ();\n+      maximum_field_alignment = save_maximum_field_alignment;\n+    }\n+\n+  push_momentary ();\n+\n+  handler_decl = build_lang_decl (VAR_DECL,\n+\t\t\t\t  get_unique_identifier (\"handler\"),\n+\t\t\t\t  handler_link_type);\n+  push_obstacks_nochange ();\n+  pushdecl(handler_decl);\n+  expand_decl (handler_decl);\n+  finish_decl (handler_decl);\n+\n+  jbuf_ref = build_component_ref (handler_decl, jbuf_ident);\n+  jbuf_ref = build_chill_arrow_expr (jbuf_ref, 1);\n+  handlers_ref = build_component_ref (handler_decl, handlers_ident);\n+  prev_ref = build_component_ref (handler_decl, prev_ident);\n+\n+  /* Emit code to link in handler in __exceptionStack chain. */\n+  mark_addressable (handler_decl);\n+  handler_addr = build1 (ADDR_EXPR, handler_link_pointer_type, handler_decl);\n+  if (inline_exception_stack_ops)\n+    {\n+      expand_expr_stmt (build_chill_modify_expr (prev_ref,\n+\t\t\t\t\t\t exception_stack_decl));\n+      expand_expr_stmt (build_chill_modify_expr (exception_stack_decl,\n+\t\t\t\t\t\t handler_addr));\n+      current_handler->handler_ref = prev_ref;\n+    }\n+  else\n+    {\n+      expand_expr_stmt (build_chill_function_call (link_handler_decl,\n+\t\t\t\t\t     build_tree_list (NULL_TREE,\n+\t\t\t\t\t\t\t      handler_addr)));\n+      current_handler->handler_ref = handler_addr;\n+    }\n+\n+  /* Expand:  handler->__handlers = { <<array mapping names to ints } */\n+  t =  build1 (NOP_EXPR, build_pointer_type (handler_element_type),\n+\t       build_chill_arrow_expr (start_handler_array (), 1));\n+  expand_expr_stmt (build_chill_modify_expr (handlers_ref, t));\n+\n+  /* Emit code to unlink handler. */\n+  if (inline_exception_stack_ops)\n+    current_handler->unlink_cleanup\n+      = build_chill_modify_expr (exception_stack_decl,\n+\t\t\t\t current_handler->handler_ref);\n+  else\n+    current_handler->unlink_cleanup\n+      = build_chill_function_call (unlink_handler_decl,\n+\t\t\t\t   build_tree_list(NULL_TREE,\n+\t\t\t\t\t       current_handler->handler_ref));\n+  cleanup_chain = tree_cons (build_int_2 (action_nesting_level, 0),\n+\t\t\t     current_handler->unlink_cleanup,\n+\t\t\t     cleanup_chain);\n+\n+  /* Emit code for setjmp. */\n+  \n+  current_handler->setjmp_expr =\n+    build_chill_function_call (BISJ, build_tree_list (NULL_TREE, jbuf_ref));\n+  expand_start_case (1, current_handler->setjmp_expr,\n+\t\t     integer_type_node, \"on handler\");\n+\n+  chill_handle_case_label (integer_zero_node, current_handler->setjmp_expr);\n+}\n+\n+/* Start emitting code for: <actions> ON <handlers> END.\n+   Assume we've parsed <actions>, and the setup needed for it. */\n+\n+void\n+chill_start_on ()\n+{\n+  expand_expr_stmt (current_handler->unlink_cleanup);\n+\n+  /* Emit code to jump past the handlers. */\n+  current_handler->end_label = gen_label_rtx ();\n+  current_handler->compiling = 1;\n+  emit_jump (current_handler->end_label);\n+}\n+\n+void\n+chill_finish_on ()\n+{\n+  expand_end_case (current_handler->setjmp_expr);\n+  \n+  finish_handler_array ();\n+\n+  emit_label (current_handler->end_label);\n+\n+  pop_momentary ();\n+\n+  cleanup_chain = TREE_CHAIN (cleanup_chain);\n+}\n+\n+void\n+chill_handle_on_labels (labels)\n+     tree labels;\n+{\n+  int alternative = ++current_handler->prev_on_alternative;\n+  if (pass == 1)\n+    {\n+      tree handler_number = build_int_2 (alternative, 0);\n+      current_handler->on_alt_list =\n+\ttree_cons (handler_number, labels, current_handler->on_alt_list);\n+    }\n+  else\n+    {\n+      /* Find handler_number saved in pass 1. */\n+      tree tmp = current_handler->on_alt_list;\n+      while (TREE_INT_CST_LOW (TREE_PURPOSE (tmp)) != alternative)\n+\ttmp = TREE_CHAIN (tmp);\n+      if (expand_exit_needed)\n+\texpand_exit_something (), expand_exit_needed = 0;\n+      chill_handle_case_label (TREE_PURPOSE (tmp),\n+\t\t\t       current_handler->setjmp_expr);\n+    }\n+}\n+\n+void\n+chill_start_default_handler ()\n+{\n+  current_handler->else_handler = ++current_handler->prev_on_alternative;\n+  if (!ignoring)\n+    {\n+      chill_handle_case_default ();\n+    }\n+}\n+\n+void\n+chill_check_no_handlers ()\n+{\n+  if (current_handler != NULL)\n+    fatal (\"internal error: on stack not empty when done\");\n+}\n+\n+static void\n+initialize_exceptions ()\n+{\n+  tree jmp_buf_type = build_array_type (integer_type_node,\n+\t\t\t\t\tbuild_index_type (build_int_2 (_JBLEN_2-1, 0)));\n+  tree setjmp_fndecl, link_ftype;\n+  tree parmtypes\n+    = tree_cons (NULL_TREE, build_pointer_type (jmp_buf_type), void_list_node);\n+\n+  setjmp_fndecl = builtin_function (\"setjmp\",\n+\t\t\t\t    build_function_type (integer_type_node,\n+\t\t\t\t\t\t\t parmtypes),\n+\t\t\t\t    NOT_BUILT_IN,\n+\t\t\t\t    SETJMP_LIBRARY_NAME);\n+  BISJ = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (setjmp_fndecl)),\n+\t\t setjmp_fndecl);\n+ \n+  char_pointer_type_for_handler\n+    = build_pointer_type (build_type_variant (char_type_node, 1, 0));\n+  handler_element_type =\n+    build_chill_struct_type (chainon\n+\t\t\t     (build_decl (FIELD_DECL,\n+\t\t\t\t\t  get_identifier(\"__exceptid\"),\n+\t\t\t\t\t  char_pointer_type_for_handler),\n+\t\t\t      build_decl (FIELD_DECL,\n+\t\t\t\t\t  get_identifier(\"__handlerno\"),\n+\t\t\t\t\t  integer_type_node)));\n+\n+  jbuf_ident = get_identifier(\"__jbuf\");\n+  prev_ident = get_identifier(\"__prev\");\n+  handlers_ident = get_identifier(\"__handlers\");\n+\n+  handler_link_type =\n+    build_chill_struct_type\n+      (chainon\n+       (build_decl (FIELD_DECL, prev_ident, ptr_type_node),\n+\tchainon\n+\t(build_decl (FIELD_DECL, handlers_ident,\n+\t\t     build_pointer_type (handler_element_type)),\n+\t build_decl (FIELD_DECL, jbuf_ident, jmp_buf_type))));\n+\n+  handler_link_pointer_type = build_pointer_type (handler_link_type);\n+\n+  if (inline_exception_stack_ops)\n+    {\n+      exception_stack_decl =\n+\tbuild_lang_decl (VAR_DECL,\n+\t\t\t get_identifier(\"__exceptionStack\"),\n+\t\t\t handler_link_pointer_type);\n+      TREE_STATIC (exception_stack_decl) = 1;\n+      TREE_PUBLIC (exception_stack_decl) = 1;\n+      DECL_EXTERNAL (exception_stack_decl) = 1;\n+      push_obstacks_nochange ();\n+      pushdecl(exception_stack_decl);\n+      make_decl_rtl (exception_stack_decl, NULL_PTR, 1);\n+      finish_decl (exception_stack_decl);\n+    }\n+\n+  link_ftype = build_function_type (void_type_node,\n+\t\t\t\t    tree_cons (NULL_TREE,\n+\t\t\t\t\t       handler_link_pointer_type,\n+\t\t\t\t\t       void_list_node));\n+  link_handler_decl = builtin_function (\"__ch_link_handler\", link_ftype,\n+\t\t\t\t\tNOT_BUILT_IN, NULL_PTR);\n+  unlink_handler_decl = builtin_function (\"__ch_unlink_handler\", link_ftype,\n+\t\t\t\t\t  NOT_BUILT_IN, NULL_PTR);\n+\n+  exceptions_initialized = 1;\n+}\n+\n+/* Do the cleanup(s) needed for a GOTO label.\n+   We only need to do the last of the cleanups. */\n+\n+void\n+expand_goto_except_cleanup (label_level)\n+     int label_level;\n+{\n+  tree list = cleanup_chain;\n+  tree last = NULL_TREE;\n+  for ( ; list != NULL_TREE; list = TREE_CHAIN (list))\n+    {\n+      if (TREE_INT_CST_LOW (TREE_PURPOSE (list)) > label_level)\n+\tlast = list;\n+      else\n+\tbreak;\n+    }\n+  if (last)\n+    expand_expr_stmt (TREE_VALUE (last));\n+}\n+\n+/* Returns true if there is a valid handler for EXCEPT_NAME\n+   in the current static scope.\n+   0 ... no handler found\n+   1 ... local handler available\n+   2 ... function may propagate this exception\n+*/\n+\n+int\n+is_handled (except_name)\n+     tree except_name;\n+{\n+  tree t;\n+  struct handler_state *h = current_handler;\n+\n+  /* if we are are currently compiling this handler\n+     we have to start at the next level */\n+  if (h && h->compiling)\n+    h = h->next;\n+  while (h != NULL)\n+    {\n+      if (h->function != current_function_decl)\n+\tbreak;\n+      if (h->else_handler > 0)\n+\treturn 1;\n+      for (t = h->on_alt_list; t != NULL_TREE; t = TREE_CHAIN (t))\n+\t{\n+\t  if (value_member (except_name, TREE_VALUE (t)))\n+\t    return 1;\n+\t}\n+      h = h->next;\n+    }\n+\n+  t = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl));\n+\n+  if (value_member (except_name, t))\n+    return 2;\n+  return 0;\n+}\n+\n+/* function generates code to reraise exceptions\n+   for PROC's propagating exceptions. */\n+\n+void\n+chill_reraise_exceptions (exceptions)\n+     tree exceptions;\n+{\n+  tree wrk;\n+\n+  if (exceptions == NULL_TREE)\n+    return; /* just in case */\n+\n+  if (pass == 1)\n+    {\n+      for (wrk = exceptions; wrk != NULL_TREE; wrk = TREE_CHAIN (wrk))\n+\tchill_handle_on_labels (build_tree_list (NULL_TREE, TREE_VALUE (wrk)));\n+    }\n+  else /* pass == 2 */\n+    {\n+      chill_start_on ();\n+      expand_exit_needed = 0;\n+\n+      for (wrk = exceptions; wrk != NULL_TREE; wrk = TREE_CHAIN (wrk))\n+\t{\n+\t  chill_handle_on_labels (TREE_VALUE (wrk));\n+\t  /* do a CAUSE exception */\n+\t  expand_expr_stmt (build_cause_exception (TREE_VALUE (wrk), 0));\n+\t  expand_exit_needed = 1;\n+\t}\n+      chill_finish_on ();\n+    }\n+  pop_handler (1);\n+}"}, {"sha": "5dcf450f435bb682842eacd93a3473092bf8d85f", "filename": "gcc/ch/grant.c", "status": "added", "additions": 3053, "deletions": 0, "changes": 3053, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fgrant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fgrant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fgrant.c?ref=80a093b29e752ac54172945174c7cd59cec1fd05"}, {"sha": "2d2293bbda1f3341112f8b4a4664629f2dcb3ed1", "filename": "gcc/ch/inout.c", "status": "added", "additions": 4675, "deletions": 0, "changes": 4675, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Finout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Finout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Finout.c?ref=80a093b29e752ac54172945174c7cd59cec1fd05"}, {"sha": "a3dbbb27baa751e09a8651eca7cd3f198e0e5887", "filename": "gcc/ch/lex.c", "status": "added", "additions": 2169, "deletions": 0, "changes": 2169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Flex.c?ref=80a093b29e752ac54172945174c7cd59cec1fd05", "patch": "@@ -0,0 +1,2169 @@\n+/* Lexical analyzer for GNU CHILL. -*- C -*-\n+   Copyright (C) 1992, 93, 1994 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+\t General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\f\n+#include <stdio.h>\n+#include <errno.h>\n+#include <setjmp.h>\n+#include <ctype.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"input.h\"\n+\n+#include \"lex.h\"\n+#include \"ch-tree.h\"\n+#include \"flags.h\"\n+#include \"parse.h\"\n+#include \"obstack.h\"\n+\n+#ifdef MULTIBYTE_CHARS\n+#include <stdlib.h>\n+#include <locale.h>\n+#endif\n+\n+/* include the keyword recognizers */\n+#include \"hash.h\"\n+\n+#undef strchr\n+\n+FILE* finput;\n+\n+static int\tlast_token = 0;\n+/* Sun's C compiler warns about the safer sequence \n+   do { .. } while 0 \n+   when there's a 'return' inside the braces, so don't use it */\n+#define RETURN_TOKEN(X) { last_token = X; return (X); }\n+\n+/* This is set non-zero to force incoming tokens to lowercase. */\n+extern int ignore_case;\n+\n+extern int module_number;\n+extern int serious_errors;\n+\n+/* This is non-zero to recognize only uppercase special words. */\n+extern int special_UC;\n+\n+extern struct obstack permanent_obstack;\n+extern struct obstack temporary_obstack;\n+\n+#ifndef errno\n+extern int errno;\n+#endif\n+\n+extern tree build_string_type        PROTO((tree, tree));\n+extern void error                    PROTO((char *, ...));\n+extern void error_with_file_and_line PROTO((char *, int, char *, ...));\n+extern void grant_use_seizefile      PROTO((char *));\n+extern void pedwarn                  PROTO((char *, ...));\n+extern void pfatal_with_name         PROTO((char *));\n+extern void push_obstacks PROTO((struct obstack *, struct obstack *));\n+extern void set_identifier_size      PROTO((int));\n+extern void sorry                    PROTO((char *, ...));\n+extern int  target_isinf             PROTO((REAL_VALUE_TYPE));\n+extern int  tolower                  PROTO((int));\n+extern void warning                  PROTO((char *, ...));\n+\n+/* forward declarations */\n+static void close_input_file         PROTO((char *));\n+static tree convert_bitstring        PROTO((char *));\n+static tree convert_integer          PROTO((char *));\n+static void maybe_downcase           PROTO((char *));\n+static int  maybe_number             PROTO((char *));\n+static tree equal_number             PROTO((void));\n+static void handle_use_seizefile_directive PROTO((int));\n+static int  handle_name\t\t     PROTO((tree));\n+static void push_back                PROTO((int));\n+static char *readstring              PROTO((int, int *));\n+static void read_directive\t     PROTO((void));\n+static tree read_identifier\t     PROTO((int));\n+static tree read_number              PROTO((int));\n+static void skip_c_comment           PROTO((void));\n+static void skip_line_comment        PROTO((void));\n+static int  skip_whitespace          PROTO((void));\n+static tree string_or_char           PROTO((int, char *));\n+\n+/* next variables are public, because ch-actions uses them */\n+\n+/* the default grantfile name, set by lang_init */\n+tree default_grant_file = 0;\n+\n+/* These tasking-related variables are NULL at the start of each \n+   compiler pass, and are set to an expression tree if and when\n+   a compiler directive is parsed containing an expression.\n+   The NULL state is significant;  it means 'no user-specified\n+   signal_code (or whatever) has been parsed'. */\n+\n+/* process type, set by <> PROCESS_TYPE = number <> */\n+tree process_type = NULL_TREE;\n+\n+/* send buffer default priority,\n+   set by <> SEND_BUFFER_DEFAULT_PRIORITY = number <> */\n+tree send_buffer_prio = NULL_TREE;\n+\n+/* send signal default priority,\n+   set by <> SEND_SIGNAL_DEFAULT_PRIORITY = number <> */\n+tree send_signal_prio = NULL_TREE;\n+\n+/* signal code, set by <> SIGNAL_CODE = number <> */\n+tree signal_code = NULL_TREE;\n+\n+/* flag for range checking */\n+int range_checking = 1;\n+\n+/* flag for NULL pointer checking */\n+int empty_checking = 1;\n+\n+/* flag to indicate making all procedure local variables\n+   to be STATIC */\n+int all_static_flag = 0;\n+\n+/* flag to indicate -fruntime-checking command line option.\n+   Needed for initializing range_checking and empty_checking\n+   before pass 2 */\n+int runtime_checking_flag = 1;\n+\n+/* The elements of `ridpointers' are identifier nodes\n+   for the reserved type names and storage classes.\n+   It is indexed by a RID_... value.  */\n+tree ridpointers[(int) RID_MAX];\n+\n+/* Nonzero tells yylex to ignore \\ in string constants.  */\n+static int ignore_escape_flag = 0;\n+\n+static int maxtoken;\t\t/* Current nominal length of token buffer.  */\n+char *token_buffer;\t/* Pointer to token buffer.\n+\t\t\t   Actual allocated length is maxtoken + 2.\n+\t\t\t   This is not static because objc-parse.y uses it.  */\n+\n+/* implement yylineno handling for flex */\n+#define yylineno lineno\n+\n+static int inside_c_comment = 0;\n+\n+static int saw_eol = 0; /* 1 if we've just seen a '\\n' */\n+static int saw_eof = 0; /* 1 if we've just seen an EOF */\n+\n+typedef struct string_list\n+  {\n+    struct string_list *next;\n+    char               *str;\n+  } STRING_LIST;\n+\n+/* list of paths specified on the compiler command line by -L options. */\n+static STRING_LIST *seize_path_list = (STRING_LIST *)0;\n+\n+/* List of seize file names.  Each TREE_VALUE is an identifier\n+   (file name) from a <>USE_SEIZE_FILE<> directive.\n+   The TREE_PURPOSE is non-NULL if a USE_SEIZE_FILE directive has been\n+   written to the grant file. */\n+static tree files_to_seize     = NULL_TREE;\n+/* Last node on files_to_seize list. */\n+static tree last_file_to_seize = NULL_TREE;\n+/* Pointer into files_to_seize list:  Next unparsed file to read. */\n+static tree next_file_to_seize = NULL_TREE;\n+\n+/* The most recent use_seize_file directive. */\n+tree use_seizefile_name = NULL_TREE;\n+\n+/* If non-NULL, the name of the seizefile we're currently processing. */\n+tree current_seizefile_name = NULL_TREE;\n+\f\n+/* called to reset for pass 2 */\n+static void\n+ch_lex_init ()\n+{\n+  current_seizefile_name = NULL_TREE;\n+\n+  lineno = 0;\n+\n+  saw_eol = 0;\n+  saw_eof = 0;\n+  /* Initialize these compiler-directive variables. */\n+  process_type     = NULL_TREE;\n+  send_buffer_prio = NULL_TREE;\n+  send_signal_prio = NULL_TREE;\n+  signal_code      = NULL_TREE;\n+  all_static_flag  = 0;\n+  /* reinitialize rnage checking and empty checking */\n+  range_checking = runtime_checking_flag;\n+  empty_checking = runtime_checking_flag;\n+}\n+\n+\n+char *\n+init_parse (filename)\n+     char *filename;\n+{\n+  int lowercase_standard_names = ignore_case || ! special_UC;\n+\n+  /* Open input file.  */\n+  if (filename == 0 || !strcmp (filename, \"-\"))\n+    {\n+      finput = stdin;\n+      filename = \"stdin\";\n+    }\n+  else\n+    finput = fopen (filename, \"r\");\n+  if (finput == 0)\n+    pfatal_with_name (filename);\n+\n+#ifdef IO_BUFFER_SIZE\n+  setvbuf (finput, (char *) xmalloc (IO_BUFFER_SIZE), _IOFBF, IO_BUFFER_SIZE);\n+#endif\n+\n+  /* Make identifier nodes long enough for the language-specific slots.  */\n+  set_identifier_size (sizeof (struct lang_identifier));\n+\n+  /* Start it at 0, because check_newline is called at the very beginning\n+     and will increment it to 1.  */\n+  lineno = 0;\n+\n+  /* Initialize these compiler-directive variables. */\n+  process_type     = NULL_TREE;\n+  send_buffer_prio = NULL_TREE;\n+  send_signal_prio = NULL_TREE;\n+  signal_code      = NULL_TREE;\n+\n+  maxtoken         = 40;\n+  token_buffer     = xmalloc ((unsigned)(maxtoken + 2));\n+\n+  init_chill_expand ();\n+\n+#define ENTER_STANDARD_NAME(RID, LOWER, UPPER) \\\n+  ridpointers[(int) RID] = \\\n+    get_identifier (lowercase_standard_names ? LOWER : UPPER)\n+\n+  ENTER_STANDARD_NAME (RID_ALL,\t\t\"all\",\t\t\"ALL\");\n+  ENTER_STANDARD_NAME (RID_ASSERTFAIL,\t\"assertfail\",\t\"ASSERTFAIL\");\n+  ENTER_STANDARD_NAME (RID_ASSOCIATION,\t\"association\",\t\"ASSOCIATION\");\n+  ENTER_STANDARD_NAME (RID_BIN,         \"bin\",          \"BIN\");\n+  ENTER_STANDARD_NAME (RID_BOOL,\t\"bool\",\t\t\"BOOL\");\n+  ENTER_STANDARD_NAME (RID_BOOLS,\t\"bools\",\t\"BOOLS\");\n+  ENTER_STANDARD_NAME (RID_BYTE,\t\"byte\",\t\t\"BYTE\");\n+  ENTER_STANDARD_NAME (RID_CHAR,\t\"char\",\t\t\"CHAR\");\n+  ENTER_STANDARD_NAME (RID_DOUBLE,\t\"double\",\t\"DOUBLE\");\n+  ENTER_STANDARD_NAME (RID_DURATION,    \"duration\",     \"DURATION\");\n+  ENTER_STANDARD_NAME (RID_DYNAMIC,\t\"dynamic\",\t\"DYNAMIC\");\n+  ENTER_STANDARD_NAME (RID_ELSE,\t\"else\",\t\t\"ELSE\");\n+  ENTER_STANDARD_NAME (RID_EMPTY,\t\"empty\",\t\"EMPTY\");\n+  ENTER_STANDARD_NAME (RID_FALSE,\t\"false\",\t\"FALSE\");\n+  ENTER_STANDARD_NAME (RID_FLOAT,\t\"float\",\t\"FLOAT\");\n+  ENTER_STANDARD_NAME (RID_GENERAL,\t\"general\",\t\"GENERAL\");\n+  ENTER_STANDARD_NAME (RID_IN,\t\t\"in\",\t\t\"IN\");\n+  ENTER_STANDARD_NAME (RID_INLINE,\t\"inline\",\t\"INLINE\");\n+  ENTER_STANDARD_NAME (RID_INOUT,\t\"inout\",\t\"INOUT\");\n+  ENTER_STANDARD_NAME (RID_INSTANCE,\t\"instance\",\t\"INSTANCE\");\n+  ENTER_STANDARD_NAME (RID_INT,\t\t\"int\",\t\t\"INT\");\n+  ENTER_STANDARD_NAME (RID_LOC,\t\t\"loc\",\t\t\"LOC\");\n+  ENTER_STANDARD_NAME (RID_LONG,\t\"long\",\t\t\"LONG\");\n+  ENTER_STANDARD_NAME (RID_LONG_REAL,\t\"long_real\",\t\"LONG_REAL\");\n+  ENTER_STANDARD_NAME (RID_NULL,\t\"null\",\t\t\"NULL\");\n+  ENTER_STANDARD_NAME (RID_OUT,\t\t\"out\",\t\t\"OUT\");\n+  ENTER_STANDARD_NAME (RID_OVERFLOW,\t\"overflow\",\t\"OVERFLOW\");\n+  ENTER_STANDARD_NAME (RID_PTR,\t\t\"ptr\",\t\t\"PTR\");\n+  ENTER_STANDARD_NAME (RID_READ,\t\"read\",\t\t\"READ\");\n+  ENTER_STANDARD_NAME (RID_REAL,\t\"real\",\t\t\"REAL\");\n+  ENTER_STANDARD_NAME (RID_RANGE,\t\"range\",\t\"RANGE\");\n+  ENTER_STANDARD_NAME (RID_RANGEFAIL,\t\"rangefail\",\t\"RANGEFAIL\");\n+  ENTER_STANDARD_NAME (RID_RECURSIVE,\t\"recursive\",\t\"RECURSIVE\");\n+  ENTER_STANDARD_NAME (RID_SHORT,\t\"short\",\t\"SHORT\");\n+  ENTER_STANDARD_NAME (RID_SIMPLE,\t\"simple\",\t\"SIMPLE\");\n+  ENTER_STANDARD_NAME (RID_TIME,        \"time\",         \"TIME\");\n+  ENTER_STANDARD_NAME (RID_TRUE,\t\"true\",\t\t\"TRUE\");\n+  ENTER_STANDARD_NAME (RID_UBYTE,\t\"ubyte\",\t\"UBYTE\");\n+  ENTER_STANDARD_NAME (RID_UINT,\t\"uint\",\t\t\"UINT\");\n+  ENTER_STANDARD_NAME (RID_ULONG,\t\"ulong\",\t\"ULONG\");\n+  ENTER_STANDARD_NAME (RID_UNSIGNED,\t\"unsigned\",\t\"UNSIGNED\");\n+  ENTER_STANDARD_NAME (RID_USHORT,\t\"ushort\",\t\"USHORT\");\n+  ENTER_STANDARD_NAME (RID_VOID,\t\"void\",\t\t\"VOID\");\n+\n+  return filename;\n+}\n+\n+void\n+finish_parse ()\n+{\n+  if (finput != NULL)\n+    fclose (finput);\n+}\n+\f\n+static int yywrap ();\n+\n+#define YY_PUTBACK_SIZE 5\n+#define YY_BUF_SIZE 1000\n+\n+static char yy_buffer[YY_PUTBACK_SIZE + YY_BUF_SIZE];\n+static char *yy_cur = yy_buffer + YY_PUTBACK_SIZE;\n+static char *yy_lim = yy_buffer + YY_PUTBACK_SIZE;\n+\n+int yy_refill ()\n+{\n+  char *buf = yy_buffer + YY_PUTBACK_SIZE;\n+  int c, result;\n+  bcopy (yy_cur - YY_PUTBACK_SIZE, yy_buffer, YY_PUTBACK_SIZE);\n+  yy_cur = buf;\n+\n+ retry:\n+  if (saw_eof)\n+    {\n+      if (yywrap ())\n+\treturn EOF;\n+      saw_eof = 0;\n+      goto retry;\n+    }\n+\n+  result = 0;\n+  while (saw_eol)\n+    {\n+      c = check_newline ();\n+      if (c == EOF)\n+        {\n+\t  saw_eof = 1;\n+\t  goto retry;\n+\t}\n+      else if (c != '\\n')\n+\t{\n+\t  saw_eol = 0;\n+\t  buf[result++] = c;\n+\t}\n+    }\n+  \n+  while (result < YY_BUF_SIZE)\n+    {\n+      c = getc(finput);\n+      if (c == EOF)\n+        {\n+\t  saw_eof = 1;\n+\t  break;\n+\t}\n+      buf[result++] = c;\n+      \n+      /* Because we might switch input files on a compiler directive\n+\t (that end with '>', don't read past a '>', just in case. */\n+      if (c == '>')\n+\tbreak;\n+      \n+      if (c == '\\n')\n+\t{\n+#ifdef YYDEBUG\n+\t  extern int yydebug;\n+\t  if (yydebug)\n+            fprintf (stderr, \"-------------------------- finished Line %d\\n\",\n+\t\t     yylineno);\n+#endif\n+\t  saw_eol = 1;\n+\t  break;\n+\t}\n+    }\n+\n+  yy_lim = yy_cur + result;\n+\n+  return yy_lim > yy_cur ? *yy_cur++ : EOF;\n+}\n+\n+#define input() (yy_cur < yy_lim ? *yy_cur++ : yy_refill ())\n+\n+#define unput(c) (*--yy_cur = (c))\n+\f\n+\n+int starting_pass_2 = 0;\n+\n+int\n+yylex ()\n+{\n+  int nextc;\n+  int len;\n+  char* tmp;\n+  int base;\n+  int ch;\n+ retry:\n+  ch = input ();\n+  if (starting_pass_2)\n+    {\n+      starting_pass_2 = 0;\n+      unput (ch);\n+      return END_PASS_1;\n+    }\n+  switch (ch)\n+    {\n+    case ' ': case '\\t': case '\\n': case '\\f': case '\\b': case '\\v': case '\\r':\n+      goto retry;\n+    case '[':\n+      return LPC;\n+    case ']':\n+      return RPC;\n+    case '{':\n+      return LC;\n+    case '}':\n+      return RC;\n+    case '(':\n+      nextc = input ();\n+      if (nextc == ':')\n+\treturn LPC;\n+      unput (nextc);\n+      return LPRN;\n+    case ')':\n+      return RPRN;\n+    case ':':\n+      nextc = input ();\n+      if (nextc == ')')\n+\treturn RPC;\n+      else if (nextc == '=')\n+\treturn ASGN;\n+      unput (nextc);\n+      return COLON;\n+    case ',':\n+      return COMMA;\n+    case ';':\n+      return SC;\n+    case '+':\n+      return PLUS;\n+    case '-':\n+      nextc = input ();\n+      if (nextc == '>')\n+\treturn ARROW;\n+      if (nextc == '-')\n+\t{\n+\t  skip_line_comment ();\n+\t  goto retry;\n+\t}\n+      unput (nextc);\n+      return SUB;\n+    case '*':\n+      return MUL;\n+    case '=':\n+      return EQL;\n+    case '/':\n+      nextc = input ();\n+      if (nextc == '/')\n+\treturn CONCAT;\n+      else if (nextc == '=')\n+\treturn NE;\n+      else if (nextc == '*')\n+\t{\n+\t  skip_c_comment ();\n+\t  goto retry;\n+\t}\n+      unput (nextc);\n+      return DIV;\n+    case '<':\n+      nextc = input ();\n+      if (nextc == '=')\n+\treturn LTE;\n+      if (nextc == '>')\n+\t{\n+\t  read_directive ();\n+\t  goto retry;\n+\t}\n+      unput (nextc);\n+      return LT;\n+    case '>':\n+      nextc = input ();\n+      if (nextc == '=')\n+\treturn GTE;\n+      unput (nextc);\n+      return GT;\n+\n+    case 'D': case 'd':\n+      base = 10;\n+      goto maybe_digits;\n+    case 'B': case 'b':\n+      base = 2;\n+      goto maybe_digits;\n+    case 'H': case 'h':\n+      base = 16;\n+      goto maybe_digits;\n+    case 'O': case 'o':\n+      base = 8;\n+      goto maybe_digits;\n+    case 'C': case 'c':\n+      nextc = input ();\n+      if (nextc == '\\'')\n+\t{\n+\t  int byte_val = 0;\n+\t  char *start;\n+\t  int len = 0;  /* Number of hex digits seen. */\n+\t  for (;;)\n+\t    {\n+\t      ch = input ();\n+\t      if (ch == '\\'')\n+\t\tbreak;\n+\t      if (ch == '_')\n+\t\tcontinue;\n+\t      if (!isxdigit (ch))           /* error on non-hex digit */\n+\t\t{\n+\t\t  if (pass == 1)\n+\t\t    error (\"invalid C'xx' \");\n+\t\t  break;\n+\t\t}\n+\t      if (ch >= 'a')\n+\t\tch -= ' ';\n+\t      ch -= '0';\n+\t      if (ch > 9)\n+\t\tch -= 7;\n+\t      byte_val *= 16;\n+\t      byte_val += (int)ch;\n+\n+\t      if (len & 1) /* collected two digits, save byte */\n+\t\tobstack_1grow (&temporary_obstack, (char) byte_val);\n+\t      len++;\n+\t    }\n+\t  start = obstack_finish (&temporary_obstack);\n+\t  yylval.ttype = string_or_char (len >> 1, start);\n+\t  obstack_free (&temporary_obstack, start);\n+\t  return len == 2 ? SINGLECHAR : STRING;\n+\t}\n+      unput (nextc);\n+      goto letter;\n+\n+    maybe_digits:\n+      nextc = input ();\n+      if (nextc == '\\'')\n+\t{\n+\t  char *start;\n+\t  obstack_1grow (&temporary_obstack, ch);\n+\t  obstack_1grow (&temporary_obstack, nextc);\n+\t  for (;;)\n+\t    {\n+\t      ch = input ();\n+\t      if (isalnum (ch))\n+\t\tobstack_1grow (&temporary_obstack, ch);\n+\t      else if (ch != '_')\n+\t\tbreak;\n+\t    }\n+\t  obstack_1grow (&temporary_obstack, '\\0');\n+\t  start = obstack_finish (&temporary_obstack);\n+\t  if (ch != '\\'')\n+\t    {\n+\t      unput (ch);\n+\t      yylval.ttype = convert_integer (start); /* Pass base? */\n+\t      return NUMBER;\n+\t    }\n+\t  else\n+\t    {\n+\t      yylval.ttype = convert_bitstring (start);\n+\t      return BITSTRING;\n+\t    }\n+\t}\n+      unput (nextc);\n+      goto letter;\n+\n+    case 'A':                                   case 'E':\n+    case 'F':  case 'G':             case 'I':  case 'J':\n+    case 'K':  case 'L':  case 'M':  case 'N':\n+    case 'P':  case 'Q':  case 'R':  case 'S':  case 'T':\n+    case 'U':  case 'V':  case 'W':  case 'X':  case 'Y':\n+    case 'Z':\n+    case 'a':                                   case 'e':\n+    case 'f':  case 'g':             case 'i':  case 'j':\n+    case 'k':  case 'l':  case 'm':  case 'n':\n+    case 'p':  case 'q':  case 'r':  case 's':  case 't':\n+    case 'u':  case 'v':  case 'w':  case 'x':  case 'y':\n+    case 'z':\n+    case '_':\n+    letter:\n+      return handle_name (read_identifier (ch));\n+    case '\\'':\n+      tmp = readstring ('\\'', &len);\n+      yylval.ttype = string_or_char (len, tmp);\n+      free (tmp);\n+      return len == 1 ? SINGLECHAR : STRING;\n+    case '\\\"':\n+      tmp = readstring ('\\\"', &len);\n+      yylval.ttype = build_chill_string (len, tmp);\n+      free (tmp);\n+      return STRING;\n+    case '.':\n+      nextc = input ();\n+      unput (nextc);\n+      if (isdigit (nextc)) /* || nextc == '_')  we don't start numbers with '_' */\n+\tgoto number;\n+      return DOT;\n+    case '0': case '1': case '2': case '3': case '4':\n+    case '5': case '6': case '7': case '8': case '9':\n+    number:\n+      yylval.ttype = read_number (ch);\n+      return TREE_CODE (yylval.ttype) == REAL_CST ? FLOATING : NUMBER;\n+    default:\n+      return ch;\n+    }\n+}\n+\n+static void\n+close_input_file (fn)\n+  char *fn;\n+{\n+  if (finput == NULL)\n+    abort ();\n+\n+  if (finput != stdin && fclose (finput) == EOF)\n+    {\n+      error (\"can't close %s\", fn);\n+      abort ();\n+    }\n+  finput = NULL;\n+}\n+\n+/* Return an identifier, starting with FIRST and then reading\n+   more characters using input().  Return an IDENTIFIER_NODE. */\n+\n+static tree\n+read_identifier (first)\n+     int first; /* First letter of identifier */\n+{\n+  tree id;\n+  char *start;\n+  for (;;)\n+    {\n+      obstack_1grow (&temporary_obstack, first);\n+      first = input ();\n+      if (first == EOF)\n+\tbreak;\n+      if (! isalnum (first) && first != '_')\n+\t{\n+\t  unput (first);\n+\t  break;\n+\t}\n+    }\n+  obstack_1grow (&temporary_obstack, '\\0');\n+  start = obstack_finish (&temporary_obstack);\n+  maybe_downcase (start);\n+  id = get_identifier (start);\n+  obstack_free (&temporary_obstack, start);\n+  return id;\n+}\n+\n+/* Given an identifier ID, check to see if it is a reserved name,\n+   and return the appropriate token type. */\n+\n+static int\n+handle_name (id)\n+     tree id;\n+{\n+  struct resword *tp;\n+  tp = in_word_set (IDENTIFIER_POINTER (id), IDENTIFIER_LENGTH (id));\n+  if (tp != NULL\n+      && special_UC == isupper (tp->name[0])\n+      && (tp->flags == RESERVED || tp->flags == PREDEF))\n+    {\n+      if (tp->rid != NORID)\n+\tyylval.ttype = ridpointers[tp->rid];\n+      else if (tp->token == THIS)\n+\tyylval.ttype = lookup_name (get_identifier (\"__whoami\"));\n+      return tp->token;\n+    }\n+  yylval.ttype = id;\n+  return NAME;\n+}\n+\n+static tree\n+read_number (ch)\n+     int ch; /* Initial character */\n+{\n+  tree num;\n+  char *start;\n+  int is_float = 0;\n+  for (;;)\n+    {\n+      if (ch != '_')\n+\tobstack_1grow (&temporary_obstack, ch);\n+      ch = input ();\n+      if (! isdigit (ch) && ch != '_')\n+\tbreak;\n+    }\n+  if (ch == '.')\n+    {\n+      do\n+\t{\n+\t  if (ch != '_')\n+\t    obstack_1grow (&temporary_obstack, ch);\n+\t  ch = input ();\n+\t} while (isdigit (ch) || ch == '_');\n+      is_float++;\n+    }\n+  if (ch == 'd' || ch == 'D' || ch == 'e' || ch == 'E')\n+    {\n+      /* Convert exponent indication [eEdD] to 'e'. */\n+      obstack_1grow (&temporary_obstack, 'e');\n+      ch = input ();\n+      if (ch == '+' || ch == '-')\n+\t{\n+\t  obstack_1grow (&temporary_obstack, ch);\n+\t  ch = input ();\n+\t}\n+      if (isdigit (ch) || ch == '_')\n+\t{\n+\t  do\n+\t    {\n+\t      if (ch != '_')\n+\t\tobstack_1grow (&temporary_obstack, ch);\n+\t      ch = input ();\n+\t    } while (isdigit (ch) || ch == '_');\n+\t}\n+      else\n+\t{\n+\t  error (\"malformed exponent part of floating-point literal\");\n+\t}\n+      is_float++;\n+    }\n+  if (ch != EOF)\n+    unput (ch);\n+  obstack_1grow (&temporary_obstack, '\\0');\n+  start = obstack_finish (&temporary_obstack);\n+  if (is_float)\n+    {\n+      REAL_VALUE_TYPE value;\n+      tree  type = double_type_node;\n+      errno = 0;\n+      value = REAL_VALUE_ATOF (start, TYPE_MODE (type));\n+      obstack_free (&temporary_obstack, start);\n+      if (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n+\t  && REAL_VALUE_ISINF (value) && pedantic)\n+\tpedwarn (\"real number exceeds range of REAL\");\n+      num = build_real (type, value);\n+    }\n+  else\n+    num = convert_integer (start);\n+  CH_DERIVED_FLAG (num) = 1;\n+  return num;\n+}\n+\n+/* Skip to the end of a compiler directive. */\n+\n+static void\n+skip_directive ()\n+{\n+  int ch = input ();\n+  for (;;)\n+    {\n+      if (ch == EOF)\n+\t{\n+\t  error (\"end-of-file in '<>' directive\");\n+\t  break;\n+\t}\n+      if (ch == '\\n')\n+\tbreak;\n+      if (ch == '<')\n+\t{\n+\t  ch = input ();\n+\t  if (ch == '>')\n+\t    break;\n+\t}\n+      ch = input ();\n+    }\n+  starting_pass_2 = 0;\n+}\n+\n+/* Read a compiler directive.  (\"<>{WS}\" have already been read. ) */\n+static void\n+read_directive ()\n+{\n+  struct resword *tp;\n+  tree id;\n+  int ch = skip_whitespace();\n+  if (isalpha (ch) || ch == '_')\n+    id = read_identifier (ch);\n+  else if (ch == EOF)\n+    {\n+      error (\"end-of-file in '<>' directive\"); \n+      to_global_binding_level (); \n+      return;\n+    }\n+  else\n+    {\n+      warning (\"unrecognized compiler directive\");\n+      skip_directive ();\n+      return;\n+    }\n+  tp = in_word_set (IDENTIFIER_POINTER (id), IDENTIFIER_LENGTH (id));\n+  if (tp == NULL || special_UC != isupper (tp->name[0]))\n+    {\n+      if (pass == 1)\n+\twarning (\"unrecognized compiler directive `%s'\",\n+\t\t IDENTIFIER_POINTER (id));\n+    }\n+  else\n+    switch (tp->token)\n+      {\n+      case ALL_STATIC_OFF:\n+\tall_static_flag = 0;\n+\tbreak;\n+      case ALL_STATIC_ON:\n+\tall_static_flag = 1;\n+\tbreak;\n+      case EMPTY_OFF:\n+\tempty_checking = 0;\n+\tbreak;\n+      case EMPTY_ON:\n+\tempty_checking = 1;\n+\tbreak;\n+      case IGNORED_DIRECTIVE:\n+\tbreak;\n+      case PROCESS_TYPE_TOKEN:\n+\tprocess_type = equal_number ();\n+\tbreak;\n+      case RANGE_OFF:\n+\trange_checking = 0;\n+\tbreak;\n+      case RANGE_ON:\n+\trange_checking = 1;\n+\tbreak;\n+      case SEND_SIGNAL_DEFAULT_PRIORITY: \n+\tsend_signal_prio = equal_number ();\n+\tbreak;\n+      case SEND_BUFFER_DEFAULT_PRIORITY:\n+\tsend_buffer_prio = equal_number ();\n+\tbreak;\n+      case SIGNAL_CODE:\n+\tsignal_code = equal_number ();\n+\tbreak;\n+      case USE_SEIZE_FILE:\n+\thandle_use_seizefile_directive (0);\n+\tbreak;\n+      case USE_SEIZE_FILE_RESTRICTED:\n+\thandle_use_seizefile_directive (1);\n+\tbreak;\n+      default:\n+\tif (pass == 1)\n+\t  warning (\"unrecognized compiler directive `%s'\", \n+\t\t   IDENTIFIER_POINTER (id));\n+\tbreak;\n+      }\n+  skip_directive ();\n+}\n+\n+\f\n+tree\n+build_chill_string (len, str)\n+    int   len;\n+    char  *str;\n+{\n+  tree t;\n+\n+  push_obstacks (&permanent_obstack, &permanent_obstack);\n+  t = build_string (len, str);\n+  TREE_TYPE (t) = build_string_type (char_type_node, \n+\t\t\t\t     build_int_2 (len, 0));\n+  CH_DERIVED_FLAG (t) = 1;\n+  pop_obstacks ();\n+  return t;\n+}\n+\n+\n+static tree\n+string_or_char (len, str)\n+     int   len;\n+     char *str;\n+{\n+  tree result;\n+  \n+  push_obstacks (&permanent_obstack, &permanent_obstack);\n+  if (len == 1)\n+    {\n+      result = build_int_2 ((unsigned char)str[0], 0);\n+      CH_DERIVED_FLAG (result) = 1;\n+      TREE_TYPE (result) = char_type_node;\n+    }\n+  else\n+    result = build_chill_string (len, str);\n+  pop_obstacks ();\n+  return result;\n+}\n+\n+\n+static void\n+maybe_downcase (str)\n+    char        *str;\n+{\n+  if (! ignore_case)\n+    return;\n+  while (*str)\n+    {\n+      if (isupper (*str))\n+\t*str = tolower (*str);\n+      str++;\n+    }\n+}\n+\n+\n+static int\n+maybe_number (s)\n+  char\t*s;\n+{\n+  char\tfc;\n+  \n+  /* check for decimal number */\n+  if (*s >= '0' && *s <= '9')\n+    {\n+      while (*s)\n+\t{\n+\t  if (*s >= '0' && *s <= '9')\n+\t    s++;\n+\t  else\n+\t    return 0;\n+\t}\n+      return 1;\n+    }\n+  \n+  fc = *s;\n+  if (s[1] != '\\'')\n+    return 0;\n+  s += 2;\n+  while (*s)\n+    {\n+      switch (fc)\n+\t{\n+\tcase 'd':\n+\tcase 'D':\n+\t  if (*s < '0' || *s > '9')\n+\t    return 0;\n+\t  break;\n+\tcase 'h':\n+\tcase 'H':\n+\t  if (!isxdigit (*s))\n+\t    return 0;\n+\t  break;\n+\tcase 'b':\n+\tcase 'B':\n+\t  if (*s < '0' || *s > '1')\n+\t    return 0;\n+\t  break;\n+\tcase 'o':\n+\tcase 'O':\n+\t  if (*s < '0' || *s > '7')\n+\t    return 0;\n+\t  break;\n+\tdefault:\n+\t  return 0;\n+\t}\n+      s++;\n+    }\n+  return 1;\n+}\n+\n+static void\n+push_back (c)\n+char c;\n+{\n+  if (c == '\\n')\n+    lineno--;\n+  unput (c);\n+}\n+\f\n+static char *\n+readstring (terminator, len)\n+     char terminator;\n+     int *len;\n+{\n+  int      c;\n+  unsigned allocated = 1024;\n+  char    *tmp = xmalloc (allocated);\n+  int      i = 0;\n+  \n+  for (;;)\n+    {\n+      c = input ();\n+      if (c == terminator)\n+\t{\n+\t  if ((c = input ()) != terminator)\n+\t    {\n+\t      unput (c);\n+\t      break;\n+\t    }\n+\t  else\n+\t    c = terminator;\n+\t}\n+      if (c == '\\n' || c == EOF)\n+\t  goto unterminated;\n+      if (c == '^')\n+\t{\n+\t  c = input();\n+\t  if (c == EOF || c == '\\n')\n+\t    goto unterminated;\n+\t  if (c == '^')\n+\t    goto storeit;\n+\t  if (c == '(')\n+\t    {\n+\t      int cc, count = 0;\n+\t      int base = 10;\n+\t      int next_apos = 0;\n+\t      int check_base = 1;\n+\t      c = 0;\n+\t      while (1)\n+\t\t{\n+\t\t  cc = input ();\n+\t\t  if (cc == terminator)\n+\t\t    {\n+\t\t      if (!(terminator == '\\'' && next_apos))\n+\t\t\t{\n+\t\t\t  error (\"unterminated control sequence\");\n+\t\t\t  serious_errors++;\n+\t\t\t  goto done;\n+\t\t\t}\n+\t\t    }\n+\t\t  if (cc == EOF || cc == '\\n')\n+\t\t    {\n+\t\t      c = cc;\n+\t\t      goto unterminated;\n+\t\t    }\n+\t\t  if (next_apos)\n+\t\t    {\n+\t\t      next_apos = 0;\n+\t\t      if (cc != '\\'')\n+\t\t\t{\n+\t\t\t  error (\"invalid integer literal in control sequence\");\n+\t\t\t  serious_errors++;\n+\t\t\t  goto done;\n+\t\t\t}\n+\t\t      continue;\n+\t\t    }\n+\t\t  if (cc == ' ' || cc == '\\t')\n+\t\t    continue;\n+\t\t  if (cc == ')')\n+\t\t    {\n+\t\t      if ((c < 0 || c > 255) && (pass == 1))\n+\t\t\terror (\"control sequence overflow\");\n+\t\t      if (! count && pass == 1)\n+\t\t\terror (\"invalid control sequence\");\n+\t\t      break;\n+\t\t    }\n+\t\t  else if (cc == ',')\n+\t\t    {\n+\t\t      if ((c < 0 || c > 255) && (pass == 1))\n+\t\t\terror (\"control sequence overflow\");\n+\t\t      if (! count && pass == 1)\n+\t\t\terror (\"invalid control sequence\");\n+\t\t      tmp[i++] = c;\n+\t\t      if (i == allocated)\n+\t\t\t{\n+\t\t\t  allocated += 1024;\n+\t\t\t  tmp = xrealloc (tmp, allocated);\n+\t\t\t}\n+\t\t      c = count = 0;\n+\t\t      base = 10;\n+\t\t      check_base = 1;\n+\t\t      continue;\n+\t\t    }\n+\t\t  else if (cc == '_')\n+\t\t    {\n+\t\t      if (! count && pass == 1)\n+\t\t\terror (\"invalid integer literal in control sequence\");\n+\t\t      continue;\n+\t\t    }\n+\t\t  if (check_base)\n+\t\t    {\n+\t\t      if (cc == 'D' || cc == 'd')\n+\t\t\t{\n+\t\t\t  base = 10;\n+\t\t\t  next_apos = 1;\n+\t\t\t}\n+\t\t      else if (cc == 'H' || cc == 'h')\n+\t\t\t{\n+\t\t\t  base = 16;\n+\t\t\t  next_apos = 1;\n+\t\t\t}\n+\t\t      else if (cc == 'O' || cc == 'o')\n+\t\t\t{\n+\t\t\t  base = 8;\n+\t\t\t  next_apos = 1;\n+\t\t\t}\n+\t\t      else if (cc == 'B' || cc == 'b')\n+\t\t\t{\n+\t\t\t  base = 2;\n+\t\t\t  next_apos = 1;\n+\t\t\t}\n+\t\t      check_base = 0;\n+\t\t      if (next_apos)\n+\t\t\tcontinue;\n+\t\t    }\n+\t\t  if (base == 2)\n+\t\t    {\n+\t\t      if (cc < '0' || cc > '1')\n+\t\t\tcc = -1;\n+\t\t      else\n+\t\t\tcc -= '0';\n+\t\t    }\n+\t\t  else if (base == 8)\n+\t\t    {\n+\t\t      if (cc < '0' || cc > '8')\n+\t\t\tcc = -1;\n+\t\t      else\n+\t\t\tcc -= '0';\n+\t\t    }\n+\t\t  else if (base == 10)\n+\t\t    {\n+\t\t      if (! isdigit (cc))\n+\t\t\tcc = -1;\n+\t\t      else\n+\t\t\tcc -= '0';\n+\t\t    }\n+\t\t  else if (base == 16)\n+\t\t    {\n+\t\t      if (!isxdigit (cc))\n+\t\t\tcc = -1;\n+\t\t      else\n+\t\t\t{\n+\t\t\t  if (cc >= 'a')\n+\t\t\t    cc -= ' ';\n+\t\t\t  cc -= '0';\n+\t\t\t  if (cc > 9)\n+\t\t\t    cc -= 7;\n+\t\t\t}\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      error (\"invalid base in read control sequence\");\n+\t\t      abort ();\n+\t\t    }\n+\t\t  if (cc == -1)\n+\t\t    {\n+\t\t      /* error in control sequence */\n+\t\t      if (pass == 1)\n+\t\t\terror (\"invalid digit in control sequence\");\n+\t\t      cc = 0;\n+\t\t    }\n+\t\t  c = (c * base) + cc;\n+\t\t  count++;\n+\t\t}\n+\t    }\n+\t  else\n+\t    c ^= 64;\n+\t}\n+    storeit:\n+      tmp[i++] = c;\n+      if (i == allocated)\n+\t{\n+\t  allocated += 1024;\n+\t  tmp = xrealloc (tmp, allocated);\n+\t}\n+    }\n+ done:\n+  tmp [*len = i] = '\\0';\n+  return tmp;\n+\n+unterminated:\n+  if (c == '\\n')\n+    unput ('\\n');\n+  *len = 1;\n+  if (pass == 1)\n+    error (\"unterminated string literal\");  \n+  to_global_binding_level ();\n+  tmp[0] = '\\0';\n+  return tmp;\n+}\n+\f\n+/* Convert an integer INTCHARS into an INTEGER_CST.\n+   INTCHARS is on the temporary_obstack, and is popped by this function. */\n+\n+static tree\n+convert_integer (intchars)\n+     char *intchars;\n+{\n+#ifdef YYDEBUG\n+  extern int yydebug;\n+#endif\n+  char *p = intchars;\n+  char         *oldp = p;\n+  int\t\tbase = 10, tmp;\n+  int           valid_chars = 0;\n+  int\t\toverflow = 0;\n+  tree\t\ttype;\n+  HOST_WIDE_INT val_lo = 0, val_hi = 0;\n+  tree\t\tval;\n+  \n+  /* determine the base */\n+  switch (*p)\n+    {\n+    case 'd':\n+    case 'D':\n+      p += 2;\n+      break;\n+    case 'o':\n+    case 'O':\n+      p += 2;\n+      base = 8;\n+      break;\n+    case 'h':\n+    case 'H':\n+      p += 2;\n+      base = 16;\n+      break;\n+    case 'b':\n+    case 'B':\n+      p += 2;\n+      base = 2;\n+      break;\n+    default:\n+      if (!isdigit (*p))   /* this test is for equal_number () */\n+\t{\n+\t  obstack_free (&temporary_obstack, intchars);\n+\t  return 0;\n+\t}\n+      break;\n+    }\n+  \n+  while (*p)\n+    {\n+      tmp = *p++;\n+      if ((tmp == '\\'') || (tmp == '_'))\n+\tcontinue;\n+      if (tmp < '0')\n+\tgoto bad_char;\n+      if (tmp >= 'a')      /* uppercase the char */\n+\ttmp -= ' ';\n+      switch (base)        /* validate the characters */\n+\t{\n+\tcase 2:\n+\t  if (tmp > '1')\n+\t    goto bad_char;\n+\t  break;\n+\tcase 8:\n+\t  if (tmp > '7')\n+\t    goto bad_char;\n+\t  break;\n+\tcase 10:\n+\t  if (tmp > '9')\n+\t    goto bad_char;\n+\t  break;\n+\tcase 16:\n+\t  if (tmp > 'F')\n+\t    goto bad_char;\n+\t  if (tmp > '9' && tmp < 'A')\n+\t    goto bad_char;\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      tmp -= '0';\n+      if (tmp > 9)\n+\ttmp -= 7;\n+      if (mul_double (val_lo, val_hi, base, 0, &val_lo, &val_hi))\n+\toverflow++;\n+      add_double (val_lo, val_hi, tmp, 0, &val_lo, &val_hi);\n+      if (val_hi < 0)\n+\toverflow++;\n+      valid_chars++;\n+    }\n+ bad_char:\n+  obstack_free (&temporary_obstack, intchars);\n+  if (!valid_chars)\n+    {\n+      if (pass == 2)\n+\terror (\"invalid number format `%s'\", oldp);\n+      return 0;\n+    }\n+  val = build_int_2 (val_lo, val_hi);\n+  /* We set the type to long long (or long long unsigned) so that\n+     constant fold of literals is less likely to overflow.  */\n+  if (int_fits_type_p (val, long_long_integer_type_node))\n+    type = long_long_integer_type_node;\n+  else\n+    {\n+      if (! int_fits_type_p (val, long_long_unsigned_type_node))\n+\toverflow++;\n+      type = long_long_unsigned_type_node;\n+    }\n+  TREE_TYPE (val) = type;\n+  CH_DERIVED_FLAG (val) = 1;\n+  \n+  if (overflow)\n+    error (\"integer literal too big\");\n+\n+  return val;\n+}\n+\f\n+/* Convert a bitstring literal on the temporary_obstack to\n+   a bitstring CONSTRUCTOR.  Free the literal from the obstack. */\n+\n+static tree\n+convert_bitstring (p)\n+     char *p;\n+{\n+#ifdef YYDEBUG\n+  extern int yydebug;\n+#endif\n+  int bl = 0, valid_chars = 0, bits_per_char = 0, c, k;\n+  tree initlist = NULL_TREE;\n+  tree val;\n+  \n+  /* Move p to stack so we can re-use temporary_obstack for result. */\n+  char *oldp = (char*) alloca (strlen (p) + 1);\n+  if (oldp == 0) fatal (\"stack space exhausted\");\n+  strcpy (oldp, p);\n+  obstack_free (&temporary_obstack, p);\n+  p = oldp;\n+  \n+  switch (*p)\n+    {\n+    case 'h':\n+    case 'H':\n+      bits_per_char = 4;\n+      break;\n+    case 'o':\n+    case 'O':\n+      bits_per_char = 3;\n+      break;\n+    case 'b':\n+    case 'B':\n+      bits_per_char = 1;\n+      break;\n+    }\n+  p += 2;\n+\n+  while (*p)\n+    {\n+      c = *p++;\n+      if (c == '_' || c == '\\'')\n+\tcontinue;\n+      if (c >= 'a')\n+\tc -= ' ';\n+      c -= '0';\n+      if (c > 9)\n+\tc -= 7;\n+      valid_chars++;\n+      \n+      for (k = BYTES_BIG_ENDIAN ? bits_per_char - 1 : 0;\n+\t   BYTES_BIG_ENDIAN ? k >= 0 : k < bits_per_char;\n+\t   bl++, BYTES_BIG_ENDIAN ? k-- : k++)\n+\t{\n+\t  if (c & (1 << k))\n+\t    initlist = tree_cons (NULL_TREE, build_int_2 (bl, 0), initlist);\n+        }\n+    }\n+#if 0\n+  /* as long as BOOLS(0) is valid it must tbe possible to\n+     specify an empty bitstring */\n+  if (!valid_chars)\n+    {\n+      if (pass == 2)\n+\terror (\"invalid number format `%s'\", oldp);\n+      return 0;\n+    }\n+#endif\n+  val = build (CONSTRUCTOR,\n+\t       build_bitstring_type (size_int (bl)),\n+\t       NULL_TREE, nreverse (initlist));\n+  TREE_CONSTANT (val) = 1;\n+  CH_DERIVED_FLAG (val) = 1;\n+  return val;\n+}\n+\f\n+/* Check if two filenames name the same file.\n+   This is done by stat'ing both files and comparing their inodes.\n+\n+   Note: we have to take care of seize_path_list. Therefore do it the same\n+   way as in yywrap. FIXME: This probably can be done better. */\n+\n+static int\n+same_file (filename1, filename2)\n+     char *filename1;\n+     char *filename2;\n+{\n+  struct stat s[2];\n+  char        *fn_input[2];\n+  int         i, stat_status;\n+  extern char *strchr();\n+  \n+  if (grant_only_flag)\n+    /* do nothing in this case */\n+    return 0;\n+\n+  /* if filenames are equal -- return 1, cause there is no need\n+     to search in the include list in this case */\n+  if (strcmp (filename1, filename2) == 0)\n+    return 1;\n+  \n+  fn_input[0] = filename1;\n+  fn_input[1] = filename2;\n+\n+  for (i = 0; i < 2; i++)\n+    {\n+      stat_status = stat (fn_input[i], &s[i]);\n+      if (stat_status < 0 &&\n+\t  strchr (fn_input[i], '/') == 0)\n+        {\n+\t  STRING_LIST *plp;\n+\t  char        *path;\n+\t  \n+\t  for (plp = seize_path_list; plp != 0; plp = plp->next)\n+\t    {\n+\t      path = (char *)xmalloc (strlen (fn_input[i]) +\n+\t\t\t\t      strlen (plp->str) + 2);\n+\t      sprintf (path, \"%s/%s\", plp->str, fn_input[i]);\n+\t      stat_status = stat (path, &s[i]);\n+\t      free (path);\n+\t      if (stat_status >= 0)\n+\t        break;\n+  \t    }\n+        }\n+      if (stat_status < 0)\n+        pfatal_with_name (fn_input[i]);\n+  }\n+  return s[0].st_ino == s[1].st_ino && s[0].st_dev == s[1].st_dev;\n+}\n+\n+/*\n+ * Note that simply appending included file names to a list in this\n+ * way completely eliminates the need for nested files, and the\n+ * associated book-keeping, since the EOF processing in the lexer\n+ * will simply process the files one at a time, in the order that the\n+ * USE_SEIZE_FILE directives were scanned.\n+ */\n+static void\n+handle_use_seizefile_directive (restricted)\n+    int restricted;\n+{\n+  tree seen;\n+  int   len;\n+  int   c = skip_whitespace ();\n+  char *use_seizefile_str = readstring (c, &len);\n+\n+  if (pass > 1)\n+    return;\n+\n+  if (c != '\\'' && c != '\\\"')\n+    {\n+      error (\"USE_SEIZE_FILE directive must be followed by string\");\n+      return;\n+    }\n+\n+  use_seizefile_name = get_identifier (use_seizefile_str);\n+  CH_USE_SEIZEFILE_RESTRICTED (use_seizefile_name) = restricted;\n+  \n+  if (!grant_only_flag)\n+    {\n+      /* If file foo.ch contains a <> use_seize_file \"bar.grt\" <>,\n+\t and file bar.ch contains a <> use_seize_file \"foo.grt\" <>,\n+\t then if we're compiling foo.ch, we will indirectly be\n+\t asked to seize foo.grt.  Don't. */\n+      extern char *grant_file_name;\n+      if (strcmp (use_seizefile_str, grant_file_name) == 0)\n+\treturn;\n+\n+      /* Check if the file is already on the list. */\n+      for (seen = files_to_seize; seen != NULL_TREE; seen = TREE_CHAIN (seen))\n+\tif (same_file (IDENTIFIER_POINTER (TREE_VALUE (seen)),\n+\t\t       use_seizefile_str))\n+\t  return;  /* Previously seen; nothing to do. */\n+    }\n+\n+  /* Haven't been asked to seize this file yet, so add\n+     its name to the list. */\n+  {\n+    tree pl = perm_tree_cons (0, use_seizefile_name, NULL_TREE);\n+    if (files_to_seize == NULL_TREE)\n+      files_to_seize = pl;\n+    else\n+      TREE_CHAIN (last_file_to_seize) = pl;\n+    if (next_file_to_seize == NULL_TREE)\n+      next_file_to_seize = pl;\n+    last_file_to_seize = pl;\n+  }\n+}\n+\n+\n+/*\n+ * get input, convert to lower case for comparison\n+ */\n+int\n+getlc (file)\n+     FILE *file;\n+{\n+  register int c;\n+\n+  c = getc (file);  \n+  if (isupper (c) && ignore_case)\n+    c = tolower (c);\n+  return c;\n+}\n+\f\n+/* At the beginning of a line, increment the line number and process\n+   any #-directive on this line.  If the line is a #-directive, read\n+   the entire line and return a newline.  Otherwise, return the line's\n+   first non-whitespace character.\n+\n+   (Each language front end has a check_newline() function that is called\n+   from lang_init() for that language.  One of the things this function\n+   must do is read the first line of the input file, and if it is a #line\n+   directive, extract the filename from it and use it to initialize\n+   main_input_filename.  Proper generation of debugging information in\n+   the normal \"front end calls cpp then calls cc1XXXX environment\" depends\n+   upon this being done.) */\n+\n+int\n+check_newline ()\n+{\n+  register int c;\n+\n+  lineno++;\n+\n+  /* Read first nonwhite char on the line.  */\n+\n+  c = getc (finput);\n+\n+  while (c == ' ' || c == '\\t')\n+    c = getc (finput);\n+\n+  if (c != '#' || inside_c_comment)\n+    {\n+      /* If not #, return it so caller will use it.  */\n+      return c;\n+    }\n+\n+  /* Read first nonwhite char after the `#'.  */\n+\n+  c = getc (finput);\n+  while (c == ' ' || c == '\\t')\n+    c = getc (finput);\n+\n+  /* If a letter follows, then if the word here is `line', skip\n+     it and ignore it; otherwise, ignore the line, with an error\n+     if the word isn't `pragma', `ident', `define', or `undef'.  */\n+\n+  if (isupper (c) && ignore_case)\n+    c = tolower (c);\n+\n+  if (c >= 'a' && c <= 'z')\n+    {\n+      if (c == 'p')\n+\t{\n+\t  if (getlc (finput) == 'r'\n+\t      && getlc (finput) == 'a'\n+\t      && getlc (finput) == 'g'\n+\t      && getlc (finput) == 'm'\n+\t      && getlc (finput) == 'a'\n+\t      && (isspace (c = getlc (finput))))\n+\t    {\n+#ifdef HANDLE_PRAGMA\n+\t      return HANDLE_PRAGMA (finput, c);\n+#else\n+\t      goto skipline;\n+#endif /* HANDLE_PRAGMA */\n+\t    }\n+\t}\n+\n+      else if (c == 'd')\n+\t{\n+\t  if (getlc (finput) == 'e'\n+\t      && getlc (finput) == 'f'\n+\t      && getlc (finput) == 'i'\n+\t      && getlc (finput) == 'n'\n+\t      && getlc (finput) == 'e'\n+\t      && (isspace (c = getlc (finput))))\n+\t    {\n+#if 0 /*def DWARF_DEBUGGING_INFO*/\n+\t      if (c != '\\n'\n+\t\t  && (debug_info_level == DINFO_LEVEL_VERBOSE)\n+\t\t  && (write_symbols == DWARF_DEBUG))\n+\t        dwarfout_define (lineno, get_directive_line (finput));\n+#endif /* DWARF_DEBUGGING_INFO */\n+\t      goto skipline;\n+\t    }\n+\t}\n+      else if (c == 'u')\n+\t{\n+\t  if (getlc (finput) == 'n'\n+\t      && getlc (finput) == 'd'\n+\t      && getlc (finput) == 'e'\n+\t      && getlc (finput) == 'f'\n+\t      && (isspace (c = getlc (finput))))\n+\t    {\n+#if 0 /*def DWARF_DEBUGGING_INFO*/\n+\t      if (c != '\\n'\n+\t\t  && (debug_info_level == DINFO_LEVEL_VERBOSE)\n+\t\t  && (write_symbols == DWARF_DEBUG))\n+\t        dwarfout_undef (lineno, get_directive_line (finput));\n+#endif /* DWARF_DEBUGGING_INFO */\n+\t      goto skipline;\n+\t    }\n+\t}\n+      else if (c == 'l')\n+\t{\n+\t  if (getlc (finput) == 'i'\n+\t      && getlc (finput) == 'n'\n+\t      && getlc (finput) == 'e'\n+\t      && ((c = getlc (finput)) == ' ' || c == '\\t'))\n+\t    goto linenum;\n+\t}\n+#if 0\n+      else if (c == 'i')\n+\t{\n+\t  if (getlc (finput) == 'd'\n+\t      && getlc (finput) == 'e'\n+\t      && getlc (finput) == 'n'\n+\t      && getlc (finput) == 't'\n+\t      && ((c = getlc (finput)) == ' ' || c == '\\t'))\n+\t    {\n+\t      /* #ident.  The pedantic warning is now in cccp.c.  */\n+\n+\t      /* Here we have just seen `#ident '.\n+\t\t A string constant should follow.  */\n+\n+\t      while (c == ' ' || c == '\\t')\n+\t\tc = getlc (finput);\n+\n+\t      /* If no argument, ignore the line.  */\n+\t      if (c == '\\n')\n+\t\treturn c;\n+\n+\t      ungetc (c, finput);\n+\t      token = yylex ();\n+\t      if (token != STRING\n+\t\t  || TREE_CODE (yylval.ttype) != STRING_CST)\n+\t\t{\n+\t\t  error (\"invalid #ident\");\n+\t\t  goto skipline;\n+\t\t}\n+\n+\t      if (!flag_no_ident)\n+\t\t{\n+#ifdef ASM_OUTPUT_IDENT\n+\t\t  extern FILE *asm_out_file;\n+\t\t  ASM_OUTPUT_IDENT (asm_out_file, TREE_STRING_POINTER (yylval.ttype));\n+#endif\n+\t\t}\n+\n+\t      /* Skip the rest of this line.  */\n+\t      goto skipline;\n+\t    }\n+\t}\n+#endif\n+\n+      error (\"undefined or invalid # directive\");\n+      goto skipline;\n+    }\n+\n+linenum:\n+  /* Here we have either `#line' or `# <nonletter>'.\n+     In either case, it should be a line number; a digit should follow.  */\n+\n+  while (c == ' ' || c == '\\t')\n+    c = getlc (finput);\n+\n+  /* If the # is the only nonwhite char on the line,\n+     just ignore it.  Check the new newline.  */\n+  if (c == '\\n')\n+    return c;\n+\n+  /* Something follows the #; read a token.  */\n+\n+  if (isdigit(c))\n+    {\n+      int old_lineno = lineno;\n+      int used_up = 0;\n+      int l = 0;\n+      extern struct obstack permanent_obstack;\n+\n+      do\n+\t{\n+\t  l = l * 10 + (c - '0'); /* FIXME Not portable */\n+\t  c = getlc(finput);\n+\t} while (isdigit(c));\n+      /* subtract one, because it is the following line that\n+\t gets the specified number */\n+\n+      l--;\n+\n+      /* Is this the last nonwhite stuff on the line?  */\n+      c = getlc (finput);\n+      while (c == ' ' || c == '\\t')\n+\tc = getlc (finput);\n+      if (c == '\\n')\n+\t{\n+\t  /* No more: store the line number and check following line.  */\n+\t  lineno = l;\n+\t  return c;\n+\t}\n+\n+      /* More follows: it must be a string constant (filename).  */\n+\n+      /* Read the string constant, but don't treat \\ as special.  */\n+      ignore_escape_flag = 1;\n+      ignore_escape_flag = 0;\n+\n+      if (c != '\\\"')\n+\t{\n+\t  error (\"invalid #line\");\n+\t  goto skipline;\n+\t}\n+\n+      for (;;)\n+\t{\n+\t  c = getc (finput);\n+\t  if (c == EOF || c == '\\n')\n+\t    {\n+\t      error (\"invalid #line\");\n+\t      return c;\n+\t    }\n+\t  if (c == '\\\"')\n+\t    {\n+\t      obstack_1grow(&permanent_obstack, 0);\n+\t      input_filename = obstack_finish (&permanent_obstack);\n+\t      break;\n+\t    }\n+\t  obstack_1grow(&permanent_obstack, c);\n+\t}\n+\n+      lineno = l;\n+\n+      /* Each change of file name\n+\t reinitializes whether we are now in a system header.  */\n+      in_system_header = 0;\n+\n+      if (main_input_filename == 0)\n+\tmain_input_filename = input_filename;\n+\n+      /* Is this the last nonwhite stuff on the line?  */\n+      c = getlc (finput);\n+      while (c == ' ' || c == '\\t')\n+\tc = getlc (finput);\n+      if (c == '\\n')\n+\treturn c;\n+\n+      used_up = 0;\n+\n+      /* `1' after file name means entering new file.\n+\t `2' after file name means just left a file.  */\n+\n+      if (isdigit (c))\n+\t{\n+\t  if (c == '1')\n+\t    {\n+\t      /* Pushing to a new file.  */\n+\t      struct file_stack *p\n+\t\t= (struct file_stack *) xmalloc (sizeof (struct file_stack));\n+\t      input_file_stack->line = old_lineno;\n+\t      p->next = input_file_stack;\n+\t      p->name = input_filename;\n+\t      input_file_stack = p;\n+\t      input_file_stack_tick++;\n+#ifdef DWARF_DEBUGGING_INFO\n+\t      if (debug_info_level == DINFO_LEVEL_VERBOSE\n+\t\t  && write_symbols == DWARF_DEBUG)\n+\t\tdwarfout_start_new_source_file (input_filename);\n+#endif /* DWARF_DEBUGGING_INFO */\n+\n+\t      used_up = 1;\n+\t    }\n+\t  else if (c == '2')\n+\t    {\n+\t      /* Popping out of a file.  */\n+\t      if (input_file_stack->next)\n+\t\t{\n+\t\t  struct file_stack *p = input_file_stack;\n+\t\t  input_file_stack = p->next;\n+\t\t  free (p);\n+\t\t  input_file_stack_tick++;\n+#ifdef DWARF_DEBUGGING_INFO\n+\t\t  if (debug_info_level == DINFO_LEVEL_VERBOSE\n+\t\t      && write_symbols == DWARF_DEBUG)\n+\t\t    dwarfout_resume_previous_source_file (input_file_stack->line);\n+#endif /* DWARF_DEBUGGING_INFO */\n+\t\t}\n+\t      else\n+\t\terror (\"#-lines for entering and leaving files don't match\");\n+\n+\t      used_up = 1;\n+\t    }\n+\t}\n+\n+      /* If we have handled a `1' or a `2',\n+\t see if there is another number to read.  */\n+      if (used_up)\n+\t{\n+\t  /* Is this the last nonwhite stuff on the line?  */\n+\t  c = getlc (finput);\n+\t  while (c == ' ' || c == '\\t')\n+\t    c = getlc (finput);\n+\t  if (c == '\\n')\n+\t    return c;\n+\t  used_up = 0;\n+\t}\n+\n+      /* `3' after file name means this is a system header file.  */\n+\n+      if (c == '3')\n+\tin_system_header = 1;\n+    }\n+  else\n+    error (\"invalid #-line\");\n+\n+  /* skip the rest of this line.  */\n+ skipline:\n+  while (c != '\\n' && c != EOF)\n+    c = getc (finput);\n+  return c;\n+}\n+\n+\n+tree\n+get_chill_filename ()\n+{\n+  return (build_chill_string (\n+            strlen (input_filename) + 1,  /* +1 to get a zero terminated string */\n+\t      input_filename));\n+}\n+\n+tree\n+get_chill_linenumber ()\n+{\n+  return build_int_2 ((HOST_WIDE_INT)lineno, 0);\n+}\n+\n+\n+/* Assuming '/' and '*' have been read, skip until we've\n+   read the terminating '*' and '/'. */\n+\n+static void\n+skip_c_comment ()\n+{\n+  int c = input();\n+  int start_line = lineno;\n+\n+  inside_c_comment++;\n+  for (;;)\n+    if (c == EOF)\n+      {\n+\terror_with_file_and_line (input_filename, start_line,\n+\t\t\t\t  \"unterminated comment\");\n+\tbreak;\n+      }\n+    else if (c != '*')\n+      c = input();\n+    else if ((c = input ()) == '/')\n+      break;\n+  inside_c_comment--;\n+}\n+\n+\n+/* Assuming \"--\" has been read, skip until '\\n'. */\n+\n+static void\n+skip_line_comment ()\n+{\n+  for (;;)\n+    {\n+      int c = input ();\n+\n+      if (c == EOF)\n+\treturn;\n+      if (c == '\\n')\n+\tbreak;\n+    }\n+  unput ('\\n');\n+}\n+\n+\n+static int\n+skip_whitespace ()\n+{\n+  for (;;)\n+    {\n+      int c = input ();\n+\n+      if (c == EOF)\n+\treturn c;\n+      if (c == ' ' || c == '\\t' || c == '\\r' || c == '\\n' || c == '\\v')\n+\tcontinue;\n+      if (c == '/')\n+\t{\n+\t  c = input ();\n+\t  if (c == '*')\n+\t    {\n+\t      skip_c_comment ();\n+\t      continue;\n+\t    }\n+\t  else\n+\t    {\n+\t      unput (c);\n+\t      return '/';\n+\t    }\n+\t}\n+      if (c == '-')\n+\t{\n+\t  c = input ();\n+\t  if (c == '-')\n+\t    {\n+\t      skip_line_comment ();\n+\t      continue;\n+\t    }\n+\t  else\n+\t    {\n+\t      unput (c);\n+\t      return '-';\n+\t    }\n+\t}\n+      return c;\n+    }\n+}\n+\f\n+/*\n+ * avoid recursive calls to yylex to parse the ' = digits' or\n+ * ' = SYNvalue' which are supposed to follow certain compiler\n+ * directives.  Read the input stream, and return the value parsed.\n+ */\n+         /* FIXME: overflow check in here */\n+         /* FIXME: check for EOF around here */\n+static tree\n+equal_number ()\n+{\n+  int      c, result;\n+  char    *tokenbuf;\n+  char    *cursor;\n+  tree     retval = integer_zero_node;\n+  \n+  c = skip_whitespace();\n+  if ((char)c != '=')\n+    {\n+      if (pass == 2)\n+\terror (\"missing `=' in compiler directive\");\n+      return integer_zero_node;\n+    }\n+  c = skip_whitespace();\n+\n+  /* collect token into tokenbuf for later analysis */\n+  while (TRUE)\n+    {\n+      if (isspace (c) || c == '<')\n+\tbreak;\n+      obstack_1grow (&temporary_obstack, c);\n+      c = input ();\n+    }\n+  unput (c);             /* put uninteresting char back */\n+  obstack_1grow (&temporary_obstack, '\\0');        /* terminate token */\n+  tokenbuf = obstack_finish (&temporary_obstack);\n+  maybe_downcase (tokenbuf);\n+\n+  if (*tokenbuf == '-')\n+    /* will fail in the next test */\n+    result = BITSTRING;\n+  else if (maybe_number (tokenbuf))\n+    {\n+      if (pass == 1)\n+\treturn integer_zero_node;\n+      push_obstacks_nochange ();\n+      end_temporary_allocation ();\n+      yylval.ttype = convert_integer (tokenbuf);\n+      tokenbuf = 0;  /* Was freed by convert_integer. */\n+      result = yylval.ttype ? NUMBER : 0;\n+      pop_obstacks ();\n+    }\n+  else\n+    result = 0;\n+  \n+  if (result  == NUMBER)\n+    {\n+      retval = yylval.ttype;\n+    }\n+  else if (result == BITSTRING)\n+    {\n+      if (pass == 1)\n+        error (\"invalid value follows `=' in compiler directive\");\n+      goto finish;\n+    }\n+  else /* not a number */\n+    {\n+      cursor = tokenbuf;\n+      c = *cursor;\n+      if (!isalpha (c) && c != '_')\n+\t{\n+\t  if (pass == 1)\n+\t    error (\"invalid value follows `=' in compiler directive\");\n+\t  goto finish;\n+\t}\n+\n+      for (cursor = &tokenbuf[1]; *cursor != '\\0'; cursor++)\n+\tif (isalpha (*cursor) || *cursor == '_' || isdigit (*cursor))\n+\t  continue;\n+\telse\n+\t  {\n+\t    if (pass == 1)\n+\t      error (\"invalid `%c' character in name\", *cursor);\n+\t    goto finish;\n+\t  }\n+      if (pass == 1)\n+\tgoto finish;\n+      else\n+\t{\n+\t  tree value = lookup_name (get_identifier (tokenbuf));\n+\t  if (value == NULL_TREE\n+\t      || TREE_CODE (value) != CONST_DECL\n+\t      || TREE_CODE (DECL_INITIAL (value)) != INTEGER_CST)\n+\t    {\n+\t      if (pass == 2)\n+\t\terror (\"`%s' not integer constant synonym \",\n+\t\t       tokenbuf);\n+\t      goto finish;\n+\t    }\n+\t  obstack_free (&temporary_obstack, tokenbuf);\n+\t  tokenbuf = 0;\n+\t  push_obstacks_nochange ();\n+\t  end_temporary_allocation ();\n+\t  retval = convert (chill_taskingcode_type_node, DECL_INITIAL (value));\n+\t  pop_obstacks ();\n+\t}\n+    }\n+\n+  /* check the value */\n+  if (TREE_CODE (retval) != INTEGER_CST)\n+    {\n+      if (pass == 2)\n+\terror (\"invalid value follows `=' in compiler directive\");\n+    }\n+  else if (TREE_INT_CST_HIGH (retval) != 0 ||\n+\t   TREE_INT_CST_LOW (retval) > TREE_INT_CST_LOW (TYPE_MAX_VALUE (chill_unsigned_type_node)))\n+    {\n+      if (pass == 2)\n+\terror (\"value out of range in compiler directive\");\n+    }\n+ finish:\n+  if (tokenbuf)\n+    obstack_free (&temporary_obstack, tokenbuf);\n+  return retval;\n+}\n+\f\n+/*\n+ * add a possible grant-file path to the list\n+ */\n+void\n+register_seize_path (path)\n+     char *path;\n+{\n+  int          pathlen = strlen (path);\n+  char        *new_path = (char *)xmalloc (pathlen + 1);\n+  STRING_LIST *pl     = (STRING_LIST *)xmalloc (sizeof (STRING_LIST));\n+    \n+  /* strip off trailing slash if any */\n+  if (path[pathlen - 1] == '/')\n+    pathlen--;\n+\n+  memcpy (new_path, path, pathlen);\n+  pl->str  = new_path;\n+  pl->next = seize_path_list;\n+  seize_path_list = pl;\n+}\n+\n+\n+/* Used by decode_decl to indicate that a <> use_seize_file NAME <>\n+   directive has been written to the grantfile. */\n+\n+void\n+mark_use_seizefile_written (name)\n+     tree name;\n+{\n+  tree node;\n+\n+  for (node = files_to_seize;  node != NULL_TREE; node = TREE_CHAIN (node))\n+    if (TREE_VALUE (node) == name)\n+      {\n+\tTREE_PURPOSE (node) = integer_one_node;\n+\tbreak;\n+      }\n+}\n+\n+\n+static int\n+yywrap ()\n+{\n+  extern char *strchr ();\n+  extern char *chill_real_input_filename;\n+  tree node;\n+\n+  close_input_file (input_filename);\n+\n+  use_seizefile_name = NULL_TREE;\n+\n+  if (next_file_to_seize && !grant_only_flag)\n+    {\n+      FILE *grt_in = NULL;\n+      char *seizefile_name_chars\n+\t= IDENTIFIER_POINTER (TREE_VALUE (next_file_to_seize));\n+\n+      /* find a seize file, open it.  If it's not at the path the\n+       * user gave us, and that path contains no slashes, look on\n+       * the seize_file paths, specified by the '-I' options.\n+       */     \n+      grt_in = fopen (seizefile_name_chars, \"r\");\n+      if (grt_in == NULL \n+\t  && strchr (seizefile_name_chars, '/') == NULL)\n+\t{\n+\t  STRING_LIST *plp;\n+\t  char      *path;\n+\n+\t  for (plp = seize_path_list; plp != NULL; plp = plp->next)\n+\t    {\n+\t      path = (char *)xmalloc (strlen (seizefile_name_chars)\n+\t\t\t\t      + strlen (plp->str) + 2);\n+\n+\t      sprintf (path, \"%s/%s\", plp->str, seizefile_name_chars);\n+\t      grt_in = fopen (path, \"r\");\n+\t      if (grt_in == NULL)\n+\t\tfree (path);\n+\t      else\n+\t\t{\n+\t\t  seizefile_name_chars = path;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (grt_in == NULL)\n+\tpfatal_with_name (seizefile_name_chars);\n+\n+      finput = grt_in;\n+      input_filename = seizefile_name_chars;\n+\n+      lineno = 0;\n+      current_seizefile_name = TREE_VALUE (next_file_to_seize);\n+\n+      next_file_to_seize = TREE_CHAIN (next_file_to_seize);\n+\n+      saw_eof = 0;\n+      return 0;\n+    }\n+\n+  if (pass == 1)\n+    {\n+      next_file_to_seize = files_to_seize;\n+      current_seizefile_name = NULL_TREE;\n+\n+      if (strcmp (main_input_filename, \"stdin\"))\n+\tfinput = fopen (chill_real_input_filename, \"r\");\n+      else\n+\tfinput = stdin;\n+      if (finput == NULL)\n+\t{\n+\t  error (\"can't reopen %s\", chill_real_input_filename);\n+\t  return 1;\n+\t}\n+      input_filename = main_input_filename;\n+      ch_lex_init ();\n+      lineno = 0;\n+      /* Read a line directive if there is one.  */\n+      ungetc (check_newline (), finput);\n+      starting_pass_2 = 1;\n+      saw_eof = 0;\n+      if (module_number == 0)\n+\twarning (\"no modules seen\");\n+      return 0;\n+    }\n+  return 1;\n+}"}, {"sha": "ddd4aad7e429a7731d7e730438de4467fa417cf0", "filename": "gcc/ch/nloop.c", "status": "added", "additions": 1244, "deletions": 0, "changes": 1244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fnloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fnloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fnloop.c?ref=80a093b29e752ac54172945174c7cd59cec1fd05", "patch": "@@ -0,0 +1,1244 @@\n+/* Implement looping actions for CHILL.\n+   Copyright (C) 1992, 93, 1994 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <stdio.h>\n+#include <limits.h>\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"ch-tree.h\"\n+#include \"lex.h\"\n+#include \"flags.h\"\n+#include \"actions.h\"\n+#include \"input.h\"\n+#include \"obstack.h\"\n+#include \"assert.h\"\n+#include \"rtl.h\"\n+\n+/* if the user codes '-flocal-loop-counter' on the command line,\n+   ch-actions.c (lang_decode_option) will set this flag. */\n+int flag_local_loop_counter = 0;\n+\n+extern tree chill_truthvalue_conversion PROTO((tree));\n+extern rtx  emit_line_note              PROTO((char *, int)); \n+extern void error                       PROTO((char *, ...));\n+extern rtx  expand_assignment           PROTO((tree, tree, int, int));\n+extern void save_expr_under_name        PROTO((tree, tree));\n+extern void stamp_nesting_label         PROTO((tree));\n+extern int  int_fits_type_p             PROTO((tree, tree));\n+extern void warning                     PROTO((char *, ...));\n+\n+/* forward declarations */\n+static int  classify_loop            PROTO((void));\n+static int  declare_temps            PROTO((void));\n+static int  initialize_iter_var      PROTO((void));\n+static int  maybe_skip_loop          PROTO((void));\n+static int  top_loop_end_check       PROTO((void));\n+static int  bottom_loop_end_check    PROTO((void));\n+static int  increment_temps          PROTO((void));\n+static tree build_temporary_variable PROTO((char *, tree));\n+static tree maybe_make_for_temp      PROTO((tree, char *, tree));\n+static tree chill_unsigned_type      PROTO((tree));\n+\f\n+/* In terms of the parameters passed to build_loop_iterator,\n+ *   there are several types of loops.  They are encoded by\n+ *   the ITER_TYPE enumeration.\n+ *\n+ *   1) DO FOR EVER; ... OD\n+ *      indicated by a NULL_TREE start_exp, step_exp and end_exp,\n+ *      condition == NULL, in_flag = 0, and ever_flag == 1 in the\n+ *      first ITERATOR.\n+ *\n+ *   2) DO WHILE cond; ... OD\n+ *      indicated by NULL_TREE start_exp, step_exp and end_exp, \n+ *      in_flag = 0, and condition != NULL.\n+ *\n+ *   3) DO; ... OD\n+ *      indicated by NULL_TREEs in start_exp, step_exp and end_exp,\n+ *      condition != NULL, in_flag == 0 and ever_flag == 0.  This\n+ *      is not really a loop, but a compound statement.\n+ *\n+ *   4) DO FOR user_var := start_exp \n+ *         [DOWN] TO end_exp BY step_exp; ... DO\n+ *      indicated by non-NULL_TREE start_exp, step_exp and end_exp.\n+ *\n+ *   5) DO FOR user_var [DOWN] IN discrete_mode; ... OD\n+ *      indicated by in_flag == 1.  start_exp is a non-NULL_TREE \n+ *      discrete mode, with an optional down_flag.\n+ *\n+ *   6) DO FOR user_var [DOWN] IN powerset_expr; ... OD\n+ *      indicated by in_flag == 1.  start_exp is a non-NULL_TREE \n+ *      powerset mode, with an optional down_flag.\n+ *\n+ *   7) DO FOR user_var [DOWN] IN location; ... OD\n+ *      indicated by in_flag == 1.  start_exp is a non-NULL_TREE \n+ *      location mode, with an optional down_flag.\n+ */\n+typedef enum \n+{\n+   DO_UNUSED,\n+   DO_FOREVER,\n+   DO_WHILE,\n+   DO_OD,\n+   DO_STEP,\n+   DO_RANGE,\n+   DO_POWERSET,\n+   DO_LOC,\n+   DO_LOC_VARYING \n+} ITER_TYPE;\n+\n+\n+typedef struct iterator \n+{\n+/* These variables only have meaning in the first ITERATOR structure. */\n+  ITER_TYPE itype;                  /* type of this iterator */\n+  int  error_flag;                  /* TRUE if no loop was started due to \n+\t\t\t\t       user error */\n+  tree condition;                   /* WHILE condition expression */\n+  int  down_flag;                   /* TRUE if DOWN was coded */\n+\n+/* These variables have meaning in every ITERATOR structure. */\n+  tree user_var;                    /* user's explicit iteration variable */\n+  tree start_exp;                   /* user's start expression\n+                                       or IN expression of a FOR .. IN*/\n+  tree step_exp;                    /* user's step expression */\n+  tree end_exp;                     /* user's end expression */\n+  tree start_temp;                  /* temp holding evaluated start_exp */\n+  tree end_temp;                    /* temp holding evaluated end_exp */\n+  tree step_temp;                   /* temp holding evaluated step_exp */\n+  tree powerset_temp;               /* temp holding user's initial powerset expression */\n+  tree loc_ptr_temp;                /* temp holding count for LOC enumeration ptr */\n+  tree iter_var;                    /* hidden variable for the loop */\n+  tree iter_type;                   /* hidden variable's type */\n+  tree base_type;                   /* LOC enumeration base type */\n+  struct iterator *next;            /* ptr to next iterator for this loop */\n+} ITERATOR;\n+\n+/*\n+ * There's an entry like this for each nested DO loop.\n+ * The list is maintained by push_loop_block\n+ * and pop_loop_block.\n+ */\n+typedef struct loop {\n+  struct loop *nxt_level;   /* pointer to enclosing loop */\n+  ITERATOR    *iter_list;   /* iterators for the current loop */\n+} LOOP;\n+\n+static LOOP *loop_stack = (LOOP *)0;\n+\f\n+#if 0\n+\n+Here is a CHILL DO FOR statement:\n+\n+DO FOR user_var := start_exp BY step_exp [DOWN] TO end_exp \n+   WHILE condition;\n+\n+For this loop to be 'safe', like a Pascal FOR loop, the start,\n+end, and increment expressions are computed once, before the\n+assignment to the iteration variable and saved in temporaries,\n+before the first assignment of the iteration variable, so the\n+following works:\n+\n+          FOR i := (i+1) TO (i+10) DO\n+\n+To prevent changes to the start/end/step expressions from\n+effecting the loop''s termination, and to make the loop end-check\n+as simple as possible, we evaluate the step expression into\n+a temporary and compute a hidden iteration count before entering \n+the loop''s body.  User code cannot effect the counter, and the\n+end-loop check simply decrements the counter and checks for zero.\n+\n+The whole phrase FOR iter := ... TO end_exp can be repeated\n+multiple times, with different user-iteration variables.  This\n+is discussed later.\n+\n+The loop counter calculations need careful design since a loop\n+from MININT TO MAXINT must work, in the precision of integers.\n+\n+Here''s how it works, in C:\n+\n+        0) The DO ... OD loop is simply a block with \n+           its own scope.  \n+\n+\t1) The DO FOR EVER is simply implemented:\n+\n+\t   loop_top:\n+\t\t.\n+\t\t. body of loop\n+\t\t.\n+\t\tgoto loop_top\n+\t   end_loop:\n+\n+\t2) The DO WHILE is also simple:\n+\n+\n+\t   loop_top:\n+\t\tif (!condition) goto end_loop\n+\t\t.\n+\t\t. body of loop\n+\t\t.\n+\t\tgoto loop_top\n+\t   end_loop:\n+\n+\n+\t3) The DO FOR [while condition] loop (no DOWN)\n+\n+\tpush a new scope,\n+\tdecl iter_var\n+\n+\t\tstep_temp = step_exp\n+                start_temp = start_exp\n+                end_temp = end_exp\n+\t\tif (end_exp < start_exp) goto end_loop\n+                /* following line is all unsigned arithmetic */\n+\t\titer_var = (end_exp - start_exp + step_exp) / step_exp\n+                user_var = start_temp\n+\t   loop_top:\n+\t\tif (!condition) goto end_loop\n+\t\t.\n+\t\t. body of loop\n+\t\t.\n+                iter_var--\n+\t\tif (iter_var == 0) goto end_loop\n+                user_var += step_temp\n+\t\tgoto loop_top\n+\tend_loop:\n+\tpop scope\n+\n+\t4) The proposed CHILL for [while condition] loop (with DOWN)\n+\n+\tpush a new scope,\n+        decl iter\n+\t\tstep_temp = step_exp\n+                start_temp = start_exp\n+                end_temp = end_exp\n+\t\tif (end_exp > start_exp) goto end_loop\n+                /* following line is all unsigned arithmetic */\n+\t\titer_var = (start_exp - end_exp + step_exp) / step_exp\n+                user_var = start_temp\n+\t   loop_top:\n+\t\tif (!condition) goto end_loop\n+\t\t.\n+\t\t. body of loop\n+\t\t.\n+                iter_var--\n+\t\tif (iter_var == 0) goto end_loop\n+\t\tuser_var -= step_temp\n+\t\tgoto loop_top\n+\t    end_loop:\n+\tpop scope\n+\n+\n+        5) The range loop, which iterates over a mode''s possible\n+           values, works just like the above step loops, but with\n+           the start and end values taken from the mode''s lower\n+           and upper domain values.\n+\f\n+\n+\t6) The FOR IN loop, where a location enumeration is\n+           specified (see spec on page 81 of Z.200, bottom\n+           of page 186):\n+\n+\tpush a new scope,\n+        decl iter_var as an unsigned integer\n+             loc_ptr_temp as pointer to a composite base type\n+        \n+               if array is varying\n+                   iter_var = array''s length field\n+               else\n+                   iter_var = sizeof array / sizeof base_type\n+\t       loc_ptr_temp = &of highest or lowest indexable entry\n+\t   loop_top:\n+\t\tif (!condition) goto end_loop\n+\t\t.\n+\t\t. body of loop\n+\t\t.\n+                iter_var--\n+                if (iter_var == 0) goto end_loop               \n+\t\tloc_ptr_temp +/-= sizeof array base_type\n+\t\tgoto loop_top\n+\t   end_loop:\n+\tpop scope\n+\n+\t7) The DO FOR (DOWN) IN powerset_exp\n+\n+\tpush a new scope,\n+        decl powerset_temp\n+\tdecl iterator as basetype of powerset\n+\n+\t        powerset_temp := start_exp\n+\t   loop_top:\n+\t        /* if DOWN */\n+                if (__flsetclrpowerset () == 0) goto end_loop;\n+                /* not DOWN */\n+                if (__ffsetclrpowerset () == 0) goto end_loop;\n+\t\tif (!condition) goto end_loop\n+\t\t.\n+\t\t. body of loop\n+\t\t.\n+\t\tgoto loop_top\n+\t   end_loop:\n+\tpop scope\n+\f\n+\n+So, here''s the general DO FOR schema, as implemented here:\n+\n+        classify_loop       -- what type of loop have we?\n+                            -- build_iterator does some of this, also\n+        expand_start_loop   -- start the loop''s control scope\n+        -- start scope for synthesized loop variables\n+        declare_temps       -- create, initialize temporary variables\n+        maybe_skip_loop     -- skip loop if end conditions unsatisfiable\n+        initialize_iter_var -- initialize the iteration counter\n+                            -- initialize user''s loop variable\n+        expand_start_loop   -- generate top-of-loop label\n+        top_loop_end_check  -- generate while code and/or\n+                               powerset find-a-bit function call\n+        .\n+        .\n+        .  user''s loop body code\n+        .\n+        .\n+        bottom_loop_end_check  -- exit if counter has become zero\n+        increment_temps     -- update temps for next iteration\n+        expand_end_loop     -- generate jump back to top of loop\n+        expand_end_cond     -- generate label for end of conditional\n+        -- end of scope for synthesized loop variables\n+        free_iterators      -- free up iterator space\n+\n+When there are two or more iterator phrases, each of the\n+above loop steps must act upon all iterators.  For example,\n+the 'increment_temps' step must increment all temporaries\n+(associated with all iterators).\n+\n+ NOTE: Z.200, section 10.1 says that a block is ...\n+       \"the actions statement list in a do action, including any\n+       loop counter and while control\".  This means that an exp-\n+       ression in a WHILE control can include references to the\n+       loop counters created for the loop''s exclusive use.  \n+       Example:\n+\n+             DCL a (1:10) INT;\n+             DCL j INT;\n+             DO FOR j IN a WHILE j > 0;\n+             ...\n+             OD;\n+       The 'j' referenced in the while is the loc-identity 'j'\n+       created inside the loop''s scope, and NOT the 'j' declared\n+       before the loop.\n+#endif\n+\f\n+/*\n+ * The following routines are called directly by the\n+ * CHILL parser.\n+ */\n+void\n+push_loop_block ()\n+{\n+  LOOP *temp = (LOOP *)xmalloc (sizeof (LOOP));\n+\n+  /* push a new loop onto the stack */\n+  temp->nxt_level = loop_stack;\n+  temp->iter_list = (ITERATOR *)0;\n+  loop_stack = temp;\n+}\n+\n+void\n+pop_loop_block ()\n+{\n+  LOOP *do_temp = loop_stack;\n+  ITERATOR  *ip;\n+\n+  /* pop loop block off the list */\n+  loop_stack = do_temp->nxt_level;\n+\n+  /* free the loop's iterator blocks */\n+  ip = do_temp->iter_list;\n+  while (ip != NULL)\n+    {\n+      ITERATOR *temp = ip->next;\n+      free (ip);\n+      ip = temp;\n+    }\n+  free (do_temp);\n+}\n+\f\n+void\n+begin_loop_scope ()\n+{\n+  ITERATOR *firstp = loop_stack->iter_list;\n+\n+  if (pass < 2)\n+    return;\n+\n+  /*\n+   * We need to classify the loop and declare its temporaries\n+   * here, so as to define them before the WHILE condition\n+   * (if any) is parsed.  The WHILE expression may refer to\n+   * a temporary.\n+   */\n+  if (classify_loop ())\n+    return;\n+\n+  if (firstp->itype != DO_OD)\n+    declare_temps ();\n+  \n+  clear_last_expr ();\n+  push_momentary ();\n+  expand_start_bindings (0);\n+}\n+\n+\n+void\n+end_loop_scope (opt_label)\n+     tree opt_label;\n+{\n+  if (opt_label)\n+    possibly_define_exit_label (opt_label);\n+  poplevel (0, 0, 0);\n+\n+  if (pass < 2)\n+    return;\n+\n+  expand_end_bindings (getdecls (), kept_level_p (), 0);\n+  pop_momentary ();\n+}\n+\f\n+/* The iterator structure records all aspects of a \n+ * 'FOR i := start [DOWN] TO end' clause or\n+ * 'FOR i IN modename' or 'FOR i IN powerset' clause.\n+ * It's saved on the iter_list of the current LOOP.\n+ */\n+void\n+build_loop_iterator (user_var, start_exp, step_exp, end_exp, \n+\t\t     down_flag, in_flag, ever_flag)\n+     tree user_var, start_exp, step_exp, end_exp;\n+     int  down_flag, in_flag, ever_flag;\n+{\n+  ITERATOR *ip = (ITERATOR *)xmalloc (sizeof (ITERATOR));\n+\n+  /* chain this iterator onto the current loop */\n+  if (loop_stack->iter_list == NULL)\n+    loop_stack->iter_list = ip;\n+  else\n+    {\n+      ITERATOR *temp = loop_stack->iter_list;\n+      while (temp->next != NULL)\n+\ttemp = temp->next;\n+      temp->next = ip;\n+    }\n+\n+  ip->itype         = DO_UNUSED;\n+  ip->user_var      = user_var;\n+  ip->start_exp     = start_exp;\n+  ip->step_exp      = step_exp;\n+  ip->end_exp       = end_exp;\n+  ip->condition     = NULL_TREE;\n+  ip->start_temp    = NULL_TREE;\n+  ip->end_temp      = NULL_TREE;\n+  ip->step_temp     = NULL_TREE;\n+  ip->down_flag     = down_flag;\n+  ip->powerset_temp = NULL_TREE;\n+  ip->iter_var      = NULL_TREE;\n+  ip->iter_type     = NULL_TREE;\n+  ip->loc_ptr_temp  = NULL_TREE;\n+  ip->error_flag    = 1;          /* assume error will be found */\n+  ip->next          = (ITERATOR *)0;\n+\n+  if (ever_flag)\n+    ip->itype = DO_FOREVER;\n+  else if (in_flag && start_exp != NULL_TREE)\n+    {\n+      if (TREE_CODE (start_exp) == ERROR_MARK)\n+\treturn;\n+      if (TREE_CODE (TREE_TYPE (start_exp)) == SET_TYPE)\n+\tip->itype = DO_POWERSET;\n+      else if (discrete_type_p (TREE_TYPE (ip->start_exp)))\n+\tip->itype = DO_RANGE;\n+      else if (TREE_CODE (TREE_TYPE (ip->start_exp)) == ARRAY_TYPE)\n+\tip->itype = DO_LOC;\n+      else if (chill_varying_type_p (TREE_TYPE (ip->start_exp)))\n+\tip->itype = DO_LOC_VARYING;\n+      else\n+\t{\n+\t  error (\"Loop's IN expression is not a composite object\");\n+\t  return;\n+\t}\n+    }\n+  else if (start_exp == NULL_TREE && end_exp == NULL_TREE\n+\t   && step_exp == NULL_TREE && !down_flag)\n+    ip->itype = DO_OD;\n+  else\n+    {\n+      /* FIXME: Move this to the lexer? */\n+#define CST_FITS_INT(NODE) (TREE_CODE(NODE) == INTEGER_CST &&\\\n+            int_fits_type_p (NODE, integer_type_node))\n+\n+      tree max_prec_type = integer_type_node;\n+\n+      if (! discrete_type_p (TREE_TYPE (ip->start_exp)))\n+\t{\n+\t  error (\"start expr must have discrete mode\");\n+\t  return;\n+\t}\n+      if (TREE_CODE (TREE_TYPE (ip->start_exp)) == ENUMERAL_TYPE\n+\t  && CH_ENUM_IS_NUMBERED (TREE_TYPE (ip->start_exp)))\n+\t{\n+\t  error (\"DO FOR start expression is a numbered SET\");\n+\t  return;\n+\t}\n+      if (TREE_CODE (TREE_TYPE (ip->end_exp)) == ENUMERAL_TYPE\n+\t  && CH_ENUM_IS_NUMBERED (TREE_TYPE (ip->end_exp)))\n+\t{\n+\t  error (\"TO expression is a numbered SET\");\n+\t  return;\n+\t}\n+      /* Convert all three expressions to a common precision,\n+\t which is the largest precision they exhibit, but\n+         INTEGER_CST nodes are built in the lexer as\n+\t long_integer_type nodes.  We'll treat convert them to\n+\t integer_type_nodes if possible, for faster loop times. */\n+\n+      if (TYPE_PRECISION (max_prec_type) <\n+\t    TYPE_PRECISION (TREE_TYPE (ip->start_exp))\n+\t  && !CST_FITS_INT (ip->start_exp))\n+\tmax_prec_type = TREE_TYPE (ip->start_exp);\n+      if (! discrete_type_p (TREE_TYPE (ip->end_exp)))\n+\t{\n+\t  error (\"TO expr must have discrete mode\");\n+\t  return;\n+\t}\n+      if (! CH_COMPATIBLE (ip->start_exp, \n+\t\t\t   TREE_TYPE (ip->end_exp)))\n+\t{\n+\t  error (\"start expr and TO expr must be compatible\");\n+\t  return;\n+\t}\n+      if (TYPE_PRECISION (max_prec_type) <\n+\t    TYPE_PRECISION (TREE_TYPE (ip->end_exp))\n+\t  && !CST_FITS_INT (ip->end_exp))\n+\tmax_prec_type = TREE_TYPE (ip->end_exp);\n+      if (ip->step_exp != NULL_TREE)\n+\t{\n+\t  /* assure that default 'BY 1' gets a useful type */\n+\t  if (ip->step_exp == integer_one_node)\n+\t    ip->step_exp = convert (TREE_TYPE (ip->start_exp),\n+\t\t\t\t    ip->step_exp);\n+\t  if (! discrete_type_p (TREE_TYPE (ip->step_exp)))\n+\t    {\n+\t      error (\"BY expr must have discrete mode\");\n+\t      return;\n+\t    }\n+\t  if (! CH_COMPATIBLE (ip->start_exp,\n+\t\t  TREE_TYPE (ip->step_exp)))\n+\t    {\n+\t      error (\"start expr and BY expr must be compatible\");\n+\t      return;\n+\t    }\n+\t  if (TYPE_PRECISION (max_prec_type) <\n+\t\tTYPE_PRECISION (TREE_TYPE (ip->step_exp))\n+\t      && !CST_FITS_INT (ip->step_exp))\n+\t    max_prec_type = TREE_TYPE (ip->step_exp);\n+\t}\n+      if (TREE_CODE (ip->start_exp) == INTEGER_CST\n+\t  && TREE_CODE (ip->end_exp) == INTEGER_CST\n+\t  && compare_int_csts (ip->down_flag ? LT_EXPR : GT_EXPR,\n+\t\t\t       ip->start_exp, ip->end_exp))\n+\twarning (\"body of DO FOR will never execute\");\n+\n+      ip->start_exp = \n+\tconvert (max_prec_type, ip->start_exp);\n+      ip->end_exp   = \n+\tconvert (max_prec_type, ip->end_exp);\n+\n+      if (ip->step_exp != NULL_TREE)\n+\t{\n+\t  ip->step_exp =\n+\t    convert (max_prec_type, ip->step_exp);\n+\n+\t  if (TREE_CODE (ip->step_exp) != INTEGER_CST)\n+\t    {\n+\t      /* generate runtime check for negative BY expr */\n+\t      ip->step_exp = \n+\t\tcheck_range (ip->step_exp, ip->step_exp,\n+\t\t\t     integer_zero_node, NULL_TREE);\n+\t    }\n+\t  else if (compare_int_csts (LE_EXPR, ip->step_exp, integer_zero_node))\n+\t    {\n+\t      error (\"BY expression is negative or zero\");\n+\t      return;\n+\t    }\n+\t}\n+      ip->itype = DO_STEP;\n+    }\n+\n+  ip->error_flag = 0;           /* no errors! */\n+}\n+\f\n+void\n+build_loop_start (while_control, start_label)\n+     tree while_control, start_label;\n+{\n+  ITERATOR *firstp = loop_stack->iter_list;\n+  \n+  firstp->condition = while_control;\n+\n+  if (firstp->error_flag)\n+    return;\n+\n+  /* We didn't know at begin_loop_scope time about the condition;\n+     adjust iterator type now. */\n+  if (firstp->itype == DO_OD && firstp->condition)\n+    firstp->itype = DO_WHILE;\n+\n+  if (initialize_iter_var ())\n+    return;\n+  \n+  if (maybe_skip_loop ())\n+    return;\n+\n+  /* use the label as an 'exit' label, \n+     'goto' needs another sort of label */\n+  expand_start_loop (start_label != NULL_TREE);\n+  \n+  if (top_loop_end_check ())\n+    return;\n+  emit_line_note (input_filename, lineno); \n+}\n+\f\n+/*\n+ * Called after the last action of the loop body\n+ * has been parsed.\n+ */\n+void\n+build_loop_end ()\n+{\n+  ITERATOR *ip = loop_stack->iter_list;\n+\n+  emit_line_note (input_filename, lineno);\n+\n+  if (ip->error_flag)\n+    return;\n+\n+  if (bottom_loop_end_check ())\n+    return;\n+\n+  if (increment_temps ())\n+    return;\n+\n+  if (ip->itype != DO_OD)\n+    {\n+      expand_end_loop ();\n+\n+      for (; ip != NULL; ip = ip->next)\n+\t{\n+\t  switch (ip->itype)\n+\t    {\n+\t    case DO_LOC_VARYING:\n+\t    case DO_STEP:\n+\t      expand_end_cond ();\n+\t      break;\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+    }\n+}\n+\f\n+/*\n+ * The rest of the routines in this file are called from\n+ * the above three routines.\n+ */\n+static int\n+classify_loop ()\n+{\n+  ITERATOR *firstp = loop_stack->iter_list, *ip;\n+\n+  firstp->error_flag = 0;\n+  if (firstp->itype == DO_UNUSED || firstp->itype == DO_OD)\n+    {\n+      /* if we have just DO .. OD, do nothing - this is just a \n+         BEGIN .. END without creating a new scope, and no looping  */\n+      if (firstp->condition != NULL_TREE)\n+\tfirstp->itype = DO_WHILE;\n+      else\n+\tfirstp->itype = DO_OD;\n+    }\n+  \n+  /* Issue a warning if the any loop counter is mentioned more \n+     than once in the iterator list. */\n+  for (ip = firstp; ip != NULL; ip = ip->next)\n+    {\n+      switch (ip->itype)\n+\t{\n+\tcase DO_FOREVER:\n+\tcase DO_WHILE:\n+\t  break;\n+\tcase DO_STEP:\n+\tcase DO_RANGE:\n+\tcase DO_POWERSET:\n+\tcase DO_LOC:\n+\tcase DO_LOC_VARYING:\n+\t  /* FIXME: check for name uniqueness */\n+\t  break;\n+\tdefault:\n+\t  ;\n+\t}\n+    }\n+  return firstp->error_flag;\n+}\n+\f\n+/*\n+ * Reserve space for any loop-control temporaries, initialize them\n+ */\n+static int\n+declare_temps ()\n+{\n+  ITERATOR *firstp = loop_stack->iter_list, *ip;\n+  tree start_ptr;\n+\n+  for (ip = firstp; ip != NULL; ip = ip->next)\n+    {\n+      switch (ip->itype)\n+\t{\n+\tcase DO_FOREVER:\n+\tcase DO_WHILE:\n+\t  break;\n+\tcase DO_STEP:\n+\t  ip->iter_type = chill_unsigned_type (TREE_TYPE (ip->start_exp));\n+\n+\t  /* create, initialize temporaries if expressions aren't constant */\n+\t  ip->start_temp = maybe_make_for_temp (ip->start_exp, \"for_start\",\n+\t\t\t\t\t\tip->iter_type);\n+\t  ip->end_temp = maybe_make_for_temp (ip->end_exp, \"for_end\",\n+\t\t\t\t\t      ip->iter_type);\n+\t  /* this is just the step-expression */\n+\t  ip->step_temp    = maybe_make_for_temp (ip->step_exp, \"for_step\",\n+\t\t\t\t\t\t  ip->iter_type);\n+\t  goto do_step_range;\n+\t  \n+\tcase DO_RANGE:\n+\t  ip->iter_type = chill_unsigned_type_node;\n+\t  \n+\t  ip->start_temp =\n+\t    (ip->down_flag ? build_chill_upper : build_chill_lower)(TREE_TYPE (ip->start_exp));\n+\t  ip->end_temp =\n+\t    (ip->down_flag ? build_chill_lower : build_chill_upper)(TREE_TYPE (ip->start_exp));\n+\t  \n+\t  ip->step_temp = integer_one_node;\n+\t  \n+\tdo_step_range:\n+\t  if (flag_local_loop_counter)\n+\t    {\n+\t      /* (re-)declare the user's iteration variable in the \n+\t\t loop's scope. */\n+\t      tree id_node = ip->user_var;\n+\t      IDENTIFIER_LOCAL_VALUE (id_node) = ip->user_var = \n+\t\tdecl_temp1 (id_node, ip->iter_type, 0, NULL_TREE,\n+\t\t\t    0, 0);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* in this case, it's a previously-declared \n+\t\t VAR_DECL node, checked in build_loop_iterator. */\n+\t      if (TREE_CODE (ip->user_var) == IDENTIFIER_NODE)\n+\t\tip->user_var = lookup_name (ip->user_var);\n+\t      if (ip->user_var == NULL_TREE)\n+\t\t{\n+\t\t  error (\"loop identifier undeclared\");\n+\t\t  ip->error_flag = 1;\n+\t\t  return 1;\n+\t\t}\n+\t    }\n+\t  ip->iter_var = \n+\t    decl_temp1 (get_unique_identifier (\"iter_var\"),\n+\t\t\tip->iter_type, 0, NULL_TREE, 0, 0);\n+\t  break;\n+\n+\tcase DO_POWERSET:\n+\t  ip->iter_type = chill_unsigned_type (\n+\t\t\t    TYPE_DOMAIN (TREE_TYPE (ip->start_exp)));\n+\t  if (flag_local_loop_counter)\n+\t    {\n+\t      /* declare the user's iteration variable in the loop's scope. */\n+\t      /* in this case, it's just an IDENTIFIER_NODE */\n+\t      ip->user_var = \n+\t\tdecl_temp1 (ip->user_var, ip->iter_type, 0, NULL_TREE, 0, 0);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* in this case, it's a previously-declared VAR_DECL node */\n+\t      ip->user_var = lookup_name (ip->user_var);\n+\t    }\n+\t  /* the user's powerset-expression, evaluated and saved in a temp */\n+\t  ip->powerset_temp = maybe_make_for_temp (ip->start_exp, \"for_set\",\n+\t\t\t\t\t\t TREE_TYPE (ip->start_exp));\n+\t  mark_addressable (ip->powerset_temp);\n+\t  break;\n+\n+\tcase DO_LOC:\n+\tcase DO_LOC_VARYING:\n+\t  ip->iter_type = chill_unsigned_type_node;\n+\t  /* create the counter temp */\n+\t  ip->iter_var = \n+\t    build_temporary_variable (\"iter_var\", ip->iter_type);\n+\n+\t  if (!CH_LOCATION_P (ip->start_exp))\n+\t    ip->start_exp\n+\t      = decl_temp1 (get_unique_identifier (\"iter_loc\"),\n+\t\t\t    TREE_TYPE (ip->start_exp), 0,\n+\t\t\t    ip->start_exp, 0, 0);\n+\n+\t  if (ip->itype == DO_LOC)\n+\t    {\n+\t      tree array_type = TREE_TYPE (ip->start_exp);\n+\t      tree ptr_type;\n+\t      tree temp;\n+\t      \n+\t      if (TREE_CODE (TREE_TYPE (array_type)) == BOOLEAN_TYPE)\n+\t\t{\n+\t\t  error (\"Can't iterate through array of BOOL\");\n+\t\t  ip->error_flag = 1;\n+\t\t  return ip->error_flag;\n+\t\t}\n+\t      \n+\t      /* FIXME: check for array type in ip->start_exp */\n+\n+\t      /* create pointer temporary */\n+\t      ip->base_type = TREE_TYPE (array_type);\n+\t      ptr_type = build_pointer_type (ip->base_type);\n+\t      ip->loc_ptr_temp =\n+\t\tbuild_temporary_variable (\"loc_ptr_tmp\", ptr_type);\n+\t      \n+\t      /* declare the user's iteration variable in \n+\t\t the loop's scope, as an expression, to be\n+\t\t passed to build_component_ref later */\n+\t      save_expr_under_name (ip->user_var, \n+\t\tbuild1 (INDIRECT_REF, ip->base_type, \n+\t\t\tip->loc_ptr_temp));\n+\t      \n+\t      /* FIXME: see stor_layout */\n+\t      ip->step_temp = size_in_bytes (ip->base_type);\n+\t      \n+\t      temp = TYPE_DOMAIN (array_type);\n+\n+\t      /* pointer to first array entry to look at */\n+\t      start_ptr = build1 (ADDR_EXPR, ptr_type, ip->start_exp);\n+\t      mark_addressable (ip->start_exp);\n+\t      ip->start_temp = ip->down_flag ? \n+\t\tfold (build (PLUS_EXPR, ptr_type, \n+\t\t\t     start_ptr,\n+\t\t  fold (build (MULT_EXPR, integer_type_node, ip->step_temp,\n+\t\t    fold (build (MINUS_EXPR, integer_type_node,\n+\t\t\t\t TYPE_MAX_VALUE (temp),\n+\t\t\t\t TYPE_MIN_VALUE (temp)))))))\n+\t\t  : start_ptr;\n+\t    }\n+\t  else\n+\t    {\n+\t      tree array_length =\n+\t\tconvert (integer_type_node,\n+\t\t  build_component_ref (ip->start_exp, var_length_id));\n+\t      tree array_type = TREE_TYPE (TREE_CHAIN (\n+\t\t\tTYPE_FIELDS (TREE_TYPE (ip->start_exp))));\n+\t      tree array_data_ptr = \n+\t\tbuild_component_ref (ip->start_exp, var_data_id);\n+\t      tree ptr_type;\n+\t      \n+\t      if (TREE_CODE (TREE_TYPE (array_type)) == BOOLEAN_TYPE)\n+\t\t{\n+\t\t  error (\"Can't iterate through array of BOOL\");\n+\t\t  firstp->error_flag = 1;\n+\t\t  return firstp->error_flag;\n+\t\t}\n+\t      \n+\t      /* create pointer temporary */\n+\t      ip->base_type = TREE_TYPE (array_type);\n+\t      ptr_type = build_pointer_type (ip->base_type);\n+\t      ip->loc_ptr_temp = \n+\t\tbuild_temporary_variable (\"loc_ptr_temp\", ptr_type);\n+\t\t\t\t\t\t\t   \n+\t      \n+\t      /* declare the user's iteration variable in \n+\t\t the loop's scope, as an expression, to be\n+\t\t passed to build_component_ref later */\n+\t      save_expr_under_name (ip->user_var, \n+\t\tbuild1 (INDIRECT_REF, ip->base_type, \n+\t\t\tip->loc_ptr_temp));\n+\t      \n+\t      /* FIXME: see stor_layout */\n+\t      ip->step_temp = size_in_bytes (ip->base_type);\n+\t      \n+\t      /* pointer to first array entry to look at */\n+\t      start_ptr = build1 (ADDR_EXPR, ptr_type, array_data_ptr);\n+\t      mark_addressable (array_data_ptr);\n+\t      ip->start_temp = ip->down_flag ? \n+\t\tfold (build (PLUS_EXPR, ptr_type, \n+                  start_ptr,\n+\t\t    fold (build (MULT_EXPR, integer_type_node, ip->step_temp,\n+\t\t      fold (build (MINUS_EXPR, integer_type_node,\n+\t\t\t\t   array_length,\n+\t\t\t\t   integer_one_node))))))\n+\t\t  : start_ptr;\n+\t    }\n+\tdefault:\n+\t  ;\n+\t}\n+    }\n+  return firstp->error_flag;\n+}\n+\f\n+/*\n+ * Initialize the hidden iteration-control variables,\n+ * and the user's explicit loop variable.\n+ */\n+static int\n+initialize_iter_var ()\n+{\n+  ITERATOR *firstp = loop_stack->iter_list, *ip;\n+\n+  for (ip = firstp; ip != NULL; ip = ip->next)\n+    {\n+      switch (ip->itype)\n+\t{\n+\tcase DO_FOREVER:\n+\tcase DO_WHILE:\n+\t  break;\n+\tcase DO_STEP:\n+\tcase DO_RANGE:\n+\t  {\n+\t    tree count =\n+\t      fold (build (PLUS_EXPR, ip->iter_type, integer_one_node,\n+\t\t  fold (build (TRUNC_DIV_EXPR, ip->iter_type, \n+\t\t    convert (ip->iter_type,\n+\t              fold (build (MINUS_EXPR, ip->iter_type,\n+\t\t\tip->down_flag ? ip->start_temp : ip->end_temp,\n+\t\t\tip->down_flag ? ip->end_temp   : ip->start_temp))),\n+\t\t\t       ip->step_temp))));\n+\t    /* initialize the loop's hidden counter variable */\n+\t    expand_expr_stmt (\n+\t      build_chill_modify_expr (ip->iter_var, count));\n+\n+\t    /* initialize user's variable */\n+\t    expand_expr_stmt (\n+\t      build_chill_modify_expr (ip->user_var, ip->start_temp));\n+\t  }\n+\t  break;\n+\tcase DO_POWERSET:\n+\t  break;\n+\tcase DO_LOC:\n+\t  {\n+\t    tree array_type = TREE_TYPE (ip->start_exp);\n+\t    tree array_length =\n+\t      fold (build (TRUNC_DIV_EXPR, integer_type_node,\n+\t\t\t   size_in_bytes (array_type),\n+\t\t\t   size_in_bytes (TREE_TYPE (array_type))));\n+\n+\t    expand_expr_stmt (\n+\t      build_chill_modify_expr (ip->iter_var, array_length));\n+\t    goto do_loc_common;\n+\t  }\n+\n+\tcase DO_LOC_VARYING:\n+\t  expand_expr_stmt (\n+\t    build_chill_modify_expr (ip->iter_var,\n+\t      convert (integer_type_node,\n+\t\tbuild_component_ref (ip->start_exp, var_length_id))));\n+\n+\tdo_loc_common:\n+\t  expand_expr_stmt (\n+\t    build_chill_modify_expr (ip->loc_ptr_temp, \n+\t\t\t\t     ip->start_temp));\n+\t  break;\n+\n+\tdefault:\n+\t  ;\n+\t}\n+    }\n+  return firstp->error_flag;\n+}\n+\f\n+/* Generate code to skip the whole loop, if start expression not\n+ * <= end expression (or >= for DOWN loops).  This comparison must\n+ * *NOT* be done in unsigned mode, or it will fail.\n+ *  Also, skip processing an empty VARYING array. \n+ */\n+static int\n+maybe_skip_loop ()\n+{\n+  ITERATOR *firstp = loop_stack->iter_list, *ip;\n+\n+  for (ip = firstp; ip != NULL; ip = ip->next)\n+    {\n+      switch (ip->itype)\n+\t{\n+\tcase DO_STEP:\n+\t  expand_start_cond (\n+\t    build (ip->down_flag ? GE_EXPR : LE_EXPR, \n+\t\t   TREE_TYPE (ip->start_exp),\n+\t\t   ip->start_exp, ip->end_exp), 0);\n+\t  break;\n+    \n+\tcase DO_LOC_VARYING:\n+\t  { tree array_length =\n+\t      convert (integer_type_node,\n+\t        build_component_ref (ip->start_exp, var_length_id));\n+\t    expand_start_cond (\n+\t      build (NE_EXPR, TREE_TYPE (array_length),\n+\t\t     array_length, integer_zero_node), 0);\n+\t    break;\n+\t  }\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+  return 0;\n+}  \n+\f\n+/*\n+ * Check at the top of the loop for a termination\n+ */\n+static int\n+top_loop_end_check ()\n+{\n+  ITERATOR *firstp = loop_stack->iter_list, *ip;\n+\n+  /* now, exit the loop if the condition isn't TRUE. */\n+  if (firstp->condition)\n+    {\n+      expand_exit_loop_if_false (0,\n+\tchill_truthvalue_conversion (firstp->condition));\n+    }\n+\n+  for (ip = firstp; ip != NULL; ip = ip->next)\n+    {\n+      switch (ip->itype)\n+\t{\n+\tcase DO_FOREVER:\n+\tcase DO_WHILE:\n+\tcase DO_STEP:\n+\tcase DO_RANGE:\n+\t  break;\n+\tcase DO_POWERSET:\n+\t  {\n+\t    tree temp1;\n+\t    char *func_name;\n+\n+\t    if (ip->down_flag)\n+\t      func_name = \"__flsetclrpowerset\";\n+\t    else\n+\t      func_name = \"__ffsetclrpowerset\";\n+\t    \n+\t    temp1 = TYPE_MIN_VALUE\n+\t      (TYPE_DOMAIN (TREE_TYPE (ip->powerset_temp)));\n+\t    expand_exit_loop_if_false (0,\n+\t      build_chill_function_call (lookup_name (get_identifier (func_name)),\n+\t        tree_cons (NULL_TREE, force_addr_of (ip->powerset_temp),\n+                  tree_cons (NULL_TREE, powersetlen (ip->powerset_temp),\n+\t            tree_cons (NULL_TREE, force_addr_of (ip->user_var),\n+                      tree_cons (NULL_TREE, size_in_bytes (TREE_TYPE (ip->user_var)),\n+\t\t        tree_cons (NULL_TREE,\n+\t\t\t\t   convert (long_integer_type_node, temp1),\n+\t\t\t\t   NULL_TREE)))))));\n+\t  }\n+\t  break;\n+\tcase DO_LOC:\n+\tcase DO_LOC_VARYING:\n+\t  break;\n+\tdefault:\n+\t  ;\n+\t}\n+    }\n+  return firstp->error_flag;\n+}\n+\f\n+/*\n+ * Check generated temporaries for loop's end\n+ */\n+static int\n+bottom_loop_end_check ()\n+{\n+  ITERATOR *firstp = loop_stack->iter_list, *ip;\n+\n+  emit_line_note (input_filename, lineno);\n+\n+  /* now, generate code to check each loop counter for termination */\n+  for (ip = firstp; ip != NULL; ip = ip->next)\n+    {\n+      switch (ip->itype)\n+\t{\n+\tcase DO_FOREVER:\n+\tcase DO_WHILE:\n+\t  break;\n+\tcase DO_STEP:\n+\tcase DO_RANGE:\n+\tcase DO_LOC:\n+\tcase DO_LOC_VARYING:\n+\t  /* decrement iteration counter by one */\n+\t  chill_expand_assignment (ip->iter_var, MINUS_EXPR, integer_one_node);\n+\t  /* exit if it's zero */\n+\t  expand_exit_loop_if_false (0,\n+\t    build (NE_EXPR, boolean_type_node, \n+\t\t   ip->iter_var,\n+\t\t   integer_zero_node));\n+\t  break;\n+\tcase DO_POWERSET:\n+\t  break;\n+\tdefault:\n+\t  ;\n+\t}\n+    }\n+\n+  return firstp->error_flag;\n+}\n+\f\n+/*\n+ * increment the loop-control variables.\n+ */\n+static int\n+increment_temps ()\n+{\n+  ITERATOR *firstp = loop_stack->iter_list, *ip;\n+\n+  for (ip  = firstp; ip != NULL; ip = ip->next)\n+    {\n+      switch (ip->itype)\n+\t{\n+\tcase DO_FOREVER:\n+\tcase DO_WHILE:\n+\t  break;\n+\tcase DO_STEP:\n+\tcase DO_RANGE:\n+\t  {\n+\t    tree delta =\n+\t      fold (build (ip->down_flag ? MINUS_EXPR : PLUS_EXPR,\n+\t\t\t   TREE_TYPE (ip->user_var), ip->user_var,\n+\t\t\t   ip->step_temp));\n+ \t    expand_expr_stmt (\n+\t      build_chill_modify_expr (ip->user_var, delta));\n+\t  }\n+\t  break;\n+\tcase DO_LOC:\n+\tcase DO_LOC_VARYING:\n+\t  /* This statement uses the C semantics, so that \n+\t     the pointer is actually incremented by the \n+\t     length of the object pointed to. */\n+#if 1\n+\t  expand_expr_stmt (\n+\t    build_modify_expr (ip->loc_ptr_temp, \n+\t\t\t       ip->down_flag ? MINUS_EXPR : PLUS_EXPR,\n+\t\t\t       integer_one_node));\n+#else\n+\t  {\n+\t    enum tree_code op = ip->down_flag ? MINUS_EXPR : PLUS_EXPR;\n+\t    tree el_type = TREE_TYPE (TREE_TYPE (ip->loc_ptr_temp));\n+\t    chill_expand_assignment (ip->loc_ptr_temp, NOP_EXPR,\n+\t\t\t\t     build (op,\n+\t\t\t\t\t    TREE_TYPE (ip->loc_ptr_temp),\n+\t\t\t\t\t    ip->loc_ptr_temp,\n+\t\t\t\t\t    size_in_bytes (el_type)));\n+\t  }\n+#endif\n+\t  break;\n+\tcase DO_POWERSET:\n+\t  break;\n+\tdefault:\n+\t  ;\n+\t}\n+    }\n+  return firstp->error_flag;\n+}\n+\f\n+/*\n+ * Generate a (temporary) unique identifier_node of\n+ * the form \"__tmp_%s_%d\"\n+ */\n+tree\n+get_unique_identifier (lead)\n+     char *lead;\n+{\n+  char idbuf [256];\n+  static int idcount = 0;\n+\n+  sprintf (idbuf, \"__tmp_%s_%d\", lead ? lead : \"\", idcount++);\n+  return get_identifier (idbuf);\n+}\n+\f\n+/*\n+ * build a temporary variable, given its NAME and TYPE.\n+ * The name will have a number appended to assure uniqueness.\n+ * return its DECL node.\n+ */\n+static tree\n+build_temporary_variable (name, type)\n+     char *name;\n+     tree type;\n+{\n+  return decl_temp1 (get_unique_identifier (name), type, 0, NULL_TREE, 0, 0);\n+}\n+\n+\n+/*\n+ * If the given expression isn't a constant, build a temp for it\n+ * and evaluate the expression into the temp.  Return the tree\n+ * representing either the original constant expression or the\n+ * temp which now contains the expression's value. \n+ */\n+static tree\n+maybe_make_for_temp (exp, temp_name, exp_type)\n+     tree exp;\n+     char *temp_name;\n+     tree exp_type;\n+{\n+  tree result = exp;\n+\n+  if (exp != NULL_TREE)\n+    {\n+      /* if exp isn't constant, create a temporary for its value */\n+      if (TREE_CONSTANT (exp))\n+\t{\n+          /* FIXME: assure that TREE_TYPE (result) == ip->exp_type */\n+\t  result = convert (exp_type, exp);\n+\t}\n+      else {\n+\t/* build temp, assign the value */\n+\tresult = decl_temp1 (get_unique_identifier (temp_name), exp_type, 0,\n+\t\t\t     exp, 0, 0);\n+      }\n+    }\n+  return result;\n+}\n+\n+\n+/*\n+ * Adapt the C unsigned_type function to CHILL - we need to\n+ * account for any CHILL-specific integer types here.  So far,\n+ * the 16-bit integer type is the only one.\n+ */\n+static tree\n+chill_unsigned_type (type)\n+     tree type;\n+{\n+  extern tree chill_unsigned_type_node;\n+  tree type1 = TYPE_MAIN_VARIANT (type);\n+\n+  if (type1 == chill_integer_type_node)\n+    return chill_unsigned_type_node;\n+  else\n+    return unsigned_type (type);\n+}"}, {"sha": "6b6b159c498206e831fd29f0b63605f2d97977e3", "filename": "gcc/ch/parse.h", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fparse.h?ref=80a093b29e752ac54172945174c7cd59cec1fd05", "patch": "@@ -0,0 +1,76 @@\n+typedef union {\n+  long itype;\n+  tree ttype;\n+  enum tree_code code;\n+  char *filename;\n+  int lineno;\n+} YYSTYPE;\n+extern YYSTYPE yylval;\n+\n+enum terminal\n+{\n+  /*EOF = 0,*/\n+  last_char_nonterminal = 256,\n+  /* Please keep these in alphabetic order, for easier reference and updating.\n+   */\n+  ABSOLUTE, ACCESS, AFTER, ALL, ALLOCATE, AND, ANDIF, ARRAY, \n+  ARROW, ASGN, ASM_KEYWORD, ASSERT, ASSOCIATION, AT,\n+  BASED, BEGINTOKEN, BIN, BIT, BITSTRING, BODY, BOOLS, BUFFER,\n+  BUFFERNAME, BUFFER_CODE, BY,\n+  CALL, CASE, CAUSE, CDDEL, CHAR, CHARS, COLON, COMMA, CONCAT, CONST,\n+  CONTINUE, CYCLE,\n+  DCL, DELAY, DIV, DO, DOT, DOWN, DYNAMIC, \n+  ELSE, ELSIF, END, ENTRY, EQL, ESAC, EVENT, EVENT_CODE, EVER,\n+  EXCEPTIONS, EXIT,\n+  EXPR, /* an expression that has been pushed back */\n+  FI, FLOATING, FOR, FORBID,\n+  GENERAL, GOTO, GRANT, GT, GTE,\n+  HEADEREL,\n+  IF, IGNORED_DIRECTIVE, IN, INIT, INOUT, INLINE,\n+  LC, LOC, LPC, LPRN, LT, LTE,\n+  MOD, MODULE, MUL, \n+  NAME, NE, NEW, NEWMODE, NONREF, NOT, NUMBER,\n+  OD, OF, ON, OR, ORIF,\n+  PARAMATTR, PERVASIVE, PLUS, POWERSET,\n+  PREFIXED, PRIORITY, PROC, PROCESS,\n+  RANGE, RC, READ, READTEXT, RECEIVE, RECURSIVE, REF, REGION, REM,\n+  RESULT, RETURN, RETURNS, ROUND, ROW, RPC, RPRN, RPRN_COLON,\n+  SAME, SC, SEIZE, SEND, SET, SHARED, SIGNAL, SIGNALNAME, SIMPLE,\n+  SINGLECHAR, SPEC, START, STATIC, STEP, STOP, STREAM, STRING, \n+  STRUCT, SUB, SYN, SYNMODE,\n+  TERMINATE, TEXT, THEN, THIS, TIMEOUT, TO, TRUNC, TYPENAME, \n+  UP, USAGE,\n+  VARYING, \n+  WHERE, WHILE, WITH,\n+  XOR,\n+\n+/* These tokens only used within ch-lex.l to process compiler directives */\n+  ALL_STATIC_OFF, ALL_STATIC_ON, EMPTY_OFF, EMPTY_ON,\n+  GRANT_FILE_SIZE, PROCESS_TYPE_TOKEN, RANGE_OFF, RANGE_ON,\n+  SEND_BUFFER_DEFAULT_PRIORITY, SEND_SIGNAL_DEFAULT_PRIORITY,\n+  SIGNAL_CODE, SIGNAL_MAX_LENGTH, USE_SEIZE_FILE, USE_SEIZE_FILE_RESTRICTED,\n+  USE_GRANT_FILE, \n+\n+  /* These tokens are recognized, and reported as errors, by the lexer. */\n+  CONTEXT, REMOTE,\n+\n+  /* These tokens are recognized in the lexer, and completely\n+     ignored. They represent unimplemented features in the\n+     current version of GNU CHILL. */\n+  NOPACK, PACK,\n+\n+/* These tokens are recognized in the lexer, and returned\n+   as reserved tokens, to prevent users from using them\n+   accidently (they'll cause a parser syntax error).  They\n+   represent unimplemented features in the current version\n+   of GNU CHILL. */\n+  POS, /*STEP, ROW,*/\n+\n+/* This token is passed back to the parser when an the main \n+   input file (not a seize file) has  reached end-of-file. */\n+  END_PASS_1,\n+\n+  EMPTY, UMINUS,\n+\n+  dummy_last_terminal\n+};"}, {"sha": "e4105d6b4ee328820ec692ee088c941f895d9510", "filename": "gcc/ch/runtime/concatstr.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Fconcatstr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Fconcatstr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fconcatstr.c?ref=80a093b29e752ac54172945174c7cd59cec1fd05", "patch": "@@ -0,0 +1,69 @@\n+/* Implement string-related runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Bill Cox\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define MIN(a, b)  ((a) < (b) ? (a) : (b))\n+\n+extern void cause_exception (char *exname, char *file, int lineno);\n+\n+/*\n+ * function __concatstring \n+ *\n+ * parameters:\n+ *     OUT  - pointer to output string\n+ *     S1   - pointer to left string\n+ *     LEN1 - length of left string\n+ *     S2   - pointer to right string\n+ *     LEN2 - length of right string\n+ *\n+ * returns:\n+ *     pointer to OUT string\n+ *\n+ * exceptions:\n+ *     none\n+ *\n+ * abstract:\n+ *     concatenates two character strings into the output string\n+ *\n+ */\n+\n+char *\n+__concatstring (out, s1, len1, s2, len2)\n+     char *out, *s1;\n+     int   len1;\n+     char *s2;\n+     int   len2;\n+{\n+  if (out)\n+    {\n+      if (s2 /* Check for overlap between s2 and out. */\n+\t  && ((s2 >= out && s2 < (out + len1 + len2))\n+\t      || (s2 + len2 > out && s2 <= out + len1)))\n+\t{\n+\t  char *tmp = alloca (len2);\n+\t  memcpy (tmp, s2, len2);\n+\t  s2 = tmp;\n+\t}\n+      if (s1)\n+\tmemmove (out, s1, len1);\n+      if (s2)\n+\tmemcpy (&out[len1], s2, len2);\n+    }\n+  return out;\n+}"}, {"sha": "76d457dfd031fe35d64d23198fced78e11eb721d", "filename": "gcc/ch/runtime/continue.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Fcontinue.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Fcontinue.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fcontinue.c?ref=80a093b29e752ac54172945174c7cd59cec1fd05", "patch": "@@ -0,0 +1,83 @@\n+/* Implement tasking-related runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"rtltypes.h\"\n+#include \"rts.h\"\n+\n+/*\n+ * function __continue\n+ *\n+ * parameters:\n+ *     evaddr     pointer to Eventlocation\n+ *     filename   source file name where function gets called\n+ *     lineno     linenumber in source file\n+ *\n+ * returns:\n+ *     void\n+ *\n+ * exceptions:\n+ *     none\n+ *\n+ * abstract:\n+ *     implement the CHILL CONTINUE action.\n+ */\n+\n+void\n+__continue (evaddr, filename, lineno)\n+     Event_Queue   **evaddr;\n+     char           *filename;\n+     int             lineno;\n+{\n+  Event_Queue  *ev = *evaddr;\n+  Event_Queue  *wrk;\n+\n+  if (ev == 0)\n+    /* nothing to do */\n+    return;\n+\n+  /* search for 1st one is not already continued */\n+  while (ev && ev->is_continued)\n+    ev = ev->forward;\n+  if (!ev)\n+    /* all have been continued in that queue, do nothing */\n+    return;\n+\n+  wrk = ev->startlist;\n+  while (wrk)\n+    {\n+      Event_Queue     *tmp = (Event_Queue *)wrk->listhead;\n+      \n+      while (tmp->forward != wrk)\n+\ttmp = tmp->forward;\n+      tmp->forward = wrk->forward;\n+      wrk = wrk->chain;\n+    }\n+\n+  /* so far so good, continue this one */\n+  ev->is_continued = 1;\n+  ev->who_continued = THIS;\n+\n+  /* tell the runtime system to activate the process */\n+  __continue_that (ev->this, ev->priority, filename, lineno);\n+}\n+\n+/* force function print_event to be linked */\n+extern void __print_event ();\n+static EntryPoint pev = __print_event;"}, {"sha": "f56fc3a94eb5ab6fdb15c4759a0944b8ce861296", "filename": "gcc/ch/runtime/convdurrtstime.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Fconvdurrtstime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Fconvdurrtstime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fconvdurrtstime.c?ref=80a093b29e752ac54172945174c7cd59cec1fd05", "patch": "@@ -0,0 +1,52 @@\n+/* Implement timing-related runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"rts.h\"\n+\n+/*\n+ * function __convert_duration_rtstime\n+ *\n+ * parameters:\n+ *      dur     the duration value\n+ *      t       pointer to the duration value converted to RtsTime\n+ *\n+ * returns:\n+ *      void\n+ *\n+ * exceptions:\n+ *      none\n+ *\n+ * abstract:\n+ *      converts a duration value (unsigned long in millisecs) to RtsTime\n+ *      format.\n+ *\n+ */\n+\n+void\n+__convert_duration_rtstime (dur, t)\n+     unsigned long  dur;\n+     RtsTime       *t;\n+{\n+  unsigned long tmp;\n+    \n+  t->secs = dur / 1000;\n+  tmp = dur - (t->secs * 1000);\n+  t->nanosecs = tmp * 1000000;\n+}"}, {"sha": "bb5b9650f57f4793e8bf46487b93b0737508f1aa", "filename": "gcc/ch/runtime/ffsetclrps.c", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Fffsetclrps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Fffsetclrps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fffsetclrps.c?ref=80a093b29e752ac54172945174c7cd59cec1fd05", "patch": "@@ -0,0 +1,102 @@\n+/* Implement POWERSET runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define __CHILL_LIB__\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+#include \"powerset.h\"\n+\n+/*\n+ * function __ffsetclrpowerset\n+ *\n+ * parameters:\n+ *\tps\t\tpowerset\n+ *\tbitlength\tlength of powerset\n+ *\n+ * returns:\n+ *\tint\t\t-1 .. nothing found\n+ *\t\t\t>=0 .. index of first true bit found\n+ * exceptions:\n+ *  none\n+ */\n+\n+int\n+__ffsetclrpowerset (ps, bitlength, first_bit)\n+     SET_WORD      *ps;\n+     unsigned long  bitlength;\n+     int first_bit;\n+{\n+  register int bitno;\n+\n+  if (first_bit >= bitlength)\n+    return -1;\n+\n+#ifndef USE_CHARS\n+  if (bitlength <= SET_CHAR_SIZE)\n+    {\n+      for (bitno = first_bit; bitno < bitlength; bitno++)\n+\tif (GET_BIT_IN_CHAR (*((SET_CHAR *)ps), bitno))\n+\t  break;\n+      return bitno == bitlength ? -1 : bitno;\n+    }\n+  else if (bitlength <= SET_SHORT_SIZE)\n+    {\n+      for (bitno = first_bit; bitno < bitlength; bitno++)\n+\tif (GET_BIT_IN_SHORT (*((SET_SHORT *)ps), bitno))\n+\t  break;\n+      return bitno == bitlength ? -1 : bitno;\n+    }\n+  else\n+#endif\n+    {\n+      unsigned int words_to_skip = (unsigned) first_bit / SET_WORD_SIZE;\n+      unsigned long cnt = words_to_skip * SET_WORD_SIZE;\n+      SET_WORD\t*p = ps + words_to_skip;\n+      SET_WORD\t*endp = ps + BITS_TO_WORDS(bitlength);\n+      SET_WORD\tc;\n+      first_bit = (unsigned) first_bit % (unsigned) SET_WORD_SIZE;\n+\n+      c = *p++;\n+      if (c)\n+\t{\n+\t  for (bitno = first_bit; bitno < SET_WORD_SIZE; bitno++)\n+\t    if (GET_BIT_IN_WORD(c, bitno))\n+\t      goto found;\n+\t}\n+      cnt += SET_WORD_SIZE;\n+\n+      while (p < endp)\n+\t{\n+\t  if ((c = *p++))\n+\t    {\n+\t      /* found a bit set .. calculate which */\n+\t      for (bitno = 0; bitno < SET_WORD_SIZE; bitno++)\n+\t\tif (GET_BIT_IN_WORD(c, bitno))\n+\t\t  goto found;\n+\t    }\n+\t  cnt += SET_WORD_SIZE;\n+\t}\n+      return -1;\n+    found:\n+      bitno += cnt;\n+      return bitno >= bitlength ? -1 : bitno;\n+    }\n+}"}, {"sha": "e768a47c537848bed097eed14d6b9a6ea9f035ae", "filename": "gcc/ch/runtime/flsetclrps.c", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Fflsetclrps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Fflsetclrps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fflsetclrps.c?ref=80a093b29e752ac54172945174c7cd59cec1fd05", "patch": "@@ -0,0 +1,99 @@\n+/* Implement POWERSET runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define __CHILL_LIB__\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+#include \"powerset.h\"\n+\n+/*\n+ * function __flsetclrpowerset\n+ *\n+ * parameters:\n+ *\tps\t\tpowerset\n+ *\tbitlength\tlength of powerset\n+ *\n+ * returns:\n+ *\tint\t\t-1 .. nothing found\n+ *\t\t\t>= 0 .. index of last set bit\n+ * exceptions:\n+ *  none\n+ *\n+ * abstract:\n+ *  Find last bit set in a powerset and return the corresponding value\n+ *  in *out and clear this bit. Return 0 for no more found, else 1.\n+ *\n+ */\n+int\n+__flsetclrpowerset (ps, bitlength, first_bit)\n+     SET_WORD      *ps;\n+     unsigned long  bitlength;\n+     int first_bit;\n+{\n+  register int bitno;\n+\n+#ifndef USE_CHARS\n+  if (bitlength <= SET_CHAR_SIZE)\n+    {\n+      for (bitno = bitlength - 1; bitno >= first_bit; bitno--)\n+\tif (GET_BIT_IN_CHAR (*((SET_CHAR *)ps), bitno))\n+\t  break;\n+      return bitno < first_bit ? -1 : bitno;\n+    }\n+  else if (bitlength <= SET_SHORT_SIZE)\n+    {\n+      for (bitno = bitlength - 1; bitno >= first_bit; bitno--)\n+\tif (GET_BIT_IN_SHORT (*((SET_SHORT *)ps), bitno))\n+\t  break;\n+      return bitno < first_bit ? -1 : bitno;\n+    }\n+  else\n+#endif\n+    {\n+      SET_WORD *p, c;\n+      bitno = bitlength - 1;\n+      if (bitno < first_bit)\n+\treturn -1;\n+      p = &ps[(unsigned) bitno / SET_WORD_SIZE];\n+      c = *p;\n+      if (((unsigned) bitlength % SET_WORD_SIZE) != 0)\n+\tMASK_UNUSED_WORD_BITS(&c, (unsigned) bitlength % SET_WORD_SIZE);\n+      if (c)\n+\tgoto found;\n+      else\n+\tbitno -= ((unsigned) bitno % SET_WORD_SIZE) + 1;\n+      while (bitno >= first_bit)\n+\t{\n+\t  c = *--p;\n+\t  if (c)\n+\t    goto found;\n+\t  bitno -= SET_WORD_SIZE;\n+\t}\n+      return -1;\n+    found:\n+      for (; bitno >= first_bit; bitno--)\n+\t{\n+\t  if (GET_BIT_IN_WORD (c, (unsigned) bitno % SET_WORD_SIZE))\n+\t    return bitno;\n+\t}\n+      return -1;\n+    }\n+}"}, {"sha": "7c5231aa31060a36771027771758a1c0ace87c1d", "filename": "gcc/ch/runtime/leps.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Fleps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Fleps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fleps.c?ref=80a093b29e752ac54172945174c7cd59cec1fd05", "patch": "@@ -0,0 +1,76 @@\n+/* Implement POWERSET runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define __CHILL_LIB__\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+#include \"powerset.h\"\n+\n+/*\n+ * function __lepowerset\n+ *\n+ * parameters:\n+ *\tleft\t\tpowerset\n+ *\tright\t\tpowerset\n+ *\tbitlength\tlength of powerset\n+ *\n+ * returns:\n+ *\tint\t\t1 .. left is included in right\n+ *\t\t\t0 .. not\n+ *\n+ * abstract:\n+ *  check if one powerset is included in another\n+ *\n+ */\n+int\n+__lepowerset (left, right, bitlength)\n+     SET_WORD      *left;\n+     SET_WORD      *right;\n+     unsigned long  bitlength;\n+{\n+  if (bitlength <= SET_CHAR_SIZE)\n+    {\n+      if ((*((SET_CHAR *)left) & *((SET_CHAR *)right))\n+\t  != *((SET_CHAR *)left))\n+\treturn 0;\n+      return 1;\n+    }\n+  else if (bitlength <= SET_SHORT_SIZE)\n+    {\n+      if ((*((SET_SHORT *)left) & *((SET_SHORT *)right))\n+\t  != *((SET_SHORT *)left))\n+\treturn 0;\n+      return 1;\n+    }\n+  else\n+    {\n+      SET_WORD *endp = left + BITS_TO_WORDS(bitlength);\n+    \n+      while (left < endp)\n+\t{\n+\t  if ((*right & *left) != *left)\n+\t    return 0;\n+\t  left++;\n+\t  right++;\n+\t}\n+      return 1;\n+    }\n+}"}, {"sha": "3ceb77675f26ab3b6617c643c60760ac1fe0e858", "filename": "gcc/ch/runtime/powerset.h", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Fpowerset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Fpowerset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fpowerset.h?ref=80a093b29e752ac54172945174c7cd59cec1fd05", "patch": "@@ -0,0 +1,106 @@\n+/* Common macros for POWERSET runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#ifndef _POWERSET_H\n+#define _POWERSET_H\n+\n+#define USE_CHARS\n+\n+#ifdef USE_CHARS\n+\n+#define SET_WORD unsigned char\n+#define SET_CHAR  unsigned char\n+#define SET_SHORT unsigned char\n+\n+#else\n+\n+#ifndef SET_WORD\n+#define SET_WORD unsigned int\n+#endif\n+#define SET_CHAR  unsigned char\n+#define SET_SHORT unsigned short\n+#endif\n+\n+#define SET_WORD_SIZE (BITS_PER_UNIT * sizeof (SET_WORD))\n+#define SET_SHORT_SIZE (BITS_PER_UNIT * sizeof (SET_SHORT))\n+#define SET_CHAR_SIZE BITS_PER_UNIT\n+\n+/* Powersets and bit strings are stored as arrays of SET_WORD.\n+   if they are a word or longer.  Powersets and bit strings whic\n+   fit in a byte or short are stored that way by the compiler.\n+\n+   The order of the bits follows native bit order:\n+   If BITS_BIG_ENDIAN, bit 0 is the most significant bit (i.e. 0x80..00);\n+   otherwise, bit 0 is the least significant bit (i.e. 0x1).\n+\n+   MASK_UNUSED_BITS masks out unused bits in powersets and bitstrings.\n+   GET_BIT_IN_WORD(W,B) yields 1 (or 0) if the B'th bit if W is set (cleared).\n+*/\n+\n+#if BITS_BIG_ENDIAN\n+#define GET_BIT_IN_WORD(w,b) (((w) >> (SET_WORD_SIZE - 1 - (b))) & 1)\n+#define GET_BIT_IN_SHORT(w,b) (((w) >> (SET_SHORT_SIZE - 1 - (b))) & 1)\n+#define GET_BIT_IN_CHAR(w,b) (((w) >> (SET_CHAR_SIZE - 1 - (b))) & 1)\n+\n+#define SET_BIT_IN_WORD(w,b) ((w) |= 1 << ((SET_WORD_SIZE) - 1 - (b)))\n+#define SET_BIT_IN_SHORT(w,b) ((w) |= 1 << ((SET_SHORT_SIZE) - 1 - (b)))\n+#define SET_BIT_IN_CHAR(w,b) ((w) |= 1 << ((SET_CHAR_SIZE) - 1 - (b)))\n+\n+#define CLEAR_BIT_IN_WORD(w,b) ((w) &= ~(1 << ((SET_WORD_SIZE) - 1 - (b))))\n+#define CLEAR_BIT_IN_SHORT(w,b) ((w) &= ~(1 << ((SET_SHORT_SIZE) - 1 - (b))))\n+#define CLEAR_BIT_IN_CHAR(w,b) ((w) &= ~(1 << ((SET_CHAR_SIZE) - 1 - (b))))\n+#define MASK_UNUSED_WORD_BITS(p,b)\t\t   \\\n+{ if (b) *(p) &= (~0) << (SET_WORD_SIZE - (b)); }\n+#define MASK_UNUSED_SHORT_BITS(p,b)\t\t   \\\n+{ if (b) *(p) &= (~0) << (SET_SHORT_SIZE - (b)); }\n+#define MASK_UNUSED_CHAR_BITS(p,b)                 \\\n+{ if (b) *(p) &= (~0) << (SET_CHAR_SIZE - (b)); }\n+\n+#else /* !BITS_BIG_ENDIAN */\n+\n+#define GET_BIT_IN_WORD(w,b) (((w) >> (b)) & 1)\n+#define GET_BIT_IN_SHORT(w,b) GET_BIT_IN_WORD(w,b)\n+#define GET_BIT_IN_CHAR(w,b) GET_BIT_IN_WORD(w,b)\n+\n+#define SET_BIT_IN_WORD(w,b) ((w) |= 1 << (b))\n+#define SET_BIT_IN_SHORT(w,b) SET_BIT_IN_WORD(w,b)\n+#define SET_BIT_IN_CHAR(w,b) SET_BIT_IN_WORD(w,b)\n+\n+#define CLEAR_BIT_IN_WORD(w,b) ((w) &= ~(1 << (b)))\n+#define CLEAR_BIT_IN_SHORT(w,b) CLEAR_BIT_IN_WORD(w,b)\n+#define CLEAR_BIT_IN_CHAR(w,b) CLEAR_BIT_IN_WORD(w,b)\n+\n+#define MASK_UNUSED_WORD_BITS(p,b)  \\\n+{ if (b) *(p) &= ~((~0) << (b)); }\n+#define MASK_UNUSED_SHORT_BITS(p,b) MASK_UNUSED_WORD_BITS(p,b)\n+#define MASK_UNUSED_CHAR_BITS(p,b) MASK_UNUSED_WORD_BITS(p,b)\n+\n+#endif\n+\n+\n+/* Number of words needed for a bitstring/powerset of size BITLENGTH.\n+   This definition handles the (BITLENGTH==0) by yielding 0. */\n+\n+#define BITS_TO_WORDS(BITLENGTH) \\\n+  (((BITLENGTH) + (SET_WORD_SIZE-1)) / SET_WORD_SIZE)\n+#define BITS_TO_CHARS(BITLENGTH) \\\n+  (((BITLENGTH) + (SET_CHAR_SIZE-1)) / SET_CHAR_SIZE)\n+\n+#endif"}, {"sha": "417d17553678bb065e4980a2cc555943bb717cae", "filename": "gcc/ch/runtime/queuelength.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Fqueuelength.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Fqueuelength.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fqueuelength.c?ref=80a093b29e752ac54172945174c7cd59cec1fd05", "patch": "@@ -0,0 +1,79 @@\n+/* Implement tasking-related runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"rtltypes.h\"\n+#include \"rts.h\"\n+\n+/*\n+ * function __queue_length\n+ *\n+ * parameters:\n+ *     buf_ev      Buffer or event location\n+ *     is_event    0 .. buf_ev is a buffer location\n+ *                 1 .. buf_ev is an event location\n+ *\n+ * returns:\n+ *     int         number of delayed processeson an event location\n+ *                 or number of send delayed processes on a buffer\n+ *\n+ * exceptions:\n+ *     none\n+ *\n+ * abstract:\n+ *     implements the QUEUE_LENGTH built-in.\n+ *\n+ */\n+\n+int\n+__queue_length (buf_ev, is_event)\n+     void  *buf_ev;\n+     int    is_event;\n+{\n+  int            retval = 0;\n+  \n+  /* if buf_ev == 0 then we don't have anything */\n+  if (buf_ev == 0)\n+    return 0;\n+\n+  if (is_event)\n+    {\n+      /* process an event queue */\n+      Event_Queue   *ev = buf_ev;\n+\n+      while (ev)\n+\t{\n+\t  retval++;\n+\t  ev = ev->forward;\n+\t}\n+    }\n+  else\n+    {\n+      /* process a buffer queue */\n+      Buffer_Queue *bq = buf_ev;\n+      Buffer_Send_Queue *bsq = bq->sendqueue;\n+\n+      while (bsq)\n+\t{\n+\t  retval++;\n+\t  bsq = bsq->forward;\n+\t}\n+    }\n+  return retval;\n+}"}, {"sha": "03641f9178ebcf689dc3d14a696287783a294a07", "filename": "gcc/ch/runtime/readrecord.c", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Freadrecord.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Freadrecord.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Freadrecord.c?ref=80a093b29e752ac54172945174c7cd59cec1fd05", "patch": "@@ -0,0 +1,208 @@\n+/* Implement Input/Output runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <setjmp.h>\n+#include <stdlib.h>\n+#include <errno.h>\n+#include <unistd.h>\n+\n+#include \"fileio.h\"\n+\n+#ifdef EOF\n+#undef EOF\n+#endif\n+#define EOF -1\n+\n+static\n+Boolean\n+doRead( Access_Mode* the_access, void* buf, size_t nbyte )\n+{\n+  size_t nread;\n+\n+  nread = read( the_access->association->handle, buf, nbyte );\n+  if( nread == nbyte )\n+  {\n+    CLR_FLAG( the_access, IO_OUTOFFILE );\n+    return True;\n+  }\n+  if( nread == 0 )\n+  {\n+    SET_FLAG( the_access, IO_OUTOFFILE );\n+    return False;\n+  }\n+  the_access->association->syserrno = errno;\n+  RWEXCEPTION( READFAIL, OS_IO_ERROR );\n+  /* no return */\n+}\n+\n+static\n+int bgetc( int handle, readbuf_t* rbptr )\n+{\n+  if( rbptr->cur >= rbptr->len )\n+    {\n+      rbptr->len = read( handle, rbptr->buf, READBUFLEN );\n+      if( rbptr->len == 0 )\n+\treturn EOF;\n+      rbptr->cur = 0;\n+    }\n+  return rbptr->buf[rbptr->cur++];\n+}\n+\n+static\n+void bungetc( readbuf_t* rbptr, int c )\n+{\n+  rbptr->buf[--rbptr->cur] = c;\n+}\n+\n+void*\n+__readrecord( Access_Mode*  the_access,\n+              signed long   the_index,\n+              char*         the_buf_addr,\n+              char*         file,\n+              int           line )\n+{\n+  unsigned long  info;\n+  char*          actaddr;\n+  unsigned short actlen;\n+  off_t          filepos;\n+  unsigned short reclen;\n+  unsigned long  readlen;\n+\n+  if( !the_access )\n+    CHILLEXCEPTION( file, line, EMPTY, NULL_ACCESS );\n+\n+  if( !the_access->association )\n+    CHILLEXCEPTION( file, line, NOTCONNECTED, IS_NOT_CONNECTED );\n+\n+  /* Usage must not be WriteOnly */\n+  if( the_access->association->usage == WriteOnly )\n+    CHILLEXCEPTION( file, line, READFAIL, BAD_USAGE );\n+\n+  /* OUTOFFILE must not be True when connected for sequential read */\n+  if( !TEST_FLAG( the_access, IO_INDEXED )\n+      && TEST_FLAG( the_access, IO_OUTOFFILE ) )\n+    CHILLEXCEPTION( file, line, READFAIL, OUT_OF_FILE );\n+\n+  /*\n+   *  Positioning\n+   */\n+  if( TEST_FLAG( the_access, IO_INDEXED ) )\n+  {\n+    /* index expression must be within bounds of index mode */\n+    if( the_index < the_access->lowindex\n+        || the_access->highindex < the_index ) \n+      CHILLEXCEPTION( file, line, RANGEFAIL, BAD_INDEX );\n+\n+    filepos = the_access->base + \n+              (the_index - the_access->lowindex) * the_access->reclength;\n+\n+    if( lseek( the_access->association->handle, filepos, SEEK_SET ) == -1L )\n+      CHILLEXCEPTION( file, line, READFAIL, LSEEK_FAILS );\n+  }\n+\n+  /* establish store loc */\n+  if( !(actaddr = the_buf_addr ))\n+  {\n+    /* if not yet allocated, do it now */\n+    if (!the_access->store_loc)\n+      if( !(the_access->store_loc = (char*)malloc( the_access->reclength ) ) )\n+\tCHILLEXCEPTION( file, line, SPACEFAIL, STORE_LOC_ALLOC );\n+    actaddr = the_access->store_loc;\n+  }\n+  actlen  = the_access->reclength;\n+\n+  if( (info = setjmp( __rw_exception )) )\n+    CHILLEXCEPTION( file, line, info>>16, info & 0xffff );\n+\n+  if( TEST_FLAG( the_access, IO_TEXTIO ) )\n+  {\n+    readlen = actlen - 2;\n+    if( TEST_FLAG( the_access, IO_INDEXED ) )\n+    {\n+      if( ! doRead( the_access, &reclen, sizeof(reclen) ) )\n+        return NULL;\n+      if( reclen > readlen )\n+        CHILLEXCEPTION( file, line, RANGEFAIL, RECORD_TOO_LONG );\n+      if( ! doRead( the_access, actaddr + 2, reclen ) )\n+        CHILLEXCEPTION( file, line, READFAIL, RECORD_TOO_SHORT );\n+    }\n+    else\n+    { \n+      Association_Mode *assoc = the_access->association;\n+      int              handle = assoc->handle;\n+      readbuf_t*       rbuf   = assoc->bufptr;\n+      char* cptr = actaddr+2;\n+      int   curr;\n+\n+      reclen = 0;\n+      while( readlen-- )\n+      {\n+        curr = bgetc( handle, rbuf );\n+        if( curr == '\\n' )\n+          goto end_of_line;\n+        if( curr == EOF )\n+\t{\n+          if( !reclen )\n+            SET_FLAG( the_access, IO_OUTOFFILE );\n+          goto end_of_line;\n+\t}\n+        *cptr++ = curr;\n+        reclen++;\n+      }\n+      if( (curr = bgetc( handle, rbuf )) != '\\n' )\n+\t{\n+\t  bungetc( rbuf, curr );\n+\t  CHILLEXCEPTION( file, line, RANGEFAIL, RECORD_TOO_LONG );\n+\t}\n+end_of_line: ;\n+    }\n+    MOV2(actaddr,&reclen);\n+  }\n+  else\n+  {\n+    switch( the_access->rectype )\n+    {\n+    case Fixed:\n+      if( ! doRead( the_access, actaddr, actlen ) )\n+        return NULL;\n+      break;\n+    case VaryingChars:\n+      if( TEST_FLAG( the_access->association, IO_VARIABLE ) )\n+      {\n+        if( ! doRead( the_access, &reclen, sizeof(reclen) ) )\n+          return NULL;\n+        if( reclen > actlen - 2 )\n+          CHILLEXCEPTION( file, line, RANGEFAIL, RECORD_TOO_LONG );\n+        readlen = TEST_FLAG( the_access, IO_INDEXED ) ? actlen - 2 : reclen;\n+        if( ! doRead( the_access, actaddr + 2, readlen ) )\n+          CHILLEXCEPTION( file, line, READFAIL, RECORD_TOO_SHORT );\n+      }\n+      else\n+      {\n+        if( ! doRead( the_access, actaddr + 2, reclen = actlen - 2 ) )\n+          CHILLEXCEPTION( file, line, READFAIL, RECORD_TOO_SHORT );\n+      }\n+      MOV2(actaddr,&reclen);\n+      break;\n+    }\n+  }\n+\n+  return actaddr;\n+}"}, {"sha": "cff2289ebf0014cfcdc7744e2c6d6ce4a46d70e8", "filename": "gcc/ch/runtime/rtsdummy.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Frtsdummy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Frtsdummy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Frtsdummy.c?ref=80a093b29e752ac54172945174c7cd59cec1fd05", "patch": "@@ -0,0 +1,65 @@\n+/* Implement runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define __CHILL_LIB__\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <setjmp.h>\n+/*#include \"gvarargs.h\"\tGcc source and runtime libs use gvarargs.h */\n+\n+#include \"rtltypes.h\"\n+\n+typedef void (*init_ptr) ();\n+typedef int * tasking_ptr;\n+\n+/* Dummy functions for rts access. When we come here we have an error. */\n+\n+typedef char *(*fetch_names) (int number);\n+typedef int (*fetch_numbers) (char *name);\n+\n+static void __rts_main_loop ()\n+{\n+  /* do nothing in case of no run time system */\n+}\n+init_ptr\t__RTS_MAIN_LOOP__ = __rts_main_loop;\n+\n+static void __rts_init ()\n+{\n+  /* do nothing in case of no run time system */\n+}\n+init_ptr\t__RTS_INIT__ = __rts_init;\n+\n+static char *__fetch_name (int number)\n+{\n+    fprintf (stderr, \"ChillLib: fetch_name: no runtime system library linked.\\n\");\n+    fflush (stderr);\n+    abort ();\n+}\n+fetch_names\t__RTS_FETCH_NAMES__ = __fetch_name;\n+\n+static int __fetch_number (char *name)\n+{\n+    fprintf (stderr, \"ChillLib: fetch_number: no runtime system library linked.\\n\");\n+    fflush (stderr);\n+    abort ();\n+}\n+fetch_numbers\t__RTS_FETCH_NUMBERS__ = __fetch_number;"}, {"sha": "94166ff9cb81346d1df5a27ca96860efc75a8048", "filename": "gcc/ch/runtime/sequencible.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Fsequencible.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Fsequencible.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fsequencible.c?ref=80a093b29e752ac54172945174c7cd59cec1fd05", "patch": "@@ -0,0 +1,32 @@\n+/* Implement Input/Output runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"fileio.h\"\n+\n+Boolean\n+__sequencible( Association_Mode* the_assoc, char* file, int line )\n+{\n+  if( !the_assoc )\n+    CHILLEXCEPTION( file, line, EMPTY, NULL_ASSOCIATION );\n+  if( !TEST_FLAG(the_assoc, IO_ISASSOCIATED) )\n+    CHILLEXCEPTION( file, line, NOTASSOCIATED, IS_NOT_ASSOCIATED );\n+  return TEST_FLAG(the_assoc, IO_SEQUENCIBLE) ? True : False;\n+}\n+"}, {"sha": "f46554855a40de77d426612d9088203c291d9469", "filename": "gcc/ch/runtime/setbitps.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Fsetbitps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Fsetbitps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fsetbitps.c?ref=80a093b29e752ac54172945174c7cd59cec1fd05", "patch": "@@ -0,0 +1,89 @@\n+/* Implement POWERSET runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define __CHILL_LIB__\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+#include \"powerset.h\"\n+\n+extern void __cause_ex1 (char *exname, char *file, int lineno);\n+\n+/*\n+ * function __setbitpowerset\n+ *\n+ * parameters:\n+ *\tset\t\tdestination set\n+ *\tbitlength\tlength of powerset in bits\n+ *      minval          lowest valid set value\n+ *      bitno           bit number within set\n+ *      new_value       zero or one - (new bit value)\n+ *\n+ * returns:\n+ *\tint\t\t1 .. found\n+ *\t\t\t0 .. not found\n+ *\n+ * exceptions:\n+ *  rangefail\n+ *\n+ * abstract:\n+ *  checks if a given value is included in a powerset\n+ *\n+ */\n+void\n+__setbitpowerset (powerset, bitlength, minval, bitno, new_value, filename, lineno)\n+     SET_WORD      *powerset;\n+     unsigned long  bitlength;\n+     long           minval;\n+     long\t    bitno;\n+     char\t    new_value; /* booleans are represented as 8 bit value */\n+     char *\t    filename;\n+     int\t    lineno;\n+{\n+  if (powerset == NULL\n+      || bitno < minval \n+      || (bitno - minval) >= bitlength)\n+    __cause_ex1 (\"rangefail\", filename, lineno);\n+\n+  bitno -= minval;\n+  if (bitlength <= SET_CHAR_SIZE)\n+    {\n+      if (new_value & 1)\n+\tSET_BIT_IN_CHAR (*((SET_CHAR *)powerset), bitno);\n+      else\n+\tCLEAR_BIT_IN_CHAR (*((SET_CHAR *)powerset), bitno);\n+    }\n+  else if (bitlength <= SET_SHORT_SIZE)\n+    {\n+      if (new_value & 1)\n+\tSET_BIT_IN_SHORT (*((SET_SHORT *)powerset), bitno);\n+      else\n+\tCLEAR_BIT_IN_SHORT (*((SET_SHORT *)powerset), bitno);\n+    }\n+  else\n+    {\n+      powerset += (bitno/SET_WORD_SIZE);\n+      bitno %= SET_WORD_SIZE;\n+      if (new_value & 1)\n+\tSET_BIT_IN_WORD (*powerset, bitno);\n+      else\n+\tCLEAR_BIT_IN_WORD (*powerset, bitno);\n+    }\n+}"}, {"sha": "1e3045c8877d44ab924d7e9e3c43cf4abb50ca71", "filename": "gcc/ch/runtime/setbits.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Fsetbits.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Fsetbits.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fsetbits.c?ref=80a093b29e752ac54172945174c7cd59cec1fd05", "patch": "@@ -0,0 +1,85 @@\n+/* Implement POWERSET runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define __CHILL_LIB__\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+#include \"powerset.h\"\n+\n+extern void __cause_ex1 (char *exname, char *file, int lineno);\n+\n+/*\n+ * function __setbits\n+ *\n+ * parameters:\n+ *\tout\t\tresult\n+ *      bitlength       length of bitstring in bits\n+ *\tstartbit\tstarting bitnumber\n+ *\tendbit\t\tending bitnumber\n+ *\n+ * returns:\n+ *\tvoid\n+ *\n+ * exceptions:\n+ *   rangefail\n+ *\n+ * abstract:\n+ *  set all bits from starting bitnumber to ending bitnumber\n+ *  in a powerset\n+ *\n+ */\n+void\n+__setbits (out, bitlength, startbit, endbit)\n+     SET_WORD      *out;\n+     unsigned long  bitlength;\n+     long  startbit;\n+     long  endbit;\n+{\n+  unsigned long i;\n+  \n+  if (out == NULL\n+      || startbit < 0\n+      || startbit >= bitlength \n+      || endbit < 0\n+      || endbit >= bitlength \n+      || endbit < startbit)\n+    __cause_ex1 (\"rangefail\", \"__setbits\", __LINE__);\n+  \n+  if (bitlength <= SET_CHAR_SIZE)\n+    for (i = startbit; i <= endbit; i++)\n+      SET_BIT_IN_CHAR (*((SET_CHAR *)out), i);\n+  else if (bitlength <= SET_SHORT_SIZE)\n+    for (i = startbit; i <= endbit; i++)\n+      SET_BIT_IN_SHORT (*((SET_SHORT *)out), i);\n+  else\n+    {\n+      SET_WORD\t*p;\n+      unsigned long       bitnr;\n+      \n+      /* FIXME - this is inefficient! */\n+      for (i = startbit; i <= endbit; i++)\n+\t{\n+\t  p = out + (i / SET_WORD_SIZE);\n+\t  bitnr = i % SET_WORD_SIZE;\n+\t  SET_BIT_IN_WORD (*p, bitnr);\n+\t}\n+    }\n+} "}, {"sha": "94b9266d1b7a7ae7647814dd4a51ca96bd8203a5", "filename": "gcc/ch/runtime/settextindex.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Fsettextindex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Fsettextindex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fsettextindex.c?ref=80a093b29e752ac54172945174c7cd59cec1fd05", "patch": "@@ -0,0 +1,38 @@\n+/* Implement Input/Output runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"fileio.h\"\n+\n+void\n+__settextindex( Text_Mode*  the_text,\n+                signed long the_text_index, \n+                char*       file,\n+                int         line )\n+{\n+  if( !the_text )\n+    CHILLEXCEPTION( file, line, EMPTY, NULL_TEXT );\n+\n+  if( the_text_index < 0 \n+      || the_text->access_sub->reclength - 2 < the_text_index )\n+    CHILLEXCEPTION( file, line, TEXTFAIL, BAD_TEXTINDEX );\n+  \n+  the_text->actual_index = the_text_index;\n+}\n+"}, {"sha": "69810b3f076299a4fc15fdc9ecbef46bac1236e0", "filename": "gcc/ch/runtime/variable.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Fvariable.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Fvariable.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fvariable.c?ref=80a093b29e752ac54172945174c7cd59cec1fd05", "patch": "@@ -0,0 +1,31 @@\n+/* Implement Input/Output runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"fileio.h\"\n+\n+Boolean\n+__variable( Association_Mode* the_assoc, char* file, int line )\n+{\n+  if( !the_assoc )\n+    CHILLEXCEPTION( file, line, EMPTY, NULL_ASSOCIATION );\n+  if( !TEST_FLAG(the_assoc, IO_ISASSOCIATED) )\n+    CHILLEXCEPTION( file, line, NOTASSOCIATED, IS_NOT_ASSOCIATED );\n+  return TEST_FLAG( the_assoc, IO_VARIABLE ) ? True : False;\n+}"}, {"sha": "cf0f5cdb9c5efad6cda20677e7b53346a060c8eb", "filename": "gcc/ch/runtime/writeable.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Fwriteable.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Fruntime%2Fwriteable.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fwriteable.c?ref=80a093b29e752ac54172945174c7cd59cec1fd05", "patch": "@@ -0,0 +1,31 @@\n+/* Implement Input/Output runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"fileio.h\"\n+\n+Boolean\n+__writeable( Association_Mode* the_assoc, char* file, int line )\n+{\n+  if( !the_assoc )\n+    CHILLEXCEPTION( file, line, EMPTY, NULL_ASSOCIATION );\n+  if( !TEST_FLAG(the_assoc, IO_ISASSOCIATED) )\n+    CHILLEXCEPTION( file, line, NOTASSOCIATED, IS_NOT_ASSOCIATED );\n+  return TEST_FLAG(the_assoc, IO_WRITEABLE) ? True : False;\n+}"}, {"sha": "31e0581bc0dc65d8381e5fc6d9c1394daeac9440", "filename": "gcc/ch/tasking.h", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Ftasking.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Ftasking.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Ftasking.h?ref=80a093b29e752ac54172945174c7cd59cec1fd05", "patch": "@@ -0,0 +1,26 @@\n+/* Implement process-related declarations for CHILL.\n+   Copyright (C) 1992, 93, 1994 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#ifndef _CH_TASKING_H\n+#define _CH_TASKING_H\n+\n+/* list of this module's process, buffer, etc. decls */\n+extern tree tasking_list;\n+\n+#endif"}, {"sha": "b1d016873197a63bfd7fdf6e1cfeb8e760814830", "filename": "gcc/ch/tree.c", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a093b29e752ac54172945174c7cd59cec1fd05/gcc%2Fch%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Ftree.c?ref=80a093b29e752ac54172945174c7cd59cec1fd05", "patch": "@@ -0,0 +1,293 @@\n+/* Language-dependent node constructors for parse phase of GNU compiler.\n+   Copyright (C) 1992, 93, 1994  Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"config.h\"\n+#include \"obstack.h\"\n+#include \"tree.h\"\n+#include \"ch-tree.h\"\n+\n+/* Here is how primitive or already-canonicalized types' \n+   hash codes are made.  */\n+#define TYPE_HASH(TYPE) ((HOST_WIDE_INT) (TYPE) & 0777777)\n+\n+extern void error PROTO((char *, ...));\n+extern int  get_type_precision PROTO((tree, tree));\n+\n+extern struct obstack permanent_obstack;\n+/* This is special sentinel used to communicate from build_string_type\n+   to layout_chill_range_type for the index range of a string. */\n+tree string_index_type_dummy;\n+\f\n+/* Build a chill string type.\n+   For a character string, ELT_TYPE==char_type_node; \n+   for a bit-string, ELT_TYPE==boolean_type_node. */\n+\n+tree\n+build_string_type (elt_type, length)\n+     tree elt_type;\n+     tree length;\n+{\n+  register tree t;\n+\n+  if (TREE_CODE (elt_type) == ERROR_MARK || TREE_CODE (length) == ERROR_MARK)\n+    return error_mark_node;\n+\n+  /* Allocate the array after the pointer type,\n+     in case we free it in type_hash_canon.  */\n+\n+  if (pass > 0 && TREE_CODE (length) == INTEGER_CST\n+      && ! tree_int_cst_equal (length, integer_zero_node)\n+      && compare_int_csts (LT_EXPR, TYPE_MAX_VALUE (chill_unsigned_type_node),\n+\t\t\t   length))\n+    {\n+      error (\"string length > UPPER (UINT)\");\n+      length = integer_one_node;\n+    }\n+\n+  /* Subtract 1 from length to get max index value.\n+     Note we cannot use size_binop for pass 1 expressions. */\n+  if (TREE_CODE (length) == INTEGER_CST || pass != 1)\n+    length = size_binop (MINUS_EXPR, length, integer_one_node);\n+  else\n+    length = build (MINUS_EXPR, sizetype, length, integer_one_node);\n+\n+  t = make_node (elt_type == boolean_type_node ? SET_TYPE : ARRAY_TYPE);\n+  TREE_TYPE (t) = elt_type;\n+\n+  MARK_AS_STRING_TYPE (t);\n+\n+  TYPE_DOMAIN (t) = build_chill_range_type (string_index_type_dummy,\n+\t\t\t\t\t    integer_zero_node, length);\n+  if (pass == 1 && TREE_CODE (length) == INTEGER_CST)\n+    TYPE_DOMAIN (t) = layout_chill_range_type (TYPE_DOMAIN (t), 0);\n+\n+  if (pass != 1\n+      || (TREE_CODE (length) == INTEGER_CST && TYPE_SIZE (elt_type)))\n+    {\n+      if (TREE_CODE (t) == SET_TYPE)\n+\tt = layout_powerset_type (t);\n+      else\n+\tt = layout_chill_array_type (t);\n+    }\n+  return t;\n+}\n+\f\n+tree\n+make_powerset_type (domain)\n+     tree domain;\n+{\n+  tree t = make_node (SET_TYPE);\n+\n+  TREE_TYPE (t) = boolean_type_node;\n+  TYPE_DOMAIN (t) = domain;\n+  \n+  return t;\n+}\n+\n+/* Used to layout both bitstring and powerset types. */\n+\n+tree\n+layout_powerset_type (type)\n+     tree type;\n+{\n+  tree domain = TYPE_DOMAIN (type);\n+\n+  if (! discrete_type_p (domain))\n+    {\n+      error (\"Can only build a powerset from a discrete mode\");\n+      return error_mark_node;\n+    }\n+\n+  if (TREE_CODE (TYPE_MAX_VALUE (domain)) == ERROR_MARK ||\n+      TREE_CODE (TYPE_MIN_VALUE (domain)) == ERROR_MARK)\n+    return error_mark_node;\n+\n+  if (TREE_CODE (TYPE_MAX_VALUE (domain)) != INTEGER_CST\n+      || TREE_CODE (TYPE_MIN_VALUE (domain)) != INTEGER_CST)\n+    {\n+      if (CH_BOOLS_TYPE_P (type))\n+\terror (\"non-constant bitstring size invalid\");\n+      else\n+\terror (\"non-constant powerset size invalid\");\n+      return error_mark_node;\n+    }\n+\n+  if (TYPE_SIZE (type) == 0)\n+    layout_type (type);\n+  return type;\n+}\n+\n+/* Build a SET_TYPE node whose elements are from the set of values\n+   in TYPE.  TYPE must be a discrete mode; we check for that here. */\n+tree\n+build_powerset_type (type)\n+     tree type;\n+{\n+  tree t = make_powerset_type (type);\n+  if (pass != 1)\n+    t = layout_powerset_type (t);\n+  return t;\n+}\n+\n+tree\n+build_bitstring_type (size_in_bits)\n+     tree size_in_bits;\n+{\n+  return build_string_type (boolean_type_node, size_in_bits);\n+}\n+\n+/* Return get_identifier (the concatenations of part1, part2, and part3). */\n+\n+tree\n+get_identifier3 (part1, part2, part3)\n+     char *part1, *part2, *part3;\n+{\n+  char *buf = (char*)\n+    alloca (strlen(part1) + strlen(part2) + strlen(part3) + 1);\n+  sprintf (buf, \"%s%s%s\", part1, part2, part3);\n+  return get_identifier (buf);\n+}\n+\n+/* Build an ALIAS_DECL for the prefix renamed clause:\n+   (OLD_PREFIX -> NEW_PREFIX) ! POSTFIX. */\n+\n+tree\n+build_alias_decl (old_prefix, new_prefix, postfix)\n+     tree old_prefix, new_prefix, postfix;\n+{\n+  tree decl = make_node (ALIAS_DECL);\n+\n+  char *postfix_pointer = IDENTIFIER_POINTER (postfix);\n+  int postfix_length = IDENTIFIER_LENGTH (postfix);\n+  int old_length = old_prefix ? IDENTIFIER_LENGTH(old_prefix) : 0;\n+  int new_length = new_prefix ? IDENTIFIER_LENGTH(new_prefix) : 0;\n+\n+  char *buf = (char*) alloca (old_length + new_length + postfix_length + 3);\n+\n+  /* Convert (OP->NP)!P!ALL to (OP!P->NP!P)!ALL */\n+  if (postfix_length > 1 && postfix_pointer[postfix_length-1] == '*')\n+    {\n+      int chopped_length = postfix_length - 2; /* Without final \"!*\" */\n+      if (old_prefix)\n+\tsprintf (buf, \"%s!%.*s\", IDENTIFIER_POINTER (old_prefix),\n+\t\t chopped_length, postfix_pointer);\n+      else\n+\tsprintf (buf, \"%.*s\", chopped_length, postfix_pointer);\n+      old_prefix = get_identifier (buf);\n+      if (new_prefix)\n+\tsprintf (buf, \"%s!%.*s\", IDENTIFIER_POINTER (new_prefix),\n+\t\t chopped_length, postfix_pointer);\n+      else\n+\tsprintf (buf, \"%.*s\", chopped_length, postfix_pointer);\n+      new_prefix = get_identifier (buf);\n+      postfix = ALL_POSTFIX;\n+    }\n+\n+  DECL_OLD_PREFIX (decl) = old_prefix;\n+  DECL_NEW_PREFIX (decl) = new_prefix;\n+  DECL_POSTFIX (decl) = postfix;\n+\n+  if (DECL_POSTFIX_ALL (decl))\n+    DECL_NAME (decl) = NULL_TREE;\n+  else if (new_prefix == NULL_TREE)\n+    DECL_NAME (decl) = postfix;\n+  else\n+    DECL_NAME (decl) = get_identifier3 (IDENTIFIER_POINTER (new_prefix),\n+\t\t\t\t\t\"!\", IDENTIFIER_POINTER (postfix));\n+\n+  return decl;\n+}\n+\n+/* Return the \"old name string\" of an ALIAS_DECL. */\n+\n+tree\n+decl_old_name (decl)\n+     tree decl;\n+{\n+  \n+  if (DECL_OLD_PREFIX (decl) == NULL_TREE)\n+    return DECL_POSTFIX (decl);\n+  return get_identifier3 (IDENTIFIER_POINTER (DECL_OLD_PREFIX (decl)),\n+\t\t\t  \"!\", IDENTIFIER_POINTER (DECL_POSTFIX (decl)));\n+}\n+\n+/* See if OLD_NAME (an identifier) matches the OLD_PREFIX!POSTFIX\n+   of ALIAS.  If so, return the corresponding NEW_NEW!POSTFIX. */\n+\n+tree\n+decl_check_rename (alias, old_name)\n+     tree alias, old_name;\n+{\n+  char *old_pointer = IDENTIFIER_POINTER (old_name);\n+  int old_len = IDENTIFIER_LENGTH (old_name);\n+  if (DECL_OLD_PREFIX (alias))\n+    {\n+      int old_prefix_len = IDENTIFIER_LENGTH (DECL_OLD_PREFIX (alias));\n+      if (old_prefix_len >= old_len\n+\t  || old_pointer[old_prefix_len] != '!'\n+\t  || strncmp (old_pointer, IDENTIFIER_POINTER (DECL_OLD_PREFIX (alias)), old_prefix_len) != 0)\n+\treturn NULL_TREE;\n+\n+      /* Skip the old prefix. */\n+      old_pointer += old_prefix_len + 1; /* Also skip the '!', */\n+    }\n+  if (DECL_POSTFIX_ALL (alias)\n+      || strcmp (IDENTIFIER_POINTER (DECL_POSTFIX (alias)), old_pointer) == 0)\n+    {\n+      if (DECL_NEW_PREFIX (alias))\n+\treturn get_identifier3 (IDENTIFIER_POINTER (DECL_NEW_PREFIX (alias)),\n+\t\t\t\t\"!\", old_pointer);\n+      else if (old_pointer == IDENTIFIER_POINTER (old_name))\n+\treturn old_name;\n+      else\n+\treturn get_identifier (old_pointer);\n+    }\n+  else\n+    return NULL_TREE;\n+}\n+\n+/* 'EXIT foo' is treated like 'GOTO EXIT!foo'.\n+    This function converts LABEL into a labal name for EXIT. */\n+\n+tree\n+munge_exit_label (label)\n+     tree label;\n+{\n+  return get_identifier3 (\"EXIT\", \"!\", IDENTIFIER_POINTER (label));\n+}\n+\n+/* Make SAVE_EXPRs as needed, but don't turn a location into a non-location. */\n+\n+tree\n+save_if_needed (exp)\n+tree exp;\n+{\n+  return CH_REFERABLE (exp) ? stabilize_reference (exp) : save_expr (exp);\n+}\n+\n+/* Return the number of elements in T, which must be a discrete type. */\n+tree\n+discrete_count (t)\n+     tree t;\n+{\n+  tree hi = convert (sizetype, TYPE_MAX_VALUE (t));\n+  if (TYPE_MIN_VALUE (t))\n+    hi = size_binop (MINUS_EXPR, hi, convert (sizetype, TYPE_MIN_VALUE (t)));\n+  return size_binop (PLUS_EXPR, hi, integer_one_node);\n+}"}]}